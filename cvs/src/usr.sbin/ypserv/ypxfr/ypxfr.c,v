head	1.39;
access;
symbols
	OPENBSD_6_2:1.39.0.10
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.39.0.12
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.8
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.4
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.39.0.6
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.37.0.22
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.37.0.20
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.37.0.16
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.14
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.12
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.10
	OPENBSD_5_0:1.37.0.8
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.6
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.4
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.36.0.8
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.4
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.35.0.6
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.35.0.4
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.35.0.2
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.34.0.2
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.33.0.4
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.32.0.4
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.32.0.2
	OPENBSD_3_6_BASE:1.32
	OPENBSD_3_5:1.31.0.4
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	OPENBSD_3_3:1.29.0.4
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	OPENBSD_3_0:1.25.0.4
	OPENBSD_3_0_BASE:1.25
	OPENBSD_2_9_BASE:1.25
	OPENBSD_2_9:1.25.0.2
	OPENBSD_2_8:1.24.0.12
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.24.0.10
	OPENBSD_2_7_BASE:1.24
	OPENBSD_2_6:1.24.0.8
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.24.0.6
	OPENBSD_2_5_BASE:1.24
	OPENBSD_2_4:1.24.0.4
	OPENBSD_2_4_BASE:1.24
	OPENBSD_2_3:1.24.0.2
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.22.0.2
	OPENBSD_2_2_BASE:1.22
	OPENBSD_2_1:1.20.0.2
	OPENBSD_2_1_BASE:1.20
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9;
locks; strict;
comment	@ * @;


1.39
date	2015.02.09.23.00.15;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	822YD61EeG0Xl9Na;

1.38
date	2015.01.16.06.40.23;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	Uu5nFG3wCl0LACBb;

1.37
date	2009.10.27.23.59.58;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.01.21.45.08;	author sobrado;	state Exp;
branches;
next	1.35;

1.35
date	2006.09.25.05.59.28;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2006.04.03.05.01.24;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.14.02.32.33;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2004.07.08.06.20.46;	author matthieu;	state Exp;
branches;
next	1.31;

1.31
date	2003.07.15.06.10.46;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.02.21.58.27;	author maja;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.19.20.59.40;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.19.02.38.40;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.26.09.35.22;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.07.19.01.29;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.05.14.47.17;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	98.02.14.10.05.27;	author maja;	state Exp;
branches;
next	1.23;

1.23
date	98.01.08.22.36.49;	author maja;	state Exp;
branches;
next	1.22;

1.22
date	97.07.30.12.07.02;	author maja;	state Exp;
branches;
next	1.21;

1.21
date	97.07.26.12.02.20;	author maja;	state Exp;
branches;
next	1.20;

1.20
date	97.05.22.08.05.30;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.05.01.22.14.48;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	97.05.01.17.49.45;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	97.04.12.16.37.37;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.04.12.00.12.58;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.02.09.09.49.37;	author maja;	state Exp;
branches;
next	1.14;

1.14
date	97.02.08.19.58.51;	author maja;	state Exp;
branches;
next	1.13;

1.13
date	97.02.07.09.24.03;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.02.03.12.15.59;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.01.15.23.44.35;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	96.12.24.19.28.03;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.10.01.01.53.08;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.09.30.20.50.25;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	96.08.15.22.16.31;	author chuck;	state Exp;
branches;
next	1.6;

1.6
date	96.05.30.09.53.35;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.03.02.04.55.02;	author dm;	state Exp;
branches;
next	1.4;

1.4
date	96.03.02.03.42.06;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	96.03.02.03.01.49;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.01.20.00.38.49;	author chuck;	state Exp;
branches;
next	1.1;

1.1
date	95.11.01.16.56.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.39
log
@clean up flags++ instances around getopt()
ok florian
@
text
@/*	$OpenBSD: ypxfr.c,v 1.38 2015/01/16 06:40:23 deraadt Exp $ */

/*
 * Copyright (c) 1994 Mats O Jansson <moj@@stacken.kth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <netdb.h>

#include <rpc/rpc.h>
#include <rpc/xdr.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>

#include "yplib_host.h"
#include "yplog.h"
#include "ypdb.h"
#include "ypdef.h"

DBM	*db;

static int
ypxfr_foreach(u_long status, char *keystr, int keylen, char *valstr, int vallen,
    void *data)
{
	datum key, val;

	if (status == YP_NOMORE)
		return(0);

	keystr[keylen] = '\0';
	valstr[vallen] = '\0';

	key.dptr = keystr;
	key.dsize = strlen(keystr);

	val.dptr = valstr;
	val.dsize = strlen(valstr);

	ypdb_store(db, key, val, YPDB_INSERT);
	return 0;
}

static int
get_local_ordernum(char *domain, char *map, u_int32_t *lordernum)
{
	char map_path[PATH_MAX], order[MAX_LAST_LEN+1];
	char order_key[] = YP_LAST_KEY;
	struct stat finfo;
	datum k, v;
	int status;
	DBM *db;

	/* This routine returns YPPUSH_SUCC or YPPUSH_NODOM */

	status = YPPUSH_SUCC;

	snprintf(map_path, sizeof map_path, "%s/%s", YP_DB_PATH, domain);
	if (!((stat(map_path, &finfo) == 0) && S_ISDIR(finfo.st_mode))) {
		fprintf(stderr, "ypxfr: domain %s not found locally\n",
		    domain);
		status = YPPUSH_NODOM;
		goto bail;
	}

	snprintf(map_path, sizeof map_path, "%s/%s/%s%s",
	    YP_DB_PATH, domain, map, YPDB_SUFFIX);
	if (!(stat(map_path, &finfo) == 0)) {
		status = YPPUSH_NOMAP;
		goto bail;
	}

	snprintf(map_path, sizeof map_path, "%s/%s/%s",
	    YP_DB_PATH, domain, map);
	db = ypdb_open(map_path, O_RDONLY, 0444);
	if (db == NULL) {
		status = YPPUSH_DBM;
		goto bail;
	}

	k.dptr = (char *)&order_key;
	k.dsize = YP_LAST_LEN;

	v = ypdb_fetch(db, k);

	if (v.dptr == NULL) {
		*lordernum = 0;
	} else {
		strlcpy(order, v.dptr, sizeof order);
		*lordernum = (u_int32_t)atol(order);
	}

	ypdb_close(db);
bail:
	if (status == YPPUSH_NOMAP || status == YPPUSH_DBM) {
		*lordernum = 0;
		status = YPPUSH_SUCC;
	}
	return (status);

}

static int
get_remote_ordernum(CLIENT *client, char *domain, char *map,
    u_int32_t lordernum, u_int32_t *rordernum)
{
	int status;

	status = yp_order_host(client, domain, map, rordernum);

	if (status == 0) {
		if (*rordernum <= lordernum)
			status = YPPUSH_AGE;
		else
			status = YPPUSH_SUCC;
	}
	return status;
}

static int
get_map(CLIENT *client, char *domain, char *map,
    struct ypall_callback *incallback)
{
	int	status;

	status = yp_all_host(client, domain, map, incallback);
	if (status == 0 || status == YPERR_NOMORE)
		status = YPPUSH_SUCC;
	else
		status = YPPUSH_YPERR;
	return (status);
}

static DBM *
create_db(char *domain, char *map, char *temp_map)
{
	return ypdb_open_suf(temp_map, O_RDWR, 0444);
}

static int
install_db(char *domain, char *map, char *temp_map)
{
	char	db_name[PATH_MAX];

	snprintf(db_name, sizeof db_name, "%s/%s/%s%s",
	    YP_DB_PATH, domain, map, YPDB_SUFFIX);
	rename(temp_map, db_name);
	return YPPUSH_SUCC;
}

static int
add_order(DBM *db, u_int32_t ordernum)
{
	char	datestr[11];
	datum	key, val;
	char	keystr[] = YP_LAST_KEY;
	int	status;

	snprintf(datestr, sizeof datestr, "%010u", ordernum);

	key.dptr = keystr;
	key.dsize = strlen(keystr);

	val.dptr = datestr;
	val.dsize = strlen(datestr);

	status = ypdb_store(db, key, val, YPDB_INSERT);
	if (status >= 0)
		status = YPPUSH_SUCC;
	else
		status = YPPUSH_DBM;
	return (status);
}

static int
add_master(CLIENT *client, char *domain, char *map, DBM *db)
{
	char	keystr[] = YP_MASTER_KEY, *master = NULL;
	datum	key, val;
	int	status;

	/* Get MASTER */
	status = yp_master_host(client, domain, map, &master);

	if (master != NULL) {
		key.dptr = keystr;
		key.dsize = strlen(keystr);

		val.dptr = master;
		val.dsize = strlen(master);

		status = ypdb_store(db, key, val, YPDB_INSERT);
		if (status >= 0)
			status = YPPUSH_SUCC;
		else
			status = YPPUSH_DBM;
	}
	return (status);
}

static int
add_interdomain(CLIENT *client, char *domain, char *map, DBM *db)
{
	char	keystr[] = YP_INTERDOMAIN_KEY, *value;
	int	vallen, status;
	datum	k, v;

	/* Get INTERDOMAIN */

	k.dptr = keystr;
	k.dsize = strlen(keystr);

	status = yp_match_host(client, domain, map,
	    k.dptr, k.dsize, &value, &vallen);
	if (status == 0 && value) {
		v.dptr = value;
		v.dsize = vallen;

		if (v.dptr != NULL) {
			status = ypdb_store(db, k, v, YPDB_INSERT);
			if (status >= 0)
				status = YPPUSH_SUCC;
			else
				status = YPPUSH_DBM;
		}
	}
	return 1;
}

static int
add_secure(CLIENT *client, char *domain, char *map, DBM *db)
{
	char	keystr[] = YP_SECURE_KEY, *value;
	int	vallen, status;
	datum	k, v;

	/* Get SECURE */

	k.dptr = keystr;
	k.dsize = strlen(keystr);

	status = yp_match_host(client, domain, map,
	    k.dptr, k.dsize, &value, &vallen);
	if (status == 0 && value) {
		v.dptr = value;
		v.dsize = vallen;

		if (v.dptr != NULL) {
			status = ypdb_store(db, k, v, YPDB_INSERT);
			if (status >= 0)
				status = YPPUSH_SUCC;
			else
				status = YPPUSH_DBM;
		}
	}
	return status;
}

static int
send_clear(CLIENT *client)
{
	struct	timeval tv;
	int	status, r;

	status = YPPUSH_SUCC;

	tv.tv_sec = 10;
	tv.tv_usec = 0;

	/* Send CLEAR */
	r = clnt_call(client, YPPROC_CLEAR, xdr_void, 0, xdr_void, 0, tv);
	if (r != RPC_SUCCESS)
		clnt_perror(client, "yp_clear: clnt_call");
	return status;

}

static int
send_reply(CLIENT *client, u_long status, u_long tid)
{
	struct	ypresp_xfr resp;
	struct	timeval tv;
	int	r;

	tv.tv_sec = 10;
	tv.tv_usec = 0;

	resp.transid = tid;
	resp.xfrstat = status;

	/* Send CLEAR */
	r = clnt_call(client, 1, xdr_ypresp_xfr, &resp, xdr_void, 0, tv);
	if (r != RPC_SUCCESS)
		clnt_perror(client, "yppushresp_xdr: clnt_call");
	return status;

}

static void
usage(void)
{
	fprintf(stderr,
	    "usage: ypxfr [-cf] [-C tid prog ipadd port] [-d domain] "
	    "[-h host] [-s domain]\n"
	    "             mapname\n");
	exit(1);
}

int
main(int argc, char *argv[])
{
	int	 cflag = 0, fflag = 0, Cflag = 0;
	char	 *domain, *host = NULL, *srcdomain = NULL;
	char	 *tid = NULL, *prog = NULL, *ipadd = NULL;
	char	 *port = NULL, *map = NULL;
	int	 status, xfr_status, ch, srvport;
	u_int32_t ordernum, new_ordernum;
	struct	 ypall_callback callback;
	CLIENT   *client = NULL;
	extern	 char *optarg;

	yp_get_default_domain(&domain);

	while ((ch = getopt(argc, argv, "cd:fh:s:C:")) != -1)
		switch (ch) {
		case 'c':
			cflag = 1;
			break;
		case 'd':
			if (strchr(optarg, '/')) /* Ha ha, we are not listening */
				break;
			domain = optarg;
			break;
		case 'f':
			fflag = 1;
			break;
		case 'h':
			host = optarg;
			break;
		case 's':
			if (strchr(optarg, '/')) /* Ha ha, we are not listening */
				break;
			srcdomain = optarg;
			break;
		case 'C':
			if (optind + 3 >= argc)
				usage();
			Cflag = 1;
			tid = optarg;
			prog = argv[optind++];
			ipadd = argv[optind++];
			port = argv[optind++];
			break;
		default:
			usage();
			break;
		}

	status = YPPUSH_SUCC;

	if (optind + 1 != argc)
		usage();

	map = argv[optind];

	if (status > 0) {
		ypopenlog();

		yplog("ypxfr: Arguments:");
		yplog("YP clear to local: %s", (cflag) ? "no" : "yes");
		yplog("   Force transfer: %s", (fflag) ? "yes" : "no");
		yplog("           domain: %s", domain);
		yplog("             host: %s", host);
		yplog("    source domain: %s", srcdomain);
		yplog("          transid: %s", tid);
		yplog("             prog: %s", prog);
		yplog("             port: %s", port);
		yplog("            ipadd: %s", ipadd);
		yplog("              map: %s", map);

		if (fflag != 0) {
			ordernum = 0;
		} else {
			status = get_local_ordernum(domain, map, &ordernum);
		}
	}

	if (status > 0) {
		yplog("Get Master");

		if (host == NULL) {
			if (srcdomain == NULL) {
				status = yp_master(domain, map, &host);
			} else {
				status = yp_master(srcdomain, map, &host);
			}
			if (status == 0) {
				status = YPPUSH_SUCC;
			} else {
				status = -status;
			}
		}
	}

	/* XXX this is raceable if portmap has holes! */
	if (status > 0) {
		yplog("Check for reserved port on host: %s", host);

		srvport = getrpcport(host, YPPROG, YPVERS, IPPROTO_TCP);
		if (srvport >= IPPORT_RESERVED)
			status = YPPUSH_REFUSED;
	}

	if (status > 0) {
		yplog("Connect host: %s", host);

		client = yp_bind_host(host, YPPROG, YPVERS, 0, 1);

		status = get_remote_ordernum(client, domain, map,
		    ordernum, &new_ordernum);
	}

	if (status == YPPUSH_SUCC) {
		char	tmpmapname[PATH_MAX];
		int	fd;

		/* Create temporary db */
		snprintf(tmpmapname, sizeof tmpmapname,
		    "%s/%s/ypdbXXXXXXXXXX", YP_DB_PATH, domain);
		fd = mkstemp(tmpmapname);
		if (fd == -1)
			status = YPPUSH_DBM;
		else
			close(fd);

		if (status > 0) {
			db = create_db(domain, map, tmpmapname);
			if (db == NULL)
				status = YPPUSH_DBM;
		}

		/* Add ORDER */
		if (status > 0)
			status = add_order(db, new_ordernum);

		/* Add MASTER */
		if (status > 0)
			status = add_master(client, domain, map, db);

		/* Add INTERDOMAIN */
		if (status > 0)
			status = add_interdomain(client, domain, map, db);

		/* Add SECURE */
		if (status > 0)
			status = add_secure(client, domain, map, db);

		if (status > 0) {
			callback.foreach = ypxfr_foreach;
			status = get_map(client, domain, map, &callback);
		}

		/* Close db */
		if (db != NULL)
			ypdb_close(db);

		/* Rename db */
		if (status > 0) {
			status = install_db(domain, map, tmpmapname);
		} else {
			unlink(tmpmapname);
			status = YPPUSH_SUCC;
		}
	}

	xfr_status = status;

	if (client != NULL)
		clnt_destroy(client);

	/* YP_CLEAR */

	if (!cflag) {
		client = yp_bind_local(YPPROG, YPVERS);
		status = send_clear(client);
		clnt_destroy(client);
	}

	if (Cflag > 0) {
		/* Send Response */
		client = yp_bind_host(ipadd, atoi(prog), 1, atoi(port), 0);
		status = send_reply(client, xfr_status, atoi(tid));
		clnt_destroy(client);
	}
	return (0);
}
@


1.38
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.37 2009/10/27 23:59:58 deraadt Exp $ */
d360 1
a360 1
			cflag++;
d368 1
a368 1
			fflag++;
d381 1
a381 1
			Cflag++;
@


1.37
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.36 2008/06/01 21:45:08 sobrado Exp $ */
d80 1
a80 1
	char map_path[MAXPATHLEN], order[MAX_LAST_LEN+1];
d176 1
a176 1
	char	db_name[MAXPATHLEN];
d457 1
a457 1
		char	tmpmapname[MAXPATHLEN];
@


1.36
log
@sort flags; synchronize synopsis and usage; style(9).

tweaked by jmc@@, thanks!

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.35 2006/09/25 05:59:28 otto Exp $ */
a27 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: ypxfr.c,v 1.35 2006/09/25 05:59:28 otto Exp $";
#endif
@


1.35
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which leads to surprising results. Spotted by
from Paul Stoeber, more to come. ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.34 2006/04/03 05:01:24 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypxfr.c,v 1.34 2006/04/03 05:01:24 deraadt Exp $";
d339 4
a342 2
	fprintf(stderr, "usage: ypxfr [-cf] [-d domain] [-h host] [-s domain] "
	    "[-C tid prog ipadd port] mapname\n");
@


1.34
log
@spreading the lint love (very minimal things..)
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.33 2005/05/14 02:32:33 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypxfr.c,v 1.33 2005/05/14 02:32:33 deraadt Exp $";
d96 1
a96 2
	if (!((stat(map_path, &finfo) == 0) &&
	    ((finfo.st_mode & S_IFMT) == S_IFDIR))) {
@


1.33
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.32 2004/07/08 06:20:46 matthieu Exp $ */
d29 2
a30 2
#ifndef LINT
static const char rcsid[] = "$OpenBSD: ypxfr.c,v 1.32 2004/07/08 06:20:46 matthieu Exp $";
@


1.32
log
@Don't close the database too early. ok deraadt@@, millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.31 2003/07/15 06:10:46 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypxfr.c,v 1.31 2003/07/15 06:10:46 deraadt Exp $";
d216 1
a216 1
	char	keystr[] = YP_MASTER_KEY, *master;
a219 2
	master = NULL;

a220 1

@


1.31
log
@protos and repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.30 2003/06/02 21:58:27 maja Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypxfr.c,v 1.30 2003/06/02 21:58:27 maja Exp $";
a122 1
	ypdb_close(db);
d131 1
@


1.30
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.29 2002/07/19 20:59:40 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypxfr.c,v 1.29 2002/07/19 20:59:40 deraadt Exp $";
d81 1
a81 1
int
d141 1
a141 1
int
d158 1
a158 1
int
d172 1
a172 1
DBM *
d178 1
a178 1
int
d189 1
a189 1
int
d213 1
a213 1
int
d242 1
a242 1
int
d271 1
a271 1
int
d300 1
a300 1
int
d319 1
a319 1
int
d340 1
a340 1
void
@


1.29
log
@bunch more careful tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.28 2002/07/19 02:38:40 deraadt Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypxfr.c,v 1.28 2002/07/19 02:38:40 deraadt Exp $";
@


1.28
log
@4344 lines of KNF diff
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.27 2002/03/26 09:35:22 fgsch Exp $ */
d35 1
a35 1
static const char rcsid[] = "$OpenBSD: ypxfr.c,v 1.27 2002/03/26 09:35:22 fgsch Exp $";
a61 1
extern char *__progname;		/* from crt0.o */
a63 5
extern bool_t xdr_ypresp_all_seq();

extern int (*ypresp_allfn)();
extern void *ypresp_data;

d103 2
a104 2
		fprintf(stderr, "%s: domain %s not found locally\n",
		    __progname, domain);
d127 1
a127 1
	v = ypdb_fetch(db,k);
d170 1
a170 1
	if ((status == 0) || (status == YPERR_NOMORE)) {
d172 1
a172 1
	} else {
a173 1
	}
d221 2
a222 2
	char	keystr[] = YP_MASTER_KEY;
	char	*master;
a223 1
	datum	key, val;
d250 2
a251 4
	char	keystr[] = YP_INTERDOMAIN_KEY;
	char	*value;
	int	vallen;
	int	status;
a272 1

d296 1
a296 1
			if (status >= 0) {
d298 1
a298 1
			} else {
a299 1
			}
a301 1

a302 1

d327 1
a328 1
	struct	ypresp_xfr resp;
d345 8
d356 1
a356 1
	int	 usage = 0, cflag = 0, fflag = 0, Cflag = 0;
d363 1
a363 1
	CLIENT   *client;
a365 4
	status = YPPUSH_SUCC;
	client = NULL;
	db = NULL;

d390 2
a391 5
			if (optind + 3 >= argc) {
				usage++;
				optind = argc;
				break;
			}
d399 1
a399 1
			usage++;
d403 4
a406 5
	if (optind + 1 != argc) {
		usage++;
	} else {
		map = argv[optind];
	}
d408 1
a408 7
	if (usage) {
		status = YPPUSH_BADARGS;
		fprintf(stderr, "usage: %s "
		    "[-cf] [-d domain] [-h host] [-s domain] "
		    "[-C tid prog ipadd port] mapname\n",
		    __progname);
	}
a538 1

a539 1

@


1.27
log
@o -Wall cleanup.
o fix usage.
o don't call ypdb_cloes() if db is never open.

maja@@ pval@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.26 2001/11/07 19:01:29 deraadt Exp $ */
d35 1
a35 1
static const char rcsid[] = "$OpenBSD: ypxfr.c,v 1.26 2001/11/07 19:01:29 deraadt Exp $";
d71 2
a72 3
ypxfr_foreach(status, keystr, keylen, valstr, vallen, data)
int status, keylen, vallen;
char *keystr, *valstr, *data;
d74 1
a74 1
	datum	key, val;
a88 1

d93 1
a93 4
get_local_ordernum(domain, map, lordernum)
char *domain;
char *map;
u_int32_t *lordernum;
d95 1
a95 1
	char map_path[MAXPATHLEN];
a96 1
	char order[MAX_LAST_LEN+1];
a97 1
	DBM *db;
d100 1
d112 1
d115 5
a119 5
	if (status > 0) {
		snprintf(map_path, sizeof map_path, "%s/%s/%s%s",
		    YP_DB_PATH, domain, map, YPDB_SUFFIX);
		if (!(stat(map_path, &finfo) == 0))
			status = YPPUSH_NOMAP;
d122 6
a127 6
	if (status > 0) {
		snprintf(map_path, sizeof map_path, "%s/%s/%s",
		    YP_DB_PATH, domain, map);
		db = ypdb_open(map_path, O_RDONLY, 0444);
		if (db == NULL)
			status = YPPUSH_DBM;
d130 2
a131 3
	if (status > 0) {
		k.dptr = (char *)&order_key;
		k.dsize = YP_LAST_LEN;
d133 2
a134 2
		v = ypdb_fetch(db,k);
		ypdb_close(db);
d136 5
a140 6
		if (v.dptr == NULL) {
			*lordernum = 0;
		} else {
	        	strlcpy(order, v.dptr, sizeof order);
			*lordernum = (u_int32_t)atol(order);
		}
d143 1
d148 1
a148 1
	return(status);
d153 2
a154 6
get_remote_ordernum(client, domain, map, lordernum, rordernum)
CLIENT *client;
char *domain;
char *map;
u_int32_t lordernum;
u_int32_t *rordernum;
d170 2
a171 5
get_map(client,domain,map,incallback)
CLIENT *client;
char *domain;
char *map;
struct ypall_callback *incallback;
d181 1
a181 2

	return(status);
d185 1
a185 4
create_db(domain,map,temp_map)
char *domain;
char *map;
char *temp_map;
d191 1
a191 4
install_db(domain,map,temp_map)
char *domain;
char *map;
char *temp_map;
a197 1

d202 1
a202 3
add_order(db, ordernum)
DBM *db;
u_int32_t ordernum;
d218 1
a218 1
	if (status >= 0) {
d220 1
a220 1
	} else {
d222 1
a222 2
	}
	return(status);
d226 1
a226 5
add_master(client, domain, map, db)
CLIENT *client;
char *domain;
char *map;
DBM *db;
d247 1
a247 1
		if (status >= 0) {
d249 1
a249 1
		} else {
a250 1
		}
d252 1
a252 1
	return status;
d256 1
a256 5
add_interdomain(client, domain, map, db)
CLIENT *client;
char *domain;
char *map;
DBM *db;
d277 1
a277 1
			if (status >= 0) {
d279 1
a279 1
			} else {
a280 1
			}
d288 1
a288 5
add_secure(client, domain, map, db)
CLIENT *client;
char *domain;
char *map;
DBM *db;
d290 2
a291 4
	char	keystr[] = YP_SECURE_KEY;
	char	*value;
	int	vallen;
	int	status;
d320 1
a320 2
send_clear(client)
CLIENT *client;
d323 1
a323 2
	int	r;
	int	status;
d339 1
a339 4
send_reply(client,status,tid)
CLIENT *client;
u_long	status;
u_long  tid;
d360 7
a366 18
main (argc,argv)
int argc;
char *argv[];
{
	int	 usage = 0;
	int	 cflag = 0;
	int	 fflag = 0;
	int	 Cflag = 0;
	int	 ch;
	extern	 char *optarg;
	char	 *domain;
	char	 *host = NULL;
	char	 *srcdomain = NULL;
	char	 *tid = NULL;
	char	 *prog = NULL;
	char	 *ipadd = NULL;
	char	 *port = NULL;
	char	 *map = NULL;
d370 1
a370 2
	int	 status, xfr_status;
	int	 srvport;
d453 1
a453 1
	        yplog("Get Master");
d458 1
a458 1
		        } else {
d471 1
a471 1
	        yplog("Check for reserved port on host: %s", host);
d479 1
a479 1
	        yplog("Connect host: %s", host);
d506 1
a506 1
	  	/* Add ORDER */
d514 1
a514 1
	        /* Add INTERDOMAIN */
d518 1
a518 1
	        /* Add SECURE */
d560 1
a560 1
	return(0);
a562 1

@


1.26
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.25 2001/02/05 14:47:17 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.25 2001/02/05 14:47:17 deraadt Exp $";
d431 1
d481 2
a482 2
		fprintf(stderr, "usage: %s %s %s\n",
		    "[-cf] [-d domain] [-h host] [-s domain]",
@


1.25
log
@sprintf purge
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.24 1998/02/14 10:05:27 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.24 1998/02/14 10:05:27 maja Exp $";
d71 3
a73 3
ypxfr_foreach(status,keystr,keylen,valstr,vallen,data)
int status,keylen,vallen;
char *keystr,*valstr,*data;
d75 1
a75 1
	datum	key,val;
d88 1
a88 1
	
d105 1
a105 1
	datum k,v;
d109 1
a109 1
	
d111 1
a111 1
	
d114 1
a114 1
	      ((finfo.st_mode & S_IFMT) == S_IFDIR))) {
d120 1
a120 1
	if(status > 0) {
d123 1
a123 1
		if(!(stat(map_path, &finfo) == 0)) {
a124 1
		}
d126 2
a127 2
	
	if(status > 0) {
d131 1
a131 1
		if(db == NULL) {
a132 2
		}
		
d134 2
a135 2
		
	if(status > 0) {
d141 1
a141 1
		
d145 1
a145 2
	        	strncpy(order, v.dptr, sizeof order-1);
			order[sizeof order-1] = '\0';
d150 1
a150 1
	if((status == YPPUSH_NOMAP) || (status == YPPUSH_DBM)) {
a153 1

d171 1
a171 1
		if(*rordernum <= lordernum) {
d173 1
a173 1
		} else {
d175 1
a175 3
		}
	} 

d228 1
a228 1
	datum	key,val;
d236 1
a236 1
	
d239 1
a239 1
	
d241 1
a241 1
	if(status >= 0) {
d259 1
a259 1
	datum	key,val;
d266 14
a279 14
	
	if(master != NULL) {
	  key.dptr = keystr;
	  key.dsize = strlen(keystr);
	  
	  val.dptr = master;
	  val.dsize = strlen(master);
	
	  status = ypdb_store(db, key, val, YPDB_INSERT);
	  if(status >= 0) {
	  	status = YPPUSH_SUCC;
	  } else {
	  	status = YPPUSH_DBM;
	  }
a280 1

d295 1
a295 1
	datum	k,v;
d303 2
a304 3
			       k.dptr, k.dsize, &value, &vallen);
	
	if(status == 0 && value) {
d307 4
a310 4
		
		if(v.dptr != NULL) {
			status = ypdb_store(db,k,v,YPDB_INSERT);
			if(status >= 0) {
d332 1
a332 1
	datum	k,v;
d340 2
a341 3
			       k.dptr, k.dsize, &value, &vallen);
	
	if(status == 0 && value) {
d344 4
a347 4
		
		if(v.dptr != NULL) {
			status = ypdb_store(db,k,v,YPDB_INSERT);
			if(status >= 0) {
d373 2
a374 4

	r = clnt_call(client, YPPROC_CLEAR,
		      xdr_void, 0, xdr_void, 0, tv);
	if(r != RPC_SUCCESS) {
a375 2
	}

d397 2
a398 4

	r = clnt_call(client, 1,
		      xdr_ypresp_xfr, &resp, xdr_void, 0, tv);
	if(r != RPC_SUCCESS) {
a399 2
	}

d426 1
a426 1
	int	 status,xfr_status;
d428 1
a428 1
	
d435 38
a472 22
	  switch (ch) {
	  case 'c':
	    cflag++;
	    break;
	  case 'd':
	    if (strchr(optarg, '/'))	/* Ha ha, we are not listening */
		break;
	    domain = optarg;
	    break;
	  case 'f':
	    fflag++;
	    break;
	  case 'h':
	    host = optarg;
	    break;
	  case 's':
	    if (strchr(optarg, '/'))	/* Ha ha, we are not listening */
		break;
	    srcdomain = optarg;
	    break;
	  case 'C':
	    if (optind + 3 >= argc) {
a473 16
		optind = argc;
		break;
	    }
	    Cflag++;
	    tid = optarg;
	    prog = argv[optind++];
	    ipadd = argv[optind++];
	    port = argv[optind++];
	    break;
	  default:
	    usage++;
	    break;
	  }

	if(optind + 1 != argc) {
	  usage++;
d475 1
a475 1
	  map = argv[optind];
d492 1
a492 1
		yplog("           domain: %s", domain); 
d501 1
a501 1
		if(fflag != 0) {
a508 1

d513 1
a513 1
				status = yp_master(domain,map,&host);
d515 1
a515 1
				status = yp_master(srcdomain,map,&host);
d517 1
a517 1
			if(status == 0) {
d523 1
a523 1
	};
d527 1
a527 2
		
	        yplog("Check for reserved port on host: %s", host); 
d529 1
a529 1
		srvport = getrpcport(host,YPPROG,YPVERS,IPPROTO_TCP);
a531 1
		
d535 1
a535 2
	  	
	        yplog("Connect host: %s", host); 
d537 1
a537 1
		client = yp_bind_host(host,YPPROG,YPVERS,0,1);
d540 1
a540 2
					     ordernum, &new_ordernum);
		
d557 2
a558 2
			db = create_db(domain,map,tmpmapname);
			if(db == NULL)
d563 1
a563 1
		if(status > 0) {
d565 1
a565 2
		}
		
d567 3
a569 4
		if(status > 0) {
			status = add_master(client,domain,map,db);
		}
		
d571 3
a573 4
		if(status > 0) {
			status = add_interdomain(client,domain,map,db);
		}
		
d575 6
a580 2
		if(status > 0) {
			status = add_secure(client,domain,map,db);
d582 1
a582 6
		
		if(status > 0) {
			callback.foreach=ypxfr_foreach;
			status = get_map(client,domain,map,&callback);
		}
		
d584 1
a584 1
		if(db != NULL) {
a585 1
		}
d588 2
a589 2
		if(status > 0) {
			status = install_db(domain,map,tmpmapname);
a593 1
		
d595 1
a595 1
	
d598 1
a598 1
	if(client != NULL) {
a599 1
	}
d603 2
a604 2
	if(!cflag) {
		client = yp_bind_local(YPPROG,YPVERS);
d609 1
a609 1
	if(Cflag > 0) {
d611 2
a612 6
		client = yp_bind_host(ipadd,
				      atoi(prog),
				      1,
				      atoi(port),
				      0);
		status = send_reply(client,xfr_status,atoi(tid));
@


1.24
log
@Don't install a new map if yp_all failed. Noticed by Theo. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.23 1998/01/08 22:36:49 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.23 1998/01/08 22:36:49 maja Exp $";
d239 1
a239 1
	sprintf(datestr, "%010u", ordernum);
@


1.23
log
@Fix some problems with xfr of secure maps. Problem reported by
Eric Rungi <rungus@@openface.org> -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.22 1997/07/30 12:07:02 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.22 1997/07/30 12:07:02 maja Exp $";
d186 1
a186 1
void
d193 10
a202 2
	(void)yp_all_host(client, domain, map, incallback);
		
d607 1
a607 1
			get_map(client,domain,map,&callback);
@


1.22
log
@Get ypxfr working again by remove some of the code from previous commit. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.21 1997/07/26 12:02:20 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.21 1997/07/26 12:02:20 maja Exp $";
d343 1
a343 1
	if(status > 0) {
@


1.21
log
@bugs killed in NetBSD by thorpej.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.20 1997/05/22 08:05:30 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.20 1997/05/22 08:05:30 deraadt Exp $";
d203 1
a203 1
	return ypdb_open_suf(temp_map, O_RDWR|O_CREAT|O_EXCL, 0444);
@


1.20
log
@getopt returns int
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.19 1997/05/01 22:14:48 niklas Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.19 1997/05/01 22:14:48 niklas Exp $";
d54 1
a55 1
#include <rpcsvc/yp.h>
d62 1
a62 1
extern char *__progname;
d72 2
a73 2
int status,keylen,vallen,*data;
char *keystr,*valstr;
d77 1
a77 1
	if (status == 2)
d203 1
a203 1
	return ypdb_open_suf(temp_map, O_RDWR, 0444);
@


1.19
log
@Umm, fix signedness error in my last commit, be explicit
about the fact that ordernumbers are 32 bit
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.18 1997/05/01 17:49:45 niklas Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.18 1997/05/01 17:49:45 niklas Exp $";
d423 1
a423 1
	char	 ch;
@


1.18
log
@mkstemp called incompatibly.  Buffer overflow fixed.  64-bit dirt cleaned up.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.17 1997/04/12 16:37:37 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.17 1997/04/12 16:37:37 deraadt Exp $";
d98 1
a98 1
int *lordernum;
d150 1
a150 1
			*lordernum = atoi((char *)&order);
d168 2
a169 2
int lordernum;
int *rordernum;
d224 1
a224 1
int ordernum;
d231 1
a231 1
	sprintf(datestr, "%010d", ordernum);
d433 1
a433 1
	int	 ordernum, new_ordernum;
@


1.17
log
@botched strncpy, adam@@math.tau.ac.il
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.16 1997/04/12 00:12:58 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.16 1997/04/12 00:12:58 deraadt Exp $";
d95 1
a95 1
get_local_ordernum(domain,map,lordernum)
d98 1
a98 1
u_long *lordernum;
d112 1
a112 1
	snprintf(map_path, sizeof map_path, "%s/%s",YP_DB_PATH,domain);
a120 1
		
d122 1
a122 1
		    YP_DB_PATH,domain,map,YPDB_SUFFIX);
a128 1
		
d130 1
a130 1
		    YP_DB_PATH,domain,map);
d139 1
a139 2
		
		k.dptr = (char *) &order_key;
d150 1
a150 1
			*lordernum = (u_long) atol((char *) &order);
d164 1
a164 1
get_remote_ordernum(client,domain,map,lordernum,rordernum)
d168 2
a169 2
u_long lordernum;
u_long *rordernum;
d173 1
a173 1
	status = yp_order_host(client, domain, map,(int *)rordernum);
d215 2
a216 2
	    YP_DB_PATH,domain,map,YPDB_SUFFIX);
	rename(temp_map,db_name);
d224 1
a224 1
u_long ordernum;
d226 1
a226 1
	char	datestr[10];
d433 1
a433 1
	u_long	 ordernum,new_ordernum;
d514 1
a514 1
			status = get_local_ordernum(domain,map,&ordernum);
d553 2
a554 2
		status = get_remote_ordernum(client,domain,map,
					     ordernum,&new_ordernum);
d564 1
a564 2
		    "%s/%s/ypdbXXXXXXXXXX%s",
		    YP_DB_PATH, domain, YPDB_SUFFIX);
@


1.16
log
@bit more care with domainnames, adam@@math.tau.ac.il
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.15 1997/02/09 09:49:37 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.15 1997/02/09 09:49:37 maja Exp $";
d151 2
a152 2
	        	strncpy(order, v.dptr, v.dsize);
			order[v.dsize] = '\0';
@


1.15
log
@Add another routine in ypdb (ypdb_open_suf) that doesn't add the suffix to
the database name. The suffix is added in the call to mkstemp. Now ypdb and
mkstemp can coexist and do what we excpect. All code from 1.12 has been
reintegrated now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.14 1997/02/08 19:58:51 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.14 1997/02/08 19:58:51 maja Exp $";
d453 2
d464 2
d539 1
@


1.14
log
@Use much of the backed out code from 1.12. But remove use of mkstemp. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.13 1997/02/07 09:24:03 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.13 1997/02/07 09:24:03 deraadt Exp $";
d116 1
a116 1
			__progname, domain);
d206 1
a206 11
	DBM	*db;
	char	db_temp[255];

	snprintf(db_temp,sizeof db_temp, "%s/%s/%s",
	    YP_DB_PATH,domain,temp_map);

	db = ypdb_open(db_temp, O_RDWR|O_CREAT, 0444);

	return db;

	yplog("Open DB %s", db_temp);
d215 1
a215 1
	char	db_name[MAXPATHLEN],db_temp[MAXPATHLEN];
d219 1
a219 16
	snprintf(db_temp, sizeof db_temp, "%s/%s/%s%s",
	    YP_DB_PATH,domain,temp_map,YPDB_SUFFIX);
	rename(db_temp,db_name);

	return YPPUSH_SUCC;
}

int
unlink_db(domain,map,temp_map)
char *temp_map;
{
	char	db_temp[MAXPATHLEN];

	snprintf(db_temp, sizeof db_temp, "%s/%s/%s%s",
	    YP_DB_PATH,domain,temp_map,YPDB_SUFFIX);
	unlink(db_temp);
a438 1
	char	 mapname[] = "ypdbXXXXXX";
d488 5
a492 2
	  status = YPPUSH_BADARGS;
	  (void)fprintf(stderr,"usage: %s [-cf] [-d domain] [-h host] [-s domain] [-C tid prog ipadd port] mapname\n",__progname);
d557 2
d561 8
a568 1
		mktemp(mapname);
d571 1
a571 1
			db = create_db(domain,map,mapname);
d608 1
a608 1
			status = install_db(domain,map,mapname);
d610 2
a611 1
			status = unlink_db(domain,map,mapname);
@


1.13
log
@back out mktemp fix; for some reason i cannot understand it causes big problems
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.11 1997/01/15 23:44:35 millert Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.11 1997/01/15 23:44:35 millert Exp $";
d38 7
a47 1
#include <sys/stat.h>
a49 3
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
a53 1
/* #include <rpcsvc/yp_prot.h> */
d62 1
a62 1
char	*progname = "ypxfr";
d75 1
a75 1
	datum key,val;
d100 1
a100 1
	char map_path[1024];
d112 1
a112 1
	sprintf(map_path,"%s/%s",YP_DB_PATH,domain);
d116 1
a116 1
			progname, domain);
d122 2
a123 1
		sprintf(map_path,"%s/%s/%s%s",YP_DB_PATH,domain,map,YPDB_SUFFIX);
d131 2
a132 1
		sprintf(map_path,"%s/%s/%s",YP_DB_PATH,domain,map);
d196 1
a196 3
	u_long  status;

	status = yp_all_host(client, domain, map, incallback);
d209 2
a210 1
	sprintf(db_temp,"%s/%s/%s",YP_DB_PATH,domain,temp_map);
d225 1
a225 1
	char	db_name[255],db_temp[255];
d227 4
a230 2
	sprintf(db_name,"%s/%s/%s%s",YP_DB_PATH,domain,map,YPDB_SUFFIX);
	sprintf(db_temp,"%s/%s/%s%s",YP_DB_PATH,domain,temp_map,YPDB_SUFFIX);
d240 1
a240 1
	char	db_temp[255];
d242 2
a243 1
	sprintf(db_temp,"%s/%s/%s%s",YP_DB_PATH,domain,temp_map,YPDB_SUFFIX);
d515 1
a515 1
	  (void)fprintf(stderr,"usage: %s [-cf] [-d domain] [-h host] [-s domain] [-C tid prog ipadd port] mapname\n",progname);
a579 1
		int fd;
d582 1
a582 5
		fd = mkstemp(mapname);
		if (fd == -1) 
			status = YPPUSH_DBM;
		else
			close(fd);
@


1.12
log
@kill non-/tmp mktemp race and misc cleanup
@
text
@a37 7
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <arpa/inet.h>

d41 1
d44 3
d51 1
d60 1
a60 1
extern char *__progname;
d73 1
a73 1
	datum	key,val;
d98 1
a98 1
	char map_path[MAXPATHLEN];
d110 1
a110 1
	snprintf(map_path, sizeof map_path, "%s/%s",YP_DB_PATH,domain);
d114 1
a114 1
		    __progname, domain);
d120 1
a120 2
		snprintf(map_path, sizeof map_path, "%s/%s/%s%s",
		    YP_DB_PATH,domain,map,YPDB_SUFFIX);
d128 1
a128 2
		snprintf(map_path, sizeof map_path, "%s/%s/%s",
		    YP_DB_PATH,domain,map);
d192 3
a194 1
	(void)yp_all_host(client, domain, map, incallback);
d204 10
a213 1
	return ypdb_open(temp_map, O_RDWR, 0444);
d222 14
a235 1
	char	db_name[MAXPATHLEN];
d237 2
a238 3
	snprintf(db_name, sizeof db_name, "%s/%s/%s%s",
	    YP_DB_PATH,domain,map,YPDB_SUFFIX);
	rename(temp_map,db_name);
d458 1
d508 2
a509 5
		status = YPPUSH_BADARGS;
		fprintf(stderr, "usage: %s %s %s\n",
		    "[-cf] [-d domain] [-h host] [-s domain]",
		    "[-C tid prog ipadd port] mapname\n",
		    __progname);
d574 1
a574 2
		char	tmpmapname[MAXPATHLEN];
		int	fd;
d577 1
a577 3
		snprintf(tmpmapname, sizeof tmpmapname, "%s/%s/ypdbXXXXXXXXXX",
		    YP_DB_PATH, domain);
		fd = mkstemp(tmpmapname);
d584 1
a584 1
			db = create_db(domain,map,tmpmapname);
d621 1
a621 1
			status = install_db(domain,map,tmpmapname);
d623 1
a623 2
			unlink(tmpmapname);
			status = YPPUSH_SUCC;
@


1.11
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.10 1996/12/24 19:28:03 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.10 1996/12/24 19:28:03 deraadt Exp $";
d38 7
a47 1
#include <sys/stat.h>
a49 3
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
a53 1
/* #include <rpcsvc/yp_prot.h> */
d62 1
a62 1
char	*progname = "ypxfr";
d75 1
a75 1
	datum key,val;
d100 1
a100 1
	char map_path[1024];
d112 1
a112 1
	sprintf(map_path,"%s/%s",YP_DB_PATH,domain);
d116 1
a116 1
			progname, domain);
d122 2
a123 1
		sprintf(map_path,"%s/%s/%s%s",YP_DB_PATH,domain,map,YPDB_SUFFIX);
d131 2
a132 1
		sprintf(map_path,"%s/%s/%s",YP_DB_PATH,domain,map);
d196 1
a196 3
	u_long  status;

	status = yp_all_host(client, domain, map, incallback);
d206 1
a206 10
	DBM	*db;
	char	db_temp[255];

	sprintf(db_temp,"%s/%s/%s",YP_DB_PATH,domain,temp_map);

	db = ypdb_open(db_temp, O_RDWR|O_CREAT, 0444);

	return db;

	yplog("Open DB %s", db_temp);
d215 1
a215 14
	char	db_name[255],db_temp[255];

	sprintf(db_name,"%s/%s/%s%s",YP_DB_PATH,domain,map,YPDB_SUFFIX);
	sprintf(db_temp,"%s/%s/%s%s",YP_DB_PATH,domain,temp_map,YPDB_SUFFIX);
	rename(db_temp,db_name);

	return YPPUSH_SUCC;
}

int
unlink_db(domain,map,temp_map)
char *temp_map;
{
	char	db_temp[255];
d217 3
a219 2
	sprintf(db_temp,"%s/%s/%s%s",YP_DB_PATH,domain,temp_map,YPDB_SUFFIX);
	unlink(db_temp);
a438 1
	char	 mapname[] = "ypdbXXXXXX";
d488 5
a492 2
	  status = YPPUSH_BADARGS;
	  (void)fprintf(stderr,"usage: %s [-cf] [-d domain] [-h host] [-s domain] [-C tid prog ipadd port] mapname\n",progname);
d557 2
a558 1
		int fd;
d561 3
a563 1
		fd = mkstemp(mapname);
d570 1
a570 1
			db = create_db(domain,map,mapname);
d607 1
a607 1
			status = install_db(domain,map,mapname);
d609 2
a610 1
			status = unlink_db(domain,map,mapname);
@


1.10
log
@use mkstemp
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.9 1996/10/01 01:53:08 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.9 1996/10/01 01:53:08 deraadt Exp $";
d467 1
a467 1
	while ((ch = getopt(argc, argv, "cd:fh:s:C:")) != EOF)
@


1.9
log
@simplify check
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.8 1996/09/30 20:50:25 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.8 1996/09/30 20:50:25 maja Exp $";
d574 1
d577 2
a578 3
		mktemp(mapname);
		db = create_db(domain,map,mapname);
		if(db == NULL) {
d580 7
@


1.8
log
@Don't allow certain operations if not from a reserved port. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.7 1996/08/15 22:16:31 chuck Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.7 1996/08/15 22:16:31 chuck Exp $";
d557 1
a557 2
		if (srvport >= IPPORT_RESERVED ||
		    srvport < IPPORT_RESERVED/2) {
a558 1
		}
@


1.7
log
@for -C check to make sure we've got the proper number of args and give up
if not.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypxfr.c,v 1.6 1996/05/30 09:53:35 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypxfr.c,v 1.6 1996/05/30 09:53:35 deraadt Exp $";
d460 1
d551 12
@


1.6
log
@$OpenBSD$ tag and few spelling errors
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD$";
d484 5
@


1.5
log
@Using TCP broke ypxfr -C which in turn caused yppush to fail on the
master NIS server.  I gave yp_bind_host an extra argument to select
TCP/UDP transport.
@
text
@d1 2
d35 1
a35 1
static char rcsid[] = "$Id: ypxfr.c,v 1.4 1996/03/02 03:42:06 dm Exp $";
@


1.4
log
@add_interdomain should succeed even with no YP_INTERDOMAIN record
@
text
@d33 1
a33 1
static char rcsid[] = "$Id: ypxfr.c,v 1.3 1996/03/02 03:01:49 dm Exp $";
d548 1
a548 1
		client = yp_bind_host(host,YPPROG,YPVERS,0);
d622 2
a623 1
				      atoi(port));
@


1.3
log
@Added in stuff from 960121.  Fixed several bugs in ypxfr.
@
text
@d33 1
a33 1
static char rcsid[] = "$Id: ypxfr.c,v 1.4 1996/01/20 16:42:27 moj Exp $";
d230 12
d322 1
a322 1
	status = !yp_match_host(client, domain, map,
d325 1
a325 1
	if(status > 0 && value) {
d339 1
a339 1
	return status;
d597 2
@


1.2
log
@use new yplog function
@
text
@d13 5
a17 3
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
d33 1
a33 1
static char rcsid[] = "$Id: ypxfr.c,v 1.1 1995/11/01 16:56:43 deraadt Exp $";
d80 1
a80 1
	key.dsize = strlen(keystr) + 1;
d83 1
a83 1
	val.dsize = strlen(valstr) + 1;
d97 1
a97 1
	char order_key[YP_LAST_LEN] = YP_LAST_KEY;
d236 1
a236 1
	char	keystr[YP_LAST_LEN] = YP_LAST_KEY;
d242 1
a242 1
	key.dsize = strlen(keystr) + 1;
d245 1
a245 1
	val.dsize = strlen(datestr) + 1;
d263 1
a263 1
	char	keystr[YP_MASTER_LEN] = YP_MASTER_KEY;
d276 1
a276 1
	  key.dsize = strlen(keystr) + 1;
d279 1
a279 1
	  val.dsize = strlen(master) + 1;
d299 1
a299 1
	char	keystr[YP_INTERDOMAIN_LEN] = YP_INTERDOMAIN_KEY;
d308 1
a308 1
	k.dsize = strlen(keystr) + 1;
d310 1
a310 1
	status = yp_match_host(client, domain, map,
d313 1
a313 1
	if(status > 0) {
d337 1
a337 1
	char	keystr[YP_SECURE_LEN] = YP_SECURE_KEY;
d346 1
a346 1
	k.dsize = strlen(keystr) + 1;
d537 1
a537 1
		
@


1.1
log
@+ full set of ypserv tools that compile
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: ypxfr.c,v 1.2 1995/09/09 22:49:40 moj Exp $";
d209 1
a209 1
	yplog_str("Open DB "); yplog_cat(db_temp); yplog_cat("\n");
d491 1
a491 1
		yplog_init(progname);
d493 11
a503 21
		yplog_date("Arguments:");
		yplog_str("YP clear to local: ");
		if (cflag) {
		  yplog_cat("no\n");
		} else {
		  yplog_cat("yes\n");
		}
		yplog_str("   Force transfer: ");
		if (fflag) {
		  yplog_cat("yes\n");
		} else {
		  yplog_cat("no\n");
		}
		yplog_str("           domain: "); yplog_cat(domain); yplog_cat("\n");
		yplog_str("             host: "); yplog_cat(host); yplog_cat("\n");
		yplog_str("    source domain: "); yplog_cat(srcdomain); yplog_cat("\n");
		yplog_str("          transid: "); yplog_cat(tid); yplog_cat("\n");
		yplog_str("             prog: "); yplog_cat(prog); yplog_cat("\n");
		yplog_str("             port: "); yplog_cat(port); yplog_cat("\n");
		yplog_str("            ipadd: "); yplog_cat(ipadd); yplog_cat("\n");
		yplog_str("              map: "); yplog_cat(map); yplog_cat("\n\n");
d514 1
a514 1
	        yplog_str("Get Master\n");
d532 1
a532 1
	        yplog_str("Connect host: "); yplog_cat(host); yplog_cat("\n");
@
