head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.12
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.8
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.4
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.16
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.14
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.12
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.10
	OPENBSD_5_0:1.27.0.8
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.6
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.4
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.26.0.8
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.4
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.6
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.4
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.21.0.8
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.6
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.14.0.4
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.10
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.8
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.6
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.31
date	2015.01.16.06.40.23;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	Uu5nFG3wCl0LACBb;

1.30
date	2014.11.04.16.16.03;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	BxCFrulLYPBySqh5;

1.29
date	2014.10.11.02.29.24;	author doug;	state Exp;
branches;
next	1.28;
commitid	Lpo23uFzJzAyYsog;

1.28
date	2013.12.04.02.18.05;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.27.23.59.58;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.01.21.45.08;	author sobrado;	state Exp;
branches;
next	1.25;

1.25
date	2006.09.25.05.59.28;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.03.05.01.23;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.16.23.53.08;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.14.02.32.33;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.15.06.10.46;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.21.58.27;	author maja;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.05.08.37.05;	author avsm;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.21.21.01.11;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.19.02.38.40;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.19.09.01.43;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.19.04.21.41;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.05.14.46.38;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.11.23.38.07;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.12.09.47.27;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.02.24.04.29.06;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.11.10.05.49.17;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.11.10.00.09.40;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.11.04.07.40.51;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.05.01.22.14.46;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.03.15.00.08.58;	author gene;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.22.10.27;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	96.11.08.21.53.32;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.05.30.09.53.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.02.04.55.00;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.03.02.03.01.43;	author dm;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: yppush.c,v 1.30 2014/11/04 16:16:03 deraadt Exp $ */

/*
 * Copyright (c) 1995 Mats O Jansson <moj@@stacken.kth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/resource.h>
#include <sys/wait.h>

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <ctype.h>

#include <rpc/rpc.h>
#include <rpc/xdr.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>

#include <netdb.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>

#include "yplib_host.h"
#include "ypdef.h"
#include "ypdb.h"

int  Verbose = 0;
char Domain[HOST_NAME_MAX+1], Map[255];
u_int32_t OrderNum;
char *master;

extern void yppush_xfrrespprog_1(struct svc_req *request, SVCXPRT *xprt);
extern bool_t xdr_ypreq_xfr(XDR *, struct ypreq_xfr *);

static void
usage(void)
{
	fprintf(stderr,
	    "usage: yppush [-v] [-d domainname] [-h hostname] mapname\n");
	exit(1);
}

static void
my_svc_run(void)
{
	struct pollfd *pfd = NULL, *newp;
	int nready, saved_max_pollfd = 0;

	for (;;) {
		if (svc_max_pollfd > saved_max_pollfd) {
			newp = reallocarray(pfd, svc_max_pollfd, sizeof(*pfd));
			if (newp == NULL) {
				free(pfd);
				perror("svc_run: - realloc failed");
				return;
			}
			pfd = newp;
			saved_max_pollfd = svc_max_pollfd;
		}
		memcpy(pfd, svc_pollfd, sizeof(*pfd) * svc_max_pollfd);

		nready = poll(pfd, svc_max_pollfd, 60 * 1000);
		switch (nready) {
		case -1:
			if (errno == EINTR)
				continue;
			perror("yppush: my_svc_run: poll failed");
			free(pfd);
			return;
		case 0:
			fprintf(stderr, "yppush: Callback timed out.\n");
			exit(0);
		default:
			svc_getreq_poll(pfd, nready);
			break;
		}
	}
}

static void
req_xfr(pid_t pid, u_int prog, SVCXPRT *transp, char *host, CLIENT *client)
{
	struct ypreq_xfr request;
	struct timeval tv;

	tv.tv_sec = 0;
	tv.tv_usec = 0;

	request.map_parms.domain=(char *)&Domain;
	request.map_parms.map=(char *)&Map;
	request.map_parms.peer=master;
	request.map_parms.ordernum=OrderNum;
	request.transid=(u_int)pid;
	request.prog=prog;
	request.port=transp->xp_port;

	if (Verbose)
		printf("%d: %s(%u@@%s) -> %s@@%s\n",
		    request.transid, request.map_parms.map,
		    request.map_parms.ordernum, host,
		    request.map_parms.peer, request.map_parms.domain);
	switch (clnt_call(client, YPPROC_XFR, xdr_ypreq_xfr, &request,
	    xdr_void, NULL, tv)) {
	case RPC_SUCCESS:
	case RPC_TIMEDOUT:
		break;
	default:
		clnt_perror(client, "yppush: Cannot call YPPROC_XFR");
		kill(pid, SIGTERM);
		break;
	}
}

static void
push(int inlen, char *indata)
{
	char host[HOST_NAME_MAX+1];
	CLIENT *client;
	SVCXPRT *transp;
	int sock = RPC_ANYSOCK, status;
	u_int prog;
	bool_t sts = 0;
	pid_t pid;
	struct rusage res;

	snprintf(host, sizeof host, "%*.*s", inlen, inlen, indata);

	client = clnt_create(host, YPPROG, YPVERS, "tcp");
	if (client == NULL) {
		if (Verbose)
			fprintf(stderr, "Target Host: %s\n", host);
		clnt_pcreateerror("yppush: Cannot create client");
		return;
	}

	transp = svcudp_create(sock);
	if (transp == NULL) {
		fprintf(stderr, "yppush: Cannot create callback transport.\n");
		return;
	}
	if (transp->xp_port >= IPPORT_RESERVED) {
		SVC_DESTROY(transp);
		fprintf(stderr, "yppush: Cannot allocate reserved port.\n");
		return;
	}

	for (prog=0x40000000; prog<0x5fffffff; prog++) {
		if ((sts = svc_register(transp, prog, 1,
		    yppush_xfrrespprog_1, IPPROTO_UDP)))
			break;
	}

	if (!sts) {
		fprintf(stderr, "yppush: Cannot register callback.\n");
		return;
	}

	switch (pid=fork()) {
	case -1:
		fprintf(stderr, "yppush: Cannot fork.\n");
		exit(1);
	case 0:
		my_svc_run();
		exit(0);
	default:
		close(transp->xp_sock);
		transp->xp_sock = -1;
		req_xfr(pid, prog, transp, host, client);
		wait4(pid, &status, 0, &res);
		svc_unregister(prog, 1);
		if (client != NULL)
			clnt_destroy(client);
		/* XXX transp leak? */
	}

}

static int
pushit(u_long instatus, char *inkey, int inkeylen, char *inval, int invallen,
    void *indata)
{
	if (instatus != YP_TRUE)
		return instatus;
	push(invallen, inval);
	return 0;
}

int
main(int argc, char *argv[])
{
	struct ypall_callback ypcb;
	extern char *optarg;
	extern int optind;
	char	*domain, *map, *hostname;
	int c, r, i;
	char *ypmap = "ypservers";
	CLIENT *client;
	static char map_path[PATH_MAX];
	struct stat finfo;
	DBM *yp_databas;
	char order_key[YP_LAST_LEN] = YP_LAST_KEY;
	datum o;

	yp_get_default_domain(&domain);
	hostname = NULL;
	while ((c=getopt(argc, argv, "d:h:v")) != -1)
		switch (c) {
		case 'd':
			domain = optarg;
			break;
		case 'h':
			hostname = optarg;
			break;
		case 'v':
			Verbose = 1;
			break;
		default:
			usage();
			/*NOTREACHED*/
		}

	if (optind + 1 != argc )
		usage();

	map = argv[optind];

	strncpy(Domain, domain, sizeof(Domain)-1);
	Domain[sizeof(Domain)-1] = '\0';
	strncpy(Map, map, sizeof(Map)-1);
	Map[sizeof(Map)-1] = '\0';

	/* Check domain */
	snprintf(map_path, sizeof map_path, "%s/%s", YP_DB_PATH, domain);
	if (!((stat(map_path, &finfo) == 0) && S_ISDIR(finfo.st_mode))) {
		fprintf(stderr, "yppush: Map does not exist.\n");
		exit(1);
	}

	/* Check map */
	snprintf(map_path, sizeof map_path, "%s/%s/%s%s",
	    YP_DB_PATH, domain, Map, YPDB_SUFFIX);
	if (!(stat(map_path, &finfo) == 0)) {
		fprintf(stderr, "yppush: Map does not exist.\n");
		exit(1);
	}

	snprintf(map_path, sizeof map_path, "%s/%s/%s",
	    YP_DB_PATH, domain, Map);
	yp_databas = ypdb_open(map_path, 0, O_RDONLY);
	OrderNum=0xffffffff;
	if (yp_databas == 0) {
		fprintf(stderr, "yppush: %s%s: Cannot open database\n",
		    map_path, YPDB_SUFFIX);
	} else {
		o.dptr = (char *) &order_key;
		o.dsize = YP_LAST_LEN;
		o = ypdb_fetch(yp_databas, o);
		if (o.dptr == NULL) {
			fprintf(stderr,
			    "yppush: %s: Cannot determine order number\n",
			    Map);
		} else {
			OrderNum=0;
			for (i=0; i<o.dsize-1; i++) {
				if (!isdigit((unsigned char)o.dptr[i]))
					OrderNum=0xffffffff;
			}
			if (OrderNum != 0) {
				fprintf(stderr,
				    "yppush: %s: Invalid order number '%s'\n",
				    Map, o.dptr);
			} else {
				OrderNum = atoi(o.dptr);
			}
		}
	}

	yp_bind(Domain);

	r = yp_master(Domain, ypmap, &master);
	if (r != 0) {
		fprintf(stderr, "yppush: could not get ypservers map\n");
		exit(1);
	}

	if (hostname != NULL) {
		push(strlen(hostname), hostname);
	} else {
		if (Verbose) {
			printf("Contacting master for ypservers (%s).\n",
			    master);
		}

		client = yp_bind_host(master, YPPROG, YPVERS, 0, 1);

		ypcb.foreach = pushit;
		ypcb.data = NULL;
		r = yp_all_host(client, Domain, ypmap, &ypcb);
	}

	exit(0);
}
@


1.30
log
@use after free in poll loop
from Dimitris Papastamos
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.29 2014/10/11 02:29:24 doug Exp $ */
d55 1
a55 1
char Domain[MAXHOSTNAMELEN], Map[255];
d144 1
a144 1
	char host[MAXHOSTNAMELEN];
d225 1
a225 1
	static char map_path[MAXPATHLEN];
@


1.29
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.28 2013/12/04 02:18:05 deraadt Exp $ */
a101 1
			free(pfd);
@


1.28
log
@ctype improvements; checked by okan
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.27 2009/10/27 23:59:58 deraadt Exp $ */
d78 1
a78 1
			newp = realloc(pfd, sizeof(*pfd) * svc_max_pollfd);
@


1.27
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.26 2008/06/01 21:45:08 sobrado Exp $ */
d293 1
a293 1
				if (!isdigit(o.dptr[i]))
@


1.26
log
@sort flags; synchronize synopsis and usage; style(9).

tweaked by jmc@@, thanks!

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.25 2006/09/25 05:59:28 otto Exp $ */
a27 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: yppush.c,v 1.25 2006/09/25 05:59:28 otto Exp $";
#endif /* not lint */
@


1.25
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which leads to surprising results. Spotted by
from Paul Stoeber, more to come. ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.24 2006/04/03 05:01:23 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: yppush.c,v 1.24 2006/04/03 05:01:23 deraadt Exp $";
d69 2
a70 1
	fprintf(stderr, "usage: yppush [-d domainname] [-h host] [-v] mapname\n");
@


1.24
log
@spreading the lint love (very minimal things..)
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.23 2005/09/16 23:53:08 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: yppush.c,v 1.23 2005/09/16 23:53:08 deraadt Exp $";
d265 1
a265 2
	if (!((stat(map_path, &finfo) == 0) &&
	    ((finfo.st_mode & S_IFMT) == S_IFDIR))) {
@


1.23
log
@use poll() instead of select(), pr4503, alexander.farber@@gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.22 2005/05/14 02:32:33 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: yppush.c,v 1.22 2005/05/14 02:32:33 deraadt Exp $";
d157 1
a157 1
	snprintf(host, sizeof host, "%*.*s" ,inlen ,inlen, indata);
d162 1
a162 1
			fprintf(stderr, "Target Host: %s\n",host);
@


1.22
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.21 2003/07/15 06:10:46 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: yppush.c,v 1.21 2003/07/15 06:10:46 deraadt Exp $";
d74 1
a74 1
_svc_run(void)
d76 2
a77 7
	fd_set *readfdsp = NULL;
	extern fd_set *__svc_fdset;
	extern int __svc_fdsetsize;
	struct timeval timeout;

	timeout.tv_sec = 60;
	timeout.tv_usec = 0;
d80 9
a88 7
		if (readfdsp)
			free(readfdsp);
		readfdsp = (fd_set *)calloc(howmany(__svc_fdsetsize, NFDBITS),
		    sizeof(fd_mask));
		if (readfdsp == NULL) {
			perror("calloc");
			return;
d90 1
a90 2
		bcopy(__svc_fdset, readfdsp, howmany(__svc_fdsetsize, NFDBITS) *
		    sizeof(fd_mask));
d92 2
a93 2
		switch (select(svc_maxfd+1, readfdsp, NULL,
		    NULL, &timeout)) {
d97 2
a98 1
			perror("yppush: _svc_run: select failed");
d104 2
a105 1
			svc_getreqset2(readfdsp, svc_maxfd+1);
d194 1
a194 1
		_svc_run();
@


1.21
log
@protos and repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.20 2003/06/02 21:58:27 maja Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: yppush.c,v 1.20 2003/06/02 21:58:27 maja Exp $";
d153 1
a153 1
	int sock = RPC_ANYSOCK;
a156 1
	int status;
@


1.20
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.19 2003/05/05 08:37:05 avsm Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: yppush.c,v 1.19 2003/05/05 08:37:05 avsm Exp $";
d66 1
a66 1
void
d73 1
a73 1
void
d113 1
a113 1
void
d147 1
a147 1
void
d212 1
a212 1
int
@


1.19
log
@-Wall cleanup: trim unused vars, better err() message in stdhosts,
and constify rcsid[]

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.18 2002/11/21 21:01:11 deraadt Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: yppush.c,v 1.18 2002/11/21 21:01:11 deraadt Exp $";
@


1.18
log
@crap in getopt; margarida
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.17 2002/07/19 02:38:40 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppush.c,v 1.17 2002/07/19 02:38:40 deraadt Exp $";
@


1.17
log
@4344 lines of KNF diff
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.16 2001/11/19 09:01:43 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppush.c,v 1.16 2001/11/19 09:01:43 deraadt Exp $";
d233 1
a233 1
	char	*domain, *map, *hostname, *parallel, *timeout;
a251 6
			break;
		case 'p':
			parallel = optarg;
			break;
		case 't':
			timeout = optarg;
@


1.16
log
@KNF here too
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.15 2001/11/19 04:21:41 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppush.c,v 1.15 2001/11/19 04:21:41 deraadt Exp $";
d46 1
d72 1
a72 1
usage()
d74 1
a74 2
	fprintf(stderr, "Usage:\n");
	fprintf(stderr, "\typpush [-d domainname] [-h host] [-v] mapname\n");
d79 1
a79 1
_svc_run()
d119 1
a119 6
req_xfr(pid, prog, transp, host, client)
pid_t pid;
u_int prog;
SVCXPRT *transp;
char *host;
CLIENT *client;
d153 1
a153 3
push(inlen, indata)
int inlen;
char *indata;
d197 1
a197 1
	switch(pid=fork()) {
d218 2
a219 7
pushit(instatus, inkey, inkeylen, inval, invallen, indata)
int instatus;
char *inkey;
int inkeylen;
char *inval;
int invallen;
char *indata;
d228 1
a228 3
main(argc, argv)
int  argc;
char **argv;
d246 1
a246 1
		switch(c) {
d280 2
a281 2
	      ((finfo.st_mode & S_IFMT) == S_IFDIR))) {
	  	fprintf(stderr, "yppush: Map does not exist.\n");
d284 1
a284 2
		
	
d292 1
a292 1
		
a322 1
	
a348 1

@


1.15
log
@no signals, no need for signal.h
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.14 2001/02/05 14:46:38 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppush.c,v 1.14 2001/02/05 14:46:38 deraadt Exp $";
d172 1
a172 1
	snprintf(host,sizeof host,"%*.*s" ,inlen ,inlen, indata);
d177 1
a177 1
			fprintf(stderr,"Target Host: %s\n",host);
d247 1
a247 1
	char	*domain,*map,*hostname,*parallel,*timeout;
d286 1
a286 1
	strncpy(Domain,domain,sizeof(Domain)-1);
d288 1
a288 1
	strncpy(Map,map,sizeof(Map)-1);
d292 1
a292 1
	snprintf(map_path,sizeof map_path,"%s/%s",YP_DB_PATH,domain);
d295 1
a295 1
	  	fprintf(stderr,"yppush: Map does not exist.\n");
d301 2
a302 2
	snprintf(map_path,sizeof map_path,"%s/%s/%s%s",
	    YP_DB_PATH,domain,Map,YPDB_SUFFIX);
d304 1
a304 1
		fprintf(stderr,"yppush: Map does not exist.\n");
d308 3
a310 2
	snprintf(map_path,sizeof map_path,"%s/%s/%s",YP_DB_PATH,domain,Map);
	yp_databas = ypdb_open(map_path,0,O_RDONLY);
d314 1
a314 1
			map_path, YPDB_SUFFIX);
d318 1
a318 1
		o=ypdb_fetch(yp_databas,o);
d321 2
a322 2
				"yppush: %s: Cannot determine order number\n",
				Map);
d326 1
a326 1
				if (!isdigit(o.dptr[i])) {
a327 1
				}
d360 1
a360 1
		r = yp_all_host(client,Domain, ypmap, &ypcb);
@


1.14
log
@always double check the work you do in a 757 over northern Brazil.
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.13 2001/01/11 23:38:07 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppush.c,v 1.13 2001/01/11 23:38:07 deraadt Exp $";
a40 1
#include <sys/signal.h>
a46 1
#include <signal.h>
@


1.13
log
@fix fd_set overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.12 2000/10/12 09:47:27 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppush.c,v 1.12 2000/10/12 09:47:27 deraadt Exp $";
d103 1
a103 1
		switch (select(svc_maxfd, readfdsp, NULL,
d114 1
a114 1
			svc_getreqset(readfdsp);
@


1.12
log
@cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.11 1998/02/24 04:29:06 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppush.c,v 1.11 1998/02/24 04:29:06 deraadt Exp $";
d83 3
a85 1
	fd_set readfds;
d92 12
a103 2
		readfds = svc_fdset;
		switch (select(_rpc_dtablesize(), &readfds, NULL,
d114 1
a114 1
			svc_getreqset(&readfds);
@


1.11
log
@pull in prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.10 1997/11/10 05:49:17 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppush.c,v 1.10 1997/11/10 05:49:17 deraadt Exp $";
d39 5
d46 3
a54 3
#include <sys/stat.h>
#include <sys/resource.h>
#include <sys/signal.h>
a75 3
/*
	fprintf(stderr, "\typpush [-d domainname] [-t seconds] [-p #paralleljobs] [-h host] [-v] mapname\n");
*/
d86 2
a87 1
	timeout.tv_sec=60; timeout.tv_usec=0;
d89 1
a89 1
	for(;;) {
d91 2
a92 2
		switch (select(_rpc_dtablesize(), &readfds, (void *) 0,
			       (void *) 0, &timeout)) {
d94 1
a94 1
			if (errno == EINTR) {
a95 1
			}
d103 1
a105 1
	
d119 2
a120 1
	tv.tv_sec=0; tv.tv_usec=0;
d132 3
a134 6
		       request.transid,
		       request.map_parms.map,
		       request.map_parms.ordernum,
		       host,
		       request.map_parms.peer,
		       request.map_parms.domain);
d136 1
a136 1
			  xdr_void, NULL, tv)) {
d143 1
d157 1
a157 1
	bool_t sts;
d184 2
a185 2
		if (sts = svc_register(transp, prog, 1,
		    yppush_xfrrespprog_1, IPPROTO_UDP))
d223 1
a223 1
	if(instatus != YP_TRUE)
d247 1
a247 1
        yp_get_default_domain(&domain);
d249 1
a249 4
/*
	while( (c=getopt(argc, argv, "d:h:p:t:v?")) != -1)
*/
	while( (c=getopt(argc, argv, "d:h:v?")) != -1)
d252 1
a252 1
                        domain = optarg;
d263 6
a268 6
                case 'v':
                        Verbose = 1;
                        break;
                case '?':
                        usage();
                        /*NOTREACHED*/
d271 1
a271 1
	if(optind + 1 != argc )
d314 1
a314 1
			for(i=0; i<o.dsize-1; i++) {
d321 2
a322 3
					"yppush: %s: Invalid order number '%s'\n",
					Map,
					o.dptr);
d327 1
a327 1
        }
d333 1
a333 1
        if (r != 0) {
d339 1
a339 1
	  push(strlen(hostname), hostname);
d341 4
a344 4
	  
	  if (Verbose) {
		printf("Contacting master for ypservers (%s).\n", master);
	  }
d346 1
a346 1
	  client = yp_bind_host(master, YPPROG, YPVERS, 0, 1);
d348 4
a351 2
	  ypcb.foreach = pushit;
	  ypcb.data = NULL;
d353 1
a353 4
	  r = yp_all_host(client,Domain, ypmap, &ypcb);
	}
        
        exit(0);
@


1.10
log
@SVC_DESTROY ?
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.9 1997/11/10 00:09:40 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppush.c,v 1.9 1997/11/10 00:09:40 deraadt Exp $";
d51 1
@


1.9
log
@use clnt_destroy(); PR#345
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.8 1997/11/04 07:40:51 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppush.c,v 1.8 1997/11/04 07:40:51 deraadt Exp $";
d176 1
a176 1
		clnt_destroy(transp);
@


1.8
log
@ensure we got a reserved port
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.7 1997/05/01 22:14:46 niklas Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppush.c,v 1.7 1997/05/01 22:14:46 niklas Exp $";
d176 1
a176 1
		svcudp_destroy(transp);
@


1.7
log
@Umm, fix signedness error in my last commit, be explicit
about the fact that ordernumbers are 32 bit
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.6 1997/03/15 00:08:58 gene Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppush.c,v 1.6 1997/03/15 00:08:58 gene Exp $";
d175 5
d183 1
a183 1
				       yppush_xfrrespprog_1, IPPROTO_UDP))
d201 1
d205 3
a207 3
		if (client != NULL) {
		  	clnt_destroy(client);
		}
@


1.6
log
@Fix so yppush will err out if it can't find the ypservers map.  This whole
code wants lots of attention, but at least it won't dump core on a virgin
installation now.
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.5 1996/12/14 22:10:27 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppush.c,v 1.5 1996/12/14 22:10:27 maja Exp $";
d60 1
a60 1
u_long OrderNum;
d127 1
a127 1
		printf("%d: %s(%d@@%s) -> %s@@%s\n",
@


1.5
log
@Add Theo's changes to yppush, some very ugly debugging code is now gone. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.4 1996/11/08 21:53:32 niklas Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppush.c,v 1.4 1996/11/08 21:53:32 niklas Exp $";
d284 1
d328 5
a332 1
        r = yp_master(Domain, ypmap, &master);
@


1.4
log
@Fix grammatical error
@
text
@d1 1
a1 1
/*	$OpenBSD: yppush.c,v 1.3 1996/05/30 09:53:19 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: yppush.c,v 1.3 1996/05/30 09:53:19 deraadt Exp $";
a37 4
/*
#include <sys/param.h>
#include <sys/socket.h>
*/
a39 4
/*
#include <time.h>
#include <netdb.h>
*/
a40 5
/*
#include <string.h>
#include <netinet/in.h>
#include <arpa/inet.h>
*/
a46 1
#include <sys/types.h>
d50 1
d59 1
a59 1
char Domain[255], Map[255], *LocalHost = "meg.celsiustech.se";
d61 1
d120 1
a120 1
	request.map_parms.peer=LocalHost;
d150 1
a150 1
	char host[255];
d160 1
a160 1
	sprintf(host,"%*.*s" ,inlen ,inlen, indata);
a226 1
        char *master;
d233 1
a233 1
	static char map_path[255];
d271 4
a274 2
	strcpy(Domain,domain);
	strcpy(Map,map);
d277 1
a277 1
	sprintf(map_path,"%s/%s",YP_DB_PATH,domain);
d285 2
a286 1
	sprintf(map_path,"%s/%s/%s%s",YP_DB_PATH,domain,Map,YPDB_SUFFIX);
d292 1
a292 1
	sprintf(map_path,"%s/%s/%s",YP_DB_PATH,domain,Map);
d327 2
a332 2
	  r = yp_master(Domain, ypmap, &master);

@


1.3
log
@$OpenBSD$ tag and few spelling errors
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD$";
d291 1
a291 1
	  	fprintf(stderr,"yppush: Map does not exists.\n");
d298 1
a298 1
		fprintf(stderr,"yppush: Map does not exists.\n");
@


1.2
log
@Using TCP broke ypxfr -C which in turn caused yppush to fail on the
master NIS server.  I gave yp_bind_host an extra argument to select
TCP/UDP transport.
@
text
@d1 2
d35 1
a35 1
static char rcsid[] = "$Id: yppush.c,v 1.1 1996/03/02 03:01:43 dm Exp $";
@


1.1
log
@Added in stuff from 960121.  Fixed several bugs in ypxfr.
@
text
@d33 1
a33 1
static char rcsid[] = "$Id: yppush.c,v 1.2 1996/01/15 01:05:13 moj Exp $";
d345 1
a345 1
	  client = yp_bind_host(master, YPPROG, YPVERS, 0);
@
