head	1.33;
access;
symbols
	OPENBSD_6_1:1.33.0.12
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.8
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.4
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.33.0.6
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.31.0.6
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.29.0.16
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.14
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.12
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.10
	OPENBSD_5_0:1.29.0.8
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.6
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.4
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.14
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.10
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.8
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.6
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.4
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.23.0.8
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.6
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.4
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.14.0.4
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.13.0.6
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.4
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.33
date	2015.02.09.23.00.15;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	822YD61EeG0Xl9Na;

1.32
date	2015.01.16.06.40.23;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	Uu5nFG3wCl0LACBb;

1.31
date	2013.12.04.02.18.05;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2013.08.22.04.43.41;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.27.23.59.57;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.19.21.42.41;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2006.11.10.20.44.07;	author mk;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.03.05.01.22;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.21.01.40.24;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.14.02.32.32;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.18.22.58.56;	author david;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.15.06.10.46;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.21.58.26;	author maja;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.05.08.37.05;	author avsm;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.19.20.59.40;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.19.02.38.40;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.20.14.19.30;	author maja;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.13.23.05.48;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.24.14.40.00;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.05.14.47.16;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.04.22.17.43.10;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.09.17.22.58.38;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	98.07.09.06.33.03;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.03.12.08.22.27;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.08.18.03.11.34;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.22.10.53.01;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	97.04.04.18.41.46;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.17.07.14.32;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.44.32;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.21.26.35;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	96.05.30.09.53.06;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.20.00.33.34;	author chuck;	state Exp;
branches;
next	1.1;

1.1
date	95.11.01.16.56.24;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.33
log
@clean up flags++ instances around getopt()
ok florian
@
text
@/*	$OpenBSD: makedbm.c,v 1.32 2015/01/16 06:40:23 deraadt Exp $ */

/*
 * Copyright (c) 1994-97 Mats O Jansson <moj@@stacken.kth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <ctype.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include "ypdb.h"
#include "ypdef.h"
#include "db.h"

extern char *__progname;		/* from crt0.o */

/*
 * Read one line
 */

static int
read_line(FILE *fp, char *buf, int size)
{
	int	done = 0;

	do {
		while (fgets(buf, size, fp)) {
			int len = strlen(buf);

			done += len;
			if (len > 1 && buf[len-2] == '\\' &&
			    buf[len-1] == '\n') {
				int ch;

				buf += len - 2;
				size -= len - 2;
				*buf = '\n'; buf[1] = '\0';

				/* Skip leading white space on next line */
				while ((ch = getc(fp)) != EOF &&
				    isascii(ch) && isspace(ch))
					;
				(void) ungetc(ch, fp);
			} else {
				return done;
			}
		}
	} while (size > 0 && !feof(fp));
	return done;
}

static void
add_record(DBM *db, char *str1, char *str2, int check)
{
	datum   key, val;
	int	status;

	key.dptr = str1;
	key.dsize = strlen(str1);

	if (check) {
		val = ypdb_fetch(db, key);

		if (val.dptr != NULL)
			return;		/* already there */
	}

	val.dptr = str2;
	val.dsize = strlen(str2);
	status = ypdb_store(db, key, val, YPDB_INSERT);

	if (status != 0) {
		printf("%s: problem storing %s %s\n",
		    __progname, str1, str2);
		exit(1);
	}
}

static char *
file_date(char *filename)
{
	struct	stat finfo;
	static	char datestr[11];
	int	status;

	if (strcmp(filename,"-") == 0) {
		snprintf(datestr, sizeof datestr, "%010lld",
		    (long long)time(0));
	} else {
		status = stat(filename, &finfo);
		if (status < 0) {
			fprintf(stderr, "%s: can't stat %s\n", __progname, filename);
			exit(1);
		}
		snprintf(datestr, sizeof datestr, "%010lld",
		    (long long)finfo.st_mtime);
	}
	return datestr;
}

static void
list_database(char *database, int Uflag)
{
	DBM	*db;
	datum	key, val;

	db = ypdb_open(database, O_RDONLY, 0444);

	if (db == NULL) {
		if (Uflag != 0)
			if (db_hash_list_database(database))
				return;

		fprintf(stderr, "%s: can't open database %s: %s\n", __progname,
		    database, strerror(errno));
		exit(1);
	}

	key = ypdb_firstkey(db);

	while (key.dptr != NULL) {
		val = ypdb_fetch(db, key);
		printf("%*.*s %*.*s\n",
		    key.dsize, key.dsize, key.dptr,
		    val.dsize, val.dsize, val.dptr);
		key = ypdb_nextkey(db);
	}
	ypdb_close(db);
}

static void
create_database(char *infile, char *database, char *yp_input_file,
    char *yp_output_file, char *yp_master_name, char *yp_domain_name,
    int bflag, int lflag, int sflag)
{
	FILE	*data_file;
	char	data_line[4096]; /* XXX: DB bsize = 4096 in ypdb.c */
	char	myname[HOST_NAME_MAX+1];
	int	line_no = 0, len;
	char	*p, *k, *v, *slash;
	DBM	*new_db;
	static	char mapname[] = "ypdbXXXXXXXXXX";
	char	db_mapname[PATH_MAX], db_outfile[PATH_MAX];
	char	db_tempname[PATH_MAX], empty_str[] = "";

	if (strcmp(infile,"-") == 0) {
		data_file = stdin;
	} else {
		data_file = fopen(infile, "r");
		if (errno != 0) {
			(void)fprintf(stderr,"%s: ", __progname);
			perror(infile);
			exit(1);
		}
	}

	if (strlen(database) + strlen(YPDB_SUFFIX) > PATH_MAX) {
		fprintf(stderr,"%s: %s: file name too long\n",
		    __progname, database);
		exit(1);
	}
	snprintf(db_outfile, sizeof(db_outfile), "%s%s", database, YPDB_SUFFIX);

	slash = strrchr(database, '/');
	if (slash != NULL)
		slash[1] = 0;			/* truncate to dir */
	else
		*database = 0;			/* eliminate */

	/* note: database is now directory where map goes ! */

	if (strlen(database) + strlen(mapname) +
	    strlen(YPDB_SUFFIX) > PATH_MAX) {
		fprintf(stderr,"%s: %s: directory name too long\n",
		    __progname, database);
		exit(1);
	}

	snprintf(db_mapname, sizeof(db_mapname), "%s%s%s",
	    database, mapname, YPDB_SUFFIX);
	mkstemps(db_mapname, sizeof(YPDB_SUFFIX));
	strlcpy(db_tempname, db_mapname, sizeof db_tempname);
	db_tempname[strlen(db_tempname) - sizeof(YPDB_SUFFIX) + 1] = '\0';

	new_db = ypdb_open(db_tempname, O_RDWR|O_CREAT, 0444);
	if (new_db == NULL) {
		fprintf(stderr, "%s: Unable to open output database %s\n",
		    __progname, db_outfile);
		exit(1);
	}

	while (read_line(data_file, data_line, sizeof(data_line))) {
		line_no++;
		len =  strlen(data_line);

		/* Check if we have the whole line */

		if (data_line[len-1] != '\n') {
			fprintf(stderr, "line %d in \"%s\" is too long",
			    line_no, infile);
		} else {
			data_line[len-1] = '\0';
		}

		p = (char *) &data_line;

		k = p;				   	 /* save start of key */
		while (!isspace((unsigned char)*p)) {	    	/* find first "space" */
			if (lflag && isupper((unsigned char)*p))   	/* if force lower case */
				*p = (char)tolower((unsigned char)*p);   /* fix it */
			p++;
		}
		while (isspace((unsigned char)*p)) {		/* replace space with <NUL> */
			*p = '\0';
			p++;
		}

		v = p;				/* save start of value */
		while (*p != '\0')		/* find end of string */
			p++;

		add_record(new_db, k, v, TRUE);	/* save record */

	}

	if (strcmp(infile,"-") != 0)
		(void) fclose(data_file);

	add_record(new_db, YP_LAST_KEY, file_date(infile), FALSE);

	if (yp_input_file)
		add_record(new_db, YP_INPUT_KEY, yp_input_file, FALSE);

	if (yp_output_file)
		add_record(new_db, YP_OUTPUT_KEY, yp_output_file, FALSE);

	if (yp_master_name)
		add_record(new_db, YP_MASTER_KEY, yp_master_name, FALSE);
	else {
		gethostname(myname, sizeof(myname));
		add_record(new_db, YP_MASTER_KEY, myname, FALSE);
	}

	if (yp_domain_name)
		add_record(new_db, YP_DOMAIN_KEY, yp_domain_name, FALSE);
	if (bflag)
		add_record(new_db, YP_INTERDOMAIN_KEY, empty_str, FALSE);
	if (sflag)
		add_record(new_db, YP_SECURE_KEY, empty_str, FALSE);

	ypdb_close(new_db);
	if (rename(db_mapname, db_outfile) < 0) {
		perror("rename");
		fprintf(stderr,"rename %s -> %s failed!\n", db_mapname,
		    db_outfile);
		exit(1);
	}

}

static void
usage(void)
{
	fprintf(stderr,"usage: makedbm [-blsUu] [-d yp_domain_name] "
	    "[-i yp_input_file]\n"
	    "\t[-m yp_master_name] [-o yp_output_file] infile outfile\n");
	exit(1);
}

int
main(int argc, char *argv[])
{
	int	aflag, uflag, bflag, lflag, sflag, Uflag;
	char	*yp_input_file, *yp_output_file;
	char	*yp_master_name, *yp_domain_name;
	char	*infile, *outfile;
	int	ch;

	extern int optind;
	extern char *optarg;

	yp_input_file = yp_output_file = NULL;
	yp_master_name = yp_domain_name = NULL;
	aflag = uflag = bflag = lflag = sflag = Uflag = 0;
	infile = outfile = NULL;

	while ((ch = getopt(argc, argv, "Ublsui:o:m:d:")) != -1)
		switch (ch) {
		case 'U':
			uflag = 1;
			Uflag = 1;
			break;
		case 'b':
			bflag = 1;
			aflag = 1;
			break;
		case 'l':
			lflag = 1;
			aflag = 1;
			break;
		case 's':
			sflag = 1;
			aflag = 1;
			break;
		case 'i':
			yp_input_file = optarg;
			aflag = 1;
			break;
		case 'o':
			yp_output_file = optarg;
			aflag = 1;
			break;
		case 'm':
			yp_master_name = optarg;
			aflag = 1;
			break;
		case 'd':
			yp_domain_name = optarg;
			aflag = 1;
			break;
		case 'u':
			uflag = 1;
			break;
		default:
			usage();
			break;
		}

	if ((uflag != 0) && (aflag != 0))
		usage();

	if (uflag != 0) {
		if (argc == (optind + 1))
			infile = argv[optind];
		else
			usage();
	} else {
		if (argc == (optind + 2)) {
			infile = argv[optind];
			outfile = argv[optind+1];
		} else
			usage();
	}

	if (uflag != 0) {
		list_database(infile,Uflag);
	} else {
		create_database(infile, outfile, yp_input_file,
		    yp_output_file, yp_master_name, yp_domain_name,
		    bflag, lflag, sflag);
	}

	return(0);
}
@


1.32
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.31 2013/12/04 02:18:05 deraadt Exp $ */
d316 2
a317 2
			uflag++;
			Uflag++;
d320 2
a321 2
			bflag++;
			aflag++;
d324 2
a325 2
			lflag++;
			aflag++;
d328 2
a329 2
			sflag++;
			aflag++;
d333 1
a333 1
			aflag++;
d337 1
a337 1
			aflag++;
d341 1
a341 1
			aflag++;
d345 1
a345 1
			aflag++;
d348 1
a348 1
			uflag++;
@


1.31
log
@ctype improvements; checked by okan
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.30 2013/08/22 04:43:41 guenther Exp $ */
a33 1
#include <sys/param.h>
d164 1
a164 1
	char	myname[MAXHOSTNAMELEN];
d169 2
a170 2
	char	db_mapname[MAXPATHLEN], db_outfile[MAXPATHLEN];
	char	db_tempname[MAXPATHLEN], empty_str[] = "";
d183 1
a183 1
	if (strlen(database) + strlen(YPDB_SUFFIX) > MAXPATHLEN) {
d199 1
a199 1
	    strlen(YPDB_SUFFIX) > MAXPATHLEN) {
@


1.30
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.29 2009/10/27 23:59:57 deraadt Exp $ */
d234 4
a237 4
		k = p;				    /* save start of key */
		while (!isspace(*p)) {		    /* find first "space" */
			if (lflag && isupper(*p))   /* if force lower case */
				*p = (char)tolower(*p);   /* fix it */
d240 1
a240 1
		while (isspace(*p)) {		/* replace space with <NUL> */
@


1.29
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.28 2007/02/19 21:42:41 jmc Exp $ */
d114 2
a115 1
		snprintf(datestr, sizeof datestr, "%010u", time(0));
d122 2
a123 1
		snprintf(datestr, sizeof datestr, "%010u", finfo.st_mtime);
@


1.28
log
@- simply synopsis and usage()
- order options

mostly from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.27 2006/11/10 20:44:07 mk Exp $ */
a27 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: makedbm.c,v 1.27 2006/11/10 20:44:07 mk Exp $";
#endif
@


1.27
log
@`elminate' etc. is not really the right way to spell `eliminate'.

ok brad
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.26 2006/04/03 05:01:22 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: makedbm.c,v 1.26 2006/04/03 05:01:22 deraadt Exp $";
d293 3
a295 4
	fprintf(stderr,"usage: makedbm [-u | -U] file\n"
	    "       makedbm [-bls] [-i YP_INPUT_FILE] [-o YP_OUTPUT_FILE]\n"
	    "               [-d YP_DOMAIN_NAME] [-m YP_MASTER_NAME] "
	    "infile outfile\n");
@


1.26
log
@spreading the lint love (very minimal things..)
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.25 2005/12/21 01:40:24 millert Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: makedbm.c,v 1.25 2005/12/21 01:40:24 millert Exp $";
d197 1
a197 1
		*database = 0;			/* elminate */
@


1.25
log
@Userland programs should include <errno.h> not <sys/errno.h>
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.24 2005/05/14 02:32:32 deraadt Exp $ */
d29 2
a30 2
#ifndef LINT
static const char rcsid[] = "$OpenBSD: makedbm.c,v 1.24 2005/05/14 02:32:32 deraadt Exp $";
d93 1
a93 1
		val = ypdb_fetch(db,key);
d104 2
a105 1
		printf("%s: problem storing %s %s\n",__progname,str1,str2);
d151 1
a151 1
		val = ypdb_fetch(db,key);
d180 1
a180 1
			(void)fprintf(stderr,"%s: ",__progname);
d221 1
a221 1
	while (read_line(data_file,data_line,sizeof(data_line))) {
d239 1
a239 1
				*p = tolower(*p);   /* fix it */
@


1.24
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.23 2003/07/18 22:58:56 david Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: makedbm.c,v 1.23 2003/07/18 22:58:56 david Exp $";
d41 1
a41 1
#include <sys/errno.h>
@


1.23
log
@add missing includes
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.22 2003/07/15 06:10:46 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: makedbm.c,v 1.22 2003/07/15 06:10:46 deraadt Exp $";
d55 1
a55 3
	int	done;

	done = 0;
d60 1
d65 1
a79 1

d99 1
a99 1
	val.dptr  = str2;
d167 2
a168 4
	int	line_no = 0;
	int	len;
	char	*p, *k, *v;
	char	*slash;
d171 2
a172 3
	char	db_mapname[MAXPATHLEN], db_outfile[MAXPATHLEN],
		db_tempname[MAXPATHLEN];
	char	empty_str[] = "";
d235 1
a235 1
		k  = p;				    /* save start of key */
d304 2
a305 2
	char	*yp_master_name,*yp_domain_name;
	char	*infile,*outfile;
@


1.22
log
@protos and repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.21 2003/06/02 21:58:26 maja Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: makedbm.c,v 1.21 2003/06/02 21:58:26 maja Exp $";
d34 1
@


1.21
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.20 2003/05/05 08:37:05 avsm Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: makedbm.c,v 1.20 2003/05/05 08:37:05 avsm Exp $";
d83 1
a83 1
void
d129 1
a129 1
void
d159 1
a159 1
void
d292 1
a292 1
void
@


1.20
log
@-Wall cleanup: trim unused vars, better err() message in stdhosts,
and constify rcsid[]

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.19 2002/07/19 20:59:40 deraadt Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: makedbm.c,v 1.19 2002/07/19 20:59:40 deraadt Exp $";
@


1.19
log
@bunch more careful tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.18 2002/07/19 02:38:40 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.18 2002/07/19 02:38:40 deraadt Exp $";
@


1.18
log
@4344 lines of KNF diff
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.17 2002/03/20 14:19:30 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.17 2002/03/20 14:19:30 maja Exp $";
d297 10
a313 1
	int	usage = 0;
d362 1
a362 1
			usage++;
d366 8
a373 2
	if ((uflag != 0) && (aflag != 0)) {
		usage++;
d375 5
a379 23

		if (uflag != 0) {
			if (argc == (optind + 1)) {
				infile = argv[optind];
			} else {
				usage++;
			}
		} else {
			if (argc == (optind + 2)) {
				infile = argv[optind];
				outfile = argv[optind+1];
			} else {
				usage++;
			}
		}
	}

	if (usage) {
		fprintf(stderr,"%s%s%s",
		    "usage:\tmakedbm [-u|-U] file\n\tmakedbm [-bls]",
		    " [-i YP_INPUT_FILE] [-o YP_OUTPUT_FILE]\n\t\t",
		    "[-d YP_DOMAIN_NAME] [-m YP_MASTER_NAME] infile outfile\n");
		exit(1);
@


1.17
log
@Improve error message in makedbm. -moj
from Kenneth Ingham <ingham@@i-pi.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.16 2002/02/13 23:05:48 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.16 2002/02/13 23:05:48 deraadt Exp $";
d56 2
a57 4
static int read_line(fp, buf, size)
	FILE	*fp;
	char	*buf;
	int	size;
d73 1
a73 1
				
d88 2
a89 5
void 
add_record(db, str1, str2, check)
	DBM	*db;
	char	*str1, *str2;
	int	check;
d96 1
a96 1
	
a101 1
		
d107 1
a107 1
	
d115 1
a115 2
file_date(filename)
	char	*filename;
d120 1
a120 1
	
d128 1
a128 1
		}	
d135 1
a135 3
list_database(database,Uflag)
	char	*database;
	int	Uflag;
d139 1
a139 1
  	
d141 1
a141 1
	
d144 2
a145 1
			if (db_hash_list_database(database)) return;
d151 1
a151 1
	
d153 1
a153 1
	
a160 1
  
d165 3
a167 7

create_database(infile, database, yp_input_file, yp_output_file,
    yp_master_name, yp_domain_name, bflag, lflag, sflag)
	char	*infile, *database;
	char	*yp_input_file, *yp_output_file;
	char	*yp_master_name, *yp_domain_name;
	int	bflag, lflag, sflag;
d181 1
a181 1
	
d192 1
a192 1
	
d201 2
a202 2
	if (slash != NULL) 
		slash[1] = 0; 			/* truncate to dir */
d227 1
a227 1
	
a228 1
		
d231 3
a233 3
		
		/* Check if we have the whole line */ 
		
d240 1
a240 1
		
d242 1
a242 1
		
d253 1
a253 1
		
d256 2
a257 2
			p++;	
		
d259 1
a259 1
		
d261 1
a261 1
	
d264 1
a264 1
	
d269 1
a269 1
	
d272 1
a272 1
	
d279 1
a279 1
	
d294 1
a294 1
	
d298 1
a298 3
main (argc,argv)
	int	argc;
	char	*argv[];
d309 1
a309 1
	
d314 1
a314 1
	
d317 1
a317 1
		case 'U': 
d322 1
a322 1
	  		bflag++;
d356 1
a356 1
	
d360 1
a360 1
		
d376 1
a376 1
	
d384 1
a384 1
	
d392 1
a392 1
	
a393 1
	
@


1.16
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.15 2001/10/24 14:40:00 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.15 2001/10/24 14:40:00 deraadt Exp $";
d155 2
a156 1
		fprintf(stderr, "%s: can't open database %s\n", __progname, database);
@


1.15
log
@pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.14 2001/02/05 14:47:16 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.14 2001/02/05 14:47:16 deraadt Exp $";
d185 1
a185 1
	int	len, fd;
a192 1
	int	count = 0;
@


1.14
log
@sprintf purge
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.13 1999/04/22 17:43:10 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.13 1999/04/22 17:43:10 deraadt Exp $";
d70 1
a70 1
					buf[len-1] == '\n') {
d78 2
a79 2
					isascii(ch) && isspace(ch))
						;
d94 1
a94 1
	int     check;
d96 2
a97 2
        datum   key, val;
        int     status;
d103 1
a103 1
	        val = ypdb_fetch(db,key);
d110 1
a110 1
        val.dptr  = str2;
d162 1
a162 1
	        val = ypdb_fetch(db,key);
d164 2
a165 2
		       key.dsize, key.dsize, key.dptr,
		       val.dsize, val.dsize, val.dptr);
d179 1
a179 1
	int	bflag, lflag, sflag;        
d208 1
a208 1
			__progname, database);
d250 1
a250 1
				line_no, infile);
d257 1
a257 1
		k  = p;				     /* save start of key */
d305 1
a305 1
			db_outfile);
@


1.13
log
@fix mktemp trash, indent; bug spotted by bmw@@visgen.com
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.12 1998/09/17 22:58:38 niklas Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.12 1998/09/17 22:58:38 niklas Exp $";
d129 1
a129 1
		sprintf(datestr, "%010d", time(0));
d136 1
a136 1
		sprintf(datestr, "%010d", finfo.st_mtime);
@


1.12
log
@Use optarg, not argv[optind]
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.11 1998/07/09 06:33:03 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.11 1998/07/09 06:33:03 deraadt Exp $";
d96 1
a96 1
        datum   key,val;
a137 1
  	
d147 1
a147 1
	datum	key,val;
d152 1
a152 3

		if (Uflag != 0) {
			
a153 3
			
		}

d168 1
a168 1
	  
a169 1
	
d174 2
a175 4
create_database(infile,database,
		yp_input_file,yp_output_file,
		yp_master_name,yp_domain_name,
		bflag, lflag, sflag)
d186 1
a186 1
	char	*p,*k,*v;
d190 1
a190 1
	char	db_mapname[MAXPATHLEN],db_outfile[MAXPATHLEN],
d193 1
d221 2
a222 2
	if (strlen(database) + strlen(mapname) 
			+ strlen(YPDB_SUFFIX) > MAXPATHLEN) {
d228 5
a232 6
	snprintf(db_tempname, sizeof(db_tempname), "%s%s", database,
		mapname);
	fd = mkstemp(db_tempname);
	if (fd == -1)
		goto fail;
	close(fd);
a233 2
	snprintf(db_mapname, sizeof(db_mapname), "%s%s", db_tempname,
	    YPDB_SUFFIX);
a235 3
fail:
		if (fd != -1)
			unlink(db_tempname);
d262 1
a262 1
		};
d266 1
a266 1
		};
d269 2
a270 1
		while(*p != '\0') { p++; };	/* find end of string */
d276 1
a276 1
	if (strcmp(infile,"-") != 0) {
a277 1
	}
d280 2
a281 2
	
	if (yp_input_file) {
a282 1
	}
d284 1
a284 1
	if (yp_output_file) {
a285 1
	}
d287 1
a287 1
	if (yp_master_name) {
d289 1
a289 1
	} else {
d294 1
a294 1
	if (yp_domain_name) {
d296 1
a296 3
	}
	
	if (bflag) {
d298 1
a298 3
	}

	if (sflag) {
a299 1
	}
d302 1
a302 1
	if (rename(db_mapname,db_outfile) < 0) {
d333 38
a370 38
			case 'U': 
				uflag++;
				Uflag++;
				break;
			case 'b':
		  		bflag++;
				aflag++;
				break;
			case 'l':
				lflag++;
				aflag++;
				break;
			case 's':
				sflag++;
				aflag++;
				break;
			case 'i':
				yp_input_file = optarg;
				aflag++;
				break;
			case 'o':
				yp_output_file = optarg;
				aflag++;
				break;
			case 'm':
				yp_master_name = optarg;
				aflag++;
				break;
			case 'd':
				yp_domain_name = optarg;
				aflag++;
				break;
			case 'u':
				uflag++;
				break;
			default:
				usage++;
				break;
d395 3
a397 3
			"usage:\tmakedbm [-u|-U] file\n\tmakedbm [-bls]",
			" [-i YP_INPUT_FILE] [-o YP_OUTPUT_FILE]\n\t\t",
			"[-d YP_DOMAIN_NAME] [-m YP_MASTER_NAME] infile outfile\n");
d404 3
a406 4
		create_database(infile,outfile,
				yp_input_file,yp_output_file,
				yp_master_name,yp_domain_name,
				bflag, lflag, sflag);
@


1.11
log
@do not gethostname with len-1
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.10 1998/03/12 08:22:27 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.10 1998/03/12 08:22:27 deraadt Exp $";
d343 1
a343 1
	
d345 1
d371 1
a371 1
				yp_input_file = argv[optind];
d375 1
a375 1
				yp_output_file = argv[optind];
d379 1
a379 1
				yp_master_name = argv[optind];
d383 1
a383 1
				yp_domain_name = argv[optind];
@


1.10
log
@mkstemp()
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.9 1997/08/18 03:11:34 millert Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.9 1997/08/18 03:11:34 millert Exp $";
d306 1
a306 1
		gethostname(myname, sizeof(myname) - 1);
@


1.9
log
@#include <string.h> not <strings.h> -- Yes, I'm a weanie...
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.8 1997/07/22 10:53:01 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.8 1997/07/22 10:53:01 maja Exp $";
d194 1
a194 1
	int	len;
d232 1
a232 1
			__progname, database);
d238 5
a242 1
	mktemp(db_tempname);
d244 1
a244 2
		YPDB_SUFFIX);

d246 8
@


1.8
log
@Added support for reading db files created by sendmail -bi. This is the
first step to support mail.aliases and mail.byaddr in ypserv. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.7 1997/04/04 18:41:46 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.7 1997/04/04 18:41:46 deraadt Exp $";
d44 1
a44 1
#include <strings.h>
@


1.7
log
@when mktemp() is hard to fix, use 10 X
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.6 1997/01/17 07:14:32 millert Exp $ */
d4 1
a4 1
 * Copyright (c) 1994 Mats O Jansson <moj@@stacken.kth.se>
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.6 1997/01/17 07:14:32 millert Exp $";
d48 1
d50 1
a50 1
char *ProgramName = "makedbm";
d115 1
a115 1
		printf("%s: problem storing %s %s\n",ProgramName,str1,str2);
d133 1
a133 1
			fprintf(stderr, "%s: can't stat %s\n", ProgramName, filename);
d143 1
a143 1
list_database(database)
d145 1
d153 9
a161 1
		fprintf(stderr, "%s: can't open database %s\n", ProgramName, database);
d208 1
a208 1
			(void)fprintf(stderr,"%s: ",ProgramName);
d216 1
a216 1
			ProgramName, database);
d232 1
a232 1
			ProgramName, database);
d326 1
a326 1
	int	aflag, uflag, bflag, lflag, sflag;
d337 1
a337 1
	aflag = uflag = bflag = lflag = sflag = 0;
d340 1
a340 1
	while ((ch = getopt(argc, argv, "blsui:o:m:d:")) != -1)
d342 4
d404 1
a404 1
			"usage:\tmakedbm -u file\n\tmakedbm [-bls]",
d411 1
a411 1
		list_database(infile);
@


1.6
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.5 1997/01/15 23:44:32 millert Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.5 1997/01/15 23:44:32 millert Exp $";
d188 1
a188 1
	static	char mapname[] = "ypdbXXXXXX";
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.4 1996/06/26 21:26:35 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.4 1996/06/26 21:26:35 maja Exp $";
d211 1
a211 1
	slash = rindex(database, '/');
@


1.4
log
@Same copyright all over, removed my name from ypdb.[ch], small bugfix
in ypserv_db.c /moj
@
text
@d1 1
a1 1
/*	$OpenBSD: makedbm.c,v 1.3 1996/05/30 09:53:06 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: makedbm.c,v 1.3 1996/05/30 09:53:06 deraadt Exp $";
d330 1
a330 1
	while ((ch = getopt(argc, argv, "blsui:o:m:d:")) != EOF)
@


1.3
log
@$OpenBSD$ tag and few spelling errors
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d15 5
a19 3
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
d35 1
a35 1
static char rcsid[] = "$OpenBSD$";
@


1.2
log
@various changes (from me):
 - don't store null in the database
 - use MAXPATHLEN
 - avoid sprintf() buffer overflows
 - minor cleanups
@
text
@d1 2
d33 1
a33 1
static char rcsid[] = "$Id: makedbm.c,v 1.1 1995/11/01 16:56:24 deraadt Exp $";
@


1.1
log
@+ full set of ypserv tools that compile
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: makedbm.c,v 1.7 1995/09/07 22:24:45 moj Exp $";
d38 1
d95 1
a95 1
	key.dsize = strlen(str1) + 1;
d100 3
a102 11
		if (val.dptr == NULL) {
			val.dptr  = str2;
			val.dsize = strlen(str2) + 1;
			status = ypdb_store(db, key, val, YPDB_INSERT);
		} else {
			status = 0;
		}
	} else {
	        val.dptr  = str2;
		val.dsize = strlen(str2) + 1;
		status = ypdb_store(db, key, val, YPDB_INSERT);
d104 4
d120 1
a120 1
	static	char datestr[10];
d156 2
a157 2
		       key.dsize - 1,key.dsize - 1,key.dptr,
		       val.dsize - 1,val.dsize - 1,val.dptr);
d177 2
a178 2
	char	data_line[4096];
	char	myname[255];
a180 1
	int	i,j;
d182 1
d185 2
a186 1
	char	db_mapname[255],db_outfile[255],db_tempname[255];
d200 20
a219 16
	j = 0;
	for (i=0; i<strlen(database); i++) {
		if (database[i] == '/') {
			j = i;
		}
	};
	
	for (i=0; i<j; i++) 
		db_tempname[i] = database[i];
	
	if (i != 0)
		db_tempname[i++] = '/';
	
	for (j=0; j<strlen(mapname); j++) {
		db_tempname[i+j] = mapname[j];
		db_tempname[i+j+1] = '\0';
d221 3
a223 1
	
d225 3
d298 6
a303 3
	sprintf(db_mapname,"%s%s",db_tempname,YPDB_SUFFIX);
	sprintf(db_outfile,"%s%s",database,YPDB_SUFFIX);
	rename(db_mapname,db_outfile);
a403 2


@

