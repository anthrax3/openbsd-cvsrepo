head	1.46;
access;
symbols
	OPENBSD_6_2:1.46.0.2
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.44.0.4
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.38.0.10
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.38.0.6
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.36.0.8
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.6
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.4
	OPENBSD_5_0:1.36.0.2
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.35.0.4
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12;
locks; strict;
comment	@ * @;


1.46
date	2017.08.12.22.09.54;	author benno;	state Exp;
branches;
next	1.45;
commitid	l6oJ2wztJM8yTyS2;

1.45
date	2017.06.19.19.55.57;	author friehm;	state Exp;
branches;
next	1.44;
commitid	qQdgRe10zVbyVHr2;

1.44
date	2016.12.22.23.03.55;	author jca;	state Exp;
branches;
next	1.43;
commitid	66JRN1ozBDz414Lx;

1.43
date	2015.12.05.13.12.40;	author claudio;	state Exp;
branches;
next	1.42;
commitid	4xNKczBxYPO9zMjt;

1.42
date	2015.12.03.17.16.39;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	I1lLcSm8MKhDuQEu;

1.41
date	2015.10.10.00.19.52;	author benno;	state Exp;
branches;
next	1.40;
commitid	Zlk1SjlGKwIVatcO;

1.40
date	2015.09.27.17.31.50;	author stsp;	state Exp;
branches;
next	1.39;
commitid	kLBPo9HaQrkEaNW3;

1.39
date	2015.09.13.11.13.12;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	HmZqjbpn4mjxGSj3;

1.38
date	2013.11.13.22.52.41;	author sthen;	state Exp;
branches;
next	1.37;

1.37
date	2013.03.22.14.25.31;	author sthen;	state Exp;
branches;
next	1.36;

1.36
date	2011.05.05.15.58.53;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.12.09.48.39;	author bluhm;	state Exp;
branches;
next	1.34;

1.34
date	2010.02.25.16.40.23;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2010.02.23.16.32.55;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2009.12.23.18.01.31;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2009.12.22.17.55.04;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.02.20.25.27;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2009.09.14.11.49.25;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.28.19.05.22;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.06.09.02.46;	author eric;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.29.18.31.47;	author stsp;	state Exp;
branches;
next	1.25;

1.25
date	2009.03.29.16.08.23;	author stsp;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.30.22.23.30;	author stsp;	state Exp;
branches;
next	1.23;

1.23
date	2009.01.29.20.09.02;	author stsp;	state Exp;
branches;
next	1.22;

1.22
date	2009.01.29.19.39.41;	author stsp;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.29.16.34.32;	author stsp;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.28.22.51.26;	author stsp;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.28.17.34.15;	author stsp;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.01.23.41.42;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.30.21.33.52;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2008.12.28.22.05.04;	author sobrado;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.28.21.32.33;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.28.21.23.51;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2008.12.28.18.31.52;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.13.08.57.32;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.27.12.24.55;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.16.21.58.58;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.16.21.37.45;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.16.12.07.58;	author norby;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.16.08.43.44;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.16.08.07.56;	author norby;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.15.02.16.35;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.14.01.28.06;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.12.09.29.45;	author norby;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.12.09.23.37;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.12.08.22.53;	author norby;	state Exp;
branches;
next	;


desc
@@


1.46
log
@fix the else case (i.e. LSA_IS_SCOPE_AS) where header could remain
uninitialized. found by clang.
ok claudio@@
@
text
@/*	$OpenBSD: ospf6ctl.c,v 1.45 2017/06/19 19:55:57 friehm Exp $ */

/*
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if_media.h>
#include <net/if_types.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ospf6.h"
#include "ospf6d.h"
#include "ospfe.h"
#include "parser.h"
#include "log.h"

__dead void	 usage(void);
int		 show_summary_msg(struct imsg *);
uint64_t	 get_ifms_type(uint8_t);
int		 show_interface_msg(struct imsg *);
int		 show_interface_detail_msg(struct imsg *);
const char	*print_link(int);
const char	*fmt_timeframe(time_t t);
const char	*fmt_timeframe_core(time_t t);
const char	*log_id(u_int32_t );
const char	*log_adv_rtr(u_int32_t);
void		 show_database_head(struct in_addr, char *, u_int16_t);
int		 show_database_msg(struct imsg *);
char		*print_ls_type(u_int16_t);
void		 show_db_hdr_msg_detail(struct lsa_hdr *);
char		*print_rtr_link_type(u_int8_t);
const char	*print_ospf_flags(u_int8_t);
const char	*print_asext_flags(u_int32_t);
const char	*print_prefix_opt(u_int8_t);
int		 show_db_msg_detail(struct imsg *imsg);
int		 show_nbr_msg(struct imsg *);
const char	*print_ospf_options(u_int32_t);
int		 show_nbr_detail_msg(struct imsg *);
int		 show_rib_msg(struct imsg *);
void		 show_rib_head(struct in_addr, u_int8_t, u_int8_t);
const char	*print_ospf_rtr_flags(u_int8_t);
int		 show_rib_detail_msg(struct imsg *);
void		 show_fib_head(void);
int		 show_fib_msg(struct imsg *);
const char *	 get_media_descr(uint64_t);
const char *	 get_linkstate(uint8_t, int);
void		 print_baudrate(u_int64_t);

struct imsgbuf	*ibuf;

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-s socket] command [argument ...]\n",
	    __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	struct sockaddr_un	 sun;
	struct parse_result	*res;
	struct imsg		 imsg;
	unsigned int		 ifidx = 0;
	int			 ctl_sock;
	int			 done = 0, verbose = 0;
	int			 n;
	int			 ch;
	char			*sockname;

	sockname = OSPF6D_SOCKET;
	while ((ch = getopt(argc, argv, "s:")) != -1) {
		switch (ch) {
		case 's':
			sockname = optarg;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;

	/* parse options */
	if ((res = parse(argc, argv)) == NULL)
		exit(1);

	/* connect to ospf6d control socket */
	if ((ctl_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		err(1, "socket");

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	strlcpy(sun.sun_path, sockname, sizeof(sun.sun_path));
	if (connect(ctl_sock, (struct sockaddr *)&sun, sizeof(sun)) == -1)
		err(1, "connect: %s", sockname);

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
		err(1, NULL);
	imsg_init(ibuf, ctl_sock);
	done = 0;

	/* process user request */
	switch (res->action) {
	case NONE:
		usage();
		/* not reached */
	case SHOW:
	case SHOW_SUM:
		imsg_compose(ibuf, IMSG_CTL_SHOW_SUM, 0, 0, -1, NULL, 0);
		break;
	case SHOW_IFACE:
		printf("%-11s %-29s %-6s %-10s %-10s %-8s\n",
		    "Interface", "Address", "State", "HelloTimer", "Linkstate",
		    "Uptime");
		/*FALLTHROUGH*/
	case SHOW_IFACE_DTAIL:
		if (*res->ifname) {
			ifidx = if_nametoindex(res->ifname);
			if (ifidx == 0)
				errx(1, "no such interface %s", res->ifname);
		}
		imsg_compose(ibuf, IMSG_CTL_SHOW_INTERFACE, 0, 0, -1,
		    &ifidx, sizeof(ifidx));
		break;
	case SHOW_NBR:
		printf("%-15s %-3s %-12s %-9s %-11s %s\n", "ID", "Pri",
		    "State", "DeadTime", "Iface","Uptime");
		/*FALLTHROUGH*/
	case SHOW_NBR_DTAIL:
		imsg_compose(ibuf, IMSG_CTL_SHOW_NBR, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DB:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DATABASE, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DBBYAREA:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DATABASE, 0, 0, -1,
		    &res->addr, sizeof(res->addr));
		break;
	case SHOW_DBEXT:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_EXT, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DBLINK:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_LINK, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DBNET:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_NET, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DBRTR:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_RTR, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DBINTRA:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_INTRA, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DBSELF:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_SELF, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DBSUM:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_SUM, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DBASBR:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_ASBR, 0, 0, -1, NULL, 0);
		break;
	case SHOW_RIB:
		printf("%-20s %-17s %-12s %-9s %-7s %-8s\n", "Destination",
		    "Nexthop", "Path Type", "Type", "Cost", "Uptime");
		/*FALLTHROUGH*/
	case SHOW_RIB_DTAIL:
		imsg_compose(ibuf, IMSG_CTL_SHOW_RIB, 0, 0, -1, NULL, 0);
		break;
	case SHOW_FIB:
		if (IN6_IS_ADDR_UNSPECIFIED(&res->addr))
			imsg_compose(ibuf, IMSG_CTL_KROUTE, 0, 0, -1,
			    &res->flags, sizeof(res->flags));
		else
			imsg_compose(ibuf, IMSG_CTL_KROUTE_ADDR, 0, 0, -1,
			    &res->addr, sizeof(res->addr));
		show_fib_head();
		break;
	case FIB:
		errx(1, "fib couple|decouple");
		break;
	case FIB_COUPLE:
		imsg_compose(ibuf, IMSG_CTL_FIB_COUPLE, 0, 0, -1, NULL, 0);
		printf("couple request sent.\n");
		done = 1;
		break;
	case FIB_DECOUPLE:
		imsg_compose(ibuf, IMSG_CTL_FIB_DECOUPLE, 0, 0, -1, NULL, 0);
		printf("decouple request sent.\n");
		done = 1;
		break;
	case LOG_VERBOSE:
		verbose = 1;
		/* FALLTHROUGH */
	case LOG_BRIEF:
		imsg_compose(ibuf, IMSG_CTL_LOG_VERBOSE, 0, 0, -1,
		    &verbose, sizeof(verbose));
		printf("logging request sent.\n");
		done = 1;
		break;
	case RELOAD:
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, -1, NULL, 0);
		printf("reload request sent.\n");
		done = 1;
		break;
	}

	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
			err(1, "write error");

	while (!done) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");

		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				errx(1, "imsg_get error");
			if (n == 0)
				break;
			switch (res->action) {
			case SHOW:
			case SHOW_SUM:
				done = show_summary_msg(&imsg);
				break;
			case SHOW_IFACE:
				done = show_interface_msg(&imsg);
				break;
			case SHOW_IFACE_DTAIL:
				done = show_interface_detail_msg(&imsg);
				break;
			case SHOW_NBR:
				done = show_nbr_msg(&imsg);
				break;
			case SHOW_NBR_DTAIL:
				done = show_nbr_detail_msg(&imsg);
				break;
			case SHOW_DB:
			case SHOW_DBBYAREA:
			case SHOW_DBSELF:
				done = show_database_msg(&imsg);
				break;
			case SHOW_DBEXT:
			case SHOW_DBLINK:
			case SHOW_DBNET:
			case SHOW_DBRTR:
			case SHOW_DBINTRA:
			case SHOW_DBSUM:
			case SHOW_DBASBR:
				done = show_db_msg_detail(&imsg);
				break;
			case SHOW_RIB:
				done = show_rib_msg(&imsg);
				break;
			case SHOW_RIB_DTAIL:
				done = show_rib_detail_msg(&imsg);
				break;
			case SHOW_FIB:
				done = show_fib_msg(&imsg);
				break;
			case NONE:
			case FIB:
			case FIB_COUPLE:
			case FIB_DECOUPLE:
			case LOG_VERBOSE:
			case LOG_BRIEF:
			case RELOAD:
				break;
			}
			imsg_free(&imsg);
		}
	}
	close(ctl_sock);
	free(ibuf);

	return (0);
}

int
show_summary_msg(struct imsg *imsg)
{
	struct ctl_sum		*sum;
	struct ctl_sum_area	*sumarea;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_SUM:
		sum = imsg->data;
		printf("Router ID: %s\n", inet_ntoa(sum->rtr_id));
		printf("Uptime: %s\n", fmt_timeframe_core(sum->uptime));

		printf("SPF delay is %d sec(s), hold time between two SPFs "
		    "is %d sec(s)\n", sum->spf_delay, sum->spf_hold_time);
		printf("Number of external LSA(s) %d\n", sum->num_ext_lsa);
		printf("Number of areas attached to this router: %d\n",
		    sum->num_area);
		break;
	case IMSG_CTL_SHOW_SUM_AREA:
		sumarea = imsg->data;
		printf("\nArea ID: %s\n", inet_ntoa(sumarea->area));
		printf("  Number of interfaces in this area: %d\n",
		    sumarea->num_iface);
		printf("  Number of fully adjacent neighbors in this "
		    "area: %d\n", sumarea->num_adj_nbr);
		printf("  SPF algorithm executed %d time(s)\n",
		    sumarea->num_spf_calc);
		printf("  Number LSA(s) %d\n", sumarea->num_lsa);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

uint64_t
get_ifms_type(uint8_t if_type)
{
	switch (if_type) {
	case IFT_ETHER:
		return (IFM_ETHER);
	case IFT_FDDI:
		return (IFM_FDDI);
	case IFT_CARP:
		return (IFM_CARP);
	case IFT_PPP:
		return (IFM_TDM);
	default:
		return (0);
	}
}

int
show_interface_msg(struct imsg *imsg)
{
	struct ctl_iface	*iface;
	char			*netid;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_INTERFACE:
		iface = imsg->data;

		if (asprintf(&netid, "%s", log_in6addr(&iface->addr)) == -1)
			err(1, NULL);
		printf("%-11s %-29s %-6s %-10s %-10s %s\n",
		    iface->name, netid, if_state_name(iface->state),
		    fmt_timeframe_core(iface->hello_timer),
		    get_linkstate(iface->if_type, iface->linkstate),
		    fmt_timeframe_core(iface->uptime));
		free(netid);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_interface_detail_msg(struct imsg *imsg)
{
	struct ctl_iface	*iface;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_INTERFACE:
		iface = imsg->data;
		printf("\n");
		printf("Interface %s, line protocol is %s\n",
		    iface->name, print_link(iface->flags));
		printf("  Internet address %s Area %s\n",
		    log_in6addr(&iface->addr), inet_ntoa(iface->area));
		printf("  Link type %s, state %s, mtu %d",
		    get_media_descr(get_ifms_type(iface->if_type)),
		    get_linkstate(iface->if_type, iface->linkstate),
		    iface->mtu);
		if (iface->linkstate != LINK_STATE_DOWN &&
		    iface->baudrate > 0) {
		    printf(", ");
		    print_baudrate(iface->baudrate);
		}
		printf("\n");
		printf("  Router ID %s, network type %s, cost: %d\n",
		    inet_ntoa(iface->rtr_id),
		    if_type_name(iface->type), iface->metric);
		printf("  Transmit delay is %d sec(s), state %s, priority %d\n",
		    iface->transmit_delay, if_state_name(iface->state),
		    iface->priority);
		printf("  Designated Router (ID) %s\n",
		    inet_ntoa(iface->dr_id));
		printf("    Interface address %s\n",
		    log_in6addr(&iface->dr_addr));
		printf("  Backup Designated Router (ID) %s\n",
		    inet_ntoa(iface->bdr_id));
		printf("    Interface address %s\n",
		    log_in6addr(&iface->bdr_addr));
		printf("  Timer intervals configured, "
		    "hello %d, dead %d, wait %d, retransmit %d\n",
		     iface->hello_interval, iface->dead_interval,
		     iface->dead_interval, iface->rxmt_interval);
		if (iface->passive)
			printf("    Passive interface (No Hellos)\n");
		else if (iface->hello_timer < 0)
			printf("    Hello timer not running\n");
		else
			printf("    Hello timer due in %s\n",
			    fmt_timeframe_core(iface->hello_timer));
		printf("    Uptime %s\n", fmt_timeframe_core(iface->uptime));
		printf("  Neighbor count is %d, adjacent neighbor count is "
		    "%d\n", iface->nbr_cnt, iface->adj_cnt);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

const char *
print_link(int state)
{
	if (state & IFF_UP)
		return ("UP");
	else
		return ("DOWN");
}

#define TF_BUFS	8
#define TF_LEN	9

const char *
fmt_timeframe(time_t t)
{
	if (t == 0)
		return ("Never");
	else
		return (fmt_timeframe_core(time(NULL) - t));
}

const char *
fmt_timeframe_core(time_t t)
{
	char		*buf;
	static char	 tfbuf[TF_BUFS][TF_LEN];	/* ring buffer */
	static int	 idx = 0;
	unsigned int	 sec, min, hrs, day, week;

	if (t == 0)
		return ("00:00:00");

	buf = tfbuf[idx++];
	if (idx == TF_BUFS)
		idx = 0;

	week = t;

	sec = week % 60;
	week /= 60;
	min = week % 60;
	week /= 60;
	hrs = week % 24;
	week /= 24;
	day = week % 7;
	week /= 7;

	if (week > 0)
		snprintf(buf, TF_LEN, "%02uw%01ud%02uh", week, day, hrs);
	else if (day > 0)
		snprintf(buf, TF_LEN, "%01ud%02uh%02um", day, hrs, min);
	else
		snprintf(buf, TF_LEN, "%02u:%02u:%02u", hrs, min, sec);

	return (buf);
}

const char *
log_id(u_int32_t id)
{
	static char	buf[48];
	struct in_addr	addr;

	addr.s_addr = id;

	if (inet_ntop(AF_INET, &addr, buf, sizeof(buf)) == NULL)
		return ("?");
	else
		return (buf);
}

const char *
log_adv_rtr(u_int32_t adv_rtr)
{
	static char	buf[48];
	struct in_addr	addr;

	addr.s_addr = adv_rtr;

	if (inet_ntop(AF_INET, &addr, buf, sizeof(buf)) == NULL)
		return ("?");
	else
		return (buf);
}

void
show_database_head(struct in_addr aid, char *ifname, u_int16_t type)
{
	char	*header, *format;
	int	cleanup = 0;

	switch (ntohs(type)) {
	case LSA_TYPE_LINK:
		format = "Link (Type-8) Link States";
		break;
	case LSA_TYPE_ROUTER:
		format = "Router Link States";
		break;
	case LSA_TYPE_NETWORK:
		format = "Net Link States";
		break;
	case LSA_TYPE_INTER_A_PREFIX:
		format = "Inter Area Prefix Link States";
		break;
	case LSA_TYPE_INTER_A_ROUTER:
		format = "Inter Area Router Link States";
		break;
	case LSA_TYPE_INTRA_A_PREFIX:
		format = "Intra Area Prefix Link States";
		break;
	case LSA_TYPE_EXTERNAL:
		printf("\n%-15s %s\n\n", "", "Type-5 AS External Link States");
		return;
	default:
		if (asprintf(&format, "LSA type %x", ntohs(type)) == -1)
			err(1, NULL);
		cleanup = 1;
		break;
	}
	if (LSA_IS_SCOPE_AREA(ntohs(type))) {
		if (asprintf(&header, "%s (Area %s)", format,
		    inet_ntoa(aid)) == -1)
			err(1, NULL);
	} else if (LSA_IS_SCOPE_LLOCAL(ntohs(type))) {
		if (asprintf(&header, "%s (Area %s Interface %s)", format,
		    inet_ntoa(aid), ifname) == -1)
			err(1, NULL);
	} else {
		if (asprintf(&header, "%s", format) == -1)
			err(1, NULL);
	}

	printf("\n%-15s %s\n\n", "", header);
	free(header);
	if (cleanup)
		free(format);
}

int
show_database_msg(struct imsg *imsg)
{
	static struct in_addr	 area_id;
	static char		 ifname[IF_NAMESIZE];
	static u_int16_t	 lasttype;
	struct area		*area;
	struct iface		*iface;
	struct lsa_hdr		*lsa;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_DATABASE:
	case IMSG_CTL_SHOW_DB_SELF:
		lsa = imsg->data;
		if (lsa->type != lasttype) {
			show_database_head(area_id, ifname, lsa->type);
			printf("%-15s %-15s %-4s %-10s %-8s\n", "Link ID",
			    "Adv Router", "Age", "Seq#", "Checksum");
		}
		printf("%-15s %-15s %-4d 0x%08x 0x%04x\n",
		    log_id(lsa->ls_id), log_adv_rtr(lsa->adv_rtr),
		    ntohs(lsa->age), ntohl(lsa->seq_num),
		    ntohs(lsa->ls_chksum));
		lasttype = lsa->type;
		break;
	case IMSG_CTL_AREA:
		area = imsg->data;
		area_id = area->id;
		lasttype = 0;
		break;
	case IMSG_CTL_IFACE:
		iface = imsg->data;
		strlcpy(ifname, iface->name, sizeof(ifname));
		lasttype = 0;
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

char *
print_ls_type(u_int16_t type)
{
	switch (ntohs(type)) {
	case LSA_TYPE_LINK:
		return ("Link");
	case LSA_TYPE_ROUTER:
		return ("Router");
	case LSA_TYPE_NETWORK:
		return ("Network");
	case LSA_TYPE_INTER_A_PREFIX:
		return ("Inter Area (Prefix)");
	case LSA_TYPE_INTER_A_ROUTER:
		return ("Inter Area (Router)");
	case LSA_TYPE_INTRA_A_PREFIX:
		return ("Intra Area (Prefix)");
	case LSA_TYPE_EXTERNAL:
		return ("AS External");
	default:
		return ("Unknown");
	}
}

void
show_db_hdr_msg_detail(struct lsa_hdr *lsa)
{
	printf("LS age: %d\n", ntohs(lsa->age));
	printf("LS Type: %s\n", print_ls_type(lsa->type));

	switch (ntohs(lsa->type)) {
	case LSA_TYPE_ROUTER:
	case LSA_TYPE_INTER_A_PREFIX:
	case LSA_TYPE_INTER_A_ROUTER:
	case LSA_TYPE_INTRA_A_PREFIX:
	case LSA_TYPE_EXTERNAL:
		printf("Link State ID: %s\n", log_id(lsa->ls_id));
		break;
	case LSA_TYPE_LINK:
		printf("Link State ID: %s (Interface ID of Advertising "
		    "Router)\n", log_id(lsa->ls_id));
		break;
	case LSA_TYPE_NETWORK:
		printf("Link State ID: %s (Interface ID of Designated "
		    "Router)\n", log_id(lsa->ls_id));
		break;
	}

	printf("Advertising Router: %s\n", log_adv_rtr(lsa->adv_rtr));
	printf("LS Seq Number: 0x%08x\n", ntohl(lsa->seq_num));
	printf("Checksum: 0x%04x\n", ntohs(lsa->ls_chksum));
	printf("Length: %d\n", ntohs(lsa->len));
}

char *
print_rtr_link_type(u_int8_t type)
{
	switch (type) {
	case LINK_TYPE_POINTTOPOINT:
		return ("Point-to-Point");
	case LINK_TYPE_TRANSIT_NET:
		return ("Transit Network");
	case LINK_TYPE_RESERVED:
		return ("Reserved");
	case LINK_TYPE_VIRTUAL:
		return ("Virtual Link");
	default:
		return ("Unknown");
	}
}

const char *
print_ospf_flags(u_int8_t opts)
{
	static char	optbuf[32];

	snprintf(optbuf, sizeof(optbuf), "*|*|*|*|*|%s|%s|%s",
	    opts & OSPF_RTR_V ? "V" : "-",
	    opts & OSPF_RTR_E ? "E" : "-",
	    opts & OSPF_RTR_B ? "B" : "-");
	return (optbuf);
}

const char *
print_asext_flags(u_int32_t opts)
{
	static char	optbuf[32];

	snprintf(optbuf, sizeof(optbuf), "*|*|*|*|*|%s|%s|%s",
	    opts & LSA_ASEXT_E_FLAG ? "E" : "-",
	    opts & LSA_ASEXT_F_FLAG ? "F" : "-",
	    opts & LSA_ASEXT_T_FLAG ? "T" : "-");
	return (optbuf);
}

const char *
print_prefix_opt(u_int8_t opts)
{
	static char	optbuf[32];

	if (opts) {
		snprintf(optbuf, sizeof(optbuf),
		    " Options: *|*|*|%s|%s|x|%s|%s",
		    opts & OSPF_PREFIX_DN ? "DN" : "-",
		    opts & OSPF_PREFIX_P ? "P" : "-",
		    opts & OSPF_PREFIX_LA ? "LA" : "-",
		    opts & OSPF_PREFIX_NU ? "NU" : "-");
		return (optbuf);
	}
	return ("");
}

int
show_db_msg_detail(struct imsg *imsg)
{
	static struct in_addr	 area_id;
	static char		 ifname[IF_NAMESIZE];
	static u_int16_t	 lasttype;
	struct in6_addr		 ia6;
	struct in_addr		 addr, data;
	struct area		*area;
	struct iface		*iface;
	struct lsa		*lsa;
	struct lsa_rtr_link	*rtr_link;
	struct lsa_net_link	*net_link;
	struct lsa_prefix	*prefix;
	struct lsa_asext	*asext;
	u_int32_t		 ext_tag;
	u_int16_t		 i, nlinks, off;

	/* XXX sanity checks! */

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_DB_EXT:
		lsa = imsg->data;
		if (lsa->hdr.type != lasttype)
			show_database_head(area_id, ifname, lsa->hdr.type);
		show_db_hdr_msg_detail(&lsa->hdr);

		asext = (struct lsa_asext *)((char *)lsa + sizeof(lsa->hdr));

		printf("    Flags: %s\n",
		    print_asext_flags(ntohl(lsa->data.asext.metric)));
		printf("    Metric: %d Type: ", ntohl(asext->metric)
		    & LSA_METRIC_MASK);
		if (ntohl(lsa->data.asext.metric) & LSA_ASEXT_E_FLAG)
			printf("2\n");
		else
			printf("1\n");

		prefix = &asext->prefix;
		bzero(&ia6, sizeof(ia6));
		bcopy(prefix + 1, &ia6, LSA_PREFIXSIZE(prefix->prefixlen));
		printf("    Prefix: %s/%d%s\n", log_in6addr(&ia6),
		    prefix->prefixlen, print_prefix_opt(prefix->options));

		off = sizeof(*asext) + LSA_PREFIXSIZE(prefix->prefixlen);
		if (ntohl(lsa->data.asext.metric) & LSA_ASEXT_F_FLAG) {
			bcopy((char *)asext + off, &ia6, sizeof(ia6));
			printf("    Forwarding Address: %s\n",
			    log_in6addr(&ia6));
			off += sizeof(ia6);
		}
		if (ntohl(lsa->data.asext.metric) & LSA_ASEXT_T_FLAG) {
			bcopy((char *)asext + off, &ext_tag, sizeof(ext_tag));
			printf("    External Route Tag: %d\n", ntohl(ext_tag));
		}
		printf("\n");
		lasttype = lsa->hdr.type;
		break;
	case IMSG_CTL_SHOW_DB_LINK:
		lsa = imsg->data;
		if (lsa->hdr.type != lasttype)
			show_database_head(area_id, ifname, lsa->hdr.type);
		show_db_hdr_msg_detail(&lsa->hdr);
		printf("Options: %s\n", print_ospf_options(LSA_24_GETLO(
		    ntohl(lsa->data.link.opts))));
		printf("Link Local Address: %s\n",
		    log_in6addr(&lsa->data.link.lladdr));

		nlinks = ntohl(lsa->data.link.numprefix);
		printf("Number of Prefixes: %d\n", nlinks);
		off = sizeof(lsa->hdr) + sizeof(struct lsa_link);

		for (i = 0; i < nlinks; i++) {
			prefix = (struct lsa_prefix *)((char *)lsa + off);
			bzero(&ia6, sizeof(ia6));
			bcopy(prefix + 1, &ia6,
			    LSA_PREFIXSIZE(prefix->prefixlen));

			printf("    Prefix: %s/%d%s\n", log_in6addr(&ia6),
			    prefix->prefixlen,
			    print_prefix_opt(prefix->options));

			off += sizeof(struct lsa_prefix)
			    + LSA_PREFIXSIZE(prefix->prefixlen);
		}

		printf("\n");
		lasttype = lsa->hdr.type;
		break;
	case IMSG_CTL_SHOW_DB_NET:
		lsa = imsg->data;
		if (lsa->hdr.type != lasttype)
			show_database_head(area_id, ifname, lsa->hdr.type);
		show_db_hdr_msg_detail(&lsa->hdr);
		printf("Options: %s\n",
		    print_ospf_options(LSA_24_GETLO(ntohl(lsa->data.net.opts))));

		nlinks = (ntohs(lsa->hdr.len) - sizeof(struct lsa_hdr) -
		    sizeof(struct lsa_net)) / sizeof(struct lsa_net_link);
		net_link = (struct lsa_net_link *)((char *)lsa +
		    sizeof(lsa->hdr) + sizeof(lsa->data.net));
		printf("Number of Routers: %d\n", nlinks);

		for (i = 0; i < nlinks; i++) {
			addr.s_addr = net_link->att_rtr;
			printf("    Attached Router: %s\n", inet_ntoa(addr));
			net_link++;
		}

		printf("\n");
		lasttype = lsa->hdr.type;
		break;
	case IMSG_CTL_SHOW_DB_RTR:
		lsa = imsg->data;
		if (lsa->hdr.type != lasttype)
			show_database_head(area_id, ifname, lsa->hdr.type);
		show_db_hdr_msg_detail(&lsa->hdr);
		printf("Flags: %s\n",
		    print_ospf_flags(LSA_24_GETHI(ntohl(lsa->data.rtr.opts))));
		printf("Options: %s\n",
		    print_ospf_options(LSA_24_GETLO(ntohl(lsa->data.rtr.opts))));

		nlinks = (ntohs(lsa->hdr.len) - sizeof(struct lsa_hdr)
		    - sizeof(u_int32_t)) / sizeof(struct lsa_rtr_link);
		printf("Number of Links: %d\n\n", nlinks);

		off = sizeof(lsa->hdr) + sizeof(struct lsa_rtr);

		for (i = 0; i < nlinks; i++) {
			rtr_link = (struct lsa_rtr_link *)((char *)lsa + off);

			printf("    Link (Interface ID %s) connected to: %s\n",
			    log_id(rtr_link->iface_id),
			    print_rtr_link_type(rtr_link->type));

			addr.s_addr = rtr_link->nbr_rtr_id;
			data.s_addr = rtr_link->nbr_iface_id;

			switch (rtr_link->type) {
			case LINK_TYPE_POINTTOPOINT:
			case LINK_TYPE_VIRTUAL:
				printf("    Router ID: %s\n", inet_ntoa(addr));
				printf("    Interface ID: %s\n",
				    inet_ntoa(data));
				break;
			case LINK_TYPE_TRANSIT_NET:
				printf("    Designated Router ID: %s\n",
				    inet_ntoa(addr));
				printf("    DR Interface ID: %s\n",
				    inet_ntoa(data));
				break;
			default:
				printf("    Link ID (Unknown type %d): %s\n",
				    rtr_link->type, inet_ntoa(addr));
				printf("    Link Data (Unknown): %s\n",
				    inet_ntoa(data));
				break;
			}

			printf("    Metric: %d\n\n", ntohs(rtr_link->metric));

			off += sizeof(struct lsa_rtr_link);
		}

		lasttype = lsa->hdr.type;
		break;
	case IMSG_CTL_SHOW_DB_INTRA:
		lsa = imsg->data;
		if (lsa->hdr.type != lasttype)
			show_database_head(area_id, ifname, lsa->hdr.type);
		show_db_hdr_msg_detail(&lsa->hdr);
		printf("Referenced LS Type: %s\n",
		    print_ls_type(lsa->data.pref_intra.ref_type));
		addr.s_addr = lsa->data.pref_intra.ref_ls_id;
		printf("Referenced Link State ID: %s\n", inet_ntoa(addr));
		addr.s_addr = lsa->data.pref_intra.ref_adv_rtr;
		printf("Referenced Advertising Router: %s\n", inet_ntoa(addr));
		nlinks = ntohs(lsa->data.pref_intra.numprefix);
		printf("Number of Prefixes: %d\n", nlinks);

		off = sizeof(lsa->hdr) + sizeof(struct lsa_intra_prefix);

		for (i = 0; i < nlinks; i++) {
			prefix = (struct lsa_prefix *)((char *)lsa + off);
			bzero(&ia6, sizeof(ia6));
			bcopy(prefix + 1, &ia6,
			    LSA_PREFIXSIZE(prefix->prefixlen));

			printf("    Prefix: %s/%d%s\n", log_in6addr(&ia6),
			    prefix->prefixlen,
			    print_prefix_opt(prefix->options));

			off += sizeof(struct lsa_prefix)
			    + LSA_PREFIXSIZE(prefix->prefixlen);
		}

		printf("\n");
		lasttype = lsa->hdr.type;
		break;
	case IMSG_CTL_SHOW_DB_SUM:
		lsa = imsg->data;
		if (lsa->hdr.type != lasttype)
			show_database_head(area_id, ifname, lsa->hdr.type);
		show_db_hdr_msg_detail(&lsa->hdr);
		printf("Prefix: XXX\n");
		printf("Metric: %d\n", ntohl(lsa->data.pref_sum.metric) &
		    LSA_METRIC_MASK);
		lasttype = lsa->hdr.type;
		break;
	case IMSG_CTL_SHOW_DB_ASBR:
		lsa = imsg->data;
		if (lsa->hdr.type != lasttype)
			show_database_head(area_id, ifname, lsa->hdr.type);
		show_db_hdr_msg_detail(&lsa->hdr);

		addr.s_addr = lsa->data.rtr_sum.dest_rtr_id;
		printf("Destination Router ID: %s\n", inet_ntoa(addr));
		printf("Options: %s\n",
		    print_ospf_options(ntohl(lsa->data.rtr_sum.opts)));
		printf("Metric: %d\n\n", ntohl(lsa->data.rtr_sum.metric) &
		    LSA_METRIC_MASK);
	case IMSG_CTL_AREA:
		area = imsg->data;
		area_id = area->id;
		lasttype = 0;
		break;
	case IMSG_CTL_IFACE:
		iface = imsg->data;
		strlcpy(ifname, iface->name, sizeof(ifname));
		lasttype = 0;
		break;
	case IMSG_CTL_END:
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_nbr_msg(struct imsg *imsg)
{
	struct ctl_nbr	*nbr;
	char		*state;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_NBR:
		nbr = imsg->data;
		if (asprintf(&state, "%s/%s", nbr_state_name(nbr->nbr_state),
		    if_state_name(nbr->iface_state)) == -1)
			err(1, NULL);
		printf("%-15s %-3d %-12s %-10s", inet_ntoa(nbr->id),
		    nbr->priority, state, fmt_timeframe_core(nbr->dead_timer));
		printf("%-11s %s\n", nbr->name,
		    nbr->uptime == 0 ? "-" : fmt_timeframe_core(nbr->uptime));
		free(state);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

const char *
print_ospf_options(u_int32_t opts)
{
	static char	optbuf[32];

	snprintf(optbuf, sizeof(optbuf), "*|*|%s|%s|%s|*|%s|%s",
	    opts & OSPF_OPTION_DC ? "DC" : "-",
	    opts & OSPF_OPTION_R ? "R" : "-",
	    opts & OSPF_OPTION_N ? "N" : "-",
	    opts & OSPF_OPTION_E ? "E" : "-",
	    opts & OSPF_OPTION_V6 ? "V6" : "-");
	return (optbuf);
}

int
show_nbr_detail_msg(struct imsg *imsg)
{
	struct ctl_nbr	*nbr;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_NBR:
		nbr = imsg->data;
		printf("\nNeighbor %s, ", inet_ntoa(nbr->id));
		printf("interface address %s\n", log_in6addr(&nbr->addr));
		printf("  Area %s, interface %s\n", inet_ntoa(nbr->area),
		    nbr->name);
		printf("  Neighbor priority is %d, "
		    "State is %s, %d state changes\n",
		    nbr->priority, nbr_state_name(nbr->nbr_state),
		    nbr->state_chng_cnt);
		printf("  DR is %s, ", inet_ntoa(nbr->dr));
		printf("BDR is %s\n", inet_ntoa(nbr->bdr));
		printf("  Options %s\n", print_ospf_options(nbr->options));
		printf("  Dead timer due in %s\n",
		    fmt_timeframe_core(nbr->dead_timer));
		printf("  Uptime %s\n", fmt_timeframe_core(nbr->uptime));
		printf("  Database Summary List %d\n", nbr->db_sum_lst_cnt);
		printf("  Link State Request List %d\n", nbr->ls_req_lst_cnt);
		printf("  Link State Retransmission List %d\n",
		    nbr->ls_retrans_lst_cnt);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_rib_msg(struct imsg *imsg)
{
	struct ctl_rt	*rt;
	char		*dstnet;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_RIB:
		rt = imsg->data;
		switch (rt->d_type) {
		case DT_NET:
			if (asprintf(&dstnet, "%s/%d", log_in6addr(&rt->prefix),
			    rt->prefixlen) == -1)
				err(1, NULL);
			break;
		case DT_RTR:
			if (asprintf(&dstnet, "%s",
			    log_in6addr(&rt->prefix)) == -1)
				err(1, NULL);
			break;
		default:
			errx(1, "Invalid route type");
		}

		printf("%-20s %-17s %-12s %-9s %-7d %s\n", dstnet,
		    log_in6addr_scope(&rt->nexthop, rt->ifindex),
		    path_type_name(rt->p_type), dst_type_name(rt->d_type),
		    rt->cost,
		    rt->uptime == 0 ? "-" : fmt_timeframe_core(rt->uptime));
		free(dstnet);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

void
show_rib_head(struct in_addr aid, u_int8_t d_type, u_int8_t p_type)
{
	char	*header, *format, *format2;

	switch (p_type) {
	case PT_INTRA_AREA:
	case PT_INTER_AREA:
		switch (d_type) {
		case DT_NET:
			format = "Network Routing Table";
			format2 = "";
			break;
		case DT_RTR:
			format = "Router Routing Table";
			format2 = "Type";
			break;
		default:
			errx(1, "unknown route type");
		}
		break;
	case PT_TYPE1_EXT:
	case PT_TYPE2_EXT:
		format = NULL;
		format2 = "Cost 2";
		if ((header = strdup("External Routing Table")) == NULL)
			err(1, NULL);
		break;
	default:
		errx(1, "unknown route type");
	}

	if (p_type != PT_TYPE1_EXT && p_type != PT_TYPE2_EXT)
		if (asprintf(&header, "%s (Area %s)", format,
		    inet_ntoa(aid)) == -1)
			err(1, NULL);

	printf("\n%-18s %s\n", "", header);
	free(header);

	printf("\n%-18s %-15s %-15s %-12s %-7s %-7s\n", "Destination",
	    "Nexthop", "Adv Router", "Path type", "Cost", format2);
}

const char *
print_ospf_rtr_flags(u_int8_t opts)
{
	static char	optbuf[32];

	snprintf(optbuf, sizeof(optbuf), "%s%s%s",
	    opts & OSPF_RTR_E ? "AS" : "",
	    opts & OSPF_RTR_E && opts & OSPF_RTR_B ? "+" : "",
	    opts & OSPF_RTR_B ? "ABR" : "");
	return (optbuf);
}

int
show_rib_detail_msg(struct imsg *imsg)
{
	static struct in_addr	 area_id;
	struct ctl_rt		*rt;
	struct area		*area;
	char			*dstnet;
	static u_int8_t		 lasttype;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_RIB:
		rt = imsg->data;

		switch (rt->p_type) {
		case PT_INTRA_AREA:
		case PT_INTER_AREA:
			switch (rt->d_type) {
			case DT_NET:
				if (lasttype != RIB_NET)
					show_rib_head(rt->area, rt->d_type,
					     rt->p_type);
				if (asprintf(&dstnet, "%s/%d",
				    log_in6addr(&rt->prefix),
				    rt->prefixlen) == -1)
					err(1, NULL);
				lasttype = RIB_NET;
				break;
			case DT_RTR:
				if (lasttype != RIB_RTR)
					show_rib_head(rt->area, rt->d_type,
					     rt->p_type);
				if (asprintf(&dstnet, "%s",
				    log_in6addr(&rt->prefix)) == -1)
					err(1, NULL);
				lasttype = RIB_RTR;
				break;
			default:
				errx(1, "unknown route type");
			}
			printf("%-18s %-15s ", dstnet,
			    log_in6addr_scope(&rt->nexthop, rt->ifindex));
			printf("%-15s %-12s %-7d", inet_ntoa(rt->adv_rtr),
			    path_type_name(rt->p_type), rt->cost);
			free(dstnet);

			if (rt->d_type == DT_RTR)
				printf(" %-7s",
				    print_ospf_rtr_flags(rt->flags));

			printf("\n");
			break;
		case PT_TYPE1_EXT:
		case PT_TYPE2_EXT:
			if (lasttype != RIB_EXT)
				show_rib_head(rt->area, rt->d_type, rt->p_type);

			if (asprintf(&dstnet, "%s/%d",
			    log_in6addr(&rt->prefix), rt->prefixlen) == -1)
				err(1, NULL);

			printf("%-18s %-15s ", dstnet,
			    log_in6addr_scope(&rt->nexthop, rt->ifindex));
			printf("%-15s %-12s %-7d %-7d\n",
			    inet_ntoa(rt->adv_rtr), path_type_name(rt->p_type),
			    rt->cost, rt->cost2);
			free(dstnet);

			lasttype = RIB_EXT;
			break;
		default:
			errx(1, "unknown route type");
		}
		break;
	case IMSG_CTL_AREA:
		area = imsg->data;
		area_id = area->id;
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

void
show_fib_head(void)
{
	printf("flags: * = valid, O = OSPF, C = Connected, S = Static\n");
	printf("%-6s %-4s %-20s %-17s\n",
	    "Flags", "Prio", "Destination", "Nexthop");
}

int
show_fib_msg(struct imsg *imsg)
{
	struct kroute		*k;
	char			*p;

	switch (imsg->hdr.type) {
	case IMSG_CTL_KROUTE:
		if (imsg->hdr.len < IMSG_HEADER_SIZE + sizeof(struct kroute))
			errx(1, "wrong imsg len");
		k = imsg->data;

		if (k->flags & F_DOWN)
			printf(" ");
		else
			printf("*");

		if (!(k->flags & F_KERNEL))
			printf("O");
		else if (k->flags & F_CONNECTED)
			printf("C");
		else if (k->flags & F_STATIC)
			printf("S");
		else
			printf(" ");

		printf("     ");
		printf("%4d ", k->priority);
		if (asprintf(&p, "%s/%u", log_in6addr(&k->prefix),
		    k->prefixlen) == -1)
			err(1, NULL);
		printf("%-20s ", p);
		free(p);

		if (!IN6_IS_ADDR_UNSPECIFIED(&k->nexthop))
			printf("%s", log_in6addr_scope(&k->nexthop, k->scope));
		else if (k->flags & F_CONNECTED)
			printf("link#%u", k->ifindex);
		printf("\n");

		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

const struct if_status_description
		if_status_descriptions[] = LINK_STATE_DESCRIPTIONS;
const struct ifmedia_description
		ifm_type_descriptions[] = IFM_TYPE_DESCRIPTIONS;

const char *
get_media_descr(uint64_t media_type)
{
	const struct ifmedia_description	*p;

	for (p = ifm_type_descriptions; p->ifmt_string != NULL; p++)
		if (media_type == p->ifmt_word)
			return (p->ifmt_string);

	return ("unknown");
}

const char *
get_linkstate(uint8_t if_type, int link_state)
{
	const struct if_status_description *p;
	static char buf[8];

	for (p = if_status_descriptions; p->ifs_string != NULL; p++) {
		if (LINK_STATE_DESC_MATCH(p, if_type, link_state))
			return (p->ifs_string);
	}
	snprintf(buf, sizeof(buf), "[#%d]", link_state);
	return (buf);
}

void
print_baudrate(u_int64_t baudrate)
{
	if (baudrate > IF_Gbps(1))
		printf("%llu GBit/s", baudrate / IF_Gbps(1));
	else if (baudrate > IF_Mbps(1))
		printf("%llu MBit/s", baudrate / IF_Mbps(1));
	else if (baudrate > IF_Kbps(1))
		printf("%llu KBit/s", baudrate / IF_Kbps(1));
	else
		printf("%llu Bit/s", baudrate);
}
@


1.45
log
@Import route priority support from ospfd to ospf6d.
Also remove the RTF_UP flag from hdr.rtm_flags in send_rtmsg() since
ospfd and bgpd don't set the flag.

OK bluhm@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.44 2016/12/22 23:03:55 jca Exp $ */
d587 3
@


1.44
log
@Also print the mtu in detailed interface info.

Copied on the diff from Remi Locherer for ospfctl.  ok benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.43 2015/12/05 13:12:40 claudio Exp $ */
d1259 2
a1260 1
	printf("%-6s %-20s %-17s\n", "Flags", "Destination", "Nexthop");
d1290 1
@


1.43
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.42 2015/12/03 17:16:39 deraadt Exp $ */
d412 1
a412 1
		printf("  Link type %s, state %s",
d414 2
a415 1
		    get_linkstate(iface->if_type, iface->linkstate));
@


1.42
log
@if_indextoname() was fixed a while back, do not need to pledge "route"
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.41 2015/10/10 00:19:52 benno Exp $ */
d246 1
a246 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.41
log
@pledge("stdio route") needed here, because ipv6
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.40 2015/09/27 17:31:50 stsp Exp $ */
d127 1
a127 1
	if (pledge("stdio route", NULL) == -1)
@


1.40
log
@As done for bgpd recently, rename if_mediatype to if_type in ospfd/ospf6d.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.39 2015/09/13 11:13:12 deraadt Exp $ */
d126 3
@


1.39
log
@match a few if_media uint64_t conversions; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.38 2013/11/13 22:52:41 sthen Exp $ */
d44 1
a44 1
int		 get_ifms_type(int);
d71 1
a71 1
const char *	 get_linkstate(uint64_t, int);
d350 2
a351 2
int
get_ifms_type(int mediatype)
d353 1
a353 1
	switch (mediatype) {
d382 1
a382 1
		    get_linkstate(iface->mediatype, iface->linkstate),
d410 2
a411 2
		    get_media_descr(get_ifms_type(iface->mediatype)),
		    get_linkstate(iface->mediatype, iface->linkstate));
d1326 1
a1326 1
get_linkstate(uint64_t media_type, int link_state)
d1332 1
a1332 1
		if (LINK_STATE_DESC_MATCH(p, media_type, link_state))
@


1.38
log
@handle msgbuf_write() returning EAGAIN, looks right to deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.37 2013/03/22 14:25:31 sthen Exp $ */
d70 2
a71 2
const char *	 get_media_descr(int);
const char *	 get_linkstate(int, int);
d1314 1
a1314 1
get_media_descr(int media_type)
d1326 1
a1326 1
get_linkstate(int media_type, int link_state)
@


1.37
log
@Allow use of an alternative control socket, ported from ospfd. ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.36 2011/05/05 15:58:53 claudio Exp $ */
d30 1
d239 1
a239 1
		if (msgbuf_write(&ibuf->w) < 0)
@


1.36
log
@order static types
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.35 2010/06/12 09:48:39 bluhm Exp $ */
d80 2
a81 1
	fprintf(stderr, "usage: %s command [argument ...]\n", __progname);
d95 16
d113 1
a113 1
	if ((res = parse(argc - 1, argv + 1)) == NULL)
d122 1
a122 1
	strlcpy(sun.sun_path, OSPF6D_SOCKET, sizeof(sun.sun_path));
d124 1
a124 1
		err(1, "connect: %s", OSPF6D_SOCKET);
@


1.35
log
@Print additional new line after 'Number of Links' in show database
router.  This separates the router and link blocks like ospfctl.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.34 2010/02/25 16:40:23 claudio Exp $ */
d578 1
a579 1
	static char		 ifname[IF_NAMESIZE];
@


1.34
log
@Fix AS-ext LSA detailed output. While there rework the way we print
prefixes a bit. The output is now a bit more compact.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.33 2010/02/23 16:32:55 claudio Exp $ */
d854 1
a854 1
		printf("Number of Links: %d\n", nlinks);
@


1.33
log
@Unbreak tree. struct lsa_asext changed so we need to adjust the output
function. Correct fix will follow but this compiles again.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.32 2009/12/23 18:01:31 claudio Exp $ */
d57 2
d701 29
d736 1
d745 1
d759 4
a762 1
		printf("    Metric type: ");
a766 2
		printf("    Metric: %d\n", ntohl(asext->metric)
		    & LSA_METRIC_MASK);
d768 18
a802 1
			struct in6_addr	ia6;
d808 3
a810 3
			printf("    Prefix Address: %s\n", log_in6addr(&ia6));
			printf("    Prefix Length: %d, Options: %x\n",
			    prefix->prefixlen, prefix->options);
a912 1
			struct in6_addr	ia6;
d918 3
a920 3
			printf("    Prefix Address: %s\n", log_in6addr(&ia6));
			printf("    Prefix Length: %d, Options: %x\n",
			    prefix->prefixlen, prefix->options);
@


1.32
log
@Print more addresses with scope.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.31 2009/12/22 17:55:04 claudio Exp $ */
a722 2
		addr.s_addr = lsa->data.asext.mask;
		printf("Network Mask: %s\n", inet_ntoa(addr));
a732 3
		addr.s_addr = asext->fw_addr;
		printf("    Forwarding Address: %s\n", inet_ntoa(addr));
		printf("    External Route Tag: %d\n\n", ntohl(asext->ext_tag));
@


1.31
log
@Use log_in6addr_scope() to print the correct nexthop.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.30 2009/11/02 20:25:27 claudio Exp $ */
d1141 1
a1141 1
			    log_in6addr(&rt->nexthop));
d1162 1
a1162 1
			    log_in6addr(&rt->nexthop));
d1229 1
a1229 1
			printf("%s", log_in6addr(&k->nexthop));
@


1.30
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging. henning, sthen, michele like the idea
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.29 2009/09/14 11:49:25 claudio Exp $ */
d1029 3
a1031 2
		    log_in6addr(&rt->nexthop), path_type_name(rt->p_type),
		    dst_type_name(rt->d_type), rt->cost,
@


1.29
log
@Switch the various link state printing codes to use the new if_media
independent LINK_STATE_DESCRIPTIONS. Code is now more or less a one to
one copy of get_linkstate() in route/route.c.
OK henning, michele, sthen, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.28 2009/07/28 19:05:22 claudio Exp $ */
d90 1
a90 1
	int			 done = 0;
d202 9
d277 2
@


1.28
log
@Track renamed struct member (r1.15 of ospf6d/ospf6.h) to fix compilation.
From stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.27 2009/06/06 09:02:46 eric Exp $ */
d351 2
a352 2
		    get_linkstate(get_ifms_type(iface->mediatype),
		    iface->linkstate), fmt_timeframe_core(iface->uptime));
d380 1
a380 2
		    get_linkstate(get_ifms_type(iface->mediatype),
		    iface->linkstate));
d1233 2
a1234 3
const int	ifm_status_valid_list[] = IFM_STATUS_VALID_LIST;
const struct ifmedia_status_description
		ifm_status_descriptions[] = IFM_STATUS_DESCRIPTIONS;
d1253 2
a1254 2
	const struct ifmedia_status_description	*p;
	int					 i;
d1256 6
a1261 14
	if (link_state == LINK_STATE_UNKNOWN)
		return ("unknown");

	for (i = 0; ifm_status_valid_list[i] != 0; i++)
		for (p = ifm_status_descriptions; p->ifms_valid != 0; p++) {
			if (p->ifms_type != media_type ||
			    p->ifms_valid != ifm_status_valid_list[i])
				continue;
			if (LINK_STATE_IS_UP(link_state))
				return (p->ifms_string[1]);
			return (p->ifms_string[0]);
		}

	return ("unknown");
@


1.27
log
@make ospf6ctl/ospf6d imsg-in-a-lib ready too.

ospf6ctl is already broken in tree (not connected to build).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.26 2009/03/29 18:31:47 stsp Exp $ */
d847 1
a847 1
		addr.s_addr = lsa->data.pref_intra.ref_lsid;
@


1.26
log
@Stop using the att_rtr member of struct lsa_net, we're going to remove it.
Calculate offsets with a struct lsa_net_link pointer instead.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.25 2009/03/29 16:08:23 stsp Exp $ */
a81 7
/* dummy function so that ospf6ctl does not need libevent */
void
imsg_event_add(struct imsgbuf *i)
{
	/* nothing */
}

d109 1
a109 1
	imsg_init(ibuf, ctl_sock, NULL);
d119 1
a119 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_SUM, 0, 0, NULL, 0);
d132 1
a132 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_INTERFACE, 0, 0,
d140 1
a140 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_NBR, 0, 0, NULL, 0);
d143 1
a143 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DATABASE, 0, 0, NULL, 0);
d146 1
a146 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DATABASE, 0, 0,
d150 1
a150 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_EXT, 0, 0, NULL, 0);
d153 1
a153 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_LINK, 0, 0, NULL, 0);
d156 1
a156 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_NET, 0, 0, NULL, 0);
d159 1
a159 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_RTR, 0, 0, NULL, 0);
d162 1
a162 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_INTRA, 0, 0, NULL, 0);
d165 1
a165 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_SELF, 0, 0, NULL, 0);
d168 1
a168 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_SUM, 0, 0, NULL, 0);
d171 1
a171 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_ASBR, 0, 0, NULL, 0);
d178 1
a178 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_RIB, 0, 0, NULL, 0);
d182 1
a182 1
			imsg_compose(ibuf, IMSG_CTL_KROUTE, 0, 0,
d185 1
a185 1
			imsg_compose(ibuf, IMSG_CTL_KROUTE_ADDR, 0, 0,
d193 1
a193 1
		imsg_compose(ibuf, IMSG_CTL_FIB_COUPLE, 0, 0, NULL, 0);
d198 1
a198 1
		imsg_compose(ibuf, IMSG_CTL_FIB_DECOUPLE, 0, 0, NULL, 0);
d203 1
a203 1
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, NULL, 0);
@


1.25
log
@ospf6ctl had lsa_rtr_link fields mixed up.
It printed iface_id as the neighbour's interface ID, but iface_id is
in fact the ID of the advertising router's interface being described.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.24 2009/01/30 22:23:30 stsp Exp $ */
d707 1
d778 4
a781 3
		nlinks = (ntohs(lsa->hdr.len) - sizeof(struct lsa_hdr)
		    - sizeof(u_int32_t)) / sizeof(struct lsa_net_link);
		off = sizeof(lsa->hdr) + sizeof(u_int32_t);
d785 1
a785 1
			addr.s_addr = lsa->data.net.att_rtr[i];
d787 1
@


1.24
log
@Add missing free. Found by norby@@ in ospfctl, same fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.23 2009/01/29 20:09:02 stsp Exp $ */
d809 2
a810 1
			printf("    Link connected to: %s\n",
d814 1
a814 1
			data.s_addr = rtr_link->iface_id;
@


1.23
log
@One more step on the long road of beautifying ospf6ctl output:
The Link State ID in OSPFv3 is just a unique identifier and has
lost its semantic meaning for a most LSA types.
Print the correct semantic meaning for those that still have one,
and don't print any additional information for those that don't.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.22 2009/01/29 19:39:41 stsp Exp $ */
d1158 1
@


1.22
log
@Don't print a header line above every individual Intra-Area-Prefix LSA
in the detailed DB output. Now behaves the same as with other LSA types.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.21 2009/01/29 16:34:32 stsp Exp $ */
a640 1
//XXX	printf("Options: %s\n", print_ospf_options(lsa->opts));
a643 3
	case LSA_TYPE_LINK:
		printf("Link State ID: %s\n", log_id(lsa->ls_id));
		break;
a644 6
		printf("Link State ID: %s\n", log_id(lsa->ls_id));
		break;
	case LSA_TYPE_NETWORK:
		printf("Link State ID: %s (interface ID of Designated Router)\n",
		    log_id(lsa->ls_id));
		break;
a645 2
		printf("Link State ID: %s (Network ID)\n", log_id(lsa->ls_id));
		break;
d647 3
a649 2
		printf("Link State ID: %s (ASBR Router ID)\n",
		    log_id(lsa->ls_id));
d651 3
a653 2
	case LSA_TYPE_INTRA_A_PREFIX:
		printf("Link State ID: %s (Network ID)\n", log_id(lsa->ls_id));
d655 3
a657 3
	case LSA_TYPE_EXTERNAL:
		printf("Link State ID: %s (External Network Number)\n",
		     log_id(lsa->ls_id));
@


1.21
log
@Fix offset calculation for lsa_prefix structs.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.20 2009/01/28 22:51:26 stsp Exp $ */
d883 3
@


1.20
log
@Add 'show database intra' command, which displays Intra-Area-Prefix LSAs.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.19 2009/01/28 17:34:15 stsp Exp $ */
d772 2
a773 1
			off += sizeof(struct lsa_prefix);
d880 2
a881 1
			off += sizeof(struct lsa_prefix);
@


1.19
log
@Print the right header for Intra-Area-Prefix LSAs when showing the database.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.18 2009/01/01 23:41:42 claudio Exp $ */
d168 3
d257 1
d851 30
@


1.18
log
@I removed prefix from lsa_prefix but this code was still using it. Unbreak
it by copying LSA_PREFIXSIZE(prefixlen) bytes after the lsa_prefix into a
struct in6_addr and print that.
Found by stsp@@ OK stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.17 2008/12/30 21:33:52 claudio Exp $ */
d538 1
a538 1
		format = "Router Link States";
@


1.17
log
@Add code to show Link LSA. Make the other detailed views a bit shorter by
removing an empty newline.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.16 2008/12/28 22:05:04 sobrado Exp $ */
d748 4
a751 3
		printf("Options: %s\n",
		    print_ospf_options(LSA_24_GETLO(ntohl(lsa->data.link.opts))));
		printf("Link Local Address: %s\n", log_in6addr(&lsa->data.link.lladdr));
d758 1
d760 7
a766 3

			printf("    Prefix Address: %s\n", log_in6addr(&prefix->prefix));
			printf("    Prefix Length: %d, Options: %x\n", prefix->prefixlen, prefix->options);
@


1.16
log
@a few documentation updates for opsf6(8) and ospf6ctl(8): remove an
existing (but undocumented) flag from the usage of ospf6d;
documentation tweaks; while here, synchronize synopsis and usage.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.15 2008/12/28 21:32:33 claudio Exp $ */
d159 3
d251 1
d713 1
d743 25
d779 1
d801 1
a801 1
		printf("Number of Links: %d\n\n", nlinks);
d848 1
a848 1
		printf("Metric: %d\n\n", ntohl(lsa->data.pref_sum.metric) &
d861 1
a861 1
		    print_ospf_options(ntohl(lsa->data.rtr_sum.options)));
@


1.15
log
@correct some output
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.14 2008/12/28 21:23:51 claudio Exp $ */
d78 1
a78 1
	fprintf(stderr, "usage: %s <command> [arg [...]]\n", __progname);
@


1.14
log
@Correctly display net lsa and the LSA type is now 16bit. This removes
the duplicate database headers seen all the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.13 2008/12/28 18:31:52 claudio Exp $ */
d519 1
a519 1
		format = "Link Link States";
d644 1
a644 1
		printf("Link State ID: %s (address of Designated Router)\n",
@


1.13
log
@Sync up with the last commit. Some flags are now gone.
From Stefan Sperling's diff collection
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.12 2007/12/13 08:57:32 claudio Exp $ */
d565 1
a565 1
	static u_int8_t		 lasttype;
d743 2
a744 2
		addr.s_addr = lsa->data.net.mask;
		printf("Network Mask: %s\n", inet_ntoa(addr));
@


1.12
log
@struct kif is gone so adapt to the situation. show interface is gone for
now. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.11 2007/11/27 12:24:55 claudio Exp $ */
d59 1
a59 1
const char	*print_ospf_options(u_int8_t);
d691 1
a691 2
	snprintf(optbuf, sizeof(optbuf), "*|*|*|*|%s|%s|%s|%s",
	    opts & OSPF_RTR_W ? "W" : "-",
d764 1
a764 1
		    print_ospf_flags(ntohl(lsa->data.rtr.opts) >> 24));
d766 1
a766 1
		    print_ospf_options(ntohl(lsa->data.rtr.opts)));
d881 1
a881 1
print_ospf_options(u_int8_t opts)
d885 1
a885 1
	snprintf(optbuf, sizeof(optbuf), "*|*|%s|%s|%s|%s|%s|%s",
a888 1
	    opts & OSPF_OPTION_MC ? "MC" : "-",
@


1.11
log
@update "show database" output (work in progress) but now link local LSA
are printed again.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.10 2007/10/16 21:58:58 claudio Exp $ */
a66 1
void		 show_interface_head(void);
a69 1
int		 show_fib_interface_msg(struct imsg *);
a189 8
	case SHOW_FIB_IFACE:
		if (*res->ifname)
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0,
			    res->ifname, sizeof(res->ifname));
		else
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0, NULL, 0);
		show_interface_head();
		break;
a262 3
			case SHOW_FIB_IFACE:
				done = show_fib_interface_msg(&imsg);
				break;
d375 4
a378 4
		printf("  Internet address %s ",
		    log_in6addr(&iface->addr));
		printf("Area %s\n", inet_ntoa(iface->area));
		printf("  Linkstate %s\n",
d381 6
a1171 7
void
show_interface_head(void)
{
	printf("%-15s%-15s%s\n", "Interface", "Flags",
	    "Link state");
}

a1222 50
}

int
show_fib_interface_msg(struct imsg *imsg)
{
	struct kif	*k;
	int		 ifms_type;

	switch (imsg->hdr.type) {
	case IMSG_CTL_IFINFO:
		k = imsg->data;
		printf("%-15s", k->ifname);
		printf("%-15s", k->flags & IFF_UP ? "UP" : "");
		switch (k->media_type) {
		case IFT_ETHER:
			ifms_type = IFM_ETHER;
			break;
		case IFT_FDDI:
			ifms_type = IFM_FDDI;
			break;
		case IFT_CARP:
			ifms_type = IFM_CARP;
			break;
		default:
			ifms_type = 0;
			break;
		}

		if (ifms_type)
			printf("%s, %s", get_media_descr(ifms_type),
			    get_linkstate(ifms_type, k->link_state));
		else if (k->link_state == LINK_STATE_UNKNOWN)
			printf("unknown");
		else
			printf("link state %u", k->link_state);

		if (k->link_state != LINK_STATE_DOWN && k->baudrate > 0) {
			printf(", ");
			print_baudrate(k->baudrate);
		}
		printf("\n");
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
@


1.10
log
@Fix show database router output.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.9 2007/10/16 21:37:45 claudio Exp $ */
d51 1
a51 1
void		 show_database_head(struct in_addr, u_int16_t);
d519 1
a519 1
show_database_head(struct in_addr aid, u_int16_t type)
d522 1
d544 4
a547 2
		format = NULL;
		if ((header = strdup("Type-5 AS External Link States")) == NULL)
d549 1
a550 2
	default:
		errx(1, "unknown LSA type");
d552 1
a552 1
	if (type != LSA_TYPE_EXTERNAL)
d556 5
d564 2
d573 1
d575 1
d583 1
a583 1
			show_database_head(area_id, lsa->type);
d598 5
d710 1
d714 1
d726 1
a726 1
			show_database_head(area_id, lsa->hdr.type);
d749 1
a749 1
			show_database_head(area_id, lsa->hdr.type);
d769 1
a769 1
			show_database_head(area_id, lsa->hdr.type);
a819 1
	case IMSG_CTL_SHOW_DB_ASBR:
d822 1
a822 1
			show_database_head(area_id, lsa->hdr.type);
d824 2
a825 3
		addr.s_addr = lsa->data.sum.mask;
		printf("Network Mask: %s\n", inet_ntoa(addr));
		printf("Metric: %d\n\n", ntohl(lsa->data.sum.metric) &
d829 12
d844 5
@


1.9
log
@Make ospf6ctl compile again and especially make ospf6ctl show database work
and so stuff starts to show up in the database:
Link ID         Adv Router      Age  Seq#       Checksum
0.0.0.1         255.1.1.1       3    0x8000028e 0xc7b3
0.0.0.0         255.1.1.1       3    0x8000027f 0xade8
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.8 2007/10/16 12:07:58 norby Exp $ */
d682 2
a683 1
	snprintf(optbuf, sizeof(optbuf), "*|*|*|*|*|%s|%s|%s",
d753 7
a759 2
		printf("Flags: %s\n", print_ospf_flags(lsa->data.rtr.flags));
		nlinks = ntohs(lsa->data.rtr.nlinks);
@


1.8
log
@Change LSA type to 16 bit and use the new defines recently comitted to
ospf6d(8).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.7 2007/10/16 08:43:44 claudio Exp $ */
d523 1
a523 1
	switch (type) {
d600 1
a600 1
	switch (type) {
d627 1
a627 1
	switch (lsa->type) {
d668 2
a669 2
	case LINK_TYPE_STUB_NET:
		return ("Stub Network");
d693 1
a693 1
	static u_int8_t		 lasttype;
d764 2
a765 2
			addr.s_addr = rtr_link->id;
			data.s_addr = rtr_link->data;
d770 3
a772 4
				printf("    Link ID (Neighbors Router ID):"
				    " %s\n", inet_ntoa(addr));
				printf("    Link Data (Router Interface "
				    "address): %s\n", inet_ntoa(data));
d775 1
a775 7
				printf("    Link ID (Designated Router "
				    "address): %s\n", inet_ntoa(addr));
				printf("    Link Data (Router Interface "
				    "address): %s\n", inet_ntoa(data));
				break;
			case LINK_TYPE_STUB_NET:
				printf("    Link ID (Network ID): %s\n",
d777 1
a777 1
				printf("    Link Data (Network Mask): %s\n",
d781 2
a782 2
				printf("    Link ID (Unknown): %s\n",
				    inet_ntoa(addr));
d790 1
a790 2
			off += sizeof(struct lsa_rtr_link) +
			    rtr_link->num_tos * sizeof(u_int32_t);
@


1.7
log
@Adapt to the changes in ospf6d. Fix more IPv6 addressing and probably break
some currently not working commands but show interface and show neighbor should
work.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.6 2007/10/16 08:07:56 norby Exp $ */
d51 1
a51 1
void		 show_database_head(struct in_addr, u_int8_t);
d53 1
a53 1
char		*print_ls_type(u_int8_t);
d519 1
a519 1
show_database_head(struct in_addr aid, u_int8_t type)
d524 3
d533 5
a537 2
	case LSA_TYPE_SUM_NETWORK:
		format = "Summary Net Link States";
d539 2
a540 2
	case LSA_TYPE_SUM_ROUTER:
		format = "Summary Router Link States";
d598 1
a598 1
print_ls_type(u_int8_t type)
d601 2
d607 6
a612 4
	case LSA_TYPE_SUM_NETWORK:
		return ("Summary (Network)");
	case LSA_TYPE_SUM_ROUTER:
		return ("Summary (Router)");
d628 3
d638 1
a638 1
	case LSA_TYPE_SUM_NETWORK:
d641 1
a641 1
	case LSA_TYPE_SUM_ROUTER:
d644 3
@


1.6
log
@Fix the output from "show neighbor".

It is not possible to fit the address of the neighbor(s) in the
short list, so we loose it...

It is still possible to see the IP address of the neighbor in the
output of "show neighbor detail".

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.5 2007/10/15 02:16:35 deraadt Exp $ */
d184 1
a184 1
		if (!res->addr.s_addr)
a517 10
/* prototype defined in ospfd.h and shared with the kroute.c version */
u_int8_t
mask2prefixlen(in_addr_t ina)
{
	if (ina == 0)
		return (0);
	else
		return (33 - ffs(ntohl(ina)));
}

d904 1
a904 1
			if (asprintf(&dstnet, "%s/%d", inet_ntoa(rt->prefix),
d910 1
a910 1
			    inet_ntoa(rt->prefix)) == -1)
d918 1
a918 1
		    inet_ntoa(rt->nexthop), path_type_name(rt->p_type),
d1011 2
a1012 1
				    inet_ntoa(rt->prefix), rt->prefixlen) == -1)
d1021 1
a1021 1
				    inet_ntoa(rt->prefix)) == -1)
d1028 2
a1029 1
			printf("%-18s %-15s ", dstnet, inet_ntoa(rt->nexthop));
d1046 1
a1046 1
			    inet_ntoa(rt->prefix), rt->prefixlen) == -1)
d1049 2
a1050 1
			printf("%-18s %-15s ", dstnet, inet_ntoa(rt->nexthop));
d1109 2
a1110 2
		if (asprintf(&p, "%s/%u", inet_ntoa(k->prefix), k->prefixlen) ==
		    -1)
d1115 2
a1116 2
		if (k->nexthop.s_addr)
			printf("%s", inet_ntoa(k->nexthop));
@


1.5
log
@specifying int instead of just unsigned is better style
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.4 2007/10/14 01:28:06 deraadt Exp $ */
d145 2
a146 2
		printf("%-15s %-3s %-12s %-8s %-15s %-9s %s\n", "ID", "Pri",
		    "State", "DeadTime", "Address", "Iface","Uptime");
d835 1
a835 1
		printf("%-15s %-3d %-12s %-9s", inet_ntoa(nbr->id),
d837 1
a837 1
		printf("%-15s %-9s %s\n", log_in6addr(&nbr->addr), nbr->name,
@


1.4
log
@please lint
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.3 2007/10/12 09:29:45 norby Exp $ */
d460 1
a460 1
	unsigned	 sec, min, hrs, day, week;
@


1.3
log
@Sanitize the output of "show interface detail".
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.2 2007/10/12 09:23:37 norby Exp $ */
d134 1
d147 1
d179 1
@


1.2
log
@Properly format the output of "show interface".

In order to make room for the longer IPv6 addresses in the output,
the two collumns nc and ac must go. Neighbor and Adjacent Neighbor Count
is still avalable in "show interface detail".

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6ctl.c,v 1.1 2007/10/12 08:22:53 norby Exp $ */
d385 1
a385 1
		printf("  Internet address %s/ ",
d397 1
a397 1
		printf("  Designated Router (ID) %s, ",
d399 3
a401 2
		printf("interface address %s\n", log_in6addr(&iface->dr_addr));
		printf("  Backup Designated Router (ID) %s, ",
d403 2
a404 1
		printf("interface address %s\n", log_in6addr(&iface->bdr_addr));
@


1.1
log
@Controller for the recently imported ospf6d(8) daemon.

Currently simple stuff like show interface works.
Not yet connected to the builds.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.38 2007/09/11 16:01:22 claudio Exp $ */
d131 1
a131 1
		printf("%-11s %-18s %-6s %-10s %-10s %-8s %3s %3s\n",
d133 1
a133 1
		    "Uptime", "nc", "ac");
d357 1
a357 1
		printf("%-11s %-18s %-6s %-10s %-10s %s %3d %3d\n",
d361 1
a361 3
		    iface->linkstate), fmt_timeframe_core(iface->uptime),
		    iface->nbr_cnt,
		    iface->adj_cnt);
@

