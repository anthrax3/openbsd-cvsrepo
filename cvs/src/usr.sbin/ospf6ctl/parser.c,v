head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.10
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.12
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.8
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.10
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.8
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.4
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.11.0.6
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4;
locks; strict;
comment	@ * @;


1.13
date	2014.11.17.21.53.55;	author tobias;	state Exp;
branches;
next	1.12;
commitid	HG8mW4flVreZqCaz;

1.12
date	2012.10.21.21.30.44;	author bluhm;	state Exp;
branches;
next	1.11;

1.11
date	2011.03.07.07.43.02;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.04.21.31.04;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.20.05.26.06;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.13.11.33.12;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.02.20.25.27;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.28.22.51.26;	author stsp;	state Exp;
branches;
next	1.5;

1.5
date	2008.12.30.21.33.52;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.13.08.57.32;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.16.08.43.44;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.14.01.28.06;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.12.08.22.53;	author norby;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Always free "ps" after usage.

ok stsp
@
text
@/*	$OpenBSD: parser.c,v 1.12 2012/10/21 21:30:44 bluhm Exp $ */

/*
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ospf6d.h"

#include "parser.h"

enum token_type {
	NOTOKEN,
	ENDTOKEN,
	KEYWORD,
	ADDRESS,
	FLAG,
	PREFIX,
	IFNAME
};

struct token {
	enum token_type		 type;
	const char		*keyword;
	int			 value;
	const struct token	*next;
};

static const struct token t_main[];
static const struct token t_fib[];
static const struct token t_show[];
static const struct token t_show_iface[];
static const struct token t_show_db[];
static const struct token t_show_area[];
static const struct token t_show_nbr[];
static const struct token t_show_rib[];
static const struct token t_show_fib[];
static const struct token t_log[];

static const struct token t_main[] = {
	{KEYWORD,	"reload",	RELOAD,		NULL},
	{KEYWORD,	"fib",		FIB,		t_fib},
	{KEYWORD,	"show",		SHOW,		t_show},
	{KEYWORD,	"log",		NONE,		t_log},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_fib[] = {
	{ KEYWORD,	"couple",	FIB_COUPLE,	NULL},
	{ KEYWORD,	"decouple",	FIB_DECOUPLE,	NULL},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show[] = {
	{NOTOKEN,	"",		NONE,		NULL},
	{KEYWORD,	"interfaces",	SHOW_IFACE,	t_show_iface},
	{KEYWORD,	"database",	SHOW_DB,	t_show_db},
	{KEYWORD,	"neighbor",	SHOW_NBR,	t_show_nbr},
	{KEYWORD,	"rib",		SHOW_RIB,	t_show_rib},
	{KEYWORD,	"fib",		SHOW_FIB,	t_show_fib},
	{KEYWORD,	"summary",	SHOW_SUM,	NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show_iface[] = {
	{NOTOKEN,	"",		NONE,			NULL},
	{KEYWORD,	"detail",	SHOW_IFACE_DTAIL,	NULL},
	{IFNAME,	"",		SHOW_IFACE_DTAIL,	NULL},
	{ENDTOKEN,	"",		NONE,			NULL}
};

static const struct token t_show_db[] = {
	{NOTOKEN,	"",			NONE,		NULL},
	{KEYWORD,	"area",			SHOW_DBBYAREA,	t_show_area},
	{KEYWORD,	"asbr",			SHOW_DBASBR,	NULL},
	{KEYWORD,	"external",		SHOW_DBEXT,	NULL},
	{KEYWORD,	"link",			SHOW_DBLINK,	NULL},
	{KEYWORD,	"network",		SHOW_DBNET,	NULL},
	{KEYWORD,	"router",		SHOW_DBRTR,	NULL},
	{KEYWORD,	"intra",		SHOW_DBINTRA,	NULL},
	{KEYWORD,	"self-originated",	SHOW_DBSELF,	NULL},
	{KEYWORD,	"summary",		SHOW_DBSUM,	NULL},
	{ENDTOKEN,	"",			NONE,		NULL}
};

static const struct token t_show_area[] = {
	{ADDRESS,	"",		NONE,		NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show_nbr[] = {
	{NOTOKEN,	"",		NONE,		NULL},
	{KEYWORD,	"detail",	SHOW_NBR_DTAIL,	NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show_rib[] = {
	{NOTOKEN,	"",		NONE,		NULL},
	{KEYWORD,	"detail",	SHOW_RIB_DTAIL,	NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show_fib[] = {
	{NOTOKEN,	"",		NONE,			NULL},
	{FLAG,		"connected",	F_CONNECTED,		t_show_fib},
	{FLAG,		"static",	F_STATIC,		t_show_fib},
	{FLAG,		"ospf",		F_OSPFD_INSERTED,	t_show_fib},
	{ADDRESS,	"",		NONE,			NULL},
	{ENDTOKEN,	"",		NONE,			NULL}
};

static const struct token t_log[] = {
	{KEYWORD,	"verbose",	LOG_VERBOSE,		NULL},
	{KEYWORD,	"brief",	LOG_BRIEF,		NULL},
	{ENDTOKEN,	"",		NONE,			NULL}
};

static const struct token *match_token(const char *, const struct token *,
    struct parse_result *);
static void show_valid_args(const struct token *);

struct parse_result *
parse(int argc, char *argv[])
{
	static struct parse_result	res;
	const struct token	*table = t_main;
	const struct token	*match;

	bzero(&res, sizeof(res));

	while (argc >= 0) {
		if ((match = match_token(argv[0], table, &res)) == NULL) {
			fprintf(stderr, "valid commands/args:\n");
			show_valid_args(table);
			return (NULL);
		}

		argc--;
		argv++;

		if (match->type == NOTOKEN || match->next == NULL)
			break;

		table = match->next;
	}

	if (argc > 0) {
		fprintf(stderr, "superfluous argument: %s\n", argv[0]);
		return (NULL);
	}

	return (&res);
}

static const struct token *
match_token(const char *word, const struct token *table,
    struct parse_result *res)
{
	u_int			 i, match;
	const struct token	*t = NULL;

	match = 0;

	for (i = 0; table[i].type != ENDTOKEN; i++) {
		switch (table[i].type) {
		case NOTOKEN:
			if (word == NULL || strlen(word) == 0) {
				match++;
				t = &table[i];
			}
			break;
		case KEYWORD:
			if (word != NULL && strncmp(word, table[i].keyword,
			    strlen(word)) == 0) {
				match++;
				t = &table[i];
				if (t->value)
					res->action = t->value;
			}
			break;
		case FLAG:
			if (word != NULL && strncmp(word, table[i].keyword,
			    strlen(word)) == 0) {
				match++;
				t = &table[i];
				res->flags |= t->value;
			}
			break;
		case ADDRESS:
			if (parse_addr(word, &res->addr)) {
				match++;
				t = &table[i];
				if (t->value)
					res->action = t->value;
			}
			break;
		case PREFIX:
			if (parse_prefix(word, &res->addr, &res->prefixlen)) {
				match++;
				t = &table[i];
				if (t->value)
					res->action = t->value;
			}
			break;
		case IFNAME:
			if (!match && word != NULL && strlen(word) > 0) {
				if (strlcpy(res->ifname, word,
				    sizeof(res->ifname)) >=
				    sizeof(res->ifname))
					err(1, "interface name too long");
				match++;
				t = &table[i];
				if (t->value)
					res->action = t->value;
			}
			break;

		case ENDTOKEN:
			break;
		}
	}

	if (match != 1) {
		if (word == NULL)
			fprintf(stderr, "missing argument:\n");
		else if (match > 1)
			fprintf(stderr, "ambiguous argument: %s\n", word);
		else if (match < 1)
			fprintf(stderr, "unknown argument: %s\n", word);
		return (NULL);
	}

	return (t);
}

static void
show_valid_args(const struct token *table)
{
	int	i;

	for (i = 0; table[i].type != ENDTOKEN; i++) {
		switch (table[i].type) {
		case NOTOKEN:
			fprintf(stderr, "  <cr>\n");
			break;
		case KEYWORD:
		case FLAG:
			fprintf(stderr, "  %s\n", table[i].keyword);
			break;
		case ADDRESS:
			fprintf(stderr, "  <address>\n");
			break;
		case PREFIX:
			fprintf(stderr, "  <address>[/<len>]\n");
			break;
		case IFNAME:
			fprintf(stderr, "  <interface>\n");
			break;
		case ENDTOKEN:
			break;
		}
	}
}

/* XXX shared with parse.y should be merged */
int
parse_addr(const char *word, struct in6_addr *addr)
{
	struct addrinfo	hints, *r;

	if (word == NULL)
		return (0);

	bzero(addr, sizeof(struct in6_addr));
	bzero(&hints, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_DGRAM; /*dummy*/
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(word, "0", &hints, &r) == 0) {
		*addr = ((struct sockaddr_in6 *)r->ai_addr)->sin6_addr;
		/* XXX address scope !!! */
		/* ((struct sockaddr_in6 *)r->ai_addr)->sin6_scope_id */
		freeaddrinfo(r);
		return (1);
	}
	return (0);
}

/* XXX shared with parse.y should be merged */
int
parse_prefix(const char *word, struct in6_addr *addr, u_int8_t *prefixlen)
{
	char		*p, *ps;
	const char	*errstr;
	int		 mask;

	if (word == NULL)
		return (0);

	if ((p = strrchr(word, '/')) != NULL) {
		mask = strtonum(p + 1, 0, 128, &errstr);
		if (errstr)
			errx(1, "invalid netmask: %s", errstr);

		if ((ps = malloc(strlen(word) - strlen(p) + 1)) == NULL)
			err(1, "parse_prefix: malloc");
		strlcpy(ps, word, strlen(word) - strlen(p) + 1);

		if (parse_addr(ps, addr) == 0) {
			free(ps);
			return (0);
		}
		free(ps);

		inet6applymask(addr, addr, mask);
		*prefixlen = mask;
		return (1);
	}
	*prefixlen = 128;
	return (parse_addr(word, addr));
}
@


1.12
log
@Move common ospf6d functions for ipv6 address manipulation into
util.c to reuse them in ospf6ctl.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.11 2011/03/07 07:43:02 henning Exp $ */
d337 1
@


1.11
log
@continguous -> contiguous
From: "Anthony J. Bentley" <anthonyjbentley at gmail dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.10 2010/09/04 21:31:04 tedu Exp $ */
a343 84
}

/* XXX prototype defined in ospfd.h and shared with the kroute.c version */
u_int8_t
mask2prefixlen(struct sockaddr_in6 *sa_in6)
{
	u_int8_t	l = 0, *ap, *ep;

	/*
	 * sin6_len is the size of the sockaddr so substract the offset of
	 * the possibly truncated sin6_addr struct.
	 */
	ap = (u_int8_t *)&sa_in6->sin6_addr;
	ep = (u_int8_t *)sa_in6 + sa_in6->sin6_len;
	for (; ap < ep; ap++) {
		/* this "beauty" is adopted from sbin/route/show.c ... */
		switch (*ap) {
		case 0xff:
			l += 8;
			break;
		case 0xfe:
			l += 7;
			return (l);
		case 0xfc:
			l += 6;
			return (l);
		case 0xf8:
			l += 5;
			return (l);
		case 0xf0:
			l += 4;
			return (l);
		case 0xe0:
			l += 3;
			return (l);
		case 0xc0:
			l += 2;
			return (l);
		case 0x80:
			l += 1;
			return (l);
		case 0x00:
			return (l);
		default:
			errx(1, "non contiguous inet6 netmask");
		}
	}

	return (l);
}

/* XXX local copy from kroute.c, should go to shared file */
struct in6_addr *
prefixlen2mask(u_int8_t prefixlen)
{
	static struct in6_addr	mask;
	int			i;

	bzero(&mask, sizeof(mask));
	for (i = 0; i < prefixlen / 8; i++)
		mask.s6_addr[i] = 0xff;
	i = prefixlen % 8;
	if (i)
		mask.s6_addr[prefixlen / 8] = 0xff00 >> i;

	return (&mask);
}

/* XXX local copy from kroute.c, should go to shared file */
void
inet6applymask(struct in6_addr *dest, const struct in6_addr *src, int prefixlen)
{
	struct in6_addr	mask;
	int		i;

	bzero(&mask, sizeof(mask));
	for (i = 0; i < prefixlen / 8; i++)
		mask.s6_addr[i] = 0xff;
	i = prefixlen % 8;
	if (i)
		mask.s6_addr[prefixlen / 8] = 0xff00 >> i;

	for (i = 0; i < 16; i++)
		dest->s6_addr[i] = src->s6_addr[i] & mask.s6_addr[i];
@


1.10
log
@move some things around to make intentions clear.  not really a functional
change.  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.9 2010/07/20 05:26:06 claudio Exp $ */
d388 1
a388 1
			errx(1, "non continguous inet6 netmask");
@


1.9
log
@Another hand rolled offsetof(), replace with mask2prefixlen from kroute.c
which was copied from bgpd. Found by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.8 2010/01/13 11:33:12 jsg Exp $ */
d142 3
a144 1
static struct parse_result	res;
d149 1
d156 1
a156 1
		if ((match = match_token(argv[0], table)) == NULL) {
d179 3
a181 2
const struct token *
match_token(const char *word, const struct token *table)
d202 1
a202 1
					res.action = t->value;
d210 1
a210 1
				res.flags |= t->value;
d214 1
a214 1
			if (parse_addr(word, &res.addr)) {
d218 1
a218 1
					res.action = t->value;
d222 1
a222 1
			if (parse_prefix(word, &res.addr, &res.prefixlen)) {
d226 1
a226 1
					res.action = t->value;
d231 3
a233 3
				if (strlcpy(res.ifname, word,
				    sizeof(res.ifname)) >=
				    sizeof(res.ifname))
d238 1
a238 1
					res.action = t->value;
d260 1
a260 1
void
@


1.8
log
@Fix problems with incomplete arrays that was fixed in other ospfctl
based programs a few months back.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.7 2009/11/02 20:25:27 claudio Exp $ */
d346 1
a346 1
	u_int8_t	l = 0, i, len;
d352 3
a354 3
	len = sa_in6->sin6_len -
	    (u_int8_t)(&((struct sockaddr_in6 *)NULL)->sin6_addr);
	for (i = 0; i < len; i++) {
d356 1
a356 1
		switch (sa_in6->sin6_addr.s6_addr[i]) {
@


1.7
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging. henning, sthen, michele like the idea
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.6 2009/01/28 22:51:26 stsp Exp $ */
d177 1
a177 1
match_token(const char *word, const struct token table[])
d257 1
a257 1
show_valid_args(const struct token table[])
@


1.6
log
@Add 'show database intra' command, which displays Intra-Area-Prefix LSAs.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.5 2008/12/30 21:33:52 claudio Exp $ */
d62 1
d68 1
d133 6
@


1.5
log
@Add code to show Link LSA. Make the other detailed views a bit shorter by
removing an empty newline.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.4 2007/12/13 08:57:32 claudio Exp $ */
d102 1
@


1.4
log
@struct kif is gone so adapt to the situation. show interface is gone for
now. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.3 2007/10/16 08:43:44 claudio Exp $ */
d99 1
@


1.3
log
@Adapt to the changes in ospf6d. Fix more IPv6 addressing and probably break
some currently not working commands but show interface and show neighbor should
work.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.2 2007/10/14 01:28:06 deraadt Exp $ */
a124 1
	{KEYWORD,	"interface",	SHOW_FIB_IFACE,		t_show_iface},
@


1.2
log
@please lint
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.1 2007/10/12 08:22:53 norby Exp $ */
d27 1
d276 1
d278 1
a278 1
parse_addr(const char *word, struct in_addr *addr)
d280 1
a280 1
	struct in_addr	ina;
d285 10
a294 5
	bzero(addr, sizeof(struct in_addr));
	bzero(&ina, sizeof(ina));

	if (inet_pton(AF_INET, word, &ina)) {
		addr->s_addr = ina.s_addr;
a296 1

d300 1
d302 1
a302 1
parse_prefix(const char *word, struct in_addr *addr, u_int8_t *prefixlen)
d304 3
a306 2
	struct in_addr	 ina;
	int		 bits = 32;
d311 8
a318 2
	bzero(addr, sizeof(struct in_addr));
	bzero(&ina, sizeof(ina));
d320 2
a321 3
	if (strrchr(word, '/') != NULL) {
		if ((bits = inet_net_pton(AF_INET, word,
		    &ina, sizeof(ina))) == -1)
d323 4
a326 2
		addr->s_addr = ina.s_addr & htonl(prefixlen2mask(bits));
		*prefixlen = bits;
d329 1
a329 1
	*prefixlen = 32;
d333 49
d383 1
a383 1
in_addr_t
d386 26
a411 2
	if (prefixlen == 0)
		return (0);
d413 2
a414 1
	return (0xffffffff << (32 - prefixlen));
@


1.1
log
@Controller for the recently imported ospf6d(8) daemon.

Currently simple stuff like show interface works.
Not yet connected to the builds.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.14 2007/02/01 13:09:42 claudio Exp $ */
d268 1
a312 3
	} else {
		*prefixlen = 32;
		return (parse_addr(word, addr));
d314 2
a315 2

	return (0);
@

