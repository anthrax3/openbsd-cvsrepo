head	1.118;
access;
symbols
	OPENBSD_6_1:1.118.0.2
	OPENBSD_6_1_BASE:1.118
	OPENBSD_6_0:1.111.0.2
	OPENBSD_6_0_BASE:1.111
	OPENBSD_5_9:1.104.0.2
	OPENBSD_5_9_BASE:1.104
	OPENBSD_5_8:1.103.0.4
	OPENBSD_5_8_BASE:1.103
	OPENBSD_5_7:1.101.0.2
	OPENBSD_5_7_BASE:1.101
	OPENBSD_5_6:1.99.0.4
	OPENBSD_5_6_BASE:1.99
	OPENBSD_5_5:1.98.0.4
	OPENBSD_5_5_BASE:1.98
	OPENBSD_5_4:1.95.0.2
	OPENBSD_5_4_BASE:1.95
	OPENBSD_5_3:1.93.0.2
	OPENBSD_5_3_BASE:1.93
	OPENBSD_5_2:1.90.0.4
	OPENBSD_5_2_BASE:1.90
	OPENBSD_5_1_BASE:1.90
	OPENBSD_5_1:1.90.0.2
	OPENBSD_5_0:1.81.0.2
	OPENBSD_5_0_BASE:1.81
	OPENBSD_4_9:1.78.0.4
	OPENBSD_4_9_BASE:1.78
	OPENBSD_4_8:1.78.0.2
	OPENBSD_4_8_BASE:1.78
	OPENBSD_4_7:1.77.0.4
	OPENBSD_4_7_BASE:1.77
	OPENBSD_4_6:1.77.0.6
	OPENBSD_4_6_BASE:1.77
	OPENBSD_4_5:1.77.0.2
	OPENBSD_4_5_BASE:1.77
	OPENBSD_4_4:1.72.0.6
	OPENBSD_4_4_BASE:1.72
	OPENBSD_4_3:1.72.0.4
	OPENBSD_4_3_BASE:1.72
	OPENBSD_4_2:1.72.0.2
	OPENBSD_4_2_BASE:1.72
	OPENBSD_4_1:1.70.0.2
	OPENBSD_4_1_BASE:1.70
	OPENBSD_4_0:1.66.0.4
	OPENBSD_4_0_BASE:1.66
	OPENBSD_3_9:1.66.0.2
	OPENBSD_3_9_BASE:1.66
	OPENBSD_3_8:1.65.0.2
	OPENBSD_3_8_BASE:1.65
	OPENBSD_3_7:1.61.0.2
	OPENBSD_3_7_BASE:1.61
	OPENBSD_3_6:1.60.0.2
	OPENBSD_3_6_BASE:1.60
	OPENBSD_3_5:1.56.0.2
	OPENBSD_3_5_BASE:1.56
	OPENBSD_3_4:1.52.0.2
	OPENBSD_3_4_BASE:1.52
	OPENBSD_3_3:1.40.0.2
	OPENBSD_3_3_BASE:1.40
	OPENBSD_3_2:1.36.0.2
	OPENBSD_3_2_BASE:1.36
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	OPENBSD_3_0:1.25.0.2
	OPENBSD_3_0_BASE:1.25
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	NetBSD-20000425:1.1.1.1
	NetBSD:1.1.1;
locks; strict;
comment	@ * @;


1.118
date	2016.11.30.23.58.07;	author mestre;	state Exp;
branches;
next	1.117;
commitid	5GPlKYQMhm5vyJES;

1.117
date	2016.11.30.22.44.19;	author mestre;	state Exp;
branches;
next	1.116;
commitid	Psq4xDxvLtBY7tZX;

1.116
date	2016.11.30.10.42.38;	author mestre;	state Exp;
branches;
next	1.115;
commitid	mE30Ei8f1RKnarND;

1.115
date	2016.11.29.16.11.44;	author deraadt;	state Exp;
branches;
next	1.114;
commitid	vSJek2hG8xDctNli;

1.114
date	2016.11.29.09.42.38;	author jsg;	state Exp;
branches;
next	1.113;
commitid	rh6mIsMfRDv6NEad;

1.113
date	2016.11.29.03.59.31;	author jsg;	state Exp;
branches;
next	1.112;
commitid	ySmBMsd4swrnMjIC;

1.112
date	2016.08.10.20.30.34;	author millert;	state Exp;
branches;
next	1.111;
commitid	gzJj9dBb2AOnfB7O;

1.111
date	2016.05.03.21.05.14;	author mestre;	state Exp;
branches;
next	1.110;
commitid	lLKC9fNDzEDz7Txv;

1.110
date	2016.05.02.15.25.03;	author millert;	state Exp;
branches;
next	1.109;
commitid	gXTrBUIdStsmyFit;

1.109
date	2016.04.26.13.30.12;	author mestre;	state Exp;
branches;
next	1.108;
commitid	P5SAnK4OEMYjRHmJ;

1.108
date	2016.03.29.17.21.50;	author mestre;	state Exp;
branches;
next	1.107;
commitid	Pn0nndZLXVPIrqvj;

1.107
date	2016.03.29.13.32.54;	author mestre;	state Exp;
branches;
next	1.106;
commitid	64hpZkpTZk6QuCLe;

1.106
date	2016.03.28.19.42.51;	author mestre;	state Exp;
branches;
next	1.105;
commitid	vMLqO9jjbAvor50Z;

1.105
date	2016.03.28.19.09.08;	author mestre;	state Exp;
branches;
next	1.104;
commitid	F9evcHcKwC5zVsGy;

1.104
date	2015.11.15.23.13.20;	author deraadt;	state Exp;
branches;
next	1.103;
commitid	ZIJQXPuf6N8nZnyj;

1.103
date	2015.04.24.08.08.29;	author dlg;	state Exp;
branches;
next	1.102;
commitid	MNS2CKt1eWbWFbiX;

1.102
date	2015.04.23.17.11.42;	author millert;	state Exp;
branches;
next	1.101;
commitid	TvM1HaCk07mrMiBa;

1.101
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.100;
commitid	Uu5nFG3wCl0LACBb;

1.100
date	2014.08.27.06.51.35;	author sebastia;	state Exp;
branches;
next	1.99;
commitid	5lCymSA9cyXpQEk5;

1.99
date	2014.07.20.01.38.40;	author guenther;	state Exp;
branches
	1.99.4.1;
next	1.98;
commitid	0acpjAf5myNxgwB5;

1.98
date	2013.11.23.17.14.05;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2013.09.10.20.53.09;	author millert;	state Exp;
branches;
next	1.96;

1.96
date	2013.08.06.21.33.03;	author millert;	state Exp;
branches;
next	1.95;

1.95
date	2013.04.02.05.04.47;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2013.03.04.07.24.52;	author ajacoutot;	state Exp;
branches;
next	1.93;

1.93
date	2013.02.16.07.25.54;	author ajacoutot;	state Exp;
branches;
next	1.92;

1.92
date	2012.09.20.11.32.06;	author ajacoutot;	state Exp;
branches;
next	1.91;

1.91
date	2012.09.18.07.56.11;	author ajacoutot;	state Exp;
branches;
next	1.90;

1.90
date	2012.01.29.08.38.54;	author ajacoutot;	state Exp;
branches;
next	1.89;

1.89
date	2012.01.28.14.25.45;	author ajacoutot;	state Exp;
branches;
next	1.88;

1.88
date	2012.01.28.10.20.01;	author ajacoutot;	state Exp;
branches;
next	1.87;

1.87
date	2012.01.12.18.35.07;	author ajacoutot;	state Exp;
branches;
next	1.86;

1.86
date	2011.12.31.14.05.51;	author ajacoutot;	state Exp;
branches;
next	1.85;

1.85
date	2011.12.30.08.39.02;	author ajacoutot;	state Exp;
branches;
next	1.84;

1.84
date	2011.12.27.08.29.38;	author ajacoutot;	state Exp;
branches;
next	1.83;

1.83
date	2011.12.24.07.17.04;	author jmc;	state Exp;
branches;
next	1.82;

1.82
date	2011.12.04.08.28.35;	author ajacoutot;	state Exp;
branches;
next	1.81;

1.81
date	2011.04.16.07.41.08;	author sobrado;	state Exp;
branches;
next	1.80;

1.80
date	2011.04.08.18.13.53;	author jmc;	state Exp;
branches;
next	1.79;

1.79
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.78;

1.78
date	2010.07.26.10.55.17;	author miod;	state Exp;
branches;
next	1.77;

1.77
date	2009.02.08.11.37.43;	author chl;	state Exp;
branches;
next	1.76;

1.76
date	2009.01.21.16.56.02;	author sobrado;	state Exp;
branches;
next	1.75;

1.75
date	2008.12.20.09.40.47;	author jmc;	state Exp;
branches;
next	1.74;

1.74
date	2008.12.16.05.25.55;	author guenther;	state Exp;
branches;
next	1.73;

1.73
date	2008.10.09.21.10.08;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2007.08.02.16.18.05;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2007.04.05.01.34.57;	author tedu;	state Exp;
branches;
next	1.70;

1.70
date	2007.03.02.04.27.11;	author ray;	state Exp;
branches;
next	1.69;

1.69
date	2007.03.02.04.23.35;	author ray;	state Exp;
branches;
next	1.68;

1.68
date	2007.01.12.13.25.12;	author otto;	state Exp;
branches;
next	1.67;

1.67
date	2006.12.20.01.58.46;	author ray;	state Exp;
branches;
next	1.66;

1.66
date	2005.12.31.19.20.49;	author millert;	state Exp;
branches;
next	1.65;

1.65
date	2005.08.27.23.12.36;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2005.07.08.18.58.32;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2005.04.15.16.27.31;	author moritz;	state Exp;
branches;
next	1.62;

1.62
date	2005.04.13.03.46.28;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2004.09.30.15.07.41;	author otto;	state Exp;
branches;
next	1.60;

1.60
date	2004.06.04.18.04.21;	author otto;	state Exp;
branches;
next	1.59;

1.59
date	2004.05.10.18.41.11;	author otto;	state Exp;
branches;
next	1.58;

1.58
date	2004.05.10.09.44.45;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2004.04.19.17.48.31;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	2004.02.26.21.18.18;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.03.18.30.39;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2003.12.25.10.23.57;	author grange;	state Exp;
branches;
next	1.53;

1.53
date	2003.12.24.20.15.58;	author otto;	state Exp;
branches;
next	1.52;

1.52
date	2003.06.14.22.12.53;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2003.06.10.21.00.37;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.10.20.52.01;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.10.20.27.31;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2003.06.10.20.03.56;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2003.06.10.19.51.22;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2003.06.10.19.45.56;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.08.23.04.36;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.08.20.50.51;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.08.20.43.25;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.13.01.12.31;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2003.04.03.16.03.06;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2002.12.10.20.49.28;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.07.22.05.43;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2002.11.07.22.02.18;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.07.21.49.31;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2002.07.25.15.41.39;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.09.22.12.57;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.17.04.07.50;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.04.04.18.39.32;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.03.22.35.26;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.14.06.51.42;	author mpech;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.05.17.30.15;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.05.18.23.55;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.05.18.20.57;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.15.20.09.08;	author danh;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.08.23.26.45;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.09.18.01.50.44;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.16.18.29.27;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.24.19.27.18;	author jakob;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.24.19.24.07;	author jakob;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.24.19.21.33;	author jakob;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.24.19.20.51;	author jakob;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.13.09.18.33;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2000.11.26.01.29.42;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.15.08.31.54;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.06.09.23.30;	author ho;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.16.07.17.39;	author ho;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.09.16.34.24;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.05.23.54.51;	author ho;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2000.05.05.23.22.39;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.05.12.33.51;	author jakob;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.04.22.56.52;	author jakob;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.26.06.27.57;	author jakob;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.24.23.11.14;	author jakob;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.24.22.59.25;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.24.22.52.36;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.24.22.40.11;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.22.38.31;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.22.37.15;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.24.22.31.29;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.24.22.27.00;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.24.22.27.00;	author jakob;	state Exp;
branches;
next	;

1.13.2.1
date	2000.06.18.03.40.12;	author jason;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2000.07.12.13.55.23;	author jason;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2000.11.29.02.43.27;	author jason;	state Exp;
branches;
next	;

1.99.4.1
date	2014.11.05.20.05.06;	author tedu;	state Exp;
branches;
next	;
commitid	uKqsncxKm6TxKOYi;


desc
@@


1.118
log
@Since pwp->pw_gid is equal to pwp->pw_uid then use the former instead in
creategid() function and in the failure message since it makes more sense in
this chunck of code.

OK millert@@
@
text
@/* $OpenBSD: user.c,v 1.117 2016/11/30 22:44:19 mestre Exp $ */
/* $NetBSD: user.c,v 1.69 2003/04/14 17:40:07 agc Exp $ */

/*
 * Copyright (c) 1999 Alistair G. Crooks.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <ctype.h>
#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <grp.h>
#include <login_cap.h>
#include <paths.h>
#include <pwd.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>
#include <util.h>

#include "usermgmt.h"


/* this struct describes a uid range */
typedef struct range_t {
	uid_t	r_from;		/* low uid */
	uid_t	r_to;		/* high uid */
} range_t;

/* this struct encapsulates the user information */
typedef struct user_t {
	int		u_flags;		/* see below */
	uid_t		u_uid;			/* uid of user */
	char	       *u_password;		/* encrypted password */
	char	       *u_comment;		/* comment field */
	char	       *u_home;		/* home directory */
	char	       *u_primgrp;		/* primary group */
	int		u_groupc;		/* # of secondary groups */
	const char     *u_groupv[NGROUPS_MAX];	/* secondary groups */
	char	       *u_shell;		/* user's shell */
	char	       *u_basedir;		/* base directory for home */
	char	       *u_expire;		/* when account will expire */
	char	       *u_inactive;		/* when password will expire */
	char	       *u_skeldir;		/* directory for startup files */
	char	       *u_class;		/* login class */
	unsigned int	u_rsize;		/* size of range array */
	unsigned int	u_rc;			/* # of ranges */
	range_t	       *u_rv;			/* the ranges */
	unsigned int	u_defrc;		/* # of ranges in defaults */
	int		u_preserve;		/* preserve uids on deletion */
} user_t;

/* flags for which fields of the user_t replace the passwd entry */
enum {
	F_COMMENT	= 0x0001,
	F_DUPUID	= 0x0002,
	F_EXPIRE	= 0x0004,
	F_GROUP		= 0x0008,
	F_HOMEDIR	= 0x0010,
	F_MKDIR		= 0x0020,
	F_INACTIVE	= 0x0040,
	F_PASSWORD	= 0x0080,
	F_SECGROUP	= 0x0100,
	F_SHELL		= 0x0200,
	F_UID		= 0x0400,
	F_USERNAME	= 0x0800,
	F_CLASS		= 0x1000,
	F_SETSECGROUP	= 0x4000,
	F_ACCTLOCK	= 0x8000,
	F_ACCTUNLOCK	= 0x10000
};

#define CONFFILE		"/etc/usermgmt.conf"
#define _PATH_NONEXISTENT	"/nonexistent"

#ifndef DEF_GROUP
#define DEF_GROUP	"=uid"
#endif

#ifndef DEF_BASEDIR
#define DEF_BASEDIR	"/home"
#endif

#ifndef DEF_SKELDIR
#define DEF_SKELDIR	"/etc/skel"
#endif

#ifndef DEF_SHELL
#define DEF_SHELL	_PATH_KSHELL
#endif

#ifndef DEF_COMMENT
#define DEF_COMMENT	""
#endif

#ifndef DEF_LOWUID
#define DEF_LOWUID	1000
#endif

#ifndef DEF_HIGHUID
#define DEF_HIGHUID	60000
#endif

#ifndef DEF_INACTIVE
#define DEF_INACTIVE	0
#endif

#ifndef DEF_EXPIRE
#define DEF_EXPIRE	NULL
#endif

#ifndef DEF_CLASS
#define DEF_CLASS	""
#endif

#ifndef WAITSECS
#define WAITSECS	10
#endif

#ifndef NOBODY_UID
#define NOBODY_UID	32767
#endif

/* some useful constants */
enum {
	MaxShellNameLen = 256,
	MaxFileNameLen = PATH_MAX,
	MaxUserNameLen = _PW_NAME_LEN,
	MaxCommandLen = 2048,
	PasswordLength = _PASSWORD_LEN,
	LowGid = DEF_LOWUID,
	HighGid = DEF_HIGHUID
};

/* Full paths of programs used here */
#define CHMOD		"/bin/chmod"
#define CHOWN		"/sbin/chown"
#define MKDIR		"/bin/mkdir"
#define MV		"/bin/mv"
#define NOLOGIN		"/sbin/nologin"
#define PAX		"/bin/pax"
#define RM		"/bin/rm"

#define UNSET_INACTIVE	"Null (unset)"
#define UNSET_EXPIRY	"Null (unset)"

static int asystem(const char *fmt, ...)
	__attribute__((__format__(__printf__, 1, 2)));

static int	verbose;

/* if *cpp is non-null, free it, then assign `n' chars of `s' to it */
static void
memsave(char **cpp, const char *s, size_t n)
{
	free(*cpp);
	if ((*cpp = calloc (n + 1, sizeof(char))) == NULL)
		err(1, NULL);
	memcpy(*cpp, s, n);
	(*cpp)[n] = '\0';
}

/* a replacement for system(3) */
static int
asystem(const char *fmt, ...)
{
	va_list	vp;
	char	buf[MaxCommandLen];
	int	ret;

	va_start(vp, fmt);
	(void) vsnprintf(buf, sizeof(buf), fmt, vp);
	va_end(vp);
	if (verbose) {
		printf("Command: %s\n", buf);
	}
	if ((ret = system(buf)) != 0) {
		warnx("[Warning] can't system `%s'", buf);
	}
	return ret;
}

/* remove a users home directory, returning 1 for success (ie, no problems encountered) */
static int
removehomedir(const char *user, uid_t uid, const char *dir)
{
	struct stat st;

	/* userid not root? */
	if (uid == 0) {
		warnx("Not deleting home directory `%s'; userid is 0", dir);
		return 0;
	}

	/* directory exists (and is a directory!) */
	if (stat(dir, &st) < 0) {
		warnx("Home directory `%s' doesn't exist", dir);
		return 0;
	}
	if (!S_ISDIR(st.st_mode)) {
		warnx("Home directory `%s' is not a directory", dir);
		return 0;
	}

	/* userid matches directory owner? */
	if (st.st_uid != uid) {
		warnx("User `%s' doesn't own directory `%s', not removed",
		    user, dir);
		return 0;
	}

	(void) seteuid(uid);
	/* we add the "|| true" to keep asystem() quiet if there is a non-zero exit status. */
	(void) asystem("%s -rf %s > /dev/null 2>&1 || true", RM, dir);
	(void) seteuid(0);
	if (rmdir(dir) < 0) {
		warnx("Unable to remove all files in `%s'", dir);
		return 0;
	}
	return 1;
}

/*
 * check that the effective uid is 0 - called from funcs which will
 * modify data and config files.
 */
static void
checkeuid(void)
{
	if (geteuid() != 0) {
		errx(EXIT_FAILURE, "Program must be run as root");
	}
}

/* copy any dot files into the user's home directory */
static int
copydotfiles(char *skeldir, uid_t uid, gid_t gid, char *dir)
{
	struct dirent	*dp;
	DIR		*dirp;
	int		n;

	if (*skeldir == '\0')
		return 0;
	if ((dirp = opendir(skeldir)) == NULL) {
		warn("can't open source . files dir `%s'", skeldir);
		return 0;
	}
	for (n = 0; (dp = readdir(dirp)) != NULL && n == 0 ; ) {
		if (strcmp(dp->d_name, ".") == 0 ||
		    strcmp(dp->d_name, "..") == 0) {
			continue;
		}
		n = 1;
	}
	(void) closedir(dirp);
	if (n == 0) {
		warnx("No \"dot\" initialisation files found");
	} else {
		(void) asystem("cd %s && %s -rw -pe %s . %s",
				skeldir, PAX, (verbose) ? "-v" : "", dir);
	}
	return n;
}

/* create a group entry with gid `gid' */
static int
creategid(char *group, gid_t gid, const char *name)
{
	struct stat	st;
	FILE		*from;
	FILE		*to;
	char		*buf;
	char		f[MaxFileNameLen];
	int		fd, ret;
	int		wroteit = 0;
	size_t		len;

	if (getgrnam(group) != NULL) {
		warnx("group `%s' already exists", group);
		return 0;
	}
	if ((from = fopen(_PATH_GROUP, "r")) == NULL) {
		warn("can't create gid for `%s': can't open `%s'", group,
		    _PATH_GROUP);
		return 0;
	}
	if (flock(fileno(from), LOCK_EX | LOCK_NB) < 0) {
		warn("can't lock `%s'", _PATH_GROUP);
	}
	(void) fstat(fileno(from), &st);
	(void) snprintf(f, sizeof(f), "%s.XXXXXXXX", _PATH_GROUP);
	if ((fd = mkstemp(f)) < 0) {
		warn("can't create gid: mkstemp failed");
		fclose(from);
		return 0;
	}
	if ((to = fdopen(fd, "w")) == NULL) {
		warn("can't create gid: fdopen `%s' failed", f);
		fclose(from);
		close(fd);
		unlink(f);
		return 0;
	}
	while ((buf = fgetln(from, &len)) != NULL && len > 0) {
		ret = 0;
		if (buf[0] == '+' && wroteit == 0) {
			ret = fprintf(to, "%s:*:%u:%s\n", group, gid, name);
			wroteit = 1;
		}
		if (ret == -1 ||
		    fprintf(to, "%*.*s", (int)len, (int)len, buf) != len) {
			warn("can't create gid: short write to `%s'", f);
			fclose(from);
			fclose(to);
			unlink(f);
			return 0;
		}
	}
	ret = 0;
	if (wroteit == 0)
		ret = fprintf(to, "%s:*:%u:%s\n", group, gid, name);
	fclose(from);
	if (fclose(to) == EOF || ret == -1) {
		warn("can't create gid: short write to `%s'", f);
		unlink(f);
		return 0;
	}
	if (rename(f, _PATH_GROUP) < 0) {
		warn("can't create gid: can't rename `%s' to `%s'", f,
		    _PATH_GROUP);
		unlink(f);
		return 0;
	}
	(void) chmod(_PATH_GROUP, st.st_mode & 0777);
	syslog(LOG_INFO, "new group added: name=%s, gid=%u", group, gid);
	return 1;
}

/* modify the group entry with name `group' to be newent */
static int
modify_gid(char *group, char *newent)
{
	struct stat	st;
	FILE		*from;
	FILE		*to;
	char		buf[LINE_MAX];
	char		f[MaxFileNameLen];
	char		*colon;
	int		groupc;
	int		entc;
	int		fd;
	int		cc;

	if ((from = fopen(_PATH_GROUP, "r")) == NULL) {
		warn("can't modify gid for `%s': can't open `%s'", group,
		    _PATH_GROUP);
		return 0;
	}
	if (flock(fileno(from), LOCK_EX | LOCK_NB) < 0) {
		warn("can't lock `%s'", _PATH_GROUP);
	}
	(void) fstat(fileno(from), &st);
	(void) snprintf(f, sizeof(f), "%s.XXXXXXXX", _PATH_GROUP);
	if ((fd = mkstemp(f)) < 0) {
		warn("can't modify gid: mkstemp failed");
		fclose(from);
		return 0;
	}
	if ((to = fdopen(fd, "w")) == NULL) {
		warn("can't modify gid: fdopen `%s' failed", f);
		fclose(from);
		close(fd);
		unlink(f);
		return 0;
	}
	groupc = strlen(group);
	while (fgets(buf, sizeof(buf), from) != NULL) {
		cc = strlen(buf);
		if (cc > 0 && buf[cc - 1] != '\n' && !feof(from)) {
			while (fgetc(from) != '\n' && !feof(from))
				cc++;
			warnx("%s: line `%s' too long (%d bytes), skipping",
			    _PATH_GROUP, buf, cc);
			continue;
		}
		if ((colon = strchr(buf, ':')) == NULL) {
			/*
			 * The only valid entry with no column is the all-YP
			 * line.
			 */
			if (strcmp(buf, "+\n") != 0) {
				warnx("badly formed entry `%.*s'", cc - 1, buf);
				continue;
			}
		} else {
			entc = (int)(colon - buf);
			if (entc == groupc && strncmp(group, buf, entc) == 0) {
				if (newent == NULL) {
					continue;
				} else {
					cc = strlcpy(buf, newent, sizeof(buf));
					if (cc >= sizeof(buf)) {
						warnx("group `%s' entry too long",
						    newent);
						fclose(from);
						fclose(to);
						unlink(f);
						return (0);
					}
				}
			}
		}
		if (fwrite(buf, cc, 1, to) != 1) {
			warn("can't modify gid: short write to `%s'", f);
			fclose(from);
			fclose(to);
			unlink(f);
			return 0;
		}
	}
	fclose(from);
	if (fclose(to) == EOF) {
		warn("can't modify gid: short write to `%s'", f);
		unlink(f);
		return 0;
	}
	if (rename(f, _PATH_GROUP) < 0) {
		warn("can't modify gid: can't rename `%s' to `%s'", f, _PATH_GROUP);
		unlink(f);
		return 0;
	}
	(void) chmod(_PATH_GROUP, st.st_mode & 0777);
	if (newent == NULL) {
		syslog(LOG_INFO, "group deleted: name=%s", group);
	} else {
		syslog(LOG_INFO, "group information modified: name=%s", group);
	}
	return 1;
}

/* modify the group entries for all `groups', by adding `user' */
static int
append_group(char *user, int ngroups, const char **groups)
{
	struct group	*grp;
	struct passwd	*pwp;
	struct stat	st;
	FILE		*from;
	FILE		*to;
	char		buf[LINE_MAX];
	char		f[MaxFileNameLen];
	char		*colon;
	char		*ugid = NULL;
	int		fd;
	int		cc;
	int		i;
	int		j;

	if ((pwp = getpwnam(user))) {
		if ((ugid = group_from_gid(pwp->pw_gid, 1)) == NULL) {
			warnx("can't get primary group for user `%s'", user);
			return 0;
		}
	}

	for (i = 0 ; i < ngroups ; i++) {
		if ((grp = getgrnam(groups[i])) == NULL) {
			warnx("can't append group `%s' for user `%s'",
			    groups[i], user);
		} else {
			for (j = 0 ; grp->gr_mem[j] ; j++) {
				if (strcmp(user, grp->gr_mem[j]) == 0) {
					/* already in it */
					groups[i] = "";
				}
			}
		}
	}
	if ((from = fopen(_PATH_GROUP, "r")) == NULL) {
		warn("can't append group for `%s': can't open `%s'", user,
		    _PATH_GROUP);
		return 0;
	}
	if (flock(fileno(from), LOCK_EX | LOCK_NB) < 0) {
		warn("can't lock `%s'", _PATH_GROUP);
	}
	(void) fstat(fileno(from), &st);
	(void) snprintf(f, sizeof(f), "%s.XXXXXXXX", _PATH_GROUP);
	if ((fd = mkstemp(f)) < 0) {
		warn("can't append group: mkstemp failed");
		fclose(from);
		return 0;
	}
	if ((to = fdopen(fd, "w")) == NULL) {
		warn("can't append group: fdopen `%s' failed", f);
		fclose(from);
		close(fd);
		unlink(f);
		return 0;
	}
	while (fgets(buf, sizeof(buf), from) != NULL) {
		cc = strlen(buf);
		if (cc > 0 && buf[cc - 1] != '\n' && !feof(from)) {
			while (fgetc(from) != '\n' && !feof(from))
				cc++;
			warnx("%s: line `%s' too long (%d bytes), skipping",
			    _PATH_GROUP, buf, cc);
			continue;
		}
		if ((colon = strchr(buf, ':')) == NULL) {
			warnx("badly formed entry `%s'", buf);
			continue;
		}
		for (i = 0 ; i < ngroups ; i++) {
			j = (int)(colon - buf);
			if (ugid) {
				if (strcmp(ugid, groups[i]) == 0) {
					/* user's primary group, no need to append */
					groups[i] = "";
				}
			}
			if (strncmp(groups[i], buf, j) == 0 &&
			    groups[i][j] == '\0') {
				while (isspace((unsigned char)buf[cc - 1]))
					cc--;
				buf[(j = cc)] = '\0';
				if (buf[strlen(buf) - 1] != ':')
					strlcat(buf, ",", sizeof(buf));
				cc = strlcat(buf, user, sizeof(buf)) + 1;
				if (cc >= sizeof(buf)) {
					warnx("Warning: group `%s' would "
					    "become too long, not modifying",
					    groups[i]);
					cc = j + 1;
				}
				buf[cc - 1] = '\n';
				buf[cc] = '\0';
			}
		}
		if (fwrite(buf, cc, 1, to) != 1) {
			warn("can't append group: short write to `%s'", f);
			fclose(from);
			fclose(to);
			unlink(f);
			return 0;
		}
	}
	fclose(from);
	if (fclose(to) == EOF) {
		warn("can't append group: short write to `%s'", f);
		unlink(f);
		return 0;
	}
	if (rename(f, _PATH_GROUP) < 0) {
		warn("can't append group: can't rename `%s' to `%s'", f, _PATH_GROUP);
		unlink(f);
		return 0;
	}
	(void) chmod(_PATH_GROUP, st.st_mode & 0777);
	return 1;
}

/* return 1 if `login' is a valid login name */
static int
valid_login(char *login_name)
{
	unsigned char	*cp;

	/* The first character cannot be a hyphen */
	if (*login_name == '-')
		return 0;

	for (cp = login_name ; *cp ; cp++) {
		/* We allow '$' as the last character for samba */
		if (!isalnum((unsigned char)*cp) && *cp != '.' &&
		    *cp != '_' && *cp != '-' &&
		    !(*cp == '$' && *(cp + 1) == '\0')) {
			return 0;
		}
	}
	if ((char *)cp - login_name > MaxUserNameLen)
		return 0;
	return 1;
}

/* return 1 if `group' is a valid group name */
static int
valid_group(char *group)
{
	unsigned char	*cp;

	for (cp = group ; *cp ; cp++) {
		if (!isalnum((unsigned char)*cp) && *cp != '.' &&
		    *cp != '_' && *cp != '-') {
			return 0;
		}
	}
	if ((char *)cp - group > MaxUserNameLen)
		return 0;
	return 1;
}

/* return 1 if `class' exists */
static int
valid_class(char *class)
{
	login_cap_t *lc;

	if ((lc = login_getclass(class)) != NULL)
		login_close(lc);
	return lc != NULL;
}

/* find the next gid in the range lo .. hi */
static int
getnextgid(uid_t *gidp, uid_t lo, uid_t hi)
{
	for (*gidp = lo ; *gidp < hi ; *gidp += 1) {
		if (getgrgid((gid_t)*gidp) == NULL) {
			return 1;
		}
	}
	return 0;
}

/* save a range of uids */
static int
save_range(user_t *up, char *cp)
{
	uid_t	from;
	uid_t	to;
	int	i;

	if (up->u_rc == up->u_rsize) {
		up->u_rsize *= 2;
		if ((up->u_rv = reallocarray(up->u_rv, up->u_rsize,
		    sizeof(range_t))) == NULL) {
			warn(NULL);
			return 0;
		}
	}
	if (up->u_rv && sscanf(cp, "%u..%u", &from, &to) == 2) {
		for (i = up->u_defrc ; i < up->u_rc ; i++) {
			if (up->u_rv[i].r_from == from && up->u_rv[i].r_to == to) {
				break;
			}
		}
		if (i == up->u_rc) {
			up->u_rv[up->u_rc].r_from = from;
			up->u_rv[up->u_rc].r_to = to;
			up->u_rc += 1;
		}
	} else {
		warnx("Bad range `%s'", cp);
		return 0;
	}
	return 1;
}

/* set the defaults in the defaults file */
static int
setdefaults(user_t *up)
{
	char	template[MaxFileNameLen];
	FILE	*fp;
	int	ret;
	int	fd;
	int	i;

	(void) snprintf(template, sizeof(template), "%s.XXXXXXXX", CONFFILE);
	if ((fd = mkstemp(template)) < 0) {
		warnx("can't mkstemp `%s' for writing", CONFFILE);
		return 0;
	}
	if ((fp = fdopen(fd, "w")) == NULL) {
		warn("can't fdopen `%s' for writing", CONFFILE);
		return 0;
	}
	ret = 1;
	if (fprintf(fp, "group\t\t%s\n", up->u_primgrp) <= 0 ||
	    fprintf(fp, "base_dir\t%s\n", up->u_basedir) <= 0 ||
	    fprintf(fp, "skel_dir\t%s\n", up->u_skeldir) <= 0 ||
	    fprintf(fp, "shell\t\t%s\n", up->u_shell) <= 0 ||
	    fprintf(fp, "class\t\t%s\n", up->u_class) <= 0 ||
	    fprintf(fp, "inactive\t%s\n", (up->u_inactive == NULL) ? UNSET_INACTIVE : up->u_inactive) <= 0 ||
	    fprintf(fp, "expire\t\t%s\n", (up->u_expire == NULL) ? UNSET_EXPIRY : up->u_expire) <= 0 ||
	    fprintf(fp, "preserve\t%s\n", (up->u_preserve == 0) ? "false" : "true") <= 0) {
		warn("can't write to `%s'", CONFFILE);
		ret = 0;
	}
	for (i = (up->u_defrc != up->u_rc) ? up->u_defrc : 0 ; i < up->u_rc ; i++) {
		if (fprintf(fp, "range\t\t%u..%u\n", up->u_rv[i].r_from, up->u_rv[i].r_to) <= 0) {
			warn("can't write to `%s'", CONFFILE);
			ret = 0;
		}
	}
	if (fclose(fp) == EOF) {
		warn("can't write to `%s'", CONFFILE);
		ret = 0;
	}
	if (ret) {
		ret = ((rename(template, CONFFILE) == 0) && (chmod(CONFFILE, 0644) == 0));
	}
	return ret;
}

/* read the defaults file */
static void
read_defaults(user_t *up)
{
	struct stat	st;
	size_t		lineno;
	size_t		len;
	FILE		*fp;
	unsigned char	*cp;
	unsigned char	*s;

	memsave(&up->u_primgrp, DEF_GROUP, strlen(DEF_GROUP));
	memsave(&up->u_basedir, DEF_BASEDIR, strlen(DEF_BASEDIR));
	memsave(&up->u_skeldir, DEF_SKELDIR, strlen(DEF_SKELDIR));
	memsave(&up->u_shell, DEF_SHELL, strlen(DEF_SHELL));
	memsave(&up->u_comment, DEF_COMMENT, strlen(DEF_COMMENT));
	memsave(&up->u_class, DEF_CLASS, strlen(DEF_CLASS));
	up->u_rsize = 16;
	up->u_defrc = 0;
	if ((up->u_rv = calloc(up->u_rsize, sizeof(range_t))) == NULL)
		err(1, NULL);
	up->u_inactive = DEF_INACTIVE;
	up->u_expire = DEF_EXPIRE;
	if ((fp = fopen(CONFFILE, "r")) == NULL) {
		if (stat(CONFFILE, &st) < 0 && !setdefaults(up)) {
			warn("can't create `%s' defaults file", CONFFILE);
		}
		fp = fopen(CONFFILE, "r");
	}
	if (fp != NULL) {
		while ((s = fparseln(fp, &len, &lineno, NULL, 0)) != NULL) {
			if (strncmp(s, "group", 5) == 0) {
				for (cp = s + 5 ; isspace((unsigned char)*cp); cp++) {
				}
				memsave(&up->u_primgrp, cp, strlen(cp));
			} else if (strncmp(s, "base_dir", 8) == 0) {
				for (cp = s + 8 ; isspace((unsigned char)*cp); cp++) {
				}
				memsave(&up->u_basedir, cp, strlen(cp));
			} else if (strncmp(s, "skel_dir", 8) == 0) {
				for (cp = s + 8 ; isspace((unsigned char)*cp); cp++) {
				}
				memsave(&up->u_skeldir, cp, strlen(cp));
			} else if (strncmp(s, "shell", 5) == 0) {
				for (cp = s + 5 ; isspace((unsigned char)*cp); cp++) {
				}
				memsave(&up->u_shell, cp, strlen(cp));
			} else if (strncmp(s, "password", 8) == 0) {
				for (cp = s + 8 ; isspace((unsigned char)*cp); cp++) {
				}
				memsave(&up->u_password, cp, strlen(cp));
			} else if (strncmp(s, "class", 5) == 0) {
				for (cp = s + 5 ; isspace((unsigned char)*cp); cp++) {
				}
				memsave(&up->u_class, cp, strlen(cp));
			} else if (strncmp(s, "inactive", 8) == 0) {
				for (cp = s + 8 ; isspace((unsigned char)*cp); cp++) {
				}
				if (strcmp(cp, UNSET_INACTIVE) == 0) {
					free(up->u_inactive);
					up->u_inactive = NULL;
				} else {
					memsave(&up->u_inactive, cp, strlen(cp));
				}
			} else if (strncmp(s, "range", 5) == 0) {
				for (cp = s + 5 ; isspace((unsigned char)*cp); cp++) {
				}
				(void) save_range(up, cp);
			} else if (strncmp(s, "preserve", 8) == 0) {
				for (cp = s + 8 ; isspace((unsigned char)*cp); cp++) {
				}
				up->u_preserve = (strncmp(cp, "true", 4) == 0) ? 1 :
						  (strncmp(cp, "yes", 3) == 0) ? 1 :
						   strtonum(cp, INT_MIN, INT_MAX, NULL);
			} else if (strncmp(s, "expire", 6) == 0) {
				for (cp = s + 6 ; isspace((unsigned char)*cp); cp++) {
				}
				if (strcmp(cp, UNSET_EXPIRY) == 0) {
					free(up->u_expire);
					up->u_expire = NULL;
				} else {
					memsave(&up->u_expire, cp, strlen(cp));
				}
			}
			free(s);
		}
		fclose(fp);
	}
	if (up->u_rc == 0) {
		up->u_rv[up->u_rc].r_from = DEF_LOWUID;
		up->u_rv[up->u_rc].r_to = DEF_HIGHUID;
		up->u_rc += 1;
	}
	up->u_defrc = up->u_rc;
}

/* return the next valid unused uid */
static int
getnextuid(int sync_uid_gid, uid_t *uid, uid_t low_uid, uid_t high_uid)
{
	for (*uid = low_uid ; *uid <= high_uid ; (*uid)++) {
		if (getpwuid((uid_t)(*uid)) == NULL && *uid != NOBODY_UID) {
			if (sync_uid_gid) {
				if (getgrgid((gid_t)(*uid)) == NULL) {
					return 1;
				}
			} else {
				return 1;
			}
		}
	}
	return 0;
}

/* look for a valid time, return 0 if it was specified but bad */
static int
scantime(time_t *tp, char *s)
{
	struct tm	tm;

	*tp = 0;
	if (s != NULL) {
		memset(&tm, 0, sizeof(tm));
		tm.tm_isdst = -1;
		if (strptime(s, "%c", &tm) != NULL) {
			*tp = mktime(&tm);
		} else if (strptime(s, "%B %d %Y", &tm) != NULL) {
			*tp = mktime(&tm);
		} else if (isdigit((unsigned char) s[0]) != 0) {
			*tp = (time_t)atoll(s);
		} else {
			return 0;
		}
	}
	return 1;
}

/* compute the extra length '&' expansion consumes */
static size_t
expand_len(const char *p, const char *username)
{
	size_t alen;
	size_t ulen;

	ulen = strlen(username);
	for (alen = 0; *p != '\0'; p++)
		if (*p == '&')
			alen += ulen - 1;
	return alen;
}

/* see if we can find out the user struct */
static struct passwd *
find_user_info(const char *name)
{
	struct passwd	*pwp;
	const char	*errstr;
	uid_t		uid;

	if ((pwp = getpwnam(name)) == NULL) {
		uid = strtonum(name, -1, UID_MAX, &errstr);
		if (errstr == NULL)
			pwp = getpwuid(uid);
	}
	return pwp;
}

/* see if we can find out the group struct */
static struct group *
find_group_info(const char *name)
{
	struct group	*grp;
	const char	*errstr;
	gid_t		gid;

	if ((grp = getgrnam(name)) == NULL) {
		gid = strtonum(name, -1, GID_MAX, &errstr);
		if (errstr == NULL)
			grp = getgrgid(gid);
	}
	return grp;
}

/* add a user */
static int
adduser(char *login_name, user_t *up)
{
	struct group	*grp;
	struct stat	st;
	time_t		expire;
	time_t		inactive;
	char		password[PasswordLength + 1];
	char		home[MaxFileNameLen];
	char		buf[LINE_MAX];
	int		sync_uid_gid;
	int		masterfd;
	int		ptmpfd;
	gid_t		gid;
	int		cc;
	int		i, yp = 0;
	FILE		*fp;

	if (!valid_login(login_name)) {
		errx(EXIT_FAILURE, "`%s' is not a valid login name", login_name);
	}
	if (!valid_class(up->u_class)) {
		errx(EXIT_FAILURE, "No such login class `%s'", up->u_class);
	}
	if ((masterfd = open(_PATH_MASTERPASSWD, O_RDONLY)) < 0) {
		err(EXIT_FAILURE, "can't open `%s'", _PATH_MASTERPASSWD);
	}
	if (flock(masterfd, LOCK_EX | LOCK_NB) < 0) {
		err(EXIT_FAILURE, "can't lock `%s'", _PATH_MASTERPASSWD);
	}
	pw_init();
	if ((ptmpfd = pw_lock(WAITSECS)) < 0) {
		int saved_errno = errno;
		close(masterfd);
		errc(EXIT_FAILURE, saved_errno, "can't obtain pw_lock");
	}
	if ((fp = fdopen(masterfd, "r")) == NULL) {
		int saved_errno = errno;
		close(masterfd);
		close(ptmpfd);
		pw_abort();
		errc(EXIT_FAILURE, saved_errno,
		    "can't fdopen `%s' for reading", _PATH_MASTERPASSWD);
	}
	while (fgets(buf, sizeof(buf), fp) != NULL) {
		cc = strlen(buf);
		/*
		 * Stop copying the file at the yp entry; we want to
		 * put the new user before it, and preserve entries
		 * after the yp entry.
		 */
		if (cc > 1 && buf[0] == '+' && buf[1] == ':') {
			yp = 1;
			break;
		}
		if (write(ptmpfd, buf, (size_t)(cc)) != cc) {
			int saved_errno = errno;
			fclose(fp);
			close(ptmpfd);
			pw_abort();
			errc(EXIT_FAILURE, saved_errno,
			    "short write to /etc/ptmp (not %d chars)", cc);
		}
	}
	if (ferror(fp)) {
		int saved_errno = errno;
		fclose(fp);
		close(ptmpfd);
		pw_abort();
		errc(EXIT_FAILURE, saved_errno, "read error on %s",
		    _PATH_MASTERPASSWD);
	}
	/* if no uid was specified, get next one in [low_uid..high_uid] range */
	sync_uid_gid = (strcmp(up->u_primgrp, "=uid") == 0);
	if (up->u_uid == UID_MAX) {
		int got_id = 0;

		/*
		 * Look for a free UID in the command line ranges (if any).
		 * These start after the ranges specified in the config file.
		 */
		for (i = up->u_defrc; got_id == 0 && i < up->u_rc ; i++) {
			got_id = getnextuid(sync_uid_gid, &up->u_uid,
			    up->u_rv[i].r_from, up->u_rv[i].r_to);
		}
		/*
		 * If there were no free UIDs in the command line ranges,
		 * try the ranges from the config file (there will always
		 * be at least one default).
		 */
		if (got_id == 0) {
			for (i = 0; got_id == 0 && i < up->u_defrc; i++) {
				got_id = getnextuid(sync_uid_gid, &up->u_uid,
				    up->u_rv[i].r_from, up->u_rv[i].r_to);
			}
		}
		if (got_id == 0) {
			close(ptmpfd);
			pw_abort();
			errx(EXIT_FAILURE, "can't get next uid for %u", up->u_uid);
		}
	}
	/* check uid isn't already allocated */
	if (!(up->u_flags & F_DUPUID) && getpwuid((uid_t)(up->u_uid)) != NULL) {
		close(ptmpfd);
		pw_abort();
		errx(EXIT_FAILURE, "uid %u is already in use", up->u_uid);
	}
	/* if -g=uid was specified, check gid is unused */
	if (sync_uid_gid) {
		if (getgrgid((gid_t)(up->u_uid)) != NULL) {
			close(ptmpfd);
			pw_abort();
			errx(EXIT_FAILURE, "gid %u is already in use", up->u_uid);
		}
		gid = up->u_uid;
	} else {
		if ((grp = find_group_info(up->u_primgrp)) == NULL) {
			close(ptmpfd);
			pw_abort();
			errx(EXIT_FAILURE, "group %s not found", up->u_primgrp);
		}
		gid = grp->gr_gid;
	}
	/* check name isn't already in use */
	if (!(up->u_flags & F_DUPUID) && getpwnam(login_name) != NULL) {
		close(ptmpfd);
		pw_abort();
		errx(EXIT_FAILURE, "already a `%s' user", login_name);
	}
	if (up->u_flags & F_HOMEDIR) {
		if (strlcpy(home, up->u_home, sizeof(home)) >= sizeof(home)) {
			close(ptmpfd);
			pw_abort();
			errx(EXIT_FAILURE, "home directory `%s' too long",
			    up->u_home);
		}
	} else {
		/* if home directory hasn't been given, make it up */
		if (snprintf(home, sizeof(home), "%s/%s", up->u_basedir,
		    login_name) >= sizeof(home)) {
			close(ptmpfd);
			pw_abort();
			errx(EXIT_FAILURE, "home directory `%s/%s' too long",
			    up->u_basedir, login_name);
		}
	}
	if (!scantime(&inactive, up->u_inactive)) {
		warnx("Warning: inactive time `%s' invalid, password expiry off",
				up->u_inactive);
	}
	if (!scantime(&expire, up->u_expire)) {
		warnx("Warning: expire time `%s' invalid, account expiry off",
				up->u_expire);
	}
	if (lstat(home, &st) < 0 && !(up->u_flags & F_MKDIR) &&
	    strcmp(home, _PATH_NONEXISTENT) != 0) {
		warnx("Warning: home directory `%s' doesn't exist, and -m was"
		    " not specified", home);
	}
	(void) strlcpy(password, up->u_password ? up->u_password : "*",
	    sizeof(password));
	cc = snprintf(buf, sizeof(buf), "%s:%s:%u:%u:%s:%lld:%lld:%s:%s:%s\n",
	    login_name,
	    password,
	    up->u_uid,
	    gid,
	    up->u_class,
	    (long long) inactive,
	    (long long) expire,
	    up->u_comment,
	    home,
	    up->u_shell);
	if (cc >= sizeof(buf) || cc < 0 ||
	    cc + expand_len(up->u_comment, login_name) >= 1023) {
		close(ptmpfd);
		pw_abort();
		errx(EXIT_FAILURE, "can't add `%s', line too long", buf);
	}
	if (write(ptmpfd, buf, (size_t) cc) != cc) {
		int saved_errno = errno;
		close(ptmpfd);
		pw_abort();
		errc(EXIT_FAILURE, saved_errno, "can't add `%s'", buf);
	}
	if (yp) {
		/* put back the + line */
		cc = snprintf(buf, sizeof(buf), "+:*::::::::\n");
		if (cc == -1 || cc >= sizeof(buf)) {
			close(ptmpfd);
			pw_abort();
			errx(EXIT_FAILURE, "can't add `%s', line too long", buf);
		}
		if (write(ptmpfd, buf, (size_t) cc) != cc) {
			int saved_errno = errno;
			close(ptmpfd);
			pw_abort();
			errc(EXIT_FAILURE, saved_errno, "can't add `%s'", buf);
		}
		/* copy the entries following it, if any */
		while (fgets(buf, sizeof(buf), fp) != NULL) {
			cc = strlen(buf);
			if (write(ptmpfd, buf, (size_t)(cc)) != cc) {
				int saved_errno = errno;
				fclose(fp);
				close(ptmpfd);
				pw_abort();
				errc(EXIT_FAILURE, saved_errno,
				    "short write to /etc/ptmp (not %d chars)",
				    cc);
			}
		}
		if (ferror(fp)) {
			int saved_errno = errno;
			fclose(fp);
			close(ptmpfd);
			pw_abort();
			errc(EXIT_FAILURE, saved_errno, "read error on %s",
			    _PATH_MASTERPASSWD);
		}
	}
	if (up->u_flags & F_MKDIR) {
		if (lstat(home, &st) == 0) {
			close(ptmpfd);
			pw_abort();
			errx(EXIT_FAILURE, "home directory `%s' already exists",
			    home);
		} else {
			if (asystem("%s -p %s", MKDIR, home) != 0) {
				int saved_errno = errno;
				close(ptmpfd);
				pw_abort();
				errc(EXIT_FAILURE, saved_errno,
				    "can't mkdir `%s'", home);
			}
			(void) copydotfiles(up->u_skeldir, up->u_uid, gid, home);
			(void) asystem("%s -R -P %u:%u %s", CHOWN, up->u_uid,
			    gid, home);
			(void) asystem("%s -R u+w %s", CHMOD, home);
		}
	}
	if (strcmp(up->u_primgrp, "=uid") == 0 &&
	    getgrnam(login_name) == NULL &&
	    !creategid(login_name, gid, "")) {
		close(ptmpfd);
		pw_abort();
		errx(EXIT_FAILURE, "can't create gid %u for login name %s",
		    gid, login_name);
	}
	if (up->u_groupc > 0 && !append_group(login_name, up->u_groupc, up->u_groupv)) {
		close(ptmpfd);
		pw_abort();
		errx(EXIT_FAILURE, "can't append `%s' to new groups", login_name);
	}
	fclose(fp);
	close(ptmpfd);
	if (pw_mkdb(yp ? NULL : login_name, 0) < 0) {
		pw_abort();
		err(EXIT_FAILURE, "pw_mkdb failed");
	}
	syslog(LOG_INFO, "new user added: name=%s, uid=%u, gid=%u, home=%s, shell=%s",
		login_name, up->u_uid, gid, home, up->u_shell);
	return 1;
}

/* remove a user from the groups file */
static int
rm_user_from_groups(char *login_name)
{
	struct stat	st;
	size_t		login_len;
	FILE		*from;
	FILE		*to;
	char		buf[LINE_MAX];
	char		f[MaxFileNameLen];
	char		*cp, *ep;
	int		fd;
	int		cc;

	login_len = strlen(login_name);
	if ((from = fopen(_PATH_GROUP, "r")) == NULL) {
		warn("can't remove gid for `%s': can't open `%s'",
		    login_name, _PATH_GROUP);
		return 0;
	}
	if (flock(fileno(from), LOCK_EX | LOCK_NB) < 0) {
		warn("can't lock `%s'", _PATH_GROUP);
	}
	(void) fstat(fileno(from), &st);
	(void) snprintf(f, sizeof(f), "%s.XXXXXXXX", _PATH_GROUP);
	if ((fd = mkstemp(f)) < 0) {
		warn("can't remove gid for `%s': mkstemp failed", login_name);
		fclose(from);
		return 0;
	}
	if ((to = fdopen(fd, "w")) == NULL) {
		warn("can't remove gid for `%s': fdopen `%s' failed",
		    login_name, f);
		fclose(from);
		close(fd);
		unlink(f);
		return 0;
	}
	while (fgets(buf, sizeof(buf), from) != NULL) {
		cc = strlen(buf);
		if (cc > 0 && buf[cc - 1] != '\n' && !feof(from)) {
			while (fgetc(from) != '\n' && !feof(from))
				cc++;
			warnx("%s: line `%s' too long (%d bytes), skipping",
			    _PATH_GROUP, buf, cc);
			continue;
		}

		/* Break out the group list. */
		for (cp = buf, cc = 0; *cp != '\0' && cc < 3; cp++) {
			if (*cp == ':')
				cc++;
		}
		if (cc != 3) {
			buf[strcspn(buf, "\n")] = '\0';
			warnx("Malformed entry `%s'. Skipping", buf);
			continue;
		}
		while ((cp = strstr(cp, login_name)) != NULL) {
			if ((cp[-1] == ':' || cp[-1] == ',') &&
			    (cp[login_len] == ',' || cp[login_len] == '\n')) {
				ep = cp + login_len;
				if (cp[login_len] == ',')
					ep++;
				else if (cp[-1] == ',')
					cp--;
				memmove(cp, ep, strlen(ep) + 1);
			} else {
				if ((cp = strchr(cp, ',')) == NULL)
					break;
				cp++;
			}
		}
		if (fwrite(buf, strlen(buf), 1, to) != 1) {
			warn("can't remove gid for `%s': short write to `%s'",
			    login_name, f);
			fclose(from);
			fclose(to);
			unlink(f);
			return 0;
		}
	}
	(void) fchmod(fileno(to), st.st_mode & 0777);
	fclose(from);
	if (fclose(to) == EOF) {
		warn("can't remove gid for `%s': short write to `%s'",
		    login_name, f);
		unlink(f);
		return 0;
	}
	if (rename(f, _PATH_GROUP) < 0) {
		warn("can't remove gid for `%s': can't rename `%s' to `%s'",
		    login_name, f, _PATH_GROUP);
		unlink(f);
		return 0;
	}
	return 1;
}

/* check that the user or group is local, not from YP/NIS */
static int
is_local(char *name, const char *file)
{
	FILE		*fp;
	char		buf[LINE_MAX];
	size_t		len;
	int		ret;
	int		cc;

	if ((fp = fopen(file, "r")) == NULL) {
		err(EXIT_FAILURE, "can't open `%s'", file);
	}
	len = strlen(name);
	for (ret = 0 ; fgets(buf, sizeof(buf), fp) != NULL ; ) {
		cc = strlen(buf);
		if (cc > 0 && buf[cc - 1] != '\n' && !feof(fp)) {
			while (fgetc(fp) != '\n' && !feof(fp))
				cc++;
			warnx("%s: line `%s' too long (%d bytes), skipping",
			    file, buf, cc);
			continue;
		}
		if (strncmp(buf, name, len) == 0 && buf[len] == ':') {
			ret = 1;
			break;
		}
	}
	fclose(fp);
	return ret;
}

/* modify a user */
static int
moduser(char *login_name, char *newlogin, user_t *up)
{
	struct passwd	*pwp = NULL;
	struct group	*grp;
	const char	*homedir;
	char		buf[LINE_MAX];
	char		acctlock_str[] = "-";
	char		pwlock_str[] = "*";
	char		pw_len[PasswordLength + 1];
	char		shell_len[MaxShellNameLen];
	char		*shell_last_char;
	size_t		colonc, loginc;
	size_t		cc;
	size_t		shell_buf;
	FILE		*master;
	char		newdir[MaxFileNameLen];
	char		*colon;
	char		*pw_tmp = NULL;
	char		*shell_tmp = NULL;
	int		len;
	int		locked = 0;
	int		unlocked = 0;
	int		masterfd;
	int		ptmpfd;
	int		rval;
	int		i;

	if (!valid_login(newlogin)) {
		errx(EXIT_FAILURE, "`%s' is not a valid login name", login_name);
	}
	if ((pwp = getpwnam_shadow(login_name)) == NULL) {
		errx(EXIT_FAILURE, "No such user `%s'", login_name);
	}
	if (up != NULL) {
		if ((*pwp->pw_passwd != '\0') &&
		    (up->u_flags & F_PASSWORD) == 0) {
			up->u_flags |= F_PASSWORD;
			memsave(&up->u_password, pwp->pw_passwd,
			    strlen(pwp->pw_passwd));
			memset(pwp->pw_passwd, 'X', strlen(pwp->pw_passwd));
		}
	}
	endpwent();

	if (pledge("stdio rpath wpath cpath fattr flock proc exec getpw id",
	    NULL) == -1)
		err(1, "pledge");

	if (!is_local(login_name, _PATH_MASTERPASSWD)) {
		errx(EXIT_FAILURE, "User `%s' must be a local user", login_name);
	}
	if (up != NULL) {
		if ((up->u_flags & (F_ACCTLOCK | F_ACCTUNLOCK)) && (pwp->pw_uid < 1000))
			errx(EXIT_FAILURE, "(un)locking is not supported for the `%s' account", pwp->pw_name);
	}
	/* keep dir name in case we need it for '-m' */
	homedir = pwp->pw_dir;

	/* get the last char of the shell in case we need it for '-U' or '-Z' */
	shell_last_char = pwp->pw_shell+strlen(pwp->pw_shell) - 1;

	if ((masterfd = open(_PATH_MASTERPASSWD, O_RDONLY)) < 0) {
		err(EXIT_FAILURE, "can't open `%s'", _PATH_MASTERPASSWD);
	}
	if (flock(masterfd, LOCK_EX | LOCK_NB) < 0) {
		err(EXIT_FAILURE, "can't lock `%s'", _PATH_MASTERPASSWD);
	}
	pw_init();
	if ((ptmpfd = pw_lock(WAITSECS)) < 0) {
		int saved_errno = errno;
		close(masterfd);
		errc(EXIT_FAILURE, saved_errno, "can't obtain pw_lock");
	}
	if ((master = fdopen(masterfd, "r")) == NULL) {
		int saved_errno = errno;
		close(masterfd);
		close(ptmpfd);
		pw_abort();
		errc(EXIT_FAILURE, saved_errno, "can't fdopen fd for %s",
		    _PATH_MASTERPASSWD);
	}
	if (up != NULL) {
		if (up->u_flags & F_USERNAME) {
			/* if changing name, check new name isn't already in use */
			if (strcmp(login_name, newlogin) != 0 && getpwnam(newlogin) != NULL) {
				close(ptmpfd);
				pw_abort();
				errx(EXIT_FAILURE, "already a `%s' user", newlogin);
			}
			pwp->pw_name = newlogin;

			/*
			 * Provide a new directory name in case the
			 * home directory is to be moved.
			 */
			if (up->u_flags & F_MKDIR) {
				(void) snprintf(newdir, sizeof(newdir),
				    "%s/%s", up->u_basedir, newlogin);
				pwp->pw_dir = newdir;
			}
		}
		if (up->u_flags & F_PASSWORD) {
			if (up->u_password != NULL)
				pwp->pw_passwd = up->u_password;
		}
		if (up->u_flags & F_ACCTLOCK) {
			/* lock the account */
			if (*shell_last_char != *acctlock_str) {
				shell_tmp = malloc(strlen(pwp->pw_shell) + sizeof(acctlock_str));
				if (shell_tmp == NULL) {
					close(ptmpfd);
					pw_abort();
					errx(EXIT_FAILURE, "account lock: cannot allocate memory");
				}
				strlcpy(shell_tmp, pwp->pw_shell, sizeof(shell_len));
				strlcat(shell_tmp, acctlock_str, sizeof(shell_len));
				pwp->pw_shell = shell_tmp;
			} else {
				locked++;
			}
			/* lock the password */
			if (strncmp(pwp->pw_passwd, pwlock_str, sizeof(pwlock_str)-1) != 0) {
				pw_tmp = malloc(strlen(pwp->pw_passwd) + sizeof(pwlock_str));
				if (pw_tmp == NULL) {
					close(ptmpfd);
					pw_abort();
					errx(EXIT_FAILURE, "password lock: cannot allocate memory");
				}
				strlcpy(pw_tmp, pwlock_str, sizeof(pw_len));
				strlcat(pw_tmp, pwp->pw_passwd, sizeof(pw_len));
				pwp->pw_passwd = pw_tmp;
			} else {
				locked++;
			}

			if (locked > 1)
				warnx("account `%s' is already locked", pwp->pw_name);
		}
		if (up->u_flags & F_ACCTUNLOCK) {
			/* unlock the password */
			if (strcmp(pwp->pw_passwd, pwlock_str) != 0 &&
			    strcmp(pwp->pw_passwd, "*************") != 0) {
				if (strncmp(pwp->pw_passwd, pwlock_str, sizeof(pwlock_str)-1) == 0) {
					pwp->pw_passwd += sizeof(pwlock_str)-1;
				} else {
					unlocked++;
				}
			} else {
				warnx("account `%s' has no password: cannot fully unlock", pwp->pw_name);
			}
			/* unlock the account */
			if (*shell_last_char == *acctlock_str) {
				shell_buf = strlen(pwp->pw_shell) + 2 - sizeof(acctlock_str);
				shell_tmp = malloc(shell_buf);
				if (shell_tmp == NULL) {
					close(ptmpfd);
					pw_abort();
					errx(EXIT_FAILURE, "unlock: cannot allocate memory");
				}
				strlcpy(shell_tmp, pwp->pw_shell, shell_buf);
				pwp->pw_shell = shell_tmp;
			} else {
				unlocked++;
			}

			if (unlocked > 1)
				warnx("account `%s' is not locked", pwp->pw_name);
		}
		if (up->u_flags & F_UID) {
			/* check uid isn't already allocated */
			if (!(up->u_flags & F_DUPUID) && getpwuid((uid_t)(up->u_uid)) != NULL) {
				close(ptmpfd);
				pw_abort();
				errx(EXIT_FAILURE, "uid %u is already in use", up->u_uid);
			}
			pwp->pw_uid = up->u_uid;
		}
		if (up->u_flags & F_GROUP) {
			/* if -g=uid was specified, check gid is unused */
			if (strcmp(up->u_primgrp, "=uid") == 0) {
				if (getgrgid((gid_t)(pwp->pw_uid)) != NULL) {
					close(ptmpfd);
					pw_abort();
					errx(EXIT_FAILURE, "gid %u is already "
					    "in use", pwp->pw_uid);
				}
				pwp->pw_gid = pwp->pw_uid;
				if (!creategid(newlogin, pwp->pw_gid, "")) {
					close(ptmpfd);
					pw_abort();
					errx(EXIT_FAILURE, "could not create "
					    "group %s with gid %u", newlogin,
					    pwp->pw_gid);
				}
			} else {
				if ((grp = find_group_info(up->u_primgrp)) == NULL) {
					close(ptmpfd);
					pw_abort();
					errx(EXIT_FAILURE, "group %s not found",
					    up->u_primgrp);
				}
				pwp->pw_gid = grp->gr_gid;
			}
		}
		if (up->u_flags & F_INACTIVE) {
			if (!scantime(&pwp->pw_change, up->u_inactive)) {
				warnx("Warning: inactive time `%s' invalid, password expiry off",
					up->u_inactive);
			}
		}
		if (up->u_flags & F_EXPIRE) {
			if (!scantime(&pwp->pw_expire, up->u_expire)) {
				warnx("Warning: expire time `%s' invalid, account expiry off",
					up->u_expire);
			}
		}
		if (up->u_flags & F_COMMENT)
			pwp->pw_gecos = up->u_comment;
		if (up->u_flags & F_HOMEDIR)
			pwp->pw_dir = up->u_home;
		if (up->u_flags & F_SHELL)
			pwp->pw_shell = up->u_shell;
		if (up->u_flags & F_CLASS) {
			if (!valid_class(up->u_class)) {
				close(ptmpfd);
				pw_abort();
				errx(EXIT_FAILURE,
				    "No such login class `%s'", up->u_class);
			}
			pwp->pw_class = up->u_class;
		}
	}
	loginc = strlen(login_name);
	while (fgets(buf, sizeof(buf), master) != NULL) {
		if ((colon = strchr(buf, ':')) == NULL) {
			warnx("Malformed entry `%s'. Skipping", buf);
			continue;
		}
		colonc = (size_t)(colon - buf);
		if (strncmp(login_name, buf, loginc) == 0 && loginc == colonc) {
			if (up != NULL) {
				if ((len = snprintf(buf, sizeof(buf),
				    "%s:%s:%u:%u:%s:%lld:%lld:%s:%s:%s\n",
				    newlogin,
				    pwp->pw_passwd,
				    pwp->pw_uid,
				    pwp->pw_gid,
				    pwp->pw_class,
				    (long long)pwp->pw_change,
				    (long long)pwp->pw_expire,
				    pwp->pw_gecos,
				    pwp->pw_dir,
				    pwp->pw_shell)) >= sizeof(buf) || len < 0 ||
				    len + expand_len(pwp->pw_gecos, newlogin)
				    >= 1023) {
					close(ptmpfd);
					pw_abort();
					errx(EXIT_FAILURE, "can't add `%s', "
					    "line too long (%zu bytes)", buf,
					    len + expand_len(pwp->pw_gecos,
					    newlogin));
				}
				if (write(ptmpfd, buf, len) != len) {
					int saved_errno = errno;
					close(ptmpfd);
					pw_abort();
					errc(EXIT_FAILURE, saved_errno,
					    "can't add `%s'", buf);
				}
			}
		} else {
			len = strlen(buf);
			if ((cc = write(ptmpfd, buf, len)) != len) {
				int saved_errno = errno;
				close(masterfd);
				close(ptmpfd);
				pw_abort();
				errc(EXIT_FAILURE, saved_errno,
				    "short write to /etc/ptmp (%lld not %lld chars)",
				    (long long)cc, (long long)len);
			}
		}
	}
	if (up != NULL) {
		if ((up->u_flags & F_MKDIR) &&
		    asystem("%s %s %s", MV, homedir, pwp->pw_dir) != 0) {
			int saved_errno = errno;
			close(ptmpfd);
			pw_abort();
			errc(EXIT_FAILURE, saved_errno,
			    "can't move `%s' to `%s'", homedir, pwp->pw_dir);
		}
		if (up->u_flags & F_SETSECGROUP) {
			for (i = 0 ; i < up->u_groupc ; i++) {
				if (getgrnam(up->u_groupv[i]) == NULL) {
					close(ptmpfd);
					pw_abort();
					errx(EXIT_FAILURE,
					    "aborting, group `%s' does not exist",
					    up->u_groupv[i]);
				}
			}
			if (!rm_user_from_groups(newlogin)) {
				close(ptmpfd);
				pw_abort();
				errx(EXIT_FAILURE,
				    "can't reset groups for `%s'", newlogin);
			}
		}
		if (up->u_groupc > 0) {
		    if (!append_group(newlogin, up->u_groupc, up->u_groupv)) {
			close(ptmpfd);
			pw_abort();
			errx(EXIT_FAILURE, "can't append `%s' to new groups",
			    newlogin);
		    }
		}
	}
	fclose(master);
	close(ptmpfd);
	free(pw_tmp);
	free(shell_tmp);
	if (up != NULL && strcmp(login_name, newlogin) == 0)
		rval = pw_mkdb(login_name, 0);
	else
		rval = pw_mkdb(NULL, 0);
	if (rval == -1) {
		pw_abort();
		err(EXIT_FAILURE, "pw_mkdb failed");
	}
	if (up == NULL) {
		syslog(LOG_INFO, "user removed: name=%s", login_name);
	} else if (strcmp(login_name, newlogin) == 0) {
		syslog(LOG_INFO, "user information modified: name=%s, uid=%u, gid=%u, home=%s, shell=%s",
			login_name, pwp->pw_uid, pwp->pw_gid, pwp->pw_dir, pwp->pw_shell);
	} else {
		syslog(LOG_INFO, "user information modified: name=%s, new name=%s, uid=%u, gid=%u, home=%s, shell=%s",
			login_name, newlogin, pwp->pw_uid, pwp->pw_gid, pwp->pw_dir, pwp->pw_shell);
	}
	return 1;
}

/* print out usage message, and then exit */
void
usermgmt_usage(const char *prog)
{
	if (strcmp(prog, "useradd") == 0) {
		fprintf(stderr, "usage: %s -D [-b base-directory] "
		    "[-e expiry-time] [-f inactive-time]\n"
		    "               [-g gid | name | =uid] [-k skel-directory] "
		    "[-L login-class]\n"
		    "               [-r low..high] [-s shell]\n", prog);
		fprintf(stderr, "       %s [-mov] [-b base-directory] "
		    "[-c comment] [-d home-directory]\n"
		    "               [-e expiry-time] [-f inactive-time]\n"
		    "               [-G secondary-group[,group,...]] "
		    "[-g gid | name | =uid]\n"
		    "               [-k skel-directory] [-L login-class] "
		    "[-p password] [-r low..high]\n"
		    "               [-s shell] [-u uid] user\n", prog);
	} else if (strcmp(prog, "usermod") == 0) {
		fprintf(stderr, "usage: %s [-moUvZ] "
		    "[-c comment] [-d home-directory] [-e expiry-time]\n"
		    "               [-f inactive-time] "
		    "[-G secondary-group[,group,...]]\n"
		    "               [-g gid | name | =uid] [-L login-class] "
		    "[-l new-login]\n"
		    "               [-p password] "
		    "[-S secondary-group[,group,...]]\n"
		    "               [-s shell] [-u uid] user\n",
		    prog);
	} else if (strcmp(prog, "userdel") == 0) {
		fprintf(stderr, "usage: %s -D [-p preserve-value]\n",
		    prog);
		fprintf(stderr, "       %s [-rv] [-p preserve-value] "
		    "user\n", prog);
	} else if (strcmp(prog, "userinfo") == 0) {
		fprintf(stderr, "usage: %s [-e] user\n", prog);
	} else if (strcmp(prog, "groupadd") == 0) {
		fprintf(stderr, "usage: %s [-ov] [-g gid] group\n",
		    prog);
	} else if (strcmp(prog, "groupdel") == 0) {
		fprintf(stderr, "usage: %s [-v] group\n", prog);
	} else if (strcmp(prog, "groupmod") == 0) {
		fprintf(stderr, "usage: %s [-ov] [-g gid] [-n newname] "
		    "group\n", prog);
	} else if (strcmp(prog, "user") == 0 || strcmp(prog, "group") == 0) {
		fprintf(stderr, "usage: %s [add | del | mod"
		" | info"
		"] ...\n",
		    prog);
	} else if (strcmp(prog, "groupinfo") == 0) {
		fprintf(stderr, "usage: %s [-e] group\n", prog);
	} else {
		fprintf(stderr, "This program must be called as {user,group}{add,del,mod,info},\n%s is not an understood name.\n", prog);
	}
	exit(EXIT_FAILURE);
}

int
useradd(int argc, char **argv)
{
	user_t	u;
	const char *errstr;
	int	defaultfield;
	int	bigD;
	int	c;
	int	i;

	memset(&u, 0, sizeof(u));
	read_defaults(&u);
	u.u_uid = UID_MAX;
	defaultfield = bigD = 0;
	while ((c = getopt(argc, argv, "DG:L:b:c:d:e:f:g:k:mop:r:s:u:v")) != -1) {
		switch(c) {
		case 'D':
			bigD = 1;
			break;
		case 'G':
			while ((u.u_groupv[u.u_groupc] = strsep(&optarg, ",")) != NULL &&
			    u.u_groupc < NGROUPS_MAX - 2) {
				if (u.u_groupv[u.u_groupc][0] != 0) {
					u.u_groupc++;
				}
			}
			if (optarg != NULL) {
				warnx("Truncated list of secondary groups to %d entries", NGROUPS_MAX - 2);
			}
			break;
		case 'b':
			defaultfield = 1;
			memsave(&u.u_basedir, optarg, strlen(optarg));
			break;
		case 'c':
			memsave(&u.u_comment, optarg, strlen(optarg));
			break;
		case 'd':
			memsave(&u.u_home, optarg, strlen(optarg));
			u.u_flags |= F_HOMEDIR;
			break;
		case 'e':
			defaultfield = 1;
			memsave(&u.u_expire, optarg, strlen(optarg));
			break;
		case 'f':
			defaultfield = 1;
			memsave(&u.u_inactive, optarg, strlen(optarg));
			break;
		case 'g':
			defaultfield = 1;
			memsave(&u.u_primgrp, optarg, strlen(optarg));
			break;
		case 'k':
			defaultfield = 1;
			memsave(&u.u_skeldir, optarg, strlen(optarg));
			break;
		case 'L':
			defaultfield = 1;
			memsave(&u.u_class, optarg, strlen(optarg));
			break;
		case 'm':
			u.u_flags |= F_MKDIR;
			break;
		case 'o':
			u.u_flags |= F_DUPUID;
			break;
		case 'p':
			memsave(&u.u_password, optarg, strlen(optarg));
			memset(optarg, 'X', strlen(optarg));
			break;
		case 'r':
			defaultfield = 1;
			(void) save_range(&u, optarg);
			break;
		case 's':
			defaultfield = 1;
			memsave(&u.u_shell, optarg, strlen(optarg));
			break;
		case 'u':
			u.u_uid = strtonum(optarg, -1, UID_MAX, &errstr);
			if (errstr != NULL) {
				errx(EXIT_FAILURE, "When using [-u uid], the uid must be numeric");
			}
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			usermgmt_usage("useradd");
		}
	}

	if (pledge("stdio rpath wpath cpath fattr flock proc exec getpw id",
	    NULL) == -1)
		err(1, "pledge");

	if (bigD) {
		if (defaultfield) {
			checkeuid();
			return setdefaults(&u) ? EXIT_SUCCESS : EXIT_FAILURE;
		}
		printf("group\t\t%s\n", u.u_primgrp);
		printf("base_dir\t%s\n", u.u_basedir);
		printf("skel_dir\t%s\n", u.u_skeldir);
		printf("shell\t\t%s\n", u.u_shell);
		printf("class\t\t%s\n", u.u_class);
		printf("inactive\t%s\n", (u.u_inactive == NULL) ? UNSET_INACTIVE : u.u_inactive);
		printf("expire\t\t%s\n", (u.u_expire == NULL) ? UNSET_EXPIRY : u.u_expire);
		for (i = 0 ; i < u.u_rc ; i++) {
			printf("range\t\t%u..%u\n", u.u_rv[i].r_from, u.u_rv[i].r_to);
		}
		return EXIT_SUCCESS;
	}
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("useradd");
	}
	checkeuid();
	openlog("useradd", LOG_PID, LOG_USER);
	return adduser(*argv, &u) ? EXIT_SUCCESS : EXIT_FAILURE;
}

int
usermod(int argc, char **argv)
{
	user_t	u;
	char	newuser[MaxUserNameLen + 1];
	int	c, have_new_user;
	const char *errstr;

	memset(&u, 0, sizeof(u));
	memset(newuser, 0, sizeof(newuser));
	read_defaults(&u);
	free(u.u_primgrp);
	u.u_primgrp = NULL;
	have_new_user = 0;
	while ((c = getopt(argc, argv, "G:L:S:UZc:d:e:f:g:l:mop:s:u:v")) != -1) {
		switch(c) {
		case 'G':
			while ((u.u_groupv[u.u_groupc] = strsep(&optarg, ",")) != NULL &&
			    u.u_groupc < NGROUPS_MAX - 2) {
				if (u.u_groupv[u.u_groupc][0] != 0) {
					u.u_groupc++;
				}
			}
			if (optarg != NULL) {
				warnx("Truncated list of secondary groups to %d entries", NGROUPS_MAX - 2);
			}
			u.u_flags |= F_SECGROUP;
			break;
		case 'S':
			while ((u.u_groupv[u.u_groupc] = strsep(&optarg, ",")) != NULL &&
			    u.u_groupc < NGROUPS_MAX - 2) {
				if (u.u_groupv[u.u_groupc][0] != 0) {
					u.u_groupc++;
				}
			}
			if (optarg != NULL) {
				warnx("Truncated list of secondary groups to %d entries", NGROUPS_MAX - 2);
			}
			u.u_flags |= F_SETSECGROUP;
			break;
		case 'U':
			u.u_flags |= F_ACCTUNLOCK;
			break;
		case 'Z':
			u.u_flags |= F_ACCTLOCK;
			break;
		case 'c':
			memsave(&u.u_comment, optarg, strlen(optarg));
			u.u_flags |= F_COMMENT;
			break;
		case 'd':
			memsave(&u.u_home, optarg, strlen(optarg));
			u.u_flags |= F_HOMEDIR;
			break;
		case 'e':
			memsave(&u.u_expire, optarg, strlen(optarg));
			u.u_flags |= F_EXPIRE;
			break;
		case 'f':
			memsave(&u.u_inactive, optarg, strlen(optarg));
			u.u_flags |= F_INACTIVE;
			break;
		case 'g':
			memsave(&u.u_primgrp, optarg, strlen(optarg));
			u.u_flags |= F_GROUP;
			break;
		case 'l':
			if (strlcpy(newuser, optarg, sizeof(newuser)) >=
			    sizeof(newuser))
				errx(EXIT_FAILURE, "username `%s' too long",
				    optarg);
			have_new_user = 1;
			u.u_flags |= F_USERNAME;
			break;
		case 'L':
			memsave(&u.u_class, optarg, strlen(optarg));
			u.u_flags |= F_CLASS;
			break;
		case 'm':
			u.u_flags |= F_MKDIR;
			break;
		case 'o':
			u.u_flags |= F_DUPUID;
			break;
		case 'p':
			memsave(&u.u_password, optarg, strlen(optarg));
			memset(optarg, 'X', strlen(optarg));
			u.u_flags |= F_PASSWORD;
			break;
		case 's':
			memsave(&u.u_shell, optarg, strlen(optarg));
			u.u_flags |= F_SHELL;
			break;
		case 'u':
			u.u_uid = strtonum(optarg, -1, UID_MAX, &errstr);
			u.u_flags |= F_UID;
			if (errstr != NULL) {
				errx(EXIT_FAILURE, "When using [-u uid], the uid must be numeric");
			}
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			usermgmt_usage("usermod");
		}
	}

	if ((u.u_flags & F_MKDIR) && !(u.u_flags & F_HOMEDIR) &&
	    !(u.u_flags & F_USERNAME)) {
		warnx("option 'm' useless without 'd' or 'l' -- ignored");
		u.u_flags &= ~F_MKDIR;
	}
	if ((u.u_flags & F_SECGROUP) && (u.u_flags & F_SETSECGROUP))
		errx(EXIT_FAILURE, "options 'G' and 'S' are mutually exclusive");
	if ((u.u_flags & F_ACCTLOCK) && (u.u_flags & F_ACCTUNLOCK))
		errx(EXIT_FAILURE, "options 'U' and 'Z' are mutually exclusive");
	if ((u.u_flags & F_PASSWORD) && (u.u_flags & (F_ACCTLOCK | F_ACCTUNLOCK)))
		errx(EXIT_FAILURE, "options 'U' or 'Z' with 'p' are mutually exclusive");
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("usermod");
	}
	checkeuid();
	openlog("usermod", LOG_PID, LOG_USER);
	return moduser(*argv, (have_new_user) ? newuser : *argv, &u) ?
	    EXIT_SUCCESS : EXIT_FAILURE;
}

int
userdel(int argc, char **argv)
{
	struct passwd	*pwp;
	user_t		u;
	int		defaultfield;
	int		rmhome;
	int		bigD;
	int		c;

	memset(&u, 0, sizeof(u));
	read_defaults(&u);
	defaultfield = bigD = rmhome = 0;
	while ((c = getopt(argc, argv, "Dp:rv")) != -1) {
		switch(c) {
		case 'D':
			bigD = 1;
			break;
		case 'p':
			defaultfield = 1;
			u.u_preserve = (strcmp(optarg, "true") == 0) ? 1 :
					(strcmp(optarg, "yes") == 0) ? 1 :
					 strtonum(optarg, INT_MIN, INT_MAX, NULL);
			break;
		case 'r':
			rmhome = 1;
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			usermgmt_usage("userdel");
		}
	}
	if (bigD) {
		if (defaultfield) {
			checkeuid();
			return setdefaults(&u) ? EXIT_SUCCESS : EXIT_FAILURE;
		}
		printf("preserve\t%s\n", (u.u_preserve) ? "true" : "false");
		return EXIT_SUCCESS;
	}
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("userdel");
	}

	if (pledge("stdio rpath wpath cpath fattr flock proc exec getpw id",
	    NULL) == -1)
		err(1, "pledge");

	checkeuid();
	if ((pwp = getpwnam(*argv)) == NULL) {
		warnx("No such user `%s'", *argv);
		return EXIT_FAILURE;
	}
	if (rmhome)
		(void)removehomedir(pwp->pw_name, pwp->pw_uid, pwp->pw_dir);
	if (u.u_preserve) {
		u.u_flags |= F_SHELL;
		memsave(&u.u_shell, NOLOGIN, strlen(NOLOGIN));
		memsave(&u.u_password, "*", strlen("*"));
		u.u_flags |= F_PASSWORD;
		openlog("userdel", LOG_PID, LOG_USER);
		return moduser(*argv, *argv, &u) ? EXIT_SUCCESS : EXIT_FAILURE;
	}
	if (!rm_user_from_groups(*argv)) {
		return 0;
	}
	openlog("userdel", LOG_PID, LOG_USER);
	return moduser(*argv, *argv, NULL) ? EXIT_SUCCESS : EXIT_FAILURE;
}

/* add a group */
int
groupadd(int argc, char **argv)
{
	int	dupgid;
	int	gid;
	int	c;
	const char *errstr;

	gid = GID_MAX;
	dupgid = 0;
	while ((c = getopt(argc, argv, "g:ov")) != -1) {
		switch(c) {
		case 'g':
			gid = strtonum(optarg, -1, GID_MAX, &errstr);
			if (errstr != NULL) {
				errx(EXIT_FAILURE, "When using [-g gid], the gid must be numeric");
			}
			break;
		case 'o':
			dupgid = 1;
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			usermgmt_usage("groupadd");
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("groupadd");
	}

	if (pledge("stdio rpath wpath cpath fattr flock getpw", NULL) == -1)
		err(1, "pledge");

	checkeuid();
	if (!valid_group(*argv)) {
		errx(EXIT_FAILURE, "invalid group name `%s'", *argv);
	}
	if (gid < 0 && !getnextgid(&gid, LowGid, HighGid)) {
		errx(EXIT_FAILURE, "can't add group: can't get next gid");
	}
	if (!dupgid && getgrgid((gid_t) gid) != NULL) {
		errx(EXIT_FAILURE, "can't add group: gid %d is a duplicate", gid);
	}
	openlog("groupadd", LOG_PID, LOG_USER);
	if (!creategid(*argv, gid, "")) {
		errx(EXIT_FAILURE, "can't add group: problems with %s file",
		    _PATH_GROUP);
	}
	return EXIT_SUCCESS;
}

/* remove a group */
int
groupdel(int argc, char **argv)
{
	int	c;

	while ((c = getopt(argc, argv, "v")) != -1) {
		switch(c) {
		case 'v':
			verbose = 1;
			break;
		default:
			usermgmt_usage("groupdel");
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("groupdel");
	}
	checkeuid();
	openlog("groupdel", LOG_PID, LOG_USER);
	if (getgrnam(*argv) == NULL) {
		warnx("No such group: `%s'", *argv);
		return EXIT_FAILURE;
	}

	if (pledge("stdio rpath wpath cpath fattr flock", NULL) == -1)
		err(1, "pledge");

	if (!modify_gid(*argv, NULL)) {
		err(EXIT_FAILURE, "can't change %s file", _PATH_GROUP);
	}
	return EXIT_SUCCESS;
}

/* modify a group */
int
groupmod(int argc, char **argv)
{
	struct group	*grp;
	const char	*errstr;
	char		buf[LINE_MAX];
	char		*newname;
	char		**cpp;
	int		dupgid;
	int		gid;
	int		cc;
	int		c;

	gid = GID_MAX;
	dupgid = 0;
	newname = NULL;
	while ((c = getopt(argc, argv, "g:n:ov")) != -1) {
		switch(c) {
		case 'g':
			gid = strtonum(optarg, -1, GID_MAX, &errstr);
			if (errstr != NULL) {
				errx(EXIT_FAILURE, "When using [-g gid], the gid must be numeric");
			}
			break;
		case 'o':
			dupgid = 1;
			break;
		case 'n':
			memsave(&newname, optarg, strlen(optarg));
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			usermgmt_usage("groupmod");
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("groupmod");
	}
	checkeuid();
	if (gid < 0 && newname == NULL) {
		errx(EXIT_FAILURE, "Nothing to change");
	}
	if (dupgid && gid < 0) {
		errx(EXIT_FAILURE, "Duplicate which gid?");
	}
	if ((grp = getgrnam(*argv)) == NULL) {
		errx(EXIT_FAILURE, "can't find group `%s' to modify", *argv);
	}

	if (pledge("stdio rpath wpath cpath fattr flock", NULL) == -1)
		err(1, "pledge");

	if (!is_local(*argv, _PATH_GROUP)) {
		errx(EXIT_FAILURE, "Group `%s' must be a local group", *argv);
	}
	if (newname != NULL && !valid_group(newname)) {
		errx(EXIT_FAILURE, "invalid group name `%s'", newname);
	}
	if ((cc = snprintf(buf, sizeof(buf), "%s:%s:%u:",
	    (newname) ? newname : grp->gr_name, grp->gr_passwd,
	    (gid < 0) ? grp->gr_gid : gid)) >= sizeof(buf) || cc < 0)
		errx(EXIT_FAILURE, "group `%s' entry too long", grp->gr_name);

	for (cpp = grp->gr_mem ; *cpp ; cpp++) {
		cc = strlcat(buf, *cpp, sizeof(buf)) + 1;
		if (cc >= sizeof(buf))
			errx(EXIT_FAILURE, "group `%s' entry too long",
			    grp->gr_name);
		if (cpp[1] != NULL) {
			buf[cc - 1] = ',';
			buf[cc] = '\0';
		}
	}
	cc = strlcat(buf, "\n", sizeof(buf));
	if (cc >= sizeof(buf))
		errx(EXIT_FAILURE, "group `%s' entry too long", grp->gr_name);

	openlog("groupmod", LOG_PID, LOG_USER);
	if (!modify_gid(*argv, buf))
		err(EXIT_FAILURE, "can't change %s file", _PATH_GROUP);
	return EXIT_SUCCESS;
}

/* display user information */
int
userinfo(int argc, char **argv)
{
	struct passwd	*pwp;
	struct group	*grp;
	char		**cpp;
	int		exists;
	int		i;

	exists = 0;
	while ((i = getopt(argc, argv, "ev")) != -1) {
		switch(i) {
		case 'e':
			exists = 1;
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			usermgmt_usage("userinfo");
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("userinfo");
	}

	if (pledge("stdio getpw", NULL) == -1)
		err(1, "pledge");

	pwp = find_user_info(*argv);
	if (exists) {
		exit((pwp) ? EXIT_SUCCESS : EXIT_FAILURE);
	}
	if (pwp == NULL) {
		errx(EXIT_FAILURE, "can't find user `%s'", *argv);
	}
	printf("login\t%s\n", pwp->pw_name);
	printf("passwd\t%s\n", pwp->pw_passwd);
	printf("uid\t%u\n", pwp->pw_uid);
	if ((grp = getgrgid(pwp->pw_gid)) == NULL)
		printf("groups\t%u", pwp->pw_gid);
	else
		printf("groups\t%s", grp->gr_name);
	while ((grp = getgrent()) != NULL) {
		for (cpp = grp->gr_mem ; *cpp ; cpp++) {
			if (strcmp(*cpp, pwp->pw_name) == 0 &&
			    grp->gr_gid != pwp->pw_gid)
				printf(" %s", grp->gr_name);
		}
	}
	fputc('\n', stdout);
	printf("change\t%s", pwp->pw_change ? ctime(&pwp->pw_change) : "NEVER\n");
	printf("class\t%s\n", pwp->pw_class);
	printf("gecos\t%s\n", pwp->pw_gecos);
	printf("dir\t%s\n", pwp->pw_dir);
	printf("shell\t%s\n", pwp->pw_shell);
	printf("expire\t%s", pwp->pw_expire ? ctime(&pwp->pw_expire) : "NEVER\n");
	return EXIT_SUCCESS;
}

/* display user information */
int
groupinfo(int argc, char **argv)
{
	struct group	*grp;
	char		**cpp;
	int		exists;
	int		i;

	exists = 0;
	while ((i = getopt(argc, argv, "ev")) != -1) {
		switch(i) {
		case 'e':
			exists = 1;
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			usermgmt_usage("groupinfo");
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 1) {
		usermgmt_usage("groupinfo");
	}

	if (pledge("stdio getpw", NULL) == -1)
		err(1, "pledge");

	grp = find_group_info(*argv);
	if (exists) {
		exit((grp) ? EXIT_SUCCESS : EXIT_FAILURE);
	}
	if (grp == NULL) {
		errx(EXIT_FAILURE, "can't find group `%s'", *argv);
	}
	printf("name\t%s\n", grp->gr_name);
	printf("passwd\t%s\n", grp->gr_passwd);
	printf("gid\t%u\n", grp->gr_gid);
	printf("members\t");
	for (cpp = grp->gr_mem ; *cpp ; cpp++) {
		printf("%s ", *cpp);
	}
	fputc('\n', stdout);
	return EXIT_SUCCESS;
}
@


1.117
log
@Mitigate some fd leaks on user(8)

OK millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.116 2016/11/30 10:42:38 mestre Exp $ */
d1510 1
a1510 1
				if (!creategid(newlogin, pwp->pw_uid, "")) {
d1514 2
a1515 2
					    "group %s with uid %u", newlogin,
					    pwp->pw_uid);
@


1.116
log
@According to usermod(8) manpage if -g =uid is used it should create a new group
with an unique UID, if it's not already created (not in the manpage), but this
wasn't implemented.
This implements that functionality similar to what NetBSD has, but with some
corrections by adding a fd closure in case of failure and on the failure
message itself which they got it wrong.

OK tb@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.115 2016/11/29 16:11:44 deraadt Exp $ */
d439 3
d1179 1
d1641 1
@


1.115
log
@remove all the (void) casts which are irrelevant.  The remaining ones
should be fixed to do error checks.
ok jsg
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.114 2016/11/29 09:42:38 jsg Exp $ */
d1499 1
a1499 1
				if (getgrgid((gid_t)(up->u_uid)) != NULL) {
d1502 10
a1511 1
					errx(EXIT_FAILURE, "gid %u is already in use", up->u_uid);
a1512 1
				pwp->pw_gid = up->u_uid;
@


1.114
log
@Correct a bit test introduced in user.c rev 1.111 that made it impossible
to set a password hash with usermod if an additional flag was specified.

ok mestre@@ tom@@ jung@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.113 2016/11/29 03:59:31 jsg Exp $ */
d107 1
a107 1
#define _PATH_NONEXISTENT       "/nonexistent"
d192 1
a192 1
	(void) memcpy(*cpp, s, n);
d208 1
a208 1
		(void) printf("Command: %s\n", buf);
d328 1
a328 1
		(void) fclose(from);
d333 3
a335 3
		(void) fclose(from);
		(void) close(fd);
		(void) unlink(f);
d347 3
a349 3
			(void) fclose(from);
			(void) fclose(to);
			(void) unlink(f);
d356 1
a356 1
	(void) fclose(from);
d359 1
a359 1
		(void) unlink(f);
d365 1
a365 1
		(void) unlink(f);
d400 1
a400 1
		(void) fclose(from);
d405 3
a407 3
		(void) fclose(from);
		(void) close(fd);
		(void) unlink(f);
d446 3
a448 3
			(void) fclose(from);
			(void) fclose(to);
			(void) unlink(f);
d452 1
a452 1
	(void) fclose(from);
d455 1
a455 1
		(void) unlink(f);
d460 1
a460 1
		(void) unlink(f);
d496 1
a496 1
		
d522 1
a522 1
		(void) fclose(from);
d527 3
a529 3
		(void) fclose(from);
		(void) close(fd);
		(void) unlink(f);
d573 3
a575 3
			(void) fclose(from);
			(void) fclose(to);
			(void) unlink(f);
d579 1
a579 1
	(void) fclose(from);
d582 1
a582 1
		(void) unlink(f);
d587 1
a587 1
		(void) unlink(f);
d824 1
a824 1
		(void) fclose(fp);
d860 1
a860 1
		(void) memset(&tm, 0, sizeof(tm));
d894 1
a894 1
	const char 	*errstr;
d910 1
a910 1
	const char 	*errstr;
d955 1
a955 1
		(void) close(masterfd);
d960 2
a961 2
		(void) close(masterfd);
		(void) close(ptmpfd);
d979 2
a980 2
			(void) fclose(fp);
			(void) close(ptmpfd);
d988 2
a989 2
		(void) fclose(fp);
		(void) close(ptmpfd);
d1006 1
a1006 1
	 	}
d1019 1
a1019 1
			(void) close(ptmpfd);
d1026 1
a1026 1
		(void) close(ptmpfd);
d1033 1
a1033 1
			(void) close(ptmpfd);
d1040 1
a1040 1
			(void) close(ptmpfd);
d1048 1
a1048 1
		(void) close(ptmpfd);
d1054 1
a1054 1
			(void) close(ptmpfd);
d1063 1
a1063 1
			(void) close(ptmpfd);
d1097 1
a1097 1
		(void) close(ptmpfd);
d1103 1
a1103 1
		(void) close(ptmpfd);
d1111 1
a1111 1
			(void) close(ptmpfd);
d1117 1
a1117 1
			(void) close(ptmpfd);
d1126 2
a1127 2
				(void) fclose(fp);
				(void) close(ptmpfd);
d1136 2
a1137 2
			(void) fclose(fp);
			(void) close(ptmpfd);
d1145 1
a1145 1
			(void) close(ptmpfd);
d1152 1
a1152 1
				(void) close(ptmpfd);
d1166 1
a1166 1
		(void) close(ptmpfd);
d1172 1
a1172 1
		(void) close(ptmpfd);
d1176 1
a1176 1
	(void) close(ptmpfd);
d1213 1
a1213 1
		(void) fclose(from);
d1219 3
a1221 3
		(void) fclose(from);
		(void) close(fd);
		(void) unlink(f);
d1262 3
a1264 3
			(void) fclose(from);
			(void) fclose(to);
			(void) unlink(f);
d1269 1
a1269 1
	(void) fclose(from);
d1273 1
a1273 1
		(void) unlink(f);
d1279 1
a1279 1
		(void) unlink(f);
d1289 1
a1289 1
	FILE	       *fp;
d1313 1
a1313 1
	(void) fclose(fp);
d1389 1
a1389 1
		(void) close(masterfd);
d1394 2
a1395 2
		(void) close(masterfd);
		(void) close(ptmpfd);
d1404 1
a1404 1
				(void) close(ptmpfd);
d1429 1
a1429 1
					(void) close(ptmpfd);
d1443 1
a1443 1
					(void) close(ptmpfd);
d1474 1
a1474 1
					(void) close(ptmpfd);
d1490 1
a1490 1
				(void) close(ptmpfd);
d1500 1
a1500 1
					(void) close(ptmpfd);
d1507 1
a1507 1
					(void) close(ptmpfd);
d1535 1
a1535 1
				(void) close(ptmpfd);
d1566 1
a1566 1
					(void) close(ptmpfd);
d1575 1
a1575 1
					(void) close(ptmpfd);
d1585 2
a1586 2
				(void) close(masterfd);
				(void) close(ptmpfd);
d1598 1
a1598 1
			(void) close(ptmpfd);
d1604 15
a1618 13
		    for (i = 0 ; i < up->u_groupc ; i++) {
		        if (getgrnam(up->u_groupv[i]) == NULL) {
		            (void) close(ptmpfd);
		            pw_abort();
		            errx(EXIT_FAILURE, "aborting, group `%s' does not exist",
			        up->u_groupv[i]);
		        }
		    }
		    if (!rm_user_from_groups(newlogin)) {
		        (void) close(ptmpfd);
		        pw_abort();
		        errx(EXIT_FAILURE, "can't reset groups for `%s'", newlogin);
		    }
d1622 1
a1622 1
			(void) close(ptmpfd);
d1629 1
a1629 1
	(void) close(ptmpfd);
d1657 1
a1657 1
		(void) fprintf(stderr, "usage: %s -D [-b base-directory] "
d1662 1
a1662 1
		(void) fprintf(stderr, "       %s [-mov] [-b base-directory] "
d1671 1
a1671 1
		(void) fprintf(stderr, "usage: %s [-moUvZ] "
d1682 1
a1682 1
		(void) fprintf(stderr, "usage: %s -D [-p preserve-value]\n",
d1684 1
a1684 1
		(void) fprintf(stderr, "       %s [-rv] [-p preserve-value] "
d1687 1
a1687 1
		(void) fprintf(stderr, "usage: %s [-e] user\n", prog);
d1689 1
a1689 1
		(void) fprintf(stderr, "usage: %s [-ov] [-g gid] group\n",
d1692 1
a1692 1
		(void) fprintf(stderr, "usage: %s [-v] group\n", prog);
d1694 1
a1694 1
		(void) fprintf(stderr, "usage: %s [-ov] [-g gid] [-n newname] "
d1697 1
a1697 1
		(void) fprintf(stderr, "usage: %s [add | del | mod"
d1702 1
a1702 1
		(void) fprintf(stderr, "usage: %s [-e] group\n", prog);
d1704 1
a1704 1
		(void) fprintf(stderr, "This program must be called as {user,group}{add,del,mod,info},\n%s is not an understood name.\n", prog);
d1719 1
a1719 1
	(void) memset(&u, 0, sizeof(u));
d1811 7
a1817 7
		(void) printf("group\t\t%s\n", u.u_primgrp);
		(void) printf("base_dir\t%s\n", u.u_basedir);
		(void) printf("skel_dir\t%s\n", u.u_skeldir);
		(void) printf("shell\t\t%s\n", u.u_shell);
		(void) printf("class\t\t%s\n", u.u_class);
		(void) printf("inactive\t%s\n", (u.u_inactive == NULL) ? UNSET_INACTIVE : u.u_inactive);
		(void) printf("expire\t\t%s\n", (u.u_expire == NULL) ? UNSET_EXPIRY : u.u_expire);
d1819 1
a1819 1
			(void) printf("range\t\t%u..%u\n", u.u_rv[i].r_from, u.u_rv[i].r_to);
d1841 2
a1842 2
	(void) memset(&u, 0, sizeof(u));
	(void) memset(newuser, 0, sizeof(newuser));
d1857 1
a1857 1
			  	warnx("Truncated list of secondary groups to %d entries", NGROUPS_MAX - 2);
d1869 1
a1869 1
			  	warnx("Truncated list of secondary groups to %d entries", NGROUPS_MAX - 2);
d1973 1
a1973 1
	(void) memset(&u, 0, sizeof(u));
d2002 1
a2002 1
		(void) printf("preserve\t%s\n", (u.u_preserve) ? "true" : "false");
d2256 3
a2258 3
	(void) printf("login\t%s\n", pwp->pw_name);
	(void) printf("passwd\t%s\n", pwp->pw_passwd);
	(void) printf("uid\t%u\n", pwp->pw_uid);
d2260 1
a2260 1
		(void) printf("groups\t%u", pwp->pw_gid);
d2262 1
a2262 1
		(void) printf("groups\t%s", grp->gr_name);
d2267 1
a2267 1
				(void) printf(" %s", grp->gr_name);
d2270 7
a2276 7
	(void) fputc('\n', stdout);
	(void) printf("change\t%s", pwp->pw_change ? ctime(&pwp->pw_change) : "NEVER\n");
	(void) printf("class\t%s\n", pwp->pw_class);
	(void) printf("gecos\t%s\n", pwp->pw_gecos);
	(void) printf("dir\t%s\n", pwp->pw_dir);
	(void) printf("shell\t%s\n", pwp->pw_shell);
	(void) printf("expire\t%s", pwp->pw_expire ? ctime(&pwp->pw_expire) : "NEVER\n");
d2318 4
a2321 4
	(void) printf("name\t%s\n", grp->gr_name);
	(void) printf("passwd\t%s\n", grp->gr_passwd);
	(void) printf("gid\t%u\n", grp->gr_gid);
	(void) printf("members\t");
d2323 1
a2323 1
		(void) printf("%s ", *cpp);
d2325 1
a2325 1
	(void) fputc('\n', stdout);
@


1.113
log
@Alistair Crooks rescinded the advertising clause of his user(8)
license in 2005 in NetBSD.

https://mail-index.netbsd.org/source-changes/2005/11/25/0002.html
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.112 2016/08/10 20:30:34 millert Exp $ */
d1353 2
a1354 1
		if ((*pwp->pw_passwd != '\0') && (up->u_flags &~ F_PASSWORD)) {
@


1.112
log
@Remove the encrypted password length check.  The admin should be
able to put whatever they like in the encrypted password field,
regardless of whether it can be matched or not.  Having this check
just makes it harder to add new encrypted password functions.
This also fixes "usermode -Z" which was the impetus for the change.
OK benno@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.111 2016/05/03 21:05:14 mestre Exp $ */
d15 1
a15 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Alistair G. Crooks.
 * 4. The name of the author may not be used to endorse or promote
@


1.111
log
@Fix regression on usermod/userdel by calling getpwnam_shadow(3) and saving
passwd hash early, instead of getpwnam(3), then close fds by calling
endpwent(3) and finally only call pledge(2) after it, otherwise on any
modification to the user it would destroy the passwd hash and therefore
forbidding him/her to login again to the machine.

Reported and tested by Edgar Pettijohn <edgar ! pettijohn-web at com>

According to deraadt@@ "that looks better then"
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.110 2016/05/02 15:25:03 millert Exp $ */
a166 3

	DES_Len = 13,

a854 45
/* structure which defines a password type */
typedef struct passwd_type_t {
	const char     *type;		/* optional type descriptor */
	int		desc_length;	/* length of type descriptor */
	int		length;		/* length of password */
} passwd_type_t;

#define NBLF "$2b"
#define BLF  "$2a"
#define MD5  "$1"
#define DES  ""

static passwd_type_t	passwd_types[] = {
	{ NBLF,	3,	54	},	/* Blowfish bcrypt version 2b */
	{ BLF,	3,	54	},	/* Blowfish */
	{ MD5,	2,	34	},	/* MD5 */
	{ DES,	0,	DES_Len	},	/* standard DES */
	{ NULL,	-1,	-1	}	/* none - terminate search */
};

/* return non-zero if it's a valid password - check length for cipher type */
static int
valid_password_length(char *newpasswd)
{
	passwd_type_t  *pwtp;

	for (pwtp = passwd_types ; pwtp->desc_length >= 0 ; pwtp++) {
		if (strncmp(newpasswd, pwtp->type, pwtp->desc_length) == 0) {
			char *p;

			if (strcmp(pwtp->type, BLF) != 0 &&
			    strcmp(pwtp->type, NBLF) != 0) {
				return strlen(newpasswd) == pwtp->length;
			}
			/* Skip first three `$'. */
			if ((p = strchr(newpasswd, '$')) == NULL ||
			    *(++p) == '$' || (p = strchr(p, '$')) == NULL ||
			    *(++p) == '$' || (p = strchr(p, '$')) == NULL)
				continue;
			return (strlen(p) - 1);
		}
	}
	return 0;
}

d1085 2
a1086 10
	if (up->u_password != NULL && valid_password_length(up->u_password)) {
		(void) strlcpy(password, up->u_password, sizeof(password));
	} else {
		(void) memset(password, '*', DES_Len);
		password[DES_Len] = 0;
		if (up->u_password != NULL) {
			warnx("Password `%s' is invalid: setting it to `%s'",
				up->u_password, password);
		}
	}
d1423 1
a1423 7
			if (up->u_password != NULL) {
				if (!valid_password_length(up->u_password)) {
					(void) close(ptmpfd);
					pw_abort();
					errx(EXIT_FAILURE, "Invalid password: `%s'",
						up->u_password);
				}
a1424 1
			}
a1967 1
	char		password[PasswordLength + 1];
d2025 1
a2025 3
		(void) memset(password, '*', DES_Len);
		password[DES_Len] = 0;
		memsave(&u.u_password, password, strlen(password));
@


1.110
log
@When writing master.password entries, use %lld for time_t and cast
to long long.  OK ajacoutot@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.109 2016/04/26 13:30:12 mestre Exp $ */
d1380 1
a1380 1
	struct passwd	*pwp;
d1408 1
a1408 1
	if ((pwp = getpwnam(login_name)) == NULL) {
d1411 14
a2002 4

	if (pledge("stdio rpath wpath cpath fattr flock proc exec getpw id",
	    NULL) == -1)
		err(1, "pledge");
@


1.109
log
@Add pledge(2) promises independently on each user(8)'s functions as follows:

useradd:	stdio rpath wpath cpath fattr flock proc exec getpw id
usermod:	stdio rpath wpath cpath fattr flock proc exec getpw id
userdel:	stdio rpath wpath cpath fattr flock proc exec getpw id
userinfo:	stdio getpw
groupadd:	stdio rpath wpath cpath fattr flock getpw
groupmod:	stdio rpath wpath cpath fattr flock
groupdel:	stdio rpath wpath cpath fattr flock
groupinfo:	stdio getpw

This was extensively tested by me and tim@@ who found some issues on my first
versions. deraadt@@ prodded me to commit this now to check who uses it in order
to report back any fallbacks with the diff, if you find any please inform us.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.108 2016/03/29 17:21:50 mestre Exp $ */
d1143 1
a1143 1
	cc = snprintf(buf, sizeof(buf), "%s:%s:%u:%u:%s:%ld:%ld:%s:%s:%s\n",
d1149 2
a1150 2
	    (long) inactive,
	    (long) expire,
d1604 1
a1604 1
				    "%s:%s:%u:%u:%s:%ld:%ld:%s:%s:%s\n",
d1610 2
a1611 2
				    (long)pwp->pw_change,
				    (long)pwp->pw_expire,
@


1.108
log
@If program cannot reserve memory then the user doesn't need to know exactly how
many bytes it couldn't allocate

Suggested and OK from natano@@ and millert@@ also agrees
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.107 2016/03/29 13:32:54 mestre Exp $ */
d1850 5
d1989 5
d2064 5
d2127 4
d2175 4
d2238 4
d2301 4
d2363 4
@


1.107
log
@-Remove function #defines from defs.h and use the actual code accordingly in
user.c
-Remove MIN and MAX #defines which are not being in use since the last 16 years
-Move last #define to user.c and remove file defs.h
-Remove lint comments

OK natano@@ after his suggestions and also OK jung@@ on an earlier version
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.106 2016/03/28 19:42:51 mestre Exp $ */
d675 1
a675 2
			warn("can't realloc %ld bytes",
			    (long)(up->u_rsize * sizeof(range_t)));
@


1.106
log
@Remove cast from free(3)

OK gsoares@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.105 2016/03/28 19:09:08 mestre Exp $ */
a56 1
#include "defs.h"
d109 2
a110 1
#define CONFFILE	"/etc/usermgmt.conf"
d196 2
a197 1
	NEWARRAY(char, *cpp, n + 1, exit(1));
d671 1
a671 4
	if (up->u_rsize == 0) {
		up->u_rsize = 32;
		NEWARRAY(range_t, up->u_rv, up->u_rsize, return(0));
	} else if (up->u_rc == up->u_rsize) {
d673 6
a678 1
		RENEW(range_t, up->u_rv, up->u_rsize, return(0));
d764 2
a765 1
	NEWARRAY(range_t, up->u_rv, up->u_rsize, exit(1));
a1756 1
	/* NOTREACHED */
a1848 1
			/* NOTREACHED */
a1982 1
			/* NOTREACHED */
a2039 1
			/* NOTREACHED */
a2105 1
			/* NOTREACHED */
a2143 1
			/* NOTREACHED */
a2198 1
			/* NOTREACHED */
a2267 1
			/* NOTREACHED */
a2325 1
			/* NOTREACHED */
@


1.105
log
@Remove handrolled #define FREE and use free(3) directly without wrapping
if (ptr!=NULL) around them since they are not needed.

OK millert@@ and jung@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.104 2015/11/15 23:13:20 deraadt Exp $ */
d825 1
a825 1
			(void) free(s);
@


1.104
log
@Really silly to chmod "st_mode & 07777" when making a copy of the
group file, like entirely missing the point.
ok jca
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.103 2015/04/24 08:08:29 dlg Exp $ */
d195 1
a195 3
	if (*cpp != NULL) {
		FREE(*cpp);
	}
d800 1
a800 3
					if (up->u_inactive) {
						FREE(up->u_inactive);
					}
d819 1
a819 3
					if (up->u_expire) {
						FREE(up->u_expire);
					}
d1676 2
a1677 4
	if (pw_tmp)
		FREE(pw_tmp);
	if (shell_tmp)
		FREE(shell_tmp);
@


1.103
log
@read_defaults has the thing for strtonum to chew on in cp, not
optarg.

fixes a segfault introduced by the atoi to strtonum change and
reported by ajacatout@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.102 2015/04/23 17:11:42 millert Exp $ */
d375 1
a375 1
	(void) chmod(_PATH_GROUP, st.st_mode & 07777);
d470 1
a470 1
	(void) chmod(_PATH_GROUP, st.st_mode & 07777);
d597 1
a597 1
	(void) chmod(_PATH_GROUP, st.st_mode & 07777);
d1330 1
a1330 1
	(void) fchmod(fileno(to), st.st_mode & 07777);
@


1.102
log
@Replace atoi() usage with strtonum().  OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.101 2015/01/16 06:40:22 deraadt Exp $ */
d818 1
a818 1
						   strtonum(optarg, INT_MIN, INT_MAX, NULL);
@


1.101
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.100 2014/08/27 06:51:35 sebastia Exp $ */
a262 12
/* return 1 if all of `s' is numeric */
static int
is_number(char *s)
{
	for ( ; *s ; s++) {
		if (!isdigit((unsigned char) *s)) {
			return 0;
		}
	}
	return 1;
}

d818 1
a818 1
						   atoi(cp);
d943 32
d1092 6
a1097 4
	} else if ((grp = getgrnam(up->u_primgrp)) != NULL) {
		gid = grp->gr_gid;
	} else if (is_number(up->u_primgrp) &&
		   (grp = getgrgid((gid_t)atoi(up->u_primgrp))) != NULL) {
a1098 4
	} else {
		(void) close(ptmpfd);
		pw_abort();
		errx(EXIT_FAILURE, "group %s not found", up->u_primgrp);
d1559 7
a1565 1
			} else if ((grp = getgrnam(up->u_primgrp)) != NULL) {
a1566 7
			} else if (is_number(up->u_primgrp) &&
				   (grp = getgrgid((gid_t)atoi(up->u_primgrp))) != NULL) {
				pwp->pw_gid = grp->gr_gid;
			} else {
				(void) close(ptmpfd);
				pw_abort();
				errx(EXIT_FAILURE, "group %s not found", up->u_primgrp);
a1705 31

/* see if we can find out the user struct */
static struct passwd *
find_user_info(char *name)
{
	struct passwd	*pwp;

	if ((pwp = getpwnam(name)) != NULL) {
		return pwp;
	}
	if (is_number(name) && (pwp = getpwuid((uid_t)atoi(name))) != NULL) {
		return pwp;
	}
	return NULL;
}

/* see if we can find out the group struct */
static struct group *
find_group_info(char *name)
{
	struct group	*grp;

	if ((grp = getgrnam(name)) != NULL) {
		return grp;
	}
	if (is_number(name) && (grp = getgrgid((gid_t)atoi(name))) != NULL) {
		return grp;
	}
	return NULL;
}

d1768 1
d1844 2
a1845 1
			if (!is_number(optarg)) {
a1847 1
			u.u_uid = atoi(optarg);
d1890 1
d1978 3
a1980 1
			if (!is_number(optarg)) {
a1982 2
			u.u_uid = atoi(optarg);
			u.u_flags |= F_UID;
d2037 1
a2037 1
					 atoi(optarg);
d2094 1
d2101 2
a2102 1
			if (!is_number(optarg)) {
a2104 1
			gid = atoi(optarg);
d2178 1
d2193 2
a2194 1
			if (!is_number(optarg)) {
a2196 1
			gid = atoi(optarg);
@


1.100
log
@Add missing capability to handle new $2b version of blowfish password
encryption for usermod and friends.

OK millert@@, seems reasonable for now tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.99 2014/07/20 01:38:40 guenther Exp $ */
d35 1
a35 1
#include <sys/param.h>
d54 1
d163 1
a163 1
	MaxFileNameLen = MAXPATHLEN,
@


1.99
log
@Make sure the correct errno is reported by warn* or err* and not
the errno of an intervening cleanup operation like close/unlink/etc.

Diff from Doug Hogan (doug (at) acyclic.org)
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.98 2013/11/23 17:14:05 deraadt Exp $ */
d879 4
a882 3
#define BLF "$2a"
#define MD5 "$1"
#define DES ""
d885 1
d902 2
a903 1
			if (strcmp(pwtp->type, BLF) != 0) {
@


1.99.4.1
log
@backport 1.100: support for $2b$ hashes. ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.100 2014/08/27 06:51:35 sebastia Exp $ */
d879 3
a881 4
#define NBLF "$2b"
#define BLF  "$2a"
#define MD5  "$1"
#define DES  ""
a883 1
	{ NBLF,	3,	54	},	/* Blowfish bcrypt version 2b */
d900 1
a900 2
			if (strcmp(pwtp->type, BLF) != 0 &&
			    strcmp(pwtp->type, NBLF) != 0) {
@


1.98
log
@unsigned char casts for ctype; ok jca
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.97 2013/09/10 20:53:09 millert Exp $ */
d41 1
d345 1
a346 1
		warn("can't create gid: mkstemp failed");
d350 1
a353 1
		warn("can't create gid: fdopen `%s' failed", f);
d364 1
a367 1
			warn("can't create gid: short write to `%s'", f);
d376 1
a377 1
		warn("can't create gid: short write to `%s'", f);
a380 1
		(void) unlink(f);
d383 1
d417 1
a418 1
		warn("can't modify gid: mkstemp failed");
d422 1
a425 1
		warn("can't modify gid: fdopen `%s' failed", f);
d463 1
a466 1
			warn("can't modify gid: short write to `%s'", f);
d472 1
a473 1
		warn("can't modify gid: short write to `%s'", f);
d477 1
a478 1
		warn("can't modify gid: can't rename `%s' to `%s'", f, _PATH_GROUP);
d539 1
a540 1
		warn("can't append group: mkstemp failed");
d544 1
a547 1
		warn("can't append group: fdopen `%s' failed", f);
d590 1
a593 1
			warn("can't append group: short write to `%s'", f);
d599 1
a600 1
		warn("can't append group: short write to `%s'", f);
d604 1
a605 1
		warn("can't append group: can't rename `%s' to `%s'", f, _PATH_GROUP);
d984 1
d986 1
a986 1
		err(EXIT_FAILURE, "can't obtain pw_lock");
d989 1
d993 2
a994 2
		err(EXIT_FAILURE, "can't fdopen `%s' for reading",
		    _PATH_MASTERPASSWD);
d1008 1
d1012 2
a1013 1
			err(EXIT_FAILURE, "short write to /etc/ptmp (not %d chars)", cc);
d1017 1
d1021 2
a1022 1
		err(EXIT_FAILURE, "read error on %s", _PATH_MASTERPASSWD);
d1142 1
d1145 1
a1145 1
		err(EXIT_FAILURE, "can't add `%s'", buf);
d1156 1
d1159 1
a1159 1
			err(EXIT_FAILURE, "can't add `%s'", buf);
d1165 1
d1169 3
a1171 1
				err(EXIT_FAILURE, "short write to /etc/ptmp (not %d chars)", cc);
d1175 1
d1179 2
a1180 1
			err(EXIT_FAILURE, "read error on %s", _PATH_MASTERPASSWD);
d1191 1
d1194 2
a1195 1
				err(EXIT_FAILURE, "can't mkdir `%s'", home);
d1252 1
a1253 1
		warn("can't remove gid for `%s': mkstemp failed", login_name);
d1257 2
a1261 2
		warn("can't remove gid for `%s': fdopen `%s' failed",
		    login_name, f);
d1300 2
a1304 2
			warn("can't remove gid for `%s': short write to `%s'",
			    login_name, f);
a1310 1
		(void) unlink(f);
d1313 1
a1316 1
		(void) unlink(f);
d1319 1
d1413 1
d1415 1
a1415 1
		err(EXIT_FAILURE, "can't obtain pw_lock");
d1418 1
d1422 2
a1423 1
		err(EXIT_FAILURE, "can't fdopen fd for %s", _PATH_MASTERPASSWD);
d1607 1
d1610 2
a1611 1
					err(EXIT_FAILURE, "can't add `%s'", buf);
d1617 1
d1621 2
a1622 1
				err(EXIT_FAILURE, "short write to /etc/ptmp (%lld not %lld chars)",
d1630 1
d1633 2
a1634 2
			err(EXIT_FAILURE, "can't move `%s' to `%s'",
			    homedir, pwp->pw_dir);
@


1.97
log
@Move the chown and chmod out of copydotfiles() and add an explicit
check for skeldir set to the empty string.  Fixes a problem where
the owner/mode is not set on the user's homedir if the specified
skeldir does not exist.  OK ajacoutot@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.96 2013/08/06 21:33:03 millert Exp $ */
d572 1
a572 1
				while (isspace(buf[cc - 1]))
d623 2
a624 1
		if (!isalnum(*cp) && *cp != '.' && *cp != '_' && *cp != '-' &&
d641 2
a642 1
		if (!isalnum(*cp) && *cp != '.' && *cp != '_' && *cp != '-') {
d785 1
a785 1
				for (cp = s + 5 ; isspace(*cp) ; cp++) {
d789 1
a789 1
				for (cp = s + 8 ; isspace(*cp) ; cp++) {
d793 1
a793 1
				for (cp = s + 8 ; isspace(*cp) ; cp++) {
d797 1
a797 1
				for (cp = s + 5 ; isspace(*cp) ; cp++) {
d801 1
a801 1
				for (cp = s + 8 ; isspace(*cp) ; cp++) {
d805 1
a805 1
				for (cp = s + 5 ; isspace(*cp) ; cp++) {
d809 1
a809 1
				for (cp = s + 8 ; isspace(*cp) ; cp++) {
d820 1
a820 1
				for (cp = s + 5 ; isspace(*cp) ; cp++) {
d824 1
a824 1
				for (cp = s + 8 ; isspace(*cp) ; cp++) {
d830 1
a830 1
				for (cp = s + 6 ; isspace(*cp) ; cp++) {
@


1.96
log
@Write uids/gids as unsigned in the passwd file and error messages.
This matches what pw_scan() expects.  OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.95 2013/04/02 05:04:47 deraadt Exp $ */
d293 2
a312 2
	(void) asystem("%s -R -P %u:%u %s", CHOWN, uid, gid, dir);
	(void) asystem("%s -R u+w %s", CHMOD, dir);
d1180 3
@


1.95
log
@for parsing time values, fall back to atoll() for time_t
ok guenther
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.94 2013/03/04 07:24:52 ajacoutot Exp $ */
d386 1
a386 1
	syslog(LOG_INFO, "new group added: name=%s, gid=%d", group, gid);
d676 2
a677 2
	int	from;
	int	to;
d687 1
a687 1
	if (up->u_rv && sscanf(cp, "%d..%d", &from, &to) == 2) {
d737 1
a737 1
		if (fprintf(fp, "range\t\t%d..%d\n", up->u_rv[i].r_from, up->u_rv[i].r_to) <= 0) {
d1115 1
a1115 1
	cc = snprintf(buf, sizeof(buf), "%s:%s:%d:%d:%s:%ld:%ld:%s:%s:%s\n",
d1187 1
a1187 1
		errx(EXIT_FAILURE, "can't create gid %d for login name %s",
d1200 1
a1200 1
	syslog(LOG_INFO, "new user added: name=%s, uid=%d, gid=%d, home=%s, shell=%s",
d1562 1
a1562 1
				    "%s:%s:%d:%d:%s:%ld:%ld:%s:%s:%s\n",
d1647 1
a1647 1
		syslog(LOG_INFO, "user information modified: name=%s, uid=%d, gid=%d, home=%s, shell=%s",
d1650 1
a1650 1
		syslog(LOG_INFO, "user information modified: name=%s, new name=%s, uid=%d, gid=%d, home=%s, shell=%s",
d1850 1
a1850 1
			(void) printf("range\t\t%d..%d\n", u.u_rv[i].r_from, u.u_rv[i].r_to);
@


1.94
log
@When locking/unlocking an account, never touch passwords that are "*"
or 13*. Also make sure to never endup with an empty password.

cluebat and ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.93 2013/02/16 07:25:54 ajacoutot Exp $ */
d926 1
a926 1
			*tp = atoi(s);
@


1.93
log
@Fix unlocking on 32bits arch where it would fuck up the shell...
Do not try to (un)lock system users; people wanting to do so (???) will
know what they do and use vipw(8).

unlocking issue reported by Andre Stobe on tech@@
cluesticks and ok miod@@, ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.92 2012/09/20 11:32:06 ajacoutot Exp $ */
d1467 7
a1473 2
			if (strncmp(pwp->pw_passwd, pwlock_str, sizeof(pwlock_str)-1) == 0) {
				pwp->pw_passwd += sizeof(pwlock_str)-1;
d1475 1
a1475 1
				unlocked++;
@


1.92
log
@Be consistent with what the installer and useradd(8) do and put newly
created users into their own primary group.
This does not change existing installations that already have a
usermgmt.conf(5).

ok todd@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.91 2012/09/18 07:56:11 ajacoutot Exp $ */
d1351 1
d1375 1
a1375 1
		if ((up->u_flags & (F_ACCTLOCK | F_ACCTUNLOCK)) && (pwp->pw_uid == 0))
d1474 2
a1475 1
				shell_tmp = malloc(strlen(pwp->pw_shell) - sizeof(acctlock_str));
d1481 1
a1481 1
				strlcpy(shell_tmp, pwp->pw_shell, sizeof(shell_tmp) + 1);
@


1.91
log
@Add 2 new knobs to usermod(8):
-U to unlock an account
-Z to lock an account

Locking means adding a '*' prefix to the encrypted password and appending
a '-' to the user's shell... and obviously the opposite for unlocking.

some inputs from sthen@@, otto@@ and deraadt@@
ok todd@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.90 2012/01/29 08:38:54 ajacoutot Exp $ */
d111 1
a111 1
#define DEF_GROUP	"users"
@


1.90
log
@fix previous: grp is unused here just check the return value
spotted by Jeremie Courreges-Anglas
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.89 2012/01/28 14:25:45 ajacoutot Exp $ */
d103 3
a105 1
	F_SETSECGROUP	= 0x4000
d1344 5
d1354 2
d1357 2
d1373 4
d1380 3
d1431 57
d1625 4
d1699 1
a1699 1
		(void) fprintf(stderr, "usage: %s [-mov] "
d1870 1
a1870 1
	while ((c = getopt(argc, argv, "G:L:S:c:d:e:f:g:l:mop:s:u:v")) != -1) {
d1896 6
d1971 4
@


1.89
log
@Make it possible to remove a user from all secondary groups by using:
usermod -S '' username
Original patch from jca at wxcvbn dot org.
Added a comment to the man page.

man tweaks and ok jmc@@
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.88 2012/01/28 10:20:01 ajacoutot Exp $ */
d1527 1
a1527 1
		        if ((grp = getgrnam(up->u_groupv[i])) == NULL) {
@


1.88
log
@When setting the groups (`-S'), make sure all provided groups exist in
the system otherwise we may end up removing all groups from a user.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.87 2012/01/12 18:35:07 ajacoutot Exp $ */
d1525 3
a1527 11
		if (up->u_groupc > 0) {
		    if (up->u_flags & F_SETSECGROUP) {
		        for (i = 0 ; i < up->u_groupc ; i++) {
			    if ((grp = getgrnam(up->u_groupv[i])) == NULL) {
		                (void) close(ptmpfd);
		                pw_abort();
			        errx(EXIT_FAILURE, "aborting, group `%s' does not exist",
			            up->u_groupv[i]);
			    }
		        }
		        if (!rm_user_from_groups(newlogin)) {
d1530 2
a1531 1
		            errx(EXIT_FAILURE, "can't reset groups for `%s'", newlogin);
d1534 7
@


1.87
log
@fgets(3) returns a pointer, so compare against NULL, not integer 0.

from Michael W. Bombardieri
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.86 2011/12/31 14:05:51 ajacoutot Exp $ */
d1351 1
d1526 10
a1535 2
		    if ((up->u_flags & F_SETSECGROUP) &&
		        !rm_user_from_groups(newlogin)) {
d1539 1
@


1.86
log
@Remove the EXTENSIONS ifdef danse; it might have made sense in the past
but user(8) behaviour has become OS specific in time so there's no
sense keeping this. We are OpenBSD and we use BSD EXTENSIONS
unconditionally.

ok miod@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.85 2011/12/30 08:39:02 ajacoutot Exp $ */
d1241 1
a1241 1
	while (fgets(buf, sizeof(buf), from) > 0) {
@


1.85
log
@Fix a warning.

inputs from and ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.84 2011/12/27 08:29:38 ajacoutot Exp $ */
a42 1
#ifdef EXTENSIONS
a43 1
#endif
a646 1
#ifdef EXTENSIONS
a656 1
#endif
a669 1
#ifdef EXTENSIONS
a701 1
#endif
a710 1
#ifdef EXTENSIONS
a711 1
#endif
a726 1
#ifdef EXTENSIONS
a727 1
#endif
a733 1
#ifdef EXTENSIONS
a739 1
#endif
a765 1
#ifdef EXTENSIONS
a766 1
#endif
a799 1
#ifdef EXTENSIONS
a803 1
#endif
a814 1
#ifdef EXTENSIONS
a818 2
#endif
#ifdef EXTENSIONS
a824 1
#endif
a967 1
#ifdef EXTENSIONS
a970 1
#endif
a1117 1
#ifdef EXTENSIONS
a1118 3
#else
	    "",
#endif
a1458 1
#ifdef EXTENSIONS
a1467 1
#endif
a1483 1
#ifdef EXTENSIONS
a1484 3
#else
				    "",
#endif
a1560 1
#ifdef EXTENSIONS
a1574 1
#endif
a1575 1
#ifdef EXTENSIONS
a1589 1
#endif
a1624 1
#ifdef EXTENSIONS
a1626 1
#endif
a1636 1
#ifdef EXTENSIONS
a1637 1
#endif
a1639 1
#ifdef EXTENSIONS
a1641 1
#endif
a1648 6
#ifdef EXTENSIONS
#define ADD_OPT_EXTENSIONS	"p:r:vL:"
#else
#define ADD_OPT_EXTENSIONS	
#endif

a1655 1
#ifdef EXTENSIONS
a1656 1
#endif
d1662 1
a1662 1
	while ((c = getopt(argc, argv, "DG:b:c:d:e:f:g:k:mou:s:" ADD_OPT_EXTENSIONS)) != -1) {
a1704 1
#ifdef EXTENSIONS
a1708 1
#endif
a1714 1
#ifdef EXTENSIONS
a1718 2
#endif
#ifdef EXTENSIONS
a1722 1
#endif
a1732 1
#ifdef EXTENSIONS
a1735 1
#endif
a1749 1
#ifdef EXTENSIONS
a1750 1
#endif
a1752 1
#ifdef EXTENSIONS
a1755 1
#endif
a1767 6
#ifdef EXTENSIONS
#define MOD_OPT_EXTENSIONS	"p:vL:"
#else
#define MOD_OPT_EXTENSIONS	
#endif

d1781 1
a1781 1
	while ((c = getopt(argc, argv, "G:S:c:d:e:f:g:l:mos:u:" MOD_OPT_EXTENSIONS)) != -1) {
a1834 1
#ifdef EXTENSIONS
a1838 1
#endif
a1844 1
#ifdef EXTENSIONS
a1849 1
#endif
a1860 1
#ifdef EXTENSIONS
a1863 1
#endif
a1886 6
#ifdef EXTENSIONS
#define DEL_OPT_EXTENSIONS	"Dp:v"
#else
#define DEL_OPT_EXTENSIONS	
#endif

d1901 1
a1901 1
	while ((c = getopt(argc, argv, "r" DEL_OPT_EXTENSIONS)) != -1) {
a1902 1
#ifdef EXTENSIONS
a1905 2
#endif
#ifdef EXTENSIONS
a1911 1
#endif
a1914 1
#ifdef EXTENSIONS
a1917 1
#endif
a1922 1
#ifdef EXTENSIONS
a1930 1
#endif
a1959 6
#ifdef EXTENSIONS
#define GROUP_ADD_OPT_EXTENSIONS	"v"
#else
#define GROUP_ADD_OPT_EXTENSIONS	
#endif

d1970 1
a1970 1
	while ((c = getopt(argc, argv, "g:o" GROUP_ADD_OPT_EXTENSIONS)) != -1) {
a1980 1
#ifdef EXTENSIONS
a1983 1
#endif
a2011 6
#ifdef EXTENSIONS
#define GROUP_DEL_OPT_EXTENSIONS	"v"
#else
#define GROUP_DEL_OPT_EXTENSIONS	
#endif

d2018 1
a2018 1
	while ((c = getopt(argc, argv, "" GROUP_DEL_OPT_EXTENSIONS)) != -1) {
a2019 1
#ifdef EXTENSIONS
a2022 1
#endif
a2044 6
#ifdef EXTENSIONS
#define GROUP_MOD_OPT_EXTENSIONS	"v"
#else
#define GROUP_MOD_OPT_EXTENSIONS	
#endif

d2061 1
a2061 1
	while ((c = getopt(argc, argv, "g:on:" GROUP_MOD_OPT_EXTENSIONS)) != -1) {
a2074 1
#ifdef EXTENSIONS
a2077 1
#endif
a2128 1
#ifdef EXTENSIONS
a2180 1
#ifdef EXTENSIONS
a2181 1
#endif
a2187 1
#endif
a2188 1
#ifdef EXTENSIONS
a2233 1
#endif
@


1.84
log
@Follow adduser(8) behaviour (as well as what the pkg tools and our
installer do) and do not append the user to its primary group name in
/etc/group.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.83 2011/12/24 07:17:04 jmc Exp $ */
d1527 1
a1527 1
					    "line too long (%d bytes)", buf,
@


1.83
log
@-p requires an argument; from Stefan Pettersson
ok krw
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.82 2011/12/04 08:28:35 ajacoutot Exp $ */
d494 1
d501 1
d507 7
d564 6
d1208 1
a1208 1
	    !creategid(login_name, gid, login_name)) {
@


1.82
log
@Add a new '-S' option to _set_ the user's secondary group(s) (which also
permits to remove a user from a group).
It uses the same syntax as `-G'.

In practice this works like `-G' on Linux; it was decided not to modify
our `-G' option because people rely on the existing behavior (which
works like `-aG' on Linux, i.e. append to group).

Reworked from scratch from a submission by Frank Brodbeck.

man page bits reviewed by jmc@@
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.81 2011/04/16 07:41:08 sobrado Exp $ */
d1644 2
a1645 1
		(void) fprintf(stderr, "       %s [-prv] user\n", prog);
@


1.81
log
@remove trailing whitespace, no binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.80 2011/04/08 18:13:53 jmc Exp $ */
d104 2
a105 1
	F_CLASS		= 0x1000
d1541 8
a1548 2
		if (up->u_groupc > 0 &&
		    !append_group(newlogin, up->u_groupc, up->u_groupv)) {
d1553 1
d1637 3
a1639 1
		    "               [-p password] [-s shell] [-u uid] user\n",
d1833 1
a1833 1
	while ((c = getopt(argc, argv, "G:c:d:e:f:g:l:mos:u:" MOD_OPT_EXTENSIONS)) != -1) {
d1847 12
d1932 2
@


1.80
log
@- avoid nasty line wrap in SYNOPSIS
- put -G in the right place
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.79 2011/04/06 11:36:26 miod Exp $ */
d307 1
a307 1
		(void) asystem("cd %s && %s -rw -pe %s . %s", 
d1028 1
a1028 1
		for (i = up->u_defrc; got_id == 0 && i < up->u_rc ; i++) { 
d1038 1
a1038 1
			for (i = 0; got_id == 0 && i < up->u_defrc; i++) { 
d1560 1
a1560 1
		syslog(LOG_INFO, "user information modified: name=%s, uid=%d, gid=%d, home=%s, shell=%s", 
d1563 1
a1563 1
		syslog(LOG_INFO, "user information modified: name=%s, new name=%s, uid=%d, gid=%d, home=%s, shell=%s", 
@


1.79
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.78 2010/07/26 10:55:17 miod Exp $ */
d1624 3
a1626 3
		    "[-G secondary-group[,group,...]] [-c comment]\n"
		    "               [-d home-directory] [-e expiry-time] "
		    "[-f inactive-time]\n"
@


1.78
log
@- use warnx instead of warn when skipping large lines, as errno is
  nonsensical in that case (and usually zero).
- when altering the groups file, preserve a single "+" line instead of
  complaining it is incorrect and removing it.
ok fgsch@@ millert@@ ray@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.77 2009/02/08 11:37:43 chl Exp $ */
d927 1
a927 1
		} else if (isdigit((unsigned char) s[0]) != NULL) {
@


1.77
log
@deal with potential empty string fgets can return
use strcspn to properly overwrite '\n' in fgets returned buffer

ok ray@@ jaredy@@
looks ok gilles@@ long time ago on a similar diff
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.76 2009/01/21 16:56:02 sobrado Exp $ */
d432 1
a432 1
			warn("%s: line `%s' too long (%d bytes), skipping",
d437 6
a442 6
			warn("badly formed entry `%s'", buf);
			continue;
		}
		entc = (int)(colon - buf);
		if (entc == groupc && strncmp(group, buf, entc) == 0) {
			if (newent == NULL) {
d444 13
a456 5
			} else {
				cc = strlcpy(buf, newent, sizeof(buf));
				if (cc >= sizeof(buf)) {
					warnx("group `%s' entry too long", newent);
					return (0);
d544 1
a544 1
			warn("%s: line `%s' too long (%d bytes), skipping",
d1256 1
a1256 1
			warn("%s: line `%s' too long (%d bytes), skipping",
d1331 1
a1331 1
			warn("%s: line `%s' too long (%d bytes), skipping",
@


1.76
log
@paragraphs and sentences start with uppercase letters; synchronize
the synopsis and usage of user(8) related commands; sort the options
list in the DESCRIPTION section of the manual pages; spacing.

ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.75 2008/12/20 09:40:47 jmc Exp $ */
d429 1
a429 1
		if (buf[cc - 1] != '\n' && !feof(from)) {
d533 1
a533 1
		if (buf[cc - 1] != '\n' && !feof(from)) {
d1245 1
a1245 1
		if (buf[cc - 1] != '\n' && !feof(from)) {
d1259 2
a1260 2
			warnx("Malformed entry `%.*s'. Skipping",
			    (int)strlen(buf) - 1, buf);
d1320 1
a1320 1
		if (buf[cc - 1] != '\n' && !feof(fp)) {
@


1.75
log
@- various improvements from Ingo Schwarze;
- remove non-functional -v option from docs/usage()

feedback/ok millert otto
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.74 2008/12/16 05:25:55 guenther Exp $ */
d1601 13
a1613 9
		(void) fprintf(stderr, "usage: %s -D [-b basedir] [-e expiry] "
		    "[-f changetime] [-g group]\n\t\t[-k skeletondir] "
		    "[-r low..high] [-s shell] [-L class]\n", prog);
		(void) fprintf(stderr, "usage: %s [-mov] [-G group[,group,...]]"
		    " [-b basedir] [-c comment]\n\t\t"
		    "[-d homedir] [-e expiry] [-f changetime] [-g group]\n\t\t"
		    "[-k skeletondir] [-p password] "
		    "[-r lowuid..highuid]\n\t\t[-s shell] [-u uid] [-L class] "
		    "user\n", prog);
d1615 7
a1621 4
		(void) fprintf(stderr, "usage: %s [-mov] [-G group[,group,...]]"
		    " [-c comment] [-d homedir]\n\t\t"
		    "[-e expire] [-f changetime] [-g group] [-l newname]\n\t\t"
		    "[-p password] [-s shell] [-u uid] [-L class] user\n",
d1624 3
a1626 2
		(void) fprintf(stderr, "usage: %s -D [-p preserve]\n", prog);
		(void) fprintf(stderr, "usage: %s [-prv] user\n", prog);
d1640 1
a1640 1
		(void) fprintf(stderr, "usage: %s [ add | del | mod "
d1642 1
a1642 1
		"| info "
@


1.74
log
@strptime() never sets tm_isdst, so set it to -1 before passing the
struct tm to mktime() so that the calculation will follow the local
DST rules

ok millert@@ otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.73 2008/10/09 21:10:08 miod Exp $ */
d1621 1
a1621 1
		(void) fprintf(stderr, "usage: %s [-ev] user\n", prog);
d1640 1
a1640 1
		(void) fprintf(stderr, "usage: %s [-ev] group\n", prog);
@


1.73
log
@When adding a new user, do not move a potential yp line (+:*:::0:0::::) to the
end of the file, for this would make logins coming after the yp line (such
as nomadic or fallback accounts) to come back before the yp line and take
precedence. Found the hard way installing packages needing a user to be created.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.72 2007/08/02 16:18:05 deraadt Exp $ */
d914 1
@


1.72
log
@catch a few truncation cases instead of silently ignoring them.  one of the
fixes is from pr 5554.  ok millert, ray
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.71 2007/04/05 01:34:57 tedu Exp $ */
d988 5
d995 1
a995 1
			continue;
d1137 1
d1148 16
@


1.71
log
@remove some extra tests, from charles longeau
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.70 2007/03/02 04:27:11 ray Exp $ */
d1066 6
a1071 1
		(void) strlcpy(home, up->u_home, sizeof(home));
d1074 7
a1080 2
		(void) snprintf(home, sizeof(home), "%s/%s", up->u_basedir,
		    login_name);
d1819 4
a1822 1
			(void) strlcpy(newuser, optarg, sizeof(newuser));
@


1.70
log
@Check if group exists before checking if group is local.

OK millert@@.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.69 2007/03/02 04:23:35 ray Exp $ */
d771 1
a771 1
				for (cp = s + 5 ; *cp && isspace(*cp) ; cp++) {
d775 1
a775 1
				for (cp = s + 8 ; *cp && isspace(*cp) ; cp++) {
d779 1
a779 1
				for (cp = s + 8 ; *cp && isspace(*cp) ; cp++) {
d783 1
a783 1
				for (cp = s + 5 ; *cp && isspace(*cp) ; cp++) {
d787 1
a787 1
				for (cp = s + 8 ; *cp && isspace(*cp) ; cp++) {
d792 1
a792 1
				for (cp = s + 5 ; *cp && isspace(*cp) ; cp++) {
d797 1
a797 1
				for (cp = s + 8 ; *cp && isspace(*cp) ; cp++) {
d809 1
a809 1
				for (cp = s + 5 ; *cp && isspace(*cp) ; cp++) {
d815 1
a815 1
				for (cp = s + 8 ; *cp && isspace(*cp) ; cp++) {
d822 1
a822 1
				for (cp = s + 6 ; *cp && isspace(*cp) ; cp++) {
@


1.69
log
@Replace regex(3) routines with simple string searching and comparison
routines.

OK millert@@.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.68 2007/01/12 13:25:12 otto Exp $ */
d2115 3
a2119 3
	}
	if ((grp = getgrnam(*argv)) == NULL) {
		errx(EXIT_FAILURE, "can't find group `%s' to modify", *argv);
@


1.68
log
@Compare against the username, so listing groups when given a numeric
user id to userinfo works. From Alf Schlichting; ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.67 2006/12/20 01:58:46 ray Exp $ */
a47 1
#include <regex.h>
a867 2
	const char     *regex;		/* regexp to output the password */
	int		re_sub;		/* subscript of regexp to use */
d870 4
d875 4
a878 4
	{ "$2a",	3,	54,	"\\$[^$]+\\$[^$]+\\$(.*)",	1 },	/* Blowfish */
	{ "$1",		2,	34,	NULL,				0 },	/* MD5 */
	{ "",		0,	DES_Len,NULL,				0 },	/* standard DES */
	{ NULL,		-1,	-1,	NULL,				0 }	/* none - terminate search */
a885 2
	regmatch_t	matchv[10];
	regex_t		r;
d889 3
a891 1
			if (pwtp->regex == NULL) {
d894 6
a899 6
			(void) regcomp(&r, pwtp->regex, REG_EXTENDED);
			if (regexec(&r, newpasswd, 10, matchv, 0) == 0) {
				regfree(&r);
				return (int)(matchv[pwtp->re_sub].rm_eo - matchv[pwtp->re_sub].rm_so + 1) == pwtp->length;
			}
			regfree(&r);
a1274 2
	regmatch_t	matchv[10];
	regex_t		r;
d1277 1
a1277 1
	char		re[LINE_MAX];
a1280 4
	(void) snprintf(re, sizeof(re), "^%s:", name);
	if (regcomp(&r, re, REG_EXTENDED) != 0) {
		errx(EXIT_FAILURE, "can't compile regular expression `%s'", re);
	}
d1284 1
d1294 1
a1294 1
		if (regexec(&r, buf, 10, matchv, 0) == 0) {
@


1.67
log
@Fix potential buffer overread in function, even though the current
code cannot overflow.  Add error checking to protect future code
changes and to provide a better example for plagiarizers.

OK millert@@.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.66 2005/12/31 19:20:49 millert Exp $ */
d2199 2
a2200 1
			if (strcmp(*cpp, *argv) == 0 && grp->gr_gid != pwp->pw_gid)
@


1.66
log
@Make useradd -p slightly less dangerous by overwriting the encrypted
password in argv.  This doesn't solve the problem; it just reduces
the amount of time that encrypted password is available via ps.
OK deraadt@@ and krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.65 2005/08/27 23:12:36 deraadt Exp $ */
d446 5
a450 2
				cc = strlen(newent);
				(void) strlcpy(buf, newent, sizeof(buf));
@


1.65
log
@change default user shell to ksh as well.
spotted by matthieu and miod
sorry bill, but you stopped just hacking far too long ago..
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.64 2005/07/08 18:58:32 millert Exp $ */
d1696 1
d1829 1
@


1.64
log
@Don't mistakenly match groups with partial name matches in "usermod -G".
Reported and fix confirmed by Maxim Bourmistrov
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.63 2005/04/15 16:27:31 moritz Exp $ */
d123 1
a123 1
#define DEF_SHELL	_PATH_CSHELL
@


1.63
log
@fix snprintf return value check. ok otto@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.62 2005/04/13 03:46:28 deraadt Exp $ */
d543 3
a545 1
			if (strncmp(groups[i], buf, colon - buf) == 0) {
@


1.62
log
@very unlikely overflow.  but sticking to the idiom is important:  thereby,
example by example, we teach people how to actually use snprintf.  because
it is clear (especially judging by code coming from netbsd hint hint perhaps
if i say it like this they will finally learn) that people are not paying
attention, and replacing one security problem with another.

in the early days we replaced buffer the typical ANSI-C standardized function
buffer overflows (by which I mean strcpy, strcat, and sprintf) with
non-overflowing ones -- range checking varients.  We knew we were fixing
a major problem.  The damn overflows.  But we did not have time in all cases
to handle the next problem we were not handling:  string truncation.  Now we
need to (I hope not slowly) start fixing the string truncations.

Anyone going to help?
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.61 2004/09/30 15:07:41 otto Exp $ */
d1117 1
a1117 1
		if (cc == -1 || cc > sizeof(buf)) {
@


1.61
log
@If the yp marker is in the file, add new users before it. PR 3727.
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.60 2004/06/04 18:04:21 otto Exp $ */
d1117 5
@


1.60
log
@Clear up some confusion: -e is account expiry flag, -f is password
expiry flag. Resolves PR 3792, though not by changing code, but by
changing docs, comments and an error message or two.
ok jmc@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.59 2004/05/10 18:41:11 otto Exp $ */
d951 2
a952 1
	int		i;
d973 13
a985 1
	while ((cc = read(masterfd, buf, sizeof(buf))) > 0) {
d987 1
a987 1
			(void) close(masterfd);
d993 6
d1115 8
d1152 1
a1152 1
	if (pw_mkdb(login_name, 0) < 0) {
@


1.59
log
@Check return value of fclose() calls after writing.
ok deraadt@@ tdeval@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.58 2004/05/10 09:44:45 deraadt Exp $ */
d80 2
a81 2
	char	       *u_expire;		/* when password will expire */
	char	       *u_inactive;		/* when account will expire */
d1048 1
a1048 1
		warnx("Warning: inactive time `%s' invalid, account expiry off",
d1052 1
a1052 1
		warnx("Warning: expire time `%s' invalid, password expiry off",
d1385 1
a1385 1
				warnx("Warning: expire time `%s' invalid, password expiry off",
@


1.58
log
@when adding a new group to /etc/groups, place it just before the first
+ entry.  assistance from tdeval and otto.  this is the first half of
pr 3727, brendan@@cs.uchicago.edu
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.57 2004/04/19 17:48:31 millert Exp $ */
d459 5
a463 1
	(void) fclose(to);
d569 5
a573 1
	(void) fclose(to);
d724 4
a727 1
	(void) fclose(fp);
d1218 6
a1223 1
	(void) fclose(to);
@


1.57
log
@Don't complain when the /nonexistent homedir does not exist.
Based on a patch from Sam Smith.  henning@@ OK
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.56 2004/02/26 21:18:18 millert Exp $ */
d323 1
a323 1
	char		buf[LINE_MAX];
d325 3
a327 2
	int		fd;
	int		cc;
d355 8
a362 2
	while ((cc = fread(buf, sizeof(char), sizeof(buf), from)) > 0) {
		if (fwrite(buf, cc, 1, to) != 1) {
d370 3
a372 1
	(void) fprintf(to, "%s:*:%u:%s\n", group, gid, name);
d374 5
a378 1
	(void) fclose(to);
@


1.56
log
@Avoid using regexp when removing a user from /etc/group entries in
userdel since a username may contain regexp special chars.

Fix a memory leak on error and chmod before moving the new group
file is moved into place instead of after.

Saner error messages in rm_user_from_groups() (cut & pastos)

OK deraadt@@, tdeval@@ and otto@@; error message fixes courtesy of otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.55 2004/01/03 18:30:39 millert Exp $ */
d1031 2
a1032 1
	if (lstat(home, &st) < 0 && !(up->u_flags & F_MKDIR)) {
@


1.55
log
@Replace bogus use of fgetln() (which doesn't NUL-terminate strings)
with fgets() (which does).  Using fgetln() doesn't make a huge amount
of sense since passwd entries are required to be short and mustn't contain
NULs.  This also fixes a bus error on sparc64 (caused by passing a pointer
to an int when a pointer to size_t was expected) found by pvalchev@@.
Tested and OK pvalchev@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.54 2003/12/25 10:23:57 grange Exp $ */
d1114 1
a1114 2
	regmatch_t	matchv[10];
	regex_t		r;
a1116 1
	char		line[LINE_MAX];
d1119 1
a1121 1
	int		sc;
d1123 1
a1123 5
	(void) snprintf(line, sizeof(line), "(:|,)(%s)(,|$)", login_name);
	if (regcomp(&r, line, REG_EXTENDED|REG_NEWLINE) != 0) {
		warn("can't compile regular expression `%s'", line);
		return 0;
	}
d1125 2
a1126 1
		warn("can't remove gid for `%s': can't open `%s'", login_name, _PATH_GROUP);
d1136 1
a1136 1
		warn("can't create gid: mkstemp failed");
d1143 2
a1144 1
		warn("can't create gid: fdopen `%s' failed", f);
d1156 24
a1179 14
		if (regexec(&r, buf, 10, matchv, 0) == 0) {
			if (buf[(int)matchv[1].rm_so] == ',')
				matchv[2].rm_so = matchv[1].rm_so;
			else if (matchv[2].rm_eo != matchv[3].rm_eo)
				matchv[2].rm_eo = matchv[3].rm_eo;
			cc -= (int) matchv[2].rm_eo;
			sc = (int) matchv[2].rm_so;
			if (fwrite(buf, sc, 1, to) != 1 ||
			    fwrite(&buf[(int)matchv[2].rm_eo], cc, 1, to) != 1) {
				(void) fclose(from);
				(void) close(fd);
				(void) unlink(f);
				warn("can't create gid: short write to `%s'", f);
				return 0;
d1181 2
a1182 1
		} else if (fwrite(buf, cc, 1, to) != 1) {
d1184 1
a1184 1
			(void) close(fd);
d1186 2
a1187 1
			warn("can't create gid: short write to `%s'", f);
d1191 1
d1196 2
a1197 1
		warn("can't create gid: can't rename `%s' to `%s'", f, _PATH_GROUP);
a1199 1
	(void) chmod(_PATH_GROUP, st.st_mode & 07777);
@


1.54
log
@Fix multi-line string
ok otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.53 2003/12/24 20:15:58 otto Exp $ */
d1243 1
a1243 1
	char		*colon, *line;
d1369 3
a1371 3
	while ((line = fgetln(master, &len)) != NULL) {
		if ((colon = strchr(line, ':')) == NULL) {
			warnx("Malformed entry `%s'. Skipping", line);
d1374 2
a1375 2
		colonc = (size_t)(colon - line);
		if (strncmp(login_name, line, loginc) == 0 && loginc == colonc) {
d1408 9
a1416 6
		} else if ((cc = write(ptmpfd, line, len)) != len) {
			(void) close(masterfd);
			(void) close(ptmpfd);
			pw_abort();
			err(EXIT_FAILURE, "short write to /etc/ptmp (%lld not %lld chars)",
			    (long long)cc, (long long)len);
@


1.53
log
@Fix bound checks for gecos field, taking into account it may contain
multiple '&'s. Resolves PR 3616.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.52 2003/06/14 22:12:53 millert Exp $ */
d1397 2
a1398 2
					errx(EXIT_FAILURE, "can't add `%s',
					    line too long (%d bytes)", buf,
@


1.52
log
@For moduser(), only do valid_class() check when F_CLASS is set in
up->u_flags.  Fixes a coredump when changing/deleting an existing
user introduced by my recent commit here.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.51 2003/06/10 21:00:37 millert Exp $ */
d897 14
d1060 2
a1061 3
	if (strchr(up->u_comment, '&') != NULL)
		cc += strlen(login_name);
	if (cc >= sizeof(buf)) {
d1239 1
a1239 1
	size_t		colonc, len, loginc;
d1244 1
d1393 2
a1394 2
				    (strchr(up->u_comment, '&') != NULL &&
				    len + strlen(newlogin) >= sizeof(buf))) {
d1399 2
a1400 1
					    len + strlen(newlogin));
@


1.51
log
@Check that login class exists before using it; based on a patch from
Peter Werner.  Closes PR 2699.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.50 2003/06/10 20:52:01 millert Exp $ */
a1237 5
#ifdef EXTENSIONS
	if (!valid_class(up->u_class)) {
		errx(EXIT_FAILURE, "No such login class `%s'", up->u_class);
	}
#endif
d1343 7
a1349 1
		if (up->u_flags & F_CLASS)
d1351 1
@


1.50
log
@o Check for fwrite() error with != 1, not <= 0 (mostly style)
o Correct some error messages
o More informative error when reading a line that is > LINE_MAX
o When saving password, only alloc space for what is used
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.49 2003/06/10 20:27:31 millert Exp $ */
d43 3
d600 13
d918 5
d1238 5
@


1.49
log
@Keep a table of password types, and their associated lengths, and
check in useradd or usermod whether the given encrypted password
has the correct length.

Factor out time code into a function, scantime()

Perform ctype(3) operations on unsigned chars.

From NetBSD (agc)
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.48 2003/06/10 20:03:56 millert Exp $ */
d352 1
a352 1
		if (fwrite(buf, cc, 1, to) <= 0) {
d390 1
a390 1
		warn("can't create gid for `%s': can't open `%s'", group,
d401 1
a401 1
		warn("can't create gid: mkstemp failed");
d408 1
a408 1
		warn("can't create gid: fdopen `%s' failed", f);
d414 2
a415 2
		if (buf[cc - 1] != '\n') {
			while (!feof(from) && fgetc(from) != '\n')
d417 2
a418 2
			warn("line `%s' too long (%d bytes), skipping", buf,
			    cc);
d434 1
a434 1
		if (fwrite(buf, cc, 1, to) <= 0) {
d438 1
a438 1
			warn("can't create gid: short write to `%s'", f);
d446 1
a446 1
		warn("can't create gid: can't rename `%s' to `%s'", f, _PATH_GROUP);
d499 1
a499 1
		warn("can't create gid: mkstemp failed");
d506 1
a506 1
		warn("can't create gid: fdopen `%s' failed", f);
d511 2
a512 2
		if (buf[cc - 1] != '\n') {
			while (!feof(from) && fgetc(from) != '\n')
d514 2
a515 2
			warn("line `%s' too long (%d bytes), skipping", buf,
			    cc);
d540 1
a540 1
		if (fwrite(buf, cc, 1, to) <= 0) {
d544 1
a544 1
			warn("can't create gid: short write to `%s'", f);
d552 1
a552 1
		warn("can't create gid: can't rename `%s' to `%s'", f, _PATH_GROUP);
d1119 7
d1131 1
a1131 1
			cc -= (int)(matchv[2].rm_eo);
d1133 2
a1134 2
			if (fwrite(buf, sizeof(char), sc, to) != sc ||
			    fwrite(&buf[(int)matchv[2].rm_eo], sizeof(char), cc, to) != cc) {
d1141 1
a1141 1
		} else if (fwrite(buf, sizeof(char), cc, to) != cc) {
d1170 1
d1180 8
d1824 1
a1824 1
		memsave(&u.u_password, password, PasswordLength);
@


1.48
log
@Use syslog(3) to log new users and groups, deletions of users and groups,
and modification of user and group information.

Syslog priority is LOG_INFO, facility is LOG_USER (there is no need to
do this via LOG_AUTH, since the password and group files are world
readable).

From NetBSD (agc)
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.47 2003/06/10 19:51:22 millert Exp $ */
d69 4
a72 4
	char		*u_password;		/* encrypted password */
	char		*u_comment;		/* comment field */
	char		*u_home;		/* home directory */
	char		*u_primgrp;		/* primary group */
d75 6
a80 6
	char		*u_shell;		/* user's shell */
	char		*u_basedir;		/* base directory for home */
	char		*u_expire;		/* when password will expire */
	char		*u_inactive;		/* when account will expire */
	char		*u_skeldir;		/* directory for startup files */
	char		*u_class;		/* login class */
d83 1
a83 1
	range_t		*u_rv;			/* the ranges */
d163 2
d263 1
a263 1
		if (!isdigit(*s)) {
d563 1
a563 1
	char	*cp;
d576 1
a576 1
	if (cp - login_name > MaxUserNameLen)
d585 1
a585 1
	char	*cp;
d592 1
a592 1
	if (cp - group > MaxUserNameLen)
d702 2
a703 2
	char		*cp;
	char		*s;
d819 62
a886 1
	struct tm	tm;
d988 2
a989 11
	inactive = 0;
	if (up->u_inactive != NULL) {
		(void) memset(&tm, 0, sizeof(tm));
		if (strptime(up->u_inactive, "%c", &tm) != NULL) {
			inactive = mktime(&tm);
		} else if (strptime(up->u_inactive, "%B %d %Y", &tm) != NULL) {
			inactive = mktime(&tm);
		} else if (isdigit(up->u_inactive[0]) != NULL) {
			inactive = atoi(up->u_inactive);
		} else {
			warnx("Warning: inactive time `%s' invalid, account expiry off",
a990 1
		}
d992 2
a993 11
	expire = 0;
	if (up->u_expire != NULL) {
		(void) memset(&tm, 0, sizeof(tm));
		if (strptime(up->u_expire, "%c", &tm) != NULL) {
			expire = mktime(&tm);
		} else if (strptime(up->u_expire, "%B %d %Y", &tm) != NULL) {
			expire = mktime(&tm);
		} else if (isdigit(up->u_expire[0]) != NULL) {
			expire = atoi(up->u_expire);
		} else {
			warnx("Warning: expire time `%s' invalid, password expiry off",
a994 1
		}
d1000 1
a1000 2
	if (up->u_password != NULL &&
	    strlen(up->u_password) <= PasswordLength) {
d1003 2
a1004 1
		(void) strlcpy(password, "*", sizeof(password));
a1009 1

a1186 1
	struct tm	tm;
d1248 7
a1254 1
			if (up->u_password != NULL && strlen(up->u_password) <= PasswordLength)
d1256 1
d1288 1
a1288 8
			(void) memset(&tm, 0, sizeof(tm));
			if (strptime(up->u_inactive, "%c", &tm) != NULL) {
				pwp->pw_change = mktime(&tm);
			} else if (strptime(up->u_inactive, "%B %d %Y", &tm) != NULL) { 
				pwp->pw_change = mktime(&tm);
			} else if (isdigit(up->u_inactive[0]) != NULL) {
				pwp->pw_change = atoi(up->u_inactive);
			} else {
d1294 1
a1294 8
			(void) memset(&tm, 0, sizeof(tm));
			if (strptime(up->u_expire, "%c", &tm) != NULL) {
				pwp->pw_expire = mktime(&tm);
			} else if (strptime(up->u_expire, "%B %d %Y", &tm) != NULL) { 
				pwp->pw_expire = mktime(&tm);
			} else if (isdigit(up->u_expire[0]) != NULL) {
				pwp->pw_expire = atoi(up->u_expire);
			} else {
d1806 2
a1807 1
		(void) strlcpy(password, "*", sizeof(password));
@


1.47
log
@Catch illegal flags and reply with usage; from NetBSD (agc)
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.46 2003/06/10 19:45:56 millert Exp $ */
d50 1
d368 1
d448 5
d1028 2
d1348 9
a1356 1

d1582 1
d1694 1
d1775 1
d1781 1
d1837 1
d1864 3
d1875 1
a1927 3
			usermgmt_usage("groupdel");
			/* NOTREACHED */
		default:
d1972 1
d1998 3
a2059 3
		default:
			usermgmt_usage("userinfo");
			/* NOTREACHED */
@


1.46
log
@o rename login variable to login_name
o remove user from supplementary groups when deleting a user and not
preserving information.
o add some const
o check that user/group is local (not YP) before trying to change it.
From NetBSD (agc)
@
text
@d1 2
a2 2
/* $OpenBSD: user.c,v 1.45 2003/06/08 23:04:36 millert Exp $ */
/* $NetBSD: user.c,v 1.56 2002/08/06 11:56:26 agc Exp $ */
d1533 3
d1660 3
d1723 3
d1796 3
d1901 6
d2033 6
@


1.45
log
@user -e and -f now accepts "month day year" (ala chpass(1)) and
seconds-since-epoch.  From NetBSD (grant).
@
text
@d1 2
a2 2
/* $OpenBSD: user.c,v 1.44 2003/06/08 20:50:51 millert Exp $ */
/* $NetBSD: user.c,v 1.52 2002/06/01 06:28:06 grant Exp $ */
d45 1
d73 1
a73 1
	char		*u_groupv[NGROUPS_MAX];	/* secondary groups */
d185 1
a185 1
memsave(char **cpp, char *s, size_t n)
d312 1
a312 1
creategid(char *group, gid_t gid, char *name)
d451 1
a451 1
append_group(char *user, int ngroups, char **groups)
d552 1
a552 1
valid_login(char *login)
d557 1
a557 1
	if (*login == '-')
d560 1
a560 1
	for (cp = login ; *cp ; cp++) {
d567 1
a567 1
	if (cp - login > MaxUserNameLen)
d812 1
a812 1
adduser(char *login, user_t *up)
d829 2
a830 2
	if (!valid_login(login)) {
		errx(EXIT_FAILURE, "`%s' is not a valid login name", login);
d906 1
a906 1
	if (!(up->u_flags & F_DUPUID) && getpwnam(login) != NULL) {
d909 1
a909 1
		errx(EXIT_FAILURE, "already a `%s' user", login);
d915 2
a916 1
		(void) snprintf(home, sizeof(home), "%s/%s", up->u_basedir, login);
d962 1
a962 1
	    login,
d977 1
a977 1
		cc += strlen(login);
d1003 3
a1005 2
	if (strcmp(up->u_primgrp, "=uid") == 0 && getgrnam(login) == NULL &&
	    !creategid(login, gid, login)) {
d1009 1
a1009 1
		    gid, login);
d1011 1
a1011 1
	if (up->u_groupc > 0 && !append_group(login, up->u_groupc, up->u_groupv)) {
d1014 1
a1014 1
		errx(EXIT_FAILURE, "can't append `%s' to new groups", login);
d1017 1
a1017 1
	if (pw_mkdb(login, 0) < 0) {
d1024 106
d1132 1
a1132 1
moduser(char *login, char *newlogin, user_t *up)
d1149 1
a1149 1
		errx(EXIT_FAILURE, "`%s' is not a valid login name", login);
d1151 5
a1155 2
	if ((pwp = getpwnam(login)) == NULL) {
		errx(EXIT_FAILURE, "No such user `%s'", login);
d1180 1
a1180 1
			if (strcmp(login, newlogin) != 0 && getpwnam(newlogin) != NULL) {
d1267 1
a1267 1
	loginc = strlen(login);
d1274 1
a1274 1
		if (strncmp(login, line, loginc) == 0 && loginc == colonc) {
d1331 2
a1332 2
	if (up != NULL && strcmp(login, newlogin) == 0)
		rval = pw_mkdb(login, 0);
d1749 3
d1902 3
@


1.44
log
@Add check for group too long and made an invalid group a fatal error
instead of just a warning which is consistent with the way an invalid
user is treated.
@
text
@d1 2
a2 2
/* $OpenBSD: user.c,v 1.43 2003/06/08 20:43:25 millert Exp $ */
/* $NetBSD: user.c,v 1.45 2001/08/17 08:29:00 joda Exp $ */
d76 1
a76 1
	int		u_inactive;		/* inactive */
d174 1
d326 1
a326 1
		warn("can't create gid for %s: can't open %s", group,
d385 1
a385 1
		warn("can't create gid for %s: can't open %s", group,
d478 1
a478 1
		warn("can't append group for %s: can't open %s", user,
d663 1
a663 1
	    fprintf(fp, "inactive\t%d\n", up->u_inactive) <= 0 ||
d745 8
a752 1
				up->u_inactive = atoi(cp);
d817 1
d916 14
d933 6
a938 2
		if (strptime(up->u_expire, "%c", &tm) == NULL) {
			warnx("invalid time format `%s'", optarg);
d940 2
a941 1
			expire = mktime(&tm);
d959 1
a959 1
	if ((cc = snprintf(buf, sizeof(buf), "%s:%s:%u:%u:%s:%d:%ld:%s:%s:%s\n",
d969 1
a969 1
	    up->u_inactive,
d973 4
a976 3
	    up->u_shell)) >= sizeof(buf) || cc < 0 ||
	    (strchr(up->u_comment, '&') != NULL &&
	    cc + strlen(login) >= sizeof(buf))) {
d1118 13
a1130 2
		if (up->u_flags |= F_INACTIVE)
			pwp->pw_change = up->u_inactive;
d1133 3
a1135 3
			if (strptime(up->u_expire, "%c", &tm) == NULL)
				warnx("invalid time format `%s'", optarg);
			else
d1137 6
d1373 1
a1373 1
			u.u_inactive = atoi(optarg);
d1435 1
a1435 1
		(void) printf("inactive\t%d\n", u.u_inactive);
d1499 1
a1499 1
			u.u_inactive = atoi(optarg);
@


1.43
log
@Use _PW_NAME_LEN not MAXLOGNAME since the latter does not include the NUL.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.42 2003/05/13 01:12:31 millert Exp $ */
d581 2
d1634 3
a1642 3
	if (!valid_group(*argv)) {
		warnx("warning - invalid group name `%s'", *argv);
	}
d1746 1
a1746 1
		warnx("warning - invalid group name `%s'", newname);
@


1.42
log
@Don't allow usernames to begin with a dash since pwd_mkdb(8)
will reject such a name; from Brian Poole
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.41 2003/04/03 16:03:06 millert Exp $ */
d157 1
a157 1
	MaxUserNameLen = MAXLOGNAME,
@


1.41
log
@The check for whether or not a group is empty was busted.  Closes PR 3178.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.40 2002/12/10 20:49:28 millert Exp $ */
d553 4
@


1.40
log
@Add 2 missing pw_abort() calls when pw_mkdb() fails and remove the
void cast from pw_abort() since it is already void.
From NetBSD via Brian Poole.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.39 2002/11/07 22:05:43 millert Exp $ */
d516 1
a516 1
				if (*(colon + 1) != '\0')
@


1.39
log
@Check for non-existent group in groupdel just like userdel; Sebastian Stark
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.38 2002/11/07 22:02:18 millert Exp $ */
d831 1
a831 1
			(void) pw_abort();
d844 1
a844 1
		for (i = up->u_defrc; got_id == 0 && i < up->u_rc ; i++){ 
d861 1
a861 1
			(void) pw_abort();
d868 1
a868 1
		(void) pw_abort();
d875 1
a875 1
			(void) pw_abort();
d886 1
a886 1
		(void) pw_abort();
d892 1
a892 1
		(void) pw_abort();
d943 1
a943 1
		(void) pw_abort();
d948 1
a948 1
		(void) pw_abort();
d954 1
a954 1
			(void) pw_abort();
d960 1
a960 1
				(void) pw_abort();
d969 1
a969 1
		(void) pw_abort();
d975 1
a975 1
		(void) pw_abort();
d980 1
d1027 1
a1027 1
		(void) pw_abort();
d1035 1
a1035 1
				(void) pw_abort();
d1058 1
a1058 1
				(void) pw_abort();
d1068 1
a1068 1
					(void) pw_abort();
d1079 1
a1079 1
				(void) pw_abort();
d1131 1
a1131 1
					(void) pw_abort();
d1138 1
a1138 1
					(void) pw_abort();
d1145 1
a1145 1
			(void) pw_abort();
d1154 1
a1154 1
			(void) pw_abort();
d1161 2
a1162 2
			 (void) pw_abort();
			 errx(EXIT_FAILURE, "can't append `%s' to new groups",
d1171 2
a1172 1
	if (rval == -1)
d1174 1
@


1.38
log
@Change some err/warn -> errx/warnx.  Should maybe do the same for
the short write cases.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.37 2002/11/07 21:49:31 millert Exp $ */
d1668 4
@


1.37
log
@Allow '$' in a username as long as it is the last character since
samba wants to create usernames that end in '$'.  From Paul Chakravarti
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.36 2002/07/25 15:41:39 millert Exp $ */
d384 2
a385 1
		warn("can't create gid for %s: can't open %s", group, _PATH_GROUP);
d508 1
a508 1
			warn("badly formed entry `%s'", buf);
d573 1
a573 1
		if (!isalnum(*cp)) {
d1626 1
a1626 1
		err(EXIT_FAILURE, "can't add group: can't get next gid");
d1724 1
a1724 1
		err(EXIT_FAILURE, "Nothing to change");
d1727 1
a1727 1
		err(EXIT_FAILURE, "Duplicate which gid?");
d1730 1
a1730 1
		err(EXIT_FAILURE, "can't find group `%s' to modify", *argv);
d1733 1
a1733 1
		warn("warning - invalid group name `%s'", newname);
d1738 1
a1738 1
		err(EXIT_FAILURE, "group `%s' entry too long", grp->gr_name);
d1743 1
a1743 1
			err(EXIT_FAILURE, "group `%s' entry too long",
d1752 1
a1752 1
		err(EXIT_FAILURE, "group `%s' entry too long", grp->gr_name);
@


1.36
log
@Check snprintf() rval for < 0; OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.35 2002/06/09 22:12:57 millert Exp $ */
d554 3
a556 1
		if (!isalnum(*cp) && *cp != '.' && *cp != '_' && *cp != '-') {
@


1.35
log
@When checking for valid login names, check length against MaxUserNameLen.
Noticed by Brian Poole who supplied a different patch.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.34 2002/05/17 04:07:50 millert Exp $ */
d922 5
a926 5
	cc = snprintf(buf, sizeof(buf), "%s:%s:%u:%u:%s:%d:%ld:%s:%s:%s\n",
			login,
			password,
			up->u_uid,
			gid,
d928 1
a928 1
			up->u_class,
d930 1
a930 1
			"",
d932 5
a936 6
			up->u_inactive,
			(long) expire,
			up->u_comment,
			home,
			up->u_shell);
	if (cc >= sizeof(buf) || cc == -1 ||
d938 1
a938 1
	     cc + strlen(login) >= sizeof(buf))) {
d1108 6
a1113 6
				len = snprintf(buf, sizeof(buf),
					"%s:%s:%d:%d:%s:%ld:%ld:%s:%s:%s\n",
					newlogin,
					pwp->pw_passwd,
					pwp->pw_uid,
					pwp->pw_gid,
d1115 1
a1115 1
					pwp->pw_class,
d1117 1
a1117 1
					"",
d1119 5
a1123 6
					(long)pwp->pw_change,
					(long)pwp->pw_expire,
					pwp->pw_gecos,
					pwp->pw_dir,
					pwp->pw_shell);
				if (len >= sizeof(buf) ||
d1128 3
a1130 1
					errx(EXIT_FAILURE, "can't add `%s', line too long (%d bytes)", buf, len + strlen(newlogin));
d1732 1
a1732 1
	cc = snprintf(buf, sizeof(buf), "%s:%s:%u:",
d1734 1
a1734 2
	    (gid < 0) ? grp->gr_gid : gid);
	if (cc >= sizeof(buf) || cc == -1)
@


1.34
log
@When modifying a group w/ no members with groupmod(8) the trailing
newline was not added.  Reported by Rob Sessink, different fix by me.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.33 2002/04/04 18:39:32 millert Exp $ */
d558 2
@


1.33
log
@From Brian Poole:
o unlink /etc/group temp file if rename fails
o when doing 'cd' in a system() separate with && not ';' so we don't
do stuff in the wrong place.  Much of this should just be done inline.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.32 2002/04/03 22:35:26 millert Exp $ */
d1741 1
a1741 3
		if (cpp[1] == NULL)
			buf[cc - 1] = '\n';
		else
d1743 2
a1744 1
		buf[cc] = '\0';
d1746 3
@


1.32
log
@UID ranges specified on the command line were being overridden by
those found in the config file.  Those on the command line should
be used in preference to the config file ranges.
Based on a patch from Brian Poole.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.31 2002/03/14 06:51:42 mpech Exp $ */
d300 1
a300 1
		(void) asystem("cd %s; %s -rw -pe %s . %s", 
d359 1
d438 1
d539 1
@


1.31
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.30 2002/03/05 17:30:15 millert Exp $ */
d830 19
a848 3
		for (i = 0 ; i < up->u_rc ; i++) {
			if (getnextuid(sync_uid_gid, &up->u_uid, up->u_rv[i].r_from, up->u_rv[i].r_to)) {
				break;
d851 1
a851 1
		if (i == up->u_rc) {
@


1.30
log
@'user -D -k path' was not actually changing the default values unless another
option to change was specified.  Also fix man page formatting mistake.
From Brian Poole
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.29 2001/12/05 18:23:55 millert Exp $ */
d237 1
a237 1
		warnx("User `%s' doesn't own directory `%s', not removed\n",
d247 1
a247 1
		warnx("Unable to remove all files in `%s'\n", dir);
@


1.29
log
@Minor sync with NetBSD
o fix two err() calls that should be errx()
o don't use the colonc variable in a non-obvious way
o add missing or of F_SHELL when in preserve mode
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.28 2001/12/05 18:20:57 millert Exp $ */
d1301 1
@


1.28
log
@o Use proper uid_t and gid_t types and fixup printf format strings to match
o Change "unsigned" -> "unsigned int"
o Correct a buffer size that should have been LINE_MAX
o Simplify creation of group entry in groupmod() using strlcat() and
  catch errors.
Theo and myself...
@
text
@d1 2
a2 2
/* $OpenBSD: user.c,v 1.27 2001/11/15 20:09:08 danh Exp $ */
/* $NetBSD: user.c,v 1.40 2001/08/17 08:29:00 joda Exp $ */
d947 1
a947 1
		err(EXIT_FAILURE, "can't create gid %d for login name %s",
a969 1
	char		newdir[MaxFileNameLen];
d972 1
d974 1
d1117 1
a1117 1
		} else if ((colonc = write(ptmpfd, line, len)) != len) {
d1122 1
a1122 1
			    (long long)colonc, (long long)len);
d1550 1
d1610 1
a1610 1
		err(EXIT_FAILURE, "can't add group: problems with %s file",
d1716 1
a1716 1
	for (cpp = grp->gr_mem ; *cpp; cpp++) {
@


1.27
log
@fix password length check; allows usermod -p to work again.

ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.26 2001/11/08 23:26:45 millert Exp $ */
d59 2
a60 2
	int	r_from;		/* low uid */
	int	r_to;		/* high uid */
d66 1
a66 1
	int		u_uid;			/* uid of user */
d79 2
a80 2
	unsigned	u_rsize;		/* size of range array */
	unsigned	u_rc;			/* # of ranges */
d82 1
a82 1
	unsigned	u_defrc;		/* # of ranges in defaults */
d215 1
a215 1
removehomedir(const char *user, int uid, const char *dir)
d279 1
a279 1
copydotfiles(char *skeldir, int uid, int gid, char *dir)
d303 1
a303 1
	(void) asystem("%s -R -P %d:%d %s", CHOWN, uid, gid, dir);
d310 1
a310 1
creategid(char *group, int gid, char *name)
d355 1
a355 1
	(void) fprintf(to, "%s:*:%d:%s\n", group, gid, name);
d574 1
a574 1
getnextgid(int *gidp, int lo, int hi)
d771 1
a771 1
getnextuid(int sync_uid_gid, int *uid, int low_uid, int high_uid)
d797 1
a797 1
	char		buf[MaxFileNameLen];
d801 1
a801 1
	int		gid;
d829 1
a829 1
	if (up->u_uid == -1) {
d838 1
a838 1
			errx(EXIT_FAILURE, "can't get next uid for %d", up->u_uid);
d845 1
a845 1
		errx(EXIT_FAILURE, "uid %d is already in use", up->u_uid);
d852 1
a852 1
			errx(EXIT_FAILURE, "gid %d is already in use", up->u_uid);
d900 2
a901 1
	cc = snprintf(buf, sizeof(buf), "%s:%s:%d:%d:%s:%d:%ld:%s:%s:%s\n",
d916 1
a916 1
	if (cc >= sizeof(buf) ||
d1034 1
a1034 1
				errx(EXIT_FAILURE, "uid %d is already in use", up->u_uid);
d1044 1
a1044 1
					errx(EXIT_FAILURE, "gid %d is already in use", up->u_uid);
d1258 1
a1258 1
	u.u_uid = -1;
d1572 1
a1572 1
	gid = -1;
d1666 1
a1666 1
	gid = -1;
d1708 16
a1723 6
	cc = snprintf(buf, sizeof(buf), "%s:%s:%d:",
			(newname) ? newname : grp->gr_name, grp->gr_passwd,
			(gid < 0) ? grp->gr_gid : gid);
	for (cpp = grp->gr_mem ; *cpp && cc < sizeof(buf) ; cpp++) {
		cc += snprintf(&buf[cc], sizeof(buf) - cc, "%s%s", *cpp,
			(cpp[1] == NULL) ? "" : ",");
a1724 4
	if (cc < sizeof(buf))
		cc += snprintf(&buf[cc], sizeof(buf) - cc, "\n");
	else
		err(EXIT_FAILURE, "group `%s' entry too long", grp->gr_name);
d1767 1
a1767 1
	(void) printf("uid\t%d\n", pwp->pw_uid);
d1769 1
a1769 1
		(void) printf("groups\t%d", pwp->pw_gid);
d1826 1
a1826 1
	(void) printf("gid\t%d\n", grp->gr_gid);
@


1.26
log
@Replace unreadable snprintf() and pointer arithmetic with simple strlcat().

If group file line would grow to be too long, leave it unmolested (previously
it would get removed).

Use fclose(fp) not close(fd) for a stream that was fdopen()ed.  Otherwise
we could leak memory.

When calling fwrite() pass the buffer as a single element instead of
using n one-byte elements.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.25 2001/09/18 01:50:44 millert Exp $ */
d1025 1
a1025 1
			if (up->u_password != NULL && strlen(up->u_password) == PasswordLength)
@


1.25
log
@Sync with NetBSD plus the following changes:
o use LINE_MAX for the max password entry length.  This is also what
  pwd_mkdb does.
o add more checks for lines that are too long
o kill some useless (and incorrect) casts
o check snprintf() return vals for sanity before use
o sync usage() with man pages
o slight KNF
o eliminate some silly uses of snprintf
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.24 2001/08/16 18:29:27 millert Exp $ */
d347 1
a347 1
		if (fwrite(buf, sizeof(char), cc, to) != cc) {
d349 1
a349 1
			(void) close(fd);
d426 1
a426 1
		if (fwrite(buf, sizeof(char), cc, to) != cc) {
d428 1
a428 1
			(void) close(fd);
a454 2
	int		groupc;
	int		entc;
a455 1
	int		nc;
a507 1
		entc = (int)(colon - buf);
d509 12
a520 14
			if ((groupc = strlen(groups[i])) == 0) {
				continue;
			}
			if (cc >= sizeof(buf)) {
				warn("line `%s' too long, skipping", buf);
				continue;
			}
			if (entc == groupc && strncmp(groups[i], buf, entc) == 0) {
				if ((nc = snprintf(&buf[cc - 1],
						sizeof(buf) - cc + 1,
						"%s%s\n",
						(buf[cc - 2] == ':') ? "" : ",",
						user)) >= sizeof(buf) - cc + 1) {
					warnx("Warning: group `%s' entry too long", groups[i]);
d522 2
a523 1
				cc += nc - 1;
d526 1
a526 1
		if (fwrite(buf, sizeof(char), cc, to) != cc) {
d528 1
a528 1
			(void) close(fd);
@


1.24
log
@extra arg to pw_mkdb
@
text
@d1 2
a2 2
/* $OpenBSD: user.c,v 1.23 2001/03/24 19:27:18 jakob Exp $ */
/* $NetBSD: user.c,v 1.17 2000/04/14 06:26:55 simonb Exp $ */
d43 1
d56 1
d65 1
a68 1
	int		u_homeset;		/* home dir has been set */
a76 2
	int		u_mkdir;		/* make the home directory */
	int		u_dupuid;		/* duplicate uids are allowed */
d78 1
d86 17
d118 1
a118 1
#define DEF_SHELL	"/bin/csh"
d138 5
a142 1
#define DEF_EXPIRE	(char *) NULL
a158 2
	MaxEntryLen = 2048,
	MaxPasswordEntryLen = 1024,
d166 1
d176 4
a179 1
static int	verbose = 0;
d185 1
a185 1
	if (*cpp != (char *) NULL) {
d195 1
a195 1
asystem(char *fmt, ...)
d213 39
d285 1
a285 1
	if ((dirp = opendir(skeldir)) == (DIR *) NULL) {
d289 1
a289 1
	for (n = 0; (dp = readdir(dirp)) != (struct dirent *) NULL && n == 0 ; ) {
d304 1
d310 1
a310 1
creategid(char *group, int gid)
d315 1
a315 1
	char		buf[MaxEntryLen];
d320 1
a320 1
	if (getgrnam(group) != (struct group *) NULL) {
d324 3
a326 2
	if ((from = fopen(_PATH_GROUP, "r")) == (FILE *) NULL) {
		warn("can't create gid for %s: can't open %s", group, _PATH_GROUP);
d333 1
a333 1
	(void) snprintf(f, sizeof(f), "%s.XXXXXX", _PATH_GROUP);
d339 1
a339 1
	if ((to = fdopen(fd, "w")) == (FILE *) NULL) {
d347 1
a347 1
		if (fwrite(buf, sizeof(char), (unsigned) cc, to) != cc) {
d355 1
a355 1
	(void) fprintf(to, "%s:*:%d:\n", group, gid);
d359 2
a360 1
		warn("can't create gid: can't rename `%s' to `%s'", f, _PATH_GROUP);
d374 1
a374 1
	char		buf[MaxEntryLen];
d382 1
a382 1
	if ((from = fopen(_PATH_GROUP, "r")) == (FILE *) NULL) {
d390 1
a390 1
	(void) snprintf(f, sizeof(f), "%s.XXXXXX", _PATH_GROUP);
d396 1
a396 1
	if ((to = fdopen(fd, "w")) == (FILE *) NULL) {
d406 7
d418 1
a418 1
		if (entc == groupc && strncmp(group, buf, (unsigned) entc) == 0) {
d426 1
a426 1
		if (fwrite(buf, sizeof(char), (unsigned) cc, to) != cc) {
d444 1
a444 1
/* (Re)write secondary groups */
d446 1
a446 1
modify_groups (char *login, char *newlogin, user_t *up, char *primgrp)
d448 31
a478 12
	struct stat    st;
	FILE          *from, *to;
	char          *colon, *p;
	char           buf[MaxEntryLen], tmpf[MaxFileNameLen];
	int            fd, cc, g;

	/* XXX This function, and modify_gid() above could possibly be */
	/* combined into one function. */

	if ((from = fopen(_PATH_GROUP, "r")) == (FILE *) NULL) {
		warn("can't create/modify groups for login %s: can't open %s",
		     login, _PATH_GROUP);
d485 2
a486 2
	(void) snprintf(tmpf, sizeof (tmpf), "%s.XXXXXX", _PATH_GROUP);
	if ((fd = mkstemp (tmpf)) < 0) {
d488 1
a488 1
		warn("can't modify secondary groups: mkstemp failed");
d491 1
a491 1
	if ((to = fdopen(fd, "w")) == (FILE *) NULL) {
d494 2
a495 2
		(void) unlink(tmpf);
		warn("can't create gid: fdopen `%s' failed", tmpf);
d498 11
a508 4

	while (fgets (buf, sizeof(buf), from) != NULL) {
	  	if ((colon = strchr (buf, ':')) == NULL) {
		  	warn ("badly formed entry `%s'", buf);
d511 18
a528 32

		/* Does the user exist in this group? */
		cc = strlen (buf);
		g  = strlen (login);
		p  = colon; 
		while (p < (buf + cc) && (p = strstr (p, login)) != NULL &&
		       *(p + g) != ',' && *(p + g) != '\n')
		  	p += g;
		if (p && p < (buf + cc)) {
		  	/* Remove. XXX Un-obfuscate. */
		  	bcopy (*(p + g) == ',' ? (p + g + 1) : (p + g), 
			       *(p - 1) == ',' && *(p + g) != ',' ? p - 1 : p, 
			       strlen (p + g) + 1);
		}
		
		/* Should the user exist in this group? */
		cc = strlen (primgrp);
		for (g = 0; g < up->u_groupc; g++) {
		        if (!up->u_groupv[g] ||
			    !strncmp (up->u_groupv[g], primgrp,
				      MAX (strlen (up->u_groupv[g]), cc)))
			  	continue;
		        if ((int)(colon - buf) == strlen (up->u_groupv[g]) &&
			    !strncmp (up->u_groupv[g], buf, 
				      (int)(colon - buf))) {
			  	/* Add user. */
				p = buf + strlen(buf) - 1; /* No '\n' */
				snprintf (p, sizeof (buf), "%s%s\n", 
					  (*(p-1) == ':' ? "" : ",") ,
					  (newlogin ? newlogin : login));
				up->u_groupv[g] = '\0'; /* Mark used. */
				g = up->u_groupc;       /* Break loop. */
d531 5
a535 8

		cc = strlen (buf);
		if (fwrite (buf, sizeof (char), cc, to) != cc) {
		  	(void) fclose (from);
			(void) close (fd);
			(void) unlink (tmpf);
			warn ("can't update secondary groups: "
			      "short write to `%s'", tmpf);
d539 4
a542 5
	(void) fclose (from);
	(void) fclose (to);
	if (rename (tmpf, _PATH_GROUP) < 0) {
	  	warn("can't create gid: can't rename `%s' to `%s'", tmpf, 
		     _PATH_GROUP);
a545 5
	/* Warn about unselected groups. */
	for (g = 0; g < up->u_groupc; g++)
	  	if (up->u_groupv[g])
		  	warnx("extraneous group `%s' not added",
			      up->u_groupv[g]);
d582 1
a582 1
		if (getgrgid((gid_t)*gidp) == (struct group *) NULL) {
d632 1
d634 1
d636 1
a636 1
	(void) snprintf(template, sizeof(template), "%s.XXXXXX", CONFFILE);
d641 1
a641 1
	if ((fp = fdopen(fd, "w")) == (FILE *) NULL) {
d650 3
d654 2
a655 1
	    fprintf(fp, "expire\t\t%s\n", (up->u_expire == NULL) ? UNSET_EXPIRY : up->u_expire) <= 0) {
d690 3
d698 1
a698 1
	if ((fp = fopen(CONFFILE, "r")) == (FILE *) NULL) {
d704 1
a704 1
	if (fp != (FILE *) NULL) {
d726 6
d779 1
a779 1
		if (getpwuid((uid_t)(*uid)) == (struct passwd *) NULL && *uid != NOBODY_UID) {
d781 1
a781 1
				if (getgrgid((gid_t)(*uid)) == (struct group *) NULL) {
d847 1
a847 1
	if (!up->u_dupuid && getpwuid((uid_t)(up->u_uid)) != (struct passwd *) NULL) {
d854 1
a854 1
		if (getgrgid((gid_t)(up->u_uid)) != (struct group *) NULL) {
d860 1
a860 1
	} else if ((grp = getgrnam(up->u_primgrp)) != (struct group *) NULL) {
d863 1
a863 1
		   (grp = getgrgid((gid_t)atoi(up->u_primgrp))) != (struct group *) NULL) {
d871 1
a871 1
	if (!up->u_dupuid && getpwnam(login) != (struct passwd *) NULL) {
d876 1
a876 1
	if (up->u_homeset) {
d891 4
d905 1
a905 1
	cc = snprintf(buf, sizeof(buf), "%s:%s:%d:%d::%d:%ld:%s:%s:%s\n",
d910 5
d920 1
a920 1
	if (cc >= MaxPasswordEntryLen ||
d922 1
a922 1
	     cc + strlen(login) >= MaxPasswordEntryLen)) {
d932 2
a933 2
	if (up->u_mkdir) {
		if (lstat(home, &st) < 0 && asystem("%s -p %s", MKDIR, home) != 0) {
d936 9
a944 1
			err(EXIT_FAILURE, "can't mkdir `%s'", home);
a945 1
		(void) copydotfiles(up->u_skeldir, up->u_uid, gid, home);
d947 2
a948 3
	if (sync_uid_gid &&
	    getgrnam(login) == (struct group *) NULL &&
	    !creategid(login, gid)) {
d951 2
a952 1
		err(EXIT_FAILURE, "can't create gid %d for login name %s", gid, login);
d954 4
a957 8
	/* Modify secondary groups */
	if (up->u_groupc != 0 && 
	    !modify_groups (login, NULL, up,
			    (sync_uid_gid ? login : up->u_primgrp))) {
	  	(void) close(ptmpfd);
	  	(void) pw_abort();
		err(EXIT_FAILURE, 
		    "failed to modify secondary groups for login %s", login);
d973 4
a976 3
	time_t		expire;
	size_t		loginc;
	size_t		colonc;
d978 1
a978 5
	char		password[PasswordLength + 1];
	char		oldhome[MaxFileNameLen];
	char		home[MaxFileNameLen];
	char		buf[MaxFileNameLen];
	char		*colon;
d981 1
a981 2
	int		gid;
	int		cc;
d986 1
a986 1
	if ((pwp = getpwnam(login)) == (struct passwd *) NULL) {
d989 3
d1003 1
a1003 1
	if ((master = fdopen(masterfd, "r")) == (FILE *) NULL) {
d1009 4
a1012 12
	if (up != (user_t *) NULL) {
		if (up->u_mkdir) {
			(void) strlcpy(oldhome, pwp->pw_dir, sizeof(oldhome));
		}
		if (up->u_uid == -1) {
			up->u_uid = pwp->pw_uid;
		}
		if (up->u_primgrp == NULL) {
			gid = pwp->pw_gid;
		} else if (strcmp(up->u_primgrp, "=uid") == 0) {
		  	/* if -g=uid was specified, check gid is unused */
			if (getgrgid((gid_t)(up->u_uid)) != (struct group *) NULL) {
d1015 12
a1026 1
				errx(EXIT_FAILURE, "gid %d is already in use", up->u_uid);
a1027 10
			gid = up->u_uid;
		} else if ((grp = getgrnam(up->u_primgrp)) != (struct group *) NULL) {
			gid = grp->gr_gid;
		} else if (is_number(up->u_primgrp) &&
			   (grp = getgrgid((gid_t)atoi(up->u_primgrp))) != (struct group *) NULL) {
			gid = grp->gr_gid;
		} else {
			(void) close(ptmpfd);
			(void) pw_abort();
			errx(EXIT_FAILURE, "group %s not found", up->u_primgrp);
d1029 12
a1040 5
		/* if changing name, check new name isn't already in use */
		if (strcmp(login, newlogin) != 0 && getpwnam(newlogin) != (struct passwd *) NULL) {
			(void) close(ptmpfd);
			(void) pw_abort();
			errx(EXIT_FAILURE, "already a `%s' user", newlogin);
d1042 19
a1060 5
		/* if home directory hasn't been given, use the old one */
		if (!up->u_homeset) {
			(void) strlcpy(home, pwp->pw_dir, sizeof(home));
		} else {
		  	(void) strlcpy(home, up->u_home, sizeof(home));
d1062 3
a1064 2
		expire = 0;
		if (up->u_expire != NULL) {
d1066 1
a1066 1
			if (strptime(up->u_expire, "%c", &tm) == NULL) {
d1068 2
a1069 15
			} else {
				expire = mktime(&tm);
			}
		}
		if (up->u_password != NULL &&
		    strlen(up->u_password) <= PasswordLength) {
			(void) strlcpy(password, up->u_password, sizeof(password));
		} else {
			(void) strlcpy(password, pwp->pw_passwd, sizeof(password));
		}
		if (strcmp(up->u_comment, DEF_COMMENT) == 0) {
			memsave(&up->u_comment, pwp->pw_gecos, strlen(pwp->pw_gecos));
		}
		if (strcmp(up->u_shell, DEF_SHELL) == 0 && strcmp(pwp->pw_shell, DEF_SHELL) != 0) {
			memsave(&up->u_shell, pwp->pw_shell, strlen(pwp->pw_shell));
d1071 10
d1083 3
a1085 4
	while (fgets(buf, sizeof(buf), master) != NULL) {
		cc = strlen(buf);
		if ((colon = strchr(buf, ':')) == NULL) {
			warnx("Malformed entry `%s'. Skipping", buf);
d1088 5
a1092 4
		colonc = (size_t)(colon - buf);
		if (strncmp(login, buf, loginc) == 0 && loginc == colonc) {
			if (up != (user_t *) NULL) {
				cc = snprintf(buf, sizeof(buf), "%s:%s:%d:%d::%d:%ld:%s:%s:%s\n",
d1094 14
a1107 9
					password,
					up->u_uid,
					gid,
					up->u_inactive,
					(long) expire,
					up->u_comment,
					home,
					up->u_shell);
				if (cc >= MaxPasswordEntryLen ||
d1109 1
a1109 1
				     cc + strlen(newlogin) >= MaxPasswordEntryLen)) {
d1112 1
a1112 1
					errx(EXIT_FAILURE, "can't add `%s', line too long (%d bytes)", buf, cc + strlen(newlogin));
d1114 1
a1114 1
				if (write(ptmpfd, buf, (size_t) cc) != cc) {
a1118 11
				/* Modify secondary groups */
				grp = getgrgid (gid);
				if (up->u_groupc != 0 || 
				    strcmp (login, newlogin))
					if (!modify_groups (login, NULL, up, grp ? grp->gr_name : newlogin)) {
						(void) close(ptmpfd);
				    		(void) pw_abort();
						err(EXIT_FAILURE, 
						    "failed to modify secondary groups for login %s", 
						    login);
					}
d1120 1
a1120 1
		} else if (write(ptmpfd, buf, (size_t)(cc)) != cc) {
d1124 2
a1125 1
			err(EXIT_FAILURE, "short write to /etc/ptmp (not %d chars)", cc);
d1128 15
a1142 6
	if (up != (user_t *) NULL &&
	    up->u_mkdir &&
	    asystem("%s %s %s", MV, oldhome, home) != 0) {
		(void) close(ptmpfd);
		(void) pw_abort();
		err(EXIT_FAILURE, "can't move `%s' to `%s'", oldhome, home);
d1145 2
a1146 2
	if (up != (user_t *) NULL && strcmp(login, newlogin) == 0)
		cc = pw_mkdb(login, 0);
d1148 2
a1149 2
		cc = pw_mkdb(NULL, 0);
	if (cc < 0) {
d1151 1
a1151 1
	}
d1163 1
a1163 1
	if ((pwp = getpwnam(name)) != (struct passwd *) NULL) {
d1166 1
a1166 1
	if (is_number(name) && (pwp = getpwuid((uid_t)atoi(name))) != (struct passwd *) NULL) {
d1169 1
a1169 1
	return (struct passwd *) NULL;
d1180 1
a1180 1
	if ((grp = getgrnam(name)) != (struct group *) NULL) {
d1183 1
a1183 1
	if (is_number(name) && (grp = getgrgid((gid_t)atoi(name))) != (struct group *) NULL) {
d1186 1
a1186 1
	return (struct group *) NULL;
d1192 1
a1192 1
usermgmt_usage(char *prog)
d1196 8
a1203 8
		    "[-f inactive] [-g group]\n\t\t[-r lowuid..highuid] "
		    "[-s shell]\n", prog);
		(void) fprintf(stderr, "usage: %s [-G group[,group,...]] "
		    "[-b basedir] [-c comment] [-d homedir]\n\t\t"
		    "[-e expiry] [-f inactive] [-g group] "
		    "[-k skeletondir]\n\t\t[-m] [-o] [-p password] "
		    "[-r lowuid..highuid]\n\t\t[-s shell] [-u uid] "
		    "[-v] user\n", prog);
d1205 5
a1209 4
		(void) fprintf(stderr, "usage: %s [-G group[,group,...]] "
		    "[-c comment] [-d homedir] [-e expire]\n\t\t"
		    "[-f inactive] [-g group] [-l newname] [-m] [-o]\n\t\t"
		    "[-p password] [-s shell] [-u uid] [-v] user\n", prog);
d1212 1
a1212 2
		(void) fprintf(stderr, "usage: %s [-p preserve] [-r] [-v] "
		    "user\n", prog);
d1215 1
a1215 1
		(void) fprintf(stderr, "usage: %s [-e] [-v] user\n", prog);
d1218 1
a1218 1
		(void) fprintf(stderr, "usage: %s [-g gid] [-o] [-v] group\n",
d1223 2
a1224 2
		(void) fprintf(stderr, "usage: %s [-g gid] [-o] [-n newname] "
		    "[-v] group\n", prog);
d1234 1
a1234 1
		(void) fprintf(stderr, "usage: %s [-e] [-v] group\n", prog);
d1244 1
a1244 1
#define ADD_OPT_EXTENSIONS	"p:r:v"
d1256 1
d1258 1
a1258 1
	char    buf[MaxEntryLen], *s, *p;
d1270 9
a1278 8
		        strlcpy (buf, optarg, sizeof(buf));
			p = buf;
			while ((s = strsep (&p, ",")) != NULL &&
			       u.u_groupc < NGROUPS_MAX - 2)
			  	memsave (&u.u_groupv[u.u_groupc++], s, 
					 strlen(s));
			if (p != NULL)
			  	errx(EXIT_FAILURE, "too many groups for -G");
a1287 1
			u.u_homeset = 1;
d1289 1
d1306 6
d1313 1
a1313 1
			u.u_mkdir = 1;
d1316 1
a1316 1
			u.u_dupuid = 1;
d1355 3
d1367 3
a1369 1
	if (argc == optind) {
d1373 1
a1373 1
	return adduser(argv[optind], &u) ? EXIT_SUCCESS : EXIT_FAILURE;
d1377 1
a1377 1
#define MOD_OPT_EXTENSIONS	"p:v"
d1387 1
a1387 3
	int	have_new_user;
	int	c;
	char    buf[MaxEntryLen], *s, *p;
a1391 1
	u.u_uid = -1;
d1398 10
a1407 8
		        strlcpy (buf, optarg, sizeof(buf));
			p = buf;
			while ((s = strsep (&p, ",")) != NULL &&
			       u.u_groupc < NGROUPS_MAX - 2)
			  	memsave (&u.u_groupv[u.u_groupc++], s, 
					 strlen(s));
			if (p != NULL)
			  	errx(EXIT_FAILURE, "too many groups for -G");
d1411 1
a1413 1
			u.u_homeset = 1;
d1415 1
d1419 1
d1423 1
d1427 1
d1430 1
d1432 6
a1437 1
			(void) strlcpy(newuser, optarg, sizeof(newuser));
d1439 1
d1441 1
a1441 1
			u.u_mkdir = 1;
d1444 1
a1444 1
			u.u_dupuid = 1;
d1449 1
d1454 1
d1461 1
d1470 8
a1477 1
	if (argc == optind) {
d1481 2
a1482 2
	return moduser(argv[optind], (have_new_user) ? newuser : argv[optind],
		       &u) ? EXIT_SUCCESS : EXIT_FAILURE;
a1494 1
	struct stat	st;
d1540 3
a1542 1
	if (argc == optind) {
d1546 2
a1547 2
	if ((pwp = getpwnam(argv[optind])) == (struct passwd *) NULL) {
		warnx("No such user `%s'", argv[optind]);
d1550 2
a1551 7
	if (rmhome) {
		if (stat(pwp->pw_dir, &st) < 0) {
			warn("Home directory `%s' does not exist", pwp->pw_dir);
			return EXIT_FAILURE;
		}
		(void) asystem("%s -rf %s", RM, pwp->pw_dir);
	}
d1556 2
a1557 1
		return moduser(argv[optind], argv[optind], &u) ? EXIT_SUCCESS : EXIT_FAILURE;
d1559 1
a1559 1
	return moduser(argv[optind], argv[optind], (user_t *) NULL) ? EXIT_SUCCESS : EXIT_FAILURE;
d1596 3
a1598 1
	if (argc == optind) {
d1605 1
a1605 1
	if (!dupgid && getgrgid((gid_t) gid) != (struct group *) NULL) {
d1608 2
a1609 2
	if (!valid_group(argv[optind])) {
		warnx("warning - invalid group name `%s'", argv[optind]);
d1611 3
a1613 2
	if (!creategid(argv[optind], gid)) {
		err(EXIT_FAILURE, "can't add group: problems with %s file", _PATH_GROUP);
d1639 3
a1641 1
	if (argc == optind) {
d1645 1
a1645 1
	if (!modify_gid(argv[optind], NULL)) {
d1662 1
a1662 1
	char		buf[MaxEntryLen];
d1694 3
a1696 1
	if (argc == optind) {
d1706 2
a1707 2
	if ((grp = getgrnam(argv[optind])) == (struct group *) NULL) {
		err(EXIT_FAILURE, "can't find group `%s' to modify", argv[optind]);
d1713 1
a1713 2
			(newname) ? newname : grp->gr_name,
			grp->gr_passwd,
d1719 6
a1724 2
	cc += snprintf(&buf[cc], sizeof(buf) - cc, "\n");
	if (!modify_gid(argv[optind], buf)) {
a1725 1
	}
a1735 1
	char		buf[MaxEntryLen];
a1737 1
	int		cc;
d1751 3
a1753 1
	if (argc == optind) {
d1756 1
a1756 1
	pwp = find_user_info(argv[optind]);
d1760 2
a1761 2
	if (pwp == (struct passwd *) NULL) {
		errx(EXIT_FAILURE, "can't find user `%s'", argv[optind]);
d1766 5
a1770 1
	for (cc = 0 ; (grp = getgrent()) != (struct group *) NULL ; ) {
d1772 2
a1773 3
			if (strcmp(*cpp, argv[optind]) == 0 && grp->gr_gid != pwp->pw_gid) {
				cc += snprintf(&buf[cc], sizeof(buf) - cc, "%s ", grp->gr_name);
			}
d1776 3
a1778 6
	if ((grp = getgrgid(pwp->pw_gid)) == (struct group *) NULL) {
		(void) printf("groups\t%d %s\n", pwp->pw_gid, buf);
	} else {
		(void) printf("groups\t%s %s\n", grp->gr_name, buf);
	}
	(void) printf("change\t%s", ctime(&pwp->pw_change));
d1780 1
d1784 1
a1784 1
	(void) printf("expire\t%s", ctime(&pwp->pw_expire));
d1810 3
a1812 1
	if (argc == optind) {
d1815 1
a1815 1
	grp = find_group_info(argv[optind]);
d1819 2
a1820 2
	if (grp == (struct group *) NULL) {
		errx(EXIT_FAILURE, "can't find group `%s'", argv[optind]);
@


1.23
log
@cleanup error message
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.22 2001/03/24 19:24:07 jakob Exp $ */
d857 1
a857 1
	if (pw_mkdb(login) < 0) {
d1028 1
a1028 1
		cc = pw_mkdb(login);
d1030 1
a1030 1
		cc = pw_mkdb(NULL);
@


1.22
log
@fix usage when called as invalid binary name; <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.21 2001/03/24 19:21:33 jakob Exp $ */
d1119 1
a1119 1
		(void) fprintf(stderr, "This program must be called as user{info,mod,del} or group{info,mod,del},\n%s is not an understood name.\n", prog);
@


1.21
log
@fix multiple UID ranges; <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.20 2001/03/24 19:20:51 jakob Exp $ */
d1118 2
@


1.20
log
@fix strlcpy; <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.19 2001/02/13 09:18:33 deraadt Exp $ */
d530 1
a530 1
		for (i = 0 ; i < up->u_rc ; i++) {
d609 1
@


1.19
log
@rely on constants; ianm@@cit.uws.edu.au
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.18 2000/11/26 01:29:42 millert Exp $ */
d1148 1
a1148 1
		        strlcpy (buf, optarg, strlen (optarg) + 1);
d1267 1
a1267 1
		        strlcpy (buf, optarg, strlen (optarg) + 1);
@


1.18
log
@Update for pw_mkdb(3) interface change.  All but vipw and userdel can
specify a username (and thus avoid rebuilding the while database).
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.17 2000/07/15 08:31:54 ho Exp $ */
d135 1
a135 2
	MaxUserNameLen = 32,
	MaxFieldNameLen = 32,
@


1.17
log
@When modifying users and not specifying a new GID, don't arbitrarily
reset it to the default GID, keep the old one.
Further, when given a new home dir, actually use it.
Fixes PR #1318.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.16 2000/07/06 09:23:30 ho Exp $ */
d857 1
a857 1
	if (pw_mkdb() < 0) {
d1027 5
a1031 1
	if (pw_mkdb() < 0) {
@


1.16
log
@Don't write password lines longer than 1023 chars.
Change two instances of err() to errx().
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.15 2000/06/16 07:17:39 ho Exp $ */
d914 4
a917 2
		/* if -g=uid was specified, check gid is unused */
		if (strcmp(up->u_primgrp, "=uid") == 0) {
d943 2
d1258 2
@


1.15
log
@Fix PR 1279.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.14 2000/06/09 16:34:24 millert Exp $ */
d820 1
a820 1
	if (cc > MaxPasswordEntryLen ||
d822 1
a822 1
	     cc + strlen(login) > MaxPasswordEntryLen)) {
d825 1
a825 1
		err(EXIT_FAILURE, "can't add `%s', line too long", buf);
d984 1
a984 1
				if (cc > MaxPasswordEntryLen ||
d986 1
a986 1
				     cc + strlen(newlogin) > MaxPasswordEntryLen)) {
d989 1
a989 1
					err(EXIT_FAILURE, "can't add `%s', line too long", buf);
@


1.14
log
@chown has moved to /sbin
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.13 2000/05/05 23:54:51 ho Exp $ */
d940 1
a940 1
			(void) strlcpy(home, pwp->pw_dir, strlen(home));
@


1.13
log
@Forgot to update usage().
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.12 2000/05/05 23:22:39 ho Exp $ */
d147 1
a147 1
#define CHOWN		"/usr/sbin/chown"
@


1.13.2.1
log
@Pull in patch from current:
Errata:
user mod -G www pete #blows away home dir in /etc/passwd
Fix (ho):
Fix PR 1279
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.15 2000/06/16 07:17:39 ho Exp $ */
d940 1
a940 1
			(void) strlcpy(home, pwp->pw_dir, sizeof(home));
@


1.13.2.2
log
@Pull in patch from current:
Fix (ho):
Don't write password lines longer than 1023 chars.
Change two instances of err() to errx().
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.13.2.1 2000/06/18 03:40:12 jason Exp $ */
d820 1
a820 1
	if (cc >= MaxPasswordEntryLen ||
d822 1
a822 1
	     cc + strlen(login) >= MaxPasswordEntryLen)) {
d825 1
a825 1
		errx(EXIT_FAILURE, "can't add `%s', line too long", buf);
d984 1
a984 1
				if (cc >= MaxPasswordEntryLen ||
d986 1
a986 1
				     cc + strlen(newlogin) >= MaxPasswordEntryLen)) {
d989 1
a989 1
					errx(EXIT_FAILURE, "can't add `%s', line too long (%d bytes)", buf, cc + strlen(newlogin));
@


1.13.2.3
log
@Pull in change from current:
Fix (ho):
When modifying users and not specifying a new GID, don't arbitrarily
reset it to the default GID, keep the old one.
Further, when given a new home dir, actually use it.
Fixes PR #1318.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.13.2.2 2000/07/12 13:55:23 jason Exp $ */
d914 2
a915 4
		if (up->u_primgrp == NULL) {
			gid = pwp->pw_gid;
		} else if (strcmp(up->u_primgrp, "=uid") == 0) {
		  	/* if -g=uid was specified, check gid is unused */
a940 2
		} else {
		  	(void) strlcpy(home, up->u_home, sizeof(home));
a1253 2
	free(u.u_primgrp);
	u.u_primgrp = NULL;
@


1.12
log
@Make -G flag work for user{add,mod}.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.11 2000/05/05 12:33:51 jakob Exp $ */
d1072 6
a1077 5
		(void) fprintf(stderr, "usage: %s [-G group] [-b basedir] "
		    "[-c comment] [-d homedir] [-e expiry]\n\t\t[-f inactive] "
		    "[-g group] [-k skeletondir] [-m] [-o]\n\t\t[-p password] "
		    "[-r lowuid..highuid] [-s shell] [-u uid]\n\t\t[-v] user\n",
		    prog);
d1079 4
a1082 4
		(void) fprintf(stderr, "usage: %s [-G group] [-c comment] "
		    "[-d homedir] [-e expire] [-f inactive]\n\t\t[-g group] "
		    "[-l newname] [-m] [-o] [-p password]\n\t\t[-s shell] "
		    "[-u uid] [-v] user\n", prog);
@


1.11
log
@limit size of a password file entry (including &-expansion)
replace a couple of strcpy with strlcpy
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.10 2000/05/04 22:56:52 jakob Exp $ */
d372 102
d847 9
d952 1
a952 1
		    strlen(up->u_password) == PasswordLength) {
d996 11
d1128 1
d1140 8
a1147 1
			memsave(&u.u_groupv[u.u_groupc++], optarg, strlen(optarg));
d1247 1
d1257 8
a1264 1
			memsave(&u.u_groupv[u.u_groupc++], optarg, strlen(optarg));
d1317 2
a1318 1
	return moduser(argv[optind], (have_new_user) ? newuser : argv[optind], &u) ? EXIT_SUCCESS : EXIT_FAILURE;
@


1.10
log
@use _PASSWORD_LEN constant
adduser(); correct sync_uid_gid handling
adduser(); initialize password correctly
copydotfiles(); run chmod properly
creategid(); cleanup
groupmod(); add missing newline
moduser(); do not overwrite shell with gecos
moduser(); initialize password correctly
read_defaults(); read default password from usermgmt.conf
userdel(); initialize password correctly

ok deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.9 2000/04/26 06:27:57 jakob Exp $ */
d139 1
d718 7
d798 1
a798 1
			(void) strcpy(oldhome, pwp->pw_dir);
d829 1
a829 1
			(void) strcpy(home, pwp->pw_dir);
d873 7
@


1.9
log
@make usage readable on a console; eric jackson <shinobi@@monkey.org>
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.8 2000/04/24 23:11:14 jakob Exp $ */
d139 1
a139 1
	PasswordLength = 13,
d240 1
a240 1
	(void) asystem("%s -R -h %d:%d %s", CHOWN, uid, gid, dir);
d246 1
a246 1
creategid(char *group, int gid, char *name)
d261 1
a261 1
		warn("can't create gid for %s: can't open %s", name, _PATH_GROUP);
d290 1
a290 1
	(void) fprintf(to, "%s:*:%d:%s\n", group, gid, name);
d534 4
a696 1
	password[PasswordLength] = '\0';
d698 2
a699 2
	    strlen(up->u_password) == PasswordLength) {
		(void) memcpy(password, up->u_password, PasswordLength);
d701 1
a701 1
		(void) memset(password, '*', PasswordLength);
d730 1
a730 1
	if (strcmp(up->u_primgrp, "=uid") == 0 &&
d732 1
a732 1
	    !creategid(login, gid, login)) {
a831 1
		password[PasswordLength] = '\0';
d834 1
a834 1
			(void) memcpy(password, up->u_password, PasswordLength);
d836 1
a836 1
			(void) memcpy(password, pwp->pw_passwd, PasswordLength);
d842 1
a842 1
			memsave(&up->u_comment, pwp->pw_shell, strlen(pwp->pw_shell));
d1240 1
a1240 2
		(void) memset(password, '*', PasswordLength);
		password[PasswordLength] = '\0';
d1294 1
a1294 1
	if (!creategid(argv[optind], gid, "")) {
d1398 1
@


1.8
log
@default to non-verbose (previously undefined)
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.7 2000/04/24 22:59:25 jakob Exp $ */
d930 7
a936 7
		(void) fprintf(stderr, "Usage: %s -D [-b basedir] [-e expiry] "
		    "[-f inactive] [-g group] [-r lowuid..highuid] [-s shell]"
		    "\n", prog);
		(void) fprintf(stderr, "Usage: %s [-G group] [-b basedir] "
		    "[-c comment] [-d homedir] [-e expiry] [-f inactive]\n"
		    "\t[-g group] [-k skeletondir] [-m] [-o] [-p password] "
		    "[-r lowuid..highuid] [-s shell]\n\t[-u uid] [-v] user\n",
d939 4
a942 4
		(void) fprintf(stderr, "Usage: %s [-G group] [-c comment] "
		    "[-d homedir] [-e expire] [-f inactive] [-g group] "
		    "[-l newname] [-m] [-o] [-p password] [-s shell] [-u uid] "
		    "[-v] user\n", prog);
d944 2
a945 2
		(void) fprintf(stderr, "Usage: %s -D [-p preserve]\n", prog);
		(void) fprintf(stderr, "Usage: %s [-p preserve] [-r] [-v] "
d949 1
a949 1
		(void) fprintf(stderr, "Usage: %s [-e] [-v] user\n", prog);
d952 1
a952 1
		(void) fprintf(stderr, "Usage: %s [-g gid] [-o] [-v] group\n",
d955 1
a955 1
		(void) fprintf(stderr, "Usage: %s [-v] group\n", prog);
d957 1
a957 1
		(void) fprintf(stderr, "Usage: %s [-g gid] [-o] [-n newname] "
d960 1
a960 1
		(void) fprintf(stderr, "Usage: %s ( add | del | mod "
d964 1
a964 1
		") ...\n",
d968 1
a968 1
		(void) fprintf(stderr, "Usage: %s [-e] [-v] group\n", prog);
@


1.7
log
@include cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.6 2000/04/24 22:52:36 jakob Exp $ */
d155 1
a155 1
static int	verbose;
@


1.6
log
@use _PATH_MASTERPASSWD & _PATH_GROUP
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.5 2000/04/24 22:40:11 jakob Exp $ */
a34 2
#include <sys/cdefs.h>
#include <sys/types.h>
@


1.5
log
@fix usage when building with EXTENSIONS
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.4 2000/04/24 22:38:31 jakob Exp $ */
a124 8
#ifndef MASTER
#define MASTER		"/etc/master.passwd"
#endif

#ifndef ETCGROUP
#define ETCGROUP	"/etc/group"
#endif

d262 2
a263 2
	if ((from = fopen(ETCGROUP, "r")) == (FILE *) NULL) {
		warn("can't create gid for %s: can't open %s", name, ETCGROUP);
d267 1
a267 1
		warn("can't lock `%s'", ETCGROUP);
d270 1
a270 1
	(void) snprintf(f, sizeof(f), "%s.XXXXXX", ETCGROUP);
d295 2
a296 2
	if (rename(f, ETCGROUP) < 0) {
		warn("can't create gid: can't rename `%s' to `%s'", f, ETCGROUP);
d299 1
a299 1
	(void) chmod(ETCGROUP, st.st_mode & 07777);
d318 2
a319 2
	if ((from = fopen(ETCGROUP, "r")) == (FILE *) NULL) {
		warn("can't create gid for %s: can't open %s", group, ETCGROUP);
d323 1
a323 1
		warn("can't lock `%s'", ETCGROUP);
d326 1
a326 1
	(void) snprintf(f, sizeof(f), "%s.XXXXXX", ETCGROUP);
d365 2
a366 2
	if (rename(f, ETCGROUP) < 0) {
		warn("can't create gid: can't rename `%s' to `%s'", f, ETCGROUP);
d369 1
a369 1
	(void) chmod(ETCGROUP, st.st_mode & 07777);
d617 2
a618 2
	if ((masterfd = open(MASTER, O_RDONLY)) < 0) {
		err(EXIT_FAILURE, "can't open `%s'", MASTER);
d621 1
a621 1
		err(EXIT_FAILURE, "can't lock `%s'", MASTER);
d770 2
a771 2
	if ((masterfd = open(MASTER, O_RDONLY)) < 0) {
		err(EXIT_FAILURE, "can't open `%s'", MASTER);
d774 1
a774 1
		err(EXIT_FAILURE, "can't lock `%s'", MASTER);
d785 1
a785 1
		err(EXIT_FAILURE, "can't fdopen fd for %s", MASTER);
d1296 1
a1296 1
		err(EXIT_FAILURE, "can't add group: problems with %s file", ETCGROUP);
d1327 1
a1327 1
		err(EXIT_FAILURE, "can't change %s file", ETCGROUP);
d1400 1
a1400 1
		err(EXIT_FAILURE, "can't change %s file", ETCGROUP);
@


1.4
log
@is_number() is needed even without EXTENSIONS defined
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.3 2000/04/24 22:37:15 jakob Exp $ */
d199 1
d970 5
a974 1
		(void) fprintf(stderr, "Usage: %s ( add | del | mod ) ...\n",
@


1.3
log
@remove lint stuff. remove unneeded strlcpy.
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.2 2000/04/24 22:31:29 jakob Exp $ */
a198 1
#ifdef EXTENSIONS
a209 1
#endif
@


1.2
log
@id-tags
@
text
@d1 1
a1 1
/* $OpenBSD: user.c,v 1.17 2000/04/14 06:26:55 simonb Exp $ */
d34 1
a35 8

#ifndef lint
__COPYRIGHT(
	"@@(#) Copyright (c) 1999 \
	        The NetBSD Foundation, Inc.  All rights reserved.");
__RCSID("$NetBSD: user.c,v 1.17 2000/04/14 06:26:55 simonb Exp $");
#endif

a197 18

#define NetBSD_1_4_K	104110000

#if defined(__NetBSD_Version__) && (__NetBSD_Version__ < NetBSD_1_4_K)
/* bounds checking strncpy */
static int
strlcpy(char *to, char *from, size_t tosize)
{
	size_t	n;
	int	fromsize;

	fromsize = strlen(from);
	n = MIN(tosize - 1, fromsize);
	(void) memcpy(to, from, n);
	to[n] = '\0';
	return fromsize;
}
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Initial import of user/group management tools from NetBSD.
@
text
@@
