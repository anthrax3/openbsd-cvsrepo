head	1.154;
access;
symbols
	OPENBSD_6_1:1.154.0.2
	OPENBSD_6_1_BASE:1.154
	OPENBSD_6_0:1.153.0.2
	OPENBSD_6_0_BASE:1.153
	OPENBSD_5_9:1.150.0.2
	OPENBSD_5_9_BASE:1.150
	OPENBSD_5_8:1.143.0.6
	OPENBSD_5_8_BASE:1.143
	OPENBSD_5_7:1.143.0.2
	OPENBSD_5_7_BASE:1.143
	OPENBSD_5_6:1.138.0.4
	OPENBSD_5_6_BASE:1.138
	OPENBSD_5_5:1.137.0.4
	OPENBSD_5_5_BASE:1.137
	OPENBSD_5_4:1.135.0.2
	OPENBSD_5_4_BASE:1.135
	OPENBSD_5_3:1.133.0.4
	OPENBSD_5_3_BASE:1.133
	OPENBSD_5_2:1.133.0.2
	OPENBSD_5_2_BASE:1.133
	OPENBSD_5_1_BASE:1.132
	OPENBSD_5_1:1.132.0.10
	OPENBSD_5_0:1.132.0.8
	OPENBSD_5_0_BASE:1.132
	OPENBSD_4_9:1.132.0.6
	OPENBSD_4_9_BASE:1.132
	OPENBSD_4_8:1.132.0.4
	OPENBSD_4_8_BASE:1.132
	OPENBSD_4_7:1.132.0.2
	OPENBSD_4_7_BASE:1.132
	OPENBSD_4_6:1.130.0.8
	OPENBSD_4_6_BASE:1.130
	OPENBSD_4_5:1.130.0.4
	OPENBSD_4_5_BASE:1.130
	OPENBSD_4_4:1.130.0.2
	OPENBSD_4_4_BASE:1.130
	OPENBSD_4_3:1.126.0.2
	OPENBSD_4_3_BASE:1.126
	OPENBSD_4_2:1.123.0.10
	OPENBSD_4_2_BASE:1.123
	OPENBSD_4_1:1.123.0.8
	OPENBSD_4_1_BASE:1.123
	OPENBSD_4_0:1.123.0.6
	OPENBSD_4_0_BASE:1.123
	OPENBSD_3_9:1.123.0.4
	OPENBSD_3_9_BASE:1.123
	OPENBSD_3_8:1.123.0.2
	OPENBSD_3_8_BASE:1.123
	OPENBSD_3_7:1.122.0.2
	OPENBSD_3_7_BASE:1.122
	OPENBSD_3_6:1.120.0.2
	OPENBSD_3_6_BASE:1.120
	OPENBSD_3_5:1.115.0.2
	OPENBSD_3_5_BASE:1.115
	OPENBSD_3_4:1.111.0.2
	OPENBSD_3_4_BASE:1.111
	OPENBSD_3_3:1.108.0.2
	OPENBSD_3_3_BASE:1.108
	OPENBSD_3_2:1.107.0.2
	OPENBSD_3_2_BASE:1.107
	OPENBSD_3_1:1.89.0.2
	OPENBSD_3_1_BASE:1.89
	OPENBSD_3_0:1.85.0.2
	OPENBSD_3_0_BASE:1.85
	OPENBSD_2_9_BASE:1.82
	OPENBSD_2_9:1.82.0.2
	OPENBSD_2_8:1.69.0.2
	OPENBSD_2_8_BASE:1.69
	OPENBSD_2_7:1.61.0.2
	OPENBSD_2_7_BASE:1.61
	OPENBSD_2_6:1.56.0.4
	OPENBSD_2_6_BASE:1.56
	OPENBSD_2_5:1.56.0.2
	OPENBSD_2_5_BASE:1.56
	OPENBSD_2_4:1.49.0.2
	OPENBSD_2_4_BASE:1.49
	OPENBSD_2_3:1.46.0.2
	OPENBSD_2_3_BASE:1.46
	OPENBSD_2_2:1.40.0.2
	OPENBSD_2_2_BASE:1.40
	OPENBSD_2_1:1.25.0.2
	OPENBSD_2_1_BASE:1.25
	OPENBSD_2_0:1.21.0.2
	OPENBSD_2_0_BASE:1.21
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.154
date	2016.08.25.05.23.19;	author tedu;	state Exp;
branches;
next	1.153;
commitid	gKmvHavAABLOB3Iz;

1.153
date	2016.03.16.20.16.39;	author mestre;	state Exp;
branches;
next	1.152;
commitid	q0Ftn0qhntMxCShu;

1.152
date	2016.03.16.20.15.15;	author mestre;	state Exp;
branches;
next	1.151;
commitid	Tcr3ZBUE7N8hLmgR;

1.151
date	2016.03.16.20.09.58;	author mestre;	state Exp;
branches;
next	1.150;
commitid	nmQKvyNFA0Dk1SKu;

1.150
date	2015.12.22.19.44.01;	author mmcc;	state Exp;
branches;
next	1.149;
commitid	urXhg4Nyq7zqdNzr;

1.149
date	2015.11.01.19.59.28;	author deraadt;	state Exp;
branches;
next	1.148;
commitid	H5Lkno2CjqB1g0BF;

1.148
date	2015.11.01.00.31.18;	author deraadt;	state Exp;
branches;
next	1.147;
commitid	6wzhIWde7EvekoPq;

1.147
date	2015.10.22.12.34.25;	author deraadt;	state Exp;
branches;
next	1.146;
commitid	stdwrFXvptO3TBnV;

1.146
date	2015.10.19.11.52.51;	author jca;	state Exp;
branches;
next	1.145;
commitid	NZWyIGGON3T2Fd9g;

1.145
date	2015.10.19.11.51.17;	author jca;	state Exp;
branches;
next	1.144;
commitid	bCf2p6gOq6v1Io8O;

1.144
date	2015.10.18.16.11.19;	author jca;	state Exp;
branches;
next	1.143;
commitid	RGlNoeYMkMK64sP4;

1.143
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.142;
commitid	Uu5nFG3wCl0LACBb;

1.142
date	2014.10.29.03.33.14;	author dlg;	state Exp;
branches;
next	1.141;
commitid	tGTDAuZ2dIHmMbXV;

1.141
date	2014.10.13.01.53.14;	author dlg;	state Exp;
branches;
next	1.140;
commitid	HSdHjglS3sp8XPoi;

1.140
date	2014.10.12.09.36.42;	author dlg;	state Exp;
branches;
next	1.139;
commitid	MmEke9HFI3zYlKBh;

1.139
date	2014.10.12.08.55.25;	author dlg;	state Exp;
branches;
next	1.138;
commitid	yKNUOmEgf7Q5Whgg;

1.138
date	2014.06.17.03.12.37;	author lteo;	state Exp;
branches;
next	1.137;
commitid	tH0vR36MDUIEgOYq;

1.137
date	2013.11.23.17.24.29;	author deraadt;	state Exp;
branches;
next	1.136;

1.136
date	2013.11.12.19.44.44;	author deraadt;	state Exp;
branches;
next	1.135;

1.135
date	2013.04.19.18.03.16;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.133;

1.133
date	2012.04.19.14.33.24;	author gsoares;	state Exp;
branches;
next	1.132;

1.132
date	2009.11.02.20.03.01;	author otto;	state Exp;
branches;
next	1.131;

1.131
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2008.07.28.15.42.07;	author claudio;	state Exp;
branches;
next	1.129;

1.129
date	2008.07.27.10.06.10;	author claudio;	state Exp;
branches;
next	1.128;

1.128
date	2008.06.28.10.54.45;	author sobrado;	state Exp;
branches;
next	1.127;

1.127
date	2008.06.04.18.11.35;	author miod;	state Exp;
branches;
next	1.126;

1.126
date	2008.01.25.13.52.20;	author espie;	state Exp;
branches;
next	1.125;

1.125
date	2008.01.05.09.53.42;	author jmc;	state Exp;
branches;
next	1.124;

1.124
date	2007.09.11.16.30.59;	author gilles;	state Exp;
branches;
next	1.123;

1.123
date	2005.04.02.18.10.52;	author otto;	state Exp;
branches;
next	1.122;

1.122
date	2004.09.15.08.46.00;	author otto;	state Exp;
branches;
next	1.121;

1.121
date	2004.09.14.22.28.41;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	2004.09.06.07.03.08;	author otto;	state Exp;
branches;
next	1.119;

1.119
date	2004.07.28.13.08.19;	author millert;	state Exp;
branches;
next	1.118;

1.118
date	2004.06.30.07.58.12;	author otto;	state Exp;
branches;
next	1.117;

1.117
date	2004.04.24.21.40.35;	author millert;	state Exp;
branches;
next	1.116;

1.116
date	2004.03.31.19.12.22;	author millert;	state Exp;
branches;
next	1.115;

1.115
date	2004.01.06.19.45.54;	author millert;	state Exp;
branches;
next	1.114;

1.114
date	2003.12.23.15.24.28;	author mpech;	state Exp;
branches;
next	1.113;

1.113
date	2003.10.24.20.30.02;	author avsm;	state Exp;
branches;
next	1.112;

1.112
date	2003.10.03.22.43.37;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2003.06.26.19.47.08;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2003.06.02.23.36.53;	author millert;	state Exp;
branches;
next	1.109;

1.109
date	2003.04.28.02.58.45;	author itojun;	state Exp;
branches;
next	1.108;

1.108
date	2002.11.11.23.46.29;	author millert;	state Exp;
branches;
next	1.107;

1.107
date	2002.09.06.19.46.52;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2002.07.20.18.01.18;	author deraadt;	state Exp;
branches;
next	1.105;

1.105
date	2002.07.15.23.05.17;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2002.07.15.22.26.31;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2002.07.04.12.36.56;	author itojun;	state Exp;
branches;
next	1.102;

1.102
date	2002.06.28.22.41.10;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2002.06.21.07.30.09;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2002.06.21.06.20.28;	author millert;	state Exp;
branches;
next	1.99;

1.99
date	2002.06.07.07.37.41;	author itojun;	state Exp;
branches;
next	1.98;

1.98
date	2002.06.01.03.42.06;	author itojun;	state Exp;
branches;
next	1.97;

1.97
date	2002.06.01.01.57.44;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2002.05.31.23.48.41;	author itojun;	state Exp;
branches;
next	1.95;

1.95
date	2002.05.31.22.20.18;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2002.05.31.20.20.53;	author itojun;	state Exp;
branches;
next	1.93;

1.93
date	2002.05.30.19.09.05;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2002.05.29.19.23.34;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2002.05.26.09.25.21;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2002.05.22.09.09.32;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.88;

1.88
date	2002.02.16.21.28.03;	author millert;	state Exp;
branches;
next	1.87;

1.87
date	2002.02.10.01.19.02;	author millert;	state Exp;
branches;
next	1.86;

1.86
date	2001.11.05.09.43.50;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2001.09.04.23.35.59;	author millert;	state Exp;
branches;
next	1.84;

1.84
date	2001.09.03.21.22.38;	author pjanzen;	state Exp;
branches;
next	1.83;

1.83
date	2001.07.04.06.46.58;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2001.03.15.18.28.41;	author danh;	state Exp;
branches
	1.82.2.1;
next	1.81;

1.81
date	2001.03.15.18.07.57;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2001.03.15.17.53.09;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2001.01.30.08.30.57;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2001.01.29.21.08.11;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2001.01.29.21.07.36;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2001.01.29.21.06.43;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2001.01.29.11.23.28;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2001.01.17.19.30.03;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2001.01.16.23.57.37;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2001.01.12.16.34.03;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2000.11.21.07.23.24;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2000.11.09.02.55.42;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2000.08.22.14.47.54;	author millert;	state Exp;
branches;
next	1.68;

1.68
date	2000.08.20.18.42.42;	author millert;	state Exp;
branches;
next	1.67;

1.67
date	2000.08.03.11.33.37;	author itojun;	state Exp;
branches;
next	1.66;

1.66
date	2000.08.01.19.05.23;	author itojun;	state Exp;
branches;
next	1.65;

1.65
date	2000.08.01.19.02.05;	author itojun;	state Exp;
branches;
next	1.64;

1.64
date	2000.08.01.18.52.50;	author itojun;	state Exp;
branches;
next	1.63;

1.63
date	2000.07.08.01.57.27;	author itojun;	state Exp;
branches;
next	1.62;

1.62
date	2000.06.19.01.28.45;	author itojun;	state Exp;
branches;
next	1.61;

1.61
date	2000.03.04.01.10.06;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2000.02.01.03.23.58;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	99.12.10.16.19.29;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	99.12.10.10.28.40;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	99.12.08.13.21.17;	author itojun;	state Exp;
branches;
next	1.56;

1.56
date	99.02.24.12.31.30;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	99.01.04.12.03.08;	author niklas;	state Exp;
branches;
next	1.54;

1.54
date	98.12.04.07.52.02;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	98.11.21.00.15.58;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	98.11.19.06.34.03;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	98.11.18.23.25.35;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	98.10.28.18.01.17;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	98.07.15.17.51.14;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	98.07.13.02.11.48;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	98.06.03.08.06.01;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	98.03.12.00.19.16;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	98.02.24.20.21.32;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	97.12.23.23.46.16;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	97.12.04.21.35.29;	author art;	state Exp;
branches;
next	1.42;

1.42
date	97.11.14.03.46.00;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	97.11.14.03.40.02;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	97.09.19.12.21.27;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	97.08.31.18.04.37;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	97.08.29.17.07.04;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	97.08.04.19.26.10;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	97.07.22.21.12.28;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	97.07.08.20.37.30;	author kstailey;	state Exp;
branches;
next	1.34;

1.34
date	97.07.08.20.31.14;	author kstailey;	state Exp;
branches;
next	1.33;

1.33
date	97.06.26.17.31.22;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	97.06.26.06.26.15;	author denny;	state Exp;
branches;
next	1.31;

1.31
date	97.06.23.09.37.37;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	97.06.23.09.35.04;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	97.06.17.05.41.19;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	97.06.17.05.26.22;	author denny;	state Exp;
branches;
next	1.27;

1.27
date	97.06.04.11.07.05;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	97.06.04.11.03.15;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	97.02.24.12.48.06;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	97.01.15.23.43.59;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	96.12.14.19.19.09;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	96.12.11.09.05.05;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	96.08.31.17.31.05;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	96.08.28.09.55.00;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	96.08.16.08.32.54;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	96.08.11.23.24.25;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	96.08.02.07.18.35;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.08.02.06.47.41;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.08.02.06.13.26;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.07.31.11.01.54;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.07.29.23.45.34;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.07.29.09.14.55;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.07.29.09.13.31;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.07.29.07.53.07;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.07.29.03.43.54;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.07.28.05.54.41;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.07.28.05.13.19;	author joshd;	state Exp;
branches;
next	1.6;

1.6
date	96.06.29.01.02.24;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.06.28.17.50.09;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.12.07.23.26;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.13.16.00.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.24;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.36;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.36;	author deraadt;	state Exp;
branches;
next	;

1.82.2.1
date	2001.07.17.04.13.48;	author jason;	state Exp;
branches;
next	;


desc
@@


1.154
log
@remove lint comments
@
text
@/*	$OpenBSD: inetd.c,v 1.153 2016/03/16 20:16:39 mestre Exp $	*/

/*
 * Copyright (c) 1983,1991 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Inetd - Internet super-server
 *
 * This program invokes all internet services as needed.
 * connection-oriented services are invoked each time a
 * connection is made, by creating a process.  This process
 * is passed the connection as file descriptor 0 and is
 * expected to do a getpeername to find out the source host
 * and port.
 *
 * Datagram oriented services are invoked when a datagram
 * arrives; a process is created and passed a pending message
 * on file descriptor 0.  Datagram servers may either connect
 * to their peer, freeing up the original socket for inetd
 * to receive further messages on, or ``take over the socket'',
 * processing all arriving datagrams and, eventually, timing
 * out.	 The first type of server is said to be ``multi-threaded'';
 * the second type of server ``single-threaded''.
 *
 * Inetd uses a configuration file which is read at startup
 * and, possibly, at some later time in response to a hangup signal.
 * The configuration file is ``free format'' with fields given in the
 * order shown below.  Continuation lines for an entry must begin with
 * a space or tab.  All fields must be present in each entry.
 *
 *	service name			must be in /etc/services
 *	socket type			stream/dgram/raw/rdm/seqpacket
 *	protocol			must be in /etc/protocols
 *	wait/nowait[.max]		single-threaded/multi-threaded, max #
 *	user[.group] or user[:group]	user/group to run daemon as
 *	server program			full path name
 *	server program arguments	maximum of MAXARGS (20)
 *
 * For RPC services
 *      service name/version            must be in /etc/rpc
 *	socket type			stream/dgram/raw/rdm/seqpacket
 *	protocol			must be in /etc/protocols
 *	wait/nowait[.max]		single-threaded/multi-threaded
 *	user[.group] or user[:group]	user to run daemon as
 *	server program			full path name
 *	server program arguments	maximum of MAXARGS (20)
 *
 * For non-RPC services, the "service name" can be of the form
 * hostaddress:servicename, in which case the hostaddress is used
 * as the host portion of the address to listen on.  If hostaddress
 * consists of a single `*' character, INADDR_ANY is used.
 *
 * A line can also consist of just
 *      hostaddress:
 * where hostaddress is as in the preceding paragraph.  Such a line must
 * have no further fields; the specified hostaddress is remembered and
 * used for all further lines that have no hostaddress specified,
 * until the next such line (or EOF).  (This is why * is provided to
 * allow explicit specification of INADDR_ANY.)  A line
 *      *:
 * is implicitly in effect at the beginning of the file.
 *
 * The hostaddress specifier may (and often will) contain dots;
 * the service name must not.
 *
 * For RPC services, host-address specifiers are accepted and will
 * work to some extent; however, because of limitations in the
 * portmapper interface, it will not work to try to give more than
 * one line for any given RPC service, even if the host-address
 * specifiers are different.
 *
 * Comment lines are indicated by a `#' in column 1.
 */

/*
 * Here's the scoop concerning the user[.:]group feature:
 *
 * 1) set-group-option off.
 *
 *	a) user = root:	NO setuid() or setgid() is done
 *
 *	b) other:	setgid(primary group as found in passwd)
 *			initgroups(name, primary group)
 *			setuid()
 *
 * 2) set-group-option on.
 *
 *	a) user = root:	setgid(specified group)
 *			NO initgroups()
 *			NO setuid()
 *
 *	b) other:	setgid(specified group)
 *			initgroups(name, specified group)
 *			setuid()
 *
 */

#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/file.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/resource.h>

#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <ctype.h>
#include <signal.h>
#include <netdb.h>
#include <syslog.h>
#include <pwd.h>
#include <grp.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <string.h>
#include <login_cap.h>
#include <ifaddrs.h>
#include <rpc/rpc.h>
#include <rpc/pmap_clnt.h>
#include <rpcsvc/nfs_prot.h>
#include <event.h>
#include "pathnames.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

#define	TOOMANY		256		/* don't start more than TOOMANY */
#define	CNT_INTVL	60		/* servers in CNT_INTVL sec. */
#define	RETRYTIME	(60*10)		/* retry after bind or server fail */

int	 debug = 0;
int	 maxsock;
int	 toomany = TOOMANY;
int	 timingout;
struct	 servent *sp;
uid_t	 uid;

#ifndef OPEN_MAX
#define OPEN_MAX	64
#endif

/* Reserve some descriptors, 3 stdio + at least: 1 log, 1 conf. file */
#define FD_MARGIN	(8)
rlim_t	rlim_nofile_cur = OPEN_MAX;

struct rlimit	rlim_nofile;

struct	servtab {
	char	*se_hostaddr;		/* host address to listen on */
	char	*se_service;		/* name of service */
	int	se_socktype;		/* type of socket to use */
	int	se_family;		/* address family */
	char	*se_proto;		/* protocol used */
	int	se_rpcprog;		/* rpc program number */
	int	se_rpcversl;		/* rpc program lowest version */
	int	se_rpcversh;		/* rpc program highest version */
#define isrpcservice(sep)	((sep)->se_rpcversl != 0)
	pid_t	se_wait;		/* single threaded server */
	short	se_checked;		/* looked at during merge */
	char	*se_user;		/* user name to run as */
	char	*se_group;		/* group name to run as */
	struct	biltin *se_bi;		/* if built-in, description */
	char	*se_server;		/* server program */
#define	MAXARGV 20
	char	*se_argv[MAXARGV+1];	/* program arguments */
	int	se_fd;			/* open descriptor */
	union {
		struct	sockaddr se_un_ctrladdr;
		struct	sockaddr_in se_un_ctrladdr_in;
		struct	sockaddr_in6 se_un_ctrladdr_in6;
		struct	sockaddr_un se_un_ctrladdr_un;
		struct	sockaddr_storage se_un_ctrladdr_storage;
	} se_un;			/* bound address */
#define se_ctrladdr	se_un.se_un_ctrladdr
#define se_ctrladdr_in	se_un.se_un_ctrladdr_in
#define se_ctrladdr_in6	se_un.se_un_ctrladdr_in6
#define se_ctrladdr_un	se_un.se_un_ctrladdr_un
#define se_ctrladdr_storage	se_un.se_un_ctrladdr_storage
	int	se_ctrladdr_size;
	int	se_max;			/* max # of instances of this service */
	int	se_count;		/* number started since se_time */
	struct	timeval se_time;	/* start of se_count */
	struct	servtab *se_next;
	struct	event se_event;
} *servtab;

void echo_stream(int, struct servtab *);
void discard_stream(int, struct servtab *);
void machtime_stream(int, struct servtab *);
void daytime_stream(int, struct servtab *);
void chargen_stream(int, struct servtab *);
void echo_dg(int, struct servtab *);
void discard_dg(int, struct servtab *);
void machtime_dg(int, struct servtab *);
void daytime_dg(int, struct servtab *);
void chargen_dg(int, struct servtab *);

struct biltin {
	char	*bi_service;		/* internally provided service name */
	int	bi_socktype;		/* type of socket supported */
	short	bi_fork;		/* 1 if should fork before call */
	short	bi_wait;		/* 1 if should wait for child */
	void	(*bi_fn)(int, struct servtab *);
} biltins[] = {
	/* Echo received data */
	{ "echo",	SOCK_STREAM,	1, 0,	echo_stream },
	{ "echo",	SOCK_DGRAM,	0, 0,	echo_dg },

	/* Internet /dev/null */
	{ "discard",	SOCK_STREAM,	1, 0,	discard_stream },
	{ "discard",	SOCK_DGRAM,	0, 0,	discard_dg },

	/* Return 32 bit time since 1900 */
	{ "time",	SOCK_STREAM,	0, 0,	machtime_stream },
	{ "time",	SOCK_DGRAM,	0, 0,	machtime_dg },

	/* Return human-readable time */
	{ "daytime",	SOCK_STREAM,	0, 0,	daytime_stream },
	{ "daytime",	SOCK_DGRAM,	0, 0,	daytime_dg },

	/* Familiar character generator */
	{ "chargen",	SOCK_STREAM,	1, 0,	chargen_stream },
	{ "chargen",	SOCK_DGRAM,	0, 0,	chargen_dg },

	{ 0 }
};

struct event evsig_alrm;
struct event evsig_hup;
struct event evsig_chld;
struct event evsig_term;
struct event evsig_int;

void	config(int, short, void *);
void	reap(int, short, void *);
void	retry(int, short, void *);
void	die(int, short, void *);

void	spawn(int, short, void *);
void	gettcp(int, short, void *);
int	setconfig(void);
void	endconfig(void);
void	register_rpc(struct servtab *);
void	unregister_rpc(struct servtab *);
void	freeconfig(struct servtab *);
void	print_service(char *, struct servtab *);
void	setup(struct servtab *);
struct servtab *getconfigent(void);
int	bump_nofile(void);
struct servtab *enter(struct servtab *);
int	matchconf(struct servtab *, struct servtab *);
int	dg_broadcast(struct in_addr *in);

#define NUMINT	(sizeof(intab) / sizeof(struct inent))
char	*CONFIG = _PATH_INETDCONF;

int		dg_badinput(struct sockaddr *sa);
void		inetd_setproctitle(char *a, int s);
void		initring(void);
u_int32_t	machtime(void);

int
main(int argc, char *argv[])
{
	int ch;

	while ((ch = getopt(argc, argv, "dR:")) != -1)
		switch (ch) {
		case 'd':
			debug = 1;
			break;
		case 'R': {	/* invocation rate */
			char *p;
			int val;

			val = strtoul(optarg, &p, 0);
			if (val >= 1 && *p == '\0') {
				toomany = val;
				break;
			}
			syslog(LOG_ERR,
			    "-R %s: bad value for service invocation rate",
			    optarg);
			break;
		}
		case '?':
		default:
			fprintf(stderr,
			    "usage: inetd [-d] [-R rate] [configuration_file]\n");
			exit(1);
		}
	argc -= optind;
	argv += optind;

	uid = getuid();
	if (uid != 0)
		CONFIG = NULL;
	if (argc > 0)
		CONFIG = argv[0];
	if (CONFIG == NULL) {
		fprintf(stderr, "inetd: non-root must specify a config file\n");
		exit(1);
	}
	if (argc > 1) {
		fprintf(stderr, "inetd: more than one argument specified\n");
		exit(1);
	}

	umask(022);
	if (debug == 0) {
		daemon(0, 0);
		if (uid == 0)
			(void) setlogin("");
	}

	if (pledge("stdio rpath cpath getpw dns inet unix proc exec id", NULL) == -1)
		err(1, "pledge");

	if (uid == 0) {
		gid_t gid = getgid();

		/* If run by hand, ensure groups vector gets trashed */
		setgroups(1, &gid);
	}

	openlog("inetd", LOG_PID | LOG_NOWAIT, LOG_DAEMON);

	if (getrlimit(RLIMIT_NOFILE, &rlim_nofile) < 0) {
		syslog(LOG_ERR, "getrlimit: %m");
	} else {
		rlim_nofile_cur = rlim_nofile.rlim_cur;
		if (rlim_nofile_cur == RLIM_INFINITY)	/* ! */
			rlim_nofile_cur = OPEN_MAX;
	}

	event_init();

	signal_set(&evsig_alrm, SIGALRM, retry, NULL);
	signal_add(&evsig_alrm, NULL);

	config(0, 0, NULL);

	signal_set(&evsig_hup, SIGHUP, config, NULL);
	signal_add(&evsig_hup, NULL);
	signal_set(&evsig_chld, SIGCHLD, reap, NULL);
	signal_add(&evsig_chld, NULL);
	signal_set(&evsig_term, SIGTERM, die, NULL);
	signal_add(&evsig_term, NULL);
	signal_set(&evsig_int, SIGINT, die, NULL);
	signal_add(&evsig_int, NULL);

	signal(SIGPIPE, SIG_IGN);

	event_dispatch();

	return (0);
}

void
gettcp(int fd, short events, void *xsep)
{
	struct servtab *sep = xsep;
	int ctrl;

	if (debug)
		fprintf(stderr, "someone wants %s\n", sep->se_service);

	ctrl = accept(sep->se_fd, NULL, NULL);
	if (debug)
		fprintf(stderr, "accept, ctrl %d\n", ctrl);
	if (ctrl < 0) {
		if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
			syslog(LOG_WARNING, "accept (for %s): %m",
			    sep->se_service);
		return;
	}
	if ((sep->se_family == AF_INET || sep->se_family == AF_INET6) &&
	    sep->se_socktype == SOCK_STREAM) {
		struct sockaddr_storage peer;
		socklen_t plen = sizeof(peer);
		char sbuf[NI_MAXSERV];

		if (getpeername(ctrl, (struct sockaddr *)&peer, &plen) < 0) {
			syslog(LOG_WARNING, "could not getpeername");
			close(ctrl);
			return;
		}
		if (getnameinfo((struct sockaddr *)&peer, plen, NULL, 0,
		    sbuf, sizeof(sbuf), NI_NUMERICSERV) == 0 &&
		    strtonum(sbuf, 1, USHRT_MAX, NULL) == 20) {
			/*
			 * ignore things that look like ftp bounce
			 */
			close(ctrl);
			return;
		}
	}

	spawn(ctrl, 0, sep);
}

int
dg_badinput(struct sockaddr *sa)
{
	struct in_addr in;
	struct in6_addr *in6;
	u_int16_t port;

	switch (sa->sa_family) {
	case AF_INET:
		in.s_addr = ntohl(((struct sockaddr_in *)sa)->sin_addr.s_addr);
		port = ntohs(((struct sockaddr_in *)sa)->sin_port);
	v4chk:
		if (IN_MULTICAST(in.s_addr))
			goto bad;
		switch ((in.s_addr & 0xff000000) >> 24) {
		case 0: case 127: case 255:
			goto bad;
		}
		if (dg_broadcast(&in))
			goto bad;
		break;
	case AF_INET6:
		in6 = &((struct sockaddr_in6 *)sa)->sin6_addr;
		port = ntohs(((struct sockaddr_in6 *)sa)->sin6_port);
		if (IN6_IS_ADDR_MULTICAST(in6) || IN6_IS_ADDR_UNSPECIFIED(in6))
			goto bad;
		/*
		 * OpenBSD does not support IPv4 mapped address (RFC2553
		 * inbound behavior) at all.  We should drop it.
		 */
		if (IN6_IS_ADDR_V4MAPPED(in6))
			goto bad;
		if (IN6_IS_ADDR_V4COMPAT(in6)) {
			memcpy(&in, &in6->s6_addr[12], sizeof(in));
			in.s_addr = ntohl(in.s_addr);
			goto v4chk;
		}
		break;
	default:
		/* Unsupported AF */
		goto bad;
	}

	if (port < IPPORT_RESERVED || port == NFS_PORT)
		goto bad;

	return (0);

bad:
	return (1);
}

int
dg_broadcast(struct in_addr *in)
{
	struct ifaddrs *ifa, *ifap;
	struct sockaddr_in *sin;

	if (getifaddrs(&ifap) < 0)
		return (0);
	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family != AF_INET ||
		    (ifa->ifa_flags & IFF_BROADCAST) == 0)
			continue;
		sin = (struct sockaddr_in *)ifa->ifa_broadaddr;
		if (sin->sin_addr.s_addr == in->s_addr) {
			freeifaddrs(ifap);
			return (1);
		}
	}
	freeifaddrs(ifap);
	return (0);
}

void
reap(int sig, short event, void *arg)
{
	struct servtab *sep;
	int status;
	pid_t pid;

	if (debug)
		fprintf(stderr, "reaping asked for\n");

	for (;;) {
		if ((pid = wait3(&status, WNOHANG, NULL)) <= 0) {
			if (pid == -1 && errno == EINTR)
				continue;
			break;
		}
		if (debug)
			fprintf(stderr, "%ld reaped, status %x\n",
			    (long)pid, status);
		for (sep = servtab; sep; sep = sep->se_next)
			if (sep->se_wait == pid) {
				if (WIFEXITED(status) && WEXITSTATUS(status))
					syslog(LOG_WARNING,
					    "%s: exit status %d",
					    sep->se_server, WEXITSTATUS(status));
				else if (WIFSIGNALED(status))
					syslog(LOG_WARNING,
					    "%s: exit signal %d",
					    sep->se_server, WTERMSIG(status));
				sep->se_wait = 1;
				event_add(&sep->se_event, NULL);
				if (debug)
					fprintf(stderr, "restored %s, fd %d\n",
					    sep->se_service, sep->se_fd);
			}
	}
}

void
config(int sig, short event, void *arg)
{
	struct servtab *sep, *cp, **sepp;
	int add;
	char protoname[11];

	if (!setconfig()) {
		syslog(LOG_ERR, "%s: %m", CONFIG);
		exit(1);
	}
	for (sep = servtab; sep; sep = sep->se_next)
		sep->se_checked = 0;
	cp = getconfigent();
	while (cp != NULL) {
		for (sep = servtab; sep; sep = sep->se_next)
			if (matchconf(sep, cp))
				break;
		add = 0;
		if (sep != NULL) {
			int i;

#define SWAP(type, a, b) {type c=(type)a; a=(type)b; b=(type)c;}

			/*
			 * sep->se_wait may be holding the pid of a daemon
			 * that we're waiting for.  If so, don't overwrite
			 * it unless the config file explicitly says don't
			 * wait.
			 */
			if (cp->se_bi == 0 &&
			    (sep->se_wait == 1 || cp->se_wait == 0))
				sep->se_wait = cp->se_wait;
			SWAP(int, cp->se_max, sep->se_max);
			SWAP(char *, sep->se_user, cp->se_user);
			SWAP(char *, sep->se_group, cp->se_group);
			SWAP(char *, sep->se_server, cp->se_server);
			for (i = 0; i < MAXARGV; i++)
				SWAP(char *, sep->se_argv[i], cp->se_argv[i]);
#undef SWAP
			if (isrpcservice(sep))
				unregister_rpc(sep);
			sep->se_rpcversl = cp->se_rpcversl;
			sep->se_rpcversh = cp->se_rpcversh;
			freeconfig(cp);
			add = 1;
		} else {
			sep = enter(cp);
		}
		sep->se_checked = 1;

		switch (sep->se_family) {
		case AF_UNIX:
			if (sep->se_fd != -1)
				break;
			sep->se_ctrladdr_size =
			    strlcpy(sep->se_ctrladdr_un.sun_path,
			    sep->se_service,
			    sizeof sep->se_ctrladdr_un.sun_path);
			if (sep->se_ctrladdr_size >=
			    sizeof sep->se_ctrladdr_un.sun_path) {
				syslog(LOG_WARNING, "%s/%s: UNIX domain socket "
				    "path too long", sep->se_service,
				    sep->se_proto);
				goto serv_unknown;
			}
			sep->se_ctrladdr_un.sun_family = AF_UNIX;
			sep->se_ctrladdr_size +=
			    1 + sizeof sep->se_ctrladdr_un.sun_family;
			(void)unlink(sep->se_service);
			setup(sep);
			break;
		case AF_INET:
			sep->se_ctrladdr_in.sin_family = AF_INET;
			/* se_ctrladdr_in was set in getconfigent */
			sep->se_ctrladdr_size = sizeof sep->se_ctrladdr_in;

			if (isrpcservice(sep)) {
				struct rpcent *rp;

				sep->se_rpcprog = strtonum(sep->se_service,
				    1, USHRT_MAX, NULL);
				if (sep->se_rpcprog == 0) {
					rp = getrpcbyname(sep->se_service);
					if (rp == 0) {
						syslog(LOG_ERR,
						    "%s: unknown rpc service",
						    sep->se_service);
						goto serv_unknown;
					}
					sep->se_rpcprog = rp->r_number;
				}
				if (sep->se_fd == -1)
					setup(sep);
				if (sep->se_fd != -1)
					register_rpc(sep);
			} else {
				u_short port = htons(strtonum(sep->se_service,
				    1, USHRT_MAX, NULL));

				if (!port) {
					(void)strlcpy(protoname, sep->se_proto,
					    sizeof(protoname));
					if (isdigit((unsigned char)
					    protoname[strlen(protoname) - 1]))
						protoname[strlen(protoname) - 1] = '\0';
					sp = getservbyname(sep->se_service,
					    protoname);
					if (sp == 0) {
						syslog(LOG_ERR,
						    "%s/%s: unknown service",
						    sep->se_service, sep->se_proto);
						goto serv_unknown;
					}
					port = sp->s_port;
				}
				if (port != sep->se_ctrladdr_in.sin_port) {
					sep->se_ctrladdr_in.sin_port = port;
					if (sep->se_fd != -1) {
						event_del(&sep->se_event);
						(void) close(sep->se_fd);
					}
					sep->se_fd = -1;
				}
				if (sep->se_fd == -1)
					setup(sep);
			}
			break;
		case AF_INET6:
			sep->se_ctrladdr_in6.sin6_family = AF_INET6;
			/* se_ctrladdr_in was set in getconfigent */
			sep->se_ctrladdr_size = sizeof sep->se_ctrladdr_in6;

			if (isrpcservice(sep)) {
				struct rpcent *rp;

				sep->se_rpcprog = strtonum(sep->se_service,
				    1, USHRT_MAX, NULL);
				if (sep->se_rpcprog == 0) {
					rp = getrpcbyname(sep->se_service);
					if (rp == 0) {
						syslog(LOG_ERR,
						    "%s: unknown rpc service",
						    sep->se_service);
						goto serv_unknown;
					}
					sep->se_rpcprog = rp->r_number;
				}
				if (sep->se_fd == -1)
					setup(sep);
				if (sep->se_fd != -1)
					register_rpc(sep);
			} else {
				u_short port = htons(strtonum(sep->se_service,
				    1, USHRT_MAX, NULL));

				if (!port) {
					(void)strlcpy(protoname, sep->se_proto,
					    sizeof(protoname));
					if (isdigit((unsigned char)
					    protoname[strlen(protoname) - 1]))
						protoname[strlen(protoname) - 1] = '\0';
					sp = getservbyname(sep->se_service,
					    protoname);
					if (sp == 0) {
						syslog(LOG_ERR,
						    "%s/%s: unknown service",
						    sep->se_service, sep->se_proto);
						goto serv_unknown;
					}
					port = sp->s_port;
				}
				if (port != sep->se_ctrladdr_in6.sin6_port) {
					sep->se_ctrladdr_in6.sin6_port = port;
					if (sep->se_fd != -1) {
						event_del(&sep->se_event);
						(void) close(sep->se_fd);
					}
					sep->se_fd = -1;
				}
				if (sep->se_fd == -1)
					setup(sep);
			}
			break;
		}
	serv_unknown:
		if (cp->se_next != NULL) {
			struct servtab *tmp = cp;

			cp = cp->se_next;
			free(tmp);
		} else {
			free(cp);
			cp = getconfigent();
		}
		if (debug)
			print_service(add ? "REDO" : "ADD", sep);
	}
	endconfig();
	/*
	 * Purge anything not looked at above.
	 */
	sepp = &servtab;
	while ((sep = *sepp)) {
		if (sep->se_checked) {
			sepp = &sep->se_next;
			continue;
		}
		*sepp = sep->se_next;
		if (sep->se_fd != -1) {
			event_del(&sep->se_event);
			(void) close(sep->se_fd);
		}
		if (isrpcservice(sep))
			unregister_rpc(sep);
		if (sep->se_family == AF_UNIX)
			(void)unlink(sep->se_service);
		if (debug)
			print_service("FREE", sep);
		freeconfig(sep);
		free(sep);
	}
}

void
retry(int sig, short events, void *arg)
{
	struct servtab *sep;

	timingout = 0;
	for (sep = servtab; sep; sep = sep->se_next) {
		if (sep->se_fd == -1) {
			switch (sep->se_family) {
			case AF_UNIX:
			case AF_INET:
			case AF_INET6:
				setup(sep);
				if (sep->se_fd != -1 && isrpcservice(sep))
					register_rpc(sep);
				break;
			}
		}
	}
}

void
die(int sig, short events, void *arg)
{
	struct servtab *sep;

	for (sep = servtab; sep; sep = sep->se_next) {
		if (sep->se_fd == -1)
			continue;

		switch (sep->se_family) {
		case AF_UNIX:
			(void)unlink(sep->se_service);
			break;
		case AF_INET:
		case AF_INET6:
			if (sep->se_wait == 1 && isrpcservice(sep))
				unregister_rpc(sep);
			break;
		}
		(void)close(sep->se_fd);
	}
	exit(0);
}

void
setup(struct servtab *sep)
{
	int on = 1;
	int r;
	mode_t mask = 0;

	if ((sep->se_fd = socket(sep->se_family, sep->se_socktype, 0)) < 0) {
		syslog(LOG_ERR, "%s/%s: socket: %m",
		    sep->se_service, sep->se_proto);
		return;
	}
#define	turnon(fd, opt) \
setsockopt(fd, SOL_SOCKET, opt, &on, sizeof (on))
	if (strncmp(sep->se_proto, "tcp", 3) == 0 && debug &&
	    turnon(sep->se_fd, SO_DEBUG) < 0)
		syslog(LOG_ERR, "setsockopt (SO_DEBUG): %m");
	if (turnon(sep->se_fd, SO_REUSEADDR) < 0)
		syslog(LOG_ERR, "setsockopt (SO_REUSEADDR): %m");
#undef turnon
	if (isrpcservice(sep)) {
		struct passwd *pwd;

		/*
		 * for RPC services, attempt to use a reserved port
		 * if they are going to be running as root.
		 *
		 * Also, zero out the port for all RPC services; let bind()
		 * find one.
		 */
		sep->se_ctrladdr_in.sin_port = 0;
		if (sep->se_user && (pwd = getpwnam(sep->se_user)) &&
		    pwd->pw_uid == 0 && uid == 0)
			r = bindresvport(sep->se_fd, &sep->se_ctrladdr_in);
		else {
			r = bind(sep->se_fd, &sep->se_ctrladdr,
			    sep->se_ctrladdr_size);
			if (r == 0) {
				socklen_t len = sep->se_ctrladdr_size;
				int saveerrno = errno;

				/* update se_ctrladdr_in.sin_port */
				r = getsockname(sep->se_fd, &sep->se_ctrladdr,
				    &len);
				if (r <= 0)
					errno = saveerrno;
			}
		}
	} else {
		if (sep->se_family == AF_UNIX)
			mask = umask(0111);
		r = bind(sep->se_fd, &sep->se_ctrladdr, sep->se_ctrladdr_size);
		if (sep->se_family == AF_UNIX)
			umask(mask);
	}
	if (r < 0) {
		syslog(LOG_ERR, "%s/%s: bind: %m",
		    sep->se_service, sep->se_proto);
		(void) close(sep->se_fd);
		sep->se_fd = -1;
		if (!timingout) {
			timingout = 1;
			alarm(RETRYTIME);
		}
		return;
	}
	if (sep->se_socktype == SOCK_STREAM)
		listen(sep->se_fd, 10);

	if (!sep->se_wait && sep->se_socktype == SOCK_STREAM) {
		event_set(&sep->se_event, sep->se_fd, EV_READ|EV_PERSIST,
		    gettcp, sep);
	} else {
		event_set(&sep->se_event, sep->se_fd, EV_READ|EV_PERSIST,
		    spawn, sep);
	}

	event_add(&sep->se_event, NULL);

	if (sep->se_fd > maxsock) {
		maxsock = sep->se_fd;
		if (maxsock > rlim_nofile_cur - FD_MARGIN)
			bump_nofile();
	}
}

void
register_rpc(struct servtab *sep)
{
	socklen_t n;
	struct sockaddr_in sin;
	struct protoent *pp;

	if ((pp = getprotobyname(sep->se_proto+4)) == NULL) {
		syslog(LOG_ERR, "%s: getproto: %m",
		    sep->se_proto);
		return;
	}
	n = sizeof sin;
	if (getsockname(sep->se_fd, (struct sockaddr *)&sin, &n) < 0) {
		syslog(LOG_ERR, "%s/%s: getsockname: %m",
		    sep->se_service, sep->se_proto);
		return;
	}

	for (n = sep->se_rpcversl; n <= sep->se_rpcversh; n++) {
		if (debug)
			fprintf(stderr, "pmap_set: %u %u %u %u\n",
			    sep->se_rpcprog, n, pp->p_proto,
			    ntohs(sin.sin_port));
		(void)pmap_unset(sep->se_rpcprog, n);
		if (!pmap_set(sep->se_rpcprog, n, pp->p_proto, ntohs(sin.sin_port)))
			syslog(LOG_ERR, "%s %s: pmap_set: %u %u %u %u: %m",
			    sep->se_service, sep->se_proto,
			    sep->se_rpcprog, n, pp->p_proto,
			    ntohs(sin.sin_port));
	}
}

void
unregister_rpc(struct servtab *sep)
{
	int n;

	for (n = sep->se_rpcversl; n <= sep->se_rpcversh; n++) {
		if (debug)
			fprintf(stderr, "pmap_unset(%u, %u)\n",
			    sep->se_rpcprog, n);
		if (!pmap_unset(sep->se_rpcprog, n))
			syslog(LOG_ERR, "pmap_unset(%u, %u)",
			    sep->se_rpcprog, n);
	}
}


struct servtab *
enter(struct servtab *cp)
{
	struct servtab *sep;

	sep = malloc(sizeof (*sep));
	if (sep == NULL) {
		syslog(LOG_ERR, "Out of memory.");
		exit(1);
	}
	*sep = *cp;
	sep->se_fd = -1;
	sep->se_rpcprog = -1;
	sep->se_next = servtab;
	servtab = sep;
	return (sep);
}

int
matchconf(struct servtab *old, struct servtab *new)
{
	if (strcmp(old->se_service, new->se_service) != 0)
		return (0);

	if (strcmp(old->se_hostaddr, new->se_hostaddr) != 0)
		return (0);

	if (strcmp(old->se_proto, new->se_proto) != 0)
		return (0);

	/*
	 * If the new servtab is bound to a specific address, check that the
	 * old servtab is bound to the same entry. If the new service is not
	 * bound to a specific address then the check of se_hostaddr above
	 * is sufficient.
	 */

	if (old->se_family == AF_INET && new->se_family == AF_INET &&
	    bcmp(&old->se_ctrladdr_in.sin_addr,
	    &new->se_ctrladdr_in.sin_addr,
	    sizeof(new->se_ctrladdr_in.sin_addr)) != 0)
		return (0);

	if (old->se_family == AF_INET6 && new->se_family == AF_INET6 &&
	    bcmp(&old->se_ctrladdr_in6.sin6_addr,
	    &new->se_ctrladdr_in6.sin6_addr,
	    sizeof(new->se_ctrladdr_in6.sin6_addr)) != 0)
		return (0);
	if (old->se_family == AF_INET6 && new->se_family == AF_INET6 &&
	    old->se_ctrladdr_in6.sin6_scope_id !=
	    new->se_ctrladdr_in6.sin6_scope_id)
		return (0);

	return (1);
}

FILE		*fconfig = NULL;
char		line[1024];
char		*defhost;
char		*skip(char **, int);
char		*nextline(FILE *);
char		*newstr(char *);
struct servtab	*dupconfig(struct servtab *);

int
setconfig(void)
{
	free(defhost);
	defhost = newstr("*");
	if (fconfig != NULL) {
		fseek(fconfig, 0L, SEEK_SET);
		return (1);
	}
	fconfig = fopen(CONFIG, "r");
	return (fconfig != NULL);
}

void
endconfig(void)
{
	if (fconfig) {
		(void) fclose(fconfig);
		fconfig = NULL;
	}
	if (defhost) {
		free(defhost);
		defhost = 0;
	}
}

struct servtab *
getconfigent(void)
{
	struct servtab *sep, *tsep;
	char *arg, *cp, *hostdelim, *s;
	int argc;

	sep = calloc(1, sizeof(struct servtab));
	if (sep == NULL) {
		syslog(LOG_ERR, "calloc: %m");
		exit(1);
	}
more:
	freeconfig(sep);

	while ((cp = nextline(fconfig)) && *cp == '#')
		;
	if (cp == NULL) {
		free(sep);
		return (NULL);
	}

	memset(sep, 0, sizeof *sep);
	arg = skip(&cp, 0);
	if (arg == NULL) {
		/* A blank line. */
		goto more;
	}

	/* Check for a host name. */
	hostdelim = strrchr(arg, ':');
	if (hostdelim) {
		*hostdelim = '\0';
		if (arg[0] == '[' && hostdelim > arg && hostdelim[-1] == ']') {
			hostdelim[-1] = '\0';
			sep->se_hostaddr = newstr(arg + 1);
		} else if (hostdelim == arg)
			sep->se_hostaddr = newstr("*");
		else
			sep->se_hostaddr = newstr(arg);
		arg = hostdelim + 1;
		/*
		 * If the line is of the form `host:', then just change the
		 * default host for the following lines.
		 */
		if (*arg == '\0') {
			arg = skip(&cp, 0);
			if (cp == NULL) {
				free(defhost);
				defhost = newstr(sep->se_hostaddr);
				goto more;
			}
		}
	} else
		sep->se_hostaddr = newstr(defhost);

	sep->se_service = newstr(arg);
	if ((arg = skip(&cp, 1)) == NULL)
		goto more;

	if (strcmp(arg, "stream") == 0)
		sep->se_socktype = SOCK_STREAM;
	else if (strcmp(arg, "dgram") == 0)
		sep->se_socktype = SOCK_DGRAM;
	else if (strcmp(arg, "rdm") == 0)
		sep->se_socktype = SOCK_RDM;
	else if (strcmp(arg, "seqpacket") == 0)
		sep->se_socktype = SOCK_SEQPACKET;
	else if (strcmp(arg, "raw") == 0)
		sep->se_socktype = SOCK_RAW;
	else
		sep->se_socktype = -1;

	if ((arg = skip(&cp, 1)) == NULL)
		goto more;

	sep->se_proto = newstr(arg);

	if (strcmp(sep->se_proto, "unix") == 0) {
		sep->se_family = AF_UNIX;
	} else {
		int s;

		sep->se_family = AF_INET;
		if (sep->se_proto[strlen(sep->se_proto) - 1] == '6')
			sep->se_family = AF_INET6;

		/* check if the family is supported */
		s = socket(sep->se_family, SOCK_DGRAM, 0);
		if (s < 0) {
			syslog(LOG_WARNING, "%s/%s: %s: the address family is "
			    "not supported by the kernel", sep->se_service,
			    sep->se_proto, sep->se_hostaddr);
			goto more;
		}
		close(s);

		if (strncmp(sep->se_proto, "rpc/", 4) == 0) {
			char *cp, *ccp;
			long l;

			cp = strchr(sep->se_service, '/');
			if (cp == 0) {
				syslog(LOG_ERR, "%s: no rpc version",
				    sep->se_service);
				goto more;
			}
			*cp++ = '\0';
			l = strtol(cp, &ccp, 0);
			if (ccp == cp || l < 0 || l > INT_MAX) {
		badafterall:
				syslog(LOG_ERR, "%s/%s: bad rpc version",
				    sep->se_service, cp);
				goto more;
			}
			sep->se_rpcversl = sep->se_rpcversh = l;
			if (*ccp == '-') {
				cp = ccp + 1;
				l = strtol(cp, &ccp, 0);
				if (ccp == cp || l < 0 || l > INT_MAX ||
				    l < sep->se_rpcversl || *ccp)
					goto badafterall;
				sep->se_rpcversh = l;
			} else if (*ccp != '\0')
				goto badafterall;
		}
	}
	arg = skip(&cp, 1);
	if (arg == NULL)
		goto more;

	s = strchr(arg, '.');
	if (s) {
		char *p;

		*s++ = '\0';
		sep->se_max = strtoul(s, &p, 0);
		if (sep->se_max < 1 || *p) {
			syslog(LOG_ERR,
			    "%s: illegal max field \"%s\", setting to %d",
			    sep->se_service, s, toomany);
			sep->se_max = toomany;
		}
	} else
		sep->se_max = toomany;

	sep->se_wait = strcmp(arg, "wait") == 0;
	if ((arg = skip(&cp, 1)) == NULL)
		goto more;
	sep->se_user = newstr(arg);
	arg = strchr(sep->se_user, '.');
	if (arg == NULL)
		arg = strchr(sep->se_user, ':');
	if (arg) {
		*arg++ = '\0';
		sep->se_group = newstr(arg);
	}
	if ((arg = skip(&cp, 1)) == NULL)
		goto more;

	sep->se_server = newstr(arg);
	if (strcmp(sep->se_server, "internal") == 0) {
		struct biltin *bi;

		for (bi = biltins; bi->bi_service; bi++)
			if (bi->bi_socktype == sep->se_socktype &&
			    strcmp(bi->bi_service, sep->se_service) == 0)
				break;
		if (bi->bi_service == 0) {
			syslog(LOG_ERR, "internal service %s unknown",
			    sep->se_service);
			goto more;
		}
		sep->se_bi = bi;
		sep->se_wait = bi->bi_wait;
	} else
		sep->se_bi = NULL;
	argc = 0;
	for (arg = skip(&cp, 0); cp; arg = skip(&cp, 0)) {
		if (argc < MAXARGV)
			sep->se_argv[argc++] = newstr(arg);
	}
	if (argc == 0 && sep->se_bi == NULL) {
		if ((arg = strrchr(sep->se_server, '/')) != NULL)
			arg++;
		else
			arg = sep->se_server;
		sep->se_argv[argc++] = newstr(arg);
	}
	while (argc <= MAXARGV)
		sep->se_argv[argc++] = NULL;

	/*
	 * Resolve each hostname in the se_hostaddr list (if any)
	 * and create a new entry for each resolved address.
	 */
	if (sep->se_hostaddr != NULL && strcmp(sep->se_proto, "unix") != 0) {
		struct addrinfo hints, *res0, *res;
		char *host, *hostlist0, *hostlist, *port;
		int error;

		hostlist = hostlist0 = sep->se_hostaddr;
		sep->se_hostaddr = NULL;
		sep->se_checked = -1;
		while ((host = strsep(&hostlist, ",")) != NULL) {
			if (*host == '\0')
				continue;

			memset(&hints, 0, sizeof(hints));
			hints.ai_family = sep->se_family;
			hints.ai_socktype = sep->se_socktype;
			hints.ai_flags = AI_PASSIVE;
			port = "0";
			error = getaddrinfo(strcmp(host, "*") ? host : NULL,
			    port, &hints, &res0);
			if (error) {
				syslog(LOG_ERR, "%s/%s: %s: %s",
				    sep->se_service, sep->se_proto,
				    host, gai_strerror(error));
				continue;
			}
			for (res = res0; res; res = res->ai_next) {
				if (res->ai_addrlen >
				    sizeof(sep->se_ctrladdr_storage))
					continue;
				/*
				 * If sep is unused, store host in there.
				 * Otherwise, dup a new entry and prepend it.
				 */
				if (sep->se_checked == -1) {
					sep->se_checked = 0;
				} else {
					tsep = dupconfig(sep);
					tsep->se_next = sep;
					sep = tsep;
				}
				sep->se_hostaddr = newstr(host);
				memcpy(&sep->se_ctrladdr_storage,
				    res->ai_addr, res->ai_addrlen);
				sep->se_ctrladdr_size = res->ai_addrlen;
			}
			freeaddrinfo(res0);
		}
		free(hostlist0);
		if (sep->se_checked == -1)
			goto more;	/* no resolvable names/addresses */
	}

	return (sep);
}

void
freeconfig(struct servtab *cp)
{
	int i;

	free(cp->se_hostaddr);
	cp->se_hostaddr = NULL;
	free(cp->se_service);
	cp->se_service = NULL;
	free(cp->se_proto);
	cp->se_proto = NULL;
	free(cp->se_user);
	cp->se_user = NULL;
	free(cp->se_group);
	cp->se_group = NULL;
	free(cp->se_server);
	cp->se_server = NULL;
	for (i = 0; i < MAXARGV; i++) {
		free(cp->se_argv[i]);
		cp->se_argv[i] = NULL;
	}
}

char *
skip(char **cpp, int report)
{
	char *cp = *cpp;
	char *start;

erp:
	if (*cpp == NULL) {
		if (report)
			syslog(LOG_ERR, "syntax error in inetd config file");
		return (NULL);
	}

again:
	while (*cp == ' ' || *cp == '\t')
		cp++;
	if (*cp == '\0') {
		int c;

		c = getc(fconfig);
		(void) ungetc(c, fconfig);
		if (c == ' ' || c == '\t')
			if ((cp = nextline(fconfig)))
				goto again;
		*cpp = NULL;
		goto erp;
	}
	start = cp;
	while (*cp && *cp != ' ' && *cp != '\t')
		cp++;
	if (*cp != '\0')
		*cp++ = '\0';
	if ((*cpp = cp) == NULL)
		goto erp;

	return (start);
}

char *
nextline(FILE *fd)
{
	if (fgets(line, sizeof (line), fd) == NULL)
		return (NULL);
	line[strcspn(line, "\n")] = '\0';
	return (line);
}

char *
newstr(char *cp)
{
	if ((cp = strdup(cp ? cp : "")))
		return(cp);
	syslog(LOG_ERR, "strdup: %m");
	exit(1);
}

struct servtab *
dupconfig(struct servtab *sep)
{
	struct servtab *newtab;
	int argc;

	newtab = calloc(1, sizeof(struct servtab));

	if (newtab == NULL) {
		syslog(LOG_ERR, "calloc: %m");
		exit(1);
	}

	newtab->se_service = sep->se_service ? newstr(sep->se_service) : NULL;
	newtab->se_socktype = sep->se_socktype;
	newtab->se_family = sep->se_family;
	newtab->se_proto = sep->se_proto ? newstr(sep->se_proto) : NULL;
	newtab->se_rpcprog = sep->se_rpcprog;
	newtab->se_rpcversl = sep->se_rpcversl;
	newtab->se_rpcversh = sep->se_rpcversh;
	newtab->se_wait = sep->se_wait;
	newtab->se_user = sep->se_user ? newstr(sep->se_user) : NULL;
	newtab->se_group = sep->se_group ? newstr(sep->se_group) : NULL;
	newtab->se_bi = sep->se_bi;
	newtab->se_server = sep->se_server ? newstr(sep->se_server) : 0;

	for (argc = 0; argc <= MAXARGV; argc++)
		newtab->se_argv[argc] = sep->se_argv[argc] ?
		    newstr(sep->se_argv[argc]) : NULL;
	newtab->se_max = sep->se_max;

	return (newtab);
}

void
inetd_setproctitle(char *a, int s)
{
	socklen_t size;
	struct sockaddr_storage ss;
	char hbuf[NI_MAXHOST];

	size = sizeof(ss);
	if (getpeername(s, (struct sockaddr *)&ss, &size) == 0) {
		if (getnameinfo((struct sockaddr *)&ss, size, hbuf,
		    sizeof(hbuf), NULL, 0, NI_NUMERICHOST) == 0)
			setproctitle("-%s [%s]", a, hbuf);
		else
			setproctitle("-%s [?]", a);
	} else
		setproctitle("-%s", a);
}

int
bump_nofile(void)
{
#define FD_CHUNK	32

	struct rlimit rl;

	if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
		syslog(LOG_ERR, "getrlimit: %m");
		return -1;
	}
	rl.rlim_cur = MINIMUM(rl.rlim_max, rl.rlim_cur + FD_CHUNK);
	rl.rlim_cur = MINIMUM(FD_SETSIZE, rl.rlim_cur + FD_CHUNK);
	if (rl.rlim_cur <= rlim_nofile_cur) {
		syslog(LOG_ERR,
		    "bump_nofile: cannot extend file limit, max = %d",
		    (int)rl.rlim_cur);
		return -1;
	}

	if (setrlimit(RLIMIT_NOFILE, &rl) < 0) {
		syslog(LOG_ERR, "setrlimit: %m");
		return -1;
	}

	rlim_nofile_cur = rl.rlim_cur;
	return 0;
}

/*
 * Internet services provided internally by inetd:
 */
#define	BUFSIZE	4096

void
echo_stream(int s, struct servtab *sep)
{
	char buffer[BUFSIZE];
	int i;

	inetd_setproctitle(sep->se_service, s);
	while ((i = read(s, buffer, sizeof(buffer))) > 0 &&
	    write(s, buffer, i) > 0)
		;
	exit(0);
}

void
echo_dg(int s, struct servtab *sep)
{
	char buffer[BUFSIZE];
	int i;
	socklen_t size;
	struct sockaddr_storage ss;

	size = sizeof(ss);
	if ((i = recvfrom(s, buffer, sizeof(buffer), 0,
	    (struct sockaddr *)&ss, &size)) < 0)
		return;
	if (dg_badinput((struct sockaddr *)&ss))
		return;
	(void) sendto(s, buffer, i, 0, (struct sockaddr *)&ss, size);
}

void
discard_stream(int s, struct servtab *sep)
{
	char buffer[BUFSIZE];

	inetd_setproctitle(sep->se_service, s);
	while ((errno = 0, read(s, buffer, sizeof(buffer)) > 0) ||
	    errno == EINTR)
		;
	exit(0);
}

void
discard_dg(int s, struct servtab *sep)
{
	char buffer[BUFSIZE];

	(void) read(s, buffer, sizeof(buffer));
}

#include <ctype.h>
#define LINESIZ 72
char ring[128];
char *endring;

void
initring(void)
{
	int i;

	endring = ring;

	for (i = 0; i <= sizeof ring; ++i)
		if (isprint((unsigned char)i))
			*endring++ = i;
}

void
chargen_stream(int s, struct servtab *sep)
{
	char *rs;
	int len;
	char text[LINESIZ+2];

	inetd_setproctitle(sep->se_service, s);

	if (!endring) {
		initring();
		rs = ring;
	}

	text[LINESIZ] = '\r';
	text[LINESIZ + 1] = '\n';
	for (rs = ring;;) {
		if ((len = endring - rs) >= LINESIZ)
			memmove(text, rs, LINESIZ);
		else {
			memmove(text, rs, len);
			memmove(text + len, ring, LINESIZ - len);
		}
		if (++rs == endring)
			rs = ring;
		if (write(s, text, sizeof(text)) != sizeof(text))
			break;
	}
	exit(0);
}

void
chargen_dg(int s, struct servtab *sep)
{
	struct sockaddr_storage ss;
	static char *rs;
	int len;
	socklen_t size;
	char text[LINESIZ+2];

	if (endring == 0) {
		initring();
		rs = ring;
	}

	size = sizeof(ss);
	if (recvfrom(s, text, sizeof(text), 0, (struct sockaddr *)&ss,
	    &size) < 0)
		return;
	if (dg_badinput((struct sockaddr *)&ss))
		return;

	if ((len = endring - rs) >= LINESIZ)
		memmove(text, rs, LINESIZ);
	else {
		memmove(text, rs, len);
		memmove(text + len, ring, LINESIZ - len);
	}
	if (++rs == endring)
		rs = ring;
	text[LINESIZ] = '\r';
	text[LINESIZ + 1] = '\n';
	(void) sendto(s, text, sizeof(text), 0, (struct sockaddr *)&ss, size);
}

/*
 * Return a machine readable date and time, in the form of the
 * number of seconds since midnight, Jan 1, 1900.  Since gettimeofday
 * returns the number of seconds since midnight, Jan 1, 1970,
 * we must add 2208988800 seconds to this figure to make up for
 * some seventy years Bell Labs was asleep.
 */
u_int32_t
machtime(void)
{
	struct timeval tv;

	if (gettimeofday(&tv, NULL) < 0)
		return (0L);

	return (htonl((u_int32_t)tv.tv_sec + 2208988800UL));
}

void
machtime_stream(int s, struct servtab *sep)
{
	u_int32_t result;

	result = machtime();
	(void) write(s, &result, sizeof(result));
}

void
machtime_dg(int s, struct servtab *sep)
{
	u_int32_t result;
	struct sockaddr_storage ss;
	socklen_t size;

	size = sizeof(ss);
	if (recvfrom(s, &result, sizeof(result), 0,
	    (struct sockaddr *)&ss, &size) < 0)
		return;
	if (dg_badinput((struct sockaddr *)&ss))
		return;
	result = machtime();
	(void) sendto(s, &result, sizeof(result), 0,
	    (struct sockaddr *)&ss, size);
}

/* Return human-readable time of day */
void
daytime_stream(int s, struct servtab *sep)
{
	char buffer[256];
	time_t clock;

	clock = time(NULL);

	(void) snprintf(buffer, sizeof buffer, "%.24s\r\n", ctime(&clock));
	(void) write(s, buffer, strlen(buffer));
}

/* Return human-readable time of day */
void
daytime_dg(int s, struct servtab *sep)
{
	char buffer[256];
	time_t clock;
	struct sockaddr_storage ss;
	socklen_t size;

	clock = time(NULL);

	size = sizeof(ss);
	if (recvfrom(s, buffer, sizeof(buffer), 0, (struct sockaddr *)&ss,
	    &size) < 0)
		return;
	if (dg_badinput((struct sockaddr *)&ss))
		return;
	(void) snprintf(buffer, sizeof buffer, "%.24s\r\n", ctime(&clock));
	(void) sendto(s, buffer, strlen(buffer), 0, (struct sockaddr *)&ss,
	    size);
}

/*
 * print_service:
 *	Dump relevant information to stderr
 */
void
print_service(char *action, struct servtab *sep)
{
	if (strcmp(sep->se_hostaddr, "*") == 0)
		fprintf(stderr, "%s: %s ", action, sep->se_service);
	else
		fprintf(stderr, "%s: %s:%s ", action, sep->se_hostaddr,
		    sep->se_service);

	if (isrpcservice(sep))
		fprintf(stderr, "rpcprog=%d, rpcvers=%d/%d, proto=%s,",
		    sep->se_rpcprog, sep->se_rpcversh,
		    sep->se_rpcversl, sep->se_proto);
	else
		fprintf(stderr, "proto=%s,", sep->se_proto);

	fprintf(stderr,
	    " wait.max=%d.%d user:group=%s:%s builtin=%lx server=%s\n",
	    sep->se_wait, sep->se_max, sep->se_user,
	    sep->se_group ? sep->se_group : "wheel",
	    (long)sep->se_bi, sep->se_server);
}

void
spawn(int ctrl, short events, void *xsep)
{
	struct servtab *sep = xsep;
	struct passwd *pwd;
	int tmpint, dofork;
	struct group *grp = NULL;
	char buf[50];
	pid_t pid;

	if (debug)
		fprintf(stderr, "someone wants %s\n", sep->se_service);

	pid = 0;
	dofork = (sep->se_bi == 0 || sep->se_bi->bi_fork);
	if (dofork) {
		if (sep->se_count++ == 0)
		    (void)gettimeofday(&sep->se_time, NULL);
		else if (sep->se_count >= sep->se_max) {
			struct timeval now;

			(void)gettimeofday(&now, NULL);
			if (now.tv_sec - sep->se_time.tv_sec >
			    CNT_INTVL) {
				sep->se_time = now;
				sep->se_count = 1;
			} else {
				if (!sep->se_wait &&
				    sep->se_socktype == SOCK_STREAM)
					close(ctrl);
				if (sep->se_family == AF_INET &&
				    ntohs(sep->se_ctrladdr_in.sin_port) >=
				    IPPORT_RESERVED) {
					/*
					 * Cannot close it -- there are
					 * thieves on the system.
					 * Simply ignore the connection.
					 */
					--sep->se_count;
					return;
				}
				syslog(LOG_ERR,
				    "%s/%s server failing (looping), service terminated",
				    sep->se_service, sep->se_proto);
				if (!sep->se_wait &&
				    sep->se_socktype == SOCK_STREAM)
					close(ctrl);
				event_del(&sep->se_event);
				(void) close(sep->se_fd);

				sep->se_fd = -1;
				sep->se_count = 0;
				if (!timingout) {
					timingout = 1;
					alarm(RETRYTIME);
				}
				return;
			}
		}
		pid = fork();
	}
	if (pid < 0) {
		syslog(LOG_ERR, "fork: %m");
		if (!sep->se_wait && sep->se_socktype == SOCK_STREAM)
			close(ctrl);
		sleep(1);
		return;
	}

	if (pledge("stdio rpath getpw inet proc exec id", NULL) == -1)
		err(1, "pledge");

	if (pid && sep->se_wait) {
		sep->se_wait = pid;
		event_del(&sep->se_event);
	}
	if (pid == 0) {
		if (sep->se_bi)
			(*sep->se_bi->bi_fn)(ctrl, sep);
		else {
			if ((pwd = getpwnam(sep->se_user)) == NULL) {
				syslog(LOG_ERR,
				    "getpwnam: %s: No such user",
				    sep->se_user);
				if (sep->se_socktype != SOCK_STREAM)
					recv(0, buf, sizeof (buf), 0);
				exit(1);
			}
			if (setsid() <0)
				syslog(LOG_ERR, "%s: setsid: %m",
				    sep->se_service);
			if (sep->se_group &&
			    (grp = getgrnam(sep->se_group)) == NULL) {
				syslog(LOG_ERR,
				    "getgrnam: %s: No such group",
				    sep->se_group);
				if (sep->se_socktype != SOCK_STREAM)
					recv(0, buf, sizeof (buf), 0);
				exit(1);
			}
			if (uid != 0) {
				/* a user running private inetd */
				if (uid != pwd->pw_uid)
					exit(1);
			} else {
				tmpint = LOGIN_SETALL &
				    ~(LOGIN_SETGROUP|LOGIN_SETLOGIN);
				if (pwd->pw_uid)
					tmpint |= LOGIN_SETGROUP|LOGIN_SETLOGIN;
				if (sep->se_group) {
					pwd->pw_gid = grp->gr_gid;
					tmpint |= LOGIN_SETGROUP;
				}
				if (setusercontext(NULL, pwd, pwd->pw_uid,
				    tmpint) < 0) {
					syslog(LOG_ERR,
					    "%s/%s: setusercontext: %m",
					    sep->se_service, sep->se_proto);
					exit(1);
				}
			}
			if (debug)
				fprintf(stderr, "%ld execv %s\n",
				    (long)getpid(), sep->se_server);
			if (ctrl != STDIN_FILENO) {
				dup2(ctrl, STDIN_FILENO);
				close(ctrl);
			}
			dup2(STDIN_FILENO, STDOUT_FILENO);
			dup2(STDIN_FILENO, STDERR_FILENO);
			closelog();
			closefrom(3);
			signal(SIGPIPE, SIG_DFL);
			execv(sep->se_server, sep->se_argv);
			if (sep->se_socktype != SOCK_STREAM)
				recv(0, buf, sizeof (buf), 0);
			syslog(LOG_ERR, "execv %s: %m", sep->se_server);
			exit(1);
		}
	}
	if (!sep->se_wait && sep->se_socktype == SOCK_STREAM)
		close(ctrl);
}
@


1.153
log
@Remove a (now) obsolete comment about shortened IPv4 syntax

OK deraadt@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.152 2016/03/16 20:15:15 mestre Exp $	*/
a1457 1
/* ARGSUSED */
a1470 1
/* ARGSUSED */
a1487 1
/* ARGSUSED */
a1499 1
/* ARGSUSED */
a1524 1
/* ARGSUSED */
a1555 1
/* ARGSUSED */
a1607 1
/* ARGSUSED */
a1616 1
/* ARGSUSED */
a1635 1
/* ARGSUSED */
a1648 1
/* ARGSUSED */
@


1.152
log
@Replace strncpy(3) calls for safer strlcpy(3)

OK deraadt@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.151 2016/03/16 20:09:58 mestre Exp $	*/
a1254 1
			/* XXX shortened IPv4 syntax is now forbidden */
@


1.151
log
@Replace atoi(3) calls for safer strtonum(3)

OK deeradt@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.150 2015/12/22 19:44:01 mmcc Exp $	*/
d649 2
a650 3
					/* XXX */
					strncpy(protoname, sep->se_proto,
						sizeof(protoname));
d705 2
a706 3
					/* XXX */
					strncpy(protoname, sep->se_proto,
						sizeof(protoname));
@


1.150
log
@remove a NULL-check before free()
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.149 2015/11/01 19:59:28 deraadt Exp $	*/
d424 1
a424 1
		    atoi(sbuf) == 20) {
d553 1
a553 1
	char protoname[10];
d628 2
a629 1
				sep->se_rpcprog = atoi(sep->se_service);
d645 2
a646 1
				u_short port = htons(atoi(sep->se_service));
d685 2
a686 1
				sep->se_rpcprog = atoi(sep->se_service);
d702 2
a703 1
				u_short port = htons(atoi(sep->se_service));
@


1.149
log
@needs pledge "cpath" to allow unlink of AF_UNIX sockets eventually
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.148 2015/11/01 00:31:18 deraadt Exp $	*/
d1017 1
a1017 2
	if (defhost)
		free(defhost);
@


1.148
log
@inetd needs pledge "unix" to bind AF_UNIX sockets
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.147 2015/10/22 12:34:25 deraadt Exp $	*/
d349 1
a349 1
	if (pledge("stdio rpath getpw dns inet unix proc exec id", NULL) == -1)
@


1.147
log
@pledge "abort" left behind accidentally
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.146 2015/10/19 11:52:51 jca Exp $	*/
d349 1
a349 1
	if (pledge("stdio rpath getpw dns inet proc exec id", NULL) == -1)
@


1.146
log
@optarg and optind are declared by unistd.h
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.145 2015/10/19 11:51:17 jca Exp $	*/
d349 1
a349 1
	if (pledge("stdio rpath getpw dns inet proc exec id abort", NULL) == -1)
d1776 1
a1776 1
	if (pledge("stdio rpath getpw inet proc exec id abort", NULL) == -1)
@


1.145
log
@Add err.h, missing after pledge() introduction.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.144 2015/10/18 16:11:19 jca Exp $	*/
a298 2
	extern char *optarg;
	extern int optind;
@


1.144
log
@Make use of pledge(2); initial diff from deraadt@@

As Theo says, there's probably room for stricter pledge requests, but
this would involve refactoring.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.143 2015/01/16 06:40:17 deraadt Exp $	*/
d137 1
@


1.143
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.142 2014/10/29 03:33:14 dlg Exp $	*/
d300 1
a300 1
	
d350 3
d1776 4
@


1.142
log
@replace the use of select and hand rolled deferral of signal handling
with libevent.

this has been in snaps for a while without any negative (or positive)
feedback.

review and tweaks by bluhm@@ nicm@@
ok bluhm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.141 2014/10/13 01:53:14 dlg Exp $	*/
a123 1
#include <sys/param.h>
d147 1
d157 2
d1433 2
a1434 2
	rl.rlim_cur = MIN(rl.rlim_max, rl.rlim_cur + FD_CHUNK);
	rl.rlim_cur = MIN(FD_SETSIZE, rl.rlim_cur + FD_CHUNK);
@


1.141
log
@dont need to store the same debug flag in two separate variables.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.140 2014/10/12 09:36:42 dlg Exp $	*/
d154 1
d162 1
a162 3
int	 nsock, maxsock;
fd_set	*allsockp;
int	 allsockn;
a166 2
sigset_t blockmask;
sigset_t emptymask;
d214 1
d258 13
a270 15
volatile sig_atomic_t wantretry;
volatile sig_atomic_t wantconfig;
volatile sig_atomic_t wantreap;
volatile sig_atomic_t wantdie;

void	config(int);
void	doconfig(void);
void	reap(int);
void	doreap(void);
void	retry(int);
void	doretry(void);
void	die(int);
void	dodie(void);
void	spawn(struct servtab *, int);
int	gettcp(struct servtab *);
a286 1
void		fd_grow(fd_set **fdsp, int *bytes, int fd);
a291 22
void
fd_grow(fd_set **fdsp, int *bytes, int fd)
{
	caddr_t new;
	int newbytes;

	newbytes = howmany(fd+1, NFDBITS) * sizeof(fd_mask);
	if (newbytes > *bytes) {
		newbytes *= 2;			/* optimism */
		new = realloc(*fdsp, newbytes);
		if (new == NULL) {
			syslog(LOG_ERR, "Out of memory.");
			exit(1);
		}
		memset(new + *bytes, 0, newbytes - *bytes);
		*fdsp = (fd_set *)new;
		*bytes = newbytes;
	}
}

struct sigaction sa, sapipe;

d295 1
a295 3
	fd_set *fdsrp = NULL;
	int readablen = 0, ch;
	struct servtab *sep;
d365 1
a365 24
	sigemptyset(&emptymask);
	sigemptyset(&blockmask);
	sigaddset(&blockmask, SIGCHLD);
	sigaddset(&blockmask, SIGHUP);
	sigaddset(&blockmask, SIGALRM);

	memset(&sa, 0, sizeof(sa));
	sigemptyset(&sa.sa_mask);
	sigaddset(&sa.sa_mask, SIGALRM);
	sigaddset(&sa.sa_mask, SIGCHLD);
	sigaddset(&sa.sa_mask, SIGHUP);
	sa.sa_handler = retry;
	sigaction(SIGALRM, &sa, NULL);
	doconfig();
	sa.sa_handler = config;
	sigaction(SIGHUP, &sa, NULL);
	sa.sa_handler = reap;
	sigaction(SIGCHLD, &sa, NULL);
	sa.sa_handler = die;
	sigaction(SIGTERM, &sa, NULL);
	sa.sa_handler = die;
	sigaction(SIGINT, &sa, NULL);
	sa.sa_handler = SIG_IGN;
	sigaction(SIGPIPE, &sa, &sapipe);
d367 2
a368 2
	for (;;) {
		int n, ctrl = -1;
d370 1
a370 10
	    restart:
		if (nsock == 0) {
			(void) sigprocmask(SIG_BLOCK, &blockmask, NULL);
			while (nsock == 0) {
				if (wantretry || wantconfig || wantreap || wantdie)
					break;
				sigsuspend(&emptymask);
			}
			(void) sigprocmask(SIG_SETMASK, &emptymask, NULL);
		}
d372 8
a379 17
		while (wantretry || wantconfig || wantreap || wantdie) {
			if (wantretry) {
				wantretry = 0;
				doretry();
			}
			if (wantconfig) {
				wantconfig = 0;
				doconfig();
			}
			if (wantreap) {
				wantreap = 0;
				doreap();
			}
			if (wantdie)
				dodie();
			goto restart;
		}
d381 1
a381 11
		if (readablen != allsockn) {
			if (fdsrp)
				free(fdsrp);
			fdsrp = calloc(allsockn, 1);
			if (fdsrp == NULL) {
				syslog(LOG_ERR, "Out of memory.");
				exit(1);
			}
			readablen = allsockn;
		}
		bcopy(allsockp, fdsrp, allsockn);
d383 1
a383 7
		if ((n = select(maxsock + 1, fdsrp, NULL, NULL, NULL)) <= 0) {
			if (n < 0 && errno != EINTR) {
				syslog(LOG_WARNING, "select: %m");
				sleep(1);
			}
			continue;
		}
d385 1
a385 19
		for (sep = servtab; n && sep; sep = sep->se_next) {
			if (sep->se_fd != -1 &&
			    FD_ISSET(sep->se_fd, fdsrp)) {
				n--;
				if (debug)
					fprintf(stderr, "someone wants %s\n",
					    sep->se_service);
				if (!sep->se_wait &&
				    sep->se_socktype == SOCK_STREAM) {
					ctrl = gettcp(sep);
					if (ctrl == -1)
						continue;
				} else
					ctrl = sep->se_fd;
				(void) sigprocmask(SIG_BLOCK, &blockmask, NULL);
				spawn(sep, ctrl);	/* spawn will unblock */
			}
		}
	}
d388 2
a389 2
int
gettcp(struct servtab *sep)
d391 1
d394 3
d405 1
a405 1
		return -1;
d416 1
a416 1
			return -1;
d425 1
a425 1
			return -1;
d428 2
a429 1
	return (ctrl);
a431 1

a505 7
/* ARGSUSED */
void
reap(int sig)
{
	wantreap = 1;
}

d507 1
a507 1
doreap(void)
d536 1
a536 3
				fd_grow(&allsockp, &allsockn, sep->se_fd);
				FD_SET(sep->se_fd, allsockp);
				nsock++;
a543 7
/* ARGSUSED */
void
config(int sig)
{
	wantconfig = 1;
}

d545 1
a545 1
doconfig(void)
a549 1
	sigset_t omask;
a567 1
			sigprocmask(SIG_BLOCK, &blockmask, &omask);
a587 1
			sigprocmask(SIG_SETMASK, &omask, NULL);
d662 1
a662 2
						FD_CLR(sep->se_fd, allsockp);
						nsock--;
d717 1
a717 2
						FD_CLR(sep->se_fd, allsockp);
						nsock--;
a743 1
	sigprocmask(SIG_BLOCK, &blockmask, &omask);
d752 1
a752 2
			FD_CLR(sep->se_fd, allsockp);
			nsock--;
a763 8
	sigprocmask(SIG_SETMASK, &omask, NULL);
}

/* ARGSUSED */
void
retry(int sig)
{
	wantretry = 1;
d767 1
a767 1
doretry(void)
a786 7
/* ARGSUSED */
void
die(int sig)
{
	wantdie = 1;
}

d788 1
a788 1
dodie(void)
d880 10
a889 3
	fd_grow(&allsockp, &allsockn, sep->se_fd);
	FD_SET(sep->se_fd, allsockp);
	nsock++;
a949 1
	sigset_t omask;
a958 1
	sigprocmask(SIG_BLOCK, &blockmask, &omask);
a960 1
	sigprocmask(SIG_SETMASK, &omask, NULL);
d1704 1
a1704 1
spawn(struct servtab *sep, int ctrl)
d1706 1
d1713 3
a1741 2
					sigprocmask(SIG_SETMASK, &emptymask,
					    NULL);
d1750 1
a1750 1
				FD_CLR(sep->se_fd, allsockp);
d1752 1
a1754 3
				nsock--;
				sigprocmask(SIG_SETMASK, &emptymask,
				    NULL);
a1767 1
		sigprocmask(SIG_SETMASK, &emptymask, NULL);
d1773 1
a1773 2
		FD_CLR(sep->se_fd, allsockp);
		nsock--;
a1774 1
	sigprocmask(SIG_SETMASK, &emptymask, NULL);
d1831 1
a1831 1
			sigaction(SIGPIPE, &sapipe, NULL);
@


1.140
log
@ansi function declarations.

ok gcc+sha256
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.139 2014/10/12 08:55:25 dlg Exp $	*/
a164 1
int	 options;
a331 1
			options |= SO_DEBUG;
d963 1
a963 1
	if (strncmp(sep->se_proto, "tcp", 3) == 0 && (options & SO_DEBUG) &&
@


1.139
log
@cut out writing a pidfile. rc.d doesnt rely on it, and nor should you.

both bcook@@ and schwartz@@ suggested removing the pidfil unlink and path
ok sthen@@ schwartz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.138 2014/06/17 03:12:37 lteo Exp $	*/
d1748 1
a1748 3
machtime_stream(s, sep)
	int s;
	struct servtab *sep;
@


1.138
log
@Convert malloc/memset to calloc, and remove pointless casts while here.

From Benjamin Baier.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.137 2013/11/23 17:24:29 deraadt Exp $	*/
a273 1
void	logpid(void);
a386 1
	logpid();
a947 1
	(void)unlink(_PATH_INETDPID);
a1553 11
}

void
logpid(void)
{
	FILE *fp;

	if ((fp = fopen(_PATH_INETDPID, "w")) != NULL) {
		fprintf(fp, "%ld\n", (long)getpid());
		(void)fclose(fp);
	}
@


1.137
log
@obvious unsigned char casts for ctype
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.136 2013/11/12 19:44:44 deraadt Exp $	*/
d458 1
a458 1
			fdsrp = (fd_set *)calloc(allsockn, 1);
d1088 1
a1088 1
	sep = (struct servtab *)malloc(sizeof (*sep));
d1183 1
a1183 1
	sep = (struct servtab *) malloc(sizeof(struct servtab));
d1185 1
a1185 1
		syslog(LOG_ERR, "malloc: %m");
a1187 2

	memset(sep, 0, sizeof *sep);
d1513 1
a1513 1
	newtab = (struct servtab *) malloc(sizeof(struct servtab));
d1516 1
a1516 1
		syslog(LOG_ERR, "malloc: %m");
a1518 2

	memset(newtab, 0, sizeof(struct servtab));
@


1.136
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.135 2013/04/19 18:03:16 deraadt Exp $	*/
d769 2
a770 1
					if (isdigit(protoname[strlen(protoname) - 1]))
d825 2
a826 1
					if (isdigit(protoname[strlen(protoname) - 1]))
d1675 1
a1675 1
		if (isprint(i))
@


1.135
log
@for datagrams, assume other protocols should fail
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.134 2013/03/11 17:40:11 deraadt Exp $	*/
d292 6
@


1.134
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.133 2012/04/19 14:33:24 gsoares Exp $	*/
d569 2
a570 2
		/* XXX unsupported af, is it safe to assume it to be safe? */
		return 0;
@


1.133
log
@small cleanup(%hd -> %d)

yes deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.132 2009/11/02 20:03:01 otto Exp $	*/
d499 4
a502 3
		if (errno == EINTR)
			return -1;
		syslog(LOG_WARNING, "accept (for %s): %m", sep->se_service);
@


1.132
log
@we have closefrom(2), so use it; ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.131 2009/10/27 23:59:51 deraadt Exp $	*/
d1844 1
a1844 1
	    " wait.max=%hd.%d user:group=%s:%s builtin=%lx server=%s\n",
@


1.131
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.130 2008/07/28 15:42:07 claudio Exp $	*/
d1980 1
a1980 2
			for (tmpint = rlim_nofile_cur-1; --tmpint > 2; )
				(void)close(tmpint);
@


1.130
log
@Do not use __progname in inetd as it is not portable. Instead hardcode it to
"inetd" in the few locations that print out the program name.
requested and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.129 2008/07/27 10:06:10 claudio Exp $	*/
a30 11

#ifndef lint
char copyright[] =
"@@(#) Copyright (c) 1983 Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static const char sccsid[] = "from: @@(#)inetd.c	5.30 (Berkeley) 6/3/91";*/
static const char rcsid[] = "$OpenBSD: inetd.c,v 1.129 2008/07/27 10:06:10 claudio Exp $";
#endif /* not lint */
@


1.129
log
@Use __progname instead of hand rolled version using argv[0].
Diff from Gleydson Soares gsoares at gmail dot com
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.128 2008/06/28 10:54:45 sobrado Exp $	*/
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: inetd.c,v 1.128 2008/06/28 10:54:45 sobrado Exp $";
a302 1
extern char	*__progname;
d358 1
a358 2
			    "usage: %s [-d] [-R rate] [configuration_file]\n",
			    __progname);
d370 1
a370 2
		fprintf(stderr, "%s: non-root must specify a config file\n",
		    __progname);
d374 1
a374 2
		fprintf(stderr, "%s: more than one argument specified\n",
		    __progname);
d392 1
a392 1
	openlog(__progname, LOG_PID | LOG_NOWAIT, LOG_DAEMON);
@


1.128
log
@add an underscore to argument name.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.127 2008/06/04 18:11:35 miod Exp $	*/
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: inetd.c,v 1.127 2008/06/04 18:11:35 miod Exp $";
d303 1
a303 1
char	*progname;
d335 1
a335 4

	progname = strrchr(argv[0], '/');
	progname = progname ? progname + 1 : argv[0];

d360 1
a360 1
			    progname);
d373 1
a373 1
		    progname);
d378 1
a378 1
		    progname);
d396 1
a396 1
	openlog(progname, LOG_PID | LOG_NOWAIT, LOG_DAEMON);
@


1.127
log
@adderss -> address
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.126 2008/01/25 13:52:20 espie Exp $	*/
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: inetd.c,v 1.126 2008/01/25 13:52:20 espie Exp $";
d362 1
a362 1
			    "usage: %s [-d] [-R rate] [configuration file]\n",
@


1.126
log
@validate argv, okay otto@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.125 2008/01/05 09:53:42 jmc Exp $	*/
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: inetd.c,v 1.125 2008/01/05 09:53:42 jmc Exp $";
d574 1
a574 1
		 * OpenBSD does not support IPv4 mapped adderss (RFC2553
@


1.125
log
@sync usage() w/ SYNOPSIS;
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.124 2007/09/11 16:30:59 gilles Exp $	*/
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: inetd.c,v 1.124 2007/09/11 16:30:59 gilles Exp $";
d376 5
@


1.124
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.123 2005/04/02 18:10:52 otto Exp $	*/
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: inetd.c,v 1.123 2005/04/02 18:10:52 otto Exp $";
d361 2
a362 1
			fprintf(stderr, "usage: %s [-R rate] [-d] [conf]\n",
@


1.123
log
@Create unix domain sockets with permissions 0666, so clients can
actually access it. If you want unix domain sockets that are access
restricted, create them in a dir with restrictive permissions. PR 4141.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.122 2004/09/15 08:46:00 otto Exp $	*/
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: inetd.c,v 1.122 2004/09/15 08:46:00 otto Exp $";
a1496 2
	char *cp;

d1499 1
a1499 3
	cp = strchr(line, '\n');
	if (cp)
		*cp = '\0';
@


1.122
log
@if (signalflag) { dowork(); signalflag = 0; } is a race. First clear flag,
then call work(). ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.121 2004/09/14 22:28:41 deraadt Exp $	*/
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: inetd.c,v 1.121 2004/09/14 22:28:41 deraadt Exp $";
d379 1
d962 1
d1005 3
a1007 1
	} else
d1009 3
a1977 6
				if (sep->se_family == AF_UNIX &&
				    chown(sep->se_ctrladdr_un.sun_path,
				    pwd->pw_uid, pwd->pw_gid) < 0)
					syslog(LOG_WARNING,
					    "%s/%s: UNIX domain socket: %m",
					    sep->se_service, sep->se_proto);
@


1.121
log
@remove gcc specific extensions, and ARGSUSED where useful
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.120 2004/09/06 07:03:08 otto Exp $	*/
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: inetd.c,v 1.120 2004/09/06 07:03:08 otto Exp $";
d444 1
a445 1
				wantretry = 0;
d448 1
a449 1
				wantconfig = 0;
d452 1
a453 1
				wantreap = 0;
@


1.120
log
@Reset signal mask in the rate limiting case; check for interrupted
waits. Fixes zombies getting reaped late and other ignored signals.
Reported by mpech@@; fix by millert@@ with help from me. Commit requested
by deraadt@@. ok mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.119 2004/07/28 13:08:19 millert Exp $	*/
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: inetd.c,v 1.119 2004/07/28 13:08:19 millert Exp $";
a178 1
char	*curdom;
d189 1
a189 1
__typeof(((struct rlimit *)0)->rlim_cur)	rlim_nofile_cur = OPEN_MAX;
d614 1
d661 1
d896 1
d924 1
@


1.119
log
@Should set user and group on unix domain sockets as reported by Juan Vera.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.118 2004/06/30 07:58:12 otto Exp $	*/
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: inetd.c,v 1.118 2004/06/30 07:58:12 otto Exp $";
d496 1
a496 1
				spawn(sep, ctrl);
d632 3
a634 2
		pid = wait3(&status, WNOHANG, NULL);
		if (pid <= 0)
d636 1
d1891 2
@


1.118
log
@Unbreak unix domain sockets and properly detect and report truncation
of the socket path name. Based on a diff from Juan Vera, with changes
by me and millert@@.  ok millert@@ djm@@; man page ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.117 2004/04/24 21:40:35 millert Exp $	*/
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: inetd.c,v 1.117 2004/04/24 21:40:35 millert Exp $";
d1964 6
@


1.117
log
@Don't return NULL in getconfigent() when an unresolvable hostname
or unsupported address family is specified.  This simplifies the
hostname/address lookup loops and gets rid of the skip label.
Found by mpech@@.  OK deraadt@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.116 2004/03/31 19:12:22 millert Exp $	*/
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: inetd.c,v 1.116 2004/03/31 19:12:22 millert Exp $";
d669 1
a669 1
	int n, add;
d723 14
a737 9
			n = strlen(sep->se_service);
			if (n > sizeof sep->se_ctrladdr_un.sun_path - 1)
				n = sizeof sep->se_ctrladdr_un.sun_path - 1;
			strncpy(sep->se_ctrladdr_un.sun_path,
			    sep->se_service, n);
			sep->se_ctrladdr_un.sun_path[n] = '\0';
			sep->se_ctrladdr_un.sun_family = AF_UNIX;
			sep->se_ctrladdr_size = n +
			    sizeof sep->se_ctrladdr_un.sun_family;
a1248 6
		if (sep->se_hostaddr != NULL) {
			syslog(LOG_WARNING, "%s/%s: %s: host address "
			    "specifiers are not supported in the UNIX domain",
			    sep->se_service, sep->se_proto, sep->se_hostaddr);
			goto more;
		}
d1365 1
a1365 1
	if (sep->se_hostaddr != NULL) {
@


1.116
log
@For non-internal services, if no program arguments are specified use
the program's basename as argv[0].  Problem found by mpech@@.
OK deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.115 2004/01/06 19:45:54 millert Exp $	*/
d39 2
a40 2
/*static char sccsid[] = "from: @@(#)inetd.c	5.30 (Berkeley) 6/3/91";*/
static char rcsid[] = "$OpenBSD: inetd.c,v 1.115 2004/01/06 19:45:54 millert Exp $";
d685 1
a685 1
		if (sep != 0) {
d1165 2
a1166 1
	struct servtab *sep;
a1167 4
	char *cp, *arg, *s;
	char *hostdelim;
	struct servtab *nsep;
	struct servtab *psep;
d1200 3
a1202 1
		} else
d1244 6
d1251 2
d1256 11
d1363 2
a1364 3
	 * Now that we've processed the entire line, check if the hostname
	 * specifier was a comma separated list of hostnames. If so
	 * we'll make new entries for each address.
d1366 11
a1376 38
	while ((hostdelim = strrchr(sep->se_hostaddr, ',')) != NULL) {
		nsep = dupconfig(sep);

		/*
		 * NULL terminate the hostname field of the existing entry,
		 * and make a dup for the new entry.
		 */
		*hostdelim++ = '\0';
		nsep->se_hostaddr = newstr(hostdelim);

		nsep->se_next = sep->se_next;
		sep->se_next = nsep;
	}

	nsep = sep;
	while (nsep != NULL) {
		nsep->se_checked = 1;
		switch (nsep->se_family) {
		case AF_INET:
		case AF_INET6:
		    {
			struct addrinfo hints, *res0, *res;
			char *host, *port;
			int error;
			int s;

			/* check if the family is supported */
			s = socket(nsep->se_family, SOCK_DGRAM, 0);
			if (s < 0) {
				syslog(LOG_WARNING,
				    "%s/%s: %s: the address family is "
				    "not supported by the kernel",
				    nsep->se_service, nsep->se_proto,
				    nsep->se_hostaddr);
				nsep->se_checked = 0;
				goto skip;
			}
			close(s);
d1379 2
a1380 2
			hints.ai_family = nsep->se_family;
			hints.ai_socktype = nsep->se_socktype;
a1381 4
			if (!strcmp(nsep->se_hostaddr, "*"))
				host = NULL;
			else
				host = nsep->se_hostaddr;
d1384 2
a1385 1
			error = getaddrinfo(host, port, &hints, &res0);
d1388 3
a1390 5
				    nsep->se_service, nsep->se_proto,
				    nsep->se_hostaddr,
				    gai_strerror(error));
				nsep->se_checked = 0;
				goto skip;
d1394 1
a1394 5
				    sizeof(nsep->se_ctrladdr_storage))
					continue;
				if (res == res0) {
					memcpy(&nsep->se_ctrladdr_storage,
					    res->ai_addr, res->ai_addrlen);
a1395 9
				}

				psep = dupconfig(nsep);
				psep->se_hostaddr = newstr(nsep->se_hostaddr);
				psep->se_checked = 1;
				memcpy(&psep->se_ctrladdr_storage, res->ai_addr,
				    res->ai_addrlen);
				psep->se_ctrladdr_size = res->ai_addrlen;

d1397 2
a1398 2
				 * Prepend to list, don't want to look up its
				 * hostname again.
d1400 11
a1410 2
				psep->se_next = sep;
				sep = psep;
a1412 30
			break;
		    }
		}
skip:
		nsep = nsep->se_next;
	}

	/*
	 * Finally, free any entries which failed the gethostbyname
	 * check.
	 */
	psep = NULL;
	nsep = sep;
	while (nsep != NULL) {
		struct servtab *tsep;

		if (nsep->se_checked == 0) {
			tsep = nsep;
			if (psep == NULL) {
				sep = nsep->se_next;
				nsep = sep;
			} else {
				nsep = nsep->se_next;
				psep->se_next = nsep;
			}
			freeconfig(tsep);
		} else {
			nsep->se_checked = 0;
			psep = nsep;
			nsep = nsep->se_next;
d1414 3
d1427 16
a1442 15
	if (cp->se_hostaddr)
		free(cp->se_hostaddr);
	if (cp->se_service)
		free(cp->se_service);
	if (cp->se_proto)
		free(cp->se_proto);
	if (cp->se_user)
		free(cp->se_user);
	if (cp->se_group)
		free(cp->se_group);
	if (cp->se_server)
		free(cp->se_server);
	for (i = 0; i < MAXARGV; i++)
		if (cp->se_argv[i])
			free(cp->se_argv[i]);
@


1.115
log
@Fix signal handling when there is an error in inetd.conf.  Found by
mpech@@.  OK mpech@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.114 2003/12/23 15:24:28 mpech Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.114 2003/12/23 15:24:28 mpech Exp $";
d1334 7
d2019 1
a2019 1
				fprintf(stderr, "%ld execl %s\n",
@


1.114
log
@Remove unnecessary casts (char *).

millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.113 2003/10/24 20:30:02 avsm Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.113 2003/10/24 20:30:02 avsm Exp $";
d432 1
d436 1
a436 1
				if (wantretry || wantconfig || wantreap)
d443 1
a443 1
		if (wantretry || wantconfig || wantreap || wantdie) {
d458 1
a458 1
			continue;
@


1.113
log
@dont compare int to NULL, millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.112 2003/10/03 22:43:37 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.112 2003/10/03 22:43:37 deraadt Exp $";
d410 1
a410 1
	memset((char *)&sa, 0, sizeof(sa));
d882 1
a882 1
		free((char *)sep);
d957 1
a957 1
setsockopt(fd, SOL_SOCKET, opt, (char *)&on, sizeof (on))
d1188 1
a1188 1
	memset((char *)sep, 0, sizeof *sep);
d1806 1
a1806 1
	(void) write(s, (char *) &result, sizeof(result));
d1818 1
a1818 1
	if (recvfrom(s, (char *)&result, sizeof(result), 0,
d1824 1
a1824 1
	(void) sendto(s, (char *) &result, sizeof(result), 0,
@


1.112
log
@exit if no config file; jeffi@@rcn.com
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.111 2003/06/26 19:47:08 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.111 2003/06/26 19:47:08 deraadt Exp $";
d351 1
a351 1
			if (val >= 1 && *p == NULL) {
@


1.111
log
@strict proto cleanups
@
text
@d1 2
a2 2
/*	$OpenBSD: inetd.c,v 1.110 2003/06/02 23:36:53 millert Exp $	*/
/*	$NetBSD: inetd.c,v 1.11 1996/02/22 11:14:41 mycroft Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.110 2003/06/02 23:36:53 millert Exp $";
d674 1
a674 1
		return;
d1137 2
a1138 1
	if (defhost) free(defhost);
@


1.110
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.109 2003/04/28 02:58:45 itojun Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.109 2003/04/28 02:58:45 itojun Exp $";
d1833 1
a1833 1
	time_t time(), clock;
d1847 1
a1847 1
	time_t time(), clock;
@


1.109
log
@advocate posix ":" for user:group.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.108 2002/11/11 23:46:29 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.108 2002/11/11 23:46:29 millert Exp $";
@


1.108
log
@Pass gcc -ansi -pedantic; Chad Loder
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.107 2002/09/06 19:46:52 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.107 2002/09/06 19:46:52 deraadt Exp $";
d1889 1
a1889 1
	    " wait.max=%hd.%d user:group=%s.%s builtin=%lx server=%s\n",
@


1.107
log
@use more socklen_t; pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.106 2002/07/20 18:01:18 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.106 2002/07/20 18:01:18 deraadt Exp $";
d194 1
a194 1
typeof(((struct rlimit *)0)->rlim_cur)	rlim_nofile_cur = OPEN_MAX;
d691 1
a691 1
#define SWAP(type, a, b) {type c=(type)a; (type)a=(type)b; (type)b=(type)c;}
@


1.106
log
@abort on setusercontext failure; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.105 2002/07/15 23:05:17 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.105 2002/07/15 23:05:17 deraadt Exp $";
d1663 2
a1664 1
	int i, size;
d1753 2
a1754 1
	int len, size;
d1818 1
a1818 1
	int size;
@


1.105
log
@minor tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.104 2002/07/15 22:26:31 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.104 2002/07/15 22:26:31 deraadt Exp $";
d2004 1
a2004 1
				    tmpint) < 0)
d2008 2
@


1.104
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.103 2002/07/04 12:36:56 itojun Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.103 2002/07/04 12:36:56 itojun Exp $";
d1374 2
a1375 1
"%s/%s: %s: the address family is not supported by the kernel",
d1709 1
a1709 1
	for (i = 0; i <= 128; ++i)
@


1.103
log
@correct udp-from-broadcast check.  from <andre@@ae-35.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.102 2002/06/28 22:41:10 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.102 2002/06/28 22:41:10 deraadt Exp $";
d301 1
d304 1
d333 1
a333 3
main(argc, argv)
	int argc;
	char *argv[];
d506 1
a506 2
gettcp(sep)
	struct servtab *sep;
d545 1
a545 2
dg_badinput(sa)
	struct sockaddr *sa;
d597 1
a597 2
dg_broadcast(in)
	struct in_addr *in;
a948 2
int bump_nofile(void);

d950 1
a950 2
setup(sep)
	struct servtab *sep;
d1023 1
a1023 2
register_rpc(sep)
	struct servtab *sep;
d1056 1
a1056 2
unregister_rpc(sep)
	struct servtab *sep;
d1072 1
a1072 2
enter(cp)
	struct servtab *cp;
d1093 1
a1093 3
matchconf (old, new)
	struct servtab	*old;
	struct servtab	*new;
d1139 1
a1139 1
setconfig()
d1152 1
a1152 1
endconfig()
d1165 1
a1165 1
getconfigent()
d1463 1
a1463 2
freeconfig(cp)
	struct servtab *cp;
d1485 1
a1485 3
skip(cpp, report)
	char **cpp;
	int report;
d1523 1
a1523 2
nextline(fd)
	FILE *fd;
d1536 1
a1536 2
newstr(cp)
	char *cp;
d1545 1
a1545 2
dupconfig(sep)
	struct servtab *sep;
d1581 1
a1581 3
inetd_setproctitle(a, s)
	char *a;
	int s;
d1599 1
a1599 1
logpid()
d1610 1
a1610 1
bump_nofile()
d1645 1
a1645 3
echo_stream(s, sep)		/* Echo service -- echo data back */
	int s;
	struct servtab *sep;
d1659 1
a1659 3
echo_dg(s, sep)			/* Echo service -- echo data back */
	int s;
	struct servtab *sep;
d1676 1
a1676 3
discard_stream(s, sep)		/* Discard service -- ignore data */
	int s;
	struct servtab *sep;
d1689 1
a1689 3
discard_dg(s, sep)		/* Discard service -- ignore data */
	int s;
	struct servtab *sep;
d1702 1
a1702 1
initring()
d1715 1
a1715 3
chargen_stream(s, sep)		/* Character generator */
	int s;
	struct servtab *sep;
d1747 1
a1747 3
chargen_dg(s, sep)		/* Character generator */
	int s;
	struct servtab *sep;
a1785 1

d1787 1
a1787 1
machtime()
d1811 1
a1811 3
machtime_dg(s, sep)
	int s;
	struct servtab *sep;
d1828 1
d1831 1
a1831 3
daytime_stream(s, sep)		/* Return human-readable time of day */
	int s;
	struct servtab *sep;
d1842 1
d1845 1
a1845 3
daytime_dg(s, sep)		/* Return human-readable time of day */
	int s;
	struct servtab *sep;
d1870 1
a1870 3
print_service(action, sep)
	char *action;
	struct servtab *sep;
d1893 1
a1893 3
spawn(sep, ctrl)
	struct servtab *sep;
	int ctrl;
@


1.102
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.101 2002/06/21 07:30:09 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.101 2002/06/21 07:30:09 deraadt Exp $";
d611 1
a611 1
		sin = (struct sockaddr_in *)ifa->ifa_addr;
@


1.101
log
@kill gratuitous hex; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.100 2002/06/21 06:20:28 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.100 2002/06/21 06:20:28 millert Exp $";
d1303 2
a1304 1
			syslog(LOG_ERR, "%s: illegal max field \"%s\", setting to %d",
d1689 2
a1690 2
	if ((i = recvfrom(s, buffer, sizeof(buffer), 0, (struct sockaddr *)&ss,
	    &size)) < 0)
@


1.100
log
@o change some 0-2 to *_FILENO
o don't #ifdef RLIMIT_NOFILE
o dup2() safety
o some NULL vs. 0 changes

deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.99 2002/06/07 07:37:41 itojun Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.99 2002/06/07 07:37:41 itojun Exp $";
d648 1
a648 1
					    "%s: exit status 0x%x",
d652 1
a652 1
					    "%s: exit signal 0x%x",
@


1.99
log
@do not respond to udp service if ip_src matches broadcast addr.  theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.98 2002/06/01 03:42:06 itojun Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.98 2002/06/01 03:42:06 itojun Exp $";
a148 4
#ifndef RLIMIT_NOFILE
#define RLIMIT_NOFILE	RLIMIT_OFILE
#endif

d194 1
a194 1
typeof(((struct rlimit *)0)->rlim_cur)	rlim_ofile_cur = OPEN_MAX;
d196 1
a196 3
#ifdef RLIMIT_NOFILE
struct rlimit	rlim_ofile;
#endif
d400 1
a400 2
#ifdef RLIMIT_NOFILE
	if (getrlimit(RLIMIT_NOFILE, &rlim_ofile) < 0) {
d403 3
a405 3
		rlim_ofile_cur = rlim_ofile.rlim_cur;
		if (rlim_ofile_cur == RLIM_INFINITY)	/* ! */
			rlim_ofile_cur = OPEN_MAX;
a406 1
#endif
d1023 1
a1023 1
		if (maxsock > rlim_ofile_cur - FD_MARGIN)
d1573 1
a1573 1
	memset((char *)newtab, 0, sizeof(struct servtab));
a1629 2
#ifdef RLIMIT_NOFILE

d1640 1
a1640 1
	if (rl.rlim_cur <= rlim_ofile_cur) {
d1652 1
a1652 1
	rlim_ofile_cur = rl.rlim_cur;
a1653 5

#else
	syslog(LOG_ERR, "bump_nofile: cannot extend file limit");
	return -1;
#endif
d1885 1
a1885 1
	int size;
d1887 1
a1887 1
	clock = time((time_t *) 0);
d2041 1
a2041 1
				if (setusercontext(0, pwd, pwd->pw_uid,
d2050 6
a2055 4
			dup2(ctrl, 0);
			close(ctrl);
			dup2(0, 1);
			dup2(0, 2);
d2057 1
a2057 1
			for (tmpint = rlim_ofile_cur-1; --tmpint > 2; )
@


1.98
log
@machtime() is 32bit quantity.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.97 2002/06/01 01:57:44 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.97 2002/06/01 01:57:44 deraadt Exp $";
d153 1
d169 1
d572 2
a573 1
		/* XXX should check for subnet broadcast using getifaddrs(3) */
d606 23
a2082 1

@


1.97
log
@i find more: a stderr print that makes no sense, and a part that was
used by the fake setproctitle.  itojun -- your turn.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.96 2002/05/31 23:48:41 itojun Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.96 2002/05/31 23:48:41 itojun Exp $";
d1806 1
a1806 1
u_int
d1814 1
a1814 1
	return (htonl((u_int)tv.tv_sec + 2208988800UL));
d1823 1
a1823 1
	u_int result;
d1835 1
a1835 1
	u_int result;
@


1.96
log
@cleanup socklen_t
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.95 2002/05/31 22:20:18 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.95 2002/05/31 22:20:18 deraadt Exp $";
d297 10
a438 11
	{
		/* space for daemons to overwrite environment for ps */
#define	DUMMYSIZE	100
		char dummy[DUMMYSIZE];

		(void)memset(dummy, 'x', DUMMYSIZE - 1);
		dummy[DUMMYSIZE - 1] = '\0';

		(void)setenv("inetd_dummy", dummy, 1);
	}

d541 1
a541 2
			 * ignore things that
			 * look like ftp bounce
a646 12
int setconfig(void);
void endconfig(void);

void register_rpc(struct servtab *);
void unregister_rpc(struct servtab *);
void freeconfig(struct servtab *);
void print_service(char *, struct servtab *);
void setup(struct servtab *);
struct servtab *getconfigent(void);
struct servtab *enter(struct servtab *);
int matchconf(struct servtab *, struct servtab *);

d1811 1
a1811 2
	if (gettimeofday(&tv, NULL) < 0) {
		fprintf(stderr, "Unable to get time of day\n");
d1813 1
a1813 1
	}
@


1.95
log
@split out two major function blocks which made the indentation horrible
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.94 2002/05/31 20:20:53 itojun Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.94 2002/05/31 20:20:53 itojun Exp $";
d530 1
a530 1
		int plen = sizeof(peer);
d988 1
a988 1
				int len = sep->se_ctrladdr_size;
d1028 1
a1028 1
	int n;
@


1.94
log
@use setproctitle(3).  check for IPv6 ftp bounce attack.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.93 2002/05/30 19:09:05 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.93 2002/05/30 19:09:05 deraadt Exp $";
a176 9
void	config(int);
void	doconfig(void);
void	reap(int);
void	doreap(void);
void	retry(int);
void	doretry(void);
void	die(int);
void	dodie(void);

d286 12
a301 2
void logpid(void);

d322 2
d329 3
a333 10
	struct servtab *sep;
	struct passwd *pwd;
	struct group *grp = NULL;
	int tmpint;
	struct sigaction sa, sapipe;
	int ch, dofork;
	pid_t pid;
	char buf[50];
	fd_set *readablep = NULL;
	int readablen = 0;
d339 1
a339 1
		switch(ch) {
d441 1
a441 1
	    int n, ctrl = -1;
d443 8
a450 6
	    if (nsock == 0) {
		(void) sigprocmask(SIG_BLOCK, &blockmask, NULL);
		while (nsock == 0) {
		    if (wantretry || wantconfig || wantreap)
			break;
		    sigsuspend(&emptymask);
a451 2
		(void) sigprocmask(SIG_SETMASK, &emptymask, NULL);
	    }
d453 8
a460 53
	    if (wantretry || wantconfig || wantreap || wantdie) {
		if (wantretry) {
		    doretry();
		    wantretry = 0;
		}
		if (wantconfig) {
		    doconfig();
		    wantconfig = 0;
		}
		if (wantreap) {
		    doreap();
		    wantreap = 0;
		}
		if (wantdie) {
		    dodie();
		}
		continue;
	    }

	    if (readablen != allsockn) {
		if (readablep)
		    free(readablep);
		readablep = (fd_set *)calloc(allsockn, 1);
		if (readablep == NULL) {
		    syslog(LOG_ERR, "Out of memory.");
		    exit(1);
		}
		readablen = allsockn;
	    }
	    bcopy(allsockp, readablep, allsockn);

	    if ((n = select(maxsock + 1, readablep, NULL, NULL, NULL)) <= 0) {
		    if (n < 0 && errno != EINTR) {
			syslog(LOG_WARNING, "select: %m");
			sleep(1);
		    }
		    continue;
	    }
	    for (sep = servtab; n && sep; sep = sep->se_next)
	    if (sep->se_fd != -1 && FD_ISSET(sep->se_fd, readablep)) {
		n--;
		if (debug)
			fprintf(stderr, "someone wants %s\n", sep->se_service);
		if (!sep->se_wait && sep->se_socktype == SOCK_STREAM) {
			ctrl = accept(sep->se_fd, NULL, NULL);
			if (debug)
				fprintf(stderr, "accept, ctrl %d\n", ctrl);
			if (ctrl < 0) {
				if (errno == EINTR)
					continue;
				syslog(LOG_WARNING, "accept (for %s): %m",
				    sep->se_service);
				continue;
d462 3
a464 23
			if ((sep->se_family == AF_INET ||
			     sep->se_family == AF_INET6) &&
			    sep->se_socktype == SOCK_STREAM) {
				struct sockaddr_storage peer;
				int plen = sizeof(peer);
				char sbuf[NI_MAXSERV];

				if (getpeername(ctrl, (struct sockaddr *)&peer,
				    &plen) < 0) {
					syslog(LOG_WARNING, "could not getpeername");
					close(ctrl);
					continue;
				}
				if (getnameinfo((struct sockaddr *)&peer, plen,
				    NULL, 0, sbuf, sizeof(sbuf),
				    NI_NUMERICSERV) == 0 && atoi(sbuf) == 20) {
					/*
					 * ignore things that look like
					 * ftp bounce
					 */
					close(ctrl);
					continue;
				}
d466 12
a477 50
		} else
			ctrl = sep->se_fd;
		(void) sigprocmask(SIG_BLOCK, &blockmask, NULL);
		pid = 0;
		dofork = (sep->se_bi == 0 || sep->se_bi->bi_fork);
		if (dofork) {
			if (sep->se_count++ == 0)
			    (void)gettimeofday(&sep->se_time, NULL);
			else if (sep->se_count >= sep->se_max) {
				struct timeval now;

				(void)gettimeofday(&now, NULL);
				if (now.tv_sec - sep->se_time.tv_sec >
				    CNT_INTVL) {
					sep->se_time = now;
					sep->se_count = 1;
				} else {
					if (!sep->se_wait &&
					    sep->se_socktype == SOCK_STREAM)
						close(ctrl);
					if (sep->se_family == AF_INET &&
					    ntohs(sep->se_ctrladdr_in.sin_port) >=
					    IPPORT_RESERVED) {
						/*
						 * Cannot close it -- there are
						 * thieves on the system.
						 * Simply ignore the connection.
						 */
						--sep->se_count;
						continue;
					}
					syslog(LOG_ERR,
			"%s/%s server failing (looping), service terminated",
					    sep->se_service, sep->se_proto);
					if (!sep->se_wait &&
					    sep->se_socktype == SOCK_STREAM)
						close(ctrl);
					FD_CLR(sep->se_fd, allsockp);
					(void) close(sep->se_fd);
					sep->se_fd = -1;
					sep->se_count = 0;
					nsock--;
					sigprocmask(SIG_SETMASK, &emptymask,
					    NULL);
					if (!timingout) {
						timingout = 1;
						alarm(RETRYTIME);
					}
					continue;
				}
d479 1
a479 1
			pid = fork();
d481 7
a487 6
		if (pid < 0) {
			syslog(LOG_ERR, "fork: %m");
			if (!sep->se_wait && sep->se_socktype == SOCK_STREAM)
				close(ctrl);
			sigprocmask(SIG_SETMASK, &emptymask, NULL);
			sleep(1);
d490 7
a496 20
		if (pid && sep->se_wait) {
			sep->se_wait = pid;
			FD_CLR(sep->se_fd, allsockp);
			nsock--;
		}
		sigprocmask(SIG_SETMASK, &emptymask, NULL);
		if (pid == 0) {
			if (sep->se_bi)
				(*sep->se_bi->bi_fn)(ctrl, sep);
			else {
				if ((pwd = getpwnam(sep->se_user)) == NULL) {
					syslog(LOG_ERR,
					    "getpwnam: %s: No such user",
					    sep->se_user);
					if (sep->se_socktype != SOCK_STREAM)
						recv(0, buf, sizeof (buf), 0);
					exit(1);
				}
				if (setsid() <0)
					syslog(LOG_ERR, "%s: setsid: %m",
d498 9
a506 45
				if (sep->se_group &&
				    (grp = getgrnam(sep->se_group)) == NULL) {
					syslog(LOG_ERR,
					    "getgrnam: %s: No such group",
					    sep->se_group);
					if (sep->se_socktype != SOCK_STREAM)
						recv(0, buf, sizeof (buf), 0);
					exit(1);
				}
				if (uid != 0) {
					/* a user running private inetd */
					if (uid != pwd->pw_uid)
						exit(1);
				} else {
					tmpint = LOGIN_SETALL &
					    ~(LOGIN_SETGROUP|LOGIN_SETLOGIN);
					if (pwd->pw_uid)
						tmpint |= LOGIN_SETGROUP|LOGIN_SETLOGIN;
					if (sep->se_group) {
						pwd->pw_gid = grp->gr_gid;
						tmpint |= LOGIN_SETGROUP;
					}
					if (setusercontext(0, pwd, pwd->pw_uid,
					    tmpint) < 0)
						syslog(LOG_ERR,
						    "%s/%s: setusercontext: %m",
						    sep->se_service,
						    sep->se_proto);
				}
				if (debug)
					fprintf(stderr, "%ld execl %s\n",
					    (long)getpid(), sep->se_server);
				dup2(ctrl, 0);
				close(ctrl);
				dup2(0, 1);
				dup2(0, 2);
				closelog();
				for (tmpint = rlim_ofile_cur-1; --tmpint > 2; )
					(void)close(tmpint);
				sigaction(SIGPIPE, &sapipe, NULL);
				execv(sep->se_server, sep->se_argv);
				if (sep->se_socktype != SOCK_STREAM)
					recv(0, buf, sizeof (buf), 0);
				syslog(LOG_ERR, "execv %s: %m", sep->se_server);
				exit(1);
d509 36
a544 1
		if (!sep->se_wait && sep->se_socktype == SOCK_STREAM)
d546 2
a547 1
	    }
d549 1
d552 1
d1932 141
@


1.93
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.92 2002/05/29 19:23:34 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.92 2002/05/29 19:23:34 deraadt Exp $";
a296 2
char	**Argv;
char	*LastArg;
d322 1
a322 1
main(argc, argv, envp)
d324 1
a324 1
	char *argv[], *envp[];
a338 7
	Argv = argv;
	if (envp == 0 || *envp == 0)
		envp = argv;
	while (*envp)
		envp++;
	LastArg = envp[-1] + strlen(envp[-1]);

d511 2
a512 1
			if (sep->se_family == AF_INET &&
d514 1
a514 1
				struct sockaddr_in peer;
d516 1
d524 7
a530 2
				if (ntohs(peer.sin_port) == 20) {
					/* ignore things that look like ftp bounce */
d1714 13
a1726 20
	int size;
	char *cp;
	struct sockaddr_in sin;
	char buf[80];

	cp = Argv[0];
	size = sizeof(sin);
	(void) snprintf(buf, sizeof buf, "-%s", a);
	if (getpeername(s, (struct sockaddr *)&sin, &size) == 0) {
		char *s = inet_ntoa(sin.sin_addr);

		buf[sizeof(buf) - 1 - strlen(s) - 3] = '\0';
		strlcat(buf, " [", sizeof buf);
		strlcat(buf, s, sizeof buf);
		strlcat(buf, "]", sizeof buf);
	}
	strncpy(cp, buf, LastArg - cp);
	cp += strlen(cp);
	while (cp < LastArg)
		*cp++ = ' ';
@


1.92
log
@more strlcat
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.91 2002/05/26 09:25:21 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.91 2002/05/26 09:25:21 deraadt Exp $";
d64 1
a64 1
 * the second type of server ``single-threaded''. 
d120 6
a125 6
 * 
 * 	a) user = root:	NO setuid() or setgid() is done
 * 
 * 	b) other:	setgid(primary group as found in passwd)
 * 			initgroups(name, primary group)
 * 			setuid()
a127 4
 * 
 * 	a) user = root:	setgid(specified group)
 * 			NO initgroups()
 * 			NO setuid()
d129 8
a136 4
 * 	b) other:	setgid(specified group)
 * 			initgroups(name, specified group)
 * 			setuid()
 * 
d424 1
a424 1
	sigemptyset(&sa.sa_mask);	
d465 1
a465 1
	    
d815 1
a815 1
			 * it unless the config file explicitly says don't 
d818 1
a818 1
			if (cp->se_bi == 0 && 
d846 1
a846 1
			if (n > sizeof sep->se_ctrladdr_un.sun_path - 1) 
d1309 1
a1309 1
	
d1316 1
a1316 1
	
d1368 1
a1368 1
	
d1398 1
a1398 1
				l = strtol(cp, &ccp, 0); 
d1438 1
a1438 1
	
d1624 1
a1624 1
	
@


1.91
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.90 2002/05/22 09:09:32 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.90 2002/05/22 09:09:32 deraadt Exp $";
d1728 3
a1730 3
		strcat(buf, " [");
		strcat(buf, s);
		strcat(buf, "]");
@


1.90
log
@more strcpy/sprintf death; mpech ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.89 2002/03/14 16:44:25 mpech Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.89 2002/03/14 16:44:25 mpech Exp $";
d649 2
a650 2
					fprintf(stderr, "%d execl %s\n",
					    getpid(), sep->se_server);
d733 2
a735 2
	int status;
	struct servtab *sep;
d745 2
a746 1
			fprintf(stderr, "%d reaped, status %x\n", pid, status);
d1744 1
a1744 1
		fprintf(fp, "%u\n", getpid());
@


1.89
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.88 2002/02/16 21:28:03 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.88 2002/02/16 21:28:03 millert Exp $";
d2001 1
a2001 1
	(void) sprintf(buffer, "%.24s\r\n", ctime(&clock));
d2024 1
a2024 1
	(void) sprintf(buffer, "%.24s\r\n", ctime(&clock));
@


1.88
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.87 2002/02/10 01:19:02 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.87 2002/02/10 01:19:02 millert Exp $";
d330 4
a333 4
	register struct servtab *sep;
	register struct passwd *pwd;
	register struct group *grp = NULL;
	register int tmpint;
d735 1
a735 1
	register struct servtab *sep;
d788 1
a788 1
	register struct servtab *sep, *cp, **sepp;
d1017 1
a1017 1
	register struct servtab *sep;
d1044 1
a1044 1
	register struct servtab *sep;
d1070 1
a1070 1
	register struct servtab *sep;
d1144 1
a1144 1
	register struct servtab *sep;
d1178 1
a1178 1
	register struct servtab *sep;
d1197 1
a1197 1
	register struct servtab *sep;
d1292 1
a1292 1
	register struct servtab *sep;
d1588 1
a1588 1
	register struct servtab *cp;
d1716 1
a1716 1
	register char *cp;
d1858 1
a1858 1
	register int i;
d1873 1
a1873 1
	register char *rs;
@


1.87
log
@Fix SIGTERM handling; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.86 2001/11/05 09:43:50 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.86 2001/11/05 09:43:50 deraadt Exp $";
d177 8
a184 8
void	config __P((int));
void	doconfig __P((void));
void	reap __P((int));
void	doreap __P((void));
void	retry __P((int));
void	doretry __P((void));
void	die __P((int));
void	dodie __P((void));
d249 10
a258 10
void echo_stream __P((int, struct servtab *));
void discard_stream __P((int, struct servtab *));
void machtime_stream __P((int, struct servtab *));
void daytime_stream __P((int, struct servtab *));
void chargen_stream __P((int, struct servtab *));
void echo_dg __P((int, struct servtab *));
void discard_dg __P((int, struct servtab *));
void machtime_dg __P((int, struct servtab *));
void daytime_dg __P((int, struct servtab *));
void chargen_dg __P((int, struct servtab *));
d265 1
a265 1
	void	(*bi_fn) __P((int, struct servtab *));
d301 1
a301 1
void logpid __P((void));
d767 2
a768 2
int setconfig __P((void));
void endconfig __P((void));
d770 8
a777 8
void register_rpc __P((struct servtab *));
void unregister_rpc __P((struct servtab *));
void freeconfig __P((struct servtab *));
void print_service __P((char *, struct servtab *));
void setup __P((struct servtab *));
struct servtab *getconfigent __P((void));
struct servtab *enter __P((struct servtab *));
int matchconf __P((struct servtab *, struct servtab *));
d1066 1
a1066 1
int bump_nofile __P((void));
d1258 4
a1261 4
char		*skip __P((char **, int));
char		*nextline __P((FILE *));
char		*newstr __P((char *));
struct servtab	*dupconfig __P((struct servtab *));
@


1.86
log
@remove last signal race
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.85 2001/09/04 23:35:59 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.85 2001/09/04 23:35:59 millert Exp $";
d466 1
a466 1
	    if (wantretry || wantconfig || wantreap) {
@


1.85
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.84 2001/09/03 21:22:38 pjanzen Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.84 2001/09/03 21:22:38 pjanzen Exp $";
d183 2
a184 1
void	goaway __P((int));
d290 4
a293 3
sig_atomic_t wantretry;
sig_atomic_t wantconfig;
sig_atomic_t wantreap;
d435 1
a435 1
	sa.sa_handler = goaway;
d437 1
a437 1
	sa.sa_handler = goaway;
d479 3
d532 1
a532 1
					/* XXX ftp bounce */
d691 1
a691 1
		/* XXX check for subnet broadcast using getifaddrs(3) */
d882 1
a882 1
					/*XXX*/
d937 1
a937 1
					/*XXX*/
d1036 7
a1042 2
goaway(sig)
	int sig;
a1045 1
	/* XXX signal race walking sep list */
d1057 1
a1057 1
				unregister_rpc(sep);	/* XXX signal race */
d1063 1
a1063 1
	_exit(0);
@


1.84
log
@doreap() needn't preserve errno, since it's not a signal handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.83 2001/07/04 06:46:58 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.83 2001/07/04 06:46:58 deraadt Exp $";
a176 2
#define	SIGBLOCK	(sigmask(SIGCHLD)|sigmask(SIGHUP)|sigmask(SIGALRM))

d185 2
a186 2
int	debug = 0;
int	nsock, maxsock;
d188 5
a192 5
int	allsockn;
int	toomany = TOOMANY;
int	options;
int	timingout;
struct	servent *sp;
d194 3
a196 1
uid_t	uid;
d415 6
d455 1
a455 1
		(void) sigblock(SIGBLOCK);
d459 1
a459 1
		    sigpause(0L);
d461 1
a461 1
		(void) sigsetmask(0L);
d534 1
a534 1
		(void) sigblock(SIGBLOCK);
d574 2
a575 1
					sigsetmask(0L);
d589 1
a589 1
			sigsetmask(0L);
d598 1
a598 1
		sigsetmask(0L);
a783 1
	int omask;
d786 1
d805 1
a805 1
			omask = sigblock(SIGBLOCK);
d826 1
a826 1
			sigsetmask(omask);
d978 1
a978 1
	omask = sigblock(SIGBLOCK);
d1000 1
a1000 1
	(void) sigsetmask(omask);
d1189 1
a1189 1
	int omask;
d1199 1
a1199 1
	omask = sigblock(SIGBLOCK);
d1202 1
a1202 1
	sigsetmask(omask);
@


1.83
log
@cleanup; itojun & jasoni
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.82 2001/03/15 18:28:41 danh Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.82 2001/03/15 18:28:41 danh Exp $";
d722 1
a722 1
	int save_errno = errno, status;
a752 1
	errno = save_errno;
@


1.82
log
@break out of loop if a flag is set; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.81 2001/03/15 18:07:57 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.81 2001/03/15 18:07:57 deraadt Exp $";
d157 1
d296 1
a296 1
char 	*LastArg;
a664 1
#ifdef INET6
a665 1
#endif
a666 1
	int i;
a680 1
#ifdef INET6
a697 1
#endif
@


1.82.2.1
log
@Pull in patch from current:
Fix (deraadt):
cleanup; itojun & jasoni (adds checking of IPv6 udp source port)
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.82 2001/03/15 18:28:41 danh Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.82 2001/03/15 18:28:41 danh Exp $";
a156 1
#include <ctype.h>
d295 1
a295 1
char	*LastArg;
d664 1
d666 1
d668 1
d683 1
d701 1
@


1.81
log
@spin even cheaper
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.80 2001/03/15 17:53:09 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.80 2001/03/15 17:53:09 deraadt Exp $";
d449 3
a451 1
		while (nsock == 0)
d453 1
@


1.80
log
@check all flags before looping
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.79 2001/01/30 08:30:57 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.79 2001/01/30 08:30:57 deraadt Exp $";
a453 12
	    if (readablen != allsockn) {
		if (readablep)
		    free(readablep);
		readablep = (fd_set *)calloc(allsockn, 1);
		if (readablep == NULL) {
		    syslog(LOG_ERR, "Out of memory.");
		    exit(1);
		}
		readablen = allsockn;
	    }
	    bcopy(allsockp, readablep, allsockn);

d469 12
@


1.79
log
@check for invalid [.max] fields
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.75 2001/01/29 11:23:28 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.75 2001/01/29 11:23:28 deraadt Exp $";
d466 13
a478 13
	    if (wantretry) {
		doretry();
		wantretry = 0;
		continue;
	    }
	    if (wantconfig) {
		doconfig();
		wantconfig = 0;
		continue;
	    }
	    if (wantreap) {
		doreap();
		wantreap = 0;
@


1.78
log
@mark signal races
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.77 2001/01/29 21:07:36 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.77 2001/01/29 21:07:36 deraadt Exp $";
d1398 2
d1401 6
a1406 1
		sep->se_max = atoi(s);
@


1.77
log
@do not _exit() in fork()'d child
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.76 2001/01/29 21:06:43 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.76 2001/01/29 21:06:43 deraadt Exp $";
d1031 1
d1043 1
a1043 1
				unregister_rpc(sep);
@


1.76
log
@do not exit(-1)
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.75 2001/01/29 11:23:28 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.75 2001/01/29 11:23:28 deraadt Exp $";
d598 1
a598 1
					_exit(1);
d610 1
a610 1
					_exit(1);
d615 1
a615 1
						_exit(1);
d647 1
a647 1
				_exit(1);
d1662 1
a1662 1
		exit (-1);
@


1.75
log
@use _exit() in signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.74 2001/01/17 19:30:03 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.74 2001/01/17 19:30:03 deraadt Exp $";
d312 1
a312 1
			exit(-1);
d460 1
a460 1
		    exit(-1);
d1188 1
a1188 1
		exit(-1);
d1287 1
a1287 1
		exit(-1);
d1648 1
a1648 1
	exit(-1);
@


1.74
log
@use sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.73 2001/01/16 23:57:37 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.73 2001/01/16 23:57:37 deraadt Exp $";
d1048 1
a1048 1
	exit(0);
@


1.73
log
@check flags every loop, not just on EINTR
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.72 2001/01/12 16:34:03 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.72 2001/01/12 16:34:03 deraadt Exp $";
d288 3
a290 3
volatile int wantretry;
volatile int wantconfig;
volatile int wantreap;
@


1.72
log
@un-race three signal handlers, and fix the fd_set overflow gunk
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.71 2000/11/21 07:23:24 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.71 2000/11/21 07:23:24 deraadt Exp $";
d466 16
a485 12
		    }
		    if (wantretry) {
			doretry();
			wantretry = 0;
		    }
		    if (wantconfig) {
			doconfig();
			wantconfig = 0;
		    }
		    if (wantreap) {
			doreap();
			wantreap = 0;
@


1.71
log
@bye bye MULOG.  code that is easy to read, is code that is easy to audit
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.70 2000/11/09 02:55:42 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.70 2000/11/09 02:55:42 deraadt Exp $";
a177 1

d179 3
a181 1
void	reapchild __P((int));
d183 1
d188 2
a189 1
fd_set	allsock;
d288 4
d300 20
d335 2
d421 1
a421 1
	config(SIGHUP);
d424 1
a424 1
	sa.sa_handler = reapchild;
a445 1
	    fd_set readable;
d453 14
a466 2
	    readable = allsock;
	    if ((n = select(maxsock + 1, &readable, NULL, NULL, NULL)) <= 0) {
d471 12
d486 1
a486 1
	    if (sep->se_fd != -1 && FD_ISSET(sep->se_fd, &readable)) {
d555 1
a555 1
					FD_CLR(sep->se_fd, &allsock);
d580 1
a580 1
			FD_CLR(sep->se_fd, &allsock);
d710 7
a716 2
reapchild(sig)
	int sig;
d722 3
d742 2
a743 1
				FD_SET(sep->se_fd, &allsock);
d766 7
a772 2
config(sig)
	int sig;
d886 1
a886 1
						FD_CLR(sep->se_fd, &allsock);
d941 1
a941 1
						FD_CLR(sep->se_fd, &allsock);
d978 1
a978 1
			FD_CLR(sep->se_fd, &allsock);
d995 7
a1001 2
retry(sig)
	int sig;
d1113 2
a1114 1
	FD_SET(sep->se_fd, &allsock);
@


1.70
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.69 2000/08/22 14:47:54 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.69 2000/08/22 14:47:54 millert Exp $";
a240 4
#ifdef MULOG
	int	se_log;
#define MULOG_RFC931	0x40000000
#endif
a578 4
#ifdef MULOG
				if (sep->se_log)
					dolog(sep, ctrl);
#endif
a1217 29
#ifdef MULOG
	while ((cp = nextline(fconfig)) && *cp == '#') {
		/* Avoid use of `skip' if there is a danger of it looking
		 * at continuation lines.
		 */
		do {
			cp++;
		} while (*cp == ' ' || *cp == '\t');
		if (*cp == '\0')
			continue;
		if ((arg = skip(&cp, 0)) == NULL)
			continue;
		if (strcmp(arg, "DOMAIN"))
			continue;
		if (curdom)
			free(curdom);
		curdom = NULL;
		while (*cp == ' ' || *cp == '\t')
			cp++;
		if (*cp == '\0')
			continue;
		arg = cp;
		while (*cp && *cp != ' ' && *cp != '\t')
			cp++;
		if (*cp != '\0')
			*cp++ = '\0';
		curdom = newstr(arg);
	}
#else
a1219 1
#endif
a1358 30
#if MULOG
		char *colon;

		if (argc == 0 && (colon = strrchr(arg, ':'))) {
			while (arg < colon) {
				int	x;
				char	*ccp;

				switch (*arg++) {
				case 'l':
					x = 1;
					if (isdigit(*arg)) {
						x = strtol(arg, &ccp, 0);
						if (ccp == arg)
							break;
						arg = ccp;
					}
					sep->se_log &= ~MULOG_RFC931;
					sep->se_log |= x;
					break;
				case 'a':
					sep->se_log |= MULOG_RFC931;
					break;
				default:
					break;
				}
			}
			arg = colon + 1;
		}
#endif
a1608 4
#ifdef MULOG
	newtab->se_log = sep->se_log;
#endif

a1958 190

#ifdef MULOG
char	*rfc931_name __P((struct sockaddr_in *, int));

dolog(sep, ctrl)
	struct servtab *sep;
	int		ctrl;
{
	struct sockaddr		sa;
	struct sockaddr_in	*sin = (struct sockaddr_in *)&sa;
	int			len = sizeof(sa);
	struct hostent		*hp;
	char			*host, *dp, buf[BUFSIZ];
	int			connected = 1;

	if (sep->se_family != AF_INET)
		return;

	if (getpeername(ctrl, &sa, &len) < 0) {
		if (errno != ENOTCONN) {
			syslog(LOG_ERR, "getpeername: %m");
			return;
		}
		if (recvfrom(ctrl, buf, sizeof(buf), MSG_PEEK, &sa, &len) < 0) {
			syslog(LOG_ERR, "recvfrom: %m");
			return;
		}
		connected = 0;
	}
	if (sa.sa_family != AF_INET) {
		syslog(LOG_ERR, "unexpected address family %u", sa.sa_family);
		return;
	}

	hp = gethostbyaddr((char *) &sin->sin_addr.s_addr,
	    sizeof (sin->sin_addr.s_addr), AF_INET);

	host = hp?hp->h_name:inet_ntoa(sin->sin_addr);

	switch (sep->se_log & ~MULOG_RFC931) {
	case 0:
		return;
	case 1:
		if (curdom == NULL || *curdom == '\0')
			break;
		dp = host + strlen(host) - strlen(curdom);
		if (dp < host)
			break;
		if (debug)
			fprintf(stderr, "check \"%s\" against curdom \"%s\"\n",
			    host, curdom);
		if (strcasecmp(dp, curdom) == 0)
			return;
		break;
	case 2:
	default:
		break;
	}

	openlog("", LOG_NOWAIT, MULOG);

	if (connected && (sep->se_log & MULOG_RFC931))
		syslog(LOG_INFO, "%s@@%s wants %s", rfc931_name(sin, ctrl),
		    host, sep->se_service);
	else
		syslog(LOG_INFO, "%s wants %s", host, sep->se_service);
}
/*
 * From tcp_log by
 *  Wietse Venema, Eindhoven University of Technology, The Netherlands.
 */
#if 0
static char sccsid[] = "@@(#) rfc931.c 1.3 92/08/31 22:54:46";
#endif

#include <setjmp.h>

#define	RFC931_PORT	113		/* Semi-well-known port */
#define	TIMEOUT		4
#define	TIMEOUT2	10

static jmp_buf timebuf;

/* timeout - handle timeouts */
static void
timeout(sig)
	int	sig;
{
	longjmp(timebuf, sig);
}

/* rfc931_name - return remote user name */
char *
rfc931_name(there, ctrl)
struct sockaddr_in *there;		/* remote link information */
int	ctrl;
{
	struct sockaddr_in here;	/* local link information */
	struct sockaddr_in sin;		/* for talking to RFC931 daemon */
	int		length;
	int		s;
	unsigned	remote;
	unsigned	local;
	static char	user[256];		/* XXX */
	char		buf[256];
	char		*cp;
	char		*result = "USER_UNKNOWN";
	int		len;

	/* Find out local port number of our stdin. */

	length = sizeof(here);
	if (getsockname(ctrl, (struct sockaddr *) &here, &length) == -1) {
		syslog(LOG_ERR, "getsockname: %m");
		return (result);
	}
	/* Set up timer so we won't get stuck. */

	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
		syslog(LOG_ERR, "socket: %m");
		return (result);
	}

	sin = here;
	sin.sin_port = htons(0);
	if (bind(s, (struct sockaddr *) &sin, sizeof(sin)) == -1) {
		syslog(LOG_ERR, "bind: %m");
		return (result);
	}

	signal(SIGALRM, timeout);
	if (setjmp(timebuf)) {
		close(s);			/* not: fclose(fp) */
		return (result);
	}
	alarm(TIMEOUT);

	/* Connect to the RFC931 daemon. */
	sin = *there;
	sin.sin_port = htons(RFC931_PORT);
	if (connect(s, (struct sockaddr *) &sin, sizeof(sin)) == -1) {
		close(s);
		alarm(0);
		return (result);
	}

	/* Query the RFC 931 server. Would 13-byte writes ever be broken up? */
	sprintf(buf, "%u,%u\r\n", ntohs(there->sin_port), ntohs(here.sin_port));

	for (len = 0, cp = buf; len < strlen(buf); ) {
		int n;

		if ((n = write(s, cp, strlen(buf) - len)) == -1) {
			close(s);
			alarm(0);
			return (result);
		}
		cp += n;
		len += n;
	}

	/* Read response */
	for (cp = buf; cp < buf + sizeof(buf) - 1; ) {
		char	c;
		if (read(s, &c, 1) != 1) {
			close(s);
			alarm(0);
			return (result);
		}
		if (c == '\n')
			break;
		*cp++ = c;
	}
	*cp = '\0';

	if (sscanf(buf, "%u , %u : USERID :%*[^:]:%255s", &remote,
	    &local, user) == 3 && ntohs(there->sin_port) == remote &&
	    ntohs(here.sin_port) == local) {

		/* Strip trailing carriage return. */
		if (cp = strchr(user, '\r'))
			*cp = 0;
		result = user;
	}

	alarm(0);
	close(s);
	return (result);
}
#endif
@


1.69
log
@If a user is specified in inetd.conf, set the LOGIN_SETGROUP flag too
since setting user implies setting default groups for that user.
Porblem noted by sigh@@kuzirabekon.econ.nagasaki-u.ac.jp.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.68 2000/08/20 18:42:42 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.68 2000/08/20 18:42:42 millert Exp $";
d69 1
a69 1
 * order shown below.  Continuation lines for an entry must being with
@


1.68
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.67 2000/08/03 11:33:37 itojun Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.67 2000/08/03 11:33:37 itojun Exp $";
d567 2
a572 2
					if (pwd->pw_uid)
						tmpint |= LOGIN_SETLOGIN;
@


1.67
log
@udp source validation: drop v4 mapped altogether.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.66 2000/08/01 19:05:23 itojun Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.66 2000/08/01 19:05:23 itojun Exp $";
d166 1
d564 11
a574 2
				} else if (pwd->pw_uid) {
					if (setlogin(sep->se_user) < 0)
d576 3
a578 10
						    "%s: setlogin: %m",
						    sep->se_service);
					if (sep->se_group)
						pwd->pw_gid = grp->gr_gid;
					(void) setgid((gid_t)pwd->pw_gid);
					initgroups(pwd->pw_name, pwd->pw_gid);
					(void) setuid((uid_t)pwd->pw_uid);
				} else if (sep->se_group) {
					(void) setgid(grp->gr_gid);
					(void) setgroups(1, &grp->gr_gid);
a590 7
#ifdef RLIMIT_NOFILE
				if (rlim_ofile.rlim_cur != rlim_ofile_cur) {
					if (setrlimit(RLIMIT_NOFILE,
					    &rlim_ofile) < 0)
						syslog(LOG_ERR,"setrlimit: %m");
				}
#endif
@


1.66
log
@unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.65 2000/08/01 19:02:05 itojun Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.65 2000/08/01 19:02:05 itojun Exp $";
d642 7
a648 1
		if (IN6_IS_ADDR_V4MAPPED(in6) || IN6_IS_ADDR_V4COMPAT(in6)) {
@


1.65
log
@be more paranoid about UDP-based echo services validation.  namely,
reject the following sources:
	0.0.0.0/8 127.0.0.0/8 240.0.0.0/4 255.0.0.0/8
	ff00::/8 ::/128
	::ffff:0.0.0.0/96 and ::0.0.0.0/96 obeys IPv4 rule.
	reserved port, or NFS port.
hint from deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.64 2000/08/01 18:52:50 itojun Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.64 2000/08/01 18:52:50 itojun Exp $";
d621 1
a621 3
	int i, bad;

	bad = 0;
@


1.64
log
@for datagram services, support IPv6.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.63 2000/07/08 01:57:27 itojun Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.63 2000/07/08 01:57:27 itojun Exp $";
d168 1
d616 39
a654 1
	struct sockaddr_in *sin;
d656 2
a657 2
	if (sa->sa_family != AF_INET)
		return (0);
a658 6
	sin = (struct sockaddr_in *)sa;
	if (ntohs(sin->sin_port) < IPPORT_RESERVED)
		return (1);
	if (sin->sin_addr.s_addr == htonl(INADDR_BROADCAST))
		return (1);
	/* XXX compare against broadcast addresses in SIOCGIFCONF list? */
d660 3
@


1.63
log
@handle IPv6 address in first element.
permit square bracket notation in first element of inetd.conf, like RFC2732.
otherwise colon is slightly ambiguous.  sync with kame.

[::1]:ftp  stream  tcp6  nowait  root  /usr/libexec/ftpd  ftpd -US -h
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.62 2000/06/19 01:28:45 itojun Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.62 2000/06/19 01:28:45 itojun Exp $";
d612 3
a614 1
dg_badinput(sin)
d616 5
a620 1
{
d1751 1
a1751 1
	struct sockaddr sa;
d1753 3
a1755 2
	size = sizeof(sa);
	if ((i = recvfrom(s, buffer, sizeof(buffer), 0, &sa, &size)) < 0)
d1757 1
a1757 1
	if (dg_badinput((struct sockaddr_in *)&sa))
d1759 1
a1759 1
	(void) sendto(s, buffer, i, 0, &sa, sizeof(sa));
d1845 1
a1845 1
	struct sockaddr sa;
d1855 3
a1857 2
	size = sizeof(sa);
	if (recvfrom(s, text, sizeof(text), 0, &sa, &size) < 0)
d1859 1
a1859 1
	if (dg_badinput((struct sockaddr_in *)&sa))
d1872 1
a1872 1
	(void) sendto(s, text, sizeof(text), 0, &sa, sizeof(sa));
d1914 1
a1914 2
	struct sockaddr sa;
	struct sockaddr_in *sin;
d1917 3
a1919 2
	size = sizeof(sa);
	if (recvfrom(s, (char *)&result, sizeof(result), 0, &sa, &size) < 0)
d1921 1
a1921 3
	sin = (struct sockaddr_in *)&sa;
	if (sin->sin_addr.s_addr == htonl(INADDR_BROADCAST) || 
	    ntohs(sin->sin_port) < IPPORT_RESERVED/2)
d1924 2
a1925 1
	(void) sendto(s, (char *) &result, sizeof(result), 0, &sa, sizeof(sa));
d1951 1
a1951 1
	struct sockaddr sa;
d1956 3
a1958 2
	size = sizeof(sa);
	if (recvfrom(s, buffer, sizeof(buffer), 0, &sa, &size) < 0)
d1960 1
a1960 1
	if (dg_badinput((struct sockaddr_in *)&sa))
d1963 2
a1964 1
	(void) sendto(s, buffer, strlen(buffer), 0, &sa, sizeof(sa));
@


1.62
log
@honor scopeid when compare ipv6 addrs
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.61 2000/03/04 01:10:06 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.61 2000/03/04 01:10:06 deraadt Exp $";
d228 1
d234 1
d1232 5
a1236 1
		sep->se_hostaddr = newstr(arg);
d1413 20
a1432 23
		if (nsep->se_family == AF_INET) {
			if (!strcmp(nsep->se_hostaddr,"*"))
				nsep->se_ctrladdr_in.sin_addr.s_addr =
				    INADDR_ANY;
			else if (!inet_aton(nsep->se_hostaddr,
			    &nsep->se_ctrladdr_in.sin_addr)) {
				struct hostent *hp;

				hp = gethostbyname(nsep->se_hostaddr);
				if (hp == 0) {
					syslog(LOG_ERR, "%s: unknown host",
					    nsep->se_hostaddr);
					nsep->se_checked = 0;
					goto skip;
				} else if (hp->h_addrtype != AF_INET) {
					syslog(LOG_ERR,
					    "%s: address isn't an Internet "
					    "address",
					    nsep->se_hostaddr);
					nsep->se_checked = 0;
					goto skip;
				} else {
					int i = 1;
d1434 28
a1461 14
					memmove(&nsep->se_ctrladdr_in.sin_addr,
					    hp->h_addr_list[0],
					    sizeof(struct in_addr));
					while (hp->h_addr_list[i] != NULL) {
						psep = dupconfig(nsep);
						psep->se_hostaddr = newstr(
						    nsep->se_hostaddr);
						psep->se_checked = 1;
						memmove(&psep->se_ctrladdr_in.sin_addr,
						    hp->h_addr_list[i],
						    sizeof(struct in_addr));
						psep->se_ctrladdr_size =
						    sizeof(psep->se_ctrladdr_in);
						i++;
d1463 13
a1475 9
						/*
						 * Prepend to list, don't
						 * want to look up its
						 * hostname again.
						 */
						psep->se_next = sep;
						sep = psep;
					}
				}
d1477 3
@


1.61
log
@handle corrupt inetd.conf files better; sdb@@ssr.com
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.60 2000/02/01 03:23:58 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.60 2000/02/01 03:23:58 deraadt Exp $";
d1119 4
@


1.60
log
@no need to extern int errno if errno.h is included
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.59 1999/12/10 16:19:29 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.59 1999/12/10 16:19:29 deraadt Exp $";
d335 1
a335 1
		            "-R %s: bad value for service invocation rate",
d857 1
a857 1
			free (cp);
d1127 1
a1127 1
char		*skip __P((char **));
d1163 1
a1163 1
	char *cp, *arg;
d1174 1
d1176 2
d1188 1
a1188 1
		if ((arg = skip(&cp)) == NULL)
d1210 2
a1211 1
	if (cp == NULL)
d1213 2
d1216 1
a1216 1
	arg = skip(&cp);
d1233 1
a1233 1
			arg = skip(&cp);
d1236 1
a1236 1
				defhost = sep->se_hostaddr;
d1244 2
a1245 1
	arg = skip(&cp);
d1260 5
a1264 1
	sep->se_proto = newstr(skip(&cp));
d1301 1
a1301 1
	arg = skip(&cp);
d1304 8
a1311 8
	{
		char	*s = strchr(arg, '.');
		if (s) {
			*s++ = '\0';
			sep->se_max = atoi(s);
		} else
			sep->se_max = toomany;
	}
d1313 3
a1315 1
	sep->se_user = newstr(skip(&cp));
d1323 4
a1326 1
	sep->se_server = newstr(skip(&cp));
d1328 1
a1328 1
		register struct biltin *bi;
d1344 1
a1344 1
	for (arg = skip(&cp); cp; arg = skip(&cp)) {
d1510 1
a1510 1
skip(cpp)
d1512 1
d1514 1
a1514 1
	register char *cp = *cpp;
d1517 7
a1523 3
	if (*cpp == NULL)
			return (NULL);

d1536 1
a1536 1
		return (NULL);
d1543 3
a1545 1
	*cpp = cp;
@


1.59
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.58 1999/12/10 10:28:40 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.58 1999/12/10 10:28:40 deraadt Exp $";
a175 1
extern	int errno;
@


1.58
log
@repair various bugs in -d mode
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.57 1999/12/08 13:21:17 itojun Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.57 1999/12/08 13:21:17 itojun Exp $";
d1110 5
a1114 7
	if ((old->se_family == AF_INET) &&
		(new->se_family == AF_INET) &&
		(bcmp(&old->se_ctrladdr_in.sin_addr,
		    &new->se_ctrladdr_in.sin_addr,
		    sizeof(new->se_ctrladdr_in.sin_addr)) != 0)) {
			return (0);
	}
d1116 5
a1120 7
	if ((old->se_family == AF_INET6) &&
		(new->se_family == AF_INET6) &&
		(bcmp(&old->se_ctrladdr_in6.sin6_addr,
		    &new->se_ctrladdr_in6.sin6_addr,
		    sizeof(new->se_ctrladdr_in6.sin6_addr)) != 0)) {
			return (0);
	}
@


1.57
log
@IPv6/v4 inetd(8) from KAME.  now you can test ftp over IPv6.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.56 1999/02/24 12:31:30 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.56 1999/02/24 12:31:30 deraadt Exp $";
d675 1
a675 1
	int n;
d689 1
d718 1
a718 2
			if (debug)
				print_service("REDO", sep);
a720 2
			if (debug)
				print_service("ADD ", sep);
d861 2
d1936 2
a1937 1
	    sep->se_wait, sep->se_max, sep->se_user, sep->se_group,
@


1.56
log
@fix -R option; hugh
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.55 1999/01/04 12:03:08 niklas Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.55 1999/01/04 12:03:08 niklas Exp $";
d227 1
d232 1
d676 1
d769 5
d775 1
a775 1
					    sep->se_proto);
d796 56
d905 1
d930 1
d957 1
a957 1
	if (strcmp(sep->se_proto, "tcp") == 0 && (options & SO_DEBUG) &&
d1118 8
d1263 2
@


1.55
log
@PIDs does not always fit in short
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.54 1998/12/04 07:52:02 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.54 1998/12/04 07:52:02 deraadt Exp $";
d329 1
a329 1
			if (val >= 1 && p == NULL) {
@


1.54
log
@support user.group or user:group, per chown(8)
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.53 1998/11/21 00:15:58 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.53 1998/11/21 00:15:58 deraadt Exp $";
d215 1
a215 1
	short	se_wait;		/* single threaded server */
@


1.53
log
@missing \n
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.52 1998/11/19 06:34:03 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.52 1998/11/19 06:34:03 deraadt Exp $";
d76 1
a76 1
 *	user[.group]			user/group to run daemon as
d85 1
a85 1
 *	user[.group]			user to run daemon as
d117 1
a117 1
 * Here's the scoop concerning the user.group feature:
d1233 2
d1859 1
a1859 1
	    " wait.max=%hd.%d user.group=%s.%s builtin=%lx server=%s\n",
@


1.52
log
@catch extra junk at the end of the numbers
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.51 1998/11/18 23:25:35 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.51 1998/11/18 23:25:35 deraadt Exp $";
d340 1
a340 1
			fprintf(stderr, "usage: %s [-R rate] [-d] [conf]",
@


1.51
log
@correct strtol() mess around rpc version numbers
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.50 1998/10/28 18:01:17 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.50 1998/10/28 18:01:17 deraadt Exp $";
d1212 1
a1212 1
				    l < sep->se_rpcversl)
d1215 2
a1216 1
			}
@


1.50
log
@fix ? usage handling; route@@resentment.infonexus.com
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.49 1998/07/15 17:51:14 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.49 1998/07/15 17:51:14 deraadt Exp $";
d1191 2
d1200 2
a1201 3
			sep->se_rpcversl =
				sep->se_rpcversh = strtol(cp, &ccp, 0);
			if (ccp == cp) {
d1207 1
d1210 3
a1212 2
				sep->se_rpcversh = strtol(cp, &ccp, 0); 
				if (ccp == cp)
d1214 1
@


1.49
log
@close fd leak; jeff@@FORYS.CRANBURY.NJ.US
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.48 1998/07/13 02:11:48 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.48 1998/07/13 02:11:48 millert Exp $";
a323 1
		case '?':
d338 1
@


1.48
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.47 1998/06/03 08:06:01 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.47 1998/06/03 08:06:01 deraadt Exp $";
d415 1
a415 1
	    int n, ctrl;
d499 3
@


1.47
log
@use sigsetops, and do cross-block signal handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.46 1998/03/12 00:19:16 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.46 1998/03/12 00:19:16 deraadt Exp $";
d1066 1
a1066 1
		fseek(fconfig, 0L, L_SET);
@


1.46
log
@unblock SIGPIPE before execv(); chuck.
convert to sigaction(); deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.45 1998/02/24 20:21:32 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.45 1998/02/24 20:21:32 deraadt Exp $";
d385 4
a388 1
	sa.sa_mask = SIGBLOCK;
d391 1
a391 1
	config(0);
@


1.45
log
@udp time may be contacted at dynamic reserved
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.44 1997/12/23 23:46:16 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.44 1997/12/23 23:46:16 deraadt Exp $";
d303 1
a303 1
	struct sigvec sv;
d384 4
a387 4
	memset((char *)&sv, 0, sizeof(sv));
	sv.sv_mask = SIGBLOCK;
	sv.sv_handler = retry;
	sigvec(SIGALRM, &sv, NULL);
d389 10
a398 10
	sv.sv_handler = config;
	sigvec(SIGHUP, &sv, NULL);
	sv.sv_handler = reapchild;
	sigvec(SIGCHLD, &sv, NULL);
	sv.sv_handler = goaway;
	sigvec(SIGTERM, &sv, NULL);
	sv.sv_handler = goaway;
	sigvec(SIGINT, &sv, NULL);
	sv.sv_handler = SIG_IGN;
	sigvec(SIGPIPE, &sv, NULL);
d588 1
@


1.44
log
@make it more obvious why pmap_set syslogs happen
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.43 1997/12/04 21:35:29 art Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.43 1997/12/04 21:35:29 art Exp $";
d1771 1
d1777 3
a1779 1
	if (dg_badinput((struct sockaddr_in *)&sa))
@


1.43
log
@Fixed a sysadmin-dos.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.42 1997/11/14 03:46:00 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.42 1997/11/14 03:46:00 deraadt Exp $";
d970 2
a971 1
			syslog(LOG_ERR, "pmap_set: %u %u %u %u: %m",
@


1.42
log
@clone freebsd "-R rate"; default to 256 invocations/minute
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.41 1997/11/14 03:40:02 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.41 1997/11/14 03:40:02 deraadt Exp $";
d747 1
a747 1
						continue;
d765 1
a765 1
						continue;
d782 1
@


1.41
log
@crank TOOMANY to 160 for now
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.40 1997/09/19 12:21:27 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.40 1997/09/19 12:21:27 deraadt Exp $";
d170 1
a170 1
#define	TOOMANY		160		/* don't start more than TOOMANY */
d186 1
d318 1
a318 1
	while ((ch = getopt(argc, argv, "d")) != -1)
d325 14
d340 2
a341 1
			fprintf(stderr, "usage: %s [-d] [conf]", progname);
d1214 1
a1214 1
			sep->se_max = TOOMANY;
@


1.40
log
@ignore SIGPIPE; not nearly as much of a problem as linux though
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.39 1997/08/31 18:04:37 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.39 1997/08/31 18:04:37 deraadt Exp $";
d170 1
a170 1
#define	TOOMANY		40		/* don't start more than TOOMANY */
@


1.39
log
@only check for ftp bounce in tcp, duh. for nonreserved ports, do not
close for looping mode. kill an fd leak.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.38 1997/08/29 17:07:04 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.38 1997/08/29 17:07:04 deraadt Exp $";
d381 2
@


1.38
log
@very weird sleep; dholland@@eecs.harvard.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.37 1997/08/04 19:26:10 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.37 1997/08/04 19:26:10 deraadt Exp $";
d190 1
a190 1
int	uid;
d303 2
a304 1
	int ch, pid, dofork, plen;
a305 1
	struct sockaddr_in peer;
d427 16
a442 11
			plen = sizeof(peer);
			if (getpeername(ctrl, (struct sockaddr *)&peer,
			    &plen) < 0) {
				syslog(LOG_WARNING, "could not getpeername");
				close(ctrl);
				continue;
			}
			if (ntohs(peer.sin_port) == 20) {
				/* XXX ftp bounce */
				close(ctrl);
				continue;
d461 14
d495 1
a495 1
			if (sep->se_socktype == SOCK_STREAM)
d599 2
a600 3
	int status;
	int pid;
	int save_errno = errno;
@


1.37
log
@save errno in sigchld handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.36 1997/07/22 21:12:28 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.36 1997/07/22 21:12:28 deraadt Exp $";
d405 1
a405 1
		    if (n < 0 && errno != EINTR)
d407 2
a408 1
		    sleep(1);
@


1.36
log
@cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.35 1997/07/08 20:37:30 kstailey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.35 1997/07/08 20:37:30 kstailey Exp $";
d581 1
d608 1
@


1.35
log
@print child exit status in debug mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.34 1997/07/08 20:31:14 kstailey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.34 1997/07/08 20:31:14 kstailey Exp $";
d423 1
a423 1
					sep->se_service);
d493 2
a494 2
						"getpwnam: %s: No such user",
						sep->se_user);
d543 1
a543 1
							&rlim_ofile) < 0)
d686 2
a687 1
				sep->se_service, n);
d1001 1
a1001 1
				return (0);
d1194 1
a1194 1
				sep->se_service);
d1455 1
a1455 1
			newstr(sep->se_argv[argc]) : NULL;
d1480 1
d1520 2
a1521 2
			"bump_nofile: cannot extend file limit, max = %d",
			(int)rl.rlim_cur);
d1588 1
a1588 1
			errno == EINTR)
d1791 1
a1791 1
			sep->se_service);
d1801 3
a1803 3
		" wait.max=%hd.%d user.group=%s.%s builtin=%lx server=%s\n",
		sep->se_wait, sep->se_max, sep->se_user, sep->se_group,
		(long)sep->se_bi, sep->se_server);
d1840 1
a1840 1
				sizeof (sin->sin_addr.s_addr), AF_INET);
d1855 1
a1855 1
					host, curdom);
d1867 2
a1868 2
		syslog(LOG_INFO, "%s@@%s wants %s",
				rfc931_name(sin, ctrl), host, sep->se_service);
d1870 1
a1870 2
		syslog(LOG_INFO, "%s wants %s",
				host, sep->se_service);
d1889 3
a1891 3

static void timeout(sig)
int     sig;
a1896 1

a1942 1

d1954 2
a1956 2
	for (len = 0, cp = buf; len < strlen(buf); ) {
		int	n;
d1980 3
a1982 3
	if (sscanf(buf, "%u , %u : USERID :%*[^:]:%255s", &remote, &local, user) == 3
		&& ntohs(there->sin_port) == remote
		&& ntohs(here.sin_port) == local) {
@


1.34
log
@NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.33 1997/06/26 17:31:22 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.33 1997/06/26 17:31:22 deraadt Exp $";
d588 1
a588 1
			fprintf(stderr, "%d reaped\n", pid);
@


1.33
log
@mem* cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.32 1997/06/26 06:26:15 denny Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.32 1997/06/26 06:26:15 denny Exp $";
d371 1
a371 1
	sigvec(SIGALRM, &sv, (struct sigvec *)0);
d374 1
a374 1
	sigvec(SIGHUP, &sv, (struct sigvec *)0);
d376 1
a376 1
	sigvec(SIGCHLD, &sv, (struct sigvec *)0);
d378 1
a378 1
	sigvec(SIGTERM, &sv, (struct sigvec *)0);
d380 1
a380 1
	sigvec(SIGINT, &sv, (struct sigvec *)0);
d404 1
a404 2
	    if ((n = select(maxsock + 1, &readable, (fd_set *)0,
		(fd_set *)0, (struct timeval *)0)) <= 0) {
d416 1
a416 2
			ctrl = accept(sep->se_fd, (struct sockaddr *)0,
			    (int *)0);
d445 1
a445 2
			    (void)gettimeofday(&sep->se_time,
			        (struct timezone *)0);
d449 1
a449 1
				(void)gettimeofday(&now, (struct timezone *)0);
d584 1
a584 1
		pid = wait3(&status, WNOHANG, (struct rusage *)0);
d960 1
a960 1
	if (sep == (struct servtab *)0) {
d1090 1
a1090 1
		return ((struct servtab *)0);
d1374 1
a1374 1
			return ((char *)0);
d1387 2
a1388 2
		*cpp = (char *)0;
		return ((char *)0);
d1406 1
a1406 1
		return ((char *)0);
d1701 1
a1701 1
	if (gettimeofday(&tv, (struct timezone *)0) < 0) {
d1748 1
a1748 1
	clock = time((time_t *) 0);
@


1.32
log
@Better support for specific instance binding in inetd:
- Allow comma delimited list of hostnames, create a socket for each
- Allow a hostname which resolves to multiple addrs, create a socket for each
- Make sure kill -HUP handles specific instance services correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.31 1997/06/23 09:37:37 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.31 1997/06/23 09:37:37 deraadt Exp $";
d368 1
a368 1
	bzero((char *)&sv, sizeof(sv));
d1094 1
a1094 1
	bzero((char *)sep, sizeof *sep);
d1270 1
d1287 3
a1289 3
					bcopy(hp->h_addr_list[0],
						&nsep->se_ctrladdr_in.sin_addr,
						sizeof(struct in_addr));
d1295 1
a1295 1
						bcopy(
a1296 1
				    &psep->se_ctrladdr_in.sin_addr,
d1299 1
a1299 1
						  sizeof(psep->se_ctrladdr_in);
d1440 1
a1440 1
	bzero ((char *)newtab, sizeof(struct servtab));
d1643 1
a1643 1
			bcopy(rs, text, LINESIZ);
d1645 2
a1646 2
			bcopy(rs, text, len);
			bcopy(ring, text + len, LINESIZ - len);
d1679 1
a1679 1
		bcopy(rs, text, LINESIZ);
d1681 2
a1682 2
		bcopy(rs, text, len);
		bcopy(ring, text + len, LINESIZ - len);
@


1.31
log
@return 32-bits worth of time for time service
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.30 1997/06/23 09:35:04 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.30 1997/06/23 09:35:04 deraadt Exp $";
d622 1
d638 2
a639 1
	while ((cp = getconfigent())) {
d641 1
a641 3
			if (strcmp(sep->se_service, cp->se_service) == 0 &&
			    strcmp(sep->se_hostaddr, cp->se_hostaddr) == 0 &&
			    strcmp(sep->se_proto, cp->se_proto) == 0)
d688 2
a689 1
			strncpy(sep->se_ctrladdr_un.sun_path, sep->se_service, n);
d697 2
a698 37
			if (!strcmp(sep->se_hostaddr,"*"))
				sep->se_ctrladdr_in.sin_addr.s_addr =
				    INADDR_ANY;
			else if (!inet_aton(sep->se_hostaddr,
			    &sep->se_ctrladdr_in.sin_addr)) {
				/*
				 * Do we really want to support hostname
				 * lookups here?
				 */
				struct hostent *hp;
				hp = gethostbyname(sep->se_hostaddr);
				if (hp == 0) {
					syslog(LOG_ERR, "%s: unknown host",
					    sep->se_hostaddr);
					sep->se_checked = 0;
					continue;
				} else if (hp->h_addrtype != AF_INET) {
					syslog(LOG_ERR,
					    "%s: address isn't an Internet "
					    "address",
					    sep->se_hostaddr);
					sep->se_checked = 0;
					continue;
				} else {
					/*
					 * What to do about multi-homed hosts?
					 *
					 * The resolver may be doing
					 * random load balancing. Somehow
					 * this doesn't seem like what the
					 * user intended.
					 */
					if (hp->h_addr_list[1] != NULL) {
						syslog(LOG_WARNING,
				"%s has multiple addresses, using the first",
							sep->se_hostaddr);
					}
a699 6
					bcopy(hp->h_addr_list[0],
						&sep->se_ctrladdr_in.sin_addr,
						sizeof(struct in_addr));
				}
			}
			sep->se_ctrladdr_size = sizeof sep->se_ctrladdr_in;
d745 9
d977 39
a1015 7
FILE	*fconfig = NULL;
struct	servtab serv;
char	line[1024];
char	*defhost;
char	*skip __P((char **));
char	*nextline __P((FILE *));
char	*newstr __P((char *));
d1046 1
a1046 1
	register struct servtab *sep = &serv;
d1050 8
d1181 4
a1184 2
	if ((sep->se_group = strchr(sep->se_user, '.'))) {
		*sep->se_group++ = '\0';
d1240 103
d1360 2
a1361 1
	/* Note: se_group is part of the newstr'ed se_user */
d1377 1
a1377 1
		return ((char *)0);
d1426 41
d1788 6
d1795 3
a1797 3
		fprintf(stderr, "%s: %s rpcprog=%d, rpcvers=%d/%d, proto=%s,",
		    action, sep->se_service, sep->se_rpcprog,
		    sep->se_rpcversh, sep->se_rpcversl, sep->se_proto);
d1799 6
a1804 6
		fprintf(stderr, "%s: %s proto=%s,",
		    action, sep->se_service, sep->se_proto);
		fprintf(stderr,
	    " wait.max=%d.%d user.group=%s.%s builtin=%lx server=%s\n",
		    sep->se_wait, sep->se_max, sep->se_user, sep->se_group,
		    (long)sep->se_bi, sep->se_server);
@


1.30
log
@sigblock plays with ints
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.29 1997/06/17 05:41:19 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.29 1997/06/17 05:41:19 deraadt Exp $";
d1543 1
a1543 1
long
d1552 1
a1552 1
	return (htonl((long)tv.tv_sec + 2208988800UL));
d1561 1
a1561 1
	long result;
d1573 1
a1573 1
	long result;
@


1.29
log
@do not test for a bug which does not exist
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.28 1997/06/17 05:26:22 denny Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.28 1997/06/17 05:26:22 denny Exp $";
d628 1
a628 1
	long omask;
d991 1
a991 1
	long omask;
@


1.28
log
@Add per-interface binding, based on der Mouse's code in netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.27 1997/06/04 11:07:05 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.27 1997/06/04 11:07:05 deraadt Exp $";
a715 6
					    sep->se_hostaddr);
					sep->se_checked = 0;
					continue;
				} else if (hp->h_length != sizeof(struct in_addr)) {
					syslog(LOG_ERR,
			"%s: address size wrong (under DNS corruption attack?)",
@


1.27
log
@toast extra \n; ficus
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.26 1997/06/04 11:03:15 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.26 1997/06/04 11:03:15 deraadt Exp $";
d89 24
d205 1
d640 1
d696 49
d1017 1
d1025 2
a1026 1

d1042 4
d1054 1
a1091 1
	sep->se_service = newstr(skip(&cp));
d1093 2
a1094 1
	if (arg == NULL)
d1096 25
d1244 2
@


1.26
log
@do not exceed bounds of fd_set
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.25 1997/02/24 12:48:06 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.25 1997/02/24 12:48:06 deraadt Exp $";
d382 1
a382 1
			syslog(LOG_WARNING, "select: %m\n");
d434 1
a434 1
			"%s/%s server failing (looping), service terminated\n",
d911 1
a911 1
			syslog(LOG_ERR, "pmap_unset(%u, %u)\n",
d1083 1
a1083 1
			syslog(LOG_ERR, "internal service %s unknown\n",
@


1.25
log
@irc thing is dumb, and do not bother wasting effort screaming about ftp bounce attempts, just slaughter them
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.24 1997/01/15 23:43:59 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.24 1997/01/15 23:43:59 millert Exp $";
d1259 1
@


1.24
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.23 1996/12/14 19:19:09 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.23 1996/12/14 19:19:09 deraadt Exp $";
d411 1
a411 2
				syslog(LOG_INFO, "Connect to %s from port %d",
				    sep->se_service, ntohs(peer.sin_port));
a545 2
		return (1);
	if (ntohs(sin->sin_port) == 6667)	/* XXX IRC version */
@


1.23
log
@be more careful with setgroups()
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.22 1996/12/11 09:05:05 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.22 1996/12/11 09:05:05 deraadt Exp $";
d292 1
a292 1
	while ((ch = getopt(argc, argv, "d")) != EOF)
@


1.22
log
@proto & column cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.21 1996/08/31 17:31:05 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.21 1996/08/31 17:31:05 deraadt Exp $";
d322 8
d505 2
a506 1
					(void) setgid((gid_t)grp->gr_gid);
@


1.21
log
@rpc is not an option anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.20 1996/08/28 09:55:00 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.20 1996/08/28 09:55:00 deraadt Exp $";
d154 4
a157 4
void	config __P((void));
void	reapchild __P((void));
void	retry __P((void));
void	goaway __P((void));
d339 1
a339 1
	config();
d548 2
a549 1
reapchild()
d593 2
a594 1
config()
d741 2
a742 1
retry()
d762 2
a763 1
goaway()
d1523 3
a1525 6
		fprintf(stderr,
		    "%s: %s rpcprog=%d, rpcvers = %d/%d, proto=%s, wait.max=%d.%d, user.group=%s.%s builtin=%lx server=%s\n",
		    action, sep->se_service,
		    sep->se_rpcprog, sep->se_rpcversh, sep->se_rpcversl, sep->se_proto,
		    sep->se_wait, sep->se_max, sep->se_user, sep->se_group,
		    (long)sep->se_bi, sep->se_server);
d1527 2
d1530 1
a1530 2
		    "%s: %s proto=%s, wait.max=%d.%d, user.group=%s.%s builtin=%lx server=%s\n",
		    action, sep->se_service, sep->se_proto,
@


1.20
log
@closer towards useable by generic joe
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.19 1996/08/16 08:32:54 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.19 1996/08/16 08:32:54 deraadt Exp $";
a128 2
#define RPC

a141 1
#ifdef RPC
a143 1
#endif
d671 1
a671 1
						    "%s: unknown service",
a860 1
#ifdef RPC
a887 1
#endif /* RPC */
a893 1
#ifdef RPC
a903 1
#endif /* RPC */
a1023 1
#ifdef RPC
a1045 5
#else
			syslog(LOG_ERR, "%s: rpc services not suported",
			    sep->se_service);
			goto more;
#endif /* RPC */
@


1.19
log
@do not do bindresvport if user runs own inetd
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.18 1996/08/11 23:24:25 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.18 1996/08/11 23:24:25 deraadt Exp $";
d170 1
d310 3
d315 5
d323 2
a324 1
		(void) setlogin("");
d486 5
a490 1
				if (pwd->pw_uid) {
d661 1
a661 1
					sizeof sep->se_ctrladdr_un.sun_family;
d675 2
a676 2
							"%s: unknown service",
							sep->se_service);
d690 1
a690 1
								sep->se_proto);
d820 1
a820 1
		    pwd->pw_uid == 0 && getuid() == 0)
d885 2
a886 1
			sep->se_rpcprog, n, pp->p_proto, ntohs(sin.sin_port));
d890 2
a891 1
			sep->se_rpcprog, n, pp->p_proto, ntohs(sin.sin_port));
d906 1
a906 1
				sep->se_rpcprog, n);
d909 1
a909 1
				sep->se_rpcprog, n);
@


1.18
log
@fix doc order of setgid/initgroups/setuid
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.17 1996/08/02 07:18:35 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.17 1996/08/02 07:18:35 deraadt Exp $";
d806 1
a806 1
		    pwd->pw_uid == 0)
@


1.17
log
@merge freebsd setlogin/setsid changes
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.16 1996/08/02 06:47:41 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.16 1996/08/02 06:47:41 deraadt Exp $";
d99 1
a99 2
 * 	b) other:	setuid()
 * 			setgid(primary group as found in passwd)
d101 2
a102 1
 * 
d105 1
a105 2
 * 	a) user = root:	NO setuid()
 * 			setgid(specified group)
d107 3
a109 3
 * 
 * 	b) other:	setuid()
 * 			setgid(specified group)
d111 1
@


1.16
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.15 1996/08/02 06:13:26 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.15 1996/08/02 06:13:26 deraadt Exp $";
d312 1
a312 1
	if (debug == 0)
d314 2
a452 2
			if (debug && dofork)
				setsid();
d464 3
d470 2
a471 2
						"getgrnam: %s: No such group",
						sep->se_group);
d477 4
@


1.15
log
@after rpc bind, getpeername() to update sin_port
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.14 1996/07/31 11:01:54 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.14 1996/07/31 11:01:54 deraadt Exp $";
d239 2
a240 2
	{ "echo",		SOCK_STREAM,	1, 0,	echo_stream },
	{ "echo",		SOCK_DGRAM,	0, 0,	echo_dg },
d247 2
a248 2
	{ "time",		SOCK_STREAM,	0, 0,	machtime_stream },
	{ "time",		SOCK_DGRAM,	0, 0,	machtime_dg },
@


1.14
log
@proto throughout
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.13 1996/07/29 23:45:34 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.13 1996/07/29 23:45:34 deraadt Exp $";
d801 1
a801 1
		else
d804 11
@


1.13
log
@udp spam on 6667
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.12 1996/07/29 09:14:55 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.12 1996/07/29 09:14:55 deraadt Exp $";
d236 1
a236 1
	void	(*bi_fn)();		/* function which performs it */
d571 2
a572 1

a577 1
	struct servtab *getconfigent(), *enter();
d906 3
a908 1
char	*skip(), *nextline();
d936 1
a936 1
	char *cp, *arg, *newstr();
d1000 1
a1000 1
			cp = index(sep->se_service, '/');
d1032 1
a1032 1
		char	*s = index(arg, '.');
d1041 1
a1041 1
	if ((sep->se_group = index(sep->se_user, '.'))) {
d1064 1
a1064 1
		char *colon, *rindex();
d1066 1
a1066 1
		if (argc == 0 && (colon = rindex(arg, ':'))) {
d1162 1
a1162 1
	cp = index(line, '\n');
d1514 2
d1524 1
a1524 1
	char			*host, *dp, buf[BUFSIZ], *rfc931_name();
@


1.12
log
@careful of bad addr/port in dgram services
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.10 1996/07/29 07:53:07 downsj Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.10 1996/07/29 07:53:07 downsj Exp $";
d522 2
d526 1
@


1.11
log
@-Wall clean; careful buffer usage
@
text
@d516 11
d1279 2
d1380 2
d1441 2
d1477 2
@


1.10
log
@Zero out the port for RPC services; let bind() find one.
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.9 1996/07/29 03:43:54 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.9 1996/07/29 03:43:54 deraadt Exp $";
d142 1
d146 1
d158 4
a161 2
void	config(), reapchild(), retry(), goaway();
char	*index();
d220 10
a229 3
int echo_stream(), discard_stream(), machtime_stream();
int daytime_stream(), chargen_stream();
int echo_dg(), discard_dg(), machtime_dg(), daytime_dg(), chargen_dg();
d236 1
a236 1
	int	(*bi_fn)();		/* function which performs it */
d239 2
a240 2
	"echo",		SOCK_STREAM,	1, 0,	echo_stream,
	"echo",		SOCK_DGRAM,	0, 0,	echo_dg,
d243 2
a244 2
	"discard",	SOCK_STREAM,	1, 0,	discard_stream,
	"discard",	SOCK_DGRAM,	0, 0,	discard_dg,
d247 2
a248 2
	"time",		SOCK_STREAM,	0, 0,	machtime_stream,
	"time",		SOCK_DGRAM,	0, 0,	machtime_dg,
d251 2
a252 2
	"daytime",	SOCK_STREAM,	0, 0,	daytime_stream,
	"daytime",	SOCK_DGRAM,	0, 0,	daytime_dg,
d255 4
a258 3
	"chargen",	SOCK_STREAM,	1, 0,	chargen_stream,
	"chargen",	SOCK_DGRAM,	0, 0,	chargen_dg,
	0
d267 2
a268 5
#ifdef sun
/*
 * Sun's RPC library caches the result of `dtablesize()'
 * This is incompatible with our "bumping" of file descriptors "on demand"
 */
a269 6
_rpc_dtablesize()
{
	return rlim_ofile_cur;
}
#endif

d278 1
a278 1
	register struct group *grp;
d549 10
d573 1
a573 1
	while (cp = getconfigent()) {
d684 1
a684 1
	while (sep = *sepp) {
d751 1
d753 1
d786 1
a786 1
			r = bindresvport(sep->se_fd, &sep->se_ctrladdr);
d815 1
d848 1
d891 1
a891 1
char	line[256];
d894 1
d906 1
d1025 1
a1025 1
	if (sep->se_group = index(sep->se_user, '.')) {
d1085 1
d1124 1
a1124 1
			if (cp = nextline(fconfig))
d1156 1
a1156 1
	if (cp = strdup(cp ? cp : ""))
d1162 1
d1174 8
a1181 4
	if (getpeername(s, (struct sockaddr *)&sin, &size) == 0)
		(void) sprintf(buf, "-%s [%s]", a, inet_ntoa(sin.sin_addr)); 
	else
		(void) sprintf(buf, "-%s", a); 
d1188 1
d1199 1
d1216 1
a1216 1
			rl.rlim_cur);
d1240 1
d1256 1
d1272 1
d1287 1
d1302 1
d1315 1
d1349 1
d1402 1
d1414 1
d1431 1
d1446 1
d1469 1
@


1.9
log
@from port 20, do not leak an fd
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.8 1996/07/28 05:54:41 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.8 1996/07/28 05:54:41 deraadt Exp $";
d764 3
d768 1
@


1.8
log
@arthur (in)dent
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.7 1996/07/28 05:13:19 joshd Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.7 1996/07/28 05:13:19 joshd Exp $";
d388 1
d394 1
@


1.7
log
@Do not allow hosts to connect to servers from
source ports < IPPORT_RESERVED/2.  This is for ftp bounce attacks,
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.6 1996/06/29 01:02:24 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.6 1996/06/29 01:02:24 deraadt Exp $";
d385 3
a387 2
			if (getpeername(ctrl, (struct sockaddr *)&peer, &plen) < 0)
			{	syslog(LOG_WARNING, "could not getpeername");
d390 3
a392 3
			if (ntohs(peer.sin_port) == 20)
			{	syslog(LOG_INFO, "Connect to %s from port %d",
				       sep->se_service, ntohs(peer.sin_port));
@


1.6
log
@bindresvport() called incorrectly; we need a proto somewhere guys
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.5 1996/06/28 17:50:09 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.5 1996/06/28 17:50:09 deraadt Exp $";
d278 1
a278 1
	int ch, pid, dofork;
d280 1
d382 10
@


1.5
log
@closelog() before we trash the syslog descriptor; suggestion from alan@@parsys.co.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.4 1996/06/12 07:23:26 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.4 1996/06/12 07:23:26 deraadt Exp $";
d753 1
a753 2
			r = bindresvport(sep->se_fd, &sep->se_ctrladdr,
			    sep->se_ctrladdr_size);
@


1.4
log
@use resv port only for root processes
@
text
@d1 1
a1 1
/*	$OpenBSD: inetd.c,v 1.3 1996/05/13 16:00:08 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: inetd.c,v 1.3 1996/05/13 16:00:08 deraadt Exp $";
d483 1
@


1.3
log
@bindresvport() for rpc ports
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD$";
d743 15
a757 4
	if (isrpcservice(sep))
		r = bindresvport(sep->se_fd, &sep->se_ctrladdr,
		    sep->se_ctrladdr_size);
	else
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d728 1
d743 6
a748 1
	if (bind(sep->se_fd, &sep->se_ctrladdr, sep->se_ctrladdr_size) < 0) {
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: inetd.c,v 1.10 1995/06/02 15:02:18 pk Exp $	*/
d44 1
a44 1
static char rcsid[] = "$Id: inetd.c,v 1.10 1995/06/02 15:02:18 pk Exp $";
d565 4
a568 8
			if (cp->se_max != sep->se_max)
				SWAP(int, cp->se_max, sep->se_max);
			if (cp->se_user)
				SWAP(char *, sep->se_user, cp->se_user);
			if (cp->se_group)
				SWAP(char *, sep->se_group, cp->se_group);
			if (cp->se_server)
				SWAP(char *, sep->se_server, cp->se_server);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

