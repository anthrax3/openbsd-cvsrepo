head	1.22;
access;
symbols
	OPENBSD_5_6:1.21.0.22
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.20
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.16
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.14
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.12
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.10
	OPENBSD_5_0:1.21.0.8
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.20
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.16
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.14
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.12
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.10
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.8
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.6
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.12
	OPENBSD_2_8:1.9.0.10
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.6
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2014.10.01.09.54.52;	author mpi;	state dead;
branches;
next	1.21;
commitid	qd1wWToTuOPbZjAS;

1.21
date	2009.10.27.23.59.54;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.04.09.03.08;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.09.21.21.17.02;	author jaredy;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.09.16.08.05;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.06.17.27.53;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.26.21.36.39;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.18.17.29.02;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.28.09;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.17.19.49.41;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.09.08.45.32;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.31.19.50.16;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.12.21.41.32;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.07.08.22.13.30;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.03.19.07.32.08;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.12.22.03.29.06;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.12.10.15.14.33;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.05.12.02.54;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.10.08.38.55;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.04.07.52.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.30.09.11.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.21;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.21;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@tedu sliplogin and slstats to beging with the slip, slipping out of the
tree event.

Discussed with many at EuroBSDCon, ok deraadt@@, henning@@, claudio@@
@
text
@/*	$OpenBSD: slstats.c,v 1.21 2009/10/27 23:59:54 deraadt Exp $	*/
/*	$NetBSD: slstats.c,v 1.6.6.1 1996/06/07 01:42:30 thorpej Exp $	*/

/*
 * print serial line IP statistics:
 *	slstats [-i interval] [-v] [interface]
 *
 * Contributed by Van Jacobson (van@@ee.lbl.gov), Dec 31, 1989.
 *
 * Copyright (c) 1989, 1990, 1991, 1992 Regents of the University of
 * California. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define INET

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/file.h>

#include <net/if.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>

#include <net/slcompress.h>
#include <net/if_slvar.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <paths.h>
#include <string.h>
#include <unistd.h>

extern	char *__progname;	/* from crt0.o */

int	vflag;
u_int	interval = 5;
int	s;
char    interface[IFNAMSIZ];

void	catchalarm(int);
void	intpr(void);
void	usage(void);

int
main(int argc, char *argv[])
{
	struct ifreq ifr;
	int ch, unit;

	(void)strlcpy(interface, "sl0", sizeof(interface));

	while ((ch = getopt(argc, argv, "i:v")) != -1) {
		switch (ch) {
		case 'i':
			interval = atoi(optarg);
			if (interval <= 0)
				usage();
			break;
		case 'v':
			++vflag;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;

	if (argc > 1)
		usage();

	if (argc > 0)
		(void)strlcpy(interface, argv[0], sizeof(interface));

	if (sscanf(interface, "sl%d", &unit) != 1 || unit < 0)
		errx(1, "invalid interface '%s' specified", interface);

	s = socket(AF_INET, SOCK_DGRAM, 0);
	if (s < 0)
		err(1, "couldn't create IP socket");
	(void)strlcpy(ifr.ifr_name, interface, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCGIFFLAGS, &ifr) < 0)
		errx(1, "nonexistent interface '%s' specified", interface);

	intpr();
	exit(0);
}

#define V(offset) ((line % 20)? cur.offset - old.offset : cur.offset)

void
usage(void)
{

	fprintf(stderr, "usage: %s [-v] [-i interval] [interface]\n",
	    __progname);
	exit(1);
}

volatile sig_atomic_t	signalled; 	/* set if alarm goes off "early" */

static void
get_sl_stats(struct sl_stats *curp)
{
	struct ifslstatsreq req;

	memset(&req, 0, sizeof(req));
	(void)strlcpy(req.ifr_name, interface, sizeof(req.ifr_name));

	if (ioctl(s, SIOCGSLSTATS, &req) < 0) {
		if (errno == ENOTTY)
			errx(1, "kernel support missing");
		else
			err(1, "couldn't get slip statistics");
	}
	*curp = req.stats;
}

/*
 * Print a running summary of interface statistics.
 * Repeat display every interval seconds, showing statistics
 * collected over that interval.  Assumes that interval is non-zero.
 * First line printed at top of screen is always cumulative.
 */
void
intpr(void)
{
	struct sl_stats cur, old;
	sigset_t mask, oldmask;
	int line = 0;

	bzero(&old, sizeof(old));
	while (1) {
		get_sl_stats(&cur);

		(void)signal(SIGALRM, (void (*)(int))catchalarm);
		signalled = 0;
		(void)alarm(interval);

		if ((line % 20) == 0) {
			printf("%8.8s %6.6s %6.6s %6.6s %6.6s",
			    "IN", "PACK", "COMP", "UNCOMP", "ERR");
			if (vflag)
				printf(" %6.6s %6.6s", "TOSS", "IP");
			printf(" | %8.8s %6.6s %6.6s %6.6s %6.6s",
			    "OUT", "PACK", "COMP", "UNCOMP", "IP");
			if (vflag)
				printf(" %6.6s %6.6s", "SEARCH", "MISS");
			putchar('\n');
		}
		printf("%8u %6d %6u %6u %6u", V(sl.sl_ibytes),
		    V(sl.sl_ipackets), V(vj.vjs_compressedin),
		    V(vj.vjs_uncompressedin), V(vj.vjs_errorin));
		if (vflag)
			printf(" %6u %6u", V(vj.vjs_tossed),
			    V(sl.sl_ipackets) - V(vj.vjs_compressedin) -
			    V(vj.vjs_uncompressedin) - V(vj.vjs_errorin));
		printf(" | %8u %6d %6u %6u %6u", V(sl.sl_obytes),
		    V(sl.sl_opackets), V(vj.vjs_compressed),
		    V(vj.vjs_packets) - V(vj.vjs_compressed),
		    V(sl.sl_opackets) - V(vj.vjs_packets));
		if (vflag)
			printf(" %6u %6u", V(vj.vjs_searches),
			    V(vj.vjs_misses));

		putchar('\n');
		fflush(stdout);
		line++;

		sigemptyset(&mask);
		sigaddset(&mask, SIGALRM);
		sigprocmask(SIG_BLOCK, &mask, &oldmask);
		if (!signalled) {
			sigemptyset(&mask);
			sigsuspend(&mask);
		}
		sigprocmask(SIG_BLOCK, &oldmask, NULL);
		signalled = 0;
		(void)alarm(interval);
		old = cur;
	}
}

/*
 * Called if an interval expires before sidewaysintpr has completed a loop.
 * Sets a flag to not wait for the alarm.
 */
/* ARGSUSED */
void
catchalarm(int signo)
{
	signalled = 1;
}
@


1.21
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.20 2005/04/04 09:03:08 deraadt Exp $	*/
@


1.20
log
@nlist.h not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.19 2004/09/21 21:17:02 jaredy Exp $	*/
a36 4

#ifndef lint
static char rcsid[] = "$OpenBSD: slstats.c,v 1.19 2004/09/21 21:17:02 jaredy Exp $";
#endif
@


1.19
log
@sync usage, de-globalize a variable, and de-lint.  ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.18 2004/07/09 16:08:05 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: slstats.c,v 1.18 2004/07/09 16:08:05 deraadt Exp $";
a68 1
#include <nlist.h>
@


1.18
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.17 2003/09/06 17:27:53 jmc Exp $	*/
d6 1
a6 1
 *	slstats [-i interval] [-v] [interface] [system [core]]
d39 1
a39 1
static char rcsid[] = "$OpenBSD: slstats.c,v 1.17 2003/09/06 17:27:53 jmc Exp $";
a76 1
int	unit;
d88 1
a88 1
	int ch;
a98 1

a101 1

d104 1
d123 1
a123 1
	if (ioctl(s, SIOCGIFFLAGS, (caddr_t)&ifr) < 0)
d136 2
a137 2
	fprintf(stderr, "usage: %s [-v] %s",
	    __progname, "[-i interval] [unit-number]\n");
d229 1
@


1.17
log
@- interval specified with -i flag, not -w
- no -M or -N options
- sync usage() and SYNOPSIS

from Jeff Ito (PRs 3452 and 2453)
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.16 2003/06/26 21:36:39 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: slstats.c,v 1.16 2003/06/26 21:36:39 deraadt Exp $";
d81 1
a81 1
void	catchalarm(void);
d135 1
a135 1
usage()
d232 1
a232 1
catchalarm()
@


1.16
log
@ansi and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.15 2002/06/18 17:29:02 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: slstats.c,v 1.15 2002/06/18 17:29:02 deraadt Exp $";
d93 1
a93 1
	while ((ch = getopt(argc, argv, "i:M:N:v")) != -1) {
d138 2
a139 2
	fprintf(stderr, "usage: %s [-i interval] %s",
	    __progname, "[-v] [unit]\n");
@


1.15
log
@update copyright notice.  mckusick says that Van signed the standard
Berkeley copyright assignment form, therefore the new license should
be on these files. I just copied in the notice that Kirk mailed me.
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.14 2002/02/16 21:28:09 millert Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: slstats.c,v 1.14 2002/02/16 21:28:09 millert Exp $";
d86 1
a86 3
main(argc, argv)
	int argc;
	char *argv[];
d146 1
a146 2
get_sl_stats(curp)
	struct sl_stats *curp;
d169 1
a169 1
intpr()
d179 1
a179 1
		(void)signal(SIGALRM, (void (*)())catchalarm);
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.13 2001/11/17 19:49:41 deraadt Exp $	*/
d8 2
d13 11
a23 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d25 11
a35 2
 *	Van Jacobson (van@@ee.lbl.gov), Dec 31, 1989:
 *	- Initial distribution.
d39 1
a39 1
static char rcsid[] = "$OpenBSD: slstats.c,v 1.13 2001/11/17 19:49:41 deraadt Exp $";
@


1.13
log
@use volatile sig_atomic_t where possible; simply volatile i other places
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.12 2001/08/09 08:45:32 deraadt Exp $	*/
d28 1
a28 1
static char rcsid[] = "$OpenBSD: slstats.c,v 1.12 2001/08/09 08:45:32 deraadt Exp $";
d70 3
a72 3
void	catchalarm __P((void));
void	intpr __P((void));
void	usage __P((void));
@


1.12
log
@sync, simplify, etc.  slstats -i is now called -w, like pppstats
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.12 2001/08/09 03:39:27 deraadt Exp $	*/
d28 1
a28 1
static char rcsid[] = "$OpenBSD: slstats.c,v 1.12 2001/08/09 03:39:27 deraadt Exp $";
d134 1
a134 1
sig_atomic_t	signalled;			/* set if alarm goes off "early" */
@


1.11
log
@shrink even more
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.10 2001/06/12 21:41:32 deraadt Exp $	*/
d28 1
a28 1
static char rcsid[] = "$OpenBSD: slstats.c,v 1.10 2001/06/12 21:41:32 deraadt Exp $";
d82 1
a82 1
	(void)strcpy(interface, "sl0");
d106 4
a109 5
	if (argc > 0) {
		(void)strncpy(interface, argv[0], sizeof(interface) - 1);
		interface[sizeof(interface) - 1] = '\0';
	}
	if (sscanf(interface, "sl%d", &unit) != 1)
d115 1
a115 1
	(void)strcpy(ifr.ifr_name, interface);
d143 1
a143 2
	(void)strncpy(req.ifr_name, interface, sizeof(req.ifr_name) - 1);
	req.ifr_name[sizeof(req.ifr_name) - 1] = '\0';
d163 2
a165 2
	int oldmask;
	struct sl_stats cur, old;
d191 2
a192 4
			    V(sl.sl_ipackets) -
			    V(vj.vjs_compressedin) -
			    V(vj.vjs_uncompressedin) -
			    V(vj.vjs_errorin));
d194 1
a194 2
		    V(sl.sl_opackets),
		    V(vj.vjs_compressed),
d204 9
a212 4
		oldmask = sigblock(sigmask(SIGALRM));
		if (!signalled)
			sigpause(0);
		sigsetmask(oldmask);
@


1.10
log
@one less setuid program (use an ioctl like pppstats)
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.9 1998/07/08 22:13:30 deraadt Exp $	*/
d28 1
a28 1
static char rcsid[] = "$OpenBSD: slstats.c,v 1.9 1998/07/08 22:13:30 deraadt Exp $";
d65 1
a65 1
unsigned interval = 5;
d67 2
a73 3
int s;
char    interface[IFNAMSIZ];

d165 1
a165 1
	register int line = 0;
a167 3
#if 0
	struct sl_comp_stats ccs, ocs;
#endif
a169 3
#if 0
	bzero(&ocs, sizeof(ocs));
#endif
a171 4
#if 0
		if (zflag || rflag)
			get_sl_cstats(&ccs);
#endif		
d210 1
a210 1
		if (!signalled) {
a211 1
		}
@


1.9
log
@whack kmem gid after kvm_openfiles()
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.8 1998/03/19 07:32:08 deraadt Exp $	*/
d28 1
a28 1
static char rcsid[] = "$OpenBSD: slstats.c,v 1.8 1998/03/19 07:32:08 deraadt Exp $";
d37 1
a52 1
#include <kvm.h>
a61 6
struct nlist nl[] = {
#define N_SOFTC 0
	{ "_sl_softc" },
	"",
};

a63 5
char	*kernel;		/* kernel for namelist */
char	*kmemf;			/* memory file */

kvm_t	*kd;

d72 3
d80 1
a80 1
	char errbuf[_POSIX2_LINE_MAX];
d83 2
a92 8
		case 'M':
			kmemf = optarg;
			break;

		case 'N':
			kernel = optarg;
			break;

d107 3
a109 19
	while (argc--) {
		if (isdigit(*argv[0])) {
			unit = atoi(*argv);
			if (unit < 0)
				usage();
			continue;
		}

		/* Fall to here, we have bogus arguments. */
		usage();
	}

	/*
	 * Discard setgid privileges if not the running kernel so that bad
	 * guys can't print interesting stuff from kernel memory.
	 */
	if (kmemf != NULL || kernel != NULL) {
		setegid(getgid());
		setgid(getgid());
d111 2
d114 6
a119 10
	memset(errbuf, 0, sizeof(errbuf));
	if ((kd = kvm_openfiles(kernel, kmemf, NULL, O_RDONLY, errbuf)) == NULL)
		errx(1, "can't open kvm: %s", errbuf);

	setegid(getgid());
	setgid(getgid());

	if (kvm_nlist(kd, nl) < 0 || nl[0].n_type == 0)
		errx(1, "%s: SLIP symbols not in namelist",
		    kernel == NULL ? _PATH_UNIX : kernel);
d125 1
a125 2
#define V(offset) ((line % 20)? sc->offset - osc->offset : sc->offset)
#define AMT (sizeof(*sc) - 2 * sizeof(sc->sc_comp.tstate))
d131 1
a131 1
	fprintf(stderr, "usage: %s [-M core] [-N system] [-i interval] %s",
d136 20
a155 1
u_char	signalled;			/* set if alarm goes off "early" */
d168 4
a171 7
	struct sl_softc *sc, *osc;
	u_long addr;

	addr = nl[N_SOFTC].n_value + unit * sizeof(struct sl_softc);
	sc = (struct sl_softc *)malloc(AMT);
	osc = (struct sl_softc *)malloc(AMT);
	bzero((char *)osc, AMT);
d173 4
d178 5
a182 2
		if (kvm_read(kd, addr, (char *)sc, AMT) != AMT)
			errx(1, "kvm_read: %s", kvm_geterr(kd));
d190 1
a190 1
				"IN", "PACK", "COMP", "UNCOMP", "ERR");
d194 1
a194 1
				"OUT", "PACK", "COMP", "UNCOMP", "IP");
d199 3
a201 6
		printf("%8u %6d %6u %6u %6u",
			V(sc_if.if_ibytes),
			V(sc_if.if_ipackets),
			V(sc_comp.sls_compressedin),
			V(sc_comp.sls_uncompressedin),
			V(sc_comp.sls_errorin));
d203 10
a212 12
			printf(" %6u %6u",
				V(sc_comp.sls_tossed),
				V(sc_if.if_ipackets) -
				  V(sc_comp.sls_compressedin) -
				  V(sc_comp.sls_uncompressedin) -
				  V(sc_comp.sls_errorin));
		printf(" | %8u %6d %6u %6u %6u",
			V(sc_if.if_obytes),
			V(sc_if.if_opackets),
			V(sc_comp.sls_compressed),
			V(sc_comp.sls_packets) - V(sc_comp.sls_compressed),
			V(sc_if.if_opackets) - V(sc_comp.sls_packets));
d214 2
a215 3
			printf(" %6u %6u",
				V(sc_comp.sls_searches),
				V(sc_comp.sls_misses));
d221 1
a221 1
		if (! signalled) {
d227 1
a227 1
		bcopy((char *)sc, (char *)osc, AMT);
@


1.8
log
@bring in memset() proto
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.7 1996/12/22 03:29:06 deraadt Exp $	*/
d28 1
a28 1
static char rcsid[] = "$OpenBSD: slstats.c,v 1.7 1996/12/22 03:29:06 deraadt Exp $";
d145 3
@


1.7
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.6 1996/12/10 15:14:33 deraadt Exp $	*/
d28 1
a28 1
static char rcsid[] = "$OpenBSD: slstats.c,v 1.6 1996/12/10 15:14:33 deraadt Exp $";
d59 1
@


1.6
log
@typo fix from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.5 1996/08/05 12:02:54 deraadt Exp $	*/
d28 1
a28 1
static char rcsid[] = "$OpenBSD: slstats.c,v 1.5 1996/08/05 12:02:54 deraadt Exp $";
d136 2
a137 1
	if (kmemf != NULL || kernel != NULL)
d139 1
@


1.5
log
@fix id
@
text
@d1 1
a1 1
/*	$OpenBSD: slstats.c,v 1.4 1996/06/10 08:38:55 deraadt Exp $	*/
d28 1
a28 1
static char rcsid[] = "$OpenBSD$";
d67 1
a67 1
extern	char __progname;	/* from crt0.o */
@


1.4
log
@support strip, use kvm_openfiles
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d28 1
a28 1
static char rcsid[] = "$OpenBSD";
@


1.3
log
@use strcmp()
@
text
@d1 3
d6 1
a6 1
 *	slstats [-i interval] [-v] [interface] [system] [core]
d28 1
a28 3
/*static char rcsid[] =
    "@@(#) $Header: /cvs/src/usr.sbin/slstats/slstats.c,v 1.2 1996/05/30 09:11:17 deraadt Exp $ (LBL)";*/
static char rcsid[] = "$Id: slstats.c,v 1.2 1996/05/30 09:11:17 deraadt Exp $";
a30 4
#include <stdio.h>
#include <paths.h>
#include <nlist.h>

d38 1
a38 2
#include <errno.h>
#include <signal.h>
d48 13
d67 6
a72 2
char	*system = _PATH_UNIX;
char	*kmemf = _PATH_KMEM;
a73 1
int	kflag;
d78 3
a80 2
extern	char *malloc();
extern	off_t lseek();
d82 1
d87 7
a93 10
	--argc; ++argv;
	while (argc > 0) {
		if (strcmp(argv[0], "-v") == 0) {
			++vflag;
			++argv, --argc;
			continue;
		}
		if (strcmp(argv[0], "-i") == 0 && argv[1] &&
		    isdigit(argv[1][0])) {
			interval = atoi(argv[1]);
d96 16
a111 3
			++argv, --argc;
			++argv, --argc;
			continue;
d113 10
a122 2
		if (isdigit(argv[0][0])) {
			unit = atoi(argv[0]);
a124 1
			++argv, --argc;
a126 2
		if (kflag)
			usage();
d128 2
a129 7
		system = *argv;
		++argv, --argc;
		if (argc > 0) {
			kmemf = *argv++;
			--argc;
			kflag++;
		}
d131 2
a132 1
        /*
d136 1
a136 1
	if (!strcmp(kmemf, _PATH_KMEM) || !strcmp(system, _PATH_UNIX))
d139 8
a146 4
	if (kopen(system, kmemf, "slstats") < 0)
		exit(1);
	if (knlist(system, nl, "slstats") < 0)
		exit(1);
d154 1
a156 2
	static char umsg[] =
		"usage: slstats [-i interval] [-v] [unit] [system] [core]\n";
d158 2
a159 1
	fprintf(stderr, umsg);
d171 1
a175 1
	void catchalarm();
d177 1
a177 1
	off_t addr;
d185 4
a188 3
		if (kread(addr, (char *)sc, AMT) < 0)
			perror("kmem read");
		(void)signal(SIGALRM, catchalarm);
a248 49
}

#include <kvm.h>
#include <fcntl.h>

kvm_t *kd;

kopen(system, kmemf, errstr)
	char *system;
	char *kmemf;
	char *errstr;
{
	if (strcmp(system, _PATH_UNIX) == 0 &&
	    strcmp(kmemf, _PATH_KMEM) == 0) {
		system = 0;
		kmemf = 0;
	}
	kd = kvm_open(system, kmemf, NULL, O_RDONLY, "slstats");
	if (kd == NULL) 
		return -1;
	return 0;
}

int
knlist(system, nl, errstr)
	char *system;
	struct nlist *nl;
	char *errstr;
{
	if (kd == 0)
		/* kopen() must be called first */
		abort();
		
	if (kvm_nlist(kd, nl) < 0 || nl[0].n_type == 0) {
		fprintf(stderr, "%s: %s: no namelist\n", errstr, system);
		return -1;
	}
	return 0;
}

int
kread(addr, buf, size)
	off_t addr;
	char *buf;
	int size;
{
	if (kvm_read(kd, (u_long)addr, buf, size) != size)
		return -1;
	return 0;
@


1.2
log
@revoke privs before opening kvm if user has specified mem/kernel paths
@
text
@d26 2
a27 2
    "@@(#) $Header: /cvs/src/usr.sbin/slstats/slstats.c,v 1.1.1.1 1995/10/18 08:48:21 deraadt Exp $ (LBL)";*/
static char rcsid[] = "$Id: slstats.c,v 1.1.1.1 1995/10/18 08:48:21 deraadt Exp $";
d111 1
a111 1
	if (system != _PATH_UNIX || kmemf != _PATH_KMEM)
@


1.1
log
@Initial revision
@
text
@d26 2
a27 2
    "@@(#) $Header: /a/cvsroot/src/usr.sbin/slstats/slstats.c,v 1.6 1994/11/13 11:20:52 glass Exp $ (LBL)";*/
static char rcsid[] = "$Id: slstats.c,v 1.6 1994/11/13 11:20:52 glass Exp $";
d107 7
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

