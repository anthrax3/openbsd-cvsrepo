head	1.63;
access;
symbols
	OPENBSD_6_0:1.63.0.8
	OPENBSD_6_0_BASE:1.63
	OPENBSD_5_9:1.63.0.4
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.63.0.6
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.61.0.4
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.58.0.8
	OPENBSD_5_4_BASE:1.58
	OPENBSD_5_3:1.58.0.6
	OPENBSD_5_3_BASE:1.58
	OPENBSD_5_2:1.58.0.4
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.58
	OPENBSD_5_1:1.58.0.2
	OPENBSD_5_0:1.57.0.2
	OPENBSD_5_0_BASE:1.57
	OPENBSD_4_9:1.53.0.18
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.53.0.16
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.53.0.12
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.53.0.14
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.53.0.10
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.53.0.8
	OPENBSD_4_4_BASE:1.53
	OPENBSD_4_3:1.53.0.6
	OPENBSD_4_3_BASE:1.53
	OPENBSD_4_2:1.53.0.4
	OPENBSD_4_2_BASE:1.53
	OPENBSD_4_1:1.53.0.2
	OPENBSD_4_1_BASE:1.53
	OPENBSD_4_0:1.51.0.2
	OPENBSD_4_0_BASE:1.51
	OPENBSD_3_9:1.50.0.4
	OPENBSD_3_9_BASE:1.50
	OPENBSD_3_8:1.50.0.2
	OPENBSD_3_8_BASE:1.50
	OPENBSD_3_7:1.48.0.2
	OPENBSD_3_7_BASE:1.48
	OPENBSD_3_6:1.47.0.6
	OPENBSD_3_6_BASE:1.47
	OPENBSD_3_5:1.47.0.4
	OPENBSD_3_5_BASE:1.47
	OPENBSD_3_4:1.47.0.2
	OPENBSD_3_4_BASE:1.47
	OPENBSD_3_3:1.40.0.2
	OPENBSD_3_3_BASE:1.40
	OPENBSD_3_2:1.39.0.2
	OPENBSD_3_2_BASE:1.39
	OPENBSD_3_1:1.37.0.2
	OPENBSD_3_1_BASE:1.37
	OPENBSD_3_0:1.34.0.2
	OPENBSD_3_0_BASE:1.34
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_9:1.29.0.2
	OPENBSD_2_8:1.24.0.2
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.21.0.2
	OPENBSD_2_7_BASE:1.21
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@# @;


1.63
date	2014.10.01.09.56.36;	author mpi;	state Exp;
branches;
next	1.62;
commitid	YjUss0iJWhbDg71W;

1.62
date	2014.07.13.20.09.38;	author tedu;	state Exp;
branches;
next	1.61;
commitid	rsM059GsiHp0ulYP;

1.61
date	2014.02.15.06.27.50;	author tedu;	state Exp;
branches;
next	1.60;

1.60
date	2014.02.15.06.25.18;	author tedu;	state Exp;
branches;
next	1.59;

1.59
date	2014.02.14.19.08.03;	author tedu;	state Exp;
branches;
next	1.58;

1.58
date	2011.09.22.10.59.23;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2011.05.12.13.56.23;	author lum;	state Exp;
branches;
next	1.56;

1.56
date	2011.05.12.10.38.27;	author lum;	state Exp;
branches;
next	1.55;

1.55
date	2011.05.12.05.13.42;	author lum;	state Exp;
branches;
next	1.54;

1.54
date	2011.05.11.08.18.43;	author lum;	state Exp;
branches;
next	1.53;

1.53
date	2007.01.03.15.26.04;	author simon;	state Exp;
branches;
next	1.52;

1.52
date	2006.12.30.09.34.00;	author ray;	state Exp;
branches;
next	1.51;

1.51
date	2006.06.07.16.02.19;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2005.08.31.17.28.15;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2005.03.30.22.12.38;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2005.02.24.16.45.02;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2003.06.17.00.58.30;	author jsyn;	state Exp;
branches;
next	1.46;

1.46
date	2003.06.14.23.23.08;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.10.21.55.02;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.09.00.33.52;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.08.21.05.29;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.13.01.23.10;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2003.04.03.18.55.33;	author jmc;	state Exp;
branches;
next	1.40;

1.40
date	2003.03.11.04.45.54;	author david;	state Exp;
branches;
next	1.39;

1.39
date	2002.07.10.19.57.31;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2002.06.14.21.35.01;	author todd;	state Exp;
branches;
next	1.37;

1.37
date	2002.03.05.17.23.45;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2002.02.23.18.54.55;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.18.21.40.08;	author ericj;	state Exp;
branches;
next	1.34;

1.34
date	2001.10.09.18.25.31;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2001.10.01.15.26.33;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.07.20.34.11;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.03.16.19.32;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.06.15.39.36;	author mpech;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.09.18.31.36;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2001.01.31.21.12.58;	author chris;	state Exp;
branches;
next	1.27;

1.27
date	2000.12.30.06.43.24;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.26.02.18.06;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2000.11.25.23.22.33;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.10.16.04.15;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2000.08.19.07.50.19;	author jakob;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.09.16.11.34;	author aaron;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.25.21.08.41;	author jakob;	state Exp;
branches;
next	1.20;

1.20
date	2000.01.03.19.30.00;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	99.09.06.16.48.41;	author alex;	state Exp;
branches;
next	1.18;

1.18
date	99.07.03.23.56.18;	author hugh;	state Exp;
branches;
next	1.17;

1.17
date	99.06.29.12.23.26;	author aaron;	state Exp;
branches;
next	1.16;

1.16
date	99.06.17.20.06.28;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	99.02.04.19.38.39;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	99.01.18.03.05.48;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.01.16.03.13.01;	author weingart;	state Exp;
branches;
next	1.12;

1.12
date	98.12.29.12.04.37;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.10.14.19.40.27;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.09.22.01.40.30;	author weingart;	state Exp;
branches;
next	1.9;

1.9
date	98.07.20.07.20.58;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.06.03.05.36.57;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.02.16.16.44.24;	author bitblt;	state Exp;
branches;
next	1.6;

1.6
date	98.02.16.16.04.41;	author bitblt;	state Exp;
branches;
next	1.5;

1.5
date	97.05.29.04.26.56;	author gene;	state Exp;
branches;
next	1.4;

1.4
date	97.02.25.00.01.52;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.02.20.01.24.17;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.12.08.13.57.07;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.09.28.05.58.35;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.63
log
@Do not mention sliplogin(8) and sl(4).
@
text
@#!/usr/bin/perl
#
#	$OpenBSD: adduser.perl,v 1.62 2014/07/13 20:09:38 tedu Exp $
#
# Copyright (c) 1995-1996 Wolfram Schneider <wosch@@FreeBSD.org>. Berlin.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# $From: adduser.perl,v 1.22 1996/12/07 21:25:12 ache Exp $

use IPC::Open2;
use Fcntl qw(:DEFAULT :flock);

################
# main
#
$check_only = 0;

$SIG{'INT'} = 'cleanup';
$SIG{'QUIT'} = 'cleanup';
$SIG{'HUP'} = 'cleanup';
$SIG{'TERM'} = 'cleanup';

&check_root;			# you must be root to run this script!
&variables;			# initialize variables
&config_read(@@ARGV);		# read variables from config-file
&parse_arguments(@@ARGV);	# parse arguments

if (!$check_only && $#batch < 0) {
    &hints;
}

# check
$changes = 0;
&variable_check;		# check for valid variables
&passwd_check;			# check for valid passwdb
&shells_read;			# read /etc/shells
&login_conf_read;		# read /etc/login.conf
&passwd_read;			# read /etc/master.passwd
&group_read;			# read /etc/group
&group_check;			# check for incon*
exit 0 if $check_only;		# only check consistence and exit

exit(!&batch(@@batch)) if $#batch >= 0; # batch mode

# Interactive:
# main loop for creating new users
&new_users;	     # add new users

#end


# Set adduser "default" variables internally before groking config file
# Adduser.conf supersedes these
sub variables {
    $verbose = 1;		# verbose = [0-2]
    $defaultpasswd = "yes";	# use password for new users
    $dotdir = "/etc/skel";	# copy dotfiles from this dir
    $dotdir_bak = $dotdir;
    $send_message = "no"; 	# send message to new user
    $message_file = "/etc/adduser.message";
    $config = "/etc/adduser.conf"; # config file for adduser
    $config_read = 1;		# read config file
    $logfile = "/var/log/adduser"; # logfile
    $home = "/home";		# default HOME
    $etc_shells = "/etc/shells";
    $etc_passwd = "/etc/master.passwd";
    $etc_ptmp = "/etc/ptmp";
    $group = "/etc/group";
    $etc_login_conf = "/etc/login.conf";
    @@pwd_mkdb = ("pwd_mkdb", "-p");	# program for building passwd database
    $encryptionmethod = "auto";

    # List of directories where shells located
    @@path = ('/bin', '/usr/bin', '/usr/local/bin');
    # common shells, first element has higher priority
    @@shellpref = ('csh', 'sh', 'bash', 'tcsh', 'ksh');

    @@encryption_methods = ('auto', 'blowfish' );

    $defaultshell = 'ksh';	# defaultshell if not empty
    $group_uniq = 'USER';
    $defaultgroup = $group_uniq;# login groupname, $group_uniq means username
    $defaultclass = 'default';  # default user login class

    $uid_start = 1000;		# new users get this uid
    $uid_end   = 2147483647;	# max. uid

    # global variables
    # passwd
    %username = ();		# $username{username} = uid
    %uid = ();			# $uid{uid} = username
    %pwgid = ();		# $pwgid{pwgid} = username; gid from passwd db

    $password = '';		# password for new users

    # group
    %groupname = ();		# $groupname{groupname} = gid
    %groupmembers = ();		# $groupmembers{gid} = members of group/kommalist
    %gid = ();			# $gid{gid} = groupname;    gid from group db

    # shell
    %shell = ();		# $shell{`basename sh`} = sh

    umask 022;			# don't give login group write access

    # regexs used in determining user supplied yes/no
    $yes = qr/^(yes|YES|y|Y)$/;
    $no = qr/^(no|NO|n|N)$/;

    $ENV{'PATH'} = "/sbin:/bin:/usr/sbin:/usr/bin";
    @@passwd_backup = ();
    @@group_backup = ();
    @@message_buffer = ();
    @@login_classes = ();
    @@user_variable_list = ();	# user variables in /etc/adduser.conf
    $do_not_delete = '## DO NOT DELETE THIS LINE!';
}

sub login_conf_read {
     foreach (`getcap -f $etc_login_conf -a -s localcipher`) {
	chomp;
	s/:.*//;
	push(@@login_classes, $_);
     }
}

# read shell database, see also: shells(5)
sub shells_read {
    local($sh);
    local($err) = 0;

    print "Reading $etc_shells\n" if $verbose;
    open(S, $etc_shells) || die "$etc_shells: $!\n";

    while(<S>) {
	if (/^\s*\//) {
	    s/^\s*//; s/\s+.*//; # chop
	    $sh = $_;
	    if (-x  $sh) {
		$shell{&basename($sh)} = $sh;
	    } else {
		warn "Shell: $sh not executable!\n";
		$err++;
	    }
	}
    }
    close(S);

    push(@@list, "/sbin/nologin");
    &shell_pref_add("nologin");
    $shell{"nologin"} = "/sbin/nologin";

    return $err;
}

# add new shells if possible
sub shells_add {
    local($sh,$dir,@@list);

    return 1 unless $verbose;

    foreach $sh (@@shellpref) {
	# all known shells
	if (!$shell{$sh}) {
	    # shell $sh is not defined as login shell
	    foreach $dir (@@path) {
		if (-x "$dir/$sh") {
		    # found shell
		    if (&confirm_yn("Found shell: $dir/$sh. Add to $etc_shells?", "yes")) {
			push(@@list, "$dir/$sh");
			&shell_pref_add("$sh");
			$shell{&basename("$dir/$sh")} = "$dir/$sh";
			$changes++;
		    }
		}
	    }
	}
    }
    &append_file($etc_shells, @@list) if $#list >= 0;
}

# add shell to preference list without duplication
sub shell_pref_add {
    local($new_shell) = @@_;
    local($shell);

    foreach $shell (@@shellpref) {
	return if ($shell eq $new_shell);
    }
    push(@@shellpref, $new_shell);
}

# choose your favourite shell and return the shell
sub shell_default {
    local($e,$i,$new_shell);
    local($sh);

    $sh = &shell_default_valid($defaultshell);
    return $sh unless $verbose;

    $new_shell = &confirm_list("Enter your default shell:", 0,
		       $sh, sort(keys %shell));
    print "Your default shell is: $new_shell -> $shell{$new_shell}\n";
    $changes++ if $new_shell ne $sh;
    return $new_shell;
}

sub shell_default_valid {
    local($sh) = @@_;
    local($s,$e);

    return $sh if $shell{$sh};

    foreach $e (@@shellpref) {
	$s = $e;
	last if defined($shell{$s});
    }
    $s = "sh" unless $s;
    warn "Shell ``$sh'' is undefined, use ``$s''\n";
    return $s;
}

# return default home partition (e.g. "/home")
# create base directory if necessary
sub home_partition {
    local($home) = @@_;
    $home = &stripdir($home);
    local($h) = $home;

    return $h if !$verbose && $h eq &home_partition_valid($h);

    while(1) {
	$h = &confirm_list("Enter your default HOME partition:", 1, $home, "");
	$h = &stripdir($h);
	last if $h eq &home_partition_valid($h);
    }

    $changes++ if $h ne $home;
    return $h;
}

sub home_partition_valid {
    local($h) = @@_;

    $h = &stripdir($h);
    # all right (I hope)
    return $h if $h =~ "^/" && -e $h && -w _ && (-d _ || -l $h);

    # Errors or todo
    if ($h !~ "^/") {
	warn "Please use absolute path for home: ``$h''.\a\n";
	return 0;
    }

    if (-e $h) {
	warn "$h exists, but is not a directory or symlink!\n"
	    unless -d $h || -l $h;
	warn "$h is not writable!\n"
	    unless -w $h;
	return 0;
    } else {
	# create home partition
	return $h if &mkdir_home($h);
    }
    return 0;
}

# check for valid passwddb
sub passwd_check {
    system(@@pwd_mkdb, "-c", $etc_passwd);
    die "\nInvalid $etc_passwd - cannot add any users!\n" if $?;
}

# read /etc/passwd
sub passwd_read {
    local($p_username, $pw, $p_uid, $p_gid, $sh);

    print "Check $etc_passwd\n" if $verbose;
    open(P, "$etc_passwd") || die "$etc_passwd: $!\n";

    # we only use this to lock the password file
    sysopen(PTMP, $etc_ptmp, O_RDWR|O_CREAT|O_EXCL, 0600) ||
	die "Password file busy\n";

    while(<P>) {
	chop;
	push(@@passwd_backup, $_);
	($p_username, $pw, $p_uid, $p_gid, $sh) = (split(/:/, $_))[0..3,9];

	print "$p_username already exists with uid: $username{$p_username}!\n"
	    if $username{$p_username} && $verbose;
	$username{$p_username} = $p_uid;
	print "User $p_username: uid $p_uid exists twice: $uid{$p_uid}\n"
	    if $uid{$p_uid} && $verbose && $p_uid;    # don't warn for uid 0
	print "User $p_username: illegal shell: ``$sh''\n"
	    if ($verbose && $sh &&
		!$shell{&basename($sh)} &&
		$p_username !~ /^(news|xten|bin|nobody|uucp)$/ &&
		$sh !~ /\/pppd$/);
	$uid{$p_uid} = $p_username;
	$pwgid{$p_gid} = $p_username;
    }
    close P;
}

# read /etc/group
sub group_read {
    local($g_groupname,$pw,$g_gid, $memb);

    print "Check $group\n" if $verbose;
    open(G, "$group") || die "$group: $!\n";
    while(<G>) {
	chop;
	push(@@group_backup, $_);
	($g_groupname, $pw, $g_gid, $memb) = (split(/:/, $_))[0..3];

	$groupmembers{$g_gid} = $memb;
	warn "Groupname exists twice: $g_groupname:$g_gid -> $g_groupname:$groupname{$g_groupname}\n"
	    if $groupname{$g_groupname} && $verbose;
	$groupname{$g_groupname} = $g_gid;
	warn "Groupid exists twice:   $g_groupname:$g_gid -> $gid{$g_gid}:$g_gid\n"
	    if $gid{$g_gid} && $verbose;
	$gid{$g_gid} = $g_groupname;
    }
    close G;
}

# check gids /etc/passwd <-> /etc/group
sub group_check {
    local($c_gid, $c_username, @@list);

    foreach $c_gid (keys %pwgid) {
	if (!$gid{$c_gid}) {
	    $c_username = $pwgid{$c_gid};
	    warn "User ``$c_username'' has gid $c_gid but a group with this " .
		"gid does not exist.\n" if $verbose;
	}
    }
}

#
# main loop for creating new users
#

# return username
sub new_users_name {
    local($name);

    while(1) {
	$name = &confirm_list("Enter username", 1, "", "");
	if (length($name) > 31) {
	    warn "Username is longer than 31 characters\a\n";
	    next;
	}
	last if (&new_users_name_valid($name) eq $name);
    }
    return $name;
}

sub new_users_name_valid {
    local($name) = @@_;

    if ($name !~ /^[a-zA-Z0-9_\.][a-zA-Z0-9_\.\-]*\$?$/ || $name eq "") {
	warn "Illegal username. " .
	    "Please see the restrictions section of the man page.\a\n";
	return 0;
    } elsif ($username{$name}) {
	warn "Username ``$name'' already exists!\a\n"; return 0;
    }
    return $name;
}

# return full name
sub new_users_fullname {
    local($name) = @@_;
    local($fullname);

    while(1) {
	$fullname = &confirm_list("Enter full name", 1, "", "");
	last if $fullname eq &new_users_fullname_valid($fullname);
    }
    $fullname = $name unless $fullname;
    return $fullname;
}

sub new_users_fullname_valid {
    local($fullname) = @@_;

    return $fullname if $fullname !~ /:/;

    warn "``:'' is not allowed!\a\n";
    return 0;
}

# return shell (full path) for user
sub new_users_shell {
    local($sh);

    $sh = &confirm_list("Enter shell", 0, $defaultshell, keys %shell);
    return $shell{$sh};
}

sub new_users_login_class {
    local($log_cl);
	
    $log_cl = &confirm_list("Login class", 0, $defaultclass, @@login_classes);
    return($log_cl);
}

# return free uid and gid
sub new_users_id {
    local($name) = @@_;
    local($u_id, $g_id) = &next_id($name);
    local($u_id_tmp, $e);

    while(1) {
	$u_id_tmp = &confirm_list("Uid", 1, $u_id, "");
	last if $u_id_tmp =~ /^[0-9]+$/ && $u_id_tmp <= $uid_end &&
		! $uid{$u_id_tmp};
	if ($uid{$u_id_tmp}) {
	    warn "Uid ``$u_id_tmp'' in use!\a\n";
	} else {
	    warn "Wrong uid.\a\n";
	}
    }
    # use calculated uid
    return ($u_id_tmp, $g_id) if $u_id_tmp eq $u_id;
    # recalculate gid
    $uid_start = $u_id_tmp;
    return &next_id($name);
}

# add user to group
sub add_group {
    local($gid, $name) = @@_;

    return 0 if
	$groupmembers{$gid} =~ /^(.*,)?$name(,.*)?$/;

    $groupmembers_bak{$gid} = $groupmembers{$gid};
    $groupmembers{$gid} .= "," if $groupmembers{$gid};
    $groupmembers{$gid} .= "$name";

    local(@@l) = split(',', $groupmembers{$gid});
    # group(5): A group cannot have more than 200 members.
    # The maximum line length of /etc/group is 1024 characters.
    # Longer lines will be skipped.
    if ($#l >= 200 ||
	length($groupmembers{$gid}) > 1024 - 50) { # 50 is for group name
	warn "WARNING, group line ``$gid{$gid}'' is either too long or has\n" .
	    "too many users in the group, see group(5)\a\n";
    }
    return $name;
}


# return login group
sub new_users_grplogin {
    local($name, $defaultgroup, $new_users_ok) = @@_;
    local($group_login, $group);

    $group = $name;
    $group = $defaultgroup if $defaultgroup ne $group_uniq;

    if ($new_users_ok) {
	# clean up backup
	foreach $e (keys %groupmembers_bak) { delete $groupmembers_bak{$e}; }
    } else {
	# restore old groupmembers, user was not accept
	foreach $e (keys %groupmembers_bak) {
	    $groupmembers{$e} = $groupmembers_bak{$e};
	}
    }

    while(1) {
	$group_login = &confirm_list("Login group", 1, $group,
				     ($name, $group));
	last if $group_login eq $group;
	last if $group_login eq $name;
	last if defined $groupname{$group_login};
	if ($group_login eq $group_uniq) {
	    $group_login = $name; last;
	}

	if (defined $gid{$group_login}) {
	    # convert numeric groupname (gid) to groupname
	    $group_login = $gid{$group_login};
	    last;
	}
	warn "Group does not exist!\a\n";
    }

    #if (defined($groupname{$group_login})) {
    #	&add_group($groupname{$group_login}, $name);
    #}

    return ($group_login, $group_uniq) if $group_login eq $name;
    return ($group_login, $group_login);
}

# return login group
sub new_users_grplogin_batch {
    local($name, $defaultgroup) = @@_;
    local($group_login, $group);

    $group_login = $name;
    $group_login = $defaultgroup if $defaultgroup ne $group_uniq;

    if (defined $gid{$group_login}) {
	# convert numeric groupname (gid) to groupname
	$group_login = $gid{$group_login};
    }

    # if (defined($groupname{$group_login})) {
    #	&add_group($groupname{$group_login}, $name);
    # }

    return $group_login
	if defined($groupname{$group_login}) || $group_login eq $name;
    warn "Group ``$group_login'' does not exist\a\n";
    return 0;
}

# return other groups (string)
sub new_users_groups {
    local($name, $other_groups) = @@_;
    local($string) =
	"Login group is ``$group_login''. Invite $name into other groups:";
    local($e, $flag);
    local($new_groups,$groups);

    $other_groups = "no" unless $other_groups;

    while(1) {
	$groups = &confirm_list($string, 1, $other_groups,
				("no", $other_groups, "guest"));
	# no other groups
	return "" if $groups eq "no";

	($flag, $new_groups) = &new_users_groups_valid($groups);
	last unless $flag;
    }
    $new_groups =~ s/\s*$//;
    return $new_groups;
}

sub new_users_groups_valid {
    local($groups) = @@_;
    local($e, $new_groups);
    local($flag) = 0;

    foreach $e (split(/[,\s]+/, $groups)) {
	# convert numbers to groupname
	if ($e =~ /^[0-9]+$/ && $gid{$e}) {
	    $e = $gid{$e};
	}
	if (defined($groupname{$e})) {
	    if ($e eq $group_login) {
		# do not add user to a group if this group
		# is also the login group.
	    } elsif (&add_group($groupname{$e}, $name)) {
		$new_groups .= "$e ";
	    } else {
		warn "$name is already member of group ``$e''\n";
	    }
	} else {
	    warn "Group ``$e'' does not exist\a\n"; $flag++;
	}
    }
    return ($flag, $new_groups);
}

# your last chance
sub new_users_ok {

    print <<EOF;

Name:	     $name
Password:    ****
Fullname:    $fullname
Uid:	     $u_id
Gid:	     $g_id ($group_login)
Groups:	     $group_login $new_groups
Login Class: $log_cl
HOME:	     $home/$name
Shell:	     $sh
EOF

    return &confirm_yn("OK?", "yes");
}

# make password database
sub new_users_pwdmkdb {
    local($last) = @@_;
    local($user);

    $user = (split(/:/, $last))[0];
    system(@@pwd_mkdb, "-u", $user, $etc_passwd);
    if ($?) {
	warn "$last\n";
	warn "``pwd_mkdb'' failed\n";
	exit($? >> 8);
    }
}

# update group database
sub new_users_group_update {
    local($e, $n, $a, @@a);

    # Add *new* group
    if (!defined($groupname{$group_login}) && !defined($gid{$g_id})) {
	push(@@group_backup, "$group_login:*:$g_id:");
	$groupname{$group_login} = $g_id;
	$gid{$g_id} = $group_login;
	# $groupmembers{$g_id} = $group_login;
    }

    if ($new_groups || defined($groupname{$group_login}) ||
	defined($gid{$groupname{$group_login}}) &&
		$gid{$groupname{$group_login}} ne "+") {
	# new user is member of some groups
	# new login group is already in name space
	rename($group, "$group.bak");
	#warn "$group_login $groupname{$group_login} $groupmembers{$groupname{$group_login}}\n";
	foreach (@@group_backup) {
            ($n, $e) = (split(/:/, $_))[0,2];
	    # special handling of YP entries
	    if (substr($n, 0, 1) eq "+") {
		# remember and skip the empty group
		if (length($n) == 1) {
			$a = $_;
			next;
		}
		# pass other groups
		push(@@a, $_);
	    }
	    # group membership might have changed
	    else {
		push(@@a, "$gid{$e}:*:$e:$groupmembers{$e}");
	    }
	}
	# append empty YP group
	if ($a) {
	    push(@@a, $a);
	}
	&append_file($group, @@a);
    } else {
	&append_file($group, "$group_login:*:$g_id:");
    }

}

sub new_users_passwd_update {
    # update passwd/group variables
    push(@@passwd_backup, $new_entry);
    $username{$name} = $u_id;
    $uid{$u_id} = $name;
    $pwgid{$g_id} = $name;
}

# send message to new user
sub new_users_sendmessage {
    return 1 if $send_message eq "no";

    return 1 if !&confirm_yn("Send welcome message to ``$name''", "yes");

    @@message_buffer = ();
    message_read ($message_file);

    local($e);

    foreach $e (@@message_buffer) {
	print eval "\"$e\"";
    }
    print "\n";

    local(@@message_buffer_append) = ();
    if (!&confirm_yn("Add anything to the message", "no")) {
	print "Use ``.'' or ^D alone on a line to finish your message.\n";
	push(@@message_buffer_append, "\n");
	while($read = <STDIN>) {
	    last if $read eq "\.\n";
	    push(@@message_buffer_append, $read);
	}
    }
    local($cc) =
	&confirm_list("Copy message to another user?:",
		      1, "no", ("root", "second_mail_address",
		      "no"));
    $cc = "" if $cc eq "no";

    &sendmessage("$name $cc", (@@message_buffer, @@message_buffer_append));
}

sub sendmessage {
    local($to, @@message) = @@_;
    local($e);

    if (!open(M, "| mail -s Welcome $to")) {
	warn "Cannot send mail to: $to!\n";
	return 0;
    } else {
	foreach $e (@@message) {
	    print M eval "\"$e\"";
	}
	close M;
	print "Mail sent!\n" if $verbose;
    }
}


sub new_users_password {

    # empty password
    return "" if $defaultpasswd ne "yes";

    local($password);

    while(1) {
	system("stty", "-echo");
	$password = &confirm_list("Enter password", 1, "", "");
	system("stty", "echo");
	print "\n";
	if ($password ne "") {
	    system("stty", "-echo");
	    $newpass = &confirm_list("Enter password again", 1, "", "");
	    system("stty", "echo");
	    print "\n";
	    last if $password eq $newpass;
	    print "They didn't match, please try again\n";
	}
	elsif (!&confirm_yn("Disable password logins for the user?", "no")) {
	    last;
	}
    }

    return $password;
}


sub new_users {

    print "\n" if $verbose;
    print "Ok, let's go.\n" .
	  "Don't worry about mistakes. There will be a chance later to " .
	  "correct any input.\n" if $verbose;

    # name: Username
    # fullname: Full name
    # sh: shell
    # u_id: user id
    # g_id: group id
    # group_login: groupname of g_id
    # new_groups: some other groups
    # log_cl: login class
    local($name, $group_login, $fullname, $sh, $u_id, $g_id, $new_groups,
	$log_cl);
    local($groupmembers_bak, $cryptpwd);
    local($new_users_ok) = 1;


    $new_groups = "no" unless $groupname{$new_groups};

    while(1) {
	$name = &new_users_name;
	$fullname = &new_users_fullname($name);
	$sh = &new_users_shell;
	($u_id, $g_id) = &new_users_id($name);
	($group_login, $defaultgroup) =
	    &new_users_grplogin($name, $defaultgroup, $new_users_ok);
	# do not use uniq username and login group
	$g_id = $groupname{$group_login} if (defined($groupname{$group_login}));

	$new_groups = &new_users_groups($name, $new_groups);
	$log_cl = &new_users_login_class;
	$password = &new_users_password;


	if (&new_users_ok) {
	    $new_users_ok = 1;

	    $cryptpwd = "*";	# Locked by default
	    $cryptpwd = encrypt($password, &salt) if ($password ne "");
	    $log_cl = "" if ($log_cl eq "default");

	    # obscure perl bug
	    $new_entry = "$name\:" . "$cryptpwd" .
		"\:$u_id\:$g_id\:$log_cl:0:0:$fullname:$home/$name:$sh";
	    &append_file($etc_passwd, "$new_entry");
	    &new_users_pwdmkdb("$new_entry");
	    &new_users_group_update;
	    &new_users_passwd_update;  print "Added user ``$name''\n";
	    &adduser_log("$name:*:$u_id:$g_id($group_login):$fullname");
	    &home_create($name, $group_login);
	    &new_users_sendmessage;
	} else {
	    $new_users_ok = 0;
	}
	if (!&confirm_yn("Add another user?", "yes")) {
	    print "Goodbye!\n" if $verbose;
	    last;
	}
	print "\n" if !$verbose;
    }
}

sub batch {
    local($name, $groups, $fullname, $password) = @@_;
    local($sh);

    $defaultshell = &shell_default_valid($defaultshell);
    return 0 unless $home = &home_partition_valid($home);
    return 0 if $dotdir ne &dotdir_default_valid($dotdir);
    $message_file = &choosetxt_yn_default($send_message, $message_file);
    $send_message = &message_default;

    return 0 if $name ne &new_users_name_valid($name);
    $sh = $shell{$defaultshell};
    ($u_id, $g_id) = &next_id($name);
    $group_login = &new_users_grplogin_batch($name, $defaultgroup);
    return 0 unless $group_login;
    $g_id = $groupname{$group_login} if (defined($groupname{$group_login}));
    ($flag, $new_groups) = &new_users_groups_valid($groups);
    return 0 if $flag;
    $log_cl = ($defaultclass eq "default") ? "" : $defaultclass;

    $cryptpwd = "*";	# Locked by default
    if ($password ne "" && $password ne "*") {
	if($unencrypted)	{ $cryptpwd = encrypt($password, &salt) }
	else			{ $cryptpwd = $password }
    }
    # obscure perl bug
    $new_entry = "$name\:" . "$cryptpwd" .
	"\:$u_id\:$g_id\:$log_cl:0:0:$fullname:$home/$name:$sh";
    &append_file($etc_passwd, "$new_entry");
    &new_users_pwdmkdb("$new_entry");
    &new_users_group_update;
    &new_users_passwd_update;  print "Added user ``$name''\n";
    &sendmessage($name, @@message_buffer) if $send_message ne "no";
    &adduser_log("$name:*:$u_id:$g_id($group_login):$fullname");
    &home_create($name, $group_login);
}

# ask for password usage
sub password_default {
    local($p) = $defaultpasswd;
    if ($verbose) {
	$p = &confirm_yn("Prompt for passwords by default", $defaultpasswd);
	$changes++ unless $p;
    }
    return "yes" if (($defaultpasswd eq "yes" && $p) ||
		     ($defaultpasswd eq "no" && !$p));
    return "no";    # otherwise
}

# get default encryption method
sub encryption_default {
    local($m) = "";
    if ($verbose) {
	while (&encryption_check($m) == 0) {
            $m = &confirm_list("Default encryption method for passwords:", 1,
                              $encryption_methods[0], @@encryption_methods);
	}
    }
    return($m);
}

sub class_default {
    local($c) = $defaultclass;

    if ($verbose) {
	$c = &confirm_list("Default login class:", 0,
		$defaultclass, @@login_classes);
	$changes++ if $c ne $defaultclass;
    }
    return($c);
}

# Confirm that we have a valid encryption method
sub encryption_check {
    local($m) = $_[0];

    foreach $i (@@encryption_methods) {
        if ($m eq $i) { return 1; }
    }

    if ($m =~ /^blowfish,(\d+)$/) { return 1; }
    return 0;
}

# misc
sub check_root {
    die "You are not root!\n" if $<;
}

sub usage {
    warn <<USAGE;
usage: adduser
    [-batch username [group[,group]...] [fullname] [password]]
    [-check_only]
    [-config_create]
    [-dotdir dotdir]
    [-e|-encryption method]
    [-group login_group]
    [-class login_class]
    [-h|-help]
    [-home home]
    [-message message_file]
    [-noconfig]
    [-shell shell]
    [-s|-silent|-q|-quiet]
    [-uid_start uid_start]
    [-uid_end uid_end]
    [-unencrypted]
    [-v|-verbose]

home=$home shell=$defaultshell dotdir=$dotdir login_group=$defaultgroup
login_class=$defaultclass uid_start=$uid_start uid_end=$uid_end 
send_message=$send_message message_file=$message_file
USAGE
    exit 1;
}

# uniq(1)
sub uniq {
    local(@@list) = @@_;
    local($e, $last = "", @@array);

    foreach $e (sort @@list) {
	push(@@array, $e) unless $e eq $last;
	$last = $e;
    }
    return @@array;
}

# Generate an appropriate argument to encrypt()
# That may be a DES salt or a blowfish rotation count
sub salt {
    local($salt);		# initialization
    if ($encryptionmethod eq "auto") {
        $salt = "";
    } elsif ($encryptionmethod =~ /^blowfish/ ) {
        ($encryptionmethod, $salt) = split(/\,/, $encryptionmethod);
	$salt = 7 unless $salt;		# default rounds if unspecified
    } else {
        warn "$encryptionmethod encryption method invalid\n" if ($verbose > 0);
	warn "Falling back to blowfish,7...\n" if ($verbose > 0);
	$encryptionmethod = "blowfish";
	$salt = 7;
    }

    warn "Salt is: $salt\n" if $verbose > 1;

    return $salt;
}

# Encrypt a password using the selected method
sub encrypt {
    local($pass, $salt) = ($_[0], $_[1]);
    local(@@args, $crypt);

    if ($encryptionmethod eq "blowfish") {
        @@args = ("-b", $salt);
    } elsif ($encryptionmethod eq "auto") {
        @@args = ("-c", $log_cl);
    }

    open2(\*ENCRD, \*ENCWR, "/usr/bin/encrypt", @@args);
    print ENCWR "$pass\n";
    close ENCWR;
    $crypt = <ENCRD>;
    close ENCRD;
    chomp $crypt;
    die "encrypt failed" if (wait == -1 || $? != 0);
    return($crypt);
}

# hints
sub hints {
    if ($verbose) {
	print "Use option ``-silent'' if you don't want to see " .
	      "all warnings and questions.\n\n";
    }
}

#
sub parse_arguments {
    local(@@argv) = @@_;

    while ($_ = $argv[0], /^-/) {
	shift @@argv;
	last if /^--$/;
	if    (/^--?(v|verbose)$/)	{ $verbose = 1 }
	elsif (/^--?(s|silent|q|quiet)$/)  { $verbose = 0 }
	elsif (/^--?(debug)$/)	    { $verbose = 2 }
	elsif (/^--?(h|help|\?)$/)	{ &usage }
	elsif (/^--?(home)$/)	 { $home = $argv[0]; shift @@argv }
	elsif (/^--?(shell)$/)	 { $defaultshell = $argv[0]; shift @@argv }
	elsif (/^--?(class)$/)	 { $defaultclass = $argv[0]; shift @@argv }
	elsif (/^--?(dotdir)$/)	 { $dotdir = $argv[0]; shift @@argv }
	elsif (/^--?(uid_start)$/)	 { $uid_start = $argv[0]; shift @@argv }
	elsif (/^--?(uid_end)$/)	 { $uid_end = $argv[0]; shift @@argv }
	elsif (/^--?(group)$/)	 { $defaultgroup = $argv[0]; shift @@argv }
	elsif (/^--?(check_only)$/) { $check_only = 1 }
	elsif (/^--?(message)$/) {
	    $send_message = $argv[0]; shift @@argv;
	    $message_file = &choosetxt_yn_default($send_message, $message_file);
	}
	elsif (/^--?(unencrypted)$/)	{ $unencrypted = 1 }
	elsif (/^--?(batch)$/)	 {
	    @@batch = splice(@@argv, 0, 4); $verbose = 0;
	    die "batch: too few arguments\n" if $#batch < 0;
	}
	# see &config_read
	elsif (/^--?(config_create)$/)	{ &hints; &create_conf; exit(0); }
	elsif (/^--?(noconfig)$/)	{ $config_read = 0; }
	elsif (/^--?(e|encryption)$/) {
	    $encryptionmethod = $argv[0];
	    shift @@argv;
	}
	else			    { &usage }
    }
    #&usage if $#argv < 0;
}

sub basename {
    local($name) = @@_;
    $name =~ s|/+$||;
    $name =~ s|.*/+||;
    return $name;
}

sub dirname {
    local($name) = @@_;
    $name = &stripdir($name);
    $name =~ s|/+[^/]+$||;
    $name = "/" unless $name;	# dirname of / is /
    return $name;
}

# return 1 if $file is a readable file or link
sub filetest {
    local($file, $verbose) = @@_;

    if (-e $file) {
	if (-f $file || -l $file) {
	    return 1 if -r _;
	    warn "$file unreadable\n" if $verbose;
	} else {
	    warn "$file is not a plain file or link\n" if $verbose;
	}
    }
    return 0;
}

# create or recreate configuration file prompting for values
sub create_conf {
    $create_conf = 1;

    &shells_read;			# Pull in /etc/shells info
    &shells_add;			# maybe add some new shells
    $defaultshell = &shell_default;	# enter default shell
    &login_conf_read;			# read /etc/login.conf
    $defaultclass = &class_default;	# default login.conf class
    $home = &home_partition($home);	# find HOME partition
    $dotdir = &dotdir_default;		# check $dotdir
    $send_message = &message_default;   # send message to new user
    $defaultpasswd = &password_default; # maybe use password
    $defaultencryption = &encryption_default;	# Encryption method

    &config_write(1);
}

# log for new user in /var/log/adduser
sub adduser_log {
    local($string) = @@_;
    local($e);

    return 1 if $logfile eq "no";

    local($sec, $min, $hour, $mday, $mon, $year) = localtime;
    $year += 1900;
    $mon++;

    foreach $e ('sec', 'min', 'hour', 'mday', 'mon') {
	# '7' -> '07'
	eval "\$$e = 0 . \$$e" if (eval "\$$e" < 10);
    }

    &append_file($logfile, "$year/$mon/$mday $hour:$min:$sec $string");
}

# create HOME directory, copy dotfiles from $dotdir to $HOME
sub home_create {
    local($name, $group) = @@_;
    local($homedir) = "$home/$name";

    if (-e "$homedir") {
	warn "HOME Directory ``$homedir'' already exists\a\n";
	return 0;
    }

    if ($dotdir eq 'no') {
	if (!mkdir("$homedir", 0755)) {
	    warn "mkdir $homedir: $!\n"; return 0;
	}
	system 'chown', "$name:$group", $homedir;
	return !$?;
    }

    # copy files from  $dotdir to $homedir
    # rename 'dot.foo' files to '.foo'
    print "Copy files from $dotdir to $homedir\n" if $verbose;
    system("cp", "-R", $dotdir, $homedir);
    system("chmod", "-R", "u+wrX,go-w", $homedir);
    system("chown", "-R", "$name:$group", $homedir);

    # security
    opendir(D, $homedir);
    foreach $file (readdir(D)) {
	if ($file =~ /^dot\./ && -f "$homedir/$file") {
	    $file =~ s/^dot\././;
	    rename("$homedir/dot$file", "$homedir/$file");
	}
	chmod(0600, "$homedir/$file")
	    if ($file =~ /^\.(rhosts|Xauthority|kermrc|netrc)$/);
	chmod(0700, "$homedir/$file")
	    if ($file =~ /^(Mail|prv|\.(iscreen|term))$/);
    }
    closedir D;
    return 1;
}

# makes a directory hierarchy
sub mkdir_home {
    local($dir) = @@_;
    $dir = &stripdir($dir);
    local($user_partition) = "/usr";
    local($dirname) = &dirname($dir);


    -e $dirname || &mkdirhier($dirname);

    if (((stat($dirname))[0]) == ((stat("/"))[0])){
	# home partition is on root partition
	# create home partition on $user_partition and make
	# a symlink from $dir to $user_partition/`basename $dir`
	# For instance: /home -> /usr/home

	local($basename) = &basename($dir);
	local($d) = "$user_partition/$basename";


	if (-d $d) {
	    warn "Oops, $d already exists\n" if $verbose;
	} else {
	    print "Create $d\n" if $verbose;
	    if (!mkdir("$d", 0755)) {
		warn "$d: $!\a\n"; return 0;
	    }
	}

	unlink($dir);		# symlink to nonexist file
	print "Create symlink: $dir -> $d\n" if $verbose;
	if (!symlink("$d", $dir)) {
	    warn "Symlink $d: $!\a\n"; return 0;
	}
    } else {
	print "Create $dir\n" if $verbose;
	if (!mkdir("$dir", 0755)) {
	    warn "Directory ``$dir'': $!\a\n"; return 0;
	}
    }
    return 1;
}

sub mkdirhier {
    local($dir) = @@_;
    local($d,$p);

    $dir = &stripdir($dir);

    foreach $d (split('/', $dir)) {
	$dir = "$p/$d";
	$dir =~ s|^//|/|;
	if (! -e "$dir") {
	    print "Create $dir\n" if $verbose;
	    if (!mkdir("$dir", 0755)) {
		warn "$dir: $!\n"; return 0;
	    }
	}
	$p .= "/$d";
    }
    return 1;
}

# stript unused '/'
# e.g.: //usr///home// -> /usr/home
sub stripdir {
    local($dir) = @@_;

    $dir =~ s|/+|/|g;		# delete double '/'
    $dir =~ s|/$||;		# delete '/' at end
    return $dir if $dir ne "";
    return '/';
}

# Read one of the elements from @@list. $confirm is the default.
# If !$allow then accept only elements from @@list.
sub confirm_list {
    local($message, $allow, $confirm, @@list) = @@_;
    local($read, $c, $print);

    $print = "$message" if $message;
    $print .= " " unless $message =~ /\n$/ || $#list == 0;

    $print .= join($", &uniq(@@list)); #"
    $print .= " " unless $message =~ /\n$/ && $#list == 0;
    print "$print";
    print "\n" if (length($print) + length($confirm)) > 60;
    print "[$confirm]: ";

    chop($read = <STDIN>);
    $read =~ s/^\s*//;
    $read =~ s/\s*$//;
    return $confirm if $read eq "";
    return "$read" if $allow;

    foreach $c (@@list) {
	return $read if $c eq $read;
    }
    warn "$read: is not allowed!\a\n";
    return &confirm_list($message, $allow, $confirm, @@list);
}

# YES, NO, DEFAULT or userstring
# 1. return "" if "no" or no string is provided by the user.
# 2. return the $default parameter if "yes" or "default" provided.
# otherwise return user provided string.
sub confirm_yn_default {
    local($message, $confirm, $default) = @@_;

    print "$message [$confirm]: ";
    chop($read = <STDIN>);
    $read =~ s/^\s*//;
    $read =~ s/\s*$//;
    return "" unless $read;

    return choosetxt_yn_default($read, $default);
}

sub choosetxt_yn_default {
    local($read, $default) = @@_;

    if ($read =~ "$no") {
	return "";
    }
    if ($read eq "default") {
	return $default;
    }
    if ($read =~ "$yes") {
	if ($verbose == 1) {
	    return $read;
	}
	return $default;
    }
    return $read;
}

# YES or NO question
# return 1 if &confirm("message", "yes") and answer is yes
#	or if &confirm("message", "no") and answer is no
# otherwise return 0
sub confirm_yn {
    local($message, $confirm) = @@_;
    local($read, $c);

    if ($confirm && ($confirm =~ "$yes" || $confirm == 1)) {
	$confirm = "y";
    } else {
	$confirm = "n";
    }
    print "$message (y/n) [$confirm]: ";
    chop($read = <STDIN>);
    $read =~ s/^\s*//;
    $read =~ s/\s*$//;
    return 1 unless $read;

    if (($confirm eq "y" && $read =~ "$yes") ||
	($confirm eq "n" && $read =~ "$no")) {
	return 1;
    }

    if ($read !~ "$yes" && $read !~ "$no") {
	warn "Wrong value. Enter again!\a\n";
	return &confirm_yn($message, $confirm);
    }
    return 0;
}

# test if $dotdir exist
# return "no" if $dotdir not exist or dotfiles should not copied
sub dotdir_default {
    local($dir) = $dotdir;

    return &dotdir_default_valid($dir) unless $verbose;
    while($verbose) {
	$dir = &confirm_list("Copy dotfiles from:", 1,
	    $dir, ("no", $dotdir_bak, $dir));
	last if $dir eq &dotdir_default_valid($dir);
    }
    warn "Do not copy dotfiles.\n" if $verbose && $dir eq "no";

    $changes++ if $dir ne $dotdir;
    return $dir;
}

sub dotdir_default_valid {
    local($dir) = @@_;

    return $dir if (-e $dir && -r _ && (-d _ || -l $dir) && $dir =~ "^/");
    return $dir if $dir eq "no";
    warn "Dotdir ``$dir'' is not a directory\a\n";
    return "no";
}

# ask for messages to new users
sub message_default {
    local($tmp_message_file) = $message_file;

    while($verbose) {
	$send_message = "no";

	$message_file = &confirm_yn_default(
			    "Send welcome message?: /path/file default no",
				"no", $tmp_message_file);
	if ($message_file eq "") {
	    $message_file = $tmp_message_file;
	    last;
	}
	if ($message_file =~ $yes) {
	    $message_file = &confirm_yn_default(
		 	     "Really? Type the filepath, 'default' or 'no'",
			     "no", $tmp_message_file);
	    if ($message_file eq "") {
	        $message_file = $tmp_message_file;
	        last;
	    }
	}

	# try and create the message file
	if (&filetest($message_file, 0)) {
	    if (&confirm_yn("File ``$message_file'' exists. Overwrite?:",
			    "no")) {
	        print "Retry: choose a different location\n";
	        next;
	    }
	    if (&message_create($message_file)) {
		print "Message file ``$message_file'' overwritten\n"
		    if $verbose;
	    }
	} else {
	    if (&message_create($message_file)) {
		print "Message file ``$message_file'' created\n" if $verbose;
	    }
	}

	if (&filetest($message_file, 0)) {
	    $send_message = "yes";
	    last;
	}
	last if !&confirm_yn("Unable to create ``$message_file'', try again?",
			     "yes");
    }

    if ($send_message eq "no" || !&filetest($message_file, 0)) {
	warn "Do not send message(s)\n" if $verbose;
	$send_message = "no";
    } else {
	&message_read($message_file);
    }

    $changes++ if $tmp_message_file ne $message_file && $verbose;
    return $send_message;
}

# create message file
sub message_create {
    local($file) = @@_;

    rename($file, "$file.bak");
    if (!open(M, "> $file")) {
	warn "Messagefile ``$file'': $!\n"; return 0;
    }
    print M <<EOF;
#
# Message file for adduser(8)
#   comment: ``#''
#   default variables: \$name, \$fullname, \$password
#   other variables:  see /etc/adduser.conf after
#		     line  ``$do_not_delete''
#

\$fullname,

your account ``\$name'' was created.
Have fun!

See also chpass(1), finger(1), passwd(1)
EOF
    close M;
    return 1;
}

# read message file into buffer
sub message_read {
    local($file) = @@_;
    @@message_buffer = ();

    if (!open(R, "$file")) {
	warn "File ``$file'':$!\n"; return 0;
    }
    while(<R>) {
	push(@@message_buffer, $_) unless /^\s*#/;
    }
    close R;
}

# write @@list to $file with file-locking
sub append_file {
    local($file,@@list) = @@_;
    local($e);

    open(F, ">> $file") || die "$file: $!\n";
    print "Lock $file.\n" if $verbose > 1;
    while(!flock(F, LOCK_EX | LOCK_NB)) {
	warn "Cannot lock file: $file\a\n";
	die "Sorry, gave up\n"
	    unless &confirm_yn("Try again?", "yes");
    }
    print F join("\n", @@list) . "\n";
    print "Unlock $file.\n" if $verbose > 1;
    flock(F, LOCK_UN);
    close F;
}

# return free uid+gid
# uid == gid if possible
sub next_id {
    local($group) = @@_;

    $uid_start = 1000 if ($uid_start <= 0 || $uid_start >= $uid_end);
    # looking for next free uid
    while($uid{$uid_start}) {
	$uid_start++;
	$uid_start = 1000 if $uid_start >= $uid_end;
	print "$uid_start\n" if $verbose > 1;
    }

    local($gid_start) = $uid_start;
    # group for user (username==groupname) already exist
    if ($groupname{$group}) {
	$gid_start = $groupname{$group};
    }
    # gid is in use, looking for another gid.
    # Note: uid and gid are not equal
    elsif ($gid{$uid_start}) {
	while($gid{$gid_start} || $uid{$gid_start}) {
	    $gid_start--;
	    $gid_start = $uid_end if $gid_start < 100;
	}
    }
    return ($uid_start, $gid_start);
}

# read config file - typically /etc/adduser.conf
sub config_read {
    local($opt) = join " ", @@_;
    local($user_flag) = 0;

    # don't read config file
    return 1 if $opt =~ /-(noconfig|config_create)/ || !$config_read;

    if (!-f $config) {
        warn("Couldn't find $config: creating a new adduser configuration file\n");
        &create_conf;
    }

    if (!open(C, "$config")) {
	warn "$config: $!\n"; return 0;
    }

    while(<C>) {
	# user defined variables
	/^$do_not_delete/ && $user_flag++;
	# found @@array or $variable
	if (s/^(\w+\s*=\s*\()/\@@$1/ || s/^(\w+\s*=)/\$$1/) {
	    eval $_;
	    #warn "$_";
	}
	next if /^$/;
	# lines with '^##' are not saved
	push(@@user_variable_list, $_)
	    if $user_flag && !/^##/ && (s/^[\$\@@]// || /^[#\s]/);
    }
    #warn "X @@user_variable_list X\n";
    close C;
}


# write config file
sub config_write {
    local($silent) = @@_;

    # nothing to do
    return 1 unless ($changes || ! -e $config || !$config_read || $silent);

    if (!$silent) {
	if (-e $config) {
	    return 1 if &confirm_yn("\nWrite your changes to $config?", "no");
	} else {
	    return 1 unless
		&confirm_yn("\nWrite your configuration to $config?", "yes");
	}
    }

    rename($config, "$config.bak");
    open(C, "> $config") || die "$config: $!\n";

    # prepare some variables
    $send_message = "no" unless $send_message;
    $defaultpasswd = "no" unless $defaultpasswd;
    local($shpref) = "'" . join("', '", @@shellpref) . "'";
    local($shpath) = "'" . join("', '", @@path) . "'";
    local($user_var) = join('', @@user_variable_list);
    local($def_lc) = "'" . join("', '", @@login_classes) . "'";

    print C <<EOF;
#
# $config - automatic generated by adduser(8)
#
# Note: adduser reads *and* writes this file.
#	You may change values, but don't add new things before the
#	line ``$do_not_delete''
#	Also, unquoted strings may cause warnings
#

# verbose = [0-2]
verbose = $verbose

# Get new password for new users
# defaultpasswd =  yes | no
defaultpasswd = "$defaultpasswd"

# Default encryption method for user passwords
# Methods are all those listed in login.conf(5)
encryptionmethod = "$defaultencryption"

# copy dotfiles from this dir ("/etc/skel" or "no")
dotdir = "$dotdir"

# send message to user? ("yes" or "no")
send_message = "$send_message"

# send this file to new user ("/etc/adduser.message")
message_file = "$message_file"

# config file for adduser ("/etc/adduser.conf")
config = "$config"

# logfile ("/var/log/adduser" or "no")
logfile = "$logfile"

# default HOME directory ("/home")
home = "$home"

# List of directories where shells located
# path = ('/bin', '/usr/bin', '/usr/local/bin')
path = ($shpath)

# common shell list, first element has higher priority
# shellpref = ('bash', 'tcsh', 'ksh', 'csh', 'sh')
shellpref = ($shpref)

# defaultshell if not empty ("bash")
defaultshell = "$defaultshell"

# defaultgroup ('USER' for same as username or any other valid group)
defaultgroup = "$defaultgroup"

# new users get this uid
uid_start = $uid_start
uid_end = $uid_end

# default login.conf(5) login class
defaultclass = "$defaultclass"

# login classes available from login.conf(5)
# login_classes = ('default', 'daemon', 'staff')
login_classes = ($def_lc)

$do_not_delete
## your own variables, see /etc/adduser.message
EOF
    print C "$user_var\n" if ($user_var ne '');
    print C "\n## end\n";
    close C;
}

# check for sane variables
sub variable_check {
	# Check uid_start & uid_end
	warn "WARNING: uid_start < 1000!\n" if($uid_start < 1000);
	die "ERROR: uid_start >= uid_end!\n" if($uid_start >= $uid_end);
	# unencrypted really only usable in batch mode
	warn "WARNING: unencrypted only effective in batch mode\n"
	    if($#batch < 0 && $unencrypted);
}

sub cleanup {
    local($sig) = @@_;

    print STDERR "Caught signal SIG$sig -- cleaning up.\n";
    system("stty", "echo");
    exit(0);
}

END {
    if (-e $etc_ptmp && defined(fileno(PTMP))) {
	    close PTMP;
	    unlink($etc_ptmp) || warn "Error: unable to remove $etc_ptmp: $!\nPlease verify that $etc_ptmp no longer exists!\n";
    }
}
@


1.62
log
@remove all crypt choices other than bcrypt. ok afresh1 deraadt
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.61 2014/02/15 06:27:50 tedu Exp $
d320 1
a320 1
		$sh !~ /\/(pppd|sliplogin)$/);
@


1.61
log
@missed a typo
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.60 2014/02/15 06:25:18 tedu Exp $
d99 1
a99 1
    @@encryption_methods = ('auto', 'blowfish', 'md5', 'des', 'old');
d961 1
a961 12
    if ($encryptionmethod eq "des" || $encryptionmethod eq "old") {
        local($i, $rand);
        local(@@itoa64) = ( '0' .. '9', 'a' .. 'z', 'A' .. 'Z' ); # 0 .. 63

        warn "calculate salt\n" if $verbose > 1;

        for ($i = 0; $i < 8; $i++) {
	    srand(time + $rand + $$);
	    $rand = rand(25*29*17 + $rand);
	    $salt .=  $itoa64[$rand & $#itoa64];
        }
    } elsif ($encryptionmethod eq "md5" || $encryptionmethod eq "auto") {
d983 1
a983 5
    if ($encryptionmethod eq "des" || $encryptionmethod eq "old") {
        @@args = ("-s", $salt);
    } elsif ($encryptionmethod eq "md5") {
        @@args = ("-m");
    } elsif ($encryptionmethod eq "blowfish") {
@


1.60
log
@make a few comments easier to read
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.59 2014/02/14 19:08:03 tedu Exp $
d1308 1
a1308 1
#	or if &confirm("message", "no") an answer is no
@


1.59
log
@clarify no password only disables password logins. from david hill.
ok halex
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.58 2011/09/22 10:59:23 deraadt Exp $
d244 1
a244 1
# return default home partition (f.e. "/home")
d594 1
a594 1
# your last change
d1234 1
a1234 1
# F.i.: //usr///home// -> /usr/home
d1244 2
a1245 2
# Read one of the elements from @@list. $confirm is default.
# If !$allow accept only elements from @@list.
d1309 1
a1309 1
# otherwise 0
@


1.58
log
@purge the rcsid
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.57 2011/05/12 13:56:23 lum Exp $
d753 1
a753 1
	elsif (!&confirm_yn("Set the password so that user cannot logon?", "no")) {
@


1.57
log
@remove sneaky little ;
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.56 2011/05/12 10:38:27 lum Exp $
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.56 2011/05/12 10:38:27 lum Exp $';
a1575 1
# $rcsid
@


1.56
log
@Add quotations around the value of name=value pairs that are missing them.
This removes a couple of "use warnings;" error messages.
Whether ' or " is used should mean string is taken literally once parsed.
ok halex@@
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.55 2011/05/12 05:13:42 lum Exp $
d93 1
a93 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.55 2011/05/12 05:13:42 lum Exp $';
d1604 1
a1604 1
message_file = "$message_file";
@


1.55
log
@Preferably we would have "use warnings;" but never-the-less a small booboo
by me. Fortunatley no side-effects.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.54 2011/05/11 08:18:43 lum Exp $
d93 1
a93 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.54 2011/05/11 08:18:43 lum Exp $';
d1583 1
d1591 1
a1591 1
defaultpasswd = $defaultpasswd
d1627 1
a1627 1
defaultgroup = $defaultgroup
d1634 1
a1634 1
defaultclass = $defaultclass
@


1.54
log
@Tidy how adduser handles email messages.

Suggestion to use install routine (additional user code) as reference
for an answer of "yes" from krw@@ (and william@@),

Suggestion for regexs and "reads good" from simon@@
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.53 2007/01/03 15:26:04 simon Exp $
d93 1
a93 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.53 2007/01/03 15:26:04 simon Exp $';
d1397 1
a1397 1
		    if verbose;
d1401 1
a1401 1
		print "Message file ``$message_file'' created\n" if verbose;
@


1.53
log
@fix bug that sorted the groups and thus broke ottos group file:
 * stop sorting the group file
 * push the empty YP group to the end
 * leave other group entries where they are

input & ok ray@@, tested & ok otto@@
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.52 2006/12/30 09:34:00 ray Exp $
a36 1
$test = 0;			# test mode, only for development
d80 2
a81 2
    $send_message = "no"; # send message to new user
    $send_message_bak = '/etc/adduser.message';
d93 1
a93 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.52 2006/12/30 09:34:00 ray Exp $';
d126 1
a126 11
    # only for me (=Wolfram)
    if ($test) {
	$home = "/home/w/tmp/adduser/home";
	$etc_shells = "./shells";
	$etc_passwd = "./master.passwd";
	$group = "./group";
	@@pwd_mkdb = ("pwd_mkdb", "-p", "-d", ".");
	$config = "adduser.conf";
	$send_message = "./adduser.message";
	$logfile = "./log.adduser";
    }
d128 3
a130 1
    umask 022;			# don't give login group write access
d687 1
a687 6
    local($cc) =
	&confirm_list("Send message to ``$name'' and:",
		      1, "no", ("root", "second_mail_address",
		      "no carbon copy"));
    local($e);
    $cc = "" if $cc eq "no";
d690 3
a692 1
    message_read ($send_message);
d700 1
a700 1
    if (!&confirm_yn("Add anything to default message", "no")) {
d708 5
d714 1
a714 2
    &sendmessage("$name $cc", (@@message_buffer, @@message_buffer_append))
	if (&confirm_yn("Send message", "yes"));
d729 1
d836 1
d915 1
a915 1
    die "You are not root!\n" if $< && !$test;
d940 2
a941 2
login_class=$defaultclass message_file=$send_message uid_start=$uid_start
uid_end=$uid_end
d1042 4
a1045 2
	elsif (/^--?(message)$/) { $send_message = $argv[0]; shift @@argv;
				   $sendmessage = 1; }
a1107 5
    if ($send_message ne 'no') {
	&message_create($send_message);
    } else {
	&message_create($send_message_bak);
    }
d1273 34
a1312 2
    local($yes) = '^(yes|YES|y|Y)$';
    local($no) = '^(no|NO|n|N)$';
d1366 1
a1366 2
    local($file) = $send_message;
    local(@@d) = ($file, $send_message_bak, "no");
d1369 41
a1409 8
	$file = &confirm_list("Send message from file:", 1, $file, @@d);
	last if $file eq "no";
	last if &filetest($file, 1);

	# maybe create message file
	&message_create($file) if &confirm_yn("Create ``$file''?", "yes");
	last if &filetest($file, 0);
	last if !&confirm_yn("File ``$file'' does not exist, try again?",
d1413 3
a1415 3
    if ($file eq "no" || !&filetest($file, 0)) {
	warn "Do not send message\n" if $verbose;
	$file = "no";
d1417 1
a1417 1
	&message_read($file);
d1420 2
a1421 2
    $changes++ if $file ne $send_message && $verbose;
    return $file;
d1599 1
a1599 1
# send this file to new user ("/etc/adduser.message" or "no")
d1601 3
@


1.52
log
@s/form/from/

``Sure.'' millert@@, ``Sure'' espie@@.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.51 2006/06/07 16:02:19 deraadt Exp $
d94 1
a94 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.51 2006/06/07 16:02:19 deraadt Exp $';
d639 1
a639 1
    local($e, @@a);
d656 20
a675 2
	foreach $e (sort {$a <=> $b} (keys %gid)) {
	    push(@@a, "$gid{$e}:*:$e:$groupmembers{$e}");
@


1.51
log
@remove first person statement; stejones@@gmail.com
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.50 2005/08/31 17:28:15 kettenis Exp $
d94 1
a94 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.50 2005/08/31 17:28:15 kettenis Exp $';
d122 1
a122 1
    %gid = ();			# $gid{gid} = groupname;    gid form group db
@


1.50
log
@Use ksh as the default shell instead of sh.
ok deraadt@@
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.49 2005/03/30 22:12:38 millert Exp $
d94 1
a94 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.49 2005/03/30 22:12:38 millert Exp $';
d756 1
a756 1
	  "Don't worry about mistakes. I will give you the chance later to " .
@


1.49
log
@Use getcap to pull out login.conf entries that contain a localcipher
entry instead of giving the user a list of all possible login
classes.  This makes the default list "daemon default staff" instead
of listing all the stub classed only meant for inclusion into the
real classes.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.48 2005/02/24 16:45:02 millert Exp $
d94 1
a94 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.48 2005/02/24 16:45:02 millert Exp $';
d103 1
a103 1
    $defaultshell = 'sh';	# defaultshell if not empty
@


1.48
log
@Close files after we are done with them; from mpech@@
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.47 2003/06/17 00:58:30 jsyn Exp $
d94 1
a94 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.47 2003/06/17 00:58:30 jsyn Exp $';
d151 1
a151 7
     local($cont);

     print "Reading $etc_login_conf\n" if $verbose;
     open(S, $etc_login_conf) || die "$etc_login_conf: $!\n";

     $cont = 0;
     while(<S>) {
d153 3
a155 8
	s/^\s*//;
        next if m/^(#|$)/;
	if (!$cont && /^([^:]+):/) {
	    push(@@login_classes, split(/\|/, $1));
	}
	$cont = /\\$/;
    }
    close(S);
@


1.47
log
@make Groupname match Groupid output; ok millert@@
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.46 2003/06/14 23:23:08 millert Exp $
d94 1
a94 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.46 2003/06/14 23:23:08 millert Exp $';
d166 1
d189 1
@


1.46
log
@Add an "auto" encryption type that calls encrypt(1) with "-c class".
This results in encrypt(1) picking the password cipher based on the
user's login class in /etc/login.conf.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.45 2003/06/10 21:55:02 millert Exp $
d94 1
a94 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.45 2003/06/10 21:55:02 millert Exp $';
d358 1
a358 1
	warn "Groupname exists twice: $g_groupname:$g_gid ->  $g_groupname:$groupname{$g_groupname}\n"
@


1.45
log
@Add login class support; based on a diff from Peter Werner
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.44 2003/06/09 00:33:52 millert Exp $
d93 2
a94 2
    $encryptionmethod = "blowfish";
    $rcsid = '$OpenBSD: adduser.perl,v 1.44 2003/06/09 00:33:52 millert Exp $';
d101 1
a101 1
    @@encryption_methods = ('blowfish', 'md5', 'des', 'old');
a801 1
	    $log_cl = "" if ($log_cl eq "default");
d804 1
d970 1
a970 1
    } elsif ($encryptionmethod eq "md5") {
d974 1
a974 1
	if ($salt eq "") { $salt = 7; }	# default rounds inf unspecified
d990 1
a990 1
    local($args, $crypt);
d993 1
a993 1
        $args = "-s $salt";
d995 1
a995 1
        $args = "-m";
d997 3
a999 1
        $args = "-b $salt";
d1002 1
a1002 1
    open2(\*ENCRD, \*ENCWR, "/usr/bin/encrypt $args");
d1529 1
a1529 1
# Methods are all those listed in passwd.conf(5)
@


1.44
log
@Fix my previous commit here, pwd_mkdb needs to be a list now too.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.43 2003/06/08 21:05:29 millert Exp $
d59 1
d91 1
d94 1
a94 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.43 2003/06/08 21:05:29 millert Exp $';
d106 1
d145 1
d150 18
d264 1
a264 1
# create base directory if necessary 
d443 7
d485 2
a486 2
    # group(5): A group cannot have more than 200 members. 
    # The maximum line length of /etc/group is 1024 characters. 
d488 1
a488 1
    if ($#l >= 200 || 
d618 9
a626 8
Name:	  $name
Password: ****
Fullname: $fullname
Uid:	  $u_id
Gid:	  $g_id ($group_login)
Groups:	  $group_login $new_groups
HOME:	  $home/$name
Shell:	  $sh
d689 1
a689 1
		      1, "no", ("root", "second_mail_address", 
d775 3
a777 1
    local($name, $group_login, $fullname, $sh, $u_id, $g_id, $new_groups);
d795 1
d802 1
d808 1
a808 1
		"\:$u_id\:$g_id\::0:0:$fullname:$home/$name:$sh";
d844 1
d853 1
a853 1
	"\:$u_id\:$g_id\::0:0:$fullname:$home/$name:$sh";
d887 11
d905 1
a905 1
    
d924 1
d937 2
a938 1
message_file=$send_message uid_start=$uid_start uid_end=$uid_end
d966 1
a966 1
	    srand(time + $rand + $$); 
d981 1
a981 1
        
d1031 1
d1093 2
d1507 1
d1526 1
a1526 1
# Default encryption method for user passwords 
d1562 7
@


1.43
log
@Instead of splitting a flat string into a list for system(), just
pass it a list in the first place.  Also fix up some spacing.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.42 2003/05/13 01:23:10 millert Exp $
d90 1
a90 1
    $pwd_mkdb = "pwd_mkdb -p";	# program for building passwd database
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.42 2003/05/13 01:23:10 millert Exp $';
d130 1
a130 1
	$pwd_mkdb = "pwd_mkdb -p -d .";
d288 1
a288 1
    system($pwd_mkdb, "-c", $etc_passwd);
d608 1
a608 1
    system($pwd_mkdb, "-u", $user, $etc_passwd);
d611 1
a611 1
	warn "``$pwd_mkdb'' failed\n";
@


1.42
log
@Sync valid username check w/ user(1).  Patch from Brian Poole,
problem reported by juncus on misc
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.41 2003/04/03 18:55:33 jmc Exp $
d50 1
a50 1
if (!$check_only &&  $#batch < 0) {
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.41 2003/04/03 18:55:33 jmc Exp $';
d288 1
a288 1
    system(split(/\s+/, "$pwd_mkdb -c $etc_passwd"));
d608 1
a608 1
    system(split(/\s+/, "$pwd_mkdb  -u $user $etc_passwd"));
d1088 1
a1088 1
	if (!mkdir("$homedir",0755)) {
@


1.41
log
@skiped -> skipped;

from David Hill (thanks)
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.40 2003/03/11 04:45:54 david Exp $
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.40 2003/03/11 04:45:54 david Exp $';
d368 1
a368 1
	$name = &confirm_list("Enter username", 1, "a-z0-9_-", "");
d381 1
a381 1
    if ($name !~ /^[a-z0-9_][a-z0-9_\-]*$/ || $name eq "a-z0-9_-") {
d383 1
a383 1
	    "Please use only lowercase characters or digits\a\n";
@


1.40
log
@spelling
ok millert@@
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.39 2002/07/10 19:57:31 millert Exp $
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.39 2002/07/10 19:57:31 millert Exp $';
d458 1
a458 1
    # Longer lines will be skiped.
@


1.39
log
@Fix encryption method prompt; Nick Nauwelaerts
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.38 2002/06/14 21:35:01 todd Exp $
d74 1
a74 1
# Adduser.conf supercedes these
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.38 2002/06/14 21:35:01 todd Exp $';
@


1.38
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.37 2002/03/05 17:23:45 millert Exp $
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.37 2002/03/05 17:23:45 millert Exp $';
d845 1
a845 1
            $m = &confirm_list("Default encryption method for passwords", 1,
@


1.37
log
@Don't delete ptmp if we didn't create it ourselves; Brian Poole
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.36 2002/02/23 18:54:55 espie Exp $
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.36 2002/02/23 18:54:55 espie Exp $';
d242 1
a242 1
# create base directory if nesseccary
@


1.36
log
@check that user is not in group more thoroughly (don't assume anything
about group contents).

ok millert@@
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.35 2002/02/18 21:40:08 ericj Exp $
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.35 2002/02/18 21:40:08 ericj Exp $';
d1538 1
a1538 1
    if (-e $etc_ptmp && defined PTMP) {
@


1.35
log
@
enable echo in signal handler, since it could be disabled
pr#1939
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.34 2001/10/09 18:25:31 millert Exp $
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.34 2001/10/09 18:25:31 millert Exp $';
d449 1
a449 1
	$groupmembers{$gid} =~ /^(.+,)?$name(,.+)?$/;
@


1.34
log
@Don't try to use $groupname{$group_login} when we know it is
undefined.  This caused adduser to not add a new login group when
there was an entry like ":*::" in /etc/group due to a false positive
on a broken sanity check.  Since we *know* the gid of the new user's
login group just use that.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.33 2001/10/01 15:26:33 millert Exp $
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.33 2001/10/01 15:26:33 millert Exp $';
d1533 1
@


1.33
log
@Do proper initialization of hashes and lists.  Use "cp -R" not "cp -r"
since the latter form is discouraged.  From raj@@cerias.purdue.edu
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.32 2001/09/07 20:34:11 millert Exp $
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.32 2001/09/07 20:34:11 millert Exp $';
d621 1
a621 2
    if (!defined($groupname{$group_login}) &&
	!defined($gid{$groupname{$group_login}})) {
@


1.32
log
@Cleanup from Brian Poole:
o remove useless copyright() sub since it does nothing
o remov unused variables
o clear hashes properly
o grammar/spelling fixes
o pass perl -w
o unlock the ptmp file before we close it, not after
o parse args in config_read() correctly
o man page cleanup
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.31 2001/09/03 16:19:32 millert Exp $
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.31 2001/09/03 16:19:32 millert Exp $';
d119 1
a119 1
    %gid = '';			# $gid{gid} = groupname;    gid form group db
d122 1
a122 1
    %shell = '';		# $shell{`basename sh`} = sh
d139 4
a142 4
    @@passwd_backup = '';
    @@group_backup = '';
    @@message_buffer = '';
    @@user_variable_list = '';	# user variables in /etc/adduser.conf
d1099 1
a1099 1
    system("cp", "-r", $dotdir, $homedir);
@


1.31
log
@correct error message when unable to open /etc/master.passwd; raj@@cerias.purdue.edu
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.30 2001/07/06 15:39:36 mpech Exp $
d51 1
a51 1
    &copyright; &hints;
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.30 2001/07/06 15:39:36 mpech Exp $';
d110 3
a112 3
    $username = '';		# $username{username} = uid
    $uid = '';			# $uid{uid} = username
    $pwgid = '';		# $pwgid{pwgid} = username; gid from passwd db
d117 3
a119 3
    $groupname ='';		# $groupname{groupname} = gid
    $groupmembers = '';		# $groupmembers{gid} = members of group/kommalist
    $gid = '';			# $gid{gid} = groupname;    gid form group db
d122 1
a122 1
    $shell = '';		# $shell{`basename sh`} = sh
d152 1
a152 1
    open(S, $etc_shells) || die "$etc_shells:$!\n";
d265 1
a265 1
    return $h if $h =~ "^/" && -e $h && -w $h && (-d $h || -l $h);
d294 1
a294 1
    local($p_username, $pw, $p_uid, $p_gid, $sh, %shlist);
d382 1
a382 1
	warn "Wrong username. " .
d461 2
a462 2
	warn "WARNING, maybe group line ``$gid{$gid}'' is to long or to\n" .
	    "much users in group, see group(5)\a\n";
d899 1
a899 1
    local($e, $last, @@array);
a943 1
    local($goodpass);
a962 5
# print banner
sub copyright {
    return;
}

d997 1
a997 1
	elsif (/^--?(config_create)$/)	{ &copyright; &hints; &create_conf; exit(0); }
d1025 1
a1025 1
    local($file, $verb) = @@_;
d1359 1
a1359 1
	die "Sorry, give up\n"
a1362 1
    close F;
d1365 1
d1387 1
a1387 1
    # Note: uid an gid are not equal
d1399 1
a1399 1
    local($opt) = @@_;
a1521 2
	local($abort) = 0;

d1538 2
a1539 1
    if (-e $etc_ptmp) {
@


1.30
log
@max uid should be 2147483647, not 2147483648.

problem report from: Chris Cameron <chris@@UpNIX.com>

millert@@ ok
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.29 2001/04/09 18:31:36 deraadt Exp $
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.29 2001/04/09 18:31:36 deraadt Exp $';
d297 1
a297 1
    open(P, "$etc_passwd") || die "$passwd: $!\n";
@


1.29
log
@31 vs 32; ianm@@cit.uws.edu.au
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.28 2001/01/31 21:12:58 chris Exp $
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.28 2001/01/31 21:12:58 chris Exp $';
d106 1
a106 1
    $uid_end   = 2147483648;	# max. uid
@


1.28
log
@32 character user names
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.27 2000/12/30 06:43:24 angelos Exp $
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.27 2000/12/30 06:43:24 angelos Exp $';
d369 2
a370 2
	if (length($name) > 32) {
	    warn "Username is longer than 32 characters\a\n";
@


1.27
log
@Change wording when empty password is entered: our adduser sets the
password to "*" (thus disallowing logon) -- PR 1480
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.26 2000/11/26 02:18:06 millert Exp $
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.26 2000/11/26 02:18:06 millert Exp $';
d369 2
a370 2
	if (length($name) > 8) {
	    warn "Username is longer than 8 chars\a\n";
@


1.26
log
@Use pwd_mkdb -u username
Call system() with a list to avoid a call to sh
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.25 2000/11/25 23:22:33 millert Exp $
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.25 2000/11/25 23:22:33 millert Exp $';
d723 1
a723 1
	elsif (!&confirm_yn("Use an empty password?", "no")) {
@


1.25
log
@Fix some warnings and take advantage of perl5 system defines

In adduser, use /etc/ptmp as a lock file like the other passwd programs.
Currently it is just kept empty which is not so great.

Use sysopen() with explicit file modes so there is no race whereby
a user could see the contents on the master.passwd temp file in rmuser.
Fix order of file opens in rmuser so we don't try and remove anything
unless we can lock all our files.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.24 2000/10/10 16:04:15 millert Exp $
d92 1
a92 1
    $rcsid = '$OpenBSD: adduser.perl,v 1.24 2000/10/10 16:04:15 millert Exp $';
d288 1
a288 1
    system("$pwd_mkdb -c $etc_passwd");
d605 1
d607 2
a608 1
    system("$pwd_mkdb $etc_passwd");
d711 1
a711 1
	system("stty -echo");
d713 1
a713 1
	system("stty echo");
d716 1
a716 1
	    system("stty -echo");
d718 1
a718 1
	    system("stty echo");
d1105 3
a1107 3
    system("cp -r $dotdir $homedir");
    system("chmod -R u+wrX,go-w $homedir");
    system("chown -R $name:$group $homedir");
@


1.24
log
@Remove useless line; mj@@who.net
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.23 2000/08/19 07:50:19 jakob Exp $
d32 1
d40 5
d88 1
d92 1
d299 4
d912 1
a912 1
        local(@@itoa64) = ( 0 .. 9, a .. z, A .. Z ); # 0 .. 63
a1357 3
    local($LOCK_EX) = 2;
    local($LOCK_NB) = 4;
    local($LOCK_UN) = 8;
d1361 1
a1361 1
    while(!flock(F, $LOCK_EX | $LOCK_NB)) {
d1369 1
a1369 1
    flock(F, $LOCK_UN);
d1464 1
a1464 1
# $OpenBSD: adduser.perl,v 1.23 2000/08/19 07:50:19 jakob Exp $
d1467 1
a1467 1
# Note: adduser read *and* write this file.
d1536 12
@


1.23
log
@valid characters mismatch, PR#1362; Marty Combs
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.22 2000/07/09 16:11:34 aaron Exp $
a736 1
    $new_groups = "no";
d1455 1
a1455 1
# $OpenBSD: adduser.perl,v 1.22 2000/07/09 16:11:34 aaron Exp $
@


1.22
log
@When a null password has been entered, default to ``no'' instead of ``yes''
for the confirmation.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.21 2000/04/25 21:08:41 jakob Exp $
d356 1
a356 1
	$name = &confirm_list("Enter username", 1, "a-z0-9_", "");
d1456 1
a1456 1
# $OpenBSD: adduser.perl,v 1.21 2000/04/25 21:08:41 jakob Exp $
@


1.21
log
@change /usr/share/skel to /etc/skel. maintain dot.magic for backwards compability.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.20 2000/01/03 19:30:00 millert Exp $
d709 1
a709 1
	elsif (&confirm_yn("Use an empty password?", "yes")) {
d1456 1
a1456 1
# $OpenBSD: adduser.perl,v 1.20 2000/01/03 19:30:00 millert Exp $
@


1.20
log
@Y2K bug in logging function, tm_year is year - 1900, not the last two digits
of year.  Two digit years are just a bad idea anyway so convert to
a four digit year in the logfile.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.19 1999/09/06 16:48:41 alex Exp $
d72 1
a72 1
    $dotdir = "/usr/share/skel"; # copy dotfiles from this dir
d1456 1
a1456 1
# $OpenBSD: adduser.perl,v 1.19 1999/09/06 16:48:41 alex Exp $
d1475 1
a1475 1
# copy dotfiles from this dir ("/usr/share/skel" or "no")
@


1.19
log
@Send password to encrypt(1) via stdin.  millert@@ ok
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.18 1999/07/03 23:56:18 hugh Exp $
d1060 1
d1063 1
a1063 1
    foreach $e ('sec', 'min', 'hour', 'mday', 'mon', 'year') {
d1456 1
a1456 1
# $OpenBSD: adduser.perl,v 1.18 1999/07/03 23:56:18 hugh Exp $
@


1.18
log
@typos
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.17 1999/06/29 12:23:26 aaron Exp $
d31 2
d941 7
a947 4
    $pass =~ s/(.)/\\$1/g;

    $crypt = `/usr/bin/encrypt $args -- $pass`;
    chop $crypt;
d1455 1
a1455 1
# $OpenBSD: adduser.perl,v 1.17 1999/06/29 12:23:26 aaron Exp $
@


1.17
log
@grammar; form@@kti.nsc.ru
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.16 1999/06/17 20:06:28 espie Exp $
d1071 1
a1071 1
	warn "HOME Directory ``$homedir'' already exist\a\n";
d1127 1
a1127 1
	    warn "Oops, $d already exist\n" if $verbose;
d1450 1
a1450 1
# $OpenBSD: adduser.perl,v 1.16 1999/06/17 20:06:28 espie Exp $
@


1.16
log
@typo
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.15 1999/02/04 19:38:39 provos Exp $
d954 2
a955 2
	print "Use option ``-silent'' if you don't want see " .
	      "all warnings & questions.\n\n";
d1450 1
a1450 1
# $OpenBSD: adduser.perl,v 1.15 1999/02/04 19:38:39 provos Exp $
@


1.15
log
@allow higher uids.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.14 1999/01/18 03:05:48 millert Exp $
d1450 1
a1450 1
# $OpenBSD: adduser.perl,v 1.14 1999/01/18 03:05:48 millert Exp $
d1454 1
a1454 1
#	You may change values, but don't add new things befor the
@


1.14
log
@add 'old' as a synonym for 'des'
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.13 1999/01/16 03:13:01 weingart Exp $
d96 1
a96 1
    $uid_end   = 32000;		# max. uid
d1450 1
a1450 1
# $OpenBSD: adduser.perl,v 1.13 1999/01/16 03:13:01 weingart Exp $
@


1.13
log
@Fix PR# 692.  evanc@@concer.to
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.12 1998/12/29 12:04:37 deraadt Exp $
d89 1
a89 1
    @@encryption_methods = ('blowfish', 'md5', 'des');
d840 1
a840 1
    local ($m) = $_[0];
d897 1
a897 1
    if ($encryptionmethod eq "des") {
d928 2
a929 2
    local $args, $crypt;
    local $goodpass;
d931 1
a931 1
    if ($encryptionmethod eq "des") {
d1450 1
a1450 1
# $OpenBSD: adduser.perl,v 1.12 1998/12/29 12:04:37 deraadt Exp $
@


1.12
log
@do batch in encrypted mode by default; ibo@@val-axs.net
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.11 1998/10/14 19:40:27 deraadt Exp $
d159 1
a159 1
    $shell{"nologin"} = "/bin/nologin";
d1450 1
a1450 1
# $OpenBSD: adduser.perl,v 1.11 1998/10/14 19:40:27 deraadt Exp $
@


1.11
log
@solve < > or - in password problem
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.10 1998/09/22 01:40:30 weingart Exp $
d798 4
a801 1
    $cryptpwd = encrypt($password, &salt) if $password ne "";
d872 1
d979 1
d1450 1
a1450 1
# $OpenBSD: adduser.perl,v 1.10 1998/09/22 01:40:30 weingart Exp $
d1517 3
@


1.10
log
@Add support for having UIDs past 32000.  Changed the option -uid to
-uid_start, and added -uid_end to specify valid ranges to adduser.
Manpage updated to relfect reality, plus a couple spelling errors.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.9 1998/07/20 07:20:58 deraadt Exp $
d937 1
a937 1
    $crypt = `/usr/bin/encrypt $args $pass`;
d1445 1
a1445 1
# $OpenBSD: adduser.perl,v 1.9 1998/07/20 07:20:58 deraadt Exp $
@


1.9
log
@clone freebsd semantics for usernames; noted by abyss@@abyss.imaji.net
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.8 1998/06/03 05:36:57 deraadt Exp $
d48 1
d867 2
a868 1
    [-uid uid_start]
d872 1
a872 1
message_file=$send_message uid_start=$uid_start
a951 3
    } else {
	print "Use option ``-verbose'' if you want see more warnings & " .
	      "questions \nor try to repair bugs.\n\n";
d969 2
a970 1
	elsif (/^--?(uid)$/)	 { $uid_start = $argv[0]; shift @@argv }
d1445 1
a1445 1
# $OpenBSD: adduser.perl,v 1.8 1998/06/03 05:36:57 deraadt Exp $
d1495 1
d1503 9
@


1.8
log
@teach adduser about /sbin/nologin
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.7 1998/02/16 16:44:24 bitblt Exp $
d353 1
a353 1
	$name = &confirm_list("Enter username", 1, "A-Za-z0-9_", "");
d366 1
a366 1
    if ($name !~ /^[a-z0-9]+$/) {
d1445 1
a1445 1
# $OpenBSD: adduser.perl,v 1.7 1998/02/16 16:44:24 bitblt Exp $
@


1.7
log
@Fix for the remainder of PR 402
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.6 1998/02/16 16:04:41 bitblt Exp $
d156 3
a158 8
# Allow /nonexistent and /bin/date as a valid shell for system utils
    push(@@list, "/nonexistent");
    &shell_pref_add("no");
    $shell{"no"} = "/nonexistent";

    push(@@list, "/bin/date");
    &shell_pref_add("date");
    $shell{"date"} = "/bin/date";
d1445 1
a1445 1
# $OpenBSD: adduser.perl,v 1.6 1998/02/16 16:04:41 bitblt Exp $
@


1.6
log
@Shell metacharacters are now ok in user passwords, as per the first half
of PR 402
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.5 1997/05/29 04:26:56 gene Exp $
d648 2
a649 1
		      1, "no", ("root", "second_mail_address", "no"));
d653 3
a768 1
	    &new_users_sendmessage;
d771 1
d1326 1
a1326 1
    @@message_buffer = '';
d1450 1
a1450 1
# $OpenBSD: adduser.perl,v 1.5 1997/05/29 04:26:56 gene Exp $
@


1.5
log
@Major cleanup:
+ No longer prompt for setting of default options _every_ time it's invoked.
Only does that when adduser.conf doesn't exist or with the passing of
-config_create
+ Scriptwork cleanup and prettying
+ Fix the manpage to use proper English and give examples and better docs in
general.
+ Improve the bonehead question "Use passwords" to seem more intuitively
meaningful.
+ Add support for multiple kinds of encryption with a default entry or a new
-e flag (passwd.conf).  TODO: Make adduser grok passwd.conf and add users
for whom the encryption is different to it.
+ "and more..." see the manpage.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.4 1997/02/25 00:01:52 downsj Exp $
d924 1
d934 3
a936 1
    $crypt = `encrypt $args $pass`;
d1446 1
a1446 1
# $OpenBSD$
@


1.4
log
@Yet more fixes from tv@@pobox.com, PR#122.
@
text
@d3 1
a3 1
#	$OpenBSD$
d31 10
d42 24
a65 1
# read variables
d81 1
a81 1

d88 2
d140 1
a140 1
    print "Check $etc_shells\n" if $verbose;
d755 3
a757 2
	    $cryptpwd = "";
	    $cryptpwd = crypt($password, &salt) if $password ne "";
d797 2
a798 2
    $cryptpwd = "";
    $cryptpwd = crypt($password, &salt) if $password ne "";
d815 1
a815 1
	$p = &confirm_yn("Use passwords", $defaultpasswd);
d823 24
d859 1
d866 1
a866 1
    [-s|-silent|-q|-quit]
d888 2
a889 1
# see /usr/src/usr.bin/passwd/local_passwd.c or librcypt, crypt(3)
d892 21
a912 9
    local($i, $rand);
    local(@@itoa64) = ( 0 .. 9, a .. z, A .. Z ); # 0 .. 63

    warn "calculate salt\n" if $verbose > 1;
    # to64
    for ($i = 0; $i < 8; $i++) {
	srand(time + $rand + $$); 
	$rand = rand(25*29*17 + $rand);
	$salt .=  $itoa64[$rand & $#itoa64];
d914 1
d920 17
d962 1
a962 1
	elsif (/^--?(s|silent|q|quit)$/)  { $verbose = 0 }
d978 1
a978 1
	elsif (/^--?(config_create)$/)	{ &create_conf; }
d980 4
d1019 1
a1019 1
# create configuration files and exit
d1022 10
a1037 1
    exit(0);
d1380 1
a1380 1
# read config file
d1388 6
a1393 1
    if(!open(C, "$config")) {
d1443 1
d1454 1
a1454 1
# use password for new users
d1458 4
a1501 40
################
# main
#
$test = 0;	      # test mode, only for development
$check_only = 0;

&check_root;	    # you must be root to run this script!
&variables;	     # initialize variables
&config_read(@@ARGV);	# read variables form config-file
&parse_arguments(@@ARGV);    # parse arguments

if (!$check_only &&  $#batch < 0) {
    &copyright; &hints;
}

# check
$changes = 0;
&passwd_check;			# check for valid passwdb
&shells_read;			# read /etc/shells
&passwd_read;			# read /etc/master.passwd
&group_read;			# read /etc/group
&group_check;			# check for incon*
exit 0 if $check_only;		# only check consistence and exit

exit(!&batch(@@batch)) if $#batch >= 0; # batch mode

# interactive
# some questions
&shells_add;			# maybe add some new shells
$defaultshell = &shell_default;	# enter default shell
$home = &home_partition($home);	# find HOME partition
$dotdir = &dotdir_default;	# check $dotdir
$send_message = &message_default;   # send message to new user
$defaultpasswd = &password_default; # maybe use password
&config_write(!$verbose);	# write variables in file

# main loop for creating new users
&new_users;	     # add new users

#end
@


1.3
log
@Don't add shells multiple times, from tv@@pobox.com.  PR# user/112.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.2 1996/12/08 13:57:07 downsj Exp $
d1295 1
d1373 1
a1373 1
# defaultgroup ('USER' for same as username or any other valid group
d1376 2
a1377 2
# new users get this uid (1000)
uid_start = 1000
a1380 3
$user_var

## end
d1382 2
@


1.2
log
@sync with FreeBSD, except for the damned tcl script.
@
text
@d3 1
a3 1
#	$OpenBSD: adduser.perl,v 1.1 1996/09/28 05:58:35 downsj Exp $
d123 1
a123 1
    push(@@shellpref, "no");
d127 1
a127 1
    push(@@shellpref, "date");
d148 1
a148 1
			push(@@shellpref, "$sh");
d157 11
@


1.1
log
@Perl adduser(8) from FreeBSD.

TODO: Hack to accept the same arguments as BSD/OS adduser(8).  Add rmuser(8).
@
text
@d3 1
a3 1
#	$OpenBSD$
d29 1
a29 1
# $From: adduser.perl,v 1.19 1996/09/17 19:34:56 wosch Exp $
d260 1
a260 1
		$p_username !~ /^(bin|uucp|falcon|nobody)$/ &&
d312 1
a312 1
	$name = &confirm_list("Enter username", 1, "a-z0-9", "");
d1191 2
a1192 2
your account ``\$name'' was created. Your password is ``\$password''.
Please expire your password. Have fun!
@
