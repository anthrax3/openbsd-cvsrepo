head	1.38;
access;
symbols
	OPENBSD_6_2:1.38.0.6
	OPENBSD_6_2_BASE:1.38
	OPENBSD_6_1:1.38.0.8
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.35.0.6
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.6
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.2
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.32.0.6
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.4
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.2
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.8
	OPENBSD_5_0:1.31.0.6
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.4
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.27.0.12
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.8
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.6
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.4
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.26.0.12
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.10
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.8
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.6
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.4
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25;
locks; strict;
comment	@ * @;


1.38
date	2015.11.15.07.12.50;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	4HPhRfZSouX7aErg;

1.37
date	2015.11.11.08.01.22;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	jcdXbEqB7DgrffES;

1.36
date	2015.10.15.16.10.57;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	lVA2xZokKTr5Askd;

1.35
date	2015.01.16.06.39.33;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	Uu5nFG3wCl0LACBb;

1.34
date	2013.11.27.20.25.47;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2013.11.26.21.13.04;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.28.18.15.49;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.14.00.47.30;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2010.01.13.10.58.38;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.27.23.59.23;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.08.02.03.23.37;	author david;	state Exp;
branches;
next	1.26;

1.26
date	2004.07.02.12.59.44;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.05.03.39.51;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.05.03.17.47;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.04.23.50.35;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.04.03.49.53;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.04.03.37.01;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.04.03.26.59;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.04.00.26.12;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.04.00.24.16;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.04.00.18.39;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.03.23.41.56;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.19.32.31;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.28.22.14.49;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.28.20.05.41;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.28.19.25.18;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.28.19.11.34;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.28.17.44.06;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.28.16.42.50;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.28.16.41.24;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.28.01.09.11;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.28.00.04.20;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.27.23.47.36;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.06.00.23.03;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.25.21.55.11;	author tdeval;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.17.22.54.26;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2003.04.17.22.53.12;	author millert;	state Exp;
branches;
next	;


desc
@@


1.38
log
@KNF, de-register, fix other minor grumbles
@
text
@/*	$OpenBSD: more.c,v 1.37 2015/11/11 08:01:22 deraadt Exp $	*/

/*
 * Copyright (c) 2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */
/*-
 * Copyright (c) 1980 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * more.c - General purpose tty output filter and file perusal program
 *
 *	by Eric Shienbrood, UC Berkeley
 *
 *	modified by Geoff Peck, UCB to add underlining, single spacing
 *	modified by John Foderaro, UCB to add -c and MORE environment variable
 */

/*
 * TODO (millert)
 *  o POSIX compliance
 */

#include <sys/types.h>
#include <sys/exec.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/wait.h>

#include <ctype.h>
#include <curses.h>
#include <errno.h>
#include <locale.h>
#include <regex.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include <limits.h>
#include <paths.h>

#define Fopen(s, m)	(Currline = 0, file_pos = 0, fopen(s,m))
#define Ftell(f)	(file_pos)
#define Fseek(f, off)	(file_pos = off, fseeko(f, off, SEEK_SET))
#define Getc(f)		(++file_pos, getc(f))
#define Ungetc(c, f)	(--file_pos, ungetc(c, f))

#define	cleareol()	(tputs(eraseln, 1, putch))
#define	clreos()	(tputs(EodClr, 1, putch))
#define	home()		(tputs(Home, 1, putch))

#define TBUFSIZ		1024
#define LINSIZ		256
#define ctrl(letter)	(letter & 077)
#define RUBOUT		'\177'
#define ESC		'\033'
#define QUIT		'\034'

#define	DUM_PROMPT	"[Press space to continue, 'q' to quit.]"
#define	DUM_ERROR	"[Press 'h' for instructions.]"
#define	QUIT_IT		"[Use q or Q to quit]"

#include "morehelp.h"

struct termios	otty, ntty;
off_t		file_pos, file_size;
int		fnum, no_intty, no_tty, slow_tty;
int		dum_opt, dlines;
int		nscroll = 11;	/* Number of lines scrolled by 'd' */
int		fold_opt = 1;	/* Fold long lines */
int		stop_opt = 1;	/* Stop after form feeds */
int		ssp_opt = 0;	/* Suppress white space */
int		ul_opt = 1;	/* Underline as best we can */
int		promptlen;
off_t		Currline;	/* Line we are currently at */
int		startup = 1;
int		firstf = 1;
int		notell = 1;
int		docrterase = 0;
int		docrtkill = 0;
int		bad_so;	/* True if overwriting does not turn off standout */
int		inwait, Pause, errors;
int		within;		/* true if we are within a file,
				   false if we are between files */
int		hard, dumb, noscroll, hardtabs, clreol, eatnl;
int		catch_susp;	/* We should catch the SIGTSTP signal */
char		**fnames;	/* The list of file names */
int		nfiles;		/* Number of files left to process */
char		*shell;		/* The name of the shell to use */
int		shellp;		/* A previous shell command exists */
char		Lineb[LINSIZ];	/* Line buffer */
char		*Line = Lineb;	/* Line pointer */
int		Lpp = 24;	/* lines per page */
char		*Clear;		/* clear screen */
char		*eraseln;	/* erase line */
char		*Senter, *Sexit;/* enter and exit standout mode */
char		*ULenter, *ULexit; /* enter and exit underline mode */
char		*chUL;		/* underline character */
char		*chBS;		/* backspace character */
char		*Home;		/* go to home */
char		*cursorm;	/* cursor movement */
char		cursorhome[40];	/* contains cursor movement to home */
char		*EodClr;	/* clear rest of screen */
int		Mcol = 80;	/* number of columns */
int		Wrap = 1;	/* set if automargins */
int		soglitch;	/* terminal has standout mode glitch */
int		ulglitch;	/* terminal has underline mode glitch */
int		pstate = 0;	/* current UL state */
int		altscr = 0;	/* terminal supports an alternate screen */
size_t		linsize = LINSIZ;

volatile sig_atomic_t signo[_NSIG];	/* signals received */

struct {
	off_t chrctr, line;
} context, screen_start;

extern char	PC;		/* pad character (termcap) */
extern char	*__progname;	/* program name (crt0) */

int   colon(char *, int, int);
int   command(char *, FILE *);
int   expand(char *, size_t, char *);
int   get_line(FILE *, int *);
int   magic(FILE *, char *);
int   number(char *);
int   readch(void);
int   search(char *, FILE *, int);
int   ttyin(char *, int, char);
void  argscan(char *);
void  copy_file(FILE *);
void  doclear(void);
void  end_it(void);
void  erasep(int);
void  error(char *);
void  execute(char *filename, char *cmd, char *, char *, char *);
void  initterm(void);
void  kill_line(void);
void  onsignal(int);
void  prbuf(char *, int);
void  putch(int);
void  rdline(FILE *);
void  reset_tty(void);
void  screen(FILE *, int);
void  set_tty(void);
void  show(int);
void  skipf(int);
void  skiplns(int, FILE *);
char *resize_line(char *);
FILE *checkf(char *, int *);
__dead void usage(void);
struct sigaction sa;

int
main(int argc, char **argv)
{
	FILE * volatile f;
	char		*s;
	volatile int	left;
	volatile off_t	initline;
	volatile int	prnames = 0;
	volatile int	initopt = 0;
	volatile int	srchopt = 0;
	int		clearit = 0;
	int		ch;
	char		initbuf[80];

	if (pledge("stdio rpath tty", NULL) == -1) {
		perror("pledge");
		exit(1);
	}

	setlocale(LC_ALL, "");

	/* all signals just use a stub handler and interrupt syscalls */
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	sa.sa_handler = onsignal;

	nfiles = argc;
	fnames = argv;
	initterm();
	nscroll = Lpp/2 - 1;
	if (nscroll <= 0)
		nscroll = 1;
	if ((s = getenv("MORE")) != NULL && *s != '\0')
		argscan(s);
	while (--nfiles > 0) {
		if ((ch = (*++fnames)[0]) == '-')
			argscan(*fnames + 1);
		else if (ch == '+') {
			s = *fnames;
			if (*++s == '/') {
				srchopt++;
				(void)strlcpy(initbuf, ++s, sizeof(initbuf));
			} else {
				initopt++;
				for (initline = 0; *s != '\0'; s++) {
					if (isdigit((unsigned char)*s))
						initline =
						    initline * 10 + *s - '0';
				}
				--initline;
			}
		} else
			break;
	}
	/*
	 * Allow clreol only if Home and eraseln and EodClr strings are
	 * defined, and in that case, make sure we are in noscroll mode.
	 */
	if (clreol) {
		if (Home == NULL || *Home == '\0' || eraseln == NULL ||
		    *eraseln == '\0' || EodClr == NULL || *EodClr == '\0')
			clreol = 0;
		else
			noscroll = 1;
	}
	if (dlines == 0)
		dlines = Lpp - 1;
	left = dlines;
	if (nfiles > 1)
		prnames++;
	if (!no_intty && nfiles == 0)
		usage();
	else
		f = stdin;
	if (!no_tty) {
		struct sigaction osa;

		(void)sigaction(SIGQUIT, &sa, NULL);
		(void)sigaction(SIGINT, &sa, NULL);
		(void)sigaction(SIGWINCH, &sa, NULL);
		if (sigaction(SIGTSTP, &osa, NULL) == 0 &&
		    osa.sa_handler == SIG_DFL) {
			(void)sigaction(SIGTSTP, &sa, NULL);
			(void)sigaction(SIGTTIN, &sa, NULL);
			(void)sigaction(SIGTTOU, &sa, NULL);
			catch_susp++;
		}
		set_tty();
	}
	if (no_intty) {
		if (no_tty)
			copy_file(stdin);
		else {
			if ((ch = Getc(f)) == '\f')
				doclear();
			else {
				Ungetc(ch, f);
				if (noscroll && ch != EOF) {
					if (clreol)
						home();
					else
						doclear();
				}
			}
			if (srchopt) {
				if (search(initbuf, stdin, 1) == 0 && noscroll)
					left--;
			} else if (initopt)
				skiplns(initline, stdin);
			screen(stdin, left);
		}
		no_intty = 0;
		dup2(STDERR_FILENO, STDIN_FILENO);	/* stderr is a tty */
		prnames++;
		firstf = 0;
	}

	while (fnum < nfiles) {
		if ((f = checkf(fnames[fnum], &clearit)) != NULL) {
			context.line = context.chrctr = 0;
			Currline = 0;
		restart:
			if (firstf) {
				firstf = 0;
				if (srchopt) {
					if (search(initbuf, f, 1) < 0)
						goto restart;
					if (noscroll)
						left--;
				} else if (initopt)
					skiplns(initline, f);
			} else if (fnum < nfiles && !no_tty)
				left = command(fnames[fnum], f);
			if (left != 0) {
				if ((noscroll || clearit) &&
				    (file_size != LONG_MAX)) {
					if (clreol)
						home();
					else
						doclear();
				}
				if (prnames) {
					if (bad_so)
						erasep(0);
					if (clreol)
						cleareol();
					fputs("::::::::::::::", stdout);
					if (promptlen > 14)
						erasep(14);
					putchar('\n');
					if (clreol)
						cleareol();
					printf("%s\n", fnames[fnum]);
					if (clreol)
						cleareol();
					fputs("::::::::::::::\n", stdout);
					if (left > Lpp - 4)
						left = Lpp - 4;
				}
				if (no_tty)
					copy_file(f);
				else {
					within++;
					screen(f, left);
					within = 0;
				}
			}
			fflush(stdout);
			fclose(f);
			screen_start.line = screen_start.chrctr = 0L;
			context.line = context.chrctr = 0L;
		}
		fnum++;
		firstf = 0;
	}
	reset_tty();
	exit(0);
}

void
argscan(char *s)
{
	int seen_num = 0;

	while (*s != '\0') {
		switch (*s) {
		case '0': case '1': case '2':
		case '3': case '4': case '5':
		case '6': case '7': case '8':
		case '9':
			if (!seen_num) {
				dlines = 0;
				seen_num = 1;
			}
			dlines = (dlines * 10) + (*s - '0');
			break;
		case 'd':
			dum_opt = 1;
			break;
		case 'l':
			stop_opt = 0;
			break;
		case 'f':
			fold_opt = 0;
			break;
		case 'p':
			noscroll++;
			break;
		case 'c':
			clreol++;
			break;
		case 's':
			ssp_opt = 1;
			break;
		case 'u':
			ul_opt = 0;
			break;
		case 'X':
		case 'E':
		case '-':
		case ' ':
		case '\t':
			break;
		default:
			fprintf(stderr, "%s: unknown option \"-%c\"\n",
			    __progname, *s);
			usage();
		}
		s++;
	}
}

/*
 * Check whether the file named by fs is an ASCII file which the user may
 * access.  If it is, return the opened file. Otherwise return NULL.
 */
FILE *
checkf(char *fs, int *clearfirst)
{
	struct stat stbuf;
	FILE *f;
	int ch;

	if (stat(fs, &stbuf) == -1) {
		(void)fflush(stdout);
		if (clreol)
			cleareol();
		perror(fs);
		return (NULL);
	}
	if ((stbuf.st_mode & S_IFMT) == S_IFDIR) {
		printf("\n*** %s: directory ***\n\n", fs);
		return (NULL);
	}
	if ((f = Fopen(fs, "r")) == NULL) {
		(void)fflush(stdout);
		perror(fs);
		return (NULL);
	}
	if (magic(f, fs))
		return (NULL);
	ch = Getc(f);
	*clearfirst = (ch == '\f');
	Ungetc(ch, f);
	if ((file_size = stbuf.st_size) == 0)
		file_size = LONG_MAX;
	return (f);
}

/*
 * magic --
 *	Check for file magic numbers.  This code would best be shared with
 *	the file(1) program or, perhaps, more should not try and be so smart?
 */
int
magic(FILE *f, char *fs)
{
	char twobytes[2];

	/* don't try to look ahead if the input is unseekable */
	if (fseeko(f, (off_t)0, SEEK_SET))
		return (0);

	if (fread(twobytes, 2, 1, f) == 1) {
		switch(twobytes[0] + (twobytes[1]<<8)) {
		case OMAGIC:
		case NMAGIC:
		case ZMAGIC:
		case 0405:
		case 0411:
		case 0x457f:
		case 0177545:
			printf("\n******** %s: Not a text file ********\n\n",
			    fs);
			(void)fclose(f);
			return (1);
		}
	}
	(void)fseeko(f, (off_t)0, SEEK_SET);	/* rewind() not necessary */
	return (0);
}

/*
 * A real function (not a macro), for the tputs() routine in termlib
 */
void
putch(int ch)
{
	putchar(ch);
}

#define	STOP	(-10)

/*
 * Print out the contents of the file f, one screenful at a time.
 */
void
screen(FILE *f, int num_lines)
{
	int ch;
	int nchars;
	int length;			/* length of current line */
	static int prev_len = 1;	/* length of previous line */

	for (;;) {
		while (num_lines > 0 && !Pause) {
			if ((nchars = get_line(f, &length)) == EOF) {
				if (clreol)
					clreos();
				return;
			}
			if (ssp_opt && length == 0 && prev_len == 0)
				continue;
			prev_len = length;
			if (bad_so ||
			    (Senter && *Senter == ' ' && promptlen > 0))
				erasep(0);
			/*
			 * Must clear before drawing line since tabs on some
			 * terminals do not erase what they tab over.
			 */
			if (clreol)
				cleareol();
			prbuf(Line, length);
			if (nchars < promptlen) {
				/* erasep() sets promptlen to 0 */
				erasep(nchars);
			} else
				promptlen = 0;
#if 0
			/* XXX - is this needed? */
			if (clreol) {
				/* must clear again in case we wrapped * */
				cleareol();
			}
#endif
			if (nchars < Mcol || !fold_opt) {
				/* will turn off UL if necessary */
				prbuf("\n", 1);
			}
			if (nchars == STOP)
				break;
			num_lines--;
		}
		if (pstate) {
			tputs(ULexit, 1, putch);
			pstate = 0;
		}
		fflush(stdout);
		if ((ch = Getc(f)) == EOF) {
			if (clreol)
				clreos();
			return;
		}

		if (Pause && clreol)
			clreos();
		Ungetc(ch, f);
		Pause = 0;
		startup = 0;
		if ((num_lines = command(NULL, f)) == 0)
			return;
		if (hard && promptlen > 0)
			erasep(0);
		if (noscroll && num_lines >= dlines) {
			if (clreol)
				home();
			else
				doclear();
		}
		/*
		 * XXX - should store the *first* line on the screen,
		 * not the last (but we don't know the file position).
		 * Fixing this requires keeping an arry of dline off_ts
		 * and updating each one when a new line is started.
		 */
		screen_start.line = Currline;
		screen_start.chrctr = Ftell(f);
	}
}

/*
 * Clean up terminal state and exit. Also come here if interrupt signal received
 */
void __dead
end_it(void)
{
	reset_tty();
	if (clreol) {
		putchar('\r');
		clreos();
		fflush(stdout);
	} else if (promptlen > 0) {
		kill_line();
		fflush(stdout);
	} else
		write(STDERR_FILENO, "\n", 1);
	_exit(0);
}

void
copy_file(FILE *f)
{
	int ch;

	while ((ch = getc(f)) != EOF)
		putchar(ch);
}

static char bell = ctrl('G');

void
prompt(char *filename)
{
	if (clreol)
		cleareol();
	else if (promptlen > 0)
		kill_line();
	if (!hard) {
		promptlen = 8;
		if (Senter && Sexit) {
			tputs(Senter, 1, putch);
			promptlen += (2 * soglitch);
		}
		if (clreol)
			cleareol();
		fputs("--More--", stdout);
		if (filename != NULL)
			promptlen += printf("(Next file: %s)", filename);
		else if (!no_intty)
			promptlen += printf("(%d%%)",
			    (int)((file_pos * 100) / file_size));
		if (dum_opt) {
			fputs(DUM_PROMPT, stdout);
			promptlen += sizeof(DUM_PROMPT) - 1;
		}
		if (Senter && Sexit)
			tputs(Sexit, 1, putch);
		if (clreol)
			clreos();
		fflush(stdout);
	} else
		write(STDERR_FILENO, &bell, 1);
	inwait++;
}

/*
 * Get a logical line.
 */
int
get_line(FILE *f, int *length)
{
	int		ch, lastch;
	char		*p, *ep;
	int		column;
	static int	colflg;

	p = Line;
	ep = Line + linsize - 1;
	column = 0;
	ch = Getc(f);
	if (colflg && ch == '\n') {
		Currline++;
		ch = Getc(f);
	}
	for (;;) {
		if (p >= ep) {
			p = resize_line(p);
			ep = Line + linsize - 1;
		}
		if (ch == EOF) {
			if (p > Line) {
				*p = '\0';
				*length = p - Line;
				return (column);
			}
			*length = p - Line;
			return (EOF);
		}
		if (ch == '\n') {
			Currline++;
			break;
		}
		*p++ = (char)ch;
		if (ch == '\t') {
			if (!hardtabs || (column < promptlen && !hard)) {
				if (hardtabs && eraseln && !dumb) {
					column = 1 + (column | 7);
					tputs(eraseln, 1, putch);
					promptlen = 0;
				} else {
					for (--p;;) {
						if (p >= ep) {
							p = resize_line(p);
							ep = Line + linsize - 1;
						}
						*p++ = ' ';
						if ((++column & 7) == 0)
							break;
					}
					if (column >= promptlen)
						promptlen = 0;
				}
			} else
				column = 1 + (column | 7);
		} else if (ch == '\b' && column > 0)
			column--;
		else if (ch == '\f' && stop_opt) {
			p[-1] = '^';
			*p++ = 'L';
			column += 2;
			Pause++;
		} else if (ch == EOF) {
			*length = p - Line;
			return (column);
		} else if (ch >= ' ' && ch != RUBOUT)
			column++;
		if (column >= Mcol && fold_opt)
			break;
		lastch = ch;
		ch = Getc(f);
		if (lastch == '\r') {
			/*
			 * Reset column to 0 for carriage return unless
			 * immediately followed by a newline.
			 */
			if (ch != '\n')
				column = 0;
			else
				p--;
		}
	}
	/* XXX - potential oflow */
	if (column >= Mcol && Mcol > 0 && !Wrap)
		*p++ = '\n';
	colflg = (column == Mcol && fold_opt);
	if (colflg && eatnl && Wrap)
		*p++ = '\n';	/* simulate normal wrap */
	*length = p - Line;
	*p = '\0';
	return (column);
}

/*
 * Erase the rest of the prompt, assuming we are starting at column col.
 */
void
erasep(int col)
{
	if (promptlen == 0)
		return;
	if (hard)
		putchar('\n');
	else {
		if (col == 0)
			putchar('\r');
		if (!dumb && eraseln)
			tputs(eraseln, 1, putch);
		else {
			for (col = promptlen - col; col > 0; col--)
				putchar(' ');
		}
	}
	promptlen = 0;
}

/*
 * Erase the current line entirely
 */
void
kill_line(void)
{
	erasep(0);
	if (!eraseln || dumb)
		putchar('\r');
}

/*
 * Print a buffer of n characters.
 */
void
prbuf(char *s, int n)
{
	char c;			/* next output character */
	int state;		/* next output char's UL state */
#define wouldul(s,n)	((n) >= 2 && (((s)[0] == '_' && (s)[1] == '\b') || ((s)[1] == '\b' && (s)[2] == '_')))

	while (--n >= 0) {
		if (!ul_opt)
			putchar(*s++);
		else {
			if (*s == ' ' && pstate == 0 && ulglitch &&
			    wouldul(s + 1, n - 1)) {
				s++;
				continue;
			}
			if ((state = wouldul(s, n))) {
				c = (*s == '_')? s[2] : *s ;
				n -= 2;
				s += 3;
			} else
				c = *s++;
			if (state != pstate) {
				if (c == ' ' && state == 0 && ulglitch &&
				    wouldul(s, n - 1))
					state = 1;
				else
					tputs(state ? ULenter : ULexit, 1, putch);
			}
			if (c != ' ' || pstate == 0 || state != 0 ||
			    ulglitch == 0)
				putchar(c);
			if (state && *chUL) {
				fputs(chBS, stdout);
				tputs(chUL, 1, putch);
			}
			pstate = state;
		}
	}
}

/*
 * Clear the screen
 */
void
doclear(void)
{
	if (Clear && !hard) {
		tputs(Clear, 1, putch);

		/*
		 * Put out carriage return so that system doesn't
		 * get confused by escape sequences when expanding tabs.
		 */
		putchar('\r');
		promptlen = 0;
	}
}

static int lastcmd, lastarg, lastp;
static int lastcolon;
char shell_line[BUFSIZ];

/*
 * Read a command and do it. A command consists of an optional integer
 * argument followed by the command character.  Return the number of lines
 * to display in the next screenful.  If there is nothing more to display
 * in the current file, zero is returned.
 */
int
command(char *filename, FILE *f)
{
	int nlines;
	int retval;
	int ch;
	char colonch;
	int done;
	char comchar, cmdbuf[80];

#define ret(val) retval=val;done++;break

	retval = done = 0;
	if (!errors)
		prompt(filename);
	else
		errors = 0;
	for (;;) {
		nlines = number(&comchar);
		lastp = colonch = 0;
		if (comchar == '.') {	/* Repeat last command */
			lastp++;
			comchar = lastcmd;
			nlines = lastarg;
			if (lastcmd == ':')
				colonch = lastcolon;
		}
		lastcmd = comchar;
		lastarg = nlines;
		if (comchar == otty.c_cc[VERASE]) {
			kill_line();
			prompt(filename);
			continue;
		}
		switch (comchar) {
		case ':':
			retval = colon(filename, colonch, nlines);
			if (retval >= 0)
				done++;
			break;
		case 'b':
		case ctrl('B'):
		    {
			int initline;

			if (no_intty) {
				write(STDERR_FILENO, &bell, 1);
				return (-1);
			}

			if (nlines == 0)
				nlines++;

			putchar('\r');
			erasep(0);
			putchar('\n');
			if (clreol)
				cleareol();
			printf("...back %d page", nlines);
			if (nlines > 1)
				fputs("s\n", stdout);
			else
				putchar('\n');

			if (clreol)
				cleareol();
			putchar('\n');

			initline = Currline - (off_t)dlines * (nlines + 1);
			if (!noscroll)
				--initline;
			if (initline < 0)
				initline = 0;
			Fseek(f, (off_t)0);
			Currline = 0; /* skiplns() will make Currline correct */
			skiplns(initline, f);
			ret(dlines);
		    }
		case ' ':
		case 'z':
			if (nlines == 0)
				nlines = dlines;
			else if (comchar == 'z')
				dlines = nlines;
			ret(nlines);
		case 'd':
		case ctrl('D'):
			if (nlines != 0)
				nscroll = nlines;
			ret(nscroll);
		case 'q':
		case 'Q':
			end_it();
		case 's':
		case 'f':
			if (nlines == 0)
				nlines++;
			if (comchar == 'f')
				nlines *= dlines;
			putchar('\r');
			erasep(0);
			putchar('\n');
			if (clreol)
				cleareol();
			printf("...skipping %d line", nlines);
			if (nlines > 1)
				fputs("s\n", stdout);
			else
				putchar('\n');

			if (clreol)
				cleareol();
			putchar('\n');

			while (nlines > 0) {
				while ((ch = Getc(f)) != '\n') {
					if (ch == EOF) {
						retval = 0;
						done++;
						goto endsw;
					}
				}
				Currline++;
				nlines--;
			}
			ret(dlines);
		case '\n':
			if (nlines != 0)
				dlines = nlines;
			else
				nlines = 1;
			ret(nlines);
		case '\f':
			if (!no_intty) {
				doclear();
				Fseek(f, screen_start.chrctr);
				Currline = screen_start.line;
				ret(dlines);
			} else {
				write(STDERR_FILENO, &bell, 1);
				break;
			}
		case '\'':
			if (!no_intty) {
				kill_line();
				fputs("\n***Back***\n\n", stdout);
				Fseek(f, context.chrctr);
				Currline = context.line;
				ret(dlines);
			} else {
				write(STDERR_FILENO, &bell, 1);
				break;
			}
		case '=':
			kill_line();
			promptlen = printf("%lld", (long long)Currline);
			fflush(stdout);
			break;
		case 'n':
			lastp++;
		case '/':
			if (nlines == 0)
				nlines++;
			kill_line();
			putchar('/');
			promptlen = 1;
			fflush(stdout);
			if (lastp) {
				/* Use previous r.e. */
				write(STDERR_FILENO, "\r", 1);
				if (search(NULL, f, nlines) < 0)
					break;
			} else {
				if (ttyin(cmdbuf, sizeof(cmdbuf) - 2, '/') < 0) {
					kill_line();
					prompt(filename);
					continue;
				}
				write(STDERR_FILENO, "\r", 1);
				if (search(cmdbuf, f, nlines) < 0)
					break;
			}
			ret(dlines-1);
		case '?':
		case 'h':
			if (noscroll)
				doclear();
			fputs(more_help, stdout);
			prompt(filename);
			break;
		default:
			if (dum_opt) {
				kill_line();
				if (Senter && Sexit) {
					tputs(Senter, 1, putch);
					fputs(DUM_ERROR, stdout);
					promptlen = sizeof(DUM_ERROR) - 1 +
					    (2 * soglitch);
					tputs(Sexit, 1, putch);
				} else {
					fputs(DUM_ERROR, stdout);
					promptlen = sizeof(DUM_ERROR) - 1;
				}
				fflush(stdout);
			} else
				write(STDERR_FILENO, &bell, 1);
			break;
		}
		if (done)
			break;
	}
	putchar('\r');
endsw:
	inwait = 0;
	notell++;
	return (retval);
}

/*
 * Execute a colon-prefixed command.
 * Returns <0 if not a command that should cause
 * more of the file to be printed.
 */
int
colon(char *filename, int cmd, int nlines)
{
	int ch;

	if (cmd == 0)
		ch = readch();
	else
		ch = cmd;
	lastcolon = ch;
	switch (ch) {
	case 'f':
		kill_line();
		if (!no_intty)
			promptlen =
			    printf("\"%s\" line %lld", fnames[fnum],
				(long long)Currline);
		else
			promptlen = printf("[Not a file] line %lld",
			    (long long)Currline);
		fflush(stdout);
		return (-1);
	case 'n':
		if (nlines == 0) {
			if (fnum >= nfiles - 1)
				end_it();
			nlines++;
		}
		putchar('\r');
		erasep(0);
		skipf(nlines);
		return (0);
	case 'p':
		if (no_intty) {
			write(STDERR_FILENO, &bell, 1);
			return (-1);
		}
		putchar('\r');
		erasep(0);
		if (nlines == 0)
			nlines++;
		skipf (-nlines);
		return (0);
	case 'q':
	case 'Q':
		end_it();
		/*FALLTHROUGH*/
	default:
		write(STDERR_FILENO, &bell, 1);
		return (-1);
	}
}

/*
 * Read a decimal number from the terminal. Set cmd to the non-digit which
 * terminates the number.
 */
int
number(char *cmd)
{
	int ch, i;

	ch = otty.c_cc[VKILL];
	i = 0;
	for (;;) {
		ch = readch();
		if (isdigit(ch))
			i = i*10 + ch - '0';
		else if (ch == otty.c_cc[VKILL])
			i = 0;
		else {
			*cmd = ch;
			break;
		}
	}
	return (i);
}


/*
 * Search for nth occurrence of regular expression contained in buf in the file
 */
int
search(char *buf, FILE *file, int n)
{
	off_t startline = Ftell(file);
	off_t line1 = startline;
	off_t line2 = startline;
	off_t line3 = startline;
	off_t saveln;
	int lncount, rv;
	char ebuf[BUFSIZ];
	static regex_t reg;
	static int initialized;

	context.line = saveln = Currline;
	context.chrctr = startline;
	lncount = 0;
	if (buf != NULL && *buf != '\0') {
		if ((rv = regcomp(&reg, buf, REG_NOSUB)) != 0) {
			initialized = 0;
			regerror(rv, &reg, ebuf, sizeof(ebuf));
			regfree(&reg);
			error(ebuf);
			return (-1);
		}
		initialized = 1;
	} else if (!initialized) {
		error("No previous regular expression");
		return (-1);
	}
	while (!feof(file)) {
		line3 = line2;
		line2 = line1;
		line1 = Ftell(file);
		rdline(file);
		lncount++;
		if ((rv = regexec(&reg, Line, 0, NULL, 0)) == 0) {
			if (--n == 0) {
				if (lncount > 3 || (lncount > 1 && no_intty)) {
					putchar('\n');
					if (clreol)
						cleareol();
					fputs("...skipping\n", stdout);
				}
				if (!no_intty) {
					Currline -= (lncount >= 3 ? 3 : lncount);
					Fseek(file, line3);
					if (noscroll) {
						if (clreol) {
							home();
							cleareol();
						} else
							doclear();
					}
				} else {
					kill_line();
					if (noscroll) {
					    if (clreol) {
						    home();
						    cleareol();
					    } else
						    doclear();
					}
					fputs(Line, stdout);
					putchar('\n');
				}
				break;
			}
		} else if (rv != REG_NOMATCH) {
			regerror(rv, &reg, ebuf, sizeof(ebuf));
			error(ebuf);
			return (-1);
		}
	}
	if (feof(file)) {
		if (!no_intty) {
			Currline = saveln;
			Fseek(file, startline);
		} else {
			fputs("\nPattern not found\n", stdout);
			end_it();
		}
		error("Pattern not found");
		return (-1);
	}
	return (0);
}

/*
 * Skip n lines in the file f
 */
void
skiplns(int n, FILE *f)
{
	int ch;

	while (n > 0) {
		while ((ch = Getc(f)) != '\n') {
			if (ch == EOF)
				return;
		}
		n--;
		Currline++;
	}
}

/*
 * Skip nskip files in the file list (from the command line).
 * Nskip may be negative.
 */
void
skipf(int nskip)
{
	if (nskip == 0)
		return;
	if (nskip > 0) {
		if (fnum + nskip > nfiles - 1)
			nskip = nfiles - fnum - 1;
	}
	else if (within)
		++fnum;
	fnum += nskip;
	if (fnum < 0)
		fnum = 0;
	fputs("\n...Skipping \n", stdout); /* XXX huh? */
	if (clreol)
		cleareol();
	printf("...Skipping %sto file %s\n", nskip > 0 ? "" : "back ",
	    fnames[fnum]);
	if (clreol)
		cleareol();
	putchar('\n');
	--fnum;
}

/*
 * Terminal I/O
 */
void
initterm(void)
{
	char		buf[TBUFSIZ];
	static char	clearbuf[TBUFSIZ];
	char		*clearptr, *padstr;
	char		*term;
	int		tgrp;
	struct winsize	win;

retry:
	if (!(no_tty = tcgetattr(STDOUT_FILENO, &otty))) {
		docrterase = (otty.c_cc[VERASE] != _POSIX_VDISABLE);
		docrtkill =  (otty.c_cc[VKILL] != _POSIX_VDISABLE);
		/*
		 * Wait until we're in the foreground before we save the
		 * the terminal modes.
		 */
		if ((tgrp = tcgetpgrp(STDOUT_FILENO)) < 0) {
			perror("tcgetpgrp");
			exit(1);
		}
		if (tgrp != getpgrp()) {
			kill(0, SIGTTOU);
			goto retry;
		}
		if ((term = getenv("TERM")) == 0 || tgetent(buf, term) <= 0) {
			dumb++; ul_opt = 0;
		} else {
			if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) < 0) {
				Lpp = tgetnum("li");
				Mcol = tgetnum("co");
			} else {
				if ((Lpp = win.ws_row) == 0)
					Lpp = tgetnum("li");
				if ((Mcol = win.ws_col) == 0)
					Mcol = tgetnum("co");
			}
			if (Lpp <= 0 || tgetflag("hc")) {
				hard++;		/* Hard copy terminal */
				Lpp = 24;
			}
			if (tgetflag("xn")) {
				/* Eat newline at last column + 1 */
				eatnl++;
			}
			if (Mcol <= 0)
				Mcol = 80;

			if (strcmp(__progname, "page") == 0 ||
			    (!hard && tgetflag("ns")))
				noscroll++;
			Wrap = tgetflag("am");
			bad_so = tgetflag ("xs");
			clearptr = clearbuf;
			eraseln = tgetstr("ce", &clearptr);
			Clear = tgetstr("cl", &clearptr);
			Senter = tgetstr("so", &clearptr);
			Sexit = tgetstr("se", &clearptr);
			if ((soglitch = tgetnum("sg")) < 0)
				soglitch = 0;

			/*
			 * Setup for underlining.  Some terminals don't need it,
			 * others have start/stop sequences, still others have
			 * an underline char sequence which is assumed to move
			 * the cursor forward one character.  If underline seq
			 * isn't available, settle for standout sequence.
			 */
			if (tgetflag("ul") || tgetflag("os"))
				ul_opt = 0;
			if ((chUL = tgetstr("uc", &clearptr)) == NULL)
				chUL = "";
			if (((ULenter = tgetstr("us", &clearptr)) == NULL ||
			    (ULexit = tgetstr("ue", &clearptr)) == NULL) &&
			    !*chUL) {
				if ((ULenter = Senter) == NULL ||
				    (ULexit = Sexit) == NULL) {
					ULenter = "";
					ULexit = "";
				} else
					ulglitch = soglitch;
			} else {
				if ((ulglitch = tgetnum("ug")) < 0)
					ulglitch = 0;
			}

			if ((padstr = tgetstr("pc", &clearptr)))
				PC = *padstr;
			Home = tgetstr("ho", &clearptr);
			if (Home == 0 || *Home == '\0') {
				cursorm = tgetstr("cm", &clearptr);
				if (cursorm != NULL) {
					strlcpy(cursorhome,
					    tgoto(cursorm, 0, 0),
					    sizeof(cursorhome));
					Home = cursorhome;
				}
			}
			EodClr = tgetstr("cd", &clearptr);
			if ((chBS = tgetstr("bc", &clearptr)) == NULL)
				chBS = "\b";
			if (tgetstr("te", &clearptr) != NULL &&
			    tgetstr("ti", &clearptr) != NULL)
				altscr = 1;
		}
		if ((shell = getenv("SHELL")) == NULL)
			shell = _PATH_BSHELL;
	}
	no_intty = !isatty(STDIN_FILENO);
	tcgetattr(STDERR_FILENO, &otty);
	slow_tty = cfgetospeed(&otty) < B1200;
	hardtabs = !(otty.c_oflag & OXTABS);
	ntty = otty;
	if (!no_tty) {
		ntty.c_lflag &= ~(ICANON|ECHO);
		ntty.c_cc[VMIN] = 1;	/* read at least 1 char */
		ntty.c_cc[VTIME] = 0;	/* no timeout */
	}
}

int
handle_signal(void)
{
	int sig, ch = -1;

	for (sig = 0; sig < _NSIG; sig++) {
		if (signo[sig] == 0)
			continue;
		signo[sig] = 0;

		switch (sig) {
		case SIGQUIT:
			if (!inwait) {
				putchar('\n');
				if (startup)
					Pause++;
			} else if (!dum_opt && notell) {
				write(STDERR_FILENO, QUIT_IT,
				    sizeof(QUIT_IT) - 1);
				promptlen += sizeof(QUIT_IT) - 1;
				notell = 0;
			}
			break;
		case SIGTSTP:
		case SIGTTIN:
		case SIGTTOU:
			/* XXX - should use saved values instead of SIG_DFL */
			sa.sa_handler = SIG_DFL;
			sa.sa_flags = SA_RESTART;
			(void)sigaction(SIGTSTP, &sa, NULL);
			(void)sigaction(SIGTTIN, &sa, NULL);
			(void)sigaction(SIGTTOU, &sa, NULL);
			reset_tty();
			kill(getpid(), sig);

			sa.sa_handler = onsignal;
			sa.sa_flags = 0;
			(void)sigaction(SIGTSTP, &sa, NULL);
			(void)sigaction(SIGTTIN, &sa, NULL);
			(void)sigaction(SIGTTOU, &sa, NULL);
			set_tty();
			if (!no_intty)
				ch = '\f';	/* force redraw */
			break;
		case SIGINT:
			end_it();
			break;
		case SIGWINCH: {
			struct winsize win;

			if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) != 0)
				break;
			if (win.ws_row != 0) {
				Lpp = win.ws_row;
				nscroll = Lpp/2 - 1;
				if (nscroll <= 0)
					nscroll = 1;
				dlines = Lpp - 1;
			}
			if (win.ws_col != 0)
				Mcol = win.ws_col;
			if (!no_intty)
				ch = '\f';	/* force redraw */
			break;
		} default:
			/* NOTREACHED */
			break;
		}
	}
	return (ch);
}

int
readch(void)
{
	unsigned char ch;
	int r;

	/* We know stderr is hooked up to /dev/tty so this is safe. */
again:
	switch (read(STDERR_FILENO, &ch, 1)) {
	case 1:
		return (ch);
	case -1:
		if (errno != EINTR)
			end_it();

		r = handle_signal();
		if (r == -1)
			goto again;
		return (r);		/* redraw, continue, etc */
	default:
	case 0:
		end_it();
	}
}

static char BS1 = '\b';
static char BSB[] = "\b \b";
static char CARAT = '^';
#define	ERASEONECHAR	do {					\
	if (docrterase)						\
		write(STDERR_FILENO, BSB, sizeof(BSB) - 1);	\
	else							\
		write(STDERR_FILENO, &BS1, 1);			\
} while (0)

int
ttyin(char *buf, int nmax, char pchar)
{
	char	cbuf, ch, *sptr;
	int	maxlen, slash;

	sptr = buf;
	slash = maxlen = 0;
	while (sptr - buf < nmax) {
		if (promptlen > maxlen)
			maxlen = promptlen;
		ch = readch();
		if (ch == '\\')
			slash++;
		else if ((ch == otty.c_cc[VERASE]) && !slash) {
			if (sptr > buf) {
				--promptlen;
				ERASEONECHAR;
				--sptr;
				if ((*sptr < ' ' && *sptr != '\n') ||
				    *sptr == RUBOUT) {
					--promptlen;
					ERASEONECHAR;
				}
				continue;
			} else {
				if (!eraseln)
					promptlen = maxlen;
				return (-1);
			}
		} else if ((ch == otty.c_cc[VKILL]) && !slash) {
			if (hard) {
				show(ch);
				putchar('\n');
				putchar(pchar);
			} else {
				putchar('\r');
				putchar(pchar);
				if (eraseln)
					erasep(1);
				else if (docrtkill) {
					while (promptlen-- > 1)
						write(STDERR_FILENO, BSB,
						    sizeof(BSB) - 1);
				}
				promptlen = 1;
			}
			sptr = buf;
			fflush(stdout);
			continue;
		}
		if (slash && (ch == otty.c_cc[VKILL] ||
		    ch == otty.c_cc[VERASE])) {
			ERASEONECHAR;
			--sptr;
		}
		if (ch != '\\')
			slash = 0;
		*sptr++ = ch;
		if ((ch < ' ' && ch != '\n' && ch != ESC) || ch == RUBOUT) {
			ch += ch == RUBOUT ? -0100 : 0100;
			write(STDERR_FILENO, &CARAT, 1);
			promptlen++;
		}
		cbuf = ch;
		if (ch != '\n' && ch != ESC) {
			write(STDERR_FILENO, &cbuf, 1);
			promptlen++;
		} else
			break;
	}
	*--sptr = '\0';
	if (!eraseln)
		promptlen = maxlen;
	if (sptr - buf >= nmax - 1)
		error("Line too long");

	return (0);
}

int
expand(char *outbuf, size_t olen, char *inbuf)
{
	size_t len;
	char *instr;
	char *outstr;
	char c;
	char temp[200];
	int changed = 0;

	instr = inbuf;
	outstr = temp;
	while ((c = *instr++) != '\0') {
		switch (c) {
		case '%':
			if (!no_intty) {
				len = strlcpy(outstr, fnames[fnum],
				    temp + sizeof(temp) - outstr);
				if (len >= temp + sizeof(temp) - outstr)
					len = temp + sizeof(temp) - outstr - 1;
				outstr += len;
				changed++;
			} else
				*outstr++ = c;
			break;
		case '!':
			if (!shellp)
				error("No previous command to substitute for");
			len = strlcpy(outstr, shell_line,
			    temp + sizeof(temp) - outstr);
			if (len >= temp + sizeof(temp) - outstr)
				len = temp + sizeof(temp) - outstr - 1;
			outstr += len;
			changed++;
			break;
		case '\\':
			if (*instr == '%' || *instr == '!') {
				*outstr++ = *instr++;
				break;
			}
		default:
			*outstr++ = c;
			break;
		}
	}
	*outstr++ = '\0';
	strlcpy(outbuf, temp, olen);
	return (changed);
}

void
show(int ch)
{
	char cbuf;

	if ((ch < ' ' && ch != '\n' && ch != ESC) || ch == RUBOUT) {
		ch += ch == RUBOUT ? -0100 : 0100;
		write(STDERR_FILENO, &CARAT, 1);
		promptlen++;
	}
	cbuf = ch;
	write(STDERR_FILENO, &cbuf, 1);
	promptlen++;
}

void
error(char *mess)
{
	if (clreol)
		cleareol();
	else
		kill_line();
	promptlen += strlen (mess);
	if (Senter && Sexit) {
		tputs(Senter, 1, putch);
		fputs(mess, stdout);
		tputs(Sexit, 1, putch);
	} else
		fputs(mess, stdout);
	fflush(stdout);
	errors++;
}

void
set_tty(void)
{
	tcsetattr(STDERR_FILENO, TCSANOW, &ntty);
}

void
reset_tty(void)
{
	if (no_tty)
		return;
	if (pstate) {
		tputs(ULexit, 1, putch);
		fflush(stdout);
		pstate = 0;
	}
	tcsetattr(STDERR_FILENO, TCSANOW, &otty);
}

void
rdline(FILE *f)
{
	int ch;
	char *p, *ep;

	p = Line;
	ep = Line + linsize - 1;
	while ((ch = Getc(f)) != '\n' && ch != EOF) {
		if (p >= ep) {
			p = resize_line(p);
			ep = Line + linsize - 1;
		}
		*p++ = (char)ch;
	}
	if (ch == '\n')
		Currline++;
	*p = '\0';
}

char *
resize_line(char *pos)
{
	char *np;

	linsize *= 2;
	if (Line != Lineb)
		np = realloc(Line, linsize);
	else if ((np = malloc(linsize)) != NULL)
		memcpy(np, Lineb, sizeof(Lineb));
	if (np == NULL) {
		kill_line();
		fputs("out of memory!\n", stdout);
		reset_tty();
		exit(1);
	}
	pos = np + (pos - Line);
	Line = np;

	return (pos);
}

/*
 * Come here when we get a signal we can handle.
 */
void
onsignal(int sig)
{
	signo[sig] = 1;
}

__dead void
usage(void)
{
	fprintf(stderr,
	    "usage: %s [-dfln] [+linenum | +/pattern] name1 name2 ...\n",
	    __progname);
	exit(1);
}
@


1.37
log
@the ramdisk more(1) works with pledge "stdio rpath tty"
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.36 2015/10/15 16:10:57 deraadt Exp $	*/
d603 1
a603 1
void
d876 1
a876 1
	char comchar, cmdbuf[80], *p;
d1465 1
a1465 1
	
d1480 1
a1480 1
	
d1522 1
d1747 1
a1747 1
		np = realloc(Line, linsize); 
@


1.36
log
@remove '!' (subshell) and 'v' (edit) commands from ramdisk more(1) command.
first off, ^Z job control was added to BSD unix sometime around 1980 and is
a much better mechanism since the parent shell can contain what is going on.
!command support becomes a visible defect when programs are pledge'd
secondly this saves space.
ok miod tobias
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.35 2015/01/16 06:39:33 deraadt Exp $	*/
d212 5
@


1.35
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.34 2013/11/27 20:25:47 deraadt Exp $	*/
a167 1
int   do_shell(char *);
a1045 7
		case '!':
			if (do_shell(filename) < 0) {
				kill_line();
				prompt(filename);
				continue;
			}
			break;
a1052 23
		case 'v':	/* This case should go right before default */
			if (!no_intty) {
				char *editor;

				editor = getenv("VISUAL");
				if (editor == NULL || *editor == '\0')
					editor = getenv("EDITOR");
				if (editor == NULL || *editor == '\0')
					editor = _PATH_VI;
				if ((p = strrchr(editor, '/')) != NULL)
					p++;
				else
					p = editor;
				kill_line();
				snprintf(cmdbuf, sizeof(cmdbuf), "+%lld",
				    (long long)Currline);
				if (!altscr)
					printf("%s %s %s", p, cmdbuf,
					    fnames[fnum]);
				execute(filename, editor, p, cmdbuf,
				    fnames[fnum]);
				break;
			}
a1128 6
	case '!':
		if (do_shell(filename) < 0) {
			kill_line();
			prompt(filename);
		}
		return (-1);
a1163 25
int
do_shell(char *filename)
{
	char cmdbuf[200];

	kill_line();
	putchar('!');
	fflush(stdout);
	promptlen = 1;
	if (lastp)
		fputs(shell_line, stdout);
	else {
		if (ttyin(cmdbuf, sizeof(cmdbuf) - 2, '!') < 0)
			return (-1);
		if (expand(shell_line, sizeof(shell_line), cmdbuf)) {
			kill_line();
			promptlen = printf("!%s", shell_line);
		}
	}
	fflush(stdout);
	write(STDERR_FILENO, "\n", 1);
	promptlen = 0;
	shellp = 1;
	execute(filename, shell, shell, "-c", shell_line);
}
a1252 51
}

void
execute(char *filename, char *cmd, char *av0, char *av1, char *av2)
{
	int id;
	int n;
	char *argp[4];

	argp[0] = av0;
	argp[1] = av1;
	argp[2] = av2;
	argp[3] = NULL;

	fflush(stdout);
	reset_tty();
	for (n = 10; (id = fork()) < 0 && n > 0; n--)
		sleep(5);
	if (id == 0) {
		execvp(cmd, argp);
		write(STDERR_FILENO, "exec failed\n", 12);
		exit(1);
	}
	if (id > 0) {
		sa.sa_flags = SA_RESTART;
		sa.sa_handler = SIG_IGN;
		(void)sigaction(SIGINT, &sa, NULL);
		(void)sigaction(SIGQUIT, &sa, NULL);
		if (catch_susp) {
			sa.sa_handler = SIG_DFL;
			(void)sigaction(SIGTSTP, &sa, NULL);
			(void)sigaction(SIGTTIN, &sa, NULL);
			(void)sigaction(SIGTTOU, &sa, NULL);
		}
		while (wait(NULL) > 0)
			continue;
		sa.sa_flags = 0;
		sa.sa_handler = onsignal;
		(void)sigaction(SIGINT, &sa, NULL);
		(void)sigaction(SIGQUIT, &sa, NULL);
		if (catch_susp) {
			(void)sigaction(SIGTSTP, &sa, NULL);
			(void)sigaction(SIGTTIN, &sa, NULL);
			(void)sigaction(SIGTTOU, &sa, NULL);
		}
	} else
		write(STDERR_FILENO, "can't fork\n", 11);
	set_tty();
	if (!altscr)
		fputs("------------------------\n", stdout);
	prompt(filename);
@


1.34
log
@astoundingly, the read loop has been subtly broken in a variety of ways
on big-endian machines for quite a while.  Some discussion with millert
and guenther to repair it.
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.33 2013/11/26 21:13:04 deraadt Exp $	*/
d65 1
a65 1
#include <sys/param.h>
d84 1
@


1.33
log
@unsigned char for ctype
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.32 2012/03/04 04:05:15 fgsch Exp $	*/
d1613 2
a1614 1
	int ch;
a1615 1
	errno = 0;
d1618 13
a1630 10
	if (read(STDERR_FILENO, &ch, 1) <= 0) {
		if (signo != 0) {
			if ((ch = handle_signal()) == -1)
				goto again;
		} else {
			if (errno != EINTR)
				end_it();
			else
				ch = otty.c_cc[VKILL];
		}
a1631 1
	return (ch);
@


1.32
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.31 2010/04/28 18:15:49 jsg Exp $	*/
d239 1
a239 1
					if (isdigit(*s))
@


1.31
log
@rename BS so we don't collide with the ocurses define,
makes gcc4 happy.

ok deraadt@@ 'Looks safe' miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.30 2010/01/14 00:47:30 deraadt Exp $	*/
d169 1
a169 1
int   getline(FILE *, int *);
d520 1
a520 1
			if ((nchars = getline(f, &length)) == EOF) {
d664 1
a664 1
getline(FILE *f, int *length)
@


1.30
log
@Same type of as in libc/libc/gen/readpassphrase.c 1.22.  Receiving
multiple signals into one variable means older signals are dropped.
ok dtucker
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.28 2009/10/27 23:59:23 deraadt Exp $	*/
d1632 1
a1632 1
static char BS = '\b';
d1639 1
a1639 1
		write(STDERR_FILENO, &BS, 1);			\
@


1.29
log
@errors spotted by lint
@
text
@d156 1
a156 1
volatile sig_atomic_t signo;	/* signal received */
d1539 1
a1539 1
handle_signal(int sig)
d1541 1
a1541 1
	int ch = -1;
d1543 4
a1546 1
	signo = 0;
d1548 57
a1604 48
	switch (sig) {
	case SIGQUIT:
		if (!inwait) {
			putchar('\n');
			if (startup)
				Pause++;
		} else if (!dum_opt && notell) {
			write(STDERR_FILENO, QUIT_IT,
			    sizeof(QUIT_IT) - 1);
			promptlen += sizeof(QUIT_IT) - 1;
			notell = 0;
		}
		break;
	case SIGTSTP:
	case SIGTTIN:
	case SIGTTOU:
		/* XXX - should use saved values instead of SIG_DFL */
		sa.sa_handler = SIG_DFL;
		sa.sa_flags = SA_RESTART;
		(void)sigaction(SIGTSTP, &sa, NULL);
		(void)sigaction(SIGTTIN, &sa, NULL);
		(void)sigaction(SIGTTOU, &sa, NULL);
		reset_tty();
		kill(getpid(), sig);

		sa.sa_handler = onsignal;
		sa.sa_flags = 0;
		(void)sigaction(SIGTSTP, &sa, NULL);
		(void)sigaction(SIGTTIN, &sa, NULL);
		(void)sigaction(SIGTTOU, &sa, NULL);
		set_tty();
		if (!no_intty)
			ch = '\f';	/* force redraw */
		break;
	case SIGINT:
		end_it();
		break;
	case SIGWINCH: {
		struct winsize win;

		if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) != 0)
			break;
		if (win.ws_row != 0) {
			Lpp = win.ws_row;
			nscroll = Lpp/2 - 1;
			if (nscroll <= 0)
				nscroll = 1;
			dlines = Lpp - 1;
a1605 8
		if (win.ws_col != 0)
			Mcol = win.ws_col;
		if (!no_intty)
			ch = '\f';	/* force redraw */
		break;
	} default:
		/* NOTREACHED */
		break;
d1620 1
a1620 1
			if ((ch = handle_signal(signo)) == -1)
d1872 1
a1872 1
	signo = sig;
@


1.28
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.27 2007/08/02 03:23:37 david Exp $	*/
a180 2
void  errwrite(char *);
void  errwrite1(char *);
d1168 1
@


1.27
log
@spelling fixes in the comments
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.26 2004/07/02 12:59:44 millert Exp $	*/
a49 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1980 The Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)more.c	5.28 (Berkeley) 3/1/93";
#else
static const char rcsid[] = "$OpenBSD: more.c,v 1.26 2004/07/02 12:59:44 millert Exp $";
#endif
#endif /* not lint */
@


1.26
log
@Accept but ignore -E and -X since they specify default more(1) behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.25 2003/06/05 03:39:51 millert Exp $	*/
d61 1
a61 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.25 2003/06/05 03:39:51 millert Exp $";
d1242 1
a1242 1
 * Search for nth ocurrence of regular expression contained in buf in the file
@


1.25
log
@Add my license
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.24 2003/06/05 03:17:47 millert Exp $	*/
d61 1
a61 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.24 2003/06/05 03:17:47 millert Exp $";
d427 2
@


1.24
log
@Attempt to deal w/ large files sanely by using off_t and fseeko().
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.23 2003/06/04 23:50:35 millert Exp $	*/
d3 19
d61 1
a61 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.23 2003/06/04 23:50:35 millert Exp $";
@


1.23
log
@Handle arbitrarily long lines and add a special case for \r\n pair;
just ignore the \r, otherwise we end up with a blank line.  An \r
in the middle of a line is left as-is.
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.22 2003/06/04 03:49:53 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.22 2003/06/04 03:49:53 millert Exp $";
a56 1
 *  o deal with large files (use off_t and ftello(), fseeko())
d81 1
a81 1
#define Fopen(s,m)	(Currline = 0, file_pos=0, fopen(s,m))
d83 1
a83 1
#define Fseek(f,off)	(file_pos=off, fseek(f,off,0))
d85 1
a85 1
#define Ungetc(c,f)	(--file_pos, ungetc(c,f))
d105 1
a105 1
long		file_pos, file_size;
d114 1
a114 1
int		Currline;	/* Line we are currently at */
d154 1
a154 1
	long chrctr, line;
d202 1
a202 1
	volatile int	initline;
d469 1
a469 1
	if (fseek(f, 0L, SEEK_SET))
d487 1
a487 1
	(void)fseek(f, 0L, L_SET);		/* rewind() not necessary */
d581 3
a583 1
		 * not the last (but we don't know the file position)
d926 1
a926 1
			initline = Currline - dlines * (nlines + 1);
d931 1
a931 1
			Fseek(f, 0L);
d1013 1
a1013 1
			promptlen = printf("%d", Currline);
d1069 2
a1070 2
				snprintf(cmdbuf, sizeof(cmdbuf), "+%d",
				    Currline);
d1126 2
a1127 1
			    printf("\"%s\" line %d", fnames[fnum], Currline);
d1129 2
a1130 1
			promptlen = printf("[Not a file] line %d", Currline);
d1226 6
a1231 6
	long startline = Ftell(file);
	long line1 = startline;
	long line2 = startline;
	long line3 = startline;
	int lncount;
	int saveln, rv;
d1299 1
a1299 1
			Fseek (file, startline);
@


1.22
log
@Correctly set dlines on terminal resize; missed this in rev 1.20.
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.21 2003/06/04 03:37:01 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.21 2003/06/04 03:37:01 millert Exp $";
d55 6
d131 2
a132 1
char		Line[LINSIZ];	/* Line buffer */
d150 1
d192 1
d660 2
a661 2
	int		ch;
	char		*p;
d666 1
d673 5
a677 1
	while (p < &Line[LINSIZ - 1]) {
d699 5
a703 1
					for (--p; p < &Line[LINSIZ - 1];) {
a714 2
		else if (ch == '\r')
			column = 0;
d727 1
d729 10
d740 1
d747 1
a747 1
	*p = 0;
d1253 1
a1253 1
		rdline (file);
d1815 1
a1815 1
	char *p;
d1818 6
a1823 1
	while ((ch = Getc(f)) != '\n' && ch != EOF && p - Line < LINSIZ - 1)
d1825 1
d1829 22
@


1.21
log
@Fix for machines w/ unsigned chars; part from drahn@@
Use 'ch' as variable name for int-sized characters (e.g. EOF)
Use 'c' as variable name for char-sized characters
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.20 2003/06/04 03:26:59 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.20 2003/06/04 03:26:59 millert Exp $";
d1555 1
a1555 1
			dlines = Lpp - (noscroll ? 1 : 2);
@


1.20
log
@o print screensize - 1 lines for each screenful, not screensize - 2.
o get rid of tailequ(); use __progname to see if we were invoked as page
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.19 2003/06/04 00:26:12 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.19 2003/06/04 00:26:12 millert Exp $";
d422 1
a422 1
	int c;
d442 3
a444 3
	c = Getc(f);
	*clearfirst = (c == '\f');
	Ungetc(c, f);
d500 1
a500 1
	int c;
d550 1
a550 1
		if ((c = Getc(f)) == EOF) {
d558 1
a558 1
		Ungetc(c, f);
d602 1
a602 1
	int c;
d604 2
a605 2
	while ((c = getc(f)) != EOF)
		putchar(c);
d651 1
a651 1
	int		c;
d658 2
a659 2
	c = Getc(f);
	if (colflg && c == '\n') {
d661 1
a661 1
		c = Getc(f);
d664 1
a664 1
		if (c == EOF) {
d673 1
a673 1
		if (c == '\n') {
d677 2
a678 2
		*p++ = c;
		if (c == '\t') {
d695 1
a695 1
		} else if (c == '\b' && column > 0)
d697 1
a697 1
		else if (c == '\r')
d699 1
a699 1
		else if (c == '\f' && stop_opt) {
d704 1
a704 1
		} else if (c == EOF) {
d707 1
a707 1
		} else if (c >= ' ' && c != RUBOUT)
d711 1
a711 1
		c = Getc(f);
d834 1
a834 1
	char c;
d944 2
a945 2
				while ((c = Getc(f)) != '\n') {
					if (c == EOF) {
d1336 1
a1336 1
	char c;
d1339 2
a1340 2
		while ((c = Getc(f)) != '\n') {
			if (c == EOF)
d1687 1
a1687 1
	char ch;
d1693 2
a1694 2
	while ((ch = *instr++) != '\0') {
		switch (ch) {
d1704 1
a1704 1
				*outstr++ = ch;
d1722 1
a1722 1
			*outstr++ = ch;
d1786 1
a1786 1
	char c;
d1790 3
a1792 3
	while ((c = Getc(f)) != '\n' && c != EOF && p - Line < LINSIZ - 1)
		*p++ = c;
	if (c == '\n')
@


1.19
log
@Check for alternate screen support and if it exists, don't print stuff
that would mess up the existing contents.  This fixes some ugliness
when running commands from more on an xterm.
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.17 2003/06/04 00:18:39 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.17 2003/06/04 00:18:39 millert Exp $";
d249 1
a249 1
		dlines = Lpp - (noscroll ? 1 : 2);
d571 4
a609 20
/*
 * See whether the last component of the path name "path" is equal to the
 * string "string".
 */
int
tailequ(char *path, char *string)
{
	char *tail;

	tail = path + strlen(path);
	while (tail >= path)
		if (*(--tail) == '/')
			break;
	++tail;
	while (*tail++ == *string++)
		if (*tail == '\0')
			return (1);
	return (0);
}

d905 1
a905 5
			if (!noscroll) {
				ret(dlines + 1);
			} else {
				ret(dlines);
			}
d1429 1
a1429 1
			if (tailequ(fnames[0], "page") ||
d1435 1
a1435 1
			eraseln = tgetstr("ce",&clearptr);
d1451 1
a1451 1
			if ((chUL = tgetstr("uc", &clearptr)) == NULL )
@


1.18
log
@Fix mergo that resulted in 2 copies of the handle_signal() function.
@
text
@d142 1
d1062 3
a1064 1
				printf("%s %s %s", p, cmdbuf, fnames[fnum]);
d1345 2
a1346 1
	fputs("------------------------\n", stdout);
d1502 3
@


1.17
log
@simplify some tty handling code:
o instead of otty and osavetty, use otty (original) and ntty (new)
o only call tcsetattr() from set_tty() and reset_tty()
o simplify set_tty() and reset_tty()
o use isatty() instead of tcgetattr() to see if stdin is a tty
o when we reset no_intty=0, also dup stderr -> stdin since stderr is a tty
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.16 2003/06/03 23:41:56 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.16 2003/06/03 23:41:56 millert Exp $";
a1511 68
}

int
handle_signal(int sig)
{
	int ch = -1;

	signo = 0;

	switch (sig) {
	case SIGQUIT:
		if (!inwait) {
			putchar('\n');
			if (startup)
				Pause++;
		} else if (!dum_opt && notell) {
			write(STDERR_FILENO, QUIT_IT,
			    sizeof(QUIT_IT) - 1);
			promptlen += sizeof(QUIT_IT) - 1;
			notell = 0;
		}
		break;
	case SIGTSTP:
	case SIGTTIN:
	case SIGTTOU:
		/* XXX - should use saved values instead of SIG_DFL */
		sa.sa_handler = SIG_DFL;
		sa.sa_flags = SA_RESTART;
		(void)sigaction(SIGTSTP, &sa, NULL);
		(void)sigaction(SIGTTIN, &sa, NULL);
		(void)sigaction(SIGTTOU, &sa, NULL);
		reset_tty();
		kill(getpid(), sig);

		sa.sa_handler = onsignal;
		sa.sa_flags = 0;
		(void)sigaction(SIGTSTP, &sa, NULL);
		(void)sigaction(SIGTTIN, &sa, NULL);
		(void)sigaction(SIGTTOU, &sa, NULL);
		set_tty();
		if (!no_intty)
			ch = '\f';	/* force redraw */
		break;
	case SIGINT:
		end_it();
		break;
	case SIGWINCH: {
		struct winsize win;

		if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) != 0)
			break;
		if (win.ws_row != 0) {
			Lpp = win.ws_row;
			nscroll = Lpp/2 - 1;
			if (nscroll <= 0)
				nscroll = 1;
			dlines = Lpp - (noscroll ? 1 : 2);
		}
		if (win.ws_col != 0)
			Mcol = win.ws_col;
		if (!no_intty)
			ch = '\f';	/* force redraw */
		break;
	} default:
		/* NOTREACHED */
		break;
	}
	return (ch);
@


1.16
log
@Eliminate setjmp/longjmp by using interruptible syscalls when reading input
from the user.  The signal handlers are now safe (they just set a flag).
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.15 2003/06/02 19:32:31 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.15 2003/06/02 19:32:31 millert Exp $";
d99 1
a99 1
struct termios	otty, osavetty;
d269 1
a269 1
		tcsetattr(STDERR_FILENO, TCSANOW, &otty);
d294 1
a1312 4
		if (!isatty(0)) {
			close(0);
			open(_PATH_TTY, 0);
		}
d1485 1
a1485 1
			Home = tgetstr("ho",&clearptr);
d1502 1
a1502 1
	no_intty = tcgetattr(STDIN_FILENO, &otty);
a1503 1
	osavetty = otty;
d1506 1
d1508 70
a1577 3
		otty.c_lflag &= ~(ICANON|ECHO);
		otty.c_cc[VMIN] = 1;
		otty.c_cc[VTIME] = 0;
d1579 1
d1848 1
a1848 4
	otty.c_lflag &= ~(ICANON|ECHO);
	otty.c_cc[VMIN] = 1;	/* read at least 1 char */
	otty.c_cc[VTIME] = 0;	/* no timeout */
	tcsetattr(STDERR_FILENO, TCSANOW, &otty);
d1861 1
a1861 4
	otty.c_lflag |= ICANON|ECHO;
	otty.c_cc[VMIN] = osavetty.c_cc[VMIN];
	otty.c_cc[VTIME] = osavetty.c_cc[VTIME];
	tcsetattr(STDERR_FILENO, TCSANOW, &osavetty);
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.14 2003/05/28 22:14:49 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.14 2003/05/28 22:14:49 millert Exp $";
a66 1
#include <setjmp.h>
a124 1
sigjmp_buf	restore;
d143 2
d154 1
d160 2
a162 1
void  chgwinsz(int);
a163 1
void  do_shell(char *);
d165 1
a165 1
void  end_it(int);
d173 1
a173 2
void  onquit(int);
void  onsusp(int);
a178 1
void  search(char *, FILE *, int);
a182 1
void  ttyin(char *, int, char);
d185 1
d203 5
d257 10
a266 5
		signal(SIGQUIT, onquit);
		signal(SIGINT, end_it);
		signal(SIGWINCH, chgwinsz);
		if (signal(SIGTSTP, SIG_IGN) == SIG_DFL) {
			signal(SIGTSTP, onsusp);
d287 1
a287 2
				search(initbuf, stdin, 1);
				if (noscroll)
d302 1
a302 2
			if (firstf)
				sigsetjmp(restore, 1);
d306 2
a307 1
					search(initbuf, f, 1);
d312 1
a312 3
			}
			else if (fnum < nfiles && !no_tty) {
				sigsetjmp(restore, 1);
a313 1
			}
a347 1
			sigsetjmp(restore, 1);
a556 1
		sigsetjmp(restore, 1);
a574 51
 * Come here if a quit signal is received.
 */
void
onquit(int dummy)
{
	int save_errno = errno;

	signal(SIGQUIT, SIG_IGN);
	if (!inwait) {
		putchar('\n');
		if (!startup) {
			signal(SIGQUIT, onquit);
			errno = save_errno;
			siglongjmp(restore, 1);
		} else
			Pause++;
	} else if (!dum_opt && notell) {
		write(STDERR_FILENO, QUIT_IT, sizeof(QUIT_IT) - 1);
		promptlen += sizeof(QUIT_IT) - 1;
		notell = 0;
	}
	signal(SIGQUIT, onquit);
	errno = save_errno;
}

/*
 * Come here if a signal for a window size change is received
 */
void
chgwinsz(int dummy)
{
	int save_errno = errno;
	struct winsize win;

	(void)signal(SIGWINCH, SIG_IGN);
	if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) != -1) {
		if (win.ws_row != 0) {
			Lpp = win.ws_row;
			nscroll = Lpp/2 - 1;
			if (nscroll <= 0)
				nscroll = 1;
			dlines = Lpp - (noscroll ? 1 : 2);
		}
		if (win.ws_col != 0)
			Mcol = win.ws_col;
	}
	(void)signal(SIGWINCH, chgwinsz);
	errno = save_errno;
}

/*
d578 1
a578 1
end_it(int dummy)
d939 1
a939 1
			end_it(0);
d1017 2
a1018 1
				search(NULL, f, nlines);
d1020 5
a1024 1
				ttyin(cmdbuf, sizeof(cmdbuf) - 2, '/');
d1026 2
a1027 1
				search(cmdbuf, f, nlines);
d1031 5
a1035 1
			do_shell(filename);
d1121 1
a1121 1
				end_it(0);
d1140 4
a1143 1
		do_shell(filename);
d1147 1
a1147 1
		end_it(0);
d1179 1
a1179 1
void
d1191 2
a1192 1
		ttyin(cmdbuf, sizeof(cmdbuf) - 2, '!');
d1208 1
a1208 1
void
d1230 1
d1233 1
a1233 1
	} else if (!initialized)
d1235 2
d1278 1
d1287 1
a1287 1
			end_it(0);
d1290 1
d1292 1
d1310 1
a1310 1
		sleep (5);
d1321 11
a1331 5
		signal(SIGINT, SIG_IGN);
		signal(SIGQUIT, SIG_IGN);
		if (catch_susp)
			signal(SIGTSTP, SIG_DFL);
		while(wait(0) > 0)
d1333 9
a1341 4
		signal(SIGINT, end_it);
		signal(SIGQUIT, onquit);
		if (catch_susp)
			signal(SIGTSTP, onsusp);
d1518 68
d1592 1
d1594 9
a1602 4
		if (errno != EINTR)
			end_it(0);
		else
			ch = otty.c_cc[VKILL];
d1617 1
a1617 1
void
d1645 1
a1645 1
				siglongjmp(restore, 1);
d1693 2
a1777 1
	siglongjmp(restore, 1);
d1820 1
a1820 1
 * Come here when we get a suspend signal from the terminal
d1823 1
a1823 1
onsusp(int dummy)
d1825 1
a1825 26
	int save_errno = errno;
	sigset_t mask, omask;

	/* ignore SIGTTOU so we don't get stopped if csh grabs the tty */
	signal(SIGTTOU, SIG_IGN);
	reset_tty();
	fflush(stdout);
	signal(SIGTTOU, SIG_DFL);
	/* Send the TSTP signal to suspend our process group */
	signal(SIGTSTP, SIG_DFL);

	/* unblock SIGTSTP or we won't be able to suspend ourself */
	sigemptyset(&mask);
	sigaddset(&mask, SIGTSTP);
	sigprocmask(SIG_UNBLOCK, &mask, &omask);

	kill(0, SIGTSTP);
	/* Pause for station break */

	/* We're back */
	sigprocmask(SIG_SETMASK, &omask, NULL);
	signal(SIGTSTP, onsusp);
	set_tty();
	errno = save_errno;
	if (inwait)
		siglongjmp(restore, 1);
@


1.14
log
@Fix ERASEONECHAR macro and BSB so we don't do sizeof(pointer).
Also remove some extraneous spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.13 2003/05/28 20:05:41 mickey Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.13 2003/05/28 20:05:41 mickey Exp $";
@


1.13
log
@even simpler help storage w/ a tweak from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.12 2003/05/28 19:25:18 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.12 2003/05/28 19:25:18 deraadt Exp $";
d964 1
a964 1
			if (! noscroll)
d1060 2
a1061 1
			if (nlines == 0) nlines++;
d1077 1
a1077 1
			do_shell (filename);
d1555 1
a1555 1
static char *BSB = "\b \b";
d1557 5
a1561 5
#define	ERASEONECHAR	do {				\
	if (docrterase)					\
		write(STDERR_FILENO, BSB, sizeof(BSB));	\
	else						\
		write(STDERR_FILENO, &BS, sizeof(BS));	\
d1596 3
a1598 3
				show (ch);
				putchar ('\n');
				putchar (pchar);
d1600 2
a1601 2
				putchar ('\r');
				putchar (pchar);
d1603 1
a1603 1
					erasep (1);
d1607 1
a1607 1
						    sizeof(BSB));
d1639 1
a1639 1
		error ("Line too long");
d1669 1
a1669 1
				error ("No previous command to substitute for");
@


1.12
log
@errno saving in signal handlers; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.11 2003/05/28 19:11:34 mickey Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.11 2003/05/28 19:11:34 mickey Exp $";
a101 1
const char *more_help[] = {
a102 2
	NULL
};
a903 1
	const char **q;
d1082 1
a1082 2
			for (q = more_help; *q; q++)
				puts(*q);
@


1.11
log
@help file incorporated, does not grow that much; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.10 2003/05/28 17:44:06 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.10 2003/05/28 17:44:06 millert Exp $";
d153 1
a153 1
    long chrctr, line;
d584 2
d591 1
d601 1
d610 1
d626 1
d760 1
a760 1
					     promptlen = 0;
d1551 3
a1553 3
                        end_it(0);
                else
                        ch = otty.c_cc[VKILL];
d1555 1
a1555 1
        return (ch);
d1775 2
a1776 1
    sigset_t mask, omask;
d1778 23
a1800 22
    /* ignore SIGTTOU so we don't get stopped if csh grabs the tty */
    signal(SIGTTOU, SIG_IGN);
    reset_tty();
    fflush(stdout);
    signal(SIGTTOU, SIG_DFL);
    /* Send the TSTP signal to suspend our process group */
    signal(SIGTSTP, SIG_DFL);

    /* unblock SIGTSTP or we won't be able to suspend ourself */
    sigemptyset(&mask);
    sigaddset(&mask, SIGTSTP);
    sigprocmask(SIG_UNBLOCK, &mask, &omask);

    kill(0, SIGTSTP);
    /* Pause for station break */

    /* We're back */
    sigprocmask(SIG_SETMASK, &omask, NULL);
    signal(SIGTSTP, onsusp);
    set_tty();
    if (inwait)
	    siglongjmp(restore, 1);
@


1.10
log
@o use _POSIX_VDISABLE instead of hard-coding 255
o call strlcpy() instead of doing the equivalent inline
o some cosmetic formatting changes
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.9 2003/05/28 16:42:50 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.9 2003/05/28 16:42:50 millert Exp $";
d79 1
a79 2

#include "pathnames.h"
d102 5
a898 1
	FILE *helpf;
d901 1
a1077 2
			if ((helpf = fopen(HELPFILE, "r")) == NULL)
				error("Can't open help file");
d1080 2
a1081 2
			copy_file(helpf);
			fclose(helpf);
@


1.9
log
@silence remaining gcc warning; now compiles -Wall clean
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.8 2003/05/28 16:41:24 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.8 2003/05/28 16:41:24 millert Exp $";
a195 1
	char		*p;
d217 1
a217 1
			argscan(*fnames+1);
d222 1
a222 5
				/* XXX - clean me (millert) */
				for (++s, p = initbuf;
				    p < initbuf + 79 && *s != '\0';)
					*p++ = *s++;
				*p = '\0';
d228 1
a228 1
						    initline * 10 + *s -'0';
d374 1
a374 1
			dlines = dlines*10 + *s - '0';
a409 1

d489 1
a489 1
#define STOP -10
d831 1
a831 1
			    wouldul(s+1, n-1)) {
d843 1
a843 1
				    wouldul(s, n-1))
d848 2
a849 1
			if (c != ' ' || pstate == 0 || state != 0 || ulglitch == 0)
d1064 1
a1064 1
				ttyin(cmdbuf, 78, '/');
d1385 2
a1386 2
 * Skip nskip files in the file list (from the command line). Nskip may be
 * negative.
d1428 2
a1429 2
		docrterase = (otty.c_cc[VERASE] != 255);
		docrtkill =  (otty.c_cc[VKILL] != 255);
@


1.8
log
@o Deal with EDITOR not being a fully-qualified pathname
o Silence a gcc warning
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.7 2003/05/28 01:09:11 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.7 2003/05/28 01:09:11 millert Exp $";
d194 1
a194 1
	FILE		*f;
@


1.7
log
@Shrink a bit by replacing custom functions w/ libc equivalents.
There is no reason for more to have its own private printf() clone.
Convert 3 one-line functions to macros and make the constant prompt
strings #defines too.
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.6 2003/05/28 00:04:20 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.6 2003/05/28 00:04:20 millert Exp $";
d744 1
a744 2
			/* XXX - grouping bug? (millert) */
			if (!hardtabs || column < promptlen && !hard) {
d1349 1
a1349 1
		execv(cmd, argp);
@


1.6
log
@o Some more KNF
o Check strlcpy() rval
o Fix hardtabs assignment
@
text
@d1 1
a1 1
/*	$OpenBSD: more.c,v 1.5 2003/05/27 23:47:36 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: more.c,v 1.5 2003/05/27 23:47:36 millert Exp $";
d88 4
d99 4
a160 3
int   pr(char *);
int   printd(int);
int   prtf(char *, ...);
a163 2
void  cleareol(void);
void  clreos(void);
a172 1
void  home(void);
a186 1
void  Sprintf(int);
d330 1
a330 1
					pr("::::::::::::::");
d333 1
a333 1
					prtf("\n");
d336 1
a336 1
					prtf("%s\n", fnames[fnum]);
d339 1
a339 1
					prtf("::::::::::::::\n");
d435 1
a435 1
		prtf("\n*** %s: directory ***\n\n", fs);
d476 2
a477 1
			prtf("\n******** %s: Not a text file ********\n\n", fs);
d487 1
a487 1
 * A real function (not a macro), for the tputs routine in termlib
d595 2
a596 2
		write(STDERR_FILENO, "[Use q or Q to quit]", 20);
		promptlen += 20;
d608 1
a608 1
    struct winsize win;
d610 13
a622 13
    (void)signal(SIGWINCH, SIG_IGN);
    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) != -1) {
	    if (win.ws_row != 0) {
		    Lpp = win.ws_row;
		    nscroll = Lpp/2 - 1;
		    if (nscroll <= 0)
			    nscroll = 1;
		    dlines = Lpp - (noscroll ? 1 : 2);
	    }
	    if (win.ws_col != 0)
		    Mcol = win.ws_col;
    }
    (void)signal(SIGWINCH, chgwinsz);
a652 81
/*
 * Simplified printf function...
 */
int
prtf (char *fmt, ...)
{
	va_list ap;
	char ch;
	int ccount;

	ccount = 0;
	va_start(ap, fmt);
	while (*fmt) {
		while ((ch = *fmt++) != '%') {
			if (ch == '\0')
				return (ccount);
			ccount++;
			putchar(ch);
		}
		switch (*fmt++) {
		case 'd':
			ccount += printd(va_arg(ap, int));
			break;
		case 's':
			ccount += pr(va_arg(ap, char *));
			break;
		case '%':
			ccount++;
			putchar('%');
			break;
		case '0':
			return (ccount);
		default:
			break;
		}
	}
	va_end(ap);
	return (ccount);

}

/*
 * Print an integer as a string of decimal digits,
 * returning the length of the print representation.
 */
int
printd(int n)
{
	int a, nchars;

	if ((a = n / 10) != 0)
		nchars = 1 + printd(a);
	else
		nchars = 1;
	putchar(n % 10 + '0');
	return (nchars);
}

static char *sptr;	/* shared between scanstr() and Sprintf() */

/*
 * Put the print representation of an integer into a string.
 */
void
scanstr(int n, char *str)
{
	sptr = str;
	Sprintf(n);
	*sptr = '\0';
}

void
Sprintf(int n)
{
    int a;

    if ((a = n / 10) != 0)
	Sprintf(a);
    *sptr++ = n % 10 + '0';
}

d690 1
a690 1
		pr("--More--");
d692 1
a692 1
			promptlen += prtf ("(Next file: %s)", filename);
d694 1
a694 1
			promptlen += prtf ("(%d%%)",
d696 4
a699 3
		if (dum_opt)
			promptlen +=
			    pr("[Press space to continue, 'q' to quit.]");
a823 30
 * Force clear to end of line
 */
void
cleareol(void)
{
	tputs(eraseln, 1, putch);
}

void
clreos(void)
{
	tputs(EodClr, 1, putch);
}

/*
 *  Print string and return number of characters
 */
int
pr(char *s1)
{
    char	*s;
    char	c;

    for (s = s1; (c = *s++) != '\0'; )
	    putchar(c);
    return (s - s1 - 1);
}


/*
d858 1
a858 1
				pr(chBS);
a883 9
/*
 * Go to home position
 */
void
home(void)
{
	tputs(Home, 1, putch);
}

d950 1
a950 1
			prtf("\n");
d953 1
a953 1
			prtf("...back %d page", nlines);
d955 1
a955 1
				pr("s\n");
d957 1
a957 1
				pr("\n");
d961 1
a961 1
			pr("\n");
d1000 1
a1000 1
			prtf ("\n");
d1003 1
a1003 1
			prtf ("...skipping %d line", nlines);
d1005 1
a1005 1
				pr("s\n");
d1007 1
a1007 1
				pr("\n");
d1011 1
a1011 1
			pr("\n");
d1044 1
a1044 1
				pr("\n***Back***\n\n");
d1054 1
a1054 1
			promptlen = printd(Currline);
d1062 1
a1062 1
			pr("/");
d1102 3
a1104 7
				cmdbuf[0] = '+';
				scanstr(Currline - dlines < 0 ? 0 :
				    Currline - (dlines + 1) / 2, &cmdbuf[1]);
				pr("vi ");
				pr(cmdbuf);
				putchar(' ');
				pr(fnames[fnum]);
d1114 3
a1116 3
					promptlen =
					    pr("[Press 'h' for instructions.]")
					    + (2 * soglitch);
d1118 4
a1121 3
				} else
					promptlen =
					    pr("[Press 'h' for instructions.]");
d1156 2
a1157 1
			promptlen = prtf("\"%s\" line %d", fnames[fnum], Currline);
d1159 1
a1159 1
			promptlen = prtf("[Not a file] line %d", Currline);
d1226 1
a1226 1
	pr("!");
d1230 1
a1230 1
		pr(shell_line);
d1232 1
a1232 1
		ttyin(cmdbuf, sizeof(cmdbuf)-2, '!');
d1235 1
a1235 1
			promptlen = prtf ("!%s", shell_line);
d1283 1
a1283 1
					pr("\n");
d1286 1
a1286 1
					pr("...skipping\n");
d1307 1
a1307 1
					pr(Line);
d1322 2
a1323 2
			pr ("\nPattern not found\n");
			end_it (0);
d1368 1
a1368 1
	pr("------------------------\n");
d1408 1
a1408 2
	pr("\n...Skipping ");
	pr("\n");
d1411 2
a1412 4
	pr("...Skipping ");
	pr(nskip > 0 ? "to file " : "back to file ");
	pr(fnames[fnum]);
	pr("\n");
d1415 1
a1415 1
	pr ("\n");
d1719 1
a1719 1
		pr(mess);
d1722 1
a1722 1
		pr(mess);
@


1.5
log
@KNF this sucka + some -Wall cleanage
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD$";
d60 1
d62 1
a63 2
#include <sys/file.h>
#include <sys/exec.h>
d65 1
d79 1
d82 3
a84 3
#define Fopen(s,m)	(Currline = 0,file_pos=0,fopen(s,m))
#define Ftell(f)	file_pos
#define Fseek(f,off)	(file_pos=off,fseek(f,off,0))
d88 2
a89 2
#define TBUFSIZ	1024
#define LINSIZ	256
d91 3
a93 3
#define RUBOUT	'\177'
#define ESC	'\033'
#define QUIT	'\034'
d95 1
a95 1
struct termios	otty, savetty0;
d113 2
a114 2
int		within;	/* true if we are within a file,
			false if we are between files */
d127 1
a127 1
char		*ULenter, *ULexit;	/* enter and exit underline mode */
d139 1
a142 2
extern char	PC;		/* pad character */
extern char	*__progname;
d144 43
a186 35
int  magic(FILE *, char *);
void initterm(void);
void kill_line(void);
void doclear(void);
void cleareol(void);
void clreos(void);
void home(void);
void error(char *);
void do_shell(char *);
int  colon(char *, int, int);
int  expand(char *, size_t, char *);
void argscan(char *);
void rdline(FILE *);
void copy_file(FILE *);
void search(char *, FILE *, int);
void skipf(int);
void skiplns(int, FILE *);
void screen(FILE *, int);
int  command(char *, FILE *);
void erasep(int);
void show(int);
int  pr(char *);
int  printd(int);
void putch(int);
void set_tty(void);
void reset_tty(void);
void ttyin(char *, int, char);
int  number(char *);
int  readch(void);
int  get_line(FILE *, int *);
void prbuf(char *, int);
int  prtf(char *, ...);
void execute(char *filename, char *cmd, char *, char *, char *);
void errwrite(char *);
void errwrite1(char *);
a187 6
void chgwinsz(int);
void end_it(int);
void onquit(int);
void onsusp(int);
void Sprintf(int);
int  getline(FILE *, int *);
d1352 1
a1352 1
		if (expand(shell_line, sizeof shell_line, cmdbuf)) {
d1370 1
a1370 1
	long startline = Ftell (file);
d1396 1
a1396 1
		line1 = Ftell (file);
d1652 1
a1652 1
	savetty0 = otty;
d1654 1
a1654 3
#if 0
	hardtabs = (otty.c_oflag & TABDLY) != OXTABS;
#endif
d1769 1
d1782 1
a1782 1
				strlcpy(outstr, fnames[fnum],
d1784 3
a1786 1
				outstr += strlen (fnames[fnum]);
d1794 1
a1794 2
			/* XXX - use strlcpy() rval (millert) */
			strlcpy(outstr, shell_line,
d1796 3
a1798 1
			outstr += strlen(shell_line);
d1870 3
a1872 3
	otty.c_cc[VMIN] = savetty0.c_cc[VMIN];
	otty.c_cc[VTIME] = savetty0.c_cc[VTIME];
	tcsetattr(STDERR_FILENO, TCSANOW, &savetty0);
d1876 1
a1876 1
rdline (FILE *f)
@


1.4
log
@more(1) now uses POSIX regex, no more ned for -lcompat; deraadt@@ OK
@
text
@d1 2
d43 1
d45 3
d51 7
a57 7
** more.c - General purpose tty output filter and file perusal program
**
**	by Eric Shienbrood, UC Berkeley
**
**	modified by Geoff Peck, UCB to add underlining, single spacing
**	modified by John Foderaro, UCB to add -c and MORE environment variable
*/
d64 1
a85 2
#define stty(fd,argp)	tcsetattr(fd,TCSANOW,argp)

d143 1
d184 1
d190 45
a234 40
    FILE		*f;
    char		*s;
    char		*p;
    int			left;
    int			prnames = 0;
    int			initopt = 0;
    int			srchopt = 0;
    int			clearit = 0;
    int			initline;
    int			ch;
    char		initbuf[80];

    setlocale(LC_ALL, "");

    nfiles = argc;
    fnames = argv;
    initterm ();
    nscroll = Lpp/2 - 1;
    if (nscroll <= 0)
	nscroll = 1;
    if((s = getenv("MORE")) && *s) argscan(s);
    while (--nfiles > 0) {
	if ((ch = (*++fnames)[0]) == '-') {
	    argscan(*fnames+1);
	}
	else if (ch == '+') {
	    s = *fnames;
	    if (*++s == '/') {
		srchopt++;
		for (++s, p = initbuf; p < initbuf + 79 && *s != '\0';)
		    *p++ = *s++;
		*p = '\0';
	    }
	    else {
		initopt++;
		for (initline = 0; *s != '\0'; s++)
		    if (isdigit (*s))
			initline = initline*10 + *s -'0';
		--initline;
	    }
d236 10
a245 29
	else break;
    }
    /* allow clreol only if Home and eraseln and EodClr strings are
     *  defined, and in that case, make sure we are in noscroll mode
     */
    if(clreol)
    {
        if((Home == NULL) || (*Home == '\0') ||
	   (eraseln == NULL) || (*eraseln == '\0') ||
           (EodClr == NULL) || (*EodClr == '\0') )
	      clreol = 0;
	else noscroll = 1;
    }
    if (dlines == 0)
	dlines = Lpp - (noscroll ? 1 : 2);
    left = dlines;
    if (nfiles > 1)
	prnames++;
    if (!no_intty && nfiles == 0)
	usage();
    else
	f = stdin;
    if (!no_tty) {
	signal(SIGQUIT, onquit);
	signal(SIGINT, end_it);
	signal(SIGWINCH, chgwinsz);
	if (signal (SIGTSTP, SIG_IGN) == SIG_DFL) {
	    signal(SIGTSTP, onsusp);
	    catch_susp++;
d247 16
a262 74
	stty (fileno(stderr), &otty);
    }
    if (no_intty) {
	if (no_tty)
	    copy_file (stdin);
	else {
	    if ((ch = Getc (f)) == '\f')
		doclear();
	    else {
		Ungetc (ch, f);
		if (noscroll && (ch != EOF)) {
		    if (clreol)
			home ();
		    else
			doclear ();
		}
	    }
	    if (srchopt)
	    {
		search (initbuf, stdin, 1);
		if (noscroll)
		    left--;
	    }
	    else if (initopt)
		skiplns (initline, stdin);
	    screen (stdin, left);
	}
	no_intty = 0;
	prnames++;
	firstf = 0;
    }

    while (fnum < nfiles) {
	if ((f = checkf (fnames[fnum], &clearit)) != NULL) {
	    context.line = context.chrctr = 0;
	    Currline = 0;
	    if (firstf) sigsetjmp (restore, 1);
	    if (firstf) {
		firstf = 0;
		if (srchopt)
		{
		    search (initbuf, f, 1);
		    if (noscroll)
			left--;
		}
		else if (initopt)
		    skiplns (initline, f);
	    }
	    else if (fnum < nfiles && !no_tty) {
		sigsetjmp (restore, 1);
		left = command (fnames[fnum], f);
	    }
	    if (left != 0) {
		if ((noscroll || clearit) && (file_size != LONG_MAX)) {
		    if (clreol)
			home ();
		    else
			doclear ();
		}
		if (prnames) {
		    if (bad_so)
			erasep (0);
		    if (clreol)
			cleareol ();
		    pr("::::::::::::::");
		    if (promptlen > 14)
			erasep (14);
		    prtf ("\n");
		    if(clreol) cleareol();
		    prtf("%s\n", fnames[fnum]);
		    if(clreol) cleareol();
		    prtf("::::::::::::::\n");
		    if (left > Lpp - 4)
			left = Lpp - 4;
d264 3
d268 1
a268 1
		    copy_file (f);
d270 18
a287 3
		    within++;
		    screen(f, left);
		    within = 0;
d289 66
a354 6
	    }
	    sigsetjmp (restore, 1);
	    fflush(stdout);
	    fclose(f);
	    screen_start.line = screen_start.chrctr = 0L;
	    context.line = context.chrctr = 0L;
d356 2
a357 5
	fnum++;
	firstf = 0;
    }
    reset_tty ();
    exit(0);
d367 4
a370 4
		  case '0': case '1': case '2':
		  case '3': case '4': case '5':
		  case '6': case '7': case '8':
		  case '9':
d377 1
a377 1
		  case 'd':
d380 1
a380 1
		  case 'l':
d383 1
a383 1
		  case 'f':
d386 1
a386 1
		  case 'p':
d389 1
a389 1
		  case 'c':
d392 1
a392 1
		  case 's':
d395 1
a395 1
		  case 'u':
d398 3
a400 1
		  case '-': case ' ': case '\t':
d402 1
a402 1
		  default:
d404 1
a404 1
			    __progname);
d413 3
a415 4
** Check whether the file named by fs is an ASCII file which the user may
** access.  If it is, return the opened file. Otherwise return NULL.
*/

d417 1
a417 1
checkf (char *fs, int *clearfirst)
d420 1
a420 1
	register FILE *f;
d423 1
a423 1
	if (stat (fs, &stbuf) == -1) {
d426 1
a426 1
			cleareol ();
d428 1
a428 1
		return((FILE *)NULL);
d432 1
a432 1
		return((FILE *)NULL);
d437 1
a437 1
		return((FILE *)NULL);
d440 1
a440 1
		return((FILE *)NULL);
d442 2
a443 2
	*clearfirst = c == '\f';
	Ungetc (c, f);
d446 1
a446 1
	return(f);
d451 1
a451 1
 *	check for file magic numbers.  This code would best be shared with
d461 1
a461 1
		return(0);
d474 1
a474 1
			return(1);
d478 1
a478 1
	return(0);
d482 2
a483 3
** A real function, for the tputs routine in termlib
*/

d485 1
a485 1
putch (int ch)
d487 1
a487 1
    putchar (ch);
a489 4
/*
** Print out the contents of the file f, one screenful at a time.
*/

d492 3
d496 1
a496 1
screen (FILE *f, int num_lines)
d498 74
a571 40
    int c;
    int nchars;
    int length;			/* length of current line */
    static int prev_len = 1;	/* length of previous line */

    for (;;) {
	while (num_lines > 0 && !Pause) {
	    if ((nchars = getline (f, &length)) == EOF)
	    {
		if (clreol)
		    clreos();
		return;
	    }
	    if (ssp_opt && length == 0 && prev_len == 0)
		continue;
	    prev_len = length;
	    if (bad_so || (Senter && *Senter == ' ' && promptlen > 0))
		erasep (0);
	    /* must clear before drawing line since tabs on some terminals
	     * do not erase what they tab over.
	     */
	    if (clreol)
		cleareol ();
	    prbuf (Line, length);
	    if (nchars < promptlen)
		erasep (nchars);	/* erasep () sets promptlen to 0 */
	    else promptlen = 0;
	    /* is this needed?
	     * if (clreol)
	     *	cleareol();	/* must clear again in case we wrapped *
	     */
	    if (nchars < Mcol || !fold_opt)
		prbuf("\n", 1);	/* will turn off UL if necessary */
	    if (nchars == STOP)
		break;
	    num_lines--;
	}
	if (pstate) {
		tputs(ULexit, 1, putch);
		pstate = 0;
a572 27
	fflush(stdout);
	if ((c = Getc(f)) == EOF)
	{
	    if (clreol)
		clreos ();
	    return;
	}

	if (Pause && clreol)
	    clreos ();
	Ungetc (c, f);
	sigsetjmp (restore, 1);
	Pause = 0; startup = 0;
	if ((num_lines = command (NULL, f)) == 0)
	    return;
	if (hard && promptlen > 0)
		erasep (0);
	if (noscroll && num_lines >= dlines)
	{
	    if (clreol)
		home();
	    else
		doclear ();
	}
	screen_start.line = Currline;
	screen_start.chrctr = Ftell (f);
    }
d576 2
a577 3
** Come here if a quit signal is received
*/

d579 1
a579 1
onquit(int signo)
d581 12
a592 6
    signal(SIGQUIT, SIG_IGN);
    if (!inwait) {
	putchar ('\n');
	if (!startup) {
	    signal(SIGQUIT, onquit);
	    siglongjmp (restore, 1);
d594 1
a594 9
	else
	    Pause++;
    }
    else if (!dum_opt && notell) {
	write (STDERR_FILENO, "[Use q or Q to quit]", 20);
	promptlen += 20;
	notell = 0;
    }
    signal(SIGQUIT, onquit);
d598 2
a599 3
** Come here if a signal for a window size change is received
*/

d601 1
a601 1
chgwinsz(int signo)
d605 11
a615 11
    (void) signal(SIGWINCH, SIG_IGN);
    if (ioctl(fileno(stdout), TIOCGWINSZ, &win) != -1) {
	if (win.ws_row != 0) {
	    Lpp = win.ws_row;
	    nscroll = Lpp/2 - 1;
	    if (nscroll <= 0)
		nscroll = 1;
	    dlines = Lpp - (noscroll ? 1 : 2);
	}
	if (win.ws_col != 0)
	    Mcol = win.ws_col;
d617 1
a617 1
    (void) signal(SIGWINCH, chgwinsz);
d621 2
a622 3
** Clean up terminal state and exit. Also come here if interrupt signal received
*/

d624 1
a624 1
end_it(int signo)
d626 11
a636 14

    reset_tty ();
    if (clreol) {
	putchar ('\r');
	clreos ();
	fflush (stdout);
    }
    else if (!clreol && (promptlen > 0)) {
	kill_line ();
	fflush (stdout);
    }
    else
	write (STDERR_FILENO, "\n", 1);
    _exit(0);
d642 1
a642 1
    int c;
d644 2
a645 2
    while ((c = getc(f)) != EOF)
	putchar(c);
d648 3
a650 2
/* Simplified printf function */

d665 1
a665 1
			putchar (ch);
d669 1
a669 1
			ccount += printd (va_arg(ap, int));
d672 1
a672 1
			ccount += pr (va_arg(ap, char *));
d676 1
a676 1
			putchar ('%');
d690 3
a692 4
** Print an integer as a string of decimal digits,
** returning the length of the print representation.
*/

d696 1
a696 1
    int a, nchars;
d698 6
a703 6
    if ((a = n/10) != 0)
	nchars = 1 + printd(a);
    else
	nchars = 1;
    putchar (n % 10 + '0');
    return (nchars);
d706 1
a706 2
/* Put the print representation of an integer into a string */
static char *sptr;
d708 3
d714 3
a716 3
    sptr = str;
    Sprintf (n);
    *sptr = '\0';
d724 2
a725 2
    if ((a = n/10) != 0)
	Sprintf (a);
d731 4
a734 4
/* See whether the last component of the path name "path" is equal to the
** string "string"
*/

d736 1
a736 1
tailequ (char *path, char *string)
d747 2
a748 2
			return(1);
	return(0);
a753 10
    if (clreol)
	cleareol ();
    else if (promptlen > 0)
	kill_line ();
    if (!hard) {
	promptlen = 8;
	if (Senter && Sexit) {
	    tputs (Senter, 1, putch);
	    promptlen += (2 * soglitch);
	}
d755 28
a782 20
	    cleareol ();
	pr("--More--");
	if (filename != NULL) {
	    promptlen += prtf ("(Next file: %s)", filename);
	}
	else if (!no_intty) {
	    promptlen += prtf ("(%d%%)", (int)((file_pos * 100) / file_size));
	}
	if (dum_opt) {
	    promptlen += pr("[Press space to continue, 'q' to quit.]");
	}
	if (Senter && Sexit)
	    tputs (Sexit, 1, putch);
	if (clreol)
	    clreos ();
	fflush(stdout);
    }
    else
	write (STDERR_FILENO, &bell, 1);
    inwait++;
d786 2
a787 3
** Get a logical line
*/

d791 21
a811 33
    int		c;
    char	*p;
    int		column;
    static int	colflg;

    p = Line;
    column = 0;
    c = Getc (f);
    if (colflg && c == '\n') {
	Currline++;
	c = Getc (f);
    }
    while (p < &Line[LINSIZ - 1]) {
	if (c == EOF) {
	    if (p > Line) {
		*p = '\0';
		*length = p - Line;
		return (column);
	    }
	    *length = p - Line;
	    return (EOF);
	}
	if (c == '\n') {
	    Currline++;
	    break;
	}
	*p++ = c;
	if (c == '\t')
	    if (!hardtabs || column < promptlen && !hard) {
		if (hardtabs && eraseln && !dumb) {
		    column = 1 + (column | 7);
		    tputs (eraseln, 1, putch);
		    promptlen = 0;
d813 3
a815 7
		else {
		    for (--p; p < &Line[LINSIZ - 1];) {
			*p++ = ' ';
			if ((++column & 7) == 0)
			    break;
		    }
		    if (column >= promptlen) promptlen = 0;
d817 36
a852 25
	    }
	    else
		column = 1 + (column | 7);
	else if (c == '\b' && column > 0)
	    column--;
	else if (c == '\r')
	    column = 0;
	else if (c == '\f' && stop_opt) {
		p[-1] = '^';
		*p++ = 'L';
		column += 2;
		Pause++;
	}
	else if (c == EOF) {
	    *length = p - Line;
	    return (column);
	}
	else if (c >= ' ' && c != RUBOUT)
	    column++;
	if (column >= Mcol && fold_opt) break;
	c = Getc (f);
    }
    if (column >= Mcol && Mcol > 0) {
	if (!Wrap) {
	    *p++ = '\n';
d854 8
a861 8
    }
    colflg = column == Mcol && fold_opt;
    if (colflg && eatnl && Wrap) {
	*p++ = '\n'; /* simulate normal wrap */
    }
    *length = p - Line;
    *p = 0;
    return (column);
d865 2
a866 3
** Erase the rest of the prompt, assuming we are starting at column col.
*/

d870 15
a884 16

    if (promptlen == 0)
	return;
    if (hard) {
	putchar ('\n');
    }
    else {
	if (col == 0)
	    putchar ('\r');
	if (!dumb && eraseln)
	    tputs (eraseln, 1, putch);
	else
	    for (col = promptlen - col; col > 0; col--)
		putchar (' ');
    }
    promptlen = 0;
d888 2
a889 3
** Erase the current line entirely
*/

d893 3
a895 3
    erasep (0);
    if (!eraseln || dumb)
	putchar ('\r');
d899 1
a899 1
 * force clear to end of line
d904 1
a904 1
    tputs(eraseln, 1, putch);
d910 1
a910 1
    tputs(EodClr, 1, putch);
d914 2
a915 3
**  Print string and return number of characters
*/

d922 2
a923 2
    for (s = s1; c = *s++; )
	putchar(c);
d928 3
a930 2
/* Print a buffer of n characters */

d934 2
a935 2
    char c;			/* next output character */
    int state;			/* next output char's UL state */
d938 30
a967 27
    while (--n >= 0)
	if (!ul_opt)
	    putchar (*s++);
	else {
	    if (*s == ' ' && pstate == 0 && ulglitch && wouldul(s+1, n-1)) {
		s++;
		continue;
	    }
	    if (state = wouldul(s, n)) {
		c = (*s == '_')? s[2] : *s ;
		n -= 2;
		s += 3;
	    } else
		c = *s++;
	    if (state != pstate) {
		if (c == ' ' && state == 0 && ulglitch && wouldul(s, n-1))
		    state = 1;
		else
		    tputs(state ? ULenter : ULexit, 1, putch);
	    }
	    if (c != ' ' || pstate == 0 || state != 0 || ulglitch == 0)
	        putchar(c);
	    if (state && *chUL) {
		pr(chBS);
		tputs(chUL, 1, putch);
	    }
	    pstate = state;
d972 2
a973 3
**  Clear the screen
*/

d977 2
a978 2
    if (Clear && !hard) {
	tputs(Clear, 1, putch);
d980 7
a986 6
	/* Put out carriage return so that system doesn't
	** get confused by escape sequences when expanding tabs
	*/
	putchar ('\r');
	promptlen = 0;
    }
d995 1
a995 1
    tputs(Home,1,putch);
d1003 15
a1017 17
** Read a command and do it. A command consists of an optional integer
** argument followed by the command character.  Return the number of lines
** to display in the next screenful.  If there is nothing more to display
** in the current file, zero is returned.
*/

command (filename, f)
char *filename;
register FILE *f;
{
    register int nlines;
    register int retval;
    register char c;
    char colonch;
    FILE *helpf;
    int done;
    char comchar, cmdbuf[80], *p;
d1021 32
a1052 32
    done = 0;
    if (!errors)
	prompt (filename);
    else
	errors = 0;
    for (;;) {
	nlines = number (&comchar);
	lastp = colonch = 0;
	if (comchar == '.') {	/* Repeat last command */
		lastp++;
		comchar = lastcmd;
		nlines = lastarg;
		if (lastcmd == ':')
			colonch = lastcolon;
	}
	lastcmd = comchar;
	lastarg = nlines;
	if (comchar == otty.c_cc[VERASE]) {
	    kill_line ();
	    prompt (filename);
	    continue;
	}
	switch (comchar) {
	case ':':
	    retval = colon (filename, colonch, nlines);
	    if (retval >= 0)
		done++;
	    break;
	case 'b':
	case ctrl('B'):
	    {
		register int initline;
d1054 4
a1057 4
		if (no_intty) {
		    write(STDERR_FILENO, &bell, 1);
		    return (-1);
		}
d1059 2
a1060 1
		if (nlines == 0) nlines++;
d1062 10
a1071 10
		putchar ('\r');
		erasep (0);
		prtf ("\n");
		if (clreol)
			cleareol ();
		prtf ("...back %d page", nlines);
		if (nlines > 1)
			pr ("s\n");
		else
			pr ("\n");
d1073 3
a1075 3
		if (clreol)
			cleareol ();
		pr ("\n");
d1077 13
a1089 52
		initline = Currline - dlines * (nlines + 1);
		if (! noscroll)
		    --initline;
		if (initline < 0) initline = 0;
		Fseek(f, 0L);
		Currline = 0;	/* skiplns() will make Currline correct */
		skiplns(initline, f);
		if (! noscroll) {
		    ret(dlines + 1);
		}
		else {
		    ret(dlines);
		}
	    }
	case ' ':
	case 'z':
	    if (nlines == 0) nlines = dlines;
	    else if (comchar == 'z') dlines = nlines;
	    ret (nlines);
	case 'd':
	case ctrl('D'):
	    if (nlines != 0) nscroll = nlines;
	    ret (nscroll);
	case 'q':
	case 'Q':
	    end_it (0);
	case 's':
	case 'f':
	    if (nlines == 0) nlines++;
	    if (comchar == 'f')
		nlines *= dlines;
	    putchar ('\r');
	    erasep (0);
	    prtf ("\n");
	    if (clreol)
		cleareol ();
	    prtf ("...skipping %d line", nlines);
	    if (nlines > 1)
		pr ("s\n");
	    else
		pr ("\n");

	    if (clreol)
		cleareol ();
	    pr ("\n");

	    while (nlines > 0) {
		while ((c = Getc (f)) != '\n')
		    if (c == EOF) {
			retval = 0;
			done++;
			goto endsw;
d1091 152
a1242 96
		    Currline++;
		    nlines--;
	    }
	    ret (dlines);
	case '\n':
	    if (nlines != 0)
		dlines = nlines;
	    else
		nlines = 1;
	    ret (nlines);
	case '\f':
	    if (!no_intty) {
		doclear ();
		Fseek (f, screen_start.chrctr);
		Currline = screen_start.line;
		ret (dlines);
	    }
	    else {
		write (STDERR_FILENO, &bell, 1);
		break;
	    }
	case '\'':
	    if (!no_intty) {
		kill_line ();
		pr ("\n***Back***\n\n");
		Fseek (f, context.chrctr);
		Currline = context.line;
		ret (dlines);
	    }
	    else {
		write (STDERR_FILENO, &bell, 1);
		break;
	    }
	case '=':
	    kill_line ();
	    promptlen = printd (Currline);
	    fflush (stdout);
	    break;
	case 'n':
	    lastp++;
	case '/':
	    if (nlines == 0) nlines++;
	    kill_line ();
	    pr ("/");
	    promptlen = 1;
	    fflush (stdout);
	    if (lastp) {
		write (STDERR_FILENO, "\r", 1);
		search (NULL, f, nlines);	/* Use previous r.e. */
	    }
	    else {
		ttyin (cmdbuf, 78, '/');
		write (STDERR_FILENO, "\r", 1);
		search (cmdbuf, f, nlines);
	    }
	    ret (dlines-1);
	case '!':
	    do_shell (filename);
	    break;
	case '?':
	case 'h':
	    if ((helpf = fopen (HELPFILE, "r")) == NULL)
		error ("Can't open help file");
	    if (noscroll) doclear ();
	    copy_file (helpf);
	    fclose (helpf);
	    prompt (filename);
	    break;
	case 'v':	/* This case should go right before default */
	    if (!no_intty) {
		char *editor;

		editor = getenv("VISUAL");
		if (editor == NULL || *editor == '\0')
			editor = getenv("EDITOR");
		if (editor == NULL || *editor == '\0')
			editor = _PATH_VI;
		if ((p = strrchr(editor, '/')) != NULL)
			p++;
		else
			p = editor;
		kill_line ();
		cmdbuf[0] = '+';
		scanstr (Currline - dlines < 0 ? 0
				: Currline - (dlines + 1) / 2, &cmdbuf[1]);
		pr ("vi "); pr (cmdbuf); putchar (' '); pr (fnames[fnum]);
		execute (filename, editor, p, cmdbuf, fnames[fnum]);
		break;
	    }
	default:
	    if (dum_opt) {
   		kill_line ();
		if (Senter && Sexit) {
		    tputs (Senter, 1, putch);
		    promptlen = pr ("[Press 'h' for instructions.]") + (2 * soglitch);
		    tputs (Sexit, 1, putch);
d1244 2
a1245 7
		else
		    promptlen = pr ("[Press 'h' for instructions.]");
		fflush (stdout);
	    }
	    else
		write (STDERR_FILENO, &bell, 1);
	    break;
d1247 1
a1247 3
	if (done) break;
    }
    putchar ('\r');
d1249 3
a1251 3
    inwait = 0;
    notell++;
    return (retval);
a1253 2
int ch;

d1259 4
a1263 2
colon (char *filename, int cmd, int nlines)
{
d1265 1
a1265 1
		ch = readch ();
d1271 1
a1271 1
		kill_line ();
d1273 1
a1273 1
			promptlen = prtf ("\"%s\" line %d", fnames[fnum], Currline);
d1275 2
a1276 2
			promptlen = prtf ("[Not a file] line %d", Currline);
		fflush (stdout);
d1281 1
a1281 1
				end_it (0);
d1284 3
a1286 3
		putchar ('\r');
		erasep (0);
		skipf (nlines);
d1290 1
a1290 1
			write (STDERR_FILENO, &bell, 1);
d1293 2
a1294 2
		putchar ('\r');
		erasep (0);
d1300 1
a1300 1
		do_shell (filename);
d1304 1
a1304 1
		end_it (0);
d1306 1
a1306 1
		write (STDERR_FILENO, &bell, 1);
d1312 5
a1316 6
** Read a decimal number from the terminal. Set cmd to the non-digit which
** terminates the number.
*/

number(cmd)
char *cmd;
d1318 1
a1318 1
	register int i;
d1320 2
a1321 1
	i = 0; ch = otty.c_cc[VKILL];
d1323 1
a1323 1
		ch = readch ();
d1337 1
a1337 1
do_shell (char *filename)
d1341 3
a1343 3
	kill_line ();
	pr ("!");
	fflush (stdout);
d1346 1
a1346 1
		pr (shell_line);
d1348 3
a1350 3
		ttyin (cmdbuf, sizeof(cmdbuf)-2, '!');
		if (expand (shell_line, sizeof shell_line, cmdbuf)) {
			kill_line ();
d1354 2
a1355 2
	fflush (stdout);
	write (STDERR_FILENO, "\n", 1);
d1358 1
a1358 1
	execute (filename, shell, shell, "-c", shell_line);
d1362 2
a1363 3
** Search for nth ocurrence of regular expression contained in buf in the file
*/

d1365 66
a1430 65
search (char *buf, FILE *file, int n)
{
    long startline = Ftell (file);
    register long line1 = startline;
    register long line2 = startline;
    register long line3 = startline;
    register int lncount;
    int saveln, rv;
    char ebuf[BUFSIZ];
    static regex_t reg;
    static int initialized;

    context.line = saveln = Currline;
    context.chrctr = startline;
    lncount = 0;
    if (buf != NULL && *buf != '\0') {
	if ((rv = regcomp(&reg, buf, REG_NOSUB)) != 0) {
	    initialized = 0;
	    regerror(rv, &reg, ebuf, sizeof(ebuf));
	    regfree(&reg);
	    error(ebuf);
	}
	initialized = 1;
    } else if (!initialized) {
	error("No previous regular expression");
    }
    while (!feof (file)) {
	line3 = line2;
	line2 = line1;
	line1 = Ftell (file);
	rdline (file);
	lncount++;
	if ((rv = regexec(&reg, Line, 0, NULL, 0)) == 0) {
		if (--n == 0) {
		    if (lncount > 3 || (lncount > 1 && no_intty))
		    {
			pr ("\n");
			if (clreol)
			    cleareol ();
			pr("...skipping\n");
		    }
		    if (!no_intty) {
			Currline -= (lncount >= 3 ? 3 : lncount);
			Fseek (file, line3);
			if (noscroll)
			    if (clreol) {
				home ();
				cleareol ();
			    }
			    else
				doclear ();
		    }
		    else {
			kill_line ();
			if (noscroll)
			    if (clreol) {
			        home ();
			        cleareol ();
			    }
			    else
				doclear ();
			pr (Line);
			putchar ('\n');
		    }
		    break;
a1431 3
	} else if (rv != REG_NOMATCH) {
	    regerror(rv, &reg, ebuf, sizeof(ebuf));
	    error(ebuf);
d1433 9
a1441 9
    }
    if (feof (file)) {
	if (!no_intty) {
	    Currline = saveln;
	    Fseek (file, startline);
	}
	else {
	    pr ("\nPattern not found\n");
	    end_it (0);
a1442 2
	error ("Pattern not found");
    }
a1444 1
/*VARARGS2*/
d1446 1
a1446 1
execute (char *filename, char *cmd, char *av0, char *av1, char *av2)
d1457 4
a1460 4
	fflush (stdout);
	reset_tty ();
	for (n = 10; (id = fork ()) < 0 && n > 0; n--)
	    sleep (5);
d1462 7
a1468 7
	    if (!isatty(0)) {
		close(0);
		open(_PATH_TTY, 0);
	    }
	    execv (cmd, argp);
	    write (STDERR_FILENO, "exec failed\n", 12);
	    exit (1);
d1471 10
a1480 9
	    signal (SIGINT, SIG_IGN);
	    signal (SIGQUIT, SIG_IGN);
	    if (catch_susp)
		signal(SIGTSTP, SIG_DFL);
	    while (wait(0) > 0);
	    signal (SIGINT, end_it);
	    signal (SIGQUIT, onquit);
	    if (catch_susp)
		signal(SIGTSTP, onsusp);
d1482 4
a1485 4
	    write(STDERR_FILENO, "can't fork\n", 11);
	set_tty ();
	pr ("------------------------\n");
	prompt (filename);
d1487 1
d1489 6
a1494 2
** Skip n lines in the file f
*/
d1496 14
d1511 1
a1511 1
skiplns (int n, FILE *f)
d1513 1
a1513 5
    char c;

    while (n > 0) {
	while ((c = Getc (f)) != '\n')
	    if (c == EOF)
d1515 21
a1535 3
	    n--;
	    Currline++;
    }
d1539 2
a1540 4
** Skip nskip files in the file list (from the command line). Nskip may be
** negative.
*/

d1542 1
a1542 1
skipf (int nskip)
d1544 6
a1549 37
    if (nskip == 0) return;
    if (nskip > 0) {
	if (fnum + nskip > nfiles - 1)
	    nskip = nfiles - fnum - 1;
    }
    else if (within)
	++fnum;
    fnum += nskip;
    if (fnum < 0)
	fnum = 0;
    pr ("\n...Skipping ");
    pr ("\n");
    if (clreol)
	cleareol ();
    pr ("...Skipping ");
    pr (nskip > 0 ? "to file " : "back to file ");
    pr (fnames[fnum]);
    pr ("\n");
    if (clreol)
	cleareol ();
    pr ("\n");
    --fnum;
}

/*----------------------------- Terminal I/O -------------------------------*/

void
initterm (void)
{
    char	buf[TBUFSIZ];
    static char	clearbuf[TBUFSIZ];
    char	*clearptr, *padstr;
    int		ldisc;
    int		lmode;
    char	*term;
    int		tgrp;
    struct winsize win;
d1552 37
a1588 72
    if (!(no_tty = tcgetattr(fileno(stdout), &otty))) {
	docrterase = (otty.c_cc[VERASE] != 255);
	docrtkill =  (otty.c_cc[VKILL] != 255);
	/*
	 * Wait until we're in the foreground before we save the
	 * the terminal modes.
	 */
	if ((tgrp = tcgetpgrp(fileno(stdout))) < 0) {
	    perror("tcgetpgrp");
	    exit(1);
	}
	if (tgrp != getpgrp()) {
	    kill(0, SIGTTOU);
	    goto retry;
	}
	if ((term = getenv("TERM")) == 0 || tgetent(buf, term) <= 0) {
	    dumb++; ul_opt = 0;
	}
	else {
	    if (ioctl(fileno(stdout), TIOCGWINSZ, &win) < 0) {
		Lpp = tgetnum("li");
		Mcol = tgetnum("co");
	    } else {
		if ((Lpp = win.ws_row) == 0)
		    Lpp = tgetnum("li");
		if ((Mcol = win.ws_col) == 0)
		    Mcol = tgetnum("co");
	    }
	    if ((Lpp <= 0) || tgetflag("hc")) {
		hard++;	/* Hard copy terminal */
		Lpp = 24;
	    }
	    if (tgetflag("xn"))
		eatnl++; /* Eat newline at last column + 1; dec, concept */
	    if (Mcol <= 0)
		Mcol = 80;

	    if (tailequ (fnames[0], "page") || !hard && tgetflag("ns"))
		noscroll++;
	    Wrap = tgetflag("am");
	    bad_so = tgetflag ("xs");
	    clearptr = clearbuf;
	    eraseln = tgetstr("ce",&clearptr);
	    Clear = tgetstr("cl", &clearptr);
	    Senter = tgetstr("so", &clearptr);
	    Sexit = tgetstr("se", &clearptr);
	    if ((soglitch = tgetnum("sg")) < 0)
		soglitch = 0;

	    /*
	     *  Set up for underlining:  some terminals don't need it;
	     *  others have start/stop sequences, still others have an
	     *  underline char sequence which is assumed to move the
	     *  cursor forward one character.  If underline sequence
	     *  isn't available, settle for standout sequence.
	     */

	    if (tgetflag("ul") || tgetflag("os"))
		ul_opt = 0;
	    if ((chUL = tgetstr("uc", &clearptr)) == NULL )
		chUL = "";
	    if (((ULenter = tgetstr("us", &clearptr)) == NULL ||
	         (ULexit = tgetstr("ue", &clearptr)) == NULL) && !*chUL) {
	        if ((ULenter = Senter) == NULL || (ULexit = Sexit) == NULL) {
			ULenter = "";
			ULexit = "";
		} else
			ulglitch = soglitch;
	    } else {
		if ((ulglitch = tgetnum("ug")) < 0)
		    ulglitch = 0;
	    }
d1590 37
a1626 14
	    if (padstr = tgetstr("pc", &clearptr))
		PC = *padstr;
	    Home = tgetstr("ho",&clearptr);
	    if (Home == 0 || *Home == '\0')
	    {
		if ((cursorm = tgetstr("cm", &clearptr)) != NULL) {
		    strlcpy(cursorhome, tgoto(cursorm, 0, 0),
		      sizeof cursorhome);
		    Home = cursorhome;
	       }
	    }
	    EodClr = tgetstr("cd", &clearptr);
	    if ((chBS = tgetstr("bc", &clearptr)) == NULL)
		chBS = "\b";
d1628 23
a1650 8
	}
	if ((shell = getenv("SHELL")) == NULL)
	    shell = "/bin/sh";
    }
    no_intty = tcgetattr(fileno(stdin), &otty);
    tcgetattr(fileno(stderr), &otty);
    savetty0 = otty;
    slow_tty = cfgetospeed(&otty) < B1200;
d1652 1
a1652 1
    hardtabs = (otty.c_oflag & TABDLY) != OXTABS;
d1654 5
a1658 5
    if (!no_tty) {
	otty.c_lflag &= ~(ICANON|ECHO);
	otty.c_cc[VMIN] = 1;
	otty.c_cc[VTIME] = 0;
    }
d1662 1
a1662 1
readch (void)
a1664 1
	extern int errno;
d1667 2
a1668 2
	/* XXX - reading from stderr?!?! */
	if (read (STDERR_FILENO, &ch, 1) <= 0)
d1673 1
d1680 77
a1756 75
#define ERASEONECHAR \
    if (docrterase) \
	write (STDERR_FILENO, BSB, sizeof(BSB)); \
    else \
	write (STDERR_FILENO, &BS, sizeof(BS));

void
ttyin (char *buf, int nmax, char pchar)
{
    char *sptr;
    char ch;
    int slash = 0;
    int	maxlen;
    char cbuf;

    sptr = buf;
    maxlen = 0;
    while (sptr - buf < nmax) {
	if (promptlen > maxlen) maxlen = promptlen;
	ch = readch ();
	if (ch == '\\') {
	    slash++;
	}
	else if ((ch == otty.c_cc[VERASE]) && !slash) {
	    if (sptr > buf) {
		--promptlen;
		ERASEONECHAR
		--sptr;
		if ((*sptr < ' ' && *sptr != '\n') || *sptr == RUBOUT) {
		    --promptlen;
		    ERASEONECHAR
		}
		continue;
	    }
	    else {
		if (!eraseln) promptlen = maxlen;
		siglongjmp (restore, 1);
	    }
	}
	else if ((ch == otty.c_cc[VKILL]) && !slash) {
	    if (hard) {
		show (ch);
		putchar ('\n');
		putchar (pchar);
	    }
	    else {
		putchar ('\r');
		putchar (pchar);
		if (eraseln)
		    erasep (1);
		else if (docrtkill)
		    while (promptlen-- > 1)
			write (STDERR_FILENO, BSB, sizeof(BSB));
		promptlen = 1;
	    }
	    sptr = buf;
	    fflush (stdout);
	    continue;
	}
	if (slash && (ch == otty.c_cc[VKILL] || ch == otty.c_cc[VERASE])) {
	    ERASEONECHAR
	    --sptr;
	}
	if (ch != '\\')
	    slash = 0;
	*sptr++ = ch;
	if ((ch < ' ' && ch != '\n' && ch != ESC) || ch == RUBOUT) {
	    ch += ch == RUBOUT ? -0100 : 0100;
	    write (STDERR_FILENO, &CARAT, 1);
	    promptlen++;
	}
	cbuf = ch;
	if (ch != '\n' && ch != ESC) {
	    write (STDERR_FILENO, &cbuf, 1);
	    promptlen++;
d1758 5
a1762 7
	else
	    break;
    }
    *--sptr = '\0';
    if (!eraseln) promptlen = maxlen;
    if (sptr - buf >= nmax - 1)
	error ("Line too long");
d1766 1
a1766 1
expand (char *outbuf, size_t olen, char *inbuf)
d1768 37
a1804 33
    char *instr;
    char *outstr;
    char ch;
    char temp[200];
    int changed = 0;

    instr = inbuf;
    outstr = temp;
    while ((ch = *instr++) != '\0')
	switch (ch) {
	case '%':
	    if (!no_intty) {
		strlcpy (outstr, fnames[fnum], temp + sizeof temp - outstr);
		outstr += strlen (fnames[fnum]);
		changed++;
	    }
	    else
		*outstr++ = ch;
	    break;
	case '!':
	    if (!shellp)
		error ("No previous command to substitute for");
	    strlcpy (outstr, shell_line, temp + sizeof temp - outstr);
	    outstr += strlen (shell_line);
	    changed++;
	    break;
	case '\\':
	    if (*instr == '%' || *instr == '!') {
		*outstr++ = *instr++;
		break;
	    }
	default:
	    *outstr++ = ch;
d1806 3
a1808 3
    *outstr++ = '\0';
    strlcpy (outbuf, temp, olen);
    return (changed);
d1812 1
a1812 1
show (int ch)
d1814 1
a1814 1
    char cbuf;
d1816 7
a1822 3
    if ((ch < ' ' && ch != '\n' && ch != ESC) || ch == RUBOUT) {
	ch += ch == RUBOUT ? -0100 : 0100;
	write (STDERR_FILENO, &CARAT, 1);
a1823 4
    }
    cbuf = ch;
    write (STDERR_FILENO, &cbuf, 1);
    promptlen++;
d1827 16
a1842 17
error (char *mess)
{
    if (clreol)
	cleareol ();
    else
	kill_line ();
    promptlen += strlen (mess);
    if (Senter && Sexit) {
	tputs (Senter, 1, putch);
	pr(mess);
	tputs (Sexit, 1, putch);
    }
    else
	pr (mess);
    fflush(stdout);
    errors++;
    siglongjmp (restore, 1);
a1844 1

d1846 1
a1846 1
set_tty (void)
d1851 1
a1851 1
	stty(STDERR_FILENO, &otty);
d1855 1
a1855 1
reset_tty (void)
d1857 11
a1867 11
    if (no_tty)
	return;
    if (pstate) {
	tputs(ULexit, 1, putch);
	fflush(stdout);
	pstate = 0;
    }
    otty.c_lflag |= ICANON|ECHO;
    otty.c_cc[VMIN] = savetty0.c_cc[VMIN];
    otty.c_cc[VTIME] = savetty0.c_cc[VTIME];
    stty(STDERR_FILENO, &savetty0);
d1873 2
a1874 2
    char c;
    char *p;
d1876 6
a1881 6
    p = Line;
    while ((c = Getc (f)) != '\n' && c != EOF && p - Line < LINSIZ - 1)
	*p++ = c;
    if (c == '\n')
	Currline++;
    *p = '\0';
d1884 3
a1886 2
/* Come here when we get a suspend signal from the terminal */

d1888 1
a1888 1
onsusp (int signo)
d1894 2
a1895 2
    reset_tty ();
    fflush (stdout);
d1905 1
a1905 1
    kill (0, SIGTSTP);
d1910 2
a1911 2
    signal (SIGTSTP, onsusp);
    set_tty ();
d1913 1
a1913 1
	    siglongjmp (restore, 1);
d1919 4
a1922 4
    fprintf(stderr,
	"usage: %s [-dfln] [+linenum | +/pattern] name1 name2 ...\n",
	__progname);
    exit(1);
@


1.3
log
@strings... ok millert@@, tedu@@
@
text
@d62 1
d1363 3
a1365 1
    char *s;
d1370 11
a1380 2
    if ((s = re_comp (buf)) != 0)
	error (s);
d1387 1
a1387 1
	if ((rv = re_exec (Line)) == 1) {
d1421 4
a1424 2
	} else if (rv == -1)
	    error ("Regular expression botch");
@


1.2
log
@Pull in some POSIX and ANSI changes from the Linux version
@
text
@d146 1
a146 1
int  expand(char *, char *);
d1337 1
a1337 1
		if (expand (shell_line, cmdbuf)) {
d1611 2
a1612 1
		    strcpy(cursorhome, tgoto(cursorm, 0, 0));
d1743 1
a1743 1
expand (char *outbuf, char *inbuf)
d1757 1
a1757 1
		strcpy (outstr, fnames[fnum]);
d1767 1
a1767 1
	    strcpy (outstr, shell_line);
d1780 1
a1780 1
    strcpy (outbuf, temp);
@


1.1
log
@old 4.3BSD more; nice and small
@
text
@d35 1
a35 1
char copyright[] =
d41 1
a41 1
static char sccsid[] = "@@(#)more.c	5.28 (Berkeley) 3/1/93";
d54 1
d57 3
a59 1
#include <signal.h>
d61 1
a61 1
#include <sgtty.h>
d63 2
a64 2
#include <a.out.h>
#include <varargs.h>
d66 1
d68 2
a69 1
#include <ctype.h>
d78 1
a78 2
#define MBIT	CBREAK
#define stty(fd,argp)	ioctl(fd,TIOCSETN,argp)
d87 1
a87 1
struct sgttyb	otty, savetty;
a90 1
void		chgwinsz(), end_it(), onquit(), onsusp();
d113 1
a113 2
char		ch;
jmp_buf		restore;
a125 1
char		*tgetstr();
a130 1
char		*getenv();
d135 1
a135 2
extern short	ospeed;

d137 49
a185 9
main(argc, argv)
int argc;
char *argv[];
{
    register FILE	*f;
    register char	*s;
    register char	*p;
    register char	ch;
    register int	left;
d191 1
d193 2
a194 1
    FILE		*checkf();
d202 1
a202 1
    if(s = getenv("MORE")) argscan(s);
d241 2
a242 9
    if (!no_intty && nfiles == 0) {
	char *rindex();

	p = rindex(argv[0], '/');
	fputs("usage: ",stderr);
	fputs(p ? p + 1 : argv[0],stderr);
	fputs(" [-dfln] [+linenum | +/pattern] name1 name2 ...\n",stderr);
	exit(1);
    }
d289 1
a289 1
	    if (firstf) setjmp (restore);
d302 1
a302 1
		setjmp (restore);
d306 1
a306 1
		if ((noscroll || clearit) && (file_size != LONG_MAX))
d311 1
d314 1
a314 1
			erase (0);
d319 1
a319 1
			erase (14);
d336 1
a336 1
	    setjmp (restore);
d349 2
a350 2
argscan(s)
char *s;
d387 6
d405 1
a405 3
checkf (fs, clearfirst)
	register char *fs;
	int *clearfirst;
d409 1
a409 1
	char c;
d442 2
a443 3
magic(f, fs)
	FILE *f;
	char *fs;
d445 5
a449 1
	struct exec ex;
d451 2
a452 2
	if (fread(&ex, sizeof(ex), 1, f) == 1)
		switch(ex.a_magic) {
d458 1
d464 1
d473 2
a474 2
putch (ch)
char ch;
d485 2
a486 3
screen (f, num_lines)
register FILE *f;
register int num_lines;
d488 2
a489 2
    register int c;
    register int nchars;
d504 2
a505 2
	    if (bad_so || (Senter && *Senter == ' ') && promptlen > 0)
		erase (0);
d513 1
a513 1
		erase (nchars);	/* erase () sets promptlen to 0 */
d540 1
a540 1
	setjmp (restore);
d545 1
a545 1
		erase (0);
d563 1
a563 1
onquit()
d570 1
a570 1
	    longjmp (restore, 1);
d576 1
a576 1
	write (2, "[Use q or Q to quit]", 20);
d588 1
a588 1
chgwinsz()
d612 1
a612 1
end_it ()
d626 1
a626 1
	write (2, "\n", 1);
d630 2
a631 2
copy_file(f)
register FILE *f;
d633 1
a633 1
    register int c;
d641 2
a642 3
prtf (fmt, va_alist)
register char *fmt;
va_dcl
d645 2
a646 2
	register char ch;
	register int ccount;
d649 1
a649 1
	va_start(ap);
d684 2
a685 2
printd (n)
int n;
d689 1
a689 1
    if (a = n/10)
d700 2
a701 3
scanstr (n, str)
int n;
char *str;
d708 2
a709 1
Sprintf (n)
d713 1
a713 1
    if (a = n/10)
d724 2
a725 3
tailequ (path, string)
char *path;
register char *string;
d727 1
a727 1
	register char *tail;
d740 2
a741 2
prompt (filename)
char *filename;
d772 1
a772 1
	write (2, &bell, 1);
d780 2
a781 3
getline(f, length)
register FILE *f;
int *length;
d783 4
a786 4
    register int	c;
    register char	*p;
    register int	column;
    static int		colflg;
d865 2
a866 2
erase (col)
register int col;
d890 2
a891 1
kill_line ()
d893 3
a895 2
    erase (0);
    if (!eraseln || dumb) putchar ('\r');
d901 2
a902 1
cleareol()
d907 2
a908 1
clreos()
d917 2
a918 2
pr(s1)
char	*s1;
d920 2
a921 2
    register char	*s;
    register char	c;
d931 2
a932 3
prbuf (s, n)
register char *s;
register int n;
d934 2
a935 2
    register char c;			/* next output character */
    register int state;			/* next output char's UL state */
d972 2
a973 1
doclear()
d989 2
a990 1
home()
d997 1
a997 1
char shell_line[132];
a1024 4
    if (MBIT == RAW && slow_tty) {
	otty.sg_flags |= MBIT;
	stty(fileno(stderr), &otty);
    }
d1037 1
a1037 1
	if (comchar == otty.sg_erase) {
d1054 1
a1054 1
		    write(2, &bell, 1);
d1061 1
a1061 1
		erase (0);
d1100 1
a1100 1
	    end_it ();
d1107 1
a1107 1
	    erase (0);
d1146 1
a1146 1
		write (2, &bell, 1);
d1158 1
a1158 1
		write (2, &bell, 1);
d1175 1
a1175 1
		write (2,"\r", 1);
d1180 1
a1180 1
		write (2, "\r", 1);
d1198 11
d1214 1
a1214 1
		execute (filename, _PATH_VI, "vi", cmdbuf, fnames[fnum], 0);
d1230 1
a1230 1
		write (2, &bell, 1);
a1238 4
    if (MBIT == RAW && slow_tty) {
	otty.sg_flags &= ~MBIT;
	stty(fileno(stderr), &otty);
    }
d1242 1
a1242 1
char ch;
d1250 1
a1250 4
colon (filename, cmd, nlines)
char *filename;
int cmd;
int nlines;
d1269 1
a1269 1
				end_it ();
d1273 1
a1273 1
		erase (0);
d1278 1
a1278 1
			write (2, &bell, 1);
d1282 1
a1282 1
		erase (0);
d1292 1
a1292 1
		end_it ();
d1294 1
a1294 1
		write (2, &bell, 1);
d1309 1
a1309 1
	i = 0; ch = otty.sg_kill;
d1312 1
a1312 1
		if (ch >= '0' && ch <= '9')
d1314 1
a1314 1
		else if (ch == otty.sg_kill)
d1324 2
a1325 2
do_shell (filename)
char *filename;
d1327 1
a1327 1
	char cmdbuf[80];
d1336 1
a1336 1
		ttyin (cmdbuf, 78, '!');
d1343 1
a1343 1
	write (2, "\n", 1);
d1346 1
a1346 1
	execute (filename, shell, shell, "-c", shell_line, 0);
d1353 2
a1354 4
search (buf, file, n)
char buf[];
FILE *file;
register int n;
d1361 2
a1362 2
    int saveln, rv, re_exec();
    char *s, *re_comp();
d1375 1
a1375 1
	if ((rv = re_exec (Line)) == 1)
d1409 1
a1409 1
	else if (rv == -1)
a1413 1
	/*    file->_flag &= ~_IOEOF; /* why doesn't fseek do this ??!!??! */
d1419 1
a1419 1
	    end_it ();
d1426 2
a1427 4
execute (filename, cmd, va_alist)
char *filename;
char *cmd;
va_dcl
d1431 6
a1436 1
	va_list argp;
d1445 1
a1445 1
		open("/dev/tty", 0);
a1446 1
	    va_start(argp);
d1448 1
a1448 1
	    write (2, "exec failed\n", 12);
a1449 1
	    va_end(argp);	/* balance {}'s for some UNIX's */
d1462 1
a1462 1
	    write(2, "can't fork\n", 11);
d1471 2
a1472 3
skiplns (n, f)
register int n;
register FILE *f;
d1474 1
a1474 1
    register char c;
d1490 2
a1491 2
skipf (nskip)
register int nskip;
d1519 2
a1520 1
initterm ()
a1529 1
    char	*tgoto();
d1532 3
a1534 7
    if (!(no_tty = ioctl(fileno(stdout), TIOCGETP, &otty))) {
	if (ioctl(fileno(stdout), TIOCLGET, &lmode) < 0) {
	    perror("TIOCLGET");
	    exit(1);
	}
	docrterase = ((lmode & LCRTERA) != 0);
	docrtkill = ((lmode & LCRTKIL) != 0);
d1539 2
a1540 2
	if (ioctl(fileno(stdout), TIOCGPGRP, &tgrp) < 0) {
	    perror("TIOCGPGRP");
d1543 1
a1543 1
	if (tgrp != getpgrp(0)) {
d1623 7
a1629 6
    no_intty = ioctl(fileno(stdin), TIOCGETP, &otty);
    (void)ioctl(fileno(stderr), TIOCGETP, &otty);
    savetty = otty;
    ospeed = otty.sg_ospeed;
    slow_tty = ospeed < B1200;
    hardtabs = (otty.sg_flags & TBDELAY) != XTABS;
d1631 3
a1633 3
	otty.sg_flags &= ~ECHO;
	if (MBIT == CBREAK || !slow_tty)
	    otty.sg_flags |= MBIT;
d1637 2
a1638 1
readch ()
d1640 1
a1640 1
	char ch;
d1644 2
a1645 1
	if (read (2, &ch, 1) <= 0)
d1647 4
a1650 4
			end_it();
		else
			ch = otty.sg_kill;
	return (ch);
d1658 1
a1658 1
	write (2, BSB, sizeof(BSB)); \
d1660 1
a1660 1
	write (2, &BS, sizeof(BS));
d1662 6
a1667 8
ttyin (buf, nmax, pchar)
char buf[];
register int nmax;
char pchar;
{
    register char *sptr;
    register char ch;
    register int slash = 0;
d1679 1
a1679 1
	else if ((ch == otty.sg_erase) && !slash) {
d1692 1
a1692 1
		longjmp (restore, 1);
d1695 1
a1695 1
	else if ((ch == otty.sg_kill) && !slash) {
d1705 1
a1705 1
		    erase (1);
d1708 1
a1708 1
			write (2, BSB, sizeof(BSB));
d1715 1
a1715 1
	if (slash && (ch == otty.sg_kill || ch == otty.sg_erase)) {
d1724 1
a1724 1
	    write (2, &CARAT, 1);
d1729 1
a1729 1
	    write (2, &cbuf, 1);
d1741 6
a1746 7
expand (outbuf, inbuf)
char *outbuf;
char *inbuf;
{
    register char *instr;
    register char *outstr;
    register char ch;
d1783 2
a1784 2
show (ch)
register char ch;
d1790 1
a1790 1
	write (2, &CARAT, 1);
d1794 1
a1794 1
    write (2, &cbuf, 1);
d1798 2
a1799 2
error (mess)
char *mess;
d1815 1
a1815 1
    longjmp (restore, 1);
d1819 2
a1820 1
set_tty ()
d1822 4
a1825 3
	otty.sg_flags |= MBIT;
	otty.sg_flags &= ~ECHO;
	stty(fileno(stderr), &otty);
d1828 2
a1829 1
reset_tty ()
d1838 4
a1841 3
    otty.sg_flags |= ECHO;
    otty.sg_flags &= ~MBIT;
    stty(fileno(stderr), &savetty);
d1844 2
a1845 2
rdline (f)
register FILE *f;
d1847 2
a1848 2
    register char c;
    register char *p;
d1861 1
a1861 1
onsusp ()
d1863 2
d1872 6
a1877 1
    sigsetmask(0);
d1882 1
d1886 10
a1895 1
	    longjmp (restore, 1);
@

