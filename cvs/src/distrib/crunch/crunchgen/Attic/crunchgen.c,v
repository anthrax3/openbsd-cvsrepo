head	1.29;
access;
symbols
	OPENBSD_4_4:1.28.0.8
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.6
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.4
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.24.0.4
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.20.0.6
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.4
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.18.0.6
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.18.0.4
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.14.0.10
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.8
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.6
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.14.0.4
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2008.08.22.15.18.55;	author deraadt;	state dead;
branches;
next	1.28;

1.28
date	2006.12.26.10.20.11;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2006.10.25.01.53.19;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2006.10.15.06.44.13;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2006.10.14.20.23.29;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.06.16.49.31;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.03.22.39.54;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.02.11.25.05;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2004.08.24.09.11.39;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.27.19.41.30;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.09.05.53.53;	author todd;	state Exp;
branches;
next	1.18;

1.18
date	2000.11.24.04.18.20;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.09.19.20.40;	author marc;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.23.21.43.54;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	99.12.06.01.47.58;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.09.07.20.08.53;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.09.07.20.03.13;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.09.07.19.35.08;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.07.23.19.31.51;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	97.04.04.21.52.40;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.01.31.19.40.42;	author rahnds;	state Exp;
branches;
next	1.8;

1.8
date	97.01.26.12.57.14;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.01.09.04.09.40;	author rahnds;	state Exp;
branches;
next	1.6;

1.6
date	96.09.28.04.30.39;	author etheisen;	state Exp;
branches;
next	1.5;

1.5
date	96.09.27.06.06.58;	author etheisen;	state Exp;
branches;
next	1.4;

1.4
date	96.09.25.06.40.52;	author etheisen;	state Exp;
branches;
next	1.3;

1.3
date	96.09.25.04.54.21;	author etheisen;	state Exp;
branches;
next	1.2;

1.2
date	96.09.25.04.41.20;	author etheisen;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.31;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Merge crunchgen & crunchhide (using name checking), and move to usr.sbin
next step is to not install it as two programs, but be even more clever
@
text
@/* $OpenBSD: crunchgen.c,v 1.28 2006/12/26 10:20:11 deraadt Exp $	 */

/*
 * Copyright (c) 1994 University of Maryland
 * All Rights Reserved.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of U.M. not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  U.M. makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * U.M. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL U.M.
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author: James da Silva, Systems Design and Analysis Group
 *			   Computer Science Department
 *			   University of Maryland at College Park
 */
/*
 * ========================================================================
 * crunchgen.c
 *
 * Generates a Makefile and main C file for a crunched executable,
 * from specs given in a .conf file.
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <string.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>

#define CRUNCH_VERSION	"0.3"

#define MAXLINELEN	16384
#define MAXFIELDS 	 2048

/* XXX - This should be runtime configurable */
/*
 * We might have more than one makefile
 * name on any given platform. Make sure
 * default name is last though.
 */
char           *mf_name[] = {
#if defined(MF_NAMES)
	MF_NAMES,
#else
	"Makefile",
#endif
	NULL
};

/* internal representation of conf file: */

/* simple lists of strings suffice for most parms */

typedef struct strlst {
	struct strlst  *next;
	char           *str;
} strlst_t;

/* progs have structure, each field can be set with "special" or calculated */

typedef struct prog {
	struct prog    *next;
	char           *name, *ident, *mf_name;
	char           *srcdir, *objdir;
	strlst_t       *objs, *objpaths;
	strlst_t       *links;
	int             goterror;
} prog_t;

strlst_t       *srcdirs = NULL;
strlst_t       *libs = NULL;
strlst_t       *libdirs = NULL;
char		objdir[MAXPATHLEN] = "obj";
prog_t         *progs = NULL;

char            line[MAXLINELEN];

char            confname[MAXPATHLEN], infilename[MAXPATHLEN];
char            outmkname[MAXPATHLEN], outcfname[MAXPATHLEN];
char            cachename[MAXPATHLEN], curfilename[MAXPATHLEN];
char            topdir[MAXPATHLEN], execfname[MAXPATHLEN];
int             linenum = -1;
int             goterror = 0;

char           *progname = "crunchgen";

int             verbose, readcache, elf_names;	/* options */
int             reading_cache;

void            status(char *str);
void            out_of_memory(void);
void            add_string(strlst_t ** listp, char *str);
int             is_dir(char *pathname);
int             is_nonempty_file(char *pathname);
void            usage(void);
void            parse_conf_file(void);
void            gen_outputs(void);

int 
main(int argc, char *argv[])
{
	char           *p;
	int             optc;
	extern int      optind;
	extern char    *optarg;

	verbose = 1;
	readcache = 1;
	*outmkname = *outcfname = *execfname = '\0';

	if (argc > 0)
		progname = argv[0];

	while ((optc = getopt(argc, argv, "m:c:e:fqD:EL:O:")) != -1) {
		switch (optc) {
		case 'f':
			readcache = 0;
			break;
		case 'q':
			verbose = 0;
			break;

		case 'm':
			if (strlcpy(outmkname, optarg, sizeof(outmkname)) >=
			    sizeof(outmkname))
				usage();
			break;
		case 'c':
			if (strlcpy(outcfname, optarg, sizeof(outcfname)) >=
			    sizeof(outcfname))
				usage();
			break;
		case 'e':
			if (strlcpy(execfname, optarg, sizeof(execfname)) >=
			    sizeof(execfname))
				usage();
			break;

		case 'D':
			if (strlcpy(topdir, optarg, sizeof(topdir)) >= sizeof(topdir))
				usage();
			break;
		case 'E':
			elf_names = 1;
			break;
		case 'L':
			if (strlen(optarg) >= MAXPATHLEN)
				usage();
			add_string(&libdirs, optarg);
			break;
		case 'O':
			if (strlcpy(objdir, optarg, sizeof(objdir)) >=
			    sizeof(objdir))
				usage();
			break;
		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;

	if (argc != 1)
		usage();

	if (libdirs == NULL)
		add_string(&libdirs, "/usr/lib");
	/*
         * generate filenames
         */

	if (strlcpy(infilename, argv[0], sizeof(infilename)) >=
	    sizeof(infilename))
		usage();

	/* confname = `basename infilename .conf` */

	if ((p = strrchr(infilename, '/')) != NULL)
		strlcpy(confname, p + 1, sizeof confname);
	else
		strlcpy(confname, infilename, sizeof confname);
	if ((p = strrchr(confname, '.')) != NULL && !strcmp(p, ".conf"))
		*p = '\0';

	if (!*outmkname)
		snprintf(outmkname, sizeof(outmkname), "%s.mk", confname);
	if (!*outcfname)
		snprintf(outcfname, sizeof(outcfname), "%s.c", confname);
	if (!*execfname)
		snprintf(execfname, sizeof(execfname), "%s", confname);
	snprintf(cachename, sizeof(cachename), "%s.cache", confname);

	parse_conf_file();
	gen_outputs();

	exit(goterror);
}

void 
usage(void)
{
	fprintf(stderr,
	    "usage: %s [-Efq] [-c c-file-name] [-D src-root] [-e exec-file-name]\n"
	    "\t[-L lib-dir] [-m makefile-name] [-O objdir-name] conf-file\n",
	    progname);
	exit(1);
}

void            parse_one_file(char *filename);
void            parse_line(char *line, int *fc, char **fv, int nf);
void            add_srcdirs(int argc, char **argv);
void            add_progs(int argc, char **argv);
void            add_link(int argc, char **argv);
void            add_libs(int argc, char **argv);
void            add_libdirs(int argc, char **argv);
void            add_special(int argc, char **argv);

prog_t         *find_prog(char *str);
void            add_prog(char *progname);

void 
parse_conf_file(void)
{
	if (!is_nonempty_file(infilename)) {
		fprintf(stderr, "%s: fatal: input file \"%s\" not found.\n",
		    progname, infilename);
		exit(1);
	}
	parse_one_file(infilename);
	if (readcache && is_nonempty_file(cachename)) {
		reading_cache = 1;
		parse_one_file(cachename);
	}
}

void 
parse_one_file(char *filename)
{
	char           *fieldv[MAXFIELDS];
	int             fieldc;
	void            (*f) (int c, char **v);
	FILE           *cf;

	snprintf(line, sizeof(line), "reading %s", filename);
	status(line);
	strlcpy(curfilename, filename, sizeof curfilename);

	if ((cf = fopen(curfilename, "r")) == NULL) {
		perror(curfilename);
		goterror = 1;
		return;
	}
	linenum = 0;
	while (fgets(line, MAXLINELEN, cf) != NULL) {
		linenum++;
		parse_line(line, &fieldc, fieldv, MAXFIELDS);
		if (fieldc < 1)
			continue;
		if (!strcmp(fieldv[0], "srcdirs"))
			f = add_srcdirs;
		else if (!strcmp(fieldv[0], "progs"))
			f = add_progs;
		else if (!strcmp(fieldv[0], "ln"))
			f = add_link;
		else if (!strcmp(fieldv[0], "libs"))
			f = add_libs;
		else if (!strcmp(fieldv[0], "special"))
			f = add_special;
		else if (!strcmp(fieldv[0], "libdirs"))
			f = add_libdirs;
		else {
			fprintf(stderr, "%s:%d: skipping unknown command `%s'.\n",
			    curfilename, linenum, fieldv[0]);
			goterror = 1;
			continue;
		}
		if (fieldc < 2) {
			fprintf(stderr,
			    "%s:%d: %s command needs at least 1 "
		  	    "argument, skipping.\n",
			    curfilename, linenum, fieldv[0]);
			goterror = 1;
			continue;
		}
		f(fieldc, fieldv);
	}

	if (ferror(cf)) {
		perror(curfilename);
		goterror = 1;
	}
	fclose(cf);
}

void 
parse_line(char *line, int *fc, char **fv, int nf)
{
	char           *p;

	p = line;
	*fc = 0;
	while (1) {
		while (isspace(*p))
			p++;
		if (*p == '\0' || *p == '#')
			break;

		if (*fc < nf)
			fv[(*fc)++] = p;
		while (*p && !isspace(*p) && *p != '#')
			p++;
		if (*p == '\0' || *p == '#')
			break;
		*p++ = '\0';
	}
	if (*p)
		*p = '\0';	/* needed for '#' case */
}

void 
add_srcdirs(int argc, char **argv)
{
	int             i;
	char            tmppath[MAXPATHLEN];
	int             overflow;

	for (i = 1; i < argc; i++) {
		overflow = 0;
		if (argv[i][0] == '/' || topdir[0] == '\0') {
			if (strlcpy(tmppath, argv[i], sizeof(tmppath)) >=
			    sizeof(tmppath))
				overflow = 1;
		} else {
			if (strlcpy(tmppath, topdir, sizeof(tmppath)) >=
			    sizeof(tmppath) ||
			    strlcat(tmppath, "/", sizeof(tmppath)) >=
			    sizeof(tmppath) ||
			    strlcat(tmppath, argv[i], sizeof(tmppath)) >=
			    sizeof(tmppath))
				overflow = 1;
		}
		if (overflow) {
			goterror = 1;
			fprintf(stderr, "%s:%d: `%.40s...' is too long, skipping it.\n",
			    curfilename, linenum, argv[i]);
			continue;
		}
		if (is_dir(tmppath))
			add_string(&srcdirs, tmppath);
		else {
			fprintf(stderr, "%s:%d: `%s' is not a directory, skipping it.\n",
			    curfilename, linenum, tmppath);
			goterror = 1;
		}
	}
}

void 
add_libdirs(int argc, char **argv)
{
	int             i;
	char            tmppath[MAXPATHLEN];
	char            tmppath2[MAXPATHLEN];
	int             overflow;

	for (i = 1; i < argc; i++) {
		overflow = 0;
		if (argv[i][0] == '/' || topdir[0] == '\0') {
			if (strlcpy(tmppath, argv[i], sizeof(tmppath)) >=
			    sizeof(tmppath))
				overflow = 1;
		} else {
			if (strlcpy(tmppath, topdir, sizeof(tmppath)) >=
			    sizeof(tmppath) ||
			    strlcat(tmppath, "/", sizeof(tmppath)) >=
			    sizeof(tmppath) ||
			    strlcat(tmppath, argv[i], sizeof(tmppath)) >=
			    sizeof(tmppath))
				overflow = 1;
		}
		if (overflow) {
			goterror = 1;
			fprintf(stderr, "%s:%d: `%.40s...' is too long, skipping it.\n",
			    curfilename, linenum, argv[i]);
			continue;
		}
		if (is_dir(tmppath)) {
			snprintf(tmppath2, sizeof(tmppath2), "%s/%s", tmppath,
			    objdir);
			if (is_dir(tmppath2))
				add_string(&libdirs, tmppath2);
			else {
				snprintf(tmppath2, sizeof(tmppath2), 
				    "%s/obj.%s", tmppath, MACHINE);
				if (is_dir(tmppath2))
					add_string(&libdirs, tmppath2);
				else
					add_string(&libdirs, tmppath);
			}
		}
		else {
			fprintf(stderr, "%s:%d: `%s' is not a directory, skipping it.\n",
			    curfilename, linenum, tmppath);
			goterror = 1;
		}
	}
}


void 
add_progs(int argc, char **argv)
{
	int             i;

	for (i = 1; i < argc; i++)
		add_prog(argv[i]);
}

void 
add_prog(char *progname)
{
	prog_t         *p1, *p2;

	/* add to end, but be smart about dups */

	for (p1 = NULL, p2 = progs; p2 != NULL; p1 = p2, p2 = p2->next)
		if (!strcmp(p2->name, progname))
			return;

	p2 = calloc(1, sizeof(prog_t));
	if (p2)
		p2->name = strdup(progname);
	if (!p2 || !p2->name)
		out_of_memory();

	p2->next = NULL;
	if (p1 == NULL)
		progs = p2;
	else
		p1->next = p2;

	p2->ident = p2->srcdir = p2->objdir = NULL;
	p2->links = p2->objs = NULL;
	p2->goterror = 0;
}

void 
add_link(int argc, char **argv)
{
	int             i;
	prog_t         *p = find_prog(argv[1]);

	if (p == NULL) {
		fprintf(stderr,
		    "%s:%d: no prog %s previously declared, skipping link.\n",
		    curfilename, linenum, argv[1]);
		goterror = 1;
		return;
	}
	for (i = 2; i < argc; i++)
		add_string(&p->links, argv[i]);
}

void 
add_libs(int argc, char **argv)
{
	int             i;

	for (i = 1; i < argc; i++)
		add_string(&libs, argv[i]);
}

void 
add_special(int argc, char **argv)
{
	int             i;
	prog_t         *p = find_prog(argv[1]);

	if (p == NULL) {
		if (reading_cache)
			return;
		fprintf(stderr,
		    "%s:%d: no prog %s previously declared, skipping special.\n",
		    curfilename, linenum, argv[1]);
		goterror = 1;
		return;
	}
	if (!strcmp(argv[2], "ident")) {
		if (argc != 4)
			goto argcount;
		if ((p->ident = strdup(argv[3])) == NULL)
			out_of_memory();
	} else if (!strcmp(argv[2], "srcdir")) {
		if (argc != 4)
			goto argcount;
		if ((p->srcdir = strdup(argv[3])) == NULL)
			out_of_memory();
	} else if (!strcmp(argv[2], "mf_name")) {
		if (argc != 4)
			goto argcount;
		if ((p->mf_name = strdup(argv[3])) == NULL)
			out_of_memory();
	} else if (!strcmp(argv[2], "objdir")) {
		if (argc != 4)
			goto argcount;
		if ((p->objdir = strdup(argv[3])) == NULL)
			out_of_memory();
	} else if (!strcmp(argv[2], "objs")) {
		p->objs = NULL;
		for (i = 3; i < argc; i++)
			add_string(&p->objs, argv[i]);
	} else if (!strcmp(argv[2], "objpaths")) {
		p->objpaths = NULL;
		for (i = 3; i < argc; i++)
			add_string(&p->objpaths, argv[i]);
	} else {
		fprintf(stderr, "%s:%d: bad parameter name `%s', skipping line.\n",
		    curfilename, linenum, argv[2]);
		goterror = 1;
	}
	return;

argcount:
	fprintf(stderr,
	    "%s:%d: too %s arguments, expected \"special %s %s <string>\".\n",
	    curfilename, linenum, argc < 4 ? "few" : "many", argv[1], argv[2]);
	goterror = 1;
}

prog_t  *
find_prog(char *str)
{
	prog_t         *p;

	for (p = progs; p != NULL; p = p->next)
		if (!strcmp(p->name, str))
			return p;
	return NULL;
}

void            remove_error_progs(void);
void            fillin_program(prog_t * p);
void            gen_specials_cache(void);
void            gen_output_makefile(void);
void            gen_output_cfile(void);

void            fillin_program_objs(prog_t * p, char *path);
void            top_makefile_rules(FILE * outmk);
void            prog_makefile_rules(FILE * outmk, prog_t * p);
void            output_strlst(FILE * outf, strlst_t * lst);
char           *genident(char *str);
char           *dir_search(char *progname);

void 
gen_outputs(void)
{
	prog_t         *p;

	for (p = progs; p != NULL; p = p->next)
		fillin_program(p);

	remove_error_progs();
	gen_specials_cache();
	gen_output_cfile();
	gen_output_makefile();
	status("");
	fprintf(stderr,
	    "Run \"make -f %s objs exe\" to build crunched binary.\n",
	    outmkname);
}

void 
fillin_program(prog_t * p)
{
	char            path[MAXPATHLEN];
	char           *srcparent;
	strlst_t       *s;
	int             i;

	snprintf(line, sizeof(line), "filling in parms for %s", p->name);
	status(line);

	if (!p->ident)
		p->ident = genident(p->name);
	if (!p->srcdir) {
		srcparent = dir_search(p->name);
		if (srcparent)
			snprintf(path, sizeof(path), "%s/%s", srcparent, p->name);
		if (is_dir(path))
			p->srcdir = strdup(path);
	}
	if (!p->objdir && p->srcdir) {
		snprintf(path, sizeof(path), "%s/%s", p->srcdir, objdir);
		if (is_dir(path))
			p->objdir = strdup(path);
		else {
			snprintf(path, sizeof(path), "%s/obj.%s", p->srcdir, MACHINE);
			if (is_dir(path))
				p->objdir = strdup(path);
			else
				p->objdir = p->srcdir;
		}
	}
	/* We have a sourcedir and no explicit objs, try */
	/* to find makefile and get objs from it. */
	if (p->srcdir && !p->objs) {
		for (i = 0; mf_name[i] != NULL; i++) {
			snprintf(path, sizeof(path), "%s/%s", p->srcdir, mf_name[i]);
			if (is_nonempty_file(path)) {
				p->mf_name = mf_name[i];
				fillin_program_objs(p, path);
				break;
			}
		}
	}
	if (!p->objpaths && p->objdir && p->objs)
		for (s = p->objs; s != NULL; s = s->next) {
			snprintf(line, sizeof(line), "%s/%s", p->objdir, s->str);
			add_string(&p->objpaths, line);
		}

	if (!p->srcdir && verbose)
		fprintf(stderr, "%s: %s: warning: could not find source directory.\n",
		    infilename, p->name);
	if (!p->objs && verbose)
		fprintf(stderr, "%s: %s: warning: could not find any .o files.\n",
		    infilename, p->name);

	if (!p->objpaths) {
		fprintf(stderr,
		    "%s: %s: error: no objpaths specified or calculated.\n",
		    infilename, p->name);
		p->goterror = goterror = 1;
	}
}

void 
fillin_program_objs(prog_t * p, char *path)
{
	char           *cp, *obj, tempfname[MAXPATHLEN];
	int             fd, rc;
	FILE           *f;

	/* discover the objs from the srcdir Makefile */

	snprintf(tempfname, sizeof(tempfname), ".tmp_%sXXXXXXXXXX", confname);
	if ((fd = mkstemp(tempfname)) == -1 || (f = fdopen(fd, "w")) == NULL) {
		if (fd != -1)
			close(fd);
		perror(tempfname);
		goterror = 1;
		return;
	}
	fprintf(f, ".include \"%s\"\n", path);
	fprintf(f, ".if defined(PROG) && !defined(OBJS)\n");
	fprintf(f, "OBJS=${PROG}.o\n");
	fprintf(f, ".endif\n");
	fprintf(f, "crunchgen_objs:\n\t@@echo 'OBJS= '${OBJS}\n");
	fclose(f);

	snprintf(line, sizeof(line), "make -f %s crunchgen_objs 2>&1", tempfname);
	if ((f = popen(line, "r")) == NULL) {
		perror("submake pipe");
		goterror = 1;
		return;
	}
	while (fgets(line, MAXLINELEN, f)) {
		if (strncmp(line, "OBJS= ", 6)) {
			if (strcmp(line,
			    "sh: warning: running as root with dot in PATH\n") == 0)
				continue;
			fprintf(stderr, "make error: %s", line);
			goterror = 1;
			continue;
		}
		cp = line + 6;
		while (isspace(*cp))
			cp++;
		while (*cp) {
			obj = cp;
			while (*cp && !isspace(*cp))
				cp++;
			if (*cp)
				*cp++ = '\0';
			add_string(&p->objs, obj);
			while (isspace(*cp))
				cp++;
		}
	}
	if ((rc = pclose(f)) != 0) {
		fprintf(stderr, "make error: make returned %d\n", rc);
		goterror = 1;
	}
	unlink(tempfname);
}

void 
remove_error_progs(void)
{
	prog_t         *p1, *p2;

	p1 = NULL;
	p2 = progs;
	while (p2 != NULL) {
		if (!p2->goterror)
			p1 = p2, p2 = p2->next;
		else {
			/* delete it from linked list */
			fprintf(stderr, "%s: %s: ignoring program because of errors.\n",
			    infilename, p2->name);
			if (p1)
				p1->next = p2->next;
			else
				progs = p2->next;
			p2 = p2->next;
		}
	}
}

void 
gen_specials_cache(void)
{
	FILE           *cachef;
	prog_t         *p;

	snprintf(line, sizeof(line), "generating %s", cachename);
	status(line);

	if ((cachef = fopen(cachename, "w")) == NULL) {
		perror(cachename);
		goterror = 1;
		return;
	}
	fprintf(cachef, "# %s - parm cache generated from %s by crunchgen %s\n\n",
	    cachename, infilename, CRUNCH_VERSION);

	for (p = progs; p != NULL; p = p->next) {
		fprintf(cachef, "\n");
		if (p->srcdir)
			fprintf(cachef, "special %s srcdir %s\n", p->name, p->srcdir);
		if (p->mf_name)
			fprintf(cachef, "special %s mf_name %s\n", p->name, p->mf_name);
		if (p->objdir)
			fprintf(cachef, "special %s objdir %s\n", p->name, p->objdir);
		if (p->objs) {
			fprintf(cachef, "special %s objs", p->name);
			output_strlst(cachef, p->objs);
		}
		fprintf(cachef, "special %s objpaths", p->name);
		output_strlst(cachef, p->objpaths);
	}
	fclose(cachef);
}

void 
gen_output_makefile(void)
{
	prog_t         *p;
	FILE           *outmk;

	snprintf(line, sizeof(line), "generating %s", outmkname);
	status(line);

	if ((outmk = fopen(outmkname, "w")) == NULL) {
		perror(outmkname);
		goterror = 1;
		return;
	}
	fprintf(outmk, "# %s - generated from %s by crunchgen %s\n\n",
	    outmkname, infilename, CRUNCH_VERSION);

	top_makefile_rules(outmk);

	for (p = progs; p != NULL; p = p->next)
		prog_makefile_rules(outmk, p);

	fprintf(outmk, "\n# ========\n");
	fclose(outmk);
}

void 
gen_output_cfile(void)
{
	extern char    *crunched_skel[];
	char          **cp;
	FILE           *outcf;
	prog_t         *p;
	strlst_t       *s;

	snprintf(line, sizeof(line), "generating %s", outcfname);
	status(line);

	if ((outcf = fopen(outcfname, "w")) == NULL) {
		perror(outcfname);
		goterror = 1;
		return;
	}
	fprintf(outcf, "/* %s - generated from %s by crunchgen %s */\n",
	    outcfname, infilename, CRUNCH_VERSION);

	fprintf(outcf, "#define EXECNAME \"%s\"\n", execfname);
	for (cp = crunched_skel; *cp != NULL; cp++)
		fprintf(outcf, "%s\n", *cp);

	for (p = progs; p != NULL; p = p->next)
		fprintf(outcf, "extern int _crunched_%s_stub();\n", p->ident);

	fprintf(outcf, "\nstruct stub entry_points[] = {\n");
	for (p = progs; p != NULL; p = p->next) {
		fprintf(outcf, "\t{ \"%s\", _crunched_%s_stub },\n",
			p->name, p->ident);
		for (s = p->links; s != NULL; s = s->next)
			fprintf(outcf, "\t{ \"%s\", _crunched_%s_stub },\n",
				s->str, p->ident);
	}

	fprintf(outcf, "\t{ EXECNAME, crunched_main },\n");
	fprintf(outcf, "\t{ NULL, NULL }\n};\n");
	fclose(outcf);
}

char           *
genident(char *str)
{
	char           *n, *s, *d;

	/*
         * generates a Makefile/C identifier from a program name, mapping '-' to
         * '_' and ignoring all other non-identifier characters.  This leads to
         * programs named "foo.bar" and "foobar" to map to the same identifier.
         */

	if ((n = strdup(str)) == NULL)
		return NULL;
	for (d = s = n; *s != '\0'; s++) {
		if (*s == '-')
			*d++ = '_';
		else if (*s == '_' || isalnum(*s))
			*d++ = *s;
	}
	*d = '\0';
	return n;
}

char           *
dir_search(char *progname)
{
	char            path[MAXPATHLEN];
	strlst_t       *dir;

	for (dir = srcdirs; dir != NULL; dir = dir->next) {
		snprintf(path, sizeof(path), "%s/%s", dir->str, progname);
		if (is_dir(path))
			return dir->str;
	}
	return NULL;
}

void 
top_makefile_rules(FILE * outmk)
{
	prog_t         *p;
	strlst_t       *l;


	fprintf(outmk, "STRIP?=strip\n");
	fprintf(outmk, "LINK=$(LD) -dc -r\n");
	fprintf(outmk, "LIBS=");
	for (l = libdirs; l != NULL; l = l->next)
		fprintf(outmk, " -L%s", l->str);
	output_strlst(outmk, libs);

	fprintf(outmk, "CRUNCHED_OBJS=");
	for (p = progs; p != NULL; p = p->next)
		fprintf(outmk, " %s.lo", p->name);
	fprintf(outmk, "\n");

	fprintf(outmk, "SUBMAKE_TARGETS=");
	for (p = progs; p != NULL; p = p->next)
		fprintf(outmk, " %s_make", p->ident);
	fprintf(outmk, "\n\n");

	fprintf(outmk, "%s: %s.o $(CRUNCHED_OBJS)\n",
	    execfname, execfname);
	fprintf(outmk, "\t$(CC) -static -o $@@ %s.o $(CRUNCHED_OBJS) $(LIBS)\n",
	    execfname);
	fprintf(outmk, "\t$(STRIP) %s\n", execfname);
	fprintf(outmk, "all: objs exe\nobjs: $(SUBMAKE_TARGETS)\n");
	fprintf(outmk, "exe: %s\n", execfname);
	fprintf(outmk, "clean:\n\trm -f %s *.lo *.o *_stub.c\n",
	    execfname);
	fprintf(outmk, ".PHONY: all objs exe clean $(SUBMAKE_TARGETS)\n\n");
}

void 
prog_makefile_rules(FILE * outmk, prog_t * p)
{
	fprintf(outmk, "\n# -------- %s\n\n", p->name);

	if (p->srcdir && p->objs) {
		fprintf(outmk, "%s_SRCDIR=%s\n", p->ident, p->srcdir);
		fprintf(outmk, "%s_OBJS=", p->ident);
		output_strlst(outmk, p->objs);
		fprintf(outmk, "%s_make:\n", p->ident);
		fprintf(outmk, "\tcd $(%s_SRCDIR) && exec $(MAKE) -f %s $(%s_OBJS)\n\n",
		    p->ident, p->mf_name, p->ident);
	} else
		fprintf(outmk, "%s_make:\n\t@@echo \"** cannot make objs for %s\"\n\n",
		    p->ident, p->name);

	fprintf(outmk, "%s_OBJPATHS=", p->ident);
	output_strlst(outmk, p->objpaths);

	fprintf(outmk, "%s_stub.c:\n", p->name);
	fprintf(outmk, "\techo \""
	    "int _crunched_%s_stub(int argc, char **argv, char **envp)"
	    "{return main(argc,argv,envp);}\" >$@@\n",
	    p->ident);
	fprintf(outmk, "%s.lo: %s_stub.o $(%s_OBJPATHS)\n",
	    p->name, p->name, p->ident);
	fprintf(outmk, "\t$(LINK) -o $@@ %s_stub.o $(%s_OBJPATHS)\n",
	    p->name, p->ident);
	fprintf(outmk, "\tcrunchide -k %s_crunched_%s_stub $@@\n",
	    elf_names ? "" : "_", p->ident);
}

void 
output_strlst(FILE * outf, strlst_t * lst)
{
	for (; lst != NULL; lst = lst->next)
		fprintf(outf, " %s", lst->str);
	fprintf(outf, "\n");
}

void 
status(char *str)
{
	static int      lastlen = 0;
	int             len, spaces;

	if (!verbose)
		return;

	len = strlen(str);
	spaces = lastlen - len;
	if (spaces < 1)
		spaces = 1;

	fprintf(stderr, " [%s]%*.*s\r", str, spaces, spaces, " ");
	fflush(stderr);
	lastlen = len;
}

void 
out_of_memory(void)
{
	fprintf(stderr, "%s: %d: out of memory, stopping.\n", infilename, linenum);
	exit(1);
}

void 
add_string(strlst_t ** listp, char *str)
{
	strlst_t       *p1, *p2;

	/* add to end, but be smart about dups */

	for (p1 = NULL, p2 = *listp; p2 != NULL; p1 = p2, p2 = p2->next)
		if (!strcmp(p2->str, str))
			return;

	p2 = calloc(1, sizeof(strlst_t));
	if (p2)
		p2->str = strdup(str);
	if (!p2 || !p2->str)
		out_of_memory();

	p2->next = NULL;
	if (p1 == NULL)
		*listp = p2;
	else
		p1->next = p2;
}

int 
is_dir(char *pathname)
{
	struct stat     buf;

	if (stat(pathname, &buf) == -1)
		return 0;
	return S_ISDIR(buf.st_mode);
}

int 
is_nonempty_file(char *pathname)
{
	struct stat     buf;

	if (stat(pathname, &buf) == -1)
		return 0;

	return S_ISREG(buf.st_mode) && buf.st_size > 0;
}
@


1.28
log
@fix usage messages
@
text
@d1 1
a1 1
/* $OpenBSD: crunchgen.c,v 1.27 2006/10/25 01:53:19 drahn Exp $	 */
@


1.27
log
@-O objdir diff missed a piece.
@
text
@d1 1
a1 1
/* $OpenBSD: crunchgen.c,v 1.26 2006/10/15 06:44:13 jmc Exp $	 */
d218 2
a219 1
	fprintf(stderr, "%s [-Efq] [-c c-file-name] [-D src-root] [-e exec-file-name]\n"
@


1.26
log
@tidy usage();
@
text
@d1 1
a1 1
/* $OpenBSD: crunchgen.c,v 1.25 2006/10/14 20:23:29 drahn Exp $	 */
d403 2
a404 1
			snprintf(tmppath2, sizeof(tmppath2), "%s/obj", tmppath);
@


1.25
log
@Add a new option to crunchgen '-O objdir-name' which allow for a object
directory other than the previously  hardcoded 'obj' to be specified.
Allows for cross building of ramdisks (down the road).
@
text
@d1 1
a1 1
/* $OpenBSD: crunchgen.c,v 1.24 2006/02/06 16:49:31 jmc Exp $	 */
d219 1
a219 1
	    "\t[-L lib-dir] [-m makefile-name] [-O objdir-name ] conf-file\n",
@


1.24
log
@typos from alexey dobriyan;
@
text
@d1 1
a1 1
/* $OpenBSD: crunchgen.c,v 1.23 2005/08/03 22:39:54 espie Exp $	 */
d88 1
d129 1
a129 1
	while ((optc = getopt(argc, argv, "m:c:e:fqD:EL:")) != -1) {
d166 5
d219 1
a219 1
	    "\t[-L lib-dir] [-m makefile-name] conf-file\n",
d607 1
a607 1
		snprintf(path, sizeof(path), "%s/obj", p->srcdir);
d880 1
a880 1
	fprintf(outmk, "STRIP=strip\n");
@


1.23
log
@document cache file name,
more use of $@@, use exec where appropriate.
okay deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: crunchgen.c,v 1.22 2005/08/02 11:25:05 espie Exp $	 */
d612 1
a612 1
	/* We have a sourcedir and no explict objs, try */
@


1.22
log
@New keyword: libdirs, to be able to specify alternate places to
look for libraries. Uses the same mechanism as srcdirs.

While in there, make extensive use of $@@ to simplify the Makefile,
introduce LINK macro to clarify things, replace
(cd dir; make -f Makefile target) with cd dir && ${MAKE} -f Makefile target
which is slightly more correct and uses the right make.
Add .PHONY targets.

comments by millert@@, okay deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: crunchgen.c,v 1.21 2004/08/24 09:11:39 jmc Exp $	 */
d45 1
a45 1
#define CRUNCH_VERSION	"0.2"
d913 1
a913 1
		fprintf(outmk, "\tcd $(%s_SRCDIR) && $(MAKE) -f %s $(%s_OBJS)\n\n",
d925 2
a926 2
	    "{return main(argc,argv,envp);}\" >%s_stub.c\n",
	    p->ident, p->name);
@


1.21
log
@- `conf-file' arg is not optional (from netbsd)
- sort SYNOPSIS and options list
- kill .Pp before a display
- sync usage()
@
text
@d1 1
a1 1
/* $OpenBSD: crunchgen.c,v 1.20 2003/01/27 19:41:30 deraadt Exp $	 */
d87 1
a95 1
char            libdir[MAXPATHLEN] = "/usr/lib";
d161 1
a161 1
			if (strlcpy(libdir, optarg, sizeof(libdir)) >= sizeof(libdir))
d163 1
d176 2
d224 1
d278 2
d368 51
d871 2
d875 1
d877 2
a878 1
	fprintf(outmk, "-L%s ", libdir);
d893 2
a894 2
	fprintf(outmk, "\t$(CC) -static -o %s %s.o $(CRUNCHED_OBJS) $(LIBS)\n",
	    execfname, execfname);
d900 1
d913 1
a913 1
		fprintf(outmk, "\t(cd $(%s_SRCDIR); make -f %s $(%s_OBJS))\n\n",
d929 4
a932 4
	fprintf(outmk, "\t${LD} -dc -r -o %s.lo %s_stub.o $(%s_OBJPATHS)\n",
	    p->name, p->name, p->ident);
	fprintf(outmk, "\tcrunchide -k %s_crunched_%s_stub %s.lo\n",
	    elf_names ? "" : "_", p->ident, p->name);
@


1.20
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: crunchgen.c,v 1.19 2002/06/09 05:53:53 todd Exp $	 */
d209 2
a210 2
	fprintf(stderr, "%s [-fq] [-m <makefile>] [-c <c file>] "
	    "[-e <exec file>] <conffile>\n",
@


1.19
log
@knf
@
text
@d1 2
a2 1
/*	$OpenBSD: crunchgen.c,v 1.18 2000/11/24 04:18:20 millert Exp $	*/
d56 1
a56 1
char  *mf_name[] = {
d58 1
a58 1
     MF_NAMES,
d60 1
a60 1
    "Makefile",
d62 1
a62 1
    NULL
d70 2
a71 2
    struct strlst *next;
    char *str;
d77 6
a82 6
    struct prog *next;
    char *name, *ident, *mf_name;
    char *srcdir, *objdir;
    strlst_t *objs, *objpaths;
    strlst_t *links;
    int goterror;
d85 127
a211 150

/* global state */

strlst_t *srcdirs = NULL;
strlst_t *libs    = NULL;
prog_t   *progs   = NULL;

char line[MAXLINELEN];

char confname[MAXPATHLEN], infilename[MAXPATHLEN];
char outmkname[MAXPATHLEN], outcfname[MAXPATHLEN], execfname[MAXPATHLEN];
char cachename[MAXPATHLEN], curfilename[MAXPATHLEN];
char topdir[MAXPATHLEN];
char libdir[MAXPATHLEN] = "/usr/lib";
int linenum = -1;
int goterror = 0;

char *pname = "crunchgen";

int verbose, readcache, elf_names;	/* options */
int reading_cache;

/* general library routines */

void status(char *str);
void out_of_memory(void);
void add_string(strlst_t **listp, char *str);
int is_dir(char *pathname);
int is_nonempty_file(char *pathname);

/* helper routines for main() */

void usage(void);			
void parse_conf_file(void);
void gen_outputs(void);


int main(int argc, char **argv)
{
    char *p;
    int optc;
    extern int optind;
    extern char *optarg;

    verbose = 1;
    readcache = 1;
    *outmkname = *outcfname = *execfname = '\0';

    if(argc > 0) pname = argv[0];

    while((optc = getopt(argc, argv, "m:c:e:fqD:EL:")) != -1) {
	switch(optc) {
	case 'f':	readcache = 0; break;
	case 'q':	verbose = 0; break;

	case 'm':
	  if (strlcpy(outmkname, optarg, sizeof(outmkname)) >=
	      sizeof(outmkname))
	    usage();
	  break;
	case 'c':
	  if (strlcpy(outcfname, optarg, sizeof(outcfname)) >=
	      sizeof(outcfname))
	    usage();
	  break;
	case 'e':
	  if (strlcpy(execfname, optarg, sizeof(execfname)) >=
	      sizeof(execfname))
	    usage();
	  break;

	case 'D':
	  if (strlcpy(topdir, optarg, sizeof(topdir)) >= sizeof(topdir))
	    usage();
	  break;
	case 'E':	elf_names = 1; break;
	case 'L':
	  if (strlcpy(libdir, optarg, sizeof(libdir)) >= sizeof(libdir))
	    usage();
	  break;
	case '?':
	default:	usage();
	}
    }

    argc -= optind;
    argv += optind;

    if(argc != 1) usage();

    /*
     * generate filenames
     */

    if (strlcpy(infilename, argv[0], sizeof(infilename)) >=
	sizeof(infilename))
      usage();

    /* confname = `basename infilename .conf` */

    if((p=strrchr(infilename, '/')) != NULL) strcpy(confname, p+1);
    else strcpy(confname, infilename);
    if((p=strrchr(confname, '.')) != NULL && !strcmp(p, ".conf")) *p = '\0';

    if(!*outmkname) snprintf(outmkname, sizeof(outmkname), "%s.mk", confname);
    if(!*outcfname) snprintf(outcfname, sizeof(outcfname), "%s.c", confname);
    if(!*execfname) snprintf(execfname, sizeof(execfname), "%s", confname);
    snprintf(cachename, sizeof(cachename), "%s.cache", confname);

    parse_conf_file();
    gen_outputs();

    exit(goterror);
}


void usage(void)
{
    fprintf(stderr,
	"%s [-fq] [-m <makefile>] [-c <c file>] [-e <exec file>] <conffile>\n",
	    pname);
    exit(1);
}


/*
 * ========================================================================
 * parse_conf_file subsystem
 *
 */

/* helper routines for parse_conf_file */

void parse_one_file(char *filename);
void parse_line(char *line, int *fc, char **fv, int nf);
void add_srcdirs(int argc, char **argv);
void add_progs(int argc, char **argv);
void add_link(int argc, char **argv);
void add_libs(int argc, char **argv);
void add_special(int argc, char **argv);

prog_t *find_prog(char *str);
void add_prog(char *progname);


void parse_conf_file(void)
{
    if(!is_nonempty_file(infilename)) {
	fprintf(stderr, "%s: fatal: input file \"%s\" not found.\n",
		pname, infilename);
a212 6
    }
    parse_one_file(infilename);
    if(readcache && is_nonempty_file(cachename)) {
	reading_cache = 1;
	parse_one_file(cachename);
    }
d215 252
a466 82

void parse_one_file(char *filename)
{
    char *fieldv[MAXFIELDS];
    int fieldc;
    void (*f)(int c, char **v);
    FILE *cf;

    snprintf(line, sizeof(line), "reading %s", filename);
    status(line);
    strcpy(curfilename, filename);

    if((cf = fopen(curfilename, "r")) == NULL) {
	perror(curfilename);
	goterror = 1;
	return;
    }

    linenum = 0;
    while(fgets(line, MAXLINELEN, cf) != NULL) {
	linenum++;
	parse_line(line, &fieldc, fieldv, MAXFIELDS);
	if(fieldc < 1) continue;
	if(!strcmp(fieldv[0], "srcdirs"))	f = add_srcdirs;
	else if(!strcmp(fieldv[0], "progs"))    f = add_progs;
	else if(!strcmp(fieldv[0], "ln"))	f = add_link;
	else if(!strcmp(fieldv[0], "libs"))	f = add_libs;
	else if(!strcmp(fieldv[0], "special"))	f = add_special;
	else {
	    fprintf(stderr, "%s:%d: skipping unknown command `%s'.\n",
		    curfilename, linenum, fieldv[0]);
	    goterror = 1;
	    continue;
	}
	if(fieldc < 2) {
	    fprintf(stderr,
		    "%s:%d: %s command needs at least 1 argument, skipping.\n",
		    curfilename, linenum, fieldv[0]);
	    goterror = 1;
	    continue;
	}
	f(fieldc, fieldv);
    }

    if(ferror(cf)) {
	perror(curfilename);
	goterror = 1;
    }
    fclose(cf);
}


void parse_line(char *line, int *fc, char **fv, int nf)
{
    char *p;

    p = line;
    *fc = 0;
    while(1) {
	while(isspace(*p)) p++;
	if(*p == '\0' || *p == '#') break;

	if(*fc < nf) fv[(*fc)++] = p;
	while(*p && !isspace(*p) && *p != '#') p++;
	if(*p == '\0' || *p == '#') break;
	*p++ = '\0';
    }
    if(*p) *p = '\0';		/* needed for '#' case */
}


void add_srcdirs(int argc, char **argv)
{
    int i;
    char tmppath[MAXPATHLEN];
    int overflow;

    for(i=1;i<argc;i++) {
        overflow = 0;
        if (argv[i][0] == '/' || topdir[0] == '\0') {
	     if (strlcpy(tmppath, argv[i], sizeof(tmppath)) >= sizeof(tmppath))
	       overflow = 1;
d468 3
a470 4
	     if (strlcpy(tmppath, topdir, sizeof(tmppath)) >= sizeof(tmppath)||
		 strlcat(tmppath, "/", sizeof(tmppath)) >= sizeof(tmppath) ||
		 strlcat(tmppath, argv[i], sizeof(tmppath)) >= sizeof(tmppath))
	       overflow = 1;
d472 1
a472 34
	if (overflow) {
	     goterror = 1;
	     fprintf(stderr, "%s:%d: `%.40s...' is too long, skipping it.\n",
		     curfilename, linenum, argv[i]);
	     continue;
	}
	if(is_dir(tmppath))
	    add_string(&srcdirs, tmppath);
	else {
	    fprintf(stderr, "%s:%d: `%s' is not a directory, skipping it.\n",
		    curfilename, linenum, tmppath);
	    goterror = 1;
	}
    }
}


void add_progs(int argc, char **argv)
{
    int i;

    for(i=1;i<argc;i++)
	add_prog(argv[i]);
}


void add_prog(char *progname)
{
    prog_t *p1, *p2;

    /* add to end, but be smart about dups */

    for(p1 = NULL, p2 = progs; p2 != NULL; p1 = p2, p2 = p2->next)
	if(!strcmp(p2->name, progname)) return;
d474 1
a474 21
    p2 = calloc(1, sizeof(prog_t));
    if(p2) p2->name = strdup(progname);
    if(!p2 || !p2->name)
	out_of_memory();

    p2->next = NULL;
    if(p1 == NULL) progs = p2;
    else p1->next = p2;

    p2->ident = p2->srcdir = p2->objdir = NULL;
    p2->links = p2->objs = NULL;
    p2->goterror = 0;
}


void add_link(int argc, char **argv)
{
    int i;
    prog_t *p = find_prog(argv[1]);

    if(p == NULL) {
d476 2
a477 2
		"%s:%d: no prog %s previously declared, skipping link.\n",
		curfilename, linenum, argv[1]);
a478 4
	return;
    }
    for(i=2;i<argc;i++)
	add_string(&p->links, argv[i]);
d481 2
a482 2

void add_libs(int argc, char **argv)
d484 1
a484 1
    int i;
d486 4
a489 2
    for(i=1;i<argc;i++)
	add_string(&libs, argv[i]);
d492 26
a517 8

void add_special(int argc, char **argv)
{
    int i;
    prog_t *p = find_prog(argv[1]);

    if(p == NULL) {
	if(reading_cache) return;
a518 98
		"%s:%d: no prog %s previously declared, skipping special.\n",
		curfilename, linenum, argv[1]);
	goterror = 1;
	return;
    }

    if(!strcmp(argv[2], "ident")) {
	if(argc != 4) goto argcount;
	if((p->ident = strdup(argv[3])) == NULL)
	    out_of_memory();
    }
    else if(!strcmp(argv[2], "srcdir")) {
	if(argc != 4) goto argcount;
	if((p->srcdir = strdup(argv[3])) == NULL)
	    out_of_memory();
    }
    else if(!strcmp(argv[2], "mf_name")) {
	if(argc != 4) goto argcount;
	if((p->mf_name = strdup(argv[3])) == NULL)
	    out_of_memory();
    }
    else if(!strcmp(argv[2], "objdir")) {
	if(argc != 4) goto argcount;
	if((p->objdir = strdup(argv[3])) == NULL)
	    out_of_memory();
    }
    else if(!strcmp(argv[2], "objs")) {
	p->objs = NULL;
	for(i=3;i<argc;i++)
	    add_string(&p->objs, argv[i]);
    }
    else if(!strcmp(argv[2], "objpaths")) {
	p->objpaths = NULL;
	for(i=3;i<argc;i++)
	    add_string(&p->objpaths, argv[i]);
    }
    else {
	fprintf(stderr, "%s:%d: bad parameter name `%s', skipping line.\n",
		curfilename, linenum, argv[2]);
	goterror = 1;
    }
    return;


 argcount:
    fprintf(stderr,
	    "%s:%d: too %s arguments, expected \"special %s %s <string>\".\n",
	    curfilename, linenum, argc < 4? "few" : "many", argv[1], argv[2]);
    goterror = 1;
}


prog_t *find_prog(char *str)
{
    prog_t *p;

    for(p = progs; p != NULL; p = p->next)
	if(!strcmp(p->name, str)) return p;

    return NULL;
}


/*
 * ========================================================================
 * gen_outputs subsystem
 *
 */

/* helper subroutines */

void remove_error_progs(void);
void fillin_program(prog_t *p);
void gen_specials_cache(void);
void gen_output_makefile(void);
void gen_output_cfile(void);

void fillin_program_objs(prog_t *p, char *path);
void top_makefile_rules(FILE *outmk);
void prog_makefile_rules(FILE *outmk, prog_t *p);
void output_strlst(FILE *outf, strlst_t *lst);
char *genident(char *str);
char *dir_search(char *progname);


void gen_outputs(void)
{
    prog_t *p;

    for(p = progs; p != NULL; p = p->next)
	fillin_program(p);

    remove_error_progs();
    gen_specials_cache();
    gen_output_cfile();
    gen_output_makefile();
    status("");
    fprintf(stderr,
d523 2
a524 128

void fillin_program(prog_t *p)
{
    char path[MAXPATHLEN];
    char *srcparent;
    strlst_t *s;
    int i;

    snprintf(line, sizeof(line), "filling in parms for %s", p->name);
    status(line);

    if(!p->ident)
	p->ident = genident(p->name);
    if(!p->srcdir) {
	srcparent = dir_search(p->name);
	if(srcparent)
	    snprintf(path, sizeof(path), "%s/%s", srcparent, p->name);
	if(is_dir(path))
	    p->srcdir = strdup(path);
    }
    if(!p->objdir && p->srcdir) {
	snprintf(path, sizeof(path), "%s/obj", p->srcdir);
	if(is_dir(path))
	    p->objdir = strdup(path);
	else {
	    snprintf(path, sizeof(path), "%s/obj.%s", p->srcdir, MACHINE);
	    if(is_dir(path))
		p->objdir = strdup(path);
	    else
		p->objdir = p->srcdir;
	}
    }

    /* We have a sourcedir and no explict objs, try */
    /* to find makefile and get objs from it. */
    if (p->srcdir && !p->objs) {
	for (i = 0; mf_name[i] != NULL; i++) {
	    snprintf(path, sizeof(path), "%s/%s", p->srcdir, mf_name[i]);
	    if (is_nonempty_file(path)) {
		p->mf_name = mf_name[i];
		fillin_program_objs(p, path);
		break;
	    }
	}
    }




    if(!p->objpaths && p->objdir && p->objs)
	for(s = p->objs; s != NULL; s = s->next) {
	    snprintf(line, sizeof(line), "%s/%s", p->objdir, s->str);
	    add_string(&p->objpaths, line);
	}

    if(!p->srcdir && verbose)
	fprintf(stderr, "%s: %s: warning: could not find source directory.\n",
		infilename, p->name);
    if(!p->objs && verbose)
	fprintf(stderr, "%s: %s: warning: could not find any .o files.\n",
		infilename, p->name);

    if(!p->objpaths) {
	fprintf(stderr,
		"%s: %s: error: no objpaths specified or calculated.\n",
		infilename, p->name);
	p->goterror = goterror = 1;
    }
}

void fillin_program_objs(prog_t *p, char *path)
{
    char *cp, *obj, tempfname[MAXPATHLEN];
    int fd, rc;
    FILE *f;

    /* discover the objs from the srcdir Makefile */

    snprintf(tempfname, sizeof(tempfname), ".tmp_%sXXXXXXXXXX", confname);
    if ((fd = mkstemp(tempfname)) == -1 || (f = fdopen(fd, "w")) == NULL) {
	if (fd != -1)
	    close(fd);
	perror(tempfname);
	goterror = 1;
	return;
    }
	
    fprintf(f, ".include \"%s\"\n", path);
    fprintf(f, ".if defined(PROG) && !defined(OBJS)\n");
    fprintf(f, "OBJS=${PROG}.o\n");
    fprintf(f, ".endif\n");
    fprintf(f, "crunchgen_objs:\n\t@@echo 'OBJS= '${OBJS}\n");
    fclose(f);

    snprintf(line, sizeof(line), "make -f %s crunchgen_objs 2>&1", tempfname);
    if((f = popen(line, "r")) == NULL) {
	perror("submake pipe");
	goterror = 1;
	return;
    }

    while(fgets(line, MAXLINELEN, f)) {
	if(strncmp(line, "OBJS= ", 6)) {
	    if (strcmp(line,
	   	"sh: warning: running as root with dot in PATH\n") == 0)
		    continue;
	    fprintf(stderr, "make error: %s", line);
	    goterror = 1;	
	    continue;
	}
	cp = line + 6;
	while(isspace(*cp)) cp++;
	while(*cp) {
	    obj = cp;
	    while(*cp && !isspace(*cp)) cp++;
	    if(*cp) *cp++ = '\0';
	    add_string(&p->objs, obj);
	    while(isspace(*cp)) cp++;
	}
    }
    if((rc=pclose(f)) != 0) {
	fprintf(stderr, "make error: make returned %d\n", rc);
	goterror = 1;
    }
    unlink(tempfname);
}

void remove_error_progs(void)
d526 158
a683 13
    prog_t *p1, *p2;

    p1 = NULL; p2 = progs;
    while(p2 != NULL) {
	if(!p2->goterror)
	    p1 = p2, p2 = p2->next;
	else {
	    /* delete it from linked list */
	    fprintf(stderr, "%s: %s: ignoring program because of errors.\n",
		    infilename, p2->name);
	    if(p1) p1->next = p2->next;
	    else progs = p2->next;
	    p2 = p2->next;
d685 1
a685 18
    }
}

void gen_specials_cache(void)
{
    FILE *cachef;
    prog_t *p;

    snprintf(line, sizeof(line), "generating %s", cachename);
    status(line);

    if((cachef = fopen(cachename, "w")) == NULL) {
	perror(cachename);
	goterror = 1;
	return;
    }

    fprintf(cachef, "# %s - parm cache generated from %s by crunchgen %s\n\n",
d688 33
a720 34
    for(p = progs; p != NULL; p = p->next) {
	fprintf(cachef, "\n");
	if(p->srcdir)
	    fprintf(cachef, "special %s srcdir %s\n", p->name, p->srcdir);
	if(p->mf_name)
	    fprintf(cachef, "special %s mf_name %s\n", p->name, p->mf_name);
	if(p->objdir)
	    fprintf(cachef, "special %s objdir %s\n", p->name, p->objdir);
	if(p->objs) {
	    fprintf(cachef, "special %s objs", p->name);
	    output_strlst(cachef, p->objs);
	}
	fprintf(cachef, "special %s objpaths", p->name);
	output_strlst(cachef, p->objpaths);
    }
    fclose(cachef);
}


void gen_output_makefile(void)
{
    prog_t *p;
    FILE *outmk;

    snprintf(line, sizeof(line), "generating %s", outmkname);
    status(line);

    if((outmk = fopen(outmkname, "w")) == NULL) {
	perror(outmkname);
	goterror = 1;
	return;
    }

    fprintf(outmk, "# %s - generated from %s by crunchgen %s\n\n",
d723 1
a723 1
    top_makefile_rules(outmk);
d725 2
a726 2
    for(p = progs; p != NULL; p = p->next)
	prog_makefile_rules(outmk, p);
d728 2
a729 2
    fprintf(outmk, "\n# ========\n");
    fclose(outmk);
d732 2
a733 2

void gen_output_cfile(void)
d735 5
a739 5
    extern char *crunched_skel[];
    char **cp;
    FILE *outcf;
    prog_t *p;
    strlst_t *s;
d741 2
a742 2
    snprintf(line, sizeof(line), "generating %s", outcfname);
    status(line);
d744 6
a749 8
    if((outcf = fopen(outcfname, "w")) == NULL) {
	perror(outcfname);
	goterror = 1;
	return;
    }

    fprintf(outcf,
	  "/* %s - generated from %s by crunchgen %s */\n",
d752 3
a754 3
    fprintf(outcf, "#define EXECNAME \"%s\"\n", execfname);
    for(cp = crunched_skel; *cp != NULL; cp++)
	fprintf(outcf, "%s\n", *cp);
d756 2
a757 2
    for(p = progs; p != NULL; p = p->next)
	fprintf(outcf, "extern int _crunched_%s_stub();\n", p->ident);
d759 8
a766 8
    fprintf(outcf, "\nstruct stub entry_points[] = {\n");
    for(p = progs; p != NULL; p = p->next) {
	fprintf(outcf, "\t{ \"%s\", _crunched_%s_stub },\n",
		p->name, p->ident);
	for(s = p->links; s != NULL; s = s->next)
	    fprintf(outcf, "\t{ \"%s\", _crunched_%s_stub },\n",
		    s->str, p->ident);
    }
d768 3
a770 3
    fprintf(outcf, "\t{ EXECNAME, crunched_main },\n");
    fprintf(outcf, "\t{ NULL, NULL }\n};\n");
    fclose(outcf);
d773 2
a774 2

char *genident(char *str)
d776 1
a776 1
    char *n,*s,*d;
d778 5
a782 5
    /*
     * generates a Makefile/C identifier from a program name, mapping '-' to
     * '_' and ignoring all other non-identifier characters.  This leads to
     * programs named "foo.bar" and "foobar" to map to the same identifier.
     */
d784 10
a793 8
    if((n = strdup(str)) == NULL)
	return NULL;
    for(d = s = n; *s != '\0'; s++) {
	if(*s == '-') *d++ = '_';
	else if(*s == '_' || isalnum(*s)) *d++ = *s;
    }
    *d = '\0';
    return n;
d796 2
a797 2

char *dir_search(char *progname)
d799 2
a800 2
    char path[MAXPATHLEN];
    strlst_t *dir;
d802 6
a807 5
    for(dir=srcdirs; dir != NULL; dir=dir->next) {
	snprintf(path, sizeof(path), "%s/%s", dir->str, progname);
	if(is_dir(path)) return dir->str;
    }
    return NULL;
d810 2
a811 2

void top_makefile_rules(FILE *outmk)
d813 1
a813 11
    prog_t *p;

    fprintf(outmk, "STRIP=strip\n");
    fprintf(outmk, "LIBS=");
    fprintf(outmk, "-L%s ", libdir);
    output_strlst(outmk, libs);

    fprintf(outmk, "CRUNCHED_OBJS=");
    for(p = progs; p != NULL; p = p->next)
	fprintf(outmk, " %s.lo", p->name);
    fprintf(outmk, "\n");
d815 14
a828 4
    fprintf(outmk, "SUBMAKE_TARGETS=");
    for(p = progs; p != NULL; p = p->next)
	fprintf(outmk, " %s_make", p->ident);
    fprintf(outmk, "\n\n");
d830 1
a830 1
    fprintf(outmk, "%s: %s.o $(CRUNCHED_OBJS)\n",
d832 1
a832 1
    fprintf(outmk, "\t$(CC) -static -o %s %s.o $(CRUNCHED_OBJS) $(LIBS)\n",
d834 4
a837 4
    fprintf(outmk, "\t$(STRIP) %s\n", execfname);
    fprintf(outmk, "all: objs exe\nobjs: $(SUBMAKE_TARGETS)\n");
    fprintf(outmk, "exe: %s\n", execfname);
    fprintf(outmk, "clean:\n\trm -f %s *.lo *.o *_stub.c\n",
d841 2
a842 2

void prog_makefile_rules(FILE *outmk, prog_t *p)
d844 1
a844 1
    fprintf(outmk, "\n# -------- %s\n\n", p->name);
d846 18
a863 19
    if(p->srcdir && p->objs) {
	fprintf(outmk, "%s_SRCDIR=%s\n", p->ident, p->srcdir);
	fprintf(outmk, "%s_OBJS=", p->ident);
	output_strlst(outmk, p->objs);
	fprintf(outmk, "%s_make:\n", p->ident);
	fprintf(outmk, "\t(cd $(%s_SRCDIR); make -f %s $(%s_OBJS))\n\n",
		p->ident, p->mf_name, p->ident);
    }
    else
	fprintf(outmk, "%s_make:\n\t@@echo \"** cannot make objs for %s\"\n\n",
		p->ident, p->name);

    fprintf(outmk,   "%s_OBJPATHS=", p->ident);
    output_strlst(outmk, p->objpaths);

    fprintf(outmk, "%s_stub.c:\n", p->name);
    fprintf(outmk, "\techo \""
		   "int _crunched_%s_stub(int argc, char **argv, char **envp)"
		   "{return main(argc,argv,envp);}\" >%s_stub.c\n",
d865 1
a865 1
    fprintf(outmk, "%s.lo: %s_stub.o $(%s_OBJPATHS)\n",
d867 1
a867 1
    fprintf(outmk, "\t${LD} -dc -r -o %s.lo %s_stub.o $(%s_OBJPATHS)\n",
d869 1
a869 1
    fprintf(outmk, "\tcrunchide -k %s_crunched_%s_stub %s.lo\n",
d873 2
a874 1
void output_strlst(FILE *outf, strlst_t *lst)
d876 3
a878 3
    for(; lst != NULL; lst = lst->next)
	fprintf(outf, " %s", lst->str);
    fprintf(outf, "\n");
d881 2
a882 8

/*
 * ========================================================================
 * general library routines
 *
 */

void status(char *str)
d884 2
a885 2
    static int lastlen = 0;
    int len, spaces;
d887 2
a888 1
    if(!verbose) return;
d890 4
a893 3
    len = strlen(str);
    spaces = lastlen - len;
    if(spaces < 1) spaces = 1;
d895 3
a897 3
    fprintf(stderr, " [%s]%*.*s\r", str, spaces, spaces, " ");
    fflush(stderr);
    lastlen = len;
d900 2
a901 2

void out_of_memory(void)
d903 2
a904 2
    fprintf(stderr, "%s: %d: out of memory, stopping.\n", infilename, linenum);
    exit(1);
d907 2
a908 2

void add_string(strlst_t **listp, char *str)
d910 1
a910 1
    strlst_t *p1, *p2;
d912 1
a912 1
    /* add to end, but be smart about dups */
d914 3
a916 2
    for(p1 = NULL, p2 = *listp; p2 != NULL; p1 = p2, p2 = p2->next)
	if(!strcmp(p2->str, str)) return;
d918 5
a922 4
    p2 = calloc(1,sizeof(strlst_t));
    if(p2) p2->str = strdup(str);
    if(!p2 || !p2->str)
	out_of_memory();
d924 5
a928 3
    p2->next = NULL;
    if(p1 == NULL) *listp = p2;
    else p1->next = p2;
d931 2
a932 2

int is_dir(char *pathname)
d934 1
a934 1
    struct stat buf;
d936 3
a938 3
    if(stat(pathname, &buf) == -1)
	return 0;
    return S_ISDIR(buf.st_mode);
d941 2
a942 1
int is_nonempty_file(char *pathname)
d944 1
a944 1
    struct stat buf;
d946 2
a947 2
    if(stat(pathname, &buf) == -1)
	return 0;
d949 1
a949 1
    return S_ISREG(buf.st_mode) && buf.st_size > 0;
@


1.18
log
@Remove errant 'continue' statement that breaks absolute paths;
paulc@@passtheaardvark.com
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchgen.c,v 1.17 2000/07/09 19:20:40 marc Exp $	*/
d32 1
a32 1
 * from specs given in a .conf file.  
d131 1
a131 1
    
d140 1
a140 1
	  if (strlcpy(outmkname, optarg, sizeof(outmkname)) >= 
d174 1
a174 1
    /* 
d202 1
a202 1
    fprintf(stderr, 
d218 1
a218 1
void parse_line(char *line, int *fc, char **fv, int nf); 
d278 1
a278 1
	    fprintf(stderr, 
d324 1
a324 1
	       overflow = 1;  
d340 1
a340 1
	    fprintf(stderr, "%s:%d: `%s' is not a directory, skipping it.\n", 
d368 1
a368 1
    if(!p2 || !p2->name) 
d387 1
a387 1
	fprintf(stderr, 
d414 1
a414 1
	fprintf(stderr, 
d460 1
a460 1
    fprintf(stderr, 
d512 1
a512 1
    fprintf(stderr, 
d528 1
a528 1
    if(!p->ident) 
d576 1
a576 1
	fprintf(stderr, "%s: %s: warning: could not find any .o files.\n", 
d580 1
a580 1
	fprintf(stderr, 
d648 2
a649 2
    p1 = NULL; p2 = progs; 
    while(p2 != NULL) { 
d719 1
a719 1
	prog_makefile_rules(outmk, p); 
d743 1
a743 1
    fprintf(outcf, 
d762 1
a762 1
    
d822 1
a822 1
    fprintf(outmk, "%s: %s.o $(CRUNCHED_OBJS)\n", 
d843 1
a843 1
	fprintf(outmk, "\t(cd $(%s_SRCDIR); make -f %s $(%s_OBJS))\n\n", 
d847 1
a847 1
	fprintf(outmk, "%s_make:\n\t@@echo \"** cannot make objs for %s\"\n\n", 
d860 1
a860 1
    fprintf(outmk, "\t${LD} -dc -r -o %s.lo %s_stub.o $(%s_OBJPATHS)\n", 
d862 1
a862 1
    fprintf(outmk, "\tcrunchide -k %s_crunched_%s_stub %s.lo\n", 
@


1.17
log
@
revert previous change: link instbin w/ scrt0, saves a couple of k's
Bad Mickey... you broke the boot floppies.  Thanks to art@@ for
suggesting this might be the problem
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchgen.c,v 1.15 1999/12/06 01:47:58 deraadt Exp $	*/
a324 1
	     continue;
@


1.16
log
@link instbin w/ scrt0, saves a couple of k's
@
text
@d825 2
a826 2
    fprintf(outmk, "\t$(CC) -static -nostdlib -o %s %s.o %s/scrt0.o $(CRUNCHED_OBJS) $(LIBS) -lgcc -lc -lgcc\n",
	    execfname, execfname, libdir);
@


1.15
log
@oflow fixes; provos
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchgen.c,v 1.14 1997/09/07 20:08:53 millert Exp $	*/
d825 2
a826 2
    fprintf(outmk, "\t$(CC) -static -o %s %s.o $(CRUNCHED_OBJS) $(LIBS)\n",
	    execfname, execfname);
@


1.14
log
@Fix misplaced parens.
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchgen.c,v 1.13 1997/09/07 20:03:13 millert Exp $	*/
d139 25
a163 8
	case 'm':	strcpy(outmkname, optarg); break;
	case 'c':	strcpy(outcfname, optarg); break;
	case 'e':	strcpy(execfname, optarg); break;

	case 'D':	strcpy(topdir, optarg); break;
	case 'E' :	elf_names = 1; break;
	case 'L':	strcpy(libdir, optarg); break;

d178 3
a180 1
    strcpy(infilename, argv[0]);
d318 1
d321 16
a336 6
	if (argv[i][0] == '/' || topdir[0] == '\0')
		strcpy(tmppath, argv[i]);
	else {
		strcpy(tmppath, topdir);
		strcat(tmppath, "/");
		strcat(tmppath, argv[i]);
@


1.13
log
@oops, fix typo
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchgen.c,v 1.12 1997/09/07 19:35:08 millert Exp $	*/
d567 1
a567 1
    if ((fd = mkstemp(tempfname) == -1) || (f = fdopen(fd, "w")) == NULL) {
@


1.12
log
@Use mkstemp, not mktemp.  Use snprintf for paranoia.  Thanks to Theo
for noting an fd leak.
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchgen.c,v 1.11 1997/07/23 19:31:51 kstailey Exp $	*/
d34 1
a36 1
#include <stdio.h>
d567 1
a567 1
    if ((fd = mkstemp(tempfname) == -1) || (f = fdopen(fd, f, "w") == NULL)) {
@


1.11
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchgen.c,v 1.10 1997/04/04 21:52:40 mickey Exp $	*/
d95 1
a95 1
char tempfname[MAXPATHLEN], cachename[MAXPATHLEN], curfilename[MAXPATHLEN];
d169 4
a172 10
    if(!*outmkname) sprintf(outmkname, "%s.mk", confname);
    if(!*outcfname) sprintf(outcfname, "%s.c", confname);
    if(!*execfname) sprintf(execfname, "%s", confname);

    sprintf(cachename, "%s.cache", confname);
    sprintf(tempfname, ".tmp_%sXXXXXX", confname);
    if(mktemp(tempfname) == NULL) {
	perror(tempfname);
	exit(1);
    }
d232 1
a232 1
    sprintf(line, "reading %s", filename);
d496 1
a496 1
    sprintf(line, "filling in parms for %s", p->name);
d504 1
a504 1
	    sprintf(path, "%s/%s", srcparent, p->name);
d509 1
a509 1
	sprintf(path, "%s/obj", p->srcdir);
d513 1
a513 1
	    sprintf(path, "%s/obj.%s", p->srcdir, MACHINE);
d525 1
a525 1
	    sprintf(path, "%s/%s", p->srcdir, mf_name[i]);
d539 1
a539 1
	    sprintf(line, "%s/%s", p->objdir, s->str);
d560 2
a561 2
    char *obj, *cp;
    int rc;
d566 4
a569 1
    if((f = fopen(tempfname, "w")) == NULL) {
d582 1
a582 1
    sprintf(line, "make -f %s crunchgen_objs 2>&1", tempfname);
d639 1
a639 1
    sprintf(line, "generating %s", cachename);
d675 1
a675 1
    sprintf(line, "generating %s", outmkname);
d705 1
a705 1
    sprintf(line, "generating %s", outcfname);
d767 1
a767 1
	sprintf(path, "%s/%s", dir->str, progname);
@


1.10
log
@init allocated memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchgen.c,v 1.9 1997/01/31 19:40:42 rahnds Exp $	*/
d523 2
a524 2
	        p->objdir = p->srcdir;
        }
d530 3
a532 3
        for (i = 0; mf_name[i] != NULL; i++) {
            sprintf(path, "%s/%s", p->srcdir, mf_name[i]);
            if (is_nonempty_file(path)) {
d534 4
a537 4
                fillin_program_objs(p, path);
                break;
            }
        }
d829 2
a830 2
	           "int _crunched_%s_stub(int argc, char **argv, char **envp)"
	           "{return main(argc,argv,envp);}\" >%s_stub.c\n",
@


1.9
log
@fix the problem with makefiles in a different way, this steps on the last
commit, but works faster.
Instead of always looking up the makefile and then deciding to
get the objects or not. Cache the makefile name along with the objects.
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchgen.c,v 1.7 1997/01/09 04:09:40 rahnds Exp $	*/
d343 1
a343 1
    p2 = malloc(sizeof(prog_t));
d887 1
a887 1
    p2 = malloc(sizeof(strlst_t));
@


1.8
log
@Even if the objs are cached, we want to find the Makefile
@
text
@d408 5
d527 3
a529 5
    /*
     * We have a sourcedir try to find a makefile and get objs from it,
     * unless we already have objs cached.
     */
    if (p->srcdir) {
d534 1
a534 2
                if (!p->objs)
			fillin_program_objs(p, path);
d658 2
@


1.7
log
@add support for ELF in crunch, for crunchgen this means
do not add a leading underscore to symbol names.
Indicated to crunchgen by a "-E" option.
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchgen.c,v 1.6 1996/09/28 04:30:39 etheisen Exp $	*/
d522 5
a526 3
    /* We have a sourcedir and no explict objs, try */
    /* to find makefile and get objs from it. */
    if (p->srcdir && !p->objs) {
d531 2
a532 1
                fillin_program_objs(p, path);
@


1.6
log
@strdup() not needed for makefile names.
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchgen.c,v 1.5 1996/09/27 06:06:58 etheisen Exp $	*/
d103 1
a103 1
int verbose, readcache;	/* options */
d134 1
a134 1
    while((optc = getopt(argc, argv, "m:c:e:fqD:L:")) != -1) {
d144 1
d827 1
a827 1
    fprintf(outmk, "\tld -dc -r -o %s.lo %s_stub.o $(%s_OBJPATHS)\n", 
d829 2
a830 2
    fprintf(outmk, "\tcrunchide -k __crunched_%s_stub %s.lo\n", 
	    p->ident, p->name);
@


1.5
log
@Cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchgen.c,v 1.4 1996/09/25 06:40:52 etheisen Exp $	*/
d527 1
a527 1
		p->mf_name = strdup(mf_name[i]);
@


1.4
log
@crunchgen needs to explictly use -f filename when building objects.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a520 1
    // emt
@


1.3
log
@Always try Makefile.bsd-wrapper first.  Remove debug.
@
text
@d1 1
d49 14
d77 1
a77 1
    char *name, *ident;
a494 5
    char  *mf_name[] = {
	"Makefile.bsd-wrapper",
	"Makefile",
	NULL
    };
d521 3
a523 3
    /* XXX - This should be runtime configurable */
    // We have a sourcedir and no explict objs, try
    // to get objs from makefile.
d528 1
d810 2
a811 2
	fprintf(outmk, "\t(cd $(%s_SRCDIR); make $(%s_OBJS))\n\n", 
		p->ident, p->ident);
@


1.2
log
@Make crunchgen work with Makefile.bsd-wrapper as well.
@
text
@d481 1
a482 1
	"Makefile.bsd-wrapper",
a516 1
            printf("*** Trying to find %s\n", path);
@


1.1
log
@Initial revision
@
text
@d479 6
d511 16
a526 3
    if(p->srcdir) sprintf(path, "%s/Makefile", p->srcdir);
    if(!p->objs && p->srcdir && is_nonempty_file(path))
	fillin_program_objs(p, path);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
