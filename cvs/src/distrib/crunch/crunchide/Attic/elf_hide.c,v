head	1.13;
access;
symbols
	OPENBSD_4_4:1.12.0.6
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.6
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4;
locks; strict;
comment	@ * @;


1.13
date	2008.08.22.15.18.55;	author deraadt;	state dead;
branches;
next	1.12;

1.12
date	2007.08.14.20.43.10;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.07.05.42.05;	author ray;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.23.02.49.59;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.01.35.30;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.27.19.41.30;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.09.05.53.53;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.23.21.00.20;	author art;	state Exp;
branches;
next	1.5;

1.5
date	97.07.23.19.31.53;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.05.19.09.24.39;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	97.05.06.17.08.29;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.04.04.21.52.42;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.01.09.04.16.52;	author rahnds;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Merge crunchgen & crunchhide (using name checking), and move to usr.sbin
next step is to not install it as two programs, but be even more clever
@
text
@/* $OpenBSD: elf_hide.c,v 1.12 2007/08/14 20:43:10 miod Exp $ */

/*
 * Copyright (c) 1997 Dale Rahn.
 * All rights reserved.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/exec.h>
#ifdef _NLIST_DO_ELF
#include <sys/exec_elf.h>

void	load_strtab(Elf_Ehdr * pehdr, char *pexe);
void	dump_strtab();
char	*get_str(int indx);

void	load_symtab(Elf_Ehdr * pehdr, char *pexe);
void	dump_symtab();

void	load_shstr_tab(Elf_Ehdr * pehdr, char *pexe);
char	*get_shstr(int indx);
void	fprint_shstr(FILE * channel, int indx);

void	hide_sym();
void	reorder_syms(Elf_Ehdr * ehdr, Elf_Shdr * symsect,
	    Elf_Sym * symtab, int symtabsize, int symtabsecnum);
typedef long    Symmap;
void	renum_reloc_syms(Elf_Ehdr * ehdr, Symmap * symmap,
	    int symtabsecnum);


char           *pexe;

void
elf_hide(int pfile, char *p)
{
	int             i;
	Elf_Ehdr       *pehdr;
	Elf_Shdr       *pshdr;
	Elf_Phdr       *pphdr;
	struct stat     sb;

	pexe = p;
	pehdr = (Elf_Ehdr *) pexe;

#ifdef DEBUG
	printf("elf header\n");
	printf("e_type %x\n", pehdr->e_type);
	printf("e_machine %x\n", pehdr->e_machine);
	printf("e_version %x\n", pehdr->e_version);
	printf("e_entry %x\n", pehdr->e_entry);
	printf("e_phoff %x\n", pehdr->e_phoff);
	printf("e_shoff %x\n", pehdr->e_shoff);
	printf("e_flags %x\n", pehdr->e_flags);
	printf("e_ehsize %x\n", pehdr->e_ehsize);
	printf("e_phentsize %x\n", pehdr->e_phentsize);
	printf("e_phnum %x\n", pehdr->e_phnum);
	printf("e_shentsize %x\n", pehdr->e_shentsize);
	printf("e_shnum %x\n", pehdr->e_shnum);
	printf("e_shstrndx %x\n", pehdr->e_shstrndx);
#endif

	load_shstr_tab(pehdr, pexe);
#ifdef DEBUG
	for (i = 0; i < pehdr->e_shnum; i++) {
		pshdr = (Elf_Phdr *) (pexe + pehdr->e_shoff +
		    (i * pehdr->e_shentsize));

		printf("section header %d\n", i);
		printf("sh_name %x ", pshdr->sh_name);
		fprint_shstr(stdout, pshdr->sh_name);
		printf("\n");
		printf("sh_type %x\n", pshdr->sh_type);
		printf("sh_flags %x\n", pshdr->sh_flags);
		printf("sh_addr %x\n", pshdr->sh_addr);
		printf("sh_offset %x\n", pshdr->sh_offset);
		printf("sh_size %x\n", pshdr->sh_size);
		printf("sh_link %x\n", pshdr->sh_link);
		printf("sh_info %x\n", pshdr->sh_info);
		printf("sh_addralign %x\n", pshdr->sh_addralign);
		printf("sh_entsize %x\n", pshdr->sh_entsize);
	}
#endif				/* DEBUG */

#ifdef DEBUG
	for (i = 0; i < pehdr->e_phnum; i++) {
		pshdr = (Elf_Phdr *) (pexe + pehdr->e_phoff +
		    (i * pehdr->e_phentsize));

		printf("program header %d\n", i);
		printf("p_type %x\n", pphdr->p_type);
		printf("p_offset %x\n", pphdr->p_offset);
		printf("p_vaddr %x\n", pphdr->p_vaddr);
		printf("p_paddr %x\n", pphdr->p_paddr);
		printf("p_filesz %x\n", pphdr->p_filesz);
		printf("p_memsz %x\n", pphdr->p_memsz);
		printf("p_flags %x\n", pphdr->p_flags);
		printf("p_align %x\n", pphdr->p_align);
	}
#endif				/* DEBUG */
#if 0
	for (i = 0; i < pehdr->e_shnum; i++) {
		pshdr = (Elf_Phdr *) (pexe + pehdr->e_shoff +
		    (i * pehdr->e_shentsize));
		if (strcmp(".strtab", get_shstr(pshdr->sh_name)) == 0)
			break;
	}
	fprint_shstr(stdout, pshdr->sh_name);
	printf("\n");
#endif

	load_strtab(pehdr, pexe);
	load_symtab(pehdr, pexe);

	munmap(pexe, sb.st_size);
	close(pfile);
}
char           *shstrtab;

void
load_shstr_tab(Elf_Ehdr * pehdr, char *pexe)
{
	Elf_Shdr       *pshdr;
	shstrtab = NULL;
	if (pehdr->e_shstrndx == 0)
		return;
	pshdr = (Elf_Shdr *) (pexe + pehdr->e_shoff +
	    (pehdr->e_shstrndx * pehdr->e_shentsize));

	shstrtab = (char *) (pexe + pshdr->sh_offset);
}

void
fprint_shstr(FILE * channel, int indx)
{
	if (shstrtab != NULL)
		fprintf(channel, "\"%s\"", &(shstrtab[indx]));
}

char           *
get_shstr(int indx)
{
	return &(shstrtab[indx]);
}

void
load_symtab(Elf_Ehdr * pehdr, char *pexe)
{
	Elf_Sym        *symtab;
	Elf_Shdr       *symsect;
	int             symtabsize;
	Elf_Shdr       *pshdr;
	Elf_Shdr       *psymshdr;
	char           *shname;
	int             i;

	symtab = NULL;
	for (i = 0; i < pehdr->e_shnum; i++) {
		pshdr = (Elf_Shdr *) (pexe + pehdr->e_shoff +
		    (i * pehdr->e_shentsize));
		if (SHT_REL != pshdr->sh_type && SHT_RELA != pshdr->sh_type)
			continue;
		psymshdr = (Elf_Shdr *) (pexe + pehdr->e_shoff +
		    (pshdr->sh_link * pehdr->e_shentsize));
#ifdef DEBUG
		fprint_shstr(stdout, pshdr->sh_name);
		printf("\n");
#endif
		symtab = (Elf_Sym *) (pexe + psymshdr->sh_offset);
		symsect = psymshdr;
		symtabsize = psymshdr->sh_size;

#ifdef DEBUG
		dump_symtab(symsect, symtab, symtabsize);
#endif
		hide_sym(pehdr, symsect, symtab, symtabsize, pshdr->sh_link);
	}

}

void
dump_symtab(Elf_Shdr * symsect, Elf_Sym * symtab, int symtabsize)
{
	int             i;
	Elf_Sym        *psymtab;

	for (i = 0; i < (symtabsize / sizeof(Elf_Sym)); i++) {
		psymtab = &(symtab[i]);
		if ((psymtab->st_info & 0xf0) == 0x10 &&
		    (psymtab->st_shndx != SHN_UNDEF)) {
			printf("symbol %d:\n", i);
			printf("st_name %x \"%s\"\n", psymtab->st_name,
			    get_str(psymtab->st_name));
			printf("st_value %x\n", psymtab->st_value);
			printf("st_size %x\n", psymtab->st_size);
			printf("st_info %x\n", psymtab->st_info);
			printf("st_other %x\n", psymtab->st_other);
			printf("st_shndx %x\n", psymtab->st_shndx);
		}
	}
}

char           *strtab;
int             strtabsize;
void
load_strtab(Elf_Ehdr * pehdr, char *pexe)
{
	Elf_Shdr       *pshdr;
	char           *shname;
	int             i;
	strtab = NULL;
	for (i = 0; i < pehdr->e_shnum; i++) {
		pshdr = (Elf_Shdr *) (pexe + pehdr->e_shoff +
		    (i * pehdr->e_shentsize));

		shname = get_shstr(pshdr->sh_name);
		if (strcmp(".strtab", shname) == 0)
			break;
	}
#ifdef DEBUG
	fprint_shstr(stdout, pshdr->sh_name);
	printf("\n");
#endif

	strtab = (char *) (pexe + pshdr->sh_offset);

	strtabsize = pshdr->sh_size;

#ifdef DEBUG
	dump_strtab();
#endif
}

void
dump_strtab()
{
	int             index;
	char           *pstr;
	char           *pnstr;
	int             i = 0;
	index = 0;
	pstr = strtab;
	while (index < strtabsize) {
		printf("string %x: \"%s\"\n", i, pstr);
		pnstr = pstr + strlen(pstr) + 1;
		index = pnstr - strtab;
		pstr = pnstr;
		i++;
	}

}

fprint_str(FILE * channel, int indx)
{
	if (strtab != NULL)
		fprintf(channel, "\"%s\"", &(strtab[indx]));
}

char *
get_str(int indx)
{
	return &(strtab[indx]);
}

int             in_keep_list(char *symbol);

void
hide_sym(Elf_Ehdr * ehdr, Elf_Shdr * symsect,
    Elf_Sym * symtab, int symtabsize, int symtabsecnum)
{
	int             i;
	unsigned char   info;
	Elf_Sym        *psymtab;

#ifdef __mips__
	u_int32_t f = arc4random();
#endif

	for (i = 0; i < (symtabsize / sizeof(Elf_Sym)); i++) {
		psymtab = &(symtab[i]);
		if ((psymtab->st_info & 0xf0) == 0x10 &&
		    (psymtab->st_shndx != SHN_UNDEF)) {
			if (in_keep_list(get_str(psymtab->st_name)))
				continue;
#ifdef DEBUG
			printf("symbol %d:\n", i);
			printf("st_name %x \"%s\"\n", psymtab->st_name,
			    get_str(psymtab->st_name));
			printf("st_info %x\n", psymtab->st_info);
#endif
#ifndef __mips__
			info = psymtab->st_info;
			info = info & 0xf;
			psymtab->st_info = info;
#else
			/*
			 * XXX This is a small ugly hack to be able to use
			 * XXX chrunchide with MIPS.
			 * XXX Because MIPS needs global symbols to stay
			 * XXX global (has to do with GOT), we mess around
			 * XXX with the symbol names instead. For most uses
			 * XXX this will be no problem, symbols are stripped
			 * XXX anyway. However, if many one character
			 * XXX symbols exist, names may clash.
			 */
			{
				char *p;
				u_int32_t n, z;

				z = f++;
				p = get_str(psymtab->st_name);
				n = strlen(p);
				if (n > 4)
					n = 4;
				while (n--) {
					p[n] = z;
					z >>= 8;
					while (p[n] == 0)
						p[n] += arc4random();
				}
			}

#endif
#ifdef DEBUG
			printf("st_info %x\n", psymtab->st_info);
#endif
		}
	}
	reorder_syms(ehdr, symsect, symtab, symtabsize, symtabsecnum);
}

void
reorder_syms(Elf_Ehdr * ehdr, Elf_Shdr * symsect,
    Elf_Sym * symtab, int symtabsize, int symtabsecnum)
{
	int             i;
	int             nsyms;
	int             cursym;
	Elf_Sym        *tmpsymtab;
	Symmap         *symmap;


	nsyms = symtabsize / sizeof(Elf_Sym);

	tmpsymtab = (Elf_Sym *) calloc(1, symtabsize);
	symmap = (Symmap *) calloc(nsyms, sizeof(Symmap));
	if (!tmpsymtab || !symmap)
		errx(5, "calloc: %s", strerror(ENOMEM));

	bcopy(symtab, tmpsymtab, symtabsize);

	cursym = 1;
	for (i = 1; i < nsyms; i++) {
		if ((tmpsymtab[i].st_info & 0xf0) == 0x00) {
#ifdef DEBUG
			printf("copying  l o%d n%d <%s>\n", i, cursym,
			    get_str(tmpsymtab[i].st_name));
#endif
			bcopy(&(tmpsymtab[i]), &(symtab[cursym]),
			    sizeof(Elf_Sym));
			symmap[i] = cursym;
			cursym++;
		}
	}
	symsect->sh_info = cursym;
	for (i = 1; i < nsyms; i++) {
		if ((tmpsymtab[i].st_info & 0xf0) != 0x00) {
#ifdef DEBUG
			printf("copying nl o%d n%d <%s>\n", i, cursym,
			    get_str(tmpsymtab[i].st_name));
#endif
			bcopy(&(tmpsymtab[i]), &(symtab[cursym]),
			    sizeof(Elf_Sym));
			symmap[i] = cursym;
			cursym++;
		}
	}
	if (cursym != nsyms) {
		printf("miscounted symbols somewhere c %d n %d \n",
		    cursym, nsyms);
		exit(5);
	}
	renum_reloc_syms(ehdr, symmap, symtabsecnum);
	free(tmpsymtab);
	free(symmap);
}

void
renum_reloc_syms(Elf_Ehdr * ehdr, Symmap * symmap, int symtabsecnum)
{
	Elf_Shdr       *pshdr;
	int             i, j;
	int             num_reloc;
	Elf_Rel        *prel;
	Elf_RelA       *prela;
	int             symnum;

	for (i = 0; i < ehdr->e_shnum; i++) {
		pshdr = (Elf_Shdr *) (pexe + ehdr->e_shoff +
		    (i * ehdr->e_shentsize));
		if ((pshdr->sh_type == SHT_RELA) &&
		    pshdr->sh_link == symtabsecnum) {

#ifdef DEBUG
			printf("section %d has rela relocations in symtab\n", i);
#endif
			prela = (Elf_RelA *) (pexe + pshdr->sh_offset);
			num_reloc = pshdr->sh_size / sizeof(Elf_RelA);
			for (j = 0; j < num_reloc; j++) {
				symnum = ELF_R_SYM(prela[j].r_info);
#ifdef DEBUG
				printf("sym num o %d n %d\n", symnum,
				    symmap[symnum]);
#endif
				prela[j].r_info = ELF_R_INFO(symmap[symnum],
				    ELF_R_TYPE(prela[j].r_info));
			}
		}
		if ((pshdr->sh_type == SHT_REL) &&
		    pshdr->sh_link == symtabsecnum) {
#ifdef DEBUG
			printf("section %d has rel relocations in symtab\n", i);
#endif
			prel = (Elf_Rel *) (pexe + pshdr->sh_offset);
			num_reloc = pshdr->sh_size / sizeof(Elf_Rel);
			for (j = 0; j < num_reloc; j++) {
				symnum = ELF_R_SYM(prel[j].r_info);
#ifdef DEBUG
				printf("sym num o %d n %d\n", symnum,
				    symmap[symnum]);
#endif
				prel[j].r_info = ELF_R_INFO(symmap[symnum],
				    ELF_R_TYPE(prel[j].r_info));
			}
		}
	}

}
#endif				/* _NLIST_DO_ELF */
@


1.12
log
@On mips systems, use arc4random() instead of time(NULL) and rand() as a random
source, and thus don't stupidly sleep(1) every time to get a different value
from time().

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: elf_hide.c,v 1.11 2007/08/07 05:42:05 ray Exp $ */
@


1.11
log
@Check for calloc failure and replace an assert with errx.

OK millert and otto.
@
text
@d1 1
a1 1
/* $OpenBSD: elf_hide.c,v 1.10 2006/03/23 02:49:59 deraadt Exp $ */
d306 1
a306 3
	int             f;
	sleep(1);
	f = time(NULL) * 200;
d328 1
a328 3
			 * chrunchide with MIPS.
			 */
			/*
d330 5
a334 11
			 * global (has to do with GOT)
			 */
			/*
			 * XXX we mess around with the symbol names instead.
			 * For most uses this
			 */
			/*
			 * XXX will be no problem, symbols are stripped
			 * anyway. However, if many
			 */
			/* XXX one character symbols exist, names may clash.
d337 2
a338 2
				char           *p;
				int             n, z;
d349 1
a349 1
						p[n] += rand();
@


1.10
log
@use calloc better; adobriyan@@gmail
@
text
@d1 1
a1 1
/* $OpenBSD: elf_hide.c,v 1.9 2003/06/03 01:35:30 drahn Exp $ */
d32 2
a38 1
#include <assert.h>
d387 2
a388 2

	assert(NULL != tmpsymtab);
@


1.9
log
@kill clause 3 and 4 from several of my copyrights, cleanup.
@
text
@d1 1
a1 1
/* $OpenBSD: elf_hide.c,v 1.8 2003/01/27 19:41:30 deraadt Exp $ */
d385 1
a385 1
	symmap = (Symmap *) calloc(1, sizeof(Symmap) * (nsyms));
@


1.8
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: elf_hide.c,v 1.7 2002/06/09 05:53:53 todd Exp $ */
d4 2
a5 1
 * Copyright (c) 1997 Dale Rahn. All rights reserved.
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.7
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: elf_hide.c,v 1.6 2001/01/23 21:00:20 art Exp $ */
d46 17
a62 3
void load_strtab(Elf_Ehdr *pehdr, char *pexe);
void dump_strtab();
char *get_str(int indx);
a63 2
void load_symtab(Elf_Ehdr *pehdr, char *pexe);
void dump_symtab();
d65 1
a65 14
void load_shstr_tab(Elf_Ehdr *pehdr, char *pexe);
char *get_shstr(int indx);
void fprint_shstr(FILE * channel, int indx);

void hide_sym();

void reorder_syms(Elf_Ehdr *ehdr, Elf_Shdr *symsect,
	Elf_Sym *symtab, int symtabsize, int symtabsecnum);

typedef long Symmap;

void renum_reloc_syms(Elf_Ehdr *ehdr, Symmap *symmap, int symtabsecnum);

char * pexe;
d70 5
a74 6
	int i;

	Elf_Ehdr *pehdr;
	Elf_Shdr *pshdr;
	Elf_Phdr *pphdr;
	struct stat sb;
d77 1
a77 1
	pehdr = (Elf_Ehdr *)pexe;
d95 1
a95 1
	
d100 1
a100 1
			(i * pehdr->e_shentsize));
d102 1
a102 1
		printf("section header %d\n",i);
d116 1
a116 1
#endif /* DEBUG */
d121 1
a121 1
			(i * pehdr->e_phentsize);
d133 1
a133 1
#endif /* DEBUG */
d137 2
a138 2
			(i * pehdr->e_shentsize);
		if (0 == strcmp(".strtab", get_shstr(pshdr->sh_name))) {
a139 1
		}
d149 1
a149 1
	close (pfile);
d151 1
a151 1
char *shstrtab;
d154 1
a154 1
load_shstr_tab(Elf_Ehdr *pehdr, char *pexe)
d156 1
a156 1
	Elf_Shdr *pshdr;
d158 1
a158 1
	if (pehdr->e_shstrndx == 0) {
d160 2
a161 3
	}
	pshdr = (Elf_Shdr *)(pexe + pehdr->e_shoff +
		(pehdr->e_shstrndx * pehdr->e_shentsize));
d163 1
a163 1
	shstrtab = (char *)(pexe + pshdr->sh_offset);
d169 1
a169 1
	if (shstrtab != NULL) {
a170 2
	}
	return;
d173 1
a173 1
char *
d180 1
a180 1
load_symtab(Elf_Ehdr *pehdr, char *pexe)
d182 8
a189 7
	Elf_Sym *symtab;
	Elf_Shdr *symsect;
	int	   symtabsize;
	Elf_Shdr *pshdr;
	Elf_Shdr *psymshdr;
	char *shname;
	int i;
d192 3
a194 3
		pshdr = (Elf_Shdr *)(pexe + pehdr->e_shoff +
		(i * pehdr->e_shentsize) );
		if (SHT_REL != pshdr->sh_type && SHT_RELA != pshdr->sh_type){
d196 2
a197 3
		}
		psymshdr = (Elf_Shdr *)(pexe + pehdr->e_shoff +
			(pshdr->sh_link * pehdr->e_shentsize) );
d202 1
a202 1
		symtab = (Elf_Sym *)(pexe + psymshdr->sh_offset);
d215 1
a215 1
dump_symtab (Elf_Shdr *symsect, Elf_Sym *symtab, int symtabsize)
d217 2
a218 2
	int i;
	Elf_Sym *psymtab;
d220 1
a220 1
	for (i = 0 ; i < (symtabsize/sizeof(Elf_Sym)); i++) {
d223 9
a231 9
			(psymtab->st_shndx != SHN_UNDEF)) {
		printf("symbol %d:\n", i);
		printf("st_name %x \"%s\"\n", psymtab->st_name,
			get_str(psymtab->st_name));
		printf("st_value %x\n", psymtab->st_value);
		printf("st_size %x\n", psymtab->st_size);
		printf("st_info %x\n", psymtab->st_info);
		printf("st_other %x\n", psymtab->st_other);
		printf("st_shndx %x\n", psymtab->st_shndx);
d236 2
a237 2
char * strtab;
int strtabsize;
d239 1
a239 1
load_strtab(Elf_Ehdr *pehdr, char *pexe)
d241 3
a243 3
	Elf_Shdr *pshdr;
	char *shname;
	int i;
d247 1
a247 1
			(i * pehdr->e_shentsize));
d250 1
a250 1
		if (0 == strcmp(".strtab", shname)) {
a251 1
		}
d270 4
a273 4
	int index;
	char *pstr;
	char *pnstr;
	int i = 0;
d283 1
a283 1
	
d285 1
d288 1
a288 1
	if (strtab != NULL) {
a289 2
	}
	return;
d291 1
d298 1
a298 1
int in_keep_list(char *symbol);
d301 2
a302 2
hide_sym(Elf_Ehdr *ehdr, Elf_Shdr *symsect,
	Elf_Sym *symtab, int symtabsize, int symtabsecnum)
d304 3
a306 3
	int i;
	unsigned char info;
	Elf_Sym *psymtab;
d309 1
a309 1
	int f;
d314 1
a314 1
	for (i = 0 ; i < (symtabsize/sizeof(Elf_Sym)); i++) {
d317 2
a318 2
			(psymtab->st_shndx != SHN_UNDEF)) {
			if (in_keep_list(get_str(psymtab->st_name))) {
a319 1
			}
d323 1
a323 1
				get_str(psymtab->st_name));
d331 18
a348 5
/* XXX This is a small ugly hack to be able to use chrunchide with MIPS.     */
/* XXX Because MIPS needs global symbols to stay global (has to do with GOT) */
/* XXX we mess around with the symbol names instead. For most uses this      */
/* XXX will be no problem, symbols are stripped anyway. However, if many     */
/* XXX one character symbols exist, names may clash.			     */
d350 2
a351 2
				char *p;
				int n, z;
d356 1
a356 1
				if(n > 4)
d358 1
a358 1
				while(n--) {
d361 1
a361 1
					while(p[n] == 0)
d374 1
d376 2
a377 2
reorder_syms(Elf_Ehdr *ehdr, Elf_Shdr *symsect,
	Elf_Sym *symtab, int symtabsize, int symtabsecnum)
d379 5
a383 5
	int i;
	int nsyms;
	int cursym;
	Elf_Sym *tmpsymtab;
	Symmap *symmap;
d388 2
a389 2
	tmpsymtab = (Elf_Sym *)calloc(1,symtabsize);
	symmap = (Symmap *)calloc(1, sizeof(Symmap) * (nsyms));
d391 1
a391 1
	assert (NULL != tmpsymtab);
d393 1
a393 1
	bcopy (symtab, tmpsymtab, symtabsize);
d399 2
a400 2
			printf("copying  l o%d n%d <%s>\n",i, cursym,
				get_str(tmpsymtab[i].st_name));
d402 2
a403 2
			bcopy (&(tmpsymtab[i]),
				&(symtab[cursym]), sizeof(Elf_Sym));
d412 2
a413 2
			printf("copying nl o%d n%d <%s>\n",i, cursym,
				get_str(tmpsymtab[i].st_name));
d415 2
a416 2
			bcopy (&(tmpsymtab[i]),
				&(symtab[cursym]), sizeof(Elf_Sym));
d423 2
a424 2
			cursym, nsyms);
		exit (5);
d427 2
a428 2
	free (tmpsymtab);
	free (symmap);
d430 1
d432 1
a432 1
renum_reloc_syms(Elf_Ehdr *ehdr, Symmap *symmap, int symtabsecnum)
d434 6
a439 6
	Elf_Shdr *pshdr;
	int i, j;
	int num_reloc;
	Elf_Rel  *prel;
	Elf_RelA *prela;
	int symnum;
d442 2
a443 2
		pshdr = (Elf_Shdr *)(pexe + ehdr->e_shoff +
		(i * ehdr->e_shentsize) );
d445 2
a446 3
			pshdr->sh_link == symtabsecnum)
		{
			
d448 1
a448 1
			printf ("section %d has rela relocations in symtab\n", i);
d450 2
a451 2
			prela = (Elf_RelA *)(pexe + pshdr->sh_offset);
			num_reloc = pshdr->sh_size /sizeof (Elf_RelA);
d456 1
a456 1
					symmap[symnum]);
d458 2
a459 2
				prela[j].r_info = ELF_R_INFO (symmap[symnum],
					ELF_R_TYPE(prela[j].r_info));
a460 1

d463 1
a463 2
			pshdr->sh_link == symtabsecnum)
		{
d465 1
a465 1
			printf ("section %d has rel relocations in symtab\n", i);
d467 2
a468 2
			prel = (Elf_Rel *)(pexe + pshdr->sh_offset);
			num_reloc = pshdr->sh_size /sizeof (Elf_Rel);
d473 1
a473 1
					symmap[symnum]);
d475 2
a476 2
				prel[j].r_info = ELF_R_INFO (symmap[symnum],
					ELF_R_TYPE(prel[j].r_info));
d480 1
a480 1
	
d482 1
a482 1
#endif /* _NLIST_DO_ELF */
@


1.6
log
@Convert to use the elf-size independent macros to make it work on alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: elf_hide.c,v 1.5 1997/07/23 19:31:53 kstailey Exp $ */
d6 1
a6 1
 *   
d31 1
a31 1
 */  
@


1.5
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: elf_hide.c,v 1.4 1997/05/19 09:24:39 pefo Exp $ */
d46 1
a46 1
void load_strtab(Elf32_Ehdr *pehdr, char *pexe);
d50 1
a50 1
void load_symtab(Elf32_Ehdr *pehdr, char *pexe);
d53 1
a53 1
void load_shstr_tab(Elf32_Ehdr *pehdr, char *pexe);
d59 2
a60 2
void reorder_syms(Elf32_Ehdr *ehdr, Elf32_Shdr *symsect,
	Elf32_Sym *symtab, int symtabsize, int symtabsecnum);
d62 1
a62 1
typedef int Symmap;
d64 1
a64 1
void renum_reloc_syms(Elf32_Ehdr *ehdr, Symmap *symmap, int symtabsecnum);
d73 3
a75 3
	Elf32_Ehdr *pehdr;
	Elf32_Shdr *pshdr;
	Elf32_Phdr *pphdr;
d79 1
a79 1
	pehdr = (Elf32_Ehdr *)pexe;
d101 1
a101 1
		pshdr = (Elf32_Phdr *) (pexe + pehdr->e_shoff +
d122 1
a122 1
		pshdr = (Elf32_Phdr *) (pexe + pehdr->e_phoff +
d138 1
a138 1
		pshdr = (Elf32_Phdr *) (pexe + pehdr->e_shoff +
d157 1
a157 1
load_shstr_tab(Elf32_Ehdr *pehdr, char *pexe)
d159 1
a159 1
	Elf32_Shdr *pshdr;
d164 1
a164 1
	pshdr = (Elf32_Shdr *)(pexe + pehdr->e_shoff +
d186 1
a186 1
load_symtab(Elf32_Ehdr *pehdr, char *pexe)
d188 2
a189 2
	Elf32_Sym *symtab;
	Elf32_Shdr *symsect;
d191 2
a192 2
	Elf32_Shdr *pshdr;
	Elf32_Shdr *psymshdr;
d197 1
a197 1
		pshdr = (Elf32_Shdr *)(pexe + pehdr->e_shoff +
d202 1
a202 1
		psymshdr = (Elf32_Shdr *)(pexe + pehdr->e_shoff +
d208 1
a208 1
		symtab = (Elf32_Sym *)(pexe + psymshdr->sh_offset);
d221 1
a221 1
dump_symtab (Elf32_Shdr *symsect, Elf32_Sym *symtab, int symtabsize)
d224 1
a224 1
	Elf32_Sym *psymtab;
d226 1
a226 1
	for (i = 0 ; i < (symtabsize/sizeof(Elf32_Sym)); i++) {
d245 1
a245 1
load_strtab(Elf32_Ehdr *pehdr, char *pexe)
d247 1
a247 1
	Elf32_Shdr *pshdr;
d252 1
a252 1
		pshdr = (Elf32_Shdr *) (pexe + pehdr->e_shoff +
d308 2
a309 2
hide_sym(Elf32_Ehdr *ehdr, Elf32_Shdr *symsect,
	Elf32_Sym *symtab, int symtabsize, int symtabsecnum)
d313 1
a313 1
	Elf32_Sym *psymtab;
d321 1
a321 1
	for (i = 0 ; i < (symtabsize/sizeof(Elf32_Sym)); i++) {
d370 2
a371 2
reorder_syms(Elf32_Ehdr *ehdr, Elf32_Shdr *symsect,
	Elf32_Sym *symtab, int symtabsize, int symtabsecnum)
d376 1
a376 1
	Elf32_Sym *tmpsymtab;
d380 1
a380 1
	nsyms = symtabsize / sizeof(Elf32_Sym);
d382 1
a382 1
	tmpsymtab = (Elf32_Sym *)calloc(1,symtabsize);
d397 1
a397 1
				&(symtab[cursym]), sizeof(Elf32_Sym));
d410 1
a410 1
				&(symtab[cursym]), sizeof(Elf32_Sym));
d425 1
a425 1
renum_reloc_syms(Elf32_Ehdr *ehdr, Symmap *symmap, int symtabsecnum)
d427 1
a427 1
	Elf32_Shdr *pshdr;
d430 2
a431 2
	Elf32_Rel  *prel;
	Elf32_Rela *prela;
d435 1
a435 1
		pshdr = (Elf32_Shdr *)(pexe + ehdr->e_shoff +
d444 2
a445 2
			prela = (Elf32_Rela *)(pexe + pshdr->sh_offset);
			num_reloc = pshdr->sh_size /sizeof (Elf32_Rela);
d447 1
a447 1
				symnum = ELF32_R_SYM(prela[j].r_info);
d452 2
a453 2
				prela[j].r_info = ELF32_R_INFO (symmap[symnum],
					ELF32_R_TYPE(prela[j].r_info));
d463 2
a464 2
			prel = (Elf32_Rel *)(pexe + pshdr->sh_offset);
			num_reloc = pshdr->sh_size /sizeof (Elf32_Rel);
d466 1
a466 1
				symnum = ELF32_R_SYM(prel[j].r_info);
d471 2
a472 2
				prel[j].r_info = ELF32_R_INFO (symmap[symnum],
					ELF32_R_TYPE(prel[j].r_info));
@


1.4
log
@A symbol mangeling hack to make chrunch work with MIPS. This is a quick and
dirty fix in the light of no time to make a more correct one. What really
should be done here is to wrap the symbols with the object file name but
that requires the symbol string table to be resized and rewritten.
The fix only affect MIPS. (__mips__ protected).
@
text
@d1 1
a1 1
/*	$OpenBSD: elf_hide.c,v 1.3 1997/05/06 17:08:29 niklas Exp $ */
d190 1
a190 1
	int        symtabsize;
d343 1
a343 1
/* XXX one character symbols exist, names may clash.                         */
@


1.3
log
@Add ECOFF support, do some slight restructuring to share the mmap between
the different object file format models
@
text
@d1 1
a1 1
/*	$OpenBSD: elf_hide.c,v 1.2 1997/04/04 21:52:42 mickey Exp $ */
d315 6
d334 1
d338 24
a366 2
#ifdef DEBUG
#endif
@


1.2
log
@init allocated memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: elf_hide.c,v 1.1 1997/01/09 04:16:52 rahnds Exp $ */
d39 2
d42 2
d67 3
a69 1
elf_hide(int pfile)
d78 1
a78 4
	fstat(pfile, &sb);
	pexe = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, 
		MAP_FILE | MAP_SHARED, pfile, 0);

d284 2
a285 2
		printf("string %x: \"%s\"\n",i, pstr);
		pnstr = (char *) ((int)strchr(pstr, '\0') + 1);
d449 1
@


1.1
log
@Add the ablity to hide symbols on ELF/OLF objects.
This is a first cut at the symbol hiding process for ELF.
The current method will not work properly on mips.
It has been tested for powerpc and should work on alpha.
The problem with mips is due to the standard PIC compilation.
@
text
@d1 1
a1 1
/*	$OpenBSD:$ */
d350 2
a351 2
	tmpsymtab = (Elf32_Sym *)malloc(symtabsize);
	symmap = (Symmap *)malloc( sizeof(Symmap) * (nsyms));
@
