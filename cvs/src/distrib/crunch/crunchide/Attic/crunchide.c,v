head	1.23;
access;
symbols
	OPENBSD_4_4:1.22.0.8
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.6
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.4
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.20.0.4
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.4
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.12.0.6
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.4
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2008.08.22.15.18.55;	author deraadt;	state dead;
branches;
next	1.22;

1.22
date	2007.02.18.23.50.46;	author ray;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.26.10.20.11;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.21.01.40.22;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.08.24.09.12.49;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.16.21.11.10;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.27.19.41.30;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.05.15.24.07;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.09.05.53.53;	author todd;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.18.21.23.41;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.11.14.08.19;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.01.22.10.03;	author todd;	state Exp;
branches;
next	1.11;

1.11
date	99.06.09.02.24.41;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	98.09.21.17.27.32;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.23.19.31.52;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.05.06.17.08.28;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.05.01.11.14.25;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.04.04.21.52.42;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.02.05.16.31.23;	author rahnds;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.40.29;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.09.04.16.52;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	95.11.06.21.51.06;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.31;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Merge crunchgen & crunchhide (using name checking), and move to usr.sbin
next step is to not install it as two programs, but be even more clever
@
text
@/* $OpenBSD: crunchide.c,v 1.22 2007/02/18 23:50:46 ray Exp $	 */

/*
 * Copyright (c) 1994 University of Maryland
 * All Rights Reserved.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of U.M. not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  U.M. makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * U.M. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL U.M.
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author: James da Silva, Systems Design and Analysis Group
 *			   Computer Science Department
 *			   University of Maryland at College Park
 */
/*
 * crunchide.c - tiptoes through an a.out symbol table, hiding all defined
 *	global symbols.  Allows the user to supply a "keep list" of symbols
 *	that are not to be hidden.  This program relies on the use of the
 * 	linker's -dc flag to actually put global bss data into the file's
 * 	bss segment (rather than leaving it as undefined "common" data).
 *
 * 	The point of all this is to allow multiple programs to be linked
 *	together without getting multiple-defined errors.
 *
 *	For example, consider a program "foo.c".  It can be linked with a
 *	small stub routine, called "foostub.c", eg:
 *	    int foo_main(int argc, char **argv){ return main(argc, argv); }
 *      like so:
 *	    cc -c foo.c foostub.c
 *	    ld -dc -r foo.o foostub.o -o foo.combined.o
 *	    crunchide -k _foo_main foo.combined.o
 *	at this point, foo.combined.o can be linked with another program
 * 	and invoked with "foo_main(argc, argv)".  foo's main() and any
 * 	other globals are hidden and will not conflict with other symbols.
 *
 * TODO:
 *	- resolve the theoretical hanging reloc problem (see check_reloc()
 *	  below). I have yet to see this problem actually occur in any real
 *	  program. In what cases will gcc/gas generate code that needs a
 *	  relative reloc from a global symbol, other than PIC?  The
 *	  solution is to not hide the symbol from the linker in this case,
 *	  but to generate some random name for it so that it doesn't link
 *	  with anything but holds the place for the reloc.
 *      - arrange that all the BSS segments start at the same address, so
 *	  that the final crunched binary BSS size is the max of all the
 *	  component programs' BSS sizes, rather than their sum.
 */
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <a.out.h>
#include <sys/types.h>
#ifdef _NLIST_DO_ECOFF
#include <sys/exec_ecoff.h>
#endif
#include <sys/mman.h>
#include <sys/stat.h>

/*
 * if __ELF__ is defined, do not bother supporting AOUT.
 */
#if defined(_NLIST_DO_AOUT) && !(defined(__ELF__))
#define DO_AOUT
#endif

char           *pname = "crunchide";

void            usage(void);

void            add_to_keep_list(char *);
void            add_file_to_keep_list(char *);

void            hide_syms(char *);
#ifdef _NLIST_DO_ECOFF
void            ecoff_hide(int, char *);
#endif
#ifdef _NLIST_DO_ELF
void            elf_hide(int, char *);
#endif

int 
main(int argc, char *argv[])
{
	int             ch;

	if (argc > 0)
		pname = argv[0];

	while ((ch = getopt(argc, argv, "k:f:")) != -1)
		switch (ch) {
		case 'k':
			add_to_keep_list(optarg);
			break;
		case 'f':
			add_file_to_keep_list(optarg);
			break;
		default:
			usage();
		}

	argc -= optind;
	argv += optind;

	if (argc == 0)
		usage();

	while (argc) {
		hide_syms(*argv);
		argc--;
		argv++;
	}

	return 0;
}

void 
usage(void)
{
	fprintf(stderr,
	    "usage: %s [-f keep-list-file] [-k keep-symbol] object-file ...\n",
	    pname);
	exit(1);
}

struct keep {
	struct keep    *next;
	char           *sym;
} *keep_list;

void 
add_to_keep_list(char *symbol)
{
	struct keep    *newp, *prevp, *curp;
	int             cmp;

	for (curp = keep_list, prevp = NULL; curp; prevp = curp, curp = curp->next)
		if ((cmp = strcmp(symbol, curp->sym)) <= 0)
			break;

	if (curp && cmp == 0)
		return;		/* already in table */

	newp = (struct keep *) calloc(1, sizeof(struct keep));
	if (newp)
		newp->sym = strdup(symbol);
	if (newp == NULL || newp->sym == NULL) {
		fprintf(stderr, "%s: out of memory for keep list\n", pname);
		exit(1);
	}
	newp->next = curp;
	if (prevp)
		prevp->next = newp;
	else
		keep_list = newp;
}

int 
in_keep_list(char *symbol)
{
	struct keep    *curp;
	int             cmp;

	for (curp = keep_list; curp; curp = curp->next)
		if ((cmp = strcmp(symbol, curp->sym)) <= 0)
			break;

	return curp && cmp == 0;
}

void 
add_file_to_keep_list(char *filename)
{
	FILE           *keepf;
	char            symbol[1024];
	int             len;

	if ((keepf = fopen(filename, "r")) == NULL) {
		perror(filename);
		usage();
	}
	while (fgets(symbol, sizeof(symbol), keepf)) {
		len = strlen(symbol);
		if (len && symbol[len - 1] == '\n')
			symbol[len - 1] = '\0';

		add_to_keep_list(symbol);
	}
	fclose(keepf);
}

int             nsyms, ntextrel, ndatarel;
struct exec    *hdrp;
char           *aoutdata, *strbase;
struct relocation_info *textrel, *datarel;
struct nlist   *symbase;

#define SYMSTR(sp)	&strbase[(sp)->n_un.n_strx]

/* is the symbol a global symbol defined in the current file? */
#define IS_GLOBAL_DEFINED(sp) \
	(((sp)->n_type & N_EXT) && ((sp)->n_type & N_TYPE) != N_UNDF)

#ifdef DO_AOUT
#if defined(__sparc__)
/* is the relocation entry dependent on a symbol? */
#define IS_SYMBOL_RELOC(rp)   \
	((rp)->r_extern || \
	((rp)->r_type >= RELOC_BASE10 && (rp)->r_type <= RELOC_BASE22) || \
	(rp)->r_type == RELOC_JMP_TBL)
#else
/* is the relocation entry dependent on a symbol? */
#define IS_SYMBOL_RELOC(rp)   \
		  ((rp)->r_extern||(rp)->r_baserel||(rp)->r_jmptable)
#endif
#endif

void            check_reloc(char *filename, struct relocation_info * relp);

void 
hide_syms(char *filename)
{
	int             inf, outf, rc;
	struct stat     infstat;
	struct relocation_info *relp;
	struct nlist   *symp;
	char           *buf;
	u_char          zero = 0;

	/*
         * Open the file and do some error checking.
         */

	if ((inf = open(filename, O_RDWR)) == -1) {
		perror(filename);
		return;
	}
	if (fstat(inf, &infstat) == -1) {
		perror(filename);
		close(inf);
		return;
	}
	if (infstat.st_size < sizeof(struct exec)) {
		fprintf(stderr, "%s: short file\n", filename);
		close(inf);
		return;
	}
	if ((buf = mmap(NULL, infstat.st_size, PROT_READ | PROT_WRITE,
	    MAP_FILE | MAP_SHARED, inf, 0)) == MAP_FAILED) {
		fprintf(stderr, "%s: cannot map\n", filename);
		close(inf);
		return;
	}

#ifdef _NLIST_DO_ELF
	if (buf[0] == 0x7f && (buf[1] == 'E' || buf[1] == 'O') &&
	    buf[2] == 'L' && buf[3] == 'F') {
		elf_hide(inf, buf);
		return;
	}
#endif				/* _NLIST_DO_ELF */

#ifdef _NLIST_DO_ECOFF
	if (!ECOFF_BADMAG((struct ecoff_exechdr *) buf)) {
		ecoff_hide(inf, buf);
		return;
	}
#endif				/* _NLIST_DO_ECOFF */

#ifdef DO_AOUT
	aoutdata = buf;

	/*
         * Check the header and calculate offsets and sizes from it.
         */
	hdrp = (struct exec *) aoutdata;

	if (N_BADMAG(*hdrp)) {
		fprintf(stderr, "%s: bad magic: not an a.out, ecoff or elf  file\n",
		    filename);
		close(inf);
		return;
	}
	textrel = (struct relocation_info *) (aoutdata + N_TRELOFF(*hdrp));
	datarel = (struct relocation_info *) (aoutdata + N_DRELOFF(*hdrp));
	symbase = (struct nlist *) (aoutdata + N_SYMOFF(*hdrp));
	strbase = (char *) (aoutdata + N_STROFF(*hdrp));

	ntextrel = hdrp->a_trsize / sizeof(struct relocation_info);
	ndatarel = hdrp->a_drsize / sizeof(struct relocation_info);
	nsyms = hdrp->a_syms / sizeof(struct nlist);

	/*
         * Zap the type field of all globally-defined symbols.  The linker will
         * subsequently ignore these entries.  Don't zap any symbols in the
         * keep list.
         */
	for (symp = symbase; symp < symbase + nsyms; symp++)
		if (IS_GLOBAL_DEFINED(symp) && !in_keep_list(SYMSTR(symp))) {
			/*
		         * XXX Our VM system has some problems, so
		         * avoid the VM system....
		         */
			lseek(inf, (off_t) ((void *) &symp->n_type -
			    (void *) buf), SEEK_SET);
			write(inf, &zero, sizeof zero);
			symp->n_type = 0;
		}
	/*
         * Check whether the relocation entries reference any symbols that we
         * just zapped.  I don't know whether ld can handle this case, but I
         * haven't encountered it yet.  These checks are here so that the program
         * doesn't fail silently should such symbols be encountered.
         */
	for (relp = textrel; relp < textrel + ntextrel; relp++)
		check_reloc(filename, relp);
	for (relp = datarel; relp < datarel + ndatarel; relp++)
		check_reloc(filename, relp);

	msync(buf, infstat.st_size, MS_SYNC);
	munmap(buf, infstat.st_size);
	close(inf);
#endif				/* DO_AOUT */
}

#ifdef DO_AOUT
void 
check_reloc(char *filename, struct relocation_info * relp)
{
	/* bail out if we zapped a symbol that is needed */
	if (IS_SYMBOL_RELOC(relp) && symbase[relp->r_symbolnum].n_type == 0) {
		fprintf(stderr,
		    "%s: oops, have hanging relocation for %s: bailing out!\n",
		    filename, SYMSTR(&symbase[relp->r_symbolnum]));
		exit(1);
	}
}
#endif				/* DO_AOUT */
@


1.22
log
@Use sizeof(buf) instead of hard coded numbers.

From Charles Longeau <chl at tuxfamily dot org> long ago.

OK moritz@@.
@
text
@d1 1
a1 1
/* $OpenBSD: crunchide.c,v 1.21 2006/12/26 10:20:11 deraadt Exp $	 */
@


1.21
log
@fix usage messages
@
text
@d1 1
a1 1
/* $OpenBSD: crunchide.c,v 1.20 2005/12/21 01:40:22 millert Exp $	 */
d197 1
a197 1
	while (fgets(symbol, 1024, keepf)) {
@


1.20
log
@Userland programs should include <errno.h> not <sys/errno.h>
OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: crunchide.c,v 1.19 2004/08/24 09:12:49 jmc Exp $	 */
d136 1
a136 1
	    "Usage: %s [-f keep-list-file] [-k keep-symbol] object-file ...\n",
@


1.19
log
@- `object-file' is not optional
- sync usage()
@
text
@d1 1
a1 1
/* $OpenBSD: crunchide.c,v 1.18 2003/04/16 21:11:10 drahn Exp $	 */
d65 1
a68 1
#include <sys/errno.h>
@


1.18
log
@Clean up some ifdefs on arch which repute to support a.out and elf.
only support ELF if __ELF__ is defined when compiling. ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: crunchide.c,v 1.17 2003/01/27 19:41:30 deraadt Exp $	 */
d136 1
a136 1
	    "Usage: %s [-k <symbol-name>] [-f <keep-list-file>] <files> ...\n",
@


1.17
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: crunchide.c,v 1.16 2002/08/05 15:24:07 art Exp $	 */
d76 1
a76 2
 * The alpha and mips based ports define _NLIST_DO_AOUT although it doesn't
 * fully support a.out.
d78 1
a78 2
#if defined(_NLIST_DO_AOUT) && !(defined(__alpha__) || defined(__mips__) || \
    (defined(__sparc__) && defined(__ELF__)))
d219 2
a220 1
#if defined(__sparc__) && !defined(__ELF__)
d230 1
@


1.16
log
@Prepare for sparc/ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchide.c,v 1.15 2002/06/09 05:53:53 todd Exp $	*/
d84 1
a84 1
char *pname = "crunchide";
d86 1
a86 1
void usage(void);
d88 2
a89 2
void add_to_keep_list(char *);
void add_file_to_keep_list(char *);
d91 1
a91 1
void hide_syms(char *);
d93 1
a93 1
void ecoff_hide(int, char *);
d96 1
a96 1
void elf_hide(int, char *);
d99 2
a100 3
int main(argc, argv)
int argc;
char **argv;
d102 1
a102 1
    int ch;
d104 2
a105 1
    if(argc > 0) pname = argv[0];
d107 22
a128 10
    while ((ch = getopt(argc, argv, "k:f:")) != -1)
	switch(ch) {
	case 'k':
	    add_to_keep_list(optarg);
	    break;
	case 'f':
	    add_file_to_keep_list(optarg);
	    break;
	default:
	    usage();
d131 1
a131 11
    argc -= optind;
    argv += optind;

    if(argc == 0) usage();

    while(argc) {
	hide_syms(*argv);
	argc--, argv++;
    }

    return 0;
d134 2
a135 1
void usage(void)
d137 1
a137 1
    fprintf(stderr,
d140 1
a140 1
    exit(1);
a142 2
/* ---------------------------- */

d144 2
a145 2
    struct keep *next;
    char *sym;
d148 2
a149 1
void add_to_keep_list(char *symbol)
d151 2
a152 2
    struct keep *newp, *prevp, *curp;
    int cmp;
d154 19
a172 16
    for(curp = keep_list, prevp = NULL; curp; prevp = curp, curp = curp->next)
	if((cmp = strcmp(symbol, curp->sym)) <= 0) break;

    if(curp && cmp == 0)
	return;	/* already in table */

    newp = (struct keep *) calloc(1,sizeof(struct keep));
    if(newp) newp->sym = strdup(symbol);
    if(newp == NULL || newp->sym == NULL) {
	fprintf(stderr, "%s: out of memory for keep list\n", pname);
	exit(1);
    }

    newp->next = curp;
    if(prevp) prevp->next = newp;
    else keep_list = newp;
d175 2
a176 1
int in_keep_list(char *symbol)
d178 2
a179 2
    struct keep *curp;
    int cmp;
d181 3
a183 2
    for(curp = keep_list; curp; curp = curp->next)
	if((cmp = strcmp(symbol, curp->sym)) <= 0) break;
d185 1
a185 1
    return curp && cmp == 0;
d188 2
a189 1
void add_file_to_keep_list(char *filename)
d191 16
a206 17
    FILE *keepf;
    char symbol[1024];
    int len;

    if((keepf = fopen(filename, "r")) == NULL) {
	perror(filename);
	usage();
    }

    while(fgets(symbol, 1024, keepf)) {
	len = strlen(symbol);
	if(len && symbol[len-1] == '\n')
	    symbol[len-1] = '\0';

	add_to_keep_list(symbol);
    }
    fclose(keepf);
d209 3
a211 5
/* ---------------------- */

int nsyms, ntextrel, ndatarel;
struct exec *hdrp;
char *aoutdata, *strbase;
d213 1
a213 2
struct nlist *symbase;

d219 1
a219 1
		  (((sp)->n_type & N_EXT) && ((sp)->n_type & N_TYPE) != N_UNDF)
d233 1
a233 1
void check_reloc(char *filename, struct relocation_info *relp);
d235 2
a236 1
void hide_syms(char *filename)
d238 31
a268 34
    int inf, outf, rc;
    struct stat infstat;
    struct relocation_info *relp;
    struct nlist *symp;
    char *buf;
    u_char zero = 0;

    /*
     * Open the file and do some error checking.
     */

    if((inf = open(filename, O_RDWR)) == -1) {
	perror(filename);
	return;
    }

    if(fstat(inf, &infstat) == -1) {
	perror(filename);
	close(inf);
	return;
    }

    if(infstat.st_size < sizeof(struct exec)) {
	fprintf(stderr, "%s: short file\n", filename);
	close(inf);
	return;
    }

    if((buf = mmap(NULL, infstat.st_size, PROT_READ|PROT_WRITE,
		   MAP_FILE|MAP_SHARED, inf, 0)) == MAP_FAILED) {
	fprintf(stderr, "%s: cannot map\n", filename);
	close(inf);
	return;
    }
d271 6
a276 7
    if(buf[0] == 0x7f && (buf[1] == 'E' || buf[1] == 'O') &&
       buf[2] == 'L' && buf[3] == 'F') {
	printf("processing elf/olf file\n");
	elf_hide(inf, buf);
	return;
    }
#endif /* _NLIST_DO_ELF */
d279 5
a283 6
    if(!ECOFF_BADMAG((struct ecoff_exechdr *)buf)) {
	printf("processing ecoff file\n");
	ecoff_hide(inf, buf);
	return;
    }
#endif /* _NLIST_DO_ECOFF */
d286 1
a286 1
    aoutdata = buf;
d288 46
a333 5
    /*
     * Check the header and calculate offsets and sizes from it.
     */

    hdrp = (struct exec *) aoutdata;
d335 2
a336 3
    if(N_BADMAG(*hdrp)) {
	fprintf(stderr, "%s: bad magic: not an a.out, ecoff or elf  file\n",
		filename);
d338 1
a338 51
	return;
    }

#ifdef __FreeBSD__
    textrel = (struct relocation_info *) (aoutdata + N_RELOFF(*hdrp));
    datarel = (struct relocation_info *) (aoutdata + N_RELOFF(*hdrp) +
					  hdrp->a_trsize);
#else
    textrel = (struct relocation_info *) (aoutdata + N_TRELOFF(*hdrp));
    datarel = (struct relocation_info *) (aoutdata + N_DRELOFF(*hdrp));
#endif
    symbase = (struct nlist *)		 (aoutdata + N_SYMOFF(*hdrp));
    strbase = (char *) 			 (aoutdata + N_STROFF(*hdrp));

    ntextrel = hdrp->a_trsize / sizeof(struct relocation_info);
    ndatarel = hdrp->a_drsize / sizeof(struct relocation_info);
    nsyms    = hdrp->a_syms   / sizeof(struct nlist);

    /*
     * Zap the type field of all globally-defined symbols.  The linker will
     * subsequently ignore these entries.  Don't zap any symbols in the
     * keep list.
     */

    for(symp = symbase; symp < symbase + nsyms; symp++)
	if(IS_GLOBAL_DEFINED(symp) && !in_keep_list(SYMSTR(symp))) {
	    /*
	     * XXX Our VM system has some problems, so
	     * avoid the VM system....
	     */
	    lseek(inf, (off_t)((void *)&symp->n_type - (void *)buf), SEEK_SET);
	    write(inf, &zero, sizeof zero);
	    symp->n_type = 0;
	}

    /*
     * Check whether the relocation entries reference any symbols that we
     * just zapped.  I don't know whether ld can handle this case, but I
     * haven't encountered it yet.  These checks are here so that the program
     * doesn't fail silently should such symbols be encountered.
     */

    for(relp = textrel; relp < textrel + ntextrel; relp++)
	check_reloc(filename, relp);
    for(relp = datarel; relp < datarel + ndatarel; relp++)
	check_reloc(filename, relp);

    msync(buf, infstat.st_size, MS_SYNC);
    munmap(buf, infstat.st_size);
    close(inf);
#endif /* DO_AOUT */
d342 2
a343 1
void check_reloc(char *filename, struct relocation_info *relp)
d345 7
a351 7
    /* bail out if we zapped a symbol that is needed */
    if(IS_SYMBOL_RELOC(relp) && symbase[relp->r_symbolnum].n_type == 0) {
	fprintf(stderr,
		"%s: oops, have hanging relocation for %s: bailing out!\n",
		filename, SYMSTR(&symbase[relp->r_symbolnum]));
	exit(1);
    }
d353 1
a353 1
#endif /* DO_AOUT */
@


1.15
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchide.c,v 1.14 2001/09/18 21:23:41 jason Exp $	*/
d79 2
a80 1
#if defined(_NLIST_DO_AOUT) && !(defined(__alpha__) || defined(__mips__))
d217 1
a217 1
#if defined(__sparc__) && !defined(__sparc64__)
@


1.14
log
@make this better for sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchide.c,v 1.13 2001/05/11 14:08:19 art Exp $	*/
d60 1
a60 1
 */ 
@


1.13
log
@-1 -> MAP_FAILED
@
text
@d1 1
a1 1
/*	$OpenBSD: crunchide.c,v 1.12 2000/03/01 22:10:03 todd Exp $	*/
d216 1
a216 1
#ifdef __sparc__
@


1.12
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d261 1
a261 1
		   MAP_FILE|MAP_SHARED, inf, 0)) == (char *)-1) {
@


1.11
log
@__sparc -> __sparc__
@
text
@d1 2
@


1.10
log
@work around the vm system problem, gross eh
@
text
@d214 1
a214 1
#ifdef __sparc
@


1.9
log
@tabify
@
text
@d235 1
d320 7
a326 1
	if(IS_GLOBAL_DEFINED(symp) && !in_keep_list(SYMSTR(symp)))
d328 1
d342 2
@


1.8
log
@Add ECOFF support, do some slight restructuring to share the mmap between
the different object file format models
@
text
@d212 1
a212 1
                  (((sp)->n_type & N_EXT) && ((sp)->n_type & N_TYPE) != N_UNDF)
d223 1
a223 1
                  ((rp)->r_extern||(rp)->r_baserel||(rp)->r_jmptable)
d259 3
a261 3
        fprintf(stderr, "%s: cannot map\n", filename);
        close(inf);
        return;
d275 1
a275 1
        printf("processing ecoff file\n");
@


1.7
log
@Hack away a.out support on mips-based OpenBSD platforms.
This probably still needs work as ld later bombs on crunched objects, bu
at least it compiles and runs now.
@
text
@d66 5
d72 8
a79 1
#include <sys/errno.h>
d85 2
a86 4
void add_to_keep_list(char *symbol);
void add_file_to_keep_list(char *filename);

void hide_syms(char *filename);
d88 7
d234 1
a234 1
    char	buf[4];
d257 6
a262 19
	if((rc = read(inf, &buf, 4)) < 4) {
		fprintf(stderr, "%s: read error: %s\n", filename,
		rc == -1? strerror(errno) : "short read");
		close(inf);
		return;
	}

	lseek(inf, 0, SEEK_SET);

	if (buf[0] == 0x7f &&
		(buf[1] == 'E' || buf[1] == 'O') &&
		buf[2] == 'L' &&
		buf[3] == 'F')
	{

		printf("processing elf/olf file\n");
		elf_hide(inf);
		return;
	}
d264 5
a268 9
#if !defined(__mips__) || !defined(__OpenBSD__)
    /*
     * Read the entire file into memory.  XXX - Really, we only need to
     * read the header and from TRELOFF to the end of the file.
     */

    if((aoutdata = (char *) calloc(1,infstat.st_size)) == NULL) {
	fprintf(stderr, "%s: too big to read into memory\n", filename);
	close(inf);
d271 1
d273 4
a276 4
    if((rc = read(inf, aoutdata, infstat.st_size)) < infstat.st_size) {
	fprintf(stderr, "%s: read error: %s\n", filename,
		rc == -1? strerror(errno) : "short read");
	close(inf);
d279 4
d291 2
a292 1
	fprintf(stderr, "%s: bad magic: not an a.out file\n", filename);
a333 10
    /*
     * Write the .o file back out to disk.  XXX - Really, we only need to
     * write the symbol table entries back out.
     */
    lseek(inf, 0, SEEK_SET);
    if((rc = write(inf, aoutdata, infstat.st_size)) < infstat.st_size) {
	fprintf(stderr, "%s: write error: %s\n", filename,
		rc == -1? strerror(errno) : "short write");
    }

d335 1
a335 1
#endif
d338 1
a338 1
#if !defined(__mips__) || !defined(__OpenBSD__)
d349 1
a349 1
#endif
@


1.6
log
@init allocated memory.
@
text
@d260 1
a260 1

d339 1
d342 1
a342 1

d353 1
@


1.5
log
@make crunchide work in the non-elf world, Opps.
@
text
@d138 1
a138 1
    newp = (struct keep *) malloc(sizeof(struct keep));
d266 1
a266 1
    if((aoutdata = (char *) malloc(infstat.st_size)) == NULL) {
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d247 2
@


1.3
log
@Add the ablity to hide symbols on ELF/OLF objects.
This is a first cut at the symbol hiding process for ELF.
The current method will not work properly on mips.
It has been tested for powerpc and should work on alpha.
The problem with mips is due to the standard PIC compilation.
@
text
@d87 1
a87 1
    while ((ch = getopt(argc, argv, "k:f:")) != EOF)
@


1.2
log
@sparc support from NetBSD
@
text
@d217 1
d239 19
@


1.1
log
@Initial revision
@
text
@d197 7
d207 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
