head	1.1014;
access;
symbols
	OPENBSD_6_1:1.989.0.4
	OPENBSD_6_1_BASE:1.989
	OPENBSD_6_0:1.902.0.2
	OPENBSD_6_0_BASE:1.902
	OPENBSD_5_9:1.880.0.2
	OPENBSD_5_9_BASE:1.880
	OPENBSD_5_8:1.854.0.4
	OPENBSD_5_8_BASE:1.854
	OPENBSD_5_7:1.815.0.2
	OPENBSD_5_7_BASE:1.815
	OPENBSD_5_6:1.788.0.4
	OPENBSD_5_6_BASE:1.788
	OPENBSD_5_5:1.752.0.4
	OPENBSD_5_5_BASE:1.752
	OPENBSD_5_4:1.682.0.2
	OPENBSD_5_4_BASE:1.682
	OPENBSD_5_3:1.674.0.2
	OPENBSD_5_3_BASE:1.674
	OPENBSD_5_2:1.662.0.2
	OPENBSD_5_2_BASE:1.662
	OPENBSD_5_1_BASE:1.655
	OPENBSD_5_1:1.655.0.2
	OPENBSD_5_0:1.652.0.2
	OPENBSD_5_0_BASE:1.652
	OPENBSD_4_9:1.635.0.2
	OPENBSD_4_9_BASE:1.635
	OPENBSD_4_8:1.617.0.2
	OPENBSD_4_8_BASE:1.617
	OPENBSD_4_7:1.600.0.2
	OPENBSD_4_7_BASE:1.600
	OPENBSD_4_6:1.592.0.2
	OPENBSD_4_6_BASE:1.592
	OPENBSD_4_5:1.447.0.2
	OPENBSD_4_5_BASE:1.447
	OPENBSD_4_4:1.436.0.2
	OPENBSD_4_4_BASE:1.436
	OPENBSD_4_3:1.426.0.2
	OPENBSD_4_3_BASE:1.426
	OPENBSD_4_2:1.421.0.2
	OPENBSD_4_2_BASE:1.421
	OPENBSD_4_1:1.411.0.2
	OPENBSD_4_1_BASE:1.411
	OPENBSD_4_0:1.406.0.2
	OPENBSD_4_0_BASE:1.406
	OPENBSD_3_9:1.401.0.2
	OPENBSD_3_9_BASE:1.401
	OPENBSD_3_8:1.390.0.2
	OPENBSD_3_8_BASE:1.390
	OPENBSD_3_7:1.363.0.2
	OPENBSD_3_7_BASE:1.363
	OPENBSD_3_6:1.351.0.2
	OPENBSD_3_6_BASE:1.351
	OPENBSD_3_5:1.337.0.2
	OPENBSD_3_5_BASE:1.337
	OPENBSD_3_4:1.320.0.2
	OPENBSD_3_4_BASE:1.320
	OPENBSD_3_3:1.293.0.2
	OPENBSD_3_3_BASE:1.293
	OPENBSD_3_2:1.265.0.2
	OPENBSD_3_2_BASE:1.265
	OPENBSD_3_1:1.205.0.2
	OPENBSD_3_1_BASE:1.205
	OPENBSD_3_0:1.170.0.2
	OPENBSD_3_0_BASE:1.170
	OPENBSD_2_9:1.166.0.2
	OPENBSD_2_9_BASE:1.166
	OPENBSD_2_8:1.158.0.2
	OPENBSD_2_8_BASE:1.158
	OPENBSD_2_7:1.153.0.2
	OPENBSD_2_7_BASE:1.153
	OPENBSD_2_6:1.145.0.2
	OPENBSD_2_6_BASE:1.145
	OPENBSD_2_5:1.122.0.2
	OPENBSD_2_5_BASE:1.122
	OPENBSD_2_4:1.108.0.2
	OPENBSD_2_4_BASE:1.108
	OPENBSD_2_3:1.75.0.2
	OPENBSD_2_3_BASE:1.75
	OPENBSD_2_2:1.48.0.2
	OPENBSD_2_2_BASE:1.48
	OPENBSD_2_1:1.35.0.2
	OPENBSD_2_1_BASE:1.35
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@# @;


1.1014
date	2017.06.03.22.27.41;	author deraadt;	state Exp;
branches;
next	1.1013;
commitid	fI5gnZRFJHA7r5YG;

1.1013
date	2017.05.31.08.02.56;	author tb;	state Exp;
branches;
next	1.1012;
commitid	oWhJZ5ULXVP4y8pg;

1.1012
date	2017.05.31.07.55.29;	author tb;	state Exp;
branches;
next	1.1011;
commitid	UshDEHKN2jmBTCQy;

1.1011
date	2017.05.28.09.24.56;	author rpe;	state Exp;
branches;
next	1.1010;
commitid	UWh5sdCBzCFBdsX8;

1.1010
date	2017.05.27.09.05.18;	author zhuk;	state Exp;
branches;
next	1.1009;
commitid	IRDscqhGTOcmuJal;

1.1009
date	2017.05.25.12.10.04;	author rpe;	state Exp;
branches;
next	1.1008;
commitid	QJhJJ8RI2oPXYgtD;

1.1008
date	2017.05.25.08.25.00;	author rpe;	state Exp;
branches;
next	1.1007;
commitid	SszxpRvSrgw2eK6S;

1.1007
date	2017.05.22.19.03.24;	author rpe;	state Exp;
branches;
next	1.1006;
commitid	WPiNPmDXCHlNgdkK;

1.1006
date	2017.05.22.17.15.52;	author rpe;	state Exp;
branches;
next	1.1005;
commitid	DoA7RVibmBfjK0aV;

1.1005
date	2017.05.21.09.09.58;	author rpe;	state Exp;
branches;
next	1.1004;
commitid	5EAYquIHzzvEVdCT;

1.1004
date	2017.05.15.17.12.25;	author rpe;	state Exp;
branches;
next	1.1003;
commitid	GRr49qlCUqarkp43;

1.1003
date	2017.05.15.17.02.48;	author rpe;	state Exp;
branches;
next	1.1002;
commitid	1Nb1loYiTchjyWam;

1.1002
date	2017.05.15.16.55.53;	author rpe;	state Exp;
branches;
next	1.1001;
commitid	oGvYHVNIC8reaSGu;

1.1001
date	2017.05.06.06.49.12;	author rpe;	state Exp;
branches;
next	1.1000;
commitid	FzMNltTeSiPjKhqz;

1.1000
date	2017.05.01.14.29.39;	author rpe;	state Exp;
branches;
next	1.999;
commitid	RGAt9eSPlOvFlCLX;

1.999
date	2017.05.01.14.22.36;	author rpe;	state Exp;
branches;
next	1.998;
commitid	vTzhdhvzFKfqIrqW;

1.998
date	2017.04.25.19.24.05;	author rpe;	state Exp;
branches;
next	1.997;
commitid	7XqgJs7m6kkQ9Ast;

1.997
date	2017.04.24.20.27.59;	author rpe;	state Exp;
branches;
next	1.996;
commitid	8Q05ABtELJoffnJx;

1.996
date	2017.04.11.19.23.10;	author rpe;	state Exp;
branches;
next	1.995;
commitid	BWg2rTAI0UQSU1v4;

1.995
date	2017.04.07.22.53.25;	author rpe;	state Exp;
branches;
next	1.994;
commitid	nR5UAjaz6p2qXcJ8;

1.994
date	2017.04.07.22.15.17;	author rpe;	state Exp;
branches;
next	1.993;
commitid	nCVemAu9TctNNzZD;

1.993
date	2017.04.07.22.02.29;	author rpe;	state Exp;
branches;
next	1.992;
commitid	6xMfc1HsqGy5WGB0;

1.992
date	2017.04.07.21.44.07;	author rpe;	state Exp;
branches;
next	1.991;
commitid	FJTLaKgpM0PdNit4;

1.991
date	2017.04.07.21.00.42;	author rpe;	state Exp;
branches;
next	1.990;
commitid	2b8KagYLekae1NZM;

1.990
date	2017.04.04.17.50.45;	author rpe;	state Exp;
branches;
next	1.989;
commitid	zdwg2OU4wJe5HTZQ;

1.989
date	2017.03.31.18.36.49;	author rpe;	state Exp;
branches;
next	1.988;
commitid	vZF8Db51BSdVpCEW;

1.988
date	2017.03.13.17.08.31;	author rpe;	state Exp;
branches;
next	1.987;
commitid	XtV9SsnGzNxWw8zy;

1.987
date	2017.03.10.22.34.09;	author rpe;	state Exp;
branches;
next	1.986;
commitid	00k1MTtwpKMuLCw7;

1.986
date	2017.03.10.22.11.28;	author rpe;	state Exp;
branches;
next	1.985;
commitid	YWpr6uoEXI3xBoF5;

1.985
date	2017.03.10.22.02.59;	author rpe;	state Exp;
branches;
next	1.984;
commitid	Zu48hayGydHkRIdH;

1.984
date	2017.03.10.19.04.17;	author rpe;	state Exp;
branches;
next	1.983;
commitid	mEVP6s5Q93teM5bh;

1.983
date	2017.03.10.17.40.26;	author rpe;	state Exp;
branches;
next	1.982;
commitid	w6bt4klD5Z3hCAbj;

1.982
date	2017.03.06.22.10.14;	author rpe;	state Exp;
branches;
next	1.981;
commitid	5Mkn6Wv42Q63rF2v;

1.981
date	2017.03.05.19.31.15;	author rpe;	state Exp;
branches;
next	1.980;
commitid	57ngHWBKJ4mEQh6p;

1.980
date	2017.03.01.20.48.12;	author rpe;	state Exp;
branches;
next	1.979;
commitid	GkXwdXOPgDv46368;

1.979
date	2017.02.28.19.42.38;	author rpe;	state Exp;
branches;
next	1.978;
commitid	DSu4eDht5cMhEl4E;

1.978
date	2017.02.28.18.32.15;	author rpe;	state Exp;
branches;
next	1.977;
commitid	rc9rjo91KpPQvnEi;

1.977
date	2017.02.27.22.02.09;	author rpe;	state Exp;
branches;
next	1.976;
commitid	nuzWyhr0z5SeGxAl;

1.976
date	2017.02.26.16.51.18;	author matthieu;	state Exp;
branches;
next	1.975;
commitid	P2dlZXDE2JznJMG3;

1.975
date	2017.02.25.12.57.03;	author rpe;	state Exp;
branches;
next	1.974;
commitid	T9xg1YJSHz7k4kvP;

1.974
date	2017.02.19.17.53.58;	author tb;	state Exp;
branches;
next	1.973;
commitid	8VKPQXsGz8ki3I4M;

1.973
date	2017.02.14.22.23.04;	author rpe;	state Exp;
branches;
next	1.972;
commitid	o9h7tNOKpsYwXZVT;

1.972
date	2017.02.14.22.05.13;	author rpe;	state Exp;
branches;
next	1.971;
commitid	9X1KLJRiJ11Bxe0N;

1.971
date	2017.02.14.22.03.01;	author rpe;	state Exp;
branches;
next	1.970;
commitid	4e32xr8HV1DkuCTw;

1.970
date	2017.02.12.08.58.30;	author landry;	state Exp;
branches;
next	1.969;
commitid	OV52HW8OLxTeckpg;

1.969
date	2017.02.08.23.13.02;	author rpe;	state Exp;
branches;
next	1.968;
commitid	m8wyKqhwmEPY6bBG;

1.968
date	2017.02.08.22.56.01;	author rpe;	state Exp;
branches;
next	1.967;
commitid	JuSAkZ6pxtmKBT7Q;

1.967
date	2017.02.08.22.43.37;	author rpe;	state Exp;
branches;
next	1.966;
commitid	5w5WqZuWIUrGj4uf;

1.966
date	2017.02.08.22.29.39;	author rpe;	state Exp;
branches;
next	1.965;
commitid	W0uEDOOHWm8Jmrbc;

1.965
date	2017.02.08.22.16.49;	author rpe;	state Exp;
branches;
next	1.964;
commitid	52PKG0OuEeUhfEYC;

1.964
date	2017.02.08.22.04.03;	author rpe;	state Exp;
branches;
next	1.963;
commitid	qhjrBUnK5ClcykGT;

1.963
date	2017.02.08.21.35.18;	author rpe;	state Exp;
branches;
next	1.962;
commitid	3jWXefo58NiT5rWr;

1.962
date	2017.02.05.19.29.32;	author rpe;	state Exp;
branches;
next	1.961;
commitid	skZbKjkmXhTntdtd;

1.961
date	2017.02.05.15.39.52;	author rpe;	state Exp;
branches;
next	1.960;
commitid	IeErm8uKrEViyM4B;

1.960
date	2017.02.05.14.57.15;	author rpe;	state Exp;
branches;
next	1.959;
commitid	GBRrt6YRx7xNXoph;

1.959
date	2017.02.05.14.40.16;	author rpe;	state Exp;
branches;
next	1.958;
commitid	i6jtgH9y5uIuHJsm;

1.958
date	2017.01.24.10.14.14;	author rpe;	state Exp;
branches;
next	1.957;
commitid	x5JH8nGnXoHmMg9T;

1.957
date	2017.01.24.10.06.21;	author rpe;	state Exp;
branches;
next	1.956;
commitid	IXzyPLWlmQKOzhY4;

1.956
date	2017.01.23.02.14.45;	author rpe;	state Exp;
branches;
next	1.955;
commitid	bghJyZYwKH0P50Ts;

1.955
date	2017.01.23.02.11.30;	author rpe;	state Exp;
branches;
next	1.954;
commitid	5fjBtJoEkvpNcHGk;

1.954
date	2017.01.22.23.38.30;	author rpe;	state Exp;
branches;
next	1.953;
commitid	4QpKFqF4soAVEEsK;

1.953
date	2017.01.22.23.37.37;	author rpe;	state Exp;
branches;
next	1.952;
commitid	jpvp8dcUkXQNwbVQ;

1.952
date	2017.01.22.23.23.23;	author rpe;	state Exp;
branches;
next	1.951;
commitid	Tff3S8e6ynlUs7Fm;

1.951
date	2017.01.22.22.47.11;	author rpe;	state Exp;
branches;
next	1.950;
commitid	yuBgBZZrliUIoEfM;

1.950
date	2017.01.22.03.30.23;	author rpe;	state Exp;
branches;
next	1.949;
commitid	EUvi0z9DJJf51TUK;

1.949
date	2017.01.21.04.33.00;	author rpe;	state Exp;
branches;
next	1.948;
commitid	5DFmnqPI5faaBG2g;

1.948
date	2017.01.20.23.14.52;	author rpe;	state Exp;
branches;
next	1.947;
commitid	NkBPeG8m6quoBXEE;

1.947
date	2017.01.11.20.43.46;	author tb;	state Exp;
branches;
next	1.946;
commitid	zYgMHdfwn3cURtS1;

1.946
date	2017.01.11.10.57.12;	author ajacoutot;	state Exp;
branches;
next	1.945;
commitid	IzGDVzBMPPHaw8Gt;

1.945
date	2017.01.10.17.50.58;	author deraadt;	state Exp;
branches;
next	1.944;
commitid	OYGNUAtiF4DWzmDC;

1.944
date	2017.01.10.00.15.16;	author bluhm;	state Exp;
branches;
next	1.943;
commitid	eDn7xf8YDZZ6Nyic;

1.943
date	2017.01.09.19.42.32;	author rpe;	state Exp;
branches;
next	1.942;
commitid	nIwKC8teXlQG3uD8;

1.942
date	2017.01.04.13.47.29;	author rpe;	state Exp;
branches;
next	1.941;
commitid	85va48t1VsZXfVOM;

1.941
date	2017.01.04.13.39.52;	author rpe;	state Exp;
branches;
next	1.940;
commitid	dtsIUY02mm4Luf6h;

1.940
date	2017.01.03.19.33.48;	author rpe;	state Exp;
branches;
next	1.939;
commitid	qWFzoy7QH2m3G9Gx;

1.939
date	2016.12.30.22.59.12;	author rpe;	state Exp;
branches;
next	1.938;
commitid	DN1IwVvlZrpAUYc0;

1.938
date	2016.12.28.11.11.13;	author rpe;	state Exp;
branches;
next	1.937;
commitid	YEo4tnsYy73tV739;

1.937
date	2016.12.27.09.17.52;	author jca;	state Exp;
branches;
next	1.936;
commitid	3qP8ymCdYHblqMMe;

1.936
date	2016.12.19.19.59.38;	author rpe;	state Exp;
branches;
next	1.935;
commitid	GiZqnQyEImeFnlBn;

1.935
date	2016.12.19.18.52.54;	author rpe;	state Exp;
branches;
next	1.934;
commitid	RMgzlwbnZeg8BFT6;

1.934
date	2016.12.18.18.15.14;	author rpe;	state Exp;
branches;
next	1.933;
commitid	Xtmv8cwh6kLXp25N;

1.933
date	2016.11.25.21.13.58;	author rpe;	state Exp;
branches;
next	1.932;
commitid	a36lezX794gSrqcg;

1.932
date	2016.11.24.14.35.43;	author krw;	state Exp;
branches;
next	1.931;
commitid	ieqYaosHmjbRVB0g;

1.931
date	2016.11.14.21.34.39;	author rpe;	state Exp;
branches;
next	1.930;
commitid	uxUtEIR2ptsmTbOj;

1.930
date	2016.11.05.09.14.36;	author rpe;	state Exp;
branches;
next	1.929;
commitid	hAyarSHmswnwilJu;

1.929
date	2016.10.30.13.27.05;	author rpe;	state Exp;
branches;
next	1.928;
commitid	3McsrV9q47ihcB7u;

1.928
date	2016.10.29.18.36.12;	author rpe;	state Exp;
branches;
next	1.927;
commitid	2F6iT7xUqjIybliM;

1.927
date	2016.10.28.17.07.34;	author rpe;	state Exp;
branches;
next	1.926;
commitid	GUPVvuovNLEvpwbV;

1.926
date	2016.10.23.08.42.58;	author rpe;	state Exp;
branches;
next	1.925;
commitid	NaV20k72c7j3DLOi;

1.925
date	2016.10.09.10.20.53;	author rpe;	state Exp;
branches;
next	1.924;
commitid	KC4U0SsEUWgS7xdf;

1.924
date	2016.09.25.15.48.15;	author rpe;	state Exp;
branches;
next	1.923;
commitid	8Dh1DhQjn9xsfGpz;

1.923
date	2016.09.25.06.06.52;	author rpe;	state Exp;
branches;
next	1.922;
commitid	VsnbNWJDaZpggb0h;

1.922
date	2016.09.22.20.48.37;	author rpe;	state Exp;
branches;
next	1.921;
commitid	JVApfdSsixWhiJxn;

1.921
date	2016.09.22.20.45.22;	author rpe;	state Exp;
branches;
next	1.920;
commitid	Ax1LjnO4mUcHpksN;

1.920
date	2016.09.16.15.35.05;	author krw;	state Exp;
branches;
next	1.919;
commitid	jiOxHm2cvBZrOIg7;

1.919
date	2016.09.16.13.28.20;	author krw;	state Exp;
branches;
next	1.918;
commitid	ee1AYjlj4xEokJ7R;

1.918
date	2016.09.13.21.25.29;	author halex;	state Exp;
branches;
next	1.917;
commitid	eJvXkJPcp0l19eev;

1.917
date	2016.09.11.03.16.52;	author deraadt;	state Exp;
branches;
next	1.916;
commitid	ORUnxJvjaC2FeeeW;

1.916
date	2016.09.10.22.34.17;	author rpe;	state Exp;
branches;
next	1.915;
commitid	SgK4gDvuY5vJ9CR1;

1.915
date	2016.09.10.17.18.30;	author rpe;	state Exp;
branches;
next	1.914;
commitid	jSGm4hYmU3rOPuen;

1.914
date	2016.09.10.15.14.52;	author rpe;	state Exp;
branches;
next	1.913;
commitid	JMFLRopvXMcuwF7z;

1.913
date	2016.09.10.08.10.19;	author rpe;	state Exp;
branches;
next	1.912;
commitid	baqX9PLH17L15jil;

1.912
date	2016.09.04.12.36.33;	author halex;	state Exp;
branches;
next	1.911;
commitid	Bq70oaIrTRuJsi89;

1.911
date	2016.09.04.10.15.04;	author halex;	state Exp;
branches;
next	1.910;
commitid	vBvP9qjHWrOj1wxm;

1.910
date	2016.09.04.09.56.46;	author rpe;	state Exp;
branches;
next	1.909;
commitid	EXeiXjuJ69mSwSKw;

1.909
date	2016.09.03.11.40.32;	author rpe;	state Exp;
branches;
next	1.908;
commitid	zdJvLW0iQ20qxcbM;

1.908
date	2016.09.03.11.29.17;	author rpe;	state Exp;
branches;
next	1.907;
commitid	vo8pKLA7ucHBP0BF;

1.907
date	2016.09.02.21.42.28;	author halex;	state Exp;
branches;
next	1.906;
commitid	VlkUtjIPnQKMevTD;

1.906
date	2016.08.23.16.49.48;	author krw;	state Exp;
branches;
next	1.905;
commitid	mF7Adh87mjE8gbBe;

1.905
date	2016.08.21.19.22.15;	author halex;	state Exp;
branches;
next	1.904;
commitid	p95zroTmf0pFzCcf;

1.904
date	2016.08.21.18.47.01;	author rpe;	state Exp;
branches;
next	1.903;
commitid	a0oKqalrjF7rIQrT;

1.903
date	2016.08.17.13.53.20;	author krw;	state Exp;
branches;
next	1.902;
commitid	lYmBZmGPFPWAwFnN;

1.902
date	2016.07.23.17.55.45;	author deraadt;	state Exp;
branches;
next	1.901;
commitid	MzuRLN0ApThoLpIp;

1.901
date	2016.05.27.21.13.17;	author deraadt;	state Exp;
branches;
next	1.900;
commitid	cllzlltj7aqLB6zN;

1.900
date	2016.05.27.20.17.39;	author rpe;	state Exp;
branches;
next	1.899;
commitid	RWBZSrSbTXn0YGMy;

1.899
date	2016.05.26.15.27.09;	author rpe;	state Exp;
branches;
next	1.898;
commitid	uDJ7MLonA5vePJHF;

1.898
date	2016.05.22.19.12.21;	author rpe;	state Exp;
branches;
next	1.897;
commitid	9iatKT1btJdMH6K3;

1.897
date	2016.05.20.17.28.43;	author rpe;	state Exp;
branches;
next	1.896;
commitid	r1hvq2Trf6PIoh5v;

1.896
date	2016.05.20.17.12.42;	author rpe;	state Exp;
branches;
next	1.895;
commitid	khv9qOCVHf8N0G95;

1.895
date	2016.04.28.18.17.30;	author natano;	state Exp;
branches;
next	1.894;
commitid	yJ7nITWQGOm5qxNW;

1.894
date	2016.04.27.14.50.18;	author ajacoutot;	state Exp;
branches;
next	1.893;
commitid	DVAYE6YV1bub10Kb;

1.893
date	2016.04.25.09.55.23;	author ajacoutot;	state Exp;
branches;
next	1.892;
commitid	SFHYR2mRv8H1nGsR;

1.892
date	2016.04.11.19.04.30;	author rpe;	state Exp;
branches;
next	1.891;
commitid	jY4JwDrgEZmSgOZG;

1.891
date	2016.04.11.18.47.05;	author rpe;	state Exp;
branches;
next	1.890;
commitid	FOPWAQAdj0ujAKpS;

1.890
date	2016.04.09.15.14.47;	author rpe;	state Exp;
branches;
next	1.889;
commitid	ge6g5Drc7M49QmiL;

1.889
date	2016.04.09.11.03.42;	author rpe;	state Exp;
branches;
next	1.888;
commitid	nozuMOzmPHOmnxXD;

1.888
date	2016.04.08.17.41.08;	author rpe;	state Exp;
branches;
next	1.887;
commitid	9xSicpkn4iuK78bn;

1.887
date	2016.04.08.17.17.54;	author rpe;	state Exp;
branches;
next	1.886;
commitid	ljNv4NuGAKF1W9gh;

1.886
date	2016.04.02.13.52.04;	author rpe;	state Exp;
branches;
next	1.885;
commitid	CgCxc62as64hNxOE;

1.885
date	2016.04.02.13.34.48;	author rpe;	state Exp;
branches;
next	1.884;
commitid	ppobpDoy1pl8LoXZ;

1.884
date	2016.04.02.12.23.46;	author rpe;	state Exp;
branches;
next	1.883;
commitid	RiZ3BjQb9aPCOLdl;

1.883
date	2016.03.05.17.18.27;	author rpe;	state Exp;
branches;
next	1.882;
commitid	687AqfUVbekezU9q;

1.882
date	2016.02.27.12.28.16;	author rpe;	state Exp;
branches;
next	1.881;
commitid	0oqVTiEnH9Xc7x9E;

1.881
date	2016.02.27.12.17.03;	author rpe;	state Exp;
branches;
next	1.880;
commitid	ehlQml3IYp8cfNEg;

1.880
date	2016.02.23.02.34.09;	author krw;	state Exp;
branches;
next	1.879;
commitid	gwUH8t5kZQGsGeyp;

1.879
date	2016.02.20.12.08.55;	author rpe;	state Exp;
branches;
next	1.878;
commitid	tBqgzLNv9dXEdu7Z;

1.878
date	2016.02.20.12.03.11;	author rpe;	state Exp;
branches;
next	1.877;
commitid	vPloziCLnBpSIfb4;

1.877
date	2016.02.12.14.18.31;	author rpe;	state Exp;
branches;
next	1.876;
commitid	sCM81A9RmQmva0wu;

1.876
date	2016.01.31.11.03.49;	author rpe;	state Exp;
branches;
next	1.875;
commitid	Jn5UoPCGT4JJ7Nk1;

1.875
date	2016.01.25.23.46.54;	author rpe;	state Exp;
branches;
next	1.874;
commitid	D5R7OrCLbMQiJDUP;

1.874
date	2016.01.24.09.16.57;	author rpe;	state Exp;
branches;
next	1.873;
commitid	7ImvQQcEy6KQxzJh;

1.873
date	2016.01.24.09.13.57;	author rpe;	state Exp;
branches;
next	1.872;
commitid	JrNhVNWuDRcDI8Fj;

1.872
date	2016.01.17.18.01.31;	author rpe;	state Exp;
branches;
next	1.871;
commitid	5eiV8n3B5sdceHVq;

1.871
date	2016.01.12.00.17.05;	author rpe;	state Exp;
branches;
next	1.870;
commitid	MDaEGogqhDxf9IvW;

1.870
date	2016.01.10.17.47.14;	author rpe;	state Exp;
branches;
next	1.869;
commitid	SwexLI6SleRJaINr;

1.869
date	2016.01.10.17.44.35;	author rpe;	state Exp;
branches;
next	1.868;
commitid	j0lYaRx3BkJKYJue;

1.868
date	2016.01.09.18.10.57;	author krw;	state Exp;
branches;
next	1.867;
commitid	ptrgnU3nbXhej2kY;

1.867
date	2015.12.27.18.42.11;	author rpe;	state Exp;
branches;
next	1.866;
commitid	pclZ6pbnIK9CJZ2z;

1.866
date	2015.12.23.18.06.32;	author rpe;	state Exp;
branches;
next	1.865;
commitid	SOqXkdccBkBPhkdZ;

1.865
date	2015.12.23.17.45.13;	author rpe;	state Exp;
branches;
next	1.864;
commitid	QCVnmFwirFNxfEYh;

1.864
date	2015.12.23.08.05.11;	author rpe;	state Exp;
branches;
next	1.863;
commitid	zi8f6De8fTe0OXr4;

1.863
date	2015.12.23.08.00.09;	author rpe;	state Exp;
branches;
next	1.862;
commitid	TkPlENGxTEkC12bG;

1.862
date	2015.12.18.16.20.58;	author rpe;	state Exp;
branches;
next	1.861;
commitid	VkQ4KC1oXExBZv81;

1.861
date	2015.12.06.20.29.07;	author rpe;	state Exp;
branches;
next	1.860;
commitid	2UMvZD2ocMxHHBVU;

1.860
date	2015.11.20.14.41.48;	author sthen;	state Exp;
branches;
next	1.859;
commitid	qhEZ5k71gJVlr5vw;

1.859
date	2015.11.18.17.48.45;	author sthen;	state Exp;
branches;
next	1.858;
commitid	39Jcgj2fEnd7GO0q;

1.858
date	2015.09.27.19.00.32;	author halex;	state Exp;
branches;
next	1.857;
commitid	Z8I4qNv5jnaGiXUt;

1.857
date	2015.09.09.23.07.10;	author halex;	state Exp;
branches;
next	1.856;
commitid	PMnT1G5OfPyllg1U;

1.856
date	2015.09.09.15.04.54;	author halex;	state Exp;
branches;
next	1.855;
commitid	vuWULq0LKUdacRbp;

1.855
date	2015.08.24.10.41.11;	author ajacoutot;	state Exp;
branches;
next	1.854;
commitid	FOxg7563yuuySklf;

1.854
date	2015.08.06.14.55.51;	author deraadt;	state Exp;
branches;
next	1.853;
commitid	zPJfs25OPOyvDnby;

1.853
date	2015.08.06.13.15.53;	author deraadt;	state Exp;
branches;
next	1.852;
commitid	WzXAgOTO7cJ0zWd3;

1.852
date	2015.08.06.06.39.41;	author deraadt;	state Exp;
branches;
next	1.851;
commitid	zAaKCQuVvJezYsVr;

1.851
date	2015.08.01.16.20.40;	author rpe;	state Exp;
branches;
next	1.850;
commitid	kbW4ptGVfAj3P9Oh;

1.850
date	2015.07.30.19.40.32;	author rpe;	state Exp;
branches;
next	1.849;
commitid	jDyCsNVgU8HkfvdG;

1.849
date	2015.07.20.01.12.49;	author rpe;	state Exp;
branches;
next	1.848;
commitid	cPOhA7Pmk6p7bkBo;

1.848
date	2015.07.19.19.33.51;	author rpe;	state Exp;
branches;
next	1.847;
commitid	odFbSbqy53lobLvV;

1.847
date	2015.07.17.15.11.52;	author rpe;	state Exp;
branches;
next	1.846;
commitid	GcixMXi3DthacqXi;

1.846
date	2015.07.16.21.05.08;	author halex;	state Exp;
branches;
next	1.845;
commitid	iKUlemEhiihXQuPF;

1.845
date	2015.07.05.09.17.39;	author rpe;	state Exp;
branches;
next	1.844;
commitid	36yt8CVTLJTjFTNL;

1.844
date	2015.07.03.18.29.08;	author rpe;	state Exp;
branches;
next	1.843;
commitid	fEgyl3TxLrCchTnJ;

1.843
date	2015.06.02.19.54.06;	author rpe;	state Exp;
branches;
next	1.842;
commitid	zUqrjWrWSBxkCmbI;

1.842
date	2015.05.31.19.40.10;	author rpe;	state Exp;
branches;
next	1.841;
commitid	p6r5f9n0C0WoWNND;

1.841
date	2015.05.20.19.14.35;	author rpe;	state Exp;
branches;
next	1.840;
commitid	yDFOqgPb16xhvc7H;

1.840
date	2015.05.19.20.12.29;	author rpe;	state Exp;
branches;
next	1.839;
commitid	140Oy6HCqOGjkJLU;

1.839
date	2015.05.18.13.48.37;	author deraadt;	state Exp;
branches;
next	1.838;
commitid	cjVIf2Z4Y6BU1kqx;

1.838
date	2015.05.15.07.41.30;	author rpe;	state Exp;
branches;
next	1.837;
commitid	d54NkJap2U60xp2L;

1.837
date	2015.05.14.10.58.55;	author rpe;	state Exp;
branches;
next	1.836;
commitid	oz6sDsFipTbRkg4l;

1.836
date	2015.05.04.19.55.26;	author rpe;	state Exp;
branches;
next	1.835;
commitid	NyWrBKI5Tnb4FUEi;

1.835
date	2015.04.28.21.41.40;	author sthen;	state Exp;
branches;
next	1.834;
commitid	Y9g7tvyIT7O3kUBa;

1.834
date	2015.04.27.23.17.11;	author djm;	state Exp;
branches;
next	1.833;
commitid	Ud6JIGs2CHffDv3h;

1.833
date	2015.04.26.14.49.23;	author henning;	state Exp;
branches;
next	1.832;
commitid	ajxroI3yWxpXu9IJ;

1.832
date	2015.04.21.10.58.28;	author henning;	state Exp;
branches;
next	1.831;
commitid	T8563u36ExhT09Ar;

1.831
date	2015.04.20.15.31.15;	author krw;	state Exp;
branches;
next	1.830;
commitid	KAGU5MyXWexr963p;

1.830
date	2015.04.06.13.34.23;	author rpe;	state Exp;
branches;
next	1.829;
commitid	3hpJNPIqJeoSBl6p;

1.829
date	2015.04.05.12.37.14;	author rpe;	state Exp;
branches;
next	1.828;
commitid	iBMmoV5KooZLWIdd;

1.828
date	2015.04.04.14.21.01;	author rpe;	state Exp;
branches;
next	1.827;
commitid	PLsgWFhLbeuIMtBT;

1.827
date	2015.04.04.11.06.33;	author rpe;	state Exp;
branches;
next	1.826;
commitid	DLE8GOHg4Xr00cDW;

1.826
date	2015.04.03.17.03.15;	author rpe;	state Exp;
branches;
next	1.825;
commitid	dfCoQ0VdQM2uaNJ3;

1.825
date	2015.03.28.17.03.11;	author rpe;	state Exp;
branches;
next	1.824;
commitid	4TVJKkJBevokqh7s;

1.824
date	2015.03.28.00.03.05;	author rpe;	state Exp;
branches;
next	1.823;
commitid	hxX5UqHok9DNQnHK;

1.823
date	2015.03.27.22.15.39;	author rpe;	state Exp;
branches;
next	1.822;
commitid	EjwYupPEuLAbP2OZ;

1.822
date	2015.03.21.21.13.52;	author rpe;	state Exp;
branches;
next	1.821;
commitid	VKdBgQ8m9TdT8dp3;

1.821
date	2015.03.21.18.27.39;	author rpe;	state Exp;
branches;
next	1.820;
commitid	cTmTDNBnYCzsWagc;

1.820
date	2015.03.21.16.45.53;	author rpe;	state Exp;
branches;
next	1.819;
commitid	CAaZgSJyonV9u9n9;

1.819
date	2015.03.17.15.21.02;	author rpe;	state Exp;
branches;
next	1.818;
commitid	YtERzUYeDwSeSq2m;

1.818
date	2015.03.15.00.09.50;	author krw;	state Exp;
branches;
next	1.817;
commitid	nPhSKx0QlrXHsDNu;

1.817
date	2015.03.13.15.02.14;	author deraadt;	state Exp;
branches;
next	1.816;
commitid	1C5d4AAVuqEQAbbP;

1.816
date	2015.03.11.21.00.35;	author krw;	state Exp;
branches;
next	1.815;
commitid	1VeYYTWfKdJjaTAv;

1.815
date	2015.03.08.13.15.00;	author deraadt;	state Exp;
branches;
next	1.814;
commitid	j23L3va8IhbuleWn;

1.814
date	2015.03.08.13.12.50;	author deraadt;	state Exp;
branches;
next	1.813;
commitid	HNLSr8xf87dxUrbm;

1.813
date	2015.03.05.17.56.35;	author krw;	state Exp;
branches;
next	1.812;
commitid	qeGtIu9OjQtzIizp;

1.812
date	2015.01.24.00.20.35;	author krw;	state Exp;
branches;
next	1.811;
commitid	BCAp0kJGEQ46cGLN;

1.811
date	2015.01.17.14.36.58;	author rpe;	state Exp;
branches;
next	1.810;
commitid	llqJ2fSD7Ovk1rc3;

1.810
date	2015.01.17.10.09.06;	author rpe;	state Exp;
branches;
next	1.809;
commitid	FDCZTEbNeaMFQNj3;

1.809
date	2015.01.12.16.33.31;	author deraadt;	state Exp;
branches;
next	1.808;
commitid	A44BjxYQVmvEK2uf;

1.808
date	2015.01.07.19.31.51;	author rpe;	state Exp;
branches;
next	1.807;
commitid	rT1FtRnC1zUoeja6;

1.807
date	2015.01.07.19.20.53;	author rpe;	state Exp;
branches;
next	1.806;
commitid	mu7XQtdQXpKcRk9k;

1.806
date	2015.01.04.18.44.12;	author tedu;	state Exp;
branches;
next	1.805;
commitid	qK8s9vGR7wFclT1l;

1.805
date	2015.01.04.02.26.29;	author tedu;	state Exp;
branches;
next	1.804;
commitid	BUdFpy400ltuFofL;

1.804
date	2015.01.01.22.53.39;	author krw;	state Exp;
branches;
next	1.803;
commitid	gtpj4sg3JzENq0LL;

1.803
date	2014.12.29.17.04.19;	author deraadt;	state Exp;
branches;
next	1.802;
commitid	7LAhpQii4Xm1N3MU;

1.802
date	2014.12.29.16.55.44;	author tedu;	state Exp;
branches;
next	1.801;
commitid	BVqb2xxZ3Rst2CMe;

1.801
date	2014.12.26.17.54.54;	author rpe;	state Exp;
branches;
next	1.800;
commitid	TIunIkT37krZgCIo;

1.800
date	2014.12.03.19.55.49;	author florian;	state Exp;
branches;
next	1.799;
commitid	jPX9re7e8bvWad2L;

1.799
date	2014.11.18.19.00.16;	author rpe;	state Exp;
branches;
next	1.798;
commitid	AsIFBVjQu8LwsIzO;

1.798
date	2014.11.11.21.31.29;	author rpe;	state Exp;
branches;
next	1.797;
commitid	cDZK2xIiukkd6Cg4;

1.797
date	2014.10.26.23.31.00;	author krw;	state Exp;
branches;
next	1.796;
commitid	J2HQBEkBjX4Jtrrr;

1.796
date	2014.10.23.21.33.21;	author rpe;	state Exp;
branches;
next	1.795;
commitid	ckuAGTb8ys2YbbuO;

1.795
date	2014.10.08.00.26.38;	author krw;	state Exp;
branches;
next	1.794;
commitid	0nlBJ2hwsMn7tnRa;

1.794
date	2014.09.26.15.44.21;	author benno;	state Exp;
branches;
next	1.793;
commitid	5ZVI3OTXN2B5HHJ5;

1.793
date	2014.08.31.20.10.36;	author rpe;	state Exp;
branches;
next	1.792;
commitid	gzZWI95CLSBRI2sd;

1.792
date	2014.08.26.20.19.26;	author rpe;	state Exp;
branches;
next	1.791;
commitid	2uCZGoLImpFRV5IL;

1.791
date	2014.08.10.20.54.17;	author rpe;	state Exp;
branches;
next	1.790;
commitid	AEJaun4iwMUJHcjT;

1.790
date	2014.08.10.16.32.28;	author rpe;	state Exp;
branches;
next	1.789;
commitid	lCRNSFKztsAF7nlY;

1.789
date	2014.08.09.21.51.29;	author halex;	state Exp;
branches;
next	1.788;
commitid	LINk3EUUsDVK3Tv6;

1.788
date	2014.07.28.14.12.14;	author kettenis;	state Exp;
branches;
next	1.787;
commitid	KYh85Ed3yjk6oKQy;

1.787
date	2014.07.28.05.42.26;	author rpe;	state Exp;
branches;
next	1.786;
commitid	v2Ba7iPVyfXDOCvB;

1.786
date	2014.07.22.17.01.33;	author deraadt;	state Exp;
branches;
next	1.785;
commitid	ZW1jD0rSsDhHPSQx;

1.785
date	2014.07.22.06.45.31;	author ajacoutot;	state Exp;
branches;
next	1.784;
commitid	hpLArYX4YZqaknr3;

1.784
date	2014.07.20.20.08.44;	author deraadt;	state Exp;
branches;
next	1.783;
commitid	cFY9IbKxmZIIVhYM;

1.783
date	2014.07.20.18.13.22;	author deraadt;	state Exp;
branches;
next	1.782;
commitid	tVjYpTL4I7KlmFyJ;

1.782
date	2014.07.16.08.27.14;	author ajacoutot;	state Exp;
branches;
next	1.781;
commitid	gLpvhCCdHAsHflLk;

1.781
date	2014.07.15.08.49.50;	author deraadt;	state Exp;
branches;
next	1.780;
commitid	tgQOjoDBlfYCUp5J;

1.780
date	2014.07.13.21.24.43;	author rpe;	state Exp;
branches;
next	1.779;
commitid	fi97teEbcpeFPOdo;

1.779
date	2014.07.13.13.53.36;	author rpe;	state Exp;
branches;
next	1.778;
commitid	emU4wiE9pJnmRk71;

1.778
date	2014.07.12.15.27.15;	author rpe;	state Exp;
branches;
next	1.777;
commitid	LnaLTeb1IvlgUy5R;

1.777
date	2014.07.11.13.21.08;	author deraadt;	state Exp;
branches;
next	1.776;
commitid	Y1pkvPoygyiec5MK;

1.776
date	2014.06.16.19.31.41;	author rpe;	state Exp;
branches;
next	1.775;
commitid	Nd7vcSRh3OM20C5R;

1.775
date	2014.06.09.18.05.55;	author rpe;	state Exp;
branches;
next	1.774;
commitid	lk8XC2UIp99hcUUb;

1.774
date	2014.05.11.08.23.46;	author rpe;	state Exp;
branches;
next	1.773;

1.773
date	2014.05.10.17.25.21;	author rpe;	state Exp;
branches;
next	1.772;

1.772
date	2014.05.08.16.46.47;	author krw;	state Exp;
branches;
next	1.771;

1.771
date	2014.05.05.00.09.16;	author bluhm;	state Exp;
branches;
next	1.770;

1.770
date	2014.05.04.13.08.39;	author krw;	state Exp;
branches;
next	1.769;

1.769
date	2014.05.04.10.47.25;	author krw;	state Exp;
branches;
next	1.768;

1.768
date	2014.04.25.19.34.24;	author halex;	state Exp;
branches;
next	1.767;

1.767
date	2014.04.21.23.15.09;	author rpe;	state Exp;
branches;
next	1.766;

1.766
date	2014.04.21.19.05.40;	author rpe;	state Exp;
branches;
next	1.765;

1.765
date	2014.04.21.15.56.19;	author rpe;	state Exp;
branches;
next	1.764;

1.764
date	2014.04.21.12.41.36;	author rpe;	state Exp;
branches;
next	1.763;

1.763
date	2014.04.20.15.53.57;	author rpe;	state Exp;
branches;
next	1.762;

1.762
date	2014.04.20.10.51.59;	author rpe;	state Exp;
branches;
next	1.761;

1.761
date	2014.04.19.18.31.24;	author rpe;	state Exp;
branches;
next	1.760;

1.760
date	2014.04.19.16.50.52;	author rpe;	state Exp;
branches;
next	1.759;

1.759
date	2014.04.16.13.12.22;	author krw;	state Exp;
branches;
next	1.758;

1.758
date	2014.04.04.19.44.02;	author krw;	state Exp;
branches;
next	1.757;

1.757
date	2014.03.22.02.42.00;	author krw;	state Exp;
branches;
next	1.756;

1.756
date	2014.03.22.02.24.43;	author krw;	state Exp;
branches;
next	1.755;

1.755
date	2014.03.22.01.13.02;	author krw;	state Exp;
branches;
next	1.754;

1.754
date	2014.03.20.20.01.28;	author krw;	state Exp;
branches;
next	1.753;

1.753
date	2014.03.10.00.14.34;	author rpe;	state Exp;
branches;
next	1.752;

1.752
date	2014.03.02.14.12.16;	author deraadt;	state Exp;
branches;
next	1.751;

1.751
date	2014.03.02.03.36.22;	author deraadt;	state Exp;
branches;
next	1.750;

1.750
date	2014.02.28.23.51.54;	author krw;	state Exp;
branches;
next	1.749;

1.749
date	2014.02.22.05.13.22;	author deraadt;	state Exp;
branches;
next	1.748;

1.748
date	2014.02.21.19.47.31;	author deraadt;	state Exp;
branches;
next	1.747;

1.747
date	2014.02.21.16.30.14;	author deraadt;	state Exp;
branches;
next	1.746;

1.746
date	2014.02.21.16.29.08;	author deraadt;	state Exp;
branches;
next	1.745;

1.745
date	2014.02.20.00.26.14;	author rpe;	state Exp;
branches;
next	1.744;

1.744
date	2014.02.19.18.48.23;	author rpe;	state Exp;
branches;
next	1.743;

1.743
date	2014.02.07.23.28.21;	author halex;	state Exp;
branches;
next	1.742;

1.742
date	2014.02.03.23.28.00;	author rpe;	state Exp;
branches;
next	1.741;

1.741
date	2014.02.02.19.33.23;	author rpe;	state Exp;
branches;
next	1.740;

1.740
date	2014.02.02.17.37.24;	author rpe;	state Exp;
branches;
next	1.739;

1.739
date	2014.02.02.17.10.33;	author rpe;	state Exp;
branches;
next	1.738;

1.738
date	2014.02.01.23.16.16;	author rpe;	state Exp;
branches;
next	1.737;

1.737
date	2014.01.28.21.34.44;	author halex;	state Exp;
branches;
next	1.736;

1.736
date	2014.01.27.23.18.53;	author rpe;	state Exp;
branches;
next	1.735;

1.735
date	2014.01.26.21.54.32;	author rpe;	state Exp;
branches;
next	1.734;

1.734
date	2014.01.26.19.01.03;	author rpe;	state Exp;
branches;
next	1.733;

1.733
date	2014.01.24.01.12.10;	author halex;	state Exp;
branches;
next	1.732;

1.732
date	2014.01.23.22.17.57;	author deraadt;	state Exp;
branches;
next	1.731;

1.731
date	2014.01.23.21.56.42;	author rpe;	state Exp;
branches;
next	1.730;

1.730
date	2014.01.23.01.04.41;	author rpe;	state Exp;
branches;
next	1.729;

1.729
date	2014.01.17.01.15.27;	author halex;	state Exp;
branches;
next	1.728;

1.728
date	2014.01.15.00.55.21;	author rpe;	state Exp;
branches;
next	1.727;

1.727
date	2014.01.11.23.28.02;	author halex;	state Exp;
branches;
next	1.726;

1.726
date	2014.01.08.21.53.35;	author deraadt;	state Exp;
branches;
next	1.725;

1.725
date	2014.01.07.23.58.44;	author rpe;	state Exp;
branches;
next	1.724;

1.724
date	2014.01.05.01.52.17;	author deraadt;	state Exp;
branches;
next	1.723;

1.723
date	2013.12.23.13.57.05;	author rpe;	state Exp;
branches;
next	1.722;

1.722
date	2013.12.18.08.04.16;	author halex;	state Exp;
branches;
next	1.721;

1.721
date	2013.12.16.16.58.22;	author halex;	state Exp;
branches;
next	1.720;

1.720
date	2013.12.16.08.15.21;	author halex;	state Exp;
branches;
next	1.719;

1.719
date	2013.12.11.23.28.01;	author halex;	state Exp;
branches;
next	1.718;

1.718
date	2013.12.11.06.37.46;	author halex;	state Exp;
branches;
next	1.717;

1.717
date	2013.12.09.23.14.34;	author halex;	state Exp;
branches;
next	1.716;

1.716
date	2013.12.08.12.38.48;	author stsp;	state Exp;
branches;
next	1.715;

1.715
date	2013.12.07.09.36.10;	author halex;	state Exp;
branches;
next	1.714;

1.714
date	2013.12.06.00.42.45;	author rpe;	state Exp;
branches;
next	1.713;

1.713
date	2013.12.05.00.44.49;	author halex;	state Exp;
branches;
next	1.712;

1.712
date	2013.12.04.21.21.35;	author halex;	state Exp;
branches;
next	1.711;

1.711
date	2013.12.04.16.19.32;	author krw;	state Exp;
branches;
next	1.710;

1.710
date	2013.12.04.01.08.49;	author sthen;	state Exp;
branches;
next	1.709;

1.709
date	2013.12.01.21.01.01;	author halex;	state Exp;
branches;
next	1.708;

1.708
date	2013.12.01.01.54.23;	author halex;	state Exp;
branches;
next	1.707;

1.707
date	2013.11.29.22.28.12;	author rpe;	state Exp;
branches;
next	1.706;

1.706
date	2013.11.29.02.02.47;	author rpe;	state Exp;
branches;
next	1.705;

1.705
date	2013.11.28.22.56.05;	author rpe;	state Exp;
branches;
next	1.704;

1.704
date	2013.11.28.22.31.07;	author halex;	state Exp;
branches;
next	1.703;

1.703
date	2013.11.28.21.20.40;	author rpe;	state Exp;
branches;
next	1.702;

1.702
date	2013.11.27.21.49.21;	author deraadt;	state Exp;
branches;
next	1.701;

1.701
date	2013.11.27.21.48.25;	author rpe;	state Exp;
branches;
next	1.700;

1.700
date	2013.11.25.23.02.04;	author rpe;	state Exp;
branches;
next	1.699;

1.699
date	2013.11.25.21.51.48;	author rpe;	state Exp;
branches;
next	1.698;

1.698
date	2013.11.23.13.25.47;	author rpe;	state Exp;
branches;
next	1.697;

1.697
date	2013.11.19.12.02.55;	author rpe;	state Exp;
branches;
next	1.696;

1.696
date	2013.11.18.21.31.39;	author rpe;	state Exp;
branches;
next	1.695;

1.695
date	2013.11.13.19.17.22;	author rpe;	state Exp;
branches;
next	1.694;

1.694
date	2013.11.13.07.16.55;	author rpe;	state Exp;
branches;
next	1.693;

1.693
date	2013.11.12.15.30.11;	author rpe;	state Exp;
branches;
next	1.692;

1.692
date	2013.11.12.13.20.47;	author rpe;	state Exp;
branches;
next	1.691;

1.691
date	2013.11.09.22.37.53;	author rpe;	state Exp;
branches;
next	1.690;

1.690
date	2013.11.09.19.38.59;	author rpe;	state Exp;
branches;
next	1.689;

1.689
date	2013.11.09.19.32.55;	author rpe;	state Exp;
branches;
next	1.688;

1.688
date	2013.11.08.21.34.35;	author rpe;	state Exp;
branches;
next	1.687;

1.687
date	2013.11.05.19.54.40;	author uwe;	state Exp;
branches;
next	1.686;

1.686
date	2013.10.31.19.15.20;	author halex;	state Exp;
branches;
next	1.685;

1.685
date	2013.10.27.22.36.06;	author uwe;	state Exp;
branches;
next	1.684;

1.684
date	2013.08.19.21.07.22;	author halex;	state Exp;
branches;
next	1.683;

1.683
date	2013.07.31.11.26.58;	author ajacoutot;	state Exp;
branches;
next	1.682;

1.682
date	2013.07.21.22.06.51;	author halex;	state Exp;
branches;
next	1.681;

1.681
date	2013.06.10.21.19.29;	author rpe;	state Exp;
branches;
next	1.680;

1.680
date	2013.06.04.00.42.23;	author halex;	state Exp;
branches;
next	1.679;

1.679
date	2013.06.02.14.55.39;	author halex;	state Exp;
branches;
next	1.678;

1.678
date	2013.05.31.23.52.18;	author halex;	state Exp;
branches;
next	1.677;

1.677
date	2013.05.31.06.27.08;	author rpe;	state Exp;
branches;
next	1.676;

1.676
date	2013.05.25.15.00.25;	author rpe;	state Exp;
branches;
next	1.675;

1.675
date	2013.03.25.21.35.45;	author halex;	state Exp;
branches;
next	1.674;

1.674
date	2013.01.02.20.35.00;	author krw;	state Exp;
branches;
next	1.673;

1.673
date	2012.12.16.20.01.26;	author rpe;	state Exp;
branches;
next	1.672;

1.672
date	2012.11.22.17.57.22;	author ajacoutot;	state Exp;
branches;
next	1.671;

1.671
date	2012.11.06.17.49.39;	author krw;	state Exp;
branches;
next	1.670;

1.670
date	2012.10.21.06.41.14;	author deraadt;	state Exp;
branches;
next	1.669;

1.669
date	2012.10.20.22.40.25;	author halex;	state Exp;
branches;
next	1.668;

1.668
date	2012.10.01.18.49.13;	author rpe;	state Exp;
branches;
next	1.667;

1.667
date	2012.09.29.17.42.10;	author rpe;	state Exp;
branches;
next	1.666;

1.666
date	2012.09.29.17.17.10;	author rpe;	state Exp;
branches;
next	1.665;

1.665
date	2012.09.03.07.34.37;	author deraadt;	state Exp;
branches;
next	1.664;

1.664
date	2012.09.03.04.35.30;	author deraadt;	state Exp;
branches;
next	1.663;

1.663
date	2012.09.03.04.34.36;	author deraadt;	state Exp;
branches;
next	1.662;

1.662
date	2012.07.20.01.33.40;	author krw;	state Exp;
branches;
next	1.661;

1.661
date	2012.07.14.08.45.33;	author halex;	state Exp;
branches;
next	1.660;

1.660
date	2012.07.12.10.42.48;	author halex;	state Exp;
branches;
next	1.659;

1.659
date	2012.07.09.10.51.10;	author halex;	state Exp;
branches;
next	1.658;

1.658
date	2012.07.08.10.10.18;	author halex;	state Exp;
branches;
next	1.657;

1.657
date	2012.04.21.10.17.26;	author henning;	state Exp;
branches;
next	1.656;

1.656
date	2012.03.12.22.45.39;	author halex;	state Exp;
branches;
next	1.655;

1.655
date	2011.11.22.14.02.14;	author krw;	state Exp;
branches;
next	1.654;

1.654
date	2011.11.08.19.55.52;	author deraadt;	state Exp;
branches;
next	1.653;

1.653
date	2011.10.18.19.02.44;	author matthieu;	state Exp;
branches;
next	1.652;

1.652
date	2011.08.08.15.41.17;	author halex;	state Exp;
branches;
next	1.651;

1.651
date	2011.08.07.15.07.22;	author krw;	state Exp;
branches;
next	1.650;

1.650
date	2011.08.02.20.40.52;	author deraadt;	state Exp;
branches;
next	1.649;

1.649
date	2011.08.02.15.52.04;	author deraadt;	state Exp;
branches;
next	1.648;

1.648
date	2011.07.28.19.11.33;	author halex;	state Exp;
branches;
next	1.647;

1.647
date	2011.07.14.14.54.57;	author ajacoutot;	state Exp;
branches;
next	1.646;

1.646
date	2011.07.09.17.53.58;	author halex;	state Exp;
branches;
next	1.645;

1.645
date	2011.07.09.03.14.53;	author deraadt;	state Exp;
branches;
next	1.644;

1.644
date	2011.07.09.03.12.24;	author ajacoutot;	state Exp;
branches;
next	1.643;

1.643
date	2011.07.09.01.20.37;	author halex;	state Exp;
branches;
next	1.642;

1.642
date	2011.07.06.23.38.41;	author halex;	state Exp;
branches;
next	1.641;

1.641
date	2011.07.06.20.02.16;	author halex;	state Exp;
branches;
next	1.640;

1.640
date	2011.07.06.15.35.15;	author ajacoutot;	state Exp;
branches;
next	1.639;

1.639
date	2011.07.04.20.59.05;	author halex;	state Exp;
branches;
next	1.638;

1.638
date	2011.04.18.16.52.10;	author thib;	state Exp;
branches;
next	1.637;

1.637
date	2011.04.17.20.57.10;	author krw;	state Exp;
branches;
next	1.636;

1.636
date	2011.03.22.19.20.15;	author krw;	state Exp;
branches;
next	1.635;

1.635
date	2011.02.25.12.55.45;	author krw;	state Exp;
branches;
next	1.634;

1.634
date	2011.01.31.16.48.18;	author halex;	state Exp;
branches;
next	1.633;

1.633
date	2011.01.06.16.59.06;	author otto;	state Exp;
branches;
next	1.632;

1.632
date	2011.01.03.00.36.50;	author deraadt;	state Exp;
branches;
next	1.631;

1.631
date	2010.11.22.14.10.42;	author halex;	state Exp;
branches;
next	1.630;

1.630
date	2010.11.19.19.33.13;	author halex;	state Exp;
branches;
next	1.629;

1.629
date	2010.11.18.23.25.46;	author deraadt;	state Exp;
branches;
next	1.628;

1.628
date	2010.11.12.06.47.40;	author halex;	state Exp;
branches;
next	1.627;

1.627
date	2010.11.05.00.23.05;	author halex;	state Exp;
branches;
next	1.626;

1.626
date	2010.11.04.06.39.19;	author deraadt;	state Exp;
branches;
next	1.625;

1.625
date	2010.11.04.04.15.56;	author deraadt;	state Exp;
branches;
next	1.624;

1.624
date	2010.10.18.22.47.07;	author deraadt;	state Exp;
branches;
next	1.623;

1.623
date	2010.10.18.22.45.28;	author halex;	state Exp;
branches;
next	1.622;

1.622
date	2010.10.18.04.18.26;	author deraadt;	state Exp;
branches;
next	1.621;

1.621
date	2010.09.26.14.49.05;	author joshe;	state Exp;
branches;
next	1.620;

1.620
date	2010.09.24.07.44.43;	author ajacoutot;	state Exp;
branches;
next	1.619;

1.619
date	2010.09.23.13.30.15;	author jsing;	state Exp;
branches;
next	1.618;

1.618
date	2010.08.30.09.52.07;	author halex;	state Exp;
branches;
next	1.617;

1.617
date	2010.08.08.21.06.06;	author krw;	state Exp;
branches;
next	1.616;

1.616
date	2010.08.08.17.02.14;	author krw;	state Exp;
branches;
next	1.615;

1.615
date	2010.08.05.10.45.32;	author halex;	state Exp;
branches;
next	1.614;

1.614
date	2010.08.02.11.21.35;	author krw;	state Exp;
branches;
next	1.613;

1.613
date	2010.07.07.07.15.00;	author halex;	state Exp;
branches;
next	1.612;

1.612
date	2010.07.04.22.51.05;	author deraadt;	state Exp;
branches;
next	1.611;

1.611
date	2010.07.04.22.12.38;	author deraadt;	state Exp;
branches;
next	1.610;

1.610
date	2010.06.30.23.02.38;	author phessler;	state Exp;
branches;
next	1.609;

1.609
date	2010.06.30.20.22.01;	author halex;	state Exp;
branches;
next	1.608;

1.608
date	2010.06.30.19.31.19;	author halex;	state Exp;
branches;
next	1.607;

1.607
date	2010.06.30.00.23.02;	author halex;	state Exp;
branches;
next	1.606;

1.606
date	2010.06.29.15.11.45;	author halex;	state Exp;
branches;
next	1.605;

1.605
date	2010.06.26.20.44.15;	author halex;	state Exp;
branches;
next	1.604;

1.604
date	2010.06.21.02.54.46;	author krw;	state Exp;
branches;
next	1.603;

1.603
date	2010.06.21.02.19.16;	author krw;	state Exp;
branches;
next	1.602;

1.602
date	2010.04.05.01.09.45;	author deraadt;	state Exp;
branches;
next	1.601;

1.601
date	2010.04.04.22.29.08;	author halex;	state Exp;
branches;
next	1.600;

1.600
date	2010.03.09.23.34.09;	author deraadt;	state Exp;
branches;
next	1.599;

1.599
date	2010.03.09.15.06.36;	author krw;	state Exp;
branches;
next	1.598;

1.598
date	2010.03.04.02.07.55;	author krw;	state Exp;
branches;
next	1.597;

1.597
date	2010.03.02.01.24.50;	author krw;	state Exp;
branches;
next	1.596;

1.596
date	2010.01.13.00.15.26;	author todd;	state Exp;
branches;
next	1.595;

1.595
date	2010.01.03.04.25.42;	author krw;	state Exp;
branches;
next	1.594;

1.594
date	2009.07.23.00.30.03;	author krw;	state Exp;
branches;
next	1.593;

1.593
date	2009.07.14.23.45.16;	author krw;	state Exp;
branches;
next	1.592;

1.592
date	2009.07.09.23.45.20;	author deraadt;	state Exp;
branches;
next	1.591;

1.591
date	2009.07.06.22.11.11;	author krw;	state Exp;
branches;
next	1.590;

1.590
date	2009.07.03.00.42.47;	author deraadt;	state Exp;
branches;
next	1.589;

1.589
date	2009.07.01.19.12.53;	author deraadt;	state Exp;
branches;
next	1.588;

1.588
date	2009.06.29.23.56.49;	author deraadt;	state Exp;
branches;
next	1.587;

1.587
date	2009.06.19.00.42.04;	author krw;	state Exp;
branches;
next	1.586;

1.586
date	2009.06.12.08.25.57;	author halex;	state Exp;
branches;
next	1.585;

1.585
date	2009.06.12.03.25.24;	author krw;	state Exp;
branches;
next	1.584;

1.584
date	2009.06.11.04.21.27;	author deraadt;	state Exp;
branches;
next	1.583;

1.583
date	2009.06.11.02.28.49;	author krw;	state Exp;
branches;
next	1.582;

1.582
date	2009.06.10.07.03.29;	author deraadt;	state Exp;
branches;
next	1.581;

1.581
date	2009.06.10.07.01.25;	author deraadt;	state Exp;
branches;
next	1.580;

1.580
date	2009.06.10.01.28.10;	author krw;	state Exp;
branches;
next	1.579;

1.579
date	2009.06.10.00.53.40;	author deraadt;	state Exp;
branches;
next	1.578;

1.578
date	2009.06.10.00.52.48;	author deraadt;	state Exp;
branches;
next	1.577;

1.577
date	2009.06.09.10.11.21;	author halex;	state Exp;
branches;
next	1.576;

1.576
date	2009.06.09.03.33.49;	author krw;	state Exp;
branches;
next	1.575;

1.575
date	2009.06.07.03.52.29;	author krw;	state Exp;
branches;
next	1.574;

1.574
date	2009.06.05.05.43.42;	author halex;	state Exp;
branches;
next	1.573;

1.573
date	2009.06.04.02.27.48;	author sthen;	state Exp;
branches;
next	1.572;

1.572
date	2009.06.03.23.44.53;	author krw;	state Exp;
branches;
next	1.571;

1.571
date	2009.06.03.06.07.37;	author halex;	state Exp;
branches;
next	1.570;

1.570
date	2009.06.03.00.30.31;	author krw;	state Exp;
branches;
next	1.569;

1.569
date	2009.06.02.23.53.34;	author krw;	state Exp;
branches;
next	1.568;

1.568
date	2009.06.02.22.44.27;	author krw;	state Exp;
branches;
next	1.567;

1.567
date	2009.06.02.10.35.26;	author halex;	state Exp;
branches;
next	1.566;

1.566
date	2009.06.02.08.59.22;	author halex;	state Exp;
branches;
next	1.565;

1.565
date	2009.06.02.03.21.31;	author halex;	state Exp;
branches;
next	1.564;

1.564
date	2009.05.31.17.57.27;	author deraadt;	state Exp;
branches;
next	1.563;

1.563
date	2009.05.31.03.34.15;	author krw;	state Exp;
branches;
next	1.562;

1.562
date	2009.05.31.00.03.29;	author deraadt;	state Exp;
branches;
next	1.561;

1.561
date	2009.05.31.00.02.50;	author deraadt;	state Exp;
branches;
next	1.560;

1.560
date	2009.05.30.20.40.59;	author deraadt;	state Exp;
branches;
next	1.559;

1.559
date	2009.05.30.19.32.20;	author deraadt;	state Exp;
branches;
next	1.558;

1.558
date	2009.05.30.18.17.16;	author deraadt;	state Exp;
branches;
next	1.557;

1.557
date	2009.05.29.00.46.41;	author deraadt;	state Exp;
branches;
next	1.556;

1.556
date	2009.05.28.02.34.56;	author krw;	state Exp;
branches;
next	1.555;

1.555
date	2009.05.24.00.17.37;	author halex;	state Exp;
branches;
next	1.554;

1.554
date	2009.05.19.07.46.03;	author halex;	state Exp;
branches;
next	1.553;

1.553
date	2009.05.19.02.56.45;	author deraadt;	state Exp;
branches;
next	1.552;

1.552
date	2009.05.17.04.59.43;	author deraadt;	state Exp;
branches;
next	1.551;

1.551
date	2009.05.17.04.41.46;	author deraadt;	state Exp;
branches;
next	1.550;

1.550
date	2009.05.17.00.43.13;	author deraadt;	state Exp;
branches;
next	1.549;

1.549
date	2009.05.16.08.51.57;	author halex;	state Exp;
branches;
next	1.548;

1.548
date	2009.05.15.02.00.36;	author krw;	state Exp;
branches;
next	1.547;

1.547
date	2009.05.15.01.40.42;	author krw;	state Exp;
branches;
next	1.546;

1.546
date	2009.05.15.01.31.01;	author deraadt;	state Exp;
branches;
next	1.545;

1.545
date	2009.05.12.09.05.54;	author halex;	state Exp;
branches;
next	1.544;

1.544
date	2009.05.09.22.41.01;	author martynas;	state Exp;
branches;
next	1.543;

1.543
date	2009.05.09.21.34.23;	author deraadt;	state Exp;
branches;
next	1.542;

1.542
date	2009.05.09.19.33.35;	author deraadt;	state Exp;
branches;
next	1.541;

1.541
date	2009.05.09.19.11.11;	author deraadt;	state Exp;
branches;
next	1.540;

1.540
date	2009.05.08.18.39.57;	author deraadt;	state Exp;
branches;
next	1.539;

1.539
date	2009.05.08.14.32.52;	author deraadt;	state Exp;
branches;
next	1.538;

1.538
date	2009.05.08.05.47.38;	author deraadt;	state Exp;
branches;
next	1.537;

1.537
date	2009.05.08.03.01.42;	author deraadt;	state Exp;
branches;
next	1.536;

1.536
date	2009.05.07.03.43.02;	author todd;	state Exp;
branches;
next	1.535;

1.535
date	2009.05.06.22.48.03;	author sthen;	state Exp;
branches;
next	1.534;

1.534
date	2009.05.06.20.41.38;	author todd;	state Exp;
branches;
next	1.533;

1.533
date	2009.05.06.02.07.19;	author krw;	state Exp;
branches;
next	1.532;

1.532
date	2009.05.06.01.29.48;	author deraadt;	state Exp;
branches;
next	1.531;

1.531
date	2009.05.06.01.00.14;	author krw;	state Exp;
branches;
next	1.530;

1.530
date	2009.05.05.21.26.09;	author deraadt;	state Exp;
branches;
next	1.529;

1.529
date	2009.05.05.21.23.58;	author deraadt;	state Exp;
branches;
next	1.528;

1.528
date	2009.05.05.21.22.14;	author deraadt;	state Exp;
branches;
next	1.527;

1.527
date	2009.05.05.21.16.34;	author deraadt;	state Exp;
branches;
next	1.526;

1.526
date	2009.05.05.21.14.46;	author deraadt;	state Exp;
branches;
next	1.525;

1.525
date	2009.05.05.21.11.57;	author deraadt;	state Exp;
branches;
next	1.524;

1.524
date	2009.05.05.21.09.54;	author deraadt;	state Exp;
branches;
next	1.523;

1.523
date	2009.05.05.19.36.31;	author sthen;	state Exp;
branches;
next	1.522;

1.522
date	2009.05.05.18.54.40;	author todd;	state Exp;
branches;
next	1.521;

1.521
date	2009.05.05.00.37.09;	author deraadt;	state Exp;
branches;
next	1.520;

1.520
date	2009.05.04.22.07.28;	author deraadt;	state Exp;
branches;
next	1.519;

1.519
date	2009.05.04.21.45.11;	author deraadt;	state Exp;
branches;
next	1.518;

1.518
date	2009.05.04.06.21.58;	author deraadt;	state Exp;
branches;
next	1.517;

1.517
date	2009.05.04.03.30.00;	author deraadt;	state Exp;
branches;
next	1.516;

1.516
date	2009.05.04.03.16.11;	author deraadt;	state Exp;
branches;
next	1.515;

1.515
date	2009.05.04.02.30.59;	author deraadt;	state Exp;
branches;
next	1.514;

1.514
date	2009.05.03.21.21.26;	author deraadt;	state Exp;
branches;
next	1.513;

1.513
date	2009.05.03.21.20.47;	author sthen;	state Exp;
branches;
next	1.512;

1.512
date	2009.05.03.06.19.14;	author deraadt;	state Exp;
branches;
next	1.511;

1.511
date	2009.05.03.03.35.17;	author deraadt;	state Exp;
branches;
next	1.510;

1.510
date	2009.05.03.00.27.28;	author deraadt;	state Exp;
branches;
next	1.509;

1.509
date	2009.05.02.17.01.26;	author deraadt;	state Exp;
branches;
next	1.508;

1.508
date	2009.05.01.16.36.07;	author deraadt;	state Exp;
branches;
next	1.507;

1.507
date	2009.05.01.16.14.12;	author deraadt;	state Exp;
branches;
next	1.506;

1.506
date	2009.05.01.15.52.15;	author deraadt;	state Exp;
branches;
next	1.505;

1.505
date	2009.05.01.01.06.17;	author krw;	state Exp;
branches;
next	1.504;

1.504
date	2009.04.30.21.18.29;	author deraadt;	state Exp;
branches;
next	1.503;

1.503
date	2009.04.30.02.42.45;	author deraadt;	state Exp;
branches;
next	1.502;

1.502
date	2009.04.30.01.03.28;	author deraadt;	state Exp;
branches;
next	1.501;

1.501
date	2009.04.30.01.01.56;	author deraadt;	state Exp;
branches;
next	1.500;

1.500
date	2009.04.30.00.28.22;	author deraadt;	state Exp;
branches;
next	1.499;

1.499
date	2009.04.29.22.45.20;	author deraadt;	state Exp;
branches;
next	1.498;

1.498
date	2009.04.29.22.44.42;	author deraadt;	state Exp;
branches;
next	1.497;

1.497
date	2009.04.29.22.43.46;	author deraadt;	state Exp;
branches;
next	1.496;

1.496
date	2009.04.29.20.30.53;	author deraadt;	state Exp;
branches;
next	1.495;

1.495
date	2009.04.29.18.10.54;	author deraadt;	state Exp;
branches;
next	1.494;

1.494
date	2009.04.29.17.26.07;	author deraadt;	state Exp;
branches;
next	1.493;

1.493
date	2009.04.28.21.40.12;	author deraadt;	state Exp;
branches;
next	1.492;

1.492
date	2009.04.28.19.55.26;	author sthen;	state Exp;
branches;
next	1.491;

1.491
date	2009.04.28.16.46.10;	author deraadt;	state Exp;
branches;
next	1.490;

1.490
date	2009.04.27.18.05.33;	author sthen;	state Exp;
branches;
next	1.489;

1.489
date	2009.04.26.21.21.12;	author deraadt;	state Exp;
branches;
next	1.488;

1.488
date	2009.04.26.21.20.27;	author deraadt;	state Exp;
branches;
next	1.487;

1.487
date	2009.04.26.03.01.39;	author deraadt;	state Exp;
branches;
next	1.486;

1.486
date	2009.04.26.03.00.32;	author deraadt;	state Exp;
branches;
next	1.485;

1.485
date	2009.04.25.20.56.39;	author miod;	state Exp;
branches;
next	1.484;

1.484
date	2009.04.25.19.25.29;	author krw;	state Exp;
branches;
next	1.483;

1.483
date	2009.04.25.16.28.40;	author krw;	state Exp;
branches;
next	1.482;

1.482
date	2009.04.25.05.47.26;	author deraadt;	state Exp;
branches;
next	1.481;

1.481
date	2009.04.25.05.46.44;	author deraadt;	state Exp;
branches;
next	1.480;

1.480
date	2009.04.25.03.53.54;	author deraadt;	state Exp;
branches;
next	1.479;

1.479
date	2009.04.25.03.51.48;	author deraadt;	state Exp;
branches;
next	1.478;

1.478
date	2009.04.25.03.50.46;	author deraadt;	state Exp;
branches;
next	1.477;

1.477
date	2009.04.25.03.21.51;	author deraadt;	state Exp;
branches;
next	1.476;

1.476
date	2009.04.25.02.36.32;	author deraadt;	state Exp;
branches;
next	1.475;

1.475
date	2009.04.24.10.26.59;	author deraadt;	state Exp;
branches;
next	1.474;

1.474
date	2009.04.24.01.14.01;	author krw;	state Exp;
branches;
next	1.473;

1.473
date	2009.04.24.01.04.33;	author krw;	state Exp;
branches;
next	1.472;

1.472
date	2009.04.24.00.15.21;	author sthen;	state Exp;
branches;
next	1.471;

1.471
date	2009.04.23.23.15.08;	author deraadt;	state Exp;
branches;
next	1.470;

1.470
date	2009.04.23.21.44.27;	author deraadt;	state Exp;
branches;
next	1.469;

1.469
date	2009.04.23.21.02.15;	author deraadt;	state Exp;
branches;
next	1.468;

1.468
date	2009.04.23.20.23.35;	author deraadt;	state Exp;
branches;
next	1.467;

1.467
date	2009.04.23.18.26.14;	author deraadt;	state Exp;
branches;
next	1.466;

1.466
date	2009.04.19.21.42.00;	author krw;	state Exp;
branches;
next	1.465;

1.465
date	2009.04.19.17.56.01;	author deraadt;	state Exp;
branches;
next	1.464;

1.464
date	2009.04.19.00.59.39;	author deraadt;	state Exp;
branches;
next	1.463;

1.463
date	2009.04.19.00.00.35;	author krw;	state Exp;
branches;
next	1.462;

1.462
date	2009.04.18.15.12.39;	author deraadt;	state Exp;
branches;
next	1.461;

1.461
date	2009.04.18.01.07.48;	author deraadt;	state Exp;
branches;
next	1.460;

1.460
date	2009.04.18.00.42.28;	author deraadt;	state Exp;
branches;
next	1.459;

1.459
date	2009.04.18.00.38.50;	author krw;	state Exp;
branches;
next	1.458;

1.458
date	2009.04.18.00.23.03;	author deraadt;	state Exp;
branches;
next	1.457;

1.457
date	2009.04.18.00.21.01;	author deraadt;	state Exp;
branches;
next	1.456;

1.456
date	2009.04.17.16.05.47;	author deraadt;	state Exp;
branches;
next	1.455;

1.455
date	2009.04.17.07.00.44;	author deraadt;	state Exp;
branches;
next	1.454;

1.454
date	2009.04.17.03.58.54;	author deraadt;	state Exp;
branches;
next	1.453;

1.453
date	2009.04.13.02.04.11;	author deraadt;	state Exp;
branches;
next	1.452;

1.452
date	2009.04.13.01.59.19;	author deraadt;	state Exp;
branches;
next	1.451;

1.451
date	2009.04.13.01.48.05;	author deraadt;	state Exp;
branches;
next	1.450;

1.450
date	2009.03.14.15.55.39;	author krw;	state Exp;
branches;
next	1.449;

1.449
date	2009.03.14.14.23.05;	author krw;	state Exp;
branches;
next	1.448;

1.448
date	2009.03.13.01.20.44;	author krw;	state Exp;
branches;
next	1.447;

1.447
date	2009.02.19.02.11.32;	author krw;	state Exp;
branches;
next	1.446;

1.446
date	2009.02.19.01.25.22;	author krw;	state Exp;
branches;
next	1.445;

1.445
date	2009.02.18.00.03.06;	author krw;	state Exp;
branches;
next	1.444;

1.444
date	2009.02.14.04.00.07;	author krw;	state Exp;
branches;
next	1.443;

1.443
date	2009.02.08.21.02.20;	author miod;	state Exp;
branches;
next	1.442;

1.442
date	2009.01.25.21.27.27;	author krw;	state Exp;
branches;
next	1.441;

1.441
date	2008.11.23.01.57.06;	author krw;	state Exp;
branches;
next	1.440;

1.440
date	2008.11.11.23.36.13;	author krw;	state Exp;
branches;
next	1.439;

1.439
date	2008.11.11.00.55.21;	author krw;	state Exp;
branches;
next	1.438;

1.438
date	2008.09.30.00.47.47;	author deraadt;	state Exp;
branches;
next	1.437;

1.437
date	2008.09.07.14.09.37;	author krw;	state Exp;
branches;
next	1.436;

1.436
date	2008.07.07.15.53.15;	author jdixon;	state Exp;
branches;
next	1.435;

1.435
date	2008.07.06.14.31.19;	author krw;	state Exp;
branches;
next	1.434;

1.434
date	2008.07.02.00.13.32;	author deraadt;	state Exp;
branches;
next	1.433;

1.433
date	2008.06.26.05.42.03;	author ray;	state Exp;
branches;
next	1.432;

1.432
date	2008.06.24.11.59.48;	author tobias;	state Exp;
branches;
next	1.431;

1.431
date	2008.06.13.04.41.44;	author krw;	state Exp;
branches;
next	1.430;

1.430
date	2008.04.17.01.51.44;	author deraadt;	state Exp;
branches;
next	1.429;

1.429
date	2008.03.15.05.28.31;	author jsing;	state Exp;
branches;
next	1.428;

1.428
date	2008.03.09.02.00.42;	author krw;	state Exp;
branches;
next	1.427;

1.427
date	2008.03.09.00.42.08;	author krw;	state Exp;
branches;
next	1.426;

1.426
date	2008.03.05.01.09.58;	author krw;	state Exp;
branches;
next	1.425;

1.425
date	2008.03.04.00.36.38;	author krw;	state Exp;
branches;
next	1.424;

1.424
date	2008.02.20.17.46.50;	author miod;	state Exp;
branches;
next	1.423;

1.423
date	2008.02.11.23.40.03;	author krw;	state Exp;
branches;
next	1.422;

1.422
date	2007.12.14.08.30.11;	author otto;	state Exp;
branches;
next	1.421;

1.421
date	2007.08.02.03.23.37;	author david;	state Exp;
branches;
next	1.420;

1.420
date	2007.07.27.01.34.32;	author deraadt;	state Exp;
branches;
next	1.419;

1.419
date	2007.05.28.02.57.11;	author krw;	state Exp;
branches;
next	1.418;

1.418
date	2007.04.27.02.41.41;	author deraadt;	state Exp;
branches;
next	1.417;

1.417
date	2007.04.25.11.59.49;	author krw;	state Exp;
branches;
next	1.416;

1.416
date	2007.04.25.11.52.14;	author krw;	state Exp;
branches;
next	1.415;

1.415
date	2007.03.26.20.13.24;	author otto;	state Exp;
branches;
next	1.414;

1.414
date	2007.03.26.12.09.13;	author krw;	state Exp;
branches;
next	1.413;

1.413
date	2007.03.16.22.33.39;	author krw;	state Exp;
branches;
next	1.412;

1.412
date	2007.03.13.00.14.21;	author krw;	state Exp;
branches;
next	1.411;

1.411
date	2007.03.04.14.37.37;	author krw;	state Exp;
branches;
next	1.410;

1.410
date	2007.03.01.03.51.56;	author deraadt;	state Exp;
branches;
next	1.409;

1.409
date	2007.02.14.23.37.18;	author krw;	state Exp;
branches;
next	1.408;

1.408
date	2007.02.12.13.10.02;	author henning;	state Exp;
branches;
next	1.407;

1.407
date	2007.02.11.18.59.31;	author krw;	state Exp;
branches;
next	1.406;

1.406
date	2006.08.29.01.02.49;	author krw;	state Exp;
branches;
next	1.405;

1.405
date	2006.07.26.20.34.11;	author deraadt;	state Exp;
branches;
next	1.404;

1.404
date	2006.05.18.11.56.09;	author krw;	state Exp;
branches;
next	1.403;

1.403
date	2006.03.15.01.17.12;	author krw;	state Exp;
branches;
next	1.402;

1.402
date	2006.03.11.19.23.31;	author krw;	state Exp;
branches;
next	1.401;

1.401
date	2006.02.28.20.33.55;	author matthieu;	state Exp;
branches;
next	1.400;

1.400
date	2006.01.19.03.30.04;	author deraadt;	state Exp;
branches;
next	1.399;

1.399
date	2005.11.22.19.29.15;	author krw;	state Exp;
branches;
next	1.398;

1.398
date	2005.10.28.13.30.50;	author jmc;	state Exp;
branches;
next	1.397;

1.397
date	2005.10.26.00.06.51;	author krw;	state Exp;
branches;
next	1.396;

1.396
date	2005.10.20.02.31.52;	author krw;	state Exp;
branches;
next	1.395;

1.395
date	2005.10.16.05.01.59;	author krw;	state Exp;
branches;
next	1.394;

1.394
date	2005.10.16.03.06.12;	author krw;	state Exp;
branches;
next	1.393;

1.393
date	2005.10.12.02.48.49;	author krw;	state Exp;
branches;
next	1.392;

1.392
date	2005.10.10.19.23.06;	author krw;	state Exp;
branches;
next	1.391;

1.391
date	2005.10.05.02.07.27;	author krw;	state Exp;
branches;
next	1.390;

1.390
date	2005.08.29.17.47.55;	author krw;	state Exp;
branches;
next	1.389;

1.389
date	2005.08.09.00.46.12;	author deraadt;	state Exp;
branches;
next	1.388;

1.388
date	2005.07.02.00.55.48;	author uwe;	state Exp;
branches;
next	1.387;

1.387
date	2005.06.13.23.42.38;	author krw;	state Exp;
branches;
next	1.386;

1.386
date	2005.05.24.22.38.41;	author krw;	state Exp;
branches;
next	1.385;

1.385
date	2005.04.30.14.09.41;	author krw;	state Exp;
branches;
next	1.384;

1.384
date	2005.04.19.00.49.20;	author krw;	state Exp;
branches;
next	1.383;

1.383
date	2005.04.18.23.56.21;	author deraadt;	state Exp;
branches;
next	1.382;

1.382
date	2005.04.15.23.45.29;	author krw;	state Exp;
branches;
next	1.381;

1.381
date	2005.04.13.03.45.51;	author krw;	state Exp;
branches;
next	1.380;

1.380
date	2005.04.13.03.12.42;	author deraadt;	state Exp;
branches;
next	1.379;

1.379
date	2005.04.13.02.52.52;	author krw;	state Exp;
branches;
next	1.378;

1.378
date	2005.04.13.02.18.10;	author krw;	state Exp;
branches;
next	1.377;

1.377
date	2005.04.13.02.03.38;	author krw;	state Exp;
branches;
next	1.376;

1.376
date	2005.04.09.23.47.34;	author deraadt;	state Exp;
branches;
next	1.375;

1.375
date	2005.04.09.15.21.28;	author krw;	state Exp;
branches;
next	1.374;

1.374
date	2005.04.09.00.47.58;	author krw;	state Exp;
branches;
next	1.373;

1.373
date	2005.04.07.20.47.15;	author krw;	state Exp;
branches;
next	1.372;

1.372
date	2005.04.05.01.00.46;	author krw;	state Exp;
branches;
next	1.371;

1.371
date	2005.04.03.19.33.59;	author krw;	state Exp;
branches;
next	1.370;

1.370
date	2005.04.02.14.27.08;	author krw;	state Exp;
branches;
next	1.369;

1.369
date	2005.04.02.13.02.52;	author krw;	state Exp;
branches;
next	1.368;

1.368
date	2005.03.27.15.13.50;	author krw;	state Exp;
branches;
next	1.367;

1.367
date	2005.03.26.15.40.21;	author krw;	state Exp;
branches;
next	1.366;

1.366
date	2005.03.26.05.08.26;	author krw;	state Exp;
branches;
next	1.365;

1.365
date	2005.03.26.03.54.40;	author krw;	state Exp;
branches;
next	1.364;

1.364
date	2005.03.26.01.40.21;	author krw;	state Exp;
branches;
next	1.363;

1.363
date	2005.03.14.02.29.33;	author krw;	state Exp;
branches;
next	1.362;

1.362
date	2005.03.08.17.56.00;	author deraadt;	state Exp;
branches;
next	1.361;

1.361
date	2005.03.08.13.13.54;	author deraadt;	state Exp;
branches;
next	1.360;

1.360
date	2005.03.07.00.05.59;	author deraadt;	state Exp;
branches;
next	1.359;

1.359
date	2005.02.16.02.04.31;	author krw;	state Exp;
branches;
next	1.358;

1.358
date	2005.02.13.06.57.59;	author david;	state Exp;
branches;
next	1.357;

1.357
date	2004.11.28.04.15.09;	author krw;	state Exp;
branches;
next	1.356;

1.356
date	2004.11.11.21.48.06;	author deraadt;	state Exp;
branches;
next	1.355;

1.355
date	2004.10.12.21.57.07;	author krw;	state Exp;
branches;
next	1.354;

1.354
date	2004.10.02.18.45.08;	author krw;	state Exp;
branches;
next	1.353;

1.353
date	2004.09.29.00.05.14;	author krw;	state Exp;
branches;
next	1.352;

1.352
date	2004.09.16.22.23.44;	author mcbride;	state Exp;
branches;
next	1.351;

1.351
date	2004.08.09.18.08.50;	author deraadt;	state Exp;
branches;
next	1.350;

1.350
date	2004.07.25.03.33.04;	author krw;	state Exp;
branches;
next	1.349;

1.349
date	2004.07.18.03.26.21;	author krw;	state Exp;
branches;
next	1.348;

1.348
date	2004.07.18.01.12.32;	author deraadt;	state Exp;
branches;
next	1.347;

1.347
date	2004.07.18.00.46.14;	author krw;	state Exp;
branches;
next	1.346;

1.346
date	2004.07.17.03.46.12;	author krw;	state Exp;
branches;
next	1.345;

1.345
date	2004.07.17.03.26.07;	author krw;	state Exp;
branches;
next	1.344;

1.344
date	2004.07.17.02.13.53;	author krw;	state Exp;
branches;
next	1.343;

1.343
date	2004.06.26.20.10.17;	author krw;	state Exp;
branches;
next	1.342;

1.342
date	2004.06.22.20.43.58;	author krw;	state Exp;
branches;
next	1.341;

1.341
date	2004.06.22.00.42.11;	author matthieu;	state Exp;
branches;
next	1.340;

1.340
date	2004.06.20.05.13.14;	author krw;	state Exp;
branches;
next	1.339;

1.339
date	2004.06.13.22.00.50;	author deraadt;	state Exp;
branches;
next	1.338;

1.338
date	2004.04.12.22.55.11;	author krw;	state Exp;
branches;
next	1.337;

1.337
date	2004.03.23.02.39.39;	author krw;	state Exp;
branches;
next	1.336;

1.336
date	2004.03.18.00.25.12;	author krw;	state Exp;
branches;
next	1.335;

1.335
date	2004.03.16.01.11.57;	author deraadt;	state Exp;
branches;
next	1.334;

1.334
date	2004.03.14.20.55.02;	author krw;	state Exp;
branches;
next	1.333;

1.333
date	2004.03.09.03.58.34;	author krw;	state Exp;
branches;
next	1.332;

1.332
date	2004.02.28.20.24.14;	author krw;	state Exp;
branches;
next	1.331;

1.331
date	2004.02.27.18.02.46;	author deraadt;	state Exp;
branches;
next	1.330;

1.330
date	2004.02.08.20.38.02;	author krw;	state Exp;
branches;
next	1.329;

1.329
date	2004.02.08.17.42.28;	author krw;	state Exp;
branches;
next	1.328;

1.328
date	2004.02.08.11.31.43;	author krw;	state Exp;
branches;
next	1.327;

1.327
date	2004.02.08.01.01.10;	author krw;	state Exp;
branches;
next	1.326;

1.326
date	2004.02.07.17.45.04;	author krw;	state Exp;
branches;
next	1.325;

1.325
date	2004.01.11.18.57.02;	author krw;	state Exp;
branches;
next	1.324;

1.324
date	2003.12.21.21.45.41;	author krw;	state Exp;
branches;
next	1.323;

1.323
date	2003.12.04.20.17.02;	author deraadt;	state Exp;
branches;
next	1.322;

1.322
date	2003.12.04.18.43.38;	author deraadt;	state Exp;
branches;
next	1.321;

1.321
date	2003.09.22.01.31.39;	author krw;	state Exp;
branches;
next	1.320;

1.320
date	2003.08.23.22.22.02;	author krw;	state Exp;
branches;
next	1.319;

1.319
date	2003.08.17.18.51.54;	author krw;	state Exp;
branches;
next	1.318;

1.318
date	2003.08.17.18.18.50;	author krw;	state Exp;
branches;
next	1.317;

1.317
date	2003.08.16.20.37.24;	author krw;	state Exp;
branches;
next	1.316;

1.316
date	2003.08.11.14.52.42;	author deraadt;	state Exp;
branches;
next	1.315;

1.315
date	2003.08.07.19.13.00;	author deraadt;	state Exp;
branches;
next	1.314;

1.314
date	2003.07.10.15.03.19;	author krw;	state Exp;
branches;
next	1.313;

1.313
date	2003.07.10.14.12.54;	author krw;	state Exp;
branches;
next	1.312;

1.312
date	2003.07.03.15.19.01;	author krw;	state Exp;
branches;
next	1.311;

1.311
date	2003.07.03.13.42.03;	author krw;	state Exp;
branches;
next	1.310;

1.310
date	2003.07.02.16.42.19;	author krw;	state Exp;
branches;
next	1.309;

1.309
date	2003.06.30.17.49.14;	author krw;	state Exp;
branches;
next	1.308;

1.308
date	2003.06.30.14.25.53;	author krw;	state Exp;
branches;
next	1.307;

1.307
date	2003.06.27.22.40.40;	author krw;	state Exp;
branches;
next	1.306;

1.306
date	2003.06.23.00.38.57;	author krw;	state Exp;
branches;
next	1.305;

1.305
date	2003.06.21.23.02.32;	author krw;	state Exp;
branches;
next	1.304;

1.304
date	2003.06.02.15.46.09;	author deraadt;	state Exp;
branches;
next	1.303;

1.303
date	2003.05.12.19.01.58;	author krw;	state Exp;
branches;
next	1.302;

1.302
date	2003.05.12.18.16.15;	author krw;	state Exp;
branches;
next	1.301;

1.301
date	2003.05.11.22.07.42;	author krw;	state Exp;
branches;
next	1.300;

1.300
date	2003.05.11.20.05.56;	author krw;	state Exp;
branches;
next	1.299;

1.299
date	2003.05.11.17.27.15;	author krw;	state Exp;
branches;
next	1.298;

1.298
date	2003.05.07.00.43.06;	author krw;	state Exp;
branches;
next	1.297;

1.297
date	2003.04.30.23.56.30;	author krw;	state Exp;
branches;
next	1.296;

1.296
date	2003.04.23.12.06.55;	author wilfried;	state Exp;
branches;
next	1.295;

1.295
date	2003.04.17.19.15.49;	author deraadt;	state Exp;
branches;
next	1.294;

1.294
date	2003.04.16.23.47.01;	author krw;	state Exp;
branches;
next	1.293;

1.293
date	2003.03.06.04.19.45;	author david;	state Exp;
branches;
next	1.292;

1.292
date	2003.03.06.00.27.41;	author krw;	state Exp;
branches;
next	1.291;

1.291
date	2003.03.02.00.17.20;	author krw;	state Exp;
branches;
next	1.290;

1.290
date	2003.02.16.23.25.40;	author krw;	state Exp;
branches;
next	1.289;

1.289
date	2003.02.15.20.36.18;	author krw;	state Exp;
branches;
next	1.288;

1.288
date	2003.02.12.23.07.28;	author deraadt;	state Exp;
branches;
next	1.287;

1.287
date	2003.01.26.15.53.13;	author krw;	state Exp;
branches;
next	1.286;

1.286
date	2003.01.25.15.46.52;	author krw;	state Exp;
branches;
next	1.285;

1.285
date	2002.12.14.15.33.35;	author krw;	state Exp;
branches;
next	1.284;

1.284
date	2002.12.08.20.24.56;	author krw;	state Exp;
branches;
next	1.283;

1.283
date	2002.12.08.19.30.40;	author krw;	state Exp;
branches;
next	1.282;

1.282
date	2002.12.04.03.39.07;	author krw;	state Exp;
branches;
next	1.281;

1.281
date	2002.12.03.00.58.35;	author krw;	state Exp;
branches;
next	1.280;

1.280
date	2002.12.01.23.19.33;	author krw;	state Exp;
branches;
next	1.279;

1.279
date	2002.12.01.16.51.14;	author krw;	state Exp;
branches;
next	1.278;

1.278
date	2002.11.29.00.24.58;	author krw;	state Exp;
branches;
next	1.277;

1.277
date	2002.11.28.03.06.30;	author deraadt;	state Exp;
branches;
next	1.276;

1.276
date	2002.11.28.01.54.58;	author krw;	state Exp;
branches;
next	1.275;

1.275
date	2002.11.28.01.11.05;	author krw;	state Exp;
branches;
next	1.274;

1.274
date	2002.11.28.00.44.56;	author krw;	state Exp;
branches;
next	1.273;

1.273
date	2002.11.10.01.08.33;	author krw;	state Exp;
branches;
next	1.272;

1.272
date	2002.11.09.06.16.06;	author krw;	state Exp;
branches;
next	1.271;

1.271
date	2002.11.09.04.41.56;	author krw;	state Exp;
branches;
next	1.270;

1.270
date	2002.11.07.01.28.52;	author krw;	state Exp;
branches;
next	1.269;

1.269
date	2002.11.01.01.08.15;	author krw;	state Exp;
branches;
next	1.268;

1.268
date	2002.10.31.00.30.31;	author krw;	state Exp;
branches;
next	1.267;

1.267
date	2002.10.28.00.36.04;	author krw;	state Exp;
branches;
next	1.266;

1.266
date	2002.10.27.14.05.21;	author krw;	state Exp;
branches;
next	1.265;

1.265
date	2002.10.04.01.22.39;	author deraadt;	state Exp;
branches;
next	1.264;

1.264
date	2002.10.03.00.56.44;	author krw;	state Exp;
branches;
next	1.263;

1.263
date	2002.09.30.07.07.55;	author deraadt;	state Exp;
branches;
next	1.262;

1.262
date	2002.09.29.22.52.21;	author krw;	state Exp;
branches;
next	1.261;

1.261
date	2002.09.29.22.45.44;	author krw;	state Exp;
branches;
next	1.260;

1.260
date	2002.09.28.23.35.12;	author krw;	state Exp;
branches;
next	1.259;

1.259
date	2002.09.24.01.26.15;	author krw;	state Exp;
branches;
next	1.258;

1.258
date	2002.09.22.22.42.25;	author krw;	state Exp;
branches;
next	1.257;

1.257
date	2002.09.20.00.15.00;	author millert;	state Exp;
branches;
next	1.256;

1.256
date	2002.09.17.16.15.25;	author krw;	state Exp;
branches;
next	1.255;

1.255
date	2002.09.17.12.28.54;	author krw;	state Exp;
branches;
next	1.254;

1.254
date	2002.09.10.21.36.56;	author deraadt;	state Exp;
branches;
next	1.253;

1.253
date	2002.08.27.02.27.07;	author krw;	state Exp;
branches;
next	1.252;

1.252
date	2002.08.15.22.56.03;	author krw;	state Exp;
branches;
next	1.251;

1.251
date	2002.07.28.01.14.58;	author krw;	state Exp;
branches;
next	1.250;

1.250
date	2002.07.27.04.05.08;	author krw;	state Exp;
branches;
next	1.249;

1.249
date	2002.07.22.00.13.01;	author krw;	state Exp;
branches;
next	1.248;

1.248
date	2002.07.18.00.36.44;	author krw;	state Exp;
branches;
next	1.247;

1.247
date	2002.07.13.16.32.13;	author krw;	state Exp;
branches;
next	1.246;

1.246
date	2002.07.13.13.18.05;	author krw;	state Exp;
branches;
next	1.245;

1.245
date	2002.07.12.01.25.44;	author krw;	state Exp;
branches;
next	1.244;

1.244
date	2002.07.12.00.07.33;	author krw;	state Exp;
branches;
next	1.243;

1.243
date	2002.07.09.23.19.10;	author krw;	state Exp;
branches;
next	1.242;

1.242
date	2002.07.07.02.34.00;	author krw;	state Exp;
branches;
next	1.241;

1.241
date	2002.07.06.16.18.13;	author krw;	state Exp;
branches;
next	1.240;

1.240
date	2002.07.04.23.36.35;	author krw;	state Exp;
branches;
next	1.239;

1.239
date	2002.07.04.21.51.16;	author krw;	state Exp;
branches;
next	1.238;

1.238
date	2002.07.04.17.23.42;	author krw;	state Exp;
branches;
next	1.237;

1.237
date	2002.07.04.16.01.21;	author krw;	state Exp;
branches;
next	1.236;

1.236
date	2002.06.29.20.01.34;	author krw;	state Exp;
branches;
next	1.235;

1.235
date	2002.06.25.00.31.59;	author krw;	state Exp;
branches;
next	1.234;

1.234
date	2002.06.15.16.03.40;	author fgsch;	state Exp;
branches;
next	1.233;

1.233
date	2002.06.11.04.25.49;	author krw;	state Exp;
branches;
next	1.232;

1.232
date	2002.06.11.03.12.22;	author krw;	state Exp;
branches;
next	1.231;

1.231
date	2002.06.10.23.03.32;	author krw;	state Exp;
branches;
next	1.230;

1.230
date	2002.06.10.22.38.12;	author krw;	state Exp;
branches;
next	1.229;

1.229
date	2002.06.10.21.09.51;	author krw;	state Exp;
branches;
next	1.228;

1.228
date	2002.06.10.19.50.16;	author krw;	state Exp;
branches;
next	1.227;

1.227
date	2002.06.09.05.53.54;	author todd;	state Exp;
branches;
next	1.226;

1.226
date	2002.06.08.21.52.02;	author krw;	state Exp;
branches;
next	1.225;

1.225
date	2002.05.22.01.48.38;	author krw;	state Exp;
branches;
next	1.224;

1.224
date	2002.05.20.16.53.57;	author krw;	state Exp;
branches;
next	1.223;

1.223
date	2002.05.20.02.45.08;	author krw;	state Exp;
branches;
next	1.222;

1.222
date	2002.05.18.17.56.03;	author krw;	state Exp;
branches;
next	1.221;

1.221
date	2002.05.14.01.49.25;	author krw;	state Exp;
branches;
next	1.220;

1.220
date	2002.05.09.21.54.46;	author krw;	state Exp;
branches;
next	1.219;

1.219
date	2002.05.08.23.01.46;	author krw;	state Exp;
branches;
next	1.218;

1.218
date	2002.05.04.22.21.21;	author krw;	state Exp;
branches;
next	1.217;

1.217
date	2002.04.30.23.26.27;	author krw;	state Exp;
branches;
next	1.216;

1.216
date	2002.04.30.04.04.47;	author deraadt;	state Exp;
branches;
next	1.215;

1.215
date	2002.04.29.01.49.49;	author krw;	state Exp;
branches;
next	1.214;

1.214
date	2002.04.29.01.38.06;	author krw;	state Exp;
branches;
next	1.213;

1.213
date	2002.04.29.00.59.35;	author krw;	state Exp;
branches;
next	1.212;

1.212
date	2002.04.28.20.41.15;	author krw;	state Exp;
branches;
next	1.211;

1.211
date	2002.04.28.14.44.01;	author krw;	state Exp;
branches;
next	1.210;

1.210
date	2002.04.27.19.12.57;	author krw;	state Exp;
branches;
next	1.209;

1.209
date	2002.04.26.02.43.14;	author krw;	state Exp;
branches;
next	1.208;

1.208
date	2002.04.26.02.26.15;	author krw;	state Exp;
branches;
next	1.207;

1.207
date	2002.04.26.02.14.23;	author krw;	state Exp;
branches;
next	1.206;

1.206
date	2002.04.20.13.42.52;	author krw;	state Exp;
branches;
next	1.205;

1.205
date	2002.04.13.21.03.58;	author deraadt;	state Exp;
branches;
next	1.204;

1.204
date	2002.04.13.21.03.31;	author deraadt;	state Exp;
branches;
next	1.203;

1.203
date	2002.04.13.00.46.46;	author deraadt;	state Exp;
branches;
next	1.202;

1.202
date	2002.04.10.19.29.15;	author deraadt;	state Exp;
branches;
next	1.201;

1.201
date	2002.04.09.01.59.41;	author krw;	state Exp;
branches;
next	1.200;

1.200
date	2002.04.09.01.01.19;	author krw;	state Exp;
branches;
next	1.199;

1.199
date	2002.04.05.23.44.54;	author krw;	state Exp;
branches;
next	1.198;

1.198
date	2002.04.05.02.51.59;	author krw;	state Exp;
branches;
next	1.197;

1.197
date	2002.04.02.01.25.34;	author krw;	state Exp;
branches;
next	1.196;

1.196
date	2002.03.31.15.30.42;	author krw;	state Exp;
branches;
next	1.195;

1.195
date	2002.03.31.03.05.04;	author krw;	state Exp;
branches;
next	1.194;

1.194
date	2002.03.30.13.34.51;	author krw;	state Exp;
branches;
next	1.193;

1.193
date	2002.03.30.01.29.18;	author deraadt;	state Exp;
branches;
next	1.192;

1.192
date	2002.03.30.00.56.10;	author deraadt;	state Exp;
branches;
next	1.191;

1.191
date	2002.03.30.00.55.32;	author deraadt;	state Exp;
branches;
next	1.190;

1.190
date	2002.03.30.00.50.57;	author krw;	state Exp;
branches;
next	1.189;

1.189
date	2002.03.26.01.50.08;	author krw;	state Exp;
branches;
next	1.188;

1.188
date	2002.03.22.23.29.28;	author deraadt;	state Exp;
branches;
next	1.187;

1.187
date	2002.03.22.01.41.54;	author krw;	state Exp;
branches;
next	1.186;

1.186
date	2002.03.04.13.59.52;	author krw;	state Exp;
branches;
next	1.185;

1.185
date	2002.03.04.13.54.28;	author krw;	state Exp;
branches;
next	1.184;

1.184
date	2002.03.03.00.43.37;	author krw;	state Exp;
branches;
next	1.183;

1.183
date	2002.01.24.23.01.18;	author millert;	state Exp;
branches;
next	1.182;

1.182
date	2001.12.23.16.54.04;	author krw;	state Exp;
branches;
next	1.181;

1.181
date	2001.12.22.18.53.45;	author krw;	state Exp;
branches;
next	1.180;

1.180
date	2001.12.17.00.41.50;	author krw;	state Exp;
branches;
next	1.179;

1.179
date	2001.12.13.01.40.15;	author krw;	state Exp;
branches;
next	1.178;

1.178
date	2001.11.25.21.43.08;	author krw;	state Exp;
branches;
next	1.177;

1.177
date	2001.11.24.14.27.42;	author krw;	state Exp;
branches;
next	1.176;

1.176
date	2001.11.22.00.56.13;	author krw;	state Exp;
branches;
next	1.175;

1.175
date	2001.11.20.01.02.49;	author krw;	state Exp;
branches;
next	1.174;

1.174
date	2001.11.19.01.09.43;	author deraadt;	state Exp;
branches;
next	1.173;

1.173
date	2001.11.18.22.48.58;	author krw;	state Exp;
branches;
next	1.172;

1.172
date	2001.11.17.20.23.23;	author krw;	state Exp;
branches;
next	1.171;

1.171
date	2001.10.31.01.33.24;	author krw;	state Exp;
branches;
next	1.170;

1.170
date	2001.10.15.22.58.59;	author krw;	state Exp;
branches;
next	1.169;

1.169
date	2001.09.19.00.04.02;	author krw;	state Exp;
branches;
next	1.168;

1.168
date	2001.09.11.13.11.18;	author deraadt;	state Exp;
branches;
next	1.167;

1.167
date	2001.08.07.15.00.09;	author markus;	state Exp;
branches;
next	1.166;

1.166
date	2001.04.20.01.55.51;	author krw;	state Exp;
branches;
next	1.165;

1.165
date	2001.04.16.19.43.28;	author krw;	state Exp;
branches;
next	1.164;

1.164
date	2001.04.15.02.35.08;	author deraadt;	state Exp;
branches;
next	1.163;

1.163
date	2001.02.23.17.53.10;	author marc;	state Exp;
branches;
next	1.162;

1.162
date	2001.02.23.17.51.09;	author marc;	state Exp;
branches;
next	1.161;

1.161
date	2001.02.12.09.54.09;	author deraadt;	state Exp;
branches;
next	1.160;

1.160
date	2000.12.10.02.40.39;	author deraadt;	state Exp;
branches;
next	1.159;

1.159
date	2000.11.20.13.11.16;	author deraadt;	state Exp;
branches;
next	1.158;

1.158
date	2000.10.09.22.47.22;	author naddy;	state Exp;
branches;
next	1.157;

1.157
date	2000.09.13.05.11.35;	author rahnds;	state Exp;
branches;
next	1.156;

1.156
date	2000.08.21.21.13.40;	author deraadt;	state Exp;
branches;
next	1.155;

1.155
date	2000.06.23.18.53.24;	author mickey;	state Exp;
branches;
next	1.154;

1.154
date	2000.06.16.03.19.42;	author deraadt;	state Exp;
branches;
next	1.153;

1.153
date	2000.05.08.21.28.03;	author millert;	state Exp;
branches;
next	1.152;

1.152
date	2000.05.07.17.08.26;	author millert;	state Exp;
branches;
next	1.151;

1.151
date	2000.04.27.16.11.05;	author deraadt;	state Exp;
branches;
next	1.150;

1.150
date	2000.04.08.05.06.25;	author deraadt;	state Exp;
branches;
next	1.149;

1.149
date	2000.03.19.01.14.03;	author espie;	state Exp;
branches;
next	1.148;

1.148
date	2000.02.25.01.39.13;	author krw;	state Exp;
branches;
next	1.147;

1.147
date	99.11.11.02.36.02;	author millert;	state Exp;
branches;
next	1.146;

1.146
date	99.10.26.22.56.54;	author deraadt;	state Exp;
branches;
next	1.145;

1.145
date	99.10.18.05.25.26;	author deraadt;	state Exp;
branches;
next	1.144;

1.144
date	99.10.17.16.57.26;	author deraadt;	state Exp;
branches;
next	1.143;

1.143
date	99.10.17.16.45.14;	author deraadt;	state Exp;
branches;
next	1.142;

1.142
date	99.10.17.15.35.51;	author deraadt;	state Exp;
branches;
next	1.141;

1.141
date	99.10.17.06.53.40;	author deraadt;	state Exp;
branches;
next	1.140;

1.140
date	99.10.16.19.01.22;	author deraadt;	state Exp;
branches;
next	1.139;

1.139
date	99.10.16.17.37.36;	author deraadt;	state Exp;
branches;
next	1.138;

1.138
date	99.10.15.16.55.00;	author millert;	state Exp;
branches;
next	1.137;

1.137
date	99.10.14.17.29.04;	author deraadt;	state Exp;
branches;
next	1.136;

1.136
date	99.10.14.17.17.46;	author millert;	state Exp;
branches;
next	1.135;

1.135
date	99.10.07.21.35.47;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	99.10.02.18.53.24;	author deraadt;	state Exp;
branches;
next	1.133;

1.133
date	99.10.02.13.32.43;	author aaron;	state Exp;
branches;
next	1.132;

1.132
date	99.09.23.21.33.43;	author aaron;	state Exp;
branches;
next	1.131;

1.131
date	99.09.23.19.02.20;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	99.09.23.18.59.02;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	99.09.23.18.58.19;	author deraadt;	state Exp;
branches;
next	1.128;

1.128
date	99.09.23.18.57.39;	author deraadt;	state Exp;
branches;
next	1.127;

1.127
date	99.08.15.09.53.36;	author millert;	state Exp;
branches;
next	1.126;

1.126
date	99.08.10.23.07.24;	author deraadt;	state Exp;
branches;
next	1.125;

1.125
date	99.07.30.00.31.27;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	99.07.24.22.46.32;	author deraadt;	state Exp;
branches;
next	1.123;

1.123
date	99.05.30.08.34.51;	author deraadt;	state Exp;
branches;
next	1.122;

1.122
date	99.04.10.04.39.50;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	99.04.07.08.47.34;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	99.04.05.00.26.49;	author millert;	state Exp;
branches;
next	1.119;

1.119
date	99.04.02.17.50.01;	author millert;	state Exp;
branches;
next	1.118;

1.118
date	99.04.02.05.51.16;	author millert;	state Exp;
branches;
next	1.117;

1.117
date	99.04.01.21.25.48;	author deraadt;	state Exp;
branches;
next	1.116;

1.116
date	99.04.01.17.41.26;	author millert;	state Exp;
branches;
next	1.115;

1.115
date	99.03.23.07.58.08;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	99.03.23.02.30.31;	author millert;	state Exp;
branches;
next	1.113;

1.113
date	98.12.19.18.31.57;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	98.11.09.03.54.52;	author millert;	state Exp;
branches;
next	1.111;

1.111
date	98.11.03.04.35.16;	author aaron;	state Exp;
branches;
next	1.110;

1.110
date	98.10.28.18.55.20;	author millert;	state Exp;
branches;
next	1.109;

1.109
date	98.10.28.17.51.14;	author millert;	state Exp;
branches;
next	1.108;

1.108
date	98.10.19.19.22.18;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	98.10.19.09.36.58;	author todd;	state Exp;
branches;
next	1.106;

1.106
date	98.10.19.05.28.07;	author deraadt;	state Exp;
branches;
next	1.105;

1.105
date	98.10.18.20.31.46;	author millert;	state Exp;
branches;
next	1.104;

1.104
date	98.10.11.02.50.47;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	98.10.10.20.54.24;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	98.10.10.08.42.29;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	98.09.30.08.02.26;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	98.09.28.13.38.39;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	98.09.28.13.28.36;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	98.09.28.12.34.06;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	98.09.24.21.55.08;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	98.09.24.06.39.07;	author millert;	state Exp;
branches;
next	1.95;

1.95
date	98.09.24.06.13.09;	author millert;	state Exp;
branches;
next	1.94;

1.94
date	98.09.23.07.22.34;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	98.09.20.08.50.16;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	98.09.19.23.02.49;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	98.09.19.23.02.16;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	98.09.19.07.05.11;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	98.09.19.07.03.24;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	98.09.18.18.40.51;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	98.09.17.23.24.32;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	98.09.17.01.25.16;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	98.09.17.00.50.01;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	98.09.17.00.44.35;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	98.09.15.21.48.27;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	98.09.14.15.16.01;	author millert;	state Exp;
branches;
next	1.81;

1.81
date	98.09.12.08.33.57;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	98.09.11.22.45.52;	author millert;	state Exp;
branches;
next	1.79;

1.79
date	98.07.09.00.02.34;	author millert;	state Exp;
branches;
next	1.78;

1.78
date	98.06.25.16.35.26;	author millert;	state Exp;
branches;
next	1.77;

1.77
date	98.06.05.01.24.15;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	98.04.28.16.25.03;	author millert;	state Exp;
branches;
next	1.75;

1.75
date	98.04.15.15.21.07;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	98.04.14.17.25.31;	author millert;	state Exp;
branches;
next	1.73;

1.73
date	98.04.13.16.12.28;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	98.04.05.23.53.17;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	98.04.03.18.56.13;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	98.04.01.20.21.49;	author millert;	state Exp;
branches;
next	1.69;

1.69
date	98.03.31.03.22.01;	author millert;	state Exp;
branches;
next	1.68;

1.68
date	98.03.30.20.56.37;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	98.03.29.20.34.02;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	98.03.29.19.54.50;	author millert;	state Exp;
branches;
next	1.65;

1.65
date	98.03.29.17.48.16;	author millert;	state Exp;
branches;
next	1.64;

1.64
date	98.03.29.01.11.32;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	98.03.28.21.40.46;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	98.03.28.21.06.53;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	98.03.26.05.17.48;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	98.03.26.03.57.43;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	98.03.26.03.49.19;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	98.03.24.06.38.56;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	98.03.23.05.33.38;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	98.03.23.05.29.21;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	98.03.12.09.42.40;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	98.03.12.08.59.45;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	98.03.12.08.13.52;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	98.03.01.19.49.03;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	98.02.17.23.19.09;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	98.01.10.02.22.57;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	97.10.29.21.38.17;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	97.10.25.05.22.19;	author deraadt;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	97.10.19.09.07.47;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	97.10.17.12.35.01;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	97.10.17.12.20.28;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	97.10.17.12.05.57;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	97.10.17.08.57.24;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	97.10.17.08.13.58;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	97.10.17.04.31.18;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	97.10.03.20.26.35;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	97.09.25.05.16.43;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	97.07.16.22.33.03;	author pefo;	state Exp;
branches;
next	1.37;

1.37
date	97.07.09.15.15.37;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	97.05.29.09.15.47;	author niklas;	state Exp;
branches;
next	1.35;

1.35
date	97.05.18.23.12.02;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	97.05.17.00.06.36;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	97.05.16.16.36.53;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	97.05.16.04.55.05;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	97.05.16.04.12.44;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	97.05.16.03.21.10;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	97.05.16.03.07.39;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	97.05.16.02.00.22;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	97.05.16.00.51.09;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	97.05.15.06.29.01;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	97.05.15.06.26.08;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	97.05.14.21.12.14;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	97.05.14.17.08.11;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	97.05.14.16.26.15;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	97.05.13.12.02.33;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	97.05.13.03.51.27;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.05.10.22.19.36;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	97.05.05.05.27.30;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.05.05.05.18.19;	author grr;	state Exp;
branches;
next	1.16;

1.16
date	97.05.05.00.35.36;	author tholo;	state Exp;
branches;
next	1.15;

1.15
date	97.05.05.00.28.45;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	97.05.04.05.08.00;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	97.05.04.04.50.22;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	97.05.04.03.25.03;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	97.05.04.03.03.14;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	97.05.03.23.06.02;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	97.05.03.07.45.10;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	97.05.02.20.56.18;	author grr;	state Exp;
branches;
next	1.7;

1.7
date	97.04.30.23.56.06;	author grr;	state Exp;
branches;
next	1.6;

1.6
date	97.04.30.20.25.36;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.04.30.18.52.45;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.09.05.21.26.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.29.05.54.16;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.03.28.21.48.19;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.07.13.22.51;	author deraadt;	state Exp;
branches;
next	;

1.48.2.1
date	97.10.29.21.49.17;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.1014
log
@After installing, chmod og-rwx {/bsd bsd.mp bsd.sp bsd.rd }
(Should we make them kmem readable?  Let's ignore that for now and see
if any issues surface).
ok tb rpe
@
text
@#!/bin/ksh
#	$OpenBSD: install.sub,v 1.1013 2017/05/31 08:02:56 tb Exp $
#
# Copyright (c) 1997-2015 Todd Miller, Theo de Raadt, Ken Westerback
# Copyright (c) 2015, Robert Peichaer <rpe@@openbsd.org>
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Copyright (c) 1996 The NetBSD Foundation, Inc.
# All rights reserved.
#
# This code is derived from software contributed to The NetBSD Foundation
# by Jason R. Thorpe.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

# OpenBSD install/upgrade script common subroutines and initialization code

# ------------------------------------------------------------------------------
# Misc functions
# ------------------------------------------------------------------------------

# Print error message to stderr and exit the script.
err_exit() {
	print -u2 -- "$*"
	exit 1
}

# Show usage of the installer script and exit.
usage() {
	err_exit "usage: ${0##*/} [-a] [-f filename] [-m install | upgrade]"
}

# Wait for the ftp process to finish, or be killed after the timeout and
# extract various informations from the ftplist.cgi output.
wait_cgiinfo() {
	local _l _s _key _val

	# Wait for the ftp(1) process started in start_cgiinfo() to end and
	# ensure, there is actual data to extract info from.
	wait "$CGIPID" 2>/dev/null
	[[ -s $CGI_INFO ]] || return

	# Extract list of mirror servers from the ftplist.cgi output.
	sed -En 's,^https?://([[A-Za-z0-9:_][]A-Za-z0-9:._-]*),\1,p' \
		$CGI_INFO >$HTTP_LIST 2>/dev/null

	# Extract the previously selected mirror server (first entry in the
	# ftplist.cgi output, if that has no location info).
	read -r -- _s _l <$HTTP_LIST
	[[ -z $_l ]] && : ${HTTP_SERVER:=${_s%%/*}}

	# Extract the previously used install method, timezone information
	# and a reference timestamp.
	while IFS='=' read -r -- _key _val; do
		case $_key=$_val in
		method=+([a-z])*([0-9]))	CGI_METHOD=$_val;;
		TIME=+([0-9]))			CGI_TIME=$_val;;
		TZ=+([-_/+[:alnum:]]))		CGI_TZ=$_val;;
		esac
	done <$CGI_INFO
}


# ------------------------------------------------------------------------------
# Utils functions
# ------------------------------------------------------------------------------

# Sort and print unique list of provided arguments.
bsort() {
	local _a=$1 _b _l

	(($#)) && shift || return

	for _b; do
		[[ $_a == "$_b" ]] && continue
		if [[ $_a > $_b ]]; then
			_l="$_a $_l" _a=$_b
		else
			_l="$_b $_l"
		fi
	done

	# Output the smallest value found.
	(($#)) && echo -n "$_a " || echo -n "$_a"

	# Sort remaining values.
	bsort $_l
}

# Test the first argument against the remaining ones, return success on a match.
isin() {
	local _a=$1 _b

	shift
	for _b; do
		[[ $_a == "$_b" ]] && return 0
	done
	return 1
}

# Add first argument to list formed by the remaining arguments.
# Adds to the tail if the element does not already exist.
addel() {
	local _a=$1

	shift
	isin "$_a" $* && echo -n "$*" || echo -n "${*:+$* }$_a"
}

# Remove all occurrences of first argument from list formed by the remaining
# arguments.
rmel() {
	local _a=$1 _b _c

	shift
	for _b; do
		[[ $_a != "$_b" ]] && _c="${_c:+$_c }$_b"
	done
	echo -n "$_c"
}

# If possible, print the timestamp received from the ftplist.cgi output,
# adjusted with the time elapsed since it was received.
http_time() {
	local _sec=$(cat $HTTP_SEC 2>/dev/null)

	[[ -n $_sec && -n $CGI_TIME ]] &&
		echo $((CGI_TIME + SECONDS - _sec))
}

# Prints the supplied parameters properly escaped for future sh/ksh parsing.
# Quotes are added if needed, so you should not do that yourself.
quote() (
	# Since this is a subshell we won't pollute the calling namespace.
	for _a; do
		alias Q=$_a; _a=$(alias Q); print -rn -- " ${_a#Q=}"
	done | sed '1s/ //'
	echo
)

# Show a list (passed via ordered arguments) in column output using ls.
show_cols() {
	local _l _cdir=/tmp/i/cdir _clist

	mkdir -p $_cdir
	rm -rf -- $_cdir/*
	while read _l; do
		[[ -n $_l ]] || continue
		mkdir -p /tmp/i/cdir/"$_l"
		_clist[${#_clist[*]}]="$_l"
	done
	(cd $_cdir; ls -Cdf "${_clist[@@]}")
	rm -rf -- $_cdir
}

# Echo file $1 to stdout. Skip comment lines and delete everything
# after the first '#' from other lines. Strip leading and trailing
# whitespace if IFS is set.
stripcom () {
	local _file=$1 _line

	[[ -f $_file ]] || return

	set -o noglob
	while read _line; do
		[[ -n ${_line%%#*} ]] && echo $_line
	done <$_file
	set +o noglob
}

# Create a temporary directory based on the supplied directory name prefix.
tmpdir() {
	local _i=1 _dir

	until _dir="${1?}.$_i.$RANDOM" && mkdir -- "$_dir" 2>/dev/null; do
		((++_i < 10000)) || return 1
	done
	echo "$_dir"
}

# Generate unique filename based on the supplied filename $1.
unique_filename() {
	local _fn=$1 _ufn

	while _ufn=${_fn}.$RANDOM && [[ -e $_ufn ]]; do done
	print -- "$_ufn"
}

# Let rc.firsttime feed file $1 using $2 as subject to whatever mail system we
# have at hand by then.
prep_root_mail() {
	local _fn=$1 _subject=$2 _ufn

	[[ -s $_fn ]] || return

	_ufn=$(unique_filename /mnt/var/log/${_fn##*/})
	cp $_fn $_ufn
	chmod 600 $_ufn
	_ufn=${_ufn#/mnt}

	cat <<__EOT >>/mnt/etc/rc.firsttime
( /usr/bin/mail -s '$_subject' root <$_ufn && rm $_ufn ) >/dev/null 2>&1 &
__EOT
}

# Examine the contents of the DHCP lease file $1 for a line containing the
# field provided as parameters and return the value of the first field found.
#
# Note that strings are unescaped but not unvis()'d.
lease_value () {
	local _lf=$1 _o

	shift
	for _o; do
		sed -E \
			-e '/^ *(option )?'"$_o"' (.*);$/!d;s//\2/' \
			-e '/^"(.*)"$/{s//\1/;s/\\(.)/\1/g;};q' "$_lf" \
			| grep ^ && return
	done
}

# ------------------------------------------------------------------------------
# Device related functions
# ------------------------------------------------------------------------------

# Show device name, info, NAA and size for the provided list of disk devices.
# Create device nodes as needed and cleanup afterwards.
diskinfo() {
	local _d _i _n _s

	for _d; do
		# Extract disk information enclosed in <> from dmesg.
		_i=$(dmesg | sed -n '/^'$_d' at /h;${g;s/^.*<\(.*\)>.*$/\1/p;}')
		_i=${_i##+([[:space:],])}
		_i=${_i%%+([[:space:],])}

		# Extract Network Address Authority information from dmesg..
		_n=$(dmesg | sed -En '/^'$_d' at /h;${g;s/^.* ([a-z0-9]+\.[a-zA-Z0-9_]+)$/\1/p;}')

		# Extract disk size from disklabel output.
		make_dev $_d
		_s=$(disklabel -dpg $_d 2>/dev/null | sed -n '/.*# total bytes: \(.*\)/{s//(\1)/p;}')
		rm -f /dev/{r,}$_d?

		echo "$_d: $_i $_n $_s"
	done
}

# Create devices passed as arguments.
make_dev() {
	[[ -z $(cd /dev && sh MAKEDEV "$@@" 2>&1) ]]
}

# Sort and print information from dmesg.boot using sed expression $1.
scan_dmesg() {
	bsort $(sed -n "$1" /var/run/dmesg.boot)
}

# Extract device names from hw.disknames matching sed expression $1.
scan_disknames() {
	local IFS=, _disks=$(sysctl -n hw.disknames)

	bsort $(for _n in $_disks; do echo "${_n%%:*} "; done | sed -n "$1")
}

# Return disk devices found in hw.disknames.
get_dkdevs () {
	echo $(scan_disknames "${MDDKDEVS:-/^[sw]d[0-9][0-9]* /s/ .*//p}")
}

# Return CDROM devices found in hw.disknames.
get_cddevs () {
	echo $(scan_disknames "${MDCDDEVS:-/^cd[0-9][0-9]* /s/ .*//p}")
}

# Return list of disks not yet initialized.
get_dkdevs_uninitialized() {
	local _disks=$(get_dkdevs) _d

	for _d in $DISKS_DONE; do
		_disks=$(rmel "$_d" $_disks)
	done
	bsort $_disks
}

# Return list of network devices. Filter out dynamically created network
# pseudo-devices except vlan.
get_ifs() {
	local _if _iflist=$(rmel vlan $(ifconfig -C))

	for _if in $(ifconfig "$@@" 2>/dev/null |
		sed -n 's/^\([^[:space:]]*\):.*/\1/p'); do
		isin "${_if%%+([0-9])}" $_iflist || echo $_if
	done
}

# Return the device name of the disk device $1, which may be a disklabel UID.
get_dkdev_name() {
	local _dev=${1#/dev/} _d

	_dev=${_dev%.[a-p]}
	((${#_dev} < 16)) && _dev=${_dev%[a-p]}
	local IFS=,
	for _d in $(sysctl -n hw.disknames); do
		[[ $_dev == @@(${_d%:*}|${_d#*:}) ]] && echo ${_d%:*} && break
	done
}

# Inspect disk $1 if it has a partition-table of type $2 and optionally
# if it has a partition of type $3.
disk_has() {
	local _disk=$1 _pttype=$2 _part=$3 _cmd _p_pttype _p_part

	[[ -n $_disk && -n $_pttype ]] || exit

	# Commands to inspect disk. Default: "fdisk $_disk"
	local _c_hfs="pdisk -l $_disk"
	local _c_sr="bioctl -q $_disk"

	# Patterns for partition-table-types and partition-types.
	local _p_gpt='Usable LBA:'
	local _p_gpt_openbsd='^[ *]...: OpenBSD '
	local _p_gpt_efisys='^[ *]...: EFI Sys '
	local _p_hfs='^Partition map '
	local _p_hfs_openbsd=' OpenBSD OpenBSD '
	local _p_mbr='Signature: 0xAA55'
	local _p_mbr_openbsd='^..: A6 '
	local _p_mbr_dos='^..: 06 '
	local _p_mbr_dos_active='^\*.: 06 '
	local _p_mbr_linux='^..: 83 '
	local _p_sr='OPENBSD, SR'
	local _p_sr_crypto='OPENBSD, SR CRYPTO'

	# Compose command and patterns based on the parameters.
	eval "_cmd=\"\$_c_${_pttype}\""
	eval "_p_pttype=\"\$_p_${_pttype}\""
	eval "_p_part=\"\$_p_${_pttype}_${_part}\""

	# Set the default command if none was defined before.
	_cmd=${_cmd:-fdisk $_disk}

	# Abort in case of undefined patterns.
	[[ -z $_p_pttype ]] && exit
	[[ -n $_part && -z $_p_part ]] && exit

	if [[ -z $_p_part ]]; then
		$_cmd 2>/dev/null | grep -Eq "$_p_pttype"
	else
		$_cmd 2>/dev/null | grep -Eq "$_p_pttype" &&
			$_cmd 2>/dev/null | grep -Eq "$_p_part"
	fi
}

# Handle disklabel auto-layout during interactive installation and
# autopartitioning during unattended installation for the root disk.
# In the latter case, ask for and download autopartitioning template.
# Abort unattended installation if autopartitioning fails.
#
# Parameters:
#
# $1 = disk
# $2 = /path/to/fstab
#
disklabel_autolayout() {
	local _disk=$1 _f=$2 _dl=/tmp/i/disklabel.auto _op _qst

	# Skip disklabel auto-layout for any disk except the root disk.
	[[ $_disk != $ROOTDISK ]] && return

	while $AUTO; do
		ask "URL to autopartitioning template for disklabel?" none
		[[ $resp == none ]] && break
		if ! $FTP_TLS && [[ $resp == https://* ]]; then
			err_exit "https not supported on this platform."
		fi
		echo "Fetching $resp"
		if unpriv ftp -Vo - "$resp" >$_dl && [[ -s $_dl ]]; then
			disklabel -T $_dl -F $_f -w -A $_disk && return
			err_exit "Autopartitioning failed."
		else
			err_exit "No autopartitioning template found."
		fi
	done

	_qst="Use (A)uto layout, (E)dit auto layout, or create (C)ustom layout?"
	while :; do
		echo "The auto-allocated layout for $_disk is:"
		disklabel -h -A $_disk | egrep "^#  |^  [a-p]:"
		ask "$_qst" a
		case $resp in
		[aA]*)	_op=-w;;
		[eE]*)	_op=-E;;
		[cC]*)	return 0;;
		*)	continue;;
		esac
		disklabel -F $_f $_op -A $_disk
		return
	done
}

# Create a partition table and configure the partition layout for disk $1.
configure_disk() {
	local _disk=$1 _fstab=/tmp/i/fstab.$1 _opt

	make_dev $_disk || return

	# Deal with disklabels, including editing the root disklabel
	# and labeling additional disks. This is machine-dependent since
	# some platforms may not be able to provide this functionality.
	# /tmp/i/fstab.$_disk is created here with 'disklabel -F'.
	rm -f /tmp/i/*.$_disk
	md_prep_disklabel $_disk || return

	# Make sure a '/' mount point exists on the root disk.
	if ! grep -qs ' / ffs ' /tmp/i/fstab.$ROOTDISK; then
		echo "'/' must be configured!"
		$AUTO && exit 1 || return 1
	fi

	if [[ -f $_fstab ]]; then
		# Avoid duplicate mount points on different disks.
		while read _pp _mp _rest; do
			if [[ $_mp == none ]]; then
				# Multiple swap partitions are ok.
				echo "$_pp $_mp $_rest" >>/tmp/i/fstab
				continue
			fi
			# Non-swap mountpoints must be in only one file.
			if [[ $_fstab != $(grep -l " $_mp " /tmp/i/fstab.*) ]]; then
				_rest=$_disk
				_disk=
				break
			fi
		done <$_fstab

		if [[ -z $_disk ]]; then
			# Duplicate mountpoint.
			# Allow disklabel(8) to read back mountpoint info
			# if it is immediately run against the same disk.
			cat /tmp/i/fstab.$_rest >/etc/fstab
			rm /tmp/i/fstab.$_rest
			set -- $(grep -h " $_mp " /tmp/i/fstab.*[0-9])
			echo "$_pp and $1 can't both be mounted at $_mp."
			$AUTO && exit 1 || return 1
		fi

		# Add ffs filesystems to list after newfs'ing them. Ignore
		# other filesystems.
		while read _pp _mp _fstype _rest; do
			[[ $_fstype == ffs ]] || continue
			_opt=
			[[ $_mp == / ]] && _opt=$MDROOTFSOPT
			newfs -q $_opt ${_pp##/dev/}
			# N.B.: '!' is lexically < '/'. That is
			#	required for correct sorting of
			#	mount points.
			FSENT="$FSENT $_mp!$_pp"
		done <$_fstab
	fi

	return 0
}

# ------------------------------------------------------------------------------
# Functions for the dmesg listener
# ------------------------------------------------------------------------------

# Acquire lock.
lock() {
	while ! mkdir /tmp/i/lock 2>/dev/null && sleep .1; do done
}

# Release lock.
unlock() {
	rm -df /tmp/i/lock 2>/dev/null
}

# Add trap to kill the listener process.
retrap() {
	trap 'kill -KILL $CPPID 2>/dev/null; echo; stty echo; exit 0' \
		INT EXIT TERM
}

# Start listener process looking for dmesg changes.
start_dmesg_listener() {
	local _update=/tmp/i/update

	# Make sure lock is initially released.
	unlock

	# The dmesg listener will check for the existence of this file and sends
	# a signal to the child process if the dmesg output differs from the
	# contents of that file.
	rm -f $_update

	$AUTO && return

	(
	while :; do
		lock
		if [[ -e $_update && "$(dmesg)" != "$(<$_update)" ]]; then
			dmesg >$_update
			kill -TERM 2>/dev/null $$ || exit 1
		fi
		unlock
		sleep .5
	done
	) |&
	CPPID=$!

	# Kill the child on exit.
	retrap
}

# ------------------------------------------------------------------------------
# Functions to ask (or auto-answer) questions
# ------------------------------------------------------------------------------

# Log installer questions and answers so that the resulting file can be used as
# response file for an unattended install/upgrade.
log_answers() {
	if [[ -n $1 && -n $2 ]]; then
		print -r -- "${1%%'?'*} = $2" >>/tmp/i/$MODE.resp
	fi
}

# Fetch response file for autoinstall.
get_responsefile() {
	local _rf _if _lf _hn _path _aifile
	export AI_MAC= AI_MODE= AI_SERVER=

	[[ -f /auto_upgrade.conf ]] && _rf=/auto_upgrade.conf AI_MODE=upgrade
	[[ -f /auto_install.conf ]] && _rf=/auto_install.conf AI_MODE=install
	[[ -f $_rf ]] && cp $_rf /tmp/ai/ai.$AI_MODE.conf && return

	for _if in ''; do
		[[ -x /sbin/dhclient ]] || break

		# Select a network interface for initial dhcp request.
		# Prefer the interface the system netbooted from.
		set -- $(get_ifs netboot)
		(($# == 0)) && set -- $(get_ifs)
		(($# == 1)) && _if=$1

		# Ask if multiple were found and system was not netbooted.
		while (($# > 1)); do
			ask_which "network interface" \
				"should be used for the initial DHCP request" \
				"$*"
			isin "$resp" $* && _if=$resp && break
		done

		# Issue initial dhcp request via the found interface.
		[[ -n $_if ]] && dhclient $_if || break
		_lf=/var/db/dhclient.leases.$_if

		# Extract installer mode and response file path from lease file.
		_aifile=$(lease_value $_lf filename bootfile-name)
		[[ $_aifile == ?(*/)auto_@@(install|upgrade) ]] || _aifile=
		_path=${_aifile%auto_@@(install|upgrade)}
		AI_MODE=${_aifile##*?(/)auto_}

		# Extract installer server ip address from lease file.
		AI_SERVER=$(lease_value $_lf \
			server-name tftp-server-name next-server)

		# Prime hostname with host-name option from lease file.
		_hn=$(lease_value $_lf host-name)
		hostname "$_hn"
	done

	# Fetch response file if server and mode are known, otherwise tell which
	# one was missing. Try to fetch mac-mode.conf, then hostname-mode.conf,
	# and finally mode.conf.
	if [[ -n $AI_SERVER && -n $AI_MODE ]]; then
		AI_MAC=$(ifconfig $_if | sed 's/.*lladdr \(.*\)/\1/p;d')
		for _rf in {$AI_MAC-,${_hn:+$_hn-,}}$AI_MODE; do
			_url="http://$AI_SERVER/$_path$_rf.conf?path=$HTTP_SETDIR"
			echo "Fetching $_url"
			if unpriv ftp -Vo - "$_url" \
				>"/tmp/ai/ai.$AI_MODE.conf" 2>/dev/null; then
				ifconfig $_if delete down 2>/dev/null
				return 0
			fi
		done
	else
		[[ -z $AI_SERVER ]] && echo "Could not determine auto server."
		[[ -z $AI_MODE ]] && echo "Could not determine auto mode."
	fi

	# Ask for url or local path to response file. Provide a default url if
	# server was found in lease file.
	while :; do
		ask "Response file location?" \
			"${AI_SERVER:+http://$AI_SERVER/install.conf}"
		[[ -n $resp ]] && _rf=$resp && break
	done

	# Ask for the installer mode only if auto-detection failed.
	AI_MODE=$(echo "$_rf" | sed -En 's/^.*(install|upgrade).conf$/\1/p')
	while [[ -z $AI_MODE ]]; do
		ask "(I)nstall or (U)pgrade?"
		[[ $resp == [iI]* ]] && AI_MODE=install
		[[ $resp == [uU]* ]] && AI_MODE=upgrade
	done

	echo "Fetching $_rf"
	[[ -f $_rf ]] && _rf="file://$_rf"
	if unpriv ftp -Vo - "$_rf" >"/tmp/ai/ai.$AI_MODE.conf" 2>/dev/null; then
		ifconfig $_if delete down 2>/dev/null
		return 0
	fi
	return 1
}

# Search question in $RESPFILE, return answer in $resp.
#
# 1) split question and answer at leftmost =
# 2) strip leading/trailing blanks
# 3) compare questions case insensitive
# 4) ignore empty and comment lines and lines without =
# 5) return default answer if provided and none is found in file
# 6) treat empty/missing/multiple answers as error and exit
#
# Parameters:
#
# $1 = the question to search for
# $2 = the default answer
#
_autorespond() {
	typeset -l _q=$1 _key
	local _def=$2 _l _val

	[[ -f $RESPFILE ]] || return

	# Find a suitable response in /tmp/ai/ai.conf and remove it if found.
	mv /tmp/ai/ai.conf /tmp/ai/ai.conf.tmp
	while IFS=' 	' read -r _l; do
		[[ $_l == [!#=]*=?* ]] || continue
		_key=${_l%%*([[:blank:]])=*}
		_val=${_l##*([!=])=*([[:blank:]])}
		[[ $_q == @@(|*[[:blank:]])"$_key"@@([[:blank:]?]*|) ]] &&
			resp=$_val && cat && return
		print -r " $_l"
	done </tmp/ai/ai.conf.tmp >/tmp/ai/ai.conf
	[[ -n $_def ]] && resp=$_def && return
	err_exit "\nQuestion has no answer in response file."
}

# Issue a read into the global variable $resp. If the dmesg output is
# changed while inside this function, the current read will be aborted
# and the function will return a non-zero value. Normally, the caller
# will then reprint any prompt and call the function again.
#
# Optional parameters:
#
# $1 = the question to ask the user
# $2 = the default answer
#
_ask() {
	local _q=$1 _def=$2 _int _redo=0 _pid

	lock; dmesg >/tmp/i/update; unlock
	echo -n "${_q:+$_q }${_def:+[$_def] }"
	_autorespond "$_q" "$_def" && echo "$resp" && return
	trap "_int=1" INT
	trap "_redo=1" TERM
	read resp
	lock; rm /tmp/i/update; unlock
	if ((_redo)); then
		stty raw
		stty -raw
	else
		case $resp in
		!)	echo "Type 'exit' to return to install."
			sh
			_redo=1
			;;
		!*)	eval "${resp#?}"
			_redo=1
			;;
		esac
	fi
	retrap
	((_int)) && kill -INT $$
	: ${resp:=$_def}
	return $_redo
}

# Ask for user input presenting question $1 with an optional default answer $2.
# Save the answer in the global variable $resp. Additionally write the question
# and the answer to a logfile. Parameters $1 and $2 are passed on to _ask(),
# which is called repeatedly until it succeds.
ask() {
	while ! _ask "$1" "$2"; do done
	log_answers "$1" "$resp"
}

# Ask the user a yes/no question, and insist on 'y', 'yes', 'n' or 'no'.
# Return 'y' or 'n' in $resp.
# Exit code: (y)es => 0, (n)o => 1
#
# Parameters:
#
# $1 = the question to ask the user
# $2 = the default answer (assumed to be 'n' if empty).
#
ask_yn() {
	local _q=$1 _a=${2:-no}
	typeset -l _resp

	while :; do
		ask "$_q" "$_a"
		_resp=$resp
		case $_resp in
		y|yes)	resp=y; return 0;;
		n|no)	resp=n; return 1;;
		esac
		echo "'$resp' is not a valid choice."
		$AUTO && exit 1
	done
}

# Ask for the user to select one value from a list, or 'done'.
# At exit $resp holds selected item, or 'done'.
#
# Parameters:
#
# $1 = name of the list items (disk, cd, etc.)
# $2 = question to ask
# $3 = list of valid choices
# $4 = default choice, if it is not specified use the first item in $3
#
# N.B.! $3 and $4 will be "expanded" using eval, so be sure to escape them
#       if they contain spooky stuff
ask_which() {
	local _name=$1 _query=$2 _list=$3 _def=$4 _dynlist _dyndef _key _q
	_key=$(echo "$_name" | sed 's/[^[:alnum:]]/_/g')

	while :; do
		eval "_dynlist=\"$_list\""
		eval "_dyndef=\"$_def\""

		# Clean away whitespace and determine the default.
		set -o noglob
		set -- $_dyndef; _dyndef="$1"
		set -- $_dynlist; _dynlist="$*"
		set +o noglob
		(($# < 1)) && resp=done && return

		: ${_dyndef:=$1}
		echo "Available ${_name}s are: $_dynlist."
		_q="Which $_name $_query?"
		echo -n "$_q (or 'done') ${_dyndef:+[$_dyndef] }"
		_autorespond "$_q" "${_dyndef-done}" && echo "$resp" \
			|| _ask || continue
		[[ -z $resp ]] && resp="$_dyndef"

		# Quote $resp to prevent user from confusing isin() by
		# entering something like 'a a'.
		if isin "$resp" $_dynlist done; then
			log_answers "$_q" "$resp"
			break
		fi
		echo "'$resp' is not a valid choice."
		$AUTO && [[ -n $RESPFILE ]] && exit 1
	done
}

# Ask for user input until a non-empty reply is entered.
# Save the user input (or the default) in $resp.
#
# Parameters:
#
# $1 = the question to ask the user
# $2 = the default answer
#
function ask_until {
	resp=

	while true; do
		ask "$1" "$2"
		[[ -n $resp ]] && break
		echo "A response is required."
		$AUTO && exit 1
	done
}

# Ask for a password, saving the input in $resp.
#
# 1) Display $1 as the prompt.
# 2) *Don't* allow the '!' options that ask does.
# 3) *Don't* echo input.
# 4) *Don't* interpret "\" as escape character.
# 5) Preserve whitespace in input
#
ask_pass() {
	stty -echo
	IFS= read -r resp?"$1 "
	stty echo
	echo
}

# Ask for a password twice, saving the input in $_password.
ask_password() {
	local _q=$1

	if $AUTO; then
		echo -n "$_q "
		_autorespond "$_q"
		echo '<provided>'
		_password=$resp
		return
	fi

	while :; do
		ask_pass "$_q (will not echo)"
		_password=$resp

		ask_pass "$_q (again)"
		[[ $resp == "$_password" ]] && break

		echo "Passwords do not match, try again."
	done
}


# ------------------------------------------------------------------------------
# Support functions for donetconfig()
# ------------------------------------------------------------------------------

# Issue a DHCP request to configure interface $1 and add the host-name option to
# /etc/dhclient.conf using $2.
dhcp_request() {
	local _if=$1 _hn=$2

	echo "lookup file bind" >/etc/resolv.conf.tail
	echo "send host-name \"$_hn\";" >/etc/dhclient.conf

	ifconfig $_if group dhcp >/dev/null 2>&1

	dhclient -c /dev/stdin $_if <<__EOT
initial-interval 1;
backoff-cutoff 2;
reboot 5;
timeout 10;
send host-name "$_hn";
__EOT

	# Move configuration files to where they will be copied to the
	# installed system. Overwrites configuration information from
	# last successful dhcp attempt.
	mv /etc/dhclient.conf /tmp/i/dhclient.conf
	mv /etc/resolv.conf.tail /tmp/i/resolv.conf.tail
}

# Obtain and output the inet information related to interface $1.
# Should output '<UP/DOWN> <addr> <netmask> <rest of inet line>'.
v4_info() {
	ifconfig $1 inet | sed -n '
		1s/.*<UP,.*/UP/p
		1s/.*<.*/DOWN/p
		/inet/s/netmask//
		/inet/s///p'
}

# Convert a netmask in hex format ($1) to dotted decimal format.
hextodec() {
	set -- $(echo ${1#0x} | sed 's/\(..\)/0x\1 /g')
	echo $(($1)).$(($2)).$(($3)).$(($4))
}

# Create an entry in the hosts file. If an entry with the same symbolic name and
# address family already exists, delete it.
#
# Parameters:
#
# $1 = IP address (v6 if it contains ':', else v4)
# $2 = symbolic name
#
add_hostent() {
	local _addr=$1 _name=$2 _delim="."

	[[ -z $_addr || -z $_name ]] && return

	[[ $_addr == *:* ]] && _delim=":"
	sed -i "/^[0-9a-fA-F]*[$_delim].*[ 	]$_name\$/d" \
		/tmp/i/hosts 2>/dev/null

	echo "$_addr $_name" >>/tmp/i/hosts
}

# Configure IPv4 interface.
#
# Parameters:
#
# $1 = name of the network device
# $2 = hostname to use for dhcp request
# $3 = /path/to/hostname.if
#
v4_config() {
	local _if=$1 _name=$2 _hn=$3 _prompt _addr _mask

	if ifconfig $_if | grep -q 'groups:.* dhcp'; then
		_addr=dhcp
	else
		set -- $(v4_info $_if)
		if [[ -n $2 ]]; then
			_addr=$2; _mask=$(hextodec $3)
			ifconfig $_if inet $_addr delete
		fi
	fi

	if [[ -x /sbin/dhclient ]]; then
		_prompt="or 'dhcp' "
		# Don't make 'dhcp' the default if dhcp was already used.
		ifconfig dhcp >/dev/null 2>&1 || _addr=dhcp
	fi
	_prompt="IPv4 address for $_if? (${_prompt}or 'none')"

	ask_until "$_prompt" "$_addr"
	case $resp in
	none)	;;
	dhcp)	if [[ ! -x /sbin/dhclient ]]; then
			echo "DHCP not possible - no /sbin/dhclient."
		else
			dhcp_request $_if "$_name"
			echo "dhcp" >>$_hn
		fi
		;;
	*)	_addr=$resp
		ask_until "Netmask for $_if?" "${_mask:=255.255.255.0}"
		ifconfig $_if -group dhcp >/dev/null 2>&1
		if ifconfig $_if inet $_addr netmask $resp up; then
			add_hostent "$_addr" "$_name"
			echo "inet $_addr $resp" >>$_hn
		fi
		;;
	esac
}

# Obtain and output the inet6 information related to interface $1.
# Should output '<UP/DOWN> <addr> <prefixlen> <rest of inet line> '.
v6_info() {
	ifconfig $1 inet6 | sed -n '
		1s/.*<UP,.*/UP/p
		1s/.*<.*/DOWN/p
		/scopeid/d
		/inet6/s/prefixlen//
		/inet6/s///p'
}

# Set up IPv6 default route on interface $1.
v6_defroute() {
	local _if=$1 _prompt _resp _routers PS3

	route -n show -inet6 | egrep -q '^default[[:space:]]' && return

	_routers=$(bsort $(ping6 -n -c 2 ff02::2%$_if 2>/dev/null |
		sed -n '/bytes from/{s/^.*from //;s/,.*$//;p;}' |
		sed -n 'G;s/\n/&&/;/^\(.*\n\).*\n\1/d;h;P'))

	_prompt="IPv6 default router?"

	if $AUTO; then
		_autorespond "$_prompt" && _resp=$resp && echo "$_prompt $_resp"
	else
		PS3="$_prompt (${_routers:+list #, }IPv6 address or 'none'): "
		select _resp in $_routers; do
			[[ ${_resp:=$REPLY} == *:* ]] && break
			[[ $_resp == none ]] && return
		done
	fi

	route -n add -inet6 -host default "$_resp" &&
		echo "$_resp" >>/tmp/i/mygate
}

# Configure IPv6 interface.
#
# Parameters:
#
# $1 = name of the network device
# $2 = hostname to use for dhcp request
# $3 = /path/to/hostname.if
#
v6_config() {
	local _if=$1 _name=$2 _hn=$3 _addr _prefixlen _prompt

	ifconfig lo0 inet6 >/dev/null 2>&1 || return

	set -- $(v6_info $_if)
	[[ -n $2 ]] && { _addr=$2; _prefixlen=$3; }

	ifconfig $_if inet6 >/dev/null 2>&1 && _prompt="or 'autoconf' "
	_prompt="IPv6 address for $_if? (${_prompt}or 'none')"
	ask_until "$_prompt" "${_addr:-none}"

	case $resp in
	none)	return
		;;
	autoconf)
		ifconfig $_if inet6 >/dev/null 2>&1 ||
			{ echo "No INET6 support."; return; }
		ifconfig $_if inet6 autoconf && echo "inet6 autoconf" >>$_hn
		return
		;;
	esac

	_addr=$resp
	ask_until "IPv6 prefix length for $_if?" "${_prefixlen:=64}"
	ifconfig $_if inet6 $_addr prefixlen $resp up || return
	echo "inet6 $_addr $resp" >>$_hn
	add_hostent "$_addr" "$_name"

	v6_defroute $_if
}

# Perform an 802.11 network scan on interface $1.
# The result is cached in $WLANLIST.
ieee80211_scan() {
	# N.B. Skipping quoted nwid's for now.
	[[ -f $WLANLIST ]] ||
		ifconfig $1 scan |
		sed -n 's/^		nwid \([^"]\)/\1/p' >$WLANLIST
	cat $WLANLIST
}

# Configure 802.11 interface $1 and append ifconfig options to hostname.if $2.
ieee80211_config() {
	local _if=$1 _hn=$2 _prompt _nwid _haswpa=0 _err

	# Reset 802.11 settings and determine wpa capability.
	ifconfig $_if -nwid -nwkey
	ifconfig $_if -wpa 2>/dev/null && _haswpa=1

	# Empty scan cache.
	rm -f $WLANLIST

	while [[ -z $_nwid ]]; do
		ask_until "Access point? (ESSID, 'any', list# or '?')" "any"
		case "$resp" in
		+([0-9]))
			_nwid=$(ieee80211_scan $_if | sed -n "${resp}s/ .*//p")
			[[ -z $_nwid ]] && echo "There is no line $resp."
			;;
		\?)	ieee80211_scan $_if |
				sed -n 's/^\([^ ]*\) chan .* bssid \([^ ]*\) .*$/	\1 (\2)/p' |
				cat -n | more -c
			;;
		*)	_nwid=$resp
			;;
		esac
	done

	# 'any' implies that only open access points are considered.
	if [[ $_nwid != any ]]; then
		ifconfig $_if nwid "$_nwid"
		quote nwid "$_nwid" >>$_hn

		_prompt="Security protocol? (O)pen, (W)EP"
		((_haswpa == 1)) && _prompt="$_prompt, WPA-(P)SK"
		while :; do
			ask_until "$_prompt" "O"
			case "$_haswpa-$resp" in
			?-[Oo])	break
				;;
			?-[Ww])	ask_until "WEP key? (will echo)"
				# Make sure ifconfig accepts the key.
				if _err=$(ifconfig $_if nwkey "$resp" 2>&1) &&
					[[ -z $_err ]]; then
					quote nwkey "$resp" >>$_hn
					break
				fi
				echo "$_err"
				;;
			1-[Pp])	ask_until "WPA passphrase? (will echo)"
				# Make sure ifconfig accepts the key.
				if ifconfig $_if wpakey "$resp"; then
					quote wpakey "$resp" >>$_hn
					break
				fi
				;;
			*)	echo "'$resp' is not a valid choice."
				;;
			esac
		done
	fi
}

# Set up IPv4 and IPv6 interface configuration.
configure_ifs() {
	local _first _ifs _if _name _hn _vl=0 _vd _vi _p _tags

	# In case of restart, discover last vlan configured.
	while :; do
		_vd=$(ifconfig vlan$_vl 2>&1)
		[[ $_vd == @@(*no such interface*) ]] && break
		[[ $_vd == @@(*vlan: +([[:digit:]]) parent interface:*) ]] ||
			break
		((_vl++))
	done
	_vd=

	# Always need lo0 configured.
	ifconfig lo0 inet 127.0.0.1/8

	# In case of restart, delete previous default gateway config.
	rm -f /tmp/i/mygate

	while :; do
		# Create new vlan if possible.
		ifconfig vlan$_vl create >/dev/null 2>&1

		ask_which "network interface" "do you wish to configure" \
			'$(get_ifs)' \
			${_p:-'$( (get_ifs netboot; get_ifs) | sed q )'}
		[[ $resp == done ]] && break

		_if=$resp
		_hn=/tmp/i/hostname.$_if
		rm -f $_hn

		# If the offered vlan is chosen, ask the relevant
		# questions and bring it up.
		if [[ $_if == vlan+([0-9]) ]]; then
			# Get existing tag for this vlan.
			_vi=$(ifconfig $_if 2>/dev/null |
				sed -n 's/vlan: \([0-9]*\).*/\1/p')
			# Get list of all in-use tags.
			_tags=$(ifconfig vlan 2>/dev/null |
				sed -n 's/vlan: \([0-9]*\).*/\1/p')
			# Current tag is a valid tag for this vlan.
			[[ -n $_tags ]] && _tags=$(rmel "$_vi" $_tags)
			if [[ -z $_vi ]]; then
				_vi=0
				while ((++_vi < 4096)); do
					! isin "$_vi" $_tags && break
				done
			fi
			_ifs=$(get_ifs)
			set -- $_ifs
			while [[ $1 == vlan+([0-9]) ]]; do
				shift
			done
			ask "Which interface:tag should $_if be on?" \
				"${_vd:=$1}:$_vi"
			_vd=${resp%%:*}
			_vi=${resp##*:}

			# Validate that $_vd is a real interface.
			if ! (isin "$_vd" $_ifs &&
				[[ $_vd != vlan+([0-9]) ]]); then
				echo "Invalid interface choice '$_vd'"
				_vd=
				continue
			fi

			# Validate range of $_vi as 1-4095, and $_vi not in use.
			if ((_vi < 1 || _vi > 4095)) || isin "$_vi" $_tags; then
				echo "Invalid or in-use vlan tag '$_vi'"
				continue
			fi

			# hostname.$_vd must say something, anything, to
			# make sure it is up.
			grep -qs "^up" /tmp/i/hostname.$_vd ||
				echo "up" >>/tmp/i/hostname.$_vd
			chmod 640 /tmp/i/hostname.$_vd
			ifconfig $_vd up

			# Make sure a hostname.$_if is created with this info.
			ifconfig $_if destroy >/dev/null 2>&1
			ifconfig $_if vlan $_vi vlandev $_vd
			echo "vlan $_vi vlandev $_vd" >>$_hn
			# Create a new vlan if we just configured the highest.
			[[ ${_if##vlan} == $_vl ]] && ((_vl++))
		fi

		# Test if it is an 802.11 interface.
		ifconfig $_if 2>/dev/null | grep -q "^[[:space:]]*ieee80211:" &&
			ieee80211_config $_if $_hn

		# First interface configured will use the hostname without
		# asking the user.
		resp=$(hostname -s)
		[[ -n $_first && $_first != $_if ]] &&
			ask "Symbolic (host) name for $_if?" $resp
		_name=$resp

		v4_config $_if $_name $_hn
		v6_config $_if $_name $_hn

		if [[ -f $_hn ]]; then
			chmod 640 $_hn
			: ${_first:=$_if}
		fi

		NIFS=$(ls -1 /tmp/i/hostname.* 2>/dev/null | grep -c ^)
		_p=done
	done
}

# Set up IPv4 default route.
v4_defroute() {
	local _dr

	# Only configure a default route if an IPv4 address was configured.
	[[ -n $(ifconfig | sed -n '/[ 	]inet .* broadcast /p') ]] || return

	# Check routing table to see if a default route ($1) already exists
	# and if it is handled by dhclient ($2).
	set -- $(route -nv show -inet |
		{ set -- $(grep '^default '); print $2 $9; })
	[[ -n $1 ]] && _dr=$1

	# Don't ask if a default route exits and is handled by dhclient.
	[[ -n $_dr && $2 == \"DHCLIENT && -f /tmp/i/dhclient.conf ]] && return

	while :; do
		ask_until "Default IPv4 route? (IPv4 address or none)" "$_dr"
		[[ $resp == none ]] && break
		route delete -inet default >/dev/null 2>&1
		route -n add -inet -host default "$resp" &&
			{ echo "$resp" >>/tmp/i/mygate; break; }
		# Put the old default route back. The new one did not work.
		route -n add -inet -host default $_dr >/dev/null 2>&1
	done
}

# Extract fully qualified domain name from current hostname. If none is
# currently set, use 'my.domain'.
get_fqdn() {
	local _dn

	_dn=$(hostname)
	_dn=${_dn#$(hostname -s)}
	_dn=${_dn#.}

	echo "${_dn:=my.domain}"
}


# ------------------------------------------------------------------------------
# Support functions for install_sets()
# ------------------------------------------------------------------------------

# Check that missing required sets were deliberately skipped.
# Care is taken to make sure the return value is correct.
sane_install() {
	local _q=$1 _s

	for _s in $SANESETS; do
		isin "$_s" $DEFAULTSETS || continue
		[[ -n $_q ]] && return 1
		# If sane_install has no argument, harass the user.
		if ! ask_yn "Are you *SURE* your $MODE is complete without '$_s'?"; then
			$AUTO && exit 1 || return 1
		fi
	done
}

# Show list of available sets and let the user select which sets to install.
# Set $resp to list of selected sets.
#
# Parameters:
#
# $1 = available sets
# $2 = already selected sets
#
select_sets() {
	local _avail=$1 _selected=$2 _f _action _col=$COLUMNS

	# account for 4 spaces added to the sets list
	let COLUMNS=_col-8

	cat <<__EOT

Select sets by entering a set name, a file name pattern or 'all'. De-select
sets by prepending a '-', e.g.: '-game*'. Selected sets are labelled '[X]'.
__EOT
	while :; do
		for _f in $_avail; do
			isin "$_f" $_selected && echo "[X] $_f" || echo "[ ] $_f"
		done | show_cols | sed 's/^/    /'
		ask "Set name(s)? (or 'abort' or 'done')" done

		set -o noglob
		for resp in $resp; do
			case $resp in
			abort)	_selected=; break 2;;
			done)	break 2;;
			-*)	_action=rmel;;
			*)	_action=addel;;
			esac
			resp=${resp#[+-]}
			[[ $resp == all ]] && resp=*

			for _f in $_avail; do
				[[ $_f == $resp ]] &&
					_selected=$($_action $_f $_selected)
			done
		done
	done

	set +o noglob
	COLUMNS=$_col

	resp=$_selected
}

# Run a command ($2+) as unprivileged user ($1).
# Take extra care that after "cmd" no "user" processes exist.
#
# Optionally:
#	- create "file" and chown it to "user"
#	- after "cmd", chown "file" back to root
#
# Usage: do_as user [-f file] cmd
do_as() {
	(( $# >= 2 )) || return

	local _file _rc _user=$1
	shift

	if [[ $1 == -f ]]; then
		_file=$2
		shift 2
	fi

	if [[ -n $_file ]]; then
		>$_file
		chown "$_user" "$_file"
	fi

	doas -u "$_user" "$@@"
	_rc=$?

	while doas -u "$_user" kill -9 -1 2>/dev/null; do
		echo "Processes still running for user $_user after: $@@"
		sleep 1
	done

	[[ -n $_file ]] && chown root "$_file"

	return $_rc
}

unpriv() {
	do_as _sndio "$@@"
}

unpriv2() {
	do_as _file "$@@"
}

# Install a user-selected subset of the files in $2 from the source
# named in $1. Display an error message for failed installs so the
# user will know to try again.
install_files() {
	local _src=$1 _files=$2 _f _sets _get_sets _n _col=$COLUMNS \
		_tmpfs _tmpsrc _cfile=/tmp/SHA256 _fsrc _unver _t _issue
	local _srclocal=false _unpriv=unpriv

	# Fetch sets from local sources (disk, cdrom, nfs) as root.
	[[ $_src == file://* ]] && _srclocal=true _unpriv=

	# Initialize _sets to the list of sets found in _src, and initialize
	# _get_sets to the intersection of _sets and DEFAULTSETS.
	#
	# Sets will be installed in the order given in THESETS to ensure proper
	# installation.  So, to minimize user confusion display the sets in the
	# order in which they will be installed.
	for _f in $THESETS; do
		isin "$_f" $_files || continue
		_sets=$(addel $_f $_sets)
		isin "$_f" $DEFAULTSETS "site$VERSION-$(hostname -s).tgz" &&
			_get_sets=$(addel $_f $_get_sets)
	done

	if [[ -z $_sets ]]; then
		echo -n "Looked at $_src "
		echo "and found no $OBSD sets.  The set names looked for were:"

		let COLUMNS=_col-8
		for _n in $THESETS; do echo $_n; done | show_cols | sed 's/^/    /'
		COLUMNS=$_col

		$AUTO && exit 1
		echo
		return
	fi

	isin "INSTALL.$ARCH" $_files ||
		ask_yn "INSTALL.$ARCH not found. Use sets found here anyway?" ||
		return

	select_sets "$_sets" "$_get_sets"

	[[ -n $resp ]] || return
	_get_sets=$resp

	# Reorder $_get_sets.
	_get_sets=$(for s in $THESETS; do isin "$s" $_get_sets && echo $s; done)

	# Note which sets didn't verify ok.
	_unver=$_get_sets

	# Try to prefetch and control checksum files.
	# Use dummy for loop as combined assignment and do { ... } while(0).
	for _issue in ''; do
		! isin SHA256.sig $_files &&
			_issue="Directory does not contain SHA256.sig" && break

		# For non-local sources find a filesystem to store the prefetched
		# sets. Prefer filesystems which are not used during extraction.
		# They need to have 512 MB free space. Otherwise use any other
		# filesystem having 2 GB free space to prevent overflow during
		# extraction.
		$_srclocal || _tmpfs=$( (
			for fs in /mnt/{{,var/}tmp,home,usr{/local,}}; do
				df -k $fs 2>/dev/null | grep " $fs\$"
			done
			df -k
		) | (
			while read a a a a m m; do
				[[ $m == /mnt/@@(@@(|var/)tmp|home|usr/@@(src,obj,xobj))@@(|/*) ]] &&
					((a > 524288)) && echo $m && exit
				[[ $m == /mnt@@(|/*) ]] &&
					((a > 524288 * 4)) && echo $m && exit
			done
		) )

		if ! $_srclocal; then
			if [[ -d $_tmpfs ]]; then
				# Try to clean up from previous runs, assuming
				# the _tmpfs selection yields the same mount
				# point.
				for _tmpsrc in $_tmpfs/sets.+([0-9]).+([0-9]); do
					[[ -d $_tmpsrc ]] && rm -r $_tmpsrc
				done
				! _tmpsrc=$(tmpdir "$_tmpfs/sets") &&
				_issue="Cannot create prefetch area" && break
			else
				_issue="Cannot determine prefetch area" && break
			fi
		fi

		# Cleanup from previous runs.
		rm -f $_cfile $_cfile.sig

		_t=Get/Verify
		$_srclocal && _t='Verifying '

		# Fetch signature file.
		! $_unpriv ftp -D "$_t" -Vmo - "$_src/SHA256.sig" >"$_cfile.sig" &&
			_issue="Cannot fetch SHA256.sig" && break

		# Verify signature file with public keys.
		! unpriv -f "$_cfile" \
			signify -Vep $PUB_KEY -x "$_cfile.sig" -m "$_cfile" &&
			_issue="Signature check of SHA256.sig failed" && break

		for _f in $_get_sets; do
			rm -f /tmp/h /tmp/fail

			# Fetch set and create checksum by pipe through sha256.
			# Create a flag file in case ftp failed. Sets from net
			# are written to prefetch area, the output of local sets
			# is discarded.
			( $_unpriv ftp -D "$_t" -Vmo - "$_src/$_f" || >/tmp/fail ) |
			( $_srclocal && unpriv2 sha256 >/tmp/h ||
				unpriv2 -f /tmp/h sha256 -ph /tmp/h >"$_tmpsrc/$_f" )

			# Handle failed transfer.
			if [[ -f /tmp/fail ]]; then
				rm -f "$_tmpsrc/$_f"
				if ! ask_yn "Fetching of $_f failed. Continue anyway?"; then
					[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc"
					$AUTO && exit 1
					return
				fi
				continue
			fi

			# Verify sets by comparing its checksum with SHA256.
			if fgrep -qx "SHA256 ($_f) = $(</tmp/h)" "$_cfile"; then
				_unver=$(rmel $_f $_unver)
			else
				if ! ask_yn "Checksum test for $_f failed. Continue anyway?"; then
					[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc"
					$AUTO && exit 1
					return
				fi
			fi
		done
	done

	[[ -n $_unver ]] && : ${_issue:="Unverified sets:" ${_unver% }}
	if [[ -n $_issue ]] &&
		! ask_yn "$_issue. Continue without verification?"; then
		[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc"
		$AUTO && exit 1
		return
	fi

	for _f in $_get_sets; do
		_fsrc="$_src/$_f"
		[[ -f $_tmpsrc/$_f ]] && _fsrc="file://$_tmpsrc/$_f"
		case $_fsrc in
		*.tgz)	$_unpriv ftp -D Installing -Vmo - "$_fsrc" |
				tar -zxphf - -C /mnt
			if [[ $_f == ?(x)base*.tgz && $MODE == install ]]; then
				ftp -D Extracting -Vmo - \
				file:///mnt/var/sysmerge/${_f%%base*}etc.tgz |
				tar -zxphf - -C /mnt
			fi
			;;
		*)	$_unpriv ftp -D Installing -Vmo - "$_fsrc" >"/mnt/$_f"
			;;
		esac
		if (($?)); then
			if ! ask_yn "Installation of $_f failed. Continue anyway?"; then
				[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc"
				$AUTO && exit 1
				return
			fi
		else
			DEFAULTSETS=$(rmel $_f $DEFAULTSETS)
		fi
		[[ -d $_tmpsrc ]] && rm -f "$_tmpsrc/$_f"
	done
	[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc" || true
}

# Fetch install sets from an HTTP server possibly using a proxy.
install_http() {
	local _d _f _flist _file_list _prompt _tls _http_proto _url_base
	local _idx=/tmp/i/index.txt _sha=/tmp/i/SHA256 _sig=/tmp/i/SHA256.sig
	local _iu_url _iu_srv _iu_dir _mirror_url _mirror_srv _mirror_dir

	# N.B.: Don't make INSTALL_MIRROR a local variable! It preserves the
	# mirror information if install_http() is called multiple times with
	# mirror and local servers. That ensures that the mirror server ends
	# up in /etc/installurl file if one of the servers is not a mirror.

	# N.B.: 'http_proxy' is an environment variable used by ftp(1).
	# DON'T change the name or case!
	ask "HTTP proxy URL? (e.g. 'http://proxy:8080', or 'none')" \
		"${http_proxy:-none}"
	unset http_proxy
	[[ $resp == none ]] || export http_proxy=$resp

	# If the mirror server listfile download failed, inform the user and
	# show a reduced prompt.
	if [[ -s $HTTP_LIST ]]; then
		_prompt="HTTP Server? (hostname, list#, 'done' or '?')"
	else
		echo "(Unable to get list from ftp.openbsd.org, but that is OK)"
		_prompt="HTTP Server? (hostname or 'done')"
	fi

	# Use information from /etc/installurl as defaults for upgrades.
	# Format of installurl: _http_proto://_iu_srv/_iu_dir
	#                       ^--------- _iu_url ---------^
	if [[ $MODE == upgrade ]] &&
		_iu_url=$(stripcom /mnt/etc/installurl); then
		_iu_srv=${_iu_url#*://}
		_iu_srv=${_iu_srv%%/*}
		_iu_dir=${_iu_url##*$_iu_srv*(/)}
	fi

	# Get server IP address or hostname and optionally the http protocol.
	while :; do
		ask_until "$_prompt" "${_iu_srv:-$HTTP_SERVER}"
		case $resp in
		done)	return
			;;
		"?")	[[ -s $HTTP_LIST ]] || continue
			# Show a numbered list of mirror servers.
			cat -n < $HTTP_LIST | more -c
			;;
		+([0-9]))
			# A number is only used as a line number in $HTTP_LIST.
			[[ -s $HTTP_LIST ]] || continue
			# Extract the URL from the mirror server listfile.
			set -- $(sed -n "${resp}p" $HTTP_LIST)
			if (($# < 1)); then
				echo "There is no line $resp."
				continue
			fi
			HTTP_SERVER=${1%%/*}
			# Repeat loop to get user to confirm server address.
			;;
		?(http?(s)://)+([A-Za-z0-9:.\[\]_-]))
			case $resp in
			https://*)	_tls=force _http_proto=https;;
			http://*)	_tls=no    _http_proto=http;;
			*)		_tls=try   _http_proto=$HTTP_PROTO;;
			esac
			if ! $FTP_TLS && [[ $_tls == force ]]; then
				echo "https not supported on this platform."
				$AUTO && exit 1 || continue
			fi
			HTTP_SERVER=${resp#*://}
			break
			;;
		*)	echo "'$resp' is not a valid hostname."
			;;
		esac
	done

	# Get directory info from *last* line starting with the server
	# name. This means the last install from a mirror will not keep
	# the specific directory info. But an install from a local
	# server *will* remember the specific directory info.
	# Format: _mirror_srv/_mirror_dir location_info
	#         ^---- _mirror_url ----^
	set -- $(grep -i "^$HTTP_SERVER" $HTTP_LIST 2>/dev/null | sed '$!d')
	_mirror_url=${1%%*(/)}
	_mirror_srv=${_mirror_url%%/*}
	_mirror_dir=${_mirror_url##*$_mirror_srv*(/)}

	# Decide on the default for the "Server directory" question.
	if [[ -n $_mirror_url ]]; then
		# Use directory information from cgi server if HTTP_SERVER was
		# found in HTTP_LIST. That is either an official mirror or the
		# server used in a previous installation or upgrade.
		_d=$_mirror_dir/$HTTP_SETDIR

		# Preserve the information that it is an official mirror if
		# location is present in $2.
		(($# > 1)) && INSTALL_MIRROR=$_mirror_url
	elif [[ -n $_iu_url ]]; then
		# Otherwise, if it exists, use directory information from
		# installurl(5) during upgrade.
		_d=$_iu_dir/$HTTP_SETDIR
	else
		_d=pub/OpenBSD/$HTTP_SETDIR
	fi

	ask_until "Server directory?" "$_d"
	HTTP_DIR=${resp##+(/)}
	_url_base="$_http_proto://$HTTP_SERVER/$HTTP_DIR"

	# Fetch SHA256.sig to create the list of files to select from.
	rm -f $_idx $_sha $_sig
	if ! unpriv -f $_sig \
		ftp -w 15 -VMo $_sig "$_url_base/SHA256.sig" 2>/dev/null; then
		case $_tls in
		force)	$AUTO && exit 1 || return
			;;
		try)	ask_yn "Unable to connect using https. Use http instead?" ||
				return
			_http_proto=http
			_url_base="http://$HTTP_SERVER/$HTTP_DIR"
			unpriv -f $_sig ftp -VMo $_sig "$_url_base/SHA256.sig" \
				2>/dev/null
			;;
		esac
	fi

	# Verify SHA256.sig, write SHA256 and extract the list of files.
	if unpriv -f $_sha \
		signify -Vep $PUB_KEY -x $_sig -m $_sha >/dev/null 2>&1; then
		_file_list="$(sed -n 's/^SHA256 (\(.*\)).*$/\1/p' $_sha)"
		_file_list="SHA256.sig $_file_list"
	else
		echo "Unable to get a verified list of distribution sets."
		# Deny this server, if it's a mirror without a valid SHA256.sig.
		if [[ ${_url_base%/$HTTP_SETDIR} == "$INSTALL_MIRROR" ]]; then
			$AUTO && exit 1 || return
		fi
	fi

	# Fetch index.txt, extract file list but add only entries that are not
	# already in _file_list. This allows for a verified list of distribution
	# sets from SHA256.sig, siteXX sets or the whole set list from index.txt
	# if SHA256.sig was not found (e.g. self compiled sets).
	if unpriv -f $_idx \
		ftp -VMo $_idx "$_url_base/index.txt" 2>/dev/null; then
		_flist=$(sed -En 's/^.* ([a-zA-Z][a-zA-Z0-9._-]+)$/\1/p' $_idx)
		for _f in $_flist; do
			! isin "$_f" $_file_list && _file_list="$_file_list $_f"
		done
	fi
	rm -f $_idx $_sha $_sig

	install_files "$_url_base" "$_file_list"

	# Remember the sets location which is used later for creating the
	# installurl(5) file and to tell the cgi server.
	if [[ -n $INSTALL_MIRROR ]]; then
		INSTALL_URL=$_http_proto://$INSTALL_MIRROR
	else
		# Remove the architecture and snaphots or version part.
		INSTALL_URL=${_url_base%/$ARCH}
		INSTALL_URL=${INSTALL_URL%@@(/$VNAME|/snapshots)}
	fi
}

# Ask for the path to the set files on an already mounted filesystem and start
# the set installation.
install_mounted_fs() {
	local _dir

	while :; do
		ask_until "Pathname to the sets? (or 'done')" "$SETDIR"
		[[ $resp == done ]] && return
		# Accept a valid /mnt2 or /mnt relative path.
		[[ -d /mnt2/$resp ]] && { _dir=/mnt2/$resp; break; }
		[[ -d /mnt/$resp ]] && { _dir=/mnt/$resp; break; }
		# Accept a valid absolute path.
		[[ -d /$resp ]] && { _dir=/$resp; break; }
		echo "The directory '$resp' does not exist."
		$AUTO && exit 1
	done

	install_files "file://$_dir" "$(ls $_dir/)"
}

# Install sets from CD-ROM drive $1.
install_cdrom() {
	local _drive=$1

	make_dev $_drive && mount_mnt2 $_drive || return

	install_mounted_fs
}

# Install sets from disk.
# Ask for the disk device containing the set files.
install_disk() {
	if ! ask_yn "Is the disk partition already mounted?"; then
		ask_which "disk" "contains the $MODE media" \
			'$(bsort $(get_dkdevs))' \
			'$(bsort $(rmel $ROOTDISK $(get_dkdevs)))'
		[[ $resp == done ]] && return 1

		# Ensure the device file exists and mount the fs on /mnt2.
		make_dev $resp && mount_mnt2 $resp || return
	fi

	install_mounted_fs
}

# Ask for the nfs share details, mount it and start the set installation.
install_nfs() {
	local _tcp

	# Get the IP address of the server.
	ask_until "Server IP address or hostname?" "$NFS_ADDR"
	NFS_ADDR=$resp

	# Get the server path to mount.
	ask_until "Filesystem on server to mount?" "$NFS_PATH"
	NFS_PATH=$resp

	# Determine use of TCP.
	ask_yn "Use TCP transport? (requires TCP-capable NFS server)" && _tcp=-T

	# Mount the server.
	mount_nfs $_tcp -o ro -R 5 $NFS_ADDR:$NFS_PATH /mnt2 || return

	install_mounted_fs
}

# Mount filesystem containing the set files on device $1, optionally ask the
# user for the device name.
mount_mnt2() {
	local _dev=$1 _opts _file=/tmp/i/parts.$1 _parts

	disklabel $_dev 2>/dev/null |
		sed -En '/swap|unused/d;/^  [a-p]: /p' >$_file
	_parts=$(sed 's/^  \(.\): .*/\1/' $_file)
	set -- $_parts
	(($# == 0)) && { echo "No filesystems found on $_dev."; return 1; }

	if isin "c" $_parts; then
		# Don't ask questions if 'c' contains a filesystem.
		resp=c
	elif (($# == 1)); then
		# Don't ask questions if there's only one choice.
		resp=$1
	else
		# Display partitions with filesystems and ask which to use.
		cat $_file
		ask_which "$_dev partition" "has the $MODE sets" \
			'$(disklabel '$_dev' 2>/dev/null |
			sed -En '\''/swap|unused/d;/^  ([a-p]): .*/s//\1/p'\'')'
		[[ $resp == done ]] && return 1
	fi

	# Always mount msdos partitions with -s to get lower case names.
	grep -q "^  $resp: .*MSDOS" $_file && _opts="-s"
	mount -o ro,$_opts /dev/$_dev$resp /mnt2
}


# ------------------------------------------------------------------------------
# Functions used in install.sh/upgrade.sh and it's associates
# ------------------------------------------------------------------------------

# Ask for terminal type if on console, otherwise ask for/set keyboard layout.
set_term() {
	local _layouts
	export TERM=${TERM:-${MDTERM:-vt220}}

	if [[ -n $CONSOLE ]]; then
		ask "Terminal type?" $TERM
		TERM=$resp
	else
		[[ -x /sbin/kbd ]] || return
		_layouts=$(bsort $(kbd -l | egrep -v "^(user|tables|encoding)"))
		while :; do
			ask "Choose your keyboard layout ('?' or 'L' for list)" default
			case $resp in
			[lL\?])		echo "Available layouts: $_layouts"
					;;
			default)	break
					;;
			*)		if kbd -q "$resp"; then
						echo $resp >/tmp/i/kbdtype
						break
					fi
					;;
			esac
		done
	fi
}

# Configure the network.
donetconfig() {
	local _dn _ns _f1 _f2 _f3

	configure_ifs
	v4_defroute

	# As dhclient will populate /etc/resolv.conf, a symbolic link to
	# /tmp/i/resolv.conf.shadow, mv any such file to /tmp/i/resolv.conf
	# so it will eventually be copied to /mnt/etc/resolv.conf and will
	# not in the meantime remove the user's ability to choose to use it
	# or not, during the rest of the install.
	if [[ -f /tmp/i/resolv.conf.shadow ]]; then
		mv /tmp/i/resolv.conf.shadow /tmp/i/resolv.conf
		# Get/store nameserver address(es) as a blank separated list
		# and the default fully qualified domain name from *first*
		# domain given on *last* search or domain statement.
		while read -r -- _f1 _f2 _f3; do
			[[ $_f1 == nameserver ]] && _ns="${_ns:+$_ns }$_f2"
			[[ $_f1 == @@(domain|search) ]] && _dn=$_f2
		done </tmp/i/resolv.conf
	fi

	# Get & apply fqdn to hostname. Don't ask if there's only one configured
	# interface and if it's managed by dhclient and if the domain name is
	# configured via dhclient too.
	resp="${_dn:-$(get_fqdn)}"
	if ifconfig dhcp >/dev/null 2>&1 && [[ $NIFS == 1 && -n $_dn ]]; then
		echo "Using DNS domainname $resp"
	else
		ask "DNS domain name? (e.g. 'bar.com')" "$resp"
	fi
	hostname "$(hostname -s).$resp"

	# Get & add nameservers to /tmp/i/resolv.conf. Don't ask if there's only
	# one configured interface and if it's managed by dhclient and if the
	# nameserver is configured via dhclient too.
	resp="${_ns:-none}"
	if ifconfig dhcp >/dev/null 2>&1 && [[ $NIFS == 1 && -n $_ns ]]; then
		echo "Using DNS nameservers at $resp"
	else
		ask "DNS nameservers? (IP address list or 'none')" "$resp"
	fi

	# Construct appropriate resolv.conf.
	if [[ $resp != none ]]; then
		echo "lookup file bind" >/tmp/i/resolv.conf
		for _ns in $resp; do
			echo "nameserver $_ns" >>/tmp/i/resolv.conf
		done
		cp /tmp/i/resolv.conf /tmp/i/resolv.conf.shadow
	fi
}

# Ask user about daemon startup on boot, X Window usage and console setup.
# The actual configuration is done later in apply().
questions() {
	local _d _cdef=no

	ask_yn "Start sshd(8) by default?" yes
	START_SSHD=$resp

	APERTURE=
	resp=
	START_XDM=
	if [[ -n $(scan_dmesg '/^wsdisplay[0-9]* /s/ .*//p') ]]; then
		if [[ -n $(scan_dmesg '/^[a-z]*[01]: aperture needed/p') ]]; then
			ask_yn "Do you expect to run the X Window System?" yes &&
				APERTURE=$MDXAPERTURE
		fi
		if [[ -n $MDXDM && $resp != n ]]; then
			ask_yn "Do you want the X Window System to be started by xenodm(1)?"
			START_XDM=$resp
		fi
	fi

	if [[ -n $CDEV ]]; then
		_d=${CPROM:-$CDEV}
		[[ -n $CONSOLE ]] && _cdef=yes
		ask_yn "Change the default console to $_d?" $_cdef
		DEFCONS=$resp
		if [[ $resp == y ]]; then
			ask_which "speed" "should $_d use" \
				"9600 19200 38400 57600 115200" $CSPEED
			case $resp in
			done)	DEFCONS=n;;
			*)	CSPEED=$resp;;
			esac
		fi
	fi
}

# Gather information for setting up the user later in do_install().
user_setup() {
	local _q="Setup a user? (enter a lower-case loginname, or 'no')"

	while :; do
		ask "$_q" no
		case $resp in
		n|no)	return
			;;
		y|yes)	_q="No really, what is the lower-case loginname, or 'no'?"
			continue
			;;
		root|daemon|operator|bin|build|sshd|www|nobody|ftp)
			;;
		[a-z]*([a-z0-9_]))
			((${#resp} <= 31)) && break
			;;
		esac
		echo "$resp is not a useable loginname."
	done
	ADMIN=$resp
	while :; do
		ask "Full name for user $ADMIN?" $ADMIN
		case $resp in
		*[:\&,]*)
			echo "':', '&' or ',' are not allowed."
			;;
		*)
			((${#resp} <= 100)) && break
			echo "Too long."
			;;
		esac
	done
	ADMIN_NAME=$resp

	ask_password "Password for user $ADMIN?"
	ADMIN_PASS=$_password

	ADMIN_KEY=
	$AUTO && ask "Public ssh key for user $ADMIN" none &&
		[[ $resp != none ]] && ADMIN_KEY=$resp
}

# Ask user whether or not to allow logins to root in case sshd(8) is enabled.
# If no user is setup, show a hint to enable root logins, but warn about risks
# of doing so.
ask_root_sshd() {
	typeset -l _resp

	[[ $START_SSHD == y ]] || return

	if [[ -z $ADMIN ]]; then
		echo "Since no user was setup, root logins via sshd(8) might be useful."
	fi
	echo "WARNING: root is targeted by password guessing attacks, pubkeys are safer."
	while :; do
		ask "Allow root ssh login? (yes, no, prohibit-password)" no
		_resp=$resp
		case $_resp in
		y|yes)	SSHD_ENABLEROOT=yes
			;;
		n|no)	SSHD_ENABLEROOT=no
			;;
		w|p|without-password|prohibit-password)
			SSHD_ENABLEROOT=prohibit-password
			;;
		*)	echo "'$resp' is not a valid choice."
			$AUTO && exit 1
			continue
			;;
		esac
		break
	done
}

# Set TZ variable based on zonefile $1 and user selection.
set_timezone() {
	local _zonefile=$1 _zonepath _zsed _zoneroot=/usr/share/zoneinfo

	# If the timezone file is not available,
	# return immediately.
	[[ ! -f $_zonefile ]] && return

	# If configured in a previous call, return immediately.
	[[ -n $TZ ]] && return

	if [[ -h /mnt/etc/localtime ]]; then
		TZ=$(ls -l /mnt/etc/localtime 2>/dev/null)
		TZ=${TZ#*${_zoneroot#/mnt}/}
	fi

	wait_cgiinfo
	isin "$CGI_TZ" $(<$_zonefile) && TZ=$CGI_TZ

	# If neither the base or HTTP_LIST gave a hint, and this is the
	# early question, give up, and ask after the sets are installed.
	[[ $_zonefile == /var/tzlist && -z $TZ ]] && return

	while :; do
		ask "What timezone are you in? ('?' for list)" "$TZ"
		_zonepath=${resp%%*(/)}
		case $_zonepath in
		"")	continue
			;;
		"?")	grep -v /. $_zonefile | show_cols
			continue
			;;
		esac

		while isin "$_zonepath/" $(<$_zonefile); do
			ask "What sub-timezone of '$_zonepath' are you in? ('?' for list)"
			_zsed=$(echo $_zonepath/ | sed 's,/,\\/,g')
			resp=${resp%%*(/)}
			case $resp in
			"")	;;
			"?")	sed -n "/^$_zsed/{s/$_zsed//;/\/./!p;}" $_zonefile | show_cols;;
			*)	_zonepath=$_zonepath/$resp;;
			esac
		done

		if isin "$_zonepath" $(<$_zonefile); then
			TZ=${_zonepath#$_zoneroot}
			return
		fi

		echo -n "'${_zonepath}'"
		echo " is not a valid timezone on this system."
	done
}

# Determine if the supplied disk is a potential root disk, by:
# - Check the disklabel if there is an 'a' partition of type 4.2BSD
# - Mount the partition (read-only) and look for typical root filesystem layout
is_rootdisk() {
	local _d=$1 _rc=1

	(
		make_dev $_d
		if disklabel $_d | grep -q '^  a: .*4\.2BSD ' &&
			mount -t ffs -r /dev/${_d}a /mnt; then
			ls -d /mnt/{bin,dev,etc,home,mnt,root,sbin,tmp,usr,var}
			_rc=$?
			umount -f /mnt
		fi
		rm -f /dev/{r,}$_d?
		return $_rc
	) >/dev/null 2>&1
}

# Get global root information. ie. ROOTDISK, ROOTDEV and SWAPDEV.
get_rootinfo() {
	local _default=$(get_dkdevs)
	local _q="Which disk is the root disk? ('?' for details)"

	while :; do
		echo "Available disks are: $(get_dkdevs | sed 's/^$/none/')."
		_ask "$_q" $_default || continue
		case $resp in
		"?")	diskinfo $(get_dkdevs);;
		'')	;;
		*)	if isin "$resp" $(get_dkdevs); then
				[[ $MODE == install ]] && break
				is_rootdisk "$resp" && break
				echo "$resp is not a valid root disk."
				_default="$(rmel "$resp" $_default) $resp"
			else
				echo "no such disk"
			fi
			;;
		esac
		$AUTO && exit 1
	done
	log_answers "$_q" "$resp"

	make_dev $resp || exit

	ROOTDISK=$resp
	ROOTDEV=${ROOTDISK}a
	SWAPDEV=${ROOTDISK}b
}

# Parse and "unpack" a hostname.if(5) line given as positional parameters.
# Fill the _cmds array with the resulting interface configuration commands.
parse_hn_line() {
	local _af=0 _name=1 _mask=2 _bc=3 _prefix=2 _c _cmd _prev _daddr
	local _has_dhclient=false _has_inet6=false
	set -A _c -- "$@@"
	set -o noglob

	ifconfig $_if inet6 >/dev/null 2>&1 && _has_inet6=true
	[[ -x /sbin/dhclient ]] && _has_dhclient=true

	case ${_c[_af]} in
	''|*([[:blank:]])'#'*)
		return
		;;
	inet)	((${#_c[*]} > 1)) || return
		[[ ${_c[_name]} == alias ]] && _mask=3 _bc=4
		[[ -n ${_c[_mask]} ]] && _c[_mask]="netmask ${_c[_mask]}"
		if [[ -n ${_c[_bc]} ]]; then
			_c[_bc]="broadcast ${_c[_bc]}"
			[[ ${_c[_bc]} == *NONE ]] && _c[_bc]=
		fi
		_cmds[${#_cmds[*]}]="ifconfig $_if ${_c[@@]}"
		;;
	inet6)	! $_has_inet6 && return
		((${#_c[*]} > 1)) || return
		if [[ ${_c[_name]} == autoconf ]]; then
			_cmds[${#_cmds[*]}]="ifconfig $_if ${_c[@@]}"
			V6_AUTOCONF=true
			return
		fi
		[[ ${_c[_name]} == alias ]] && _prefix=3
		[[ -n ${_c[_prefix]} ]] && _c[_prefix]="prefixlen ${_c[_prefix]}"
		_cmds[${#_cmds[*]}]="ifconfig $_if ${_c[@@]}"
		;;
	dest)	((${#_c[*]} == 2)) && _daddr=${_c[1]} || return
		! $_has_inet6 && [[ $_daddr == @@(*:*) ]] && return
		_prev=$((${#_cmds[*]} - 1))
		((_prev >= 0)) || return
		set -A _c -- ${_cmds[_prev]}
		_name=3
		[[ ${_c[_name]} == alias ]] && _name=4
		_c[_name]="${_c[_name]} $_daddr"
		_cmds[$_prev]="${_c[@@]}"
		;;
	dhcp)	! $_has_dhclient && return
		_c[0]=
		_cmds[${#_cmds[*]}]="ifconfig $_if ${_c[@@]} down;dhclient $_if"
		V4_DHCPCONF=true
		;;
	rtsol)	# XXX Support the rtsol keyword for some time to enable a smooth
		# XXX transition to autoconf.
		_c[0]=
		_cmds[${#_cmds[*]}]="ifconfig $_if ${_c[@@]} up"
		_cmds[${#_cmds[*]}]="ifconfig $_if inet6 autoconf"
		V6_AUTOCONF=true
		;;
	'!'*|bridge)
		# Skip shell commands and bridge in the installer.
		return
		;;
	*)	_cmds[${#_cmds[*]}]="ifconfig $_if ${_c[@@]}"
		;;
	esac
	unset _c
	set +o noglob
}

# Start interface using the on-disk hostname.if file passed as argument $1.
# Much of this is gratuitously stolen from /etc/netstart.
ifstart () {
	local _hn=$1 _if=${1#/mnt/etc/hostname.} _cmds _i=0 _line
	set -A _cmds

	((NIFS++))

	# Parse the hostname.if(5) file and fill _cmds array with interface
	# configuration commands.
	set -o noglob
	while IFS= read -- _line; do
		parse_hn_line $_line
	done <$_hn

	# Apply the interface configuration commands stored in _cmds array.
	while ((_i < ${#_cmds[*]})); do
		eval "${_cmds[_i]}"
		((_i++))
	done
	unset _cmds
	set +o noglob
}

# Configure the network during upgrade based on the on-disk configuration.
enable_network() {
	local _f _gw _hn _if _trunks _svlans _vlans

	# Copy any network configuration files.
	for _f in dhclient.conf resolv.conf resolv.conf.tail; do
		if [[ -f /mnt/etc/$_f ]]; then
			cp /mnt/etc/$_f /etc/$_f
		fi
	done

	# Create a minimal hosts file.
	echo "127.0.0.1\tlocalhost" >/tmp/i/hosts
	echo "::1\t\tlocalhost" >>/tmp/i/hosts

	# Set the address for the loopback interface. Bringing the
	# interface up, automatically invokes the IPv6 address ::1.
	ifconfig lo0 inet 127.0.0.1/8

	# Configure all of the non-loopback interfaces which we know about.
	# Refer to hostname.if(5)
	for _hn in /mnt/etc/hostname.*; do
		# Strip off prefix to get interface name.
		_if=${_hn#/mnt/etc/hostname.}
		if isin "${_if%%+([0-9])}" $(ifconfig -C); then
			# Dynamic interfaces must be done later.
			case ${_if%%+([0-9])} in
			trunk)	_trunks="$_trunks $_hn";;
			svlan)	_svlans="$_svlans $_hn";;
			vlan)	_vlans="$_vlans $_hn";;
			esac
		else
			# 'Real' interfaces (if available) are done now.
			ifconfig $_if >/dev/null 2>&1 && ifstart $_hn
		fi
	done
	# Configure any dynamic interfaces now that 'real' ones are up.
	# ORDER IS IMPORTANT! (see /etc/netstart).
	for _hn in $_trunks $_svlans $_vlans; do
		ifstart $_hn
	done

	# /mnt/etc/mygate, if it exists, contains the address(es) of my
	# default gateway(s). Use for ipv4 if no interfaces configured via
	# dhcp. Use for ipv6 if no interfaces configured via autoconf.
	! $V4_DHCPCONF && stripcom /mnt/etc/mygate |
	while read _gw; do
		[[ $_gw == @@(*:*) ]] && continue
		route -qn add -host default $_gw && break
	done
	! $V6_AUTOCONF && stripcom /mnt/etc/mygate |
	while read _gw; do
		[[ $_gw == !(*:*) ]] && continue
		route -qn add -host -inet6 default $_gw && break
	done

	route -qn add -net 127 127.0.0.1 -reject >/dev/null
}

# Fetch the list of mirror servers and installer choices from previous runs if
# available from ftplist.cgi. Start the ftp process in the background, but kill
# it if it takes longer than 12 seconds.
start_cgiinfo() {
	# If no networks are configured, we do not need the httplist file.
	((NIFS < 1)) && return

	# Ensure proper name resolution in case there's no dns yet.
	add_hostent 129.128.5.191 ftp.openbsd.org

	# Make sure the ftp subshell gets its own process group.
	set -m
	(
		unpriv2 ftp -w 15 -Vao - \
			"$HTTP_PROTO://ftp.openbsd.org/cgi-bin/ftplist.cgi?dbversion=1" \
			2>/dev/null >$CGI_INFO

		# Remember finish time for adjusting the received timestamp.
		echo -n $SECONDS >$HTTP_SEC
		feed_random
	) & CGIPID=$!
	set +m

	# If the ftp process takes more than 12 seconds, kill it.
	# XXX We are relying on the pid space not randomly biting us.
	# XXX ftp could terminate early, and the pid could be reused.
	(sleep 12; kill -INT -$CGIPID >/dev/null 2>&1) &
}

# Create a skeletal but useful /etc/fstab from /tmp/i/fstab by stripping all
# comment lines and dropping all filesystems which
#
# 1) can't be mounted (no mount_* command is found),
# 2) have 'xx' in the option field (usually /altroot),
# 3) have 'noauto' in the option field,
# 4) are nfs (since name resolution may not be present),
# 5) are on a vnd device.
#
# In addition,
#
# 1) delete 'softdep' options (no soft updates in ramdisk kernels),
# 2) mount non-ffs filesystems read only,
# 3) prepend '/mnt' to all mount points,
# 4) delete any trailing '/' from the mount point (e.g. root),
#
# If no /etc/fstab is created, do not proceed with install/upgrade.
munge_fstab() {
	local _dev _mp _fstype _opt _rest

	while read _dev _mp _fstype _opt _rest; do
		# Drop irrelevant lines and filesystems.
		[[ $_dev == @@(/dev/vnd*|\#*) ||
			$_fstype == nfs ||
			! -f /sbin/mount_$_fstype ||
			$_opt == *noauto* ||
			$_opt == *xx* ]] && continue

		# Remove any softdep options, as soft updates are not
		# available in the ramdisk kernels.
		_opt=$(echo $_opt | sed 's/softdep//')

		# Change read-only ffs to read-write since we'll potentially
		# write to these filesystems.
		# Mount non-ffs filesystems read only.
		if [[ $_fstype == ffs ]]; then
			_opt=$(echo $_opt | sed 's/[[:<:]]ro[[:>:]]/rw/')
		else
			_opt=$(echo $_opt | sed 's/[[:<:]]rw[[:>:]]/ro/')
		fi

		# Write fs entry in fstab.
		# 1) prepend '/mnt' to the mount point.
		# 2) remove a trailing '/' from the mount point (e.g. root).
		echo $_dev /mnt${_mp%/} $_fstype $_opt $_rest

	done </tmp/i/fstab >/etc/fstab

	# If no /etc/fstab was created, we have nowhere to $MODE to.
	if [[ ! -s /etc/fstab ]]; then
		echo "Unable to create valid /etc/fstab."
		exit
	fi
}

# Preen all filesystems in /etc/fstab that have a /sbin/fsck_XXX and a
# fs_passno > 0, showing individual results, but skipping $ROOTDEV. This was
# already fsck'ed successfully.
#
# Exit if any fsck's fail (but do them all before exiting!).
check_fs() {
	local _dev _dn _mp _fstype _rest _fail _f _passno

	ask_yn "Force checking of clean non-root filesystems?" && _f=f

	while read _dev _mp _fstype _rest _rest _passno _rest; do
		_dn=$(get_dkdev_name "$_dev")
		[[ $ROOTDEV == @@(${_dev#/dev/}|$_dn${_dev##*.}) ]] && continue
		[[ -f /sbin/fsck_$_fstype ]] || continue
		# Make sure device exists before fsck'ing it.
		make_dev "$_dn" || continue
		((_passno > 0)) || continue
		echo -n "fsck -${_f}p $_dev..."
		if ! fsck -${_f}p $_dev >/dev/null 2>&1; then
			echo "FAILED. You must fsck $_dev manually."
			_fail=y
		else
			echo "OK."
		fi
	done </etc/fstab

	[[ -n $_fail ]] && exit
}

# Must mount filesystems manually, one at a time, so we can make sure the mount
# points exist.
mount_fs() {
	local _async=$1 _dev _mp _fstype _opt _rest _msg _fail

	while read _dev _mp _fstype _opt _rest; do
		# If not the root filesystem, make sure the mount
		# point is present.
		[[ $_mp == /mnt ]] || mkdir -p $_mp

		# Mount the filesystem. Remember any failure.
		_msg=$(mount -v -t $_fstype $_async -o $_opt $_dev $_mp) ||
			_fail="$_fail\n$_mp ($_dev)"
		echo $_msg | sed 's/, ctime=[^,)]*//'
	done </etc/fstab

	if [[ -n $_fail ]]; then
		# One or more mounts failed. Continue or abort?
		echo "\nWARNING! The following filesystems were not properly mounted:$_fail"
		ask_yn "Continue anyway?" || exit
	fi
}

# Feed the random pool some entropy before we read from it.
feed_random() {
	(dmesg; cat $CGI_INFO /*.conf; sysctl; route -n show; df;
		ifconfig -A; hostname) >/dev/random 2>&1
	if [[ -e /mnt/var/db/host.random ]]; then
		dd if=/mnt/var/db/host.random of=/dev/random bs=65536 count=1 \
			status=none
	fi
}

# Ask the user for locations of sets, and then install whatever sets the user
# selects from that location. Repeat as many times as the user needs to get all
# desired sets.
install_sets() {
	local _cddevs=$(get_cddevs) _d _im _locs="disk http" _src

	echo

	# Set default location to method recorded last time.
	_d=$CGI_METHOD

	# Set default location to HTTP in case we netbooted.
	ifconfig netboot >/dev/null 2>&1 && : ${_d:=http}

	# Set default location to HTTP if installurl(5) exists.
	[[ -s /mnt/etc/installurl ]] && _d=http

	# Set default location to the first cdrom device if any are found.
	[[ -n $_cddevs ]] && : ${_d:=cd0}

	# Add NFS to set locations if the boot kernel supports it.
	[[ -x /sbin/mount_nfs ]] && _locs="$_locs nfs"

	# In case none of the above applied, set HTTP as default location.
	: ${_d:=http}

	# If the default location set so far is not one of the cdrom devices or
	# is not in the list of valid locations, set a sane default.
	if ! isin "$_d" $_cddevs $_locs; then
		for _src in http $_cddevs nfs disk; do
			isin "$_src" $_cddevs $_locs && _d=$_src && break
		done
	fi

	echo "Let's $MODE the sets!"
	while :; do
		# Get list of cdroms again in case one just got plugged in.
		_cddevs=$(get_cddevs)
		umount -f /mnt2 >/dev/null 2>&1

		ask "Location of sets? (${_cddevs:+$_cddevs }$_locs or 'done')" "$_d"
		case $resp in
		done)	sane_install && return
			;;
		[cC]*)	if [[ -n $_cddevs ]]; then
				set -- $_cddevs
				[[ $resp == [cC]?([dD]) ]] && resp=$1
				_im=$resp
				install_cdrom $resp && INSTALL_METHOD=$_im
			fi
			;;
		[dD]*)	install_disk && INSTALL_METHOD=disk
			;;
		[hH]*)	isin http $_locs && install_http && INSTALL_METHOD=http
			;;
		[nN]*)	isin nfs $_locs && install_nfs && INSTALL_METHOD=nfs
			;;
		*)	$AUTO && err_exit "'$resp' is not a valid choice."
			;;
		esac

		# Preserve the selected install source selection.
		[[ -n $INSTALL_METHOD ]] && _d=$INSTALL_METHOD

		# Set default to 'done' to leave the while-loop.
		sane_install quiet || $AUTO && _d=done
	done
}

# Apply configuration settings based on the previously gathered information.
apply() {
	if [[ $START_SSHD == n ]]; then
		echo "sshd_flags=NO" >>/mnt/etc/rc.conf.local
	elif [[ -n $SSHD_ENABLEROOT ]]; then
		# Only change sshd_config if the user choice is not the default.
		if ! grep -q "^#PermitRootLogin $SSHD_ENABLEROOT\$" \
				/mnt/etc/ssh/sshd_config; then
			sed -i "s/^#\(PermitRootLogin\) .*/\1 $SSHD_ENABLEROOT/" \
				/mnt/etc/ssh/sshd_config
		fi
	fi

	[[ -n $APERTURE ]] &&
		echo "machdep.allowaperture=$APERTURE # See xf86(4)" \
			>>/mnt/etc/sysctl.conf

	[[ $START_XDM == y && -x /mnt/usr/X11R6/bin/xenodm ]] &&
		echo "xenodm_flags=" >>/mnt/etc/rc.conf.local

	if [[ $DEFCONS == y ]]; then
		cp /mnt/etc/ttys /tmp/i/ttys
		sed	-e "/^$CTTY/s/std.9600/std.${CSPEED}/" \
			-e "/^$CTTY/s/unknown/vt220	/" \
			-e "/$CTTY/s/off.*/on secure/" /tmp/i/ttys >/mnt/etc/ttys
		[[ -n $CPROM ]] &&
			echo "stty $CPROM $CSPEED\nset tty $CPROM" \
				>>/mnt/etc/boot.conf
	fi

	ln -sf /usr/share/zoneinfo/$TZ /mnt/etc/localtime
}

# Return string suitable for the encrypted password field in master.passwd.
#
# 1) Without argument, return a single '*'.
# 2) Return argument unchanged if it looks like a encrypted password string
#    or if it consists of just 13 asterisks.
# 3) Otherwise return encrypted password string.
#
encr_pwd() {
	local _p=$1

	if [[ -z $_p ]]; then
		echo '*'
	elif [[ $_p == \$2?\$[0-9][0-9]\$* && ${#_p} > 40 ||
		$_p == '*************' ]]; then
		echo "$_p"
	else
		encrypt -b a -- "$_p"
	fi
}

# Store entropy for the next boot.
store_random() {
	dd if=/dev/random of=/mnt/var/db/host.random bs=65536 count=1 \
		status=none
	dd if=/dev/random of=/mnt/etc/random.seed bs=512 count=1 status=none
	chmod 600 /mnt/var/db/host.random /mnt/etc/random.seed
}

# Final steps common for installs and upgrades.
finish_up() {
	local _dev _mp _fstype _rest _d

	# Mount all known swap partitions.  This gives systems with little
	# memory a better chance at running 'MAKEDEV all'.
	if [[ -x /mnt/sbin/swapctl ]]; then
		/mnt/sbin/swapctl -a /dev/$SWAPDEV >/dev/null 2>&1
		# Can't do chmod && swapctl -A because devices are not yet
		# created on install'ed systems. On upgrade'ed system there
		# is a small chance the device does not exist on the ramdisk
		# and will thus not get mounted.
		while read _dev _mp _fstype _rest; do
			[[ $_fstype == swap ]] &&
				/mnt/sbin/swapctl -a $_dev >/dev/null 2>&1
		done </mnt/etc/fstab
	fi

	# Create /etc/installurl if it does not yet exist.
	if [[ -n $INSTALL_URL && ! -f /mnt/etc/installurl ]]; then
		echo "$INSTALL_URL" >/mnt/etc/installurl
	fi

	echo -n "Making all device nodes..."
	(cd /mnt/dev; sh MAKEDEV all
		# Make sure any devices we found during probe are created in the
		# installed system.
		for _dev in $(get_dkdevs) $(get_cddevs); do
			sh MAKEDEV $_dev
		done
	)
	echo "done."

	# We may run some programs in chroot, and some of them might be
	# dynamic.  That is highly discouraged, but let us play it safe.
	rm -f /mnt/var/run/ld.so.hints

	# Conditionally create /usr/{src,obj,xobj} directories and set
	# proper ownership and permissions during install.
	if [[ $MODE == install ]]; then
		mkdir -p /mnt/usr/{src,{,x}obj} && (
			cd /mnt/usr
			chmod 770 {,x}obj
			chown build:wobj {,x}obj
			chmod 775 src
			chown root:wsrc src
		)
	fi

	[[ -x /mnt/$MODE.site ]] && chroot /mnt /$MODE.site

	# In case this is a softraid device, make sure all underlying
	# device nodes exist before installing boot-blocks on disk.
	make_dev $(bioctl $ROOTDISK 2>/dev/null | sed -n 's/.*<\(.*\)>$/\1/p')
	md_installboot $ROOTDISK

	chmod og-rwx /mnt/bsd{,.mp,.rd} 2>/dev/null
	if [[ -f /mnt/bsd.mp ]] && ((NCPU > 1)); then
		echo "Multiprocessor machine; using bsd.mp instead of bsd."
		mv /mnt/bsd /mnt/bsd.sp 2>/dev/null
		mv /mnt/bsd.mp /mnt/bsd
	fi

	# Ensure that sysmerge in batch mode is run on reboot.
	[[ $MODE == upgrade ]] &&
		echo "/usr/sbin/sysmerge -b" >>/mnt/etc/rc.sysmerge

	# Ensure that fw_update is run on reboot.
	echo "/usr/sbin/fw_update -v" >>/mnt/etc/rc.firsttime

	# Email installer questions and their answers to root on next boot.
	prep_root_mail /tmp/i/$MODE.resp "$(hostname) $MODE response file"

	# Store entropy for the next boot.
	store_random

	# Pat on the back.
	cat <<__EOT

CONGRATULATIONS! Your OpenBSD $MODE has been successfully completed!
To boot the new system, enter 'reboot' at the command prompt.
__EOT
	[[ $MODE == install ]] && cat <<__EOT
When you login to your new system the first time, please read your mail
using the 'mail' command.
__EOT

	md_congrats
	$AUTO && >/tmp/ai/ai.done
}

do_autoinstall() {
	rm -f /tmp/ai/ai.done

	echo "Performing non-interactive $AI_MODE..."
	/$AI_MODE -af /tmp/ai/ai.$AI_MODE.conf 2>&1 </dev/null |
		sed "s/^.*$(echo '\r')//;w/tmp/ai/ai.log"

	[[ -f /tmp/ai/ai.done ]] || err_exit "failed; check /tmp/ai/ai.log"

	# Email autoinstall protocol to root on next boot.
	prep_root_mail /tmp/ai/ai.log "$(hostname) $AI_MODE log"

	exec reboot
}

do_install() {
	local _rootkey _rootpass

	# Ask for and set the system hostname and add the hostname specific
	# siteXX set.
	while :; do
		ask_until "System hostname? (short form, e.g. 'foo')" \
			"$(hostname -s)"
		[[ $resp != *+([[:cntrl:]]|[[:space:]])* ]] && break
		echo "Invalid hostname."
		$AUTO && exit 1
	done
	[[ ${resp%%.*} != $(hostname -s) ]] && hostname "$resp"
	THESETS="$THESETS site$VERSION-$(hostname -s).tgz"

	echo

	# Configure the network.
	donetconfig

	# If there's network connectivity, fetch list of mirror servers and
	# installer choices from previous runs.
	((NIFS)) && start_cgiinfo

	echo

	while :; do
		ask_password "Password for root account?"
		_rootpass="$_password"
		[[ -n "$_password" ]] && break
		echo "The root password must be set."
	done

	# Ask for the root user public ssh key during autoinstall.
	_rootkey=
	if $AUTO; then
		ask "Public ssh key for root account?" none
		[[ $resp != none ]] && _rootkey=$resp
	fi

	# Ask user about daemon startup on boot, X Window usage and console
	# setup.
	questions

	# Gather information for setting up the initial user account.
	user_setup
	ask_root_sshd

	# Set TZ variable based on zonefile and user selection.
	set_timezone /var/tzlist

	echo

	# Get information about ROOTDISK, etc.
	get_rootinfo

	DISKS_DONE=
	FSENT=

	# Remove traces of previous install attempt.
	rm -f /tmp/i/fstab*

	# Configure the disk(s).
	while :; do
		# Always do ROOTDISK first, and repeat until it is configured.
		if ! isin "$ROOTDISK" $DISKS_DONE; then
			resp=$ROOTDISK
			rm -f /tmp/i/fstab
		else
			# Force the user to think and type in a disk name by
			# making 'done' the default choice.
			ask_which "disk" "do you wish to initialize" \
				'$(get_dkdevs_uninitialized)' done
			[[ $resp == done ]] && break
		fi
		_disk=$resp
		configure_disk $_disk || continue
		DISKS_DONE=$(addel $_disk $DISKS_DONE)
	done

	# Write fstab entries to fstab in mount point alphabetic order
	# to enforce a rational mount order.
	for _mp in $(bsort $FSENT); do
		_pp=${_mp##*!}
		_mp=${_mp%!*}
		echo -n "$_pp $_mp ffs rw"

		# Only '/' is neither nodev nor nosuid. i.e. it can obviously
		# *always* contain devices or setuid programs.
		[[ $_mp == / ]] && { echo " 1 1"; continue; }

		# Every other mounted filesystem is nodev. If the user chooses
		# to mount /dev as a separate filesystem, then on the user's
		# head be it.
		echo -n ",nodev"

		# The only directories that the install puts suid binaries into
		# (as of 3.2) are:
		#
		# /sbin
		# /usr/bin
		# /usr/sbin
		# /usr/libexec
		# /usr/libexec/auth
		# /usr/X11R6/bin
		#
		# and ports and users can do who knows what to /usr/local and
		# sub directories thereof.
		#
		# So try to ensure that only filesystems that are mounted at
		# or above these directories can contain suid programs. In the
		# case of /usr/libexec, give blanket permission for
		# subdirectories.
		case $_mp in
		/sbin|/usr)			;;
		/usr/bin|/usr/sbin)		;;
		/usr/libexec|/usr/libexec/*)	;;
		/usr/local|/usr/local/*)	;;
		/usr/X11R6|/usr/X11R6/bin)	;;
		*)	echo -n ",nosuid"	;;
		esac
		echo " 1 2"
	done >>/tmp/i/fstab

	# Create a skeletal /etc/fstab which is usable for the installation
	# process.
	munge_fstab

	# Use async options for faster mounts of the filesystems.
	mount_fs "-o async"

	# Feed the random pool some entropy before we read from it.
	feed_random

	# Ask the user for locations, and install whatever sets the user
	# selected.
	install_sets

	# Set 'wxallowed' mount option for the filesystem /usr/local resides on.
	_mp=$(df /mnt/usr/local | sed '$!d')
	_mp=${_mp##*/mnt}
	sed -i "s#\(${_mp:-/} ffs rw\)#\1,wxallowed#" /tmp/i/fstab

	# If we did not succeed at setting TZ yet, we try again
	# using the timezone names extracted from the base set.
	if [[ -z $TZ ]]; then
		(cd /mnt/usr/share/zoneinfo
			ls -1dF $(tar cvf /dev/null [A-Za-y]*) >/mnt/tmp/tzlist )
		echo
		set_timezone /mnt/tmp/tzlist
		rm -f /mnt/tmp/tzlist
	fi

	# If we got a timestamp from the cgi server, and that time diffs by more
	# than 120 seconds, ask if the user wants to adjust the time.
	if _time=$(http_time) && _now=$(date +%s) &&
		(( _now - _time > 120 || _time - _now > 120 )); then
		_tz=/mnt/usr/share/zoneinfo/$TZ
		if ask_yn "Time appears wrong.  Set to '$(TZ=$_tz date -r "$(http_time)")'?" yes; then
			# We do not need to specify TZ below since both date
			# invocations use the same one.
			date $(date -r "$(http_time)" "+%Y%m%d%H%M.%S") >/dev/null
			# N.B. This will screw up SECONDS.
		fi
	fi

	# If we managed to talk to the cgi server before, tell it what
	# location we used... so it can perform magic next time.
	if [[ -s $HTTP_LIST ]]; then
		_i=${INSTALL_URL:+install=$INSTALL_URL&}
		_i=$_i${TZ:+TZ=$TZ&}
		_i=$_i${INSTALL_METHOD:+method=$INSTALL_METHOD}
		_i=${_i%&}
		[[ -n $_i ]] && unpriv2 ftp -w 15 -Vao - \
			"$HTTP_PROTO://ftp.openbsd.org/cgi-bin/ftpinstall.cgi?dbversion=1&$_i" \
			 >/dev/null 2>&1 &
	fi

	# Ensure an enabled console has the correct speed in /etc/ttys.
	sed "/^console.*on.*secure.*$/s/std\.[0-9]*/std.$(stty speed </dev/console)/" \
		/mnt/etc/ttys >/tmp/i/ttys
	mv /tmp/i/ttys /mnt/etc/ttys

	echo -n "Saving configuration files..."

	# Save any leases obtained during install.
	(cd /var/db; for _f in dhclient.leases.*; do
		[[ -f $_f ]] && mv $_f /mnt/var/db/.
	done)

	# Move configuration files from /tmp/i/ to /mnt/etc.
	hostname >/tmp/i/myname

	# Append entries to installed hosts file, changing '1.2.3.4 hostname'
	# to '1.2.3.4 hostname.$FQDN hostname'. Leave untouched lines containing
	# domain information or aliases. These are lines the user added/changed
	# manually.

	# Add common entries.
	echo "127.0.0.1\tlocalhost" >/mnt/etc/hosts
	echo "::1\t\tlocalhost" >>/mnt/etc/hosts

	# Note we may have no hosts file if no interfaces were configured.
	if [[ -f /tmp/i/hosts ]]; then
		# Remove the entry for ftp.openbsd.org
		sed -i '/^129\.128\.5\.191 /d' /tmp/i/hosts
		_dn=$(get_fqdn)
		while read _addr _hn _aliases; do
			if [[ -n $_aliases || $_hn != ${_hn%%.*} || -z $_dn ]]; then
				echo "$_addr\t$_hn $_aliases"
			else
				echo "$_addr\t$_hn.$_dn $_hn"
			fi
		done </tmp/i/hosts >>/mnt/etc/hosts
		rm /tmp/i/hosts
	fi

	# Append dhclient.conf to installed dhclient.conf.
	_f=dhclient.conf
	[[ -f /tmp/i/$_f ]] && { cat /tmp/i/$_f >>/mnt/etc/$_f; rm /tmp/i/$_f; }

	# Possible files to copy from /tmp/i/: fstab hostname.* kbdtype mygate
	#     myname ttys boot.conf resolv.conf sysctl.conf resolv.conf.tail
	# Save only non-empty (-s) regular (-f) files.
	(cd /tmp/i; for _f in fstab hostname* kbdtype my* ttys *.conf *.tail; do
		[[ -f $_f && -s $_f ]] && mv $_f /mnt/etc/.
	done)

	echo "done."

	# Apply configuration settings based on information from questions().
	apply

	# Create user account based on information from user_setup().
	if [[ -n $ADMIN ]]; then
		_encr=$(encr_pwd "$ADMIN_PASS")
		_home=/home/$ADMIN
		uline="${ADMIN}:${_encr}:1000:1000:staff:0:0:${ADMIN_NAME}:$_home:/bin/ksh"
		echo "$uline" >>/mnt/etc/master.passwd
		echo "${ADMIN}:*:1000:" >>/mnt/etc/group
		echo $ADMIN >/mnt/root/.forward

		_home=/mnt$_home
		mkdir -p $_home
		(cd /mnt/etc/skel; pax -rw -k -pe . $_home)
		(umask 077 && sed "s,^To: root\$,To: ${ADMIN_NAME} <${ADMIN}>," \
			/mnt/var/mail/root >/mnt/var/mail/$ADMIN )
		chown -R 1000:1000 $_home /mnt/var/mail/$ADMIN
		sed -i -e "s@@^wheel:.:0:root\$@@wheel:\*:0:root,${ADMIN}@@" \
			/mnt/etc/group 2>/dev/null

		# During autoinstall, add public ssh key to authorized_keys.
		[[ -n "$ADMIN_KEY" ]] &&
			print -r -- "$ADMIN_KEY" >>$_home/.ssh/authorized_keys
	fi

	# Store root password and rebuild password database.
	if [[ -n "$_rootpass" ]]; then
		_encr=$(encr_pwd "$_rootpass")
		sed -i -e "s@@^root::@@root:${_encr}:@@" /mnt/etc/master.passwd \
			2>/dev/null
	fi
	pwd_mkdb -p -d /mnt/etc /etc/master.passwd

	# During autoinstall, add root user's public ssh key to authorized_keys.
	[[ -n "$_rootkey" ]] && (
		umask 077
		print -r -- "$_rootkey" >>/mnt/root/.ssh/authorized_keys
	)

	# Perform final steps common to both an install and an upgrade.
	finish_up
}

do_upgrade(){
	# Get $ROOTDISK and $ROOTDEV
	get_rootinfo

	echo -n "Checking root filesystem (fsck -fp /dev/$ROOTDEV)..."
	fsck -fp /dev/$ROOTDEV >/dev/null 2>&1 || { echo "FAILED."; exit; }
	echo "OK."

	echo -n "Mounting root filesystem (mount -o ro /dev/$ROOTDEV /mnt)..."
	mount -o ro /dev/$ROOTDEV /mnt || { echo "FAILED."; exit; }
	echo "OK."

	# The fstab and myname files are required.
	for _f in /mnt/etc/{fstab,myname}; do
		[[ -f $_f ]] || { echo "No $_f!"; exit; }
		cp $_f /tmp/i/${_f##*/}
	done
	hostname $(stripcom /tmp/i/myname)
	THESETS="$THESETS site$VERSION-$(hostname -s).tgz"

	# Configure the network.
	enable_network

	# Fetch the list of mirror servers and installer choices from previous
	# runs.
	start_cgiinfo

	# Create a skeletal /etc/fstab which is usable for the upgrade process.
	munge_fstab

	# fsck -p non-root filesystems in /etc/fstab.
	check_fs

	# Mount filesystems in /etc/fstab.
	umount /mnt || { echo "Can't umount $ROOTDEV!"; exit; }
	mount_fs

	# Feed the random pool some entropy before we read from it.
	feed_random

	# Ensure that previous installer choices (e.g. method) are available.
	wait_cgiinfo

	# Ask the user for locations, and install whatever sets the user
	# selected.
	install_sets

	# Perform final steps common to both an install and an upgrade.
	finish_up
}

# ------------------------------------------------------------------------------
# Initial actions common to both installs and upgrades.
#
# Some may require machine dependent routines, which may call functions defined
# above, so it's safest to put this code here rather than at the top.
# ------------------------------------------------------------------------------

# Parse parameters.
AUTO=false
MODE=
PROGNAME=${0##*/}
RESPFILE=
while getopts "af:m:" opt; do
	case $opt in
	a)	AUTO=true;;
	f)	RESPFILE=$OPTARG;;
	m)	MODE=$OPTARG;;
	*)	usage;;
	esac
done
shift $((OPTIND-1))
(($# == 0)) || usage

# The installer can be started by using the symbolic links 'install', 'upgrade'
# and 'autoinstall' pointing to this script. Set MODE and AUTO based on that.
if [[ -z $MODE ]]; then
	case $PROGNAME in
	autoinstall)		AUTO=true;;
	install|upgrade)	MODE=$PROGNAME;;
	*)			exit 1;;
	esac
fi

# Do not limit ourselves during installs or upgrades.
for _opt in d f l m n p s; do
	ulimit -$_opt unlimited
done

# umount all filesystems, just in case we are re-running install or upgrade.
cd /
umount -af >/dev/null 2>&1

# Make sure only successful dhcp requests retain their state.
for _if in $(get_ifs dhcp); do
	set -- $(v4_info $_if)
	[[ $1 == UP && -n $2 ]] && continue
	ifconfig $_if delete down -group dhcp 2>/dev/null
done

# Include machine-dependent functions and definitions.
#
# The following functions must be provided:
#	md_congrats()		  - display friendly message
#	md_installboot()	  - install boot-blocks on disk
#	md_prep_disklabel()	  - put an OpenBSD disklabel on the disk
#	md_consoleinfo()	  - set CDEV, CTTY, CSPEED, CPROM
#
# The following variables can be provided if required:
#	MDEFI       - set to 'y' on archs that support GPT partitioning
#	MDROOTFSOPT - newfs options for the root partition
#	MDSETS	    - list of files to add to THESETS
#	MDTERM      - 'vt220' assumed if not provided
#	MDDKDEVS    - '/^[sw]d[0-9][0-9]* /s/ .*//p' assumed if not provided
#	MDCDDEVS    - '/^cd[0-9][0-9]* /s/ .*//p'    assumed if not provided
#	MDXAPERTURE - set machdep.allowaperture=value in sysctl.conf
#	MDXDM       - ask if xdm should be started if set to 'y'
#	NCPU	    - the number of cpus for mp capable arches
. install.md

# Start listener process looking for dmesg changes.
start_dmesg_listener

CGI_INFO=/tmp/i/cgiinfo
CGI_METHOD=
CGI_TIME=
CGI_TZ=
export EDITOR=ed
HTTP_DIR=
HTTP_LIST=/tmp/i/httplist
HTTP_SEC=/tmp/i/httpsec
INSTALL_METHOD=
NIFS=0
PUB_KEY=/etc/signify/openbsd-${VERSION}-base.pub
ROOTDEV=
ROOTDISK=
SETDIR="$VNAME/$ARCH"
V4_DHCPCONF=false
V6_AUTOCONF=false
WLANLIST=/tmp/i/wlanlist

# Extract and save one boot's worth of dmesg.
dmesg | sed -n '/^OpenBSD /h;/^OpenBSD /!H;${g;p;}' >/var/run/dmesg.boot

# Are we in a real release, or a snapshot?  If this is a snapshot
# install media, default us to a snapshot directory.
HTTP_SETDIR=$SETDIR
set -- $(scan_dmesg "/^OpenBSD $VNAME\([^ ]*\).*$/s//\1/p")
[[ $1 == -!(stable) ]] && HTTP_SETDIR=snapshots/$ARCH

# Detect if ftp(1) has tls support and set defaults based on that.
if [[ -e /etc/ssl/cert.pem ]]; then
	FTP_TLS=true
	HTTP_PROTO=https
else
	FTP_TLS=false
	HTTP_PROTO=http
fi

# Scan /var/run/dmesg.boot for console device.
CONSOLE=$(scan_dmesg '/^\([^ ]*\).*: console$/s//\1/p')
[[ -n $CONSOLE ]] && CSPEED=$(stty speed </dev/console)

# Look for the serial device matching the console. If we are not installing
# from a serial console, just find the first serial device that could be used
# as a console. If a suitable device is found, set CDEV, CTTY, CSPEED, CPROM.
md_consoleinfo

# Selected sets will be installed in the order they are listed in $THESETS.
# Ensure that siteXX.tgz is the *last* set listed so its contents overwrite
# the contents of the other sets, not the other way around.
SETS=$(echo {base,comp,man,game,xbase,xshare,xfont,xserv}$VERSION.tgz)
DEFAULTSETS="${DEFAULTSETS:-bsd bsd.rd} $SETS"
THESETS="bsd bsd.rd bsd.mp $MDSETS $SETS site$VERSION.tgz"
SANESETS="${SANESETS:-bsd} base${VERSION}.tgz"

# Prepare COLUMNS sanely.
export COLUMNS=$(stty -a </dev/console |
	sed -n '/columns/{s/^.* \([0-9]*\) columns.*$/\1/;p;}')
((COLUMNS == 0)) && COLUMNS=80

# Interactive or automatic installation?
if ! $AUTO; then
	cat <<__EOT
At any prompt except password prompts you can escape to a shell by
typing '!'. Default answers are shown in []'s and are selected by
pressing RETURN.  You can exit this program at any time by pressing
Control-C, but this can leave your system in an inconsistent state.

__EOT
elif [[ -z $RESPFILE ]]; then
	get_responsefile ||
		err_exit "No response file found; non-interactive mode aborted."

	do_autoinstall
else
	cp $RESPFILE /tmp/ai/ai.conf || exit
fi

# Configure the terminal and keyboard.
set_term

# In case of restart, delete previously logged answers.
rm -f /tmp/i/$MODE.resp

case $MODE in
install)	do_install;;
upgrade)	do_upgrade;;
esac
@


1.1013
log
@whitespace nit
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.1012 2017/05/31 07:55:29 tb Exp $
d2629 1
@


1.1012
log
@Change cp -pR to pax copy mode with -k when copying /etc/skel. This way
we keep existing files in the user's home directory that might have been
installed from siteXX.tgz. Found the hard way by Erling Westenvik.
Thanks to trondd for helpful analysis.

"If that's what it does, I'm all for it" halex
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.1011 2017/05/28 09:24:56 rpe Exp $
d2678 1
a2678 1
do_install(){
@


1.1011
log
@Remove _mode variable and use AI_MODE directly instead. Use the
exit code of ftp consistently to determine success of fetching the
response file.

discussed with and OK tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.1010 2017/05/27 09:05:18 zhuk Exp $
d2922 1
a2922 1
		(cd /mnt/etc/skel; cp -pR . $_home)
@


1.1010
log
@De-duplicate sets selection instructions, and give a short example.
Still one lines shorter.

Input and okay from tedu@@ and deraadt@@; also a "weak" okay from sthen@@.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.1009 2017/05/25 12:10:04 rpe Exp $
d570 1
a570 1
	local _rf _if _mode _lf _hn _path _aifile
d573 3
a575 4
	[[ -f /auto_upgrade.conf ]] && _rf=/auto_upgrade.conf _mode=upgrade
	[[ -f /auto_install.conf ]] && _rf=/auto_install.conf _mode=install
	[[ -f $_rf ]] && cp $_rf /tmp/ai/ai.$_mode.conf &&
		AI_MODE=$_mode && return
d602 1
a602 1
		_mode=${_aifile##*?(/)auto_}
d616 1
a616 1
	if [[ -n $AI_SERVER && -n $_mode ]]; then
d618 1
a618 1
		for _rf in {$AI_MAC-,${_hn:+$_hn-,}}$_mode; do
d622 1
a622 2
				>"/tmp/ai/ai.$_mode.conf" 2>/dev/null; then
				AI_MODE=$_mode
d629 1
a629 1
		[[ -z $_mode ]] && echo "Could not determine auto mode."
d641 2
a642 2
	_mode=$(echo "$_rf" | sed -En 's/^.*(install|upgrade).conf$/\1/p')
	while [[ -z $_mode ]]; do
d644 2
a645 2
		[[ $resp == [iI]* ]] && _mode=install
		[[ $resp == [uU]* ]] && _mode=upgrade
d650 5
a654 4
	unpriv ftp -Vo - "$_rf" >"/tmp/ai/ai.$_mode.conf" 2>/dev/null &&
		 AI_MODE=$_mode
	ifconfig $_if delete down 2>/dev/null
	[[ -n $AI_MODE ]]
@


1.1009
log
@Move the code that runs the installer script in non-interactive
mode into a dedicated do_autoinstall() function.

OK halex@@, krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.1008 2017/05/25 08:25:00 rpe Exp $
d1322 1
a1322 2
sets by prepending a '-' to the set name, file name pattern or 'all'. Selected
sets are labelled '[X]'.
@


1.1008
log
@Replace various echo "..."; exit 1 with a new err_exit() function.

diskussed with tb@@ and halex@@
OK krw@@ on a similar diff
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.1007 2017/05/22 19:03:24 rpe Exp $
d2665 15
d3148 1
a3148 11
	rm -f /tmp/ai/ai.done
	echo "Performing non-interactive $AI_MODE..."
	/$AI_MODE -af /tmp/ai/ai.$AI_MODE.conf 2>&1 </dev/null |
		sed "s/^.*$(echo '\r')//;w/tmp/ai/ai.log"
	if [[ -f /tmp/ai/ai.done ]]; then
		# Email /tmp/ai/ai.log to root on next boot.
		prep_root_mail /tmp/ai/ai.log "$(hostname) $AI_MODE log"
		exec reboot
	else
		err_exit "failed; check /tmp/ai/ai.log"
	fi
@


1.1007
log
@The DISPLAY variable is actually not a global variable as it's used
only once in questions(). Use scan_dmesg() output directly to test
for wsdisplay* in dmesg.boot instead.

Change comment, now that it only refers to setting CONSOLE.

no objection tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.1006 2017/05/22 17:15:52 rpe Exp $
d63 6
d71 1
a71 2
	echo "usage: ${0##*/} [-a] [-f filename] [-m install | upgrade]" >&2
	exit 1
d415 1
a415 2
			echo "https not supported on this platform."
			exit 1
d420 1
a420 2
			echo "Autopartitioning failed"
			exit 1
d422 1
a422 2
			echo "No autopartitioning template found."
			exit 1
d689 1
a689 2
	echo "\nQuestion has no answer in response file."
	exit 1
d2502 1
a2502 1
		*)	$AUTO && echo "'$resp' is not a valid choice." && exit 1
d3130 3
a3132 4
	if ! get_responsefile; then
		echo "No response file found; non-interactive mode aborted."
		exit 1
	fi
d3142 1
a3142 2
		echo "failed; check /tmp/ai/ai.log"
		exit 1
@


1.1006
log
@No need to trim a trailling blank, bsort (in scan_dmesg) does not
emit one anymore.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.1005 2017/05/21 09:09:58 rpe Exp $
d1939 1
a1939 1
	if [[ -n $DISPLAY ]]; then
d3097 1
a3097 2
# Scan /var/run/dmesg.boot for interesting devices.
DISPLAY=$(scan_dmesg '/^wsdisplay[0-9]* /s/ .*//p')
@


1.1005
log
@Ensure a clean initial state (e.g. in case of an installer restart)
by moving setting ulimit, unmounting all filesystems and cleaning up
the dhcp state upwards to before sourcing install.md.

OK tb@@

While here, 1>/dev/null -> >/dev/null.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.1004 2017/05/15 17:12:25 rpe Exp $
a3099 1
CONSOLE=${CONSOLE% }
@


1.1004
log
@- export EDITOR and COLUMNS on assignment
- move EDITOR into the block of global variables and export
- break long line in COLUMNS assignment
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.1003 2017/05/15 17:02:48 rpe Exp $
d3022 16
a3078 5
# Do not limit ourselves during installs or upgrades.
for _opt in d f l m n p s; do
	ulimit -$_opt unlimited
done

a3119 11

# umount all filesystems, just in case we are re-running install or upgrade.
cd /
umount -af 1>/dev/null 2>&1

# Make sure only successful dhcp requests retain their state.
for _if in $(get_ifs dhcp); do
	set -- $(v4_info $_if)
	[[ $1 == UP && -n $2 ]] && continue
	ifconfig $_if delete down -group dhcp 2>/dev/null
done
@


1.1003
log
@- move NIFS into the block of global variables
- sort global variable block alphabetically
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.1002 2017/05/15 16:55:53 rpe Exp $
d3049 1
d3106 2
a3107 1
COLUMNS=$(stty -a </dev/console | sed -n '/columns/{s/^.* \([0-9]*\) columns.*$/\1/;p;}')
a3108 3

EDITOR=ed
export EDITOR COLUMNS
@


1.1002
log
@- Move the dmesg listener code into it's own start_dmesg_listener() function.
- Add -f option to rm in unlock() to be able to use it in the new function.

OK halex@@, krw@@, tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.1001 2017/05/06 06:49:12 rpe Exp $
a3044 4
ROOTDISK=
ROOTDEV=

SETDIR="$VNAME/$ARCH"
d3046 2
a3048 3
CGI_TIME=
CGI_METHOD=
INSTALL_METHOD=
d3050 1
d3052 2
a3053 2
HTTP_LIST=/tmp/i/httplist
WLANLIST=/tmp/i/wlanlist
d3055 3
d3060 1
a3085 1
NIFS=0
a3086 1

@


1.1001
log
@Add build to the list of usernames that are rejected during
installation.

Noted by crd _at_ crdavies.eu
OK tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.1000 2017/05/01 14:29:39 rpe Exp $
d514 1
a514 1
	rm -d /tmp/i/lock 2>/dev/null
d523 30
d3042 2
a3043 26
# Make sure lock is initially released.
rm -df /tmp/i/lock

# The dmesg listener will check for the existence of this file and sends a
# signal to the child process if the dmesg output differs from the contents
# of that file.
rm -f /tmp/i/update

if ! $AUTO; then
	# Start listener process looking for dmesg changes.
	(
		while :; do
			lock
			if [[ -e /tmp/i/update && "$(dmesg)" != "$(</tmp/i/update)" ]]; then
				dmesg >/tmp/i/update
				kill -TERM 2>/dev/null $$ || exit 1
			fi
			unlock
			sleep .5
		done
	) |&
	CPPID=$!

	# Kill the child on exit.
	retrap
fi
@


1.1000
log
@Apply same change of defaultroute handling as in r1.179 of netstart.

Now that routes are automatically G/C with the address they are
attached to there's no reason to duplicate the kernel's job.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.999 2017/05/01 14:22:36 rpe Exp $
d1948 1
a1948 1
		root|daemon|operator|bin|sshd|www|nobody|ftp)
@


1.999
log
@Remove last remnants of rtsol. IPv6 autoconfiguration of interfaces
is now done in ifstart(). Replace rtsolif with a boolean variable
V6_AUTOCONF. Replace dhcpif with a boolean variable V4_DHCPCONF.
Both are later used to decide whether or not to configre defaultroutes
from /etc/mygate.

OK krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.998 2017/04/25 19:24:05 rpe Exp $
a2256 1
		route -qn delete default >/dev/null 2>&1
a2261 1
		route -qn delete -inet6 default >/dev/null 2>&1
@


1.998
log
@Unbreak multiple interface configurations like trunk or carp. Ensure
that the noglob option is disabled at the end of parse_hn_line()
and ifstart().
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.997 2017/04/24 20:27:59 rpe Exp $
d2145 1
a2145 1
			rtsolif="$rtsolif $_if"
d2165 1
a2165 1
		dhcpif="$dhcpif $_if"
d2172 1
a2172 1
		rtsolif="$rtsolif $_if"
a2250 2
	[[ -n $rtsolif ]] && ifconfig $rtsolif inet6 autoconf

d2254 2
a2255 1
	[[ -z $dhcpif ]] && stripcom /mnt/etc/mygate | while read _gw; do
d2260 2
a2261 1
	[[ -z $rtsolif ]] && stripcom /mnt/etc/mygate | while read _gw; do
d3055 2
@


1.997
log
@Introduce a new function parse_hn_line() that replaces the existing
hostname.if(5) parsing code in ifstart().

- change v6_config()
  - replace rtsol with autoconf in "IPv6 addres for <if>" question
  - write 'inet6 autoconf" to hostname.if file instead of rtsol
- add parse_hn_line() function with installer specific changes
  - skip shell command and bridge config lines
  - skip inet6 config (incl. dest lines) if there's no inet6 support
  - skip dhcp config if there's no dhclient
- change ifstart() to use parse_hn_line()

Discussed with and positive feedback from many
'commit' deraadt@@
conditional OK sthen@@ (untested)
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.996 2017/04/11 19:23:10 rpe Exp $
d2182 1
d2206 1
@


1.996
log
@Ensure that the version part of $_url_base is correctly removed by
using $VNAME (x.y) instead of $VERSION (xy). This fixes the problem
that the version part ended up in installurl which is wrong anyway
and also confuses pkg_add.

Thanks to florian@@ and trondd at kagu-tsuchi dot com for reporting
this.

OK tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.995 2017/04/07 22:53:25 rpe Exp $
d1006 1
a1006 1
	ifconfig $_if inet6 >/dev/null 2>&1 && _prompt="or 'rtsol' "
d1013 2
a1014 1
	rtsol)	ifconfig $_if inet6 >/dev/null 2>&1 ||
d1016 1
a1016 2
		ifconfig $_if up
		ifconfig $_if inet6 autoconf && echo "up\nrtsol" >>$_hn
d2117 67
d2187 2
a2188 3
	# Note: Do not rename the 'if' variable which is documented as being
	# usable in hostname.if(5) files.
	local _hn=$1 if=${1#/mnt/etc/hostname.}
d2191 6
a2196 91
	while :; do
		if [ "$cmd2" ]; then
			# We are carrying over from the 'read dt dtaddr'
			# last time.
			set -- $cmd2
			af=$1 name=$2 mask=$3 bcaddr=$4 ext1=$5 cmd2=
			# Make sure and get any remaining args in ext2,
			# like the read below.
			i=1
			while [ $i -lt 6 -a -n "$1" ]; do shift; let i=i+1; done
			ext2="$@@"
		else
			# Read the next line or exit the while loop.
			read af name mask bcaddr ext1 ext2 || break
		fi
		# $af can be "dhcp", "up", "rtsol", an address family, commands,
		# or a comment.
		case "$af" in
		"#"*|"!"*|"bridge"|"")
			# Skip comments, user commands, bridges, and empty lines.
			continue
			;;
		"dhcp")
			[ "$name" = "NONE" ] && name=
			[ "$mask" = "NONE" ] && mask=
			[ "$bcaddr" = "NONE" ] && bcaddr=
			cmd="ifconfig $if $name $mask $bcaddr $ext1 $ext2 down"
			if [[ -x /sbin/dhclient ]]; then
				cmd="$cmd; dhclient $if"
			else
				cmd="$cmd; echo /sbin/dhclient missing - skipping dhcp request."
			fi
			dhcpif="$dhcpif $if"
			;;
		"rtsol")
			if ifconfig $if inet6 >/dev/null 2>&1; then
				rtsolif="$rtsolif $if"
				cmd="ifconfig $if $name $mask $bcaddr $ext1 $ext2 up"
			else
				cmd="$cmd; echo no INET6 support - skipping rtsol request."
			fi
			;;
		*)
			read dt dtaddr
			if [ "$name" = "alias" ]; then
				# Perform a 'shift' of sorts.
				alias=$name
				name=$mask
				mask=$bcaddr
				bcaddr=$ext1
				ext1=$ext2
				ext2=
			else
				alias=
			fi
			cmd="ifconfig $if $af $alias $name"
			case "$dt" in
			dest)
				cmd="$cmd $dtaddr"
				;;
			*)
				cmd2="$dt $dtaddr"
				;;
			esac
			case $af in
			inet)
				if [ ! -n "$name" ]; then
					echo "/etc/hostname.$if: inet alone is invalid"
					return
				fi
				[ "$mask" ] && cmd="$cmd netmask $mask"
				if [ "$bcaddr" -a "X$bcaddr" != "XNONE" ]; then
					cmd="$cmd broadcast $bcaddr"
				fi
				;;
			inet6)
				if [ ! -n "$name" ]; then
					echo "/etc/hostname.$if: inet6 alone is invalid"
					return
				fi
				[ "$mask" ] && cmd="$cmd prefixlen $mask"
				cmd="$cmd $bcaddr"
				;;
			*)
				cmd="$cmd $mask $bcaddr"
				;;
			esac
			cmd="$cmd $ext1 $ext2"
			;;
		esac
		eval "$cmd"
d2198 7
d2253 1
a2253 1
	# dhcp. Use for ipv6 if no interfaces configured via rtsol.
@


1.995
log
@Minimize differences in ifstart() function between netstart and
install.sub which makes it easier to spot changes in the future.

- comments and formatting
- quotes on assignments are not needed (netstart)
- remove stray space in test (netstart)
- use $file variable with while-loop (netstart)
- although valid, instead of i use $i in arithmetic test (install.sub)

OK krw@@, tb@@
Looks good deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.994 2017/04/07 22:15:17 rpe Exp $
d1710 1
a1710 1
		INSTALL_URL=${INSTALL_URL%@@(/$VERSION|/snapshots)}
@


1.994
log
@Align comments of ifstart() function in netstart and install.sub.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.993 2017/04/07 22:02:29 rpe Exp $
d2134 1
a2134 1
			while [ i -lt 6 -a -n "$1" ]; do shift; let i=i+1; done
d2140 1
a2140 1
		# $af can be "dhcp", "rtsol", an address family, commands,
d2147 2
a2148 1
		"dhcp")	[ "$name" = "NONE" ] && name=
a2150 1
			dhcpif="$dhcpif $if"
d2157 1
d2167 2
a2168 1
		*)	read dt dtaddr
d2182 2
a2183 1
			dest)	cmd="$cmd $dtaddr"
d2196 1
a2196 1
				if [ "$bcaddr" -a X"$bcaddr" != "XNONE" ]; then
d2208 2
a2209 1
			*)	cmd="$cmd $mask $bcaddr"
@


1.993
log
@Sync variable names with netstart version of stripcom().
Use $_file variable instead of $1 with the wile-loop.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.992 2017/04/07 21:44:07 rpe Exp $
d2127 2
a2128 2
			# we are carrying over from the 'read dt dtaddr'
			# last time
d2131 2
a2132 2
			# make sure and get any remaining args in ext2,
			# like the read below
d2137 1
a2137 1
			# read the next line or exit the while loop
d2140 2
a2141 2
		# $af can be "dhcp", "rtsol", an address family,
		# commands, or a comment.
d2144 1
a2144 2
			# skip comments, user commands, bridges,
			# and empty lines
d2168 1
a2168 1
				# perform a 'shift' of sorts
@


1.992
log
@Align comments of stripcom() function in netstart and install.sub.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.991 2017/04/07 21:00:42 rpe Exp $
d196 1
a196 1
	local _l
d198 1
a198 1
	[[ -f $1 ]] || return
d201 3
a203 3
	while read _l; do
		[[ -n ${_l%%#*} ]] && echo $_l
	done <$1
@


1.991
log
@Extend the information shown by diskinfo() to help to identify
disks. Extract the disk information enclosed in <> and the NAA
from the last matching dmesg line. Useful if there are multiple
identically sized disk of the same type.

Suggested by jirib at devio dot us
Discussed with deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.990 2017/04/04 17:50:45 rpe Exp $
d192 3
a194 2
# Echo file $1 to stdout. Skip comment lines and delete everything after the
# first '#' from other lines.
@


1.990
log
@Ensure, that during upgrades, the default for the "Location of sets"
question is set to http if /etc/installurl exists and override the
install method information from the cgi server.

'makes sense' deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.989 2017/03/31 18:36:49 rpe Exp $
d261 1
a261 1
# Show device name, label and size for the provided list of disk devices.
d264 1
a264 1
	local _d
d267 9
d277 1
a277 5
		echo -n "$_d: "
		disklabel -dpg $_d 2>/dev/null |
		sed	-e '/^label: /{s,,,;s/ *$//;s/^$/<no label>/;h;d;}' \
			-e '/.*# total bytes: \(.*\)/{s//(\1)/;H;}' \
			-e '$!d;x;s/\n/ /'
d279 2
@


1.989
log
@The default for the "Server directory?" question can possibly come
from either what information is extracted from the cgi server or
from installurl(5). Otherwise a sane default is used.

Based on what server (HTTP_SERVER) is provided by the user decide
on what source to choose from for the default.

At the end of install_http() use the url from the cgi server as the
base for what's written to /etc/installurl if an official mirror was
used. Otherwise trim _url_base and remove the architecture and
snapshots or version part.

This fixes the problem reported by phessler@@ which exposed how
fragile the current logic for this was after recent changes.

At this time of the release cycle the kernel presents itself as
release kernel, but we're still pre-release and the sets are still
in the snapshots directory on the mirrors. This was confusing the
installer script.

Thanks to phessler@@ for finding this and testing.
Special thanks to tb@@ who imposed on himself to try to understand
and review the diffs.

OK tb@@, phessler@@ (on a similar diff)
'commit when your are happy' deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.988 2017/03/13 17:08:31 rpe Exp $
d2430 1
a2430 1
	[[ -s /mnt/etc/installurl ]] && : ${_d:=http}
@


1.988
log
@Remove leading slashes from response to ensure a proper url.

Feedback and OK halex@@ tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.987 2017/03/10 22:34:09 rpe Exp $
d1542 1
a1542 1
	local _f _flist _file_list _prompt _tls _http_proto _http_server
d1544 1
a1544 1
	local _url_base _install_url _mirror_url _mirror_srv _mirror_dir
d1568 2
a1569 1
	# Format of installurl: _http_proto://_http_server/_url_path
d1571 4
a1574 3
		_install_url=$(stripcom /mnt/etc/installurl); then
		_http_server=${_install_url#*://}
		_http_server=${_http_server%%/*}
d1579 1
a1579 1
		ask_until "$_prompt" "${_http_server:-$HTTP_SERVER}"
d1624 1
a1624 1
	_mirror_url=$1
d1626 1
a1626 1
	_mirror_dir=${_mirror_url#*$_mirror_srv}
d1628 16
a1643 7
	resp=$_mirror_dir/$HTTP_SETDIR
	# If there is no directory specified, don't use this entry!
	[[ -z $_mirror_dir ]] && resp=
	if (($# > 1)); then
		# It's a mirror, since it has location info.
		resp=$_mirror_dir/$HTTP_SETDIR
		INSTALL_MIRROR=$_mirror_url
d1646 1
a1646 3
	# Set HTTP_DIR to a default path in case it was not defined yet.
	: ${HTTP_DIR:=pub/OpenBSD/$HTTP_SETDIR}
	ask_until "Server directory?" "${resp:-$HTTP_DIR}"
d1697 7
a1703 2
	INSTALL_URL=${_url_base%/$HTTP_SETDIR}
	[[ -n $INSTALL_MIRROR ]] && INSTALL_URL=$_http_proto://$INSTALL_MIRROR
@


1.987
log
@Add a comment why INSTALL_MIRROR must not become a local variable
although it's only used in install_http() now.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.986 2017/03/10 22:11:28 rpe Exp $
d1638 1
a1638 1
	HTTP_DIR=$resp
@


1.986
log
@In a scenario, where the distribution sets are fetched from a mirror
and the siteXX.tgz file is fetched from a local server, ensure that
the mirror server ends up in /etc/installurl.

joint work with and OK tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.985 2017/03/10 22:02:59 rpe Exp $
d1545 5
@


1.985
log
@Search case-insensitive for HTTP_SERVER in the ftplist.cgi output.
This ensures that ftp.OpenBSD.org is detected as mirror if
ftp.openbsd.org is specified as set location.

noticed by tj@@
joint work with and OK tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.984 2017/03/10 19:04:17 rpe Exp $
a1623 1
	INSTALL_MIRROR=
d1661 1
a1661 1
		if [[ -n $INSTALL_MIRROR ]]; then
@


1.984
log
@Explain more accurately why to remember the sets location.

noted by tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.983 2017/03/10 17:40:26 rpe Exp $
d1616 1
a1616 1
	set -- $(sed "/^$HTTP_SERVER/x;\$!d;x" $HTTP_LIST 2>/dev/null)
@


1.983
log
@Always create the installurl(5) file during installation and upgrade
if it does not yet exist. Before it was created only when a mirror
server was used.

suggested by deraadt@@
OK halex@@ tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.982 2017/03/06 22:10:14 rpe Exp $
d1682 2
a1683 1
	# Remember where we installed from, to tell the cgi server.
@


1.982
log
@Localize the 'hn' and 'if' variables in enable_network().
Document why renaming the 'if' variable in ifstart() is not allowed.

OK tb@@, krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.981 2017/03/05 19:31:15 rpe Exp $
d2544 2
a2545 3
	# Create /etc/installurl with the mirror used during install or upgrade
	# if it does not yet exist.
	if [[ -n $INSTALL_MIRROR && ! -f /mnt/etc/installurl ]]; then
@


1.981
log
@Stop using and copying the on-disk /etc/hosts file to the bsd.rd
/tmp dir during upgrade.

Create and use a minimal hosts file instead to avoid that a big
hosts file fills up the small bsd.rd / filesystem as reported
recently by Ted Roby.

Note that network interface configuration using hostnames instead
of ip addresses in hostname.if(5) relies on the on-disk /etc/hosts
file which is not used anymore during upgrade.

discussed with many
ok tb@@, halex@@
'sure' deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.980 2017/03/01 20:48:12 rpe Exp $
d2093 2
d2191 1
a2191 1
	local _f _gw _trunks _svlans _vlans
d2210 1
a2210 1
	for hn in /mnt/etc/hostname.*; do
d2212 2
a2213 2
		if=${hn#/mnt/etc/hostname.}
		if isin "${if%%+([0-9])}" $(ifconfig -C); then
d2215 4
a2218 4
			case ${if%%+([0-9])} in
			trunk)	_trunks="$_trunks $hn";;
			svlan)	_svlans="$_svlans $hn";;
			vlan)	_vlans="$_vlans $hn";;
d2222 1
a2222 1
			ifconfig $if >/dev/null 2>&1 && ifstart $hn
d2227 2
a2228 2
	for hn in $_trunks $_svlans $_vlans; do
		ifstart $hn
@


1.980
log
@Comments ...
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.979 2017/02/28 19:42:38 rpe Exp $
d2191 1
a2191 1
	# Copy any network configuration files. N.B.: hosts already copied.
d2198 4
d2901 2
a2902 2
	# The fstab, hosts and myname files are required.
	for _f in /mnt/etc/{fstab,hosts,myname}; do
@


1.979
log
@Create the /etc/installurl file during upgrade too if a mirror was
used and if the file did not yet exist.

discussed with aja@@ and deraadt@@
OK tb@@ aja@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.978 2017/02/28 18:32:15 rpe Exp $
d2573 1
a2573 1
	# device nodes exist.
d2583 1
a2583 1
	# Ensure that fw_update is run on reboot.
d2586 2
d2593 1
@


1.978
log
@Modify the logic to determine the default answer for the "Location
of sets?" question.  Present 'http' as the default answer if
/etc/installurl exists.  This fixes the issue noted by aja@@ and
espie@@ that 'cd' was always overriding 'http'.

OK aja@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.977 2017/02/27 22:02:09 rpe Exp $
d2538 3
a2540 2
	# Create /etc/installurl with the mirror used during install.
	if [[ $MODE == install && -n $INSTALL_MIRROR ]]; then
@


1.977
log
@Sync comments about install.md variables with reality.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.976 2017/02/26 16:51:18 matthieu Exp $
d2403 3
@


1.976
log
@Switch to xenodm(1).

Do it now deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.975 2017/02/25 12:57:03 rpe Exp $
d2971 2
d2978 1
@


1.975
log
@Localize _OPT as it is not used as a global variable.

OK tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.974 2017/02/19 17:53:58 tb Exp $
d1888 1
a1888 1
			ask_yn "Do you want the X Window System to be started by xdm(1)?"
d2473 2
a2474 2
	[[ $START_XDM == y && -x /mnt/usr/X11R6/bin/xdm ]] &&
		echo "xdm_flags=" >>/mnt/etc/rc.conf.local
@


1.974
log
@Remove an unfortunate significant trailing whitespace that ended up passing
a bogus argument to ftp(1), disabling redirection and running ftp(1) in the
background.

ok rpe
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.973 2017/02/14 22:23:04 rpe Exp $
d434 1
a434 1
	local _disk=$1 _fstab=/tmp/i/fstab.$1
d482 3
a484 3
			_OPT=
			[[ $_mp == / ]] && _OPT=$MDROOTFSOPT
			newfs -q $_OPT ${_pp##/dev/}
@


1.973
log
@These variables are global so use uppercase and rename sshd and xdm
to START_SSHD and START_XDM to better match their purpose.

aperture -> APERTURE
defcons -> DEFCONS
ssh_enableroot -> SSHD_ENABLEROOT
sshd -> START_SSHD
xdm -> START_XDM

OK krw@@, tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.972 2017/02/14 22:05:13 rpe Exp $
d2778 1
a2778 1
			"$HTTP_PROTO://ftp.openbsd.org/cgi-bin/ftpinstall.cgi?dbversion=1&$_i" \ 
@


1.972
log
@Fix comment.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.971 2017/02/14 22:03:01 rpe Exp $
d1877 1
a1877 1
	sshd=$resp
d1879 1
a1879 1
	aperture=
d1881 1
a1881 1
	xdm=
d1885 1
a1885 1
				aperture=$MDXAPERTURE
d1889 1
a1889 1
			xdm=$resp
d1897 1
a1897 1
		defcons=$resp
d1902 1
a1902 1
			done)	defcons=n;;
d1958 1
a1958 1
	[[ $sshd == y ]] || return
d1968 1
a1968 1
		y|yes)	sshd_enableroot=yes
d1970 1
a1970 1
		n|no)	sshd_enableroot=no
d1973 1
a1973 1
			sshd_enableroot=prohibit-password
d2458 1
a2458 1
	if [[ $sshd == n ]]; then
d2460 1
a2460 1
	elif [[ -n $sshd_enableroot ]]; then
d2462 1
a2462 1
		if ! grep -q "^#PermitRootLogin $sshd_enableroot\$" \
d2464 1
a2464 1
			sed -i "s/^#\(PermitRootLogin\) .*/\1 $sshd_enableroot/" \
d2469 2
a2470 2
	[[ -n $aperture ]] &&
		echo "machdep.allowaperture=$aperture # See xf86(4)" \
d2473 1
a2473 1
	[[ $xdm == y && -x /mnt/usr/X11R6/bin/xdm ]] &&
d2476 1
a2476 1
	if [[ $defcons == y ]]; then
@


1.971
log
@Rename functions to match the predominantly used verb_noun naming scheme
and to improve readability.

addhostent -> add_hostent
askpass -> ask_pass
askpassword -> ask_password
makedev -> make_dev
showcols -> show_cols
startcgiinfo -> start_cgiinfo
waitcgiinfo -> wait_cgiinfo

OK krw@@, tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.970 2017/02/12 08:58:30 landry Exp $
d1909 1
a1909 1
# Gather information for setting up the user later in apply().
@


1.970
log
@In autoinstall, no need to create /mnt/root/.ssh if the install script
provided an ssh public key, the directory is in the base set now.

From tb@@, discussed with rpe@@ and tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.969 2017/02/08 23:13:02 rpe Exp $
d71 1
a71 1
waitcgiinfo() {
d74 1
a74 1
	# Wait for the ftp(1) process started in startcgiinfo() to end and
d178 1
a178 1
showcols() {
d267 1
a267 1
		makedev $_d
d278 1
a278 1
makedev() {
d436 1
a436 1
	makedev $_disk || return
d800 1
a800 1
askpass() {
d808 1
a808 1
askpassword() {
d820 1
a820 1
		askpass "$_q (will not echo)"
d823 1
a823 1
		askpass "$_q (again)"
d884 1
a884 1
addhostent() {
d938 1
a938 1
			addhostent "$_addr" "$_name"
d1017 1
a1017 1
	addhostent "$_addr" "$_name"
d1289 1
a1289 1
		done | showcols | sed 's/^/    /'
d1390 1
a1390 1
		for _n in $THESETS; do echo $_n; done | showcols | sed 's/^/    /'
d1711 1
a1711 1
	makedev $_drive && mount_mnt2 $_drive || return
d1726 1
a1726 1
		makedev $resp && mount_mnt2 $resp || return
d1944 1
a1944 1
	askpassword "Password for user $ADMIN?"
d2000 1
a2000 1
	waitcgiinfo
d2013 1
a2013 1
		"?")	grep -v /. $_zonefile | showcols
d2024 1
a2024 1
			"?")	sed -n "/^$_zsed/{s/$_zsed//;/\/./!p;}" $_zonefile | showcols;;
d2046 1
a2046 1
		makedev $_d
d2083 1
a2083 1
	makedev $resp || exit
d2247 1
a2247 1
startcgiinfo() {
d2252 1
a2252 1
	addhostent 129.128.5.191 ftp.openbsd.org
d2343 1
a2343 1
		makedev "$_dn" || continue
d2570 1
a2570 1
	makedev $(bioctl $ROOTDISK 2>/dev/null | sed -n 's/.*<\(.*\)>$/\1/p')
d2626 1
a2626 1
	((NIFS)) && startcgiinfo
d2631 1
a2631 1
		askpassword "Password for root account?"
d2903 1
a2903 1
	startcgiinfo
d2919 1
a2919 1
	waitcgiinfo
@


1.969
log
@Add even more line breaks to fit to 80 columns.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.968 2017/02/08 22:56:01 rpe Exp $
a2870 1
		mkdir /mnt/root/.ssh
@


1.968
log
@Use a variable to make the prompt fit to 80 columns.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.967 2017/02/08 22:43:37 rpe Exp $
d1102 2
a1103 1
		[[ $_vd == @@(*vlan: +([[:digit:]]) parent interface:*) ]] || break
d1149 2
a1150 1
			ask "Which interface:tag should $_if be on?" "${_vd:=$1}:$_vi"
d1155 2
a1156 1
			if ! (isin "$_vd" $_ifs && [[ $_vd != vlan+([0-9]) ]]); then
@


1.967
log
@Add some more line breaks to fit to 80 columns.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.966 2017/02/08 22:29:39 rpe Exp $
d393 1
a393 1
	local _disk=$1 _f=$2 _dl=/tmp/i/disklabel.auto _op
d416 1
d420 1
a420 1
		ask "Use (A)uto layout, (E)dit auto layout, or create (C)ustom layout?" a
@


1.966
log
@Add some line breaks to fit to 80 columns.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.965 2017/02/08 22:16:49 rpe Exp $
d1300 2
a1301 1
				[[ $_f == $resp ]] && _selected=$($_action $_f $_selected)
d1460 2
a1461 1
		! unpriv -f "$_cfile" signify -Vep $PUB_KEY -x "$_cfile.sig" -m "$_cfile" &&
d1511 2
a1512 1
		*.tgz)	$_unpriv ftp -D Installing -Vmo - "$_fsrc" | tar -zxphf - -C /mnt
d2478 2
a2479 1
			echo "stty $CPROM $CSPEED\nset tty $CPROM" >>/mnt/etc/boot.conf
d2859 2
a2860 1
		sed -i -e "s@@^root::@@root:${_encr}:@@" /mnt/etc/master.passwd 2>/dev/null
@


1.965
log
@Localize PS3 at the top of v6_defroute() to make its assignment
fit to 80 columns.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.964 2017/02/08 22:04:03 rpe Exp $
d1004 2
a1005 1
	rtsol)	ifconfig $_if inet6 >/dev/null 2>&1 || { echo "No INET6 support."; return; }
d1212 2
a1213 1
	set -- $(route -nv show -inet | { set -- $(grep '^default '); print $2 $9; })
d1223 2
a1224 1
		route -n add -inet -host default "$resp" && { echo "$resp" >>/tmp/i/mygate; break; }
@


1.964
log
@Use a variable for the sysctl output to shorten the for-loop to
fit to 80 columns.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.963 2017/02/08 21:35:18 rpe Exp $
d957 1
a957 1
	local _if=$1 _prompt _resp _routers
d970 1
a970 1
		local PS3="$_prompt (${_routers:+list #, }IPv6 address or 'none'): "
@


1.963
log
@Reformat get_responsfile() to fit to 80 columns.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.962 2017/02/05 19:29:32 rpe Exp $
d289 1
a289 1
	local IFS=,
d291 1
a291 1
	bsort $(for _n in $(sysctl -n hw.disknames); do echo "${_n%%:*} "; done | sed -n "$1")
@


1.962
log
@Reformat and adapt install_http() to fit to 80 columns.

OK krw@@, tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.961 2017/02/05 15:39:52 rpe Exp $
d534 2
a535 1
	[[ -f $_rf ]] && cp $_rf /tmp/ai/ai.$_mode.conf && AI_MODE=$_mode && return
d549 2
a550 1
				"should be used for the initial DHCP request" "$*"
d565 2
a566 1
		AI_SERVER=$(lease_value $_lf server-name tftp-server-name next-server)
d581 2
a582 1
			if unpriv ftp -Vo - "$_url" >"/tmp/ai/ai.$_mode.conf" 2>/dev/null; then
d611 2
a612 1
	unpriv ftp -Vo - "$_rf" >"/tmp/ai/ai.$_mode.conf" 2>/dev/null && AI_MODE=$_mode
@


1.961
log
@Curly brackets are not needed here.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.960 2017/02/05 14:57:15 rpe Exp $
d1527 1
a1527 1
	local _f _file_list _prompt _url_base _tls _http_proto _http_server
d1529 1
a1529 1
	local _install_url _mirror_url _mirror_srv _mirror_dir
d1570 4
a1573 1
			(($# < 1)) && { echo "There is no line $resp."; continue; }
d1624 2
a1625 1
	if ! unpriv -f $_sig ftp -w 15 -VMo $_sig "$_url_base/SHA256.sig" 2>/dev/null; then
d1633 2
a1634 1
			unpriv -f $_sig ftp -VMo $_sig "$_url_base/SHA256.sig" 2>/dev/null
d1640 4
a1643 2
	if unpriv -f $_sha signify -Vep $PUB_KEY -x $_sig -m $_sha >/dev/null 2>&1; then
		_file_list="SHA256.sig $(sed -n 's/^SHA256 (\(.*\)).*$/\1/p' $_sha)"
d1656 4
a1659 2
	if unpriv -f $_idx ftp -VMo $_idx "$_url_base/index.txt" 2>/dev/null; then
		for _f in $(sed -En 's/^.* ([a-zA-Z][a-zA-Z0-9._-]+)$/\1/p' $_idx); do
@


1.960
log
@Rename rootpass to _rootpass and localize it together with _rootkey.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.959 2017/02/05 14:40:16 rpe Exp $
d2819 1
a2819 1
		echo ${ADMIN} >/mnt/root/.forward
@


1.959
log
@user, username, userpass and userkey are global variables. The user
created during install is added to the wheel group and as such is
actually an admin user. So use ADMIN, ADMIN_NAME, ADMIN_PASS and
ADMIN_KEY instead.

OK tb@@
OK krw@@ on a similar diff
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.958 2017/01/24 10:14:14 rpe Exp $
d2580 2
d2613 1
a2613 1
	rootkey=
d2616 1
a2616 1
		[[ $resp != none ]] && rootkey=$resp
d2843 1
a2843 1
	[[ -n "$rootkey" ]] && (
d2846 1
a2846 1
		print -r -- "$rootkey" >>/mnt/root/.ssh/authorized_keys
@


1.958
log
@ftplist.cgi provides the http server from previous installs as the
first line of its output. In contrast to the rest of the list of
mirror servers, this first line does not have any location info.

Only use this first line as default answer, if it has no location
info.

OK krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.957 2017/01/24 10:06:21 rpe Exp $
d1905 1
a1905 1
	user=$resp
d1907 1
a1907 1
		ask "Full name for user $user?" $user
d1918 1
a1918 1
	username=$resp
d1920 2
a1921 2
	askpassword "Password for user $user?"
	userpass=$_password
d1923 3
a1925 3
	userkey=
	$AUTO && ask "Public ssh key for user $user" none &&
		[[ $resp != none ]] && userkey=$resp
d1936 1
a1936 1
	if [[ -z $user ]]; then
d2811 4
a2814 4
	if [[ -n $user ]]; then
		_encr=$(encr_pwd "$userpass")
		_home=/home/$user
		uline="${user}:${_encr}:1000:1000:staff:0:0:${username}:$_home:/bin/ksh"
d2816 2
a2817 2
		echo "${user}:*:1000:" >>/mnt/etc/group
		echo ${user} >/mnt/root/.forward
d2822 4
a2825 4
		(umask 077 && sed "s,^To: root\$,To: ${username} <${user}>," \
			/mnt/var/mail/root >/mnt/var/mail/$user )
		chown -R 1000:1000 $_home /mnt/var/mail/$user
		sed -i -e "s@@^wheel:.:0:root\$@@wheel:\*:0:root,${user}@@" \
d2829 2
a2830 2
		[[ -n "$userkey" ]] &&
			print -r -- "$userkey" >>$_home/.ssh/authorized_keys
@


1.957
log
@Don't allow any control and space characters in the answer to the
"System hostname" question.

OK tb@@ krw@@
'sure' deraadt@@
positive feedback on the idea halex@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.956 2017/01/23 02:14:45 rpe Exp $
d72 1
a72 1
	local _l _key _val
d84 3
a86 3
	# ftplist.cgi output).
	read -r -- _l <$HTTP_LIST
	: ${HTTP_SERVER:=${_l%%/*}}
@


1.956
log
@Clean up possible leftover prefetch area in case of installer restarts.

OK tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.955 2017/01/23 02:11:30 rpe Exp $
d2582 7
a2588 1
	ask_until "System hostname? (short form, e.g. 'foo')" "$(hostname -s)"
@


1.955
log
@Export AI_MAC and AI_SERVER in addition to AI_MODE so they're visible
in the install.site and upgrade.site scripts.

OK tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.954 2017/01/22 23:38:30 rpe Exp $
d1427 6
@


1.954
log
@Ensure the right hand side of the test is not treated as pattern.

OK tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.953 2017/01/22 23:37:37 rpe Exp $
d529 2
a530 2
	local _rf _if _mac _mode _lf _hn _path _aifile
	AI_MODE=
a563 1
		export AI_SERVER
d574 2
a575 2
		_mac=$(ifconfig $_if | sed 's/.*lladdr \(.*\)/\1/p;d')
		for _rf in {$_mac-,${_hn:+$_hn-,}}$_mode; do
a2965 3

AI_MODE=
AI_SERVER=
@


1.953
log
@= -> == inside [[ ]] tests.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.952 2017/01/22 23:23:23 rpe Exp $
d153 1
a153 1
		[[ $_a != $_b ]] && _c="${_c:+$_c }$_b"
@


1.952
log
@Unobscure the installer script code a bit by adding and rewording comments.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.951 2017/01/22 22:47:11 rpe Exp $
d1290 1
a1290 1
			[[ $resp = all ]] && resp=*
d1293 1
a1293 1
				[[ $_f = $resp ]] && _selected=$($_action $_f $_selected)
d1976 1
a1976 1
	[[ $_zonefile = /var/tzlist && -z $TZ ]] && return
@


1.951
log
@Prefix local variables with '_'.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.950 2017/01/22 03:30:23 rpe Exp $
d69 2
a70 1
# Wait for the ftp process to finish, or be killed after the timeout.
d74 2
d79 1
d82 3
d88 2
d241 2
a242 2
# Examine the contents of the DHCP lease file named in $1 for a line
# containing the field provided as parameters.
a244 2
#
# Return the value of the first field found.
d261 2
a262 1
# Show device name, label and size for the provided list of devices.
d325 1
a325 1
# Return the device name of the device $1, which may be a disklabel UID.
d362 1
d366 2
d370 1
d444 1
a444 1
	# Make sure there is a '/ mount point.
a535 4
	# Select a network interface for initial dhcp request.
	# Ask if multiple were found and system was not netbooted.
	# Extract server ip address, installer mode and response file path
	# from lease file. Prime hostname with host-name option.
d538 3
d544 2
d551 2
d556 1
d562 1
d566 1
d1520 1
a1520 1
# Get several parameters from the user, and xfer files from the http server.
d1526 2
a1527 2
	# N.B.: 'http_proxy' is an environment variable used by ftp(1). DON'T
	# change the name or case!
d1533 2
d1557 1
d1561 1
a1561 2
			# A numeric hostname is ignored. A number is only used
			# as a line number in $HTTP_LIST.
d1563 1
d1608 1
d1678 1
a1678 1
# Install sets from CD-ROM.
d1687 2
a1688 2
# Ask for the disk device containing the set files, mount it and start the set
# installation.
d1695 2
d2365 1
a2365 1
	local _cddevs=$(get_cddevs) _d=$CGI_METHOD _im _locs="disk http" _src
d2369 4
d2374 2
d2377 2
d2380 2
d2384 2
d2394 1
d2419 1
d2421 2
@


1.950
log
@Tweak previous ...
- remove the unsued _err variable
- rework the extraction of the mirror dir info from HTTP_LIST
- use INSTALL_MIRROR to save the mirror info from HTTP_LIST
- use _http_proto to for the final INSTALL_URL if it's a mirror
- assign the correct info to INSTALL_URL
- write INSTALL_URL to /etc/installurl on install if a mirror was used

Feedback and OK tb@@
'Looks good' deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.949 2017/01/21 04:33:00 rpe Exp $
d162 2
a163 2
	for a; do
		alias Q=$a; a=$(alias Q); print -rn -- " ${a#Q=}"
@


1.949
log
@Start creating and using /etc/installurl. This file is created
during installation if an OpenBSD mirror server is used for the
sets download. It contains the mirror server url in the same format
as provided by ftplist.cgi.

The installurl file is used by the OpenBSD installer, the syspatch(8)
and the pkg_add(1) commands.

Stop creating and updating the /etc/pkg.conf file - the pkg_add(1)
command will use the information in installurl.

Use a new dbversion of the CGIs which accecpt and provide mirror
urls without the release/arch part at the end..

Idea from ajacoutot@@
Joint work with and OK ajacoutot@@ tb@@ beck@@ deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.948 2017/01/20 23:14:52 rpe Exp $
d1504 1
a1504 1
	local _file_list _prompt _mirror _url_base _err _tls _http_proto _f
d1506 1
a1506 1
	local _http_server _install_url
d1570 2
d1573 8
a1580 3
	resp=${1#*/}
	# If there is no directory specified, don't use the server name!
	[[ $resp == "$1" ]] && resp=
d1583 2
a1584 2
		resp=$resp/$HTTP_SETDIR
		_mirror=yes
d1600 1
d1613 1
a1613 1
		if [[ $_mirror == yes ]]; then
a1626 1

d1632 2
a1633 2
	INSTALL_URL=
	[[ $_mirror == yes ]] && INSTALL_URL=${_url_base%/$HTTP_SETDIR}
d2466 1
a2466 1
	[[ $MODE == install && -n $INSTALL_URL ]] &&
d2468 1
@


1.948
log
@Use a global variable PUB_KEY for the location of the key file.

OK tb@@ krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.947 2017/01/11 20:43:46 tb Exp $
d1506 1
d1522 8
d1532 1
a1532 1
		ask_until "$_prompt" "$HTTP_SERVER"
d1625 2
a1626 9
	INSTALL_URL=$_url_base

	# Bake a package path only if we installed from a mirror.
	PACKAGE_PATH=
	if [[ -n $_mirror ]]; then
		PACKAGE_PATH=$(print -r -- "$_url_base" |
			sed -E "/\/(snapshots|[0-9]\.[0-9])\/($ARCH)\/*$/!d
				s!!/\1/packages/$(arch -s)/!;q")
	fi
d2197 2
a2198 1
		unpriv2 ftp -w 15 -Vao - "$HTTP_PROTO://ftp.openbsd.org/cgi-bin/ftplist.cgi?path=$HTTP_SETDIR" \
d2458 3
a2460 6
	# Create or update pkg.conf with the new package path, if any.
	if [[ -n $PACKAGE_PATH ]]; then
		grep -v '^[ 	]*installpath[ 	]*=' /mnt/etc/pkg.conf 2>/dev/null >/tmp/i/pkgconf
		print -r -- "installpath = $PACKAGE_PATH" >>/tmp/i/pkgconf
		cp /tmp/i/pkgconf /mnt/etc/pkg.conf
	fi
d2692 2
a2693 1
			"$HTTP_PROTO://ftp.openbsd.org/cgi-bin/ftpinstall.cgi?$_i" >/dev/null 2>&1 &
a2924 1
PACKAGE_PATH=
a2930 1
INSTALL_URL=
@


1.947
log
@Eliminate an error message by checking whether /tmp/i/hosts exists before
calling sed -i on it.  While there, use a stricter regular expression, as
suggested by halex.

Problem reported by Pedro Caetano.
ok mestre, halex; ok rpe for earlier version without regex tweak
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.946 2017/01/11 10:57:12 ajacoutot Exp $
d1428 1
a1428 2
		! unpriv -f "$_cfile" signify -Vep /etc/signify/openbsd-${VERSION}-base.pub \
			-x "$_cfile.sig" -m "$_cfile" &&
d1504 1
a1504 1
	local _file_list _prompt _mirror _url_base _err _tls _http_proto
a1505 1
	local _pubkey=/etc/signify/openbsd-${VERSION}-base.pub _f
d1591 1
a1591 1
	if unpriv -f $_sha signify -Vep $_pubkey -x $_sig -m $_sha >/dev/null 2>&1; then
d2937 1
@


1.946
log
@typo: verfied -> verified

ok jmc@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.945 2017/01/10 17:50:58 deraadt Exp $
a2716 3
	# Remove entry for ftp.openbsd.org before final hosts file is created.
	sed -i '/129.128.5.191/d' /tmp/i/hosts

d2723 2
@


1.945
log
@whitespace
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.944 2017/01/10 00:15:16 bluhm Exp $
d1596 1
a1596 1
		echo "Unable to get a verfied list of distribution sets."
@


1.944
log
@When installing with a dhcp server that does not provide domain-name
and name-server information, the user was not asked for this
configuration.  Do not assign a default value to _dn and _ns before
the values are checked with -n in donetconfig().
Fix from halex@@; tested and OK rpe@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.943 2017/01/09 19:42:32 rpe Exp $
d1614 1
a1614 1
	
@


1.943
log
@Use a verified list of distribution set files extracted from
the SHA256.sig file which is signed by the OpenBSD project.
Deny the use of mirror servers where the verification fails.

Site specifc sets (siteXX.tgz and siteXX-hostname.tgz) or self
compiled sets in local setups are still supported by using the
index.txt file. Files listed in SHA256.sig override any file
listed in index.txt.

Support http://server and https://server as answers to the
"HTTP Server?" question. This allows a user to control the
logic used to download the set files on architectures that
have tls support for ftp(1).

'server' --> Use https for the sets download. If the server
does not support https, fall back to http but only after
user confirmation.

'https://server'--> Use https only for the sets download.

'http://server' --> Use http only for the sets download.

NOTE: If the autoinstall(8) feature is used, the installer
aborts the installation or upgrade in the following cases:
- a mirror server provides an invalid SHA256.sig file
- 'server' is used, https fails and the question to confirm
  the fallback to http is not answered in the response file.
- 'https://server' is used but ftp(1) has no tls support.
- 'https://server' is used but not supported by the server.

Suggested by, in joint work with and OK deraadt@@
Feedback, testing and OK tb@@
positive feedback halex@@ for the http/https part
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.942 2017/01/04 13:47:29 rpe Exp $
d1783 1
a1783 1
	resp="${_dn:=$(get_fqdn)}"
d1794 1
a1794 1
	resp="${_ns:=none}"
@


1.942
log
@Support https for the url to the autopartitioning template for
disklabel on platforms that have tls enabled ftp(1) including
error handling in case ftp(1) doesn't have it.

OK tb@@ halex@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.941 2017/01/04 13:39:52 rpe Exp $
d1505 3
a1507 2
	local _file_list _prompt _mirror _url_base _err _idx=/tmp/i/index.txt
	local _idx_url _rc
d1523 1
a1523 1
	# Get server IP address or hostname.
d1541 11
a1551 2
		+([A-Za-z0-9\:.\[\]_-]))
			HTTP_SERVER=$resp
d1576 1
a1576 1
	_url_base="$HTTP_PROTO://$HTTP_SERVER/$HTTP_DIR"
d1578 7
a1584 16
	# Get list of files from the server.
	# Assumes index file is "index.txt" for http (or proxy).
	# We can't use index.html since the format is server-dependent.
	# If ftp(1) has tls, fetch index.txt via https. If that fails
	# tell the user about it and switch to http.
	rm -f $_idx
	if $FTP_TLS; then
		_idx_url=$_url_base/index.txt
		_err=$(unpriv -f $_idx ftp -w 15 -Vo $_idx "$_idx_url" 2>&1)
		_rc=$?

		# Consider the https connect failed either if it was refused by
		# the server, or it took longer than -w sec (exit code 2).
		if ( (($_rc == 1)) && [[ $_err == *'Connection refused'* ]] ) ||
			(($_rc == 2)); then
			ask_yn "Unable to connect using https. Use http instead?" ||
d1587 13
d1603 9
a1611 5
	# Create the list of files by either using the index.txt downloaded
	# before or by fetching it via http.
	[[ -s $_idx ]] || unpriv -f $_idx ftp -VMo $_idx "$_url_base/index.txt"
	_file_list=$(sed "s/^.* //;s/$(echo '\r')//" $_idx)
	rm -f $_idx
d1613 2
@


1.941
log
@Enforce https for connections to ftplist.cgi and ftpinstall.cgi on
platforms that have tls enabled ftp(1).

OK tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.940 2017/01/03 19:33:48 rpe Exp $
d389 4
@


1.940
log
@Add https support to the OpenBSD installer.

The sets are downloaded using https per default. If the server does
not support https, the installer offers falling back to http after
asking for confirmation.

NOTE: Depending on the setup, people using autoinstall(8) might
need to add this new installer question to the response file.

   Unable to connect using https. Use http instead = yes|no

Joint work with and 'go for it' from deraadt@@
Tested from and OK tb@@
Feedback and OK for the approach halex@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.939 2016/12/30 22:59:12 rpe Exp $
d2173 1
a2173 1
		unpriv2 ftp -Vao - "http://ftp.openbsd.org/cgi-bin/ftplist.cgi?path=$HTTP_SETDIR" \
d2669 2
a2670 2
		[[ -n $_i ]] && unpriv2 ftp -Vao - \
			"http://ftp.openbsd.org/cgi-bin/ftpinstall.cgi?$_i" >/dev/null 2>&1 &
@


1.939
log
@Switch the connection to ftp.openbsd.org from using the ip address
to hostname as preparation for an upcoming change.

But to ensure proper name resolution in case dns is not available
yet, add an entry to the hosts file. After an installation, remove
it so it does not end up in the final hosts file. Not needed for
upgrades because the file is not copied to the upgraded system.

OK deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.938 2016/12/28 11:11:13 rpe Exp $
d76 1
a76 1
	sed -n 's,^http://\([[A-Za-z0-9\:_][]A-Za-z0-9:._-]*\),\1,p' \
d1501 2
a1502 1
	local _file_list _prompt _mirror _url_base
d1562 1
a1562 1
	_url_base="http://$HTTP_SERVER/$HTTP_DIR"
d1567 23
a1589 2
	_file_list=$(unpriv ftp -Vo - "$_url_base/index.txt" |
		sed "s/^.* //;s/$(echo '\r')//")
d2930 9
@


1.938
log
@Replace literal ^M with $(echo '\r') to avoid cluttering diffs.

OK halex@@
fine for deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.937 2016/12/27 09:17:52 jca Exp $
d2145 3
d2151 1
a2151 3
		# ftp.openbsd.org == 129.128.5.191 and will remain at
		# that address for the foreseeable future.
		unpriv2 ftp -Vao - "http://129.128.5.191/cgi-bin/ftplist.cgi?path=$HTTP_SETDIR" \
d2648 1
a2648 1
			"http://129.128.5.191/cgi-bin/ftpinstall.cgi?$_i" >/dev/null 2>&1 &
d2670 3
@


1.937
log
@Remove user uucp and group news from base.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.936 2016/12/19 19:59:38 rpe Exp $
d1566 2
a1567 1
	_file_list=$(unpriv ftp -Vo - "$_url_base/index.txt" | sed 's/^.* //;s///')
d2960 2
a2961 1
	/$AI_MODE -af /tmp/ai/ai.$AI_MODE.conf 2>&1 </dev/null | sed 's/^.*//;w/tmp/ai/ai.log'
@


1.936
log
@Revert r1.934 to unbreak autoinstall
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.935 2016/12/19 18:52:54 rpe Exp $
d1814 1
a1814 1
		root|daemon|operator|bin|sshd|uucp|www|nobody|ftp)
@


1.935
log
@- no need to export the TERM variable twice
- re-format case-block
- unquote single word default answer
- use 'break' instead of return to leave (same effect here, but
  needed later when the function is no function anymore)
- use -q option with kbd to limit output to warnings/errors only

discussed with and OK krw@@ tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.934 2016/12/18 18:15:14 rpe Exp $
d1465 1
a1465 1
		! ask_yn "$_issue.\nContinue without verification?"; then
@


1.934
log
@Split _issue msg and "Continue without verification?" question.

Prodded by and OK aja@@
OK halex@@ krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.933 2016/11/25 21:13:58 rpe Exp $
d1689 1
a1689 1
		export TERM=$resp
d1694 1
a1694 1
			ask "Choose your keyboard layout ('?' or 'L' for list)" "default"
d1696 9
a1704 3
			[lL\?]) echo "Available layouts: $_layouts";;
			default) return;;
			*)	kbd $resp && { echo $resp >/tmp/i/kbdtype; return; };;
@


1.933
log
@The build systems now uses the user build and the group wobj.
Add them to bsd.rd and set the ownership and permissions of
/usr/obj and /usr/xobj accordingly.

feedback and OK tb@@
Looks good deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.932 2016/11/24 14:35:43 krw Exp $
d1465 1
a1465 1
		! ask_yn "$_issue. Continue without verification?"; then
@


1.932
log
@Don't manually add a route to an alias IP via 127.0.0.1. This is
now automatically handled by the kernel.

The same change was made to /etc/netstart in 5.5 with r1.139.

Should fix the (U)pgrade problem reported on bugs@@ by Clint Pachl.

ok mpi@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.931 2016/11/14 21:34:39 rpe Exp $
d2425 1
a2425 1
	# proper ownership (root:wsrc) and permissions during install.
d2427 7
a2433 5
		for _d in /mnt/usr/{obj,src,xobj}; do
			mkdir -p $_d
			chmod 775 $_d
			chown root:wsrc $_d
		done
@


1.931
log
@Ensure, that the root disk question is added to the response file
mail.

found by and OK tb@@
OK halex@@ krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.930 2016/11/05 09:14:36 rpe Exp $
a2054 1
				[ "$alias" ] && rtcmd=";route -qn add -host $name 127.0.0.1"
d2067 1
a2067 1
			cmd="$cmd $ext1 $ext2$rtcmd" rtcmd=
@


1.930
log
@Remove the obj, xobj and src directories from the base set.
The installer will create these directories during install.
So local setups will not get overwritten during upgrades.

idea from and OK deraadt@@
with help from and OK tb@@
feedback from and no objections halex@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.929 2016/10/30 13:27:05 rpe Exp $
d1948 2
d1952 1
a1952 2
		_ask "Which disk is the root disk? ('?' for details)" \
			$_default || continue
d1968 2
@


1.929
log
@Search for and create a prefetch area only for nonlocal sources.

This enables the installer to verify local set files even if the
prefetch area would not fit on the local disk.

OK krw@@ on a similar diff
Idea from and OK naddy@@
Feedback and OK tb@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.928 2016/10/29 18:36:12 rpe Exp $
d2385 1
a2385 1
	local _dev _mp _fstype _rest
d2421 10
@


1.928
log
@Fix an issue found by naddy@@ where the installer was not able
to fetch local sets without a SHA256.sig file in a directory
unreachable by the unprivileged users. The missing SHA256.sig
file caused an early exit from the for-loop where the _unpriv
variable is unset in case of local sets.

- Move the check of the set location (local/net) to the top
- Set the ftp command title based on the _srclocal variable
- Remove the now unnecessary second _unpriv=

OK naddy@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.927 2016/10/28 17:07:34 rpe Exp $
d1385 6
a1390 5
		# Find a filesystem to store the prefetched sets. Prefer file-
		# systems which are not used during extraction. They need to
		# have 512 MB free space. Otherwise use any other filesystem
		# having 2 GB free space to prevent overflow during extraction.
		_tmpfs=$( (
d1404 7
a1410 5
		if [[ -d $_tmpfs ]]; then
			! _tmpsrc=$(tmpdir "$_tmpfs/sets") &&
			_issue="Cannot create prefetch area" && break
		else
			_issue="Cannot determine prefetch area" && break
@


1.927
log
@- move SHA256 SHA256.sig h fail from _tmpsrc to /tmp
- cleanup SHA256 and SHA256.sig before download
- move assignment of _cfile and _srclocal to the top

In a later step, this allows verification of local sets without the
need of a prefetch area which is not used in this case anyway.

Idea from and OK naddy@@
OK krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.926 2016/10/23 08:42:58 rpe Exp $
d1335 3
d1414 1
a1414 1
		[[ $_src == file://* ]] && _srclocal=true _t='Verifying ' _unpriv=
d1470 1
a1470 1
		[[ -f $_tmpsrc/$_f ]] && _fsrc="file://$_tmpsrc/$_f" _unpriv=
@


1.926
log
@Exit autoinstall in case of missing / or duplicate mountpoints.
This also covers the case when a template is rejected by disklabel.

OK krw
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.925 2016/10/09 10:20:53 rpe Exp $
d1332 2
a1333 2
		_tmpfs _tmpsrc _cfile _fsrc _unver _t _issue _srclocal
	local _unpriv=unpriv
d1407 3
a1409 2
		_cfile=$_tmpsrc/SHA256
		_srclocal=false
d1423 1
a1423 1
			rm -f "$_tmpsrc/h" "$_tmpsrc/fail"
d1429 3
a1431 3
			( $_unpriv ftp -D "$_t" -Vmo - "$_src/$_f" || >"$_tmpsrc/fail" ) |
			( $_srclocal && unpriv2 sha256 >"$_tmpsrc/h" ||
				unpriv2 -f "$_tmpsrc/h" sha256 -ph "$_tmpsrc/h" >"$_tmpsrc/$_f" )
d1434 1
a1434 1
			if [[ -f $_tmpsrc/fail ]]; then
d1445 1
a1445 1
			if fgrep -qx "SHA256 ($_f) = $(<$_tmpsrc/h)" "$_cfile"; then
@


1.925
log
@Re-enable fetching sets from local sources (disk, cdrom, nfs) as root.
It's the users responsibility to ensure the integrity of these files!

Problem found by Laurence Tratt who placed the sets in his home dir
where the unprivileged users now used by the installer weren't able
to read them from.

discussed with deraadt@@
OK krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.924 2016/09/25 15:48:15 rpe Exp $
d431 1
a431 1
		return 1
d458 1
a458 1
			return 1
@


1.924
log
@Tweak/add comments.

with input from and OK tb
OK halex krw
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.923 2016/09/25 06:06:52 rpe Exp $
d1333 1
d1410 1
a1410 1
		[[ $_src == file://* ]] && _srclocal=true _t='Verifying '
d1413 1
a1413 1
		! unpriv ftp -D "$_t" -Vmo - "$_src/SHA256.sig" >"$_cfile.sig" &&
d1428 1
a1428 1
			( unpriv ftp -D "$_t" -Vmo - "$_src/$_f" || >"$_tmpsrc/fail" ) |
d1466 1
a1466 1
		[[ -f $_tmpsrc/$_f ]] && _fsrc="file://$_tmpsrc/$_f"
d1468 1
a1468 1
		*.tgz)	unpriv ftp -D Installing -Vmo - "$_fsrc" | tar -zxphf - -C /mnt
d1475 1
a1475 1
		*)	unpriv ftp -D Installing -Vmo - "$_fsrc" >"/mnt/$_f"
@


1.923
log
@Tweak addel(), rmel() and bsort() to not emit a leading/trailing blank.

OK tb krw
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.922 2016/09/22 20:48:37 rpe Exp $
d63 1
d183 2
a184 2
# Echo the file $1 to standard output, skipping any lines that begin with a
# '#'. i.e. strip comment lines from the file.
d286 1
a286 1
# Return list of disk devices.
d291 1
a291 1
# Return list of CDROM devices.
d383 1
d415 1
d666 4
a669 3
# Ask for user input, which is returned in $resp.
# Any parameters are passed on to _ask(), which is called
# repeatedly until it succeds.
d675 1
a675 1
# Ask the user for a y or n, and insist on 'y', 'yes', 'n' or 'no'.
d677 1
a677 1
# Exit code: yes => 0, no => 1
d2453 2
a2454 1
	# Ask for/set the system hostname and add the hostname specific siteXX set.
d2464 2
a2465 2
	# If there's network connectivity, fetch list of mirror servers and installer
	# choices from previous runs.
d2484 2
a2485 1
	# Ask user about daemon startup on boot, X Window usage and console setup.
d2568 2
a2569 1
	# Create a skeletal /etc/fstab which is usable for the installation process.
d2578 2
a2579 1
	# Ask the user for locations, and install whatever sets the user selected.
d2738 2
a2739 1
	# Fetch the list of mirror servers and installer choices from previous runs.
d2758 2
a2759 1
	# Ask the user for locations, and install whatever sets the user selected.
a2766 1
#
d2769 2
a2770 4
# Some may require machine dependent routines, which may
# call functions defined above, so it's safest to put this
# code here rather than at the top of the file.
#
d2789 2
@


1.922
log
@The tape install method is gone for a while already.
Remove leftovers.

OK krw halex deraadt
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.921 2016/09/22 20:45:22 rpe Exp $
d110 1
a110 1
	echo -n "$_a "
d133 1
a133 2
	echo -n "$*"
	isin "$_a" $* || echo -n " $_a"
d139 1
a139 1
	local _a=$1 _b
d143 1
a143 1
		[[ $_a != $_b ]] && echo -n "$_b "
d145 1
@


1.921
log
@vi is not available on the install media.
Besides ... real men use ed!

OK krw halex deraadt
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.920 2016/09/16 15:35:05 krw Exp $
d2400 1
a2400 1
		for _dev in $(get_dkdevs) $(get_cddevs) $MTDEVS; do
a2802 1
#	MDMTDEVS    - '/^[cms]t[0-9][0-9]* /s/ .*//p'
a2867 1
MTDEVS=$(scan_dmesg "${MDMTDEVS:-/^[cms]t[0-9][0-9]* /s/ .*//p}")
@


1.920
log
@Revert last. -f is a bad bad idea here.

ok deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.919 2016/09/16 13:28:20 krw Exp $
d2894 1
a2894 3
# Decide upon an editor.
: ${EDITOR:=ed}
[[ -x /usr/bin/vi ]] && EDITOR=vi
@


1.919
log
@Use 'umount -f' so failing to umount root does not blow up install/upgrade
while root (sic) causes are probed.

Problem reported by RD Thrush via bugs@@ and reproduced locally.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.918 2016/09/13 21:25:29 halex Exp $
d2740 1
a2740 1
	umount -f /mnt || { echo "Can't umount $ROOTDEV!"; exit; }
@


1.918
log
@"Make disk selection dumb again", or at least make the change less
intrusive. Default to the first available disk, skipping to the next
(and so on), should the selected one be determined unsuitable for the
install or upgrade taking place.

"please commit" deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.917 2016/09/11 03:16:52 deraadt Exp $
d2740 1
a2740 1
	umount /mnt || { echo "Can't umount $ROOTDEV!"; exit; }
@


1.917
log
@a lonely little space
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.916 2016/09/10 22:34:17 rpe Exp $
a1932 23
# From the supplied list of devices, determine a single device suitable
# for $MODE.
# On success, prints the device name and returns 0
# On failure, prints an error message and returns 1
find_root() {
	local _d

	for _d; do
		[[ $MODE == upgrade ]] && ! is_rootdisk $_d && continue
		echo $_d
	done |
	(
		! read first && echo "No root disk found" && exit 1

		! read second && echo $first && exit

		echo "Multiple potential root devices found:" \
			$(echo $first $second; cat)"."
		echo "Please specify one."
		exit 1
	)
}

d1935 1
d1939 1
a1939 1
			auto || continue
d1943 8
a1950 7
		auto)	echo "Scanning disks"
			resp=$(find_root $(get_dkdevs)) &&
				echo "Using $resp as root disk" && break
			echo "$resp"
			;;
		*)	isin "$resp" $(get_dkdevs) && break
			echo "no such disk"
@


1.916
log
@Ensure that a previous cdrom install method is passed through
to install_sets() and that it is presented as default answer.

- fix pattern in waitcgiinfo() to match method=cd0.
- use a separate variable _im to set INSTALL_METHOD
  resp might get overwritten in install_cdrom()

OK halex
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.915 2016/09/10 17:18:30 rpe Exp $
d1307 1
a1307 1
		sleep 1 
@


1.915
log
@Ensure that previous installer choices are available during upgrades
by moving waitcgiinfo() from install_http() to before install_sets()
in do_upgrade().

OK halex
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.914 2016/09/10 15:14:52 rpe Exp $
d82 3
a84 3
		method=+([a-z]))	CGI_METHOD=$_val;;
		TIME=+([0-9]))		CGI_TIME=$_val;;
		TZ=+([-_/+[:alnum:]]))	CGI_TZ=$_val;;
d2286 1
a2286 1
	local _cddevs=$(get_cddevs) _d=$CGI_METHOD _locs="disk http" _src
d2313 2
a2314 1
				install_cdrom $resp && INSTALL_METHOD=$resp
@


1.914
log
@Ensure that install_files() returns successful if the _tmpsrc
directory does not exist. Otherwise, INSTALL_METHOD is not set
and this information is not sent to the cgi server.

OK halex
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.913 2016/09/10 08:10:19 rpe Exp $
a1490 1
	waitcgiinfo
d2765 3
@


1.913
log
@Fix detection if default route was set by dhclient in v4_defroute().
Route labels are now enclosed in double quotes (see r1.107 of
src/sbin/route/show.c).

OK claudio, krw
no objections halex
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.912 2016/09/04 12:36:33 halex Exp $
d1484 1
a1484 1
	[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc"
@


1.912
log
@Not having the root filesystem on the 'a' partition is
stupi^Wunfortunate, so stop asking.

deraadt@@ and krw@@ agrees
ok rpe@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.911 2016/09/04 10:15:04 halex Exp $
d1185 1
a1185 1
	[[ -n $_dr && $2 == DHCLIENT && -f /tmp/i/dhclient.conf ]] && return
@


1.911
log
@Improve the auto disk selection and also apply it for installs as well
as for upgrades.

- For installs, find all and any disks available.
- For upgrades, look for 'a' partitions with the typical root filesystem
  directories in them.

In both cases, if one and only one match is found, it will be selected.

If no disk or multiple disks are found, the installer will require you
to specify a disk, be it by hand or by auto{install,upgrade}.conf.

ok rpe@@ krw@@ "Innovative." deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.910 2016/09/04 09:56:46 rpe Exp $
d2729 1
a2729 1
	# Have the user confirm that $ROOTDEV is the root filesystem.
a2730 7
	while :; do
		ask "Root filesystem?" $ROOTDEV
		resp=${resp##*/}
		[[ -b /dev/$resp ]] && break
		echo "$resp is not a block device."
	done
	ROOTDEV=$resp
@


1.910
log
@Move files created by root during install/upgrade in a subdir of
/tmp with proper permissions so that unprivileged programs can not
tamper with them.

positive feedback from deraadt
OK halex
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.909 2016/09/03 11:40:32 rpe Exp $
d1915 23
a1937 2
# Scan supplied disks and print the first one having a 4.2BSD 'a' partition.
# If none is found, prints nothing and returns nonzero.
d1942 13
a1954 6
		makedev $_d
		disklabel "$_d" | grep -q '^  a: .*4\.2BSD ' &&
			echo $_d && return
		rm -f /dev/{r,}$_d?
	done
	return 1
a1958 2
	local _auto
	[[ $MODE == upgrade ]] && _auto=auto
d1962 1
a1962 1
			$_auto $(get_dkdevs) || continue
d1966 4
a1969 3
		"$_auto")
			resp=$(find_root $(get_dkdevs)) && break
			echo "no disk found"
d1975 1
@


1.909
log
@Make the installer safer by fetching and verifying external data
as unprivileged users.

OK halex, tb, deraadt
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.908 2016/09/03 11:29:17 rpe Exp $
d169 1
a169 1
	local _l _cdir=/tmp/cdir _clist
d175 1
a175 1
		mkdir -p /tmp/cdir/"$_l"
d380 1
a380 1
	local _disk=$1 _f=$2 _dl=/disklabel.auto _op
d414 1
a414 1
	local _disk=$1 _fstab=/tmp/fstab.$1
d421 2
a422 2
	# /tmp/fstab.$_disk is created here with 'disklabel -F'.
	rm -f /tmp/*.$_disk
d426 1
a426 1
	if ! grep -qs ' / ffs ' /tmp/fstab.$ROOTDISK; then
d436 1
a436 1
				echo "$_pp $_mp $_rest" >>/tmp/fstab
d440 1
a440 1
			if [[ $_fstab != $(grep -l " $_mp " /tmp/fstab.*) ]]; then
d451 3
a453 3
			cat /tmp/fstab.$_rest >/etc/fstab
			rm /tmp/fstab.$_rest
			set -- $(grep -h " $_mp " /tmp/fstab.*[0-9])
d481 1
a481 1
	while ! mkdir /tmp/lock 2>/dev/null && sleep .1; do done
d486 1
a486 1
	rm -d /tmp/lock 2>/dev/null
d504 1
a504 1
		print -r -- "${1%%'?'*} = $2" >>/tmp/$MODE.resp
d515 1
a515 1
	[[ -f $_rf ]] && cp $_rf /ai.$_mode.conf && AI_MODE=$_mode && return
d554 1
a554 1
			if unpriv ftp -Vo - "$_url" >"/ai.$_mode.conf" 2>/dev/null; then
d583 1
a583 1
	unpriv ftp -Vo - "$_rf" >"/ai.$_mode.conf" 2>/dev/null && AI_MODE=$_mode
d608 2
a609 2
	# Find a suitable response in /ai.conf and remove it if found.
	mv /ai.conf /ai.conf.tmp
d617 1
a617 1
	done </ai.conf.tmp >/ai.conf
d636 1
a636 1
	lock; dmesg >/tmp/update; unlock
d642 1
a642 1
	lock; rm /tmp/update; unlock
d825 2
a826 2
	mv /etc/dhclient.conf /tmp/dhclient.conf
	mv /etc/resolv.conf.tail /tmp/resolv.conf.tail
d860 1
a860 1
		/tmp/hosts 2>/dev/null
d862 1
a862 1
	echo "$_addr $_name" >>/tmp/hosts
d948 1
a948 1
		echo "$_resp" >>/tmp/mygate
d1079 1
a1079 1
	rm -f /tmp/mygate
d1091 1
a1091 1
		_hn=/tmp/hostname.$_if
d1135 3
a1137 3
			grep -qs "^up" /tmp/hostname.$_vd ||
				echo "up" >>/tmp/hostname.$_vd
			chmod 640 /tmp/hostname.$_vd
d1167 1
a1167 1
		NIFS=$(ls -1 /tmp/hostname.* 2>/dev/null | grep -c ^)
d1185 1
a1185 1
	[[ -n $_dr && $2 == DHCLIENT && -f /tmp/dhclient.conf ]] && return
d1191 1
a1191 1
		route -n add -inet -host default "$resp" && { echo "$resp" >>/tmp/mygate; break; }
d1638 1
a1638 1
	local _dev=$1 _opts _file=/tmp/parts.$1 _parts
d1687 1
a1687 1
			*)	kbd $resp && { echo $resp >/tmp/kbdtype; return; };;
d1701 1
a1701 1
	# /tmp/resolv.conf.shadow, mv any such file to /tmp/resolv.conf
d1705 2
a1706 2
	if [[ -f /tmp/resolv.conf.shadow ]]; then
		mv /tmp/resolv.conf.shadow /tmp/resolv.conf
d1713 1
a1713 1
		done </tmp/resolv.conf
d1727 1
a1727 1
	# Get & add nameservers to /tmp/resolv.conf. Don't ask if there's only
d1739 1
a1739 1
		echo "lookup file bind" >/tmp/resolv.conf
d1741 1
a1741 1
			echo "nameserver $_ns" >>/tmp/resolv.conf
d1743 1
a1743 1
		cp /tmp/resolv.conf /tmp/resolv.conf.shadow
d2138 1
a2138 1
# Create a skeletal but useful /etc/fstab from /tmp/fstab by stripping all
d2184 1
a2184 1
	done </tmp/fstab >/etc/fstab
d2325 1
a2325 1
		cp /mnt/etc/ttys /tmp/ttys
d2328 1
a2328 1
			-e "/$CTTY/s/off.*/on secure/" /tmp/ttys >/mnt/etc/ttys
d2384 3
a2386 3
		grep -v '^[ 	]*installpath[ 	]*=' /mnt/etc/pkg.conf 2>/dev/null >/tmp/pkgconf
		print -r -- "installpath = $PACKAGE_PATH" >>/tmp/pkgconf
		cp /tmp/pkgconf /mnt/etc/pkg.conf
d2422 1
a2422 1
	prep_root_mail /tmp/$MODE.resp "$(hostname) $MODE response file"
d2438 1
a2438 1
	$AUTO && >/ai.done
d2491 1
a2491 1
	rm -f /tmp/fstab*
d2498 1
a2498 1
			rm -f /tmp/fstab
d2553 1
a2553 1
	done >>/tmp/fstab
d2570 1
a2570 1
	sed -i "s#\(${_mp:-/} ffs rw\)#\1,wxallowed#" /tmp/fstab
d2608 2
a2609 2
		/mnt/etc/ttys >/tmp/ttys
	mv /tmp/ttys /mnt/etc/ttys
d2618 2
a2619 2
	# Move configuration files from /tmp to /mnt/etc.
	hostname >/tmp/myname
d2631 1
a2631 1
	if [[ -f /tmp/hosts ]]; then
d2639 2
a2640 2
		done </tmp/hosts >>/mnt/etc/hosts
		rm /tmp/hosts
d2645 1
a2645 1
	[[ -f /tmp/$_f ]] && { cat /tmp/$_f >>/mnt/etc/$_f; rm /tmp/$_f; }
d2647 1
a2647 1
	# Possible files to copy from /tmp: fstab hostname.* kbdtype mygate
d2650 1
a2650 1
	(cd /tmp; for _f in fstab hostname* kbdtype my* ttys *.conf *.tail; do
d2722 1
a2722 1
		cp $_f /tmp/${_f##*/}
d2724 1
a2724 1
	hostname $(stripcom /tmp/myname)
a2786 1

d2806 1
a2806 1
rm -df /tmp/lock
d2811 1
a2811 1
rm -f /tmp/update
d2818 2
a2819 2
			if [[ -e /tmp/update && "$(dmesg)" != "$(</tmp/update)" ]]; then
				dmesg >/tmp/update
d2840 1
a2840 1
CGI_INFO=/tmp/cgiinfo
d2847 3
a2849 3
HTTP_SEC=/tmp/httpsec
HTTP_LIST=/tmp/httplist
WLANLIST=/tmp/wlanlist
d2921 1
a2921 1
	rm -f /ai.done
d2923 4
a2926 4
	/$AI_MODE -af /ai.$AI_MODE.conf 2>&1 </dev/null | sed 's/^.*//;w/ai.log'
	if [[ -f /ai.done ]]; then
		# Email ai.log to root on next boot.
		prep_root_mail /ai.log "$(hostname) $AI_MODE log"
d2929 1
a2929 1
		echo "failed; check /ai.log"
d2933 1
a2933 1
	cp $RESPFILE /ai.conf || exit
d2940 1
a2940 1
rm -f /tmp/$MODE.resp
@


1.908
log
@Add a do_as() function that executes commands as unprivileged user
and ensures that no processes of this user remain active afterwards.
Optionally, it creates a file, that is owned by the user only for
this command execution. Afterwards it's chown'd by root.

Add wrapper functions for do_as(). unpriv() uses the _sndio user
and unpriv2() uses the _file user to execute commands.

OK halex, tb, deraadt
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.907 2016/09/02 21:42:28 halex Exp $
d388 1
a388 1
		if ftp -Vo $_dl "$resp" && [[ -s $_dl ]]; then
d554 1
a554 1
			if ftp -Vo "/ai.$_mode.conf" "$_url" 2>/dev/null; then
d583 1
a583 1
	ftp -Vo "/ai.$_mode.conf" "$_rf" 2>/dev/null && AI_MODE=$_mode
d1408 1
a1408 1
		! ftp -D "$_t" -Vmo "$_cfile.sig" "$_src/SHA256.sig" &&
d1412 1
a1412 1
		! signify -Vep /etc/signify/openbsd-${VERSION}-base.pub \
d1423 3
a1425 3
			( ftp -D "$_t" -Vmo - "$_src/$_f" || >"$_tmpsrc/fail" ) |
			( $_srclocal && sha256 >$_tmpsrc/h ||
				sha256 -ph "$_tmpsrc/h" >"$_tmpsrc/$_f" )
d1463 1
a1463 1
		*.tgz)	ftp -D Installing -Vmo - "$_fsrc" | tar -zxphf - -C /mnt
d1470 1
a1470 1
		*)	ftp -D Installing -Vmo "/mnt/$_f" "$_fsrc"
d1555 1
a1555 1
	_file_list=$(ftp -Vo - "$_url_base/index.txt" | sed 's/^.* //;s///')
d2123 1
a2123 1
		ftp -Vao - "http://129.128.5.191/cgi-bin/ftplist.cgi?path=$HTTP_SETDIR" \
d2602 1
a2602 1
		[[ -n $_i ]] && ftp -Vao - \
@


1.907
log
@for an upgrade disk selection, present a default alternative of 'auto',
which will scan the available disks, selecting the first disk with an
'a' partition of type 4.2BSD

ok deraadt@@ krw@@ phessler@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.906 2016/08/23 16:49:48 krw Exp $
d1276 45
@


1.906
log
@Type. 'if' != 'lf'. Fixes error message and setting hostname from dhcp lease
during install.

Spotted & diff from Patrik Lundin. Thanks!
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.905 2016/08/21 19:22:15 halex Exp $
d1870 14
d1886 2
d1891 1
a1891 1
			$(get_dkdevs | sed 's/ .*//') || continue
d1893 5
a1897 1
		"?")	diskinfo $(get_dkdevs)
a1898 1
		'')	;;
@


1.905
log
@Make lease_value() unescape quoted strings. To be fully compliant, we
should unvis() it too, but I think this is enough, at least for now.

ok krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.904 2016/08/21 18:47:01 rpe Exp $
d542 1
a542 1
		_hn=$(lease_value $_if host-name)
@


1.904
log
@tweak previous

OK halex, krw
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.903 2016/08/17 13:53:20 krw Exp $
d234 2
d242 4
a245 1
		sed -E '/^ *(option )?'"$_o"' (.*);$/!d;s//\2/;s/^"//;s/"$//;q' "$_lf" | grep ^ && return
@


1.903
log
@Use more dhcp info when trying autoinstall/autoupgrade.

For the file name try 'filename' then 'option bootfile-name'.

For the server name try 'server-name' then 'option tftp-server-name' then
'next-server'.

Original idea from Patrick Lundin. Suggestions from rpe@@.

Tweaks & ok halex@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.902 2016/07/23 17:55:45 deraadt Exp $
d530 1
a530 1
		[[ $_aifile = ?(*/)auto_@@(install|upgrade) ]] || _aifile=
@


1.902
log
@Back out the automatic pkg.conf installpath changes; because pkg_add has
an immature heuristic for "what is a release and what is a snapshot".
This change maybe improved the post-release experience, but it damages the
pre-release experience, which may result in less effective pre-release
testing, which risks creating poor releases, which may result in poor
post-release experiences.
Specific case: subtle breakage to fw_update.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.901 2016/05/27 21:13:17 deraadt Exp $
d231 13
d505 1
a505 1
	local _rf _if _mac _mode _lf _hn _path
d528 10
a537 4
		export AI_SERVER=$(sed "/^ *next-server /!d;s///;s/;$//;q" $_lf)
		_mode=$(sed -E '/^ *filename "(.*\/)?auto_(install|upgrade)";$/!d;s//\2/;q' $_lf)
		_path=$(sed -E '/^ *filename "(.*\/)[^/]+";$/!d;s//\1/;q' $_lf)
		_hn=$(sed -E '/^ *option host-name "(.*)";$/!d;s//\1/;q' $_lf)
d556 1
a556 1
		[[ -z $AI_SERVER ]] && echo "Could not determine next-server."
@


1.901
log
@whitespaces grow bsd.rd, you know
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.900 2016/05/27 20:17:39 rpe Exp $
d1498 1
a1498 1
				s!!/%c/packages/%a/!;q")
@


1.900
log
@During install, set new 'wxallowed' mount option for the filesystem
/usr/local resides on.

idea from and ok deraadt
with feedback from halex
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.899 2016/05/26 15:27:09 rpe Exp $
d422 1
a422 1
			if [[ $_fstab != $(grep -l " $_mp " /tmp/fstab.*) ]]; then 
d1648 1
a1648 1
	# interface and if it's managed by dhclient and if the domain name is 
d2358 1
a2358 1
	
d2360 1
a2360 1
	
d2363 1
a2363 1
	
d2367 1
a2367 1
	
d2369 1
a2369 1
	
d2376 1
a2376 1
	
d2383 1
a2383 1
	
d2386 1
a2386 1
	
d2390 1
a2390 1
	
d2393 1
a2393 1
	
d2395 1
a2395 1
	
d2398 1
a2398 1
	
d2401 1
a2401 1
	
d2404 1
a2404 1
	
d2422 1
a2422 1
	
d2429 1
a2429 1
	
d2433 1
a2433 1
	
d2438 1
a2438 1
	
d2466 1
a2466 1
	
d2469 1
a2469 1
	
d2472 1
a2472 1
	
d2475 1
a2475 1
	
d2483 1
a2483 1
	
d2493 1
a2493 1
	
d2506 1
a2506 1
	
d2517 1
a2517 1
	
d2522 1
a2522 1
	
d2524 1
a2524 1
	
d2529 1
a2529 1
	
d2532 1
a2532 1
	
d2537 1
a2537 1
	
d2541 1
a2541 1
	
d2554 1
a2554 1
	
d2558 1
a2558 1
	
d2565 1
a2565 1
	
d2567 1
a2567 1
	
d2570 1
a2570 1
	
d2579 1
a2579 1
	
d2588 1
a2588 1
	
d2593 1
a2593 1
	
d2600 1
a2600 1
	
d2607 1
a2607 1
	
d2622 1
a2622 1
	
d2626 1
a2626 1
	
d2630 1
a2630 1
	
d2638 1
a2638 1
	
d2641 1
a2641 1
	
d2644 1
a2644 1
	
d2647 1
a2647 1
	
d2650 1
a2650 1
	
d2654 1
a2654 1
	
d2657 1
a2657 1
	
d2660 1
a2660 1
	
@


1.899
log
@Rename variables to a less ambiguous name better matching their purpose.

OK krw
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.898 2016/05/22 19:12:21 rpe Exp $
d2478 5
@


1.898
log
@Rename variable $action (which is actually global) to AI_MODE.
While there, (re)set AI_MODE and AI_SERVER at the start of the
installer script.

OK krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.897 2016/05/20 17:28:43 rpe Exp $
d1491 1
a1491 1
	INSTALL=$_url_base
d2198 1
a2198 1
				install_cdrom $resp && METHOD=$resp
d2201 1
a2201 1
		[dD]*)	install_disk && METHOD=disk
d2203 1
a2203 1
		[hH]*)	isin http $_locs && install_http && METHOD=http
d2205 1
a2205 1
		[nN]*)	isin nfs $_locs && install_nfs && METHOD=nfs
d2211 1
a2211 1
		[[ -n $METHOD ]] && _d=$METHOD
d2505 1
a2505 1
		_i=${INSTALL:+install=$INSTALL&}
d2507 1
a2507 1
		_i=$_i${METHOD:+method=$METHOD}
d2752 2
a2753 2
INSTALL=
METHOD=
@


1.897
log
@Log questions and answers during install/upgrade in a format that can be
used as a response file for autoinstall(8). The result is emailed to the
root user on next boot. Passwords are not logged.

positive feedback deraadt, jung
OK krw, halex, sthen
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.896 2016/05/20 17:12:42 rpe Exp $
d493 1
a493 1
	action=
d497 1
a497 1
	[[ -f $_rf ]] && cp $_rf /ai.$_mode.conf && action=$_mode && return
d531 1
a531 1
				action=$_mode
d559 1
a559 1
	ftp -Vo "/ai.$_mode.conf" "$_rf" 2>/dev/null && action=$_mode
d561 1
a561 1
	[[ -n $action ]]
d2740 3
d2830 2
a2831 2
	echo "Performing non-interactive $action..."
	/$action -af /ai.$action.conf 2>&1 </dev/null | sed 's/^.*//;w/ai.log'
d2834 1
a2834 1
		prep_root_mail /ai.log "$(hostname) $action log"
@


1.896
log
@Move code to create unique filenames and to prepare a file
to be sent to root on reboot into separate functions.

positive feedback deraadt
OK krw, sthen, halex
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.895 2016/04/28 18:17:30 natano Exp $
d482 8
d644 1
d709 4
a712 1
		isin "$resp" $_dynlist done && break
d2333 3
d2843 3
@


1.895
log
@Replace /dev/bpf[0-9] with /dev/bpf and /dev/bpf0. The /dev/bpf node is
unused for now, but I plan to convert all programs in base to use it in
a future diff. /dev/bpf0 is for compatibility with existing binaries
and is to be removed after a transition period.

ok rpe krw, for the installer part
"Let's see it hit the tree." deraadt
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.894 2016/04/27 14:50:18 ajacoutot Exp $
d206 24
d2815 2
a2816 10
		# Generate unique filename and let rc.firsttime feed it to
		# whatever mail system we have at hand by then.
		while _lf=/mnt/var/log/ai.log.$RANDOM && [[ -e $_lf ]]; do done
		cp /ai.log $_lf
		chmod 600 $_lf
		_lf=${_lf#/mnt}
		cat <<__EOT >>/mnt/etc/rc.firsttime
( /usr/bin/mail -s '$(hostname) $action log' root <$_lf &&
	rm $_lf ) >/dev/null 2>&1 &
__EOT
@


1.894
log
@rc.firsttime -> rc.sysmerge for running sysmerge(8) after an upgrade.
While here, don't echo 'running sysmerge...' since that'd get us a mail each
time we upgrade even when nothing changed.

ok deraadt@@ rpe@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.893 2016/04/25 09:55:23 ajacoutot Exp $
a742 10

# Run dhclient, making sure there is a free bpf first.
dhclient() {
	local _i=0

	while makedev bpf$_i && ! </dev/bpf$_i; do
		((++_i < 50)) || return
	done 2>/dev/null
	/sbin/dhclient "$@@"
}
@


1.893
log
@In upgrade mode, automatically run sysmerge(8) in batch mode before fw_update(1).
Putting this at the beginning of the p2k16 hackathon so we can see if anything
breaks and to get feedback about the output etc
If sysmerge cannot merge/install a file automatically, login into the machine
and running it interactively will ask you what you want to do with it.

It may not stay in this exact form, but that's a first step and now is a good
time to get it in.

discussed with deraadt@@ for a while
ok rpe@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.892 2016/04/11 19:04:30 rpe Exp $
d2304 1
a2304 2
		echo 'echo "running sysmerge..."' >>/mnt/etc/rc.firsttime &&
		echo "/usr/sbin/sysmerge -b" >>/mnt/etc/rc.firsttime
@


1.892
log
@- In isin(), quote $_b to ensure it's treated as string not as pattern.
- Always quote the first argument to isin()

OK halex@@, krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.891 2016/04/11 18:47:05 rpe Exp $
d2303 3
a2321 2
	[[ $MODE == upgrade ]] && \
		echo "After rebooting, run sysmerge(8) to update your system configuration."
@


1.891
log
@Tweak bsort():
- make it clear in comment that it returns a unique list
- shift is only possible if argc > 0, otherwise return
- quote "$_b" in equality test forcing possible patterns being
  treated as strings

OK halex@@, krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.890 2016/04/09 15:14:47 rpe Exp $
d122 1
a122 1
		[[ $_a == $_b ]] && return 0
d270 1
a270 1
		isin ${_if%%+([0-9])} $_iflist || echo $_if
d1170 1
a1170 1
		isin $_s $DEFAULTSETS || continue
d1201 1
a1201 1
			isin $_f $_selected && echo "[X] $_f" || echo "[ ] $_f"
d1242 1
a1242 1
		isin $_f $_files || continue
d1244 1
a1244 1
		isin $_f $DEFAULTSETS "site$VERSION-$(hostname -s).tgz" &&
d1261 1
a1261 1
	isin INSTALL.$ARCH $_files ||
d1271 1
a1271 1
	_get_sets=$(for s in $THESETS; do isin $s $_get_sets && echo $s; done)
d1960 1
a1960 1
		if isin ${if%%+([0-9])} $(ifconfig -C); then
d2156 1
a2156 1
			isin $_src $_cddevs $_locs && _d=$_src && break
d2379 1
a2379 1
		if ! isin $ROOTDISK $DISKS_DONE; then
@


1.890
log
@Remove _tz as intermediate variable and use CGI_TZ directly.

Feedback from and OK halex@@
OK krw@@ for a similar diff
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.889 2016/04/09 11:03:42 rpe Exp $
d94 1
a94 1
# Sort and print provided arguments.
d96 1
a96 1
	local _l _a=$1 _b
d98 1
a98 1
	(($# > 0)) || return
a99 1
	shift
d101 5
a105 6
		if [[ $_a != $_b ]]; then
			if [[ $_a > $_b ]]; then
				_l="$_a $_l"; _a=$_b
			else
				_l="$_b $_l"
			fi
@


1.889
log
@Use _if for a single interface name and _ifs for a list of interface
names instead of _ifdev and _ifdevs.

OK krw@@ halex@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.888 2016/04/08 17:41:08 rpe Exp $
d1769 1
a1769 1
	local _zonefile=$1 _zonepath _zsed _tz _zoneroot=/usr/share/zoneinfo
d1784 1
a1784 4
	if [[ -n $CGI_TZ ]]; then
		_tz=$CGI_TZ
		[[ -n $_tz ]] && isin "$_tz" $(<$_zonefile) && TZ=$_tz
	fi
@


1.888
log
@Use _if instead of _ifs as variable name for single interface names.

OK krw@@, halex@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.887 2016/04/08 17:17:54 rpe Exp $
d267 1
a267 1
get_ifdevs() {
d462 1
a462 1
	local _rf _ifdev _mac _mode _lf _hn _path
d473 1
a473 1
	for _ifdev in ''; do
d475 3
a477 3
		set -- $(get_ifdevs netboot)
		(($# == 0)) && set -- $(get_ifdevs)
		(($# == 1)) && _ifdev=$1
d481 1
a481 1
			isin "$resp" $* && _ifdev=$resp && break
d483 2
a484 2
		[[ -n $_ifdev ]] && dhclient $_ifdev || break
		_lf=/var/db/dhclient.leases.$_ifdev
d496 1
a496 1
		_mac=$(ifconfig $_ifdev | sed 's/.*lladdr \(.*\)/\1/p;d')
d502 1
a502 1
				ifconfig $_ifdev delete down 2>/dev/null
d530 1
a530 1
	ifconfig $_ifdev delete down 2>/dev/null
d1016 1
a1016 1
	local _first _ifdevs _if _name _hn _vl=0 _vd _vi _p _tags
d1038 2
a1039 2
			'$(get_ifdevs)' \
			${_p:-'$( (get_ifdevs netboot; get_ifdevs) | sed q )'}
d1063 2
a1064 2
			_ifdevs=$(get_ifdevs)
			set -- $_ifdevs
d1073 1
a1073 1
			if ! (isin "$_vd" $_ifdevs && [[ $_vd != vlan+([0-9]) ]]); then
d2782 1
a2782 1
for _if in $(get_ifdevs dhcp); do
@


1.887
log
@Rename getdevname() to get_dkdev_name() to better reflect the actual
purpose and simplify the logic to remove the partition information
from the device name.

With help from and OK halex@@, krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.886 2016/04/02 13:52:04 rpe Exp $
d759 1
a759 1
	local _ifs=$1 _hn=$2
d764 1
a764 1
	ifconfig $_ifs group dhcp >/dev/null 2>&1
d766 1
a766 1
	dhclient -c /dev/stdin $_ifs <<__EOT
d826 1
a826 1
	local _ifs=$1 _name=$2 _hn=$3 _prompt _addr _mask
d828 1
a828 1
	if ifconfig $_ifs | grep -q 'groups:.* dhcp'; then
d831 1
a831 1
		set -- $(v4_info $_ifs)
d834 1
a834 1
			ifconfig $_ifs inet $_addr delete
d843 1
a843 1
	_prompt="IPv4 address for $_ifs? (${_prompt}or 'none')"
d851 1
a851 1
			dhcp_request $_ifs "$_name"
d856 3
a858 3
		ask_until "Netmask for $_ifs?" "${_mask:=255.255.255.0}"
		ifconfig $_ifs -group dhcp >/dev/null 2>&1
		if ifconfig $_ifs inet $_addr netmask $resp up; then
d912 1
a912 1
	local _ifs=$1 _name=$2 _hn=$3 _addr _prefixlen _prompt
d916 1
a916 1
	set -- $(v6_info $_ifs)
d919 2
a920 2
	ifconfig $_ifs inet6 >/dev/null 2>&1 && _prompt="or 'rtsol' "
	_prompt="IPv6 address for $_ifs? (${_prompt}or 'none')"
d926 3
a928 3
	rtsol)	ifconfig $_ifs inet6 >/dev/null 2>&1 || { echo "No INET6 support."; return; }
		ifconfig $_ifs up
		ifconfig $_ifs inet6 autoconf && echo "up\nrtsol" >>$_hn
d934 2
a935 2
	ask_until "IPv6 prefix length for $_ifs?" "${_prefixlen:=64}"
	ifconfig $_ifs inet6 $_addr prefixlen $resp up || return
d939 1
a939 1
	v6_defroute $_ifs
d954 1
a954 1
	local _ifs=$1 _hn=$2 _prompt _nwid _haswpa=0 _err
d957 2
a958 2
	ifconfig $_ifs -nwid -nwkey
	ifconfig $_ifs -wpa 2>/dev/null && _haswpa=1
d967 1
a967 1
			_nwid=$(ieee80211_scan $_ifs | sed -n "${resp}s/ .*//p")
d970 1
a970 1
		\?)	ieee80211_scan $_ifs |
d981 1
a981 1
		ifconfig $_ifs nwid "$_nwid"
d993 1
a993 1
				if _err=$(ifconfig $_ifs nwkey "$resp" 2>&1) &&
d1002 1
a1002 1
				if ifconfig $_ifs wpakey "$resp"; then
d1016 1
a1016 1
	local _first _ifdevs _ifs _name _hn _vl=0 _vd _vi _p _tags
d1042 2
a1043 2
		_ifs=$resp
		_hn=/tmp/hostname.$_ifs
d1048 1
a1048 1
		if [[ $_ifs == vlan+([0-9]) ]]; then
d1050 1
a1050 1
			_vi=$(ifconfig $_ifs 2>/dev/null |
d1068 1
a1068 1
			ask "Which interface:tag should $_ifs be on?" "${_vd:=$1}:$_vi"
d1092 3
a1094 3
			# Make sure a hostname.$_ifs is created with this info.
			ifconfig $_ifs destroy >/dev/null 2>&1
			ifconfig $_ifs vlan $_vi vlandev $_vd
d1097 1
a1097 1
			[[ ${_ifs##vlan} == $_vl ]] && ((_vl++))
d1101 2
a1102 2
		ifconfig $_ifs 2>/dev/null | grep -q "^[[:space:]]*ieee80211:" &&
			ieee80211_config $_ifs $_hn
d1107 2
a1108 2
		[[ -n $_first && $_first != $_ifs ]] &&
			ask "Symbolic (host) name for $_ifs?" $resp
d1111 2
a1112 2
		v4_config $_ifs $_name $_hn
		v6_config $_ifs $_name $_hn
d1116 1
a1116 1
			: ${_first:=$_ifs}
d2782 2
a2783 2
for _ifs in $(get_ifdevs dhcp); do
	set -- $(v4_info $_ifs)
d2785 1
a2785 1
	ifconfig $_ifs delete down -group dhcp 2>/dev/null
@


1.886
log
@Simplify defining the various set lists.

Feedback from and OK halex@@
OK krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.885 2016/04/02 13:34:48 rpe Exp $
d277 2
a278 2
getdevname() {
	local _dev=$1
d280 6
a285 9
	if [[ ${#_dev} == 18 && $_dev == +([0-9a-f]).[a-p] ||
		${#_dev} == 16 && $_dev == +([0-9a-f]) ]]; then
		# Lookup device name matching the disklabel UID.
		sysctl -n hw.disknames |
			sed -nE "s/^(.*,)*(.*):${_dev%.?}.*/\\2/p"
	else
		_dev=${_dev#/dev/}
		print -r -- "${_dev%[a-p]}"
	fi
d2095 1
a2095 1
		_dn=$(getdevname "$_dev")
@


1.885
log
@Remove unused variable.

OK krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.884 2016/04/02 12:23:46 rpe Exp $
d2766 3
a2768 7
THESETS="bsd bsd.rd bsd.mp $MDSETS"
: ${DEFAULTSETS:="bsd bsd.rd"}
for _set in base comp man game xbase xshare xfont xserv site; do
	THESETS="$THESETS ${_set}${VERSION}.tgz"
	isin $_set site && continue
	DEFAULTSETS="$DEFAULTSETS ${_set}${VERSION}.tgz"
done
@


1.884
log
@- merge install.sh into install.sub as do_install()
- merge upgrade.sh into install.sub as do_upgrade()
- delete install.sh and upgrade.sh
- make install.sub executable
- turn install and upgrade into symbolic links to install.sub
- add autoinstall symbolic link to install.sub
- change dot.profile to use these symlinks
- introduce a -m option to set MODE in install.sub
- alternativly set MODE and AUTO depending on PROGNAME
- execute the do_{install,upgrade) functions depending on $MODE

OK halex@@, krw@@
'go for it' deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.883 2016/03/05 17:18:27 rpe Exp $
a1390 1
			GOTSETS="$GOTSETS $_f"
@


1.883
log
@missed 'sed -i'

OK halex@@
@
text
@d1 2
a2 1
#	$OpenBSD: install.sub,v 1.882 2016/02/27 12:28:16 rpe Exp $
d64 1
a64 1
	echo "usage: ${0##*/} [-a] [-f filename]" >&2
d2333 306
d2652 2
d2655 1
a2655 1
while getopts "af:" opt; do
d2659 1
d2666 9
d2835 5
@


1.882
log
@Cleanup the list of usernames that are rejected during installation.

- sendmail, named, popa3d are not part of base anymore and their ports
versions use _<username>.

- _tftp_proxy and _ftp_proxy are used instead of the proxy user.

OK ajacoutot@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.881 2016/02/27 12:17:03 rpe Exp $
d813 2
a814 3
	sed "/^[0-9a-fA-F]*[$_delim].*[ 	]$_name\$/d" /tmp/hosts \
		>/tmp/hosts.new 2>/dev/null
	mv /tmp/hosts.new /tmp/hosts
@


1.881
log
@Shorter version that does the same.
Change description to better match the purpose of this function.

OK halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.880 2016/02/23 02:34:09 krw Exp $
d1708 1
a1708 3
		root|daemon|operator|bin|smmsp|popa3d)
			;;
		sshd|uucp|www|named|proxy|nobody|ftp)
@


1.880
log
@In the great pdisk churn we lost a pdisk pecularity in disk name
handling. "pdisk -l /dev/wd0c" used to work as well as "pdisk -l
/dev/rwd0c". The new, more fdisk-like, code does not accept the
former.

Adjust the install scripts to eliminate the use of "/dev/wd0c"
constructs and, like fdisk, simply use 'wd0'.

Fixes macppc installs to HFS partitioned disks.

Discovered and diff by rpe@@.

ok rpe@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.879 2016/02/20 12:08:55 rpe Exp $
d793 1
a793 1
# Convert a hex value passed as argument $1 to dotted decimal format.
d795 2
a796 6
	local _d _b

	for _b in $(echo ${1#0x} | sed 's/\(..\)/\1 /g'); do
		_d=$_d.$((0x$_b))
	done
	echo ${_d#.}
@


1.879
log
@Combine two sed calls into one.

OK krw@@, halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.878 2016/02/20 12:03:11 rpe Exp $
d298 1
a298 1
	local _c_hfs="pdisk -l /dev/${_disk}c"
@


1.878
log
@remove stray semicolon

OK krw@@, halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.877 2016/02/12 14:18:31 rpe Exp $
d1470 1
a1470 2
	_file_list=$(ftp -Vo - "$_url_base/index.txt" |
		sed 's/^.* //' | sed 's///')
@


1.877
log
@Uppercase global variable.

OK halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.876 2016/01/31 11:03:49 rpe Exp $
d1251 1
a1251 1
		isin $_f $_files || continue;
@


1.876
log
@- remove _d from local list which is a leftover from a previous change
- rename a -> _src and localize it

OK krw@@, halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.875 2016/01/25 23:46:54 rpe Exp $
d453 1
a453 1
	trap 'kill -KILL $cppid 2>/dev/null; echo; stty echo; exit 0' \
d2403 1
a2403 1
	cppid=$!
@


1.875
log
@localize _clist

feedback and OK halex@@
OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.874 2016/01/24 09:16:57 rpe Exp $
d2161 1
a2161 1
	local _cddevs=$(get_cddevs) _d _locs="disk http" _d=$CGI_METHOD
d2171 2
a2172 2
		for a in http $_cddevs nfs disk; do
			isin $a $_cddevs $_locs && _d=$a && break
@


1.874
log
@spacing

ok krw@@, halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.873 2016/01/24 09:13:57 rpe Exp $
d170 1
a170 1
	local _l _cdir=/tmp/cdir
a171 1
	set -A _clist
@


1.873
log
@- cleanup quoting in sed pattern
- use shell built-in read command instead of 'sed q'

OK krw@@, halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.872 2016/01/17 18:01:31 rpe Exp $
d119 1
a119 1
	local	_a=$1 _b
d131 1
a131 1
	local	_a=$1
a133 1

d141 1
a141 1
	local	_a=$1 _b
d171 1
d201 1
d216 1
d241 1
d258 1
d279 1
d554 1
d556 1
a657 1

d697 1
d724 1
d752 1
d769 1
a769 1
	dhclient -c /dev/stdin $_ifs << __EOT
a817 1

d1199 1
a1558 1

d1591 1
a1592 1
	export TERM=${TERM:-${MDTERM:-vt220}}
d1754 1
a1784 1

d2162 1
a2162 1
	local _cddevs=$(get_cddevs) _d _locs="disk http"
a2165 2
	_d=$CGI_METHOD

d2248 1
d2511 1
a2511 1
( /usr/bin/mail -s '$(hostname) $action log' root < $_lf &&
@


1.872
log
@Discard stderr of fdisk and pdisk.

disussed with and OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.871 2016/01/12 00:17:05 rpe Exp $
d69 1
a69 1
	local _key _val
d74 1
a74 1
	sed -n "s,^http://"'\([[A-Za-z0-9\:_][]A-Za-z0-9:._-]*\),\1,p' \
d76 2
a77 2
	set -- $(sed q $HTTP_LIST)
	: ${HTTP_SERVER:=${1%%/*}}
@


1.871
log
@The data for CGI_{METHOD,TIME,TZ} comes from an external source.
Validate before assignment.

with feedback from and OK halex@@
OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.870 2016/01/10 17:47:14 rpe Exp $
d320 1
a320 1
		$_cmd | grep -Eq "$_p_pttype"
d322 2
a323 1
		$_cmd | grep -Eq "$_p_pttype" && $_cmd | grep -Eq "$_p_part"
@


1.870
log
@replace test command with [[ ]]

OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.869 2016/01/10 17:44:35 rpe Exp $
d69 2
d79 7
a85 3
	CGI_METHOD=$(sed -n '/^method=/s///p' $CGI_INFO 2>/dev/null)
	CGI_TZ=$(sed -n '/^TZ=/s///p' $CGI_INFO 2>/dev/null)
	CGI_TIME=$(sed -n '/^TIME=/s///p' $CGI_INFO 2>/dev/null)
@


1.869
log
@simplify pattern

feedback halex@@
OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.868 2016/01/09 18:10:57 krw Exp $
d2382 1
a2382 1
			if test -e /tmp/update && [[ "$(dmesg)" != "$(</tmp/update)" ]]; then
d2492 1
a2492 1
		while _lf=/mnt/var/log/ai.log.$RANDOM && test -e $_lf; do done
@


1.868
log
@Revamp the display of GPT information, hiding less important
information under the '-v' flag. This brings the GPT display more
into line with the MBR display and simplifies and hardens the parsing
of the partition info in the install scripts.

Original problem with install scripts parsing hand edited GPT
information reported by Valere Monseur via bugs@@.

Man page fixes and tweaks from jmc@@.
Install script changes tested & ok rpe@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.867 2015/12/27 18:42:11 rpe Exp $
d2175 1
a2175 1
				[[ $resp == @@(c|C|cd|CD|Cd|cD) ]] && resp=$1
@


1.867
log
@Refactor and move disk initialization code from install.sh to a separate
function configure_disk() in install.sub.

based on work from and OK halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.866 2015/12/23 18:06:32 rpe Exp $
d292 3
a294 3
	local _p_gpt='First usable LBA:'
	local _p_gpt_openbsd='^[ ]+OpenBSD[ ]+OpenBSD Area'
	local _p_gpt_efisys='^[ ]+EFI Sys[ ]+EFI System Area'
@


1.866
log
@Move the code, that lists uninitialized disk into a separate function.
This makes the disk initialization question code easier to understand.

OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.865 2015/12/23 17:45:13 rpe Exp $
d362 62
@


1.865
log
@Change comment style for headings so they get removed by list2sh.awk and
don't end up in bsd.rd.

OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.864 2015/12/23 08:05:11 rpe Exp $
d244 9
@


1.864
log
@Ensure the installer asks for the dns domain and nameserver in case an
interface has been configured via dhcp and then again manually.

tested and OK krw@@
makes sense halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.863 2015/12/23 08:00:09 rpe Exp $
d58 1
a58 1
#-------------------------------------------------------------------------------
d60 1
a60 1
#-------------------------------------------------------------------------------
d83 1
a83 1
#-------------------------------------------------------------------------------
d85 1
a85 1
#-------------------------------------------------------------------------------
d202 1
a202 1
#-------------------------------------------------------------------------------
d204 1
a204 1
#-------------------------------------------------------------------------------
d355 1
a355 1
#-------------------------------------------------------------------------------
d357 1
a357 1
#-------------------------------------------------------------------------------
d376 1
a376 1
#-------------------------------------------------------------------------------
d378 1
a378 1
#-------------------------------------------------------------------------------
d659 1
a659 1
#-------------------------------------------------------------------------------
d661 1
a661 1
#-------------------------------------------------------------------------------
d1084 1
a1084 1
#-------------------------------------------------------------------------------
d1086 1
a1086 1
#-------------------------------------------------------------------------------
d1498 1
a1498 1
#-------------------------------------------------------------------------------
d1500 1
a1500 1
#-------------------------------------------------------------------------------
d2257 1
a2257 1
#-------------------------------------------------------------------------------
d2265 1
a2265 1
#-------------------------------------------------------------------------------
@


1.863
log
@Ensure the installer asks for IPv4 default route in case an interface has
been configured via dhcp and then again manually.

While there, remove 'dhcp' as valid answer for the default route qeustion.
It was a no-op and was handled the same way as 'none'.

tested and OK krw@@
makes sense halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.862 2015/12/18 16:20:58 rpe Exp $
d1547 3
a1549 1
	# Get & apply fully qualified domain name to hostname.
d1551 3
a1553 1
	if [[ ! -f /tmp/dhclient.conf || $NIFS != 1 ]]; then
a1554 2
	else
		echo "Using DNS domainname $resp"
d1558 3
a1560 2
	# If only one interface, and it is running dhclient, ask nothing
	# else Get/Confirm nameservers.
d1562 3
a1564 1
	if [[ ! -f /tmp/dhclient.conf || $NIFS != 1 || $resp == none ]]; then
a1565 2
	else
		echo "Using DNS nameservers at $resp"
d1567 1
@


1.862
log
@Introduce a new function disk_has() to inspect a disk if it has a
partition-table of a certain type and optionally if it has a partition
of a certain type.

Use disk_has() in the install.md script to replace all the various
"fdisk <disk> | grep <pattern>" commands greatly simplifying things.

positive feedback from sthen@@
"time to get it really tested" deraadt@@
OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.861 2015/12/06 20:29:07 rpe Exp $
d1048 1
a1048 1
	local _dr _prompt=" or 'none'"
d1050 1
a1050 1
	# Get/Confirm an IPv4 default route if an IPv4 address was configured.
d1053 4
a1056 2
	# If only one interface, and it is running dhclient, ask nothing.
	[[ -f /tmp/dhclient.conf && $NIFS == 1 ]] && return
d1058 2
a1059 5
	[[ -x /sbin/dhclient ]] && _prompt=", 'dhcp'$_prompt"
	_prompt="Default IPv4 route? (IPv4 address$_prompt)"

	_dr=$(route -n show -inet | sed -n '/^default */{s///; s/ .*//; p;}')
	[[ -f /tmp/dhclient.conf ]] && _dr=dhcp
d1062 2
a1063 2
		ask_until "$_prompt" "$_dr"
		[[ $resp == @@(none|dhcp) ]] && break
@


1.861
log
@Do the same with less code.

OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.860 2015/11/20 14:41:48 sthen Exp $
d268 40
@


1.860
log
@don't auto-skip X sets on systems without wscons, you can remove them easily
with -x*, and "no wscons" doesn't cover all of the systems where one might
intentionally want to skip them anyway.  ok bmercer deraadt espie rpe
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.859 2015/11/18 17:48:45 sthen Exp $
d1487 1
a1487 1
	local _dn _ns _n
d1499 7
a1505 13
		# Get nameserver address(es). Store as a blank separated list.
		for _n in $(grep '^nameserver ' /tmp/resolv.conf); do
			[[ $_n == nameserver ]] || _ns="$_ns$_n "
		done
		# Zap trailing space in _ns.
		set -- $_ns
		_ns=$*
		# Get default fully qualified domain name from *first* domain
		# given on *last* search or domain statement.
		_dn=$(sed -n \
			-e '/^domain[[:space:]][[:space:]]*/{s///;s/\([^[:space:]]*\).*$/\1/;h;}' \
			-e '/^search[[:space:]][[:space:]]*/{s///;s/\([^[:space:]]*\).*$/\1/;h;}' \
			-e '${g;p;}' /tmp/resolv.conf)
@


1.859
log
@Now that the transition is over, have the installer set 'prohibit-password'
in sshd_config instead of 'without-password'.  "it is time" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.858 2015/09/27 19:00:32 halex Exp $
a1127 4
		# No displays and X isn't installed ==> skip X sets.
		[[ -z $DISPLAY && ! -d /mnt/etc/X11 ]] &&
			isin ${_f%${VERSION}.tgz} xbase xshare xfont xserv &&
			continue
@


1.858
log
@HEAD is past 5.8 now, so remove /var/tmp removal tweak.

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.857 2015/09/09 23:07:10 halex Exp $
d1648 1
a1648 1
			sshd_enableroot=without-password
@


1.857
log
@zap trailing whitespace
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.856 2015/09/09 15:04:54 halex Exp $
a1250 4

	# XXX Delete this chunk after 5.8 (not a supported upgrade path).
	# XXX Undo old configurations where /var/tmp is a directory.
	[[ $MODE == upgrade ]] && rm -rf /mnt/var/tmp
@


1.856
log
@At some point back in time, the disk info (obtained by responding '?' at
the root disk question) got some extra linefeeds in it. This fixes the
output to be one line per disk again.

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.855 2015/08/24 10:41:11 ajacoutot Exp $
d1400 1
a1400 1
# installation. 
@


1.855
log
@/usr/share/sysmerge -> /var/sysmerge

requested by several
discussed with deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.854 2015/08/06 14:55:51 deraadt Exp $
d213 1
a213 1
		sed	-e '/^label: /{s,,,;s/ *$//;s/^$/<no label>/;H;d;}' \
@


1.854
log
@match change to prohibit-password.  however, also default to "no", as
as strong secure-by-default stance.
people who upload root keys via site.tgz need to adjust sshd_config;
those who load a root key via autoinstall should trigger on this
question and select prohibit-password.
discussed at length
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.853 2015/08/06 13:15:53 deraadt Exp $
d1263 1
a1263 1
				file:///mnt/usr/share/sysmerge/${_f%%base*}etc.tgz |
@


1.853
log
@spelling
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.852 2015/08/06 06:39:41 deraadt Exp $
d1644 1
a1644 1
		ask "Allow root ssh login? (yes, no, pubkeys-only)" pubkeys-only
d1651 1
a1651 1
		w|p|without-password|pubkeys-only)
@


1.852
log
@Change the ssh root login question to avoid the unnatural keyword
"without-password". Instead use "pubkeys-only" which people will find
conceptually easier.  Still quietly accept "w" or "without-password"
as an option.
Place a warning beforehands:
WARNING: root is targetted by password guessing attacks, pubkeys are safer.

Everyone happy now, or at learning to not use root passwords?
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.851 2015/08/01 16:20:40 rpe Exp $
d1642 1
a1642 1
	echo "WARNING: root is targetted by password guessing attacks, pubkeys are safer."
@


1.851
log
@- Be more specific as to what accept as answer to the "Allow root
  ssh login?" question. Either the first letter or the whole word
- Use grep to check for the default in sshd_config
- Simplify sed expression for changing sshd_config

Based on feedback from and OK halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.850 2015/07/30 19:40:32 rpe Exp $
a1640 1
		echo "WARNING: root accounts are often targets of password guessing attacks."
d1642 1
d1644 1
a1644 1
		ask "Allow root ssh login? (yes, no, without-password)" without-password
d1651 1
a1651 1
		w|without-password)
@


1.850
log
@Change installer to cope with the new sshd_config(5) default for
the PermitRootLogin option. Additionally to 'yes' and 'no' allow
'without-password' and make that the proposed default answer for
the "Allow root ssh login?" question. Modify sshd_config only if
the user choice is not the default.

OK deraadt
discussed with halex@@, sthen@@ and others
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.849 2015/07/20 01:12:49 rpe Exp $
d1636 2
d1645 13
a1657 5
		case $resp in
		[yY]*)	sshd_enableroot=yes;;
		[nN]*)	sshd_enableroot=no;;
		[wW]*)	sshd_enableroot=without-password;;
		*)	$AUTO && exit 1 || continue;;
d1659 1
a1659 1
		return
a2095 2
	local _sshd_default

a2098 2
		_sshd_default=$(sed -n '/^#PermitRootLogin \(.*\)$/s//\1/p' \
			/mnt/etc/ssh/sshd_config)
d2100 3
a2102 2
		if [[ $sshd_enableroot != $_sshd_default ]]; then
			sed -i "/^#\(PermitRootLogin\) .*$/s//\1 $sshd_enableroot/" \
@


1.849
log
@Fix some typos and reformat comments.

OK halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.848 2015/07/19 19:33:51 rpe Exp $
d1634 1
a1634 2
# of doing so. During autoinstall ask if a rootkey is provided, even if a user
# is setup.
d1641 10
a1650 4
	if [[ -z $user || -n $rootkey ]]; then
		ask_yn "Enable sshd(8) logins to root?" no
		sshd_enableroot=$resp
	fi
d2086 1
a2086 1
	local ssh_permitroot=
d2090 8
a2097 6
	elif [[ $sshd_enableroot == y ]]; then
		ssh_permitroot=yes
		[[ -n $rootkey ]] && ssh_permitroot=without-password
		sed "/^#\(PermitRootLogin\) no/s//\1 $ssh_permitroot/" \
			</mnt/etc/ssh/sshd_config >/tmp/sshd_config
		cp /tmp/sshd_config /mnt/etc/ssh/sshd_config
@


1.848
log
@Use the %c (version or snapshots) and %a (package architecture) for
installpath in pkg.conf instead of hardcoding that information.
This fixes the problem, that installpath has a path from an older
release after updating from disk for a while.

NOTE: This matches fw_update behaviour in that during a beta cycle,
it will expand to 5.8 (for e.g.) instead of snapshots.

requested by and OK ajacoutot@@
OK halex@@ krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.847 2015/07/17 15:11:52 rpe Exp $
d67 1
a67 1
# Wait for the http process to finish, or be killed after the timeout.
d133 2
a134 2
# Remove all occurrences of first argument from list formed by
# the remaining arguments.
d278 2
a279 2
#    $1 = disk
#    $2 = /path/to/fstab
d337 1
a337 1
# Functions to ask (or auto-answer) queststions
d416 8
a423 6
# - split question and answer at leftmost =
# - strip leading/trailing blanks
# - compare questions case insensitive
# - ignore empty and comment lines and lines without =
# - return default answer if provided and none is found in file
# - treat empty/missing/multiple answers as error and exit
d453 3
a455 2
#    $1    = the question to ask the user
#    $2    = the default answer
d495 4
d500 2
a501 2
#    $1    = the question to ask the user
#    $2    = the default answer (assumed to be 'n' if empty).
a502 2
# Return 'y' or 'n' in $resp.
# Exit code: yes => 0, no => 1
d520 3
a530 2
#
# At exit $resp holds selected item, or 'done'.
d564 3
d568 2
a569 2
#    $1    = the question to ask the user
#    $2    = the default answer
a570 1
# Save the user input (or the default) in $resp.
d582 7
a588 5
#    Display $1 as the prompt.
#    *Don't* allow the '!' options that ask does.
#    *Don't* echo input.
#    *Don't* interpret "\" as escape character.
#    Preserve whitespace in input
a656 1
# $1 == interface
d658 1
a658 1
# Should output '<UP/DOWN> <addr> <netmask> <rest of inet line> '.
d682 2
a683 2
#    $1 = IP address (v6 if it contains ':', else v4)
#    $2 = symbolic name
d703 3
a705 3
#    $1 = name of the network device
#    $2 = hostname to use for dhcp request
#    $3 = /path/to/hostname.if
d789 3
a791 3
#    $1 = name of the network device
#    $2 = hostname to use for dhcp request
#    $3 = /path/to/hostname.if
d824 1
a824 1
# Perform an 802.11 interface network scan.
a825 1
# $1 == interface
d834 1
a834 4
# Configures an 802.11 interface.
#
# $1 == interface
# $2 == hostname
d1065 3
a1071 1
# Set $resp to list of selected sets.
d1914 5
a1918 5
#	1) can't be mounted (no mount_* command is found),
#	2) have 'xx' in the option field (usually /altroot),
#	3) have 'noauto' in the option field,
#	4) are nfs (since name resolution may not be present),
#	5) are on a vnd device.
d1922 4
a1925 4
#	1) delete 'softdep' options (no soft updates in ramdisk kernels),
#	2) mount non-ffs filesystems read only,
#	3) prepend '/mnt' to all mount points,
#	4) delete any trailing '/' from the mount point (e.g. root),
d2139 1
a2139 1
# Final steps common for installations and upgrades.
d2214 1
a2214 1
# #######################################################################
d2222 1
a2222 1
# #######################################################################
d2258 1
a2258 1
# The dmesg listener will check for the existance of this file and send a
@


1.847
log
@Remove spaces before the double semicolons in case-blocks.

OK krw@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.846 2015/07/16 21:05:08 halex Exp $
d1359 1
a1359 1
				s!!/\1/packages/$(arch -s)/!;q")
@


1.846
log
@zap trailing whitespace

with rpe's blessing
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.845 2015/07/05 09:17:39 rpe Exp $
d305 4
a308 4
		[aA]*)	_op=-w ;;
		[eE]*)	_op=-E ;;
		[cC]*)	return 0 ;;
		*)	continue ;;
d1843 3
a1845 3
			trunk)	_trunks="$_trunks $hn"	;;
			svlan)	_svlans="$_svlans $hn"	;;
			vlan)	_vlans="$_vlans $hn"	;;
@


1.845
log
@In case-statements where single and multiline commands are used,
put the terminating ;; always on its own line.

discussed with and OK krw@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.844 2015/07/03 18:29:08 rpe Exp $
d297 1
a297 1
		fi	
@


1.844
log
@Use [aA]* instead of a*|A* in case-blocks.

OK krw@@
@@halex agreed on this in a similar diff
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.843 2015/06/02 19:54:06 rpe Exp $
d851 2
a852 1
		*)	_nwid=$resp;;
d1258 4
a1261 2
			fi;;
		*)	ftp -D Installing -Vmo "/mnt/$_f" "$_fsrc";;
d1301 2
a1302 1
		done)	return;;
d1587 2
a1588 1
		n|no)	return;;
d1590 6
a1595 3
			continue;;
		root|daemon|operator|bin|smmsp|popa3d) ;;
		sshd|uucp|www|named|proxy|nobody|ftp) ;;
d1597 2
a1598 1
			((${#resp} <= 31)) && break;;
d1607 2
a1608 1
			echo "':', '&' or ',' are not allowed.";;
d1611 2
a1612 1
			echo "Too long.";;
d1672 2
a1673 1
		"")	continue;;
d1675 2
a1676 1
			continue;;
d1707 2
a1708 1
		"?")	diskinfo $(get_dkdevs);;
d1711 2
a1712 1
			echo "no such disk";;
d2049 2
a2050 1
		done)	sane_install && return;;
d2055 10
a2064 5
			fi;;
		[dD]*)	install_disk && METHOD=disk;;
		[hH]*)	isin http $_locs && install_http && METHOD=http;;
		[nN]*)	isin nfs $_locs && install_nfs && METHOD=nfs;;
		*)	$AUTO && echo "'$resp' is not a valid choice." && exit 1;;
@


1.843
log
@Remove the $FSTABFLAG variable and use -F directly. The installer
uses disklabel UIDs unconditionally for a while already.

OK krw@@
"looks good" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.842 2015/05/31 19:40:10 rpe Exp $
d305 3
a307 3
		a*|A*)	_op=-w ;;
		e*|E*)	_op=-E ;;
		c*|C*)	return 0 ;;
d1474 1
a1474 1
			"?"|L|l) echo "Available layouts: $_layouts";;
d2035 1
a2035 1
		c*|C*)	if [[ -n $_cddevs ]]; then
d2040 3
a2042 3
		d*|D*)	install_disk && METHOD=disk;;
		h*|H*)	isin http $_locs && install_http && METHOD=http;;
		n*|N*)	isin nfs $_locs && install_nfs && METHOD=nfs;;
@


1.842
log
@Replace identical code in the MD scripts of the installer with a new
MI function disklabel_autolayout() which now handles all aspects of
the disklabel auto-layout and autopartitioning case for the root disk.
Remove get_disklabel_template() and merge it with the new function.

"move forward" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.841 2015/05/20 19:14:35 rpe Exp $
d291 1
a291 1
			disklabel -T $_dl $FSTABFLAG $_f -w -A $_disk && return
d310 1
a310 1
		disklabel $FSTABFLAG $_f $_op -A $_disk
a2268 1
FSTABFLAG=-F
@


1.841
log
@Merge the get_drive() function with install_disk(), which is the
only remaining consumer.

OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.840 2015/05/19 20:12:29 rpe Exp $
d271 43
a1704 12
}

# Ask for and download autopartitioning template for disklabel.
get_disklabel_template() {
	local _dl=/disklabel.auto

	ask "URL to autopartitioning template for disklabel?" none
	[[ $resp == none ]] && return 1
	echo "Fetching $resp"
	ftp -Vo $_dl "$resp" && [[ -s $_dl ]] && return
	echo "No autopartitioning template found."
	exit 1
@


1.840
log
@Fix installing sets from cdrom if more than one drive is present.
Run makedev in install_cdrom() to create the necessary device nodes,
which got lost in a recent change.

Found by James Hartley, thanks for the bug report!
OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.839 2015/05/18 13:48:37 deraadt Exp $
a256 8
# Ask for the device that contains the install/upgrade media.
get_drive() {
	ask_which "$1" "contains the $MODE media" "$2" "$3"
	[[ $resp == done ]] && return 1
	makedev $resp || return 1
	return 0
}

d1349 5
a1353 3
		get_drive "disk" '$(bsort $(get_dkdevs))' \
			'$(bsort $(rmel $ROOTDISK $(get_dkdevs)))' || return
		mount_mnt2 $resp || return
@


1.839
log
@enable ntpd by default at install time.  We use pools and a reliable
constraint to keep them in check.  in the worst case of being on a
dark net, nothing changes.

this is being enabled by default to allow gathering of more operational
information from users.  and if the operational heuristics in ntpd can be
suitable refined, this may stay the default into the future.  if not, ntpd
will become even more awesome along the way.

with reyk rpe
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.838 2015/05/15 07:41:30 rpe Exp $
d1348 1
a1348 1
	mount_mnt2 $_drive || return
@


1.838
log
@Remove the 'Use DUIDs rather than device names in fstab?' question
and use DUIDs unconditionally. DUIDs in the installed /etc/fstab
has been the default for quite some time now.

OK deraadt@@, krw@@, guenther@@, beck@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.837 2015/05/14 10:58:55 rpe Exp $
a1508 7
	ask_yn "Start ntpd(8) by default?"
	ntpd=$resp
	if [[ $resp == y ]]; then
		ask "NTP server? (hostname or 'default')" default
		ntpd_server=$resp
	fi

a2037 6
	fi

	if [[ $ntpd == y ]]; then
		echo "ntpd_flags=" >>/mnt/etc/rc.conf.local
		[[ $ntpd_server == default ]] && ntpd_server=pool.ntp.org
		echo "servers ${ntpd_server%% *}" >>/mnt/etc/ntpd.conf
@


1.837
log
@Extend autoinstall(8) to allow for <hostname>-<mode>.conf response files
and to put response files in a subdir of the webserver's document root.
Based on diffs from Nathanael Rensen, thanks!

While here fix a buglet introduced by the $_server -> $AI_SERVER change.

OK krw, halex
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.836 2015/05/04 19:55:26 rpe Exp $
d2257 1
a2257 1
FSTABFLAG=-f
@


1.836
log
@Add the new template file based autopartitioning feature of disklabel(8)
to the OpenBSD installer. It is available during unattended installation.
The template file is fetched from an url, provided as answer to a new
question in the response file:

    URL to autopartitioning template for disklabel = url

Original diff from and OK henning@@
'no objection' krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.835 2015/04/28 21:41:40 sthen Exp $
d307 1
a307 1
	local _rf _ifdev _mac _mode _lf
d316 2
a317 2
	# Extract server ip address and installer mode from lease file.
	# Prime hostname with host-name option.
d331 4
a334 2
		_mode=$(sed -E '/^ *filename "auto_(install|upgrade)";$/!d;s//\1/;q' $_lf)
		hostname "$(sed -E '/^ *option host-name "(.*)";$/!d;s//\1/;q' $_lf)"
d338 2
a339 1
	# one was missing. First try to fetch mac-mode.conf, then mode.conf.
d342 2
a343 2
		for _rf in {$_mac-,}$_mode; do
			_url="http://$AI_SERVER/$_rf.conf?path=$HTTP_SETDIR"
d360 1
a360 1
			"${AI_SERVER:+http://$_server/install.conf}"
@


1.835
log
@ajacoutot spotted a problem with the new sshd logic (to disable root logins
by default completely in most cases, except where a public ssh key was provided
to autoinstall) - in the case where a (non-root) account was created, sshd
was being disabled; this diff fixes it. Looks good ajacoutot, OK djm@@,
extensive testing+OK rpe@@,
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.834 2015/04/27 23:17:11 djm Exp $
d1672 12
@


1.834
log
@Rework sshd enable root login questions in light of sshd PermitRootLogin
default change. The new default is not to ask to enable root logins
when a non-root user has been addedi. There is some additional sublety
for auto-installs that provide root ssh keys.

patch by myself and rpe@@ with feedback from sthen@@;
ok rpe@@ deraadt@@ sthen@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.833 2015/04/26 14:49:23 henning Exp $
d2022 3
a2024 1
	if [[ $sshd == y && $sshd_enableroot == y ]]; then
a2029 2
	else
		echo "sshd_flags=NO" >>/mnt/etc/rc.conf.local
@


1.833
log
@get_responsefile: instead of keeping the dhcp-supplied next-server where
we fetch the response file from in a local _server var, put it in an
exported AI_SERVER one. last not least that allows install.site to see it.
ok krw rpe
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.832 2015/04/21 10:58:28 henning Exp $
d1579 1
d1581 13
a1593 3
	if [[ $sshd == y ]]; then
		ask_yn "Since you set up a user, disable sshd(8) logins to root?" yes
		sshd_disableroot=$resp
a1594 1

d2020 7
a2026 4
	[[ $sshd == n ]] && echo "sshd_flags=NO" >>/mnt/etc/rc.conf.local
	if [[ $sshd_disableroot == y ]]; then
		sed "/^#\(PermitRootLogin\) yes/s//\1 no/" \
			< /mnt/etc/ssh/sshd_config >/tmp/sshd_config
d2028 2
d2031 1
@


1.832
log
@append the setdir ("5.7/amd64", "snapshots/vax") as get-parameter "path"
when fetching the autoinstall response file.
a webserver that serves static files doesn't give a damn. if I map that
to something that dynamically creates the response file, i can use that to
construct the sets path, or play other arch and/or version dependent
games.
ok krw uwe
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.831 2015/04/20 15:31:15 krw Exp $
d307 1
a307 1
	local _rf _ifdev _mac _mode _server _lf
d330 1
a330 1
		_server=$(sed "/^ *next-server /!d;s///;s/;$//;q" $_lf)
d337 1
a337 1
	if [[ -n $_server && -n $_mode ]]; then
d340 1
a340 1
			_url="http://$_server/$_rf.conf?path=$HTTP_SETDIR"
d349 1
a349 1
		[[ -z $_server ]] && echo "Could not determine next-server."
d357 1
a357 1
			"${_server:+http://$_server/install.conf}"
@


1.831
log
@Fix asking for list of http servers via '?'. The 'more' now used
on the install media does not (currently) support '-e' or other
posix nifties, but does exit after displaying the last line.

Should fix scanning for wireless networks too.

Reported by Adam Wolk on misc@@.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.830 2015/04/06 13:34:23 rpe Exp $
d340 1
a340 1
			_url=http://$_server/$_rf.conf
@


1.830
log
@Use if then else instead of testing $_fstype twice.

OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.829 2015/04/05 12:37:14 rpe Exp $
d811 1
a811 1
				cat -n | more -ce
d1262 1
a1262 1
			cat -n < $HTTP_LIST | more -ce
@


1.829
log
@Cope with the removal of less from install media.
Noted by Adam Wolk, thanks.

OK krw@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.828 2015/04/04 14:21:01 rpe Exp $
d1880 2
a1881 1
		[[ $_fstype == ffs ]] &&
d1883 1
a1883 3

		# Mount non-ffs filesystems read only.
		[[ $_fstype == ffs ]] ||
d1885 1
@


1.828
log
@I contributed substantially to the installer, so add copyright.

prodded by deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.827 2015/04/04 11:06:33 rpe Exp $
d811 1
a811 1
				less -XEN
d1262 1
a1262 1
			less -XEN < $HTTP_LIST
@


1.827
log
@Moar comments !!

Add comment headers to each function, briefly explaining its purpose
and arguments.

Feedback and OK halex@@ krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.826 2015/04/03 17:03:15 rpe Exp $
d4 2
@


1.826
log
@Eleminate the last occurrences of backticks and replace constructs
like `cat file` or $(cat file) with $(<file) in places, where we
can be sure that file exists.

OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.825 2015/03/28 17:03:11 rpe Exp $
d85 1
d223 1
d228 1
d234 1
d239 1
d244 2
d255 1
d263 1
a263 1
# Return the device name for the supplied device, which may be a disklabel UID.
a606 2
# Output '<UP | DOWN> [<addr> <netmask> <rest of inet line>]'.
#
d608 2
d618 1
a618 1
# Convert a hex value to dotted decimal format.
d628 8
a635 4
# Create an entry in the hosts file. If an entry with the
# same symbolic name and address family already exists, delete it.
# $1 - IP address (v6 if it contains ':', else v4)
# $2 - symbolic name
d650 8
d699 2
a700 4
# Obtain and output the inet6 information related to the given
# interface. Should output '<UP/DOWN> <addr> <prefixlen> <rest of inet line> '.
#
# $1 == interface
d710 1
d736 8
d850 1
d960 1
d1319 2
d1339 1
d1348 2
d1360 1
d1381 2
d1418 1
d1440 1
d1496 2
d1541 1
d1585 1
d1662 1
d1760 1
d1817 3
d1928 2
a1929 2
# Must mount filesystems manually, one at a time, so we can make
# sure the mount points exist.
d1961 3
a1963 3
# Ask the user for locations of sets, and then install whatever sets the
# user selects from that location. Repeat as many times as the user
# needs to get all desired sets.
d2006 1
d2039 7
d2058 1
d2066 1
@


1.825
log
@fix typos

noted by Mikolaj Kucharski, thx
OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.824 2015/03/28 00:03:05 rpe Exp $
d1562 1
a1562 1
		[[ -n $_tz ]] && isin "$_tz" `cat $_zonefile` && TZ=$_tz
d1578 1
a1578 1
		while isin "$_zonepath/" $(cat $_zonefile); do
d1589 1
a1589 1
		if isin "$_zonepath" $(cat $_zonefile); then
d2137 1
a2137 1
			if test -e /tmp/update && [[ "`dmesg`" != "`cat /tmp/update`" ]]; then
@


1.824
log
@- Start comments with capital letters.
- End comments with a full stop.

OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.823 2015/03/27 22:15:39 rpe Exp $
d61 1
a61 1
	asdfecho "usage: ${0##*/} [-a] [-f filename]" >&2
d1958 1
a1958 2
apply()
{
@


1.823
log
@Tame the more than 70 functions in install.sub.
Regroup them by their purpose and add section headers.

go for it halex@@, OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.822 2015/03/21 21:13:52 rpe Exp $
d65 1
a65 1
# Wait for the http process to finish, or be killed after the timeout
d108 1
a108 1
# test the first argument against the remaining ones, return success on a match
d119 2
a120 2
# add first argument to list formed by the remaining arguments
# adds to the tail if the element does not already exist
d130 2
a131 2
# remove all occurrences of first argument from list formed by
# the remaining arguments
d142 1
a142 1
# adjusted with the time elapsed since it was received
d153 1
a153 1
	# Since this is a subshell we won't pollute the calling namespace
d160 1
a160 1
# show a list (passed via ordered arguments) in column output using ls
d203 1
a203 1
# Show device name, label and size for the provided list of devices
d217 1
a217 1
# Create devices passed as arguments
d260 1
a260 1
		# Lookup device name matching the disklabel UID
d274 1
a274 1
# Acquire lock
d279 1
a279 1
# Release lock
d284 1
a284 1
# Add trap to kill the listener process
d366 1
a366 1
# Search question in $RESPFILE, return answer in $resp
d476 1
a476 1
# At exit $resp holds selected item, or 'done'
d486 1
a486 1
		# Clean away whitespace and determine the default
d538 1
a538 1
# Ask for a password twice, saving the input in $_password
d565 1
a565 1
# Run dhclient, making sure there is a free bpf first
d610 1
a610 1
# Convert a hex value to dotted decimal format
d749 1
a749 1
# The result is cached in $WLANLIST
d752 1
a752 1
	# N.B. Skipping quoted nwid's for now
d759 1
a759 1
# Configures an 802.11 interface
d766 1
a766 1
	# Reset 802.11 settings and determine wpa capability
d770 1
a770 1
	# Empty scan cache
d788 1
a788 1
	# 'any' implies that only open access points are considered
d801 1
a801 1
				# Make sure ifconfig accepts the key
d810 1
a810 1
				# Make sure ifconfig accepts the key
d855 1
a855 1
		# questions and bring it up
d880 1
a880 1
			# Validate that $_vd is a real interface
d908 1
a908 1
		# Test if it is an 802.11 interface
d938 1
a938 1
	# If only one interface, and it is running dhclient, ask nothing
d1051 1
a1051 1
		# No displays and X isn't installed ==> skip X sets
d1081 1
a1081 1
	# Reorder $_get_sets
d1084 1
a1084 1
	# Note which sets didn't verify ok
d1087 2
a1088 2
	# Try to prefetch and control checksum files
	# use dummy for loop as combined assignment and do { ... } while(0)
d1123 1
a1123 1
		# Fetch signature file
d1127 1
a1127 1
		# Verify signature file with public keys
d1135 1
a1135 1
			# Fetch set and create checksum by pipe through sha256
d1175 2
a1176 2
	# XXX Delete this chunk after 5.8 (not a supported upgrade path)
	# XXX Undo old configurations where /var/tmp is a directory
d1225 1
a1225 1
	# Get server IP address or hostname
d1271 2
a1272 2
	# Assumes index file is "index.txt" for http (or proxy)
	# We can't use index.html since the format is server-dependent
d1337 1
a1337 1
	# Determine use of TCP
d1340 1
a1340 1
	# Mount the server
d1440 1
a1440 1
	# else Get/Confirm nameservers
d1551 1
a1551 1
	# If configured in a previous call, return immediately
d1566 1
a1566 1
	# early question, give up, and ask after the sets are installed
d1730 2
a1731 2
	# configure all of the non-loopback interfaces which we know about.
	# refer to hostname.if(5)
d1743 1
a1743 1
			# 'real' interfaces (if available) are done now.
d1748 1
a1748 1
	# ORDER IS IMPORTANT! (see /etc/netstart)
d1773 1
a1773 1
	# If no networks are configured, we do not need the httplist file
d1776 1
a1776 1
	# Make sure the ftp subshell gets its own process group
d1784 1
a1784 1
		# Remember finish time for adjusting the received timestamp
d1790 3
a1792 3
	# If the ftp process takes more than 12 seconds, kill it
	# XXX We are relying on the pid space not randomly biting us --
	# XXX ftp could terminate early, and the pid could be reused
d1903 1
a1903 1
# Feed the random pool some entropy before we read from it
d2027 1
a2027 1
	# Create or update pkg.conf with the new package path, if any
d2094 1
a2094 1
# Parse parameters
d2125 1
a2125 1
# Make sure lock is initially released
d2130 1
a2130 1
# of that file
d2134 1
a2134 1
	# Start listener process looking for dmesg changes
d2148 1
a2148 1
	# Kill the child on exit
d2174 1
a2174 1
# Extract and save one boot's worth of dmesg
d2209 1
a2209 1
# prepare COLUMNS sanely
d2213 1
a2213 1
# decide upon an editor
d2222 1
a2222 1
# make sure only successful dhcp requests retain their state
@


1.822
log
@Fold the single command from update_firmware() into finish_up()
and remove the update_firmware() function all together.

OK halex@@ krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.821 2015/03/21 18:27:39 rpe Exp $
d56 4
d61 1
a61 1
	echo "usage: ${0##*/} [-a] [-f filename]" >&2
d65 94
a158 2
set_term() {
	local _layouts
d160 13
a172 16
	export TERM=${TERM:-${MDTERM:-vt220}}
	if [[ -n $CONSOLE ]]; then
		ask "Terminal type?" $TERM
		export TERM=$resp
	else
		[[ -x /sbin/kbd ]] || return
		_layouts=$(bsort $(kbd -l | egrep -v "^(user|tables|encoding)"))
		while :; do
			ask "Choose your keyboard layout ('?' or 'L' for list)" "default"
			case $resp in
			"?"|L|l) echo "Available layouts: $_layouts";;
			default) return;;
			*)	kbd $resp && { echo $resp >/tmp/kbdtype; return; };;
			esac
		done
	fi
a188 10
# Prints the supplied parameters properly escaped for future sh/ksh parsing.
# Quotes are added if needed, so you should not do that yourself.
quote() (
	# Since this is a subshell we won't pollute the calling namespace
	for a; do
		alias Q=$a; a=$(alias Q); print -rn -- " ${a#Q=}"
	done | sed '1s/ //'
	echo
)

d198 24
d255 8
a262 16
mount_mnt2() {
	local _dev=$1 _opts _file=/tmp/parts.$1 _parts

	disklabel $_dev 2>/dev/null |
		sed -En '/swap|unused/d;/^  [a-p]: /p' >$_file

	_parts=$(sed 's/^  \(.\): .*/\1/' $_file)
	set -- $_parts
	(($# == 0)) && { echo "No filesystems found on $_dev."; return 1; }

	if isin "c" $_parts; then
		# Don't ask questions if 'c' contains a filesystem.
		resp=c
	elif (($# == 1)); then
		# Don't ask questions if there's only one choice.
		resp=$1
d264 2
a265 6
		# Display partitions with filesystems and ask which to use.
		cat $_file
		ask_which "$_dev partition" "has the $MODE sets" \
			'$(disklabel '$_dev' 2>/dev/null |
			sed -En '\''/swap|unused/d;/^  ([a-p]): .*/s//\1/p'\'')'
		[[ $resp == done ]] && return 1
d267 1
a268 4
	# Always mount msdos partitions with -s to get lower case names.
	grep -q "^  $resp: .*MSDOS" $_file && _opts="-s"
	mount -o ro,$_opts /dev/$_dev$resp /mnt2
}
d270 3
a272 12
# Ask for a password, saving the input in $resp.
#    Display $1 as the prompt.
#    *Don't* allow the '!' options that ask does.
#    *Don't* echo input.
#    *Don't* interpret "\" as escape character.
#    Preserve whitespace in input
askpass() {
	stty -echo
	IFS= read -r resp?"$1 "
	stty echo
	echo
}
a289 11
# Issue a read into the global variable $resp. If the dmesg output is
# changed while inside this function, the current read will be aborted
# and the function will return a non-zero value. Normally, the caller
# will then reprint any prompt and call the function again.
#
# Optional parameters:
#    $1    = the question to ask the user
#    $2    = the default answer
#
_ask() {
	local _q=$1 _def=$2 _int _redo=0 _pid
d291 74
a364 26
	lock; dmesg >/tmp/update; unlock
	echo -n "${_q:+$_q }${_def:+[$_def] }"
	_autorespond "$_q" "$_def" && echo "$resp" && return
	trap "_int=1" INT
	trap "_redo=1" TERM
	read resp
	lock; rm /tmp/update; unlock
	if ((_redo)); then
		stty raw
		stty -raw
	else
		case $resp in
		!)	echo "Type 'exit' to return to install."
			sh
			_redo=1
			;;
		!*)	eval "${resp#?}"
			_redo=1
			;;
		esac
	fi
	retrap
	((_int)) && kill -INT $$
	: ${resp:=$_def}
	return $_redo
}
d397 11
a407 6
# Ask for user input, which is returned in $resp.
# Any parameters are passed on to _ask(), which is called
# repeatedly until it succeds.
ask() {
	while ! _ask "$1" "$2"; do done
}
d409 10
a418 29
# Ask for a password twice, saving the input in $_password
askpassword() {
	local _q=$1
	if $AUTO; then
		echo -n "$_q "
		_autorespond "$_q"
		echo '<provided>'
		_password=$resp
		return
	fi

	while :; do
		askpass "$_q (will not echo)"
		_password=$resp

		askpass "$_q (again)"
		[[ $resp == "$_password" ]] && break

		echo "Passwords do not match, try again."
	done
}

encr_pwd() {
	local _p=$1
	if [[ -z $_p ]]; then
		echo '*'
	elif [[ $_p == \$2?\$[0-9][0-9]\$* && ${#_p} > 40 ||
		$_p == '*************' ]]; then
		echo "$_p"
a419 9
		encrypt -b a -- "$_p"
	fi
}

user_setup() {
	local _q="Setup a user? (enter a lower-case loginname, or 'no')"

	while :; do
		ask "$_q" no
d421 7
a427 19
		n|no)	return;;
		y|yes)	_q="No really, what is the lower-case loginname, or 'no'?"
			continue;;
		root|daemon|operator|bin|smmsp|popa3d) ;;
		sshd|uucp|www|named|proxy|nobody|ftp) ;;
		[a-z]*([a-z0-9_]))
			((${#resp} <= 31)) && break;;
		esac
		echo "$resp is not a useable loginname."
	done
	user=$resp
	while :; do
		ask "Full name for user $user?" $user
		case $resp in
		*[:\&,]*)
			echo "':', '&' or ',' are not allowed.";;
		*)
			((${#resp} <= 100)) && break
			echo "Too long.";;
a428 13
	done
	username=$resp

	askpassword "Password for user $user?"
	userpass=$_password

	userkey=
	$AUTO && ask "Public ssh key for user $user" none &&
		[[ $resp != none ]] && userkey=$resp

	if [[ $sshd == y ]]; then
		ask_yn "Since you set up a user, disable sshd(8) logins to root?" yes
		sshd_disableroot=$resp
d430 4
a433 1

d436 5
a440 14
# Ask for user input until a non-empty reply is entered.
#
#    $1    = the question to ask the user
#    $2    = the default answer
#
# Save the user input (or the default) in $resp.
function ask_until {
	resp=
	while true; do
		ask "$1" "$2"
		[[ -n $resp ]] && break
		echo "A response is required."
		$AUTO && exit 1
	done
d509 13
a521 7
# test the first argument against the remaining ones, return success on a match
isin() {
	local	_a=$1 _b

	shift
	for _b; do
		[[ $_a == $_b ]] && return 0
a522 1
	return 1
d525 12
a536 4
# add first argument to list formed by the remaining arguments
# adds to the tail if the element does not already exist
addel() {
	local	_a=$1
d538 10
a547 1
	shift
d549 3
a551 3
	echo -n "$*"
	isin "$_a" $* || echo -n " $_a"
}
d553 2
a554 4
# remove all occurrences of first argument from list formed by
# the remaining arguments
rmel() {
	local	_a=$1 _b
d556 1
a556 3
	shift
	for _b; do
		[[ $_a != $_b ]] && echo -n "$_b "
a559 2
bsort() {
	local _l _a=$1 _b
d561 3
a563 1
	(($# > 0)) || return
d565 18
a582 10
	shift
	for _b; do
		if [[ $_a != $_b ]]; then
			if [[ $_a > $_b ]]; then
				_l="$_a $_l"; _a=$_b
			else
				_l="$_b $_l"
			fi
		fi
	done
d584 7
a590 2
	# Output the smallest value found.
	echo -n "$_a "
d592 5
a596 2
	# Sort remaining values.
	bsort $_l
d599 9
a607 13
# show a list (passed via ordered arguments) in column output using ls
showcols() {
	local _l _cdir=/tmp/cdir
	set -A _clist
	mkdir -p $_cdir
	rm -rf -- $_cdir/*
	while read _l; do
		[[ -n $_l ]] || continue
		mkdir -p /tmp/cdir/"$_l"
		_clist[${#_clist[*]}]="$_l"
	done
	(cd $_cdir; ls -Cdf "${_clist[@@]}")
	rm -rf -- $_cdir
d610 8
a617 3
# Create devices passed as arguments
makedev() {
	[[ -z $(cd /dev && sh MAKEDEV "$@@" 2>&1) ]]
d638 43
a680 1
# Show list of available sets and let the user select which sets to install.
d682 12
a693 8
# $1 = available sets
# $2 = already selected sets
#
# Set $resp to list of selected sets.
select_sets() {
	local _avail=$1 _selected=$2 _f _action _col=$COLUMNS
	# account for 4 spaces added to the sets list
	let COLUMNS=_col-8
d695 1
a695 1
	cat <<__EOT
d697 3
a699 9
Select sets by entering a set name, a file name pattern or 'all'. De-select
sets by prepending a '-' to the set name, file name pattern or 'all'. Selected
sets are labelled '[X]'.
__EOT
	while :; do
		for _f in $_avail; do
			isin $_f $_selected && echo "[X] $_f" || echo "[ ] $_f"
		done | showcols | sed 's/^/    /'
		ask "Set name(s)? (or 'abort' or 'done')" done
d701 1
a701 10
		set -o noglob
		for resp in $resp; do
			case $resp in
			abort)	_selected=; break 2;;
			done)	break 2;;
			-*)	_action=rmel;;
			*)	_action=addel;;
			esac
			resp=${resp#[+-]}
			[[ $resp = all ]] && resp=*
d703 7
a709 3
			for _f in $_avail; do
				[[ $_f = $resp ]] && _selected=$($_action $_f $_selected)
			done
d711 10
a720 1
	done
d722 2
a723 2
	set +o noglob
	COLUMNS=$_col
d725 3
a727 2
	resp=$_selected
}
d729 9
a737 2
configure_ifs() {
	local _first _ifdevs _ifs _name _hn _vl=0 _vd _vi _p _tags
d739 5
a743 8
	# In case of restart, discover last vlan configured.
	while :; do
		_vd=$(ifconfig vlan$_vl 2>&1)
		[[ $_vd == @@(*no such interface*) ]] && break
		[[ $_vd == @@(*vlan: +([[:digit:]]) parent interface:*) ]] || break
		((_vl++))
	done
	_vd=
d745 2
a746 2
	# Always need lo0 configured.
	ifconfig lo0 inet 127.0.0.1/8
d748 10
a757 2
	# In case of restart, delete previous default gateway config.
	rm -f /tmp/mygate
d759 6
a764 3
	while :; do
		# Create new vlan if possible.
		ifconfig vlan$_vl create >/dev/null 2>&1
d766 3
a768 4
		ask_which "network interface" "do you wish to configure" \
			'$(get_ifdevs)' \
			${_p:-'$( (get_ifdevs netboot; get_ifdevs) | sed q )'}
		[[ $resp == done ]] && break
d770 83
a852 3
		_ifs=$resp
		_hn=/tmp/hostname.$_ifs
		rm -f $_hn
d932 11
a942 10
# Output '<UP | DOWN> [<addr> <netmask> <rest of inet line>]'.
#
# $1 == interface
v4_info() {
	ifconfig $1 inet | sed -n '
		1s/.*<UP,.*/UP/p
		1s/.*<.*/DOWN/p
		/inet/s/netmask//
		/inet/s///p'
}
d944 2
a945 12
# Obtain and output the inet6 information related to the given
# interface. Should output '<UP/DOWN> <addr> <prefixlen> <rest of inet line> '.
#
# $1 == interface
v6_info() {
	ifconfig $1 inet6 | sed -n '
		1s/.*<UP,.*/UP/p
		1s/.*<.*/DOWN/p
		/scopeid/d
		/inet6/s/prefixlen//
		/inet6/s///p'
}
d947 8
a954 7
# Run dhclient, making sure there is a free bpf first
dhclient() {
	local _i=0
	while makedev bpf$_i && ! </dev/bpf$_i; do
		((++_i < 50)) || return
	done 2>/dev/null
	/sbin/dhclient "$@@"
d957 4
a960 4
# Issue a DHCP request to configure interface $1 and add the host-name option to
# /etc/dhclient.conf using $2.
dhcp_request() {
	local _ifs=$1 _hn=$2
d962 3
a964 2
	echo "lookup file bind" >/etc/resolv.conf.tail
	echo "send host-name \"$_hn\";" >/etc/dhclient.conf
d966 2
a967 1
	ifconfig $_ifs group dhcp >/dev/null 2>&1
a968 7
	dhclient -c /dev/stdin $_ifs << __EOT
initial-interval 1;
backoff-cutoff 2;
reboot 5;
timeout 10;
send host-name "$_hn";
__EOT
d970 3
a972 6
	# Move configuration files to where they will be copied to the
	# installed system. Overwrites configuration information from
	# last successful dhcp attempt.
	mv /etc/dhclient.conf /tmp/dhclient.conf
	mv /etc/resolv.conf.tail /tmp/resolv.conf.tail
}
d974 4
a977 3
# Convert a hex value to dotted decimal format
hextodec() {
	local _d _b
d979 7
a985 2
	for _b in $(echo ${1#0x} | sed 's/\(..\)/\1 /g'); do
		_d=$_d.$((0x$_b))
a986 1
	echo ${_d#.}
d989 10
a998 10
# Perform an 802.11 interface network scan.
# The result is cached in $WLANLIST
# $1 == interface
ieee80211_scan() {
	# N.B. Skipping quoted nwid's for now
	[[ -f $WLANLIST ]] ||
		ifconfig $1 scan |
		sed -n 's/^		nwid \([^"]\)/\1/p' >$WLANLIST
	cat $WLANLIST
}
d1000 1
a1000 6
# Configures an 802.11 interface
#
# $1 == interface
# $2 == hostname
ieee80211_config() {
	local _ifs=$1 _hn=$2 _prompt _nwid _haswpa=0 _err
d1002 9
a1010 3
	# Reset 802.11 settings and determine wpa capability
	ifconfig $_ifs -nwid -nwkey
	ifconfig $_ifs -wpa 2>/dev/null && _haswpa=1
d1012 10
a1021 2
	# Empty scan cache
	rm -f $WLANLIST
d1023 4
a1026 13
	while [[ -z $_nwid ]]; do
		ask_until "Access point? (ESSID, 'any', list# or '?')" "any"
		case "$resp" in
		+([0-9]))
			_nwid=$(ieee80211_scan $_ifs | sed -n "${resp}s/ .*//p")
			[[ -z $_nwid ]] && echo "There is no line $resp."
			;;
		\?)	ieee80211_scan $_ifs |
				sed -n 's/^\([^ ]*\) chan .* bssid \([^ ]*\) .*$/	\1 (\2)/p' |
				less -XEN
			;;
		*)	_nwid=$resp;;
		esac
d1029 12
a1040 4
	# 'any' implies that only open access points are considered
	if [[ $_nwid != any ]]; then
		ifconfig $_ifs nwid "$_nwid"
		quote nwid "$_nwid" >>$_hn
d1042 20
a1061 29
		_prompt="Security protocol? (O)pen, (W)EP"
		((_haswpa == 1)) && _prompt="$_prompt, WPA-(P)SK"
		while :; do
			ask_until "$_prompt" "O"
			case "$_haswpa-$resp" in
			?-[Oo])	break
				;;
			?-[Ww])	ask_until "WEP key? (will echo)"
				# Make sure ifconfig accepts the key
				if _err=$(ifconfig $_ifs nwkey "$resp" 2>&1) &&
					[[ -z $_err ]]; then
					quote nwkey "$resp" >>$_hn
					break
				fi
				echo "$_err"
				;;
			1-[Pp])	ask_until "WPA passphrase? (will echo)"
				# Make sure ifconfig accepts the key
				if ifconfig $_ifs wpakey "$resp"; then
					quote wpakey "$resp" >>$_hn
					break
				fi
				;;
			*)	echo "'$resp' is not a valid choice."
				;;
			esac
		done
	fi
}
d1063 3
a1065 2
v4_config() {
	local _ifs=$1 _name=$2 _hn=$3 _prompt _addr _mask
d1067 3
a1069 8
	if ifconfig $_ifs | grep -q 'groups:.* dhcp'; then
		_addr=dhcp
	else
		set -- $(v4_info $_ifs)
		if [[ -n $2 ]]; then
			_addr=$2; _mask=$(hextodec $3)
			ifconfig $_ifs inet $_addr delete
		fi
d1072 3
a1074 6
	if [[ -x /sbin/dhclient ]]; then
		_prompt="or 'dhcp' "
		# Don't make 'dhcp' the default if dhcp was already used.
		ifconfig dhcp >/dev/null 2>&1 || _addr=dhcp
	fi
	_prompt="IPv4 address for $_ifs? (${_prompt}or 'none')"
d1076 1
a1076 20
	ask_until "$_prompt" "$_addr"
	case $resp in
	none)	;;
	dhcp)	if [[ ! -x /sbin/dhclient ]]; then
			echo "DHCP not possible - no /sbin/dhclient."
		else
			dhcp_request $_ifs "$_name"
			echo "dhcp" >>$_hn
		fi
		;;
	*)	_addr=$resp
		ask_until "Netmask for $_ifs?" "${_mask:=255.255.255.0}"
		ifconfig $_ifs -group dhcp >/dev/null 2>&1
		if ifconfig $_ifs inet $_addr netmask $resp up; then
			addhostent "$_addr" "$_name"
			echo "inet $_addr $resp" >>$_hn
		fi
		;;
	esac
}
d1078 2
a1079 2
v6_config() {
	local _ifs=$1 _name=$2 _hn=$3 _addr _prefixlen _prompt
d1081 2
a1082 1
	ifconfig lo0 inet6 >/dev/null 2>&1 || return
d1084 2
a1085 2
	set -- $(v6_info $_ifs)
	[[ -n $2 ]] && { _addr=$2; _prefixlen=$3; }
d1087 5
a1091 3
	ifconfig $_ifs inet6 >/dev/null 2>&1 && _prompt="or 'rtsol' "
	_prompt="IPv6 address for $_ifs? (${_prompt}or 'none')"
	ask_until "$_prompt" "${_addr:-none}"
d1093 17
a1109 9
	case $resp in
	none)	return
		;;
	rtsol)	ifconfig $_ifs inet6 >/dev/null 2>&1 || { echo "No INET6 support."; return; }
		ifconfig $_ifs up
		ifconfig $_ifs inet6 autoconf && echo "up\nrtsol" >>$_hn
		return
		;;
	esac
d1111 6
a1116 5
	_addr=$resp
	ask_until "IPv6 prefix length for $_ifs?" "${_prefixlen:=64}"
	ifconfig $_ifs inet6 $_addr prefixlen $resp up || return
	echo "inet6 $_addr $resp" >>$_hn
	addhostent "$_addr" "$_name"
d1118 4
a1121 2
	v6_defroute $_ifs
}
d1123 3
a1125 2
v4_defroute() {
	local _dr _prompt=" or 'none'"
d1127 4
a1130 2
	# Get/Confirm an IPv4 default route if an IPv4 address was configured.
	[[ -n $(ifconfig | sed -n '/[ 	]inet .* broadcast /p') ]] || return
d1132 2
a1133 2
	# If only one interface, and it is running dhclient, ask nothing
	[[ -f /tmp/dhclient.conf && $NIFS == 1 ]] && return
d1135 7
a1141 2
	[[ -x /sbin/dhclient ]] && _prompt=", 'dhcp'$_prompt"
	_prompt="Default IPv4 route? (IPv4 address$_prompt)"
d1143 10
a1152 2
	_dr=$(route -n show -inet | sed -n '/^default */{s///; s/ .*//; p;}')
	[[ -f /tmp/dhclient.conf ]] && _dr=dhcp
d1154 11
a1164 7
	while :; do
		ask_until "$_prompt" "$_dr"
		[[ $resp == @@(none|dhcp) ]] && break
		route delete -inet default >/dev/null 2>&1
		route -n add -inet -host default "$resp" && { echo "$resp" >>/tmp/mygate; break; }
		# Put the old default route back. The new one did not work.
		route -n add -inet -host default $_dr >/dev/null 2>&1
a1165 1
}
d1167 7
a1173 2
v6_defroute() {
	local _if=$1 _prompt _resp _routers
d1175 3
a1177 1
	route -n show -inet6 | egrep -q '^default[[:space:]]' && return
d1179 26
a1204 3
	_routers=$(bsort $(ping6 -n -c 2 ff02::2%$_if 2>/dev/null |
		sed -n '/bytes from/{s/^.*from //;s/,.*$//;p;}' |
		sed -n 'G;s/\n/&&/;/^\(.*\n\).*\n\1/d;h;P'))
d1206 11
a1216 1
	_prompt="IPv6 default router?"
d1218 2
a1219 2
	if $AUTO; then
		_autorespond "$_prompt" && _resp=$resp && echo "$_prompt $_resp"
d1221 2
a1222 5
		local PS3="$_prompt (${_routers:+list #, }IPv6 address or 'none'): "
		select _resp in $_routers; do
			[[ ${_resp:=$REPLY} == *:* ]] && break
			[[ $_resp == none ]] && return
		done
d1225 1
a1225 9
	route -n add -inet6 -host default "$_resp" &&
		echo "$_resp" >>/tmp/mygate
}

# Much of this is gratuitously stolen from /etc/netstart.
ifstart () {
	local _hn=$1 if=${1#/mnt/etc/hostname.}

	((NIFS++))
d1227 5
a1231 21
		if [ "$cmd2" ]; then
			# we are carrying over from the 'read dt dtaddr'
			# last time
			set -- $cmd2
			af=$1 name=$2 mask=$3 bcaddr=$4 ext1=$5 cmd2=
			# make sure and get any remaining args in ext2,
			# like the read below
			i=1
			while [ i -lt 6 -a -n "$1" ]; do shift; let i=i+1; done
			ext2="$@@"
		else
			# read the next line or exit the while loop
			read af name mask bcaddr ext1 ext2 || break
		fi
		# $af can be "dhcp", "rtsol", an address family,
		# commands, or a comment.
		case "$af" in
		"#"*|"!"*|"bridge"|"")
			# skip comments, user commands, bridges,
			# and empty lines
			continue
d1233 8
a1240 10
		"dhcp")	[ "$name" = "NONE" ] && name=
			[ "$mask" = "NONE" ] && mask=
			[ "$bcaddr" = "NONE" ] && bcaddr=
			dhcpif="$dhcpif $if"
			cmd="ifconfig $if $name $mask $bcaddr $ext1 $ext2 down"
			if [[ -x /sbin/dhclient ]]; then
				cmd="$cmd; dhclient $if"
			else
				cmd="$cmd; echo /sbin/dhclient missing - skipping dhcp request."
			fi
d1242 3
a1244 7
		"rtsol")
			if ifconfig $if inet6 >/dev/null 2>&1; then
				rtsolif="$rtsolif $if"
				cmd="ifconfig $if $name $mask $bcaddr $ext1 $ext2 up"
			else
				cmd="$cmd; echo no INET6 support - skipping rtsol request."
			fi
d1246 1
a1246 44
		*)	read dt dtaddr
			if [ "$name" = "alias" ]; then
				# perform a 'shift' of sorts
				alias=$name
				name=$mask
				mask=$bcaddr
				bcaddr=$ext1
				ext1=$ext2
				ext2=
			else
				alias=
			fi
			cmd="ifconfig $if $af $alias $name"
			case "$dt" in
			dest)	cmd="$cmd $dtaddr"
				;;
			*)
				cmd2="$dt $dtaddr"
				;;
			esac
			case $af in
			inet)
				if [ ! -n "$name" ]; then
					echo "/etc/hostname.$if: inet alone is invalid"
					return
				fi
				[ "$mask" ] && cmd="$cmd netmask $mask"
				if [ "$bcaddr" -a X"$bcaddr" != "XNONE" ]; then
					cmd="$cmd broadcast $bcaddr"
				fi
				[ "$alias" ] && rtcmd=";route -qn add -host $name 127.0.0.1"
				;;
			inet6)
				if [ ! -n "$name" ]; then
					echo "/etc/hostname.$if: inet6 alone is invalid"
					return
				fi
				[ "$mask" ] && cmd="$cmd prefixlen $mask"
				cmd="$cmd $bcaddr"
				;;
			*)	cmd="$cmd $mask $bcaddr"
				;;
			esac
			cmd="$cmd $ext1 $ext2$rtcmd" rtcmd=
d1249 39
a1287 2
		eval "$cmd"
	done <$_hn
d1290 2
a1291 2
enable_network() {
	local _f _gw _trunks _svlans _vlans
d1293 10
a1302 5
	# Copy any network configuration files. N.B.: hosts already copied.
	for _f in dhclient.conf resolv.conf resolv.conf.tail; do
		if [[ -f /mnt/etc/$_f ]]; then
			cp /mnt/etc/$_f /etc/$_f
		fi
d1305 5
a1309 3
	# Set the address for the loopback interface. Bringing the
	# interface up, automatically invokes the IPv6 address ::1.
	ifconfig lo0 inet 127.0.0.1/8
d1311 1
a1311 22
	# configure all of the non-loopback interfaces which we know about.
	# refer to hostname.if(5)
	for hn in /mnt/etc/hostname.*; do
		# Strip off prefix to get interface name.
		if=${hn#/mnt/etc/hostname.}
		if isin ${if%%+([0-9])} $(ifconfig -C); then
			# Dynamic interfaces must be done later.
			case ${if%%+([0-9])} in
			trunk)	_trunks="$_trunks $hn"	;;
			svlan)	_svlans="$_svlans $hn"	;;
			vlan)	_vlans="$_vlans $hn"	;;
			esac
		else
			# 'real' interfaces (if available) are done now.
			ifconfig $if >/dev/null 2>&1 && ifstart $hn
		fi
	done
	# Configure any dynamic interfaces now that 'real' ones are up.
	# ORDER IS IMPORTANT! (see /etc/netstart)
	for hn in $_trunks $_svlans $_vlans; do
		ifstart $hn
	done
d1313 2
a1314 1
	[[ -n $rtsolif ]] && ifconfig $rtsolif inet6 autoconf
d1316 6
a1321 13
	# /mnt/etc/mygate, if it exists, contains the address(es) of my
	# default gateway(s). Use for ipv4 if no interfaces configured via
	# dhcp. Use for ipv6 if no interfaces configured via rtsol.
	[[ -z $dhcpif ]] && stripcom /mnt/etc/mygate | while read _gw; do
		[[ $_gw == @@(*:*) ]] && continue
		route -qn delete default >/dev/null 2>&1
		route -qn add -host default $_gw && break
	done
	[[ -z $rtsolif ]] && stripcom /mnt/etc/mygate | while read _gw; do
		[[ $_gw == !(*:*) ]] && continue
		route -qn delete -inet6 default >/dev/null 2>&1
		route -qn add -host -inet6 default $_gw && break
	done
d1323 1
a1323 1
	route -qn add -net 127 127.0.0.1 -reject >/dev/null
d1326 2
a1327 6
# Install a user-selected subset of the files in $2 from the source
# named in $1. Display an error message for failed installs so the
# user will know to try again.
install_files() {
	local _src=$1 _files=$2 _f _sets _get_sets _n _col=$COLUMNS \
		_tmpfs _tmpsrc _cfile _fsrc _unver _t _issue _srclocal
d1329 3
a1331 16
	# Initialize _sets to the list of sets found in _src, and initialize
	# _get_sets to the intersection of _sets and DEFAULTSETS.
	#
	# Sets will be installed in the order given in THESETS to ensure proper
	# installation.  So, to minimize user confusion display the sets in the
	# order in which they will be installed.
	for _f in $THESETS; do
		isin $_f $_files || continue;
		_sets=$(addel $_f $_sets)
		# No displays and X isn't installed ==> skip X sets
		[[ -z $DISPLAY && ! -d /mnt/etc/X11 ]] &&
			isin ${_f%${VERSION}.tgz} xbase xshare xfont xserv &&
			continue
		isin $_f $DEFAULTSETS "site$VERSION-$(hostname -s).tgz" &&
			_get_sets=$(addel $_f $_get_sets)
	done
d1333 3
a1335 3
	if [[ -z $_sets ]]; then
		echo -n "Looked at $_src "
		echo "and found no $OBSD sets.  The set names looked for were:"
d1337 2
a1338 3
		let COLUMNS=_col-8
		for _n in $THESETS; do echo $_n; done | showcols | sed 's/^/    /'
		COLUMNS=$_col
d1340 2
a1341 4
		$AUTO && exit 1
		echo
		return
	fi
d1343 2
a1344 3
	isin INSTALL.$ARCH $_files ||
		ask_yn "INSTALL.$ARCH not found. Use sets found here anyway?" ||
		return
d1346 2
a1347 1
	select_sets "$_sets" "$_get_sets"
d1349 2
a1350 2
	[[ -n $resp ]] || return
	_get_sets=$resp
d1352 3
a1354 2
	# Reorder $_get_sets
	_get_sets=$(for s in $THESETS; do isin $s $_get_sets && echo $s; done)
d1356 14
a1369 2
	# Note which sets didn't verify ok
	_unver=$_get_sets
d1371 4
a1374 5
	# Try to prefetch and control checksum files
	# use dummy for loop as combined assignment and do { ... } while(0)
	for _issue in ''; do
		! isin SHA256.sig $_files &&
			_issue="Directory does not contain SHA256.sig" && break
a1375 17
		# Find a filesystem to store the prefetched sets. Prefer file-
		# systems which are not used during extraction. They need to
		# have 512 MB free space. Otherwise use any other filesystem
		# having 2 GB free space to prevent overflow during extraction.
		_tmpfs=$( (
			for fs in /mnt/{{,var/}tmp,home,usr{/local,}}; do
				df -k $fs 2>/dev/null | grep " $fs\$"
			done
			df -k
		) | (
			while read a a a a m m; do
				[[ $m == /mnt/@@(@@(|var/)tmp|home|usr/@@(src,obj,xobj))@@(|/*) ]] &&
					((a > 524288)) && echo $m && exit
				[[ $m == /mnt@@(|/*) ]] &&
					((a > 524288 * 4)) && echo $m && exit
			done
		) )
d1377 3
a1379 6
		if [[ -d $_tmpfs ]]; then
			! _tmpsrc=$(tmpdir "$_tmpfs/sets") &&
			_issue="Cannot create prefetch area" && break
		else
			_issue="Cannot determine prefetch area" && break
		fi
d1381 2
a1382 4
		_cfile=$_tmpsrc/SHA256
		_srclocal=false
		_t=Get/Verify
		[[ $_src == file://* ]] && _srclocal=true _t='Verifying '
d1384 17
a1400 3
		# Fetch signature file
		! ftp -D "$_t" -Vmo "$_cfile.sig" "$_src/SHA256.sig" &&
			_issue="Cannot fetch SHA256.sig" && break
d1402 2
a1403 4
		# Verify signature file with public keys
		! signify -Vep /etc/signify/openbsd-${VERSION}-base.pub \
			-x "$_cfile.sig" -m "$_cfile" &&
			_issue="Signature check of SHA256.sig failed" && break
d1405 2
a1406 2
		for _f in $_get_sets; do
			rm -f "$_tmpsrc/h" "$_tmpsrc/fail"
d1408 21
a1428 7
			# Fetch set and create checksum by pipe through sha256
			# Create a flag file in case ftp failed. Sets from net
			# are written to prefetch area, the output of local sets
			# is discarded.
			( ftp -D "$_t" -Vmo - "$_src/$_f" || >"$_tmpsrc/fail" ) |
			( $_srclocal && sha256 >$_tmpsrc/h ||
				sha256 -ph "$_tmpsrc/h" >"$_tmpsrc/$_f" )
d1430 8
a1437 10
			# Handle failed transfer.
			if [[ -f $_tmpsrc/fail ]]; then
				rm -f "$_tmpsrc/$_f"
				if ! ask_yn "Fetching of $_f failed. Continue anyway?"; then
					[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc"
					$AUTO && exit 1
					return
				fi
				continue
			fi
d1439 13
a1451 10
			# Verify sets by comparing its checksum with SHA256.
			if fgrep -qx "SHA256 ($_f) = $(<$_tmpsrc/h)" "$_cfile"; then
				_unver=$(rmel $_f $_unver)
			else
				if ! ask_yn "Checksum test for $_f failed. Continue anyway?"; then
					[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc"
					$AUTO && exit 1
					return
				fi
			fi
d1453 9
a1461 1
	done
d1463 5
a1467 6
	[[ -n $_unver ]] && : ${_issue:="Unverified sets:" ${_unver% }}
	if [[ -n $_issue ]] &&
		! ask_yn "$_issue. Continue without verification?"; then
		[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc"
		$AUTO && exit 1
		return
d1470 13
a1482 3
	# XXX Delete this chunk after 5.8 (not a supported upgrade path)
	# XXX Undo old configurations where /var/tmp is a directory
	[[ $MODE == upgrade ]] && rm -rf /mnt/var/tmp
d1484 12
a1495 21
	for _f in $_get_sets; do
		_fsrc="$_src/$_f"
		[[ -f $_tmpsrc/$_f ]] && _fsrc="file://$_tmpsrc/$_f"
		case $_fsrc in
		*.tgz)	ftp -D Installing -Vmo - "$_fsrc" | tar -zxphf - -C /mnt
			if [[ $_f == ?(x)base*.tgz && $MODE == install ]]; then
				ftp -D Extracting -Vmo - \
				file:///mnt/usr/share/sysmerge/${_f%%base*}etc.tgz |
				tar -zxphf - -C /mnt
			fi;;
		*)	ftp -D Installing -Vmo "/mnt/$_f" "$_fsrc";;
		esac
		if (($?)); then
			if ! ask_yn "Installation of $_f failed. Continue anyway?"; then
				[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc"
				$AUTO && exit 1
				return
			fi
		else
			DEFAULTSETS=$(rmel $_f $DEFAULTSETS)
			GOTSETS="$GOTSETS $_f"
d1497 1
a1497 3
		[[ -d $_tmpsrc ]] && rm -f "$_tmpsrc/$_f"
	done
	[[ -d $_tmpsrc ]] && rm -rf "$_tmpsrc"
d1500 2
a1501 3
startcgiinfo() {
	# If no networks are configured, we do not need the httplist file
	((NIFS < 1)) && return
d1503 25
a1527 7
	# Make sure the ftp subshell gets its own process group
	set -m
	(
		# ftp.openbsd.org == 129.128.5.191 and will remain at
		# that address for the foreseeable future.
		ftp -Vao - "http://129.128.5.191/cgi-bin/ftplist.cgi?path=$HTTP_SETDIR" \
			2>/dev/null >$CGI_INFO
d1529 2
a1530 5
		# Remember finish time for adjusting the received timestamp
		echo -n $SECONDS >$HTTP_SEC
		feed_random
	) & CGIPID=$!
	set +m
d1532 3
a1534 5
	# If the ftp process takes more than 12 seconds, kill it
	# XXX We are relying on the pid space not randomly biting us --
	# XXX ftp could terminate early, and the pid could be reused
	(sleep 12; kill -INT -$CGIPID >/dev/null 2>&1) &
}
d1536 4
a1539 9
# Wait for the http process to finish, or be killed after the timeout
waitcgiinfo() {
	wait "$CGIPID" 2>/dev/null
	[[ -s $CGI_INFO ]] || return

	sed -n "s,^http://"'\([[A-Za-z0-9\:_][]A-Za-z0-9:._-]*\),\1,p' \
		$CGI_INFO >$HTTP_LIST 2>/dev/null
	set -- $(sed q $HTTP_LIST)
	: ${HTTP_SERVER:=${1%%/*}}
a1540 3
	CGI_METHOD=$(sed -n '/^method=/s///p' $CGI_INFO 2>/dev/null)
	CGI_TZ=$(sed -n '/^TZ=/s///p' $CGI_INFO 2>/dev/null)
	CGI_TIME=$(sed -n '/^TIME=/s///p' $CGI_INFO 2>/dev/null)
d1543 2
a1544 4
# If possible, print the timestamp received from the ftplist.cgi output,
# adjusted with the time elapsed since it was received
http_time() {
	local _sec=$(cat $HTTP_SEC 2>/dev/null)
d1546 2
a1547 3
	[[ -n $_sec && -n $CGI_TIME ]] &&
		echo $((CGI_TIME + SECONDS - _sec))
}
d1549 1
a1549 3
# Get several parameters from the user, and xfer files from the http server.
install_http() {
	local _file_list _prompt _mirror _url_base
d1551 2
a1552 7
	waitcgiinfo
	# N.B.: 'http_proxy' is an environment variable used by ftp(1). DON'T
	# change the name or case!
	ask "HTTP proxy URL? (e.g. 'http://proxy:8080', or 'none')" \
		"${http_proxy:-none}"
	unset http_proxy
	[[ $resp == none ]] || export http_proxy=$resp
d1554 3
a1556 5
	if [[ -s $HTTP_LIST ]]; then
		_prompt="HTTP Server? (hostname, list#, 'done' or '?')"
	else
		echo "(Unable to get list from ftp.openbsd.org, but that is OK)"
		_prompt="HTTP Server? (hostname or 'done')"
d1559 4
a1562 38
	# Get server IP address or hostname
	while :; do
		ask_until "$_prompt" "$HTTP_SERVER"
		case $resp in
		done)	return;;
		"?")	[[ -s $HTTP_LIST ]] || continue
			less -XEN < $HTTP_LIST
			;;
		+([0-9]))
			# A numeric hostname is ignored. A number is only used
			# as a line number in $HTTP_LIST.
			[[ -s $HTTP_LIST ]] || continue
			set -- $(sed -n "${resp}p" $HTTP_LIST)
			(($# < 1)) && { echo "There is no line $resp."; continue; }
			HTTP_SERVER=${1%%/*}
			# Repeat loop to get user to confirm server address.
			;;
		+([A-Za-z0-9\:.\[\]_-]))
			HTTP_SERVER=$resp
			break
			;;
		*)	echo "'$resp' is not a valid hostname."
			;;
		esac
	done

	# Get directory info from *last* line starting with the server
	# name. This means the last install from a mirror will not keep
	# the specific directory info. But an install from a local
	# server *will* remember the specific directory info.
	set -- $(sed "/^$HTTP_SERVER/x;\$!d;x" $HTTP_LIST 2>/dev/null)
	resp=${1#*/}
	# If there is no directory specified, don't use the server name!
	[[ $resp == "$1" ]] && resp=
	if (($# > 1)); then
		# It's a mirror, since it has location info.
		resp=$resp/$HTTP_SETDIR
		_mirror=yes
d1565 3
a1567 4
	: ${HTTP_DIR:=pub/OpenBSD/$HTTP_SETDIR}
	ask_until "Server directory?" "${resp:-$HTTP_DIR}"
	HTTP_DIR=$resp
	_url_base="http://$HTTP_SERVER/$HTTP_DIR"
d1569 8
a1576 5
	# Get list of files from the server.
	# Assumes index file is "index.txt" for http (or proxy)
	# We can't use index.html since the format is server-dependent
	_file_list=$(ftp -Vo - "$_url_base/index.txt" |
		sed 's/^.* //' | sed 's///')
d1578 10
a1587 1
	install_files "$_url_base" "$_file_list"
d1589 4
a1592 2
	# Remember where we installed from, to tell the cgi server.
	INSTALL=$_url_base
d1594 3
a1596 7
	# Bake a package path only if we installed from a mirror.
	PACKAGE_PATH=
	if [[ -n $_mirror ]]; then
		PACKAGE_PATH=$(print -r -- "$_url_base" |
			sed -E "/\/(snapshots|[0-9]\.[0-9])\/($ARCH)\/*$/!d
				s!!/\1/packages/$(arch -s)/!;q")
	fi
d1599 2
a1600 3
install_mounted_fs() {
	local _dir

d1602 9
a1610 9
		ask_until "Pathname to the sets? (or 'done')" "$SETDIR"
		[[ $resp == done ]] && return
		# Accept a valid /mnt2 or /mnt relative path.
		[[ -d /mnt2/$resp ]] && { _dir=/mnt2/$resp; break; }
		[[ -d /mnt/$resp ]] && { _dir=/mnt/$resp; break; }
		# Accept a valid absolute path.
		[[ -d /$resp ]] && { _dir=/$resp; break; }
		echo "The directory '$resp' does not exist."
		$AUTO && exit 1
d1612 1
d1614 3
a1616 1
	install_files "file://$_dir" "$(ls $_dir/)"
d1619 3
a1621 2
install_cdrom() {
	local _drive=$1
d1623 91
a1713 13
	mount_mnt2 $_drive || return

	install_mounted_fs
}

install_disk() {
	if ! ask_yn "Is the disk partition already mounted?"; then
		get_drive "disk" '$(bsort $(get_dkdevs))' \
			'$(bsort $(rmel $ROOTDISK $(get_dkdevs)))' || return
		mount_mnt2 $resp || return
	fi

	install_mounted_fs
d1716 2
a1717 2
install_nfs() {
	local _tcp
d1719 6
a1724 3
	# Get the IP address of the server.
	ask_until "Server IP address or hostname?" "$NFS_ADDR"
	NFS_ADDR=$resp
d1726 3
a1728 3
	# Get the server path to mount.
	ask_until "Filesystem on server to mount?" "$NFS_PATH"
	NFS_PATH=$resp
d1730 11
a1740 52
	# Determine use of TCP
	ask_yn "Use TCP transport? (requires TCP-capable NFS server)" && _tcp=-T

	# Mount the server
	mount_nfs $_tcp -o ro -R 5 $NFS_ADDR:$NFS_PATH /mnt2 || return

	install_mounted_fs
}

set_timezone() {
	local _zonefile=$1 _zonepath _zsed _tz _zoneroot=/usr/share/zoneinfo

	# If the timezone file is not available,
	# return immediately.

	[[ ! -f $_zonefile ]] && return

	# If configured in a previous call, return immediately
	[[ -n $TZ ]] && return

	if [[ -h /mnt/etc/localtime ]]; then
		TZ=$(ls -l /mnt/etc/localtime 2>/dev/null)
		TZ=${TZ#*${_zoneroot#/mnt}/}
	fi

	waitcgiinfo
	if [[ -n $CGI_TZ ]]; then
		_tz=$CGI_TZ
		[[ -n $_tz ]] && isin "$_tz" `cat $_zonefile` && TZ=$_tz
	fi

	# If neither the base or HTTP_LIST gave a hint, and this is the
	# early question, give up, and ask after the sets are installed
	[[ $_zonefile = /var/tzlist && -z $TZ ]] && return

	while :; do
		ask "What timezone are you in? ('?' for list)" "$TZ"
		_zonepath=${resp%%*(/)}
		case $_zonepath in
		"")	continue;;
		"?")	grep -v /. $_zonefile | showcols
			continue;;
		esac

		while isin "$_zonepath/" $(cat $_zonefile); do
			ask "What sub-timezone of '$_zonepath' are you in? ('?' for list)"
			_zsed=$(echo $_zonepath/ | sed 's,/,\\/,g')
			resp=${resp%%*(/)}
			case $resp in
			"")	;;
			"?")	sed -n "/^$_zsed/{s/$_zsed//;/\/./!p;}" $_zonefile | showcols;;
			*)	_zonepath=$_zonepath/$resp;;
d1742 3
a1744 5
		done

		if isin "$_zonepath" $(cat $_zonefile); then
			TZ=${_zonepath#$_zoneroot}
			return
a1745 3

		echo -n "'${_zonepath}'"
		echo " is not a valid timezone on this system."
d1747 5
a1751 1
}
d1753 1
a1753 4
# Check that missing required sets were deliberately skipped.
# Care is taken to make sure the return value is correct.
sane_install() {
	local _q=$1 _s
d1755 12
a1766 7
	for _s in $SANESETS; do
		isin $_s $DEFAULTSETS || continue
		[[ -n $_q ]] && return 1
		# If sane_install has no argument, harass the user.
		if ! ask_yn "Are you *SURE* your $MODE is complete without '$_s'?"; then
			$AUTO && exit 1 || return 1
		fi
d1768 2
d1772 3
a1774 5
# Ask the user for locations of sets, and then install whatever sets the
# user selects from that location. Repeat as many times as the user
# needs to get all desired sets.
install_sets() {
	local _cddevs=$(get_cddevs) _d _locs="disk http"
d1776 7
a1782 1
	echo
d1784 5
a1788 1
	_d=$CGI_METHOD
d1790 4
a1793 33
	ifconfig netboot >/dev/null 2>&1 && : ${_d:=http}
	[[ -n $_cddevs ]] && : ${_d:=cd0}
	[[ -x /sbin/mount_nfs ]] && _locs="$_locs nfs"
	: ${_d:=http}

	if ! isin "$_d" $_cddevs $_locs; then
		for a in http $_cddevs nfs disk; do
			isin $a $_cddevs $_locs && _d=$a && break
		done
	fi

	echo "Let's $MODE the sets!"
	while :; do
		_cddevs=$(get_cddevs)
		umount -f /mnt2 >/dev/null 2>&1

		ask "Location of sets? (${_cddevs:+$_cddevs }$_locs or 'done')" "$_d"
		case $resp in
		done)	sane_install && return;;
		c*|C*)	if [[ -n $_cddevs ]]; then
				set -- $_cddevs
				[[ $resp == @@(c|C|cd|CD|Cd|cD) ]] && resp=$1
				install_cdrom $resp && METHOD=$resp
			fi;;
		d*|D*)	install_disk && METHOD=disk;;
		h*|H*)	isin http $_locs && install_http && METHOD=http;;
		n*|N*)	isin nfs $_locs && install_nfs && METHOD=nfs;;
		*)	$AUTO && echo "'$resp' is not a valid choice." && exit 1;;
		esac

		[[ -n $METHOD ]] && _d=$METHOD
		sane_install quiet || $AUTO && _d=done
	done
a1850 37
# Must mount filesystems manually, one at a time, so we can make
# sure the mount points exist.
mount_fs() {
	local _async=$1 _dev _mp _fstype _opt _rest _msg _fail

	while read _dev _mp _fstype _opt _rest; do
		# If not the root filesystem, make sure the mount
		# point is present.
		[[ $_mp == /mnt ]] || mkdir -p $_mp

		# Mount the filesystem. Remember any failure.
		_msg=$(mount -v -t $_fstype $_async -o $_opt $_dev $_mp) ||
			_fail="$_fail\n$_mp ($_dev)"
		echo $_msg | sed 's/, ctime=[^,)]*//'
	done </etc/fstab

	if [[ -n $_fail ]]; then
		# One or more mounts failed. Continue or abort?
		echo "\nWARNING! The following filesystems were not properly mounted:$_fail"
		ask_yn "Continue anyway?" || exit
	fi
}

# Return the device name for the supplied device, which may be a disklabel UID.
getdevname() {
	local _dev=$1
	if [[ ${#_dev} == 18 && $_dev == +([0-9a-f]).[a-p] ||
		${#_dev} == 16 && $_dev == +([0-9a-f]) ]]; then
		# Lookup device name matching the disklabel UID
		sysctl -n hw.disknames |
			sed -nE "s/^(.*,)*(.*):${_dev%.?}.*/\\2/p"
	else
		_dev=${_dev#/dev/}
		print -r -- "${_dev%[a-p]}"
	fi
}

d1880 38
a1917 4
# Extract fully qualified domain name from current hostname. If none is
# currently set, use 'my.domain'.
get_fqdn() {
	local _dn
d1919 1
a1919 3
	_dn=$(hostname)
	_dn=${_dn#$(hostname -s)}
	_dn=${_dn#.}
d1921 1
a1921 2
	echo "${_dn:=my.domain}"
}
d1923 4
a1926 2
donetconfig() {
	local _dn _ns _n
d1928 3
a1930 13
	configure_ifs
	v4_defroute

	# As dhclient will populate /etc/resolv.conf, a symbolic link to
	# /tmp/resolv.conf.shadow, mv any such file to /tmp/resolv.conf
	# so it will eventually be copied to /mnt/etc/resolv.conf and will
	# not in the meantime remove the user's ability to choose to use it
	# or not, during the rest of the install.
	if [[ -f /tmp/resolv.conf.shadow ]]; then
		mv /tmp/resolv.conf.shadow /tmp/resolv.conf
		# Get nameserver address(es). Store as a blank separated list.
		for _n in $(grep '^nameserver ' /tmp/resolv.conf); do
			[[ $_n == nameserver ]] || _ns="$_ns$_n "
a1931 9
		# Zap trailing space in _ns.
		set -- $_ns
		_ns=$*
		# Get default fully qualified domain name from *first* domain
		# given on *last* search or domain statement.
		_dn=$(sed -n \
			-e '/^domain[[:space:]][[:space:]]*/{s///;s/\([^[:space:]]*\).*$/\1/;h;}' \
			-e '/^search[[:space:]][[:space:]]*/{s///;s/\([^[:space:]]*\).*$/\1/;h;}' \
			-e '${g;p;}' /tmp/resolv.conf)
d1934 18
a1951 8
	# Get & apply fully qualified domain name to hostname.
	resp="${_dn:=$(get_fqdn)}"
	if [[ ! -f /tmp/dhclient.conf || $NIFS != 1 ]]; then
		ask "DNS domain name? (e.g. 'bar.com')" "$resp"
	else
		echo "Using DNS domainname $resp"
	fi
	hostname "$(hostname -s).$resp"
d1953 3
a1955 16
	# If only one interface, and it is running dhclient, ask nothing
	# else Get/Confirm nameservers
	resp="${_ns:=none}"
	if [[ ! -f /tmp/dhclient.conf || $NIFS != 1 || $resp == none ]]; then
		ask "DNS nameservers? (IP address list or 'none')" "$resp"
	else
		echo "Using DNS nameservers at $resp"
	fi
	# Construct appropriate resolv.conf.
	if [[ $resp != none ]]; then
		echo "lookup file bind" >/tmp/resolv.conf
		for _ns in $resp; do
			echo "nameserver $_ns" >>/tmp/resolv.conf
		done
		cp /tmp/resolv.conf /tmp/resolv.conf.shadow
	fi
d1991 9
a1999 50
questions() {
	local _d _cdef=no

	ask_yn "Start sshd(8) by default?" yes
	sshd=$resp

	ask_yn "Start ntpd(8) by default?"
	ntpd=$resp
	if [[ $resp == y ]]; then
		ask "NTP server? (hostname or 'default')" default
		ntpd_server=$resp
	fi

	aperture=
	resp=
	xdm=
	if [[ -n $DISPLAY ]]; then
		if [[ -n $(scan_dmesg '/^[a-z]*[01]: aperture needed/p') ]]; then
			ask_yn "Do you expect to run the X Window System?" yes &&
				aperture=$MDXAPERTURE
		fi
		if [[ -n $MDXDM && $resp != n ]]; then
			ask_yn "Do you want the X Window System to be started by xdm(1)?"
			xdm=$resp
		fi
	fi

	if [[ -n $CDEV ]]; then
		_d=${CPROM:-$CDEV}
		[[ -n $CONSOLE ]] && _cdef=yes
		ask_yn "Change the default console to $_d?" $_cdef
		defcons=$resp
		if [[ $resp == y ]]; then
			ask_which "speed" "should $_d use" \
				"9600 19200 38400 57600 115200" $CSPEED
			case $resp in
			done)	defcons=n;;
			*)	CSPEED=$resp;;
			esac
		fi
	fi
}

# Feed the random pool some entropy before we read from it
feed_random() {
	(dmesg; cat $CGI_INFO /*.conf; sysctl; route -n show; df;
		ifconfig -A; hostname) >/dev/random 2>&1
	if [[ -e /mnt/var/db/host.random ]]; then
		dd if=/mnt/var/db/host.random of=/dev/random bs=65536 count=1 \
			status=none
a2080 105
}

# Show device name, label and size for the provided list of devices
diskinfo() {
	local _d
	for _d; do
		makedev $_d
		echo -n "$_d: "
		disklabel -dpg $_d 2>/dev/null |
		sed	-e '/^label: /{s,,,;s/ *$//;s/^$/<no label>/;H;d;}' \
			-e '/.*# total bytes: \(.*\)/{s//(\1)/;H;}' \
			-e '$!d;x;s/\n/ /'
		rm -f /dev/{r,}$_d?
	done
}

# Get global root information. ie. ROOTDISK, ROOTDEV and SWAPDEV.
get_rootinfo() {
	while :; do
		echo "Available disks are: $(get_dkdevs | sed 's/^$/none/')."
		_ask "Which disk is the root disk? ('?' for details)" \
			$(get_dkdevs | sed 's/ .*//') || continue
		case $resp in
		"?")	diskinfo $(get_dkdevs);;
		'')	;;
		*)	isin "$resp" $(get_dkdevs) && break
			echo "no such disk";;
		esac
	done
	makedev $resp || exit

	ROOTDISK=$resp
	ROOTDEV=${ROOTDISK}a
	SWAPDEV=${ROOTDISK}b
}

# Fetch response file for autoinstall.
get_responsefile() {
	local _rf _ifdev _mac _mode _server _lf
	action=

	[[ -f /auto_upgrade.conf ]] && _rf=/auto_upgrade.conf _mode=upgrade
	[[ -f /auto_install.conf ]] && _rf=/auto_install.conf _mode=install
	[[ -f $_rf ]] && cp $_rf /ai.$_mode.conf && action=$_mode && return

	# Select a network interface for initial dhcp request.
	# Ask if multiple were found and system was not netbooted.
	# Extract server ip address and installer mode from lease file.
	# Prime hostname with host-name option.
	for _ifdev in ''; do
		[[ -x /sbin/dhclient ]] || break
		set -- $(get_ifdevs netboot)
		(($# == 0)) && set -- $(get_ifdevs)
		(($# == 1)) && _ifdev=$1
		while (($# > 1)); do
			ask_which "network interface" \
				"should be used for the initial DHCP request" "$*"
			isin "$resp" $* && _ifdev=$resp && break
		done
		[[ -n $_ifdev ]] && dhclient $_ifdev || break
		_lf=/var/db/dhclient.leases.$_ifdev
		_server=$(sed "/^ *next-server /!d;s///;s/;$//;q" $_lf)
		_mode=$(sed -E '/^ *filename "auto_(install|upgrade)";$/!d;s//\1/;q' $_lf)
		hostname "$(sed -E '/^ *option host-name "(.*)";$/!d;s//\1/;q' $_lf)"
	done

	# Fetch response file if server and mode are known, otherwise tell which
	# one was missing. First try to fetch mac-mode.conf, then mode.conf.
	if [[ -n $_server && -n $_mode ]]; then
		_mac=$(ifconfig $_ifdev | sed 's/.*lladdr \(.*\)/\1/p;d')
		for _rf in {$_mac-,}$_mode; do
			_url=http://$_server/$_rf.conf
			echo "Fetching $_url"
			if ftp -Vo "/ai.$_mode.conf" "$_url" 2>/dev/null; then
				action=$_mode
				ifconfig $_ifdev delete down 2>/dev/null
				return 0
			fi
		done
	else
		[[ -z $_server ]] && echo "Could not determine next-server."
		[[ -z $_mode ]] && echo "Could not determine auto mode."
	fi

	# Ask for url or local path to response file. Provide a default url if
	# server was found in lease file.
	while :; do
		ask "Response file location?" \
			"${_server:+http://$_server/install.conf}"
		[[ -n $resp ]] && _rf=$resp && break
	done

	# Ask for the installer mode only if auto-detection failed.
	_mode=$(echo "$_rf" | sed -En 's/^.*(install|upgrade).conf$/\1/p')
	while [[ -z $_mode ]]; do
		ask "(I)nstall or (U)pgrade?"
		[[ $resp == [iI]* ]] && _mode=install
		[[ $resp == [uU]* ]] && _mode=upgrade
	done

	echo "Fetching $_rf"
	[[ -f $_rf ]] && _rf="file://$_rf"
	ftp -Vo "/ai.$_mode.conf" "$_rf" 2>/dev/null && action=$_mode
	ifconfig $_ifdev delete down 2>/dev/null
	[[ -n $action ]]
@


1.821
log
@Move code that gets executed when install.sub is sourced
to the bottom of the file to make it easier to see what
code is actually executed.

OK krw@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.820 2015/03/21 16:45:53 rpe Exp $
a1584 4
update_firmware() {
	echo "/usr/sbin/fw_update -v" >>/mnt/etc/rc.firsttime
}

d1917 2
a1918 1
	update_firmware
@


1.820
log
@Bourne to Korn shell

OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.819 2015/03/17 15:21:02 rpe Exp $
a60 31
# Parse parameters
AUTO=false
RESPFILE=
while getopts "af:" opt; do
	case $opt in
	a)	AUTO=true;;
	f)	RESPFILE=$OPTARG;;
	*)	usage;;
	esac
done
shift $((OPTIND-1))
(($# == 0)) || usage

# Include machine-dependent functions and definitions.
#
# The following functions must be provided:
#	md_congrats()		  - display friendly message
#	md_installboot()	  - install boot-blocks on disk
#	md_prep_disklabel()	  - put an OpenBSD disklabel on the disk
#	md_consoleinfo()	  - set CDEV, CTTY, CSPEED, CPROM
#
# The following variables can be provided if required:
#	MDSETS	    - list of files to add to THESETS
#	MDTERM      - 'vt220' assumed if not provided
#	MDDKDEVS    - '/^[sw]d[0-9][0-9]* /s/ .*//p' assumed if not provided
#	MDCDDEVS    - '/^cd[0-9][0-9]* /s/ .*//p'    assumed if not provided
#	MDMTDEVS    - '/^[cms]t[0-9][0-9]* /s/ .*//p'
#	MDXAPERTURE - set machdep.allowaperture=value in sysctl.conf
#	NCPU	    - the number of cpus for mp capable arches
. install.md

a190 3
# Make sure lock is initially released
rm -df /tmp/lock

a206 24
# The dmesg listener will check for the existance of this file and send a
# signal to the child process if the dmesg output differs from the contents
# of that file
rm -f /tmp/update

if ! $AUTO; then
	# Start listener process looking for dmesg changes
	(
		while :; do
			lock
			if test -e /tmp/update && [[ "`dmesg`" != "`cat /tmp/update`" ]]; then
				dmesg >/tmp/update
				kill -TERM 2>/dev/null $$ || exit 1
			fi
			unlock
			sleep .5
		done
	) |&
	cppid=$!

	# Kill the child on exit
	retrap
fi

d2057 58
@


1.819
log
@Restore previous behaviour that got lost with 1.780.
Don't ask about xdm if the answer to the X question was no.

Noted by mlarkin@@
"Looks good" deraadt@@
OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.818 2015/03/15 00:09:50 krw Exp $
d72 1
a72 1
[ $# = 0 ] || usage
d1117 1
a1117 1
		if [ -f /mnt/etc/$_f ]; then
@


1.818
log
@Eliminate the question 'Which cd?' and just show the available cd's
in the 'Location of sets?' prompt.

Idea from deraadt@@

Developed with and tested by rpe@@

ok deraadt@@ rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.817 2015/03/13 15:02:14 deraadt Exp $
d1882 1
d1889 1
a1889 1
		if [[ -n $MDXDM ]]; then
@


1.817
log
@chroot is now inside instbin, so do not need to run the copy in /mnt
ok rpe
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.816 2015/03/11 21:00:35 krw Exp $
d1490 3
a1492 2
	get_drive "CD-ROM" '$(get_cddevs)' || return
	mount_mnt2 $resp || return
d1602 1
a1602 1
	local _d _locs="disk http"
d1609 1
a1609 1
	[[ -n $(get_cddevs) ]] && { _locs="cd $_locs"; : ${_d:=cd}; }
d1613 3
a1615 3
	if ! isin "$_d" $_locs; then
		for a in http cd nfs disk; do
			isin $a $_locs && _d=$a && break
d1621 1
d1624 1
a1624 1
		ask "Location of sets? ($_locs or 'done')" "$_d"
d1627 5
a1631 1
		c*|C*)	isin cd $_locs && install_cdrom && METHOD=cd;;
@


1.816
log
@Shuffle some code around to make it easier to read. Add get_rootinfo()
and shuffle some install specific code into install.sh. No intentional
functional change.

Update copyrights to 2015 while here.

Tested & ok rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.815 2015/03/08 13:15:00 deraadt Exp $
d1959 1
a1959 1
	[[ -x /mnt/$MODE.site ]] && /mnt/usr/sbin/chroot /mnt /$MODE.site
@


1.815
log
@oops, wrong file to commit a diff to
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.813 2015/03/05 17:56:35 krw Exp $
d3 1
a3 1
# Copyright (c) 1997-2009 Todd Miller, Theo de Raadt, Ken Westerback
d1993 106
a2185 71
# Fetch response file for autoinstall.
get_responsefile() {
	local _rf _ifdev _mac _mode _server _lf
	action=

	[[ -f /auto_upgrade.conf ]] && _rf=/auto_upgrade.conf _mode=upgrade
	[[ -f /auto_install.conf ]] && _rf=/auto_install.conf _mode=install
	[[ -f $_rf ]] && cp $_rf /ai.$_mode.conf && action=$_mode && return

	# Select a network interface for initial dhcp request.
	# Ask if multiple were found and system was not netbooted.
	# Extract server ip address and installer mode from lease file.
	# Prime hostname with host-name option.
	for _ifdev in ''; do
		[[ -x /sbin/dhclient ]] || break
		set -- $(get_ifdevs netboot)
		(($# == 0)) && set -- $(get_ifdevs)
		(($# == 1)) && _ifdev=$1
		while (($# > 1)); do
			ask_which "network interface" \
				"should be used for the initial DHCP request" "$*"
			isin "$resp" $* && _ifdev=$resp && break
		done
		[[ -n $_ifdev ]] && dhclient $_ifdev || break
		_lf=/var/db/dhclient.leases.$_ifdev
		_server=$(sed "/^ *next-server /!d;s///;s/;$//;q" $_lf)
		_mode=$(sed -E '/^ *filename "auto_(install|upgrade)";$/!d;s//\1/;q' $_lf)
		hostname "$(sed -E '/^ *option host-name "(.*)";$/!d;s//\1/;q' $_lf)"
	done

	# Fetch response file if server and mode are known, otherwise tell which
	# one was missing. First try to fetch mac-mode.conf, then mode.conf.
	if [[ -n $_server && -n $_mode ]]; then
		_mac=$(ifconfig $_ifdev | sed 's/.*lladdr \(.*\)/\1/p;d')
		for _rf in {$_mac-,}$_mode; do
			_url=http://$_server/$_rf.conf
			echo "Fetching $_url"
			if ftp -Vo "/ai.$_mode.conf" "$_url" 2>/dev/null; then
				action=$_mode
				ifconfig $_ifdev delete down 2>/dev/null
				return 0
			fi
		done
	else
		[[ -z $_server ]] && echo "Could not determine next-server."
		[[ -z $_mode ]] && echo "Could not determine auto mode."
	fi

	# Ask for url or local path to response file. Provide a default url if
	# server was found in lease file.
	while :; do
		ask "Response file location?" \
			"${_server:+http://$_server/install.conf}"
		[[ -n $resp ]] && _rf=$resp && break
	done

	# Ask for the installer mode only if auto-detection failed.
	_mode=$(echo "$_rf" | sed -En 's/^.*(install|upgrade).conf$/\1/p')
	while [[ -z $_mode ]]; do
		ask "(I)nstall or (U)pgrade?"
		[[ $resp == [iI]* ]] && _mode=install
		[[ $resp == [uU]* ]] && _mode=upgrade
	done

	echo "Fetching $_rf"
	[[ -f $_rf ]] && _rf="file://$_rf"
	ftp -Vo "/ai.$_mode.conf" "$_rf" 2>/dev/null && action=$_mode
	ifconfig $_ifdev delete down 2>/dev/null
	[[ -n $action ]]
}

a2224 61

if [[ $MODE == install ]]; then
	ask_until "System hostname? (short form, e.g. 'foo')" "$(hostname -s)"
	[[ ${resp%%.*} != $(hostname -s) ]] && hostname $resp
	THESETS="$THESETS site$VERSION-$(hostname -s).tgz"

	echo
	donetconfig

	((NIFS != 0)) && startcgiinfo

	echo
	while :; do
		askpassword "Password for root account?"
		_rootpass="$_password"
		[[ -n "$_password" ]] && break
		echo "The root password must be set."
	done

	rootkey=
	$AUTO && ask "Public ssh key for root account?" none &&
		[[ $resp != none ]] && rootkey=$resp

	questions
	user_setup

	set_timezone /var/tzlist
	echo
fi

# Show device name, label and size for the provided list of devices
diskinfo() {
	local _d
	for _d; do
		makedev $_d
		echo -n "$_d: "
		disklabel -dpg $_d 2>/dev/null |
		sed	-e '/^label: /{s,,,;s/ *$//;s/^$/<no label>/;H;d;}' \
			-e '/.*# total bytes: \(.*\)/{s//(\1)/;H;}' \
			-e '$!d;x;s/\n/ /'
		rm -f /dev/{r,}$_d?
	done
}

# Get ROOTDISK, ROOTDEV and SWAPDEV.
while :; do
	echo "Available disks are: $(get_dkdevs | sed 's/^$/none/')."
	_ask "Which disk is the root disk? ('?' for details)" \
		$(get_dkdevs | sed 's/ .*//') || continue
	case $resp in
	"?")	diskinfo $(get_dkdevs);;
	'')	;;
	*)	isin "$resp" $(get_dkdevs) && break
		echo "no such disk";;
	esac
done
makedev $resp || exit

ROOTDISK=$resp
ROOTDEV=${ROOTDISK}a
SWAPDEV=${ROOTDISK}b
@


1.814
log
@last rev fixed upgrades, but broke installs, sigh.  use on-bsd.rd sdboot
for LIF/header creation, pre-disklabel.  post-install/upgrade, this
gets redone, this time with -r /mnt to pick up the new sdboot file
ok krw jsing miod
@
text
@d1959 1
a1959 1
	[[ -x /mnt/$MODE.site ]] && chroot /mnt /$MODE.site
@


1.813
log
@Manipulate only whole words when flipping 'ro' and 'rw' in fstab entries.

Fixes 'groupquota' -> 'grwupquota' damage noted by giovanni@@.

Diff from rpe@@, ok halex@@, giovanni@@, deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.812 2015/01/24 00:20:35 krw Exp $
d1959 1
a1959 1
	[[ -x /mnt/$MODE.site ]] && /mnt/usr/sbin/chroot /mnt /$MODE.site
@


1.812
log
@In shell statements use shell pattern '+([0-9])', not sed regular
expression '[0-9]*'.

Should fix problem reported by jsg@@ where 'hostname.vlan6.bak' was
deemed to be an active vlan specification during upgrade.

No change to script output.

Tested by rpe@@.

ok halex@@ rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.811 2015/01/17 14:36:58 rpe Exp $
d1675 2
a1676 1
		[[ $_fstype == ffs ]] && _opt=$(echo $_opt | sed 's/ro/rw/')
d1679 2
a1680 1
		[[ $_fstype == ffs ]] || _opt=$(echo $_opt | sed 's/rw/ro/')
@


1.811
log
@Remove unnecessary double-quotes inside [[]].

OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.810 2015/01/17 10:09:06 rpe Exp $
d168 1
a168 1
		isin ${_if%%[0-9]*} $_iflist || echo $_if
d674 1
a674 1
		if [[ $_ifs == vlan[0-9]* ]]; then
d691 1
a691 1
			while [[ $1 == vlan[0-9]* ]]; do
d699 1
a699 1
			if ! (isin "$_vd" $_ifdevs && [[ $_vd != vlan[0-9]* ]]); then
d1131 1
a1131 1
		if isin ${if%%[0-9]*} $(ifconfig -C); then
d1133 1
a1133 1
			case ${if%%[0-9]*} in
@


1.810
log
@Uppercase global vars (auto -> AUTO, respfile -> RESPFILE)

OK krw@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.809 2015/01/12 16:33:31 deraadt Exp $
d1986 1
a1986 1
	[[ "$MODE" == upgrade ]] && \
@


1.809
log
@Enable lid suspends by default in the kernel, and remove the question from
the installer.  We used a full release cycle to learn that suspend/resume
is reliable enough for this default.  Personal policy can disable this using
machdep.lidsuspend=0 in /etc/sysctl.conf
ok more people begging, and less people whining
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.808 2015/01/07 19:31:51 rpe Exp $
d62 2
a63 2
auto=false
respfile=
d66 2
a67 2
	a)	auto=true;;
	f)	respfile=$OPTARG;;
d246 1
a246 1
if ! $auto; then
d304 1
a304 1
# Search question in $respfile, return answer in $resp
d319 1
a319 1
	[[ -f $respfile ]] || return
d345 1
a345 1
	if $auto; then
d409 1
a409 1
	$auto && ask "Public ssh key for user $user" none &&
d431 1
a431 1
		$auto && exit 1
d454 1
a454 1
		$auto && exit 1
d497 1
a497 1
		$auto && [[ -n $respfile ]] && exit 1
d744 1
a744 1
		
d1001 1
a1001 1
	if $auto; then
d1200 1
a1200 1
		$auto && exit 1
d1281 1
a1281 1
					$auto && exit 1
d1293 1
a1293 1
					$auto && exit 1
d1304 1
a1304 1
		$auto && exit 1
d1327 1
a1327 1
				$auto && exit 1
d1483 1
a1483 1
		$auto && exit 1
d1592 1
a1592 1
			$auto && exit 1 || return 1
d1629 1
a1629 1
		*)	$auto && echo "'$resp' is not a valid choice." && exit 1;;
d1633 1
a1633 1
		sane_install quiet || $auto && _d=done
d1988 1
a1988 1
	$auto && >/ai.done
d2150 1
a2150 1
if ! $auto; then
d2158 1
a2158 1
elif [[ -z $respfile ]]; then
d2183 1
a2183 1
	cp $respfile /ai.conf || exit
d2208 1
a2208 1
	$auto && ask "Public ssh key for root account?" none &&
@


1.808
log
@Cleanup network config after fetching the responsefile. This enables
automatic upgrades on systems with trunk interfaces.

OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.807 2015/01/07 19:20:53 rpe Exp $
a1844 4
	[[ -n $lidsuspend ]] &&
		echo "machdep.lidsuspend=1 # Try to suspend on lid close" \
			>>/mnt/etc/sysctl.conf

a1874 1
	lidsuspend=
a1882 4
		fi
		if [[ -n $MDLID ]]; then
			ask_yn "Do you want to suspend on lid close?" yes && \
				lidsuspend=$resp
@


1.807
log
@Fix get_ifdevs() - don't filter vlan interfaces.

OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.806 2015/01/04 18:44:12 tedu Exp $
d2090 1
d2124 5
a2128 2
			ftp -Vo "/ai.$_mode.conf" "$_url" 2>/dev/null &&
				action=$_mode && return
d2154 2
@


1.806
log
@back to using ramdisk encrypt again. theo found and fixed the (my) bug.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.805 2015/01/04 02:26:29 tedu Exp $
d164 1
a164 1
	local _if _iflist=$(ifconfig -C)
@


1.805
log
@go back to using /mnt encrypt. it seems something isn't working yet.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.804 2015/01/01 22:53:39 krw Exp $
d372 1
a372 1
		/mnt/usr/bin/encrypt -b a -- "$_p"
@


1.804
log
@Enable 'ifconfig -C' (list dynamic interface types) on install
media. Use this feature in install scripts to eliminate manually
maintained list of dynamic interface types.

'-C' brought to my attention by reyk@@, tweaks to install script to
use -C in get_ifdevs() from rpe@@.

ok rpe@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.803 2014/12/29 17:04:19 deraadt Exp $
d372 1
a372 1
		encrypt -b a -- "$_p"
@


1.803
log
@encrypt is now built into instbin, do not need to use the /mnt version
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.802 2014/12/29 16:55:44 tedu Exp $
d164 6
a169 3
	ifconfig "$@@" 2>/dev/null |
		egrep -v '^[[:space:]]|(bridge|enc|gif|gre|lo|pflog|pfsync|ppp|tun)[[:digit:]]+:' |
		sed -n 's/^\(.*\):.*/\1/p'
d1131 11
a1141 20
		# Check for ifconfig'able interface.
		(ifconfig $if||ifconfig $if create) >/dev/null 2>&1 || continue
		# Don't immediately do interfaces constructed from others.
		# Skip uninteresting devices.
		case ${if%%[0-9]*} in
		trunk)	_trunks="$_trunks $hn"
			continue
		       ;;
		svlan)	_svlans="$_svlans $hn"
			continue
			;;
		vlan)	_vlans="$_vlans $hn"
			continue
			;;
		bridge|carp|enc|gif|gre|lo|pflog|pfsync|ppp|tun)
			continue
			;;
		esac
		# Now parse the hostname.* file
		ifstart $hn
d1143 1
a1143 1
	# Configure any constructed interfaces now that 'real' ones are up.
@


1.802
log
@switch encrypt to auto scaling bcrypt rounds. ok deraadt
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.801 2014/12/26 17:54:54 rpe Exp $
d369 1
a369 1
		/mnt/usr/bin/encrypt -b a -- "$_p"
@


1.801
log
@Remove upgrade_to64time_t() now that the transition to 64 bit time_t
is done.

diff from tj at mrsk.me
OK halex@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.800 2014/12/03 19:55:49 florian Exp $
d369 1
a369 1
		/mnt/usr/bin/encrypt -b 8 -- "$_p"
@


1.800
log
@The kernel handles rtsol(8) functionality since some time now.
Treat rtsol in hostname.if as a keyword like dhcp and call ifconfig
inet6 autoconf.
"reads good" todd@@
OK krw@@ (who is *not* an IPv6 person), but I recruited him in his
capacity as an installer person.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.799 2014/11/18 19:00:16 rpe Exp $
a1916 8
# Rebuild or wipe time_t size dependant stuff.
# XXX To be removed after 5.6 is released.
upgrade_to64time_t() {
	/mnt/usr/sbin/pwd_mkdb -d /mnt/etc master.passwd
	>/mnt/var/log/lastlog
	>/mnt/var/run/utmp
}

a1985 3

	# XXX To be removed after 5.6 is released.
	upgrade_to64time_t
@


1.799
log
@Delete tmp directory in /mnt/var during upgrades right before the
extraction of baseXX.tgz creates the symlink to ../tmp.

OK deraadt
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.798 2014/11/11 21:31:29 rpe Exp $
d939 1
a939 1
	[[ -x /sbin/rtsol ]] && _prompt="or 'rtsol' "
d946 1
a946 1
	rtsol)	[[ ! -x /sbin/rtsol ]] && { echo "No /sbin/rtsol."; return; }
d948 1
a948 1
		rtsol -F $_ifs && echo "up\nrtsol" >>$_hn
d1052 6
a1057 2
			rtsolif="$rtsolif $if"
			cmd="ifconfig $if $name $mask $bcaddr $ext1 $ext2 up"
d1155 1
a1155 1
	[[ -n $rtsolif ]] && /mnt/sbin/rtsol -F $rtsolif
@


1.798
log
@Store autoinstaller logfile in /mnt/var/log to be available after
reboot and to cope with an upcoming change to /var/tmp.

Noted by and OK halex@@
OK deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.797 2014/10/26 23:31:00 krw Exp $
d1309 4
@


1.797
log
@Defer processing hostname.if files for trunks, svlans and vlans
during upgrades. This ensures all physical interfaces are configured
first, as is done in /etc/netstart.

Currently only vlans are present in install images, but that could
change.

Requested by many so trunks might work during upgrades.  Prodded
by henning@@ actually creating a diff to add trunks to boot images.

Tested & ok rpe@@ sthen@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.796 2014/10/23 21:33:21 rpe Exp $
d2181 1
a2181 1
		while _lf=/mnt/var/tmp/ai.log.$RANDOM && test -e $_lf; do done
@


1.796
log
@Extend autoinstall(8) feature:

- Ask for responsefile location (url or local path) if dhcp discovery
  fails for location or mode.  If 'next-server' is found in dhcp lease
  file, provide a default url http://next-server/install.conf.

- Ask for installer mode if the specified response file name does not
  match *install.conf or *upgrade.conf.

- If present, use /auto_install.conf or /auto_upgrade.conf as response
  file for unattended installation or upgrade.

- Automatically start installer in unattended mode if either one of
  these files is present when the system boots.

- Document changes in manpage and installation notes.

OK krw@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.795 2014/10/08 00:26:38 krw Exp $
d1013 92
d1106 1
a1106 1
	local _f _gw
d1122 1
a1122 3
		((NIFS++))

		# Strip off /mnt/etc/hostname. prefix
a1123 1

d1126 16
a1141 1

d1143 6
a1148 86
		while :; do
			if [ "$cmd2" ]; then
				# we are carrying over from the 'read dt dtaddr'
				# last time
				set -- $cmd2
				af=$1 name=$2 mask=$3 bcaddr=$4 ext1=$5 cmd2=
				# make sure and get any remaining args in ext2,
				# like the read below
				i=1
				while [ i -lt 6 -a -n "$1" ]; do shift; let i=i+1; done
				ext2="$@@"
			else
				# read the next line or exit the while loop
				read af name mask bcaddr ext1 ext2 || break
			fi
			# $af can be "dhcp", "rtsol", an address family,
			# commands, or a comment.
			case "$af" in
			"#"*|"!"*|"bridge"|"")
				# skip comments, user commands, bridges,
				# and empty lines
				continue
				;;
			"dhcp")	[ "$name" = "NONE" ] && name=
				[ "$mask" = "NONE" ] && mask=
				[ "$bcaddr" = "NONE" ] && bcaddr=
				dhcpif="$dhcpif $if"
				cmd="ifconfig $if $name $mask $bcaddr $ext1 $ext2 down"
				if [[ -x /sbin/dhclient ]]; then
					cmd="$cmd; dhclient $if"
				else
					cmd="$cmd; echo /sbin/dhclient missing - skipping dhcp request."
				fi
				;;
			"rtsol")
				rtsolif="$rtsolif $if"
				cmd="ifconfig $if $name $mask $bcaddr $ext1 $ext2 up"
				;;
			*)	read dt dtaddr
				if [ "$name" = "alias" ]; then
					# perform a 'shift' of sorts
					alias=$name
					name=$mask
					mask=$bcaddr
					bcaddr=$ext1
					ext1=$ext2
					ext2=
				else
					alias=
				fi
				cmd="ifconfig $if $af $alias $name"
				case "$dt" in
				dest)	cmd="$cmd $dtaddr"
					;;
				*)
					cmd2="$dt $dtaddr"
					;;
				esac
				case $af in
				inet)
					if [ ! -n "$name" ]; then
						echo "/etc/hostname.$if: inet alone is invalid"
						return
					fi
					[ "$mask" ] && cmd="$cmd netmask $mask"
					if [ "$bcaddr" -a X"$bcaddr" != "XNONE" ]; then
						cmd="$cmd broadcast $bcaddr"
					fi
					[ "$alias" ] && rtcmd=";route -qn add -host $name 127.0.0.1"
					;;
				inet6)
					if [ ! -n "$name" ]; then
						echo "/etc/hostname.$if: inet6 alone is invalid"
						return
					fi
					[ "$mask" ] && cmd="$cmd prefixlen $mask"
					cmd="$cmd $bcaddr"
					;;
				*)	cmd="$cmd $mask $bcaddr"
					;;
				esac
				cmd="$cmd $ext1 $ext2$rtcmd" rtcmd=
				;;
			esac
			eval "$cmd"
		done </mnt/etc/hostname.$if
@


1.795
log
@sl(4) was tedu'd. No need to filter it out of interface list anymore.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.794 2014/09/26 15:44:21 benno Exp $
d2072 1
a2072 5
# Fetch a response file from a http server.
#
# Select a network interface for an initial dhcp request to get the IP
# from the lease file via the next-server attribute.
#
d2074 1
a2074 2
	local _f _ifdev _mac _mode _server _lf
	[[ -x /sbin/dhclient ]] || return
d2076 35
a2110 32
	_ifdev=$(get_ifdevs netboot)
	if [[ -z $_ifdev ]]; then
		set -- $(get_ifdevs)
		(($#)) || return
		if (($# == 1)); then
			_ifdev=$1
		else
			while :; do
				ask_which "network interface" \
					"should be used for the initial DHCP request" \
					"$*"
				isin "$resp" $* && _ifdev=$resp && break
			done
		fi
	fi
	[[ -n $_ifdev ]] || return

	dhclient $_ifdev

	_lf=/var/db/dhclient.leases.$_ifdev
	_server=$(sed "/^ *next-server /!d;s///;s/;$//;q" $_lf)
	_mode=$(sed -E '/^ *filename "auto_(install|upgrade)";$/!d;s//\1/;q' \
		$_lf)
	_mac=$(ifconfig $_ifdev | sed 's/.*lladdr \(.*\)/\1/p;d')

	# Prime hostname with host-name option
	hostname "$(sed -E '/^ *option host-name "(.*)";$/!d;s//\1/;q' $_lf)"

	if [[ -z $_server ]]; then
		echo "Could not determine next-server."
	elif [[ -z $_mode ]]; then
		echo "Could not determine auto mode."
d2112 2
a2113 4
		for _f in {$_mac-,}$_mode; do
			ftp -o "/$_mode.conf" "http://$_server/$_f.conf" &&
				action=$_mode && return 0
		done
d2116 19
a2134 2
	# No response file found
	return 1
d2153 1
a2153 1
	/$action -af /$action.conf 2>&1 </dev/null | sed 's/^.*//;w/ai.log'
@


1.794
log
@make the default of the "Change the default console" question depend
on whether the install is done on a serial console.

ok halex@@, deraadt@@ likes it too
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.793 2014/08/31 20:10:36 rpe Exp $
d165 1
a165 1
		egrep -v '^[[:space:]]|(bridge|enc|gif|gre|lo|pflog|pfsync|ppp|sl|tun)[[:digit:]]+:' |
@


1.793
log
@The xetc set is now part of xbase and not distributed separately anymore.
Extract it from xbase during installation.

OK ajacoutot@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.792 2014/08/26 20:19:26 rpe Exp $
d1839 1
a1839 1
	local _d
d1871 2
a1872 1
		ask_yn "Change the default console to $_d?"
@


1.792
log
@Create etc set during 'make build' and embed it in base set to make
it available during a regular install or upgrade so that it doesn't
need to be independently fetched.

Idea, directions and OK deraadt@@
Feedback and Ok halex@@ and aja@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.791 2014/08/10 20:54:17 rpe Exp $
d1164 1
a1164 1
			isin ${_f%${VERSION}.tgz} xbase xetc xshare xfont xserv &&
d1291 1
a1291 1
			if [[ $_f == base*.tgz && $MODE == install ]]; then
d1293 1
a1293 1
				file:///mnt/usr/share/sysmerge/etc.tgz |
d2044 1
a2044 2
for _set in base comp man game xbase xetc xshare xfont xserv site; do
	[[ $MODE == upgrade && $_set == xetc ]] && continue
@


1.791
log
@[] -> [[]]

OK krw@@
"well ok" halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.790 2014/08/10 16:32:28 rpe Exp $
d1290 6
a1295 1
		*.tgz)	ftp -D Installing -Vmo - "$_fsrc" | tar -zxphf - -C /mnt;;
d2044 2
a2045 2
for _set in base etc comp man game xbase xetc xshare xfont xserv site; do
	[[ $MODE == upgrade && $_set == @@(etc|xetc) ]] && continue
d2050 1
a2050 3
# Since etc${VERSION}.tgz is not in DEFAULTSETS for upgrades, it can always be
# in SANESETS.
SANESETS="${SANESETS:-bsd} base${VERSION}.tgz etc${VERSION}.tgz"
@


1.790
log
@Convert if foo; then bar; fi blocks to foo && bar but leave out enable_network()
because it shares code&style with /etc/netstart. No functional change.

with feedback and OK krw@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.789 2014/08/09 21:51:29 halex Exp $
d561 1
a561 1
		[ "$_l" ] || continue
d1657 1
a1657 1
	if [ ! -s /etc/fstab ]; then
d1671 1
a1671 1
		[ "$_mp" = "/mnt" ] || mkdir -p $_mp
d1713 1
a1713 1
		[ -f "/sbin/fsck_$_fstype" ] || continue
d1726 1
a1726 1
	[ "$_fail" ] && exit
d1752 1
a1752 1
	if [ -f /tmp/resolv.conf.shadow ]; then
d1942 1
a1942 1
	[ -x /mnt/$MODE.site ] && /mnt/usr/sbin/chroot /mnt /$MODE.site
@


1.789
log
@After a cleanup by deraadt I noticed the four-space-indent had started
infesting the scripts. As we generally use a single tab for line
continuation indent in the scripts, let's reclaim 30 precious bytes!

ok rpe@@ krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.788 2014/07/28 14:12:14 kettenis Exp $
d948 1
a948 3
		if rtsol -F $_ifs; then
			echo "up\nrtsol" >>$_hn
		fi
d1162 4
a1165 4
		if [[ -z $DISPLAY && ! -d /mnt/etc/X11 ]]; then
			# No displays and X isn't installed ==> skip X sets
			isin ${_f%${VERSION}.tgz} xbase xetc xshare xfont xserv && continue
		fi
d1798 1
a1798 3
	if [[ $sshd == n ]]; then
		echo "sshd_flags=NO" >>/mnt/etc/rc.conf.local
	fi
d1810 1
a1810 1
	if [[ -n $aperture ]]; then
a1812 1
	fi
d1814 1
a1814 1
	if [[ -n $lidsuspend ]]; then
a1816 1
	fi
d1818 1
a1818 1
	if [[ $xdm == y && -x /mnt/usr/X11R6/bin/xdm ]]; then
a1819 1
	fi
@


1.788
log
@Avoid matching a particular driver for "aperture needed" detection.
On sparc64 we also need to match machfb(4) in addition to vgafb(4) so let's
just match any driver.

ok halex@@, deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.787 2014/07/28 05:42:26 rpe Exp $
d1816 1
a1816 1
		    >>/mnt/etc/sysctl.conf
d1821 1
a1821 1
		    >>/mnt/etc/sysctl.conf
d1859 1
a1859 1
			    aperture=$MDXAPERTURE
d1867 1
a1867 1
			    lidsuspend=$resp
d1897 1
a1897 1
	    ifconfig -A; hostname) >/dev/random 2>&1
d1900 1
a1900 1
		    status=none
d1906 1
a1906 1
	    status=none
d2094 2
a2095 2
				    "should be used for the initial DHCP request" \
				    "$*"
@


1.787
log
@Change detection of unconfigured vlan interfaces from using flags to
looking for vlan id and parent interface. This avoids the creation of
unconfigured vlan interface every time /install is restarted.

Noted by and OK miod@@
OK krw@@
Positive feedback sthen@@ claudio@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.786 2014/07/22 17:01:33 deraadt Exp $
d1857 1
a1857 1
		if [[ -n $(scan_dmesg '/^vga.*: aperture needed/p') ]]; then
@


1.786
log
@use a better style of sh code around aperture
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.785 2014/07/22 06:45:31 ajacoutot Exp $
d645 1
a645 1
		[[ $_vd == @@(vlan$_vl: flags=0<>*) ]] && break
@


1.785
log
@Drop the "... during install" comments; they were missing in several
places and it makes things simpler: no need to check for file existence.

discussed with and ok deraadt@@ rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.784 2014/07/20 20:08:44 deraadt Exp $
d1857 1
a1857 1
		[[ -n $(scan_dmesg '/^vga.*: aperture needed/p') ]] &&
d1859 2
a1860 2
			aperture=$MDXAPERTURE

@


1.784
log
@if we think this is a laptop (wsdisplay.....) ask a lidsuspend
question.  Let's see who whines.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.783 2014/07/20 18:13:22 deraadt Exp $
d1801 1
a1801 2
		echo "sshd_flags=NO		# disabled during install" \
			>>/mnt/etc/rc.conf.local
d1809 1
a1809 2
		echo "ntpd_flags=		# enabled during install" \
			>>/mnt/etc/rc.conf.local
d1811 1
a1811 2
		echo "# created during install\nservers ${ntpd_server%% *}" \
			>/mnt/etc/ntpd.conf
a1814 2
		[[ ! -f /mnt/etc/sysctl.conf ]] && \
			echo "# created during install" >/mnt/etc/sysctl.conf
a1819 2
		[[ ! -f /mnt/etc/sysctl.conf ]] && \
			echo "# created during install" >/mnt/etc/sysctl.conf
d1825 1
a1825 2
		echo "xdm_flags=		# enabled during install" \
			>>/mnt/etc/rc.conf.local
@


1.783
log
@match on vga1 or vgafb0, well, let's just call it vga.* for now
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.782 2014/07/16 08:27:14 ajacoutot Exp $
d1824 7
d1863 1
d1872 4
@


1.782
log
@Add a comment at the top of sysctl.conf when it is created by the
installer.

ok deraadt@@ rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.781 2014/07/15 08:49:50 deraadt Exp $
d1857 1
a1857 1
		[[ -n $(scan_dmesg '/^vga1: aperture needed/p') ]] &&
@


1.781
log
@Create /etc/sysctl.conf based upon the 3 variables we might want to set
at install time.
ok aja
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.780 2014/07/13 21:24:43 rpe Exp $
d1818 2
@


1.780
log
@Only set machdep.allowaperture if 'vga1: aperture needed' is found
in dmesg output. Use that information to decide whether or not to
ask the user if he intends to use X.

initial diff from and OK halex@@
OK deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.779 2014/07/13 13:53:36 rpe Exp $
d1818 2
a1819 3
		sed "s/^#\(machdep\.allowaperture=$aperture\)/\1	/" \
			/mnt/etc/sysctl.conf >/tmp/sysctl.conf
		cp /tmp/sysctl.conf /mnt/etc/sysctl.conf
@


1.779
log
@- move the ntpd.conf file to examples directory
- move it from BIN1 to EXAMPLES in src/etc/Makefile
- change the installer to create the file instead of editing it
- add a '+' to the corresponding changelist entry

suggested by and OK deraadt@@
OK for the installer change krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.778 2014/07/12 15:27:15 rpe Exp $
d1817 2
a1818 2
	if [[ $x11 == y ]]; then
		sed "/^#\(machdep\.allowaperture=${MDXAPERTURE}\)/s//\1	/" \
d1841 1
a1841 1
	local _d _xdmask=y _def
d1853 11
a1863 12
	def=no
	[[ -n $DISPLAY ]] && def=yes
	if [[ -n $MDXAPERTURE ]]; then
		ask_yn "Do you expect to run the X Window System?" $def
		x11=$resp
		# if aperture was n, do not ask for xdm
		_xdmask=$resp
	fi

	if [[ -n $MDXDM && $_xdmask == y ]]; then
		ask_yn "Do you want the X Window System to be started by xdm(1)?"
		xdm=$resp
@


1.778
log
@xbase has its own cpp now so it doesn't depend on comp anymore.
Remove the code introduced in r1.723 to tie them together.

OK deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.777 2014/07/11 13:21:08 deraadt Exp $
d1812 3
a1814 10
		if [[ $ntpd_server != default ]]; then
			# Comment out the default 'servers' line, and add a
			# 'servers' line with the first token in $resp as the
			# server.
			set -- $ntpd_server
			sed "s/^servers /#&/;/#server /a\\
servers $1
" /mnt/etc/ntpd.conf >/tmp/ntpd.conf
			cp /tmp/ntpd.conf /mnt/etc/ntpd.conf
		fi
@


1.777
log
@take the directories specified by BSD.local.dist, and add them into
4.4BSD.dist.  The base set grows by a tiny amount, but we no longer
need to run chroot'd dynamic mtree from the installer.
ok espie halex schwarze
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.776 2014/06/16 19:31:41 rpe Exp $
a599 1
	local _comp=comp${VERSION}.tgz _xbase=xbase${VERSION}.tgz
a629 5
		if isin $_xbase $_selected && ! isin $_comp $_selected &&
			isin $_comp $_avail; then
			_selected=$(addel $_comp $_selected)
			echo "The xbase set requires the comp set, so adding it back in."
		fi
@


1.776
log
@Allow autoinstall to fetch/install sets from multiple locations.

Noted by and OK sebastia@@
OK halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.775 2014/06/09 18:05:55 rpe Exp $
a1956 5

	if [ -f /mnt/etc/mtree/BSD.local.dist ]; then
		/mnt/usr/sbin/chroot /mnt /usr/sbin/mtree -Uedqn -p /usr/local \
			-f /etc/mtree/BSD.local.dist >/dev/null
	fi
@


1.775
log
@remove sysmerge leftovers

OK halex@@ krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.774 2014/05/11 08:23:46 rpe Exp $
d1566 1
d1568 3
a1570 3
		[[ -z $_q ]] &&
			ask_yn "Are you *SURE* your $MODE is complete without '$_s'?" ||
			return
a1597 2
		[[ -n $METHOD ]] && _d=$METHOD
		sane_install quiet && _d=done
d1609 2
a1610 2
		# Install sets only once, in non-interactive installations.
		$auto && break
@


1.774
log
@Fix configuration of static IPv6 default gateway
- Append IPv4 default gw to /tmp/mygate instead of overwriting it.
- Delete /tmp/mygate at the beginning of configure_ifs() to reset
  previous default gw config on installer restarts.

pointed out by todd@@
OK halex@@ krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.773 2014/05/10 17:25:21 rpe Exp $
a2013 2
SM_ARGS=
SM_ARGSX=
@


1.773
log
@Fix v6_defroute() for automatic installation.

OK krw@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.772 2014/05/08 16:46:47 krw Exp $
d659 3
d989 1
a989 1
		route -n add -inet -host default "$resp" && { echo "$resp" >/tmp/mygate; break; }
@


1.772
log
@"Server?" -> "HTTP Server?" to allow unambiguous auto-install
handling.

Confusion with "NTP Server?" reported by Xavier Claude via misc@@.

ok rpe@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.771 2014/05/05 00:09:16 bluhm Exp $
d993 1
a993 1
	local _if=$1 _resp _routers
d1001 11
a1011 5
	local PS3="IPv6 default router? (${_routers:+list #, }IPv6 address or 'none'): "
	select _resp in $_routers; do
		[[ ${_resp:=$REPLY} == *:* ]] && break
		[[ $_resp == none ]] && return
	done
@


1.771
log
@Redirecting stderr to /dev/null suppresses all errors.  Instead use
the new status=none feature to make dd quiet.
OK krw@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.770 2014/05/04 13:08:39 krw Exp $
d1368 1
a1368 1
		_prompt="Server? (hostname, list#, 'done' or '?')"
d1371 1
a1371 1
		_prompt="Server? (hostname or 'done')"
@


1.770
log
@Revert previous. Insufficient discussion. Introduces
inconsistancy between configured and unconfigured interfaces.

Requested by deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.769 2014/05/04 10:47:25 krw Exp $
d1897 1
a1897 2
	{
	    (dmesg; cat $CGI_INFO /*.conf; sysctl; route -n show; df;
d1899 4
a1902 2
	    dd if=/mnt/var/db/host.random of=/dev/random bs=65536 count=1
	} >/dev/null 2>&1
d1906 4
a1909 5
	{
	    dd if=/dev/random of=/mnt/var/db/host.random bs=65536 count=1
	    dd if=/dev/random of=/mnt/etc/random.seed bs=512 count=1
	    chmod 600 /mnt/var/db/host.random /mnt/etc/random.seed
	} >/dev/null 2>&1
@


1.769
log
@Make answering 'none' to the installer question "IPv6 address?" result
in no IPv6 address, by appending '-inet6' to the generated hostname.<if>
file.

Less surprising to many people.

ok henning@@ reyk@@ beck@@ rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.768 2014/04/25 19:34:24 halex Exp $
d947 1
a947 2
	none)	echo "-inet6" >>$_hn
		return
@


1.768
log
@filter excess data from autoinstall output *before* it ends up in the
log file on the ramdisk, in order not to run out of its precious space

reported by, tested and ok sebastia@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.767 2014/04/21 23:15:09 rpe Exp $
d947 2
a948 1
	none)	return
@


1.767
log
@Avoid a loop during autoinstall in case the path in the responsefile does
not exist.

OK halex@@ krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.766 2014/04/21 19:05:40 rpe Exp $
d2152 1
a2152 1
	/$action -af /$action.conf 2>&1 </dev/null | sed 'w/ai.log'
d2157 1
a2157 1
		sed 's/^.*//' /ai.log >>$_lf
@


1.766
log
@Change dhcp_request() and v4_config() to be able to configure dhcp
for an interface without an active network connection.

- Don't write options to dhclient.conf that are default. Only use
  the 'host-name' option for hostname associated dhcp requests.

- Run dhclient with options to reduce the time it takes to finish
  in case it gets no answer from a DHCP server.

- Don't bother removing the interface from group dhcp and save the
  configuration files even if dhclient fails. If the same interface
  is statically configured later, it is removed from the group dhcp.

- Add 'dhcp' to hostname.if file regardless whether dhcp_request()
  was successful or not.

- Change the Netmask question to be more autoinstaller friendly.

based on krw's work
discussed with and OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.765 2014/04/21 15:56:19 rpe Exp $
d1451 1
@


1.765
log
@Use a better way that ensures that NIFS is really 0 if there are no
hostname.if files.

suggested by and OK halex@@
OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.764 2014/04/21 12:41:36 rpe Exp $
d783 2
a784 5
# Construct etc/dhclient.conf and issue DHCP request. Return FALSE if
# no IP address assigned to $1.
#
# $1 == interface
# $2 == hostname
d789 1
d791 3
a793 1
	cat >/etc/dhclient.conf <<__EOT
d795 3
a798 2
request subnet-mask, broadcast-address, routers, domain-name,
	domain-name-servers, host-name;
d801 5
a805 17
	ifconfig $_ifs group dhcp >/dev/null 2>&1
	dhclient $_ifs

	set -- $(v4_info $_ifs)

	if [[ $1 == UP && -n $2 ]]; then
		# Move configuration files to where they will be copied to the
		# installed system. Overwrites configuration information from
		# last successful dhcp attempt.
		mv /etc/dhclient.conf /tmp/dhclient.conf
		mv /etc/resolv.conf.tail /tmp/resolv.conf.tail
		return 0
	fi

	ifconfig $_ifs delete down -group dhcp 2>/dev/null
	rm /etc/dhclient.conf /etc/resolv.conf.tail
	return 1
d918 2
a919 1
		elif dhcp_request $_ifs "$_name"; then
d924 1
a924 1
		ask_until "Netmask?" "${_mask:=255.255.255.0}"
@


1.764
log
@NIFS is supposed to represent the number of configured interfaces.
If an interface got configured twice, NIFS must not be incremented.
So count the number of hostname.if files instead.

discussed with and OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.763 2014/04/20 15:53:57 rpe Exp $
d745 1
a745 1
		NIFS=0; for _hn in /tmp/hostname.*; do ((NIFS++)); done
@


1.763
log
@Only issue a single dhcp requests per interface with the host-name
option set. Remove the second request, which does not provide the
host-name option. The client supplied hostname is used in certain
setups by DHCP servers to update DNS records on behalf of clients
and ensures that the hostname information is in the lease db.

discussed with deraadt
ok krw@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.762 2014/04/20 10:51:59 rpe Exp $
a741 1
			((NIFS++))
d744 2
@


1.762
log
@Simplify shell pattern.

OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.761 2014/04/19 18:31:24 rpe Exp $
d786 1
a786 1
# $2 == hostname (optional).
a791 7
	if [[ -n $_hn ]]; then
		_hn="send host-name \"$_hn\";"
		echo "Issuing hostname-associated DHCP request for $_ifs."
	else
		echo "Issuing free-roaming DHCP request for $_ifs."
	fi

d794 1
a794 1
$_hn
d928 1
a928 1
		elif dhcp_request $_ifs "$_name" || dhcp_request $_ifs; then
@


1.761
log
@populateusrlocal() is used only once in finish_up(). Just fold it in there.

OK krw@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.760 2014/04/19 16:50:52 rpe Exp $
d2070 1
a2070 1
	[[ $MODE == upgrade && ( $_set == etc || $_set == xetc ) ]] && continue
@


1.760
log
@Simplify things by using the return code of ask_yn() directly instead
of looking in resp. No need to specify 'no' as default answer. It's
the default for ask_yn() anyway.

OK krw@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.759 2014/04/16 13:12:22 krw Exp $
a1810 6
populateusrlocal() {
	if [ -f /mnt/etc/mtree/BSD.local.dist ]; then
		/mnt/usr/sbin/chroot /mnt /usr/sbin/mtree -Uedqn -p /usr/local -f /etc/mtree/BSD.local.dist >/dev/null
	fi
}

d1965 4
a1968 1
	populateusrlocal
@


1.759
log
@Tweak network interface configuration so that after 1st attempted
(rather than first successfull) configuration, the default selection
becomes [done]. This allows one to <cr> past network configuration.
e.g. when dhcp is not working.

Requested by deraadt@@. ok halex@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.758 2014/04/04 19:44:02 krw Exp $
d1480 1
a1480 2
	ask_yn "Is the disk partition already mounted?"
	if [[ $resp == n ]]; then
d1501 1
a1501 2
	ask_yn "Use TCP transport? (requires TCP-capable NFS server)"
	[[ $resp == y ]] && _tcp=-T
d1697 1
a1697 4
		ask_yn "Continue anyway?" no
		if [[ $resp == n ]]; then
			exit
		fi
d1723 1
a1723 2
	ask_yn "Force checking of clean non-root filesystems?"
	[[ $resp == y ]] && _f=f
@


1.758
log
@Change HTTP_PROXY back to http_proxy. This is an environment variable
for ftp(1) and not an install script global variable.

Pointed out by rpe@@, and probably explains M. Lucas's problems of a
few days ago.

ok sthen@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.757 2014/03/22 02:42:00 krw Exp $
a743 1
			_p=done
d745 1
@


1.757
log
@Upper case another global variable (nifs -> NIFS).
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.756 2014/03/22 02:24:43 krw Exp $
d1376 2
d1379 3
a1381 3
		"${HTTP_PROXY:-none}"
	unset HTTP_PROXY
	[[ $resp == none ]] || export HTTP_PROXY=$resp
@


1.756
log
@Oops. MDMTDEVS is used to populate /dev. Put those bits back.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.755 2014/03/22 01:13:02 krw Exp $
d742 1
a742 1
			((nifs++))
d990 1
a990 1
	[[ -f /tmp/dhclient.conf && $nifs == 1 ]] && return
d1045 1
a1045 1
		((nifs++))
d1325 1
a1325 1
	((nifs < 1)) && return
d1790 1
a1790 1
	if [[ ! -f /tmp/dhclient.conf || $nifs != 1 ]]; then
d1800 1
a1800 1
	if [[ ! -f /tmp/dhclient.conf || $nifs != 1 || $resp == none ]]; then
d2059 1
a2059 1
nifs=0
d2206 1
a2206 1
	((nifs != 0)) && startcgiinfo
@


1.755
log
@Remove 'tape' as a method for installing sets. Elite masters of unix
arcana able to do without instructions for tape installs, can do
without the crutch of script support. If any non-EMOUA tape users
surface, this is easy to restore.

ok halex@@ on the actual diff.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.754 2014/03/20 20:01:28 krw Exp $
d87 1
@


1.754
log
@FTP is so 20th century. Remove 'ftp' as a method to obtain installation
sets. 'http' is the present.

A bunch of related or triggered cleanup/consistenizing.

Prodded by deraadt@@, much feedback and testing by rpe@@.

ok rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.753 2014/03/10 00:14:34 rpe Exp $
a86 1
#	MDMTDEVS    - '/^[cms]t[0-9][0-9]* /s/ .*//p'
a1507 46
install_tape() {
	local _z _bs

	# Get the name of the tape device.
	get_drive "tape drive" '$MTDEVS' || return
	export TAPE=/dev/nr$resp
	if [[ ! -c $TAPE ]]; then
		echo "$TAPE is not a character special file."
		return
	fi

	# Rewind the tape device.
	echo -n "Rewinding $TAPE (mt rewind)..."
	mt rewind || return
	echo "done."

	# Extract the desired files.
	while :; do
		ask_until "Skip how many files? (or 'done')" 0
		[[ $resp == done ]] && return
		[[ $resp == +([0-9]) ]] || continue

		if (($resp > 0)); then
			echo -n "Skipping $resp file(s)..."
			mt fsf $resp || return
			echo "done."
		elif [[ -n $_bs ]]; then
			# Dance to start of next file.
			mt bsf; mt fsf
		fi

		unset _z
		ask_yn "Is the file gzipped?" yes
		[[ $resp == y ]] && _z=z

		# Get the blocksize to use. If the file isn't gzipped then
		# default to the 20 x 512 = 10,240 byte tar default.
		[[ $_z == z ]] || _bs=10240
		ask_until "Blocksize for this file?" "${_bs:-8k}"
		[[ $resp == done ]] && return
		_bs=$resp

		dd if=$TAPE bs=$_bs | tar ${_z}xvphf - -C /mnt || return
	done
}

a1590 1
	[[ -n $MTDEVS && -x /bin/mt ]] && _locs="$_locs tape"
d1594 1
a1594 1
		for a in http cd nfs tape disk; do
a1611 1
		t*|T*)	isin tape $_locs && install_tape && METHOD=tape;;
@


1.753
log
@replace set size calculation with a fixed value
- reduce complexity
- don't abuse index.txt

OK halex@@ krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.752 2014/03/02 14:12:16 deraadt Exp $
d1186 1
a1186 3
		# Show $_src, but delete any ftp password.
		echo -n "Looked at "
		echo $_src | sed 's/\(^ftp:\/\/[^/]*\)\(:[^/]*\)\(@@.*\)/\1\3/'
d1323 2
a1324 63
# Encode $1 as specified for usercodes and passwords in RFC 1738
# section 3.1 and section 5.
#
# Escape everything between 0x20 and 0x7e to avoid both illegal url
# characters and characters causing problems during script processing.
#
# *NOTE*
#	1) quotes around $1 are required to preserve trailing or
#	   embedded blanks in usercodes and passwords.
#	2) substitute '%' FIRST so it doesn't eliminate '%' chars we insert.
encode_for_url() {
	echo "$1" | sed "
s/%/%25/g
s/ /%20/g
s/!/%21/g
s/\"/%22/g
s/#/%23/g
s/\\\$/%24/g
s/&/%26/g
s/'/%27/g
s/(/%28/g
s/)/%29/g
s/\*/%2a/g
s/+/%2b/g
s/,/%2c/g
s/-/%2d/g
s/\./%2e/g
s/\//%2f/g
s/:/%3a/g
s/;/%3b/g
s/</%3c/g
s/=/%3d/g
s/>/%3e/g
s/?/%3f/g
s/@@/%40/g
s/\[/%5b/g
s/\\\\/%5c/g
s/]/%5d/g
s/\^/%5e/g
s/_/%5f/g
s/\`/%60/g
s/{/%7b/g
s/|/%7c/g
s/}/%7d/g
s/~/%7e/g
"
}

# Check for the presence of an error message in the output of the ftp commands
# used to get the list of files in a directory.
#
# $1 = error message to look for
# $2 = ftp command output
ftp_error() {
	if [[ -n $(echo "$2" | grep "$1") ]]; then
		echo $1
		return 0
	fi
	return 1
}

startftplist() {
	# If no networks are configured, we do not need the ftplist file
d1332 2
a1333 2
		ftp -Vao - "http://129.128.5.191/cgi-bin/ftplist.cgi?path=$FTPSETDIR" \
			2>/tmp/ftplisterr >$SERVERLISTALL
d1336 1
a1336 1
		echo -n $SECONDS >$SERVERLISTSEC
d1338 1
a1338 1
	) & ftppid=$!
d1344 1
a1344 1
	(sleep 12; kill -INT -$ftppid >/dev/null 2>&1) &
d1347 13
a1359 3
# Wait for the ftp process to finish, or be killed after the timeout
waitftplist() {
	wait "$ftppid" 2>/dev/null
d1364 10
a1373 21
ftp_time() {
	local _ftplist_sec=$(cat $SERVERLISTSEC 2>/dev/null)
	local _time=$(sed '/^TIME=\([0-9]*\)$/!d;s//\1/;q' $SERVERLISTALL 2>/dev/null)
	[[ -n $_ftplist_sec && -n $_time ]] &&
		echo $((_time + SECONDS - _ftplist_sec))
}

# Get several parameters from the user, and xfer
# files from the server.
# $1 = url type (ftp or http)
# Note:	_ftp_server_ip, _ftp_server_dir, _ftp_server_login must be global.
install_url() {
	local _url_type=$1 _file_list _url_base _prompt _passwd _mirror
	eval local _server_ip=\$_${_url_type}_server_ip \
		_server_dir=\$_${_url_type}_server_dir

	waitftplist
	ask "HTTP/FTP proxy URL? (e.g. 'http://proxy:8080', or 'none')" \
		"${ftp_proxy:-none}"
	unset ftp_proxy http_proxy
	[[ $resp == none ]] || export ftp_proxy=$resp http_proxy=$resp
d1375 7
a1381 1
	if [[ -s $SERVERLISTALL ]]; then
a1382 4
		sed -n "s,^${_url_type}://"'\([[A-Za-z0-9\:_][]A-Za-z0-9:._-]*\),\1,p' \
			$SERVERLISTALL >$SERVERLIST
		set -- $(sed q $SERVERLIST)
		_server_ip=${1%%/*}
d1384 1
a1384 1
		echo "(Was not able to get ftplist from ftp.openbsd.org, but that is OK)"
d1390 1
a1390 1
		ask_until "$_prompt" "$_server_ip"
d1393 2
a1394 2
		"?")	[[ -s $SERVERLIST ]] || continue
			less -XEN < $SERVERLIST
d1398 3
a1400 3
			# as a line number in $SERVERLIST.
			[[ -s $SERVERLIST ]] || continue
			set -- $(sed -n "${resp}p" $SERVERLIST)
d1402 1
a1402 1
			_server_ip=${1%%/*}
d1406 1
a1406 1
			_server_ip=$resp
a1412 1
	eval _${_url_type}_server_ip=$_server_ip
d1418 1
a1418 1
	set -- $(sed "/^$_server_ip/x;\$!d;x" $SERVERLIST 2>/dev/null)
d1424 1
a1424 1
		resp=$resp/$FTPSETDIR
d1428 4
a1431 27
	ask_until "Server directory?" "${resp:-pub/OpenBSD/$FTPSETDIR}"
	_server_dir=$resp
	eval _${_url_type}_server_dir=$_server_dir

	if [[ $_url_type == ftp ]]; then
		# Get login name, preserving leading and trailing blanks
		IFS= ask_until "Login?" "${_ftp_server_login:=anonymous}"
		_ftp_server_login=$resp

		# Get password unless login in 'anonymous' or 'ftp'
		if [[ $_ftp_server_login == @@(anonymous|ftp) ]]; then
			_passwd=root@@`hostname`
		else
			resp=
			while [[ -z $resp ]]; do
				askpass "Password? (will not echo)"
			done
			_passwd=$resp
		fi
	fi

	# Build up the base url since it is so nasty...
	_url_base=$_url_type://
	if [[ $_url_type == ftp && $_ftp_server_login != anonymous ]]; then
		_url_base=$_url_base$(encode_for_url "$_ftp_server_login"):$(encode_for_url "$_passwd")@@
	fi
	_url_base=$_url_base$_server_ip/$_server_dir
d1434 4
a1437 10
	if [[ $_url_type == ftp && -z $ftp_proxy ]]; then
		_file_list=$(ftp -V "$_url_base/")
		ftp_error "Login failed." "$_file_list" && return
		ftp_error "No such file or directory." "$_file_list" && return
	else
		# Assumes index file is "index.txt" for http (or proxy)
		# We can't use index.html since the format is server-dependent
		_file_list=$(ftp -Vo - "$_url_base/index.txt" |
			sed 's/^.* //' | sed 's///')
	fi
d1441 2
a1442 2
	# Remember where we installed from
	installedfrom=$_url_type://$_server_ip/$_server_dir
d1444 2
a1445 1
	# Bake a package path if we installed from a mirror
d1447 1
a1447 1
		PACKAGE_PATH=$(print -r -- "$installedfrom" |
a1449 2
	else
		PACKAGE_PATH=
d1571 3
a1573 3
	waitftplist
	if [[ -s $SERVERLISTALL ]]; then
		_tz=$(sed -n '/^TZ=/s/TZ=//p' <$SERVERLISTALL)
d1577 1
a1577 1
	# If neither the base or SERVERLIST gave a hint, and this is the
d1629 1
a1629 1
	local _d _locs="disk ftp http"
d1633 1
a1633 2
	[[ -s $SERVERLISTALL ]] &&
		_d=$(sed -n '/^method=/s/method=//p' $SERVERLISTALL)
d1642 1
a1642 1
		for a in http ftp cd nfs tape disk; do
d1650 1
a1650 1
		[[ -n $method ]] && _d=$method
d1656 6
a1661 6
		c*|C*)	isin cd $_locs && install_cdrom && method=cd;;
		d*|D*)	install_disk && method=disk;;
		f*|F*)	isin ftp $_locs && install_url ftp && method=ftp;;
		h*|H*)	isin http $_locs && install_url http && method=http;;
		n*|N*)	isin nfs $_locs && install_nfs && method=nfs;;
		t*|T*)	isin tape $_locs && install_tape && method=tape;;
d1971 1
a1971 1
	    (dmesg; cat $SERVERLISTALL /*.conf; sysctl; route -n show; df;
d2079 9
a2087 4
FTPDIR="pub/OpenBSD/$VNAME"
SERVERLISTALL=/tmp/serverlistall
SERVERLISTSEC=/tmp/serverlistsec
SERVERLIST=/tmp/serverlist
d2101 1
a2101 1
FTPSETDIR=$SETDIR
d2103 1
a2103 1
[[ $1 == -!(stable) ]] && FTPSETDIR=snapshots/$ARCH
d2254 1
a2254 1
	((nifs != 0)) && startftplist
@


1.752
log
@the map-to-lowercase scheme for msdos is not going to work, because other
filesystems can contain mixed case files (ie. sgi).
discussed with krw and halex
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.749 2014/02/22 05:13:22 deraadt Exp $
d1166 1
a1166 1
		_tmpfs _tmpsrc _cfile _fsrc _unver _t _issue _srclocal _size
a1211 10
	# Sum up the size of the selected sets
	_size=$( ( [[ $_src == file://* ]] && ls -lT "${_src#file://}" ||
		ftp -V -o - "$_src/index.txt" 2>/dev/null ) | (
		sum=0
		while read x x x x s x x x f2 f && : ${f:=$f2}; do
			isin $f $_get_sets && let sum+=s
		done; echo $sum ) )

	# Byte -> KByte and fallback to 512M if _size calculation failed
	_size=$((${_size:-536870912} / 1024))
d1223 2
a1224 4
		# have free space the size of the selected sets +10M. Other-
		# wise use any other filesystem that has four time the free
		# space of the selected sets to prevent overflow during the
		# extraction.
d1233 1
a1233 1
					((a > _size + 10240)) && echo $m && exit
d1235 1
a1235 1
					((a > _size * 4)) && echo $m && exit
@


1.751
log
@move to official keys
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.750 2014/02/28 23:51:54 krw Exp $
d201 2
a202 1
	grep -q "^  $resp: .*MSDOS" $_file && _opts="-l"
d1165 1
a1165 1
	local _src=$1 _f _sets _get_sets _n _col=$COLUMNS \
a1166 1
	typeset -l _files=$2
d1200 1
a1200 1
	isin install.$ARCH $_files ||
d1228 1
a1228 1
		! isin sha256.sig $_files &&
a1264 1
		! ftp -D "$_t" -Vmo "$_cfile.sig" "$_src/sha256.sig" &&
@


1.750
log
@Mount MSDOS partitions with '-l' and not '-s'. Force lists of file names
to all lower case. Check for install.$ARCH and sha256*. Fixes
getting sets from an MSDOS partition, which uebayasi@@ reported was
broken, without impacting other sources for sets.

ok rpe@@ halex@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.749 2014/02/22 05:13:22 deraadt Exp $
d1269 1
a1269 1
		! signify -Vep /etc/signify/${VERSION}base.pub \
@


1.749
log
@Do an additional feed_random in the co-routine that is fetching the sets
like.  This is going to finish at a really unpredictable time, and
that is a swell time to do an aggressive push & stir.
ok halex
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.748 2014/02/21 19:47:31 deraadt Exp $
d201 1
a201 2
	# Always mount msdos partitions with -s to get lower case names.
	grep -q "^  $resp: .*MSDOS" $_file && _opts="-s"
d1164 1
a1164 1
	local _src=$1 _files=$2 _f _sets _get_sets _n _col=$COLUMNS \
d1166 1
d1200 1
a1200 1
	isin INSTALL.$ARCH $_files ||
d1228 1
a1228 1
		! isin SHA256.sig $_files &&
d1265 1
@


1.748
log
@some spaces snuck in, and they cost us on the install media.  Not joking.
ok krw halex
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.747 2014/02/21 16:30:14 deraadt Exp $
d1412 1
@


1.747
log
@oops, seperate pieces coming...
@
text
@d1 1
a1 2
#	$OpenBSD: install.sub,v 1.745 2014/02/20 00:26:14 rpe Exp $
#	$NetBSD: install.sub,v 1.5.2.8 1996/09/02 23:25:02 pk Exp $
d842 1
a842 1
		sed -n 's/^		nwid \([^"]\)/\1/p' > $WLANLIST
d1051 1
a1051 1
		(ifconfig $if||ifconfig $if create)> /dev/null 2>&1 || continue
d1238 1
a1238 1
		        for fs in /mnt/{{,var/}tmp,home,usr{/local,}}; do
d1255 1
a1255 1
			_issue="Cannot determine prefetch area" && break	
d1408 1
a1408 1
			2>/tmp/ftplisterr > $SERVERLISTALL
d1453 1
a1453 1
			$SERVERLISTALL > $SERVERLIST
d1775 1
a1775 1
	echo "/usr/sbin/fw_update -v" >> /mnt/etc/rc.firsttime
d1982 1
a1982 1
			< /mnt/etc/ssh/sshd_config > /tmp/sshd_config
d2109 2
a2110 2
		grep -v '^[ 	]*installpath[ 	]*=' /mnt/etc/pkg.conf 2>/dev/null > /tmp/pkgconf
		print -r -- "installpath = $PACKAGE_PATH" >> /tmp/pkgconf
d2327 1
a2327 1
		sed 's/^.*//' /ai.log >> $_lf
@


1.746
log
@services
@
text
@d2 1
d843 1
a843 1
		sed -n 's/^		nwid \([^"]\)/\1/p' >$WLANLIST
d1052 1
a1052 1
		(ifconfig $if||ifconfig $if create) >/dev/null 2>&1 || continue
d1239 1
a1239 1
			for fs in /mnt/{{,var/}tmp,home,usr{/local,}}; do
d1256 1
a1256 1
			_issue="Cannot determine prefetch area" && break
d1409 1
a1409 1
			2>/tmp/ftplisterr >$SERVERLISTALL
a1412 1
		feed_random
d1454 1
a1454 1
			$SERVERLISTALL >$SERVERLIST
d1776 1
a1776 1
	echo "/usr/sbin/fw_update -v" >>/mnt/etc/rc.firsttime
d1983 1
a1983 1
			< /mnt/etc/ssh/sshd_config >/tmp/sshd_config
d2110 2
a2111 2
		grep -v '^[ 	]*installpath[ 	]*=' /mnt/etc/pkg.conf 2>/dev/null >/tmp/pkgconf
		print -r -- "installpath = $PACKAGE_PATH" >>/tmp/pkgconf
d2328 1
a2328 1
		sed 's/^.*//' /ai.log >>$_lf
@


1.745
log
@Adjust alignment of ftp titles

OK halex@@ deraadt@@
@
text
@d1 1
a1 2
#	$OpenBSD: install.sub,v 1.744 2014/02/19 18:48:23 rpe Exp $
#	$NetBSD: install.sub,v 1.5.2.8 1996/09/02 23:25:02 pk Exp $
d842 1
a842 1
		sed -n 's/^		nwid \([^"]\)/\1/p' > $WLANLIST
d1051 1
a1051 1
		(ifconfig $if||ifconfig $if create)> /dev/null 2>&1 || continue
d1238 1
a1238 1
		        for fs in /mnt/{{,var/}tmp,home,usr{/local,}}; do
d1255 1
a1255 1
			_issue="Cannot determine prefetch area" && break	
d1408 1
a1408 1
			2>/tmp/ftplisterr > $SERVERLISTALL
d1412 1
d1454 1
a1454 1
			$SERVERLISTALL > $SERVERLIST
d1776 1
a1776 1
	echo "/usr/sbin/fw_update -v" >> /mnt/etc/rc.firsttime
d1983 1
a1983 1
			< /mnt/etc/ssh/sshd_config > /tmp/sshd_config
d2110 2
a2111 2
		grep -v '^[ 	]*installpath[ 	]*=' /mnt/etc/pkg.conf 2>/dev/null > /tmp/pkgconf
		print -r -- "installpath = $PACKAGE_PATH" >> /tmp/pkgconf
d2328 1
a2328 1
		sed 's/^.*//' /ai.log >> $_lf
@


1.744
log
@Improve the logic to find a filesystem to store the prefetched sets.

Prefer filesystems which are not used during extraction. They need
to have free space the size of the selected sets +10M. Otherwise
use any other filesystem that has four time the free space of the
selected sets to prevent overflow during the extraction.

joint work with and OK halex@@
deraadt@@ likes the direction
OK krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.743 2014/02/07 23:28:21 halex Exp $
d1262 1
a1262 1
		[[ $_src == file://* ]] && _srclocal=true _t=Verifying
d1265 1
a1265 1
		! ftp -D $_t -Vmo "$_cfile.sig" "$_src/SHA256.sig" &&
d1280 1
a1280 1
			( ftp -D $_t -Vmo - "$_src/$_f" || >"$_tmpsrc/fail" ) |
@


1.743
log
@make sure a free bpf exists before dhclient is run, and remove some
prior workarounds

until we have clonable bpfs

ok rpe@@ krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.742 2014/02/03 23:28:00 rpe Exp $
d1167 1
a1167 1
		_tmpfs _tmpsrc _cfile _fsrc _unver _t _issue _srclocal
d1213 10
d1232 6
a1237 5
		# Find the filesystem with the most available space,
		# excluding filesystems that are populated by the
		# sets, in order not to ruin the set extraction. If
		# /tmp, /var/tmp or /home, in that order, is found
		# to have more than 500M free space, that one is used.
d1239 4
a1242 1
			df -k /mnt/{{,var/}tmp,home} 2>/dev/null; df -k
a1243 1
			amax=0 mmax=
d1245 4
a1248 4
				[[ $m == /mnt/@@(@@(|var/)tmp|home|usr/@@(src,obj,xobj))@@(|/*) ]] ||
					continue
				((a > 512000)) && echo $m && exit
				((a > amax)) && amax=$a mmax=$m
a1249 1
			echo $mmax
@


1.742
log
@Use get_ifdevs() to get the name of a possibly existing netboot
interface instead of using handrolled ifconfig | sed combo.

OK halex@@ krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.741 2014/02/02 19:33:23 rpe Exp $
d774 9
a937 2
			# Create a new bpf in case we start another dhclient
			makedev bpf$(ls /dev | grep -c "^bpf[0-9]")
a1087 2
				# Create a new bpf in case we start another dhclient
				makedev bpf$(ls /dev | grep -c "^bpf[0-9]")
d2246 1
a2246 3
# from the lease file via the next-server attribute. Kill a dhclient
# from a previous attempt by taking down that interface first and so
# free up the only bpf which exists at this point.
a2268 1
	ifconfig $_ifdev down
@


1.741
log
@Allow to use ************* (13 '*') as password in the response file
for accounts which have password logins disabled but login with e.g.
ssh-keys is still possible.

suggested and OK sthen@@, OK halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.740 2014/02/02 17:37:24 rpe Exp $
d666 1
a666 1
			${_p:-'$( (ifconfig netboot 2>/dev/null | sed -n '\''1s/:.*//p'\''; get_ifdevs) | sed q )'}
@


1.740
log
@replace multiple grep with sed onliners in mount_mnt2()

with feedback and OK halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.739 2014/02/02 17:10:33 rpe Exp $
d366 2
a367 1
	elif [[ $_p == \$2?\$[0-9][0-9]\$* && ${#_p} > 40 ]]; then
@


1.739
log
@fix typo
from Markus Lude markus _dot_ lude _at_ gmx _dot_ de

OK halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.738 2014/02/01 23:16:16 rpe Exp $
d180 2
a181 2
	disklabel $_dev 2>/dev/null | grep '^  [a-p]: '	|
		egrep -v "swap|unused" >$_file
d195 1
a195 1
		cat /tmp/parts.$_dev
d197 2
a198 3
			'$(disklabel '$_dev' 2>/dev/null | grep "^  [a-p]: " |
			egrep -v "swap|unused" |
			sed '\''s/^  \(.\): .*/\1/'\'')'
@


1.738
log
@remove -e sed option where only one command is used

OK halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.737 2014/01/28 21:34:44 halex Exp $
d1293 1
a1293 1
		! ask_yn "$_issue. Continue without verifcation?"; then
@


1.737
log
@trim sane_sets()

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.736 2014/01/27 23:18:53 rpe Exp $
d148 1
a148 1
	bsort $(sed -ne "$1" /var/run/dmesg.boot)
d153 1
a153 1
	bsort $(for _n in $(sysctl -n hw.disknames); do echo "${_n%%:*} "; done | sed -ne "$1")
d167 1
a167 1
		sed -ne 's/^\(.*\):.*/\1/p'
d183 1
a183 1
	_parts=$(sed -e 's/^  \(.\): .*/\1/' $_file)
d981 1
a981 1
	[[ -n $(ifconfig | sed -ne '/[ 	]inet .* broadcast /p') ]] || return
d989 1
a989 1
	_dr=$(route -n show -inet | sed -ne '/^default */{s///; s/ .*//; p;}')
d1008 2
a1009 2
		sed -ne '/bytes from/{s/^.*from //;s/,.*$//;p;}' |
		sed -ne 'G;s/\n/&&/;/^\(.*\n\).*\n\1/d;h;P'))
d1184 1
a1184 1
		echo $_src | sed -e 's/\(^ftp:\/\/[^/]*\)\(:[^/]*\)\(@@.*\)/\1\3/'
d1332 1
a1332 1
	echo "$1" | sed -e "
d1523 1
a1523 1
			sed -e 's/^.* //' | sed -e 's///')
d1661 1
a1661 1
		_tz=$(sed -ne '/^TZ=/s/TZ=//p' <$SERVERLISTALL)
d1722 1
a1722 1
		_d=$(sed -ne '/^method=/s/method=//p' $SERVERLISTALL)
d1792 1
a1792 1
		_opt=$(echo $_opt | sed -e 's/softdep//')
d1796 1
a1796 1
		[[ $_fstype == ffs ]] && _opt=$(echo $_opt | sed -e 's/ro/rw/')
d1799 1
a1799 1
		[[ $_fstype == ffs ]] || _opt=$(echo $_opt | sed -e 's/rw/ro/')
d1828 1
a1828 1
		echo $_msg | sed -e 's/, ctime=[^,)]*//'
d1965 1
a1965 1
		sed -e "/^#\(PermitRootLogin\) yes/s//\1 no/" \
d1977 1
a1977 1
			sed -e "s/^servers /#&/;/#server /a\\
d1985 1
a1985 1
		sed -e "/^#\(machdep\.allowaperture=${MDXAPERTURE}\)/s//\1	/" \
d2181 1
a2181 1
dmesg | sed -ne '/^OpenBSD /h;/^OpenBSD /!H;${g;p;}' >/var/run/dmesg.boot
@


1.736
log
@remove spaces right before ; and ;;

OK halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.735 2014/01/26 21:54:32 rpe Exp $
d1700 1
d1702 1
a1702 1
	local _q=$1 _s _m
d1707 3
a1709 3
		resp=n
		[[ -z $_q ]] && ask_yn "Are you *SURE* your $MODE is complete without '$_s'?"
		[[ $resp == n ]] && _m="$_m $_s"
a1710 3

	[[ -n $_m ]] && return 1
	return 0
@


1.735
log
@- extend logic to find a sensible location to place prefetched sets
- complain loudly on errors and give users a chance to react on them
- improve detection if ftp fails while fetching sets
- be more cautious while removing temporary directories

joint work with and ok halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.734 2014/01/26 19:01:03 rpe Exp $
d106 3
a108 3
			"?"|L|l) echo "Available layouts: $_layouts" ;;
			default) return ;;
			*)	kbd $resp && { echo $resp >/tmp/kbdtype ; return ; } ;;
d185 1
a185 1
	(($# == 0)) && { echo "No filesystems found on $_dev." ; return 1 ; }
d380 1
a380 1
		n|no)	return ;;
d382 1
a382 1
			continue ;;
d386 1
a386 1
			((${#resp} <= 31)) && break ;;
d395 1
a395 1
			echo "':', '&' or ',' are not allowed." ;;
d398 1
a398 1
			echo "Too long." ;;
d539 2
a540 2
		if [[ $_a != $_b ]] ; then
			if [[ $_a > $_b ]] ; then
d620 4
a623 4
			abort)	_selected=; break 2 ;;
			done)	break 2 ;;
			-*)	_action=rmel ;;
			*)	_action=addel ;;
d863 1
a863 1
		*)	_nwid=$resp ;;
d927 1
a927 1
		elif dhcp_request $_ifs "$_name" || dhcp_request $_ifs ; then
d936 1
a936 1
		if ifconfig $_ifs inet $_addr netmask $resp up ; then
d959 1
a959 1
	rtsol)	[[ ! -x /sbin/rtsol ]] && { echo "No /sbin/rtsol." ; return ; }
d996 1
a996 1
		route -n add -inet -host default "$resp" && { echo "$resp" >/tmp/mygate ; break ; }
d1449 1
a1449 1
		done)	return ;;
d1458 1
a1458 1
			(($# < 1)) && { echo "There is no line $resp." ; continue ; }
d1500 1
a1500 1
			while [[ -z $resp ]] ; do
d1515 1
a1515 1
	if [[ $_url_type == ftp && -z $ftp_proxy ]] ; then
d1548 2
a1549 2
		[[ -d /mnt2/$resp ]] && { _dir=/mnt2/$resp ; break ; }
		[[ -d /mnt/$resp ]] && { _dir=/mnt/$resp ; break ; }
d1551 1
a1551 1
		[[ -d /$resp ]] && { _dir=/$resp ; break ; }
d1625 1
a1625 1
			mt bsf ; mt fsf
d1673 1
a1673 1
		"")	continue ;;
d1675 1
a1675 1
			continue ;;
d1684 2
a1685 2
			"?")	sed -n "/^$_zsed/{s/$_zsed//;/\/./!p;}" $_zonefile | showcols ;;
			*)	_zonepath=$_zonepath/$resp ;;
d1727 1
a1727 1
	[[ -n $(get_cddevs) ]] && { _locs="cd $_locs" ; : ${_d:=cd} ; }
d1746 7
a1752 7
		done)	sane_install && return ;;
		c*|C*)	isin cd $_locs && install_cdrom && method=cd ;;
		d*|D*)	install_disk && method=disk ;;
		f*|F*)	isin ftp $_locs && install_url ftp && method=ftp ;;
		h*|H*)	isin http $_locs && install_url http && method=http ;;
		n*|N*)	isin nfs $_locs && install_nfs && method=nfs ;;
		t*|T*)	isin tape $_locs && install_tape && method=tape ;;
d2044 2
a2045 2
			done)	defcons=n ;;
			*)	CSPEED=$resp ;;
d2104 1
a2104 1
		for _dev in $(get_dkdevs) $(get_cddevs) $MTDEVS ; do
d2210 1
a2210 1
for _set in base etc comp man game xbase xetc xshare xfont xserv site ; do
@


1.734
log
@let ask_yn() return 0 for yes, 1 for no

from and OK halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.733 2014/01/24 01:12:10 halex Exp $
d1162 1
a1162 1
		_tmpsrc _cfile _fsrc _unver _t
a1195 1
	resp=y
d1197 2
a1198 2
		ask_yn "INSTALL.$ARCH not found. Use sets found here anyway?"
	[[ $resp = n ]] && return
d1212 29
a1240 2
	if df | grep -q ' /mnt/home$' && isin SHA256.sig $_files &&
		_tmpsrc=$(tmpdir /mnt/home/sets); then
a1241 1
		# Fetch signed checksum file and check signature
d1243 10
a1252 3
		[[ $_src == file://* ]] && _t=Verifying || _t='Get/Verify'
		ftp -D $_t -Vmo "$_cfile.sig" "$_src/SHA256.sig" &&
		signify -Vep /etc/signify/${VERSION}base.pub \
d1254 2
d1257 12
a1268 10
			rm -f $_tmpsrc/h
			if [[ $_src == file://* ]]; then
				ln -s "${_src#file://}/$_f" "$_tmpsrc/$_f" &&
				ftp -D Verifying -Vmo - "$_src/$_f" |
					sha256 -ph $_tmpsrc/h >/dev/null
			else
				ftp -D 'Get/Verify' -Vmo - "$_src/$_f" |
					sha256 -ph $_tmpsrc/h >"$_tmpsrc/$_f"
			fi || {
				echo "Fetching of $_f failed."
d1270 5
a1274 1
				$auto && rm -rf "$_tmpsrc" && exit 1
d1276 4
a1279 3
			}
			_h=$(sed -En '/\('$_f'\)/s/^.*= (.*)$/\1/p' $_cfile)
			if [[ -s $_tmpsrc/h && $(<$_tmpsrc/h) == "$_h" ]] ; then
d1282 5
a1286 1
				echo "Checksum for $_f failed!"
d1289 8
a1298 4
	resp=y
	[[ -n $_unver ]] && echo "Unverified sets:" ${_unver% }. && \
		ask_yn "Install sets anyway?" no
	[[ $resp == y ]] &&
d1307 1
a1307 2
			echo "'$_f' did not install correctly."
			if $auto; then
d1309 2
a1310 1
				exit 1
d1316 1
a1316 1
		rm -f "$_tmpsrc/$_f"
@


1.733
log
@don't ever use an unsigned SHA256

ok rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.732 2014/01/23 22:17:57 deraadt Exp $
d439 1
d448 2
a449 2
		y|yes)	resp=y ; return ;;
		n|no)	resp=n ; return ;;
@


1.732
log
@watch out, a white space!
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.731 2014/01/23 21:56:42 rpe Exp $
d1212 1
a1212 2
	if df | grep -q ' /mnt/home$' && isin SHA256.sig $_files ||
		( [[ $_src == file://* ]] && isin SHA256 $_files ) &&
d1217 4
a1220 8
		if isin SHA256.sig $_files; then
			[[ $_src == file://* ]] && _t=Verifying || _t='Get/Verify'
			ftp -D $_t -Vmo "$_cfile.sig" "$_src/SHA256.sig" &&
			signify -Vep /etc/signify/${VERSION}base.pub \
				-x "$_cfile.sig" -m "$_cfile"
		else
			ftp -D Fetching -Vmo "$_cfile" "$_src/SHA256"
		fi &&
@


1.731
log
@- always show (ftp) progress bar with the appropriate title
- the Verifying part is done even if the sets are on local media

OK todd@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.730 2014/01/23 01:04:41 rpe Exp $
d1222 1
a1222 1
 				-x "$_cfile.sig" -m "$_cfile"
@


1.730
log
@first take in using ftp -D to more consistently show "named" progress
during (pre)fetch/verify/install

idea from and OK deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.729 2014/01/17 01:15:27 halex Exp $
d1161 1
a1161 1
		_tmpsrc _cfile _fsrc _unver
d1219 2
a1220 1
			ftp -D 'Get/Verify' -Vmo "$_cfile.sig" "$_src/SHA256.sig" &&
d1227 1
d1229 3
a1231 1
				ln -s "${_src#file://}/$_f" "$_tmpsrc/$_f"
d1233 2
a1234 1
				ftp -D 'Get/Verify' -Vmo "$_tmpsrc/$_f" "$_src/$_f"
d1241 2
a1242 2
			if sha256 "$_tmpsrc/$_f" | sed 's,/.*/,,' |
				fgrep -qxf /dev/stdin "$_cfile"; then
a1245 2
				#rm -rf "$_tmpsrc/$_f"
				#return
@


1.729
log
@add signature checking and make checksum procedure more robust by
prefetching sets to a temporary directory within /home, iff it is a
separate mount point

with rpe@@ and deraadt@@, "ffiinaallllyyy .... OK" rpe@@ (r.i.p. progress bars)
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.728 2014/01/15 00:55:21 rpe Exp $
a1216 1
		echo "Fetching checksum file."
d1219 1
a1219 1
			ftp -Vo "$_cfile.sig" "$_src/SHA256.sig" >/dev/null &&
d1223 1
a1223 1
			ftp -Vo "$_cfile" "$_src/SHA256"
a1224 1
		echo "Prefetching and verifying sets." &&
d1229 1
a1229 1
				ftp -Vmo "$_tmpsrc/$_f" "$_src/$_f"
a1250 1
	echo "Installing sets." &&
d1255 2
a1256 4
		file://*.tgz)	tar -zxphf "${_fsrc##file://}" -C /mnt;;
		file://*)	cp "${_fsrc##file://}" /mnt;;
		*.tgz)		ftp -Vmo - "$_fsrc" | tar -zxphf - -C /mnt;;
		*)		ftp -Vmo "/mnt/$_f" "$_fsrc";;
@


1.728
log
@Since we now show the installer output we want that new line back.

OK halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.727 2014/01/11 23:28:02 halex Exp $
d138 9
d1160 2
a1161 1
	local _src=$1 _files=$2 _f _sets _get_sets _n _col=$COLUMNS
d1205 43
a1247 1
	[[ $resp = n ]] && return
d1249 13
a1261 11
	for _f in $THESETS ; do
		isin $_f $_get_sets || continue
		echo -n "Getting $_f ..."
		rm -f /tmp/h
		case $_f in
		*.tgz)	ftp -Vmo - "$_src/$_f" |
				sha256 -p -h /tmp/h | tar zxphf - -C /mnt
			;;
		*)	ftp -Vmo - "$_src/$_f" |
				sha256 -p -h /tmp/h > "/mnt/$_f"
			;;
d1263 1
a1263 1
		if (($? != 0)); then
d1265 3
a1267 5
		elif [ -f /tmp/h -a -f "/var/hash/$_f" ]; then
			if [ "$(</tmp/h)" != "$(</var/hash/$_f)" ]; then
				echo "The SHA256 hash $(cat /tmp/h)"
				echo "for $_f did not match what this bsd.rd expected."
				# XXX should mark failure somehow
a1268 2
			DEFAULTSETS=$(rmel $_f $DEFAULTSETS)
			GOTSETS="$GOTSETS $_f"
d1273 1
d1275 1
@


1.727
log
@when selecting sets to install, postpone the xbase/comp check so the
comp set does not get readded if the xbase set is being removed later
on the same input line

"nice semantics" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.726 2014/01/08 21:53:35 deraadt Exp $
d2215 1
a2215 1
	echo -n "Performing non-interactive $action..."
@


1.726
log
@Switch to using the base sha256 command, rather than some customized
abomination.
install.sub chunk tested by rpe
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.725 2014/01/07 23:58:44 rpe Exp $
a620 6
			if isin $_xbase $_selected && isin $_comp $_avail ; then
				if ! isin $_comp $_selected ; then
					_selected=$(addel $_comp $_selected)
					echo "The xbase set requires the comp set, so adding it back in."
				fi
			fi
d622 5
@


1.725
log
@Make skipping the root fs DUID aware.

If ROOTDEV is either the device from fstab or the converted DUID
device name with the partition added, skip the current fstab entry

ok halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.724 2014/01/05 01:52:17 deraadt Exp $
a1197 3
	shacmd="cat"
	[[ -x /bin/sha256 ]] && shacmd="sha256 /tmp/h"

d1204 1
a1204 1
				$shacmd | tar zxphf - -C /mnt
d1207 1
a1207 1
				$shacmd > "/mnt/$_f"
@


1.724
log
@provide feed_random() and store_random().  The first is used by install or
upgrade to feed as much additional usable entropy (as early as possible)
to the current bsd.rd install kernel.  The latter is used late in the
procedure to store entropy for the next boot (of a real kernel)
based on an issue described by dtucker, must conversation with halex and rpe
tested by rpe
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.723 2013/12/23 13:57:05 rpe Exp $
d1772 1
a1772 1
	local _dev _mp _fstype _rest _fail _f _passno
d1778 2
a1779 1
		[ "$_dev" != /dev/"$ROOTDEV" ] || continue
d1782 1
a1782 1
		makedev "$(getdevname "$_dev")" || continue
@


1.723
log
@The xbase set requires the comp set. If xbase is in the selection,
but not comp, put comp back in automatically.

suggested by and ok deraadt@@
ok halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.722 2013/12/18 08:04:16 halex Exp $
d1967 17
d2041 2
@


1.722
log
@change password prompts (for the good of install.conf)
add autoinstall question for root ssh pubkey
make pubkey prompts appear in autoinstall log

ideas from and ok deraaddt@@, ok rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.721 2013/12/16 16:58:22 halex Exp $
d591 1
d621 6
@


1.721
log
@Replace `[RESPONSEFILE=...] install auto` voodoo with plain'ol getopts,
as discussed with uwe@@ at some point.

ok krw@@, rpe@@, "Cool" uwe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.720 2013/12/16 08:15:21 halex Exp $
d334 1
d336 2
a337 2
		echo -n "Password for $1 account? "
		_autorespond "Password for $1 account?"
d344 1
a344 1
		askpass "Password for $1 account? (will not echo)"
d347 1
a347 1
		askpass "Password for $1 account? (again)"
d383 1
a383 1
		ask "Full user name for $user?" $user
d394 1
a394 1
	askpassword $user
d398 1
a398 1
	_autorespond "Public ssh key for $user" none &&
d2229 1
a2229 1
		askpassword root
d2234 4
@


1.720
log
@Change subject of install|upgrade log to match periodic maintenance
email subjects better.

ok deraadt@@ rpe@@
Suggested by, and "Lovely" deraadt@@, "Sure" rpe@@,
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.719 2013/12/11 23:28:01 halex Exp $
d57 17
a73 3
# Check if we're supposed to run non-interactively before losing the
# command arguments with some "set --" magic.
[ "$1" = auto ] && auto=true || auto=false
d294 1
a294 1
# Search question in $RESPONSEFILE, return answer in $resp
d309 1
a309 1
	[[ -f $RESPONSEFILE ]] || return
d484 1
a484 1
		$auto && [[ -n $RESPONSEFILE ]] && exit 1
d2185 1
a2185 1
elif [[ -z $RESPONSEFILE ]]; then
d2192 1
a2192 2
	RESPONSEFILE=/$action.conf /$action auto 2>&1 </dev/null |
		sed 'w/ai.log'
d2210 1
a2210 1
	cp $RESPONSEFILE /ai.conf || exit
@


1.719
log
@make the word-matching of the autoinstaller config file allow skipping
the trailing question mark, such as in "hostname = foo"

noted by, discussed with, and ok rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.718 2013/12/11 06:37:46 halex Exp $
d2187 4
a2190 2
		echo "( /usr/bin/mail -s '$action log' root < $_lf &&" \
			"rm $_lf ) >/dev/null 2>&1 &" >> /mnt/etc/rc.firsttime
@


1.718
log
@for automated installs, use the hostname from the dhcp lease by default

ok rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.717 2013/12/09 23:14:34 halex Exp $
d302 1
a302 1
		[[ $_q == @@(|*[[:blank:]])"$_key"@@([[:blank:]]*|) ]] &&
@


1.717
log
@Make the response lookup of a question match on entire words, where
anything not being a whitespace is considered part of a word.

deraadt@@ likes it, rpe@@ has approved of the idea
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.716 2013/12/08 12:38:48 stsp Exp $
d2143 3
@


1.716
log
@After a completed upgrade, present reboot and post-reboot instructions in a
more intuitive order: Show the 'After rebooting, run sysmerge' hint below
the line that explains how to reboot, instead of several lines above.
Suggested by a new user doing the first upgrade.
input/ok halex@@ rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.715 2013/12/07 09:36:10 halex Exp $
d302 2
a303 1
		[[ $_q == *"$_key"* ]] && resp=$_val && cat && return
@


1.715
log
@Change the response file handling such that it "consumes" an answer
once it's been used, and allow the same question to be answered
multiple times. This way, responses to ask_which() questions no
longer need the special magic we had for them being on a single line.

idea from deraadt@@
ok rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.714 2013/12/06 00:42:45 rpe Exp $
a1996 3
	[[ "$MODE" == upgrade ]] && \
		echo "After rebooting, run sysmerge(8) to update your system configuration."

d2014 2
@


1.714
log
@Workaround closed stdin in non-interactive mode.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.713 2013/12/05 00:44:49 halex Exp $
d294 1
a294 1
	local _def=$2 _i=0 _l _val
d296 2
d302 5
a306 9
		[[ $_q == *"$_key"* ]] && resp=$_val && let _i++
	done <$RESPONSEFILE
	((_i == 1)) && return
	if ((_i == 0)); then
		[[ -n $_def ]] && resp=$_def && return
		echo "\nQuestion has no answer in response file."
		exit 1
	fi
	echo "\nQuestion has multiple answers in response file."
d461 2
a462 9
		if _autorespond "$_q" done; then
			eval ": \${ask_which_resp_$_key=\"\$resp done\"}"
			eval "set -- \$ask_which_resp_$_key"
			resp=$1; shift
			eval "ask_which_resp_$_key=\$*"
			echo "$resp"
		else
			_ask || continue
		fi
a588 1
		$auto && resp="$resp done"
d2159 10
a2168 2
# Fully automatic installation?
if $auto && [[ -z $RESPONSEFILE ]]; then
d2191 2
a2192 10
fi

if ! $auto; then
	cat <<__EOT
At any prompt except password prompts you can escape to a shell by
typing '!'. Default answers are shown in []'s and are selected by
pressing RETURN.  You can exit this program at any time by pressing
Control-C, but this can leave your system in an inconsistent state.

__EOT
@


1.713
log
@improve the question part (second line) of ask_which to actually include
the name of what we're asking for, rather than 'Which _one_ ...'
Improves things a lot for the autoinstaller.

ok rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.712 2013/12/04 21:21:35 halex Exp $
d2075 1
a2075 1
[[ -n $CONSOLE ]] && CSPEED=$(stty speed)
d2098 1
a2098 1
COLUMNS=$(stty -a | sed -n '/columns/{s/^.* \([0-9]*\) columns.*$/\1/;p;}')
@


1.712
log
@Defer spooling of the install log output mail until we are up and
running again, with our mail system of choice running.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.711 2013/12/04 16:19:32 krw Exp $
d444 1
a444 1
	local _name=$1 _query=$2 _list=$3 _def=$4 _dynlist _dyndef _key
d461 3
a463 3
		echo -n "Which one $_query? (or 'done') "
		[[ -n $_dyndef ]] && echo -n "[$_dyndef] "
		if _autorespond "${_name}s" done; then
@


1.711
log
@Eliminate spurious space that breaks parsing of nwids containing
blanks.

Same fix was applied by todd@@ to /etc/netstart (r1.114) in 2006.

Pointed out by Remy via bugs@@. Thanks!
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.710 2013/12/04 01:08:49 sthen Exp $
d2180 8
a2187 14
		_sf=/mnt/var/mail/root
		(_root="root@@$(hostname)"
		cat <<__EOT
From $_root $(date -u '+%a %b %d %T %Y')
Date: $(date '+%a, %d %b %Y %T %z (%Z)')
From: root <$_root>
To: $_root
Subject: $action log

__EOT
		sed 's/^.*//;s/^\(>*From \)/>\1/' /ai.log
		echo) >>$_sf
		chmod 600 $_sf
		echo "done."
@


1.710
log
@the hostname.if for a vlan's parent interface should be mode 640 to avoid
a warning at first boot  ok deraadt
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.709 2013/12/01 21:01:01 halex Exp $
d1078 1
a1078 1
				cmd="ifconfig $if $af $alias $name "
@


1.709
log
@More robuse parsing of the DHCP lease file for autoinstall.  This will,
for example, bail out instead of producing annoying output if the
filename statement does not match auto_(install|upgrade).

Brought up again by Patrik Lundin, thanks!
ok rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.708 2013/12/01 01:54:23 halex Exp $
d694 1
@


1.708
log
@Allows the autoinstaller to pass a public ssh key for inclusion in the
user's .ssh/authorized_keys. Deliberately not in interactive mode since
I am not sure it's worth adding another question that only quite few
people would enjoy.

ok rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.707 2013/11/29 22:28:12 rpe Exp $
d2124 1
a2124 1
	local _f _ifdev _mac _mode _server
d2147 4
a2150 4
	_server=$(sed "/next-server/s/^.* \([^ ]*\);$/\1/p;d" \
	    /var/db/dhclient.leases.$_ifdev 2>/dev/null)
	_mode=$(sed -E '/filename/s/^.*auto_(install|upgrade).*$/\1/p;d' \
	    /var/db/dhclient.leases.$_ifdev 2>/dev/null)
d2153 13
a2165 4
	for _f in $_mac-$_mode $_mode; do
		ftp -o "/$_mode.conf" "http://$_server/$_f.conf"
		[[ -s /$_mode.conf ]] && action=$_mode && break
	done
d2170 1
a2170 3
	action=
	get_responsefile
	if [[ -z $action ]]; then
@


1.707
log
@Move the comments out of get_responsefile() into a description block
at the top.

ok halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.706 2013/11/29 02:02:47 rpe Exp $
d382 4
@


1.706
log
@- Rename _bootdev to _ifdev now that we not only support
  the interface we netbooted from for initial dhcp reqest.
- Change the error message in case no response file was
  found to match the info message at the beginning.

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.705 2013/11/28 22:56:05 rpe Exp $
d2112 7
a2118 1
# Fetch a response file from the "netboot" interface.
a2120 2
	# Fetching the response file requires DHCP, even if the
	# machine was booted via RARP and TFTP.
a2122 1
	# Select network interface for initial dhcp request
a2139 2
	# Take interface down killing a dhclient from a previous attempt
	# and so free up the only bpf which exists in this installstage.
a2140 3

	# Try to get a DHCP lease.  This whole process is done in the
	# background, so it doesn't matter how long the timeout is.
a2142 3
	# Extract next-server IP and the installer mode from attributes
	# in the dhcp lease file. Use this together with the MAC from the
	# netboot interface to assemble the URL.
@


1.705
log
@simplify the check if a responsefile line is valid

idea from and ok halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.704 2013/11/28 22:31:07 halex Exp $
d2114 1
a2114 1
	local _bootdev _f _mac _mode _server
d2120 2
a2121 2
	_bootdev=$(get_ifdevs netboot)
	if [[ -z $_bootdev ]]; then
d2125 1
a2125 1
			_bootdev=$1
d2131 1
a2131 1
				isin "$resp" $* && _bootdev=$resp && break
d2135 1
a2135 1
	[[ -n $_bootdev ]] || return
d2139 1
a2139 1
	ifconfig $_bootdev down
d2143 1
a2143 1
	dhclient $_bootdev
d2149 1
a2149 1
	    /var/db/dhclient.leases.$_bootdev 2>/dev/null)
d2151 2
a2152 2
	    /var/db/dhclient.leases.$_bootdev 2>/dev/null)
	_mac=$(ifconfig $_bootdev | sed 's/.*lladdr \(.*\)/\1/p;d')
d2165 1
a2165 1
		echo "No response file found; automatic installation aborted."
@


1.704
log
@make ask_which bail out on a missing response in the autoinstall case
rather than looping endlessly.

ok rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.703 2013/11/28 21:20:40 rpe Exp $
d297 1
a299 2
		((${#_key} != ${#_l})) || continue
		[[ -n ${_key%%#*} && -n $_val ]] || continue
@


1.703
log
@- use IFS=<space><tab> to trim the leading/trailing blanks with read
- simplify the key/value splitting with a true halexism
- recognize a line without a '=' by counting the chars in _key/_val
  instead of doing a string comparison which needs a temporary _k var
- localize _l

ok krw@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.702 2013/11/27 21:49:21 deraadt Exp $
d399 1
a399 1
	while [[ -z $resp ]] ; do
d401 3
@


1.702
log
@wasteful spaces and tabs snuck in.  Actually, it's true -- this is one
place where they do matter...
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.701 2013/11/27 21:48:25 rpe Exp $
d283 1
a283 2
# - strip leading/trailing blanks from question
# - strip leading blanks from answer
d294 1
a294 1
	local _def=$2 _i=0 _k _val
d296 4
a299 4
	while IFS= read -r _l; do
		_k=${_l%%*([[:blank:]])=*} _val=${_l#*=}
		_key=${_k##+([[:blank:]])} _val=${_val##+([[:blank:]])}
		[[ $_k != "$_l" ]] || continue
@


1.701
log
@Remove an outdated comment.

ok krw@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.700 2013/11/25 23:02:04 rpe Exp $
d304 1
a304 1
	((_i == 1)) && return	
d2152 1
a2152 1
	
@


1.700
log
@Allow auto install/upgrade in non-netbooted case.

Add some logic to get_responsefile() to select an interface for the
initial dhcp request which tells what to do (install/upgrade) and
where to fetch the responsefile from.

- if netbooted, use the interface in netboot group, or
- if only one interface exists, use it, or
- if more intefaces exist, ask user which one to use

Tweak ask_which() to be usable if $auto is true, but
$RESPSONSEFILE not yet set.

ok halex@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.699 2013/11/25 21:51:48 rpe Exp $
a443 3
		# Put both lines in ask prompt, rather than use a
		# separate 'echo' to ensure the entire question is
		# re-ask'ed after a '!' or '!foo' shell escape.
@


1.699
log
@Rework _autorespond()

- strip leading/trailing blanks from question
- strip leading blanks from answer
- compare questions case insensitive
- ignore empty and comment lines and lines without =
- treat empty/missing/multiple answers as error and exit
- ensure, that $RESPONSEFILE is actually an existing file.
- unset IFS to preserve leading/trailing blanks on read.
- use read -r, because we don't support line continuation in answers.
- simplify the "_i=0 but we have a default answer" case a bit.

lots of feedback from halex@@
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.698 2013/11/23 13:25:47 rpe Exp $
d476 1
a476 1
		$auto && exit 1
d2121 1
a2121 1
	# Did we do a netboot?
d2123 14
@


1.698
log
@- use a flag file to recognize a successfull autoinstaller run
- use a shorter constant logfile name
- quote From lines and remove ^M in ftp output from logfile
- provide the autoinstaller logfile as mail to root

with help and positive feedback halex@@ krw@@ deraadt@@
ok halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.697 2013/11/19 12:02:55 rpe Exp $
d280 13
d295 12
a306 11
	local _def=$2 _value _i=0
	[[ -n $RESPONSEFILE ]] || return
	while IFS== read _key _value; do
		_key=${_key##+( |	])} _value=${_value##+( |	)}
		_key=${_key%%+( |	])} _value=${_value%%+( |	)}
		[[ $_q == *"$_key"* && -n $_value ]] &&
			resp=$_value && let _i++
	done < $RESPONSEFILE
	(( _i == 1 )) && return
	(( !_i )) && [[ -n $_def ]] && resp=$_def && return
	if (( !_i )); then
@


1.697
log
@Fetch host specific responsefile, if that does not exist, fall back
to generic one.

noted by and ok phessler@@
ok krw@@ and positive feedback deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.696 2013/11/18 21:31:39 rpe Exp $
d2010 1
d2142 13
d2156 4
a2159 4
	echo -n "Performing non-interactive $action..."
	RESPONSEFILE=/$action.conf /$action auto >>/$action.log 2>&1 <&-
	# XXX: Isn't the installer's exit code reliable?
	if grep -q CONGRATULATIONS /$action.log; then
a2160 1
		cp /$action.log /mnt/$action.log
d2163 1
a2163 1
		echo "failed; check /$action.log"
@


1.696
log
@Extract the information whether to install or upgrade in unattended
mode from DHCP attribute "filename", which has to be "auto_install"
or "auto_upgrade". For archs that use this attribute for the boot
program create a symbolic link to auto_install and/or auto_install.

Change the naming scheme for response files on the http server to
<mac-addres>-<install|upgrade>.conf where <mac-address> is the
lladdr of the netboot interface of to be installed/upgraded hosts,
e.g. 52:54:00:12:34:56-install.conf. This allows different response
files for multiple hosts.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.695 2013/11/13 19:17:22 rpe Exp $
d2101 1
a2101 1
	local _bootdev _mac _mode _server
d2127 4
a2130 2
	ftp -o "/$_mode.conf" "http://$_server/$_mac-$_mode.conf"
	[[ -s /$_mode.conf ]] && action=$_mode
@


1.695
log
@Ignore empty lines and emtpy answers in install.conf.

bug report from philip
e1c1bac6253dc54a1e89ddc046585792 at posteo dot net

ok halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.694 2013/11/13 07:16:55 rpe Exp $
d2101 1
a2101 1
	local _bootdev _rf=$1 _server
d2118 3
a2120 1
	# Get the "next-server" address?
d2123 6
a2128 4
	[[ -n $_server ]] || return

	ftp -o "$_rf" "http://$_server/install.conf"
	[[ -s $1 ]]
d2133 3
a2135 2
	responsefile=/install.conf
	if ! get_responsefile $responsefile; then
d2140 2
a2141 2
	echo -n "Performing non-interactive installation..."
	RESPONSEFILE=$responsefile $0 auto >>/install.log 2>&1 <&-
d2143 1
a2143 1
	if grep -q CONGRATULATIONS /install.log; then
d2145 1
a2145 1
		cp /install.log /mnt/install.log
d2148 1
a2148 1
		echo "failed; check /install.log"
@


1.694
log
@Ensure, that install.conf is non-empty and is
refetched on every restart of the autoinstaller.

ok halex@@ krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.693 2013/11/12 15:30:11 rpe Exp $
d287 2
a288 1
		[[ $_q == *"$_key"* ]] && resp=$_value && let _i++
@


1.693
log
@Make variables inside get_responsefile() local.

ok krw@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.692 2013/11/12 13:20:47 rpe Exp $
d2129 1
a2129 2
	[ -f $responsefile ] || get_responsefile $responsefile
	if [ ! -f $responsefile ]; then
@


1.692
log
@Rework get_responsefile()

- Take netboot interface down and so kill a dhclient from a previous
  attempt and to free up the only bpf which exists in this installstage.
  Without this, we're not able to "restart" autoinstall because dhclient
  fails due to lack of bpf's. dhclient takes the interface up again.
- Remove -s leasefile check, it's implicitly done with -n SERVER check.
- Avoid possible sed error msgs by redirecting STDERR to /dev/null.
- Fetch install.conf in a ftp on-liner whithout unneccessary URL var.
- Shorten -s install.conf check,
- [] -> [[]] for consistency

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.691 2013/11/09 22:37:53 rpe Exp $
d2100 1
d2106 2
a2107 2
	BOOTDEV=$(get_ifdevs netboot)
	[[ -n $BOOTDEV ]] || return
d2111 1
a2111 1
	ifconfig $BOOTDEV down
d2115 1
a2115 1
	dhclient $BOOTDEV
d2118 3
a2120 3
	SERVER=$(sed "/next-server/s/^.* \([^ ]*\);$/\1/p;d" \
	    /var/db/dhclient.leases.$BOOTDEV 2>/dev/null)
	[[ -n $SERVER ]] || return
d2122 1
a2122 1
	ftp -o "$1" "http://$SERVER/install.conf"
@


1.691
log
@Abort autoinstaller in case of an invalid answer to a yes/no question.
Avoids an endless question/wrong answer loop.

with help from and ok halex@@
ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.690 2013/11/09 19:38:59 rpe Exp $
d2102 1
a2102 1
	[ -x /sbin/dhclient ] || return
d2108 4
a2114 1
	[ -s /var/db/dhclient.leases.$BOOTDEV ] || return
d2118 1
a2118 1
	    /var/db/dhclient.leases.$BOOTDEV)
d2121 2
a2122 3
	URL="http://$SERVER/install.conf"
	ftp -o "$1" "$URL"
	[ -s "$1" ] || return
@


1.690
log
@Abort automatic installation if no sets are found in install_files().

ok krw@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.689 2013/11/09 19:32:55 rpe Exp $
d407 2
@


1.689
log
@Replace handrolled tolower() function with ksh equivalent.

ok krw@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.688 2013/11/08 21:34:35 rpe Exp $
d1148 1
@


1.688
log
@Use get_ifdevs() to get the interface name
which the system netbooted from.

"cool" uwe@@ on a similar diff
ok krw@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.687 2013/11/05 19:54:40 uwe Exp $
a279 4
tolower() {
	echo "$1" | sed 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'
}

d281 2
a282 1
	local _q=$1 _def=$2 _key _value _i=0
a286 2
		_q=$(tolower "$_q")
		_key=$(tolower "$_key")
@


1.687
log
@avoid touching the signal traps during autoinstall

With this, the installer finishes even when there are kernel messages
output during the installation. :)

original diff and ok halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.686 2013/10/31 19:15:20 halex Exp $
d2107 1
a2107 1
	BOOTDEV=$(ifconfig netboot 2>/dev/null | sed "/^	/d;s/:.*//")
@


1.686
log
@If if looks like a duck, swims like a duck, and quacks like a duck, then
it's probably is a pre-encrypted password hash.

This means that the autoinstall configuration (and interactive password
too) does not have to specify a cleartext password.

reworked diff originating from krw@@
no objections, specifically so from krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.685 2013/10/27 22:36:06 uwe Exp $
d57 4
d222 14
a235 13
# Start listener process looking for dmesg changes
(
	while :; do
		lock
		if test -e /tmp/update && [[ "`dmesg`" != "`cat /tmp/update`" ]]; then
			dmesg >/tmp/update
			kill -TERM 2>/dev/null $$ || exit 1
		fi
		unlock
		sleep .5
	done
) |&
cppid=$!
d237 3
a239 2
# Kill the child on exit
retrap
d253 3
a257 3
	lock; dmesg >/tmp/update; unlock
	echo -n "${_q:+$_q }${_def:+[$_def] }"
	_autorespond "$_q" "$_def" && echo "$resp" && retrap && return
a2021 4

# Check if we're supposed to run non-interactively before losing the
# command arguments with some "set --" magic.
[ "$1" = auto ] && auto=true || auto=false
@


1.685
log
@Unattended installation using DHCP and a response file

For a completely unattended installation bsd.rd has to be netbooted,
a DHCP server must be running and provide "next-server", which will be
used to fetch "http://<next-server>/install.conf".  The format of the
response file is a list of "<key> = <value>" pairs where <key> is a
substring of the interactive question (case-insensitive) and <value> is
what would be entered interactively.

Minimal response file example:

  system hostname = openbsd
  password for root account = <...>
  network interfaces = re0
  IPv4 address for re0 = dhcp
  server? = <...>

This is a starting point, it still a bit rough.

ok krw@@, many improvements by halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.684 2013/08/19 21:07:22 halex Exp $
d324 11
@


1.684
log
@(temporarily) introduce upgrade_to64time_t() to handle the transition
to 64 bit time_t

prodded by deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.683 2013/07/31 11:26:58 ajacoutot Exp $
d103 1
d107 1
d251 1
d274 24
d307 8
d410 3
a412 1
	local _name=$1 _query=$2 _list=$3 _def=$4 _dynlist _dyndef
d432 9
a440 1
		_ask || continue
d447 1
d567 1
d610 1
d1617 3
d2006 4
d2087 49
a2135 1
cat <<__EOT
d2142 1
@


1.683
log
@Remove the sysmerge(8) glue from the installer -- it's never been used
and something else is in the work.

ok halex@@ sthen@@ deraadt@@ kettenis@@ phessler@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.682 2013/07/21 22:06:51 halex Exp $
d1862 8
d1927 3
@


1.682
log
@stop adding static entries to /etc/hosts for dynamic ip addresses

"do it NOW" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.681 2013/06/10 21:19:29 rpe Exp $
a1132 10

		# get sets and save arguments for sysmerge(8)
		[[ $_f == base$VERSION.tgz ]] &&
			ftp -Vmo /mnt/tmp/etc$VERSION.tgz \
				"$_src/etc$VERSION.tgz" >/dev/null 2>&1 &&
			SM_ARGS="-s /tmp/etc$VERSION.tgz"
		[[ $_f == xbase$VERSION.tgz ]] &&
			ftp -Vmo /mnt/tmp/xetc$VERSION.tgz \
				"$_src/xetc$VERSION.tgz" >/dev/null 2>&1 &&
			SM_ARGSX="-x /tmp/xetc$VERSION.tgz"
a1571 10
run_sysmerge() {
	echo "After rebooting, run sysmerge(8) to update your /etc configuration."
	#if [[ -n "$SM_ARGS" || -n "$SM_ARGSX" ]]; then
	#	ask_yn "Merge the new etc/xetc install sets using sysmerge(8)?" no
	#	if [[ $resp == y ]]; then
	#		/mnt/usr/sbin/chroot /mnt /usr/sbin/sysmerge $SM_ARGS $SM_ARGSX
	#	fi
	#fi
}

d1915 2
a1916 1
	[[ "$MODE" == upgrade ]] && run_sysmerge
@


1.681
log
@rework v6_defroute()
- simplify search for an existing ipv6 def. route
- ensure, that $_routers holds a sorted and unique list
- show 'list #' in prompt only if there's a list to select from
- zap IFS/_oifs dance and simplify select loop
- set ipv6 def. route in v6_defroute() instead of in v6_config()

thanks naddy@@ and todd@@ for their feedback
ok sthen@@, krw@@ on a similar diff
with help from and ok halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.680 2013/06/04 00:42:23 halex Exp $
a825 3
			# Add hosts entry. Overwrites previous entry if any.
			set -- $(v4_info $_ifs)
			addhostent "$2" "$_name"
a859 2
			set -- $(v6_info $_ifs)
			addhostent "$2" "$_name"
@


1.680
log
@supress errors that would occur if bioctl is missing or is run with an
unsupported disk as argument (e.g. wd*)
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.679 2013/06/02 14:55:39 halex Exp $
a877 3
	[[ $resp == none ]] && return
	route -n add -inet6 -host default "$resp" || return
	echo "$resp" >>/tmp/mygate
d906 1
a906 1
	local _if=$1 _routers _oifs
d908 1
a908 4
	if [[ -z $(route -n show -inet6 | sed -ne '/^default */{s///; s/ .*//; p;}') ]]; then
		resp=none
		return
	fi
d910 3
a912 4
	if [[ -x /sbin/ping6 ]]; then
		_routers=$(ping6 -n -c 2 ff02::2%$_if 2>&1 |
			sed -ne '/bytes from/{s/^.*from //;s/,.*$//;p;}')
	fi
d914 4
a917 12
	_oifs=$IFS
	IFS=
	PS3="IPv6 default router? (list #, IPv6 address or 'none'): "
	select i in $_routers; do
		case $i in
		"")	resp=$REPLY
			[[ -n $resp ]] && break
			;;
		*)	resp=$i
			break
			;;
		esac
d919 3
a921 1
	IFS=$_oifs
@


1.679
log
@If case we're running installboot on a softraid device, make sure all
underlying device nodes exists. Also clean up makedev and allow it to
pass multiple arguments to MAKEDEV.

ok krw@@ rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.678 2013/05/31 23:52:18 halex Exp $
d1944 1
a1944 1
	makedev $(bioctl $ROOTDISK | sed -n 's/.*<\(.*\)>$/\1/p')
@


1.678
log
@clean up some IFS and input handling

ok rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.677 2013/05/31 06:27:08 rpe Exp $
d476 1
a476 3
# Create a device.
#
# $1 = name of the device to create.
d478 1
a478 8
	local _dev=$1

	if [[ ! -r /dev/MAKEDEV ]] ; then
		echo "MAKEDEV not found. Can't create device nodes."
		return 1
	fi

	[[ -z $(cd /dev && sh MAKEDEV "$_dev" 2>&1) ]]
d1942 3
@


1.677
log
@remove unneeded '\' for line continuations

ok halex@@ krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.676 2013/05/25 15:00:25 rpe Exp $
d123 1
a123 2
	local _n _oifs=$IFS
	IFS=","
a124 1
	IFS=$_oifs
d184 1
a185 1
	set -o noglob
d187 1
a187 1
	read -r resp?"$1 "
a188 1
	set +o noglob
a279 2
	local _oifs=$IFS
	IFS=
d285 1
a285 3
		# N.B.: Need quotes around $resp and $_password to preserve leading
		#       or trailing spaces.
		[[ "$resp" == "$_password" ]] && break
a288 1
	IFS=$_oifs
d336 1
a336 1
ask_until() {
d1276 1
a1276 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _passwd _mirror
d1343 2
a1344 5
		# Get login name, setting IFS to nothing so trailing or
		# embedded blanks are preserved!
		_oifs=$IFS
		IFS=
		ask_until "Login?" "${_ftp_server_login:=anonymous}"
a1356 1
		IFS=$_oifs
@


1.676
log
@remove first and last space within (( ))

ok halex@@ krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.675 2013/03/25 21:35:45 halex Exp $
d138 3
a140 3
	ifconfig "$@@" 2>/dev/null \
		| egrep -v '^[[:space:]]|(bridge|enc|gif|gre|lo|pflog|pfsync|ppp|sl|tun)[[:digit:]]+:' \
		| sed -ne 's/^\(.*\):.*/\1/p'
d153 2
a154 2
	disklabel $_dev 2>/dev/null | grep '^  [a-p]: '	\
		| egrep -v "swap|unused" >$_file
d593 1
a593 1
			_vi=$(ifconfig $_ifs 2>/dev/null | \
d596 1
a596 1
			_tags=$(ifconfig vlan 2>/dev/null | \
d630 1
a630 1
			grep -qs "^up" /tmp/hostname.$_vd || \
d649 1
a649 1
		[[ -n $_first && $_first != $_ifs ]] && \
d934 2
a935 2
		_routers=$(ping6 -n -c 2 ff02::2%$_if 2>&1 | sed -n \
			-e '/bytes from/{s/^.*from //;s/,.*$//;p;}')
d1109 1
a1109 1
		isin $_f $DEFAULTSETS "site$VERSION-$(hostname -s).tgz" && \
d1147 1
a1147 1
		*.tgz)	ftp -Vmo - "$_src/$_f" | \
d1150 1
a1150 1
		*)	ftp -Vmo - "$_src/$_f" | \
d1170 1
a1170 1
		[[ $_f == base$VERSION.tgz ]] && \
d1172 1
a1172 1
				"$_src/etc$VERSION.tgz" >/dev/null 2>&1 && \
d1174 1
a1174 1
		[[ $_f == xbase$VERSION.tgz ]] && \
d1176 1
a1176 1
				"$_src/xetc$VERSION.tgz" >/dev/null 2>&1  && \
d1386 1
a1386 1
		_file_list=$(ftp -Vo - "$_url_base/index.txt" | \
d1587 1
a1587 1
	[[ -s $SERVERLISTALL ]] && \
d1625 1
a1625 1
	#	if [[ $resp == y ]]; then \
d1657 4
a1660 4
		[[ $_dev == @@(/dev/vnd*|\#*) || \
			$_fstype == nfs || \
			! -f /sbin/mount_$_fstype || \
			$_opt == *noauto* || \
d1872 1
a1872 1
		[[ -n $CPROM ]] && \
d1933 1
a1933 1
			[[ $_fstype == swap ]] && \
@


1.675
log
@during upgrade network setup, print friendlier error message if
/sbin/dhclient is required but missing

brought to attention by florian@@
ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.674 2013/01/02 20:35:00 krw Exp $
d254 1
a254 1
	if (( _redo )); then
d269 1
a269 1
	(( _int )) && kill -INT $$
d311 1
a311 1
			(( ${#resp} <= 31 )) && break ;;
d322 1
a322 1
			(( ${#resp} <= 100 )) && break
d397 1
a397 1
		(( $# < 1 )) && resp=done && return
d623 1
a623 1
			if (( _vi < 1 || _vi > 4095 )) || isin "$_vi" $_tags; then
d1244 1
a1244 1
	(( nifs < 1 )) && return
d1340 1
a1340 1
	if (( $# > 1 )); then
d2095 1
a2095 1
	(( nifs != 0 )) && startftplist
@


1.674
log
@Sync hostname.if parsing with /etc/netstart. Toss in a ipv6
'prefix' parsing fix.

ok rpe@@ naddy@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.673 2012/12/16 20:01:26 rpe Exp $
d1009 5
a1013 1
				cmd="$cmd; dhclient $if"
@


1.673
log
@use grep -q instead of redirecting to /dev/null

ok krw@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.672 2012/11/22 17:57:22 ajacoutot Exp $
d685 1
d983 2
a984 1
				# we are carrying over from the 'read dt dtaddr' last time
d987 4
a990 2
				# make sure and get any remaining args in ext2, like the read below
				i=1; while [ i -lt 6 -a -n "$1" ]; do shift; let i++; done
d996 3
a998 3
			# $af can be "dhcp", "up", "rtsol", an address family, commands, or
			# a comment.
			case $af in
a1016 5
			"up")
				# The only one of these guaranteed to be set is $if
				# the remaining ones exist so that media controls work
				cmd="ifconfig $if $name $mask $bcaddr $ext1 $ext2 up"
				;;
d1030 1
a1030 1
				case $dt in
d1033 1
a1033 1
				[a-z!]*)
a1036 4
				if [ -z "$name" ]; then
					echo "/mnt/etc/hostname.$if: invalid network configuration file"
					return
				fi
d1038 7
a1044 2
				inet)	[ "$mask" ] && cmd="$cmd netmask $mask"
					if [ "$bcaddr" -a "$bcaddr" != "NONE" ]; then
d1047 1
a1047 1
					[ "$alias" ] && rtcmd="; route -qn add -host $name 127.0.0.1"
d1050 4
@


1.672
log
@Stop saying "please", people needs to run sysmerge(8) after an upgrade.
Also s/repair/update .

wording from sthen@@
ok sthen@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.671 2012/11/06 17:49:39 krw Exp $
d819 1
a819 1
	if ifconfig $_ifs | grep 'groups:.* dhcp' >/dev/null 2>&1; then
@


1.671
log
@Always setup lo0 with 127.0.0.1/8 when configuring the network,
whether installing or upgrading.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.670 2012/10/21 06:41:14 deraadt Exp $
d1614 1
a1614 1
	echo "Please run sysmerge(8) after rebooting to repair your /etc configuration."
@


1.670
log
@remove some backwards compat for 5.0 -> 5.1/5.2 upgrades
ok krw matthieu
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.669 2012/10/20 22:40:25 halex Exp $
d574 3
a1368 3

	# XXX Workaround for problems ftp'ing out from a v6 only host.
	ifconfig lo0 127.0.0.1
@


1.669
log
@waitftplist:
- simplify
- remove excess comments
- reduce verbosity

ok deraadt@@ rpe@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.668 2012/10/01 18:49:13 rpe Exp $
a1129 5

	# XXX Fix xkb mistake in 5.0
	# XXX Remove this chunk after 5.2 release
	local _bad_dir=/mnt/usr/X11R6/share/X11/xkb/symbols/srvr_ctrl
	isin xshare${VERSION}.tgz $_get_sets && [[ -d $_bad_dir ]] && rm -rf $_bad_dir
@


1.668
log
@remove check for negative numbers in resp
previous check ensures positive numbers

ok halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.667 2012/09/29 17:42:10 rpe Exp $
a1259 1
# XXX contains a bit of debug code for now
d1261 1
a1261 9
	local _dot						# XXX

	[[ -z $ftppid ]] && return
	while [[ -n $(jobs $ftppid 2>/dev/null) ]]; do
		echo -n .					# XXX
		_dot=.						# XXX
		sleep 0.2					# XXX
	done
	[[ -n $_dot ]] && echo					# XXX
@


1.667
log
@use ++ operator for increments

ok halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.666 2012/09/29 17:17:10 rpe Exp $
a1487 1
		(($resp < 0)) && continue
@


1.666
log
@use (()) for arithmetic tests

ok halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.665 2012/09/03 07:34:37 deraadt Exp $
d570 1
a570 1
		: $(( _vl++ ))
d599 1
a599 1
				while (( (_vi += 1) < 4096 )); do
d636 1
a636 1
			[[ ${_ifs##vlan} == $_vl ]] && (( _vl += 1 ))
d655 1
a655 1
			(( nifs += 1 ))
d968 1
a968 1
		(( nifs += 1 ))
d983 1
a983 1
				i=1; while [ i -lt 6 -a -n "$1" ]; do shift; let i=i+1; done
@


1.665
log
@compress arguments to the ftp command; ok halex
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.664 2012/09/03 04:35:30 deraadt Exp $
d158 1
a158 1
	[[ $# == 0 ]] && { echo "No filesystems found on $_dev." ; return 1 ; }
d163 1
a163 1
	elif [[ $# == 1 ]]; then
d449 1
a449 1
	[[ $# -gt 0 ]] || return
d784 1
a784 1
		[[ $_haswpa == 1 ]] && _prompt="$_prompt, WPA-(P)SK"
d1148 1
a1148 1
		if [ $? -ne 0 ]; then
d1321 1
a1321 1
			[[ $# -lt 1 ]] && { echo "There is no line $resp." ; continue ; }
d1751 1
a1751 1
		[[ $_passno > 0 ]] || continue
d2065 1
a2065 1
[ COLUMNS -eq 0 ] && COLUMNS=80
@


1.664
log
@roll a comment to a new line, so that the comment-stripper can remove it
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.663 2012/09/03 04:34:36 deraadt Exp $
d1141 1
a1141 1
		*.tgz)	ftp $FTPOPTS -o - -m "$_src/$_f" | \
d1144 1
a1144 1
		*)	ftp $FTPOPTS -o - -m "$_src/$_f" | \
d1165 2
a1166 2
			ftp $FTPOPTS -o /mnt/tmp/etc$VERSION.tgz \
				-m "$_src/etc$VERSION.tgz" >/dev/null 2>&1 && \
d1169 2
a1170 2
			ftp $FTPOPTS -o /mnt/tmp/xetc$VERSION.tgz \
				-m "$_src/xetc$VERSION.tgz" >/dev/null 2>&1  && \
d1245 1
a1245 1
		ftp $FTPOPTS -a -o - "http://129.128.5.191/cgi-bin/ftplist.cgi?path=$FTPSETDIR" \
d1285 1
a1285 2
# Note:	_ftp_server_ip, _ftp_server_dir, _ftp_server_login,
#	and FTPOPTS must be global.
d1386 1
a1386 1
		_file_list=$(ftp $FTPOPTS "$_url_base/")
d1392 1
a1392 1
		_file_list=$(ftp $FTPOPTS -o - "$_url_base/index.txt" | \
a2013 1
FTPOPTS="-V"
@


1.663
log
@we CAPITALIZE variables used in multiple sh functions
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.662 2012/07/20 01:33:40 krw Exp $
d1905 2
a1906 1
		_xdmask=$resp	# if aperture was n, do not ask for xdm
@


1.662
log
@Replace some leading blanks before comments with leading tab. Noticed
by and diff from Robert at peichaer dot org.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.661 2012/07/14 08:45:33 halex Exp $
d1404 1
a1404 1
		package_path=$(print -r -- "$installedfrom" |
d1408 1
a1408 1
		package_path=
d1946 1
a1946 1
	if [[ -n $package_path ]]; then
d1948 1
a1948 1
		print -r -- "installpath = $package_path" >> /tmp/pkgconf
d2008 1
a2008 1
package_path=
@


1.661
log
@as _resp is being localized by typeset -l, no need to localize it twice

from Robert Peichaer, thanks!

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.660 2012/07/12 10:42:48 halex Exp $
d1131 2
a1132 2
        # XXX Fix xkb mistake in 5.0
        # XXX Remove this chunk after 5.2 release
@


1.660
log
@ksh does not properly separate the arguments in "$@@" if IFS is an
empty string.

Since some places in the installer like to fiddle with IFS before
calling the various ask functions, be sure to use the positional
parameters one by one in those.

I believe the fix should really be applied to ksh, but this should
do for now.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.659 2012/07/09 10:51:10 halex Exp $
d358 1
a358 1
	local _q=$1 _a=${2:-no} _resp
@


1.659
log
@when being asked which disk to install on, give the user the chance to
see some details for each device.

"Lovely" deraadt@@ and some more ok's on previous similar versions
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.658 2012/07/08 10:10:18 halex Exp $
d278 1
a278 1
	while ! _ask "$@@"; do done
@


1.658
log
@Move functionality from ask() to _ask() to make the latter more useful
from other places.

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.657 2012/04/21 10:17:26 henning Exp $
d2120 14
d2136 9
a2144 3
	ask_which "disk" "is the root disk" '$(get_dkdevs | sed s,^$,none, )'
	[[ $resp == done ]] && exit
	[[ $resp != none ]] && break
@


1.657
log
@remove the "Do you want to do any manual network configuration?" question.
there is barely ever a need to do so these days, I for one don't remember
ever using it, and we have a well documented way of escaping to a shell at
any point in the install process, which the installer conveniently points
out right at the beginning.
stumbled upon while reviewing the upcoming 2nd edition of Michael Lucas'
"Absolute OpenBSD"
ok sthen deraadt halex krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.655 2011/11/22 14:02:14 krw Exp $
d240 5
d246 1
a246 1
	local _int _redo=0 _pid
d251 1
d270 1
d274 3
a276 9
# Ask for user input.
#
#    $1    = the question to ask the user
#    $2    = the default answer
#
# Save the user input (or the default) in $resp.
#
# Allow the user to escape to shells ('!') or execute commands
# ('!foo') before entering the input.
d278 1
a278 7
	local _question=$1 _default=$2

	while :; do
		echo -n "$_question "
		[[ -z $_default ]] || echo -n "[$_default] "
		_ask && : ${resp:=$_default} && break
	done
@


1.656
log
@more cleanup of the bad style of closing fd 0-2

pre-lock ok krw@@
@
text
@a488 8
# Offer to shell out for manual network configuration, and do so if
# the user accepts the offer.
manual_net_cfg() {
	ask_yn "Do you want to do any manual network configuration?"

	[[ $resp == y ]] && { echo "Type 'exit' to return to $MODE." ; sh ; }
}

a1834 2

	manual_net_cfg
@


1.655
log
@MAKEDEV never reports failure, always returning 0. So check for
error messages to detect failure to create a device.

Provides the user the intended chance to proceed without mounting
a filesystem whose device can't be created. Particularly useful
for softraid encrypted partitions that are not needed during an
upgrade.

ok halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.654 2011/11/08 19:55:52 deraadt Exp $
d138 1
a138 1
	ifconfig "$@@" 2>&- \
d200 1
a200 1
	while ! mkdir /tmp/lock 2>&- && sleep .1; do done
d205 1
a205 1
	rm -d /tmp/lock 2>&-
d210 1
a210 1
	trap '>&- && kill -KILL $cppid 2>&-; echo; stty echo; exit 0' \
d225 1
a225 1
			kill -TERM 2>&- $$ || exit 1
d653 1
a653 1
		ifconfig $_ifs 2>&- | grep -q "^[[:space:]]*ieee80211:" &&
d736 1
a736 1
	ifconfig $_ifs delete down -group dhcp 2>&-
d771 1
a771 1
	ifconfig $_ifs -wpa 2>&- && _haswpa=1
d1289 2
a1290 2
	local _ftplist_sec=$(cat $SERVERLISTSEC 2>&-)
	local _time=$(sed '/^TIME=\([0-9]*\)$/!d;s//\1/;q' $SERVERLISTALL 2>&-)
d1353 1
a1353 1
	set -- $(sed "/^$_server_ip/x;\$!d;x" $SERVERLIST 2>&-)
d1962 1
a1962 1
		grep -v '^[ 	]*installpath[ 	]*=' /mnt/etc/pkg.conf 2>&- > /tmp/pkgconf
d2096 1
a2096 1
	ifconfig $_ifs delete down -group dhcp 2>&-
@


1.654
log
@Now that the code is well tested, don't ask the firmware question
anymore.  Saves 141 precious bytes on the inside of the media.
ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.653 2011/10/18 19:02:44 matthieu Exp $
d508 1
a508 1
	(cd /dev && sh MAKEDEV "$_dev") >/dev/null 2>&1
@


1.653
log
@Fix xkb mistake: remove symbols/srvr_ctrl directory that is now a file
in xshareXX.tgz before extracting it.
With feedback from  halex@@, krw@@ and deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.652 2011/08/08 15:41:17 halex Exp $
d1653 1
a1653 5
	local _get=Install
	[[ $MODE == upgrade ]] && _get=Update
	ask_yn "$_get non-free firmware files on first boot?" no
	[[ $resp == y ]] && \
		echo "/usr/sbin/fw_update -v" >> /mnt/etc/rc.firsttime
@


1.652
log
@revert the last commit and do the right thing instead.

tested and ok krw@@, "get it in" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.650 2011/08/02 20:40:52 deraadt Exp $
d1143 5
@


1.651
log
@Check that timezones provided by the user do not include spaces.
e.g. 'Brazil/DeNoronha East'. Input with embedded spaces put the
install script into a state where a valid timezone could not be
entered.

Problem noted by and fix tested by Javier Bassi.

ok deraadt@@
@
text
@a1555 3
		*+([[:space:]])*)
			echo "'$_zonepath' is not a valid timezone on this system."
			continue ;;
d1558 1
a1558 1
		while isin $_zonepath/ $(cat $_zonefile); do
a1564 2
			*+([[:space:]])*)
				echo "'$_zonepath/$resp' is not a valid timezone on this system." ;;
d1569 1
a1569 1
		if isin $_zonepath $(cat $_zonefile); then
d1574 2
a1575 1
		echo "'${_zonepath}' is not a valid timezone on this system."
@


1.650
log
@Disable upgrade-time sysmerge for the 5.0 release.  Between 4.9 and 5.0
/etc has changed in substantial ways.  Perhaps on the 5.0->5.1 transition
this will not be so scary.  As it is now, it is way too tempting for
inexperienced users with incredibly complex configurations to go into
sysmerge and cause themselves major havoc.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.649 2011/08/02 15:52:04 deraadt Exp $
d1556 3
d1568 2
d1579 1
a1579 2
		echo -n "'${_zonepath}'"
		echo " is not a valid timezone on this system."
@


1.649
log
@Say "firmware files" instead of "firmwares".  It is so hard to be clear
when they are per-device packages which can containing more than one
firmware files..
from sthen
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.648 2011/07/28 19:11:33 halex Exp $
d1638 7
a1644 6
	if [[ -n "$SM_ARGS" || -n "$SM_ARGSX" ]]; then
		ask_yn "Merge the new etc/xetc install sets using sysmerge(8)?" no
		if [[ $resp == y ]]; then \
			/mnt/usr/sbin/chroot /mnt /usr/sbin/sysmerge $SM_ARGS $SM_ARGSX
		fi
	fi
@


1.648
log
@remove unneeded echo in rc.firsttime, since fw_update became more verbose

ok deraadt krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.647 2011/07/14 14:54:57 ajacoutot Exp $
d1646 1
a1646 1
update_firmwares() {
d1649 1
a1649 1
	ask_yn "$_get non-free firmwares on first boot?" no
d1993 1
a1993 1
	update_firmwares
@


1.647
log
@Fix a bug reported by "Remco" on misc@@ where sysmerge(8) would fail to
run when upgrading using a CD.
The reason was that at the time sysmerge(8) would run (and gets its
sets), the CD would be unmounted. We are now taking a different approach
and get the (x)etc sets anyway according to whether base and/or xbase
was selected and put them under /tmp in the chroot.
This way whatever upgrade method is chosen, the sets will always be in
a consistent location.

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.646 2011/07/09 17:53:58 halex Exp $
d1651 1
a1651 2
		echo "echo 'updating firmwares'; /usr/sbin/fw_update -v" \
			>> /mnt/etc/rc.firsttime
@


1.646
log
@move the 'updating firmwares' message into rc.firsttime rather than having
startup-like output in fw_update

"looks good" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.645 2011/07/09 03:14:53 deraadt Exp $
d1171 1
a1171 1
		# save arguments for sysmerge(8)
d1173 3
a1175 1
			SM_ETC="$_src/etc$VERSION.tgz"
d1177 3
a1179 1
			SM_XETC="$_src/xetc$VERSION.tgz"
d1638 1
a1638 1
	if [[ -n "$SM_ETC" || -n "$SM_XETC" ]]; then
a1640 6
			[[ X"$SM_ETC" != X"" ]] && \
				ftp $FTPOPTS -o /mnt/tmp/etc$VERSION.tgz -m "$SM_ETC" && \
				SM_ARGS="-s /tmp/etc$VERSION.tgz"
			[[ X"$SM_XETC" != X"" ]] && \
				ftp $FTPOPTS -o /mnt/tmp/xetc$VERSION.tgz -m "$SM_XETC" && \
				SM_ARGSX="-x /tmp/xetc$VERSION.tgz"
@


1.645
log
@delete the ld.so.hints file on the ramdisk, because I am worried about
future messes now that there are a few more dynamics programs running
in chroot.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.644 2011/07/09 03:12:24 ajacoutot Exp $
d1653 2
a1654 1
		echo '/usr/sbin/fw_update -v' >> /mnt/etc/rc.firsttime
@


1.644
log
@Unbreak sysmerge(8) with 'disk' install media.

reported by and ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.643 2011/07/09 01:20:37 halex Exp $
d1976 4
@


1.643
log
@Ask to install non-free firmwares at first boot

"go ahead" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.642 2011/07/06 23:38:41 halex Exp $
d1173 1
a1173 1
			SM_ARGS="-s $_src/etc$VERSION.tgz"
d1175 1
a1175 1
			SM_ARGSX="-x $_src/xetc$VERSION.tgz"
d1634 1
a1634 1
	if [[ -n "$SM_ARGS" || -n "$SM_ARGSX" ]]; then
d1636 7
a1642 1
		[[ $resp == y ]] && \
d1644 1
@


1.642
log
@"Tweak previous", aka

- Globals variable names should not start with an underscore
- Fetch {,x}etcNN.tgz from where we found the corresponding base
  (meaning it must not be the same place)

"reads ok" todd@@, ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.641 2011/07/06 20:02:16 halex Exp $
d1641 8
d1983 2
@


1.641
log
@As non-mp install.md's neither set NCPU, nor will have a bsd.mp,
we could as well pull the 'mv bsd.mp bsd' and the associated checks
out of there.

ok deraadt@@ "makes sense" todd@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.640 2011/07/06 15:35:15 ajacoutot Exp $
d1170 6
a1176 9

	# save arguments from the first installation source for sysmerge(8)
	if [[ -z "$FETCH_CMD" ]]; then
		FETCH_CMD="ftp $FTPOPTS -m"
		isin base$VERSION.tgz $GOTSETS && \
			_sm_args="-s $_src/etc$VERSION.tgz"
		isin xbase$VERSION.tgz $GOTSETS && \
			_sm_argx="-x $_src/xetc$VERSION.tgz"
	fi
d1634 1
a1634 1
	if [[ -n "$_sm_args" || -n "$_sm_argx" ]]; then
d1637 1
a1637 1
			/mnt/usr/sbin/chroot /mnt /usr/sbin/sysmerge $_sm_args $_sm_argx
d2003 2
@


1.640
log
@Add a new question to run sysmerge(8) at the end of an upgrade; defaults
to no.

The way it works is as follow:
- if baseXX was selected during the upgrade, etcXX will be added to the
args to pass to sysmerge(8)
- if xbaseXX was selected during the upgrade, xetcXX will be added to
the args to pass to sysmerge(8)
Note that etcXX and xetcXX will always be fetched from the first
installation source that was configured during the upgrade (it is most
likely that other sources contain site specific sets rather than the
base ones).
This option will not be available when using tape.

"read good" krw@@
prodded by and ok (with love) pirofti@@, ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.639 2011/07/04 20:59:05 halex Exp $
d72 1
d1970 6
@


1.639
log
@there is no need to do the rtsol check (whether to enable
net.inet6.ip6.accept_rtadv in sysctl.conf or not) on updates
as then we dont do any network config, so move it from
install.sub to install.sh

idea not rejected by IPv6-enabled bluhm@@
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.638 2011/04/18 16:52:10 thib Exp $
d1170 9
d1635 8
d1969 2
@


1.638
log
@Deprecate vnds in favour of svnds.

In effect, this removes the "old" vndX nodes, and renames
the svndX nodes to vndX.

Old svndX nodes will still continue to work though, for now.

Cleanup accordingly.

ok deraadt@@, todd@@
comments and ok on the man page bits from jmc@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.637 2011/04/17 20:57:10 krw Exp $
a1927 6
	fi

	if grep -qs '^rtsol' /mnt/etc/hostname.*; then
		sed -e "/^#\(net\.inet6\.ip6\.accept_rtadv\)/s//\1/" \
			/mnt/etc/sysctl.conf >/tmp/sysctl.conf
		cp /tmp/sysctl.conf /mnt/etc/sysctl.conf
@


1.637
log
@First crack at enabling the installation of a DUID version of
/etc/fstab, after asking user. Current default is existing behaviour.

Feedback & suggestions deraadt@@, halex@@, jsing@@, todd@@.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.636 2011/03/22 19:20:15 krw Exp $
d1633 1
a1633 1
#	5) are on a svnd device.
d1648 1
a1648 1
		[[ $_dev == @@(/dev/svnd*|\#*) || \
@


1.636
log
@Pay attention to result of amd64/i386 installboot(8).  Warn user
when they won't be able to boot the installed root disk.  Move
installboot invocation to just before congratulation on sucess is
emitted. Thus the installed partition will be 'complete' if it ever
is booted.

"go for it" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.635 2011/02/25 12:55:45 krw Exp $
d1994 1
@


1.635
log
@Silence a bit of error output when no ftplist can be downloaded.
Silence is golden. Problem seen and fix tested by guenther@@.

ok guenther@@ halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.634 2011/01/31 16:48:18 halex Exp $
a1952 2
	md_installboot $ROOTDISK

d1956 2
@


1.634
log
@- do not run fsck for fstab entries with zero or empty fs_passno
- ask for permission to continue upgrade if one or more mounts failed

Fixes issue noted by Peter Miller, who also tested the diff. Thanks!

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.633 2011/01/06 16:59:06 otto Exp $
d1337 1
a1337 1
	set -- $(sed "/^$_server_ip/x;\$!d;x" $SERVERLIST)
@


1.633
log
@rephrase fsck question and default to 'n'; ok krw@@ henning@@ stsp@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.632 2011/01/03 00:36:50 deraadt Exp $
a1640 1
#	5) leave out fs_freq and fs_passno fields.
d1668 1
a1668 2
		# 3) leave out fs_freq and fs_passno fields (i.e. $_rest).
		echo $_dev /mnt${_mp%/} $_fstype $_opt
d1682 1
a1682 1
	local _async=$1 _dev _mp _fstype _opt _rest _err _msg
d1689 3
a1691 3
		# Mount the filesystem. If the mount fails, exit.
		_msg=$(mount -v -t $_fstype $_async -o $_opt $_dev $_mp)
		_err=$?
d1693 1
a1693 6
		if [ $_err != 0 ]; then
			# In addition to the error message displayed by mount ...
			cat <<__EOT

FATAL ERROR:	Cannot mount filesystems. Double-check your configuration
		and restart the $MODE.
d1695 5
a1699 1
__EOT
d1702 1
a1702 1
	done </etc/fstab
d1719 3
a1721 3
# Preen all filesystems in /etc/fstab that have a /sbin/fsck_XXX,
# showing individual results, but skipping $ROOTDEV. This was already
# fsck'ed successfully.
d1725 1
a1725 1
	local _dev _mp _fstype _rest _fail _f
d1730 1
a1730 1
	while read _dev _mp _fstype _rest; do
d1735 1
@


1.632
log
@reduce the amount of cd'ing in the install script, since it sucks
to change the environment that functions assume they run in.  use
sub-shells or absolute paths when possible.
ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.631 2010/11/22 14:10:42 halex Exp $
d1730 1
a1730 1
	ask_yn "Force checking of non-root filesystems?" yes
@


1.631
log
@create devices for fstab entries that are using the disklabel UID notation too

ok krw@@, jsing@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.630 2010/11/19 19:33:13 halex Exp $
d1946 6
a1951 7
	(cd /mnt/dev
	sh MAKEDEV all
	# Make sure any devices we found during probe are created in the
	# installed system.
	for _dev in $(get_dkdevs) $(get_cddevs) $MTDEVS ; do
		sh MAKEDEV $_dev
	done
d1955 1
a1955 2
	(cd /; md_installboot $ROOTDISK)
	cd /
@


1.630
log
@- drop dhcp group from interfaces which did not go UP and got
  an ip address
- do the same on startup of the install/upgrade too
- do NOT do it unconditionally on all dhcp'd interfaces, since
  we use the group to retain state.

ok krw@@, deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.629 2010/11/18 23:25:46 deraadt Exp $
d507 1
a507 1
	(cd /dev && sh MAKEDEV $_dev) >/dev/null 2>&1
d1708 14
d1737 1
a1737 2
		_rest=${_dev#/dev/}
		[ ${_dev#/} == ${_dev} ] || makedev ${_rest%[a-p]} || continue
@


1.629
log
@do not run makedev for a uid; ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.628 2010/11/12 06:47:40 halex Exp $
d137 1
a137 1
	ifconfig \
d735 1
a735 1
	ifconfig $_ifs delete down
d2041 7
@


1.628
log
@- introduce quote() which prints its arguments quoted for sh/ksh parsing
- use the aformentioned function to properly quote the wireless config
  into /etc/hostname.$if

Now, if only /etc/netstart didn't screw up whitespace...

"I don't speak Swahili, so I'm going to have to trust you" deraadt@@
no objections from others, specifically so from krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.627 2010/11/05 00:23:05 halex Exp $
d1724 1
a1724 1
		makedev ${_rest%[a-p]} || continue
@


1.627
log
@Properly quote the wpakey argument. Fixes issue noted by tdm.

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.626 2010/11/04 06:39:19 deraadt Exp $
d107 10
d775 1
a775 1
	while [ -z $_nwid ]; do
d793 1
a793 1
		echo "nwid \"$_nwid\"" >>$_hn
d806 1
a806 1
					echo "nwkey \"$resp\"" >>$_hn
d814 1
a814 1
					echo "wpakey \"$resp\"" >>$_hn
@


1.626
log
@correct comment
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.625 2010/11/04 04:15:56 deraadt Exp $
d803 1
a803 1
				if ifconfig $_ifs wpakey $resp; then
@


1.625
log
@default to using all the IPs for ntp servers; ok krw henning
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.624 2010/10/18 22:47:07 deraadt Exp $
d1818 1
a1818 1
			# 'server' line with the first token in $resp as the
@


1.624
log
@delete a wasteful space
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.623 2010/10/18 22:45:28 halex Exp $
d1822 1
a1822 1
server $1
@


1.623
log
@allow configuration of 802.11 interfaces in the installer

based on a diff from damien@@
ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.622 2010/10/18 04:18:26 deraadt Exp $
d363 1
a363 1
 }
@


1.622
log
@no more misc set
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.621 2010/09/26 14:49:05 joshe Exp $
d641 4
d740 75
d1974 1
@


1.621
log
@Correctly parse new hw.disknames output.

Nicer fix from guenther@@, tested by editing install.sub while booted
into bsd.rd.

"please commit asap" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.620 2010/09/24 07:44:43 ajacoutot Exp $
d1929 1
a1929 1
for _set in base etc misc comp man game xbase xetc xshare xfont xserv site ; do
@


1.620
log
@Prefer -h instead over -L for symlink test.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.619 2010/09/23 13:30:15 jsing Exp $
d114 1
a114 1
	bsort $(for _n in $(sysctl -n hw.disknames); do echo "$_n " | sed "s/:.*$//"; done | sed -ne "$1")
@


1.619
log
@Teach the installer how to process the new hw.disknames output.

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.617 2010/08/08 21:06:06 krw Exp $
d1434 1
a1434 1
	if [[ -L /mnt/etc/localtime ]]; then
@


1.618
log
@Make future work in the installer easier by reducing the amount of
eval craziness in install_url().

ok krw@@
@
text
@d114 1
a114 1
	bsort $(for _n in $(sysctl -n hw.disknames); do echo "$_n "; done | sed -ne "$1")
@


1.617
log
@Revert auto-enabling of apm. Some security implications were not
fully appreciated, and no time to work through them.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.616 2010/08/08 17:02:14 krw Exp $
d1197 2
a1198 2
	local _server_ip_var=_${_url_type}_server_ip \
		_server_dir_var=_${_url_type}_server_dir
d1211 1
a1211 1
		eval $_server_ip_var=\${1%%/*}
d1219 1
a1219 2
		eval resp=\$$_server_ip_var
		ask_until "$_prompt" "$resp"
d1231 1
a1231 1
			eval $_server_ip_var=\${1%%/*}
d1235 1
a1235 1
			eval $_server_ip_var=\$resp
d1242 1
d1248 1
a1248 1
	set -- $(eval grep -s "^\$$_server_ip_var" $SERVERLIST | sed '$!d')
d1259 2
a1260 1
	eval $_server_dir_var=\$resp
d1288 1
a1288 1
	eval _url_base=\$_url_base\$$_server_ip_var/\$$_server_dir_var
d1308 1
a1308 1
	eval installedfrom=$_url_type://\$$_server_ip_var/\$$_server_dir_var
@


1.616
log
@Look for MD devices or assurance that apmd would be a useful thing to
run. If found, add "apmd_flags=" installed rc.conf.local. Suggested by
deraadt@@.

i386/apm test by kettenis@@.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.615 2010/08/05 10:45:32 halex Exp $
a70 1
#	MDAPMDEV    - '' assumed if not provided
a1756 6
	fi

	if [[ -n $MDAPMD ]]; then
		[[ $MDAPMD == y || -n $(egrep "$MDAPMD" /var/run/dmesg.boot) ]] && \
			echo "apmd_flags=		# enabled during install" \
				>>/mnt/etc/rc.conf.local
@


1.615
log
@Return the old behaviour of exiting if a mount fails rather than ignoring it

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.614 2010/08/02 11:21:35 krw Exp $
d71 1
d1758 6
@


1.614
log
@Suppress MAKEDEV warnings about 'unknown device' that can appear
during upgrades when /etc/fstab is using disklabel UID's to mount
partitions.

Feedback & trash elimination from halex@@

"That seems acceptable to me" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.613 2010/07/07 07:15:00 halex Exp $
d1605 1
a1605 1
		if ! $_e ; then
@


1.613
log
@zap chmod of /etc/pkg.conf since the installer itself will not put a username
or password in there, and any existing /etc/pkg.conf file will already have its
file mode preserved

"sure" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.612 2010/07/04 22:51:05 deraadt Exp $
d497 1
a497 1
	(cd /dev ; sh MAKEDEV $_dev || return 1 ; cd - >/dev/null)
@


1.612
log
@600 i mean.  hackathon took it's toll.  pointed out by halex
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.611 2010/07/04 22:12:38 deraadt Exp $
a1839 1
		chmod 600 /mnt/etc/pkg.conf
@


1.611
log
@the pkg.conf file should be mode 644, in case the user used a ftp
user:password (unlikely.. but)
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.610 2010/06/30 23:02:38 phessler Exp $
d1840 1
a1840 1
		chmod 0644 /mnt/etc/pkg.conf
@


1.610
log
@we don't need to add a localhost route for our hostname address, our arp
code is smarter these days.

a side effect of this was noticed by reyk@@

OK claudio@@ henning@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.609 2010/06/30 20:22:01 halex Exp $
d1840 1
@


1.609
log
@revert last ^D behaviour change

requested and well explained by krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.607 2010/06/30 00:23:02 halex Exp $
a998 2
	# Use loopback, not the wire.
	route -qn add -host `hostname` 127.0.0.1 >/dev/null
@


1.608
log
@make the installer quit when ^D is pressed at any prompt

ok deraadt@@
@
text
@d178 1
a178 1
	read -r resp?"$1 " || exit 1
d230 1
a230 1
	local _int _redo=0 _pid _fail
d235 1
a235 1
	read resp || _fail=1
a239 2
	elif [[ -n $_fail ]]; then
		exit 1
@


1.607
log
@handle whitespace around installpath in pkg.conf

feedback from espie@@ deraadt@@ krw@@
ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.606 2010/06/29 15:11:45 halex Exp $
d178 1
a178 1
	read -r resp?"$1 "
d230 1
a230 1
	local _int _redo=0 _pid
d235 1
a235 1
	read resp
d240 2
@


1.606
log
@After installing or updating from a public mirror, the installfrom=...
line in /etc/pkg.conf is set to point at the corresponding package
collection. The file is created if it does not exist.

discussed with deraadt@@ and espie@@
ok espie@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.605 2010/06/26 20:44:15 halex Exp $
d1839 2
a1840 2
		grep -v '^installpath=' /mnt/etc/pkg.conf 2>&- > /tmp/pkgconf
		print -r -- "installpath=$package_path" >> /tmp/pkgconf
@


1.605
log
@make http the default network install method rather than ftp

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.604 2010/06/21 02:54:46 krw Exp $
d1198 1
a1198 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _passwd
d1257 1
d1310 9
d1837 7
d1888 1
@


1.604
log
@Argh. Back out previous until correct diff found.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.603 2010/06/21 02:19:16 krw Exp $
d1497 1
a1497 1
	ifconfig netboot >/dev/null 2>&1 && : ${_d:=ftp}
d1501 1
a1501 1
	: ${_d:=ftp}
d1504 1
a1504 1
		for a in ftp http cd nfs tape disk; do
@


1.603
log
@Juggle code a bit and add a check so we don't attempt to create
a device from a UID name.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.602 2010/04/05 01:09:45 deraadt Exp $
d1622 2
a1623 3
		[[ $_dev == /dev/* ]] || continue
		[[ $_dev != /dev/$ROOTDEV ]] || continue
		[[ -f /sbin/fsck_$_fstype ]] || continue
d1636 1
a1636 1
	[[ $_fail == y ]] && exit
@


1.602
log
@purge extra spaces which make the media cry
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.601 2010/04/04 22:29:08 halex Exp $
d1622 3
a1624 2
		[ "$_dev" != /dev/"$ROOTDEV" ] || continue
		[ -f "/sbin/fsck_$_fstype" ] || continue
d1637 1
a1637 1
	[ "$_fail" ] && exit
@


1.601
log
@If the system time is off by more than 120 seconds from the TIME=nnn
supplied from ftplist.cgi, ask if the user wants to set it accordingly.

Idea from deraadt@@, feedback from sthen@@, guenther@@
ok deraadt@@, krw@@ (slightly different version)
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.600 2010/03/09 23:34:09 deraadt Exp $
a161 1
			
d602 1
a602 1
					! isin "$_vi" $_tags && break	
d1250 1
a1250 1
	set -- $(eval grep -s "^\$$_server_ip_var" $SERVERLIST | sed '$!d') 
d1504 1
a1504 1
		for a in ftp http cd nfs tape disk; do 
@


1.600
log
@correctly choose the files in a directory, even if it is a symbolic link
also don't pull extra goop into the selector (do not use ls -l)
diff from halex
ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.599 2010/03/09 15:06:36 krw Exp $
d1151 12
a1162 4
	# ftp.openbsd.org == 129.128.5.191 and will remain at
	# that address for the foreseeable future.
	ftp $FTPOPTS -a -o - "http://129.128.5.191/cgi-bin/ftplist.cgi?path=$FTPSETDIR" \
		2>/tmp/ftplisterr > $SERVERLISTALL & ftppid=$!
d1167 1
a1167 1
	(sleep 12; kill -INT $ftppid >/dev/null 2>&1) &
d1184 9
d1877 1
@


1.599
log
@Tweak default set selection so X sets are in the default list when
/etc/X11 already exists. So if you install X to a headless machine
and then upgrade you don't have to remember to add X sets.

Idea from landry@@ who installs to a lot of ports boxen.

ok halex@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.598 2010/03/04 02:07:55 krw Exp $
d1309 1
a1309 1
	install_files "file://$_dir" "$(ls -l $_dir)"
@


1.598
log
@Gracefully handle trailing '/'s when asking for [sub]Timezones.
i.e. ignore them all. Problem pointed out by Sebastian Rother. More
script discipline and voodoo from halex@@.

ok halex@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.597 2010/03/02 01:24:50 krw Exp $
d1020 4
a1897 4
	if [[ -z $DISPLAY ]]; then
		# If we have no displays, skip the X sets
		isin $_set xbase xetc xshare xfont xserv site && continue
	fi
@


1.597
log
@The -stable default ftp directory should not be snapshots/$ARCH.
The normal release directory is a less surprising default.

Suggested by henning@@ a while ago. Working script incantation
courtesy of several cluebats from halex@@. No strong opposition.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.596 2010/01/13 00:15:26 todd Exp $
a1420 2
		_zonepath=""

d1422 6
a1427 6

		if [[ $resp = "?" ]]; then
			grep -v /. $_zonefile | showcols
			continue
		fi
		_zonepath=$_zonepath$resp
d1432 1
@


1.596
log
@match the 'use 127.0.0.1/8 instead of 127.0.0.1 for clarity' change in netstart
sure henning@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.595 2010/01/03 04:25:42 krw Exp $
d1870 2
a1871 2
CURRENT=$(scan_dmesg "/^OpenBSD $VNAME\([^ ]*\).*$/s//\1/p")
[[ -n $CURRENT ]] && FTPSETDIR=snapshots/$ARCH
@


1.595
log
@Since we can now recognize new disks as they appear, loop waiting
for a root disk to appear if no disks are initially found.

Diff & ok from halex@@, idea from deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.594 2009/07/23 00:30:03 krw Exp $
d887 1
a887 1
	ifconfig lo0 inet 127.0.0.1
@


1.594
log
@Don't use the presence of /etc/fstab to determine if all filesystems
are umount'd at the start of install/upgrade. As halex@@ pointed out
'umount -af' doesn't actually use /etc/fstab, so just always do it.
Fixes situations where bailing out of install/upgrade before
/etc/fstab was created meant filesystems were not umount'd and
restarting the install/upgrade would fail.

Noticed & prodded deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.593 2009/07/14 23:45:16 krw Exp $
d1956 5
a1960 4
[[ -n $(get_dkdevs) ]] || { echo "No disks found." ; exit ; }

ask_which "disk" "is the root disk" '$(get_dkdevs)'
[[ $resp == done ]] && exit
@


1.593
log
@Add a couple of missing ';;'s in case statements. Both are just
before the 'esac' so there should be no functional change, but
consistancy feels so good.

ok halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.592 2009/07/09 23:45:20 deraadt Exp $
d1917 1
a1917 2
[[ -f /etc/fstab ]] && umount -af 1>/dev/null 2>&1
umount /mnt 1>/dev/null 2>&1
@


1.592
log
@The cd install method is called cd, not cdrom.  This gets told to the
back end, which feeds it back to us next time, and since we don't know
what it means... we ignore it.  That is dumb.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.591 2009/07/06 22:11:11 krw Exp $
d975 1
d1222 1
@


1.591
log
@Fix handling of install info saving and fetching. May still be some
interesting behaviour with v6 '[]' ftp syntax, but best we can do
for 4.6. Testing and tweaking from halex@@ and phessler@@, and a host
of others in various previous versions.

ok halex@@ deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.590 2009/07/03 00:42:47 deraadt Exp $
d1497 1
a1497 1
		c*|C*)	isin cd $_locs && install_cdrom && method=cdrom ;;
@


1.590
log
@jmc becomes upset when nouns are used as verbs; via krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.589 2009/07/01 19:12:53 deraadt Exp $
d1177 1
a1177 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _passwd _default
d1189 1
a1189 1
		sed -n "s,^${_url_type}://"'\([[A-Za-z0-9\:_][]A-Za-z0-9:._-]*/[^ 	]\),\1,p' \
a1192 1
		_default=$1
a1212 1
			echo "Using	$*"
a1213 2
			eval $_server_dir_var=\${1#*/}/\$FTPSETDIR
			_default=$1
a1217 5
			if [[ $resp = "${_default%%/*}" ]]; then
				eval $_server_dir_var=\${_default#*/}/\$FTPSETDIR
			else
				eval $_server_dir_var=pub/OpenBSD/\$FTPSETDIR
			fi
d1224 13
a1236 2
	# Get server directory
	eval resp=\$$_server_dir_var
d1286 1
a1286 1
	eval installedfrom=$_url_type://\$$_server_ip_var/\${$_server_dir_var%\"/\$FTPSETDIR\"}
@


1.589
log
@Do not default to disk installs;  ftp or cdrom covers 99% of users; ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.588 2009/06/29 23:56:49 deraadt Exp $
d327 1
a327 1
		ask_yn "Since you setup a user, disable sshd(8) logins to root?" yes
@


1.588
log
@Revert 1.558, making the installer (in the worst case) use the base-set
localtime zone for decision making.  But when we get into that situation,
also skip timezone manipulation the first time (before base install) and
defer it to after the base install (since that is the only time that file
exists).  Complicated?  It could be worse..
ok krw halex
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.587 2009/06/19 00:42:04 krw Exp $
d1478 1
a1478 1
	: ${_d:=disk}
@


1.587
log
@Don't create bogus hosts file entries if too few parameters are
passed to addhostent(). Noticed by sthen@@ and jsing@@.

ok halex@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.586 2009/06/12 08:25:57 halex Exp $
d1401 5
d1412 3
a1414 1
	: ${TZ:=GMT}
@


1.586
log
@make the interrupt handler in install.sub print a linefeed and also make
sure to enable echoing of the input to the tty

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.585 2009/06/12 03:25:24 krw Exp $
d507 2
@


1.585
log
@Avoid vlan explosion reported by deraadt@@, sthen@@ and jsing@@ when
^C'ing and restarting the install script. When looking for the next
vlan to offer, stop at the first unconfigured one rather than the
first non-existant one.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.584 2009/06/11 04:21:27 deraadt Exp $
d200 2
a201 1
	trap '>&- && kill -KILL $cppid 2>&-; exit' INT EXIT TERM
@


1.584
log
@krw must not have tested his dhcp change from a scratch boot
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.583 2009/06/11 02:28:49 krw Exp $
d566 4
a569 1
	while ifconfig vlan$_vl >/dev/null 2>&1; do
d572 1
@


1.583
log
@Make 'dhcp' the default answer only if no other interface has
been configured to use dhcp. Requested by deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.582 2009/06/10 07:03:29 deraadt Exp $
d746 1
a746 1
		ifconfig dhcp >/dev/null 2>&1 || ${_addr:=dhcp}
@


1.582
log
@A tighter printing format for the SHA256 hashes.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.581 2009/06/10 07:01:25 deraadt Exp $
d743 5
a747 1
	[[ -x /sbin/dhclient ]] && { _prompt="or 'dhcp' " ; : ${_addr:=dhcp} ; }
@


1.581
log
@On systems without keyboard setting, the hostname choice had no blank line
above it.  It disturbed me deeply.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.580 2009/06/10 01:28:10 krw Exp $
d1057 2
a1058 2
				echo "The SHA256 hash for $_f did not match what this bsd.rd expected:"
				cat /tmp/h
@


1.580
log
@Count existing vlan's so restarting the script doesn't lose track of
which vlan to create next.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.579 2009/06/10 00:53:40 deraadt Exp $
a78 1
		echo
a83 1
		echo
d1903 1
@


1.579
log
@when sets cannot be found, do the 4-space indent dance to make the
failure list a whole lot prettier.
ok todd
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.578 2009/06/10 00:52:48 deraadt Exp $
d566 5
@


1.578
log
@the interface list should not be sorted.  use the order that ifconfig
chooses, since that is the order people are used to.  krw remembered
some weird behaviour, but i tested and could not find it
ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.577 2009/06/09 10:11:21 halex Exp $
d538 1
a538 1
		done|showcols|sed 's/^/    /'
d994 1
a994 1
	local _src=$1 _files=$2 _f _sets _get_sets _n
d1014 5
a1018 1
		for _n in $THESETS; do echo $_n; done | showcols
@


1.577
log
@Update the user input routines to (re-evaluate and) redraw the
question if dmesg changes are detected. The password reading
routines are not subject to these changes at this point.

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.576 2009/06/09 03:33:49 krw Exp $
d129 1
a129 1
	bsort $(ifconfig \
d131 1
a131 1
		| sed -ne 's/^\(.*\):.*/\1/p')
@


1.576
log
@Tighten and tweak keyboard question. Use 'layout' instead of 'type'
as suggested by mk@@. Shortened verbiage allows us to bring back 'L'
as a way to list the alternate layouts, as pointed out by Andr?s
on tech@@. On some keyboards finding the '?' can be a challenge
before the layout is set.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.575 2009/06/07 03:52:29 krw Exp $
d135 1
a135 1
	ask_which "$1" "contains the $MODE media" "$2"
d160 5
a164 1
		ask_which "$_dev partition" "has the $MODE sets" "$_parts"
d187 71
a269 1
	set -o noglob
d273 1
a273 11
		read resp
		case $resp in
		!)	echo "Type 'exit' to return to install."
			sh
			;;
		!*)	eval "${resp#?}"
			;;
		*)	: ${resp:=$_default}
			break
			;;
		esac
a274 1
	set +o noglob
d374 3
d379 1
a379 11
	local _name=$1 _query=$2 _list=$3 _def=$4

	set -- $_list
	if (( $# < 1 )); then
		resp=done
		return
	fi
	: ${_def:=$1}

	# Eliminate extraneous (especially trailing) whitespace in _list.
	_list="$*"
d385 16
a400 1
		ask "Available ${_name}s are: $_list.\nWhich one $_query? (or 'done')" "$_def"
d404 1
a404 1
		isin "$resp" $_list done && break
a566 3
	# Select the initial default interface.
	_p=$(ifconfig netboot 2>/dev/null | sed -n '1s/:.*//p')

a569 1
		_ifdevs=$(get_ifdevs)
d571 2
a572 1
			"$_ifdevs" "$_p"
d596 1
d1287 1
a1287 1
	get_drive "CD-ROM" "$(get_cddevs)" || return
d1296 2
a1297 1
		get_drive "disk" "$(get_dkdevs)" || return
d1329 1
a1329 1
	get_drive "tape drive" "$MTDEVS" || return
d1929 1
a1929 1
ask_which "disk" "is the root disk" "$(get_dkdevs)"
@


1.575
log
@More tersification. Fixes verbiage issue reported by jdixon@@ on
icb.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.574 2009/06/05 05:43:42 halex Exp $
d75 1
a75 1
	local _tables
d84 1
a84 1
		_tables=$(bsort $(kbd -l | egrep -v "^(user|tables|encoding)"))
d87 1
a87 1
			ask "Choose your keyboard type if it is nationalized? ('?' for list)" "default"
d89 1
a89 1
			"?")	echo "Major tables: $_tables" ;;
@


1.574
log
@add some hostname sanity check
honour the path part of the suggested hostname/path combo

"please commit" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.573 2009/06/04 02:27:48 sthen Exp $
d1820 7
@


1.573
log
@count nifs in enable_network(); allows ftplist to be fetched in the
upgrade case too.  ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.572 2009/06/03 23:44:53 krw Exp $
d1090 1
a1090 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _passwd
d1102 2
a1103 1
		sed -n "s,^${_url_type}://,,p" $SERVERLISTALL > $SERVERLIST
d1106 1
d1130 1
d1133 7
a1139 1
		*)	eval $_server_ip_var=\$resp
d1142 1
@


1.572
log
@Add hw.machine and kern.osrelease to install media sysctl. Using
these rather than hard coded variables allows the rationalization
of the greeting by moving it into dot.profile. Whack at dot.profile
a lot. Eliminate the 'Proceed with ...' question as unneeded.
Eliminate welcome().

ok deraadt@@ "I like" todd@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.571 2009/06/03 06:07:37 halex Exp $
d809 2
@


1.571
log
@make sure timezone and sets location gets sane defaults

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.570 2009/06/03 00:30:31 krw Exp $
a96 35
welcome() {
	cat <<__EOT

Welcome to the $OBSD $MODE program.

This program will $MODE OpenBSD. At any prompt except password prompts you
can escape to a shell by typing '!'. Default answers are shown in []'s and
are selected by pressing RETURN.  At any time you can exit this program by
pressing Control-C, but exiting during an $MODE can leave your system in an
inconsistent state.

__EOT

	if [[ $MODE == upgrade ]]; then
		cat <<__EOT
NOTE: Once your system has been upgraded, you must manually merge any
changes to files in the 'etc' set into the files already on your system.
sysmerge(8) can help.

__EOT
	fi

	ask_yn "Proceed with $MODE?"
	if [[ $resp == n ]]; then
		cat <<__EOT
Remove your install media (if any), and enter 'reboot' at the command
prompt to return to your original OS.

__EOT
		exit
	fi

	echo "Cool! Let's get to it."
}

a1741 3
VERSION=45

VNAME="$(( $VERSION / 10 )).$(( $VERSION % 10 ))"
a1744 1
OBSD="OpenBSD/$ARCH $VNAME"
a1807 3

# Introduce ourselves.
welcome
@


1.570
log
@Only need to umount once on restarting. Force umounts in case of
restarting. No need to ask for verbose umount output since we send
it all to /dev/null. Make sure we start in '/', lest we were restarted
while exploring the installed/upgraded filesystems.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.569 2009/06/02 23:53:34 krw Exp $
d1339 1
a1339 1
		[[ -n $_tz ]] && TZ=$_tz
d1407 6
@


1.569
log
@Nuke sissy verbiage about losing data. No more special casing for
restarted installs/upgrades. They should just work the same as first
attempts except for presenting some remembered info as default
answers.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.568 2009/06/02 22:44:27 krw Exp $
d1838 3
a1840 2
[[ -f /etc/fstab ]] && umount -av 1>/dev/null 2>&1
umount -v /mnt 1>/dev/null 2>&1
@


1.568
log
@Bring interface list handling up to disk and cd behaviour of being
able to detect added/deleted interfaces.

Tweak vlan handling. No longer delete interfaces as they are
configured so you can choose to reconfigure them.

ok deraadt@@, ksh tweaks from halex@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.567 2009/06/02 10:35:26 halex Exp $
a97 2
	local _q

d110 1
a110 2
	case $MODE in
	upgrade)
a111 3
IS YOUR DATA BACKED UP?  Upgrades are never as simple as they seem.  While
carefully designed, this process could lead to SIGNIFICANT data loss.

d113 2
a114 2
changes to files in the 'etc' set into the files already on your system,
perhaps using the sysmerge(8) command.
d117 1
a117 20
		_q="Proceed with upgrade?"
		;;

	install)
		if [ -f /etc/fstab ]; then
			cat <<__EOT
You seem to be trying to restart an interrupted installation! You can skip
the disk preparation steps and continue, or you can reboot and start over.

__EOT
			_q="Skip disk initialization?"
		else
		cat <<__EOT
If you change your mind and do not want to install, type Control-C now
and then type 'reboot' at the command prompt.
__EOT
			return
		fi
		;;
	esac
d119 1
a119 1
	[[ -n $_q ]] && ask_yn "$_q"
a121 1

d124 1
@


1.567
log
@strip /<version>/<arch> part from the install url before feeding it back
to the ftplist server

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.566 2009/06/02 08:59:22 halex Exp $
d189 3
a191 3
	ifconfig \
		| egrep -v '^[[:space:]]|(bridge|enc|gif|gre|lo|pflog|pfsync|ppp|sl|tun|vlan)[[:digit:]]+:' \
		| sed -ne 's/^\(.*\):.*/\1/p'
d554 1
a554 1
	local _IFDEVS=$IFDEVS _oifs _ifs _name _hn _vl _vli _vd _vi _p
d556 2
a557 7
	# Check if the kernel supports vlans, and if so, offer it up
	ifconfig $vlan99 destroy >/dev/null 2>&1
	if ifconfig vlan99 create >/dev/null 2>&1; then
		ifconfig vlan99 destroy
		_vli=0
		_vl="vlan$_vli"
	fi
d559 4
a562 9
	# Select the default interface
	if ifconfig netboot >/dev/null 2>&1; then
		_p=$(ifconfig netboot | sed -ne '1s/:.*//p')
	else
		set -- $IFDEVS
		_p=$1
	fi

	while [[ -n $_IFDEVS ]]; do
d564 1
a564 1
			"$_IFDEVS $_vl" "$_p"
d573 22
a594 10
		if [[ $resp == $_vl ]]; then
			_vi=$_vli
			[[ $_vli == 0 ]] && _vi=1
			set -- $IFDEVS
			ask "Which interface:tag should $_vl be on?" ${1}:$_vi
			_oifs=$IFS
			IFS=: ; set -- $resp
			_vd=$1
			_vi=$2
			IFS=$_oifs
d597 3
a599 2
			if ! isin $_vd $IFDEVS; then
				echo "Invalid interface choice $_vd"
d603 3
a605 3
			# Validate range of $_vi as 1-4095
			if (( _vi < 1 || _vi > 4095 )); then
				echo "Invalid vlan tag $_vi"
d610 3
a612 2
			# make sure it is up
			echo "up" >> /tmp/hostname.$_vd
d615 3
a617 3
			# Make sure a hostname.$_vl is created with this info
			ifconfig $_vl destroy >/dev/null 2>&1
			ifconfig $_vl vlan $_vi vlandev $_vd
d619 2
a620 7

			# Now we can act like it is a real interface
			IFDEVS="$IFDEVS $_vl"

			# Next time around, offer up another vlan to modify
			: $(( _vli += 1 ))
			_vl="vlan$_vli"
d626 2
a627 1
		[[ $_IFDEVS != $IFDEVS ]] && ask "Symbolic (host) name for $_ifs?" $resp
d633 6
a638 3
		[[ -f $_hn ]] && chmod 640 $_hn && _IFDEVS=$(rmel $_ifs $_IFDEVS)
		let nifs=nifs+1
		_p=done
a1821 1
IFDEVS=$(get_ifdevs)
d1880 1
a1880 3
	if [[ $nifs != 0 ]]; then
		startftplist
	fi
@


1.566
log
@some sed cleanup and killing a cat

very similar diff ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.565 2009/06/02 03:21:31 halex Exp $
d1242 1
a1242 1
	eval installedfrom=$_url_type://\$$_server_ip_var/\$$_server_dir_var
@


1.565
log
@make the eval's resistant to rouge user input
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.564 2009/05/31 17:57:27 deraadt Exp $
d1157 2
a1158 2
		sed -ne "/^${_url_type}:\/\//s///p" < $SERVERLISTALL > $SERVERLIST
		set -- $(sed -ne "1p" $SERVERLIST)
d1172 1
a1172 1
			cat -n $SERVERLIST | less -XE
d1178 1
a1178 1
			set -- $(sed -ne "${resp}p" $SERVERLIST)
@


1.564
log
@If xdm was requested, but then xbase was not installed, don't try to
enable it.
ok halex
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.563 2009/05/31 03:34:15 krw Exp $
d264 1
a264 1
		!*)	eval ${resp#?}
d1146 2
d1159 1
a1159 1
		eval _${_url_type}_server_ip=${1%%/*}
d1167 1
a1167 1
		eval resp=\$_${_url_type}_server_ip
d1181 2
a1182 2
			eval _${_url_type}_server_ip=${1%%/*}
			eval _${_url_type}_server_dir=${1#*/}/$FTPSETDIR
d1185 1
a1185 1
		*)	eval _${_url_type}_server_ip=$resp
d1192 1
a1192 1
	eval resp=\$_${_url_type}_server_dir
d1194 1
a1194 1
	eval _${_url_type}_server_dir=$resp
d1222 1
a1222 1
	eval _url_base=$_url_base\$_${_url_type}_server_ip/\$_${_url_type}_server_dir
d1242 1
a1242 1
	eval installedfrom=$_url_type://\$_${_url_type}_server_ip/\$_${_url_type}_server_dir
@


1.563
log
@Fix sane_sets. Set default set source to last successful source
until sane_install succeeds, then make it 'done'. Nuke a useless
bleet when harassing user.

Mostly requested by deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.562 2009/05/31 00:03:29 deraadt Exp $
d1665 1
a1665 1
	if [[ $xdm == y ]]; then
@


1.562
log
@Ask the cgi to remember the install method too, and as a result, this
makes two more questions only need a return.
ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.561 2009/05/31 00:02:50 deraadt Exp $
d1395 1
a1395 1
# Check with the user that missing required sets were deliberately skipped.
d1397 1
a1397 1
	local _s _m
d1401 3
a1403 7
		# If sane_install has an argument, be quiet
		if [[ -n $1 ]]; then
			echo "'$_s' was not installed."
			ask_yn "Are you *SURE* your $MODE is complete without '$_s'?"
		else
			resp=n
		fi
d1415 1
a1415 1
	local _d=disk _dd _locs="disk ftp http"
d1419 5
a1423 2
	[[ -n $(get_cddevs) ]] && { _locs="cd $_locs" ; _d=cd ; }
	ifconfig netboot > /dev/null 2>&1 && _d=ftp
d1426 1
a1426 4
	if [[ -s $SERVERLISTALL ]]; then
		_dd=$(sed -ne '/^method=/s/method=//p' <$SERVERLISTALL)
		[[ -n $_dd ]] && _d=$_dd
	fi
d1431 2
a1432 1
		[[ -z $DEFAULTSETS ]] && _d=done
d1437 1
a1437 1
		c*|C*)	isin "cd" $_locs && install_cdrom && method=cdrom ;;
d1439 4
a1442 4
		f*|F*)	isin "ftp" $_locs && install_url ftp && method=ftp ;;
		h*|H*)	isin "http" $_locs && install_url http && method=http ;;
		n*|N*)	isin "nfs" $_locs && install_nfs && method=nfs ;;
		t*|T*)	isin "tape" $_locs && install_tape && method=tape ;;
a1443 3

		sane_install quiet
		[ $? -eq 0 ] && _d=done
@


1.561
log
@Change the order of the installer questions again, because it is better.
hostname, network, root password, misc, timezone, and then the disks
and sets.
ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.560 2009/05/30 20:40:59 deraadt Exp $
d1401 7
a1407 1
		ask_yn "'$_s' was not installed.\nAre you *SURE* your $MODE is complete without '$_s'?"
d1419 1
a1419 1
	local _d=disk _locs="disk ftp http"
d1427 4
d1440 6
a1445 6
		c*|C*)	isin "cd" $_locs && install_cdrom ;;
		d*|D*)	install_disk ;;
		f*|F*)	isin "ftp" $_locs && install_url ftp ;;
		h*|H*)	isin "http" $_locs && install_url http ;;
		n*|N*)	isin "nfs" $_locs && install_nfs ;;
		t*|T*)	isin "tape" $_locs && install_tape ;;
d1447 3
@


1.560
log
@Defer talking to the ftpinstall cgi until a fair bit later, so that we can
also tell it the timezone.  As a result, this will also work for non-url
based installs.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.558 2009/05/30 18:17:16 deraadt Exp $
a1363 1
	echo
d1866 8
d1884 1
a1885 7
	donetconfig

	if [[ $nifs == 0 ]]; then
		set_timezone /var/tzlist
	else
		startftplist
	fi
@


1.559
log
@these scripts should use tabs because 4 spaces wastes 3 chars of media space
@
text
@d1239 2
a1240 7
	# Tell the FTP server what location we used... so it can perform magic
	if [[ -s $SERVERLIST ]]; then
		eval _url_base=$_url_type://\$_${_url_type}_server_ip/\$_${_url_type}_server_dir
		ftp $FTPOPTS -a -o - \
			"http://129.128.5.191/cgi-bin/ftpinstall.cgi?install=$_url_base" \
			>/dev/null 2>&1 &
	fi
@


1.558
log
@The TZ question can be asked at 3 different places.  In the "media which
lacks the names but we have net" case, we end up with installed sets.
Remove the code which guesses the TZ from the sets just installed.  We
now default to GMT, unless the ftplist.cgi made a better guess.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.557 2009/05/29 00:46:41 deraadt Exp $
d1713 1
a1713 1
			    "9600 19200 38400 57600 115200" $CSPEED
@


1.557
log
@Remember to copy the modified ntpd.conf back to /etc
problem spotted by Thomas Pfaff
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.556 2009/05/28 02:34:56 krw Exp $
a1359 5

	if [[ -L /mnt/etc/localtime ]]; then
		TZ=$(ls -l /mnt/etc/localtime 2>/dev/null)
		TZ=${TZ#*${_zoneroot#/mnt}}
	fi
@


1.556
log
@Get the list of disks or cds whenever required rather than once at
startup. This means you can plugin USB disks or cds after the install
has started and you will see the new device the next time the list
is shown. The wonders of using sysctl.

'excellent' miod@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.555 2009/05/24 00:17:37 halex Exp $
d1659 1
@


1.555
log
@Make select_sets insensitive to rougue user input and
allow [+-] prefixing per whitespace separated parameter.

This makes it possible to write e.g.

  * -x* +xbase* done

The previous way of entering multiple sets separated by
pipes will no longer work.

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.554 2009/05/19 07:46:03 halex Exp $
d180 8
d1266 1
a1266 1
	get_drive "CD-ROM" "$CDDEVS" || return
d1275 1
a1275 1
		get_drive "disk" "$DKDEVS" || return
d1428 1
a1428 1
	[[ -n $CDDEVS ]] && { _locs="cd $_locs" ; _d=cd ; }
d1754 1
a1754 1
	for _dev in $DKDEVS $CDDEVS $MTDEVS; do
a1818 2
DKDEVS=$(scan_disknames "${MDDKDEVS:-/^[sw]d[0-9][0-9]* /s/ .*//p}")
CDDEVS=$(scan_disknames "${MDCDDEVS:-/^cd[0-9][0-9]* /s/ .*//p}")
d1897 1
a1897 2
set -- $DKDEVS
(( $# == 0 )) && { echo "No disks found." ; exit ; }
d1899 1
a1899 1
ask_which "disk" "is the root disk" "$DKDEVS"
@


1.554
log
@refine login name and full user name sanity check

spotted by miod@@
feedback and ok deraadt@@, krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.553 2009/05/19 02:56:45 deraadt Exp $
a516 1
		_action=
d520 1
a520 7
		ask "Set name? (or 'abort' or 'done')" done
		case $resp in
		abort)	_selected=
			break ;;
		done)	break ;;
		-*)	_action=rmel ;;
		esac
d522 10
a531 7
		: ${_action:=addel}
		resp=${resp#+|-}

		case $resp in
		"")	continue ;;
		all)	resp=* ;;
		esac
d533 3
a535 7
		# Use @@($resp) rather than just $resp to protect
		# against silly user input that might cause syntax
		# errors.
		for _f in $_avail; do
			eval "case $_f in
			@@($resp)) _selected=\`$_action $_f \$_selected\` ;;
			esac"
d538 2
@


1.553
log
@shorten ftp server install prompt; ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.552 2009/05/17 04:59:43 deraadt Exp $
d295 2
a296 1
		[a-z]*([a-z0-9])) break ;;
d301 10
a310 1
	ask "Full user name for $user?" $user
@


1.552
log
@add a period; Stephan A. Rickauer
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.551 2009/05/17 04:41:46 deraadt Exp $
d1142 1
a1142 1
		_prompt="Server? (IP address, hostname, list#, 'done' or '?')"
d1148 1
a1148 1
		_prompt="Server? (IP address, hostname or 'done')"
@


1.551
log
@noone needs to use halt.  reboot will do
discussed with jmc
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.550 2009/05/17 00:43:13 deraadt Exp $
d201 1
a201 1
	[[ $# == 0 ]] && { echo "No filesystems found on $_dev" ; return 1 ; }
@


1.550
log
@do not hardcode the version into the script; ok krw miod
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.549 2009/05/16 08:51:57 halex Exp $
d137 1
a137 1
and then type 'reboot' or 'halt' at the command prompt.
d1759 1
a1759 1
To boot the new system, enter "reboot" or "halt" at the command prompt.
d1763 1
a1763 1
using the "mail" command.
@


1.549
log
@cleanup of set_timezone resulting in byte shaving and fixing an issue where
posixright would apprear in the listing of posix/ while it is actually its
sibling
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.548 2009/05/15 02:00:36 krw Exp $
d1803 1
a1803 1
CURRENT=$(scan_dmesg '/^OpenBSD 4.5\([^ ]*\).*$/s//\1/p')
@


1.548
log
@Since _defdsk is now only set to "", just nuke it.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.547 2009/05/15 01:40:42 krw Exp $
d1369 1
a1369 1
			sed -n "/^$_zonepath/{s,^$_zonepath/,,;/\/.*\//d;/\/./d;/./p;}" $_zonefile|showcols
d1376 1
a1376 1
			_zsed=$(echo $_zonepath|sed 's/\//\\\//g')
d1379 1
a1379 1
			"?")	sed -n "/^$_zsed/{s,^$_zsed/,,;/\/.*\//d;/\/./d;/./p;}" $_zonefile|showcols;;
@


1.547
log
@Zap tedious verbiage announcing disk configuration will start soon.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.546 2009/05/15 01:31:01 deraadt Exp $
a1888 1
(( $# > 1 )) && _defdsk=
d1890 1
a1890 1
ask_which "disk" "is the root disk" "$DKDEVS" "$_defdsk"
@


1.546
log
@If we have more than one disk, we don't know what the user wants but done
is probably not the right default answer.  ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.545 2009/05/12 09:05:54 halex Exp $
a1886 10
if [[ $MODE == install && ! -f /etc/fstab ]]; then
	cat <<__EOT

You will now initialize the disk(s) that OpenBSD will use. To enable all
available security features you should configure the disk(s) to allow the
creation of separate filesystems for /, /tmp, /var, /usr, and /home.

__EOT
fi

@


1.545
log
@Cleanup and shave some bytes in hextodec()

ok krw@@, "If that works, commit it" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.544 2009/05/09 22:41:01 martynas Exp $
d1899 1
a1899 1
(( $# > 1 )) && _defdsk=done
@


1.544
log
@- ask_yn defaults to no
- remove trailing whitespace
ok krw@@, sthen@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.543 2009/05/09 21:34:23 deraadt Exp $
d697 2
a698 2
	for _b in $(echo $1 | sed -e 's/0x\(..\)\(..\)\(..\)\(..\)/\1 \2 \3 \4/'); do
		_d=${_d}.$((16#$_b))
d700 1
a700 1
	echo $_d | sed -e 's/^\.//'
@


1.543
log
@Read the netmask in dotted decimal notation, even though ifconfig does
the wrong thing.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.542 2009/05/09 19:33:35 deraadt Exp $
d1383 1
a1383 1
		
d1679 1
a1679 1
	ask_yn "Start ntpd(8) by default?" no
@


1.542
log
@IFS dance not needed
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.541 2009/05/09 19:11:11 deraadt Exp $
d693 10
d711 1
a711 1
			_addr=$2; _mask=$3
@


1.541
log
@Pretty up the failed sets message
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.540 2009/05/08 18:39:57 deraadt Exp $
d958 1
a958 1
	local _src=$1 _files=$2 _f _sets _get_sets _oifs _n
a977 1
		_oifs=$IFS; IFS=" "
a978 1
		IFS=$_oifs
@


1.540
log
@If sshd is enabled, and a user is setup, as if sshd should turn off
sshd's PermitRootLogin
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.539 2009/05/08 14:32:52 deraadt Exp $
d958 1
a958 1
	local _src=$1 _files=$2 _f _sets _get_sets
d975 7
a981 7
		cat <<__EOT
No $OBSD sets were found at

	$(echo $_src | sed -e 's/\(^ftp:\/\/[^/]*\)\(:[^/]*\)\(@@.*\)/\1\3/')

Set names are: $THESETS
__EOT
@


1.539
log
@improve user_setup by only accepting good usernames; idea from alexander
hall.  also improve the 2nd question designed for people not paying
attention; ok todd
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.538 2009/05/08 05:47:38 deraadt Exp $
d305 6
d1622 5
@


1.538
log
@use $nifs instead of hostname.* existance to determine if we should get ftplist
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.537 2009/05/08 03:01:42 deraadt Exp $
d285 4
a288 4
	ask "Setup a user? (enter a lower-case loginname, or 'no')" no
	case $resp in
	n|no)	return ;;
	y|yes)	ask "No really, what is the lower-case loginname, or 'no'?"
d291 8
a298 3
		esac ;;
	esac

@


1.537
log
@Since our order is now net, disk, TZ, we can increase the ftp timeout
up to 12 seconds more comfortably
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.536 2009/05/07 03:43:02 todd Exp $
d1081 1
a1081 1
	ls /tmp/hostname.* /mnt/etc/hostname.* >/dev/null 2>&1 && return
@


1.536
log
@o use 'ls -C' to speed and simplify both sets viewing and timezone selection
o use a tzlist instead of a tzdir
o as a bonus, sets lists are now sorted top-down instead of left-right
o use stty to calculate 4char padding surrounding sets lists
collaboration with Alexander Hall halex@@
ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.535 2009/05/06 22:48:03 sthen Exp $
d1088 1
a1088 1
	# If the ftp process takes more than 9 seconds, kill it
d1091 1
a1091 1
	(sleep 9; kill -INT $ftppid >/dev/null 2>&1) &
@


1.535
log
@use /snapshots/ rather than /4.5/ when you choose a numbered mirror from
the list.  ok deraadt
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.534 2009/05/06 20:41:38 todd Exp $
d425 15
d485 3
a487 2
	local _avail=$1 _selected=$2 _f _action _col _p
	typeset -L18 _l
a496 1
		_col=0
d498 2
a499 29
			if isin $_f $_selected; then
				_p="[X] $_f"
			else
				_p="[ ] $_f"
			fi
			if (( _col == 0 )); then
				echo -n '    '
			fi
			if (( ${#_p} > 18 )); then
				# probably site##-hostname.tgz, so print the
				# long version and force a newline
				print -n "$_p"
				_col=2
			else
				_l="$_p"
				print -n "$_l"
			fi
			let _col=_col+1
			if (( _col == 3 )); then
				# end of a column
				echo
				_col=0
			fi
		done
		if (( _col % 3 )); then
			# complete a partial column
			echo
		fi

d525 1
d1320 1
a1320 1
	local _zoneroot=$1 _zonepath _tz
d1322 2
a1323 2
	# If the timezone directory structure is not
	# available, return immediately.
d1325 1
a1325 1
	[[ ! -d $_zoneroot ]] && return
d1345 1
a1345 1
		_zonepath=$_zoneroot
d1349 3
a1351 3
		if [[ $resp == "?" ]]; then
			ls -F ${_zonepath}
			continue;
d1353 1
d1355 3
a1357 4
		_zonepath=${_zonepath}${resp}

		while [[ -d $_zonepath ]]; do
			ask "What sub-timezone of '${_zonepath#$_zoneroot}' are you in? ('?' for list)"
d1360 1
a1360 1
			"?")	ls -F $_zonepath ;;
d1364 2
a1365 2

		if [[ -f $_zonepath ]]; then
d1370 1
a1370 1
		echo -n "'${_zonepath#$_zoneroot}'"
d1818 4
d1825 1
a1825 1
export EDITOR
d1856 1
a1856 1
		set_timezone /var/tzdir/
@


1.534
log
@make nifs init global, so it can be relied upon
ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.533 2009/05/06 02:07:19 krw Exp $
d1160 1
a1160 1
			eval _${_url_type}_server_dir=${1#*/}/$SETDIR
@


1.533
log
@Don't display 'No disks found.' after configuring the last disk.

"Silence is golden." deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.532 2009/05/06 01:29:48 deraadt Exp $
a559 1
	nifs=0
d1798 1
@


1.532
log
@Split the collection of many questions from the appplication of their
change.  Then ask them at the start.  The timezone stuff remains a bit
weird since we have to depend on when we get the TZ names, or when we
get network... so there are 3 possible places that question can be
asked.  But now basically once it starts ftp'ing the sets, you only
have the final done prompt.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.531 2009/05/06 01:00:14 krw Exp $
a340 1
# $5 = error message if no items in $3, defaults to 'No $1s found.'
d344 1
a344 1
	local _name=$1 _query=$2 _list=$3 _def=$4 _err=$5
a347 1
		echo "${_err:=No ${_name}s found}."
d1881 2
a1882 1
[[ $# -gt 1 ]] && _defdsk=done
@


1.531
log
@De-uglify disk configuration in the non-auto layout cases. Trust
disklabel(8) to prevent duplicate mount points, and the user to
enter all their mountpoint info in disklabel(8). Proceed directly
to disk formatting after the last disk is configured. Do not pass
go.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.530 2009/05/05 21:26:09 deraadt Exp $
a284 2
	local _u _n _encr

d294 6
a299 17
	_u=$resp
	ask "Full user name for $_u?" $_u
	_n=$resp

	askpassword $_u
	_encr="*"
	[[ -n "$_password" ]] && _encr=`/mnt/usr/bin/encrypt -b 8 -- "$_password"`
	echo "${_u}:${_encr}:1000:10::0:0:${_n}:/home/${_u}:/bin/ksh" \
		>> /mnt/etc/master.passwd

	mkdir -p /mnt/home/$_u
	(cd /mnt/etc/skel; cp -pR . /mnt/home/$_u)
	cp -p /mnt/var/mail/root /mnt/var/mail/$_u
	chown -R 1000.10 /mnt/home/$_u /mnt/var/mail/$_u
	echo "1,s@@wheel:.:0:root\$@@wheel:\*:0:root,${_u}@@
w
q" | /mnt/bin/ed /mnt/etc/group 2>/dev/null
d1113 1
d1334 1
a1334 1
	local _zoneroot=/mnt/usr/share/zoneinfo/ _zonepath
d1341 3
d1357 1
a1380 1
			ln -sf /usr/share/zoneinfo/$TZ /mnt/etc/localtime
d1409 1
a1409 1
	startftplist
d1416 1
a1416 1
	echo "\nLet's $MODE the sets!"
d1589 2
d1599 2
d1620 19
a1638 2
xquestions() {
	local _xdmask=y
d1640 5
a1644 6
	# If any of the X11 sets are missing, then no need to enable X
	for i in xbase xetc xshare xfont xserv; do
		if ! isin $i${VERSION}.tgz $GOTSETS; then
			return
		fi
	done
d1646 3
a1648 8
	if [[ -n $MDXAPERTURE ]]; then
		ask_yn "Do you expect to run the X Window System?"
		if [[ $resp == y ]]; then
			sed -e "/^#\(machdep\.allowaperture=${MDXAPERTURE}\)/s//\1	/" \
				/mnt/etc/sysctl.conf >/tmp/sysctl.conf
			cp /tmp/sysctl.conf /mnt/etc/sysctl.conf
		fi
		_xdmask=$resp	# if aperture was n, do not ask for xdm
d1651 7
a1657 6
	if [[ -n $MDXDM && $_xdmask == y ]]; then
		ask_yn "Do you want the X Window System to be started by xdm(1)?"
		if [[ $resp == y ]]; then
			echo "xdm_flags=		# enabled during install" \
				>>/mnt/etc/rc.conf.local
		fi
d1659 2
d1664 1
a1664 1
	local _d
d1667 1
a1667 4
	if [[ $resp == n ]]; then
		echo "sshd_flags=NO		# disabled during install" \
			>>/mnt/etc/rc.conf.local
	fi
d1670 1
a1671 2
		echo "ntpd_flags=		# enabled during install" \
			>>/mnt/etc/rc.conf.local
d1673 1
a1673 9
		if [[ $resp != default ]]; then
			# Comment out the default 'servers' line, and add a
			# 'server' line with the first token in $resp as the
			# server.
			set -- $resp
			sed -e "s/^servers /#&/;/#server /a\\
server $1
" /mnt/etc/ntpd.conf >/tmp/ntpd.conf
		fi
d1676 7
a1682 1
	xquestions
d1684 4
a1687 10
	[[ -n $CDEV ]] || return
	_d=${CPROM:-$CDEV}
	ask_yn "Change the default console to $_d?"
	[[ $resp == n ]] && return
	ask_which "speed" "should $_d use" "9600 19200 38400 57600 115200" \
		$CSPEED
	[[ $resp == done ]] && return
	sed	-e "/^$CTTY/s/std.9600/std.${resp}/" \
		-e "/^$CTTY/s/unknown/vt220	/" \
		-e "/$CTTY/s/off.*/on secure/" /mnt/etc/ttys >/tmp/ttys
d1689 13
a1701 2
	[[ -n $CPROM ]] && \
		echo "stty $CPROM $resp\nset tty $CPROM" >>/mnt/etc/boot.conf
d1845 25
@


1.530
log
@accept TZ hints from the ftplist
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.529 2009/05/05 21:23:58 deraadt Exp $
a218 28
}

# Translate block count into human readable byte count.
# N.B.:  Assumes blocks being counted are 512 bytes!
# N.B.:  ksh arithmetic is 32 bits so can't just calculate!
stdsize ()  {
	local _p= _s= _sz=$1

	set -- " " K M G T P E Z Y

	while (( ${#_sz} > 4 )); do
		shift
		_p=${_sz%[0-9][0-9][0-9]}
		_s=${_sz#$_p}
		_s=${_s##+(0)}
		_sz=$_p
	done

	_sz=$(( _sz * 512))
	if (( ${#_sz} > 3 )); then
		shift
		_p=${_sz%[0-9][0-9][0-9]}
		_s=${_sz#$_p}
		_s=${_s##+(0)}
		_sz=$_p
	fi

	echo "${_sz} ${1}Bytes"
@


1.529
log
@shorter default answer for the nameserver question
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.528 2009/05/05 21:22:14 deraadt Exp $
d1384 6
@


1.528
log
@If only one interface, and it is running dhclient, skip the
default route / domainname / nameserver questions we already
know the answers to
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.527 2009/05/05 21:16:34 deraadt Exp $
d1627 1
a1627 1
		ask "DNS nameservers? (IP address list or 'none')" "${_ns:=none}"
@


1.527
log
@count network interfaces as we configure them
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.526 2009/05/05 21:14:46 deraadt Exp $
d822 3
d1617 4
a1620 1
	ask "DNS domain name? (e.g. 'bar.com')" "${_dn:=$(get_fqdn)}"
d1623 7
a1629 2
	# Get/Confirm nameservers, and construct appropriate resolv.conf.
	ask "DNS nameservers? (IP address list or 'none')" "${_ns:=none}"
@


1.526
log
@avoid changing directories a bit
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.525 2009/05/05 21:11:57 deraadt Exp $
d603 1
d666 1
@


1.525
log
@tabs and spaces and pedantry for the user entry
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.524 2009/05/05 21:09:54 deraadt Exp $
d487 1
a487 1
	cd /dev ; sh MAKEDEV $_dev || return 1 ; cd - >/dev/null
d1729 1
a1729 1
	cd /mnt/dev
d1736 1
a1737 1
	cd /
d1739 1
a1739 1
	md_installboot $ROOTDISK
@


1.524
log
@cope with users who cannot read the username question
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.523 2009/05/05 19:36:31 sthen Exp $
d318 1
a318 1
	y|yes)  ask "No really, what is the lower-case loginname, or 'no'?"
d321 1
a321 1
		esac
@


1.523
log
@adjust for ftp -DSMALL changes. been in test kernels tested by many.
ok martynas, deraadt
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.522 2009/05/05 18:54:40 todd Exp $
a315 1

d318 4
@


1.522
log
@fix for upgrade and vlans
noticed by naddy@@, tested by me, ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.521 2009/05/05 00:37:09 deraadt Exp $
a472 11
# log in via ftp to host $1 as user $2 with password $3
# and return a list of all files in the directory $4 on stdout
ftp_list_files() {
	ftp $FTPOPTS -n "$1" <<__EOT
user "$2" "$3"
cd "$4"
ls
quit
__EOT
}

d1242 1
a1242 1
		_file_list=$(ftp_list_files "$_ftp_server_ip" "$_ftp_server_login" "$_passwd" "$_ftp_server_dir")
@


1.521
log
@spaces to tabs
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.520 2009/05/04 22:07:28 deraadt Exp $
d895 1
a895 1
		ifconfig $if >/dev/null 2>&1 || continue
@


1.520
log
@Make the http fetcher capable of dealing with more complex index.txt files
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.519 2009/05/04 21:45:11 deraadt Exp $
d1053 1
a1053 1
			    $shacmd | tar zxphf - -C /mnt
d1056 1
a1056 1
			    $shacmd > "/mnt/$_f"
d1471 1
a1471 1
#       1) can't be mounted (no mount_* command is found),
@


1.519
log
@pass desired set path to ftplist
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.518 2009/05/04 06:21:58 deraadt Exp $
d1259 2
a1260 1
		_file_list=$(ftp $FTPOPTS -o - "$_url_base/index.txt" | sed 's///')
@


1.518
log
@a bit of wordsmithing for the SHA256 message
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.517 2009/05/04 03:30:00 deraadt Exp $
d1143 1
a1143 1
	ftp $FTPOPTS -a -o - http://129.128.5.191/cgi-bin/ftplist.cgi \
d1171 1
a1171 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _passwd _setdir
a1215 2
	_setdir=$SETDIR
	[[ $_url_type == ftp || $_url_type == http ]] && _setdir=$FTPSETDIR
d1217 1
a1217 1
	ask_until "Server directory?" "${resp:-pub/OpenBSD/$_setdir}"
@


1.517
log
@ok, but the jobs stderr redirect from guenther is good
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.516 2009/05/04 03:16:11 deraadt Exp $
d1063 1
a1063 1
				echo "The SHA256 hash for $_f did not match what bsd.rd expected:"
@


1.516
log
@no, that way of looking at the jobs does not work
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.515 2009/05/04 02:30:59 deraadt Exp $
d1157 1
a1157 1
	while [[ -n $(jobs $ftppid) ]]; do
@


1.515
log
@cleaner job watcher by guenther
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.514 2009/05/03 21:21:26 deraadt Exp $
d1157 1
a1157 1
	while jobs $ftppid 2>/dev/null; do
@


1.514
log
@delete XXX comment about upgrades; it should work
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.513 2009/05/03 21:20:47 sthen Exp $
d1157 1
a1157 1
	while [[ -n $(jobs $ftppid) ]]; do
@


1.513
log
@don't emit spurious error when no network is configured, also fix typos.
ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.512 2009/05/03 06:19:14 deraadt Exp $
a1138 1
	# XXX does this work on upgrades?
@


1.512
log
@Use the new ftplist backend which tries to intelligently provide you with
the ftp server you probably want to use.  Some XXX's in the code still;
please report issues to me.
ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.511 2009/05/03 03:35:17 deraadt Exp $
d1140 1
a1140 1
	[[ -z $(ls /tmp/hostname.* /mnt/etc/hostname.*) ]] && return
d1148 1
a1148 1
	# XXX We are relyong on the pid space not randomly biting us --
d1150 1
a1150 1
	(sleep 9; kill -INT $ftppid >/devnull 2>&1) &
@


1.511
log
@the _oifs variables should be local; spotted by Alexander Hall
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.510 2009/05/03 00:27:28 deraadt Exp $
d1137 29
d1174 1
d1180 8
a1187 17
	rm -f $SERVERLIST
	ask_yn "Display the list of known $_url_type servers?"
	if [[ $resp == y ]]; then
		# ftp.openbsd.org == 129.128.5.191 and will remain at
		# that address for the foreseeable future.
		echo -n "Getting the list from 129.128.5.191 (ftp.openbsd.org)..."
		ftp $FTPOPTS -a -o - \
			ftp://129.128.5.191/$FTPDIR/ftplist 2>/tmp/ftplisterr \
			| sed -ne "/^${_url_type}:\/\//s///p" >$SERVERLIST
		if [[ -s $SERVERLIST ]]; then
			echo "done."
			_prompt="Server? (IP address, hostname, list#, 'done' or '?')"
			cat -n $SERVERLIST | less -XE
		else
			echo "FAILED."
			cat /tmp/ftplisterr
		fi
a1190 1
	: ${_prompt:="Server? (IP address, hostname or 'done')"}
d1266 8
d1445 2
d1790 1
@


1.510
log
@Remove an XXX handled in the previous 5 lines of code
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.509 2009/05/02 17:01:26 deraadt Exp $
d296 1
a296 1
	_oifs=$IFS
d593 1
a593 1
	local _IFDEVS=$IFDEVS _ifs _name _hn _vl _vli _vd _vi _p
@


1.509
log
@If we are on the console we can assume the term type is either vt220 or
MDTERM, so we don't need to ask for the terminal type.  If we are not on
the console, don't ask for keyboard nationalization since we can't do that
for serial ports.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.508 2009/05/01 16:36:07 deraadt Exp $
a1623 2
	# XXX if any of the X sets are not installed, we should
	# not ask these questions
@


1.508
log
@Simplify the initial script text to ask less questions.  Instead of asking
a stupid "are you sure" question, instead remind people (twice) that duh,
since this is Unix, ^C gets you out of trouble if you change your mind about
modifying your disk.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.507 2009/05/01 16:14:12 deraadt Exp $
d77 18
a94 14
	TERM=${TERM:-${MDTERM:-vt220}}
	ask "Terminal type?" $TERM
	export TERM=$resp

	[[ -x /sbin/kbd ]] || return
	_tables=$(bsort $(kbd -l | egrep -v "^(user|tables|encoding)"))
	while :; do
		ask "Choose your keyboard type if it is nationalized? ('?' for list)" "default"
		case $resp in
		"?")	echo "Major tables: $_tables" ;;
		default) return ;;
		*)	kbd $resp && { echo $resp >/tmp/kbdtype ; return ; } ;;
		esac
	done
a137 1

a154 1
	echo
@


1.507
log
@Only tell the user about new mail at install time (not upgrade); from Pierre Riteau
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.506 2009/05/01 15:52:15 deraadt Exp $
d100 5
a104 15
This program will help you $MODE OpenBSD. At any prompt except password
prompts you can escape to a shell by typing '!'. Default answers are shown
in []'s and are selected by pressing RETURN.  At any time you can exit this
program by pressing Control-C, but exiting during an $MODE can leave your
system in an inconsistent state.

__EOT

	# Configure the terminal and keyboard.
	set_term

	cat <<__EOT

IS YOUR DATA BACKED UP? As with anything that modifies disk contents, this
program can cause SIGNIFICANT data loss.
d111 6
a116 2
NOTE: once your system has been upgraded, you must manually merge any changes
to files in the 'etc' set into the files already on your system.
d131 6
a136 1
			_q="Proceed with install?"
d141 1
a141 1
	ask_yn "$_q"
d145 2
a146 2
Enter 'halt' at the prompt to gracefully exit OpenBSD. You can then
power cycle the machine and boot your original OS.
d152 1
d1822 3
@


1.506
log
@Clean up the keyboard type question
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.505 2009/05/01 01:06:17 krw Exp $
d1731 2
@


1.505
log
@Since we no longer give an explicit chance to tweak the fstab used
during upgrade and therein change any normally ro ffs filesystems
to rw for the upgrade, just change any ffs filesystems to rw for
the upgrade. If we can't trust the upgrade process who can we trust?

Diff from RD Thrush.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.504 2009/04/30 21:18:29 deraadt Exp $
d84 1
a84 1
		ask "kbd(8) mapping? ('?' for list)" "none"
d87 1
a87 1
		none)	return ;;
@


1.504
log
@Only do the snapshots vs release thingy for ftp or http transfers,
because the install*.iso media for instance has the files in the
release directory.  Oops.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.503 2009/04/30 02:42:45 deraadt Exp $
d1470 4
@


1.503
log
@since the installer now chooses the sets mostly by itself, the default
operation in the sets menu should be "done".
ok @@krw with a tear in his eye
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.502 2009/04/30 01:03:28 deraadt Exp $
d1141 1
a1141 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _passwd
d1195 2
d1198 1
a1198 1
	ask_until "Server directory?" "${resp:-pub/OpenBSD/$SETDIR}"
d1766 1
d1768 1
a1768 1
[[ -n $CURRENT ]] && SETDIR=snapshots/$ARCH
@


1.502
log
@Allow the user's password to not be set, but in that case do not leave it
open, but * it out, since that is obviously what the administrator wants
ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.501 2009/04/30 01:01:56 deraadt Exp $
d519 1
a519 1
	local _avail=$1 _selected=$2 _next _f _action _col _p
a529 1
		_next=
a535 1
				: ${_next:=$_f}
a559 1
		: ${_next:=done}
d561 1
a561 1
		ask "Set name? (or 'abort' or 'done')" "$_next"
@


1.501
log
@quotes around ? matches; Alexander Hall
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.502 2009/04/30 00:59:41 deraadt Exp $
d324 1
@


1.500
log
@if the kernel is a -current kernel, change the default path to snapshots
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.499 2009/04/29 22:45:20 deraadt Exp $
d86 1
a86 1
		?)	echo "Major tables: $_tables" ;;
d1368 1
a1368 1
		if [[ $resp == ? ]]; then
d1379 1
a1379 1
			?)	ls -F $_zonepath ;;
@


1.499
log
@only encrypt passwords if they are set
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.498 2009/04/29 22:44:42 deraadt Exp $
d1763 5
@


1.498
log
@in [ ] or [[ ]] use -z instead of ! -n since it is shorter
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.497 2009/04/29 22:43:46 deraadt Exp $
d326 1
a326 1
	    >> /mnt/etc/master.passwd
@


1.497
log
@in [ ] or [[ ]] use -z instead of ! -n since it is shorter
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.496 2009/04/29 20:30:53 deraadt Exp $
d1788 1
a1788 1
	if [[ ! -n $DISPLAY ]]; then
@


1.496
log
@If we netbooted, use that interface as the default choice in the interface
selector
ok sthen
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.495 2009/04/29 18:10:54 deraadt Exp $
d324 1
a324 1
	_encr=`/mnt/usr/bin/encrypt -b 8 -- "$_password"`
d956 1
a956 1
				if [ ! -n "$name" ]; then
@


1.495
log
@no need for -g in ifconfig netboot group test; ok claudio
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.494 2009/04/29 17:26:07 deraadt Exp $
d603 7
a609 3
	# First time, default value is first interface
	set -- $IFDEVS
	_p=$1
@


1.494
log
@If the machine has any wsdisplay devices at all, we probably want the
X sets
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.493 2009/04/28 21:40:12 deraadt Exp $
d1412 1
a1412 1
	ifconfig -g netboot > /dev/null 2>&1 && _d=ftp
@


1.493
log
@When asking for network configs, prompt with the first interface name the
first time.  After one network has been configured, change the default
prompt to done.  Most people when installing only want to setup one interface,
and this lets them hit <return> instead of done<return>
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.492 2009/04/28 19:55:26 sthen Exp $
d1765 1
d1784 5
a1788 1
	isin $_set xbase xetc xshare xfont xserv site && continue
@


1.492
log
@adjust comment to match code; vlan tag range is 1-4095 not 0-4095
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.491 2009/04/28 16:46:10 deraadt Exp $
d593 1
a593 1
	local _IFDEVS=$IFDEVS _ifs _name _hn _vl _vli _vd _vi
d602 5
d608 2
a609 1
		ask_which "network interface" "do you wish to configure" "$_IFDEVS $_vl"
a618 1
			set -- $IFDEVS
d621 1
d669 1
@


1.491
log
@If the RAMDISK kernel in use supports vlans, ask the right question
and configure it properly.
tested by jsg, some help from sthen
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.490 2009/04/27 18:05:33 sthen Exp $
d629 1
a629 1
			# Validate range of $_vi as 0-4095
@


1.490
log
@if we netbooted (i.e. ifconfig -g netboot doesn't return an error),
select ftp rather than cd by default.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.489 2009/04/26 21:21:12 deraadt Exp $
d593 1
a593 1
	local _IFDEVS=$IFDEVS _ifs _name _hn
d595 7
d603 1
a603 1
		ask_which "network interface" "do you wish to configure" "$_IFDEVS"
d610 43
d767 1
a767 1
			echo "inet $_addr $resp" >$_hn
@


1.489
log
@No need to say that we setup the timezone; the user can assume it happens because we move on to the next task
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.488 2009/04/26 21:20:27 deraadt Exp $
d1355 1
@


1.488
log
@no more need for ftp -T option, since it is automatic now
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.487 2009/04/26 03:01:39 deraadt Exp $
a1324 1
			echo -n "Setting local timezone to '$TZ'..."
a1325 1
			echo "done."
@


1.487
log
@substantial changes -> copyright date crank
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.486 2009/04/26 03:00:32 deraadt Exp $
d991 1
a991 1
		*.tgz)	ftp -T "$_f" $FTPOPTS -o - -m "$_src/$_f" | \
d994 1
a994 1
		*)	ftp -T "$_f" $FTPOPTS -o - -m "$_src/$_f" | \
@


1.486
log
@extra spaces really matter on the media
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.485 2009/04/25 20:56:39 miod Exp $
d4 1
a4 1
# Copyright (c) 1997-2007 Todd Miller, Theo de Raadt, Ken Westerback
@


1.485
log
@stdsize() used to round the sector count to a multiple of 10**3, and
then would multiply by 512 and print the result. This means that, when
printing a partition size, the installer would print sizes rounded to
multiples of 512MB for partitions shorter than a few GB, for example.

Change this to round up one less 10**3 unit, then multiply by 512, then
complete the rounding.

ok krw@@ long ago.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.484 2009/04/25 19:25:29 krw Exp $
d763 1
a763 1
	
d1557 1
a1557 1
			
@


1.484
log
@edit_tmp_file() no longer used, so nuke it.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.483 2009/04/25 16:28:40 krw Exp $
d227 1
a227 1
	while (( ${#_sz} > 3 )); do
d235 8
a242 1
	(( _s > 500 )) && : $(( _sz = _sz + 1 ))
d244 1
a244 1
	echo "$(( _sz * 512 )) ${1}Bytes"
@


1.483
log
@Ask for IPv4 default route immediately after interfaces configured, not
after all DNS questions.

Requested by deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.482 2009/04/25 05:47:26 deraadt Exp $
a452 11
}

# Offer to edit a file in /tmp and execute ${EDITOR} to do so if the user
# accepts the offer.
#
# $1 == file in /tmp to edit
edit_tmp_file() {
	local _file=$1

	ask_yn "Edit $_file with $EDITOR?"
	[[ $resp == y ]] && $EDITOR /tmp/$_file
@


1.482
log
@Have to remember sets we installed
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.481 2009/04/25 05:46:44 deraadt Exp $
d767 3
d1505 1
a1541 3

	# Get/Confirm an IPv4 default route if an IPv4 address was configured.
	[[ -n $(ifconfig -a | sed -ne '/[ 	]inet .* broadcast /p') ]] && v4_defroute
@


1.481
log
@If any of the X sets is missing, there is no point in asking the X questions
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.480 2009/04/25 03:53:54 deraadt Exp $
d1008 1
d1011 1
@


1.480
log
@ask people to read their mail upon their first login
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.479 2009/04/25 03:51:48 deraadt Exp $
d1552 7
@


1.479
log
@For years now, the DNS server question has accepted a list of IP addresses
(because I asked for it :) so pluralize the question, and insert a little
missing word which everyone will understand.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.478 2009/04/25 03:50:46 deraadt Exp $
d1661 2
@


1.478
log
@Today, few people halt a machine and then reset it.  No, they really
want to use reboot, so be more clear and simple about it.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.477 2009/04/25 03:21:51 deraadt Exp $
d1528 1
a1528 1
	ask "DNS nameserver? (IP address or 'none')" "${_ns:=none}"
@


1.477
log
@If the right conditions exist, ask if xdm should be started automatically.
Yes, there are machines where you X needs configuration, but let us be
realistic about it: THAT IS AN X BUG.  And there are machines where getty
and xdm fight: THAT IS A CONSOLE DRIVER BUG.  And this commit is going to
force those bugs to eventually matter enough so that they get fixed.   Just
watch.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.476 2009/04/25 02:36:32 deraadt Exp $
d1660 1
a1660 2
To boot the new system, enter halt at the command prompt. Once the
system has halted, reset the machine and boot from the disk.
@


1.476
log
@one added word makes this a bit clearer for semi-newbies (actually, the
install script is changing so much, by 4.6 many people are going to be
newbies..)
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.475 2009/04/24 10:26:59 deraadt Exp $
d1549 24
d1598 1
a1598 8
	if [[ -n $MDXAPERTURE ]]; then
		ask_yn "Do you expect to run the X Window System?"
		if [[ $resp == y ]]; then
			sed -e "/^#\(machdep\.allowaperture=${MDXAPERTURE}\)/s//\1	/" \
				/mnt/etc/sysctl.conf >/tmp/sysctl.conf
			cp /tmp/sysctl.conf /mnt/etc/sysctl.conf
		fi
	fi
@


1.475
log
@make kbd table also use ? for listing; ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.474 2009/04/24 01:14:01 krw Exp $
d600 1
a600 1
		ask_which "interface" "do you wish to configure" "$_IFDEVS"
@


1.474
log
@Don't display network interface and route info during upgrades. If
you need it go look for it.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.473 2009/04/24 01:04:33 krw Exp $
d84 1
a84 1
		ask "kbd(8) mapping? ('L' for list)" "none"
d86 1
a86 1
		[Ll?])	echo "Major tables: $_tables" ;;
@


1.473
log
@Move bsd.mp juggling into relevant MD files. Make bsd.mp a default
selection on multi-processor machines. Make bsd.mp a sanity check
item on multi-processor machines.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.472 2009/04/24 00:15:21 sthen Exp $
a938 12

	# Display results...
	echo "Network interface configuration:"
	ifconfig -a media

	# enable the resolver if resolv.conf is available
	route -n show
	if [ -f /etc/resolv.conf ]; then
		echo "\nResolver enabled."
	else
		echo "\nResolver not enabled."
	fi
@


1.472
log
@use correct parenthesis; Alexander Hall
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.471 2009/04/23 23:15:08 deraadt Exp $
d1645 1
d1711 1
a1711 4
DEFAULTSETS="bsd bsd.rd"
if [ $(sysctl -n hw.ncpufound) -gt 1 ]; then
	DEFAULTSETS="$DEFAULTSETS bsd.mp"
fi
d1720 1
a1720 1
SANESETS="bsd base${VERSION}.tgz etc${VERSION}.tgz"
@


1.471
log
@The active mode ftp stuff is archaic, so delete it.  People who still
have that problem can use the plethora of www servers we have instead of
ftp.  Or as sthen pointed out, this is almost assuredly not biting anyone
today since we have received no complaits of the ftplist fetching
failing (that did not use the -A flag)
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.470 2009/04/23 21:44:27 deraadt Exp $
d1453 1
a1453 1
		echo $_msg | sed -e 's/, ctime=[^,(]*//'
@


1.470
log
@simplify mount -v sed; from guenther
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.469 2009/04/23 21:02:15 deraadt Exp $
a1086 10
set_ftp_opt() {
	local _q=$1 _opt=$2
	ask_yn "Use $_q?" $(isin $_opt $FTPOPTS && echo "yes")

	case $resp in
	y) FTPOPTS=$(addel $_opt $FTPOPTS) ;;
	n) FTPOPTS=$(rmel $_opt $FTPOPTS) ;;
	esac
}

a1144 7

	# Some older servers lie about their support for passive mode ftp, so
	# ask the user if it worth trying passive mode to the chosen server.
	# Irrelevant if using a proxy.
	if [[ $_url_type == ftp && -z $ftp_proxy ]]; then
		set_ftp_opt "active mode ftp" "-A"
	fi
@


1.469
log
@Cut the ctime= message strings out of the mount -v output to make this
a lot prettier.  We still leave this output in -v mode because we want
people to see how smart the install script is about making the different
partitions have different nosetuid, nodev modes
assistance with the right ksh code from drahn, beck, and espie
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.468 2009/04/23 20:23:35 deraadt Exp $
d1470 1
a1470 1
		echo $_msg | sed -e 's/, ctime=[^,(]*\([,)]\)/\1/'
@


1.468
log
@Give the user a copy of root's (install time) mail
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.467 2009/04/23 18:26:14 deraadt Exp $
d1460 1
a1460 1
	local _async=$1 _dev _mp _fstype _opt _rest
d1468 4
a1471 1
		if ! mount -v -t $_fstype $_async -o $_opt $_dev $_mp ; then
@


1.467
log
@Near the end of the installation, prompt for the setup of an initial
user, who will also be placed in wheel.  The setup of that user is
expected to be mostly compatible with what useradd(8) would have done.
krw will probably improve the ksh code in here after this :)
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.466 2009/04/19 21:42:00 krw Exp $
d323 2
a324 1
	chown -R 1000.10 /mnt/home/$_u
@


1.466
log
@When configuring the network assume the user means to assign
$(hostname -s) as the symbolic name of the first interface that is
configured. Subsequent interfaces still get the question.

Don't emit 'No more interfaces to initialize.'. Just move on to the
rest of the network configuration. Use the word 'configure' rather
than 'initialize'.

Suggested by & ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.465 2009/04/19 17:56:01 deraadt Exp $
d283 44
@


1.465
log
@If hw.ncpufound > 1, have the install script automatically prefer to use
bsd.mp instead of bsd (using -- mv bsd bsd.sp; mv bsd.mp bsd). anyone
who brings up boot.conf is an i386 bigot.
tested on almost all platforms that can do this, ok various people
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.464 2009/04/19 00:59:39 deraadt Exp $
d554 2
a555 3
	while :; do
		ask_which "interface" "do you wish to initialize" "$_IFDEVS" \
			"" "No more interfaces to initialize"
d560 1
d562 4
a565 2
		# Get symbolic name - will be used in DHCP requests.
		ask "Symbolic (host) name for $_ifs?" "$(hostname -s)"
d568 2
a569 3
		rm -f $_hn
		v4_config "$_ifs" "$_name" "$_hn"
		v6_config "$_ifs" "$_name" "$_hn"
d571 1
a571 1
		[[ -f $_hn ]] && chmod 640 $_hn && _IFDEVS=$(rmel "$_ifs" $_IFDEVS)
@


1.464
log
@Use sysctl -n hw.disknames instead of the custom disknames program
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.463 2009/04/19 00:00:35 krw Exp $
d1679 3
@


1.463
log
@Be consistant and make 'none' the last selection option presented.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.462 2009/04/18 15:12:39 deraadt Exp $
d174 1
a174 1
	bsort $(for _n in $(disknames); do echo "$_n "; done | sed -ne "$1")
@


1.462
log
@remove some obvious text; ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.461 2009/04/18 01:07:48 deraadt Exp $
d653 2
a654 2
	[[ -x /sbin/dhclient ]] && { _prompt=" or 'dhcp'" ; : ${_addr:=dhcp} ; }
	_prompt="IPv4 address for $_ifs? (or 'none'$_prompt)"
@


1.461
log
@Get rid of the final "Are you ready to install sets?" question by adding
an 'abort' option to the previous question.  Another question goes *poof*
ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.460 2009/04/18 00:42:28 deraadt Exp $
a128 6
		cat <<__EOT
It is often helpful to have the installation notes handy. For complex disk
configurations, relevant disk hardware manuals and a calculator are useful.

__EOT

@


1.460
log
@18 characters per column is better, since xshareXX.tgz is a long name.
(This gets noticed on non-SMP architectures, since they do not have
the bsd.mp which pushes xshareXX.tgz to the 3rd column)
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.459 2009/04/18 00:38:50 krw Exp $
d528 1
a528 1
		ask "Set name? (or 'done')" "$_next"
d530 2
a958 1
	ask_yn "Ready to $MODE sets?" yes
@


1.459
log
@Don't bother trying to handle network interface media modifications
in the script. If that level of tweaking is needed, it is safer to
not pretend to handle it in the scripts and leave it to the expert
installer to do manually. Very very rarely used in any case.

Suggested by and 'just commit' deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.458 2009/04/18 00:23:03 deraadt Exp $
d484 1
a484 1
	typeset -L16 _l
d506 1
a506 1
			if (( ${#_p} > 16 )); then
@


1.458
log
@If people want to edit their hosts file, they can do it in the next step
ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.457 2009/04/18 00:21:01 deraadt Exp $
d556 1
a556 1
	local _IFDEVS=$IFDEVS _ifs _name _media _hn
a569 22
		# Get and apply media options.
		_media=$(ifconfig $_ifs media | grep "media ")
		if [[ -n $_media ]]; then
			cat <<__EOT
The media options for $_ifs are currently
$(ifconfig $_ifs media | sed -n '/supported/D;/media:/p')
__EOT
			ask_yn "Do you want to change the media options?"
			case $resp in
			y)	cat <<__EOT
Supported media options for $_ifs are:
$_media
__EOT
				ask "Media options for $_ifs?"
				_media=$resp
				ifconfig $_ifs $_media || return 1
				;;
			n)	_media=
				;;
			esac
		fi

d571 2
a572 2
		v4_config "$_ifs" "$_media" "$_name" "$_hn"
		v6_config "$_ifs" "$_media" "$_name" "$_hn"
d645 1
a645 1
	local _ifs=$1 _media=$2 _name=$3 _hn=$4 _prompt _addr _mask
d669 1
a669 1
			echo "dhcp NONE NONE NONE $_media" >>$_hn
d679 1
a679 1
			echo "inet $_addr $resp NONE $_media" >$_hn
d686 1
a686 1
	local _ifs=$1 _media=$2 _name=$3 _hn=$4 _addr _prefixlen _prompt
d705 1
a705 1
			echo "up\nrtsol $media" >>$_hn
d714 1
a714 1
	echo "inet6 $_addr $resp $media" >>$_hn
@


1.457
log
@Always enable DNS in the installer, without asking, since everyone just
hits return for the question and accepts it.  Welcome to the Internet,
everyone has it today. ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.456 2009/04/17 16:05:47 deraadt Exp $
a1546 1
	edit_tmp_file hosts
@


1.456
log
@silence delete of hash output file
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.455 2009/04/17 07:00:44 deraadt Exp $
d1541 1
a1541 2
		ask_yn "Use the nameserver now?" yes
		[[ $resp == y ]] && cp /tmp/resolv.conf /tmp/resolv.conf.shadow
@


1.455
log
@undesireable tabs (waste space on the media)
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.454 2009/04/17 03:58:54 deraadt Exp $
d983 1
a983 1
		rm /tmp/h
@


1.454
log
@For SHA256 hashes to be ready to go onto the install media, we must
build the sets before we build the media.  While there we can get rid
of DESTDIR/snapshot too, and simply install straight into RELEASEDIR.
(This also ends up saving an astounding amount of traffic/latency in a nfs
environment)
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.453 2009/04/13 02:04:11 deraadt Exp $
d172 1
a172 1
		
d660 1
a660 1
	
@


1.453
log
@krw says comments only stripped when alone on a line
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.452 2009/04/13 01:59:19 deraadt Exp $
a973 1
	ask_yn "Ready to $MODE sets?" yes
d976 4
d983 1
d985 2
a986 1
		*.tgz)	ftp -T "$_f" $FTPOPTS -o - -m "$_src/$_f" | tar zxphf - -C /mnt
d988 2
a989 1
		*)	ftp -T "$_f" $FTPOPTS -o "/mnt/$_f" -m "$_src/$_f"
d994 7
@


1.452
log
@Print the sets list in 3 columns.  Some pathological case handling for
extremely siteXX-stupidlonghostname.tgz files worked out with krw
The shell script output is now substantially shorter than it was before
and blind people will appreciate this in our next release.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.451 2009/04/13 01:48:05 deraadt Exp $
d484 1
a484 1
	typeset -L16 _l		# 16 characters per column
d507 4
a510 2
				print -n "$_p"	# XXX site* is last entry
				_col=2		# trigger a new line
d517 2
a518 1
				echo		# end of a column
d523 2
a524 1
			echo			# complete a partial column
@


1.451
log
@use the new ftp -T title mode to compress the install script output
a bit more (and it is a lot prettier, too) ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.450 2009/03/14 15:55:39 krw Exp $
d483 2
a484 1
	local _avail=$1 _selected=$2 _next _f _action
d495 1
a495 1
		echo
d498 1
a498 1
				echo "	[X] $_f"
d500 1
a500 1
				echo "	[ ] $_f"
d503 15
d519 3
@


1.450
log
@Installed dhclient.conf is now all comments. Installed hosts is
now correct as is, since we don't add info to localhost lines. So
ditch comment-preserving dance through /tmp and just append our
new info to installed files. Shrinks scripts without changing
behaviour.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.449 2009/03/14 14:23:05 krw Exp $
d956 1
a956 1
		echo "Getting $_f ..."
d958 1
a958 1
		*.tgz)	ftp $FTPOPTS -o - -m "$_src/$_f" | tar zxphf - -C /mnt
d960 1
a960 1
		*)	ftp $FTPOPTS -o "/mnt/$_f" -m "$_src/$_f"
@


1.449
log
@There should only be one ::1 and one 127.0.0.1 entry in the hosts
file.  And 'localhost' don't need no stinkin' domain names.

Insert line(s) with the address(es) of last interface defined instead
of duplicate ::1 and 127.0.0.1 entries, Thus dhcp configured
interfaces may eventually drift away from the value in hosts file.

Much discussed just before tree lock. Time to see what happens.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.448 2009/03/13 01:20:44 krw Exp $
a413 13
}

# Add interesting/useful comments from mnt/etc/$1 to /tmp/$1.
#
# $1 == file in /tmp and /mnt/etc directories
save_comments() {
	local _file=$1

	if [[ -f /mnt/etc/$_file ]]; then
		grep "^#" /mnt/etc/$_file >/tmp/$_file.new
		[[ -f /tmp/$_file ]] && cat /tmp/$_file >>/tmp/$_file.new
		mv /tmp/$_file.new /tmp/$_file
	fi
@


1.448
log
@Add tab's to the whitespace pattern used to eliminate existing entries
when adding a host line via addhost_entry(). Thus preventing the duplicate
entries for 127.0.0.1 we started inserting when we switched to using tabs
in the initial hosts file.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.447 2009/02/19 02:11:32 krw Exp $
d482 2
a483 1
	sed "/^[0-9a-fA-F]*[$_delim].*[ 	]$_name\$/d" /tmp/hosts >/tmp/hosts.new
d678 3
a680 1
			addhostent "127.0.0.1" "$_name"
d714 5
a718 3
		rtsol -F $_ifs
		addhostent "::1" "$_name"
		echo "up\nrtsol $media" >>$_hn
@


1.447
log
@Third time lucky. Proper use of quotes when comparing the first and
second copies of the entered password will preserve leading and
trailing spaces.

Prodded by dale@@. Proper clue pointed out by todd@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.446 2009/02/19 01:25:22 krw Exp $
d482 1
a482 1
	sed "/^[0-9a-fA-F]*[$_delim].* $_name\$/d" /tmp/hosts >/tmp/hosts.new
@


1.446
log
@No need for caveat about ignoring "\" when reading passwords, \r\n get
passed through just fine. Also add comment to note that leading and
trailing space will be trimmed.

Pointed out by 'x' on bugs@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.445 2009/02/18 00:03:06 krw Exp $
a250 1
#    NOTE: leading and trailing space will be trimmed from password.
@


1.445
log
@Use 'read -r' to read password, which allows "\" to be in the
password unless it's part of an escape sequence like "\r". Prompted
by Aaron W. Hsu via PR#6042.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.444 2009/02/14 04:00:07 krw Exp $
d250 2
a251 3
#    *Don't* interpret "\" as escape character if not at start of escape
#            sequence. e.g. "\s" will be left alone and "\<newline>" will
#            not cause line continuation. "\r", etc. still get interpreted.
@


1.444
log
@Don't copy the 'full' installed protocols(5) or services(5) to the
ramdisk environment during an upgrade. They are large and potentially
modified beyond usefulness. The minimal ones on the install media
are sufficient.

ok ian@@ guenther@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.443 2009/02/08 21:02:20 miod Exp $
d250 3
d256 1
a256 1
	read resp?"$1 "
@


1.443
log
@Move to 4.5-BETA
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.442 2009/01/25 21:27:27 krw Exp $
d782 1
a782 1
	for _f in dhclient.conf resolv.conf resolv.conf.tail protocols services; do
@


1.442
log
@Only copy hosts file once during upgrades. Shorten a long variable name.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.441 2008/11/23 01:57:06 krw Exp $
d1642 1
a1642 1
VERSION=44
@


1.441
log
@Create a new bpfN device whenever a dhclient is started. Multiple
interfaces can now be configured with dhcp during install and upgrades.
Problem most forcibly pointed out by Luis and Pedro at h2k8.

"go for it" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.440 2008/11/11 23:36:13 krw Exp $
d779 1
a779 1
	local _netfile _gw
d781 4
a784 4
	# Copy any required or optional files found
	for _netfile in hosts dhclient.conf resolv.conf resolv.conf.tail protocols services; do
		if [ -f /mnt/etc/${_netfile} ]; then
			cp /mnt/etc/${_netfile} /etc/${_netfile}
@


1.440
log
@Drop svnd lines from the munged fstab for upgrades, to avoid confusing
fsck. Reported by Sebastian Rother via tech@@.

"sure" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.439 2008/11/11 00:55:21 krw Exp $
d678 2
d828 2
@


1.439
log
@Replace some 4 space knf spacing with install space paranoia tabs, saving
33 characters.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.438 2008/09/30 00:47:47 deraadt Exp $
d1360 2
a1361 1
#	4) are nfs (since name resolution may not be present).
d1377 1
a1377 1
		[[ $_dev == \#* || \
@


1.438
log
@install hostname.* files mode 640 root.wheel by default; ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.437 2008/09/07 14:09:37 krw Exp $
d186 2
a187 2
	    | egrep -v '^[[:space:]]|(bridge|enc|gif|gre|lo|pflog|pfsync|ppp|sl|tun|vlan)[[:digit:]]+:' \
	    | sed -ne 's/^\(.*\):.*/\1/p'
d1054 1
a1054 1
	    "${ftp_proxy:-none}"
d1377 4
a1380 4
		    $_fstype == nfs || \
		    ! -f /sbin/mount_$_fstype || \
		    $_opt == *noauto* || \
		    $_opt == *xx* ]] && continue
d1530 1
a1530 1
		    >>/mnt/etc/rc.conf.local
d1553 1
a1553 1
			    /mnt/etc/sysctl.conf >/tmp/sysctl.conf
d1586 1
a1586 1
			    /mnt/sbin/swapctl -a $_dev >/dev/null 2>&1
d1592 1
a1592 1
		    /mnt/etc/sysctl.conf >/tmp/sysctl.conf
@


1.437
log
@Nuke ifconfig '-m' uses. Use bare 'media' instead. Pointed out by
Paul de Weerd via source-changes@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.436 2008/07/07 15:53:15 jdixon Exp $
d584 1
a584 1
		[[ -f $_hn ]] && chmod 600 $_hn && _IFDEVS=$(rmel "$_ifs" $_IFDEVS)
@


1.436
log
@Rework the ntpd question to default to no, and ask for the NTP server only if user chooses yes.  Easier than the 3-part question and requires far fewer keystrokes to enable the 'default'.

ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.435 2008/07/06 14:31:19 krw Exp $
d559 1
a559 1
		_media=$(ifconfig -m $_ifs | grep "media ")
d563 1
a563 1
$(ifconfig -m $_ifs | sed -n '/supported/D;/media:/p')
d902 1
a902 1
	ifconfig -am
@


1.435
log
@Make 'dhcp' the initial default when configuring the network. This
makes one more answer <cr>'able during install without changing any
existing behaviour.

Change 'NTP server?' default answer from 'none' to 'default'.

Suggested by thib@@, supported by marco@@, jsing@@, millert@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.434 2008/07/02 00:13:32 deraadt Exp $
d1533 2
a1534 2
	ask "NTP server? (host, 'none' or 'default')" default
	if [[ $resp != none ]]; then
d1537 1
@


1.434
log
@move to 4.4-beta
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.433 2008/06/26 05:42:03 ray Exp $
d667 1
a667 1
	[[ -x /sbin/dhclient ]] && _prompt=" or 'dhcp'"
d1533 1
a1533 1
	ask "NTP server? (host, 'none' or 'default')" none
@


1.433
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.432 2008/06/24 11:59:48 tobias Exp $
d1636 1
a1636 1
VERSION=43
@


1.432
log
@Remove leading zeros of subpart of partition's blocksize so ksh does not
interpret it as octal, leading to error messages like "048" is not a
number.

ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.431 2008/06/13 04:41:44 krw Exp $
a40 7
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#        This product includes software developed by the NetBSD
#        Foundation, Inc. and its contributors.
# 4. Neither the name of The NetBSD Foundation nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
@


1.431
log
@ksh's arithmetic is 32 bit signed so we can no longer rely on
block counts being small enough to do arithmetic on. Manually
process partition block counts into 'human readable' byte sizes
when asking for confirmation of disk configuration.

Install script now properly displays the size of Yottabyte
partitions.

requested by & ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.430 2008/04/17 01:51:44 deraadt Exp $
d244 1
@


1.430
log
@force mode for hostname.* files to 600; ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.429 2008/03/15 05:28:31 jsing Exp $
d230 20
@


1.429
log
@When installing via NFS, only retry the mount five times (instead of the
default 10,000 times).

ok deraadt@@ krw@@ thib@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.428 2008/03/09 02:00:42 krw Exp $
d570 1
a570 1
		[[ -f $_hn ]] && _IFDEVS=$(rmel "$_ifs" $_IFDEVS)
@


1.428
log
@Remove question about keep alive option.

Requested by deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.427 2008/03/09 00:42:08 krw Exp $
d1197 1
a1197 1
	mount_nfs $_tcp -o ro $NFS_ADDR:$NFS_PATH /mnt2 || return
@


1.427
log
@Consolidate FTP option handling, fixing one missing set of options
and adding a new question during install to allow the setting of
FTP's -k option in situations where intervening routers/firewalls
are prematurely killing connections.

Original idea and diff from espie@@

ok espie@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.426 2008/03/05 01:09:58 krw Exp $
a1094 1
		set_ftp_opt "keepalive (NOOP) commands" "-k60"
@


1.426
log
@Tweak regexp replacing 'off' with 'on secure' so we don't end up with
'on secure secure'.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.425 2008/03/04 00:36:38 krw Exp $
d436 1
a436 1
	ftp ${_ftp_active} -V -n "$1" <<__EOT
d947 1
a947 1
		*.tgz)	ftp $_ftp_active -o - -V -m "$_src/$_f" | tar zxphf - -C /mnt
d949 1
a949 1
		*)	ftp $_ftp_active -o "/mnt/$_f" -V -m "$_src/$_f"
d1021 10
d1035 1
a1035 1
#	and _ftp_active must be global.
d1050 1
a1050 1
		ftp $_ftp_active -V -a -o - \
d1094 2
a1095 8
		case $_ftp_active in
		-A)	resp=no ;;
		*)	resp=yes ;;
		esac

		unset _ftp_active
		ask_yn "Does the server support passive mode ftp?" $resp
		[[ $resp == n ]] && _ftp_active=-A
d1142 1
a1142 1
		_file_list=$(ftp -o - -V "$_url_base/index.txt" | sed 's///')
d1628 1
@


1.425
log
@Redo serial console configuration logic. Smaller, easier to
understand.

Add serial console handling for alpha, macppc, zaurus.  No functional
change for i386/amd64.

All archs should now have automatic serial console configuration.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.424 2008/02/20 17:46:50 miod Exp $
d1549 1
a1549 1
		-e "/$CTTY/s/off/on secure/" /mnt/etc/ttys >/tmp/ttys
@


1.424
log
@4.3-beta
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.423 2008/02/11 23:40:03 krw Exp $
d70 1
a77 1
#	MDSERIAL    - offer to configure a serial console
a196 32
# Get the first (lowest unit #) serial device if any, if MDSERIAL is set.
#
# MDSERIAL is of the form
#
# "<dmesg device prefix> <boot loader device prefix> <tty device prefix>"
#
# So "pccom com tty0" means the dmesg is searched for devices pccom0, pccom1,
# ... pccom9. If pccom2 is found, then com2 and tty02 are used in serial
# console configuration via boot.conf commands and /etc/ttys.
#
# NOTE: Only single digit serial devices (<dev>0 -> <dev>9) are looked for.
get_serialdev() {
	local _d _bd _td

	[[ -n $MDSERIAL ]] || exit
	set -- $MDSERIAL
	_d=$1
	_bd=$2
	_td=$3
	set -- $(scan_dmesg "/^${_d}\([0-9]\) .*/s//\1/p")
	echo "$_bd$1 $_td$1"
}

get_console() {
	local _d

	# Find '<dev>: console' and extract <dev>.
	_d=$(sed -ne '/^\([^ ]*\): console$/s//\1/p' /var/run/dmesg.boot)
	set -- $MDSERIAL
	[[ ${_d%[0-9]} == $1 ]] && echo "$2${_d##*[a-z]} $3${_d##*[a-z]}"
}

d1508 1
a1508 1
	local _bd _td _sp
d1540 3
a1542 12
	[[ -z $SERIALDEV ]] && return
	set -- $(get_console)
	if [[ -n $1 && -n $2 ]]; then
		# When installing via a serial console use it and current speed.
		_sp=$(stty speed)
	else
		# Use first serial port and 9600 (i.e. leave _sp unset).
		set -- $SERIALDEV
	fi
	_bd=$1
	_td=$2
	ask_yn "Change the default console to $_bd?"
d1544 2
a1545 1
	ask_which "speed" "should $_bd use" "9600 19200 38400 57600 115200" $_sp
d1547 6
a1552 4
	echo "stty $_bd $resp\nset tty $_bd" >>/mnt/etc/boot.conf
	sed	-e "/^${_td}/s/std.9600/std.${resp}/" \
		-e "/^${_td}/s/unknown/vt220	/" \
		-e "/${_td}/s/off/on secure/" /mnt/etc/ttys >/tmp/ttys
d1640 9
a1648 1
SERIALDEV=$(get_serialdev)
@


1.423
log
@For architectures with an enabled 'console' ttys entry, adjust the
speed of said entry to reflect the speed of the console being used to
install.

For archs with MDSERIAL defined, offer the current device and speed as
the defaults for switching to serial consoles.

Fixes new Sun gear that uses a 115200 console speed and makes for
better defaults without breaking current install processes.

ok dlg@@ henning@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.422 2007/12/14 08:30:11 otto Exp $
d1657 1
a1657 1
VERSION=42
@


1.422
log
@make more clear that the NTP question is not a three way yes/no
question; ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.421 2007/08/02 03:23:37 david Exp $
d220 9
d1540 1
a1540 1
	local _bd _td
d1573 8
a1580 1
	set -- $SERIALDEV
d1585 1
a1585 1
	ask_which "speed" "should $_bd use" "9600 19200 38400 57600 115200"
@


1.421
log
@spelling fixes in the comments
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.420 2007/07/27 01:34:32 deraadt Exp $
d1539 1
a1539 1
	ask "NTP server? (or 'none' or 'default')" none
@


1.420
log
@oops, forgot to crank to 4.2
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.419 2007/05/28 02:57:11 krw Exp $
d991 1
a991 1
#	   embeddded blanks in usercodes and passwords.
d1061 1
a1061 1
		# that address for the forseeable future.
@


1.419
log
@Don't look for wt tape devices while installing.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.418 2007/04/27 02:41:41 deraadt Exp $
d1641 1
a1641 1
VERSION=41
@


1.418
log
@caps for NTP server; from jdixon
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.417 2007/04/25 11:59:49 krw Exp $
d76 1
a76 1
#	MDMTDEVS    - '/^[cmsw]t[0-9][0-9]* /s/ .*//p'
d1660 1
a1660 1
MTDEVS=$(scan_dmesg "${MDMTDEVS:-/^[cmsw]t[0-9][0-9]* /s/ .*//p}")
@


1.417
log
@Use 'ifconfig' and not 'ifconfig -a' as the -a is now the default.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.416 2007/04/25 11:52:14 krw Exp $
d1539 1
a1539 1
	ask "ntp server? (or 'none' or 'default')" none
@


1.416
log
@Add capacity to specify one ntp 'server' (not 'servers') during install.

Suggested by deraadt@@, nifty sed nit from ray@@.

ok deraadt@@ beck@@ mbalmer@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.415 2007/03/26 20:13:24 otto Exp $
d192 1
a192 1
	ifconfig -a \
@


1.415
log
@Make the default behaviour to force a fsck when upgrading, as it
was before it became optional. ok krw@@ beck@@ pedro@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.414 2007/03/26 12:09:13 krw Exp $
d1539 2
a1540 2
	ask_yn "Start ntpd(8) by default?"
	if [[ $resp == y ]]; then
d1542 10
a1551 1
		    >>/mnt/etc/rc.conf.local
@


1.414
log
@Don't pass fsck '--fp'. From Loic Tortay via PR #5422.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.413 2007/03/16 22:33:39 krw Exp $
d1442 1
a1442 1
	ask_yn "Force checking of non-root filesystems?"
@


1.413
log
@Give the upgrader an option to *not* fsck -f non-root filesystems. In
fact make that the default. Help upgraders with big filesystems and no
patience.

Suggested by & ok beck@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.412 2007/03/13 00:14:21 krw Exp $
d1443 1
a1443 1
	[[ $resp == y ]] && _f=-f
@


1.412
log
@Keep copyright year current.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.411 2007/03/04 14:37:37 krw Exp $
d1440 1
a1440 1
	local _dev _mp _fstype _rest _fail
d1442 2
a1443 1
	echo "Checking non-root filesystems..."
d1451 2
a1452 2
		echo -n "fsck -p ${_dev}..."
		if ! fsck -fp ${_dev} >/dev/null 2>&1; then
a1458 2

	echo "...done."
@


1.411
log
@If INSTALL.<arch> isn't present at the given set location, give the
user a chance to bail out before selecting sets to install. Just in
case the user ended up in the wrong directory.

Suggested by beck@@, feedback from various.

"emphatic ok" beck@@ "go for it" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.410 2007/03/01 03:51:56 deraadt Exp $
d4 1
a4 1
# Copyright (c) 1997-2006 Todd Miller, Theo de Raadt, Ken Westerback
@


1.410
log
@shrink early text; input from frantisek holop, discussion and ok ok krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.409 2007/02/14 23:37:18 krw Exp $
d952 5
@


1.409
log
@Use new 'disknames' command to get names of disks and cds.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.408 2007/02/12 13:10:02 henning Exp $
d107 5
a111 6
This program will help you $MODE OpenBSD in a simple and rational way. At
any prompt except password prompts you can run a shell command by typing
'!foo', or escape to a shell by typing '!'. Default answers are shown in []'s
and are selected by pressing RETURN. At any time you can exit this program by
pressing Control-C and then RETURN, but quitting during an $MODE can leave
your system in an inconsistent state.
@


1.408
log
@4.1-beta
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.407 2007/02/11 18:59:31 krw Exp $
d185 7
d1646 2
a1647 2
DKDEVS=$(scan_dmesg "${MDDKDEVS:-/^[sw]d[0-9][0-9]* /s/ .*//p}")
CDDEVS=$(scan_dmesg "${MDCDDEVS:-/^cd[0-9][0-9]* /s/ .*//p}")
@


1.407
log
@Nuke MDFSTYPE and MDFSOPTS, 'mount -t ...' and giving the user the
option to choose a filesystem type when mounting a disk. Rely on the
filesystem information provided by the disklabel.

When there is only one usable partition on the selected disk, just
mount it without bothering the user with a question.

Ensure that msdos filesystems are mounted with '-s' so that the names
of the install sets will be in lower case and thus visible to the
script.

msdos problems noted by Rodolfo Gouveia, who did a lot of testing and
debugging. 'mount -t ...' silliness pointed out by deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.406 2006/08/29 01:02:49 krw Exp $
d1622 1
a1622 1
VERSION=40
@


1.406
log
@Handle site${VERSION}-$(hostname -s).tgz files better so that they
don't get in the way of noticing that all default sets are installed.

Restores the desired behaviour where [done] becomes the default answer
to the "Location of sets?" question once all default sets are
successfully installed.

spotted by & ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.405 2006/07/26 20:34:11 deraadt Exp $
a73 2
#	MDFSTYPE    - nothing assumed if not provided
#	MDFSOPTS    - nothing assumed if not provided
d221 2
a222 2
get_partition() {
	local _drive=$1 _fstypes=$2 _part _fst
d224 2
a225 7
	# Create file /tmp/parts.$_drive where each line is of the
	# form "<partition letter> <fs type>".
	disklabel $_drive 2>/dev/null		\
		| grep '^  [a-p]: '		\
		| egrep -v "swap|unused"	\
		| sed -e 's/^  \(.\):  *[^ ]*  *[^ ]*  *\([^ ]*\) .*/\1 \2/' \
		>/tmp/parts.$_drive
d227 16
a242 8
	disklabel $_drive 2>/dev/null | grep '^  .:'

	ask_which "$_drive partition" "has the $MODE sets" \
		 "$(sed -e 's/^\(.\).*/\1/' /tmp/parts.$_drive)"
	[[ $resp == done ]] && return 1

	_part=$resp
	_fst=$(sed -ne "/^$_part /s///p" /tmp/parts.$_drive)
d244 3
a246 8
	ask_which "filesystem type" "should be used to mount $_drive$_part" "$_fst $_fstypes ffs"
	case $resp in
	done)	return 1 ;;
	$_fst)	resp="$_part" ;;
	*)	resp="$_part $resp" ;;
	esac

	return 0
a1173 2
	local _drive _part=c _fstype

d1175 1
a1175 1
	_drive=$resp
a1176 12
	set -- $(disklabel $_drive 2>&1 | grep '^  c: ')
	case $4 in
	ISO9660) _fstype=cd9660 ;;
	UDF)	 _fstype=udf ;;
	*)	 get_partition $_drive "cd9660" || return
		 set -- $resp
		 _part=$1
		 [[ -n $2 ]] && _fstype=$2
		;;
	esac

	mount -t $_fstype -o ro /dev/$_drive$_part /mnt2 || return
a1180 2
	local _drive _dev _fstype _fsopts

d1184 2
a1185 7
		_drive=$resp

		get_partition $_drive "$MDFSTYPE" || return
		set -- $resp
		_dev=/dev/$_drive$1
		[[ -n $2 ]] && _fstype="-t $2"
		[[ $_fstype == $MDFSTYPE ]] && _fsopts=$MDFSOPTS
a1186 4
		if [[ -z $(mount | grep "^$_dev") ]]; then
			mount $_fstype -o ro,$_fsopts $_dev /mnt2 || return
		fi
	fi
@


1.405
log
@crank to 4.0-beta
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.404 2006/05/18 11:56:09 krw Exp $
d935 2
a936 1
		isin $_f $DEFAULTSETS && _get_sets=$(addel $_f $_get_sets)
@


1.404
log
@Don't ask for a password for ftp transfers if the username 'ftp' is used.

Suggested by deraadt@@, 'looks good to me' deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.403 2006/03/15 01:17:12 krw Exp $
a970 3
			# XXX Hack for 3.9. Remove old static X modules.
			[[ $_f == xserv39.tgz ]] || continue
			( cd /mnt/usr/X11R6/lib/modules ; rm -f *.[ao] */*.[ao] )
d1650 1
a1650 1
VERSION=39
@


1.403
log
@Make 'no' the default answer to 'Display the list of XXX servers?'.

Suggested by otto@@, various people chiming in to agree.

While here fix one ask_yn misuse and update copyright to 2006.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.402 2006/03/11 19:23:31 krw Exp $
d1125 4
a1128 3
		# Get password unless anonymous
		_passwd=root@@`hostname`
		if [[ $_ftp_server_login != anonymous ]]; then
@


1.402
log
@Change default answer for 'Do you expect to run the X Window System?'
to 'no'.

Requested by deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.401 2006/02/28 20:33:55 matthieu Exp $
d4 1
a4 1
# Copyright (c) 1997-2005 Todd Miller, Theo de Raadt, Ken Westerback
d1053 2
a1054 3
	ask_yn "Display the list of known $_url_type servers?" "${_get_server_list:-yes}"
	_get_server_list=$resp
	if [[ $_get_server_list == y ]]; then
d1559 1
a1559 1
	ask_yn "Start ntpd(8) by default?" no
@


1.401
log
@Remove old static X modules from previous versions. Patch by krw@@, ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.400 2006/01/19 03:30:04 deraadt Exp $
d1567 1
a1567 1
		ask_yn "Do you expect to run the X Window System?" yes
@


1.400
log
@crank to 3.8-beta
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.399 2005/11/22 19:29:15 krw Exp $
d971 3
@


1.399
log
@'?' may not be easily found until the keyboard is mapped. Make 'L' the
command to list the major keymaps. Also accept 'l' and '?' without
explictly mentioning them in the user prompt.

A varient of a suggestion by And??s (sic) Delfino, seconded by jmc@@.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.398 2005/10/28 13:30:50 jmc Exp $
d1650 1
a1650 1
VERSION=38
@


1.398
log
@selected install sets are denoted by `[X]', not `[x]';
ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.397 2005/10/26 00:06:51 krw Exp $
d93 1
a93 1
		ask "kbd(8) mapping? ('?' for list)" "none"
d95 1
a96 1
		"?")	echo "Major tables: $_tables" ;;
@


1.397
log
@Sync mygate handling with latest netstart changes so upgrades work.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.396 2005/10/20 02:31:52 krw Exp $
d507 1
a507 1
sets are labelled '[x]'.
@


1.396
log
@Always give user a chance to confirm/modify TERM and keymap when
running install or upgrade.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.395 2005/10/16 05:01:59 krw Exp $
d175 3
d731 1
a731 1
	echo "!route -qn add -host -inet6 default $resp" >>$_hn
d784 1
a784 1
	local _netfile
d889 13
a901 6
	# /mnt/etc/mygate contains the address of my gateway host. Ignore
	# it if any interfaces attempted dhcp.
	if [[ -z $dhcpif && -f /mnt/etc/mygate ]]; then
		route delete default >/dev/null 2>&1
		route -qn add -host default $(stripcom /mnt/etc/mygate)
	fi
@


1.395
log
@Bring enable_network() into line with /etc/netstart by not attempting
to use mygate if any interface attempts dhcp.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.394 2005/10/16 03:06:12 krw Exp $
d86 3
a88 4
	[[ -n $TERM ]] && return
	ask "Terminal type?" ${MDTERM:-vt220}
	TERM=$resp
	export TERM
@


1.394
log
@Use 'rtsolif' in enable_network(), rather than 'rtsif', to make it more
closely resemble netstart. No functional change.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.393 2005/10/12 02:48:49 krw Exp $
d828 1
d887 3
a889 3
	# /mnt/etc/mygate, if it exists, contains the name of my gateway host
	# that name must be in /etc/hosts.
	if [ -f /mnt/etc/mygate ]; then
@


1.393
log
@Comments are now allowed in myname and mygate. Steal stripcom() from
/etc/netstart and use in myname and mygate processing. Fixes problems
with (U)pgrade's. Discovered while preparing for Todd's new mygate
functionality.

ok todd@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.392 2005/10/10 19:23:06 krw Exp $
d832 1
a832 1
				rtsif="$rtsif $if"
d884 1
a884 1
	[[ -n $rtsif ]] && /mnt/sbin/rtsol -F $rtsif
@


1.392
log
@Provide some verbiage about MDSERIAL. Suggested by miod@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.391 2005/10/05 02:07:27 krw Exp $
d172 9
d890 1
a890 1
		route -qn add -host default $(</mnt/etc/mygate)
@


1.391
log
@Apply Todd's netstart r1.106 fix to evaluation of dhcp and rtsol lines
in hostname.if files.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.390 2005/08/29 17:47:55 krw Exp $
d79 1
d183 9
@


1.390
log
@addhostent() shouldn't delete the hosts entry for the 'other' address
family. Specifying an IPv6 address will no longer remove an IPv4 entry
from hosts, nor visa verse. Noted by mickey@@.

ok deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.389 2005/08/09 00:46:12 deraadt Exp $
d809 2
a810 2
				ifconfig $if $name $mask $bcaddr $ext1 $ext2 down
				cmd="dhclient $if"
a812 1
				ifconfig $if $name $mask $bcaddr $ext1 $ext2 up
d814 1
a814 1
				cmd=
@


1.389
log
@move to 3.8-beta
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.388 2005/07/02 00:55:48 uwe Exp $
d463 1
a463 1
	local _addr=$1 _name=$2
d465 3
a467 1
	sed "/^[0-9a-fA-F]*[:.].* $_name\$/d" /tmp/hosts >/tmp/hosts.new
@


1.388
log
@During set selection, ask for a "file name pattern" rather than a
"regular expression" because the answer is processed by the shell.
ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.387 2005/06/13 23:42:38 krw Exp $
d1620 1
a1620 1
VERSION=37
@


1.387
log
@Typo. ${version} -> ${VERSION}. Spotted by David Krause.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.386 2005/05/24 22:38:41 krw Exp $
d482 2
a483 2
Select sets by entering a set name, a regular expression or 'all'. De-select
sets by prepending a '-' to the set name, regular expression or 'all'. Selected
@


1.386
log
@Checking for the address '0.0.0.0' no longer works as test for
dhclient failure.  Just check if any inet address was assigned.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.385 2005/04/30 14:09:41 krw Exp $
d1654 1
a1654 1
# Since etc${version}.tgz is not in DEFAULTSETS for upgrades, it can always be
d1656 1
a1656 1
SANESETS="bsd base${VERSION}.tgz etc${version}.tgz"
@


1.385
log
@Fix rtsol IPv6 install - check correct directory for hostname.* files.

Found & ok dlg@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.384 2005/04/19 00:49:20 krw Exp $
d596 1
a596 1
# no IP address or 0.0.0.0 assigned to $1.
d624 1
a624 1
	if [[ $1 == UP && $2 != "0.0.0.0" ]]; then
@


1.384
log
@There is no reliable way to detect a working network interface. So
always offer ftp and http as set sources.

Problem noted by uwe@@, ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.383 2005/04/18 23:56:21 deraadt Exp $
d1573 1
a1573 1
	if grep -qs '^rtsol' /tmp/hostname.*; then
@


1.383
log
@restore tab before [X] list; krw ok
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.382 2005/04/15 23:45:29 krw Exp $
d1323 1
a1323 1
	local _d=disk _locs=disk
d1326 1
a1326 4
	if [[ -n $(ifconfig | grep 'status: active') ]]; then
		_locs="$_locs ftp http"
		[[ -x /sbin/mount_nfs ]] && _locs="$_locs nfs"
	fi
@


1.382
log
@Report dhcp success *only* if the interface is UP, and an address other
than 0.0.0.0 has been assigned to it. Fixes problem of interfaces
being removed from the available list even if dhcp fails because there
is no link.

Some code cleanup and shrinkage.

Pointed out a long time ago by a friend of Henning's, whose email I
read again this afternoon and now can't find for the life of me.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.381 2005/04/13 03:45:51 krw Exp $
d492 1
a492 1
				echo "[X] $_f"
d494 1
a494 1
				echo "[ ] $_f"
@


1.381
log
@Tweak set source option testing. Don't offer nfs if no active interface
is found - even if /sbin/mount_nfs is present.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.380 2005/04/13 03:12:42 deraadt Exp $
d601 1
a601 1
	local _ifs=$1 _hostname=$2
d603 1
a603 1
	echo "initial-interval 1;" >/etc/dhclient.conf
d605 2
a606 2
	if [[ -n $_hostname ]]; then
		echo "send host-name \"$_hostname\";" >>/etc/dhclient.conf
d612 5
a616 11
	cat >>/etc/dhclient.conf <<__EOT
request subnet-mask,
	broadcast-address,
	routers,
	domain-name,
	domain-name-servers,
	host-name;
__EOT

	cat >>/etc/resolv.conf.tail <<__EOT
lookup file bind
d624 7
a630 4
	if [[ $1 == UP && $2 == "0.0.0.0" ]]; then
		ifconfig $_ifs delete down
		rm /etc/dhclient.conf /etc/resolv.conf.tail
		return 1
d632 4
a635 8

	# Move configuration files to where they will be copied to the
	# installed system. Overwrites configuration information from last
	# successful dhcp attempt.
	mv /etc/dhclient.conf /tmp/dhclient.conf
	mv /etc/resolv.conf.tail /tmp/resolv.conf.tail

	return 0
@


1.380
log
@spacing
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.379 2005/04/13 02:52:52 krw Exp $
d1333 4
a1336 2
	[[ -n $(ifconfig | grep 'status: active') ]] && _locs="$_locs ftp http"
	[[ -x /sbin/mount_nfs ]] && _locs="$_locs nfs"
@


1.379
log
@Display 'none' as v6 default address when no v6 address is detected.
Tighten some code.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.378 2005/04/13 02:18:10 krw Exp $
d98 1
a98 1
		esac	
d1337 1
a1337 1
	echo "\nLet's $MODE the sets!"	
@


1.378
log
@Only show sets locations that might work. e.g. no /sbin/nfs == don't
offer nfs as a location. Eliminate (m)ounted source in favour of an
extra question for disk sources. Bit of cleanup and overall shrinkage.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.377 2005/04/13 02:03:38 krw Exp $
d692 1
a692 1
	ask_until "$_prompt" "$_addr"
d697 1
a697 4
	rtsol)	if [[ ! -x /sbin/rtsol ]]; then
			echo "rtsol not possible - no /sbin/rtsol."
			return
		fi
@


1.377
log
@Allow any valid kbd(8) mapping to be specified (e.g. us.dvorak). Be
more terse both in prompts and output. Show list of major tables only
on request. Problem noted by Matt Jibson.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.376 2005/04/09 23:47:34 deraadt Exp $
d168 1
a168 1
	echo "Cool!  Let's get to it..."
d480 6
a487 7
		cat <<__EOT

The following sets are available. Enter a filename, 'all' to select
all the sets, or 'done'. You may de-select a set by prepending a '-'
to its name.

__EOT
d489 1
d492 1
a492 1
				echo "	[X] $_f"
d494 1
a494 1
				echo "	[ ] $_f"
d500 1
a500 1
		ask "\nFile name? (or 'done')" "$_next"
d1180 4
a1183 2
	get_drive "disk" "$DKDEVS" || return
	_drive=$resp
d1185 5
a1189 5
	get_partition $_drive "$MDFSTYPE" || return
	set -- $resp
	_dev=/dev/$_drive$1
	[[ -n $2 ]] && _fstype="-t $2"
	[[ $_fstype == $MDFSTYPE ]] && _fsopts=$MDFSOPTS
d1191 3
a1193 2
	if [[ -z $(mount | grep "^$_dev") ]]; then
		mount $_fstype -o ro,$_fsopts $_dev /mnt2 || return
d1199 1
a1199 5
	# Can we actually mount NFS filesystems?
	if [ ! -f /sbin/mount_nfs ]; then
		echo "/sbin/mount_nfs not found. Cannot mount NFS filesystems."
		return
	fi
d1201 7
a1207 7
	# Get the IP address of the server
	ask_until "Server IP address or hostname?" "$_nfs_server_ip"
	_nfs_server_ip=$resp

	# Get server path to mount
	ask_until "Filesystem on server to mount?" "$_nfs_server_path"
	_nfs_server_path=$resp
d1210 2
a1211 3
	_nfs_tcp=
	ask_yn "Use TCP transport? (only works with capable NFS server)"
	[[ $resp == y ]] && _nfs_tcp=-T
d1214 1
a1214 4
	if ! mount_nfs $_nfs_tcp -o ro ${_nfs_server_ip}:${_nfs_server_path} /mnt2 ; then
		echo "Cannot mount NFS server."
		return
	fi
a1221 6
	# Can't use tape without /bin/mt.
	if [[ ! -x /bin/mt ]]; then
		echo "/bin/mt not found. Can't $MODE from tape."
		return
	fi

d1333 1
a1333 1
	local _d
d1335 4
a1338 7
	cat <<__EOT

You will now specify the location and names of the $MODE sets you want to
load. You will be able to repeat this step until all of your sets have been
successfully loaded. If you are not sure what sets to $MODE, refer to the
installation notes for details on the contents of each.
__EOT
d1340 1
d1342 1
a1342 6
		_d=
		cat <<__EOT

Sets can be located on a (m)ounted filesystem; a (c)drom, (d)isk or (t)ape
device; or a (f)tp, (n)fs or (h)ttp server.
__EOT
a1343 1
		ask "Where are the $MODE sets? (or 'done')" "$_d"
d1345 1
d1348 1
a1348 1
		c*|C*)	install_cdrom ;;
d1350 4
a1353 6
		f*|F*)	install_url ftp ;;
		h*|H*)	install_url http ;;
		m*|M*)	install_mounted_fs ;;
		n*|N*)	install_nfs ;;
		t*|T*)	install_tape ;;
		*)	;;
a1354 2

		umount -f /mnt2 >/dev/null 2>&1
@


1.376
log
@spaces
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.375 2005/04/09 15:21:28 krw Exp $
d92 8
a99 2
	ask_which "kbd(8) table" "best matches your keyboard" "$_tables" us
	[[ $resp != @@(done|us) ]] && kbd $resp && echo $resp >/tmp/kbdtype
d395 1
a395 1
	echo "$_a "
@


1.375
log
@Create on the installed system all disk, cd and tape devices found in
dmesg.boot, not just the ones that happen to be referenced by the
install process.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.374 2005/04/09 00:47:58 krw Exp $
d458 1
a458 1
	
d689 1
a689 1
	none)	return	
d691 1
a691 1
	rtsol) 	if [[ ! -x /sbin/rtsol ]]; then
d694 1
a694 1
 		fi
d700 2
a701 2
 		;;
 	esac
d759 1
a759 1
	done	
d1165 1
a1165 1
	esac		
@


1.374
log
@Don't error out on mount just because someone confuses (m)ounted with
(d)isk sources and tries to mount an already mounted partition. Using
(d)isk where (m)ounted was meant should now just work.

ok nick@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.373 2005/04/07 20:47:15 krw Exp $
a449 2

	DEVSMADE=$(addel $_dev $DEVSMADE)
d1609 3
a1611 3
	# Make sure any devices we added as a result of makedev() calls
	# are recreated in installed system.
	for _dev in $DEVSMADE; do
a1668 3

# Devices created with makedev().
DEVSMADE=
@


1.373
log
@If a UDF 'c' partition is found on a CD, just mount it without asking
questions. Just as ISO9660 'c' partitions are mounted w/o questions.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.372 2005/04/05 01:00:46 krw Exp $
a1134 2
# $1 - mount point directory is relative to
# $2 - default directory
d1136 1
a1136 1
	local _mp=$1 _dir=$2
d1139 1
a1139 1
		ask_until "Pathname to the sets? (or 'done')" "$_dir"
d1141 3
a1143 2
		# Accept a valid $_mp relative path.
		[[ -d $_mp/$resp ]] && { _dir=$_mp/$resp ; break ; }
a1145 1
		# Otherwise ask again, with original default dir.
d1158 1
a1158 1
	set -- $(disklabel $_drive 2>&1 | grep '^ *c: ')
d1170 1
a1170 2
	install_mounted_fs /mnt2 "$SETDIR"
	umount -f /mnt2 >/dev/null 2>&1
d1174 1
a1174 1
	local _drive _part _fstype _fsopts
d1181 1
a1181 1
	_part=$1
d1183 1
a1183 1
	[[ $2 == $MDFSTYPE ]] && _fsopts=$MDFSOPTS
d1185 4
a1188 3
	mount $_fstype -o ro,$_fsopts /dev/$_drive$_part /mnt2 || return
	install_mounted_fs /mnt2
	umount -f /mnt2 >/dev/null 2>&1
d1217 1
a1217 2
	install_mounted_fs /mnt2
	umount -f /mnt2 >/dev/null 2>&1
d1366 1
a1366 1
		m*|M*)	install_mounted_fs /mnt ;;
d1371 2
@


1.372
log
@Use 'route -qn' for the IPv6 default route command in hostname.if.

Don't use local link address as possible IPv6 manual address.

From todd@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.371 2005/04/03 19:33:59 krw Exp $
d1155 1
a1155 1
	local _drive _part=c _fstype="-t cd9660"
d1160 10
a1169 8
	# Only ask detail questions for non-ISO9660 CD-ROMs.
	if [[ -z $(disklabel $_drive 2>&1 | grep '^ *c: .*ISO9660') ]]; then
		unset _fstype
		get_partition $_drive "cd9660" || return
		set -- $resp
		_part=$1
		[[ -n $2 ]] && _fstype="-t $2"
	fi
d1171 1
a1171 1
	mount $_fstype -o ro /dev/$_drive$_part /mnt2 || return
@


1.371
log
@More shrinkage with a bit of code factoring.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.370 2005/04/02 14:27:08 krw Exp $
d587 1
a587 1
		/inet6/s/prefixlen//
d714 1
a714 1
	echo "!route -n add -host -inet6 default $resp" >>$_hn
@


1.370
log
@Scrounge a few characters of whitespace.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.369 2005/04/02 13:02:52 krw Exp $
d76 1
a76 1
#	MDDISKDEVS  - '/^[sw]d[0-9][0-9]* /s/ .*//p' assumed if not provided
d78 2
a79 1
#	MDXAPERTURE - if not empty, set machdep.allowaperture=value in sysctl.conf
d165 2
a166 11
get_dkdevs() {
	bsort `sed -ne "${MDDISKDEVS:-/^[sw]d[0-9][0-9]* /s/ .*//p}" /var/run/dmesg.boot`
}

get_cddevs() {
	bsort `sed -ne "${MDCDDEVS:-/^cd[0-9][0-9]* /s/ .*//p}" /var/run/dmesg.boot`
}

get_tapedevs () {
	bsort $(egrep "^(ct|mt|st|ts|wt)[[:digit:]]+ " /var/run/dmesg.boot \
		| sed -e "s/ .*//p" )
d178 1
a178 1
	local _devs _d _bd _td
d185 2
a186 4
	_devs=$(sed -ne "/^${_d}\([0-9]\) .*/s//\1/p" /var/run/dmesg.boot)
	_devs=$(bsort $_devs)
	set -- $_devs
	echo "${_bd}${1} ${_td}${1}"
d1231 1
a1231 1
	get_drive "tape drive" "$TAPEDEVS" || return
d1665 3
a1667 2
DKDEVS=$(get_dkdevs)
CDDEVS=$(get_cddevs)
a1668 1
TAPEDEVS=$(get_tapedevs)
@


1.369
log
@Initial IPv6 install/upgrade support.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.368 2005/03/27 15:13:50 krw Exp $
d98 1
a98 1
	cat << __EOT
d114 1
a114 1
	cat << __EOT
d123 1
a123 1
		cat << __EOT
d132 1
a132 1
		cat << __EOT
d139 1
a139 1
			cat << __EOT
d153 1
a153 1
		cat << __EOT
d412 2
a413 2
		grep "^#" /mnt/etc/$_file > /tmp/$_file.new
		[[ -f /tmp/$_file ]] && cat /tmp/$_file >> /tmp/$_file.new
d440 1
a440 1
	ftp ${_ftp_active} -V -n "$1" << __EOT
d488 1
a488 1
		cat << __EOT
d551 1
a551 1
			cat << __EOT
d557 1
a557 1
			y)	cat << __EOT
d609 1
a609 1
	echo "initial-interval 1;" > /etc/dhclient.conf
d612 1
a612 1
		echo "send host-name \"$_hostname\";" >> /etc/dhclient.conf
d618 1
a618 1
	cat >> /etc/dhclient.conf << __EOT
d627 1
a627 1
	cat >> /etc/resolv.conf.tail << __EOT
d674 1
a674 1
			echo "dhcp NONE NONE NONE $_media" >> $_hn
d682 1
a682 1
			echo "inet $_addr $resp NONE $_media" > $_hn
d739 1
a739 1
		route delete -inet default > /dev/null 2>&1
d886 1
a886 1
		route -qn add -host default $(< /mnt/etc/mygate)
d926 1
a926 1
		cat << __EOT
d1181 1
a1181 1
	umount -f /mnt2 > /dev/null 2>&1
d1198 1
a1198 1
	umount -f /mnt2 > /dev/null 2>&1
d1228 1
a1228 1
	umount -f /mnt2 > /dev/null 2>&1
d1353 1
a1353 1
	cat << __EOT
d1363 1
a1363 1
		cat << __EOT
d1426 1
a1426 1
	done < /tmp/fstab > /etc/fstab
d1448 1
a1448 1
			cat << __EOT
d1456 1
a1456 1
	done < /etc/fstab
d1476 1
a1476 1
		if ! fsck -fp ${_dev} > /dev/null 2>&1; then
d1482 1
a1482 1
	done < /etc/fstab
d1535 1
a1535 1
		echo "lookup file bind" > /tmp/resolv.conf
d1537 1
a1537 1
			echo "nameserver $_ns" >> /tmp/resolv.conf
d1562 1
a1562 1
		    >> /mnt/etc/rc.conf.local
d1568 1
a1568 1
		    >> /mnt/etc/rc.conf.local
d1613 1
a1613 1
		    /mnt/etc/sysctl.conf > /tmp/sysctl.conf
d1635 1
a1635 1
	cat << __EOT
d1672 1
a1672 1
dmesg | sed -ne '/^OpenBSD /h;/^OpenBSD /!H;${g;p;}' > /var/run/dmesg.boot
d1713 1
a1713 1
	cat << __EOT
@


1.368
log
@Use new skeleton kbd(8) '-l' to generalize kbd(8) use.  Eliminate
fixed list of available maps and machine dependant md_set_term()
functions.

Any ramdisk with /sbin/kbd present (amd64, cats, i386 at the moment)
will now present list of available keyboard encodings.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.367 2005/03/26 15:40:21 krw Exp $
d465 2
a466 2
# same symbolic name already exists, delete it.
# $1 - IP address
d469 3
a471 1
	sed "/ $2\$/d" /tmp/hosts > /tmp/hosts.new
d474 1
a474 1
	echo "$1 $2" >> /tmp/hosts
d572 1
d589 12
d674 1
a674 1
			echo "dhcp NONE NONE NONE $_media" > $_hn
d688 39
d746 29
d815 1
a815 1
			"#"*|"!"*|"bridge"|""|"rtsol")
d817 1
a817 1
				# IPv6 rtsol and empty lines
d826 5
d868 2
a869 2
					# Ignore IPv6 setup
					continue
d880 2
d1128 3
d1575 2
a1576 1
			    /mnt/etc/sysctl.conf > /tmp/sysctl.conf
d1609 6
@


1.367
log
@More cleanup & cleanup. Use more '[[]]' over '[]' to eliminate "'s,
use pattern matching in '[[]]' rather than case statement.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.366 2005/03/26 05:08:26 krw Exp $
a69 1
#	md_set_term()		  - set up terminal
d82 2
d89 4
a92 1
	md_set_term
d111 1
a111 1
	# Configure the terminal.
@


1.366
log
@More cleanup. ${MODE} -> $MODE.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.365 2005/03/26 03:54:40 krw Exp $
d351 1
a351 1
		[ "$_a" = "$_b" ] && return 0
d374 1
a374 1
		[ "$_a" != "$_b" ] && echo -n "$_b "
d680 1
a680 3
		case $resp in
		none|dhcp) break ;;
		esac
d1055 7
a1061 12
		case $resp in
		done)	return
			;;
		*)
			# Accept a valid $_mp relative path.
			[[ -d $_mp/$resp ]] && { _dir=$_mp/$resp ; break ; }
			# Accept a valid absolute path.
			[[ -d /$resp ]] && { _dir=/$resp ; break ; }
			# Otherwise ask again, with original default dir.
			echo "The directory '$resp' does not exist."
			;;
		esac
@


1.365
log
@More cleanup. Nuke isalphanumeric() and assume anything that
successfully ifconfig's is a valid interface.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.364 2005/03/26 01:40:21 krw Exp $
d1265 1
a1265 1
You will now specify the location and names of the ${MODE} sets you want to
d1267 1
a1267 1
successfully loaded. If you are not sure what sets to ${MODE}, refer to the
d1338 1
a1338 1
	# If no /etc/fstab was created, we have nowhere to ${MODE} to.
d1361 1
a1361 1
		and restart the ${MODE}.
d1535 1
a1535 1
	[ -x /mnt/${MODE}.site ] && /mnt/usr/sbin/chroot /mnt /${MODE}.site
d1540 1
a1540 1
CONGRATULATIONS! Your OpenBSD ${MODE} has been successfully completed!
@


1.364
log
@Start some delayed cleanup and shrinkage. Today: ': ;' -> ':;' in
while statements.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.363 2005/03/14 02:29:33 krw Exp $
a689 13
# Returns true if $1 contains only alphanumerics
isalphanumeric() {
	local _n=$1
	while [[ ${#_n} -ne 0 ]]; do
		case $_n in
		[A-Za-z0-9]*)	;;
		*)		return 1;;
		esac
		_n=${_n#?}
	done
	return 0
}

d711 2
a712 9
		# Interface names must be alphanumeric only. We check to avoid
		# configuring backup or temp files, and to catch the "*" case.
		if ! isalphanumeric "$if"; then
			continue
		fi
		ifconfig $if > /dev/null 2>&1
		if [ $? -ne 0 ]; then
			continue
		fi
@


1.363
log
@Present list of dns servers supplied by dhcp as blank separated list,
not newline separted list.

Spotted by & ok deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.362 2005/03/08 17:56:00 deraadt Exp $
d258 1
a258 1
	while : ; do
d299 1
a299 1
	while : ; do
d480 1
a480 1
	while : ; do
d530 1
a530 1
	while : ; do
d678 1
a678 1
	while : ; do
d985 1
a985 1
	while : ; do
d1075 1
a1075 1
	while : ; do
d1229 1
a1229 1
	while : ; do
d1291 1
a1291 1
	while : ; do
@


1.362
log
@append to rc.conf.local; david
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.361 2005/03/08 13:13:54 deraadt Exp $
d1432 1
a1432 1
	local _dn _ns
d1443 7
a1449 2
		# Get nameserver address(es).
		_ns=$(sed -ne '/^nameserver /s///p' /tmp/resolv.conf)
@


1.361
log
@ask about ntpd(8) in install script; ok krw henning
this is pending an improvement from henning to ntpd to make it utterly
silent during startup.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.360 2005/03/07 00:05:59 deraadt Exp $
d1487 1
a1487 1
		    > /mnt/etc/rc.conf.local
d1493 1
a1493 1
		    > /mnt/etc/rc.conf.local
@


1.360
log
@move to 3.7-beta
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.359 2005/02/16 02:04:31 krw Exp $
d1487 6
@


1.359
log
@Validate successful installation of required sets by seeing if they
are still in DEFAULTSETS. Better than checking random file/dir we
expect set to provide.

Give the user the option to complete an installation/upgrade without
installing all the sets we think are required.

Shrinks code a bit. From an idea by beck@@.

ok deraadt@@ nick@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.358 2005/02/13 06:57:59 david Exp $
d1570 1
a1570 1
VERSION=36
@


1.358
log
@zap whitespace at eol; ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.357 2004/11/28 04:15:09 krw Exp $
d4 1
a4 1
# Copyright (c) 1997-2004 Todd Miller, Theo de Raadt, Ken Westerback
d1263 1
a1263 9
# Check that required sets were successfully installed by checking
# for the presence of a 'random' selection of their contents.
#
# Required sets are:
#	1) bsd
#	2) baseXX
#	3) etcXX
#
# If a 'problem' set is found, add it back to DEFAULTSETS.
d1265 1
a1265 1
	local _insane
d1267 5
a1271 28
	# Check if bsd is installed and >0 bytes in size.
	if [[ ! -s /mnt/bsd ]]; then
		_insane=y
		DEFAULTSETS=$(addel bsd $DEFAULTSETS)
		cat << __EOT
+*** 'bsd' must be (re)installed: no kernel found.
__EOT
	fi

	# Check if baseXX is installed.
	if [[ ! -d /mnt/sbin || ! -d /mnt/dev ]]; then
		_insane=y
		DEFAULTSETS=$(addel base${VERSION}.tgz $DEFAULTSETS)
		cat << __EOT
+*** 'base${VERSION}.tgz' must be (re)installed: /sbin or /dev is missing.
__EOT
	fi

	# Check if etcXX is installed.
	if [[ ! -s /mnt/etc/rc ]]; then
		_insane=y
		DEFAULTSETS=$(addel etc${VERSION}.tgz $DEFAULTSETS)
		cat << __EOT
+*** 'etc${VERSION}.tgz' must be (re)installed: /etc/rc is missing.
__EOT
	fi

	[[ -n $_insane ]] && return 1
d1273 1
d1607 3
@


1.357
log
@When dhcp configuration is attempted add the network interface to a
'dhcp' group . Present 'dhcp' as the default value for the ip address
of interfaces in the 'dhcp' group, not the address the previous dhcp
configuration might have obtained. Makes it 'safer' to restart
installs after network configuration.

Suggested by/ok mickey@@, ok deraadt@@, henning@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.356 2004/11/11 21:48:06 deraadt Exp $
d637 1
a637 1
	else	
@


1.356
log
@typo; bad krw
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.355 2004/10/12 21:57:07 krw Exp $
d612 1
d633 1
a633 1
	local _ifs=$1 _media=$2 _name=$3 _hn=$4 _prompt
d635 8
a642 4
	set -- $(v4_info $_ifs)
	if [[ -n $2 ]]; then
		ifconfig $_ifs inet $2 delete
		[[ $2 != "0.0.0.0" ]] && { _addr=$2; _mask=$3; }
d660 1
@


1.355
log
@
Bring the tape install code up to current standards and
add a few enhancements:

- allow installation of all files on a tape without rewinding
- ask for and use a blocksize for each file
- provide a list of tape devices to users
- force use of 'nr<tape>' devices
- check for /bin/mt before trying to install

makedev() is simplified a bit to rely on errors from MAKEDEV rather
than checking for specific devices being present.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.354 2004/10/02 18:45:08 krw Exp $
d1151 1
a1151 1
	Install_mounted_fs /mnt2
@


1.354
log
@Minor code cleanup and shrinkage. No functional change.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.353 2004/09/29 00:05:14 krw Exp $
d168 5
d444 1
a444 4
# Check for the existence of the device nodes for the
# supplied device name. If they are missing (as indicated
# by r${1}c not being found) then create them. In either
# case, return true if the nodes exist and false if not.
d446 1
a446 1
# $1 = name of the device that is about to be used.
d448 1
a448 4
	local _dev=$1 _node=/dev/r${1}c

	# If the device node exists, don't need to create it.
	[[ -c $_node ]] && return 0
d451 1
a451 1
		echo "No /dev/MAKEDEV. Can't create device nodes for ${_dev}."
d455 1
a455 1
	(cd /dev; sh MAKEDEV $_dev)
d457 1
a457 5
	# If the device nodes still do not exist, assume MAKEDEV issued a useful
	# error message and return false.
	[[ -c $_node ]] || return 1

	DEVSMADE=`addel $_dev $DEVSMADE`
d1151 1
a1151 1
	install_mounted_fs /mnt2
d1156 1
a1156 1
	local _xcmd
d1158 3
a1160 11
	# Get the name of the tape from the user.
	cat << __EOT

The installation program needs to know which tape device to use. Make
sure you use a "no rewind on close" device.

__EOT
	ask_until "Name of tape device?" "${TAPE##*/}"
	TAPE=/dev/${resp##*/}
	if [ ! -c $TAPE ]; then
		echo "$TAPE does not exist or is not a character special file."
a1162 1
	export TAPE
d1164 5
a1168 4
	# Rewind the tape device
	echo -n "Rewinding ${TAPE} (mt rewind)..."
	if ! mt rewind ; then
		echo "FAILED."
d1171 4
d1177 14
a1190 20
	# Get the file number
	resp=
	while [ -z "$resp" ]; do
		ask "File number?"
		case $resp in
		[1-9]*)	_nskip=$(( $resp - 1 ))
			;;
		*)	echo "Invalid file number ${resp}."
			# force loop to repeat
			resp=
			;;
		esac
	done

	# Skip to correct file.
	if [ $_nskip -ne 0 ]; then
		echo -n "Skipping to source file (mt fsf ${_nskip})..."
		if ! mt fsf $_nskip ; then
			echo "FAILED. Could not skip $_nskip files."
			return
a1191 9
		echo "done."
	fi

cat << __EOT

There are 2 different ways the file can be stored on tape:

1) an image of a gzipped tar file
2) a standard tar image
d1193 10
a1202 1
__EOT
d1204 1
a1204 14
	resp=
	while [ -z "$resp" ]; do
		ask "Which way is it?" 1
		case $resp in
		1)	_xcmd="tar zxvphf -"
			;;
		2)	_xcmd="tar xvphf -"
			;;
		*)	echo "Invalid response: $resp."
			# force loop to repeat
			resp=
			;;
		esac
		( cd /mnt; dd if=$TAPE | $_xcmd )
a1205 1
	echo "Extraction complete."
d1614 1
@


1.353
log
@Code cleanup and shrinkage (~2K).

Factor out drive/partition handling for CD and disk installs. Should
only affect installs/upgrades from non-ISO CDs and unmounted disk partitions.

Tested by Otto@@.

'It is that high risk time' deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.352 2004/09/16 22:23:44 mcbride Exp $
d1661 3
a1663 5
if [ -z "$EDITOR" ] ; then
	EDITOR=ed
	[ -x /usr/bin/vi ] && EDITOR=vi
	export EDITOR
fi
@


1.352
log
@Set the console device speed before instead of after selecting it as the
console. Fixes booting on Soekris net4501 without a cable connected.

ok tom@@ markus@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.351 2004/08/09 18:08:50 deraadt Exp $
d190 37
d304 1
a304 2
# Ask for the user to select a device from a list generated by scanning
# /var/run/dmesg.boot, and make the device if it doesn't exist.
d306 1
a306 1
# $1 = device name (disk, cd, etc.)
d308 3
a310 3
# $3 = list of devices from /var/run/dmesg.boot scan
# $4 = default device. If it is not specified, use the first device in $3
# $5 = error message if no devices in $3, defaults to 'No $1s found.'
d312 1
a312 1
# $resp holds device selected at exit, or 'done'
d314 1
a314 1
	local _name=$1 _query=$2 _devs=$3 _defdev=$4 _err=$5
d316 2
a317 2
	set -- $_devs
	if [[ $# -lt 1 ]]; then
d322 1
a322 1
	: ${_defdev:=$1}
d324 2
a325 2
	# Eliminate extraneous (especially trailing) whitespace in _devs.
	_devs="$*"
d327 1
a327 1
	while : ; do
d331 1
a331 2
		ask "Available ${_name}s are: ${_devs}.\nWhich one ${_query}? (or 'done')" "$_defdev"
		[[ $resp == done ]] && break
d335 2
a336 5
		if isin "$resp" $_devs; then
			makedev $resp && break
		else
			echo "'$resp' is not a valid choice."
		fi
d448 2
a449 6
	# Don't need to make network interface device nodes.  If the device is
	# just a number then ignore it. This is used when selecting a serial
	# console speed.  If the device node exists, don't need to create it.
	if isin $_dev $IFDEVS || [[ -c $_node || -z ${_dev##+([0-9])} ]] ; then
		return 0
	fi
d1090 1
a1090 1
	install_files "file://$_dir" "`ls -l $_dir`"
d1094 1
a1094 4
	local _drive _part _fstype _directory _n

	ask_which "CD-ROM" "contains the ${MODE} media" "$CDDEVS"
	[[ $resp == done ]] && return
d1096 1
d1099 7
a1105 67
	# If it is an ISO9660 CD-ROM, we don't need to ask any other questions
	_n=0
	until disklabel $_drive >/tmp/label.$_drive 2>&1; do
		# Try up to 6 times to access the CD
		if egrep -q '(Input/output error)|(sector size 0)' /tmp/label.$_drive; then
			_n=$(( $_n + 1 ))
			if [ _n -le 5 ]; then
				echo "I/O error accessing $_drive; retrying"
				sleep 10
			else
				echo "Cannot access $_drive."
				return
			fi
		else
			break
		fi
	done

	echo
	if grep -q '^ *c: .*ISO9660' /tmp/label.$_drive; then
		_fstype=cd9660
		_part=c
	else
		# Get partition from user
		resp=
		while [ -z "$resp" ] ; do
			ask "CD-ROM partition to mount? (normally 'c')" c
			case $resp in
			[a-p])
				_part=$resp
				;;
			*)	echo "Invalid response: $resp"
				# force loop to repeat
				resp=
				;;
			esac
		done

		# Ask for filesystem type
		cat << __EOT

Two CD-ROM filesystem types are currently supported by this program:
cd9660		ISO-9660
ffs		Berkeley Fast Filesystem

__EOT
		resp=
		while [ -z "$resp" ] ; do
			ask "Which filesystem type?" cd9660
			case $resp in
			cd9660|ffs)
				_fstype=$resp
				;;
			*)	echo "Invalid response: '$resp'"
				# force loop to repeat
				resp=
				;;
			esac
		done
	fi

	rm -f /tmp/label.$_drive

	# Mount the CD-ROM
	if ! mount -t ${_fstype} -o ro /dev/${_drive}${_part} /mnt2 ; then
		echo "Cannot mount CD-ROM drive."
		return
d1108 1
d1113 2
a1114 9
# Mount a disk on /mnt2. The set of disk devices to choose from
# is $DKDEVS.
# returns 0 on success, 1 on failure
mount_a_disk() {
	local _drive _def_partition _partition_range _partition
	local _fstype _fsopts

	ask_which "disk" "contains the ${MODE} sets" "$DKDEVS"
	[[ $resp == done ]] && return 1
d1116 1
d1119 5
a1123 2
	# Get partition
	cat << __EOT
d1125 3
a1127 80
The following partitions have been found on $_drive:

__EOT
	disklabel $_drive 2>/dev/null | grep '^  .:'
	echo
	_likely_partition_range=`disklabel $_drive 2>/dev/null | \
		sed -n	-e '/swap/s/.*//' -e '/unused/s/.*//' \
			-e '/^  .:/{s/^  \(.\).*/\1/;H;}' \
			-e '${g;s/\n//g;s/^/[/;s/$/]/p;}'`
	_partition_range=`disklabel $_drive 2>/dev/null | \
		sed -n	-e '/^  .:/{s/^  \(.\).*/\1/;H;}' \
			-e '${g;s/\n//g;s/^/[/;s/$/]/p;}'`
	_def_partition=`echo $_likely_partition_range | \
		sed -n 's/^\[\(.\).*\]/\1/p'`
	if [ -z "$_def_partition" ]; then
		_def_partition=`echo $_partition_range | \
			sed -n 's/^\[\(.\).*\]/\1/p'`
		if [ -z "$_def_partition" ]; then
			echo "There are no usable partitions on that disk"
			return 1
		fi
	fi

	resp=
	while [ -z "$resp" ]; do
		ask "Partition?" "$_def_partition"
		case $resp in
		$_partition_range)
			_partition=$resp
			;;
		*)	echo "Invalid response: $resp"
			# force loop to repeat
			resp=
			;;
		esac
	done

	# Ask for filesystem type
	cat << __EOT

The following filesystem types are supported:
default		(deduced from the disklabel)
ffs
$MDFSTYPE
__EOT

	resp=
	while [ -z "$resp" ]; do
		ask "Which filesystem type?" default
		case $resp in
		default)
			;;
		ffs)	_fstype="-t ffs"
			_fsopts=async
			;;
		$MDFSTYPE)
			_fstype="-t $resp"
			_fsopts=$MDFSOPTS
			;;
		*)	echo "Invalid response: $resp"
			# force loop to repeat
			resp=
			;;
		esac
	done

	# Mount the disk read-only
	if ! mount $_fstype -o ro,$_fsopts /dev/${_drive}${_partition} /mnt2; then
		echo "Cannot mount disk."
		return 1
	fi

	return 0
}

install_disk() {
	if mount_a_disk; then
		install_mounted_fs /mnt2
		umount -f /mnt2 > /dev/null 2>&1
	fi
d1690 1
@


1.351
log
@move to 3.6-beta
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.350 2004/07/25 03:33:04 krw Exp $
d1672 1
a1672 1
	echo "set tty $_bd\nstty $_bd $resp" >>/mnt/etc/boot.conf
@


1.350
log
@Don't need to specify 9600 as the default speed, since it is first on the
list of speeds and thus the default default.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.349 2004/07/18 03:26:21 krw Exp $
d1736 1
a1736 1
VERSION=35
@


1.349
log
@Make bsd.rd a default set.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.348 2004/07/18 01:12:32 deraadt Exp $
d1670 1
a1670 1
	ask_which "speed" "should $_bd use" "9600 19200 38400 57600 115200" 9600
@


1.348
log
@spaces
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.347 2004/07/18 00:46:14 krw Exp $
d1765 1
a1765 1
DEFAULTSETS="bsd"
@


1.347
log
@For set installation via URL or NFS, assume the network has been configured
to the user's satisfaction.

ok tdeval@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.346 2004/07/17 03:46:12 krw Exp $
d513 1
a513 1
		_hn=/tmp/hostname.$_ifs 
d615 1
a615 1
	fi	
d619 1
a619 1
	
@


1.346
log
@Delete unused local vars.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.345 2004/07/17 03:26:07 krw Exp $
a684 2
	DIDNET=y

a928 2
	donetconfig

a1249 2
	donetconfig

a1598 4

	[[ -n $DIDNET ]] && return

	DIDNET=y
@


1.345
log
@Add 'stty <tty> <speed>' line to boot.conf if serial console is
made the default console. Ensures specified speed is actually used.

Pointed out by Derick Siddoway and Bob Humphrey.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.344 2004/07/17 02:13:53 krw Exp $
d322 1
a322 1
	local	_a=$1 _b _seen=false
@


1.344
log
@Don't add '/'s to timezone path when null input entered
as sub-timezone.

Pointed out by cloder@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.343 2004/06/26 20:10:17 krw Exp $
a1679 1
	echo "set tty $_bd" >>/mnt/etc/boot.conf
d1682 1
@


1.343
log
@Allow change of default console to first serial device during install. Used in
i386 only at this time.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.342 2004/06/22 20:43:58 krw Exp $
d1385 5
a1389 5
			if [[ $resp == ? ]]; then
				ls -F $_zonepath
			else
				_zonepath=$_zonepath/$resp
			fi
@


1.342
log
@Don't make xetc a default install set.

ok matthieu@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.341 2004/06/22 00:42:11 matthieu Exp $
d174 16
d416 4
a419 3
	# Don't need to make network interface devices nodes. If the device
	# nodes exist, don't need to create them.
	if isin $_dev $IFDEVS || [[ -c $_node ]] ; then
d1658 3
a1660 1
	ask_yn "Do you wish sshd(8) to be started by default?" yes
d1666 7
a1672 1
	[[ -n $MDXAPERTURE ]] || return
d1674 12
a1685 5
	ask_yn "Do you expect to run the X Window System?" yes
	if [[ $resp == y ]]; then
		sed -e "/^#\(machdep\.allowaperture=${MDXAPERTURE}\)/s//\1	/" \
		    /mnt/etc/sysctl.conf > /tmp/sysctl.conf
	fi
d1762 5
a1766 4
# Scan /var/run/dmesg.boot for disks and cds
DKDEVS=`get_dkdevs`
CDDEVS=`get_cddevs`
IFDEVS=`get_ifdevs`
@


1.341
log
@introduce the new xetc set. ok deraadt@@, miod@@, krw@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.340 2004/06/20 05:13:14 krw Exp $
d1746 1
a1746 1
	isin $_set xbase xshare xfont xserv site && continue
@


1.340
log
@If all default sets have been successfully installed, make [done] the
default answer to 'Where are the install sets?'.

Requested by various, most recently Henning and Theo.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.339 2004/06/13 22:00:50 deraadt Exp $
d1743 2
a1744 2
for _set in base etc misc comp man game xbase xshare xfont xserv site ; do
	[[ $MODE == upgrade && $_set == etc ]] && continue
@


1.339
log
@if bsd.mp exists... let a user install it
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.338 2004/04/12 22:55:11 krw Exp $
d1436 2
d1447 1
d1453 2
a1454 1
		ask "Where are the ${MODE} sets? (or 'done')"
@


1.338
log
@Refactor network initialization code into explicit v4 routines to
prepare for v6 initialization. Minor verbiage changes, and not asking
for v4 default route if no v4 addresses were configured are the only
user visible changes.

ok deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.337 2004/03/23 02:39:39 krw Exp $
d1737 1
a1737 1
THESETS="bsd bsd.rd $MDSETS"
@


1.337
log
@Update copyrights to 2004.

ok deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.336 2004/03/18 00:25:12 krw Exp $
d487 2
a488 2
configure_all_interfaces() {
	local _IFDEVS=$IFDEVS _ifs
d491 2
a492 4
		_IFDEVS=`rmel "$_ifs" $_IFDEVS`

		ask_which "interface" "do you wish to initialize" "$_IFDEVS" "" \
		    "No more interfaces to initialize"
d496 32
a527 1
		configure_ifs $_ifs || _ifs=
d534 1
a534 1
inet_info() {
d574 1
a574 1
	set -- $(inet_info $_ifs)
d591 2
a592 36
configure_ifs() {
	local _ifs=$1 _addr _mask _name _prompt _media _config

	set -- $(inet_info $_ifs)
	[[ $1 == UP ]] && ifconfig $_ifs delete down
	[[ -n $2 && $2 != "0.0.0.0" ]] && { _addr=$2; _mask=$3; }

	# Get symbolic name - will be used in DHCP requests.
	ask "Symbolic (host) name for $_ifs?" "$(hostname -s)"
	_name=$resp

	# Get and apply media options.
	_media=$(ifconfig -m $_ifs | grep "media ")
	if [[ -n $_media ]]; then
		cat << __EOT
The default media for $_ifs is
$(ifconfig -m $_ifs | sed -n '/supported/D;/media:/p')
__EOT
		ask_yn "Do you want to change the default media?"
		case $resp in
		y)	cat << __EOT
Supported media options for $_ifs are:
$_media
__EOT
			ask "Media options for $_ifs?"
			_media=$resp
			ifconfig $_ifs $_media down || return 1
			;;
		n)	_media=
			;;
		esac
	fi

	# Get address and mask.
	_prompt="IP address for ${_ifs}?"
	[[ -x /sbin/dhclient ]] && _prompt="$_prompt (or 'dhcp')"
d594 9
d605 1
d607 4
a610 2
			echo "DHCP not supported - no /sbin/dhclient found."
			return 1
a611 4
		dhcp_request $_ifs "$_name" || dhcp_request $_ifs || return 1
		_config="dhcp NONE NONE"
		# Fake address for the hosts file.
		_addr=127.0.0.1
d615 4
a618 3
		_mask=$resp
		ifconfig $_ifs inet $_addr netmask $_mask $_media up || return 1
		_config="inet $_addr $_mask"
d621 4
d626 17
a642 5
	# Save configuration information.
	echo "$_config NONE $_media" > /tmp/hostname.$_ifs
	addhostent $_addr $_name
	return 0
 }
d1583 1
a1583 1
	local _dn _ns _dr
d1589 1
a1589 1
	configure_all_interfaces
d1623 2
a1624 13
	# Get/Confirm the default route.
	_dr=$(route -n show | sed -ne '/^default */{s///; s/ .*//; p;}')
	[[ -f /tmp/dhclient.conf ]] && _dr=dhcp
	while : ; do
		ask_until "Default route? (IP address, 'dhcp' or 'none')" "$_dr"
		case $resp in
		none|dhcp) break ;;
		esac
		route delete default > /dev/null 2>&1
		route -n add -host default "$resp" && { echo "$resp" >/tmp/mygate ; break ; }
		# Put the old default route back. The new one did not work.
		route -n add -host default $_dr >/dev/null 2>&1
	done
@


1.336
log
@Don't ask for timezone info during an upgrade.

Suggestion by Tom Cosgrove.

ok miod@@ millert@@ deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.335 2004/03/16 01:11:57 deraadt Exp $
d4 1
a4 1
# Copyright (c) 1997-2003 Todd Miller, Theo de Raadt, Ken Westerback
@


1.335
log
@save 2 bytes due to tabs
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.334 2004/03/14 20:55:02 krw Exp $
a1644 2

	set_timezone
@


1.334
log
@Fix sane_install() tests to use relevant directories/files. Tighten
emitted error messages.

Change default response to 'Use the nameserver now?' from a 'y' to
'yes' to be consistant with other ask_yn() usages.

ok beck@@ deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.333 2004/03/09 03:58:34 krw Exp $
d248 1
a248 1
	done		
@


1.333
log
@URL-encode all usercode/password characters between 0x20 and 0x7e so that
more weird usercodes and passwords work. Embedded blanks especially.

ok beck@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.332 2004/02/28 20:24:14 krw Exp $
d1385 1
a1385 3

*** /bsd is not present in the installed system, or is 0 bytes long. OpenBSD
    cannot boot without a valid kernel! 'bsd' must be (re)installed.
d1390 1
a1390 1
	if [[ ! -x /mnt/bin/cat || ! -x /mnt/dev/MAKEDEV ]]; then
d1394 1
a1394 4

*** One or both of the executable files /bin/cat and /dev/MAKEDEV are not
    present in the installed system. This indicates that executable files
    OpenBSD requires are missing. 'base${VERSION}' must be (re)installed.
d1399 1
a1399 1
	if [[ ! -d /mnt/etc || ! -d /mnt/usr/share/zoneinfo || ! -d /mnt/dev ]]; then
d1403 1
a1403 4

*** One or more of the directories /etc, /usr/share/zoneinfo and /dev are not
    present in the installed system. This indicates that directories OpenBSD
    requires are missing. 'etc${VERSION}' must be (re)installed.
d1599 1
a1599 1
		ask_yn "Use the nameserver now?" y
@


1.332
log
@Revert v1.314 changes adding '~' to user supplied relative ftp paths,
since today's ftp/fetch.c commit fixes real issue, and v1.314 broke
'ftp' user.

Problems with 'ftp' user reported by Stephen Kirkham of UofA.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.331 2004/02/27 18:02:46 deraadt Exp $
d826 1
a826 1
# section 3.1, and now supported by our in-tree ftp:
d828 2
a829 3
#    ':' -> '%3a'
#    '@@' -> '%40'
#    '/' -> '%2f'
d831 4
a834 2
# *NOTE* quotes around $1 are required to preserve trailing or
# embeddded blanks in usercodes and passwords!
d836 35
a870 1
	echo "$1" | sed -e 's/:/%3a/g' -e 's/@@/%40/g' -e 's/\//%2f/g'
@


1.331
log
@move to 3.5-beta
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.330 2004/02/08 20:38:02 krw Exp $
d857 1
a857 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _home _passwd
a954 1
		[[ $_ftp_server_dir == /* || $_ftp_server_dir == ~* ]] || _home="~/"
d957 1
a957 1
	eval _url_base=$_url_base\$_${_url_type}_server_ip/$_home\$_${_url_type}_server_dir
@


1.330
log
@Shave a few more characters.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.329 2004/02/08 17:42:28 krw Exp $
d1677 1
a1677 1
VERSION=34
@


1.329
log
@Replace 'localhost' with '127.0.0.1' and add -q to route invocations
in enable_network(). From /etc/netstart.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.328 2004/02/08 11:31:43 krw Exp $
d510 1
a510 1
		/inet/s/inet//p'
d626 1
a626 2
	local _n
	_n=$1
d1586 1
a1586 1
		route -n add -host default "$resp" && { echo "$resp" > /tmp/mygate ; break ; }
@


1.328
log
@Add loopback routes late during upgrades, as /etc/netstart does now.
Scavange a couple of characters while in the area.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.327 2004/02/08 01:01:10 krw Exp $
d653 1
a653 1
	ifconfig lo0 inet localhost
d732 1
a732 1
					[ "$alias" ] && rtcmd="; route -n add -host $name 127.0.0.1"
d751 1
a751 1
		route -n add -host default $(< /mnt/etc/mygate)
@


1.327
log
@Fix typo: 2>&2 -> 2>&1.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.326 2004/02/07 17:45:04 krw Exp $
d651 2
a652 1
	# set the address for the loopback interface
a654 4
	# use loopback, not the wire
	route -n add -host `hostname` localhost > /dev/null
	route -n add -net 127 127.0.0.1 -reject > /dev/null

d744 1
a744 1
		done < /mnt/etc/hostname.$if
d750 2
a751 2
		route delete default > /dev/null 2>&1
		route -n add -host default `cat /mnt/etc/mygate`
d753 4
@


1.326
log
@Simplify inet line processing in inet_info().
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.325 2004/01/11 18:57:02 krw Exp $
d1588 1
a1588 1
		route -n add -host default $_dr > /dev/null 2>&2
@


1.325
log
@With wonderful new dhclient there is no need to try to kill a running
client or to run it with -1.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.324 2003/12/21 21:45:41 krw Exp $
d502 1
a502 2
# Obtain and output the inet information related to the given
# interface. Should output '<up/down> <addr> <netmask> <broadcast>'.
d507 2
a508 5
		1s/.*<UP,.*$/UP/p
		1s/.*<.*>*$/DOWN/p
		/media:/s/^.*$//
		/status:/s/^.*$//
		/inet/s/--> [0-9.][0-9.]*//
d510 1
a510 2
		/inet/s/broadcast//
		/inet/s/inet// p'
@


1.324
log
@Bowing to the relentless pressure from Nick Holland, change the default answer
to 'Use the nameserver now?' to 'yes'. ok deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.323 2003/12/04 20:17:02 deraadt Exp $
d548 1
a548 2
	kill_dhclient
	dhclient -1 $_ifs
a703 1
				kill_dhclient
a1496 8
}

# Try to kill a running dhclient.
kill_dhclient() {
	if [[ -f /var/run/dhclient.pid ]]; then
		kill -HUP $(sed -ne "1p" /var/run/dhclient.pid) > /dev/null 2>&1
		rm -f /var/run/dhclient.pid
	fi
@


1.323
log
@shorten a teeny bit more
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.322 2003/12/04 18:43:38 deraadt Exp $
d1588 1
a1588 1
		ask_yn "Use the nameserver now?"
@


1.322
log
@ask if sshd should be on by default (default to yes, still); tested by nick
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.321 2003/09/22 01:31:39 krw Exp $
d196 1
a196 1
ask () {
d224 1
a224 1
ask_until () {
d237 1
a237 1
ask_yn () {
d261 1
a261 1
ask_which () {
d351 1
a351 1
save_comments () {
d365 1
a365 1
edit_tmp_file () {
d374 1
a374 1
manual_net_cfg () {
d506 1
a506 1
inet_info () {
d523 1
a523 1
dhcp_request () {
d780 1
a780 1
install_files () {
d850 1
a850 1
ftp_error () {
d1502 1
a1502 1
kill_dhclient () {
@


1.321
log
@Introduce a function ask_yn() to use when asking 'yes or no'
questions.

ask_yn() always returns a 'y' or 'n' in $resp, vastly simplifying the
logic used to check the user response.

ask_yn() insists on the user responding with a 'y', 'n', 'yes', or
'no'. Case is ignored.

Previously almost any input was accepted as either a yes or a no
depending on the question. ask_yn() reduces the chance of user error,
e.g.  by answering the next question (default route) instead of the
posed one (Use DNS server now?).

All 'yes or no' questions now use ask_yn(). All questions show the
full default answer, i.e. 'yes' or 'no' rather than 'y' or 'n'.

Some minor logic cleanups of the usual sort, but no changes to logic
flow or questions bar minor verbiage adjustment.

Inspired by a Bob Beck install nit.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.320 2003/08/23 22:22:02 krw Exp $
d1616 7
a1622 1
set_machdep_apertureallowed() {
d1628 1
a1628 1
			/mnt/etc/sysctl.conf > /tmp/sysctl.conf
@


1.320
log
@If any interface has been configured using DHCP, assume the default route
will be set by DHCP.

ok drahn@@ beck@@ henning@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.319 2003/08/17 18:51:54 krw Exp $
d69 1
a69 1
#	md_prep_disklabel()	  - label the root disk
d83 1
a83 1
	[ "$TERM" ] && return
d92 2
d124 1
a124 1
		ask "Proceed with upgrade?" n
d140 1
a140 1
			ask "Skip disk initialization?" n
d142 1
a142 1
			ask "Proceed with install?" n
d147 3
a149 4
	case $resp in
	y*|Y*)	echo "Cool!  Let's get to it..."
		;;
	*)	cat << __EOT
d155 3
a157 2
		;;
	esac
d196 1
a196 1
ask() {
d231 20
d368 2
a369 5
	ask "Edit $_file with ${EDITOR}?" n
	case $resp in
	y*|Y*)	${EDITOR} /tmp/$_file
		;;
	esac
d375 1
a375 1
	ask "Do you want to do any manual network configuration?" n
d377 1
a377 5
	case $resp in
	y*|Y*)	echo "Type 'exit' to return to ${MODE}."
		sh
		;;
	esac
d586 1
a586 1
		ask "Do you want to change the default media?" n
d588 1
a588 1
		y*|Y*)	cat << __EOT
d596 1
a596 1
		*)	_media=
d812 2
a813 4
	ask "Ready to $MODE sets?" y
	case $resp in
	n*|N*)	return ;;
	esac
d874 3
a876 6
	ask "Display the list of known $_url_type servers?" "${_get_server_list:-y}"
	case $resp in
	n*|N*)	_get_server_list=n
		;;
	*)
		_get_server_list=y
d891 1
a891 2
		;;
	esac
d925 2
a926 2
		-A)	resp=n ;;
		*)	resp=y ;;
d929 3
a931 5
		ask "Does the server support passive mode ftp?" "$resp"
		case $resp in
		n*|N*)	_ftp_active=-A ;;
		*)	unset _ftp_active ;;
		esac
d1201 3
a1203 7
	ask "Use TCP transport? (only works with capable NFS server)" n
	case $resp in
	y*|Y*)	_nfs_tcp=-T
		;;
	*)	_nfs_tcp=
		;;
	esac
d1588 2
a1589 5
		ask "Use the nameserver now?" y
		case $resp in
		y*|Y*)	cp /tmp/resolv.conf /tmp/resolv.conf.shadow
			;;
		esac
d1617 1
a1617 1
	[ "$MDXAPERTURE" ] || return
d1619 2
a1620 3
	ask "Do you expect to run the X Window System?" y
	case $resp in
	y*|Y*)
d1623 1
a1623 2
		;;
	esac
@


1.319
log
@'Security' fix/cleanup/shrinkage.

Don't leave ftp password in a global variable. It is re-initialized
each time it is used anyway. Use a shorter (_passwd vs
_ftp_server_password) local variable name to save a few bytes.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.318 2003/08/17 18:18:50 krw Exp $
d1594 1
@


1.318
log
@Message clarification & cleanup.

Replace the generic 'Done - no available Xs found.' message with two
more relevant ones. Suggested several times, most memorably by Todd@@.

a) For selection of disks or cds to install from, and for selection of
the root disk, make it 'No Xs found.'.

b) For processing the list of disks or interfaces to initialize, make
it 'No more Xs to initialize.'.

Delete get_root() as it is only called in one place, and insert code
at that location.

Reclaim a few characters by putting ask_which() punctuation where
message is output rather than repeating it where message passed.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.317 2003/08/16 20:37:24 krw Exp $
d849 1
a849 1
#	_ftp_server_password, and _ftp_active must be global.
d851 1
a851 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _home
d941 1
a941 1
		_ftp_server_password=root@@`hostname`
d947 1
a947 1
			_ftp_server_password=$resp
d956 1
a956 1
		_url_base=$_url_base$(encode_for_url "$_ftp_server_login"):$(encode_for_url "$_ftp_server_password")@@
d962 1
a962 1
		_file_list=$(ftp_list_files "$_ftp_server_ip" "$_ftp_server_login" "$_ftp_server_password" "$_ftp_server_dir")
@


1.317
log
@Minor cosmetic cleanup.

Use '<msg>...done.' consistantly by replacing last five varient uses. Out with
'<msg> ... done.', '<msg>...Done.', etc.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.316 2003/08/11 14:52:42 deraadt Exp $
d235 2
a236 1
# $4 = default device. If it is not specified, use the first device in $3.
d240 1
a240 1
	local _name=$1 _query=$2 _devs=$3 _defdev=$4
d244 1
a244 1
		echo "Done - no available ${_name}s found."
d257 1
a257 1
		ask "Available ${_name}s are: ${_devs}.\nWhich one $_query (or 'done')" "$_defdev"
a404 28
get_rootdisk() {
	local _defdsk

	if [[ $MODE == install && ! -f /etc/fstab ]]; then
		cat << __EOT

You will now initialize the disk(s) that OpenBSD will use. To enable all
available security features you should configure the disk(s) to allow the
creation of separate filesystems for /, /tmp, /var, /usr, and /home.

__EOT
fi

	ROOTDISK=
	ROOTDEV=
	SWAPDEV=

	set -- $DKDEVS
	[[ $# -gt 1 ]] && _defdsk=done

	ask_which "disk" "is the root disk?" "$DKDEVS" "$_defdsk"
	[[ $resp == done ]] && exit

	ROOTDISK=$resp
	ROOTDEV=${ROOTDISK}a
	SWAPDEV=${ROOTDISK}b
}

d478 2
a479 1
		ask_which "interface" "do you wish to initialize?" "$_IFDEVS"
d1001 1
a1001 1
	ask_which "CD-ROM" "contains the ${MODE} media?" "$CDDEVS"
d1086 1
a1086 1
	ask_which "disk" "contains the ${MODE} sets?" "$DKDEVS"
d1737 20
a1756 2
# Get ROOTDISK and default ROOTDEV
get_rootdisk
@


1.316
log
@move to 3.4-beta
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.315 2003/08/07 19:13:00 deraadt Exp $
d1557 1
a1557 1
	echo "...Done."
@


1.315
log
@spaces
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.314 2003/07/10 15:03:19 krw Exp $
d1713 1
a1713 1
VERSION=33
@


1.314
log
@Try to ensure that ftp gets install sets from the same directory it
looked in to get the list of available sets.

The list of available sets is obtained by connecting to the ftp server
interactively and issuing the commands

user <user> <pass>
cd <dir>
ls

where <dir> is treated as a relative path unless the user enters an
initial '/'. But the files are obtained by issuing the command

ftp ftp://<user>:<pass>@@<host>/<dir>

and here <dir> is treated as an absolute path.

When using non-anonymous ftp this difference in the treatment of <dir>
could result in

a) Unhelpful error messages and unsuccessfull transfers.

b) Different sets than intended being installed.

c) Incorrect lists of available sets being displayed.

Now, the non-anonymous ftp transfer command with relative paths (i.e.
no leading '/' or '~') will look like

ftp ftp://<user>:<pass>@@<host>/~/<dir>

Problem reported by (amoung others) Sebastian Stark, Nick Holland,
Steven Boothe, Sam Smith, Sergey Smitienko, Stephen Marley, Brad Ely.

ok millert@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.313 2003/07/10 14:12:54 krw Exp $
d240 1
a240 1
	
d930 1
a930 1
 			;;
@


1.313
log
@Ensure that the install/upgrade process is not troubled by any ulimit
settings. Set them all to 'unlimited'.

Problem with datasize limit vs fsck of large filesystem noted by
millert@@.

ok millert@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.312 2003/07/03 15:19:01 krw Exp $
d877 1
a877 1
	local _url_type=$1 _file_list _url_base _oifs _prompt
d981 1
d984 1
a984 1
	eval _url_base=$_url_base\$_${_url_type}_server_ip/\$_${_url_type}_server_dir
@


1.312
log
@Use numeric comparison operators when testing numeric values.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.311 2003/07/03 13:42:03 krw Exp $
d1719 5
@


1.311
log
@Clarify and shrink.

In addel(), use $* and isin to avoid a duplicated traversal of the
argument list.

In bsort() remove code designed to prevent a trailing space in sorted
list. With the elimination of cutlast() and cutword() this is not
longer necessary.

The usual [] -> [[]], etc. in areas being revised.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.310 2003/07/02 16:42:19 krw Exp $
d242 1
a242 1
	if [[ $# < 1 ]]; then
d305 1
a305 1
	[[ $# > 0 ]] || return
d422 1
a422 1
	[[ $# > 1 ]] && _defdsk=done
d645 1
a645 1
	while [ ${#_n} != 0 ]; do
d925 1
a925 1
			[[ $# < 1 ]] && { echo "There is no line $resp." ; continue ; }
@


1.310
log
@Eliminate cutword(), replacing it with specific code: 'set --' in two
cases and a simple sed expression in the third.

Add pfsync to the list of interfaces that should not be offered to the
user for configuration.

Display the server line selected from the ftp/http server list in a
more compact form with only a single space between fields.

The usual [] -> [[]], etc. in areas being revised.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.309 2003/06/30 17:49:14 krw Exp $
a285 4
	for _b; do
		echo -n "$_b "
		[ "$_a" = "$_b" ] && _seen=true
	done
d287 2
a288 1
	$_seen || echo -n "$_a"
d305 1
a305 4
	case $# in
	0) return;;
	1) echo $1; return;;
	esac
d309 2
a310 2
		if [[ "$_a" != "$_b" ]] ; then
			if [[ "$_a" > "$_b" ]] ; then
d318 2
a319 1
	echo -n $_a
d321 2
a322 8
	# Prevent a trailing blank on the output, and thus a bad value
	# for cutword, by outputting blanks only when $_l
	# has values to sort.

	if [[ -n "$_l" ]] ; then
		echo -n " "
		bsort $_l
	fi
@


1.309
log
@Cleanup ask_which() logic.

Use first device in supplied list as default unless overridden.
Eliminates repeated 'echo XXX | cutword 1' constructs.

Use 'set -- $_devs' to parse _devs and find out if there are any
devices in the list. Then use '_devs="$*" to eliminate all extraneous
whitespace from _devs, rather than just a single trailing blank.

Usual [...] -> [[...]], `` -> $(), extra '{}' and '"' eliminations in
areas being fixed up.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.308 2003/06/30 14:25:53 krw Exp $
d167 3
a169 1
	ifconfig -a | egrep -v '^([[:space:]]|(lo|enc|gre|ppp|sl|tun|bridge|pflog|vlan|gif)[[:digit:]])' | cutword -t: 1
a304 18
# read lines on stdin, return Nth element of each line, like cut(1)
cutword () {
	local _a _n _oifs=$IFS

	# optional field separator
	case $1 in
	-t?*) IFS=${1#-t}; shift;;
	esac

	_n=$1
	while read _a; do
		set -- $_a
		[ "$1" ] || break
		eval echo \$$_n
	done
	IFS=$_oifs
}

d888 1
a888 1
	local _url_type=$1 _file_list _url_base _oifs _prompt _line
d935 5
a939 6
			_line=$(sed -ne "${resp}p" $SERVERLIST)
			[[ -n $_line ]] || { echo "There is no line $resp." ; continue ; }
			echo "Using	$_line"
			_line=$(echo $_line | cutword -t' ' 1)
			eval _${_url_type}_server_ip=${_line%%/*}
			eval _${_url_type}_server_dir=${_line#*/}/$SETDIR
@


1.308
log
@Use built in pattern matching rather than cutlast() when extracting
timezone name from '/etc/localtime' link. Use cutword() rather than
cutlast() to see if there is more than one possible root disk. As
these were the last two uses of cutlast(), eradicate it.

Usual [...] -> [[...]], `` -> $(), extra '{}' and '"' eliminations in
areas being fixed up.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.307 2003/06/27 22:40:40 krw Exp $
d233 1
a233 1
# $4 = default device
d238 3
a240 10

	# If not default device is supplied, assume 'done'.
	: ${_defdev:=done}

	# A trailing space may be present if _devs list
	# was manipulated by rmel().
	_devs=${_devs% }

	resp=
	if [[ -z $_devs ]]; then
d243 1
d245 4
d250 1
a250 1
	while [ -z "$resp" ]; do
d252 2
a253 2
		# separate 'echo', to ensure entire question is
		# re-ask'ed after a '!' '!foo' shell escape.
d255 1
d259 3
a261 3
		if isin "$resp" $_devs ; then
			makedev $resp || resp=
		elif [ "$resp" != "done" ]; then
a262 1
			resp=
a433 3
	_defdsk=$(echo $DKDEVS | cutword 1)
	[[ $_defdsk == $DKDEVS ]] || _defdsk=

d448 3
d532 2
a533 3
		ask_which "interface" "do you wish to initialize?" "$_IFDEVS" "`echo $_IFDEVS | cutword 1`"

		[ "$resp" = "done" ] && break
d1054 2
a1055 2
	ask_which "CD-ROM" "contains the ${MODE} media?" "$CDDEVS" "`echo $CDDEVS | cutword 1`"
	[ "$resp" = "done" ] && return
d1139 2
a1140 2
	ask_which "disk" "contains the ${MODE} sets?" "$DKDEVS" "`echo $DKDEVS | cutword 1`"
	[ "$resp" = "done" ] && return 1
@


1.307
log
@Improve swap partition handling during install/upgrade.

a) Add all defined swap partitions except the default partition on the
root disk to the installed /etc/fstab.

b) Mount all possible swap partitions just before creating all
devices, giving small memory machines a better chance to successfully
install/upgrade.

Should obviate the need for FAQ 4.3.6.

ok deraadt@@ millert@@ (slightly earlier version)
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.306 2003/06/23 00:38:57 krw Exp $
a322 9
# read a line of data, return last element. Equiv. of awk '{print $NF}'.
cutlast () {
	local _a

	read _a; set -- $_a
	[ $# -gt 0 ] || return
	eval echo \$\{$#\}
}

d345 1
a345 1
	# for cutlast or cutword, by outputting blanks only when $_l
d436 2
a437 2
	_defdsk=`echo $DKDEVS | cutlast`
	[ "$_defdsk" = "$DKDEVS" ] || _defdsk=
d439 1
a439 1
	if [ "$MODE" = "install" -a ! -f /etc/fstab ]; then
d454 1
a454 1
	[ "$resp" = "done" ] && exit
d1351 1
a1351 1
	[ ! -d $_zoneroot ] && return
d1353 3
a1355 3
	if [ -L /mnt/etc/localtime ]; then
		TZ=`ls -l /mnt/etc/localtime 2>/dev/null | cutlast`
		TZ=${TZ#${_zoneroot#/mnt}}
d1365 1
a1365 1
		if [ "$resp" = "?" ]; then
d1372 1
a1372 1
		while [ -d "$_zonepath" ]; do
d1374 2
a1375 2
			if [ "$resp" = "?" ]; then
				ls -F ${_zonepath}
d1377 1
a1377 1
				_zonepath=${_zonepath}/${resp}
d1381 1
a1381 1
		if [ -f "$_zonepath" ]; then
@


1.306
log
@Minor cleanups.

1) Don't check for the existance of /mnt/etc/hosts twice. Since we
bail out at the first check the 2nd one is superfluous.

2) Shorten and clarify the upgrade network configuration logic.

3) Always ask if manual network configuration is desired when
upgrading. Allows the upgrader to decline to use the existing network
configuration and still have an explicit opportunity to configure the
network.

4) Don't bail out if the existing network configuration fails. Instead
(see 3)) offer manual network configuration and let the user decide if
it is worthwhile to continue.

5) Refer to actual file that is missing when bailing out, rather than
forcing user to be alert enough to prepend '/mnt'.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.305 2003/06/21 23:02:32 krw Exp $
d460 1
d467 1
d1693 1
a1693 1
	local _dev
d1696 14
@


1.305
log
@Make file selection more resistant to unexpected user input.

Rather than evaluating the expression

	case _f in
	$resp) ...
	esac

use the equivalent form

	case _f in
	@@($resp)) ...
	esac

so that user input with multiple file names, user input with some
special characters like ';', etc. do not cause syntax errors and
premature ejection from the selection loop. A determined user can
still cause problems, e.g. by using quotes.

Clean up and simplify the code while in the area.

Problems noted by todd@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.304 2003/06/02 15:46:09 deraadt Exp $
a695 6
	# Check for required hosts file.
	if [ ! -f /mnt/etc/hosts ]; then
		echo "ERROR: no /mnt/etc/hosts!"
		return 1
	fi

a822 2

	return 0
@


1.304
log
@licence cleanup; agreement from krw and millert
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.303 2003/05/12 19:01:58 krw Exp $
d489 1
a508 1

d510 2
a511 8
		""|+|-) continue
			;;
		done)	break
			;;
		-*)	_action=rmel
			;;
		*)	_action=addel
			;;
d514 1
a515 1
		[[ $resp == all ]] && resp=*
d517 8
d527 1
a527 3
			$resp)
				_selected=\`$_action $_f \$_selected\`
				;;
a529 1

@


1.303
log
@More cleanup and fixes in url installs.

1) Filter appropriate lines (ftp or http) from ftplist once when it is
downloaded rather than everytime the lines are needed.

2) Don't display the 'ftp://' or 'http://' part of the listed url's as
all displayed url's are of the same type. Partially compensates for
the last increase in the width of the 'cat -n' line number field.

3) Store filtered lines in /tmp/serverlist instead of /tmp/ftplist,
since it can be a list of http servers too. Makes it more obvious that
it is not a copy of ftplist.

4) Avoid 'ftplist: No such file' message, but add more informative
'Getting...done.' or 'Getting...FAILED.' message. Display the actual
ftp error that caused the FAILED status.

5) Add 'done' to the list of available options when asking for a
server location, allowing the user to return to set location selection
without having to enter a server.

6) Mention the '?' option in the prompt. It re-displays the list of
servers.

7) Eliminate unneeded variables 'host' and 'maxlines'. Make global
tline a local (_line). Change _ftp_get_list global to more generic
_get_server_list.

8) General logic cleanup.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.301 2003/05/11 22:07:42 krw Exp $
a14 6
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#	This product includes software developed by Todd Miller and
#	Theo de Raadt
# 4. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
@


1.302
log
@Fix 'eval' statement in _url_base construction so that we use the
contents of ftp_server_dir or http_server_dir, and not their names.

ftp and http installs now work again.
@
text
@d228 1
a228 1
	while [ -z "$resp" ] ; do
d929 1
a929 1
	local _file_list _url_type=$1 _url_base _oifs
d938 2
a939 1
	ask "Display the list of known $_url_type servers?" "${_ftp_getlist:-y}"
d941 1
a941 1
	n*|N*)	_ftp_getlist=n
d944 1
a944 1
		_ftp_getlist=y
d947 12
a958 2
		ftp ${_ftp_active} -V -a -o /tmp/ftplist ftp://129.128.5.191/$FTPDIR/ftplist > /dev/null
		grep "^${_url_type}:" /tmp/ftplist | cat -n | less -XE
d963 4
a966 9
	resp=
	while [[ -z $resp ]] ; do
		if [ ! -f /tmp/ftplist ]; then
			eval ask \"Server IP address, or hostname?\" \"\$_${_url_type}_server_ip\"
			continue;
		fi

		eval ask \"Server IP address, hostname, or list#?\" \"\$_${_url_type}_server_ip\"

d968 3
a970 3
		"?")
			grep "^${_url_type}:" /tmp/ftplist | cat -n | less -XE
			resp=
d973 13
a985 18
			maxlines=`grep "^${_url_type}:" /tmp/ftplist | sed -ne '$='`

			if [ $maxlines -lt $resp -o $resp -lt 1 ]; then
				echo "There is no ${resp}th line in the list."
			else
				tline=`grep "^${_url_type}:" /tmp/ftplist | sed -ne "${resp}p"`
				echo "Using	$tline"
				url=`echo $tline | sed -e "s/^${_url_type}:\/\///" |
					cutword -t' ' 1 | cutword -t' ' 1`
				host=`echo $url | cutword -t/ 1`
				eval _${_url_type}_server_ip=$host
				eval _${_url_type}_server_dir=$(echo $url | sed -e "s/^${host}\///")/$SETDIR
			fi

			# Always do it again, just to double check
			resp=
			;;
		*)
a989 2
	eval _${_url_type}_server_ip=$resp

d1058 1
a1058 1
		ask "Pathname to the sets? (or 'done')" "$_dir"
a1061 1
		"")	;;
d1757 1
@


1.301
log
@More cleanup and fixes in url installs.

1) Rework _url_base to eliminate need for _url_pass and _url_login
variables.

2) Shorten and make more consistant with other messages the prompt for
the list of ftp/http servers.

3) Don't refer to _ftp_server_dir, use ${_url_type}_server_dir so that
a default prompt is available for both ftp and http installs.

4) Eliminate a couple of unneeded {}'s.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.300 2003/05/11 20:05:56 krw Exp $
d1037 1
a1037 1
	eval _url_base=$_url_base\$_${_url_type}_server_ip/\$_\${_url_type}_server_dir
@


1.300
log
@Shrink & clarify code around ftp/http proxy identification.

Eliminate unnecessary _proxy_host variable that merely kept a copy of
the value of ftp_proxy and http_proxy.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.299 2003/05/11 17:27:15 krw Exp $
d929 1
a929 1
	local _file_list _url_type=$1 _url_base _url_login _url_pass _oifs
d938 1
a938 4
	# Provide a list of possible servers
	: ${_ftp_getlist:=y}

	ask "Do you want to see a list of potential $_url_type servers?" "$_ftp_getlist"
a950 2
	: ${_ftp_server_dir:=pub/OpenBSD/$SETDIR}

d1008 2
a1009 1
	eval ask_until \"Server directory?\" \"\$_${_url_type}_server_dir\"
d1033 1
d1035 1
a1035 5
		_url_login=`encode_for_url "$_ftp_server_login"`
		_url_pass=`encode_for_url "$_ftp_server_password"`
		_url_base=ftp://${_url_login}:${_url_pass}@@${_ftp_server_ip}/${_ftp_server_dir}
	else
		eval _url_base=${_url_type}://\$_${_url_type}_server_ip/\$_${_url_type}_server_dir
d1037 1
d1041 1
a1041 1
		_file_list=`ftp_list_files "$_ftp_server_ip" "$_ftp_server_login" "$_ftp_server_password" "$_ftp_server_dir"`
d1047 1
a1047 1
		_file_list=`ftp -o - -V "${_url_base}/index.txt" | sed 's///'`
@


1.299
log
@Don't reject a perfectly valid absolute path to sets just because the
user was observant enough to see where the filesystems are mounted.

Suggested by espie@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.298 2003/05/07 00:43:06 krw Exp $
d933 4
a936 11
	# Proxy the connections?
	: ${_proxy_host:=none}

	ask "HTTP/FTP proxy URL? (e.g. 'http://proxy:8080', or 'none')" "$_proxy_host"
	if [[ $resp == none ]]; then
		unset _proxy_host ftp_proxy http_proxy
	else
		_proxy_host=$resp
		export ftp_proxy=$_proxy_host
		export http_proxy=$_proxy_host
	fi
@


1.298
log
@Use -h option in tar invocations so that upgrades respect links.

Recover two of the three extra characters by deleting unneeded '-'s in
the tar invocations used in tape installs.

Problem noted and solution suggested by millert@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.297 2003/04/30 23:56:30 krw Exp $
d1077 7
a1083 6
		*)	if [[ -d $_mp/$resp ]]; then
				_dir=$_mp/$resp
				break
			else
				echo "The directory '$resp' does not exist."
			fi
@


1.297
log
@Rework munge_fstab to shrink and clarify code.

Collect all tests that cause a line to be skipped into one test by
using ksh string pattern features instead of case statements.

Simply sed expressions by not worrying about extra commas in the
options field (they're ignored during mount) and assuming 'rw',
'noauto', 'xx' do not appear as substrings in any valid option.

Leave out fs_freq and fs_passno fields as unnecessary during
install/upgrade.

Eliminate special test for '/' mount point and simply strip any
trailing slash from all mount points.

Kicked off my wifried@@'s 'xx'/altroot change, and ok'ed in various
incarnations by wilfried@@ deraadt@@ millert@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.296 2003/04/23 12:06:55 wilfried Exp $
d884 1
a884 1
		*.tgz)	ftp $_ftp_active -o - -V -m "$_src/$_f" | tar zxpf - -C /mnt
d1367 1
a1367 1
		1)	_xcmd="tar -zxvpf -"
d1369 1
a1369 1
		2)	_xcmd="tar -xvpf -"
@


1.296
log
@ignore altroot filesystem when upgrading, ok krw@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.295 2003/04/17 19:15:49 deraadt Exp $
d1516 15
a1530 6
# Create a /etc/fstab from /tmp/fstab. Ensure /etc/fstab
#	1) contains only filesystems we can mount
#	2) contains no altroot filesystem
#	3) contains only filesystems without the 'noauto' option
#	4) contains no 'softdep' options
#	5) mounts all filesystems relative to /mnt
d1537 6
a1542 18
		# Skip comment lines.
		case $_dev in
		\#*)	continue ;;
		esac

		# Skip noauto and altroot filesystems.
		case $_opt in
		*noauto*|*xx*) continue ;;
		esac

		# Skip filesystems we can't mount.
		[ -f "/sbin/mount_${_fstype}" ] || continue

		# Skip nfs filesystems because all name
		# resolutions (e.g. yp) are not available
		# and success is not guaranteed. The user
		# will have to mount nfs filesystems manually.
		[ "$_fstype" != "nfs" ] || continue
d1546 1
a1546 7
		_opt="$(echo ${_opt} | \
			sed -e 's/^softdep$//; s/^softdep,//; s/,softdep,/,/; s/,softdep$//;')"

		# Mount non-ffs filesystems read-only
		[ "$_fstype" = "ffs" ] || \
			_opt="$(echo ${_opt} | \
				sed -e 's/^rw$/ro/; s/^rw,/ro,/; s/,rw,/,ro,/; s/,rw$/,ro/')"
d1548 2
a1549 2
		# Avoid '/mnt/' in root fs entry in munged fstab
		[ "$_mp" = "/" ] && _mp=
d1552 4
a1555 1
		echo $_dev /mnt$_mp $_fstype $_opt $_rest
@


1.295
log
@remove extra spaces, make smaller, krw you keep adding them back! ;)
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.294 2003/04/16 23:47:01 krw Exp $
d1517 5
a1521 4
#	1) contains only ffs filesystems
#	2) contains only filesystems without the 'noauto' option
#	3) contains no 'softdep' options
#	4) mounts all filesystems relative to /mnt
d1533 1
a1533 1
		# Skip noauto filesystems.
d1535 1
a1535 1
		*noauto*) continue ;;
@


1.294
log
@Always do 'route -n show' not 'route show'. Even saves some space.

From deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.293 2003/03/06 04:19:45 david Exp $
d612 1
a612 1
 	fi
d637 1
a637 1
 		cat << __EOT
d642 2
a643 2
 		case $resp in
 		y*|Y*)	cat << __EOT
d652 3
a654 3
 			;;
 		esac
 	fi
d665 1
a665 1
 		fi
d847 1
a847 1
	# _get_sets to the intersection of _sets and DEFAULTSETS. 
d1087 1
a1087 1
	install_files "file://$_dir" "`ls -l $_dir`" 
d1636 1
a1636 1
 	local _dn
d1775 1
a1775 1
OBSD="OpenBSD/$ARCH $VNAME" 
@


1.293
log
@spelling fixes
ok henning@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.292 2003/03/06 00:27:41 krw Exp $
d830 1
a831 1
		route show
a833 1
		route -n show
@


1.292
log
@Delete the password from the ftp url shown when no sets are found.

a) We shouldn't display passwords.

b) If it is encoded, and thus different from what was entered,
installers will leap to the incorrect conclusion that the logon
failed.

c) At this point the logon to the server was successful so the
password worked, and the user shouldn't have forgotten it already.

ok deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.291 2003/03/02 00:17:20 krw Exp $
d419 1
a419 1
# Check for the existance of the device nodes for the
@


1.291
log
@Fix default route handling during installation to preserve active
default route even if 'none' or 'dhcp' is selected as the default
route for the installed system. Previously, specifying 'none' or
'dhcp' would delete the existing default route, making ftp installs
from non-local servers impossible.

This is done by only deleting the existing default route when a change
is attempted, and putting back the previous default route if the
change fails.

Problem noticed by drahn@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.290 2003/02/16 23:25:40 krw Exp $
d860 1
d864 1
a864 1
    '$_src'
@


1.290
log
@Fix up some DNS verbiage to make it consistant.

Fix up default route selection by

a) Forcing user to explicitly chose 'dhcp' as a mechanism for
specifying a default route, rather than guessing based on one or more
interfaces being configured by dhcp.

b) If the user specified default route does not work, re-present the
existing default route rather than losing it.

c) Move default route selection to after nameserver activation so the
user can specify a hostname as the default route.

Change /etc/netstart so that /etc/mygate wins if a default route was
already specified (i.e. by dhcp).

ok deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.289 2003/02/15 20:36:18 krw Exp $
a1690 1
	route delete default > /dev/null 2>&1
d1696 1
d1698 2
@


1.289
log
@Make bsd.rd an install/upgrade set.

Suggestion by Nick Holland out of comments by deraadt@@ and miod@@.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.288 2003/02/12 23:07:28 deraadt Exp $
d1646 1
a1646 1
	local _dn _ns
a1674 12
	# Get/Confirm the default route.
	resp=$(route -n show | sed -ne '/^default */{s///; s/ .*//; p;}')
	route delete default > /dev/null 2>&1
	while : ; do
		ask "IP address of default route? (or 'none')" "${resp:=none}"
		[[ $resp == none ]] && break
		route add default $resp || { resp= ; continue; }
		# Save default route if DHCP wasn't used.
 		[ -f /tmp/dhclient.conf ] || echo $resp > /tmp/mygate
		break
	done

d1676 1
a1676 1
	ask "IP address of DNS nameserver? (or 'none')" "${_ns:=none}"
d1682 1
a1682 1
		ask "Would you like to use the nameserver now?" y
d1688 11
@


1.288
log
@move to 3.3-beta
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.287 2003/01/26 15:53:13 krw Exp $
d1790 1
a1790 1
THESETS="bsd $MDSETS"
@


1.287
log
@Last (?) big cleanup in distrib/miniroot this release cycle.

Simplify and clarify logic around selecting/installing sets.

Rename do_selection_list() to select_sets(), and install_get_files()
to install_files().

Eliminate glob_selection() and get_get_files() and the global
GET_FILES, folding logic into select_sets() and install_files().

Show the user entire 'url' when no sets are found, rather than trying
to hide mount points, etc.

Eliminate VERSION_MAJOR and VERSION_MINOR since they were always used
together. Instead, simply construct a few variables (SETDIR, FTPDIR,
OBSD) holding the strings these were used to construct.

Various 'standard' cleanups of quotes, braces, etc. in modified areas.

Also shrinks install.sub by 681 bytes.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.286 2003/01/25 15:46:52 krw Exp $
d1769 1
a1769 1
VERSION=32
@


1.286
log
@Eliminate unused global SETSDONE.

Add (back?) function SETSDONE was probably supposed to be doing
(preventing the automatic selection of already installed sets) by
manipulating DEFAULTSETS instead. Remove successfully installed sets
from DEFAULTSETS, and add 'problem' sets detected in sane_install()
back into DEFAULTSETS.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.285 2002/12/14 15:33:35 krw Exp $
d4 1
a4 1
# Copyright (c) 1997-2002 Todd Miller, Theo de Raadt, Ken Westerback
d100 1
a100 1
Welcome to the OpenBSD/${ARCH} ${VERSION_MAJOR}.${VERSION_MINOR} ${MODE} program.
d102 1
a102 1
This program will help you ${MODE} OpenBSD in a simple and rational way. At
d106 1
a106 1
pressing Control-C and then RETURN, but quitting during an ${MODE} can leave
d485 1
a485 2
# Show selection list and get user response to give question
# in global _resp.
d487 50
a536 14
# $1 = full list to display
# $2 = list of already selected elements
# $3 = question to ask user
do_selection_list() {
	local _next _elem

	for _elem in $1; do
		if isin $_elem $2; then
			echo -n "	[X] "
		else
			echo -n "	[ ] "
			: ${_next:=$_elem}
		fi
		echo $_elem
a537 1
	: ${_next:=done}
d539 1
a539 1
	ask "\n$3 (or 'done')" "$_next"
d841 5
a845 21
# Do globbing on the selection and parse +/-. Update the global
# GET_FILES appropriately.
#
# $1 = user's selection (e.g. 'x*', or '-games*')
# $2 = list of sets available from current source
glob_selection() {
	local _selection=$1 _sets=$2 _action _f

	# Change +/- into add/remove, but ignore bare '+' or '-'
	_action=addel
	case $_selection in
	""|+|-)	return
		;;
	+*)	_selection=${_selection#?}
		;;
	-*)	_selection=${_selection#?}
		_action=rmel
		;;
	esac

	[ "$_selection" = "all" ] && _selection=*
d847 10
a856 24
	set -o noglob
	for _f in $_sets; do
		eval "case $_f in
		$_selection)
			GET_FILES=\`$_action $_f \$GET_FILES\`
			;;
		esac"
	done
	set +o noglob
}

# Set GET_FILES to the list of sets requested by the user.
# $1 = list of files available in source directory or url.
# $2 = source directory or url
get_get_files () {
	local _files=$1 _src=$2 _sets _f

	GET_FILES=

	for _f in $THESETS ; do
		if isin $_f $_files ; then
			_sets="$_sets $_f"
			isin $_f $DEFAULTSETS && GET_FILES="$GET_FILES $_f"
		fi
d859 1
a859 1
	if [ -z "$_sets" ]; then
d861 1
a861 1
No OpenBSD ${VERSION_MAJOR}.${VERSION_MINOR} ${MODE} sets were found in
d863 1
a863 1
    '${_src}'
d865 1
a865 1
Valid set names would be:
a866 3
		for _f in $THESETS ; do
			echo "   $_f"
		done
d870 1
a870 3
	# Allow the user to select/de-select additional sets
	while : ; do
		cat << __EOT
d872 2
a873 3
The following sets are available. Enter a filename, 'all' to select
all the sets, or 'done'. You may de-select a set by prepending a '-'
to its name.
d875 1
a875 19
__EOT
		do_selection_list "$_sets" "$GET_FILES" "File Name?"

		[ "$resp" = "done" ] && break

		glob_selection "$resp" "$_sets"
	done
}

# Install the list of files in the global GET_FILES from the source
# named in $1. Display an error message for failed installs so the
# user will know to try again.
install_get_files () {
	local _f _src=$1

	# User may have selected no files
	[[ -n $GET_FILES ]] || return

	ask "Ready to ${MODE} sets?" y
a879 1
	echo
d881 2
a882 2
		isin $_f $GET_FILES || continue
		echo "Getting ${_f} ..."
d884 1
a884 1
		*.tgz)	ftp ${_ftp_active} -o - -V -m "${_src}/${_f}" | tar zxpf - -C /mnt
d886 1
a886 1
		*)	ftp ${_ftp_active} -o "/mnt/${_f}" -V -m "${_src}/${_f}"
d890 1
a890 1
			echo "'${_f}' did not install correctly."
d937 1
a937 1
	if [ "$resp" = "none" ]; then
d941 2
a942 2
		export ftp_proxy=${_proxy_host}
		export http_proxy=${_proxy_host}
d948 1
a948 1
	ask "Do you want to see a list of potential ${_url_type} servers?" "$_ftp_getlist"
d956 1
a956 1
		ftp ${_ftp_active} -V -a -o /tmp/ftplist ftp://129.128.5.191/pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/ftplist > /dev/null
d961 2
d965 1
a965 1
	while [ -z "$resp" ] ; do
d985 1
a988 2
				path=`echo $url | sed -e "s/^${host}\///"`
				path=${path}/${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}
d990 1
a990 2
				eval _${_url_type}_server_dir=$path
				echo "Using	$tline"
d1006 1
a1006 1
	if [ "$_url_type" = "ftp" -a -z "$ftp_proxy" ]; then
a1019 5
	if [ "$_url_type" = "ftp" -a -z "$_ftp_server_dir" ] ; then
		# Default ftp dir
		_ftp_server_dir=pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}
	fi

d1023 1
a1023 1
	if [ "$_url_type" = "ftp" ]; then
d1033 1
a1033 1
		if [ "$_ftp_server_login" != "anonymous" ]; then
d1035 1
a1035 1
			while [ -z "$resp" ] ; do
d1044 1
a1044 1
	if [ "$_url_type" = "ftp" -a "$_ftp_server_login" != "anonymous" ]; then
d1053 1
a1053 2
	# XXX - check for nil $_file_list and deal
	if [ "$_url_type" = "ftp" -a -z "$ftp_proxy" ] ; then
d1063 1
a1063 3
	get_get_files "$_file_list" "`eval echo \\$_${_url_type}_server_dir`"

	install_get_files "$_url_base"
d1087 1
a1087 3
	get_get_files "`ls -l $_dir`" "$_dir"

	install_get_files "file:$_dir"
d1167 1
a1167 1
	install_mounted_fs /mnt2 "${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}"
d1768 1
d1770 5
a1774 3
VERSION_MAJOR=$(( $VERSION / 10 ))
VERSION_MINOR=$(( $VERSION % 10 ))
export VERSION VERSION_MAJOR VERSION_MINOR
a1797 3

# Global variable using during sets installation
GET_FILES=
@


1.285
log
@Expunge some trailing whitespace.

From David Krause.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.284 2002/12/08 20:24:56 krw Exp $
d913 1
a913 1
			SETSDONE=`addel ${_f} ${SETSDONE}`
d1469 1
a1469 1
# If a 'problem' set is found, remove it from SETSDONE list.
d1476 1
a1476 1
		SETSDONE=`rmel bsd $SETSDONE`
d1487 1
a1487 1
		SETSDONE=`rmel base${VERSION}.tgz $SETSDONE`
d1499 1
a1499 1
		SETSDONE=`rmel etc${VERSION}.tgz $SETSDONE`
a1827 1
SETSDONE=
@


1.284
log
@Fix botch in last commit: prepend comments to hosts after adding FQDN to
hosts entries, so comments are not processed.

Last few touchups & shrinkage for this round.

Current score:

install.sh+install.sub+upgrade.sh = 36,934 (vs 40,062 for 3.2).
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.283 2002/12/08 19:30:40 krw Exp $
d543 1
a543 1
# $2 == hostname (optional). 
d555 1
a555 1
 
d564 1
a564 1
 
d568 1
a568 1
 
d571 1
a571 1
 
d573 1
a573 1
 
d579 1
a579 1
 
d621 1
a621 1
 
d650 1
a650 1
 
d1713 1
a1713 1
		# Save default route if DHCP wasn't used. 
d1838 1
a1838 1
# umount all filesystems, just in case we are re-running install or upgrade. 
@


1.283
log
@Fix & cleanup logic, especially around interrupted installs.

Use value of 'hostname' to store all HOSTNAME and FQDN information.  Elminate
those global variables. For install accept user input as is, but if the short
form hostname is unchanged, save any domain info by not re-setting hostname.
For upgrade just set hostname from /tmp/myname.

Unconditionally create default hosts file in install.sh, rather than doing it
in separate places depending on whether or not the user configures the network.
Always ask if the user wants to edit the hosts file when the network is
configured, but without listing it out.

Don't put 'search' command in resolv.conf as we now set hostnames to include
fully qualified domain names, which will be used to yield local domain name.

Loop asking for the default route until the user enters one that 'route'
accepts or the user explicitly asks for no default route by entering 'none'.

Add FQDN info to hosts file just before saving configuration files to the
installed system. Preserve user added lines - those with aliases or with domain
information in the hostname.

Clean up donetconfig() logic. Delete network config files in install.sh so that
if the user restarts an interrupted install previous network configuration does
not leak into installed system.

Elminiate get_resolv_fqdn(), searching resolv.conf for domain info only when
dhcp was used. get_fqdn() is reduced to looking for domain info in current
hostname, and supplying 'my.domain' if none found.

Add save_comments() and use to preserve useful comments in the installed
/etc/hosts and /etc/dhclient.conf files. Previous logic for dhclient.conf could
cause repeated appending of configuration info rather than just preserving the
comments.

Cleanup logic copying files from /tmp to /mnt/etc, eliminating unneeded
cfgfiles variable. Use wildcards and subshells to shrink code size.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.282 2002/12/04 03:39:07 krw Exp $
d1677 1
a1677 1
	local _ns
a1689 1
	resp=
d1692 2
d1695 2
a1696 2
		# given on *last* search or domain statement
		resp=$(sed -n \
d1703 1
a1703 1
	ask "DNS domain name? (e.g. 'bar.com')" "${resp:=$(get_fqdn)}"
a1707 1
	[[ -z $resp && -f /tmp/mygate ]] && resp=$(< /tmp/mygate)
a1708 1
	rm -f /tmp/mygate
d1714 1
a1714 1
 		[[ -f /tmp/dhclient.conf ]] || echo $resp > /tmp/mygate
d1719 1
a1719 5
	resp=
	if [ -f /tmp/resolv.conf ]; then
		resp=$(sed -ne '/^nameserver /s///p' /tmp/resolv.conf)
	fi
	ask "IP address of DNS nameserver? (or 'none')" "${resp:=none}"
@


1.282
log
@Code cleanup & shrinkage.

Redo configure_ifs() to take full advantage of recent code
refactoring, and cleanup code while there.

Move address or dhcp question to after media option handling so that
each question gives immediate feedback. i.e. if the media options
given don't work then say so and exit, and if dhcp is requested
immediately issue the dhcp request. Also allows some code shrinkage.

Eliminate addifconfig() and remount(). The former is folded into
configure_ifs() and the latter's three lines simply replace the call
in install.sh.

Move remount code to before any configuration files are moved to the
installed system.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.281 2002/12/03 00:58:35 krw Exp $
d369 13
d597 1
a597 1
	ask "Symbolic (host) name for $_ifs?" "$HOSTNAME"
d1450 1
a1450 1
			echo "You have selected timezone '$TZ'".
d1452 1
d1664 2
a1665 16
# Find LAST instance of DOMAIN or SEARCH and extract first domain name
# on that line as FQDN.
# $1 = resolv.conf file name
get_resolv_fqdn () {
	[[ -f $1 ]] || return

	FQDN=`sed -n \
		-e '/^domain[[:space:]][[:space:]]*/{s///;s/\([^[:space:]]*\).*$/\1/;h;}' \
		-e '/^search[[:space:]][[:space:]]*/{s///;s/\([^[:space:]]*\).*$/\1/;h;}' \
		-e '${g;p;}' $1`
}

# Get Fully Qualified Domain Name and update hosts file appropriately.
#
# $1 = resolv.conf file to search for FQDN
# $2 = hosts file to add FQDN information to
d1667 1
a1667 1
	get_resolv_fqdn $1
d1669 3
a1671 2
	ask "DNS domain name? (e.g. 'bar.com')" "$FQDN"
	FQDN=$resp
d1673 1
a1673 9
	if [ -f "$2" -a -n "$FQDN" ]; then
		# Add FQDN to hosts file entries created by addhostent, changing
		# lines like
		#    1.2.3.4 hostname
		# to
		#    1.2.3.4 hostname.$FQDN hostname
		sed "s/\\(.*\\)[[:space:]]\\(.*\\)\$/\\1 \\2.$FQDN \\2/" $2 > $2.new
		mv $2.new $2
	fi
d1677 1
a1677 1
	local _nam
d1679 1
a1679 1
	[ "$DIDNET" ] && return
a1682 17
	# Always create new hosts file. If install.sh has been
	# restarted, an existing one may contain information which
	# will conflict with the information about to be entered.
	# Also ensures logic to put FQDN in hosts file will create
	# hosts file lines in correct format.
	echo "::1 localhost\n127.0.0.1 localhost" > /tmp/hosts

	# Remove any existing hostname.* files. If install.sh has
	# been restarted, this ensures a correct list of configured
	# interfaces is displayed, and gives the user a chance to
	# change which interfaces are to be configured.
	rm -f /tmp/hostname.*

	# Revoke any previous decision on whether or not to use
	# a nameserver during installation.
	rm -f /tmp/resolv.conf.shadow

d1690 1
d1693 25
a1717 1
	fi
d1719 2
a1720 26
	# Get/Confirm FQDN, and apply it to the hosts file.
	get_fqdn /tmp/resolv.conf /tmp/hosts

	hostname $HOSTNAME.$FQDN

	resp=`route -n show | sed -ne '/^default */{
		s///
		s/ .*//
		p
	}'`
	if [ -z "$resp" ] ; then
		resp=none
		if [ -f /tmp/mygate ]; then
			resp=`cat /etc/mygate`
			: ${_resp:=none}
		fi
	fi
	ask "IP address of default route?" "$resp"
	if [ "$resp" != "none" ]; then
		route delete default > /dev/null 2>&1
		if route add default $resp > /dev/null ; then
			echo $resp > /tmp/mygate
		fi
	fi

	resp=none
d1722 1
a1722 9
		resp=
		for n in `sed -ne '/^nameserver /s///p' /tmp/resolv.conf`
			do
			if [ -z "$resp" ] ; then
				resp=$n
			else
				resp="$resp $n"
			fi
		done
d1724 5
a1728 5
	ask "IP address of primary nameserver?" "$resp"
	if [ "$resp" != "none" ]; then
		echo "search $FQDN" > /tmp/resolv.conf
		for n in `echo ${resp}`; do
			echo "nameserver $n" >> /tmp/resolv.conf
a1729 2
		echo "lookup file bind" >> /tmp/resolv.conf

d1737 1
a1737 11
	if [ ! -f /tmp/resolv.conf.shadow ]; then
		cat << __EOT

The host table contains:

$(< /tmp/hosts)

__EOT
		edit_tmp_file hosts
	fi

a1834 6

# The Fully Qualified Domain Name.
FQDN=

# The system hostname (short form).
HOSTNAME=
@


1.281
log
@More code consolidation.

Create dhcp_request() and use in configure_ifs() rather than repeat code. When
dhcp is successful, move /etc/dhclient.conf, /etc/resolv.conf.tail to /tmp, and
use normal configuration file installation to put them on the installed system.

Also apply any user specified media options immediately. If they don't compute
then return immediately.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.280 2002/12/01 23:19:33 krw Exp $
a471 16
# Create a hostname.* file for the interface.
# $1 - interface name
# $2 - interface symbolic name
# $3 - interface IP address
# $4 - interface netmask
# $5 - (optional) interface media directives
addifconfig() {
	if [ "$3" = "dhcp" ]; then
		echo "dhcp NONE NONE NONE $5" > /tmp/hostname.$1
		addhostent 127.0.0.1 $2
	else
		echo "inet $3 $4 NONE $5" > /tmp/hostname.$1
		addhostent $3 $2
	fi
}

d577 1
a577 3
	local _up _if_name=$1 _if_ip _if_mask
	local _if_symname _if_extra
	local _dhcp_prompt _mediaopts
d580 2
a581 3
	_up=$1
	_if_ip=$2
	_if_mask=$3
d583 29
a611 1
	[ $_up = "UP" ] && ifconfig $_if_name delete down
d613 18
a630 62
	[ -x /sbin/dhclient ] && _dhcp_prompt=" (or 'dhcp')"

	# Get IP address
	resp=
	while [ -z "$resp" ] ; do
		ask "IP address for ${_if_name}?${_dhcp_prompt}" "$_if_ip"
		if [ ! -x /sbin/dhclient -a "$resp" == "dhcp" ]; then
			echo "DHCP is not supported."
			resp=
		fi
	done
	_if_ip=$resp

	# Get symbolic name
	ask_until "Symbolic (host) name?" "$HOSTNAME"
	_if_symname=$resp

	# Get netmask
	if [ "$_if_ip" != "dhcp" ]; then
		ask_until "Netmask?" "${_if_mask:=255.255.255.0}"
		_if_mask=$resp
	fi

	_mediaopts=`ifconfig -m $_if_name | sed -n '/media:/D;/media/p'`
	if [ "$_mediaopts" ]; then
		cat << __EOT
The default media for $_if_name is
$(ifconfig -m $_if_name | sed -n '/supported/D;/media:/p')
__EOT
		ask "Do you want to change the default media?" "n"
		case $resp in
		y*|Y*)	cat << __EOT
Supported media options for $_if_name are:
$_mediaopts
__EOT
			ask "Media options for $_if_name?"
			_if_extra=$resp
			;;
		*)	;;
		esac
	fi

	# Apply any specified media options immediately.
	ifconfig ${_if_name} down ${_if_extra} || return 1

	# Configure the interface. If it succeeds, add it to the permanent
	# network configuration info.
	if [ "$_if_ip" = "dhcp" ]; then
		dhcp_request $_if_name $_if_symname || dhcp_request $_if_name || return 1
		addifconfig ${_if_name} ${_if_symname} ${_if_ip}
		return 0
	else
		if ifconfig ${_if_name} inet \
			${_if_ip} \
			netmask ${_if_mask} ${_if_extra} up
			then
			addifconfig ${_if_name} ${_if_symname} ${_if_ip} ${_if_mask} "$_if_extra"
			return 0
		fi
	fi
	return 1
}
d632 6
a1617 11
}

# Remount all filesystems in /etc/fstab with the options from
# /etc/fstab, i.e. without any options such as async which
# may have been used in the first mount.
remount_fs() {
	local _dev _mp _fstype _opt _rest

	while read _dev _mp _fstype _opt _rest; do
		mount -u -o $_opt $_dev $_mp ||	exit
	done < /etc/fstab
@


1.280
log
@Code consolidation. Create edit_tmp_file(), manual_net_cfg(), inet_info()
to abstract repeated code blocks.

Current score: 3.2      install+upgrade+install.sub = 40,062 bytes
               -current    "        "         "     = 38,051
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.279 2002/12/01 16:51:14 krw Exp $
d542 50
d646 4
a649 2
	# Configure the interface. If it
	# succeeds, add it to the permanent
d652 3
a654 38
		ifconfig ${_if_name} down ${_if_extra}
		cat > /etc/dhclient.conf << __EOT
initial-interval 1;
send host-name "$HOSTNAME";
request subnet-mask, broadcast-address, routers,
	domain-name, domain-name-servers, host-name;
__EOT
		kill_dhclient
		dhclient -1 ${_if_name}

		set -- $(inet_info $_ifs)
		if [ $1 = "UP" -a $2 = "0.0.0.0" ]; then
			echo "hostname-associated DHCP attempt for $_if_name failed..."
			ifconfig $_if_name delete down

			cat > /etc/dhclient.conf << __EOT
initial-interval 1;
request subnet-mask, broadcast-address, routers,
	domain-name, domain-name-servers, host-name;
__EOT
			kill_dhclient
			dhclient -1 ${_if_name}

			set -- $(inet_info $_ifs)
			if [ $1 = "UP" -a $2 = "0.0.0.0" ]; then
				echo "free-roaming DHCP attempt for $_if_name failed."
				ifconfig $_if_name delete down
				return 1
			else
				echo "DHCP attempt for $_if_name successful."
				addifconfig ${_if_name} ${_if_symname} ${_if_ip}
				return 0
			fi
		else
			echo "DHCP configuration of $_if_name successful."
			addifconfig ${_if_name} ${_if_symname} ${_if_ip}
			return 0
		fi
a655 1
		ifconfig ${_if_name} down
@


1.279
log
@Create kill_dhclient(). Use before any attempt to run dhclient, to
avoid problems with the single bpf interface available on install
media.

Move umount'ing of filesystems to the start of any install or upgrade
execution.

Eliminate now vestigal cleanup_on_exit() and all associated traps.

Shrinks scripts, makes more reliable, improves intuitiveness of
re-running install or upgrade, eliminates an install/upgrade time
message, leaves filesystems available if install/upgrade script
interrupted.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.278 2002/11/29 00:24:58 krw Exp $
d369 26
d526 6
a531 6
configure_ifs() {
	local _up _if_name=$1 _if_ip _if_mask
	local _if_symname _if_extra
	local _dhcp_prompt _mediaopts

	set -- `ifconfig $_if_name | sed -n '
d539 7
a545 1
		/inet/s/inet// p'`
d547 1
d610 1
a610 10
		set -- `ifconfig $_if_name | sed -n '
			1s/.*<UP,.*$/UP/p
			1s/.*<.*>*$/DOWN/p
			/media:/s/^.*$//
			/status:/s/^.*$//
			/inet/s/--> [0-9.][0-9.]*//
			/inet/s/netmask//
			/inet/s/broadcast//
			/inet/s/inet// p'`

a621 9
			set -- `ifconfig $_if_name | sed -n '
				1s/.*<UP,.*$/UP/p
				1s/.*<.*>*$/DOWN/p
				/media:/s/^.*$//
				/status:/s/^.*$//
				/inet/s/--> [0-9.][0-9.]*//
				/inet/s/netmask//
				/inet/s/broadcast//
				/inet/s/inet// p'`
d623 1
d1795 8
a1802 7
		echo "\nThe host table contains:\n"
		cat /tmp/hosts
		ask "\nWould you like to edit the host table with ${EDITOR}?" n
		case $resp in
		y*|Y*)	${EDITOR} /tmp/hosts
			;;
		esac
d1805 1
a1805 6
	ask "Do you want to do more, manual, network configuration?" n
	case $resp in
	y*|Y*)	echo "Type 'exit' to return to install."
		sh
		;;
	esac
@


1.278
log
@Ask for DNS domain name *after* the interfaces are configured, at the
same time as we ask for the default route and name server addresses.

This allows users to override any DHCP supplied domain information the
same way they could override DHCP supplied default route and name server
addresses. As a result, remove the now superfluous warning about
not supplying information DHCP is going to overwrite.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.277 2002/11/28 03:06:30 deraadt Exp $
d574 1
d596 1
d716 1
d1609 4
a1612 10
# Script is exiting. Clean up as much as possible.
cleanup_on_exit() {
	echo "\nCleaning up..."

	# Kill any running dhclient, so a restart will not
	# find /dev/bpf0 busy.

	if [ -f /var/run/dhclient.pid ]; then
		echo "Stopping dhclient"
		kill -HUP `sed -ne "1p" /var/run/dhclient.pid` > /dev/null 2>&1
a1614 8

	if [ -f /etc/fstab ]; then
		umount -av
	elif [ ! "`df /`" = "`df /mnt`" ]; then
		umount -v /mnt
	fi

	echo "Done."
a1835 4
	# Disable trap(s) that do cleanup on exit. With success comes a
	# reboot which washes away all sins.
	trap - HUP INT QUIT TERM EXIT

d1904 3
a1906 3
# Cleanup if the script exit prematurely.
trap 'cleanup_on_exit' EXIT
trap 'exit 2' HUP INT QUIT TERM
@


1.277
log
@spaces
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.276 2002/11/28 01:54:58 krw Exp $
d1681 2
a1682 2
# Find FQDN in resolv.conf. If we aren't updating a hosts file, ask
# user to confirm the domain name. Else just fix hosts file
d1688 3
a1698 3
	else
		ask "DNS domain name? (e.g. 'bar.com')" "$FQDN"
		FQDN=$resp
a1725 9
	cat << __EOT

If any interface will be configured by DHCP, you should not enter
information that will be supplied via DHCP, e.g. the DNS domain name.

__EOT

	get_fqdn /tmp/resolv.conf

d1737 1
a1737 4
	# Get any DHCP supplied FQDN, and in any case apply FQDN to
	# the host names in /tmp/hosts, all without asking for any more
	# user confirmation. This means DHCP supplied information will
	# override a user supplied (or previous DHCP supplied) FQDN.
@


1.276
log
@Make questions out of requests for user input that were demands.  Use
a standard format of

   <question>? (<extra verbiage>) [<default value>]

Makes things more consistant, and sometimes more terse.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.275 2002/11/28 01:11:05 krw Exp $
d116 1
a116 1
IS YOUR DATA BACKED UP? As with anything that modifies disk contents, this 
d877 1
a877 1
	case $resp in 
d880 1
a880 1
	
d913 1
a913 1
# used to get the list of files in a directory. 
d970 1
a970 1
	
d983 1
a983 1
			else	
d1080 1
a1080 1
	
d1497 1
a1497 1
 	cat << __EOT
d1556 1
a1556 1
		
d1574 1
a1574 1
	
d1859 1
a1859 1
	# Disable trap(s) that do cleanup on exit. With success comes a 
d1908 4
a1911 4
       [[ $MODE == upgrade && $_set == etc ]] && continue
       THESETS="$THESETS ${_set}${VERSION}.tgz"
       isin $_set xbase xshare xfont xserv site && continue
       DEFAULTSETS="$DEFAULTSETS ${_set}${VERSION}.tgz"
d1938 1
a1938 1
# Get ROOTDISK and default ROOTDEV 
@


1.275
log
@Save a few bytes;

1) The one '/sbin/ifconfig' -> 'ifconfig'.

2) Eliminate local variable and thereby unneeded '\n' in welcome().
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.274 2002/11/28 00:44:56 krw Exp $
d90 1
a90 1
	ask "Specify terminal type:" ${MDTERM:-vt220}
d526 1
a526 1
		ask "IP address for ${_if_name}${_dhcp_prompt}?" "$_if_ip"
d556 1
a556 1
			ask "Enter media options for $_if_name:"
d1043 1
a1043 1
				askpass "Password (will not echo):"
d1082 1
a1082 1
		ask "Specify pathname to the sets: (or 'done')" "$_dir"
d1421 1
a1421 1
			ask "Select a sub-timezone of '${_zonepath#$_zoneroot}' ('?' for list):"
d1697 1
a1697 1
		ask "Enter DNS domain name (e.g. 'bar.com'):" "$FQDN"
d1766 1
a1766 1
	ask "Enter IP address of default route:" "$resp"
d1786 1
a1786 1
	ask "Enter IP address of primary nameserver:" "$resp"
@


1.274
log
@Fix indent botch.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.273 2002/11/10 01:08:33 krw Exp $
a97 2
	local _query

d118 1
a123 1

d126 1
d128 1
a128 1
		_query="Proceed with upgrade?"
a132 1

d135 1
a139 1

d142 1
d144 1
a144 1
			_query="Skip disk initialization?"
d146 1
a146 1
			_query="Proceed with install?"
a150 1
	ask "\n$_query" n
d173 1
a173 1
	/sbin/ifconfig -a | egrep -v '^([[:space:]]|(lo|enc|gre|ppp|sl|tun|bridge|pflog|vlan|gif)[[:digit:]])' | cutword -t: 1
@


1.273
log
@Fix makedev() so that if the device nodes are *not* created, makedev()
returns false, and the device is *not* added to DEVSMADE.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.272 2002/11/09 06:16:06 krw Exp $
d417 2
a418 2
if [ "$MODE" = "install" -a ! -f /etc/fstab ]; then
	cat << __EOT
@


1.272
log
@Code cleanup, simplification and shrinkage.

Eliminate the function get_setsdir() by merging it into
install_mounted_fs(). Eliminate global SETSDIR as a result.

Move the loop logic used to select the directory to use on a mounted
filesystem to a 'done' style loop. i.e. loop until valid input (a
directory which exists) or 'done'. 'done' implies abandoning effort to
find a directory.

Eliminate the test for and associated error message about no
filesystems being mounted below the mount point passed to
install_mounted_fs(). This served little purpose not addressed by the
message generated when a non-existant directory is entered.  i.e.
novices won't understand and experts can '!' out to investigate.

Remove the option to list mounted filesystems. Same reasons as for
eliminating the test for mounted filesystems.

Move repeated tests for an empty GET_FILES into the function
invariably called after the tests (install_get_files()).
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.271 2002/11/09 04:41:56 krw Exp $
d382 6
d389 1
a389 1
	local _d=$1
d391 5
a395 2
	# Don't need to make network interface devices.
	isin $_d $IFDEVS && return
d397 3
a399 9
	if [ ! -c /dev/r${_d}c ]; then
		if [ -r /dev/MAKEDEV ]; then
			(cd /dev; sh MAKEDEV $_d)
			DEVSMADE=`addel $_d $DEVSMADE`
		else
			echo "Device nodes for $_d are missing, and MAKEDEV"
			echo "does not exist to create them with.  Sorry."
			false
		fi
d401 8
@


1.271
log
@Fix two problems:

1) When asked to choose a device, a user could enter two identical
words separated by a blank (e.g. 'a a') and thereby confuse the check
for selection validity. Quote user response before using it.

2) When asked to choose a sub-timezone, the user could escape to
a shell and when returning only see half the sub-timezone prompt
redisplayed. Put entire prompt into ask() parameter rather than
displaying first half in a separate echo -n.

Also change a "(or done)" to "(or 'done')" to be consistant with
other similar displays and move the initial comment for mount_a_disk()
to before the function to conform to normal usage.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.270 2002/11/07 01:28:52 krw Exp $
a381 43
# $1 is the mountpoint the local directory will be relative to.
# $2 is the default directory
get_setsdir() {
	local _mp=$1 _dir=$2 _mounted
	
	SETSDIR=

	_mounted=`mount | sed -ne "/\(.*\)\/\(${_mp#/}\)\/*\(.*\) type.*/s//\/\3/p"`

	if [ -z "$_mounted" ]; then
		echo "No filesystems mounted at or below ${_mp}."
		return
	fi

	while : ; do
		ask "Enter the pathname where the sets are stored (or '?')" "$_dir"
		case $resp in
		"?")	cat << __EOT
Sets could be stored on:

${_mounted}

__EOT
			continue
			;;
		"")	;;
		*)	if [ -d "${_mp}/${resp}" ]; then
				SETSDIR=${_mp}/${resp}
				return
			fi
			echo "The directory '${resp}' does not exist."
			;;
		esac

		ask "Re-enter pathname?" y
		case $resp in
		y*|Y*)	;;
		*)	break
			;;
		esac
	done
}

d864 3
a1063 3
	# User may have selected no files
	[ "$GET_FILES" ] || return

d1070 17
a1086 5
	local _f

	get_setsdir "$1" "$2"

	[ -d "$SETSDIR" ] || return
d1088 1
a1088 4
	get_get_files "`ls -l ${SETSDIR}`" "$SETSDIR"

	# User may have selected no files
	[ "$GET_FILES" ] || return
d1090 1
a1090 1
	install_get_files "file:$SETSDIR"
a1905 1
SETSDIR=
@


1.270
log
@Treat 'bsd' like just another filename in THESETS, no more 'kernel'
logic.  As result, MDSETS gone from everything but mac68k.

MDSETS now treated as a list of complete file names to add to THESETS,
allowing more MD flexibility, i.e. may or may not be .tgz files.

All traces of tar.gz removed. Not used for sets since 2.7 or so. As a
result of code simplification from not having to consider tar.gz, the
functions get_sets(), make_lastset(), and set_not_done() are
eliminated, along with the global SETS.

Build THESETS and DEFAULTSETS to contain full file names.

Always install sets in the order they appear in THESETS, keeping
siteXX last but without needing special logic. More predictable for
user if a lot of set additions and removals done before being
satisfied, as the sets are now installed in the same order they appear
in the selection list.

Remove ability to look for non-set .tgz/.tar.gz files. The job of the
install scripts is to install the standard sets in a simple and
rational way. Not to install general tar balls. The user can do that
post-install or simply '!' out to do it during install. On their head
be it.

If no sets are found in a specified source, list the filenames in
THESETS to show what is being looked for.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.269 2002/11/01 01:08:15 krw Exp $
d264 1
a264 1
		ask "Available ${_name}s are: ${_devs}.\nWhich one $_query (or done)" "$_defdev"
d266 3
a268 1
		if isin $resp $_devs ; then
d1208 3
a1211 4
	# Mount a disk on /mnt2. The set of disk devices to choose from
	# is $DKDEVS.
	# returns 0 on success, 1 on failure

d1446 1
a1446 2
			echo -n "Select a sub-timezone of "
			ask "'${_zonepath#$_zoneroot}' ('?' for list):"
@


1.269
log
@Cleanup. Don't bother complaining when the user selects some non-existant
set. Just re-display the selection list unchanged. Smaller, cleaner.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.268 2002/10/31 00:30:31 krw Exp $
d79 1
d822 3
d826 1
a826 1
	local _selection=$1 _action _f
d843 1
a843 1
	for _f in $SETS; do
d853 5
a857 7
# Set global SETS to either
#     1) a list of sets found in both $1 and $THESETS, where
#        $2 is the location that generated the list of files in $1.
# or
#     2) a list of .tgz or .tar.gz files found in $2
get_sets () {
	local _f _file_list=$1 _src=$2
d859 1
a859 1
	SETS=
d862 3
a864 8
		if [ "$_f" = "kernel" ]; then
			if isin bsd $_file_list; then
				SETS="$SETS bsd"
			fi
		elif isin ${_f}${VERSION}.tar.gz $_file_list; then
			SETS="$SETS ${_f}${VERSION}.tar.gz"
		elif isin ${_f}${VERSION}.tgz $_file_list; then
			SETS="$SETS ${_f}${VERSION}.tgz"
d868 1
a868 1
	if [ -z "$SETS" ]; then
d874 1
d876 2
a877 9
		ask "Search for other *.tar.gz and *.tgz files?" y
		case $resp in
		n*|N*)	return ;;
		esac
		# *.tar.gz and *.tgz are possible sets
		for _f in $_file_list ; do
			case $_f in
			*.tar.gz|*.tgz)	SETS="$SETS ${_f}"
			esac
a878 8
	fi

	if [ -z "$SETS" ]; then
		ask "There are no *.tar.gz or *.tgz files in ${_src}.\nSee a directory listing?" y
		case $resp in
		n*|N*)	return ;;
		esac
		echo "\n${_file_list}\n"
a880 23
}

# Set global GET_FILES to the list of sets requested by the user.
# $1 = list of files available in source directory or url.
# $2 = source directory or url
get_get_files () {
	local _files=$1 _src=$2

	GET_FILES=

	get_sets "$_files" "$_src"

	[ "$SETS" ] || return

	# Set the default list of files
	for _f in $SETS ; do
		# $SETS contains only .tgz and .tar.gz file names and 'bsd'.
		case $_f in
		base*|bsd|comp*|etc*|game*|man*|misc*)
			isin $_f $SETSDONE || GET_FILES=`addel $_f $GET_FILES`
			;;
		esac
	done
d891 1
a891 1
		do_selection_list "$SETS" "$GET_FILES" "File Name?"
d895 1
a895 1
		glob_selection "$resp"
a898 10
# Ensure that $1 (if present) is the last element in $GET_FILES.
make_last_set () {
	local _set=$1

	if isin $_set $GET_FILES; then
		GET_FILES=`rmel $_set $GET_FILES`
		GET_FILES=`addel $_set $GET_FILES`
	fi
}

a909 9
	# Ensure that siteXX.tgz and siteXX.tar.gz are the *last* sets
	# installed so their contents overwrite the contents of the
	# other sets, not the other way around. By selecting sets out
	# of order, the user can cause a set other than siteXX to be
	# the last set in GET_FILES.

	make_last_set "site${VERSION}.tgz"
	make_last_set "site${VERSION}.tar.gz"

d911 2
a912 1
	for _f in $GET_FILES ; do
d915 1
a915 2
		*.tar.gz|*.tgz)
			ftp ${_ftp_active} -o - -V -m "${_src}/${_f}" | tar zxpf - -C /mnt
d917 1
a917 2
		*)
			ftp ${_ftp_active} -o "/mnt/${_f}" -V -m "${_src}/${_f}"
a1465 11
# Remove $1 from $SETSDONE, taking account of the different
# possible suffixes - none for bsd, .tgz or .tar.gz for the
# other sets.
set_not_done () {
	local _set=$1

	SETSDONE=`rmel $_set $SETSDONE`
	SETSDONE=`rmel ${_set}.tgz $SETSDONE`
	SETSDONE=`rmel ${_set}.tar.tgz $SETSDONE`
}

d1481 1
a1481 1
		set_not_done bsd
d1492 1
a1492 1
		set_not_done base${VERSION}
d1504 1
a1504 1
		set_not_done etc${VERSION}
d1927 11
a1937 3
# $MDSETS is the list of kernels for an architecture.
# extra "site" set can be provided by person doing install or upgrade.
THESETS="$MDSETS base etc misc comp man game xbase xshare xfont xserv site"
a1939 1
SETS=
@


1.268
log
@Introduce some better feedback during attempted ftp installations. In
this pass check the file list returned by ftp_list_file() for two
common errors ('Login failed.' and 'No such file or directory.') and
display the error messages rather than just complaining that no sets
were found.

Delete an unused local variable.

Do not allow the user to continue with the install/upgrade if the
sanity checks fail. Keep asking them to install more sets until the
checks succeed.

ok millert@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.267 2002/10/28 00:36:04 krw Exp $
d819 1
a819 1
# Do globbing on the selection and parse +/-, sets the global
d822 1
a822 2
	local _selection=$1 _src=$2
	local _action _nomatch _f
a842 1
			_nomatch=false
a846 10

	if $_nomatch; then
		cat << __EOT
The file

    '${_src}/${_selection}'

does not exist. Check to make sure you entered the name properly.
__EOT
	fi
d935 1
a935 1
		glob_selection "$resp" "$_src"
@


1.267
log
@Rework/reword the install sanity checks and associated logic slightly.

1) Do all three sanity checks (for bsd, base32, etc32) every time so
the user is aware of all three problems asap. Make the error messages
stand out, and refer explicitly to the sets that should fix the
problem.

2) Use standard 'done' logic to exit the set selection loop rather than
ask a separate question. One side effect: a <cr> at the set location
prompt now just causes the redisplay of the prompt rather than an
error.

3) Remove 'suspect' sets from the SETSDONE list so that if bsd, base32
or etc32 are found to be wanting, they are automatically selected the
next time they appear on the list of available sets.

4) But the $MDSETS (and therefore the 'bsd' set) first on the
selection list. This puts all three 'required' sets at the top of the
list where they seem to belong.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.266 2002/10/27 14:05:21 krw Exp $
d1013 13
d1032 1
a1032 1
	local _f _file_list _url_type=$1 _url_base _url_login _url_pass _oifs
d1164 2
d1596 1
a1596 2
	resp=
	[[ -n $_insane ]] && ask "\nDo you want to (re)install the problem sets?" y
d1598 1
a1598 4
	case $resp in
	Y*|y*)	return 1 ;;
	*)	return 0 ;;
	esac
@


1.266
log
@Ensure that 'siteXX.tgz' and 'siteXX.tar.gz' are the *last* sets
installed.

This should guarantee that any site-specific files which are intended
to replace files installed from 'normal' sets will do so.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.265 2002/10/04 01:22:39 deraadt Exp $
d1523 20
d1544 6
a1549 1
	if [ ! -s /mnt/bsd ]; then
d1552 2
a1553 3
Warning, no kernel (/mnt/bsd) installed! You did not unpack a file set
containing a kernel -- this is needed to boot. Please note that the install
kernel is *not* suitable for general use.
d1555 1
a1555 2
	elif [ ! -f /mnt/bin/cat ]; then
		cat << __EOT
d1557 4
a1560 5
You still do not have a /bin/cat in your filesystem (i.e. a sample random file
which you probably want). This seems to indicate that you are still missing
important distribution files.
__EOT
	elif [ ! -x /mnt/dev/MAKEDEV ]; then
d1563 3
a1565 1
No /dev/MAKEDEV has been installed yet.
d1567 1
d1569 4
a1572 1
	elif [ ! -d /mnt/etc -o ! -d /mnt/usr/share/zoneinfo -o ! -d /mnt/dev ]; then
d1575 3
a1577 2
One or more of /etc, /usr/share/zoneinfo or /dev is missing. Did you
forget to extract a required set?
a1578 2
	else
		return 0
d1581 2
a1582 1
	cat << __EOT
d1584 4
a1587 5
You can now try to install the missing set(s), or you can enter '!' at the
prompt to escape to a shell and fix things by hand.
__EOT

	return 1
d1608 1
a1608 1
		ask "Where are the ${MODE} sets you want to use? (m, c, f, etc.)"
d1611 9
a1619 30
		c*|C*)	install_cdrom
			;;
		d*|D*)	install_disk
			;;
		f*|F*)	install_url ftp
			;;
		h*|H*)	install_url http
			;;
		m*|M*)	install_mounted_fs /mnt
			;;
		n*|N*)	install_nfs
			;;
		t*|T*)	install_tape
			;;
		*)	echo "Invalid response: $resp"
			;;
		esac

		# Give the user the opportunity to extract more sets.

		ask "Extract more sets?" n
		case $resp in
		n*|N*)	# Perform sanity checks...
			sane_install && break
			ask "\nDo you want to extract more sets?" y
			case $resp in 
			n*|N*)	break
				;;
			esac
			;;
d1999 1
d2001 1
a2001 1
THESETS="base etc misc comp man game xbase xshare xfont xserv $MDSETS site"
@


1.265
log
@krw fucked up; i must re-tag this file
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.264 2002/10/03 00:56:44 krw Exp $
d951 10
d971 9
d1994 1
a1994 1
THESETS="base etc misc comp man game xbase xshare xfont xserv site $MDSETS"
@


1.264
log
@Divorce system hostname handling from network configuration.

Every system has a name, and thus generated keys with that
name, even if there is no currently configured network.

So, ask for a system hostname before configuring the network.

Eliminate /tmp/myname and just keep hostname set to the lastest name
and FQDN.

Construct /etc/myname from hostname as configuration data is being
saved. Construct /etc/hosts (preserving the informative leading comment
from the /etc/hosts file in etcXX.tgx) at the same time.

Construct an appropriate /etc/hosts file even if the network is not
configured.

During upgrade, if the user enables the network using the existing
configuration, don't ask about the domain name - just use the
configured one.

Take care to handle existing /etc/myname files which do not necessarily
have a FQDN.

Originally problem with hostname handling pointed out by beck@@.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.263 2002/09/30 07:07:55 deraadt Exp $
d1745 1
a1745 4
	if [[ ! -f $1 ]]; then
		FQDN=
		return
	fi
@


1.263
log
@a few new spaces -> tabs
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.262 2002/09/29 22:52:21 krw Exp $
d533 1
a533 1
	local _if_symname _if_extra _hostname
d566 1
a566 2
	_hostname=`hostname`
	ask_until "Symbolic (host) name?" "$_hostname"
d601 1
a601 1
send host-name "$_hostname";
d680 7
a686 7
	# Check for required network related files
	for _netfile in hosts myname; do
		if [ ! -f /mnt/etc/${_netfile} ]; then
			echo "ERROR: no /mnt/etc/${_netfile}!"
			return 1
		fi
	done
d689 1
a689 1
	for _netfile in hosts myname dhclient.conf resolv.conf resolv.conf.tail protocols services; do
a694 3
	hostname=`cat /etc/myname`
	hostname $hostname

d701 1
a701 1
	route -n add -host $hostname localhost > /dev/null
a802 3
	# Get FQDN after any DHCP manipulation of resolv.conf is done
	get_fqdn /etc/resolv.conf

d1108 1
a1108 1
		_ftp_server_password=root@@`hostname`.$FQDN
d1742 16
a1757 1
# on that line as FQDN. Then ask user, just to be sure.
d1761 1
a1761 6
	if [ -f "$1" ]; then
		FQDN=`sed -n \
			-e '/^domain[[:space:]][[:space:]]*/{s///;s/\([^[:space:]]*\).*$/\1/;h;}' \
			-e '/^search[[:space:]][[:space:]]*/{s///;s/\([^[:space:]]*\).*$/\1/;h;}' \
			-e '${g;p;}' $1`
	fi
a1783 9
	[ -f /tmp/myname ] && _nam=`cat /tmp/myname`

	# chop off any fqdn that may be present in /tmp/myname.
	_nam=${_nam%%.*}

	ask_until "Enter system hostname (short form, e.g. 'foo'):" "$_nam"
	hostname $resp
	echo $resp > /tmp/myname

a1807 1
	FQDN=
d1827 1
a1827 5
	# Also add FQDN to myname
	if [ "$FQDN" ]; then
		sed "s/\\(.*\\)\$/\\1.${FQDN}/" /tmp/myname > /tmp/myname.new
		mv /tmp/myname.new /tmp/myname
	fi
d1985 6
@


1.262
log
@Keep track of all devices that makedev() creates and recreate
them in the installed system.

ok deraadt@@. (which I forgot to mention for the last commit).
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.261 2002/09/29 22:45:44 krw Exp $
d389 2
a390 2
	    echo "No filesystems mounted at or below ${_mp}."
	    return
d576 1
a576 1
        _mediaopts=`ifconfig -m $_if_name | sed -n '/media:/D;/media/p'`
@


1.261
log
@Modify makedev so that it does not attempt to create network interface
devices, to allow ask_which() to be used for interface configuration.

Rework network interface configuration logic to use ask_which() instead
of local code. This

1) May fix the problem noted by David Norman, where the prompts are
somehow broken, since no such problems have been noted with the
ask_which() code.

2) Shrinks the install output by a few lines.

3) Makes the install script smaller and clearer.

4) Makes interface configuration consistant with other 'device'
configurations.

5) Makes it impossible for a user to configure an interface more than
once.

Add the interface name to the 'IP address (or dhcp)' question. This
makes it more informative, especially if a '!' or '!foo' shell escape
has been used and overwritten the list of interfaces and the display of
the name of the one being configured.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.260 2002/09/28 23:35:12 krw Exp $
d431 1
d1924 2
d1928 1
a1928 1
	echo -n "Making all device nodes (by running /dev/MAKEDEV all) ..."
d1931 6
a1936 1
	echo "... done."
d1984 3
@


1.260
log
@Cleanup/fix/improve question asking.

1) If the user escapes to a shell with '!' or executes a command with
'!foo' at a prompt then repeat the prompt when the shell or command
returns.

2) If ask_which() is passed an empty list of devices , then set resp to
'done' and return. Replaces a couple of checks before calling
ask_which(). Also emit a message about the lack of devices.

3) In ask_which(), delete any trailing blank which rmel() may have
appended to the device list. Replaces a check before calling
ask_which().

4) Remove an unneeded blank line before the 'invalid choice' message
from ask_which().

5) Make the first disk device the default answer when asking for which
disk contains install sets.

A few code/verbiage nits:

1) make _a a local in cutlast().

2) use normal ': ${_defdev:=done}' idiom instead of an or condition in
ask_which.

3) Eliminate an unnecessary blank line/paragraph by putting 3(!)
sentences into a single paragraph when describing process of selecting
install sets.

4) Eliminate another unnecessary blank line between the list of
possible install sources and the question about which one to use.

5) Eliminate another unnecessary blank line before the 'Extract
more sets?' question

6) Eliminate a double blank line after the sanity check error
messages.

ok deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.259 2002/09/24 01:26:15 krw Exp $
d425 3
d516 1
a516 1
	local _ifsdone _ifs
d519 1
a519 1
		cat << __EOT
d521 1
a521 1
Available network interfaces ([X] == already configured) are:
d523 1
a523 2
__EOT
		do_selection_list "$IFDEVS" "$_ifsdone" "Configure which interface?"
d525 2
a526 13
		case $resp in
		"done")	break	
			;;
		*)	_ifs=$resp
			if isin $_ifs $IFDEVS ; then
				if configure_ifs $_ifs ; then
					_ifsdone="$_ifs $_ifsdone"
				fi
			else
				echo "Invalid response: '$resp' is not in list"
			fi
			;;
		esac
d556 1
a556 1
		ask "IP address${_dhcp_prompt}?" "$_if_ip"
@


1.259
log
@Rejig addel()/rmel() to keep items on a single line, with blanks
separating items.

This allows a compaction of the displayed lines for device selection.

Customize the device selection routine so the actual device type is
shown (disk or CD-ROM). Rename ask_fordev to ask_which so the
invocations (with device type) read better.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.258 2002/09/22 22:42:25 krw Exp $
d200 1
a200 2
	echo -n "$1 "
	[ $# -lt 2 ] || echo -n "[$2] "
d204 2
d213 1
a213 1
		*)	: ${resp:=$2}
d246 6
a251 1
	[ "$_defdev" ] || _defdev=done
d254 5
d260 4
a263 2
		echo "Available ${_name}s are: ${_devs}."
		ask "Which one $_query (or done)" "$_defdev"
d268 1
a268 1
			echo "\n'$resp' is not a valid choice."
d330 2
a1180 6
	# Get the cdrom device info
	if [ -z "$CDDEVS" ]; then
		echo "No CD-ROM devices are available."
		return
	fi

d1267 1
a1267 1
	ask_which "disk" "contains the ${MODE} sets?" "$DKDEVS"
a1553 1

d1565 4
a1568 6
You will now specify the location and names of the ${MODE} sets you want
to load. You will be able to repeat this step until all of your sets
have been successfully loaded.

If you are not sure what sets to ${MODE}, refer to the installation notes
for details on the contents of each.
a1575 1

d1600 1
a1600 1
		ask "\nExtract more sets?" n
@


1.258
log
@Do not allow install to proceed until root filesystem can be mounted on
$ROOTDEV and ${ROOTDISK}b can be used for swap.  Also shortens output
generated during (successful) install.

Fix problem with upgrade on systems with many disk devices by
automatically creating devices encountered during the fsck'ing of fstab
filesystems. Problem noted by Dethlef Madsen and Nick Nauwelaerts.

Adjust some verbiage in i386 install.md to make it more consistant.

Reformat welcome message to make sure all lines are <80 characters wide.

Minor cleanups.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.257 2002/09/20 00:15:00 millert Exp $
d236 4
a239 3
# $1 = question to ask
# $2 = list of devices from /var/run/dmesg.boot scan
# $3 = default device
d242 2
a243 2
ask_fordev () {
	local _query=$1 _devs=$2 _defdev=$3
d249 2
a250 2
		echo "\nAvailable devices are:\n\n${_devs}\n"
		ask "$_query (or done)" "$_defdev"
d279 1
a279 1
		echo "$_b"
d283 1
a283 1
	$_seen || echo "$_a"
d293 1
a293 1
		[ "$_a" != "$_b" ] && echo "$_b"
d433 1
d440 1
a440 1
	ask_fordev "Which disk is the root disk?" "$DKDEVS" "$_defdsk"
d1172 1
a1172 1
	ask_fordev "Which CD-ROM contains the ${MODE} media?" "$CDDEVS" "`echo $CDDEVS | cutword 1`"
d1258 1
a1258 1
	ask_fordev "Which disk contains the ${MODE} sets?" "$DKDEVS"
@


1.257
log
@Add pflog, vlan and gif to list of interfaces filtered; krw@@ OK
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.256 2002/09/17 16:15:25 krw Exp $
d104 3
a106 3
any prompt except password prompts you can run a shell command by typing '!foo',
or escape to a shell by typing '!'. Default answers are shown in []'s and are
selected by pressing RETURN. At any time you can exit this program by
a422 2
	ROOTDISK=

d435 3
d1732 3
d1737 1
a1737 1
			echo "FAILED. You must fsck this device manually."
@


1.256
log
@Fix commit botch that deleted '#' at beginning of '$OpenBSD$' tag line.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.255 2002/09/17 12:28:54 krw Exp $
d174 1
a174 1
	/sbin/ifconfig -a | egrep -v '^([[:space:]]|(lo|enc|gre|ppp|sl|tun|bridge)[[:digit:]])' | cutword -t: 1
@


1.255
log
@Ruthlessly expunge unnecessary verbiage and whitespace to make sure
the install example will easily fit on the CD insert at some
reasonable font size. Reword many messages and questions for same
reason.

In addition:

1) Add '...done.' to match 'Installing boot block...'

2) During install, after asking which is the root disk, start
initializing it immediately rather than asking again which disk to
work on.

3) Move munged fstab filesystem mounting to *before* network
initialization so that if you bail out during network initialization
and restart you do not have to go through disk initialization again.
Also puts fsck and mount messages close to each other rather than
spitting out the latter just before root password questions.

4) Make 'usr/obj' nosuid,nodev by default, /home nodev by default.

5) For network interfaces only show the complete list of media options
if the user indicates they want to change the default.

6) Move the question about the ftp server supporting passive ftp to
*after* selecting the ftp server where it is more 'rational' and can
easily be made more concise.

7) Don't bother umount'ing filesystems or stopping the dhclient after
a successful install/upgrade. The next step is a reboot after all.

Some minor code tweaks and comment cleanup while in the area.

Tested in recent snapshots. Suggested by & ok deraadt@@.
@
text
@d1 1
a1 1
	$OpenBSD: install.sub,v 1.254 2002/09/10 21:36:56 deraadt Exp $
@


1.254
log
@move to 3.2-beta
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.253 2002/08/27 02:27:07 krw Exp $
d96 3
a98 1
welcome_banner() {
d101 8
d110 6
a115 8
As with anything that modifies your disk's contents, this program can
cause SIGNIFICANT data loss, and you are advised to make sure your
data is backed up before beginning the installation process.

Default answers are displayed in brackets after the questions. You can
hit Control-C at any time to quit, but if you do so at a prompt, you
may have to hit return. Also, quitting in the middle of an ${MODE} may
leave your system in an inconsistent state.
d117 2
a118 2
If you hit Control-C and restart the ${MODE}, the ${MODE} program will
remember many of your old answers.
d120 3
a122 1
	if [ "$MODE" = "upgrade" ]; then
d125 2
a126 4
As a reminder, installing the 'etc' binary set is NOT recommended.
Once the rest of your system has been upgraded, you should manually
merge any changes to files in the 'etc' set into those files which
already exist on your system.
d128 4
a131 1
	else
d134 2
a135 3
You'll be asked several questions, and it would probably be useful to
have your disk's hardware manual, the installation notes, and a
calculator handy.
d137 26
a162 1
	fi
d381 1
a381 2
The following filesystems are mounted at or below ${_mp} and are therefore
possible sources for ${MODE} sets:
d397 1
a397 1
		ask "\nRe-enter pathname?" y
d428 1
d431 3
a433 3
The installation program needs to know which disk to consider the root disk.
Note the unit number may be different than the unit number you used in the
boot program (especially on a machine with multiple disk controllers).
d435 2
d500 1
a500 2
You may configure the following network interfaces (the interfaces
marked with [X] have been successfully configured):
d524 1
a524 1
	local _dhcp_prompt
d566 2
a567 1
	if [ "`ifconfig -m ${_if_name} | sed -n '/media/p'`" ]; then
d569 2
a570 2
Your use of the network interface may require non-default
media directives. The default media is:
d572 5
a576 11
		ifconfig -m ${_if_name} | sed -n '
			/supported/D
			/media:/p'
		echo "This is a list of supported media:"
		ifconfig -m ${_if_name} | sed -n '
			/media:/D
			s/^	//
			/media/p'
		cat << __EOT
If the default is not satisfactory, and you wish to use another
media, copy that line from above (e.g. "media 100baseTX")
d578 5
a582 2
		ask "Media directives?"
		_if_extra=$resp
d882 1
a882 1
The directory
a885 1
contains no OpenBSD ${VERSION_MAJOR}.${VERSION_MINOR} ${MODE} sets.
a920 7
	cat << __EOT

You will now be asked which sets to ${MODE}. Some of these sets are required
for your ${MODE} and some are optional. You will want at least the
base and bsd sets. Consult the installation notes if you are not sure
which sets are required!
__EOT
a1000 6
	cat << __EOT

This is an automated ${_url_type}-based installation process. You will be asked
questions and then the files will be retrieved iteratively via ${_url_type}.

__EOT
a1011 19
	if [ "$_url_type" = "ftp" -a -z "$ftp_proxy" ]; then
		# Use active mode ftp? (irrelevant if using a proxy)
		case $_ftp_active in
		-A)	resp=y ;;
		*)	resp=n ;;
		esac

		cat << __EOT
By default, ftp will attempt a passive connection and fall back to a normal
(active) connection if that does not work. However, there are some very
old ftp servers that claim to support passive mode, but really do not.
In this case, you should explicitly request an active session.
__EOT
		ask "Do you want to use active ftp?" "$resp"
		case $resp in
		y*|Y*)	_ftp_active=-A ;;
		*)	unset _ftp_active ;;
		esac
	fi
d1016 1
a1016 1
	ask "Do you want a list of potential ${_url_type} servers?" "$_ftp_getlist"
d1071 16
a1139 6
	cat << __EOT

Fetching files via ${_url_type} may take a long time, especially over a slow
network connection.
__EOT

d1169 1
a1169 7
	cat << __EOT

Please make sure the CD is in the CD-ROM drive and select
the device containing the CD with the installation sets.
__EOT

	ask_fordev "Which CD-ROM contains the installation media?" "$CDDEVS" "`echo $CDDEVS | cutword 1`"
d1215 1
a1215 1
There are two CD-ROM filesystem types currently supported by this program:
d1255 1
a1255 7
	cat << __EOT

Please select the disk device containing the partition with the
installation sets.
__EOT

	ask_fordev "Which is the disk with the installation sets?" "$DKDEVS"
a1465 10
	cat << __EOT

Select a time zone for your location. Timezones are represented on the system
by a directory structure rooted in "/usr/share/timezone". Most timezones can
be selected by entering a token like "CET" or "GMT-6". Other zones are
grouped by continent or country, with detailed zone information separated by
a slash ("/"), e.g. "US/Pacific" or "Canada/Mountain".

__EOT

d1540 2
a1541 2
You will now be given the chance to install the missing set(s). You can
enter '!' at the prompt to escape to a shell and fix things by hand if you wish.
d1554 3
a1556 5
You will now be asked for the location of the ${MODE} sets you want to
use, and then which sets to actually use. These steps will repeat
until you are satisfied that all the sets you want have been
loaded. Thus you will be able to load sets from multiple locations,
and you can recover from some errors.
d1558 2
a1563 1
Sets can be located on a
d1565 2
a1566 3
	(m)ounted filesystem
	(c)drom, (d)isk or (t)ape device
	(f)tp, (n)fs or (h)ttp server
d1806 2
a1807 3
If any interfaces will be configured using a DHCP server
it is recommended that you do not enter a DNS domain name,
a default route, or any name servers.
d1885 1
a1885 1
		echo "\nThe host table is as follows:\n"
d1887 1
a1887 7
	cat << __EOT

You may want to edit the host table in the event that you are doing an
NFS installation or an FTP installation without a name server and want
to refer to the server by name rather than by its numeric ip address.
__EOT
		ask "Would you like to edit the host table with ${EDITOR}?" n
d1894 1
a1894 8
	cat << __EOT

You will now be given the opportunity to escape to the command shell to do
any additional network configuration you may need. This may include adding
additional routes, if needed. In addition, you might take this opportunity
to redo the default route in the event that it failed above.
__EOT
	ask "Escape to shell?" n
d1911 1
a1911 1
	ask "\nDo you expect to run the X Window System?" y
a1915 1
		echo "machdep.allowaperture enabled in /etc/sysctl.conf. Read xf86(4) for details."
a1932 1
	# XXXXX - what is this for?
d1935 2
a1936 3
	# Unmount filesystems, etc. Disable trap that would do same on exit.
	# Do this manually rather than through the trap so congrats is
	# the last message printed.
a1937 1
	cleanup_on_exit
d1991 1
a1991 1
# Cleanup when the script exits.
a1994 1

d1996 1
a1996 43
cat << __EOT

Welcome to the OpenBSD/${ARCH} ${VERSION_MAJOR}.${VERSION_MINOR} ${MODE} program.

This program will help you ${MODE} OpenBSD in a simple and rational way.

At any prompt except password prompts you can run a shell command by
typing '!foo', or escape to a shell by typing '!'.

__EOT

# Deal with terminal issues now, so 'less' can print meaningfull prompt if
# messages are >1 page long.
set_term

# Good {morning,afternoon,evening,night}.
welcome_banner | less -XE

if [ -f /etc/fstab -a "$MODE" = "install" ]; then
	cat << __EOT

You seem to be trying to restart an interrupted installation!
You can skip the disk preparation steps and continue,
or you can reboot and start over.

__EOT
	echo -n "Skip disk initialization and p"
else
	echo -n "\nP"
fi
	
ask "roceed with ${MODE}?" n
case $resp in
y*|Y*)	echo "\nCool!  Let's get to it...\n"
	;;
*)	cat << __EOT

Enter 'halt' at the prompt to gracefully exit OpenBSD. You can then
power cycle the machine and boot your original OS.
__EOT
	exit
	;;
esac
@


1.253
log
@Missed file in last commit.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.252 2002/08/15 22:56:03 krw Exp $
d1993 1
a1993 1
VERSION=31
@


1.252
log
@Fix a problem with re-started installs that caused the domain
name to be repeatedly appended to the host name. Simply strip
the domain name from the host name read from /tmp/myname.

Problem noted by Nick Holland.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.251 2002/07/28 01:14:58 krw Exp $
d219 1
a219 1
			echo "\n'$resp' does not exist."
d2071 3
@


1.251
log
@New feature request by (most recently) drahn@@:

Do not allow the same mountpoint to be specified for >1 disk
partition.

If a mountpoint that has already been specified is entered again an
error message of the form:

Invalid response: sd0a is already being mounted at /var

is emitted. Partitions on both the disk being initialized and
previously initialized disks are checked.

Rework a bit of the logic to simplify and shorten in compensation. e.g.
eliminate references to /tmp/fstab.<disk> as it is never created.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.250 2002/07/27 04:05:08 krw Exp $
a1790 1
	_nam=
d1792 3
@


1.250
log
@Fix two problems.

1) Even if /sbin/mount_nfs is present, do *not* try to automatically
mount nfs file systems. Because not all name resolution mechanisms are
present during upgrade (e.g. yp) it is not safe to do so. The user
must manually mount nfs file systems if they are the source of any
sets.  Problem noted by miod@@, change seconded by deraadt@@.

2) Change initial verbiage so that a brief introduction is displayed,
along with the information about !foo or !, before the terminal type
is requested.  After the terminal type is known display the rest of
the introductory text using less -XE. This belts and suspender fix
makes both the install and upgrade text fit in 'page' size (<24 lines)
chunks and ensures that if the text ever grows beyond a page a more
informative prompt is displayed. Problem noted by millert@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.249 2002/07/22 00:13:01 krw Exp $
d98 1
@


1.249
log
@Undo a cvs botch in the last commit that reverted a few lines.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.248 2002/07/18 00:36:44 krw Exp $
d99 8
a106 1
Welcome to the OpenBSD/${ARCH} ${VERSION_MAJOR}.${VERSION_MINOR} ${MODE} program.
d108 2
a109 1
This program will help you ${MODE} OpenBSD in a simple and rational way.
a110 1

a126 18

	cat << __EOT

As with anything that modifies your disk's contents, this program can
cause SIGNIFICANT data loss, and you are advised to make sure your
data is backed up before beginning the installation process.

Default answers are displayed in brackets after the questions. You can
hit Control-C at any time to quit, but if you do so at a prompt, you
may have to hit return. Also, quitting in the middle of an ${MODE} may
leave your system in an inconsistent state.

If you hit Control-C and restart the ${MODE}, the ${MODE} program will
remember many of your old answers.

At any prompt except password prompts you can run a shell command by
typing '!foo', or escape to a shell by typing '!'.
__EOT
d1636 1
a1636 2
		*noauto*)
			continue ;;
d1642 6
d2023 17
d2041 1
a2041 1
welcome_banner | more
a2067 3

# Deal with terminal issues
set_term
@


1.248
log
@Rework upgrade's fstab handling so

1) All filesystem with a corresponding /sbin/mount_<type> available
will be mounted. i.e. don't restrict automounting to ffs filesystems
when the user can later mount the others manually.

2) All non-ffs filesystems will be mounted ro, just as currently is
the case for user-mounted filesystems.

3) fsck all to-be-mounted filesystems that have a corresponding
/sbin/fsck_<type> program present.

Some verbiage adjustment and related code cleanup as well.

ok deraadt@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.247 2002/07/13 16:32:13 krw Exp $
d1742 1
a1742 1
	local _dev _mp _fstype _rest _badfsck=0 _root=$1
d1747 1
a1747 1
		[ "$_dev" != "$_root" ] || continue
@


1.247
log
@Cleanup/Shrinkage.

1) Eliminate more if's in favour of 'cond || stmt' or
   'cond && stmt' constructs.

2) Global _didnet -> DIDNET, make local _nam a local.

3) Display 'DHCP not supported' error every time user
   specifies 'dhcp' but the client is not present.

4) if if_extra is empty, that's ok, so just assign
   $resp to it whether $resp is empty or not.

5) Check for DIDNET inside donetconfig() instead of
   before each call to donetconfig.

6) Eliminate superfluous 'Aborting' comments, and let
   the user draw their own conclusion from getting the
   'Extract more sets' message.

7) Minor code tweaks like not continually assigning
   $resp to a value in a loop, when all we want is
   the final value, and only displaying 'Skipping'
   message in tape installs if we are actually
   skipping files, etc.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.246 2002/07/13 13:18:05 krw Exp $
d1640 1
a1640 2
		# Skip comment lines, non-ffs filesystems and
		# 'noauto' filesystems.
d1644 2
a1645 4
		case $_fstype in
		ffs)	;;
		*)	continue ;;
		esac
d1651 5
a1655 1
		# Don't use soft updates
d1659 6
d1667 1
d1669 1
d1736 3
a1738 3
# Preen all filesystems in /etc/fstab, showing individual results,
# but skipping the root filesystem device $ROOTDEV. This was
# already fsck'ed successfully.
d1742 1
a1742 1
	local _dev _rest _fail
d1746 3
a1748 2
	while read _dev _rest; do
		[ "$_dev" = "/dev/$ROOTDEV" ] && continue
@


1.246
log
@More cleanup/simplification/shrinkage.

1) Factor out inquiring for a device. ask_fordev()
   now does this for root disk determination, other
   disk initialization, install sets disk or cd
   inquiry. Also ensures cd devices are created on
   the fly like disk devices already were, and
   shortens some verbiage.

2) Just ask for root disk if install is skipping
   disk initialization, rather than doing the
   'df /mnt ...' scan, since 1) we just end up asking
   anyway and 2) everything *should* have been
   umount'ed when previous install was finished or
   interrupted.

3) getrootdisk -> get_rootdisk to conform to
   get_<global> naming convention.

4) Add and use new global ROOTDEV rather than
   constantly adding 'a' to ROOTDISK. ROOTDEV
   default is set in get_rootdisk().

5) Put loop inside get_rootdisk rather than
   always putting one around it. If no rootdisk
   found/specified just exit install/update.

6) Eliminate getanotherdisk since ask_fordev()
   does most of the work.

7) Eliminate parameter to check_fs, just use
   ROOTDEV instead.

8) Some typographical and minor code tweaks.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.245 2002/07/12 01:25:44 krw Exp $
d514 1
a514 3
	if [ $_up = "UP" ]; then
		ifconfig $_if_name delete down
	fi
d516 1
a516 5
	if [ ! -x /sbin/dhclient ]; then
		echo "DHCP install not supported\n"
	else
		_dhcp_prompt=" (or 'dhcp')"
	fi
d523 1
a525 1
		_if_ip=$resp
d527 1
d557 2
a558 4
		ask "Media directives?" "$_if_extra"
		if [ "$resp" ]; then
			_if_extra=$resp
		fi
d665 1
a665 1
	_didnet=1
d892 2
a897 2
	GET_FILES=

d910 1
a910 3
			if ! isin ${_f} ${SETSDONE}; then
				GET_FILES=`addel ${_f} ${GET_FILES}`
			fi
d983 1
a983 1
	[ "$_didnet" ] || donetconfig
d1189 1
a1189 1
				echo "Cannot access $_drive. Aborting."
d1244 1
a1244 1
		echo "Cannot mount CD-ROM drive. Aborting."
d1342 1
a1342 1
		echo "Cannot mount disk. Aborting."
d1363 1
a1363 1
	[ "$_didnet" ] || donetconfig
d1384 1
a1384 1
		echo "Cannot mount NFS server. Aborting."
a1405 1
		echo "Aborting."
d1411 1
a1411 1
	echo -n "Rewinding tape..."
d1413 1
a1413 2
		echo "$TAPE may not be attached to the system or may not be"
		echo "a tape device. Aborting."
a1432 1
	echo -n "Skipping to source file..."
d1434 1
d1436 1
a1436 1
			echo "Could not skip $_nskip files. Aborting."
d1439 1
a1440 1
	echo "done."
d1658 1
a1658 3
		if [ "$_mp" = "/" ]; then
			_mp=
		fi
d1678 1
a1678 3
		if [ "$_mp" != "/mnt" ]; then
			mkdir -p $_mp
		fi
d1780 5
a1784 1
	_didnet=1
d1787 1
a1787 3
	if [ -f /tmp/myname ]; then
		_nam=`cat /tmp/myname`
	fi
@


1.245
log
@Eliminate list_has_sets() by eliminating its only use. Instead of
checking for sets when the a valid directory is given in
get_setsdir(), rely on eqivalent check in get_sets() instead.

Reduces code duplication and eliminates a possible duplicated error
message about not finding sets in a directory.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.244 2002/07/12 00:07:33 krw Exp $
d208 27
d396 2
a397 20
getanotherdisk() {
	cat << __EOT

Now you can select another disk to initialize. (Do not re-select a disk
you have already entered information for). Available disks are:

$DKDEVS

__EOT
	ask "Which one?" done
	if [ "$resp" = "done" ]; then
		DISK=done
	elif isin $resp $DKDEVS ; then
		DISK=$resp
		makedev $resp || DISK=
	else
		echo "\nThe disk $resp does not exist."
		DISK=
	fi
}
d399 1
a399 2
getrootdisk() {
	local _defdsk
d409 3
a411 3
Available disks are:

$DKDEVS
d413 2
a414 9
__EOT
	ask "Which disk is the root disk?" "$_defdsk"
	if isin $resp $DKDEVS ; then
		ROOTDISK=$resp
		makedev $resp || ROOTDISK=
	else
		echo "\nThe disk '$resp' does not exist."
		ROOTDISK=
	fi
a1178 1
The following CD-ROM devices are installed on your system.
d1180 2
a1181 1
the device containing the CD with the installation sets:
d1183 2
a1184 1
$CDDEVS
d1186 1
a1186 16
__EOT

	_drive=`echo $CDDEVS | cutword 1`
	ask "Which CD-ROM contains the installation media?" "$_drive"
	case $resp in
	abort)	echo "Aborting."
		return
		;;
	*)	if isin $resp $CDDEVS ; then
			_drive=$resp
		else
			echo "\nThe CD-ROM $resp does not exist.\nAborting."
			return
		fi
		;;
	esac
d1271 2
a1272 5
The following disk devices are installed on your system; please select
the disk device containing the partition with the installation sets:

$DKDEVS

d1275 2
a1276 1
	ask "Which is the disk with the installation sets?" abort
d1278 1
a1278 12
	case $resp in
	abort)	echo "Aborting."
		return 1
		;;
	*)	if isin $resp $DKDEVS ; then
			_drive=$resp
		else
			echo "\nThe disk $resp does not exist.\nAborting."
			return 1
		fi
		;;
	esac
d1743 1
a1743 1
# but skipping the root filesystem device given in $1. This was
d1748 1
a1748 1
	local _dev _rest _fail _root=$1
d1753 1
a1753 1
		[ "$_dev" = "$_root" ] && continue
d1998 1
@


1.244
log
@Consolidate repeated logic to get non-empty $resp into a
function ask_until().

Eliminate some unnecessary ':' statements used to initialize
variables by doing initialization in first reference - i.e.
when passing the variable to ask_until().

Shrinks and clarifies.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.243 2002/07/09 23:19:10 krw Exp $
a299 22
# return true when the list $1 contains a set also in one of $2 ... $n
list_has_sets() {
	local _list=$1 _f

	shift
	for _f; do
		if isin ${_f}${VERSION}.tar.gz $_list; then
			return 0
		fi
		# Try for stupid msdos convention
		if isin ${_f}${VERSION}.tgz $_list; then
			return 0
		fi
		# Special check for kernel
		if [ "$_f" = "kernel" ] && isin bsd $_list; then
			return 0
		fi
	done

	return 1
}

d338 1
a338 3
		*)	if [ ! -d "${_mp}/${resp}" ]; then
				echo "The directory '${resp}' does not exist."
			elif list_has_sets "`ls -l ${_mp}/${resp}`" $THESETS; then
a340 8
			else
				cat << __EOT
The directory

	"$resp"

does not hold any OpenBSD ${VERSION_MAJOR}.${VERSION_MINOR} ${MODE} sets.
__EOT
d342 1
@


1.243
log
@Fix typo (get_sets_list -> get_sets) that caused ftp installs to fail.

Noticed by STeve Andre
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.242 2002/07/07 02:34:00 krw Exp $
d195 13
d566 2
a567 5
	resp=
	while [ -z "$resp" ] ; do
		ask "Symbolic (host) name?" "$_hostname"
		_if_symname=$resp
	done
d571 2
a572 6
		resp=
		: ${_if_mask:=255.255.255.0}
		while [ -z "$resp" ]; do
			ask "Netmask?" "$_if_mask"
			_if_mask=$resp
		done
d1124 3
a1126 5
	resp=
	while [ -z "$resp" ] ; do
		eval ask \"Server directory?\" \"\$_${_url_type}_server_dir\"
		eval _${_url_type}_server_dir=$resp
	done
d1133 2
a1134 6
		resp=
		: ${_ftp_server_login:=anonymous}
		while [ -z "$resp" ] ; do
			ask "Login?" "$_ftp_server_login"
			_ftp_server_login=$resp
		done
d1432 1
a1432 4
	resp=
	while [ -z "$resp" ] ; do
		ask "Server IP address or hostname?" "$_nfs_server_ip"
	done
d1436 1
a1436 4
	resp=
	while [ -z "$resp" ]; do
		ask "Filesystem on server to mount?" "$_nfs_server_path"
	done
d1468 1
a1468 4
	resp=
	while [ -z "$resp" ]; do
		ask "Name of tape device?" "${TAPE##*/}"
	done
d1859 1
a1859 4
	resp=
	while [ -z "$resp" ] ; do
		ask "Enter system hostname (short form, e.g. 'foo'):" "$_nam"
	done
@


1.242
log
@More cleanup/shrinkage/clarification.

a) Eliminate single invocation here document functions
   not_going_to_install(), congrats() by putting the here
   document at the point of invocation.

b) Make (deliberately) global variables consistantly upper case and
   with no leading '_'. Many variables that could be local are still
   creating globals.

c) Make all get_* functions names conform to a convention of
   get_<global variable name>, where the <global_variable_name>
   is the global variable set by the function, or whose new
   value is returned by the function.

d) Change _IFS to IFDEVS to be consistant with CDDEVS and DKDEVS,
   and initialize it at the same place.

e) Handle bare '+', '-' in same place other selections are parsed
   rather than in a separate case statement.

f) eliminate '[ "$var" ] || var=value' constructs with ': ${var:=value}'
   constructs.

g) Rename local_sets_dir -> SETSDIR.

h) Rework logic around ftp passwords to eliminate duplications
   and ensure a new password is asked for each time.

i) Some minor cosmetic adjustments.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.241 2002/07/06 16:18:13 krw Exp $
d923 1
a923 1
	get_sets_list "$_files" "$_src"
@


1.241
log
@Fix typo in get_get_files_list() that prevented sets from
being found for install/upgrade.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.240 2002/07/04 23:36:35 krw Exp $
a95 1

d140 1
a140 20
not_going_to_install() {
	cat << __EOT

Enter 'halt' at the prompt to gracefully exit OpenBSD. You can then
power cycle the machine and boot your original OS.
__EOT
}

congrats() {
	cat << __EOT

CONGRATULATIONS! Your OpenBSD ${MODE} has been successfully completed!
To boot the new system, enter halt at the command prompt. Once the
system has halted, reset the machine and boot from the disk.
__EOT

	md_congrats
}

get_diskdevs() {
d148 4
a255 5
# return available network devices
get_ifdevs() {
	/sbin/ifconfig -a | egrep -v '^([[:space:]]|(lo|enc|gre|ppp|sl|tun|bridge)[[:digit:]])' | cutword -t: 1
}

d322 1
a322 1
get_localdir() {
d325 1
a325 1
	local_sets_dir=
d350 1
a350 1
				local_sets_dir=${_mp}/${resp}
d393 1
a393 1
$_DKDEVS
d399 1
a399 1
	elif isin $resp $_DKDEVS ; then
d411 2
a412 4
	_defdsk=`echo $_DKDEVS | cutlast`
	if [ "$_defdsk" != "$_DKDEVS" ]; then
		_defdsk=
	fi
d421 1
a421 1
$_DKDEVS
d425 1
a425 1
	if isin $resp $_DKDEVS ; then
a486 2
	_IFS=`get_ifdevs`

d494 1
a494 1
		do_selection_list "$_IFS" "$_ifsdone" "Configure which interface?"
d500 1
a500 1
			if isin $_ifs $_IFS ; then
d824 1
a824 1
# _get_files appropriately.
d829 1
a829 1
	# Change +/- into add/remove
d832 1
a832 1
	"")	return
d844 1
a844 1
	for _f in $_sets; do
d847 1
a847 1
			_get_files=\`$_action $_f \$_get_files\`
d865 1
a865 1
# Set global _sets to either
d870 1
a870 1
get_sets_list () {
d873 1
a873 1
	_sets=
d878 1
a878 1
				_sets="$_sets bsd"
d881 1
a881 1
			_sets="$_sets ${_f}${VERSION}.tar.gz"
d883 1
a883 1
			_sets="$_sets ${_f}${VERSION}.tgz"
d887 1
a887 1
	if [ -z "$_sets" ]; then
d902 1
a902 1
			*.tar.gz|*.tgz)	_sets="$_sets ${_f}"
d907 1
a907 1
	if [ -z "$_sets" ]; then
d917 1
a917 1
# Set global _get_files to the list of sets requested by the user.
d920 1
a920 1
get_get_files_list () {
d925 1
a925 1
	[ "$_sets" ] || return
d927 1
a927 1
	_get_files=
d937 2
a938 2
	for _f in $_sets ; do
		# $_sets contains only .tgz and .tar.gz file names and 'bsd'.
d941 2
a942 2
			if ! isin ${_f} ${_setsdone}; then
				_get_files=`addel ${_f} ${_get_files}`
d957 1
a957 1
		do_selection_list "$_sets" "$_get_files" "File Name?"
d959 1
a959 7
		# Ignore a bare '-' or '+'
		case $resp in
		+|-)	continue
			;;
		done)	break
			;;
		esac
d965 1
a965 1
# Install the list of files in the global _get_files from the source
d968 1
a968 1
install_get_files_list () {
d977 1
a977 1
	for _f in $_get_files ; do
d990 1
a990 1
			_setsdone=`addel ${_f} ${_setsdone}`
d1025 1
a1025 1
	[ "$_proxy_host" ] || _proxy_host=none
d1056 2
a1057 1
	[ "$_ftp_getlist" ] || _ftp_getlist=y
a1124 4
		# Need default values even if we proxy ftp...
		[ "$_ftp_server_login" ] || _ftp_server_login=anonymous
		[ "$_ftp_server_password" ] || _ftp_server_password=root@@`hostname`.$FQDN

d1130 1
d1137 1
a1141 1
				_ftp_server_password=$resp
d1143 1
a1143 3
		else
			# only used by ftp_list_files()
			_ftp_server_password=root@@`hostname`.$FQDN
d1167 1
a1167 1
	get_get_files_list "$_file_list" "`eval echo \\$_${_url_type}_server_dir`"
d1170 1
a1170 1
	[ "$_get_files" ] || return
d1178 1
a1178 1
	install_get_files_list "$_url_base"
d1186 1
a1186 1
	get_localdir "$1" "$2"
d1188 1
a1188 1
	[ -d "$local_sets_dir" ] || return
d1190 1
a1190 1
	get_get_files_list "`ls -l ${local_sets_dir}`" "$local_sets_dir"
d1193 1
a1193 1
	[ "$_get_files" ] || return
d1195 1
a1195 1
	install_get_files_list "file:$local_sets_dir"
d1202 1
a1202 1
	if [ -z "$_CDDEVS" ]; then
d1213 1
a1213 1
$_CDDEVS
d1217 1
a1217 1
	_drive=`echo $_CDDEVS | cutword 1`
d1223 1
a1223 1
	*)	if isin $resp $_CDDEVS ; then
d1307 1
a1307 1
	# is $_DKDEVS.
d1318 1
a1318 1
$_DKDEVS
d1328 1
a1328 1
	*)	if isin $resp $_DKDEVS ; then
d1546 1
a1546 1
get_timezone() {
d1569 1
a1569 1
	[ "$TZ" ] || TZ=GMT
d1935 1
a1935 1
			[ "$resp" ] || resp=none
d2024 1
a2024 2
	# Get timezone info
	get_timezone
d2032 1
a2032 1
	md_installboot ${ROOTDISK}
d2040 1
a2040 1
	# Do this manually rather than through the trap so md_congrats is
d2046 1
a2046 1
	congrats
d2048 6
a2053 1
	exit 0
d2076 3
a2078 2
_DKDEVS=`get_diskdevs`
_CDDEVS=`get_cddevs`
d2080 1
a2080 2
# extra "site" set can be provided by person doing install or
# upgrade.
d2084 4
a2087 4
local_sets_dir=
_sets=
_setsdone=
_get_files=
d2092 1
a2092 3
	if [ -x /usr/bin/vi ]; then
		EDITOR=vi
	fi
d2120 5
a2124 1
*)	not_going_to_install
@


1.240
log
@More cleanup/shrinkage/clarification.

a) Abstract selection list handling into a function
   do_selection_list() rather than repeating the
   code twice.

b) Eliminate function get_selection() and put limited
   remaining functionality directly into only caller,
   get_get_file_list().

c) Remove unused parameters in glob_selection() and
   invocations of same.

d) Remove unused parameters from install_get_files_list()
   invocations.

e) Remove unnecessary local parameter '_file_list' in
   install_mounted_fs().
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.239 2002/07/04 21:51:16 krw Exp $
d946 1
a946 1
	local _filelist=$1 _src=$2
d948 1
a948 1
	get_sets_list "$_file_list" "$_src"
@


1.239
log
@Eliminate the separate display_* functions. A little more
consolidation reduces calls to these functions to either 0
(display_failure_msg()) or 1.

Just put the here documents in place of the invocation.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.238 2002/07/04 17:23:42 krw Exp $
d484 23
d508 1
a508 1
	local _ifsdone _ifs _ouranswer
d519 2
a520 12
		_ouranswer=
		for _ifs in $_IFS; do
			if isin $_ifs $_ifsdone ; then
				echo -n "	[X] "
			else
				echo -n "	[ ] "
				: ${_ouranswer:=$_ifs}
			fi
			echo $_ifs
		done
		: ${_ouranswer:=done}
		ask "\nConfigure which interface? (or 'done')" "$_ouranswer"
a847 33
# Print the selector and get a response
# The list of sets is passed in as $1, sets $resp
get_selection() {
	local _next=done _f _sets=$1

	cat << __EOT

The following sets are available. Enter a filename, 'all' to select
all the sets, or 'done'. You may de-select a set by prepending a '-'
to its name.

__EOT
	for _f in $_sets ; do
		if isin $_f $_get_files ; then
			echo -n "	[X] "
		else
			echo -n "	[ ] "
			if [ "$_next" = "done" ]; then
				_next=$_f
			fi
		fi
		echo $_f
	done

	# Get the name of the file.
	ask "File name?" "$_next"

	# Ignore a bare '-' or '+'
	case $resp in
	+|-)	resp=
	esac
}

d851 1
a851 1
	local _selection=$1 _src=$2 _sets=$3
d942 3
a944 2
# Set global _get_files to the list of sets requested by the user
# from $1.
d946 5
a950 1
	local _src=$1
d975 5
d981 2
a982 1
		get_selection "$_sets"
d984 7
a990 3
		if [ "$resp" = "done" ]; then
			break
		fi
d992 1
a992 1
		glob_selection "$resp" "$_src" "$_sets"
d1202 1
a1202 5
	get_sets_list  "$_file_list" "`eval echo \\$_${_url_type}_server_dir`"

	[ "$_sets" ] || return

	get_get_files_list "`eval echo \\$_${_url_type}_server_dir`"
d1213 1
a1213 1
	install_get_files_list "$_url_base" "`eval echo \$_${_url_type}_server_dir`"
d1219 1
a1219 1
	local _f _file_list
d1225 1
a1225 7
	_file_list=`ls -l ${local_sets_dir}`

	get_sets_list "$_file_list" "$local_sets_dir"

	[ "$_sets" ] || return

	get_get_files_list "$local_sets_dir"
d1230 1
a1230 1
	install_get_files_list "file:$local_sets_dir" "$local_sets_dir"
@


1.238
log
@Since the directory /var/run is now present during install/upgrade,
put dmesg.boot there rather than the non-normal location
/tmp/dmesg.boot.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.237 2002/07/04 16:01:21 krw Exp $
d840 7
a909 32
display_failure_msg() {
		cat << __EOT

The following files failed to extract correctly.
Choose which one(s) to retry or 'done' to exit selector.
You may de-select a file by prepending a '-' to its name.

__EOT
}

display_selection_msg() {
	cat << __EOT

The following sets are available. Enter a filename, 'all' to select
all the sets, or 'done'. You may de-select a set by prepending a '-'
to its name.

__EOT
}

display_extract_msg() {

	cat << __EOT

You will now be asked which sets to ${MODE}. Some of these sets are required
for your ${MODE} and some are optional. You will want at least the
base and bsd sets. Consult the installation notes if you are not sure
which sets are required!
__EOT

}

d969 7
a990 2
		display_selection_msg

a1210 2
	display_extract_msg

a1238 2

	display_extract_msg
@


1.237
log
@Fix set selection list logic so that when extracting more sets

a) The selection list does not display default sets already
transferred.

b) Saying 'done' does not seem to mysteriously skip the sets
erroneously shown as selected due to a).

This problem was found by miod@@.

In the process

a) Use _setsdone only to record sets that have successfully been
extracted.

b) Don't loop on fetching files if a transfer fails. Just let the user
know, and let the normal logic offer them a chance to extract the
failed sets from the same or different source.

c) Eliminate some (newly) dead variables, especially the global
_osetsdone.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.236 2002/06/29 20:01:34 krw Exp $
d161 1
a161 1
	bsort `sed -ne "${MDDISKDEVS:-/^[sw]d[0-9][0-9]* /s/ .*//p}" /tmp/dmesg.boot`
d165 1
a165 1
	bsort `sed -ne "${MDCDDEVS:-/^cd[0-9][0-9]* /s/ .*//p}" /tmp/dmesg.boot`
d2143 1
a2143 1
dmesg | sed -ne '/^OpenBSD /h;/^OpenBSD /!H;${g;p;}' > /tmp/dmesg.boot
d2145 1
a2145 1
# Scan /tmp/dmesg.boot for disks and cds
@


1.236
log
@Some cleanup/simplification:

1) Put knowledge of /tmp/fstab in munge_fstab rather
   than redirect input on calls. Check in munge_fstab
   whether /etc/fstab was successfully created, and exit
   install/upgrade with appropriate error if not. This
   error condition is therefore checked on install and upgrade.

2) Don't bother specifying value in exit statements - no one
   is checking whether it is 1, 2, or 0.

3) Put status messages inside check_fs rather than around
   invocation, and exit from check_fs if a fsck fails, rather
   than checking return value and exiting.

4) With above changes, simplify munge_fs/check_fs/mount_fs logic in
   upgrade.sh.

5) Various cosmetic cleanups.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.235 2002/06/25 00:31:59 krw Exp $
d841 1
a841 1
		if isin $_f $_setsdone ; then
d862 1
a862 1
# _get_files and _setsdone appropriately.
a885 1
			_setsdone=\`$_action $_f \$_setsdone\`
d988 1
a988 2
# from $1. Add this list to _setsdone after saving current value
# of _setsdone.
a992 1
	_osetsdone=$_setsdone
a1000 1
				_setsdone=`addel ${_f} ${_setsdone}`
d1022 2
a1023 2
# in $1, aka $2. For mounted file system installs $1==file:$2. For URL
# installs $1 == $_url_base and $2 == $1 w/o passwords, etc.
d1025 1
a1025 1
	local _f _failed_files _src=$1 _public_src=$2
d1028 2
a1029 5
	case $resp in
	y*|Y*)	;;
	*)	_setsdone=$_osetsdone
		return
		;;
d1032 16
a1047 35
	# Install/Upgrade the sets one at a time. Keep track of which
	# ones fail.
	while [ "$_get_files" ] ; do
		_failed_files=
		echo
		for _f in $_get_files ; do
			echo "Getting ${_f} ..."
			case $_f in
			*.tar.gz|*.tgz)
				ftp ${_ftp_active} -o - -V -m "${_src}/${_f}" | tar zxpf - -C /mnt
				;;
			*)
				ftp ${_ftp_active} -o "/mnt/${_f}" -V -m "${_src}/${_f}"
				;;
			esac
			if [ $? -ne 0 ]; then
				# Mark xfer as having failed,.
				_setsdone=`rmel $_f $_setsdone`
				_failed_files="${_failed_files} ${_f}"
			fi
		done

		# Offer the option of re-fetching failed files.
		_get_files=
		while [ "$_failed_files" ] ; do
			display_failure_msg

			get_selection "$_failed_files"

			if [ "$resp" = "done" ]; then
				break
			fi

			glob_selection "$resp" "$_public_src" "$_failed_files"
		done
a2156 1
_osetsdone=
@


1.235
log
@Complete yet more of the c2k2 initiated changes. In this round:

1) Centralize selection of install/upgrade media rather than ask
   separately for mounted filesystem. Eliminate separate calls
   to get_localdir in install.sh and upgrade.sh. In install.sh
   this call occurred only if a diskless system was detected, which
   millert@@ agreed was a historical relic, i.e. what exactly would
   a diskless workstation be installing to?

2) Check for the presence of any mounted filesystems at the expected
   mount point (/mnt or /mnt2) and emit an error message if none found.

3) Add a '?' option to the pathname question so you can see what
   filesystems are mounted at/below the expected mount point.

4) Rework logic in get_localdir to make flow more logical. e.g. only
   do sane_install() check after the user says to install no more sets;
   if sane_install() fails ask a slightly different question and make
   the default 'y' to install more sets.

5) Rework install_sets() to simplify logic. Don't try to tailor
   list of install media to system, just warn that some may not be
   available and emit useful error messages if the user tries a
   non-available source.

Some verbiage still needs work (amoung other things).

fgsch@@ noticed problems with installing from mounted filesystems, forcing me
to finish these changes.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.234 2002/06/15 16:03:40 fgsch Exp $
d1806 7
a1812 2
# Create a fstab to use for fsck'ing, mounting and unmounting all
# of the target filesystems relative to /mnt.
d1840 7
a1846 1
	done > /etc/fstab
a1876 2
	local _bad_devs

d1880 1
a1880 3
	# find /dev/bpf0 busy. Do this first so a user who
	# interrupts out of any fsck'ing will not be stuck
	# with an active dhclient.
d1904 1
a1904 4
		if ! mount -u -o $_opt $_dev $_mp ; then
			# error message displayed by mount
			exit 1
		fi
d1911 2
d1914 3
a1916 1
	local _dev _rest _badfsck=0 _root=$1
d1923 1
a1923 1
			_badfsck=1
d1929 3
a1931 1
	return $_badfsck
@


1.234
log
@rename install_from_mounted_fs to install_mounted_fs here as well; krw@@ ok.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.233 2002/06/11 04:25:49 krw Exp $
d344 10
a353 1
	local _mp=$1 _dir=$2
a354 1
	local_sets_dir=
d356 1
a356 1
		ask "Enter the pathname where the sets are stored (or abort)" "$_dir"
d358 3
a360 4
		abort)	return;;
		"")	continue;;
		*)	;;
		esac
d362 1
a362 1
		_dir=$_mp/$resp
d364 11
a374 7
		if [ ! -d "$_dir" ]; then
			echo "The directory '${_dir}' does not exist"
		elif list_has_sets "`ls -l ${_dir}`" $THESETS; then
			local_sets_dir=$_dir
			return
		else
			cat << __EOT
d377 1
a377 1
	"$_dir"
d381 3
a383 1
		fi
d385 1
a385 1
		ask "Re-enter pathname?" y
d1303 1
a1303 1
		echo "No CD-ROM devices were found. Aborting."
d1746 3
d1750 1
a1750 1
	local _yup=FALSE _have_nfs
d1752 5
a1756 2
	# Can we do an NFS install?
	[ -f /sbin/mount_nfs ] && _have_nfs=true
d1758 5
a1762 2
	# Ask the user which media to load the distribution from.
	cat << __EOT
d1764 3
a1766 6
You must now specify where the ${MODE} sets you want to use are. They
must either be on a local device (disk, tape, or CD-ROM), an
accessible NFS filesystem or an accessible ftp or http network
server. You will have the chance to repeat this step or to extract
sets from several places, so you do not have to try to load all the
sets in one try and can recover from some errors.
d1769 1
d1771 18
a1788 4
	if [ "$local_sets_dir" ]; then
		install_mounted_fs "$local_sets_dir"
		[ "$_setsdone" ] && _yup=TRUE
	fi
d1790 1
a1790 36
	# Go on prodding for alternate locations
	resp=
	while [ -z "$resp" ]; do
		# If _yup is not FALSE, it means that we extracted sets above.
		# If that's the case, bypass the menu the first time.
		if [ "$_yup" = "FALSE" ]; then
			echo -n	"Install from (f)tp, (h)ttp, (t)ape, (C)D-ROM"
			[ "$_have_nfs" ] && echo -n ", (N)FS"
			ask " or local (d)isk?"
			case $resp in
			d*|D*)	install_disk
				resp=d
				;;
			f*|F*)	install_url ftp
				resp=f
				;;
			h*|H*)	install_url http
				resp=h
				;;
			t*|T*)	install_tape
				resp=t
				;;
			c*|C*)	install_cdrom
				resp=c
				;;
			n*|N*)	install_nfs
				resp=n
				;;
			*)	echo "Invalid response: $resp"
				resp=
				;;
			esac
		else
			# So we'll ask next time
			_yup=FALSE
		fi
d1792 7
a1798 9
		# Perform sanity checks...
		if sane_install; then
			# Give the user the opportunity to extract more sets. They
			# don't necessarily have to come from the same media.
			ask "\nExtract more sets?" n
			case $resp in
			y*|Y*)	
				# Force loop to repeat
				resp=
d1801 2
a1802 4
		else
			# Not sane, don't exit loop.
			resp=
		fi
@


1.233
log
@Rework get_localdir() so that

1) It takes two parameters, the mount point and a default
directory.

2) It has one step escape ('abort') instead of asking user if they are
really sure an empty pathname is what they want. Empty entry with no
default value now just re-presents the prompt. More consistant with the
behaviour of other prompts.

3) Provide separate error messages for non-existant directory and a
directory with no sets.

Rework install_mounted_fs() (renamed from install_from_mounted_fs to
be consistant with install_disk, etc.) so that

1) It takes two parameters, the mount point and the default directory.

2) It calls get_localdir(), passing the parameters along.

Rework install_disk(), install_cdrom() and install_nfs() to eliminate
local queries for local dir and rely on get_local() via
install_mounted_fs() instead.

Make mount_a_disk() return 0 on success to make testing its return
value more obvious. Use this in install_disk() to make logic clearer
and eliminate the need for a return.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.232 2002/06/11 03:12:22 krw Exp $
d1752 1
a1752 1
		install_from_mounted_fs "$local_sets_dir"
@


1.232
log
@Delete an extraneous 'mkdir /mnt2' in install_nfs().

Mount NFS servers with -o ro the same as all other install
sets sources.

Check for /sbin/mount_nfs in install_nfs() rather before
the call in install_sets(). Makes install_sets() more
consistant in both code and reactions to failed attempts
to find sets.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.231 2002/06/10 23:03:32 krw Exp $
d341 2
a342 1
# $1 is relative mountpoint
d344 1
a344 1
	local _mp=$1 _dir=
d346 1
d348 17
a364 2
		ask "Enter the pathname where the sets are stored:" "$_dir"
		_dir=$resp
d366 1
a366 10
		# Allow break-out with empty response
		if [ -z "$_dir" ]; then
			ask "Are you sure you don't want to set the pathname?" n
			case $resp in
			y*|Y*)	break
				;;
			*)	continue
				;;
			esac
		fi
d368 2
a369 4
		if list_has_sets "`ls -l ${_mp}/${_dir}`" $THESETS
		then
			local_sets_dir=$_mp/$_dir
			break
a371 4
		cat << __EOT
The directory "${_mp}/${_dir}" does not exist, or does not hold any
OpenBSD ${VERSION_MAJOR}.${VERSION_MINOR} ${MODE} sets.
__EOT
d375 1
a375 2
		*)	local_sets_dir=
			break
a1092 1

d1260 6
a1265 3
# $1 - directory containing installation sets
install_from_mounted_fs() {
	local _f _get_files _file_list
d1267 1
a1267 4
	if [ ! -d "$1" ]; then
		echo "No such directory: '$1'"
		return
	fi
d1269 1
a1269 1
	_file_list=`ls -l ${1}`
d1271 1
a1271 1
	get_sets_list "$_file_list" "$1"
d1277 1
a1277 1
	get_get_files_list "$1"
d1282 1
a1282 1
	install_get_files_list "file:$1" "$1"
d1388 1
a1388 7
	# Get the directory where the file lives
	resp=
	_directory=${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}
	echo "Enter the directory relative to the mount point that contains"
	ask "the file:" "$_directory"

	install_from_mounted_fs "/mnt2/${resp}"
d1395 1
a1395 1
	# returns 0 on failure.
d1413 1
a1413 1
		return 0
d1419 1
a1419 1
			return 0
d1446 1
a1446 1
			return 0
d1496 1
a1496 1
		return 0
d1499 1
a1499 1
	return 1
d1503 3
a1505 2
	if mount_a_disk ; then
		return
a1506 7

	# Get the directory where the file lives
	echo "Enter the directory relative to the mount point that"
	ask "contains the file:" .

	install_from_mounted_fs "/mnt2/${resp}"
	umount -f /mnt2 > /dev/null 2>&1
d1547 1
a1547 8
	# Get the directory where the file lives
	resp=
	while [ -z "$resp" ]; do
		echo "Enter the directory relative to the mount point that"
		ask "contains the file:" .
	done

	install_from_mounted_fs "/mnt2/${resp}"
@


1.231
log
@Be more paranoid about option fiddling in munge_fs, in case someone
ever adds an option with a name too similar to the name of the one
being manipulated.

Only softdep at the moment but some more option fiddling coming.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.230 2002/06/10 22:38:12 krw Exp $
d1522 6
d1554 1
a1554 2
	mkdir /mnt2 > /dev/null 2>&1
	if ! mount_nfs $_nfs_tcp ${_nfs_server_ip}:${_nfs_server_path} /mnt2 ; then
d1800 2
a1801 7
			n*|N*)	if [ "$_have_nfs" ]; then
					install_nfs
					resp=n
				else
					echo "Invalid response: $resp"
					resp=
				fi
@


1.230
log
@Eliminate unused _installed_via_${_url_type} variables.

Don't bother returning a value of 1 from installed_get_files_list()
now, since it was only used to set the eliminated variables.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.229 2002/06/10 21:09:51 krw Exp $
d1851 2
a1852 1
		_opt="$(echo ${_opt} | sed 's/,softdep,/,/; s/,softdep//; s/softdep,//')"
@


1.229
log
@Move '[ "$_didnet" ] || donetconfig' lines into install_url and
install_nfs rather than before function calls.

Eliminates duplicate calls before install_url and now network will not
be configured if install_nfs is not a valid choice.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.228 2002/06/10 19:50:16 krw Exp $
a1013 3
#
# Return 0 if install was attempted, 1 if user aborted before install
# was tried.
d1021 1
a1021 1
		return 1
a1257 4
	if [ $? -eq 0 ] ; then
		# Stash the fact that we configured and downloaded via this url method
		eval _installed_via_${_url_type}=1
	fi
@


1.228
log
@Pass 'ftp' or 'http' to install_url, rather than '-ftp' or '-http' and
just assign $1 to _url_type rather than translating -ftp to ftp and
-http to http in a case statement.

Smaller. Simpler. Clearer.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.227 2002/06/09 05:53:54 todd Exp $
d1087 2
d1529 2
d1790 1
a1790 2
			f*|F*)	[ "$_didnet" ] || donetconfig
				install_url ftp
d1793 1
a1793 2
			h*|H*)	[ "$_didnet" ] || donetconfig
				install_url http
d1802 1
a1802 2
			n*|N*)	[ "$_didnet" ] || donetconfig
				if [ "$_have_nfs" ]; then
@


1.227
log
@knf
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.226 2002/06/08 21:52:02 krw Exp $
d1081 1
d1085 1
a1085 7
	local _f _file_list _url_type _url_base _url_login _url_pass _oifs

	# Parse arguments, shell style
	case $1 in
	-ftp)	_url_type=ftp ;;
	-http)	_url_type=http ;;
	esac
d1787 1
a1787 1
				install_url -ftp
d1791 1
a1791 1
				install_url -http
@


1.226
log
@Add FQDN to contents of /etc/myname during install.

Also remove a few extraneous braces.

Requested by and OK'd by two different Todds.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.225 2002/05/22 01:48:38 krw Exp $
d185 1
a185 1
#    
d492 1
a492 1
		: ${_ouranswer:=done} 
d847 1
a847 1
# Do globbing on the selection and parse +/-, sets the global 
d922 1
a922 1
# Set global _sets to either 
d1252 1
a1252 1
	get_get_files_list "`eval echo \\$_${_url_type}_server_dir`" 
d1287 1
a1287 1
	get_get_files_list "$1" 
@


1.225
log
@Fix quoting botch in earlier commit. Make sure MDDISKDEVS and
MDCDDEVS actually work with non-empty values as well as the
supplied default this time.

Problem first detected by jsyn@@.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.224 2002/05/20 16:53:57 krw Exp $
d1201 1
a1201 1
		[ "$_ftp_server_password" ] || _ftp_server_password=root@@`hostname`.${FQDN}
d1222 1
a1222 1
			_ftp_server_password=root@@`hostname`.${FQDN}
d2043 6
@


1.224
log
@Eliminate md_questions(). It was used only to control the setting of
machdep.allowaperture. Remove the setting of machdep.allowaperture
from md_installboot().

Add MDXAPERTURE variable to relevant architectures.

Add a new function set_machdep_allowaperture(). It is called *after*
install_sets() (which changes when the X Window question is asked), and
if MDXAPERTURE is present modifies sysctl.conf.

Shrinks overall size for i386, macppc, sparc64 (which used md_questions
for machdep.allowaperture) but increases size a bit for other
architectures since set_machep_allowaperture is in install.sub.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.223 2002/05/20 02:45:08 krw Exp $
d161 1
a161 1
	bsort `sed -ne ${MDDISKDEVS:-'/^[sw]d[0-9][0-9]* /s/ .*//p'} /tmp/dmesg.boot`
d165 1
a165 1
	bsort `sed -ne ${MDCDDEVS:-'/^cd[0-9][0-9]* /s/ .*//p'} /tmp/dmesg.boot`
@


1.223
log
@Move verbiage about '!' and '!foo' at prompts to welcome_banner() from
separate here document. This moves it before first questions are
asked, which makes more sense.

Replace 'especially on a PC' with 'especially on a machine', since it
is displayed on all installs/upgrades regardless of architecture.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.222 2002/05/18 17:56:03 krw Exp $
d79 6
a84 5
#	MDTERM     - 'vt220' assumed if not provided
#	MDFSTYPE   - nothing assumed if not provided
#	MDFSOPTS   - nothing assumed if not provided
#	MDDISKDEVS - '/^[sw]d[0-9][0-9]* /s/ .*//p' assumed if not provided
#	MDCDDEVS   - '/^cd[0-9][0-9]* /s/ .*//p'    assumed if not provided
d2126 13
@


1.222
log
@Eliminate md_get_diskdevs() and md_get_cddevs() by

1) Saving one boot's worth of dmesg in /tmp/dmesg.boot
2) Using sed to scan for devices and pull out names in
   new get_diskdevs() and get_cddevs() in install.sub
3) Saving any md disk/cd sed patterns in MDDISKDEVS and
   MDCDDEVS variables.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.221 2002/05/14 01:49:25 krw Exp $
d134 3
d426 1
a426 1
boot program (especially on a PC with multiple disk controllers).
a2229 6

cat << __EOT

At any prompt except password prompts you can run a shell command by
typing '!foo', or escape to a shell by typing '!'.
__EOT
@


1.221
log
@Eliminate md_native_fstype() and md_native_fsopts(). Both functions
simply echo'd a single word if present at all.

Replace with variables MDFSTYPE and MDFSOPTS if required. Rework logic
in install.sub's mount_a_disk() to always include 'ro' as an option to
the mount command. This allows even those arch's with MDFSTYPE to
usually get by without MDFSOPTS.

ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.220 2002/05/09 21:54:46 krw Exp $
a73 2
#	md_get_cddevs()		  - return available CD-ROM devices
#	md_get_diskdevs()	  - return available disk devices
d79 5
a83 3
#	MDTERM    - 'vt220' assumed if not provided
#	MDFSTYPE  - nothing assumed if not provided
#	MDFSOPTS  - nothing assumed if not provided
d156 8
d2169 6
a2174 3
# Use install.md routines to get lists of devices on system
_DKDEVS=`md_get_diskdevs`
_CDDEVS=`md_get_cddevs`
@


1.220
log
@Elminate md_welcome_banner() and md_not_going_to_install() as the
output of both was essentially identical on all architectures. Replace
with welcome_banner() and not_going_to_install() in install.sub.

Abstract common verbiage from md_congrats() into congrats() which
calls md_congrats() for any architecture specific additional verbiage.

Reword things so ${MODE} can be plausibly used in more places.

Remove extraneous #!/bin/sh in hp300 install.md.

ok deraadt@@ espie@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.219 2002/05/08 23:01:46 krw Exp $
a76 2
#	md_native_fsopts()	  - native filesystem options for disk installs
#	md_native_fstype()	  - native filesystem type for disk installs
d81 3
a83 1
#	MDTERM           - 'vt220' assumed if not provided
d1401 2
a1402 2
	local _drive _def_partition _partition_range _partition _fstype
	local _fsopts _md_fstype _md_fsopts
d1474 1
a1476 8
	_md_fstype=`md_native_fstype`
	_md_fsopts=`md_native_fsopts`
	if [ "$_md_fstype" ]; then
		echo "	$_md_fstype"
	else
		_md_fstype=_undefined_
	fi

a1481 2
			_fstype=
			_fsopts=ro
d1483 2
a1484 2
		ffs)	_fstype="-t $resp"
			_fsopts=async,ro
d1486 1
a1486 1
		$_md_fstype)
d1488 1
a1488 1
			_fsopts=$_md_fsopts
d1497 2
a1498 2
	# Mount the disk
	if ! mount $_fstype -o $_fsopts /dev/${_drive}${_partition} /mnt2; then
@


1.219
log
@Abstract out common md_set_term() code into set_term() in install.sub,
calling md_set_term() from set_term() to do machine dependent stuff.
Currently only i386 does anything - keyboard mappings.

Add MDTERM variable to allow install.md to set proper default terminal
type. Default to vt220.

Eliminate md_get_partition_range() as useless since every architecture
returned '[a-p]'.

Make default term for all mvme* architectures vt100 as requested by miod@@.

ok deraadt@@ millert@@ miod@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.218 2002/05/04 22:21:21 krw Exp $
a78 1
#	md_not_going_to_install() - display friendly message
a80 1
#	md_welcome_banner()	  - display friendly message
d95 61
d2149 1
a2149 1
	md_congrats
d2199 1
a2199 2
echo
md_welcome_banner
d2203 1
d2211 1
a2211 1
	echo -n "P"
d2218 1
a2218 1
*)	md_not_going_to_install
@


1.218
log
@Clean up the logic in install_url():

a) Eliminate extraneous cat invocations that are piped to
   grep by simply calling grep with the file name.
b) Eliminate the only use of isnumeric() by using a ksh'ism
   left exposed in sh: '+([0-9])'. Eliminate isnumeric().
c) Test for a http/ftp list index of '0' and treat as an out
   of range error rather than an IP address.
d) Reorganize to make smaller and more clear.

Add documentation to sh(1) for ksh patterns that are available.

ok millert@@, miod@@
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.217 2002/04/30 23:26:27 krw Exp $
d70 2
a71 1
# include machine-dependent functions
d73 6
a78 6
#	md_get_diskdevs()	- return available disk devices
#	md_get_cddevs()		- return available CD-ROM devices
#	md_get_partition_range() - return range of valid partition letters
#	md_installboot()	- install boot-blocks on disk
#	md_prep_disklabel()	- label the root disk
#	md_welcome_banner()	- display friendly message
d80 7
a86 3
#	md_congrats()		- display friendly message
#	md_native_fstype()	- native filesystem type for disk installs
#	md_native_fsopts()	- native filesystem options for disk installs
d88 8
a95 2
# include machine dependent subroutines
. install.md
d1225 1
a1225 1
	local _drive _range _part _fstype _directory _n
a1281 1
		_range=`md_get_partition_range`
d1286 1
a1286 1
			$_range)
d2165 1
a2165 1
md_set_term
@


1.217
log
@Clean up configure_all_interfaces() a bit.

Always make the default answer the first unconfigured interface, and
when there are no unconfigured interfaces make the default answer
'done'.

As a result _reprompt would always be set to 1, so eliminate it and
the if statement testing it.
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.216 2002/04/30 04:04:47 deraadt Exp $
a189 13
isnumeric() {
	local _a=$1

	while [ ${#_a} != 0 ]; do
		case $_a in
		[0-9]*)	;;
		*)	echo 0; return;;
		esac
		_a=${_a#?}
	done
	echo 1; return
}

d1059 1
a1059 1
		cat /tmp/ftplist | grep "^${_url_type}:" | cat -n | less -XE
d1063 1
a1063 1
	# Get server IP address
d1066 1
a1066 3
		if [ -f /tmp/ftplist ]; then
			eval ask \"Server IP address, hostname, or list#?\" \"\$_${_url_type}_server_ip\"
		else
d1068 1
d1070 6
a1075 2
		if [ "$resp" = "?" -a -f /tmp/ftplist ]; then
			cat /tmp/ftplist | grep "^${_url_type}:" | cat -n | less -XE
d1077 2
a1078 5
		elif [ -n "$resp" \
			-a `isnumeric $resp` -eq 1 \
			-a ${resp:-0} -ge 1 \
			-a -f /tmp/ftplist ]
			then
d1080 2
a1081 1
			if [ $maxlines -lt $resp ]; then
d1083 10
a1092 2
				resp=
				continue
d1094 2
a1095 9
			tline=`grep "^${_url_type}:" /tmp/ftplist | sed -ne "${resp}p"`
			url=`echo $tline | sed -e "s/^${_url_type}:\/\///" |
				cutword -t' ' 1 | cutword -t' ' 1`
			host=`echo $url | cutword -t/ 1`
			path=`echo $url | sed -e "s/^${host}\///"`
			path=${path}/${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}
			eval _${_url_type}_server_ip=$host
			eval _${_url_type}_server_dir=$path
			# do it again, just to double check
d1097 4
a1100 4
			echo "Using	$tline"
		else
			eval _${_url_type}_server_ip=$resp
		fi
d1102 2
@


1.216
log
@this is not run by hand, no need for #!/bin/sh; krw ok
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.215 2002/04/29 01:49:49 krw Exp $
d402 1
a402 1
	local _ifsdone= _ifs _ouranswer= _reprompt=1
d406 2
a407 4
	resp=
	while [ "$resp" != "done" ]; do
		if [ $_reprompt = 1 ]; then
			cat << __EOT
d413 6
a418 2

			for _ifs in $_IFS; do
d420 5
a424 10
				if isin $_ifs $_ifsdone ; then
					echo -n "	[X] "
				else
					echo -n "	[ ] "
				fi
				echo $_ifs
			done
			echo
		fi
		ask "Configure which interface? (or 'done')" "$_ouranswer"
d426 1
a426 2
		"done")	;;
		"")	_reprompt=0
a428 1
			_ouranswer=done
a431 2
				else
				_ouranswer=
a435 1
			_reprompt=1
a437 1

@


1.215
log
@Expose a few more comments to stripping: must be on separate line, and
must *not* start with consecutive '#'s.
@
text
@d1 1
a1 2
#!/bin/sh
#	$OpenBSD: install.sub,v 1.214 2002/04/29 01:38:06 krw Exp $
@


1.214
log
@Eliminate basename(). Just use parameter expansion syntax to remove
everything up to and including the last '/'.  Also removes a now
unnecessary variable from install_tape().

Which brings up the question 'Does anyone use tape installs?'.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.213 2002/04/29 00:59:35 krw Exp $
d1776 2
a1777 1
			y*|Y*)	# Force loop to repeat
d2104 1
a2104 1
########################################################################
d2112 1
a2112 1
########################################################################
@


1.213
log
@Rely on [] evaluating empty string as false, non-empty string as true
to eliminate a lot of -z and -n tests.

Thus,

'[ -z "$x" ] && cmd' -> '[ "$x" ] || cmd'
'if [ -z "$x" ]; then; y; fi' -> '[ "$x" ] || y'.
'[ -n "$x" ]' -> '[ "$x" ]'

Use variable default value syntax in a couple of places rather than if
statements. e.g. ': ${_ouranswer:=$_ifs}'.

Suggestions from millert@@, aaron@@, espie@@, miod@@ at various times.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.212 2002/04/28 20:41:15 krw Exp $
a190 12
basename () {
	local _oifs

	[ "$1" ] || return
	_oifs=$IFS
	IFS=/
	set -- $1
	IFS=$_oifs
	while [ "$#" -gt 10 ]; do shift 10; done
	eval echo \$$#
}

a1529 1
	_tape=`basename $TAPE`
d1532 1
a1532 1
		ask "Name of tape device?" "$_tape"
d1534 1
a1534 2
	_tape=`basename $resp`
	TAPE=/dev/${_tape}
@


1.212
log
@Remove superfluous '{}' in variable references that are all alone in a
string. i.e. "${a}" -> "$a". Save the {} form for strings where
variables are mixed with text.

Remove superfluous X's. e.g. "X$resp" = "Xdone" -> "$resp" = "done".

Change last few '[ "$v" = "" ]' or equivalents to '[ -z "$v" ]'.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.211 2002/04/28 14:44:01 krw Exp $
d178 1
a178 1
		[ -z "$1" ] && break
d194 1
a194 1
	[ -z "$1" ] && return
d430 1
a430 3
				if [ -z "$_ouranswer" ]; then
					_ouranswer=$_ifs
				fi
d513 1
a513 3
		if [ -z "$_if_mask" ]; then
			_if_mask=255.255.255.0
		fi
d520 1
a520 1
	if [ -n "`ifconfig -m ${_if_name} | sed -n '/media/p'`" ]; then
d538 1
a538 1
		if [ -n "$resp" ]; then
d983 1
a983 1
	while [ -n "$_get_files" ] ; do
d1005 1
a1005 1
		while [ -n "$_failed_files" ] ; do
d1053 2
a1054 3
	if [ -z "$_proxy_host" ]; then
		_proxy_host=none
	fi
d1084 1
a1084 1
	[ -z "$_ftp_getlist" ] && _ftp_getlist=y
d1149 2
a1150 6
		if [ -z "$_ftp_server_login" ] ; then
			_ftp_server_login=anonymous
		fi
		if [ -z "$_ftp_server_password" ] ; then
			_ftp_server_password=root@@`hostname`.${FQDN}
		fi
d1197 1
a1197 1
	[ -z "$_sets" ] && return
d1204 1
a1204 1
	[ -z "$_get_files" ] && return
d1232 1
a1232 1
	[ -z "$_sets" ] && return
d1239 1
a1239 1
	[ -z "$_get_files" ] && return
d1440 1
a1440 1
	if [ -n "$_md_fstype" ]; then
d1639 1
a1639 1
	[ -z "$TZ" ] && TZ=GMT
d1734 1
a1734 1
	if [ -n "$local_sets_dir" ]; then
d1736 1
a1736 1
		[ -n "$_setsdone" ] && _yup=TRUE
d1746 1
a1746 1
			[ -n "$_have_nfs" ] && echo -n ", (N)FS"
d1752 1
a1752 1
			f*|F*)	[ -n "$_didnet" ] || donetconfig
d1756 1
a1756 1
			h*|H*)	[ -n "$_didnet" ] || donetconfig
d1766 2
a1767 2
			n*|N*)	[ -n "$_didnet" ] || donetconfig
				if [ -n "$_have_nfs" ]; then
d2013 1
a2013 3
			if [ -z "$resp" ]; then
				resp=none
			fi
@


1.211
log
@Change getresp() into ask().

ask() takes 2 parameters. The first one is the question to
ask the user, and the 2nd is the default answer.

Shrinks and makes the code clearer.

From espie@@ with some tweaking, ok deraadt@@.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.209 2002/04/26 02:43:14 krw Exp $
d348 1
a348 1
	if [ "X${resp}" = "Xdone" ]; then
d363 1
a363 1
	if [ "${_defdsk}" != "${_DKDEVS}" ]; then
d420 1
a420 1
	while [ "X${resp}" != X"done" ]; do
d498 1
a498 1
		if [ ! -x /sbin/dhclient -a "X$resp" == "Xdhcp" ]; then
d610 1
a610 1
			addifconfig ${_if_name} ${_if_symname} ${_if_ip} ${_if_mask} "${_if_extra}"
d734 1
a734 1
					if [ "$bcaddr" -a "X$bcaddr" != "XNONE" ]; then
d788 1
a788 1
			if [ "X$_next" = "Xdone" ]; then
d890 1
a890 1
		if [ "X${_f}" = "Xkernel" ]; then
d960 1
a960 1
		if [ "X${resp}" = "Xdone" ]; then
d987 1
a987 1
	while [ -n "${_get_files}" ] ; do
d1009 1
a1009 1
		while [ -n "${_failed_files}" ] ; do
d1014 1
a1014 1
			if [ "X${resp}" = X"done" ]; then
d1061 1
a1061 1
	if [ "X${resp}" = X"none" ]; then
d1068 1
a1068 1
	if [ "${_url_type}" = "ftp" -a -z "$ftp_proxy" ]; then
d1111 1
a1111 1
		if [ "X$resp" = "X?" -a -f /tmp/ftplist ]; then
d1142 1
a1142 1
	if [ "${_url_type}" = "ftp" -a -z "$_ftp_server_dir" ] ; then
d1152 1
a1152 1
	if [ "${_url_type}" = "ftp" ]; then
d1172 1
a1172 1
		if [ "${_ftp_server_login}" != "anonymous" ]; then
d1186 3
a1188 3
	if [ "${_url_type}" = "ftp" -a "${_ftp_server_login}" != "anonymous" ]; then
		_url_login=`encode_for_url "${_ftp_server_login}"`
		_url_pass=`encode_for_url "${_ftp_server_password}"`
d1196 1
a1196 1
	if [ "${_url_type}" = "ftp" -a -z "$ftp_proxy" ] ; then
d1590 1
a1590 1
	if [ "X${_nskip}" != X"0" ]; then
d1744 1
a1744 1
		install_from_mounted_fs "${local_sets_dir}"
d1753 1
a1753 1
		if [ X"$_yup" = X"FALSE" ]; then
d1849 1
a1849 1
		if [ "X{$_mp}" != X"/mnt" ]; then
d2028 1
a2028 1
	if [ "X${resp}" != X"none" ]; then
d2048 1
a2048 1
	if [ "X${resp}" != X"none" ]; then
d2176 1
a2176 1
if [ -f /etc/fstab -a "${MODE}" = "install" ]; then
@


1.210
log
@Fix typo ('remel' -> 'rmel') in glob_selection.
@
text
@d89 1
a89 1
#    *Don't* allow the '!' options that getresp does.
d100 13
a112 5
# Ask for user input, saving the input (or the default value
# given in $1 if the input is empty) in $resp. Allow the user
# to escape to shells ('!') or execute commands ('!foo')
# before entering the input.
getresp() {
d122 1
a122 1
		*)	: ${resp:=$1}
d290 1
a290 2
		echo -n "Enter the pathname where the sets are stored: [$_dir] "
		getresp "$_dir"
d295 1
a295 2
			echo -n "Are you sure you don't want to set the pathname? [n] "
			getresp n
d314 1
a314 2
		echo -n "Re-enter pathname? [y] "
		getresp y
d347 1
a347 2
	echo -n	"Which one? [done] "
	getresp done
d377 1
a377 2
	echo -n "Which disk is the root disk? [${_defdsk}] "
	getresp "$_defdsk"
d442 1
a442 2
		echo -n	"Configure which interface? (or 'done') [$_ouranswer] "
		getresp "$_ouranswer"
d497 1
a497 2
		echo -n "IP address${_dhcp_prompt}? [$_if_ip] "
		getresp "$_if_ip"
d508 1
a508 2
		echo -n "Symbolic (host) name? [$_hostname] "
		getresp "$_hostname"
d519 1
a519 2
			echo -n "Netmask? [$_if_mask] "
			getresp "$_if_mask"
d541 1
a541 2
		echo -n "Media directives? [$_if_extra] "
		getresp "$_if_extra"
d796 1
a796 2
	echo -n "File name? [$_next] "
	getresp "$_next"
d909 1
a909 2
		echo -n "Search for other *.tar.gz and *.tgz files? [y] "
		getresp y
d922 1
a922 3
		eval echo "There are no *.tar.gz or *.tgz files in ${_src}."
		echo -n "See a directory listing? [y] "
		getresp y
d977 1
a977 2
	echo -n "Ready to ${MODE} sets? [y] "
	getresp y
d1060 1
a1060 2
	echo -n "HTTP/FTP proxy URL? (e.g. 'http://proxy:8080', or 'none') [${_proxy_host}] "
	getresp "$_proxy_host"
d1081 1
a1081 2
		echo -n "Do you want to use active ftp? [${resp}] "
		getresp "$resp"
d1090 1
a1090 2
	echo -n "Do you want a list of potential ${_url_type} servers? [${_ftp_getlist}] "
	getresp "$_ftp_getlist"
d1107 1
a1107 1
			eval echo -n "Server IP address, hostname, or list#? [\$_${_url_type}_server_ip]\ "
d1109 1
a1109 1
			eval echo -n "Server IP address, or hostname? [\$_${_url_type}_server_ip]\ "
a1110 1
		eval getresp "\$_${_url_type}_server_ip"
d1148 1
a1148 2
		eval echo -n "Server directory? [\$_${_url_type}_server_dir]\ "
		eval getresp "\$_${_url_type}_server_dir"
d1167 1
a1167 2
			echo -n "Login? [${_ftp_server_login}] "
			getresp "$_ftp_server_login"
d1273 1
a1273 2
	echo -n	"Which CD-ROM contains the installation media? [$_drive] "
	getresp "$_drive"
d1314 1
a1314 2
			echo -n 'CD-ROM partition to mount? (normally "c") [c] '
			getresp c
d1336 1
a1336 2
			echo -n "Which filesystem type? [cd9660] "
			getresp cd9660
d1361 1
a1361 3
	echo -n "the file: [${_directory}] "

	getresp "$_directory"
d1384 1
a1384 2
	echo -n	"Which is the disk with the installation sets? [abort] "
	getresp abort
d1427 1
a1427 2
		echo -n "Partition? [$_def_partition] "
		getresp "$_def_partition"
d1457 1
a1457 2
		echo -n "Which filesystem type? [default] "
		getresp default
d1493 1
a1493 2
	echo -n "contains the file: [.] "
	getresp "."
d1503 1
a1503 2
		echo -n "Server IP address or hostname? [${_nfs_server_ip}] "
		getresp "$_nfs_server_ip"
d1510 1
a1510 2
		echo -n "Filesystem on server to mount? [${_nfs_server_path}] "
		getresp "$_nfs_server_path"
d1515 1
a1515 2
	echo -n "Use TCP transport? (only works with capable NFS server) [n] "
	getresp n
d1534 1
a1534 2
		echo -n "contains the file: [.] "
		getresp
d1554 1
a1554 2
		echo -n "Name of tape device? [${_tape}]"
		getresp "$_tape"
d1577 1
a1577 2
		echo -n "File number? "
		getresp
d1609 1
a1609 2
		echo -n "Which way is it? [1] "
		getresp 1
d1653 1
a1653 2
		echo -n	"What timezone are you in? ('?' for list) [$TZ] "
		getresp "$TZ"
d1664 1
a1664 2
			echo -n "'${_zonepath#$_zoneroot}' ('?' for list): "
			getresp
d1756 1
a1756 2
			echo -n " or local (d)isk? "
			getresp
d1797 1
a1797 2
			echo -n	"\nExtract more sets? [n] "
			getresp n
d1948 1
a1948 2
		echo -n "Enter DNS domain name (e.g. 'bar.com'): [$FQDN] "
		getresp "$FQDN"
d1963 1
a1963 2
		echo -n "Enter system hostname (short form, e.g. 'foo'): [$_nam] "
		getresp "$_nam"
d2027 1
a2027 2
	echo -n "Enter IP address of default route: [$resp] "
	getresp "$resp"
d2047 1
a2047 2
	echo -n	"Enter IP address of primary nameserver: [$resp] "
	getresp "$resp"
d2055 1
a2055 2
		echo -n "Would you like to use the nameserver now? [y] "
		getresp y
d2071 1
a2071 2
		echo -n "Would you like to edit the host table with ${EDITOR}? [n] "
		getresp n
d2085 1
a2085 2
	echo -n "Escape to shell? [n] "
	getresp n
d2188 1
a2188 2
echo -n "roceed with ${MODE}? [n] "
getresp n
@


1.209
log
@Rework glob_selection() to eliminate 'Major hack' and a 'Eww' by
getting eval to work correctly. Some other logic cleanups in
glob_selection.

Eliminate 'dead' code trying to use dns to resolve
ftp.openbsd.org. Not only was the code dead, $_resolver_enabled
having been eliminated a while ago, but unnecessary as Theo has
promised the IP address will not change.

Spell 'occurrences' correctly.

From espie@@ with slight modifications. ok espie@@ millert@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.205 2002/04/13 21:03:58 deraadt Exp $
d821 1
a821 1
		_action=remel
@


1.208
log
@Change 'while $1; shift' loops to 'for _b;' loops.

Move more 'if [] then; x; fi' to '[] && x' or
'[] || x' idioms.

Remove code supporting an optional IFS parameter in cutlast(),
as it was never used. Also redo logic a bit in cutlast() to
use eval to better effect.

Improve logic a bit in bsort.

From espie@@ with slight modifications. ok espie@@ millert@@
@
text
@d147 1
a147 1
# remove all occurances of first argument from list formed by
d811 1
a811 5
	local _action _matched _tfile _f

	if [ -z "$_selection" ]; then
		return
	fi
d814 1
a814 1
	_action=add
d816 2
d821 1
a821 1
		_action=remove
d825 2
a826 1
	# Major hack to allow the user to select globbing patterns
a827 26
	if [ X"$_selection" = X"all" ]; then
		_selection=*
	fi
	# This is safe in single user mode.
	_tfile=/tmp/install_case.$$
	cat >$_tfile << __EOT
	case \$_f in
	$_selection)
		# Add/remove file to extraction list
		if [ "\$_action" = "add" ]; then
			_get_files=\`addel \${_f} \${_get_files}\`
			_setsdone=\`addel \${_f} \${_setsdone}\`
		elif [ "\$_action" = "remove" ]; then
			_get_files=\`rmel \${_f} \${_get_files}\`
			_setsdone=\`rmel \${_f} \${_setsdone}\`
		else
			echo "Unknown action: \$_action"
		fi
		_matched=\$(( \$_matched + 1 ))
		;;
	esac
__EOT
	set +o noglob

	# Eww.
	_matched=0
d829 7
a835 1
		. $_tfile
d837 1
a837 1
	rm -f $_tfile
d839 1
a839 1
	if [ $_matched -eq 0 ]; then
d1106 3
a1108 5
		ftphost=129.128.5.191
		if [ "X${_resolver_enabled}" = X"TRUE" ]; then
			ftphost=ftp.openbsd.org
		fi
		ftp ${_ftp_active} -V -a -o /tmp/ftplist ftp://${ftphost}/pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/ftplist > /dev/null
@


1.207
log
@Improve use of sed in various places, eliminating unnecessary
calls to grep and file redirections.

Eliminate function firstchar(). Rework of partition gathering
code removes the only use.

Remove the usual extraneous 'X's and {}'s in the code being
worked on.

From espie@@ with slight modifications. ok espie@@ millert@@
@
text
@d124 1
a124 1
	local	_a=$1
d127 2
a128 3
	while [ $# != 0 ]; do
		if [ "$_a" = "$1" ]; then return 0; fi
		shift
d136 1
a136 1
	local	_a=$1 _seen=
d139 3
a141 6
	while [ $# != 0 ]; do
		echo "$1"
		if [ "$_a" = "$1" ]; then
			_seen=yes
		fi
		shift
d143 2
a144 3
	if [ -z "$_seen" ]; then
		echo "$_a"
	fi
d147 2
a148 1
# remove first argument from list formed by the remaining arguments
d150 1
a150 1
	local	_a=$1
d153 2
a154 5
	while [ $# != 0 ]; do
		if [ "$_a" != "$1" ]; then
			echo "$1"
		fi
		shift
a177 7
	local _a _oifs=$IFS

	# optional field separator
	case $1 in
	-t?*)	IFS=${1#-t}; shift;;
	esac

d179 2
a180 4
	IFS=$_oifs
	[ -z "$1" ] && return
	while [ "$#" -gt 10 ]; do shift 10; done
	eval echo \$$#
d214 1
a214 1
	local _l _a=$1
d216 4
a219 7
	if [ $# == 0 ]; then
		return
	fi

	if [ $# == 1 ]; then
		echo $1; return
	fi
d222 1
a222 2
	while [ $# != 0 ]; do
		local _b=$1
a229 1
		shift
d249 1
a249 2
	for _f in $*
	do
@


1.206
log
@Split out a new function askpass() and as a result
greatly simplify both getresp() and the code around
obtaining passwords. Shrinks, simplifies and
makes the code clearer.

From espie@@.

ok deraadt@@ and espie@@.
@
text
@a198 10
# return first character of argument
firstchar () {
	local _a=$1

	while [ ${#_a} != 1 ]; do
		_a=${_a%?}
	done
	echo $_a
}

d411 1
a411 1
	sed "/ $2\$/d" < /tmp/hosts > /tmp/hosts.new
d1175 1
a1175 2
			maxlines=`grep "^${_url_type}:" /tmp/ftplist | cat -n |
				sed -n -e '$p' | cutword 1`
d1181 1
a1181 1
			tline=`grep "^${_url_type}:" /tmp/ftplist | sed -n -e "${resp}p"`
d2023 1
a2023 1
		sed "s/\\(.*\\)[[:space:]]\\(.*\\)\$/\\1 \\2.$FQDN \\2/" < $2 > $2.new
d2093 5
a2097 3
	resp=`route -n show |
		grep '^default' |
		sed -e 's/^default *//' -e 's/ .*//'`
d2119 1
a2119 2
		for n in `grep '^nameserver ' /tmp/resolv.conf | \
			sed -e 's/^nameserver //'`
@


1.205
log
@allow todd to do very weird things at the timezone prompt; fix from krw
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.204 2002/04/13 21:03:31 deraadt Exp $
d87 17
a104 8
	local _no_shell=0

	# -n option means don't try to run shell commands
	if [ "$1" = "-n" ]; then
		_no_shell=1
		shift
	fi

d106 1
a106 2
	valid=
	while [ -z "$valid" ]; do
d108 10
a117 16
		if [ ${_no_shell} -eq 1 ]; then
			[ -z "$resp" ] && resp=$1
		else
			case $resp in
			"")	resp=$1
				;;
			!)	echo "Type 'exit' to return to install."
				sh
				continue
				;;
			!*)	eval ${resp#?}
				continue
				;;
			esac
		fi
		valid=true
d1244 1
a1244 5
				echo -n "Password (will not echo): "
				stty -echo
				getresp -n "$_ftp_server_password"
				stty echo
				echo
@


1.204
log
@only fsck root once in upgrade; from krw
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.203 2002/04/13 00:46:46 deraadt Exp $
d1750 1
a1750 1
		while [ -d ${_zonepath} ]; do
d1761 1
a1761 1
		if [ -f ${_zonepath} ]; then
@


1.203
log
@do not check filesystems; krw ok
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.202 2002/04/10 19:29:15 deraadt Exp $
d1998 3
a2000 1
# Preen all filesystems in /etc/fstab, showing individual results.
d2002 1
a2002 1
	local _dev _rest _badfsck=0
d2005 1
@


1.202
log
@If disk device nodes are missing, and MAKEDEV can be found on the media,
use it to make 'em.  Now you can install with as many disks as you want.
cleanup by espie, tests by jason
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.201 2002/04/09 01:59:41 krw Exp $
a1976 1
		check_fs
@


1.201
log
@Move introductory blocks of comments to above their functions.

Eliminate some blank lines.

Only comments and blank lines affected, no code.

Suggested by deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.200 2002/04/09 01:01:19 krw Exp $
d349 14
d378 1
d407 1
@


1.200
log
@More reorganizations, fixes and shrinkage.

a) Make [ -z "$var" ] standard idiom, replacing
   many variants on [ X"$var" = X"" ].

b) Factor out three large chunks of repeated code
   for finding sets, getting user to select sets
   and then installing the sets. This creates
   get_sets_list(), get_get_files_list() and
   install_get_files_list().

c) Eliminate unneeded dir_has_sets() function.

d) Indent last large functions that were not
   properly indented.

e) Replace most if not all 'test' invocations
   with [], replacing a few if statements along
   the way.

f) Use ${MODE} a lot more to make messages appear
   more relevant to process.

g) Fix erroneous display of $local_sets_dir so
   the error for a non-existant dir actually displays
   the user input, not an empty string.

h) Eliminate the 'list' option in selecting sets. It
   was not possible to actually select anything except
   what was already displayed, so bring verbiage and
   options into line with code.

i) Replace a number of '\"' and "\'" with just plain
   's or "s as appropriate.

j) Replace ".  " with ". ".

k) Use some more "OpenBSD {$VERSION_MAJOR}.${VERSION_MINOR}"
   to make more messages correct and current.

l) Various typos fixed.

Net shrinkage approximately 2K.

ok millert@@ deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.199 2002/04/05 23:44:54 krw Exp $
d69 2
a86 2
# OpenBSD install/upgrade script common subroutines and initialization code

d120 1
a121 1
	# test the first argument against the remaining ones, return success on a match
d132 2
a134 2
	# add first argument to list formed by the remaining arguments
	# adds to the tail if the element does not already exist
d150 1
a151 1
	# remove first argument from list formed by the remaining arguments
d163 1
a164 1
	# read lines on stdin, return Nth element of each line, like cut(1)
d181 1
a182 1
	# read a line of data, return last element. Equiv. of awk '{print $NF}'.
d197 1
a198 1
	# return first character of argument
d232 1
a233 1
	# return available network devices
d273 1
a274 1
	# return true when the list $1 contains a set also in one of $2 ... $n
d296 2
a298 3
	# log in via ftp to host $1 as user $2 with password $3
	# and return a list of all files in the directory $4 on stdout

d307 1
a308 1
	# $1 is relative mountpoint
d398 4
a402 6
	# $1 - IP address
	# $2 - symbolic name

	# Create an entry in the hosts file. If an entry with the
	# same symbolic name already exists, delete it.

d409 6
a415 7
	# $1 - interface name
	# $2 - interface symbolic name
	# $3 - interface IP address
	# $4 - interface netmask
	# $5 - (optional) interface media directives

	# Create a hostname.* file for the interface.
a921 1

a974 1

d1065 9
a1074 10
	# Encode $1 as specified for usercodes and passwords in RFC 1738
	# section 3.1, and now supported by our in-tree ftp:
	#
	#    ':' -> '%3a'
	#    '@@' -> '%40'
	#    '/' -> '%2f'
	#
	# *NOTE* quotes around $1 are required to preserve trailing or
	# embeddded blanks in usercodes and passwords!

d1078 4
a1082 5
	# Get several parameters from the user, and xfer
	# files from the server.
	# Note:	_ftp_server_ip, _ftp_server_dir, _ftp_server_login,
	#	_ftp_server_password, and _ftp_active must be global.

d1283 1
a1284 1
	# $1 - directory containing installation sets
d1885 2
a1887 3
	# Create a fstab to use for fsck'ing, mounting and unmounting all
	# of the target filesystems relative to /mnt.

d1916 2
a1918 2
	# Must mount filesystems manually, one at a time, so we can make
	# sure the mount points exist.
d1942 1
a1943 1
	# Script is exiting. Clean up as much as possible.
d1969 3
a1972 3
	# Remount all filesystems in /etc/fstab with the options from
	# /etc/fstab, i.e. without any options such as async which
	# may have been used in the first mount.
d1983 1
a1984 1
	# Preen all filesystems in /etc/fstab, showing individual results.
d2000 4
a2004 6
	# $1 = resolv.conf file to search for FQDN
	# $2 = hosts file to add FQDN information to

	# Find LAST instance of DOMAIN or SEARCH and extract first domain name
	# on that line as FQDN. Then ask user, just to be sure.

@


1.199
log
@Tune get_selection() so that

1) If there are no unselected sets then the default
   becomes 'done'.

2) A bare '-' or '+' is ignored, since it causes
   problems for the functions that call get_selection().
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.198 2002/04/05 02:51:59 krw Exp $
d98 1
a98 1
	while [ "X$valid" = "X" ]; do
d101 1
a101 1
			test -z "$resp" && resp=$1
d121 1
a121 1
# test the first argument against the remaining ones, return success on a match
d133 2
a134 2
# add first argument to list formed by the remaining arguments
# adds to the tail if the element does not already exist
d145 1
a145 1
	if [ "X$_seen" = "X" ]; then
d151 1
a151 1
# remove first argument from list formed by the remaining arguments
d164 1
a164 1
# read lines on stdin, return Nth element of each line, like cut(1)
d175 1
a175 1
		test -z "$1" && break
d182 1
a182 1
# read a line of data, return last element. Equiv. of awk '{print $NF}'.
d192 1
a192 1
	if [ "$1" = "" ]; then return; fi
d198 1
a198 1
# return first character of argument
d210 1
a210 1
	if [ "$1" = "" ]; then return; fi
d267 1
a267 1
	if [[ "X$_l" != "X" ]] ; then
d273 3
a275 3
dir_has_sets() {
	# return true when the directory $1 contains a set for $2...$n
	local _dir=$1 _file
d278 1
a278 1
	for _file in $*
d280 1
a280 1
		if [ -f "$_dir/${_file}${VERSION}.tar.gz" ]; then
d284 1
a284 1
		if [ -f "$_dir/${_file}${VERSION}.tgz" ]; then
d288 1
a288 1
		if [ $_file = "kernel" -a -f "$_dir/bsd" ]; then
a291 6
	return 1
}

list_has_sets() {
	# return true when the list $1 contains a set, given dir $2 for $3...$n
	local _list=$1 _file
a292 15
	shift
	for _file in $*
	do
		if isin ${_file}${VERSION}.tar.gz $_list; then
			return 0
		fi
		# Try for stupid msdos convention
		if isin ${_file}${VERSION}.tgz $_list; then
			return 0
		fi
		# Special check for kernel
		if test $_file = "kernel" && isin bsd $_list; then
			return 0
		fi
	done
d329 1
a329 1
		if dir_has_sets "$_mp/$_dir" $THESETS
d333 5
a337 4
		else
			cat << __EOT
The directory \"$local_sets_dir\" does not exist, or does not hold any of the
upgrade sets.
d339 8
a346 9
			echo -n "Re-enter pathname? [y] "
			getresp y
			case $resp in
			y*|Y*)	;;
			*)	local_sets_dir=
				break
				;;
			esac
		fi
d353 2
a354 2
Now you can select another disk to initialize.  (Do not re-select a disk
you have already entered information for).  Available disks are:
d403 1
a403 1
	# Create an entry in the hosts file.  If an entry with the
d445 1
a445 1
				if [ "X${_ouranswer}" = "X" ]; then
d472 1
a472 1
				echo "Invalid response: \"$resp\" is not in list"
d512 1
a512 1
	while [ "X${resp}" = X"" ]; do
d524 1
a524 1
	while [ "X${resp}" = X"" ]; do
d533 1
a533 1
		if [ "X${_if_mask}" = X"" ]; then
d536 1
a536 1
		while [ "X${resp}" = X"" ]; do
d546 1
a546 1
media directives.  The default media is:
d558 1
a558 1
media, copy that line from above (e.g. \"media 100baseTX\")
d562 1
a562 1
		if [ "X${resp}" != X"" ]; then
d567 1
a567 1
	# Configure the interface.  If it
d572 1
a572 1
cat > /etc/dhclient.conf << __EOT
d686 1
a686 1
		# Interface names must be alphanumeric only.  We check to avoid
d692 1
a692 1
		if [ "$?" != "0" ]; then
d825 2
a826 2
# Do globbing on the selection and parse +/-, sets _get_files and _setsdone
# (which must exist in the local namespace) as side effects.
d828 1
a828 1
	local _selection=$1 _parent_dir=$2 _sets=$3
d831 1
a831 1
	if [ "X${_selection}" = X"" ]; then
d880 5
a884 2
File $_parent_dir/$_selection does not exist.  Check to make
sure you entered the information properly or enter 'list' for a file list.
d902 3
a904 3
The following sets are available. Enter a filename, 'list' for a list of
all files, 'all' to select all the sets, or 'done'. You may de-select
a set by prepending a '-' to its name.
d913 34
a946 2
You will now be asked for files to extract. In addition to the files
listed, you may select any .tgz or .tar.gz archive located at
d948 1
a948 1
    $1
d950 1
a950 3
Some of these sets are required for your ${MODE} and some are
optional. You will want at least the base and bsd sets. Consult the
installation notes if you are not sure which sets are required!
d952 109
d1062 7
d1086 12
a1097 13
# Get several parameters from the user, and xfer
# files from the server.
# Note:	_ftp_server_ip, _ftp_server_dir, _ftp_server_login,
#	_ftp_server_password, and _ftp_active must be global.

local _sets _kernel _f _file_list _get_files _failed_files _osetsdone
local _url_type _url_base _url_login _url_pass _oifs

# Parse arguments, shell style
case $1 in
-ftp)	_url_type=ftp ;;
-http)	_url_type=http ;;
esac
d1099 1
a1099 1
cat << __EOT
d1106 19
a1124 19
# Proxy the connections?
if [ "X${_proxy_host}" = X"" ]; then
	_proxy_host=none
fi
echo -n "HTTP/FTP proxy URL? (e.g. \"http://proxy:8080\", or \"none\") [${_proxy_host}] "
getresp "$_proxy_host"
if [ "X${resp}" = X"none" ]; then
	unset _proxy_host ftp_proxy http_proxy
else
	_proxy_host=$resp
	export ftp_proxy=${_proxy_host}
	export http_proxy=${_proxy_host}
fi
if [ "${_url_type}" = "ftp" -a "X$ftp_proxy" = "X" ]; then
	# Use active mode ftp? (irrelevant if using a proxy)
	case $_ftp_active in
	-A)	resp=y ;;
	*)	resp=n ;;
	esac
d1126 1
a1126 1
	cat << __EOT
d1128 1
a1128 1
(active) connection if that doesn't work.  However, there are some very
d1132 12
a1143 2
	echo -n "Do you want to use active ftp? [${resp}] "
	getresp "$resp"
d1145 11
a1155 2
	y*|Y*)	_ftp_active=-A ;;
	*)	unset _ftp_active ;;
a1156 1
fi
d1158 33
a1190 39
# Provide a list of possible servers
test -z "$_ftp_getlist" && _ftp_getlist=y
echo -n "Do you want a list of potential ${_url_type} servers? [${_ftp_getlist}] "
getresp "$_ftp_getlist"
case $resp in
n*|N*)	_ftp_getlist=n
	;;
*)
	_ftp_getlist=y
	ftphost=129.128.5.191
	if [ "X${_resolver_enabled}" = X"TRUE" ]; then
		ftphost=ftp.openbsd.org
	fi
	ftp ${_ftp_active} -V -a -o /tmp/ftplist ftp://${ftphost}/pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/ftplist > /dev/null
	cat /tmp/ftplist | grep "^${_url_type}:" | cat -n | less -XE
	;;
esac

# Get server IP address
resp=
while [ "X${resp}" = X"" ]; do
	if [ -f /tmp/ftplist ]; then
		eval echo -n "Server IP address, hostname, or list#? [\$_${_url_type}_server_ip]\ "
	else
		eval echo -n "Server IP address, or hostname? [\$_${_url_type}_server_ip]\ "
	fi
	eval getresp "\$_${_url_type}_server_ip"
	if [ "X$resp" = "X?" -a -f /tmp/ftplist ]; then
		cat /tmp/ftplist | grep "^${_url_type}:" | cat -n | less -XE
		resp=
	elif [ -n "$resp" \
		-a `isnumeric $resp` -eq 1 \
		-a ${resp:-0} -ge 1 \
		-a -f /tmp/ftplist ]
		then
		maxlines=`grep "^${_url_type}:" /tmp/ftplist | cat -n |
			sed -n -e '$p' | cutword 1`
		if [ $maxlines -lt $resp ]; then
			echo "There is no ${resp}th line in the list."
d1192 3
a1194 1
			continue
d1196 1
a1196 15
		tline=`grep "^${_url_type}:" /tmp/ftplist | sed -n -e "${resp}p"`
		url=`echo $tline | sed -e "s/^${_url_type}:\/\///" |
			cutword -t' ' 1 | cutword -t' ' 1`
		host=`echo $url | cutword -t/ 1`
		path=`echo $url | sed -e "s/^${host}\///"`
		path=${path}/${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}
		eval _${_url_type}_server_ip=$host
		eval _${_url_type}_server_dir=$path
		# do it again, just to double check
		resp=
		echo "Using	$tline"
	else
		eval _${_url_type}_server_ip=$resp
	fi
done
d1198 4
a1201 19
# Get server directory
if [ "${_url_type}" = "ftp" -a "X${_ftp_server_dir}" = X"" ]; then
	# Default ftp dir
	_ftp_server_dir=pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}
fi
resp=
while [ "X${resp}" = X"" ]; do
	eval echo -n "Server directory? [\$_${_url_type}_server_dir]\ "
	eval getresp "\$_${_url_type}_server_dir"
	eval _${_url_type}_server_dir=$resp
done

if [ "${_url_type}" = "ftp" ]; then
	# Need default values even if we proxy ftp...
	if [ "X${_ftp_server_login}" = X"" ]; then
		_ftp_server_login=anonymous
	fi
	if [ "X${_ftp_server_password}" = X"" ]; then
		_ftp_server_password=root@@`hostname`.${FQDN}
a1202 5

	# Get login name, setting IFS to nothing so trailing or
	# embedded blanks are preserved!
	_oifs=$IFS
	IFS=
d1204 4
a1207 4
	while [ "X${resp}" = X"" ]; do
		echo -n "Login? [${_ftp_server_login}] "
		getresp "$_ftp_server_login"
		_ftp_server_login=$resp
d1210 13
a1222 2
	# Get password unless anonymous
	if [ "${_ftp_server_login}" != "anonymous" ]; then
d1224 4
a1227 7
		while [ "X${resp}" = X"" ]; do
			echo -n "Password (will not echo): "
			stty -echo
			getresp -n "$_ftp_server_password"
			stty echo
			echo
			_ftp_server_password=$resp
d1229 17
a1245 3
	else
		# only used by ftp_list_files()
		_ftp_server_password=root@@`hostname`.${FQDN}
a1246 21
	IFS=$_oifs
fi

# Build up the base url since it is so nasty...
if [ "${_url_type}" = "ftp" -a "${_ftp_server_login}" != "anonymous" ]; then
	_url_login=`encode_for_url "${_ftp_server_login}"`
	_url_pass=`encode_for_url "${_ftp_server_password}"`
	_url_base=ftp://${_url_login}:${_url_pass}@@${_ftp_server_ip}/${_ftp_server_dir}
else
	eval _url_base=${_url_type}://\$_${_url_type}_server_ip/\$_${_url_type}_server_dir
fi

# Get list of files from the server.
# XXX - check for nil $_file_list and deal
if [ "${_url_type}" = "ftp" -a "X${ftp_proxy}" = X"" ]; then
	_file_list=`ftp_list_files "$_ftp_server_ip" "$_ftp_server_login" "$_ftp_server_password" "$_ftp_server_dir"`
else
	# Assumes index file is "index.txt" for http (or proxy)
	# We can't use index.html since the format is server-dependent
	_file_list=`ftp -o - -V "${_url_base}/index.txt" | sed 's///'`
fi
d1248 5
a1252 37
_sets=
if list_has_sets "$_file_list" $THESETS; then
	for _f in $THESETS ; do
		if [ "X${_f}" = "Xkernel" ]; then
			if isin bsd $_file_list; then
				_kernel=bsd
			fi
		elif isin ${_f}${VERSION}.tar.gz $_file_list; then
			_sets="$_sets ${_f}${VERSION}.tar.gz"
		elif isin ${_f}${VERSION}.tgz $_file_list; then
			_sets="$_sets ${_f}${VERSION}.tgz"
		fi
	done
else
	eval echo "There are no OpenBSD install sets available in \"\$_${_url_type}_server_dir\"."
	echo -n "Search for *.tar.gz and *.tgz files? [y] "
	getresp y
	case $resp in
	n*|N*)	return ;;
	esac
	# *.tar.gz and *.tgz are possible sets
	_sets=
	_kernel=
	for _f in ${_file_list} ; do
		case $_f in
		*.tar.gz|*.tgz)	_sets="$_sets ${_f}"
		esac
	done
	if [ "X${_sets}" = X"" ]; then
		echo "There are no *.tar.gz or *.tgz files in that dir."
		echo -n "See a directory listing? [y] "
		getresp y
		case $resp in
		n*|N*)	return ;;
		esac
		echo "\n${_file_list}\n"
		return
d1254 1
a1254 1
		echo "Adding *.tar.gz and *.tgz files to selector."
a1255 1
fi
d1257 8
a1264 30
	display_extract_msg "$(eval echo ${_url_type}://\$_${_url_type}_server_ip/\$_${_url_type}_server_dir)"

_osetsdone=$_setsdone
# Set the minimal default
for _f in $_sets $_kernel; do
	# From logic above, $_sets contains only .tgz and .tar.gz
	# file names, and $_kernel is empty or 'bsd'.
	case $_f in
	base*|bsd|comp*|etc*|game*|man*|misc*)
		if ! isin ${_f} ${_setsdone}; then
			_get_files=`addel ${_f} ${_get_files}`
			_setsdone=`addel ${_f} ${_setsdone}`
		fi
		;;
	esac
done

# Allow the user to select/de-select additional sets
while : ; do
    
	display_selection_msg

	get_selection "$_sets $_kernel"

	if [ "X${resp}" = X"done" ]; then
		break
	elif [ "X${resp}" = X"list" ]; then
		eval echo "\n\$_${_url_type}_server_dir:"
		echo "${_file_list}"
		continue
d1267 1
a1267 2
	eval glob_selection \"$resp\" \$_${_url_type}_server_dir \"$_sets $_kernel\"
done
d1269 1
a1269 4
# User may have said "done" without selecting any files
if [ "X${_get_files}" = X"" ]; then
	return
fi
d1271 1
a1271 2
# Stash the fact that we configured and downloaded via this url method
eval _installed_via_${_url_type}=1
d1273 1
a1273 27
echo "\nFetching files via ${_url_type} may take a long time, especially over a slow network"
echo -n "connection. Ready to download files? [y] "
getresp y
case $resp in
y*|Y*)	;;
*)	_setsdone=$_osetsdone
	return
	;;
esac

# Download the files one at a time and keep track of which ones failed
while test -n "${_get_files}" ; do
	_failed_files=
	echo
	for _f in $_get_files ; do
		echo "Getting ${_f} ..."
		if [ "X${_f}" = "X${_kernel}" ]; then
			( cd /mnt ; ftp ${_ftp_active} -V -m "${_url_base}/${_f}" )
		else
			( cd /mnt ; ftp ${_ftp_active} -o - -V -m "${_url_base}/${_f}" | tar zxpf - )
		fi
		if [ $? -ne 0 ]; then
			# Mark xfer as having failed,.
			_setsdone=`rmel $_f $_setsdone`
			_failed_files="${_failed_files} ${_f}"
		fi
	done
d1275 2
a1276 4
	# Give them the option of refetching failed files.
	_get_files=
	while test -n "${_failed_files}" ; do
		display_failure_msg
d1278 1
a1278 1
		get_selection "$_failed_files"
d1280 3
a1282 7
		if [ "X${resp}" = X"done" ]; then
			break
		elif [ "X${resp}" = X"list" ]; then
			eval echo "\n\$_${_url_type}_server_dir:"
			echo "${_file_list}\n"
			continue
		fi
d1284 5
a1288 3
		eval glob_selection \"$resp\" \$_${_url_type}_server_dir \"$_failed_files\"
	done
done
d1292 2
a1293 2
# $1 - directory containing installation sets
local _sets= _kernel _f _get_files _failed_files _osetsdone
d1295 2
a1296 38
if [ ! -d "$1" ]; then
	echo "No such directory: '$1'"
	return
fi

if dir_has_sets "$1" $THESETS; then
	for _f in $THESETS ; do
		if [ "X${_f}" = "Xkernel" ]; then
			if [ -f "$1/bsd" ]; then
				_kernel=bsd
			fi
		elif [ -f "$1/${_f}${VERSION}.tar.gz" ]; then
			_sets="$_sets ${_f}${VERSION}.tar.gz"
		elif [ -f "$1/${_f}${VERSION}.tgz" ]; then
			_sets="$_sets ${_f}${VERSION}.tgz"
		fi
	done
else
	echo "There are no OpenBSD install sets available in \"$1\"."
	echo -n "Search for *.tar.gz and *.tgz files? [y] "
	getresp y
	case $resp in
	n*|N*)	return ;;
	esac
	# *.tar.gz and *.tgz are possible sets
	_sets=
	_kernel=
	_sets=`cd "$1" ; echo *.tar.gz *.tgz`
	if [ "X${_sets}" = X'*.tar.gz *.tgz' ]; then
		echo "There are no *.tar.gz or *.tgz files in that dir."
		echo -n "See a directory listing? [y] "
		getresp y
		case $resp in
		n*|N*)	return ;;
		esac
		echo
		( cd "$1" && ls )
		echo
a1297 2
	else
		echo "Adding *.tar.gz and *.tgz files to selector."
a1298 1
fi
d1300 1
a1300 1
display_extract_msg "$1"
d1302 1
a1302 14
_osetsdone=$_setsdone
# Set a minimal default
for _f in $_sets $_kernel; do
	case $_f in
	# From logic above, $_sets contains only .tgz and .tar.gz
	# file names, and $_kernel is empty or 'bsd'.
	base*|bsd|comp*|etc*|game*|man*|misc*)
		if ! isin ${_f} ${_setsdone}; then
			_get_files=`addel ${_f} ${_get_files}`
			_setsdone=`addel ${_f} ${_setsdone}`
		fi
		;;
	esac
done
d1304 1
a1304 2
# Allow the user to select/de-select additional sets
while : ; do
d1306 1
a1306 1
	display_selection_msg
d1308 1
a1308 1
	get_selection "$_sets $_kernel"
d1310 2
a1311 7
	if [ "X${resp}" = X"done" ]; then
		break
	elif [ "X${resp}" = X"list" ]; then
		echo "\n${1}:"
		( cd $1 && ls )
		continue
	fi
d1313 2
a1314 55
	glob_selection "$resp" "$1" "$_sets $_kernel"
done

# User may have said "done" without selecting any files
if [ "X${_get_files}" = X"" ]; then
	return
fi

echo -n "\nReady to extract selected file sets? [y] "
getresp y
case $resp in
y*|Y*)	;;
*)	_setsdone=$_osetsdone
	return
	;;
esac

# Extract the files one at a time and keep track of which ones failed
while test -n "${_get_files}" ; do
	_failed_files=
	echo
	for _f in $_get_files ; do
		echo "$1/${_f}:"
		if [ "X${_f}" = "X${_kernel}" ]; then
			ftp -V -m -o /mnt/$_f file:$1/$_f
		else
			ftp -V -m -o - file:$1/$_f | (cd /mnt; tar -zxpf -)
		fi
		if [ $? -ne 0 ]; then
			# Mark xfer as having failed,.
			_setsdone=`rmel $_f $_setsdone`
			_failed_files="${_failed_files} ${_f}"
		fi
	done

	# Give them the option of retrying failed files.
	_get_files=
	while test -n "${_failed_files}" ; do
		display_failure_msg

		get_selection "$_failed_files"

		if [ "X${resp}" = X"done" ]; then
			break
		elif [ "X${resp}" = X"list" ]; then
			echo "\n${1}:"
			( cd $1 && ls )
			echo
			continue
		fi

		glob_selection "$resp" "$1" "$_failed_files"
	done
done
}
d1317 1
a1317 1
local _drive _range _part _fstype _directory _n
d1319 5
a1323 5
# Get the cdrom device info
if [ "X${_CDDEVS}" = X"" ]; then
	echo "No CD-ROM devices were found.  Aborting."
	return
fi
d1325 1
a1325 1
cat << __EOT
d1334 6
a1339 11
_drive=`echo $_CDDEVS | cutword 1`
echo -n	"Which CD-ROM contains the installation media? [$_drive] "
getresp "$_drive"
case $resp in
abort)	echo "Aborting."
	return
	;;
*)	if isin $resp $_CDDEVS ; then
		_drive=$resp
	else
		echo "\nThe CD-ROM $resp does not exist.\nAborting."
d1341 9
a1349 3
	fi
	;;
esac
d1351 13
a1363 9
# If it is an ISO9660 CD-ROM, we don't need to ask any other questions
_n=0
until disklabel $_drive >/tmp/label.$_drive 2>&1; do
	# Try up to 6 times to access the CD
	if egrep -q '(Input/output error)|(sector size 0)' /tmp/label.$_drive; then
		_n=$(( $_n + 1 ))
		if [ _n -le 5 ]; then
			echo "I/O error accessing $_drive; retrying"
			sleep 10
d1365 1
a1365 2
			echo "Cannot access $_drive.  Aborting."
			return
d1367 6
d1374 16
a1389 24
		break
	fi
done
echo
if grep -q '^ *c: .*ISO9660' /tmp/label.$_drive; then
	_fstype=cd9660
	_part=c
else
	# Get partition from user
	_range=`md_get_partition_range`
	resp=
	while [ "X${resp}" = X"" ]; do
		echo -n 'CD-ROM partition to mount? (normally "c") [c] '
		getresp c
		case $resp in
		$_range)
			_part=$resp
			;;
		*)	echo "Invalid response: $resp"
			# force loop to repeat
			resp=
			;;
		esac
	done
d1391 2
a1392 2
	# Ask for filesystem type
	cat << __EOT
d1399 15
a1413 16
	resp=
	while [ "X${resp}" = X"" ]; do
		echo -n "Which filesystem type? [cd9660] "
		getresp cd9660
		case $resp in
		cd9660|ffs)
			_fstype=$resp
			;;
		*)	echo "Invalid response: $resp"
			# force loop to repeat
			resp=
			;;
		esac
	done
fi
rm -f /tmp/label.$_drive
d1415 1
a1415 5
# Mount the CD-ROM
if ! mount -t ${_fstype} -o ro /dev/${_drive}${_part} /mnt2 ; then
	echo "Cannot mount CD-ROM drive.  Aborting."
	return
fi
d1417 5
a1421 5
# Get the directory where the file lives
resp=
_directory=${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}
echo "Enter the directory relative to the mount point that contains"
echo -n "the file: [${_directory}] "
d1423 5
a1427 1
getresp "$_directory"
d1429 4
a1432 2
install_from_mounted_fs "/mnt2/${resp}"
umount -f /mnt2 > /dev/null 2>&1
d1436 3
a1438 3
# Mount a disk on /mnt2. The set of disk devices to choose from
# is $_DKDEVS.
# returns 0 on failure.
d1440 2
a1441 2
local _drive _def_partition _partition_range _partition _fstype
local _fsopts _md_fstype _md_fsopts
d1443 1
a1443 1
cat << __EOT
d1452 2
a1453 2
echo -n	"Which is the disk with the installation sets? [abort] "
getresp abort
d1455 2
a1456 8
case $resp in
abort)	echo "Aborting."
	return 0
	;;
*)	if isin $resp $_DKDEVS ; then
		_drive=$resp
	else
		echo "\nThe disk $resp does not exist.\nAborting."
d1458 9
a1466 3
	fi
	;;
esac
d1468 2
a1469 2
# Get partition
cat << __EOT
d1474 10
a1483 13
disklabel $_drive 2>/dev/null | grep '^  .:'
echo
_likely_partition_range=`disklabel $_drive 2>/dev/null | \
	sed -n -e '/swap/s/.*//' -e '/unused/s/.*//' \
		-e '/^  .:/{s/^  \(.\).*/\1/;H;}' \
		-e '${g;s/\n//g;s/^/[/;s/$/]/p;}'`
_partition_range=`disklabel $_drive 2>/dev/null | \
	sed -n -e '/^  .:/{s/^  \(.\).*/\1/;H;}' \
		-e '${g;s/\n//g;s/^/[/;s/$/]/p;}'`
_def_partition=`echo $_likely_partition_range | \
	sed -n 's/^\[\(.\).*\]/\1/p'`
if [ -z "$_def_partition" ]; then
	_def_partition=`echo $_partition_range | \
d1486 6
a1491 2
		echo "There are no usable partitions on that disk"
		return 0
a1492 15
fi
resp=
while [ "X${resp}" = X"" ]; do
	echo -n "Partition? [$_def_partition] "
	getresp "$_def_partition"
	case $resp in
	$_partition_range)
		_partition=$resp
		;;
	*)	echo "Invalid response: $resp"
		# force loop to repeat
		resp=
		;;
	esac
done
d1494 17
a1510 2
# Ask for filesystem type
cat << __EOT
a1515 29
_md_fstype=`md_native_fstype`
_md_fsopts=`md_native_fsopts`
if [ ! -z "$_md_fstype" ]; then
	echo "	$_md_fstype"
else
	_md_fstype=_undefined_
fi
resp=
while [ "X${resp}" = X"" ]; do
	echo -n "Which filesystem type? [default] "
	getresp default
	case $resp in
	default)
		_fstype=
		_fsopts=ro
		;;
	ffs)	_fstype="-t $resp"
		_fsopts=async,ro
		;;
	$_md_fstype)
		_fstype="-t $resp"
		_fsopts=$_md_fsopts
		;;
	*)	echo "Invalid response: $resp"
		# force loop to repeat
		resp=
		;;
	esac
done
d1517 36
a1552 5
# Mount the disk
if ! mount $_fstype -o $_fsopts /dev/${_drive}${_partition} /mnt2; then
	echo "Cannot mount disk.  Aborting."
	return 0
fi
d1554 1
a1554 1
return 1
d1574 1
a1574 1
	while [ "X${resp}" = X"" ]; do
d1582 1
a1582 1
	while [ "X${resp}" = X"" ]; do
d1607 1
a1607 1
	while [ "X${resp}" = X"" ]; do
d1618 1
a1618 1
local _xcmd
d1620 2
a1621 2
# Get the name of the tape from the user.
cat << __EOT
d1623 1
a1623 1
The installation program needs to know which tape device to use.  Make
d1627 14
a1640 14
_tape=`basename $TAPE`
resp=
while [ "X${resp}" = X"" ]; do
	echo -n "Name of tape device? [${_tape}]"
	getresp "$_tape"
done
_tape=`basename $resp`
TAPE=/dev/${_tape}
if [ ! -c $TAPE ]; then
	echo "$TAPE does not exist or is not a character special file."
	echo "Aborting."
	return
fi
export TAPE
d1642 8
a1649 8
# Rewind the tape device
echo -n "Rewinding tape..."
if ! mt rewind ; then
	echo "$TAPE may not be attached to the system or may not be"
	echo "a tape device.  Aborting."
	return
fi
echo "done."
d1651 14
a1664 14
# Get the file number
resp=
while [ "X${resp}" = X"" ]; do
	echo -n "File number? "
	getresp
	case $resp in
	[1-9]*)	_nskip=$(( $resp - 1 ))
		;;
	*)	echo "Invalid file number ${resp}."
		# force loop to repeat
		resp=
		;;
	esac
done
d1666 7
a1672 6
# Skip to correct file.
echo -n "Skipping to source file..."
if [ "X${_nskip}" != X"0" ]; then
	if ! mt fsf $_nskip ; then
		echo "Could not skip $_nskip files.  Aborting."
		return
d1674 1
a1674 2
fi
echo "done."
d1684 18
a1701 17
resp=
while [ "X${resp}" = X"" ]; do
	echo -n "Which way is it? [1] "
	getresp 1
	case $resp in
	1)	_xcmd="tar -zxvpf -"
		;;
	2)	_xcmd="tar -xvpf -"
		;;
	*)	echo "Invalid response: $resp."
		# force loop to repeat
		resp=
		;;
	esac
	( cd /mnt; dd if=$TAPE | $_xcmd )
done
echo "Extraction complete."
d1705 1
a1705 1
local _zoneroot=/mnt/usr/share/zoneinfo/ _zonepath
d1707 2
a1708 2
# If the timezone directory structure is not
# available, return immediately.
d1710 1
a1710 1
[ ! -d $_zoneroot ] && return
d1712 1
a1712 1
cat << __EOT
d1716 1
a1716 1
be selected by entering a token like "CET" or "GMT-6".  Other zones are
d1722 4
a1725 4
if [ -L /mnt/etc/localtime ]; then
	TZ=`ls -l /mnt/etc/localtime 2>/dev/null | cutlast`
	TZ=${TZ#${_zoneroot#/mnt}}
fi
d1727 1
a1727 1
[ -z $TZ ] && TZ=GMT
d1729 2
a1730 10
while : ; do
	_zonepath=$_zoneroot

	echo -n	"What timezone are you in? (\`?' for list) [$TZ] "
	getresp "$TZ"

	if [ "$resp" = "?" ]; then
		ls -F ${_zonepath}
		continue;
	fi
d1732 2
a1733 1
	_zonepath=${_zonepath}${resp}
a1734 4
	while [ -d ${_zonepath} ]; do
		echo -n "Select a sub-timezone of "
		echo -n "'${_zonepath#$_zoneroot}' (\`?' for list): "
		getresp
d1737 1
a1737 2
		else
			_zonepath=${_zonepath}/${resp}
a1738 1
	done
d1740 19
a1758 6
	if [ -f ${_zonepath} ]; then
		TZ=${_zonepath#$_zoneroot}
		echo "You have selected timezone '$TZ'".
		ln -sf /usr/share/zoneinfo/$TZ /mnt/etc/localtime
		return
	fi
d1760 3
a1762 3
	echo -n "'${_zonepath#$_zoneroot}'"
	echo " is not a valid timezone on this system."
done
d1769 2
a1770 2
Warning, no kernel (/mnt/bsd) installed!  You did not unpack a file set
containing a kernel--this is needed to boot.  Please note that the install
d1777 1
a1777 1
which you probably want).  This seems to indicate that you are still missing
d1798 1
a1798 1
You will now be given the chance to install the missing set(s).  You can
d1807 1
a1807 1
local _yup=FALSE _have_nfs
d1809 2
a1810 2
# Can we do an NFS install?
test -f /sbin/mount_nfs && _have_nfs=true
d1812 9
a1820 7
# Ask the user which media to load the distribution from.
cat << __EOT
It is now time to extract the installation sets onto the hard disk.  Make sure
the sets are either on a local device (i.e. tape, CD-ROM) or on a network
server.  You will have the chance to repeat this step or to extract sets from
several places, so you don't have to try to load all the sets in one try and
can recover from some errors.
d1824 3
a1826 4
if [ "X$local_sets_dir" != "X" ]; then
	install_from_mounted_fs "${local_sets_dir}"
	if [ X"$_setsdone" != X ]; then
		_yup=TRUE
a1827 1
fi
d1829 38
a1866 34
# Go on prodding for alternate locations
resp=
while [ X"${resp}" = X ]; do
	# If _yup is not FALSE, it means that we extracted sets above.
	# If that's the case, bypass the menu the first time.
	if [ X"$_yup" = X"FALSE" ]; then
		echo -n	"Install from (f)tp, (h)ttp, (t)ape, (C)D-ROM"
		test -n "$_have_nfs" && echo -n ", (N)FS"
		echo -n " or local (d)isk? "
		getresp
		case $resp in
		d*|D*)	install_disk
			resp=d
			;;
		f*|F*)	test -n "$_didnet" || donetconfig
			install_url -ftp
			resp=f
			;;
		h*|H*)	test -n "$_didnet" || donetconfig
			install_url -http
			resp=h
			;;
		t*|T*)	install_tape
			resp=t
			;;
		c*|C*)	install_cdrom
			resp=c
			;;
		n*|N*)	test -n "$_didnet" || donetconfig
			if [ -n "$_have_nfs" ]; then
				install_nfs
				resp=n
			else
				echo "Invalid response: $resp"
d1868 6
a1873 10
			fi
			;;
		*)	echo "Invalid response: $resp"
			resp=
			;;
		esac
	else
		# So we'll ask next time
		_yup=FALSE
	fi
d1875 13
a1887 8
	# Perform sanity checks...
	if sane_install; then
		# Give the user the opportunity to extract more sets. They
		# don't necessarily have to come from the same media.
		echo -n	"\nExtract more sets? [n] "
		getresp n
		case $resp in
		y*|Y*)	# Force loop to repeat
d1889 2
a1890 7
			;;
		esac
	else
		# Not sane, don't exit loop.
		resp=
	fi
done
d1918 1
a1918 1
			_mp=""
d1942 1
a1942 1
FATAL ERROR:	Cannot mount filesystems.  Double-check your configuration
d2023 1
a2023 1
	if [ -f "$2" -a "X$FQDN" != "X" ]; then
d2032 1
a2032 1
		echo -n "Enter DNS domain name (e.g. \"bar.com\"): [$FQDN] "
d2047 2
a2048 2
	while [ "X${resp}" = X"" ]; do
		echo -n "Enter system hostname (short form, e.g. \"foo\"): [$_nam] "
d2102 1
a2102 1
	if [ "X${resp}" = "X" ]; then
d2106 1
a2106 1
			if [ "X${resp}" = "X" ]; then
d2126 1
a2126 1
			if [ "X${resp}" = "X" ]; then
d2170 2
a2171 2
any additional network configuration you may need.  This may include adding
additional routes, if needed.  In addition, you might take this opportunity
d2202 3
a2204 1
	test -x /mnt/${MODE}.site && /mnt/usr/sbin/chroot /mnt /${MODE}.site
d2218 2
d2222 2
a2223 2
# Some may require machine dependend routines, which may
# call functions defined above, so it's easiest to put this
d2225 2
d2242 1
a2242 1
# Path searched for sets by install_sets on the local filesystems
d2244 4
d2250 1
a2250 1
if [ "X$EDITOR" = X ]; then
d2273 3
a2275 2
	echo -n "Skip disk initialization and "

d2278 1
a2278 1
echo -n "Proceed with ${MODE}? [n] "
@


1.198
log
@Abstract out common startup and finishing code from install.sh
and upgrade.sh, putting it into install.sub.

Replace groups of echo's with here documents.

Eliminate bare echo's with embedded \n's.

Abstract repeated verbiage into display_* functions, also eliminating
a backslash orgy when showing the ftp/http server location. This
also makes the verbiage consistant across ftp, cd, etc. installs.

Try hard to make file selection screen fit on one screen.

Fix default in 'File name?' prompt so it contains the first
non-selected set.

Some minor wording adjustment, typos, etc.

Net shrinkage of about 1.5K.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.197 2002/04/02 01:25:34 krw Exp $
d822 1
a822 1
	local _next= _f _sets=$1
d829 1
a829 1
			if [ -z "$_next" ]; then
d839 5
@


1.197
log
@Do not copy /etc/mygate to install'ed systems if dhcp is specified
for one or more network interfaces.

Rework timezone logic to shrink it and make it more clear. Don't
bother checking for /usr/share/zoneinfo as it is never there, just
look for /mnt/usr/share/zoneinfo.

Eliminate spurious early call to get_timezone() that
(accidentally?)  made GMT the default timezone during
installs. Instead rely on the /etc/localtime that is installed
from etcXX.gz. Currently this means the default timezone is the
historically resonant US/Pacific.

Ideas if not code details ok deraadt@@ and millert@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.196 2002/03/31 15:30:42 krw Exp $
d69 17
a85 1
#	OpenBSD installation/upgrade script - common subroutines.
d387 1
a387 2
		echo
		echo "The disk $resp does not exist."
d415 1
a415 2
		echo
		echo "The disk '$resp' does not exist."
d526 1
a526 2
		echo "DHCP install not supported"
		echo
d565 4
a568 2
		echo "Your use of the network interface may require non-default"
		echo "media directives.  The default media is:"
d577 4
a580 2
		echo "If the default is not satisfactory, and you wish to use another"
		echo "media, copy that line from above (e.g. \"media 100baseTX\")"
a826 1
			_next=
d895 4
a898 2
		echo "File $_parent_dir/$_selection does not exist.  Check to make"
		echo "sure you entered the information properly or enter 'list' for a file list."
d902 36
d967 6
a972 4
echo
echo "This is an automated ${_url_type}-based installation process.  You will be asked"
echo "questions and then the files will be retrieved iteratively via ${_url_type}."
echo
d993 7
a999 4
	echo "By default, ftp will attempt a passive connection and fall back to a normal"
	echo "(active) connection if that doesn't work.  However, there are some very"
	echo "old ftp servers that claim to support passive mode, but really do not."
	echo "In this case, you should explicitly request an active session."
d1170 1
a1170 3
		echo
		echo "${_file_list}"
		echo
d1177 2
a1178 10
# Yes, all those blackslashes really are necessary...
eval echo "\\\\n"\
"You will now be asked for files to extract. In addition to the files listed,\\\\n"\
"you may select any file located at\\\\n"\
"	\$_${_url_type}_server_ip:\$_${_url_type}_server_dir\\\\n"\
"You can also enter \'all\' to install all the standard sets, or \'list\' to list\\\\n"\
"the files available.  When you are done selecting files, enter \'done\'. Some of\\\\n"\
"these sets are required for your ${MODE} and some are optional -- you will want\\\\n"\
"at least the base and bsd sets.  Consult the installation notes if you are not\\\\n"\
"sure which sets are required!"
d1196 3
a1198 5
	echo
	echo "The following sets are available for extraction."
	echo "Enter filename, \`list', \`all', or \`done'."
	echo "You may de-select a set by prepending a '-' to its name."
	echo
d1204 1
a1204 2
		echo
		eval echo "\$_${_url_type}_server_dir:"
d1220 1
a1220 2
echo
echo "Fetching files via ${_url_type} may take a long time, especially over a slow network"
d1251 2
a1252 5
		echo
		echo "The following files failed to transfer and extract correctly:"
		echo "Choose which one(s) to refetch or 'done' to exit selector."
		echo "You may de-select a file by prepending a '-' to its name."
		echo
d1258 2
a1259 4
			echo
			eval echo "\$_${_url_type}_server_dir:"
			echo "${_file_list}"
			echo
d1316 2
a1317 9
echo "\n"\
"You will now be asked for files to extract.  In addition to the\n"\
"files listed in the selector you may enter any file located in\n"\
"$1.  You can also enter 'all' to install all the standard\n"\
"sets, or 'list' to list the files avilable in $1.\n"\
"When you are done selecting files, enter 'done'.\n"\
"Some of these sets are required for your ${MODE} and some are optional --\n"\
"You will want at least the base and bsd sets.\n"\
"Consult the installation notes if you are not sure which sets are required!"
d1335 3
a1337 5
	echo
	echo "The following sets are available for extraction."
	echo "Enter filename, \`list', \`all', or \`done'."
	echo "You may de-select a set by prepending a '-' to its name."
	echo
d1343 1
a1343 2
		echo
		echo "${1}:"
d1356 1
a1356 2
echo
echo -n "Ready to extract selected file sets? [y] "
d1386 2
a1387 5
		echo
		echo "The following files failed to extract correctly:"
		echo "Choose which one(s) to retry or 'done' to exit selector."
		echo "You may de-select a file by prepending a '-' to its name."
		echo
d1393 1
a1393 2
			echo
			echo "${1}:"
d1432 1
a1432 3
		echo
		echo "The CD-ROM $resp does not exist."
		echo "Aborting."
d1547 1
a1547 3
		echo
		echo "The disk $resp does not exist."
		echo "Aborting."
d1861 6
d1870 1
a1870 1
Something needed to complete the installation seems to be missing, did you
d1960 1
a1960 2
		echo
		echo -n	"Extract more sets? [n] "
d2152 7
a2158 5
	echo
	echo "If any interfaces will be configured using a DHCP server"
	echo "it is recommended that you do not enter a DNS domain name,"
	echo "a default route, or any name servers."
	echo
d2232 1
a2232 3
		echo
		echo "The host table is as follows:"
		echo
d2270 28
a2297 1
# Actions common to both installs and upgrades.
d2328 38
@


1.196
log
@naddy@@ pointed out that in the two situations

case WORD

and

var=WORD

Bourne and related/descendant shells such as our sh do *not* do
field splitting or globbing on WORD. Thus we can eliminate a large
number of unnecessary '"'s in case statements and variable
assignments.

This is a lightly adapted version of naddy's diff, to take account
of changes in the scripts since he generated it.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.195 2002/03/31 03:05:04 krw Exp $
d159 1
a159 1
		test "$1" = "" && break
d1765 1
a1765 1
local _a _zonepath
d1767 4
a1770 13
#
# If the zoneinfo is not on the installation medium or on the
# installed filesystem, set TZ to GMT and return immediatly.
#
if [ ! -e /usr/share/zoneinfo -a ! -e /mnt/usr/share/zoneinfo ]; then
	TZ=GMT
	return
fi
if [ ! -d /usr/share/zoneinfo ]; then
	_zonepath=/mnt
else
	_zonepath=
fi
d1780 1
a1780 2
To get a listing of what's available in /usr/share/zoneinfo, enter "?"
at the prompts below.
d1782 1
a1782 2
__EOT
if [ X$TZ = X ]; then
d1784 1
a1784 1
	TZ=${TZ#/usr/share/zoneinfo/}
d1786 3
d1790 2
d1794 16
a1809 26
	case $resp in
	"")	echo "Timezone defaults to GMT"
		TZ=GMT
		break
		;;
	"?")	ls -F ${_zonepath}/usr/share/zoneinfo
		;;
	*)	_a=$resp
		while [ -d ${_zonepath}/usr/share/zoneinfo/$_a ]; do
			echo -n "There are several timezones available"
			echo " within zone '$_a'"
			echo -n "Select a sub-timezone (\`?' for list): "
			getresp
			case $resp in
			"?")	ls -F ${_zonepath}/usr/share/zoneinfo/$_a ;;
			*)	_a=${_a}/${resp}
				if [ -f ${_zonepath}/usr/share/zoneinfo/$_a ]; then
					break
				fi
				;;
			esac
		done
		if [ -f ${_zonepath}/usr/share/zoneinfo/$_a ]; then
			TZ=$_a
			echo "You have selected timezone \"$_a\"".
			return
d1811 11
a1821 3
		echo "'/usr/share/zoneinfo/$_a' is not a valid timezone on this system."
		;;
	esac
d2154 1
a2154 1
		sed -e 's/^default          //' -e 's/ .*//'`
@


1.195
log
@This omnibus diff does a number of cleanups:

1) Move the 'executed' code at the top of install.sub
   to the end, so that it can successfully use .md
   functions.

2) Get _DKDEVS once only, and get _CDDEVS at the same
   time (see (1))

3) Clean up calls to getresp so that
      a) no '"'s used on constants
      b) '"'s always used for variables
      c) never use {} for variables
      d) ensure parameter passed matches default shown
         in any preceeding []

4) Try to put '"'s around directory names

5) Replace a couple of instances of using []s around
   a prompt comment instead of ()s

6) Reduce some code by putting $_DKDEVS inside
   here documents, rather than echo'ing it

7) eliminate an unused variable _directory

8) eliminate a couple of while RESP="" loops which
   never loop because a non-null default is provided
   to getresp

9) move some code into mount_a_disk to make logic
   clearer

10) eliminate a couple of extra blanks in prompts

11) eliminate ALLSETS and UPGRSETS by just removing
    'etc' from THESETS in upgrade.sh

12) Indent a couple of smaller functions

ok deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.194 2002/03/30 13:34:51 krw Exp $
d81 1
a81 1
	valid=""
d85 1
a85 1
			test -z "$resp" && resp="$1"
d87 2
a88 2
			case "$resp" in
			"")	resp="$1"
d99 1
a99 1
		valid="true"
d125 1
a125 1
			_seen="yes"
d149 1
a149 1
	local _a _n _oifs="$IFS"
d152 1
a152 1
	case "$1" in
d162 1
a162 1
	IFS="$_oifs"
d167 1
a167 1
	local _a _oifs="$IFS"
d170 1
a170 1
	case "$1" in
d175 1
a175 1
	IFS="$_oifs"
d195 2
a196 2
	_oifs="$IFS"
	IFS="/"
d198 1
a198 1
	IFS="$_oifs"
d259 1
a259 1
	local _dir="$1" _file
d320 1
a320 1
		_dir="$resp"
d326 1
a326 1
			case "$resp" in
d336 1
a336 1
			local_sets_dir="$_mp/$_dir"
d345 1
a345 1
			case "$resp" in
d369 1
a369 1
		DISK="$resp"
d398 1
a398 1
		ROOTDISK="$resp"
d466 1
a466 1
		case "$resp" in
d471 1
a471 1
			_ouranswer="done"
d705 1
a705 1
				af="$1" name="$2" mask="$3" bcaddr="$4" ext1="$5" cmd2=
d715 1
a715 1
			case "$af" in
d745 1
a745 1
				case "$dt" in
d828 1
a828 1
	local _selection="$1" _parent_dir="$2" _sets="$3"
d837 2
a838 2
	case "$_selection" in
	+*)	_selection="${_selection#?}"
d840 1
a840 1
	-*)	_selection="${_selection#?}"
d908 1
a908 1
case "$1" in
d933 1
a933 1
	case "${_ftp_active}" in
d943 1
a943 1
	case "$resp" in
d953 1
a953 1
case "$resp" in
d996 1
a996 1
		path="${path}/${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}"
d1003 1
a1003 1
		eval _${_url_type}_server_ip="$resp"
d1010 1
a1010 1
	_ftp_server_dir="pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}"
d1030 1
a1030 1
	_oifs="$IFS"
d1036 1
a1036 1
		_ftp_server_login="$resp"
d1048 1
a1048 1
			_ftp_server_password="$resp"
d1054 1
a1054 1
	IFS="$_oifs"
d1061 1
a1061 1
	_url_base="ftp://${_url_login}:${_url_pass}@@${_ftp_server_ip}/${_ftp_server_dir}"
d1093 1
a1093 1
	case "$resp" in
d1100 1
a1100 1
		case "$_f" in
d1108 1
a1108 1
		case "$resp" in
d1130 1
a1130 1
_osetsdone="$_setsdone"
d1135 1
a1135 1
	case "$_f" in
d1178 1
a1178 1
case "$resp" in
d1180 1
a1180 1
*)	_setsdone="$_osetsdone"
d1253 1
a1253 1
	case "$resp" in
d1264 1
a1264 1
		case "$resp" in
d1285 1
a1285 1
_osetsdone="$_setsdone"
d1288 1
a1288 1
	case "$_f" in
d1329 1
a1329 1
case "$resp" in
d1331 1
a1331 1
*)	_setsdone="$_osetsdone"
d1400 1
a1400 1
case "$resp" in
d1443 1
a1443 1
		case "$resp" in
d1466 1
a1466 1
		case "$resp" in
d1487 1
a1487 1
_directory="${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}"
d1517 1
a1517 1
case "$resp" in
d1561 1
a1561 1
	case "$resp" in
d1584 1
a1584 1
	_md_fstype="_undefined_"
d1590 1
a1590 1
	case "$resp" in
d1593 1
a1593 1
		_fsopts="ro"
d1596 1
a1596 1
		_fsopts="async,ro"
d1652 2
a1653 2
	case "$resp" in
	y*|Y*)	_nfs_tcp="-T"
d1695 1
a1695 1
TAPE="/dev/${_tape}"
d1717 1
a1717 1
	case "$resp" in
d1749 1
a1749 1
	case "$resp" in
d1800 1
a1800 1
	case "$resp" in
d1802 1
a1802 1
		TZ="GMT"
d1813 1
a1813 1
			case "$resp" in
d1823 1
a1823 1
			TZ="$_a"
d1869 1
a1869 1
local _yup="FALSE" _have_nfs
d1887 1
a1887 1
		_yup="TRUE"
d1901 1
a1901 1
		case "$resp" in
d1934 1
a1934 1
		_yup="FALSE"
d1944 1
a1944 1
		case "$resp" in
d1965 1
a1965 1
		case "$_dev" in
d1968 1
a1968 1
		case "$_fstype" in
d1972 1
a1972 1
		case "$_opt" in
d2140 1
a2140 1
	FQDN=""
d2188 1
a2188 1
				resp="$n"
d2205 1
a2205 1
		case "$resp" in
d2224 1
a2224 1
		case "$resp" in
d2239 1
a2239 1
	case "$resp" in
@


1.194
log
@Keep all comments on separate lines so they are stripped
from scripts put on floppy images.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.193 2002/03/30 01:29:18 deraadt Exp $
a70 25
ROOTDISK=
VERSION=31
VERSION_MAJOR=$(( $VERSION / 10 ))
VERSION_MINOR=$(( $VERSION % 10 ))
export VERSION VERSION_MAJOR VERSION_MINOR

# extra "site" set can be provided by person doing install or
# upgrade. THESETS is set to ALLSETS for installs and UPGRSETS
# for upgrades.
ALLSETS="base etc misc comp man game xbase xshare xfont xserv site"
UPGRSETS="base misc comp man game xbase xshare xfont xserv site"
THESETS=

# Path searched for sets by install_sets on the local filesystems
local_sets_dir=

# decide upon an editor
if [ "X$EDITOR" = X ]; then
	EDITOR=ed
	if [ -x /usr/bin/vi ]; then
		EDITOR=vi
	fi
	export EDITOR
fi

d259 1
a259 1
	local _dir=$1 _file
d264 1
a264 1
		if [ -f $_dir/${_file}${VERSION}.tar.gz ]; then
d268 1
a268 1
		if [ -f $_dir/${_file}${VERSION}.tgz ]; then
d272 1
a272 1
		if [ $_file = "kernel" -a -f $_dir/bsd ]; then
d318 1
a318 1
		echo -n "Enter the pathname where the sets are stored [$_dir] "
d320 1
a320 1
		_dir=$resp
d325 1
a325 1
			getresp "n"
d344 1
a344 1
			getresp "y"
d361 2
a363 3
	_DKDEVS=`md_get_diskdevs`
	echo	"$_DKDEVS"
	echo
d365 2
a366 4
	getresp ""
	if [ "X${resp}" = "X" ]; then
		DISK=done
	elif [ "X${resp}" = "Xdone" ]; then
d378 7
d392 2
a394 9
	local _defdsk

	_DKDEVS=`md_get_diskdevs`
	_defdsk=`echo $_DKDEVS | cutlast`
	if [ "${_defdsk}" != "${_DKDEVS}" ]; then
		_defdsk=
	fi
	echo	"$_DKDEVS"
	echo
d396 1
a396 1
	getresp "${_defdsk}"
d401 1
a401 1
		echo "The disk $resp does not exist."
d464 1
a464 1
		echo -n	"Configure which interface? (or, enter 'done') [$_ouranswer] "
d521 1
a521 1
		echo -n "IP address${_dhcp_prompt} ? [$_if_ip] "
d545 1
a545 1
			echo -n "Netmask ? [$_if_mask] "
d923 1
a923 1
getresp "${_proxy_host}"
d942 1
a942 1
	getresp "${resp}"
d952 1
a952 1
getresp $_ftp_getlist
d1035 1
a1035 1
		getresp "${_ftp_server_login}"
d1045 1
a1045 1
			getresp -n "${_ftp_server_password}"
d1092 1
a1092 1
	getresp "y"
d1107 1
a1107 1
		getresp "y"
d1176 2
a1177 2
echo -n "connection.  Ready to download files? [y] "
getresp "y"
d1232 2
a1233 2
if [ ! -d $1 ]; then
	echo "No such directory: $1"
d1237 1
a1237 1
if dir_has_sets $1 $THESETS; then
d1240 1
a1240 1
			if [ -f $1/bsd ]; then
d1243 1
a1243 1
		elif [ -f $1/${_f}${VERSION}.tar.gz ]; then
d1245 1
a1245 1
		elif [ -f $1/${_f}${VERSION}.tgz ]; then
d1252 1
a1252 1
	getresp "y"
d1259 1
a1259 1
	_sets=`cd $1 ; echo *.tar.gz *.tgz`
d1263 1
a1263 1
		getresp "y"
d1268 1
a1268 1
		( cd $1 && ls )
d1328 1
a1328 1
getresp "y"
a1382 1
_CDDEVS=`md_get_cddevs`
d1441 1
a1441 1
		echo -n 'CD-ROM partition to mount (normally "c")? [c] '
d1465 1
a1465 1
		getresp "cd9660"
a1485 3
if [ "X${_directory}" = X"" ]; then
	_directory="/${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}"
fi
d1487 5
a1491 6
while [ "X${resp}" = X"" ]; do
	echo "Enter the directory relative to the mount point that"
	echo -n "contains the file. [${_directory}] "
	getresp "${_directory}"
done
_directory=$resp
d1493 1
a1493 1
install_from_mounted_fs /mnt2/${_directory}
d1503 13
a1515 1
local _fsopts _directory _md_fstype _md_fsopts
a1516 1
getresp "abort"
d1541 3
a1543 3
    sed -n -e '/swap/s/.*//' -e '/unused/s/.*//' \
	-e '/^  .:/{s/^  \(.\).*/\1/;H;}' \
	-e '${g;s/\n//g;s/^/[/;s/$/]/p;}'`
d1545 2
a1546 2
    sed -n -e '/^  .:/{s/^  \(.\).*/\1/;H;}' \
	-e '${g;s/\n//g;s/^/[/;s/$/]/p;}'`
d1548 1
a1548 1
    sed -n 's/^\[\(.\).*\]/\1/p'`
d1589 1
a1589 1
	getresp "default"
d1614 1
d1619 3
a1621 1
local _directory
d1623 1
a1623 18
cat << __EOT

The following disk devices are installed on your system; please select
the disk device containing the partition with the installation sets:

__EOT
_DKDEVS=`md_get_diskdevs`
echo "$_DKDEVS"
echo
echo -n	"Which is the disk with the installation sets? [abort] "

if mount_a_disk ; then
	return
fi

# Get the directory where the file lives
resp=
while [ "X${resp}" = X"" ]; do
d1625 2
a1626 4
	echo -n "contains the file. [${_directory}] "
	getresp "${_directory}"
done
_directory=$resp
d1628 2
a1629 2
install_from_mounted_fs /mnt2/${_directory}
umount -f /mnt2 > /dev/null 2>&1
d1633 7
a1639 7
# Get the IP address of the server
resp=
while [ "X${resp}" = X"" ]; do
	echo -n "Server IP address or hostname? [${_nfs_server_ip}] "
	getresp "${_nfs_server_ip}"
done
_nfs_server_ip=$resp
d1641 7
a1647 7
# Get server path to mount
resp=
while [ "X${resp}" = X"" ]; do
	echo -n "Filesystem on server to mount? [${_nfs_server_path}] "
	getresp "${_nfs_server_path}"
done
_nfs_server_path=$resp
d1649 9
a1657 9
# Determine use of TCP
echo -n "Use TCP transport (only works with capable NFS server)? [n] "
getresp "n"
case "$resp" in
y*|Y*)	_nfs_tcp="-T"
	;;
*)	_nfs_tcp=
	;;
esac
d1659 6
a1664 6
# Mount the server
mkdir /mnt2 > /dev/null 2>&1
if ! mount_nfs $_nfs_tcp ${_nfs_server_ip}:${_nfs_server_path} /mnt2 ; then
	echo "Cannot mount NFS server.  Aborting."
	return
fi
d1666 7
a1672 8
# Get the directory where the file lives
resp=
while [ "X${resp}" = X"" ]; do
	echo "Enter the directory relative to the mount point that"
	echo -n "contains the file. [${_nfs_directory}] "
	getresp "${_nfs_directory}"
done
_nfs_directory=$resp
d1674 2
a1675 2
install_from_mounted_fs /mnt2/${_nfs_directory}
umount -f /mnt2 > /dev/null 2>&1
d1692 1
a1692 1
	getresp "${_tape}"
d1716 1
a1716 1
	getresp ""
d1748 1
a1748 1
	getresp "1"
d1798 1
a1798 1
	echo -n	"What timezone are you in? [\`?' for list] [$TZ] "
d1811 2
a1812 2
			echo -n "Select a sub-timezone [\`?' for list]: "
			getresp ""
d1885 1
a1885 1
	install_from_mounted_fs ${local_sets_dir}
d1900 1
a1900 1
		getresp ""
d1943 1
a1943 1
		getresp "n"
d2204 1
a2204 1
		getresp "y"
d2223 1
a2223 1
		getresp "n"
d2238 1
a2238 1
	getresp "n"
d2251 32
@


1.193
log
@shrink 599 more bytes:  cleanups to "case" and such; ok krw
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.192 2002/03/30 00:56:10 deraadt Exp $
d755 2
a756 1
			"up")	# The only one of these guaranteed to be set is $if
d791 2
a792 1
				inet6)	# Ignore IPv6 setup
@


1.192
log
@shrink 4 more bytes
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.191 2002/03/30 00:55:32 deraadt Exp $
d89 1
a91 2
	else
		EDITOR=ed
d113 9
a121 10
				"")	resp="$1"
					;;
				!)	echo "Type 'exit' to return to install."
					sh
					continue
					;;
				!*)
					eval ${resp#?}
					continue
					;;
d178 1
a178 1
		-t?*) IFS=${1#-t}; shift;;
d196 1
a196 1
		-t?*) IFS=${1#-t}; shift;;
d233 2
a234 2
			[0-9]*) ;;
			*)	echo 0; return;;
d330 1
a330 1
	ftp ${_ftp_active} -V -n "$1"  << __EOT
d352 4
a355 6
				y*|Y*)
					break
					;;
				*)
					continue
					;;
d371 4
a374 6
				y*|Y*)
					;;
				*)
					local_sets_dir=
					break
					;;
d495 2
a496 4
		"done")
			;;
		"")
			_reprompt=0
d498 1
a498 2
		*)
			_ifs=$resp
d675 2
a676 2
			[A-Za-z0-9]*)	;;
			*)		return 1;;
d749 1
a749 2
			"dhcp")
				[ "$name" = "NONE" ] && name=
d755 1
a755 2
			"up")
				# The only one of these guaranteed to be set is $if
d759 2
a760 3
			*)
				read dt dtaddr
				if [ "$name"  = "alias" ]; then
d773 1
a773 2
				dest)
					cmd="$cmd $dtaddr"
d784 1
a784 2
				inet)
					[ "$mask" ] && cmd="$cmd netmask $mask"
d790 1
a790 2
				inet6)
					# Ignore IPv6 setup
d864 5
a868 5
		+*)	_selection="${_selection#?}"
			;;
		-*)	_selection="${_selection#?}"
			_action=remove
			;;
d880 13
a892 13
		$_selection)
			# Add/remove file to extraction list
			if [ "\$_action" = "add" ]; then
				_get_files=\`addel \${_f} \${_get_files}\`
				_setsdone=\`addel \${_f} \${_setsdone}\`
			elif [ "\$_action" = "remove" ]; then
				_get_files=\`rmel \${_f} \${_get_files}\`
				_setsdone=\`rmel \${_f} \${_setsdone}\`
			else
				echo "Unknown action: \$_action"
			fi
			_matched=\$(( \$_matched + 1 ))
			;;
d935 2
a936 2
	-ftp)	_url_type=ftp  ;;
	-http)	_url_type=http ;;
d960 2
a961 2
		-A)	resp=y ;;
		*)	resp=n ;;
d970 2
a971 2
		y*|Y*)	_ftp_active=-A ;;
		*)	unset _ftp_active ;;
d980 11
a990 11
	n*|N*)	_ftp_getlist=n
		;;
	*)
		_ftp_getlist=y
		ftphost=129.128.5.191
		if [ "X${_resolver_enabled}" = X"TRUE" ]; then
			ftphost=ftp.openbsd.org
		fi
		ftp ${_ftp_active} -V -a -o /tmp/ftplist ftp://${ftphost}/pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/ftplist > /dev/null
		cat /tmp/ftplist | grep "^${_url_type}:" | cat -n | less -XE
		;;
d1120 1
a1120 2
		n*|N*)	return ;;
		*)	;;
d1127 1
a1127 1
			*.tar.gz|*.tgz)	_sets="$_sets ${_f}"
d1135 1
a1135 2
			n*|N*)	return ;;
			*)	;;
d1162 6
a1167 6
		base*|bsd|comp*|etc*|game*|man*|misc*)
			if ! isin ${_f} ${_setsdone}; then
				_get_files=`addel ${_f} ${_get_files}`
				_setsdone=`addel ${_f} ${_setsdone}`
			fi
			;;
d1205 4
a1208 6
	y*|Y*)
		;;
	*)
		_setsdone="$_osetsdone"
		return
		;;
d1280 1
a1280 2
		n*|N*)	return ;;
		*)	;;
d1291 1
a1291 2
			n*|N*)	return ;;
			*)	;;
d1317 6
a1322 6
		base*|bsd|comp*|etc*|game*|man*|misc*)
			if ! isin ${_f} ${_setsdone}; then
				_get_files=`addel ${_f} ${_get_files}`
				_setsdone=`addel ${_f} ${_setsdone}`
			fi
			;;
d1356 4
a1359 6
	y*|Y*)
		;;
	*)
		_setsdone="$_osetsdone"
		return
		;;
d1428 8
a1435 1
	abort)
d1438 2
a1439 12
		;;

	*)
		if isin $resp $_CDDEVS ; then
			_drive=$resp
		else
			echo
			echo "The CD-ROM $resp does not exist."
			echo "Aborting."
			return
		fi
		;;
d1471 7
a1477 9
			$_range)
				_part=$resp
				;;

			*)
				echo "Invalid response: $resp"
				# force loop to repeat
				resp=
				;;
d1494 7
a1500 9
			cd9660|ffs)
				_fstype=$resp
				;;

			*)
				echo "Invalid response: $resp"
				# force loop to repeat
				resp=
				;;
d1507 1
a1507 2
if ! mount -t ${_fstype} -o ro \
    /dev/${_drive}${_part} /mnt2 ; then
d1538 8
a1545 1
	abort)
d1548 2
a1549 12
		;;

	*)
		if isin $resp $_DKDEVS ; then
			_drive=$resp
		else
			echo
			echo "The disk $resp does not exist."
			echo "Aborting."
			return 0
		fi
		;;
d1582 7
a1588 9
		$_partition_range)
			_partition=$resp
			;;

		*)
			echo "Invalid response: $resp"
			# force loop to repeat
			resp=
			;;
d1611 15
a1625 17
		default)
			_fstype=
			_fsopts="ro"
			;;
		ffs)
			_fstype="-t $resp"
			_fsopts="async,ro"
			;;
		$_md_fstype)
			_fstype="-t $resp"
			_fsopts=$_md_fsopts
			;;
		*)
			echo "Invalid response: $resp"
			# force loop to repeat
			resp=
			;;
d1647 1
a1647 1
echo    "$_DKDEVS"
d1689 4
a1692 7
	y*|Y*)
		_nfs_tcp="-T"
		;;

	*)
		_nfs_tcp=
		;;
d1697 1
a1697 2
if ! mount_nfs $_nfs_tcp ${_nfs_server_ip}:${_nfs_server_path} \
    /mnt2 ; then
d1755 6
a1760 9
		[1-9]*)
			_nskip=$(( $resp - 1 ))
			;;

		*)
			echo "Invalid file number ${resp}."
			# force loop to repeat
			resp=
			;;
d1787 1
a1787 2
	1)
		_xcmd="tar -zxvpf -"
d1789 1
a1789 3

	2)
		_xcmd="tar -xvpf -"
d1791 1
a1791 3

	*)
		echo "Invalid response: $resp."
d1838 1
a1838 2
	"")
		echo "Timezone defaults to GMT"
d1842 1
a1842 2
	"?")
		ls -F ${_zonepath}/usr/share/zoneinfo
d1844 1
a1844 2
	*)
		_a=$resp
d1851 1
a1851 1
			"?") ls -F ${_zonepath}/usr/share/zoneinfo/$_a ;;
d1939 1
a1939 2
		d*|D*)
			install_disk
d1942 1
a1942 2
		f*|F*)
			test -n "$_didnet" || donetconfig
d1946 1
a1946 2
		h*|H*)
			test -n "$_didnet" || donetconfig
d1950 1
a1950 2
		t*|T*)
			install_tape
d1953 1
a1953 2
		c*|C*)
			install_cdrom
d1956 1
a1956 2
		n*|N*)
			test -n "$_didnet" || donetconfig
d1965 1
a1965 2
		*)
			echo "Invalid response: $resp"
d1982 1
a1982 2
		y*|Y*)
			# Force loop to repeat
a1984 3

		*)
			;;
d2003 1
a2003 2
			\#*)	continue;;
			*)	;;
d2006 2
a2007 2
			ffs)	;;
			*)	continue;;
d2010 2
a2011 2
			*noauto*)    continue;;
			*)	;;
d2243 2
a2244 7
			y*|Y*)
				cp /tmp/resolv.conf \
					/tmp/resolv.conf.shadow
				;;

			*)
				;;
d2262 2
a2263 6
			y*|Y*)
				${EDITOR} /tmp/hosts
				;;

			*)
				;;
d2277 3
a2279 7
		y*|Y*)
			echo "Type 'exit' to return to install."
			sh
			;;

		*)
			;;
@


1.191
log
@remove extra spaces
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.190 2002/03/30 00:50:57 krw Exp $
d2087 1
a2087 1
	    done > /etc/fstab
@


1.190
log
@Squeeze a few bytes out of the installation scripts by using
standard __EOT as here document delimiter.

Remove unnecessary escaping of __EOT.

Could be/Should be extended to .md scripts and other non-miniroot
architectures.

Concept approved a *long* time ago by deraadt@@ and millert@@ but
never got out of my tree.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.189 2002/03/26 01:50:08 krw Exp $
d935 1
a935 1
    
@


1.189
log
@Cleanup (and shrink) ftp_list_files() in install.sub by removing
some unneeded intermediate local variables and just using the
parameters.

Make upgrade fsck output for root partition consistant with later
fsck output for other partitions.

ok deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.188 2002/03/22 23:29:28 deraadt Exp $
d332 1
a332 1
	ftp ${_ftp_active} -V -n "$1"  << __ptf
d337 1
a337 1
__ptf
d893 1
a893 1
	cat >$_tfile << OOF
d909 1
a909 1
OOF
d2323 1
a2323 1
	cat << __hosts_table_1
d2328 1
a2328 1
__hosts_table_1
d2341 1
a2341 1
	cat << \__network_config_2
d2347 1
a2347 1
__network_config_2
@


1.188
log
@move to 3.1-beta
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.187 2002/03/22 01:41:54 krw Exp $
a330 1
	local _host=$1 _user="$2" _pass="$3" _dir=$4
d332 3
a334 5
	shift; shift; shift; shift

	ftp ${_ftp_active} -V -n $_host  << __ptf
user "$_user" "$_pass"
cd $_dir
@


1.187
log
@Clean up getresp() by

1) Deleting code for '-s' option, which was never used.

2) Deleting code for >1 parameters after optional '-n'.
   Also never used.

@@ok millert
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.186 2002/03/04 13:59:52 krw Exp $
d72 1
a72 1
VERSION=30
@


1.186
log
@Update Copyright(c)'s to 2002
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.185 2002/03/04 13:54:28 krw Exp $
a96 2
# Please don't use the 1 of n form below, good idea, wrong implementation!
# get a reponse with default[s]
a97 1
	local _shell_aware=0
a99 5
	# -s option means exit after a shell (caller is shell-aware)
	if [ "$1" = "-s" ]; then
		_shell_aware=1
		shift
	fi
d107 2
a108 2
	valid="false"
	while [ "X$valid" = "Xfalse" ]; do
d118 1
a118 1
					test $_shell_aware -eq 0 && continue
d122 1
a122 1
					test $_shell_aware -eq 0 && continue
d126 1
a126 12
		if [ $# -gt 1 ]; then
			for i in $@@; do
				if [ "X$resp" = "X$i" ]; then
					valid="true"
				fi
			done
		else
			valid="true"
		fi
		if [ "X$valid" = "Xfalse" ]; then
			echo "Try again: Enter one of [$@@]"
		fi
@


1.185
log
@Change the default install sets to include everything but the X sets.
This should cut down on the inquires on @@misc/@@tech about missing
compilers, etc. In the days of 180GB disks we should not run out of
space too often.

Clean up some logic, removing references to -reuse and -minpat
arguments in install_url(), as install_url() is only called with -http
or -ftp.

Simplify selector setup by noting that $_sets is carefully initialized
to hold only file names ending in .tgz or .tar.gz.

@@ok millert
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.184 2002/03/03 00:43:37 krw Exp $
d5 1
a5 1
# Copyright (c) 1997,1998 Todd Miller, Theo de Raadt
@


1.184
log
@Cleanup/Improve trap handling.

a) Add /var/run to the filesystem created when the installation media
   boots. This allows the creation and use of the dhclient.pid file.
   Synchronize all mtree.conf files in architectures using miniroot.

b) Rework the traps used in upgrade.sh and install.sh so that HUP,
   INT, QUIT, TERM and EXIT all invoke a cleanup function that kills an
   active dhclient, unmounts all filesystems and fsck's -p all devices
   in /etc/fstab, or just /mnt if /etc/fstab is not present.

c) Make sure the actions of the cleanup function are visible, thus
   eliminating the long delay with no feedback at the end of the
   upgrade/install script, after the congratulatory message.

d) Reduce manual parsing of fstab files by using umount -a to
   unmount all mounted filesystems.

e) Since the new cleanup function tries to unmount all filesystems,
   use the presence of /etc/fstab, rather than a difference between
   `df /` and `df /mnt`, to determine if an install is being restarted
   in a state where disk initialization can be skipped.

f) Change munge_fs, check_fs, mount_fs, remount_fs so that they
   all 'know' about /etc/fstab rather than passing the same
   parameter in all the time.

g) Use input redirection on munge_fs to read correct file, rather
   than passing a file name as a parameter.

h) Indent code for various smaller functions.

i) Eliminate some subshell usage to simplify code further.

j) Display pretty messages during fsck -p to clearly indicate success
   or failure of fsck, rather than just dumping fsck output.

k) Always run mount_fs in install.sh, even if disk initialization is
   being skipped, because the trap should have unmounted all filesystems
   when the last run terminated.

ok weingart@@ millert@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.183 2002/01/24 23:01:18 millert Exp $
d968 1
a968 1
local _url_type _url_base _url_login _url_pass _reuse _minpat _oifs
d971 4
a974 12
while test $# != 0; do
	case "$1" in
		-ftp) _url_type=ftp ;;
		-http) _url_type=http ;;
		-reuse) _reuse=1 ;;
		-minpat) shift; _minpat="$1" ;;
	esac
	shift
done
if [ X"${_minpat}" = X ]; then
	_minpat='base*.tar.gz|base*.tgz|man*.tar.gz|man*.tgz|etc*.tar.gz|etc*.tgz|bsd'
fi
d981 29
a1009 11
# Reuse old values w/o prompting for anything?
if [ X"$_reuse" = X"1" ]; then
	_reuse=
	if eval test X"\$_installed_via_${_url_type}" = X"1"; then
		echo -n "Use values from previous ${_url_type} install? [y] "
		getresp y
		case "$resp" in
			y*|Y*)
				_reuse=1;;
		esac
	fi
a1010 31
if [ X"$_reuse" = X ]; then
	# Proxy the connections?
	if [ "X${_proxy_host}" = X"" ]; then
		_proxy_host=none
	fi
	echo -n "HTTP/FTP proxy URL? (e.g. \"http://proxy:8080\", or \"none\") [${_proxy_host}] "
	getresp "${_proxy_host}"
	if [ "X${resp}" = X"none" ]; then
		unset _proxy_host ftp_proxy http_proxy
	else
		_proxy_host=$resp
		export ftp_proxy=${_proxy_host}
		export http_proxy=${_proxy_host}
	fi
	if [ "${_url_type}" = "ftp" -a "X$ftp_proxy" = "X" ]; then
		# Use active mode ftp? (irrelevant if using a proxy)
		case "${_ftp_active}" in
			-A)	resp=y ;;
			*)	resp=n ;;
		esac
		echo "By default, ftp will attempt a passive connection and fall back to a normal"
		echo "(active) connection if that doesn't work.  However, there are some very"
		echo "old ftp servers that claim to support passive mode, but really do not."
		echo "In this case, you should explicitly request an active session."
		echo -n "Do you want to use active ftp? [${resp}] "
		getresp "${resp}"
		case "$resp" in
			y*|Y*)	_ftp_active=-A ;;
			*)	unset _ftp_active ;;
		esac
	fi
d1012 5
a1016 5
	# Provide a list of possible servers
	test -z "$_ftp_getlist" && _ftp_getlist=y
	echo -n "Do you want a list of potential ${_url_type} servers? [${_ftp_getlist}] "
	getresp $_ftp_getlist
	case "$resp" in
d1028 1
a1028 1
	esac
d1030 21
a1050 11
	# Get server IP address
	resp=
	while [ "X${resp}" = X"" ]; do
		if [ -f /tmp/ftplist ]; then
			eval echo -n "Server IP address, hostname, or list#? [\$_${_url_type}_server_ip]\ "
		else
			eval echo -n "Server IP address, or hostname? [\$_${_url_type}_server_ip]\ "
		fi
		eval getresp "\$_${_url_type}_server_ip"
		if [ "X$resp" = "X?" -a -f /tmp/ftplist ]; then
			cat /tmp/ftplist | grep "^${_url_type}:" | cat -n | less -XE
d1052 1
a1052 25
		elif [ -n "$resp" \
			-a `isnumeric $resp` -eq 1 \
			-a ${resp:-0} -ge 1 \
			-a -f /tmp/ftplist ]
			then
			maxlines=`grep "^${_url_type}:" /tmp/ftplist | cat -n |
				sed -n -e '$p' | cutword 1`
			if [ $maxlines -lt $resp ]; then
				echo "There is no ${resp}th line in the list."
				resp=
				continue
			fi
			tline=`grep "^${_url_type}:" /tmp/ftplist | sed -n -e "${resp}p"`
			url=`echo $tline | sed -e "s/^${_url_type}:\/\///" |
				cutword -t' ' 1 | cutword -t' ' 1`
			host=`echo $url | cutword -t/ 1`
			path=`echo $url | sed -e "s/^${host}\///"`
			path="${path}/${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}"
			eval _${_url_type}_server_ip=$host
			eval _${_url_type}_server_dir=$path
			# do it again, just to double check
			resp=
			echo "Using	$tline"
		else
			eval _${_url_type}_server_ip="$resp"
d1054 27
a1080 1
	done
d1082 4
a1085 4
	# Get server directory
	if [ "${_url_type}" = "ftp" -a "X${_ftp_server_dir}" = X"" ]; then
		# Default ftp dir
		_ftp_server_dir="pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}"
d1087 8
d1097 3
a1099 3
		eval echo -n "Server directory? [\$_${_url_type}_server_dir]\ "
		eval getresp "\$_${_url_type}_server_dir"
		eval _${_url_type}_server_dir=$resp
d1102 2
a1103 13
	if [ "${_url_type}" = "ftp" ]; then
		# Need default values even if we proxy ftp...
		if [ "X${_ftp_server_login}" = X"" ]; then
			_ftp_server_login=anonymous
		fi
		if [ "X${_ftp_server_password}" = X"" ]; then
			_ftp_server_password=root@@`hostname`.${FQDN}
		fi

		# Get login name, setting IFS to nothing so trailing or
		# embedded blanks are preserved!
		_oifs="$IFS"
		IFS=
d1106 6
a1111 3
			echo -n "Login? [${_ftp_server_login}] "
			getresp "${_ftp_server_login}"
			_ftp_server_login="$resp"
d1113 3
a1115 17

		# Get password unless anonymous
		if [ "${_ftp_server_login}" != "anonymous" ]; then
			resp=
			while [ "X${resp}" = X"" ]; do
				echo -n "Password (will not echo): "
				stty -echo
				getresp -n "${_ftp_server_password}"
				stty echo
				echo
				_ftp_server_password="$resp"
			done
		else
			# only used by ftp_list_files()
			_ftp_server_password=root@@`hostname`.${FQDN}
		fi
		IFS="$_oifs"
d1117 1
d1198 10
a1207 7
	eval "case $_f in \
		${_minpat}) \
			if ! isin \${_f} \${_setsdone}; then \
				_get_files=\`addel \${_f} \${_get_files}\` ; \
				_setsdone=\`addel \${_f} \${_setsdone}\` ; \
			fi ;; \
	esac"
d1358 3
a1360 1
		base*.tar.gz|base*.tgz|man*.tar.gz|man*.tgz|etc*.tar.gz|etc*.tgz|bsd)
@


1.183
log
@Fix `necesary' typos; Alexander Yurchenko

Alas many of these were introduced by yours truly as necessary
just doesn't look right to me for some reason ;-)
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.182 2001/12/23 16:54:04 krw Exp $
d2097 2
a2098 1
local _fstab _fstab_shadow _dev _mp _fstype _dev _options
d2100 27
a2126 26
# Create a 'shadow' fstab to use for mounting and unmounting all
# of the target filesystems relative to /mnt.
_fstab=$1
_fstab_shadow=$2
( while read _dev _mp _fstype _options _rest; do
	# Skip comment lines, non-ffs filesystems and
	# 'noauto' filesystems.
	case "$_dev" in
		\#*)	continue;;
		*)	;;
	esac
	case "$_fstype" in
		ffs)	;;
		*)	continue;;
	esac
	case "$_options" in
		*noauto*)    continue;;
		*)	;;
	esac
	# Don't use soft updates
	_options="$(echo ${_options} | sed 's/,softdep,/,/; s/,softdep//; s/softdep,//')"
	if [ "$_mp" = "/" ]; then
		_mp=""
	fi
	echo $_dev /mnt$_mp $_fstype $_options $_rest
    done ) < $_fstab > $_fstab_shadow
d2130 15
a2144 27
# Must mount filesystems manually, one at a time, so we can make
# sure the mount points exist.
# $1 is a file in fstab format
local _fstab=$1
local _async=$2

( while read line; do
	set -- $line
	_dev=$1
	_mp=$2
	_fstype=$3
	_opt=$4

	# If not the root filesystem, make sure the mount
	# point is present.
	if [ "X{$_mp}" != X"/mnt" ]; then
		mkdir -p $_mp
	fi

	# Mount the filesystem.  If the mount fails, exit
	# with an error condition to tell the outer
	# later to bail.
	if ! mount -v -t $_fstype $_async -o $_opt $_dev $_mp ; then
		# error message displayed by mount
		exit 1
	fi
done ) < $_fstab
d2146 2
a2147 2
if [ "X${?}" != X"0" ]; then
	cat << __EOT
a2148 2
FATAL ERROR:  Cannot mount filesystems.  Double-check your configuration
and restart the installation process.
d2150 3
a2152 2
	exit
fi
d2155 5
a2159 4
unmount_fs() {
	# Unmount all filesystems and check their integrity.
	# Usage: [-check] <fstab file>
	local _check _fstab _pid _devs=	_mps=
d2161 9
a2169 6
	if [ "$1" = "-check" ]; then
		_check=1
		_fstab=$2
	else
		_check=0
		_fstab=$1
d2172 5
a2176 3
	if [ ! \( -f $_fstab -a -s $_fstab \) ]; then
		echo "fstab empty" > /dev/tty
		return
d2179 1
a2179 22
	# maintain reverse order
	while read line; do
		set -- $line
		_devs="$1 ${_devs}"
		_mps="$2 ${_mps}"
	done < $_fstab

	echo -n "Unmounting filesystems... "
	for _mp in ${_mps}; do
		echo -n "${_mp} "
		umount ${_mp}
	done
	echo "... Done."

	if [ $_check = 1 ]; then
		echo "Checking filesystem integrity..."
		for _dev in ${_devs}; do
			echo  "${_dev}"
			fsck -f ${_dev}
		done
		echo "... Done."
	fi
d2183 11
a2193 12
( while read line; do
	set -- $line
	_dev=$1
	_mp=$2
	_fstype=$3
	_opt=$4

	if ! mount -u -o $_opt $_dev $_mp ; then
		# error message displayed by mount
		exit 1
	fi
done ) < $1
d2197 14
a2210 15
	# Check filesystem integrity.
	# $1 is a file in fstab format
	local _fstab=$1 _devs= _dev

	while read line; do
		set -- $line
		_devs="$1 ${_devs}"
	done < $_fstab

	echo "Checking filesystem integrity..."
	for _dev in ${_devs}; do
		echo  "${_dev}"
		fsck -f ${_dev}
	done
	echo "Done."
@


1.182
log
@Some minor typographical adjustments:

a) Indent encode_for_url() in install.sub with tabs not spaces
b) delete a couple of extra blank lines
c) delete a few unnecessary ';'s at the end of lines
d) delete a few unnecessary '"'s around values assigned to resp (e.g.
   'resp="X"' to 'resp=X'
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.181 2001/12/22 18:53:45 krw Exp $
d1207 1
a1207 1
# Yes, all those blackslashes really are necesary...
@


1.181
log
@Enable users to fix filesystem problems encountered by fsck in
check_fs() and unmount_fs() by restricting i/o redirection to the
reading of fstab.

Fix a typo ('succes' -> 'success').

Indent lines inside check_fs() and unmount_fs() functions.

Eliminate an unused variable _mps in check_fs().

ok millert@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.180 2001/12/17 00:41:50 krw Exp $
d442 1
a442 1
	local _defdsk;
a864 1

d948 11
a958 11
    # Encode $1 as specified for usercodes and passwords in RFC 1738
    # section 3.1, and now supported by our in-tree ftp:
    #
    #    ':' -> '%3a'
    #    '@@' -> '%40'
    #    '/' -> '%2f'
    #
    # *NOTE* quotes around $1 are required to preserve trailing or
    # embeddded blanks in usercodes and passwords!

    echo "$1" | sed -e 's/:/%3a/g' -e 's/@@/%40/g' -e 's/\//%2f/g'
d1930 1
a1930 1
		break;
d1946 1
a1946 1
					break;
d1984 1
a1984 1
		return 0;
d2337 1
a2337 1
				resp="none";
d2350 1
a2350 1
	resp="none"
@


1.180
log
@Use actual files for short versions of /etc/protocols and
/etc/services used during installations.

This way it is not necessary to run the install script before
using commands requiring these files.

Requested by deraadt@@.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.179 2001/12/13 01:40:15 krw Exp $
d151 1
a151 1
# test the first argument against the remaining ones, return succes on a match
d2168 11
a2178 11
# Unmount all filesystems and check their integrity.
# Usage: [-check] <fstab file>
local _check _fstab _pid

if [ "$1" = "-check" ]; then
	_check=1
	_fstab=$2
else
	_check=0
	_fstab=$1
fi
d2180 4
a2183 4
if [ ! \( -f $_fstab -a -s $_fstab \) ]; then
	echo "fstab empty" > /dev/tty
	return
fi
a2184 3
(
	_devs=
	_mps=
d2190 2
a2191 1
	done
a2206 1
) < $_fstab
d2225 3
a2227 3
# Check filesystem integrity.
# $1 is a file in fstab format
local _fstab=$1
a2228 3
(
	_devs=
	_mps=
d2232 1
a2232 2
		_mps="$2 ${_mps}"
	done
a2239 1
) < $_fstab
@


1.179
log
@Remove /etc/protocols and /etc/services from install media
that use the miniroot install scripts.

During an install, donetconfig() in miniroot/install.sub now
creates a minimal /etc/protocols and /etc/services.

During an upgrade, enable_network() now copies the existing
protocols and services files into /etc.

Saves approximately 13K on floppy/cd images.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.178 2001/11/25 21:43:08 krw Exp $
a2293 20

	# Create minimal protocols and services for use during install
	cat > /etc/protocols <<EOF
ip	0	IP
icmp	1	ICMP
tcp	6	TCP
udp	17	UDP
EOF

	cat > /etc/services <<EOF
ftp-data	20/tcp
ftp		21/tcp
domain		53/tcp		nameserver
domain		53/udp		nameserver
www		80/tcp		http
www		80/udp
nfsd		2049/udp	nfs
nfsd		2049/tcp	nfs
shell		514/tcp		cmd
EOF
@


1.178
log
@Squeeze all obvious <blank>+<tab> and <tab><blank>+ combinations
out. Save about 287 bytes. Based on diff from deraadt@@.

Update Copyright (ok deraadt@@).
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.177 2001/11/24 14:27:42 krw Exp $
d725 1
a725 1
	for _netfile in hosts myname dhclient.conf resolv.conf resolv.conf.tail; do
d2294 20
@


1.177
log
@Fix bsort() so that trailing spaces are not emitted.

When a system is rebooted rather than power cycled it is possible
for duplicate entries for a disk or cd to appear in the dmesg
output. One from the previous boot and one from the current
reboot.

bsort() correctly filtered out the duplicates, but could emit a
trailing space.

This trailing space caused problems when, for instance, the root
disk was being determined. With the trailing space present, the
install or upgrade script would not fill in the default root disk,
even if the system only had one disk.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.176 2001/11/22 00:56:13 krw Exp $
d298 2
a299 2
	    echo -n " "
	    bsort $_l
d367 17
a383 17
	    echo -n "Enter the pathname where the sets are stored [$_dir] "
	    getresp "$_dir"
	    _dir=$resp

	    # Allow break-out with empty response
	    if [ -z "$_dir" ]; then
		echo -n "Are you sure you don't want to set the pathname? [n] "
		getresp "n"
		case "$resp" in
			y*|Y*)
				break
				;;
			*)
				continue
				;;
		esac
	    fi
d385 6
a390 6
	    if dir_has_sets "$_mp/$_dir" $THESETS
	    then
		local_sets_dir="$_mp/$_dir"
		break
	    else
		cat << __EOT
d394 11
a404 11
		echo -n "Re-enter pathname? [y] "
		getresp "y"
		case "$resp" in
			y*|Y*)
				;;
			*)
				local_sets_dir=
				break
				;;
		esac
	    fi
d639 1
a639 1
       domain-name, domain-name-servers, host-name;
d660 1
a660 1
       domain-name, domain-name-servers, host-name;
d690 3
a692 2
		    ${_if_ip} \
		    netmask ${_if_mask} ${_if_extra} up ; then
d746 2
a747 2
    		# Strip off /mnt/etc/hostname. prefix
    		if=${hn#/mnt/etc/hostname.}
d749 3
a751 3
    		# Interface names must be alphanumeric only.  We check to avoid
    		# configuring backup or temp files, and to catch the "*" case.
    		if ! isalphanumeric "$if"; then
d753 3
a755 3
    		fi
    		ifconfig $if > /dev/null 2>&1
    		if [ "$?" != "0" ]; then
d757 1
a757 1
    		fi
d759 2
a760 2
    		# Now parse the hostname.* file
    		while :; do
d762 6
a767 6
	    			# we are carrying over from the 'read dt dtaddr' last time
	    			set -- $cmd2
	    			af="$1" name="$2" mask="$3" bcaddr="$4" ext1="$5" cmd2=
	    			# make sure and get any remaining args in ext2, like the read below
	    			i=1; while [ i -lt 6 -a -n "$1" ]; do shift; let i=i+1; done
	    			ext2="$@@"
d769 2
a770 2
	    			# read the next line or exit the while loop
	    			read af name mask bcaddr ext1 ext2 || break
d778 2
a779 2
	    			continue
	    			;;
d781 6
a786 6
	   			[ "$name" = "NONE" ] && name=
	    			[ "$mask" = "NONE" ] && mask=
	    			[ "$bcaddr" = "NONE" ] && bcaddr=
	    			ifconfig $if $name $mask $bcaddr $ext1 $ext2 down
	    			cmd="dhclient $if"
	    			;;
d788 4
a791 4
	   			# The only one of these guaranteed to be set is $if
	    			# the remaining ones exist so that media controls work
	    			cmd="ifconfig $if $name $mask $bcaddr $ext1 $ext2 up"
	    			;;
d793 2
a794 2
	    			read dt dtaddr
	    			if [ "$name"  = "alias" ]; then
d802 1
a802 1
	    			else
d804 4
a807 4
	    			fi
	    			cmd="ifconfig $if $af $alias $name "
	    			case "$dt" in
	    			dest)
d810 1
a810 1
	    			[a-z!]*)
d813 3
a815 3
	    			esac
	    			if [ ! -n "$name" ]; then
		    			echo "/mnt/etc/hostname.$if: invalid network configuration file"
d817 3
a819 3
	    			fi
	    			case $af in
	    			inet)
d822 1
a822 1
		   			 	cmd="$cmd broadcast $bcaddr"
d826 1
a826 1
	    			inet6)
d830 4
a833 4
	    			*)      cmd="$cmd $mask $bcaddr"
	    			esac
	    			cmd="$cmd $ext1 $ext2$rtcmd" rtcmd=
	    			;;
d836 1
a836 1
    		done < /mnt/etc/hostname.$if
d878 1
a878 1
			    _next=$_f
d1064 5
a1068 2
		elif [ -n "$resp" -a `isnumeric $resp` -eq 1 -a ${resp:-0} -ge 1 \
		    -a -f /tmp/ftplist ]; then
d1070 1
a1070 1
			    sed -n -e '$p' | cutword 1`
d1078 1
a1078 1
			    cutword -t' ' 1 | cutword -t' ' 1`
d1188 1
a1188 1
		    *.tar.gz|*.tgz)	_sets="$_sets ${_f}"
d1645 1
a1645 1
	    sed -n 's/^\[\(.\).*\]/\1/p'`
d2106 1
a2106 1
        # 'noauto' filesystems.
d2117 1
a2117 1
		*)      ;;
d2120 1
a2120 1
        _options="$(echo ${_options} | sed 's/,softdep,/,/; s/,softdep//; s/softdep,//')"
d2122 1
a2122 1
	        _mp=""
d2339 2
a2340 2
	    grep '^default' |
	    sed -e 's/^default          //' -e 's/ .*//'`
d2363 2
a2364 1
		    sed -e 's/^nameserver //'`; do
d2386 1
a2386 1
				    /tmp/resolv.conf.shadow
@


1.176
log
@Fix getresp() so that imbedded or trailing blanks in the
default response ($1) are preserved in $resp.

Fix handling of _ftp_server_login, _ftp_server_password and
_url_base so any blanks present are preserved.

Problem with blanks pointed out by drahn@@.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.175 2001/11/20 01:02:49 krw Exp $
d291 10
a300 1
	echo -n "$_a "; bsort $_l
@


1.175
log
@Encode usercode/password in ftp url's as required by RFC 1738,
section 3.1. Allows for use of '@@', ':' and '/' in usercodes
and passwords without confusion.

ok deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.174 2001/11/19 01:09:43 deraadt Exp $
d119 1
a119 1
			test -z "$resp" && resp=$1
d122 1
a122 1
				"")	resp=$1
d341 1
a341 1
	local _host=$1 _user=$2 _pass=$3 _dir=$4
d346 1
a346 1
user $_user $_pass
d945 3
d949 1
a949 1
    echo $1 | sed -e 's/:/%3a/g' -e 's/@@/%40/g' -e 's/\//%2f/g'
d959 1
a959 1
local _url_type _url_base _url_login _url_pass _reuse _minpat
d1100 4
a1103 1
		# Get login name
d1108 1
a1108 1
			_ftp_server_login=$resp
d1112 1
a1112 1
		if [ ${_ftp_server_login} != "anonymous" ]; then
d1120 1
a1120 1
				_ftp_server_password=$resp
d1126 1
d1132 3
a1134 3
	_url_login=`encode_for_url ${_ftp_server_login}`
	_url_pass=`encode_for_url ${_ftp_server_password}`
	_url_base=ftp://${_url_login}:${_url_pass}@@${_ftp_server_ip}/${_ftp_server_dir}
d1146 1
a1146 1
	_file_list=`ftp -o - -V ${_url_base}/index.txt | sed 's///'`
d1266 1
a1266 1
			( cd /mnt ; ftp ${_ftp_active} -V -m ${_url_base}/${_f} )
d1268 1
a1268 1
			( cd /mnt ; ftp ${_ftp_active} -o - -V -m ${_url_base}/${_f} | tar zxpf - )
@


1.174
log
@remove 6 spaces or tabs at end of line, making this file 6 bytes smaller.  eat your heart out krw
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.173 2001/11/18 22:48:58 krw Exp $
d938 11
d956 1
a956 1
local _url_type _url_base _reuse _minpat
d1125 3
a1127 1
	_url_base=ftp://${_ftp_server_login}:${_ftp_server_password}@@${_ftp_server_ip}/${_ftp_server_dir}
@


1.173
log
@Purge more (last?) comments from install scripts by removing all
comments that, being on the end of code lines, cannot be stripped
automatically.

Just delete unhelpful ones, and move the rest onto separate lines
where they can be stripped.

Also remove a duplicated initialization of ROOTDISK.

In total, reduces script size on floppy by 1117 bytes, making room
for coming improvements.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.172 2001/11/17 20:23:23 krw Exp $
d146 1
a146 1
	done	
d842 1
a842 1
 
d1874 1
a1874 1
	
d2287 1
a2287 1
 
d2290 1
a2290 1
	# As dhclient will populate /etc/resolv.conf, a symbolic link to 
d2360 1
a2360 1
	if [ ! -f /tmp/resolv.conf.shadow ]; then 
@


1.172
log
@Improve/enhance network handling during installations.

a) Allow user to enter empty FQDN and assume DHCP will supply one.
b) Silently check for any DHCP supplied FQDN after network
   interfaces are initialized. *NOTE* DHCP information will
   now override any user supplied FQDN.
c) Apply FQDN information to hosts file only after DHCP has had a
   chance to supply information.
d) Don't modify hosts file if FQDN is empty.
e) Don't preserve hosts file across install script restarts.
f) Don't preserve hostname.* files across install script restarts.
g) Don't preserve decision to use resolver during install across
   install script restarts.
h) Don't allow DHCP to force use of resolver during install.
i) Ensure DHCP created resolv.conf file is saved as /etc/resolv.conf.
j) Add IPv6 localhost ('::1') line to hosts file. (Closes PR#2155)
k) Make IPv4 and IPv6 localhost lines in hosts file look like
   'X localhost.domain.name localhost'

Bonus: install.sub on the floppy image is 51 bytes smaller.

ok millert@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.171 2001/10/31 01:33:24 krw Exp $
d71 1
a71 1
ROOTDISK=				# filled in below
d77 6
a82 7
# extra "site" set can be provided by person doing install
ALLSETS="base etc misc comp man game xbase xshare xfont xserv site"	# install
UPGRSETS="base misc comp man game xbase xshare xfont xserv site"	# upgrade
SNAPSETS="bin dev etc games man misc sbin \
	  usr.bin usr.binutils usr.games usr.include \
	  usr.lib usr.libexec usr.misc usr.sbin usr.share var"
THESETS=					# one of the above
d487 2
a488 1
	resp=		# force at least one iteration
d569 1
a569 1
	resp=		# force one iteration
d581 1
a581 1
	resp=		# force one iteration
d904 2
a905 1
	_tfile=/tmp/install_case.$$	# safe in single user mode
d908 2
a909 1
		$_selection)	# Add/remove file to extraction list
d1029 1
a1029 1
	resp=		# force one iteration
d1057 2
a1058 1
			resp=		# do it again, just to double check
d1070 1
a1070 1
	resp=		# force one iteration
d1087 1
a1087 1
		resp=		# force one iteration
d1096 1
a1096 1
			resp=		# force one iteration
d1499 1
a1499 1
	resp=		# force one iteration
d1510 2
a1511 1
				resp=		# force loop to repeat
d1524 1
a1524 1
	resp=		# force one iteration
d1535 2
a1536 1
				resp=		# force loop to repeat
d1554 1
a1554 1
resp=		# force one iteration
d1618 1
a1618 1
resp=		# force one iteration
d1629 2
a1630 1
			resp=		# force loop to repeat
d1649 1
a1649 1
resp=		# force one iteration
d1668 2
a1669 1
			resp=		# force loop to repeat
d1701 1
a1701 1
resp=		# force one iteration
d1715 1
a1715 1
resp=		# force one iteration
d1723 1
a1723 1
resp=		# force one iteration
d1752 1
a1752 1
resp=		# force one iteration
d1775 1
a1775 1
resp=		# force one iteration
d1799 1
a1799 1
resp=		# force one iteration
d1810 2
a1811 1
			resp=		# force loop to repeat
d1834 1
a1834 1
resp=		# force one iteration
d1849 2
a1850 1
		resp=		# force loop to repeat
d1989 1
a1989 1
resp=		# force at least one iteration
d2037 2
a2038 1
		_yup="FALSE"	# So we'll ask next time
d2248 1
a2248 1
	resp=		# force at least one iteration
d2253 2
@


1.171
log
@Fix creation of /etc/hosts file in install.

Obtaining the FQDN *after* calling configurenetwork(), so that
DHCP info can be used, turns out to not be a good idea because
/etc/hosts is created in configurenetwork().

As a result the /etc/hosts created by the 3.0 install script
contains bogus entries with a '.' instead of '.<domain name>'.

So, put configurenetwork() back where it was pre-3.0, i.e. after
FQDN is determined.

Noticed by David Krause (PR#2155).

Other /etc/hosts issues (including David's ipv6 suggestion) under
investigation.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.170 2001/10/15 22:58:59 krw Exp $
d458 2
a459 6
	# Create an entry in the hosts table.  If no host table
	# exists, create one.  If the symbolic name already exists,
	# replace its entry.
	if [ ! -f /tmp/hosts ]; then
		echo "127.0.0.1 localhost" > /tmp/hosts
	fi
d461 1
a461 1
	sed "/ $2.$FQDN $2\$/d" < /tmp/hosts > /tmp/hosts.new
d464 1
a464 1
	echo "$1 $2.$FQDN $2" >> /tmp/hosts
d484 1
a484 1
configurenetwork() {
d2208 3
d2221 9
a2229 2
	resp=		# force at least one iteration
	while [ "X${resp}" = X"" ]; do
d2232 2
a2233 3
	done

	FQDN=$resp
d2250 17
d2268 3
a2270 3
	echo "If you have any devices being configured by a DHCP server"
	echo "it is recommended that you do not enter a default route or"
	echo "any name servers."
d2273 10
a2282 1
	# Get FQDN before creation of hosts file entries in addhostent()
d2284 1
a2284 4
		get_fqdn /tmp/resolv.conf.shadow
	else
		# If install is being re-run, save a few keystrokes
		get_fqdn /tmp/resolv.conf
d2287 5
a2291 1
	configurenetwork
d2315 1
a2315 11
	if [ -f /etc/resolv.conf ]; then
		resp=
		for n in `grep '^nameserver ' /etc/resolv.conf | \
		    sed -e 's/^nameserver //'`; do
			if [ "X${resp}" = "X" ]; then
				resp="$n"
			else
				resp="$resp $n"
			fi
		done
	elif [ -f /tmp/resolv.conf ]; then
@


1.170
log
@Resync the upgrade script's enable_network() function with the
current /etc/netstart, leaving out all code relevant to IPv6 and
multicasting.

In addition, ignore any '!' lines in hostname.if files and ignore
any bridge.if files.

This change enables dhcp configured interfaces to work during the
upgrade process, amoung other improvements.

Also rework FQDN handling to ensure that it is set *after* any
dhcp activity and is set both during installs and upgrades. FQDN
is now set from the last DOMAIN or SEARCH statement in
resolv.conf.

Architecture specific install.sub's (macppc, mvme68k, mvme88k,
mvmeppc, sparc64) are not being updated for 3.0.

ok deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.169 2001/09/19 00:04:02 krw Exp $
d2251 1
a2251 3
	configurenetwork

	# Get FQDN after possible DHCP invocation
d2258 2
@


1.169
log
@Fix typo: succesfully -> successfully
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.168 2001/09/11 13:11:18 deraadt Exp $
a542 1

d694 14
d710 16
a725 6
	# Set up the hostname.
	if [ ! -f /mnt/etc/myname ]; then
		echo "ERROR: no /etc/myname!"
		return 1
	fi
	hostname=`cat /mnt/etc/myname`
a729 33
	# configure all the interfaces which we know about.
(
	tmp="$IFS"
	IFS="$IFS."
	set -- `echo /mnt/etc/hostname*`
	IFS=$tmp
	unset tmp

	while [ $# -ge 2 ] ; do
		shift		# get rid of "hostname"
		(
			read af name mask bcaddr extras
			read dt dtaddr

			if [ ! -n "$name" ]; then
				echo "/etc/hostname.$1: invalid network configuration file"
				exit
			fi

			cmd="ifconfig $1 $af $name "
			if [ "${dt}" = "dest" ]; then cmd="$cmd $dtaddr"; fi
			if [ -n "$mask" ]; then cmd="$cmd netmask $mask"; fi
			if [ -n "$bcaddr" -a "X$bcaddr" != "XNONE" ]; then
				cmd="$cmd broadcast $bcaddr";
			fi
			cmd="$cmd $extras"

			$cmd
		) < /mnt/etc/hostname.$1
		shift
	done
)

d734 98
a831 1
	route add $hostname localhost
d833 1
a833 1
	# /etc/mygate, if it exists, contains the name of my gateway host
d837 1
a837 1
		route add default `cat /mnt/etc/mygate`
d840 2
a841 5
	# enable the resolver, if appropriate.
	if [ -f /mnt/etc/resolv.conf ]; then
		_resolver_enabled="TRUE"
		cp /mnt/etc/resolv.conf /tmp/resolv.conf.shadow
	fi
d844 1
a844 1
	echo	"Network interface configuration:"
d846 3
a848 4

	echo

	if [ "X${_resolver_enabled}" = X"TRUE" ]; then
d850 1
a850 2
		echo
		echo	"Resolver enabled."
d853 1
a853 2
		echo
		echo	"Resolver not enabled."
d859 1
d2211 20
a2244 11
	resp=		# force at least one iteration
	if [ -f /tmp/resolv.conf ]; then
		FQDN=`grep '^domain ' /tmp/resolv.conf | \
		    sed -e 's/^domain //'`
	fi
	while [ "X${resp}" = X"" ]; do
		echo -n "Enter DNS domain name (e.g. \"bar.com\"): [$FQDN] "
		getresp "$FQDN"
	done
	FQDN=$resp

d2252 8
@


1.168
log
@move to 3.0-beta
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.167 2001/08/07 15:00:09 markus Exp $
d498 1
a498 1
marked with [X] have been succesfully configured):
@


1.167
log
@suggest CET, not MET, ok deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.166 2001/04/20 01:55:51 krw Exp $
d72 1
a72 1
VERSION=29
@


1.166
log
@Cleanup, new features, shrinkage.

Remove chunk of commented out, unused code.

Add _didnet=1 to enable_network() so that ftp upgrade
does not ask for network information it already has.

Tell a user that selects the http installation method
that the files will be downloaded via http.

Suppress all 'softdep' options in fstab_shadow so
there are no warnings when the filesystems are
mounted.

Suppress all non-ffs (including nfs, ufs) filesystems
from fstab_shadow. Ufs was never used to install
OpenBSD.

Suppress all 'noauto' filesystems from fstab_shadow.

Reword some comments and messages, esp. the one
just before the offer to edit fstab. Punch up the
fact that the fstab will not be saved, mention
that non-ffs and noauto filesystems will be
ignored.

Move

   /usr/X11R6/lib/X11/{rstart,twm,xkb,xsm,xinit}

directories to

   /usr/X11R6/lib/X11/XF3{rstart,twm,xkb,xsm,xinit}

and replace with links. Links can be overwritten
during upgrade. Directories can't. This enables the
upgrade from XFree86 3.x to XFree86 4.x.

ok deraadt@@ millert@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.165 2001/04/16 19:43:28 krw Exp $
d1792 1
a1792 1
be selected by entering a token like "MET" or "GMT-6".  Other zones are
@


1.165
log
@Fix a couple of nits: delete some unnecessary commas and
only print a 'Done.' for fsck'ing if fsck'ing is actually
attempted.

ok deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.164 2001/04/15 02:35:08 deraadt Exp $
a696 1

d705 2
d883 1
a883 1
echo "questions and then the files will be retrieved iteratively via ftp(1)."
d1977 1
a1977 1
local _fstab _fstab_shadow _dev _mp _fstype _rest
d1979 2
a1980 3
# Now that the 'real' fstab is configured, we munge it into a 'shadow'
# fstab which we'll use for mounting and unmounting all of the target
# filesystems relative to /mnt.  Mount all filesystems.
d1983 3
a1985 2
( while read _dev _mp _fstype _rest; do
	# Skip comment lines
a1989 6
	# ...and filesystems with mounting options ``xx''
	case "$_rest" in
		xx*)    continue;;
		*)      ;;
	esac
	# and some filesystem types (like there are swap,kernfs,...)
d1991 1
a1991 1
		ffs|ufs|nfs)	;;
d1994 6
d2001 1
a2001 3
		echo $_dev /mnt $_fstype $_rest
	else
		echo $_dev /mnt$_mp $_fstype $_rest
d2003 1
@


1.164
log
@move to 2.9-beta
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.163 2001/02/23 17:53:10 marc Exp $
d2086 1
a2087 1
	echo "Done."
@


1.163
log
@
back out prev change.   I should read ALL of my mail before acting
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.162 2001/02/23 17:51:09 marc Exp $
d72 1
a72 1
VERSION=28
@


1.162
log
@create dhclient.leases when needed; ok deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.161 2001/02/12 09:54:09 deraadt Exp $
a636 1
		> /var/db/dhclient.leases
@


1.161
log
@fix http handling; reported as busted by don@@research-cistw.saic.com
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.160 2000/12/10 02:40:39 deraadt Exp $
d637 1
@


1.160
log
@ignore filesystems marked "xx"; os@@atina.ar
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.159 2000/11/20 13:11:16 deraadt Exp $
d870 1
a870 1
		-html) _url_type=http ;;
@


1.159
log
@correct url handling; canacar@@eee.metu.edu.tr
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.158 2000/10/09 22:47:22 naddy Exp $
d1988 5
@


1.158
log
@Replace gratuitous eval by results of the evaluation, in particular
don't eval ${_ftp_server_password}.  This should allow FTP passwords
that contain shell meta characters.

ok millert@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.157 2000/09/13 05:11:35 rahnds Exp $
d870 1
a870 1
		-html) _url_type=html ;;
@


1.157
log
@Fix problem with bsort and multiple input data, original fix by
me, bytes saved by millert, OKed by mickey, millert.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.156 2000/08/21 21:13:40 deraadt Exp $
d1032 1
a1032 1
	eval _url_base=${_url_type}://${_ftp_server_login}:${_ftp_server_password}@@\$_${_url_type}_server_ip/\$_${_url_type}_server_dir
@


1.156
log
@2.8-beta (so that X11 can distinguish login.conf)
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.155 2000/06/23 18:53:24 mickey Exp $
d269 1
a269 1
	local _a=$1
@


1.155
log
@implement bubble sort in ksh instead of using sort(1).
i think i'll fix sparc next week to use it.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.154 2000/06/16 03:19:42 deraadt Exp $
d72 1
a72 1
VERSION=27
@


1.154
log
@ssl package no longer needed (will be tested)
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.153 2000/05/08 21:28:03 millert Exp $
d266 27
@


1.153
log
@If there are no CD devices, abort early.
For ISO9660 CDs we can take advantage of the label spoofing and not
ask the user for partition/fstype.  Also shorten a few variable names.
This makes CD installs go more smoothly.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.152 2000/05/07 17:08:26 millert Exp $
d1136 1
a1136 4
		if [ "X${_f}" = "Xssl${VERSION}.tgz" -o \
		    "X${_f}" = "XsslUSA${VERSION}.tgz" ]; then
			( cd /mnt ; ftp ${_ftp_active} -o - -V -m ${_url_base}/${_f} | /mnt/usr/sbin/chroot /mnt /usr/sbin/pkg_add -I -)
		elif [ "X${_f}" = "X${_kernel}" ]; then
a1144 3
		elif [ "X${_f}" = "Xssl${VERSION}.tgz" -o \
		    "X${_f}" = "XsslUSA${VERSION}.tz" ]; then
			ssl=1
d1289 1
a1289 4
		if [ "X${_f}" = "Xssl${VERSION}.tgz" -o \
		    "X${_f}" = "XsslUSA${VERSION}.tgz" ]; then
			( cd /mnt ; ftp -o - -V -m file:$1/${_f} | /mnt/usr/sbin/chroot /mnt /usr/sbin/pkg_add -I -)
		elif [ "X${_f}" = "X${_kernel}" ]; then
a1297 3
		elif [ "X${_f}" = "Xssl${VERSION}.tgz" -o \
		    "X${_f}" = "XsslUSA${VERSION}.tgz" ]; then
			ssl=1
@


1.152
log
@Add -n flag to getresp, indicating shell escapes are not to be allowed
Don't show gre interfaces when prompting user for an ether device
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.151 2000/04/27 16:11:05 deraadt Exp $
d1339 1
a1339 1
local _drive _partition_range _partition _fstype _directory
d1342 6
d1350 5
a1354 2
The following CD-ROM devices are installed on your system; please select
the CD-ROM device containing the partition with the installation sets:
d1357 3
a1359 5
_CDDEVS=`md_get_cddevs`
echo    "$_CDDEVS"
echo
echo -n	"Which is the CD-ROM with the installation media? [abort] "
getresp "abort"
d1378 32
a1409 10
# Get partition
_partition_range=`md_get_partition_range`
resp=		# force one iteration
while [ "X${resp}" = X"" ]; do
	echo -n "CD-ROM partition to mount (normally \"c\")? [c] "
	getresp "c"
	case "$resp" in
		$_partition_range)
			_partition=$resp
			;;
d1411 6
a1416 6
		*)
			echo "Invalid response: $resp"
			resp=		# force loop to repeat
			;;
	esac
done
d1418 2
a1419 2
# Ask for filesystem type
cat << __EOT
d1426 8
a1433 8
resp=		# force one iteration
while [ "X${resp}" = X"" ]; do
	echo -n "Which filesystem type (Official OpenBSD CD-ROM is cd9660)? [cd9660] "
	getresp "cd9660"
	case "$resp" in
		cd9660|ffs)
			_fstype=$resp
			;;
d1435 8
a1442 6
		*)
			echo "Invalid response: $resp"
			resp=		# force loop to repeat
			;;
	esac
done
d1446 1
a1446 1
    /dev/${_drive}${_partition} /mnt2 ; then
@


1.151
log
@ssl is now a tgz
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.150 2000/04/08 05:06:25 deraadt Exp $
d102 1
d109 5
d119 16
a134 12
		case "$resp" in
			"")	resp=$1
				;;
			!)	echo "Type 'exit' to return to install."
				sh
				test $_shell_aware -eq 0 && continue
				;;
			!*)
				eval ${resp#?}
				test $_shell_aware -eq 0 && continue
				;;
		esac
d265 1
a265 1
	/sbin/ifconfig -a | egrep -v '^([[:space:]]|(lo|enc|ppp|sl|tun|bridge)[[:digit:]])' | cutword -t: 1
d991 1
a991 1
				getresp "${_ftp_server_password}"
@


1.150
log
@2.7-beta
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.149 2000/03/19 01:14:03 espie Exp $
d1126 2
a1127 2
		if [ "X${_f}" = "Xssl${VERSION}.tar.gz" -o \
		    "X${_f}" = "XsslUSA${VERSION}.tar.gz" ]; then
d1138 2
a1139 2
		elif [ "X${_f}" = "Xssl${VERSION}.tar.gz" -o \
		    "X${_f}" = "XsslUSA${VERSION}.tar.gz" ]; then
d1285 2
a1286 2
		if [ "X${_f}" = "Xssl${VERSION}.tar.gz" -o \
		    "X${_f}" = "XsslUSA${VERSION}.tar.gz" ]; then
d1297 2
a1298 2
		elif [ "X${_f}" = "Xssl${VERSION}.tar.gz" -o \
		    "X${_f}" = "XsslUSA${VERSION}.tar.gz" ]; then
@


1.149
log
@populateusrlocal: create the right hierarchy under /usr/local
right before unmounting the new system.
Beats having mtree files around every package...
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.148 2000/02/25 01:39:13 krw Exp $
d72 1
a72 1
VERSION=26
@


1.148
log
@'ie.' -> 'e.g.' or 'i.e.' as appropriate
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.147 1999/11/11 02:36:02 millert Exp $
d2207 6
@


1.147
log
@Only allow dhcp as an option if /sbin/dhclient exists; deraadt@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.146 1999/10/26 22:56:54 deraadt Exp $
d581 1
a581 1
		echo "media, copy that line from above (ie. \"media 100baseTX\")"
d865 1
a865 1
	echo -n "HTTP/FTP proxy URL? (ie. \"http://proxy:8080\", or \"none\") [${_proxy_host}] "
d1797 1
a1797 1
You still do not have a /bin/cat in your filesystem (ie. a sample random file
d2076 1
a2076 1
		echo -n "Enter system hostname (short form, ie. \"foo\"): [$_nam] "
d2088 1
a2088 1
		echo -n "Enter DNS domain name (ie. \"bar.com\"): [$FQDN] "
@


1.146
log
@siteXX.tar.gz set also choosable, starting next release; mho@@stacken.kth.se
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.145 1999/10/18 05:25:26 deraadt Exp $
d509 1
d529 7
d539 1
a539 1
		echo -n "IP address (or 'dhcp') ? [$_if_ip] "
d541 3
@


1.145
log
@default to man set included, from cd/disk too
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.144 1999/10/17 16:57:26 deraadt Exp $
d77 3
a79 2
ALLSETS="base etc misc comp man game xbase xshare xfont xserv"	# install
UPGRSETS="base misc comp man game xbase xshare xfont xserv"	# upgrade
@


1.144
log
@another stupid typo
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.143 1999/10/17 16:45:14 deraadt Exp $
d1220 1
a1220 1
		base*.tar.gz|base*.tgz|etc*.tar.gz|etc*.tgz|bsd)
@


1.143
log
@fix errors
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.142 1999/10/17 15:35:51 deraadt Exp $
d1115 1
a1115 1
		    "X${_f}" = "XsslUSA${VERSION}.tar.gz"]; then
@


1.142
log
@pretty reuse prompt; requested by kwesterback@@home.com
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.141 1999/10/17 06:53:40 deraadt Exp $
d88 1
a88 1
if [ X$EDITOR = X ]; then
d1115 1
a1115 1
		    X${_f}" = "XsslUSA${VERSION}.tar.gz"]; then
@


1.141
log
@damnit: complete disgusting dual-matching for ssl libraries which really shows
how little sh i know (and how incapable i am of reading the sh manpage after 7
guiness).  thanks to various people for going through the grief of discovering
this problem first hand, after a few people in michigan had not gotten around
to testing their work (tsk tsk tsk!)
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.140 1999/10/16 19:01:22 deraadt Exp $
d840 1
a840 1
		echo -n "Use values from previous ${_url_type} install? "
@


1.140
log
@in any situation where network config is needed, if the network is not configured, configure it then
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.139 1999/10/16 17:37:36 deraadt Exp $
d1114 2
a1115 1
		if [ "X${_f}" = "Xssl${VERSION}.tar.gz" ]; then
d1126 2
a1127 1
		elif [ "X${_f}" = "Xssl${VERSION}.tar.gz" ]; then
d1273 2
a1274 1
		if [ "X${_f}" = "Xssl${VERSION}.tar.gz" ]; then
d1285 2
a1286 1
		elif [ "X${_f}" = "Xssl${VERSION}.tar.gz" ]; then
@


1.139
log
@pretty; fries
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.138 1999/10/15 16:55:00 millert Exp $
d1844 1
d1849 1
d1862 1
d2050 141
@


1.138
log
@o Support separate USA and International versions of libssl
o add support for passing in wildcards to designate what should
  get pre-selected in the file selector and use it for libssl.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.137 1999/10/14 17:29:04 deraadt Exp $
d1051 3
a1053 3
"these sets are required for your ${MODE} and some are optional -- you will want at\\\\n"\
"least the base and bsd sets.  Consult the installation notes if you are not sure\\\\n"\
"which sets are required!"
@


1.137
log
@libssl*.t*z -> ssl*.t*z
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.136 1999/10/14 17:17:46 millert Exp $
d815 1
a815 1
local _url_type _url_base _reuse
d823 1
d827 3
d1055 1
a1055 1
# Set a minimal default
d1057 7
a1063 8
	case "$_f" in
		base*.tar.gz|base*.tgz|man*.tar.gz|man*.tgz|etc*.tar.gz|etc*.tgz|bsd)
			if ! isin ${_f} ${_setsdone}; then
				_get_files=`addel ${_f} ${_get_files}`
				_setsdone=`addel ${_f} ${_setsdone}`
			fi
			;;
	esac
a1812 1

@


1.136
log
@o When doing an ftp/http install where all the info has already been entered
  give the user the option of just using the old info instead of re-prompting.
o Do network setup before grabbing libssl via ftp/http if it has not
  already been setup.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.135 1999/10/07 21:35:47 deraadt Exp $
d77 2
a78 2
ALLSETS="base etc misc comp man game xbase xshare xfont xserv libssl"	# install
UPGRSETS="base misc comp man game xbase xshare xfont xserv libssl"	# upgrade
d1042 8
a1049 9
"You will now be asked for files to extract.  In addition to the\\\\n"\
"files listed in the selector you may enter any file located at\\\\n"\
"\$_${_url_type}_server_ip:\$_${_url_type}_server_dir.  You can also enter\\\\n"\
"'all' to install all the standard sets, or 'list' to list the\\\\n"\
"files avilable at \$_${_url_type}_server_ip:\$_${_url_type}_server_dir.\\\\n"\
"When you are done selecting files, enter 'done'.\\\\n"\
"Some of these sets are required for your ${MODE} and some are optional --\\\\n"\
"You will want at least the base and bsd sets.\\\\n"\
"Consult the installation notes if you are not sure which sets are required!"
d1111 1
a1111 1
		if [ "X${_f}" = "Xlibssl${VERSION}.tar.gz" ]; then
d1122 2
a1123 2
		elif [ "X${_f}" = "Xlibssl${VERSION}.tar.gz" ]; then
			libssl=1
d1268 1
a1268 1
		if [ "X${_f}" = "Xlibssl${VERSION}.tar.gz" ]; then
d1279 2
a1280 2
		elif [ "X${_f}" = "Xlibssl${VERSION}.tar.gz" ]; then
			libssl=1
@


1.135
log
@use pkg_add -I for ssl package
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.134 1999/10/02 18:53:24 deraadt Exp $
d729 1
a729 1
# The list of sets is passed in as $1, sets $resp 
d815 1
a815 1
local _url_type _url_base
d817 9
a825 2
# Is this an ftp or http install?
_url_type=$1; shift
a830 31
    
# Proxy the connections?
if [ "X${_proxy_host}" = X"" ]; then
	_proxy_host=none
fi
echo -n "HTTP/FTP proxy URL? (ie. \"http://proxy:8080\", or \"none\") [${_proxy_host}] "
getresp "${_proxy_host}"
if [ "X${resp}" = X"none" ]; then
	unset _proxy_host ftp_proxy http_proxy
else
	_proxy_host=$resp
	export ftp_proxy=${_proxy_host}
	export http_proxy=${_proxy_host}
fi
if [ "${_url_type}" = "ftp" -a "X$ftp_proxy" = "X" ]; then
	# Use active mode ftp? (irrelevant if using a proxy)
	case "${_ftp_active}" in
		-A)	resp=y ;;
		*)	resp=n ;;
	esac
	echo "By default, ftp will attempt a passive connection and fall back to a normal"
	echo "(active) connection if that doesn't work.  However, there are some very"
	echo "old ftp servers that claim to support passive mode, but really do not."
	echo "In this case, you should explicitly request an active session."
	echo -n "Do you want to use active ftp? [${resp}] "
	getresp "${resp}"
	case "$resp" in
		y*|Y*)	_ftp_active=-A ;;
		*)	unset _ftp_active ;;
	esac
fi
d832 10
a841 12
# Provide a list of possible servers
test -z "$_ftp_getlist" && _ftp_getlist=y
echo -n "Do you want a list of potential ${_url_type} servers? [${_ftp_getlist}] "
getresp $_ftp_getlist
case "$resp" in
n*|N*)	_ftp_getlist=n
	;;
*)
	_ftp_getlist=y
	ftphost=129.128.5.191
	if [ "X${_resolver_enabled}" = X"TRUE" ]; then
		ftphost=ftp.openbsd.org
d843 10
a852 10
	ftp ${_ftp_active} -V -a -o /tmp/ftplist ftp://${ftphost}/pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/ftplist > /dev/null
	cat /tmp/ftplist | grep "^${_url_type}:" | cat -n | less -XE
	;;
esac

# Get server IP address
resp=		# force one iteration
while [ "X${resp}" = X"" ]; do
	if [ -f /tmp/ftplist ]; then
		eval echo -n "Server IP address, hostname, or list#? [\$_${_url_type}_server_ip]\ "
d854 20
a873 1
		eval echo -n "Server IP address, or hostname? [\$_${_url_type}_server_ip]\ "
d875 15
a889 2
	eval getresp "\$_${_url_type}_server_ip"
	if [ "X$resp" = "X?" -a -f /tmp/ftplist ]; then
d891 14
a904 7
		resp=
	elif [ -n "$resp" -a `isnumeric $resp` -eq 1 -a ${resp:-0} -ge 1 \
	    -a -f /tmp/ftplist ]; then
		maxlines=`grep "^${_url_type}:" /tmp/ftplist | cat -n |
		    sed -n -e '$p' | cutword 1`
		if [ $maxlines -lt $resp ]; then
			echo "There is no ${resp}th line in the list."
d906 21
a926 1
			continue
d928 1
a928 14
		tline=`grep "^${_url_type}:" /tmp/ftplist | sed -n -e "${resp}p"`
		url=`echo $tline | sed -e "s/^${_url_type}:\/\///" |
		    cutword -t' ' 1 | cutword -t' ' 1`
		host=`echo $url | cutword -t/ 1`
		path=`echo $url | sed -e "s/^${host}\///"`
		path="${path}/${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}"
		eval _${_url_type}_server_ip=$host
		eval _${_url_type}_server_dir=$path
		resp=		# do it again, just to double check
		echo "Using	$tline"
	else
		eval _${_url_type}_server_ip="$resp"
	fi
done
d930 4
a933 19
# Get server directory
if [ "${_url_type}" = "ftp" -a "X${_ftp_server_dir}" = X"" ]; then
	# Default ftp dir
	_ftp_server_dir="pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}"
fi
resp=		# force one iteration
while [ "X${resp}" = X"" ]; do
	eval echo -n "Server directory? [\$_${_url_type}_server_dir]\ "
	eval getresp "\$_${_url_type}_server_dir"
	eval _${_url_type}_server_dir=$resp
done

if [ "${_url_type}" = "ftp" ]; then
	# Need default values even if we proxy ftp...
	if [ "X${_ftp_server_login}" = X"" ]; then
		_ftp_server_login=anonymous
	fi
	if [ "X${_ftp_server_password}" = X"" ]; then
		_ftp_server_password=root@@`hostname`.${FQDN}
a934 2

	# Get login name
d937 3
a939 3
		echo -n "Login? [${_ftp_server_login}] "
		getresp "${_ftp_server_login}"
		_ftp_server_login=$resp 
d942 10
a951 2
	# Get password unless anonymous
	if [ ${_ftp_server_login} != "anonymous" ]; then
d954 3
a956 6
			echo -n "Password (will not echo): "
			stty -echo
			getresp "${_ftp_server_password}"
			stty echo
			echo
			_ftp_server_password=$resp
d958 16
a973 3
	else
		# only used by ftp_list_files()
		_ftp_server_password=root@@`hostname`.${FQDN}
d1090 3
d1211 1
a1211 1
"Consult the intallation notes if you are not sure which sets are required!"
d1459 1
a1459 1
fi 
d1843 1
a1843 1
			install_url ftp
d1847 1
a1847 1
			install_url http
@


1.134
log
@fix local disk package install
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.133 1999/10/02 13:32:43 aaron Exp $
d1089 1
a1089 1
			( cd /mnt ; ftp ${_ftp_active} -o - -V -m ${_url_base}/${_f} | /mnt/usr/sbin/chroot /mnt /usr/sbin/pkg_add -)
d1246 1
a1246 1
			( cd /mnt ; ftp -o - -V -m file:$1/${_f} | /mnt/usr/sbin/chroot /mnt /usr/sbin/pkg_add -)
@


1.133
log
@Fix a typo; ian@@darwinsys.com
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.132 1999/09/23 21:33:43 aaron Exp $
d1246 1
a1246 1
			( cd /mnt ; ftp ${_ftp_active} -o - -V -m ${_url_base}/${_f} | /mnt/usr/sbin/chroot /mnt /usr/sbin/pkg_add -)
@


1.132
log
@Formatting, typo, and grammar fixes.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.131 1999/09/23 19:02:20 deraadt Exp $
d1771 1
a1771 1
You will now be given the chance to install the missing set(s).  You can can
@


1.131
log
@first cut at ssl chroot package install
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.127 1999/08/15 09:53:36 millert Exp $
d405 1
a405 1
	echo -n "Which disk is the root disk [${_defdsk}]? "
d747 1
a747 1
	echo -n "File name [$_next]? "
d1323 1
a1323 1
	echo -n "CDROM partition to mount (normally \"c\")? [c] "
d1347 1
a1347 1
	echo -n "Which filesystem type (Official OpenBSD CDROM is cd9660)? [cd9660] "
d1706 1
a1706 1
	echo -n	"What timezone are you in [\`?' for list] [$TZ]? "
d1968 1
a1968 1
	echo -n "Umounting filesystems... "
@


1.130
log
@put man package in the default; get used to it people
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.129 1999/09/23 18:58:19 deraadt Exp $
d77 2
a78 2
ALLSETS="base etc misc comp man game xbase xshare xfont xserv"	# install
UPGRSETS="base misc comp man game xbase xshare xfont xserv"	# upgrade
d1088 3
a1090 1
		if [ "X${_f}" = "X${_kernel}" ]; then
d1099 2
d1245 3
a1247 1
		if [ "X${_f}" = "X${_kernel}" ]; then
d1256 2
@


1.129
log
@ask for ftp password once
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.128 1999/09/23 18:57:39 deraadt Exp $
d1034 1
a1034 1
		base*.tar.gz|base*.tgz|etc*.tar.gz|etc*.tgz|bsd)
@


1.128
log
@crank to 26
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.127 1999/08/15 09:53:36 millert Exp $
a948 10

			echo -n "Password (again): "
			stty -echo
			getresp "${_ftp_server_password}"
			stty echo
			echo
			if [ "${_ftp_server_password}" != "${resp}" ]; then
				echo "Passwords do not match, try again."
				resp=
			fi
@


1.127
log
@o When clearing a variable, do ``foo='', not ``foo=""'' to save 2 bytes.
  There are other places where double quotes are used unnecessarily as well
o Kill md_copy_kernel() and check_kernel() since the kernel is now a 'set'
o Add support for shell escapes from any prompt
o Consolidate post-install_sets sanity checks and put them in sane_install().
o install_sets() now calls sane_install() to do the sanity checks and won't
  let you continue until things are sane (as far as it can determine).
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.126 1999/08/10 23:07:24 deraadt Exp $
d72 1
a72 1
VERSION=24
@


1.126
log
@typo
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.125 1999/07/30 00:31:27 deraadt Exp $
d71 1
a71 1
ROOTDISK=""				# filled in below
d85 1
a85 1
local_sets_dir=""
d100 8
d112 12
a123 3
		if [ "X$resp" = "X" ]; then
			resp=$1
		fi
d155 1
a155 1
	local	_a=$1 _seen=""
d318 1
a318 1
	local _mp=$1 _dir=""
d354 1
a354 1
				local_sets_dir=""
d383 1
a383 1
		DISK=""
d401 1
a401 1
		_defdsk=""
d412 1
a412 1
		ROOTDISK=""
d451 1
a451 1
	local _ifsdone="" _ifs _ouranswer="" _reprompt=1
d454 1
a454 1
	resp=""		# force at least one iteration
d492 1
a492 1
				_ouranswer=""
d528 1
a528 1
	resp=""		# force one iteration
d537 1
a537 1
	resp=""		# force one iteration
d546 1
a546 1
		resp=""
d731 1
a731 1
	local _next="" _f _sets=$1
d736 1
a736 1
			_next=""
d875 1
a875 1
resp=""		# force one iteration
d885 1
a885 1
		resp=""
d892 1
a892 1
			resp=""
d903 1
a903 1
		resp=""		# do it again, just to double check
d915 1
a915 1
resp=""		# force one iteration
d932 1
a932 1
	resp=""		# force one iteration
d941 1
a941 1
		resp=""		# force one iteration
d957 1
a957 1
				resp=""
d983 1
a983 1
_sets=""
d1005 2
a1006 2
	_sets=""
	_kernel=""
d1094 1
a1094 1
	_failed_files=""
d1111 1
a1111 1
	_get_files=""
d1137 1
a1137 1
local _sets="" _kernel _f _get_files _failed_files _osetsdone
d1165 2
a1166 2
	_sets=""
	_kernel=""
d1247 1
a1247 1
	_failed_files=""
d1264 1
a1264 1
	_get_files=""
d1323 1
a1323 1
resp=""		# force one iteration
d1334 1
a1334 1
			resp=""		# force loop to repeat
d1347 1
a1347 1
resp=""		# force one iteration
d1358 1
a1358 1
			resp=""		# force loop to repeat
d1374 1
a1374 1
resp=""		# force one iteration
d1438 1
a1438 1
resp=""		# force one iteration
d1449 1
a1449 1
			resp=""		# force loop to repeat
d1468 1
a1468 1
resp=""		# force one iteration
d1474 1
a1474 1
			_fstype=""
d1487 1
a1487 1
			resp=""		# force loop to repeat
d1519 1
a1519 1
resp=""		# force one iteration
d1533 1
a1533 1
resp=""		# force one iteration
d1541 1
a1541 1
resp=""		# force one iteration
d1557 1
a1557 1
		_nfs_tcp=""
d1570 1
a1570 1
resp=""		# force one iteration
d1593 1
a1593 1
resp=""		# force one iteration
d1617 1
a1617 1
resp=""		# force one iteration
d1628 1
a1628 1
			resp=""		# fore loop to repeat
d1651 1
a1651 1
resp=""		# force one iteration
d1666 1
a1666 1
		resp=""		# force loop to repeat
d1688 1
a1688 1
	_zonepath=""
d1746 35
d1806 1
a1806 1
resp=""		# force at least one iteration
d1842 1
a1842 1
				resp=""
d1847 1
a1847 1
			resp=""
d1854 12
a1865 2
	if [ ! -f /mnt/bsd ]; then
		cat << __EOT
d1867 6
a1872 14
You still do not have a /bsd in your filesystem (ie. the kernel), which
seems to indicate that you are still missing important distribution files.
So please continue installing...
__EOT
		resp=""
	fi
	if [ ! -f /mnt/bin/cat ]; then
		cat << __EOT

You still do not have a /bin/cat in your filesystem (ie. a sample random file
which you probably want). This seems to indicate that you are still missing
important distribution files. So please continue installing...
__EOT
		resp=""
a1873 15

	# Give the user the opportunity to extract more sets. They
	# don't necessarily have to come from the same media.
	echo
	echo -n	"Extract more sets? [n] "
	getresp "n"
	case "$resp" in
	y*|Y*)
		# Force loop to repeat
		resp=""
		;;

	*)
		;;
	esac
d1962 2
a1963 2
	_devs=""
	_mps=""
d2009 2
a2010 2
	_devs=""
	_mps=""
a2023 20
}

check_kernel() {
	if [ ! -s /mnt/bsd ]; then
		echo
		echo	"Warning, no kernel installed!"
		echo	"You did not unpack a file set containing a kernel."
		echo	"This is needed to boot.  Please note that the install"
		echo	"kernel is not suitable for general use."
		echo -n	"Escape to shell add /mnt/bsd by hand? [y] "
		getresp "y"
		case "$resp" in
			y*|Y*)
				echo "Type 'exit' to return to install."
				sh
				;;
			*)
				;;
		esac
	fi
@


1.125
log
@leave async mode before installboot is run...
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.124 1999/07/24 22:46:32 deraadt Exp $
d1993 1
a1993 1
		echo	"install kernel is not suitable for general use."
@


1.124
log
@do install using -o async mounts, faster
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.123 1999/05/30 08:34:51 deraadt Exp $
d1870 1
d1888 2
a1889 2
	if ! mount -v -t $_fstype -o async -o $_opt $_dev $_mp ; then
		# error message displated by mount
d1947 15
@


1.123
log
@improve ftp/http proxy prompt
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.122 1999/04/10 04:39:50 deraadt Exp $
d1462 1
a1462 1
			_fsopts="ro"
d1887 1
a1887 1
	if ! mount -v -t $_fstype -o $_opt $_dev $_mp ; then
@


1.122
log
@spelling
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.121 1999/04/07 08:47:34 deraadt Exp $
d812 1
a812 1
echo -n "HTTP/FTP proxy URL? (if you use a proxy) [${_proxy_host}] "
@


1.121
log
@save bytes; move swapon question
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.120 1999/04/05 00:26:49 millert Exp $
d830 1
a830 1
	echo "In this case, you should explicately request an active session."
@


1.120
log
@Fix persistence of potential servers answer
Don't make NFS an option if no /sbin/mount_nfs
Fix syntax error when user hits return at ftp/http IP/name prompt
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.119 1999/04/02 17:50:01 millert Exp $
d354 1
a354 1
	echo	""
d364 1
a364 1
		echo ""
d387 1
a387 1
	echo	""
d393 1
a393 1
		echo ""
d458 1
a458 1
			echo	""
d696 1
a696 1
	echo	""
d700 1
a700 1
		echo	""
d704 1
a704 1
		echo	""
d930 1
a930 1
			echo ""
d937 1
a937 1
			echo ""
d1003 1
a1003 1
		echo ""
d1005 1
a1005 1
		echo ""
d1038 1
a1038 1
	echo ""
d1042 1
a1042 1
	echo ""
d1048 1
a1048 1
		echo ""
d1078 1
a1078 1
	echo ""
d1096 1
a1096 1
		echo ""
d1100 1
a1100 1
		echo ""
d1106 1
a1106 1
			echo ""
d1109 1
a1109 1
			echo ""
d1159 1
a1159 1
		echo ""
d1161 1
a1161 1
		echo ""
d1192 1
a1192 1
	echo ""
d1196 1
a1196 1
	echo ""
d1202 1
a1202 1
		echo ""
d1231 1
a1231 1
	echo ""
d1249 1
a1249 1
		echo ""
d1253 1
a1253 1
		echo ""
d1259 1
a1259 1
			echo ""
d1262 1
a1262 1
			echo ""
d1283 1
a1283 1
echo	""
d1296 1
a1296 1
			echo ""
d1388 1
a1388 1
			echo ""
d1494 1
a1494 1
echo	""
d1823 1
a1823 1
	echo	""
d1973 1
a1973 1
		echo	""
@


1.119
log
@Remember the value for "Do you want a list of potential servers"
Update ftp.openbsd.org IP addr
shave a few bytes
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.118 1999/04/02 05:51:16 millert Exp $
d840 3
a842 6
case "${_ftp_getlist}" in
	n*|N*)	resp=n ;;
	*)	resp=y ;;
esac
echo -n "Do you want a list of potential ${_url_type} servers? [${resp}] "
getresp "y"
d869 1
a869 1
	elif [ -n "$resp" -a `isnumeric $resp` -eq 1 -a $resp -ge 1 \
d1730 4
a1733 1
local _yup="FALSE"
d1759 3
a1761 2
		echo -n	"Install from (f)tp, (h)ttp, (t)ape, (C)D-ROM,"
		echo -n " (N)FS or local (d)isk? "
d1785 7
a1791 2
			install_nfs
			resp=n
@


1.118
log
@Change a = to -eq in test statement.  Otherwise we get an error if someone just hits return at the Server IP prompt during an ftp install
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.117 1999/04/01 21:25:48 deraadt Exp $
d291 1
a291 1
	ftp ${_ftp_active} -V -n $_host  <<__ptf
d327 1
a327 1
		cat << __get_reldir_1
d330 1
a330 1
__get_reldir_1
d346 1
a346 1
	cat << \__getanotherdisk_1
d351 1
a351 1
__getanotherdisk_1
d371 1
a371 1
	cat << \__getrootdisk_1
d378 1
a378 1
__getrootdisk_1
d440 1
a440 1
			cat << \__configurenetwork_1
d445 1
a445 1
__configurenetwork_1
d565 1
a565 1
cat > /etc/dhclient.conf << __dhclientedit1
d570 1
a570 1
__dhclientedit1
d587 1
a587 1
			cat > /etc/dhclient.conf << __dhclientedit2
d591 1
a591 1
__dhclientedit2
d840 5
a844 1
echo -n "Do you want a list of potential ${_url_type} servers? [y] "
d847 2
a848 1
n*|N*) ;;
d850 2
a851 2

	ftphost=129.128.76.52
d872 1
a872 1
	elif [ "X${resp}" != X"" -a `isnumeric $resp` -eq 1 -a $resp -ge 1 \
d1278 1
a1278 1
cat << \__install_cdrom_1
d1283 1
a1283 1
__install_cdrom_1
d1326 1
a1326 1
cat << \__install_cdrom_2
d1332 1
a1332 1
__install_cdrom_2
d1335 1
a1335 1
	echo -n "Which filesystem type (Official OpenBSD CDROM are cd9660)? [cd9660] "
d1400 1
a1400 1
cat <<__mount_a_disk_1
d1404 1
a1404 1
__mount_a_disk_1
d1441 1
a1441 1
cat << \__mount_a_disk_2
d1446 1
a1446 1
__mount_a_disk_2
d1489 1
a1489 1
cat << \__install_disk_1
d1494 1
a1494 1
__install_disk_1
d1572 1
a1572 1
cat << \__install_tape_1
d1577 1
a1577 1
__install_tape_1
d1629 1
a1629 1
cat << \__install_tape_2
d1636 1
a1636 1
__install_tape_2
d1677 1
a1677 1
cat << \__get_timezone_1
d1688 1
a1688 1
__get_timezone_1
d1732 1
a1732 2
install_sets()
{
d1736 1
a1736 1
cat << \__install_sets_1
d1744 1
a1744 1
__install_sets_1
d1797 1
a1797 1
		cat << \__install_sets_2
d1802 1
a1802 1
__install_sets_2
d1806 1
a1806 1
		cat << \__install_sets_3
d1811 1
a1811 1
__install_sets_3
d1832 1
a1832 2
munge_fstab()
{
d1859 1
a1859 2
mount_fs()
{
d1888 1
a1888 1
	cat << \__mount_filesystems_1
d1892 1
a1892 1
__mount_filesystems_1
d1897 1
a1897 2
unmount_fs()
{
d1942 1
a1942 2
check_fs()
{
@


1.117
log
@shrink by merging local variable decl
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.116 1999/04/01 17:41:26 millert Exp $
d867 1
a867 1
	elif [ "X${resp}" != X"" -a `isnumeric $resp` = 1 -a $resp -ge 1 \
@


1.116
log
@ignore bridge[0-9] when prompting for interfaces to bring up
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.115 1999/03/23 07:58:08 deraadt Exp $
d84 2
a85 2
local_sets_dir=""			# Path searched for sets by install_sets
					# on the local filesystems
d125 1
a125 1
	local	_a
d127 1
a127 1
	_a=$1; shift
d138 1
a138 2
	local	_a
	local	_seen
d140 1
a140 2
	_seen=""
	_a=$1; shift
d155 1
a155 1
	local	_a
d157 1
a157 1
	_a=$1; shift
d168 1
a168 3
	local _a
	local _n
	local _oifs
a170 1
	_oifs="$IFS"
d186 1
a186 2
	local _a
	local _oifs
a188 1
	_oifs="$IFS"
d202 2
a203 2
	local _a
	_a=$1
d212 1
d223 2
a224 2
	local _a
	_a=$1
d242 1
a242 2
	local _dir
	local _file
d244 1
a244 1
	_dir=$1; shift
d264 1
a264 2
	local _list
	local _file
d266 1
a266 1
	_list=$1; shift
d287 3
a289 9
	local _host
	local _user
	local _pass
	local _dir

	_host=$1; shift
	_user=$1; shift
	_pass=$1; shift
	_dir=$1; shift
a298 10
twiddle() {
# spin the propeller so we don't get bored
	while : ; do  
		sleep 1; echo -n "/";
		sleep 1; echo -n "-";
		sleep 1; echo -n "\\";
		sleep 1; echo -n "|";
	done > /dev/tty & echo $!
}

d301 1
a301 2
	local _mp
	local _dir
a302 2
	_mp=$1
	_dir=
d434 1
a434 4
	local _ifsdone
	local _ifs
	local _ouranswer
	local _reprompt
a436 3
	_ifsdone=""
	_ouranswer=""
	_reprompt=1
d489 2
a490 9
	local _up
	local _interface_name
	local _interface_ip
	local _interface_mask
	local _interface_symname
	local _interface_extra
	local _hostname

	_interface_name=$1
d492 1
a492 1
	set -- `ifconfig $_interface_name | sed -n '
d503 2
a504 2
	_interface_ip=$2
	_interface_mask=$3
d507 1
a507 1
		ifconfig $_interface_name delete down
d513 3
a515 3
		echo -n "IP address (or 'dhcp') ? [$_interface_ip] "
		getresp "$_interface_ip"
		_interface_ip=$resp
d524 1
a524 1
		_interface_symname=$resp
d528 1
a528 1
	if [ "$_interface_ip" != "dhcp" ]; then
d530 2
a531 2
		if [ "X${_interface_mask}" = X"" ]; then
			_interface_mask=255.255.255.0
d534 3
a536 3
			echo -n "Netmask ? [$_interface_mask] "
			getresp "$_interface_mask"
			_interface_mask=$resp
d540 1
a540 1
	if [ -n "`ifconfig -m ${_interface_name} | sed -n '/media/p'`" ]; then
d543 1
a543 1
		ifconfig -m ${_interface_name} | sed -n '
d547 1
a547 1
		ifconfig -m ${_interface_name} | sed -n '
d553 2
a554 2
		echo -n "Media directives? [$_interface_extra] "
		getresp "$_interface_extra"
d556 1
a556 1
			_interface_extra=$resp
d563 2
a564 2
	if [ "$_interface_ip" = "dhcp" ]; then
		ifconfig ${_interface_name} down ${_interface_extra}
d571 1
a571 1
		dhclient -1 ${_interface_name}
d573 1
a573 1
		set -- `ifconfig $_interface_name | sed -n '
d584 2
a585 2
			echo "hostname-associated DHCP attempt for $_interface_name failed..."
			ifconfig $_interface_name delete down
d592 2
a593 2
			dhclient -1 ${_interface_name}
			set -- `ifconfig $_interface_name | sed -n '
d604 2
a605 2
				echo "free-roaming DHCP attempt for $_interface_name failed."
				ifconfig $_interface_name delete down
d608 2
a609 5
				echo "DHCP attempt for $_interface_name successful."
				addifconfig \
					${_interface_name} \
					${_interface_symname} \
					${_interface_ip}
d613 2
a614 5
			echo "DHCP configuration of $_interface_name successful."
			addifconfig \
				${_interface_name} \
				${_interface_symname} \
				${_interface_ip}
d618 5
a622 9
		ifconfig ${_interface_name} down
		if ifconfig ${_interface_name} inet \
		    ${_interface_ip} \
		    netmask ${_interface_mask} ${_interface_extra} up ; then
			addifconfig \
			    ${_interface_name} \
			    ${_interface_symname} \
			    ${_interface_ip} \
			    ${_interface_mask} "${_interface_extra}"
d714 1
a714 3
	local _next
	local _f
	local _sets
a715 2
	_sets=$1
	_next=""
d737 2
a738 7
	local _selection="$1"
	local _parent_dir="$2"
	local _sets="$3"
	local _action
	local _matched
	local _tfile
	local _f
d797 2
a798 9
local _sets
local _kernel
local _f
local _file_list
local _get_files
local _failed_files
local _osetsdone
local _url_type
local _url_base
d1118 1
a1118 6
local _sets
local _kernel
local _f
local _get_files
local _failed_files
local _osetsdone
a1124 1
_sets=""
d1270 1
a1270 5
local _drive
local _partition_range
local _partition
local _fstype
local _directory
d1372 2
a1373 9
local _drive
local _def_partition
local _partition_range
local _partition
local _fstype
local _fsopts
local _directory
local _md_fstype
local _md_fsopts
d1656 1
a1656 2
local _a
local _zonepath
d1729 1
a1729 2
local _yup
_yup="FALSE"
d1830 1
a1830 6
local _fstab
local _fstab_shadow
local _dev
local _mp
local _fstype
local _rest
d1861 1
a1861 3
local _fstab

_fstab=$1
d1899 1
a1899 3
local _check
local _fstab
local _pid
d1945 1
a1945 3
local _fstab

_fstab=$1
@


1.115
log
@put fqdn first; matter@@research.suspicious.org
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.114 1999/03/23 02:30:31 millert Exp $
d243 1
a243 1
	/sbin/ifconfig -a | egrep -v '^([[:space:]]|(lo|enc|ppp|sl|tun)[[:digit:]])' | cutword -t: 1
@


1.114
log
@(h)ttp, not h(ttp),; brad@@openbsd.org
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.113 1998/12/19 18:31:57 deraadt Exp $
d437 1
a437 1
	sed "/ $2 $2.$FQDN\$/d" < /tmp/hosts > /tmp/hosts.new
d440 1
a440 1
	echo "$1 $2 $2.$FQDN" >> /tmp/hosts
@


1.113
log
@merge text into base
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.112 1998/11/09 03:54:52 millert Exp $
d1840 1
a1840 1
		echo -n	"Install from (f)tp, h(ttp), (t)ape, (C)D-ROM,"
@


1.112
log
@Remove labelmoredisks(), nothing uses it anymore and most install.md's
don't provide a real md_labeldisk() anyway.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.111 1998/11/03 04:35:16 aaron Exp $
d77 3
a79 3
ALLSETS="base etc misc comp text man game xbase xshare xfont xserv"	# install
UPGRSETS="base misc comp text man game xbase xshare xfont xserv"	# upgrade
SNAPSETS="bin dev etc games man misc sbin text \
@


1.111
log
@it's -> its where appropriate
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.110 1998/10/28 18:55:20 millert Exp $
a423 25
}

labelmoredisks() {
	cat << \__labelmoredisks_1

You may label the following disks:

__labelmoredisks_1
	echo "$_DKDEVS"
	echo	""
	echo -n	"Label which disk? [done] "
	getresp "done"
	case "$resp" in
		done)
			;;

		*)
			if isin $resp $_DKDEVS ; then
				md_labeldisk $resp
			else
				echo ""
				echo "The disk $resp does not exist."
			fi
			;;
	esac
@


1.110
log
@isnumeric did not check the last char in a string
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.109 1998/10/28 17:51:14 millert Exp $
d457 1
a457 1
	# replace it's entry.
d1130 1
a1130 1
	echo "You may de-select a set by prepending a '-' to it's name."
d1188 1
a1188 1
		echo "You may de-select a file by prepending a '-' to it's name."
d1290 1
a1290 1
	echo "You may de-select a set by prepending a '-' to it's name."
d1347 1
a1347 1
		echo "You may de-select a file by prepending a '-' to it's name."
@


1.109
log
@Move md_copy_kernel after install_sets and add check_kernel (which
should probably be used instead of md_copy_kernel once I am sure
nothing actually uses md_copy_kernel to copy the kernel any more).
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.108 1998/10/19 19:22:18 deraadt Exp $
d231 1
a231 1
	while [ ${#_a} != 1 ]; do
@


1.108
log
@oops
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.107 1998/10/19 09:36:58 todd Exp $
d2084 20
@


1.107
log
@add xshare
it is shared across all X platforms and came from xbase so it IS required.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.106 1998/10/19 05:28:07 deraadt Exp $
d77 2
a78 2
ALLSETS="base etc misc comp text man game xbase xshare xman xfont xserv"	# install
UPGRSETS="base misc comp text man game xbase xshare xman xfont xserv"		# upgrade
@


1.106
log
@load xshare
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.105 1998/10/18 20:31:46 millert Exp $
d77 2
a78 2
ALLSETS="base etc misc comp text man game xbase xman xfont xserv"	# install
UPGRSETS="base misc comp text man game xbase xman xfont xserv"		# upgrade
@


1.105
log
@Check for selection == empty string in glob_selection so we don't get syntax errors when we use that as part of a case statement
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.104 1998/10/11 02:50:47 deraadt Exp $
d77 2
a78 2
ALLSETS="base etc misc comp text man game xbase xfont xserv"	# default install sets
UPGRSETS="base misc comp text man game xbase xfont xserv"	# default upgrade sets
@


1.104
log
@prettier prompts
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.103 1998/10/10 20:54:24 deraadt Exp $
d823 4
@


1.103
log
@move blank line in extraction process
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.102 1998/10/10 08:42:29 deraadt Exp $
d1403 1
a1403 1
	echo -n "Partition? [c] "
d1427 1
a1427 1
	echo -n "Which filesystem type? [cd9660] "
@


1.102
log
@non-verbose tar extract for cd install too
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.101 1998/09/30 08:02:26 deraadt Exp $
d1322 1
a1323 1
		echo ""
@


1.101
log
@significant enhancements to the ftp/http fetching areas
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.100 1998/09/28 13:38:39 deraadt Exp $
d1328 1
a1328 1
			ftp -V -m -o - file:$1/$_f | (cd /mnt; tar -zxvpf -)
@


1.100
log
@use ftp file:/ URL support for filebased (cdrom, nfs, etc) installs
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.99 1998/09/28 13:28:36 deraadt Exp $
d228 13
d242 1
a242 1
        # return available network devices
d932 7
a938 1
	ftp ${_ftp_active} -V -a -o - ftp://ftp.openbsd.org/pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/ftplist | grep "^${_url_type}:"
d945 5
a949 1
	eval echo -n "Server IP address or hostname? [\$_${_url_type}_server_ip]\ "
d951 25
a975 1
	eval _${_url_type}_server_ip=$resp
@


1.99
log
@toast the obviously untested nfs changes
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.98 1998/09/28 12:34:06 deraadt Exp $
d1279 1
a1279 1
			cp $1/$_f /mnt/$_f
d1281 1
a1281 1
			cat $1/$_f | (cd /mnt; tar -zxvpf -)
@


1.98
log
@nfs root patches; todd@@
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.97 1998/09/24 21:55:08 deraadt Exp $
d132 1
a132 1
	return
d366 1
a366 1
	_DKDEVS=`md_get_diskdevs; echo nfs`
d371 3
a373 1
	if [ "X${resp}" = "X" -o "X${resp}" = "Xdone" ]; then
d395 1
a395 1
	_DKDEVS=`md_get_diskdevs; echo nfs`
d1604 1
a1604 1
	return 1
@


1.97
log
@totally gruesome dhcp hacks.. for bad bad dhcp servers... like shaw
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.96 1998/09/24 06:39:07 millert Exp $
d132 1
a132 1
	return 1
d366 1
a366 1
	_DKDEVS=`md_get_diskdevs`
d371 1
a371 3
	if [ "X${resp}" = "X" ]; then
		DISK=done
	elif [ "X${resp}" = "Xdone" ]; then
d393 1
a393 1
	_DKDEVS=`md_get_diskdevs`
d1602 1
a1602 1
	return
@


1.96
log
@Make cutword operate on all lines of a file, not just the first,
so we can use it like cut(1).  Also fix a typo.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.95 1998/09/24 06:13:09 millert Exp $
a604 1
		echo ""
d617 6
d636 1
a636 1
			echo "DHCP configuration of $_interface_name failed."
d638 29
a666 1
			return 1
@


1.95
log
@use cutword instead of sed
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.94 1998/09/23 07:22:34 deraadt Exp $
d169 1
a169 1
# read a line of data, return Nth element.
d181 5
a185 1
	read _a; set -- $_a
a186 2
	if [ "$1" = "" ]; then return; fi
	eval echo \$$_n
d230 1
a230 1
	/sbin/ifconfig -a | egrep -v '^([[:space:]]|(lo|enc|ppp|sl|tun)[[:digit:]])' | cutword -t: 1`
@


1.94
log
@better example
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.93 1998/09/20 08:50:16 deraadt Exp $
d228 1
a228 1
	/sbin/ifconfig -a | egrep -v '^([[:space:]]|(lo|enc|ppp|sl|tun)[[:digit:]])' | sed 's/:.*//'
@


1.93
log
@use dhclient -1: permits retrying of dhcp configurations
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.92 1998/09/19 23:02:49 deraadt Exp $
d601 2
a602 2
		echo "If the default is not satisfactory, and you wish to use"
		echo "another media, copy that line from above."
@


1.92
log
@use new ftp -m mode for status bar
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.91 1998/09/19 23:02:16 deraadt Exp $
d616 1
a616 1
		dhclient ${_interface_name}
@


1.91
log
@media directives; not link-layer arguments
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.90 1998/09/19 07:05:11 deraadt Exp $
d1081 1
d1083 1
a1083 1
		echo ""
d1085 1
a1085 1
			( cd /mnt ; ftp ${_ftp_active} -V ${_url_base}/${_f} )
d1087 1
a1087 1
			( cd /mnt ; ftp ${_ftp_active} -o - -V ${_url_base}/${_f} | tar zxvpf - )
@


1.90
log
@apply media directives before running dhclient
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.89 1998/09/19 07:03:24 deraadt Exp $
d458 1
a458 1
	# $5 - (optional) interface link-layer directives
d599 1
d602 1
a602 2
		echo "another media, enter it now, like:"
		echo "        media 100baseTX mediaopt full-duplex"
d604 1
a604 1
		echo -n "Additional link-layer arguments? [$_interface_extra] "
@


1.89
log
@fix a mistake; jbi130@@mail.usask.ca
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.88 1998/09/18 18:40:51 deraadt Exp $
d615 1
@


1.88
log
@support media directives on dhcp interfaces
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.87 1998/09/17 23:24:32 deraadt Exp $
d461 2
a462 2
	if [ "$3" = "dhcp NONE NONE NONE $5" ]; then
		echo "dhcp" > /tmp/hostname.$1
@


1.87
log
@detect dhclient failing and re-query.  (there may be a dhclient process lying
around, and i cannot figure out how to kill it yet)
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.86 1998/09/17 01:25:16 deraadt Exp $
d461 1
a461 1
	if [ "$3" = "dhcp" ]; then
d681 1
a681 1
		    echo "/etc/hostname.$1: invalid network configuration file"
@


1.86
log
@do not permit duplicate hostnames in /etc/hosts
encode /etc/hostname.* files with an IP address, not a hostname
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.85 1998/09/17 00:50:01 deraadt Exp $
d513 1
d517 2
a522 1
			_ouranswer="done"
d615 17
a631 1
		if dhclient ${_interface_name} ; then
@


1.85
log
@pretty up device unmounting
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.84 1998/09/17 00:44:35 deraadt Exp $
d441 1
a441 1
	# exists, create one.  If the IP address already exists,
d447 1
a447 1
	sed "/^$1 /d" < /tmp/hosts > /tmp/hosts.new
d465 1
a465 1
		echo "inet $2 $4 NONE $5" > /tmp/hostname.$1
@


1.84
log
@permit re-configuring of ip addresses..
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.83 1998/09/15 21:48:27 deraadt Exp $
d1941 1
a1941 1
	echo "Done."
@


1.83
log
@add dhclient support; jbi130@@mail.usask.ca and I
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.82 1998/09/14 15:16:01 millert Exp $
d554 4
d612 8
a619 22
	if [ $_up != "UP" ]; then
		if [ "$_interface_ip" = "dhcp" ]; then
			if dhclient ${_interface_name} ; then
				echo "DHCP configuration of $_interface_name successful."
				addifconfig \
					${_interface_name} \
					${_interface_symname} \
					${_interface_ip}
				return 0
			fi
		else
			ifconfig ${_interface_name} down
			if ifconfig ${_interface_name} inet \
			    ${_interface_ip} \
			    netmask ${_interface_mask} ${_interface_extra} up ; then
				addifconfig \
				    ${_interface_name} \
				    ${_interface_symname} \
				    ${_interface_ip} \
				    ${_interface_mask} "${_interface_extra}"
				return 0
			fi
d622 2
a623 5
		echo "Interface ${_interface_name} is already active."
		echo "Just saving configuration on new root filesystem."
		addifconfig \
		    ${_interface_name} \
		    ${_interface_symname} \
d625 8
a632 1
		    ${_interface_mask} "${_interface_extra}"
@


1.82
log
@use sed, not cut since not all platforms have cut on the floppy
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.81 1998/09/12 08:33:57 deraadt Exp $
d72 1
a72 1
VERSION=23
d371 2
d461 7
a467 3
	echo "inet $2 $4 NONE $5" > /tmp/hostname.$1

	addhostent $3 $2
d557 1
a557 1
		echo -n "IP address? [$_interface_ip] "
d572 10
a581 3
	resp=""
	if [ "X${_interface_mask}" = X"" ]; then
		_interface_mask=255.255.255.0
a582 5
	while [ "X${resp}" = X"" ]; do
		echo -n "Netmask ? [$_interface_mask] "
		getresp "$_interface_mask"
		_interface_mask=$resp
	done
d609 12
a620 7
		ifconfig ${_interface_name} down
		if ifconfig ${_interface_name} inet \
		    ${_interface_ip} \
		    netmask ${_interface_mask} ${_interface_extra} up ; then
			addifconfig \
			    ${_interface_name} \
			    ${_interface_symname} \
d622 8
a629 2
			    ${_interface_mask} "${_interface_extra}"
			return 0
@


1.81
log
@handle ifconfig media support; remove link0-2 support
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.80 1998/09/11 22:45:52 millert Exp $
d228 1
a228 1
	/sbin/ifconfig -a | egrep -v '^([[:space:]]|(lo|enc|ppp|sl|tun)[[:digit:]])' | cut -f 1 -d :
@


1.80
log
@mi get_ifdevs()
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.79 1998/07/09 00:02:34 millert Exp $
d537 6
a542 5
		2s/inet//
		2s/--> [0-9.][0-9.]*//
		2s/netmask//
		2s/broadcast//
		2p'`
d576 19
a594 11
	echo "Your network interface might require additional link-layer"
	echo "directives (like \`link0'). If this is the case you can enter"
	echo "these at the next prompt.  Values used by some drivers are:"
	echo "    -link0            BNC"
	echo "    link0 -link1      AUI"
	echo "    link0 link1       UTP"
	echo "(But please keep in mind not all drivers use flags like this)."
	echo -n "Additional link-layer arguments? [$_interface_extra] "
	getresp "$_interface_extra"
	if [ "X${resp}" != X"" ]; then
		_interface_extra=$resp
d689 1
a689 1
	ifconfig -a
@


1.79
log
@treat 'all' just like '*'
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.78 1998/06/25 16:35:26 millert Exp $
d226 5
d470 1
a470 1
	_IFS=`md_get_ifdevs`
@


1.78
log
@use POSIX sh builtin arithmetic, not expr
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.77 1998/06/05 01:24:15 deraadt Exp $
d742 3
a1008 4
	elif [ "X${resp}" = X"all" ]; then
		_get_files="$_sets $_kernel"
		_setsdone="$_sets $_kernel"
		break
a1167 4
	elif [ "X${resp}" = X"all" ]; then
		_get_files="$_sets $_kernel"
		_setsdone="$_sets $_kernel"
		break
@


1.77
log
@continent; map@@stacken.kth.se
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.76 1998/04/28 16:25:03 millert Exp $
d72 1
a72 1
VERSION=
d1584 1
a1584 1
			_nskip=`expr $resp - 1`
@


1.76
log
@move globbing code into its own function
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.75 1998/04/15 15:21:07 deraadt Exp $
d1655 5
a1659 5
Select a time zone for your location. Timezones are represented on the
system by a directory structure rooted in "/usr/share/timezone". Most
timezones can be selected by entering a token like "MET" or "GMT-6".
Other zones are grouped by continent, with detailed zone information
separated by a slash ("/"), e.g. "US/Pacific" or "Canada/Mountain".
@


1.75
log
@spelling
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.74 1998/04/14 17:25:31 millert Exp $
d719 55
a788 3
local _tfile
local _matched
local _action
d1012 1
a1012 42
	# Change +/- into add/remove
	_action=add
	case "$resp" in
		+*)	resp="${resp#?}"
			;;
		-*)	resp="${resp#?}"
			_action=remove
			;;
	esac

	# Major hack to allow the user to select globbing patterns
	set -o noglob
	_tfile=/tmp/install_case.$$	# safe in single user mode
	cat >$_tfile << OOF
	case \$_f in
		$resp)	# Add/remove file to extraction list
			if [ "\$_action" = "add" ]; then
				_get_files=\`addel \${_f} \${_get_files}\`
				_setsdone=\`addel \${_f} \${_setsdone}\`
			elif [ "\$_action" = "remove" ]; then
				_get_files=\`rmel \${_f} \${_get_files}\`
				_setsdone=\`rmel \${_f} \${_setsdone}\`
			else
				echo "Unknown action: \$_action"
			fi
			_matched=\$(( \$_matched + 1 ))
			;;
	esac
OOF
	set +o noglob

	# Eww.
	_matched=0
	for _f in $_sets $_kernel; do
		. $_tfile
	done
	rm -f $_tfile

	if [ $_matched -eq 0 ]; then
		eval echo "File \$_${_url_type}_server_dir/$resp does not exist.  Check to make"
		echo "sure you entered the information properly or enter 'list' for a file list."
	fi
d1070 1
a1070 42
		# Change +/- into add/remove
		_action=add
		case "$resp" in
			+*)	resp="${resp#?}"
				;;
			-*)	resp="${resp#?}"
				_action=remove
				;;
		esac

		# Major hack to allow the user to select globbing patterns
		set -o noglob
		_tfile=/tmp/install_case.$$	# safe in single user mode
		cat >$_tfile << OOF
		case \$_f in
			$resp)	# Add/remove file to extraction list
				if [ "\$_action" = "add" ]; then
					_get_files=\`addel \${_f} \${_get_files}\`
					_setsdone=\`addel \${_f} \${_setsdone}\`
				elif [ "\$_action" = "remove" ]; then
					_get_files=\`rmel \${_f} \${_get_files}\`
					_setsdone=\`rmel \${_f} \${_setsdone}\`
				else
					echo "Unknown action: \$_action"
				fi
				_matched=\$(( \$_matched + 1 ))
				;;
		esac
OOF
		set +o noglob

		# Eww.
		_matched=0
		for _f in $_failed_files; do
			. $_tfile
		done
		rm -f $_tfile

		if [ $_matched -eq 0 ]; then
			eval echo "File \$_${_url_type}_server_dir/$resp does not exist.  Check to make"
			echo "sure you entered the information properly or enter 'list' for a file list."
		fi
a1082 3
local _tfile
local _matched
local _action
d1175 1
a1175 42
	# Change +/- into add/remove
	_action=add
	case "$resp" in
		+*)	resp="${resp#?}"
			;;
		-*)	resp="${resp#?}"
			_action=remove
			;;
	esac

	# Major hack to allow the user to select globbing patterns
	set -o noglob
	_tfile=/tmp/install_case.$$	# safe in single user mode
	cat >$_tfile << OOF
	case \$_f in
		$resp)	# Add/remove file to extraction list
			if [ "\$_action" = "add" ]; then
				_get_files=\`addel \${_f} \${_get_files}\`
				_setsdone=\`addel \${_f} \${_setsdone}\`
			elif [ "\$_action" = "remove" ]; then
				_get_files=\`rmel \${_f} \${_get_files}\`
				_setsdone=\`rmel \${_f} \${_setsdone}\`
			else
				echo "Unknown action: \$_action"
			fi
			_matched=\$(( \$_matched + 1 ))
			;;
	esac
OOF
	set +o noglob

	# Eww.
	_matched=0
	for _f in $_sets $_kernel; do
		. $_tfile
	done
	rm -f $_tfile

	if [ $_matched = 0 ]; then
	    echo "File $1/$resp does not exist.  Check to make"
	    echo "sure you entered the information properly or enter 'list' for a file list."
	fi
d1233 1
a1233 42
		# Change +/- into add/remove
		_action=add
		case "$resp" in
			+*)	resp="${resp#?}"
				;;
			-*)	resp="${resp#?}"
				_action=remove
				;;
		esac

		# Major hack to allow the user to select globbing patterns
		set -o noglob
		_tfile=/tmp/install_case.$$	# safe in single user mode
		cat >$_tfile << OOF
		case \$_f in
			$resp)	# Add/remove file to extraction list
				if [ "\$_action" = "add" ]; then
					_get_files=\`addel \${_f} \${_get_files}\`
					_setsdone=\`addel \${_f} \${_setsdone}\`
				elif [ "\$_action" = "remove" ]; then
					_get_files=\`rmel \${_f} \${_get_files}\`
					_setsdone=\`rmel \${_f} \${_setsdone}\`
				else
					echo "Unknown action: \$_action"
				fi
				_matched=\$(( \$_matched + 1 ))
				;;
		esac
OOF
		set +o noglob

		# Eww.
		_matched=0
		for _f in $_failed_files; do
			. $_tfile
		done
		rm -f $_tfile

		if [ $_matched = 0 ]; then
		    echo "File $1/$resp does not exist.  Check to make"
		    echo "sure you entered the information properly or enter 'list' for a file list."
		fi
@


1.74
log
@1) If the user selects a set multiple times in a session only
   extract once.  This is a problem now that default sets are
   selected automatically.
2) Don't select any default sets that have already been installed.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.73 1998/04/13 16:12:28 deraadt Exp $
d924 1
a924 1
"Consult the intallation notes if you are not sure which sets are required!"
@


1.73
log
@ls -F the zoneinfo files, shows what is a zone-dir and what is a zone-file
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.72 1998/04/05 23:53:17 deraadt Exp $
d135 20
d162 1
a162 1
			echo "$1";
d930 4
a933 2
			_get_files="${_get_files} ${_f}"
			_setsdone="${_f} ${_setsdone}"
a954 2
		# XXX - setting _setsdone like this
		#       is not entirely correct.
d977 2
a978 2
				_get_files="\${_get_files} \$_f"
				_setsdone="\$_f \$_setsdone"
d980 2
a981 2
				_get_files=\`rmel \$_f \$_get_files\`
				_setsdone=\`rmel \$_f \$_setsdone\`
d1076 2
a1077 2
					_get_files="\${_get_files} \$_f"
					_setsdone="\$_f \$_setsdone"
d1079 2
a1080 2
					_get_files=\`rmel \$_f \$_get_files\`
					_setsdone=\`rmel \$_f \$_setsdone\`
d1178 4
a1181 2
			_get_files="${_get_files} ${_f}"
			_setsdone="${_f} ${_setsdone}"
a1202 2
		# XXX - setting _setsdone like this
		#       is not entirely correct.
d1225 2
a1226 2
				_get_files="\${_get_files} \$_f"
				_setsdone="\$_f \$_setsdone"
d1228 2
a1229 2
				_get_files=\`rmel \$_f \$_get_files\`
				_setsdone=\`rmel \$_f \$_setsdone\`
d1324 2
a1325 2
					_get_files="\${_get_files} \$_f"
					_setsdone="\$_f \$_setsdone"
d1327 2
a1328 2
					_get_files=\`rmel \$_f \$_get_files\`
					_setsdone=\`rmel \$_f \$_setsdone\`
@


1.72
log
@look for seperate xfont archives
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.71 1998/04/03 18:56:13 deraadt Exp $
d1774 1
a1774 1
		ls ${_zonepath}/usr/share/zoneinfo
d1784 1
a1784 1
			"?") ls ${_zonepath}/usr/share/zoneinfo/$_a ;;
@


1.71
log
@another timezone example
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.70 1998/04/01 20:21:49 millert Exp $
d77 2
a78 2
ALLSETS="base etc misc comp text man game xbase xserv"	# default install sets
UPGRSETS="base misc comp text man game xbase xserv"	# default upgrade sets
@


1.70
log
@move xlink to i386 md sets
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.69 1998/03/31 03:22:01 millert Exp $
d1754 1
a1754 1
separated by a slash ("/"), e.g. "US/Pacific".
@


1.69
log
@Kill unnecesary newline.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.68 1998/03/30 20:56:37 deraadt Exp $
d77 2
a78 2
ALLSETS="base etc misc comp text man game xbase xserv xlink"	# default install sets
UPGRSETS="base misc comp text man game xbase xserv xlink"	# default upgrade sets
@


1.68
log
@know about X sets
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.67 1998/03/29 20:34:02 millert Exp $
d904 1
a904 1
"Consult the intallation notes if you are not sure which sets are required!\\\\n"
d1152 1
a1152 1
"Consult the intallation notes if you are not sure which sets are required!\n"
@


1.67
log
@Select base*, etc* and bsd by default in the file selector.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.66 1998/03/29 19:54:50 millert Exp $
d77 2
a78 2
ALLSETS="base etc misc comp text man game"	# default install sets
UPGRSETS="base misc comp text man game"		# default upgrade sets
@


1.66
log
@Allow +/- in file selector (works with glob patterns too).
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.65 1998/03/29 17:48:16 millert Exp $
d906 11
d1154 11
@


1.65
log
@glob against files in the selector not in the total file list
(although it would be nice to be able to do that too).
Now '*' does what the user might expect.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.64 1998/03/29 01:11:32 millert Exp $
d716 1
d910 1
d929 10
d944 10
a953 3
		$resp)	# Add file to extraction list
			_get_files="\${_get_files} \$_f"
			_setsdone="\$_f \$_setsdone"
d1014 1
d1028 10
d1043 10
a1052 3
			$resp)	# Add file to extraction list
				_get_files="\${_get_files} \$_f"
				_setsdone="\$_f \$_setsdone"
d1084 1
d1147 1
d1166 10
d1181 10
a1190 3
		$resp)	# Add file to extraction list
			_get_files="\${_get_files} \${_f}"
			_setsdone="\${_f} \${_setsdone}"
d1251 1
d1265 10
d1280 10
a1289 3
			$resp)	# Add file to extraction list
				_get_files="\${_get_files} \${_f}"
				_setsdone="\${_f} \${_setsdone}"
@


1.64
log
@Fix a typo
Move fileset selector code into its own function
Add support for globbing patters in the file selector (needs documenting)
    Ie: `*.gz' or even `*23.tar.gz|bsd'
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.63 1998/03/28 21:40:46 deraadt Exp $
d943 1
a943 1
	for _f in $_file_list; do
d1024 1
a1024 1
		for _f in $_file_list; do
d1143 1
a1143 1
	for _f in `cd $1 && echo *`; do
d1224 1
a1224 1
		for _f in `cd $1 && echo *`; do
@


1.63
log
@oops
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.62 1998/03/28 21:06:53 deraadt Exp $
d100 1
d120 1
d672 21
a692 5
install_url() {
	# Get several parameters from the user, and xfer
	# files from the server.
	# Note:	_ftp_server_ip, _ftp_server_dir, _ftp_server_login,
	#	_ftp_server_password, and _ftp_active must be global.
d694 4
a697 48
	local _sets
	local _kernel
	local _f
	local _file_list
	local _get_files
	local _failed_files
	local _osetsdone
	local _url_type
	local _url_base

	# Is this an ftp or http install?
	_url_type=$1; shift

	echo
	echo "This is an automated ${_url_type}-based installation process.  You will be asked"
	echo "questions and then the files will be retrieved iteratively via ftp(1)."
	echo
	    
	# Proxy the connections?
	if [ "X${_proxy_host}" = X"" ]; then
		_proxy_host=none
	fi
	echo -n "HTTP/FTP proxy URL? (if you use a proxy) [${_proxy_host}] "
	getresp "${_proxy_host}"
	if [ "X${resp}" = X"none" ]; then
		unset _proxy_host ftp_proxy http_proxy
	else
		_proxy_host=$resp
		export ftp_proxy=${_proxy_host}
		export http_proxy=${_proxy_host}
	fi
	if [ "${_url_type}" = "ftp" -a "X$ftp_proxy" = "X" ]; then
		# Use active mode ftp? (irrelevant if using a proxy)
		case "${_ftp_active}" in
			-A)	resp=y ;;
			*)	resp=n ;;
		esac
		echo "By default, ftp will attempt a passive connection and fall back to a normal"
		echo "(active) connection if that doesn't work.  However, there are some very"
		echo "old ftp servers that claim to support passive mode, but really do not."
		echo "In this case, you should explicately request an active session."
		echo -n "Do you want to use active ftp? [${resp}] "
		getresp "${resp}"
		case "$resp" in
			y*|Y*)	_ftp_active=-A ;;
			*)	unset _ftp_active ;;
		esac
	fi
d699 51
a749 3
	# Provide a list of possible servers
	echo -n "Do you want a list of potential ${_url_type} servers? [y] "
	getresp "y"
d751 2
a752 4
	n*|N*) ;;
	*)
		ftp ${_ftp_active} -V -a -o - ftp://ftp.openbsd.org/pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/ftplist | grep "^${_url_type}:"
		;;
d754 1
d756 38
a793 7
	# Get server IP address
	resp=""		# force one iteration
	while [ "X${resp}" = X"" ]; do
		eval echo -n "Server IP address or hostname? [\$_${_url_type}_server_ip]\ "
		eval getresp "\$_${_url_type}_server_ip"
		eval _${_url_type}_server_ip=$resp
	done
d795 1
a795 5
	# Get server directory
	if [ "${_url_type}" = "ftp" -a "X${_ftp_server_dir}" = X"" ]; then
		# Default ftp dir
		_ftp_server_dir="pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}"
	fi
d798 3
a800 3
		eval echo -n "Server directory? [\$_${_url_type}_server_dir]\ "
		eval getresp "\$_${_url_type}_server_dir"
		eval _${_url_type}_server_dir=$resp
d803 2
a804 10
	if [ "${_url_type}" = "ftp" ]; then
		# Need default values even if we proxy ftp...
		if [ "X${_ftp_server_login}" = X"" ]; then
			_ftp_server_login=anonymous
		fi
		if [ "X${_ftp_server_password}" = X"" ]; then
			_ftp_server_password=root@@`hostname`.${FQDN}
		fi

		# Get login name
d807 16
a822 3
			echo -n "Login? [${_ftp_server_login}] "
			getresp "${_ftp_server_login}"
			_ftp_server_login=$resp 
d824 3
a826 26

		# Get password unless anonymous
		if [ ${_ftp_server_login} != "anonymous" ]; then
			resp=""		# force one iteration
			while [ "X${resp}" = X"" ]; do
				echo -n "Password (will not echo): "
				stty -echo
				getresp "${_ftp_server_password}"
				stty echo
				echo ""
				_ftp_server_password=$resp

				echo -n "Password (again): "
				stty -echo
				getresp "${_ftp_server_password}"
				stty echo
				echo ""
				if [ "${_ftp_server_password}" != "${resp}" ]; then
					echo "Passwords do not match, try again."
					resp=""
				fi
			done
		else
			# only used by ftp_list_files()
			_ftp_server_password=root@@`hostname`.${FQDN}
		fi
d828 1
d830 6
a835 6
	# Build up the base url since it is so nasty...
	if [ "${_url_type}" = "ftp" -a "${_ftp_server_login}" != "anonymous" ]; then
		eval _url_base=${_url_type}://${_ftp_server_login}:${_ftp_server_password}@@\$_${_url_type}_server_ip/\$_${_url_type}_server_dir
	else
		eval _url_base=${_url_type}://\$_${_url_type}_server_ip/\$_${_url_type}_server_dir
	fi
d837 9
a845 9
	# Get list of files from the server.
	# XXX - check for nil $_file_list and deal
	if [ "${_url_type}" = "ftp" -a "X${ftp_proxy}" = X"" ]; then
		_file_list=`ftp_list_files "$_ftp_server_ip" "$_ftp_server_login" "$_ftp_server_password" "$_ftp_server_dir"`
	else
		# Assumes index file is "index.txt" for http (or proxy)
		# We can't use index.html since the format is server-dependent
		_file_list=`ftp -o - -V ${_url_base}/index.txt | sed 's///'`
	fi
d847 22
d870 9
a878 15
	if list_has_sets "$_file_list" $THESETS; then
		for _f in $THESETS ; do
			if [ "X${_f}" = "Xkernel" ]; then
				if isin bsd $_file_list; then
					_kernel=bsd
				fi
			elif isin ${_f}${VERSION}.tar.gz $_file_list; then
				_sets="$_sets ${_f}${VERSION}.tar.gz"
			elif isin ${_f}${VERSION}.tgz $_file_list; then
				_sets="$_sets ${_f}${VERSION}.tgz"
			fi
		done
	else
		eval echo "There are no OpenBSD install sets available in \"\$_${_url_type}_server_dir\"."
		echo -n "Search for *.tar.gz and *.tgz files? [y] "
d884 6
a889 23
		# *.tar.gz and *.tgz are possible sets
		_sets=""
		_kernel=""
		for _f in ${_file_list} ; do
			case "$_f" in
			    *.tar.gz|*.tgz)	_sets="$_sets ${_f}"
			esac
		done
		if [ "X${_sets}" = X"" ]; then
			echo "There are no *.tar.gz or *.tgz files in that dir."
			echo -n "See a directory listing? [y] "
			getresp "y"
			case "$resp" in
				n*|N*)	return ;;
				*)	;;
			esac
			echo ""
			echo "${_file_list}"
			echo ""
			return
		else
			echo "Adding *.tar.gz and *.tgz files to selector."
		fi
d891 1
d893 2
a894 2
	# Yes, all those blackslashes really are necesary...
	eval echo "\\\\n"\
d904 11
a914 2
	_osetsdone="$_setsdone"
	while : ; do
d916 60
a975 2
		echo "The following sets are available for extraction."
		echo "Enter filename, \`list', \`all', or \`done'."
d977 11
d989 8
a996 13
		_next=""
		for _f in $_sets $_kernel ; do
			if isin $_f $_setsdone ; then
				echo -n "	[X] "
				_next=""
			else
				echo -n "	[ ] "
				if [ -z "$_next" ]; then
				    _next=$_f
				fi
			fi
			echo $_f
		done
a997 3
		# Get the name of the file.
		echo -n "File name [$_next]? "
		getresp "$_next"
d1004 1
a1005 6
		elif [ "X${resp}" = X"all" ]; then
			# XXX - setting _setsdone like this
			#       is not entirely correct.
			_get_files="$_sets $_kernel"
			_setsdone="$_sets $_kernel"
			break
a1006 1
		_f=$resp
d1008 23
a1030 3
		# Ensure file exists
		if ! isin $_f $_file_list ; then
			eval echo "File \$_${_url_type}_server_dir/$_f does not exist.  Check to make"
a1031 1
			continue
a1032 4

		# Add file to extraction list
		_get_files="${_get_files} $_f"
		_setsdone="$_f $_setsdone"
d1034 2
d1037 15
a1051 4
	# User may have said "done" without selecting any files
	if [ "X${_get_files}" = X"" ]; then
		return
	fi
d1053 16
a1068 3
	echo
	echo "Fetching files via ${_url_type} may take a long time, especially over a slow network"
	echo -n "connection.  Ready to download files? [y] "
d1071 2
a1072 6
		y*|Y*)
			;;
		*)
			_setsdone="$_osetsdone"
			return
			;;
d1074 1
a1074 81

	# Download the files one at a time and keep track of which ones failed
	while test -n "${_get_files}" ; do
		_failed_files=""
		for _f in $_get_files ; do
			echo ""
			if [ "X${_f}" = "X${_kernel}" ]; then
				( cd /mnt ; ftp ${_ftp_active} -V ${_url_base}/${_f} )
			else
				( cd /mnt ; ftp ${_ftp_active} -o - -V ${_url_base}/${_f} | tar zxvpf - )
			fi
			if [ $? -ne 0 ]; then
				# Mark xfer as having failed,.
				_setsdone=`rmel $_f $_setsdone`
				_failed_files="${_failed_files} ${_f}"
			fi
		done

		# Give them the option of refetching failed files.
		_get_files=""
		while test -n "${_failed_files}" ; do
			echo ""
			echo "The following files failed to transfer and extract correctly:"
			echo "Choose which one(s) to refetch or 'done' to exit selector."
			echo ""

			_next=""
			for _f in $_failed_files ; do
				if isin $_f $_setsdone ; then
					echo -n "	[X] "
					_next=""
				else
					echo -n "	[ ] "
					if [ -z "$_next" ]; then
						_next=$_f
					fi
				fi
				echo $_f
			done
			echo ""

			# Get the name of the file.
			echo -n "File name [$_next]? "
			getresp "$_next"
			if [ "X${resp}" = X"done" ]; then
				break
			elif [ "X${resp}" = X"list" ]; then
				echo ""
				eval echo "\$_${_url_type}_server_dir:"
				echo "${_file_list}"
				echo ""
				continue
			fi
			_f=$resp

			# Ensure file exists
			if ! isin $_f $_file_list ; then
				eval echo "File \$_${_url_type}_server_dir/$_f does not exist.  Check to make"
				echo "sure you entered the information properly."				continue
			fi
			# Add file to extraction list
			_get_files="${_get_files} ${_f}"
			_setsdone="${_f} ${_setsdone}"
		done
	done
}

install_from_mounted_fs() {
	# $1 - directory containing installation sets
	local _sets
	local _kernel
	local _f
	local _get_files
	local _failed_files
	local _osetsdone

	if [ ! -d $1 ]; then
		echo "No such directory: $1"
		return
	fi

d1076 5
a1080 15
	if dir_has_sets $1 $THESETS; then
		for _f in $THESETS ; do
			if [ "X${_f}" = "Xkernel" ]; then
				if [ -f $1/bsd ]; then
					_kernel=bsd
				fi
			elif [ -f $1/${_f}${VERSION}.tar.gz ]; then
				_sets="$_sets ${_f}${VERSION}.tar.gz"
			elif [ -f $1/${_f}${VERSION}.tgz ]; then
				_sets="$_sets ${_f}${VERSION}.tgz"
			fi
		done
	else
		echo "There are no OpenBSD install sets available in \"$1\"."
		echo -n "Search for *.tar.gz and *.tgz files? [y] "
d1086 6
a1091 19
		# *.tar.gz and *.tgz are possible sets
		_sets=""
		_kernel=""
		_sets=`cd $1 ; echo *.tar.gz *.tgz`
		if [ "X${_sets}" = X'*.tar.gz *.tgz' ]; then
			echo "There are no *.tar.gz or *.tgz files in that dir."
			echo -n "See a directory listing? [y] "
			getresp "y"
			case "$resp" in
				n*|N*)	return ;;
				*)	;;
			esac
			echo ""
			( cd $1 && ls )
			echo ""
			return
		else
			echo "Adding *.tar.gz and *.tgz files to selector."
		fi
d1093 1
d1095 1
a1095 1
	echo "\n"\
d1103 12
a1114 3
"Consult the intallation notes if you are not sure which sets are required!\n"\
	_osetsdone="$_setsdone"
	while : ; do
d1116 59
a1174 2
		echo "The following sets are available for extraction."
		echo "Enter filename, \`list', \`all', or \`done'."
d1176 12
d1189 8
a1196 13
		_next=""
		for _f in $_sets $_kernel ; do
			if isin $_f $_setsdone ; then
				echo -n "	[X] "
				_next=""
			else
				echo -n "	[ ] "
				if [ -z "$_next" ]; then
				    _next=$_f
				fi
			fi
			echo $_f
		done
a1197 3
		# Get the name of the file.
		echo -n "File name [$_next]? "
		getresp "$_next"
d1204 1
a1205 6
		elif [ "X${resp}" = X"all" ]; then
			# XXX - setting _setsdone like this
			#       is not entirely correct.
			_get_files="$_sets $_kernel"
			_setsdone="$_sets $_kernel"
			break
a1206 1
		_f=$resp
d1208 13
a1220 11
		# Ensure file exists
		if [ ! -f $1/$_f ]; then
			echo "File $1/$_f does not exist.  Check to make"
			echo "sure you entered the information properly."
			continue
		fi

		# Add file to extraction list
		_get_files="${_get_files} $_f"
		_setsdone="$_f $_setsdone"
	done
d1222 4
a1225 33
	# User may have said "done" without selecting any files
	if [ "X${_get_files}" = X"" ]; then
		return
	fi

	echo
	echo -n "Ready to extract selected file sets? [y] "
	getresp "y"
	case "$resp" in
		y*|Y*)
			;;
		*)
			_setsdone="$_osetsdone"
			return
			;;
	esac

	# Extract the files one at a time and keep track of which ones failed
	while test -n "${_get_files}" ; do
		_failed_files=""
		for _f in $_get_files ; do
			echo ""
			echo "$1/${_f}:"
			if [ "X${_f}" = "X${_kernel}" ]; then
				cp $1/$_f /mnt/$_f
			else
				cat $1/$_f | (cd /mnt; tar -zxvpf -)
			fi
			if [ $? -ne 0 ]; then
				# Mark xfer as having failed,.
				_setsdone=`rmel $_f $_setsdone`
				_failed_files="${_failed_files} ${_f}"
			fi
d1227 1
d1229 4
a1232 46
		# Give them the option of retrying failed files.
		_get_files=""
		while test -n "${_failed_files}" ; do
			echo ""
			echo "The following files failed to extract correctly:"
			echo "Choose which one(s) to retry or 'done' to exit selector."
			echo ""

			_next=""
			for _f in $_failed_files ; do
				if isin $_f $_setsdone ; then
					echo -n "	[X] "
					_next=""
				else
					echo -n "	[ ] "
					if [ -z "$_next" ]; then
						_next=$_f
					fi
				fi
				echo $_f
			done
			echo ""

			# Get the name of the file.
			echo -n "File name [$_next]? "
			getresp "$_next"
			if [ "X${resp}" = X"done" ]; then
				break
			elif [ "X${resp}" = X"list" ]; then
				echo ""
				echo "${1}:"
				( cd $1 && ls )
				echo ""
				continue
			fi
			_f=$resp

			# Ensure file exists
			if [ ! -f $1/$_f ]; then
				echo "File $1/$_f does not exist.  Check to make"
				echo "sure you entered the information properly."
			fi
			# Add file to extraction list
			_get_files="${_get_files} ${_f}"
			_setsdone="${_f} ${_setsdone}"
		done
d1234 1
d1238 5
a1242 5
	local _drive
	local _partition_range
	local _partition
	local _fstype
	local _directory
d1244 2
a1245 2
	# Get the cdrom device info
	cat << \__install_cdrom_1
d1251 17
a1267 7
	_CDDEVS=`md_get_cddevs`
	echo    "$_CDDEVS"
	echo	""
	echo -n	"Which is the CD-ROM with the installation media? [abort] "
	getresp "abort"
	case "$resp" in
		abort)
d1270 13
d1286 2
a1287 8
			if isin $resp $_CDDEVS ; then
				_drive=$resp
			else
				echo ""
				echo "The CD-ROM $resp does not exist."
				echo "Aborting."
				return
			fi
d1290 1
d1292 2
a1293 20
	# Get partition
	_partition_range=`md_get_partition_range`
	resp=""		# force one iteration
	while [ "X${resp}" = X"" ]; do
		echo -n "Partition? [c] "
		getresp "c"
		case "$resp" in
			$_partition_range)
				_partition=$resp
				;;

			*)
				echo "Invalid response: $resp"
				resp=""		# force loop to repeat
				;;
		esac
	done

	# Ask for filesystem type
	cat << \__install_cdrom_2
d1296 2
a1297 2
	cd9660		ISO-9660
	ffs		Berkeley Fast Filesystem
d1300 8
a1307 8
	resp=""		# force one iteration
	while [ "X${resp}" = X"" ]; do
		echo -n "Which filesystem type? [cd9660] "
		getresp "cd9660"
		case "$resp" in
			cd9660|ffs)
				_fstype=$resp
				;;
d1309 6
a1314 6
			*)
				echo "Invalid response: $resp"
				resp=""		# force loop to repeat
				;;
		esac
	done
d1316 6
a1321 6
	# Mount the CD-ROM
	if ! mount -t ${_fstype} -o ro \
	    /dev/${_drive}${_partition} /mnt2 ; then
		echo "Cannot mount CD-ROM drive.  Aborting."
		return
	fi
d1323 11
a1333 11
	# Get the directory where the file lives
	if [ "X${_directory}" = X"" ]; then
		_directory="/${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}"
	fi
	resp=""		# force one iteration
	while [ "X${resp}" = X"" ]; do
		echo "Enter the directory relative to the mount point that"
		echo -n "contains the file. [${_directory}] "
		getresp "${_directory}"
	done
	_directory=$resp
d1335 2
a1336 2
	install_from_mounted_fs /mnt2/${_directory}
	umount -f /mnt2 > /dev/null 2>&1
d1340 20
a1359 13
	# Mount a disk on /mnt2. The set of disk devices to choose from
	# is $_DKDEVS.
	# returns 0 on failure.

	local _drive
	local _def_partition
	local _partition_range
	local _partition
	local _fstype
	local _fsopts
	local _directory
	local _md_fstype
	local _md_fsopts
d1361 6
a1366 3
	getresp "abort"
	case "$resp" in
		abort)
d1369 3
a1371 13
			;;

		*)
			if isin $resp $_DKDEVS ; then
				_drive=$resp
			else
				echo ""
				echo "The disk $resp does not exist."
				echo "Aborting."
				return 0
			fi
			;;
	esac
d1373 2
a1374 2
	# Get partition
	cat <<__mount_a_disk_1
d1379 13
a1391 10
	disklabel $_drive 2>/dev/null | grep '^  .:'
	echo
	_likely_partition_range=`disklabel $_drive 2>/dev/null | \
	    sed -n -e '/swap/s/.*//' -e '/unused/s/.*//' \
		-e '/^  .:/{s/^  \(.\).*/\1/;H;}' \
		-e '${g;s/\n//g;s/^/[/;s/$/]/p;}'`
	_partition_range=`disklabel $_drive 2>/dev/null | \
	    sed -n -e '/^  .:/{s/^  \(.\).*/\1/;H;}' \
		-e '${g;s/\n//g;s/^/[/;s/$/]/p;}'`
	_def_partition=`echo $_likely_partition_range | \
d1394 12
a1405 15
		_def_partition=`echo $_partition_range | \
		    sed -n 's/^\[\(.\).*\]/\1/p'`
		if [ -z "$_def_partition" ]; then
			echo "There are no usable partitions on that disk"
			return 0
		fi
	fi 
	resp=""		# force one iteration
	while [ "X${resp}" = X"" ]; do
		echo -n "Partition? [$_def_partition] "
		getresp "$_def_partition"
		case "$resp" in
			$_partition_range)
				_partition=$resp
				;;
d1407 6
a1412 6
			*)
				echo "Invalid response: $resp"
				resp=""		# force loop to repeat
				;;
		esac
	done
d1414 2
a1415 2
	# Ask for filesystem type
	cat << \__mount_a_disk_2
d1418 2
a1419 2
	default		(deduced from the disklabel)
	ffs
d1421 30
a1450 30
	_md_fstype=`md_native_fstype`
	_md_fsopts=`md_native_fsopts`
	if [ ! -z "$_md_fstype" ]; then
		echo "	$_md_fstype"
	else
		_md_fstype="_undefined_"
	fi
	resp=""		# force one iteration
	while [ "X${resp}" = X"" ]; do
		echo -n "Which filesystem type? [default] "
		getresp "default"
		case "$resp" in
			default)
				_fstype=""
				_fsopts="ro"
				;;
			ffs)
				_fstype="-t $resp"
				_fsopts="ro"
				;;
			$_md_fstype)
				_fstype="-t $resp"
				_fsopts=$_md_fsopts
				;;
			*)
				echo "Invalid response: $resp"
				resp=""		# force loop to repeat
				;;
		esac
	done
d1452 6
a1457 6
	# Mount the disk
	if ! mount $_fstype -o $_fsopts /dev/${_drive}${_partition} /mnt2; then
		echo "Cannot mount disk.  Aborting."
		return 0
	fi
	return 1
d1461 1
a1461 1
	local _directory
d1463 1
a1463 1
	cat << \__install_disk_1
d1469 4
a1472 4
	_DKDEVS=`md_get_diskdevs`
	echo    "$_DKDEVS"
	echo	""
	echo -n	"Which is the disk with the installation sets? [abort] "
d1474 3
a1476 3
	if mount_a_disk ; then
		return
	fi
d1478 8
a1485 8
	# Get the directory where the file lives
	resp=""		# force one iteration
	while [ "X${resp}" = X"" ]; do
		echo "Enter the directory relative to the mount point that"
		echo -n "contains the file. [${_directory}] "
		getresp "${_directory}"
	done
	_directory=$resp
d1487 2
a1488 2
	install_from_mounted_fs /mnt2/${_directory}
	umount -f /mnt2 > /dev/null 2>&1
d1492 23
a1514 7
	# Get the IP address of the server
	resp=""		# force one iteration
	while [ "X${resp}" = X"" ]; do
		echo -n "Server IP address or hostname? [${_nfs_server_ip}] "
		getresp "${_nfs_server_ip}"
	done
	_nfs_server_ip=$resp
d1516 4
a1519 7
	# Get server path to mount
	resp=""		# force one iteration
	while [ "X${resp}" = X"" ]; do
		echo -n "Filesystem on server to mount? [${_nfs_server_path}] "
		getresp "${_nfs_server_path}"
	done
	_nfs_server_path=$resp
d1521 7
a1527 20
	# Determine use of TCP
	echo -n "Use TCP transport (only works with capable NFS server)? [n] "
	getresp "n"
	case "$resp" in
		y*|Y*)
			_nfs_tcp="-T"
			;;

		*)
			_nfs_tcp=""
			;;
	esac

	# Mount the server
	mkdir /mnt2 > /dev/null 2>&1
	if ! mount_nfs $_nfs_tcp ${_nfs_server_ip}:${_nfs_server_path} \
	    /mnt2 ; then
		echo "Cannot mount NFS server.  Aborting."
		return
	fi
d1529 8
a1536 8
	# Get the directory where the file lives
	resp=""		# force one iteration
	while [ "X${resp}" = X"" ]; do
		echo "Enter the directory relative to the mount point that"
		echo -n "contains the file. [${_nfs_directory}] "
		getresp "${_nfs_directory}"
	done
	_nfs_directory=$resp
d1538 2
a1539 2
	install_from_mounted_fs /mnt2/${_nfs_directory}
	umount -f /mnt2 > /dev/null 2>&1
d1543 1
a1543 1
	local _xcmd
d1545 2
a1546 2
	# Get the name of the tape from the user.
	cat << \__install_tape_1
d1552 14
a1565 14
	_tape=`basename $TAPE`
	resp=""		# force one iteration
	while [ "X${resp}" = X"" ]; do
		echo -n "Name of tape device? [${_tape}]"
		getresp "${_tape}"
	done
	_tape=`basename $resp`
	TAPE="/dev/${_tape}"
	if [ ! -c $TAPE ]; then
		echo "$TAPE does not exist or is not a character special file."
		echo "Aborting."
		return
	fi
	export TAPE
d1567 8
a1574 8
	# Rewind the tape device
	echo -n "Rewinding tape..."
	if ! mt rewind ; then
		echo "$TAPE may not be attached to the system or may not be"
		echo "a tape device.  Aborting."
		return
	fi
	echo "done."
d1576 9
a1584 9
	# Get the file number
	resp=""		# force one iteration
	while [ "X${resp}" = X"" ]; do
		echo -n "File number? "
		getresp ""
		case "$resp" in
			[1-9]*)
				_nskip=`expr $resp - 1`
				;;
d1586 6
a1591 6
			*)
				echo "Invalid file number ${resp}."
				resp=""		# fore loop to repeat
				;;
		esac
	done
d1593 6
a1598 7
	# Skip to correct file.
	echo -n "Skipping to source file..."
	if [ "X${_nskip}" != X"0" ]; then
		if ! mt fsf $_nskip ; then
			echo "Could not skip $_nskip files.  Aborting."
			return
		fi
d1600 2
a1601 1
	echo "done."
d1603 1
a1603 1
	cat << \__install_tape_2
d1607 2
a1608 2
	1) an image of a gzipped tar file
	2) a standard tar image
d1611 8
a1618 8
	resp=""		# force one iteration
	while [ "X${resp}" = X"" ]; do
		echo -n "Which way is it? [1] "
		getresp "1"
		case "$resp" in
		1)
			_xcmd="tar -zxvpf -"
			;;
d1620 3
a1622 3
		2)
			_xcmd="tar -xvpf -"
			;;
d1624 8
a1631 8
		*)
			echo "Invalid response: $resp."
			resp=""		# force loop to repeat
			;;
		esac
		( cd /mnt; dd if=$TAPE | $_xcmd )
	done
	echo "Extraction complete."
d1635 2
a1636 2
	local _a
	local _zonepath
d1638 14
a1651 14
	#
	# If the zoneinfo is not on the installation medium or on the
	# installed filesystem, set TZ to GMT and return immediatly.
	#
	if [ ! -e /usr/share/zoneinfo -a ! -e /mnt/usr/share/zoneinfo ]; then
		TZ=GMT
		return
	fi
	if [ ! -d /usr/share/zoneinfo ]; then
		_zonepath=/mnt
	else
		_zonepath=""
	fi
		
d1664 41
a1704 41
	if [ X$TZ = X ]; then
		TZ=`ls -l /mnt/etc/localtime 2>/dev/null | cutlast`
		TZ=${TZ#/usr/share/zoneinfo/}
	fi
	while : ; do
		echo -n	"What timezone are you in [\`?' for list] [$TZ]? "
		getresp "$TZ"
		case "$resp" in
		"")
			echo "Timezone defaults to GMT"
			TZ="GMT"
			break;
			;;
		"?")
			ls ${_zonepath}/usr/share/zoneinfo
			;;
		*)
			_a=$resp
			while [ -d ${_zonepath}/usr/share/zoneinfo/$_a ]; do
				echo -n "There are several timezones available"
				echo " within zone '$_a'"
				echo -n "Select a sub-timezone [\`?' for list]: "
				getresp ""
				case "$resp" in
				"?") ls ${_zonepath}/usr/share/zoneinfo/$_a ;;
				*)	_a=${_a}/${resp}
					if [ -f ${_zonepath}/usr/share/zoneinfo/$_a ]; then
						break;
					fi
					;;
				esac
			done
			if [ -f ${_zonepath}/usr/share/zoneinfo/$_a ]; then
				TZ="$_a"
				echo "You have selected timezone \"$_a\"".
				return
			fi
			echo "'/usr/share/zoneinfo/$_a' is not a valid timezone on this system."
			;;
		esac
	done
d1709 2
a1710 2
	local _yup
	_yup="FALSE"
d1712 2
a1713 2
	# Ask the user which media to load the distribution from.
	cat << \__install_sets_1
d1723 4
a1726 5
	if [ "X$local_sets_dir" != "X" ]; then
		install_from_mounted_fs ${local_sets_dir}
		if [ X"$_setsdone" != X ]; then
			_yup="TRUE"
		fi
d1728 1
d1730 42
a1771 42
	# Go on prodding for alternate locations
	resp=""		# force at least one iteration
	while [ X"${resp}" = X ]; do
		# If _yup is not FALSE, it means that we extracted sets above.
		# If that's the case, bypass the menu the first time.
		if [ X"$_yup" = X"FALSE" ]; then
			echo -n	"Install from (f)tp, h(ttp), (t)ape, (C)D-ROM,"
			echo -n " (N)FS or local (d)isk? "
			getresp ""
			case "$resp" in
			d*|D*)
				install_disk
				resp=d
				;;
			f*|F*)
				install_url ftp
				resp=f
				;;
			h*|H*)
				install_url http
				resp=h
				;;
			t*|T*)
				install_tape
				resp=t
				;;
			c*|C*)
				install_cdrom
				resp=c
				;;
			n*|N*)
				install_nfs
				resp=n
				;;
			*)
				echo "Invalid response: $resp"
				resp=""
				;;
			esac
		else
			_yup="FALSE"	# So we'll ask next time
		fi
d1773 2
a1774 2
		if [ ! -f /mnt/bsd ]; then
			cat << \__install_sets_2
d1780 4
a1783 4
			resp=""
		fi
		if [ ! -f /mnt/bin/cat ]; then
			cat << \__install_sets_3
d1789 2
a1790 2
			resp=""
		fi
d1792 10
a1801 10
		# Give the user the opportunity to extract more sets. They
		# don't necessarily have to come from the same media.
		echo	""
		echo -n	"Extract more sets? [n] "
		getresp "n"
		case "$resp" in
		y*|Y*)
			# Force loop to repeat
			resp=""
			;;
d1803 4
a1806 4
		*)
			;;
		esac
	done
d1811 29
a1839 29
	local _fstab
	local _fstab_shadow
	local _dev
	local _mp
	local _fstype
	local _rest

	# Now that the 'real' fstab is configured, we munge it into a 'shadow'
	# fstab which we'll use for mounting and unmounting all of the target
	# filesystems relative to /mnt.  Mount all filesystems.
	_fstab=$1
	_fstab_shadow=$2
	( while read _dev _mp _fstype _rest; do
		# Skip comment lines
		case "$_dev" in
			\#*)	continue;;
			*)	;;
		esac
		# and some filesystem types (like there are swap,kernfs,...)
		case "$_fstype" in
			ffs|ufs|nfs)	;;
			*)	continue;;
		esac
		if [ "$_mp" = "/" ]; then
			echo $_dev /mnt $_fstype $_rest
		else
			echo $_dev /mnt$_mp $_fstype $_rest
		fi
	    done ) < $_fstab > $_fstab_shadow
d1844 28
a1871 28
	# Must mount filesystems manually, one at a time, so we can make
	# sure the mount points exist.
	# $1 is a file in fstab format
	local _fstab

	_fstab=$1

	( while read line; do
		set -- $line
		_dev=$1
		_mp=$2
		_fstype=$3
		_opt=$4

		# If not the root filesystem, make sure the mount
		# point is present.
		if [ "X{$_mp}" != X"/mnt" ]; then
			mkdir -p $_mp
		fi

		# Mount the filesystem.  If the mount fails, exit
		# with an error condition to tell the outer
		# later to bail.
		if ! mount -v -t $_fstype -o $_opt $_dev $_mp ; then
			# error message displated by mount
			exit 1
		fi
	done ) < $_fstab
d1873 2
a1874 2
	if [ "X${?}" != X"0" ]; then
		cat << \__mount_filesystems_1
d1879 2
a1880 2
		exit
	fi
d1885 18
a1902 13
	# Unmount all filesystems and check their integrity.
	# Usage: [-check] <fstab file>
	local _check
	local _fstab
	local _pid

	if [ "$1" = "-check" ]; then
		_check=1
		_fstab=$2
	else
		_check=0
		_fstab=$1
	fi
d1904 15
a1918 4
	if [ ! \( -f $_fstab -a -s $_fstab \) ]; then
		echo "fstab empty" > /dev/tty
		return
	fi
d1920 5
a1924 8
	(
		_devs=""
		_mps=""
		# maintain reverse order
		while read line; do
			set -- $line
			_devs="$1 ${_devs}"
			_mps="$2 ${_mps}"
d1926 3
a1928 16
		echo -n "Umounting filesystems... "
		for _mp in ${_mps}; do
			echo -n "${_mp} "
			umount ${_mp}
		done
		echo "Done."

		if [ $_check = 1 ]; then
			echo "Checking filesystem integrity..."
			for _dev in ${_devs}; do
				echo  "${_dev}"
				fsck -f ${_dev}
			done
		fi
		echo "Done."
	) < $_fstab
d1933 3
a1935 3
	# Check filesystem integrity.
	# $1 is a file in fstab format
	local _fstab
d1937 1
a1937 1
	_fstab=$1
d1939 8
a1946 8
	(
		_devs=""
		_mps=""
		while read line; do
			set -- $line
			_devs="$1 ${_devs}"
			_mps="$2 ${_mps}"
		done
d1948 7
a1954 7
		echo "Checking filesystem integrity..."
		for _dev in ${_devs}; do
			echo  "${_dev}"
			fsck -f ${_dev}
		done
		echo "Done."
	) < $_fstab
@


1.62
log
@copyrights
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.61 1998/03/26 05:17:48 millert Exp $
d19 1
a19 1
	Theo de Raadt
@


1.61
log
@For non-anonymous ftp, ask for the password twice and and make sure
they match.  This is because passwords are no longer echo'd so we
want to make sure they are correct before we do any xfers.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.60 1998/03/26 03:57:43 deraadt Exp $
d4 29
@


1.60
log
@fix disk prompt
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.59 1998/03/26 03:49:19 millert Exp $
d753 10
@


1.59
log
@Make nfs/cdrom/localdisk install the same as ftp/http install.
Ie: select the sets once and then extract en mass.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.58 1998/03/24 06:38:56 millert Exp $
d342 1
a342 1
	echo -n	"Which disk is the root disk? [${_defdsk}]"
@


1.58
log
@ o sanitize ftp/http url handling (too many evals make my head spin)
 o proxied ftp can have a username too
 o make first ethernet device the default
 o if there is only one disk device make it the default
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.56 1998/03/23 05:29:21 deraadt Exp $
d648 1
a971 1
	local _filename
d973 1
a973 1
	local _next
d975 8
a982 1
	local _kernel
d998 26
a1023 2
		echo "There are no OpenBSD install sets available in \"$1\""
		return
d1026 10
d1037 3
a1039 2
		echo "The following sets are available for extraction:"
		echo "(marked sets have already been extracted)"
d1044 1
a1044 1
			if isin $_f $_setsdone; then
d1050 1
a1050 1
					_next=$_f
a1054 1
		echo ""
d1057 14
a1070 8
		if [ "X$_next" = "X" ]; then
			resp=n
		else
			resp=y
		fi
		echo -n "Continue extraction in this directory [$resp]?"
		getresp "$resp"
		if [ "$resp" = "n" ]; then
a1072 3

		echo -n "File name [$_next]? "
		getresp "$_next"
a1073 1
		_filename="/$1/$_f"
d1076 2
a1077 2
		if [ ! -f $_filename ]; then
			echo "File $_filename does not exist.  Check to make"
d1082 2
a1083 7
		# Extract file
		if [ X$_f = X$_kernel ]; then
			cp $_filename /mnt/$_f
		else
			cat $_filename | (cd /mnt; tar -zxvpf -)
		fi
		echo "Extraction complete."
d1085 1
d1087 81
@


1.57
log
@do not mislead user with numbers; johns
@
text
@d234 1
a234 1
	ftp -V -n $_host  <<__ptf
d333 2
d336 4
d342 2
a343 2
	echo -n	"Which disk is the root disk? "
	getresp ""
d429 3
d654 1
d734 7
a740 8
		if [ "X${ftp_proxy}" = X"" ]; then
			# Get login name
			resp=""		# force one iteration
			while [ "X${resp}" = X"" ]; do
				echo -n "Login? [${_ftp_server_login}] "
				getresp "${_ftp_server_login}"
				_ftp_server_login=$resp 
			done
d742 2
a743 1
			# Get password
d746 2
a747 1
				echo -n "Password? [${_ftp_server_password}] "
d749 2
d753 3
d759 7
d773 1
a773 1
		_file_list=`eval ftp -o - -V ${_url_type}://\\$_${_url_type}_server_ip/\\$_${_url_type}_server_dir/index.txt | sed 's///'`
d831 2
a832 2
"You will want at least the base and bsd sets.\\\\n"
"Consult the intallation notes if you are not sure which sets are required!\\\\n"\
d876 1
a876 1
			echo "sure you entered the information properly."
d909 1
a909 5
				if [ "${_url_type}" = "ftp" -a "X${ftp_proxy}" = X"" ]; then
					( cd /mnt ; ftp ${_ftp_active} -V ftp://${_ftp_server_login}:${_ftp_server_password}@@${_ftp_server_ip}/${_ftp_server_dir}/${_f} )
				else
					( cd /mnt ; eval ftp -V ${_url_type}://\$_${_url_type}_server_ip/\$_${_url_type}_server_dir/${_f} )
				fi
d911 1
a911 5
				if [ "${_url_type}" = "ftp" -a "X${ftp_proxy}" = X"" ]; then
					( cd /mnt ; ftp -o - ${_ftp_active} -V ftp://${_ftp_server_login}:${_ftp_server_password}@@${_ftp_server_ip}/${_ftp_server_dir}/${_f} | tar zxvpf - )
				else
					( cd /mnt ; eval ftp -o - -V ${_url_type}://\$_${_url_type}_server_ip/\$_${_url_type}_server_dir/${_f} | tar zxvpf - )
				fi
d1592 1
a1592 1
So please continue installing..
d1601 1
a1601 1
important distribution files. So please continue installing..
@


1.56
log
@make sure people do not use numbers for disk types; johns
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.55 1998/03/12 09:42:40 deraadt Exp $
d1095 2
a1096 2
	1) ISO-9660 (cd9660)
	2) Berkeley Fast Filesystem (ffs)
@


1.55
log
@formatting
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.54 1998/03/12 08:59:45 deraadt Exp $
d1217 2
a1218 2
	1) default (deduced from the disklabel)
	2) ffs
d1223 1
a1223 1
		echo "	3) $_md_fstype"
@


1.54
log
@a nice little space
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.53 1998/03/12 08:13:52 deraadt Exp $
d1574 1
d1583 1
@


1.53
log
@various prompt and message changes
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.52 1998/03/01 19:49:03 millert Exp $
d1536 1
a1536 1
			echo -n "(N)FS or local (d)isk? "
@


1.52
log
@Remove an extra "-o -" so the kernel doesn't go to stdout.  Noted by pefo.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.51 1998/02/17 23:19:09 millert Exp $
d304 2
a305 2
Now you can select another disk to initialize.
Available disks are:
d1514 5
a1518 7
It is now time to extract the installation sets onto the hard disk.
Make sure the sets are either on a local device (i.e. tape, CD-ROM)
or on a network server.

You will have the chance to repeat this step or to extract sets from
several places, so you don't have to try to load all the sets in one
try and can recover from some errors.
@


1.51
log
@Use ftp's new -o flag and give the user the option of using
active ftp (default is passive with auto-fallback to active).
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.50 1998/01/10 02:22:57 deraadt Exp $
d887 1
a887 1
					( cd /mnt ; ftp -o - ${_ftp_active} -V ftp://${_ftp_server_login}:${_ftp_server_password}@@${_ftp_server_ip}/${_ftp_server_dir}/${_f} )
d889 1
a889 1
					( cd /mnt ; eval ftp -o - -V ${_url_type}://\$_${_url_type}_server_ip/\$_${_url_type}_server_dir/${_f} )
@


1.50
log
@support installing to multiple disks; cyxob@@isl.vtu.lt
after install is done, if /bsd or /bin/cat do not exist, complain that the
kernel or baseXX.tar distributions did not get installed; deraadt
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.49 1997/10/29 21:38:17 deraadt Exp $
d636 1
a636 1
	#	_ftp_server_password, and _ftp_passive must be global.
d668 3
a670 3
		# Use passive mode ftp? (incompatible with proxy)
		case "${_ftp_passive}" in
			-p)	resp=y ;;
d673 5
a677 1
		echo -n "Do you want to use passive ftp? [${resp}] "
d680 2
a681 2
			y*|Y*)	_ftp_passive=-p ;;
			*)	unset _ftp_passive ;;
d691 1
a691 1
		ftp ${_ftp_passive} -V -a ftp://ftp.openbsd.org/pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/ftplist | grep "^${_url_type}:"
d750 1
a750 1
		_file_list=`eval ftp -V ${_url_type}://\\$_${_url_type}_server_ip/\\$_${_url_type}_server_dir/index.txt | sed 's///'`
d887 1
a887 1
					( cd /mnt ; ftp ${_ftp_passive} -V ftp://${_ftp_server_login}:${_ftp_server_password}@@${_ftp_server_ip}/${_ftp_server_dir}/${_f} )
d889 1
a889 1
					( cd /mnt ; eval ftp -V ${_url_type}://\$_${_url_type}_server_ip/\$_${_url_type}_server_dir/${_f} )
d893 1
a893 1
					( cd /mnt ; ftp ${_ftp_passive} -V ftp://${_ftp_server_login}:${_ftp_server_password}@@${_ftp_server_ip}/${_ftp_server_dir}/${_f} | tar zxvpf - )
d895 1
a895 1
					( cd /mnt ; eval ftp -V ${_url_type}://\$_${_url_type}_server_ip/\$_${_url_type}_server_dir/${_f} | tar zxvpf - )
@


1.49
log
@clarify a prompt
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.48 1997/10/25 05:22:19 deraadt Exp $
d301 23
d803 3
a805 3
"Some of these sets are required for your ${MODE} and some are optional.\\\\n"\
"Consult the intallation notes if you are not sure which sets are required!\\\\n"

d1568 17
@


1.48
log
@ask for netmask
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.47 1997/10/19 09:07:47 deraadt Exp $
d979 1
a979 1
		echo -n "Continue extraction [$resp]?"
@


1.48.2.1
log
@merge in 1.49: clarify a prompt
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.49 1997/10/29 21:38:17 deraadt Exp $
d979 1
a979 1
		echo -n "Continue extraction in this directory [$resp]?"
@


1.47
log
@do not indent $_DKDEVS
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.46 1997/10/17 12:35:01 deraadt Exp $
d477 1
@


1.46
log
@look at ftp.openbsd.org not ftp.usa... the ftp one is now fast
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.45 1997/10/17 12:20:28 deraadt Exp $
d311 1
a311 1
	echo	"	$_DKDEVS"
d330 1
a330 1
	echo "	$_DKDEVS"
d1241 1
a1241 1
	echo    "	$_DKDEVS"
@


1.45
log
@pretty a bit more
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.44 1997/10/17 12:05:57 deraadt Exp $
d663 1
a663 1
		ftp ${_ftp_passive} -V -a ftp://ftp.usa.openbsd.org/pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/ftplist | grep "^${_url_type}:"
@


1.44
log
@clarify significantly. in many situations, put more effort into remembering
previous answers to the questions, so that it is easier to abort and restart
the install script.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.43 1997/10/17 08:57:24 deraadt Exp $
a801 1
		echo ""
d839 3
a841 4
	echo	""
	echo	"Fetching files via ${_url_type} may take a long time,"
	echo	"especially over a slow network connection."
	echo -n	"Ready to download files? [y] "
@


1.43
log
@indent disk list
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.42 1997/10/17 08:13:58 deraadt Exp $
d304 3
a306 5
The installation program needs to know which disk to consider
the root disk.  Note the unit number may be different than
the unit number you used in the boot program (especially on a
PC with multiple disk controllers).

d330 1
a330 1
	echo "$_DKDEVS"
d382 2
d387 2
d391 2
a392 1
	cat << \__configurenetwork_1
d399 12
a410 11
		for _ifs in $_IFS; do
			if isin $_ifs $_ifsdone ; then
				echo -n "[X] "
			else
				echo -n "    "
			fi
			echo $_ifs
		done
		echo	""
		echo -n	"Configure which interface? [done] "
		getresp "done"
d414 3
d426 2
d430 1
d477 3
a479 1
	resp=""		# force one iteration
d481 1
a481 1
		echo -n "Netmask (ie. 255.255.255.0)? [$_interface_mask] "
d492 1
a492 2
	echo "But please keep in mind not all drivers use flags like this."
	echo ""
d625 4
a628 3
	echo "\nThis is an automated ${_url_type}-based installation process.\n"\
"You will be asked several questions and then the\n"\
"files will be retrieved iteratively via ftp(1).\n"
d634 1
a634 1
	echo -n "http/ftp proxy URL? (none if you do not use a proxy) [${_proxy_host}] "
d670 1
a670 1
		eval echo -n "Server IP? [\$_${_url_type}_server_ip]\ "
d792 1
a792 1
				echo -n "[X] "
d795 1
a795 1
				echo -n "    "
d890 1
a890 1
					echo -n "[X] "
d893 1
a893 1
					echo -n "    "
d962 1
a962 1
				echo -n "[X] "
d965 1
a965 1
				echo -n "    "
d1268 1
a1268 1
		echo -n "Server IP address? [${_nfs_server_ip}] "
@


1.42
log
@clarify
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.41 1997/10/17 04:31:18 deraadt Exp $
d306 2
a307 2
the unit number you used in the standalone installation
program (especially on a PC with multiple disk controllers).
d313 1
a313 1
	echo	"$_DKDEVS"
d1231 1
a1231 1
	echo    "$_DKDEVS"
@


1.41
log
@... especially on PC machines...
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.40 1997/10/03 20:26:35 deraadt Exp $
d469 1
a469 1
		echo -n "Netmask? [$_interface_mask] "
d622 1
a622 1
	echo -n "http/ftp proxy URL? [${_proxy_host}] "
@


1.40
log
@choose install-from disk correctly; matthieu@@mipnet.fr, PR#325
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.39 1997/09/25 05:16:43 millert Exp $
d307 1
a307 1
program.
@


1.39
log
@Fix typo, noted by johns@@heuris.com.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.38 1997/07/16 22:33:03 pefo Exp $
d1150 1
a1150 1
	    sed -n 's/^\[\(.\)\]/\1/p'`
d1153 1
a1153 1
		    sed -n 's/^\[\(.\)\]/\1/p'`
@


1.38
log
@Fix the frigging CD rom mount bug!!
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.37 1997/07/09 15:15:37 millert Exp $
d1664 1
a1664 1
		if [ $_check = 1]; then
@


1.37
log
@Don't do needless sync and change -fast to -check in unmount_fs()
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.36 1997/05/29 09:15:47 niklas Exp $
d1078 1
a1078 1
	if ! mount -t ${_filesystem} -o ro \
@


1.36
log
@Be nicer about the partition query
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.35 1997/05/18 23:12:02 deraadt Exp $
d1630 2
a1631 2
	# Usage: [-fast] <fstab file>
	local _fast
d1635 2
a1636 2
	if [ "$1" = "-fast" ]; then
		_fast=1
d1639 1
a1639 1
		_fast=0
a1647 8
	if [ $_fast = 0 ]; then
		echo -n	"Syncing disks..."
		#_pid=`twiddle`
		sync; sleep 4; sync; sleep 2; sync; sleep 2
		#kill $_pid
		echo	"done."
	fi

d1664 6
a1669 2
		if [ $_fast = 0 ]; then
			exit
a1670 5
		echo "Checking filesystem integrity..."
		for _dev in ${_devs}; do
			echo  "${_dev}"
			fsck -f ${_dev}
		done
@


1.35
log
@provide link0/link1 examples
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.34 1997/05/17 00:06:36 millert Exp $
d1106 1
d1135 24
a1158 1
	_partition_range=`md_get_partition_range`
d1161 2
a1162 2
		echo -n "Partition? [d] "
		getresp "d"
d1179 2
a1180 1
	1) ffs
d1185 1
a1185 1
		echo "	2) $_md_fstype"
d1191 2
a1192 2
		echo -n "Which filesystem type? [ffs] "
		getresp "ffs"
d1194 4
d1199 1
a1199 1
				_fstype=$resp
d1203 1
a1203 1
				_fstype=$resp
d1214 1
a1214 2
	if ! mount -t ${_fstype} -o $_fsopts \
	    /dev/${_drive}${_partition} /mnt2 ; then
@


1.34
log
@Make an echo line up neatly.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.33 1997/05/16 16:36:53 millert Exp $
d476 5
a480 1
	echo "these at the next prompt."
@


1.33
log
@unset $_ftp_passive if user says no to passive mode and fix a typo.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.32 1997/05/16 04:55:05 millert Exp $
d611 2
a612 2
	     "You will be asked several questions and then the\n"\
	     "files will be retrieved iteratively via ftp(1).\n"
@


1.32
log
@Use a single proxy variable since we need to set both ftp/http proxies
and they are virtually guaranteed to be the same.
Proxy http install now works.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.31 1997/05/16 04:12:44 millert Exp $
d636 2
a637 2
			y*|N*)	_ftp_passive=-p ;;
			*)	;;
@


1.31
log
@Strip possible <cr> from index.txt
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.30 1997/05/16 03:21:10 millert Exp $
d615 13
a627 6
	eval echo -n "${_url_type} proxy URL? [\$${_url_type}_proxy]\ "
	eval getresp "\$${_url_type}_proxy"
	if [ "X$resp" != "X" ]; then
		eval ${_url_type}_proxy=$resp
		eval export ${_url_type}_proxy
	elif [ "${_url_type}" = "ftp" ]; then
@


1.30
log
@Fix instance of ftp_server_dir -> _ftp_server_dir.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.29 1997/05/16 03:07:39 millert Exp $
d699 1
a699 1
		_file_list="`eval ftp -V ${_url_type}://\\$_${_url_type}_server_ip/\\$_${_url_type}_server_dir/index.txt | cat`"
@


1.29
log
@proxy-ftp install needs to use index.txt too
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.28 1997/05/16 02:00:22 millert Exp $
d653 1
a653 1
	if [ "${_url_type}" = "ftp" -a "X${ftp_server_dir}" = X"" ]; then
d655 1
a655 1
		ftp_server_dir="pub/OpenBSD/${VERSION_MAJOR}.${VERSION_MINOR}/${ARCH}"
@


1.28
log
@- Proxy setting takes a URL, not an IP.
- Use ${VERSION_MAJOR} and ${VERSION_MINOR}, not sed.
- Server list file is always called ftplist.  Grep out applicable
  servers based on URL-type.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.27 1997/05/16 00:51:09 millert Exp $
d694 1
a694 1
	if [ "${_url_type}" = "ftp" ]; then
d697 1
a697 1
		# Assumes index file is "index.txt" for http
@


1.27
log
@When getting a file list, make things relative to the install dir, not
absolute.  Necesary for http listing via index.txt.  list_has_sets() no
longer takes a dir argument as file lists contain relative paths.
Remove a few eval's now that we use relative paths in file lists.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.26 1997/05/15 06:29:01 millert Exp $
d615 1
a615 1
	eval echo -n "${_url_type} proxy IP? [\$${_url_type}_proxy]\ "
d640 1
a640 1
		ftp ${_ftp_passive} -V -a ftp://ftp.usa.openbsd.org/pub/OpenBSD/`echo ${VERSION} | sed 's/\(.\)\(.\)/\1.\2/'`/${_url_type}list | cat
@


1.26
log
@Get ``ftplist'' from ftp.usa.openbsd.org.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.25 1997/05/15 06:26:08 millert Exp $
a200 1
	local _dir
a203 1
	_dir=$1; shift
d206 1
a206 1
		if isin $_dir/${_file}${VERSION}.tar.gz $_list; then
d210 1
a210 1
		if isin $_dir/${_file}${VERSION}.tgz $_list; then
d214 1
a214 1
		if test $_file = "kernel" && isin $_dir/bsd $_list; then
d236 2
a237 1
ls $_dir
a600 1
	local _filename
d698 1
d703 1
a703 1
	if eval list_has_sets \"$_file_list\" \$_${_url_type}_server_dir $THESETS; then
d706 1
a706 1
				if eval isin \$_${_url_type}_server_dir/bsd $_file_list; then
d709 1
a709 1
			elif eval isin \$_${_url_type}_server_dir/${_f}${VERSION}.tar.gz $_file_list; then
d711 1
a711 1
			elif eval isin \$_${_url_type}_server_dir/${_f}${VERSION}.tgz $_file_list; then
d726 1
a726 1
		for _f in `echo "${_file_list}" | sed 's/^.*\///'` ; do
d788 1
a798 1
		eval _filename="\$_${_url_type}_server_dir/$_f"
d801 2
a802 2
		if ! isin $_filename $_file_list ; then
			echo "File $_filename does not exist.  Check to make"
d886 1
a891 1
			eval _filename="\$_${_url_type}_server_dir/$_f"
d894 2
a895 2
			if ! isin $_filename $_file_list ; then
				echo "File $_filename does not exist.  Check to make"
@


1.25
log
@install_ftp -> install.url (http support is untested)
Fix a problem with ftp proxy and getting a file list
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.23 1997/05/14 17:08:11 millert Exp $
d642 1
a642 1
		ftp ${_ftp_passive} -V -a ftp://ftp.openbsd.org/pub/OpenBSD/`echo ${VERSION} | sed 's/\(.\)\(.\)/\1.\2/'`/${_url_type}list | cat
@


1.24
log
@Add VERSION_MAJOR and VERSION_MINOR.  Currently assumes release
is ${major}${minor} not ${major}${minor}${teeny}.
@
text
@d594 1
a594 1
install_ftp() {
d603 3
a605 3
	local _ftp_file_list
	local _ftp_get_files
	local _ftp_failed_files
d607 1
d609 2
a610 1
	cat << \__install_ftp_1
d612 7
a618 8
This is an automated ftp-based installation process.  You will be asked
several questions and then the files will be retrieved iteratively via ftp(1).

__install_ftp_1

	# Proxy ftp connections?
	echo -n "ftp proxy IP? [${ftp_proxy}] "
	getresp "${ftp_proxy}"
d620 3
a622 3
		ftp_proxy=$resp
		export ftp_proxy
	else
d636 2
a637 2
	# Provide a list of possible FTP servers
	echo -n "Do you want a list of potential FTP servers? [y] "
d642 1
a642 1
		ftp ${_ftp_passive} -V -a ftp://ftp.openbsd.org/pub/OpenBSD/`echo ${VERSION} | sed 's/\(.\)\(.\)/\1.\2/'`/ftplist | cat
d649 3
a651 3
		echo -n "Server IP? [${_ftp_server_ip}] "
		getresp "${_ftp_server_ip}"
		_ftp_server_ip=$resp
d655 4
d661 3
a663 3
		echo -n "Server directory? [${_ftp_server_dir}] "
		getresp "${_ftp_server_dir}"
		_ftp_server_dir=$resp
d666 2
a667 3
	if [ "X${ftp_proxy}" = X"" ]; then
		# Get login name
		resp=""		# force one iteration
a670 8
		while [ "X${resp}" = X"" ]; do
			echo -n "Login? [${_ftp_server_login}] "
			getresp "${_ftp_server_login}"
			_ftp_server_login=$resp 
		done

		# Get password
		resp=""		# force one iteration
d674 18
a691 5
		while [ "X${resp}" = X"" ]; do
			echo -n "Password? [${_ftp_server_password}] "
			getresp "${_ftp_server_password}"
			_ftp_server_password=$resp
		done
d694 8
a701 2
	# Get list of files from ftp server.
	_ftp_file_list=`ftp_list_files $_ftp_server_ip $_ftp_server_login $_ftp_server_password $_ftp_server_dir`
d704 1
a704 1
	if list_has_sets "$_ftp_file_list" $_ftp_server_dir $THESETS; then
d707 1
a707 1
				if isin $_ftp_server_dir/bsd $_ftp_file_list; then
d710 1
a710 1
			elif isin $_ftp_server_dir/${_f}${VERSION}.tar.gz $_ftp_file_list; then
d712 1
a712 1
			elif isin $_ftp_server_dir/${_f}${VERSION}.tgz $_ftp_file_list; then
d717 1
a717 1
		echo "There are no OpenBSD install sets available in \"$_ftp_server_dir\"."
d727 1
a727 1
		for _f in `echo "${_ftp_file_list}" | sed 's/^.*\///'` ; do
d741 1
a741 1
			echo "${_ftp_file_list}"
d749 10
a758 12
	cat << __install_ftp_2

You will now be asked for files to extract.  In addition to the
files listed in the selector you may enter any file located at
${_ftp_server_ip}:${_ftp_server_dir}.  You can also enter
'all' to install all the standard sets, or 'list' to list the
files avilable at ${_ftp_server_ip}:${_ftp_server_dir}.  When
you are done selecting files, enter 'done'.

Some of these sets are required for your ${MODE} and some are optional.
Consult the intallation notes if you are not sure which sets are required!
__install_ftp_2
d789 1
a789 1
			echo "${_ftp_file_list}"
d794 1
a794 1
			_ftp_get_files="$_sets $_kernel"
d799 1
a799 1
		_filename="$_ftp_server_dir/$_f"
d802 1
a802 1
		if ! isin $_filename $_ftp_file_list ; then
d809 1
a809 1
		_ftp_get_files="${_ftp_get_files} $_f"
d813 5
d819 1
a819 1
	echo	"Fetching files via ftp may take a long time,"
d833 3
a835 3
	while test -n "${_ftp_get_files}" ; do
		_ftp_failed_files=""
		for _f in $_ftp_get_files ; do
d838 1
a838 1
				if [ "X${ftp_proxy}" = X"" ]; then
d841 1
a841 1
					( cd /mnt ; ftp -V ftp://${_ftp_server_ip}/${_ftp_server_dir}/${_f} )
d844 1
a844 1
				if [ "X${ftp_proxy}" = X"" ]; then
d847 1
a847 1
					( cd /mnt ; ftp -V ftp://${_ftp_server_ip}/${_ftp_server_dir}/${_f} | tar zxvpf - )
d853 1
a853 1
				_ftp_failed_files="${_ftp_failed_files} ${_f}"
d858 2
a859 2
		_ftp_get_files=""
		while test -n "${_ftp_failed_files}" ; do
d866 1
a866 1
			for _f in $_ftp_failed_files ; do
d887 1
a887 1
				echo "${_ftp_file_list}"
d892 1
a892 1
			_filename="$_ftp_server_dir/$_f"
d895 1
a895 1
			if ! isin $_filename $_ftp_file_list ; then
d900 1
a900 1
			_ftp_get_files="${_ftp_get_files} ${_f}"
d1075 3
d1461 2
a1462 2
			echo -n	"Install from (f)tp, (t)ape, (C)D-ROM, (N)FS"
			echo -n " or local (d)isk? "
d1470 1
a1470 1
				install_ftp
d1472 4
@


1.23
log
@Fix phantom "bsd" that showed up when there were no recognized sets
(variable needed to be re-init'd).
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.22 1997/05/14 16:26:15 millert Exp $
d44 3
a46 1
export VERSION
@


1.22
log
@New ftp install.  Disk install should be made to be more this.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.21 1997/05/13 12:02:33 niklas Exp $
d708 2
@


1.21
log
@Protect against an possibly empty shell variable
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.20 1997/05/13 03:51:27 millert Exp $
d196 45
d593 13
a605 3
	# Get several parameters from the user, and create
	# a shell script that directs the appropriate
	# commands into ftp.
d609 1
a609 2
several questions.  The correct set of commands will be placed in a script
that will be fed to ftp(1).
d613 20
d639 1
a639 1
		ftp -V -a ftp://ftp.openbsd.org/pub/OpenBSD/`echo ${VERSION} | sed 's/\(.\)\(.\)/\1.\2/'`/ftplist | cat
d659 26
a684 8
	# Get login name
	resp=""		# force one iteration
	_ftp_server_login=anonymous
	while [ "X${resp}" = X"" ]; do
		echo -n "Login? [${_ftp_server_login}] "
		getresp "${_ftp_server_login}"
		_ftp_server_login=$resp 
	done
d686 43
a728 8
	# Get password
	resp=""		# force one iteration
	_ftp_server_password=root@@`hostname`.${FQDN}
	while [ "X${resp}" = X"" ]; do
		echo -n "Password? [${_ftp_server_password}] "
		getresp "${_ftp_server_password}"
		_ftp_server_password=$resp
	done
a729 1
	# Get list of files for mget.
d732 6
a737 8
You will now be asked for files to extract.  If you specify just a setname,
it will be treated as setname${VERSION}.tar.gz or you can specify the
explict name.  You can also enter 'all' to install all the standard sets,
or 'list' to list the files avilable at ${_ftp_server_ip}:${_ftp_server_dir}.
When you are done entering files, enter 'done'.

If you were enter 'all', the following sets would be fetched/extracted:
	$THESETS
d741 1
d743 21
a763 9
__install_ftp_2
	echo "#!/bin/sh" > /tmp/ftp-script.sh
	echo "cd /mnt" >> /tmp/ftp-script.sh
	echo "ftp -i -n $_ftp_server_ip << \__end_commands" >> \
	    /tmp/ftp-script.sh
	echo "user $_ftp_server_login $_ftp_server_password" >> \
	    /tmp/ftp-script.sh
	echo "bin" >> /tmp/ftp-script.sh
	echo "cd $_ftp_server_dir" >> /tmp/ftp-script.sh
d765 3
a767 4
	resp=""		# force one interation
	while [ "X${resp}" != X"done" ]; do
		echo -n "File? [done] "
		getresp "done"
d770 10
d781 7
a787 2
		if [ "X${resp}" = X"list" ]; then
			echo "ls" >> /tmp/ftp-script.sh
a789 3
		if [ "X${resp}" = X"all" ]; then
			resp="$THESETS"
		fi
d791 30
a820 4
		for _ftp_file in $resp; do
			if [ "X${_ftp_file}" = "Xkernel" ]; then
				echo -n "get " >> /tmp/ftp-script.sh
				echo "bsd" >> /tmp/ftp-script.sh
d822 10
a831 6
				echo -n "get " >> /tmp/ftp-script.sh
				echo -n "${_ftp_file}" | \
				    sed "/\./!s/\$/${VERSION}.tar.gz/" >> \
					/tmp/ftp-script.sh
				echo " |\"tar -zxvpf -\"" >> \
				    /tmp/ftp-script.sh
a833 1
	done
d835 22
a856 2
	echo "quit" >> /tmp/ftp-script.sh
	echo "__end_commands" >> /tmp/ftp-script.sh
d858 13
a870 1
	cat << \__install_ftp_3
d872 10
a881 26
Fetching the files via ftp may take a long time, especially over a slow
network connection.  You may want to review/edit the ftp script to make
sure that you haven't made any errors in the file names.
__install_ftp_3
	echo -n "edit ftp script? [n] "
	getresp "n"
	case "$resp" in
	y*|Y*)
		$EDITOR /tmp/ftp-script.sh
		;;
	*)
		;;
	esac
	
	echo -n "submit ftp script? [y] "
	getresp "y"
	case "$resp" in
	y*|Y*)
		sh /tmp/ftp-script.sh
		echo "Extraction complete."
		;;
	*)
		;;
	esac
	
	rm -f /tmp/ftp-script.sh
d922 3
a924 1
				if [ -z "$_next" ]; then _next=$_f; fi
d931 5
a935 1
		if [ "X$_next" = "X" ]; then resp=n; else resp=y; fi
d1366 1
a1366 1
	while :; do
@


1.20
log
@Need to add ${VERSION} when checking for the existence of sets.
We use "route show" not "netstat -r"
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.19 1997/05/10 22:19:36 millert Exp $
d756 1
a756 1
		if [ $_f = $_kernel ]; then
@


1.19
log
@Add SNAPSETS -- can be included in MDSETS if so desired.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.18 1997/05/05 05:27:30 deraadt Exp $
d92 2
d181 1
a181 1
		if [ -f $_dir/${_file}.tar.gz ]; then
d185 1
a185 1
		if [ -f $_dir/${_file}.tgz ]; then
d535 1
a535 1
		netstat -r
d539 1
a539 1
		netstat -rn
@


1.18
log
@get ftplist from proper host
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.17 1997/05/05 05:18:19 grr Exp $
d48 3
@


1.17
log
@turns out changes to getresp weren't really the ticket, I'd revert it, but don't want to mess up anybody at this point.  If everybody's going to be using this stuff, it needs a post-release overhaul...
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.16 1997/05/05 00:35:36 tholo Exp $
d560 1
a560 1
		ftp -V -a ftp://cvs.openbsd.org/pub/OpenBSD/`echo ${VERSION} | sed 's/\(.\)\(.\)/\1.\2/'`/ftplist | cat
@


1.16
log
@Default FTP login anonymous with root@@this.machine as password for FTP install
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.15 1997/05/05 00:28:45 tholo Exp $
d63 1
@


1.15
log
@When doing FTP installs, allow the user to get a list of FTP servers
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.14 1997/05/04 05:08:00 tholo Exp $
d581 1
d590 1
@


1.14
log
@Install `base' set before `etc' (configuration files)
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.13 1997/05/04 04:50:22 tholo Exp $
d552 11
@


1.13
log
@Distribution sets has version as part of the file name; be consistent
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.12 1997/05/04 03:25:03 tholo Exp $
d46 1
a46 1
ALLSETS="etc base misc comp text man game"	# default install sets
@


1.12
log
@Need to quote interface flags to addifconfig as there might be more than one
flag specified
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.11 1997/05/04 03:03:14 tholo Exp $
d684 7
a690 5
				_kernel=bsd
			elif [ -f $1/${_f}.tar.gz ]; then
				_sets="$_sets ${_f}.tar.gz"
			elif [ -f $1/${_f}.tgz ]; then
				_sets="$_sets ${_f}.tgz"
@


1.11
log
@Fix thinko in kernel install handling
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.10 1997/05/03 23:06:02 tholo Exp $
d444 1
a444 1
			    ${_interface_mask} ${_interface_extra}
d454 1
a454 1
		    ${_interface_mask} ${_interface_extra}
@


1.10
log
@Disable twiddle() as it causes problems on some architectures
Actually install machine dependant sets if there are any specified
Special-case a set named "kernel" so that it will copy "bsd" to the root
disk
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.9 1997/05/03 07:45:10 tholo Exp $
d43 1
a43 1
VERSION=21
d625 1
a625 1
			if [ "X${resp}" = "Xkernel" ]; then
@


1.9
log
@Make $EDITOR available after setting it
break cannot break out of a case; just return
Work around apparent pdksh bug where it will look at a modified $resp after
executing code in a case statement.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.8 1997/05/02 20:56:18 grr Exp $
d182 4
d625 11
a635 6
			echo -n "get " >> /tmp/ftp-script.sh
			echo -n "${_ftp_file}" | \
			    sed "/\./!s/\$/${VERSION}.tar.gz/" >> \
				/tmp/ftp-script.sh
			echo " |\"tar -zxvpf -\"" >> \
			    /tmp/ftp-script.sh
d659 1
a659 1
	getresp "n"
d678 1
d683 3
a685 1
			if [ -f $1/${_f}.tar.gz ]; then
d702 1
a702 1
		for _f in $_sets ; do
d735 5
a739 1
		cat $_filename | (cd /mnt; tar -zxvpf -)
d1363 1
a1363 1
		_pid=`twiddle`
d1365 1
a1365 1
		kill $_pid
@


1.8
log
@allow install to be restarted in many cases without blowing away everything already extracted and move the ftp extract further in the direction of user friendly
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.7 1997/04/30 23:56:06 grr Exp $
d60 1
d1161 1
a1161 1
				break 2
d1206 1
d1210 1
d1214 1
d1218 1
d1222 1
@


1.7
log
@clean up sparc mini-root stuff and eliminate some mysteries and surprises therein
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.6 1997/04/30 20:25:36 deraadt Exp $
d43 1
a43 1
VERSION=				# filled in automatically (see list)
d46 2
a47 2
ALLSETS="base comp etc games man misc text"	# default install sets
UPGRSETS="base comp games man misc text"	# default upgrade sets
d580 1
a580 1
	cat << \__install_ftp_2
d582 4
a585 1
You will now be asked for files to extract.  Enter one file at a time.
d588 6
d611 7
d619 8
a626 3
		_ftp_file=`echo ${resp} | cutword 1'`
		echo "get ${_ftp_file} |\"tar -zxvpf -\"" >> \
		    /tmp/ftp-script.sh
d635 1
a635 1
network connection.  You may want to review/edit the fetch script to make
d638 1
a638 1
	echo -n "edit ftp fetch script? [n] "
d648 11
a658 2

	sh /tmp/ftp-script.sh
a659 1
	echo "Extraction complete."
d1177 6
a1182 2
Make sure the sets are either on a local device (i.e. tape, CD-ROM) or on a
network server.
@


1.6
log
@no --unlink
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.5 1997/04/30 18:52:45 niklas Exp $
d62 1
d64 19
a82 4
	read resp
	if [ "X$resp" = "X" ]; then
		resp=$1
	fi
d375 1
d401 1
d404 2
a405 2
		echo -n "Symbolic (host) name? "
		getresp ""
d610 17
@


1.5
log
@We run OpenBSD. we also want vim acting as vi.
@
text
@d2 1
a2 1
#	$OpenBSD: install.sub,v 1.5.2.8 1996/09/02 23:25:02 pk Exp $
d586 1
a586 1
		echo "get ${_ftp_file} |\"tar --unlink -zxvpf -\"" >> \
d658 1
a658 1
		cat $_filename | (cd /mnt; tar --unlink -zxvpf -)
d1014 1
a1014 1
			_xcmd="tar --unlink -zxvpf -"
d1018 1
a1018 1
			_xcmd="tar --unlink -xvpf -"
@


1.4
log
@sync to netbsd
@
text
@d2 1
d40 1
a40 1
#	NetBSD installation/upgrade script - common subroutines.
d615 1
a615 1
		echo "There are no NetBSD install sets available in \"$1\""
@


1.3
log
@Update for removal of GNU tar(1)
@
text
@d2 1
a2 2
#	$OpenBSD$
#	$NetBSD: install.sub,v 1.2 1996/02/28 00:47:43 thorpej Exp $
d39 1
a39 1
#	OpenBSD installation/upgrade script - common subroutines.
a40 2
VERSION=1.1A
export VERSION				# XXX needed in subshell
d42 2
d47 13
d80 2
d91 77
d178 4
a181 1
. install.md
d183 20
a202 3
do_mfs_mount() {
	# $1 is the mount point
	# $2 is the size in DEV_BIZE blocks
d204 21
a224 12
	umount $1 > /dev/null 2>&1
	if ! mount_mfs -s $2 swap $1 ; then
		cat << \__mfs_failed_1

FATAL ERROR: Can't mount the memory filesystem.

__mfs_failed_1
		exit
	fi

	# Bleh.  Give mount_mfs a chance to DTRT.
	sleep 2
d267 1
a267 1
			if echo "$_DKDEVS" | grep "^$resp" > /dev/null ; then
d288 2
a289 4
	if grep "^$1 " /tmp/hosts > /dev/null; then
		grep -v "^$1 " /tmp/hosts > /tmp/hosts.new
		mv /tmp/hosts.new /tmp/hosts
	fi
d299 1
d302 1
a302 1
	echo "inet $2 $4" > /tmp/hostname.$1
d352 7
d361 13
d377 2
a378 2
		echo -n "IP address? "
		getresp ""
d393 2
a394 2
		echo -n "Netmask? "
		getresp ""
d398 10
d411 15
a425 4
	ifconfig ${_interface_name} down
	if ifconfig ${_interface_name} inet \
	    ${_interface_ip} \
	    netmask ${_interface_mask} up ; then
d430 1
a430 2
		    ${_interface_mask}
		return 0
d584 2
a585 2
		_ftp_file=`echo ${resp} | awk '{print $1}'`
		echo "get ${_ftp_file} |\"tar -xzvpf -\"" >> \
d597 2
a598 2
install_common_nfs_cdrom() {
	# $1 - directory containing file
d600 2
a601 2
	local _setsdone
	local _prev
d604 11
a614 3
	_sets=`(cd /mnt2/$1; ls *.tar.gz)`
	if [ -z "$_sets" ]; then
		echo "There are no OpenBSD install sets available in \"$1\""
a617 1
	_setsdone=""
d623 1
a623 1
		_prev=""
d627 1
d630 1
a630 1
				if [ -z "$_prev" ]; then _prev=$_f; fi
d637 1
a637 1
		if [ "X$_prev" = "X" ]; then resp=n; else resp=y; fi
d644 2
a645 2
		echo -n "File name [$_prev]? "
		getresp "$_prev"
d647 1
a647 1
		_filename="/mnt2/$1/$_f"
d657 1
a657 1
		cat $_filename | (cd /mnt; tar -xzvpf -)
d665 6
d675 1
a675 1
the CD-ROM device containing the installation media:
d691 1
a691 1
				_cdrom_drive=$resp
d702 1
d708 2
a709 2
			[a-h])
				_cdrom_partition=$resp
d733 1
a733 1
				_cdrom_filesystem=$resp
d744 2
a745 2
	if ! mount -t ${_cdrom_filesystem} -o ro \
	    /dev/${_cdrom_drive}${_cdrom_partition} /mnt2 ; then
d754 2
a755 2
		echo -n "contains the file. [${_cdrom_directory}] "
		getresp "${_cdrom_directory}"
d757 1
a757 1
	_cdrom_directory=$resp
d759 125
a883 1
	install_common_nfs_cdrom ${_cdrom_directory}
d934 1
a934 1
	install_common_nfs_cdrom ${_nfs_directory}
d939 2
d1012 3
a1014 6
			1)
				(
					cd /mnt
					dd if=$TAPE | tar -xzvpf -
				)
				;;
d1016 3
a1018 6
			2)
				(
					cd /mnt
					dd if=$TAPE | tar -xzvpf -
				)
				;;
d1020 4
a1023 4
			*)
				echo "Invalid response: $resp."
				resp=""		# force loop to repeat
				;;
d1025 1
d1032 16
d1061 2
a1062 2
		TZ=`ls -l /etc/timezone 2>/dev/null | awk '{print $NF}' |
			sed -e 's?/usr/share/zoneinfo/??'`
d1074 1
a1074 1
			ls /usr/share/zoneinfo
d1078 1
a1078 1
			while [ -d /usr/share/zoneinfo/$_a ]; do
d1084 1
a1084 1
				"?") ls /usr/share/zoneinfo/$_a ;;
d1086 1
a1086 1
					if [ -f /usr/share/zoneinfo/$_a ]; then
d1092 1
a1092 1
			if [ -f /usr/share/zoneinfo/$_a ]; then
d1105 5
a1109 3
# arguments: the base names of the distribution sets to consider
# Ask the user which media to load the distribution from.
cat << \__install_sets_1
d1112 1
a1112 1
Make sure The sets are either on a local device (i.e. tape, CD-ROM) or on a
d1116 17
a1132 11
if [ -f $RELDIR/$1.tar.gz ]; then
	echo -n "Install from sets in the current root filesystem? [y] "
	getresp "y"
	case "$resp" in
	y*|Y*)
		for _f do
			if [ ! -f $RELDIR/${_f}.tar.gz ]; then
				continue
			fi
			echo -n "Install \"$_f\" ? [y]"
			getresp "y"
d1134 14
a1147 5
			y*|Y*)
			     cat $RELDIR/${_f}.tar.gz |
					(cd /mnt; tar -xzvpf -)
				_yup="TRUE"
				echo "Extraction complete."
d1150 2
a1151 1
				echo "Skipping \"$_f\"."
d1154 3
a1156 9
		done
		;;
	*)
		_yup="FALSE"
		;;
	esac
else
	_yup="FALSE"
fi
d1158 5
a1162 8
# Go on prodding for alternate locations
resp=""		# force at least one iteration
while [ "X${resp}" = X"" ]; do
	# If _yup is not FALSE, it means that we extracted sets above.
	# If that's the case, bypass the menu the first time.
	if [ X"$_yup" = X"FALSE" ]; then
		echo -n	"Install from (f)tp, (t)ape, (C)D-ROM, or (N)FS? [f] "
		getresp "f"
d1164 3
a1166 14
		f*|F*)
			install_ftp
			;;

		t*|T*)
			install_tape
			;;

		c*|C*)
			install_cdrom
			;;

		n*|N*)
			install_nfs
a1169 2
			echo "Invalid response: $resp"
			resp=""
d1172 1
a1172 19
	else
		_yup="FALSE"	# So we'll ask next time
	fi

	# Give the user the opportunity to extract more sets.  They don't
	# necessarily have to come from the same media.
	echo	""
	echo -n	"Extract more sets? [n] "
	getresp "n"
	case "$resp" in
	y*|Y*)
		# Force loop to repeat
		resp=""
		;;

	*)
		;;
	esac
done
d1179 5
d1189 13
a1201 3
	awk '{
		if ($2 == "/")
		    printf("%s /mnt %s %s %s %s\n", $1, $3, $4, $5, $6)
d1203 3
a1205 2
		    printf("%s /mnt%s %s %s %s %s\n", $1, $2, $3, $4, $5, $6)
	}' < $_fstab > $_fstab_shadow
d1218 5
a1222 4
		_dev=`echo $line | awk '{print $1}'`
		_mp=`echo $line | awk '{print $2}'`
		_fstype=`echo $line | awk '{print $3}'`
		_opt=`echo $line | awk '{print $4}'`
d1252 2
a1253 1
	# $1 is a file in fstab format
d1255 9
d1265 4
a1268 1
	_fstab=$1
d1270 7
a1276 5
	echo -n	"Syncing disks..."
	pid=`twiddle`
	sync; sleep 4; sync; sleep 2; sync; sleep 2
	kill $pid
	echo	"done."
d1283 3
a1285 2
			_devs="`echo $line | awk '{print $1}'` ${_devs}"
			_mps="`echo $line | awk '{print $2}'` ${_mps}"
d1294 3
d1318 3
a1320 2
			_devs="`echo $line | awk '{print $1}'` ${_devs}"
			_mps="`echo $line | awk '{print $2}'` ${_mps}"
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d426 1
a426 1
		echo "get ${_ftp_file} |\"tar --unlink -zxvpf -\"" >> \
d490 1
a490 1
		cat $_filename | (cd /mnt; tar -zxvpf -)
d715 1
a715 1
					dd if=$TAPE | tar --unlink -zxvpf -
d722 1
a722 1
					dd if=$TAPE | tar --unlink -xvpf -
d817 1
a817 1
					(cd /mnt; tar --unlink -zxvpf -)
@


1.1
log
@update from netbsd
@
text
@d2 2
a3 1
#	$NetBSD: install.sub,v 1.1 1996/01/06 22:45:13 pk Exp $
d5 1
a5 1
# Copyright (c) 1995 Jason R. Thorpe.
d8 3
d21 5
a25 4
#	This product includes software developed for the NetBSD Project
#	by Jason R. Thorpe.
# 4. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission
d27 11
a37 10
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d40 1
a40 1
#	NetBSD installation/upgrade script - common subroutines.
d447 1
a447 1
		echo "There are no NetBSD install sets available in \"$1\""
@

