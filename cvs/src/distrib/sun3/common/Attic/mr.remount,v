head	1.3;
access;
symbols
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2000.06.20.21.29.17;	author miod;	state dead;
branches;
next	1.2;

1.2
date	2000.03.01.22.10.10;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	95.11.06.21.28.53;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Completely new ramdisk stuff, inspired by the existing sparc ramdisk.
@
text
@#!/bin/sh
# $OpenBSD: mr.remount,v 1.2 2000/03/01 22:10:10 todd Exp $
# $NetBSD: mr.remount,v 1.1 1995/11/01 23:53:29 gwr Exp $
#
# Find out what the root is mounted on,
# remount the root read/write, then
# create a valid /etc/fstab for it.
#
# Uses: dmesg, grep, mount

# Given a sequence of lines like: "root on sd0b"
# print the last part of the last line: "sd0b"
findroot() {
	name='??'
	while read a b c d
	do
		name="$c"
	done
	echo "$name"
}

if [ -f /etc/fstab ]
then
	echo "root already mounted read/write"
	exit 1
fi

echo "Determining current root device..."
root=`/sbin/dmesg |grep '^root on ' |findroot`

echo "Remounting root device $root"
/sbin/mount -u "/dev/$root" /

echo "/dev/$root / ufs rw 1 1" > /etc/fstab
exit 0
@


1.2
log
@$OpenBSD$
@
text
@d2 1
a2 1
# $OpenBSD: mr.remount,v 1.1 1995/11/01 23:53:29 gwr Exp $
@


1.1
log
@from netbsd
@
text
@d2 1
@

