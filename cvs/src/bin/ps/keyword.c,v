head	1.45;
access;
symbols
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.42.0.6
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.37.0.6
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.4
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.2
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.2
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.30.0.6
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.4
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.28.0.8
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.4
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.4
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.23.0.6
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.4
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.13.0.12
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.13.0.10
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.13.0.8
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.6
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.13.0.4
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2017.01.24.22.40.09;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	DUPaNwLEn6fhN1Qr;

1.44
date	2016.09.08.15.11.29;	author tedu;	state Exp;
branches;
next	1.43;
commitid	Ektj5UIXo8ssHb1H;

1.43
date	2015.12.30.14.59.10;	author tedu;	state Exp;
branches;
next	1.42;
commitid	pcpM0SacneEDdJB8;

1.42
date	2015.01.16.06.39.32;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	Uu5nFG3wCl0LACBb;

1.41
date	2014.10.13.17.30.21;	author schwarze;	state Exp;
branches;
next	1.40;
commitid	f48W5bFs5rxfDVCk;

1.40
date	2014.03.20.03.38.33;	author lteo;	state Exp;
branches;
next	1.39;

1.39
date	2013.10.24.06.21.47;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2013.09.22.17.28.34;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2012.04.11.17.33.26;	author guenther;	state Exp;
branches;
next	1.36;

1.36
date	2012.04.04.16.13.11;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2012.01.07.05.38.12;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2011.12.29.17.13.55;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2011.12.11.00.16.49;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.10.03.20.58;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2011.03.12.04.54.28;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2010.02.14.00.17.14;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2008.03.08.19.20.12;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.13.19.20.23;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2006.11.29.12.34.19;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2006.10.16.15.00.10;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.02.05.25.19;	author hugh;	state Exp;
branches;
next	1.23;

1.23
date	2004.09.14.23.45.14;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.11.01.32.13;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.08.18.18.35;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.16.00.37.21;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.25.21.12.45;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.11.23.42.12;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.23.32.09;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.12.19.21.29.46;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.19.14.20.44;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.11.25.22.33.38;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	97.11.06.15.59.54;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	97.09.03.13.51.40;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	97.08.22.20.08.14;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.08.08.19.30.09;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.08.04.05.37.03;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.23.19.18.18;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.06.18.18.54.05;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.02.12.15.28.24;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.02.05.17.10.55;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.20.49;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.04.35.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.19;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.19;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.45
log
@do not need sys/proc.h
@
text
@/*	$OpenBSD: keyword.c,v 1.44 2016/09/08 15:11:29 tedu Exp $	*/
/*	$NetBSD: keyword.c,v 1.12.6.1 1996/05/30 21:25:13 cgd Exp $	*/

/*-
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXCOMLEN */
#include <sys/time.h>
#include <sys/resource.h>

#include <err.h>
#include <errno.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ps.h"

#include <sys/ucred.h>
#include <sys/sysctl.h>

int needheader;

static VAR *findvar(char *);
static int  vcmp(const void *, const void *);

#ifdef NOTINUSE
int	utime(), stime(), ixrss(), idrss(), isrss();
	{{"utime"}, "UTIME", USER, utime, 4},
	{{"stime"}, "STIME", USER, stime, 4},
	{{"ixrss"}, "IXRSS", USER, ixrss, 4},
	{{"idrss"}, "IDRSS", USER, idrss, 4},
	{{"isrss"}, "ISRSS", USER, isrss, 4},
#endif

/* Compute offset in common structures. */
#define	POFF(x)	offsetof(struct kinfo_proc, x)

#define	UIDFMT	"u"
#define	UIDLEN	5
#define	UID(n1, n2, fn, off) \
	{ n1, n2, NULL, 0, fn, UIDLEN, 0, off, UINT32, UIDFMT }
#define	GID(n1, n2, fn, off)	UID(n1, n2, fn, off)

#define	PIDFMT	"d"
#define	PIDLEN	5
#define	PID(n1, n2, fn, off) \
	{ n1, n2, NULL, 0, fn, PIDLEN, 0, off, INT32, PIDFMT }

#define	TIDFMT	"d"
#define TIDLEN	7
#define	TID(n1, n2, fn, off) \
	{ n1, n2, NULL, 0, fn, TIDLEN, 0, off, INT32, TIDFMT }

#define	USERLEN	8
#define	CWDLEN	40

/* Bit types must match their respective entries in struct kinfo_proc */
/* Entries must be sorted in lexical ascending order! */
VAR var[] = {
	{"%cpu", "%CPU", NULL, NLIST, pcpu, 4},
	{"%mem", "%MEM", NULL, NLIST, pmem, 4},
	{"acflag", "ACFLG", NULL, 0, pvar, 3, 0, POFF(p_acflag), UINT16, "x"},
	{"acflg", "", "acflag"},
	{"args", "", "command"},
	{"blocked", "", "sigmask"},
	{"caught", "", "sigcatch"},
	{"comm", "COMMAND", "ucomm"},
	{"command", "COMMAND", NULL, COMM|LJUST|USER, command, 16},
	{"cpu", "CPU", NULL, 0, pvar, 3, 0, POFF(p_estcpu), UINT32, "d"},
	{"cpuid", "CPUID", NULL, 0, pvar, 8, 0, POFF(p_cpuid), UINT64, "lld"},
	{"cputime", "", "time"},
	{"cwd", "CWD", NULL, LJUST, curwd, CWDLEN},
	{"dsiz", "DSIZ", NULL, 0, dsize, 4},
	{"emul", "EMUL", NULL, LJUST, emulname, KI_EMULNAMELEN - 1},
	{"etime", "ELAPSED", NULL, USER, elapsed, 12},
	{"f", "F", NULL, 0, pvar, 7, 0, POFF(p_flag), INT32, "x"},
	{"flags", "", "f"},
	GID("gid", "GID", pvar, POFF(p_gid)),
	{"group", "GROUP", NULL, LJUST, gname, USERLEN},
	{"ignored", "", "sigignore"},
	{"inblk", "INBLK", NULL, USER, pvar, 4, 0, POFF(p_uru_inblock), UINT64, "lld"},
	{"inblock", "", "inblk"},
	{"jobc", "JOBC", NULL, 0, pvar, 4, 0, POFF(p_jobc), INT16, "d"},
	{"ktrace", "KTRACE", NULL, 0, pvar, 8, 0, POFF(p_traceflag), INT32, "x"},
	/* XXX */
	{"ktracep", "KTRACEP", NULL, 0, pvar, PTRWIDTH, 0, POFF(p_tracep), UINT64, "llx"},
	{"lim", "LIM", NULL, 0, maxrss, 5},
	{"login", "LOGIN", NULL, LJUST, logname, LOGIN_NAME_MAX},
	{"logname", "", "login"},
	{"lstart", "STARTED", NULL, LJUST|USER, lstarted, 28},
	{"majflt", "MAJFLT", NULL, USER, pvar, 4, 0, POFF(p_uru_majflt), UINT64, "lld"},
	{"maxrss", "MAXRSS", NULL, USER, pvar, 4, 0, POFF(p_uru_maxrss), UINT64, "lld"},
	{"minflt", "MINFLT", NULL, USER, pvar, 4, 0, POFF(p_uru_minflt), UINT64, "lld"},
	{"msgrcv", "MSGRCV", NULL, USER, pvar, 4, 0, POFF(p_uru_msgrcv), UINT64, "lld"},
	{"msgsnd", "MSGSND", NULL, USER, pvar, 4, 0, POFF(p_uru_msgsnd), UINT64, "lld"},
	{"ni", "", "nice"},
	{"nice", "NI", NULL, 0, pnice, 3},
	{"nivcsw", "NIVCSW", NULL, USER, pvar, 5, 0, POFF(p_uru_nivcsw), UINT64, "lld"},
	{"nsignals", "", "nsigs"},
	{"nsigs", "NSIGS", NULL, USER, pvar, 4, 0, POFF(p_uru_nsignals), UINT64, "lld"},
	{"nswap", "NSWAP", NULL, USER, pvar, 4, 0, POFF(p_uru_nswap), UINT64, "lld"},
	{"nvcsw", "NVCSW", NULL, USER, pvar, 5, 0, POFF(p_uru_nvcsw), UINT64, "lld"},
	/* XXX */
	{"nwchan", "WCHAN", NULL, 0, pvar, PTRWIDTH, 0, POFF(p_wchan), UINT64, "llx"},
	{"oublk", "OUBLK", NULL, USER, pvar, 4, 0, POFF(p_uru_oublock), UINT64, "lld"},
	{"oublock", "", "oublk"},
	/* XXX */
	{"p_ru", "P_RU", NULL, 0, pvar, PTRWIDTH, 0, POFF(p_ru), UINT64, "llx"},
	/* XXX */
	{"paddr", "PADDR", NULL, 0, pvar, PTRWIDTH, 0, POFF(p_paddr), UINT64, "llx"},
	{"pagein", "PAGEIN", NULL, USER, pagein, 6},
	{"pcpu", "", "%cpu"},
	{"pending", "", "sig"},
	PID("pgid", "PGID", pvar, POFF(p__pgid)),
	PID("pid", "PID", pvar, POFF(p_pid)),
	{"pmem", "", "%mem"},
	PID("ppid", "PPID", pvar, POFF(p_ppid)),
	{"pri", "PRI", NULL, 0, pri, 3},
	{"procflags", "PROCF", NULL, 0, pvar, 7, 0, POFF(p_psflags), INT32, "x"},
	{"re", "RE", NULL, INF127, pvar, 3, 0, POFF(p_swtime), UINT32, "u"},
	GID("rgid", "RGID", pvar, POFF(p_rgid)),
	/* XXX */
	{"rgroup", "RGROUP", NULL, LJUST, rgname, USERLEN},
	{"rlink", "RLINK", NULL, 0, pvar, 8, 0, POFF(p_back), UINT64, "llx"},
	{"rss", "RSS", NULL, 0, p_rssize, 5},
	{"rssize", "", "rsz"},
	{"rsz", "RSZ", NULL, 0, rssize, 4},
	{"rtable", "RTABLE", NULL, 0, pvar, 0, 0, POFF(p_rtableid), INT32, "d"},
	UID("ruid", "RUID", pvar, POFF(p_ruid)),
	{"ruser", "RUSER", NULL, LJUST, runame, USERLEN},
	{"sess", "SESS", NULL, 0, pvar, PTRWIDTH, 0, POFF(p_sess), UINT64, "llx"},
	{"sig", "PENDING", NULL, 0, pvar, 8, 0, POFF(p_siglist), INT32, "x"},
	{"sigcatch", "CAUGHT", NULL, 0, pvar, 8, 0, POFF(p_sigcatch), UINT32, "x"},
	{"sigignore", "IGNORED",
		NULL, 0, pvar, 8, 0, POFF(p_sigignore), UINT32, "x"},
	{"sigmask", "BLOCKED", NULL, 0, pvar, 8, 0, POFF(p_sigmask), UINT32, "x"},
	{"sl", "SL", NULL, INF127, pvar, 3, 0, POFF(p_slptime), UINT32, "u"},
	{"ssiz", "SSIZ", NULL, 0, ssize, 4},
	{"start", "STARTED", NULL, LJUST|USER, started, 8},
	{"stat", "", "state"},
	{"state", "STAT", NULL, LJUST|NLIST, printstate, 5},
	GID("svgid", "SVGID", pvar, POFF(p_svgid)),
	UID("svuid", "SVUID", pvar, POFF(p_svuid)),
	{"tdev", "TDEV", NULL, 0, tdev, 4},
	TID("tid", "TID", pvar, POFF(p_tid)),
	{"time", "TIME", NULL, USER, cputime, 9},
	PID("tpgid", "TPGID", pvar, POFF(p_tpgid)),
	{"tsess", "TSESS", NULL, 0, pvar, PTRWIDTH, 0, POFF(p_tsess), UINT64, "llx"},
	{"tsiz", "TSIZ", NULL, 0, tsize, 4},
	{"tt", "TT", NULL, LJUST, tname, 3},
	{"tty", "TTY", NULL, LJUST, longtname, 8},
	{"ucomm", "UCOMM", NULL, LJUST, ucomm, MAXCOMLEN},
	UID("uid", "UID", pvar, POFF(p_uid)),
	{"upr", "UPR", NULL, 0, pvar, 3, 0, POFF(p_usrpri), UINT8, "d"},
	{"user", "USER", NULL, LJUST, euname, USERLEN},
	{"usrpri", "", "upr"},
	{"vsize", "", "vsz"},
	{"vsz", "VSZ", NULL, 0, vsize, 5},
	{"wchan", "WCHAN", NULL, LJUST, wchan, KI_WMESGLEN - 1},
	{"xstat", "XSTAT", NULL, 0, pvar, 4, 0, POFF(p_xstat), UINT16, "x"},
	{""},
};

void
showkey(void)
{
	VAR *v;
	int i;
	char *p, *sep;

	i = 0;
	sep = "";
	for (v = var; *(p = v->name); ++v) {
		int len = strlen(p);
		if (termwidth && (i += len + 1) > termwidth) {
			i = len;
			sep = "\n";
		}
		(void) printf("%s%s", sep, p);
		sep = " ";
	}
	(void) printf("\n");
}

void
parsefmt(char *p)
{
	static struct varent *vtail;

#define	FMTSEP	" \t,\n"
	while (p && *p) {
		char *cp;
		VAR *v;
		struct varent *vent;

		while ((cp = strsep(&p, FMTSEP)) != NULL && *cp == '\0')
			/* void */;
		if (!cp)
			break;
		if (!(v = findvar(cp)) || v->parsed == 1)
			continue;
		v->parsed = 1;
		if ((vent = malloc(sizeof(struct varent))) == NULL)
			err(1, NULL);
		vent->var = v;
		vent->next = NULL;
		if (vhead == NULL)
			vhead = vtail = vent;
		else {
			vtail->next = vent;
			vtail = vent;
		}
		needheader |= v->header[0] != '\0';
	}
	if (!vhead)
		errx(1, "no valid keywords");
}

static VAR *
findvar(char *p)
{
	VAR *v, key;
	char *hp;

	key.name = p;

	hp = strchr(p, '=');
	if (hp)
		*hp++ = '\0';

aliased:
	key.name = p;
	v = bsearch(&key, var, sizeof(var)/sizeof(VAR) - 1, sizeof(VAR), vcmp);

	if (v && v->alias) {
		p = v->alias;
		if (hp == NULL && v->header[0] != '\0')
			hp = v->header;
		goto aliased;
	}
	if (!v) {
		warnx("%s: keyword not found", p);
		eval = 1;
		return (NULL);
	}
	if (hp)
		v->header = hp;
	return (v);
}

static int
vcmp(const void *a, const void *b)
{
	return (strcmp(((VAR *)a)->name, ((VAR *)b)->name));
}
@


1.44
log
@etime isn't just an alias for start. the output format is different.
diff from Carlin Bingham. ok millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.43 2015/12/30 14:59:10 tedu Exp $	*/
a35 1
#include <sys/proc.h>
@


1.43
log
@rename a few variables/functions to avoid shadowing
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.42 2015/01/16 06:39:32 deraadt Exp $	*/
d104 1
a104 1
	{"etime", "ELAPSED", "start"},
@


1.42
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.41 2014/10/13 17:30:21 schwarze Exp $	*/
d170 1
a170 1
	{"state", "STAT", NULL, LJUST|NLIST, state, 5},
@


1.41
log
@Remove duplicate and misleading vcmp() prototype;
patch from Martin <Natano at natano dot net>;
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.40 2014/03/20 03:38:33 lteo Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d117 1
a117 1
	{"login", "LOGIN", NULL, LJUST, logname, MAXLOGNAME},
@


1.40
log
@Move the "minflt" entry to the correct spot in the var array so that all
keywords are sorted in ascending order again.  This fixes a bug where
ps(1) thought that "minflt" was an invalid keyword.

This bug was introduced when the "maxrss" keyword was accidentally added
to the array after "minflt" instead of before, so the bsearch(3)-based
keyword lookup could never find "minflt".

ok deraadt@@ guenther@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.39 2013/10/24 06:21:47 guenther Exp $	*/
a252 1
	int vcmp(const void *, const void *);
@


1.39
log
@Fix field header overriding on fields that are (internally) aliases for others.
Follow POSIX spec for the default headers for the comm, etime, and tty fields.

Problem noted by lotheac (at) iki.fi
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.38 2013/09/22 17:28:34 guenther Exp $	*/
d121 1
a122 1
	{"maxrss", "MAXRSS", NULL, USER, pvar, 4, 0, POFF(p_uru_maxrss), UINT64, "lld"},
@


1.38
log
@Stop merging the per-thread and per-process flags when reporting
them via sysctl(KERN_PROC).  In struct kinfo_proc the per-process
flags move to p_psflags, leaving the per-thread flags in p_flags.
Flag descriptions in ps(1) updated to be less obtuse.

discussed with matthew@@ some time ago; ok jca@@, manpage bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.37 2012/04/11 17:33:26 guenther Exp $	*/
d96 1
a96 1
	{"comm", "", "ucomm"},
d104 1
a104 1
	{"etime", "", "start"},
d261 1
d266 4
a269 6
		if (hp) {
			warnx("%s: illegal keyword specification", p);
			eval = 1;
		}
		parsefmt(v->alias);
		return (NULL);
@


1.37
log
@Add maxrss keyword for the ru_maxrss value...which ariane@@ is making work
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.36 2012/04/04 16:13:11 jsing Exp $	*/
d87 1
d148 1
@


1.36
log
@Add "tid" as a formatting keyword. If the -H option is specified, include
the thread ID in the default format.

ok deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.34 2011/12/29 17:13:55 guenther Exp $	*/
d121 1
@


1.35
log
@Add rtable id and thread id to struct kinfo_proc (and fix process id)
and add an 'rtableid' keyword to ps.

Add rtable id, thread id, and socket splice info to struct kinfo_file2
and make fstat display socket splice information.

Remove old KVM_PROC2 and kinfo_proc2 interfaces; bump libkvm major

Socket splice info and corrections from bluhm@@  "Lovely" deraadt@@
@
text
@d78 5
d171 1
@


1.34
log
@Suppress the header line if all the field headers have been set to empty.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.33 2011/12/11 00:16:49 nicm Exp $	*/
d149 1
@


1.33
log
@Make ps understand -o cwd using the new KERN_PROC_CWD sysctl. Some help
and suggestions from guenther.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.32 2011/04/10 03:20:58 guenther Exp $	*/
d50 2
d232 1
@


1.32
log
@Switch back from KERN_PROC2/kinfo_proc2 to KERN_PROC/kinfo_proc now
that we've got name we want for the API we want

"ZAP!" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.31 2011/03/12 04:54:28 guenther Exp $	*/
d77 1
d93 1
@


1.31
log
@Replace the old, broken KERN_PROC ABI and its matching functions
in libkvm with the stable-ABI versions that are currently named
KERN_PROC2, kvm_get{proc,argv,envv}2().  The latter names and symbols
will continue to be supported for a few releases.

Committing now that they ports people have had a couple releases
to update pkgs that usd the old functions
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.30 2010/02/14 00:17:14 guenther Exp $	*/
d63 1
a63 1
#define	POFF(x)	offsetof(struct kinfo_proc2, x)
d78 1
a78 1
/* Bit types must match their respective entries in struct kinfo_proc2 */
@


1.30
log
@Avoid overflow and wraparound in memory fields by using unsigned
long long arithmetic and formats.
Use PTRWIDTH for the column size for various address fields.

ok otto@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.29 2009/10/27 23:59:22 deraadt Exp $	*/
d93 1
a93 1
	{"emul", "EMUL", NULL, LJUST, emulname, EMULNAMELEN},
d174 1
a174 1
	{"wchan", "WCHAN", NULL, LJUST, wchan, 7},
@


1.29
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.28 2008/03/08 19:20:12 millert Exp $	*/
d105 1
a105 1
	{"ktracep", "KTRACEP", NULL, 0, pvar, 8, 0, POFF(p_tracep), UINT64, "llx"},
d122 1
a122 1
	{"nwchan", "WCHAN", NULL, 0, pvar, 7, 0, POFF(p_wchan), UINT64, "llx"},
d126 1
a126 1
	{"p_ru", "P_RU", NULL, 0, pvar, 6, 0, POFF(p_ru), UINT64, "llx"},
d128 1
a128 1
	{"paddr", "PADDR", NULL, 0, pvar, 6, 0, POFF(p_paddr), UINT64, "llx"},
@


1.28
log
@Instead of calling donlist() in the format print routines, call it
a single time before we print anything, if needed.  Uses a flag to
specify which formats need the kernel info donlist() provides.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.27 2007/04/13 19:20:23 miod Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)keyword.c	8.5 (Berkeley) 4/2/94";
#else
static char rcsid[] = "$OpenBSD: keyword.c,v 1.27 2007/04/13 19:20:23 miod Exp $";
#endif
#endif /* not lint */
@


1.27
log
@Userland gets 7 chars of wchan, not 6; noticed by thib@@
ok mickey@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.26 2006/11/29 12:34:19 miod Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.26 2006/11/29 12:34:19 miod Exp $";
d88 2
a89 2
	{"%cpu", "%CPU", NULL, 0, pcpu, 4},
	{"%mem", "%MEM", NULL, 0, pmem, 4},
d165 1
a165 1
	{"state", "STAT", NULL, LJUST, state, 5},
@


1.26
log
@Do not test for processes being swapped out since this can't happen anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.25 2006/10/16 15:00:10 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.25 2006/10/16 15:00:10 millert Exp $";
d130 1
a130 1
	{"nwchan", "WCHAN", NULL, 0, pvar, 6, 0, POFF(p_wchan), UINT64, "llx"},
d182 1
a182 1
	{"wchan", "WCHAN", NULL, LJUST, wchan, 6},
@


1.25
log
@The session field is a pointer and so should be 8 chars for
32-bit CPUs and 16 chars for 64-bit ones.  Also, left-justify
the state field name to match the justification of the state data.
OK jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.24 2006/05/02 05:25:19 hugh Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.24 2006/05/02 05:25:19 hugh Exp $";
a106 1
	{"holdcnt", "HOLDCNT", NULL, 0, pvar, 8, 0, POFF(p_holdcnt), INT32, "d"},
@


1.24
log
@Format nicelevel relative NZERO as other tools do.
Surely, says millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.23 2004/09/14 23:45:14 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.23 2004/09/14 23:45:14 deraadt Exp $";
d156 1
a156 1
	{"sess", "SESS", NULL, 0, pvar, 6, 0, POFF(p_sess), UINT64, "llx"},
d166 1
a166 1
	{"state", "STAT", NULL, 0, state, 5},
d172 1
a172 1
	{"tsess", "TSESS", NULL, 0, pvar, 6, 0, POFF(p_tsess), UINT64, "llx"},
@


1.23
log
@rename internal uname() to euname() to avoid libc conflict
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.22 2004/06/11 01:32:13 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.22 2004/06/11 01:32:13 deraadt Exp $";
d124 1
a124 1
	{"nice", "NI", NULL, 0, pvar, 2, 0, POFF(p_nice), UINT8, "d"},
@


1.22
log
@export cpuid via kproc2, and make ps & top aware... from niklas
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.21 2004/01/08 18:18:35 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.21 2004/01/08 18:18:35 millert Exp $";
d179 1
a179 1
	{"user", "USER", NULL, LJUST, uname, USERLEN},
@


1.21
log
@Convert to kinfo_proc2.  The sort order for -u and -m will be different
due to a bug fix in the sort routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.20 2003/12/16 00:37:21 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.20 2003/12/16 00:37:21 deraadt Exp $";
d98 1
@


1.20
log
@typo; mjc@@bitz.ca
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.19 2003/06/25 21:12:45 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.19 2003/06/25 21:12:45 deraadt Exp $";
d71 1
a71 4
#define	POFF(x)	offsetof(struct proc, x)
#define	EOFF(x)	offsetof(struct eproc, x)
#define	UOFF(x)	offsetof(struct usave, x)
#define	ROFF(x)	offsetof(struct rusage, x)
d86 1
d90 1
a90 1
	{"acflag", "ACFLG", NULL, 0, pvar, 3, 0, POFF(p_acflag), USHORT, "x"},
d97 1
a97 1
	{"cpu", "CPU", NULL, 0, pvar, 3, 0, POFF(p_estcpu), UINT, "d"},
d102 1
a102 1
	{"f", "F", NULL, 0, pvar, 7, 0, POFF(p_flag), INT, "x"},
d104 1
a104 1
	GID("gid", "GID", evar, EOFF(e_ucred.cr_gid)),
d106 1
a106 1
	{"holdcnt", "HOLDCNT", NULL, 0, pvar, 8, 0, POFF(p_holdcnt), INT, "d"},
d108 1
a108 1
	{"inblk", "INBLK", NULL, USER, rvar, 4, 0, ROFF(ru_inblock), LONG, "d"},
d110 2
a111 2
	{"jobc", "JOBC", NULL, 0, evar, 4, 0, EOFF(e_jobc), SHORT, "d"},
	{"ktrace", "KTRACE", NULL, 0, pvar, 8, 0, POFF(p_traceflag), INT, "x"},
d113 1
a113 1
	{"ktracep", "KTRACEP", NULL, 0, pvar, 8, 0, POFF(p_tracep), KPTR, "x"},
d118 4
a121 4
	{"majflt", "MAJFLT", NULL, USER, rvar, 4, 0, ROFF(ru_majflt), LONG, "d"},
	{"minflt", "MINFLT", NULL, USER, rvar, 4, 0, ROFF(ru_minflt), LONG, "d"},
	{"msgrcv", "MSGRCV", NULL, USER, rvar, 4, 0, ROFF(ru_msgrcv), LONG, "d"},
	{"msgsnd", "MSGSND", NULL, USER, rvar, 4, 0, ROFF(ru_msgsnd), LONG, "d"},
d123 2
a124 2
	{"nice", "NI", NULL, 0, pvar, 2, 0, POFF(p_nice), CHAR, "d"},
	{"nivcsw", "NIVCSW", NULL, USER, rvar, 5, 0, ROFF(ru_nivcsw), LONG, "d"},
d126 3
a128 3
	{"nsigs", "NSIGS", NULL, USER, rvar, 4, 0, ROFF(ru_nsignals), LONG, "d"},
	{"nswap", "NSWAP", NULL, USER, rvar, 4, 0, ROFF(ru_nswap), LONG, "d"},
	{"nvcsw", "NVCSW", NULL, USER, rvar, 5, 0, ROFF(ru_nvcsw), LONG, "d"},
d130 2
a131 2
	{"nwchan", "WCHAN", NULL, 0, pvar, 6, 0, POFF(p_wchan), KPTR, "x"},
	{"oublk", "OUBLK", NULL, USER, rvar, 4, 0, ROFF(ru_oublock), LONG, "d"},
d134 1
a134 1
	{"p_ru", "P_RU", NULL, 0, pvar, 6, 0, POFF(p_ru), KPTR, "x"},
d136 1
a136 1
	{"paddr", "PADDR", NULL, 0, evar, 6, 0, EOFF(e_paddr), KPTR, "x"},
d140 1
a140 1
	PID("pgid", "PGID", evar, EOFF(e_pgid)),
d143 1
a143 1
	PID("ppid", "PPID", evar, EOFF(e_ppid)),
d145 2
a146 2
	{"re", "RE", NULL, INF127, pvar, 3, 0, POFF(p_swtime), UINT, "d"},
	GID("rgid", "RGID", evar, EOFF(e_pcred.p_rgid)),
d149 1
a149 1
	{"rlink", "RLINK", NULL, 0, pvar, 8, 0, POFF(p_back), KPTR, "x"},
d153 1
a153 1
	UID("ruid", "RUID", evar, EOFF(e_pcred.p_ruid)),
d155 3
a157 3
	{"sess", "SESS", NULL, 0, evar, 6, 0, EOFF(e_sess), KPTR, "x"},
	{"sig", "PENDING", NULL, 0, pvar, 8, 0, POFF(p_siglist), INT, "x"},
	{"sigcatch", "CAUGHT", NULL, 0, pvar, 8, 0, POFF(p_sigcatch), UINT, "x"},
d159 3
a161 3
		NULL, 0, pvar, 8, 0, POFF(p_sigignore), UINT, "x"},
	{"sigmask", "BLOCKED", NULL, 0, pvar, 8, 0, POFF(p_sigmask), UINT, "x"},
	{"sl", "SL", NULL, INF127, pvar, 3, 0, POFF(p_slptime), UINT, "d"},
d166 2
a167 2
	GID("svgid", "SVGID", evar, EOFF(e_pcred.p_svgid)),
	UID("svuid", "SVUID", evar, EOFF(e_pcred.p_svuid)),
d170 2
a171 2
	PID("tpgid", "TPGID", evar, EOFF(e_tpgid)),
	{"tsess", "TSESS", NULL, 0, evar, 6, 0, EOFF(e_tsess), KPTR, "x"},
d176 2
a177 2
	UID("uid", "UID", evar, EOFF(e_ucred.cr_uid)),
	{"upr", "UPR", NULL, 0, pvar, 3, 0, POFF(p_usrpri), UCHAR, "d"},
d183 1
a183 1
	{"xstat", "XSTAT", NULL, 0, pvar, 4, 0, POFF(p_xstat), USHORT, "x"},
@


1.19
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.18 2003/06/11 23:42:12 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.18 2003/06/11 23:42:12 deraadt Exp $";
d172 1
a172 1
	PID("tpgid", "TGPID", evar, EOFF(e_tpgid)),
@


1.18
log
@ansification, art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.17 2003/06/02 23:32:09 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.17 2003/06/02 23:32:09 millert Exp $";
d248 1
a248 1
	int vcmp();
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.16 2002/12/19 21:29:46 mickey Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.16 2002/12/19 21:29:46 mickey Exp $";
d190 1
a190 1
showkey()
d211 1
a211 2
parsefmt(p)
	char *p;
d244 1
a244 2
findvar(p)
	char *p;
d278 1
a278 2
vcmp(a, b)
	const void *a, *b;
@


1.16
log
@add dsiz and ssiz to accompany tsiz; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.15 2002/07/19 14:20:44 drahn Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.15 2002/07/19 14:20:44 drahn Exp $";
@


1.15
log
@Fix format bug with ps -o group. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.14 2002/02/16 21:27:07 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.14 2002/02/16 21:27:07 millert Exp $";
d105 1
d168 1
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.13 1998/11/25 22:33:38 aaron Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.13 1998/11/25 22:33:38 aaron Exp $";
d110 1
a110 1
	{"group", "GROUP", NULL, 0, gname, USERLEN},
@


1.13
log
@null pointers are not your friend
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.12 1997/11/06 15:59:54 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.12 1997/11/06 15:59:54 kstailey Exp $";
d62 2
a63 2
static VAR *findvar __P((char *));
static int  vcmp __P((const void *, const void *));
@


1.12
log
@fix ps(1) LIM column
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.11 1997/09/03 13:51:40 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.11 1997/09/03 13:51:40 kstailey Exp $";
d226 2
@


1.11
log
@add ps "emul" option
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.10 1997/08/22 20:08:14 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.10 1997/08/22 20:08:14 kstailey Exp $";
d155 1
a155 1
	{"rss", "RSS", NULL, 0, p_rssize, 4},
@


1.10
log
@XPG4 compatibility for format options:
two new options: group and rgroup.
three new aliases: etime for start, comm for ucomm, and args for command.
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.9 1997/08/08 19:30:09 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.9 1997/08/08 19:30:09 millert Exp $";
d105 1
@


1.9
log
@Add a "parsed" flag for ps fields so we don't print the same field
multiple times.  Fixes PR #298 from Carsten Hammer <chammer@@vogon.party.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.8 1997/08/04 05:37:03 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.8 1997/08/04 05:37:03 deraadt Exp $";
d98 1
d101 1
d105 1
d109 1
d152 1
@


1.8
log
@toast non-NEWVM code; freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.7 1997/07/23 19:18:18 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.7 1997/07/23 19:18:18 kstailey Exp $";
d83 1
a83 1
	{ n1, n2, NULL, 0, fn, UIDLEN, off, UINT32, UIDFMT }
d89 1
a89 1
	{ n1, n2, NULL, 0, fn, PIDLEN, off, INT32, PIDFMT }
d96 1
a96 1
	{"acflag", "ACFLG", NULL, 0, pvar, 3, POFF(p_acflag), USHORT, "x"},
d101 1
a101 1
	{"cpu", "CPU", NULL, 0, pvar, 3, POFF(p_estcpu), UINT, "d"},
d103 1
a103 1
	{"f", "F", NULL, 0, pvar, 7, POFF(p_flag), INT, "x"},
d106 1
a106 1
	{"holdcnt", "HOLDCNT", NULL, 0, pvar, 8, POFF(p_holdcnt), INT, "d"},
d108 1
a108 1
	{"inblk", "INBLK", NULL, USER, rvar, 4, ROFF(ru_inblock), LONG, "d"},
d110 2
a111 2
	{"jobc", "JOBC", NULL, 0, evar, 4, EOFF(e_jobc), SHORT, "d"},
	{"ktrace", "KTRACE", NULL, 0, pvar, 8, POFF(p_traceflag), INT, "x"},
d113 1
a113 1
	{"ktracep", "KTRACEP", NULL, 0, pvar, 8, POFF(p_tracep), KPTR, "x"},
d118 4
a121 4
	{"majflt", "MAJFLT", NULL, USER, rvar, 4, ROFF(ru_majflt), LONG, "d"},
	{"minflt", "MINFLT", NULL, USER, rvar, 4, ROFF(ru_minflt), LONG, "d"},
	{"msgrcv", "MSGRCV", NULL, USER, rvar, 4, ROFF(ru_msgrcv), LONG, "d"},
	{"msgsnd", "MSGSND", NULL, USER, rvar, 4, ROFF(ru_msgsnd), LONG, "d"},
d123 2
a124 2
	{"nice", "NI", NULL, 0, pvar, 2, POFF(p_nice), CHAR, "d"},
	{"nivcsw", "NIVCSW", NULL, USER, rvar, 5, ROFF(ru_nivcsw), LONG, "d"},
d126 3
a128 3
	{"nsigs", "NSIGS", NULL, USER, rvar, 4, ROFF(ru_nsignals), LONG, "d"},
	{"nswap", "NSWAP", NULL, USER, rvar, 4, ROFF(ru_nswap), LONG, "d"},
	{"nvcsw", "NVCSW", NULL, USER, rvar, 5, ROFF(ru_nvcsw), LONG, "d"},
d130 2
a131 2
	{"nwchan", "WCHAN", NULL, 0, pvar, 6, POFF(p_wchan), KPTR, "x"},
	{"oublk", "OUBLK", NULL, USER, rvar, 4, ROFF(ru_oublock), LONG, "d"},
d134 1
a134 1
	{"p_ru", "P_RU", NULL, 0, pvar, 6, POFF(p_ru), KPTR, "x"},
d136 1
a136 1
	{"paddr", "PADDR", NULL, 0, evar, 6, EOFF(e_paddr), KPTR, "x"},
d145 1
a145 1
	{"re", "RE", NULL, INF127, pvar, 3, POFF(p_swtime), UINT, "d"},
d148 1
a148 1
	{"rlink", "RLINK", NULL, 0, pvar, 8, POFF(p_back), KPTR, "x"},
d154 3
a156 3
	{"sess", "SESS", NULL, 0, evar, 6, EOFF(e_sess), KPTR, "x"},
	{"sig", "PENDING", NULL, 0, pvar, 8, POFF(p_siglist), INT, "x"},
	{"sigcatch", "CAUGHT", NULL, 0, pvar, 8, POFF(p_sigcatch), UINT, "x"},
d158 3
a160 3
		NULL, 0, pvar, 8, POFF(p_sigignore), UINT, "x"},
	{"sigmask", "BLOCKED", NULL, 0, pvar, 8, POFF(p_sigmask), UINT, "x"},
	{"sl", "SL", NULL, INF127, pvar, 3, POFF(p_slptime), UINT, "d"},
d169 1
a169 1
	{"tsess", "TSESS", NULL, 0, evar, 6, EOFF(e_tsess), KPTR, "x"},
d175 1
a175 1
	{"upr", "UPR", NULL, 0, pvar, 3, POFF(p_usrpri), UCHAR, "d"},
d181 1
a181 1
	{"xstat", "XSTAT", NULL, 0, pvar, 4, POFF(p_xstat), USHORT, "x"},
d220 1
a220 1
		if (!(v = findvar(cp)))
d222 1
@


1.7
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.6 1997/06/18 18:54:05 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.6 1997/06/18 18:54:05 kstailey Exp $";
a58 5
#ifdef P_PPWAIT
#define NEWVM
#endif

#ifdef NEWVM
a60 1
#endif
a93 1
#ifdef NEWVM
a181 88
#else
	{"%cpu", "%CPU", NULL, 0, pcpu, 4},
	{"%mem", "%MEM", NULL, 0, pmem, 4},
	{"acflag", "ACFLG", NULL, USER, uvar, 3, UOFF(u_acflag), SHORT, "x"},
	{"acflg", "", "acflag"},
	{"blocked", "", "sigmask"},
	{"caught", "", "sigcatch"},
	{"command", "COMMAND", NULL, COMM|LJUST|USER, command, 16},
	{"cpu", "CPU", NULL, 0, pvar, 3, POFF(p_cpu), ULONG, "d"},
	{"cputime", "", "time"},
	{"f", "F", NULL, 0, pvar, 7, POFF(p_flag), LONG, "x"},
	{"flags", "", "f"},
	{"gid", "GID", NULL, 0, pvar, UIDLEN, POFF(p_gid), USHORT, UIDFMT},
	{"ignored", "", "sigignore"},
	{"inblk", "INBLK", NULL, USER, rvar, 4, ROFF(ru_inblock), LONG, "d"},
	{"inblock", "", "inblk"},
	{"jobc", "JOBC", NULL, 0, evar, 4, EOFF(e_jobc), SHORT, "d"},
	{"ktrace", "KTRACE", NULL, 0, pvar, 8, POFF(p_traceflag), LONG, "x"},
	{"ktracep", "KTRACEP", NULL, 0, pvar, 8, POFF(p_tracep), LONG, "x"},
	{"lim", "LIM", NULL, 0, maxrss, 5},
	{"logname", "LOGNAME", NULL, LJUST, logname, MAXLOGNAME},
	{"lstart", "STARTED", NULL, LJUST|USER, lstarted, 28},
	{"majflt", "MAJFLT", NULL, USER, rvar, 4, ROFF(ru_majflt), LONG, "d"},
	{"minflt", "MINFLT", NULL, USER, rvar, 4, ROFF(ru_minflt), LONG, "d"},
	{"msgrcv", "MSGRCV", NULL, USER, rvar, 4, ROFF(ru_msgrcv), LONG, "d"},
	{"msgsnd", "MSGSND", NULL, USER, rvar, 4, ROFF(ru_msgsnd), LONG, "d"},
	{"ni", "", "nice"},
	{"nice", "NI", NULL, 0, pvar, 2, POFF(p_nice), CHAR, "d"},
	{"nivcsw", "NIVCSW", NULL, USER, rvar, 5, ROFF(ru_nivcsw), LONG, "d"},
	{"nsignals", "", "nsigs"},
	{"nsigs", "NSIGS", NULL, USER, rvar, 4, ROFF(ru_nsignals), LONG, "d"},
	{"nswap", "NSWAP", NULL, USER, rvar, 4, ROFF(ru_nswap), LONG, "d"},
	{"nvcsw", "NVCSW", NULL, USER, rvar, 5, ROFF(ru_nvcsw), LONG, "d"},
	{"nwchan", "WCHAN", NULL, 0, pvar, 6, POFF(p_wchan), KPTR, "x"},
	{"oublk", "OUBLK", NULL, USER, rvar, 4, ROFF(ru_oublock), LONG, "d"},
	{"oublock", "", "oublk"},
	{"p_ru", "P_RU", NULL, 0, pvar, 6, POFF(p_ru), KPTR, "x"},
	{"paddr", "PADDR", NULL, 0, evar, 6, EOFF(e_paddr), KPTR, "x"},
	{"pagein", "PAGEIN", NULL, USER, pagein, 6},
	{"pcpu", "", "%cpu"},
	{"pending", "", "sig"},
	{"pgid", "PGID", NULL, 0, evar, PIDLEN, EOFF(e_pgid), ULONG, PIDFMT},
	{"pid", "PID", NULL, 0, pvar, PIDLEN, POFF(p_pid), LONG, PIDFMT},
	{"pmem", "", "%mem"},
	{"poip", "POIP", NULL, 0, pvar, 4, POFF(p_poip), SHORT, "d"},
	{"ppid", "PPID", NULL, 0, pvar, PIDLEN, POFF(p_ppid), LONG, PIDFMT},
	{"pri", "PRI", NULL, 0, pri, 3},
	{"re", "RE", NULL, 0, pvar, 3, POFF(p_swtime), ULONG, "d"},
	{"rgid", "RGID", NULL, 0, pvar, UIDLEN, POFF(p_rgid), USHORT, UIDFMT},
	{"rlink", "RLINK", NULL, 0, pvar, 8, POFF(p_rlink), KPTR, "x"},
	{"rss", "RSS", NULL, 0, p_rssize, 4},
	{"rssize", "", "rsz"},
	{"rsz", "RSZ", NULL, 0, rssize, 4},
	{"ruid", "RUID", NULL, 0, pvar, UIDLEN, POFF(p_ruid), USHORT, UIDFMT},
	{"ruser", "RUSER", NULL, LJUST, runame, USERLEN},
	{"sess", "SESS", NULL, 0, evar, 6, EOFF(e_sess), KPTR, "x"},
	{"sig", "PENDING", NULL, 0, pvar, 8, POFF(p_sig), LONG, "x"},
	{"sigcatch", "CAUGHT", NULL, 0, pvar, 8, POFF(p_sigcatch), LONG, "x"},
	{"sigignore", "IGNORED",
		NULL, 0, pvar, 8, POFF(p_sigignore), LONG, "x"},
	{"sigmask", "BLOCKED", NULL, 0, pvar, 8, POFF(p_sigmask), LONG, "x"},
	{"sl", "SL", NULL, 0, pvar, 3, POFF(p_slptime), ULONG, "d"},
	{"start", "STARTED", NULL, LJUST|USER, started, 8},
	{"stat", "", "state"},
	{"state", "STAT", NULL, 0, state, 4},
	{"svgid", "SVGID",
		NULL, 0, pvar, UIDLEN, POFF(p_svgid), USHORT, UIDFMT},
	{"svuid", "SVUID",
		NULL, 0, pvar, UIDLEN, POFF(p_svuid), USHORT, UIDFMT},
	{"tdev", "TDEV", NULL, 0, tdev, 4},
	{"time", "TIME", NULL, USER, cputime, 9},
	{"tpgid", "TPGID", NULL, 0, evar, 4, EOFF(e_tpgid), ULONG, PIDFMT},
	{"trs", "TRS", NULL, 0, trss, 3},
	{"tsess", "TSESS", NULL, 0, evar, 6, EOFF(e_tsess), KPTR, "x"},
	{"tsiz", "TSIZ", NULL, 0, tsize, 4},
	{"tt", "TT", NULL, LJUST, tname, 3},
	{"tty", "TTY", NULL, LJUST, longtname, 8},
	{"ucomm", "UCOMM", NULL, LJUST, ucomm, MAXCOMLEN},
	{"uid", "UID", NULL, 0, pvar, UIDLEN, POFF(p_uid),USHORT, UIDFMT},
	{"upr", "UPR", NULL, 0, pvar, 3, POFF(p_usrpri), CHAR, "d"},
	{"uprocp", "UPROCP", NULL, USER, uvar, 6, UOFF(u_procp), KPTR, "x"},
	{"user", "USER", NULL, LJUST, uname, USERLEN},
	{"usrpri", "", "upr"},
	{"vsize", "", "vsz"},
	{"vsz", "VSZ", NULL, 0, vsize, 5},
	{"wchan", "WCHAN", NULL, LJUST, wchan, 6},
	{"xstat", "XSTAT", NULL, 0, pvar, 4, POFF(p_xstat), USHORT, "x"},
#endif
@


1.6
log
@(foo *)NULL -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.5 1997/02/12 15:28:24 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.5 1997/02/12 15:28:24 kstailey Exp $";
d369 1
a369 1
        const void *a, *b;
d371 1
a371 1
        return (strcmp(((VAR *)a)->name, ((VAR *)b)->name));
@


1.5
log
@Stat field takes 5 chars not 4 (think "IW<s+")
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.4 1997/02/05 17:10:55 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.4 1997/02/05 17:10:55 kstailey Exp $";
d355 1
a355 1
		return ((VAR *)NULL);
d360 1
a360 1
		return ((VAR *)NULL);
@


1.4
log
@Added "gid" keyword to print effective group ID of process.
(also alpha-sorted some of the man page that was nearly sorted.)

BEFORE:

kstailey@@hermes$ ps -o ruid,svuid,uid,command
 RUID SVUID   UID COMMAND
  333   333   333 -bash (bash)

worked, but group equivalent failed:

kstailey@@hermes$ ps -o rgid,svgid,gid,command
ps: gid: keyword not found
 RGID SVGID COMMAND
   20    20 -bash (bash)

AFTER:

kstailey@@hermes$ ps -o rgid,svgid,gid,command
 RGID SVGID   GID COMMAND
   20    20    20 -bash (bash)
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.3 1996/06/23 14:20:49 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.3 1996/06/23 14:20:49 deraadt Exp $";
d170 1
a170 1
	{"state", "STAT", NULL, 0, state, 4},
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: keyword.c,v 1.12.6.1 1996/05/30 21:25:13 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: keyword.c,v 1.12.6.1 1996/05/30 21:25:13 cgd Exp $";
d112 1
d201 1
@


1.2
log
@in findvar() return NULL for keywords not found
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: keyword.c,v 1.12.6.1 1996/05/30 21:25:13 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: keyword.c,v 1.12 1995/09/29 21:58:59 cgd Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: keyword.c,v 1.12 1995/09/29 21:58:59 cgd Exp $";
d357 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
