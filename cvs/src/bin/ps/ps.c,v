head	1.71;
access;
symbols
	OPENBSD_6_0:1.70.0.2
	OPENBSD_6_0_BASE:1.70
	OPENBSD_5_9:1.69.0.2
	OPENBSD_5_9_BASE:1.69
	OPENBSD_5_8:1.65.0.4
	OPENBSD_5_8_BASE:1.65
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.59.0.4
	OPENBSD_5_5_BASE:1.59
	OPENBSD_5_4:1.55.0.6
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.55.0.4
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.55.0.2
	OPENBSD_5_2_BASE:1.55
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.2
	OPENBSD_5_0:1.49.0.2
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.48.0.4
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.48.0.2
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.46.0.8
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.46.0.4
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.46.0.2
	OPENBSD_4_4_BASE:1.46
	OPENBSD_4_3:1.44.0.2
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.42.0.4
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.40.0.6
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.40.0.4
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.38.0.4
	OPENBSD_3_6_BASE:1.38
	OPENBSD_3_5:1.38.0.2
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	OPENBSD_3_3:1.30.0.4
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.71
date	2016.09.23.06.28.08;	author bentley;	state Exp;
branches;
next	1.70;
commitid	T4KnzSzaKfvTIl2L;

1.70
date	2016.03.17.05.27.10;	author bentley;	state Exp;
branches;
next	1.69;
commitid	0afdJPZPXUfvItJV;

1.69
date	2016.01.10.14.04.16;	author schwarze;	state Exp;
branches;
next	1.68;
commitid	LRaYILYXBFr3pchR;

1.68
date	2015.11.11.03.20.02;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	fjh63cMNm2837L3e;

1.67
date	2015.10.25.09.39.00;	author deraadt;	state Exp;
branches;
next	1.66;
commitid	D2D4KkN3zTC2PhBw;

1.66
date	2015.10.23.03.26.24;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	7XmiAOXOqUGI0vLc;

1.65
date	2015.06.29.15.03.33;	author bluhm;	state Exp;
branches;
next	1.64;
commitid	zqqB6c65L8hxs5Kq;

1.64
date	2015.04.09.19.48.25;	author okan;	state Exp;
branches;
next	1.63;
commitid	JqLLiaHuxRW8vjs5;

1.63
date	2015.01.16.06.39.32;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	Uu5nFG3wCl0LACBb;

1.62
date	2014.07.08.23.31.22;	author deraadt;	state Exp;
branches;
next	1.61;
commitid	3An6VhB3KqpFYVig;

1.61
date	2014.06.05.07.29.20;	author guenther;	state Exp;
branches;
next	1.60;
commitid	bZfHymBPckcCBtYW;

1.60
date	2014.05.07.01.31.25;	author tedu;	state Exp;
branches;
next	1.59;

1.59
date	2013.11.21.15.54.45;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2013.10.31.01.59.33;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2013.10.28.13.05.53;	author okan;	state Exp;
branches;
next	1.56;

1.56
date	2013.09.22.17.28.34;	author guenther;	state Exp;
branches;
next	1.55;

1.55
date	2012.04.21.03.14.50;	author guenther;	state Exp;
branches;
next	1.54;

1.54
date	2012.04.17.23.17.53;	author pirofti;	state Exp;
branches;
next	1.53;

1.53
date	2012.04.12.14.59.19;	author pirofti;	state Exp;
branches;
next	1.52;

1.52
date	2012.04.04.16.13.11;	author jsing;	state Exp;
branches;
next	1.51;

1.51
date	2011.10.13.01.15.04;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2011.09.25.00.29.59;	author guenther;	state Exp;
branches;
next	1.49;

1.49
date	2011.04.10.03.20.58;	author guenther;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.02.15.43.15;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2008.07.18.14.24.18;	author kevlo;	state Exp;
branches;
next	1.45;

1.45
date	2008.03.08.19.20.12;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2007.12.28.19.17.28;	author chl;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.01.19.32.19;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2006.11.01.19.07.18;	author jmc;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.25.15.41.07;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2004.11.24.19.17.10;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2004.09.14.23.45.35;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2004.02.24.11.53.45;	author jmc;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.08.19.28.19;	author otto;	state Exp;
branches;
next	1.36;

1.36
date	2004.02.04.12.58.27;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.08.18.18.35;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.29.00.24.15;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.11.23.42.12;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.02.23.32.09;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.15.01.19.34;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.12.03.44.35;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.09.05.46.44;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.08.22.41.46;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.06.23.55.40;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.30.17.52.40;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.30.17.02.55;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.27.12.53.47;	author mpech;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.06.13.29.08;	author mpech;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.03.04.48.15;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.03.04.30.47;	author angelos;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.17.21.12.07;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.17.00.50.16;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.15.23.32.31;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.05.00.31.51;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.05.00.30.45;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.18.17.59.54;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.16.02.19.55;	author ericj;	state Exp;
branches;
next	1.12;

1.12
date	99.06.21.20.47.59;	author art;	state Exp;
branches;
next	1.11;

1.11
date	99.04.28.20.55.14;	author alex;	state Exp;
branches;
next	1.10;

1.10
date	98.07.08.22.14.25;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.08.04.05.37.05;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.06.13.00.37.39;	author michaels;	state Exp;
branches;
next	1.7;

1.7
date	96.12.22.02.57.50;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.12.14.12.18.10;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.08.06.19.33.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.02.12.41.02;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.20.51;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.16.01.17.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.19;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.19;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.71
log
@Attempt to use stdout, stderr, or stdin terminal widths if they exist.

This behavior already existed but was unintentionally lost in revision
1.70 of ps.c.

ok millert@@ tb@@
@
text
@/*	$OpenBSD: ps.c,v 1.70 2016/03/17 05:27:10 bentley Exp $	*/
/*	$NetBSD: ps.c,v 1.15 1995/05/18 20:33:25 mycroft Exp $	*/

/*-
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXCOMLEN NODEV */
#include <sys/types.h>
#include <sys/sysctl.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/proc.h>
#include <sys/stat.h>
#include <sys/ioctl.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <kvm.h>
#include <locale.h>
#include <nlist.h>
#include <paths.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "ps.h"

extern char *__progname;

struct varent *vhead;

int	eval;			/* exit value */
int	sumrusage;		/* -S */
int	termwidth;		/* width of screen (0 == infinity) */
int	totwidth;		/* calculated width of requested variables */

int	needcomm, needenv, neednlist, commandonly;

enum sort { DEFAULT, SORTMEM, SORTCPU } sortby = DEFAULT;

static char	*kludge_oldps_options(char *);
static int	 pscomp(const void *, const void *);
static void	 scanvars(void);
static void	 usage(void);

char dfmt[] = "pid tt state time command";
char tfmt[] = "pid tid tt state time command";
char jfmt[] = "user pid ppid pgid sess jobc state tt time command";
char lfmt[] = "uid pid ppid cpu pri nice vsz rss wchan state tt time command";
char   o1[] = "pid";
char   o2[] = "tt state time command";
char ufmt[] = "user pid %cpu %mem vsz rss tt state start time command";
char vfmt[] = "pid state time sl re pagein vsz rss lim tsiz %cpu %mem command";

kvm_t *kd;
int kvm_sysctl_only;

int
main(int argc, char *argv[])
{
	struct kinfo_proc *kp, **kinfo;
	struct varent *vent;
	struct winsize ws;
	struct passwd *pwd;
	dev_t ttydev;
	pid_t pid;
	uid_t uid;
	int all, ch, flag, i, fmt, lineno, nentries;
	int prtheader, showthreads, wflag, kflag, what, Uflag, xflg;
	char *nlistf, *memf, *swapf, *cols, errbuf[_POSIX2_LINE_MAX];

	setlocale(LC_CTYPE, "");

	termwidth = 0;
	if ((cols = getenv("COLUMNS")) != NULL)
		termwidth = strtonum(cols, 1, INT_MAX, NULL);
	if (termwidth == 0 &&
	    (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == 0 ||
	    ioctl(STDERR_FILENO, TIOCGWINSZ, &ws) == 0 ||
	    ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == 0) &&
	    ws.ws_col > 0)
		termwidth = ws.ws_col - 1;
	if (termwidth == 0)
		termwidth = 79;

	if (argc > 1)
		argv[1] = kludge_oldps_options(argv[1]);

	all = fmt = prtheader = showthreads = wflag = kflag = Uflag = xflg = 0;
	pid = -1;
	uid = 0;
	ttydev = NODEV;
	memf = nlistf = swapf = NULL;
	while ((ch = getopt(argc, argv,
	    "AaCcegHhjkLlM:mN:O:o:p:rSTt:U:uvW:wx")) != -1)
		switch (ch) {
		case 'A':
			all = 1;
			xflg = 1;
			break;
		case 'a':
			all = 1;
			break;
		case 'C':
			break;			/* no-op */
		case 'c':
			commandonly = 1;
			break;
		case 'e':			/* XXX set ufmt */
			needenv = 1;
			break;
		case 'g':
			break;			/* no-op */
		case 'H':
			showthreads = 1;
			break;
		case 'h':
			prtheader = ws.ws_row > 5 ? ws.ws_row : 22;
			break;
		case 'j':
			parsefmt(jfmt);
			fmt = 1;
			jfmt[0] = '\0';
			break;
		case 'k':
			kflag = 1;
			break;
		case 'L':
			showkey();
			exit(0);
		case 'l':
			parsefmt(lfmt);
			fmt = 1;
			lfmt[0] = '\0';
			break;
		case 'M':
			memf = optarg;
			break;
		case 'm':
			sortby = SORTMEM;
			break;
		case 'N':
			nlistf = optarg;
			break;
		case 'O':
			parsefmt(o1);
			parsefmt(optarg);
			parsefmt(o2);
			o1[0] = o2[0] = '\0';
			fmt = 1;
			break;
		case 'o':
			parsefmt(optarg);
			fmt = 1;
			break;
		case 'p':
			pid = atol(optarg);
			xflg = 1;
			break;
		case 'r':
			sortby = SORTCPU;
			break;
		case 'S':
			sumrusage = 1;
			break;
		case 'T':
			if ((optarg = ttyname(STDIN_FILENO)) == NULL)
				errx(1, "stdin: not a terminal");
			/* FALLTHROUGH */
		case 't': {
			struct stat sb;
			char *ttypath, pathbuf[PATH_MAX];

			if (strcmp(optarg, "co") == 0)
				ttypath = _PATH_CONSOLE;
			else if (*optarg != '/')
				(void)snprintf(ttypath = pathbuf,
				    sizeof(pathbuf), "%s%s", _PATH_TTY, optarg);
			else
				ttypath = optarg;
			if (stat(ttypath, &sb) == -1)
				err(1, "%s", ttypath);
			if (!S_ISCHR(sb.st_mode))
				errx(1, "%s: not a terminal", ttypath);
			ttydev = sb.st_rdev;
			break;
		}
		case 'U':
			pwd = getpwnam(optarg);
			if (pwd == NULL)
				errx(1, "%s: no such user", optarg);
			uid = pwd->pw_uid;
			endpwent();
			Uflag = xflg = 1;
			break;
		case 'u':
			parsefmt(ufmt);
			sortby = SORTCPU;
			fmt = 1;
			ufmt[0] = '\0';
			break;
		case 'v':
			parsefmt(vfmt);
			sortby = SORTMEM;
			fmt = 1;
			vfmt[0] = '\0';
			break;
		case 'W':
			swapf = optarg;
			break;
		case 'w':
			if (wflag)
				termwidth = UNLIMITED;
			else if (termwidth < 131)
				termwidth = 131;
			wflag = 1;
			break;
		case 'x':
			xflg = 1;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

#define	BACKWARD_COMPATIBILITY
#ifdef	BACKWARD_COMPATIBILITY
	if (*argv) {
		nlistf = *argv;
		if (*++argv) {
			memf = *argv;
			if (*++argv)
				swapf = *argv;
		}
	}
#endif

	if (nlistf == NULL && memf == NULL && swapf == NULL) {
		kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, errbuf);
		kvm_sysctl_only = 1;
	} else {
		kd = kvm_openfiles(nlistf, memf, swapf, O_RDONLY, errbuf);
	}
	if (kd == NULL)
		errx(1, "%s", errbuf);

	if (pledge("stdio rpath getpw ps", NULL) == -1)
		err(1, "pledge");

	if (!fmt) {
		if (showthreads)
			parsefmt(tfmt);
		else
			parsefmt(dfmt);
	}

	/* XXX - should be cleaner */
	if (!all && ttydev == NODEV && pid == -1 && !Uflag) {
		uid = getuid();
		Uflag = 1;
	}

	/*
	 * scan requested variables, noting what structures are needed,
	 * and adjusting header widths as appropriate.
	 */
	scanvars();

	if (neednlist && !nlistread)
		(void) donlist();

	/*
	 * get proc list
	 */
	if (Uflag) {
		what = KERN_PROC_UID;
		flag = uid;
	} else if (ttydev != NODEV) {
		what = KERN_PROC_TTY;
		flag = ttydev;
	} else if (pid != -1) {
		what = KERN_PROC_PID;
		flag = pid;
	} else if (kflag) {
		what = KERN_PROC_KTHREAD;
		flag = 0;
	} else {
		what = KERN_PROC_ALL;
		flag = 0;
	}
	if (showthreads)
		what |= KERN_PROC_SHOW_THREADS;

	/*
	 * select procs
	 */
	kp = kvm_getprocs(kd, what, flag, sizeof(*kp), &nentries);
	if (kp == NULL)
		errx(1, "%s", kvm_geterr(kd));

	/*
	 * print header
	 */
	printheader();
	if (nentries == 0)
		exit(1);
	/*
	 * sort proc list, we convert from an array of structs to an array
	 * of pointers to make the sort cheaper.
	 */
	if ((kinfo = reallocarray(NULL, nentries, sizeof(*kinfo))) == NULL)
		err(1, "failed to allocate memory for proc pointers");
	for (i = 0; i < nentries; i++)
		kinfo[i] = &kp[i];
	qsort(kinfo, nentries, sizeof(*kinfo), pscomp);
	/*
	 * for each proc, call each variable output function.
	 */
	for (i = lineno = 0; i < nentries; i++) {
		if (showthreads == 0 && (kinfo[i]->p_flag & P_THREAD) != 0)
			continue;
		if (xflg == 0 && ((int)kinfo[i]->p_tdev == NODEV ||
		    (kinfo[i]->p_psflags & PS_CONTROLT ) == 0))
			continue;
		if (showthreads && kinfo[i]->p_tid == -1)
			continue;
		for (vent = vhead; vent; vent = vent->next) {
			(vent->var->oproc)(kinfo[i], vent);
			if (vent->next != NULL)
				(void)putchar(' ');
		}
		(void)putchar('\n');
		if (prtheader && lineno++ == prtheader - 4) {
			(void)putchar('\n');
			printheader();
			lineno = 0;
		}
	}
	exit(eval);
}

static void
scanvars(void)
{
	struct varent *vent;
	VAR *v;
	int i;

	for (vent = vhead; vent; vent = vent->next) {
		v = vent->var;
		i = strlen(v->header);
		if (v->width < i)
			v->width = i;
		totwidth += v->width + 1;	/* +1 for space */
		if (v->flag & COMM)
			needcomm = 1;
		if (v->flag & NLIST)
			neednlist = 1;
	}
	totwidth--;
}

static int
pscomp(const void *v1, const void *v2)
{
	const struct kinfo_proc *kp1 = *(const struct kinfo_proc **)v1;
	const struct kinfo_proc *kp2 = *(const struct kinfo_proc **)v2;
	int i;
#define VSIZE(k) ((k)->p_vm_dsize + (k)->p_vm_ssize + (k)->p_vm_tsize)

	if (sortby == SORTCPU && (i = getpcpu(kp2) - getpcpu(kp1)) != 0)
		return (i);
	if (sortby == SORTMEM && (i = VSIZE(kp2) - VSIZE(kp1)) != 0)
		return (i);
	if ((i = kp1->p_tdev - kp2->p_tdev) == 0 &&
	    (i = kp1->p_ustart_sec - kp2->p_ustart_sec) == 0)
		i = kp1->p_ustart_usec - kp2->p_ustart_usec;
	return (i);
}

/*
 * ICK (all for getopt), would rather hide the ugliness
 * here than taint the main code.
 *
 *  ps foo -> ps -foo
 *  ps 34 -> ps -p34
 *
 * The old convention that 't' with no trailing tty arg means the users
 * tty, is only supported if argv[1] doesn't begin with a '-'.  This same
 * feature is available with the option 'T', which takes no argument.
 */
static char *
kludge_oldps_options(char *s)
{
	size_t len;
	char *newopts, *ns, *cp;

	len = strlen(s);
	if ((newopts = ns = malloc(2 + len + 1)) == NULL)
		err(1, NULL);
	/*
	 * options begin with '-'
	 */
	if (*s != '-')
		*ns++ = '-';	/* add option flag */

	/*
	 * gaze to end of argv[1]
	 */
	cp = s + len - 1;
	/*
	 * if last letter is a 't' flag with no argument (in the context
	 * of the oldps options -- option string NOT starting with a '-' --
	 * then convert to 'T' (meaning *this* terminal, i.e. ttyname(0)).
	 */
	if (*cp == 't' && *s != '-')
		*cp = 'T';
	else {
		/*
		 * otherwise check for trailing number, which *may* be a
		 * pid.
		 */
		while (cp >= s && isdigit((unsigned char)*cp))
			--cp;
	}
	cp++;
	memmove(ns, s, (size_t)(cp - s));	/* copy up to trailing number */
	ns += cp - s;
	/*
	 * if there's a trailing number, and not a preceding 'p' (pid) or
	 * 't' (tty) flag, then assume it's a pid and insert a 'p' flag.
	 */
	if (isdigit((unsigned char)*cp) &&
	    (cp == s || (cp[-1] != 't' && cp[-1] != 'p' &&
	    (cp - 1 == s || cp[-2] != 't'))))
		*ns++ = 'p';
	/* and append the number */
	(void)strlcpy(ns, cp, newopts + len + 3 - ns);

	return (newopts);
}

static void
usage(void)
{
	(void)fprintf(stderr,
	    "usage: %s [-AaceHhjkLlmrSTuvwx] [-M core] [-N system] [-O fmt] [-o fmt] [-p pid]\n",
	    __progname);
	(void)fprintf(stderr,
	    "%-*s[-t tty] [-U username] [-W swap]\n", (int)strlen(__progname) + 8, "");
	exit(1);
}
@


1.70
log
@Switch (non-curses, non-ksh) programs that use COLUMNS to a single idiom.

Previously behaviors were all over the map. This changes them to
use COLUMNS first, and either terminal width or a hardcoded value
(typically 80) as appropriate.

ok deraadt@@; man bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.69 2016/01/10 14:04:16 schwarze Exp $	*/
d108 4
a111 1
	if (termwidth == 0 && ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == 0 &&
@


1.69
log
@UTF-8 support:
In a UTF-8 locale, columnate correctly and replace valid, but non-
printable characters with the Unicode replacement character U+FFFD.
No change in the C/POSIX locale, and no change for invalid bytes.
Grand total, the code becomes shorter by almost 30 lines.
Feedback from czarkoff@@, OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.68 2015/11/11 03:20:02 deraadt Exp $	*/
d105 8
a112 16
	if ((cols = getenv("COLUMNS")) != NULL && *cols != '\0') {
		const char *errstr;

		termwidth = strtonum(cols, 1, INT_MAX, &errstr);
		if (errstr != NULL)
			warnx("COLUMNS: %s: %s", cols, errstr);
	}
	if (termwidth == 0) {
		if ((ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1 &&
		    ioctl(STDERR_FILENO, TIOCGWINSZ, &ws) == -1 &&
		    ioctl(STDIN_FILENO,  TIOCGWINSZ, &ws) == -1) ||
		    ws.ws_col == 0)
			termwidth = 79;
		else
			termwidth = ws.ws_col - 1;
	}
@


1.68
log
@fix pledge error message
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.67 2015/10/25 09:39:00 deraadt Exp $	*/
d47 1
d102 2
@


1.67
log
@need "getpw" pledge; spotted by matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.66 2015/10/23 03:26:24 deraadt Exp $	*/
d282 1
a282 1
		err(1, "abort pledge");
@


1.66
log
@With new pledge "ps" and "vminfo" requests, ps/top/w become possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.65 2015/06/29 15:03:33 bluhm Exp $	*/
d281 1
a281 1
	if (pledge("stdio rpath ps", NULL) == -1)
@


1.65
log
@After removing the p_swtime from the kernel, ps always printed 0.0
as %cpu time.  Remove the calculation in ps that includes the process
lifetime.  Just print the p_pctcpu value, that was done before when
ps was called with -C.  Keep -C as a no-op for existing scripts.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.64 2015/04/09 19:48:25 okan Exp $	*/
d280 3
@


1.64
log
@kflag and wflag don't need to be counters; wflag only needs to know if
greater than 0 for its one test case.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.63 2015/01/16 06:39:32 deraadt Exp $	*/
a62 1
int	rawcpu;			/* -C */
d138 1
a138 2
			rawcpu = 1;
			break;
d478 2
a479 2
	    "usage: %s [-AaCceHhjkLlmrSTuvwx] [-M core] [-N system] [-O fmt] [-o fmt] [-p pid]\n",
	    __progname);	
@


1.63
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.62 2014/07/08 23:31:22 deraadt Exp $	*/
d161 1
a161 1
			kflag++;
d251 1
a251 1
			wflag++;
@


1.62
log
@sys/user.h can now be substantially gutted.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.61 2014/06/05 07:29:20 guenther Exp $	*/
d33 2
a34 1
#include <sys/param.h>
d207 1
a207 1
			char *ttypath, pathbuf[MAXPATHLEN];
@


1.61
log
@Add support for COLUMNS env variable, inspired by FreeBSD but with a dash
of strtonum() from millert@@ sprinkled on top.
Also, we've always supported TZ for formatting dates, so say so.

ok jmc@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.60 2014/05/07 01:31:25 tedu Exp $	*/
a34 1
#include <sys/user.h>
@


1.60
log
@convert calloc to use reallocarray instead. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.59 2013/11/21 15:54:45 deraadt Exp $	*/
d101 1
a101 1
	char *nlistf, *memf, *swapf, errbuf[_POSIX2_LINE_MAX];
d103 16
a118 7
	if ((ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1 &&
	    ioctl(STDERR_FILENO, TIOCGWINSZ, &ws) == -1 &&
	    ioctl(STDIN_FILENO,  TIOCGWINSZ, &ws) == -1) ||
	    ws.ws_col == 0)
		termwidth = 79;
	else
		termwidth = ws.ws_col - 1;
@


1.59
log
@add unsigned char casts for specific calls to ctype.h macros.
ok guenther step
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.58 2013/10/31 01:59:33 deraadt Exp $	*/
d335 1
a335 1
	if ((kinfo = calloc(sizeof(*kinfo), nentries)) == NULL)
@


1.58
log
@pull in less .h to do the same
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.57 2013/10/28 13:05:53 okan Exp $	*/
d447 1
a447 1
		while (cp >= s && isdigit(*cp))
d457 2
a458 1
	if (isdigit(*cp) && (cp == s || (cp[-1] != 't' && cp[-1] != 'p' &&
@


1.57
log
@add -A (-ax) support; from Lauri Tirkkonen with some option sorting.

ok guenther@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.56 2013/09/22 17:28:34 guenther Exp $	*/
d34 1
@


1.56
log
@Stop merging the per-thread and per-process flags when reporting
them via sysctl(KERN_PROC).  In struct kinfo_proc the per-process
flags move to p_psflags, leaving the per-thread flags in p_flags.
Flag descriptions in ps(1) updated to be less obtuse.

discussed with matthew@@ some time ago; ok jca@@, manpage bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.55 2012/04/21 03:14:50 guenther Exp $	*/
d119 1
a119 1
	    "acCegHhjkLlM:mN:O:o:p:rSTt:U:uvW:wx")) != -1)
d121 4
d128 3
a136 3
		case 'C':
			rawcpu = 1;
			break;
d469 1
a469 1
	    "usage: %s [-aCceHhjkLlmrSTuvwx] [-M core] [-N system] [-O fmt] [-o fmt] [-p pid]\n",
@


1.55
log
@Remove a check made superfluous by the KERN_PROC_SHOW_THREADS flag.
This lets new binaries work (at least w/o the -H option) with old kernels.

ok pirofti@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.54 2012/04/17 23:17:53 pirofti Exp $	*/
d342 1
a342 1
		    (kinfo[i]->p_flag & P_CONTROLT ) == 0))
@


1.54
log
@Make it optional for kvm_getprocs() (and related sysctl) to return
thread information.

Add a KERN_PROC_SHOW_THREADS flag that has to be set in order to get the
thread info and make it off by default. This creates backwards compatibility
for applications that relied on a given size/number of items to be returned.

Modify ps(1) and top(1) accordingly.

Okay guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.53 2012/04/12 14:59:19 pirofti Exp $	*/
a342 2
			continue;
		if (!showthreads && kinfo[i]->p_tid != -1)
@


1.53
log
@Add per thread accounting, mainly for usage & friends.

This expands the already bloated FILL_KPROC macro to take an extra
parameter that indicates if the callee is a thread or a process.

The userland bits are adjusted accordingly and ps(1) and top(1) now
display per thread usage times when -H is used.

Also pkill(1) had to be adjusted so that duplicates don't pop up.

libkvm does basically the same thing as the kernel bits.

Okay guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.52 2012/04/04 16:13:11 jsing Exp $	*/
d310 2
@


1.52
log
@Add "tid" as a formatting keyword. If the -H option is specified, include
the thread ID in the default format.

ok deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.50 2011/09/25 00:29:59 guenther Exp $	*/
d341 4
@


1.51
log
@Remove support for systems that lack CPUs.  (i.e., stop looking up
HW_NCPU when the only test was whether it's non-zero)

ok millert@@
@
text
@d77 1
d269 6
a274 2
	if (!fmt)
		parsefmt(dfmt);
@


1.50
log
@Add -H option to show rthreads, hiding them by default

Diff from uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.49 2011/04/10 03:20:58 guenther Exp $	*/
a39 2
#include <sys/sysctl.h>
#include <sys/types.h>
a66 2
int	ncpu = 1;

d97 1
a97 1
	int all, ch, flag, i, fmt, lineno, nentries, mib[6];
a99 1
	size_t size;
a304 5

	mib[0] = CTL_HW;
	mib[1] = HW_NCPU;
	size = sizeof(ncpu);
	(void) sysctl(mib, 2, &ncpu, &size, NULL, 0);
@


1.49
log
@Switch back from KERN_PROC2/kinfo_proc2 to KERN_PROC/kinfo_proc now
that we've got name we want for the API we want

"ZAP!" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.48 2010/07/02 15:43:15 guenther Exp $	*/
d102 1
a102 1
	int prtheader, wflag, kflag, what, Uflag, xflg;
d117 1
a117 1
	all = fmt = prtheader = wflag = kflag = Uflag = xflg = 0;
d123 1
a123 1
	    "acCeghjkLlM:mN:O:o:p:rSTt:U:uvW:wx")) != -1)
d139 3
d342 2
d466 1
a466 1
	    "usage: %s [-aCcehjkLlmrSTuvwx] [-M core] [-N system] [-O fmt] [-o fmt] [-p pid]\n",
@


1.48
log
@ps uses libkvm, so it doesn't need its own copy of the "get process info
via sysctl" logic.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.47 2009/10/27 23:59:22 deraadt Exp $	*/
d94 1
a94 1
	struct kinfo_proc2 *kp, **kinfo;
d316 1
a316 1
	kp = kvm_getproc2(kd, what, flag, sizeof(*kp), &nentries);
d381 2
a382 2
	const struct kinfo_proc2 *kp1 = *(const struct kinfo_proc2 **)v1;
	const struct kinfo_proc2 *kp2 = *(const struct kinfo_proc2 **)v2;
@


1.47
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.46 2008/07/18 14:24:18 kevlo Exp $	*/
d267 1
a267 1
	if (kd == NULL && (nlistf != NULL || memf != NULL || swapf != NULL))
d316 4
a319 28
	if (kd != NULL) {
		kp = kvm_getproc2(kd, what, flag, sizeof(*kp), &nentries);
		if (kp == NULL)
			errx(1, "%s", kvm_geterr(kd));
	} else {
		mib[0] = CTL_KERN;
		mib[1] = KERN_PROC2;
		mib[2] = what;
		mib[3] = flag;
		mib[4] = sizeof(struct kinfo_proc2);
		mib[5] = 0;
	    retry:
		if (sysctl(mib, 6, NULL, &size, NULL, 0) < 0)
			err(1, "could not get kern.proc2 size");
		size = 5 * size / 4;		/* extra slop */
		if ((kp = malloc(size)) == NULL)
			err(1,
			    "failed to allocate memory for proc structures");
		mib[5] = (int)(size / sizeof(struct kinfo_proc2));
		if (sysctl(mib, 6, kp, &size, NULL, 0) < 0) {
			if (errno == ENOMEM) {
				free(kp);
				goto retry;
			}
			err(1, "could not read kern.proc2");
		}
		nentries = (int)(size / sizeof(struct kinfo_proc2));
	}
@


1.46
log
@remove unnessasary cast.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.45 2008/03/08 19:20:12 millert Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1990, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)ps.c	8.4 (Berkeley) 4/2/94";
#else
static char rcsid[] = "$OpenBSD: ps.c,v 1.45 2008/03/08 19:20:12 millert Exp $";
#endif
#endif /* not lint */
@


1.45
log
@Instead of calling donlist() in the format print routines, call it
a single time before we print anything, if needed.  Uses a flag to
specify which formats need the kernel info donlist() provides.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.44 2007/12/28 19:17:28 chl Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.44 2007/12/28 19:17:28 chl Exp $";
d138 1
a138 1
		switch((char)ch) {
@


1.44
log
@printf field widths are always int, so add a cast to remove
"warning: field width is not type int"

"looks good" otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.43 2007/09/01 19:32:19 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.43 2007/09/01 19:32:19 deraadt Exp $";
d85 1
a85 1
int	needcomm, needenv, commandonly;
d298 4
d410 2
@


1.43
log
@malloc(n * m) -> calloc(n, m); from zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.42 2006/11/01 19:07:18 jmc Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.42 2006/11/01 19:07:18 jmc Exp $";
d496 1
a496 1
	    "%-*s[-t tty] [-U username] [-W swap]\n", strlen(__progname) + 8, "");
@


1.42
log
@simplify synopsis and sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.41 2006/04/25 15:41:07 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.41 2006/04/25 15:41:07 deraadt Exp $";
d364 1
a364 1
	if ((kinfo = malloc(sizeof(*kinfo) * nentries)) == NULL)
@


1.41
log
@various small lint cleanups; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.40 2004/11/24 19:17:10 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.40 2004/11/24 19:17:10 deraadt Exp $";
d493 1
a493 1
	    "usage: %s [-][aCcehjklmrSTuvwx] [-M core] [-N system] [-O fmt] [-o fmt] [-p pid]\n",
a496 1
	(void)fprintf(stderr, "       %s [-L]\n", __progname);
@


1.40
log
@on MP machines, in STAT field, add /# where # is the cpu number so that
you can see processes move around; ok pval millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.39 2004/09/14 23:45:35 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.39 2004/09/14 23:45:35 deraadt Exp $";
d120 3
a122 3
	if ((ioctl(STDOUT_FILENO, TIOCGWINSZ, (char *)&ws) == -1 &&
	    ioctl(STDERR_FILENO, TIOCGWINSZ, (char *)&ws) == -1 &&
	    ioctl(STDIN_FILENO,  TIOCGWINSZ, (char *)&ws) == -1) ||
@


1.39
log
@remove unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.38 2004/02/24 11:53:45 jmc Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.38 2004/02/24 11:53:45 jmc Exp $";
d83 2
d317 6
@


1.38
log
@- `C' before `c'
- replace `<' and `>'
- sync usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.37 2004/02/08 19:28:19 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.37 2004/02/08 19:28:19 otto Exp $";
d75 1
a75 1
struct varent *vhead, *vtail;
d365 1
a365 1
		if (xflg == 0 && (kinfo[i]->p_tdev == NODEV ||
@


1.37
log
@'ps' should not act like 'ps a'. Resolves PR 3676.
ok tdeval@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.36 2004/02/04 12:58:27 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.36 2004/02/04 12:58:27 otto Exp $";
d485 1
a485 1
	    "usage: %s [-][acCehjklmrSTuvwx] [-O|o fmt] [-p pid] [-t tty] [-U user]\n",
d488 1
a488 1
	    "%-*s[-M core] [-N system] [-W swap]\n", strlen(__progname) + 8, "");
@


1.36
log
@(uid_t) -1 is a valid uid, so do not use it as a flag.
From Joris Vink <nimadeus at pandora dot be> with tweaks from me.
ok tdeval@@ hshoexer@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.35 2004/01/08 18:18:35 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.35 2004/01/08 18:18:35 millert Exp $";
d286 1
a286 1
	if (!all && ttydev == NODEV && pid == -1 && !Uflag)
d288 2
@


1.35
log
@Convert to kinfo_proc2.  The sort order for -u and -m will be different
due to a bug fix in the sort routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.34 2003/07/29 00:24:15 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.34 2003/07/29 00:24:15 deraadt Exp $";
d114 1
a114 1
	int prtheader, wflag, kflag, what, xflg;
d129 1
a129 1
	all = fmt = prtheader = wflag = kflag = xflg = 0;
d131 1
a131 1
	uid = (uid_t) -1;
d228 1
a228 1
			xflg = 1;
d286 1
a286 1
	if (!all && ttydev == NODEV && pid == -1 && uid == (uid_t)-1)
d297 1
a297 1
	if (uid != (uid_t) -1) {
@


1.34
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.33 2003/06/11 23:42:12 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.33 2003/06/11 23:42:12 deraadt Exp $";
a74 1
KINFO *kinfo;
a88 1
static void	 saveuser(KINFO *);
d106 1
a106 1
	struct kinfo_proc *kp;
d113 1
a113 1
	int all, ch, flag, i, fmt, lineno, nentries, mib[4], mibcnt, nproc;
d298 2
a299 3
		what = mib[2] = KERN_PROC_UID;
		flag = mib[3] = uid;
		mibcnt = 4;
d301 2
a302 3
		what = mib[2] = KERN_PROC_TTY;
		flag = mib[3] = ttydev;
		mibcnt = 4;
d304 2
a305 3
		what = mib[2] = KERN_PROC_PID;
		flag = mib[3] = pid;
		mibcnt = 4;
d307 1
a307 1
		what = mib[2] = KERN_PROC_KTHREAD;
a308 1
		mibcnt = 3;
d310 1
a310 1
		what = mib[2] = KERN_PROC_ALL;
a311 1
		mibcnt = 3;
d317 2
a318 1
		if ((kp = kvm_getprocs(kd, what, flag, &nentries)) == 0)
d320 1
a320 2
	}
	else {
d322 10
a331 8
		mib[1] = KERN_NPROCS;
		size = sizeof (nproc);
		if (sysctl(mib, 2, &nproc, &size, NULL, 0) < 0)
			err(1, "could not get kern.nproc");
		/* Allocate more memory than is needed, just in case */
		size = (5 * nproc * sizeof(struct kinfo_proc)) / 4;
		kp = calloc(size, sizeof(char));
		if (kp == NULL)
d333 10
a342 12
			    "failed to allocated memory for proc structures");
		mib[1] = KERN_PROC;
		if (sysctl(mib, mibcnt, kp, &size, NULL, 0) < 0)
			err(1, "could not read kern.proc");
		nentries = size / sizeof(struct kinfo_proc);
	}

	if ((kinfo = malloc(nentries * sizeof(*kinfo))) == NULL)
		err(1, NULL);
	for (i = nentries; --i >= 0; ++kp) {
		kinfo[i].ki_p = kp;
		saveuser(&kinfo[i]);
d351 2
a352 1
	 * sort proc list
d354 5
a358 1
	qsort(kinfo, nentries, sizeof(KINFO), pscomp);
d363 2
a364 4
		KINFO *ki = &kinfo[i];

		if (xflg == 0 && (KI_EPROC(ki)->e_tdev == NODEV ||
		    (KI_PROC(ki)->p_flag & P_CONTROLT ) == 0))
d367 1
a367 1
			(vent->var->oproc)(ki, vent);
a399 14
static void
saveuser(KINFO *ki)
{
	struct usave *usp;

	usp = &ki->ki_u;
	usp->u_valid = KI_EPROC(ki)->e_pstats_valid;
	if (!usp->u_valid)
		return;
	usp->u_start = KI_EPROC(ki)->e_pstats.p_start;
	usp->u_ru = KI_EPROC(ki)->e_pstats.p_ru;
	usp->u_cru = KI_EPROC(ki)->e_pstats.p_cru;
}

d401 1
a401 1
pscomp(const void *a, const void *b)
d403 2
d406 9
a414 14
#define VSIZE(k) (KI_EPROC(k)->e_vm.vm_dsize + KI_EPROC(k)->e_vm.vm_ssize + \
		  KI_EPROC(k)->e_vm.vm_tsize)
#define STARTTIME(k) (k->ki_u.u_start.tv_sec)
#define STARTuTIME(k) (k->ki_u.u_start.tv_usec)

	if (sortby == SORTCPU)
		return (getpcpu((KINFO *)b) - getpcpu((KINFO *)a));
	if (sortby == SORTMEM)
		return (VSIZE((KINFO *)b) - VSIZE((KINFO *)a));
	i =  KI_EPROC((KINFO *)a)->e_tdev - KI_EPROC((KINFO *)b)->e_tdev;
	if (i == 0)
		i = STARTTIME(((KINFO *)a)) - STARTTIME(((KINFO *)b));
		if (i == 0)
			i = STARTuTIME(((KINFO *)a)) - STARTuTIME(((KINFO *)b));
@


1.33
log
@ansification, art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.32 2003/06/02 23:32:09 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.32 2003/06/02 23:32:09 millert Exp $";
d121 3
a123 3
	     ioctl(STDERR_FILENO, TIOCGWINSZ, (char *)&ws) == -1 &&
	     ioctl(STDIN_FILENO,  TIOCGWINSZ, (char *)&ws) == -1) ||
	     ws.ws_col == 0)
d504 2
a505 2
            "usage: %s [-][acCehjklmrSTuvwx] [-O|o fmt] [-p pid] [-t tty] [-U user]\n",
	     __progname);	
@


1.32
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.31 2003/04/15 01:19:34 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.31 2003/04/15 01:19:34 deraadt Exp $";
d106 1
a106 3
main(argc, argv)
	int argc;
	char *argv[];
d386 1
a386 1
scanvars()
d405 1
a405 2
saveuser(ki)
	KINFO *ki;
d419 1
a419 2
pscomp(a, b)
	const void *a, *b;
d451 1
a451 2
kludge_oldps_options(s)
	char *s;
d501 1
a501 1
usage()
@


1.31
log
@mix of tdeval and my string cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.30 2002/06/12 03:44:35 art Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.30 2002/06/12 03:44:35 art Exp $";
@


1.30
log
@unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.29 2002/06/09 05:46:44 art Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.29 2002/06/09 05:46:44 art Exp $";
d466 1
a466 1
	if ((newopts = ns = malloc(len + 3)) == NULL)
d473 1
d503 2
a504 1
	(void)strcpy(ns, cp);		/* and append the number */
@


1.29
log
@Fix the start time on sysctl kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.28 2002/06/08 22:41:46 art Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.28 2002/06/08 22:41:46 art Exp $";
a413 1
	struct pstats pstats;
@


1.28
log
@Use KVM_NO_FILES and remove the setgid.
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.27 2002/04/06 23:55:40 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.27 2002/04/06 23:55:40 millert Exp $";
d418 6
a423 14
	if (kd != NULL && kvm_read(kd, (u_long)&KI_PROC(ki)->p_addr->u_stats,
	    &pstats, sizeof(pstats)) == sizeof(pstats)) {
		/*
		 * The u-area might be swapped out, and we can't get
		 * at it because we have a crashdump and no swap.
		 * If it's here fill in these fields, otherwise, just
		 * leave them 0.
		 */
		usp->u_start = pstats.p_start;
		usp->u_ru = pstats.p_ru;
		usp->u_cru = pstats.p_cru;
		usp->u_valid = 1;
	} else
		usp->u_valid = 0;
@


1.27
log
@Fix a typo and sync usage() with man page; Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.26 2002/02/16 21:27:07 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.26 2002/02/16 21:27:07 millert Exp $";
d107 1
d280 6
a285 7
	/*
	 * Discard setgid privileges if not the running kernel so that bad
	 * guys can't print interesting stuff from kernel memory.
	 */
	if (nlistf != NULL || memf != NULL || swapf != NULL) {
		setegid(getgid());
		setgid(getgid());
a286 2

	kd = kvm_openfiles(nlistf, memf, swapf, O_RDONLY, errbuf);
a288 3

	setegid(getgid());
	setgid(getgid());
@


1.26
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.25 2002/01/30 17:52:40 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.25 2002/01/30 17:52:40 mickey Exp $";
d304 1
a304 1
	 * and adjusting header widths as appropiate.
d525 1
a525 1
            "usage: %s [-][aChjlmrSTuvwx] [-O|o fmt] [-p pid] [-t tty] [-U user]\n",
@


1.25
log
@right, just check more for nulls; from Dan Harnett <danh@@wzrd.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.24 2002/01/30 17:02:55 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.24 2002/01/30 17:02:55 mickey Exp $";
d92 5
a96 5
static char	*kludge_oldps_options __P((char *));
static int	 pscomp __P((const void *, const void *));
static void	 saveuser __P((KINFO *));
static void	 scanvars __P((void));
static void	 usage __P((void));
@


1.24
log
@always check for kvm_openfiles failure; pointed out by juan@@coredump.com.ar in pr/2362
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.23 2001/09/27 12:53:47 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.23 2001/09/27 12:53:47 mpech Exp $";
d289 1
a289 1
	if (kd == NULL)
d423 1
a423 1
	if (kvm_read(kd, (u_long)&KI_PROC(ki)->p_addr->u_stats,
@


1.23
log
@If kvm_openfiles() fail the systctl() should work.
Spotted by: mike <mike@@gravitino.net>
Patch from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.22 2001/09/06 13:29:08 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.22 2001/09/06 13:29:08 mpech Exp $";
d289 1
a289 1
	if (kd == NULL && (nlistf != NULL || memf != NULL || swapf != NULL))
@


1.22
log
@o) __progname aria;

millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.21 2001/06/03 04:48:15 angelos Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.21 2001/06/03 04:48:15 angelos Exp $";
d289 1
a289 1
	if (kd == 0)
@


1.21
log
@Use kern.nprocs
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.20 2001/06/03 04:30:47 angelos Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.20 2001/06/03 04:30:47 angelos Exp $";
d77 2
a523 1

d525 5
a529 4
	    "usage:\t%s\n\t   %s\n\t%s\n",
	    "ps [-][aChjlmrSTuvwx] [-O|o fmt] [-p pid] [-t tty] [-U user]",
	    "[-M core] [-N system] [-W swap]",
	    "ps [-L]");
@


1.20
log
@Use sysctl to get process information, if kvm has not been initialized
(which is still not the case).
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.19 2001/04/17 21:12:07 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.19 2001/04/17 21:12:07 millert Exp $";
d118 1
a118 1
	int all, ch, flag, i, fmt, lineno, nentries, mib[4], mibcnt;
d338 6
a343 5
		mib[1] = KERN_PROC;
		size = 0;
		if (sysctl(mib, mibcnt, NULL, &size, NULL, 0) < 0)
			err(1, "could not get kern.proc size");
		size *= 2;
d348 1
@


1.19
log
@Missing bits from last commit here; kstailey@@disclosure.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.18 2001/04/17 00:50:16 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.18 2001/04/17 00:50:16 millert Exp $";
d118 1
a118 1
	int all, ch, flag, i, fmt, lineno, nentries;
d121 1
d309 3
a311 2
		what = KERN_PROC_UID;
		flag = uid;
d313 3
a315 2
		what = KERN_PROC_TTY;
		flag = ttydev;
d317 3
a319 2
		what = KERN_PROC_PID;
		flag = pid;
d321 1
a321 1
		what = KERN_PROC_KTHREAD;
d323 1
d325 1
a325 1
		what = KERN_PROC_ALL;
d327 1
d332 20
a351 2
	if ((kp = kvm_getprocs(kd, what, flag, &nentries)) == 0)
		errx(1, "%s", kvm_geterr(kd));
@


1.18
log
@Updated version of last patch from kstailey@@disclosure.com.
We should always save the user area since we are sorting on
start time (which lives there).
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.17 2001/04/15 23:32:31 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.17 2001/04/15 23:32:31 millert Exp $";
d88 1
a88 1
enum sort { DEFAULT, SORTMEM, SORTCPU, SORTSTART } sortby = SORTSTART;
d425 2
a426 1
	if (sortby == SORTSTART) {
a429 5
		return (i);
	}
	i =  KI_EPROC((KINFO *)a)->e_tdev - KI_EPROC((KINFO *)b)->e_tdev;
	if (i == 0)
		i = KI_PROC((KINFO *)a)->p_pid - KI_PROC((KINFO *)b)->p_pid;
@


1.17
log
@Randomized PIDs uglifies "ps -ax" output since it sorts on tty then
PID and it makes no sense to sort on a strong random number.
This patch changes the default to be the start time so output looks
logical to a human.  From kstailey@@disclosure.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.16 2001/02/05 00:31:51 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.16 2001/02/05 00:31:51 deraadt Exp $";
d86 1
a86 1
int	needuser, needcomm, needenv, commandonly;
a298 3
	if (sortby == SORTSTART)
		needuser = 1;

d332 1
a332 2
		if (needuser)
			saveuser(&kinfo[i]);
a380 2
		if (v->flag & USER)
			needuser = 1;
@


1.16
log
@[-] outside braces
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.15 2001/02/05 00:30:45 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.15 2001/02/05 00:30:45 deraadt Exp $";
d88 1
a88 1
enum sort { DEFAULT, SORTMEM, SORTCPU } sortby = DEFAULT;
d299 3
d424 2
d431 6
@


1.15
log
@extra - in usage too
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.14 2000/06/18 17:59:54 niklas Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.14 2000/06/18 17:59:54 niklas Exp $";
d498 1
a498 1
	    "ps [[-]aChjlmrSTuvwx] [-O|o fmt] [-p pid] [-t tty] [-U user]",
@


1.14
log
@Mark kernel threads as system processes.  Make ps hide them by default,
show them with -k.  Do not try to show RSS based values for them as they
mess up column alignment.  vmstat -f now shows kernel threads separately
from rforks too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.13 2000/04/16 02:19:55 ericj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.13 2000/04/16 02:19:55 ericj Exp $";
d498 1
a498 1
	    "ps [-aChjlmrSTuvwx] [-O|o fmt] [-p pid] [-t tty] [-U user]",
@


1.13
log
@correct getopt
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.12 1999/06/21 20:47:59 art Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.12 1999/06/21 20:47:59 art Exp $";
d119 1
a119 1
	int prtheader, wflag, what, xflg;
d133 1
a133 1
	all = fmt = prtheader = wflag = xflg = 0;
d139 1
a139 1
	    "acCeghjLlM:mN:O:o:p:rSTt:U:uvW:wx")) != -1)
d163 3
d316 3
@


1.12
log
@stop casting the third argument to kvm_read to char *. it is a void *.
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.11 1999/04/28 20:55:14 alex Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.11 1999/04/28 20:55:14 alex Exp $";
d139 1
a139 1
	    "acCeghjLlM:mN:O:o:p:rSTt:U:uvW:wx")) != EOF)
@


1.11
log
@Implement -U <username> option from FreeBSD.  Original code by Peter Wemm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.10 1998/07/08 22:14:25 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.10 1998/07/08 22:14:25 deraadt Exp $";
d393 1
a393 1
	    (char *)&pstats, sizeof(pstats)) == sizeof(pstats)) {
@


1.10
log
@whack kmem gid after kvm_openfiles()
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.9 1997/08/04 05:37:05 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.9 1997/08/04 05:37:05 deraadt Exp $";
d59 1
d68 1
d114 1
d139 1
a139 1
	    "acCeghjLlM:mN:O:o:p:rSTt:uvW:wx")) != EOF)
d223 8
d292 2
a293 1
	if (!all && ttydev == NODEV && pid == -1)  /* XXX - should be cleaner */
d492 1
a492 1
	    "ps [-aChjlmrSTuvwx] [-O|o fmt] [-p pid] [-t tty]",
@


1.9
log
@toast non-NEWVM code; freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.8 1997/06/13 00:37:39 michaels Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.8 1997/06/13 00:37:39 michaels Exp $";
d274 3
@


1.8
log
@return 1 if the process does not exist.
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.6 1996/12/14 12:18:10 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.6 1996/12/14 12:18:10 mickey Exp $";
a74 4
#ifdef P_PPWAIT
#define NEWVM
#endif

a397 1
#ifdef NEWVM
a399 3
#else
#define VSIZE(k) ((k)->ki_p->p_dsize + (k)->ki_p->p_ssize + (k)->ki_e->e_xsize)
#endif
@


1.7
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d323 1
a323 1
		exit(0);
@


1.6
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.5 1996/08/06 19:33:47 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.5 1996/08/06 19:33:47 deraadt Exp $";
d270 2
a271 1
	if (nlistf != NULL || memf != NULL || swapf != NULL)
d273 1
@


1.5
log
@_POSIX2_LINE_MAX errbuf for kvm_openfiles()
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.4 1996/08/02 12:41:02 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.4 1996/08/02 12:41:02 deraadt Exp $";
d469 2
a470 2
	if (isdigit(*cp) && (cp == s || cp[-1] != 't' && cp[-1] != 'p' &&
	    (cp - 1 == s || cp[-2] != 't')))
@


1.4
log
@zap getopt() case of -?, come on, it is the default!
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.3 1996/06/23 14:20:51 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.3 1996/06/23 14:20:51 deraadt Exp $";
d71 1
d121 1
a121 1
	char *nlistf, *memf, *swapf, errbuf[256];
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: ps.c,v 1.15 1995/05/18 20:33:25 mycroft Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ps.c,v 1.15 1995/05/18 20:33:25 mycroft Exp $";
a247 1
		case '?':
@


1.2
log
@allocate large enough buffer; netbsd pr#2550; gsstark@@mit.edu
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: ps.c,v 1.15 1995/05/18 20:33:25 mycroft Exp $";
@


1.1
log
@Initial revision
@
text
@d435 1
a435 1
	if ((newopts = ns = malloc(len + 2)) == NULL)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
