head	1.69;
access;
symbols
	OPENBSD_6_1_BASE:1.69
	OPENBSD_6_0:1.67.0.2
	OPENBSD_6_0_BASE:1.67
	OPENBSD_5_9:1.66.0.2
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.62.0.4
	OPENBSD_5_8_BASE:1.62
	OPENBSD_5_7:1.59.0.2
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.57.0.4
	OPENBSD_5_6_BASE:1.57
	OPENBSD_5_5:1.56.0.4
	OPENBSD_5_5_BASE:1.56
	OPENBSD_5_4:1.54.0.2
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.53.0.4
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.53.0.2
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.2
	OPENBSD_5_0:1.48.0.2
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.46.0.6
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.46.0.4
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.44.0.8
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.4
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.44.0.2
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.43.0.2
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.42.0.4
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.38.0.4
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.37.0.2
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.32.0.4
	OPENBSD_3_6_BASE:1.32
	OPENBSD_3_5:1.32.0.2
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	OPENBSD_3_3:1.29.0.2
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9:1.16.0.4
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.14.0.8
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.6
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.4
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.69
date	2016.09.08.15.11.29;	author tedu;	state Exp;
branches;
next	1.68;
commitid	Ektj5UIXo8ssHb1H;

1.68
date	2016.09.01.09.44.06;	author tedu;	state Exp;
branches;
next	1.67;
commitid	re8NDRJqR9wO66Q7;

1.67
date	2016.04.25.19.12.07;	author tedu;	state Exp;
branches;
next	1.66;
commitid	OAdoVOvynceaXSP4;

1.66
date	2016.01.10.14.04.16;	author schwarze;	state Exp;
branches;
next	1.65;
commitid	LRaYILYXBFr3pchR;

1.65
date	2015.12.30.14.59.10;	author tedu;	state Exp;
branches;
next	1.64;
commitid	pcpM0SacneEDdJB8;

1.64
date	2015.10.25.15.26.53;	author czarkoff;	state Exp;
branches;
next	1.63;
commitid	yFF0Y6AH0BLwSq3l;

1.63
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	sbrB3Q5CNxcwZpfU;

1.62
date	2015.07.19.19.26.00;	author deraadt;	state Exp;
branches;
next	1.61;
commitid	UnRUUdE0GnZB6Rvp;

1.61
date	2015.06.29.15.03.33;	author bluhm;	state Exp;
branches;
next	1.60;
commitid	zqqB6c65L8hxs5Kq;

1.60
date	2015.03.15.00.41.27;	author millert;	state Exp;
branches;
next	1.59;
commitid	IbVxlqGw2UipKdDr;

1.59
date	2015.01.16.06.39.32;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	Uu5nFG3wCl0LACBb;

1.58
date	2014.08.16.16.38.38;	author tedu;	state Exp;
branches;
next	1.57;
commitid	FneoW0PEakItgTdK;

1.57
date	2014.07.04.05.58.31;	author guenther;	state Exp;
branches;
next	1.56;
commitid	vhXZZxMGVTWiFaF3;

1.56
date	2013.11.11.23.07.15;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2013.09.22.17.28.34;	author guenther;	state Exp;
branches;
next	1.54;

1.54
date	2013.03.23.21.12.31;	author tedu;	state Exp;
branches;
next	1.53;

1.53
date	2012.07.10.17.24.45;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2011.12.29.17.13.55;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2011.12.11.00.16.49;	author nicm;	state Exp;
branches;
next	1.50;

1.50
date	2011.10.13.01.15.04;	author guenther;	state Exp;
branches;
next	1.49;

1.49
date	2011.09.25.00.32.47;	author guenther;	state Exp;
branches;
next	1.48;

1.48
date	2011.04.10.03.20.58;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2011.03.12.04.54.28;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2010.02.14.00.17.14;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2008.03.08.19.20.12;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.06.10.22.29;	author chl;	state Exp;
branches;
next	1.42;

1.42
date	2006.11.29.12.34.19;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.02.05.25.19;	author hugh;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.10.11.31.41;	author moritz;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.10.06.32.00;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.06.21.41.24;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2005.01.14.16.44.14;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2004.12.20.15.10.46;	author aaron;	state Exp;
branches;
next	1.35;

1.35
date	2004.11.24.19.17.10;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2004.11.18.15.10.24;	author markus;	state Exp;
branches;
next	1.33;

1.33
date	2004.09.14.23.45.14;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.08.18.18.35;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.11.23.42.12;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.02.23.32.09;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.05.01.39.24;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.12.19.21.29.46;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.18.03.21.33;	author provos;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.19.23.54.41;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.10.21.07.00;	author naddy;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.30.17.52.40;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.05.02.23.59;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.01.19.01.45;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.07.08.23.08;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.07.08.19.43;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.13.22.41.16;	author heko;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.30.09.37.11;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.18.17.59.53;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.04.17.26.25;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.11.30.05.43.12;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.11.30.05.41.23;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.11.06.15.59.56;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	97.11.05.18.22.56;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.09.12.04.41.52;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.09.03.13.51.41;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.09.01.18.30.19;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.08.22.20.08.14;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.08.04.05.37.04;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.08.01.09.48.44;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.23.19.18.19;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.12.14.12.18.09;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.20.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.19;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.19;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.69
log
@etime isn't just an alias for start. the output format is different.
diff from Carlin Bingham. ok millert.
@
text
@/*	$OpenBSD: print.c,v 1.68 2016/09/01 09:44:06 tedu Exp $	*/
/*	$NetBSD: print.c,v 1.27 1995/09/29 21:58:12 cgd Exp $	*/

/*-
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXCOMLEN PZERO NODEV */
#include <sys/types.h>
#include <sys/proc.h>
#include <sys/stat.h>

#include <sys/sysctl.h>

#include <err.h>
#include <grp.h>
#include <kvm.h>
#include <math.h>
#include <nlist.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <pwd.h>

#include "ps.h"

extern kvm_t *kd;
extern int needenv, needcomm, neednlist, commandonly;

int mbswprint(const char *, int, int);  /* utf8.c */

static char *cmdpart(char *);

#define	min(a,b)	((a) < (b) ? (a) : (b))

static char *
cmdpart(char *arg0)
{
	char *cp;

	return ((cp = strrchr(arg0, '/')) != NULL ? cp + 1 : arg0);
}

void
printheader(void)
{
	VAR *v;
	struct varent *vent;

	if (!needheader)
		return;
	for (vent = vhead; vent; vent = vent->next) {
		v = vent->var;
		if (v->flag & LJUST) {
			if (vent->next == NULL)	/* last one */
				(void)printf("%s", v->header);
			else
				(void)printf("%-*s", v->width, v->header);
		} else
			(void)printf("%*s", v->width, v->header);
		if (vent->next != NULL)
			(void)putchar(' ');
	}
	(void)putchar('\n');
}

void
command(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;
	int left, wantspace = 0;
	char **argv, **p;

	/*
	 * Determine the available number of display columns.
	 * Always decrement and check after writing.
	 * No check is needed before mbswprint()
	 * and after writing the last data, though.
	 */

	v = ve->var;
	if (ve->next != NULL || termwidth != UNLIMITED) {
		if (ve->next == NULL) {
			left = termwidth - (totwidth - v->width);
			if (left < 1) /* already wrapped, just use std width */
				left = v->width;
		} else
			left = v->width;
	} else
		left = INT_MAX;

	if (needenv && kd != NULL) {
		argv = kvm_getenvv(kd, kp, termwidth);
		if ((p = argv) != NULL) {
			while (*p) {
				if (wantspace) {
					putchar(' ');
					left--;
				}
				left -= mbswprint(*p, left, 0);
				if (left == 0)
					return;
				p++;
				wantspace = 1;
			}
		}
	} else
		argv = NULL;

	if (needcomm) {
		if (!commandonly) {
			if (kd != NULL) {
				argv = kvm_getargv(kd, kp, termwidth);
				if ((p = argv) != NULL) {
					while (*p) {
						if (wantspace) {
							putchar(' ');
							left--;
						}
						left -= mbswprint(*p, left, 0);
						if (left == 0)
							return;
						p++;
						wantspace = 1;
					}
				}
			}
			if (argv == NULL || argv[0] == '\0' ||
			    strcmp(cmdpart(argv[0]), kp->p_comm)) {
				if (wantspace) {
					putchar(' ');
					if (--left == 0)
						return;
				}
				putchar('(');
				left--;
				left -= mbswprint(kp->p_comm, left, 0);
				if (left == 0)
					return;
				putchar(')');
				left--;
			}
		} else {
			if (wantspace) {
				putchar(' ');
				left--;
			}
			left -= mbswprint(kp->p_comm, left, 0);
		}
	}
	if (ve->next != NULL)
		while (left-- > 0)
			putchar(' ');
}

void
ucomm(const struct kinfo_proc *kp, VARENT *ve)
{
	mbswprint(kp->p_comm, ve->var->width, ve->next != NULL);
}

void
curwd(const struct kinfo_proc *kp, VARENT *ve)
{
	int name[] = { CTL_KERN, KERN_PROC_CWD, kp->p_pid };
	char path[PATH_MAX];
	size_t pathlen = sizeof path;

	if (!kvm_sysctl_only || sysctl(name, 3, path, &pathlen, NULL, 0) != 0)
		*path = '\0';

	mbswprint(path, ve->var->width, ve->next != NULL);
}

void
logname(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	if (kp->p_login[0]) {
		int n = min(v->width, LOGIN_NAME_MAX);
		mbswprint(kp->p_login, n, ve->next != NULL);
		if (ve->next != NULL)
			while (n++ < v->width)
				putchar(' ');
	} else
		(void)printf("%-*s", v->width, "-");
}

#define pgtok(a)	(((unsigned long long)(a)*getpagesize())/1024)

void
printstate(const struct kinfo_proc *kp, VARENT *ve)
{
	int flag;
	char *cp, state = '\0';
	VAR *v;
	char buf[16];

	v = ve->var;
	flag = kp->p_flag;
	cp = buf;

	switch (kp->p_stat) {

	case SSTOP:
		*cp = 'T';
		break;

	case SSLEEP:
		if (flag & P_SINTR)	/* interruptible (long) */
			*cp = kp->p_slptime >= maxslp ? 'I' : 'S';
		else
			*cp = 'D';
		break;

	case SRUN:
	case SIDL:
	case SONPROC:
		state = *cp = 'R';
		break;

	case SDEAD:
		*cp = 'Z';
		break;

	default:
		*cp = '?';
	}
	cp++;

	if (kp->p_nice < NZERO)
		*cp++ = '<';
	else if (kp->p_nice > NZERO)
		*cp++ = 'N';
	if (kp->p_psflags & PS_TRACED)
		*cp++ = 'X';
	if ((kp->p_psflags & (PS_EXITING | PS_ZOMBIE)) == PS_EXITING)
		*cp++ = 'E';
	if (kp->p_psflags & PS_ISPWAIT)
		*cp++ = 'V';
	if (flag & P_SYSTEM)
		*cp++ = 'K';
	if ((flag & P_SYSTEM) == 0 &&
	    kp->p_rlim_rss_cur / 1024 < pgtok(kp->p_vm_rssize))
		*cp++ = '>';
	if (kp->p_eflag & EPROC_SLEADER)
		*cp++ = 's';
	if ((kp->p_psflags & PS_CONTROLT) && kp->p__pgid == kp->p_tpgid)
		*cp++ = '+';
	if (kp->p_psflags & PS_PLEDGE)
		*cp++ = 'p';
	*cp = '\0';

	if (state == 'R' && kp->p_cpuid != KI_NOCPU) {
		char pbuf[16];

		snprintf(pbuf, sizeof pbuf, "/%llu", kp->p_cpuid);
		*++cp = '\0';
		strlcat(buf, pbuf, sizeof buf);
		cp = buf + strlen(buf);
	}

	(void)printf("%-*s", v->width, buf);
}

void
pri(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	(void)printf("%*d", v->width, kp->p_priority - PZERO);
}

void
pnice(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;
	v = ve->var;
	(void)printf("%*d", v->width, kp->p_nice - NZERO);
}

void
euname(const struct kinfo_proc *kp, VARENT *ve)
{
	mbswprint(user_from_uid(kp->p_uid, 0), ve->var->width,
	    ve->next != NULL);
}

void
runame(const struct kinfo_proc *kp, VARENT *ve)
{
	mbswprint(user_from_uid(kp->p_ruid, 0), ve->var->width,
	    ve->next != NULL);
}

void
gname(const struct kinfo_proc *kp, VARENT *ve)
{
	mbswprint(group_from_gid(kp->p_gid, 0), ve->var->width,
	    ve->next != NULL);
}

void
rgname(const struct kinfo_proc *kp, VARENT *ve)
{
	mbswprint(group_from_gid(kp->p_rgid, 0), ve->var->width,
	    ve->next != NULL);
}

void
tdev(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;
	dev_t dev;
	char buff[16];

	v = ve->var;
	dev = kp->p_tdev;
	if (dev == NODEV)
		(void)printf("%*s", v->width, "??");
	else {
		(void)snprintf(buff, sizeof(buff),
		    "%d/%d", major(dev), minor(dev));
		(void)printf("%*s", v->width, buff);
	}
}

void
tname(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;
	dev_t dev;
	char *ttname;

	v = ve->var;
	dev = kp->p_tdev;
	if (dev == NODEV || (ttname = devname(dev, S_IFCHR)) == NULL)
		(void)printf("%-*s", v->width, "??");
	else {
		if (strncmp(ttname, "tty", 3) == 0)
			ttname += 3;
		(void)printf("%*.*s%c", v->width-1, v->width-1, ttname,
			kp->p_eflag & EPROC_CTTY ? ' ' : '-');
	}
}

void
longtname(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;
	dev_t dev;
	char *ttname;

	v = ve->var;
	dev = kp->p_tdev;
	if (dev == NODEV || (ttname = devname(dev, S_IFCHR)) == NULL)
		(void)printf("%-*s", v->width, "??");
	else
		(void)printf("%-*s", v->width, ttname);
}

void
started(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;
	static time_t now;
	time_t startt;
	struct tm *tp;
	char buf[100];

	v = ve->var;
	if (!kp->p_uvalid) {
		(void)printf("%-*s", v->width, "-");
		return;
	}

#define SECSPERHOUR	(60 * 60)
#define SECSPERDAY	(24 * 60 * 60)

	startt = kp->p_ustart_sec;
	tp = localtime(&startt);
	if (!now)
		(void)time(&now);
	if (now - kp->p_ustart_sec < 12 * SECSPERHOUR) {
		(void)strftime(buf, sizeof(buf) - 1, "%l:%M%p", tp);
	} else if (now - kp->p_ustart_sec < 7 * SECSPERDAY) {
		(void)strftime(buf, sizeof(buf) - 1, "%a%I%p", tp);
	} else
		(void)strftime(buf, sizeof(buf) - 1, "%e%b%y", tp);
	(void)printf("%-*s", v->width, buf);
}

void
lstarted(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;
	time_t startt;
	char buf[100];

	v = ve->var;
	if (!kp->p_uvalid) {
		(void)printf("%-*s", v->width, "-");
		return;
	}
	startt = kp->p_ustart_sec;
	(void)strftime(buf, sizeof(buf) -1, "%c",
	    localtime(&startt));
	(void)printf("%-*s", v->width, buf);
}

void elapsed(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;
	static time_t now;
	time_t secs;
	char buf[64];
	long days, hours, minutes, seconds;

	v = ve->var;
	if (!kp->p_uvalid) {
		(void)printf("%*s", v->width, "-");
		return;
	}

	if (!now)
		(void)time(&now);
	secs = now - kp->p_ustart_sec;

	if (secs < 0) {
		(void)printf("%*s", v->width, "-");
		return;
	}

	days = secs / SECSPERDAY;
	secs %= SECSPERDAY;

	hours = secs / SECSPERHOUR;
	secs %= SECSPERHOUR;

	minutes = secs / 60;
	seconds = secs % 60;

	if (days > 0)
		(void)snprintf(buf, sizeof(buf), "%ld-%02ld:%02ld:%02ld",
		    days, hours, minutes, seconds);
	else if (hours > 0)
		(void)snprintf(buf, sizeof(buf), "%02ld:%02ld:%02ld",
		    hours, minutes, seconds);
	else
		(void)snprintf(buf, sizeof(buf), "%02ld:%02ld",
		    minutes, seconds);
	(void)printf("%*s", v->width, buf);
}

void
wchan(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	if (kp->p_wmesg[0]) {
		(void)printf("%-*s", (int)v->width, kp->p_wmesg);
	} else
		(void)printf("%-*s", v->width, "-");
}

void
vsize(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	(void)printf("%*llu", v->width,
	    pgtok(kp->p_vm_dsize + kp->p_vm_ssize + kp->p_vm_tsize));
}

void
rssize(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	/* XXX don't have info about shared */
	(void)printf("%*llu", v->width, (kp->p_flag & P_SYSTEM) ? 0 :
	    pgtok(kp->p_vm_rssize));
}

void
p_rssize(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	(void)printf("%*llu", v->width, (kp->p_flag & P_SYSTEM) ? 0 :
	    pgtok(kp->p_vm_rssize));
}

void
cputime(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;
	long secs;
	long psecs;	/* "parts" of a second. first micro, then centi */
	char obuff[128];

	v = ve->var;
	if (kp->p_stat == SDEAD || !kp->p_uvalid) {
		secs = 0;
		psecs = 0;
	} else {
		/*
		 * This counts time spent handling interrupts.  XXX
		 */
		secs = kp->p_rtime_sec;
		psecs = kp->p_rtime_usec;
		if (sumrusage) {
			secs += kp->p_uctime_sec;
			psecs += kp->p_uctime_usec;
		}
		/*
		 * round and scale to 100's
		 */
		psecs = (psecs + 5000) / 10000;
		secs += psecs / 100;
		psecs = psecs % 100;
	}
	(void)snprintf(obuff, sizeof(obuff),
	    "%3ld:%02ld.%02ld", secs/60, secs%60, psecs);
	(void)printf("%*s", v->width, obuff);
}

double
getpcpu(const struct kinfo_proc *kp)
{
	if (fscale == 0)
		return (0.0);

#define	fxtofl(fixpt)	((double)(fixpt) / fscale)

	return (100.0 * fxtofl(kp->p_pctcpu));
}

void
pcpu(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	(void)printf("%*.1f", v->width, getpcpu(kp));
}

double
getpmem(const struct kinfo_proc *kp)
{
	double fracmem;

	if (mempages == 0)
		return (0.0);

	if (kp->p_flag & P_SYSTEM)
		return (0.0);
	/* XXX don't have info about shared */
	fracmem = ((float)kp->p_vm_rssize)/mempages;
	return (100.0 * fracmem);
}

void
pmem(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	(void)printf("%*.1f", v->width, getpmem(kp));
}

void
pagein(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	(void)printf("%*llu", v->width,
	    kp->p_uvalid ? kp->p_uru_majflt : 0);
}

void
maxrss(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	(void)printf("%*llu", v->width, kp->p_rlim_rss_cur / 1024);
}

void
tsize(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	(void)printf("%*llu", v->width, pgtok(kp->p_vm_tsize));
}

void
dsize(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	(void)printf("%*llu", v->width, pgtok(kp->p_vm_dsize));
}

void
ssize(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	(void)printf("%*llu", v->width, pgtok(kp->p_vm_ssize));
}

/*
 * Generic output routines.  Print fields from various prototype
 * structures.
 */
static void
printval(char *bp, VAR *v)
{
	char ofmt[32];

	snprintf(ofmt, sizeof(ofmt), "%%%s*%s", (v->flag & LJUST) ? "-" : "",
	    v->fmt);

	/*
	 * Note that the "INF127" check is nonsensical for types
	 * that are or can be signed.
	 */
#define	GET(type)		(*(type *)bp)
#define	CHK_INF127(n)		(((n) > 127) && (v->flag & INF127) ? 127 : (n))

	switch (v->type) {
	case INT8:
		(void)printf(ofmt, v->width, GET(int8_t));
		break;
	case UINT8:
		(void)printf(ofmt, v->width, CHK_INF127(GET(u_int8_t)));
		break;
	case INT16:
		(void)printf(ofmt, v->width, GET(int16_t));
		break;
	case UINT16:
		(void)printf(ofmt, v->width, CHK_INF127(GET(u_int16_t)));
		break;
	case INT32:
		(void)printf(ofmt, v->width, GET(int32_t));
		break;
	case UINT32:
		(void)printf(ofmt, v->width, CHK_INF127(GET(u_int32_t)));
		break;
	case INT64:
		(void)printf(ofmt, v->width, GET(int64_t));
		break;
	case UINT64:
		(void)printf(ofmt, v->width, CHK_INF127(GET(u_int64_t)));
		break;
	default:
		errx(1, "unknown type %d", v->type);
	}
#undef GET
#undef CHK_INF127
}

void
pvar(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	if ((v->flag & USER) && !kp->p_uvalid)
		(void)printf("%*s", v->width, "-");
	else
		printval((char *)kp + v->off, v);
}

void
emulname(const struct kinfo_proc *kp, VARENT *ve)
{
	VAR *v;

	v = ve->var;

	(void)printf("%-*s", (int)v->width, kp->p_emul);
}
@


1.68
log
@simplify comment to remove reference to sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.67 2016/04/25 19:12:07 tedu Exp $	*/
d440 44
@


1.67
log
@remove references to systrace
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.66 2016/01/10 14:04:16 schwarze Exp $	*/
d499 1
a499 3
		 * This counts time spent handling interrupts.  We could
		 * fix this, but it is not 100% trivial (and interrupt
		 * time fractions only work on the sparc anyway).	XXX
@


1.66
log
@UTF-8 support:
In a UTF-8 locale, columnate correctly and replace valid, but non-
printable characters with the Unicode replacement character U+FFFD.
No change in the C/POSIX locale, and no change for invalid bytes.
Grand total, the code becomes shorter by almost 30 lines.
Feedback from czarkoff@@, OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.65 2015/12/30 14:59:10 tedu Exp $	*/
a266 2
	if (flag & P_SYSTRACE)
		*cp++ = 'x';
@


1.65
log
@rename a few variables/functions to avoid shadowing
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.64 2015/10/25 15:26:53 czarkoff Exp $	*/
d58 2
d102 7
d118 2
a119 1
		left = -1;
d124 7
a130 1
				fmt_puts(*p, &left);
d132 1
a132 4
				if (*p)
					fmt_putc(' ', &left);
				else
					wantspace = 1;
d137 1
a142 4
					if (wantspace) {
						fmt_putc(' ', &left);
						wantspace = 0;
					}
d144 7
a150 1
						fmt_puts(*p, &left);
d152 1
a152 4
						if (*p)
							fmt_putc(' ', &left);
						else
							wantspace = 1;
d159 3
a161 2
					fmt_putc(' ', &left);
					wantspace = 0;
d163 7
a169 3
				fmt_putc('(', &left);
				fmt_puts(kp->p_comm, &left);
				fmt_putc(')', &left);
d173 2
a174 2
				fmt_putc(' ', &left);
				wantspace = 0;
d176 1
a176 1
			fmt_puts(kp->p_comm, &left);
d179 3
a181 7
	if (ve->next && left > 0) {
		if (wantspace) {
			fmt_putc(' ', &left);
			wantspace = 0;
		}
		printf("%*s", left, "");
	}
d187 1
a187 4
	VAR *v;

	v = ve->var;
	(void)printf("%-*s", v->width, kp->p_comm);
a195 3
	int left;

	left = ve->var->width;
d200 1
a200 3
	fmt_puts(path, &left);
	if (ve->next != NULL && left)
		(void)printf("%-*s", left, "");
d211 4
a214 3
		(void)printf("%-*.*s", n, n, kp->p_login);
		if (v->width > n)
			(void)printf("%*s", v->width - n, "");
d318 2
a319 5
	VAR *v;

	v = ve->var;
	(void)printf("%-*s",
	    (int)v->width, user_from_uid(kp->p_uid, 0));
d325 2
a326 5
	VAR *v;

	v = ve->var;
	(void)printf("%-*s",
	    (int)v->width, user_from_uid(kp->p_ruid, 0));
d332 2
a333 5
	VAR *v;

	v = ve->var;
	(void)printf("%-*s",
	    (int)v->width, group_from_gid(kp->p_gid, 0));
d339 2
a340 5
	VAR *v;

	v = ve->var;
	(void)printf("%-*s",
	    (int)v->width, group_from_gid(kp->p_rgid, 0));
@


1.64
log
@strvis directory names in ps

OK stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.63 2015/10/09 01:37:06 deraadt Exp $	*/
d215 1
a215 1
state(const struct kinfo_proc *kp, VARENT *ve)
@


1.63
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.62 2015/07/19 19:26:00 deraadt Exp $	*/
a181 1
	VAR *v;
d185 3
d192 3
a194 2
	v = ve->var;
	(void)printf("%-*s", v->width, path);
@


1.62
log
@show tame flag
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.61 2015/06/29 15:03:33 bluhm Exp $	*/
d272 2
a273 2
	if (kp->p_psflags & PS_TAMED)
		*cp++ = 't';
@


1.61
log
@After removing the p_swtime from the kernel, ps always printed 0.0
as %cpu time.  Remove the calculation in ps that includes the process
lifetime.  Just print the p_pctcpu value, that was done before when
ps was called with -C.  Keep -C as a no-op for existing scripts.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.60 2015/03/15 00:41:27 millert Exp $	*/
d272 2
@


1.60
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.59 2015/01/16 06:39:32 deraadt Exp $	*/
a525 2
	double d;

d531 1
a531 15
	/* XXX - I don't like this */
	if (kp->p_swtime == 0)
		return (0.0);
	if (rawcpu)
		return (100.0 * fxtofl(kp->p_pctcpu));

	d = kp->p_swtime * log(fxtofl(ccpu));
	if (d < -700.0)
		d = 0.0;		/* avoid IEEE underflow */
	else
		d = exp(d);
	if (d == 1.0)
		return (0.0);
	return (100.0 * fxtofl(kp->p_pctcpu) /
		(1.0 - d));
@


1.59
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.58 2014/08/16 16:38:38 tedu Exp $	*/
a48 1
#include <tzfile.h>
d409 3
@


1.58
log
@reduce cutoff for "hours only" start times to reduce window of ambiguity.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.57 2014/07/04 05:58:31 guenther Exp $	*/
d33 2
a34 1
#include <sys/param.h>
d51 1
d185 1
a185 1
	char path[MAXPATHLEN];
d202 1
a202 1
		int n = min(v->width, MAXLOGNAME);
@


1.57
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.56 2013/11/11 23:07:15 deraadt Exp $	*/
d413 1
a413 1
	if (now - kp->p_ustart_sec < 24 * SECSPERHOUR) {
@


1.56
log
@remove totally excessive set of #include
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.55 2013/09/22 17:28:34 guenther Exp $	*/
d241 1
a241 1
	case SZOMB:
d258 1
a258 1
	if (flag & P_WEXIT && kp->p_stat != SZOMB)
d492 1
a492 1
	if (kp->p_stat == SZOMB || !kp->p_uvalid) {
@


1.55
log
@Stop merging the per-thread and per-process flags when reporting
them via sysctl(KERN_PROC).  In struct kinfo_proc the per-process
flags move to p_psflags, leaving the per-thread flags in p_flags.
Flag descriptions in ps(1) updated to be less obtuse.

discussed with matthew@@ some time ago; ok jca@@, manpage bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.54 2013/03/23 21:12:31 tedu Exp $	*/
a33 2
#include <sys/time.h>
#include <sys/resource.h>
a36 1
#include <sys/ucred.h>
a37 1
#include <uvm/uvm_extern.h>
@


1.54
log
@wchan is no longer exposed, just check if wmesg is not empty.
(wmesg hasn't itself been a pointer since conversion to kinfo_proc.)
noticed by sthen.
ok deraadt jsing millert sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.53 2012/07/10 17:24:45 deraadt Exp $	*/
d258 1
a258 1
	if (flag & P_TRACED)
d264 1
a264 1
	if (flag & PS_ISPWAIT)
d273 1
a273 1
	if ((flag & P_CONTROLT) && kp->p__pgid == kp->p_tpgid)
@


1.53
log
@Accounting for page tables, USPACE, and whatever else... as part
of the per-process %mem is not going to happen.  In particular,
we want USPACE to be removed from param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.52 2011/12/29 17:13:55 guenther Exp $	*/
d450 1
a450 1
	if (kp->p_wchan) {
@


1.52
log
@Suppress the header line if all the field headers have been set to empty.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.51 2011/12/11 00:16:49 nicm Exp $	*/
a562 1
	int szptudot;
a568 2
	/* XXX want pmap ptpages, segtab, etc. (per architecture) */
	szptudot = USPACE/getpagesize();
d570 1
a570 1
	fracmem = ((float)kp->p_vm_rssize + szptudot)/mempages;
@


1.51
log
@Make ps understand -o cwd using the new KERN_PROC_CWD sysctl. Some help
and suggestions from guenther.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.50 2011/10/13 01:15:04 guenther Exp $	*/
d79 2
@


1.50
log
@Remove support for systems that lack CPUs.  (i.e., stop looking up
HW_NCPU when the only test was whether it's non-zero)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.49 2011/09/25 00:32:47 guenther Exp $	*/
d178 15
@


1.49
log
@Restore correct display of the 'V' flag on the parent in vfork()
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.48 2011/04/10 03:20:58 guenther Exp $	*/
a199 1
	extern int ncpu;
d260 1
a260 1
	if (state == 'R' && ncpu && kp->p_cpuid != KI_NOCPU) {
@


1.48
log
@Switch back from KERN_PROC2/kinfo_proc2 to KERN_PROC/kinfo_proc now
that we've got name we want for the API we want

"ZAP!" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.47 2011/03/12 04:54:28 guenther Exp $	*/
d248 1
a248 1
	if (flag & P_PPWAIT)
@


1.47
log
@Replace the old, broken KERN_PROC ABI and its matching functions
in libkvm with the stable-ABI versions that are currently named
KERN_PROC2, kvm_get{proc,argv,envv}2().  The latter names and symbols
will continue to be supported for a few releases.

Committing now that they ports people have had a couple releases
to update pkgs that usd the old functions
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.46 2010/02/14 00:17:14 guenther Exp $	*/
d95 1
a95 1
command(const struct kinfo_proc2 *kp, VARENT *ve)
d112 1
a112 1
		argv = kvm_getenvv2(kd, kp, termwidth);
d128 1
a128 1
				argv = kvm_getargv2(kd, kp, termwidth);
d172 1
a172 1
ucomm(const struct kinfo_proc2 *kp, VARENT *ve)
d181 1
a181 1
logname(const struct kinfo_proc2 *kp, VARENT *ve)
d198 1
a198 1
state(const struct kinfo_proc2 *kp, VARENT *ve)
d274 1
a274 1
pri(const struct kinfo_proc2 *kp, VARENT *ve)
d283 1
a283 1
pnice(const struct kinfo_proc2 *kp, VARENT *ve)
d291 1
a291 1
euname(const struct kinfo_proc2 *kp, VARENT *ve)
d301 1
a301 1
runame(const struct kinfo_proc2 *kp, VARENT *ve)
d311 1
a311 1
gname(const struct kinfo_proc2 *kp, VARENT *ve)
d321 1
a321 1
rgname(const struct kinfo_proc2 *kp, VARENT *ve)
d331 1
a331 1
tdev(const struct kinfo_proc2 *kp, VARENT *ve)
d349 1
a349 1
tname(const struct kinfo_proc2 *kp, VARENT *ve)
d368 1
a368 1
longtname(const struct kinfo_proc2 *kp, VARENT *ve)
d383 1
a383 1
started(const struct kinfo_proc2 *kp, VARENT *ve)
d411 1
a411 1
lstarted(const struct kinfo_proc2 *kp, VARENT *ve)
d429 1
a429 1
wchan(const struct kinfo_proc2 *kp, VARENT *ve)
d441 1
a441 1
vsize(const struct kinfo_proc2 *kp, VARENT *ve)
d451 1
a451 1
rssize(const struct kinfo_proc2 *kp, VARENT *ve)
d462 1
a462 1
p_rssize(const struct kinfo_proc2 *kp, VARENT *ve)
d472 1
a472 1
cputime(const struct kinfo_proc2 *kp, VARENT *ve)
d508 1
a508 1
getpcpu(const struct kinfo_proc2 *kp)
d535 1
a535 1
pcpu(const struct kinfo_proc2 *kp, VARENT *ve)
d544 1
a544 1
getpmem(const struct kinfo_proc2 *kp)
d562 1
a562 1
pmem(const struct kinfo_proc2 *kp, VARENT *ve)
d571 1
a571 1
pagein(const struct kinfo_proc2 *kp, VARENT *ve)
d581 1
a581 1
maxrss(const struct kinfo_proc2 *kp, VARENT *ve)
d590 1
a590 1
tsize(const struct kinfo_proc2 *kp, VARENT *ve)
d599 1
a599 1
dsize(const struct kinfo_proc2 *kp, VARENT *ve)
d608 1
a608 1
ssize(const struct kinfo_proc2 *kp, VARENT *ve)
d668 1
a668 1
pvar(const struct kinfo_proc2 *kp, VARENT *ve)
d680 1
a680 1
emulname(const struct kinfo_proc2 *kp, VARENT *ve)
@


1.46
log
@Avoid overflow and wraparound in memory fields by using unsigned
long long arithmetic and formats.
Use PTRWIDTH for the column size for various address fields.

ok otto@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.45 2009/10/27 23:59:22 deraadt Exp $	*/
d435 1
a435 10
		int n;

		if (kp->p_wmesg) {
			n = min(v->width, WMESGLEN);
			(void)printf("%-*.*s", n, n, kp->p_wmesg);
			if (v->width > n)
				(void)printf("%*s", v->width - n, "");
		} else
			(void)printf("%-*lx", v->width,
			    (long)kp->p_wchan &~ KERNBASE);
@


1.45
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.44 2008/03/08 19:20:12 millert Exp $	*/
d195 1
a195 1
#define pgtok(a)	(((a)*getpagesize())/1024)
d455 1
a455 1
	(void)printf("%*d", v->width,
d466 1
a466 1
	(void)printf("%*d", v->width, (kp->p_flag & P_SYSTEM) ? 0 :
d476 1
a476 1
	(void)printf("%*d", v->width, (kp->p_flag & P_SYSTEM) ? 0 :
d595 1
a595 1
	(void)printf("%*lld", v->width, kp->p_rlim_rss_cur / 1024);
d604 1
a604 1
	(void)printf("%*d", v->width, pgtok(kp->p_vm_tsize));
d613 1
a613 1
	(void)printf("%*d", v->width, pgtok(kp->p_vm_dsize));
d622 1
a622 1
	(void)printf("%*d", v->width, pgtok(kp->p_vm_ssize));
@


1.44
log
@Instead of calling donlist() in the format print routines, call it
a single time before we print anything, if needed.  Uses a flag to
specify which formats need the kernel info donlist() provides.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.43 2007/11/06 10:22:29 chl Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)print.c	8.6 (Berkeley) 4/16/94";
#else
static char rcsid[] = "$OpenBSD: print.c,v 1.43 2007/11/06 10:22:29 chl Exp $";
#endif
#endif /* not lint */
@


1.43
log
@fix format string

ok ray@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.42 2006/11/29 12:34:19 miod Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: print.c,v 1.42 2006/11/29 12:34:19 miod Exp $";
d67 1
a67 1
extern int needenv, needcomm, commandonly;
a526 1
	static int failure;
d529 1
a529 3
	if (!nlistread)
		failure = donlist();
	if (failure)
a562 1
	static int failure;
d566 1
a566 3
	if (!nlistread)
		failure = donlist();
	if (failure)
@


1.42
log
@Do not test for processes being swapped out since this can't happen anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.41 2006/05/02 05:25:19 hugh Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: print.c,v 1.41 2006/05/02 05:25:19 hugh Exp $";
d272 1
a272 1
		snprintf(pbuf, sizeof pbuf, "/%d", kp->p_cpuid);
@


1.41
log
@Format nicelevel relative NZERO as other tools do.
Surely, says millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.40 2006/03/10 11:31:41 moritz Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: print.c,v 1.40 2006/03/10 11:31:41 moritz Exp $";
a245 3
	if (flag & P_INMEM) {
	} else
		*cp++ = 'W';
a259 3
	/* XXX Since P_SYSTEM now shows a K, should L just be for holdcnt? */
	if ((flag & P_SYSTEM) || kp->p_holdcnt)
		*cp++ = 'L';
d538 1
a538 1
	if (kp->p_swtime == 0 || (kp->p_flag & P_INMEM) == 0)
d575 1
a575 1
	if ((kp->p_flag & P_INMEM) == 0 || (kp->p_flag & P_SYSTEM))
@


1.40
log
@add missing break; found by lint
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.39 2006/03/10 06:32:00 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: print.c,v 1.39 2006/03/10 06:32:00 deraadt Exp $";
d294 8
@


1.39
log
@1.36 and onwards did not print extra spaces, but sometimes skipped spaces.
we need a proper flag to keep track of space insert requirements
thanks for further testing by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.35 2004/11/24 19:17:10 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: print.c,v 1.35 2004/11/24 19:17:10 deraadt Exp $";
d677 1
@


1.38
log
@Only print a space separating argv and the real command (in parens)
when argv is non-NULL and empty.  OK deraadt@@ and fgsch@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.37 2005/01/14 16:44:14 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: print.c,v 1.37 2005/01/14 16:44:14 deraadt Exp $";
d106 1
a106 1
	int left;
a122 2
				if (p != argv)
					fmt_putc(' ', &left);
d125 4
d138 4
a142 2
						if (p != argv)
							fmt_putc(' ', &left);
d145 4
d154 1
a154 1
				if (argv != NULL && argv[0] != '\0')
d156 2
d163 4
d170 5
a174 1
	if (ve->next && left > 0)
d176 1
@


1.37
log
@bring back the space before (cmd); ok millert aaron
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.36 2004/12/20 15:10:46 aaron Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: print.c,v 1.36 2004/12/20 15:10:46 aaron Exp $";
d146 2
a147 1
				fmt_putc(' ', &left);
@


1.36
log
@Don't print an unnecessary trailing space character at the end of command
argument display.  This makes it easier to grep ps output for 'foo$', instead
of having to use 'foo *$'.  millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.35 2004/11/24 19:17:10 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: print.c,v 1.35 2004/11/24 19:17:10 deraadt Exp $";
d146 1
@


1.35
log
@on MP machines, in STAT field, add /# where # is the cpu number so that
you can see processes move around; ok pval millert
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.34 2004/11/18 15:10:24 markus Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: print.c,v 1.34 2004/11/18 15:10:24 markus Exp $";
d123 2
a126 1
				fmt_putc(' ', &left);
d137 2
a140 1
						fmt_putc(' ', &left);
@


1.34
log
@handle SONPROC; ok aaron, deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.33 2004/09/14 23:45:14 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: print.c,v 1.33 2004/09/14 23:45:14 deraadt Exp $";
d185 1
d187 1
a187 1
	char *cp;
d211 1
a211 1
		*cp = 'R';
d222 1
d251 10
@


1.33
log
@rename internal uname() to euname() to avoid libc conflict
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.32 2004/01/08 18:18:35 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: print.c,v 1.32 2004/01/08 18:18:35 millert Exp $";
d209 1
@


1.32
log
@Convert to kinfo_proc2.  The sort order for -u and -m will be different
due to a bug fix in the sort routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.31 2003/06/11 23:42:12 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: print.c,v 1.31 2003/06/11 23:42:12 deraadt Exp $";
d261 1
a261 1
uname(const struct kinfo_proc2 *kp, VARENT *ve)
@


1.31
log
@ansification, art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.30 2003/06/02 23:32:09 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: print.c,v 1.30 2003/06/02 23:32:09 millert Exp $";
d103 1
a103 1
command(KINFO *ki, VARENT *ve)
d120 1
a120 1
		argv = kvm_getenvv(kd, ki->ki_p, termwidth);
d133 1
a133 1
				argv = kvm_getargv(kd, ki->ki_p, termwidth);
d143 1
a143 1
			    strcmp(cmdpart(argv[0]), KI_PROC(ki)->p_comm)) {
d145 1
a145 1
				fmt_puts(KI_PROC(ki)->p_comm, &left);
d149 1
a149 1
			fmt_puts(KI_PROC(ki)->p_comm, &left);
d157 1
a157 1
ucomm(KINFO *k, VARENT *ve)
d162 1
a162 1
	(void)printf("%-*s", v->width, KI_PROC(k)->p_comm);
d166 1
a166 1
logname(KINFO *k, VARENT *ve)
d171 1
a171 1
	if (KI_EPROC(k)->e_login[0]) {
d173 1
a173 1
		(void)printf("%-*.*s", n, n, KI_EPROC(k)->e_login);
d183 1
a183 1
state(KINFO *k, VARENT *ve)
a184 1
	struct proc *p;
d191 1
a191 2
	p = KI_PROC(k);
	flag = p->p_flag;
d194 1
a194 1
	switch (p->p_stat) {
d202 1
a202 1
			*cp = p->p_slptime >= maxslp ? 'I' : 'S';
d223 1
a223 1
	if (p->p_nice < NZERO)
d225 1
a225 1
	else if (p->p_nice > NZERO)
d231 1
a231 1
	if (flag & P_WEXIT && p->p_stat != SZOMB)
d238 1
a238 1
	if ((flag & P_SYSTEM) || p->p_holdcnt)
d241 1
a241 1
	    KI_EPROC(k)->e_maxrss / 1024 < pgtok(KI_EPROC(k)->e_vm.vm_rssize))
d243 1
a243 1
	if (KI_EPROC(k)->e_flag & EPROC_SLEADER)
d245 1
a245 1
	if ((flag & P_CONTROLT) && KI_EPROC(k)->e_pgid == KI_EPROC(k)->e_tpgid)
d252 1
a252 1
pri(KINFO *k, VARENT *ve)
d257 1
a257 1
	(void)printf("%*d", v->width, KI_PROC(k)->p_priority - PZERO);
d261 1
a261 1
uname(KINFO *k, VARENT *ve)
d267 1
a267 1
	    (int)v->width, user_from_uid(KI_EPROC(k)->e_ucred.cr_uid, 0));
d271 1
a271 1
runame(KINFO *k, VARENT *ve)
d277 1
a277 1
	    (int)v->width, user_from_uid(KI_EPROC(k)->e_pcred.p_ruid, 0));
d281 1
a281 1
gname(KINFO *k, VARENT *ve)
d287 1
a287 1
	    (int)v->width, group_from_gid(KI_EPROC(k)->e_ucred.cr_gid, 0));
d291 1
a291 1
rgname(KINFO *k, VARENT *ve)
d297 1
a297 1
	    (int)v->width, group_from_gid(KI_EPROC(k)->e_pcred.p_rgid, 0));
d301 1
a301 1
tdev(KINFO *k, VARENT *ve)
d308 1
a308 1
	dev = KI_EPROC(k)->e_tdev;
d319 1
a319 1
tname(KINFO *k, VARENT *ve)
d326 1
a326 1
	dev = KI_EPROC(k)->e_tdev;
d333 1
a333 1
			KI_EPROC(k)->e_flag & EPROC_CTTY ? ' ' : '-');
d338 1
a338 1
longtname(KINFO *k, VARENT *ve)
d345 1
a345 1
	dev = KI_EPROC(k)->e_tdev;
d353 1
a353 1
started(KINFO *k, VARENT *ve)
d362 1
a362 1
	if (!k->ki_u.u_valid) {
d367 1
a367 1
	startt = k->ki_u.u_start.tv_sec;
d371 1
a371 1
	if (now - k->ki_u.u_start.tv_sec < 24 * SECSPERHOUR) {
d373 1
a373 1
	} else if (now - k->ki_u.u_start.tv_sec < 7 * SECSPERDAY) {
d381 1
a381 1
lstarted(KINFO *k, VARENT *ve)
d388 1
a388 1
	if (!k->ki_u.u_valid) {
d392 1
a392 1
	startt = k->ki_u.u_start.tv_sec;
d399 1
a399 1
wchan(KINFO *k, VARENT *ve)
d404 1
a404 1
	if (KI_PROC(k)->p_wchan) {
d407 1
a407 1
		if (KI_PROC(k)->p_wmesg) {
d409 1
a409 1
			(void)printf("%-*.*s", n, n, KI_EPROC(k)->e_wmesg);
d414 1
a414 1
			    (long)KI_PROC(k)->p_wchan &~ KERNBASE);
d420 1
a420 1
vsize(KINFO *k, VARENT *ve)
d426 1
a426 2
	    pgtok(KI_EPROC(k)->e_vm.vm_dsize + KI_EPROC(k)->e_vm.vm_ssize +
		KI_EPROC(k)->e_vm.vm_tsize));
d430 1
a430 1
rssize(KINFO *k, VARENT *ve)
d436 2
a437 2
	(void)printf("%*d", v->width, (KI_PROC(k)->p_flag & P_SYSTEM) ? 0 :
	    pgtok(KI_EPROC(k)->e_vm.vm_rssize));
d441 1
a441 1
p_rssize(KINFO *k, VARENT *ve)
d446 2
a447 2
	(void)printf("%*d", v->width, (KI_PROC(k)->p_flag & P_SYSTEM) ? 0 :
	    pgtok(KI_EPROC(k)->e_vm.vm_rssize));
d451 1
a451 1
cputime(KINFO *k, VARENT *ve)
d459 1
a459 1
	if (KI_PROC(k)->p_stat == SZOMB || !k->ki_u.u_valid) {
d468 2
a469 2
		secs = KI_PROC(k)->p_rtime.tv_sec;
		psecs = KI_PROC(k)->p_rtime.tv_usec;
d471 2
a472 4
			secs += k->ki_u.u_cru.ru_utime.tv_sec +
				k->ki_u.u_cru.ru_stime.tv_sec;
			psecs += k->ki_u.u_cru.ru_utime.tv_usec +
				k->ki_u.u_cru.ru_stime.tv_usec;
d487 1
a487 1
getpcpu(KINFO *k)
a488 1
	struct proc *p;
a496 1
	p = KI_PROC(k);
d500 1
a500 1
	if (p->p_swtime == 0 || (p->p_flag & P_INMEM) == 0)
d503 1
a503 1
		return (100.0 * fxtofl(p->p_pctcpu));
d505 1
a505 1
	d = p->p_swtime * log(fxtofl(ccpu));
d512 1
a512 1
	return (100.0 * fxtofl(p->p_pctcpu) /
d517 1
a517 1
pcpu(KINFO *k, VARENT *ve)
d522 1
a522 1
	(void)printf("%*.1f", v->width, getpcpu(k));
d526 1
a526 1
getpmem(KINFO *k)
a528 2
	struct proc *p;
	struct eproc *e;
d537 1
a537 3
	p = KI_PROC(k);
	e = KI_EPROC(k);
	if ((p->p_flag & P_INMEM) == 0 || (p->p_flag & P_SYSTEM))
d542 1
a542 1
	fracmem = ((float)e->e_vm.vm_rssize + szptudot)/mempages;
d547 1
a547 1
pmem(KINFO *k, VARENT *ve)
d552 1
a552 1
	(void)printf("%*.1f", v->width, getpmem(k));
d556 1
a556 1
pagein(KINFO *k, VARENT *ve)
d561 2
a562 2
	(void)printf("%*ld", v->width,
	    k->ki_u.u_valid ? k->ki_u.u_ru.ru_majflt : 0);
d566 1
a566 1
maxrss(KINFO *k, VARENT *ve)
d571 1
a571 1
	(void)printf("%*lld", v->width, KI_EPROC(k)->e_maxrss / 1024);
d575 1
a575 1
tsize(KINFO *k, VARENT *ve)
d580 1
a580 1
	(void)printf("%*d", v->width, pgtok(KI_EPROC(k)->e_vm.vm_tsize));
d584 1
a584 1
dsize(KINFO *k, VARENT *ve)
d589 1
a589 1
	(void)printf("%*d", v->width, pgtok(KI_EPROC(k)->e_vm.vm_dsize));
d593 1
a593 1
ssize(KINFO *k, VARENT *ve)
d598 1
a598 1
	(void)printf("%*d", v->width, pgtok(KI_EPROC(k)->e_vm.vm_ssize));
d608 4
a611 10
	static char ofmt[32] = "%";
	char *fcp, *cp;
	enum type type;

	cp = ofmt + 1;
	fcp = v->fmt;
	if (v->flag & LJUST)
		*cp++ = '-';
	*cp++ = '*';
	while ((*cp++ = *fcp++));
d621 2
a622 7
	case INT32:
		if (sizeof(int32_t) == sizeof(int))
			type = INT;
		else if (sizeof(int32_t) == sizeof(long))
			type = LONG;
		else
			errx(1, "unknown conversion for type %d", v->type);
d624 2
a625 7
	case UINT32:
		if (sizeof(u_int32_t) == sizeof(u_int))
			type = UINT;
		else if (sizeof(u_int32_t) == sizeof(u_long))
			type = ULONG;
		else
			errx(1, "unknown conversion for type %d", v->type);
d627 2
a628 2
	default:
		type = v->type;
d630 2
a631 5
	}

	switch (type) {
	case CHAR:
		(void)printf(ofmt, v->width, GET(char));
d633 2
a634 2
	case UCHAR:
		(void)printf(ofmt, v->width, CHK_INF127(GET(u_char)));
d636 2
a637 2
	case SHORT:
		(void)printf(ofmt, v->width, GET(short));
d639 4
a642 17
	case USHORT:
		(void)printf(ofmt, v->width, CHK_INF127(GET(u_short)));
		break;
	case INT:
		(void)printf(ofmt, v->width, GET(int));
		break;
	case UINT:
		(void)printf(ofmt, v->width, CHK_INF127(GET(u_int)));
		break;
	case LONG:
		(void)printf(ofmt, v->width, GET(long));
		break;
	case ULONG:
		(void)printf(ofmt, v->width, CHK_INF127(GET(u_long)));
		break;
	case KPTR:
		(void)printf(ofmt, v->width, GET(u_long) &~ KERNBASE);
d652 1
a652 1
pvar(KINFO *k, VARENT *ve)
d657 1
a657 21
	printval((char *)((char *)KI_PROC(k) + v->off), v);
}

void
evar(KINFO *k, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	printval((char *)((char *)KI_EPROC(k) + v->off), v);
}

void
uvar(KINFO *k, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	if (k->ki_u.u_valid)
		printval((char *)((char *)&k->ki_u + v->off), v);
	else
a658 10
}

void
rvar(KINFO *k, VARENT *ve)
{
	VAR *v;

	v = ve->var;
	if (k->ki_u.u_valid)
		printval((char *)((char *)(&k->ki_u.u_ru) + v->off), v);
d660 1
a660 1
		(void)printf("%*s", v->width, "-");
d664 1
a664 1
emulname(KINFO *k, VARENT *ve)
d670 1
a670 2
	(void)printf("%-*s",
	    (int)v->width, KI_EPROC(k)->e_emul);
@


1.30
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.29 2003/01/05 01:39:24 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: print.c,v 1.29 2003/01/05 01:39:24 deraadt Exp $";
d74 1
a74 2
cmdpart(arg0)
	char *arg0;
d82 1
a82 1
printheader()
d103 1
a103 3
command(ki, ve)
	KINFO *ki;
	VARENT *ve;
d157 1
a157 3
ucomm(k, ve)
	KINFO *k;
	VARENT *ve;
d166 1
a166 3
logname(k, ve)
	KINFO *k;
	VARENT *ve;
d183 1
a183 3
state(k, ve)
	KINFO *k;
	VARENT *ve;
d254 1
a254 3
pri(k, ve)
	KINFO *k;
	VARENT *ve;
d263 1
a263 3
uname(k, ve)
	KINFO *k;
	VARENT *ve;
d273 1
a273 3
runame(k, ve)
	KINFO *k;
	VARENT *ve;
d283 1
a283 3
gname(k, ve)
	KINFO *k;
	VARENT *ve;
d293 1
a293 3
rgname(k, ve)
	KINFO *k;
	VARENT *ve;
d303 1
a303 3
tdev(k, ve)
	KINFO *k;
	VARENT *ve;
d321 1
a321 3
tname(k, ve)
	KINFO *k;
	VARENT *ve;
d340 1
a340 3
longtname(k, ve)
	KINFO *k;
	VARENT *ve;
d355 1
a355 3
started(k, ve)
	KINFO *k;
	VARENT *ve;
d383 1
a383 3
lstarted(k, ve)
	KINFO *k;
	VARENT *ve;
d401 1
a401 3
wchan(k, ve)
	KINFO *k;
	VARENT *ve;
d422 1
a422 3
vsize(k, ve)
	KINFO *k;
	VARENT *ve;
d433 1
a433 3
rssize(k, ve)
	KINFO *k;
	VARENT *ve;
d444 1
a444 3
p_rssize(k, ve)		/* doesn't account for text */
	KINFO *k;
	VARENT *ve;
d454 1
a454 3
cputime(k, ve)
	KINFO *k;
	VARENT *ve;
d492 1
a492 2
getpcpu(k)
	KINFO *k;
d524 1
a524 3
pcpu(k, ve)
	KINFO *k;
	VARENT *ve;
d533 1
a533 2
getpmem(k)
	KINFO *k;
d558 1
a558 3
pmem(k, ve)
	KINFO *k;
	VARENT *ve;
d567 1
a567 3
pagein(k, ve)
	KINFO *k;
	VARENT *ve;
d577 1
a577 3
maxrss(k, ve)
	KINFO *k;
	VARENT *ve;
d586 1
a586 3
tsize(k, ve)
	KINFO *k;
	VARENT *ve;
d595 1
a595 3
dsize(k, ve)
	KINFO *k;
	VARENT *ve;
d604 1
a604 3
ssize(k, ve)
	KINFO *k;
	VARENT *ve;
d617 1
a617 3
printval(bp, v)
	char *bp;
	VAR *v;
d695 1
a695 3
pvar(k, ve)
	KINFO *k;
	VARENT *ve;
d704 1
a704 3
evar(k, ve)
	KINFO *k;
	VARENT *ve;
d713 1
a713 3
uvar(k, ve)
	KINFO *k;
	VARENT *ve;
d725 1
a725 3
rvar(k, ve)
	KINFO *k;
	VARENT *ve;
d737 1
a737 3
emulname(k, ve)
	KINFO *k;
	VARENT *ve;
@


1.29
log
@work around a very rare div by 0 that should not happen, but can happen on
non-IEEE systems apparently.  like the vax.  this is in the same area of
code that has caused us problems with the 68060/68040 before; very curious,
and i don't know why.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.28 2002/12/19 21:29:46 mickey Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: print.c,v 1.28 2002/12/19 21:29:46 mickey Exp $";
@


1.28
log
@add dsiz and ssiz to accompany tsiz; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.27 2002/06/18 03:21:33 provos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.27 2002/06/18 03:21:33 provos Exp $";
d561 2
@


1.27
log
@add x flag for systraced processes; mentioned by christos@@netbsd
document missing flags from proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.26 2002/03/19 23:54:41 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.26 2002/03/19 23:54:41 millert Exp $";
d645 22
@


1.26
log
@Fix unitialized variable in non-setgid case; Gregory Steuck
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.25 2002/02/16 21:27:07 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.25 2002/02/16 21:27:07 millert Exp $";
d244 2
@


1.25
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.24 2002/02/10 21:07:00 naddy Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.24 2002/02/10 21:07:00 naddy Exp $";
d135 2
a136 1
	}
d149 1
a149 1
			if (argv == 0 || argv[0] == 0 ||
@


1.24
log
@remove pre-ansi, SCCS workaround cruft; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.23 2002/01/30 17:52:40 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.23 2002/01/30 17:52:40 mickey Exp $";
d73 1
a73 1
static char *cmdpart __P((char *));
@


1.23
log
@right, just check more for nulls; from Dan Harnett <danh@@wzrd.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.22 2001/12/05 02:23:59 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.22 2001/12/05 02:23:59 art Exp $";
d402 1
a402 3
		/* I *hate* SCCS... */
		static char fmt[] = __CONCAT("%l:%", "M%p");
		(void)strftime(buf, sizeof(buf) - 1, fmt, tp);
d404 1
a404 3
		/* I *hate* SCCS... */
		static char fmt[] = __CONCAT("%a%", "I%p");
		(void)strftime(buf, sizeof(buf) - 1, fmt, tp);
@


1.22
log
@Get MAXSLP from kvm/sysctl. It's patchable in the kernel now.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.21 2001/12/01 19:01:45 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.21 2001/12/01 19:01:45 deraadt Exp $";
d126 1
a126 1
	if (needenv) {
d138 8
a145 6
			argv = kvm_getargv(kd, ki->ki_p, termwidth);
			if ((p = argv) != NULL) {
				while (*p) {
					fmt_puts(*p, &left);
					p++;
					fmt_putc(' ', &left);
@


1.21
log
@wrong printf spec for a field
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.20 2001/11/07 08:23:08 miod Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.20 2001/11/07 08:23:08 miod Exp $";
d214 1
a214 1
			*cp = p->p_slptime >= MAXSLP ? 'I' : 'S';
@


1.20
log
@Doh, bring the correct header, this is userland...
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.19 2001/11/07 08:19:43 miod Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.19 2001/11/07 08:19:43 miod Exp $";
d632 1
a632 1
		(void)printf("%*d", v->width, KI_EPROC(k)->e_maxrss / 1024);
@


1.19
log
@Use uvm headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.18 2001/08/13 22:41:16 heko Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.18 2001/08/13 22:41:16 heko Exp $";
d53 1
a53 1
#include <uvm/uvm.h>
@


1.18
log
@Typo in comments: 'interuptable' => 'interruptible'
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.16 2000/06/18 17:59:53 niklas Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.16 2000/06/18 17:59:53 niklas Exp $";
d53 1
a53 1
#include <vm/vm.h>
@


1.17
log
@CLSIZE is 1 on all archs and will go away soon.
@
text
@d213 1
a213 1
		if (flag & P_SINTR)	/* interuptable (long) */
@


1.16
log
@Mark kernel threads as system processes.  Make ps hide them by default,
show them with -k.  Do not try to show RSS based values for them as they
mess up column alignment.  vmstat -f now shows kernel threads separately
from rforks too.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.15 2000/05/04 17:26:25 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.15 2000/05/04 17:26:25 deraadt Exp $";
d597 1
a597 1
	fracmem = ((float)e->e_vm.vm_rssize + szptudot)/CLSIZE/mempages;
@


1.15
log
@avoid IEEE underflow in exp(), shows up most on 68060 FPE which is precise; any math wizards want to help me clean this up?
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.14 1997/11/30 05:43:12 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.14 1997/11/30 05:43:12 deraadt Exp $";
d245 3
d250 2
a251 1
	if (KI_EPROC(k)->e_maxrss / 1024 < pgtok(KI_EPROC(k)->e_vm.vm_rssize))
d477 2
a478 1
	(void)printf("%*d", v->width, pgtok(KI_EPROC(k)->e_vm.vm_rssize));
d489 2
a490 1
	(void)printf("%*d", v->width, pgtok(KI_EPROC(k)->e_vm.vm_rssize));
d592 1
a592 1
	if ((p->p_flag & P_INMEM) == 0)
@


1.14
log
@oh yeah, we are min() clean
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.13 1997/11/30 05:41:23 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.13 1997/11/30 05:41:23 deraadt Exp $";
d533 1
d548 6
d555 1
a555 1
		(1.0 - exp(p->p_swtime * log(fxtofl(ccpu)))));
@


1.13
log
@deal with unterminated e_login and e_wmesg
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.12 1997/11/06 15:59:56 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.12 1997/11/06 15:59:56 kstailey Exp $";
d74 2
@


1.12
log
@fix ps(1) LIM column
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.11 1997/11/05 18:22:56 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.11 1997/11/05 18:22:56 deraadt Exp $";
d177 6
a182 3
	if (KI_EPROC(k)->e_login[0])
		(void)printf("%-*s", v->width, KI_EPROC(k)->e_login);
	else
d435 8
a442 4
		if (KI_PROC(k)->p_wmesg)
			(void)printf("%-*.*s", v->width, v->width,
				      KI_EPROC(k)->e_wmesg);
		else
@


1.11
log
@print "-" instead of "" for login name; dada@@sbox.tu-graz.ac.at
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.10 1997/09/12 04:41:52 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.10 1997/09/12 04:41:52 millert Exp $";
d183 2
d242 2
a441 2
#define pgtok(a)	(((a)*getpagesize())/1024)

d610 1
a610 1
		(void)printf("%*s", v->width, "-");
@


1.10
log
@#include <grp.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.9 1997/09/03 13:51:41 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.9 1997/09/03 13:51:41 kstailey Exp $";
d177 4
a180 1
	(void)printf("%-*s", v->width, KI_EPROC(k)->e_login);
@


1.9
log
@add ps "emul" option
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.8 1997/09/01 18:30:19 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.8 1997/09/01 18:30:19 deraadt Exp $";
d56 1
@


1.8
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.7 1997/08/22 20:08:14 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.7 1997/08/22 20:08:14 kstailey Exp $";
d750 13
@


1.7
log
@XPG4 compatibility for format options:
two new options: group and rgroup.
three new aliases: etime for start, comm for ucomm, and args for command.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.6 1997/08/04 05:37:04 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.6 1997/08/04 05:37:04 deraadt Exp $";
d425 1
a425 1
			(void)printf("%-*.*s", v->width, v->width, 
d592 1
a592 1
	(void)printf("%*ld", v->width, 
@


1.6
log
@toast non-NEWVM code; freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.5 1997/08/01 09:48:44 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.5 1997/08/01 09:48:44 deraadt Exp $";
d277 24
@


1.5
log
@for lstart, use %c not %C; tetsuya@@secom-sis.co.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.4 1997/07/23 19:18:19 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.4 1997/07/23 19:18:19 kstailey Exp $";
a50 5
#ifdef P_PPWAIT
#define NEWVM
#endif

#ifdef NEWVM
a53 5
#else
#include <machine/pte.h>
#include <sys/vmparam.h>
#include <sys/vm.h>
#endif
a175 3
#ifndef NEWVM
	(void)printf("%-*s", v->width, KI_PROC(k)->p_logname);
#else
a176 1
#endif
a221 4
#ifndef NEWVM
		if (p->p_rssize > p->p_maxrss)
			*cp++ = '>';
#endif
a227 6
#ifndef NEWVM
	if (flag & SUANOM)
		*cp++ = 'A';
	else if (flag & SSEQL)
		*cp++ = 'S';
#endif
a231 1
#ifdef NEWVM
a232 3
#else
	if (flag & SVFORK)
#endif
a233 1
#ifdef NEWVM
a234 3
#else
	if (flag & (SSYS|SLOCK|SULOCK|SKEEP|SPHYSIO))
#endif
a262 4
#ifndef NEWVM
	(void)printf("%-*s",
	    (int)v->width, user_from_uid(KI_PROC(k)->p_uid, 0));
#else
a264 1
#endif
a274 4
#ifndef NEWVM
	(void)printf("%-*s",
	    (int)v->width, user_from_uid(KI_PROC(k)->p_ruid, 0));
#else
a276 1
#endif
a420 4
#ifndef NEWVM
	    pgtok(KI_PROC(k)->p_dsize +
		KI_PROC(k)->p_ssize + KI_EPROC(k)->e_xsize));
#else
a422 1
#endif
a432 5
#ifndef NEWVM
	(void)printf("%*d", v->width,
	    pgtok(KI_PROC(k)->p_rssize + (KI_EPROC(k)->e_xccount ?
	    (KI_EPROC(k)->e_xrssize / KI_EPROC(k)->e_xccount) : 0)));
#else
a434 1
#endif
a444 3
#ifndef NEWVM
	(void)printf("%*d", v->width, pgtok(KI_PROC(k)->p_rssize));
#else
a445 1
#endif
a541 7
#ifndef NEWVM
	szptudot = USPACE/getpagesize() +
	    clrnd(ctopt(p->p_dsize + p->p_ssize + e->e_xsize));
	fracmem = ((float)p->p_rssize + szptudot)/CLSIZE/mempages;
	if (p->p_textp && e->e_xccount)
		fracmem += ((float)e->e_xrssize)/CLSIZE/e->e_xccount/mempages;
#else
a545 1
#endif
a579 5
#ifndef NEWVM	/* not yet */
	if (KI_PROC(k)->p_maxrss != (RLIM_INFINITY/getpagesize()))
		(void)printf("%*d", v->width, pgtok(KI_PROC(k)->p_maxrss));
	else
#endif
a590 3
#ifndef NEWVM
	(void)printf("%*d", v->width, pgtok(KI_EPROC(k)->e_xsize));
#else
a591 1
#endif
a592 13

#ifndef NEWVM
void
trss(k, ve)
	KINFO *k;
	VARENT *ve;
{
	VAR *v;

	v = ve->var;
	(void)printf("%*d", v->width, pgtok(KI_EPROC(k)->e_xrssize));
}
#endif
@


1.4
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.3 1996/12/14 12:18:09 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.3 1996/12/14 12:18:09 mickey Exp $";
d428 1
a428 1
	(void)strftime(buf, sizeof(buf) -1, "%C",
@


1.3
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.2 1996/06/23 14:20:50 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.2 1996/06/23 14:20:50 deraadt Exp $";
d452 1
a452 1
#define pgtok(a)        (((a)*getpagesize())/1024)
d465 1
a465 1
	        KI_PROC(k)->p_ssize + KI_EPROC(k)->e_xsize));
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.27 1995/09/29 21:58:12 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: print.c,v 1.27 1995/09/29 21:58:12 cgd Exp $";
d75 1
d135 1
a135 1
		if (p = argv) {
d146 1
a146 1
			if (p = argv) {
d633 1
a633 1
	(void)printf("%*d", v->width, 
d699 1
a699 1
	while (*cp++ = *fcp++);
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: print.c,v 1.27 1995/09/29 21:58:12 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
