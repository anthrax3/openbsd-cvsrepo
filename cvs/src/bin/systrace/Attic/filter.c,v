head	1.38;
access;
symbols
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.10
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.8
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.4
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.33.0.26
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.24
	OPENBSD_5_0:1.33.0.22
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.20
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.18
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.14
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.16
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.12
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.10
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.8
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.6
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.33.0.4
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.30.0.10
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.8
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.6
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.4
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17;
locks; strict;
comment	@ * @;


1.38
date	2016.04.25.19.09.24;	author tedu;	state dead;
branches;
next	1.37;
commitid	Ne4KgWE1uInoydsl;

1.37
date	2015.12.09.19.36.17;	author mmcc;	state Exp;
branches;
next	1.36;
commitid	8oyfVibTyuKjsb15;

1.36
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	6b2lLILbgCR1fvia;

1.35
date	2015.01.16.00.19.12;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	9JSDzKTCgxU6o5el;

1.34
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2006.07.02.12.34.15;	author sturm;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.02.19.49.05;	author sturm;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.26.20.19.25;	author sturm;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.23.20.51.18;	author sturm;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.04.18.15.11;	author sturm;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.19.11.48.57;	author sturm;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.16.06.36.40;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.29.00.39.12;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.24.09.49.06;	author mpech;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.09.07.24.56;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.09.07.22.52;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.15.22.33.27;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.16.15.01.08;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.16.14.41.52;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.09.03.52.10;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.08.03.06.45;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.23.04.41.02;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.08.21.18.20;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.19.14.38.57;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.09.15.22.27;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.19.16.31.07;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.18.01.54.31;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.11.05.30.28;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.07.18.05.20;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.06.01.05.57;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.05.18.14.00;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.05.16.51.08;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.05.16.09.20;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.05.15.59.52;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.04.19.15.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.04.19.07.04;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.04.17.20.04;	author provos;	state Exp;
branches;
next	;


desc
@@


1.38
log
@boom goes the dynamite
@
text
@/*	$OpenBSD: filter.c,v 1.37 2015/12/09 19:36:17 mmcc Exp $	*/
/*
 * Copyright 2002 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/tree.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <regex.h>
#include <errno.h>
#include <fnmatch.h>
#include <err.h>

#include "intercept.h"
#include "systrace.h"
#include "filter.h"
#include "util.h"

extern int allow;
extern int noalias;
extern int connected;
extern int cradle;
extern char cwd[];
extern char home[];
extern char username[];
extern char *guipath;

int requestor_restart = 0;

static void logic_free(struct logic *);
static int filter_match(struct intercept_pid *, struct intercept_tlq *,
    struct logic *);
static void filter_review(struct filterq *);
static void filter_templates(const char *);
static int filter_template(int, struct policy *, int);
static int filter_quickpredicate(struct filter *);
static void filter_policyrecord(struct policy *, struct filter *, const char *,
    const char *, char *);
static void filter_replace(char *, size_t, char *, char *);

static int
filter_match(struct intercept_pid *icpid, struct intercept_tlq *tls,
    struct logic *logic)
{
	struct intercept_translate *tl;
	int off = 0, res;

	switch (logic->op) {
	case LOGIC_NOT:
		return (!filter_match(icpid, tls, logic->left));
	case LOGIC_OR:
		if (filter_match(icpid, tls, logic->left))
			return (1);
		return (filter_match(icpid, tls, logic->right));
	case LOGIC_AND:
		if (!filter_match(icpid, tls, logic->left))
			return (0);
		return (filter_match(icpid, tls, logic->right));
	default:
		break;
	}

	/* Now we just have a logic single */
	if (logic->type == NULL)
		goto match;

	if (tls == NULL)
		errx(1, "filter_match has no translators");

	TAILQ_FOREACH(tl, tls, next) {
		if (!tl->trans_valid)
			continue;

		if (strcasecmp(tl->name, logic->type))
			continue;

		if (logic->typeoff == -1 || logic->typeoff == off)
			break;

		off++;
	}

	if (tl == NULL)
		return (0);

 match:
	/* We need to do dynamic expansion on the data */
	if (logic->filterdata && (logic->flags & LOGIC_NEEDEXPAND)) {
		char *old = logic->filterdata;
		size_t oldlen = logic->filterlen;

		logic->filterdata = filter_dynamicexpand(icpid, old);
		logic->filterlen = strlen(logic->filterdata) + 1;

		res = logic->filter_match(tl, logic);

		logic->filterdata = old;
		logic->filterlen = oldlen;
	} else
		res = logic->filter_match(tl, logic);

	return (res);
}

/* Evaluate filter predicate */

int
filter_predicate(struct intercept_pid *icpid, struct predicate *pdc)
{
	id_t pidnr, pdcnr;
	int res = 0;

	if (!pdc->p_flags)
		return (1);

	if (pdc->p_flags & PREDIC_UID) {
		pidnr = icpid->uid;
		pdcnr = pdc->p_uid;
	} else {
		pidnr = icpid->gid;
		pdcnr = pdc->p_gid;
	}

	switch (pdc->p_flags & PREDIC_MASK) {
	case PREDIC_NEGATIVE:
		res = pidnr != pdcnr;
		break;
	case PREDIC_LESSER:
		res = pidnr < pdcnr;
		break;
	case PREDIC_GREATER:
		res = pidnr > pdcnr;
		break;
	default:
		res = pidnr == pdcnr;
		break;
	}

	return (res);
}

short
filter_evaluate(struct intercept_tlq *tls, struct filterq *fls,
    struct intercept_pid *icpid)
{
	struct filter *filter, *last = NULL;
	short action;

	TAILQ_FOREACH(filter, fls, next) {
		action = filter->match_action;

		if (filter_predicate(icpid, &filter->match_predicate) &&
		    filter_match(icpid, tls, filter->logicroot)) {
			/* Profile feedback optimization */
			filter->match_count++;
			if (last != NULL && last->match_action == action &&
			    last->match_flags == filter->match_flags &&
			    filter->match_count > last->match_count) {
				TAILQ_REMOVE(fls, last, next);
				TAILQ_INSERT_AFTER(fls, filter, last, next);
			}

			if (action == ICPOLICY_NEVER)
				action = filter->match_error;
			icpid->uflags = filter->match_flags;

			/* Policy requests privilege elevation */
			if (filter->elevate.e_flags)
				icpid->elevate = &filter->elevate;
			return (action);
		}

		/* Keep track of last processed filtered in a group */
		last = filter;
	}

	return (ICPOLICY_ASK);
}

static void
logic_free(struct logic *logic)
{
	if (logic->left)
		logic_free(logic->left);
	if (logic->right)
		logic_free(logic->right);
	free(logic->type);
	free(logic->filterdata);
	free(logic);
}

void
filter_free(struct filter *filter)
{
	if (filter->logicroot)
		logic_free(filter->logicroot);
	free(filter->rule);
	free(filter);
}

static void
filter_review(struct filterq *fls)
{
	struct filter *filter;
	int i = 0;

	printf("Filter review:\n");

	TAILQ_FOREACH(filter, fls, next) {
		i++;
		printf("%d. %s\n", i, filter->rule);
	}
}

static void
filter_templates(const char *emulation)
{
	extern struct tmplqueue templates;
	struct template *template;
	int i = 0;

	printf("Available Templates:\n");

	TAILQ_FOREACH(template, &templates, next) {
		if (strcmp(template->emulation, emulation))
			continue;

		i++;
		printf("%d. %s - %s\n", i,
		    template->name, template->description);
	}
}

/* Inserts a policy from a template */

static int
filter_template(int fd, struct policy *policy, int count)
{
	extern struct tmplqueue templates;
	struct template *template;
	int i = 0;

	TAILQ_FOREACH(template, &templates, next) {
		if (strcmp(template->emulation, policy->emulation))
			continue;

		i++;
		if (i == count)
			break;
	}

	if (i != count)
		return (-1);

	template = systrace_readtemplate(template->filename, policy, template);
	if (template == NULL)
		return (-1);

	if (filter_prepolicy(fd, policy) == -1)
		return (-1);

	/* We inserted new statements into the policy */
	policy->flags |= POLICY_CHANGED;

	return (0);
}

static void
filter_policyrecord(struct policy *policy, struct filter *filter,
    const char *emulation, const char *name, char *rule)
{
	/* Record the filter in the policy */
	filter = calloc(1, sizeof(struct filter));
	if (filter == NULL)
		err(1, "%s:%d: calloc", __func__, __LINE__);
	if ((filter->rule = strdup(rule)) == NULL)
		err(1, "%s:%d: strdup", __func__, __LINE__);

	strlcpy(filter->name, name, sizeof(filter->name));
	strlcpy(filter->emulation, emulation, sizeof(filter->emulation));

	TAILQ_INSERT_TAIL(&policy->filters, filter, policy_next);
	policy->nfilters++;

	policy->flags |= POLICY_CHANGED;
}

int
filter_parse(char *line, struct filter **pfilter)
{
	char *rule;

	if (parse_filter(line, pfilter) == -1)
		return (-1);

	if ((rule = strdup(line)) == NULL)
		err(1, "%s:%d: strdup", __func__, __LINE__);

	(*pfilter)->rule = rule;

	return (0);
}

/* Translate a simple action like "permit" or "deny[einval]" to numbers */

int
filter_parse_simple(char *rule, short *paction, short *pfuture)
{
	char buf[_POSIX2_LINE_MAX];
	int isfuture = 1;
	char *line, *p;

	if (strlcpy(buf, rule, sizeof(buf)) >= sizeof(buf))
		return (-1);

	line = buf;

	if (!strcmp("permit", line)) {
		*paction = *pfuture = ICPOLICY_PERMIT;
		return (0);
	} else if (!strcmp("permit-now", line)) {
		*paction = ICPOLICY_PERMIT;
		return (0);
	} else if (strncmp("deny", line, 4))
		return (-1);

	line +=4 ;
	if (!strncmp("-now", line, 4)) {
		line += 4;
		isfuture = 0;
	}

	*paction = ICPOLICY_NEVER;

	switch (line[0]) {
	case '\0':
		break;
	case '[':
		line++;
		p = strsep(&line, "]");
		if (line == NULL || *line != '\0')
			return (-1);

		*paction = systrace_error_translate(p);
		if (*paction == -1)
			return (-1);
		break;
	default:
		return (-1);
	}

	if (isfuture)
		*pfuture = *paction;

	return (0);
}

void
filter_modifypolicy(int fd, int policynr, const char *emulation,
    const char *name, short future)
{
	struct systrace_revalias *reverse = NULL;

	/*
	 * Check if we are dealing with a system call that really
	 * is an alias for something else.
	 */
	if (!noalias)
		reverse = systrace_find_reverse(emulation, name);
	if (reverse == NULL) {
		if (systrace_modifypolicy(fd, policynr, name, future) == -1)
			errx(1, "%s:%d: modify policy for %s-%s",
			    __func__, __LINE__, emulation, name);
	} else {
		struct systrace_alias *alias; 

		/* For every system call associated with this alias
		 * set the permanent in-kernel policy.
		 */
		TAILQ_FOREACH(alias, &reverse->revl, next) {
			if(systrace_modifypolicy(fd, policynr,
			       alias->name, future) == -1)
				errx(1, "%s:%d: modify policy for %s-%s",
				    __func__, __LINE__,
				    emulation, alias->name);
		}
	}
}

/* In non-root case, evaluate predicates early */ 

static int
filter_quickpredicate(struct filter *filter)
{
	struct predicate *pdc;
	struct intercept_pid icpid;

	pdc = &filter->match_predicate;
	if (!pdc->p_flags)
		return (1);

	intercept_setpid(&icpid, getuid(), getgid());

	if (!filter_predicate(&icpid, pdc))
		return (0);

	memset(pdc, 0, sizeof(filter->match_predicate));

	return (1);
}

/*
 * Processes the filters for a policy that have not been applied yet.
 * Pre-filters get installed when reading a policy.  This function
 * installs a fast-path in the kernel.
 */

int
filter_prepolicy(int fd, struct policy *policy)
{
	int res;
	struct filter *filter, *parsed;
	struct filterq *fls;
	short action, future;
	extern int iamroot;

	/* Commit all matching pre-filters */
	for (filter = TAILQ_FIRST(&policy->prefilters);
	    filter; filter = TAILQ_FIRST(&policy->prefilters)) {
		future = ICPOLICY_ASK;

		TAILQ_REMOVE(&policy->prefilters, filter, policy_next);

		res = 0;
		parsed = NULL;
		/* Special rules that are not real filters */
		if (filter_parse_simple(filter->rule, &action, &future) == -1)
			res = filter_parse(filter->rule, &parsed);
		if (res == -1)
			errx(1, "%s:%d: can not parse \"%s\"",
			    __func__, __LINE__, filter->rule);

		if (future == ICPOLICY_ASK) {
			if (iamroot || filter_quickpredicate(parsed)) {
				fls = systrace_policyflq(policy,
				    policy->emulation, filter->name);
				TAILQ_INSERT_TAIL(fls, parsed, next);
			}
		} else {
			filter_modifypolicy(fd, policy->policynr,
			    policy->emulation, filter->name, future);
		}
		filter_policyrecord(policy, parsed, policy->emulation,
		    filter->name, filter->rule);

		filter_free(filter);
	}

	/* Existing policy applied undo changed flag */
	policy->flags &= ~POLICY_CHANGED;

	return (0);
}

short
filter_ask(int fd, struct intercept_tlq *tls, struct filterq *fls,
    int policynr, const char *emulation, const char *name,
    char *output, short *pfuture, struct intercept_pid *icpid)
{
	char line[2*PATH_MAX], *p;
	char compose[2*PATH_MAX];
	struct filter *filter;
	struct policy *policy;
	short action;
	int first = 1, isalias, isprompt = 0;

	*pfuture = ICPOLICY_ASK;

	isalias = systrace_find_reverse(emulation, name) != NULL;

	if ((policy = systrace_findpolnr(policynr)) == NULL)
		errx(1, "%s:%d: no policy %d", __func__, __LINE__, policynr);

	if (!allow)
		printf("%s\n", output);
	else {
		/* Automatically allow */
		if (tls != NULL) {
			struct intercept_translate *tl;
			char *l, *lst = NULL;
			int set = 0;

			/* Explicitly match every component */
			line[0] = '\0';
			TAILQ_FOREACH(tl, tls, next) {
				if (!tl->trans_valid)
					continue;
				l = intercept_translate_print(tl);
				if (l == NULL)
					continue;

				snprintf(compose, sizeof(compose),
				    "%s%s eq \"%s\"",
				    tl->name,
				    lst && !strcmp(tl->name, lst) ? "[1]" : "",
				    strescape(l));

				lst = tl->name;

				if (set)
					strlcat(line, " and ",
					    sizeof(line));
				else
					set = 1;
				strlcat(line, compose, sizeof(line));
			}
			if (!set)
				strlcpy(line, "true", sizeof(line));
			strlcat(line, " then permit", sizeof(line));
		} else
			strlcpy(line, "permit", sizeof(line));
	}

	while (1) {
		/* Special policy active that allows only yes or no */
		if (icpid->uflags & PROCESS_PROMPT)
			isprompt = 1;
		filter = NULL;

		if (!allow) {
			/* Ask for a policy */
			if (!connected)
				printf("Answer: ");
			else {
				/* Do not prompt the first time */
				if (!first) {
					printf("WRONG\n");
				}
			}

			if (fgets(line, sizeof(line), stdin) == NULL) {
				if (connected && !cradle && errno == EPIPE &&
				    !requestor_restart) {
					requestor_start(guipath, 0);
					clearerr(stdin);
					clearerr(stdout);
					requestor_restart = 1;
					printf("%s\n", output);
					continue;
				}
				err(1, "EOF on policy input request");
			}
			p = line;
			strsep(&p, "\n");
		} else if (!first) {
			/* Error with filter */
			errx(1, "Filter generation error: %s", line);
		}
		first = 0;
		requestor_restart = 0;

		/* Simple keywords */
		if (!strcasecmp(line, "detach")) {
			if (policy->nfilters) {
				policy->flags |= POLICY_UNSUPERVISED;
				action = ICPOLICY_NEVER;
			} else {
				policy->flags |= POLICY_DETACHED;
				policy->flags |= POLICY_CHANGED;
				action = ICPOLICY_PERMIT;
			}
			goto out;
		} else if (!strcasecmp(line, "kill")) {
			action = ICPOLICY_KILL;
			goto out;
		} else if (!strcasecmp(line, "review") && fls != NULL) {
			filter_review(fls);
			continue;
		} else if (!strcasecmp(line, "templates")) {
			filter_templates(emulation);
			continue;
		} else if (!strncasecmp(line, "template ", 9)) {
			const char *errstr;
			int count = strtonum(line + 9, 1, INT_MAX, &errstr);

			if (errstr ||
			    filter_template(fd, policy, count) == -1) {
				printf("Syntax error.\n");
				continue;
			}

			if (fls != NULL)
				action = filter_evaluate(tls, fls, icpid);
			else
				action = ICPOLICY_PERMIT;
			if (action == ICPOLICY_ASK) {
				printf("Filter unmatched.\n");
				continue;
			}

			goto out;
		}

		if (filter_parse_simple(line, &action, pfuture) != -1) {
			/* Yes or no, no in-kernel policy allowed */
			if (isprompt)
				*pfuture = ICPOLICY_ASK;
			if (*pfuture == ICPOLICY_ASK)
				goto out;
			/* We have a policy decision */
			if (!isalias)
				break;

			/* No in-kernel policy for aliases */
			strlcpy(compose, line, sizeof(compose));
			
			/* Change into userland rule */
			snprintf(line, sizeof(line), "true then %s", compose);
		}

		if (isprompt) {
			printf("Answer only \"permit\" or \"deny\". "
			    "This is a prompt.\n");
			continue;
		}

		if (fls == NULL) {
			printf("Syntax error.\n");
			continue;
		}

		if (filter_parse(line, &filter) == -1) {
			printf("Parse error.\n");
			continue;
		}

		TAILQ_INSERT_TAIL(fls, filter, next);
		action = filter_evaluate(tls, fls, icpid);

		/* If we get a prompt flag here, we ask again */
		if (icpid->uflags & PROCESS_PROMPT) {
			filter_policyrecord(policy, filter, emulation, name, line);
			printf("Answer only \"permit\" or \"deny\". "
			    "This is a prompt.\n");
			continue;
		}
		if (action == ICPOLICY_ASK) {
			TAILQ_REMOVE(fls, filter, next);
			printf("Filter unmatched. Freeing it\n");
			filter_free(filter);
			continue;
		}

		break;
	}

	filter_policyrecord(policy, filter, emulation, name, line);

 out:
	if (connected)
		printf("OKAY\n");
	return (action);

}

static void
filter_replace(char *buf, size_t buflen, char *match, char *repl)
{
	while (strrpl(buf, buflen, match, repl) != NULL)
		;
}

char *
filter_expand(char *data)
{
	static char expand[2*PATH_MAX];

	strlcpy(expand, data, sizeof(expand));

	filter_replace(expand, sizeof(expand), "$HOME", home);
	filter_replace(expand, sizeof(expand), "$USER", username);
	filter_replace(expand, sizeof(expand), "$CWD", cwd);

	return (expand);
}

char *
filter_dynamicexpand(struct intercept_pid *icpid, char *data)
{
	extern char cwd[];
	static char expand[2*PATH_MAX];

	strlcpy(expand, data, sizeof(expand));

	filter_replace(expand, sizeof(expand), "$HOME", icpid->home);
	filter_replace(expand, sizeof(expand), "$USER", icpid->username);
	filter_replace(expand, sizeof(expand), "$CWD", cwd);

	return (expand);
}

/* Checks if the string needs expansion */

int
filter_needexpand(char *data)
{
	if (strstr(data, "$HOME") != NULL)
		return (1);
	if (strstr(data, "$USER") != NULL)
		return (1);
	if (strstr(data, "$CWD") != NULL)
		return (1);

	return (0);
}

int
filter_fnmatch(struct intercept_translate *tl, struct logic *logic)
{
	int res;
	char *line;

	if ((line = intercept_translate_print(tl)) == NULL)
		return (0);
	res = fnmatch(logic->filterdata, line, FNM_PATHNAME | FNM_LEADING_DIR);

	return (res == 0);
}

int
filter_substrmatch(struct intercept_translate *tl, struct logic *logic)
{
	char *line;

	if ((line = intercept_translate_print(tl)) == NULL)
		return (0);

	return (strstr(line, logic->filterdata) != NULL);
}

int
filter_negsubstrmatch(struct intercept_translate *tl, struct logic *logic)
{
	char *line;

	if ((line = intercept_translate_print(tl)) == NULL)
		return (0);

	return (strstr(line, logic->filterdata) == NULL);
}

int
filter_stringmatch(struct intercept_translate *tl, struct logic *logic)
{
	char *line;

	if ((line = intercept_translate_print(tl)) == NULL)
		return (0);

	return (!strcasecmp(line, logic->filterdata));
}

int
filter_negstringmatch(struct intercept_translate *tl, struct logic *logic)
{
	char *line;

	if ((line = intercept_translate_print(tl)) == NULL)
		return (1);

	return (strcasecmp(line, logic->filterdata) != 0);
}

int
filter_inpath(struct intercept_translate *tl, struct logic *logic)
{
	char *line, c;
	int len;

	if ((line = intercept_translate_print(tl)) == NULL)
		return (0);

	len = strlen(line);
	if (len == 0 || len > strlen(logic->filterdata))
		return (0);

	/* Root is always in path */
	if (len == 1)
		return (line[0] == '/');

	/* Complete filename needs to fit */
	if (strncmp(line, logic->filterdata, len))
		return (0);

	/* Termination has to be \0 or / */
	c = ((char *)logic->filterdata)[len];
	if (c != '/' && c != '\0')
		return (0);

	return (1);
}

int
filter_regex(struct intercept_translate *tl, struct logic *logic)
{
	regex_t tmpre, *re;
	char *line;
	int res;

	if ((line = intercept_translate_print(tl)) == NULL)
		return (0);

	re = logic->filterarg;
	if (re == NULL) {
		/* If regex does not compute, we just do not match */
		if (regcomp(&tmpre, logic->filterdata,
			REG_EXTENDED | REG_NOSUB) != 0)
			return (0);
		re = &tmpre;
	}

	res = regexec(re, line, 0, NULL, 0);

	/* Clean up temporary memory associated with regex */
	if (re == &tmpre)
		regfree(re);

	return (res == 0);
}

/* ARGSUSED */
int
filter_true(struct intercept_translate *tl, struct logic *logic)
{
	return (1);
}
@


1.37
log
@Remove NULL-check before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.36 2015/04/18 18:28:37 deraadt Exp $	*/
@


1.36
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.35 2015/01/16 00:19:12 deraadt Exp $	*/
d219 2
a220 4
	if (logic->type)
		free(logic->type);
	if (logic->filterdata)
		free(logic->filterdata);
d229 1
a229 2
	if (filter->rule)
		free(filter->rule);
@


1.35
log
@move to PATH_MAX, etc; normalize includes for life in the <limits.h> universe
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.34 2012/12/04 02:24:47 deraadt Exp $	*/
d618 2
a619 1
			int count = atoi(line + 9);
d621 1
a621 1
			if (count == 0 ||
@


1.34
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.33 2006/07/02 12:34:15 sturm Exp $	*/
d505 2
a506 2
	char line[2*MAXPATHLEN], *p;
	char compose[2*MAXPATHLEN];
d710 1
a710 1
	static char expand[2*MAXPATHLEN];
d725 1
a725 1
	static char expand[2*MAXPATHLEN];
@


1.33
log
@sync with systrace 1.6d, keeping local changes

tests and feedback by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.32 2006/05/02 19:49:05 sturm Exp $	*/
a31 1
#include <sys/param.h>
@


1.32
log
@some type cleanup

with feedback from kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.31 2006/04/26 20:19:25 sturm Exp $	*/
d400 4
d448 6
d562 1
a562 2
		if (icpid->uflags & PROCESS_PROMPT) {
			fprintf(stderr, "isprompt\n");
a563 1
		}
@


1.31
log
@ARGSUSED and a FALLTHROUGH to please lint

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.30 2004/01/23 20:51:18 sturm Exp $	*/
d143 1
a143 1
	int pidnr, pdcnr;
@


1.30
log
@support for cradle mode by marius at monkey.org; cradle mode allows the
systrace UI to be attached and re-attached, it also multiplexes across
systrace process so that one UI can function as central notification

from provos@@, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.29 2003/08/04 18:15:11 sturm Exp $	*/
d858 1
@


1.29
log
@several diffs from Niels as applied to NetBSD

monkey.org/NetBSD commit messages:
- get rid of retarded CWD handling.  CWD is fixed to the CWD of the systrace
that started everything.
- normalize file name function
- normalize CWD for cases where CWD has a symlink in it.  should solve
problems where CWD policies would not match.
- avoid warning due to name collision.
- fixed contrived race condition during attachment; from marius@@monkey.org

itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.28 2003/07/19 11:48:57 sturm Exp $	*/
d43 1
d55 1
d59 3
d569 12
a580 2
			if (fgets(line, sizeof(line), stdin) == NULL)
				errx(1, "EOF on policy input request");
d588 1
@


1.28
log
@- sync with NetBSD or Niels' tarball where appropriate
- keeps local changes
- fixes a bug in profile feedback optimization and avoids symbol
  conflicts with errno
- new feature: "ask" action

itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.27 2003/06/16 06:36:40 itojun Exp $	*/
d701 1
d708 1
a708 1
	filter_replace(expand, sizeof(expand), "$CWD", icpid->cwd);
@


1.27
log
@- limited number of processes per systrace
- escape fixes for special characters
markus, sturm ok.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.26 2003/05/29 00:39:12 itojun Exp $	*/
d185 1
d496 1
a496 1
	int first = 1, isalias;
a498 1
	icpid->uflags = 0;
d546 5
d565 1
a565 1
				errx(1, "EOF");
d616 3
d632 6
d643 2
a644 1
		if (filter_parse(line, &filter) == -1)
d646 1
d650 8
@


1.26
log
@>permit numberic values for uid and gid;  allow "<" and ">" for less and
>greate; requested by dugsong@@,
strum ok
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.25 2003/04/24 09:49:06 mpech Exp $	*/
d49 1
d175 1
a175 1
	short action, laction = 0;
a201 1
		laction = action;
d303 5
a307 7
	if (filter == NULL) {
		filter = calloc(1, sizeof(struct filter));
		if (filter == NULL)
			err(1, "%s:%d: calloc", __func__, __LINE__);
		if ((filter->rule = strdup(rule)) == NULL)
			err(1, "%s:%d: strdup", __func__, __LINE__);
	}
d527 1
a527 1
				    l);
@


1.25
log
@fix for EOF in interactive policy generation.

millert@@ provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.24 2002/12/09 07:24:56 itojun Exp $	*/
d137 1
a137 1
	int negative;
d143 7
a149 5
	negative = pdc->p_flags & PREDIC_NEGATIVE;
	if (pdc->p_flags & PREDIC_UID)
		res = icpid->uid == pdc->p_uid;
	else if (pdc->p_flags & PREDIC_GID)
		res = icpid->gid == pdc->p_gid;
d151 16
a166 1
	return (negative ? !res : res);
@


1.24
log
@add support for regular expressions and pidname translations.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.23 2002/12/09 07:22:52 itojun Exp $	*/
d544 2
a545 1
			fgets(line, sizeof(line), stdin);
@


1.23
log
@prevent the use of permit for aliases.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.22 2002/11/15 22:33:27 itojun Exp $	*/
d42 1
d99 1
a99 1
			return (0);
d370 1
a370 1
	return (NULL);
d503 1
a503 1
					break;
d771 28
@


1.22
log
@no need to check trans_size.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.21 2002/10/16 15:01:08 itojun Exp $	*/
d475 1
d479 1
a479 1
	int first = 1;
d484 2
d495 1
a495 2
			char compose[2*MAXPATHLEN], *l;
			char *lst = NULL;
d596 9
a604 1
			break;
@


1.21
log
@support for privilege elevation.

with privilege elevation no suid or sgid binaries are necessary any
longer.  Applications can be executed completely
unprivileged. Systrace raises the privileges for a single system call
depending on the configured policy.

Idea from discussions with Perry Metzger, Dug Song and Marcus Watts.

from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.20 2002/10/16 14:41:52 itojun Exp $	*/
a680 3

	if (tl->trans_size == 0)
		return (0);
@


1.20
log
@correctly evaluate group predicates.
afrom provos
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.19 2002/10/09 03:52:10 itojun Exp $	*/
d174 4
d412 1
a412 1
	intercept_setpid(&icpid);
@


1.19
log
@predicates are part of the grammar now; in non-root case, predicates are
evaluated only once; in root case, predicates and variable expansion are
dynamic.
from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.18 2002/10/08 03:06:45 itojun Exp $	*/
d146 1
a146 1
		res = icpid->uid == pdc->p_uid;
@


1.18
log
@assume that inserting a template implies permit for the current
syscall
from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.17 2002/09/23 04:41:02 itojun Exp $	*/
d53 2
d57 2
a58 1
static int filter_match(struct intercept_tlq *, struct logic *);
d62 1
d68 2
a69 1
filter_match(struct intercept_tlq *tls, struct logic *logic)
d72 1
a72 1
	int off = 0;
d76 1
a76 1
		return (!filter_match(tls, logic->left));
d78 1
a78 1
		if (filter_match(tls, logic->left))
d80 1
a80 1
		return (filter_match(tls, logic->right));
d82 1
a82 1
		if (!filter_match(tls, logic->left))
d84 1
a84 1
		return (filter_match(tls, logic->right));
d93 3
d113 36
a148 1
	return (logic->filter_match(tl, logic));
d152 2
a153 1
filter_evaluate(struct intercept_tlq *tls, struct filterq *fls, int *pflags)
d161 2
a162 1
		if (filter_match(tls, filter->logicroot)) {
d173 1
a173 1
			*pflags = filter->match_flags;
d396 22
d425 1
d444 5
a448 3
			fls = systrace_policyflq(policy, policy->emulation,
			    filter->name);
			TAILQ_INSERT_TAIL(fls, parsed, next);
d468 1
a468 1
    char *output, short *pfuture, int *pflags)
d477 1
a477 1
	*pflags = 0;
d576 1
a576 1
				action = filter_evaluate(tls, fls, pflags);
d602 1
a602 1
		action = filter_evaluate(tls, fls, pflags);
a632 1
	char *what;
d634 1
a634 2
	if (data != NULL)
		strlcpy(expand, data, sizeof(expand));
d636 3
a638 6
	what = getenv("HOME");
	if (what != NULL)
		filter_replace(expand, sizeof(expand), "$HOME", what);
	what = getenv("USER");
	if (what != NULL)
		filter_replace(expand, sizeof(expand), "$USER", what);
d640 13
a652 1
	filter_replace(expand, sizeof(expand), "$CWD", cwd);
d655 15
@


1.17
log
@support for templates.  they allow fast generation of new policies. an
appropriate template can be inserted during initial policy generation.
from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.16 2002/08/08 21:18:20 provos Exp $	*/
d505 4
a508 1
			action = filter_evaluate(tls, fls, pflags);
@


1.16
log
@no \n in err
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.15 2002/07/19 14:38:57 itojun Exp $	*/
d57 2
d179 53
d396 1
a396 1
filter_ask(struct intercept_tlq *tls, struct filterq *fls,
d493 19
@


1.15
log
@constify, have missing prototypes, use pedantic compilation options.
niels ok
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.14 2002/07/09 15:22:27 provos Exp $	*/
d355 1
a355 2
		errx(1, "%s:%d: no policy %d\n", __func__, __LINE__,
		    policynr);
@


1.14
log
@support for system call aliasing.  stat/fstat/readlink/access etc... gets
grouped into fsread, unlink/rmdir/mkdir goes to fswrite.  open switches
back between fsread and fswrite depending on oflags parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.13 2002/06/19 16:31:07 provos Exp $	*/
d47 1
d54 8
a61 1
int
d138 1
a138 1
void
d162 1
a162 1
void
d176 1
a176 1
void
d178 1
a178 1
    char *emulation, char *name, char *rule)
d269 2
a270 2
filter_modifypolicy(int fd, int policynr, char *emulation, char *name,
    short future)
d342 1
a342 1
    int policynr, char *emulation, char *name,
d476 1
a476 1
void
@


1.13
log
@more careful buffer handling; pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.12 2002/06/18 01:54:31 deraadt Exp $	*/
d49 1
d260 28
d317 2
a318 5
			res = systrace_modifypolicy(fd, policy->policynr,
			    filter->name, future);
			if (res == -1)
				errx(1, "%s:%d: modify policy for \"%s\"",
				    __func__, __LINE__, filter->rule);
@


1.12
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.11 2002/06/11 05:30:28 provos Exp $	*/
d36 1
d210 1
a210 1
	char buf[1024];
d214 3
a216 1
	strlcpy(buf, rule, sizeof(buf));
@


1.11
log
@change a few buffers to 2*MAXPATHLEN; pob deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.10 2002/06/09 05:47:27 todd Exp $	*/
d330 1
a330 1
			
d339 1
a339 1
					
@


1.10
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.9 2002/06/07 18:05:20 provos Exp $	*/
d327 1
a327 1
			char compose[MAXPATHLEN], *l;
@


1.9
log
@use profiling to order filter lists more optimally.
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.8 2002/06/06 01:05:57 provos Exp $	*/
d342 1
a342 1
				    tl->name, 
@


1.8
log
@fix automatic policy generation for system calls that have the same args
twice, like rename.  problem found by gustavo
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.7 2002/06/05 18:14:00 provos Exp $	*/
d99 2
a100 2
	struct filter *filter;
	short action;
d103 2
d106 8
a113 1
			action = filter->match_action;
d119 4
@


1.7
log
@no special case of execve.
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.6 2002/06/05 16:51:08 provos Exp $	*/
d299 1
a299 1
	int first = 0;
d310 38
d358 1
a358 1
				if (first) {
a360 1
				first = 1;
d364 5
a368 30
		} else {
			/* Automatically allow */
			if (tls != NULL) {
				struct intercept_translate *tl;
				char compose[MAXPATHLEN], *l;
				int set = 0;

				/* Explicitly match every component */
				line[0] = '\0';
				TAILQ_FOREACH(tl, tls, next) {
					if (!tl->trans_valid)
						break;
					l = intercept_translate_print(tl);
					if (l == NULL)
						continue;

					snprintf(compose, sizeof(compose),
					    "%s eq \"%s\"", tl->name, l);
					if (set)
						strlcat(line, " and ",
						    sizeof(line));
					else
						set = 1;
					strlcat(line, compose, sizeof(line));
				}
				if (!set)
					strlcpy(line, "true", sizeof(line));
				strlcat(line, " then permit", sizeof(line));
			} else
				strlcpy(line, "permit", sizeof(line));
d370 1
a370 3

		p = line;
		strsep(&p, "\n");
@


1.6
log
@introduce an automatic policy generation mode.  it creates a policy based
on what the application tries to do.  the policy can be refined further on.
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.5 2002/06/05 16:09:20 provos Exp $	*/
d329 1
a329 3
			if (strcmp(name, "execve") == 0) {
				strlcpy(line,"true then permit", sizeof(line));
			} else if (tls != NULL) {
@


1.5
log
@inpath logic, for example, filename inpath "$CWD"
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.4 2002/06/05 15:59:52 provos Exp $	*/
d47 1
d295 1
a295 1
	char line[1024], *p;
d308 2
a309 1
	printf("%s\n", output);
d314 10
a323 6
		if (!connected)
			printf("Answer: ");
		else {
			/* Do not prompt the first time */
			if (first) {
				printf("WRONG\n");
d325 34
a358 1
			first = 1;
a360 1
		fgets(line, sizeof(line), stdin);
@


1.4
log
@know about CWD. will make some filter rules simpler.
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.3 2002/06/04 19:15:54 deraadt Exp $	*/
d466 29
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.2 2002/06/04 19:07:04 provos Exp $	*/
d32 1
d48 1
d390 1
a390 1
	static char expand[1024];
d402 2
@


1.2
log
@__FUNCTION__ -> __func__ from espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filter.c,v 1.1 2002/06/04 17:20:04 provos Exp $	*/
d165 1
a165 1
	
d249 1
a249 1
	for (filter = TAILQ_FIRST(&policy->prefilters); 
d409 1
a409 1
	
d424 1
a424 1
	
d435 1
a435 1
	
@


1.1
log
@initial import of systrace.  don't touch this, more stuff coming in a while
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d158 1
a158 1
			err(1, "%s:%d: calloc", __FUNCTION__, __LINE__);
d160 1
a160 1
			err(1, "%s:%d: strdup", __FUNCTION__, __LINE__);
d181 1
a181 1
		err(1, "%s:%d: strdup", __FUNCTION__, __LINE__);
d262 1
a262 1
			    __FUNCTION__, __LINE__, filter->rule);
d273 1
a273 1
				    __FUNCTION__, __LINE__, filter->rule);
d302 1
a302 1
		errx(1, "%s:%d: no policy %d\n", __FUNCTION__, __LINE__,
@

