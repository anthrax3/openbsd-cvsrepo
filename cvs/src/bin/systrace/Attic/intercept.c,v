head	1.66;
access;
symbols
	OPENBSD_5_9:1.65.0.2
	OPENBSD_5_9_BASE:1.65
	OPENBSD_5_8:1.63.0.6
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.60.0.8
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.60.0.4
	OPENBSD_5_4_BASE:1.60
	OPENBSD_5_3:1.60.0.2
	OPENBSD_5_3_BASE:1.60
	OPENBSD_5_2:1.58.0.4
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.58
	OPENBSD_5_1:1.58.0.2
	OPENBSD_5_0:1.56.0.6
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.56.0.4
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.56.0.2
	OPENBSD_4_8_BASE:1.56
	OPENBSD_4_7:1.55.0.10
	OPENBSD_4_7_BASE:1.55
	OPENBSD_4_6:1.55.0.12
	OPENBSD_4_6_BASE:1.55
	OPENBSD_4_5:1.55.0.8
	OPENBSD_4_5_BASE:1.55
	OPENBSD_4_4:1.55.0.6
	OPENBSD_4_4_BASE:1.55
	OPENBSD_4_3:1.55.0.4
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.55.0.2
	OPENBSD_4_2_BASE:1.55
	OPENBSD_4_1:1.53.0.2
	OPENBSD_4_1_BASE:1.53
	OPENBSD_4_0:1.52.0.2
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.49.0.8
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.49.0.6
	OPENBSD_3_8_BASE:1.49
	OPENBSD_3_7:1.49.0.4
	OPENBSD_3_7_BASE:1.49
	OPENBSD_3_6:1.49.0.2
	OPENBSD_3_6_BASE:1.49
	OPENBSD_3_5:1.45.0.2
	OPENBSD_3_5_BASE:1.45
	OPENBSD_3_4:1.42.0.2
	OPENBSD_3_4_BASE:1.42
	OPENBSD_3_3:1.38.0.2
	OPENBSD_3_3_BASE:1.38
	OPENBSD_3_2:1.31.0.2
	OPENBSD_3_2_BASE:1.31;
locks; strict;
comment	@ * @;


1.66
date	2016.04.25.19.09.25;	author tedu;	state dead;
branches;
next	1.65;
commitid	Ne4KgWE1uInoydsl;

1.65
date	2015.12.09.19.36.17;	author mmcc;	state Exp;
branches;
next	1.64;
commitid	8oyfVibTyuKjsb15;

1.64
date	2015.10.01.02.32.07;	author guenther;	state Exp;
branches;
next	1.63;
commitid	DA03ltgCTpoknko0;

1.63
date	2015.01.16.00.19.12;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	9JSDzKTCgxU6o5el;

1.62
date	2014.07.20.01.38.40;	author guenther;	state Exp;
branches;
next	1.61;
commitid	0acpjAf5myNxgwB5;

1.61
date	2014.04.24.01.57.06;	author tedu;	state Exp;
branches;
next	1.60;

1.60
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2012.08.23.00.08.36;	author guenther;	state Exp;
branches;
next	1.58;

1.58
date	2011.10.18.20.01.28;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	2011.09.18.23.24.14;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	2010.04.20.21.56.52;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2007.06.15.11.43.08;	author sturm;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.15.19.42.46;	author sturm;	state Exp;
branches;
next	1.53;

1.53
date	2006.09.19.10.48.41;	author otto;	state Exp;
branches;
next	1.52;

1.52
date	2006.07.02.12.34.15;	author sturm;	state Exp;
branches;
next	1.51;

1.51
date	2006.04.26.20.19.25;	author sturm;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.06.10.44.10;	author djm;	state Exp;
branches;
next	1.49;

1.49
date	2004.07.07.07.31.40;	author marius;	state Exp;
branches;
next	1.48;

1.48
date	2004.06.24.21.00.10;	author marius;	state Exp;
branches;
next	1.47;

1.47
date	2004.06.23.05.16.35;	author marius;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.30.15.43.20;	author sturm;	state Exp;
branches;
next	1.45;

1.45
date	2004.01.30.17.21.16;	author sturm;	state Exp;
branches;
next	1.44;

1.44
date	2003.10.18.19.26.00;	author jmc;	state Exp;
branches;
next	1.43;

1.43
date	2003.10.08.16.32.44;	author sturm;	state Exp;
branches;
next	1.42;

1.42
date	2003.08.04.18.15.11;	author sturm;	state Exp;
branches;
next	1.41;

1.41
date	2003.07.19.11.48.57;	author sturm;	state Exp;
branches;
next	1.40;

1.40
date	2003.06.16.06.36.40;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	2003.05.17.03.09.59;	author sturm;	state Exp;
branches;
next	1.38;

1.38
date	2003.02.20.22.03.31;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2002.12.09.07.22.53;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.26.03.48.07;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.12.17.04.07;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2002.10.17.05.49.40;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2002.10.16.15.01.08;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2002.10.09.03.52.10;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2002.09.17.04.57.53;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2002.09.06.22.56.21;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2002.08.28.03.30.27;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2002.08.08.00.47.33;	author provos;	state Exp;
branches;
next	1.27;

1.27
date	2002.08.07.21.27.15;	author provos;	state Exp;
branches;
next	1.26;

1.26
date	2002.08.05.19.10.22;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.05.14.49.26;	author provos;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.04.04.15.50;	author provos;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.02.02.26.27;	author provos;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.01.20.50.17;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.01.20.16.45;	author provos;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.30.16.09.48;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.30.03.16.40;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.22.04.02.39;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.19.14.38.57;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.16.01.22.48;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.12.12.26.29;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.10.13.46.13;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.10.07.05.02;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.09.20.46.18;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.09.15.22.27;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.09.13.07.42;	author dhartmei;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.07.23.14.43;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.28.00.26.29;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.21.15.26.06;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.19.16.31.07;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.10.19.16.26;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.04.19.25.54;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.04.19.15.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.04.19.07.04;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.04.17.20.04;	author provos;	state Exp;
branches;
next	;


desc
@@


1.66
log
@boom goes the dynamite
@
text
@/*	$OpenBSD: intercept.c,v 1.65 2015/12/09 19:36:17 mmcc Exp $	*/
/*
 * Copyright 2002 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/types.h>
#include <sys/tree.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <limits.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <poll.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <limits.h>
#include <errno.h>
#include <err.h>
#include <libgen.h>
#include <pwd.h>

#include "intercept.h"

void simplify_path(char *);
char *intercept_realpath(const char *, char *);

struct intercept_syscall {
	SPLAY_ENTRY(intercept_syscall) node;

	char name[64];
	char emulation[16];

	short (*cb)(int, pid_t, int, const char *, int, const char *, void *,
	    int, struct intercept_replace *, struct intercept_tlq *, void *);
	void *cb_arg;

	struct intercept_tlq tls;
};

static int sccompare(struct intercept_syscall *, struct intercept_syscall *);
static int pidcompare(struct intercept_pid *, struct intercept_pid *);
static struct intercept_syscall *intercept_sccb_find(const char *,
    const char *);
static void sigusr1_handler(int);

static SPLAY_HEAD(pidtree, intercept_pid) pids;
static SPLAY_HEAD(sctree, intercept_syscall) scroot;

static volatile int got_sigusr1 = 0;

/* Generic callback functions */

void (*intercept_newimagecb)(int, pid_t, int, const char *, const char *, void *) = NULL;
void *intercept_newimagecbarg = NULL;
short (*intercept_gencb)(int, pid_t, int, const char *, int, const char *, void *, int, void *) = NULL;
void *intercept_gencbarg = NULL;
void (*intercept_pfreecb)(int, void*);
void *intercept_pfreearg = NULL;

int
sccompare(struct intercept_syscall *a, struct intercept_syscall *b)
{
	int diff;

	diff = strcmp(a->emulation, b->emulation);
	if (diff)
		return (diff);
	return (strcmp(a->name, b->name));
}

int
pidcompare(struct intercept_pid *a, struct intercept_pid *b)
{
	int diff = a->pid - b->pid;

	if (diff == 0)
		return (0);
	if (diff > 0)
		return (1);
	return (-1);
}

SPLAY_PROTOTYPE(sctree, intercept_syscall, node, sccompare)
SPLAY_GENERATE(sctree, intercept_syscall, node, sccompare)

SPLAY_PROTOTYPE(pidtree, intercept_pid, next, pidcompare)
SPLAY_GENERATE(pidtree, intercept_pid, next, pidcompare)

extern struct intercept_system intercept;
int ic_abort;

int
intercept_init(void)
{
	SPLAY_INIT(&pids);
	SPLAY_INIT(&scroot);

	intercept_newimagecb = NULL;
	intercept_gencb = NULL;

	return (intercept.init());
}

struct intercept_syscall *
intercept_sccb_find(const char *emulation, const char *name)
{
	struct intercept_syscall tmp;

	strlcpy(tmp.name, name, sizeof(tmp.name));
	strlcpy(tmp.emulation, emulation, sizeof(tmp.emulation));
	return (SPLAY_FIND(sctree, &scroot, &tmp));
}

struct intercept_translate *
intercept_register_translation(char *emulation, char *name, int offset,
    struct intercept_translate *tl)
{
	struct intercept_syscall *tmp;
	struct intercept_translate *tlnew;

	if (offset >= INTERCEPT_MAXSYSCALLARGS)
		errx(1, "%s: %s-%s: offset too large",
		    __func__, emulation, name);

	tmp = intercept_sccb_find(emulation, name);
	if (tmp == NULL)
		errx(1, "%s: %s-%s: can't find call back",
		    __func__, emulation, name);

	tlnew = malloc(sizeof(struct intercept_translate));
	if (tlnew == NULL)
		err(1, "%s: %s-%s: malloc",
		    __func__, emulation, name);

	memcpy(tlnew, tl, sizeof(struct intercept_translate));
	tlnew->off = offset;

	TAILQ_INSERT_TAIL(&tmp->tls, tlnew, next);

	return (tlnew);
}

void *
intercept_sccb_cbarg(char *emulation, char *name)
{
	struct intercept_syscall *tmp;

	if ((tmp = intercept_sccb_find(emulation, name)) == NULL)
		return (NULL);

	return (tmp->cb_arg);
}

int
intercept_register_sccb(char *emulation, char *name,
    short (*cb)(int, pid_t, int, const char *, int, const char *, void *, int,
	struct intercept_replace *, struct intercept_tlq *, void *),
    void *cbarg)
{
	struct intercept_syscall *tmp;

	if (intercept_sccb_find(emulation, name))
		return (-1);

	if (intercept.getsyscallnumber(emulation, name) == -1) {
		warnx("%s: %d: unknown syscall: %s-%s", __func__, __LINE__,
		    emulation, name);
		return (-1);
	}

	if ((tmp = calloc(1, sizeof(struct intercept_syscall))) == NULL) {
		warn("%s:%d: calloc", __func__, __LINE__);
		return (-1);
	}

	TAILQ_INIT(&tmp->tls);
	strlcpy(tmp->name, name, sizeof(tmp->name));
	strlcpy(tmp->emulation, emulation, sizeof(tmp->emulation));
	tmp->cb = cb;
	tmp->cb_arg = cbarg;

	SPLAY_INSERT(sctree, &scroot, tmp);

	return (0);
}

int
intercept_register_gencb(short (*cb)(int, pid_t, int, const char *, int, const char *, void *, int, void *), void *arg)
{
	intercept_gencb = cb;
	intercept_gencbarg = arg;

	return (0);
}

int
intercept_register_execcb(void (*cb)(int, pid_t, int, const char *, const char *, void *), void *arg)
{
	intercept_newimagecb = cb;
	intercept_newimagecbarg = arg;

	return (0);
}

int
intercept_register_pfreecb(void (*cb)(int, void *), void *arg)
{
	intercept_pfreecb = cb;
	intercept_pfreearg = arg;

	return (0);
}

/* ARGSUSED */
static void
sigusr1_handler(int signum)
{
	/* all we need to do is pretend to handle it */
	got_sigusr1 = 1;
}

void
intercept_setpid(struct intercept_pid *icpid, uid_t uid, gid_t gid)
{
	struct passwd *pw;

	icpid->uid = uid;
	icpid->gid = gid;
	if ((pw = getpwuid(icpid->uid)) == NULL) {
		snprintf(icpid->username, sizeof(icpid->username),
		    "unknown(%d)", icpid->uid);
		strlcpy(icpid->home, "/var/empty", sizeof(icpid->home));
	} else {
		strlcpy(icpid->username, pw->pw_name, sizeof(icpid->username));
		strlcpy(icpid->home, pw->pw_dir, sizeof(icpid->home));
	}
}

pid_t
intercept_run(int bg, int *fdp, uid_t uid, gid_t gid,
    char *path, char *const argv[])
{
	struct intercept_pid *icpid;
	sigset_t none, set, oset;
	sig_t ohandler;
	pid_t pid, cpid;
	int status;

	/* Block signals so that timing on signal delivery does not matter */
	sigemptyset(&none);
	sigemptyset(&set);
	sigaddset(&set, SIGUSR1);
	if (sigprocmask(SIG_BLOCK, &set, &oset) == -1)
		err(1, "sigprocmask");
	ohandler = signal(SIGUSR1, sigusr1_handler);
	if (ohandler == SIG_ERR)
		err(1, "signal");

	/*
	 * If systrace process will be the child then we must reopen
	 * the fd in the child after the fork
	 */
	if (bg)
		close(*fdp);

	pid = getpid();
	cpid = fork();
	if (cpid == -1)
		return (-1);

	/*
	 * If the systrace process should be in the background and we're
	 * the parent, or vice versa.
	 */
	if ((!bg && cpid == 0) || (bg && cpid != 0)) {
		if (bg) {
			/* Wait for child to "detach" */
			cpid = wait(&status);
			if (cpid == -1)
				err(1, "wait");
			if (status != 0)
				errx(1, "wait: child gave up");
		}

		/* Sleep */
		sigsuspend(&none);

		if (!got_sigusr1)
			errx(1, "wrong signal");

		/*
		 * Woken up, restore signal handling state.
		 *
		 * Note that there is either no child or we have no idea
		 * what pid it might have at this point.  If we fail.
		 */
		if (signal(SIGUSR1, ohandler) == SIG_ERR)
			err(1, "signal");
		if (sigprocmask(SIG_SETMASK, &oset, NULL) == -1)
			err(1, "sigprocmask");

		/* Change to different user */
		if (uid || gid) {
			if (setresgid(gid, gid, gid) == -1)
				err(1, "setresgid");
			if (setgroups(1, &gid) == -1)
				err(1, "setgroups");
			if (setresuid(uid, uid, uid) == -1)
				err(1, "setresuid");
		}
		execvp(path, argv);

		/* Error */
		err(1, "execvp");
	}

	/* Choose the pid of the systraced process */
	pid = bg ? pid : cpid;

	icpid = intercept_getpid(pid);
	
	/* Set up user related information */
	if (!uid && !gid) {
		uid = getuid();
		gid = getgid();
	}
	intercept_setpid(icpid, uid, gid);
	
	/* Setup done, restore signal handling state */
	if (signal(SIGUSR1, ohandler) == SIG_ERR) {
		int saved_errno = errno;
		kill(pid, SIGKILL);
		errc(1, saved_errno, "signal");
	}
	if (sigprocmask(SIG_SETMASK, &oset, NULL) == -1) {
		int saved_errno = errno;
		kill(pid, SIGKILL);
		errc(1, saved_errno, "sigprocmask");
	}

	if (bg) {
		if (daemon(1, 1) == -1) {
			int saved_errno = errno;
			kill(pid, SIGKILL);
			errc(1, saved_errno, "daemon");
		}
		if ((*fdp = intercept_open()) == -1) {
			int saved_errno = errno;
			kill(pid, SIGKILL);
			errc(1, saved_errno, "intercept_open");
		}
	}

	return (pid);
}

int
intercept_existpids(void)
{
	return (SPLAY_ROOT(&pids) != NULL);
}

void
intercept_freepid(pid_t pidnr)
{
	struct intercept_pid *pid, tmp2;

	tmp2.pid = pidnr;
	pid = SPLAY_FIND(pidtree, &pids, &tmp2);
	if (pid == NULL)
		return;

	intercept.freepid(pid);

	SPLAY_REMOVE(pidtree, &pids, pid);
	free(pid->name);
	free(pid->newname);
	free(pid);
}

struct intercept_pid *
intercept_findpid(pid_t pid)
{
	struct intercept_pid *tmp, tmp2;

	tmp2.pid = pid;
	tmp = SPLAY_FIND(pidtree, &pids, &tmp2);

	return (tmp);
}

struct intercept_pid *
intercept_getpid(pid_t pid)
{
	struct intercept_pid *tmp, tmp2;

	tmp2.pid = pid;
	tmp = SPLAY_FIND(pidtree, &pids, &tmp2);

	if (tmp)
		return (tmp);

	if ((tmp = calloc(1, sizeof(struct intercept_pid))) == NULL)
		err(1, "%s: calloc", __func__);

	tmp->pid = pid;

	SPLAY_INSERT(pidtree, &pids, tmp);

	return (tmp);
}

int
intercept_open(void)
{
	int fd;

	if ((fd = intercept.open()) == -1)
		return (-1);

	if (fcntl(fd, F_SETFL, O_NONBLOCK) == -1)
		warn("fcntl(O_NONBLOCK)");

	return (fd);
}

int
intercept_attach(int fd, pid_t pid)
{
	return (intercept.attach(fd, pid));
}

int
intercept_attachpid(int fd, pid_t pid, char *name)
{
	struct intercept_pid *icpid;
	int res;

	res = intercept.attach(fd, pid);
	if (res == -1)
		return (-1);

	icpid = intercept_getpid(pid);

	if ((icpid->newname = strdup(name)) == NULL)
		err(1, "strdup");

	if (intercept.report(fd, pid) == -1)
		return (-1);

	/* Indicates a running attach */
	icpid->execve_code = -1;

	return (0);
}

int
intercept_detach(int fd, pid_t pid)
{
	int res;

	res = intercept.detach(fd, pid);
	if (res != -1)
		intercept_freepid(pid);
	return (res);
}

int
intercept_read(int fd)
{
	struct pollfd pollfd;
	int n;

	pollfd.fd = fd;
	pollfd.events = POLLIN;

	do  {
		n = poll(&pollfd, 1, -1);
		if (n == -1) {
			if (errno != EINTR && errno != EAGAIN)
				return (-1);
		}
	} while (n <= 0);

	if (!(pollfd.revents & (POLLIN|POLLRDNORM)))
		return (-1);

	return (intercept.read(fd));
}

int
intercept_replace_init(struct intercept_replace *repl)
{
	memset(repl, 0, sizeof(struct intercept_replace));

	return (0);
}

int
intercept_replace_add(struct intercept_replace *repl, int off,
    u_char *addr, size_t len, u_int flags)
{
	int ind = repl->num;

	if (ind >= INTERCEPT_MAXSYSCALLARGS)
		return (-1);

	repl->ind[ind] = off;
	repl->address[ind] = addr;
	repl->len[ind] = len;
	repl->flags[ind] = flags;

	repl->num++;

	return (0);
}

int
intercept_replace(int fd, pid_t pid, u_int16_t seqnr,
    struct intercept_replace *repl)
{
	if (repl->num == 0)
		return (0);

	return (intercept.replace(fd, pid, seqnr, repl));
}

char *
intercept_get_string(int fd, pid_t pid, void *addr)
{
	static char name[ARG_MAX];
	int off = 0, done = 0, stride;

	if (addr == NULL)
		return (NULL);

	stride = 32;
	do {
		if (intercept.io(fd, pid, INTERCEPT_READ, (char *)addr + off,
		    &name[off], stride) == -1) {
			/* Did the current system call get interrupted? */
			if (errno == EBUSY)
				return (NULL);
			if (errno != EINVAL || stride == 1) {
				warn("%s: ioctl", __func__);
				return (NULL);
			}

			/* Try smaller stride */
			stride /= 2;
			continue;
		}

		off += stride;
		name[off] = '\0';
		if (strlen(name) < off)
			done = 1;

	} while (!done && off + stride + 1 < sizeof(name));

	if (!done) {
		warnx("%s: string too long", __func__);
		return (NULL);
	}

	return (name);
}

char *
intercept_filename(int fd, pid_t pid, void *addr, int userp, char *before)
{
	return (intercept_filenameat(fd, pid, AT_FDCWD, addr, userp, before));
}

char *
intercept_filenameat(int fd, pid_t pid, int atfd, void *addr, int userp, char *before)
{
	char *name;

	if ((name = intercept_get_string(fd, pid, addr)) == NULL)
		goto abort;

	if (before != NULL)
		strlcpy(before, name, PATH_MAX);

	if ((name = normalize_filenameat(fd, pid, atfd, name, userp)) == NULL)
		goto abort;

	return (name);

 abort:
	ic_abort = 1;
	return (NULL);
}

/*
 * Normalizes a pathname so that Systrace policies entries are
 * invariant to symlinks.
 */

char *
normalize_filename(int fd, pid_t pid, char *name, int userp)
{
	return (normalize_filenameat(fd, pid, AT_FDCWD, name, userp));
}

char *
normalize_filenameat(int fd, pid_t pid, int atfd, char *name, int userp)
{
	static char cwd[2*PATH_MAX];
	int havecwd = 0;

	/*
	 * The empty filename does not receive normalization.
	 * System calls are supposed to fail on it.
	 */
	if (strcmp(name, "") == 0)
		return (name);

	if (fd != -1 && intercept.setcwd(fd, pid, atfd) == -1) {
		if (errno == EBUSY)
			return (NULL);
	getcwderr:
		if (strcmp(name, "/") == 0)
			return (name);

		err(1, "%s: getcwd", __func__);
	}

	if (userp == ICLINK_NONE) {
		if (getcwd(cwd, sizeof(cwd)) == NULL)
			goto getcwderr;
		havecwd = 1;
	}

	if (havecwd && name[0] != '/') {
		if (strlcat(cwd, "/", sizeof(cwd)) >= sizeof(cwd))
			return (NULL);
		if (strlcat(cwd, name, sizeof(cwd)) >= sizeof(cwd))
			return (NULL);
	} else {
		if (strlcpy(cwd, name, sizeof(cwd)) >= sizeof(cwd))
			return (NULL);
	}

	if (userp != ICLINK_NONE) {
		static char rcwd[2*PATH_MAX];
		char *base = basename(cwd);
		int failed = 0;

		/* The dot maybe used by rmdir("/tmp/something/.") */
		if (strcmp(base, ".") == 0)
			goto nolast;

		if (userp == ICLINK_NOLAST) {
			/* Check if the last component has special meaning */
			if (strcmp(base, "..") == 0 || strcmp(base, "/") == 0)
				userp = ICLINK_ALL;
			else
				goto nolast;
		}

		/* If realpath fails then the filename does not exist,
		 * or we are supposed to not resolve the last component */
		if (intercept_realpath(cwd, rcwd) == NULL) {
			char *dir, last_char;
			struct stat st;
			int base_is_dir;

			if (errno != EACCES) {
				failed = 1;
				goto out;
			}

		nolast:
			/* Component of path could not be entered */
			if (strlcpy(rcwd, cwd, sizeof(rcwd)) >= sizeof(rcwd))
				goto error;
			last_char = rcwd[strlen(rcwd)-1];
			if (last_char == '/')
				base_is_dir = 1;
			else
				base_is_dir = 0;
			if ((base = basename(rcwd)) == NULL)
				goto error;
			if ((dir = dirname(rcwd)) == NULL)
				goto error;

			/* So, try again */
			if (intercept_realpath(dir, rcwd) == NULL) {
				failed = 1;
				goto out;
			}
			/* If path is not "/" append a "/" */
			if (strlen(rcwd) > 1 &&
			    strlcat(rcwd, "/", sizeof(rcwd)) >= sizeof(rcwd))
				goto error;
			if (strlcat(rcwd, base, sizeof(rcwd)) >= sizeof(rcwd))
				goto error;
			if (base_is_dir &&
			    strlcat(rcwd, "/", sizeof(rcwd)) >= sizeof(rcwd))
				goto error;
			/* 
			 * At this point, filename has to exist and has to
			 * be a directory.
			 */
			if (userp != ICLINK_NOLAST) {
				if (lstat(rcwd, &st) == -1 ||
				    !S_ISDIR(st.st_mode))
					failed = 1;
			}
		}
	out:
		if (failed)
			snprintf(rcwd, sizeof(rcwd),
			    "/<non-existent filename>: %s", cwd);
		name = rcwd;
	} else {
		simplify_path(cwd);
		name = cwd;
	}


	/* Restore working directory and change root space after realpath */
	if (fd != -1 && intercept.restcwd(fd) == -1)
		err(1, "%s: restcwd", __func__);

	return (name);

 error:
	errx(1, "%s: filename too long", __func__);
	/* NOTREACHED */
}

void
intercept_syscall(int fd, pid_t pid, u_int16_t seqnr, int policynr,
    const char *name, int code, const char *emulation, void *args, int argsize)
{
	short action, flags = 0;
	struct intercept_syscall *sc;
	struct intercept_pid *icpid;
	struct elevate *elevate = NULL;
	int error = 0;

	action = ICPOLICY_PERMIT;
	flags = 0;

	icpid = intercept_getpid(pid);

	/* Special handling for the exec call */
	if (!strcmp(name, "execve")) {
		void *addr;
		char *argname, before[PATH_MAX];

		icpid->execve_code = code;
		icpid->policynr = policynr;

		free(icpid->newname);

		intercept.getarg(0, args, argsize, &addr);
		argname = intercept_filename(fd, pid, addr, ICLINK_ALL, before);
		if (argname == NULL)
			err(1, "%s:%d: intercept_filename",
			    __func__, __LINE__);

		if (intercept.scriptname(fd, pid, before) != 0)
			err(1, "%s:%d: ioctl", __func__, __LINE__);

		icpid->newname = strdup(argname);
		if (icpid->newname == NULL)
			err(1, "%s:%d: strdup", __func__, __LINE__);

		/* We need to know the result from this system call */
		flags = ICFLAGS_RESULT;
	}

	icpid->elevate = NULL;

	sc = intercept_sccb_find(emulation, name);
	if (sc != NULL) {
		struct intercept_translate *tl;

		ic_abort = 0;
		TAILQ_FOREACH(tl, &sc->tls, next) {
			if (intercept_translate(tl, fd, pid, tl->off,
				args, argsize) == -1)
				break;
		}

		if (!ic_abort) {
			struct intercept_replace repl;

			intercept_replace_init(&repl);

			action = (*sc->cb)(fd, pid, policynr, name, code,
			    emulation, args, argsize, &repl,
			    &sc->tls, sc->cb_arg);

			if (action < ICPOLICY_NEVER) {
				/* if we can not rewrite the arguments,
				 * system call fails.
				 */
				if (intercept_replace(fd, pid, seqnr, &repl) == -1)
					action = ICPOLICY_NEVER;
			}
		} else
			action = ICPOLICY_NEVER;
	} else if (intercept_gencb != NULL)
		action = (*intercept_gencb)(fd, pid, policynr, name, code,
		    emulation, args, argsize, intercept_gencbarg);

	if (action > 0) {
		error = action;
		action = ICPOLICY_NEVER;
	} else {
		icpid = intercept_findpid(pid);
		if (icpid != NULL)
			elevate = icpid->elevate;
		else
			elevate = NULL;
	}

	/* Resume execution of the process */
	intercept.answer(fd, pid, seqnr, action, error, flags, elevate);
}

void
intercept_syscall_result(int fd, pid_t pid, u_int16_t seqnr, int policynr,
    const char *name, int code, const char *emulation, void *args, int argsize,
    int result, void *rval)
{
	struct intercept_pid *icpid;

	if (result > 0)
		goto out;

	icpid = intercept_getpid(pid);
	if (!strcmp("execve", name)) {
		intercept_newimage(fd, pid, policynr,
		    emulation, icpid->newname, icpid);
		/* we might have detached by now */
		if (intercept_findpid(pid) == NULL)
			return;
	}

 out:
	/* Resume execution of the process */
	intercept.answer(fd, pid, seqnr, 0, 0, 0, NULL);
}

void
intercept_newimage(int fd, pid_t pid, int policynr,
    const char *emulation, char *newname, struct intercept_pid *icpid)
{
	if (icpid == NULL)
		icpid = intercept_getpid(pid);

	free(icpid->name);
	if ((icpid->name = strdup(newname)) == NULL)
		err(1, "%s:%d: strdup", __func__, __LINE__);

	free(icpid->newname);
	icpid->newname = NULL;

	if (intercept_newimagecb != NULL)
		(*intercept_newimagecb)(fd, pid, policynr, emulation,
		    icpid->name, intercept_newimagecbarg);
}

int
intercept_newpolicy(int fd)
{
	int policynr;

	policynr = intercept.newpolicy(fd);

	return (policynr);
}

int
intercept_assignpolicy(int fd, pid_t pid, int policynr)
{
	return (intercept.assignpolicy(fd, pid, policynr));
}

int
intercept_modifypolicy_nr(int fd, int policynr, int code, short policy)
{
	return (intercept.policy(fd, policynr, code, policy));
}

int
intercept_modifypolicy(int fd, int policynr, const char *emulation,
    const char *name, short policy)
{
	int code;

	code = intercept.getsyscallnumber(emulation, name);
	if (code == -1)
		return (-1);

	return (intercept.policy(fd, policynr, code, policy));
}

void
intercept_child_info(pid_t opid, pid_t npid)
{
	struct intercept_pid *ipid, *inpid, tmp;

	/* A child just died on us */
	if (npid == -1) {
		intercept_freepid(opid);
		return;
	}

	tmp.pid = opid;
	ipid = SPLAY_FIND(pidtree, &pids, &tmp);
	if (ipid == NULL)
		return;

	inpid = intercept_getpid(npid);

	inpid->policynr = ipid->policynr;
	if (ipid->name != NULL) {
		inpid->name = strdup(ipid->name);
		if (inpid->name == NULL)
			err(1, "%s:%d: strdup", __func__, __LINE__);
	}

	/* Process tree */
	inpid->ppid = opid;

	/* Copy some information */
	inpid->uid = ipid->uid;
	inpid->gid = ipid->gid;
	strlcpy(inpid->username, ipid->username, sizeof(inpid->username));
	strlcpy(inpid->home, ipid->home, sizeof(inpid->home));

	/* XXX - keeps track of emulation */
	intercept.clonepid(ipid, inpid);
}

void
intercept_ugid(struct intercept_pid *icpid, uid_t uid, gid_t gid)
{
	/* Update current home dir */
	if (icpid->uid != uid) {
		struct passwd *pw;

		if ((pw = getpwuid(uid)) == NULL) {
			snprintf(icpid->username, sizeof(icpid->username),
			    "uid %d", uid);
			strlcpy(icpid->home, "/", sizeof(icpid->home));
		} else {
			strlcpy(icpid->username, pw->pw_name,
			    sizeof(icpid->username));
			strlcpy(icpid->home, pw->pw_dir, sizeof(icpid->home));
		}
	}

	icpid->uid = uid;
	icpid->gid = gid;
}

/*
 * Returns the number of a system call
 */

int
intercept_getsyscallnumber(const char *emulation, const char *name)
{
	int nr = intercept.getsyscallnumber(emulation, name);

	if (nr >= INTERCEPT_MAXSYSCALLNR)
		err(1, "%s: system call number too high: %d", __func__, nr);

	return (nr);
}

/*
 * Checks if the given emulation has a certain system call.
 * This is a very slow function.
 */

int
intercept_isvalidsystemcall(const char *emulation, const char *name)
{
	int res;

	res = intercept.getsyscallnumber(emulation, name);

	return (res != -1);
}

/*
 * Call back when a user has exhausted the number of allowed policies
 * in the kernel.  The kernel returns the policy number of a policy
 * that has been purged.
 */

void
intercept_policy_free(int policynr)
{
	(*intercept_pfreecb)(policynr, intercept_pfreearg);
}

char *
intercept_realpath(const char *path, char *resolved)
{
	struct stat sb;
	int idx = 0, n, nlnk = 0, serrno = errno;
	const char *q;
	char *p, wbuf[2][PATH_MAX];
	size_t len;

	/*
	 * Build real path one by one with paying an attention to .,
	 * .. and symbolic link.
	 */

	/*
	 * `p' is where we'll put a new component with prepending
	 * a delimiter.
	 */
	p = resolved;

	if (*path == 0) {
		*p = 0;
		errno = ENOENT;
		return (NULL);
	}

	/* If relative path, start from current working directory. */
	if (*path != '/') {
		if (getcwd(resolved, PATH_MAX) == NULL) {
			p[0] = '.';
			p[1] = 0;
			return (NULL);
		}
		len = strlen(resolved);
		if (len > 1)
			p += len;
	}

loop:
	/* Skip any slash. */
	while (*path == '/')
		path++;

	if (*path == 0) {
		if (p == resolved)
			*p++ = '/';
		*p = 0;
		return (resolved);
	}

	/* Find the end of this component. */
	q = path;
	do
		q++;
	while (*q != '/' && *q != 0);

	/* Test . or .. */
	if (path[0] == '.') {
		if (q - path == 1) {
			path = q;
			goto loop;
		}
		if (path[1] == '.' && q - path == 2) {
			/* Trim the last component. */
			if (p != resolved)
				while (*--p != '/')
					;
			path = q;
			goto loop;
		}
	}

	/* Append this component. */
	if (p - resolved + 1 + q - path + 1 > PATH_MAX) {
		errno = ENAMETOOLONG;
		if (p == resolved)
			*p++ = '/';
		*p = 0;
		return (NULL);
	}
	p[0] = '/';
	memcpy(&p[1], path, q - path);
	p[1 + q - path] = 0;

	/*
	 * If this component is a symlink, toss it and prepend link
	 * target to unresolved path.
	 */
	if (lstat(resolved, &sb) == -1) {
		/* Allow nonexistent component if this is the last one. */
		while (*q == '/')
			q++;

		if (*q == 0  && errno == ENOENT) {
			errno = serrno;
			return (resolved);
		}

		return (NULL);
	}
	if (S_ISLNK(sb.st_mode)) {
		if (nlnk++ >= SYMLOOP_MAX) {
			errno = ELOOP;
			return (NULL);
		}
		n = readlink(resolved, wbuf[idx], sizeof(wbuf[0]) - 1);
		if (n < 0)
			return (NULL);
		if (n == 0) {
			errno = ENOENT;
			return (NULL);
		}

		/* Append unresolved path to link target and switch to it. */
		if (n + (len = strlen(q)) + 1 > sizeof(wbuf[0])) {
			errno = ENAMETOOLONG;
			return (NULL);
		}
		memcpy(&wbuf[idx][n], q, len + 1);
		path = wbuf[idx];
		idx ^= 1;

		/* If absolute symlink, start from root. */
		if (*path == '/')
			p = resolved;
		goto loop;
	}
	if (*q == '/' && !S_ISDIR(sb.st_mode)) {
		errno = ENOTDIR;
		return (NULL);
	}

	/* Advance both resolved and unresolved path. */
	p += 1 + q - path;
	path = q;
	goto loop;
}
@


1.65
log
@Remove NULL-check before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.64 2015/10/01 02:32:07 guenther Exp $	*/
@


1.64
log
@Eliminate the last of the LINTEDn and PRINTFLIKEn comments.  In one
case, by deleting some useless '& of an array' we also eliminate the need
for the casts which prompted the original lint warnings

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.63 2015/01/16 00:19:12 deraadt Exp $	*/
d405 2
a406 4
	if (pid->name)
		free(pid->name);
	if (pid->newname)
		free(pid->newname);
d787 1
a787 2
		if (icpid->newname)
			free(icpid->newname);
d887 1
a887 2
	if (icpid->name)
		free(icpid->name);
d891 2
a892 4
	if (icpid->newname != NULL) {
		free(icpid->newname);
		icpid->newname = NULL;
	}
@


1.63
log
@move to PATH_MAX, etc; normalize includes for life in the <limits.h> universe
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.62 2014/07/20 01:38:40 guenther Exp $	*/
d1123 1
a1123 3
	memcpy(&p[1], path,
	    /* LINTED We know q > path. */
	    q - path);
@


1.62
log
@Make sure the correct errno is reported by warn* or err* and not
the errno of an intervening cleanup operation like close/unlink/etc.

Diff from Doug Hogan (doug (at) acyclic.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.61 2014/04/24 01:57:06 tedu Exp $	*/
d45 1
d615 1
a615 1
		strlcpy(before, name, MAXPATHLEN);
d641 1
a641 1
	static char cwd[2*MAXPATHLEN];
d678 1
a678 1
		static char rcwd[2*MAXPATHLEN];
d784 1
a784 1
		char *argname, before[MAXPATHLEN];
d1048 1
a1048 1
	char *p, wbuf[2][MAXPATHLEN];
d1070 1
a1070 1
		if (getcwd(resolved, MAXPATHLEN) == NULL) {
d1115 1
a1115 1
	if (p - resolved + 1 + q - path + 1 > MAXPATHLEN) {
d1145 1
a1145 1
		if (nlnk++ >= MAXSYMLINKS) {
@


1.61
log
@calloc is better. from Peter Malone
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.60 2012/12/04 02:24:47 deraadt Exp $	*/
d359 1
d361 1
a361 1
		err(1, "signal");
d364 1
d366 1
a366 1
		err(1, "sigprocmask");
d371 1
d373 1
a373 1
			err(1, "daemon");
d376 1
d378 1
a378 1
			err(1, "intercept_open");
@


1.60
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.59 2012/08/23 00:08:36 guenther Exp $	*/
d200 1
a200 1
		warn("%s:%d: malloc", __func__, __LINE__);
d429 2
a430 2
	if ((tmp = malloc(sizeof(struct intercept_pid))) == NULL)
		err(1, "%s: malloc", __func__);
a431 1
	memset(tmp, 0, sizeof(struct intercept_pid));
@


1.59
log
@Reopen the systrace file in the process that will actually attach to the
target process(es), so that systrace files can be made unsharable.

ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.58 2011/10/18 20:01:28 matthew Exp $	*/
a33 1
#include <sys/param.h>
@


1.58
log
@Bump intercept_get_string() internal buffer to allow strings up to
ARG_MAX long, so that ic_trargv can execute reliably.

Thanks to Olivier Cherrier for reporting and helping to diagnose the
problem.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.57 2011/09/18 23:24:14 matthew Exp $	*/
d269 1
a269 1
intercept_run(int bg, int fd, uid_t uid, gid_t gid,
d288 7
a304 3
		/* Needs to be closed */
		close(fd);

d372 4
@


1.57
log
@Add support for *at(2) system calls to systrace(1).

ok deraadt@@, sthen@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.56 2010/04/20 21:56:52 tedu Exp $	*/
d551 1
a551 1
	static char name[8192];
@


1.56
log
@fix trailing slashes in filenames behavior by *not* fixing it in systrace.
code from netbsd.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.55 2007/06/15 11:43:08 sturm Exp $	*/
d592 6
d606 1
a606 1
	if ((name = normalize_filename(fd, pid, name, userp)) == NULL)
d624 6
d640 1
a640 1
	if (fd != -1 && intercept.setcwd(fd, pid) == -1) {
@


1.55
log
@keep trailing slashes in path normalization, as these might result in
errors otherwise hidden by systrace

noticed by naddy, ok ray on an earlier version of this diff
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.54 2007/05/15 19:42:46 sturm Exp $	*/
d54 1
d673 1
a673 1
		if (realpath(cwd, rcwd) == NULL) {
d698 1
a698 1
			if (realpath(dir, rcwd) == NULL) {
d1017 140
@


1.54
log
@don't assume 4-byte aligned memory when intercepting a string
this should get rid of

    systrace: intercept_get_string: ioctl: Invalid argument

no objections from provos, ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.53 2006/09/19 10:48:41 otto Exp $	*/
d673 1
a673 1
			char *dir, *file;
d675 1
d686 6
a691 1
			if ((file = basename(rcwd)) == NULL)
d705 4
a708 1
			if (strlcat(rcwd, file, sizeof(rcwd)) >= sizeof(rcwd))
@


1.53
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which leads to surprising results. Spotted by/partly
from Paul Stoeber, more to come. ok ho@@ miod@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.52 2006/07/02 12:34:15 sturm Exp $	*/
d563 1
a563 1
			if (errno != EINVAL || stride == 4) {
@


1.52
log
@sync with systrace 1.6d, keeping local changes

tests and feedback by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.51 2006/04/26 20:19:25 sturm Exp $	*/
d707 1
a707 1
				    !(st.st_mode & S_IFDIR))
@


1.51
log
@ARGSUSED and a FALLTHROUGH to please lint

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.50 2006/03/06 10:44:10 djm Exp $	*/
d32 1
d245 1
a245 1
{                                                                              
d553 3
a642 1
	/* Need concatenated path for simplifypath */
d664 1
a664 2
			if (strcmp(base, "..") == 0 ||
			    strcmp(base, "/") == 0)
a871 1

d889 6
d968 15
d988 1
a988 1
intercept_isvalidsystemcall(char *emulation, char *name)
@


1.50
log
@convert permanent privilege revocation to use setresuid/setresgid;
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.49 2004/07/07 07:31:40 marius Exp $	*/
d241 1
@


1.49
log
@fix an issue when scripts are exec'd under systrace where
the argv[0] would be normalized, and hence break scripts
that depend on how they were called.

this fixes an issue in the ports builds.

ok provos@@ deraadt@@; lots of testing during hackathon sturm@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.48 2004/06/24 21:00:10 marius Exp $	*/
d326 2
d330 2
a331 8
			if (setgid(gid) == -1)
				err(1, "setgid");
			if (setegid(gid) == -1)
				err(1, "setegid");
			if (setuid(uid) == -1)
				err(1, "setuid");
			if (seteuid(uid) == -1)
				err(1, "seteuid");
@


1.48
log
@if we have detached after an exec, bail out early, and avoid a double free.

ok provos@@, "works fine" sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.47 2004/06/23 05:16:35 marius Exp $	*/
d588 1
a588 1
intercept_filename(int fd, pid_t pid, void *addr, int userp)
d595 3
d752 1
a752 1
		char *argname;
d761 1
a761 1
		argname = intercept_filename(fd, pid, addr, ICLINK_ALL);
d765 4
@


1.47
log
@a few fixes to systrace

- add an exec message so that whenever a set-uid/gid process
  exec's a new image which we may control, the exec does not
  go by unnoticed.

- take special care to check for P_SUGIDEXEC as well as
  P_SUGID, corresponding to the same changes that were made in
  the ptrace code a while ago

ok niels@@, sturm@@; thanks to naddy for testing
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.46 2004/03/30 15:43:20 sturm Exp $	*/
d834 3
a836 2
		free(icpid->newname);
		icpid->newname = NULL;
d855 5
@


1.46
log
@if a string considered a filename is too long, don't exit but just let
the syscall fail, it might not actually be a filename

fixes pr 3140, ok provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.45 2004/01/30 17:21:16 sturm Exp $	*/
d832 3
a834 5

		/* Commit the name of the new image */
		if (icpid->name)
			free(icpid->name);
		icpid->name = icpid->newname;
a835 5

		if (intercept_newimagecb != NULL)
			(*intercept_newimagecb)(fd, pid, policynr, emulation,
			    icpid->name, intercept_newimagecbarg);

d842 18
@


1.45
log
@The empty filename does not receive normalization.
System calls are supposed to fail on it.

from provos@@, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.44 2003/10/18 19:26:00 jmc Exp $	*/
d642 1
a642 1
			goto error;
d644 1
a644 1
			goto error;
d647 1
a647 1
			goto error;
@


1.44
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.43 2003/10/08 16:32:44 sturm Exp $	*/
d615 7
@


1.43
log
@originally from cb@@openbsd.org, adapted by provos

itojun@@ ok

fix a race condition between path resolution in userland
and the subsequent namei(): inform the kernel portion of
valid filenames and then disallow symlink lookups for
those filenames by means of a hook in namei().
with suggestions from provos@@

also, add (currently unused) seqnr field to struct
systrace_replace, from provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.42 2003/08/04 18:15:11 sturm Exp $	*/
d275 1
a275 1
	/* Block signals so that timeing on signal delivery does not matter */
d645 1
a645 1
		char *base= basename(cwd);
@


1.42
log
@several diffs from Niels as applied to NetBSD

monkey.org/NetBSD commit messages:
- get rid of retarded CWD handling.  CWD is fixed to the CWD of the systrace
that started everything.
- normalize file name function
- normalize CWD for cases where CWD has a symlink in it.  should solve
problems where CWD policies would not match.
- avoid warning due to name collision.
- fixed contrived race condition during attachment; from marius@@monkey.org

itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.41 2003/07/19 11:48:57 sturm Exp $	*/
d61 1
a61 1
	    int, struct intercept_tlq *, void *);
d184 1
a184 1
	struct intercept_tlq *, void *),
d522 1
a522 1
    u_char *addr, size_t len)
d532 1
d540 2
a541 1
intercept_replace(int fd, pid_t pid, struct intercept_replace *repl)
d546 1
a546 1
	return (intercept.replace(fd, pid, repl));
d776 5
a780 1
		if (!ic_abort)
d782 11
a792 2
			    emulation, args, argsize, &sc->tls, sc->cb_arg);
		else
@


1.41
log
@- sync with NetBSD or Niels' tarball where appropriate
- keeps local changes
- fixes a bug in profile feedback optimization and avoids symbol
  conflicts with errno
- new feature: "ask" action

itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.40 2003/06/16 06:36:40 itojun Exp $	*/
d76 2
d245 1
a254 2
	if (getcwd(icpid->cwd, sizeof(icpid->cwd)) == NULL)
		err(1, "getcwd");
d310 3
a587 2
	static char cwd[2*MAXPATHLEN];
	struct intercept_pid *icpid;
a588 1
	int havecwd = 0;
d590 4
a593 2
	name = intercept_get_string(fd, pid, addr);
	if (name == NULL)
d596 19
a614 1
	if (intercept.setcwd(fd, pid) == -1) {
d616 1
a616 1
			goto abort;
a629 7
	if (havecwd) {
		/* Update cwd for process */
		icpid = intercept_getpid(pid);
		if (strlcpy(icpid->cwd, cwd, sizeof(icpid->cwd)) >= sizeof(icpid->cwd))
			errx(1, "cwd too long");
	}

d643 1
d646 4
a650 2
			char *file = basename(cwd);

d652 2
a653 1
			if (strcmp(file, ".") == 0 || strcmp(file, "..") == 0)
d712 1
a712 1
	if (intercept.restcwd(fd) == -1)
a719 4

 abort:
	ic_abort = 1;
	return (NULL);
a889 1
	strlcpy(inpid->cwd, ipid->cwd, sizeof(inpid->cwd));
@


1.40
log
@- limited number of processes per systrace
- escape fixes for special characters
markus, sturm ok.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.39 2003/05/17 03:09:59 sturm Exp $	*/
d616 1
d722 1
a722 1
		
@


1.39
log
@pull in a bugfix from systrace-current to let systrace deal with creating
directories correctly

OK itojun@@, thanks to niels for the help
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.38 2003/02/20 22:03:31 art Exp $	*/
d82 2
d230 9
d916 12
@


1.38
log
@Fix a crash in the systrace found by form@@
One is a kernel fix that changes the lockin and one is a userland fix that
prevents dereferencing a freed pointer.
From provos
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.37 2002/12/09 07:22:53 itojun Exp $	*/
d664 3
a666 4
			if (lstat(rcwd, &st) == -1)
				failed = 1;
			else if (userp != ICLINK_NOLAST &&
			    !(st.st_mode & S_IFDIR))
d668 1
@


1.37
log
@prevent the use of permit for aliases.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.36 2002/11/26 03:48:07 itojun Exp $	*/
d387 11
d760 7
a766 3
	} else
		elevate = icpid->elevate;

@


1.36
log
@performance improvement by omitting a redundant getcwd.
from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.35 2002/11/12 17:04:07 itojun Exp $	*/
d875 15
@


1.35
log
@fix bug in determining execve name.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.34 2002/10/17 05:49:40 itojun Exp $	*/
d565 1
d571 1
a571 1
	if (intercept.getcwd(fd, pid, cwd, sizeof(cwd)) == NULL) {
d574 1
d581 12
a592 4
	/* Update cwd for process */
	icpid = intercept_getpid(pid);
	if (strlcpy(icpid->cwd, cwd, sizeof(icpid->cwd)) >= sizeof(icpid->cwd))
		errx(1, "cwd too long");
d594 1
a594 1
	if (name[0] != '/') {
d676 4
a682 3

 error:
	errx(1, "%s: filename too long", __func__);
@


1.34
log
@little cleanup (intercept_getpid dies within the function on error).
from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.33 2002/10/16 15:01:08 itojun Exp $	*/
d701 1
a701 1
		argname = intercept_filename(fd, pid, addr, 0);
@


1.33
log
@support for privilege elevation.

with privilege elevation no suid or sgid binaries are necessary any
longer.  Applications can be executed completely
unprivileged. Systrace raises the privileges for a single system call
depending on the configured policy.

Idea from discussions with Perry Metzger, Dug Song and Marcus Watts.

from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.32 2002/10/09 03:52:10 itojun Exp $	*/
d331 1
a331 2
	if ((icpid = intercept_getpid(pid)) == NULL)
		err(1, "intercept_getpid");
d438 1
a438 2
	if ((icpid = intercept_getpid(pid)) == NULL)
		return (-1);
d580 1
a580 2
	if ((icpid = intercept_getpid(pid)) == NULL)
		err(1, "intercept_getpid");
@


1.32
log
@predicates are part of the grammar now; in non-root case, predicates are
evaluated only once; in root case, predicates and variable expansion are
dynamic.
from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.31 2002/09/17 04:57:53 itojun Exp $	*/
d235 1
a235 1
intercept_setpid(struct intercept_pid *icpid)
d239 2
a240 2
	icpid->uid = getuid();
	icpid->gid = getgid();
d243 8
a250 4
	if ((pw = getpwuid(icpid->uid)) == NULL)
		err(1, "getpwuid");
	strlcpy(icpid->username, pw->pw_name, sizeof(icpid->username));
	strlcpy(icpid->home, pw->pw_dir, sizeof(icpid->home));
d254 2
a255 1
intercept_run(int bg, int fd, char *path, char *const argv[])
d309 13
d335 5
a339 1
	intercept_setpid(icpid);
d683 2
d690 2
a693 1
		struct intercept_pid *icpid;
a696 3
		if ((icpid = intercept_getpid(pid)) == NULL)
			err(1, "intercept_getpid");

d716 2
d741 3
a743 1
	}
d746 1
a746 1
	intercept.answer(fd, pid, seqnr, action, error, flags);
d776 1
a776 1
	intercept.answer(fd, pid, seqnr, 0, 0, 0);
@


1.31
log
@daemon should not change the directory.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.30 2002/09/06 22:56:21 deraadt Exp $	*/
d48 1
d234 15
d316 2
a317 4
	/* Set uid and gid information */
	icpid->uid = getuid();
	icpid->gid = getgid();
	icpid->flags |= ICFLAGS_UIDKNOWN | ICFLAGS_GIDKNOWN;
d543 1
d559 6
a691 2
	} else if (!strcmp(name, "setuid") || !strcmp(name, "setgid")) {
		flags = ICFLAGS_RESULT;
d746 1
a746 2
	} else if (!strcmp("setuid", name)) {
		register_t reg;
a747 10
		intercept.getarg(0, args, argsize, (void **)&reg);
		icpid->uid = reg;
		icpid->flags |= ICFLAGS_UIDKNOWN;
	} else if (!strcmp("setgid", name)) {
		register_t reg;

		intercept.getarg(0, args, argsize, (void **)&reg);
		icpid->gid = reg;
		icpid->flags |= ICFLAGS_GIDKNOWN;
	}
a810 1
	inpid->flags = ipid->flags;
d813 3
d819 22
@


1.30
log
@standalone ; at top scope is illegal in ansi c
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.29 2002/08/28 03:30:27 itojun Exp $	*/
d316 1
a316 1
		if (daemon(0, 1) == -1) {
@


1.29
log
@fix systrace with chroot.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.28 2002/08/08 00:47:33 provos Exp $	*/
d105 2
a106 2
SPLAY_PROTOTYPE(sctree, intercept_syscall, node, sccompare);
SPLAY_GENERATE(sctree, intercept_syscall, node, sccompare);
d108 2
a109 2
SPLAY_PROTOTYPE(pidtree, intercept_pid, next, pidcompare);
SPLAY_GENERATE(pidtree, intercept_pid, next, pidcompare);
d496 1
a496 1
			&name[off], stride) == -1) {
@


1.28
log
@if getcwd fails and we continue dont restcwd.
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.27 2002/08/07 21:27:15 provos Exp $	*/
a529 1
	int norescwd = 0;
d536 6
a541 6
		if (name[0] != '/') {
			if (errno == EBUSY)
				goto abort;
			err(1, "%s: getcwd", __func__);
		}
		norescwd = 1;
d621 1
a621 1
	if (!norescwd && intercept.restcwd(fd) == -1)
@


1.27
log
@deal better with interrupted system calls
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.26 2002/08/05 19:10:22 jason Exp $	*/
d530 1
d536 1
a536 1
	if (intercept.getcwd(fd, pid, cwd, sizeof(cwd)) == NULL)
d542 2
d622 1
a622 1
	if (intercept.restcwd(fd) == -1)
@


1.26
log
@uid and gid are not guaranteed to be aligned on a register_t sized boundary.
Use a temporary location and then copy the value into place. provos ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.25 2002/08/05 14:49:26 provos Exp $	*/
d112 1
d497 3
d533 1
a533 1
		err(1, "%s: getstring", __func__);
d536 3
a538 1
		if (name[0] != '/')
d540 1
d624 4
d647 1
d659 5
a663 1
		icpid->newname = strdup(intercept_filename(fd, pid, addr, 0));
d677 1
d684 5
a688 2
		action = (*sc->cb)(fd, pid, policynr, name, code, emulation,
		    args, argsize, &sc->tls, sc->cb_arg);
@


1.25
log
@increase buffer size for getstring, useful for execve arguments.
intercept_filename deals better with symlinked last component lookups.
change some translations to use unlinkname.
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.24 2002/08/04 04:15:50 provos Exp $	*/
d706 4
a709 1
		intercept.getarg(0, args, argsize, (void **)&icpid->uid);
d712 4
a715 1
		intercept.getarg(0, args, argsize, (void **)&icpid->gid);
@


1.24
log
@keep track of ppid and allow matching rules to be logged via syslog.
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.23 2002/08/02 02:26:27 provos Exp $	*/
d489 1
a489 1
	static char name[_POSIX2_LINE_MAX];
d549 9
a557 2
		if (userp == ICLINK_NOLAST)
			goto nolast;
d584 3
a586 1
			if (strlcat(rcwd, "/", sizeof(rcwd)) >= sizeof(rcwd))
@


1.23
log
@performance improvement, reduces number of ioctl calls
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.22 2002/08/01 20:50:17 provos Exp $	*/
d761 3
@


1.22
log
@correctly separate execve argv arguments.  increase buffer size for
get_string
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.21 2002/08/01 20:16:45 provos Exp $	*/
d490 1
a490 1
	int off = 0, done = 0;
d492 1
d495 9
a503 3
			&name[off], 4) == -1) {
			warn("%s: ioctl", __func__);
			return (NULL);
d506 1
a506 1
		off += 4;
d511 1
a511 1
	} while (!done && off + 5 < sizeof(name));
@


1.21
log
@the last component in a filename for unlink may be a symlink
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.20 2002/07/30 16:09:48 itojun Exp $	*/
d37 1
d489 1
a489 1
	static char name[MAXPATHLEN];
@


1.20
log
@sometimes no-return syscalls (execve) emit errno < 0.  ignore them.
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.19 2002/07/30 03:16:40 provos Exp $	*/
d537 1
a537 1
	if (userp) {
d540 6
a545 1
		/* If realpath fails then the filename does not exist */
d555 1
d577 1
a577 1
			if (lstat(rcwd, &st) == -1 || !(st.st_mode & S_IFDIR))
d579 3
@


1.19
log
@solve a problem with realpath when the last component of the path is
a directory without S_IXUSR; tested by me and dugsong.
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.18 2002/07/22 04:02:39 provos Exp $	*/
d663 1
a663 1
	if (result)
@


1.18
log
@add seqnr to message from kernel, userland needs to quote correct seqnr.
avoids problems where tsleep has been interrupted by a signal.
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.17 2002/07/19 14:38:57 itojun Exp $	*/
d36 1
d46 1
a536 1
	name = cwd;
d538 2
d541 39
a579 3
		if (realpath(cwd, cwd) == NULL)
			name = "<non-existent filename>";
	} else
d581 2
@


1.17
log
@constify, have missing prototypes, use pedantic compilation options.
niels ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.16 2002/07/16 01:22:48 provos Exp $	*/
d555 2
a556 2
intercept_syscall(int fd, pid_t pid, int policynr, const char *name, int code,
    const char *emulation, void *args, int argsize)
d612 1
a612 1
	intercept.answer(fd, pid, action, error, flags);
d616 1
a616 1
intercept_syscall_result(int fd, pid_t pid, int policynr,
d647 1
a647 1
	intercept.answer(fd, pid, 0, 0, 0);
@


1.16
log
@internal uid/gid tracking.  permit can not detach systrace, useful for
sshd.
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.15 2002/07/12 12:26:29 provos Exp $	*/
d56 2
a57 2
	short (*cb)(int, pid_t, int, char *, int, char *, void *, int,
	    struct intercept_tlq *, void *);
d63 6
d74 1
a74 1
void (*intercept_newimagecb)(int, pid_t, int, char *, char *, void *) = NULL;
d76 1
a76 1
short (*intercept_gencb)(int, pid_t, int, char *, int, char *, void *, int, void *) = NULL;
d123 1
a123 1
intercept_sccb_find(char *emulation, char *name)
d174 1
a174 1
    short (*cb)(int, pid_t, int, char *, int, char *, void *, int,
d206 1
a206 1
intercept_register_gencb(short (*cb)(int, pid_t, int, char *, int, char *, void *, int, void *), void *arg)
d215 1
a215 1
intercept_register_execcb(void (*cb)(int, pid_t, int, char *, char *, void *), void *arg)
d490 1
a490 1
		if (intercept.io(fd, pid, INTERCEPT_READ, addr + off,
d555 2
a556 2
intercept_syscall(int fd, pid_t pid, int policynr, char *name, int code,
    char *emulation, void *args, int argsize)
d617 1
a617 1
    char *name, int code, char *emulation, void *args, int argsize,
d667 2
a668 2
intercept_modifypolicy(int fd, int policynr, char *emulation, char *name,
    short policy)
@


1.15
log
@some clean up.  install argument replacements only if we are going to
permit the system call.  translate some set[e]{g,u}id calls
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.14 2002/07/10 13:46:13 provos Exp $	*/
d226 1
d287 8
d580 2
d616 4
a620 2
		if (result)
			goto out;
a622 1
		icpid = intercept_getpid(pid);
d632 6
d697 5
@


1.14
log
@make it work with chroot
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.13 2002/07/10 07:05:02 provos Exp $	*/
d35 1
@


1.13
log
@do not close fds in daemon.
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.12 2002/07/09 20:46:18 provos Exp $	*/
d506 2
a507 1
		err(1, "%s: getcwd", __func__);
@


1.12
log
@allow systrace to run in the background if possible so that the executed
process gets the terminal correctly and exit status reporting works;
based on a diff from atatat@@atatdot.net from netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.11 2002/07/09 15:22:27 provos Exp $	*/
d296 1
a296 1
		if (daemon(0, 0) == -1) {
@


1.11
log
@support for system call aliasing.  stat/fstat/readlink/access etc... gets
grouped into fsread, unlink/rmdir/mkdir goes to fswrite.  open switches
back between fsread and fswrite depending on oflags parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.10 2002/07/09 13:07:42 dhartmei Exp $	*/
d216 6
d223 1
a223 1
intercept_run(int fd, char *path, char *const argv[])
d225 19
a243 1
	pid_t pid;
d245 5
a249 4
	pid = fork();
	if (pid == -1)
		return (-1);
	if (pid == 0) {
d253 22
a274 2
		/* Stop myself */
		raise(SIGSTOP);
d282 19
a300 1
	sleep(1); /* XXX */
@


1.10
log
@Potential off-by-five, ok provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.9 2002/07/07 23:14:43 provos Exp $	*/
d125 1
a125 1
int
d133 2
a134 1
		return (-1);
d138 2
a139 1
		return (-1);
d143 2
a144 1
		return (-1);
d151 1
a151 1
	return (0);
@


1.9
log
@missing error checks on strdup. from cloder@@acm.org
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.8 2002/06/28 00:26:29 deraadt Exp $	*/
d419 1
a419 1
	} while (!done && off < sizeof(name));
@


1.8
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.7 2002/06/21 15:26:06 provos Exp $	*/
d606 1
a606 1
	if (ipid->name != NULL)
d608 3
@


1.7
log
@rewrite all system call arguments in the permit case.  use realpath
when we still have the root and we of the monitored process.  this
eliminates almost all race coniditions.
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.7 2002/06/21 15:22:04 provos Exp $	*/
d76 1
@


1.6
log
@more careful buffer handling; pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.5 2002/06/10 19:16:26 provos Exp $	*/
d365 35
d429 1
a429 1
intercept_filename(int fd, pid_t pid, void *addr)
d438 3
a441 3
		if (intercept.getcwd(fd, pid, cwd, sizeof(cwd)) == NULL)
			err(1, "%s: getcwd", __func__);

d451 7
a457 1
	simplify_path(cwd);
d459 6
a464 1
	return (cwd);
d496 1
a496 1
		icpid->newname = strdup(intercept_filename(fd, pid, addr));
@


1.5
log
@support attaching to a running process; some code by fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.4 2002/06/04 19:25:54 provos Exp $	*/
d368 2
a369 2
	static char name[1024];
	int off = 0;
d374 1
a374 1
			warn("ioctl");
d381 1
a381 1
			break;
d383 6
a388 1
	} while (off < sizeof(name));
d396 1
a396 1
	static char cwd[1024];
d401 1
a401 1
		err(1, "%s:%d: getstring", __func__, __LINE__);
d405 1
a405 1
			err(1, "%s:%d: getcwd", __func__, __LINE__);
d407 8
a414 4
		strlcat(cwd, "/", sizeof(cwd));
		strlcat(cwd, name, sizeof(cwd));
	} else
		strlcpy(cwd, name, sizeof(cwd));
d419 3
@


1.4
log
@complain about missing device only once. from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.3 2002/06/04 19:15:54 deraadt Exp $	*/
d304 25
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.2 2002/06/04 19:07:04 provos Exp $	*/
d291 3
a293 1
	fd = intercept.open();
@


1.2
log
@__FUNCTION__ -> __func__ from espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept.c,v 1.1 2002/06/04 17:20:04 provos Exp $	*/
d86 1
a86 1
	
d292 2
a293 2
        if (fcntl(fd, F_SETFL, O_NONBLOCK) == -1)
                warn("fcntl(O_NONBLOCK)");
d518 1
a518 1
	
@


1.1
log
@initial import of systrace.  don't touch this, more stuff coming in a while
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d173 1
a173 1
		warnx("%s: %d: unknown syscall: %s-%s", __FUNCTION__, __LINE__,
d179 1
a179 1
		warn("%s:%d: malloc", __FUNCTION__, __LINE__);
d276 1
a276 1
		err(1, "%s: malloc", __FUNCTION__);
d369 1
a369 1
		err(1, "%s:%d: getstring", __FUNCTION__, __LINE__);
d373 1
a373 1
			err(1, "%s:%d: getcwd", __FUNCTION__, __LINE__);
d413 1
a413 1
			err(1, "%s:%d: strdup", __FUNCTION__, __LINE__);
@

