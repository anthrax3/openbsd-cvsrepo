head	1.64;
access;
symbols
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.63.0.4
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.62.0.2
	OPENBSD_5_7_BASE:1.62
	OPENBSD_5_6:1.58.0.10
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.58.0.8
	OPENBSD_5_5_BASE:1.58
	OPENBSD_5_4:1.58.0.4
	OPENBSD_5_4_BASE:1.58
	OPENBSD_5_3:1.58.0.2
	OPENBSD_5_3_BASE:1.58
	OPENBSD_5_2:1.56.0.20
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.18
	OPENBSD_5_0:1.56.0.16
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.56.0.14
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.56.0.12
	OPENBSD_4_8_BASE:1.56
	OPENBSD_4_7:1.56.0.8
	OPENBSD_4_7_BASE:1.56
	OPENBSD_4_6:1.56.0.10
	OPENBSD_4_6_BASE:1.56
	OPENBSD_4_5:1.56.0.6
	OPENBSD_4_5_BASE:1.56
	OPENBSD_4_4:1.56.0.4
	OPENBSD_4_4_BASE:1.56
	OPENBSD_4_3:1.56.0.2
	OPENBSD_4_3_BASE:1.56
	OPENBSD_4_2:1.54.0.6
	OPENBSD_4_2_BASE:1.54
	OPENBSD_4_1:1.54.0.4
	OPENBSD_4_1_BASE:1.54
	OPENBSD_4_0:1.54.0.2
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.50.0.4
	OPENBSD_3_9_BASE:1.50
	OPENBSD_3_8:1.50.0.2
	OPENBSD_3_8_BASE:1.50
	OPENBSD_3_7:1.49.0.6
	OPENBSD_3_7_BASE:1.49
	OPENBSD_3_6:1.49.0.4
	OPENBSD_3_6_BASE:1.49
	OPENBSD_3_5:1.49.0.2
	OPENBSD_3_5_BASE:1.49
	OPENBSD_3_4:1.45.0.2
	OPENBSD_3_4_BASE:1.45
	OPENBSD_3_3:1.42.0.2
	OPENBSD_3_3_BASE:1.42
	OPENBSD_3_2:1.35.0.2
	OPENBSD_3_2_BASE:1.35;
locks; strict;
comment	@ * @;


1.64
date	2016.04.25.19.09.25;	author tedu;	state dead;
branches;
next	1.63;
commitid	Ne4KgWE1uInoydsl;

1.63
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	6b2lLILbgCR1fvia;

1.62
date	2015.01.16.00.19.12;	author deraadt;	state Exp;
branches;
next	1.61;
commitid	9JSDzKTCgxU6o5el;

1.61
date	2014.11.26.18.34.51;	author millert;	state Exp;
branches;
next	1.60;
commitid	9QOFSShUOtA0kQLF;

1.60
date	2014.08.25.07.50.25;	author doug;	state Exp;
branches;
next	1.59;
commitid	vcwz0sp1JH7QzUmA;

1.59
date	2014.08.09.22.44.15;	author guenther;	state Exp;
branches;
next	1.58;
commitid	7w83XngN3LmOTSuy;

1.58
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2012.08.23.00.08.36;	author guenther;	state Exp;
branches;
next	1.56;

1.56
date	2007.11.26.09.28.33;	author martynas;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.02.15.19.08;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2006.07.02.12.34.15;	author sturm;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.02.19.49.05;	author sturm;	state Exp;
branches;
next	1.52;

1.52
date	2006.04.26.20.19.25;	author sturm;	state Exp;
branches;
next	1.51;

1.51
date	2006.03.18.19.03.23;	author robert;	state Exp;
branches;
next	1.50;

1.50
date	2005.05.03.18.03.26;	author sturm;	state Exp;
branches;
next	1.49;

1.49
date	2004.01.23.20.51.18;	author sturm;	state Exp;
branches;
next	1.48;

1.48
date	2004.01.07.21.15.43;	author sturm;	state Exp;
branches;
next	1.47;

1.47
date	2003.10.18.19.26.00;	author jmc;	state Exp;
branches;
next	1.46;

1.46
date	2003.10.08.16.32.44;	author sturm;	state Exp;
branches;
next	1.45;

1.45
date	2003.08.04.18.15.11;	author sturm;	state Exp;
branches;
next	1.44;

1.44
date	2003.07.19.11.48.58;	author sturm;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.16.06.36.40;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2002.12.12.00.39.14;	author avsm;	state Exp;
branches;
next	1.41;

1.41
date	2002.12.11.16.55.28;	author avsm;	state Exp;
branches;
next	1.40;

1.40
date	2002.12.09.07.24.56;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	2002.10.28.17.10.10;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2002.10.16.15.01.08;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2002.10.09.03.52.10;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2002.10.08.03.13.23;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2002.09.23.04.41.02;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2002.09.17.04.57.53;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2002.09.16.04.34.46;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2002.08.05.23.27.53;	author provos;	state Exp;
branches;
next	1.31;

1.31
date	2002.08.04.04.15.50;	author provos;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.30.05.52.50;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.19.14.38.58;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.17.04.50.19;	author provos;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.16.01.22.48;	author provos;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.12.12.26.29;	author provos;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.11.12.57.41;	author provos;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.10.07.05.38;	author provos;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.10.07.05.02;	author provos;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.09.20.46.18;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.09.15.22.27;	author provos;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.22.00.03.35;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.21.15.26.06;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.19.16.31.07;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.18.23.28.29;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.12.22.14.51;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.11.05.21.17;	author jsyn;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.10.19.16.26;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.05.20.52.47;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.05.20.01.22;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.05.16.51.08;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.05.15.59.52;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.04.22.45.25;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.04.20.13.19;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.04.19.58.46;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.04.19.50.12;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.04.19.43.35;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.04.19.25.54;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.04.19.15.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.04.19.07.04;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.04.17.20.04;	author provos;	state Exp;
branches;
next	;


desc
@@


1.64
log
@boom goes the dynamite
@
text
@/*	$OpenBSD: systrace.c,v 1.63 2015/04/18 18:28:37 deraadt Exp $	*/
/*
 * Copyright 2002 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <limits.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <stdarg.h>
#include <fcntl.h>
#include <signal.h>
#include <syslog.h>
#include <string.h>
#include <err.h>
#include <errno.h>
#include <grp.h>
#include <pwd.h>
#include <event.h>

#include "intercept.h"
#include "systrace.h"
#include "util.h"

#define CRADLE_SERVER "cradle_server"
#define CRADLE_UI     "cradle_ui"

#define VERSION "1.6d (OpenBSD)"

pid_t trpid;
int trfd;
int connected = 0;		/* Connected to GUI */
int inherit = 0;		/* Inherit policy to childs */
int automatic = 0;		/* Do not run interactively */
int allow = 0;			/* Allow all and generate */
int userpolicy = 1;		/* Permit user defined policies */
int noalias = 0;		/* Do not do system call aliasing */
int iamroot = 0;		/* Set if we are running as root */
int cradle = 0;			/* Set if we are running in cradle mode */
int logtofile = 0;		/* Log to file instead of syslog */
FILE *logfile;			/* default logfile to send to if enabled */
char cwd[PATH_MAX];		/* Current working directory */
char home[PATH_MAX];		/* Home directory of user */
char username[LOGIN_NAME_MAX];	/* Username: predicate match and expansion */
char *guipath = _PATH_XSYSTRACE; /* Path to GUI executable */
char dirpath[PATH_MAX];

static struct event ev_read;
static struct event ev_timeout;

static void child_handler(int);
static void log_msg(int, const char *, ...);
static void systrace_read(int, short, void *);
static void systrace_timeout(int, short, void *);
static void usage(void);

void
systrace_parameters(void)
{
	struct passwd *pw;
	char *normcwd;
	uid_t uid = getuid();

	iamroot = getuid() == 0;

	/* Find out current username. */
	if ((pw = getpwuid(uid)) == NULL) {
		snprintf(username, sizeof(username), "uid %u", uid);
	} else {
		strlcpy(username, pw->pw_name, sizeof(username));
		strlcpy(home, pw->pw_dir, sizeof(home));
	}

	/* Determine current working directory for filtering */
	if (getcwd(cwd, sizeof(cwd)) == NULL)
		err(1, "getcwd");
	if ((normcwd = normalize_filename(-1, 0, cwd, ICLINK_ALL)) == NULL)
		errx(1, "normalize_filename");
	if (strlcpy(cwd, normcwd, sizeof(cwd)) >= sizeof(cwd))
		errx(1, "cwd too long");
}

/*
 * Generate human readable output and setup replacements if available.
 */

void
make_output(char *output, size_t outlen, const char *binname,
    pid_t pid, pid_t ppid,
    int policynr, const char *policy, int nfilters, const char *emulation,
    const char *name, int code, struct intercept_tlq *tls,
    struct intercept_replace *repl)
{
	struct intercept_translate *tl;
	char *p, *line;
	int size;

	snprintf(output, outlen,
	    "%s, pid: %d(%d)[%d], policy: %s, filters: %d, syscall: %s-%s(%d)",
	    binname, pid, policynr, ppid, policy, nfilters,
	    emulation, name, code);

	p = output + strlen(output);
	size = outlen - strlen(output);

	if (tls == NULL)
		return;

	TAILQ_FOREACH(tl, tls, next) {
		if (!tl->trans_valid)
			continue;
		line = intercept_translate_print(tl);
		if (line == NULL)
			continue;

		snprintf(p, size, ", %s: %s", tl->name, strescape(line));
		p = output + strlen(output);
		size = outlen - strlen(output);

		if (repl != NULL && tl->trans_size)
			intercept_replace_add(repl, tl->off,
			    tl->trans_data, tl->trans_size,
			    tl->trans_flags);
	}
}

short
trans_cb(int fd, pid_t pid, int policynr,
    const char *name, int code, const char *emulation,
    void *args, int argsize,
    struct intercept_replace *repl,
    struct intercept_tlq *tls, void *cbarg)
{
	short action, future;
	struct policy *policy;
	struct intercept_pid *ipid;
	struct intercept_tlq alitls;
	struct intercept_translate alitl[SYSTRACE_MAXALIAS];
	struct systrace_alias *alias = NULL;
	struct filterq *pflq = NULL;
	const char *binname = NULL;
	char output[_POSIX2_LINE_MAX];
	pid_t ppid;
	int done = 0, dolog = 0;

	action = ICPOLICY_PERMIT;

	if (policynr == -1)
		goto out;

	if ((policy = systrace_findpolnr(policynr)) == NULL)
		errx(1, "%s:%d: find %d", __func__, __LINE__,
		    policynr);

	ipid = intercept_getpid(pid);
	ipid->uflags = 0;
	binname = ipid->name != NULL ? ipid->name : policy->name;
	ppid = ipid->ppid;

	/* Required to set up replacements */
	do {
		make_output(output, sizeof(output), binname, pid, ppid,
		    policynr, policy->name, policy->nfilters,
		    emulation, name, code, tls, repl);

		/* Fast-path checking */
		if ((action = policy->kerneltable[code]) != ICPOLICY_ASK)
			goto out;

		pflq = systrace_policyflq(policy, emulation, name);
		if (pflq == NULL)
			errx(1, "%s:%d: no filter queue", __func__, __LINE__);

		action = filter_evaluate(tls, pflq, ipid);
		if (action != ICPOLICY_ASK)
			goto done;

		/* Do aliasing here */
		if (!noalias)
			alias = systrace_find_alias(emulation, name);
		if (alias != NULL) {
			int i;

			/* Set up variables for further filter actions */
			tls = &alitls;
			emulation = alias->aemul;
			name = alias->aname;

			/* Create an aliased list for filter_evaluate */
			TAILQ_INIT(tls);
			for (i = 0; i < alias->nargs; i++) {
				memcpy(&alitl[i], alias->arguments[i], 
				    sizeof(struct intercept_translate));
				TAILQ_INSERT_TAIL(tls, &alitl[i], next);
			}

			if ((pflq = systrace_policyflq(policy,
			    alias->aemul, alias->aname)) == NULL)
				errx(1, "%s:%d: no filter queue",
				    __func__, __LINE__);

			action = filter_evaluate(tls, pflq, ipid);
			if (action != ICPOLICY_ASK)
				goto done;

			make_output(output, sizeof(output), binname, pid, ppid,
			    policynr, policy->name, policy->nfilters,
			    alias->aemul, alias->aname, code, tls, NULL);
		}

		/*
		 * At this point, we have to ask the user, but we may check
		 * if the policy has been updated in the meanwhile.
		 */
		if (systrace_updatepolicy(fd, policy) == -1)
			done = 1;
	} while (!done);

	if (policy->flags & POLICY_UNSUPERVISED) {
		action = ICPOLICY_NEVER;
		dolog = 1;
		goto out;
	}

	action = filter_ask(fd, tls, pflq, policynr, emulation, name,
	    output, &future, ipid);
	if (future != ICPOLICY_ASK)
		filter_modifypolicy(fd, policynr, emulation, name, future);

	if (policy->flags & POLICY_DETACHED) {
		if (intercept_detach(fd, pid) == -1)
			err(1, "intercept_detach");
		return (action);
	} else if (action == ICPOLICY_KILL) {
		kill(pid, SIGKILL);
		return (ICPOLICY_NEVER);
	}
 done:
	if (ipid->uflags & SYSCALL_LOG)
		dolog = 1;

 out:
	if (dolog)
		log_msg(LOG_WARNING, "%s user: %s, prog: %s",
		    action < ICPOLICY_NEVER ? "permit" : "deny",
		    ipid->username, output);

 	/* Argument replacement in intercept might still fail */

	return (action);
}

short
gen_cb(int fd, pid_t pid, int policynr, const char *name, int code,
    const char *emulation, void *args, int argsize, void *cbarg)
{
	char output[_POSIX2_LINE_MAX];
	struct policy *policy;
	struct intercept_pid *ipid;
	struct filterq *pflq = NULL;
	short action = ICPOLICY_PERMIT;
	short future;
	int off, done = 0, dolog = 0;
	size_t len;

	if (policynr == -1)
		goto out;

	if ((policy = systrace_findpolnr(policynr)) == NULL)
		errx(1, "%s:%d: find %d", __func__, __LINE__,
		    policynr);

	ipid = intercept_getpid(pid);
	ipid->uflags = 0;

	make_output(output, sizeof(output),
	    ipid->name != NULL ? ipid->name : policy->name,
	    pid, ipid->ppid, policynr,
	    policy->name, policy->nfilters, emulation, name, code,
	    NULL, NULL);

	off = strlen(output);
	len = sizeof(output) - off;
	if (len > 0)
		snprintf(output + off, len, ", args: %d", argsize);

	if ((pflq = systrace_policyflq(policy, emulation, name)) == NULL)
		errx(1, "%s:%d: no filter queue", __func__, __LINE__);

	do {
		/* Fast-path checking */
		if ((action = policy->kerneltable[code]) != ICPOLICY_ASK)
			goto out;

		action = filter_evaluate(NULL, pflq, ipid);

		if (action != ICPOLICY_ASK)
			goto haveresult;
		/*
		 * At this point, we have to ask the user, but we may check
		 * if the policy has been updated in the meanwhile.
		 */
		if (systrace_updatepolicy(fd, policy) == -1)
			done = 1;
	} while (!done);

	if (policy->flags & POLICY_UNSUPERVISED) {
		action = ICPOLICY_NEVER;
		dolog = 1;
		goto haveresult;
	}

	action = filter_ask(fd, NULL, pflq, policynr, emulation, name,
	    output, &future, ipid);
	if (future != ICPOLICY_ASK)
		systrace_modifypolicy(fd, policynr, name, future);

	if (policy->flags & POLICY_DETACHED) {
		if (intercept_detach(fd, pid) == -1)
			err(1, "intercept_detach");
	} else if (action == ICPOLICY_KILL) {
		kill(pid, SIGKILL);
		return (ICPOLICY_NEVER);
	}

 haveresult:
	if (ipid->uflags & SYSCALL_LOG)
		dolog = 1;
	if (dolog)
		log_msg(LOG_WARNING, "%s user: %s, prog: %s",
		    action < ICPOLICY_NEVER ? "permit" : "deny",
		    ipid->username, output);
 out:
	return (action);
}

void
execres_cb(int fd, pid_t pid, int policynr, const char *emulation,
    const char *name, void *arg)
{
	struct policy *policy;

	if (policynr != -1) {
		struct intercept_pid *ipid;

		ipid = intercept_getpid(pid);
		if (ipid->uflags & PROCESS_DETACH) {
			if (intercept_detach(fd, pid) == -1)
				err(1, "%s: intercept_detach", __func__);
			return;
		}
		if (inherit)
			return;

		if (ipid->uflags & PROCESS_INHERIT_POLICY)
			return;
	}
	if ((policy = systrace_newpolicy(emulation, name)) == NULL)
		goto error;

	/* See if this policies runs without interactive feedback */
	if (automatic)
		policy->flags |= POLICY_UNSUPERVISED;

	policynr = policy->policynr;

	/* Try to find existing policy in file system */
	if (policynr == -1 && TAILQ_FIRST(&policy->prefilters) == NULL)
		systrace_addpolicy(name);

	if (policy->flags & POLICY_DETACHED) {
		if (intercept_detach(fd, pid) == -1)
			err(1, "intercept_detach");
		return;
	}

	if (policynr == -1) {
		policynr = systrace_newpolicynr(fd, policy);
		if (policynr == -1)
			goto error;
	}

	if (intercept_assignpolicy(fd, pid, policynr) == -1)
		goto error;

	if (TAILQ_FIRST(&policy->prefilters) != NULL)
		filter_prepolicy(fd, policy);

	return;

 error:
	kill(pid, SIGKILL);
	fprintf(stderr, "Terminating %d: %s\n", pid, name);
}

void
policyfree_cb(int policynr, void *arg)
{
	struct policy *policy;

	if ((policy = systrace_findpolnr(policynr)) == NULL)
		errx(1, "%s:%d: find %d", __func__, __LINE__,
		    policynr);

	systrace_freepolicy(policy);
}

/* ARGSUSED */
static void
child_handler(int sig)
{
	int s = errno, status;

	if (signal(SIGCHLD, child_handler) == SIG_ERR) {
		close(trfd);
	}

	while (wait4(-1, &status, WNOHANG, NULL) > 0)
		;

	errno = s;
}

static void
log_msg(int priority, const char *fmt, ...)
{
	char buf[_POSIX2_LINE_MAX];
	extern char *__progname;
	va_list ap;

	va_start(ap, fmt);

	if (logtofile) {
		vsnprintf(buf, sizeof(buf), fmt, ap);
		fprintf(logfile, "%s: %s\n", __progname, buf);
	} else
		vsyslog(priority, fmt, ap);

	va_end(ap);
}

static void
usage(void)
{
	fprintf(stderr,
	    "Usage: systrace [-AaCeitUuV] [-c user:group] [-d policydir] [-E logfile]\n"
	    "\t [-f file] [-g gui] [-p pid] command ...\n");
	exit(1);
}

int
requestor_start(char *path, int docradle)
{
	char *argv[3];
	int pair[2];
	pid_t pid;

	argv[0] = path;
	argv[1] = docradle ? "-C" : NULL;
	argv[2] = NULL;

	if (!docradle && socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1)
		err(1, "socketpair");

	pid = fork();
	if (pid == -1)
		err(1, "fork");
	if (pid == 0) {
		if (!docradle) {
			close(pair[0]);
			if (dup2(pair[1], fileno(stdin)) == -1)
				err(1, "dup2");
			if (dup2(pair[1], fileno(stdout)) == -1)
				err(1, "dup2");
			setvbuf(stdout, NULL, _IOLBF, 0);

			close(pair[1]);
		}

		execvp(path, argv);

		err(1, "execvp: %s", path);

	}

	if (!docradle) {
		close(pair[1]);
		if (dup2(pair[0], fileno(stdin)) == -1)
			err(1, "dup2");

		if (dup2(pair[0], fileno(stdout)) == -1)
			err(1, "dup2");

		close(pair[0]);

		setvbuf(stdout, NULL, _IOLBF, 0);

		connected = 1;
	}

	return (0);
}


static void
cradle_setup(char *pathtogui)
{
	struct stat sb;
	char cradlepath[PATH_MAX], cradleuipath[PATH_MAX];

	snprintf(dirpath, sizeof(dirpath), "/tmp/systrace-%d", getuid());

	if (stat(dirpath, &sb) == -1) {
		if (errno != ENOENT)
			err(1, "stat()");
		if (mkdir(dirpath, S_IRUSR | S_IWUSR | S_IXUSR) == -1)
			err(1, "mkdir()");
	} else {
		if (sb.st_uid != getuid())
			errx(1, "Wrong owner on directory %s", dirpath);
		if (sb.st_mode != (S_IFDIR | S_IRUSR | S_IWUSR | S_IXUSR))
			errx(1, "Wrong permissions on directory %s", dirpath);
	}

	strlcpy(cradlepath, dirpath, sizeof (cradlepath));
	strlcat(cradlepath, "/" CRADLE_SERVER, sizeof (cradlepath));

	strlcpy(cradleuipath, dirpath, sizeof (cradleuipath));
	strlcat(cradleuipath, "/" CRADLE_UI, sizeof (cradleuipath));

	cradle_start(cradlepath, cradleuipath, pathtogui);
}

static int
get_uid_gid(const char *argument, uid_t *uid, gid_t *gid)
{
	struct group *gp;
	struct passwd *pw;
	unsigned long ulval;
	char uid_gid_str[128];
	char *endp, *g, *u;

	strlcpy(uid_gid_str, argument, sizeof(uid_gid_str));
	g = uid_gid_str;
	u = strsep(&g, ":");

	if ((pw = getpwnam(u)) != NULL) {
		explicit_bzero(pw->pw_passwd, strlen(pw->pw_passwd));
		*uid = pw->pw_uid;
		*gid = pw->pw_gid;
		/* Ok if group not specified. */
		if (g == NULL)
			return (0);
	} else {
		errno = 0;
		ulval = strtoul(u, &endp, 10);
		if (u[0] == '\0' || *endp != '\0')
			errx(1, "no such user '%s'", u);
		if (errno == ERANGE && ulval == ULONG_MAX)
			errx(1, "invalid uid %s", u);
		*uid = (uid_t)ulval;
	}

	if (g == NULL)
		return (-1);

	if ((gp = getgrnam(g)) != NULL)
		*gid = gp->gr_gid;
	else {
		errno = 0;
		ulval = strtoul(g, &endp, 10);
		if (g[0] == '\0' || *endp != '\0')
			errx(1, "no such group '%s'", g);
		if (errno == ERANGE && ulval == ULONG_MAX)
			errx(1, "invalid gid %s", g);
		*gid = (gid_t)ulval;
	}

	return (0);
}

static void
systrace_timeout(int fd, short what, void *arg)
{
	struct timeval tv;

	/* Reschedule timeout */
	timerclear(&tv);
	tv.tv_sec = SYSTRACE_UPDATETIME;
	evtimer_add(&ev_timeout, &tv);

	systrace_updatepolicies(trfd);
	if (userpolicy)
		systrace_dumppolicies(trfd);
}

/*
 * Read from the kernel if something happened.
 */

static void
systrace_read(int fd, short what, void *arg)
{
	intercept_read(fd);

	if (!intercept_existpids()) {
		event_del(&ev_read);
		event_del(&ev_timeout);
	}
}

int
main(int argc, char **argv)
{
	int i, c;
	char **args;
	char *filename = NULL;
	char *policypath = NULL;
	const char *errstr;
	struct timeval tv;
	pid_t pidattach = 0;
	int usex11 = 1;
	int background;
	int setcredentials = 0;
	uid_t cr_uid;
	gid_t cr_gid;

	while ((c = getopt(argc, argv, "Vc:aAeE:ituUCd:g:f:p:")) != -1) {
		switch (c) {
		case 'V':
			fprintf(stderr, "%s V%s\n", argv[0], VERSION);
			exit(0);
		case 'c':
			setcredentials = 1;
			if (get_uid_gid(optarg, &cr_uid, &cr_gid) == -1)
				usage();
			break;
		case 'a':
			if (allow)
				usage();
			automatic = 1;
			break;
		case 'd':
			policypath = optarg;
			break;
		case 'e':
			logtofile = 1;
			logfile = stderr;
			break;
		case 'E':
			logtofile = 1;
			logfile = fopen(optarg, "a");
			if (logfile == NULL)
				err(1, "Cannot open \"%s\" for writing",
				    optarg);
			break;
		case 'A':
			if (automatic)
				usage();
			allow = 1;
			break;
		case 'u':
			noalias = 1;
			break;
		case 'i':
			inherit = 1;
			break;
		case 'g':
			guipath = optarg;
			break;
		case 'C':
			cradle = 1;
			break;
		case 'f':
			filename = optarg;
			break;
		case 'p':
			if (setcredentials)
				usage();
			pidattach = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr) {
				warnx("bad pid: %s", optarg);
				usage();
			}
			break;
		case 't':
			usex11 = 0;
			break;
		case 'U':
			userpolicy = 0;
			break;
		default:
			usage();
			break;
		}
	}
	argc -= optind;
	argv += optind;

	if (argc == 0 || (pidattach && *argv[0] != '/'))
		usage();

	systrace_parameters();

	if (setcredentials && !iamroot) {
		fprintf(stderr, "Need to be root to change credentials.\n");
		usage();
	}

	/* Initialize libevent but without kqueue because of systrace fd */
	setenv("EVENT_NOKQUEUE", "yes", 0);
	event_init();

	/* Local initialization */
	systrace_initalias();
	systrace_initpolicy(filename, policypath);
	systrace_initcb();

	if ((trfd = intercept_open()) == -1)
		exit(1);

	/* See if we can run the systrace process in the background */
	background = usex11 || automatic || allow;

	if (pidattach == 0) {
		/* Run a command and attach to it */
		args = reallocarray(NULL, argc + 1, sizeof(char *));
		if (args == NULL)
			err(1, "malloc");

		for (i = 0; i < argc; i++)
			args[i] = argv[i];
		args[i] = NULL;

		if (setcredentials)
			trpid = intercept_run(background, &trfd,
			    cr_uid, cr_gid, args[0], args);
		else
			trpid = intercept_run(background, &trfd, 0, 0,
			    args[0], args);
		if (trpid == -1)
			err(1, "fork");

		if (intercept_attach(trfd, trpid) == -1)
			err(1, "attach");

		if (kill(trpid, SIGUSR1) == -1)
			err(1, "kill");
	} else {
		/* Attach to a running command */
		if (intercept_attachpid(trfd, pidattach, argv[0]) == -1)
			err(1, "attachpid");

		if (background) {
			if (daemon(1, 1) == -1)
				err(1, "daemon");
		}
	}

	if (signal(SIGCHLD, child_handler) == SIG_ERR)
		err(1, "signal");

	if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
		err(1, "signal");

	/* Start the policy GUI or cradle if necessary */
	if (usex11 && (!automatic && !allow)) {
		if (cradle)
			cradle_setup(guipath);
		else
			requestor_start(guipath, 0);

	}

	/* Register read events */
	event_set(&ev_read, trfd, EV_READ|EV_PERSIST, systrace_read, NULL);
	event_add(&ev_read, NULL);

	if (userpolicy || automatic) {
		evtimer_set(&ev_timeout, systrace_timeout, &ev_timeout);
		timerclear(&tv);
		tv.tv_sec = SYSTRACE_UPDATETIME;
		evtimer_add(&ev_timeout, &tv);
	}

	/* Wait for events */
	event_dispatch();

	if (userpolicy)
		systrace_dumppolicies(trfd);

	close(trfd);

	exit(0);
}
@


1.63
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.62 2015/01/16 00:19:12 deraadt Exp $	*/
@


1.62
log
@move to PATH_MAX, etc; normalize includes for life in the <limits.h> universe
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.61 2014/11/26 18:34:51 millert Exp $	*/
d650 1
d711 2
a712 1
			if ((pidattach = atoi(optarg)) == 0) {
@


1.61
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.60 2014/08/25 07:50:25 doug Exp $	*/
d73 2
a74 2
char cwd[MAXPATHLEN];		/* Current working directory */
char home[MAXPATHLEN];		/* Home directory of user */
d77 1
a77 1
char dirpath[MAXPATHLEN];
d540 1
a540 1
	char cradlepath[MAXPATHLEN], cradleuipath[MAXPATHLEN];
@


1.60
log
@Delete secret or secret-derived data with explicit_bzero.

concept ok deraadt@@
diff looks ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.59 2014/08/09 22:44:15 guenther Exp $	*/
d506 1
a506 1
			setlinebuf(stdout);
d527 1
a527 1
		setlinebuf(stdout);
@


1.59
log
@Switch from calloc() to reallocarray() where the zeroing isn't needed
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.58 2012/12/04 02:24:47 deraadt Exp $	*/
d579 1
a579 1
		memset(pw->pw_passwd, 0, strlen(pw->pw_passwd));
@


1.58
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.57 2012/08/23 00:08:36 guenther Exp $	*/
d756 2
a757 1
		if ((args = calloc(argc + 1, sizeof(char *))) == NULL)
@


1.57
log
@Reopen the systrace file in the process that will actually attach to the
target process(es), so that systrace files can be made unsharable.

ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.56 2007/11/26 09:28:33 martynas Exp $	*/
a32 1
#include <sys/param.h>
@


1.56
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.55 2007/09/02 15:19:08 deraadt Exp $	*/
d765 1
a765 1
			trpid = intercept_run(background, trfd,
d768 1
a768 1
			trpid = intercept_run(background, trfd, 0, 0,
@


1.55
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.54 2006/07/02 12:34:15 sturm Exp $	*/
d740 1
a740 1
	/* Initalize libevent but without kqueue because of systrace fd */
@


1.54
log
@sync with systrace 1.6d, keeping local changes

tests and feedback by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.53 2006/05/02 19:49:05 sturm Exp $	*/
d757 1
a757 1
		if ((args = malloc((argc + 1) * sizeof(char *))) == NULL)
@


1.53
log
@some type cleanup

with feedback from kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.52 2006/04/26 20:19:25 sturm Exp $	*/
d51 1
d60 2
d72 2
a73 1
int logstderr = 0;		/* Log to STDERR instead of syslog */
d76 1
a76 1
char username[MAXLOGNAME];	/* Username: predicate match and expansion */
d80 3
d85 2
d176 1
a176 1
	int dolog = 0;
d193 4
a196 3
	make_output(output, sizeof(output), binname, pid, ppid, policynr,
	    policy->name, policy->nfilters, emulation, name, code,
	    tls, repl);
d198 3
a200 2
	if ((pflq = systrace_policyflq(policy, emulation, name)) == NULL)
		errx(1, "%s:%d: no filter queue", __func__, __LINE__);
d202 2
a203 25
	action = filter_evaluate(tls, pflq, ipid);
	if (action != ICPOLICY_ASK)
		goto done;

	/* Do aliasing here */
	if (!noalias)
		alias = systrace_find_alias(emulation, name);
	if (alias != NULL) {
		int i;

		/* Set up variables for further filter actions */
		tls = &alitls;
		emulation = alias->aemul;
		name = alias->aname;

		/* Create an aliased list for filter_evaluate */
		TAILQ_INIT(tls);
		for (i = 0; i < alias->nargs; i++) {
			memcpy(&alitl[i], alias->arguments[i], 
			    sizeof(struct intercept_translate));
			TAILQ_INSERT_TAIL(tls, &alitl[i], next);
		}

		if ((pflq = systrace_policyflq(policy,
			 alias->aemul, alias->aname)) == NULL)
d210 40
a249 4
		make_output(output, sizeof(output), binname, pid, ppid,
		    policynr, policy->name, policy->nfilters,
		    alias->aemul, alias->aname, code, tls, NULL);
	}
d295 1
a295 1
	int off, dolog = 0;
d322 4
a325 1
	action = filter_evaluate(NULL, pflq, ipid);
d327 1
a327 2
	if (ipid->uflags & SYSCALL_LOG)
		dolog = 1;
d329 9
a337 2
	if (action != ICPOLICY_ASK)
		goto out;
d342 1
a342 1
		goto out;
d357 4
a360 1
 out:
d365 1
a365 1

d465 1
a465 1
	if (logstderr) {
d467 1
a467 1
		fprintf(stderr, "%s: %s\n", __progname, buf);
d478 2
a479 2
	    "Usage: systrace [-AaCeitUu] [-c uid:gid] [-d policydir] [-f file]\n"
	    "\t [-g gui] [-p pid] command ...\n");
d614 30
d651 1
a651 1
	struct timeval tv, tv_wait = {60, 0};
d653 1
a653 1
	int usex11 = 1, count;
d659 1
a659 1
	while ((c = getopt(argc, argv, "c:aAeituUCd:g:f:p:")) != -1) {
d661 3
d678 9
a686 1
			logstderr = 1;
d740 4
d792 4
a795 1
	/* Start the policy gui or cradle if necessary */
d804 9
a812 24
	/* Loop on requests */
	count = 0;
	while (intercept_read(trfd) != -1) {
		if (!intercept_existpids())
			break;
		if (userpolicy) {
			/* Periodically save modified policies */
			if (count == 0) {
				/* Set new wait time */
				gettimeofday(&tv, NULL);
				timeradd(&tv, &tv_wait, &tv);
			} else if (count > 10) {
				struct timeval now;
				gettimeofday(&now, NULL);

				count = 0;
				if (timercmp(&now, &tv, >)) {
					/* Dump policy and cause new time */
					systrace_dumppolicy();
					continue;
				}
			}
			count++;
		}
d815 3
d819 1
a819 1
		systrace_dumppolicy();
@


1.52
log
@ARGSUSED and a FALLTHROUGH to please lint

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.51 2006/03/18 19:03:23 robert Exp $	*/
d271 2
a272 1
	int len, off, dolog = 0;
@


1.51
log
@fix problems found by Coverity via NetBSD:
- systrace.c: Don't try to dereference pw when it's NULL.
Coverity CID 900
- parse.y: free allocated space on failure Coverity CID 1661
- policy.c: Change a return to "goto out" so that fclose will be called.
Coverity CID 1881

ok sturm@@, ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.50 2005/05/03 18:03:26 sturm Exp $	*/
d403 1
@


1.50
log
@some snprintf() -> strlcpy to improve readibility (and speed?)

from rohee@@, ok millert@@ before 3.7
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.49 2004/01/23 20:51:18 sturm Exp $	*/
d90 1
a90 1
	if ((pw = getpwuid(uid)) == NULL)
d92 1
a92 1
	else
d94 2
a95 2

	strlcpy(home, pw->pw_dir, sizeof(home));
@


1.49
log
@support for cradle mode by marius at monkey.org; cradle mode allows the
systrace UI to be attached and re-attached, it also multiplexes across
systrace process so that one UI can function as central notification

from provos@@, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.48 2004/01/07 21:15:43 sturm Exp $	*/
d93 1
a93 1
		snprintf(username, sizeof(username), "%s", pw->pw_name);
@


1.48
log
@new command line option allows logging to stderr instead of syslog

"looks good" provos@@, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.47 2003/10/18 19:26:00 jmc Exp $	*/
d37 1
d56 3
d68 1
d73 2
a78 1
static int requestor_start(char *);
d440 1
a440 1
	    "Usage: systrace [-AaitUu] [-c uid:gid] [-d policydir] [-f file]\n"
d445 2
a446 2
static int
requestor_start(char *path)
d448 1
a448 1
	char *argv[2];
d453 2
a454 1
	argv[1] = NULL;
d456 1
a456 1
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1)
d463 7
a469 6
		close(pair[0]);
		if (dup2(pair[1], fileno(stdin)) == -1)
			err(1, "dup2");
		if (dup2(pair[1], fileno(stdout)) == -1)
			err(1, "dup2");
		setlinebuf(stdout);
d471 2
a472 1
		close(pair[1]);
d477 1
d480 4
a483 3
	close(pair[1]);
	if (dup2(pair[0], fileno(stdin)) == -1)
		err(1, "dup2");
d485 2
a486 2
	if (dup2(pair[0], fileno(stdout)) == -1)
		err(1, "dup2");
d488 1
a488 1
	close(pair[0]);
d490 1
a490 1
	setlinebuf(stdout);
d492 2
a493 1
	connected = 1;
d498 30
a582 1
	char *guipath = _PATH_XSYSTRACE;
d591 1
a591 1
	while ((c = getopt(argc, argv, "c:aAeituUd:g:f:p:")) != -1) {
d623 3
d709 8
a716 3
	/* Start the policy gui if necessary */
	if (usex11 && !automatic && !allow)
		requestor_start(guipath);
@


1.47
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.46 2003/10/08 16:32:44 sturm Exp $	*/
d41 1
d64 1
d70 1
d246 1
a246 1
		syslog(LOG_WARNING, "%s user: %s, prog: %s",
d319 1
a319 1
		syslog(LOG_WARNING, "%s user: %s, prog: %s",
d413 18
d550 1
a550 1
	while ((c = getopt(argc, argv, "c:aAituUd:g:f:p:")) != -1) {
d564 3
@


1.46
log
@originally from cb@@openbsd.org, adapted by provos

itojun@@ ok

fix a race condition between path resolution in userland
and the subsequent namei(): inform the kernel portion of
valid filenames and then disallow symlink lookups for
those filenames by means of a hook in namei().
with suggestions from provos@@

also, add (currently unused) seqnr field to struct
systrace_replace, from provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.45 2003/08/04 18:15:11 sturm Exp $	*/
d593 1
a593 1
	/* Local initalization */
@


1.45
log
@several diffs from Niels as applied to NetBSD

monkey.org/NetBSD commit messages:
- get rid of retarded CWD handling.  CWD is fixed to the CWD of the systrace
that started everything.
- normalize file name function
- normalize CWD for cases where CWD has a symlink in it.  should solve
problems where CWD policies would not match.
- avoid warning due to name collision.
- fixed contrived race condition during attachment; from marius@@monkey.org

itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.44 2003/07/19 11:48:58 sturm Exp $	*/
a119 3
	if (repl != NULL)
		intercept_replace_init(repl);

d136 2
a137 1
			    tl->trans_data, tl->trans_size);
d144 3
a146 1
    void *args, int argsize, struct intercept_tlq *tls, void *cbarg)
a150 1
	struct intercept_replace repl;
d177 1
a177 1
	    tls, &repl);
d184 1
a184 1
		goto replace;
d211 1
a211 1
			goto replace;
d237 1
a237 1
 replace:
a240 5
	if (action < ICPOLICY_NEVER) {
		/* If we can not rewrite the arguments, system call fails */
		if (intercept_replace(fd, pid, &repl) == -1)
			action = ICPOLICY_NEVER;
	}
d246 2
@


1.44
log
@- sync with NetBSD or Niels' tarball where appropriate
- keeps local changes
- fixes a bug in profile feedback optimization and avoids symbol
  conflicts with errno
- new feature: "ask" action

itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.43 2003/06/16 06:36:40 itojun Exp $	*/
d75 1
d91 4
@


1.43
log
@- limited number of processes per systrace
- escape fixes for special characters
markus, sturm ok.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.42 2002/12/12 00:39:14 avsm Exp $	*/
d47 1
d301 1
a301 1
	action = filter_ask(fd, NULL, NULL, policynr, emulation, name,
d412 2
a413 2
	    "Usage: systrace [-aAituU] [-d poldir] [-g gui] [-f policy]\n"
	    "\t [-c uid:gid] [-p pid] command ...\n");
d464 48
d519 1
a519 1
	char *guipath = _PATH_XSYSTRACE, *p;
a530 3
			p = strsep(&optarg, ":");
			if (optarg == NULL || *optarg == '\0')
				usage();
d532 1
a532 4
			cr_uid = atoi(p);
			cr_gid = atoi(optarg);

			if (cr_uid <= 0 || cr_gid <= 0)
@


1.42
log
@Allow the log directive to work for non-translated syscalls as well.
provos ok
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.41 2002/12/11 16:55:28 avsm Exp $	*/
d127 1
a127 1
		snprintf(p, size, ", %s: %s", tl->name, line);
d378 12
@


1.41
log
@rename log->dolog, from thorpej@@netbsd, ok provos
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.40 2002/12/09 07:24:56 itojun Exp $	*/
d287 4
@


1.40
log
@add support for regular expressions and pidname translations.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.39 2002/10/28 17:10:10 itojun Exp $	*/
d153 1
a153 1
	int log = 0;
d215 1
a215 1
		log = 1;
d234 1
a234 1
		log = 1;
d242 1
a242 1
	if (log)
d260 1
a260 1
	int len, off, log = 0;
d292 1
a292 1
		log = 1;
d309 1
a309 1
	if (log)
@


1.39
log
@add missing "break".  Alexander Yurchenko
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.38 2002/10/16 15:01:08 itojun Exp $	*/
d122 1
a122 1
			break;
@


1.38
log
@support for privilege elevation.

with privilege elevation no suid or sgid binaries are necessary any
longer.  Applications can be executed completely
unprivileged. Systrace raises the privileges for a single system call
depending on the configured policy.

Idea from discussions with Perry Metzger, Dug Song and Marcus Watts.

from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.37 2002/10/09 03:52:10 itojun Exp $	*/
d475 1
@


1.37
log
@predicates are part of the grammar now; in non-root case, predicates are
evaluated only once; in root case, predicates and variable expansion are
dynamic.
from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.36 2002/10/08 03:13:23 itojun Exp $	*/
d395 2
a396 1
	    "Usage: systrace [-aituU] [-d poldir] [-g gui] [-f policy] [-p pid] command ...\n");
d454 1
a454 1
	char *guipath = _PATH_XSYSTRACE;
d459 3
d463 1
a463 1
	while ((c = getopt(argc, argv, "aAituUd:g:f:p:")) != -1) {
d465 10
d476 2
d484 2
d501 2
d527 5
d552 6
a557 1
		trpid = intercept_run(background, trfd, args[0], args);
@


1.36
log
@"output" is a pointer of size "outlen", so use outlen instead of
sizeof(output)
From "Vincent Labrecque" <vincent@@psyfreaks.ca>
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.35 2002/09/23 04:41:02 itojun Exp $	*/
d47 1
d61 4
a64 2
char *username = NULL;		/* Username in automatic mode */
char cwd[MAXPATHLEN];		/* Current working directory of process */
d70 21
d177 1
a177 1
	action = filter_evaluate(tls, pflq, &ipid->uflags);
d204 1
a204 1
		action = filter_evaluate(tls, pflq, &ipid->uflags);
d220 1
a220 1
	    output, &future, &ipid->uflags);
d245 1
a245 1
		    username, output);
d257 1
d283 7
d297 1
a297 1
	    output, &future, &ipid->uflags);
d312 1
a312 1
		    username, output);
d505 1
a505 6
	/* Username for automatic mode, and policy predicates */
	username = uid_to_name(getuid());

	/* Determine current working directory for filtering */
	if (getcwd(cwd, sizeof(cwd)) == NULL)
		err(1, "getcwd");
@


1.35
log
@support for templates.  they allow fast generation of new policies. an
appropriate template can be inserted during initial policy generation.
from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.34 2002/09/17 04:57:53 itojun Exp $	*/
d105 1
a105 1
		size = sizeof(output) - strlen(output);
@


1.34
log
@daemon should not change the directory.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.33 2002/09/16 04:34:46 itojun Exp $	*/
d195 1
a195 1
	action = filter_ask(tls, pflq, policynr, emulation, name,
d264 1
a264 1
	action = filter_ask(NULL, NULL, policynr, emulation, name,
@


1.33
log
@periodically save policies that have been modified.  from provos

>here is a diff that will cause systrace to periodically save policies
>that have been modified.  Useful if you run systrace on an xterm and
>kill it accidently.  Or other applications like opera that are long
>running and can cause weird crashes.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.32 2002/08/05 23:27:53 provos Exp $	*/
d515 1
a515 1
			if (daemon(0, 1) == -1)
@


1.32
log
@allow to specify an alternate directory for policy loading and writing
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.31 2002/08/04 04:15:50 provos Exp $	*/
d422 1
d424 1
a424 1
	int usex11 = 1;
d527 3
a529 1
	while (intercept_read(trfd) != -1)
d532 20
@


1.31
log
@keep track of ppid and allow matching rules to be logged via syslog.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.30 2002/07/30 05:52:50 itojun Exp $	*/
d363 1
a363 1
	    "Usage: systrace [-aituU] [-g gui] [-f policy] [-p pid] command ...\n");
d420 1
d426 1
a426 1
	while ((c = getopt(argc, argv, "aAituUg:f:p:")) != -1) {
d431 3
d481 1
a481 1
	systrace_initpolicy(filename);
@


1.30
log
@SPLAY_INSERT is a void function
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.29 2002/07/19 14:38:58 itojun Exp $	*/
d72 2
a73 1
make_output(char *output, size_t outlen, const char *binname, pid_t pid,
d83 2
a84 2
	    "%s, pid: %d(%d), policy: %s, filters: %d, syscall: %s-%s(%d)",
	    binname, pid, policynr, policy, nfilters,
d92 4
d128 2
d143 1
d146 1
a146 1
	make_output(output, sizeof(output), binname, pid, policynr,
d184 2
a185 2
		make_output(output, sizeof(output), binname, pid, policynr,
		    policy->name, policy->nfilters,
d191 1
a191 1
		syslog(LOG_WARNING, "user: %s, prog: %s", username, output);
d209 3
d218 5
d235 1
d246 11
a256 4
	snprintf(output, sizeof(output),
	    "%s, pid: %d(%d), policy: %s, filters: %d, syscall: %s-%s(%d), args: %d",
	    ipid->name != NULL ? ipid->name : policy->name, pid, policynr,
	    policy->name, policy->nfilters, emulation, name, code, argsize);
d260 1
a260 1
		syslog(LOG_WARNING, "user: %s, prog: %s", username, output);
d274 1
a274 1
		action = ICPOLICY_NEVER;
d277 5
@


1.29
log
@constify, have missing prototypes, use pedantic compilation options.
niels ok
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.28 2002/07/17 04:50:19 provos Exp $	*/
d52 2
a53 2
pid_t pid;
int fd;
d321 1
a321 1
		close(fd);
d451 1
a451 1
	if ((fd = intercept_open()) == -1)
d466 2
a467 2
		pid = intercept_run(background, fd, args[0], args);
		if (pid == -1)
d470 1
a470 1
		if (intercept_attach(fd, pid) == -1)
d473 1
a473 1
		if (kill(pid, SIGUSR1) == -1)
d477 1
a477 1
		if (intercept_attachpid(fd, pidattach, argv[0]) == -1)
d493 1
a493 1
	while (intercept_read(fd) != -1)
d500 1
a500 1
	close(fd);
@


1.28
log
@on detach or kill do not do argument replacement
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.27 2002/07/16 01:22:48 provos Exp $	*/
d50 1
d63 4
d72 4
a75 3
make_output(char *output, size_t outlen, char *binname, pid_t pid,
    int policynr, char *policy, int nfilters, char *emulation, char *name,
    int code, struct intercept_tlq *tls, struct intercept_replace *repl)
d110 1
a110 1
    char *name, int code, char *emulation,
d121 1
a121 1
	char *binname = NULL;
d211 2
a212 2
gen_cb(int fd, pid_t pid, int policynr, char *name, int code,
    char *emulation, void *args, int argsize, void *cbarg)
d257 2
a258 1
execres_cb(int fd, pid_t pid, int policynr, char *emulation, char *name, void *arg)
d315 1
a315 1
void
d330 1
a330 1
void
d338 1
a338 1
int
@


1.27
log
@internal uid/gid tracking.  permit can not detach systrace, useful for
sshd.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.26 2002/07/12 12:26:29 provos Exp $	*/
d189 1
d192 1
a192 1
		action = ICPOLICY_NEVER;
@


1.26
log
@some clean up.  install argument replacements only if we are going to
permit the system call.  translate some set[e]{g,u}id calls
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.25 2002/07/11 12:57:41 provos Exp $	*/
d257 6
a265 1
		ipid = intercept_getpid(pid);
@


1.25
log
@cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.24 2002/07/10 07:05:38 provos Exp $	*/
d73 1
a73 3
	int size, dorepl;

	dorepl = tl != NULL && repl != NULL;
d83 1
a83 1
	if (dorepl)
d96 1
a96 1
		if (dorepl && tl->trans_size)
d194 1
a194 1
	if (action != ICPOLICY_NEVER) {
@


1.24
log
@add fchmod translation
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.23 2002/07/10 07:05:02 provos Exp $	*/
a318 135
#define X(x)	if ((x) == -1) \
	err(1, "%s:%d: intercept failed", __func__, __LINE__)

void
systrace_initcb(void)
{
	struct systrace_alias *alias;
	struct intercept_translate *tl;

	X(intercept_init());

	X(intercept_register_gencb(gen_cb, NULL));
	X(intercept_register_sccb("native", "open", trans_cb, NULL));
	tl = intercept_register_transfn("native", "open", 0);
	intercept_register_translation("native", "open", 1, &oflags);
	alias = systrace_new_alias("native", "open", "native", "fswrite");
	systrace_alias_add_trans(alias, tl);

	X(intercept_register_sccb("native", "connect", trans_cb, NULL));
	intercept_register_translation("native", "connect", 1,
	    &ic_translate_connect);
	X(intercept_register_sccb("native", "sendto", trans_cb, NULL));
	intercept_register_translation("native", "sendto", 4,
	    &ic_translate_connect);
	X(intercept_register_sccb("native", "bind", trans_cb, NULL));
	intercept_register_translation("native", "bind", 1,
	    &ic_translate_connect);
	X(intercept_register_sccb("native", "execve", trans_cb, NULL));
	intercept_register_transfn("native", "execve", 0);
	X(intercept_register_sccb("native", "stat", trans_cb, NULL));
	tl = intercept_register_transfn("native", "stat", 0);
	alias = systrace_new_alias("native", "stat", "native", "fsread");
	systrace_alias_add_trans(alias, tl);

	X(intercept_register_sccb("native", "lstat", trans_cb, NULL));
	tl = intercept_register_translink("native", "lstat", 0);
	alias = systrace_new_alias("native", "lstat", "native", "fsread");
	systrace_alias_add_trans(alias, tl);

	X(intercept_register_sccb("native", "unlink", trans_cb, NULL));
	tl = intercept_register_transfn("native", "unlink", 0);
	alias = systrace_new_alias("native", "unlink", "native", "fswrite");
	systrace_alias_add_trans(alias, tl);

	X(intercept_register_sccb("native", "chown", trans_cb, NULL));
	intercept_register_transfn("native", "chown", 0);
	intercept_register_translation("native", "chown", 1, &uidt);
	intercept_register_translation("native", "chown", 2, &gidt);
	X(intercept_register_sccb("native", "fchown", trans_cb, NULL));
	intercept_register_translation("native", "fchown", 0, &fdt);
	intercept_register_translation("native", "fchown", 1, &uidt);
	intercept_register_translation("native", "fchown", 2, &gidt);
	X(intercept_register_sccb("native", "chmod", trans_cb, NULL));
	intercept_register_transfn("native", "chmod", 0);
	intercept_register_translation("native", "chmod", 1, &modeflags);
	X(intercept_register_sccb("native", "fchmod", trans_cb, NULL));
	intercept_register_translation("native", "fchmod", 0, &fdt);
	intercept_register_translation("native", "fchmod", 1, &modeflags);
	X(intercept_register_sccb("native", "readlink", trans_cb, NULL));
	tl = intercept_register_translink("native", "readlink", 0);
	alias = systrace_new_alias("native", "readlink", "native", "fsread");
	systrace_alias_add_trans(alias, tl);

	X(intercept_register_sccb("native", "chdir", trans_cb, NULL));
	intercept_register_transfn("native", "chdir", 0);
	X(intercept_register_sccb("native", "access", trans_cb, NULL));
	tl = intercept_register_transfn("native", "access", 0);
	alias = systrace_new_alias("native", "access", "native", "fsread");
	systrace_alias_add_trans(alias, tl);

	X(intercept_register_sccb("native", "mkdir", trans_cb, NULL));
	tl = intercept_register_transfn("native", "mkdir", 0);
	alias = systrace_new_alias("native", "mkdir", "native", "fswrite");
	systrace_alias_add_trans(alias, tl);
	X(intercept_register_sccb("native", "rmdir", trans_cb, NULL));
	tl = intercept_register_transfn("native", "rmdir", 0);
	alias = systrace_new_alias("native", "rmdir", "native", "fswrite");
	systrace_alias_add_trans(alias, tl);

	X(intercept_register_sccb("native", "rename", trans_cb, NULL));
	intercept_register_transfn("native", "rename", 0);
	intercept_register_transfn("native", "rename", 1);
	X(intercept_register_sccb("native", "symlink", trans_cb, NULL));
	intercept_register_transstring("native", "symlink", 0);
	intercept_register_translink("native", "symlink", 1);

	X(intercept_register_sccb("linux", "open", trans_cb, NULL));
	tl = intercept_register_translink("linux", "open", 0);
	intercept_register_translation("linux", "open", 1, &linux_oflags);
	alias = systrace_new_alias("linux", "open", "linux", "fswrite");
	systrace_alias_add_trans(alias, tl);

	X(intercept_register_sccb("linux", "stat", trans_cb, NULL));
	tl = intercept_register_translink("linux", "stat", 0);
	alias = systrace_new_alias("linux", "stat", "linux", "fsread");
	systrace_alias_add_trans(alias, tl);
	X(intercept_register_sccb("linux", "lstat", trans_cb, NULL));
	tl = intercept_register_translink("linux", "lstat", 0);
	alias = systrace_new_alias("linux", "lstat", "linux", "fsread");
	systrace_alias_add_trans(alias, tl);
	X(intercept_register_sccb("linux", "execve", trans_cb, NULL));
	intercept_register_translink("linux", "execve", 0);
	X(intercept_register_sccb("linux", "access", trans_cb, NULL));
	tl = intercept_register_translink("linux", "access", 0);
	alias = systrace_new_alias("linux", "access", "linux", "fsread");
	systrace_alias_add_trans(alias, tl);
	X(intercept_register_sccb("linux", "symlink", trans_cb, NULL));
	intercept_register_transstring("linux", "symlink", 0);
	intercept_register_translink("linux", "symlink", 1);
	X(intercept_register_sccb("linux", "readlink", trans_cb, NULL));
	tl = intercept_register_translink("linux", "readlink", 0);
	alias = systrace_new_alias("linux", "readlink", "linux", "fsread");
	systrace_alias_add_trans(alias, tl);
	X(intercept_register_sccb("linux", "rename", trans_cb, NULL));
	intercept_register_translink("linux", "rename", 0);
	intercept_register_translink("linux", "rename", 1);
	X(intercept_register_sccb("linux", "mkdir", trans_cb, NULL));
	tl = intercept_register_translink("linux", "mkdir", 0);
	alias = systrace_new_alias("linux", "mkdir", "linux", "fswrite");
	systrace_alias_add_trans(alias, tl);
	X(intercept_register_sccb("linux", "rmdir", trans_cb, NULL));
	tl = intercept_register_translink("linux", "rmdir", 0);
	alias = systrace_new_alias("linux", "rmdir", "linux", "fswrite");
	systrace_alias_add_trans(alias, tl);
	X(intercept_register_sccb("linux", "unlink", trans_cb, NULL));
	tl = intercept_register_translink("linux", "unlink", 0);
	alias = systrace_new_alias("linux", "unlink", "linux", "fswrite");
	systrace_alias_add_trans(alias, tl);
	X(intercept_register_sccb("linux", "chmod", trans_cb, NULL));
	intercept_register_translink("linux", "chmod", 0);
	intercept_register_translation("linux", "chmod", 1, &modeflags);

	X(intercept_register_execcb(execres_cb, NULL));
}

a464 2
		pid_t cpid;

@


1.23
log
@do not close fds in daemon.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.22 2002/07/09 20:46:18 provos Exp $	*/
d374 3
@


1.22
log
@allow systrace to run in the background if possible so that the executed
process gets the terminal correctly and exit status reporting works;
based on a diff from atatat@@atatdot.net from netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.21 2002/07/09 15:22:27 provos Exp $	*/
d604 1
a604 1
			if (daemon(0, 0) == -1)
@


1.21
log
@support for system call aliasing.  stat/fstat/readlink/access etc... gets
grouped into fsread, unlink/rmdir/mkdir goes to fswrite.  open switches
back between fsread and fswrite depending on oflags parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.20 2002/06/22 00:03:35 provos Exp $	*/
d515 1
a566 3
	if (signal(SIGCHLD, child_handler) == SIG_ERR)
		err(1, "signal");

d575 3
d587 1
a587 1
		pid = intercept_run(fd, args[0], args);
d594 1
a594 1
		if (kill(pid, SIGCONT) == -1)
d597 2
a599 1

d602 5
d608 3
@


1.20
log
@replace argument only if it is not copied in the kernel already (has length
> 0)
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.19 2002/06/21 15:26:06 provos Exp $	*/
d58 1
d62 42
a110 1
	struct intercept_translate *tl;
d113 3
d117 2
a118 2
	char output[_POSIX2_LINE_MAX], *p, *line;
	int size;
a128 3
	if ((pflq = systrace_policyflq(policy, emulation, name)) == NULL)
		errx(1, "%s:%d: no filter queue", __func__, __LINE__);

d131 1
a131 6
	snprintf(output, sizeof(output),
	    "%s, pid: %d(%d), policy: %s, filters: %d, syscall: %s-%s(%d)",
	    ipid->name != NULL ? ipid->name : policy->name, pid, policynr,
	    policy->name, policy->nfilters, emulation, name, code);
	p = output + strlen(output);
	size = sizeof(output) - strlen(output);
d133 4
a136 7
	intercept_replace_init(&repl);
	TAILQ_FOREACH(tl, tls, next) {
		if (!tl->trans_valid)
			break;
		line = intercept_translate_print(tl);
		if (line == NULL)
			continue;
d138 2
a139 8
		snprintf(p, size, ", %s: %s", tl->name, line);
		p = output + strlen(output);
		size = sizeof(output) - strlen(output);

		if (tl->trans_size)
			intercept_replace_add(&repl, tl->off,
			    tl->trans_data, tl->trans_size);
	}
d144 33
d186 1
a186 1
		systrace_modifypolicy(fd, policynr, name, future);
d325 3
d332 4
a335 2
	X(intercept_register_transfn("native", "open", 0));
	X(intercept_register_translation("native", "open", 1, &oflags));
d338 2
a339 2
	X(intercept_register_translation("native", "connect", 1,
	    &ic_translate_connect));
d341 2
a342 2
	X(intercept_register_translation("native", "sendto", 4,
	    &ic_translate_connect));
d344 2
a345 2
	X(intercept_register_translation("native", "bind", 1,
	    &ic_translate_connect));
d347 1
a347 1
	X(intercept_register_transfn("native", "execve", 0));
d349 4
a352 1
	X(intercept_register_transfn("native", "stat", 0));
d354 4
a357 1
	X(intercept_register_translink("native", "lstat", 0));
d359 4
a362 1
	X(intercept_register_transfn("native", "unlink", 0));
d364 3
a366 3
	X(intercept_register_transfn("native", "chown", 0));
	X(intercept_register_translation("native", "chown", 1, &uidt));
	X(intercept_register_translation("native", "chown", 2, &gidt));
d368 3
a370 3
	X(intercept_register_translation("native", "fchown", 0, &fdt));
	X(intercept_register_translation("native", "fchown", 1, &uidt));
	X(intercept_register_translation("native", "fchown", 2, &gidt));
d372 2
a373 2
	X(intercept_register_transfn("native", "chmod", 0));
	X(intercept_register_translation("native", "chmod", 1, &modeflags));
d375 4
a378 1
	X(intercept_register_translink("native", "readlink", 0));
d380 1
a380 1
	X(intercept_register_transfn("native", "chdir", 0));
d382 4
a385 1
	X(intercept_register_transfn("native", "access", 0));
d387 3
a389 1
	X(intercept_register_transfn("native", "mkdir", 0));
d391 4
a394 1
	X(intercept_register_transfn("native", "rmdir", 0));
d396 2
a397 2
	X(intercept_register_transfn("native", "rename", 0));
	X(intercept_register_transfn("native", "rename", 1));
d399 2
a400 2
	X(intercept_register_transstring("native", "symlink", 0));
	X(intercept_register_translink("native", "symlink", 1));
d403 5
a407 2
	X(intercept_register_translink("linux", "open", 0));
	X(intercept_register_translation("linux", "open", 1, &linux_oflags));
d409 3
a411 1
	X(intercept_register_translink("linux", "stat", 0));
d413 3
a415 1
	X(intercept_register_translink("linux", "lstat", 0));
d417 1
a417 1
	X(intercept_register_translink("linux", "execve", 0));
d419 3
a421 1
	X(intercept_register_translink("linux", "access", 0));
d423 2
a424 2
	X(intercept_register_transstring("linux", "symlink", 0));
	X(intercept_register_translink("linux", "symlink", 1));
d426 3
a428 1
	X(intercept_register_translink("linux", "readlink", 0));
d430 2
a431 2
	X(intercept_register_translink("linux", "rename", 0));
	X(intercept_register_translink("linux", "rename", 1));
d433 3
a435 1
	X(intercept_register_translink("linux", "mkdir", 0));
d437 3
a439 1
	X(intercept_register_translink("linux", "rmdir", 0));
d441 3
a443 1
	X(intercept_register_translink("linux", "unlink", 0));
d445 2
a446 2
	X(intercept_register_translink("linux", "chmod", 0));
	X(intercept_register_translation("linux", "chmod", 1, &modeflags));
d455 1
a455 1
	    "Usage: systrace [-ait] [-g gui] [-f policy] [-p pid] command ...\n");
d516 1
a516 1
	while ((c = getopt(argc, argv, "aAitUg:f:p:")) != -1) {
d524 3
d570 1
@


1.19
log
@rewrite all system call arguments in the permit case.  use realpath
when we still have the root and we of the monitored process.  this
eliminates almost all race coniditions.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.19 2002/06/21 15:22:04 provos Exp $	*/
d108 3
a110 2
		intercept_replace_add(&repl, tl->off,
		    tl->trans_data, tl->trans_size);
@


1.18
log
@more careful buffer handling; pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.17 2002/06/18 23:28:29 deraadt Exp $	*/
d70 1
d96 1
d101 9
a109 5
		if (line != NULL) {
			snprintf(p, size, ", %s: %s", tl->name, line);
			p = output + strlen(output);
			size = sizeof(output) - strlen(output);
		}
d114 1
a114 1
		goto out;
d132 6
@


1.17
log
@string.h
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.16 2002/06/12 22:14:51 provos Exp $	*/
d37 1
d71 1
a71 1
	char output[1024], *p, *line;
d135 1
a135 1
	char output[1024];
@


1.16
log
@gui needs to be started after child has been forked to prevent fds from
being inherited and stdout/stdin from being mangled; from xs@@kittenz.org
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.15 2002/06/11 05:21:17 jsyn Exp $	*/
d43 1
@


1.15
log
@kill err(3) newlines; ok provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.14 2002/06/10 19:16:26 provos Exp $	*/
a451 4
	/* Start the policy gui if necessary */
	if (usex11 && !automatic && !allow)
		requestor_start(guipath);

d479 4
@


1.14
log
@support attaching to a running process; some code by fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.13 2002/06/05 20:52:47 provos Exp $	*/
d78 1
a78 1
		errx(1, "%s:%d: find %d\n", __func__, __LINE__,
d82 1
a82 1
		errx(1, "%s:%d: no filter queue\n", __func__, __LINE__);
d143 1
a143 1
		errx(1, "%s:%d: find %d\n", __func__, __LINE__,
@


1.13
log
@support simple predicates to prefix rules.  Allows global policies to be
different for different users.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.12 2002/06/05 20:01:22 provos Exp $	*/
d337 1
a337 1
	    "Usage: systrace [-ait] [-g gui] [-f policy] command ...\n");
d395 1
d398 1
a398 1
	while ((c = getopt(argc, argv, "aAitUg:f:")) != -1) {
d415 6
d435 1
a435 1
	if (argc == 0)
a444 7
	if ((args = malloc((argc + 1) * sizeof(char *))) == NULL)
		err(1, "malloc");

	for (i = 0; i < argc; i++)
		args[i] = argv[i];
	args[i] = NULL;

d452 4
d459 20
a478 3
	pid = intercept_run(fd, args[0], args);
	if (pid == -1)
		err(1, "fork");
d480 3
a482 8
	if (intercept_attach(fd, pid) == -1)
		err(1, "attach");

	if (usex11 && !automatic && !allow)
		requestor_start(guipath);

	if (kill(pid, SIGCONT) == -1)
		err(1, "kill");
@


1.12
log
@dump policies only if user policy is specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.11 2002/06/05 16:51:08 provos Exp $	*/
a400 1
			username = uid_to_name(getuid());
d430 3
@


1.11
log
@introduce an automatic policy generation mode.  it creates a policy based
on what the application tries to do.  the policy can be refined further on.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.10 2002/06/05 15:59:52 provos Exp $	*/
d470 2
a471 1
	systrace_dumppolicy();
@


1.10
log
@know about CWD. will make some filter rules simpler.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.9 2002/06/04 22:45:25 provos Exp $	*/
d54 1
d397 1
a397 1
	while ((c = getopt(argc, argv, "aitUg:f:")) != -1) {
d403 3
d460 1
a460 1
	if (usex11 && !automatic)
@


1.9
log
@log offending syscalls to syslog in automatic mode. dugsong@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.8 2002/06/04 20:13:19 provos Exp $	*/
d33 1
d56 1
d427 4
@


1.8
log
@add flag to ignore user specified policies
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.7 2002/06/04 19:58:46 provos Exp $	*/
d41 1
d54 1
d106 1
a142 5
	if (policy->flags & POLICY_UNSUPERVISED) {
		action = ICPOLICY_NEVER;
		goto out;
	}

d150 6
d398 1
@


1.7
log
@usage; fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.6 2002/06/04 19:50:12 provos Exp $	*/
d52 1
d390 1
a390 1
	while ((c = getopt(argc, argv, "aitg:f:")) != -1) {
d406 3
@


1.6
log
@guipath for getopt
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.5 2002/06/04 19:43:35 provos Exp $	*/
d328 2
a329 1
	fprintf(stderr, "Usage: systrace [-ait] [-f policy] command ...\n");
@


1.5
log
@explicit path for notification tool xsystrace.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.4 2002/06/04 19:25:54 provos Exp $	*/
d385 1
d388 1
a388 1
	while ((c = getopt(argc, argv, "aitf:")) != -1) {
d396 3
d441 1
a441 1
		requestor_start(_PATH_XSYSTRACE);
@


1.4
log
@complain about missing device only once. from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.3 2002/06/04 19:15:54 deraadt Exp $	*/
d360 1
a360 1
		err(1, "execvp");
d437 1
a437 1
		requestor_start("./notification/src/notification");
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.2 2002/06/04 19:07:04 provos Exp $	*/
d426 2
a427 1
	X(fd = intercept_open());
@


1.2
log
@__FUNCTION__ -> __func__ from espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.1 2002/06/04 17:20:04 provos Exp $	*/
d67 1
a67 1
		
d224 1
a224 1
	
d250 1
a250 1
	      &ic_translate_connect));
d253 1
a253 1
	      &ic_translate_connect));
d256 1
a256 1
	      &ic_translate_connect));
@


1.1
log
@initial import of systrace.  don't touch this, more stuff coming in a while
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d72 1
a72 1
		errx(1, "%s:%d: find %d\n", __FUNCTION__, __LINE__,
d76 1
a76 1
		errx(1, "%s:%d: no filter queue\n", __FUNCTION__, __LINE__);
d136 1
a136 1
		errx(1, "%s:%d: find %d\n", __FUNCTION__, __LINE__,
d236 1
a236 1
	err(1, "%s:%d: intercept failed", __FUNCTION__, __LINE__)
@

