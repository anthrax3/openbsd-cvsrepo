head	1.19;
access;
symbols
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.10
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.8
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.13.0.22
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.20
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.18
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.14
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.16
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.12
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.10
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.11.0.8
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9;
locks; strict;
comment	@ * @;


1.19
date	2016.04.25.19.09.25;	author tedu;	state dead;
branches;
next	1.18;
commitid	Ne4KgWE1uInoydsl;

1.18
date	2015.12.09.19.36.17;	author mmcc;	state Exp;
branches;
next	1.17;
commitid	8oyfVibTyuKjsb15;

1.17
date	2014.08.10.04.57.33;	author guenther;	state Exp;
branches;
next	1.16;
commitid	eN1HiqeMJLCAsCxx;

1.16
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2012.03.02.17.23.08;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	2011.09.18.23.24.14;	author matthew;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2006.06.10.07.19.13;	author sturm;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.02.19.49.05;	author sturm;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.07.07.31.40;	author marius;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.08.16.32.44;	author sturm;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.01.20.16.45;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.20.04.19.53;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.19.14.38.57;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.14.22.34.55;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.13.08.53.02;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.21.15.26.06;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.19.16.31.07;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.04.19.15.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.04.17.20.04;	author provos;	state Exp;
branches;
next	;

1.14.2.1
date	2012.04.06.11.32.47;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.19
log
@boom goes the dynamite
@
text
@/*	$OpenBSD: intercept-translate.c,v 1.18 2015/12/09 19:36:17 mmcc Exp $	*/
/*
 * Copyright 2002 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/tree.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <stdint.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>
#include <err.h>

#include "intercept.h"

char *error_msg = "error";

static void ic_trans_free(struct intercept_translate *);
static int ic_print_filename(char *, size_t, struct intercept_translate *);
static int ic_get_filename(struct intercept_translate *, int, pid_t, void *);
static int ic_get_string(struct intercept_translate *, int, pid_t, void *);
static int ic_get_linkname(struct intercept_translate *, int, pid_t, void *);
static int ic_get_sockaddr(struct intercept_translate *, int, pid_t, void *);
static int ic_print_sockaddr(char *, size_t, struct intercept_translate *);

static void
ic_trans_free(struct intercept_translate *trans)
{
	free(trans->trans_data);
	free(trans->trans_print);
	trans->trans_valid = 0;
	trans->trans_data = NULL;
	trans->trans_print = NULL;
	trans->trans_size = 0;
	trans->trans_addr = NULL;
}

extern struct intercept_system intercept;

/* Takes a translation structure and retrieves the right data */

int
intercept_translate(struct intercept_translate *trans,
    int fd, pid_t pid, int off, void *args, int argsize)
{
	void *addr, *addr2, *addrend;

	ic_trans_free(trans);

	if (intercept.getarg(off, args, argsize, &addr) == -1)
		return (-1);
	if (trans->off2) {
		if (intercept.getarg(trans->off + trans->off2,
			args, argsize, &addr2) == -1)
			return (-1);
		trans->trans_addr2 = addr2;
	}
	if (trans->offend) {
		/* XXX: Abstraction violation. */
		int numargs = argsize / sizeof(register_t);

		if (intercept.getarg(numargs + trans->offend,
		    args, argsize, &addrend) == -1)
			return (-1);
		trans->trans_addrend = addrend;
	}

	trans->trans_valid = 1;
	trans->trans_addr = addr;

	if (trans->translate == NULL)
		return (0);

	if ((*trans->translate)(trans, fd, pid, addr) == -1) {
		trans->trans_valid = 0;
		return (-1);
	}

	return (0);
}

char *
intercept_translate_print(struct intercept_translate *trans)
{
	char line[_POSIX2_LINE_MAX];

	if (trans->trans_print == NULL) {
		if (trans->print(line, sizeof(line), trans) == -1)
			return (error_msg);

		if ((trans->trans_print = strdup(line)) == NULL)
			return (error_msg);
	}

	return (trans->trans_print);
}

static int
ic_print_filename(char *buf, size_t buflen, struct intercept_translate *tl)
{
	strlcpy(buf, tl->trans_data, buflen);

	return (0);
}

static int
ic_get_filename(struct intercept_translate *trans, int fd, pid_t pid,
    void *addr)
{
	char *name;
	size_t len;

	name = intercept_filename(fd, pid, addr, ICLINK_ALL, NULL);
	if (name == NULL)
		return (-1);

	len = strlen(name) + 1;
	trans->trans_data = malloc(len);
	if (trans->trans_data == NULL)
		return (-1);

	trans->trans_size = len;
	memcpy(trans->trans_data, name, len);
	trans->trans_flags = ICTRANS_NOLINKS;

	return (0);
}

static int
ic_get_string(struct intercept_translate *trans, int fd, pid_t pid, void *addr)
{
	char *name;
	size_t len;

	if (addr == NULL)
		return (-1);

	name = intercept_get_string(fd, pid, addr);
	if (name == NULL)
		return (-1);

	len = strlen(name) + 1;
	trans->trans_data = malloc(len);
	if (trans->trans_data == NULL)
		return (-1);

	trans->trans_size = len;
	memcpy(trans->trans_data, name, len);

	return (0);
}

static int
ic_get_linkname(struct intercept_translate *trans, int fd, pid_t pid,
    void *addr)
{
	char *name;
	size_t len;

	name = intercept_filename(fd, pid, addr, ICLINK_NONE, NULL);
	if (name == NULL)
		return (-1);

	len = strlen(name) + 1;
	trans->trans_data = malloc(len);
	if (trans->trans_data == NULL)
		return (-1);

	trans->trans_size = len;
	memcpy(trans->trans_data, name, len);

	return (0);
}

/* Resolves all symlinks but for the last component */

static int
ic_get_unlinkname(struct intercept_translate *trans, int fd, pid_t pid,
    void *addr)
{
	char *name;
	size_t len;

	name = intercept_filename(fd, pid, addr, ICLINK_NOLAST, NULL);
	if (name == NULL)
		return (-1);

	len = strlen(name) + 1;
	trans->trans_data = malloc(len);
	if (trans->trans_data == NULL)
		return (-1);

	trans->trans_size = len;
	memcpy(trans->trans_data, name, len);
	trans->trans_flags = ICTRANS_NOLINKS;

	return (0);
}

static int
ic_get_filenameat(struct intercept_translate *trans, int fd, pid_t pid,
    void *addr)
{
	char *name;
	size_t len;
	int atfd = (intptr_t)trans->trans_addr2;
	int follow = (intptr_t)trans->user;
	int userp;

	if (trans->offend) {
		int flag = (intptr_t)trans->trans_addrend;
		if ((flag & ~(AT_SYMLINK_FOLLOW | AT_SYMLINK_NOFOLLOW)) != 0)
			return (-1);
		if ((flag & follow) != 0)
			return (-1);
		if (flag != 0)
			follow = flag;
	}

	userp = (follow == AT_SYMLINK_FOLLOW) ? ICLINK_ALL : ICLINK_NOLAST;
	name = intercept_filenameat(fd, pid, atfd, addr, userp, NULL);
	if (name == NULL)
		return (-1);

	len = strlen(name) + 1;
	trans->trans_data = malloc(len);
	if (trans->trans_data == NULL)
		return (-1);

	trans->trans_size = len;
	memcpy(trans->trans_data, name, len);
	trans->trans_flags = ICTRANS_NOLINKS;

	return (0);
}

static int
ic_get_sockaddr(struct intercept_translate *trans, int fd, pid_t pid,
    void *addr)
{
	struct sockaddr_storage sa;
	socklen_t len;

	len = (intptr_t)trans->trans_addr2;
	if (len == 0 || len > sizeof(struct sockaddr_storage))
		return (-1);

	if (intercept.io(fd, pid, INTERCEPT_READ, addr,
		(void *)&sa, len) == -1)
		return (-1);

	trans->trans_data = malloc(len);
	if (trans->trans_data == NULL)
		return (-1);
	trans->trans_size = len;
	memcpy(trans->trans_data, &sa, len);

	return (0);
}

#ifndef offsetof
#define offsetof(s, e)	((size_t)&((s *)0)->e)
#endif

static int
ic_print_sockaddr(char *buf, size_t buflen, struct intercept_translate *tl)
{
	char host[NI_MAXHOST];
	char serv[NI_MAXSERV];
	struct sockaddr *sa = tl->trans_data;
	socklen_t len = (socklen_t)tl->trans_size;

	buf[0] = '\0';

	switch (sa->sa_family) {
	case PF_LOCAL:
		if (len <= offsetof(struct sockaddr, sa_data))
			return (-1);
		len -= offsetof(struct sockaddr, sa_data);
		if (buflen < len + 1)
			len = buflen - 1;
		memcpy(buf, sa->sa_data, len);
		buf[len] = '\0';
		return (0);
	case PF_INET:
	case PF_INET6:
		break;
	default:
		snprintf(buf, buflen, "family(%d)", sa->sa_family);
		return (0);
	}

	sa->sa_len = len;
	if (getnameinfo(sa, len,
		host, sizeof(host), serv, sizeof(serv),
		NI_NUMERICHOST | NI_NUMERICSERV)) {
		warn("getnameinfo");
		return (-1);
	}

	snprintf(buf, buflen, "inet-[%s]:%s", host, serv);

	return (0);
}

static int
ic_get_msghdr(struct intercept_translate *trans, int fd, pid_t pid,
    void *addr)
{
	struct msghdr msg;
	int len = sizeof(struct msghdr);

	if (intercept.io(fd, pid, INTERCEPT_READ, addr,
	    (void *)&msg, len) == -1)
		return (-1);

	len = msg.msg_namelen;
	if (msg.msg_name == NULL || len <= 0 || len > 2048) {
		trans->trans_data = NULL;
		trans->trans_size = 0;
		return (0);
	}

	trans->trans_size = len;
	trans->trans_data = malloc(len);
	if (trans->trans_data == NULL)
		return (-1);
	if (intercept.io(fd, pid, INTERCEPT_READ, msg.msg_name,
	    (void *)trans->trans_data, trans->trans_size) == -1)
		return (-1);

	return (0);
}

static int
ic_print_msghdr(char *buf, size_t buflen, struct intercept_translate *tl)
{
	int res = 0;

	if (tl->trans_size == 0) {
		snprintf(buf, buflen, "<unknown>");
	} else {
		res = ic_print_sockaddr(buf, buflen, tl);
		/*
		 * disable replacement of this argument because it's two levels
		 * deep and we cant replace that fast.
		 */
		tl->trans_size = 0;

		/* TODO: make this less of a hack */
	}

	return (res);
}

struct intercept_translate ic_translate_string = {
	"string",
	ic_get_string, ic_print_filename,
};

struct intercept_translate ic_translate_filename = {
	"filename",
	ic_get_filename, ic_print_filename,
};

struct intercept_translate ic_translate_linkname = {
	"filename",
	ic_get_linkname, ic_print_filename,
};

struct intercept_translate ic_translate_unlinkname = {
	"filename",
	ic_get_unlinkname, ic_print_filename,
};

struct intercept_translate ic_translate_filenameat = {
	"filename",
	ic_get_filenameat, ic_print_filename,
	.off2 = -1,
	.user = (void *)AT_SYMLINK_FOLLOW,
};

struct intercept_translate ic_translate_unlinknameat = {
	"filename",
	ic_get_filenameat, ic_print_filename,
	.off2 = -1,
	.user = (void *)AT_SYMLINK_NOFOLLOW,
};

struct intercept_translate ic_translate_filenameatflag = {
	"filename",
	ic_get_filenameat, ic_print_filename,
	.off2 = -1,
	.offend = -1,
	.user = (void *)AT_SYMLINK_FOLLOW,
};

struct intercept_translate ic_translate_unlinknameatflag = {
	"filename",
	ic_get_filenameat, ic_print_filename,
	.off2 = -1,
	.offend = -1,
	.user = (void *)AT_SYMLINK_NOFOLLOW,
};

struct intercept_translate ic_translate_connect = {
	"sockaddr",
	ic_get_sockaddr, ic_print_sockaddr,
	/* XXX - Special handling */ 1,
};

struct intercept_translate ic_translate_sendmsg = {
	"sockaddr",
	ic_get_msghdr, ic_print_msghdr,
};
@


1.18
log
@Remove NULL-check before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.17 2014/08/10 04:57:33 guenther Exp $	*/
@


1.17
log
@Only need <stdint.h> and not all of <inttypes.h> here
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.16 2012/12/04 02:24:47 deraadt Exp $	*/
d59 2
a60 4
	if (trans->trans_data)
		free(trans->trans_data);
	if (trans->trans_print)
		free(trans->trans_print);
@


1.16
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.15 2012/03/02 17:23:08 matthew Exp $	*/
d36 1
a36 1
#include <inttypes.h>
@


1.15
log
@Fix handling of 'offend' (OFFset from the END of the arg list)
arguments in systrace(1).  In intercept_translate(), argsize is
actually the number of *bytes* taken up by the arguments, not the
number of arguments.

ok ajacoutot, sthen, dcoppa
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.14 2011/09/18 23:24:14 matthew Exp $	*/
a32 1
#include <sys/param.h>
@


1.14
log
@Add support for *at(2) system calls to systrace(1).

ok deraadt@@, sthen@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.13 2006/06/10 07:19:13 sturm Exp $	*/
d92 4
a95 1
		if (intercept.getarg(argsize + trans->offend,
@


1.14.2.1
log
@MFC systrace intercept_translate() problem resulting in problems with
systrace and some *at functions, most noticable building ports using gtar
under systrace.

Date: 2012/03/02 17:23:08
Author: matthew
Branch: HEAD
Tag: (none)
Log:
Fix handling of 'offend' (OFFset from the END of the arg list)
arguments in systrace(1).  In intercept_translate(), argsize is
actually the number of *bytes* taken up by the arguments, not the
number of arguments.

ok ajacoutot, sthen, dcoppa

Members:
        intercept-translate.c:1.14->1.15
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.15 2012/03/02 17:23:08 matthew Exp $	*/
d92 1
a92 4
		/* XXX: Abstraction violation. */
		int numargs = argsize / sizeof(register_t);

		if (intercept.getarg(numargs + trans->offend,
@


1.13
log
@add a translation for sendmsg()

from provos, with feedback from ray and pat
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.12 2006/05/02 19:49:05 sturm Exp $	*/
d36 1
d79 1
a79 1
	void *addr, *addr2;
d91 6
d231 37
d404 30
@


1.12
log
@some type cleanup

with feedback from kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.11 2004/07/07 07:31:40 marius Exp $	*/
d292 50
d366 5
@


1.11
log
@fix an issue when scripts are exec'd under systrace where
the argv[0] would be normalized, and hence break scripts
that depend on how they were called.

this fixes an issue in the ports builds.

ok provos@@ deraadt@@; lots of testing during hackathon sturm@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.10 2003/10/08 16:32:44 sturm Exp $	*/
d134 1
a134 1
	int len;
d156 1
a156 1
	int len;
d181 1
a181 1
	int len;
d205 1
a205 1
	int len;
@


1.10
log
@originally from cb@@openbsd.org, adapted by provos

itojun@@ ok

fix a race condition between path resolution in userland
and the subsequent namei(): inform the kernel portion of
valid filenames and then disallow symlink lookups for
those filenames by means of a hook in namei().
with suggestions from provos@@

also, add (currently unused) seqnr field to struct
systrace_replace, from provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.9 2002/08/01 20:16:45 provos Exp $	*/
d136 1
a136 1
	name = intercept_filename(fd, pid, addr, ICLINK_ALL);
d183 1
a183 1
	name = intercept_filename(fd, pid, addr, ICLINK_NONE);
d207 1
a207 1
	name = intercept_filename(fd, pid, addr, ICLINK_NOLAST);
@


1.9
log
@the last component in a filename for unlink may be a symlink
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.8 2002/07/20 04:19:53 provos Exp $	*/
d147 1
d218 1
@


1.8
log
@compile on sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.7 2002/07/19 14:38:57 itojun Exp $	*/
d136 1
a136 1
	name = intercept_filename(fd, pid, addr, 1);
d182 25
a206 1
	name = intercept_filename(fd, pid, addr, 0);
d303 5
@


1.7
log
@constify, have missing prototypes, use pedantic compilation options.
niels ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.6 2002/07/14 22:34:55 provos Exp $	*/
d36 1
d204 1
a204 1
	len = (socklen_t )trans->trans_addr2;
@


1.6
log
@argv translation for exeve
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.5 2002/07/13 08:53:02 provos Exp $	*/
d47 9
a55 1
void
d120 1
a120 1
int
d128 1
a128 1
int
d150 1
a150 1
int
d174 1
a174 1
int
d196 1
a196 1
int
d224 1
a224 1
int
@


1.5
log
@use correct length for PF_LOCAL sockets; not all applications fill in
sa_len
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.4 2002/06/21 15:26:06 provos Exp $	*/
d147 3
@


1.4
log
@rewrite all system call arguments in the permit case.  use realpath
when we still have the root and we of the monitored process.  this
eliminates almost all race coniditions.
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.4 2002/06/21 15:22:04 provos Exp $	*/
d209 4
d225 3
a227 2
		if (sa->sa_len < len)
			len = sa->sa_len;
@


1.3
log
@more careful buffer handling; pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.2 2002/06/04 19:15:54 deraadt Exp $	*/
d124 1
a124 2
	char buf[MAXPATHLEN];
	char *path, *name;
d127 1
a127 1
	name = intercept_filename(fd, pid, addr);
d131 1
a131 6
	/* If realpath fails then the filename does not exist */
	path = buf;
	if (realpath(name, path) == NULL)
		path = "<non-existant filename>";

	len = strlen(path) + 1;
d137 1
a137 1
	memcpy(trans->trans_data, path, len);
d170 1
a170 1
	name = intercept_filename(fd, pid, addr);
@


1.2
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: intercept-translate.c,v 1.1 2002/06/04 17:20:04 provos Exp $	*/
d36 1
d99 1
a99 1
	char line[1024];
@


1.1
log
@initial import of systrace.  don't touch this, more stuff coming in a while
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 1
a65 1
intercept_translate(struct intercept_translate *trans, 
d126 1
a126 1
	
d152 1
a152 1
	
d174 1
a174 1
	
@

