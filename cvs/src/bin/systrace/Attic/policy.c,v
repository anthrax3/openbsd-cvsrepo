head	1.37;
access;
symbols
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.35.0.6
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.6
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.33.0.4
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.32.0.24
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.22
	OPENBSD_5_0:1.32.0.20
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.18
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.16
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.12
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.14
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.10
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.8
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.6
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.4
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.29.0.12
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.10
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.8
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.29.0.6
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20;
locks; strict;
comment	@ * @;


1.37
date	2016.04.25.19.09.25;	author tedu;	state dead;
branches;
next	1.36;
commitid	Ne4KgWE1uInoydsl;

1.36
date	2015.12.30.14.59.10;	author tedu;	state Exp;
branches;
next	1.35;
commitid	pcpM0SacneEDdJB8;

1.35
date	2015.01.16.00.19.12;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	9JSDzKTCgxU6o5el;

1.34
date	2013.11.21.15.54.46;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2006.09.19.10.48.41;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2006.07.02.12.34.15;	author sturm;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.18.19.03.23;	author robert;	state Exp;
branches;
next	1.29;

1.29
date	2003.07.19.11.48.58;	author sturm;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.19.06.26.19;	author pvalchev;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.16.06.36.40;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.02.03.51;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.17.07.39.24;	author pvalchev;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.18.13.14.43;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.09.07.23.52;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2002.12.09.07.22.53;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.09.03.52.10;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.23.04.41.02;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.17.05.10.58;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.16.04.34.46;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.06.22.56.21;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.30.17.09.21;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.07.00.34.17;	author vincent;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.05.23.27.53;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.19.14.38.58;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.07.23.14.43;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.22.18.23.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.19.16.31.07;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.11.05.30.28;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.09.04.18.56;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.05.21.09.02;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.05.20.52.47;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.04.23.05.26;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.04.20.13.19;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.04.19.15.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.04.19.07.04;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.04.17.20.04;	author provos;	state Exp;
branches;
next	;


desc
@@


1.37
log
@boom goes the dynamite
@
text
@/*	$OpenBSD: policy.c,v 1.36 2015/12/30 14:59:10 tedu Exp $	*/
/*
 * Copyright 2002 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/tree.h>
#include <dirent.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <grp.h>
#include <stdio.h>
#include <fcntl.h>
#include <ctype.h>
#include <err.h>
#include <libgen.h>

#include "intercept.h"
#include "systrace.h"

static int psccompare(struct policy_syscall *, struct policy_syscall *);
static int policycompare(struct policy *, struct policy *);
static int polnrcompare(struct policy *, struct policy *);
static char *systrace_policyfilename(char *, const char *);
static char *systrace_policyline(char *line);
static int systrace_policyprocess(struct policy *,
    char *);
static int systrace_writepolicy(struct policy *);

int systrace_templatedir(void);

static int
psccompare(struct policy_syscall *a, struct policy_syscall *b)
{
	int diff;
	diff = strcmp(a->emulation, b->emulation);
	if (diff)
		return (diff);
	return (strcmp(a->name, b->name));
}

SPLAY_PROTOTYPE(syscalltree, policy_syscall, node, psccompare)
SPLAY_GENERATE(syscalltree, policy_syscall, node, psccompare)

static SPLAY_HEAD(policytree, policy) policyroot;
static SPLAY_HEAD(polnrtree, policy) polnrroot;

int
policycompare(struct policy *a, struct policy *b)
{
	return (strcmp(a->name, b->name));
}

int
polnrcompare(struct policy *a, struct policy *b)
{
	int diff = a->policynr - b->policynr;

	if (diff == 0)
		return (0);
	if (diff > 0 )
		return (1);
	return (-1);
}

SPLAY_PROTOTYPE(policytree, policy, node, policycompare)
SPLAY_GENERATE(policytree, policy, node, policycompare)

SPLAY_PROTOTYPE(polnrtree, policy, nrnode, polnrcompare)
SPLAY_GENERATE(polnrtree, policy, nrnode, polnrcompare)

extern int userpolicy;

static char policydir[PATH_MAX];

struct tmplqueue templates;

void
systrace_setupdir(char *path)
{
	char *home;
	struct stat sb;

	if (path == NULL) {
		home = getenv("HOME");

		if (home == NULL)
			errx(1, "No HOME environment set");

		if (strlcpy(policydir, home, sizeof(policydir)) >= sizeof(policydir))
			errx(1, "HOME too long");

		if (strlcat(policydir, "/.systrace", sizeof(policydir)) >= sizeof(policydir))
			errx(1, "HOME too long");
	} else if (strlcpy(policydir, path, sizeof(policydir)) >= sizeof(policydir))
		errx(1, "policy directory too long");
		

	if (stat(policydir, &sb) != -1) {
		if (!S_ISDIR(sb.st_mode))
			errx(1, "Not a directory: \"%s\"", policydir);
	} else if (mkdir(policydir, 0700) == -1)
		err(1, "mkdir(%s)", policydir);
}

int
systrace_initpolicy(char *file, char *path)
{
	SPLAY_INIT(&policyroot);
	SPLAY_INIT(&polnrroot);

	if (userpolicy) {
		systrace_setupdir(path);
		systrace_templatedir();
	}

	if (file != NULL)
		return (systrace_readpolicy(file) != NULL ? 0 : -1);

	return (0);
}

struct policy *
systrace_findpolicy(const char *name)
{
	struct policy tmp;

	tmp.name = name;

	return (SPLAY_FIND(policytree, &policyroot, &tmp));
}

struct policy *
systrace_findpolicy_wildcard(const char *name)
{
	struct policy tmp, *res;
	static char path[PATH_MAX], lookup[PATH_MAX];

	if (strlcpy(path, name, sizeof(path)) >= sizeof(path))
		errx(1, "%s: path name overflow", __func__);

	strlcpy(lookup, "*/", sizeof(lookup));
	strlcat(lookup, basename(path), sizeof(lookup));

	tmp.name = lookup;
	res = SPLAY_FIND(policytree, &policyroot, &tmp);
	if (res == NULL)
		return (NULL);

	/* we found the wildcarded policy; now remove it and bind it */
	SPLAY_REMOVE(policytree, &policyroot, res);

	free((char *)res->name);
	if ((res->name = strdup(name)) == NULL)
		err(1, "%s: strdup", __func__);

	SPLAY_INSERT(policytree, &policyroot, res);
	return (res);
}

struct policy *
systrace_findpolnr(int nr)
{
	struct policy tmp;

	tmp.policynr = nr;

	return (SPLAY_FIND(polnrtree, &polnrroot, &tmp));
}

int
systrace_newpolicynr(int fd, struct policy *tmp)
{
	if (tmp->policynr != -1)
		return (-1);

	if ((tmp->policynr = intercept_newpolicy(fd)) == -1) {
		/* XXX - maybe free policy structure here */
		return (-1);
	}

	SPLAY_INSERT(polnrtree, &polnrroot, tmp);

	return (tmp->policynr);
}

struct policy *
systrace_newpolicy(const char *emulation, const char *name)
{
	int i;
	struct policy *tmp;

	if ((tmp = systrace_findpolicy(name)) != NULL)
		return (tmp);

	if ((tmp = systrace_findpolicy_wildcard(name)) != NULL)
		return (tmp);

	tmp = calloc(1, sizeof(struct policy));
	if (tmp == NULL)
		return (NULL);

	tmp->policynr = -1;

	/* New policies requires initialization */
	if ((tmp->name = strdup(name)) == NULL)
		err(1, "%s:%d: strdup", __func__, __LINE__);
	strlcpy(tmp->emulation, emulation, sizeof(tmp->emulation));

	SPLAY_INSERT(policytree, &policyroot, tmp);
	SPLAY_INIT(&tmp->pflqs);
	TAILQ_INIT(&tmp->filters);
	TAILQ_INIT(&tmp->prefilters);

	/* Set the default policy to ask */
	for (i = 0; i < INTERCEPT_MAXSYSCALLNR; i++)
		tmp->kerneltable[i] = ICPOLICY_ASK;

	return (tmp);
}

void
systrace_cleanpolicy(struct policy *policy)
{
	struct filter *filter;
	struct policy_syscall *pflq;
	int i;

	/* Set the default policy to ask */
	for (i = 0; i < INTERCEPT_MAXSYSCALLNR; i++)
		policy->kerneltable[i] = ICPOLICY_ASK;

	while ((filter = TAILQ_FIRST(&policy->prefilters)) != NULL) {
		TAILQ_REMOVE(&policy->prefilters, filter, policy_next);
		filter_free(filter);
	}

	while ((filter = TAILQ_FIRST(&policy->filters)) != NULL) {
		TAILQ_REMOVE(&policy->filters, filter, policy_next);
		filter_free(filter);
	}

	while ((pflq = SPLAY_ROOT(&policy->pflqs)) != NULL) {
		SPLAY_REMOVE(syscalltree, &policy->pflqs, pflq);

		while ((filter = TAILQ_FIRST(&pflq->flq)) != NULL) {
			TAILQ_REMOVE(&pflq->flq, filter, next);
			filter_free(filter);
		}

		free(pflq);
	}
}

void
systrace_freepolicy(struct policy *policy)
{
	if (policy->flags & POLICY_CHANGED) {
		if (systrace_writepolicy(policy) == -1)
			fprintf(stderr, "Failed to write policy for %s\n",
			    policy->name);
	}

	systrace_cleanpolicy(policy);

	SPLAY_REMOVE(policytree, &policyroot, policy);
	if (policy->policynr != -1)
		SPLAY_REMOVE(polnrtree, &polnrroot, policy);

	free((char *)policy->name);
	free(policy);
}

struct filterq *
systrace_policyflq(struct policy *policy, const char *emulation,
    const char *name)
{
	struct policy_syscall tmp2, *tmp;

	strlcpy(tmp2.emulation, emulation, sizeof(tmp2.emulation));
	strlcpy(tmp2.name, name, sizeof(tmp2.name));

	tmp = SPLAY_FIND(syscalltree, &policy->pflqs, &tmp2);
	if (tmp != NULL)
		return (&tmp->flq);

	if ((tmp = calloc(1, sizeof(struct policy_syscall))) == NULL)
		err(1, "%s:%d: out of memory", __func__, __LINE__);

	strlcpy(tmp->emulation, emulation, sizeof(tmp->emulation));
	strlcpy(tmp->name, name, sizeof(tmp->name));
	TAILQ_INIT(&tmp->flq);

	SPLAY_INSERT(syscalltree, &policy->pflqs, tmp);

	return (&tmp->flq);
}

int
systrace_modifypolicy(int fd, int policynr, const char *name, short action)
{
	struct policy *policy;
	int res, nr;

	if ((policy = systrace_findpolnr(policynr)) == NULL)
		return (-1);

	res = intercept_modifypolicy(fd, policynr, policy->emulation,
	    name, action);

	/* Remember the kernel policy */
	if (res != -1 &&
	    (nr = intercept_getsyscallnumber(policy->emulation, name)) != -1)
		policy->kerneltable[nr] = action;

	return (res);
}

char *
systrace_policyfilename(char *dir, const char *name)
{
	static char file[2*PATH_MAX];
	const char *p;
	int i, plen;

	if (strlen(name) + strlen(dir) + 1 >= sizeof(file))
		return (NULL);

	strlcpy(file, dir, sizeof(file));
	i = strlen(file);
	file[i++] = '/';
	plen = i;

	p = name;
	while (*p) {
		if (!isalnum((unsigned char)*p)) {
			if (i != plen)
				file[i++] = '_';
		} else
			file[i++] = *p;
		p++;
	}

	file[i] = '\0';

	return (file);
}

/*
 * Converts a executeable name into the corresponding filename
 * that contains the security policy.
 */

char *
systrace_getpolicyname(const char *name)
{
	char *file = NULL;

	if (userpolicy) {
		file = systrace_policyfilename(policydir, name);
		/* Check if the user policy file exists */
		if (file != NULL && access(file, R_OK) == -1)
			file = NULL;
	}

	/* Read global policy */
	if (file == NULL)
		file = systrace_policyfilename(POLICY_PATH, name);

	return (file);
}

int
systrace_addpolicy(const char *name)
{
	char *file;

	if ((file = systrace_getpolicyname(name)) == NULL)
		return (-1);

	return (systrace_readpolicy(file) != NULL ? 0 : -1);
}

/* 
 * Reads policy templates from the template directory.
 * These policies can be inserted during interactive policy
 * generation.
 */

int
systrace_templatedir(void)
{
	char filename[PATH_MAX];
	DIR *dir = NULL;
	struct stat sb;
	struct dirent *dp;
	struct template *template;
	int off;

	TAILQ_INIT(&templates);

	if (userpolicy) {
		if (strlcpy(filename, policydir, sizeof(filename)) >=
		    sizeof(filename))
			goto error;
		if (strlcat(filename, "/templates", sizeof(filename)) >=
		    sizeof(filename))
			goto error;

		/* Check if template directory exists */
		if (stat(filename, &sb) != -1 && S_ISDIR(sb.st_mode))
			dir = opendir(filename);
	}

	/* Read global policy */
	if (dir == NULL) {
		strlcpy(filename, POLICY_PATH, sizeof(filename));
		strlcat(filename, "/templates", sizeof(filename));
		if (stat(filename, &sb) != -1 && S_ISDIR(sb.st_mode))
			dir = opendir(filename);
		if (dir == NULL)
			return (-1);
	}

	if (strlcat(filename, "/", sizeof(filename)) >= sizeof(filename))
		goto error;
	off = strlen(filename);

	while ((dp = readdir(dir)) != NULL) {
		filename[off] = '\0';
		if (strlcat(filename, dp->d_name, sizeof(filename)) >=
		    sizeof(filename))
			goto error;

		if (stat(filename, &sb) == -1 || !S_ISREG(sb.st_mode))
			continue;

		template = systrace_readtemplate(filename, NULL, NULL);
		if (template == NULL)
			continue;

		TAILQ_INSERT_TAIL(&templates, template, next);
	}
	closedir(dir);

	return (0);

 error:
	errx(1, "%s: template name too long", __func__);

	/* NOTREACHED */
}

struct template *
systrace_readtemplate(char *filename, struct policy *policy,
    struct template *template)
{
	FILE *fp;
	char line[_POSIX2_LINE_MAX], *p;
	char *emulation, *name, *description;
	int linenumber = 0;
	
	if ((fp = fopen(filename, "r")) == NULL)
		return (NULL);

	/* Set up pid with current information */
	while (fgets(line, sizeof(line), fp)) {
		linenumber++;

		if ((p = systrace_policyline(line)) == NULL) {
			fprintf(stderr, "%s:%d: input line too long.\n",
			    filename, linenumber);
			template = NULL;
			goto out;
		}

		if (strlen(p) == 0)
			continue;

		if (!strncasecmp(p, "Template: ", 10)) {
			p += 10;
			name = strsep(&p, ",");
			if (p == NULL)
				goto error;
			if (strncasecmp(p, " Emulation: ", 12))
				goto error;
			p += 12;
			emulation = strsep(&p, ", ");
			if (p == NULL)
				goto error;
			if (strncasecmp(p, " Description: ", 14))
				goto error;
			p += 14;
			description = p;

			if (template != NULL)
				continue;
			
			template = calloc(1, sizeof(struct template));
			if (template == NULL)
				err(1, "calloc");

			template->filename = strdup(filename);
			template->name = strdup(name);
			template->emulation = strdup(emulation);
			template->description = strdup(description);

			if (template->filename == NULL ||
			    template->name == NULL ||
			    template->emulation == NULL ||
			    template->description == NULL)
				err(1, "strdup");

			continue;
		}

		if (policy == NULL)
			goto out;

		if (systrace_policyprocess(policy, p) == -1)
			goto error;
	}

 out:
	fclose(fp);
	return (template);

 error:
	fprintf(stderr, "%s:%d: syntax error.\n", filename, linenumber);
	goto out;
}

/*
 * Removes trailing whitespace and comments from the input line
 */

static char *
systrace_policyline(char *line)
{
	char *p;
	int quoted = 0;

	if ((p = strchr(line, '\n')) == NULL)
		return (NULL);
	*p = '\0';

	/* Remove comments from the input line but ignore # that are part
	 * of the system call name or within quotes.
	 */
	for (p = line; *p; p++) {
		if (*p == '"')
			quoted = quoted ? 0 : 1;
		if (*p == '#') {
			if (quoted)
				continue;
			if (p != line && *(p-1) == '-')
				continue;
			*p = '\0';
			break;
		}
	}

	/* Remove trailing white space */
	p = line + strlen(line) - 1;
	while (p > line) {
		if (!isspace((unsigned char)*p))
			break;
		*p-- = '\0';
	}

	/* Ignore white space at start of line */
	p = line;
	p += strspn(p, " \t");

	return (p);
}

/*
 * Parse a single line from a policy and convert it into a policy filter.
 * Predicates are matched.
 */

static int
systrace_policyprocess(struct policy *policy, char *p)
{
	char line[_POSIX2_LINE_MAX];
	char *name, *emulation, *rule;
	struct filter *filter, *parsed;
	short action, future;
	int  resolved = 0, res, isvalid;

	/* Delay predicate evaluation if we are root */

	emulation = strsep(&p, "-");
	if (p == NULL || *p == '\0')
		return (-1);

	if (strcmp(emulation, policy->emulation))
		return (-1);

	name = strsep(&p, ":");
	if (p == NULL || *p != ' ')
		return (-1);

	isvalid = intercept_isvalidsystemcall(emulation, name);

	p++;
	rule = p;

	if ((p = strrchr(p, ',')) != NULL && !strncasecmp(p, ", if", 4)) {
		*p = '\0';
		res = filter_parse_simple(rule, &action, &future);
		*p = ',';
		if (res == 0) {
			/* Need to make a real policy out of it */
			snprintf(line, sizeof(line), "true then %s", rule);
			rule = line;
		}
	} else if (filter_parse_simple(rule, &action, &future) == 0)
		resolved = 1;

	/*
	 * For now, everything that does not seem to be a valid syscall
	 * does not get fast kernel policies even though the aliasing
	 * system supports it.
	 */
	if (resolved && !isvalid) {
		resolved = 0;
		snprintf(line, sizeof(line), "true then %s", rule);
		rule = line;
	}

	/* If the simple parser did not match, try real parser */
	if (!resolved) {
		if (parse_filter(rule, &parsed) == -1)
			return (-1);

		filter_free(parsed);
	}

	filter = calloc(1, sizeof(struct filter));
	if (filter == NULL)
		err(1, "%s:%d: calloc", __func__, __LINE__);

	filter->rule = strdup(rule);
	if (filter->rule == NULL)
		err(1, "%s:%d: strdup", __func__, __LINE__);

	strlcpy(filter->name, name, sizeof(filter->name));
	strlcpy(filter->emulation,  emulation, sizeof(filter->emulation));

	TAILQ_INSERT_TAIL(&policy->prefilters, filter, policy_next);

	return (0);
}

/*
 * Reads security policy from specified file.
 * If policy exists already, this function appends new statements from the
 * file to the existing policy.
 */

struct policy *
systrace_readpolicy(const char *filename)
{
	FILE *fp;
	struct policy *policy;
	char line[_POSIX2_LINE_MAX], *p;
	char *emulation, *name;
	int linenumber = 0;
	int res = -1;

	if ((fp = fopen(filename, "r")) == NULL)
		return (NULL);

	policy = NULL;
	while (fgets(line, sizeof(line), fp)) {
		linenumber++;

		if ((p = systrace_policyline(line)) == NULL) {
			fprintf(stderr, "%s:%d: input line too long.\n",
			    filename, linenumber);
			goto out;
		}

		if (strlen(p) == 0)
			continue;

		if (!strncasecmp(p, "Policy: ", 8)) {
			struct timeval now;

			p += 8;
			name = strsep(&p, ",");
			if (p == NULL)
				goto error;
			if (strncasecmp(p, " Emulation: ", 12))
				goto error;
			p += 12;
			emulation = p;

			policy = systrace_newpolicy(emulation, name);
			if (policy == NULL)
				goto error;

			/* Update access time */
			gettimeofday(&now, NULL);
			TIMEVAL_TO_TIMESPEC(&now, &policy->ts_last);
			continue;
		}

		if (policy == NULL)
			goto error;

		if (!strncasecmp(p, "detached", 8)) {
			policy->flags |= POLICY_DETACHED;
			policy = NULL;
			continue;
		}

		if (systrace_policyprocess(policy, p) == -1)
			goto error;
	}
	res = 0;

 out:
	fclose(fp);
	return (res == -1 ? NULL : policy);

 error:
	fprintf(stderr, "%s:%d: syntax error.\n", filename, linenumber);
	goto out;
}

/*
 * Appends new policy statements if the policy has been updated by
 * another process.  Assumes that policies are append-only.
 *
 * Returns:
 *	-1	if the policy could not be updated.
 *	 0	if the policy has been updated.
 */

int
systrace_updatepolicy(int fd, struct policy *policy)
{
	struct stat sb;
	struct timespec mtimespec;
	int i, policynr = policy->policynr;
	char *file;

	if ((file = systrace_getpolicyname(policy->name)) == NULL)
		return (-1);

	if (stat(file, &sb) == -1)
		return (-1);

	mtimespec = sb.st_mtimespec;

	/* Policy does not need updating */
	if (timespeccmp(&mtimespec, &policy->ts_last, <=))
		return (-1);

	/* Reset the existing policy */
	for (i = 0; i < INTERCEPT_MAXSYSCALLNR; i++) {
		if (policy->kerneltable[i] == ICPOLICY_ASK)
			continue;
		if (intercept_modifypolicy_nr(fd, policynr, i,
		    ICPOLICY_ASK) == -1)
			errx(1, "%s: failed to modify policy for %d",
			    __func__, i);
	}

	/* Now clean up all filter structures in this policy */
	systrace_cleanpolicy(policy);

	/* XXX - This does not deal with Detached and Automatic */
	if (systrace_readpolicy(file) == NULL)
		return (-1);

	/* Resets the changed flag */
	filter_prepolicy(fd, policy);

	return (0);
}

int
systrace_writepolicy(struct policy *policy)
{
	FILE *fp;
	int fd;
	char *p;
	char tmpname[2*PATH_MAX];
	char finalname[2*PATH_MAX];
	struct filter *filter;
	struct timeval now;

	if ((p = systrace_policyfilename(policydir, policy->name)) == NULL)
		return (-1);
	strlcpy(finalname, p, sizeof(finalname));
	if ((p = systrace_policyfilename(policydir, "tmpXXXXXXXX")) == NULL)
		return (-1);
	strlcpy(tmpname, p, sizeof(tmpname));
	if ((fd = mkstemp(tmpname)) == -1 ||
	    (fp = fdopen(fd, "w+")) == NULL) {
		if (fd != -1) {
			unlink(tmpname);
			close(fd);
		}
		return (-1);
	}


	fprintf(fp, "Policy: %s, Emulation: %s\n",
	    policy->name, policy->emulation);
	if (policy->flags & POLICY_DETACHED) {
		fprintf(fp, "detached\n");
	} else {
		TAILQ_FOREACH(filter, &policy->prefilters, policy_next) {
			fprintf(fp, "\t%s-%s: %s\n",
			    filter->emulation, filter->name, filter->rule);
		}
		TAILQ_FOREACH(filter, &policy->filters, policy_next) {
			fprintf(fp, "\t%s-%s: %s\n",
			    filter->emulation, filter->name, filter->rule);
		}
	}
	fprintf(fp, "\n");
	fclose(fp);

	if (rename(tmpname, finalname) == -1) {
		warn("rename(%s, %s)", tmpname, finalname);
		return (-1);
	}

	/* Update access time */
	gettimeofday(&now, NULL);
	TIMEVAL_TO_TIMESPEC(&now, &policy->ts_last);

	return (0);
}

int
systrace_updatepolicies(int fd)
{
	struct policy *policy;

	SPLAY_FOREACH(policy, policytree, &policyroot) {
		/* Check if the policy has been updated */
		systrace_updatepolicy(fd, policy);
	}

	return (0);
}

/*
 * Write policy to disk if it has been changed.  We need to
 * call systrace_updatepolicies() before this, so that we
 * don't clobber changes.
 */

int
systrace_dumppolicies(int fd)
{
	struct policy *policy;

	SPLAY_FOREACH(policy, policytree, &policyroot) {
		if (!(policy->flags & POLICY_CHANGED))
			continue;

		if (systrace_writepolicy(policy) == -1)
			fprintf(stderr, "Failed to write policy for %s\n",
			    policy->name);
		else
			policy->flags &= ~POLICY_CHANGED;
	}

	return (0);
}
@


1.36
log
@rename a few variables/functions to avoid shadowing
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.35 2015/01/16 00:19:12 deraadt Exp $	*/
@


1.35
log
@move to PATH_MAX, etc; normalize includes for life in the <limits.h> universe
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.34 2013/11/21 15:54:46 deraadt Exp $	*/
d349 1
a349 1
systrace_policyfilename(char *dirname, const char *name)
d355 1
a355 1
	if (strlen(name) + strlen(dirname) + 1 >= sizeof(file))
d358 1
a358 1
	strlcpy(file, dirname, sizeof(file));
@


1.34
log
@add unsigned char casts for specific calls to ctype.h macros.
ok guenther step
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.33 2012/12/04 02:24:47 deraadt Exp $	*/
d103 1
a103 1
static char policydir[MAXPATHLEN];
d166 1
a166 1
	static char path[MAXPATHLEN], lookup[MAXPATHLEN];
d351 1
a351 1
	static char file[2*MAXPATHLEN];
d422 1
a422 1
	char filename[MAXPATHLEN];
d821 2
a822 2
	char tmpname[2*MAXPATHLEN];
	char finalname[2*MAXPATHLEN];
@


1.33
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.32 2006/09/19 10:48:41 otto Exp $	*/
d365 1
a365 1
		if (!isalnum(*p)) {
d595 1
a595 1
		if (!isspace(*p))
@


1.32
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which leads to surprising results. Spotted by/partly
from Paul Stoeber, more to come. ok ho@@ miod@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.31 2006/07/02 12:34:15 sturm Exp $	*/
a32 1
#include <sys/param.h>
@


1.31
log
@sync with systrace 1.6d, keeping local changes

tests and feedback by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.30 2006/03/18 19:03:23 robert Exp $	*/
d130 1
a130 1
		if (!(sb.st_mode & S_IFDIR))
d441 1
a441 1
		if (stat(filename, &sb) != -1 && (sb.st_mode & S_IFDIR))
d449 1
a449 1
		if (stat(filename, &sb) != -1 && (sb.st_mode & S_IFDIR))
d465 1
a465 1
		if (stat(filename, &sb) == -1 || !(sb.st_mode & S_IFREG))
@


1.30
log
@fix problems found by Coverity via NetBSD:
- systrace.c: Don't try to dereference pw when it's NULL.
Coverity CID 900
- parse.y: free allocated space on failure Coverity CID 1661
- policy.c: Change a return to "goto out" so that fclose will be called.
Coverity CID 1881

ok sturm@@, ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.29 2003/07/19 11:48:58 sturm Exp $	*/
d46 1
d148 1
a148 1
		return (systrace_readpolicy(file));
d164 28
d220 1
d226 3
d245 4
d253 1
a253 1
systrace_freepolicy(struct policy *policy)
d257 1
d259 3
a261 5
	if (policy->flags & POLICY_CHANGED) {
		if (systrace_writepolicy(policy) == -1)
			fprintf(stderr, "Failed to write policy for %s\n",
			    policy->name);
	}
d283 12
d333 1
a333 1
	int res;
d341 5
d379 7
a385 2
int
systrace_addpolicy(const char *name)
d397 1
a397 1
	if (file == NULL) {
a398 3
		if (file == NULL)
			return (-1);
	}
d400 12
a411 1
	return (systrace_readpolicy(file));
d480 2
d563 3
a565 1
/* Removes trailing whitespace and comments from the input line */
d652 2
a653 1
	/* For now, everything that does not seem to be a valid syscall
d687 8
a694 2
int
systrace_readpolicy(char *filename)
d704 1
a704 1
		return (-1);
d720 2
d734 4
d757 1
a757 1
	return (res);
d764 52
d825 1
d865 4
d873 20
a892 1
systrace_dumppolicy(void)
@


1.29
log
@- sync with NetBSD or Niels' tarball where appropriate
- keeps local changes
- fixes a bug in profile feedback optimization and avoids symbol
  conflicts with errno
- new feature: "ask" action

itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.28 2003/06/19 06:26:19 pvalchev Exp $	*/
d480 1
a480 1
			return (template);
@


1.28
log
@remove unused code which allocated useless memory (which was not freed)
ok provos itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.27 2003/06/16 06:36:40 itojun Exp $	*/
d132 1
a132 1
		err(1, "mdkdir(%s)", policydir);
@


1.27
log
@- limited number of processes per systrace
- escape fixes for special characters
markus, sturm ok.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.26 2003/06/02 02:03:51 itojun Exp $	*/
a103 2
static char *groupnames[NGROUPS_MAX];
static int ngroups;
a137 3
	gid_t groups[NGROUPS_MAX];
	int i;

a139 16

	/* Find out group names for current user */
	if ((ngroups = getgroups(NGROUPS_MAX, groups)) == -1)
		err(1, "getgroups");

	for (i = 0; i < ngroups; i++) {
		struct group *gr;

		if ((gr = getgrgid(groups[i])) != NULL) {
			if ((groupnames[i] = strdup(gr->gr_name)) == NULL)
				err(1, "strdup(%s)", gr->gr_name);
		} else {
			if (asprintf(&groupnames[i], "%u", groups[i]) == -1)
				errx(1, "asprintf: cannot allocate memory");
		}
	}
@


1.26
log
@prevents systrace from referencing freed memory; provos
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.25 2003/04/17 07:39:24 pvalchev Exp $	*/
d234 41
@


1.25
log
@use asprintf; fix (remove) some incorrectly sized buffers in the process
help & ok millert, miod, deraadt, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.24 2003/02/18 13:14:43 jmc Exp $	*/
d200 1
a200 1
		free(tmp);
@


1.24
log
@intial -> initial;

the great intial witch hunt, as prompted by tdeval@@

os-aix-dso.c: ok henning@@
ab.C: ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.23 2002/12/09 07:23:52 itojun Exp $	*/
a140 1
	char gidbuf[10];
d157 2
a158 4
			snprintf(gidbuf, sizeof(gidbuf), "%u",
			    groups[i]);
			if ((groupnames[i] = strdup(gidbuf)) == NULL)
				err(1, "strdup(%s)", gidbuf);
@


1.23
log
@better parsing of # comments.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.22 2002/12/09 07:22:53 itojun Exp $	*/
d226 1
a226 1
	/* New policies requires intialization */
@


1.22
log
@prevent the use of permit for aliases.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.21 2002/10/09 03:52:10 itojun Exp $	*/
d484 1
d490 11
a500 6
	/* Remove comments from the input line */
	p = strchr(line, '#');
	if (p != NULL) {
		if (p != line && *(p-1) == '-')
			p = strchr(p + 1, '#');
		if (p != NULL)
d502 2
@


1.21
log
@predicates are part of the grammar now; in non-root case, predicates are
evaluated only once; in root case, predicates and variable expansion are
dynamic.
from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.20 2002/09/23 04:41:02 itojun Exp $	*/
d525 1
a525 1
	int  resolved = 0, res;
d539 3
d556 10
@


1.20
log
@support for templates.  they allow fast generation of new policies. an
appropriate template can be inserted during initial policy generation.
from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.19 2002/09/17 05:10:58 itojun Exp $	*/
d55 2
a56 2
static int systrace_policyprocess(struct policy *, char *);
static int systrace_predicatematch(char *);
d411 1
a477 53
int
systrace_predicatematch(char *p)
{
	extern char *username;
	int i, res, neg;

	res = 0;
	neg = 0;

	if (!strncasecmp(p, "user", 4)) {
		/* Match against user name */
		p += 4;
		p += strspn(p, " \t");
		if (!strncmp(p, "=", 1)) {
			p += 1;
			neg = 0;
		} else if (!strncmp(p, "!=", 2)) {
			p += 2;
			neg = 1;
		} else
			return (-1);
		p += strspn(p, " \t");

		res = (!strcmp(p, username));
	} else if (!strncasecmp(p, "group", 5)) {
		/* Match against group list */
		p += 5;
		p += strspn(p, " \t");
		if (!strncmp(p, "=", 1)) {
			p += 1;
			neg = 0;
		} else if (!strncmp(p, "!=", 2)) {
			p += 2;
			neg = 1;
		} else
			return (-1);
		p += strspn(p, " \t");

		for (i = 0; i < ngroups; i++) {
			if (!strcmp(p, groupnames[i])) {
				res = 1;
				break;
			}
		}
	} else
		return (-1);

	if (neg)
		res = !res;

	return (res);
}

d521 1
d525 3
a542 2
		int match;

d544 9
d554 3
a556 6
		/* Process predicates */
		p += 4;
		p += strspn(p, " \t");

		match = systrace_predicatematch(p);
		if (match == -1)
a557 4
		/* If the predicate does not match skip rule */
		if (!match)
			return (0);
	}
a558 3
	if (filter_parse_simple(rule, &action, &future) == -1) {
		if (parse_filter(rule, &parsed) == -1)
			return (-1);
@


1.19
log
@split white space and single line policy processing into separate
functions.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.18 2002/09/16 04:34:46 itojun Exp $	*/
d36 1
d107 2
d165 1
a165 1
	if (userpolicy)
d167 2
d329 146
@


1.18
log
@periodically save policies that have been modified.  from provos

>here is a diff that will cause systrace to periodically save policies
>that have been modified.  Useful if you run systrace on an xterm and
>kill it accidently.  Or other applications like opera that are long
>running and can cause weird crashes.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.17 2002/09/06 22:56:21 deraadt Exp $	*/
d53 2
d58 2
d379 99
d484 1
a485 3
	char *name, *emulation, *rule;
	struct filter *filter, *parsed;
	short action, future;
d494 2
a495 1
		if ((p = strchr(line, '\n')) == NULL) {
a499 16
		*p = '\0';

		p = strchr(line, '#');
		if (p != NULL) {
			if (p != line && *(p-1) == '-')
				p = strchr(p + 1, '#');
			if (p != NULL)
				*p = '\0';
		}

		p = line + strlen(line) - 1;
		while (p > line) {
			if (!isspace(*p))
				break;
			*p-- = '\0';
		}
a500 2
		p = line;
		p += strspn(p, " \t");
d529 1
a529 9
		emulation = strsep(&p, "-");
		if (p == NULL || *p == '\0')
			goto error;

		if (strcmp(emulation, policy->emulation))
			goto error;

		name = strsep(&p, ":");
		if (p == NULL || *p != ' ')
a530 39
		p++;
		rule = p;

		if ((p = strrchr(p, ',')) != NULL &&
		    !strncasecmp(p, ", if", 4)) {
			int match;

			*p = '\0';

			/* Process predicates */
			p += 4;
			p += strspn(p, " \t");

			match = systrace_predicatematch(p);
			if (match == -1)
				goto error;
			/* If the predicate does not match skip rule */
			if (!match)
				continue;
		}

		if (filter_parse_simple(rule, &action, &future) == -1) {
			if (parse_filter(rule, &parsed) == -1)
				goto error;
			filter_free(parsed);
		}

		filter = calloc(1, sizeof(struct filter));
		if (filter == NULL)
			err(1, "%s:%d: calloc", __func__, __LINE__);

		filter->rule = strdup(rule);
		if (filter->rule == NULL)
			err(1, "%s:%d: strdup", __func__, __LINE__);

		strlcpy(filter->name, name, sizeof(filter->name));
		strlcpy(filter->emulation,emulation,sizeof(filter->emulation));

		TAILQ_INSERT_TAIL(&policy->prefilters, filter, policy_next);
d539 1
a539 2
	fprintf(stderr, "%s:%d: syntax error.\n",
	    filename, linenumber);
@


1.17
log
@standalone ; at top scope is illegal in ansi c
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.16 2002/08/30 17:09:21 itojun Exp $	*/
d570 2
@


1.16
log
@allow # in system call name. remove trailing white space.
from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.15 2002/08/07 00:34:17 vincent Exp $	*/
d66 2
a67 2
SPLAY_PROTOTYPE(syscalltree, policy_syscall, node, psccompare);
SPLAY_GENERATE(syscalltree, policy_syscall, node, psccompare);
d90 2
a91 2
SPLAY_PROTOTYPE(policytree, policy, node, policycompare);
SPLAY_GENERATE(policytree, policy, node, policycompare);
d93 2
a94 2
SPLAY_PROTOTYPE(polnrtree, policy, nrnode, polnrcompare);
SPLAY_GENERATE(polnrtree, policy, nrnode, polnrcompare);
@


1.15
log
@typo

ok provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.14 2002/08/05 23:27:53 provos Exp $	*/
d400 14
a413 2
		p = line;
		strsep(&p, "#");
@


1.14
log
@allow to specify an alternate directory for policy loading and writing
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.13 2002/07/19 14:38:58 itojun Exp $	*/
d490 1
a490 1
	fprintf(stderr, "%s:%d: systax error.\n",
@


1.13
log
@constify, have missing prototypes, use pedantic compilation options.
niels ok
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.12 2002/07/07 23:14:43 provos Exp $	*/
a51 1
static void systrace_setupdir(void);
d103 1
a103 1
systrace_setupdir(void)
d108 2
a109 1
	home = getenv("HOME");
d111 2
a112 2
	if (home == NULL)
		errx(1, "No HOME environment set");
d114 2
a115 2
	if (strlcpy(policydir, home, sizeof(policydir)) >= sizeof(policydir))
		errx(1, "HOME too long");
d117 5
a121 2
	if (strlcat(policydir, "/.systrace", sizeof(policydir)) >= sizeof(policydir))
		errx(1, "HOME too long");
d131 1
a131 1
systrace_initpolicy(char *file)
d159 1
a159 1
		systrace_setupdir();
@


1.12
log
@missing error checks on strdup. from cloder@@acm.org
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.11 2002/06/22 18:23:02 deraadt Exp $	*/
d49 8
d165 1
a165 1
systrace_findpolicy(char *name)
d201 1
a201 1
systrace_newpolicy(char *emulation, char *name)
d228 2
a229 1
systrace_policyflq(struct policy *policy, char *emulation, char *name)
d253 1
a253 1
systrace_modifypolicy(int fd, int policynr, char *name, short action)
d262 1
a262 1
		    name, action);
d268 1
a268 1
systrace_policyfilename(char *dirname, char *name)
d271 1
a271 1
	char *p;
d298 1
a298 1
systrace_addpolicy(char *name)
@


1.11
log
@gid is u_int
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.10 2002/06/19 16:31:07 provos Exp $	*/
d463 3
@


1.10
log
@more careful buffer handling; pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.9 2002/06/11 05:30:28 provos Exp $	*/
d140 2
a141 2
			snprintf(gidbuf, sizeof(gidbuf), "%lu",
			    (u_long)groups[i]);
@


1.9
log
@change a few buffers to 2*MAXPATHLEN; pob deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.8 2002/06/09 04:18:56 itojun Exp $	*/
a33 1

d36 1
d368 1
a368 1
	char line[1024], *p;
@


1.8
log
@allow numeric group ID (group ID appear in /etc/passwd, but not in /etc/group)
niels ok
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.7 2002/06/05 21:09:02 provos Exp $	*/
d261 1
a261 1
	static char file[MAXPATHLEN];
d486 2
a487 2
	char tmpname[MAXPATHLEN];
	char finalname[MAXPATHLEN];
@


1.7
log
@append predicate, instead of prepending.  makes rules sortable again.
pointed out by dugsong@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.6 2002/06/05 20:52:47 provos Exp $	*/
d123 1
d136 9
a144 4
		if ((gr = getgrgid(groups[i])) == NULL)
			err(1, "getgrgid(%d)", groups[i]);
		if ((groupnames[i] = strdup(gr->gr_name)) == NULL)
			err(1, "strdup(%s)", gr->gr_name);
@


1.6
log
@support simple predicates to prefix rules.  Allows global policies to be
different for different users.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.5 2002/06/04 23:05:26 provos Exp $	*/
a412 19
		} else if (!strncasecmp(p, "if", 2)) {
			int match;
			char *predicate;

			/* Process predicates */
			p += 2;
			p += strspn(p, " \t");
			predicate = strsep(&p, ",");
			if (p == NULL)
				goto error;

			match = systrace_predicatematch(predicate);
			if (match == -1)
				goto error;
			/* If the predicate does not match skip rule */
			if (!match)
				continue;

			p += strspn(p, " \t");
d427 18
@


1.5
log
@setup user systrace dir only if user policies are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.4 2002/06/04 20:13:19 provos Exp $	*/
d40 1
d91 3
a93 1
char policydir[MAXPATHLEN];
d122 3
d128 13
d305 53
d413 19
@


1.4
log
@add flag to ignore user specified policies
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.3 2002/06/04 19:15:54 deraadt Exp $	*/
d88 2
d122 2
a123 1
	systrace_setupdir();
a266 1
	extern int userpolicy;
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.2 2002/06/04 19:07:04 provos Exp $	*/
d263 2
a264 1
	char *file;
d266 9
a274 4
	if ((file = systrace_policyfilename(policydir, name)) == NULL)
		return (-1);
	/* Check if the user policy file exists */
	if (access(file, R_OK) == -1) {
@


1.2
log
@__FUNCTION__ -> __func__ from espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.1 2002/06/04 17:20:04 provos Exp $	*/
d74 1
a74 1
	
d301 1
a301 1
		
d325 1
a325 1
		
d357 1
a357 1
		
@


1.1
log
@initial import of systrace.  don't touch this, more stuff coming in a while
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d180 1
a180 1
		err(1, "%s:%d: strdup", __FUNCTION__, __LINE__);
d204 1
a204 1
		err(1, "%s:%d: out of memory", __FUNCTION__, __LINE__);
d356 1
a356 1
			err(1, "%s:%d: calloc", __FUNCTION__, __LINE__);
@

