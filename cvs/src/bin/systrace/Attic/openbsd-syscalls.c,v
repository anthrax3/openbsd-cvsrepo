head	1.48;
access;
symbols
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.45.0.6
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.44.0.6
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.44.0.4
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.43.0.2
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.41.0.6
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.4
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.2
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.38.0.4
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.32.0.10
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.12
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.8
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.6
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.4
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.31.0.4
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.28.0.6
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.4
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13;
locks; strict;
comment	@ * @;


1.48
date	2016.04.25.19.09.25;	author tedu;	state dead;
branches;
next	1.47;
commitid	Ne4KgWE1uInoydsl;

1.47
date	2016.03.01.16.26.06;	author naddy;	state Exp;
branches;
next	1.46;
commitid	xolw6dPbpLrdT9Jj;

1.46
date	2015.12.09.19.36.17;	author mmcc;	state Exp;
branches;
next	1.45;
commitid	8oyfVibTyuKjsb15;

1.45
date	2015.01.16.00.19.12;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	9JSDzKTCgxU6o5el;

1.44
date	2013.10.17.10.21.58;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2013.04.29.00.28.23;	author okan;	state Exp;
branches;
next	1.42;

1.42
date	2013.04.03.03.36.25;	author guenther;	state Exp;
branches;
next	1.41;

1.41
date	2011.09.18.23.24.14;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.04.22.59.42;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.05.15.22.51;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2010.07.05.22.26.20;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.02.20.00.54;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2010.07.01.17.26.52;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.30.20.46.51;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.29.20.30.32;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.29.17.32.51;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.29.01.02.21;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2006.07.02.12.34.15;	author sturm;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.02.19.49.05;	author sturm;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.01.11.48.45;	author sturm;	state Exp;
branches;
next	1.28;

1.28
date	2004.07.09.23.51.42;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2004.07.09.23.42.50;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2004.07.09.21.53.55;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.07.07.31.40;	author marius;	state Exp;
branches;
next	1.24;

1.24
date	2004.06.23.05.16.35;	author marius;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.22.21.03.35;	author sturm;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.08.16.32.44;	author sturm;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.23.20.01.57;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.19.11.48.58;	author sturm;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.16.06.36.40;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.04.17.40.06;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.26.03.50.58;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.26.03.48.07;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.16.15.01.08;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.09.03.52.10;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.28.03.54.35;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.28.03.30.27;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.07.21.27.15;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.30.09.16.19;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.22.04.02.39;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.19.14.38.58;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.06.19.14.19;	author nordin;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.21.15.26.06;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.10.19.16.26;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.04.19.15.54;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.04.19.09.45;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.04.19.07.04;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.04.17.20.04;	author provos;	state Exp;
branches;
next	;


desc
@@


1.48
log
@boom goes the dynamite
@
text
@/*	$OpenBSD: openbsd-syscalls.c,v 1.47 2016/03/01 16:26:06 naddy Exp $	*/
/*
 * Copyright 2002 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/types.h>

#include <sys/syscall.h>

#define KTRACE
#define PTRACE
#define NFSCLIENT
#define NFSSERVER
#define SYSVSEM
#define SYSVMSG
#define SYSVSHM
#include <kern/syscalls.c>
#undef KTRACE
#undef PTRACE
#undef NFSCLIENT
#undef NFSSERVER
#undef SYSVSEM
#undef SYSVMSG
#undef SYSVSHM

#include <limits.h>

#include <sys/ioctl.h>
#include <sys/tree.h>
#include <dev/systrace.h>

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <err.h>

#include "intercept.h"

struct emulation {
	const char *name;	/* Emulation name */
	char **sysnames;	/* Array of system call names */
	int  nsysnames;		/* Number of */
};

static struct emulation emulations[] = {
	{ "native",	syscallnames,		SYS_MAXSYSCALL },
	{ NULL,		NULL,			0 }
};

struct obsd_data {
	struct emulation *current;
	struct emulation *commit;
};

static int obsd_init(void);
static int obsd_attach(int, pid_t);
static int obsd_report(int, pid_t);
static int obsd_detach(int, pid_t);
static int obsd_open(void);
static struct intercept_pid *obsd_getpid(pid_t);
static void obsd_freepid(struct intercept_pid *);
static void obsd_clonepid(struct intercept_pid *, struct intercept_pid *);
static struct emulation *obsd_find_emulation(const char *);
static int obsd_set_emulation(pid_t, const char *);
static struct emulation *obsd_switch_emulation(struct obsd_data *);
static const char *obsd_syscall_name(pid_t, int);
static int obsd_syscall_number(const char *, const char *);
static short obsd_translate_policy(short);
static short obsd_translate_flags(short);
static int obsd_translate_errno(int);
static int obsd_answer(int, pid_t, u_int16_t, short, int, short,
    struct elevate *);
static int obsd_newpolicy(int);
static int obsd_assignpolicy(int, pid_t, int);
static int obsd_modifypolicy(int, int, int, short);
static int obsd_replace(int, pid_t, u_int16_t, struct intercept_replace *);
static int obsd_io(int, pid_t, int, void *, u_char *, size_t);
static int obsd_setcwd(int, pid_t, int);
static int obsd_restcwd(int);
static int obsd_argument(int, void *, int, void **);
static int obsd_read(int);
static int obsd_scriptname(int, pid_t, char *);

static int
obsd_init(void)
{
	return (0);
}

static int
obsd_attach(int fd, pid_t pid)
{
	if (ioctl(fd, STRIOCATTACH, &pid) == -1)
		return (-1);

	return (0);
}

static int
obsd_report(int fd, pid_t pid)
{
	if (ioctl(fd, STRIOCREPORT, &pid) == -1)
		return (-1);

	return (0);
}

static int
obsd_detach(int fd, pid_t pid)
{
	if (ioctl(fd, STRIOCDETACH, &pid) == -1)
		return (-1);

	return (0);
}

static int
obsd_open(void)
{
	char *path = "/dev/systrace";
	int fd, cfd = -1;

	fd = open(path, O_RDONLY, 0);
	if (fd == -1) {
		warn("open: %s", path);
		return (-1);
	}

	if (ioctl(fd, STRIOCCLONE, &cfd) == -1) {
		warn("ioctl(STRIOCCLONE)");
		goto out;
	}

	if (fcntl(cfd, F_SETFD, FD_CLOEXEC) == -1)
		warn("fcntl(F_SETFD)");

 out:
	close (fd);
	return (cfd);
}

static struct intercept_pid *
obsd_getpid(pid_t pid)
{
	struct intercept_pid *icpid;
	struct obsd_data *data;

	icpid = intercept_getpid(pid);
	if (icpid == NULL)
		return (NULL);
	if (icpid->data != NULL)
		return (icpid);

	if ((icpid->data = malloc(sizeof(struct obsd_data))) == NULL)
		err(1, "%s:%d: malloc", __func__, __LINE__);

	data = icpid->data;
	data->current = &emulations[0];
	data->commit = NULL;

	return (icpid);
}

static void
obsd_freepid(struct intercept_pid *ipid)
{
	free(ipid->data);
}

static void
obsd_clonepid(struct intercept_pid *opid, struct intercept_pid *npid)
{
	if (opid->data == NULL) {
		npid->data = NULL;
		return;
	}

	if ((npid->data = malloc(sizeof(struct obsd_data))) == NULL)
		err(1, "%s:%d: malloc", __func__, __LINE__);
	memcpy(npid->data, opid->data, sizeof(struct obsd_data));
}

static struct emulation *
obsd_find_emulation(const char *name)
{
	struct emulation *tmp;

	tmp = emulations;
	while (tmp->name) {
		if (!strcmp(tmp->name, name))
			break;
		tmp++;
	}

	if (!tmp->name)
		return (NULL);

	return (tmp);
}

static int
obsd_set_emulation(pid_t pidnr, const char *name)
{
	struct emulation *tmp;
	struct intercept_pid *pid;
	struct obsd_data *data;

	if ((tmp = obsd_find_emulation(name)) == NULL)
		return (-1);

	pid = intercept_getpid(pidnr);
	if (pid == NULL)
		return (-1);
	data = pid->data;

	data->commit = tmp;

	return (0);
}

static struct emulation *
obsd_switch_emulation(struct obsd_data *data)
{
	data->current = data->commit;
	data->commit = NULL;

	return (data->current);
}

static const char *
obsd_syscall_name(pid_t pidnr, int number)
{
	struct intercept_pid *pid;
	struct emulation *current;

	pid = obsd_getpid(pidnr);
	if (pid == NULL)
		return (NULL);
	current = ((struct obsd_data *)pid->data)->current;

	if (number < 0 || number >= current->nsysnames)
		return (NULL);

	return (current->sysnames[number]);
}

static int
obsd_syscall_number(const char *emulation, const char *name)
{
	struct emulation *current;
	int i;

	current = obsd_find_emulation(emulation);
	if (current == NULL)
		return (-1);

	for (i = 0; i < current->nsysnames; i++)
		if (!strcmp(name, current->sysnames[i]))
			return (i);

	return (-1);
}

static short
obsd_translate_policy(short policy)
{
	switch (policy) {
	case ICPOLICY_ASK:
		return (SYSTR_POLICY_ASK);
	case ICPOLICY_PERMIT:
		return (SYSTR_POLICY_PERMIT);
	case ICPOLICY_NEVER:
	default:
		return (SYSTR_POLICY_NEVER);
	}
}

static short
obsd_translate_flags(short flags)
{
	switch (flags) {
	case ICFLAGS_RESULT:
		return (SYSTR_FLAGS_RESULT);
	default:
		return (0);
	}
}

static int
obsd_translate_errno(int nerrno)
{
	return (nerrno);
}

static int
obsd_answer(int fd, pid_t pid, u_int16_t seqnr, short policy, int nerrno,
    short flags, struct elevate *elevate)
{
	struct systrace_answer ans;

	memset(&ans, 0, sizeof(ans));
	ans.stra_pid = pid;
	ans.stra_seqnr = seqnr;
	ans.stra_policy = obsd_translate_policy(policy);
	ans.stra_flags = obsd_translate_flags(flags);
	ans.stra_error = obsd_translate_errno(nerrno);

	if (elevate != NULL) {
		if (elevate->e_flags & ELEVATE_UID) {
			ans.stra_flags |= SYSTR_FLAGS_SETEUID;
			ans.stra_seteuid = elevate->e_uid;
		}
		if (elevate->e_flags & ELEVATE_GID) {
			ans.stra_flags |= SYSTR_FLAGS_SETEGID;
			ans.stra_setegid = elevate->e_gid;
		}
	}

	if (ioctl(fd, STRIOCANSWER, &ans) == -1)
		return (-1);

	return (0);
}

static int 
obsd_scriptname(int fd, pid_t pid, char *scriptname)
{
	struct systrace_scriptname sn;

	sn.sn_pid = pid;
	strlcpy(sn.sn_scriptname, scriptname, sizeof(sn.sn_scriptname));

	return (ioctl(fd, STRIOCSCRIPTNAME, &sn));
}

static int
obsd_newpolicy(int fd)
{
	struct systrace_policy pol;

	pol.strp_op = SYSTR_POLICY_NEW;
	pol.strp_num = -1;
	pol.strp_maxents = 512;

	if (ioctl(fd, STRIOCPOLICY, &pol) == -1)
		return (-1);

	return (pol.strp_num);
}

static int
obsd_assignpolicy(int fd, pid_t pid, int num)
{
	struct systrace_policy pol;

	pol.strp_op = SYSTR_POLICY_ASSIGN;
	pol.strp_num = num;
	pol.strp_pid = pid;

	if (ioctl(fd, STRIOCPOLICY, &pol) == -1)
		return (-1);

	return (0);
}

static int
obsd_modifypolicy(int fd, int num, int code, short policy)
{
	struct systrace_policy pol;

	pol.strp_op = SYSTR_POLICY_MODIFY;
	pol.strp_num = num;
	pol.strp_code = code;
	pol.strp_policy = obsd_translate_policy(policy);

	if (ioctl(fd, STRIOCPOLICY, &pol) == -1)
		return (-1);

	return (0);
}

static int
obsd_replace(int fd, pid_t pid, u_int16_t seqnr,
    struct intercept_replace *repl)
{
	struct systrace_replace replace;
	size_t len, off;
	int i, ret;

	memset(&replace, 0, sizeof(replace));

	for (i = 0, len = 0; i < repl->num; i++) {
		len += repl->len[i];
	}

	replace.strr_pid = pid;
	replace.strr_seqnr = seqnr;
	replace.strr_nrepl = repl->num;
	replace.strr_base = malloc(len);
	replace.strr_len = len;
	if (replace.strr_base == NULL)
		err(1, "%s: malloc", __func__);

	for (i = 0, off = 0; i < repl->num; i++) {
		replace.strr_argind[i] = repl->ind[i];
		replace.strr_offlen[i] = repl->len[i];
		if (repl->len[i] == 0) {
			replace.strr_off[i] = (size_t)repl->address[i];
			continue;
		}

		replace.strr_off[i] = off;
		memcpy(replace.strr_base + off,
		    repl->address[i], repl->len[i]);
		if (repl->flags[i] & ICTRANS_NOLINKS) {
			replace.strr_flags[i] = SYSTR_NOLINKS;
		} else
			replace.strr_flags[i] = 0;

		off += repl->len[i];
	}

	ret = ioctl(fd, STRIOCREPLACE, &replace);
	if (ret == -1 && errno != EBUSY) {
		warn("%s: ioctl", __func__);
	}

	free(replace.strr_base);
	
	return (ret);
}

static int
obsd_io(int fd, pid_t pid, int op, void *addr, u_char *buf, size_t size)
{
	struct systrace_io io;
	extern int ic_abort;

	memset(&io, 0, sizeof(io));
	io.strio_pid = pid;
	io.strio_addr = buf;
	io.strio_len = size;
	io.strio_offs = addr;
	io.strio_op = (op == INTERCEPT_READ ? SYSTR_READ : SYSTR_WRITE);
	if (ioctl(fd, STRIOCIO, &io) == -1) {
		if (errno == EBUSY)
			ic_abort = 1;
		return (-1);
	}

	return (0);
}

static int
obsd_setcwd(int fd, pid_t pid, int atfd)
{
	struct systrace_getcwd gd;
	gd.strgd_pid = pid;
	gd.strgd_atfd = atfd;
	return (ioctl(fd, STRIOCGETCWD, &gd));
}

static int
obsd_restcwd(int fd)
{
	int res;
	if ((res = ioctl(fd, STRIOCRESCWD, 0)) == -1)
		warn("%s: ioctl", __func__); /* XXX */

	return (res);
}

static int
obsd_argument(int off, void *pargs, int argsize, void **pres)
{
	register_t *args = (register_t *)pargs;

	if (off >= argsize / sizeof(register_t))
		return (-1);

	*pres = (void *)args[off];

	return (0);
}

static int
obsd_read(int fd)
{
	struct str_message msg;
	struct intercept_pid *icpid;
	struct obsd_data *data;
	struct emulation *current;

	char name[SYSTR_EMULEN+1];
	const char *sysname;
	u_int16_t seqnr;
	pid_t pid;
	int code;

	if (read(fd, &msg, sizeof(msg)) != sizeof(msg))
		return (-1);

	icpid = obsd_getpid(msg.msg_pid);
	if (icpid == NULL)
		return (-1);
	data = icpid->data;

	current = data->current;
	
	seqnr = msg.msg_seqnr;
	pid = msg.msg_pid;
	switch (msg.msg_type) {
	case SYSTR_MSG_ASK:
		code = msg.msg_data.msg_ask.code;
		sysname = obsd_syscall_name(pid, code);

		intercept_syscall(fd, pid, seqnr, msg.msg_policy,
		    sysname, code, current->name,
		    (void *)msg.msg_data.msg_ask.args,
		    msg.msg_data.msg_ask.argsize);
		break;

	case SYSTR_MSG_RES:
		code = msg.msg_data.msg_ask.code;
		sysname = obsd_syscall_name(pid, code);

		/* Switch emulation around at the right time */
		if (data->commit != NULL) {
			current = obsd_switch_emulation(data);
		}

		intercept_syscall_result(fd, pid, seqnr, msg.msg_policy,
		    sysname, code, current->name,
		    (void *)msg.msg_data.msg_ask.args,
		    msg.msg_data.msg_ask.argsize,
		    msg.msg_data.msg_ask.result,
		    msg.msg_data.msg_ask.rval);
		break;

	case SYSTR_MSG_EMUL:
		memcpy(name, msg.msg_data.msg_emul.emul, SYSTR_EMULEN);
		name[SYSTR_EMULEN] = '\0';

		if (obsd_set_emulation(pid, name) == -1)
			errx(1, "%s:%d: set_emulation(%s)",
			    __func__, __LINE__, name);

		if (icpid->execve_code == -1) {
			icpid->execve_code = 0;

			/* A running attach fake a exec cb */
			current = obsd_switch_emulation(data);

			intercept_syscall_result(fd,
			    pid, seqnr, msg.msg_policy,
			    "execve", 0, current->name,
			    NULL, 0, 0, NULL);
			break;
		}

		if (obsd_answer(fd, pid, seqnr, 0, 0, 0, NULL) == -1)
			err(1, "%s:%d: answer", __func__, __LINE__);
		break;

	case SYSTR_MSG_UGID: {
		struct str_msg_ugid *msg_ugid;
		
		msg_ugid = &msg.msg_data.msg_ugid;

		intercept_ugid(icpid, msg_ugid->uid, msg_ugid->uid);

		if (obsd_answer(fd, pid, seqnr, 0, 0, 0, NULL) == -1)
			err(1, "%s:%d: answer", __func__, __LINE__);
		break;
	}
	case SYSTR_MSG_CHILD:
		intercept_child_info(msg.msg_pid,
		    msg.msg_data.msg_child.new_pid);
		break;
#ifdef SYSTR_MSG_EXECVE
	case SYSTR_MSG_EXECVE: {
		struct str_msg_execve *msg_execve = &msg.msg_data.msg_execve;
		
		intercept_newimage(fd, pid, msg.msg_policy, current->name,
		    msg_execve->path, NULL);

		if (obsd_answer(fd, pid, seqnr, 0, 0, 0, NULL) == -1)
			err(1, "%s:%d: answer", __func__, __LINE__);
		break;
	}
#endif

#ifdef SYSTR_MSG_POLICYFREE
	case SYSTR_MSG_POLICYFREE:
		intercept_policy_free(msg.msg_policy);
		break;
#endif
	}
	return (0);
}

struct intercept_system intercept = {
	"openbsd",
	obsd_init,
	obsd_open,
	obsd_attach,
	obsd_detach,
	obsd_report,
	obsd_read,
	obsd_syscall_number,
	obsd_setcwd,
	obsd_restcwd,
	obsd_io,
	obsd_argument,
	obsd_answer,
	obsd_newpolicy,
	obsd_assignpolicy,
	obsd_modifypolicy,
	obsd_replace,
	obsd_clonepid,
	obsd_freepid,
	obsd_scriptname,
};
@


1.47
log
@drop Linux emulation support; ok sthen@@ visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.46 2015/12/09 19:36:17 mmcc Exp $	*/
@


1.46
log
@Remove NULL-check before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.45 2015/01/16 00:19:12 deraadt Exp $	*/
a34 2
#include <compat/linux/linux_syscall.h>

a42 2

#include <compat/linux/linux_syscalls.c>
a74 1
	{ "linux",	linux_syscallnames,	LINUX_SYS_MAXSYSCALL },
@


1.45
log
@move to PATH_MAX, etc; normalize includes for life in the <limits.h> universe
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.44 2013/10/17 10:21:58 deraadt Exp $	*/
d200 1
a200 2
	if (ipid->data != NULL)
		free(ipid->data);
@


1.44
log
@a.out emulation went away
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.43 2013/04/29 00:28:23 okan Exp $	*/
a31 1
#include <sys/param.h>
d54 2
@


1.43
log
@use FD_CLOEXEC instead of 1; from David Hill

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.42 2013/04/03 03:36:25 guenther Exp $	*/
a77 1
	{ "aout",	syscallnames,		SYS_MAXSYSCALL },
@


1.42
log
@LFS option is long gone
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.41 2011/09/18 23:24:14 matthew Exp $	*/
d167 1
a167 1
	if (fcntl(cfd, F_SETFD, 1) == -1)
@


1.41
log
@Add support for *at(2) system calls to systrace(1).

ok deraadt@@, sthen@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.40 2011/07/04 22:59:42 tedu Exp $	*/
a44 1
#define LFS
a54 1
#undef LFS
@


1.40
log
@remove compat_svr4
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.39 2011/04/05 15:22:51 guenther Exp $	*/
d113 1
a113 1
static int obsd_setcwd(int, pid_t);
d491 1
a491 1
obsd_setcwd(int fd, pid_t pid)
d493 4
a496 1
	return (ioctl(fd, STRIOCGETCWD, &pid));
@


1.39
log
@Remove FREEBSD_COMPAT bits and obsolete RTHREAD define
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.38 2010/07/05 22:26:20 tedu Exp $	*/
a36 1
#include <compat/svr4/svr4_syscall.h>
a48 1
#include <compat/svr4/svr4_syscalls.c>
a81 1
	{ "svr4",	svr4_syscallnames,	SVR4_SYS_MAXSYSCALL },
@


1.38
log
@compat_bsdos is gone
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.37 2010/07/02 20:00:54 tedu Exp $	*/
a35 1
#include <compat/freebsd/freebsd_syscall.h>
a46 1
#define RTHREADS
a48 1
#include <compat/freebsd/freebsd_syscalls.c>
a58 1
#undef RTHREADS
a84 1
	{ "freebsd",	freebsd_syscallnames,	FREEBSD_SYS_MAXSYSCALL },
@


1.37
log
@remove userland bits of compat_sunos
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.36 2010/07/01 17:26:52 tedu Exp $	*/
a35 1
#include <compat/bsdos/bsdos_syscall.h>
a50 1
#include <compat/bsdos/bsdos_syscalls.c>
a88 1
	{ "bsdos",	bsdos_syscallnames,	BSDOS_SYS_MAXSYSCALL },
@


1.36
log
@another day, another compat gets removed.  today is ibcs2's turn
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.35 2010/06/30 20:46:51 tedu Exp $	*/
a38 1
#include <compat/sunos/sunos_syscall.h>
a54 1
#include <compat/sunos/sunos_syscalls.c>
a89 1
	{ "sunos",	sunos_syscallnames,	SUNOS_SYS_MAXSYSCALL },
@


1.35
log
@remove compat_osf1.  ok deraadt miod
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.34 2010/06/29 20:30:32 guenther Exp $	*/
a37 1
#include <compat/ibcs2/ibcs2_syscall.h>
a54 1
#include <compat/ibcs2/ibcs2_syscalls.c>
a90 1
	{ "ibcs2",	ibcs2_syscallnames,	IBCS2_SYS_MAXSYSCALL },
@


1.34
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.33 2010/06/29 17:32:51 tedu Exp $	*/
a39 1
#include <compat/osf1/osf1_syscall.h>
a57 1
#include <compat/osf1/osf1_syscalls.c>
a94 1
	{ "osf1",	osf1_syscallnames,	OSF1_SYS_MAXSYSCALL },
@


1.33
log
@ultrix compat is going away...
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.32 2007/05/29 01:02:21 otto Exp $	*/
a37 3
#if defined(__hppa__) || defined(__m68k__)
#include <compat/hpux/hpux_syscall.h>
#endif
a56 3
#if defined(__hppa__) || defined(__m68k__)
#include <compat/hpux/hpux_syscalls.c>
#endif
a94 3
#if defined(__hppa__) || defined(__m68k__)
	{ "hpux",	hpux_syscallnames,	HPUX_SYS_MAXSYSCALL },
#endif
@


1.32
log
@remove compat netbsd stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.31 2006/07/02 12:34:15 sturm Exp $	*/
a45 1
#include <compat/ultrix/ultrix_syscall.h>
a67 1
#include <compat/ultrix/ultrix_syscalls.c>
a108 1
	{ "ultrix",	ultrix_syscallnames,	ULTRIX_SYS_MAXSYSCALL },
@


1.31
log
@sync with systrace 1.6d, keeping local changes

tests and feedback by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.30 2006/05/02 19:49:05 sturm Exp $	*/
a37 1
#include <compat/netbsd/netbsd_syscall.h>
a60 1
#include <compat/netbsd/netbsd_syscalls.c>
a113 1
	{ "netbsd",	netbsd_syscallnames,	NETBSD_SYS_MAXSYSCALL },
@


1.30
log
@some type cleanup

with feedback from kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.29 2006/01/01 11:48:45 sturm Exp $	*/
d460 2
@


1.29
log
@add PTRACE and RTHREADS defines
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.28 2004/07/09 23:51:42 deraadt Exp $	*/
d141 1
a141 1
static int obsd_answer(int, pid_t, u_int32_t, short, int, short,
d367 1
a367 1
obsd_answer(int fd, pid_t pid, u_int32_t seqnr, short policy, int nerrno,
@


1.28
log
@#ifdef hpux only for m68k or hppa; this needs a revisit since this shows
something flawed in the way that the emulation system calls are being
handled
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.27 2004/07/09 23:42:50 mickey Exp $	*/
d50 1
d57 1
d73 1
d80 1
@


1.27
log
@oops committed the old version
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.26 2004/07/09 21:53:55 mickey Exp $	*/
d39 1
d41 1
d61 1
d63 1
d101 1
d103 1
@


1.26
log
@better includes for syscalls from kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.25 2004/07/07 07:31:40 marius Exp $	*/
d39 1
a39 1
#include <compat/hpux/common/hpux_syscall.h>
d59 1
a59 1
#include <compat/hpux/common/hpux_syscalls.c>
@


1.25
log
@fix an issue when scripts are exec'd under systrace where
the argv[0] would be normalized, and hence break scripts
that depend on how they were called.

this fixes an issue in the ports builds.

ok provos@@ deraadt@@; lots of testing during hackathon sturm@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.24 2004/06/23 05:16:35 marius Exp $	*/
d36 10
a45 10
#include "../../sys/compat/bsdos/bsdos_syscall.h"
#include "../../sys/compat/freebsd/freebsd_syscall.h"
#include "../../sys/compat/netbsd/netbsd_syscall.h"
#include "../../sys/compat/hpux/hpux_syscall.h"
#include "../../sys/compat/ibcs2/ibcs2_syscall.h"
#include "../../sys/compat/linux/linux_syscall.h"
#include "../../sys/compat/osf1/osf1_syscall.h"
#include "../../sys/compat/sunos/sunos_syscall.h"
#include "../../sys/compat/svr4/svr4_syscall.h"
#include "../../sys/compat/ultrix/ultrix_syscall.h"
d54 1
a54 1
#include "../../sys/kern/syscalls.c"
d56 10
a65 10
#include "../../sys/compat/bsdos/bsdos_syscalls.c"
#include "../../sys/compat/freebsd/freebsd_syscalls.c"
#include "../../sys/compat/netbsd/netbsd_syscalls.c"
#include "../../sys/compat/hpux/hpux_syscalls.c"
#include "../../sys/compat/ibcs2/ibcs2_syscalls.c"
#include "../../sys/compat/linux/linux_syscalls.c"
#include "../../sys/compat/osf1/osf1_syscalls.c"
#include "../../sys/compat/sunos/sunos_syscalls.c"
#include "../../sys/compat/svr4/svr4_syscalls.c"
#include "../../sys/compat/ultrix/ultrix_syscalls.c"
@


1.24
log
@a few fixes to systrace

- add an exec message so that whenever a set-uid/gid process
  exec's a new image which we may control, the exec does not
  go by unnoticed.

- take special care to check for P_SUGIDEXEC as well as
  P_SUGID, corresponding to the same changes that were made in
  the ptrace code a while ago

ok niels@@, sturm@@; thanks to naddy for testing
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.23 2003/10/22 21:03:35 sturm Exp $	*/
d142 1
d386 11
d678 1
@


1.23
log
@from NetBSD:

initialise an integer field with 0 instead of NULL

ok provos, itojun, avsm, fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.22 2003/10/08 16:32:44 sturm Exp $	*/
d624 13
@


1.22
log
@originally from cb@@openbsd.org, adapted by provos

itojun@@ ok

fix a race condition between path resolution in userland
and the subsequent namei(): inform the kernel portion of
valid filenames and then disallow symlink lookups for
those filenames by means of a hook in namei().
with suggestions from provos@@

also, add (currently unused) seqnr field to struct
systrace_replace, from provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.21 2003/08/23 20:01:57 fgsch Exp $	*/
d107 1
a107 1
	{ NULL,		NULL,			NULL }
@


1.21
log
@teach systrace about "aout" emul; henning@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.19 2003/06/16 06:36:40 itojun Exp $	*/
d136 1
a136 1
static int obsd_replace(int, pid_t, struct intercept_replace *);
d432 2
a433 1
obsd_replace(int fd, pid_t pid, struct intercept_replace *repl)
d444 1
d462 4
@


1.20
log
@- sync with NetBSD or Niels' tarball where appropriate
- keeps local changes
- fixes a bug in profile feedback optimization and avoids symbol
  conflicts with errno
- new feature: "ask" action

itojun@@ ok
@
text
@d96 1
@


1.19
log
@- limited number of processes per systrace
- escape fixes for special characters
markus, sturm ok.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.18 2002/12/04 17:40:06 mickey Exp $	*/
d355 1
a355 1
obsd_answer(int fd, pid_t pid, u_int32_t seqnr, short policy, int errno,
d365 1
a365 1
	ans.stra_error = obsd_translate_errno(errno);
@


1.18
log
@rename to a new ioctl
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.17 2002/11/26 03:50:58 itojun Exp $	*/
d617 5
@


1.17
log
@avoid symbol conflict with "errno"
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.16 2002/11/26 03:48:07 itojun Exp $	*/
d187 2
a188 2
	if (ioctl(fd, SYSTR_CLONE, &cfd) == -1) {
		warn("ioctl(SYSTR_CLONE)");
@


1.16
log
@performance improvement by omitting a redundant getcwd.
from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.15 2002/10/16 15:01:08 itojun Exp $	*/
d349 1
a349 1
obsd_translate_errno(int errno)
d351 1
a351 1
	return (errno);
@


1.15
log
@support for privilege elevation.

with privilege elevation no suid or sgid binaries are necessary any
longer.  Applications can be executed completely
unprivileged. Systrace raises the privileges for a single system call
depending on the configured policy.

Idea from discussions with Perry Metzger, Dug Song and Marcus Watts.

from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.14 2002/10/09 03:52:10 itojun Exp $	*/
d137 1
a137 1
static char *obsd_getcwd(int, pid_t, char *, size_t);
d349 1
a349 1
obsd_translate_errno(int nerrno)
d351 1
a351 1
	return (nerrno);
d355 1
a355 1
obsd_answer(int fd, pid_t pid, u_int32_t seqnr, short policy, int nerrno,
d365 1
a365 1
	ans.stra_error = obsd_translate_errno(nerrno);
d494 2
a495 2
static char *
obsd_getcwd(int fd, pid_t pid, char *buf, size_t size)
d497 1
a497 10
	char *path;

	if (ioctl(fd, STRIOCGETCWD, &pid) == -1)
		return (NULL);

	path = getcwd(buf, size);
	if (path == NULL)
		obsd_restcwd(fd);

	return (path);
d630 1
a630 1
	obsd_getcwd,
@


1.14
log
@predicates are part of the grammar now; in non-root case, predicates are
evaluated only once; in root case, predicates and variable expansion are
dynamic.
from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.13 2002/08/28 03:54:35 itojun Exp $	*/
d130 2
a131 1
static int obsd_answer(int, pid_t, u_int32_t, short, int, short);
d356 1
a356 1
    short flags)
d360 1
d367 11
d607 1
a607 1
		if (obsd_answer(fd, pid, seqnr, 0, 0, 0) == -1)
d618 1
a618 1
		if (obsd_answer(fd, pid, seqnr, 0, 0, 0) == -1)
@


1.13
log
@avoid symbol conflict (errno)
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.12 2002/08/28 03:30:27 itojun Exp $	*/
d598 11
@


1.12
log
@fix systrace with chroot.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.11 2002/08/07 21:27:15 provos Exp $	*/
d348 1
a348 1
obsd_translate_errno(int errno)
d350 1
a350 1
	return (errno);
d354 1
a354 1
obsd_answer(int fd, pid_t pid, u_int32_t seqnr, short policy, int errno,
d363 1
a363 1
	ans.stra_error = obsd_translate_errno(errno);
@


1.11
log
@deal better with interrupted system calls
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.10 2002/07/30 09:16:19 itojun Exp $	*/
d490 3
@


1.10
log
@sync function decl and prototype (static-ness)
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.9 2002/07/22 04:02:39 provos Exp $	*/
d83 1
d451 1
a451 1
	if (ret == -1)
d453 1
d464 1
d472 3
a474 1
	if (ioctl(fd, STRIOCIO, &io) == -1)
d476 1
@


1.9
log
@add seqnr to message from kernel, userland needs to quote correct seqnr.
avoids problems where tsleep has been interrupted by a signal.
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.8 2002/07/19 14:38:58 itojun Exp $	*/
d475 1
a475 1
char *
@


1.8
log
@constify, have missing prototypes, use pedantic compilation options.
niels ok
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.7 2002/07/06 19:14:19 nordin Exp $	*/
d129 1
a129 1
static int obsd_answer(int, pid_t, short, int, short);
d353 2
a354 1
obsd_answer(int fd, pid_t pid, short policy, int errno, short flags)
d359 1
d520 2
d533 3
a535 1

d539 1
a539 1
		sysname = obsd_syscall_name(msg.msg_pid, code);
d541 1
a541 1
		intercept_syscall(fd, msg.msg_pid, msg.msg_policy,
d549 1
a549 1
		sysname = obsd_syscall_name(msg.msg_pid, code);
d556 1
a556 1
		intercept_syscall_result(fd, msg.msg_pid, msg.msg_policy,
d568 1
a568 1
		if (obsd_set_emulation(msg.msg_pid, name) == -1)
d579 1
a579 1
			    msg.msg_pid, msg.msg_policy,
d585 1
a585 1
		if (obsd_answer(fd, msg.msg_pid, 0, 0, 0) == -1)
@


1.7
log
@Remove kernel support for NTP. ok deraadt@@ and tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.6 2002/06/21 15:26:06 provos Exp $	*/
a86 6
/* Callback into main library */
void intercept_child_info(pid_t, pid_t);
void intercept_syscall(int, pid_t, int, char *, int, char *, void *, int);
void intercept_syscall_result(int, pid_t, int, char *, int, char *, void *,
    int, int, void *);

d88 1
a88 1
	char *name;		/* Emulation name */
d113 28
a140 1
int
d146 1
a146 1
int
d155 1
a155 1
int
d164 1
a164 1
int
d173 1
a173 1
int
d198 1
a198 1
struct intercept_pid *
d220 1
a220 1
void
d227 1
a227 1
void
d240 2
a241 2
struct emulation *
obsd_find_emulation(char *name)
d258 2
a259 2
int
obsd_set_emulation(pid_t pidnr, char *name)
d278 1
a278 1
struct emulation *
d287 1
a287 1
char *
d304 2
a305 2
int
obsd_syscall_number(char *emulation, char *name)
d321 1
a321 1
short
d335 1
a335 1
short
d346 1
a346 1
int
d352 1
a352 1
int
d368 1
a368 1
int
d383 1
a383 1
int
d398 1
a398 1
int
d414 1
a414 1
int
d456 1
a456 1
int
d485 1
a485 1
int
d495 1
a495 1
int
d508 1
a508 1
int
d516 2
a517 1
	char name[SYSTR_EMULEN+1], *sysname;
@


1.6
log
@rewrite all system call arguments in the permit case.  use realpath
when we still have the root and we of the monitored process.  this
eliminates almost all race coniditions.
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.6 2002/06/21 15:22:04 provos Exp $	*/
a53 1
#define NTP
a72 1
#undef NTP
@


1.5
log
@support attaching to a running process; some code by fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.4 2002/06/04 19:15:54 deraadt Exp $	*/
d396 42
d463 2
d466 5
a470 1
	if (ioctl(fd, STRIOCRESCWD, 0) == -1)
d473 1
a473 1
	return (path);
d581 1
d588 1
@


1.4
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.3 2002/06/04 19:09:45 provos Exp $	*/
d137 9
d259 9
d479 1
a479 2
			current = data->current = data->commit;
			data->commit = NULL;
d498 13
d529 1
@


1.3
log
@no absolute includes, changed to relatives; from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.2 2002/06/04 19:07:04 provos Exp $	*/
d184 1
a184 1
	
d444 1
a444 1
	switch(msg.msg_type) {
d476 1
a476 1
		    
@


1.2
log
@__FUNCTION__ -> __func__ from espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openbsd-syscalls.c,v 1.1 2002/06/04 17:20:04 provos Exp $	*/
d36 10
a45 10
#include "/sys/compat/bsdos/bsdos_syscall.h"
#include "/sys/compat/freebsd/freebsd_syscall.h"
#include "/sys/compat/netbsd/netbsd_syscall.h"
#include "/sys/compat/hpux/hpux_syscall.h"
#include "/sys/compat/ibcs2/ibcs2_syscall.h"
#include "/sys/compat/linux/linux_syscall.h"
#include "/sys/compat/osf1/osf1_syscall.h"
#include "/sys/compat/sunos/sunos_syscall.h"
#include "/sys/compat/svr4/svr4_syscall.h"
#include "/sys/compat/ultrix/ultrix_syscall.h"
d55 1
a55 1
#include "/sys/kern/syscalls.c"
d57 10
a66 10
#include "/sys/compat/bsdos/bsdos_syscalls.c"
#include "/sys/compat/freebsd/freebsd_syscalls.c"
#include "/sys/compat/netbsd/netbsd_syscalls.c"
#include "/sys/compat/hpux/hpux_syscalls.c"
#include "/sys/compat/ibcs2/ibcs2_syscalls.c"
#include "/sys/compat/linux/linux_syscalls.c"
#include "/sys/compat/osf1/osf1_syscalls.c"
#include "/sys/compat/sunos/sunos_syscalls.c"
#include "/sys/compat/svr4/svr4_syscalls.c"
#include "/sys/compat/ultrix/ultrix_syscalls.c"
@


1.1
log
@initial import of systrace.  don't touch this, more stuff coming in a while
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d183 1
a183 1
		err(1, "%s:%d: malloc", __FUNCTION__, __LINE__);
d208 1
a208 1
		err(1, "%s:%d: malloc", __FUNCTION__, __LINE__);
d405 1
a405 1
		warn("%s: ioctl", __FUNCTION__); /* XXX */
d479 1
a479 1
			    __FUNCTION__, __LINE__, name);
d482 1
a482 1
			err(1, "%s:%d: answer", __FUNCTION__, __LINE__);
@

