head	1.28;
access;
symbols
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.32
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.30
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.28
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.26
	OPENBSD_5_0:1.17.0.24
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.22
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.20
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.16
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.18
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.14
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.12
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.10
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.8
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.8
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.11.0.6
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.14
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.12
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.10
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.8
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.6
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2015.11.17.19.01.34;	author mmcc;	state Exp;
branches;
next	1.27;
commitid	RNKGm937BDNb5LTK;

1.27
date	2015.03.19.05.14.24;	author guenther;	state Exp;
branches;
next	1.26;
commitid	s0WKwITEr5aJPBA2;

1.26
date	2015.03.17.03.23.17;	author guenther;	state Exp;
branches;
next	1.25;
commitid	gv8qhyah1XKC6RDB;

1.25
date	2015.03.09.04.23.29;	author guenther;	state Exp;
branches;
next	1.24;
commitid	JMkpovMhu0rmLvCn;

1.24
date	2015.02.21.22.48.23;	author guenther;	state Exp;
branches
	1.24.2.1;
next	1.23;
commitid	AdteqX8nU06lUYnQ;

1.23
date	2015.02.11.23.14.46;	author guenther;	state Exp;
branches;
next	1.22;
commitid	lWdBzWkSKKObQ4Qj;

1.22
date	2015.02.05.22.32.20;	author sthen;	state Exp;
branches;
next	1.21;
commitid	QBujBhAFFXGSsgsF;

1.21
date	2015.02.05.07.49.25;	author guenther;	state Exp;
branches;
next	1.20;
commitid	4roKhm1wyg3vjc8b;

1.20
date	2015.01.16.06.39.32;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	Uu5nFG3wCl0LACBb;

1.19
date	2014.11.23.05.32.20;	author guenther;	state Exp;
branches;
next	1.18;
commitid	eLkSd1w0WMKVZRNV;

1.18
date	2014.01.30.13.30.11;	author espie;	state Exp;
branches
	1.18.6.1;
next	1.17;

1.17
date	2005.11.09.19.59.06;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.20.06.22.27;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.26.00.10.17;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.32.09;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.18.15.38.11;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.10.16.18.40.30;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.16.03.04.58;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.07.19.04.14;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.23.19.15.58;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.04.06.06.11.14;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.02.27.23.32.59;	author michaels;	state Exp;
branches;
next	1.6;

1.6
date	96.12.09.12.00.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.10.27.06.45.14;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.09.22.20.09.54;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.20.40;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.06.47.57;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.18;	author deraadt;	state Exp;
branches;
next	;

1.18.6.1
date	2015.04.30.19.30.57;	author guenther;	state Exp;
branches;
next	;
commitid	tPD1f2vGi43RT0WC;

1.24.2.1
date	2015.04.30.19.28.46;	author guenther;	state Exp;
branches;
next	;
commitid	pbBButXFqiIh89mX;


desc
@@


1.28
log
@int -> size_t for a len field

ok guenther@@, deraadt@@
@
text
@/*	$OpenBSD: pax.h,v 1.27 2015/03/19 05:14:24 guenther Exp $	*/
/*	$NetBSD: pax.h,v 1.3 1995/03/21 09:07:41 cgd Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pax.h	8.2 (Berkeley) 4/18/94
 */

/*
 * BSD PAX global data structures and constants.
 */

#define	MAXBLK		64512	/* MAX blocksize supported (posix SPEC) */
				/* WARNING: increasing MAXBLK past 32256 */
				/* will violate posix spec. */
#define	MAXBLK_POSIX	32256	/* MAX blocksize supported as per POSIX */
#define BLKMULT		512	/* blocksize must be even mult of 512 bytes */
				/* Don't even think of changing this */
#define DEVBLK		8192	/* default read blksize for devices */
#define FILEBLK		10240	/* default read blksize for files */
#define PAXPATHLEN	3072	/* maximum path length for pax. MUST be */
				/* longer than the system PATH_MAX */

/*
 * Pax modes of operation
 */
#define	LIST		0	/* List the file in an archive */
#define	EXTRACT		1	/* extract the files in an archive */
#define ARCHIVE		2	/* write a new archive */
#define APPND		3	/* append to the end of an archive */
#define	COPY		4	/* copy files to destination dir */
#define DEFOP		LIST	/* if no flags default is to LIST */

/*
 * Device type of the current archive volume
 */
#define ISREG		0	/* regular file */
#define ISCHR		1	/* character device */
#define ISBLK		2	/* block device */
#define ISTAPE		3	/* tape drive */
#define ISPIPE		4	/* pipe/socket */

/*
 * Pattern matching structure
 *
 * Used to store command line patterns
 */
typedef struct pattern {
	char		*pstr;		/* pattern to match, user supplied */
	char		*pend;		/* end of a prefix match */
	char		*chdname;	/* the dir to change to if not NULL.  */
	size_t		plen;		/* length of pstr */
	int		flgs;		/* processing/state flags */
#define MTCH		0x1		/* pattern has been matched */
#define DIR_MTCH	0x2		/* pattern matched a directory */
	struct pattern	*fow;		/* next pattern */
} PATTERN;

/*
 * General Archive Structure (used internal to pax)
 *
 * This structure is used to pass information about archive members between
 * the format independent routines and the format specific routines. When
 * new archive formats are added, they must accept requests and supply info
 * encoded in a structure of this type. The name fields are declared statically
 * here, as there is only ONE of these floating around, size is not a major
 * consideration. Eventually converting the name fields to a dynamic length
 * may be required if and when the supporting operating system removes all
 * restrictions on the length of pathnames it will resolve.
 */
typedef struct {
	int nlen;			/* file name length */
	char name[PAXPATHLEN+1];	/* file name */
	int ln_nlen;			/* link name length */
	char ln_name[PAXPATHLEN+1];	/* name to link to (if any) */
	char *org_name;			/* orig name in file system */
	PATTERN *pat;			/* ptr to pattern match (if any) */
	struct stat sb;			/* stat buffer see stat(2) */
	off_t pad;			/* bytes of padding after file xfer */
	off_t skip;			/* bytes of real data after header */
					/* IMPORTANT. The st_size field does */
					/* not always indicate the amount of */
					/* data following the header. */
	u_int32_t crc;			/* file crc */
	int type;			/* type of file node */
#define PAX_DIR		1		/* directory */
#define PAX_CHR		2		/* character device */
#define PAX_BLK		3		/* block device */
#define PAX_REG		4		/* regular file */
#define PAX_SLK		5		/* symbolic link */
#define PAX_SCK		6		/* socket */
#define PAX_FIF		7		/* fifo */
#define PAX_HLK		8		/* hard link */
#define PAX_HRG		9		/* hard link to a regular file */
#define PAX_CTG		10		/* high performance file */
#define PAX_GLL		11		/* GNU long symlink */
#define PAX_GLF		12		/* GNU long file */
} ARCHD;

#define PAX_IS_REG(type)	((type) == PAX_REG || (type) == PAX_CTG)
#define PAX_IS_HARDLINK(type)	((type) == PAX_HLK || (type) == PAX_HRG)
#define PAX_IS_LINK(type)	((type) == PAX_SLK || PAX_IS_HARDLINK(type))

/*
 * Format Specific Routine Table
 *
 * The format specific routine table allows new archive formats to be quickly
 * added. Overall pax operation is independent of the actual format used to
 * form the archive. Only those routines which deal directly with the archive
 * are tailored to the oddities of the specific format. All other routines are
 * independent of the archive format. Data flow in and out of the format
 * dependent routines pass pointers to ARCHD structure (described below).
 */
typedef struct {
	char *name;		/* name of format, this is the name the user */
				/* gives to -x option to select it. */
	int bsz;		/* default block size. used when the user */
				/* does not specify a blocksize for writing */
				/* Appends continue to with the blocksize */
				/* the archive is currently using. */
	int hsz;		/* Header size in bytes. this is the size of */
				/* the smallest header this format supports. */
				/* Headers are assumed to fit in a BLKMULT. */
				/* If they are bigger, get_head() and */
				/* get_arc() must be adjusted */
	int udev;		/* does append require unique dev/ino? some */
				/* formats use the device and inode fields */
				/* to specify hard links. when members in */
				/* the archive have the same inode/dev they */
				/* are assumed to be hard links. During */
				/* append we may have to generate unique ids */
				/* to avoid creating incorrect hard links */
	int hlk;		/* does archive store hard links info? if */
				/* not, we do not bother to look for them */
				/* during archive write operations */
	int blkalgn;		/* writes must be aligned to blkalgn boundary */
	int inhead;		/* is the trailer encoded in a valid header? */
				/* if not, trailers are assumed to be found */
				/* in invalid headers (i.e like tar) */
	int (*id)(char *,	/* checks if a buffer is a valid header */
	    int);		/* returns 1 if it is, o.w. returns a 0 */
	int (*st_rd)(void);	/* initialize routine for read. so format */
				/* can set up tables etc before it starts */
				/* reading an archive */
	int (*rd)(ARCHD *,	/* read header routine. passed a pointer to */
	    char *);		/* ARCHD. It must extract the info from the */
				/* format and store it in the ARCHD struct. */
				/* This routine is expected to fill all the */
				/* fields in the ARCHD (including stat buf) */
				/* 0 is returned when a valid header is */
				/* found. -1 when not valid. This routine */
				/* set the skip and pad fields so the format */
				/* independent routines know the amount of */
				/* padding and the number of bytes of data */
				/* which follow the header. This info is */
				/* used skip to the next file header */
	off_t (*end_rd)(void);	/* read cleanup. Allows format to clean up */
				/* and MUST RETURN THE LENGTH OF THE TRAILER */
				/* RECORD (so append knows how many bytes */
				/* to move back to rewrite the trailer) */
	int (*st_wr)(void);	/* initialize routine for write operations */
	int (*wr)(ARCHD *);	/* write archive header. Passed an ARCHD */
				/* filled with the specs on the next file to */
				/* archived. Returns a 1 if no file data is */
				/* is to be stored; 0 if file data is to be */
				/* added. A -1 is returned if a write */
				/* operation to the archive failed. this */
				/* function sets the skip and pad fields so */
				/* the proper padding can be added after */
				/* file data. This routine must NEVER write */
				/* a flawed archive header. */
	int (*end_wr)(void);	/* end write. write the trailer and do any */
				/* other format specific functions needed */
				/* at the end of an archive write */
	int (*trail)(ARCHD *,	/* returns 0 if a valid trailer, -1 if not */
	    char *, int,	/* For formats which encode the trailer */
	    int *);		/* outside of a valid header, a return value */
				/* of 1 indicates that the block passed to */
				/* it can never contain a valid header (skip */
				/* this block, no point in looking at it)  */
				/* CAUTION: parameters to this function are */
				/* different for trailers inside or outside */
				/* of headers. See get_head() for details */
	int (*options)(void);	/* process format specific options (-o) */
} FSUB;

/*
 * Time data for a given file.  This is usually embedded in a structure
 * indexed by dev+ino, by name, by order in the archive, etc.  set_attr()
 * takes one of these and will only change the times or mode if the file
 * at the given name has the indicated dev+ino.
 */
struct file_times {
	ino_t	ft_ino;			/* inode number to verify */
	struct	timespec ft_mtim;	/* times to set */
	struct	timespec ft_atim;
	char	*ft_name;		/* name of file to set the times on */
	dev_t	ft_dev;			/* device number to verify */
};

/*
 * Format Specific Options List
 *
 * Used to pass format options to the format options handler
 */
typedef struct oplist {
	char		*name;		/* option variable name e.g. name= */
	char		*value;		/* value for option variable */
	struct oplist	*fow;		/* next option */
} OPLIST;

/*
 * General Macros
 */
#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))
#define MAJOR(x)	major(x)
#define MINOR(x)	minor(x)
#define TODEV(x, y)	makedev((x), (y))

#define FILEBITS		(S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
#define SETBITS			(S_ISUID | S_ISGID)
#define ABITS			(FILEBITS | SETBITS)

/*
 * General Defines
 */
#define HEX		16
#define OCT		8
#define _PAX_		1
#define _TFILE_BASE	"paxXXXXXXXXXX"
@


1.27
log
@Use struct timespec internally.  This gives nanosecond precision to pax -rw
and a basis for support of mtime and atime values in pax-format extended
header records.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.26 2015/03/17 03:23:17 guenther Exp $	*/
d82 1
a82 1
	int		plen;		/* length of pstr */
@


1.26
log
@Add PAX_IS_{REG,HARDLINK,LINK} macros to simply many file type tests

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.25 2015/03/09 04:23:29 guenther Exp $	*/
d224 5
a228 5
	ino_t	ft_ino;		/* inode number to verify */
	time_t	ft_mtime;	/* times to set */
	time_t	ft_atime;
	char	*ft_name;	/* name of file to set the times on */
	dev_t	ft_dev;		/* device number to verify */
@


1.25
log
@Unrevert post-unlock:
* Prevent an archive from esacaping the current directory by itself:
  when extracting a symlink whose value is absolute or contains ".."
  components, just create a zero-length normal file (with additional
  tracking of the mode and hardlinks to the symlink) until everything
  else is extracted, then go back and replace it with the requested
  link (if it's still that zero-length placeholder).

* For tar without -P, if a path in the archive has any ".." components
  then strip everything up to and including the last of them (if
  it ends in ".." then it becomes ".")
  This mostly follows GNU tar's behavior, except for 'tar tf' and
  'tar xvf' we report the modified path that would be/was actually
  created instead of the raw path from the archive

  Above two fixes prompted by a report from Daniel Cegielka
  (daniel.cegielka (at) gmail.com)

* For directories whose times or mode will be fixed up in the
  clean-up pass, record their dev+ino and then use
  open(O_DIRECTORY)+fstat() to verify that we're updating the correct
  directory before using futimens() and fchmod().

* Correct buffer overflow in handling of pax extension headers,
  caught by the memcpy() overlap check.


previously ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.23 2015/02/11 23:14:46 guenther Exp $	*/
d129 4
@


1.24
log
@Recent changes haven't been completely stable, so revert for the 5.7 release

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.20 2015/01/16 06:39:32 deraadt Exp $	*/
d214 14
d245 4
@


1.24.2.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.24 2015/02/21 22:48:23 guenther Exp $	*/
a213 14
 * Time data for a given file.  This is usually embedded in a structure
 * indexed by dev+ino, by name, by order in the archive, etc.  set_attr()
 * takes one of these and will only change the times or mode if the file
 * at the given name has the indicated dev+ino.
 */
struct file_times {
	ino_t	ft_ino;		/* inode number to verify */
	time_t	ft_mtime;	/* times to set */
	time_t	ft_atime;
	char	*ft_name;	/* name of file to set the times on */
	dev_t	ft_dev;		/* device number to verify */
};

/*
a230 4

#define FILEBITS		(S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
#define SETBITS			(S_ISUID | S_ISGID)
#define ABITS			(FILEBITS | SETBITS)
@


1.23
log
@Take II, this time without an incorrect mode test.
For directories whose times or mode will be fixed up in the clean-up pass,
record their dev+ino and then use open(O_DIRECTORY)+fstat() to verify that
we're updating the correct directory before using futimens() and fchmod().

ok sthen@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.22 2015/02/05 22:32:20 sthen Exp $	*/
a213 14
 * Time data for a given file.  This is usually embedded in a structure
 * indexed by dev+ino, by name, by order in the archive, etc.  set_attr()
 * takes one of these and will only change the times or mode if the file
 * at the given name has the indicated dev+ino.
 */
struct file_times {
	ino_t	ft_ino;		/* inode number to verify */
	time_t	ft_mtime;	/* times to set */
	time_t	ft_atime;
	char	*ft_name;	/* name of file to set the times on */
	dev_t	ft_dev;		/* device number to verify */
};

/*
a230 4

#define FILEBITS		(S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
#define SETBITS			(S_ISUID | S_ISGID)
#define ABITS			(FILEBITS | SETBITS)
@


1.22
log
@backout previous for now; issues seen with "tar: Directory vanished before
restoring mode and times: ..." (and an error exit code, which breaks at least
building ports). krw@@ agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.20 2015/01/16 06:39:32 deraadt Exp $	*/
d214 14
d245 4
@


1.21
log
@For directories whose times or mode will be fixed up in the clean-up pass,
record their dev+ino and then use open(O_DIRECTORY)+fstat() to verify that
we're updating the correct directory before using futimens() and fchmod().

ok millert@@
@
text
@a213 14
 * Time data for a given file.  This is usually embedded in a structure
 * indexed by dev+ino, by name, by order in the archive, etc.  set_attr()
 * takes one of these and will only change the times or mode if the file
 * at the given name has the indicated dev+ino.
 */
struct file_times {
	ino_t	ft_ino;		/* inode number to verify */
	time_t	ft_mtime;	/* times to set */
	time_t	ft_atime;
	char	*ft_name;	/* name of file to set the times on */
	dev_t	ft_dev;		/* device number to verify */
};

/*
a230 4

#define FILEBITS		(S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
#define SETBITS			(S_ISUID | S_ISGID)
#define ABITS			(FILEBITS | SETBITS)
@


1.20
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.19 2014/11/23 05:32:20 guenther Exp $	*/
d214 14
d245 4
@


1.19
log
@Use PATH_MAX from <limits.h> instead of MAXPATHLEN from <sys/param.h>
Eliminate a couple unneeded #includes
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.18 2014/01/30 13:30:11 espie Exp $	*/
d227 1
a227 3
#ifndef MIN
#define	MIN(a,b) (((a)<(b))?(a):(b))
#endif
@


1.18
log
@abstraction for the sake of abstraction is distracting.

zap extra func pointer going to the same routines for all formats.
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.17 2005/11/09 19:59:06 otto Exp $	*/
d52 1
a52 1
				/* longer than the system MAXPATHLEN */
@


1.18.6.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.18 2014/01/30 13:30:11 espie Exp $	*/
a213 14
 * Time data for a given file.  This is usually embedded in a structure
 * indexed by dev+ino, by name, by order in the archive, etc.  set_attr()
 * takes one of these and will only change the times or mode if the file
 * at the given name has the indicated dev+ino.
 */
struct file_times {
	ino_t	ft_ino;		/* inode number to verify */
	time_t	ft_mtime;	/* times to set */
	time_t	ft_atime;
	char	*ft_name;	/* name of file to set the times on */
	dev_t	ft_dev;		/* device number to verify */
};

/*
a232 4

#define FILEBITS		(S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
#define SETBITS			(S_ISUID | S_ISGID)
#define ABITS			(FILEBITS | SETBITS)
@


1.17
log
@Compute the sv4cpio "crc" (it's actualy just a checksum) as a 32bit
number. Fixes crc computation on 64 bit archs. From Peter Philipp in PR
4606; looks right fgsch@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.16 2003/10/20 06:22:27 jmc Exp $	*/
a209 4
	int (*rd_data)(ARCHD *,	/* read/process file data from the archive */
	    int, off_t *);
	int (*wr_data)(ARCHD *,	/* write/process file data to the archive */
	    int, off_t *);
@


1.16
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.15 2003/06/26 00:10:17 deraadt Exp $	*/
d114 1
a114 1
	u_long crc;			/* file crc */
@


1.15
log
@protos.  this requires changing the api for the *trail() functions a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.14 2003/06/02 23:32:09 millert Exp $	*/
d51 1
a51 1
#define PAXPATHLEN	3072	/* maximium path length for pax. MUST be */
d136 1
a136 1
 * are tailored to the oddities of the specifc format. All other routines are
d200 1
a200 1
				/* at the ecnd of a archive write */
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.13 2002/10/18 15:38:11 millert Exp $	*/
d74 57
d166 3
a168 3
	int (*id)();		/* checks if a buffer is a valid header */
				/* returns 1 if it is, o.w. returns a 0 */
	int (*st_rd)();		/* initialize routine for read. so format */
d171 2
a172 2
	int (*rd)();		/* read header routine. passed a pointer to */
				/* ARCHD. It must extract the info from the */
d183 1
a183 1
	off_t (*end_rd)();	/* read cleanup. Allows format to clean up */
d187 2
a188 2
	int (*st_wr)();		/* initialize routine for write operations */
	int (*wr)();		/* write archive header. Passed an ARCHD */
d198 1
a198 1
	int (*end_wr)();	/* end write. write the trailer and do any */
d201 3
a203 3
	int (*trail)();		/* returns 0 if a valid trailer, -1 if not */
				/* For formats which encode the trailer */
				/* outside of a valid header, a return value */
d210 5
a214 3
	int (*rd_data)();	/* read/process file data from the archive */
	int (*wr_data)();	/* write/process file data to the archive */
	int (*options)();	/* process format specific options (-o) */
a215 57

/*
 * Pattern matching structure
 *
 * Used to store command line patterns
 */
typedef struct pattern {
	char		*pstr;		/* pattern to match, user supplied */
	char		*pend;		/* end of a prefix match */
	char		*chdname;	/* the dir to change to if not NULL.  */
	int		plen;		/* length of pstr */
	int		flgs;		/* processing/state flags */
#define MTCH		0x1		/* pattern has been matched */
#define DIR_MTCH	0x2		/* pattern matched a directory */
	struct pattern	*fow;		/* next pattern */
} PATTERN;

/*
 * General Archive Structure (used internal to pax)
 *
 * This structure is used to pass information about archive members between
 * the format independent routines and the format specific routines. When
 * new archive formats are added, they must accept requests and supply info
 * encoded in a structure of this type. The name fields are declared statically
 * here, as there is only ONE of these floating around, size is not a major
 * consideration. Eventually converting the name fields to a dynamic length
 * may be required if and when the supporting operating system removes all
 * restrictions on the length of pathnames it will resolve.
 */
typedef struct {
	int nlen;			/* file name length */
	char name[PAXPATHLEN+1];	/* file name */
	int ln_nlen;			/* link name length */
	char ln_name[PAXPATHLEN+1];	/* name to link to (if any) */
	char *org_name;			/* orig name in file system */
	PATTERN *pat;			/* ptr to pattern match (if any) */
	struct stat sb;			/* stat buffer see stat(2) */
	off_t pad;			/* bytes of padding after file xfer */
	off_t skip;			/* bytes of real data after header */
					/* IMPORTANT. The st_size field does */
					/* not always indicate the amount of */
					/* data following the header. */
	u_long crc;			/* file crc */
	int type;			/* type of file node */
#define PAX_DIR		1		/* directory */
#define PAX_CHR		2		/* character device */
#define PAX_BLK		3		/* block device */
#define PAX_REG		4		/* regular file */
#define PAX_SLK		5		/* symbolic link */
#define PAX_SCK		6		/* socket */
#define PAX_FIF		7		/* fifo */
#define PAX_HLK		8		/* hard link */
#define PAX_HRG		9		/* hard link to a regular file */
#define PAX_CTG		10		/* high performance file */
#define PAX_GLL		11		/* GNU long symlink */
#define PAX_GLF		12		/* GNU long file */
} ARCHD;
@


1.13
log
@Pull in some changes from NetBSD
o When extracting GNU tar archives, honor @@LongLink long links/files
o Add an option to prevent pax from prompting for the next volume
  upon premature end of archive.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.12 2002/10/16 18:40:30 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.12
log
@Fix comment typos; most from NetBSD and FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.11 2001/05/16 03:04:58 mickey Exp $	*/
d215 2
@


1.11
log
@use proper str*cpy functions instead of home grown one, spaces; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.10 2001/02/07 19:04:14 millert Exp $	*/
d109 1
a109 1
	int blkalgn;		/* writes must be aligned to blkalgn boundry */
@


1.10
log
@Honor TMPDIR environment variable and document the fact.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.9 1997/07/23 19:15:58 kstailey Exp $	*/
d69 1
a69 1
 * Device type of the current archive volume 
d82 1
a82 1
 * form the archive. Only those routines which deal directly with the archive 
d214 1
a214 1
#define PAX_CTG		10		/* high performance file */ 
d232 1
a232 1
#define	       MIN(a,b) (((a)<(b))?(a):(b))
@


1.9
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.8 1997/04/06 06:11:14 millert Exp $	*/
d241 4
a244 3
#define HEX	16
#define OCT	8
#define _PAX_	1
@


1.8
log
@Allow creation of archives with block sizes up to 64512 bytes
but complain about non-portability if > 32256 bytes.
Brought up by George Robbins <grr@@shandakor.tharsis.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.7 1997/02/27 23:32:59 michaels Exp $	*/
d232 1
a232 1
#define        MIN(a,b) (((a)<(b))?(a):(b))
d234 2
a235 2
#define MAJOR(x)        major(x)
#define MINOR(x)        minor(x)
@


1.7
log
@fix pr system/124, reported by Janjaap van Velthooven (janjaap@@stack.nl).
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.3 1996/06/23 14:20:40 deraadt Exp $	*/
d47 1
a47 1
#define	MAXBLK		32256	/* MAX blocksize supported (posix SPEC) */
d50 1
d93 1
a93 1
				/* the archive is currently using.*/
@


1.6
log
@revert to spawning compress-ing program. normally we want extracts using
'z' to also work on .Z files, but libz does not deal with compressed
data. Hacking the code to deal well with pipes has proven very hard.
@
text
@d169 1
a169 1
	char		*chdnam;
@


1.5
log
@Initial cut -C support in paxtar.  Exceeds GNU tar by quite a bit.
General pax still seems to work ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.4 1996/09/22 20:09:54 tholo Exp $	*/
a74 6

/*
 * Compression types
 */
#define	GZIP_CMP	1	/* gzip format */
#define	COMPRESS_CMP	2	/* compress format */
@


1.4
log
@Use zopen for compress-style compressed archives
Use libz for gzip-style compressed archives
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.3 1996/06/23 14:20:40 deraadt Exp $	*/
d175 1
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.h,v 1.3 1995/03/21 09:07:41 cgd Exp $	*/
d75 6
@


1.2
log
@Use systems definition for getting major and minor numbers, and for
creating a device; from FreeBSD
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d231 3
a233 3
#define MAJOR(x)        (((unsigned)(x) >> 8) & 0xff)
#define MINOR(x)        ((x) & 0xff)
#define TODEV(x, y)	(((unsigned)(x) << 8) | ((unsigned)(y)))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
