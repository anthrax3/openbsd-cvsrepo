head	1.50;
access;
symbols
	OPENBSD_6_2:1.50.0.2
	OPENBSD_6_2_BASE:1.50
	OPENBSD_6_1:1.50.0.4
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.45.0.2
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.34.0.4
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.33.0.2
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.30.0.4
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.28.0.20
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.16
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.14
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.12
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.10
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.8
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.6
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.4
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.27.0.4
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.20.0.4
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.14.0.8
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.14.0.6
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.11.0.4
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.50
date	2017.03.11.12.55.47;	author tb;	state Exp;
branches;
next	1.49;
commitid	vLhSs8uwZxyoO4sW;

1.49
date	2017.01.23.12.46.13;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	0CvD9OvF163f51Fm;

1.48
date	2017.01.23.04.25.05;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	NeJrtXDNhZqhGXfa;

1.47
date	2016.08.26.04.11.16;	author guenther;	state Exp;
branches;
next	1.46;
commitid	JeDGCh3Baf9wzXzL;

1.46
date	2016.08.23.06.00.28;	author guenther;	state Exp;
branches;
next	1.45;
commitid	lequwSVdrsu8itF8;

1.45
date	2016.06.23.06.37.36;	author semarie;	state Exp;
branches;
next	1.44;
commitid	nDEpKRnM73mGiWPn;

1.44
date	2015.12.16.01.39.11;	author tb;	state Exp;
branches;
next	1.43;
commitid	2PFFQfU1kBJoHI3T;

1.43
date	2015.12.06.16.57.45;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	twr8YTraN2kDAzjR;

1.42
date	2015.10.12.05.05.24;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	mRVEKONqPhGT4efi;

1.41
date	2015.03.09.04.23.29;	author guenther;	state Exp;
branches;
next	1.40;
commitid	JMkpovMhu0rmLvCn;

1.40
date	2015.02.21.22.48.23;	author guenther;	state Exp;
branches
	1.40.2.1;
next	1.39;
commitid	AdteqX8nU06lUYnQ;

1.39
date	2015.02.12.23.44.57;	author guenther;	state Exp;
branches;
next	1.38;
commitid	lkvsxr9r9MdXqaQN;

1.38
date	2014.11.23.05.28.12;	author guenther;	state Exp;
branches;
next	1.37;
commitid	GoH40iniQ6KqwYGS;

1.37
date	2014.05.24.03.49.49;	author guenther;	state Exp;
branches
	1.37.4.1;
next	1.36;

1.36
date	2014.05.23.19.47.49;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2014.01.09.03.12.25;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2012.12.04.02.24.45;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2012.04.19.04.26.46;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2011.05.26.14.42.06;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2010.12.02.04.08.27;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.28.20.30.41;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.04.10.02.44;	author mpf;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.16.22.50.23;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.20.14.08.45;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.20.06.22.27;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.13.17.51.14;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.23.32.09;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.16.19.20.02;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.16.18.40.30;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.05.09.38.52;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.16.03.04.57;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.07.19.04.14;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.09.16.37.54;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	98.09.20.02.22.22;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.07.27.05.18.29;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.06.03.08.10.17;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.09.01.18.29.58;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.07.25.18.58.35;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.07.24.23.19.21;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.23.19.15.58;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.04.05.22.36.17;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.03.02.09.46.49;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.10.27.06.45.13;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.14.20.39;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.11.06.41.53;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.04.19.02.24.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.18;	author deraadt;	state Exp;
branches;
next	;

1.37.4.1
date	2015.04.30.19.30.57;	author guenther;	state Exp;
branches;
next	;
commitid	tPD1f2vGi43RT0WC;

1.40.2.1
date	2015.04.30.19.28.46;	author guenther;	state Exp;
branches;
next	;
commitid	pbBButXFqiIh89mX;


desc
@@


1.50
log
@switch pax to using pledge tape instead of ioctl.

ok kettenis
@
text
@/*	$OpenBSD: pax.c,v 1.49 2017/01/23 12:46:13 deraadt Exp $	*/
/*	$NetBSD: pax.c,v 1.5 1996/03/26 23:54:20 mrg Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/resource.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <err.h>
#include <fcntl.h>
#include <paths.h>
#include <stdio.h>

#include "pax.h"
#include "extern.h"
static int gen_init(void);

/*
 * PAX main routines, general globals and some simple start up routines
 */

/*
 * Variables that can be accessed by any routine within pax
 */
int	act = DEFOP;		/* read/write/append/copy */
FSUB	*frmt = NULL;		/* archive format type */
int	cflag;			/* match all EXCEPT pattern/file */
int	cwdfd;			/* starting cwd */
int	dflag;			/* directory member match only  */
int	iflag;			/* interactive file/archive rename */
int	kflag;			/* do not overwrite existing files */
int	lflag;			/* use hard links when possible */
int	nflag;			/* select first archive member match */
int	tflag;			/* restore access time after read */
int	uflag;			/* ignore older modification time files */
int	vflag;			/* produce verbose output */
int	Dflag;			/* same as uflag except inode change time */
int	Hflag;			/* follow command line symlinks (write only) */
int	Lflag;			/* follow symlinks when writing */
int	Nflag;			/* only use numeric uid and gid */
int	Xflag;			/* archive files with same device id only */
int	Yflag;			/* same as Dflag except after name mode */
int	Zflag;			/* same as uflag except after name mode */
int	zeroflag;		/* use \0 as pathname terminator */
int	vfpart;			/* is partial verbose output in progress */
int	patime = 1;		/* preserve file access time */
int	pmtime = 1;		/* preserve file modification times */
int	nodirs;			/* do not create directories as needed */
int	pmode;			/* preserve file mode bits */
int	pids;			/* preserve file uid/gid */
int	rmleadslash = 0;	/* remove leading '/' from pathnames */
int	exit_val;		/* exit value */
int	docrc;			/* check/create file crc */
char	*dirptr;		/* destination dir in a copy */
char	*argv0;			/* root of argv[0] */
enum op_mode op_mode;		/* what program are we acting as? */
sigset_t s_mask;		/* signal mask for cleanup critical sect */
FILE	*listf = stderr;	/* file pointer to print file list to */
int	listfd = STDERR_FILENO;	/* fd matching listf, for sighandler output */
char	*tempfile;		/* tempfile to use for mkstemp(3) */
char	*tempbase;		/* basename of tempfile to use for mkstemp(3) */

/*
 *	PAX - Portable Archive Interchange
 *
 *	A utility to read, write, and write lists of the members of archive
 *	files and copy directory hierarchies. A variety of archive formats
 *	are supported (some are described in POSIX 1003.1 10.1):
 *
 *		ustar - 10.1.1 extended tar interchange format
 *		cpio  - 10.1.2 extended cpio interchange format
 *		tar - old BSD 4.3 tar format
 *		binary cpio - old cpio with binary header format
 *		sysVR4 cpio -  with and without CRC
 *
 * This version is a superset of IEEE Std 1003.2b-d3
 *
 * Summary of Extensions to the IEEE Standard:
 *
 * 1	READ ENHANCEMENTS
 * 1.1	Operations which read archives will continue to operate even when
 *	processing archives which may be damaged, truncated, or fail to meet
 *	format specs in several different ways. Damaged sections of archives
 *	are detected and avoided if possible. Attempts will be made to resync
 *	archive read operations even with badly damaged media.
 * 1.2	Blocksize requirements are not strictly enforced on archive read.
 *	Tapes which have variable sized records can be read without errors.
 * 1.3	The user can specify via the non-standard option flag -E if error
 *	resync operation should stop on a media error, try a specified number
 *	of times to correct, or try to correct forever.
 * 1.4	Sparse files (lseek holes) stored on the archive (but stored with blocks
 *	of all zeros will be restored with holes appropriate for the target
 *	filesystem
 * 1.5	The user is notified whenever something is found during archive
 *	read operations which violates spec (but the read will continue).
 * 1.6	Multiple archive volumes can be read and may span over different
 *	archive devices
 * 1.7	Rigidly restores all file attributes exactly as they are stored on the
 *	archive.
 * 1.8	Modification change time ranges can be specified via multiple -T
 *	options. These allow a user to select files whose modification time
 *	lies within a specific time range.
 * 1.9	Files can be selected based on owner (user name or uid) via one or more
 *	-U options.
 * 1.10	Files can be selected based on group (group name or gid) via one o
 *	more -G options.
 * 1.11	File modification time can be checked against existing file after
 *	name modification (-Z)
 *
 * 2	WRITE ENHANCEMENTS
 * 2.1	Write operation will stop instead of allowing a user to create a flawed
 *	flawed archive (due to any problem).
 * 2.2	Archives written by pax are forced to strictly conform to both the
 *	archive and pax the specific format specifications.
 * 2.3	Blocking size and format is rigidly enforced on writes.
 * 2.4	Formats which may exhibit header overflow problems (they have fields
 *	too small for large file systems, such as inode number storage), use
 *	routines designed to repair this problem. These techniques still
 *	conform to both pax and format specifications, but no longer truncate
 *	these fields. This removes any restrictions on using these archive
 *	formats on large file systems.
 * 2.5	Multiple archive volumes can be written and may span over different
 *	archive devices
 * 2.6	A archive volume record limit allows the user to specify the number
 *	of bytes stored on an archive volume. When reached the user is
 *	prompted for the next archive volume. This is specified with the
 *	non-standard -B flag. The limit is rounded up to the next blocksize.
 * 2.7	All archive padding during write use zero filled sections. This makes
 *	it much easier to pull data out of flawed archive during read
 *	operations.
 * 2.8	Access time reset with the -t applies to all file nodes (including
 *	directories).
 * 2.9	Symbolic links can be followed with -L (optional in the spec).
 * 2.10	Modification or inode change time ranges can be specified via
 *	multiple -T options. These allow a user to select files whose
 *	modification or inode change time lies within a specific time range.
 * 2.11	Files can be selected based on owner (user name or uid) via one or more
 *	-U options.
 * 2.12	Files can be selected based on group (group name or gid) via one o
 *	more -G options.
 * 2.13	Symlinks which appear on the command line can be followed (without
 *	following other symlinks; -H flag)
 *
 * 3	COPY ENHANCEMENTS
 * 3.1	Sparse files (lseek holes) can be copied without expanding the holes
 *	into zero filled blocks. The file copy is created with holes which are
 *	appropriate for the target filesystem
 * 3.2	Access time as well as modification time on copied file trees can be
 *	preserved with the appropriate -p options.
 * 3.3	Access time reset with the -t applies to all file nodes (including
 *	directories).
 * 3.4	Symbolic links can be followed with -L (optional in the spec).
 * 3.5	Modification or inode change time ranges can be specified via
 *	multiple -T options. These allow a user to select files whose
 *	modification or inode change time lies within a specific time range.
 * 3.6	Files can be selected based on owner (user name or uid) via one or more
 *	-U options.
 * 3.7	Files can be selected based on group (group name or gid) via one o
 *	more -G options.
 * 3.8	Symlinks which appear on the command line can be followed (without
 *	following other symlinks; -H flag)
 * 3.9  File inode change time can be checked against existing file before
 *	name modification (-D)
 * 3.10 File inode change time can be checked against existing file after
 *	name modification (-Y)
 * 3.11	File modification time can be checked against existing file after
 *	name modification (-Z)
 *
 * 4	GENERAL ENHANCEMENTS
 * 4.1	Internal structure is designed to isolate format dependent and
 *	independent functions. Formats are selected via a format driver table.
 *	This encourages the addition of new archive formats by only having to
 *	write those routines which id, read and write the archive header.
 */

/*
 * main()
 *	parse options, set up and operate as specified by the user.
 *	any operational flaw will set exit_val to non-zero
 * Return: 0 if ok, 1 otherwise
 */

int
main(int argc, char **argv)
{
	char *tmpdir;
	size_t tdlen;

	/*
	 * Keep a reference to cwd, so we can always come back home.
	 */
	cwdfd = open(".", O_RDONLY | O_CLOEXEC);
	if (cwdfd < 0) {
		syswarn(1, errno, "Can't open current working directory.");
		return(exit_val);
	}

	/*
	 * Where should we put temporary files?
	 */
	if ((tmpdir = getenv("TMPDIR")) == NULL || *tmpdir == '\0')
		tmpdir = _PATH_TMP;
	tdlen = strlen(tmpdir);
	while (tdlen > 0 && tmpdir[tdlen - 1] == '/')
		tdlen--;
	tempfile = malloc(tdlen + 1 + sizeof(_TFILE_BASE));
	if (tempfile == NULL) {
		paxwarn(1, "Cannot allocate memory for temp file name.");
		return(exit_val);
	}
	if (tdlen)
		memcpy(tempfile, tmpdir, tdlen);
	tempbase = tempfile + tdlen;
	*tempbase++ = '/';

	/*
	 * parse options, determine operational mode, general init
	 */
	options(argc, argv);
	if ((gen_init() < 0) || (tty_init() < 0))
		return(exit_val);

	/*
	 * pmode needs to restore setugid bits when extracting or copying,
	 * so can't pledge at all then.
	 */
	if (pmode == 0 || (act != EXTRACT && act != COPY)) {
		if (pledge("stdio rpath wpath cpath fattr dpath getpw proc exec tape",
		    NULL) == -1)
			err(1, "pledge");

		/* Copy mode, or no gzip -- don't need to fork/exec. */
		if (gzip_program == NULL || act == COPY) {
			if (pledge("stdio rpath wpath cpath fattr dpath getpw tape",
			    NULL) == -1)
				err(1, "pledge");
		}
	}

	/*
	 * select a primary operation mode
	 */
	switch (act) {
	case EXTRACT:
		extract();
		break;
	case ARCHIVE:
		archive();
		break;
	case APPND:
		if (gzip_program != NULL)
			errx(1, "can not gzip while appending");
		append();
		break;
	case COPY:
		copy();
		break;
	default:
	case LIST:
		list();
		break;
	}
	return(exit_val);
}

/*
 * sig_cleanup()
 *	when interrupted we try to do whatever delayed processing we can.
 *	This is not critical, but we really ought to limit our damage when we
 *	are aborted by the user.
 * Return:
 *	never....
 */

void
sig_cleanup(int which_sig)
{
	char errbuf[80];

	/*
	 * restore modes and times for any dirs we may have created
	 * or any dirs we may have read.
	 */

	/* paxwarn() uses stdio; fake it as well as we can */
	if (which_sig == SIGXCPU)
		strlcpy(errbuf, "\nCPU time limit reached, cleaning up.\n",
		    sizeof errbuf);
	else
		strlcpy(errbuf, "\nSignal caught, cleaning up.\n",
		    sizeof errbuf);
	(void) write(STDERR_FILENO, errbuf, strlen(errbuf));

	ar_close(1);
	sltab_process(1);
	proc_dir(1);
	if (tflag)
		atdir_end();
	_exit(1);
}

/*
 * setup_sig()
 *	set a signal to be caught, but only if it isn't being ignored already
 */

static int
setup_sig(int sig, const struct sigaction *n_hand)
{
	struct sigaction o_hand;

	if (sigaction(sig, NULL, &o_hand) < 0)
		return (-1);

	if (o_hand.sa_handler == SIG_IGN)
		return (0);

	return (sigaction(sig, n_hand, NULL));
}

/*
 * gen_init()
 *	general setup routines. Not all are required, but they really help
 *	when dealing with a medium to large sized archives.
 */

static int
gen_init(void)
{
	struct rlimit reslimit;
	struct sigaction n_hand;

	/*
	 * Really needed to handle large archives. We can run out of memory for
	 * internal tables really fast when we have a whole lot of files...
	 */
	if (getrlimit(RLIMIT_DATA , &reslimit) == 0){
		reslimit.rlim_cur = reslimit.rlim_max;
		(void)setrlimit(RLIMIT_DATA , &reslimit);
	}

	/*
	 * should file size limits be waived? if the os limits us, this is
	 * needed if we want to write a large archive
	 */
	if (getrlimit(RLIMIT_FSIZE , &reslimit) == 0){
		reslimit.rlim_cur = reslimit.rlim_max;
		(void)setrlimit(RLIMIT_FSIZE , &reslimit);
	}

	/*
	 * increase the size the stack can grow to
	 */
	if (getrlimit(RLIMIT_STACK , &reslimit) == 0){
		reslimit.rlim_cur = reslimit.rlim_max;
		(void)setrlimit(RLIMIT_STACK , &reslimit);
	}

	/*
	 * not really needed, but doesn't hurt
	 */
	if (getrlimit(RLIMIT_RSS , &reslimit) == 0){
		reslimit.rlim_cur = reslimit.rlim_max;
		(void)setrlimit(RLIMIT_RSS , &reslimit);
	}

	/*
	 * signal handling to reset stored directory times and modes. Since
	 * we deal with broken pipes via failed writes we ignore it. We also
	 * deal with any file size limit through failed writes. Cpu time
	 * limits are caught and a cleanup is forced.
	 */
	if ((sigemptyset(&s_mask) < 0) || (sigaddset(&s_mask, SIGTERM) < 0) ||
	    (sigaddset(&s_mask,SIGINT) < 0)||(sigaddset(&s_mask,SIGHUP) < 0) ||
	    (sigaddset(&s_mask,SIGPIPE) < 0)||(sigaddset(&s_mask,SIGQUIT)<0) ||
	    (sigaddset(&s_mask,SIGXCPU) < 0)||(sigaddset(&s_mask,SIGXFSZ)<0)) {
		paxwarn(1, "Unable to set up signal mask");
		return(-1);
	}

	/* snag the fd to be used from the signal handler */
	listfd = fileno(listf);

	memset(&n_hand, 0, sizeof n_hand);
	n_hand.sa_mask = s_mask;
	n_hand.sa_flags = 0;
	n_hand.sa_handler = sig_cleanup;

	if (setup_sig(SIGHUP,  &n_hand) ||
	    setup_sig(SIGTERM, &n_hand) ||
	    setup_sig(SIGINT,  &n_hand) ||
	    setup_sig(SIGQUIT, &n_hand) ||
	    setup_sig(SIGXCPU, &n_hand))
		goto out;

	n_hand.sa_handler = SIG_IGN;
	if ((sigaction(SIGPIPE, &n_hand, NULL) < 0) ||
	    (sigaction(SIGXFSZ, &n_hand, NULL) < 0))
		goto out;
	return(0);

    out:
	syswarn(1, errno, "Unable to set up signal handler");
	return(-1);
}
@


1.49
log
@Slow down the churn and continue using old pledge name "ioctl" instead
of "tape" for a week or so.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.48 2017/01/23 04:25:05 deraadt Exp $	*/
d264 1
a264 1
		if (pledge("stdio rpath wpath cpath fattr dpath getpw proc exec ioctl",
d270 1
a270 1
			if (pledge("stdio rpath wpath cpath fattr dpath getpw ioctl",
@


1.48
log
@Split pledge "ioctl" into "tape" and "bpf", and allow SIOCGIFGROUP only
upon "inet".  Adjust the 4 programs that care about this.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.47 2016/08/26 04:11:16 guenther Exp $	*/
d264 1
a264 1
		if (pledge("stdio rpath wpath cpath fattr dpath getpw proc exec tape",
d270 1
a270 1
			if (pledge("stdio rpath wpath cpath fattr dpath getpw tape",
@


1.47
log
@Don't need <sys/time.h> or "options.h" here
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.46 2016/08/23 06:00:28 guenther Exp $	*/
d264 1
a264 1
		if (pledge("stdio rpath wpath cpath fattr dpath getpw ioctl proc exec",
d270 1
a270 1
			if (pledge("stdio rpath wpath cpath fattr dpath getpw ioctl",
@


1.46
log
@Instead of doing strcmp(argv0), track the invocation mode (pax/tar/cpio)
in a separate variable

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.45 2016/06/23 06:37:36 semarie Exp $	*/
a38 1
#include <sys/time.h>
@


1.45
log
@allow creation of devices or fifo without -p (as it is already allowed with -p)

diff from trondd at kagu-tsuchi com, enhanced by me for reordering promises

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.44 2015/12/16 01:39:11 tb Exp $	*/
d93 1
@


1.44
log
@Replace "tame" by "pledge" in a comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.43 2015/12/06 16:57:45 deraadt Exp $	*/
d264 1
a264 1
		if (pledge("stdio rpath wpath cpath dpath fattr getpw ioctl proc exec",
d270 1
a270 1
			if (pledge("stdio rpath wpath fattr cpath getpw ioctl",
@


1.43
log
@pledge "dpath" to allow creation of nodes via mkfifo(2) and mknod(2)
NOTE: dpath requires a fairly new kernel
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.42 2015/10/12 05:05:24 deraadt Exp $	*/
d261 1
a261 1
	 * so can't tame at all then.
@


1.42
log
@preservation modes can adjust setugid bits, so no pledge is possible.
Otherwise, lay the groundwork for whether a gzip program may be run or not.
After such a gzip program is started, pledge the program will not exec
again.  Took a few iterations to get this going... it is looking good.
with guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.41 2015/03/09 04:23:29 guenther Exp $	*/
d264 1
a264 1
		if (pledge("stdio rpath wpath cpath fattr getpw ioctl proc exec",
@


1.41
log
@Unrevert post-unlock:
* Prevent an archive from esacaping the current directory by itself:
  when extracting a symlink whose value is absolute or contains ".."
  components, just create a zero-length normal file (with additional
  tracking of the mode and hardlinks to the symlink) until everything
  else is extracted, then go back and replace it with the requested
  link (if it's still that zero-length placeholder).

* For tar without -P, if a path in the archive has any ".." components
  then strip everything up to and including the last of them (if
  it ends in ".." then it becomes ".")
  This mostly follows GNU tar's behavior, except for 'tar tf' and
  'tar xvf' we report the modified path that would be/was actually
  created instead of the raw path from the archive

  Above two fixes prompted by a report from Daniel Cegielka
  (daniel.cegielka (at) gmail.com)

* For directories whose times or mode will be fixed up in the
  clean-up pass, record their dev+ino and then use
  open(O_DIRECTORY)+fstat() to verify that we're updating the correct
  directory before using futimens() and fchmod().

* Correct buffer overflow in handling of pax extension headers,
  caught by the memcpy() overlap check.


previously ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.39 2015/02/12 23:44:57 guenther Exp $	*/
d258 17
@


1.40
log
@Recent changes haven't been completely stable, so revert for the 5.7 release

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.38 2014/11/23 05:28:12 guenther Exp $	*/
d314 1
@


1.40.2.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.40 2015/02/21 22:48:23 guenther Exp $	*/
a313 1
	sltab_process(1);
@


1.39
log
@Prevent an archive from esacaping the current directory by itself:
when extracting a symlink whose value is absolute or contains ".."
components, just create a zero-length normal file (with additional
tracking of the mode and hardlinks to the symlink) until everything
else is extracted, then go back and replace it with the requested
link (if its still that zero-length placeholder).

This and previous symlink and ".." path fixes prompted by a report
from Daniel Cegielka (daniel.cegielka (at) gmail.com)

ok millert@@
@
text
@a313 1
	sltab_process(1);
@


1.38
log
@Don't leak the fds for "." and the tty to the compression process
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.37 2014/05/24 03:49:49 guenther Exp $	*/
d314 1
@


1.37
log
@Make signal setup clearer via helper function, eliminating a gap in
ignoring signals when they were already ignored

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.36 2014/05/23 19:47:49 guenther Exp $	*/
d228 1
a228 1
	cwdfd = open(".", O_RDONLY);
@


1.37.4.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.37 2014/05/24 03:49:49 guenther Exp $	*/
a313 1
	sltab_process(1);
@


1.36
log
@Make the signal handler safe: block signals when updating data-structures
that are walked by routines called from the signal handler and use
dprintf() instead fprintf() in ar_close().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.35 2014/01/09 03:12:25 guenther Exp $	*/
d321 19
a349 1
	struct sigaction o_hand;
d407 5
a411 23
	if ((sigaction(SIGHUP, &n_hand, &o_hand) < 0) ||
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGHUP, &o_hand, &o_hand) < 0))
		goto out;

	if ((sigaction(SIGTERM, &n_hand, &o_hand) < 0) ||
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGTERM, &o_hand, &o_hand) < 0))
		goto out;

	if ((sigaction(SIGINT, &n_hand, &o_hand) < 0) ||
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGINT, &o_hand, &o_hand) < 0))
		goto out;

	if ((sigaction(SIGQUIT, &n_hand, &o_hand) < 0) ||
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGQUIT, &o_hand, &o_hand) < 0))
		goto out;

	if ((sigaction(SIGXCPU, &n_hand, &o_hand) < 0) ||
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGXCPU, &o_hand, &o_hand) < 0))
d415 2
a416 2
	if ((sigaction(SIGPIPE, &n_hand, &o_hand) < 0) ||
	    (sigaction(SIGXFSZ, &n_hand, &o_hand) < 0))
@


1.35
log
@Update pax -v format to match "ls -l": display the year for dates
in the future and include a space between the major and minor numbers
for devices.  Eliminate bogus handling of LC_TIME environment variable.
Make strftime() format selection understandable by gcc -Wformat=2.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.34 2012/12/04 02:24:45 deraadt Exp $	*/
d95 1
d301 1
a301 2
	 * or any dirs we may have read. Set vflag and vfpart so the user
	 * will clearly see the message on a line by itself.
a302 1
	vflag = vfpart = 1;
d306 1
a306 1
		strlcpy(errbuf, "CPU time limit reached, cleaning up.\n",
d309 1
a309 1
		strlcpy(errbuf, "Signal caught, cleaning up.\n",
d313 2
a314 2
	ar_close();			/* XXX signal race */
	proc_dir();			/* XXX signal race */
d316 1
a316 1
		atdir_end();		/* XXX signal race */
d380 4
@


1.34
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.33 2012/04/19 04:26:46 deraadt Exp $	*/
a91 1
char	*ltmfrmt;		/* -v locale time format (if any) */
a366 7

	/*
	 * Handle posix locale
	 *
	 * set user defines time printing format for -v option
	 */
	ltmfrmt = getenv("LC_TIME");
@


1.33
log
@add newline to signal error messages; Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.32 2011/05/26 14:42:06 deraadt Exp $	*/
a36 1
#include <stdio.h>
a37 1
#include <sys/param.h>
d49 2
@


1.32
log
@fix one signal race bug, and mark the others that remain much more
specifically
ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.31 2010/12/02 04:08:27 tedu Exp $	*/
d308 1
a308 1
		strlcpy(errbuf, "Cpu time limit reached, cleaning up.",
d311 1
a311 1
		strlcpy(errbuf, "Signal caught, cleaning up.",
@


1.31
log
@a -N option for tar that uses numeric only IDs, useful for cross system
tar file manipulation.  with advice from guenther and jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.30 2009/10/28 20:30:41 guenther Exp $	*/
d297 1
a297 1
	/* XXX signal races */
d305 2
d308 2
a309 1
		paxwarn(0, "Cpu time limit reached, cleaning up.");
d311 3
a313 1
		paxwarn(0, "Signal caught, cleaning up.");
d315 2
a316 2
	ar_close();
	proc_dir();
d318 2
a319 2
		atdir_end();
	exit(1);
@


1.30
log
@Err out if either sigaction fails and not just when both do.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.29 2009/10/27 23:59:22 deraadt Exp $	*/
d77 1
@


1.29
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.28 2005/08/04 10:02:44 mpf Exp $	*/
d388 1
a388 1
	if ((sigaction(SIGHUP, &n_hand, &o_hand) < 0) &&
d393 1
a393 1
	if ((sigaction(SIGTERM, &n_hand, &o_hand) < 0) &&
d398 1
a398 1
	if ((sigaction(SIGINT, &n_hand, &o_hand) < 0) &&
d403 1
a403 1
	if ((sigaction(SIGQUIT, &n_hand, &o_hand) < 0) &&
d408 1
a408 1
	if ((sigaction(SIGXCPU, &n_hand, &o_hand) < 0) &&
@


1.28
log
@Make pax exit unsuccessfully on errors.
Patch by fgsch@@ and me.
Fixes PR 4310.
OK fgsch@@ otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.27 2004/04/16 22:50:23 deraadt Exp $	*/
a35 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)pax.c	8.2 (Berkeley) 4/18/94";
#else
static const char rcsid[] = "$OpenBSD: pax.c,v 1.27 2004/04/16 22:50:23 deraadt Exp $";
#endif
#endif /* not lint */
@


1.27
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.26 2004/01/20 14:08:45 otto Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: pax.c,v 1.26 2004/01/20 14:08:45 otto Exp $";
d243 1
a243 1
		syswarn(0, errno, "Can't open current working directory.");
@


1.26
log
@When trying to append to a gzipped archive, print msg using errx(),
not err().  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.25 2003/10/20 06:22:27 jmc Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: pax.c,v 1.25 2003/10/20 06:22:27 jmc Exp $";
d253 1
a253 1
	while(tdlen > 0 && tmpdir[tdlen - 1] == '/')
d275 1
a275 1
	switch(act) {
@


1.25
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.24 2003/06/13 17:51:14 millert Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: pax.c,v 1.24 2003/06/13 17:51:14 millert Exp $";
d284 1
a284 1
			err(1, "can not gzip while appending");
@


1.24
log
@Add a -0 flag to make pax use a NUL instead of a newline as the
pathname separator.  Works in list mode as well as read/copy mode.
Based on a patch from David Leonard; closes PR 3310
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.23 2003/06/02 23:32:09 millert Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: pax.c,v 1.23 2003/06/02 23:32:09 millert Exp $";
d92 2
a93 2
int	Yflag;			/* same as Dflg except after name mode */
int	Zflag;			/* same as uflg except after name mode */
d163 1
a163 1
 *	archive and pax the spceific format specifications.
d387 1
a387 1
	 * deal with any file size limit thorugh failed writes. Cpu time
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.22 2002/10/16 19:20:02 millert Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: pax.c,v 1.22 2002/10/16 19:20:02 millert Exp $";
d94 1
@


1.22
log
@sprinkle const; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.21 2002/10/16 18:40:30 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: pax.c,v 1.21 2002/10/16 18:40:30 millert Exp $";
@


1.21
log
@Fix comment typos; most from NetBSD and FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.20 2002/02/19 19:39:35 millert Exp $	*/
d42 1
a42 1
static char copyright[] =
d49 1
a49 1
static char sccsid[] = "@@(#)pax.c	8.2 (Berkeley) 4/18/94";
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.20 2002/02/19 19:39:35 millert Exp $";
@


1.20
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.19 2002/02/16 21:27:07 millert Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.19 2002/02/16 21:27:07 millert Exp $";
d159 1
a159 1
 * 1.11	File modification time can be checked against exisiting file after
d165 1
a165 1
 * 2.2	Archives writtens by pax are forced to strictly conform to both the
d179 1
a179 1
 *	non-standard -B flag. THe limit is rounded up to the next blocksize.
d214 1
a214 1
 * 3.9  File inode change time can be checked against exisiting file before
d216 1
a216 1
 * 3.10 File inode change time can be checked against exisiting file after
d218 1
a218 1
 * 3.11	File modification time can be checked against exisiting file after
@


1.19
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.18 2001/11/05 09:38:52 deraadt Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.18 2001/11/05 09:38:52 deraadt Exp $";
a234 1
#ifdef __STDC__
a236 6
#else
int
main(argc, argv)
	int argc;
	char **argv;
#endif
a309 1
#ifdef __STDC__
a311 5
#else
void
sig_cleanup(which_sig)
	int which_sig;
#endif
a338 1
#ifdef __STDC__
a340 4
#else
static int
gen_init()
#endif
@


1.18
log
@mark a zone of signal races
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.17 2001/05/16 03:04:57 mickey Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.17 2001/05/16 03:04:57 mickey Exp $";
d71 1
a71 1
static int gen_init __P((void));
@


1.17
log
@use proper str*cpy functions instead of home grown one, spaces; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.16 2001/02/07 19:04:14 millert Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.16 2001/02/07 19:04:14 millert Exp $";
d326 2
@


1.16
log
@Honor TMPDIR environment variable and document the fact.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.15 2000/06/09 16:37:54 espie Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.15 2000/06/09 16:37:54 espie Exp $";
d118 1
a118 1
 * 	A utility to read, write, and write lists of the members of archive
d134 1
a134 1
 *	processing archives which may be damaged, truncated, or fail to meet 
d149 1
a149 1
 *	archive devices 
d175 1
a175 1
 *	archive devices 
d222 1
a222 1
 * 4.1	Internal structure is designed to isolate format dependent and 
d283 1
a283 1
	 * select a primary operation mode 
d399 1
a399 1
	 * set user defines time printing format for -v option 
@


1.15
log
@Some minor cleanup, ok'd millert@@
- remove zflag variable, since gzip_program is enough to know what's
going on.
- fix ar_gzip call to not depend on global variables. Avoid bogus act
checks, avoid calling if fd == -1.
- do gzip check for append as early as possible.
- remove old K&R prototype when updating.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.14 1998/09/20 02:22:22 millert Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.14 1998/09/20 02:22:22 millert Exp $";
d68 1
d112 2
d245 3
d256 18
@


1.14
log
@When invoked as tar, print verbose output to stdout, not stderr.  If in list mode or in create mode where create output is to stdout print to stderr
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.13 1998/07/27 05:18:29 millert Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.13 1998/07/27 05:18:29 millert Exp $";
d66 1
a90 1
int	zflag;			/* use gzip */
d269 2
@


1.13
log
@pull in string.h for memset() proto
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.12 1998/06/03 08:10:17 deraadt Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.12 1998/06/03 08:10:17 deraadt Exp $";
d110 1
@


1.12
log
@zero sigset_t before use
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.11 1997/09/01 18:29:58 deraadt Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.11 1997/09/01 18:29:58 deraadt Exp $";
d64 1
@


1.11
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.10 1997/07/25 18:58:35 mickey Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.10 1997/07/25 18:58:35 mickey Exp $";
d388 1
@


1.10
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.9 1997/07/24 23:19:21 millert Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.9 1997/07/24 23:19:21 millert Exp $";
d393 1
a393 1
	    (o_hand.sa_handler == SIG_IGN) && 
d398 1
a398 1
	    (o_hand.sa_handler == SIG_IGN) && 
d403 1
a403 1
	    (o_hand.sa_handler == SIG_IGN) && 
d408 1
a408 1
	    (o_hand.sa_handler == SIG_IGN) && 
d413 1
a413 1
	    (o_hand.sa_handler == SIG_IGN) && 
@


1.9
log
@Stash fd of cwd instead of using getcwd() to stash path.
This works in cases where the parent dir is not readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.8 1997/07/23 19:15:58 kstailey Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.8 1997/07/23 19:15:58 kstailey Exp $";
d230 1
a230 1
#if __STDC__
d289 1
a289 1
#if __STDC__
d322 1
a322 1
#if __STDC__
@


1.8
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.7 1997/04/05 22:36:17 millert Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.7 1997/04/05 22:36:17 millert Exp $";
d65 1
d80 1
a107 1
char	*cwdpt;			/* starting cwd */
d243 3
a245 3
	cwdpt = getcwd(NULL, 0);
	if (cwdpt == NULL) {
		syswarn(0, errno, "Can't get current working directory.");
@


1.7
log
@Strip leading '/' of pathnames (only in tar mode).  -S option turns
this off like GNU tar.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.6 1997/03/02 09:46:49 tholo Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.6 1997/03/02 09:46:49 tholo Exp $";
d252 1
a252 1
        if ((gen_init() < 0) || (tty_init() < 0))
@


1.6
log
@More complete cpio(1) emulation
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.5 1996/10/27 06:45:13 downsj Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.5 1996/10/27 06:45:13 downsj Exp $";
d100 1
@


1.5
log
@Initial cut -C support in paxtar.  Exceeds GNU tar by quite a bit.
General pax still seems to work ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.4 1996/06/23 14:20:39 deraadt Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.4 1996/06/23 14:20:39 deraadt Exp $";
d97 1
@


1.4
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.5 1996/03/26 23:54:20 mrg Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: pax.c,v 1.5 1996/03/26 23:54:20 mrg Exp $";
d104 1
d237 9
@


1.3
log
@Correct compile warnings
Rename warn() to paxwarn() so <err.h> can be included

Remove #include <ctype.h> when not needed; from FreeBSD
@
text
@d1 1
d51 1
a51 1
static char rcsid[] = "$NetBSD: pax.c,v 1.5 1996/03/26 23:54:20 mrg Exp $";
@


1.2
log
@from mrg; impliment -z (gzip) in pax and tar, and -Z (compress) in tar
@
text
@d291 1
a291 1
		warn(0, "Cpu time limit reached, cleaning up.");
d293 1
a293 1
		warn(0, "Signal caught, cleaning up.");
d371 1
a371 1
		warn(1, "Unable to set up signal mask");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: pax.c,v 1.4 1995/03/21 09:07:39 cgd Exp $	*/
d50 1
a50 1
static char rcsid[] = "$NetBSD: pax.c,v 1.4 1995/03/21 09:07:39 cgd Exp $";
d86 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
