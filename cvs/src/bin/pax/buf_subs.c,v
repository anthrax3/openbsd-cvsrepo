head	1.30;
access;
symbols
	OPENBSD_6_2:1.30.0.2
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.27.0.6
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.8
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.23.0.12
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.21.0.18
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.14
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.12
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.10
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.8
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.6
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.4
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.6
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.7.0.16
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.14
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.12
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2016.12.20.21.29.08;	author kettenis;	state Exp;
branches;
next	1.29;
commitid	o2vw67ta1c9wJpLf;

1.29
date	2016.08.26.04.11.16;	author guenther;	state Exp;
branches;
next	1.28;
commitid	JeDGCh3Baf9wzXzL;

1.28
date	2016.08.14.18.30.33;	author guenther;	state Exp;
branches;
next	1.27;
commitid	qmsIw7NlXw1nDUYx;

1.27
date	2015.03.19.05.14.24;	author guenther;	state Exp;
branches;
next	1.26;
commitid	s0WKwITEr5aJPBA2;

1.26
date	2015.01.16.06.39.32;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	Uu5nFG3wCl0LACBb;

1.25
date	2014.07.14.05.58.19;	author guenther;	state Exp;
branches;
next	1.24;
commitid	7trvwLDtRk2spMXa;

1.24
date	2012.12.04.02.24.45;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2009.12.22.12.09.36;	author jasper;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.09.19.59.06;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.16.22.50.23;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.30.16.14.22;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.20.06.22.27;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.23.32.08;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.03.09.06.43;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.18.15.38.11;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.16.19.20.02;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.16.18.40.30;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.10.16.17.43.10;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.06.20.21.55;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.19.10.58.07;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.16.03.04.55;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.09.01.18.29.46;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.18.58.25;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.07.23.19.15.55;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.04.06.06.11.10;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.20.30;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.06.41.47;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.16;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Fix a bug where archives smaller than 512 bytes would trigger a next volume
prompt.  From NetBSD.

ok millert@@, deraadt@@
@
text
@/*	$OpenBSD: buf_subs.c,v 1.29 2016/08/26 04:11:16 guenther Exp $	*/
/*	$NetBSD: buf_subs.c,v 1.5 1995/03/21 09:07:08 cgd Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include "pax.h"
#include "extern.h"

/*
 * routines which implement archive and file buffering
 */

#define MINFBSZ		512		/* default block size for hole detect */
#define MAXFLT		10		/* default media read error limit */

/*
 * Need to change bufmem to dynamic allocation when the upper
 * limit on blocking size is removed (though that will violate pax spec)
 * MAXBLK define and tests will also need to be updated.
 */
static char bufmem[MAXBLK+BLKMULT];	/* i/o buffer + pushback id space */
static char *buf;			/* normal start of i/o buffer */
static char *bufend;			/* end or last char in i/o buffer */
static char *bufpt;			/* read/write point in i/o buffer */
int blksz = MAXBLK;			/* block input/output size in bytes */
int wrblksz;				/* user spec output size in bytes */
int maxflt = MAXFLT;			/* MAX consecutive media errors */
int rdblksz;				/* first read blksize (tapes only) */
off_t wrlimit;				/* # of bytes written per archive vol */
off_t wrcnt;				/* # of bytes written on current vol */
off_t rdcnt;				/* # of bytes read on current vol */

/*
 * wr_start()
 *	set up the buffering system to operate in a write mode
 * Return:
 *	0 if ok, -1 if the user specified write block size violates pax spec
 */

int
wr_start(void)
{
	buf = &(bufmem[BLKMULT]);
	/*
	 * Check to make sure the write block size meets pax specs. If the user
	 * does not specify a blocksize, we use the format default blocksize.
	 * We must be picky on writes, so we do not allow the user to create an
	 * archive that might be hard to read elsewhere. If all ok, we then
	 * open the first archive volume
	 */
	if (!wrblksz)
		wrblksz = frmt->bsz;
	if (wrblksz > MAXBLK) {
		paxwarn(1, "Write block size of %d too large, maximium is: %d",
			wrblksz, MAXBLK);
		return(-1);
	}
	if (wrblksz % BLKMULT) {
		paxwarn(1, "Write block size of %d is not a %d byte multiple",
		    wrblksz, BLKMULT);
		return(-1);
	}
	if (wrblksz > MAXBLK_POSIX) {
		paxwarn(0, "Write block size of %d larger than POSIX max %d, archive may not be portable",
			wrblksz, MAXBLK_POSIX);
		return(-1);
	}

	/*
	 * we only allow wrblksz to be used with all archive operations
	 */
	blksz = rdblksz = wrblksz;
	if ((ar_open(arcname) < 0) && (ar_next() < 0))
		return(-1);
	wrcnt = 0;
	bufend = buf + wrblksz;
	bufpt = buf;
	return(0);
}

/*
 * rd_start()
 *	set up buffering system to read an archive
 * Return:
 *	0 if ok, -1 otherwise
 */

int
rd_start(void)
{
	/*
	 * leave space for the header pushback (see get_arc()). If we are
	 * going to append and user specified a write block size, check it
	 * right away
	 */
	buf = &(bufmem[BLKMULT]);
	if ((act == APPND) && wrblksz) {
		if (wrblksz > MAXBLK) {
			paxwarn(1,"Write block size %d too large, maximium is: %d",
				wrblksz, MAXBLK);
			return(-1);
		}
		if (wrblksz % BLKMULT) {
			paxwarn(1, "Write block size %d is not a %d byte multiple",
			wrblksz, BLKMULT);
			return(-1);
		}
	}

	/*
	 * open the archive
	 */
	if ((ar_open(arcname) < 0) && (ar_next() < 0))
		return(-1);
	bufend = buf + rdblksz;
	bufpt = bufend;
	rdcnt = 0;
	return(0);
}

/*
 * cp_start()
 *	set up buffer system for copying within the file system
 */

void
cp_start(void)
{
	buf = &(bufmem[BLKMULT]);
	rdblksz = blksz = MAXBLK;
}

/*
 * appnd_start()
 *	Set up the buffering system to append new members to an archive that
 *	was just read. The last block(s) of an archive may contain a format
 *	specific trailer. To append a new member, this trailer has to be
 *	removed from the archive. The first byte of the trailer is replaced by
 *	the start of the header of the first file added to the archive. The
 *	format specific end read function tells us how many bytes to move
 *	backwards in the archive to be positioned BEFORE the trailer. Two
 *	different position have to be adjusted, the O.S. file offset (e.g. the
 *	position of the tape head) and the write point within the data we have
 *	stored in the read (soon to become write) buffer. We may have to move
 *	back several records (the number depends on the size of the archive
 *	record and the size of the format trailer) to read up the record where
 *	the first byte of the trailer is recorded. Trailers may span (and
 *	overlap) record boundaries.
 *	We first calculate which record has the first byte of the trailer. We
 *	move the OS file offset back to the start of this record and read it
 *	up. We set the buffer write pointer to be at this byte (the byte where
 *	the trailer starts). We then move the OS file pointer back to the
 *	start of this record so a flush of this buffer will replace the record
 *	in the archive.
 *	A major problem is rewriting this last record. For archives stored
 *	on disk files, this is trivial. However, many devices are really picky
 *	about the conditions under which they will allow a write to occur.
 *	Often devices restrict the conditions where writes can be made,
 *	so it may not be feasible to append archives stored on all types of
 *	devices.
 * Return:
 *	0 for success, -1 for failure
 */

int
appnd_start(off_t skcnt)
{
	int res;
	off_t cnt;

	if (exit_val != 0) {
		paxwarn(0, "Cannot append to an archive that may have flaws.");
		return(-1);
	}
	/*
	 * if the user did not specify a write blocksize, inherit the size used
	 * in the last archive volume read. (If a is set we still use rdblksz
	 * until next volume, cannot shift sizes within a single volume).
	 */
	if (!wrblksz)
		wrblksz = blksz = rdblksz;
	else
		blksz = rdblksz;

	/*
	 * make sure that this volume allows appends
	 */
	if (ar_app_ok() < 0)
		return(-1);

	/*
	 * Calculate bytes to move back and move in front of record where we
	 * need to start writing from. Remember we have to add in any padding
	 * that might be in the buffer after the trailer in the last block. We
	 * travel skcnt + padding ROUNDED UP to blksize.
	 */
	skcnt += bufend - bufpt;
	if ((cnt = (skcnt/blksz) * blksz) < skcnt)
		cnt += blksz;
	if (ar_rev(cnt) < 0)
		goto out;

	/*
	 * We may have gone too far if there is valid data in the block we are
	 * now in front of, read up the block and position the pointer after
	 * the valid data.
	 */
	if ((cnt -= skcnt) > 0) {
		/*
		 * watch out for stupid tape drives. ar_rev() will set rdblksz
		 * to be real physical blocksize so we must loop until we get
		 * the old rdblksz (now in blksz). If ar_rev() fouls up the
		 * determination of the physical block size, we will fail.
		 */
		bufpt = buf;
		bufend = buf + blksz;
		while (bufpt < bufend) {
			if ((res = ar_read(bufpt, rdblksz)) <= 0)
				goto out;
			bufpt += res;
		}
		if (ar_rev(bufpt - buf) < 0)
			goto out;
		bufpt = buf + cnt;
		bufend = buf + blksz;
	} else {
		/*
		 * buffer is empty
		 */
		bufend = buf + blksz;
		bufpt = buf;
	}
	rdblksz = blksz;
	rdcnt -= skcnt;
	wrcnt = 0;

	/*
	 * At this point we are ready to write. If the device requires special
	 * handling to write at a point were previously recorded data resides,
	 * that is handled in ar_set_wr(). From now on we operate under normal
	 * ARCHIVE mode (write) conditions
	 */
	if (ar_set_wr() < 0)
		return(-1);
	act = ARCHIVE;
	return(0);

    out:
	paxwarn(1, "Unable to rewrite archive trailer, cannot append.");
	return(-1);
}

/*
 * rd_sync()
 *	A read error occurred on this archive volume. Resync the buffer and
 *	try to reset the device (if possible) so we can continue to read. Keep
 *	trying to do this until we get a valid read, or we reach the limit on
 *	consecutive read faults (at which point we give up). The user can
 *	adjust the read error limit through a command line option.
 * Returns:
 *	0 on success, and -1 on failure
 */

int
rd_sync(void)
{
	int errcnt = 0;
	int res;

	/*
	 * if the user says bail out on first fault, we are out of here...
	 */
	if (maxflt == 0)
		return(-1);
	if (act == APPND) {
		paxwarn(1, "Unable to append when there are archive read errors.");
		return(-1);
	}

	/*
	 * poke at device and try to get past media error
	 */
	if (ar_rdsync() < 0) {
		if (ar_next() < 0)
			return(-1);
		else
			rdcnt = 0;
	}

	for (;;) {
		if ((res = ar_read(buf, blksz)) > 0) {
			/*
			 * All right! got some data, fill that buffer
			 */
			bufpt = buf;
			bufend = buf + res;
			rdcnt += res;
			return(0);
		}

		/*
		 * Oh well, yet another failed read...
		 * if error limit reached, ditch. o.w. poke device to move past
		 * bad media and try again. if media is badly damaged, we ask
		 * the poor (and upset user at this point) for the next archive
		 * volume. remember the goal on reads is to get the most we
		 * can extract out of the archive.
		 */
		if ((maxflt > 0) && (++errcnt > maxflt))
			paxwarn(0,"Archive read error limit (%d) reached",maxflt);
		else if (ar_rdsync() == 0)
			continue;
		if (ar_next() < 0)
			break;
		rdcnt = 0;
		errcnt = 0;
	}
	return(-1);
}

/*
 * pback()
 *	push the data used during the archive id phase back into the I/O
 *	buffer. This is required as we cannot be sure that the header does NOT
 *	overlap a block boundary (as in the case we are trying to recover a
 *	flawed archived). This was not designed to be used for any other
 *	purpose. (What software engineering, HA!)
 *	WARNING: do not even THINK of pback greater than BLKMULT, unless the
 *	pback space is increased.
 */

void
pback(char *pt, int cnt)
{
	bufpt -= cnt;
	memcpy(bufpt, pt, cnt);
}

/*
 * rd_skip()
 *	skip forward in the archive during a archive read. Used to get quickly
 *	past file data and padding for files the user did NOT select.
 * Return:
 *	0 if ok, -1 failure, and 1 when EOF on the archive volume was detected.
 */

int
rd_skip(off_t skcnt)
{
	off_t res;
	off_t cnt;
	off_t skipped = 0;

	/*
	 * consume what data we have in the buffer. If we have to move forward
	 * whole records, we call the low level skip function to see if we can
	 * move within the archive without doing the expensive reads on data we
	 * do not want.
	 */
	if (skcnt == 0)
		return(0);
	res = MINIMUM((bufend - bufpt), skcnt);
	bufpt += res;
	skcnt -= res;

	/*
	 * if skcnt is now 0, then no additional i/o is needed
	 */
	if (skcnt == 0)
		return(0);

	/*
	 * We have to read more, calculate complete and partial record reads
	 * based on rdblksz. we skip over "cnt" complete records
	 */
	res = skcnt%rdblksz;
	cnt = (skcnt/rdblksz) * rdblksz;

	/*
	 * if the skip fails, we will have to resync. ar_fow will tell us
	 * how much it can skip over. We will have to read the rest.
	 */
	if (ar_fow(cnt, &skipped) < 0)
		return(-1);
	res += cnt - skipped;
	rdcnt += skipped;

	/*
	 * what is left we have to read (which may be the whole thing if
	 * ar_fow() told us the device can only read to skip records);
	 */
	while (res > 0) {
		cnt = bufend - bufpt;
		/*
		 * if the read fails, we will have to resync
		 */
		if ((cnt <= 0) && ((cnt = buf_fill()) < 0))
			return(-1);
		if (cnt == 0)
			return(1);
		cnt = MINIMUM(cnt, res);
		bufpt += cnt;
		res -= cnt;
	}
	return(0);
}

/*
 * wr_fin()
 *	flush out any data (and pad if required) the last block. We always pad
 *	with zero (even though we do not have to). Padding with 0 makes it a
 *	lot easier to recover if the archive is damaged. zero padding SHOULD
 *	BE a requirement....
 */

void
wr_fin(void)
{
	if (bufpt > buf) {
		memset(bufpt, 0, bufend - bufpt);
		bufpt = bufend;
		(void)buf_flush(blksz);
	}
}

/*
 * wr_rdbuf()
 *	fill the write buffer from data passed to it in a buffer (usually used
 *	by format specific write routines to pass a file header). On failure we
 *	punt. We do not allow the user to continue to write flawed archives.
 *	We assume these headers are not very large (the memory copy we use is
 *	a bit expensive).
 * Return:
 *	0 if buffer was filled ok, -1 o.w. (buffer flush failure)
 */

int
wr_rdbuf(char *out, int outcnt)
{
	int cnt;

	/*
	 * while there is data to copy copy into the write buffer. when the
	 * write buffer fills, flush it to the archive and continue
	 */
	while (outcnt > 0) {
		cnt = bufend - bufpt;
		if ((cnt <= 0) && ((cnt = buf_flush(blksz)) < 0))
			return(-1);
		/*
		 * only move what we have space for
		 */
		cnt = MINIMUM(cnt, outcnt);
		memcpy(bufpt, out, cnt);
		bufpt += cnt;
		out += cnt;
		outcnt -= cnt;
	}
	return(0);
}

/*
 * rd_wrbuf()
 *	copy from the read buffer into a supplied buffer a specified number of
 *	bytes. If the read buffer is empty fill it and continue to copy.
 *	usually used to obtain a file header for processing by a format
 *	specific read routine.
 * Return
 *	number of bytes copied to the buffer, 0 indicates EOF on archive volume,
 *	-1 is a read error
 */

int
rd_wrbuf(char *in, int cpcnt)
{
	int res;
	int cnt;
	int incnt = cpcnt;

	/*
	 * loop until we fill the buffer with the requested number of bytes
	 */
	while (incnt > 0) {
		cnt = bufend - bufpt;
		if ((cnt <= 0) && ((cnt = buf_fill()) <= 0)) {
			/*
			 * read error, return what we got (or the error if
			 * no data was copied). The caller must know that an
			 * error occurred and has the best knowledge what to
			 * do with it
			 */
			if ((res = cpcnt - incnt) > 0)
				return(res);
			return(cnt);
		}

		/*
		 * calculate how much data to copy based on whats left and
		 * state of buffer
		 */
		cnt = MINIMUM(cnt, incnt);
		memcpy(in, bufpt, cnt);
		bufpt += cnt;
		incnt -= cnt;
		in += cnt;
	}
	return(cpcnt);
}

/*
 * wr_skip()
 *	skip forward during a write. In other words add padding to the file.
 *	we add zero filled padding as it makes flawed archives much easier to
 *	recover from. the caller tells us how many bytes of padding to add
 *	This routine was not designed to add HUGE amount of padding, just small
 *	amounts (a few 512 byte blocks at most)
 * Return:
 *	0 if ok, -1 if there was a buf_flush failure
 */

int
wr_skip(off_t skcnt)
{
	int cnt;

	/*
	 * loop while there is more padding to add
	 */
	while (skcnt > 0) {
		cnt = bufend - bufpt;
		if ((cnt <= 0) && ((cnt = buf_flush(blksz)) < 0))
			return(-1);
		cnt = MINIMUM(cnt, skcnt);
		memset(bufpt, 0, cnt);
		bufpt += cnt;
		skcnt -= cnt;
	}
	return(0);
}

/*
 * wr_rdfile()
 *	fill write buffer with the contents of a file. We are passed an	open
 *	file descriptor to the file an the archive structure that describes the
 *	file we are storing. The variable "left" is modified to contain the
 *	number of bytes of the file we were NOT able to write to the archive.
 *	it is important that we always write EXACTLY the number of bytes that
 *	the format specific write routine told us to. The file can also get
 *	bigger, so reading to the end of file would create an improper archive,
 *	we just detect this case and warn the user. We never create a bad
 *	archive if we can avoid it. Of course trying to archive files that are
 *	active is asking for trouble. It we fail, we pass back how much we
 *	could NOT copy and let the caller deal with it.
 * Return:
 *	0 ok, -1 if archive write failure. a short read of the file returns a
 *	0, but "left" is set to be greater than zero.
 */

int
wr_rdfile(ARCHD *arcn, int ifd, off_t *left)
{
	int cnt;
	int res = 0;
	off_t size = arcn->sb.st_size;
	struct stat sb;

	/*
	 * while there are more bytes to write
	 */
	while (size > 0) {
		cnt = bufend - bufpt;
		if ((cnt <= 0) && ((cnt = buf_flush(blksz)) < 0)) {
			*left = size;
			return(-1);
		}
		cnt = MINIMUM(cnt, size);
		if ((res = read(ifd, bufpt, cnt)) <= 0)
			break;
		size -= res;
		bufpt += res;
	}

	/*
	 * better check the file did not change during this operation
	 * or the file read failed.
	 */
	if (res < 0)
		syswarn(1, errno, "Read fault on %s", arcn->org_name);
	else if (size != 0)
		paxwarn(1, "File changed size during read %s", arcn->org_name);
	else if (fstat(ifd, &sb) < 0)
		syswarn(1, errno, "Failed stat on %s", arcn->org_name);
	else if (timespeccmp(&arcn->sb.st_mtim, &sb.st_mtim, !=))
		paxwarn(1, "File %s was modified during copy to archive",
			arcn->org_name);
	*left = size;
	return(0);
}

/*
 * rd_wrfile()
 *	extract the contents of a file from the archive. If we are unable to
 *	extract the entire file (due to failure to write the file) we return
 *	the numbers of bytes we did NOT process. This way the caller knows how
 *	many bytes to skip past to find the next archive header. If the failure
 *	was due to an archive read, we will catch that when we try to skip. If
 *	the format supplies a file data crc value, we calculate the actual crc
 *	so that it can be compared to the value stored in the header
 * NOTE:
 *	We call a special function to write the file. This function attempts to
 *	restore file holes (blocks of zeros) into the file. When files are
 *	sparse this saves space, and is a LOT faster. For non sparse files
 *	the performance hit is small. As of this writing, no archive supports
 *	information on where the file holes are.
 * Return:
 *	0 ok, -1 if archive read failure. if we cannot write the entire file,
 *	we return a 0 but "left" is set to be the amount unwritten
 */

int
rd_wrfile(ARCHD *arcn, int ofd, off_t *left)
{
	int cnt = 0;
	off_t size = arcn->sb.st_size;
	int res = 0;
	char *fnm = arcn->name;
	int isem = 1;
	int rem;
	int sz = MINFBSZ;
	struct stat sb;
	u_int32_t crc = 0;

	/*
	 * pass the blocksize of the file being written to the write routine,
	 * if the size is zero, use the default MINFBSZ
	 */
	if (ofd < 0)
		sz = PAXPATHLEN + 1;		/* GNU tar long link/file */
	else if (fstat(ofd, &sb) == 0) {
		if (sb.st_blksize > 0)
			sz = (int)sb.st_blksize;
	} else
		syswarn(0,errno,"Unable to obtain block size for file %s",fnm);
	rem = sz;
	*left = 0;

	/*
	 * Copy the archive to the file the number of bytes specified. We have
	 * to assume that we want to recover file holes as none of the archive
	 * formats can record the location of file holes.
	 */
	while (size > 0) {
		cnt = bufend - bufpt;
		/*
		 * if we get a read error, we do not want to skip, as we may
		 * miss a header, so we do not set left, but if we get a write
		 * error, we do want to skip over the unprocessed data.
		 */
		if ((cnt <= 0) && ((cnt = buf_fill()) <= 0))
			break;
		cnt = MINIMUM(cnt, size);
		if ((res = file_write(ofd,bufpt,cnt,&rem,&isem,sz,fnm)) <= 0) {
			*left = size;
			break;
		}

		if (docrc) {
			/*
			 * update the actual crc value
			 */
			cnt = res;
			while (--cnt >= 0)
				crc += *bufpt++ & 0xff;
		} else
			bufpt += res;
		size -= res;
	}

	/*
	 * if the last block has a file hole (all zero), we must make sure this
	 * gets updated in the file. We force the last block of zeros to be
	 * written. just closing with the file offset moved forward may not put
	 * a hole at the end of the file.
	 */
	if (isem && (arcn->sb.st_size > 0))
		file_flush(ofd, fnm, isem);

	/*
	 * if we failed from archive read, we do not want to skip
	 */
	if ((size > 0) && (*left == 0))
		return(-1);

	/*
	 * some formats record a crc on file data. If so, then we compare the
	 * calculated crc to the crc stored in the archive
	 */
	if (docrc && (size == 0) && (arcn->crc != crc))
		paxwarn(1,"Actual crc does not match expected crc %s",arcn->name);
	return(0);
}

/*
 * cp_file()
 *	copy the contents of one file to another. used during -rw phase of pax
 *	just as in rd_wrfile() we use a special write function to write the
 *	destination file so we can properly copy files with holes.
 */

void
cp_file(ARCHD *arcn, int fd1, int fd2)
{
	int cnt;
	off_t cpcnt = 0;
	int res = 0;
	char *fnm = arcn->name;
	int no_hole = 0;
	int isem = 1;
	int rem;
	int sz = MINFBSZ;
	struct stat sb;

	/*
	 * check for holes in the source file. If none, we will use regular
	 * write instead of file write.
	 */
	 if (((off_t)(arcn->sb.st_blocks * BLKMULT)) >= arcn->sb.st_size)
		++no_hole;

	/*
	 * pass the blocksize of the file being written to the write routine,
	 * if the size is zero, use the default MINFBSZ
	 */
	if (fstat(fd2, &sb) == 0) {
		if (sb.st_blksize > 0)
			sz = sb.st_blksize;
	} else
		syswarn(0,errno,"Unable to obtain block size for file %s",fnm);
	rem = sz;

	/*
	 * read the source file and copy to destination file until EOF
	 */
	for (;;) {
		if ((cnt = read(fd1, buf, blksz)) <= 0)
			break;
		if (no_hole)
			res = write(fd2, buf, cnt);
		else
			res = file_write(fd2, buf, cnt, &rem, &isem, sz, fnm);
		if (res != cnt)
			break;
		cpcnt += cnt;
	}

	/*
	 * check to make sure the copy is valid.
	 */
	if (res < 0)
		syswarn(1, errno, "Failed write during copy of %s to %s",
			arcn->org_name, arcn->name);
	else if (cpcnt != arcn->sb.st_size)
		paxwarn(1, "File %s changed size during copy to %s",
			arcn->org_name, arcn->name);
	else if (fstat(fd1, &sb) < 0)
		syswarn(1, errno, "Failed stat of %s", arcn->org_name);
	else if (timespeccmp(&arcn->sb.st_mtim, &sb.st_mtim, !=))
		paxwarn(1, "File %s was modified during copy to %s",
			arcn->org_name, arcn->name);

	/*
	 * if the last block has a file hole (all zero), we must make sure this
	 * gets updated in the file. We force the last block of zeros to be
	 * written. just closing with the file offset moved forward may not put
	 * a hole at the end of the file.
	 */
	if (!no_hole && isem && (arcn->sb.st_size > 0))
		file_flush(fd2, fnm, isem);
}

/*
 * buf_fill()
 *	fill the read buffer with the next record (or what we can get) from
 *	the archive volume.
 * Return:
 *	Number of bytes of data in the read buffer, -1 for read error, and
 *	0 when finished (user specified termination in ar_next()).
 */

int
buf_fill(void)
{
	int cnt;
	static int fini = 0;

	if (fini)
		return(0);

	for (;;) {
		/*
		 * try to fill the buffer. on error the next archive volume is
		 * opened and we try again.
		 */
		if ((cnt = ar_read(buf, blksz)) > 0) {
			bufpt = buf;
			bufend = buf + cnt;
			rdcnt += cnt;
			return(cnt);
		}

		/*
		 * errors require resync, EOF goes to next archive
		 * but in case we have not determined yet the format,
		 * this means that we have a very short file, so we
		 * are done again.
		 */
		if (cnt < 0)
			break;
		if (frmt == NULL || ar_next() < 0) {
			fini = 1;
			return(0);
		}
		rdcnt = 0;
	}
	exit_val = 1;
	return(-1);
}

/*
 * buf_flush()
 *	force the write buffer to the archive. We are passed the number of
 *	bytes in the buffer at the point of the flush. When we change archives
 *	the record size might change. (either larger or smaller).
 * Return:
 *	0 if all is ok, -1 when a write error occurs.
 */

int
buf_flush(int bufcnt)
{
	int cnt;
	int push = 0;
	int totcnt = 0;

	/*
	 * if we have reached the user specified byte count for each archive
	 * volume, prompt for the next volume. (The non-standard -R flag).
	 * NOTE: If the wrlimit is smaller than wrcnt, we will always write
	 * at least one record. We always round limit UP to next blocksize.
	 */
	if ((wrlimit > 0) && (wrcnt > wrlimit)) {
		paxwarn(0, "User specified archive volume byte limit reached.");
		if (ar_next() < 0) {
			wrcnt = 0;
			exit_val = 1;
			return(-1);
		}
		wrcnt = 0;

		/*
		 * The new archive volume might have changed the size of the
		 * write blocksize. if so we figure out if we need to write
		 * (one or more times), or if there is now free space left in
		 * the buffer (it is no longer full). bufcnt has the number of
		 * bytes in the buffer, (the blocksize, at the point we were
		 * CALLED). Push has the amount of "extra" data in the buffer
		 * if the block size has shrunk from a volume change.
		 */
		bufend = buf + blksz;
		if (blksz > bufcnt)
			return(0);
		if (blksz < bufcnt)
			push = bufcnt - blksz;
	}

	/*
	 * We have enough data to write at least one archive block
	 */
	for (;;) {
		/*
		 * write a block and check if it all went out ok
		 */
		cnt = ar_write(buf, blksz);
		if (cnt == blksz) {
			/*
			 * the write went ok
			 */
			wrcnt += cnt;
			totcnt += cnt;
			if (push > 0) {
				/* we have extra data to push to the front.
				 * check for more than 1 block of push, and if
				 * so we loop back to write again
				 */
				memcpy(buf, bufend, push);
				bufpt = buf + push;
				if (push >= blksz) {
					push -= blksz;
					continue;
				}
			} else
				bufpt = buf;
			return(totcnt);
		} else if (cnt > 0) {
			/*
			 * Oh drat we got a partial write!
			 * if format does not care about alignment let it go,
			 * we warned the user in ar_write().... but this means
			 * the last record on this volume violates pax spec....
			 */
			totcnt += cnt;
			wrcnt += cnt;
			bufpt = buf + cnt;
			cnt = bufcnt - cnt;
			memcpy(buf, bufpt, cnt);
			bufpt = buf + cnt;
			if (!frmt->blkalgn || ((cnt % frmt->blkalgn) == 0))
				return(totcnt);
			break;
		}

		/*
		 * All done, go to next archive
		 */
		wrcnt = 0;
		if (ar_next() < 0)
			break;

		/*
		 * The new archive volume might also have changed the block
		 * size. if so, figure out if we have too much or too little
		 * data for using the new block size
		 */
		bufend = buf + blksz;
		if (blksz > bufcnt)
			return(0);
		if (blksz < bufcnt)
			push = bufcnt - blksz;
	}

	/*
	 * write failed, stop pax. we must not create a bad archive!
	 */
	exit_val = 1;
	return(-1);
}
@


1.29
log
@Don't need <sys/time.h> or "options.h" here
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.28 2016/08/14 18:30:33 guenther Exp $	*/
d851 3
d857 1
a857 1
		if (ar_next() < 0) {
@


1.28
log
@Remove many unnecessary casts.  Verified by comparing generated code on
both ILP32 and LP64.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.27 2015/03/19 05:14:24 guenther Exp $	*/
a37 1
#include <sys/time.h>
@


1.27
log
@Use struct timespec internally.  This gives nanosecond precision to pax -rw
and a basis for support of mtime and atime values in pax-format extended
header records.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.26 2015/01/16 06:39:32 deraadt Exp $	*/
d239 1
a239 1
	if (ar_rev((off_t)cnt) < 0)
d261 1
a261 1
		if (ar_rev((off_t)(bufpt - buf)) < 0)
d431 1
a431 1
	while (res > 0L) {
d568 1
a568 1
	while (skcnt > 0L) {
d609 1
a609 1
	while (size > 0L) {
d628 1
a628 1
	else if (size != 0L)
d684 1
a684 1
	*left = 0L;
d691 1
a691 1
	while (size > 0L) {
d724 1
a724 1
	if (isem && (arcn->sb.st_size > 0L))
d730 1
a730 1
	if ((size > 0L) && (*left == 0L))
d737 1
a737 1
	if (docrc && (size == 0L) && (arcn->crc != crc))
d753 1
a753 1
	off_t cpcnt = 0L;
d816 1
a816 1
	if (!no_hole && isem && (arcn->sb.st_size > 0L))
@


1.26
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.25 2014/07/14 05:58:19 guenther Exp $	*/
d632 1
a632 1
	else if (arcn->sb.st_mtime != sb.st_mtime)
d806 1
a806 1
	else if (arcn->sb.st_mtime != sb.st_mtime)
@


1.25
log
@Delete pointless 'return;' at end of function
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.24 2012/12/04 02:24:45 deraadt Exp $	*/
d401 1
a401 1
	res = MIN((bufend - bufpt), skcnt);
d440 1
a440 1
		cnt = MIN(cnt, res);
d492 1
a492 1
		cnt = MIN(cnt, outcnt);
d540 1
a540 1
		cnt = MIN(cnt, incnt);
d572 1
a572 1
		cnt = MIN(cnt, skcnt);
d615 1
a615 1
		cnt = MIN(cnt, size);
d700 1
a700 1
		cnt = MIN(cnt, size);
@


1.24
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.23 2009/12/22 12:09:36 jasper Exp $	*/
a375 1
	return;
a817 1
	return;
@


1.23
log
@- two more typo's spotted by Brad Tilley
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.22 2009/10/27 23:59:22 deraadt Exp $	*/
a39 1
#include <sys/param.h>
@


1.22
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.21 2005/11/09 19:59:06 otto Exp $	*/
d946 1
a946 1
			 * if format doesnt care about alignment let it go,
@


1.21
log
@Compute the sv4cpio "crc" (it's actualy just a checksum) as a 32bit
number. Fixes crc computation on 64 bit archs. From Peter Philipp in PR
4606; looks right fgsch@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.20 2004/04/16 22:50:23 deraadt Exp $	*/
a35 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)buf_subs.c	8.2 (Berkeley) 4/18/94";
#else
static const char rcsid[] = "$OpenBSD: buf_subs.c,v 1.20 2004/04/16 22:50:23 deraadt Exp $";
#endif
#endif /* not lint */
@


1.20
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.19 2004/03/30 16:14:22 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: buf_subs.c,v 1.19 2004/03/30 16:14:22 millert Exp $";
d680 1
a680 1
	u_long crc = 0L;
@


1.19
log
@Add support for expanding GNU long links from NetBSD.  I've had this
in my tree for ages but didn't have a proper test case.  Thanks to
otto@@ for providing one.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.18 2003/10/20 06:22:27 jmc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: buf_subs.c,v 1.18 2003/10/20 06:22:27 jmc Exp $";
d793 1
a793 1
	for(;;) {
d849 1
a849 1
	for(;;) {
@


1.18
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.17 2003/06/02 23:32:08 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: buf_subs.c,v 1.17 2003/06/02 23:32:08 millert Exp $";
d686 1
a686 1
	if (ofd == -1)
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.16 2003/02/03 09:06:43 jmc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: buf_subs.c,v 1.16 2003/02/03 09:06:43 jmc Exp $";
d207 1
a207 1
 *	so it may not be feasable to append archives stored on all types of
d461 1
a461 1
 *	lot easier to recover if the archive is damaged. zero paddding SHOULD
@


1.16
log
@typos;
from netbsd(svs+pr@@grep.ru)
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.15 2002/10/18 15:38:11 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: buf_subs.c,v 1.15 2002/10/18 15:38:11 millert Exp $";
@


1.15
log
@Pull in some changes from NetBSD
o When extracting GNU tar archives, honor @@LongLink long links/files
o Add an option to prevent pax from prompting for the next volume
  upon premature end of archive.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.14 2002/10/16 19:20:02 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: buf_subs.c,v 1.14 2002/10/16 19:20:02 millert Exp $";
d208 1
a208 1
 *	on disk files, this is trival. However, many devices are really picky
d210 1
a210 1
 *	Often devices restrict the conditions where writes can be made writes,
@


1.14
log
@sprinkle const; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.13 2002/10/16 18:40:30 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: buf_subs.c,v 1.13 2002/10/16 18:40:30 millert Exp $";
d690 3
a692 1
	if (fstat(ofd, &sb) == 0) {
@


1.13
log
@Fix comment typos; most from NetBSD and FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.12 2002/10/16 17:43:10 millert Exp $	*/
d43 1
a43 1
static char sccsid[] = "@@(#)buf_subs.c	8.2 (Berkeley) 4/18/94";
d45 1
a45 1
static char rcsid[] = "$OpenBSD: buf_subs.c,v 1.12 2002/10/16 17:43:10 millert Exp $";
@


1.12
log
@kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.11 2002/02/19 19:39:35 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: buf_subs.c,v 1.11 2002/02/19 19:39:35 millert Exp $";
d194 1
a194 1
 *	different postions have to be adjusted, the O.S. file offset (e.g. the
d200 1
a200 1
 *	overlap) record boundries.
d377 1
a377 1
 *	overlap a block boundry (as in the case we are trying to recover a
d394 1
a394 1
 *	skip foward in the archive during a archive read. Used to get quickly
d408 1
a408 1
	 * consume what data we have in the buffer. If we have to move foward
d565 1
a565 1
 *	skip foward during a write. In other words add padding to the file.
d733 1
a733 1
	 * written. just closing with the file offset moved foward may not put
d825 1
a825 1
	 * written. just closing with the file offset moved foward may not put
@


1.11
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.10 2001/10/06 20:21:55 niklas Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: buf_subs.c,v 1.10 2001/10/06 20:21:55 niklas Exp $";
d220 1
a220 1
	register int res;
d319 2
a320 2
	register int errcnt = 0;
	register int res;
d491 1
a491 1
wr_rdbuf(register char *out, register int outcnt)
d493 1
a493 1
	register int cnt;
d527 1
a527 1
rd_wrbuf(register char *in, register int cpcnt)
d529 3
a531 3
	register int res;
	register int cnt;
	register int incnt = cpcnt;
d577 1
a577 1
	register int cnt;
d615 3
a617 3
	register int cnt;
	register int res = 0;
	register off_t size = arcn->sb.st_size;
d676 4
a679 4
	register int cnt = 0;
	register off_t size = arcn->sb.st_size;
	register int res = 0;
	register char *fnm = arcn->name;
d764 5
a768 5
	register int cnt;
	register off_t cpcnt = 0L;
	register int res = 0;
	register char *fnm = arcn->name;
	register int no_hole = 0;
d845 1
a845 1
	register int cnt;
d888 1
a888 1
buf_flush(register int bufcnt)
d890 3
a892 3
	register int cnt;
	register int push = 0;
	register int totcnt = 0;
@


1.10
log
@s/standrad/standard/
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.9 2001/09/19 10:58:07 mpech Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: buf_subs.c,v 1.9 2001/09/19 10:58:07 mpech Exp $";
a91 1
#ifdef __STDC__
a93 4
#else
int
wr_start()
#endif
a139 1
#ifdef __STDC__
a141 4
#else
int
rd_start()
#endif
a177 1
#ifdef __STDC__
a179 4
#else
void
cp_start()
#endif
a216 1
#ifdef __STDC__
a218 5
#else
int
appnd_start(skcnt)
	off_t skcnt;
#endif
a315 1
#ifdef __STDC__
a317 4
#else
int
rd_sync()
#endif
a383 1
#ifdef __STDC__
a385 6
#else
void
pback(pt, cnt)
	char *pt;
	int cnt;
#endif
a399 1
#ifdef __STDC__
a401 5
#else
int
rd_skip(skcnt)
	off_t skcnt;
#endif
a468 1
#ifdef __STDC__
a470 4
#else
void
wr_fin()
#endif
a489 1
#ifdef __STDC__
a491 6
#else
int
wr_rdbuf(out, outcnt)
	register char *out;
	register int outcnt;
#endif
a525 1
#ifdef __STDC__
a527 6
#else
int
rd_wrbuf(in, cpcnt)
	register char *in;
	register int cpcnt;
#endif
a573 1
#ifdef __STDC__
a575 5
#else
int
wr_skip(skcnt)
	off_t skcnt;
#endif
a611 1
#ifdef __STDC__
a613 7
#else
int
wr_rdfile(arcn, ifd, left)
	ARCHD *arcn;
	int ifd;
	off_t *left;
#endif
a672 1
#ifdef __STDC__
a674 7
#else
int
rd_wrfile(arcn, ofd, left)
	ARCHD *arcn;
	int ofd;
	off_t *left;
#endif
a760 1
#ifdef __STDC__
a762 7
#else
void
cp_file(arcn, fd1, fd2)
	ARCHD *arcn;
	int fd1;
	int fd2;
#endif
a841 1
#ifdef __STDC__
a843 4
#else
int
buf_fill()
#endif
a886 1
#ifdef __STDC__
a888 5
#else
int
buf_flush(bufcnt)
	register int bufcnt;
#endif
@


1.9
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok

p.s. Next commit will fix a typo in the sys/
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.8 2001/05/16 03:04:55 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: buf_subs.c,v 1.8 2001/05/16 03:04:55 mickey Exp $";
d995 1
a995 1
	 * volume, prompt for the next volume. (The non-standrad -R flag).
@


1.8
log
@use proper str*cpy functions instead of home grown one, spaces; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.7 1997/09/01 18:29:46 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: buf_subs.c,v 1.7 1997/09/01 18:29:46 deraadt Exp $";
d600 1
a600 1
			 * error occured and has the best knowledge what to
@


1.7
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.6 1997/07/25 18:58:25 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: buf_subs.c,v 1.6 1997/07/25 18:58:25 mickey Exp $";
d127 1
a127 1
	 * we only allow wrblksz to be used with all archive operations 
d167 1
a167 1
		    	wrblksz, BLKMULT);
d227 1
a227 1
 *	devices. 
d325 1
a325 1
	
d500 1
a500 1
/* 
d529 1
a529 1
 *	a bit expensive). 
d763 1
a763 1
 	struct stat sb;
@


1.6
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.5 1997/07/23 19:15:55 kstailey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: buf_subs.c,v 1.5 1997/07/23 19:15:55 kstailey Exp $";
d108 1
a108 1
	if (!wrblksz)  
d822 1
a822 1
	if ((size > 0L) && (*left == 0L)) 
d1031 1
a1031 1
		cnt = ar_write(buf, blksz); 
@


1.5
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.4 1997/04/06 06:11:10 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: buf_subs.c,v 1.4 1997/04/06 06:11:10 millert Exp $";
d92 1
a92 1
#if __STDC__
d145 1
a145 1
#if __STDC__
d188 1
a188 1
#if __STDC__
d232 1
a232 1
#if __STDC__
d337 1
a337 1
#if __STDC__
d410 1
a410 1
#if __STDC__
d433 1
a433 1
#if __STDC__
d508 1
a508 1
#if __STDC__
d534 1
a534 1
#if __STDC__
d577 1
a577 1
#if __STDC__
d632 1
a632 1
#if __STDC__
d676 1
a676 1
#if __STDC__
d745 1
a745 1
#if __STDC__
d841 1
a841 1
#if __STDC__
d930 1
a930 1
#if __STDC__
d980 1
a980 1
#if __STDC__
@


1.4
log
@Allow creation of archives with block sizes up to 64512 bytes
but complain about non-portability if > 32256 bytes.
Brought up by George Robbins <grr@@shandakor.tharsis.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.3 1996/06/23 14:20:30 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: buf_subs.c,v 1.3 1996/06/23 14:20:30 deraadt Exp $";
d66 1
a66 1
#define MAXFLT          10              /* default media read error limit */
d77 2
a78 2
int blksz = MAXBLK;                    	/* block input/output size in bytes */
int wrblksz;                      	/* user spec output size in bytes */
d770 1
a770 1
        if (fstat(ofd, &sb) == 0) {
d773 2
a774 2
        } else
                syswarn(0,errno,"Unable to obtain block size for file %s",fnm);
d873 1
a873 1
        if (fstat(fd2, &sb) == 0) {
d876 2
a877 2
        } else
                syswarn(0,errno,"Unable to obtain block size for file %s",fnm);
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.5 1995/03/21 09:07:08 cgd Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: buf_subs.c,v 1.5 1995/03/21 09:07:08 cgd Exp $";
d118 5
@


1.2
log
@Correct compile warnings
Rename warn() to paxwarn() so <err.h> can be included

Remove #include <ctype.h> when not needed; from FreeBSD
@
text
@d1 1
d45 1
a45 1
static char rcsid[] = "$NetBSD: buf_subs.c,v 1.5 1995/03/21 09:07:08 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@a52 1
#include <ctype.h>
d110 1
a110 1
		warn(1, "Write block size of %d too large, maximium is: %d",
d115 1
a115 1
		warn(1, "Write block size of %d is not a %d byte multiple",
d155 1
a155 1
			warn(1,"Write block size %d too large, maximium is: %d",
d160 1
a160 1
			warn(1, "Write block size %d is not a %d byte multiple",
d239 1
a239 1
		warn(0, "Cannot append to an archive that may have flaws.");
d316 1
a316 1
	warn(1, "Unable to rewrite archive trailer, cannot append.");
d348 1
a348 1
		warn(1, "Unable to append when there are archive read errors.");
d382 1
a382 1
			warn(0,"Archive read error limit (%d) reached",maxflt);
d709 1
a709 1
		warn(1, "File changed size during read %s", arcn->org_name);
d713 1
a713 1
		warn(1, "File %s was modified during copy to archive",
d824 1
a824 1
		warn(1,"Actual crc does not match expected crc %s",arcn->name);
d896 1
a896 1
		warn(1, "File %s changed size during copy to %s",
d901 1
a901 1
		warn(1, "File %s was modified during copy to %s",
d994 1
a994 1
		warn(0, "User specified archive volume byte limit reached.");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
