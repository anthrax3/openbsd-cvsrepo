head	1.48;
access;
symbols
	OPENBSD_6_2:1.48.0.2
	OPENBSD_6_2_BASE:1.48
	OPENBSD_6_1:1.48.0.4
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.45.0.6
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.45.0.4
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.34.0.4
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.33.0.12
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.10
	OPENBSD_5_0:1.33.0.8
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.6
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.8
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.4
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.31.0.6
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.4
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.28.0.6
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.4
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.14.0.12
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.14.0.10
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.8
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.14.0.6
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.13.0.4
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2016.08.26.05.06.14;	author guenther;	state Exp;
branches;
next	1.47;
commitid	p36gyuPwcgIjfujh;

1.47
date	2016.08.26.04.31.35;	author guenther;	state Exp;
branches;
next	1.46;
commitid	oEeHzAYDyi3kUy6E;

1.46
date	2016.08.25.01.44.55;	author guenther;	state Exp;
branches;
next	1.45;
commitid	udvMiyfPVZQYw9Ht;

1.45
date	2015.03.19.05.14.24;	author guenther;	state Exp;
branches;
next	1.44;
commitid	s0WKwITEr5aJPBA2;

1.44
date	2015.03.17.03.23.17;	author guenther;	state Exp;
branches;
next	1.43;
commitid	gv8qhyah1XKC6RDB;

1.43
date	2015.03.12.04.15.03;	author guenther;	state Exp;
branches;
next	1.42;
commitid	bOaKdaMtDoZV3lP7;

1.42
date	2015.03.09.04.23.29;	author guenther;	state Exp;
branches;
next	1.41;
commitid	JMkpovMhu0rmLvCn;

1.41
date	2015.02.21.22.48.23;	author guenther;	state Exp;
branches
	1.41.2.1;
next	1.40;
commitid	AdteqX8nU06lUYnQ;

1.40
date	2015.02.12.23.44.57;	author guenther;	state Exp;
branches;
next	1.39;
commitid	lkvsxr9r9MdXqaQN;

1.39
date	2014.05.23.19.47.49;	author guenther;	state Exp;
branches
	1.39.4.1;
next	1.38;

1.38
date	2014.02.05.20.35.42;	author halex;	state Exp;
branches;
next	1.37;

1.37
date	2014.01.30.13.30.11;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2014.01.08.06.41.49;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2014.01.08.04.43.48;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2012.12.04.02.24.45;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2008.05.06.06.54.28;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2006.11.17.08.38.04;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2006.07.21.22.56.58;	author ray;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.25.17.42.08;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.16.22.50.23;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.30.16.14.22;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.15.22.18.15;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.26.00.10.17;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.02.23.32.08;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.03.09.06.43;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.18.15.38.11;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.16.19.20.02;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.16.18.40.30;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.16.17.43.10;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.17.18.19.48;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.16.03.04.55;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	98.09.20.02.22.21;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.09.16.21.20.35;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.09.01.18.29.44;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.07.25.18.58.24;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.07.24.23.19.17;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.23.19.15.54;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.06.18.18.48.24;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.06.04.00.15.14;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.02.27.23.32.57;	author michaels;	state Exp;
branches;
next	1.5;

1.5
date	97.01.24.19.41.19;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.10.27.06.45.09;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.20.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.06.41.47;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.16;	author deraadt;	state Exp;
branches;
next	;

1.39.4.1
date	2015.04.30.19.30.57;	author guenther;	state Exp;
branches;
next	;
commitid	tPD1f2vGi43RT0WC;

1.41.2.1
date	2015.04.30.19.28.46;	author guenther;	state Exp;
branches;
next	;
commitid	pbBButXFqiIh89mX;


desc
@@


1.48
log
@Need <time.h> for time() and others.  Pulled in by coincidence previously

noted by tb@@
@
text
@/*	$OpenBSD: ar_subs.c,v 1.47 2016/08/26 04:31:35 guenther Exp $	*/
/*	$NetBSD: ar_subs.c,v 1.5 1995/03/21 09:07:06 cgd Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "pax.h"
#include "extern.h"

static void wr_archive(ARCHD *, int is_app);
static int get_arc(void);
static int next_head(ARCHD *);
extern sigset_t s_mask;

/*
 * Routines which control the overall operation modes of pax as specified by
 * the user: list, append, read ...
 */

static char hdbuf[BLKMULT];		/* space for archive header on read */
u_long flcnt;				/* number of files processed */

/*
 * list()
 *	list the contents of an archive which match user supplied pattern(s)
 *	(no pattern matches all).
 */

void
list(void)
{
	ARCHD *arcn;
	int res;
	ARCHD archd;
	time_t now;

	arcn = &archd;
	/*
	 * figure out archive type; pass any format specific options to the
	 * archive option processing routine; call the format init routine. We
	 * also save current time for ls_list() so we do not make a system
	 * call for each file we need to print. If verbose (vflag) start up
	 * the name and group caches.
	 */
	if ((get_arc() < 0) || ((*frmt->options)() < 0) ||
	    ((*frmt->st_rd)() < 0))
		return;

	now = time(NULL);

	/*
	 * step through the archive until the format says it is done
	 */
	while (next_head(arcn) == 0) {
		if (arcn->type == PAX_GLL || arcn->type == PAX_GLF) {
			/*
			 * we need to read, to get the real filename
			 */
			off_t cnt;
			if (!rd_wrfile(arcn, arcn->type == PAX_GLF
			    ? -1 : -2, &cnt))
				(void)rd_skip(cnt + arcn->pad);
			continue;
		}

		/*
		 * check for pattern, and user specified options match.
		 * When all patterns are matched we are done.
		 */
		if ((res = pat_match(arcn)) < 0)
			break;

		if ((res == 0) && (sel_chk(arcn) == 0)) {
			/*
			 * pattern resulted in a selected file
			 */
			if (pat_sel(arcn) < 0)
				break;

			/*
			 * modify the name as requested by the user if name
			 * survives modification, do a listing of the file
			 */
			if ((res = mod_name(arcn)) < 0)
				break;
			if (res == 0)
				ls_list(arcn, now, stdout);
		}

		/*
		 * skip to next archive format header using values calculated
		 * by the format header read routine
		 */
		if (rd_skip(arcn->skip + arcn->pad) == 1)
			break;
	}

	/*
	 * all done, let format have a chance to cleanup, and make sure that
	 * the patterns supplied by the user were all matched
	 */
	(void)(*frmt->end_rd)();
	(void)sigprocmask(SIG_BLOCK, &s_mask, NULL);
	ar_close(0);
	pat_chk();
}

static int
cmp_file_times(int mtime_flag, int ctime_flag, ARCHD *arcn, struct stat *sbp)
{
	struct stat sb;

	if (sbp == NULL) {
		if (lstat(arcn->name, &sb) != 0)
			return (0);
		sbp = &sb;
	}

	if (ctime_flag && mtime_flag)
		return (timespeccmp(&arcn->sb.st_mtim, &sbp->st_mtim, <=) &&
		        timespeccmp(&arcn->sb.st_ctim, &sbp->st_ctim, <=));
	else if (ctime_flag)
		return (timespeccmp(&arcn->sb.st_ctim, &sbp->st_ctim, <=));
	else
		return (timespeccmp(&arcn->sb.st_mtim, &sbp->st_mtim, <=));
}

/*
 * extract()
 *	extract the member(s) of an archive as specified by user supplied
 *	pattern(s) (no patterns extracts all members)
 */

void
extract(void)
{
	ARCHD *arcn;
	int res;
	off_t cnt;
	ARCHD archd;
	int fd;
	time_t now;

	sltab_start();

	arcn = &archd;
	/*
	 * figure out archive type; pass any format specific options to the
	 * archive option processing routine; call the format init routine;
	 * start up the directory modification time and access mode database
	 */
	if ((get_arc() < 0) || ((*frmt->options)() < 0) ||
	    ((*frmt->st_rd)() < 0) || (dir_start() < 0))
		return;

	/*
	 * When we are doing interactive rename, we store the mapping of names
	 * so we can fix up hard links files later in the archive.
	 */
	if (iflag && (name_start() < 0))
		return;

	now = time(NULL);

	/*
	 * step through each entry on the archive until the format read routine
	 * says it is done
	 */
	while (next_head(arcn) == 0) {
		if (arcn->type == PAX_GLL || arcn->type == PAX_GLF) {
			/*
			 * we need to read, to get the real filename
			 */
			if (!rd_wrfile(arcn, arcn->type == PAX_GLF
			    ? -1 : -2, &cnt))
				(void)rd_skip(cnt + arcn->pad);
			continue;
		}

		/*
		 * check for pattern, and user specified options match. When
		 * all the patterns are matched we are done
		 */
		if ((res = pat_match(arcn)) < 0)
			break;

		if ((res > 0) || (sel_chk(arcn) != 0)) {
			/*
			 * file is not selected. skip past any file data and
			 * padding and go back for the next archive member
			 */
			(void)rd_skip(arcn->skip + arcn->pad);
			continue;
		}

		/*
		 * with -u or -D only extract when the archive member is newer
		 * than the file with the same name in the file system (no
		 * test of being the same type is required).
		 * NOTE: this test is done BEFORE name modifications as
		 * specified by pax. this operation can be confusing to the
		 * user who might expect the test to be done on an existing
		 * file AFTER the name mod. In honesty the pax spec is probably
		 * flawed in this respect.
		 */
		if ((uflag || Dflag) &&
		    cmp_file_times(uflag, Dflag, arcn, NULL)) {
			(void)rd_skip(arcn->skip + arcn->pad);
			continue;
		}

		/*
		 * this archive member is now been selected. modify the name.
		 */
		if ((pat_sel(arcn) < 0) || ((res = mod_name(arcn)) < 0))
			break;
		if (res > 0) {
			/*
			 * a bad name mod, skip and purge name from link table
			 */
			purg_lnk(arcn);
			(void)rd_skip(arcn->skip + arcn->pad);
			continue;
		}

		/*
		 * Non standard -Y and -Z flag. When the existing file is
		 * same age or newer skip
		 */
		if ((Yflag || Zflag) &&
		    cmp_file_times(Yflag, Zflag, arcn, NULL)) {
			(void)rd_skip(arcn->skip + arcn->pad);
			continue;
		}

		if (vflag) {
			if (vflag > 1)
				ls_list(arcn, now, listf);
			else {
				(void)safe_print(arcn->name, listf);
				vfpart = 1;
			}
		}

		/*
		 * if required, chdir around.
		 */
		if ((arcn->pat != NULL) && (arcn->pat->chdname != NULL))
			if (chdir(arcn->pat->chdname) != 0)
				syswarn(1, errno, "Cannot chdir to %s",
				    arcn->pat->chdname);

		/*
		 * all ok, extract this member based on type
		 */
		if (!PAX_IS_REG(arcn->type)) {
			/*
			 * process archive members that are not regular files.
			 * throw out padding and any data that might follow the
			 * header (as determined by the format).
			 */
			if (PAX_IS_HARDLINK(arcn->type))
				res = lnk_creat(arcn);
			else
				res = node_creat(arcn);

			(void)rd_skip(arcn->skip + arcn->pad);
			if (res < 0)
				purg_lnk(arcn);

			if (vflag && vfpart) {
				(void)putc('\n', listf);
				vfpart = 0;
			}
			goto popd;
		}
		/*
		 * we have a file with data here. If we can not create it, skip
		 * over the data and purge the name from hard link table
		 */
		if ((fd = file_creat(arcn)) < 0) {
			(void)rd_skip(arcn->skip + arcn->pad);
			purg_lnk(arcn);
			goto popd;
		}
		/*
		 * extract the file from the archive and skip over padding and
		 * any unprocessed data
		 */
		res = rd_wrfile(arcn, fd, &cnt);
		file_close(arcn, fd);
		if (vflag && vfpart) {
			(void)putc('\n', listf);
			vfpart = 0;
		}
		if (!res)
			(void)rd_skip(cnt + arcn->pad);

popd:
		/*
		 * if required, chdir around.
		 */
		if ((arcn->pat != NULL) && (arcn->pat->chdname != NULL))
			if (fchdir(cwdfd) != 0)
				syswarn(1, errno,
				    "Can't fchdir to starting directory");
	}

	/*
	 * all done, restore directory modes and times as required; make sure
	 * all patterns supplied by the user were matched; block off signals
	 * to avoid chance for multiple entry into the cleanup code.
	 */
	(void)(*frmt->end_rd)();
	(void)sigprocmask(SIG_BLOCK, &s_mask, NULL);
	ar_close(0);
	sltab_process(0);
	proc_dir(0);
	pat_chk();
}

/*
 * wr_archive()
 *	Write an archive. used in both creating a new archive and appends on
 *	previously written archive.
 */

static void
wr_archive(ARCHD *arcn, int is_app)
{
	int res;
	int hlk;
	int wr_one;
	off_t cnt;
	int (*wrf)(ARCHD *);
	int fd = -1;
	time_t now;

	/*
	 * if this format supports hard link storage, start up the database
	 * that detects them.
	 */
	if (((hlk = frmt->hlk) == 1) && (lnk_start() < 0))
		return;

	/*
	 * if this is not append, and there are no files, we do not write a
	 * trailer
	 */
	wr_one = is_app;

	/*
	 * start up the file traversal code and format specific write
	 */
	if (ftree_start() < 0) {
		if (is_app)
			goto trailer;
		return;
	} else if (((*frmt->st_wr)() < 0))
		return;

	wrf = frmt->wr;

	/*
	 * When we are doing interactive rename, we store the mapping of names
	 * so we can fix up hard links files later in the archive.
	 */
	if (iflag && (name_start() < 0))
		return;

	now = time(NULL);

	/*
	 * while there are files to archive, process them one at at time
	 */
	while (next_file(arcn) == 0) {
		/*
		 * check if this file meets user specified options match.
		 */
		if (sel_chk(arcn) != 0)
			continue;
		fd = -1;
		if (uflag) {
			/*
			 * only archive if this file is newer than a file with
			 * the same name that is already stored on the archive
			 */
			if ((res = chk_ftime(arcn)) < 0)
				break;
			if (res > 0) {
				ftree_skipped_newer(arcn);
				continue;
			}
		}

		/*
		 * this file is considered selected now. see if this is a hard
		 * link to a file already stored
		 */
		ftree_sel(arcn);
		if (hlk && (chk_lnk(arcn) < 0))
			break;

		if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG)) {
			/*
			 * we will have to read this file. by opening it now we
			 * can avoid writing a header to the archive for a file
			 * we were later unable to read (we also purge it from
			 * the link table).
			 */
			if ((fd = open(arcn->org_name, O_RDONLY, 0)) < 0) {
				syswarn(1,errno, "Unable to open %s to read",
					arcn->org_name);
				purg_lnk(arcn);
				continue;
			}
		}

		/*
		 * Now modify the name as requested by the user
		 */
		if ((res = mod_name(arcn)) < 0) {
			/*
			 * name modification says to skip this file, close the
			 * file and purge link table entry
			 */
			rdfile_close(arcn, &fd);
			purg_lnk(arcn);
			break;
		}

		if ((res > 0) || (docrc && (set_crc(arcn, fd) < 0))) {
			/*
			 * unable to obtain the crc we need, close the file,
			 * purge link table entry
			 */
			rdfile_close(arcn, &fd);
			purg_lnk(arcn);
			continue;
		}

		if (vflag) {
			if (vflag > 1)
				ls_list(arcn, now, listf);
			else {
				(void)safe_print(arcn->name, listf);
				vfpart = 1;
			}
		}
		++flcnt;

		/*
		 * looks safe to store the file, have the format specific
		 * routine write routine store the file header on the archive
		 */
		if ((res = (*wrf)(arcn)) < 0) {
			rdfile_close(arcn, &fd);
			break;
		}
		wr_one = 1;
		if (res > 0) {
			/*
			 * format write says no file data needs to be stored
			 * so we are done messing with this file
			 */
			if (vflag && vfpart) {
				(void)putc('\n', listf);
				vfpart = 0;
			}
			rdfile_close(arcn, &fd);
			continue;
		}

		/*
		 * Add file data to the archive, quit on write error. if we
		 * cannot write the entire file contents to the archive we
		 * must pad the archive to replace the missing file data
		 * (otherwise during an extract the file header for the file
		 * which FOLLOWS this one will not be where we expect it to
		 * be).
		 */
		res = wr_rdfile(arcn, fd, &cnt);
		rdfile_close(arcn, &fd);
		if (vflag && vfpart) {
			(void)putc('\n', listf);
			vfpart = 0;
		}
		if (res < 0)
			break;

		/*
		 * pad as required, cnt is number of bytes not written
		 */
		if (((cnt > 0) && (wr_skip(cnt) < 0)) ||
		    ((arcn->pad > 0) && (wr_skip(arcn->pad) < 0)))
			break;
	}

trailer:
	/*
	 * tell format to write trailer; pad to block boundary; reset directory
	 * mode/access times, and check if all patterns supplied by the user
	 * were matched. block off signals to avoid chance for multiple entry
	 * into the cleanup code
	 */
	if (wr_one) {
		(*frmt->end_wr)();
		wr_fin();
	}
	(void)sigprocmask(SIG_BLOCK, &s_mask, NULL);
	ar_close(0);
	if (tflag)
		proc_dir(0);
	ftree_chk();
}

/*
 * append()
 *	Add file to previously written archive. Archive format specified by the
 *	user must agree with archive. The archive is read first to collect
 *	modification times (if -u) and locate the archive trailer. The archive
 *	is positioned in front of the record with the trailer and wr_archive()
 *	is called to add the new members.
 *	PAX IMPLEMENTATION DETAIL NOTE:
 *	-u is implemented by adding the new members to the end of the archive.
 *	Care is taken so that these do not end up as links to the older
 *	version of the same file already stored in the archive. It is expected
 *	when extraction occurs these newer versions will over-write the older
 *	ones stored "earlier" in the archive (this may be a bad assumption as
 *	it depends on the implementation of the program doing the extraction).
 *	It is really difficult to splice in members without either re-writing
 *	the entire archive (from the point were the old version was), or having
 *	assistance of the format specification in terms of a special update
 *	header that invalidates a previous archive record. The posix spec left
 *	the method used to implement -u unspecified. This pax is able to
 *	over write existing files that it creates.
 */

void
append(void)
{
	ARCHD *arcn;
	int res;
	ARCHD archd;
	FSUB *orgfrmt;
	int udev;
	off_t tlen;

	arcn = &archd;
	orgfrmt = frmt;

	/*
	 * Do not allow an append operation if the actual archive is of a
	 * different format than the user specified format.
	 */
	if (get_arc() < 0)
		return;
	if ((orgfrmt != NULL) && (orgfrmt != frmt)) {
		paxwarn(1, "Cannot mix current archive format %s with %s",
		    frmt->name, orgfrmt->name);
		return;
	}

	/*
	 * pass the format any options and start up format
	 */
	if (((*frmt->options)() < 0) || ((*frmt->st_rd)() < 0))
		return;

	/*
	 * if we only are adding members that are newer, we need to save the
	 * mod times for all files we see.
	 */
	if (uflag && (ftime_start() < 0))
		return;

	/*
	 * some archive formats encode hard links by recording the device and
	 * file serial number (inode) but copy the file anyway (multiple times)
	 * to the archive. When we append, we run the risk that newly added
	 * files may have the same device and inode numbers as those recorded
	 * on the archive but during a previous run. If this happens, when the
	 * archive is extracted we get INCORRECT hard links. We avoid this by
	 * remapping the device numbers so that newly added files will never
	 * use the same device number as one found on the archive. remapping
	 * allows new members to safely have links among themselves. remapping
	 * also avoids problems with file inode (serial number) truncations
	 * when the inode number is larger than storage space in the archive
	 * header. See the remap routines for more details.
	 */
	if ((udev = frmt->udev) && (dev_start() < 0))
		return;

	/*
	 * reading the archive may take a long time. If verbose tell the user
	 */
	if (vflag) {
		(void)fprintf(listf,
			"%s: Reading archive to position at the end...", argv0);
		vfpart = 1;
	}

	/*
	 * step through the archive until the format says it is done
	 */
	while (next_head(arcn) == 0) {
		/*
		 * check if this file meets user specified options.
		 */
		if (sel_chk(arcn) != 0) {
			if (rd_skip(arcn->skip + arcn->pad) == 1)
				break;
			continue;
		}

		if (uflag) {
			/*
			 * see if this is the newest version of this file has
			 * already been seen, if so skip.
			 */
			if ((res = chk_ftime(arcn)) < 0)
				break;
			if (res > 0) {
				if (rd_skip(arcn->skip + arcn->pad) == 1)
					break;
				continue;
			}
		}

		/*
		 * Store this device number. Device numbers seen during the
		 * read phase of append will cause newly appended files with a
		 * device number seen in the old part of the archive to be
		 * remapped to an unused device number.
		 */
		if ((udev && (add_dev(arcn) < 0)) ||
		    (rd_skip(arcn->skip + arcn->pad) == 1))
			break;
	}

	/*
	 * done, finish up read and get the number of bytes to back up so we
	 * can add new members. The format might have used the hard link table,
	 * purge it.
	 */
	tlen = (*frmt->end_rd)();
	lnk_end();

	/*
	 * try to position for write, if this fails quit. if any error occurs,
	 * we will refuse to write
	 */
	if (appnd_start(tlen) < 0)
		return;

	/*
	 * tell the user we are done reading.
	 */
	if (vflag && vfpart) {
		(void)fputs("done.\n", listf);
		vfpart = 0;
	}

	/*
	 * go to the writing phase to add the new members
	 */
	wr_archive(arcn, 1);
}

/*
 * archive()
 *	write a new archive
 */

void
archive(void)
{
	ARCHD archd;

	/*
	 * if we only are adding members that are newer, we need to save the
	 * mod times for all files; set up for writing; pass the format any
	 * options write the archive
	 */
	if ((uflag && (ftime_start() < 0)) || (wr_start() < 0))
		return;
	if ((*frmt->options)() < 0)
		return;

	wr_archive(&archd, 0);
}

/*
 * copy()
 *	copy files from one part of the file system to another. this does not
 *	use any archive storage. The EFFECT OF THE COPY IS THE SAME as if an
 *	archive was written and then extracted in the destination directory
 *	(except the files are forced to be under the destination directory).
 */

void
copy(void)
{
	ARCHD *arcn;
	int res;
	int fddest;
	char *dest_pt;
	size_t dlen;
	size_t drem;
	int fdsrc = -1;
	struct stat sb;
	ARCHD archd;
	char dirbuf[PAXPATHLEN+1];

	sltab_start();

	arcn = &archd;
	/*
	 * set up the destination dir path and make sure it is a directory. We
	 * make sure we have a trailing / on the destination
	 */
	dlen = strlcpy(dirbuf, dirptr, sizeof(dirbuf));
	if (dlen >= sizeof(dirbuf) ||
	    (dlen == sizeof(dirbuf) - 1 && dirbuf[dlen - 1] != '/')) {
		paxwarn(1, "directory name is too long %s", dirptr);
		return;
	}
	dest_pt = dirbuf + dlen;
	if (*(dest_pt-1) != '/') {
		*dest_pt++ = '/';
		*dest_pt = '\0';
		++dlen;
	}
	drem = PAXPATHLEN - dlen;

	if (stat(dirptr, &sb) < 0) {
		syswarn(1, errno, "Cannot access destination directory %s",
			dirptr);
		return;
	}
	if (!S_ISDIR(sb.st_mode)) {
		paxwarn(1, "Destination is not a directory %s", dirptr);
		return;
	}

	/*
	 * start up the hard link table; file traversal routines and the
	 * modification time and access mode database
	 */
	if ((lnk_start() < 0) || (ftree_start() < 0) || (dir_start() < 0))
		return;

	/*
	 * When we are doing interactive rename, we store the mapping of names
	 * so we can fix up hard links files later in the archive.
	 */
	if (iflag && (name_start() < 0))
		return;

	/*
	 * set up to cp file trees
	 */
	cp_start();

	/*
	 * while there are files to archive, process them
	 */
	while (next_file(arcn) == 0) {
		fdsrc = -1;

		/*
		 * check if this file meets user specified options
		 */
		if (sel_chk(arcn) != 0)
			continue;

		/*
		 * if there is already a file in the destination directory with
		 * the same name and it is newer, skip the one stored on the
		 * archive.
		 * NOTE: this test is done BEFORE name modifications as
		 * specified by pax. this can be confusing to the user who
		 * might expect the test to be done on an existing file AFTER
		 * the name mod. In honesty the pax spec is probably flawed in
		 * this respect
		 */
		if (uflag || Dflag) {
			/*
			 * create the destination name
			 */
			if (strlcpy(dest_pt, arcn->name + (*arcn->name == '/'),
			    drem + 1) > drem) {
				paxwarn(1, "Destination pathname too long %s",
					arcn->name);
				continue;
			}

			/*
			 * if existing file is same age or newer skip
			 */
			res = lstat(dirbuf, &sb);
			*dest_pt = '\0';

			if (res == 0) {
				ftree_skipped_newer(arcn);
				if (cmp_file_times(uflag, Dflag, arcn, &sb))
					continue;
			}
		}

		/*
		 * this file is considered selected. See if this is a hard link
		 * to a previous file; modify the name as requested by the
		 * user; set the final destination.
		 */
		ftree_sel(arcn);
		if ((chk_lnk(arcn) < 0) || ((res = mod_name(arcn)) < 0))
			break;
		if ((res > 0) || (set_dest(arcn, dirbuf, dlen) < 0)) {
			/*
			 * skip file, purge from link table
			 */
			purg_lnk(arcn);
			continue;
		}

		/*
		 * Non standard -Y and -Z flag. When the existing file is
		 * same age or newer skip
		 */
		if ((Yflag || Zflag) &&
		    cmp_file_times(Yflag, Zflag, arcn, NULL))
			continue;

		if (vflag) {
			(void)safe_print(arcn->name, listf);
			vfpart = 1;
		}
		++flcnt;

		/*
		 * try to create a hard link to the src file if requested
		 * but make sure we are not trying to overwrite ourselves.
		 */
		if (lflag)
			res = cross_lnk(arcn);
		else
			res = chk_same(arcn);
		if (res <= 0) {
			if (vflag && vfpart) {
				(void)putc('\n', listf);
				vfpart = 0;
			}
			continue;
		}

		/*
		 * have to create a new file
		 */
		if (!PAX_IS_REG(arcn->type)) {
			/*
			 * create a link or special file
			 */
			if (PAX_IS_HARDLINK(arcn->type))
				res = lnk_creat(arcn);
			else
				res = node_creat(arcn);
			if (res < 0)
				purg_lnk(arcn);
			if (vflag && vfpart) {
				(void)putc('\n', listf);
				vfpart = 0;
			}
			continue;
		}

		/*
		 * have to copy a regular file to the destination directory.
		 * first open source file and then create the destination file
		 */
		if ((fdsrc = open(arcn->org_name, O_RDONLY, 0)) < 0) {
			syswarn(1, errno, "Unable to open %s to read",
			    arcn->org_name);
			purg_lnk(arcn);
			continue;
		}
		if ((fddest = file_creat(arcn)) < 0) {
			rdfile_close(arcn, &fdsrc);
			purg_lnk(arcn);
			continue;
		}

		/*
		 * copy source file data to the destination file
		 */
		cp_file(arcn, fdsrc, fddest);
		file_close(arcn, fddest);
		rdfile_close(arcn, &fdsrc);

		if (vflag && vfpart) {
			(void)putc('\n', listf);
			vfpart = 0;
		}
	}

	/*
	 * restore directory modes and times as required; make sure all
	 * patterns were selected block off signals to avoid chance for
	 * multiple entry into the cleanup code.
	 */
	(void)sigprocmask(SIG_BLOCK, &s_mask, NULL);
	ar_close(0);
	sltab_process(0);
	proc_dir(0);
	ftree_chk();
}

/*
 * next_head()
 *	try to find a valid header in the archive. Uses format specific
 *	routines to extract the header and id the trailer. Trailers may be
 *	located within a valid header or in an invalid header (the location
 *	is format specific. The inhead field from the option table tells us
 *	where to look for the trailer).
 *	We keep reading (and resyncing) until we get enough contiguous data
 *	to check for a header. If we cannot find one, we shift by a byte
 *	add a new byte from the archive to the end of the buffer and try again.
 *	If we get a read error, we throw out what we have (as we must have
 *	contiguous data) and start over again.
 *	ASSUMED: headers fit within a BLKMULT header.
 * Return:
 *	0 if we got a header, -1 if we are unable to ever find another one
 *	(we reached the end of input, or we reached the limit on retries. see
 *	the specs for rd_wrbuf() for more details)
 */

static int
next_head(ARCHD *arcn)
{
	int ret;
	char *hdend;
	int res;
	int shftsz;
	int hsz;
	int in_resync = 0;		/* set when we are in resync mode */
	int cnt = 0;			/* counter for trailer function */
	int first = 1;			/* on 1st read, EOF isn't premature. */

	/*
	 * set up initial conditions, we want a whole frmt->hsz block as we
	 * have no data yet.
	 */
	res = hsz = frmt->hsz;
	hdend = hdbuf;
	shftsz = hsz - 1;
	for (;;) {
		/*
		 * keep looping until we get a contiguous FULL buffer
		 * (frmt->hsz is the proper size)
		 */
		for (;;) {
			if ((ret = rd_wrbuf(hdend, res)) == res)
				break;

			/*
			 * If we read 0 bytes (EOF) from an archive when we
			 * expect to find a header, we have stepped upon
			 * an archive without the customary block of zeroes
			 * end marker.  It's just stupid to error out on
			 * them, so exit gracefully.
			 */
			if (first && ret == 0)
				return(-1);
			first = 0;

			/*
			 * some kind of archive read problem, try to resync the
			 * storage device, better give the user the bad news.
			 */
			if ((ret == 0) || (rd_sync() < 0)) {
				paxwarn(1,"Premature end of file on archive read");
				return(-1);
			}
			if (!in_resync) {
				if (act == APPND) {
					paxwarn(1,
					  "Archive I/O error, cannot continue");
					return(-1);
				}
				paxwarn(1,"Archive I/O error. Trying to recover.");
				++in_resync;
			}

			/*
			 * oh well, throw it all out and start over
			 */
			res = hsz;
			hdend = hdbuf;
		}

		/*
		 * ok we have a contiguous buffer of the right size. Call the
		 * format read routine. If this was not a valid header and this
		 * format stores trailers outside of the header, call the
		 * format specific trailer routine to check for a trailer. We
		 * have to watch out that we do not mis-identify file data or
		 * block padding as a header or trailer. Format specific
		 * trailer functions must NOT check for the trailer while we
		 * are running in resync mode. Some trailer functions may tell
		 * us that this block cannot contain a valid header either, so
		 * we then throw out the entire block and start over.
		 */
		if ((*frmt->rd)(arcn, hdbuf) == 0)
			break;

		if (!frmt->inhead) {
			/*
			 * this format has trailers outside of valid headers
			 */
			if ((ret = (*frmt->trail)(arcn,hdbuf,in_resync,&cnt)) == 0){
				/*
				 * valid trailer found, drain input as required
				 */
				ar_drain();
				return(-1);
			}

			if (ret == 1) {
				/*
				 * we are in resync and we were told to throw
				 * the whole block out because none of the
				 * bytes in this block can be used to form a
				 * valid header
				 */
				res = hsz;
				hdend = hdbuf;
				continue;
			}
		}

		/*
		 * Brute force section.
		 * not a valid header. We may be able to find a header yet. So
		 * we shift over by one byte, and set up to read one byte at a
		 * time from the archive and place it at the end of the buffer.
		 * We will keep moving byte at a time until we find a header or
		 * get a read error and have to start over.
		 */
		if (!in_resync) {
			if (act == APPND) {
				paxwarn(1,"Unable to append, archive header flaw");
				return(-1);
			}
			paxwarn(1,"Invalid header, starting valid header search.");
			++in_resync;
		}
		memmove(hdbuf, hdbuf+1, shftsz);
		res = 1;
		hdend = hdbuf + shftsz;
	}

	/*
	 * ok got a valid header, check for trailer if format encodes it in the
	 * the header. NOTE: the parameters are different than trailer routines
	 * which encode trailers outside of the header!
	 */
	if (frmt->inhead && ((*frmt->trail)(arcn,NULL,0,NULL) == 0)) {
		/*
		 * valid trailer found, drain input as required
		 */
		ar_drain();
		return(-1);
	}

	++flcnt;
	return(0);
}

/*
 * get_arc()
 *	Figure out what format an archive is. Handles archive with flaws by
 *	brute force searches for a legal header in any supported format. The
 *	format id routines have to be careful to NOT mis-identify a format.
 *	ASSUMED: headers fit within a BLKMULT header.
 * Return:
 *	0 if archive found -1 otherwise
 */

static int
get_arc(void)
{
	int i;
	int hdsz = 0;
	int res;
	int minhd = BLKMULT;
	char *hdend;
	int notice = 0;

	/*
	 * find the smallest header size in all archive formats and then set up
	 * to read the archive.
	 */
	for (i = 0; ford[i] >= 0; ++i) {
		if (fsub[ford[i]].name != NULL && fsub[ford[i]].hsz < minhd)
			minhd = fsub[ford[i]].hsz;
	}
	if (rd_start() < 0)
		return(-1);
	res = BLKMULT;
	hdsz = 0;
	hdend = hdbuf;
	for (;;) {
		for (;;) {
			/*
			 * fill the buffer with at least the smallest header
			 */
			i = rd_wrbuf(hdend, res);
			if (i > 0)
				hdsz += i;
			if (hdsz >= minhd)
				break;

			/*
			 * if we cannot recover from a read error quit
			 */
			if ((i == 0) || (rd_sync() < 0))
				goto out;

			/*
			 * when we get an error none of the data we already
			 * have can be used to create a legal header (we just
			 * got an error in the middle), so we throw it all out
			 * and refill the buffer with fresh data.
			 */
			res = BLKMULT;
			hdsz = 0;
			hdend = hdbuf;
			if (!notice) {
				if (act == APPND)
					return(-1);
				paxwarn(1,"Cannot identify format. Searching...");
				++notice;
			}
		}

		/*
		 * we have at least the size of the smallest header in any
		 * archive format. Look to see if we have a match. The array
		 * ford[] is used to specify the header id order to reduce the
		 * chance of incorrectly id'ing a valid header (some formats
		 * may be subsets of each other and the order would then be
		 * important).
		 */
		for (i = 0; ford[i] >= 0; ++i) {
			if (fsub[ford[i]].id == NULL ||
			    (*fsub[ford[i]].id)(hdbuf, hdsz) < 0)
				continue;
			frmt = &(fsub[ford[i]]);
			/*
			 * yuck, to avoid slow special case code in the extract
			 * routines, just push this header back as if it was
			 * not seen. We have left extra space at start of the
			 * buffer for this purpose. This is a bit ugly, but
			 * adding all the special case code is far worse.
			 */
			pback(hdbuf, hdsz);
			return(0);
		}

		/*
		 * We have a flawed archive, no match. we start searching, but
		 * we never allow additions to flawed archives
		 */
		if (!notice) {
			if (act == APPND)
				return(-1);
			paxwarn(1, "Cannot identify format. Searching...");
			++notice;
		}

		/*
		 * brute force search for a header that we can id.
		 * we shift through byte at a time. this is slow, but we cannot
		 * determine the nature of the flaw in the archive in a
		 * portable manner
		 */
		if (--hdsz > 0) {
			memmove(hdbuf, hdbuf+1, hdsz);
			res = BLKMULT - hdsz;
			hdend = hdbuf + hdsz;
		} else {
			res = BLKMULT;
			hdend = hdbuf;
			hdsz = 0;
		}
	}

    out:
	/*
	 * we cannot find a header, bow, apologize and quit
	 */
	paxwarn(1, "Sorry, unable to determine archive format.");
	return(-1);
}
@


1.47
log
@reduce and sort #includes
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.46 2016/08/25 01:44:55 guenther Exp $	*/
d44 1
@


1.46
log
@Replace name_{uid,gid}() with the libc routines user_from_uid() and
group_from_gid().  Eliminate some superfluous strncpy() calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.45 2015/03/19 05:14:24 guenther Exp $	*/
a37 1
#include <sys/time.h>
d39 2
d42 1
a43 3
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
d45 1
a45 1
#include <stdlib.h>
@


1.45
log
@Use struct timespec internally.  This gives nanosecond precision to pax -rw
and a basis for support of mtime and atime values in pax-format extended
header records.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.44 2015/03/17 03:23:17 guenther Exp $	*/
a86 3
		return;

	if (vflag && ((uidtb_start() < 0) || (gidtb_start() < 0)))
@


1.44
log
@Add PAX_IS_{REG,HARDLINK,LINK} macros to simply many file type tests

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.43 2015/03/12 04:15:03 guenther Exp $	*/
d151 20
a183 1
	struct stat sb;
d249 4
a252 16
		if ((uflag || Dflag) && ((lstat(arcn->name, &sb) == 0))) {
			if (uflag && Dflag) {
				if ((arcn->sb.st_mtime <= sb.st_mtime) &&
				    (arcn->sb.st_ctime <= sb.st_ctime)) {
					(void)rd_skip(arcn->skip + arcn->pad);
					continue;
				}
			} else if (Dflag) {
				if (arcn->sb.st_ctime <= sb.st_ctime) {
					(void)rd_skip(arcn->skip + arcn->pad);
					continue;
				}
			} else if (arcn->sb.st_mtime <= sb.st_mtime) {
				(void)rd_skip(arcn->skip + arcn->pad);
				continue;
			}
d273 4
a276 16
		if ((Yflag || Zflag) && ((lstat(arcn->name, &sb) == 0))) {
			if (Yflag && Zflag) {
				if ((arcn->sb.st_mtime <= sb.st_mtime) &&
				    (arcn->sb.st_ctime <= sb.st_ctime)) {
					(void)rd_skip(arcn->skip + arcn->pad);
					continue;
				}
			} else if (Yflag) {
				if (arcn->sb.st_ctime <= sb.st_ctime) {
					(void)rd_skip(arcn->skip + arcn->pad);
					continue;
				}
			} else if (arcn->sb.st_mtime <= sb.st_mtime) {
				(void)rd_skip(arcn->skip + arcn->pad);
				continue;
			}
d849 1
a849 8
				if (uflag && Dflag) {
					if ((arcn->sb.st_mtime<=sb.st_mtime) &&
					    (arcn->sb.st_ctime<=sb.st_ctime))
						continue;
				} else if (Dflag) {
					if (arcn->sb.st_ctime <= sb.st_ctime)
						continue;
				} else if (arcn->sb.st_mtime <= sb.st_mtime)
d874 3
a876 11
		if ((Yflag || Zflag) && ((lstat(arcn->name, &sb) == 0))) {
			if (Yflag && Zflag) {
				if ((arcn->sb.st_mtime <= sb.st_mtime) &&
				    (arcn->sb.st_ctime <= sb.st_ctime))
					continue;
			} else if (Yflag) {
				if (arcn->sb.st_ctime <= sb.st_ctime)
					continue;
			} else if (arcn->sb.st_mtime <= sb.st_mtime)
				continue;
		}
@


1.43
log
@If an archive isn't a recognized type, then check whether it looks
like compress, gzip, bzip2, or xz output.  If so then error out with
a useful message directing the user to the correct option and error
out instead of scanning forward for an embedded tar/cpio header.

wording help from sobrado@@
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.42 2015/03/09 04:23:29 guenther Exp $	*/
d304 1
a304 1
		if ((arcn->type != PAX_REG) && (arcn->type != PAX_CTG)) {
d310 1
a310 1
			if ((arcn->type == PAX_HLK) || (arcn->type == PAX_HRG))
d452 1
a452 2
		if ((arcn->type == PAX_REG) || (arcn->type == PAX_HRG) ||
		    (arcn->type == PAX_CTG)) {
d923 1
a923 1
		if ((arcn->type != PAX_REG) && (arcn->type != PAX_CTG)) {
d927 1
a927 1
			if ((arcn->type == PAX_HLK) || (arcn->type == PAX_HRG))
@


1.42
log
@Unrevert post-unlock:
* Prevent an archive from esacaping the current directory by itself:
  when extracting a symlink whose value is absolute or contains ".."
  components, just create a zero-length normal file (with additional
  tracking of the mode and hardlinks to the symlink) until everything
  else is extracted, then go back and replace it with the requested
  link (if it's still that zero-length placeholder).

* For tar without -P, if a path in the archive has any ".." components
  then strip everything up to and including the last of them (if
  it ends in ".." then it becomes ".")
  This mostly follows GNU tar's behavior, except for 'tar tf' and
  'tar xvf' we report the modified path that would be/was actually
  created instead of the raw path from the archive

  Above two fixes prompted by a report from Daniel Cegielka
  (daniel.cegielka (at) gmail.com)

* For directories whose times or mode will be fixed up in the
  clean-up pass, record their dev+ino and then use
  open(O_DIRECTORY)+fstat() to verify that we're updating the correct
  directory before using futimens() and fchmod().

* Correct buffer overflow in handling of pax extension headers,
  caught by the memcpy() overlap check.


previously ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.40 2015/02/12 23:44:57 guenther Exp $	*/
d1219 1
a1219 1
			if (fsub[ford[i]].name == NULL ||
@


1.41
log
@Recent changes haven't been completely stable, so revert for the 5.7 release

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.39 2014/05/23 19:47:49 guenther Exp $	*/
d168 2
d365 1
d764 2
d977 1
@


1.41.2.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.41 2015/02/21 22:48:23 guenther Exp $	*/
a167 2
	sltab_start();

a362 1
	sltab_process(0);
a760 2
	sltab_start();

a971 1
	sltab_process(0);
@


1.40
log
@Prevent an archive from esacaping the current directory by itself:
when extracting a symlink whose value is absolute or contains ".."
components, just create a zero-length normal file (with additional
tracking of the mode and hardlinks to the symlink) until everything
else is extracted, then go back and replace it with the requested
link (if its still that zero-length placeholder).

This and previous symlink and ".." path fixes prompted by a report
from Daniel Cegielka (daniel.cegielka (at) gmail.com)

ok millert@@
@
text
@a167 2
	sltab_start();

a362 1
	sltab_process(0);
a760 2
	sltab_start();

a971 1
	sltab_process(0);
@


1.39
log
@Make the signal handler safe: block signals when updating data-structures
that are walked by routines called from the signal handler and use
dprintf() instead fprintf() in ar_close().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.38 2014/02/05 20:35:42 halex Exp $	*/
d168 2
d365 1
d764 2
d977 1
@


1.39.4.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.39 2014/05/23 19:47:49 guenther Exp $	*/
a167 2
	sltab_start();

a362 1
	sltab_process(0);
a760 2
	sltab_start();

a971 1
	sltab_process(0);
@


1.38
log
@make pax cope with a stripped down format list, e.g. when compiled
with -DNOCPIO
- ignore empty entries (millert@@, halex@@)
- replace bsort with linear scan (guenther@@)

ok millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.37 2014/01/30 13:30:11 espie Exp $	*/
d147 1
a147 1
	ar_close();
d362 2
a363 2
	ar_close();
	proc_dir();
d557 1
a557 1
	ar_close();
d559 1
a559 1
		proc_dir();
d971 2
a972 2
	ar_close();
	proc_dir();
@


1.37
log
@abstraction for the sake of abstraction is distracting.

zap extra func pointer going to the same routines for all formats.
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.36 2014/01/08 06:41:49 guenther Exp $	*/
d1162 1
a1162 1
		if (fsub[ford[i]].hsz < minhd)
d1213 2
a1214 1
			if ((*fsub[ford[i]].id)(hdbuf, hdsz) < 0)
@


1.36
log
@Zap trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.35 2014/01/08 04:43:48 guenther Exp $	*/
d103 1
a103 1
			if (!(*frmt->rd_data)(arcn, arcn->type == PAX_GLF
d196 1
a196 1
			if (!(*frmt->rd_data)(arcn, arcn->type == PAX_GLF
d336 1
a336 1
		res = (*frmt->rd_data)(arcn, fd, &cnt);
d528 1
a528 1
		res = (*frmt->wr_data)(arcn, fd, &cnt);
@


1.35
log
@Use size_t where appropriate

ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.34 2012/12/04 02:24:45 deraadt Exp $	*/
d392 1
a392 1
	 * if this is not append, and there are no files, we do not write a 
@


1.34
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.33 2009/10/27 23:59:22 deraadt Exp $	*/
d754 2
a755 2
	int dlen;
	int drem;
@


1.33
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.32 2008/05/06 06:54:28 henning Exp $	*/
a39 1
#include <sys/param.h>
@


1.32
log
@when pax is running in -u mode, and no files are beeing updated because
not one changed, we should not exit with an error but zero to indicate
success (matches solaris behaviour).
need to track wether files were skipped because of the -u checks for that
and take that into account later when taking the exit code decision.
ok theo, comments from otto and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.31 2006/11/17 08:38:04 otto Exp $	*/
a35 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)ar_subs.c	8.2 (Berkeley) 4/18/94";
#else
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.31 2006/11/17 08:38:04 otto Exp $";
#endif
#endif /* not lint */
@


1.31
log
@Fix extracting and setting permissions for tar archives when
(multiple) -C options are present and/or (multiple) file selections
args are used. Based on a diff in NetBSD PR 22995. Tested by ckuethe@@
and jaredy@@; ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.30 2006/07/21 22:56:58 ray Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.30 2006/07/21 22:56:58 ray Exp $";
d444 2
a445 1
			if (res > 0)
d447 1
d858 1
@


1.30
log
@Prevent segfault when "cpio -o" is called with no input.

Found and fix provided by Alf Schlichting <a dot schlichting at
lemarit dot com>.

OK millert@@ and markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.29 2006/01/25 17:42:08 markus Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.29 2006/01/25 17:42:08 markus Exp $";
d330 1
a330 1
			continue;
d339 1
a339 1
			continue;
d354 1
@


1.29
log
@append without a file list should not corrupt a tar file;
report Rainer Giedat; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.28 2004/04/16 22:50:23 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.28 2004/04/16 22:50:23 deraadt Exp $";
d411 4
a414 3
		if (((*frmt->st_wr)() < 0))
			return;
	}
@


1.28
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.27 2004/03/30 16:14:22 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.27 2004/03/30 16:14:22 millert Exp $";
d400 6
d408 6
a413 2
	if ((ftree_start() < 0) || ((*frmt->st_wr)() < 0))
		return;
a422 6
	/*
	 * if this is not append, and there are no files, we do not write a 
	 * trailer
	 */
	wr_one = is_app;

d550 1
@


1.27
log
@Add support for expanding GNU long links from NetBSD.  I've had this
in my tree for ages but didn't have a proper test case.  Thanks to
otto@@ for providing one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.26 2004/03/15 22:18:15 djm Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.26 2004/03/15 22:18:15 djm Exp $";
d1013 1
a1013 1
	for(;;) {
d1169 1
a1169 1
	for(;;) {
@


1.26
log
@more "if (foo);" ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.25 2003/06/26 00:10:17 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.25 2003/06/26 00:10:17 deraadt Exp $";
d112 2
a113 1
			if (!(*frmt->rd_data)(arcn, -1, &cnt))
d205 2
a206 1
			if (!(*frmt->rd_data)(arcn, -1, &cnt))
@


1.25
log
@protos.  this requires changing the api for the *trail() functions a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.24 2003/06/02 23:32:08 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.24 2003/06/02 23:32:08 millert Exp $";
d112 1
a112 1
			if (!(*frmt->rd_data)(arcn, -1, &cnt));
d204 1
a204 1
			if (!(*frmt->rd_data)(arcn, -1, &cnt));
@


1.24
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.23 2003/02/03 09:06:43 jmc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.23 2003/02/03 09:06:43 jmc Exp $";
d386 1
a386 1
	int (*wrf)();
d1075 1
a1075 1
			if ((ret = (*frmt->trail)(hdbuf,in_resync,&cnt)) == 0){
d1122 1
a1122 1
	if (frmt->inhead && ((*frmt->trail)(arcn) == 0)) {
@


1.23
log
@typos;
from netbsd(svs+pr@@grep.ru)
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.22 2002/10/18 15:38:11 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.22 2002/10/18 15:38:11 millert Exp $";
@


1.22
log
@Pull in some changes from NetBSD
o When extracting GNU tar archives, honor @@LongLink long links/files
o Add an option to prevent pax from prompting for the next volume
  upon premature end of archive.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.21 2002/10/16 19:20:02 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.21 2002/10/16 19:20:02 millert Exp $";
d231 1
a231 1
		 * than the file with the same name in the file system (nos
d416 2
a417 1
	 * if this not append, and there are no files, we do no write a trailer
@


1.21
log
@sprinkle const; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.20 2002/10/16 18:40:30 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.20 2002/10/16 18:40:30 millert Exp $";
d111 10
d204 8
@


1.20
log
@Fix comment typos; most from NetBSD and FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.19 2002/10/16 17:43:10 millert Exp $	*/
d43 1
a43 1
static char sccsid[] = "@@(#)ar_subs.c	8.2 (Berkeley) 4/18/94";
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.19 2002/10/16 17:43:10 millert Exp $";
@


1.19
log
@kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.18 2002/02/19 19:39:35 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.18 2002/02/19 19:39:35 millert Exp $";
d254 1
a254 1
		 * Non standard -Y and -Z flag. When the exisiting file is
d530 1
a530 1
	 * tell format to write trailer; pad to block boundry; reset directory
d583 1
a583 1
	 * different format than the user specified foramt.
d679 1
a679 1
	 * try to postion for write, if this fails quit. if any error occurs,
d861 1
a861 1
		 * Non standard -Y and -Z flag. When the exisiting file is
@


1.18
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.17 2002/02/16 21:27:07 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.17 2002/02/16 21:27:07 millert Exp $";
d63 1
a63 1
static void wr_archive(register ARCHD *, int is_app);
d65 1
a65 1
static int next_head(register ARCHD *);
d85 2
a86 2
	register ARCHD *arcn;
	register int res;
d162 2
a163 2
	register ARCHD *arcn;
	register int res;
d366 1
a366 1
wr_archive(register ARCHD *arcn, int is_app)
d368 3
a370 3
	register int res;
	register int hlk;
	register int wr_one;
d571 2
a572 2
	register ARCHD *arcn;
	register int res;
d733 6
a738 6
	register ARCHD *arcn;
	register int res;
	register int fddest;
	register char *dest_pt;
	register int dlen;
	register int drem;
d978 1
a978 1
next_head(register ARCHD *arcn)
d980 6
a985 6
	register int ret;
	register char *hdend;
	register int res;
	register int shftsz;
	register int hsz;
	register int in_resync = 0;	/* set when we are in resync mode */
d1132 4
a1135 4
	register int i;
	register int hdsz = 0;
	register int res;
	register int minhd = BLKMULT;
@


1.17
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.16 2001/07/17 18:19:48 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.16 2001/07/17 18:19:48 millert Exp $";
a81 1
#ifdef __STDC__
a83 4
#else
void
list()
#endif
a158 1
#ifdef __STDC__
a160 4
#else
void
extract()
#endif
a364 1
#ifdef __STDC__
a366 6
#else
static void
wr_archive(arcn, is_app)
	register ARCHD *arcn;
	int is_app;
#endif
a567 1
#ifdef __STDC__
a569 4
#else
void
append()
#endif
a703 1
#ifdef __STDC__
a705 4
#else
void
archive()
#endif
a729 1
#ifdef __STDC__
a731 4
#else
void
copy()
#endif
a976 1
#ifdef __STDC__
a978 5
#else
static int
next_head(arcn)
	register ARCHD *arcn;
#endif
a1128 1
#ifdef __STDC__
a1130 4
#else
static int
get_arc()
#endif
@


1.16
log
@Add a safe_print() function that uses vis(3) if output is a tty.
Uses the vis C-style mode which is consistent with what GNU tar
does (though GNU tar does vis(3) regardless of whether output is a tty).

It may make sense to add a flag to force vis(3)ification like ls does
but I have not done that here as I'm reticent to add more flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.15 2001/05/16 03:04:55 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.15 2001/05/16 03:04:55 mickey Exp $";
d63 3
a65 3
static void wr_archive __P((register ARCHD *, int is_app));
static int get_arc __P((void));
static int next_head __P((register ARCHD *));
@


1.15
log
@use proper str*cpy functions instead of home grown one, spaces; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.14 1998/09/20 02:22:21 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.14 1998/09/20 02:22:21 millert Exp $";
d289 1
a289 1
				(void)fputs(arcn->name, listf);
d493 1
a493 1
				(void)fputs(arcn->name, listf);
d909 1
a909 1
			(void)fputs(arcn->name, listf);
@


1.14
log
@When invoked as tar, print verbose output to stdout, not stderr.  If in list mode or in create mode where create output is to stdout print to stderr
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.13 1997/09/16 21:20:35 niklas Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.13 1997/09/16 21:20:35 niklas Exp $";
d482 1
a482 1
			 * purge link table entry 
d509 1
a509 1
			/* 
d572 1
a572 1
 *	Care is taken so that these do not end up as links to the older 
d714 1
a714 1
       
d781 6
a786 1
	dlen = l_strncpy(dirbuf, dirptr, sizeof(dirbuf) - 1);
d790 1
a792 1
	*dest_pt = '\0';
d807 1
a807 1
	 * modification time and access mode database 
d850 2
a851 5
			if (*(arcn->name) == '/')
				res = 1;
			else
				res = 0;
			if ((arcn->nlen - res) > drem) {
a855 2
			(void)strncpy(dest_pt, arcn->name + res, drem);
			dirbuf[PAXPATHLEN] = '\0';
d863 1
a863 1
		    	if (res == 0) {
d866 1
a866 1
			    		    (arcn->sb.st_ctime<=sb.st_ctime))
d1023 1
a1023 1
	register int in_resync = 0; 	/* set when we are in resync mode */
d1241 1
a1241 1
			/* 
@


1.13
log
@Do not error out on archives without the
customary block of zeroes at the end.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.12 1997/09/01 18:29:44 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.12 1997/09/01 18:29:44 deraadt Exp $";
d287 1
a287 1
				ls_list(arcn, now, stderr);
d289 1
a289 1
				(void)fputs(arcn->name, stderr);
d321 1
a321 1
				(void)putc('\n', stderr);
d342 1
a342 1
			(void)putc('\n', stderr);
d491 1
a491 1
				ls_list(arcn, now, stderr);
d493 1
a493 1
				(void)fputs(arcn->name, stderr);
d514 1
a514 1
				(void)putc('\n', stderr);
d532 1
a532 1
			(void)putc('\n', stderr);
d649 1
a649 1
		(void)fprintf(stderr,
d711 1
a711 1
		(void)fputs("done.\n", stderr);
d909 1
a909 1
			(void)fputs(arcn->name, stderr);
d924 1
a924 1
				(void)putc('\n', stderr);
d944 1
a944 1
				(void)putc('\n', stderr);
d974 1
a974 1
			(void)putc('\n', stderr);
@


1.12
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.11 1997/07/25 18:58:24 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.11 1997/07/25 18:58:24 mickey Exp $";
d1025 1
d1042 11
@


1.11
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.10 1997/07/24 23:19:17 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.10 1997/07/24 23:19:17 millert Exp $";
d918 1
a918 1
		if (lflag) 
d1025 1
a1025 1
	
d1169 1
a1169 1
	
@


1.10
log
@Stash fd of cwd instead of using getcwd() to stash path.
This works in cases where the parent dir is not readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.9 1997/07/23 19:15:54 kstailey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.9 1997/07/23 19:15:54 kstailey Exp $";
d82 1
a82 1
#if __STDC__
d164 1
a164 1
#if __STDC__
d375 1
a375 1
#if __STDC__
d585 1
a585 1
#if __STDC__
d726 1
a726 1
#if __STDC__
d757 1
a757 1
#if __STDC__
d1009 1
a1009 1
#if __STDC__
d1155 1
a1155 1
#if __STDC__
@


1.9
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.8 1997/06/18 18:48:24 kstailey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.8 1997/06/18 18:48:24 kstailey Exp $";
d352 3
a354 2
			if (chdir(cwdpt) != 0)
				syswarn(1, errno, "Can't chdir to %s", cwdpt);
@


1.8
log
@(foo *)NULL -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.7 1997/06/04 00:15:14 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.7 1997/06/04 00:15:14 millert Exp $";
d73 1
a73 1
static char hdbuf[BLKMULT];             /* space for archive header on read */
d1052 1
a1052 1
				          "Archive I/O error, cannot continue");
@


1.7
log
@Fix usage of l_strncpy() (noticed by Theo) and make l_strncpy()
pad with NULL's like strncpy(3).  This eliminates the need for
zf_strncpy(); ocurrences of zf_strncpy() have been changed to l_strncpy().
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.6 1997/02/27 23:32:57 michaels Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.6 1997/02/27 23:32:57 michaels Exp $";
d110 1
a110 1
	now = time((time_t *)NULL);
d153 1
a153 1
	(void)sigprocmask(SIG_BLOCK, &s_mask, (sigset_t *)NULL);
d197 1
a197 1
	now = time((time_t *)NULL);
d362 1
a362 1
	(void)sigprocmask(SIG_BLOCK, &s_mask, (sigset_t *)NULL);
d418 1
a418 1
	now = time((time_t *)NULL);
d555 1
a555 1
	(void)sigprocmask(SIG_BLOCK, &s_mask, (sigset_t *)NULL);
d983 1
a983 1
	(void)sigprocmask(SIG_BLOCK, &s_mask, (sigset_t *)NULL);
@


1.6
log
@fix pr system/124, reported by Janjaap van Velthooven (janjaap@@stack.nl).
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.4 1996/10/27 06:45:09 downsj Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.4 1996/10/27 06:45:09 downsj Exp $";
d780 1
a780 1
	dlen = l_strncpy(dirbuf, dirptr, PAXPATHLEN);
@


1.5
log
@Support multiple -v options like GNU tar (> 1 -v means do ls-like output).
@
text
@d297 2
a298 2
		if ((arcn->pat != NULL) && (arcn->pat->chdnam != NULL)) {
			if (chdir(arcn->pat->chdnam) < 0) {
d300 1
a300 4
				    arcn->pat->chdnam);
				return;
			}
		}
d351 3
a353 6
		if ((arcn->pat != NULL) && (arcn->pat->chdnam != NULL)) {
			if (chdir(cwdpt) < 0) {
				syswarn(0, errno, "Can't chdir to %s", cwdpt);
				return;
			}
		}
@


1.4
log
@Initial cut -C support in paxtar.  Exceeds GNU tar by quite a bit.
General pax still seems to work ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.3 1996/06/23 14:20:29 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.3 1996/06/23 14:20:29 deraadt Exp $";
d137 1
a137 1
				ls_list(arcn, now);
d178 1
d197 2
d286 6
a291 2
			(void)fputs(arcn->name, stderr);
			vfpart = 1;
d396 1
d424 2
d495 6
a500 2
			(void)fputs(arcn->name, stderr);
			vfpart = 1;
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.5 1995/03/21 09:07:06 cgd Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_subs.c,v 1.5 1995/03/21 09:07:06 cgd Exp $";
d288 11
d343 10
@


1.2
log
@Correct compile warnings
Rename warn() to paxwarn() so <err.h> can be included

Remove #include <ctype.h> when not needed; from FreeBSD
@
text
@d1 1
d45 1
a45 1
static char rcsid[] = "$NetBSD: ar_subs.c,v 1.5 1995/03/21 09:07:06 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@a54 1
#include <ctype.h>
d579 1
a579 1
		warn(1, "Cannot mix current archive format %s with %s",
d765 1
a765 1
		warn(1, "Destination is not a directory %s", dirptr);
d819 1
a819 1
				warn(1, "Destination pathname too long %s",
d1016 1
a1016 1
				warn(1,"Premature end of file on archive read");
d1021 1
a1021 1
					warn(1,
d1025 1
a1025 1
				warn(1,"Archive I/O error. Trying to recover.");
d1086 1
a1086 1
				warn(1,"Unable to append, archive header flaw");
d1089 1
a1089 1
			warn(1,"Invalid header, starting valid header search.");
d1181 1
a1181 1
				warn(1,"Cannot identify format. Searching...");
d1216 1
a1216 1
			warn(1, "Cannot identify format. Searching...");
d1241 1
a1241 1
	warn(1, "Sorry, unable to determine archive format.");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
