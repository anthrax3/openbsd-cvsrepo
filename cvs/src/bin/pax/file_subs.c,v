head	1.53;
access;
symbols
	OPENBSD_6_1:1.53.0.4
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.48.0.4
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.47.0.4
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.32.0.14
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.12
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.10
	OPENBSD_5_0:1.32.0.8
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.6
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.4
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.30.0.18
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.14
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.12
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.10
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.8
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.6
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.4
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.13.0.16
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.13.0.14
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.12
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.13.0.10
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.8
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.6
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.4
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.53
date	2017.01.21.08.17.06;	author krw;	state Exp;
branches;
next	1.52;
commitid	mFkIRgt9JJvfM9Bd;

1.52
date	2016.08.26.04.11.16;	author guenther;	state Exp;
branches;
next	1.51;
commitid	JeDGCh3Baf9wzXzL;

1.51
date	2016.08.23.06.00.28;	author guenther;	state Exp;
branches;
next	1.50;
commitid	lequwSVdrsu8itF8;

1.50
date	2016.08.23.03.31.44;	author guenther;	state Exp;
branches;
next	1.49;
commitid	fqfKyzlY7FTQGWYR;

1.49
date	2016.08.14.18.30.33;	author guenther;	state Exp;
branches;
next	1.48;
commitid	qmsIw7NlXw1nDUYx;

1.48
date	2016.02.16.04.30.07;	author guenther;	state Exp;
branches;
next	1.47;
commitid	Qjj9gZrFkHHxfytV;

1.47
date	2015.03.19.05.14.24;	author guenther;	state Exp;
branches;
next	1.46;
commitid	s0WKwITEr5aJPBA2;

1.46
date	2015.03.15.06.05.59;	author guenther;	state Exp;
branches;
next	1.45;
commitid	4RYxR2zmtZBHwFuh;

1.45
date	2015.03.09.04.23.29;	author guenther;	state Exp;
branches;
next	1.44;
commitid	JMkpovMhu0rmLvCn;

1.44
date	2015.02.21.22.48.23;	author guenther;	state Exp;
branches
	1.44.2.1;
next	1.43;
commitid	AdteqX8nU06lUYnQ;

1.43
date	2015.02.15.22.18.29;	author millert;	state Exp;
branches;
next	1.42;
commitid	uRyOrDxTxh06jP2Y;

1.42
date	2015.02.12.23.44.57;	author guenther;	state Exp;
branches;
next	1.41;
commitid	lkvsxr9r9MdXqaQN;

1.41
date	2015.02.11.23.14.46;	author guenther;	state Exp;
branches;
next	1.40;
commitid	lWdBzWkSKKObQ4Qj;

1.40
date	2015.02.05.22.32.20;	author sthen;	state Exp;
branches;
next	1.39;
commitid	QBujBhAFFXGSsgsF;

1.39
date	2015.02.05.07.49.25;	author guenther;	state Exp;
branches;
next	1.38;
commitid	4roKhm1wyg3vjc8b;

1.38
date	2015.01.16.06.39.32;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	Uu5nFG3wCl0LACBb;

1.37
date	2014.11.23.05.32.20;	author guenther;	state Exp;
branches;
next	1.36;
commitid	eLkSd1w0WMKVZRNV;

1.36
date	2014.07.14.05.58.19;	author guenther;	state Exp;
branches
	1.36.4.1;
next	1.35;
commitid	7trvwLDtRk2spMXa;

1.35
date	2014.01.14.02.55.09;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2013.10.08.03.10.36;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2013.04.16.18.06.35;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2009.12.22.12.08.30;	author jasper;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.09.19.59.06;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.25.19.39.52;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2004.11.29.16.23.22;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.16.22.50.23;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.30.16.14.22;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.20.06.22.27;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.06.21.08.05;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.23.32.08;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.03.09.06.43;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.18.15.38.11;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.16.19.20.02;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.16.18.40.30;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.16.17.43.10;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.25.16.59.03;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.16.03.04.56;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	97.09.01.18.29.48;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.07.25.18.58.29;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.06.06.16.03.13;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.06.06.05.56.04;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.06.04.04.56.26;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.04.09.01.59.00;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.03.05.05.53.22;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	97.03.04.05.44.49;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	97.03.02.09.46.45;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	97.01.26.10.33.22;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.20.33;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.06.41.50;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.17;	author deraadt;	state Exp;
branches;
next	;

1.36.4.1
date	2015.04.30.19.30.57;	author guenther;	state Exp;
branches;
next	;
commitid	tPD1f2vGi43RT0WC;

1.44.2.1
date	2015.04.30.19.28.46;	author guenther;	state Exp;
branches;
next	;
commitid	pbBButXFqiIh89mX;


desc
@@


1.53
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: file_subs.c,v 1.52 2016/08/26 04:11:16 guenther Exp $	*/
/*	$NetBSD: file_subs.c,v 1.4 1995/03/21 09:07:18 cgd Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "pax.h"
#include "extern.h"

static int
mk_link(char *, struct stat *, char *, int);

/*
 * routines that deal with file operations such as: creating, removing;
 * and setting access modes, uid/gid and times of files
 */

/*
 * file_creat()
 *	Create and open a file.
 * Return:
 *	file descriptor or -1 for failure
 */

int
file_creat(ARCHD *arcn)
{
	int fd = -1;
	mode_t file_mode;
	int oerrno;

	/*
	 * Assume file doesn't exist, so just try to create it, most times this
	 * works. We have to take special handling when the file does exist. To
	 * detect this, we use O_EXCL. For example when trying to create a
	 * file and a character device or fifo exists with the same name, we
	 * can accidently open the device by mistake (or block waiting to open).
	 * If we find that the open has failed, then spend the effort to
	 * figure out why. This strategy was found to have better average
	 * performance in common use than checking the file (and the path)
	 * first with lstat.
	 */
	file_mode = arcn->sb.st_mode & FILEBITS;
	if ((fd = open(arcn->name, O_WRONLY | O_CREAT | O_EXCL,
	    file_mode)) >= 0)
		return(fd);

	/*
	 * the file seems to exist. First we try to get rid of it (found to be
	 * the second most common failure when traced). If this fails, only
	 * then we go to the expense to check and create the path to the file
	 */
	if (unlnk_exist(arcn->name, arcn->type) != 0)
		return(-1);

	for (;;) {
		/*
		 * try to open it again, if this fails, check all the nodes in
		 * the path and give it a final try. if chk_path() finds that
		 * it cannot fix anything, we will skip the last attempt
		 */
		if ((fd = open(arcn->name, O_WRONLY | O_CREAT | O_TRUNC,
		    file_mode)) >= 0)
			break;
		oerrno = errno;
		if (nodirs || chk_path(arcn->name,arcn->sb.st_uid,arcn->sb.st_gid) < 0) {
			syswarn(1, oerrno, "Unable to create %s", arcn->name);
			return(-1);
		}
	}
	return(fd);
}

/*
 * file_close()
 *	Close file descriptor to a file just created by pax. Sets modes,
 *	ownership and times as required.
 * Return:
 *	0 for success, -1 for failure
 */

void
file_close(ARCHD *arcn, int fd)
{
	int res = 0;

	if (fd < 0)
		return;

	/*
	 * set owner/groups first as this may strip off mode bits we want
	 * then set file permission modes. Then set file access and
	 * modification times.
	 */
	if (pids)
		res = fset_ids(arcn->name, fd, arcn->sb.st_uid,
		    arcn->sb.st_gid);

	/*
	 * IMPORTANT SECURITY NOTE:
	 * if not preserving mode or we cannot set uid/gid, then PROHIBIT
	 * set uid/gid bits
	 */
	if (!pmode || res)
		arcn->sb.st_mode &= ~(SETBITS);
	if (pmode)
		fset_pmode(arcn->name, fd, arcn->sb.st_mode);
	if (patime || pmtime)
		fset_ftime(arcn->name, fd, &arcn->sb.st_mtim,
		    &arcn->sb.st_atim, 0);
	if (close(fd) < 0)
		syswarn(0, errno, "Unable to close file descriptor on %s",
		    arcn->name);
}

/*
 * lnk_creat()
 *	Create a hard link to arcn->ln_name from arcn->name. arcn->ln_name
 *	must exist;
 * Return:
 *	0 if ok, -1 otherwise
 */

int
lnk_creat(ARCHD *arcn)
{
	struct stat sb;
	int res;

	/*
	 * we may be running as root, so we have to be sure that link target
	 * is not a directory, so we lstat and check
	 */
	if (lstat(arcn->ln_name, &sb) < 0) {
		syswarn(1,errno,"Unable to link to %s from %s", arcn->ln_name,
		    arcn->name);
		return(-1);
	}

	if (S_ISDIR(sb.st_mode)) {
		paxwarn(1, "A hard link to the directory %s is not allowed",
		    arcn->ln_name);
		return(-1);
	}

	res = mk_link(arcn->ln_name, &sb, arcn->name, 0);
	if (res == 0) {
		/* check for a hardlink to a placeholder symlink */
		res = sltab_add_link(arcn->name, &sb);

		if (res < 0) {
			/* arrgh, it failed, clean up */
			unlink(arcn->name);
		}
	}

	return (res);
}

/*
 * cross_lnk()
 *	Create a hard link to arcn->org_name from arcn->name. Only used in copy
 *	with the -l flag. No warning or error if this does not succeed (we will
 *	then just create the file)
 * Return:
 *	1 if copy() should try to create this file node
 *	0 if cross_lnk() ok, -1 for fatal flaw (like linking to self).
 */

int
cross_lnk(ARCHD *arcn)
{
	/*
	 * try to make a link to original file (-l flag in copy mode). make
	 * sure we do not try to link to directories in case we are running as
	 * root (and it might succeed).
	 */
	if (arcn->type == PAX_DIR)
		return(1);
	return(mk_link(arcn->org_name, &(arcn->sb), arcn->name, 1));
}

/*
 * chk_same()
 *	In copy mode if we are not trying to make hard links between the src
 *	and destinations, make sure we are not going to overwrite ourselves by
 *	accident. This slows things down a little, but we have to protect all
 *	those people who make typing errors.
 * Return:
 *	1 the target does not exist, go ahead and copy
 *	0 skip it file exists (-k) or may be the same as source file
 */

int
chk_same(ARCHD *arcn)
{
	struct stat sb;

	/*
	 * if file does not exist, return. if file exists and -k, skip it
	 * quietly
	 */
	if (lstat(arcn->name, &sb) < 0)
		return(1);
	if (kflag)
		return(0);

	/*
	 * better make sure the user does not have src == dest by mistake
	 */
	if ((arcn->sb.st_dev == sb.st_dev) && (arcn->sb.st_ino == sb.st_ino)) {
		paxwarn(1, "Unable to copy %s, file would overwrite itself",
		    arcn->name);
		return(0);
	}
	return(1);
}

/*
 * mk_link()
 *	try to make a hard link between two files. if ign set, we do not
 *	complain.
 * Return:
 *	0 if successful (or we are done with this file but no error, such as
 *	finding the from file exists and the user has set -k).
 *	1 when ign was set to indicates we could not make the link but we
 *	should try to copy/extract the file as that might work (and is an
 *	allowed option). -1 an error occurred.
 */

static int
mk_link(char *to, struct stat *to_sb, char *from, int ign)
{
	struct stat sb;
	int oerrno;

	/*
	 * if from file exists, it has to be unlinked to make the link. If the
	 * file exists and -k is set, skip it quietly
	 */
	if (lstat(from, &sb) == 0) {
		if (kflag)
			return(0);

		/*
		 * make sure it is not the same file, protect the user
		 */
		if ((to_sb->st_dev==sb.st_dev)&&(to_sb->st_ino == sb.st_ino)) {
			paxwarn(1, "Unable to link file %s to itself", to);
			return(-1);
		}

		/*
		 * try to get rid of the file, based on the type
		 */
		if (S_ISDIR(sb.st_mode)) {
			if (rmdir(from) < 0) {
				syswarn(1, errno, "Unable to remove %s", from);
				return(-1);
			}
			delete_dir(sb.st_dev, sb.st_ino);
		} else if (unlink(from) < 0) {
			if (!ign) {
				syswarn(1, errno, "Unable to remove %s", from);
				return(-1);
			}
			return(1);
		}
	}

	/*
	 * from file is gone (or did not exist), try to make the hard link.
	 * if it fails, check the path and try it again (if chk_path() says to
	 * try again)
	 */
	for (;;) {
		if (linkat(AT_FDCWD, to, AT_FDCWD, from, 0) == 0)
			break;
		oerrno = errno;
		if (!nodirs && chk_path(from, to_sb->st_uid, to_sb->st_gid) == 0)
			continue;
		if (!ign) {
			syswarn(1, oerrno, "Could not link to %s from %s", to,
			    from);
			return(-1);
		}
		return(1);
	}

	/*
	 * all right the link was made
	 */
	return(0);
}

/*
 * node_creat()
 *	create an entry in the file system (other than a file or hard link).
 *	If successful, sets uid/gid modes and times as required.
 * Return:
 *	0 if ok, -1 otherwise
 */

int
node_creat(ARCHD *arcn)
{
	int res;
	int ign = 0;
	int oerrno;
	int pass = 0;
	mode_t file_mode;
	struct stat sb;
	char target[PATH_MAX];
	char *nm = arcn->name;
	int len, defer_pmode = 0;

	/*
	 * create node based on type, if that fails try to unlink the node and
	 * try again. finally check the path and try again. As noted in the
	 * file and link creation routines, this method seems to exhibit the
	 * best performance in general use workloads.
	 */
	file_mode = arcn->sb.st_mode & FILEBITS;

	for (;;) {
		switch (arcn->type) {
		case PAX_DIR:
			/*
			 * If -h (or -L) was given in tar-mode, follow the
			 * potential symlink chain before trying to create the
			 * directory.
			 */
			if (op_mode == OP_TAR && Lflag) {
				while (lstat(nm, &sb) == 0 &&
				    S_ISLNK(sb.st_mode)) {
					len = readlink(nm, target,
					    sizeof target - 1);
					if (len == -1) {
						syswarn(0, errno,
						   "cannot follow symlink %s in chain for %s",
						    nm, arcn->name);
						res = -1;
						goto badlink;
					}
					target[len] = '\0';
					nm = target;
				}
			}
			res = mkdir(nm, file_mode);

badlink:
			if (ign)
				res = 0;
			break;
		case PAX_CHR:
			file_mode |= S_IFCHR;
			res = mknod(nm, file_mode, arcn->sb.st_rdev);
			break;
		case PAX_BLK:
			file_mode |= S_IFBLK;
			res = mknod(nm, file_mode, arcn->sb.st_rdev);
			break;
		case PAX_FIF:
			res = mkfifo(nm, file_mode);
			break;
		case PAX_SCK:
			/*
			 * Skip sockets, operation has no meaning under BSD
			 */
			paxwarn(0,
			    "%s skipped. Sockets cannot be copied or extracted",
			    nm);
			return(-1);
		case PAX_SLK:
			if (arcn->ln_name[0] != '/' &&
			    !has_dotdot(arcn->ln_name))
				res = symlink(arcn->ln_name, nm);
			else {
				/*
				 * absolute symlinks and symlinks with ".."
				 * have to be deferred to prevent the archive
				 * from bootstrapping itself to outside the
				 * working directory.
				 */
				res = sltab_add_sym(nm, arcn->ln_name,
				    arcn->sb.st_mode);
				if (res == 0)
					defer_pmode = 1;
			}
			break;
		case PAX_CTG:
		case PAX_HLK:
		case PAX_HRG:
		case PAX_REG:
		default:
			/*
			 * we should never get here
			 */
			paxwarn(0, "%s has an unknown file type, skipping",
				nm);
			return(-1);
		}

		/*
		 * if we were able to create the node break out of the loop,
		 * otherwise try to unlink the node and try again. if that
		 * fails check the full path and try a final time.
		 */
		if (res == 0)
			break;

		/*
		 * we failed to make the node
		 */
		oerrno = errno;
		if ((ign = unlnk_exist(nm, arcn->type)) < 0)
			return(-1);

		if (++pass <= 1)
			continue;

		if (nodirs || chk_path(nm,arcn->sb.st_uid,arcn->sb.st_gid) < 0) {
			syswarn(1, oerrno, "Could not create: %s", nm);
			return(-1);
		}
	}

	/*
	 * we were able to create the node. set uid/gid, modes and times
	 */
	if (pids)
		res = set_ids(nm, arcn->sb.st_uid, arcn->sb.st_gid);
	else
		res = 0;

	/*
	 * IMPORTANT SECURITY NOTE:
	 * if not preserving mode or we cannot set uid/gid, then PROHIBIT any
	 * set uid/gid bits
	 */
	if (!pmode || res)
		arcn->sb.st_mode &= ~(SETBITS);
	if (pmode && !defer_pmode)
		set_pmode(nm, arcn->sb.st_mode);

	if (arcn->type == PAX_DIR && op_mode != OP_CPIO) {
		/*
		 * Dirs must be processed again at end of extract to set times
		 * and modes to agree with those stored in the archive. However
		 * to allow extract to continue, we may have to also set owner
		 * rights. This allows nodes in the archive that are children
		 * of this directory to be extracted without failure. Both time
		 * and modes will be fixed after the entire archive is read and
		 * before pax exits.  To do that safely, we want the dev+ino
		 * of the directory we created.
		 */
		if (lstat(nm, &sb) < 0) {
			syswarn(0, errno,"Could not access %s (stat)", nm);
		} else if (access(nm, R_OK | W_OK | X_OK) < 0) {
			/*
			 * We have to add rights to the dir, so we make
			 * sure to restore the mode. The mode must be
			 * restored AS CREATED and not as stored if
			 * pmode is not set.
			 */
			set_pmode(nm,
			    ((sb.st_mode & FILEBITS) | S_IRWXU));
			if (!pmode)
				arcn->sb.st_mode = sb.st_mode;

			/*
			 * we have to force the mode to what was set
			 * here, since we changed it from the default
			 * as created.
			 */
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
			add_dir(nm, &(arcn->sb), 1);
		} else if (pmode || patime || pmtime) {
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
			add_dir(nm, &(arcn->sb), 0);
		}
	} else if (patime || pmtime)
		set_ftime(nm, &arcn->sb.st_mtim, &arcn->sb.st_atim, 0);
	return(0);
}

/*
 * unlnk_exist()
 *	Remove node from file system with the specified name. We pass the type
 *	of the node that is going to replace it. When we try to create a
 *	directory and find that it already exists, we allow processing to
 *	continue as proper modes etc will always be set for it later on.
 * Return:
 *	0 is ok to proceed, no file with the specified name exists
 *	-1 we were unable to remove the node, or we should not remove it (-k)
 *	1 we found a directory and we were going to create a directory.
 */

int
unlnk_exist(char *name, int type)
{
	struct stat sb;

	/*
	 * the file does not exist, or -k we are done
	 */
	if (lstat(name, &sb) < 0)
		return(0);
	if (kflag)
		return(-1);

	if (S_ISDIR(sb.st_mode)) {
		/*
		 * try to remove a directory, if it fails and we were going to
		 * create a directory anyway, tell the caller (return a 1)
		 */
		if (rmdir(name) < 0) {
			if (type == PAX_DIR)
				return(1);
			syswarn(1,errno,"Unable to remove directory %s", name);
			return(-1);
		}
		delete_dir(sb.st_dev, sb.st_ino);
		return(0);
	}

	/*
	 * try to get rid of all non-directory type nodes
	 */
	if (unlink(name) < 0) {
		syswarn(1, errno, "Could not unlink %s", name);
		return(-1);
	}
	return(0);
}

/*
 * chk_path()
 *	We were trying to create some kind of node in the file system and it
 *	failed. chk_path() makes sure the path up to the node exists and is
 *	writeable. When we have to create a directory that is missing along the
 *	path somewhere, the directory we create will be set to the same
 *	uid/gid as the file has (when uid and gid are being preserved).
 *	NOTE: this routine is a real performance loss. It is only used as a
 *	last resort when trying to create entries in the file system.
 * Return:
 *	-1 when it could find nothing it is allowed to fix.
 *	0 otherwise
 */

int
chk_path(char *name, uid_t st_uid, gid_t st_gid)
{
	char *spt = name;
	char *next;
	struct stat sb;
	int retval = -1;

	/*
	 * watch out for paths with nodes stored directly in / (e.g. /bozo)
	 */
	while (*spt == '/')
		++spt;

	for (;;) {
		/*
		 * work forward from the first / and check each part of the path
		 */
		spt = strchr(spt, '/');
		if (spt == NULL)
			break;

		/*
		 * skip over duplicate slashes; stop if there're only
		 * trailing slashes left
		 */
		next = spt + 1;
		while (*next == '/')
			next++;
		if (*next == '\0')
			break;

		*spt = '\0';

		/*
		 * if it exists we assume it is a directory, it is not within
		 * the spec (at least it seems to read that way) to alter the
		 * file system for nodes NOT EXPLICITLY stored on the archive.
		 * If that assumption is changed, you would test the node here
		 * and figure out how to get rid of it (probably like some
		 * recursive unlink()) or fix up the directory permissions if
		 * required (do an access()).
		 */
		if (lstat(name, &sb) == 0) {
			*spt = '/';
			spt = next;
			continue;
		}

		/*
		 * the path fails at this point, see if we can create the
		 * needed directory and continue on
		 */
		if (mkdir(name, S_IRWXU | S_IRWXG | S_IRWXO) < 0) {
			*spt = '/';
			retval = -1;
			break;
		}

		/*
		 * we were able to create the directory. We will tell the
		 * caller that we found something to fix, and it is ok to try
		 * and create the node again.
		 */
		retval = 0;
		if (pids)
			(void)set_ids(name, st_uid, st_gid);

		/*
		 * make sure the user doesn't have some strange umask that
		 * causes this newly created directory to be unusable. We fix
		 * the modes and restore them back to the creation default at
		 * the end of pax
		 */
		if ((access(name, R_OK | W_OK | X_OK) < 0) &&
		    (lstat(name, &sb) == 0)) {
			set_pmode(name, ((sb.st_mode & FILEBITS) | S_IRWXU));
			add_dir(name, &sb, 1);
		}
		*spt = '/';
		spt = next;
		continue;
	}
	return(retval);
}

/*
 * set_ftime()
 *	Set the access time and modification time for a named file. If frc
 *	is non-zero we force these times to be set even if the user did not
 *	request access and/or modification time preservation (this is also
 *	used by -t to reset access times).
 *	When ign is zero, only those times the user has asked for are set, the
 *	other ones are left alone.
 */

void
set_ftime(const char *fnm, const struct timespec *mtimp,
    const struct timespec *atimp, int frc)
{
	struct timespec tv[2];

	tv[0] = *atimp;
	tv[1] = *mtimp;

	if (!frc) {
		/*
		 * if we are not forcing, only set those times the user wants
		 * set.
		 */
		if (!patime)
			tv[0].tv_nsec = UTIME_OMIT;
		if (!pmtime)
			tv[1].tv_nsec = UTIME_OMIT;
	}

	/*
	 * set the times
	 */
	if (utimensat(AT_FDCWD, fnm, tv, AT_SYMLINK_NOFOLLOW) < 0)
		syswarn(1, errno, "Access/modification time set failed on: %s",
		    fnm);
}

void
fset_ftime(const char *fnm, int fd, const struct timespec *mtimp,
    const struct timespec *atimp, int frc)
{
	struct timespec tv[2];


	tv[0] = *atimp;
	tv[1] = *mtimp;

	if (!frc) {
		/*
		 * if we are not forcing, only set those times the user wants
		 * set.
		 */
		if (!patime)
			tv[0].tv_nsec = UTIME_OMIT;
		if (!pmtime)
			tv[1].tv_nsec = UTIME_OMIT;
	}
	/*
	 * set the times
	 */
	if (futimens(fd, tv) < 0)
		syswarn(1, errno, "Access/modification time set failed on: %s",
		    fnm);
}

/*
 * set_ids()
 *	set the uid and gid of a file system node
 * Return:
 *	0 when set, -1 on failure
 */

int
set_ids(char *fnm, uid_t uid, gid_t gid)
{
	if (fchownat(AT_FDCWD, fnm, uid, gid, AT_SYMLINK_NOFOLLOW) < 0) {
		/*
		 * ignore EPERM unless in verbose mode or being run by root.
		 * if running as pax, POSIX requires a warning.
		 */
		if (op_mode == OP_PAX || errno != EPERM || vflag ||
		    geteuid() == 0)
			syswarn(1, errno, "Unable to set file uid/gid of %s",
			    fnm);
		return(-1);
	}
	return(0);
}

int
fset_ids(char *fnm, int fd, uid_t uid, gid_t gid)
{
	if (fchown(fd, uid, gid) < 0) {
		/*
		 * ignore EPERM unless in verbose mode or being run by root.
		 * if running as pax, POSIX requires a warning.
		 */
		if (op_mode == OP_PAX || errno != EPERM || vflag ||
		    geteuid() == 0)
			syswarn(1, errno, "Unable to set file uid/gid of %s",
			    fnm);
		return(-1);
	}
	return(0);
}

/*
 * set_pmode()
 *	Set file access mode
 */

void
set_pmode(char *fnm, mode_t mode)
{
	mode &= ABITS;
	if (fchmodat(AT_FDCWD, fnm, mode, AT_SYMLINK_NOFOLLOW) < 0)
		syswarn(1, errno, "Could not set permissions on %s", fnm);
}

void
fset_pmode(char *fnm, int fd, mode_t mode)
{
	mode &= ABITS;
	if (fchmod(fd, mode) < 0)
		syswarn(1, errno, "Could not set permissions on %s", fnm);
}

/*
 * set_attr()
 *	Given a DIRDATA, restore the mode and times as indicated, but
 *	only after verifying that it's the directory that we wanted.
 */
int
set_attr(const struct file_times *ft, int force_times, mode_t mode,
    int do_mode, int in_sig)
{
	struct stat sb;
	int fd, r;

	if (!do_mode && !force_times && !patime && !pmtime)
		return (0);

	/*
	 * We could legitimately go through a symlink here,
	 * so do *not* use O_NOFOLLOW.  The dev+ino check will
	 * protect us from evil.
	 */
	fd = open(ft->ft_name, O_RDONLY | O_DIRECTORY);
	if (fd == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to restore mode and times"
			    " for directory: %s", ft->ft_name);
		return (-1);
	}

	if (fstat(fd, &sb) == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to stat directory: %s",
			    ft->ft_name);
		r = -1;
	} else if (ft->ft_ino != sb.st_ino || ft->ft_dev != sb.st_dev) {
		if (!in_sig)
			paxwarn(1, "Directory vanished before restoring"
			    " mode and times: %s", ft->ft_name);
		r = -1;
	} else {
		/* Whew, it's a match!  Is there anything to change? */
		if (do_mode && (mode & ABITS) != (sb.st_mode & ABITS))
			fset_pmode(ft->ft_name, fd, mode);
		if (((force_times || patime) &&
		    timespeccmp(&ft->ft_atim, &sb.st_atim, !=)) ||
		    ((force_times || pmtime) &&
		    timespeccmp(&ft->ft_mtim, &sb.st_mtim, !=)))
			fset_ftime(ft->ft_name, fd, &ft->ft_mtim,
			    &ft->ft_atim, force_times);
		r = 0;
	}
	close(fd);

	return (r);
}


/*
 * file_write()
 *	Write/copy a file (during copy or archive extract). This routine knows
 *	how to copy files with lseek holes in it. (Which are read as file
 *	blocks containing all 0's but do not have any file blocks associated
 *	with the data). Typical examples of these are files created by dbm
 *	variants (.pag files). While the file size of these files are huge, the
 *	actual storage is quite small (the files are sparse). The problem is
 *	the holes read as all zeros so are probably stored on the archive that
 *	way (there is no way to determine if the file block is really a hole,
 *	we only know that a file block of all zero's can be a hole).
 *	At this writing, no major archive format knows how to archive files
 *	with holes. However, on extraction (or during copy, -rw) we have to
 *	deal with these files. Without detecting the holes, the files can
 *	consume a lot of file space if just written to disk. This replacement
 *	for write when passed the basic allocation size of a file system block,
 *	uses lseek whenever it detects the input data is all 0 within that
 *	file block. In more detail, the strategy is as follows:
 *	While the input is all zero keep doing an lseek. Keep track of when we
 *	pass over file block boundaries. Only write when we hit a non zero
 *	input. once we have written a file block, we continue to write it to
 *	the end (we stop looking at the input). When we reach the start of the
 *	next file block, start checking for zero blocks again. Working on file
 *	block boundaries significantly reduces the overhead when copying files
 *	that are NOT very sparse. This overhead (when compared to a write) is
 *	almost below the measurement resolution on many systems. Without it,
 *	files with holes cannot be safely copied. It does has a side effect as
 *	it can put holes into files that did not have them before, but that is
 *	not a problem since the file contents are unchanged (in fact it saves
 *	file space). (Except on paging files for diskless clients. But since we
 *	cannot determine one of those file from here, we ignore them). If this
 *	ever ends up on a system where CTG files are supported and the holes
 *	are not desired, just do a conditional test in those routines that
 *	call file_write() and have it call write() instead. BEFORE CLOSING THE
 *	FILE, make sure to call file_flush() when the last write finishes with
 *	an empty block. A lot of file systems will not create an lseek hole at
 *	the end. In this case we drop a single 0 at the end to force the
 *	trailing 0's in the file.
 *	---Parameters---
 *	rem: how many bytes left in this file system block
 *	isempt: have we written to the file block yet (is it empty)
 *	sz: basic file block allocation size
 *	cnt: number of bytes on this write
 *	str: buffer to write
 * Return:
 *	number of bytes written, -1 on write (or lseek) error.
 */

int
file_write(int fd, char *str, int cnt, int *rem, int *isempt, int sz,
	char *name)
{
	char *pt;
	char *end;
	int wcnt;
	char *st = str;
	char **strp;

	/*
	 * while we have data to process
	 */
	while (cnt) {
		if (!*rem) {
			/*
			 * We are now at the start of file system block again
			 * (or what we think one is...). start looking for
			 * empty blocks again
			 */
			*isempt = 1;
			*rem = sz;
		}

		/*
		 * only examine up to the end of the current file block or
		 * remaining characters to write, whatever is smaller
		 */
		wcnt = MINIMUM(cnt, *rem);
		cnt -= wcnt;
		*rem -= wcnt;
		if (*isempt) {
			/*
			 * have not written to this block yet, so we keep
			 * looking for zero's
			 */
			pt = st;
			end = st + wcnt;

			/*
			 * look for a zero filled buffer
			 */
			while ((pt < end) && (*pt == '\0'))
				++pt;

			if (pt == end) {
				/*
				 * skip, buf is empty so far
				 */
				if (fd > -1 &&
				    lseek(fd, wcnt, SEEK_CUR) < 0) {
					syswarn(1,errno,"File seek on %s",
					    name);
					return(-1);
				}
				st = pt;
				continue;
			}
			/*
			 * drat, the buf is not zero filled
			 */
			*isempt = 0;
		}

		/*
		 * have non-zero data in this file system block, have to write
		 */
		switch (fd) {
		case -1:
			strp = &gnu_name_string;
			break;
		case -2:
			strp = &gnu_link_string;
			break;
		default:
			strp = NULL;
			break;
		}
		if (strp) {
			if (*strp)
				err(1, "WARNING! Major Internal Error! GNU hack Failing!");
			*strp = malloc(wcnt + 1);
			if (*strp == NULL) {
				paxwarn(1, "Out of memory");
				return(-1);
			}
			memcpy(*strp, st, wcnt);
			(*strp)[wcnt] = '\0';
			break;
		} else if (write(fd, st, wcnt) != wcnt) {
			syswarn(1, errno, "Failed write to file %s", name);
			return(-1);
		}
		st += wcnt;
	}
	return(st - str);
}

/*
 * file_flush()
 *	when the last file block in a file is zero, many file systems will not
 *	let us create a hole at the end. To get the last block with zeros, we
 *	write the last BYTE with a zero (back up one byte and write a zero).
 */

void
file_flush(int fd, char *fname, int isempt)
{
	static char blnk[] = "\0";

	/*
	 * silly test, but make sure we are only called when the last block is
	 * filled with all zeros.
	 */
	if (!isempt)
		return;

	/*
	 * move back one byte and write a zero
	 */
	if (lseek(fd, -1, SEEK_CUR) < 0) {
		syswarn(1, errno, "Failed seek on file %s", fname);
		return;
	}

	if (write(fd, blnk, 1) < 0)
		syswarn(1, errno, "Failed write to file %s", fname);
}

/*
 * rdfile_close()
 *	close a file we have been reading (to copy or archive). If we have to
 *	reset access time (tflag) do so (the times are stored in arcn).
 */

void
rdfile_close(ARCHD *arcn, int *fd)
{
	/*
	 * make sure the file is open
	 */
	if (*fd < 0)
		return;

	/*
	 * user wants last access time reset
	 */
	if (tflag)
		fset_ftime(arcn->org_name, *fd, &arcn->sb.st_mtim,
		    &arcn->sb.st_atim, 1);

	(void)close(*fd);
	*fd = -1;
}

/*
 * set_crc()
 *	read a file to calculate its crc. This is a real drag. Archive formats
 *	that have this, end up reading the file twice (we have to write the
 *	header WITH the crc before writing the file contents. Oh well...
 * Return:
 *	0 if was able to calculate the crc, -1 otherwise
 */

int
set_crc(ARCHD *arcn, int fd)
{
	int i;
	int res;
	off_t cpcnt = 0;
	size_t size;
	u_int32_t crc = 0;
	char tbuf[FILEBLK];
	struct stat sb;

	if (fd < 0) {
		/*
		 * hmm, no fd, should never happen. well no crc then.
		 */
		arcn->crc = 0;
		return(0);
	}

	if ((size = arcn->sb.st_blksize) > sizeof(tbuf))
		size = sizeof(tbuf);

	/*
	 * read all the bytes we think that there are in the file. If the user
	 * is trying to archive an active file, forget this file.
	 */
	for (;;) {
		if ((res = read(fd, tbuf, size)) <= 0)
			break;
		cpcnt += res;
		for (i = 0; i < res; ++i)
			crc += (tbuf[i] & 0xff);
	}

	/*
	 * safety check. we want to avoid archiving files that are active as
	 * they can create inconsistent archive copies.
	 */
	if (cpcnt != arcn->sb.st_size)
		paxwarn(1, "File changed size %s", arcn->org_name);
	else if (fstat(fd, &sb) < 0)
		syswarn(1, errno, "Failed stat on %s", arcn->org_name);
	else if (timespeccmp(&arcn->sb.st_mtim, &sb.st_mtim, !=))
		paxwarn(1, "File %s was modified during read", arcn->org_name);
	else if (lseek(fd, 0, SEEK_SET) < 0)
		syswarn(1, errno, "File rewind failed on: %s", arcn->org_name);
	else {
		arcn->crc = crc;
		return(0);
	}
	return(-1);
}
@


1.52
log
@Don't need <sys/time.h> or "options.h" here
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.51 2016/08/23 06:00:28 guenther Exp $	*/
d722 1
a722 1
	
@


1.51
log
@Instead of doing strcmp(argv0), track the invocation mode (pax/tar/cpio)
in a separate variable

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.50 2016/08/23 03:31:44 guenther Exp $	*/
a36 1
#include <sys/time.h>
a46 1
#include "options.h"
@


1.50
log
@Only try to set the times on a directory once, at the end, to avoid
duplication of warning messages

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.49 2016/08/14 18:30:33 guenther Exp $	*/
d374 1
a374 1
			if (strcmp(NM_TAR, argv0) == 0 && Lflag) {
d487 1
a487 1
	if (arcn->type == PAX_DIR && strcmp(NM_CPIO, argv0) != 0) {
d761 1
a761 1
		if (strcmp(NM_PAX, argv0) == 0 || errno != EPERM || vflag ||
d778 1
a778 1
		if (strcmp(NM_PAX, argv0) == 0 || errno != EPERM || vflag ||
@


1.49
log
@Remove many unnecessary casts.  Verified by comparing generated code on
both ILP32 and LP64.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.48 2016/02/16 04:30:07 guenther Exp $	*/
d525 1
a525 3
	}

	if (patime || pmtime)
@


1.48
log
@Ignore trailing slashes and skip over duplicate slashes in chk_path() to
avoid infinite loop when creating intermediate directories

Fix based on diff by Nicolas Bedos (nicolas.bedos (at) gmail.com)
ok millert@@ ok and tweak zhuk@@,
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.47 2015/03/19 05:14:24 guenther Exp $	*/
d964 1
a964 1
				    lseek(fd, (off_t)wcnt, SEEK_CUR) < 0) {
d1034 1
a1034 1
	if (lseek(fd, (off_t)-1, SEEK_CUR) < 0) {
d1083 2
a1084 2
	off_t cpcnt = 0L;
	u_long size;
d1093 1
a1093 1
		arcn->crc = 0L;
d1097 2
a1098 2
	if ((size = (u_long)arcn->sb.st_blksize) > (u_long)sizeof(tbuf))
		size = (u_long)sizeof(tbuf);
d1122 1
a1122 1
	else if (lseek(fd, (off_t)0L, SEEK_SET) < 0)
@


1.47
log
@Use struct timespec internally.  This gives nanosecond precision to pax -rw
and a basis for support of mtime and atime values in pax-format extended
header records.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.46 2015/03/15 06:05:59 guenther Exp $	*/
d600 1
d607 1
a607 1
	if (*spt == '/')
d617 11
d640 2
a641 1
			*(spt++) = '/';
d675 2
a676 1
		*(spt++) = '/';
@


1.46
log
@Using O_TRUNC with O_CREAT|O_EXCL is just confusing: fail if it exists,
but if you *did* succeed anyway, truncate it?
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.45 2015/03/09 04:23:29 guenther Exp $	*/
d150 2
a151 2
		fset_ftime(arcn->name, fd, arcn->sb.st_mtime,
		    arcn->sb.st_atime, 0);
d528 1
a528 1
		set_ftime(nm, arcn->sb.st_mtime, arcn->sb.st_atime, 0);
d679 2
a680 1
set_ftime(char *fnm, time_t mtime, time_t atime, int frc)
d684 3
a686 4
	tv[0].tv_sec = atime;
	tv[0].tv_nsec = 0L;
	tv[1].tv_sec = mtime;
	tv[1].tv_nsec = 0L;
d707 2
a708 1
fset_ftime(char *fnm, int fd, time_t mtime, time_t atime, int frc)
d712 4
a715 4
	tv[0].tv_sec = atime;
	tv[0].tv_nsec = 0L;
	tv[1].tv_sec = mtime;
	tv[1].tv_nsec = 0L;
d838 6
a843 4
		if (((force_times || patime) && ft->ft_atime != sb.st_atime) ||
		    ((force_times || pmtime) && ft->ft_mtime != sb.st_mtime))
			fset_ftime(ft->ft_name, fd, ft->ft_mtime,
			    ft->ft_atime, force_times);
d1048 2
a1049 2
		fset_ftime(arcn->org_name, *fd, arcn->sb.st_mtime,
		    arcn->sb.st_atime, 1);
d1106 1
a1106 1
	else if (arcn->sb.st_mtime != sb.st_mtime)
@


1.45
log
@Unrevert post-unlock:
* Prevent an archive from esacaping the current directory by itself:
  when extracting a symlink whose value is absolute or contains ".."
  components, just create a zero-length normal file (with additional
  tracking of the mode and hardlinks to the symlink) until everything
  else is extracted, then go back and replace it with the requested
  link (if it's still that zero-length placeholder).

* For tar without -P, if a path in the archive has any ".." components
  then strip everything up to and including the last of them (if
  it ends in ".." then it becomes ".")
  This mostly follows GNU tar's behavior, except for 'tar tf' and
  'tar xvf' we report the modified path that would be/was actually
  created instead of the raw path from the archive

  Above two fixes prompted by a report from Daniel Cegielka
  (daniel.cegielka (at) gmail.com)

* For directories whose times or mode will be fixed up in the
  clean-up pass, record their dev+ino and then use
  open(O_DIRECTORY)+fstat() to verify that we're updating the correct
  directory before using futimens() and fchmod().

* Correct buffer overflow in handling of pax extension headers,
  caught by the memcpy() overlap check.


previously ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.43 2015/02/15 22:18:29 millert Exp $	*/
d85 1
a85 1
	if ((fd = open(arcn->name, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL,
@


1.44
log
@Recent changes haven't been completely stable, so revert for the 5.7 release

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.38 2015/01/16 06:39:32 deraadt Exp $	*/
a58 4
#define FILEBITS		(S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
#define SETBITS			(S_ISUID | S_ISGID)
#define ABITS			(FILEBITS | SETBITS)

d169 1
d187 12
a198 1
	return(mk_link(arcn->ln_name, &sb, arcn->name, 0));
d302 1
d356 1
a356 1
	int len;
d416 15
a430 1
			res = symlink(arcn->ln_name, nm);
d484 1
a484 1
	if (pmode)
d495 2
a496 1
		 * before pax exits.
d498 13
a510 17
		if (access(nm, R_OK | W_OK | X_OK) < 0) {
			if (lstat(nm, &sb) < 0) {
				syswarn(0, errno,"Could not access %s (stat)",
				    arcn->name);
				set_pmode(nm,file_mode | S_IRWXU);
			} else {
				/*
				 * We have to add rights to the dir, so we make
				 * sure to restore the mode. The mode must be
				 * restored AS CREATED and not as stored if
				 * pmode is not set.
				 */
				set_pmode(nm,
				    ((sb.st_mode & FILEBITS) | S_IRWXU));
				if (!pmode)
					arcn->sb.st_mode = sb.st_mode;
			}
d513 3
a515 2
			 * we have to force the mode to what was set here,
			 * since we changed it from the default as created.
d517 2
d520 3
a522 1
		} else if (pmode || patime || pmtime)
d524 1
d568 1
d796 54
a1040 5
	(void)close(*fd);
	*fd = -1;
	if (!tflag)
		return;

d1044 6
a1049 1
	set_ftime(arcn->org_name, arcn->sb.st_mtime, arcn->sb.st_atime, 1);
@


1.44.2.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.44 2015/02/21 22:48:23 guenther Exp $	*/
d59 4
a172 1
	int res;
d190 1
a190 12
	res = mk_link(arcn->ln_name, &sb, arcn->name, 0);
	if (res == 0) {
		/* check for a hardlink to a placeholder symlink */
		res = sltab_add_link(arcn->name, &sb);

		if (res < 0) {
			/* arrgh, it failed, clean up */
			unlink(arcn->name);
		}
	}

	return (res);
a293 1
			delete_dir(sb.st_dev, sb.st_ino);
d347 1
a347 1
	int len, defer_pmode = 0;
d407 1
a407 15
			if (arcn->ln_name[0] != '/' &&
			    !has_dotdot(arcn->ln_name))
				res = symlink(arcn->ln_name, nm);
			else {
				/*
				 * absolute symlinks and symlinks with ".."
				 * have to be deferred to prevent the archive
				 * from bootstrapping itself to outside the
				 * working directory.
				 */
				res = sltab_add_sym(nm, arcn->ln_name,
				    arcn->sb.st_mode);
				if (res == 0)
					defer_pmode = 1;
			}
d461 1
a461 1
	if (pmode && !defer_pmode)
d472 1
a472 2
		 * before pax exits.  To do that safely, we want the dev+ino
		 * of the directory we created.
d474 17
a490 13
		if (lstat(nm, &sb) < 0) {
			syswarn(0, errno,"Could not access %s (stat)", nm);
		} else if (access(nm, R_OK | W_OK | X_OK) < 0) {
			/*
			 * We have to add rights to the dir, so we make
			 * sure to restore the mode. The mode must be
			 * restored AS CREATED and not as stored if
			 * pmode is not set.
			 */
			set_pmode(nm,
			    ((sb.st_mode & FILEBITS) | S_IRWXU));
			if (!pmode)
				arcn->sb.st_mode = sb.st_mode;
d493 2
a494 3
			 * we have to force the mode to what was set
			 * here, since we changed it from the default
			 * as created.
a495 2
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
d497 1
a497 3
		} else if (pmode || patime || pmtime) {
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
a498 1
		}
a541 1
		delete_dir(sb.st_dev, sb.st_ino);
a768 54
 * set_attr()
 *	Given a DIRDATA, restore the mode and times as indicated, but
 *	only after verifying that it's the directory that we wanted.
 */
int
set_attr(const struct file_times *ft, int force_times, mode_t mode,
    int do_mode, int in_sig)
{
	struct stat sb;
	int fd, r;

	if (!do_mode && !force_times && !patime && !pmtime)
		return (0);

	/*
	 * We could legitimately go through a symlink here,
	 * so do *not* use O_NOFOLLOW.  The dev+ino check will
	 * protect us from evil.
	 */
	fd = open(ft->ft_name, O_RDONLY | O_DIRECTORY);
	if (fd == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to restore mode and times"
			    " for directory: %s", ft->ft_name);
		return (-1);
	}

	if (fstat(fd, &sb) == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to stat directory: %s",
			    ft->ft_name);
		r = -1;
	} else if (ft->ft_ino != sb.st_ino || ft->ft_dev != sb.st_dev) {
		if (!in_sig)
			paxwarn(1, "Directory vanished before restoring"
			    " mode and times: %s", ft->ft_name);
		r = -1;
	} else {
		/* Whew, it's a match!  Is there anything to change? */
		if (do_mode && (mode & ABITS) != (sb.st_mode & ABITS))
			fset_pmode(ft->ft_name, fd, mode);
		if (((force_times || patime) && ft->ft_atime != sb.st_atime) ||
		    ((force_times || pmtime) && ft->ft_mtime != sb.st_mtime))
			fset_ftime(ft->ft_name, fd, ft->ft_mtime,
			    ft->ft_atime, force_times);
		r = 0;
	}
	close(fd);

	return (r);
}


/*
d960 5
d968 1
a968 6
	if (tflag)
		fset_ftime(arcn->org_name, *fd, arcn->sb.st_mtime,
		    arcn->sb.st_atime, 1);

	(void)close(*fd);
	*fd = -1;
@


1.43
log
@Fix two bugs.  The first affected tar files with the same
directory listed twice with nothing created inside the directory
in between the two instances of the directory.  The other fixes
extracting symlinks when the -C option is used.  From guenther@@
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.42 2015/02/12 23:44:57 guenther Exp $	*/
d59 4
a172 1
	int res;
d190 1
a190 12
	res = mk_link(arcn->ln_name, &sb, arcn->name, 0);
	if (res == 0) {
		/* check for a hardlink to a placeholder symlink */
		res = sltab_add_link(arcn->name, &sb);

		if (res < 0) {
			/* arrgh, it failed, clean up */
			unlink(arcn->name);
		}
	}

	return (res);
a293 1
			delete_dir(sb.st_dev, sb.st_ino);
d347 1
a347 1
	int len, defer_pmode = 0;
d407 1
a407 15
			if (arcn->ln_name[0] != '/' &&
			    !has_dotdot(arcn->ln_name))
				res = symlink(arcn->ln_name, nm);
			else {
				/*
				 * absolute symlinks and symlinks with ".."
				 * have to be deferred to prevent the archive
				 * from bootstrapping itself to outside the
				 * working directory.
				 */
				res = sltab_add_sym(nm, arcn->ln_name,
				    arcn->sb.st_mode);
				if (res == 0)
					defer_pmode = 1;
			}
d461 1
a461 1
	if (pmode && !defer_pmode)
d472 1
a472 2
		 * before pax exits.  To do that safely, we want the dev+ino
		 * of the directory we created.
d474 17
a490 13
		if (lstat(nm, &sb) < 0) {
			syswarn(0, errno,"Could not access %s (stat)", nm);
		} else if (access(nm, R_OK | W_OK | X_OK) < 0) {
			/*
			 * We have to add rights to the dir, so we make
			 * sure to restore the mode. The mode must be
			 * restored AS CREATED and not as stored if
			 * pmode is not set.
			 */
			set_pmode(nm,
			    ((sb.st_mode & FILEBITS) | S_IRWXU));
			if (!pmode)
				arcn->sb.st_mode = sb.st_mode;
d493 2
a494 3
			 * we have to force the mode to what was set
			 * here, since we changed it from the default
			 * as created.
a495 2
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
d497 1
a497 3
		} else if (pmode || patime || pmtime) {
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
a498 1
		}
a541 1
		delete_dir(sb.st_dev, sb.st_ino);
a768 54
 * set_attr()
 *	Given a DIRDATA, restore the mode and times as indicated, but
 *	only after verifying that it's the directory that we wanted.
 */
int
set_attr(const struct file_times *ft, int force_times, mode_t mode,
    int do_mode, int in_sig)
{
	struct stat sb;
	int fd, r;

	if (!do_mode && !force_times && !patime && !pmtime)
		return (0);

	/*
	 * We could legitimately go through a symlink here,
	 * so do *not* use O_NOFOLLOW.  The dev+ino check will
	 * protect us from evil.
	 */
	fd = open(ft->ft_name, O_RDONLY | O_DIRECTORY);
	if (fd == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to restore mode and times"
			    " for directory: %s", ft->ft_name);
		return (-1);
	}

	if (fstat(fd, &sb) == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to stat directory: %s",
			    ft->ft_name);
		r = -1;
	} else if (ft->ft_ino != sb.st_ino || ft->ft_dev != sb.st_dev) {
		if (!in_sig)
			paxwarn(1, "Directory vanished before restoring"
			    " mode and times: %s", ft->ft_name);
		r = -1;
	} else {
		/* Whew, it's a match!  Is there anything to change? */
		if (do_mode && (mode & ABITS) != (sb.st_mode & ABITS))
			fset_pmode(ft->ft_name, fd, mode);
		if (((force_times || patime) && ft->ft_atime != sb.st_atime) ||
		    ((force_times || pmtime) && ft->ft_mtime != sb.st_mtime))
			fset_ftime(ft->ft_name, fd, ft->ft_mtime,
			    ft->ft_atime, force_times);
		r = 0;
	}
	close(fd);

	return (r);
}


/*
d960 5
d968 1
a968 6
	if (tflag)
		fset_ftime(arcn->org_name, *fd, arcn->sb.st_mtime,
		    arcn->sb.st_atime, 1);

	(void)close(*fd);
	*fd = -1;
@


1.42
log
@Prevent an archive from esacaping the current directory by itself:
when extracting a symlink whose value is absolute or contains ".."
components, just create a zero-length normal file (with additional
tracking of the mode and hardlinks to the symlink) until everything
else is extracted, then go back and replace it with the requested
link (if its still that zero-length placeholder).

This and previous symlink and ".." path fixes prompted by a report
from Daniel Cegielka (daniel.cegielka (at) gmail.com)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.41 2015/02/11 23:14:46 guenther Exp $	*/
d302 1
d568 1
@


1.41
log
@Take II, this time without an incorrect mode test.
For directories whose times or mode will be fixed up in the clean-up pass,
record their dev+ino and then use open(O_DIRECTORY)+fstat() to verify that
we're updating the correct directory before using futimens() and fchmod().

ok sthen@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.40 2015/02/05 22:32:20 sthen Exp $	*/
d169 1
d187 12
a198 1
	return(mk_link(arcn->ln_name, &sb, arcn->name, 0));
d355 1
a355 1
	int len;
d415 15
a429 1
			res = symlink(arcn->ln_name, nm);
d483 1
a483 1
	if (pmode)
@


1.40
log
@backout previous for now; issues seen with "tar: Directory vanished before
restoring mode and times: ..." (and an error exit code, which breaks at least
building ports). krw@@ agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.38 2015/01/16 06:39:32 deraadt Exp $	*/
a58 4
#define FILEBITS		(S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
#define SETBITS			(S_ISUID | S_ISGID)
#define ABITS			(FILEBITS | SETBITS)

d468 2
a469 1
		 * before pax exits.
d471 13
a483 17
		if (access(nm, R_OK | W_OK | X_OK) < 0) {
			if (lstat(nm, &sb) < 0) {
				syswarn(0, errno,"Could not access %s (stat)",
				    arcn->name);
				set_pmode(nm,file_mode | S_IRWXU);
			} else {
				/*
				 * We have to add rights to the dir, so we make
				 * sure to restore the mode. The mode must be
				 * restored AS CREATED and not as stored if
				 * pmode is not set.
				 */
				set_pmode(nm,
				    ((sb.st_mode & FILEBITS) | S_IRWXU));
				if (!pmode)
					arcn->sb.st_mode = sb.st_mode;
			}
d486 3
a488 2
			 * we have to force the mode to what was set here,
			 * since we changed it from the default as created.
d490 2
d493 3
a495 1
		} else if (pmode || patime || pmtime)
d497 1
d768 54
a1012 5
	(void)close(*fd);
	*fd = -1;
	if (!tflag)
		return;

d1016 6
a1021 1
	set_ftime(arcn->org_name, arcn->sb.st_mtime, arcn->sb.st_atime, 1);
@


1.39
log
@For directories whose times or mode will be fixed up in the clean-up pass,
record their dev+ino and then use open(O_DIRECTORY)+fstat() to verify that
we're updating the correct directory before using futimens() and fchmod().

ok millert@@
@
text
@d59 4
d472 1
a472 2
		 * before pax exits.  To do that safely, we want the dev+ino
		 * of the directory we created.
d474 17
a490 13
		if (lstat(nm, &sb) < 0) {
			syswarn(0, errno,"Could not access %s (stat)", nm);
		} else if (access(nm, R_OK | W_OK | X_OK) < 0) {
			/*
			 * We have to add rights to the dir, so we make
			 * sure to restore the mode. The mode must be
			 * restored AS CREATED and not as stored if
			 * pmode is not set.
			 */
			set_pmode(nm,
			    ((sb.st_mode & FILEBITS) | S_IRWXU));
			if (!pmode)
				arcn->sb.st_mode = sb.st_mode;
d493 2
a494 3
			 * we have to force the mode to what was set
			 * here, since we changed it from the default
			 * as created.
a495 2
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
d497 1
a497 3
		} else if (pmode || patime || pmtime) {
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
a498 1
		}
a768 55
 * set_attr()
 *	Given a DIRDATA, restore the mode and times as indicated, but
 *	only after verifying that it's the directory that we wanted.
 */
int
set_attr(const struct file_times *ft, int force_times, mode_t mode,
    int do_mode, int in_sig)
{
	struct stat sb;
	int fd, r;

	if (!do_mode && !force_times && !patime && !pmtime)
		return (0);

	/*
	 * We could legitimately go through a symlink here,
	 * so do *not* use O_NOFOLLOW.  The dev+ino check will
	 * protect us from evil.
	 */
	fd = open(ft->ft_name, O_RDONLY | O_DIRECTORY);
	if (fd == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to restore mode and times"
			    " for directory: %s", ft->ft_name);
		return (-1);
	}

	if (fstat(fd, &sb) == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to stat directory: %s",
			    ft->ft_name);
		r = -1;
	} else if (ft->ft_ino != sb.st_ino || ft->ft_dev != sb.st_dev ||
	    !S_ISDIR(mode)) {
		if (!in_sig)
			paxwarn(1, "Directory vanished before restoring"
			    " mode and times: %s", ft->ft_name);
		r = -1;
	} else {
		/* Whew, it's a match!  Is there anything to change? */
		if (do_mode && (mode & ABITS) != (sb.st_mode & ABITS))
			fset_pmode(ft->ft_name, fd, mode);
		if (((force_times || patime) && ft->ft_atime != sb.st_atime) ||
		    ((force_times || pmtime) && ft->ft_mtime != sb.st_mtime))
			fset_ftime(ft->ft_name, fd, ft->ft_mtime,
			    ft->ft_atime, force_times);
		r = 0;
	}
	close(fd);

	return (r);
}


/*
d960 5
d968 1
a968 6
	if (tflag)
		fset_ftime(arcn->org_name, *fd, arcn->sb.st_mtime,
		    arcn->sb.st_atime, 1);

	(void)close(*fd);
	*fd = -1;
@


1.38
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.37 2014/11/23 05:32:20 guenther Exp $	*/
a58 4
#define FILEBITS		(S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
#define SETBITS			(S_ISUID | S_ISGID)
#define ABITS			(FILEBITS | SETBITS)

d468 2
a469 1
		 * before pax exits.
d471 13
a483 17
		if (access(nm, R_OK | W_OK | X_OK) < 0) {
			if (lstat(nm, &sb) < 0) {
				syswarn(0, errno,"Could not access %s (stat)",
				    arcn->name);
				set_pmode(nm,file_mode | S_IRWXU);
			} else {
				/*
				 * We have to add rights to the dir, so we make
				 * sure to restore the mode. The mode must be
				 * restored AS CREATED and not as stored if
				 * pmode is not set.
				 */
				set_pmode(nm,
				    ((sb.st_mode & FILEBITS) | S_IRWXU));
				if (!pmode)
					arcn->sb.st_mode = sb.st_mode;
			}
d486 3
a488 2
			 * we have to force the mode to what was set here,
			 * since we changed it from the default as created.
d490 2
d493 3
a495 1
		} else if (pmode || patime || pmtime)
d497 1
d768 55
a1013 5
	(void)close(*fd);
	*fd = -1;
	if (!tflag)
		return;

d1017 6
a1022 1
	set_ftime(arcn->org_name, arcn->sb.st_mtime, arcn->sb.st_atime, 1);
@


1.37
log
@Use PATH_MAX from <limits.h> instead of MAXPATHLEN from <sys/param.h>
Eliminate a couple unneeded #includes
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.36 2014/07/14 05:58:19 guenther Exp $	*/
d844 1
a844 1
		wcnt = MIN(cnt, *rem);
@


1.36
log
@Delete pointless 'return;' at end of function
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.35 2014/01/14 02:55:09 guenther Exp $	*/
a36 1
#include <sys/param.h>
a38 1
#include <sys/uio.h>
d42 1
d345 1
a345 1
	char target[MAXPATHLEN];
@


1.36.4.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.36 2014/07/14 05:58:19 guenther Exp $	*/
d60 4
a173 1
	int res;
d191 1
a191 12
	res = mk_link(arcn->ln_name, &sb, arcn->name, 0);
	if (res == 0) {
		/* check for a hardlink to a placeholder symlink */
		res = sltab_add_link(arcn->name, &sb);

		if (res < 0) {
			/* arrgh, it failed, clean up */
			unlink(arcn->name);
		}
	}

	return (res);
a294 1
			delete_dir(sb.st_dev, sb.st_ino);
d348 1
a348 1
	int len, defer_pmode = 0;
d408 1
a408 15
			if (arcn->ln_name[0] != '/' &&
			    !has_dotdot(arcn->ln_name))
				res = symlink(arcn->ln_name, nm);
			else {
				/*
				 * absolute symlinks and symlinks with ".."
				 * have to be deferred to prevent the archive
				 * from bootstrapping itself to outside the
				 * working directory.
				 */
				res = sltab_add_sym(nm, arcn->ln_name,
				    arcn->sb.st_mode);
				if (res == 0)
					defer_pmode = 1;
			}
d462 1
a462 1
	if (pmode && !defer_pmode)
d473 1
a473 2
		 * before pax exits.  To do that safely, we want the dev+ino
		 * of the directory we created.
d475 17
a491 13
		if (lstat(nm, &sb) < 0) {
			syswarn(0, errno,"Could not access %s (stat)", nm);
		} else if (access(nm, R_OK | W_OK | X_OK) < 0) {
			/*
			 * We have to add rights to the dir, so we make
			 * sure to restore the mode. The mode must be
			 * restored AS CREATED and not as stored if
			 * pmode is not set.
			 */
			set_pmode(nm,
			    ((sb.st_mode & FILEBITS) | S_IRWXU));
			if (!pmode)
				arcn->sb.st_mode = sb.st_mode;
d494 2
a495 3
			 * we have to force the mode to what was set
			 * here, since we changed it from the default
			 * as created.
a496 2
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
d498 1
a498 3
		} else if (pmode || patime || pmtime) {
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
a499 1
		}
a542 1
		delete_dir(sb.st_dev, sb.st_ino);
a769 54
 * set_attr()
 *	Given a DIRDATA, restore the mode and times as indicated, but
 *	only after verifying that it's the directory that we wanted.
 */
int
set_attr(const struct file_times *ft, int force_times, mode_t mode,
    int do_mode, int in_sig)
{
	struct stat sb;
	int fd, r;

	if (!do_mode && !force_times && !patime && !pmtime)
		return (0);

	/*
	 * We could legitimately go through a symlink here,
	 * so do *not* use O_NOFOLLOW.  The dev+ino check will
	 * protect us from evil.
	 */
	fd = open(ft->ft_name, O_RDONLY | O_DIRECTORY);
	if (fd == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to restore mode and times"
			    " for directory: %s", ft->ft_name);
		return (-1);
	}

	if (fstat(fd, &sb) == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to stat directory: %s",
			    ft->ft_name);
		r = -1;
	} else if (ft->ft_ino != sb.st_ino || ft->ft_dev != sb.st_dev) {
		if (!in_sig)
			paxwarn(1, "Directory vanished before restoring"
			    " mode and times: %s", ft->ft_name);
		r = -1;
	} else {
		/* Whew, it's a match!  Is there anything to change? */
		if (do_mode && (mode & ABITS) != (sb.st_mode & ABITS))
			fset_pmode(ft->ft_name, fd, mode);
		if (((force_times || patime) && ft->ft_atime != sb.st_atime) ||
		    ((force_times || pmtime) && ft->ft_mtime != sb.st_mtime))
			fset_ftime(ft->ft_name, fd, ft->ft_mtime,
			    ft->ft_atime, force_times);
		r = 0;
	}
	close(fd);

	return (r);
}


/*
d961 5
d969 1
a969 6
	if (tflag)
		fset_ftime(arcn->org_name, *fd, arcn->sb.st_mtime,
		    arcn->sb.st_atime, 1);

	(void)close(*fd);
	*fd = -1;
@


1.35
log
@No exception is made for symlinks in the spec, so use
fchmodat(AT_SYMLINK_NOFOLLOW) to set the mode on symlinks, pass
AT_SYMLINK_NOFOLLOW to utimensat(), and then let those be called
on symlinks by dropping the test that skipped them.  Eliminate
set_lids() by changing set_ids() to use fchownat(AT_SYMLINK_NOFOLLOW)
and delete a redundant conditional in each of set_ftime()/fset_ftime().

suggested by espie@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.34 2013/10/08 03:10:36 guenther Exp $	*/
a677 1
	return;
a704 1
	return;
a758 1
	return;
a766 1
	return;
a943 1
	return;
a969 1
	return;
@


1.34
log
@POSIX specifies that when the pax input file requests a hardlink
to a symlinks, that it be exactly that and not a hardlink to the
file pointed to by the symlink.  Use linkat() to get what we want.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.33 2013/04/16 18:06:35 millert Exp $	*/
d451 1
a451 3
		res = ((arcn->type == PAX_SLK) ?
		    set_lids(nm, arcn->sb.st_uid, arcn->sb.st_gid) :
		    set_ids(nm, arcn->sb.st_uid, arcn->sb.st_gid));
a455 6
	 * symlinks are done now.
	 */
	if (arcn->type == PAX_SLK)
		return(0);

	/*
d661 1
a661 1
	if (!frc && (!patime || !pmtime)) {
d675 1
a675 1
	if (utimensat(AT_FDCWD, fnm, tv, 0) < 0)
d690 1
a690 1
	if (!frc && (!patime || !pmtime)) {
d719 1
a719 1
	if (chown(fnm, uid, gid) < 0) {
a750 24
 * set_lids()
 *	set the uid and gid of a file system node
 * Return:
 *	0 when set, -1 on failure
 */

int
set_lids(char *fnm, uid_t uid, gid_t gid)
{
	if (lchown(fnm, uid, gid) < 0) {
		/*
		 * ignore EPERM unless in verbose mode or being run by root.
		 * if running as pax, POSIX requires a warning.
		 */
		if (strcmp(NM_PAX, argv0) == 0 || errno != EPERM || vflag ||
		    geteuid() == 0)
			syswarn(1, errno, "Unable to set file uid/gid of %s",
			    fnm);
		return(-1);
	}
	return(0);
}

/*
d759 1
a759 1
	if (chmod(fnm, mode) < 0)
@


1.33
log
@Use utimensat() and futimens() instead of utimes() and futimes().
This lets us use UTIME_OMIT instead of having to lstat() the file
when we want to preserve one of the times.  Remove casts to long
for tv_sec to prepare for upcoming time_t changes.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.32 2009/12/22 12:08:30 jasper Exp $	*/
d310 1
a310 1
		if (link(to, from) == 0)
@


1.32
log
@- tyop, spotted by Brad Tilley
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.31 2009/10/27 23:59:22 deraadt Exp $	*/
d657 1
a657 3
 *	other ones are left alone. We do not assume the un-documented feature
 *	of many utimes() implementations that consider a 0 time value as a do
 *	not set request.
d663 1
a663 2
	static struct timeval tv[2] = {{0L, 0L}, {0L, 0L}};
	struct stat sb;
d665 4
a668 2
	tv[0].tv_sec = (long)atime;
	tv[1].tv_sec = (long)mtime;
d672 1
a672 1
		 * set. We get the current values of the times if we need them.
d674 4
a677 7
		if (lstat(fnm, &sb) == 0) {
			if (!patime)
				tv[0].tv_sec = (long)sb.st_atime;
			if (!pmtime)
				tv[1].tv_sec = (long)sb.st_mtime;
		} else
			syswarn(0,errno,"Unable to obtain file stats %s", fnm);
d683 1
a683 1
	if (utimes(fnm, tv) < 0)
d692 1
a692 2
	static struct timeval tv[2] = {{0L, 0L}, {0L, 0L}};
	struct stat sb;
d694 4
a697 2
	tv[0].tv_sec = (long)atime;
	tv[1].tv_sec = (long)mtime;
d701 1
a701 1
		 * set. We get the current values of the times if we need them.
d703 4
a706 7
		if (fstat(fd, &sb) == 0) {
			if (!patime)
				tv[0].tv_sec = (long)sb.st_atime;
			if (!pmtime)
				tv[1].tv_sec = (long)sb.st_mtime;
		} else
			syswarn(0,errno,"Unable to obtain file stats %s", fnm);
d711 1
a711 1
	if (futimes(fd, tv) < 0)
@


1.31
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.30 2005/11/09 19:59:06 otto Exp $	*/
d991 1
a991 1
 *	close a file we have beed reading (to copy or archive). If we have to
@


1.30
log
@Compute the sv4cpio "crc" (it's actualy just a checksum) as a 32bit
number. Fixes crc computation on 64 bit archs. From Peter Philipp in PR
4606; looks right fgsch@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.29 2005/04/25 19:39:52 otto Exp $	*/
a35 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)file_subs.c	8.1 (Berkeley) 5/31/93";
#else
static const char rcsid[] = "$OpenBSD: file_subs.c,v 1.29 2005/04/25 19:39:52 otto Exp $";
#endif
#endif /* not lint */
@


1.29
log
@Use the various f* functions to set owner, mode and times, instead
of operating on the path name. Avoids some races. ok deraadt@@ cloder@@
millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.28 2004/11/29 16:23:22 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: file_subs.c,v 1.28 2004/11/29 16:23:22 otto Exp $";
d1040 1
a1040 1
	unsigned long crc = 0L;
@


1.28
log
@Build the table of created directories in-memory, instead of using
a tmp file.  Makes it possible to unpack an archive without using
/tmp, while memory usage is still within every reasonable limit.

"love it" deraadt@@  ok millert@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.27 2004/04/16 22:50:23 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: file_subs.c,v 1.27 2004/04/16 22:50:23 deraadt Exp $";
a142 3
	if (close(fd) < 0)
		syswarn(0, errno, "Unable to close file descriptor on %s",
		    arcn->name);
d150 2
a151 1
		res = set_ids(arcn->name, arcn->sb.st_uid, arcn->sb.st_gid);
d161 1
a161 1
		set_pmode(arcn->name, arcn->sb.st_mode);
d163 5
a167 1
		set_ftime(arcn->name, arcn->sb.st_mtime, arcn->sb.st_atime, 0);
d701 30
d755 17
d806 9
@


1.27
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.26 2004/03/30 16:14:22 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: file_subs.c,v 1.26 2004/03/30 16:14:22 millert Exp $";
d511 1
a511 1
			add_dir(nm, strlen(nm), &(arcn->sb), 1);
d513 1
a513 1
			add_dir(nm, strlen(nm), &(arcn->sb), 0);
d648 1
a648 1
			add_dir(name, spt - name, &sb, 1);
@


1.26
log
@Add support for expanding GNU long links from NetBSD.  I've had this
in my tree for ages but didn't have a proper test case.  Thanks to
otto@@ for providing one.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.25 2003/10/20 06:22:27 jmc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: file_subs.c,v 1.25 2003/10/20 06:22:27 jmc Exp $";
d365 1
a365 1
		switch(arcn->type) {
d597 1
a597 1
	for(;;) {
d1001 1
a1001 1
	for(;;) {
@


1.25
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.24 2003/08/06 21:08:05 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: file_subs.c,v 1.24 2003/08/06 21:08:05 millert Exp $";
d817 1
d876 13
a888 3
		if (fd == -1) {
			/* GNU hack */
			if (gnu_hack_string)
d890 2
a891 2
			gnu_hack_string = malloc(wcnt + 1);
			if (gnu_hack_string == NULL) {
d895 3
a897 2
			memcpy(gnu_hack_string, st, wcnt);
			gnu_hack_string[wcnt] = '\0';
@


1.24
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.23 2003/06/02 23:32:08 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: file_subs.c,v 1.23 2003/06/02 23:32:08 millert Exp $";
d214 1
a214 1
	 * try to make a link to orginal file (-l flag in copy mode). make
d999 1
a999 1
	 * they can create inconsistant archive copies.
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.22 2003/02/03 09:06:43 jmc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: file_subs.c,v 1.22 2003/02/03 09:06:43 jmc Exp $";
d290 1
a290 1
			return(-1);;
@


1.22
log
@typos;
from netbsd(svs+pr@@grep.ru)
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.21 2002/10/18 15:38:11 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: file_subs.c,v 1.21 2002/10/18 15:38:11 millert Exp $";
@


1.21
log
@Pull in some changes from NetBSD
o When extracting GNU tar archives, honor @@LongLink long links/files
o Add an option to prevent pax from prompting for the next volume
  upon premature end of archive.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.20 2002/10/16 19:20:02 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: file_subs.c,v 1.20 2002/10/16 19:20:02 millert Exp $";
d96 1
a96 1
	 * If we find that the open has failed, then spend the effore to
@


1.20
log
@sprinkle const; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.19 2002/10/16 18:40:30 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: file_subs.c,v 1.19 2002/10/16 18:40:30 millert Exp $";
d49 1
a49 1
#include <sys/types.h>
d52 3
a54 2
#include <unistd.h>
#include <sys/param.h>
a55 1
#include <string.h>
a56 2
#include <errno.h>
#include <sys/uio.h>
d58 2
d861 2
a862 1
				if (lseek(fd, (off_t)wcnt, SEEK_CUR) < 0) {
d879 12
a890 1
		if (write(fd, st, wcnt) != wcnt) {
@


1.19
log
@Fix comment typos; most from NetBSD and FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.18 2002/10/16 17:43:10 millert Exp $	*/
d43 1
a43 1
static char sccsid[] = "@@(#)file_subs.c	8.1 (Berkeley) 5/31/93";
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.18 2002/10/16 17:43:10 millert Exp $";
@


1.18
log
@kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.17 2002/02/19 19:39:35 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.17 2002/02/19 19:39:35 millert Exp $";
d91 1
a91 1
	 * assume file doesn't exist, so just try to create it, most times this
d95 2
a96 2
	 * can accidently open the device by mistake (or block waiting to open)
	 * If we find that the open has failed, then figure spend the effore to
d218 3
a220 3
	 * try to make a link to orginal file (-l flag in copy mode). make sure
	 * we do not try to link to directories in case we are running as root
	 * (and it might succeed).
d603 1
a603 1
		 * work foward from the first / and check each part of the path
d644 1
a644 1
		 * make sure the user doen't have some strange umask that
d662 2
a663 2
 *	Set the access time and modification time for a named file. If frc is
 *	non-zero we force these times to be set even if the user did not
d784 1
a784 1
 *	pass over file block boundries. Only write when we hit a non zero
d788 1
a788 1
 *	block boundries significantly reduces the overhead when copying files
@


1.17
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.16 2002/02/16 21:27:07 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.16 2002/02/16 21:27:07 millert Exp $";
d65 1
a65 1
mk_link(register char *,register struct stat *,register char *, int);
d84 1
a84 1
file_creat(register ARCHD *arcn)
d141 1
a141 1
file_close(register ARCHD *arcn, int fd)
d181 1
a181 1
lnk_creat(register ARCHD *arcn)
d215 1
a215 1
cross_lnk(register ARCHD *arcn)
d239 1
a239 1
chk_same(register ARCHD *arcn)
d276 1
a276 2
mk_link(register char *to, register struct stat *to_sb, register char *from,
	int ign)
d348 1
a348 1
node_creat(register ARCHD *arcn)
d350 4
a353 4
	register int res;
	register int ign = 0;
	register int oerrno;
	register int pass = 0;
d538 1
a538 1
unlnk_exist(register char *name, register int type)
d589 1
a589 1
chk_path( register char *name, uid_t st_uid, gid_t st_gid)
d591 1
a591 1
	register char *spt = name;
d814 1
a814 1
file_write(int fd, char *str, register int cnt, int *rem, int *isempt, int sz,
d817 4
a820 4
	register char *pt;
	register char *end;
	register int wcnt;
	register char *st = str;
d926 1
a926 1
rdfile_close(register ARCHD *arcn, register int *fd)
d956 1
a956 1
set_crc(register ARCHD *arcn, register int fd)
d958 2
a959 2
	register int i;
	register int res;
@


1.16
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.15 2001/10/25 16:59:03 niklas Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.15 2001/10/25 16:59:03 niklas Exp $";
a82 1
#ifdef __STDC__
a84 5
#else
int
file_creat(arcn)
	register ARCHD *arcn;
#endif
a139 1
#ifdef __STDC__
a141 6
#else
void
file_close(arcn, fd)
	register ARCHD *arcn;
	int fd;
#endif
a179 1
#ifdef __STDC__
a181 5
#else
int
lnk_creat(arcn)
	register ARCHD *arcn;
#endif
a213 1
#ifdef __STDC__
a215 5
#else
int
cross_lnk(arcn)
	register ARCHD *arcn;
#endif
a237 1
#ifdef __STDC__
a239 5
#else
int
chk_same(arcn)
	register ARCHD *arcn;
#endif
a274 1
#ifdef __STDC__
a277 8
#else
static int
mk_link(to, to_sb, from, ign)
	register char *to;
	register struct stat *to_sb;
	register char *from;
	int ign;
#endif
a347 1
#ifdef __STDC__
a349 5
#else
int
node_creat(arcn)
	register ARCHD *arcn;
#endif
a537 1
#ifdef __STDC__
a539 6
#else
int
unlnk_exist(name, type)
	register char *name;
	register int type;
#endif
a588 1
#ifdef __STDC__
a590 7
#else
int
chk_path(name, st_uid, st_gid)
	register char *name;
	uid_t st_uid;
	gid_t st_gid;
#endif
a672 1
#ifdef __STDC__
a674 8
#else
void
set_ftime(fnm, mtime, atime, frc)
	char *fnm;
	time_t mtime;
	time_t atime;
	int frc;
#endif
a710 1
#ifdef __STDC__
a712 7
#else
int
set_ids(fnm, uid, gid)
	char *fnm;
	uid_t uid;
	gid_t gid;
#endif
a734 1
#ifdef __STDC__
a736 7
#else
int
set_lids(fnm, uid, gid)
	char *fnm;
	uid_t uid;
	gid_t gid;
#endif
a756 1
#ifdef __STDC__
a758 6
#else
void
set_pmode(fnm, mode)
	char *fnm;
	mode_t mode;
#endif
a813 1
#ifdef __STDC__
a816 11
#else
int
file_write(fd, str, cnt, rem, isempt, sz, name)
	int fd;
	char *str;
	register int cnt;
	int *rem;
	int *isempt;
	int sz;
	char *name;
#endif
a894 1
#ifdef __STDC__
a896 7
#else
void
file_flush(fd, fname, isempt)
	int fd;
	char *fname;
	int isempt;
#endif
a925 1
#ifdef __STDC__
a927 6
#else
void
rdfile_close(arcn, fd)
	register ARCHD *arcn;
	register int *fd;
#endif
a955 1
#ifdef __STDC__
a957 6
#else
int
set_crc(arcn, fd)
	register ARCHD *arcn;
	register int fd;
#endif
@


1.15
log
@Make -h and -L follow symlinks on extraction of directories.
This means that existing symbolic links won't get overwritten with a
directory, but instead the directory is created/updated with the privs
from the archive at the end of the symlink chain.  Great for unpacking
OpenBSD release tarballs, where you have linked away stuff due to lack of
space on a certain partition etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.14 2001/05/16 03:04:56 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.14 2001/05/16 03:04:56 mickey Exp $";
d65 1
a65 1
mk_link __P((register char *,register struct stat *,register char *, int));
@


1.14
log
@use proper str*cpy functions instead of home grown one, spaces; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.13 1997/09/01 18:29:48 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.13 1997/09/01 18:29:48 deraadt Exp $";
d403 3
d418 24
a441 1
			res = mkdir(arcn->name, file_mode);
d447 1
a447 1
			res = mknod(arcn->name, file_mode, arcn->sb.st_rdev);
d451 1
a451 1
			res = mknod(arcn->name, file_mode, arcn->sb.st_rdev);
d454 1
a454 1
			res = mkfifo(arcn->name, file_mode);
d462 1
a462 1
			    arcn->name);
d465 1
a465 1
			res = symlink(arcn->ln_name, arcn->name);
d476 1
a476 1
				arcn->name);
d492 1
a492 1
		if ((ign = unlnk_exist(arcn->name, arcn->type)) < 0)
d498 2
a499 2
		if (nodirs || chk_path(arcn->name,arcn->sb.st_uid,arcn->sb.st_gid) < 0) {
			syswarn(1, oerrno, "Could not create: %s", arcn->name);
d509 2
a510 2
		    set_lids(arcn->name, arcn->sb.st_uid, arcn->sb.st_gid) :
		    set_ids(arcn->name, arcn->sb.st_uid, arcn->sb.st_gid));
d528 1
a528 1
		set_pmode(arcn->name, arcn->sb.st_mode);
d540 2
a541 2
		if (access(arcn->name, R_OK | W_OK | X_OK) < 0) {
			if (lstat(arcn->name, &sb) < 0) {
d544 1
a544 1
				set_pmode(arcn->name,file_mode | S_IRWXU);
d552 1
a552 1
				set_pmode(arcn->name,
d562 1
a562 1
			add_dir(arcn->name, arcn->nlen, &(arcn->sb), 1);
d564 1
a564 1
			add_dir(arcn->name, arcn->nlen, &(arcn->sb), 0);
d568 1
a568 1
		set_ftime(arcn->name, arcn->sb.st_mtime, arcn->sb.st_atime, 0);
@


1.13
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.12 1997/07/25 18:58:29 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.12 1997/07/25 18:58:29 mickey Exp $";
d167 1
a167 1
	 * modification times. 
d188 1
a188 1
 *	must exist; 
d274 1
a274 1
	/* 
@


1.12
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.11 1997/06/06 16:03:13 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.11 1997/06/06 16:03:13 millert Exp $";
d585 1
a585 1
				return(1); 
d901 1
a901 1
	
@


1.11
log
@geteuid(2) can never fail.  What was I thinking?
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.10 1997/06/06 05:56:04 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.10 1997/06/06 05:56:04 millert Exp $";
d83 1
a83 1
#if __STDC__
d146 1
a146 1
#if __STDC__
d193 1
a193 1
#if __STDC__
d233 1
a233 1
#if __STDC__
d263 1
a263 1
#if __STDC__
d306 1
a306 1
#if __STDC__
d388 1
a388 1
#if __STDC__
d558 1
a558 1
#if __STDC__
d616 1
a616 1
#if __STDC__
d708 1
a708 1
#if __STDC__
d755 1
a755 1
#if __STDC__
d787 1
a787 1
#if __STDC__
d817 1
a817 1
#if __STDC__
d881 1
a881 1
#if __STDC__
d974 1
a974 1
#if __STDC__
d1013 1
a1013 1
#if __STDC__
d1050 1
a1050 1
#if __STDC__
@


1.10
log
@POSIX says pax must complain about not being able to set permissions
but we don't have to do that in non-pax modes.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.9 1997/06/04 04:56:26 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.9 1997/06/04 04:56:26 millert Exp $";
a768 1
		 * note that errno may get clobbered by geteuid(2).
d773 1
a773 1
			syswarn(1, EPERM, "Unable to set file uid/gid of %s",
a800 1
		 * note that errno may get clobbered by geteuid(2).
d805 1
a805 1
			syswarn(1, EPERM, "Unable to set file uid/gid of %s",
@


1.9
log
@Don't complain about not being able to set uid/gid in "tar -p"
(EPERM) unless the verbose flag is given or the user is root.
Noted by Magnus Holmberg <mho@@stacken.kth.se>.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.8 1997/04/09 01:59:00 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.8 1997/04/09 01:59:00 deraadt Exp $";
d770 1
d772 2
a773 1
		if (errno == EPERM && (vflag || geteuid() == 0))
d803 1
d805 2
a806 1
		if (errno == EPERM && (vflag || geteuid() == 0))
@


1.8
log
@the the
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.7 1997/03/05 05:53:22 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.7 1997/03/05 05:53:22 tholo Exp $";
d767 7
a773 1
		syswarn(1, errno, "Unable to set file uid/gid of %s", fnm);
d798 7
a804 1
		syswarn(1, errno, "Unable to set file uid/gid of %s", fnm);
@


1.7
log
@Add missing #include
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.6 1997/03/04 05:44:49 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.6 1997/03/04 05:44:49 tholo Exp $";
d699 1
a699 1
 *	non-zero we force these times to be set even if the the user did not
@


1.6
log
@Do not post-process directories in cpio mode
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.5 1997/03/02 09:46:45 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.5 1997/03/02 09:46:45 tholo Exp $";
d61 1
@


1.5
log
@More complete cpio(1) emulation
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.4 1997/01/26 10:33:22 downsj Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.4 1997/01/26 10:33:22 downsj Exp $";
d503 1
a503 1
	if (arcn->type == PAX_DIR) {
@


1.4
log
@Support lchown().
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.3 1996/06/23 14:20:33 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.3 1996/06/23 14:20:33 deraadt Exp $";
d129 1
a129 1
		if (chk_path(arcn->name,arcn->sb.st_uid,arcn->sb.st_gid) < 0) {
d363 1
a363 1
		if (chk_path(from, to_sb->st_uid, to_sb->st_gid) == 0)
d471 1
a471 1
		if (chk_path(arcn->name,arcn->sb.st_uid,arcn->sb.st_gid) < 0) {
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.4 1995/03/21 09:07:18 cgd Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: file_subs.c,v 1.4 1995/03/21 09:07:18 cgd Exp $";
d438 1
a438 2
			if ((res = symlink(arcn->ln_name, arcn->name)) == 0)
				return(0);
d481 3
a483 1
		res = set_ids(arcn->name, arcn->sb.st_uid, arcn->sb.st_gid);
d488 6
d766 25
@


1.2
log
@Correct compile warnings
Rename warn() to paxwarn() so <err.h> can be included

Remove #include <ctype.h> when not needed; from FreeBSD
@
text
@d1 1
d45 1
a45 1
static char rcsid[] = "$NetBSD: file_subs.c,v 1.4 1995/03/21 09:07:18 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@a55 1
#include <ctype.h>
d213 1
a213 1
		warn(1, "A hard link to the directory %s is not allowed",
d285 1
a285 1
		warn(1, "Unable to copy %s, file would overwrite itself",
d332 1
a332 1
			warn(1, "Unable to link file %s to itself", to);
d432 1
a432 1
			warn(0,
d448 1
a448 1
			warn(0, "%s has an unknown file type, skipping",
d1048 1
a1048 1
		warn(1, "File changed size %s", arcn->org_name);
d1052 1
a1052 1
		warn(1, "File %s was modified during read", arcn->org_name);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
