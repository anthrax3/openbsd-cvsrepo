head	1.41;
access;
symbols
	OPENBSD_6_2:1.41.0.2
	OPENBSD_6_2_BASE:1.41
	OPENBSD_6_1:1.40.0.4
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.39.0.2
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.38.0.4
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.30.0.8
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.4
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.29.0.12
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.10
	OPENBSD_5_0:1.29.0.8
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.6
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.4
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.8
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.4
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.6
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.4
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.26.0.6
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.4
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.25.0.4
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.9.0.10
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.6
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2017.09.16.07.42.34;	author otto;	state Exp;
branches;
next	1.40;
commitid	UAIch61G0VKbA6po;

1.40
date	2016.08.26.04.17.48;	author guenther;	state Exp;
branches;
next	1.39;
commitid	cze6QIXpFeZ25dJ2;

1.39
date	2016.06.03.23.22.20;	author tedu;	state Exp;
branches;
next	1.38;
commitid	97UrMIkVErmkPRJd;

1.38
date	2015.03.19.05.14.24;	author guenther;	state Exp;
branches;
next	1.37;
commitid	s0WKwITEr5aJPBA2;

1.37
date	2015.03.09.04.23.29;	author guenther;	state Exp;
branches;
next	1.36;
commitid	JMkpovMhu0rmLvCn;

1.36
date	2015.02.21.22.48.23;	author guenther;	state Exp;
branches
	1.36.2.1;
next	1.35;
commitid	AdteqX8nU06lUYnQ;

1.35
date	2015.02.11.23.14.46;	author guenther;	state Exp;
branches;
next	1.34;
commitid	lWdBzWkSKKObQ4Qj;

1.34
date	2015.02.05.22.32.20;	author sthen;	state Exp;
branches;
next	1.33;
commitid	QBujBhAFFXGSsgsF;

1.33
date	2015.02.05.07.49.25;	author guenther;	state Exp;
branches;
next	1.32;
commitid	4roKhm1wyg3vjc8b;

1.32
date	2014.07.11.07.51.48;	author tedu;	state Exp;
branches
	1.32.4.1;
next	1.31;
commitid	amZTt0IVp7KVm6WF;

1.31
date	2014.05.24.18.51.00;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2012.12.04.02.24.45;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2008.05.06.06.54.28;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.26.20.58.25;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.21.21.47.18;	author beck;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.16.22.50.23;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.20.06.22.27;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.13.17.51.14;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.23.32.08;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.16.19.20.02;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.16.18.40.30;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.16.17.43.10;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.26.00.32.21;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.19.15.31.20;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.16.03.04.56;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.09.23.01.00;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.09.17.14.43;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.09.14.04.33;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.07.19.43.10;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.06.09.07.28.41;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.09.01.18.29.49;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.25.18.58.30;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.07.24.23.19.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.06.04.00.15.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.10.27.06.45.11;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.20.34;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.06.41.50;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.17;	author deraadt;	state Exp;
branches;
next	;

1.32.4.1
date	2015.04.30.19.30.57;	author guenther;	state Exp;
branches;
next	;
commitid	tPD1f2vGi43RT0WC;

1.36.2.1
date	2015.04.30.19.28.46;	author guenther;	state Exp;
branches;
next	;
commitid	pbBButXFqiIh89mX;


desc
@@


1.41
log
@Carefully add casts to silence clang sign-compare warnings. ok millert@@
@
text
@/*	$OpenBSD: ftree.c,v 1.40 2016/08/26 04:17:48 guenther Exp $	*/
/*	$NetBSD: ftree.c,v 1.4 1995/03/21 09:07:21 cgd Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <fts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "pax.h"
#include "extern.h"

/*
 * Data structure used to store the file args to be handed to fts().
 * It keeps track of which args generated a "selected" member.
 */
typedef struct ftree {
	char		*fname;		/* file tree name */
	int		refcnt;		/* has tree had a selected file? */
	int		newercnt;	/* skipped due to -u/-D */
	int		chflg;		/* change directory flag */
	struct ftree	*fow;		/* pointer to next entry on list */
} FTREE;


/*
 * routines to interface with the fts library function.
 *
 * file args supplied to pax are stored on a single linked list (of type FTREE)
 * and given to fts to be processed one at a time. pax "selects" files from
 * the expansion of each arg into the corresponding file tree (if the arg is a
 * directory, otherwise the node itself is just passed to pax). The selection
 * is modified by the -n and -u flags. The user is informed when a specific
 * file arg does not generate any selected files. -n keeps expanding the file
 * tree arg until one of its files is selected, then skips to the next file
 * arg. when the user does not supply the file trees as command line args to
 * pax, they are read from stdin
 */

static FTS *ftsp = NULL;		/* current FTS handle */
static int ftsopts;			/* options to be used on fts_open */
static char *farray[2];			/* array for passing each arg to fts */
static FTREE *fthead = NULL;		/* head of linked list of file args */
static FTREE *fttail = NULL;		/* tail of linked list of file args */
static FTREE *ftcur = NULL;		/* current file arg being processed */
static FTSENT *ftent = NULL;		/* current file tree entry */
static int ftree_skip;			/* when set skip to next file arg */

static int ftree_arg(void);
static char *getpathname(char *, int);

/*
 * ftree_start()
 *	initialize the options passed to fts_open() during this run of pax
 *	options are based on the selection of pax options by the user
 *	fts_start() also calls fts_arg() to open the first valid file arg. We
 *	also attempt to reset directory access times when -t (tflag) is set.
 * Return:
 *	0 if there is at least one valid file arg to process, -1 otherwise
 */

int
ftree_start(void)
{
	/*
	 * set up the operation mode of fts, open the first file arg. We must
	 * use FTS_NOCHDIR, as the user may have to open multiple archives and
	 * if fts did a chdir off into the boondocks, we may create an archive
	 * volume in an place where the user did not expect to.
	 */
	ftsopts = FTS_NOCHDIR;

	/*
	 * optional user flags that effect file traversal
	 * -H command line symlink follow only (half follow)
	 * -L follow sylinks (logical)
	 * -P do not follow sylinks (physical). This is the default.
	 * -X do not cross over mount points
	 * -t preserve access times on files read.
	 * -n select only the first member of a file tree when a match is found
	 * -d do not extract subtrees rooted at a directory arg.
	 */
	if (Lflag)
		ftsopts |= FTS_LOGICAL;
	else
		ftsopts |= FTS_PHYSICAL;
	if (Hflag)
		ftsopts |= FTS_COMFOLLOW;
	if (Xflag)
		ftsopts |= FTS_XDEV;

	if ((fthead == NULL) && ((farray[0] = malloc(PAXPATHLEN+2)) == NULL)) {
		paxwarn(1, "Unable to allocate memory for file name buffer");
		return(-1);
	}

	if (ftree_arg() < 0)
		return(-1);
	if (tflag && (atdir_start() < 0))
		return(-1);
	return(0);
}

/*
 * ftree_add()
 *	add the arg to the linked list of files to process. Each will be
 *	processed by fts one at a time
 * Return:
 *	0 if added to the linked list, -1 if failed
 */

int
ftree_add(char *str, int chflg)
{
	FTREE *ft;
	int len;

	/*
	 * simple check for bad args
	 */
	if ((str == NULL) || (*str == '\0')) {
		paxwarn(0, "Invalid file name argument");
		return(-1);
	}

	/*
	 * allocate FTREE node and add to the end of the linked list (args are
	 * processed in the same order they were passed to pax). Get rid of any
	 * trailing / the user may pass us. (watch out for / by itself).
	 */
	if ((ft = malloc(sizeof(FTREE))) == NULL) {
		paxwarn(0, "Unable to allocate memory for filename");
		return(-1);
	}

	if (((len = strlen(str) - 1) > 0) && (str[len] == '/'))
		str[len] = '\0';
	ft->fname = str;
	ft->refcnt = 0;
	ft->newercnt = 0;
	ft->chflg = chflg;
	ft->fow = NULL;
	if (fthead == NULL) {
		fttail = fthead = ft;
		return(0);
	}
	fttail->fow = ft;
	fttail = ft;
	return(0);
}

/*
 * ftree_sel()
 *	this entry has been selected by pax. bump up reference count and handle
 *	-n and -d processing.
 */

void
ftree_sel(ARCHD *arcn)
{
	/*
	 * set reference bit for this pattern. This linked list is only used
	 * when file trees are supplied pax as args. The list is not used when
	 * the trees are read from stdin.
	 */
	if (ftcur != NULL)
		ftcur->refcnt = 1;

	/*
	 * if -n we are done with this arg, force a skip to the next arg when
	 * pax asks for the next file in next_file().
	 * if -d we tell fts only to match the directory (if the arg is a dir)
	 * and not the entire file tree rooted at that point.
	 */
	if (nflag)
		ftree_skip = 1;

	if (!dflag || (arcn->type != PAX_DIR))
		return;

	if (ftent != NULL)
		(void)fts_set(ftsp, ftent, FTS_SKIP);
}

/*
 * ftree_skipped_newer()
 *	file has been skipped because a newer file exists and -u/-D given
 */

void
ftree_skipped_newer(ARCHD *arcn)
{
	/* skipped due to -u/-D, mark accordingly */
	if (ftcur != NULL)
		ftcur->newercnt = 1;
}

/*
 * ftree_chk()
 *	called at end on pax execution. Prints all those file args that did not
 *	have a selected member (reference count still 0)
 */

void
ftree_chk(void)
{
	FTREE *ft;
	int wban = 0;

	/*
	 * make sure all dir access times were reset.
	 */
	if (tflag)
		atdir_end();

	/*
	 * walk down list and check reference count. Print out those members
	 * that never had a match
	 */
	for (ft = fthead; ft != NULL; ft = ft->fow) {
		if ((ft->refcnt > 0) || ft->newercnt > 0 || ft->chflg)
			continue;
		if (wban == 0) {
			paxwarn(1,"WARNING! These file names were not selected:");
			++wban;
		}
		(void)fprintf(stderr, "%s\n", ft->fname);
	}
}

/*
 * ftree_arg()
 *	Get the next file arg for fts to process. Can be from either the linked
 *	list or read from stdin when the user did not them as args to pax. Each
 *	arg is processed until the first successful fts_open().
 * Return:
 *	0 when the next arg is ready to go, -1 if out of file args (or EOF on
 *	stdin).
 */

static int
ftree_arg(void)
{

	/*
	 * close off the current file tree
	 */
	if (ftsp != NULL) {
		(void)fts_close(ftsp);
		ftsp = NULL;
	}

	/*
	 * keep looping until we get a valid file tree to process. Stop when we
	 * reach the end of the list (or get an eof on stdin)
	 */
	for (;;) {
		if (fthead == NULL) {
			/*
			 * the user didn't supply any args, get the file trees
			 * to process from stdin;
			 */
			if (getpathname(farray[0], PAXPATHLEN+1) == NULL)
				return(-1);
		} else {
			/*
			 * the user supplied the file args as arguments to pax
			 */
			if (ftcur == NULL)
				ftcur = fthead;
			else if ((ftcur = ftcur->fow) == NULL)
				return(-1);
			if (ftcur->chflg) {
				/* First fchdir() back... */
				if (fchdir(cwdfd) < 0) {
					syswarn(1, errno,
					  "Can't fchdir to starting directory");
					return(-1);
				}
				if (chdir(ftcur->fname) < 0) {
					syswarn(1, errno, "Can't chdir to %s",
					    ftcur->fname);
					return(-1);
				}
				continue;
			} else
				farray[0] = ftcur->fname;
		}

		/*
		 * watch it, fts wants the file arg stored in a array of char
		 * ptrs, with the last one a null. we use a two element array
		 * and set farray[0] to point at the buffer with the file name
		 * in it. We cannot pass all the file args to fts at one shot
		 * as we need to keep a handle on which file arg generates what
		 * files (the -n and -d flags need this). If the open is
		 * successful, return a 0.
		 */
		if ((ftsp = fts_open(farray, ftsopts, NULL)) != NULL)
			break;
	}
	return(0);
}

/*
 * next_file()
 *	supplies the next file to process in the supplied archd structure.
 * Return:
 *	0 when contents of arcn have been set with the next file, -1 when done.
 */

int
next_file(ARCHD *arcn)
{
	int cnt;

	/*
	 * ftree_sel() might have set the ftree_skip flag if the user has the
	 * -n option and a file was selected from this file arg tree. (-n says
	 * only one member is matched for each pattern) ftree_skip being 1
	 * forces us to go to the next arg now.
	 */
	if (ftree_skip) {
		/*
		 * clear and go to next arg
		 */
		ftree_skip = 0;
		if (ftree_arg() < 0)
			return(-1);
	}

	/*
	 * loop until we get a valid file to process
	 */
	for (;;) {
		if ((ftent = fts_read(ftsp)) == NULL) {
			if (errno)
				syswarn(1, errno, "next_file");
			/*
			 * out of files in this tree, go to next arg, if none
			 * we are done
			 */
			if (ftree_arg() < 0)
				return(-1);
			continue;
		}

		/*
		 * handle each type of fts_read() flag
		 */
		switch (ftent->fts_info) {
		case FTS_D:
		case FTS_DEFAULT:
		case FTS_F:
		case FTS_SL:
		case FTS_SLNONE:
			/*
			 * these are all ok
			 */
			break;
		case FTS_DP:
			/*
			 * already saw this directory. If the user wants file
			 * access times reset, we use this to restore the
			 * access time for this directory since this is the
			 * last time we will see it in this file subtree
			 * remember to force the time (this is -t on a read
			 * directory, not a created directory).
			 */
			if (!tflag)
				continue;
			do_atdir(ftent->fts_path, ftent->fts_statp->st_dev,
			    ftent->fts_statp->st_ino);
			continue;
		case FTS_DC:
			/*
			 * fts claims a file system cycle
			 */
			paxwarn(1,"File system cycle found at %s",ftent->fts_path);
			continue;
		case FTS_DNR:
			syswarn(1, ftent->fts_errno,
			    "Unable to read directory %s", ftent->fts_path);
			continue;
		case FTS_ERR:
			syswarn(1, ftent->fts_errno,
			    "File system traversal error");
			continue;
		case FTS_NS:
		case FTS_NSOK:
			syswarn(1, ftent->fts_errno,
			    "Unable to access %s", ftent->fts_path);
			continue;
		}

		/*
		 * ok got a file tree node to process. copy info into arcn
		 * structure (initialize as required)
		 */
		arcn->skip = 0;
		arcn->pad = 0;
		arcn->ln_nlen = 0;
		arcn->ln_name[0] = '\0';
		memcpy(&arcn->sb, ftent->fts_statp, sizeof(arcn->sb));

		/*
		 * file type based set up and copy into the arcn struct
		 * SIDE NOTE:
		 * we try to reset the access time on all files and directories
		 * we may read when the -t flag is specified. files are reset
		 * when we close them after copying. we reset the directories
		 * when we are done with their file tree (we also clean up at
		 * end in case we cut short a file tree traversal). However
		 * there is no way to reset access times on symlinks.
		 */
		switch (S_IFMT & arcn->sb.st_mode) {
		case S_IFDIR:
			arcn->type = PAX_DIR;
			if (!tflag)
				break;
			add_atdir(ftent->fts_path, arcn->sb.st_dev,
			    arcn->sb.st_ino, &arcn->sb.st_mtim,
			    &arcn->sb.st_atim);
			break;
		case S_IFCHR:
			arcn->type = PAX_CHR;
			break;
		case S_IFBLK:
			arcn->type = PAX_BLK;
			break;
		case S_IFREG:
			/*
			 * only regular files with have data to store on the
			 * archive. all others will store a zero length skip.
			 * the skip field is used by pax for actual data it has
			 * to read (or skip over).
			 */
			arcn->type = PAX_REG;
			arcn->skip = arcn->sb.st_size;
			break;
		case S_IFLNK:
			arcn->type = PAX_SLK;
			/*
			 * have to read the symlink path from the file
			 */
			if ((cnt = readlink(ftent->fts_path, arcn->ln_name,
			    PAXPATHLEN)) < 0) {
				syswarn(1, errno, "Unable to read symlink %s",
				    ftent->fts_path);
				continue;
			}
			/*
			 * set link name length, watch out readlink does not
			 * NUL terminate the link path
			 */
			arcn->ln_name[cnt] = '\0';
			arcn->ln_nlen = cnt;
			break;
		case S_IFSOCK:
			/*
			 * under BSD storing a socket is senseless but we will
			 * let the format specific write function make the
			 * decision of what to do with it.
			 */
			arcn->type = PAX_SCK;
			break;
		case S_IFIFO:
			arcn->type = PAX_FIF;
			break;
		}
		break;
	}

	/*
	 * copy file name, set file name length
	 */
	arcn->nlen = strlcpy(arcn->name, ftent->fts_path, sizeof(arcn->name));
	if ((size_t)arcn->nlen >= sizeof(arcn->name))
		arcn->nlen = sizeof(arcn->name) - 1; /* XXX truncate? */
	arcn->org_name = ftent->fts_path;
	return(0);
}

/*
 * getpathname()
 *	Reads a pathname from stdin, handling NUL- or newline-termination.
 * Return:
 *	NULL at end of file, otherwise the NUL-terminated buffer.
 */

static char *
getpathname(char *buf, int buflen)
{
	char *bp, *ep;
	int ch, term;

	if (zeroflag) {
		/*
		 * Read a NUL-terminated pathname, being especially
		 * paranoid about proper termination and pathname length.
		 */
		for (bp = buf, ep = buf + buflen; bp < ep; bp++) {
			if ((ch = getchar()) == EOF) {
				if (bp != buf)
					paxwarn(1, "Ignoring unterminated "
					    "pathname at EOF");
				return(NULL);
			}
			if ((*bp = ch) == '\0')
				return(buf);
		}
		/* Too long - skip this path */
		*--bp = '\0';
		term = '\0';
	} else {
		if (fgets(buf, buflen, stdin) == NULL)
			return(NULL);
		if ((bp = strchr(buf, '\n')) != NULL || feof(stdin)) {
			if (bp != NULL)
				*bp = '\0';
			return(buf);
		}
		/* Too long - skip this path */
		term = '\n';
	}
	while ((ch = getchar()) != term && ch != EOF)
		continue;
	paxwarn(1, "Ignoring too-long pathname: %s", buf);
	return(NULL);
}
@


1.40
log
@ftree.h is only used by ftree.c; merge it into the .c file
<sys/time.h> is unnecessary; sort #includes
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.39 2016/06/03 23:22:20 tedu Exp $	*/
d514 1
a514 1
	if (arcn->nlen >= sizeof(arcn->name))
@


1.39
log
@new style overlords say to use continue in empty loops.
this is easier to see and self documenting.
ok openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.38 2015/03/19 05:14:24 guenther Exp $	*/
a37 1
#include <sys/time.h>
d39 2
a40 2
#include <unistd.h>
#include <string.h>
a41 1
#include <errno.h>
d43 3
a45 1
#include <fts.h>
a46 1
#include "ftree.h"
d48 13
@


1.38
log
@Use struct timespec internally.  This gives nanosecond precision to pax -rw
and a basis for support of mtime and atime values in pax-format extended
header records.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.37 2015/03/09 04:23:29 guenther Exp $	*/
d551 1
a551 1
		;
@


1.37
log
@Unrevert post-unlock:
* Prevent an archive from esacaping the current directory by itself:
  when extracting a symlink whose value is absolute or contains ".."
  components, just create a zero-length normal file (with additional
  tracking of the mode and hardlinks to the symlink) until everything
  else is extracted, then go back and replace it with the requested
  link (if it's still that zero-length placeholder).

* For tar without -P, if a path in the archive has any ".." components
  then strip everything up to and including the last of them (if
  it ends in ".." then it becomes ".")
  This mostly follows GNU tar's behavior, except for 'tar tf' and
  'tar xvf' we report the modified path that would be/was actually
  created instead of the raw path from the archive

  Above two fixes prompted by a report from Daniel Cegielka
  (daniel.cegielka (at) gmail.com)

* For directories whose times or mode will be fixed up in the
  clean-up pass, record their dev+ino and then use
  open(O_DIRECTORY)+fstat() to verify that we're updating the correct
  directory before using futimens() and fchmod().

* Correct buffer overflow in handling of pax extension headers,
  caught by the memcpy() overlap check.


previously ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.35 2015/02/11 23:14:46 guenther Exp $	*/
d446 2
a447 2
			    arcn->sb.st_ino, arcn->sb.st_mtime,
			    arcn->sb.st_atime);
@


1.36
log
@Recent changes haven't been completely stable, so revert for the 5.7 release

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.32 2014/07/11 07:51:48 tedu Exp $	*/
a339 2
	time_t atime;
	time_t mtime;
d394 1
a394 2
			if (!tflag || (get_atdir(ftent->fts_statp->st_dev,
			    ftent->fts_statp->st_ino, &mtime, &atime) < 0))
d396 2
a397 1
			set_ftime(ftent->fts_path, mtime, atime, 1);
@


1.36.2.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.36 2015/02/21 22:48:23 guenther Exp $	*/
d340 2
d396 2
a397 1
			if (!tflag)
d399 1
a399 2
			do_atdir(ftent->fts_path, ftent->fts_statp->st_dev,
			    ftent->fts_statp->st_ino);
@


1.35
log
@Take II, this time without an incorrect mode test.
For directories whose times or mode will be fixed up in the clean-up pass,
record their dev+ino and then use open(O_DIRECTORY)+fstat() to verify that
we're updating the correct directory before using futimens() and fchmod().

ok sthen@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.34 2015/02/05 22:32:20 sthen Exp $	*/
d340 2
d396 2
a397 1
			if (!tflag)
d399 1
a399 2
			do_atdir(ftent->fts_path, ftent->fts_statp->st_dev,
			    ftent->fts_statp->st_ino);
@


1.34
log
@backout previous for now; issues seen with "tar: Directory vanished before
restoring mode and times: ..." (and an error exit code, which breaks at least
building ports). krw@@ agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.32 2014/07/11 07:51:48 tedu Exp $	*/
a339 2
	time_t atime;
	time_t mtime;
d394 1
a394 2
			if (!tflag || (get_atdir(ftent->fts_statp->st_dev,
			    ftent->fts_statp->st_ino, &mtime, &atime) < 0))
d396 2
a397 1
			set_ftime(ftent->fts_path, mtime, atime, 1);
@


1.33
log
@For directories whose times or mode will be fixed up in the clean-up pass,
record their dev+ino and then use open(O_DIRECTORY)+fstat() to verify that
we're updating the correct directory before using futimens() and fchmod().

ok millert@@
@
text
@d340 2
d396 2
a397 1
			if (!tflag)
d399 1
a399 2
			do_atdir(ftent->fts_path, ftent->fts_statp->st_dev,
			    ftent->fts_statp->st_ino);
@


1.32
log
@clarify a comment about readlink. from Doug Hogan
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.31 2014/05/24 18:51:00 guenther Exp $	*/
a339 2
	time_t atime;
	time_t mtime;
d394 1
a394 2
			if (!tflag || (get_atdir(ftent->fts_statp->st_dev,
			    ftent->fts_statp->st_ino, &mtime, &atime) < 0))
d396 2
a397 1
			set_ftime(ftent->fts_path, mtime, atime, 1);
@


1.32.4.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.32 2014/07/11 07:51:48 tedu Exp $	*/
d340 2
d396 2
a397 1
			if (!tflag)
d399 1
a399 2
			do_atdir(ftent->fts_path, ftent->fts_statp->st_dev,
			    ftent->fts_statp->st_ino);
@


1.31
log
@Delete pointless casts: free() return value to (void), free()'s
argument to (char *), and malloc/calloc's return value to the type
of the variable it's being assigned to.
Convert the one calloc() where the zeroing isn't needed to a reallocarray().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.30 2012/12/04 02:24:45 deraadt Exp $	*/
d480 1
a480 1
			 * always NUL terminate the link path
@


1.30
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.29 2009/10/27 23:59:22 deraadt Exp $	*/
d155 1
a155 1
	if ((ft = (FTREE *)malloc(sizeof(FTREE))) == NULL) {
@


1.29
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.28 2008/05/06 06:54:28 henning Exp $	*/
a39 1
#include <sys/param.h>
@


1.28
log
@when pax is running in -u mode, and no files are beeing updated because
not one changed, we should not exit with an error but zero to indicate
success (matches solaris behaviour).
need to track wether files were skipped because of the -u checks for that
and take that into account later when taking the exit code decision.
ok theo, comments from otto and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.27 2006/12/26 20:58:25 otto Exp $	*/
a35 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)ftree.c	8.2 (Berkeley) 4/18/94";
#else
static const char rcsid[] = "$OpenBSD: ftree.c,v 1.27 2006/12/26 20:58:25 otto Exp $";
#endif
#endif /* not lint */
@


1.27
log
@fts_read returning NULL and errno set is an error. ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.26 2005/04/21 21:47:18 beck Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ftree.c,v 1.26 2005/04/21 21:47:18 beck Exp $";
d173 1
d219 13
d254 1
a254 1
		if ((ft->refcnt > 0) || ft->chflg)
@


1.26
log
@fix strlcpy abuse in pax - this commit turns potential overflows into
potential non-spec compliance - the use of these fields as strings needs
to be revisited more thouroughly.
ok millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.25 2004/04/16 22:50:23 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ftree.c,v 1.25 2004/04/16 22:50:23 deraadt Exp $";
d358 2
@


1.25
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.24 2003/10/20 06:22:27 jmc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ftree.c,v 1.24 2003/10/20 06:22:27 jmc Exp $";
d497 2
@


1.24
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.23 2003/06/13 17:51:14 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ftree.c,v 1.23 2003/06/13 17:51:14 millert Exp $";
d276 1
a276 1
	for(;;) {
d356 1
a356 1
	for(;;) {
d370 1
a370 1
		switch(ftent->fts_info) {
d435 1
a435 1
		switch(S_IFMT & arcn->sb.st_mode) {
@


1.23
log
@Add a -0 flag to make pax use a NUL instead of a newline as the
pathname separator.  Works in list mode as well as read/copy mode.
Based on a patch from David Leonard; closes PR 3310
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.22 2003/06/02 23:32:08 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ftree.c,v 1.22 2003/06/02 23:32:08 millert Exp $";
d73 1
a73 1
static FTS *ftsp = NULL;		/* curent FTS handle */
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.21 2002/10/16 19:20:02 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ftree.c,v 1.21 2002/10/16 19:20:02 millert Exp $";
d83 1
a262 1
	char *pt;
d282 1
a282 1
			if (fgets(farray[0], PAXPATHLEN+1, stdin) == NULL)
a283 2
			if ((pt = strchr(farray[0], '\n')) != NULL)
				*pt = '\0';
d499 48
@


1.21
log
@sprinkle const; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.20 2002/10/16 18:40:30 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ftree.c,v 1.20 2002/10/16 18:40:30 millert Exp $";
@


1.20
log
@Fix comment typos; most from NetBSD and FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.19 2002/10/16 17:43:10 millert Exp $	*/
d43 1
a43 1
static char sccsid[] = "@@(#)ftree.c	8.2 (Berkeley) 4/18/94";
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.19 2002/10/16 17:43:10 millert Exp $";
@


1.19
log
@kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.18 2002/02/19 19:39:35 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.18 2002/02/19 19:39:35 millert Exp $";
d319 1
a319 1
		 * in it. We cannnot pass all the file args to fts at one shot
@


1.18
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.17 2002/02/16 21:27:07 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.17 2002/02/16 21:27:07 millert Exp $";
d149 1
a149 1
ftree_add(register char *str, int chflg)
d151 2
a152 2
	register FTREE *ft;
	register int len;
d194 1
a194 1
ftree_sel(register ARCHD *arcn)
d229 2
a230 2
	register FTREE *ft;
	register int wban = 0;
d266 1
a266 1
	register char *pt;
d338 1
a338 1
next_file(register ARCHD *arcn)
d340 1
a340 1
	register int cnt;
@


1.17
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.16 2001/05/26 00:32:21 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.16 2001/05/26 00:32:21 millert Exp $";
a97 1
#ifdef __STDC__
a99 4
#else
int
ftree_start()
#endif
a147 1
#ifdef __STDC__
a149 6
#else
int
ftree_add(str, chflg)
	register char *str;
	int chflg;
#endif
a192 1
#ifdef __STDC__
a194 5
#else
void
ftree_sel(arcn)
	register ARCHD *arcn;
#endif
a225 1
#ifdef __STDC__
a227 4
#else
void
ftree_chk()
#endif
a262 1
#ifdef __STDC__
a264 4
#else
static int
ftree_arg()
#endif
a336 1
#ifdef __STDC__
a338 5
#else
int
next_file(arcn)
	register ARCHD *arcn;
#endif
@


1.16
log
@Get rid of NET2_FTS and NET2_REGEX #ifdefs since they are useless.
Change NET2_STAT into LONG_OFF_T for portability to systems with
a 32bit off_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.15 2001/05/19 15:31:20 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.15 2001/05/19 15:31:20 millert Exp $";
d86 1
a86 1
static int ftree_arg __P((void));
@


1.15
log
@Use an explicit memcpy() to copy a stat struct.  Fixes a mysterious
Memory fault on my hp300 boxes.  This is more than a little worrisome
(and it doesn't show up on i386).  The problem may actually be related
to struct alignment and the recent fts struct changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.14 2001/05/16 03:04:56 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.14 2001/05/16 03:04:56 mickey Exp $";
a128 3
#	ifdef NET2_FTS
		paxwarn(0, "The -H flag is not supported on this version");
#	else
a129 1
#	endif
a428 4
#			ifdef NET2_FTS
			if (!tflag || (get_atdir(ftent->fts_statb.st_dev,
			    ftent->fts_statb.st_ino, &mtime, &atime) < 0))
#			else
a430 1
#			endif
a440 3
#			ifdef NET2_FTS
			syswarn(1, errno,
#			else
a441 1
#			endif
a444 3
#			ifdef NET2_FTS
			syswarn(1, errno,
#			else
a445 1
#			endif
a449 3
#			ifdef NET2_FTS
			syswarn(1, errno,
#			else
a450 1
#			endif
a462 3
#		ifdef NET2_FTS
		arcn->sb = ftent->fts_statb;
#		else
a463 1
#		endif
@


1.14
log
@use proper str*cpy functions instead of home grown one, spaces; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.13 2001/02/09 23:01:00 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.13 2001/02/09 23:01:00 millert Exp $";
d487 1
a487 1
		arcn->sb = *(ftent->fts_statp);
@


1.13
log
@another typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.12 2001/02/09 17:14:43 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.12 2001/02/09 17:14:43 millert Exp $";
d316 1
a316 1
			 * to process from stdin; 
d385 1
a385 1
	 * only one member is matched for each pattern) ftree_skip being 1 
d561 1
a561 2
	arcn->nlen = l_strncpy(arcn->name, ftent->fts_path, sizeof(arcn->name) - 1);
	arcn->name[arcn->nlen] = '\0';
@


1.12
log
@no need to revert a change that just fixed a typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.10 2001/02/07 19:43:10 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.10 2001/02/07 19:43:10 millert Exp $";
d324 1
a324 1
			 * the user supplied the file args as arguements to pax
@


1.11
log
@Revert broken fix, until a correct fix is written.
Breaking all ports like that is not acceptable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.9 1998/06/09 07:28:41 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.9 1998/06/09 07:28:41 deraadt Exp $";
d174 1
a174 1
		paxwarn(0, "Invalid file name arguement");
@


1.10
log
@Fix -T option and add support for -C option in the file pointed to
by -T ala GNU tar.
Based on a patch from woods@@proven.weird.com; Closes PR #1664
@
text
@d174 1
a174 1
		paxwarn(0, "Invalid file name argument");
@


1.9
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.8 1997/09/01 18:29:49 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.8 1997/09/01 18:29:49 deraadt Exp $";
d174 1
a174 1
		paxwarn(0, "Invalid file name arguement");
@


1.8
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.7 1997/07/25 18:58:30 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.7 1997/07/25 18:58:30 mickey Exp $";
d538 1
a538 1
			 * allways null terminate the link path
@


1.7
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.6 1997/07/24 23:19:19 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.6 1997/07/24 23:19:19 millert Exp $";
d223 1
a223 1
	if (ftcur != NULL) 
@


1.6
log
@Stash fd of cwd instead of using getcwd() to stash path.
This works in cases where the parent dir is not readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.5 1997/06/04 00:15:16 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.5 1997/06/04 00:15:16 millert Exp $";
d98 1
a98 1
#if __STDC__
d157 1
a157 1
#if __STDC__
d209 1
a209 1
#if __STDC__
d248 1
a248 1
#if __STDC__
d290 1
a290 1
#if __STDC__
d369 1
a369 1
#if __STDC__
@


1.5
log
@Fix usage of l_strncpy() (noticed by Theo) and make l_strncpy()
pad with NULL's like strncpy(3).  This eliminates the need for
zf_strncpy(); ocurrences of zf_strncpy() have been changed to l_strncpy().
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.4 1996/10/27 06:45:11 downsj Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.4 1996/10/27 06:45:11 downsj Exp $";
d331 4
a334 4
				/* First chdir() back... */
				if (chdir(cwdpt) < 0) {
					syswarn(1, errno, "Can't chdir to %s",
					    cwdpt);
@


1.4
log
@Initial cut -C support in paxtar.  Exceeds GNU tar by quite a bit.
General pax still seems to work ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.3 1996/06/23 14:20:34 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.3 1996/06/23 14:20:34 deraadt Exp $";
d561 1
a561 1
	arcn->nlen = l_strncpy(arcn->name, ftent->fts_path, PAXPATHLEN+1);
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.4 1995/03/21 09:07:21 cgd Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ftree.c,v 1.4 1995/03/21 09:07:21 cgd Exp $";
d159 1
a159 1
ftree_add(register char *str)
d162 1
a162 1
ftree_add(str)
d164 1
d192 1
d270 1
a270 1
		if (ft->refcnt > 0)
d330 15
a344 1
			farray[0] = ftcur->fname;
@


1.2
log
@Correct compile warnings
Rename warn() to paxwarn() so <err.h> can be included

Remove #include <ctype.h> when not needed; from FreeBSD
@
text
@d1 1
d45 1
a45 1
static char rcsid[] = "$NetBSD: ftree.c,v 1.4 1995/03/21 09:07:21 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@a54 1
#include <ctype.h>
d129 1
a129 1
		warn(0, "The -H flag is not supported on this version");
d137 1
a137 1
		warn(1, "Unable to allocate memory for file name buffer");
d172 1
a172 1
		warn(0, "Invalid file name arguement");
d182 1
a182 1
		warn(0, "Unable to allocate memory for filename");
d270 1
a270 1
			warn(1,"WARNING! These file names were not selected:");
d430 1
a430 1
			warn(1,"File system cycle found at %s",ftent->fts_path);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
