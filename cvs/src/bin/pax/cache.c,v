head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.6
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.4
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.21.0.10
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.6
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.8
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.8
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.4
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.17.0.26
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.22
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.20
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.18
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.16
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.14
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.12
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.10
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.8
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.7.0.10
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.08.26.04.08.18;	author guenther;	state Exp;
branches;
next	1.22;
commitid	2jovnioaPGqqWYYZ;

1.22
date	2016.08.25.01.44.55;	author guenther;	state Exp;
branches;
next	1.21;
commitid	udvMiyfPVZQYw9Ht;

1.21
date	2014.05.24.18.51.00;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2012.12.04.02.24.45;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.22.12.09.36;	author jasper;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.16.03.28.34;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.20.06.22.27;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.08.01.39.52;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.32.08;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.10.03.50.13;	author david;	state Exp;
branches;
next	1.12;

1.12
date	2002.10.16.19.20.02;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.16.17.43.10;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.26.14.19.33;	author lebel;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.26.00.32.21;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.04.08.03.50.58;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.18.58.27;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.06.03.11.03.03;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.09.15.22.34.06;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.20.30;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.06.41.48;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.16;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@cache.h is only used by cache.c; merge it into the .c file
<unistd.h> and <sys/time.h> are unneeded here

ok by general acclaim
@
text
@/*	$OpenBSD: cache.c,v 1.22 2016/08/25 01:44:55 guenther Exp $	*/
/*	$NetBSD: cache.c,v 1.4 1995/03/21 09:07:10 cgd Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <grp.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pax.h"
#include "extern.h"

/*
 * Constants and data structures used to implement group and password file
 * caches. Traditional passwd/group cache routines perform quite poorly with
 * archives. The chances of hitting a valid lookup with an archive is quite a
 * bit worse than with files already resident on the file system. These misses
 * create a MAJOR performance cost. To address this problem, these routines
 * cache both hits and misses.
 *
 * NOTE:  name lengths must be as large as those stored in ANY PROTOCOL and
 * as stored in the passwd and group files. CACHE SIZES MUST BE PRIME
 */
#define UNMLEN		32	/* >= user name found in any protocol */
#define GNMLEN		32	/* >= group name found in any protocol */
#define UNM_SZ		317	/* size of uid_name() cache */
#define GNM_SZ		317	/* size of gid_name() cache */
#define VALID		1	/* entry and name are valid */
#define INVALID		2	/* entry valid, name NOT valid */

/*
 * Node structures used in the user, group, uid, and gid caches.
 */

typedef struct uidc {
	int valid;		/* is this a valid or a miss entry */
	char name[UNMLEN];	/* uid name */
	uid_t uid;		/* cached uid */
} UIDC;

typedef struct gidc {
	int valid;		/* is this a valid or a miss entry */
	char name[GNMLEN];	/* gid name */
	gid_t gid;		/* cached gid */
} GIDC;


/*
 * routines that control user, group, uid and gid caches (for the archive
 * member print routine).
 * IMPORTANT:
 * these routines cache BOTH hits and misses, a major performance improvement
 */

static	int pwopn = 0;		/* is password file open */
static	int gropn = 0;		/* is group file open */
static UIDC **usrtb = NULL;	/* user name to uid cache */
static GIDC **grptb = NULL;	/* group name to gid cache */

/*
 * usrtb_start
 *	creates an empty usrtb
 * Return:
 *	0 if ok, -1 otherwise
 */

int
usrtb_start(void)
{
	static int fail = 0;

	if (usrtb != NULL)
		return(0);
	if (fail)
		return(-1);
	if ((usrtb = calloc(UNM_SZ, sizeof(UIDC *))) == NULL) {
		++fail;
		paxwarn(1, "Unable to allocate memory for user name cache table");
		return(-1);
	}
	return(0);
}

/*
 * grptb_start
 *	creates an empty grptb
 * Return:
 *	0 if ok, -1 otherwise
 */

int
grptb_start(void)
{
	static int fail = 0;

	if (grptb != NULL)
		return(0);
	if (fail)
		return(-1);
	if ((grptb = calloc(GNM_SZ, sizeof(GIDC *))) == NULL) {
		++fail;
		paxwarn(1,"Unable to allocate memory for group name cache table");
		return(-1);
	}
	return(0);
}

/*
 * uid_name()
 *	caches the uid for a given user name. We use a simple hash table.
 * Return
 *	the uid (if any) for a user name, or a -1 if no match can be found
 */

int
uid_name(char *name, uid_t *uid)
{
	struct passwd *pw;
	UIDC *ptr;
	int namelen;

	/*
	 * return -1 for mangled names
	 */
	if (((namelen = strlen(name)) == 0) || (name[0] == '\0'))
		return(-1);
	if ((usrtb == NULL) && (usrtb_start() < 0))
		return(-1);

	/*
	 * look up in hash table, if found and valid return the uid,
	 * if found and invalid, return a -1
	 */
	ptr = usrtb[st_hash(name, namelen, UNM_SZ)];
	if ((ptr != NULL) && (ptr->valid > 0) && !strcmp(name, ptr->name)) {
		if (ptr->valid == INVALID)
			return(-1);
		*uid = ptr->uid;
		return(0);
	}

	if (!pwopn) {
		setpassent(1);
		++pwopn;
	}

	if (ptr == NULL)
		ptr = usrtb[st_hash(name, namelen, UNM_SZ)] =
		  malloc(sizeof(UIDC));

	/*
	 * no match, look it up, if no match store it as an invalid entry,
	 * or store the matching uid
	 */
	if (ptr == NULL) {
		if ((pw = getpwnam(name)) == NULL)
			return(-1);
		*uid = pw->pw_uid;
		return(0);
	}
	(void)strlcpy(ptr->name, name, sizeof(ptr->name));
	if ((pw = getpwnam(name)) == NULL) {
		ptr->valid = INVALID;
		return(-1);
	}
	ptr->valid = VALID;
	*uid = ptr->uid = pw->pw_uid;
	return(0);
}

/*
 * gid_name()
 *	caches the gid for a given group name. We use a simple hash table.
 * Return
 *	the gid (if any) for a group name, or a -1 if no match can be found
 */

int
gid_name(char *name, gid_t *gid)
{
	struct group *gr;
	GIDC *ptr;
	int namelen;

	/*
	 * return -1 for mangled names
	 */
	if (((namelen = strlen(name)) == 0) || (name[0] == '\0'))
		return(-1);
	if ((grptb == NULL) && (grptb_start() < 0))
		return(-1);

	/*
	 * look up in hash table, if found and valid return the uid,
	 * if found and invalid, return a -1
	 */
	ptr = grptb[st_hash(name, namelen, GNM_SZ)];
	if ((ptr != NULL) && (ptr->valid > 0) && !strcmp(name, ptr->name)) {
		if (ptr->valid == INVALID)
			return(-1);
		*gid = ptr->gid;
		return(0);
	}

	if (!gropn) {
		setgroupent(1);
		++gropn;
	}
	if (ptr == NULL)
		ptr = grptb[st_hash(name, namelen, GNM_SZ)] =
		  malloc(sizeof(GIDC));

	/*
	 * no match, look it up, if no match store it as an invalid entry,
	 * or store the matching gid
	 */
	if (ptr == NULL) {
		if ((gr = getgrnam(name)) == NULL)
			return(-1);
		*gid = gr->gr_gid;
		return(0);
	}

	(void)strlcpy(ptr->name, name, sizeof(ptr->name));
	if ((gr = getgrnam(name)) == NULL) {
		ptr->valid = INVALID;
		return(-1);
	}
	ptr->valid = VALID;
	*gid = ptr->gid = gr->gr_gid;
	return(0);
}
@


1.22
log
@Replace name_{uid,gid}() with the libc routines user_from_uid() and
group_from_gid().  Eliminate some superfluous strncpy() calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.21 2014/05/24 18:51:00 guenther Exp $	*/
a37 1
#include <sys/time.h>
d39 2
a40 1
#include <string.h>
a41 3
#include <pwd.h>
#include <grp.h>
#include <unistd.h>
d43 2
a45 1
#include "cache.h"
d47 35
@


1.21
log
@Delete pointless casts: free() return value to (void), free()'s
argument to (char *), and malloc/calloc's return value to the type
of the variable it's being assigned to.
Convert the one calloc() where the zeroing isn't needed to a reallocarray().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.20 2012/12/04 02:24:45 deraadt Exp $	*/
a58 2
static UIDC **uidtb = NULL;	/* uid to name cache */
static GIDC **gidtb = NULL;	/* gid to name cache */
a62 48
 * uidtb_start
 *	creates an empty uidtb
 * Return:
 *	0 if ok, -1 otherwise
 */

int
uidtb_start(void)
{
	static int fail = 0;

	if (uidtb != NULL)
		return(0);
	if (fail)
		return(-1);
	if ((uidtb = calloc(UID_SZ, sizeof(UIDC *))) == NULL) {
		++fail;
		paxwarn(1, "Unable to allocate memory for user id cache table");
		return(-1);
	}
	return(0);
}

/*
 * gidtb_start
 *	creates an empty gidtb
 * Return:
 *	0 if ok, -1 otherwise
 */

int
gidtb_start(void)
{
	static int fail = 0;

	if (gidtb != NULL)
		return(0);
	if (fail)
		return(-1);
	if ((gidtb = calloc(GID_SZ, sizeof(GIDC *))) == NULL) {
		++fail;
		paxwarn(1, "Unable to allocate memory for group id cache table");
		return(-1);
	}
	return(0);
}

/*
a110 132
 * name_uid()
 *	caches the name (if any) for the uid. If frc set, we always return the
 *	the stored name (if valid or invalid match). We use a simple hash table.
 * Return
 *	Pointer to stored name (or a empty string)
 */

char *
name_uid(uid_t uid, int frc)
{
	struct passwd *pw;
	UIDC *ptr;

	if ((uidtb == NULL) && (uidtb_start() < 0))
		return("");

	/*
	 * see if we have this uid cached
	 */
	ptr = uidtb[uid % UID_SZ];
	if ((ptr != NULL) && (ptr->valid > 0) && (ptr->uid == uid)) {
		/*
		 * have an entry for this uid
		 */
		if (frc || (ptr->valid == VALID))
			return(ptr->name);
		return("");
	}

	/*
	 * No entry for this uid, we will add it
	 */
	if (!pwopn) {
		setpassent(1);
		++pwopn;
	}
	if (ptr == NULL)
		ptr = uidtb[uid % UID_SZ] = malloc(sizeof(UIDC));

	if ((pw = getpwuid(uid)) == NULL) {
		/*
		 * no match for this uid in the local password file
		 * a string that is the uid in numeric format
		 */
		if (ptr == NULL)
			return("");
		ptr->uid = uid;
		ptr->valid = INVALID;
		(void)snprintf(ptr->name, sizeof(ptr->name), "%lu",
			       (unsigned long)uid);
		if (frc == 0)
			return("");
	} else {
		/*
		 * there is an entry for this uid in the password file
		 */
		if (ptr == NULL)
			return(pw->pw_name);
		ptr->uid = uid;
		(void)strlcpy(ptr->name, pw->pw_name, sizeof(ptr->name));
		ptr->valid = VALID;
	}
	return(ptr->name);
}

/*
 * name_gid()
 *	caches the name (if any) for the gid. If frc set, we always return the
 *	the stored name (if valid or invalid match). We use a simple hash table.
 * Return
 *	Pointer to stored name (or a empty string)
 */

char *
name_gid(gid_t gid, int frc)
{
	struct group *gr;
	GIDC *ptr;

	if ((gidtb == NULL) && (gidtb_start() < 0))
		return("");

	/*
	 * see if we have this gid cached
	 */
	ptr = gidtb[gid % GID_SZ];
	if ((ptr != NULL) && (ptr->valid > 0) && (ptr->gid == gid)) {
		/*
		 * have an entry for this gid
		 */
		if (frc || (ptr->valid == VALID))
			return(ptr->name);
		return("");
	}

	/*
	 * No entry for this gid, we will add it
	 */
	if (!gropn) {
		setgroupent(1);
		++gropn;
	}
	if (ptr == NULL)
		ptr = gidtb[gid % GID_SZ] = malloc(sizeof(GIDC));

	if ((gr = getgrgid(gid)) == NULL) {
		/*
		 * no match for this gid in the local group file, put in
		 * a string that is the gid in numeric format
		 */
		if (ptr == NULL)
			return("");
		ptr->gid = gid;
		ptr->valid = INVALID;
		(void)snprintf(ptr->name, sizeof(ptr->name), "%lu",
			       (unsigned long)gid);
		if (frc == 0)
			return("");
	} else {
		/*
		 * there is an entry for this group in the group file
		 */
		if (ptr == NULL)
			return(gr->gr_name);
		ptr->gid = gid;
		(void)strlcpy(ptr->name, gr->gr_name, sizeof(ptr->name));
		ptr->valid = VALID;
	}
	return(ptr->name);
}

/*
d199 1
a199 1
	ptr = grptb[st_hash(name, namelen, GID_SZ)];
d212 1
a212 1
		ptr = grptb[st_hash(name, namelen, GID_SZ)] =
@


1.20
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.19 2009/12/22 12:09:36 jasper Exp $	*/
d80 1
a80 1
	if ((uidtb = (UIDC **)calloc(UID_SZ, sizeof(UIDC *))) == NULL) {
d104 1
a104 1
	if ((gidtb = (GIDC **)calloc(GID_SZ, sizeof(GIDC *))) == NULL) {
d128 1
a128 1
	if ((usrtb = (UIDC **)calloc(UNM_SZ, sizeof(UIDC *))) == NULL) {
d152 1
a152 1
	if ((grptb = (GIDC **)calloc(GNM_SZ, sizeof(GIDC *))) == NULL) {
d333 1
a333 1
		  (UIDC *)malloc(sizeof(UIDC));
d395 1
a395 1
		  (GIDC *)malloc(sizeof(GIDC));
@


1.19
log
@- two more typo's spotted by Brad Tilley
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.18 2009/10/27 23:59:22 deraadt Exp $	*/
a39 1
#include <sys/param.h>
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.17 2004/03/16 03:28:34 tedu Exp $	*/
d270 1
a270 1
		 * a string that is the gid in numberic format
@


1.17
log
@actually use the cache instead of throwing away memory.  doh!
from Rodney Ruddock  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.16 2003/10/20 06:22:27 jmc Exp $	*/
a35 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)cache.c	8.1 (Berkeley) 5/31/93";
#else
static const char rcsid[] = "$OpenBSD: cache.c,v 1.16 2003/10/20 06:22:27 jmc Exp $";
#endif
#endif /* not lint */
@


1.16
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.15 2003/08/08 01:39:52 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: cache.c,v 1.15 2003/08/08 01:39:52 millert Exp $";
d207 1
a207 1
		ptr = (UIDC *)malloc(sizeof(UIDC));
d273 1
a273 1
		ptr = (GIDC *)malloc(sizeof(GIDC));
@


1.15
log
@use sizeof with strlcpy() when possible; it is less error prone.
From Patrick Latifi; ok avsm@@ and krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.14 2003/06/02 23:32:08 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: cache.c,v 1.14 2003/06/02 23:32:08 millert Exp $";
d212 1
a212 1
		 * a string that is the uid in numberic format
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.13 2003/03/10 03:50:13 david Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: cache.c,v 1.13 2003/03/10 03:50:13 david Exp $";
d229 1
a229 1
		(void)strlcpy(ptr->name, pw->pw_name, UNMLEN);
d295 1
a295 1
		(void)strlcpy(ptr->name, gr->gr_name, GNMLEN);
d354 1
a354 1
	(void)strlcpy(ptr->name, name, UNMLEN);
d417 1
a417 1
	(void)strlcpy(ptr->name, name, GNMLEN);
@


1.13
log
@double words in comments
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.12 2002/10/16 19:20:02 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: cache.c,v 1.12 2002/10/16 19:20:02 millert Exp $";
@


1.12
log
@sprinkle const; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.11 2002/10/16 17:43:10 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: cache.c,v 1.11 2002/10/16 17:43:10 millert Exp $";
d79 1
a79 1
 *	creates an an empty uidtb
d103 1
a103 1
 *	creates an an empty gidtb
d127 1
a127 1
 *	creates an an empty usrtb
d151 1
a151 1
 *	creates an an empty grptb
@


1.11
log
@kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.10 2002/02/19 19:39:35 millert Exp $	*/
d43 1
a43 1
static char sccsid[] = "@@(#)cache.c	8.1 (Berkeley) 5/31/93";
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cache.c,v 1.10 2002/02/19 19:39:35 millert Exp $";
@


1.10
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.9 2001/06/26 14:19:33 lebel Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cache.c,v 1.9 2001/06/26 14:19:33 lebel Exp $";
d184 2
a185 2
	register struct passwd *pw;
	register UIDC *ptr;
d250 2
a251 2
	register struct group *gr;
	register GIDC *ptr;
d315 3
a317 3
	register struct passwd *pw;
	register UIDC *ptr;
	register int namelen;
d378 3
a380 3
	register struct group *gr;
	register GIDC *ptr;
	register int namelen;
@


1.9
log
@use strlcpy vs strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.8 2001/05/26 00:32:21 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cache.c,v 1.8 2001/05/26 00:32:21 millert Exp $";
a83 1
#ifdef __STDC__
a85 4
#else
int
uidtb_start()
#endif
a107 1
#ifdef __STDC__
a109 4
#else
int
gidtb_start()
#endif
a131 1
#ifdef __STDC__
a133 4
#else
int
usrtb_start()
#endif
a155 1
#ifdef __STDC__
a157 4
#else
int
grptb_start()
#endif
a180 1
#ifdef __STDC__
a182 6
#else
char *
name_uid(uid, frc)
	uid_t uid;
	int frc;
#endif
a246 1
#ifdef __STDC__
a248 6
#else
char *
name_gid(gid, frc)
	gid_t gid;
	int frc;
#endif
a311 1
#ifdef __STDC__
a313 6
#else
int
uid_name(name, uid)
	char *name;
	uid_t *uid;
#endif
a374 1
#ifdef __STDC__
a376 6
#else
int
gid_name(name, gid)
	char *name;
	gid_t *gid;
#endif
@


1.8
log
@Get rid of NET2_FTS and NET2_REGEX #ifdefs since they are useless.
Change NET2_STAT into LONG_OFF_T for portability to systems with
a 32bit off_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.7 1999/04/08 03:50:58 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cache.c,v 1.7 1999/04/08 03:50:58 deraadt Exp $";
d260 1
a260 2
		(void)strncpy(ptr->name, pw->pw_name, UNMLEN-1);
		ptr->name[UNMLEN-1] = '\0';
d333 1
a333 2
		(void)strncpy(ptr->name, gr->gr_name, GNMLEN-1);
		ptr->name[GNMLEN-1] = '\0';
d399 1
a399 2
	(void)strncpy(ptr->name, name, UNMLEN-1);
	ptr->name[UNMLEN-1] = '\0';
d469 1
a469 2
	(void)strncpy(ptr->name, name, GNMLEN-1);
	ptr->name[GNMLEN-1] = '\0';
@


1.7
log
@memory leak fix; niklas
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.6 1997/07/25 18:58:27 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cache.c,v 1.6 1997/07/25 18:58:27 mickey Exp $";
a248 3
#		ifdef NET2_STAT
		(void)snprintf(ptr->name, sizeof(ptr->name), "%u", uid);
#		else
a250 1
#		endif
a322 3
#		ifdef NET2_STAT
		(void)snprintf(ptr->name, sizeof(ptr->name), "%u", gid);
#		else
a324 1
#		endif
@


1.6
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.5 1997/06/03 11:03:03 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cache.c,v 1.5 1997/06/03 11:03:03 deraadt Exp $";
d396 2
a397 1
		ptr = (UIDC *)malloc(sizeof(UIDC));
d466 2
a467 1
		ptr = (GIDC *)malloc(sizeof(GIDC));
@


1.5
log
@less strncpy; charnier@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.4 1996/09/15 22:34:06 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cache.c,v 1.4 1996/09/15 22:34:06 millert Exp $";
d84 1
a84 1
#if __STDC__
d113 1
a113 1
#if __STDC__
d142 1
a142 1
#if __STDC__
d171 1
a171 1
#if __STDC__
d201 1
a201 1
#if __STDC__
d279 1
a279 1
#if __STDC__
d356 1
a356 1
#if __STDC__
d426 1
a426 1
#if __STDC__
@


1.4
log
@sprintf -> snprintf paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.3 1996/06/23 14:20:30 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cache.c,v 1.3 1996/06/23 14:20:30 deraadt Exp $";
d264 1
a264 1
		(void)strncpy(ptr->name, pw->pw_name, UNMLEN);
d342 1
a342 1
		(void)strncpy(ptr->name, gr->gr_name, GNMLEN);
d408 1
a408 1
	(void)strncpy(ptr->name, name, UNMLEN);
d478 1
a478 1
	(void)strncpy(ptr->name, name, GNMLEN);
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: cache.c,v 1.4 1995/03/21 09:07:10 cgd Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cache.c,v 1.4 1995/03/21 09:07:10 cgd Exp $";
d250 1
a250 1
		(void)sprintf(ptr->name, "%u", uid);
d252 2
a253 1
		(void)sprintf(ptr->name, "%lu", (unsigned long)uid);
d328 1
a328 1
		(void)sprintf(ptr->name, "%u", gid);
d330 2
a331 1
		(void)sprintf(ptr->name, "%lu", (unsigned long)gid);
@


1.2
log
@Correct compile warnings
Rename warn() to paxwarn() so <err.h> can be included

Remove #include <ctype.h> when not needed; from FreeBSD
@
text
@d1 1
d45 1
a45 1
static char rcsid[] = "$NetBSD: cache.c,v 1.4 1995/03/21 09:07:10 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@a53 1
#include <ctype.h>
d99 1
a99 1
		warn(1, "Unable to allocate memory for user id cache table");
d128 1
a128 1
		warn(1, "Unable to allocate memory for group id cache table");
d157 1
a157 1
		warn(1, "Unable to allocate memory for user name cache table");
d186 1
a186 1
		warn(1,"Unable to allocate memory for group name cache table");
d251 1
a251 1
		(void)sprintf(ptr->name, "%lu", uid);
d328 1
a328 1
		(void)sprintf(ptr->name, "%lu", gid);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
