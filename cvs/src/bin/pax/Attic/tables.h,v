head	1.17;
access;
symbols
	OPENBSD_6_0:1.16.0.6
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.8.0.36
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.34
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.30
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.28
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.26
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.24
	OPENBSD_5_0:1.8.0.22
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.20
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.18
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.14
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.16
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.12
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.6
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.4
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.08.26.04.23.44;	author guenther;	state dead;
branches;
next	1.16;
commitid	uyIncXAC8ztQtHa0;

1.16
date	2015.03.19.05.14.24;	author guenther;	state Exp;
branches;
next	1.15;
commitid	s0WKwITEr5aJPBA2;

1.15
date	2015.03.09.04.23.29;	author guenther;	state Exp;
branches;
next	1.14;
commitid	JMkpovMhu0rmLvCn;

1.14
date	2015.02.21.22.48.23;	author guenther;	state Exp;
branches
	1.14.2.1;
next	1.13;
commitid	AdteqX8nU06lUYnQ;

1.13
date	2015.02.12.23.44.57;	author guenther;	state Exp;
branches;
next	1.12;
commitid	lkvsxr9r9MdXqaQN;

1.12
date	2015.02.11.23.14.46;	author guenther;	state Exp;
branches;
next	1.11;
commitid	lWdBzWkSKKObQ4Qj;

1.11
date	2015.02.05.22.32.20;	author sthen;	state Exp;
branches;
next	1.10;
commitid	QBujBhAFFXGSsgsF;

1.10
date	2015.02.05.07.49.25;	author guenther;	state Exp;
branches;
next	1.9;
commitid	4roKhm1wyg3vjc8b;

1.9
date	2014.12.13.21.02.32;	author guenther;	state Exp;
branches;
next	1.8;
commitid	HiRY7mzCopWr3fje;

1.8
date	2006.08.05.23.05.13;	author ray;	state Exp;
branches
	1.8.36.1;
next	1.7;

1.7
date	2004.11.29.16.23.22;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.20.06.22.27;	author jmc;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.02.23.32.09;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.16.18.40.30;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.16.03.04.58;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.20.43;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.18;	author deraadt;	state Exp;
branches;
next	;

1.8.36.1
date	2015.04.30.19.30.57;	author guenther;	state Exp;
branches;
next	;
commitid	tPD1f2vGi43RT0WC;

1.14.2.1
date	2015.04.30.19.28.46;	author guenther;	state Exp;
branches;
next	;
commitid	pbBButXFqiIh89mX;


desc
@@


1.17
log
@tables.h is only used by tables.c; merge it into the .c file
<sys/time.h> is unnecessary; sort the #includes
@
text
@/*	$OpenBSD: tables.h,v 1.16 2015/03/19 05:14:24 guenther Exp $	*/
/*	$NetBSD: tables.h,v 1.3 1995/03/21 09:07:47 cgd Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tables.h	8.1 (Berkeley) 5/31/93
 */

/*
 * data structures and constants used by the different databases kept by pax
 */

/*
 * Hash Table Sizes MUST BE PRIME, if set too small performance suffers.
 * Probably safe to expect 500000 inodes per tape. Assuming good key
 * distribution (inodes) chains of under 50 long (worst case) is ok.
 */
#define L_TAB_SZ	2503		/* hard link hash table size */
#define F_TAB_SZ	50503		/* file time hash table size */
#define N_TAB_SZ	541		/* interactive rename hash table */
#define D_TAB_SZ	317		/* unique device mapping table */
#define A_TAB_SZ	317		/* ftree dir access time reset table */
#define SL_TAB_SZ	317		/* escape symlink tables */
#define MAXKEYLEN	64		/* max number of chars for hash */
#define DIRP_SIZE	64		/* initial size of created dir table */

/*
 * file hard link structure (hashed by dev/ino and chained) used to find the
 * hard links in a file system or with some archive formats (cpio)
 */
typedef struct hrdlnk {
	ino_t		ino;	/* files inode number */
	char		*name;	/* name of first file seen with this ino/dev */
	dev_t		dev;	/* files device number */
	u_long		nlink;	/* expected link count */
	struct hrdlnk	*fow;
} HRDLNK;

/*
 * Archive write update file time table (the -u, -C flag), hashed by filename.
 * Filenames are stored in a scratch file at seek offset into the file. The
 * file time (mod time) and the file name length (for a quick check) are
 * stored in a hash table node. We were forced to use a scratch file because
 * with -u, the mtime for every node in the archive must always be available
 * to compare against (and this data can get REALLY large with big archives).
 * By being careful to read only when we have a good chance of a match, the
 * performance loss is not measurable (and the size of the archive we can
 * handle is greatly increased).
 */
typedef struct ftm {
	off_t		seek;		/* location in scratch file */
	struct timespec	mtim;		/* files last modification time */
	struct ftm	*fow;
	int		namelen;	/* file name length */
} FTM;

/*
 * Interactive rename table (-i flag), hashed by orig filename.
 * We assume this will not be a large table as this mapping data can only be
 * obtained through interactive input by the user. Nobody is going to type in
 * changes for 500000 files? We use chaining to resolve collisions.
 */

typedef struct namt {
	char		*oname;		/* old name */
	char		*nname;		/* new name typed in by the user */
	struct namt	*fow;
} NAMT;

/*
 * Unique device mapping tables. Some protocols (e.g. cpio) require that the
 * <c_dev,c_ino> pair will uniquely identify a file in an archive unless they
 * are links to the same file. Appending to archives can break this. For those
 * protocols that have this requirement we map c_dev to a unique value not seen
 * in the archive when we append. We also try to handle inode truncation with
 * this table. (When the inode field in the archive header are too small, we
 * remap the dev on writes to remove accidental collisions).
 *
 * The list is hashed by device number using chain collision resolution. Off of
 * each DEVT are linked the various remaps for this device based on those bits
 * in the inode which were truncated. For example if we are just remapping to
 * avoid a device number during an update append, off the DEVT we would have
 * only a single DLIST that has a truncation id of 0 (no inode bits were
 * stripped for this device so far). When we spot inode truncation we create
 * a new mapping based on the set of bits in the inode which were stripped off.
 * so if the top four bits of the inode are stripped and they have a pattern of
 * 0110...... (where . are those bits not truncated) we would have a mapping
 * assigned for all inodes that has the same 0110.... pattern (with this dev
 * number of course). This keeps the mapping sparse and should be able to store
 * close to the limit of files which can be represented by the optimal
 * combination of dev and inode bits, and without creating a fouled up archive.
 * Note we also remap truncated devs in the same way (an exercise for the
 * dedicated reader; always wanted to say that...:)
 */

typedef struct devt {
	dev_t		dev;	/* the orig device number we now have to map */
	struct devt	*fow;	/* new device map list */
	struct dlist	*list;	/* map list based on inode truncation bits */
} DEVT;

typedef struct dlist {
	ino_t trunc_bits;	/* truncation pattern for a specific map */
	dev_t dev;		/* the new device id we use */
	struct dlist *fow;
} DLIST;

/*
 * ftree directory access time reset table. When we are done with a
 * subtree we reset the access and mod time of the directory when the tflag is
 * set. Not really explicitly specified in the pax spec, but easy and fast to
 * do (and this may have even been intended in the spec, it is not clear).
 * table is hashed by inode with chaining.
 */

typedef struct atdir {
	struct file_times ft;
	struct atdir *fow;
} ATDIR;

/*
 * created directory time and mode storage entry. After pax is finished during
 * extraction or copy, we must reset directory access modes and times that
 * may have been modified after creation (they no longer have the specified
 * times and/or modes). We must reset time in the reverse order of creation,
 * because entries are added  from the top of the file tree to the bottom.
 * We MUST reset times from leaf to root (it will not work the other
 * direction).
 */

typedef struct dirdata {
	struct file_times ft;
	u_int16_t mode;		/* file mode to restore */
	u_int16_t frc_mode;	/* do we force mode settings? */
} DIRDATA;
@


1.16
log
@Use struct timespec internally.  This gives nanosecond precision to pax -rw
and a basis for support of mtime and atime values in pax-format extended
header records.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.15 2015/03/09 04:23:29 guenther Exp $	*/
@


1.15
log
@Unrevert post-unlock:
* Prevent an archive from esacaping the current directory by itself:
  when extracting a symlink whose value is absolute or contains ".."
  components, just create a zero-length normal file (with additional
  tracking of the mode and hardlinks to the symlink) until everything
  else is extracted, then go back and replace it with the requested
  link (if it's still that zero-length placeholder).

* For tar without -P, if a path in the archive has any ".." components
  then strip everything up to and including the last of them (if
  it ends in ".." then it becomes ".")
  This mostly follows GNU tar's behavior, except for 'tar tf' and
  'tar xvf' we report the modified path that would be/was actually
  created instead of the raw path from the archive

  Above two fixes prompted by a report from Daniel Cegielka
  (daniel.cegielka (at) gmail.com)

* For directories whose times or mode will be fixed up in the
  clean-up pass, record their dev+ino and then use
  open(O_DIRECTORY)+fstat() to verify that we're updating the correct
  directory before using futimens() and fchmod().

* Correct buffer overflow in handling of pax extension headers,
  caught by the memcpy() overlap check.


previously ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.13 2015/02/12 23:44:57 guenther Exp $	*/
d82 1
a82 1
	time_t		mtime;		/* files last modification time */
@


1.14
log
@Recent changes haven't been completely stable, so revert for the 5.7 release

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.9 2014/12/13 21:02:32 guenther Exp $	*/
d53 1
d147 1
a147 4
	ino_t ino;
	time_t mtime;	/* access and mod time to reset to */
	time_t atime;
	char *name;	/* name of directory to reset */
a148 1
	dev_t dev;	/* dev and inode for fast lookup */
d162 2
a163 4
	time_t mtime;	/* mtime to set */
	time_t atime;	/* atime to set */
	char *name;	/* file name */
	u_int16_t mode;	/* file mode to restore */
@


1.14.2.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.14 2015/02/21 22:48:23 guenther Exp $	*/
a52 1
#define SL_TAB_SZ	317		/* escape symlink tables */
d146 4
a149 1
	struct file_times ft;
d151 1
d165 4
a168 2
	struct file_times ft;
	u_int16_t mode;		/* file mode to restore */
@


1.13
log
@Prevent an archive from esacaping the current directory by itself:
when extracting a symlink whose value is absolute or contains ".."
components, just create a zero-length normal file (with additional
tracking of the mode and hardlinks to the symlink) until everything
else is extracted, then go back and replace it with the requested
link (if its still that zero-length placeholder).

This and previous symlink and ".." path fixes prompted by a report
from Daniel Cegielka (daniel.cegielka (at) gmail.com)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.12 2015/02/11 23:14:46 guenther Exp $	*/
a52 1
#define SL_TAB_SZ	317		/* escape symlink tables */
d146 4
a149 1
	struct file_times ft;
d151 1
d165 4
a168 2
	struct file_times ft;
	u_int16_t mode;		/* file mode to restore */
@


1.12
log
@Take II, this time without an incorrect mode test.
For directories whose times or mode will be fixed up in the clean-up pass,
record their dev+ino and then use open(O_DIRECTORY)+fstat() to verify that
we're updating the correct directory before using futimens() and fchmod().

ok sthen@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.11 2015/02/05 22:32:20 sthen Exp $	*/
d53 1
@


1.11
log
@backout previous for now; issues seen with "tar: Directory vanished before
restoring mode and times: ..." (and an error exit code, which breaks at least
building ports). krw@@ agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.9 2014/12/13 21:02:32 guenther Exp $	*/
d146 1
a146 4
	ino_t ino;
	time_t mtime;	/* access and mod time to reset to */
	time_t atime;
	char *name;	/* name of directory to reset */
a147 1
	dev_t dev;	/* dev and inode for fast lookup */
d161 2
a162 4
	time_t mtime;	/* mtime to set */
	time_t atime;	/* atime to set */
	char *name;	/* file name */
	u_int16_t mode;	/* file mode to restore */
@


1.10
log
@For directories whose times or mode will be fixed up in the clean-up pass,
record their dev+ino and then use open(O_DIRECTORY)+fstat() to verify that
we're updating the correct directory before using futimens() and fchmod().

ok millert@@
@
text
@d146 4
a149 1
	struct file_times ft;
d151 1
d165 4
a168 2
	struct file_times ft;
	u_int16_t mode;		/* file mode to restore */
@


1.9
log
@Sort members by size to reduce structure padding
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.8 2006/08/05 23:05:13 ray Exp $	*/
d146 1
a146 4
	ino_t ino;
	time_t mtime;	/* access and mod time to reset to */
	time_t atime;
	char *name;	/* name of directory to reset */
a147 1
	dev_t dev;	/* dev and inode for fast lookup */
d161 2
a162 4
	time_t mtime;	/* mtime to set */
	time_t atime;	/* atime to set */
	char *name;	/* file name */
	u_int16_t mode;	/* file mode to restore */
@


1.8
log
@Remove "with with" typos.

Fix by Tobias Stoeckmann <tobias at bugol dot de> in PR 5193.
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.7 2004/11/29 16:23:22 otto Exp $	*/
d61 1
a63 1
	ino_t		ino;	/* files inode number */
d80 1
a80 1
	int		namelen;	/* file name length */
a81 1
	off_t		seek;		/* location in scratch file */
d83 1
a145 2
	char *name;	/* name of directory to reset */
	dev_t dev;	/* dev and inode for fast lookup */
d149 1
d151 1
a164 1
	char *name;	/* file name */
d167 1
@


1.8.36.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.8 2006/08/05 23:05:13 ray Exp $	*/
a52 1
#define SL_TAB_SZ	317		/* escape symlink tables */
d146 5
a150 1
	struct file_times ft;
d165 4
a168 2
	struct file_times ft;
	u_int16_t mode;		/* file mode to restore */
@


1.7
log
@Build the table of created directories in-memory, instead of using
a tmp file.  Makes it possible to unpack an archive without using
/tmp, while memory usage is still within every reasonable limit.

"love it" deraadt@@  ok millert@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.6 2003/10/20 06:22:27 jmc Exp $	*/
d138 1
a138 1
 * ftree directory access time reset table. When we are done with with a
@


1.6
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.5 2003/06/02 23:32:09 millert Exp $	*/
d54 1
d161 1
a161 2
 * direction).  Entries are recorded into a spool file to make reverse
 * reading faster.
d165 1
a165 3
	int nlen;	/* length of the directory name (includes \0) */
	off_t npos;	/* position in file where this dir name starts */
	mode_t mode;	/* file mode to restore */
d168 2
a169 1
	int frc_mode;	/* do we force mode settings? */
@


1.5
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.4 2002/10/16 18:40:30 millert Exp $	*/
d81 1
a81 1
	off_t		seek;		/* loacation in scratch file */
@


1.4
log
@Fix comment typos; most from NetBSD and FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.3 2001/05/16 03:04:58 mickey Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.3
log
@use proper str*cpy functions instead of home grown one, spaces; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.2 1996/06/23 14:20:43 deraadt Exp $	*/
d50 1
a50 1
 * distribution (inodes) chains of under 50 long (worse case) is ok.
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.3 1995/03/21 09:07:47 cgd Exp $	*/
d111 1
a111 1
 * The list is hashed by device number using chain collision resolution. Off of 
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
