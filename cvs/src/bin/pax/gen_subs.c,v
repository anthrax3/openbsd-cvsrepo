head	1.32;
access;
symbols
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.28.0.6
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.20.0.12
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.10
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.12
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.8
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.6
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.8
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.6
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.4
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.8
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.8.0.14
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.12
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2016.08.26.05.06.14;	author guenther;	state Exp;
branches;
next	1.31;
commitid	p36gyuPwcgIjfujh;

1.31
date	2016.08.26.04.11.16;	author guenther;	state Exp;
branches;
next	1.30;
commitid	JeDGCh3Baf9wzXzL;

1.30
date	2016.08.25.01.44.55;	author guenther;	state Exp;
branches;
next	1.29;
commitid	udvMiyfPVZQYw9Ht;

1.29
date	2016.08.14.04.47.52;	author guenther;	state Exp;
branches;
next	1.28;
commitid	KTreFUOYbPKrm5vY;

1.28
date	2015.03.17.03.23.17;	author guenther;	state Exp;
branches;
next	1.27;
commitid	gv8qhyah1XKC6RDB;

1.27
date	2015.03.15.00.41.27;	author millert;	state Exp;
branches;
next	1.26;
commitid	IbVxlqGw2UipKdDr;

1.26
date	2014.07.14.05.58.19;	author guenther;	state Exp;
branches;
next	1.25;
commitid	7trvwLDtRk2spMXa;

1.25
date	2014.01.09.03.12.25;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2014.01.08.05.52.47;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2014.01.08.04.58.36;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2013.07.03.04.08.29;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2012.12.04.02.24.45;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.04.21.55.10;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.28.06.58.07;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.13.17.51.14;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.32.08;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.16.19.20.02;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.16.17.43.10;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.17.18.19.49;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.26.00.32.21;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.16.03.04.57;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.12.13.51.15;	author danh;	state Exp;
branches;
next	1.8;

1.8
date	97.09.01.18.29.51;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.25.18.58.31;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.06.18.18.48.25;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.06.04.00.15.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.01.24.19.41.21;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.20.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.06.41.51;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.17;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Need <time.h> for time() and others.  Pulled in by coincidence previously

noted by tb@@
@
text
@/*	$OpenBSD: gen_subs.c,v 1.31 2016/08/26 04:11:16 guenther Exp $	*/
/*	$NetBSD: gen_subs.c,v 1.5 1995/03/21 09:07:26 cgd Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <grp.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <utmp.h>
#include <vis.h>

#include "pax.h"
#include "extern.h"

/*
 * a collection of general purpose subroutines used by pax
 */

/*
 * constants used by ls_list() when printing out archive members
 */
#define MODELEN 20
#define DATELEN 64
#define SECSPERDAY	(24 * 60 * 60)
#define SIXMONTHS	(SECSPERDAY * 365 / 2)
#define CURFRMT		"%b %e %H:%M"
#define OLDFRMT		"%b %e  %Y"
#define NAME_WIDTH	8
#define	TIMEFMT(t, now) \
	(((t) + SIXMONTHS <= (now) || (t) > (now)) ? OLDFRMT : CURFRMT)

/*
 * ls_list()
 *	list the members of an archive in ls format
 */

void
ls_list(ARCHD *arcn, time_t now, FILE *fp)
{
	struct stat *sbp;
	char f_mode[MODELEN];
	char f_date[DATELEN];
	int term;

	term = zeroflag ? '\0' : '\n';	/* path termination character */

	/*
	 * if not verbose, just print the file name
	 */
	if (!vflag) {
		if (zeroflag)
			(void)fputs(arcn->name, fp);
		else
			safe_print(arcn->name, fp);
		(void)putc(term, fp);
		(void)fflush(fp);
		return;
	}

	/*
	 * user wants long mode
	 */
	sbp = &(arcn->sb);
	strmode(sbp->st_mode, f_mode);

	/*
	 * print file mode, link count, uid, gid and time
	 */
	if (strftime(f_date, sizeof(f_date), TIMEFMT(sbp->st_mtime, now),
	    localtime(&(sbp->st_mtime))) == 0)
		f_date[0] = '\0';
	(void)fprintf(fp, "%s%2u %-*.*s %-*.*s ", f_mode, sbp->st_nlink,
		NAME_WIDTH, UT_NAMESIZE, user_from_uid(sbp->st_uid, 0),
		NAME_WIDTH, UT_NAMESIZE, group_from_gid(sbp->st_gid, 0));

	/*
	 * print device id's for devices, or sizes for other nodes
	 */
	if ((arcn->type == PAX_CHR) || (arcn->type == PAX_BLK))
		(void)fprintf(fp, "%4lu, %4lu ",
		    (unsigned long)MAJOR(sbp->st_rdev),
		    (unsigned long)MINOR(sbp->st_rdev));
	else {
		(void)fprintf(fp, "%9llu ", sbp->st_size);
	}

	/*
	 * print name and link info for hard and soft links
	 */
	(void)fputs(f_date, fp);
	(void)putc(' ', fp);
	safe_print(arcn->name, fp);
	if (PAX_IS_HARDLINK(arcn->type)) {
		fputs(" == ", fp);
		safe_print(arcn->ln_name, fp);
	} else if (arcn->type == PAX_SLK) {
		fputs(" -> ", fp);
		safe_print(arcn->ln_name, fp);
	}
	(void)putc(term, fp);
	(void)fflush(fp);
}

/*
 * tty_ls()
 *	print a short summary of file to tty.
 */

void
ls_tty(ARCHD *arcn)
{
	char f_date[DATELEN];
	char f_mode[MODELEN];
	time_t now = time(NULL);

	/*
	 * convert time to string, and print
	 */
	if (strftime(f_date, DATELEN, TIMEFMT(arcn->sb.st_mtime, now),
	    localtime(&(arcn->sb.st_mtime))) == 0)
		f_date[0] = '\0';
	strmode(arcn->sb.st_mode, f_mode);
	tty_prnt("%s%s %s\n", f_mode, f_date, arcn->name);
}

void
safe_print(const char *str, FILE *fp)
{
	char visbuf[5];
	const char *cp;

	/*
	 * if printing to a tty, use vis(3) to print special characters.
	 */
	if (isatty(fileno(fp))) {
		for (cp = str; *cp; cp++) {
			(void)vis(visbuf, cp[0], VIS_CSTYLE, cp[1]);
			(void)fputs(visbuf, fp);
		}
	} else {
		(void)fputs(str, fp);
	}
}

/*
 * asc_ul()
 *	convert hex/octal character string into a u_long. We do not have to
 *	check for overflow! (the headers in all supported formats are not large
 *	enough to create an overflow).
 *	NOTE: strings passed to us are NOT TERMINATED.
 * Return:
 *	unsigned long value
 */

u_long
asc_ul(char *str, int len, int base)
{
	char *stop;
	u_long tval = 0;

	stop = str + len;

	/*
	 * skip over leading blanks and zeros
	 */
	while ((str < stop) && ((*str == ' ') || (*str == '0')))
		++str;

	/*
	 * for each valid digit, shift running value (tval) over to next digit
	 * and add next digit
	 */
	if (base == HEX) {
		while (str < stop) {
			if ((*str >= '0') && (*str <= '9'))
				tval = (tval << 4) + (*str++ - '0');
			else if ((*str >= 'A') && (*str <= 'F'))
				tval = (tval << 4) + 10 + (*str++ - 'A');
			else if ((*str >= 'a') && (*str <= 'f'))
				tval = (tval << 4) + 10 + (*str++ - 'a');
			else
				break;
		}
	} else {
		while ((str < stop) && (*str >= '0') && (*str <= '7'))
			tval = (tval << 3) + (*str++ - '0');
	}
	return(tval);
}

/*
 * ul_asc()
 *	convert an unsigned long into an hex/oct ascii string. pads with LEADING
 *	ascii 0's to fill string completely
 *	NOTE: the string created is NOT TERMINATED.
 */

int
ul_asc(u_long val, char *str, int len, int base)
{
	char *pt;
	u_long digit;

	/*
	 * WARNING str is not '\0' terminated by this routine
	 */
	pt = str + len - 1;

	/*
	 * do a tailwise conversion (start at right most end of string to place
	 * least significant digit). Keep shifting until conversion value goes
	 * to zero (all digits were converted)
	 */
	if (base == HEX) {
		while (pt >= str) {
			if ((digit = (val & 0xf)) < 10)
				*pt-- = '0' + (char)digit;
			else
				*pt-- = 'a' + (char)(digit - 10);
			val >>= 4;
			if (val == 0)
				break;
		}
	} else {
		while (pt >= str) {
			*pt-- = '0' + (char)(val & 0x7);
			val >>= 3;
			if (val == 0)
				break;
		}
	}

	/*
	 * pad with leading ascii ZEROS. We return -1 if we ran out of space.
	 */
	while (pt >= str)
		*pt-- = '0';
	if (val != 0)
		return(-1);
	return(0);
}

/*
 * asc_ull()
 *	Convert hex/octal character string into a unsigned long long.
 *	We do not have to check for overflow!  (The headers in all
 *	supported formats are not large enough to create an overflow).
 *	NOTE: strings passed to us are NOT TERMINATED.
 * Return:
 *	unsigned long long value
 */

unsigned long long
asc_ull(char *str, int len, int base)
{
	char *stop;
	unsigned long long tval = 0;

	stop = str + len;

	/*
	 * skip over leading blanks and zeros
	 */
	while ((str < stop) && ((*str == ' ') || (*str == '0')))
		++str;

	/*
	 * for each valid digit, shift running value (tval) over to next digit
	 * and add next digit
	 */
	if (base == HEX) {
		while (str < stop) {
			if ((*str >= '0') && (*str <= '9'))
				tval = (tval << 4) + (*str++ - '0');
			else if ((*str >= 'A') && (*str <= 'F'))
				tval = (tval << 4) + 10 + (*str++ - 'A');
			else if ((*str >= 'a') && (*str <= 'f'))
				tval = (tval << 4) + 10 + (*str++ - 'a');
			else
				break;
		}
	} else {
		while ((str < stop) && (*str >= '0') && (*str <= '7'))
			tval = (tval << 3) + (*str++ - '0');
	}
	return(tval);
}

/*
 * ull_asc()
 *	Convert an unsigned long long into a hex/oct ascii string.
 *	Pads with LEADING ascii 0's to fill string completely
 *	NOTE: the string created is NOT TERMINATED.
 */

int
ull_asc(unsigned long long val, char *str, int len, int base)
{
	char *pt;
	unsigned long long digit;

	/*
	 * WARNING str is not '\0' terminated by this routine
	 */
	pt = str + len - 1;

	/*
	 * do a tailwise conversion (start at right most end of string to place
	 * least significant digit). Keep shifting until conversion value goes
	 * to zero (all digits were converted)
	 */
	if (base == HEX) {
		while (pt >= str) {
			if ((digit = (val & 0xf)) < 10)
				*pt-- = '0' + (char)digit;
			else
				*pt-- = 'a' + (char)(digit - 10);
			val >>= 4;
			if (val == 0)
				break;
		}
	} else {
		while (pt >= str) {
			*pt-- = '0' + (char)(val & 0x7);
			val >>= 3;
			if (val == 0)
				break;
		}
	}

	/*
	 * pad with leading ascii ZEROS. We return -1 if we ran out of space.
	 */
	while (pt >= str)
		*pt-- = '0';
	if (val != 0)
		return(-1);
	return(0);
}

/*
 * Copy at max min(bufz, fieldsz) chars from field to buf, stopping
 * at the first NUL char. NUL terminate buf if there is room left.
 */
size_t
fieldcpy(char *buf, size_t bufsz, const char *field, size_t fieldsz)
{
	char *p = buf;
	const char *q = field;
	size_t i = 0;

	if (fieldsz > bufsz)
		fieldsz = bufsz;
	while (i < fieldsz && *q != '\0') {
		*p++ = *q++;
		i++;
	}
	if (i < bufsz)
		*p = '\0';
	return(i);
}
@


1.31
log
@Don't need <sys/time.h> or "options.h" here
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.30 2016/08/25 01:44:55 guenther Exp $	*/
d44 1
@


1.30
log
@Replace name_{uid,gid}() with the libc routines user_from_uid() and
group_from_gid().  Eliminate some superfluous strncpy() calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.29 2016/08/14 04:47:52 guenther Exp $	*/
a37 1
#include <sys/time.h>
@


1.29
log
@Replace u_quad_t with unsigned long long and replace "uqd" with "ull" in
function names to match.  Pull some tangled assignments out of conditions
and use >>= where possible.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.28 2015/03/17 03:23:17 guenther Exp $	*/
d40 2
a42 2
#include <utmp.h>
#include <unistd.h>
d45 2
d48 1
d110 2
a111 2
		NAME_WIDTH, UT_NAMESIZE, name_uid(sbp->st_uid, 1),
		NAME_WIDTH, UT_NAMESIZE, name_gid(sbp->st_gid, 1));
@


1.28
log
@Add PAX_IS_{REG,HARDLINK,LINK} macros to simply many file type tests

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.27 2015/03/15 00:41:27 millert Exp $	*/
d254 2
a255 1
			if ((val = (val >> 4)) == (u_long)0)
d261 2
a262 1
			if ((val = (val >> 3)) == (u_long)0)
d272 1
a272 1
	if (val != (u_long)0)
d278 4
a281 4
 * asc_uqd()
 *	convert hex/octal character string into a u_quad_t. We do not have to
 *	check for overflow! (the headers in all supported formats are not large
 *	enough to create an overflow).
d284 1
a284 1
 *	u_quad_t value
d287 2
a288 2
u_quad_t
asc_uqd(char *str, int len, int base)
d291 1
a291 1
	u_quad_t tval = 0;
d324 3
a326 3
 * uqd_asc()
 *	convert an u_quad_t into a hex/oct ascii string. pads with LEADING
 *	ascii 0's to fill string completely
d331 1
a331 1
uqd_asc(u_quad_t val, char *str, int len, int base)
d334 1
a334 1
	u_quad_t digit;
d352 2
a353 1
			if ((val = (val >> 4)) == (u_quad_t)0)
d359 2
a360 1
			if ((val = (val >> 3)) == (u_quad_t)0)
d370 1
a370 1
	if (val != (u_quad_t)0)
@


1.27
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.26 2014/07/14 05:58:19 guenther Exp $	*/
d127 1
a127 1
	if ((arcn->type == PAX_HLK) || (arcn->type == PAX_HRG)) {
@


1.26
log
@Delete pointless 'return;' at end of function
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.25 2014/01/09 03:12:25 guenther Exp $	*/
a40 1
#include <tzfile.h>
d58 2
a59 1
#define SIXMONTHS	 ((DAYSPERNYEAR / 2) * SECSPERDAY)
@


1.25
log
@Update pax -v format to match "ls -l": display the year for dates
in the future and include a space between the major and minor numbers
for devices.  Eliminate bogus handling of LC_TIME environment variable.
Make strftime() format selection understandable by gcc -Wformat=2.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.24 2014/01/08 05:52:47 guenther Exp $	*/
a135 1
	return;
a157 1
	return;
@


1.24
log
@Replace strtoq(), QUAD_MAX, and %qu with their long long equivalent
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.23 2014/01/08 04:58:36 guenther Exp $	*/
d63 2
a76 1
	const char *timefrmt;
a99 12
	if (ltmfrmt == NULL) {
		/*
		 * no locale specified format. time format based on age
		 * compared to the time pax was started.
		 */
		if ((sbp->st_mtime + SIXMONTHS) <= now)
			timefrmt = OLDFRMT;
		else
			timefrmt = CURFRMT;
	} else
		timefrmt = ltmfrmt;

d103 2
a104 1
	if (strftime(f_date,DATELEN,timefrmt,localtime(&(sbp->st_mtime))) == 0)
d114 1
a114 1
		(void)fprintf(fp, "%4lu,%4lu ",
d149 1
a149 12
	const char *timefrmt;

	if (ltmfrmt == NULL) {
		/*
		 * no locale specified format
		 */
		if ((arcn->sb.st_mtime + SIXMONTHS) <= time(NULL))
			timefrmt = OLDFRMT;
		else
			timefrmt = CURFRMT;
	} else
		timefrmt = ltmfrmt;
d154 1
a154 1
	if (strftime(f_date, DATELEN, timefrmt,
@


1.23
log
@Eliminate poisonous LONG_OFF_T conditional

adjective suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.22 2013/07/03 04:08:29 guenther Exp $	*/
d124 2
a125 1
		(void)fprintf(fp, "%4lu,%4lu ", (unsigned long)MAJOR(sbp->st_rdev),
d128 1
a128 1
		(void)fprintf(fp, "%9qu ", sbp->st_size);
@


1.22
log
@cpio and ustar formats store times in octal fields that are 11 characters
wide, so they support up to 33bits.  Take advantage of the extra bits by
no longer forcing them into 32bit ints before the time_t conversion.  This
gets us another 204 years of range once time_t changes type

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.21 2012/12/04 02:24:45 deraadt Exp $	*/
a123 3
#		ifdef LONG_OFF_T
		(void)fprintf(fp, "%4u,%4u ", MAJOR(sbp->st_rdev),
#		else
a124 1
#		endif
a126 3
#		ifdef LONG_OFF_T
		(void)fprintf(fp, "%9lu ", sbp->st_size);
#		else
a127 1
#		endif
@


1.21
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.20 2009/10/27 23:59:22 deraadt Exp $	*/
a304 1
#ifndef LONG_OFF_T
a399 1
#endif
@


1.20
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.19 2007/04/04 21:55:10 millert Exp $	*/
a39 1
#include <sys/param.h>
@


1.19
log
@For verbose archive listings, use -> for symlinks, not =>,
as per POSIX.  From Igor Sobrado via jmc@@.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.18 2005/04/28 06:58:07 otto Exp $	*/
a35 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)gen_subs.c	8.1 (Berkeley) 5/31/93";
#else
static const char rcsid[] = "$OpenBSD: gen_subs.c,v 1.18 2005/04/28 06:58:07 otto Exp $";
#endif
#endif /* not lint */
@


1.18
log
@Use a special crafted string copy function to copy data from ustar
headers to the generic pax structs. ustar is "funny" since some fields
are not always NUL terminated. Old-style tar headers and ustar
creation remains to be done. ok millert@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.17 2003/06/13 17:51:14 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: gen_subs.c,v 1.17 2003/06/13 17:51:14 millert Exp $";
d157 1
a157 1
		fputs(" => ", fp);
@


1.17
log
@Add a -0 flag to make pax use a NUL instead of a newline as the
pathname separator.  Works in list mode as well as read/copy mode.
Based on a patch from David Leonard; closes PR 3310
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.16 2003/06/02 23:32:08 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: gen_subs.c,v 1.16 2003/06/02 23:32:08 millert Exp $";
d411 22
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.15 2002/10/16 19:20:02 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: gen_subs.c,v 1.15 2002/10/16 19:20:02 millert Exp $";
d85 3
d93 5
a97 2
		safe_print(arcn->name, fp);
		(void)putc('\n', fp);
d160 1
a160 1
	(void)putc('\n', fp);
@


1.15
log
@sprinkle const; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.14 2002/10/16 17:43:10 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: gen_subs.c,v 1.14 2002/10/16 17:43:10 millert Exp $";
@


1.14
log
@kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.13 2002/02/19 19:39:35 millert Exp $	*/
d43 1
a43 1
static char sccsid[] = "@@(#)gen_subs.c	8.1 (Berkeley) 5/31/93";
d45 1
a45 1
static char rcsid[] = "$OpenBSD: gen_subs.c,v 1.13 2002/02/19 19:39:35 millert Exp $";
d88 1
a88 1
	char *timefrmt;
d173 1
a173 1
	char *timefrmt;
d198 1
a198 1
safe_print(char *str, FILE *fp)
d201 1
a201 1
	char *cp;
@


1.13
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.12 2001/07/17 18:19:49 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: gen_subs.c,v 1.12 2001/07/17 18:19:49 millert Exp $";
d83 1
a83 1
ls_list(register ARCHD *arcn, time_t now, FILE *fp)
d85 1
a85 1
	register struct stat *sbp;
d169 1
a169 1
ls_tty(register ARCHD *arcn)
d227 1
a227 1
asc_ul(register char *str, int len, register int base)
d229 1
a229 1
	register char *stop;
d270 1
a270 1
ul_asc(u_long val, register char *str, register int len, register int base)
d272 1
a272 1
	register char *pt;
d324 1
a324 1
asc_uqd(register char *str, int len, register int base)
d326 1
a326 1
	register char *stop;
d367 1
a367 1
uqd_asc(u_quad_t val, register char *str, register int len, register int base)
d369 1
a369 1
	register char *pt;
@


1.12
log
@Add a safe_print() function that uses vis(3) if output is a tty.
Uses the vis C-style mode which is consistent with what GNU tar
does (though GNU tar does vis(3) regardless of whether output is a tty).

It may make sense to add a flag to force vis(3)ification like ls does
but I have not done that here as I'm reticent to add more flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.11 2001/05/26 00:32:21 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: gen_subs.c,v 1.11 2001/05/26 00:32:21 millert Exp $";
a81 1
#ifdef __STDC__
a83 7
#else
void
ls_list(arcn, now, fp)
	register ARCHD *arcn;
	time_t now;
	FILE *fp;
#endif
a167 1
#ifdef __STDC__
a169 5
#else
void
ls_tty(arcn)
	register ARCHD *arcn;
#endif
a196 1
#ifdef __STDC__
a198 6
#else
void
safe_print(str, fp)
	char *str;
	FILE *fp;
#endif
a225 1
#ifdef __STDC__
a227 7
#else
u_long
asc_ul(str, len, base)
	register char *str;
	int len;
	register int base;
#endif
a268 1
#ifdef __STDC__
a270 8
#else
int
ul_asc(val, str, len, base)
	u_long val;
	register char *str;
	register int len;
	register int base;
#endif
a322 1
#ifdef __STDC__
a324 7
#else
u_quad_t
asc_uqd(str, len, base)
	register char *str;
	int len;
	register int base;
#endif
a365 1
#ifdef __STDC__
a367 8
#else
int
uqd_asc(val, str, len, base)
	u_quad_t val;
	register char *str;
	register int len;
	register int base;
#endif
@


1.11
log
@Get rid of NET2_FTS and NET2_REGEX #ifdefs since they are useless.
Change NET2_STAT into LONG_OFF_T for portability to systems with
a 32bit off_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.10 2001/05/16 03:04:57 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: gen_subs.c,v 1.10 2001/05/16 03:04:57 mickey Exp $";
d59 1
d102 2
a103 1
		(void)fprintf(fp, "%s\n", arcn->name);
d156 11
a166 7
	(void)fprintf(fp, "%s %s", f_date, arcn->name);
	if ((arcn->type == PAX_HLK) || (arcn->type == PAX_HRG))
		(void)fprintf(fp, " == %s\n", arcn->ln_name);
	else if (arcn->type == PAX_SLK)
		(void)fprintf(fp, " => %s\n", arcn->ln_name);
	else
		(void)putc('\n', fp);
d209 26
@


1.10
log
@use proper str*cpy functions instead of home grown one, spaces; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.9 2001/02/12 13:51:15 danh Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: gen_subs.c,v 1.9 2001/02/12 13:51:15 danh Exp $";
d137 1
a137 1
#		ifdef NET2_STAT
d144 1
a144 1
#		ifdef NET2_STAT
d318 1
a318 1
#ifndef NET2_STAT
@


1.9
log
@don't use long usernames by default; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.8 1997/09/01 18:29:51 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: gen_subs.c,v 1.8 1997/09/01 18:29:51 deraadt Exp $";
d130 1
a130 1
		NAME_WIDTH, UT_NAMESIZE, name_uid(sbp->st_uid, 1), 
d167 1
a167 1
 * 	print a short summary of file to tty.
a205 33
 * l_strncpy()
 *	copy src to dest up to len chars (stopping at first '\0').
 *	when src is shorter than len, pads to len with '\0'. 
 * Return:
 *	number of chars copied. (Note this is a real performance win over
 *	doing a strncpy(), a strlen(), and then a possible memset())
 */

#ifdef __STDC__
int
l_strncpy(register char *dest, register char *src, int len)
#else
int
l_strncpy(dest, src, len)
	register char *dest;
	register char *src;
	int len;
#endif
{
	register char *stop;
	register char *start;

	stop = dest + len;
	start = dest;
	while ((dest < stop) && (*src != '\0'))
		*dest++ = *src++;
	len = dest - start;
	while (dest < stop)
		*dest++ = '\0';
	return(len);
}

/*
d253 1
a253 1
 		while ((str < stop) && (*str >= '0') && (*str <= '7'))
d367 1
a367 1
 		while ((str < stop) && (*str >= '0') && (*str <= '7'))
@


1.8
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.7 1997/07/25 18:58:31 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: gen_subs.c,v 1.7 1997/07/25 18:58:31 mickey Exp $";
d74 1
a74 4
#ifndef UT_NAMESIZE
#define UT_NAMESIZE	8
#endif
#define UT_GRPSIZE	6
d129 3
a131 3
	(void)fprintf(fp, "%s%2u %-*s %-*s ", f_mode, sbp->st_nlink,
		UT_NAMESIZE, name_uid(sbp->st_uid, 1), UT_GRPSIZE,
		name_gid(sbp->st_gid, 1));
@


1.7
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.6 1997/06/18 18:48:25 kstailey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: gen_subs.c,v 1.6 1997/06/18 18:48:25 kstailey Exp $";
d316 1
a316 1
	
d331 1
a331 1
			else 
d430 1
a430 1
	
d445 1
a445 1
			else 
@


1.6
log
@(foo *)NULL -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.5 1997/06/04 00:15:16 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: gen_subs.c,v 1.5 1997/06/04 00:15:16 millert Exp $";
d84 1
a84 1
#if __STDC__
d173 1
a173 1
#if __STDC__
d217 1
a217 1
#if __STDC__
d251 1
a251 1
#if __STDC__
d302 1
a302 1
#if __STDC__
d365 1
a365 1
#if __STDC__
d416 1
a416 1
#if __STDC__
@


1.5
log
@Fix usage of l_strncpy() (noticed by Theo) and make l_strncpy()
pad with NULL's like strncpy(3).  This eliminates the need for
zf_strncpy(); ocurrences of zf_strncpy() have been changed to l_strncpy().
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.4 1997/01/24 19:41:21 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: gen_subs.c,v 1.4 1997/01/24 19:41:21 millert Exp $";
d190 1
a190 1
		if ((arcn->sb.st_mtime + SIXMONTHS) <= time((time_t *)NULL))
@


1.4
log
@Support multiple -v options like GNU tar (> 1 -v means do ls-like output).
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.3 1996/06/23 14:20:35 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: gen_subs.c,v 1.3 1996/06/23 14:20:35 deraadt Exp $";
a208 29
 * zf_strncpy()
 *	copy src to dest up to len chars (stopping at first '\0'), when src is
 *	shorter than len, pads to len with '\0'. big performance win (and 
 *	a lot easier to code) over strncpy(), then a strlen() then a
 *	memset(). (or doing the memset() first).
 */

#if __STDC__
void
zf_strncpy(register char *dest, register char *src, int len)
#else
void
zf_strncpy(dest, src, len)
	register char *dest;
	register char *src;
	int len;
#endif
{
	register char *stop;

	stop = dest + len;
	while ((dest < stop) && (*src != '\0'))
		*dest++ = *src++;
	while (dest < stop)
		*dest++ = '\0';
	return;
}

/*
d210 2
a211 1
 *	copy src to dest up to len chars (stopping at first '\0')
d214 1
a214 1
 *	doing a strncpy() then a strlen()
d235 4
a238 3
	if (dest < stop)
		*dest = '\0';
	return(dest - start);
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.5 1995/03/21 09:07:26 cgd Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: gen_subs.c,v 1.5 1995/03/21 09:07:26 cgd Exp $";
d86 1
a86 1
ls_list(register ARCHD *arcn, time_t now)
d89 1
a89 1
ls_list(arcn, now)
d92 1
d104 2
a105 2
		(void)printf("%s\n", arcn->name);
		(void)fflush(stdout);
d132 2
a133 2
	(void)printf("%s%2u %-*s %-*s ", f_mode, sbp->st_nlink, UT_NAMESIZE,
		name_uid(sbp->st_uid, 1), UT_GRPSIZE,
d141 1
a141 1
		(void)printf("%4u,%4u ", MAJOR(sbp->st_rdev),
d143 1
a143 1
		(void)printf("%4lu,%4lu ", (unsigned long)MAJOR(sbp->st_rdev),
d148 1
a148 1
		(void)printf("%9lu ", sbp->st_size);
d150 1
a150 1
		(void)printf("%9qu ", sbp->st_size);
d157 1
a157 1
	(void)printf("%s %s", f_date, arcn->name);
d159 1
a159 1
		(void)printf(" == %s\n", arcn->ln_name);
d161 1
a161 1
		(void)printf(" => %s\n", arcn->ln_name);
d163 2
a164 2
		(void)putchar('\n');
	(void)fflush(stdout);
@


1.2
log
@Correct compile warnings
Rename warn() to paxwarn() so <err.h> can be included

Remove #include <ctype.h> when not needed; from FreeBSD
@
text
@d1 1
d45 1
a45 1
static char rcsid[] = "$NetBSD: gen_subs.c,v 1.5 1995/03/21 09:07:26 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@a52 1
#include <ctype.h>
d141 1
a141 1
		(void)printf("%4lu,%4lu ", MAJOR(sbp->st_rdev),
d143 1
a143 1
		    MINOR(sbp->st_rdev));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
