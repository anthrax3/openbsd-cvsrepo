head	1.62;
access;
symbols
	OPENBSD_6_2:1.62.0.2
	OPENBSD_6_2_BASE:1.62
	OPENBSD_6_1:1.62.0.4
	OPENBSD_6_1_BASE:1.62
	OPENBSD_6_0:1.56.0.2
	OPENBSD_6_0_BASE:1.56
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.48.0.4
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.44.0.4
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.40.0.4
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.40.0.2
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.39.0.12
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.10
	OPENBSD_5_0:1.39.0.8
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.39.0.6
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.4
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.38.0.8
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.4
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.38.0.2
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.37.0.12
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.37.0.10
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.37.0.8
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.37.0.6
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.37.0.4
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.36.0.4
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.36.0.2
	OPENBSD_3_6_BASE:1.36
	OPENBSD_3_5:1.34.0.4
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	OPENBSD_3_3:1.32.0.2
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.26.0.4
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9:1.20.0.4
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.19.0.4
	OPENBSD_2_7_BASE:1.19
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.18.0.4
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.18.0.2
	OPENBSD_2_4_BASE:1.18
	OPENBSD_2_3:1.17.0.4
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.17.0.2
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.62
date	2017.03.11.12.55.47;	author tb;	state Exp;
branches;
next	1.61;
commitid	vLhSs8uwZxyoO4sW;

1.61
date	2017.01.23.12.46.13;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	0CvD9OvF163f51Fm;

1.60
date	2017.01.23.04.25.05;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	NeJrtXDNhZqhGXfa;

1.59
date	2016.08.26.04.31.35;	author guenther;	state Exp;
branches;
next	1.58;
commitid	oEeHzAYDyi3kUy6E;

1.58
date	2016.08.23.06.00.28;	author guenther;	state Exp;
branches;
next	1.57;
commitid	lequwSVdrsu8itF8;

1.57
date	2016.08.14.18.30.33;	author guenther;	state Exp;
branches;
next	1.56;
commitid	qmsIw7NlXw1nDUYx;

1.56
date	2016.06.03.23.22.20;	author tedu;	state Exp;
branches;
next	1.55;
commitid	97UrMIkVErmkPRJd;

1.55
date	2015.12.06.16.57.45;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	twr8YTraN2kDAzjR;

1.54
date	2015.10.14.20.57.28;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	T6URM97g2BjFuHGX;

1.53
date	2015.10.12.14.01.06;	author semarie;	state Exp;
branches;
next	1.52;
commitid	sZF5MpwQYam6JGRe;

1.52
date	2015.10.12.09.28.54;	author semarie;	state Exp;
branches;
next	1.51;
commitid	Ae97NP3yTzeWoOot;

1.51
date	2015.10.12.05.05.24;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	mRVEKONqPhGT4efi;

1.50
date	2015.03.22.03.15.00;	author guenther;	state Exp;
branches;
next	1.49;
commitid	JUoLXmHphmM0Ue48;

1.49
date	2015.03.09.04.25.28;	author guenther;	state Exp;
branches;
next	1.48;
commitid	35o3xyLD9BDd4XoB;

1.48
date	2014.05.24.18.51.00;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2014.05.23.21.58.26;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2014.05.23.19.47.49;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2014.05.21.04.17.56;	author guenther;	state Exp;
branches;
next	1.44;

1.44
date	2014.01.11.05.36.26;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2014.01.08.05.52.47;	author guenther;	state Exp;
branches;
next	1.42;

1.42
date	2014.01.08.04.58.36;	author guenther;	state Exp;
branches;
next	1.41;

1.41
date	2014.01.08.04.42.24;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2012.12.04.02.24.45;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.11.00.49.08;	author pvalchev;	state Exp;
branches;
next	1.37;

1.37
date	2005.08.04.10.02.44;	author mpf;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.20.16.22.08;	author niklas;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.16.22.50.23;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2003.09.08.20.19.51;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.02.23.32.08;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2003.02.03.09.06.42;	author jmc;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.29.09.27.34;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.10.18.15.38.11;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.10.16.19.20.02;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.10.16.18.40.30;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.10.16.17.43.10;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.19.10.58.07;	author mpech;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.09.07.04.26;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.26.00.32.20;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.16.03.04.54;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.09.16.37.54;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	99.08.04.17.13.24;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	98.09.20.02.22.21;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.09.01.18.29.42;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.07.25.18.58.21;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.07.23.19.15.53;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	97.06.18.18.48.23;	author kstailey;	state Exp;
branches;
next	1.13;

1.13
date	97.03.25.09.30.19;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.03.02.20.42.56;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	97.02.27.23.32.56;	author michaels;	state Exp;
branches;
next	1.10;

1.10
date	97.02.20.06.54.31;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	97.02.16.07.51.12;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.12.09.12.00.13;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.11.24.18.15.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.10.27.00.29.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.22.20.09.53;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.14.20.28;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.11.06.41.46;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.04.19.02.24.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.16;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.62
log
@switch pax to using pledge tape instead of ioctl.

ok kettenis
@
text
@/*	$OpenBSD: ar_io.c,v 1.61 2017/01/23 12:46:13 deraadt Exp $	*/
/*	$NetBSD: ar_io.c,v 1.5 1996/03/26 23:54:13 mrg Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/mtio.h>
#include <sys/wait.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "pax.h"
#include "extern.h"

/*
 * Routines which deal directly with the archive I/O device/file.
 */

#define DMOD		0666		/* default mode of created archives */
#define EXT_MODE	O_RDONLY	/* open mode for list/extract */
#define AR_MODE		(O_WRONLY | O_CREAT | O_TRUNC)	/* mode for archive */
#define APP_MODE	O_RDWR		/* mode for append */
#define STDO		"<STDOUT>"	/* pseudo name for stdout */
#define STDN		"<STDIN>"	/* pseudo name for stdin */
static int arfd = -1;			/* archive file descriptor */
static int artyp = ISREG;		/* archive type: file/FIFO/tape */
static int arvol = 1;			/* archive volume number */
static int lstrval = -1;		/* return value from last i/o */
static int io_ok;			/* i/o worked on volume after resync */
static int did_io;			/* did i/o ever occur on volume? */
static int done;			/* set via tty termination */
static struct stat arsb;		/* stat of archive device at open */
static int invld_rec;			/* tape has out of spec record size */
static int wr_trail = 1;		/* trailer was rewritten in append */
static int can_unlnk = 0;		/* do we unlink null archives?  */
const char *arcname;			/* printable name of archive */
const char *gzip_program;		/* name of gzip program */
static pid_t zpid = -1;			/* pid of child process */
int force_one_volume;			/* 1 if we ignore volume changes */

static int get_phys(void);
extern sigset_t s_mask;
static void ar_start_gzip(int, const char *, int);

/*
 * ar_open()
 *	Opens the next archive volume. Determines the type of the device and
 *	sets up block sizes as required by the archive device and the format.
 *	Note: we may be called with name == NULL on the first open only.
 * Return:
 *	-1 on failure, 0 otherwise
 */

int
ar_open(const char *name)
{
	struct mtget mb;

	if (arfd != -1)
		(void)close(arfd);
	arfd = -1;
	can_unlnk = did_io = io_ok = invld_rec = 0;
	artyp = ISREG;
	flcnt = 0;

	/*
	 * open based on overall operation mode
	 */
	switch (act) {
	case LIST:
	case EXTRACT:
		if (name == NULL) {
			arfd = STDIN_FILENO;
			arcname = STDN;
		} else if ((arfd = open(name, EXT_MODE, DMOD)) < 0)
			syswarn(1, errno, "Failed open to read on %s", name);
		if (arfd != -1 && gzip_program != NULL)
			ar_start_gzip(arfd, gzip_program, 0);
		break;
	case ARCHIVE:
		if (name == NULL) {
			arfd = STDOUT_FILENO;
			arcname = STDO;
		} else if ((arfd = open(name, AR_MODE, DMOD)) < 0)
			syswarn(1, errno, "Failed open to write on %s", name);
		else
			can_unlnk = 1;
		if (arfd != -1 && gzip_program != NULL)
			ar_start_gzip(arfd, gzip_program, 1);
		break;
	case APPND:
		if (name == NULL) {
			arfd = STDOUT_FILENO;
			arcname = STDO;
		} else if ((arfd = open(name, APP_MODE, DMOD)) < 0)
			syswarn(1, errno, "Failed open to read/write on %s",
				name);
		break;
	case COPY:
		/*
		 * arfd not used in COPY mode
		 */
		arcname = "<NONE>";
		lstrval = 1;
		return(0);
	}
	if (arfd < 0)
		return(-1);

	if (chdname != NULL)
		if (chdir(chdname) != 0) {
			syswarn(1, errno, "Failed chdir to %s", chdname);
			return(-1);
		}
	/*
	 * set up is based on device type
	 */
	if (fstat(arfd, &arsb) < 0) {
		syswarn(1, errno, "Failed stat on %s", arcname);
		(void)close(arfd);
		arfd = -1;
		can_unlnk = 0;
		return(-1);
	}
	if (S_ISDIR(arsb.st_mode)) {
		paxwarn(0, "Cannot write an archive on top of a directory %s",
		    arcname);
		(void)close(arfd);
		arfd = -1;
		can_unlnk = 0;
		return(-1);
	}

	if (S_ISCHR(arsb.st_mode))
		artyp = ioctl(arfd, MTIOCGET, &mb) ? ISCHR : ISTAPE;
	else if (S_ISBLK(arsb.st_mode))
		artyp = ISBLK;
	else if ((lseek(arfd, 0, SEEK_CUR) == -1) && (errno == ESPIPE))
		artyp = ISPIPE;
	else
		artyp = ISREG;

	/*
	 * make sure beyond any doubt that we can unlink only regular files
	 * we created
	 */
	if (artyp != ISREG)
		can_unlnk = 0;
	/*
	 * if we are writing, we are done
	 */
	if (act == ARCHIVE) {
		blksz = rdblksz = wrblksz;
		lstrval = 1;
		return(0);
	}

	/*
	 * set default blksz on read. APPNDs writes rdblksz on the last volume
	 * On all new archive volumes, we shift to wrblksz (if the user
	 * specified one, otherwise we will continue to use rdblksz). We
	 * must set blocksize based on what kind of device the archive is
	 * stored.
	 */
	switch (artyp) {
	case ISTAPE:
		/*
		 * Tape drives come in at least two flavors. Those that support
		 * variable sized records and those that have fixed sized
		 * records. They must be treated differently. For tape drives
		 * that support variable sized records, we must make large
		 * reads to make sure we get the entire record, otherwise we
		 * will just get the first part of the record (up to size we
		 * asked). Tapes with fixed sized records may or may not return
		 * multiple records in a single read. We really do not care
		 * what the physical record size is UNLESS we are going to
		 * append. (We will need the physical block size to rewrite
		 * the trailer). Only when we are appending do we go to the
		 * effort to figure out the true PHYSICAL record size.
		 */
		blksz = rdblksz = MAXBLK;
		break;
	case ISPIPE:
	case ISBLK:
	case ISCHR:
		/*
		 * Blocksize is not a major issue with these devices (but must
		 * be kept a multiple of 512). If the user specified a write
		 * block size, we use that to read. Under append, we must
		 * always keep blksz == rdblksz. Otherwise we go ahead and use
		 * the device optimal blocksize as (and if) returned by stat
		 * and if it is within pax specs.
		 */
		if ((act == APPND) && wrblksz) {
			blksz = rdblksz = wrblksz;
			break;
		}

		if ((arsb.st_blksize > 0) && (arsb.st_blksize < MAXBLK) &&
		    ((arsb.st_blksize % BLKMULT) == 0))
			rdblksz = arsb.st_blksize;
		else
			rdblksz = DEVBLK;
		/*
		 * For performance go for large reads when we can without harm
		 */
		if ((act == APPND) || (artyp == ISCHR))
			blksz = rdblksz;
		else
			blksz = MAXBLK;
		break;
	case ISREG:
		/*
		 * if the user specified wrblksz works, use it. Under appends
		 * we must always keep blksz == rdblksz
		 */
		if ((act == APPND) && wrblksz && ((arsb.st_size%wrblksz)==0)){
			blksz = rdblksz = wrblksz;
			break;
		}
		/*
		 * See if we can find the blocking factor from the file size
		 */
		for (rdblksz = MAXBLK; rdblksz > 0; rdblksz -= BLKMULT)
			if ((arsb.st_size % rdblksz) == 0)
				break;
		/*
		 * When we cannot find a match, we may have a flawed archive.
		 */
		if (rdblksz <= 0)
			rdblksz = FILEBLK;
		/*
		 * for performance go for large reads when we can
		 */
		if (act == APPND)
			blksz = rdblksz;
		else
			blksz = MAXBLK;
		break;
	default:
		/*
		 * should never happen, worst case, slow...
		 */
		blksz = rdblksz = BLKMULT;
		break;
	}
	lstrval = 1;
	return(0);
}

/*
 * ar_close(int int_sig)
 *	closes archive device, increments volume number, and prints i/o summary
 *	If in_sig is set we're in a signal handler and can't flush stdio.
 */
void
ar_close(int in_sig)
{
	int status;

	if (arfd < 0) {
		did_io = io_ok = flcnt = 0;
		return;
	}
	if (!in_sig)
		fflush(listf);

	/*
	 * Close archive file. This may take a LONG while on tapes (we may be
	 * forced to wait for the rewind to complete) so tell the user what is
	 * going on (this avoids the user hitting control-c thinking pax is
	 * broken).
	 */
	if (vflag && (artyp == ISTAPE)) {
		(void)dprintf(listfd,
		    "%s%s: Waiting for tape drive close to complete...",
		    vfpart ? "\n" : "", argv0);
	}

	/*
	 * if nothing was written to the archive (and we created it), we remove
	 * it
	 */
	if (can_unlnk && (fstat(arfd, &arsb) == 0) && (S_ISREG(arsb.st_mode)) &&
	    (arsb.st_size == 0)) {
		(void)unlink(arcname);
		can_unlnk = 0;
	}

	/*
	 * for a quick extract/list, pax frequently exits before the child
	 * process is done
	 */
	if ((act == LIST || act == EXTRACT) && nflag && zpid > 0) {
		kill(zpid, SIGINT);
		zpid = -1;
	}

	(void)close(arfd);

	/* Do not exit before child to ensure data integrity */
	if (zpid > 0) {
		waitpid(zpid, &status, 0);
		if (!WIFEXITED(status) || WEXITSTATUS(status))
			exit_val = 1;
	}


	if (vflag && (artyp == ISTAPE)) {
		(void)write(listfd, "done.\n", sizeof("done.\n")-1);
		vfpart = 0;
	}
	arfd = -1;

	if (!io_ok && !did_io) {
		flcnt = 0;
		return;
	}
	did_io = io_ok = 0;

	/*
	 * The volume number is only increased when the last device has data
	 * and we have already determined the archive format.
	 */
	if (frmt != NULL)
		++arvol;

	if (!vflag) {
		flcnt = 0;
		return;
	}

	/*
	 * Print out a summary of I/O for this archive volume.
	 */
	if (vfpart) {
		(void)write(listfd, "\n", 1);
		vfpart = 0;
	}

	/*
	 * If we have not determined the format yet, we just say how many bytes
	 * we have skipped over looking for a header to id. there is no way we
	 * could have written anything yet.
	 */
	if (frmt == NULL) {
		(void)dprintf(listfd,
		    "%s: unknown format, %llu bytes skipped.\n", argv0, rdcnt);
		flcnt = 0;
		return;
	}

	if (op_mode == OP_PAX)
		(void)dprintf(listfd, "%s: %s vol %d, %lu files,"
		    " %llu bytes read, %llu bytes written.\n",
		    argv0, frmt->name, arvol-1, flcnt, rdcnt, wrcnt);
#ifndef NOCPIO
	else if (op_mode == OP_CPIO)
		(void)dprintf(listfd, "%llu blocks\n",
		    (rdcnt ? rdcnt : wrcnt) / 5120);
#endif /* !NOCPIO */
	flcnt = 0;
}

/*
 * ar_drain()
 *	drain any archive format independent padding from an archive read
 *	from a socket or a pipe. This is to prevent the process on the
 *	other side of the pipe from getting a SIGPIPE (pax will stop
 *	reading an archive once a format dependent trailer is detected).
 */
void
ar_drain(void)
{
	int res;
	char drbuf[MAXBLK];

	/*
	 * we only drain from a pipe/socket. Other devices can be closed
	 * without reading up to end of file. We sure hope that pipe is closed
	 * on the other side so we will get an EOF.
	 */
	if ((artyp != ISPIPE) || (lstrval <= 0))
		return;

	/*
	 * keep reading until pipe is drained
	 */
	while ((res = read(arfd, drbuf, sizeof(drbuf))) > 0)
		continue;
	lstrval = res;
}

/*
 * ar_set_wr()
 *	Set up device right before switching from read to write in an append.
 *	device dependent code (if required) to do this should be added here.
 *	For all archive devices we are already positioned at the place we want
 *	to start writing when this routine is called.
 * Return:
 *	0 if all ready to write, -1 otherwise
 */

int
ar_set_wr(void)
{
	off_t cpos;

	/*
	 * we must make sure the trailer is rewritten on append, ar_next()
	 * will stop us if the archive containing the trailer was not written
	 */
	wr_trail = 0;

	/*
	 * Add any device dependent code as required here
	 */
	if (artyp != ISREG)
		return(0);
	/*
	 * Ok we have an archive in a regular file. If we were rewriting a
	 * file, we must get rid of all the stuff after the current offset
	 * (it was not written by pax).
	 */
	if (((cpos = lseek(arfd, 0, SEEK_CUR)) < 0) ||
	    (ftruncate(arfd, cpos) < 0)) {
		syswarn(1, errno, "Unable to truncate archive file");
		return(-1);
	}
	return(0);
}

/*
 * ar_app_ok()
 *	check if the last volume in the archive allows appends. We cannot check
 *	this until we are ready to write since there is no spec that says all
 *	volumes in a single archive have to be of the same type...
 * Return:
 *	0 if we can append, -1 otherwise.
 */

int
ar_app_ok(void)
{
	if (artyp == ISPIPE) {
		paxwarn(1, "Cannot append to an archive obtained from a pipe.");
		return(-1);
	}

	if (!invld_rec)
		return(0);
	paxwarn(1,"Cannot append, device record size %d does not support %s spec",
		rdblksz, argv0);
	return(-1);
}

/*
 * ar_read()
 *	read up to a specified number of bytes from the archive into the
 *	supplied buffer. When dealing with tapes we may not always be able to
 *	read what we want.
 * Return:
 *	Number of bytes in buffer. 0 for end of file, -1 for a read error.
 */

int
ar_read(char *buf, int cnt)
{
	int res = 0;

	/*
	 * if last i/o was in error, no more reads until reset or new volume
	 */
	if (lstrval <= 0)
		return(lstrval);

	/*
	 * how we read must be based on device type
	 */
	switch (artyp) {
	case ISTAPE:
		if ((res = read(arfd, buf, cnt)) > 0) {
			/*
			 * CAUTION: tape systems may not always return the same
			 * sized records so we leave blksz == MAXBLK. The
			 * physical record size that a tape drive supports is
			 * very hard to determine in a uniform and portable
			 * manner.
			 */
			io_ok = 1;
			if (res != rdblksz) {
				/*
				 * Record size changed. If this happens on
				 * any record after the first, we probably have
				 * a tape drive which has a fixed record size
				 * (we are getting multiple records in a single
				 * read). Watch out for record blocking that
				 * violates pax spec (must be a multiple of
				 * BLKMULT).
				 */
				rdblksz = res;
				if (rdblksz % BLKMULT)
					invld_rec = 1;
			}
			return(res);
		}
		break;
	case ISREG:
	case ISBLK:
	case ISCHR:
	case ISPIPE:
	default:
		/*
		 * Files are so easy to deal with. These other things cannot
		 * be trusted at all. So when we are dealing with character
		 * devices and pipes we just take what they have ready for us
		 * and return. Trying to do anything else with them runs the
		 * risk of failure.
		 */
		if ((res = read(arfd, buf, cnt)) > 0) {
			io_ok = 1;
			return(res);
		}
		break;
	}

	/*
	 * We are in trouble at this point, something is broken...
	 */
	lstrval = res;
	if (res < 0)
		syswarn(1, errno, "Failed read on archive volume %d", arvol);
	else
		paxwarn(0, "End of archive volume %d reached", arvol);
	return(res);
}

/*
 * ar_write()
 *	Write a specified number of bytes in supplied buffer to the archive
 *	device so it appears as a single "block". Deals with errors and tries
 *	to recover when faced with short writes.
 * Return:
 *	Number of bytes written. 0 indicates end of volume reached and with no
 *	flaws (as best that can be detected). A -1 indicates an unrecoverable
 *	error in the archive occurred.
 */

int
ar_write(char *buf, int bsz)
{
	int res;
	off_t cpos;

	/*
	 * do not allow pax to create a "bad" archive. Once a write fails on
	 * an archive volume prevent further writes to it.
	 */
	if (lstrval <= 0)
		return(lstrval);

	if ((res = write(arfd, buf, bsz)) == bsz) {
		wr_trail = 1;
		io_ok = 1;
		return(bsz);
	}
	/*
	 * write broke, see what we can do with it. We try to send any partial
	 * writes that may violate pax spec to the next archive volume.
	 */
	if (res < 0)
		lstrval = res;
	else
		lstrval = 0;

	switch (artyp) {
	case ISREG:
		if ((res > 0) && (res % BLKMULT)) {
			/*
			 * try to fix up partial writes which are not BLKMULT
			 * in size by forcing the runt record to next archive
			 * volume
			 */
			if ((cpos = lseek(arfd, 0, SEEK_CUR)) < 0)
				break;
			cpos -= res;
			if (ftruncate(arfd, cpos) < 0)
				break;
			res = lstrval = 0;
			break;
		}
		if (res >= 0)
			break;
		/*
		 * if file is out of space, handle it like a return of 0
		 */
		if ((errno == ENOSPC) || (errno == EFBIG) || (errno == EDQUOT))
			res = lstrval = 0;
		break;
	case ISTAPE:
	case ISCHR:
	case ISBLK:
		if (res >= 0)
			break;
		if (errno == EACCES) {
			paxwarn(0, "Write failed, archive is write protected.");
			res = lstrval = 0;
			return(0);
		}
		/*
		 * see if we reached the end of media, if so force a change to
		 * the next volume
		 */
		if ((errno == ENOSPC) || (errno == EIO) || (errno == ENXIO))
			res = lstrval = 0;
		break;
	case ISPIPE:
	default:
		/*
		 * we cannot fix errors to these devices
		 */
		break;
	}

	/*
	 * Better tell the user the bad news...
	 * if this is a block aligned archive format, we may have a bad archive
	 * if the format wants the header to start at a BLKMULT boundary. While
	 * we can deal with the mis-aligned data, it violates spec and other
	 * archive readers will likely fail. if the format is not block
	 * aligned, the user may be lucky (and the archive is ok).
	 */
	if (res >= 0) {
		if (res > 0)
			wr_trail = 1;
		io_ok = 1;
	}

	/*
	 * If we were trying to rewrite the trailer and it didn't work, we
	 * must quit right away.
	 */
	if (!wr_trail && (res <= 0)) {
		paxwarn(1,"Unable to append, trailer re-write failed. Quitting.");
		return(res);
	}

	if (res == 0)
		paxwarn(0, "End of archive volume %d reached", arvol);
	else if (res < 0)
		syswarn(1, errno, "Failed write to archive volume: %d", arvol);
	else if (!frmt->blkalgn || ((res % frmt->blkalgn) == 0))
		paxwarn(0,"WARNING: partial archive write. Archive MAY BE FLAWED");
	else
		paxwarn(1,"WARNING: partial archive write. Archive IS FLAWED");
	return(res);
}

/*
 * ar_rdsync()
 *	Try to move past a bad spot on a flawed archive as needed to continue
 *	I/O. Clears error flags to allow I/O to continue.
 * Return:
 *	0 when ok to try i/o again, -1 otherwise.
 */

int
ar_rdsync(void)
{
	long fsbz;
	off_t cpos;
	off_t mpos;
	struct mtop mb;

	/*
	 * Fail resync attempts at user request (done) or if this is going to be
	 * an update/append to a existing archive. if last i/o hit media end,
	 * we need to go to the next volume not try a resync
	 */
	if ((done > 0) || (lstrval == 0))
		return(-1);

	if ((act == APPND) || (act == ARCHIVE)) {
		paxwarn(1, "Cannot allow updates to an archive with flaws.");
		return(-1);
	}
	if (io_ok)
		did_io = 1;

	switch (artyp) {
	case ISTAPE:
		/*
		 * if the last i/o was a successful data transfer, we assume
		 * the fault is just a bad record on the tape that we are now
		 * past. If we did not get any data since the last resync try
		 * to move the tape forward one PHYSICAL record past any
		 * damaged tape section. Some tape drives are stubborn and need
		 * to be pushed.
		 */
		if (io_ok) {
			io_ok = 0;
			lstrval = 1;
			break;
		}
		mb.mt_op = MTFSR;
		mb.mt_count = 1;
		if (ioctl(arfd, MTIOCTOP, &mb) < 0)
			break;
		lstrval = 1;
		break;
	case ISREG:
	case ISCHR:
	case ISBLK:
		/*
		 * try to step over the bad part of the device.
		 */
		io_ok = 0;
		if (((fsbz = arsb.st_blksize) <= 0) || (artyp != ISREG))
			fsbz = BLKMULT;
		if ((cpos = lseek(arfd, 0, SEEK_CUR)) < 0)
			break;
		mpos = fsbz - (cpos % fsbz);
		if (lseek(arfd, mpos, SEEK_CUR) < 0)
			break;
		lstrval = 1;
		break;
	case ISPIPE:
	default:
		/*
		 * cannot recover on these archive device types
		 */
		io_ok = 0;
		break;
	}
	if (lstrval <= 0) {
		paxwarn(1, "Unable to recover from an archive read failure.");
		return(-1);
	}
	paxwarn(0, "Attempting to recover from an archive read failure.");
	return(0);
}

/*
 * ar_fow()
 *	Move the I/O position within the archive forward the specified number of
 *	bytes as supported by the device. If we cannot move the requested
 *	number of bytes, return the actual number of bytes moved in skipped.
 * Return:
 *	0 if moved the requested distance, -1 on complete failure, 1 on
 *	partial move (the amount moved is in skipped)
 */

int
ar_fow(off_t sksz, off_t *skipped)
{
	off_t cpos;
	off_t mpos;

	*skipped = 0;
	if (sksz <= 0)
		return(0);

	/*
	 * we cannot move forward at EOF or error
	 */
	if (lstrval <= 0)
		return(lstrval);

	/*
	 * Safer to read forward on devices where it is hard to find the end of
	 * the media without reading to it. With tapes we cannot be sure of the
	 * number of physical blocks to skip (we do not know physical block
	 * size at this point), so we must only read forward on tapes!
	 */
	if (artyp != ISREG)
		return(0);

	/*
	 * figure out where we are in the archive
	 */
	if ((cpos = lseek(arfd, 0, SEEK_CUR)) >= 0) {
		/*
		 * we can be asked to move farther than there are bytes in this
		 * volume, if so, just go to file end and let normal buf_fill()
		 * deal with the end of file (it will go to next volume by
		 * itself)
		 */
		if ((mpos = cpos + sksz) > arsb.st_size) {
			*skipped = arsb.st_size - cpos;
			mpos = arsb.st_size;
		} else
			*skipped = sksz;
		if (lseek(arfd, mpos, SEEK_SET) >= 0)
			return(0);
	}
	syswarn(1, errno, "Forward positioning operation on archive failed");
	lstrval = -1;
	return(-1);
}

/*
 * ar_rev()
 *	move the i/o position within the archive backwards the specified byte
 *	count as supported by the device. With tapes drives we RESET rdblksz to
 *	the PHYSICAL blocksize.
 *	NOTE: We should only be called to move backwards so we can rewrite the
 *	last records (the trailer) of an archive (APPEND).
 * Return:
 *	0 if moved the requested distance, -1 on complete failure
 */

int
ar_rev(off_t sksz)
{
	off_t cpos;
	struct mtop mb;
	int phyblk;

	/*
	 * make sure we do not have try to reverse on a flawed archive
	 */
	if (lstrval < 0)
		return(lstrval);

	switch (artyp) {
	case ISPIPE:
		if (sksz <= 0)
			break;
		/*
		 * cannot go backwards on these critters
		 */
		paxwarn(1, "Reverse positioning on pipes is not supported.");
		lstrval = -1;
		return(-1);
	case ISREG:
	case ISBLK:
	case ISCHR:
	default:
		if (sksz <= 0)
			break;

		/*
		 * For things other than files, backwards movement has a very
		 * high probability of failure as we really do not know the
		 * true attributes of the device we are talking to (the device
		 * may not even have the ability to lseek() in any direction).
		 * First we figure out where we are in the archive.
		 */
		if ((cpos = lseek(arfd, 0, SEEK_CUR)) < 0) {
			syswarn(1, errno,
			   "Unable to obtain current archive byte offset");
			lstrval = -1;
			return(-1);
		}

		/*
		 * we may try to go backwards past the start when the archive
		 * is only a single record. If this happens and we are on a
		 * multi-volume archive, we need to go to the end of the
		 * previous volume and continue our movement backwards from
		 * there.
		 */
		if ((cpos -= sksz) < 0) {
			if (arvol > 1) {
				/*
				 * this should never happen
				 */
				paxwarn(1,"Reverse position on previous volume.");
				lstrval = -1;
				return(-1);
			}
			cpos = 0;
		}
		if (lseek(arfd, cpos, SEEK_SET) < 0) {
			syswarn(1, errno, "Unable to seek archive backwards");
			lstrval = -1;
			return(-1);
		}
		break;
	case ISTAPE:
		/*
		 * Calculate and move the proper number of PHYSICAL tape
		 * blocks. If the sksz is not an even multiple of the physical
		 * tape size, we cannot do the move (this should never happen).
		 * (We also cannot handle trailers spread over two vols.)
		 * get_phys() also makes sure we are in front of the filemark.
		 */
		if ((phyblk = get_phys()) <= 0) {
			lstrval = -1;
			return(-1);
		}

		/*
		 * make sure future tape reads only go by physical tape block
		 * size (set rdblksz to the real size).
		 */
		rdblksz = phyblk;

		/*
		 * if no movement is required, just return (we must be after
		 * get_phys() so the physical blocksize is properly set)
		 */
		if (sksz <= 0)
			break;

		/*
		 * ok we have to move. Make sure the tape drive can do it.
		 */
		if (sksz % phyblk) {
			paxwarn(1,
			    "Tape drive unable to backspace requested amount");
			lstrval = -1;
			return(-1);
		}

		/*
		 * move backwards the requested number of bytes
		 */
		mb.mt_op = MTBSR;
		mb.mt_count = sksz/phyblk;
		if (ioctl(arfd, MTIOCTOP, &mb) < 0) {
			syswarn(1,errno, "Unable to backspace tape %d blocks.",
			    mb.mt_count);
			lstrval = -1;
			return(-1);
		}
		break;
	}
	lstrval = 1;
	return(0);
}

/*
 * get_phys()
 *	Determine the physical block size on a tape drive. We need the physical
 *	block size so we know how many bytes we skip over when we move with
 *	mtio commands. We also make sure we are BEFORE THE TAPE FILEMARK when
 *	return.
 *	This is one really SLOW routine...
 * Return:
 *	physical block size if ok (ok > 0), -1 otherwise
 */

static int
get_phys(void)
{
	int padsz = 0;
	int res;
	int phyblk;
	struct mtop mb;
	char scbuf[MAXBLK];

	/*
	 * move to the file mark, and then back up one record and read it.
	 * this should tell us the physical record size the tape is using.
	 */
	if (lstrval == 1) {
		/*
		 * we know we are at file mark when we get back a 0 from
		 * read()
		 */
		while ((res = read(arfd, scbuf, sizeof(scbuf))) > 0)
			padsz += res;
		if (res < 0) {
			syswarn(1, errno, "Unable to locate tape filemark.");
			return(-1);
		}
	}

	/*
	 * move backwards over the file mark so we are at the end of the
	 * last record.
	 */
	mb.mt_op = MTBSF;
	mb.mt_count = 1;
	if (ioctl(arfd, MTIOCTOP, &mb) < 0) {
		syswarn(1, errno, "Unable to backspace over tape filemark.");
		return(-1);
	}

	/*
	 * move backwards so we are in front of the last record and read it to
	 * get physical tape blocksize.
	 */
	mb.mt_op = MTBSR;
	mb.mt_count = 1;
	if (ioctl(arfd, MTIOCTOP, &mb) < 0) {
		syswarn(1, errno, "Unable to backspace over last tape block.");
		return(-1);
	}
	if ((phyblk = read(arfd, scbuf, sizeof(scbuf))) <= 0) {
		syswarn(1, errno, "Cannot determine archive tape blocksize.");
		return(-1);
	}

	/*
	 * read forward to the file mark, then back up in front of the filemark
	 * (this is a bit paranoid, but should be safe to do).
	 */
	while ((res = read(arfd, scbuf, sizeof(scbuf))) > 0)
		continue;
	if (res < 0) {
		syswarn(1, errno, "Unable to locate tape filemark.");
		return(-1);
	}
	mb.mt_op = MTBSF;
	mb.mt_count = 1;
	if (ioctl(arfd, MTIOCTOP, &mb) < 0) {
		syswarn(1, errno, "Unable to backspace over tape filemark.");
		return(-1);
	}

	/*
	 * set lstrval so we know that the filemark has not been seen
	 */
	lstrval = 1;

	/*
	 * return if there was no padding
	 */
	if (padsz == 0)
		return(phyblk);

	/*
	 * make sure we can move backwards over the padding. (this should
	 * never fail).
	 */
	if (padsz % phyblk) {
		paxwarn(1, "Tape drive unable to backspace requested amount");
		return(-1);
	}

	/*
	 * move backwards over the padding so the head is where it was when
	 * we were first called (if required).
	 */
	mb.mt_op = MTBSR;
	mb.mt_count = padsz/phyblk;
	if (ioctl(arfd, MTIOCTOP, &mb) < 0) {
		syswarn(1,errno,"Unable to backspace tape over %d pad blocks",
		    mb.mt_count);
		return(-1);
	}
	return(phyblk);
}

/*
 * ar_next()
 *	prompts the user for the next volume in this archive. For some devices
 *	we may allow the media to be changed. Otherwise a new archive is
 *	prompted for. By pax spec, if there is no controlling tty or an eof is
 *	read on tty input, we must quit pax.
 * Return:
 *	0 when ready to continue, -1 when all done
 */

int
ar_next(void)
{
	char buf[PAXPATHLEN+2];
	static int freeit = 0;
	sigset_t o_mask;

	/*
	 * WE MUST CLOSE THE DEVICE. A lot of devices must see last close, (so
	 * things like writing EOF etc will be done) (Watch out ar_close() can
	 * also be called via a signal handler, so we must prevent a race.
	 */
	if (sigprocmask(SIG_BLOCK, &s_mask, &o_mask) < 0)
		syswarn(0, errno, "Unable to set signal mask");
	ar_close(0);
	if (sigprocmask(SIG_SETMASK, &o_mask, NULL) < 0)
		syswarn(0, errno, "Unable to restore signal mask");

	if (done || !wr_trail || force_one_volume || op_mode == OP_TAR)
		return(-1);

	tty_prnt("\nATTENTION! %s archive volume change required.\n", argv0);

	/*
	 * if i/o is on stdin or stdout, we cannot reopen it (we do not know
	 * the name), the user will be forced to type it in.
	 */
	if (strcmp(arcname, STDO) && strcmp(arcname, STDN) && (artyp != ISREG)
	    && (artyp != ISPIPE)) {
		if (artyp == ISTAPE) {
			tty_prnt("%s ready for archive tape volume: %d\n",
				arcname, arvol);
			tty_prnt("Load the NEXT TAPE on the tape drive");
		} else {
			tty_prnt("%s ready for archive volume: %d\n",
				arcname, arvol);
			tty_prnt("Load the NEXT STORAGE MEDIA (if required)");
		}

		if ((act == ARCHIVE) || (act == APPND))
			tty_prnt(" and make sure it is WRITE ENABLED.\n");
		else
			tty_prnt("\n");

		for (;;) {
			tty_prnt("Type \"y\" to continue, \".\" to quit %s,",
				argv0);
			tty_prnt(" or \"s\" to switch to new device.\nIf you");
			tty_prnt(" cannot change storage media, type \"s\"\n");
			tty_prnt("Is the device ready and online? > ");

			if ((tty_read(buf,sizeof(buf))<0) || !strcmp(buf,".")){
				done = 1;
				lstrval = -1;
				tty_prnt("Quitting %s!\n", argv0);
				vfpart = 0;
				return(-1);
			}

			if ((buf[0] == '\0') || (buf[1] != '\0')) {
				tty_prnt("%s unknown command, try again\n",buf);
				continue;
			}

			switch (buf[0]) {
			case 'y':
			case 'Y':
				/*
				 * we are to continue with the same device
				 */
				if (ar_open(arcname) >= 0)
					return(0);
				tty_prnt("Cannot re-open %s, try again\n",
					arcname);
				continue;
			case 's':
			case 'S':
				/*
				 * user wants to open a different device
				 */
				tty_prnt("Switching to a different archive\n");
				break;
			default:
				tty_prnt("%s unknown command, try again\n",buf);
				continue;
			}
			break;
		}
	} else
		tty_prnt("Ready for archive volume: %d\n", arvol);

	/*
	 * have to go to a different archive
	 */
	for (;;) {
		tty_prnt("Input archive name or \".\" to quit %s.\n", argv0);
		tty_prnt("Archive name > ");

		if ((tty_read(buf, sizeof(buf)) < 0) || !strcmp(buf, ".")) {
			done = 1;
			lstrval = -1;
			tty_prnt("Quitting %s!\n", argv0);
			vfpart = 0;
			return(-1);
		}
		if (buf[0] == '\0') {
			tty_prnt("Empty file name, try again\n");
			continue;
		}
		if (!strcmp(buf, "..")) {
			tty_prnt("Illegal file name: .. try again\n");
			continue;
		}
		if (strlen(buf) > PAXPATHLEN) {
			tty_prnt("File name too long, try again\n");
			continue;
		}

		/*
		 * try to open new archive
		 */
		if (ar_open(buf) >= 0) {
			if (freeit) {
				free((char *)arcname);
				freeit = 0;
			}
			if ((arcname = strdup(buf)) == NULL) {
				done = 1;
				lstrval = -1;
				paxwarn(0, "Cannot save archive name.");
				return(-1);
			}
			freeit = 1;
			break;
		}
		tty_prnt("Cannot open %s, try again\n", buf);
		continue;
	}
	return(0);
}

/*
 * ar_start_gzip()
 * starts the gzip compression/decompression process as a child, using magic
 * to keep the fd the same in the calling function (parent).
 */
void
ar_start_gzip(int fd, const char *path, int wr)
{
	int fds[2];
	const char *gzip_flags;

	if (pipe(fds) < 0)
		err(1, "could not pipe");
	zpid = fork();
	if (zpid < 0)
		err(1, "could not fork");

	/* parent */
	if (zpid) {
		if (wr)
			dup2(fds[1], fd);
		else
			dup2(fds[0], fd);
		close(fds[0]);
		close(fds[1]);

		if (pmode == 0 || (act != EXTRACT && act != COPY)) {
		    if (pledge("stdio rpath wpath cpath fattr dpath getpw proc tape",
			NULL) == -1)
				err(1, "pledge");
		}
	} else {
		if (wr) {
			dup2(fds[0], STDIN_FILENO);
			dup2(fd, STDOUT_FILENO);
			gzip_flags = "-c";
		} else {
			dup2(fds[1], STDOUT_FILENO);
			dup2(fd, STDIN_FILENO);
			gzip_flags = "-dc";
		}
		close(fds[0]);
		close(fds[1]);

		/* System compressors are more likely to use pledge(2) */
		putenv("PATH=/usr/bin:/usr/local/bin");

		if (execlp(path, path, gzip_flags, (char *)NULL) < 0)
			err(1, "could not exec %s", path);
		/* NOTREACHED */
	}
}
@


1.61
log
@Slow down the churn and continue using old pledge name "ioctl" instead
of "tape" for a week or so.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.60 2017/01/23 04:25:05 deraadt Exp $	*/
d1264 1
a1264 1
		    if (pledge("stdio rpath wpath cpath fattr dpath getpw proc ioctl",
@


1.60
log
@Split pledge "ioctl" into "tape" and "bpf", and allow SIOCGIFGROUP only
upon "inet".  Adjust the 4 programs that care about this.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.59 2016/08/26 04:31:35 guenther Exp $	*/
d1264 1
a1264 1
		    if (pledge("stdio rpath wpath cpath fattr dpath getpw proc tape",
@


1.59
log
@reduce and sort #includes
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.58 2016/08/23 06:00:28 guenther Exp $	*/
d1264 1
a1264 1
		    if (pledge("stdio rpath wpath cpath fattr dpath getpw ioctl proc",
@


1.58
log
@Instead of doing strcmp(argv0), track the invocation mode (pax/tar/cpio)
in a separate variable

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.57 2016/08/14 18:30:33 guenther Exp $	*/
a37 1
#include <sys/time.h>
d42 3
d46 2
a48 1
#include <fcntl.h>
d50 1
a50 4
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <err.h>
a51 1
#include "options.h"
@


1.57
log
@Remove many unnecessary casts.  Verified by comparing generated code on
both ILP32 and LP64.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.56 2016/06/03 23:22:20 tedu Exp $	*/
d393 1
a393 1
	if (strcmp(NM_PAX, argv0) == 0)
d398 1
a398 1
	else if (strcmp(NM_CPIO, argv0) == 0)
d1115 1
a1115 1
	if (done || !wr_trail || force_one_volume || strcmp(NM_TAR, argv0) == 0)
@


1.56
log
@new style overlords say to use continue in empty loops.
this is easier to see and self documenting.
ok openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.55 2015/12/06 16:57:45 deraadt Exp $	*/
d178 1
a178 1
	else if ((lseek(arfd, (off_t)0L, SEEK_CUR) == -1) && (errno == ESPIPE))
d465 1
a465 1
	if (((cpos = lseek(arfd, (off_t)0L, SEEK_CUR)) < 0) ||
d624 1
a624 1
			if ((cpos = lseek(arfd, (off_t)0L, SEEK_CUR)) < 0)
d626 1
a626 1
			cpos -= (off_t)res;
d760 1
a760 1
		if ((cpos = lseek(arfd, (off_t)0L, SEEK_CUR)) < 0)
d762 1
a762 1
		mpos = fsbz - (cpos % (off_t)fsbz);
d821 1
a821 1
	if ((cpos = lseek(arfd, (off_t)0L, SEEK_CUR)) >= 0) {
d889 1
a889 1
		if ((cpos = lseek(arfd, (off_t)0L, SEEK_CUR)) < 0) {
d903 1
a903 1
		if ((cpos -= sksz) < (off_t)0L) {
d912 1
a912 1
			cpos = (off_t)0L;
@


1.55
log
@pledge "dpath" to allow creation of nodes via mkfifo(2) and mknod(2)
NOTE: dpath requires a fairly new kernel
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.54 2015/10/14 20:57:28 deraadt Exp $	*/
d430 1
a430 1
		;
d1041 1
a1041 1
		;
@


1.54
log
@Use a strict $PATH of "/usr/bin:/usr/local/bin" to run the (de)compressors
(gzip, compress, bzip2) rather than following the user's path.  This
seems easier than hardcoding the paths elsewhere and using basename().

pax/tar is pledged itself, but it can spawn one of these programs if
asked.  The three found at the strict path use pledge "stdio" very early
during startup, providing a warm fuzzy pledge->exec->no-pledge->pledge
interlock.  For bzip2, this assumes use of the ports/packages version
installed to /usr/local/bin, which has been pledged by sthen@@.

Doing a 'tar tvfz hostile.tgz' becomes a bit safer, since an attacker
finding a buffer overflow or use after free has significantly fewer
system calls available (only pledge "stdio" in the decompressor).

ok millert sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.53 2015/10/12 14:01:06 semarie Exp $	*/
d1265 1
a1265 1
		    if (pledge("stdio rpath wpath cpath fattr getpw ioctl proc",
@


1.53
log
@reenable pledge(2) on pax, but only if pmode isn't in use or if action
shouldn't do things with filesystem.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.52 2015/10/12 09:28:54 semarie Exp $	*/
d1281 4
@


1.52
log
@Revert the pledge() call on pax/ar_io.c for now.

A pledged program is not allowed to change user/group for others.

"I think that makes the most sense" @@sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.51 2015/10/12 05:05:24 deraadt Exp $	*/
d1264 5
a1268 5
#if 0
		if (pledge("stdio rpath wpath cpath fattr getpw ioctl proc",
		    NULL) == -1)
			err(1, "pledge");
#endif
@


1.51
log
@preservation modes can adjust setugid bits, so no pledge is possible.
Otherwise, lay the groundwork for whether a gzip program may be run or not.
After such a gzip program is started, pledge the program will not exec
again.  Took a few iterations to get this going... it is looking good.
with guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.50 2015/03/22 03:15:00 guenther Exp $	*/
d1264 1
d1268 1
@


1.50
log
@rev 1.44 accidentally changed ar_close() to give cpio the same output as pax.
Adjust the conditions to correct that.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.49 2015/03/09 04:25:28 guenther Exp $	*/
d1263 4
@


1.49
log
@Fix comment grammar
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.48 2014/05/24 18:51:00 guenther Exp $	*/
d393 1
a393 1
	if (strcmp(NM_TAR, argv0) != 0)
@


1.48
log
@Delete pointless casts: free() return value to (void), free()'s
argument to (char *), and malloc/calloc's return value to the type
of the variable it's being assigned to.
Convert the one calloc() where the zeroing isn't needed to a reallocarray().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.47 2014/05/23 21:58:26 guenther Exp $	*/
d184 1
a184 1
	 * make sure we beyond any doubt that we only can unlink regular files
@


1.47
log
@Archives written with a non-standard blocksize currently show up as
truncated reads.  Until better detection of that case can is implemented,
back out that part of rev 1.45

problem noted by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.46 2014/05/23 19:47:49 guenther Exp $	*/
d1220 1
a1220 1
				(void)free((char *)arcname);
@


1.46
log
@Make the signal handler safe: block signals when updating data-structures
that are walked by routines called from the signal handler and use
dprintf() instead fprintf() in ar_close().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.45 2014/05/21 04:17:56 guenther Exp $	*/
d574 1
a574 1
		paxwarn(1, "End of archive volume %d reached", arvol);
@


1.45
log
@Exit with non-zero status if a read is truncated, or if a compression
program was used but it didn't exit successfully.

Original diff by mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.44 2014/01/11 05:36:26 deraadt Exp $	*/
d292 1
a292 1
 * ar_close()
d294 1
d297 1
a297 1
ar_close(void)
d305 2
d315 3
a317 6
		if (vfpart)
			(void)putc('\n', listf);
		(void)fprintf(listf,
			"%s: Waiting for tape drive close to complete...",
			argv0);
		(void)fflush(listf);
d350 1
a350 1
		(void)fputs("done.\n", listf);
a351 1
		(void)fflush(listf);
d377 1
a377 1
		(void)putc('\n', listf);
d387 2
a388 3
		(void)fprintf(listf, "%s: unknown format, %llu bytes skipped.\n",
		    argv0, rdcnt);
		(void)fflush(listf);
d394 2
a395 2
		(void)fprintf(listf,
		    "%s: %s vol %d, %lu files, %llu bytes read, %llu bytes written.\n",
d399 2
a400 1
		(void)fprintf(listf, "%llu blocks\n", (rdcnt ? rdcnt : wrcnt) / 5120);
a401 1
	(void)fflush(listf);
d1111 1
a1111 1
	ar_close();
@


1.44
log
@Add -DNOCPIO option for use by distrib/special
ok guenther tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.43 2014/01/08 05:52:47 guenther Exp $	*/
d334 1
a334 1
	if ((act == LIST || act == EXTRACT) && nflag && zpid > 0)
d336 2
d342 1
a342 1
	if (zpid > 0)
d344 4
d576 1
a576 1
		paxwarn(0, "End of archive volume %d reached", arvol);
@


1.43
log
@Replace strtoq(), QUAD_MAX, and %qu with their long long equivalent
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.42 2014/01/08 04:58:36 guenther Exp $	*/
d389 1
a389 3
	if (strcmp(NM_CPIO, argv0) == 0)
		(void)fprintf(listf, "%llu blocks\n", (rdcnt ? rdcnt : wrcnt) / 5120);
	else if (strcmp(NM_TAR, argv0) != 0)
d393 4
@


1.42
log
@Eliminate poisonous LONG_OFF_T conditional

adjective suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.41 2014/01/08 04:42:24 guenther Exp $	*/
d382 1
a382 1
		(void)fprintf(listf, "%s: unknown format, %qu bytes skipped.\n",
d390 1
a390 1
		(void)fprintf(listf, "%qu blocks\n", (rdcnt ? rdcnt : wrcnt) / 5120);
d393 1
a393 1
		    "%s: %s vol %d, %lu files, %qu bytes read, %qu bytes written.\n",
d662 1
a662 1
	 * if the format wants the header to start at a BLKMULT boundary.. While
@


1.41
log
@Rename arguments to avoid shadowing global variables

ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.40 2012/12/04 02:24:45 deraadt Exp $	*/
a381 3
#	ifdef LONG_OFF_T
		(void)fprintf(listf, "%s: unknown format, %lu bytes skipped.\n",
#	else
a382 1
#	endif
a392 3
#	ifdef LONG_OFF_T
		    "%s: %s vol %d, %lu files, %lu bytes read, %lu bytes written.\n",
#	else
a393 1
#	endif
@


1.40
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.39 2009/10/27 23:59:22 deraadt Exp $	*/
d1246 1
a1246 1
ar_start_gzip(int fd, const char *gzip_program, int wr)
d1277 2
a1278 2
		if (execlp(gzip_program, gzip_program, gzip_flags, (char *)NULL) < 0)
			err(1, "could not exec %s", gzip_program);
@


1.39
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.38 2008/06/11 00:49:08 pvalchev Exp $	*/
a41 1
#include <sys/param.h>
@


1.38
log
@Add tar -j option that calls bzip2 for compress/decompress. Requires
you to install the bzip2 pkg (or add bzip2 in another way).

ok millert@@ otto@@ deraadt@@ and 'many others'@@
man page tweak from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.37 2005/08/04 10:02:44 mpf Exp $	*/
a35 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)ar_io.c	8.2 (Berkeley) 4/18/94";
#else
static const char rcsid[] = "$OpenBSD: ar_io.c,v 1.37 2005/08/04 10:02:44 mpf Exp $";
#endif
#endif /* not lint */
@


1.37
log
@Make pax exit unsuccessfully on errors.
Patch by fgsch@@ and me.
Fixes PR 4310.
OK fgsch@@ otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.36 2004/06/20 16:22:08 niklas Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_io.c,v 1.36 2004/06/20 16:22:08 niklas Exp $";
d1287 1
a1287 1
			err(1, "could not exec");
@


1.36
log
@Do not go on if the -C option caused a failed chdir. ok millert@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.35 2004/04/16 22:50:23 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_io.c,v 1.35 2004/04/16 22:50:23 deraadt Exp $";
d125 1
a125 1
			syswarn(0, errno, "Failed open to read on %s", name);
d134 1
a134 1
			syswarn(0, errno, "Failed open to write on %s", name);
d145 1
a145 1
			syswarn(0, errno, "Failed open to read/write on %s",
d168 1
a168 1
		syswarn(0, errno, "Failed stat on %s", arcname);
@


1.35
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.34 2003/09/08 20:19:51 tedu Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_io.c,v 1.34 2003/09/08 20:19:51 tedu Exp $";
d160 1
a160 1
		if (chdir(chdname) != 0)
d162 2
@


1.34
log
@fix pr3455 from Joerg.Sonnenberger.  slightly improved fix suggested by
millert@@.  ok beck@@ deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.33 2003/06/02 23:32:08 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_io.c,v 1.33 2003/06/02 23:32:08 millert Exp $";
d212 1
a212 1
	switch(artyp) {
d739 1
a739 1
	switch(artyp) {
d874 1
a874 1
	switch(artyp) {
d1150 1
a1150 1
		for(;;) {
@


1.33
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.32 2003/02/03 09:06:42 jmc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_io.c,v 1.32 2003/02/03 09:06:42 jmc Exp $";
d305 1
d341 1
a341 2
	if ((act == LIST || act == EXTRACT) && nflag && zpid > 0) {
		int status;
a342 2
		waitpid(zpid, &status, 0);
	}
d345 4
@


1.32
log
@typos;
from netbsd(svs+pr@@grep.ru)
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.31 2002/11/29 09:27:34 deraadt Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_io.c,v 1.31 2002/11/29 09:27:34 deraadt Exp $";
@


1.31
log
@Foward; torh@@bogus.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.30 2002/10/18 15:38:11 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: ar_io.c,v 1.30 2002/10/18 15:38:11 millert Exp $";
d212 2
a213 2
	 * specified one, otherwize we will continue to use rdblksz). We
	 * must to set blocksize based on what kind of device the archive is
d544 1
a544 1
				 * Record size changed. If this is happens on
d547 1
a547 1
				 * we are getting multiple records in a single
d727 1
a727 1
	 * Fail resync attempts at user request (done) or this is going to be
d909 2
a910 2
		 * is only a single record. If this hapens and we are on a
		 * multi volume archive, we need to go to the end of the
d936 1
a936 1
		 * (We also cannot handler trailers spread over two vols).
@


1.30
log
@Pull in some changes from NetBSD
o When extracting GNU tar archives, honor @@LongLink long links/files
o Add an option to prevent pax from prompting for the next volume
  upon premature end of archive.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.29 2002/10/16 19:20:02 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: ar_io.c,v 1.29 2002/10/16 19:20:02 millert Exp $";
d847 1
a847 1
	syswarn(1, errno, "Foward positioning operation on archive failed");
@


1.29
log
@sprinkle const; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.28 2002/10/16 18:40:30 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: ar_io.c,v 1.28 2002/10/16 18:40:30 millert Exp $";
d92 1
d1126 1
a1126 1
	if (done || !wr_trail || strcmp(NM_TAR, argv0) == 0)
@


1.28
log
@Fix comment typos; most from NetBSD and FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.27 2002/10/16 17:43:10 millert Exp $	*/
d43 1
a43 1
static char sccsid[] = "@@(#)ar_io.c	8.2 (Berkeley) 4/18/94";
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.27 2002/10/16 17:43:10 millert Exp $";
d89 1
a89 1
char *arcname;				/* printable name of archive */
d107 1
a107 1
ar_open(char *name)
d1230 1
a1230 1
				(void)free(arcname);
d1257 1
a1257 1
	char *gzip_flags;
@


1.27
log
@kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.26 2002/02/19 19:39:35 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.26 2002/02/19 19:39:35 millert Exp $";
d76 2
a77 2
#define STDO		"<STDOUT>"	/* psuedo name for stdout */
#define STDN		"<STDIN>"	/* psuedo name for stdin */
d278 1
a278 1
		 * When we cannont find a match, we may have a flawed archive.
d292 1
a292 1
		 * should never happen, worse case, slow...
d678 1
a678 1
	 * if the format wants the header to start at a BLKMULT boundry. While
d746 1
a746 1
		 * to move the tape foward one PHYSICAL record past any
d795 1
a795 1
 *	Move the I/O position within the archive foward the specified number of
d814 1
a814 1
	 * we cannot move foward at EOF or error
d823 1
a823 1
	 * size at this point), so we must only read foward on tapes!
d1047 1
a1047 1
	 * read foward to the file mark, then back up in front of the filemark
@


1.26
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.25 2002/02/16 21:27:07 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.25 2002/02/16 21:27:07 millert Exp $";
d425 1
a425 1
	register int res;
d517 1
a517 1
ar_read(register char *buf, register int cnt)
d519 1
a519 1
	register int res = 0;
d600 1
a600 1
ar_write(register char *buf, register int bsz)
d602 1
a602 1
	register int res;
d867 1
a867 1
	register int phyblk;
d997 3
a999 3
	register int padsz = 0;
	register int res;
	register int phyblk;
@


1.25
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.24 2001/09/19 10:58:07 mpech Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.24 2001/09/19 10:58:07 mpech Exp $";
a105 1
#ifdef __STDC__
a107 5
#else
int
ar_open(name)
	char *name;
#endif
a304 1
#ifdef __STDC__
a306 4
#else
void
ar_close()
#endif
a421 1
#ifdef __STDC__
a423 4
#else
void
ar_drain()
#endif
a453 1
#ifdef __STDC__
a455 4
#else
int
ar_set_wr()
#endif
a491 1
#ifdef __STDC__
a493 4
#else
int
ar_app_ok()
#endif
a515 1
#ifdef __STDC__
a517 6
#else
int
ar_read(buf, cnt)
	register char *buf;
	register int cnt;
#endif
a598 1
#ifdef __STDC__
a600 6
#else
int
ar_write(buf, bsz)
	register char *buf;
	register int bsz;
#endif
a716 1
#ifdef __STDC__
a718 4
#else
int
ar_rdsync()
#endif
a802 1
#ifdef __STDC__
a804 6
#else
int
ar_fow(sksz, skipped)
	off_t sksz;
	off_t *skipped;
#endif
a861 1
#ifdef __STDC__
a863 5
#else
int
ar_rev(sksz)
	off_t sksz;
#endif
a993 1
#ifdef __STDC__
a995 4
#else
static int
get_phys()
#endif
a1106 1
#ifdef __STDC__
a1108 4
#else
int
ar_next()
#endif
@


1.24
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok

p.s. Next commit will fix a typo in the sys/
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.23 2001/07/09 07:04:26 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.23 2001/07/09 07:04:26 deraadt Exp $";
d93 1
a93 1
static int get_phys __P((void));
d95 1
a95 1
static void ar_start_gzip __P((int, const char *, int));
@


1.23
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.22 2001/05/26 00:32:20 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.22 2001/05/26 00:32:20 millert Exp $";
d629 1
a629 1
 *	error in the archive occured.
@


1.22
log
@Get rid of NET2_FTS and NET2_REGEX #ifdefs since they are useless.
Change NET2_STAT into LONG_OFF_T for portability to systems with
a 32bit off_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.21 2001/05/16 03:04:54 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.21 2001/05/16 03:04:54 mickey Exp $";
d1353 1
a1353 1
		if (execlp(gzip_program, gzip_program, gzip_flags, NULL) < 0)
@


1.21
log
@use proper str*cpy functions instead of home grown one, spaces; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.20 2000/06/09 16:37:54 espie Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.20 2000/06/09 16:37:54 espie Exp $";
d401 1
a401 1
#	ifdef NET2_STAT
d416 1
a416 1
#	ifdef NET2_STAT
@


1.20
log
@Some minor cleanup, ok'd millert@@
- remove zflag variable, since gzip_program is enough to know what's
going on.
- fix ar_gzip call to not depend on global variables. Avoid bogus act
checks, avoid calling if fd == -1.
- do gzip check for append as early as possible.
- remove old K&R prototype when updating.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.19 1999/08/04 17:13:24 espie Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.19 1999/08/04 17:13:24 espie Exp $";
d298 1
a298 1
		 * should never happen, worse case, slow... 
d486 1
a486 1
	/* 
d507 1
a507 1
 *	this until we are ready to write since there is no spec that says all 
d670 1
a670 1
		 	 * try to fix up partial writes which are not BLKMULT
d673 1
a673 1
		 	 */
d884 2
a885 2
		/* 
	 	 * we can be asked to move farther than there are bytes in this
d889 1
a889 1
	 	 */
d990 1
a990 1
	 	 * Calculate and move the proper number of PHYSICAL tape
d995 1
a995 1
	 	 */
d1044 1
a1044 1
 *	block size so we know how many bytes we skip over when we move with 
@


1.19
log
@Kill gzip subprocess correctly instead of letting it get a SIGPIPE when
using pax -n to list/extract.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.18 1998/09/20 02:22:21 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.18 1998/09/20 02:22:21 millert Exp $";
d90 1
a90 1
char *gzip_program;			/* name of gzip program */
d95 1
a95 1
static void ar_start_gzip __P((int));
d135 2
a136 2
		if (zflag)
			ar_start_gzip(arfd);
d146 2
a147 2
		if (zflag)
			ar_start_gzip(arfd);
a149 2
		if (zflag)
			err(1, "can not gzip while appending");
d1322 1
a1322 6
#ifdef __STDC__
ar_start_gzip(int fd)
#else
ar_start_gzip(fd)
	int fd;
#endif
d1335 1
a1335 2
		switch (act) {
		case ARCHIVE:
d1337 1
a1337 3
			break;
		case LIST:
		case EXTRACT:
a1338 4
			break;
		default:
			errx(1, "ar_start_gzip:  impossible");
		}
d1342 1
a1342 2
		switch (act) {
		case ARCHIVE:
d1346 1
a1346 3
			break;
		case LIST:
		case EXTRACT:
a1349 3
			break;
		default:
			errx(1, "ar_start_gzip:  impossible");
@


1.18
log
@When invoked as tar, print verbose output to stdout, not stderr.  If in list mode or in create mode where create output is to stdout print to stderr
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.17 1997/09/01 18:29:42 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.17 1997/09/01 18:29:42 deraadt Exp $";
d55 1
d91 1
d352 10
a1330 1
	pid_t pid;
d1336 2
a1337 2
	pid = fork();
	if (pid < 0)
d1341 1
a1341 1
	if (pid) {
@


1.17
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.16 1997/07/25 18:58:21 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.16 1997/07/25 18:58:21 mickey Exp $";
a318 1
	FILE *outf;
a324 5
	if (act == LIST)
		outf = stdout;
	else
		outf = stderr;

d333 2
a334 2
			(void)putc('\n', outf);
		(void)fprintf(outf,
d337 1
a337 1
		(void)fflush(outf);
d353 1
a353 1
		(void)fputs("done.\n", outf);
d355 1
a355 1
		(void)fflush(outf);
d381 1
a381 1
		(void)putc('\n', outf);
d392 1
a392 1
		(void)fprintf(outf, "%s: unknown format, %lu bytes skipped.\n",
d394 1
a394 1
		(void)fprintf(outf, "%s: unknown format, %qu bytes skipped.\n",
d397 1
a397 1
		(void)fflush(outf);
d403 1
a403 1
		(void)fprintf(outf, "%qu blocks\n", (rdcnt ? rdcnt : wrcnt) / 5120);
d405 1
a405 1
		(void)fprintf(outf,
d412 1
a412 1
	(void)fflush(outf);
@


1.16
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.15 1997/07/23 19:15:53 kstailey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.15 1997/07/23 19:15:53 kstailey Exp $";
d481 1
a481 1
	
d615 1
a615 1
} 
d733 2
a734 2
		
	if (res == 0) 
d814 1
a814 1
		if (lseek(arfd, mpos, SEEK_CUR) < 0) 
d873 1
a873 1
	if (artyp != ISREG) 
d921 1
a921 1
	register int phyblk; 
d931 1
a931 1
		if (sksz <= 0) 
d1241 1
a1241 1
				if (ar_open(arcname) >= 0) 
@


1.15
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.14 1997/06/18 18:48:23 kstailey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.14 1997/06/18 18:48:23 kstailey Exp $";
d104 1
a104 1
#if __STDC__
d311 1
a311 1
#if __STDC__
d429 1
a429 1
#if __STDC__
d466 1
a466 1
#if __STDC__
d509 1
a509 1
#if __STDC__
d538 1
a538 1
#if __STDC__
d628 1
a628 1
#if __STDC__
d753 1
a753 1
#if __STDC__
d844 1
a844 1
#if __STDC__
d910 1
a910 1
#if __STDC__
d1048 1
a1048 1
#if __STDC__
d1166 1
a1166 1
#if __STDC__
@


1.14
log
@(foo *)NULL -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.13 1997/03/25 09:30:19 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.13 1997/03/25 09:30:19 millert Exp $";
d88 1
a88 1
char *arcname;                  	/* printable name of archive */
d113 1
a113 1
        struct mtget mb;
d764 1
a764 1
        struct mtop mb;
d920 1
a920 1
        struct mtop mb;
d1280 4
a1283 4
                if (!strcmp(buf, "..")) {
                        tty_prnt("Illegal file name: .. try again\n");
                        continue;
                }
@


1.13
log
@Back out my previous kludge to make tar files with short trailers work in
favor of a simpler change--never try to do a media change when invoked
as tar.  This fixes problems that crop up if gzip exits unhappily and
others.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.12 1997/03/02 20:42:56 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.12 1997/03/02 20:42:56 tholo Exp $";
d1186 1
a1186 1
	if (sigprocmask(SIG_SETMASK, &o_mask, (sigset_t *)NULL) < 0)
@


1.12
log
@Say how many blocks were read/written in cpio mode
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.11 1997/02/27 23:32:56 michaels Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.11 1997/02/27 23:32:56 michaels Exp $";
d1189 1
a1189 1
	if (done || !wr_trail)
@


1.11
log
@fix pr system/124, reported by Janjaap van Velthooven (janjaap@@stack.nl).
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.10 1997/02/20 06:54:31 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.10 1997/02/20 06:54:31 tholo Exp $";
d408 3
a410 1
	if (strcmp(NM_TAR, argv0) != 0 && strcmp(NM_CPIO, argv0) != 0)
@


1.10
log
@cpio emulation for pax
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.9 1997/02/16 07:51:12 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.9 1997/02/16 07:51:12 tholo Exp $";
d168 3
@


1.9
log
@Don't give summary line at end when using tar format
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.8 1996/12/09 12:00:13 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.8 1996/12/09 12:00:13 deraadt Exp $";
d405 1
a405 1
	if (strcmp(NM_TAR, argv0) != 0)
@


1.8
log
@revert to spawning compress-ing program. normally we want extracts using
'z' to also work on .Z files, but libz does not deal with compressed
data. Hacking the code to deal well with pipes has proven very hard.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.4 1996/06/23 14:20:28 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.7 1996/11/24 18:15:59 millert Exp $";
d64 1
d405 2
a406 1
	(void)fprintf(outf,
d408 1
a408 1
	    "%s: %s vol %d, %lu files, %lu bytes read, %lu bytes written.\n",
d410 1
a410 1
	    "%s: %s vol %d, %lu files, %qu bytes read, %qu bytes written.\n",
d412 1
a412 1
	    argv0, frmt->name, arvol-1, flcnt, rdcnt, wrcnt);
@


1.7
log
@Fix core dump if -xz and archive does not exist (doh!)
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.6 1996/10/27 00:29:40 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.6 1996/10/27 00:29:40 millert Exp $";
a62 1
#include <zlib.h>
a86 2
static gzFile gzf;			/* file pointer for gzip archives */
static FILE *cfp;			/* file pointer for compress archives */
d88 1
a89 1
FILE *zdopen __P((int, const char *));
d92 1
d114 2
a115 8
	if (arfd != -1) {
		if (zflag == GZIP_CMP)
			(void)gzclose(gzf);
		else if (zflag == COMPRESS_CMP)
			(void)fclose(cfp);
		else
			(void)close(arfd);
	}
d132 2
a133 9
		if (zflag == GZIP_CMP) {
			gzf = gzdopen(arfd, "r");
			if (gzf && !gz_iszipped(gzf)) {
				(void)lseek(arfd, 0, SEEK_SET);
				zflag = COMPRESS_CMP;
			}
		}
		if (zflag == COMPRESS_CMP)
			cfp = zdopen(arfd, "r");
d143 2
a144 4
		if (zflag == GZIP_CMP)
			gzf = gzdopen(arfd, "w");
		else if (zflag == COMPRESS_CMP)
			cfp = zdopen(arfd, "w");
d148 1
a148 1
			err(1, "can not compress while appending");
d172 1
a172 6
		if (zflag == GZIP_CMP)
			(void)gzclose(gzf);
		else if (zflag == COMPRESS_CMP)
			(void)fclose(cfp);
		else
			(void)close(arfd);
d180 1
a180 6
		if (zflag == GZIP_CMP)
			(void)gzclose(gzf);
		else if (zflag == COMPRESS_CMP)
			(void)fclose(cfp);
		else
			(void)close(arfd);
d352 1
a352 6
	if (zflag == GZIP_CMP)
		(void)gzclose(gzf);
	else if (zflag == COMPRESS_CMP)
		(void)fclose(cfp);
	else
		(void)close(arfd);
d444 2
a445 12
	if (zflag == GZIP_CMP) {
		while ((res = gzread(gzf, drbuf, sizeof(drbuf))) > 0)
			;
	}
	else if (zflag == COMPRESS_CMP) {
		while ((res = fread(drbuf, 1, sizeof(drbuf), cfp)) > 0)
			;
	}
	else {
		while ((res = read(arfd, drbuf, sizeof(drbuf))) > 0)
			;
	}
a514 5
	if (zflag) {
		paxwarn(1, "Cannot append to a compressed archive.");
		return(-1);
	}

d554 10
a563 2
		if (!zflag) {
			if ((res = read(arfd, buf, cnt)) > 0) {
d565 7
a571 5
				 * CAUTION: tape systems may not always return the same
				 * sized records so we leave blksz == MAXBLK. The
				 * physical record size that a tape drive supports is
				 * very hard to determine in a uniform and portable
				 * manner.
d573 3
a575 16
				io_ok = 1;
				if (res != rdblksz) {
					/*
					 * Record size changed. If this is happens on
					 * any record after the first, we probably have
					 * a tape drive which has a fixed record size
					 * we are getting multiple records in a single
					 * read). Watch out for record blocking that
					 * violates pax spec (must be a multiple of
					 * BLKMULT).
					 */
					rdblksz = res;
					if (rdblksz % BLKMULT)
						invld_rec = 1;
				}
				return(res);
d577 1
a577 1
			break;
d579 1
d592 3
a594 17
		if (zflag == GZIP_CMP) {
			if ((res = gzread(gzf, buf, cnt)) > 0) {
				io_ok = 1;
				return(res);
			}
		}
		else if (zflag == COMPRESS_CMP) {
			if ((res = fread(buf, 1, cnt, cfp)) > 0) {
				io_ok = 1;
				return(res);
			}
		}
		else {
			if ((res = read(arfd, buf, cnt)) > 0) {
				io_ok = 1;
				return(res);
			}
d641 4
a644 20
	if (zflag == GZIP_CMP) {
		if ((res = gzwrite(gzf, buf, bsz)) == bsz) {
			wr_trail = 1;
			io_ok = 1;
			return(bsz);
		}
	}
	else if (zflag == COMPRESS_CMP) {
		if ((res = fwrite(buf, 1, bsz, cfp)) == bsz) {
			wr_trail = 1;
			io_ok = 1;
			return(bsz);
		}
	}
	else {
		if ((res = write(arfd, buf, bsz)) == bsz) {
			wr_trail = 1;
			io_ok = 1;
			return(bsz);
		}
d655 9
a663 15
	if (!zflag) {
		switch (artyp) {
		case ISREG:
			if ((res > 0) && (res % BLKMULT)) {
				/*
			 	 * try to fix up partial writes which are not BLKMULT
				 * in size by forcing the runt record to next archive
				 * volume
			 	 */
				if ((cpos = lseek(arfd, (off_t)0L, SEEK_CUR)) < 0)
					break;
				cpos -= (off_t)res;
				if (ftruncate(arfd, cpos) < 0)
					break;
				res = lstrval = 0;
d665 2
a666 2
			}
			if (res >= 0)
d668 1
a668 5
			/*
			 * if file is out of space, handle it like a return of 0
			 */
			if ((errno == ENOSPC) || (errno == EFBIG) || (errno == EDQUOT))
				res = lstrval = 0;
d670 2
a671 16
		case ISTAPE:
		case ISCHR:
		case ISBLK:
			if (res >= 0)
				break;
			if (errno == EACCES) {
				paxwarn(0, "Write failed, archive is write protected.");
				res = lstrval = 0;
				return(0);
			}
			/*
			 * see if we reached the end of media, if so force a change to
			 * the next volume
			 */
			if ((errno == ENOSPC) || (errno == EIO) || (errno == ENXIO))
				res = lstrval = 0;
d673 10
a682 5
		case ISPIPE:
		default:
			/*
			 * we cannot fix errors to these devices
			 */
d684 4
d689 13
d774 12
a785 22
	if (zflag)
		io_ok = 0;
	else {
		switch(artyp) {
		case ISTAPE:
			/*
		 	 * if the last i/o was a successful data transfer, we assume
		 	 * the fault is just a bad record on the tape that we are now
		 	 * past. If we did not get any data since the last resync try
		 	 * to move the tape foward one PHYSICAL record past any
		 	 * damaged tape section. Some tape drives are stubborn and need
		 	 * to be pushed.
		 	 */
			if (io_ok) {
				io_ok = 0;
				lstrval = 1;
				break;
			}
			mb.mt_op = MTFSR;
			mb.mt_count = 1;
			if (ioctl(arfd, MTIOCTOP, &mb) < 0)
				break;
d788 17
a804 15
		case ISREG:
		case ISCHR:
		case ISBLK:
			/*
		 	 * try to step over the bad part of the device.
		 	 */
			io_ok = 0;
			if (((fsbz = arsb.st_blksize) <= 0) || (artyp != ISREG))
				fsbz = BLKMULT;
			if ((cpos = lseek(arfd, (off_t)0L, SEEK_CUR)) < 0)
				break;
			mpos = fsbz - (cpos % (off_t)fsbz);
			if (lseek(arfd, mpos, SEEK_CUR) < 0) 
				break;
			lstrval = 1;
d806 2
a807 6
		case ISPIPE:
		default:
			/*
		 	 * cannot recover on these archive device types
		 	 */
			io_ok = 0;
d809 9
a817 1
		}
d851 1
a851 1
	if (zflag || sksz <= 0)
a921 13
	if (zflag) {
		if (sksz <= 0) {
			lstrval = 1;
			return 0;
		}
		/*
		 * cannot go backwards on these critters
		 */
		paxwarn(1, "Reverse positioning on pipes is not supported.");
		lstrval = -1;
		return(-1);
	}

a1054 5
	if (zflag) {
		syswarn(1, errno, "Cannot determine archive tape blocksize.");
		return(-1);
	}

d1303 62
@


1.6
log
@-z can now list/extra compressed files too.  Uses new gz_iszipped() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.5 1996/09/22 20:09:53 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.5 1996/09/22 20:09:53 tholo Exp $";
d142 1
a142 1
			if (!gz_iszipped(gzf)) {
@


1.5
log
@Use zopen for compress-style compressed archives
Use libz for gzip-style compressed archives
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.4 1996/06/23 14:20:28 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.4 1996/06/23 14:20:28 deraadt Exp $";
d140 1
a140 1
		if (zflag == GZIP_CMP)
d142 6
a147 1
		else if (zflag == COMPRESS_CMP)
@


1.4
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.5 1996/03/26 23:54:13 mrg Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: ar_io.c,v 1.5 1996/03/26 23:54:13 mrg Exp $";
d63 1
d88 2
a90 1
char *gzip_program;			/* name of gzip program */
d92 1
a94 1
static void ar_start_gzip __P((int));
d116 8
a123 2
	if (arfd != -1)
		(void)close(arfd);
d140 4
a143 2
		if (zflag)
			ar_start_gzip(arfd);
d153 4
a156 2
		if (zflag)
			ar_start_gzip(arfd);
d160 1
a160 1
			err(1, "can not gzip while appending");
d184 6
a189 1
		(void)close(arfd);
d197 6
a202 1
		(void)close(arfd);
d374 6
a379 1
	(void)close(arfd);
d471 12
a482 2
	while ((res = read(arfd, drbuf, sizeof(drbuf))) > 0)
		;
d552 5
d596 2
a597 10
		if ((res = read(arfd, buf, cnt)) > 0) {
			/*
			 * CAUTION: tape systems may not always return the same
			 * sized records so we leave blksz == MAXBLK. The
			 * physical record size that a tape drive supports is
			 * very hard to determine in a uniform and portable
			 * manner.
			 */
			io_ok = 1;
			if (res != rdblksz) {
d599 5
a603 7
				 * Record size changed. If this is happens on
				 * any record after the first, we probably have
				 * a tape drive which has a fixed record size
				 * we are getting multiple records in a single
				 * read). Watch out for record blocking that
				 * violates pax spec (must be a multiple of
				 * BLKMULT).
d605 16
a620 3
				rdblksz = res;
				if (rdblksz % BLKMULT)
					invld_rec = 1;
d622 1
a622 1
			return(res);
a623 1
		break;
d636 17
a652 3
		if ((res = read(arfd, buf, cnt)) > 0) {
			io_ok = 1;
			return(res);
d699 20
a718 4
	if ((res = write(arfd, buf, bsz)) == bsz) {
		wr_trail = 1;
		io_ok = 1;
		return(bsz);
d729 15
a743 9
	switch (artyp) {
	case ISREG:
		if ((res > 0) && (res % BLKMULT)) {
			/*
		 	 * try to fix up partial writes which are not BLKMULT
			 * in size by forcing the runt record to next archive
			 * volume
		 	 */
			if ((cpos = lseek(arfd, (off_t)0L, SEEK_CUR)) < 0)
d745 2
a746 2
			cpos -= (off_t)res;
			if (ftruncate(arfd, cpos) < 0)
d748 5
a752 1
			res = lstrval = 0;
d754 16
a769 2
		}
		if (res >= 0)
d771 5
a775 10
		/*
		 * if file is out of space, handle it like a return of 0
		 */
		if ((errno == ENOSPC) || (errno == EFBIG) || (errno == EDQUOT))
			res = lstrval = 0;
		break;
	case ISTAPE:
	case ISCHR:
	case ISBLK:
		if (res >= 0)
a776 4
		if (errno == EACCES) {
			paxwarn(0, "Write failed, archive is write protected.");
			res = lstrval = 0;
			return(0);
a777 13
		/*
		 * see if we reached the end of media, if so force a change to
		 * the next volume
		 */
		if ((errno == ENOSPC) || (errno == EIO) || (errno == ENXIO))
			res = lstrval = 0;
		break;
	case ISPIPE:
	default:
		/*
		 * we cannot fix errors to these devices
		 */
		break;
d850 30
a879 11
	switch(artyp) {
	case ISTAPE:
		/*
		 * if the last i/o was a successful data transfer, we assume
		 * the fault is just a bad record on the tape that we are now
		 * past. If we did not get any data since the last resync try
		 * to move the tape foward one PHYSICAL record past any
		 * damaged tape section. Some tape drives are stubborn and need
		 * to be pushed.
		 */
		if (io_ok) {
d881 7
d890 7
a897 29
		mb.mt_op = MTFSR;
		mb.mt_count = 1;
		if (ioctl(arfd, MTIOCTOP, &mb) < 0)
			break;
		lstrval = 1;
		break;
	case ISREG:
	case ISCHR:
	case ISBLK:
		/*
		 * try to step over the bad part of the device.
		 */
		io_ok = 0;
		if (((fsbz = arsb.st_blksize) <= 0) || (artyp != ISREG))
			fsbz = BLKMULT;
		if ((cpos = lseek(arfd, (off_t)0L, SEEK_CUR)) < 0)
			break;
		mpos = fsbz - (cpos % (off_t)fsbz);
		if (lseek(arfd, mpos, SEEK_CUR) < 0) 
			break;
		lstrval = 1;
		break;
	case ISPIPE:
	default:
		/*
		 * cannot recover on these archive device types
		 */
		io_ok = 0;
		break;
d931 1
a931 1
	if (sksz <= 0)
d1002 13
d1148 5
a1400 62
}

/*
 * ar_start_gzip()
 * starts the gzip compression/decompression process as a child, using magic
 * to keep the fd the same in the calling function (parent).
 */
void
#ifdef __STDC__
ar_start_gzip(int fd)
#else
ar_start_gzip(fd)
	int fd;
#endif
{
	pid_t pid;
	int fds[2];
	char *gzip_flags;

	if (pipe(fds) < 0)
		err(1, "could not pipe");
	pid = fork();
	if (pid < 0)
		err(1, "could not fork");

	/* parent */
	if (pid) {
		switch (act) {
		case ARCHIVE:
			dup2(fds[1], fd);
			break;
		case LIST:
		case EXTRACT:
			dup2(fds[0], fd);
			break;
		default:
			errx(1, "ar_start_gzip:  impossible");
		}
		close(fds[0]);
		close(fds[1]);
	} else {
		switch (act) {
		case ARCHIVE:
			dup2(fds[0], STDIN_FILENO);
			dup2(fd, STDOUT_FILENO);
			gzip_flags = "-c";
			break;
		case LIST:
		case EXTRACT:
			dup2(fds[1], STDOUT_FILENO);
			dup2(fd, STDIN_FILENO);
			gzip_flags = "-dc";
			break;
		default:
			errx(1, "ar_start_gzip:  impossible");
		}
		close(fds[0]);
		close(fds[1]);
		if (execlp(gzip_program, gzip_program, gzip_flags, NULL) < 0)
			err(1, "could not exec");
		/* NOTREACHED */
	}
@


1.3
log
@Correct compile warnings
Rename warn() to paxwarn() so <err.h> can be included

Remove #include <ctype.h> when not needed; from FreeBSD
@
text
@d1 1
d45 1
a45 1
static char rcsid[] = "$NetBSD: ar_io.c,v 1.5 1996/03/26 23:54:13 mrg Exp $";
@


1.2
log
@from mrg; impliment -z (gzip) in pax and tar, and -Z (compress) in tar
@
text
@a58 1
#include <ctype.h>
d61 1
d177 1
a177 1
		warn(0, "Cannot write an archive on top of a directory %s",
d510 1
a510 1
		warn(1, "Cannot append to an archive obtained from a pipe.");
d516 1
a516 1
	warn(1,"Cannot append, device record size %d does not support %s spec",
d605 1
a605 1
		warn(0, "End of archive volume %d reached", arvol);
d684 1
a684 1
			warn(0, "Write failed, archive is write protected.");
d722 1
a722 1
		warn(1,"Unable to append, trailer re-write failed. Quitting.");
d727 1
a727 1
		warn(0, "End of archive volume %d reached", arvol);
d731 1
a731 1
		warn(0,"WARNING: partial archive write. Archive MAY BE FLAWED");
d733 1
a733 1
		warn(1,"WARNING: partial archive write. Archive IS FLAWED");
d767 1
a767 1
		warn(1, "Cannot allow updates to an archive with flaws.");
d819 1
a819 1
		warn(1, "Unable to recover from an archive read failure.");
d822 1
a822 1
	warn(0, "Attempting to recover from an archive read failure.");
d928 1
a928 1
		warn(1, "Reverse positioning on pipes is not supported.");
d964 1
a964 1
				warn(1,"Reverse position on previous volume.");
d1006 1
a1006 1
			warn(1,
d1130 1
a1130 1
		warn(1, "Tape drive unable to backspace requested amount");
d1292 1
a1292 1
				warn(0, "Cannot save archive name.");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ar_io.c,v 1.4 1995/03/21 09:07:04 cgd Exp $	*/
d44 1
a44 1
static char rcsid[] = "$NetBSD: ar_io.c,v 1.4 1995/03/21 09:07:04 cgd Exp $";
d87 1
d91 1
d131 2
d142 2
d146 2
d1302 62
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
