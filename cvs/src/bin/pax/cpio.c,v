head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.2
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.27.0.6
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.10
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.14
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.12
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.10
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.8
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.5.0.16
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2016.08.26.04.11.16;	author guenther;	state Exp;
branches;
next	1.29;
commitid	JeDGCh3Baf9wzXzL;

1.29
date	2016.08.14.18.30.33;	author guenther;	state Exp;
branches;
next	1.28;
commitid	qmsIw7NlXw1nDUYx;

1.28
date	2016.08.14.04.47.52;	author guenther;	state Exp;
branches;
next	1.27;
commitid	KTreFUOYbPKrm5vY;

1.27
date	2015.03.19.05.14.24;	author guenther;	state Exp;
branches;
next	1.26;
commitid	s0WKwITEr5aJPBA2;

1.26
date	2015.03.17.03.23.17;	author guenther;	state Exp;
branches;
next	1.25;
commitid	gv8qhyah1XKC6RDB;

1.25
date	2014.02.19.03.59.47;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2014.01.08.05.52.47;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2014.01.08.04.58.36;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2013.07.03.04.08.29;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2013.05.25.13.33.47;	author lum;	state Exp;
branches;
next	1.20;

1.20
date	2012.12.04.02.24.45;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2008.01.01.16.22.44;	author tobias;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.16.22.50.23;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.26.00.10.17;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.32.08;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.03.09.06.43;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.16.19.20.02;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.10.16.18.40.30;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.16.17.43.10;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.09.02.35.27;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.26.00.32.21;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.16.03.04.56;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.07.25.18.58.28;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.07.23.19.15.56;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.20.31;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.06.41.49;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.16;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Don't need <sys/time.h> or "options.h" here
@
text
@/*	$OpenBSD: cpio.c,v 1.29 2016/08/14 18:30:33 guenther Exp $	*/
/*	$NetBSD: cpio.c,v 1.5 1995/03/21 09:07:13 cgd Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <limits.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include "pax.h"
#include "cpio.h"
#include "extern.h"

static int rd_nm(ARCHD *, int);
static int rd_ln_nm(ARCHD *);
static int com_rd(ARCHD *);

/*
 * Routines which support the different cpio versions
 */

static int swp_head;		/* binary cpio header byte swap */

/*
 * Routines common to all versions of cpio
 */

/*
 * cpio_strd()
 *	Fire up the hard link detection code
 * Return:
 *      0 if ok -1 otherwise (the return values of lnk_start())
 */

int
cpio_strd(void)
{
	return(lnk_start());
}

/*
 * cpio_trail()
 *	Called to determine if a header block is a valid trailer. We are
 *	passed the block, the in_sync flag (which tells us we are in resync
 *	mode; looking for a valid header), and cnt (which starts at zero)
 *	which is used to count the number of empty blocks we have seen so far.
 * Return:
 *	0 if a valid trailer, -1 if not a valid trailer,
 */

int
cpio_trail(ARCHD *arcn, char *notused, int notused2, int *notused3)
{
	/*
	 * look for trailer id in file we are about to process
	 */
	if ((strcmp(arcn->name, TRAILER) == 0) && (arcn->sb.st_size == 0))
		return(0);
	return(-1);
}

/*
 * com_rd()
 *	operations common to all cpio read functions.
 * Return:
 *	0
 */

static int
com_rd(ARCHD *arcn)
{
	arcn->skip = 0;
	arcn->pat = NULL;
	arcn->org_name = arcn->name;
	switch (arcn->sb.st_mode & C_IFMT) {
	case C_ISFIFO:
		arcn->type = PAX_FIF;
		break;
	case C_ISDIR:
		arcn->type = PAX_DIR;
		break;
	case C_ISBLK:
		arcn->type = PAX_BLK;
		break;
	case C_ISCHR:
		arcn->type = PAX_CHR;
		break;
	case C_ISLNK:
		arcn->type = PAX_SLK;
		break;
	case C_ISOCK:
		arcn->type = PAX_SCK;
		break;
	case C_ISCTG:
	case C_ISREG:
	default:
		/*
		 * we have file data, set up skip (pad is set in the format
		 * specific sections)
		 */
		arcn->sb.st_mode = (arcn->sb.st_mode & 0xfff) | C_ISREG;
		arcn->type = PAX_REG;
		arcn->skip = arcn->sb.st_size;
		break;
	}
	if (chk_lnk(arcn) < 0)
		return(-1);
	return(0);
}

/*
 * cpio_endwr()
 *	write the special file with the name trailer in the proper format
 * Return:
 *	result of the write of the trailer from the cpio specific write func
 */

int
cpio_endwr(void)
{
	ARCHD last;

	/*
	 * create a trailer request and call the proper format write function
	 */
	memset(&last, 0, sizeof(last));
	last.nlen = sizeof(TRAILER) - 1;
	last.type = PAX_REG;
	last.sb.st_nlink = 1;
	(void)strlcpy(last.name, TRAILER, sizeof(last.name));
	return((*frmt->wr)(&last));
}

/*
 * rd_nm()
 *	read in the file name which follows the cpio header
 * Return:
 *	0 if ok, -1 otherwise
 */

static int
rd_nm(ARCHD *arcn, int nsz)
{
	/*
	 * do not even try bogus values
	 */
	if ((nsz == 0) || (nsz > sizeof(arcn->name))) {
		paxwarn(1, "Cpio file name length %d is out of range", nsz);
		return(-1);
	}

	/*
	 * read the name and make sure it is not empty and is \0 terminated
	 */
	if ((rd_wrbuf(arcn->name,nsz) != nsz) || (arcn->name[nsz-1] != '\0') ||
	    (arcn->name[0] == '\0')) {
		paxwarn(1, "Cpio file name in header is corrupted");
		return(-1);
	}
	return(0);
}

/*
 * rd_ln_nm()
 *	read in the link name for a file with links. The link name is stored
 *	like file data (and is NOT \0 terminated!)
 * Return:
 *	0 if ok, -1 otherwise
 */

static int
rd_ln_nm(ARCHD *arcn)
{
	/*
	 * check the length specified for bogus values
	 */
	if ((arcn->sb.st_size == 0) ||
	    (arcn->sb.st_size >= sizeof(arcn->ln_name))) {
		paxwarn(1, "Cpio link name length is invalid: %llu",
		    arcn->sb.st_size);
		return(-1);
	}

	/*
	 * read in the link name and \0 terminate it
	 */
	if (rd_wrbuf(arcn->ln_name, (int)arcn->sb.st_size) !=
	    (int)arcn->sb.st_size) {
		paxwarn(1, "Cpio link name read error");
		return(-1);
	}
	arcn->ln_nlen = arcn->sb.st_size;
	arcn->ln_name[arcn->ln_nlen] = '\0';

	/*
	 * watch out for those empty link names
	 */
	if (arcn->ln_name[0] == '\0') {
		paxwarn(1, "Cpio link name is corrupt");
		return(-1);
	}
	return(0);
}

/*
 * Routines common to the extended byte oriented cpio format
 */

/*
 * cpio_id()
 *      determine if a block given to us is a valid extended byte oriented
 *	cpio header
 * Return:
 *      0 if a valid header, -1 otherwise
 */

int
cpio_id(char *blk, int size)
{
	if ((size < sizeof(HD_CPIO)) ||
	    (strncmp(blk, AMAGIC, sizeof(AMAGIC) - 1) != 0))
		return(-1);
	return(0);
}

/*
 * cpio_rd()
 *	determine if a buffer is a byte oriented extended cpio archive entry.
 *	convert and store the values in the ARCHD parameter.
 * Return:
 *	0 if a valid header, -1 otherwise.
 */

int
cpio_rd(ARCHD *arcn, char *buf)
{
	int nsz;
	unsigned long long val;
	HD_CPIO *hd;

	/*
	 * check that this is a valid header, if not return -1
	 */
	if (cpio_id(buf, sizeof(HD_CPIO)) < 0)
		return(-1);
	hd = (HD_CPIO *)buf;

	/*
	 * byte oriented cpio (posix) does not have padding! extract the octal
	 * ascii fields from the header
	 */
	arcn->pad = 0;
	arcn->sb.st_dev = (dev_t)asc_ul(hd->c_dev, sizeof(hd->c_dev), OCT);
	arcn->sb.st_ino = (ino_t)asc_ul(hd->c_ino, sizeof(hd->c_ino), OCT);
	arcn->sb.st_mode = (mode_t)asc_ul(hd->c_mode, sizeof(hd->c_mode), OCT);
	arcn->sb.st_uid = (uid_t)asc_ul(hd->c_uid, sizeof(hd->c_uid), OCT);
	arcn->sb.st_gid = (gid_t)asc_ul(hd->c_gid, sizeof(hd->c_gid), OCT);
	arcn->sb.st_nlink = (nlink_t)asc_ul(hd->c_nlink, sizeof(hd->c_nlink),
	    OCT);
	arcn->sb.st_rdev = (dev_t)asc_ul(hd->c_rdev, sizeof(hd->c_rdev), OCT);
	val = asc_ull(hd->c_mtime, sizeof(hd->c_mtime), OCT);
	if ((time_t)val < 0 || (time_t)val != val)
		arcn->sb.st_mtime = INT_MAX;			/* XXX 2038 */
	else
		arcn->sb.st_mtime = val;
	arcn->sb.st_mtim.tv_nsec = 0;
	arcn->sb.st_ctim = arcn->sb.st_atim = arcn->sb.st_mtim;
	arcn->sb.st_size = (off_t)asc_ull(hd->c_filesize,sizeof(hd->c_filesize),
	    OCT);

	/*
	 * check name size and if valid, read in the name of this entry (name
	 * follows header in the archive)
	 */
	if ((nsz = (int)asc_ul(hd->c_namesize,sizeof(hd->c_namesize),OCT)) < 2)
		return(-1);
	arcn->nlen = nsz - 1;
	if (rd_nm(arcn, nsz) < 0)
		return(-1);

	if (((arcn->sb.st_mode&C_IFMT) != C_ISLNK)||(arcn->sb.st_size == 0)) {
		/*
		 * no link name to read for this file
		 */
		arcn->ln_nlen = 0;
		arcn->ln_name[0] = '\0';
		return(com_rd(arcn));
	}

	/*
	 * check link name size and read in the link name. Link names are
	 * stored like file data.
	 */
	if (rd_ln_nm(arcn) < 0)
		return(-1);

	/*
	 * we have a valid header (with a link)
	 */
	return(com_rd(arcn));
}

/*
 * cpio_endrd()
 *      no cleanup needed here, just return size of the trailer (for append)
 * Return:
 *      size of trailer header in this format
 */

off_t
cpio_endrd(void)
{
	return sizeof(HD_CPIO) + sizeof(TRAILER);
}

/*
 * cpio_stwr()
 *	start up the device mapping table
 * Return:
 *	0 if ok, -1 otherwise (what dev_start() returns)
 */

int
cpio_stwr(void)
{
	return(dev_start());
}

/*
 * cpio_wr()
 *	copy the data in the ARCHD to buffer in extended byte oriented cpio
 *	format.
 * Return
 *      0 if file has data to be written after the header, 1 if file has NO
 *	data to write after the header, -1 if archive write failed
 */

int
cpio_wr(ARCHD *arcn)
{
	HD_CPIO *hd;
	int nsz;
	char hdblk[sizeof(HD_CPIO)];

	/*
	 * check and repair truncated device and inode fields in the header
	 */
	if (map_dev(arcn, CPIO_MASK, CPIO_MASK) < 0)
		return(-1);

	arcn->pad = 0;
	nsz = arcn->nlen + 1;
	hd = (HD_CPIO *)hdblk;
	if ((arcn->type != PAX_BLK) && (arcn->type != PAX_CHR))
		arcn->sb.st_rdev = 0;

	switch (arcn->type) {
	case PAX_CTG:
	case PAX_REG:
	case PAX_HRG:
		/*
		 * set data size for file data
		 */
		if (ull_asc(arcn->sb.st_size, hd->c_filesize,
		    sizeof(hd->c_filesize), OCT)) {
			paxwarn(1,"File is too large for cpio format %s",
			    arcn->org_name);
			return(1);
		}
		break;
	case PAX_SLK:
		/*
		 * set data size to hold link name
		 */
		if (ul_asc(arcn->ln_nlen, hd->c_filesize,
		    sizeof(hd->c_filesize), OCT))
			goto out;
		break;
	default:
		/*
		 * all other file types have no file data
		 */
		if (ul_asc(0, hd->c_filesize, sizeof(hd->c_filesize), OCT))
			goto out;
		break;
	}

	/*
	 * copy the values to the header using octal ascii
	 */
	if (ul_asc(MAGIC, hd->c_magic, sizeof(hd->c_magic), OCT) ||
	    ul_asc(arcn->sb.st_dev, hd->c_dev, sizeof(hd->c_dev), OCT) ||
	    ul_asc(arcn->sb.st_ino, hd->c_ino, sizeof(hd->c_ino), OCT) ||
	    ul_asc(arcn->sb.st_mode, hd->c_mode, sizeof(hd->c_mode), OCT) ||
	    ul_asc(arcn->sb.st_uid, hd->c_uid, sizeof(hd->c_uid), OCT) ||
	    ul_asc(arcn->sb.st_gid, hd->c_gid, sizeof(hd->c_gid), OCT) ||
	    ul_asc(arcn->sb.st_nlink, hd->c_nlink, sizeof(hd->c_nlink), OCT) ||
	    ul_asc(arcn->sb.st_rdev, hd->c_rdev, sizeof(hd->c_rdev), OCT) ||
	    ull_asc(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->c_mtime,
		sizeof(hd->c_mtime), OCT) ||
	    ul_asc(nsz, hd->c_namesize, sizeof(hd->c_namesize), OCT))
		goto out;

	/*
	 * write the file name to the archive
	 */
	if ((wr_rdbuf(hdblk, (int)sizeof(HD_CPIO)) < 0) ||
	    (wr_rdbuf(arcn->name, nsz) < 0)) {
		paxwarn(1, "Unable to write cpio header for %s", arcn->org_name);
		return(-1);
	}

	/*
	 * if this file has data, we are done. The caller will write the file
	 * data, if we are link tell caller we are done, go to next file
	 */
	if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG))
		return(0);
	if (arcn->type != PAX_SLK)
		return(1);

	/*
	 * write the link name to the archive, tell the caller to go to the
	 * next file as we are done.
	 */
	if (wr_rdbuf(arcn->ln_name, arcn->ln_nlen) < 0) {
		paxwarn(1,"Unable to write cpio link name for %s",arcn->org_name);
		return(-1);
	}
	return(1);

    out:
	/*
	 * header field is out of range
	 */
	paxwarn(1, "Cpio header field is too small to store file %s",
	    arcn->org_name);
	return(1);
}

/*
 * Routines common to the system VR4 version of cpio (with/without file CRC)
 */

/*
 * vcpio_id()
 *      determine if a block given to us is a valid system VR4 cpio header
 *	WITHOUT crc. WATCH it the magic cookies are in OCTAL, the header
 *	uses HEX
 * Return:
 *      0 if a valid header, -1 otherwise
 */

int
vcpio_id(char *blk, int size)
{
	if ((size < sizeof(HD_VCPIO)) ||
	    (strncmp(blk, AVMAGIC, sizeof(AVMAGIC) - 1) != 0))
		return(-1);
	return(0);
}

/*
 * crc_id()
 *      determine if a block given to us is a valid system VR4 cpio header
 *	WITH crc. WATCH it the magic cookies are in OCTAL the header uses HEX
 * Return:
 *      0 if a valid header, -1 otherwise
 */

int
crc_id(char *blk, int size)
{
	if ((size < sizeof(HD_VCPIO)) ||
	    (strncmp(blk, AVCMAGIC, sizeof(AVCMAGIC) - 1) != 0))
		return(-1);
	return(0);
}

/*
 * crc_strd()
 w	set file data CRC calculations. Fire up the hard link detection code
 * Return:
 *      0 if ok -1 otherwise (the return values of lnk_start())
 */

int
crc_strd(void)
{
	docrc = 1;
	return(lnk_start());
}

/*
 * vcpio_rd()
 *	determine if a buffer is a system VR4 archive entry. (with/without CRC)
 *	convert and store the values in the ARCHD parameter.
 * Return:
 *	0 if a valid header, -1 otherwise.
 */

int
vcpio_rd(ARCHD *arcn, char *buf)
{
	HD_VCPIO *hd;
	dev_t devminor;
	dev_t devmajor;
	int nsz;

	/*
	 * during the id phase it was determined if we were using CRC, use the
	 * proper id routine.
	 */
	if (docrc) {
		if (crc_id(buf, sizeof(HD_VCPIO)) < 0)
			return(-1);
	} else {
		if (vcpio_id(buf, sizeof(HD_VCPIO)) < 0)
			return(-1);
	}

	hd = (HD_VCPIO *)buf;
	arcn->pad = 0;

	/*
	 * extract the hex ascii fields from the header
	 */
	arcn->sb.st_ino = (ino_t)asc_ul(hd->c_ino, sizeof(hd->c_ino), HEX);
	arcn->sb.st_mode = (mode_t)asc_ul(hd->c_mode, sizeof(hd->c_mode), HEX);
	arcn->sb.st_uid = (uid_t)asc_ul(hd->c_uid, sizeof(hd->c_uid), HEX);
	arcn->sb.st_gid = (gid_t)asc_ul(hd->c_gid, sizeof(hd->c_gid), HEX);
	arcn->sb.st_mtime = (time_t)asc_ul(hd->c_mtime,sizeof(hd->c_mtime),HEX);
	arcn->sb.st_mtim.tv_nsec = 0;
	arcn->sb.st_ctim = arcn->sb.st_atim = arcn->sb.st_mtim;
	arcn->sb.st_size = (off_t)asc_ull(hd->c_filesize,
	    sizeof(hd->c_filesize), HEX);
	arcn->sb.st_nlink = (nlink_t)asc_ul(hd->c_nlink, sizeof(hd->c_nlink),
	    HEX);
	devmajor = (dev_t)asc_ul(hd->c_maj, sizeof(hd->c_maj), HEX);
	devminor = (dev_t)asc_ul(hd->c_min, sizeof(hd->c_min), HEX);
	arcn->sb.st_dev = TODEV(devmajor, devminor);
	devmajor = (dev_t)asc_ul(hd->c_rmaj, sizeof(hd->c_maj), HEX);
	devminor = (dev_t)asc_ul(hd->c_rmin, sizeof(hd->c_min), HEX);
	arcn->sb.st_rdev = TODEV(devmajor, devminor);
	arcn->crc = asc_ul(hd->c_chksum, sizeof(hd->c_chksum), HEX);

	/*
	 * check the length of the file name, if ok read it in, return -1 if
	 * bogus
	 */
	if ((nsz = (int)asc_ul(hd->c_namesize,sizeof(hd->c_namesize),HEX)) < 2)
		return(-1);
	arcn->nlen = nsz - 1;
	if (rd_nm(arcn, nsz) < 0)
		return(-1);

	/*
	 * skip padding. header + filename is aligned to 4 byte boundaries
	 */
	if (rd_skip(VCPIO_PAD(sizeof(HD_VCPIO) + nsz)) < 0)
		return(-1);

	/*
	 * if not a link (or a file with no data), calculate pad size (for
	 * padding which follows the file data), clear the link name and return
	 */
	if (((arcn->sb.st_mode&C_IFMT) != C_ISLNK)||(arcn->sb.st_size == 0)) {
		/*
		 * we have a valid header (not a link)
		 */
		arcn->ln_nlen = 0;
		arcn->ln_name[0] = '\0';
		arcn->pad = VCPIO_PAD(arcn->sb.st_size);
		return(com_rd(arcn));
	}

	/*
	 * read in the link name and skip over the padding
	 */
	if ((rd_ln_nm(arcn) < 0) ||
	    (rd_skip(VCPIO_PAD(arcn->sb.st_size)) < 0))
		return(-1);

	/*
	 * we have a valid header (with a link)
	 */
	return(com_rd(arcn));
}

/*
 * vcpio_endrd()
 *      no cleanup needed here, just return size of the trailer (for append)
 * Return:
 *      size of trailer header in this format
 */

off_t
vcpio_endrd(void)
{
	return sizeof(HD_VCPIO) + sizeof(TRAILER) +
		(VCPIO_PAD(sizeof(HD_VCPIO) + sizeof(TRAILER)));
}

/*
 * crc_stwr()
 *	start up the device mapping table, enable crc file calculation
 * Return:
 *	0 if ok, -1 otherwise (what dev_start() returns)
 */

int
crc_stwr(void)
{
	docrc = 1;
	return(dev_start());
}

/*
 * vcpio_wr()
 *	copy the data in the ARCHD to buffer in system VR4 cpio
 *	(with/without crc) format.
 * Return
 *	0 if file has data to be written after the header, 1 if file has
 *	NO data to write after the header, -1 if archive write failed
 */

int
vcpio_wr(ARCHD *arcn)
{
	HD_VCPIO *hd;
	unsigned int nsz;
	char hdblk[sizeof(HD_VCPIO)];

	/*
	 * check and repair truncated device and inode fields in the cpio
	 * header
	 */
	if (map_dev(arcn, VCPIO_MASK, VCPIO_MASK) < 0)
		return(-1);
	nsz = arcn->nlen + 1;
	hd = (HD_VCPIO *)hdblk;
	if ((arcn->type != PAX_BLK) && (arcn->type != PAX_CHR))
		arcn->sb.st_rdev = 0;

	/*
	 * add the proper magic value depending whether we were asked for
	 * file data crc's, and the crc if needed.
	 */
	if (docrc) {
		if (ul_asc(VCMAGIC, hd->c_magic, sizeof(hd->c_magic), OCT) ||
		    ul_asc(arcn->crc,hd->c_chksum,sizeof(hd->c_chksum), HEX))
			goto out;
	} else {
		if (ul_asc(VMAGIC, hd->c_magic, sizeof(hd->c_magic), OCT) ||
		    ul_asc(0, hd->c_chksum, sizeof(hd->c_chksum),HEX))
			goto out;
	}

	switch (arcn->type) {
	case PAX_CTG:
	case PAX_REG:
	case PAX_HRG:
		/*
		 * caller will copy file data to the archive. tell him how
		 * much to pad.
		 */
		arcn->pad = VCPIO_PAD(arcn->sb.st_size);
		if (ull_asc(arcn->sb.st_size, hd->c_filesize,
		    sizeof(hd->c_filesize), HEX)) {
			paxwarn(1,"File is too large for sv4cpio format %s",
			    arcn->org_name);
			return(1);
		}
		break;
	case PAX_SLK:
		/*
		 * no file data for the caller to process, the file data has
		 * the size of the link
		 */
		arcn->pad = 0;
		if (ul_asc(arcn->ln_nlen, hd->c_filesize,
		    sizeof(hd->c_filesize), HEX))
			goto out;
		break;
	default:
		/*
		 * no file data for the caller to process
		 */
		arcn->pad = 0;
		if (ul_asc(0, hd->c_filesize, sizeof(hd->c_filesize), HEX))
			goto out;
		break;
	}

	/*
	 * set the other fields in the header
	 */
	if (ul_asc(arcn->sb.st_ino, hd->c_ino, sizeof(hd->c_ino), HEX) ||
	    ul_asc(arcn->sb.st_mode, hd->c_mode, sizeof(hd->c_mode), HEX) ||
	    ul_asc(arcn->sb.st_uid, hd->c_uid, sizeof(hd->c_uid), HEX) ||
	    ul_asc(arcn->sb.st_gid, hd->c_gid, sizeof(hd->c_gid), HEX) ||
	    ul_asc(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->c_mtime,
		sizeof(hd->c_mtime), HEX) ||
	    ul_asc(arcn->sb.st_nlink, hd->c_nlink, sizeof(hd->c_nlink), HEX) ||
	    ul_asc(MAJOR(arcn->sb.st_dev),hd->c_maj, sizeof(hd->c_maj), HEX) ||
	    ul_asc(MINOR(arcn->sb.st_dev),hd->c_min, sizeof(hd->c_min), HEX) ||
	    ul_asc(MAJOR(arcn->sb.st_rdev),hd->c_rmaj,sizeof(hd->c_maj), HEX) ||
	    ul_asc(MINOR(arcn->sb.st_rdev),hd->c_rmin,sizeof(hd->c_min), HEX) ||
	    ul_asc(nsz, hd->c_namesize, sizeof(hd->c_namesize), HEX))
		goto out;

	/*
	 * write the header, the file name and padding as required.
	 */
	if ((wr_rdbuf(hdblk, (int)sizeof(HD_VCPIO)) < 0) ||
	    (wr_rdbuf(arcn->name, (int)nsz) < 0)  ||
	    (wr_skip(VCPIO_PAD(sizeof(HD_VCPIO) + nsz)) < 0)) {
		paxwarn(1,"Could not write sv4cpio header for %s",arcn->org_name);
		return(-1);
	}

	/*
	 * if we have file data, tell the caller we are done, copy the file
	 */
	if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG))
		return(0);

	/*
	 * if we are not a link, tell the caller we are done, go to next file
	 */
	if (arcn->type != PAX_SLK)
		return(1);

	/*
	 * write the link name, tell the caller we are done.
	 */
	if ((wr_rdbuf(arcn->ln_name, arcn->ln_nlen) < 0) ||
	    (wr_skip(VCPIO_PAD(arcn->ln_nlen)) < 0)) {
		paxwarn(1,"Could not write sv4cpio link name for %s",
		    arcn->org_name);
		return(-1);
	}
	return(1);

    out:
	/*
	 * header field is out of range
	 */
	paxwarn(1,"Sv4cpio header field is too small for file %s",arcn->org_name);
	return(1);
}

/*
 * Routines common to the old binary header cpio
 */

/*
 * bcpio_id()
 *      determine if a block given to us is a old binary cpio header
 *	(with/without header byte swapping)
 * Return:
 *      0 if a valid header, -1 otherwise
 */

int
bcpio_id(char *blk, int size)
{
	if (size < sizeof(HD_BCPIO))
		return(-1);

	/*
	 * check both normal and byte swapped magic cookies
	 */
	if (((u_short)SHRT_EXT(blk)) == MAGIC)
		return(0);
	if (((u_short)RSHRT_EXT(blk)) == MAGIC) {
		if (!swp_head)
			++swp_head;
		return(0);
	}
	return(-1);
}

/*
 * bcpio_rd()
 *	determine if a buffer is a old binary archive entry. (it may have byte
 *	swapped header) convert and store the values in the ARCHD parameter.
 *	This is a very old header format and should not really be used.
 * Return:
 *	0 if a valid header, -1 otherwise.
 */

int
bcpio_rd(ARCHD *arcn, char *buf)
{
	HD_BCPIO *hd;
	int nsz;

	/*
	 * check the header
	 */
	if (bcpio_id(buf, sizeof(HD_BCPIO)) < 0)
		return(-1);

	arcn->pad = 0;
	hd = (HD_BCPIO *)buf;
	if (swp_head) {
		/*
		 * header has swapped bytes on 16 bit boundaries
		 */
		arcn->sb.st_dev = (dev_t)(RSHRT_EXT(hd->h_dev));
		arcn->sb.st_ino = (ino_t)(RSHRT_EXT(hd->h_ino));
		arcn->sb.st_mode = (mode_t)(RSHRT_EXT(hd->h_mode));
		arcn->sb.st_uid = (uid_t)(RSHRT_EXT(hd->h_uid));
		arcn->sb.st_gid = (gid_t)(RSHRT_EXT(hd->h_gid));
		arcn->sb.st_nlink = (nlink_t)(RSHRT_EXT(hd->h_nlink));
		arcn->sb.st_rdev = (dev_t)(RSHRT_EXT(hd->h_rdev));
		arcn->sb.st_mtime = (time_t)(RSHRT_EXT(hd->h_mtime_1));
		arcn->sb.st_mtime =  (arcn->sb.st_mtime << 16) |
			((time_t)(RSHRT_EXT(hd->h_mtime_2)));
		arcn->sb.st_size = (off_t)(RSHRT_EXT(hd->h_filesize_1));
		arcn->sb.st_size = (arcn->sb.st_size << 16) |
			((off_t)(RSHRT_EXT(hd->h_filesize_2)));
		nsz = (int)(RSHRT_EXT(hd->h_namesize));
	} else {
		arcn->sb.st_dev = (dev_t)(SHRT_EXT(hd->h_dev));
		arcn->sb.st_ino = (ino_t)(SHRT_EXT(hd->h_ino));
		arcn->sb.st_mode = (mode_t)(SHRT_EXT(hd->h_mode));
		arcn->sb.st_uid = (uid_t)(SHRT_EXT(hd->h_uid));
		arcn->sb.st_gid = (gid_t)(SHRT_EXT(hd->h_gid));
		arcn->sb.st_nlink = (nlink_t)(SHRT_EXT(hd->h_nlink));
		arcn->sb.st_rdev = (dev_t)(SHRT_EXT(hd->h_rdev));
		arcn->sb.st_mtime = (time_t)(SHRT_EXT(hd->h_mtime_1));
		arcn->sb.st_mtime =  (arcn->sb.st_mtime << 16) |
			((time_t)(SHRT_EXT(hd->h_mtime_2)));
		arcn->sb.st_size = (off_t)(SHRT_EXT(hd->h_filesize_1));
		arcn->sb.st_size = (arcn->sb.st_size << 16) |
			((off_t)(SHRT_EXT(hd->h_filesize_2)));
		nsz = (int)(SHRT_EXT(hd->h_namesize));
	}
	arcn->sb.st_mtim.tv_nsec = 0;
	arcn->sb.st_ctim = arcn->sb.st_atim = arcn->sb.st_mtim;

	/*
	 * check the file name size, if bogus give up. otherwise read the file
	 * name
	 */
	if (nsz < 2)
		return(-1);
	arcn->nlen = nsz - 1;
	if (rd_nm(arcn, nsz) < 0)
		return(-1);

	/*
	 * header + file name are aligned to 2 byte boundaries, skip if needed
	 */
	if (rd_skip(BCPIO_PAD(sizeof(HD_BCPIO) + nsz)) < 0)
		return(-1);

	/*
	 * if not a link (or a file with no data), calculate pad size (for
	 * padding which follows the file data), clear the link name and return
	 */
	if (((arcn->sb.st_mode & C_IFMT) != C_ISLNK)||(arcn->sb.st_size == 0)){
		/*
		 * we have a valid header (not a link)
		 */
		arcn->ln_nlen = 0;
		arcn->ln_name[0] = '\0';
		arcn->pad = BCPIO_PAD(arcn->sb.st_size);
		return(com_rd(arcn));
	}

	if ((rd_ln_nm(arcn) < 0) ||
	    (rd_skip(BCPIO_PAD(arcn->sb.st_size)) < 0))
		return(-1);

	/*
	 * we have a valid header (with a link)
	 */
	return(com_rd(arcn));
}

/*
 * bcpio_endrd()
 *      no cleanup needed here, just return size of the trailer (for append)
 * Return:
 *      size of trailer header in this format
 */

off_t
bcpio_endrd(void)
{
	return sizeof(HD_BCPIO) + sizeof(TRAILER) +
		(BCPIO_PAD(sizeof(HD_BCPIO) + sizeof(TRAILER)));
}

/*
 * bcpio_wr()
 *	copy the data in the ARCHD to buffer in old binary cpio format
 *	There is a real chance of field overflow with this critter. So we
 *	always check the conversion is ok. nobody in their right mind
 *	should write an archive in this format...
 * Return
 *      0 if file has data to be written after the header, 1 if file has NO
 *	data to write after the header, -1 if archive write failed
 */

int
bcpio_wr(ARCHD *arcn)
{
	HD_BCPIO *hd;
	int nsz;
	char hdblk[sizeof(HD_BCPIO)];
	off_t t_offt;
	int t_int;
	time_t t_timet;

	/*
	 * check and repair truncated device and inode fields in the cpio
	 * header
	 */
	if (map_dev(arcn, BCPIO_MASK, BCPIO_MASK) < 0)
		return(-1);

	if ((arcn->type != PAX_BLK) && (arcn->type != PAX_CHR))
		arcn->sb.st_rdev = 0;
	hd = (HD_BCPIO *)hdblk;

	switch (arcn->type) {
	case PAX_CTG:
	case PAX_REG:
	case PAX_HRG:
		/*
		 * caller will copy file data to the archive. tell him how
		 * much to pad.
		 */
		arcn->pad = BCPIO_PAD(arcn->sb.st_size);
		hd->h_filesize_1[0] = CHR_WR_0(arcn->sb.st_size);
		hd->h_filesize_1[1] = CHR_WR_1(arcn->sb.st_size);
		hd->h_filesize_2[0] = CHR_WR_2(arcn->sb.st_size);
		hd->h_filesize_2[1] = CHR_WR_3(arcn->sb.st_size);
		t_offt = (off_t)(SHRT_EXT(hd->h_filesize_1));
		t_offt = (t_offt<<16) | ((off_t)(SHRT_EXT(hd->h_filesize_2)));
		if (arcn->sb.st_size != t_offt) {
			paxwarn(1,"File is too large for bcpio format %s",
			    arcn->org_name);
			return(1);
		}
		break;
	case PAX_SLK:
		/*
		 * no file data for the caller to process, the file data has
		 * the size of the link
		 */
		arcn->pad = 0;
		hd->h_filesize_1[0] = CHR_WR_0(arcn->ln_nlen);
		hd->h_filesize_1[1] = CHR_WR_1(arcn->ln_nlen);
		hd->h_filesize_2[0] = CHR_WR_2(arcn->ln_nlen);
		hd->h_filesize_2[1] = CHR_WR_3(arcn->ln_nlen);
		t_int = (int)(SHRT_EXT(hd->h_filesize_1));
		t_int = (t_int << 16) | ((int)(SHRT_EXT(hd->h_filesize_2)));
		if (arcn->ln_nlen != t_int)
			goto out;
		break;
	default:
		/*
		 * no file data for the caller to process
		 */
		arcn->pad = 0;
		hd->h_filesize_1[0] = (char)0;
		hd->h_filesize_1[1] = (char)0;
		hd->h_filesize_2[0] = (char)0;
		hd->h_filesize_2[1] = (char)0;
		break;
	}

	/*
	 * build up the rest of the fields
	 */
	hd->h_magic[0] = CHR_WR_2(MAGIC);
	hd->h_magic[1] = CHR_WR_3(MAGIC);
	hd->h_dev[0] = CHR_WR_2(arcn->sb.st_dev);
	hd->h_dev[1] = CHR_WR_3(arcn->sb.st_dev);
	if (arcn->sb.st_dev != (dev_t)(SHRT_EXT(hd->h_dev)))
		goto out;
	hd->h_ino[0] = CHR_WR_2(arcn->sb.st_ino);
	hd->h_ino[1] = CHR_WR_3(arcn->sb.st_ino);
	if (arcn->sb.st_ino != (ino_t)(SHRT_EXT(hd->h_ino)))
		goto out;
	hd->h_mode[0] = CHR_WR_2(arcn->sb.st_mode);
	hd->h_mode[1] = CHR_WR_3(arcn->sb.st_mode);
	if (arcn->sb.st_mode != (mode_t)(SHRT_EXT(hd->h_mode)))
		goto out;
	hd->h_uid[0] = CHR_WR_2(arcn->sb.st_uid);
	hd->h_uid[1] = CHR_WR_3(arcn->sb.st_uid);
	if (arcn->sb.st_uid != (uid_t)(SHRT_EXT(hd->h_uid)))
		goto out;
	hd->h_gid[0] = CHR_WR_2(arcn->sb.st_gid);
	hd->h_gid[1] = CHR_WR_3(arcn->sb.st_gid);
	if (arcn->sb.st_gid != (gid_t)(SHRT_EXT(hd->h_gid)))
		goto out;
	hd->h_nlink[0] = CHR_WR_2(arcn->sb.st_nlink);
	hd->h_nlink[1] = CHR_WR_3(arcn->sb.st_nlink);
	if (arcn->sb.st_nlink != (nlink_t)(SHRT_EXT(hd->h_nlink)))
		goto out;
	hd->h_rdev[0] = CHR_WR_2(arcn->sb.st_rdev);
	hd->h_rdev[1] = CHR_WR_3(arcn->sb.st_rdev);
	if (arcn->sb.st_rdev != (dev_t)(SHRT_EXT(hd->h_rdev)))
		goto out;
	if (arcn->sb.st_mtime > 0) {
		hd->h_mtime_1[0] = CHR_WR_0(arcn->sb.st_mtime);
		hd->h_mtime_1[1] = CHR_WR_1(arcn->sb.st_mtime);
		hd->h_mtime_2[0] = CHR_WR_2(arcn->sb.st_mtime);
		hd->h_mtime_2[1] = CHR_WR_3(arcn->sb.st_mtime);
		t_timet = (time_t)SHRT_EXT(hd->h_mtime_1);
		t_timet =  t_timet << 16 | (time_t)SHRT_EXT(hd->h_mtime_2);
		if (arcn->sb.st_mtime != t_timet)
			goto out;
	} else {
		hd->h_mtime_1[0] = hd->h_mtime_1[1] = 0;
		hd->h_mtime_2[0] = hd->h_mtime_2[1] = 0;
	}
	nsz = arcn->nlen + 1;
	hd->h_namesize[0] = CHR_WR_2(nsz);
	hd->h_namesize[1] = CHR_WR_3(nsz);
	if (nsz != (int)(SHRT_EXT(hd->h_namesize)))
		goto out;

	/*
	 * write the header, the file name and padding as required.
	 */
	if ((wr_rdbuf(hdblk, (int)sizeof(HD_BCPIO)) < 0) ||
	    (wr_rdbuf(arcn->name, nsz) < 0) ||
	    (wr_skip(BCPIO_PAD(sizeof(HD_BCPIO) + nsz)) < 0)) {
		paxwarn(1, "Could not write bcpio header for %s", arcn->org_name);
		return(-1);
	}

	/*
	 * if we have file data, tell the caller we are done
	 */
	if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG))
		return(0);

	/*
	 * if we are not a link, tell the caller we are done, go to next file
	 */
	if (arcn->type != PAX_SLK)
		return(1);

	/*
	 * write the link name, tell the caller we are done.
	 */
	if ((wr_rdbuf(arcn->ln_name, arcn->ln_nlen) < 0) ||
	    (wr_skip(BCPIO_PAD(arcn->ln_nlen)) < 0)) {
		paxwarn(1,"Could not write bcpio link name for %s",arcn->org_name);
		return(-1);
	}
	return(1);

    out:
	/*
	 * header field is out of range
	 */
	paxwarn(1,"Bcpio header field is too small for file %s", arcn->org_name);
	return(1);
}
@


1.29
log
@Remove many unnecessary casts.  Verified by comparing generated code on
both ILP32 and LP64.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.28 2016/08/14 04:47:52 guenther Exp $	*/
a37 1
#include <sys/time.h>
@


1.28
log
@Replace u_quad_t with unsigned long long and replace "uqd" with "ull" in
function names to match.  Pull some tangled assignments out of conditions
and use >>= where possible.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.27 2015/03/19 05:14:24 guenther Exp $	*/
d287 1
a287 1
	arcn->pad = 0L;
d348 1
a348 1
	return((off_t)(sizeof(HD_CPIO) + sizeof(TRAILER)));
d383 1
a383 1
	if (map_dev(arcn, (u_long)CPIO_MASK, (u_long)CPIO_MASK) < 0)
d386 1
a386 1
	arcn->pad = 0L;
d410 1
a410 1
		if (ul_asc((u_long)arcn->ln_nlen, hd->c_filesize,
d418 1
a418 2
		if (ul_asc((u_long)0, hd->c_filesize, sizeof(hd->c_filesize),
		     OCT))
d426 8
a433 15
	if (ul_asc((u_long)MAGIC, hd->c_magic, sizeof(hd->c_magic), OCT) ||
	    ul_asc((u_long)arcn->sb.st_dev, hd->c_dev, sizeof(hd->c_dev),
		OCT) ||
	    ul_asc((u_long)arcn->sb.st_ino, hd->c_ino, sizeof(hd->c_ino),
		OCT) ||
	    ul_asc((u_long)arcn->sb.st_mode, hd->c_mode, sizeof(hd->c_mode),
		OCT) ||
	    ul_asc((u_long)arcn->sb.st_uid, hd->c_uid, sizeof(hd->c_uid),
		OCT) ||
	    ul_asc((u_long)arcn->sb.st_gid, hd->c_gid, sizeof(hd->c_gid),
		OCT) ||
	    ul_asc((u_long)arcn->sb.st_nlink, hd->c_nlink, sizeof(hd->c_nlink),
		 OCT) ||
	    ul_asc((u_long)arcn->sb.st_rdev, hd->c_rdev, sizeof(hd->c_rdev),
		OCT) ||
d436 1
a436 1
	    ul_asc((u_long)nsz, hd->c_namesize, sizeof(hd->c_namesize), OCT))
d558 1
a558 1
	arcn->pad = 0L;
d595 1
a595 1
	if (rd_skip((off_t)(VCPIO_PAD(sizeof(HD_VCPIO) + nsz))) < 0)
d616 1
a616 1
	    (rd_skip((off_t)(VCPIO_PAD(arcn->sb.st_size))) < 0))
d635 2
a636 2
	return((off_t)(sizeof(HD_VCPIO) + sizeof(TRAILER) +
		(VCPIO_PAD(sizeof(HD_VCPIO) + sizeof(TRAILER)))));
d673 1
a673 1
	if (map_dev(arcn, (u_long)VCPIO_MASK, (u_long)VCPIO_MASK) < 0)
d685 2
a686 4
		if (ul_asc((u_long)VCMAGIC, hd->c_magic, sizeof(hd->c_magic),
			OCT) ||
		    ul_asc((u_long)arcn->crc,hd->c_chksum,sizeof(hd->c_chksum),
			HEX))
d689 2
a690 3
		if (ul_asc((u_long)VMAGIC, hd->c_magic, sizeof(hd->c_magic),
			OCT) ||
		    ul_asc((u_long)0L, hd->c_chksum, sizeof(hd->c_chksum),HEX))
d715 2
a716 2
		arcn->pad = 0L;
		if (ul_asc((u_long)arcn->ln_nlen, hd->c_filesize,
d724 2
a725 3
		arcn->pad = 0L;
		if (ul_asc((u_long)0L, hd->c_filesize, sizeof(hd->c_filesize),
		    HEX))
d733 4
a736 8
	if (ul_asc((u_long)arcn->sb.st_ino, hd->c_ino, sizeof(hd->c_ino),
		HEX) ||
	    ul_asc((u_long)arcn->sb.st_mode, hd->c_mode, sizeof(hd->c_mode),
		HEX) ||
	    ul_asc((u_long)arcn->sb.st_uid, hd->c_uid, sizeof(hd->c_uid),
		HEX) ||
	    ul_asc((u_long)arcn->sb.st_gid, hd->c_gid, sizeof(hd->c_gid),
		HEX) ||
d739 6
a744 11
	    ul_asc((u_long)arcn->sb.st_nlink, hd->c_nlink, sizeof(hd->c_nlink),
		HEX) ||
	    ul_asc((u_long)MAJOR(arcn->sb.st_dev),hd->c_maj, sizeof(hd->c_maj),
		HEX) ||
	    ul_asc((u_long)MINOR(arcn->sb.st_dev),hd->c_min, sizeof(hd->c_min),
		HEX) ||
	    ul_asc((u_long)MAJOR(arcn->sb.st_rdev),hd->c_rmaj,sizeof(hd->c_maj),
		HEX) ||
	    ul_asc((u_long)MINOR(arcn->sb.st_rdev),hd->c_rmin,sizeof(hd->c_min),
		HEX) ||
	    ul_asc((u_long)nsz, hd->c_namesize, sizeof(hd->c_namesize), HEX))
d752 1
a752 1
	    (wr_skip((off_t)(VCPIO_PAD(sizeof(HD_VCPIO) + nsz))) < 0)) {
d773 1
a773 1
	    (wr_skip((off_t)(VCPIO_PAD(arcn->ln_nlen))) < 0)) {
d840 1
a840 1
	arcn->pad = 0L;
d892 1
a892 1
	if (rd_skip((off_t)(BCPIO_PAD(sizeof(HD_BCPIO) + nsz))) < 0)
d910 1
a910 1
	    (rd_skip((off_t)(BCPIO_PAD(arcn->sb.st_size))) < 0))
d929 2
a930 2
	return((off_t)(sizeof(HD_BCPIO) + sizeof(TRAILER) +
		(BCPIO_PAD(sizeof(HD_BCPIO) + sizeof(TRAILER)))));
d958 1
a958 1
	if (map_dev(arcn, (u_long)BCPIO_MASK, (u_long)BCPIO_MASK) < 0)
d991 1
a991 1
		arcn->pad = 0L;
d1005 1
a1005 1
		arcn->pad = 0L;
d1070 1
a1070 1
	    (wr_skip((off_t)(BCPIO_PAD(sizeof(HD_BCPIO) + nsz))) < 0)) {
d1091 1
a1091 1
	    (wr_skip((off_t)(BCPIO_PAD(arcn->ln_nlen))) < 0)) {
@


1.27
log
@Use struct timespec internally.  This gives nanosecond precision to pax -rw
and a basis for support of mtime and atime values in pax-format extended
header records.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.26 2015/03/17 03:23:17 guenther Exp $	*/
d273 1
a273 1
	u_quad_t val;
d296 1
a296 1
	val = asc_uqd(hd->c_mtime, sizeof(hd->c_mtime), OCT);
d303 1
a303 1
	arcn->sb.st_size = (off_t)asc_uqd(hd->c_filesize,sizeof(hd->c_filesize),
d399 1
a399 1
		if (uqd_asc((u_quad_t)arcn->sb.st_size, hd->c_filesize,
d442 1
a442 1
	    uqd_asc(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->c_mtime,
d578 1
a578 1
	arcn->sb.st_size = (off_t)asc_uqd(hd->c_filesize,
d714 1
a714 1
		if (uqd_asc((u_quad_t)arcn->sb.st_size, hd->c_filesize,
@


1.26
log
@Add PAX_IS_{REG,HARDLINK,LINK} macros to simply many file type tests

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.25 2014/02/19 03:59:47 guenther Exp $	*/
d301 2
a302 1
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;
d576 2
a577 1
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;
d897 2
a898 1
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;
@


1.25
log
@Map negative mtimes to zero instead of skipping the affected files.

problem noted by miod@@
ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.24 2014/01/08 05:52:47 guenther Exp $	*/
d459 1
a459 2
	if ((arcn->type == PAX_CTG) || (arcn->type == PAX_REG) ||
	    (arcn->type == PAX_HRG))
d779 1
a779 2
	if ((arcn->type == PAX_CTG) || (arcn->type == PAX_REG) ||
	    (arcn->type == PAX_HRG))
d1096 1
a1096 2
	if ((arcn->type == PAX_CTG) || (arcn->type == PAX_REG) ||
	    (arcn->type == PAX_HRG))
@


1.24
log
@Replace strtoq(), QUAD_MAX, and %qu with their long long equivalent
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.23 2014/01/08 04:58:36 guenther Exp $	*/
d441 2
a442 2
	    uqd_asc((u_quad_t)arcn->sb.st_mtime,hd->c_mtime,sizeof(hd->c_mtime),
		OCT) ||
d752 2
a753 2
	    ul_asc((u_long)arcn->sb.st_mtime, hd->c_mtime, sizeof(hd->c_mtime),
		HEX) ||
d1066 13
a1078 8
	hd->h_mtime_1[0] = CHR_WR_0(arcn->sb.st_mtime);
	hd->h_mtime_1[1] = CHR_WR_1(arcn->sb.st_mtime);
	hd->h_mtime_2[0] = CHR_WR_2(arcn->sb.st_mtime);
	hd->h_mtime_2[1] = CHR_WR_3(arcn->sb.st_mtime);
	t_timet = (time_t)(SHRT_EXT(hd->h_mtime_1));
	t_timet =  (t_timet << 16) | ((time_t)(SHRT_EXT(hd->h_mtime_2)));
	if (arcn->sb.st_mtime != t_timet)
		goto out;
@


1.23
log
@Eliminate poisonous LONG_OFF_T conditional

adjective suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.22 2013/07/03 04:08:29 guenther Exp $	*/
d214 1
a214 1
		paxwarn(1, "Cpio link name length is invalid: %qu",
@


1.22
log
@cpio and ustar formats store times in octal fields that are 11 characters
wide, so they support up to 33bits.  Take advantage of the extra bits by
no longer forcing them into 32bit ints before the time_t conversion.  This
gets us another 204 years of range once time_t changes type

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.21 2013/05/25 13:33:47 lum Exp $	*/
a213 4
#		ifdef LONG_OFF_T
		paxwarn(1, "Cpio link name length is invalid: %lu",
		    arcn->sb.st_size);
#		else
a215 1
#		endif
a301 4
#	ifdef LONG_OFF_T
	arcn->sb.st_size = (off_t)asc_ul(hd->c_filesize,sizeof(hd->c_filesize),
	    OCT);
#	else
a303 1
#	endif
a397 4
#		ifdef LONG_OFF_T
		if (ul_asc((u_long)arcn->sb.st_size, hd->c_filesize,
		    sizeof(hd->c_filesize), OCT)) {
#		else
a399 1
#		endif
a576 4
#	ifdef LONG_OFF_T
	arcn->sb.st_size = (off_t)asc_ul(hd->c_filesize,
	    sizeof(hd->c_filesize), HEX);
#	else
a578 1
#	endif
a712 4
#		ifdef LONG_OFF_T
		if (ul_asc((u_long)arcn->sb.st_size, hd->c_filesize,
		    sizeof(hd->c_filesize), HEX)) {
#		else
a714 1
#		endif
@


1.21
log
@Fix typo. From Caspar Schutijser via tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.20 2012/12/04 02:24:45 deraadt Exp $	*/
d40 1
d278 1
d301 5
a305 2
	arcn->sb.st_mtime = (time_t)asc_ul(hd->c_mtime, sizeof(hd->c_mtime),
	    OCT);
d456 1
a456 1
	    ul_asc((u_long)arcn->sb.st_mtime,hd->c_mtime,sizeof(hd->c_mtime),
@


1.20
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.19 2009/10/27 23:59:22 deraadt Exp $	*/
d169 1
a169 1
 * rd_nam()
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.18 2008/01/01 16:22:44 tobias Exp $	*/
a39 1
#include <sys/param.h>
@


1.18
log
@Typo in comment about cpio_endwr() fixed.

OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.17 2004/04/16 22:50:23 deraadt Exp $	*/
a35 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)cpio.c	8.1 (Berkeley) 5/31/93";
#else
static const char rcsid[] = "$OpenBSD: cpio.c,v 1.17 2004/04/16 22:50:23 deraadt Exp $";
#endif
#endif /* not lint */
@


1.17
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.16 2003/06/26 00:10:17 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: cpio.c,v 1.16 2003/06/26 00:10:17 deraadt Exp $";
d155 1
a155 1
 * cpio_end_wr()
@


1.16
log
@protos.  this requires changing the api for the *trail() functions a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.15 2003/06/02 23:32:08 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: cpio.c,v 1.15 2003/06/02 23:32:08 millert Exp $";
d118 1
a118 1
	switch(arcn->sb.st_mode & C_IFMT) {
d405 1
a405 1
	switch(arcn->type) {
d728 1
a728 1
	switch(arcn->type) {
d1014 1
a1014 1
	switch(arcn->type) {
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.14 2003/02/03 09:06:43 jmc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: cpio.c,v 1.14 2003/02/03 09:06:43 jmc Exp $";
d95 1
a95 1
cpio_trail(ARCHD *arcn)
@


1.14
log
@typos;
from netbsd(svs+pr@@grep.ru)
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.13 2002/10/16 19:20:02 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: cpio.c,v 1.13 2002/10/16 19:20:02 millert Exp $";
@


1.13
log
@sprinkle const; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.12 2002/10/16 18:40:30 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: cpio.c,v 1.12 2002/10/16 18:40:30 millert Exp $";
d990 1
a990 1
 *	always check the conversion is ok. nobody in his their right mind
@


1.12
log
@Fix comment typos; most from NetBSD and FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.11 2002/10/16 17:43:10 millert Exp $	*/
d43 1
a43 1
static char sccsid[] = "@@(#)cpio.c	8.1 (Berkeley) 5/31/93";
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cpio.c,v 1.11 2002/10/16 17:43:10 millert Exp $";
@


1.11
log
@kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.10 2002/06/09 02:35:27 itojun Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cpio.c,v 1.10 2002/06/09 02:35:27 itojun Exp $";
d628 1
a628 1
	 * skip padding. header + filename is aligned to 4 byte boundries
d898 1
a898 1
		 * header has swapped bytes on 16 bit boundries
d943 1
a943 1
	 * header + file name are aligned to 2 byte boundries, skip if needed
d991 1
a991 1
 *	should write an achive in this format...
@


1.10
log
@strlcpy fix, PR 2727
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.9 2002/02/19 19:39:35 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cpio.c,v 1.9 2002/02/19 19:39:35 millert Exp $";
d61 3
a63 3
static int rd_nm(register ARCHD *, int);
static int rd_ln_nm(register ARCHD *);
static int com_rd(register ARCHD *);
d99 1
a99 1
cpio_trail(register ARCHD *arcn)
d117 1
a117 1
com_rd(register ARCHD *arcn)
d189 1
a189 1
rd_nm(register ARCHD *arcn, int nsz)
d219 1
a219 1
rd_ln_nm(register ARCHD *arcn)
d287 1
a287 1
cpio_rd(register ARCHD *arcn, register char *buf)
d289 2
a290 2
	register int nsz;
	register HD_CPIO *hd;
d391 1
a391 1
cpio_wr(register ARCHD *arcn)
d393 2
a394 2
	register HD_CPIO *hd;
	register int nsz;
d569 1
a569 1
vcpio_rd(register ARCHD *arcn, register char *buf)
d571 1
a571 1
	register HD_VCPIO *hd;
d574 1
a574 1
	register int nsz;
d698 1
a698 1
vcpio_wr(register ARCHD *arcn)
d700 1
a700 1
	register HD_VCPIO *hd;
d883 1
a883 1
bcpio_rd(register ARCHD *arcn, register char *buf)
d885 2
a886 2
	register HD_BCPIO *hd;
	register int nsz;
d998 1
a998 1
bcpio_wr(register ARCHD *arcn)
d1000 2
a1001 2
	register HD_BCPIO *hd;
	register int nsz;
@


1.9
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.8 2002/02/16 21:27:07 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cpio.c,v 1.8 2002/02/16 21:27:07 millert Exp $";
d177 1
a177 1
	(void)strcpy(last.name, TRAILER);
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.7 2001/05/26 00:32:21 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cpio.c,v 1.7 2001/05/26 00:32:21 millert Exp $";
a81 1
#ifdef __STDC__
a83 4
#else
int
cpio_strd()
#endif
a97 1
#ifdef __STDC__
a99 5
#else
int
cpio_trail(arcn)
	register ARCHD *arcn;
#endif
a115 1
#ifdef __STDC__
a117 5
#else
static int
com_rd(arcn)
	register ARCHD *arcn;
#endif
a164 1
#ifdef __STDC__
a166 4
#else
int
cpio_endwr()
#endif
a187 1
#ifdef __STDC__
a189 6
#else
static int
rd_nm(arcn, nsz)
	register ARCHD *arcn;
	int nsz;
#endif
a217 1
#ifdef __STDC__
a219 5
#else
static int
rd_ln_nm(arcn)
	register ARCHD *arcn;
#endif
a268 1
#ifdef __STDC__
a270 6
#else
int
cpio_id(blk, size)
	char *blk;
	int size;
#endif
a285 1
#ifdef __STDC__
a287 6
#else
int
cpio_rd(arcn, buf)
	register ARCHD *arcn;
	register char *buf;
#endif
a361 1
#ifdef __STDC__
a363 4
#else
off_t
cpio_endrd()
#endif
a374 1
#ifdef __STDC__
a376 4
#else
int
cpio_stwr()
#endif
a389 1
#ifdef __STDC__
a391 5
#else
int
cpio_wr(arcn)
	register ARCHD *arcn;
#endif
a519 1
#ifdef __STDC__
a521 6
#else
int
vcpio_id(blk, size)
	char *blk;
	int size;
#endif
a536 1
#ifdef __STDC__
a538 6
#else
int
crc_id(blk, size)
	char *blk;
	int size;
#endif
a552 1
#ifdef __STDC__
a554 4
#else
int
crc_strd()
#endif
a567 1
#ifdef __STDC__
a569 6
#else
int
vcpio_rd(arcn, buf)
	register ARCHD *arcn;
	register char *buf;
#endif
a666 1
#ifdef __STDC__
a668 4
#else
off_t
vcpio_endrd()
#endif
a680 1
#ifdef __STDC__
a682 4
#else
int
crc_stwr()
#endif
a696 1
#ifdef __STDC__
a698 5
#else
int
vcpio_wr(arcn)
	register ARCHD *arcn;
#endif
a853 1
#ifdef __STDC__
a855 6
#else
int
bcpio_id(blk, size)
	char *blk;
	int size;
#endif
a881 1
#ifdef __STDC__
a883 6
#else
int
bcpio_rd(arcn, buf)
	register ARCHD *arcn;
	register char *buf;
#endif
a978 1
#ifdef __STDC__
a980 4
#else
off_t
bcpio_endrd()
#endif
a996 1
#ifdef __STDC__
a998 5
#else
int
bcpio_wr(arcn)
	register ARCHD *arcn;
#endif
@


1.7
log
@Get rid of NET2_FTS and NET2_REGEX #ifdefs since they are useless.
Change NET2_STAT into LONG_OFF_T for portability to systems with
a 32bit off_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.6 2001/05/16 03:04:56 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cpio.c,v 1.6 2001/05/16 03:04:56 mickey Exp $";
d61 3
a63 3
static int rd_nm __P((register ARCHD *, int));
static int rd_ln_nm __P((register ARCHD *));
static int com_rd __P((register ARCHD *));
@


1.6
log
@use proper str*cpy functions instead of home grown one, spaces; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.5 1997/07/25 18:58:28 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cpio.c,v 1.5 1997/07/25 18:58:28 mickey Exp $";
d261 1
a261 1
#		ifdef NET2_STAT
d364 1
a364 1
#	ifdef NET2_STAT
d481 1
a481 1
#		ifdef NET2_STAT
d691 1
a691 1
#	ifdef NET2_STAT
d848 1
a848 1
#		ifdef NET2_STAT
@


1.5
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.4 1997/07/23 19:15:56 kstailey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cpio.c,v 1.4 1997/07/23 19:15:56 kstailey Exp $";
d100 1
a100 1
 *	0 if a valid trailer, -1 if not a valid trailer, 
d384 2
a385 2
	 	 * no link name to read for this file
	 	 */
d579 1
a579 1
 *	WITHOUT crc. WATCH it the magic cookies are in OCTAL, the header 
d828 1
a828 1
	    		OCT) ||
d830 1
a830 1
	    		HEX))
d834 1
a834 1
	    		OCT) ||
d891 1
a891 1
    		HEX) ||
d893 1
a893 1
    		HEX) ||
d895 1
a895 1
    		HEX) ||
@


1.4
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.3 1996/06/23 14:20:31 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cpio.c,v 1.3 1996/06/23 14:20:31 deraadt Exp $";
d82 1
a82 1
#if __STDC__
d103 1
a103 1
#if __STDC__
d127 1
a127 1
#if __STDC__
d182 1
a182 1
#if __STDC__
d210 1
a210 1
#if __STDC__
d247 1
a247 1
#if __STDC__
d304 1
a304 1
#if __STDC__
d328 1
a328 1
#if __STDC__
d411 1
a411 1
#if __STDC__
d429 1
a429 1
#if __STDC__
d449 1
a449 1
#if __STDC__
d585 1
a585 1
#if __STDC__
d609 1
a609 1
#if __STDC__
d632 1
a632 1
#if __STDC__
d652 1
a652 1
#if __STDC__
d758 1
a758 1
#if __STDC__
d777 1
a777 1
#if __STDC__
d798 1
a798 1
#if __STDC__
d961 1
a961 1
#if __STDC__
d996 1
a996 1
#if __STDC__
d1100 1
a1100 1
#if __STDC__
d1123 1
a1123 1
#if __STDC__
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.5 1995/03/21 09:07:13 cgd Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: cpio.c,v 1.5 1995/03/21 09:07:13 cgd Exp $";
d516 1
a516 1
	        OCT) ||
@


1.2
log
@Correct compile warnings
Rename warn() to paxwarn() so <err.h> can be included

Remove #include <ctype.h> when not needed; from FreeBSD
@
text
@d1 1
d45 1
a45 1
static char rcsid[] = "$NetBSD: cpio.c,v 1.5 1995/03/21 09:07:13 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@a52 1
#include <ctype.h>
d223 1
a223 1
		warn(1, "Cpio file name length %d is out of range", nsz);
d232 1
a232 1
		warn(1, "Cpio file name in header is corrupted");
d261 1
a261 1
		warn(1, "Cpio link name length is invalid: %lu",
d264 1
a264 1
		warn(1, "Cpio link name length is invalid: %qu",
d275 1
a275 1
		warn(1, "Cpio link name read error");
d285 1
a285 1
		warn(1, "Cpio link name is corrupt");
d487 1
a487 1
			warn(1,"File is too large for cpio format %s",
d538 1
a538 1
		warn(1, "Unable to write cpio header for %s", arcn->org_name);
d557 1
a557 1
		warn(1,"Unable to write cpio link name for %s",arcn->org_name);
d566 1
a566 1
	warn(1, "Cpio header field is too small to store file %s",
d854 1
a854 1
			warn(1,"File is too large for sv4cpio format %s",
d912 1
a912 1
		warn(1,"Could not write sv4cpio header for %s",arcn->org_name);
d934 1
a934 1
		warn(1,"Could not write sv4cpio link name for %s",
d944 1
a944 1
	warn(1,"Sv4cpio header field is too small for file %s",arcn->org_name);
d1165 1
a1165 1
			warn(1,"File is too large for bcpio format %s",
d1250 1
a1250 1
		warn(1, "Could not write bcpio header for %s", arcn->org_name);
d1272 1
a1272 1
		warn(1,"Could not write bcpio link name for %s",arcn->org_name);
d1281 1
a1281 1
	warn(1,"Bcpio header field is too small for file %s", arcn->org_name);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
