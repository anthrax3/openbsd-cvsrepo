head	1.66;
access;
symbols
	OPENBSD_6_2:1.66.0.4
	OPENBSD_6_2_BASE:1.66
	OPENBSD_6_1:1.63.0.4
	OPENBSD_6_1_BASE:1.63
	OPENBSD_6_0:1.59.0.4
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.58.0.4
	OPENBSD_5_8_BASE:1.58
	OPENBSD_5_7:1.55.0.2
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.53.0.6
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.53.0.4
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.48.0.2
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.44.0.2
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.43.0.8
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.6
	OPENBSD_5_0:1.43.0.4
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.2
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.42.0.4
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.42.0.2
	OPENBSD_4_7_BASE:1.42
	OPENBSD_4_6:1.41.0.16
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.41.0.12
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.41.0.10
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.8
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.41.0.6
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.41.0.4
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.39.0.2
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.34.0.2
	OPENBSD_3_7_BASE:1.34
	OPENBSD_3_6:1.33.0.2
	OPENBSD_3_6_BASE:1.33
	OPENBSD_3_5:1.31.0.4
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	OPENBSD_3_3:1.29.0.2
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.25.0.4
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_8:1.15.0.4
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.14.0.6
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.12.0.4
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.66
date	2017.09.16.07.42.34;	author otto;	state Exp;
branches;
next	1.65;
commitid	UAIch61G0VKbA6po;

1.65
date	2017.09.12.17.11.11;	author otto;	state Exp;
branches;
next	1.64;
commitid	O8IaeFeNkXg09HEH;

1.64
date	2017.09.08.12.23.47;	author otto;	state Exp;
branches;
next	1.63;
commitid	VolkZqy2sP9RxL7x;

1.63
date	2016.08.26.04.11.16;	author guenther;	state Exp;
branches;
next	1.62;
commitid	JeDGCh3Baf9wzXzL;

1.62
date	2016.08.25.01.44.55;	author guenther;	state Exp;
branches;
next	1.61;
commitid	udvMiyfPVZQYw9Ht;

1.61
date	2016.08.14.18.30.33;	author guenther;	state Exp;
branches;
next	1.60;
commitid	qmsIw7NlXw1nDUYx;

1.60
date	2016.08.14.04.47.52;	author guenther;	state Exp;
branches;
next	1.59;
commitid	KTreFUOYbPKrm5vY;

1.59
date	2016.02.15.02.38.53;	author guenther;	state Exp;
branches;
next	1.58;
commitid	gnNxIt5sMkJqr1Ej;

1.58
date	2015.03.17.03.23.17;	author guenther;	state Exp;
branches;
next	1.57;
commitid	gv8qhyah1XKC6RDB;

1.57
date	2015.03.15.19.47.27;	author guenther;	state Exp;
branches;
next	1.56;
commitid	GNp5QMuUaAzwIVNl;

1.56
date	2015.03.09.04.23.29;	author guenther;	state Exp;
branches;
next	1.55;
commitid	JMkpovMhu0rmLvCn;

1.55
date	2015.02.21.22.48.23;	author guenther;	state Exp;
branches
	1.55.2.1;
next	1.54;
commitid	AdteqX8nU06lUYnQ;

1.54
date	2015.01.29.19.41.49;	author guenther;	state Exp;
branches;
next	1.53;
commitid	xnMfZPdUDpZsjm9f;

1.53
date	2014.02.19.03.59.47;	author guenther;	state Exp;
branches
	1.53.6.1;
next	1.52;

1.52
date	2014.01.08.06.41.49;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2014.01.08.04.58.36;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2014.01.08.04.41.41;	author guenther;	state Exp;
branches;
next	1.49;

1.49
date	2013.11.21.15.54.45;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2013.07.03.04.08.29;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2013.04.11.00.44.26;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2013.04.09.18.30.34;	author fgsch;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.27.17.14.10;	author zhuk;	state Exp;
branches;
next	1.44;

1.44
date	2012.12.04.02.24.45;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2010.12.02.04.08.27;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.04.20.24.55;	author otto;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.17.19.47.02;	author otto;	state Exp;
branches;
next	1.39;

1.39
date	2005.06.13.19.20.05;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2005.04.28.06.58.07;	author otto;	state Exp;
branches;
next	1.37;

1.37
date	2005.04.21.21.47.18;	author beck;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.14.08.24.09;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.10.18.08.53;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2004.10.23.19.34.14;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.16.22.50.23;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.30.16.14.23;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.26.00.10.18;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.02.23.32.09;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.10.18.15.38.11;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.10.16.19.20.02;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.10.16.18.40.30;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.16.17.43.10;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.19.22.51.32;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.19.19.59.26;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.19.19.47.50;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.26.14.55.13;	author lebel;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.26.14.19.33;	author lebel;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.26.00.32.21;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.16.03.04.59;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.04.20.31.25;	author todd;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.21.05.11.36;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	98.10.19.05.46.12;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.09.26.21.29.41;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.09.01.18.30.03;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.07.25.18.58.38;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.06.04.00.15.18;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.04.05.22.36.19;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.04.02.00.31.58;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.03.25.09.30.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.02.16.06.54.21;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	97.02.10.06.48.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.08.27.03.53.14;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.20.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.06.41.55;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.18;	author deraadt;	state Exp;
branches;
next	;

1.53.6.1
date	2015.04.30.19.30.57;	author guenther;	state Exp;
branches;
next	;
commitid	tPD1f2vGi43RT0WC;

1.55.2.1
date	2015.04.30.19.28.46;	author guenther;	state Exp;
branches;
next	;
commitid	pbBButXFqiIh89mX;


desc
@@


1.66
log
@Carefully add casts to silence clang sign-compare warnings. ok millert@@
@
text
@/*	$OpenBSD: tar.c,v 1.65 2017/09/12 17:11:11 otto Exp $	*/
/*	$NetBSD: tar.c,v 1.5 1995/03/21 09:07:49 cgd Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <ctype.h>
#include <errno.h>
#include <grp.h>
#include <limits.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "pax.h"
#include "extern.h"
#include "tar.h"

/*
 * Routines for reading, writing and header identify of various versions of tar
 */

static size_t expandname(char *, size_t, char **, const char *, size_t);
static u_long tar_chksm(char *, int);
static char *name_split(char *, int);
static int ul_oct(u_long, char *, int, int);
static int ull_oct(unsigned long long, char *, int, int);
#ifndef SMALL
static int rd_xheader(ARCHD *arcn, int, off_t);
#endif

static uid_t uid_nobody;
static uid_t uid_warn;
static gid_t gid_nobody;
static gid_t gid_warn;

/*
 * Routines common to all versions of tar
 */

int tar_nodir;				/* do not write dirs under old tar */
char *gnu_name_string;			/* GNU ././@@LongLink hackery name */
char *gnu_link_string;			/* GNU ././@@LongLink hackery link */

/*
 * tar_endwr()
 *	add the tar trailer of two null blocks
 * Return:
 *	0 if ok, -1 otherwise (what wr_skip returns)
 */

int
tar_endwr(void)
{
	return wr_skip(NULLCNT * BLKMULT);
}

/*
 * tar_endrd()
 *	no cleanup needed here, just return size of trailer (for append)
 * Return:
 *	size of trailer (2 * BLKMULT)
 */

off_t
tar_endrd(void)
{
	return NULLCNT * BLKMULT;
}

/*
 * tar_trail()
 *	Called to determine if a header block is a valid trailer. We are passed
 *	the block, the in_sync flag (which tells us we are in resync mode;
 *	looking for a valid header), and cnt (which starts at zero) which is
 *	used to count the number of empty blocks we have seen so far.
 * Return:
 *	0 if a valid trailer, -1 if not a valid trailer, or 1 if the block
 *	could never contain a header.
 */

int
tar_trail(ARCHD *ignore, char *buf, int in_resync, int *cnt)
{
	int i;

	/*
	 * look for all zero, trailer is two consecutive blocks of zero
	 */
	for (i = 0; i < BLKMULT; ++i) {
		if (buf[i] != '\0')
			break;
	}

	/*
	 * if not all zero it is not a trailer, but MIGHT be a header.
	 */
	if (i != BLKMULT)
		return(-1);

	/*
	 * When given a zero block, we must be careful!
	 * If we are not in resync mode, check for the trailer. Have to watch
	 * out that we do not mis-identify file data as the trailer, so we do
	 * NOT try to id a trailer during resync mode. During resync mode we
	 * might as well throw this block out since a valid header can NEVER be
	 * a block of all 0 (we must have a valid file name).
	 */
	if (!in_resync && (++*cnt >= NULLCNT))
		return(0);
	return(1);
}

/*
 * ul_oct()
 *	convert an unsigned long to an octal string. many oddball field
 *	termination characters are used by the various versions of tar in the
 *	different fields. term selects which kind to use. str is '0' padded
 *	at the front to len. we are unable to use only one format as many old
 *	tar readers are very cranky about this.
 * Return:
 *	0 if the number fit into the string, -1 otherwise
 */

static int
ul_oct(u_long val, char *str, int len, int term)
{
	char *pt;

	/*
	 * term selects the appropriate character(s) for the end of the string
	 */
	pt = str + len - 1;
	switch (term) {
	case 3:
		*pt-- = '\0';
		break;
	case 2:
		*pt-- = ' ';
		*pt-- = '\0';
		break;
	case 1:
		*pt-- = ' ';
		break;
	case 0:
	default:
		*pt-- = '\0';
		*pt-- = ' ';
		break;
	}

	/*
	 * convert and blank pad if there is space
	 */
	while (pt >= str) {
		*pt-- = '0' + (char)(val & 0x7);
		val >>= 3;
		if (val == 0)
			break;
	}

	while (pt >= str)
		*pt-- = '0';
	if (val != 0)
		return(-1);
	return(0);
}

/*
 * ull_oct()
 *	Convert an unsigned long long to an octal string.  One of many oddball
 *	field termination characters are used by the various versions of tar
 *	in the different fields.  term selects which kind to use.  str is
 *	'0' padded at the front to len.  We are unable to use only one format
 *	as many old tar readers are very cranky about this.
 * Return:
 *	0 if the number fit into the string, -1 otherwise
 */

static int
ull_oct(unsigned long long val, char *str, int len, int term)
{
	char *pt;

	/*
	 * term selects the appropriate character(s) for the end of the string
	 */
	pt = str + len - 1;
	switch (term) {
	case 3:
		*pt-- = '\0';
		break;
	case 2:
		*pt-- = ' ';
		*pt-- = '\0';
		break;
	case 1:
		*pt-- = ' ';
		break;
	case 0:
	default:
		*pt-- = '\0';
		*pt-- = ' ';
		break;
	}

	/*
	 * convert and blank pad if there is space
	 */
	while (pt >= str) {
		*pt-- = '0' + (char)(val & 0x7);
		val >>= 3;
		if (val == 0)
			break;
	}

	while (pt >= str)
		*pt-- = '0';
	if (val != 0)
		return(-1);
	return(0);
}

/*
 * tar_chksm()
 *	calculate the checksum for a tar block counting the checksum field as
 *	all blanks (BLNKSUM is that value pre-calculated, the sum of 8 blanks).
 *	NOTE: we use len to short circuit summing 0's on write since we ALWAYS
 *	pad headers with 0.
 * Return:
 *	unsigned long checksum
 */

static u_long
tar_chksm(char *blk, int len)
{
	char *stop;
	char *pt;
	u_long chksm = BLNKSUM;	/* initial value is checksum field sum */

	/*
	 * add the part of the block before the checksum field
	 */
	pt = blk;
	stop = blk + CHK_OFFSET;
	while (pt < stop)
		chksm += (u_long)(*pt++ & 0xff);
	/*
	 * move past the checksum field and keep going, spec counts the
	 * checksum field as the sum of 8 blanks (which is pre-computed as
	 * BLNKSUM).
	 * ASSUMED: len is greater than CHK_OFFSET. (len is where our 0 padding
	 * starts, no point in summing zero's)
	 */
	pt += CHK_LEN;
	stop = blk + len;
	while (pt < stop)
		chksm += (u_long)(*pt++ & 0xff);
	return(chksm);
}

/*
 * Routines for old BSD style tar (also made portable to sysV tar)
 */

/*
 * tar_id()
 *	determine if a block given to us is a valid tar header (and not a USTAR
 *	header). We have to be on the lookout for those pesky blocks of	all
 *	zero's.
 * Return:
 *	0 if a tar header, -1 otherwise
 */

int
tar_id(char *blk, int size)
{
	HD_TAR *hd;
	HD_USTAR *uhd;

	if (size < BLKMULT)
		return(-1);
	hd = (HD_TAR *)blk;
	uhd = (HD_USTAR *)blk;

	/*
	 * check for block of zero's first, a simple and fast test, then make
	 * sure this is not a ustar header by looking for the ustar magic
	 * cookie. We should use TMAGLEN, but some USTAR archive programs are
	 * wrong and create archives missing the \0. Last we check the
	 * checksum. If this is ok we have to assume it is a valid header.
	 */
	if (hd->name[0] == '\0')
		return(-1);
	if (strncmp(uhd->magic, TMAGIC, TMAGLEN - 1) == 0)
		return(-1);
	if (asc_ul(hd->chksum,sizeof(hd->chksum),OCT) != tar_chksm(blk,BLKMULT))
		return(-1);
	force_one_volume = 1;
	return(0);
}

/*
 * tar_opt()
 *	handle tar format specific -o options
 * Return:
 *	0 if ok -1 otherwise
 */

int
tar_opt(void)
{
	OPLIST *opt;

	while ((opt = opt_next()) != NULL) {
		if (strcmp(opt->name, TAR_OPTION) ||
		    strcmp(opt->value, TAR_NODIR)) {
			paxwarn(1, "Unknown tar format -o option/value pair %s=%s",
			    opt->name, opt->value);
			paxwarn(1,"%s=%s is the only supported tar format option",
			    TAR_OPTION, TAR_NODIR);
			return(-1);
		}

		/*
		 * we only support one option, and only when writing
		 */
		if ((act != APPND) && (act != ARCHIVE)) {
			paxwarn(1, "%s=%s is only supported when writing.",
			    opt->name, opt->value);
			return(-1);
		}
		tar_nodir = 1;
	}
	return(0);
}


/*
 * tar_rd()
 *	extract the values out of block already determined to be a tar header.
 *	store the values in the ARCHD parameter.
 * Return:
 *	0
 */

int
tar_rd(ARCHD *arcn, char *buf)
{
	HD_TAR *hd;
	unsigned long long val;
	char *pt;

	/*
	 * we only get proper sized buffers passed to us
	 */
	if (tar_id(buf, BLKMULT) < 0)
		return(-1);
	memset(arcn, 0, sizeof(*arcn));
	arcn->org_name = arcn->name;
	arcn->sb.st_nlink = 1;

	/*
	 * copy out the name and values in the stat buffer
	 */
	hd = (HD_TAR *)buf;
	if (hd->linkflag != LONGLINKTYPE && hd->linkflag != LONGNAMETYPE) {
		arcn->nlen = expandname(arcn->name, sizeof(arcn->name),
		    &gnu_name_string, hd->name, sizeof(hd->name));
		arcn->ln_nlen = expandname(arcn->ln_name, sizeof(arcn->ln_name),
		    &gnu_link_string, hd->linkname, sizeof(hd->linkname));
	}
	arcn->sb.st_mode = (mode_t)(asc_ul(hd->mode,sizeof(hd->mode),OCT) &
	    0xfff);
	arcn->sb.st_uid = (uid_t)asc_ul(hd->uid, sizeof(hd->uid), OCT);
	arcn->sb.st_gid = (gid_t)asc_ul(hd->gid, sizeof(hd->gid), OCT);
	arcn->sb.st_size = (off_t)asc_ull(hd->size, sizeof(hd->size), OCT);
	val = asc_ull(hd->mtime, sizeof(hd->mtime), OCT);
	if (val > MAX_TIME_T)
		arcn->sb.st_mtime = INT_MAX;                    /* XXX 2038 */
	else
		arcn->sb.st_mtime = val;
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;

	/*
	 * have to look at the last character, it may be a '/' and that is used
	 * to encode this as a directory
	 */
	pt = &(arcn->name[arcn->nlen - 1]);
	arcn->pad = 0;
	arcn->skip = 0;
	switch (hd->linkflag) {
	case SYMTYPE:
		/*
		 * symbolic link, need to get the link name and set the type in
		 * the st_mode so -v printing will look correct.
		 */
		arcn->type = PAX_SLK;
		arcn->sb.st_mode |= S_IFLNK;
		break;
	case LNKTYPE:
		/*
		 * hard link, need to get the link name, set the type in the
		 * st_mode and st_nlink so -v printing will look better.
		 */
		arcn->type = PAX_HLK;
		arcn->sb.st_nlink = 2;

		/*
		 * no idea of what type this thing really points at, but
		 * we set something for printing only.
		 */
		arcn->sb.st_mode |= S_IFREG;
		break;
	case LONGLINKTYPE:
	case LONGNAMETYPE:
		/*
		 * GNU long link/file; we tag these here and let the
		 * pax internals deal with it -- too ugly otherwise.
		 */
		arcn->type =
		    hd->linkflag == LONGLINKTYPE ? PAX_GLL : PAX_GLF;
		arcn->pad = TAR_PAD(arcn->sb.st_size);
		arcn->skip = arcn->sb.st_size;
		break;
	case DIRTYPE:
		/*
		 * It is a directory, set the mode for -v printing
		 */
		arcn->type = PAX_DIR;
		arcn->sb.st_mode |= S_IFDIR;
		arcn->sb.st_nlink = 2;
		break;
	case AREGTYPE:
	case REGTYPE:
	default:
		/*
		 * If we have a trailing / this is a directory and NOT a file.
		 */
		arcn->ln_name[0] = '\0';
		arcn->ln_nlen = 0;
		if (*pt == '/') {
			/*
			 * it is a directory, set the mode for -v printing
			 */
			arcn->type = PAX_DIR;
			arcn->sb.st_mode |= S_IFDIR;
			arcn->sb.st_nlink = 2;
		} else {
			/*
			 * have a file that will be followed by data. Set the
			 * skip value to the size field and calculate the size
			 * of the padding.
			 */
			arcn->type = PAX_REG;
			arcn->sb.st_mode |= S_IFREG;
			arcn->pad = TAR_PAD(arcn->sb.st_size);
			arcn->skip = arcn->sb.st_size;
		}
		break;
	}

	/*
	 * strip off any trailing slash.
	 */
	if (*pt == '/') {
		*pt = '\0';
		--arcn->nlen;
	}
	return(0);
}

/*
 * tar_wr()
 *	write a tar header for the file specified in the ARCHD to the archive.
 *	Have to check for file types that cannot be stored and file names that
 *	are too long. Be careful of the term (last arg) to ul_oct, each field
 *	of tar has it own spec for the termination character(s).
 *	ASSUMED: space after header in header block is zero filled
 * Return:
 *	0 if file has data to be written after the header, 1 if file has NO
 *	data to write after the header, -1 if archive write failed
 */

int
tar_wr(ARCHD *arcn)
{
	HD_TAR *hd;
	int len;
	char hdblk[sizeof(HD_TAR)];

	/*
	 * check for those file system types which tar cannot store
	 */
	switch (arcn->type) {
	case PAX_DIR:
		/*
		 * user asked that dirs not be written to the archive
		 */
		if (tar_nodir)
			return(1);
		break;
	case PAX_CHR:
		paxwarn(1, "Tar cannot archive a character device %s",
		    arcn->org_name);
		return(1);
	case PAX_BLK:
		paxwarn(1, "Tar cannot archive a block device %s", arcn->org_name);
		return(1);
	case PAX_SCK:
		paxwarn(1, "Tar cannot archive a socket %s", arcn->org_name);
		return(1);
	case PAX_FIF:
		paxwarn(1, "Tar cannot archive a fifo %s", arcn->org_name);
		return(1);
	case PAX_SLK:
	case PAX_HLK:
	case PAX_HRG:
		if ((size_t)arcn->ln_nlen > sizeof(hd->linkname)) {
			paxwarn(1, "Link name too long for tar %s",
			    arcn->ln_name);
			return(1);
		}
		break;
	case PAX_REG:
	case PAX_CTG:
	default:
		break;
	}

	/*
	 * check file name len, remember extra char for dirs (the / at the end)
	 */
	len = arcn->nlen;
	if (arcn->type == PAX_DIR)
		++len;
	if ((size_t)len > sizeof(hd->name)) {
		paxwarn(1, "File name too long for tar %s", arcn->name);
		return(1);
	}

	/*
	 * Copy the data out of the ARCHD into the tar header based on the type
	 * of the file. Remember, many tar readers want all fields to be
	 * padded with zero so we zero the header first.  We then set the
	 * linkflag field (type), the linkname, the size, and set the padding
	 * (if any) to be added after the file data (0 for all other types,
	 * as they only have a header).
	 */
	memset(hdblk, 0, sizeof(hdblk));
	hd = (HD_TAR *)hdblk;
	fieldcpy(hd->name, sizeof(hd->name), arcn->name, sizeof(arcn->name));
	arcn->pad = 0;

	if (arcn->type == PAX_DIR) {
		/*
		 * directories are the same as files, except have a filename
		 * that ends with a /, we add the slash here. No data follows
		 * dirs, so no pad.
		 */
		hd->linkflag = AREGTYPE;
		hd->name[len-1] = '/';
		if (ul_oct(0, hd->size, sizeof(hd->size), 1))
			goto out;
	} else if (arcn->type == PAX_SLK) {
		/*
		 * no data follows this file, so no pad
		 */
		hd->linkflag = SYMTYPE;
		fieldcpy(hd->linkname, sizeof(hd->linkname), arcn->ln_name,
		    sizeof(arcn->ln_name));
		if (ul_oct(0, hd->size, sizeof(hd->size), 1))
			goto out;
	} else if (PAX_IS_HARDLINK(arcn->type)) {
		/*
		 * no data follows this file, so no pad
		 */
		hd->linkflag = LNKTYPE;
		fieldcpy(hd->linkname, sizeof(hd->linkname), arcn->ln_name,
		    sizeof(arcn->ln_name));
		if (ul_oct(0, hd->size, sizeof(hd->size), 1))
			goto out;
	} else {
		/*
		 * data follows this file, so set the pad
		 */
		hd->linkflag = AREGTYPE;
		if (ull_oct(arcn->sb.st_size, hd->size, sizeof(hd->size), 1)) {
			paxwarn(1, "File is too large for tar %s",
			    arcn->org_name);
			return(1);
		}
		arcn->pad = TAR_PAD(arcn->sb.st_size);
	}

	/*
	 * copy those fields that are independent of the type
	 */
	if (ul_oct(arcn->sb.st_mode, hd->mode, sizeof(hd->mode), 0) ||
	    ull_oct(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->mtime,
		sizeof(hd->mtime), 1) ||
	    ul_oct(arcn->sb.st_uid, hd->uid, sizeof(hd->uid), 0) ||
	    ul_oct(arcn->sb.st_gid, hd->gid, sizeof(hd->gid), 0))
		goto out;

	/*
	 * calculate and add the checksum, then write the header. A return of
	 * 0 tells the caller to now write the file data, 1 says no data needs
	 * to be written
	 */
	if (ul_oct(tar_chksm(hdblk, sizeof(HD_TAR)), hd->chksum,
	    sizeof(hd->chksum), 3))
		goto out;
	if (wr_rdbuf(hdblk, sizeof(HD_TAR)) < 0)
		return(-1);
	if (wr_skip(BLKMULT - sizeof(HD_TAR)) < 0)
		return(-1);
	if (PAX_IS_REG(arcn->type))
		return(0);
	return(1);

    out:
	/*
	 * header field is out of range
	 */
	paxwarn(1, "Tar header field is too small for %s", arcn->org_name);
	return(1);
}

/*
 * Routines for POSIX ustar
 */

/*
 * ustar_strd()
 *	initialization for ustar read
 * Return:
 *	0 if ok, -1 otherwise
 */

int
ustar_strd(void)
{
	if ((usrtb_start() < 0) || (grptb_start() < 0))
		return(-1);
	return(0);
}

/*
 * ustar_id()
 *	determine if a block given to us is a valid ustar header. We have to
 *	be on the lookout for those pesky blocks of all zero's
 * Return:
 *	0 if a ustar header, -1 otherwise
 */

int
ustar_id(char *blk, int size)
{
	HD_USTAR *hd;

	if (size < BLKMULT)
		return(-1);
	hd = (HD_USTAR *)blk;

	/*
	 * check for block of zero's first, a simple and fast test then check
	 * ustar magic cookie. We should use TMAGLEN, but some USTAR archive
	 * programs are fouled up and create archives missing the \0. Last we
	 * check the checksum. If ok we have to assume it is a valid header.
	 */
	if (hd->prefix[0] == '\0' && hd->name[0] == '\0')
		return(-1);
	if (strncmp(hd->magic, TMAGIC, TMAGLEN - 1) != 0)
		return(-1);
	if (asc_ul(hd->chksum,sizeof(hd->chksum),OCT) != tar_chksm(blk,BLKMULT))
		return(-1);
	return(0);
}

/*
 * ustar_rd()
 *	extract the values out of block already determined to be a ustar header.
 *	store the values in the ARCHD parameter.
 * Return:
 *	0
 */

int
ustar_rd(ARCHD *arcn, char *buf)
{
	HD_USTAR *hd = (HD_USTAR *)buf;
	char *dest;
	int cnt = 0;
	dev_t devmajor;
	dev_t devminor;
	unsigned long long val;

	/*
	 * we only get proper sized buffers
	 */
	if (ustar_id(buf, BLKMULT) < 0)
		return(-1);

#ifndef SMALL
reset:
#endif
	memset(arcn, 0, sizeof(*arcn));
	arcn->org_name = arcn->name;
	arcn->sb.st_nlink = 1;

#ifndef SMALL
	/* Process Extended headers. */
	if (hd->typeflag == XHDRTYPE || hd->typeflag == GHDRTYPE) {
		if (rd_xheader(arcn, hd->typeflag == GHDRTYPE,
		    (off_t)asc_ul(hd->size, sizeof(hd->size), OCT)) < 0)
			return (-1);

		/* Update and check the ustar header. */
		if (rd_wrbuf(buf, BLKMULT) != BLKMULT)
			return (-1);
		if (ustar_id(buf, BLKMULT) < 0)
			return(-1);

		/* if the next block is another extension, reset the values */
		if (hd->typeflag == XHDRTYPE || hd->typeflag == GHDRTYPE)
			goto reset;
	}
#endif

	if (!arcn->nlen) {
		/*
		 * See if the filename is split into two parts. if, so join
		 * the parts.  We copy the prefix first and add a / between
		 * the prefix and name.
		 */
		dest = arcn->name;
		if (*(hd->prefix) != '\0') {
			cnt = fieldcpy(dest, sizeof(arcn->name) - 1,
			    hd->prefix, sizeof(hd->prefix));
			dest += cnt;
			*dest++ = '/';
			cnt++;
		} else
			cnt = 0;

		if (hd->typeflag != LONGLINKTYPE &&
		    hd->typeflag != LONGNAMETYPE) {
			arcn->nlen = cnt + expandname(dest,
			    sizeof(arcn->name) - cnt, &gnu_name_string,
			    hd->name, sizeof(hd->name));
		}
	}

	if (!arcn->ln_nlen &&
	    hd->typeflag != LONGLINKTYPE && hd->typeflag != LONGNAMETYPE) {
		arcn->ln_nlen = expandname(arcn->ln_name, sizeof(arcn->ln_name),
		    &gnu_link_string, hd->linkname, sizeof(hd->linkname));
	}

	/*
	 * follow the spec to the letter. we should only have mode bits, strip
	 * off all other crud we may be passed.
	 */
	arcn->sb.st_mode = (mode_t)(asc_ul(hd->mode, sizeof(hd->mode), OCT) &
	    0xfff);
	arcn->sb.st_size = (off_t)asc_ull(hd->size, sizeof(hd->size), OCT);
	val = asc_ull(hd->mtime, sizeof(hd->mtime), OCT);
	if (val > MAX_TIME_T)
		arcn->sb.st_mtime = INT_MAX;                    /* XXX 2038 */
	else
		arcn->sb.st_mtime = val;
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;

	/*
	 * If we can find the ascii names for gname and uname in the password
	 * and group files we will use the uid's and gid they bind. Otherwise
	 * we use the uid and gid values stored in the header. (This is what
	 * the posix spec wants).
	 */
	hd->gname[sizeof(hd->gname) - 1] = '\0';
	if (Nflag || gid_name(hd->gname, &(arcn->sb.st_gid)) < 0)
		arcn->sb.st_gid = (gid_t)asc_ul(hd->gid, sizeof(hd->gid), OCT);
	hd->uname[sizeof(hd->uname) - 1] = '\0';
	if (Nflag || uid_name(hd->uname, &(arcn->sb.st_uid)) < 0)
		arcn->sb.st_uid = (uid_t)asc_ul(hd->uid, sizeof(hd->uid), OCT);

	/*
	 * set the defaults, these may be changed depending on the file type
	 */
	arcn->pad = 0;
	arcn->skip = 0;
	arcn->sb.st_rdev = (dev_t)0;

	/*
	 * set the mode and PAX type according to the typeflag in the header
	 */
	switch (hd->typeflag) {
	case FIFOTYPE:
		arcn->type = PAX_FIF;
		arcn->sb.st_mode |= S_IFIFO;
		break;
	case DIRTYPE:
		arcn->type = PAX_DIR;
		arcn->sb.st_mode |= S_IFDIR;
		arcn->sb.st_nlink = 2;

		/*
		 * Some programs that create ustar archives append a '/'
		 * to the pathname for directories. This clearly violates
		 * ustar specs, but we will silently strip it off anyway.
		 */
		if (arcn->name[arcn->nlen - 1] == '/')
			arcn->name[--arcn->nlen] = '\0';
		break;
	case BLKTYPE:
	case CHRTYPE:
		/*
		 * this type requires the rdev field to be set.
		 */
		if (hd->typeflag == BLKTYPE) {
			arcn->type = PAX_BLK;
			arcn->sb.st_mode |= S_IFBLK;
		} else {
			arcn->type = PAX_CHR;
			arcn->sb.st_mode |= S_IFCHR;
		}
		devmajor = (dev_t)asc_ul(hd->devmajor,sizeof(hd->devmajor),OCT);
		devminor = (dev_t)asc_ul(hd->devminor,sizeof(hd->devminor),OCT);
		arcn->sb.st_rdev = TODEV(devmajor, devminor);
		break;
	case SYMTYPE:
	case LNKTYPE:
		if (hd->typeflag == SYMTYPE) {
			arcn->type = PAX_SLK;
			arcn->sb.st_mode |= S_IFLNK;
		} else {
			arcn->type = PAX_HLK;
			/*
			 * so printing looks better
			 */
			arcn->sb.st_mode |= S_IFREG;
			arcn->sb.st_nlink = 2;
		}
		break;
	case LONGLINKTYPE:
	case LONGNAMETYPE:
		/*
		 * GNU long link/file; we tag these here and let the
		 * pax internals deal with it -- too ugly otherwise.
		 */
		arcn->type =
		    hd->typeflag == LONGLINKTYPE ? PAX_GLL : PAX_GLF;
		arcn->pad = TAR_PAD(arcn->sb.st_size);
		arcn->skip = arcn->sb.st_size;
		break;
	case CONTTYPE:
	case AREGTYPE:
	case REGTYPE:
	default:
		/*
		 * these types have file data that follows. Set the skip and
		 * pad fields.
		 */
		arcn->type = PAX_REG;
		arcn->pad = TAR_PAD(arcn->sb.st_size);
		arcn->skip = arcn->sb.st_size;
		arcn->sb.st_mode |= S_IFREG;
		break;
	}
	return(0);
}

/*
 * ustar_wr()
 *	write a ustar header for the file specified in the ARCHD to the archive
 *	Have to check for file types that cannot be stored and file names that
 *	are too long. Be careful of the term (last arg) to ul_oct, we only use
 *	'\0' for the termination character (this is different than picky tar)
 *	ASSUMED: space after header in header block is zero filled
 * Return:
 *	0 if file has data to be written after the header, 1 if file has NO
 *	data to write after the header, -1 if archive write failed
 */

int
ustar_wr(ARCHD *arcn)
{
	HD_USTAR *hd;
	char *pt, *name;
	char hdblk[sizeof(HD_USTAR)];

	/*
	 * check for those file system types ustar cannot store
	 */
	if (arcn->type == PAX_SCK) {
		paxwarn(1, "Ustar cannot archive a socket %s", arcn->org_name);
		return(1);
	}

	/*
	 * user asked that dirs not be written to the archive
	 */
	if (arcn->type == PAX_DIR && tar_nodir)
		return (1);

	/*
	 * check the length of the linkname
	 */
	if (PAX_IS_LINK(arcn->type) &&
	    ((size_t)arcn->ln_nlen > sizeof(hd->linkname))) {
		paxwarn(1, "Link name too long for ustar %s", arcn->ln_name);
		return(1);
	}

	/*
	 * split the path name into prefix and name fields (if needed). if
	 * pt != arcn->name, the name has to be split
	 */
	if ((pt = name_split(arcn->name, arcn->nlen)) == NULL) {
		paxwarn(1, "File name too long for ustar %s", arcn->name);
		return(1);
	}

	/*
	 * zero out the header so we don't have to worry about zero fill below
	 */
	memset(hdblk, 0, sizeof(hdblk));
	hd = (HD_USTAR *)hdblk;
	arcn->pad = 0;

	/*
	 * split the name, or zero out the prefix
	 */
	if (pt != arcn->name) {
		/*
		 * name was split, pt points at the / where the split is to
		 * occur, we remove the / and copy the first part to the prefix
		 */
		*pt = '\0';
		fieldcpy(hd->prefix, sizeof(hd->prefix), arcn->name,
		    sizeof(arcn->name));
		*pt++ = '/';
	}

	/*
	 * copy the name part. this may be the whole path or the part after
	 * the prefix
	 */
	fieldcpy(hd->name, sizeof(hd->name), pt,
	    sizeof(arcn->name) - (pt - arcn->name));

	/*
	 * set the fields in the header that are type dependent
	 */
	switch (arcn->type) {
	case PAX_DIR:
		hd->typeflag = DIRTYPE;
		if (ul_oct(0, hd->size, sizeof(hd->size), 3))
			goto out;
		break;
	case PAX_CHR:
	case PAX_BLK:
		if (arcn->type == PAX_CHR)
			hd->typeflag = CHRTYPE;
		else
			hd->typeflag = BLKTYPE;
		if (ul_oct(MAJOR(arcn->sb.st_rdev), hd->devmajor,
		   sizeof(hd->devmajor), 3) ||
		   ul_oct(MINOR(arcn->sb.st_rdev), hd->devminor,
		   sizeof(hd->devminor), 3) ||
		   ul_oct(0, hd->size, sizeof(hd->size), 3))
			goto out;
		break;
	case PAX_FIF:
		hd->typeflag = FIFOTYPE;
		if (ul_oct(0, hd->size, sizeof(hd->size), 3))
			goto out;
		break;
	case PAX_SLK:
	case PAX_HLK:
	case PAX_HRG:
		if (arcn->type == PAX_SLK)
			hd->typeflag = SYMTYPE;
		else
			hd->typeflag = LNKTYPE;
		fieldcpy(hd->linkname, sizeof(hd->linkname), arcn->ln_name,
		    sizeof(arcn->ln_name));
		if (ul_oct(0, hd->size, sizeof(hd->size), 3))
			goto out;
		break;
	case PAX_REG:
	case PAX_CTG:
	default:
		/*
		 * file data with this type, set the padding
		 */
		if (arcn->type == PAX_CTG)
			hd->typeflag = CONTTYPE;
		else
			hd->typeflag = REGTYPE;
		arcn->pad = TAR_PAD(arcn->sb.st_size);
		if (ull_oct(arcn->sb.st_size, hd->size, sizeof(hd->size), 3)) {
			paxwarn(1, "File is too long for ustar %s",
			    arcn->org_name);
			return(1);
		}
		break;
	}

	strncpy(hd->magic, TMAGIC, TMAGLEN);
	strncpy(hd->version, TVERSION, TVERSLEN);

	/*
	 * set the remaining fields. Some versions want all 16 bits of mode
	 * we better humor them (they really do not meet spec though)....
	 */
	if (ul_oct(arcn->sb.st_uid, hd->uid, sizeof(hd->uid), 3)) {
		if (uid_nobody == 0) {
			if (uid_name("nobody", &uid_nobody) == -1)
				goto out;
		}
		if (uid_warn != arcn->sb.st_uid) {
			uid_warn = arcn->sb.st_uid;
			paxwarn(1,
			    "Ustar header field is too small for uid %lu, "
			    "using nobody", (u_long)arcn->sb.st_uid);
		}
		if (ul_oct(uid_nobody, hd->uid, sizeof(hd->uid), 3))
			goto out;
	}
	if (ul_oct(arcn->sb.st_gid, hd->gid, sizeof(hd->gid), 3)) {
		if (gid_nobody == 0) {
			if (gid_name("nobody", &gid_nobody) == -1)
				goto out;
		}
		if (gid_warn != arcn->sb.st_gid) {
			gid_warn = arcn->sb.st_gid;
			paxwarn(1,
			    "Ustar header field is too small for gid %lu, "
			    "using nobody", (u_long)arcn->sb.st_gid);
		}
		if (ul_oct(gid_nobody, hd->gid, sizeof(hd->gid), 3))
			goto out;
	}
	if (ull_oct(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->mtime,
		sizeof(hd->mtime), 3) ||
	    ul_oct(arcn->sb.st_mode, hd->mode, sizeof(hd->mode), 3))
		goto out;
	if (!Nflag) {
		if ((name = user_from_uid(arcn->sb.st_uid, 1)) != NULL)
			strncpy(hd->uname, name, sizeof(hd->uname));
		if ((name = group_from_gid(arcn->sb.st_gid, 1)) != NULL)
			strncpy(hd->gname, name, sizeof(hd->gname));
	}

	/*
	 * calculate and store the checksum write the header to the archive
	 * return 0 tells the caller to now write the file data, 1 says no data
	 * needs to be written
	 */
	if (ul_oct(tar_chksm(hdblk, sizeof(HD_USTAR)), hd->chksum,
	   sizeof(hd->chksum), 3))
		goto out;
	if (wr_rdbuf(hdblk, sizeof(HD_USTAR)) < 0)
		return(-1);
	if (wr_skip(BLKMULT - sizeof(HD_USTAR)) < 0)
		return(-1);
	if (PAX_IS_REG(arcn->type))
		return(0);
	return(1);

    out:
	/*
	 * header field is out of range
	 */
	paxwarn(1, "Ustar header field is too small for %s", arcn->org_name);
	return(1);
}

/*
 * name_split()
 *	see if the name has to be split for storage in a ustar header. We try
 *	to fit the entire name in the name field without splitting if we can.
 *	The split point is always at a /
 * Return
 *	character pointer to split point (always the / that is to be removed
 *	if the split is not needed, the points is set to the start of the file
 *	name (it would violate the spec to split there). A NULL is returned if
 *	the file name is too long
 */

static char *
name_split(char *name, int len)
{
	char *start;

	/*
	 * check to see if the file name is small enough to fit in the name
	 * field. if so just return a pointer to the name.
	 * The strings can fill the complete name and prefix fields
	 * without a NUL terminator.
	 */
	if (len <= TNMSZ)
		return(name);
	if (len > (TPFSZ + TNMSZ + 1))
		return(NULL);

	/*
	 * we start looking at the biggest sized piece that fits in the name
	 * field. We walk forward looking for a slash to split at. The idea is
	 * to find the biggest piece to fit in the name field (or the smallest
	 * prefix we can find) (the -1 is correct the biggest piece would
	 * include the slash between the two parts that gets thrown away)
	 */
	start = name + len - TNMSZ - 1;

	/*
	 * the prefix may not be empty, so skip the first character when
	 * trying to split a path of exactly TNMSZ+1 characters.
	 * NOTE: This means the ustar format can't store /str if
	 * str contains no slashes and the length of str == TNMSZ
	 */
	if (start == name)
		++start;

	while ((*start != '\0') && (*start != '/'))
		++start;

	/*
	 * if we hit the end of the string, this name cannot be split, so we
	 * cannot store this file.
	 */
	if (*start == '\0')
		return(NULL);

	/*
	 * the split point isn't valid if it results in a prefix
	 * longer than TPFSZ
	 */
	if ((start - name) > TPFSZ)
		return(NULL);

	/*
	 * ok have a split point, return it to the caller
	 */
	return(start);
}

static size_t
expandname(char *buf, size_t len, char **gnu_name, const char *name,
    size_t limit)
{
	size_t nlen;

	if (*gnu_name) {
		/* *gnu_name is NUL terminated */
		if ((nlen = strlcpy(buf, *gnu_name, len)) >= len)
			nlen = len - 1;
		free(*gnu_name);
		*gnu_name = NULL;
	} else
		nlen = fieldcpy(buf, len, name, limit);
	return(nlen);
}

#ifndef SMALL

/* shortest possible extended record: "5 a=\n" */
#define MINXHDRSZ	5

/* longest record we'll accept */
#define MAXXHDRSZ	BLKMULT

static int
rd_xheader(ARCHD *arcn, int global, off_t size)
{
	char buf[MAXXHDRSZ];
	long len;
	char *delim, *keyword;
	char *nextp, *p, *end;
	int pad, ret = 0;

	/* before we alter size, make note of how much we have to skip */
	pad = TAR_PAD((unsigned)size);

	p = end = buf;
	while (size > 0 || p < end) {
		if (size > 0) {
			int rdlen;

			/* shift stuff down */
			if (p > buf) {
				memmove(buf, p, end - p);
				end -= p - buf;
				p = buf;
			}

			/* fill starting at end */
			rdlen = MINIMUM(size, (buf + sizeof buf) - end);
			if (rd_wrbuf(end, rdlen) != rdlen) {
				ret = -1;
				break;
			}
			size -= rdlen;
			end += rdlen;
		}

		/* [p, end) is good */
		if (memchr(p, ' ', end - p) == NULL ||
		    !isdigit((unsigned char)*p)) {
			paxwarn(1, "Invalid extended header record");
			ret = -1;
			break;
		}
		errno = 0;
		len = strtol(p, &delim, 10);
		if (*delim != ' ' || (errno == ERANGE && len == LONG_MAX) ||
		    len < MINXHDRSZ) {
			paxwarn(1, "Invalid extended header record length");
			ret = -1;
			break;
		}
		if (len > end - p) {
			paxwarn(1, "Extended header record length %lu is "
			    "out of range", len);
			/* if we can just toss this record, do so */
			len -= end - p;
			if (len <= size && rd_skip(len) == 0) {
				size -= len;
				p = end = buf;
				continue;
			}
			ret = -1;
			break;
		}
		nextp = p + len;
		keyword = p = delim + 1;
		p = memchr(p, '=', len);
		if (!p || nextp[-1] != '\n') {
			paxwarn(1, "Malformed extended header record");
			ret = -1;
			break;
		}
		*p++ = nextp[-1] = '\0';
		if (!global) {
			if (!strcmp(keyword, "path")) {
				arcn->nlen = strlcpy(arcn->name, p,
				    sizeof(arcn->name));
			} else if (!strcmp(keyword, "linkpath")) {
				arcn->ln_nlen = strlcpy(arcn->ln_name, p,
				    sizeof(arcn->ln_name));
			}
		}
		p = nextp;
	}

	if (rd_skip(size + pad) < 0)
		return (-1);
	return (ret);
}
#endif
@


1.65
log
@there is no offical way to get the max value of time_t, but this one works
on any sensible posix system (in which time_t must be an integer type)
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.64 2017/09/08 12:23:47 otto Exp $	*/
d553 1
a553 1
		if (arcn->ln_nlen > sizeof(hd->linkname)) {
d571 1
a571 1
	if (len > sizeof(hd->name)) {
d944 2
a945 1
	if (PAX_IS_LINK(arcn->type) && (arcn->ln_nlen > sizeof(hd->linkname))) {
@


1.64
log
@Avoid clang warning and make code better by using a signed long;
with hint from millert@@; ok millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.63 2016/08/26 04:11:16 guenther Exp $	*/
d413 1
a413 1
	if ((time_t)val < 0 || (time_t)val != val)
d803 1
a803 1
	if ((time_t)val < 0 || (time_t)val != val)
@


1.63
log
@Don't need <sys/time.h> or "options.h" here
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.62 2016/08/25 01:44:55 guenther Exp $	*/
d1212 1
a1212 1
	unsigned long len;
d1250 2
a1251 2
		len = strtoul(p, &delim, 10);
		if (*delim != ' ' || (errno == ERANGE && len == ULONG_MAX) ||
@


1.62
log
@Replace name_{uid,gid}() with the libc routines user_from_uid() and
group_from_gid().  Eliminate some superfluous strncpy() calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.61 2016/08/14 18:30:33 guenther Exp $	*/
a37 1
#include <sys/time.h>
@


1.61
log
@Remove many unnecessary casts.  Verified by comparing generated code on
both ILP32 and LP64.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.60 2016/08/14 04:47:52 guenther Exp $	*/
d42 1
d44 3
a47 1
#include <stdio.h>
d49 1
a49 1
#include <stdlib.h>
a684 15
 * ustar_stwr()
 *	initialization for ustar write
 * Return:
 *	0 if ok, -1 otherwise
 */

int
ustar_stwr(void)
{
	if ((uidtb_start() < 0) || (gidtb_start() < 0))
		return(-1);
	return(0);
}

/*
d925 1
a925 1
	char *pt;
d1085 4
a1088 5
		strncpy(hd->uname, name_uid(arcn->sb.st_uid, 0), sizeof(hd->uname));
		strncpy(hd->gname, name_gid(arcn->sb.st_gid, 0), sizeof(hd->gname));
	} else {
		strncpy(hd->uname, "", sizeof(hd->uname));
		strncpy(hd->gname, "", sizeof(hd->gname));
@


1.60
log
@Replace u_quad_t with unsigned long long and replace "uqd" with "ull" in
function names to match.  Pull some tangled assignments out of conditions
and use >>= where possible.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.59 2016/02/15 02:38:53 guenther Exp $	*/
d87 1
a87 1
	return(wr_skip((off_t)(NULLCNT*BLKMULT)));
d100 1
a100 1
	return((off_t)(NULLCNT*BLKMULT));
d595 1
a595 1
		if (ul_oct((u_long)0L, hd->size, sizeof(hd->size), 1))
d604 1
a604 1
		if (ul_oct((u_long)0L, hd->size, sizeof(hd->size), 1))
d613 1
a613 1
		if (ul_oct((u_long)0L, hd->size, sizeof(hd->size), 1))
d631 1
a631 1
	if (ul_oct((u_long)arcn->sb.st_mode, hd->mode, sizeof(hd->mode), 0) ||
d634 2
a635 2
	    ul_oct((u_long)arcn->sb.st_uid, hd->uid, sizeof(hd->uid), 0) ||
	    ul_oct((u_long)arcn->sb.st_gid, hd->gid, sizeof(hd->gid), 0))
d648 1
a648 1
	if (wr_skip((off_t)(BLKMULT - sizeof(HD_TAR))) < 0)
d976 1
a976 1
	arcn->pad = 0L;
d1005 1
a1005 1
		if (ul_oct((u_long)0L, hd->size, sizeof(hd->size), 3))
d1014 1
a1014 1
		if (ul_oct((u_long)MAJOR(arcn->sb.st_rdev), hd->devmajor,
d1016 1
a1016 1
		   ul_oct((u_long)MINOR(arcn->sb.st_rdev), hd->devminor,
d1018 1
a1018 1
		   ul_oct((u_long)0L, hd->size, sizeof(hd->size), 3))
d1023 1
a1023 1
		if (ul_oct((u_long)0L, hd->size, sizeof(hd->size), 3))
d1035 1
a1035 1
		if (ul_oct((u_long)0L, hd->size, sizeof(hd->size), 3))
d1064 1
a1064 1
	if (ul_oct((u_long)arcn->sb.st_uid, hd->uid, sizeof(hd->uid), 3)) {
d1075 1
a1075 1
		if (ul_oct((u_long)uid_nobody, hd->uid, sizeof(hd->uid), 3))
d1078 1
a1078 1
	if (ul_oct((u_long)arcn->sb.st_gid, hd->gid, sizeof(hd->gid), 3)) {
d1089 1
a1089 1
		if (ul_oct((u_long)gid_nobody, hd->gid, sizeof(hd->gid), 3))
d1094 1
a1094 1
	    ul_oct((u_long)arcn->sb.st_mode, hd->mode, sizeof(hd->mode), 3))
d1114 1
a1114 1
	if (wr_skip((off_t)(BLKMULT - sizeof(HD_USTAR))) < 0)
@


1.59
log
@To archive a 101 character absolute path in ustar format we must
split it on a slash other than the leading one.

Fix based on patches from Peter Fokker (openbsd (at) berestijn.nl) and
Peter Bisroev (peter (at) int19h.net)
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.58 2015/03/17 03:23:17 guenther Exp $	*/
d59 1
a59 1
static int uqd_oct(u_quad_t, char *, int, int);
d189 2
a190 1
		if ((val = val >> 3) == (u_long)0)
d196 1
a196 1
	if (val != (u_long)0)
d202 6
a207 6
 * uqd_oct()
 *	convert an u_quad_t to an octal string. one of many oddball field
 *	termination characters are used by the various versions of tar in the
 *	different fields. term selects which kind to use. str is '0' padded
 *	at the front to len. we are unable to use only one format as many old
 *	tar readers are very cranky about this.
d213 1
a213 1
uqd_oct(u_quad_t val, char *str, int len, int term)
d244 2
a245 1
		if ((val = val >> 3) == 0)
d251 1
a251 1
	if (val != (u_quad_t)0)
d383 1
a383 1
	u_quad_t val;
d409 2
a410 2
	arcn->sb.st_size = (off_t)asc_uqd(hd->size, sizeof(hd->size), OCT);
	val = asc_uqd(hd->mtime, sizeof(hd->mtime), OCT);
d620 3
a622 3
		if (uqd_oct((u_quad_t)arcn->sb.st_size, hd->size,
		    sizeof(hd->size), 1)) {
			paxwarn(1,"File is too large for tar %s", arcn->org_name);
d632 1
a632 1
	    uqd_oct(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->mtime,
d744 1
a744 1
	u_quad_t val;
d814 2
a815 2
	arcn->sb.st_size = (off_t)asc_uqd(hd->size, sizeof(hd->size), OCT);
	val = asc_uqd(hd->mtime, sizeof(hd->mtime), OCT);
d1049 3
a1051 3
		if (uqd_oct((u_quad_t)arcn->sb.st_size, hd->size,
		    sizeof(hd->size), 3)) {
			paxwarn(1,"File is too long for ustar %s",arcn->org_name);
d1092 1
a1092 1
	if (uqd_oct(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->mtime,
@


1.58
log
@Add PAX_IS_{REG,HARDLINK,LINK} macros to simply many file type tests

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.57 2015/03/15 19:47:27 guenther Exp $	*/
d1162 10
a1180 1
	len = start - name;
d1183 2
a1184 4
	 * NOTE: /str where the length of str == TNMSZ can not be stored under
	 * the p1003.1-1990 spec for ustar. We could force a prefix of / and
	 * the file would then expand on extract to //str. The len == 0 below
	 * makes this special case follow the spec to the letter.
d1186 1
a1186 1
	if ((len > TPFSZ) || (len == 0))
@


1.57
log
@Handle tar -o by setting the tar_nodir directly instead of faking up a
pax-like -o write_opt=nodir.

ok millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.56 2015/03/09 04:23:29 guenther Exp $	*/
d604 1
a604 1
	} else if ((arcn->type == PAX_HLK) || (arcn->type == PAX_HRG)) {
d648 1
a648 1
	if ((arcn->type == PAX_CTG) || (arcn->type == PAX_REG))
d955 1
a955 2
	if (((arcn->type == PAX_SLK) || (arcn->type == PAX_HLK) ||
	    (arcn->type == PAX_HRG)) && (arcn->ln_nlen > sizeof(hd->linkname))){
d1114 1
a1114 1
	if ((arcn->type == PAX_CTG) || (arcn->type == PAX_REG))
@


1.56
log
@Unrevert post-unlock:
* Prevent an archive from esacaping the current directory by itself:
  when extracting a symlink whose value is absolute or contains ".."
  components, just create a zero-length normal file (with additional
  tracking of the mode and hardlinks to the symlink) until everything
  else is extracted, then go back and replace it with the requested
  link (if it's still that zero-length placeholder).

* For tar without -P, if a path in the archive has any ".." components
  then strip everything up to and including the last of them (if
  it ends in ".." then it becomes ".")
  This mostly follows GNU tar's behavior, except for 'tar tf' and
  'tar xvf' we report the modified path that would be/was actually
  created instead of the raw path from the archive

  Above two fixes prompted by a report from Daniel Cegielka
  (daniel.cegielka (at) gmail.com)

* For directories whose times or mode will be fixed up in the
  clean-up pass, record their dev+ino and then use
  open(O_DIRECTORY)+fstat() to verify that we're updating the correct
  directory before using futimens() and fchmod().

* Correct buffer overflow in handling of pax extension headers,
  caught by the memcpy() overlap check.


previously ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.54 2015/01/29 19:41:49 guenther Exp $	*/
d73 1
a73 1
static int tar_nodir;			/* do not write dirs under old tar */
@


1.55
log
@Recent changes haven't been completely stable, so revert for the 5.7 release

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.53 2014/02/19 03:59:47 guenther Exp $	*/
d61 1
a61 1
static int rd_xheader(ARCHD *, char *, off_t, char);
d737 1
a737 1
	HD_USTAR *hd;
d749 4
a755 1
	hd = (HD_USTAR *)buf;
d758 1
a758 1
	/* Process the Extended header. */
d760 2
a761 3
		if (rd_xheader(arcn, buf,
		    (off_t)asc_ul(hd->size, sizeof(hd->size), OCT),
		    hd->typeflag) < 0)
d763 10
d1208 5
a1212 1
#define MINXHDRSZ	6
d1215 1
a1215 1
rd_xheader(ARCHD *arcn, char *buf, off_t size, char typeflag)
d1217 2
a1218 1
	off_t len;
d1220 2
a1221 1
	char *nextp, *p;
d1223 24
a1246 8
	if (size < MINXHDRSZ) {
		paxwarn(1, "Invalid extended header length");
		return (-1);
	}
	if (rd_wrbuf(buf, size) != size)
		return (-1);
	if (rd_skip((off_t)BLKMULT - size) < 0)
		return (-1);
d1248 3
a1250 2
	for (p = buf; size > 0; size -= len, p = nextp) {
		if (!isdigit((unsigned char)*p)) {
d1252 2
a1253 1
			return (-1);
d1256 2
a1257 3
		len = strtoll(p, &delim, 10);
		if (*delim != ' ' || (errno == ERANGE &&
		    (len == LLONG_MIN || len == LLONG_MAX)) ||
d1260 2
a1261 1
			return (-1);
d1263 12
a1274 4
		if (len > size) {
			paxwarn(1, "Extended header record length %lld is "
			    "out of range", (long long)len);
			return (-1);
d1281 2
a1282 1
			return (-1);
d1285 1
a1285 1
		if (typeflag == XHDRTYPE) {
d1294 1
d1297 1
a1297 2
	/* Update the ustar header. */
	if (rd_wrbuf(buf, BLKMULT) != BLKMULT)
d1299 1
a1299 1
	return (0);
@


1.55.2.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.55 2015/02/21 22:48:23 guenther Exp $	*/
d61 1
a61 1
static int rd_xheader(ARCHD *arcn, int, off_t);
d737 1
a737 1
	HD_USTAR *hd = (HD_USTAR *)buf;
a748 4

#ifndef SMALL
reset:
#endif
d752 1
d755 1
a755 1
	/* Process Extended headers. */
d757 3
a759 2
		if (rd_xheader(arcn, hd->typeflag == GHDRTYPE,
		    (off_t)asc_ul(hd->size, sizeof(hd->size), OCT)) < 0)
a760 10

		/* Update and check the ustar header. */
		if (rd_wrbuf(buf, BLKMULT) != BLKMULT)
			return (-1);
		if (ustar_id(buf, BLKMULT) < 0)
			return(-1);

		/* if the next block is another extension, reset the values */
		if (hd->typeflag == XHDRTYPE || hd->typeflag == GHDRTYPE)
			goto reset;
d1196 1
a1196 5
/* shortest possible extended record: "5 a=\n" */
#define MINXHDRSZ	5

/* longest record we'll accept */
#define MAXXHDRSZ	BLKMULT
d1199 1
a1199 1
rd_xheader(ARCHD *arcn, int global, off_t size)
d1201 1
a1201 2
	char buf[MAXXHDRSZ];
	unsigned long len;
d1203 1
a1203 2
	char *nextp, *p, *end;
	int pad, ret = 0;
d1205 8
a1212 2
	/* before we alter size, make note of how much we have to skip */
	pad = TAR_PAD((unsigned)size);
d1214 2
a1215 25
	p = end = buf;
	while (size > 0 || p < end) {
		if (size > 0) {
			int rdlen;

			/* shift stuff down */
			if (p > buf) {
				memmove(buf, p, end - p);
				end -= p - buf;
				p = buf;
			}

			/* fill starting at end */
			rdlen = MINIMUM(size, (buf + sizeof buf) - end);
			if (rd_wrbuf(end, rdlen) != rdlen) {
				ret = -1;
				break;
			}
			size -= rdlen;
			end += rdlen;
		}

		/* [p, end) is good */
		if (memchr(p, ' ', end - p) == NULL ||
		    !isdigit((unsigned char)*p)) {
d1217 1
a1217 2
			ret = -1;
			break;
d1220 3
a1222 2
		len = strtoul(p, &delim, 10);
		if (*delim != ' ' || (errno == ERANGE && len == ULONG_MAX) ||
d1225 1
a1225 2
			ret = -1;
			break;
d1227 4
a1230 12
		if (len > end - p) {
			paxwarn(1, "Extended header record length %lu is "
			    "out of range", len);
			/* if we can just toss this record, do so */
			len -= end - p;
			if (len <= size && rd_skip(len) == 0) {
				size -= len;
				p = end = buf;
				continue;
			}
			ret = -1;
			break;
d1237 1
a1237 2
			ret = -1;
			break;
d1240 1
a1240 1
		if (!global) {
a1248 1
		p = nextp;
d1251 2
a1252 1
	if (rd_skip(size + pad) < 0)
d1254 1
a1254 1
	return (ret);
@


1.54
log
@Correct buffer overflow in handling of pax extension headers, caught
by the memcpy() overlap check.

ok millert@@ deraadt@@
@
text
@d61 1
a61 1
static int rd_xheader(ARCHD *arcn, int, off_t);
d737 1
a737 1
	HD_USTAR *hd = (HD_USTAR *)buf;
a748 4

#ifndef SMALL
reset:
#endif
d752 1
d755 1
a755 1
	/* Process Extended headers. */
d757 3
a759 2
		if (rd_xheader(arcn, hd->typeflag == GHDRTYPE,
		    (off_t)asc_ul(hd->size, sizeof(hd->size), OCT)) < 0)
a760 10

		/* Update and check the ustar header. */
		if (rd_wrbuf(buf, BLKMULT) != BLKMULT)
			return (-1);
		if (ustar_id(buf, BLKMULT) < 0)
			return(-1);

		/* if the next block is another extension, reset the values */
		if (hd->typeflag == XHDRTYPE || hd->typeflag == GHDRTYPE)
			goto reset;
d1196 1
a1196 5
/* shortest possible extended record: "5 a=\n" */
#define MINXHDRSZ	5

/* longest record we'll accept */
#define MAXXHDRSZ	BLKMULT
d1199 1
a1199 1
rd_xheader(ARCHD *arcn, int global, off_t size)
d1201 1
a1201 2
	char buf[MAXXHDRSZ];
	unsigned long len;
d1203 1
a1203 2
	char *nextp, *p, *end;
	int pad, ret = 0;
d1205 8
a1212 2
	/* before we alter size, make note of how much we have to skip */
	pad = TAR_PAD((unsigned)size);
d1214 2
a1215 25
	p = end = buf;
	while (size > 0 || p < end) {
		if (size > 0) {
			int rdlen;

			/* shift stuff down */
			if (p > buf) {
				memmove(buf, p, end - p);
				end -= p - buf;
				p = buf;
			}

			/* fill starting at end */
			rdlen = MINIMUM(size, (buf + sizeof buf) - end);
			if (rd_wrbuf(end, rdlen) != rdlen) {
				ret = -1;
				break;
			}
			size -= rdlen;
			end += rdlen;
		}

		/* [p, end) is good */
		if (memchr(p, ' ', end - p) == NULL ||
		    !isdigit((unsigned char)*p)) {
d1217 1
a1217 2
			ret = -1;
			break;
d1220 3
a1222 2
		len = strtoul(p, &delim, 10);
		if (*delim != ' ' || (errno == ERANGE && len == ULONG_MAX) ||
d1225 1
a1225 2
			ret = -1;
			break;
d1227 4
a1230 12
		if (len > end - p) {
			paxwarn(1, "Extended header record length %lu is "
			    "out of range", len);
			/* if we can just toss this record, do so */
			len -= end - p;
			if (len <= size && rd_skip(len) == 0) {
				size -= len;
				p = end = buf;
				continue;
			}
			ret = -1;
			break;
d1237 1
a1237 2
			ret = -1;
			break;
d1240 1
a1240 1
		if (!global) {
a1248 1
		p = nextp;
d1251 2
a1252 1
	if (rd_skip(size + pad) < 0)
d1254 1
a1254 1
	return (ret);
@


1.53
log
@Map negative mtimes to zero instead of skipping the affected files.

problem noted by miod@@
ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.52 2014/01/08 06:41:49 guenther Exp $	*/
d61 1
a61 1
static int rd_xheader(ARCHD *, char *, off_t, char);
d737 1
a737 1
	HD_USTAR *hd;
d749 4
a755 1
	hd = (HD_USTAR *)buf;
d758 1
a758 1
	/* Process the Extended header. */
d760 2
a761 3
		if (rd_xheader(arcn, buf,
		    (off_t)asc_ul(hd->size, sizeof(hd->size), OCT),
		    hd->typeflag) < 0)
d763 10
d1208 5
a1212 1
#define MINXHDRSZ	6
d1215 1
a1215 1
rd_xheader(ARCHD *arcn, char *buf, off_t size, char typeflag)
d1217 2
a1218 1
	off_t len;
d1220 2
a1221 1
	char *nextp, *p;
d1223 24
a1246 8
	if (size < MINXHDRSZ) {
		paxwarn(1, "Invalid extended header length");
		return (-1);
	}
	if (rd_wrbuf(buf, size) != size)
		return (-1);
	if (rd_skip((off_t)BLKMULT - size) < 0)
		return (-1);
d1248 3
a1250 2
	for (p = buf; size > 0; size -= len, p = nextp) {
		if (!isdigit((unsigned char)*p)) {
d1252 2
a1253 1
			return (-1);
d1256 2
a1257 3
		len = strtoll(p, &delim, 10);
		if (*delim != ' ' || (errno == ERANGE &&
		    (len == LLONG_MIN || len == LLONG_MAX)) ||
d1260 2
a1261 1
			return (-1);
d1263 12
a1274 4
		if (len > size) {
			paxwarn(1, "Extended header record length %lld is "
			    "out of range", (long long)len);
			return (-1);
d1281 2
a1282 1
			return (-1);
d1285 1
a1285 1
		if (typeflag == XHDRTYPE) {
d1294 1
d1297 1
a1297 2
	/* Update the ustar header. */
	if (rd_wrbuf(buf, BLKMULT) != BLKMULT)
d1299 1
a1299 1
	return (0);
@


1.53.6.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.53 2014/02/19 03:59:47 guenther Exp $	*/
d61 1
a61 1
static int rd_xheader(ARCHD *arcn, int, off_t);
d737 1
a737 1
	HD_USTAR *hd = (HD_USTAR *)buf;
a748 4

#ifndef SMALL
reset:
#endif
d752 1
d755 1
a755 1
	/* Process Extended headers. */
d757 3
a759 2
		if (rd_xheader(arcn, hd->typeflag == GHDRTYPE,
		    (off_t)asc_ul(hd->size, sizeof(hd->size), OCT)) < 0)
a760 10

		/* Update and check the ustar header. */
		if (rd_wrbuf(buf, BLKMULT) != BLKMULT)
			return (-1);
		if (ustar_id(buf, BLKMULT) < 0)
			return(-1);

		/* if the next block is another extension, reset the values */
		if (hd->typeflag == XHDRTYPE || hd->typeflag == GHDRTYPE)
			goto reset;
d1196 1
a1196 5
/* shortest possible extended record: "5 a=\n" */
#define MINXHDRSZ	5

/* longest record we'll accept */
#define MAXXHDRSZ	BLKMULT
d1199 1
a1199 1
rd_xheader(ARCHD *arcn, int global, off_t size)
d1201 1
a1201 2
	char buf[MAXXHDRSZ];
	unsigned long len;
d1203 1
a1203 2
	char *nextp, *p, *end;
	int pad, ret = 0;
d1205 8
a1212 2
	/* before we alter size, make note of how much we have to skip */
	pad = TAR_PAD((unsigned)size);
d1214 2
a1215 25
	p = end = buf;
	while (size > 0 || p < end) {
		if (size > 0) {
			int rdlen;

			/* shift stuff down */
			if (p > buf) {
				memmove(buf, p, end - p);
				end -= p - buf;
				p = buf;
			}

			/* fill starting at end */
			rdlen = MIN(size, (buf + sizeof buf) - end);
			if (rd_wrbuf(end, rdlen) != rdlen) {
				ret = -1;
				break;
			}
			size -= rdlen;
			end += rdlen;
		}

		/* [p, end) is good */
		if (memchr(p, ' ', end - p) == NULL ||
		    !isdigit((unsigned char)*p)) {
d1217 1
a1217 2
			ret = -1;
			break;
d1220 3
a1222 2
		len = strtoul(p, &delim, 10);
		if (*delim != ' ' || (errno == ERANGE && len == ULONG_MAX) ||
d1225 1
a1225 2
			ret = -1;
			break;
d1227 4
a1230 12
		if (len > end - p) {
			paxwarn(1, "Extended header record length %lu is "
			    "out of range", len);
			/* if we can just toss this record, do so */
			len -= end - p;
			if (len <= size && rd_skip(len) == 0) {
				size -= len;
				p = end = buf;
				continue;
			}
			ret = -1;
			break;
d1237 1
a1237 2
			ret = -1;
			break;
d1240 1
a1240 1
		if (!global) {
a1248 1
		p = nextp;
d1251 2
a1252 1
	if (rd_skip(size + pad) < 0)
d1254 1
a1254 1
	return (ret);
@


1.52
log
@Zap trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.51 2014/01/08 04:58:36 guenther Exp $	*/
d630 2
d633 1
a633 2
	    ul_oct((u_long)arcn->sb.st_gid, hd->gid, sizeof(hd->gid), 0) ||
	    uqd_oct(arcn->sb.st_mtime, hd->mtime, sizeof(hd->mtime), 1))
d1079 3
a1081 2
	if (ul_oct((u_long)arcn->sb.st_mode, hd->mode, sizeof(hd->mode), 3) ||
	    uqd_oct(arcn->sb.st_mtime, hd->mtime, sizeof(hd->mtime), 3))
@


1.51
log
@Eliminate poisonous LONG_OFF_T conditional

adjective suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.50 2014/01/08 04:41:41 guenther Exp $	*/
d787 1
a787 1
	if (!arcn->ln_nlen && 
@


1.50
log
@Mark some functions as printf-like and fix a bogus format string

ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.49 2013/11/21 15:54:45 deraadt Exp $	*/
a406 3
#ifdef LONG_OFF_T
	arcn->sb.st_size = (off_t)asc_ul(hd->size, sizeof(hd->size), OCT);
#else
a407 1
#endif
a617 4
#		ifdef LONG_OFF_T
		if (ul_oct((u_long)arcn->sb.st_size, hd->size,
		    sizeof(hd->size), 1)) {
#		else
a619 1
#		endif
a798 3
#ifdef LONG_OFF_T
	arcn->sb.st_size = (off_t)asc_ul(hd->size, sizeof(hd->size), OCT);
#else
a799 1
#endif
a1034 4
#		ifdef LONG_OFF_T
		if (ul_oct((u_long)arcn->sb.st_size, hd->size,
		    sizeof(hd->size), 3)) {
#		else
a1036 1
#		endif
@


1.49
log
@add unsigned char casts for specific calls to ctype.h macros.
ok guenther step
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.48 2013/07/03 04:08:29 guenther Exp $	*/
d1244 2
a1245 2
			paxwarn(1, "Extended header record length %j is "
			    "out of range", len);
@


1.48
log
@cpio and ustar formats store times in octal fields that are 11 characters
wide, so they support up to 33bits.  Take advantage of the extra bits by
no longer forcing them into 32bit ints before the time_t conversion.  This
gets us another 204 years of range once time_t changes type

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.47 2013/04/11 00:44:26 guenther Exp $	*/
d1231 1
a1231 1
		if (!isdigit(*p)) {
@


1.47
log
@The tweaks I suggested to the previous diff resulted in the typeflag
being checked after it was overwritten by the next block read in.
Eliminate the argument aliasing that led to this being overlooked
by passing rd_xheader() the size and typeflag directly.

problem discovery and ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.46 2013/04/09 18:30:34 fgsch Exp $	*/
a58 1
#ifndef LONG_OFF_T
a59 1
#endif
a199 1
#ifndef LONG_OFF_T
a252 1
#endif
d381 1
d412 5
a416 1
	arcn->sb.st_mtime = (time_t)asc_ul(hd->mtime, sizeof(hd->mtime), OCT);
d641 1
a641 1
	    ul_oct((u_long)(u_int)arcn->sb.st_mtime, hd->mtime, sizeof(hd->mtime), 1))
d750 1
d813 5
a817 1
	arcn->sb.st_mtime = (time_t)asc_ul(hd->mtime, sizeof(hd->mtime), OCT);
d1097 1
a1097 1
	    ul_oct((u_long)(u_int)arcn->sb.st_mtime,hd->mtime,sizeof(hd->mtime),3))
@


1.46
log
@Add extended header support for ustar.  Currently only path and linkpath are
handled.
input from zhuk and guenther. tested by zhuk and sthen on a bulk.
ok guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.45 2013/03/27 17:14:10 zhuk Exp $	*/
d63 1
a63 1
static int rd_xheader(ARCHD *, char *, HD_USTAR **);
d763 3
a765 1
		if (rd_xheader(arcn, buf, &hd) < 0)
d1209 1
a1209 1
rd_xheader(ARCHD *arcn, char *buf, HD_USTAR **hd)
d1211 1
a1211 1
	off_t len, size;
a1214 1
	size = (off_t)asc_ul((*hd)->size, sizeof((*hd)->size), OCT);
d1250 1
a1250 1
		if ((*hd)->typeflag == XHDRTYPE) {
a1263 1
	*hd = (HD_USTAR *)buf;
@


1.45
log
@Enable support for write_opt=nodir for ustar archives which helps to fix
issues with some crappy tar archive readers out there that rely on the
fact that directory entries ends up with "/" when created by GNU Tar, and
now I'm finishing this commit message by mentioning people who gave input
and okays: deraadt@@ millert@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.44 2012/12/04 02:24:45 deraadt Exp $	*/
d40 3
d62 3
d760 30
a789 13
	/*
	 * see if the filename is split into two parts. if, so joint the parts.
	 * we copy the prefix first and add a / between the prefix and name.
	 */
	dest = arcn->name;
	if (*(hd->prefix) != '\0') {
		cnt = fieldcpy(dest, sizeof(arcn->name) - 1, hd->prefix,
		    sizeof(hd->prefix));
		dest += cnt;
		*dest++ = '/';
		cnt++;
	} else {
		cnt = 0;
d792 2
a793 3
	if (hd->typeflag != LONGLINKTYPE && hd->typeflag != LONGNAMETYPE) {
		arcn->nlen = cnt + expandname(dest, sizeof(arcn->name) - cnt,
		    &gnu_name_string, hd->name, sizeof(hd->name));
d1201 66
@


1.44
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.43 2010/12/02 04:08:27 tedu Exp $	*/
d915 6
@


1.43
log
@a -N option for tar that uses numeric only IDs, useful for cross system
tar file manipulation.  with advice from guenther and jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.42 2009/10/27 23:59:22 deraadt Exp $	*/
a39 1
#include <sys/param.h>
@


1.42
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.41 2006/03/04 20:24:55 otto Exp $	*/
d798 1
a798 1
	if (gid_name(hd->gname, &(arcn->sb.st_gid)) < 0)
d801 1
a801 1
	if (uid_name(hd->uname, &(arcn->sb.st_uid)) < 0)
d1064 7
a1070 2
	strncpy(hd->uname, name_uid(arcn->sb.st_uid, 0), sizeof(hd->uname));
	strncpy(hd->gname, name_gid(arcn->sb.st_gid, 0), sizeof(hd->gname));
@


1.41
log
@Properly take into account that the name and prefix field in the tar
header are not always NUL-terminated. This means there's room for 1
more byte in those field. This effectively reverts revs 1.13 and 1.14;
ok jaredy@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.40 2005/12/17 19:47:02 otto Exp $	*/
a35 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)tar.c	8.2 (Berkeley) 4/18/94";
#else
static const char rcsid[] = "$OpenBSD: tar.c,v 1.40 2005/12/17 19:47:02 otto Exp $";
#endif
#endif /* not lint */
@


1.40
log
@Avoid sign extend when writing time stamps; fixes "tar: Ustar header
field is too small for foo" error messages when writing files with
negative time stamps on 64 bit archs.
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.39 2005/06/13 19:20:05 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.39 2005/06/13 19:20:05 otto Exp $";
d929 1
a929 1
	    (arcn->type == PAX_HRG)) && (arcn->ln_nlen >= sizeof(hd->linkname))){
d1119 2
d1122 1
a1122 1
	if (len < TNMSZ)
d1124 1
a1124 1
	if (len > (TPFSZ + TNMSZ))
d1131 2
a1132 1
	 * prefix we can find)
d1134 1
a1134 1
	start = name + len - TNMSZ;
d1152 1
a1152 1
	if ((len >= TPFSZ) || (len == 0))
@


1.39
log
@Fix writing of old-style tar headers. Filenames and linknames actually
are not NUL terminated if the fill the whole field.
ok millert@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.38 2005/04/28 06:58:07 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.38 2005/04/28 06:58:07 otto Exp $";
d643 1
a643 1
	    ul_oct((u_long)arcn->sb.st_mtime, hd->mtime, sizeof(hd->mtime), 1))
d1070 1
a1070 1
	    ul_oct((u_long)arcn->sb.st_mtime,hd->mtime,sizeof(hd->mtime),3))
@


1.38
log
@Use a special crafted string copy function to copy data from ustar
headers to the generic pax structs. ustar is "funny" since some fields
are not always NUL terminated. Old-style tar headers and ustar
creation remains to be done. ok millert@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.37 2005/04/21 21:47:18 beck Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.37 2005/04/21 21:47:18 beck Exp $";
d556 2
a557 1
			paxwarn(1,"Link name too long for tar %s", arcn->ln_name);
d573 1
a573 1
	if (len >= sizeof(hd->name)) {
d588 1
a588 1
	strlcpy(hd->name, arcn->name, sizeof(hd->name));
d606 2
a607 1
		strlcpy(hd->linkname, arcn->ln_name, sizeof(hd->linkname));
d615 2
a616 1
		strlcpy(hd->linkname, arcn->ln_name, sizeof(hd->linkname));
d959 2
a960 1
		strlcpy(hd->prefix, arcn->name, sizeof(hd->prefix));
d968 2
a969 1
	strlcpy(hd->name, pt, sizeof(hd->name));
d1005 2
a1006 1
		strlcpy(hd->linkname, arcn->ln_name, sizeof(hd->linkname));
@


1.37
log
@fix strlcpy abuse in pax - this commit turns potential overflows into
potential non-spec compliance - the use of these fields as strings needs
to be revisited more thouroughly.
ok millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.36 2005/04/14 08:24:09 markus Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.36 2005/04/14 08:24:09 markus Exp $";
d724 1
a724 1
	if (hd->name[0] == '\0')
d766 2
a767 3
		cnt = strlcpy(dest, hd->prefix, sizeof(arcn->name) - 1);
		if (cnt >= sizeof(arcn->name) - 1)
			cnt = sizeof(arcn->name) - 2; /* XXX truncate? */
d1159 1
d1164 2
a1165 7
	} else {
		/* name is not necessarily NUL terminated */
		if (len > limit)
			len = limit + 1;
		if ((nlen = strlcpy(buf, name, len)) >= len)
			nlen = len - 1;
	}
@


1.36
log
@add the prefix length to nlen for ustar; ok otto millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.35 2005/04/10 18:08:53 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.35 2005/04/10 18:08:53 otto Exp $";
d767 2
@


1.35
log
@Handle path names of exactly 100 chars correctly. Based on a diff
from espie@@. ok espie@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.34 2004/10/23 19:34:14 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.34 2004/10/23 19:34:14 otto Exp $";
d775 1
a775 1
		arcn->nlen = expandname(dest, sizeof(arcn->name) - cnt,
@


1.34
log
@If a uid or gid does not fit into into the tar header, issue a warning
and use the uid/gid of nobody. Spotted by and ok drahn@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.33 2004/04/16 22:50:23 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.33 2004/04/16 22:50:23 deraadt Exp $";
d61 1
a61 1
static size_t expandname(char *, size_t, char **, const char *);
d405 1
a405 1
		    &gnu_name_string, hd->name);
d407 1
a407 1
		    &gnu_link_string, hd->linkname);
d776 1
a776 1
		    &gnu_name_string, hd->name);
d778 1
a778 1
		    &gnu_link_string, hd->linkname);
d1152 2
a1153 1
expandname(char *buf, size_t len, char **gnu_name, const char *name)
d1163 3
@


1.33
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.32 2004/03/30 16:14:23 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.32 2004/03/30 16:14:23 millert Exp $";
d69 5
d1034 28
a1062 2
	    ul_oct((u_long)arcn->sb.st_uid, hd->uid, sizeof(hd->uid), 3)  ||
	    ul_oct((u_long)arcn->sb.st_gid, hd->gid, sizeof(hd->gid), 3) ||
@


1.32
log
@Add support for expanding GNU long links from NetBSD.  I've had this
in my tree for ages but didn't have a proper test case.  Thanks to
otto@@ for providing one.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.31 2003/06/26 00:10:18 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.31 2003/06/26 00:10:18 deraadt Exp $";
d166 1
a166 1
	switch(term) {
d221 1
a221 1
	switch(term) {
d423 1
a423 1
	switch(hd->linkflag) {
d526 1
a526 1
	switch(arcn->type) {
d813 1
a813 1
	switch(hd->typeflag) {
d963 1
a963 1
	switch(arcn->type) {
@


1.31
log
@protos.  this requires changing the api for the *trail() functions a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.30 2003/06/02 23:32:09 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.30 2003/06/02 23:32:09 millert Exp $";
d61 1
d74 2
a75 1
char *gnu_hack_string;			/* GNU ././@@LongLink hackery */
d390 1
a392 1
	arcn->pat = NULL;
d398 5
a402 7
	if (gnu_hack_string) {
		arcn->nlen = strlcpy(arcn->name, gnu_hack_string,
		    sizeof(arcn->name));
		free(gnu_hack_string);
		gnu_hack_string = NULL;
	} else {
		arcn->nlen = strlcpy(arcn->name, hd->name, sizeof(arcn->name));
a429 2
		arcn->ln_nlen = strlcpy(arcn->ln_name, hd->linkname,
			sizeof(arcn->ln_name));
a438 2
		arcn->ln_nlen = strlcpy(arcn->ln_name, hd->linkname,
			sizeof(arcn->ln_name));
a446 2
		arcn->type = PAX_GLL;
		/* FALLTHROUGH */
d452 2
a453 2
		if (hd->linkflag != LONGLINKTYPE)
			arcn->type = PAX_GLF;
a455 2
		arcn->ln_name[0] = '\0';
		arcn->ln_nlen = 0;
a463 2
		arcn->ln_name[0] = '\0';
		arcn->ln_nlen = 0;
d750 1
a752 2
	arcn->pat = NULL;
	arcn->nlen = 0;
d765 2
d768 6
a773 7
	if (gnu_hack_string) {
		arcn->nlen = strlcpy(dest, gnu_hack_string,
		    sizeof(arcn->name) - cnt);
		free(gnu_hack_string);
		gnu_hack_string = NULL;
	} else {
		arcn->nlen = strlcpy(dest, hd->name, sizeof(arcn->name) - cnt);
a805 2
	arcn->ln_name[0] = '\0';
	arcn->ln_nlen = 0;
a859 5
		/*
		 * copy the link name
		 */
		arcn->ln_nlen = strlcpy(arcn->ln_name, hd->linkname,
			sizeof(arcn->ln_name));
a870 2
		arcn->ln_name[0] = '\0';
		arcn->ln_nlen = 0;
d1118 17
@


1.30
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.29 2002/10/18 15:38:11 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.29 2002/10/18 15:38:11 millert Exp $";
d113 1
a113 1
tar_trail(char *buf, int in_resync, int *cnt)
@


1.29
log
@Pull in some changes from NetBSD
o When extracting GNU tar archives, honor @@LongLink long links/files
o Add an option to prevent pax from prompting for the next volume
  upon premature end of archive.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.28 2002/10/16 19:20:02 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.28 2002/10/16 19:20:02 millert Exp $";
@


1.28
log
@sprinkle const; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.27 2002/10/16 18:40:30 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.27 2002/10/16 18:40:30 millert Exp $";
d77 1
d333 1
d400 8
a407 1
	arcn->nlen = strlcpy(arcn->name, hd->name, sizeof(arcn->name));
d454 15
d781 8
a788 1
	arcn->nlen = cnt + strlcpy(dest, hd->name, sizeof(arcn->name) - cnt);
d881 13
@


1.27
log
@Fix comment typos; most from NetBSD and FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.26 2002/10/16 17:43:10 millert Exp $	*/
d43 1
a43 1
static char sccsid[] = "@@(#)tar.c	8.2 (Berkeley) 4/18/94";
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.26 2002/10/16 17:43:10 millert Exp $";
@


1.26
log
@kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.25 2002/02/19 19:39:35 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.25 2002/02/19 19:39:35 millert Exp $";
d260 1
a260 1
 *	all blanks (BLNKSUM is that value pre-calculated, the sume of 8 blanks).
d473 1
a473 1
			 * skip value to the size field and caluculate the size
d1068 1
a1068 1
	 * field. We walk foward looking for a slash to split at. The idea is
@


1.25
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.24 2002/02/16 21:27:07 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.24 2002/02/16 21:27:07 millert Exp $";
d65 3
a67 3
static u_long tar_chksm(register char *, register int);
static char *name_split(register char *, register int);
static int ul_oct(u_long, register char *, register int, int);
d69 1
a69 1
static int uqd_oct(u_quad_t, register char *, register int, int);
d116 1
a116 1
tar_trail(register char *buf, register int in_resync, register int *cnt)
d118 1
a118 1
	register int i;
d159 1
a159 1
ul_oct(u_long val, register char *str, register int len, int term)
d161 1
a161 1
	register char *pt;
d214 1
a214 1
uqd_oct(u_quad_t val, register char *str, register int len, int term)
d216 1
a216 1
	register char *pt;
d268 1
a268 1
tar_chksm(register char *blk, register int len)
d270 2
a271 2
	register char *stop;
	register char *pt;
d309 1
a309 1
tar_id(register char *blk, int size)
d311 2
a312 2
	register HD_TAR *hd;
	register HD_USTAR *uhd;
d380 1
a380 1
tar_rd(register ARCHD *arcn, register char *buf)
d382 2
a383 2
	register HD_TAR *hd;
	register char *pt;
d507 1
a507 1
tar_wr(register ARCHD *arcn)
d509 1
a509 1
	register HD_TAR *hd;
d697 1
a697 1
	register HD_USTAR *hd;
d727 1
a727 1
ustar_rd(register ARCHD *arcn, register char *buf)
d729 3
a731 3
	register HD_USTAR *hd;
	register char *dest;
	register int cnt = 0;
d881 1
a881 1
ustar_wr(register ARCHD *arcn)
d883 2
a884 2
	register HD_USTAR *hd;
	register char *pt;
d1053 1
a1053 1
name_split(register char *name, register int len)
d1055 1
a1055 1
	register char *start;
@


1.24
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.23 2001/12/19 22:51:32 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.23 2001/12/19 22:51:32 millert Exp $";
a84 1
#ifdef __STDC__
a86 4
#else
int
tar_endwr()
#endif
a97 1
#ifdef __STDC__
a99 4
#else
off_t
tar_endrd()
#endif
a114 1
#ifdef __STDC__
a116 7
#else
int
tar_trail(buf, in_resync, cnt)
	register char *buf;
	register int in_resync;
	register int *cnt;
#endif
a157 1
#ifdef __STDC__
a159 8
#else
static int
ul_oct(val, str, len, term)
	u_long val;
	register char *str;
	register int len;
	int term;
#endif
a212 1
#ifdef __STDC__
a214 8
#else
static int
uqd_oct(val, str, len, term)
	u_quad_t val;
	register char *str;
	register int len;
	int term;
#endif
a266 1
#ifdef __STDC__
a268 6
#else
static u_long
tar_chksm(blk, len)
	register char *blk;
	register int len;
#endif
a307 1
#ifdef __STDC__
a309 6
#else
int
tar_id(blk, size)
	register char *blk;
	int size;
#endif
a341 1
#ifdef __STDC__
a343 4
#else
int
tar_opt()
#endif
a378 1
#ifdef __STDC__
a380 6
#else
int
tar_rd(arcn, buf)
	register ARCHD *arcn;
	register char *buf;
#endif
a505 1
#ifdef __STDC__
a507 5
#else
int
tar_wr(arcn)
	register ARCHD *arcn;
#endif
a662 1
#ifdef __STDC__
a664 4
#else
int
ustar_strd()
#endif
a677 1
#ifdef __STDC__
a679 4
#else
int
ustar_stwr()
#endif
a693 1
#ifdef __STDC__
a695 6
#else
int
ustar_id(blk, size)
	char *blk;
	int size;
#endif
a725 1
#ifdef __STDC__
a727 6
#else
int
ustar_rd(arcn, buf)
	register ARCHD *arcn;
	register char *buf;
#endif
a879 1
#ifdef __STDC__
a881 5
#else
int
ustar_wr(arcn)
	register ARCHD *arcn;
#endif
a1051 1
#ifdef __STDC__
a1053 6
#else
static char *
name_split(name, len)
	register char *name;
	register int len;
#endif
@


1.23
log
@When writing tar and ustar archives, zero out the header before we
do anything else to it.  This lets us restore the strlcpy() calls
and remove a buch of memset()s that were zeroing out individual
fields of the header.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.22 2001/12/19 19:59:26 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.22 2001/12/19 19:59:26 millert Exp $";
d65 3
a67 3
static u_long tar_chksm __P((register char *, register int));
static char *name_split __P((register char *, register int));
static int ul_oct __P((u_long, register char *, register int, int));
d69 1
a69 1
static int uqd_oct __P((u_quad_t, register char *, register int, int));
@


1.22
log
@More strlcpy() backout.  Various tar programs require ustar header
elements to be zero padded too.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.21 2001/12/19 19:47:50 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.21 2001/12/19 19:47:50 millert Exp $";
d633 4
a636 4
	 * padded with zero.  We set the linkflag field (type), the linkname
	 * (or zero if not used),the size, and set the padding (if any) to be
	 * added after the file data (0 for all other types, as they only have
	 * a header)
d638 1
d640 1
a640 2
	strncpy(hd->name, arcn->name, sizeof(hd->name) - 1);	/* zero pad */
	hd->name[sizeof(hd->name) - 1] = '\0';
d646 1
a646 1
		 * that ends with a /, we add the slash here. No data follows,
a649 1
		memset(hd->linkname, 0, sizeof(hd->linkname));
d658 1
a658 1
		strlcpy(hd->linkname,arcn->ln_name, sizeof(hd->linkname));
d666 1
a666 1
		strlcpy(hd->linkname,arcn->ln_name, sizeof(hd->linkname));
a673 1
		memset(hd->linkname, 0, sizeof(hd->linkname));
a966 3
 * NOTE:
 *	We use strncpy() instead of strlcpy() to please some picky tar
 *	programs that require all header elements to be zero padded.
d1010 5
d1027 1
a1027 2
		strncpy(hd->prefix, arcn->name, sizeof(hd->prefix) - 1);
		hd->prefix[sizeof(hd->prefix) - 1] = '\0';
d1029 1
a1029 2
	} else
		memset(hd->prefix, 0, sizeof(hd->prefix));
d1035 1
a1035 2
	strncpy(hd->name, pt, sizeof(hd->name) - 1);
	hd->name[sizeof(hd->name) - 1] = '\0';
a1042 3
		memset(hd->linkname, 0, sizeof(hd->linkname));
		memset(hd->devmajor, 0, sizeof(hd->devmajor));
		memset(hd->devminor, 0, sizeof(hd->devminor));
a1051 1
		memset(hd->linkname, 0, sizeof(hd->linkname));
a1060 3
		memset(hd->linkname, 0, sizeof(hd->linkname));
		memset(hd->devmajor, 0, sizeof(hd->devmajor));
		memset(hd->devminor, 0, sizeof(hd->devminor));
d1071 1
a1071 4
		strncpy(hd->linkname, arcn->ln_name, sizeof(hd->linkname) - 1);
		hd->linkname[sizeof(hd->linkname) - 1] = '\0';
		memset(hd->devmajor, 0, sizeof(hd->devmajor));
		memset(hd->devminor, 0, sizeof(hd->devminor));
a1084 3
		memset(hd->linkname, 0, sizeof(hd->linkname));
		memset(hd->devmajor, 0, sizeof(hd->devmajor));
		memset(hd->devminor, 0, sizeof(hd->devminor));
@


1.21
log
@Back out a strncpy -> strlcpy conversion.  When writing old style
tar files we need to zero-pad the file name or many tars will get
a directory checksum error trying to unpack the archive.

This does not affect ustar archives (pax's default) though whether
or not padding matters there still needs to be determined.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.20 2001/06/26 14:55:13 lebel Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.20 2001/06/26 14:55:13 lebel Exp $";
d969 3
d1027 2
a1028 1
		strlcpy(hd->prefix, arcn->name, sizeof(hd->prefix));
d1037 2
a1038 1
	strlcpy(hd->name, pt, sizeof(hd->name));
d1081 2
a1082 1
		strlcpy(hd->linkname,arcn->ln_name, sizeof(hd->linkname));
d1127 2
a1128 2
	strncpy(hd->uname,name_uid(arcn->sb.st_uid, 0),sizeof(hd->uname));
	strncpy(hd->gname,name_gid(arcn->sb.st_gid, 0),sizeof(hd->gname));
@


1.20
log
@really use strlcpy.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.19 2001/06/26 14:19:33 lebel Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.19 2001/06/26 14:19:33 lebel Exp $";
d631 3
a633 3
	 * copy the data out of the ARCHD into the tar header based on the type
	 * of the file. Remember many tar readers want the unused fields to be
	 * padded with zero. We set the linkflag field (type), the linkname
d639 2
a640 1
	strlcpy(hd->name, arcn->name, sizeof(hd->name));
@


1.19
log
@use strlcpy vs strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.18 2001/05/26 00:32:21 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.18 2001/05/26 00:32:21 millert Exp $";
d1023 1
a1023 1
		strncpy(hd->prefix, arcn->name, sizeof(hd->prefix));
d1032 1
a1032 1
	strncpy(hd->name, pt, sizeof(hd->name));
d1075 1
a1075 1
		strncpy(hd->linkname,arcn->ln_name, sizeof(hd->linkname));
@


1.18
log
@Get rid of NET2_FTS and NET2_REGEX #ifdefs since they are useless.
Change NET2_STAT into LONG_OFF_T for portability to systems with
a 32bit off_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.17 2001/05/16 03:04:59 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.17 2001/05/16 03:04:59 mickey Exp $";
d1023 1
a1023 2
		strncpy(hd->prefix, arcn->name, sizeof(hd->prefix) - 1);
		hd->prefix[sizeof(hd->prefix) - 1] = '\0';
d1032 1
a1032 2
	strncpy(hd->name, pt, sizeof(hd->name) - 1);
	hd->name[sizeof(hd->name) - 1] = '\0';
d1075 1
a1075 2
		strncpy(hd->linkname,arcn->ln_name, sizeof(hd->linkname) - 1);
		hd->linkname[sizeof(hd->linkname) - 1] = '\0';
@


1.17
log
@use proper str*cpy functions instead of home grown one, spaces; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.16 2001/01/04 20:31:25 todd Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.16 2001/01/04 20:31:25 todd Exp $";
d68 1
a68 1
#ifndef NET2_STAT
d228 1
a228 1
#ifndef NET2_STAT
d465 1
a465 1
#ifdef NET2_STAT
d675 1
a675 1
#		ifdef NET2_STAT
d858 1
a858 1
#ifdef NET2_STAT
d1098 1
a1098 1
#		ifdef NET2_STAT
@


1.16
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.15 2000/01/21 05:11:36 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.15 2000/01/21 05:11:36 tholo Exp $";
d460 1
a460 2
	arcn->nlen = l_strncpy(arcn->name, hd->name, sizeof(arcn->name) - 1);
	arcn->name[arcn->nlen] = '\0';
d487 2
a488 3
		arcn->ln_nlen = l_strncpy(arcn->ln_name, hd->linkname,
			sizeof(arcn->ln_name) - 1);
		arcn->ln_name[arcn->ln_nlen] = '\0';
d498 2
a499 3
		arcn->ln_nlen = l_strncpy(arcn->ln_name, hd->linkname,
			sizeof(arcn->ln_name) - 1);
		arcn->ln_name[arcn->ln_nlen] = '\0';
d550 1
a550 1
		*pt = '\0'; 
d639 1
a639 2
	l_strncpy(hd->name, arcn->name, sizeof(hd->name) - 1);
	hd->name[sizeof(hd->name) - 1] = '\0';
d658 1
a658 2
		l_strncpy(hd->linkname,arcn->ln_name, sizeof(hd->linkname) - 1);
		hd->linkname[sizeof(hd->linkname) - 1] = '\0';
d666 1
a666 2
		l_strncpy(hd->linkname,arcn->ln_name, sizeof(hd->linkname) - 1);
		hd->linkname[sizeof(hd->linkname) - 1] = '\0';
d845 1
a845 1
		cnt = l_strncpy(dest, hd->prefix, sizeof(arcn->name) - 2);
d850 1
a850 2
	arcn->nlen = cnt + l_strncpy(dest, hd->name, sizeof(arcn->name) - cnt);
	arcn->name[arcn->nlen] = '\0';
d941 2
a942 3
		arcn->ln_nlen = l_strncpy(arcn->ln_name, hd->linkname,
			sizeof(arcn->ln_name) - 1);
		arcn->ln_name[arcn->ln_nlen] = '\0';
d1023 2
a1024 1
		l_strncpy(hd->prefix, arcn->name, sizeof(hd->prefix) - 1);
d1033 1
a1033 1
	l_strncpy(hd->name, pt, sizeof(hd->name) - 1);
d1077 1
a1077 1
		l_strncpy(hd->linkname,arcn->ln_name, sizeof(hd->linkname) - 1);
d1111 2
a1112 2
	l_strncpy(hd->magic, TMAGIC, TMAGLEN);
	l_strncpy(hd->version, TVERSION, TVERSLEN);
d1123 2
a1124 2
	l_strncpy(hd->uname,name_uid(arcn->sb.st_uid, 0),sizeof(hd->uname));
	l_strncpy(hd->gname,name_gid(arcn->sb.st_gid, 0),sizeof(hd->gname));
d1143 1
a1143 1
    	/*
@


1.15
log
@Work with files larger than 2 Gb; from NetBSD change by mycroft@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.14 1998/10/19 05:46:12 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.14 1998/10/19 05:46:12 millert Exp $";
d315 1
a315 1
	u_long chksm = BLNKSUM;	/* inital value is checksum field sum */
@


1.14
log
@Fix off-by-one error when adding files of exactly 100 characters; wsanchez@@apple.com
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.13 1998/09/26 21:29:41 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.13 1998/09/26 21:29:41 millert Exp $";
d466 5
a470 1
	arcn->sb.st_size = (size_t)asc_ul(hd->size, sizeof(hd->size), OCT);
d865 5
a869 1
	arcn->sb.st_size = (size_t)asc_ul(hd->size, sizeof(hd->size), OCT);
@


1.13
log
@fix storage of paths that are exactly 100 chars; mgw@@pacbell.net
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.12 1997/09/01 18:30:03 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.12 1997/09/01 18:30:03 deraadt Exp $";
d998 1
a998 1
	    (arcn->type == PAX_HRG)) && (arcn->ln_nlen > sizeof(hd->linkname))){
d1179 1
a1179 1
	if (len > (TPFSZ + TNMSZ + 1))
d1186 1
a1186 2
	 * prefix we can find) (the -1 is correct the biggest piece would
	 * include the slash between the two parts that gets thrown away)
d1188 1
a1188 1
	start = name + len - TNMSZ - 1;
d1206 1
a1206 1
	if ((len > TPFSZ) || (len == 0))
@


1.12
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.11 1997/07/25 18:58:38 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.11 1997/07/25 18:58:38 mickey Exp $";
d624 1
a624 1
	if (len > sizeof(hd->name)) {
d1177 1
a1177 1
	if (len <= TNMSZ)
@


1.11
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.10 1997/06/04 00:15:18 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.10 1997/06/04 00:15:18 millert Exp $";
d189 1
a189 1
	
d253 1
a253 1
	
d322 2
a323 2
	while (pt < stop)	
		chksm += (u_long)(*pt++ & 0xff);	
d334 1
a334 1
		chksm += (u_long)(*pt++ & 0xff);	
d1035 1
a1035 1
	/* 
@


1.10
log
@Fix usage of l_strncpy() (noticed by Theo) and make l_strncpy()
pad with NULL's like strncpy(3).  This eliminates the need for
zf_strncpy(); ocurrences of zf_strncpy() have been changed to l_strncpy().
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.9 1997/04/05 22:36:19 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.9 1997/04/05 22:36:19 millert Exp $";
d85 1
a85 1
#if __STDC__
d103 1
a103 1
#if __STDC__
d125 1
a125 1
#if __STDC__
d176 1
a176 1
#if __STDC__
d240 1
a240 1
#if __STDC__
d303 1
a303 1
#if __STDC__
d351 1
a351 1
#if __STDC__
d392 1
a392 1
#if __STDC__
d434 1
a434 1
#if __STDC__
d567 1
a567 1
#if __STDC__
d734 1
a734 1
#if __STDC__
d754 1
a754 1
#if __STDC__
d775 1
a775 1
#if __STDC__
d814 1
a814 1
#if __STDC__
d973 1
a973 1
#if __STDC__
d1161 1
a1161 1
#if __STDC__
@


1.9
log
@Strip leading '/' of pathnames (only in tar mode).  -S option turns
this off like GNU tar.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.8 1997/04/02 00:31:58 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.8 1997/04/02 00:31:58 millert Exp $";
d460 1
a460 1
	arcn->nlen = l_strncpy(arcn->name, hd->name, sizeof(hd->name) - 1);
d485 1
a485 1
			sizeof(hd->linkname) - 1);
d497 1
a497 1
			sizeof(hd->linkname) - 1);
d638 1
a638 1
	zf_strncpy(hd->name, arcn->name, sizeof(hd->name) - 1);
d658 1
a658 1
		zf_strncpy(hd->linkname,arcn->ln_name, sizeof(hd->linkname) - 1);
d667 1
a667 1
		zf_strncpy(hd->linkname,arcn->ln_name, sizeof(hd->linkname) - 1);
d847 1
a847 2
		cnt = l_strncpy(dest, hd->prefix, sizeof(hd->prefix) - 1);
		hd->prefix[sizeof(hd->prefix) - 1] = '\0';
d852 1
a852 1
	arcn->nlen = cnt + l_strncpy(dest, hd->name, sizeof(hd->name) - 1);
d941 1
a941 1
			sizeof(hd->linkname) - 1);
d1023 1
a1023 1
		zf_strncpy(hd->prefix, arcn->name, sizeof(hd->prefix) - 1);
d1032 1
a1032 1
	zf_strncpy(hd->name, pt, sizeof(hd->name) - 1);
d1076 1
a1076 1
		zf_strncpy(hd->linkname,arcn->ln_name, sizeof(hd->linkname) - 1);
d1110 2
a1111 2
	zf_strncpy(hd->magic, TMAGIC, TMAGLEN);
	zf_strncpy(hd->version, TVERSION, TVERSLEN);
d1122 2
a1123 2
	zf_strncpy(hd->uname,name_uid(arcn->sb.st_uid, 0),sizeof(hd->uname));
	zf_strncpy(hd->gname,name_gid(arcn->sb.st_gid, 0),sizeof(hd->gname));
@


1.8
log
@Deal with old-style tar archives with a directory specifier (extension).
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.7 1997/03/25 09:30:22 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.7 1997/03/25 09:30:22 millert Exp $";
d639 1
a639 1
	arcn->name[sizeof(hd->name) - 1] = '\0';
@


1.7
log
@Back out my previous kludge to make tar files with short trailers work in
favor of a simpler change--never try to do a media change when invoked
as tar.  This fixes problems that crop up if gzip exits unhappily and
others.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.6 1997/02/16 06:54:21 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.6 1997/02/16 06:54:21 tholo Exp $";
d505 10
@


1.6
log
@Correct handling of long filenames that has been stored with a prefix in
the archive; generate POSIXly correct padding of octal fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.5 1997/02/10 06:48:16 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.5 1997/02/10 06:48:16 millert Exp $";
d160 1
a160 1
	if (!in_resync)
@


1.5
log
@Permit single block trailers differently.
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.4 1996/08/27 03:53:14 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.4 1996/08/27 03:53:14 tholo Exp $";
d169 1
a169 1
 *	different fields. term selects which kind to use. str is BLANK padded
d222 1
a222 1
		*pt-- = ' ';
d233 1
a233 1
 *	different fields. term selects which kind to use. str is BLANK padded
d286 1
a286 1
		*pt-- = ' ';
d695 1
a695 1
	    sizeof(hd->chksum), 2))
d828 1
d837 1
a837 1
		cnt = l_strncpy(arcn->name, hd->prefix, sizeof(hd->prefix) - 1);
d839 1
a839 1
		dest = arcn->name + arcn->nlen;
d841 1
d843 1
a843 2
	arcn->nlen = l_strncpy(dest, hd->name, sizeof(hd->name) - 1);
	arcn->nlen += cnt;
@


1.4
log
@Fix uses of strncpy
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.3 1996/06/23 14:20:43 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.3 1996/06/23 14:20:43 deraadt Exp $";
d160 1
a160 1
	if (!in_resync && (++*cnt >= NULLCNT))
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.5 1995/03/21 09:07:49 cgd Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: tar.c,v 1.5 1995/03/21 09:07:49 cgd Exp $";
d460 1
a460 1
	arcn->nlen = l_strncpy(arcn->name, hd->name, sizeof(hd->name));
d485 1
a485 1
			sizeof(hd->linkname));
d497 1
a497 1
			sizeof(hd->linkname));
d628 2
a629 1
	zf_strncpy(hd->name, arcn->name, sizeof(hd->name));
d648 2
a649 1
		zf_strncpy(hd->linkname,arcn->ln_name, sizeof(hd->linkname));
d657 2
a658 1
		zf_strncpy(hd->linkname,arcn->ln_name, sizeof(hd->linkname));
d836 2
a837 1
		cnt = l_strncpy(arcn->name, hd->prefix, sizeof(hd->prefix));
d841 1
a841 1
	arcn->nlen = l_strncpy(dest, hd->name, sizeof(hd->name));
d931 1
a931 1
			sizeof(hd->linkname));
d1013 1
a1013 1
		zf_strncpy(hd->prefix, arcn->name, sizeof(hd->prefix));
d1022 2
a1023 1
	zf_strncpy(hd->name, pt, sizeof(hd->name));
d1066 2
a1067 1
		zf_strncpy(hd->linkname,arcn->ln_name, sizeof(hd->linkname));
@


1.2
log
@Correct compile warnings
Rename warn() to paxwarn() so <err.h> can be included

Remove #include <ctype.h> when not needed; from FreeBSD
@
text
@d1 1
d45 1
a45 1
static char rcsid[] = "$NetBSD: tar.c,v 1.5 1995/03/21 09:07:49 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@a53 1
#include <ctype.h>
d404 1
a404 1
			warn(1, "Unknown tar format -o option/value pair %s=%s",
d406 1
a406 1
			warn(1,"%s=%s is the only supported tar format option",
d415 1
a415 1
			warn(1, "%s=%s is only supported when writing.",
d581 1
a581 1
		warn(1, "Tar cannot archive a character device %s",
d585 1
a585 1
		warn(1, "Tar cannot archive a block device %s", arcn->org_name);
d588 1
a588 1
		warn(1, "Tar cannot archive a socket %s", arcn->org_name);
d591 1
a591 1
		warn(1, "Tar cannot archive a fifo %s", arcn->org_name);
d597 1
a597 1
			warn(1,"Link name too long for tar %s", arcn->ln_name);
d614 1
a614 1
		warn(1, "File name too long for tar %s", arcn->name);
d670 1
a670 1
			warn(1,"File is too large for tar %s", arcn->org_name);
d705 1
a705 1
	warn(1, "Tar header field is too small for %s", arcn->org_name);
d975 1
a975 1
		warn(1, "Ustar cannot archive a socket %s", arcn->org_name);
d984 1
a984 1
		warn(1, "Link name too long for ustar %s", arcn->ln_name);
d993 1
a993 1
		warn(1, "File name too long for ustar %s", arcn->name);
d1087 1
a1087 1
			warn(1,"File is too long for ustar %s",arcn->org_name);
d1128 1
a1128 1
	warn(1, "Ustar header field is too small for %s", arcn->org_name);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
