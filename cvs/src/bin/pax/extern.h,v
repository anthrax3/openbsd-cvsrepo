head	1.58;
access;
symbols
	OPENBSD_6_1:1.57.0.4
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.54.0.4
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.53.0.4
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.35.0.2
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.34.0.8
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.6
	OPENBSD_5_0:1.34.0.4
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.33.0.10
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.6
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.8
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.4
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.32.0.6
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.4
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.31.0.6
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.4
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.27.0.4
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.21.0.4
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.15.0.8
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.15.0.6
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.4
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.14.0.4
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.58
date	2017.09.12.17.11.11;	author otto;	state Exp;
branches;
next	1.57;
commitid	O8IaeFeNkXg09HEH;

1.57
date	2016.08.25.01.44.55;	author guenther;	state Exp;
branches;
next	1.56;
commitid	udvMiyfPVZQYw9Ht;

1.56
date	2016.08.23.06.00.28;	author guenther;	state Exp;
branches;
next	1.55;
commitid	lequwSVdrsu8itF8;

1.55
date	2016.08.14.04.47.52;	author guenther;	state Exp;
branches;
next	1.54;
commitid	KTreFUOYbPKrm5vY;

1.54
date	2016.01.01.15.56.03;	author tedu;	state Exp;
branches;
next	1.53;
commitid	GaE4tzQnYDHDy9vm;

1.53
date	2015.03.19.05.14.24;	author guenther;	state Exp;
branches;
next	1.52;
commitid	s0WKwITEr5aJPBA2;

1.52
date	2015.03.15.21.53.09;	author guenther;	state Exp;
branches;
next	1.51;
commitid	AaUVnmaFPjKKDin0;

1.51
date	2015.03.15.19.47.27;	author guenther;	state Exp;
branches;
next	1.50;
commitid	GNp5QMuUaAzwIVNl;

1.50
date	2015.03.09.04.23.29;	author guenther;	state Exp;
branches;
next	1.49;
commitid	JMkpovMhu0rmLvCn;

1.49
date	2015.02.21.22.48.23;	author guenther;	state Exp;
branches
	1.49.2.1;
next	1.48;
commitid	AdteqX8nU06lUYnQ;

1.48
date	2015.02.15.22.18.29;	author millert;	state Exp;
branches;
next	1.47;
commitid	uRyOrDxTxh06jP2Y;

1.47
date	2015.02.12.23.44.57;	author guenther;	state Exp;
branches;
next	1.46;
commitid	lkvsxr9r9MdXqaQN;

1.46
date	2015.02.12.01.30.47;	author guenther;	state Exp;
branches;
next	1.45;
commitid	DMos38EAdN7hlJXS;

1.45
date	2015.02.11.23.14.46;	author guenther;	state Exp;
branches;
next	1.44;
commitid	lWdBzWkSKKObQ4Qj;

1.44
date	2015.02.05.22.32.20;	author sthen;	state Exp;
branches;
next	1.43;
commitid	QBujBhAFFXGSsgsF;

1.43
date	2015.02.05.07.49.25;	author guenther;	state Exp;
branches;
next	1.42;
commitid	4roKhm1wyg3vjc8b;

1.42
date	2014.07.14.06.00.22;	author guenther;	state Exp;
branches
	1.42.4.1;
next	1.41;
commitid	dlNCMAKnoCpgkwr2;

1.41
date	2014.05.23.19.47.49;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2014.01.19.10.22.57;	author guenther;	state Exp;
branches;
next	1.39;

1.39
date	2014.01.09.03.12.25;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2014.01.08.04.48.29;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2014.01.08.04.41.40;	author guenther;	state Exp;
branches;
next	1.36;

1.36
date	2013.07.03.04.08.29;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2012.12.04.02.27.00;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2010.12.02.04.08.27;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2008.05.06.06.54.28;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.17.08.38.04;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.28.06.58.07;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.25.19.39.52;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2004.11.29.16.23.22;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.30.16.14.22;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.26.00.10.17;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.13.17.51.14;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.23.32.08;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.10.18.15.38.11;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.10.16.19.20.02;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.16.17.43.10;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.17.18.19.49;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.26.00.32.21;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.16.03.04.56;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.07.19.04.14;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.09.16.37.54;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	98.09.20.02.22.21;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.07.24.23.19.18;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.06.04.00.15.15;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.04.05.22.36.12;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.03.02.09.46.43;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	97.02.27.23.32.57;	author michaels;	state Exp;
branches;
next	1.9;

1.9
date	97.01.26.10.33.22;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.01.24.19.41.20;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.12.09.12.00.14;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.10.27.06.45.10;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.09.22.20.09.53;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.14.20.33;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.11.06.41.49;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.04.19.02.24.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.17;	author deraadt;	state Exp;
branches;
next	;

1.42.4.1
date	2015.04.30.19.30.57;	author guenther;	state Exp;
branches;
next	;
commitid	tPD1f2vGi43RT0WC;

1.49.2.1
date	2015.04.30.19.28.46;	author guenther;	state Exp;
branches;
next	;
commitid	pbBButXFqiIh89mX;


desc
@@


1.58
log
@there is no offical way to get the max value of time_t, but this one works
on any sensible posix system (in which time_t must be an integer type)
ok deraadt@@ millert@@
@
text
@/*	$OpenBSD: extern.h,v 1.57 2016/08/25 01:44:55 guenther Exp $	*/
/*	$NetBSD: extern.h,v 1.5 1996/03/26 23:54:16 mrg Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)extern.h	8.2 (Berkeley) 4/18/94
 */

/*
 * External references from each source file
 */

/*
 * ar_io.c
 */
extern const char *arcname;
extern const char *gzip_program;
extern int force_one_volume;
int ar_open(const char *);
void ar_close(int _in_sig);
void ar_drain(void);
int ar_set_wr(void);
int ar_app_ok(void);
int ar_read(char *, int);
int ar_write(char *, int);
int ar_rdsync(void);
int ar_fow(off_t, off_t *);
int ar_rev(off_t );
int ar_next(void);

/*
 * ar_subs.c
 */
extern u_long flcnt;
void list(void);
void extract(void);
void append(void);
void archive(void);
void copy(void);

/*
 * buf_subs.c
 */
extern int blksz;
extern int wrblksz;
extern int maxflt;
extern int rdblksz;
extern off_t wrlimit;
extern off_t rdcnt;
extern off_t wrcnt;
int wr_start(void);
int rd_start(void);
void cp_start(void);
int appnd_start(off_t);
int rd_sync(void);
void pback(char *, int);
int rd_skip(off_t);
void wr_fin(void);
int wr_rdbuf(char *, int);
int rd_wrbuf(char *, int);
int wr_skip(off_t);
int wr_rdfile(ARCHD *, int, off_t *);
int rd_wrfile(ARCHD *, int, off_t *);
void cp_file(ARCHD *, int, int);
int buf_fill(void);
int buf_flush(int);

/*
 * cache.c
 */
int usrtb_start(void);
int grptb_start(void);
int uid_name(char *, uid_t *);
int gid_name(char *, gid_t *);

/*
 * cpio.c
 */
int cpio_strd(void);
int cpio_trail(ARCHD *, char *, int, int *);
int cpio_endwr(void);
int cpio_id(char *, int);
int cpio_rd(ARCHD *, char *);
off_t cpio_endrd(void);
int cpio_stwr(void);
int cpio_wr(ARCHD *);
int vcpio_id(char *, int);
int crc_id(char *, int);
int crc_strd(void);
int vcpio_rd(ARCHD *, char *);
off_t vcpio_endrd(void);
int crc_stwr(void);
int vcpio_wr(ARCHD *);
int bcpio_id(char *, int);
int bcpio_rd(ARCHD *, char *);
off_t bcpio_endrd(void);
int bcpio_wr(ARCHD *);

/*
 * file_subs.c
 */
int file_creat(ARCHD *);
void file_close(ARCHD *, int);
int lnk_creat(ARCHD *);
int cross_lnk(ARCHD *);
int chk_same(ARCHD *);
int node_creat(ARCHD *);
int unlnk_exist(char *, int);
int chk_path(char *, uid_t, gid_t);
void set_ftime(const char *, const struct timespec *,
    const struct timespec *, int);
void fset_ftime(const char *, int, const struct timespec *,
    const struct timespec *, int);
int set_ids(char *, uid_t, gid_t);
int fset_ids(char *, int, uid_t, gid_t);
void set_pmode(char *, mode_t);
void fset_pmode(char *, int, mode_t);
int set_attr(const struct file_times *, int _force_times, mode_t, int _do_mode,
    int _in_sig);
int file_write(int, char *, int, int *, int *, int, char *);
void file_flush(int, char *, int);
void rdfile_close(ARCHD *, int *);
int set_crc(ARCHD *, int);

/*
 * ftree.c
 */
int ftree_start(void);
int ftree_add(char *, int);
void ftree_sel(ARCHD *);
void ftree_skipped_newer(ARCHD *);
void ftree_chk(void);
int next_file(ARCHD *);

/*
 * gen_subs.c
 */
void ls_list(ARCHD *, time_t, FILE *);
void ls_tty(ARCHD *);
void safe_print(const char *, FILE *);
u_long asc_ul(char *, int, int);
int ul_asc(u_long, char *, int, int);
unsigned long long asc_ull(char *, int, int);
int ull_asc(unsigned long long, char *, int, int);
size_t fieldcpy(char *, size_t, const char *, size_t);

/*
 * getoldopt.c
 */
int getoldopt(int, char **, const char *);

/*
 * options.c
 */
extern FSUB fsub[];
extern int ford[];
void options(int, char **);
OPLIST * opt_next(void);
int opt_add(const char *);
int bad_opt(void);
extern char *chdname;

/*
 * pat_rep.c
 */
int rep_add(char *);
int pat_add(char *, char *);
void pat_chk(void);
int pat_sel(ARCHD *);
int pat_match(ARCHD *);
int mod_name(ARCHD *);
int set_dest(ARCHD *, char *, int);
int has_dotdot(const char *);

/*
 * pax.c
 */
extern int act;
extern FSUB *frmt;
extern int cflag;
extern int cwdfd;
extern int dflag;
extern int iflag;
extern int kflag;
extern int lflag;
extern int nflag;
extern int tflag;
extern int uflag;
extern int vflag;
extern int Dflag;
extern int Hflag;
extern int Lflag;
extern int Nflag;
extern int Xflag;
extern int Yflag;
extern int Zflag;
extern int zeroflag;
extern int vfpart;
extern int patime;
extern int pmtime;
extern int nodirs;
extern int pmode;
extern int pids;
extern int rmleadslash;
extern int exit_val;
extern int docrc;
extern char *dirptr;
extern char *argv0;
extern enum op_mode { OP_PAX, OP_TAR, OP_CPIO } op_mode;
extern FILE *listf;
extern int listfd;
extern char *tempfile;
extern char *tempbase;
extern int havechd;

void sig_cleanup(int);

/*
 * sel_subs.c
 */
int sel_chk(ARCHD *);
int grp_add(char *);
int usr_add(char *);
int trng_add(char *);

/*
 * tables.c
 */
int lnk_start(void);
int chk_lnk(ARCHD *);
void purg_lnk(ARCHD *);
void lnk_end(void);
int ftime_start(void);
int chk_ftime(ARCHD *);
int sltab_start(void);
int sltab_add_sym(const char *_path, const char *_value, mode_t _mode);
int sltab_add_link(const char *, const struct stat *);
void sltab_process(int _in_sig);
int name_start(void);
int add_name(char *, int, char *);
void sub_name(char *, int *, int);
#ifndef NOCPIO
int dev_start(void);
int add_dev(ARCHD *);
int map_dev(ARCHD *, u_long, u_long);
#else
# define dev_start()	0
# define add_dev(x)	0
# define map_dev(x,y,z)	0
#endif /* NOCPIO */
int atdir_start(void);
void atdir_end(void);
void add_atdir(char *, dev_t, ino_t, const struct timespec *,
    const struct timespec *);
int do_atdir(const char *, dev_t, ino_t);
int dir_start(void);
void add_dir(char *, struct stat *, int);
void delete_dir(dev_t, ino_t);
void proc_dir(int _in_sig);
u_int st_hash(const char *, int, int);

/*
 * tar.c
 */
extern int tar_nodir;
extern char *gnu_name_string, *gnu_link_string;
int tar_endwr(void);
off_t tar_endrd(void);
int tar_trail(ARCHD *, char *, int, int *);
int tar_id(char *, int);
int tar_opt(void);
int tar_rd(ARCHD *, char *);
int tar_wr(ARCHD *);
int ustar_strd(void);
int ustar_id(char *, int);
int ustar_rd(ARCHD *, char *);
int ustar_wr(ARCHD *);

/*
 * tty_subs.c
 */
int tty_init(void);
void tty_prnt(const char *, ...)
    __attribute__((nonnull(1), format(printf, 1, 2)));
int tty_read(char *, int);
void paxwarn(int, const char *, ...)
    __attribute__((nonnull(2), format(printf, 2, 3)));
void syswarn(int, int, const char *, ...)
    __attribute__((nonnull(3), format(printf, 3, 4)));
@


1.57
log
@Replace name_{uid,gid}() with the libc routines user_from_uid() and
group_from_gid().  Eliminate some superfluous strncpy() calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.56 2016/08/23 06:00:28 guenther Exp $	*/
d271 1
a271 1
void sub_name(char *, int *, size_t);
@


1.56
log
@Instead of doing strcmp(argv0), track the invocation mode (pax/tar/cpio)
in a separate variable

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.55 2016/08/14 04:47:52 guenther Exp $	*/
a100 2
int uidtb_start(void);
int gidtb_start(void);
a102 2
char * name_uid(uid_t, int);
char * name_gid(gid_t, int);
a304 1
int ustar_stwr(void);
@


1.55
log
@Replace u_quad_t with unsigned long long and replace "uqd" with "ull" in
function names to match.  Pull some tangled assignments out of conditions
and use >>= where possible.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.54 2016/01/01 15:56:03 tedu Exp $	*/
d243 1
@


1.54
log
@don't declar main. from Michal Mazurek
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.53 2015/03/19 05:14:24 guenther Exp $	*/
d177 2
a178 2
u_quad_t asc_uqd(char *, int, int);
int uqd_asc(u_quad_t, char *, int, int);
@


1.53
log
@Use struct timespec internally.  This gives nanosecond precision to pax -rw
and a basis for support of mtime and atime values in pax-format extended
header records.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.52 2015/03/15 21:53:09 guenther Exp $	*/
a248 1
int main(int, char **);
@


1.52
log
@Define chdname once in a .c and make it extern in the .h
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.51 2015/03/15 19:47:27 guenther Exp $	*/
d144 4
a147 2
void set_ftime(char *fnm, time_t mtime, time_t atime, int frc);
void fset_ftime(char *fnm, int, time_t mtime, time_t atime, int frc);
d287 2
a288 1
void add_atdir(char *, dev_t, ino_t, time_t, time_t);
@


1.51
log
@Handle tar -o by setting the tar_nodir directly instead of faking up a
pax-like -o write_opt=nodir.

ok millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.50 2015/03/09 04:23:29 guenther Exp $	*/
d193 1
a193 1
char *chdname;
@


1.50
log
@Unrevert post-unlock:
* Prevent an archive from esacaping the current directory by itself:
  when extracting a symlink whose value is absolute or contains ".."
  components, just create a zero-length normal file (with additional
  tracking of the mode and hardlinks to the symlink) until everything
  else is extracted, then go back and replace it with the requested
  link (if it's still that zero-length placeholder).

* For tar without -P, if a path in the archive has any ".." components
  then strip everything up to and including the last of them (if
  it ends in ".." then it becomes ".")
  This mostly follows GNU tar's behavior, except for 'tar tf' and
  'tar xvf' we report the modified path that would be/was actually
  created instead of the raw path from the archive

  Above two fixes prompted by a report from Daniel Cegielka
  (daniel.cegielka (at) gmail.com)

* For directories whose times or mode will be fixed up in the
  clean-up pass, record their dev+ino and then use
  open(O_DIRECTORY)+fstat() to verify that we're updating the correct
  directory before using futimens() and fchmod().

* Correct buffer overflow in handling of pax extension headers,
  caught by the memcpy() overlap check.


previously ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.48 2015/02/15 22:18:29 millert Exp $	*/
d296 1
@


1.49
log
@Recent changes haven't been completely stable, so revert for the 5.7 release

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.42 2014/07/14 06:00:22 guenther Exp $	*/
d150 2
d205 1
d267 4
d274 1
d278 5
d286 1
a286 1
int get_atdir(dev_t, ino_t, time_t *, time_t *);
d289 1
@


1.49.2.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.49 2015/02/21 22:48:23 guenther Exp $	*/
a149 2
int set_attr(const struct file_times *, int _force_times, mode_t, int _do_mode,
    int _in_sig);
a202 1
int has_dotdot(const char *);
a263 4
int sltab_start(void);
int sltab_add_sym(const char *_path, const char *_value, mode_t _mode);
int sltab_add_link(const char *, const struct stat *);
void sltab_process(int _in_sig);
a266 1
#ifndef NOCPIO
a269 5
#else
# define dev_start()	0
# define add_dev(x)	0
# define map_dev(x,y,z)	0
#endif /* NOCPIO */
d273 1
a273 1
int do_atdir(const char *, dev_t, ino_t);
a275 1
void delete_dir(dev_t, ino_t);
@


1.48
log
@Fix two bugs.  The first affected tar files with the same
directory listed twice with nothing created inside the directory
in between the two instances of the directory.  The other fixes
extracting symlinks when the -C option is used.  From guenther@@
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.47 2015/02/12 23:44:57 guenther Exp $	*/
a149 2
int set_attr(const struct file_times *, int _force_times, mode_t, int _do_mode,
    int _in_sig);
a202 1
int has_dotdot(const char *);
a263 4
int sltab_start(void);
int sltab_add_sym(const char *_path, const char *_value, mode_t _mode);
int sltab_add_link(const char *, const struct stat *);
void sltab_process(int _in_sig);
a266 1
#ifndef NOCPIO
a269 5
#else
# define dev_start()	0
# define add_dev(x)	0
# define map_dev(x,y,z)	0
#endif /* NOCPIO */
d273 1
a273 1
int do_atdir(const char *, dev_t, ino_t);
a275 1
void delete_dir(dev_t, ino_t);
@


1.47
log
@Prevent an archive from esacaping the current directory by itself:
when extracting a symlink whose value is absolute or contains ".."
components, just create a zero-length normal file (with additional
tracking of the mode and hardlinks to the symlink) until everything
else is extracted, then go back and replace it with the requested
link (if its still that zero-length placeholder).

This and previous symlink and ".." path fixes prompted by a report
from Daniel Cegielka (daniel.cegielka (at) gmail.com)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.46 2015/02/12 01:30:47 guenther Exp $	*/
d289 1
@


1.46
log
@Put the dev+ino table for cpio hardlink matching behind #ifndef NOCPIO

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.45 2015/02/11 23:14:46 guenther Exp $	*/
d205 1
d267 4
@


1.45
log
@Take II, this time without an incorrect mode test.
For directories whose times or mode will be fixed up in the clean-up pass,
record their dev+ino and then use open(O_DIRECTORY)+fstat() to verify that
we're updating the correct directory before using futimens() and fchmod().

ok sthen@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.44 2015/02/05 22:32:20 sthen Exp $	*/
d269 1
d273 5
@


1.44
log
@backout previous for now; issues seen with "tar: Directory vanished before
restoring mode and times: ..." (and an error exit code, which breaks at least
building ports). krw@@ agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.42 2014/07/14 06:00:22 guenther Exp $	*/
d150 2
d275 1
a275 1
int get_atdir(dev_t, ino_t, time_t *, time_t *);
@


1.43
log
@For directories whose times or mode will be fixed up in the clean-up pass,
record their dev+ino and then use open(O_DIRECTORY)+fstat() to verify that
we're updating the correct directory before using futimens() and fchmod().

ok millert@@
@
text
@a149 2
int set_attr(const struct file_times *, int _force_times, mode_t, int _do_mode,
    int _in_sig);
d273 1
a273 1
int do_atdir(const char *, dev_t, ino_t);
@


1.42
log
@Constipate st_hash()
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.41 2014/05/23 19:47:49 guenther Exp $	*/
d150 2
d275 1
a275 1
int get_atdir(dev_t, ino_t, time_t *, time_t *);
@


1.42.4.1
log
@Backport trunk commit of 2015/03/09 04:23:29:
tar/pax/cpio had multiple issues:
 * extracting a malicious archive could create files outside of the
   current directory without using pre-existing symlinks to 'escape',
   and could change the timestamps and modes on preexisting files
 * tar without -P would permit extraction of paths with ".." components
 * there was a buffer overflow in the handling of pax extension headers
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.42 2014/07/14 06:00:22 guenther Exp $	*/
a149 2
int set_attr(const struct file_times *, int _force_times, mode_t, int _do_mode,
    int _in_sig);
a202 1
int has_dotdot(const char *);
a263 4
int sltab_start(void);
int sltab_add_sym(const char *_path, const char *_value, mode_t _mode);
int sltab_add_link(const char *, const struct stat *);
void sltab_process(int _in_sig);
a266 1
#ifndef NOCPIO
a269 5
#else
# define dev_start()	0
# define add_dev(x)	0
# define map_dev(x,y,z)	0
#endif /* NOCPIO */
d273 1
a273 1
int do_atdir(const char *, dev_t, ino_t);
a275 1
void delete_dir(dev_t, ino_t);
@


1.41
log
@Make the signal handler safe: block signals when updating data-structures
that are walked by routines called from the signal handler and use
dprintf() instead fprintf() in ar_close().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.40 2014/01/19 10:22:57 guenther Exp $	*/
d277 1
a277 1
u_int st_hash(char *, int, int);
@


1.40
log
@Forget to remove the prototype for set_lids() after removing the definition
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.39 2014/01/09 03:12:25 guenther Exp $	*/
d50 1
a50 1
void ar_close(void);
d239 1
d276 1
a276 1
void proc_dir(void);
@


1.39
log
@Update pax -v format to match "ls -l": display the year for dates
in the future and include a space between the major and minor numbers
for devices.  Eliminate bogus handling of LC_TIME environment variable.
Make strftime() format selection understandable by gcc -Wformat=2.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.38 2014/01/08 04:48:29 guenther Exp $	*/
a147 1
int set_lids(char *, uid_t, gid_t);
@


1.38
log
@Delete a bogus extern declaration and move around a couple others
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.37 2014/01/08 04:41:40 guenther Exp $	*/
a237 1
extern char *ltmfrmt;
@


1.37
log
@Mark some functions as printf-like and fix a bogus format string

ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.36 2013/07/03 04:08:29 guenther Exp $	*/
a135 1
extern char *gnu_name_string, *gnu_link_string;
d283 1
a283 1
extern char *gnu_hack_string;
@


1.36
log
@cpio and ustar formats store times in octal fields that are 11 characters
wide, so they support up to 33bits.  Take advantage of the extra bits by
no longer forcing them into 32bit ints before the time_t conversion.  This
gets us another 204 years of range once time_t changes type

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.35 2012/12/04 02:27:00 deraadt Exp $	*/
d302 2
a303 1
void tty_prnt(const char *, ...);
d305 4
a308 2
void paxwarn(int, const char *, ...);
void syswarn(int, int, const char *, ...);
@


1.35
log
@remove some unnecessary sys/cdefs.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.34 2010/12/02 04:08:27 tedu Exp $	*/
a174 1
#ifndef LONG_OFF_T
a176 1
#endif
@


1.34
log
@a -N option for tar that uses numeric only IDs, useful for cross system
tar file manipulation.  with advice from guenther and jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.33 2008/05/06 06:54:28 henning Exp $	*/
a41 2

#include <sys/cdefs.h>
@


1.33
log
@when pax is running in -u mode, and no files are beeing updated because
not one changed, we should not exit with an error but zero to indicate
success (matches solaris behaviour).
need to track wether files were skipped because of the -u checks for that
and take that into account later when taking the exit code decision.
ok theo, comments from otto and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.32 2006/11/17 08:38:04 otto Exp $	*/
d228 1
@


1.32
log
@Fix extracting and setting permissions for tar archives when
(multiple) -C options are present and/or (multiple) file selections
args are used. Based on a diff in NetBSD PR 22995. Tested by ckuethe@@
and jaredy@@; ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.31 2005/04/28 06:58:07 otto Exp $	*/
d165 1
@


1.31
log
@Use a special crafted string copy function to copy data from ustar
headers to the generic pax structs. ustar is "funny" since some fields
are not always NUL terminated. Old-style tar headers and ustar
creation remains to be done. ok millert@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.30 2005/04/25 19:39:52 otto Exp $	*/
d246 1
@


1.30
log
@Use the various f* functions to set owner, mode and times, instead
of operating on the path name. Avoids some races. ok deraadt@@ cloder@@
millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.29 2004/11/29 16:23:22 otto Exp $	*/
d180 1
@


1.29
log
@Build the table of created directories in-memory, instead of using
a tmp file.  Makes it possible to unpack an archive without using
/tmp, while memory usage is still within every reasonable limit.

"love it" deraadt@@  ok millert@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.28 2004/03/30 16:14:22 millert Exp $	*/
d148 1
d150 1
d153 1
@


1.28
log
@Add support for expanding GNU long links from NetBSD.  I've had this
in my tree for ages but didn't have a proper test case.  Thanks to
otto@@ for providing one.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.27 2003/06/26 00:10:17 deraadt Exp $	*/
d274 1
a274 1
void add_dir(char *, int, struct stat *, int);
@


1.27
log
@protos.  this requires changing the api for the *trail() functions a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.26 2003/06/13 17:51:14 millert Exp $	*/
d138 1
@


1.26
log
@Add a -0 flag to make pax use a NUL instead of a newline as the
pathname separator.  Works in list mode as well as read/copy mode.
Based on a patch from David Leonard; closes PR 3310
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.25 2003/06/02 23:32:08 millert Exp $	*/
d116 1
a116 1
int cpio_trail(ARCHD *);
d283 1
a283 1
int tar_trail(char *, int, int *);
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.24 2002/10/18 15:38:11 millert Exp $	*/
d225 1
@


1.24
log
@Pull in some changes from NetBSD
o When extracting GNU tar archives, honor @@LongLink long links/files
o Add an option to prevent pax from prompting for the next volume
  upon premature end of archive.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.23 2002/10/16 19:20:02 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.23
log
@sprinkle const; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.22 2002/10/16 17:43:10 millert Exp $	*/
d54 1
d283 1
@


1.22
log
@kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.21 2002/02/16 21:27:07 millert Exp $	*/
d52 1
a52 1
extern char *arcname;
d54 1
a54 1
int ar_open(char *);
d172 1
a172 1
void safe_print(char *, FILE *);
d183 1
a183 1
int getoldopt(int, char **, char *);
d192 1
a192 1
int opt_add(char *);
d299 1
a299 1
void tty_prnt(char *, ...);
d301 2
a302 2
void paxwarn(int, char *, ...);
void syswarn(int, int, char *, ...);
@


1.21
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.20 2001/07/17 18:19:49 millert Exp $	*/
d59 2
a60 2
int ar_read(register char *, register int);
int ar_write(register char *, register int);
d94 2
a95 2
int wr_rdbuf(register char *, register int);
int rd_wrbuf(register char *, register int);
d101 1
a101 1
int buf_flush(register int);
d119 1
a119 1
int cpio_trail(register ARCHD *);
d122 1
a122 1
int cpio_rd(register ARCHD *, register char *);
d125 1
a125 1
int cpio_wr(register ARCHD *);
d129 1
a129 1
int vcpio_rd(register ARCHD *, register char *);
d132 1
a132 1
int vcpio_wr(register ARCHD *);
d134 1
a134 1
int bcpio_rd(register ARCHD *, register char *);
d136 1
a136 1
int bcpio_wr(register ARCHD *);
d141 8
a148 8
int file_creat(register ARCHD *);
void file_close(register ARCHD *, int);
int lnk_creat(register ARCHD *);
int cross_lnk(register ARCHD *);
int chk_same(register ARCHD *);
int node_creat(register ARCHD *);
int unlnk_exist(register char *, register int);
int chk_path(register char *, uid_t, gid_t);
d153 1
a153 1
int file_write(int, char *, register int, int *, int *, int, char *);
d155 2
a156 2
void rdfile_close(register ARCHD *, register int *);
int set_crc(register ARCHD *, register int);
d162 2
a163 2
int ftree_add(register char *, int);
void ftree_sel(register ARCHD *);
d165 1
a165 1
int next_file(register ARCHD *);
d170 2
a171 2
void ls_list(register ARCHD *, time_t, FILE *);
void ls_tty(register ARCHD *);
d173 2
a174 2
u_long asc_ul(register char *, int, register int);
int ul_asc(u_long, register char *, register int, register int);
d176 2
a177 2
u_quad_t asc_uqd(register char *, int, register int);
int uqd_asc(u_quad_t, register char *, register int, register int);
d190 1
a190 1
void options(register int, register char **);
d192 1
a192 1
int opt_add(register char *);
d199 1
a199 1
int rep_add(register char *);
d202 4
a205 4
int pat_sel(register ARCHD *);
int pat_match(register ARCHD *);
int mod_name(register ARCHD *);
int set_dest(register ARCHD *, char *, int);
d250 4
a253 4
int sel_chk(register ARCHD *);
int grp_add(register char *);
int usr_add(register char *);
int trng_add(register char *);
d259 2
a260 2
int chk_lnk(register ARCHD *);
void purg_lnk(register ARCHD *);
d263 1
a263 1
int chk_ftime(register ARCHD *);
d265 2
a266 2
int add_name(register char *, int, char *);
void sub_name(register char *, int *, size_t);
d268 2
a269 2
int add_dev(register ARCHD *);
int map_dev(register ARCHD *, u_long, u_long);
d284 2
a285 2
int tar_trail(register char *, register int, register int *);
int tar_id(register char *, int);
d287 2
a288 2
int tar_rd(register ARCHD *, register char *);
int tar_wr(register ARCHD *);
d292 2
a293 2
int ustar_rd(register ARCHD *, register char *);
int ustar_wr(register ARCHD *);
@


1.20
log
@Add a safe_print() function that uses vis(3) if output is a tty.
Uses the vis C-style mode which is consistent with what GNU tar
does (though GNU tar does vis(3) regardless of whether output is a tty).

It may make sense to add a flag to force vis(3)ification like ls does
but I have not done that here as I'm reticent to add more flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.19 2001/05/26 00:32:21 millert Exp $	*/
d54 11
a64 11
int ar_open __P((char *));
void ar_close __P((void));
void ar_drain __P((void));
int ar_set_wr __P((void));
int ar_app_ok __P((void));
int ar_read __P((register char *, register int));
int ar_write __P((register char *, register int));
int ar_rdsync __P((void));
int ar_fow __P((off_t, off_t *));
int ar_rev __P((off_t ));
int ar_next __P((void));
d70 5
a74 5
void list __P((void));
void extract __P((void));
void append __P((void));
void archive __P((void));
void copy __P((void));
d86 16
a101 16
int wr_start __P((void));
int rd_start __P((void));
void cp_start __P((void));
int appnd_start __P((off_t));
int rd_sync __P((void));
void pback __P((char *, int));
int rd_skip __P((off_t));
void wr_fin __P((void));
int wr_rdbuf __P((register char *, register int));
int rd_wrbuf __P((register char *, register int));
int wr_skip __P((off_t));
int wr_rdfile __P((ARCHD *, int, off_t *));
int rd_wrfile __P((ARCHD *, int, off_t *));
void cp_file __P((ARCHD *, int, int));
int buf_fill __P((void));
int buf_flush __P((register int));
d106 8
a113 8
int uidtb_start __P((void));
int gidtb_start __P((void));
int usrtb_start __P((void));
int grptb_start __P((void));
char * name_uid __P((uid_t, int));
char * name_gid __P((gid_t, int));
int uid_name __P((char *, uid_t *));
int gid_name __P((char *, gid_t *));
d118 19
a136 19
int cpio_strd __P((void));
int cpio_trail __P((register ARCHD *));
int cpio_endwr __P((void));
int cpio_id __P((char *, int));
int cpio_rd __P((register ARCHD *, register char *));
off_t cpio_endrd __P((void));
int cpio_stwr __P((void));
int cpio_wr __P((register ARCHD *));
int vcpio_id __P((char *, int));
int crc_id __P((char *, int));
int crc_strd __P((void));
int vcpio_rd __P((register ARCHD *, register char *));
off_t vcpio_endrd __P((void));
int crc_stwr __P((void));
int vcpio_wr __P((register ARCHD *));
int bcpio_id __P((char *, int));
int bcpio_rd __P((register ARCHD *, register char *));
off_t bcpio_endrd __P((void));
int bcpio_wr __P((register ARCHD *));
d141 16
a156 16
int file_creat __P((register ARCHD *));
void file_close __P((register ARCHD *, int));
int lnk_creat __P((register ARCHD *));
int cross_lnk __P((register ARCHD *));
int chk_same __P((register ARCHD *));
int node_creat __P((register ARCHD *));
int unlnk_exist __P((register char *, register int));
int chk_path __P((register char *, uid_t, gid_t));
void set_ftime __P((char *fnm, time_t mtime, time_t atime, int frc));
int set_ids __P((char *, uid_t, gid_t));
int set_lids __P((char *, uid_t, gid_t));
void set_pmode __P((char *, mode_t));
int file_write __P((int, char *, register int, int *, int *, int, char *));
void file_flush __P((int, char *, int));
void rdfile_close __P((register ARCHD *, register int *));
int set_crc __P((register ARCHD *, register int));
d161 5
a165 5
int ftree_start __P((void));
int ftree_add __P((register char *, int));
void ftree_sel __P((register ARCHD *));
void ftree_chk __P((void));
int next_file __P((register ARCHD *));
d170 5
a174 5
void ls_list __P((register ARCHD *, time_t, FILE *));
void ls_tty __P((register ARCHD *));
void safe_print __P((char *, FILE *));
u_long asc_ul __P((register char *, int, register int));
int ul_asc __P((u_long, register char *, register int, register int));
d176 2
a177 2
u_quad_t asc_uqd __P((register char *, int, register int));
int uqd_asc __P((u_quad_t, register char *, register int, register int));
d183 1
a183 1
int getoldopt __P((int, char **, char *));
d190 4
a193 4
void options __P((register int, register char **));
OPLIST * opt_next __P((void));
int opt_add __P((register char *));
int bad_opt __P((void));
d199 7
a205 7
int rep_add __P((register char *));
int pat_add __P((char *, char *));
void pat_chk __P((void));
int pat_sel __P((register ARCHD *));
int pat_match __P((register ARCHD *));
int mod_name __P((register ARCHD *));
int set_dest __P((register ARCHD *, char *, int));
d244 2
a245 2
int main __P((int, char **));
void sig_cleanup __P((int));
d250 4
a253 4
int sel_chk __P((register ARCHD *));
int grp_add __P((register char *));
int usr_add __P((register char *));
int trng_add __P((register char *));
d258 20
a277 20
int lnk_start __P((void));
int chk_lnk __P((register ARCHD *));
void purg_lnk __P((register ARCHD *));
void lnk_end __P((void));
int ftime_start __P((void));
int chk_ftime __P((register ARCHD *));
int name_start __P((void));
int add_name __P((register char *, int, char *));
void sub_name __P((register char *, int *, size_t));
int dev_start __P((void));
int add_dev __P((register ARCHD *));
int map_dev __P((register ARCHD *, u_long, u_long));
int atdir_start __P((void));
void atdir_end __P((void));
void add_atdir __P((char *, dev_t, ino_t, time_t, time_t));
int get_atdir __P((dev_t, ino_t, time_t *, time_t *));
int dir_start __P((void));
void add_dir __P((char *, int, struct stat *, int));
void proc_dir __P((void));
u_int st_hash __P((char *, int, int));
d282 12
a293 12
int tar_endwr __P((void));
off_t tar_endrd __P((void));
int tar_trail __P((register char *, register int, register int *));
int tar_id __P((register char *, int));
int tar_opt __P((void));
int tar_rd __P((register ARCHD *, register char *));
int tar_wr __P((register ARCHD *));
int ustar_strd __P((void));
int ustar_stwr __P((void));
int ustar_id __P((char *, int));
int ustar_rd __P((register ARCHD *, register char *));
int ustar_wr __P((register ARCHD *));
d298 5
a302 5
int tty_init __P((void));
void tty_prnt __P((char *, ...));
int tty_read __P((char *, int));
void paxwarn __P((int, char *, ...));
void syswarn __P((int, int, char *, ...));
@


1.19
log
@Get rid of NET2_FTS and NET2_REGEX #ifdefs since they are useless.
Change NET2_STAT into LONG_OFF_T for portability to systems with
a 32bit off_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.18 2001/05/16 03:04:56 mickey Exp $	*/
d172 1
@


1.18
log
@use proper str*cpy functions instead of home grown one, spaces; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.17 2001/02/07 19:04:14 millert Exp $	*/
d174 1
a174 1
#ifndef NET2_STAT
@


1.17
log
@Honor TMPDIR environment variable and document the fact.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.16 2000/06/09 16:37:54 espie Exp $	*/
a171 1
int l_strncpy __P((register char *, register char *, int));
d179 1
a179 1
/* 
@


1.16
log
@Some minor cleanup, ok'd millert@@
- remove zflag variable, since gzip_program is enough to know what's
going on.
- fix ar_gzip call to not depend on global variables. Avoid bogus act
checks, avoid calling if fd == -1.
- do gzip check for append as early as possible.
- remove old K&R prototype when updating.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.15 1998/09/20 02:22:21 millert Exp $	*/
d241 2
@


1.15
log
@When invoked as tar, print verbose output to stdout, not stderr.  If in list mode or in create mode where create output is to stdout print to stderr
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.14 1997/07/24 23:19:18 millert Exp $	*/
d53 1
a53 1
extern char *gzip_program;
a221 1
extern int zflag;
@


1.14
log
@Stash fd of cwd instead of using getcwd() to stash path.
This works in cases where the parent dir is not readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.13 1997/06/04 00:15:15 millert Exp $	*/
d241 2
@


1.13
log
@Fix usage of l_strncpy() (noticed by Theo) and make l_strncpy()
pad with NULL's like strncpy(3).  This eliminates the need for
zf_strncpy(); ocurrences of zf_strncpy() have been changed to l_strncpy().
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.12 1997/04/05 22:36:12 millert Exp $	*/
d213 1
a240 1
extern char *cwdpt;
@


1.12
log
@Strip leading '/' of pathnames (only in tar mode).  -S option turns
this off like GNU tar.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.11 1997/03/02 09:46:43 tholo Exp $	*/
a171 1
void zf_strncpy __P((register char *, register char *, int));
d263 1
a263 1
void sub_name __P((register char *, int *));
@


1.11
log
@More complete cpio(1) emulation
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.10 1997/02/27 23:32:57 michaels Exp $	*/
d235 1
@


1.10
log
@fix pr system/124, reported by Janjaap van Velthooven (janjaap@@stack.nl).
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.8 1997/01/24 19:41:20 millert Exp $	*/
d232 1
@


1.9
log
@Support lchown().
@
text
@d195 1
@


1.8
log
@Support multiple -v options like GNU tar (> 1 -v means do ls-like output).
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.7 1996/12/09 12:00:14 deraadt Exp $	*/
d151 1
@


1.7
log
@revert to spawning compress-ing program. normally we want extracts using
'z' to also work on .Z files, but libz does not deal with compressed
data. Hacking the code to deal well with pipes has proven very hard.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.4 1996/06/23 14:20:33 deraadt Exp $	*/
d169 1
a169 1
void ls_list __P((register ARCHD *, time_t));
@


1.6
log
@Initial cut -C support in paxtar.  Exceeds GNU tar by quite a bit.
General pax still seems to work ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.5 1996/09/22 20:09:53 tholo Exp $	*/
d53 1
@


1.5
log
@Use zopen for compress-style compressed archives
Use libz for gzip-style compressed archives
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.4 1996/06/23 14:20:33 deraadt Exp $	*/
d160 1
a160 1
int ftree_add __P((register char *));
d198 1
a198 1
int pat_add __P((char *));
d236 1
@


1.4
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.5 1996/03/26 23:54:16 mrg Exp $	*/
a52 1
extern char *gzip_program;
@


1.3
log
@Correct compile warnings
Rename warn() to paxwarn() so <err.h> can be included

Remove #include <ctype.h> when not needed; from FreeBSD
@
text
@d1 1
@


1.2
log
@from mrg; impliment -z (gzip) in pax and tar, and -Z (compress) in tar
@
text
@d293 1
a293 1
void warn __P((int, char *, ...));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: extern.h,v 1.4 1995/03/21 09:07:16 cgd Exp $	*/
d52 1
d219 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
