head	1.101;
access;
symbols
	OPENBSD_6_2:1.101.0.2
	OPENBSD_6_2_BASE:1.101
	OPENBSD_6_1:1.101.0.4
	OPENBSD_6_1_BASE:1.101
	OPENBSD_6_0:1.93.0.2
	OPENBSD_6_0_BASE:1.93
	OPENBSD_5_9:1.92.0.2
	OPENBSD_5_9_BASE:1.92
	OPENBSD_5_8:1.91.0.4
	OPENBSD_5_8_BASE:1.91
	OPENBSD_5_7:1.86.0.2
	OPENBSD_5_7_BASE:1.86
	OPENBSD_5_6:1.86.0.4
	OPENBSD_5_6_BASE:1.86
	OPENBSD_5_5:1.84.0.4
	OPENBSD_5_5_BASE:1.84
	OPENBSD_5_4:1.77.0.2
	OPENBSD_5_4_BASE:1.77
	OPENBSD_5_3:1.76.0.2
	OPENBSD_5_3_BASE:1.76
	OPENBSD_5_2:1.75.0.2
	OPENBSD_5_2_BASE:1.75
	OPENBSD_5_1_BASE:1.74
	OPENBSD_5_1:1.74.0.6
	OPENBSD_5_0:1.74.0.4
	OPENBSD_5_0_BASE:1.74
	OPENBSD_4_9:1.74.0.2
	OPENBSD_4_9_BASE:1.74
	OPENBSD_4_8:1.73.0.4
	OPENBSD_4_8_BASE:1.73
	OPENBSD_4_7:1.73.0.2
	OPENBSD_4_7_BASE:1.73
	OPENBSD_4_6:1.70.0.8
	OPENBSD_4_6_BASE:1.70
	OPENBSD_4_5:1.70.0.4
	OPENBSD_4_5_BASE:1.70
	OPENBSD_4_4:1.70.0.2
	OPENBSD_4_4_BASE:1.70
	OPENBSD_4_3:1.67.0.6
	OPENBSD_4_3_BASE:1.67
	OPENBSD_4_2:1.67.0.4
	OPENBSD_4_2_BASE:1.67
	OPENBSD_4_1:1.67.0.2
	OPENBSD_4_1_BASE:1.67
	OPENBSD_4_0:1.64.0.2
	OPENBSD_4_0_BASE:1.64
	OPENBSD_3_9:1.63.0.4
	OPENBSD_3_9_BASE:1.63
	OPENBSD_3_8:1.63.0.2
	OPENBSD_3_8_BASE:1.63
	OPENBSD_3_7:1.61.0.4
	OPENBSD_3_7_BASE:1.61
	OPENBSD_3_6:1.61.0.2
	OPENBSD_3_6_BASE:1.61
	OPENBSD_3_5:1.60.0.2
	OPENBSD_3_5_BASE:1.60
	OPENBSD_3_4:1.59.0.2
	OPENBSD_3_4_BASE:1.59
	OPENBSD_3_3:1.56.0.2
	OPENBSD_3_3_BASE:1.56
	OPENBSD_3_2:1.51.0.2
	OPENBSD_3_2_BASE:1.51
	OPENBSD_3_1:1.50.0.2
	OPENBSD_3_1_BASE:1.50
	OPENBSD_3_0:1.48.0.2
	OPENBSD_3_0_BASE:1.48
	OPENBSD_2_9:1.47.0.2
	OPENBSD_2_9_BASE:1.47
	OPENBSD_2_8:1.42.0.2
	OPENBSD_2_8_BASE:1.42
	OPENBSD_2_7:1.41.0.2
	OPENBSD_2_7_BASE:1.41
	OPENBSD_2_6:1.40.0.2
	OPENBSD_2_6_BASE:1.40
	OPENBSD_2_5:1.35.0.2
	OPENBSD_2_5_BASE:1.35
	OPENBSD_2_4:1.34.0.2
	OPENBSD_2_4_BASE:1.34
	OPENBSD_2_3:1.33.0.2
	OPENBSD_2_3_BASE:1.33
	OPENBSD_2_2:1.30.0.2
	OPENBSD_2_2_BASE:1.30
	OPENBSD_2_1:1.24.0.2
	OPENBSD_2_1_BASE:1.24
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.101
date	2016.12.26.23.43.52;	author krw;	state Exp;
branches;
next	1.100;
commitid	vrrtXSUiwujWxgBE;

1.100
date	2016.08.26.04.40.27;	author guenther;	state Exp;
branches;
next	1.99;
commitid	pWOfqUI8wk36rVn1;

1.99
date	2016.08.26.04.33.11;	author guenther;	state Exp;
branches;
next	1.98;
commitid	q3ReWRB68FBGiL1j;

1.98
date	2016.08.25.01.44.55;	author guenther;	state Exp;
branches;
next	1.97;
commitid	udvMiyfPVZQYw9Ht;

1.97
date	2016.08.24.19.15.42;	author guenther;	state Exp;
branches;
next	1.96;
commitid	hOEbtL1c5lX25gOx;

1.96
date	2016.08.24.19.13.52;	author guenther;	state Exp;
branches;
next	1.95;
commitid	CIUgzEmb8basF3al;

1.95
date	2016.08.23.06.00.28;	author guenther;	state Exp;
branches;
next	1.94;
commitid	lequwSVdrsu8itF8;

1.94
date	2016.08.14.04.47.52;	author guenther;	state Exp;
branches;
next	1.93;
commitid	KTreFUOYbPKrm5vY;

1.93
date	2016.04.19.03.26.11;	author guenther;	state Exp;
branches;
next	1.92;
commitid	BTSOjuUM3RAWUaMB;

1.92
date	2015.12.06.12.00.16;	author tobias;	state Exp;
branches;
next	1.91;
commitid	CoyY8UEEpJPwBza5;

1.91
date	2015.05.18.20.26.16;	author czarkoff;	state Exp;
branches;
next	1.90;
commitid	0XlmAUimUPWQOOKd;

1.90
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.89;
commitid	6b2lLILbgCR1fvia;

1.89
date	2015.03.15.21.53.09;	author guenther;	state Exp;
branches;
next	1.88;
commitid	AaUVnmaFPjKKDin0;

1.88
date	2015.03.15.19.47.27;	author guenther;	state Exp;
branches;
next	1.87;
commitid	GNp5QMuUaAzwIVNl;

1.87
date	2015.03.12.04.15.03;	author guenther;	state Exp;
branches;
next	1.86;
commitid	bOaKdaMtDoZV3lP7;

1.86
date	2014.05.24.18.51.00;	author guenther;	state Exp;
branches;
next	1.85;

1.85
date	2014.05.07.14.56.57;	author tedu;	state Exp;
branches;
next	1.84;

1.84
date	2014.02.06.20.51.55;	author guenther;	state Exp;
branches;
next	1.83;

1.83
date	2014.02.05.20.35.42;	author halex;	state Exp;
branches;
next	1.82;

1.82
date	2014.01.30.13.30.11;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2014.01.11.05.36.26;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2014.01.08.06.43.34;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2014.01.08.05.52.47;	author guenther;	state Exp;
branches;
next	1.78;

1.78
date	2014.01.08.04.58.36;	author guenther;	state Exp;
branches;
next	1.77;

1.77
date	2013.03.27.17.14.10;	author zhuk;	state Exp;
branches;
next	1.76;

1.76
date	2012.12.04.02.24.45;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.74;

1.74
date	2010.12.02.04.08.27;	author tedu;	state Exp;
branches;
next	1.73;

1.73
date	2009.11.13.17.22.13;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2009.11.12.20.10.48;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2008.06.11.00.49.08;	author pvalchev;	state Exp;
branches;
next	1.69;

1.69
date	2008.05.28.20.04.59;	author sobrado;	state Exp;
branches;
next	1.68;

1.68
date	2008.05.17.23.31.52;	author sobrado;	state Exp;
branches;
next	1.67;

1.67
date	2007.02.24.09.50.55;	author jmc;	state Exp;
branches;
next	1.66;

1.66
date	2007.02.24.09.29.55;	author jmc;	state Exp;
branches;
next	1.65;

1.65
date	2006.11.17.08.38.04;	author otto;	state Exp;
branches;
next	1.64;

1.64
date	2006.04.09.03.35.34;	author jaredy;	state Exp;
branches;
next	1.63;

1.63
date	2005.06.02.19.11.06;	author jaredy;	state Exp;
branches;
next	1.62;

1.62
date	2005.05.24.16.33.45;	author jaredy;	state Exp;
branches;
next	1.61;

1.61
date	2004.04.16.22.50.23;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2003.11.30.16.58.24;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.26.00.10.17;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.13.17.51.14;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.02.23.32.08;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	2003.02.03.09.06.43;	author jmc;	state Exp;
branches;
next	1.55;

1.55
date	2002.10.18.15.38.11;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2002.10.16.19.20.02;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2002.10.16.18.40.30;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2002.10.16.17.43.10;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2002.09.06.18.17.30;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2001.05.26.00.32.21;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2001.02.10.17.21.14;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2001.02.09.14.04.33;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2001.02.07.19.43.10;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2001.02.05.00.32.12;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2000.11.09.03.36.10;	author provos;	state Exp;
branches;
next	1.42;

1.42
date	2000.06.09.16.37.54;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2000.01.22.20.24.52;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	99.07.28.12.33.40;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	99.07.27.20.00.45;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	99.07.04.18.21.11;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	99.05.23.17.19.22;	author aaron;	state Exp;
branches;
next	1.36;

1.36
date	99.04.29.12.59.03;	author aaron;	state Exp;
branches;
next	1.35;

1.35
date	98.12.07.23.45.46;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	98.09.20.02.22.22;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	98.03.31.17.14.21;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	98.03.03.05.11.36;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	98.01.22.06.21.29;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	97.09.01.18.29.54;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	97.07.25.18.58.32;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	97.07.23.19.15.57;	author kstailey;	state Exp;
branches;
next	1.27;

1.27
date	97.06.18.20.06.30;	author kstailey;	state Exp;
branches;
next	1.26;

1.26
date	97.06.18.18.48.26;	author kstailey;	state Exp;
branches;
next	1.25;

1.25
date	97.05.29.15.47.18;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	97.04.16.03.50.23;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	97.04.12.17.25.25;	author tholo;	state Exp;
branches;
next	1.22;

1.22
date	97.04.06.06.26.23;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	97.04.05.22.51.53;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	97.04.05.22.36.14;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.04.04.20.54.50;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	97.04.02.17.48.53;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.03.26.01.14.13;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.03.02.09.46.47;	author tholo;	state Exp;
branches;
next	1.15;

1.15
date	97.02.27.23.32.58;	author michaels;	state Exp;
branches;
next	1.14;

1.14
date	97.02.20.06.54.34;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	97.01.24.19.41.23;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	96.12.09.12.02.16;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.12.09.12.00.15;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.10.27.06.45.12;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.09.22.20.09.54;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.08.10.03.08.00;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.08.02.12.41.01;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.06.23.14.20.36;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.06.11.07.10.27;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.06.11.06.57.47;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.06.11.06.41.52;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.04.19.02.24.56;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.17;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.101
log
@Put some variable declarations under appropriate #if/#endif protection
so gcc doesn't complain about defining but not using them.

typo correction & ok jca@@
@
text
@/*	$OpenBSD: options.c,v 1.100 2016/08/26 04:40:27 guenther Exp $	*/
/*	$NetBSD: options.c,v 1.6 1996/03/26 23:54:18 mrg Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <limits.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "pax.h"
#include "cpio.h"
#include "tar.h"
#include "extern.h"

/*
 * argv[0] names. Used for tar and cpio emulation
 */

#define NM_TAR  "tar"
#define NM_CPIO "cpio"
#define NM_PAX  "pax"

/*
 * Constants used to specify the legal sets of flags in pax. For each major
 * operation mode of pax, a set of illegal flags is defined. If any one of
 * those illegal flags are found set, we scream and exit
 */

/*
 * flags (one for each option).
 */
#define	AF	0x00000001
#define	BF	0x00000002
#define	CF	0x00000004
#define	DF	0x00000008
#define	FF	0x00000010
#define	IF	0x00000020
#define	KF	0x00000040
#define	LF	0x00000080
#define	NF	0x00000100
#define	OF	0x00000200
#define	PF	0x00000400
#define	RF	0x00000800
#define	SF	0x00001000
#define	TF	0x00002000
#define	UF	0x00004000
#define	VF	0x00008000
#define	WF	0x00010000
#define	XF	0x00020000
#define	CBF	0x00040000	/* nonstandard extension */
#define	CDF	0x00080000	/* nonstandard extension */
#define	CEF	0x00100000	/* nonstandard extension */
#define	CGF	0x00200000	/* nonstandard extension */
#define	CHF	0x00400000	/* nonstandard extension */
#define	CLF	0x00800000	/* nonstandard extension */
#define	CPF	0x01000000	/* nonstandard extension */
#define	CTF	0x02000000	/* nonstandard extension */
#define	CUF	0x04000000	/* nonstandard extension */
#define	CXF	0x08000000
#define	CYF	0x10000000	/* nonstandard extension */
#define	CZF	0x20000000	/* nonstandard extension */
#define	C0F	0x40000000	/* nonstandard extension */

/*
 * ascii string indexed by bit position above (alter the above and you must
 * alter this string) used to tell the user what flags caused us to complain
 */
#define FLGCH	"abcdfiklnoprstuvwxBDEGHLPTUXYZ0"

/*
 * legal pax operation bit patterns
 */

#define ISLIST(x)	(((x) & (RF|WF)) == 0)
#define	ISEXTRACT(x)	(((x) & (RF|WF)) == RF)
#define ISARCHIVE(x)	(((x) & (AF|RF|WF)) == WF)
#define ISAPPND(x)	(((x) & (AF|RF|WF)) == (AF|WF))
#define	ISCOPY(x)	(((x) & (RF|WF)) == (RF|WF))
#define	ISWRITE(x)	(((x) & (RF|WF)) == WF)

/*
 * Illegal option flag subsets based on pax operation
 */

#define	BDEXTR	(AF|BF|LF|TF|WF|XF|CBF|CHF|CLF|CPF|CXF)
#define	BDARCH	(CF|KF|LF|NF|PF|RF|CDF|CEF|CYF|CZF)
#define	BDCOPY	(AF|BF|FF|OF|XF|CBF|CEF)
#define	BDLIST (AF|BF|IF|KF|LF|OF|PF|RF|TF|UF|WF|XF|CBF|CDF|CHF|CLF|CPF|CXF|CYF|CZF)


/*
 * Routines which handle command line options
 */

static char flgch[] = FLGCH;	/* list of all possible flags */
static OPLIST *ophead = NULL;	/* head for format specific options -x */
static OPLIST *optail = NULL;	/* option tail */

static int no_op(void);
static void printflg(unsigned int);
static off_t str_offt(char *);
static char *get_line(FILE *fp);
static void pax_options(int, char **);
static void pax_usage(void);
static void tar_options(int, char **);
static void tar_usage(void);
#ifndef NOCPIO
static void cpio_options(int, char **);
static void cpio_usage(void);
#endif

static int compress_id(char *_blk, int _size);
static int gzip_id(char *_blk, int _size);
static int bzip2_id(char *_blk, int _size);
static int xz_id(char *_blk, int _size);

#define GZIP_CMD	"gzip"		/* command to run as gzip */
#define COMPRESS_CMD	"compress"	/* command to run as compress */
#define BZIP2_CMD	"bzip2"		/* command to run as bzip2 */

/*
 *	Format specific routine table
 *	(see pax.h for description of each function)
 *
 *	name, blksz, hdsz, udev, hlk, blkagn, inhead, id, st_read,
 *	read, end_read, st_write, write, end_write, trail,
 *	rd_data, wr_data, options
 */

FSUB fsub[] = {
#ifdef NOCPIO
/* 0: OLD BINARY CPIO */
	{ },
/* 1: OLD OCTAL CHARACTER CPIO */
	{ },
/* 2: SVR4 HEX CPIO */
	{ },
/* 3: SVR4 HEX CPIO WITH CRC */
	{ },
#else
/* 0: OLD BINARY CPIO */
	{"bcpio", 5120, sizeof(HD_BCPIO), 1, 0, 0, 1, bcpio_id, cpio_strd,
	bcpio_rd, bcpio_endrd, cpio_stwr, bcpio_wr, cpio_endwr, cpio_trail,
	bad_opt},

/* 1: OLD OCTAL CHARACTER CPIO */
	{"cpio", 5120, sizeof(HD_CPIO), 1, 0, 0, 1, cpio_id, cpio_strd,
	cpio_rd, cpio_endrd, cpio_stwr, cpio_wr, cpio_endwr, cpio_trail,
	bad_opt},

/* 2: SVR4 HEX CPIO */
	{"sv4cpio", 5120, sizeof(HD_VCPIO), 1, 0, 0, 1, vcpio_id, cpio_strd,
	vcpio_rd, vcpio_endrd, cpio_stwr, vcpio_wr, cpio_endwr, cpio_trail,
	bad_opt},

/* 3: SVR4 HEX CPIO WITH CRC */
	{"sv4crc", 5120, sizeof(HD_VCPIO), 1, 0, 0, 1, crc_id, crc_strd,
	vcpio_rd, vcpio_endrd, crc_stwr, vcpio_wr, cpio_endwr, cpio_trail,
	bad_opt},
#endif
/* 4: OLD TAR */
	{"tar", 10240, BLKMULT, 0, 1, BLKMULT, 0, tar_id, no_op,
	tar_rd, tar_endrd, no_op, tar_wr, tar_endwr, tar_trail,
	tar_opt},

/* 5: POSIX USTAR */
	{"ustar", 10240, BLKMULT, 0, 1, BLKMULT, 0, ustar_id, ustar_strd,
	ustar_rd, tar_endrd, no_op, ustar_wr, tar_endwr, tar_trail,
	tar_opt},

#ifdef SMALL
/* 6: compress, to detect failure to use -Z */
	{ },
/* 7: xz, to detect failure to decompress it */
	{ },
/* 8: bzip2, to detect failure to use -j */
	{ },
/* 9: gzip, to detect failure to use -z */
	{ },
#else
/* 6: compress, to detect failure to use -Z */
	{NULL, 0, 4, 0, 0, 0, 0, compress_id},
/* 7: xz, to detect failure to decompress it */
	{NULL, 0, 4, 0, 0, 0, 0, xz_id},
/* 8: bzip2, to detect failure to use -j */
	{NULL, 0, 4, 0, 0, 0, 0, bzip2_id},
/* 9: gzip, to detect failure to use -z */
	{NULL, 0, 4, 0, 0, 0, 0, gzip_id},
#endif
};
#define	F_OCPIO	0	/* format when called as cpio -6 */
#define	F_ACPIO	1	/* format when called as cpio -c */
#define	F_CPIO	3	/* format when called as cpio */
#define F_OTAR	4	/* format when called as tar -o */
#define F_TAR	5	/* format when called as tar */
#define DEFLT	5	/* default write format from list above */

/*
 * ford is the archive search order used by get_arc() to determine what kind
 * of archive we are dealing with. This helps to properly id archive formats
 * some formats may be subsets of others....
 */
int ford[] = {5, 4, 9, 8, 7, 6, 3, 2, 1, 0, -1};

/*
 * Do we have -C anywhere and what is it?
 */
int havechd = 0;
char *chdname = NULL;

/*
 * options()
 *	figure out if we are pax, tar or cpio. Call the appropriate options
 *	parser
 */

void
options(int argc, char **argv)
{
	extern char *__progname;

	/*
	 * Are we acting like pax, tar or cpio (based on argv[0])
	 */
	argv0 = __progname;

	if (strcmp(NM_TAR, argv0) == 0) {
		op_mode = OP_TAR;
		tar_options(argc, argv);
		return;
	}
#ifndef NOCPIO
	else if (strcmp(NM_CPIO, argv0) == 0) {
		op_mode = OP_CPIO;
		cpio_options(argc, argv);
		return;
	}
#endif /* !NOCPIO */
	/*
	 * assume pax as the default
	 */
	argv0 = NM_PAX;
	op_mode = OP_PAX;
	pax_options(argc, argv);
}

/*
 * pax_options()
 *	look at the user specified flags. set globals as required and check if
 *	the user specified a legal set of flags. If not, complain and exit
 */

static void
pax_options(int argc, char **argv)
{
	int c;
	unsigned i;
	unsigned int flg = 0;
	unsigned int bflg = 0;
	const char *errstr;
	char *pt;

	/*
	 * process option flags
	 */
	while ((c=getopt(argc,argv,"ab:cdf:ijklno:p:rs:tuvwx:zB:DE:G:HLOPT:U:XYZ0"))
	    != -1) {
		switch (c) {
		case 'a':
			/*
			 * append
			 */
			flg |= AF;
			break;
		case 'b':
			/*
			 * specify blocksize
			 */
			flg |= BF;
			if ((wrblksz = (int)str_offt(optarg)) <= 0) {
				paxwarn(1, "Invalid block size %s", optarg);
				pax_usage();
			}
			break;
		case 'c':
			/*
			 * inverse match on patterns
			 */
			cflag = 1;
			flg |= CF;
			break;
		case 'd':
			/*
			 * match only dir on extract, not the subtree at dir
			 */
			dflag = 1;
			flg |= DF;
			break;
		case 'f':
			/*
			 * filename where the archive is stored
			 */
			arcname = optarg;
			flg |= FF;
			break;
		case 'i':
			/*
			 * interactive file rename
			 */
			iflag = 1;
			flg |= IF;
			break;
		case 'j':
			/*
			 * use bzip2.  Non standard option.
			 */
			gzip_program = BZIP2_CMD;
			break;
		case 'k':
			/*
			 * do not clobber files that exist
			 */
			kflag = 1;
			flg |= KF;
			break;
		case 'l':
			/*
			 * try to link src to dest with copy (-rw)
			 */
			lflag = 1;
			flg |= LF;
			break;
		case 'n':
			/*
			 * select first match for a pattern only
			 */
			nflag = 1;
			flg |= NF;
			break;
		case 'o':
			/*
			 * pass format specific options
			 */
			flg |= OF;
			if (opt_add(optarg) < 0)
				pax_usage();
			break;
		case 'p':
			/*
			 * specify file characteristic options
			 */
			for (pt = optarg; *pt != '\0'; ++pt) {
				switch (*pt) {
				case 'a':
					/*
					 * do not preserve access time
					 */
					patime = 0;
					break;
				case 'e':
					/*
					 * preserve user id, group id, file
					 * mode, access/modification times
					 */
					pids = 1;
					pmode = 1;
					patime = 1;
					pmtime = 1;
					break;
				case 'm':
					/*
					 * do not preserve modification time
					 */
					pmtime = 0;
					break;
				case 'o':
					/*
					 * preserve uid/gid
					 */
					pids = 1;
					break;
				case 'p':
					/*
					 * preserve file mode bits
					 */
					pmode = 1;
					break;
				default:
					paxwarn(1, "Invalid -p string: %c", *pt);
					pax_usage();
					break;
				}
			}
			flg |= PF;
			break;
		case 'r':
			/*
			 * read the archive
			 */
			flg |= RF;
			break;
		case 's':
			/*
			 * file name substitution name pattern
			 */
			if (rep_add(optarg) < 0) {
				pax_usage();
				break;
			}
			flg |= SF;
			break;
		case 't':
			/*
			 * preserve access time on filesystem nodes we read
			 */
			tflag = 1;
			flg |= TF;
			break;
		case 'u':
			/*
			 * ignore those older files
			 */
			uflag = 1;
			flg |= UF;
			break;
		case 'v':
			/*
			 * verbose operation mode
			 */
			vflag = 1;
			flg |= VF;
			break;
		case 'w':
			/*
			 * write an archive
			 */
			flg |= WF;
			break;
		case 'x':
			/*
			 * specify an archive format on write
			 */
			for (i = 0; i < sizeof(fsub)/sizeof(FSUB); ++i)
				if (fsub[i].name != NULL &&
				    strcmp(fsub[i].name, optarg) == 0)
					break;
			if (i < sizeof(fsub)/sizeof(FSUB)) {
				frmt = &fsub[i];
				flg |= XF;
				break;
			}
			paxwarn(1, "Unknown -x format: %s", optarg);
			(void)fputs("pax: Known -x formats are:", stderr);
			for (i = 0; i < (sizeof(fsub)/sizeof(FSUB)); ++i)
				if (fsub[i].name != NULL)
					(void)fprintf(stderr, " %s",
					    fsub[i].name);
			(void)fputs("\n\n", stderr);
			pax_usage();
			break;
		case 'z':
			/*
			 * use gzip.  Non standard option.
			 */
			gzip_program = GZIP_CMD;
			break;
		case 'B':
			/*
			 * non-standard option on number of bytes written on a
			 * single archive volume.
			 */
			if ((wrlimit = str_offt(optarg)) <= 0) {
				paxwarn(1, "Invalid write limit %s", optarg);
				pax_usage();
			}
			if (wrlimit % BLKMULT) {
				paxwarn(1, "Write limit is not a %d byte multiple",
				    BLKMULT);
				pax_usage();
			}
			flg |= CBF;
			break;
		case 'D':
			/*
			 * On extraction check file inode change time before the
			 * modification of the file name. Non standard option.
			 */
			Dflag = 1;
			flg |= CDF;
			break;
		case 'E':
			/*
			 * non-standard limit on read faults
			 * 0 indicates stop after first error, values
			 * indicate a limit
			 */
			flg |= CEF;
			maxflt = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr) {
				paxwarn(1, "Error count value: %s", errstr);
				pax_usage();
			}
			break;
		case 'G':
			/*
			 * non-standard option for selecting files within an
			 * archive by group (gid or name)
			 */
			if (grp_add(optarg) < 0) {
				pax_usage();
				break;
			}
			flg |= CGF;
			break;
		case 'H':
			/*
			 * follow command line symlinks only
			 */
			Hflag = 1;
			flg |= CHF;
			break;
		case 'L':
			/*
			 * follow symlinks
			 */
			Lflag = 1;
			flg |= CLF;
			break;
		case 'O':
			/*
			 * Force one volume.  Non standard option.
			 */
			force_one_volume = 1;
			break;
		case 'P':
			/*
			 * do NOT follow symlinks (default)
			 */
			Lflag = 0;
			flg |= CPF;
			break;
		case 'T':
			/*
			 * non-standard option for selecting files within an
			 * archive by modification time range (lower,upper)
			 */
			if (trng_add(optarg) < 0) {
				pax_usage();
				break;
			}
			flg |= CTF;
			break;
		case 'U':
			/*
			 * non-standard option for selecting files within an
			 * archive by user (uid or name)
			 */
			if (usr_add(optarg) < 0) {
				pax_usage();
				break;
			}
			flg |= CUF;
			break;
		case 'X':
			/*
			 * do not pass over mount points in the file system
			 */
			Xflag = 1;
			flg |= CXF;
			break;
		case 'Y':
			/*
			 * On extraction check file inode change time after the
			 * modification of the file name. Non standard option.
			 */
			Yflag = 1;
			flg |= CYF;
			break;
		case 'Z':
			/*
			 * On extraction check modification time after the
			 * modification of the file name. Non standard option.
			 */
			Zflag = 1;
			flg |= CZF;
			break;
		case '0':
			/*
			 * Use \0 as pathname terminator.
			 * (For use with the -print0 option of find(1).)
			 */
			zeroflag = 1;
			flg |= C0F;
			break;
		default:
			pax_usage();
			break;
		}
	}

	/*
	 * figure out the operation mode of pax read,write,extract,copy,append
	 * or list. check that we have not been given a bogus set of flags
	 * for the operation mode.
	 */
	if (ISLIST(flg)) {
		act = LIST;
		listf = stdout;
		bflg = flg & BDLIST;
	} else if (ISEXTRACT(flg)) {
		act = EXTRACT;
		bflg = flg & BDEXTR;
	} else if (ISARCHIVE(flg)) {
		act = ARCHIVE;
		bflg = flg & BDARCH;
	} else if (ISAPPND(flg)) {
		act = APPND;
		bflg = flg & BDARCH;
	} else if (ISCOPY(flg)) {
		act = COPY;
		bflg = flg & BDCOPY;
	} else
		pax_usage();
	if (bflg) {
		printflg(flg);
		pax_usage();
	}

	/*
	 * if we are writing (ARCHIVE) we use the default format if the user
	 * did not specify a format. when we write during an APPEND, we will
	 * adopt the format of the existing archive if none was supplied.
	 */
	if (!(flg & XF) && (act == ARCHIVE))
		frmt = &(fsub[DEFLT]);

	/*
	 * process the args as they are interpreted by the operation mode
	 */
	switch (act) {
	case LIST:
	case EXTRACT:
		for (; optind < argc; optind++)
			if (pat_add(argv[optind], NULL) < 0)
				pax_usage();
		break;
	case COPY:
		if (optind >= argc) {
			paxwarn(0, "Destination directory was not supplied");
			pax_usage();
		}
		--argc;
		dirptr = argv[argc];
		/* FALL THROUGH */
	case ARCHIVE:
	case APPND:
		for (; optind < argc; optind++)
			if (ftree_add(argv[optind], 0) < 0)
				pax_usage();
		/*
		 * no read errors allowed on updates/append operation!
		 */
		maxflt = 0;
		break;
	}
}


/*
 * tar_options()
 *	look at the user specified flags. set globals as required and check if
 *	the user specified a legal set of flags. If not, complain and exit
 */

static void
tar_options(int argc, char **argv)
{
	int c;
	int Oflag = 0;
	int nincfiles = 0;
	int incfiles_max = 0;
	struct incfile {
		char *file;
		char *dir;
	};
	struct incfile *incfiles = NULL;

	/*
	 * Set default values.
	 */
	rmleadslash = 1;

	/*
	 * process option flags
	 */
	while ((c = getoldopt(argc, argv,
	    "b:cef:hjmopqruts:vwxzBC:HI:LNOPXZ014578")) != -1) {
		switch (c) {
		case 'b':
			/*
			 * specify blocksize in 512-byte blocks
			 */
			if ((wrblksz = (int)str_offt(optarg)) <= 0) {
				paxwarn(1, "Invalid block size %s", optarg);
				tar_usage();
			}
			wrblksz *= 512;		/* XXX - check for int oflow */
			break;
		case 'c':
			/*
			 * create an archive
			 */
			act = ARCHIVE;
			break;
		case 'e':
			/*
			 * stop after first error
			 */
			maxflt = 0;
			break;
		case 'f':
			/*
			 * filename where the archive is stored
			 */
			arcname = optarg;
			break;
		case 'h':
			/*
			 * follow symlinks
			 */
			Lflag = 1;
			break;
		case 'j':
			/*
			 * use bzip2.  Non standard option.
			 */
			gzip_program = BZIP2_CMD;
			break;
		case 'm':
			/*
			 * do not preserve modification time
			 */
			pmtime = 0;
			break;
		case 'O':
			Oflag = 1;
			break;
		case 'o':
			Oflag = 2;
			tar_nodir = 1;
			break;
		case 'p':
			/*
			 * preserve uid/gid and file mode, regardless of umask
			 */
			pmode = 1;
			pids = 1;
			break;
		case 'q':
			/*
			 * select first match for a pattern only
			 */
			nflag = 1;
			break;
		case 'r':
		case 'u':
			/*
			 * append to the archive
			 */
			act = APPND;
			break;
		case 's':
			/*
			 * file name substitution name pattern
			 */
			if (rep_add(optarg) < 0) {
				tar_usage();
				break;
			}
			break;
		case 't':
			/*
			 * list contents of the tape
			 */
			act = LIST;
			break;
		case 'v':
			/*
			 * verbose operation mode
			 */
			vflag++;
			break;
		case 'w':
			/*
			 * interactive file rename
			 */
			iflag = 1;
			break;
		case 'x':
			/*
			 * extract an archive, preserving mode,
			 * and mtime if possible.
			 */
			act = EXTRACT;
			pmtime = 1;
			break;
		case 'z':
			/*
			 * use gzip.  Non standard option.
			 */
			gzip_program = GZIP_CMD;
			break;
		case 'B':
			/*
			 * Nothing to do here, this is pax default
			 */
			break;
		case 'C':
			havechd++;
			chdname = optarg;
			break;
		case 'H':
			/*
			 * follow command line symlinks only
			 */
			Hflag = 1;
			break;
		case 'I':
			if (++nincfiles > incfiles_max) {
				size_t n = nincfiles + 3;
				struct incfile *p;

				p = reallocarray(incfiles, n,
				    sizeof(*incfiles));
				if (p == NULL) {
					paxwarn(0, "Unable to allocate space "
					    "for option list");
					exit(1);
				}
				incfiles = p;
				incfiles_max = n;
			}
			incfiles[nincfiles - 1].file = optarg;
			incfiles[nincfiles - 1].dir = chdname;
			break;
		case 'L':
			/*
			 * follow symlinks
			 */
			Lflag = 1;
			break;
		case 'N':
			/* numeric uid and gid only */
			Nflag = 1;
			break;
		case 'P':
			/*
			 * do not remove leading '/' from pathnames
			 */
			rmleadslash = 0;
			break;
		case 'X':
			/*
			 * do not pass over mount points in the file system
			 */
			Xflag = 1;
			break;
		case 'Z':
			/*
			 * use compress.
			 */
			gzip_program = COMPRESS_CMD;
			break;
		case '0':
			arcname = DEV_0;
			break;
		case '1':
			arcname = DEV_1;
			break;
		case '4':
			arcname = DEV_4;
			break;
		case '5':
			arcname = DEV_5;
			break;
		case '7':
			arcname = DEV_7;
			break;
		case '8':
			arcname = DEV_8;
			break;
		default:
			tar_usage();
			break;
		}
	}
	argc -= optind;
	argv += optind;

	if ((arcname == NULL) || (*arcname == '\0')) {
		arcname = getenv("TAPE");
		if ((arcname == NULL) || (*arcname == '\0'))
			arcname = _PATH_DEFTAPE;
	}
	if ((arcname[0] == '-') && (arcname[1]== '\0'))
		arcname = NULL;

	/*
	 * Traditional tar behaviour: list-like output goes to stdout unless
	 * writing the archive there.  (pax uses stderr unless in list mode)
	 */
        if (act == LIST || act == EXTRACT || arcname != NULL)
		listf = stdout;

	/* Traditional tar behaviour (pax wants to read file list from stdin) */
	if ((act == ARCHIVE || act == APPND) && argc == 0 && nincfiles == 0)
		exit(0);

	/*
	 * process the args as they are interpreted by the operation mode
	 */
	switch (act) {
	case LIST:
	case EXTRACT:
	default:
		{
			int sawpat = 0;
			char *file, *dir;

			while (nincfiles || *argv != NULL) {
				/*
				 * If we queued up any include files,
				 * pull them in now.  Otherwise, check
				 * for -I and -C positional flags.
				 * Anything else must be a file to
				 * extract.
				 */
				if (nincfiles) {
					file = incfiles->file;
					dir = incfiles->dir;
					incfiles++;
					nincfiles--;
				} else if (strcmp(*argv, "-I") == 0) {
					if (*++argv == NULL)
						break;
					file = *argv++;
					dir = chdname;
				} else
					file = NULL;
				if (file != NULL) {
					FILE *fp;
					char *str;

					if (strcmp(file, "-") == 0)
						fp = stdin;
					else if ((fp = fopen(file, "r")) == NULL) {
						syswarn(1, errno,
						    "Unable to open %s", file);
						tar_usage();
					}
					while ((str = get_line(fp)) != NULL) {
						if (pat_add(str, dir) < 0)
							tar_usage();
						sawpat = 1;
					}
					if (ferror(fp)) {
						syswarn(1, errno,
						    "Unable to read from %s",
						    strcmp(file, "-") ? file :
						    "stdin");
						tar_usage();
					}
					if (strcmp(file, "-") != 0)
						fclose(fp);
				} else if (strcmp(*argv, "-C") == 0) {
					if (*++argv == NULL)
						break;
					chdname = *argv++;
					havechd++;
				} else if (pat_add(*argv++, chdname) < 0)
					tar_usage();
				else
					sawpat = 1;
			}
			/*
			 * if patterns were added, we are doing	chdir()
			 * on a file-by-file basis, else, just one
			 * global chdir (if any) after opening input.
			 */
			if (sawpat > 0)
				chdname = NULL;
		}
		break;
	case ARCHIVE:
	case APPND:
		frmt = &(fsub[Oflag ? F_OTAR : F_TAR]);

		if (chdname != NULL) {	/* initial chdir() */
			if (ftree_add(chdname, 1) < 0)
				tar_usage();
		}

		while (nincfiles || *argv != NULL) {
			char *file, *dir;

			/*
			 * If we queued up any include files, pull them in
			 * now.  Otherwise, check for -I and -C positional
			 * flags.  Anything else must be a file to include
			 * in the archive.
			 */
			if (nincfiles) {
				file = incfiles->file;
				dir = incfiles->dir;
				incfiles++;
				nincfiles--;
			} else if (strcmp(*argv, "-I") == 0) {
				if (*++argv == NULL)
					break;
				file = *argv++;
				dir = NULL;
			} else
				file = NULL;
			if (file != NULL) {
				FILE *fp;
				char *str;

				/* Set directory if needed */
				if (dir) {
					if (ftree_add(dir, 1) < 0)
						tar_usage();
				}

				if (strcmp(file, "-") == 0)
					fp = stdin;
				else if ((fp = fopen(file, "r")) == NULL) {
					syswarn(1, errno, "Unable to open %s",
					    file);
					tar_usage();
				}
				while ((str = get_line(fp)) != NULL) {
					if (ftree_add(str, 0) < 0)
						tar_usage();
				}
				if (ferror(fp)) {
					syswarn(1, errno,
					    "Unable to read from %s",
					    strcmp(file, "-") ? file : "stdin");
					tar_usage();
				}
				if (strcmp(file, "-") != 0)
					fclose(fp);
			} else if (strcmp(*argv, "-C") == 0) {
				if (*++argv == NULL)
					break;
				if (ftree_add(*argv++, 1) < 0)
					tar_usage();
				havechd++;
			} else if (ftree_add(*argv++, 0) < 0)
				tar_usage();
		}
		/*
		 * no read errors allowed on updates/append operation!
		 */
		maxflt = 0;
		break;
	}
}

int mkpath(char *);

int
mkpath(path)
	char *path;
{
	struct stat sb;
	char *slash;
	int done = 0;

	slash = path;

	while (!done) {
		slash += strspn(slash, "/");
		slash += strcspn(slash, "/");

		done = (*slash == '\0');
		*slash = '\0';

		if (stat(path, &sb)) {
			if (errno != ENOENT || mkdir(path, 0777)) {
				paxwarn(1, "%s", path);
				return (-1);
			}
		} else if (!S_ISDIR(sb.st_mode)) {
			syswarn(1, ENOTDIR, "%s", path);
			return (-1);
		}

		if (!done)
			*slash = '/';
	}

	return (0);
}

#ifndef NOCPIO
/*
 * cpio_options()
 *	look at the user specified flags. set globals as required and check if
 *	the user specified a legal set of flags. If not, complain and exit
 */

static void
cpio_options(int argc, char **argv)
{
	const char *errstr;
	int c, list_only = 0;
	unsigned i;
	char *str;
	FILE *fp;

	kflag = 1;
	pids = 1;
	pmode = 1;
	pmtime = 0;
	arcname = NULL;
	dflag = 1;
	act = -1;
	nodirs = 1;
	while ((c=getopt(argc,argv,"abcdfijklmoprstuvzABC:E:F:H:I:LO:SZ6")) != -1)
		switch (c) {
			case 'a':
				/*
				 * preserve access time on files read
				 */
				tflag = 1;
				break;
			case 'b':
				/*
				 * swap bytes and half-words when reading data
				 */
				break;
			case 'c':
				/*
				 * ASCII cpio header
				 */
				frmt = &(fsub[F_ACPIO]);
				break;
			case 'd':
				/*
				 * create directories as needed
				 */
				nodirs = 0;
				break;
			case 'f':
				/*
				 * invert meaning of pattern list
				 */
				cflag = 1;
				break;
			case 'i':
				/*
				 * restore an archive
				 */
				act = EXTRACT;
				break;
			case 'j':
				/*
				 * use bzip2.  Non standard option.
				 */
				gzip_program = BZIP2_CMD;
				break;
			case 'k':
				break;
			case 'l':
				/*
				 * use links instead of copies when possible
				 */
				lflag = 1;
				break;
			case 'm':
				/*
				 * preserve modification time
				 */
				pmtime = 1;
				break;
			case 'o':
				/*
				 * create an archive
				 */
				act = ARCHIVE;
				frmt = &(fsub[F_CPIO]);
				break;
			case 'p':
				/*
				 * copy-pass mode
				 */
				act = COPY;
				break;
			case 'r':
				/*
				 * interactively rename files
				 */
				iflag = 1;
				break;
			case 's':
				/*
				 * swap bytes after reading data
				 */
				break;
			case 't':
				/*
				 * list contents of archive
				 */
				list_only = 1;
				break;
			case 'u':
				/*
				 * replace newer files
				 */
				kflag = 0;
				break;
			case 'v':
				/*
				 * verbose operation mode
				 */
				vflag = 1;
				break;
			case 'z':
				/*
				 * use gzip.  Non standard option.
				 */
				gzip_program = GZIP_CMD;
				break;
			case 'A':
				/*
				 * append mode
				 */
				act = APPND;
				break;
			case 'B':
				/*
				 * Use 5120 byte block size
				 */
				wrblksz = 5120;
				break;
			case 'C':
				/*
				 * set block size in bytes
				 */
				wrblksz = strtonum(optarg, 0, INT_MAX, &errstr);
				if (errstr) {
					paxwarn(1, "Invalid block size %s: %s",
					    optarg, errstr);
					pax_usage();
				}
				break;
			case 'E':
				/*
				 * file with patterns to extract or list
				 */
				if ((fp = fopen(optarg, "r")) == NULL) {
					syswarn(1, errno, "Unable to open %s",
					    optarg);
					cpio_usage();
				}
				while ((str = get_line(fp)) != NULL) {
					pat_add(str, NULL);
				}
				if (ferror(fp)) {
					syswarn(1, errno,
					    "Unable to read from %s", optarg);
					cpio_usage();
				}
				fclose(fp);
				break;
			case 'F':
			case 'I':
			case 'O':
				/*
				 * filename where the archive is stored
				 */
				if ((optarg[0] == '-') && (optarg[1]== '\0')) {
					/*
					 * treat a - as stdin
					 */
					arcname = NULL;
					break;
				}
				arcname = optarg;
				break;
			case 'H':
				/*
				 * specify an archive format on write
				 */
				for (i = 0; i < sizeof(fsub)/sizeof(FSUB); ++i)
					if (fsub[i].name != NULL &&
					    strcmp(fsub[i].name, optarg) == 0)
						break;
				if (i < sizeof(fsub)/sizeof(FSUB)) {
					frmt = &fsub[i];
					break;
				}
				paxwarn(1, "Unknown -H format: %s", optarg);
				(void)fputs("cpio: Known -H formats are:", stderr);
				for (i = 0; i < (sizeof(fsub)/sizeof(FSUB)); ++i)
					if (fsub[i].name != NULL)
						(void)fprintf(stderr, " %s",
						    fsub[i].name);
				(void)fputs("\n\n", stderr);
				cpio_usage();
				break;
			case 'L':
				/*
				 * follow symbolic links
				 */
				Lflag = 1;
				break;
			case 'S':
				/*
				 * swap halfwords after reading data
				 */
				break;
			case 'Z':
				/*
				 * use compress.  Non standard option.
				 */
				gzip_program = COMPRESS_CMD;
				break;
			case '6':
				/*
				 * process Version 6 cpio format
				 */
				frmt = &(fsub[F_OCPIO]);
				break;
			case '?':
			default:
				cpio_usage();
				break;
		}
	argc -= optind;
	argv += optind;

	/*
	 * process the args as they are interpreted by the operation mode
	 */
	switch (act) {
		case EXTRACT:
			if (list_only) {
				act = LIST;

				/*
				 * cpio is like pax: list to stderr
				 * unless in list mode
				 */
				listf = stdout;
			}
			while (*argv != NULL)
				if (pat_add(*argv++, NULL) < 0)
					cpio_usage();
			break;
		case COPY:
			if (*argv == NULL) {
				paxwarn(0, "Destination directory was not supplied");
				cpio_usage();
			}
			dirptr = *argv;
			if (mkpath(dirptr) < 0)
				cpio_usage();
			--argc;
			++argv;
			/* FALL THROUGH */
		case ARCHIVE:
		case APPND:
			if (*argv != NULL)
				cpio_usage();
			/*
			 * no read errors allowed on updates/append operation!
			 */
			maxflt = 0;
			while ((str = get_line(stdin)) != NULL) {
				ftree_add(str, 0);
			}
			if (ferror(stdin)) {
				syswarn(1, errno, "Unable to read from %s",
				    "stdin");
				cpio_usage();
			}
			break;
		default:
			cpio_usage();
			break;
	}
}
#endif /* !NOCPIO */

/*
 * printflg()
 *	print out those invalid flag sets found to the user
 */

static void
printflg(unsigned int flg)
{
	int nxt;
	int pos = 0;

	(void)fprintf(stderr,"%s: Invalid combination of options:", argv0);
	while ((nxt = ffs(flg)) != 0) {
		flg >>= nxt;
		pos += nxt;
		(void)fprintf(stderr, " -%c", flgch[pos-1]);
	}
	(void)putc('\n', stderr);
}

/*
 * opt_next()
 *	called by format specific options routines to get each format specific
 *	flag and value specified with -o
 * Return:
 *	pointer to next OPLIST entry or NULL (end of list).
 */

OPLIST *
opt_next(void)
{
	OPLIST *opt;

	if ((opt = ophead) != NULL)
		ophead = ophead->fow;
	return(opt);
}

/*
 * bad_opt()
 *	generic routine used to complain about a format specific options
 *	when the format does not support options.
 */

int
bad_opt(void)
{
	OPLIST *opt;

	if (ophead == NULL)
		return(0);
	/*
	 * print all we were given
	 */
	paxwarn(1,"These format options are not supported");
	while ((opt = opt_next()) != NULL)
		(void)fprintf(stderr, "\t%s = %s\n", opt->name, opt->value);
	pax_usage();
	return(0);
}

/*
 * opt_add()
 *	breaks the value supplied to -o into a option name and value. options
 *	are given to -o in the form -o name-value,name=value
 *	multiple -o may be specified.
 * Return:
 *	0 if format in name=value format, -1 if -o is passed junk
 */

int
opt_add(const char *str)
{
	OPLIST *opt;
	char *frpt;
	char *pt;
	char *endpt;
	char *dstr;

	if ((str == NULL) || (*str == '\0')) {
		paxwarn(0, "Invalid option name");
		return(-1);
	}
	if ((dstr = strdup(str)) == NULL) {
		paxwarn(0, "Unable to allocate space for option list");
		return(-1);
	}
	frpt = endpt = dstr;

	/*
	 * break into name and values pieces and stuff each one into a
	 * OPLIST structure. When we know the format, the format specific
	 * option function will go through this list
	 */
	while ((frpt != NULL) && (*frpt != '\0')) {
		if ((endpt = strchr(frpt, ',')) != NULL)
			*endpt = '\0';
		if ((pt = strchr(frpt, '=')) == NULL) {
			paxwarn(0, "Invalid options format");
			free(dstr);
			return(-1);
		}
		if ((opt = malloc(sizeof(OPLIST))) == NULL) {
			paxwarn(0, "Unable to allocate space for option list");
			free(dstr);
			return(-1);
		}
		dstr = NULL;	/* parts of string going onto the OPLIST */
		*pt++ = '\0';
		opt->name = frpt;
		opt->value = pt;
		opt->fow = NULL;
		if (endpt != NULL)
			frpt = endpt + 1;
		else
			frpt = NULL;
		if (ophead == NULL) {
			optail = ophead = opt;
			continue;
		}
		optail->fow = opt;
		optail = opt;
	}
	free(dstr);
	return(0);
}

/*
 * str_offt()
 *	Convert an expression of the following forms to an off_t > 0.
 *	1) A positive decimal number.
 *	2) A positive decimal number followed by a b (mult by 512).
 *	3) A positive decimal number followed by a k (mult by 1024).
 *	4) A positive decimal number followed by a m (mult by 512).
 *	5) A positive decimal number followed by a w (mult by sizeof int)
 *	6) Two or more positive decimal numbers (with/without k,b or w).
 *	   separated by x (also * for backwards compatibility), specifying
 *	   the product of the indicated values.
 * Return:
 *	0 for an error, a positive value o.w.
 */

static off_t
str_offt(char *val)
{
	char *expr;
	off_t num, t;

	num = strtoll(val, &expr, 0);
	if ((num == LLONG_MAX) || (num <= 0) || (expr == val))
		return(0);

	switch (*expr) {
	case 'b':
		t = num;
		num *= 512;
		if (t > num)
			return(0);
		++expr;
		break;
	case 'k':
		t = num;
		num *= 1024;
		if (t > num)
			return(0);
		++expr;
		break;
	case 'm':
		t = num;
		num *= 1048576;
		if (t > num)
			return(0);
		++expr;
		break;
	case 'w':
		t = num;
		num *= sizeof(int);
		if (t > num)
			return(0);
		++expr;
		break;
	}

	switch (*expr) {
		case '\0':
			break;
		case '*':
		case 'x':
			t = num;
			num *= str_offt(expr + 1);
			if (t > num)
				return(0);
			break;
		default:
			return(0);
	}
	return(num);
}

char *
get_line(FILE *f)
{
	char *str = NULL;
	size_t size = 0;
	ssize_t len;

	do {
		len = getline(&str, &size, f);
		if (len == -1) {
			free(str);
			return NULL;
		}
		if (str[len - 1] == '\n')
			str[len - 1] = '\0';
	} while (str[0] == '\0');
	return str;
}

/*
 * no_op()
 *	for those option functions where the archive format has nothing to do.
 * Return:
 *	0
 */

static int
no_op(void)
{
	return(0);
}

/*
 * pax_usage()
 *	print the usage summary to the user
 */

void
pax_usage(void)
{
	(void)fputs(
	    "usage: pax [-0cdjnOvz] [-E limit] [-f archive] [-G group] [-s replstr]\n"
	    "           [-T range] [-U user] [pattern ...]\n"
	    "       pax -r [-0cDdijknOuvYZz] [-E limit] [-f archive] [-G group] [-o options]\n"
	    "           [-p string] [-s replstr] [-T range] [-U user] [pattern ...]\n"
	    "       pax -w [-0adHijLOPtuvXz] [-B bytes] [-b blocksize] [-f archive]\n"
	    "           [-G group] [-o options] [-s replstr] [-T range] [-U user]\n"
	    "           [-x format] [file ...]\n"
	    "       pax -rw [-0DdHikLlnOPtuvXYZ] [-G group] [-p string] [-s replstr]\n"
	    "           [-T range] [-U user] [file ...] directory\n",
	    stderr);
	exit(1);
}

/*
 * tar_usage()
 *	print the usage summary to the user
 */

void
tar_usage(void)
{
	(void)fputs(
	    "usage: tar {crtux}[014578befHhjLmNOoPpqsvwXZz]\n"
	    "           [blocking-factor | archive | replstr] [-C directory] [-I file]\n"
	    "           [file ...]\n"
	    "       tar {-crtux} [-014578eHhjLmNOoPpqvwXZz] [-b blocking-factor]\n"
	    "           [-C directory] [-f archive] [-I file] [-s replstr] [file ...]\n",
	    stderr);
	exit(1);
}

#ifndef NOCPIO
/*
 * cpio_usage()
 *	print the usage summary to the user
 */

void
cpio_usage(void)
{
	(void)fputs(
	    "usage: cpio -o [-AaBcjLvZz] [-C bytes] [-F archive] [-H format]\n"
	    "            [-O archive] < name-list [> archive]\n"
	    "       cpio -i [-6BbcdfjmrSstuvZz] [-C bytes] [-E file] [-F archive] [-H format]\n"
	    "            [-I archive] [pattern ...] [< archive]\n"
	    "       cpio -p [-adLlmuv] destination-directory < name-list\n",
	    stderr);
	exit(1);
}
#endif /* !NOCPIO */

#ifndef SMALL
static int
compress_id(char *blk, int size)
{
	if (size >= 2 && blk[0] == '\037' && blk[1] == '\235') {
		paxwarn(0, "input compressed with %s; use the -%c option"
		    " to decompress it", "compress", 'Z');
		exit(1);
	}
	return (-1);
}

static int
gzip_id(char *blk, int size)
{
	if (size >= 2 && blk[0] == '\037' && blk[1] == '\213') {
		paxwarn(0, "input compressed with %s; use the -%c option"
		    " to decompress it", "gzip", 'z');
		exit(1);
	}
	return (-1);
}

static int
bzip2_id(char *blk, int size)
{
	if (size >= 3 && blk[0] == 'B' && blk[1] == 'Z' && blk[2] == 'h') {
		paxwarn(0, "input compressed with %s; use the -%c option"
		    " to decompress it", "bzip2", 'j');
		exit(1);
	}
	return (-1);
}

static int
xz_id(char *blk, int size)
{
	if (size >= 6 && memcmp(blk, "\xFD\x37\x7A\x58\x5A", 6) == 0) {
		paxwarn(0, "input compressed with xz");
		exit(1);
	}
	return (-1);
}
#endif /* !SMALL */
@


1.100
log
@-E NONE has *never* worked; it was always -E none.  It's a dubious option
value that merits a warning in the manpage and using 2 billion will get
you practically the same effect, so delete the -E none support
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.99 2016/08/26 04:33:11 guenther Exp $	*/
d144 1
d147 1
@


1.99
log
@options.h is only used by options.c; merge it into the .c file
reduce and sort #includes
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.98 2016/08/25 01:44:55 guenther Exp $	*/
d530 1
a530 1
			 * indicate a limit, "NONE" try forever
d533 4
a536 8
			if (strcmp("none", optarg) == 0)
				maxflt = -1;
			else {
				maxflt = strtonum(optarg, 0, INT_MAX, &errstr);
				if (errstr) {
					paxwarn(1, "Error count value: %s", errstr);
					pax_usage();
				}
@


1.98
log
@Replace name_{uid,gid}() with the libc routines user_from_uid() and
group_from_gid().  Eliminate some superfluous strncpy() calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.97 2016/08/24 19:15:42 guenther Exp $	*/
a37 1
#include <sys/time.h>
d39 3
a41 1
#include <sys/mtio.h>
d43 1
a44 1
#include <errno.h>
d46 1
a46 3
#include <stdlib.h>
#include <limits.h>
#include <paths.h>
a47 1
#include "options.h"
d53 76
d533 1
a533 1
			if (strcmp(NONE, optarg) == 0)
@


1.97
log
@Make list-like output go to stderr when appending to an archive on stdout.
Simplify the recognition of -f- and TAPE=- as meaning stdin/stdout.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.96 2016/08/24 19:13:52 guenther Exp $	*/
d129 1
a129 1
	ustar_rd, tar_endrd, ustar_stwr, ustar_wr, tar_endwr, tar_trail,
@


1.96
log
@Treat cpio's -t option as a modifier to -i, so they're ordering independent

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.95 2016/08/23 06:00:28 guenther Exp $	*/
a643 1
	int fstdin = 0;
a689 9
			if ((optarg[0] == '-') && (optarg[1]== '\0')) {
				/*
				 * treat a - as stdin
				 */
				fstdin = 1;
				arcname = NULL;
				break;
			}
			fstdin = 0;
d865 1
a865 1
	if (!fstdin && ((arcname == NULL) || (*arcname == '\0'))) {
a868 4
		else if ((arcname[0] == '-') && (arcname[1]== '\0')) {
			arcname = NULL;
			fstdin = 1;
		}
d870 2
d873 5
a877 4
	/* Traditional tar behaviour (pax uses stderr unless in list mode) */
	if (fstdin == 1 && act == ARCHIVE)
		listf = stderr;
	else
@


1.95
log
@Instead of doing strcmp(argv0), track the invocation mode (pax/tar/cpio)
in a separate variable

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.94 2016/08/14 04:47:52 guenther Exp $	*/
d1093 1
a1093 1
	int c;
d1191 1
a1191 2
				act = LIST;
				listf = stdout;
a1323 1
		case LIST:
d1325 9
@


1.94
log
@Replace u_quad_t with unsigned long long and replace "uqd" with "ull" in
function names to match.  Pull some tangled assignments out of conditions
and use >>= where possible.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.93 2016/04/19 03:26:11 guenther Exp $	*/
d189 1
d195 1
d204 1
@


1.93
log
@Switch from fgetln() to getline() to simplify error handling.
Use syswarn() in more places which set errno and regularize the error messages.
Skip empty lines in the input read for tar -T, cpio -E, and cpio stdin.

based on diff from mmcc@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.92 2015/12/06 12:00:16 tobias Exp $	*/
d1376 1
a1376 1
		flg = flg >> nxt;
@


1.92
log
@Use __progname instead of manually handling argv[0].

ok deraadt, mmcc, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.91 2015/05/18 20:26:16 czarkoff Exp $	*/
a77 6
/* errors from get_line */
#define GETLINE_FILE_CORRUPT 1
#define GETLINE_OUT_OF_MEM 2
static int getline_error;


d930 2
a931 1
						paxwarn(1, "Unable to open file '%s' for read", file);
d939 7
a947 4
					if (getline_error) {
						paxwarn(1, "Problem with file '%s'", file);
						tar_usage();
					}
d1010 2
a1011 1
					paxwarn(1, "Unable to open file '%s' for read", file);
d1018 6
a1025 5
				if (getline_error) {
					paxwarn(1, "Problem with file '%s'",
					    file);
					tar_usage();
				}
d1237 2
a1238 1
					paxwarn(1, "Unable to open file '%s' for read", optarg);
d1244 3
a1246 3
				fclose(fp);
				if (getline_error) {
					paxwarn(1, "Problem with file '%s'", optarg);
d1249 1
d1350 3
a1352 2
			if (getline_error) {
				paxwarn(1, "Problem while reading stdin");
d1565 14
a1578 18
	char *name, *temp;
	size_t len;

	name = fgetln(f, &len);
	if (!name) {
		getline_error = ferror(f) ? GETLINE_FILE_CORRUPT : 0;
		return(0);
	}
	if (name[len-1] != '\n')
		len++;
	temp = malloc(len);
	if (!temp) {
		getline_error = GETLINE_OUT_OF_MEM;
		return(0);
	}
	memcpy(temp, name, len-1);
	temp[len-1] = 0;
	return(temp);
@


1.91
log
@Make TAPE=- mean stdout in tar

Some scripts and GUI ssh clients assume that tar writes to standard output by
default.  This changes allows enforcing such behavior by setting TAPE="-" in
user profile.

Also, this makes parsing argument to "-f" option and contents of TAPE
environment variable consistent.

OK guenther@@, jmc@@ and sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.90 2015/04/18 18:28:37 deraadt Exp $	*/
d187 1
d192 1
a192 4
	if ((argv0 = strrchr(argv[0], '/')) != NULL)
		argv0++;
	else
		argv0 = argv[0];
@


1.90
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.89 2015/03/15 21:53:09 guenther Exp $	*/
d880 10
a1041 5
	}
	if (!fstdin && ((arcname == NULL) || (*arcname == '\0'))) {
		arcname = getenv("TAPE");
		if ((arcname == NULL) || (*arcname == '\0'))
			arcname = _PATH_DEFTAPE;
@


1.89
log
@Define chdname once in a .c and make it extern in the .h
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.88 2015/03/15 19:47:27 guenther Exp $	*/
d226 1
d466 6
a471 3
			else if ((maxflt = atoi(optarg)) < 0) {
				paxwarn(1, "Error count value must be positive");
				pax_usage();
d1086 1
d1222 6
a1227 1
				wrblksz = atoi(optarg);
@


1.88
log
@Handle tar -o by setting the tar_nodir directly instead of faking up a
pax-like -o write_opt=nodir.

ok millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.87 2015/03/12 04:15:03 guenther Exp $	*/
d173 1
a173 1
 * Do we have -C anywhere?
d176 1
@


1.87
log
@If an archive isn't a recognized type, then check whether it looks
like compress, gzip, bzip2, or xz output.  If so then error out with
a useful message directing the user to the correct option and error
out instead of scanning forward for an embedded tar/cpio header.

wording help from sobrado@@
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.86 2014/05/24 18:51:00 guenther Exp $	*/
d725 1
a958 3

		if (Oflag == 2 && opt_add("write_opt=nodir") < 0)
			tar_usage();
@


1.86
log
@Delete pointless casts: free() return value to (void), free()'s
argument to (char *), and malloc/calloc's return value to the type
of the variable it's being assigned to.
Convert the one calloc() where the zeroing isn't needed to a reallocarray().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.85 2014/05/07 14:56:57 tedu Exp $	*/
d73 5
d137 20
d170 1
a170 1
int ford[] = {5, 4, 3, 2, 1, 0, -1 };
d1642 45
@


1.85
log
@use reallocarray. ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.84 2014/02/06 20:51:55 guenther Exp $	*/
d1425 1
a1425 1
		if ((opt = (OPLIST *)malloc(sizeof(OPLIST))) == NULL) {
@


1.84
log
@Oops, pax -x and cpio -H need to set frmt
Add 'break' accidentally removed by previous commit and future-proof
format listing by cpio -H

problem noted by naddy@@
ok halex@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.83 2014/02/05 20:35:42 halex Exp $	*/
d782 2
a783 2
				p = realloc(incfiles,
				    sizeof(*incfiles) * n);
a784 2
					free(incfiles);
					incfiles = NULL;
@


1.83
log
@make pax cope with a stripped down format list, e.g. when compiled
with -DNOCPIO
- ignore empty entries (millert@@, halex@@)
- replace bsort with linear scan (guenther@@)

ok millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.82 2014/01/30 13:30:11 espie Exp $	*/
d387 1
d1236 3
a1238 1
				if (i < sizeof(fsub)/sizeof(FSUB))
d1240 1
d1244 3
a1246 1
					(void)fprintf(stderr, " %s", fsub[i].name);
@


1.82
log
@abstraction for the sake of abstraction is distracting.

zap extra func pointer going to the same routines for all formats.
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.81 2014/01/11 05:36:26 deraadt Exp $	*/
a63 1
static int c_frmt(const void *, const void *);
d84 1
a84 1
 *	Format specific routine table - MUST BE IN SORTED ORDER BY NAME
d197 1
a197 1
	int i;
a200 1
	FSUB tmp;
d382 5
a386 3
			tmp.name = optarg;
			if ((frmt = (FSUB *)bsearch((void *)&tmp, (void *)fsub,
			    sizeof(fsub)/sizeof(FSUB), sizeof(FSUB), c_frmt)) != NULL) {
d393 3
a395 1
				(void)fprintf(stderr, " %s", fsub[i].name);
d1059 2
a1060 1
	int c, i;
a1061 1
	FSUB tmp;
d1232 4
a1235 3
				tmp.name = optarg;
				if ((frmt = (FSUB *)bsearch((void *)&tmp, (void *)fsub,
				    sizeof(fsub)/sizeof(FSUB), sizeof(FSUB), c_frmt)) != NULL)
a1336 12
}

/*
 * c_frmt()
 *	comparison routine used by bsearch to find the format specified
 *	by the user
 */

static int
c_frmt(const void *a, const void *b)
{
	return(strcmp(((FSUB *)a)->name, ((FSUB *)b)->name));
@


1.81
log
@Add -DNOCPIO option for use by distrib/special
ok guenther tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.80 2014/01/08 06:43:34 deraadt Exp $	*/
d107 1
a107 1
	rd_wrfile, wr_rdfile, bad_opt},
d112 1
a112 1
	rd_wrfile, wr_rdfile, bad_opt},
d117 1
a117 1
	rd_wrfile, wr_rdfile, bad_opt},
d122 1
a122 1
	rd_wrfile, wr_rdfile, bad_opt},
d127 1
a127 1
	rd_wrfile, wr_rdfile, tar_opt},
d132 1
a132 1
	rd_wrfile, wr_rdfile, tar_opt},
@


1.80
log
@Zap leading whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.79 2014/01/08 05:52:47 guenther Exp $	*/
d94 10
d123 1
a123 1

d174 3
a176 1
	} else if (strcmp(NM_CPIO, argv0) == 0) {
d180 1
d1046 2
d1314 1
d1603 1
d1621 1
@


1.79
log
@Replace strtoq(), QUAD_MAX, and %qu with their long long equivalent
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.78 2014/01/08 04:58:36 guenther Exp $	*/
d88 1
a88 1
 * 	name, blksz, hdsz, udev, hlk, blkagn, inhead, id, st_read,
d1442 1
a1442 1
 * 	1) A positive decimal number.
@


1.78
log
@Eliminate poisonous LONG_OFF_T conditional

adjective suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.77 2013/03/27 17:14:10 zhuk Exp $	*/
d1460 2
a1461 2
	num = strtoq(val, &expr, 0);
	if ((num == QUAD_MAX) || (num <= 0) || (expr == val))
d1533 1
a1533 1
			
@


1.77
log
@Enable support for write_opt=nodir for ustar archives which helps to fix
issues with some crappy tar archive readers out there that rely on the
fact that directory entries ends up with "/" when created by GNU Tar, and
now I'm finishing this commit message by mentioning people who gave input
and okays: deraadt@@ millert@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.76 2012/12/04 02:24:45 deraadt Exp $	*/
a1459 4
#	ifdef LONG_OFF_T
	num = strtol(val, &expr, 0);
	if ((num == LONG_MAX) || (num <= 0) || (expr == val))
#	else
a1461 1
#	endif
@


1.76
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.75 2012/03/04 04:05:15 fgsch Exp $	*/
d122 1
a122 1
	rd_wrfile, wr_rdfile, bad_opt},
@


1.75
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.74 2010/12/02 04:08:27 tedu Exp $	*/
a40 1
#include <sys/param.h>
@


1.74
log
@a -N option for tar that uses numeric only IDs, useful for cross system
tar file manipulation.  with advice from guenther and jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.73 2009/11/13 17:22:13 deraadt Exp $	*/
d67 1
a67 1
static char *getline(FILE *fp);
d75 1
a75 1
/* errors from getline */
d887 1
a887 1
					while ((str = getline(fp)) != NULL) {
d966 1
a966 1
				while ((str = getline(fp)) != NULL) {
d1188 1
a1188 1
				while ((str = getline(fp)) != NULL) {
d1287 1
a1287 1
			while ((str = getline(stdin)) != NULL) {
d1518 1
a1518 1
getline(FILE *f)
@


1.73
log
@stop the options string leak if it is not attached into the options
linked list, found by parfait, ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.72 2009/11/12 20:10:48 deraadt Exp $	*/
d623 1
a623 1
	    "b:cef:hjmopqruts:vwxzBC:HI:LOPXZ014578")) != -1) {
d788 4
d1584 1
a1584 1
	    "usage: tar {crtux}[014578befHhjLmOoPpqsvwXZz]\n"
d1587 1
a1587 1
	    "       tar {-crtux} [-014578eHhjLmOoPpqvwXZz] [-b blocking-factor]\n"
@


1.72
log
@Do realloc() the paranoid way, at the very least to once again educate
people about the potential for memory leaks when realloc is use sloppily
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.71 2009/10/27 23:59:22 deraadt Exp $	*/
d1416 1
d1432 1
@


1.71
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.70 2008/06/11 00:49:08 pvalchev Exp $	*/
d764 8
a771 4
				incfiles_max = nincfiles + 3;
				incfiles = realloc(incfiles,
				    sizeof(*incfiles) * incfiles_max);
				if (incfiles == NULL) {
d776 2
@


1.70
log
@Add tar -j option that calls bzip2 for compress/decompress. Requires
you to install the bzip2 pkg (or add bzip2 in another way).

ok millert@@ otto@@ deraadt@@ and 'many others'@@
man page tweak from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.69 2008/05/28 20:04:59 sobrado Exp $	*/
a35 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)options.c	8.2 (Berkeley) 4/18/94";
#else
static const char rcsid[] = "$OpenBSD: options.c,v 1.69 2008/05/28 20:04:59 sobrado Exp $";
#endif
#endif /* not lint */
@


1.69
log
@write cpio_usage() in a way consistent with pax_usage() and tar_usage();
wrap options around to fill out the 80 columns; spacing.

tweaked by jsing@@, thank you very much!

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.68 2008/05/17 23:31:52 sobrado Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.68 2008/05/17 23:31:52 sobrado Exp $";
d91 1
d203 1
a203 1
	while ((c=getopt(argc,argv,"ab:cdf:iklno:p:rs:tuvwx:zB:DE:G:HLOPT:U:XYZ0"))
d250 6
d631 1
a631 1
	    "b:cef:hmopqruts:vwxzBC:HI:LOPXZ014578")) != -1) {
d676 6
d1054 1
a1054 1
	while ((c=getopt(argc,argv,"abcdfiklmoprstuvzABC:E:F:H:I:LO:SZ6")) != -1)
d1091 6
d1558 1
a1558 1
	    "usage: pax [-0cdnOvz] [-E limit] [-f archive] [-G group] [-s replstr]\n"
d1560 1
a1560 1
	    "       pax -r [-0cDdiknOuvYZz] [-E limit] [-f archive] [-G group] [-o options]\n"
d1562 1
a1562 1
	    "       pax -w [-0adHiLOPtuvXz] [-B bytes] [-b blocksize] [-f archive]\n"
d1580 1
a1580 1
	    "usage: tar {crtux}[014578befHhLmOoPpqsvwXZz]\n"
d1583 1
a1583 1
	    "       tar {-crtux} [-014578eHhLmOoPpqvwXZz] [-b blocking-factor]\n"
d1598 1
a1598 1
	    "usage: cpio -o [-AaBcLvZz] [-C bytes] [-F archive] [-H format]\n"
d1600 1
a1600 1
	    "       cpio -i [-6BbcdfmrSstuvZz] [-C bytes] [-E file] [-F archive] [-H format]\n"
@


1.68
log
@documentation tweaks.

ok (some time ago) jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.67 2007/02/24 09:50:55 jmc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.67 2007/02/24 09:50:55 jmc Exp $";
d1541 2
a1542 3
	    "       pax -r [-0cDdiknOuvYZz] [-E limit] [-f archive] [-G group]\n"
	    "           [-o options] [-p string] [-s replstr] [-T range]\n"
	    "           [-U user] [pattern ...]\n"
d1544 2
a1545 2
	    "           [-G group] [-o options] [-s replstr]\n"
	    "           [-T range] [-U user] [-x format] [file ...]\n"
d1578 7
a1584 5
	(void)fputs("usage: cpio -o [-AaBcLvZz] [-C bytes] [-F archive] [-H format]\n", stderr);
	(void)fputs("               [-O archive] < name-list [> archive]\n", stderr);
	(void)fputs("       cpio -i [-6BbcdfmrSstuvZz] [-C bytes] [-E file] [-F archive]\n", stderr);
	(void)fputs("               [-H format] [-I archive] [pattern...] [< archive]\n", stderr);
	(void)fputs("       cpio -p [-adLlmuv] destination-directory < name-list\n", stderr);
@


1.67
log
@sort options; sync usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.66 2007/02/24 09:29:55 jmc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.66 2007/02/24 09:29:55 jmc Exp $";
d1540 1
a1540 1
	    "\t  [-T range] [-U user] [pattern ...]\n"
d1542 2
a1543 2
	    "\t  [-o options] [-p string] [-s replstr] [-T range]\n"
	    "\t  [-U user] [pattern ...]\n"
d1545 2
a1546 2
	    "\t  [-G group] [-o options] [-s replstr]\n"
	    "\t  [-T range] [-U user] [-x format] [file ...]\n"
d1548 1
a1548 1
	    "\t  [-T range] [-U user] [file ...] directory\n",
d1563 2
a1564 2
	    "\t  [blocking-factor | archive | replstr] [-C directory] [-I file]\n"
	    "\t  [file ...]\n"
d1566 1
a1566 1
	    "\t  [-C directory] [-f archive] [-I file] [-s replstr] [file ...]\n",
@


1.66
log
@sort options; sync usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.65 2006/11/17 08:38:04 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.65 2006/11/17 08:38:04 otto Exp $";
d1539 4
a1542 4
	    "usage: pax [-0cdOnvz] [-E limit] [-f archive] [-G group] [-s replstr]\n"
	    "\t  [-T [from_date][,to_date][/[c][m]]] [-U user] [pattern ...]\n"
	    "       pax -r [-0cDdikOnuvzYZz] [-E limit] [-f archive] [-G group]\n"
	    "\t  [-o options] [-p string] [-s replstr] [-T [from_date][,to_date]]\n"
d1546 3
a1548 3
	    "\t  [-T [from_date][,to_date][/[c][m]]] [-U user] [-x format] [file ...]\n"
	    "       pax -r -w [-0DdHikLlnOPtuvXYZ] [-G group] [-p string] [-s replstr]\n"
	    "\t  [-T [from_date][,to_date][/[c][m]]] [-U user] [file ...] directory\n",
@


1.65
log
@Fix extracting and setting permissions for tar archives when
(multiple) -C options are present and/or (multiple) file selections
args are used. Based on a diff in NetBSD PR 22995. Tested by ckuethe@@
and jaredy@@; ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.64 2006/04/09 03:35:34 jaredy Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.64 2006/04/09 03:35:34 jaredy Exp $";
d1579 5
a1583 5
	(void)fputs("usage: cpio -o [-aABcLvVzZ] [-C bytes] [-H format] [-O archive]\n", stderr);
	(void)fputs("               [-F archive] < name-list [> archive]\n", stderr);
	(void)fputs("       cpio -i [-bBcdfmnrsStuvVzZ6] [-C bytes] [-E file] [-H format]\n", stderr);
	(void)fputs("               [-I archive] [-F archive] [pattern...] [< archive]\n", stderr);
	(void)fputs("       cpio -p [-adlLmuvV] destination-directory < name-list\n", stderr);
@


1.64
log
@ftree_add arg #2 expects int not pointer.

from Han Boetes <han@@mijncomputer.nl> via tech@@

ok moritz
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.63 2005/06/02 19:11:06 jaredy Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.63 2005/06/02 19:11:06 jaredy Exp $";
d147 5
d748 1
d887 1
d967 1
@


1.63
log
@add -O to getopt (ok otto) and sync usage
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.62 2005/05/24 16:33:45 jaredy Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.62 2005/05/24 16:33:45 jaredy Exp $";
d1259 1
a1259 1
				ftree_add(str, NULL);
@


1.62
log
@variety of man page fixes
- add non-legacy synopsis (and sync usage)
- sort options
- refer to synopsis arguments consistently
- rearrange examples
- mdoc tweaks
- mention glob patterns for -t and -x

ok jmc, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.61 2004/04/16 22:50:23 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.61 2004/04/16 22:50:23 deraadt Exp $";
d197 1
a197 1
	while ((c=getopt(argc,argv,"ab:cdf:iklno:p:rs:tuvwx:zB:DE:G:HLPT:U:XYZ0"))
d1530 12
a1541 23
	(void)fputs("usage: pax [-cdnvzO] [-E limit] [-f archive] ", stderr);
	(void)fputs("[-s replstr] ... [-U user] ...", stderr);
	(void)fputs("\n           [-G group] ... ", stderr);
	(void)fputs("[-T [from_date][,to_date]] ... ", stderr);
	(void)fputs("[pattern ...]\n", stderr);
	(void)fputs("       pax -r [-cdiknuvzDOYZ] [-E limit] ", stderr);
	(void)fputs("[-f archive] [-o options] ... \n", stderr);
	(void)fputs("           [-p string] ... [-s replstr] ... ", stderr);
	(void)fputs("[-U user] ... [-G group] ...\n	      ", stderr);
	(void)fputs("[-T [from_date][,to_date]] ... ", stderr);
	(void)fputs(" [pattern ...]\n", stderr);
	(void)fputs("       pax -w [-dituvzHLOPX] [-b blocksize] ", stderr);
	(void)fputs("[ [-a] [-f archive] ] [-x format] \n", stderr);
	(void)fputs("           [-B bytes] [-s replstr] ... ", stderr);
	(void)fputs("[-o options] ... [-U user] ...", stderr);
	(void)fputs("\n           [-G group] ... ", stderr);
	(void)fputs("[-T [from_date][,to_date][/[c][m]]] ... ", stderr);
	(void)fputs("[file ...]\n", stderr);
	(void)fputs("       pax -r -w [-diklntuvDHLOPXYZ] ", stderr);
	(void)fputs("[-p string] ... [-s replstr] ...", stderr);
	(void)fputs("\n           [-U user] ... [-G group] ... ", stderr);
	(void)fputs("[-T [from_date][,to_date][/[c][m]]] ... ", stderr);
	(void)fputs("\n           [file ...] directory\n", stderr);
@


1.61
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.60 2003/11/30 16:58:24 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.60 2003/11/30 16:58:24 millert Exp $";
d1564 6
a1569 3
	(void)fputs("usage: tar [-]{crtux}[-befhmopqsvwzHLOPXZ014578] [blocksize] ",
		 stderr);
	(void)fputs("[archive] [replstr] [-C directory] [-I file] [file ...]\n",
@


1.60
log
@Ignore -o/-O in non-extract mode.  Earlier version OK'd by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.59 2003/06/26 00:10:17 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.59 2003/06/26 00:10:17 deraadt Exp $";
d278 1
a278 1
				switch(*pt) {
d620 1
a620 1
		switch(c) {
d1439 1
a1439 1
	switch(*expr) {
d1470 1
a1470 1
	switch(*expr) {
@


1.59
log
@protos.  this requires changing the api for the *trail() functions a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.58 2003/06/13 17:51:14 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.58 2003/06/13 17:51:14 millert Exp $";
a669 3
		case 'o':
			if (opt_add("write_opt=nodir") < 0)
				tar_usage();
d673 3
a825 11
	 * if we are writing (ARCHIVE) specify tar, otherwise run like pax
	 * (unless -o specified)
	 */
	if (act == ARCHIVE || act == APPND)
		frmt = &(fsub[Oflag ? F_OTAR : F_TAR]);
	else if (Oflag) {
		paxwarn(1, "The -O/-o options are only valid when writing an archive");
		tar_usage();		/* only valid when writing */
	}

	/*
d897 5
@


1.58
log
@Add a -0 flag to make pax use a NUL instead of a newline as the
pathname separator.  Works in list mode as well as read/copy mode.
Based on a patch from David Leonard; closes PR 3310
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.57 2003/06/02 23:32:08 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.57 2003/06/02 23:32:08 millert Exp $";
d981 2
@


1.57
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.56 2003/02/03 09:06:43 jmc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.56 2003/02/03 09:06:43 jmc Exp $";
d197 1
a197 1
	while ((c=getopt(argc,argv,"ab:cdf:iklno:p:rs:tuvwx:zB:DE:G:HLPT:U:XYZ"))
d507 8
@


1.56
log
@typos;
from netbsd(svs+pr@@grep.ru)
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.55 2002/10/18 15:38:11 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.55 2002/10/18 15:38:11 millert Exp $";
@


1.55
log
@Pull in some changes from NetBSD
o When extracting GNU tar archives, honor @@LongLink long links/files
o Add an option to prevent pax from prompting for the next volume
  upon premature end of archive.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.54 2002/10/16 19:20:02 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.54 2002/10/16 19:20:02 millert Exp $";
d145 1
a145 1
 * of archive we are dealing with. This helps to properly id  archive formats
@


1.54
log
@sprinkle const; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.53 2002/10/16 18:40:30 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.53 2002/10/16 18:40:30 millert Exp $";
d454 6
d1530 1
a1530 1
	(void)fputs("usage: pax [-cdnvz] [-E limit] [-f archive] ", stderr);
d1535 1
a1535 1
	(void)fputs("       pax -r [-cdiknuvzDYZ] [-E limit] ", stderr);
d1541 1
a1541 1
	(void)fputs("       pax -w [-dituvzHLPX] [-b blocksize] ", stderr);
d1548 1
a1548 1
	(void)fputs("       pax -r -w [-diklntuvDHLPXYZ] ", stderr);
@


1.53
log
@Fix comment typos; most from NetBSD and FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.52 2002/10/16 17:43:10 millert Exp $	*/
d43 1
a43 1
static char sccsid[] = "@@(#)options.c	8.2 (Berkeley) 4/18/94";
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.52 2002/10/16 17:43:10 millert Exp $";
d1349 1
a1349 1
opt_add(char *str)
d1355 1
d1361 1
a1361 1
	if ((str = strdup(str)) == NULL) {
d1365 1
a1365 1
	frpt = endpt = str;
d1377 1
a1377 1
			free(str);
d1382 1
a1382 1
			free(str);
@


1.52
log
@kill register
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.51 2002/09/06 18:17:30 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.51 2002/09/06 18:17:30 deraadt Exp $";
d313 1
a313 1
					 * preserver file mode bits
d1343 1
a1343 1
 *	mulltiple -o may be specified.
@


1.51
log
@do not return void
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.50 2002/02/19 19:39:35 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.50 2002/02/19 19:39:35 millert Exp $";
d80 1
a80 1
static void pax_options(register int, register char **);
d82 1
a82 1
static void tar_options(register int, register char **);
d84 1
a84 1
static void cpio_options(register int, register char **);
d157 1
a157 1
options(register int argc, register char **argv)
d189 1
a189 1
pax_options(register int argc, register char **argv)
d191 2
a192 2
	register int c;
	register int i;
d195 1
a195 1
	register char *pt;
d587 1
a587 1
tar_options(register int argc, register char **argv)
d589 1
a589 1
	register int c;
d977 1
a977 1
	register char *slash;
d1012 1
a1012 1
cpio_options(register int argc, register char **argv)
d1014 1
a1014 1
	register int c, i;
d1325 1
a1325 1
	register OPLIST *opt;
d1349 1
a1349 1
opt_add(register char *str)
d1351 4
a1354 4
	register OPLIST *opt;
	register char *frpt;
	register char *pt;
	register char *endpt;
@


1.50
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.49 2002/02/16 21:27:07 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.49 2002/02/16 21:27:07 millert Exp $";
d168 7
a174 4
	if (strcmp(NM_TAR, argv0) == 0)
		return(tar_options(argc, argv));
	else if (strcmp(NM_CPIO, argv0) == 0)
		return(cpio_options(argc, argv));
d179 1
a179 1
	return(pax_options(argc, argv));
@


1.49
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.48 2001/05/26 00:32:21 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.48 2001/05/26 00:32:21 millert Exp $";
a155 1
#ifdef __STDC__
a157 6
#else
void
options(argc, argv)
	register int argc;
	register char **argv;
#endif
a184 1
#ifdef __STDC__
a186 6
#else
static void
pax_options(argc, argv)
	register int argc;
	register char **argv;
#endif
a582 1
#ifdef __STDC__
a584 6
#else
static void
tar_options(argc, argv)
	register int argc;
	register char **argv;
#endif
a1007 1
#ifdef __STDC__
a1009 6
#else
static void
cpio_options(argc, argv)
	register int argc;
	register char **argv;
#endif
a1267 1
#ifdef __STDC__
a1269 5
#else
static void
printflg(flg)
	unsigned int flg;
#endif
a1288 1
#ifdef __STDC__
a1290 6
#else
static int
c_frmt(a, b)
	void *a;
	void *b;
#endif
a1302 1
#ifdef __STDC__
a1304 4
#else
OPLIST *
opt_next()
#endif
a1318 1
#ifdef __STDC__
a1320 4
#else
int
bad_opt()
#endif
a1344 1
#ifdef __STDC__
a1346 5
#else
int
opt_add(str)
	register char *str;
#endif
a1413 1
#ifdef __STDC__
a1415 5
#else
static off_t
str_offt(val)
	char *val;
#endif
a1475 1
#ifdef __STDC__
a1477 5
#else
char *
getline(f)
	FILE *f;
#endif
a1505 1
#ifdef __STDC__
a1507 4
#else
static int
no_op()
#endif
a1516 1
#ifdef __STDC__
a1518 4
#else
void
pax_usage()
#endif
a1550 1
#ifdef __STDC__
a1552 4
#else
void
tar_usage()
#endif
a1565 1
#ifdef __STDC__
a1567 4
#else
void
cpio_usage()
#endif
@


1.48
log
@Get rid of NET2_FTS and NET2_REGEX #ifdefs since they are useless.
Change NET2_STAT into LONG_OFF_T for portability to systems with
a 32bit off_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.47 2001/02/10 17:21:14 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.47 2001/02/10 17:21:14 millert Exp $";
d75 11
a85 11
static int no_op __P((void));
static void printflg __P((unsigned int));
static int c_frmt __P((const void *, const void *));
static off_t str_offt __P((char *));
static char *getline __P((FILE *fp));
static void pax_options __P((register int, register char **));
static void pax_usage __P((void));
static void tar_options __P((register int, register char **));
static void tar_usage __P((void));
static void cpio_options __P((register int, register char **));
static void cpio_usage __P((void));
@


1.47
log
@Replace -T flag with more standard -I flag and make it work as a standard
argument (and thus work as in the 'packed' option form) as well as a
positional argument.
Our -T flag was basically equivalent to -I but different from gnutar's -T
so -T gets thrown out.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.46 2001/02/09 14:04:33 espie Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.46 2001/02/09 14:04:33 espie Exp $";
d1483 1
a1483 1
#	ifdef NET2_STAT
@


1.46
log
@Revert broken fix, until a correct fix is written.
Breaking all ports like that is not acceptable.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.44 2001/02/05 00:32:12 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.44 2001/02/05 00:32:12 deraadt Exp $";
d610 7
d627 1
a627 2
	    "b:cef:hmopqruts:vwxzBC:HLOPXZ014578"))
	    != -1) {
d759 14
d829 2
a830 2
	/* Traditional tar behaviour (pax wants to read filelist from stdin) */
	if ((act == ARCHIVE || act == APPND) && argc == 0)
d853 1
d855 15
a869 3
			while (*argv != NULL) {
				if (strcmp(*argv, "-C") == 0) {
					if(*++argv == NULL)
d871 5
a875 5
					chdname = *argv++;

					continue;
				} 
				if (strcmp(*argv, "-T") == 0) {
d879 4
a882 5
					if (*++argv == NULL)
						break;

					if ((fp = fopen(*argv, "r")) == NULL) {
						paxwarn(1, "Unable to open file '%s' for read", *argv);
d886 1
a886 1
						if (pat_add(str, chdname) < 0)
d888 1
a888 1
						sawpat++;
d890 2
a891 1
					fclose(fp);
d893 1
a893 1
						paxwarn(1, "Problem with file '%s'", *argv);
d896 5
a900 5
					argv++;

					continue;
				}
				if (pat_add(*argv++, chdname) < 0)
d902 2
a903 1
				sawpat++;
d907 1
a907 1
			 * on a file-by-file basis, else, just one 
d921 15
a935 2
		while (*argv != NULL) {
			if (strcmp(*argv, "-C") == 0) {
d938 5
a942 6
				if (ftree_add(*argv++, 1) < 0)
					tar_usage();

				continue;
			}
			if (strcmp(*argv, "-T") == 0) {
d946 5
a950 2
				if (*++argv == NULL)
					break;
d952 4
a955 2
				if ((fp = fopen(*argv, "r")) == NULL) {
					paxwarn(1, "Unable to open file '%s' for read", *argv);
d962 2
a963 1
				fclose(fp);
d965 2
a966 1
					paxwarn(1, "Problem with file '%s'", *argv);
d969 6
a974 5
				argv++;

				continue;
			}
			if (ftree_add(*argv++, 0) < 0)
d1638 1
a1638 1
	(void)fputs("usage: tar [-]{txru}[cevfbmopqswzBHLPXZ014578] [tapefile] ",
d1640 1
a1640 1
	(void)fputs("[blocksize] [replstr] [-C directory] [-T file] file1 file2...\n",
@


1.45
log
@Fix -T option and add support for -C option in the file pointed to
by -T ala GNU tar.
Based on a patch from woods@@proven.weird.com; Closes PR #1664
@
text
@a609 1
	char *listfile = NULL;
d620 1
a620 1
	    "b:cef:hmopqruts:vwxzBC:HLOPT:XZ014578"))
a764 3
		case 'T':
			listfile = optarg;
			break;
d809 2
a810 2
	/* Traditional tar behaviour (pax wants to read file list from stdin) */
	if ((act == ARCHIVE || act == APPND) && argc == 0 && listfile == NULL)
a832 17
			int cdmode = 0;

			if (listfile) {
				FILE *fp;
				char *str;
			
				if (strcmp(listfile, "-") == 0)
					fp = stdin;
				else if ((fp = fopen(listfile, "r")) == NULL) {
					paxwarn(1, "Unable to open file '%s' for read", listfile);
					tar_usage();
				}
				while ((str = getline(fp)) != NULL) {
					if (strcmp(str, "-C") == 0) {
						cdmode = 1;
						continue;
					}
a833 20
					/*
					 * If last line was "-C" then
					 * this line has the dir, else
					 * we have a pattern.
					 */
					if (cdmode)
						chdname = str;
					else if (pat_add(str, chdname) < 0)
						tar_usage();
					else
						sawpat = 1;
					cdmode = 0;
				}
				if (strcmp(listfile, "-") != 0)
					fclose(fp);
				if (getline_error) {
					paxwarn(1, "Problem with file '%s'", listfile);
					tar_usage();
				}
			}
d842 25
d869 1
a869 1
				sawpat = 1;
a886 29
		if (listfile) {
			FILE *fp;
			char *str;
			int cdmode = 0;
			
			if (strcmp(listfile, "-") == 0)
				fp = stdin;
			else if ((fp = fopen(listfile, "r")) == NULL) {
				paxwarn(1, "Unable to open file '%s' for read",
				    listfile);
				tar_usage();
			}
			while ((str = getline(fp)) != NULL) {
				if (strcmp(str, "-C") == 0) {
					cdmode = 1;
					continue;
				}

				if (ftree_add(str, cdmode) < 0)
					tar_usage();
				cdmode = 0;
			}
			if (strcmp(listfile, "-") != 0)
				fclose(fp);
			if (getline_error) {
				paxwarn(1, "Problem with file '%s'", listfile);
				tar_usage();
			}
		}
d896 24
d1584 1
a1584 1
	(void)fputs("usage: tar [-]{crtux}[-befhmopqvwzHLOPXZ014578] [archive] ",
d1586 1
a1586 1
	(void)fputs("[blocksize] [-C directory] [-T file] [-s replstr] [file ...]\n",
@


1.44
log
@improve usage
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.43 2000/11/09 03:36:10 provos Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.43 2000/11/09 03:36:10 provos Exp $";
d610 1
d621 1
a621 1
	    "b:cef:hmopqruts:vwxzBC:HLOPXZ014578"))
d766 3
d813 2
a814 2
	/* Traditional tar behaviour (pax wants to read filelist from stdin) */
	if ((act == ARCHIVE || act == APPND) && argc == 0)
d837 17
d855 20
a882 25
				if (strcmp(*argv, "-T") == 0) {
					FILE *fp;
					char *str;

					if (*++argv == NULL)
						break;

					if ((fp = fopen(*argv, "r")) == NULL) {
						paxwarn(1, "Unable to open file '%s' for read", *argv);
						tar_usage();
					}
					while ((str = getline(fp)) != NULL) {
						if (pat_add(str, chdname) < 0)
							tar_usage();
						sawpat++;
					}
					fclose(fp);
					if (getline_error) {
						paxwarn(1, "Problem with file '%s'", *argv);
						tar_usage();
					}
					argv++;

					continue;
				}
d885 1
a885 1
				sawpat++;
d903 29
a940 24
			if (strcmp(*argv, "-T") == 0) {
				FILE *fp;
				char *str;

				if (*++argv == NULL)
					break;

				if ((fp = fopen(*argv, "r")) == NULL) {
					paxwarn(1, "Unable to open file '%s' for read", *argv);
					tar_usage();
				}
				while ((str = getline(fp)) != NULL) {
					if (ftree_add(str, 0) < 0)
						tar_usage();
				}
				fclose(fp);
				if (getline_error) {
					paxwarn(1, "Problem with file '%s'", *argv);
					tar_usage();
				}
				argv++;

				continue;
			}
d1605 1
a1605 1
	(void)fputs("usage: tar [-]{txru}[cevfbmopqswzBHLPXZ014578] [tapefile] ",
d1607 1
a1607 1
	(void)fputs("[blocksize] [replstr] [-C directory] [-T file] file1 file2...\n",
@


1.43
log
@typo, inspired by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.42 2000/06/09 16:37:54 espie Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.42 2000/06/09 16:37:54 espie Exp $";
d1584 1
a1584 1
	(void)fputs("usage: tar -{txru}[cevfbmopqswzBHLPXZ014578] [tapefile] ",
@


1.42
log
@Some minor cleanup, ok'd millert@@
- remove zflag variable, since gzip_program is enough to know what's
going on.
- fix ar_gzip call to not depend on global variables. Avoid bogus act
checks, avoid calling if fd == -1.
- do gzip check for append as early as possible.
- remove old K&R prototype when updating.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.41 2000/01/22 20:24:52 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.41 2000/01/22 20:24:52 deraadt Exp $";
d1411 1
a1411 1
 *	   seperated by x (also * for backwards compatibility), specifying
@


1.41
log
@remove extra externs not needed because of unistd.h (rest of tree will be done later.. contact me if you want to help)
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.40 1999/07/28 12:33:40 espie Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.40 1999/07/28 12:33:40 espie Exp $";
a399 1
			zflag = 1;
a736 1
			zflag = 1;
a774 1
			zflag = 1;
a1095 1
				zflag = 1;
a1177 1
				zflag = 1;
@


1.40
log
@Add -T support, ala GNU-tar.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.38 1999/07/04 18:21:11 espie Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.38 1999/07/04 18:21:11 espie Exp $";
a207 2
	extern char *optarg;
	extern int optind;
@


1.39
log
@fgetln does not allocate memory, pax tree functions don't allocate
memory...

but someone HAS to.
@
text
@d846 25
d901 24
d1593 1
a1593 1
	(void)fputs("[blocksize] [replstr] [-C directory] file1 file2...\n",
@


1.38
log
@New: tar -q option (for quick)
same as pax -n. Useful for packages.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.37 1999/05/23 17:19:22 aaron Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.37 1999/05/23 17:19:22 aaron Exp $";
d79 1
d87 6
d868 1
a868 1
			if (!strcmp(*argv, "-C")) {
d873 2
a874 3
			} else {
				if (ftree_add(*argv++, 0) < 0)
					tar_usage();
d876 2
d942 1
a942 2
	size_t len;
	char *p, *str;
d1081 1
a1081 2
				while ((str = fgetln(fp, &len)) != NULL) {
					str[len - 1] = '\0';
d1085 4
d1181 6
a1186 7
			while ((str = fgetln(stdin, &len)) != NULL) {
				str[len - 1] = '\0';
				if ((p = strdup(str)) == NULL) {
					paxwarn(0, "Out of memory.");
					exit(1);
				}
				ftree_add(p, NULL);
d1443 29
@


1.37
log
@getopt(3) returns -1, not EOF
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.36 1999/04/29 12:59:03 aaron Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.36 1999/04/29 12:59:03 aaron Exp $";
d616 1
a616 1
	    "b:cef:hmopruts:vwxzBC:HLOPXZ014578"))
d681 6
d1504 1
a1504 1
	(void)fputs("usage: tar -{txru}[cevfbmopswzBHLPXZ014578] [tapefile] ",
@


1.36
log
@always check return value of strdup()
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.35 1998/12/07 23:45:46 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.35 1998/12/07 23:45:46 deraadt Exp $";
d208 1
a208 1
	    != EOF) {
d617 1
a617 1
	    != EOF) {
d941 1
a941 1
	while ((c=getopt(argc,argv,"abcdfiklmoprstuvzABC:E:F:H:I:LO:SZ6")) != EOF)
@


1.35
log
@doc -z pax option; d
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.34 1998/09/20 02:22:22 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.34 1998/09/20 02:22:22 millert Exp $";
d929 1
a929 1
	char *str;
d1167 5
a1171 1
				ftree_add(strdup(str), NULL);
@


1.34
log
@When invoked as tar, print verbose output to stdout, not stderr.  If in list mode or in create mode where create output is to stdout print to stderr
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.33 1998/03/31 17:14:21 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.33 1998/03/31 17:14:21 millert Exp $";
d1455 1
a1455 1
	(void)fputs("usage: pax [-cdnv] [-E limit] [-f archive] ", stderr);
d1460 1
a1460 1
	(void)fputs("       pax -r [-cdiknuvDYZ] [-E limit] ", stderr);
d1466 1
a1466 1
	(void)fputs("       pax -w [-dituvHLPX] [-b blocksize] ", stderr);
@


1.33
log
@only preserve uid/gid if -p.  This is unlike traditional tar but more like gtar
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.32 1998/03/03 05:11:36 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.32 1998/03/03 05:11:36 millert Exp $";
d526 1
d795 6
d1021 1
@


1.32
log
@Correct -x and -p flags to be more like traditional tar and make
the man page reflect reality.  The -p flag only preserves the file
mode (irrespective of umask) if possible.  The -x flag tries
to set user/group, mtime, and mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.31 1998/01/22 06:21:29 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.31 1998/01/22 06:21:29 millert Exp $";
d675 1
a675 1
			 * preserve file mode, regardless of umask
d678 1
d717 1
a717 1
			 * mtime and ids if possible.
a720 1
			pids = 1;
@


1.31
log
@Preserve uid/gid if invoked as tar and extracting as root.
This is traditional tar behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.30 1997/09/01 18:29:54 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.30 1997/09/01 18:29:54 deraadt Exp $";
d675 1
a675 2
			 * preserve user id, group id, file
			 * mode, access/modification times
a676 1
			pids = 1;
a677 2
			patime = 1;
			pmtime = 1;
d715 2
a716 1
			 * write an archive, preserve ids if root
d719 2
a720 2
			if (geteuid() == 0)
				pids = 1;
@


1.30
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.29 1997/07/25 18:58:32 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.29 1997/07/25 18:58:32 mickey Exp $";
d719 1
a719 1
			 * write an archive
d722 2
@


1.29
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.28 1997/07/23 19:15:57 kstailey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.28 1997/07/23 19:15:57 kstailey Exp $";
d615 2
a616 2
	    "b:cef:hmopruts:vwxzBC:HLOPXZ014578")) 
	    != EOF)  {
d819 1
a819 1
				
d836 1
a836 1
			*/
d838 1
a838 1
				chdname = NULL;	
@


1.28
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.27 1997/06/18 20:06:30 kstailey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.27 1997/06/18 20:06:30 kstailey Exp $";
d149 1
a149 1
#if __STDC__
d185 1
a185 1
#if __STDC__
d592 1
a592 1
#if __STDC__
d911 1
a911 1
#if __STDC__
d1174 1
a1174 1
#if __STDC__
d1201 1
a1201 1
#if __STDC__
d1222 1
a1222 1
#if __STDC__
d1243 1
a1243 1
#if __STDC__
d1274 1
a1274 1
#if __STDC__
d1349 1
a1349 1
#if __STDC__
d1424 1
a1424 1
#if __STDC__
d1440 1
a1440 1
#if __STDC__
d1479 1
a1479 1
#if __STDC__
d1499 1
a1499 1
#if __STDC__
@


1.27
log
@(foo *)0 -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.26 1997/06/18 18:48:26 kstailey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.26 1997/06/18 18:48:26 kstailey Exp $";
d200 1
a200 1
        FSUB tmp;
d895 1
a895 1
		        syswarn(1, ENOTDIR, "%s", path);
d924 1
a924 1
        FSUB tmp;
d1207 2
a1208 2
        void *a;
        void *b;
d1211 1
a1211 1
        return(strcmp(((FSUB *)a)->name, ((FSUB *)b)->name));
d1456 1
a1456 1
	(void)fputs("[-U user] ... [-G group] ...\n           ", stderr);
@


1.26
log
@(foo *)NULL -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.25 1997/05/29 15:47:18 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.25 1997/05/29 15:47:18 millert Exp $";
d649 1
a649 1
				arcname = (char *)0;
@


1.25
log
@Fix -o option and add -O.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.24 1997/04/16 03:50:23 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.24 1997/04/16 03:50:23 millert Exp $";
d820 1
a820 1
			while (*argv != (char *)NULL) {
d822 1
a822 1
					if(*++argv == (char *)NULL)
d843 1
a843 1
		if (chdname != (char *)NULL) {	/* initial chdir() */
d848 1
a848 1
		while (*argv != (char *)NULL) {
d850 1
a850 1
				if (*++argv == (char *)NULL)
d865 1
a865 1
	if (!fstdin && ((arcname == (char *)NULL) || (*arcname == '\0'))) {
d867 1
a867 1
		if ((arcname == (char *)NULL) || (*arcname == '\0'))
d1135 1
a1135 1
			while (*argv != (char *)NULL)
d1140 1
a1140 1
			if (*argv == (char *)NULL) {
d1152 1
a1152 1
			if (*argv != (char *)NULL)
@


1.24
log
@Change rmt -> rst and use _PATH_DEFTAPE as default file if none is
specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.23 1997/04/12 17:25:25 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.23 1997/04/12 17:25:25 tholo Exp $";
d132 1
d604 1
d615 1
a615 1
	    "b:cef:hmopruts:vwxzBC:HLPXZ014578")) 
d670 2
d801 1
d803 6
a808 2
	if (act == ARCHIVE)
		frmt = &(fsub[F_TAR]);
@


1.23
log
@We need to copy the pathnames we get from fgetln() on stdin, as the buffer
will be reused.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.22 1997/04/06 06:26:23 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.22 1997/04/06 06:26:23 millert Exp $";
d60 1
d859 1
a859 1
			arcname = DEV_8;
@


1.22
log
@Remove old -P flag since it doesn't do anything and make -P mean
"preserve leading /" like GNU tar (no longer use -S for this).
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.21 1997/04/05 22:51:53 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.21 1997/04/05 22:51:53 millert Exp $";
d1150 1
a1150 1
				ftree_add(str, NULL);
@


1.21
log
@Fix bug introduced with "exit(0) if no files" behavior change.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.20 1997/04/05 22:36:14 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.20 1997/04/05 22:36:14 millert Exp $";
d612 1
a612 1
	    "b:cef:hmopruts:vwxzBC:HLPSXZ014578")) 
a745 6
			/*
			 * do not follow symlinks
			 */
			Lflag = 0;
			break;
		case 'S':
@


1.20
log
@Strip leading '/' of pathnames (only in tar mode).  -S option turns
this off like GNU tar.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.19 1997/04/04 20:54:50 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.19 1997/04/04 20:54:50 millert Exp $";
d797 1
a797 1
	if (argc == 0)
@


1.19
log
@Improvements based on commets by George Robbins <grr@@shandakor.tharsis.com>
 - ``tar cf'' will now just exit instead of waiting for a file list
   on stdin.  The old behavior should be re-enabled with an option.
 - Better wording in tar man page for -o and -w
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.18 1997/04/02 17:48:53 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.18 1997/04/02 17:48:53 millert Exp $";
d604 5
d612 1
a612 1
	    "b:cef:hmopruts:vwxzBC:HLPXZ014578")) 
d750 6
@


1.18
log
@opt_add() needs to make a copy of the input string since it modifies
it and new compilers don't let you write to constant strings.
Problem (core dump when using -o) noted by Felix Schroeter.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.17 1997/03/26 01:14:13 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.17 1997/03/26 01:14:13 millert Exp $";
d784 4
@


1.17
log
@Blocking factor in tar is in 512byte blocks.  Makes -b act like
``real'' tars.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.16 1997/03/02 09:46:47 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.16 1997/03/02 09:46:47 tholo Exp $";
d1273 4
d1289 1
d1294 1
@


1.16
log
@More complete cpio(1) emulation
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.15 1997/02/27 23:32:58 michaels Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.15 1997/02/27 23:32:58 michaels Exp $";
d612 1
a612 1
			 * specify blocksize
d618 1
@


1.15
log
@fix pr system/124, reported by Janjaap van Velthooven (janjaap@@stack.nl).
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.14 1997/02/20 06:54:34 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.14 1997/02/20 06:54:34 tholo Exp $";
d852 33
d910 1
d914 1
d938 1
d1120 1
a1120 1
			if (optind >= argc) {
d1124 3
d1128 1
a1128 1
			dirptr = argv[argc];
@


1.14
log
@cpio emulation for pax
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.13 1997/01/24 19:41:23 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.13 1997/01/24 19:41:23 millert Exp $";
a601 1
	char *chdnam = (char *)NULL;
d725 1
a725 1
			chdnam = optarg;
d799 1
a799 1

d801 1
a801 1
				if (!strcmp(*argv, "-C")) {
d804 1
a804 1
					chdnam = *argv++;
d808 1
a808 1
				if (pat_add(*argv++, chdnam) < 0)
a811 1

d813 6
a818 10
			 * If there were no patterns, but there was a chdir,
			 * we do it now.
			 */
			if ((sawpat == 0) && (chdnam != (char *)NULL)) {
				if (chdir(chdnam) < 0) {
					syswarn(0, errno, "Can't chdir to %s",
					    chdnam);
					exit(exit_val);
				}
			}
d823 2
a824 2
		if (chdnam != (char *)NULL) {	/* initial chdir() */
			if (ftree_add(chdnam, 1) < 0)
@


1.13
log
@Support multiple -v options like GNU tar (> 1 -v means do ls-like output).
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.12 1996/12/09 12:02:16 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.12 1996/12/09 12:02:16 deraadt Exp $";
a81 1
#ifdef notdef
a83 1
#endif
d128 3
a167 1
#	ifdef notdef
a169 1
#	endif
a857 1
#ifdef notdef
d874 240
a1114 1
#endif
a1434 1
#ifdef notdef
d1448 5
a1454 1
#endif
@


1.12
log
@support pax '-s replstr' option in tar mode too. this can be used to
deal with cleaning up absolute paths
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.9 1996/09/22 20:09:54 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.11 1996/12/09 12:00:15 deraadt Exp $";
d700 1
a700 1
			vflag = 1;
@


1.11
log
@revert to spawning compress-ing program. normally we want extracts using
'z' to also work on .Z files, but libz does not deal with compressed
data. Hacking the code to deal well with pipes has proven very hard.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.8 1996/08/10 03:08:00 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.10 1996/10/27 06:45:12 downsj Exp $";
d608 2
a609 1
	while ((c = getoldopt(argc, argv, "b:cef:hmoprutvwxzBC:HLPXZ014578")) 
d681 9
d1191 1
a1191 1
	(void)fputs("usage: tar -{txru}[cevfbmopwzBHLPXZ014578] [tapefile] ",
d1193 2
a1194 1
	(void)fputs("[blocksize] [-C directory] file1 file2...\n", stderr);
@


1.10
log
@Initial cut -C support in paxtar.  Exceeds GNU tar by quite a bit.
General pax still seems to work ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.9 1996/09/22 20:09:54 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.9 1996/09/22 20:09:54 tholo Exp $";
d87 3
d394 2
a395 1
			zflag = GZIP_CMP;
d708 2
a709 1
			zflag = GZIP_CMP;
d747 2
a748 1
			zflag = COMPRESS_CMP;
@


1.9
log
@Use zopen for compress-style compressed archives
Use libz for gzip-style compressed archives
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.8 1996/08/10 03:08:00 tholo Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.8 1996/08/10 03:08:00 tholo Exp $";
d56 1
d556 1
a556 1
			if (pat_add(argv[optind]) < 0)
d570 1
a570 1
			if (ftree_add(argv[optind]) < 0)
d599 1
d604 1
a604 1
	while ((c = getoldopt(argc, argv, "b:cef:hmoprutvwxzBHLPXZ014578")) 
d711 3
d783 28
a810 3
		while (*argv != (char *)NULL)
			if (pat_add(*argv++) < 0)
				tar_usage();
d814 2
a815 2
		while (*argv != (char *)NULL)
			if (ftree_add(*argv++) < 0)
d817 13
d1177 1
a1177 1
	(void)fputs("[blocksize] file1 file2...\n", stderr);
@


1.8
log
@Add support for -h in tar emulation mode to follow symlinks
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.7 1996/08/02 12:41:01 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.7 1996/08/02 12:41:01 deraadt Exp $";
a85 3
#define GZIP_CMD	"gzip"		/* command to run as gzip */
#define COMPRESS_CMD	"compress"	/* command to run as compress */

d390 1
a390 2
			zflag = 1;
			gzip_program = GZIP_CMD;
d702 1
a702 2
			zflag = 1;
			gzip_program = GZIP_CMD;
d737 1
a737 2
			zflag = 1;
			gzip_program = COMPRESS_CMD;
@


1.7
log
@zap getopt() case of -?, come on, it is the default!
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.6 1996/06/23 14:20:36 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.6 1996/06/23 14:20:36 deraadt Exp $";
d606 1
a606 1
	while ((c = getoldopt(argc, argv, "b:cef:moprutvwxzBHLPXZ014578")) 
d644 6
@


1.6
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.6 1996/03/26 23:54:18 mrg Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: options.c,v 1.6 1996/03/26 23:54:18 mrg Exp $";
a510 1
		case '?':
@


1.5
log
@Default to "ustar" format when invoked as tar
@
text
@d1 1
d45 1
a45 1
static char rcsid[] = "$NetBSD: options.c,v 1.6 1996/03/26 23:54:18 mrg Exp $";
@


1.4
log
@Add -z and -Z options to tar usage strings
@
text
@d128 1
a128 1
#define F_TAR	4	/* format when called as tar */
@


1.3
log
@Correct compile warnings
Rename warn() to paxwarn() so <err.h> can be included

Remove #include <ctype.h> when not needed; from FreeBSD
@
text
@d1132 1
a1132 1
	(void)fputs("usage: tar -{txru}[cevfbmopwBHLPX014578] [tapefile] ",
@


1.2
log
@from mrg; impliment -z (gzip) in pax and tar, and -Z (compress) in tar
@
text
@a53 1
#include <ctype.h>
d99 1
a99 1
	"bcpio", 5120, sizeof(HD_BCPIO), 1, 0, 0, 1, bcpio_id, cpio_strd,
d101 1
a101 1
	rd_wrfile, wr_rdfile, bad_opt,
d104 1
a104 1
	"cpio", 5120, sizeof(HD_CPIO), 1, 0, 0, 1, cpio_id, cpio_strd,
d106 1
a106 1
	rd_wrfile, wr_rdfile, bad_opt,
d109 1
a109 1
	"sv4cpio", 5120, sizeof(HD_VCPIO), 1, 0, 0, 1, vcpio_id, cpio_strd,
d111 1
a111 1
	rd_wrfile, wr_rdfile, bad_opt,
d114 1
a114 1
	"sv4crc", 5120, sizeof(HD_VCPIO), 1, 0, 0, 1, crc_id, crc_strd,
d116 1
a116 1
	rd_wrfile, wr_rdfile, bad_opt,
d119 1
a119 1
	"tar", 10240, BLKMULT, 0, 1, BLKMULT, 0, tar_id, no_op,
d121 1
a121 1
	rd_wrfile, wr_rdfile, tar_opt,
d124 1
a124 1
	"ustar", 10240, BLKMULT, 0, 1, BLKMULT, 0, ustar_id, ustar_strd,
d126 1
a126 1
	rd_wrfile, wr_rdfile, bad_opt,
d219 1
a219 1
				warn(1, "Invalid block size %s", optarg);
d321 1
a321 1
					warn(1, "Invalid -p string: %c", *pt);
d376 2
a377 2
			if (frmt = (FSUB *)bsearch((void *)&tmp, (void *)fsub,
			    sizeof(fsub)/sizeof(FSUB), sizeof(FSUB), c_frmt)) {
d381 1
a381 1
			warn(1, "Unknown -x format: %s", optarg);
d401 1
a401 1
				warn(1, "Invalid write limit %s", optarg);
d405 1
a405 1
				warn(1, "Write limit is not a %d byte multiple",
d429 1
a429 1
				warn(1, "Error count value must be positive");
d564 1
a564 1
			warn(0, "Destination directory was not supplied");
d614 1
a614 1
				warn(1, "Invalid block size %s", optarg);
d838 1
a838 1
	while (nxt = ffs(flg)) {
d909 1
a909 1
	warn(1,"These format options are not supported");
d940 1
a940 1
		warn(0, "Invalid option name");
d954 1
a954 1
			warn(0, "Invalid options format");
d958 1
a958 1
			warn(0, "Unable to allocate space for option list");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: options.c,v 1.5 1995/03/21 09:07:30 cgd Exp $	*/
d44 1
a44 1
static char rcsid[] = "$NetBSD: options.c,v 1.5 1995/03/21 09:07:30 cgd Exp $";
d86 3
d205 1
a205 1
	while ((c=getopt(argc,argv,"ab:cdf:iklno:p:rs:tuvwx:B:DE:G:HLPT:U:XYZ"))
d389 7
d607 1
a607 1
	while ((c = getoldopt(argc, argv, "b:cef:moprutvwxBHLPX014578")) 
d697 7
d732 7
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

