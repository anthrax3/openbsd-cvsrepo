head	1.18;
access;
symbols
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.11.0.26
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.18
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.22
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.20
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.28
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.24
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.22
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.20
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.18
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.16
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.14
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.6.0.14
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.12
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.10.11.06.54.05;	author martijn;	state Exp;
branches;
next	1.17;
commitid	8p9OiUv1PKZp4MBd;

1.17
date	2016.10.10.17.36.03;	author martijn;	state Exp;
branches;
next	1.16;
commitid	CzprbkdZ1T7LYzcH;

1.16
date	2016.08.02.20.17.06;	author martijn;	state Exp;
branches;
next	1.15;
commitid	dqnoMqZE4OSAHErC;

1.15
date	2016.03.22.17.58.28;	author mmcc;	state Exp;
branches;
next	1.14;
commitid	dG9FDzJpMhZLrmQQ;

1.14
date	2015.10.09.20.27.28;	author tobias;	state Exp;
branches;
next	1.13;
commitid	75UxTlTgsWoFG3EU;

1.13
date	2015.10.09.19.47.02;	author millert;	state Exp;
branches;
next	1.12;
commitid	z8ymRwVMvCsHkr2w;

1.12
date	2015.10.04.15.23.24;	author millert;	state Exp;
branches;
next	1.11;
commitid	DzhpkCptJKskzdTA;

1.11
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.11.23.42.12;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.24.22.17.04;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.16.03.04.46;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.09.01.18.29.31;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.12.17.58;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.12.19.38.42;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.15.22.25.58;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.20.04;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.07;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Reimplement g flag for s commands. Got lost in previous commit.

Found because of a hint by and OK schwarze@@.
@
text
@/*	$OpenBSD: sub.c,v 1.17 2016/10/10 17:36:03 martijn Exp $	*/
/*	$NetBSD: sub.c,v 1.4 1995/03/21 09:04:50 cgd Exp $	*/

/* sub.c: This file contains the substitution routines for the ed
   line editor */
/*-
 * Copyright (c) 1993 Andrew Moore, Talke Studio.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <limits.h>
#include <regex.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ed.h"

static char *extract_subst_template(void);
static int substitute_matching_text(regex_t *, line_t *, int, int);
static int apply_subst_template(char *, regmatch_t *, int, int);

static char *rhbuf;		/* rhs substitution buffer */
static int rhbufsz;		/* rhs substitution buffer size */
static int rhbufi;		/* rhs substitution buffer index */

/* extract_subst_tail: extract substitution tail from the command buffer */
int
extract_subst_tail(int *flagp, int *np)
{
	char delimiter;

	*flagp = *np = 0;
	if ((delimiter = *ibufp) == '\n') {
		rhbufi = 0;
		*flagp = GPR;
		return 0;
	} else if (extract_subst_template() == NULL)
		return  ERR;
	else if (*ibufp == '\n') {
		*flagp = GPR;
		return 0;
	} else if (*ibufp == delimiter)
		ibufp++;
	if ('1' <= *ibufp && *ibufp <= '9') {
		STRTOI(*np, ibufp);
		return 0;
	} else if (*ibufp == 'g') {
		ibufp++;
		*flagp = GSG;
		return 0;
	}
	return 0;
}


/* extract_subst_template: return pointer to copy of substitution template
   in the command buffer */
static char *
extract_subst_template(void)
{
	int n = 0;
	int i = 0;
	char c;
	char delimiter = *ibufp++;

	if (*ibufp == '%' && *(ibufp + 1) == delimiter) {
		ibufp++;
		if (!rhbuf)
			seterrmsg("no previous substitution");
		return rhbuf;
	}
	while (*ibufp != delimiter) {
		REALLOC(rhbuf, rhbufsz, i + 2, NULL);
		if ((c = rhbuf[i++] = *ibufp++) == '\n' && *ibufp == '\0') {
			i--, ibufp--;
			break;
		} else if (c != '\\')
			;
		else if ((rhbuf[i++] = *ibufp++) != '\n')
			;
		else if (!isglobal) {
			while ((n = get_tty_line()) == 0 ||
			    (n > 0 && ibuf[n - 1] != '\n'))
				clearerr(stdin);
			if (n < 0)
				return NULL;
		}
	}
	REALLOC(rhbuf, rhbufsz, i + 1, NULL);
	rhbuf[rhbufi = i] = '\0';
	return  rhbuf;
}


static char *rbuf;		/* substitute_matching_text buffer */
static int rbufsz;		/* substitute_matching_text buffer size */

/* search_and_replace: for each line in a range, change text matching a pattern
   according to a substitution template; return status  */
int
search_and_replace(regex_t *pat, int gflag, int kth)
{
	undo_t *up;
	char *txt;
	char *eot;
	int lc;
	int xa = current_addr;
	int nsubs = 0;
	line_t *lp;
	int len;

	current_addr = first_addr - 1;
	for (lc = 0; lc <= second_addr - first_addr; lc++) {
		lp = get_addressed_line_node(++current_addr);
		if ((len = substitute_matching_text(pat, lp, gflag, kth)) < 0)
			return ERR;
		else if (len) {
			up = NULL;
			if (delete_lines(current_addr, current_addr) < 0)
				return ERR;
			txt = rbuf;
			eot = rbuf + len;
			SPL1();
			do {
				if ((txt = put_sbuf_line(txt)) == NULL) {
					SPL0();
					return ERR;
				} else if (up)
					up->t = get_addressed_line_node(current_addr);
				else if ((up = push_undo_stack(UADD,
				    current_addr, current_addr)) == NULL) {
					SPL0();
					return ERR;
				}
			} while (txt != eot);
			SPL0();
			nsubs++;
			xa = current_addr;
		}
	}
	current_addr = xa;
	if  (nsubs == 0 && !(gflag & GLB)) {
		seterrmsg("no match");
		return ERR;
	} else if ((gflag & (GPR | GLS | GNP)) &&
	    display_lines(current_addr, current_addr, gflag) < 0)
		return ERR;
	return 0;
}


/* substitute_matching_text: replace text matched by a pattern according to
   a substitution template; return length of rbuf if changed, 0 if unchanged, or
   ERR on error */
static int
substitute_matching_text(regex_t *pat, line_t *lp, int gflag, int kth)
{
	int off = 0;
	int changed = 0;
	int matchno = 0;
	int i = 0;
	int nempty = -1;
	regmatch_t rm[SE_MAX];
	char *txt;
	char *eot, *eom;

	if ((eom = txt = get_sbuf_line(lp)) == NULL)
		return ERR;
	if (isbinary)
		NUL_TO_NEWLINE(txt, lp->len);
	eot = txt + lp->len;
	if (!regexec(pat, txt, SE_MAX, rm, 0)) {
		do {
/* Don't do a 0-length match directly after a non-0-length */
			if (rm[0].rm_eo == nempty) {
				rm[0].rm_so++;
				rm[0].rm_eo = lp->len;
				continue;
			}
			if (!kth || kth == ++matchno) {
				changed = 1;
				i = rm[0].rm_so - (eom - txt);
				REALLOC(rbuf, rbufsz, off + i, ERR);
				if (isbinary)
					NEWLINE_TO_NUL(eom,
					    rm[0].rm_eo - (eom - txt));
				memcpy(rbuf + off, eom, i);
				off += i;
				if ((off = apply_subst_template(txt, rm, off,
				    pat->re_nsub)) < 0)
					return ERR;
				eom = txt + rm[0].rm_eo;
				if (kth)
					break;
			}
			if (rm[0].rm_so == rm[0].rm_eo)
				rm[0].rm_so = rm[0].rm_eo + 1;
			else
				nempty = rm[0].rm_so = rm[0].rm_eo;
			rm[0].rm_eo = lp->len;
		} while (rm[0].rm_so < lp->len && (gflag & GSG || kth) &&
		    !regexec(pat, txt, SE_MAX, rm, REG_STARTEND | REG_NOTBOL));
		i = eot - eom;
		REALLOC(rbuf, rbufsz, off + i + 2, ERR);
		if (isbinary)
			NEWLINE_TO_NUL(eom, i);
		memcpy(rbuf + off, eom, i);
		memcpy(rbuf + off + i, "\n", 2);
	}
	return changed ? off + i + 1 : 0;
}


/* apply_subst_template: modify text according to a substitution template;
   return offset to end of modified text */
static int
apply_subst_template(char *boln, regmatch_t *rm, int off, int re_nsub)
{
	int j = 0;
	int k = 0;
	int n;
	char *sub = rhbuf;

	for (; sub - rhbuf < rhbufi; sub++)
		if (*sub == '&') {
			j = rm[0].rm_so;
			k = rm[0].rm_eo;
			REALLOC(rbuf, rbufsz, off + k - j, ERR);
			while (j < k)
				rbuf[off++] = boln[j++];
		} else if (*sub == '\\' && '1' <= *++sub && *sub <= '9' &&
		    (n = *sub - '0') <= re_nsub) {
			j = rm[n].rm_so;
			k = rm[n].rm_eo;
			REALLOC(rbuf, rbufsz, off + k - j, ERR);
			while (j < k)
				rbuf[off++] = boln[j++];
		} else {
			REALLOC(rbuf, rbufsz, off + 1, ERR);
			rbuf[off++] = *sub;
		}
	REALLOC(rbuf, rbufsz, off + 1, ERR);
	rbuf[off] = '\0';
	return off;
}
@


1.17
log
@Remove infinite loop detection from the s-command.
If a zero-length match is found do the replacement and increment the start point
for the next search by one. This allows for commands like s/^/- /
This brings the behaviour closer to the way sed and vi work.

OK schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.16 2016/08/02 20:17:06 martijn Exp $	*/
d224 1
a224 1
		} while (rm[0].rm_so < lp->len &&
@


1.16
log
@Fix the begin of word bug in s-command, similar to sed.

nit fix and OK schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.15 2016/03/22 17:58:28 mmcc Exp $	*/
d185 1
a185 1
	int inf = 0;
d197 6
d220 3
a222 2
				inf = 1;
			rm[0].rm_so = rm[0].rm_eo;
a224 1
		    (!changed || ((gflag & GSG) && !inf)) &&
a227 4
		if (i > 0 && (gflag & GSG) && inf) {
			seterrmsg("infinite substitution loop");
			return  ERR;
		}
@


1.15
log
@header cleanup

from Edgar Pettijohn, correction from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.14 2015/10/09 20:27:28 tobias Exp $	*/
d176 2
a177 1
   a substitution template; return pointer to the modified text */
d185 1
d188 1
a188 1
	char *eot;
d190 1
a190 1
	if ((txt = get_sbuf_line(lp)) == NULL)
d198 2
a199 2
				changed++;
				i = rm[0].rm_so;
d202 3
a204 2
					NEWLINE_TO_NUL(txt, rm[0].rm_eo);
				memcpy(rbuf + off, txt, i);
d209 3
a211 7
			} else {
				i = rm[0].rm_eo;
				REALLOC(rbuf, rbufsz, off + i, ERR);
				if (isbinary)
					NEWLINE_TO_NUL(txt, i);
				memcpy(rbuf + off, txt, i);
				off += i;
d213 8
a220 4
			txt += rm[0].rm_eo;
		} while (*txt && (!changed || ((gflag & GSG) && rm[0].rm_eo)) &&
		    !regexec(pat, txt, SE_MAX, rm, REG_NOTBOL));
		i = eot - txt;
d222 1
a222 1
		if (i > 0 && !rm[0].rm_eo && (gflag & GSG)) {
d227 2
a228 2
			NEWLINE_TO_NUL(txt, i);
		memcpy(rbuf + off, txt, i);
@


1.14
log
@Define functions as static when they are not used outside their own c-files.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.13 2015/10/09 19:47:02 millert Exp $	*/
d31 7
@


1.13
log
@Mark static globals that are only used in their respective .c files.
Also make stdin unbuffered since that is the same as using a
single-byte buffer.  OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.12 2015/10/04 15:23:24 millert Exp $	*/
d34 3
d74 1
a74 1
char *
d170 1
a170 1
int
d227 1
a227 1
int
@


1.12
log
@Remove useless pattern_t typedef, POSIX regex is here to stay so
just use regex_t directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.11 2009/10/27 23:59:21 deraadt Exp $	*/
d35 3
a37 3
char *rhbuf;			/* rhs substitution buffer */
int rhbufsz;			/* rhs substitution buffer size */
int rhbufi;			/* rhs substitution buffer index */
d108 2
a109 2
char *rbuf;			/* substitute_matching_text buffer */
int rbufsz;			/* substitute_matching_text buffer size */
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.10 2003/06/11 23:42:12 deraadt Exp $	*/
d114 1
a114 1
search_and_replace(pattern_t *pat, int gflag, int kth)
d168 1
a168 1
substitute_matching_text(pattern_t *pat, line_t *lp, int gflag, int kth)
@


1.10
log
@ansification, art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.9 2002/06/09 05:47:27 todd Exp $	*/
a30 8

#ifndef lint
#if 0
static char *rcsid = "@@(#)sub.c,v 1.1 1994/02/01 00:34:44 alm Exp";
#else
static char rcsid[] = "$OpenBSD: sub.c,v 1.9 2002/06/09 05:47:27 todd Exp $";
#endif
#endif /* not lint */
@


1.9
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.8 2002/03/24 22:17:04 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: sub.c,v 1.8 2002/03/24 22:17:04 millert Exp $";
d49 1
a49 3
extract_subst_tail(flagp, np)
	int *flagp;
	int *np;
d80 1
a80 1
extract_subst_template()
d122 1
a122 4
search_and_replace(pat, gflag, kth)
	pattern_t *pat;
	int gflag;
	int kth;
d176 1
a176 5
substitute_matching_text(pat, lp, gflag, kth)
	pattern_t *pat;
	line_t *lp;
	int gflag;
	int kth;
d233 1
a233 5
apply_subst_template(boln, rm, off, re_nsub)
	char *boln;
	regmatch_t *rm;
	int off;
	int re_nsub;
@


1.8
log
@Kill unneeded longs; fixes some minor 64 bit issues.  deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.7 2001/01/16 03:04:46 deraadt Exp $	*/
d4 1
a4 1
/* sub.c: This file contains the substitution routines for the ed 
d36 1
a36 1
static char rcsid[] = "$OpenBSD: sub.c,v 1.7 2001/01/16 03:04:46 deraadt Exp $";
@


1.7
log
@cleanup strcpy, strncpy, signal races, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.6 1997/09/01 18:29:31 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: sub.c,v 1.6 1997/09/01 18:29:31 deraadt Exp $";
d51 1
a51 1
	long *np;
d68 1
a68 1
		STRTOL(*np, ibufp);
d132 2
a133 2
	long lc;
	long xa = current_addr;
@


1.6
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.5 1996/12/14 12:17:58 mickey Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: sub.c,v 1.5 1996/12/14 12:17:58 mickey Exp $";
d92 1
a92 1
			strcpy(errmsg, "no previous substitution");
d169 1
a169 1
		strcpy(errmsg, "no match");
d227 1
a227 1
			strcpy(errmsg, "infinite substitution loop");
@


1.5
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.4 1996/10/12 19:38:42 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: sub.c,v 1.4 1996/10/12 19:38:42 millert Exp $";
d197 1
a197 1
	if (isbinary) 
@


1.4
log
@Back out my sprintf -> snprintf changes where they don't make sense and
use good ole strcpy() instead.  Also use perror() instead of fprintf()
where it makes sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.3 1996/09/15 22:25:58 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: sub.c,v 1.3 1996/09/15 22:25:58 millert Exp $";
d106 1
a106 1
			    n > 0 && ibuf[n - 1] != '\n')
d222 1
a222 1
		} while (*txt && (!changed || (gflag & GSG) && rm[0].rm_eo) &&
@


1.3
log
@sprintf -> snprintf paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.2 1996/06/23 14:20:04 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: sub.c,v 1.2 1996/06/23 14:20:04 deraadt Exp $";
d92 1
a92 1
			snprintf(errmsg, sizeof(errmsg), "no previous substitution");
d169 1
a169 1
		snprintf(errmsg, sizeof(errmsg), "no match");
d227 1
a227 1
			snprintf(errmsg, sizeof(errmsg), "infinite substitution loop");
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: sub.c,v 1.4 1995/03/21 09:04:50 cgd Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: sub.c,v 1.4 1995/03/21 09:04:50 cgd Exp $";
d91 2
a92 1
		if (!rhbuf) sprintf(errmsg, "no previous substitution");
d169 1
a169 1
		sprintf(errmsg, "no match");
d227 1
a227 1
			sprintf(errmsg, "infinite substitution loop");
@


1.1
log
@Initial revision
@
text
@d1 1
d36 1
a36 1
static char rcsid[] = "$NetBSD: sub.c,v 1.4 1995/03/21 09:04:50 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
