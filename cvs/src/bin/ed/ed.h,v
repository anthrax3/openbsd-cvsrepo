head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.4
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.6
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.8
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.4
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.11.0.24
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.22
	OPENBSD_5_0:1.11.0.20
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.18
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.16
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.12
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.14
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.10
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.8
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.6
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.20
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.18
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.16
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.14
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.12
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.10
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.8
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.16
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.14
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.03.27.00.43.38;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	2OGzZv9y9DmiyNpS;

1.21
date	2015.10.09.21.24.05;	author tobias;	state Exp;
branches;
next	1.20;
commitid	lMLGwZnIoP49Tk0o;

1.20
date	2015.10.09.20.27.28;	author tobias;	state Exp;
branches;
next	1.19;
commitid	75UxTlTgsWoFG3EU;

1.19
date	2015.10.09.19.47.02;	author millert;	state Exp;
branches;
next	1.18;
commitid	z8ymRwVMvCsHkr2w;

1.18
date	2015.10.04.15.23.24;	author millert;	state Exp;
branches;
next	1.17;
commitid	DzhpkCptJKskzdTA;

1.17
date	2015.10.04.15.03.24;	author millert;	state Exp;
branches;
next	1.16;
commitid	bSiRNka8EjZW40u3;

1.16
date	2015.07.14.19.16.33;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	GMOLaDTE4ZEs4fp9;

1.15
date	2015.01.16.06.39.32;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	Uu5nFG3wCl0LACBb;

1.14
date	2014.12.02.20.34.14;	author millert;	state Exp;
branches;
next	1.13;
commitid	7Z7aqQEwcncHP7hd;

1.13
date	2014.04.14.22.12.01;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2012.12.04.02.40.47;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.24.13.24.47;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.24.22.17.04;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.17.19.42.19;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.05.22.30.15;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.16.03.04.45;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.10.12.19.38.33;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.15.22.25.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.08.22.00.35.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.20.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.07;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@actually remove unnecessary includes

from Edgar Pettijohn, ok and with input from tb@@
@
text
@/*	$OpenBSD: ed.h,v 1.21 2015/10/09 21:24:05 tobias Exp $	*/
/*	$NetBSD: ed.h,v 1.23 1995/03/21 09:04:40 cgd Exp $	*/

/* ed.h: type and constant definitions for the ed editor. */
/*
 * Copyright (c) 1993 Andrew Moore
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ed.h,v 1.5 1994/02/01 00:34:39 alm Exp
 */

#include <limits.h>
#include <regex.h>
#include <signal.h>

#define ERR		(-2)
#define EMOD		(-3)
#define FATAL		(-4)

#define MINBUFSZ 512		/* minimum buffer size - must be > 0 */
#define SE_MAX 30		/* max subexpressions in a regular expression */
#define LINECHARS INT_MAX	/* max chars per line */

/* gflags */
#define GLB 001		/* global command */
#define GPR 002		/* print after command */
#define GLS 004		/* list after command */
#define GNP 010		/* enumerate after command */
#define GSG 020		/* global substitute */

/* Line node */
typedef struct	line {
	struct line	*q_forw;
	struct line	*q_back;
	off_t		seek;		/* address of line in scratch buffer */
	int		len;		/* length of line */
} line_t;


typedef struct undo {

/* type of undo nodes */
#define UADD	0
#define UDEL 	1
#define UMOV	2
#define VMOV	3

	int type;			/* command type */
	line_t	*h;			/* head of list */
	line_t  *t;			/* tail of list */
} undo_t;

#ifndef max
# define max(a,b) ((a) > (b) ? (a) : (b))
#endif
#ifndef min
# define min(a,b) ((a) < (b) ? (a) : (b))
#endif

#define INC_MOD(l, k)	((l) + 1 > (k) ? 0 : (l) + 1)
#define DEC_MOD(l, k)	((l) - 1 < 0 ? (k) : (l) - 1)

/* SPL1: disable some interrupts (requires reliable signals) */
#define SPL1() mutex++

/* SPL0: enable all interrupts; check signal flags (requires reliable signals) */
#define SPL0()						\
	do {						\
		if (--mutex == 0) {			\
			if (sighup)			\
				handle_hup(SIGHUP);	\
			if (sigint)			\
				handle_int(SIGINT);	\
		}					\
	} while (0)

/* STRTOI: convert a string to int */
#define STRTOI(i, p) { \
	long l = strtol(p, &p, 10); \
	if (l <= INT_MIN || l >= INT_MAX) { \
		seterrmsg("number out of range"); \
	    	i = 0; \
		return ERR; \
	} else \
		i = (int)l; \
}

/* REALLOC: assure at least a minimum size for buffer b */
#define REALLOC(b,n,i,err) \
if ((i) > (n)) { \
	int ti = (n); \
	char *ts; \
	SPL1(); \
	if ((ts = realloc((b), ti += max((i), MINBUFSZ))) == NULL) { \
		perror(NULL); \
		seterrmsg("out of memory"); \
		SPL0(); \
		return err; \
	} \
	(n) = ti; \
	(b) = ts; \
	SPL0(); \
}

/* REQUE: link pred before succ */
#define REQUE(pred, succ) (pred)->q_forw = (succ), (succ)->q_back = (pred)

/* INSQUE: insert elem in circular queue after pred */
#define INSQUE(elem, pred) \
{ \
	REQUE((elem), (pred)->q_forw); \
	REQUE((pred), elem); \
}

/* remque: remove_lines elem from circular queue */
#define REMQUE(elem) REQUE((elem)->q_back, (elem)->q_forw);

/* NUL_TO_NEWLINE: overwrite ASCII NULs with newlines */
#define NUL_TO_NEWLINE(s, l) translit_text(s, l, '\0', '\n')

/* NEWLINE_TO_NUL: overwrite newlines with ASCII NULs */
#define NEWLINE_TO_NUL(s, l) translit_text(s, l, '\n', '\0')

/* Local Function Declarations */
void add_line_node(line_t *);
int build_active_list(int);
void clear_active_list(void);
void clear_undo_stack(void);
int close_sbuf(void);
int delete_lines(int, int);
int display_lines(int, int, int);
int exec_command(void);
int exec_global(int, int);
int extract_addr_range(void);
int extract_subst_tail(int *, int *);
line_t *get_addressed_line_node(int);
regex_t *get_compiled_pattern(void);
char *get_extended_line(int *, int);
int get_line_node_addr(line_t *);
char *get_sbuf_line(line_t *);
int get_tty_line(void);
void handle_hup(int);
void handle_int(int);
int has_trailing_escape(char *, char *);
void init_buffers(void);
int open_sbuf(void);
int pop_undo_stack(void);
undo_t *push_undo_stack(int, int, int);
char *put_sbuf_line(char *);
int put_tty_line(char *, int, int, int);
void quit(int);
int read_file(char *, int);
int search_and_replace(regex_t *, int, int);
void seterrmsg(char *);
char *strip_escapes(char *);
char *translit_text(char *, int, int, int);
void unmark_line_node(line_t *);
void unset_active_nodes(line_t *, line_t *);
int write_file(char *, char *, int, int);

/* global buffers */
extern char *ibuf;
extern char *ibufp;
extern int ibufsz;

/* global flags */
extern int isbinary;
extern int isglobal;
extern int modified;

extern volatile sig_atomic_t mutex;
extern volatile sig_atomic_t sighup;
extern volatile sig_atomic_t sigint;

/* global vars */
extern int addr_last;
extern int current_addr;
extern int first_addr;
extern int lineno;
extern int second_addr;
@


1.21
log
@The variable errmsg can be static in main.c if code in re.c uses an own
buffer to construct error messages.

with input by and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.20 2015/10/09 20:27:28 tobias Exp $	*/
a32 2
#include <sys/types.h>
#include <errno.h>
a35 4
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.20
log
@Define functions as static when they are not used outside their own c-files.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.19 2015/10/09 19:47:02 millert Exp $	*/
a204 1
extern char errmsg[PATH_MAX + 40];
@


1.19
log
@Mark static globals that are only used in their respective .c files.
Also make stdin unbuffered since that is the same as using a
single-byte buffer.  OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.18 2015/10/04 15:23:24 millert Exp $	*/
a152 2
int append_lines(int);
int apply_subst_template(char *, regmatch_t *, int, int);
a153 1
int check_addr_range(int, int);
a156 1
int copy_lines(int);
a158 1
line_t *dup_line_node(line_t *);
a161 1
char *extract_pattern(int);
a162 1
char *extract_subst_template(void);
a165 1
char *get_filename(void);
a166 2
int get_matching_node_addr(regex_t *, int);
int get_marked_node_addr(int);
a167 2
int get_shell_command(void);
int get_stream_line(FILE *);
a170 1
void handle_winch(int);
a172 5
int join_lines(int, int);
int mark_line_node(line_t *, int);
int move_lines(int);
line_t *next_active_node(void);
int next_addr(void);
a173 1
char *parse_char_class(char *);
a176 1
int put_stream_line(FILE *, char *, int);
a179 1
int read_stream(FILE *, int);
a180 1
int set_active_node(line_t *);
a181 2
void signal_hup(int);
void signal_int(int);
a182 1
int substitute_matching_text(regex_t *, line_t *, int, int);
a186 1
int write_stream(FILE *, int, int);
@


1.18
log
@Remove useless pattern_t typedef, POSIX regex is here to stay so
just use regex_t directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.17 2015/10/04 15:03:24 millert Exp $	*/
a214 1
extern char stdinbuf[];
@


1.17
log
@Remove #ifdefs for non-POSIX systems.  Also remove #ifdef for
SIGWINCH, it is not POSIX but it is a defacto standard.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.16 2015/07/14 19:16:33 deraadt Exp $	*/
a57 2
typedef regex_t pattern_t;

d171 1
a171 1
pattern_t *get_compiled_pattern(void);
d175 1
a175 1
int get_matching_node_addr(pattern_t *, int);
d201 1
a201 1
int search_and_replace(pattern_t *, int, int);
d207 1
a207 1
int substitute_matching_text(pattern_t *, line_t *, int, int);
@


1.16
log
@use atomic operations on sig_atomic_t variables inside the signal handlers,
rather than sharing one variable unsafely.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.15 2015/01/16 06:39:32 deraadt Exp $	*/
d49 1
a49 5
#ifdef INT_MAX
# define LINECHARS INT_MAX	/* max chars per line */
#else
# define LINECHARS MAXINT	/* max chars per line */
#endif
@


1.15
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.14 2014/12/02 20:34:14 millert Exp $	*/
d99 10
a108 6
/* SPL0: enable all interrupts; check sigflags (requires reliable signals) */
#define SPL0() \
if (--mutex == 0) { \
	if (sigflags & (1 << (SIGHUP - 1))) handle_hup(SIGHUP); \
	if (sigflags & (1 << (SIGINT - 1))) handle_int(SIGINT); \
}
d127 1
a127 1
	if ((ts = (char *) realloc((b), ti += max((i), MINBUFSZ))) == NULL) { \
d230 4
a233 2
extern int mutex;
extern int sigflags;
@


1.14
log
@Remove prototypes for functions that were already removed.
From Benjamin Scher Purcell.
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.13 2014/04/14 22:12:01 tedu Exp $	*/
a33 1
#include <sys/param.h>		/* for MAXPATHLEN */
d232 1
a232 1
extern char errmsg[MAXPATHLEN + 40];
@


1.13
log
@remove nonstandard DES support because DES. ok beck deraadt miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.12 2012/12/04 02:40:47 deraadt Exp $	*/
a158 2
int cbc_decode(char *, FILE *);
int cbc_encode(char *, int, FILE *);
a176 1
int get_keyword(void);
a187 1
int hex_to_binary(int, int);
a188 1
int is_legal_filename(char *);
@


1.12
log
@remove sunos backwards compat
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.11 2007/02/24 13:24:47 millert Exp $	*/
a166 1
void des_error(char *);
a170 1
void expand_des_key(char *, char *);
a174 1
int flush_des_file(FILE *);
a176 1
int get_des_char(FILE *);
a192 1
void init_des_cipher(void);
a202 1
int put_des_char(int, FILE *);
a210 1
void set_des_key(char *);
@


1.11
log
@There is no filter_lines function, remove its prototype.  From Mark Lumsden.
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.10 2002/03/24 22:17:04 millert Exp $	*/
d34 1
a34 3
#if defined(BSD) && BSD >= 199103 || defined(__386BSD__)
# include <sys/param.h>		/* for MAXPATHLEN */
#endif
d36 1
a36 3
#if defined(sun) || defined(__NetBSD__) || defined(__OpenBSD__)
# include <limits.h>
#endif
a47 4
#ifndef MAXPATHLEN
# define MAXPATHLEN 255		/* _POSIX_PATH_MAX */
#endif

a117 27
#if defined(sun) || defined(NO_REALLOC_NULL)
/* REALLOC: assure at least a minimum size for buffer b */
#define REALLOC(b,n,i,err) \
if ((i) > (n)) { \
	int ti = (n); \
	char *ts; \
	SPL1(); \
	if ((b) != NULL) { \
		if ((ts = (char *) realloc((b), ti += max((i), MINBUFSZ))) == NULL) { \
			perror(NULL); \
			seterrmsg("out of memory"); \
			SPL0(); \
			return err; \
		} \
	} else { \
		if ((ts = (char *) malloc(ti += max((i), MINBUFSZ))) == NULL) { \
			perror(NULL); \
			seterrmsg("out of memory"); \
			SPL0(); \
			return err; \
		} \
	} \
	(n) = ti; \
	(b) = ts; \
	SPL0(); \
}
#else /* NO_REALLOC_NULL */
a133 1
#endif /* NO_REALLOC_NULL */
a153 4
#ifdef sun
# define strerror(n) sys_errlist[n]
#endif

a248 3
#ifdef sun
extern char *sys_errlist[];
#endif
@


1.10
log
@Kill unneeded longs; fixes some minor 64 bit issues.  deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.9 2002/02/17 19:42:19 millert Exp $	*/
a216 1
int filter_lines(int, int, char *);
@


1.9
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.8 2002/02/16 21:27:06 millert Exp $	*/
d115 4
a118 4
/* STRTOL: convert a string to long */
#define STRTOL(i, p) { \
	if (((i = strtol(p, &p, 10)) == LONG_MIN || i == LONG_MAX) && \
	    errno == ERANGE) { \
d122 2
a123 1
	} \
d196 1
a196 1
int append_lines(long);
d201 1
a201 1
int check_addr_range(long, long);
d205 2
a206 2
int copy_lines(long);
int delete_lines(long, long);
d208 1
a208 1
int display_lines(long, long, int);
d211 1
a211 1
long exec_global(int, int);
d215 1
a215 1
int extract_subst_tail(int *, long *);
d217 1
a217 1
int filter_lines(long, long, char *);
d219 1
a219 1
line_t *get_addressed_line_node(long);
d225 3
a227 3
long get_line_node_addr(line_t *);
long get_matching_node_addr(pattern_t *, int);
long get_marked_node_addr(int);
d240 1
a240 1
int join_lines(long, long);
d242 1
a242 1
int move_lines(long);
d244 1
a244 1
long next_addr(void);
d248 1
a248 1
undo_t *push_undo_stack(int, long, long);
d252 1
a252 1
int put_tty_line(char *, int, long, int);
d254 2
a255 2
long read_file(char *, long);
long read_stream(FILE *, long);
d267 2
a268 2
long write_file(char *, char *, long, long);
long write_stream(FILE *, long, long);
d284 2
a285 2
extern long addr_last;
extern long current_addr;
d287 1
a287 1
extern long first_addr;
d289 1
a289 1
extern long second_addr;
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.7 2001/07/05 22:30:15 espie Exp $	*/
a190 8
#endif

#ifndef __P
# ifndef __STDC__
#  define __P(proto) ()
# else
#  define __P(proto) proto
# endif
@


1.7
log
@Fix prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.6 2001/01/16 03:04:45 deraadt Exp $	*/
d202 74
a275 74
void add_line_node __P((line_t *));
int append_lines __P((long));
int apply_subst_template __P((char *, regmatch_t *, int, int));
int build_active_list __P((int));
int cbc_decode __P((char *, FILE *));
int cbc_encode __P((char *, int, FILE *));
int check_addr_range __P((long, long));
void clear_active_list __P((void));
void clear_undo_stack __P((void));
int close_sbuf __P((void));
int copy_lines __P((long));
int delete_lines __P((long, long));
void des_error __P((char *));
int display_lines __P((long, long, int));
line_t *dup_line_node __P((line_t *));
int exec_command __P((void));
long exec_global __P((int, int));
void expand_des_key __P((char *, char *));
int extract_addr_range __P((void));
char *extract_pattern __P((int));
int extract_subst_tail __P((int *, long *));
char *extract_subst_template __P((void));
int filter_lines __P((long, long, char *));
int flush_des_file __P((FILE *));
line_t *get_addressed_line_node __P((long));
pattern_t *get_compiled_pattern __P((void));
int get_des_char __P((FILE *));
char *get_extended_line __P((int *, int));
char *get_filename __P((void));
int get_keyword __P((void));
long get_line_node_addr __P((line_t *));
long get_matching_node_addr __P((pattern_t *, int));
long get_marked_node_addr __P((int));
char *get_sbuf_line __P((line_t *));
int get_shell_command __P((void));
int get_stream_line __P((FILE *));
int get_tty_line __P((void));
void handle_hup __P((int));
void handle_int __P((int));
void handle_winch __P((int));
int has_trailing_escape __P((char *, char *));
int hex_to_binary __P((int, int));
void init_buffers __P((void));
void init_des_cipher __P((void));
int is_legal_filename __P((char *));
int join_lines __P((long, long));
int mark_line_node __P((line_t *, int));
int move_lines __P((long));
line_t *next_active_node __P((void));
long next_addr __P((void));
int open_sbuf __P((void));
char *parse_char_class __P((char *));
int pop_undo_stack __P((void));
undo_t *push_undo_stack __P((int, long, long));
int put_des_char __P((int, FILE *));
char *put_sbuf_line __P((char *));
int put_stream_line __P((FILE *, char *, int));
int put_tty_line __P((char *, int, long, int));
void quit __P((int));
long read_file __P((char *, long));
long read_stream __P((FILE *, long));
int search_and_replace __P((pattern_t *, int, int));
int set_active_node __P((line_t *));
void set_des_key __P((char *));
void seterrmsg __P((char *));
void signal_hup __P((int));
void signal_int __P((int));
char *strip_escapes __P((char *));
int substitute_matching_text __P((pattern_t *, line_t *, int, int));
char *translit_text __P((char *, int, int, int));
void unmark_line_node __P((line_t *));
void unset_active_nodes __P((line_t *, line_t *));
long write_file __P((char *, char *, long, long));
long write_stream __P((FILE *, long, long));
@


1.6
log
@cleanup strcpy, strncpy, signal races, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.5 1996/10/12 19:38:33 millert Exp $	*/
d250 1
a250 1
line_t *next_active_node __P(());
d266 1
@


1.5
log
@Back out my sprintf -> snprintf changes where they don't make sense and
use good ole strcpy() instead.  Also use perror() instead of fprintf()
where it makes sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.4 1996/09/15 22:25:55 millert Exp $	*/
d119 1
a119 1
		strcpy(errmsg, "number out of range"); \
d135 1
a135 1
			strcpy(errmsg, "out of memory"); \
d142 1
a142 1
			strcpy(errmsg, "out of memory"); \
d160 1
a160 1
		strcpy(errmsg, "out of memory"); \
@


1.4
log
@sprintf -> snprintf paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.3 1996/08/22 00:35:17 deraadt Exp $	*/
d119 1
a119 1
		snprintf(errmsg, sizeof(errmsg), "number out of range"); \
d134 2
a135 2
			fprintf(stderr, "%s\n", strerror(errno)); \
			snprintf(errmsg, sizeof(errmsg), "out of memory"); \
d141 2
a142 2
			fprintf(stderr, "%s\n", strerror(errno)); \
			snprintf(errmsg, sizeof(errmsg), "out of memory"); \
d159 2
a160 2
		fprintf(stderr, "%s\n", strerror(errno)); \
		snprintf(errmsg, sizeof(errmsg), "out of memory"); \
@


1.3
log
@__OpenBSD__
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.2 1996/06/23 14:20:00 deraadt Exp $	*/
d119 1
a119 1
		sprintf(errmsg, "number out of range"); \
d135 1
a135 1
			sprintf(errmsg, "out of memory"); \
d142 1
a142 1
			sprintf(errmsg, "out of memory"); \
d160 1
a160 1
		sprintf(errmsg, "out of memory"); \
d292 1
a292 1
extern char errmsg[];
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.23 1995/03/21 09:04:40 cgd Exp $	*/
d38 1
a38 1
#if defined(sun) || defined(__NetBSD__)
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
