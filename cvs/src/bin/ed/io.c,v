head	1.19;
access;
symbols
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.16.0.8
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.20
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.12.0.10
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.6
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.18
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.16
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.14
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.12
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.10
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2016.03.22.17.58.28;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	dG9FDzJpMhZLrmQQ;

1.18
date	2015.10.09.20.27.28;	author tobias;	state Exp;
branches;
next	1.17;
commitid	75UxTlTgsWoFG3EU;

1.17
date	2015.10.09.19.47.02;	author millert;	state Exp;
branches;
next	1.16;
commitid	z8ymRwVMvCsHkr2w;

1.16
date	2014.04.14.22.12.01;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.28.15.40.47;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.28.05.06.17;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.06.10.22.29;	author chl;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.11.23.42.12;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.24.22.17.04;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.16.18.44.21;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.16.03.04.45;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.02.01.12.03.07;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.12.14.12.17.54;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.12.37.53;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.12.19.38.36;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.15.22.25.56;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.20.02;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.07;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@header cleanup

from Edgar Pettijohn, correction from deraadt@@
@
text
@/*	$OpenBSD: io.c,v 1.18 2015/10/09 20:27:28 tobias Exp $	*/
/*	$NetBSD: io.c,v 1.2 1995/03/21 09:04:43 cgd Exp $	*/

/* io.c: This file contains the i/o routines for the ed line editor */
/*-
 * Copyright (c) 1993 Andrew Moore, Talke Studio.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <regex.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ed.h"

static int read_stream(FILE *, int);
static int get_stream_line(FILE *);
static int write_stream(FILE *, int, int);
static int put_stream_line(FILE *, char *, int);

extern int scripted;

/* read_file: read a named file/pipe into the buffer; return line count */
int
read_file(char *fn, int n)
{
	FILE *fp;
	int size;


	fp = (*fn == '!') ? popen(fn + 1, "r") : fopen(strip_escapes(fn), "r");
	if (fp == NULL) {
		perror(fn);
		seterrmsg("cannot open input file");
		return ERR;
	} else if ((size = read_stream(fp, n)) < 0)
		return ERR;
	 else if (((*fn == '!') ?  pclose(fp) : fclose(fp)) < 0) {
		perror(fn);
		seterrmsg("cannot close input file");
		return ERR;
	}
	fprintf(stderr, !scripted ? "%d\n" : "", size);
	return current_addr - n;
}


static char *sbuf;		/* file i/o buffer */
static int sbufsz;		/* file i/o buffer size */
int newline_added;		/* if set, newline appended to input file */

/* read_stream: read a stream into the editor buffer; return status */
static int
read_stream(FILE *fp, int n)
{
	line_t *lp = get_addressed_line_node(n);
	undo_t *up = NULL;
	unsigned int size = 0;
	int o_newline_added = newline_added;
	int o_isbinary = isbinary;
	int appended = (n == addr_last);
	int len;

	isbinary = newline_added = 0;
	for (current_addr = n; (len = get_stream_line(fp)) > 0; size += len) {
		SPL1();
		if (put_sbuf_line(sbuf) == NULL) {
			SPL0();
			return ERR;
		}
		lp = lp->q_forw;
		if (up)
			up->t = lp;
		else if ((up = push_undo_stack(UADD, current_addr,
		    current_addr)) == NULL) {
			SPL0();
			return ERR;
		}
		SPL0();
	}
	if (len < 0)
		return ERR;
	if (appended && size && o_isbinary && o_newline_added)
		fputs("newline inserted\n", stderr);
	else if (newline_added && (!appended || (!isbinary && !o_isbinary)))
		fputs("newline appended\n", stderr);
	if (isbinary && newline_added && !appended)
	    	size += 1;
	if (!size)
		newline_added = 1;
	newline_added = appended ? newline_added : o_newline_added;
	isbinary = isbinary | o_isbinary;
	return size;
}

/* get_stream_line: read a line of text from a stream; return line length */
static int
get_stream_line(FILE *fp)
{
	int c;
	int i = 0;

	while (((c = getc(fp)) != EOF || (!feof(fp) &&
	    !ferror(fp))) && c != '\n') {
		REALLOC(sbuf, sbufsz, i + 1, ERR);
		if (!(sbuf[i++] = c))
			isbinary = 1;
	}
	REALLOC(sbuf, sbufsz, i + 2, ERR);
	if (c == '\n')
		sbuf[i++] = c;
	else if (ferror(fp)) {
		perror(NULL);
		seterrmsg("cannot read input file");
		return ERR;
	} else if (i) {
		sbuf[i++] = '\n';
		newline_added = 1;
	}
	sbuf[i] = '\0';
	return (isbinary && newline_added && i) ? --i : i;
}


/* write_file: write a range of lines to a named file/pipe; return line count */
int
write_file(char *fn, char *mode, int n, int m)
{
	FILE *fp;
	int size;

	fp = (*fn == '!') ? popen(fn+1, "w") : fopen(strip_escapes(fn), mode);
	if (fp == NULL) {
		perror(fn);
		seterrmsg("cannot open output file");
		return ERR;
	} else if ((size = write_stream(fp, n, m)) < 0)
		return ERR;
	 else if (((*fn == '!') ?  pclose(fp) : fclose(fp)) < 0) {
		perror(fn);
		seterrmsg("cannot close output file");
		return ERR;
	}
	fprintf(stderr, !scripted ? "%d\n" : "", size);
	return n ? m - n + 1 : 0;
}


/* write_stream: write a range of lines to a stream; return status */
static int
write_stream(FILE *fp, int n, int m)
{
	line_t *lp = get_addressed_line_node(n);
	unsigned int size = 0;
	char *s;
	int len;

	for (; n && n <= m; n++, lp = lp->q_forw) {
		if ((s = get_sbuf_line(lp)) == NULL)
			return ERR;
		len = lp->len;
		if (n != addr_last || !isbinary || !newline_added)
			s[len++] = '\n';
		if (put_stream_line(fp, s, len) < 0)
			return ERR;
		size += len;
	}
	return size;
}


/* put_stream_line: write a line of text to a stream; return status */
static int
put_stream_line(FILE *fp, char *s, int len)
{
	while (len--) {
		if (fputc(*s, fp) < 0) {
			perror(NULL);
			seterrmsg("cannot write file");
			return ERR;
		}
		s++;
	}
	return 0;
}

/* get_extended_line: get a an extended line from stdin */
char *
get_extended_line(int *sizep, int nonl)
{
	static char *cvbuf = NULL;		/* buffer */
	static int cvbufsz = 0;			/* buffer size */

	int l, n;
	char *t = ibufp;

	while (*t++ != '\n')
		;
	if ((l = t - ibufp) < 2 || !has_trailing_escape(ibufp, ibufp + l - 1)) {
		*sizep = l;
		return ibufp;
	}
	*sizep = -1;
	REALLOC(cvbuf, cvbufsz, l, NULL);
	memcpy(cvbuf, ibufp, l);
	*(cvbuf + --l - 1) = '\n'; 	/* strip trailing esc */
	if (nonl)
		l--; 			/* strip newline */
	for (;;) {
		if ((n = get_tty_line()) < 0)
			return NULL;
		else if (n == 0 || ibuf[n - 1] != '\n') {
			seterrmsg("unexpected end-of-file");
			return NULL;
		}
		REALLOC(cvbuf, cvbufsz, l + n, NULL);
		memcpy(cvbuf + l, ibuf, n);
		l += n;
		if (n < 2 || !has_trailing_escape(cvbuf, cvbuf + l - 1))
			break;
		*(cvbuf + --l - 1) = '\n'; 	/* strip trailing esc */
		if (nonl) l--; 			/* strip newline */
	}
	REALLOC(cvbuf, cvbufsz, l + 1, NULL);
	cvbuf[l] = '\0';
	*sizep = l;
	return cvbuf;
}


/* get_tty_line: read a line of text from stdin; return line length */
int
get_tty_line(void)
{
	int oi = 0;
	int i = 0;
	int c;

	for (;;)
		switch (c = getchar()) {
		default:
			oi = 0;
			REALLOC(ibuf, ibufsz, i + 2, ERR);
			if (!(ibuf[i++] = c)) isbinary = 1;
			if (c != '\n')
				continue;
			lineno++;
			ibuf[i] = '\0';
			ibufp = ibuf;
			return i;
		case EOF:
			if (ferror(stdin)) {
				perror("stdin");
				seterrmsg("cannot read stdin");
				clearerr(stdin);
				ibufp = NULL;
				return ERR;
			} else {
				clearerr(stdin);
				if (i != oi) {
					oi = i;
					continue;
				} else if (i)
					ibuf[i] = '\0';
				ibufp = ibuf;
				return i;
			}
		}
}



#define ESCAPES "\a\b\f\n\r\t\v\\"
#define ESCCHARS "abfnrtv\\"

extern int rows;
extern int cols;

/* put_tty_line: print text to stdout */
int
put_tty_line(char *s, int l, int n, int gflag)
{
	int col = 0;
#ifndef BACKWARDS
	int lc = 0;
#endif
	char *cp;

	if (gflag & GNP) {
		printf("%d\t", n);
		col = 8;
	}
	for (; l--; s++) {
		if ((gflag & GLS) && ++col > cols) {
			fputs("\\\n", stdout);
			col = 1;
#ifndef BACKWARDS
			if (!scripted && !isglobal && ++lc > rows) {
				lc = 0;
				fputs("Press <RETURN> to continue... ", stdout);
				fflush(stdout);
				if (get_tty_line() < 0)
					return ERR;
			}
#endif
		}
		if (gflag & GLS) {
			if (31 < *s && *s < 127 && *s != '\\')
				putchar(*s);
			else {
				putchar('\\');
				col++;
				if (*s && (cp = strchr(ESCAPES, *s)) != NULL)
					putchar(ESCCHARS[cp - ESCAPES]);
				else {
					putchar((((unsigned char) *s & 0300) >> 6) + '0');
					putchar((((unsigned char) *s & 070) >> 3) + '0');
					putchar(((unsigned char) *s & 07) + '0');
					col += 2;
				}
			}

		} else
			putchar(*s);
	}
#ifndef BACKWARDS
	if (gflag & GLS)
		putchar('$');
#endif
	putchar('\n');
	return 0;
}
@


1.18
log
@Define functions as static when they are not used outside their own c-files.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.17 2015/10/09 19:47:02 millert Exp $	*/
d30 6
@


1.17
log
@Mark static globals that are only used in their respective .c files.
Also make stdin unbuffered since that is the same as using a
single-byte buffer.  OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.16 2014/04/14 22:12:01 tedu Exp $	*/
d33 4
d70 1
a70 1
int
d114 1
a114 1
int
d167 1
a167 1
int
d190 1
a190 1
int
@


1.16
log
@remove nonstandard DES support because DES. ok beck deraadt miod
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.15 2009/10/28 15:40:47 deraadt Exp $	*/
d61 2
a62 2
char *sbuf;			/* file i/o buffer */
int sbufsz;			/* file i/o buffer size */
@


1.15
log
@one more () for halex
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.14 2009/10/28 05:06:17 deraadt Exp $	*/
a60 2
extern int des;

a77 4
#ifdef DES
	if (des)
		init_des_cipher();
#endif
a105 2
	if (des)
		size += 8 - size % 8;			/* adjust DES size */
a108 6
#ifdef DES
#define DESGETCHAR(fp) (des ? get_des_char((fp)) : getc((fp)))
#else
#define DESGETCHAR(fp) (getc((fp)))
#endif

d116 1
a116 1
	while (((c = DESGETCHAR(fp)) != EOF || (!feof(fp) &&
a170 4
#ifdef DES
	if (des)
		init_des_cipher();
#endif
a180 6
#ifdef DES
	if (des) {
		flush_des_file(fp);			/* flush buffer */
		size += 8 - size % 8;			/* adjust DES size */
	}
#endif
a183 6
#ifdef DES
#define DESPUTCHAR(c, fp) (des ? put_des_char((c), (fp)) : fputc((c), (fp)))
#else
#define DESPUTCHAR(c, fp) (fputc((c), (fp)))
#endif

d190 1
a190 1
		if (DESPUTCHAR(*s, fp) < 0) {
@


1.14
log
@the code to support -DDES spread it's way outside of -DDES... fix that
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.13 2009/10/27 23:59:21 deraadt Exp $	*/
d209 1
a209 1
#define DESPUTCHAR(c, fp) (des ? put_des_char(c, (fp)) : fputc((c), (fp)))
@


1.13
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.12 2007/11/06 10:22:29 chl Exp $	*/
d80 1
d83 1
d117 5
d130 1
a130 1
	while (((c = des ? get_des_char(fp) : getc(fp)) != EOF || (!feof(fp) &&
d185 1
d188 1
d199 1
d204 1
d208 6
d219 2
a220 2
	while (len--)
		if ((des ? put_des_char(*s++, fp) : fputc(*s++, fp)) < 0) {
d225 2
@


1.12
log
@fix format string

ok ray@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.11 2003/06/11 23:42:12 deraadt Exp $	*/
a29 8

#ifndef lint
#if 0
static char *rcsid = "@@(#)io.c,v 1.1 1994/02/01 00:34:41 alm Exp";
#else
static char rcsid[] = "$OpenBSD: io.c,v 1.11 2003/06/11 23:42:12 deraadt Exp $";
#endif
#endif /* not lint */
@


1.11
log
@ansification, art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.10 2002/03/24 22:17:04 millert Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: io.c,v 1.10 2002/03/24 22:17:04 millert Exp $";
d64 1
a64 1
	fprintf(stderr, !scripted ? "%lu\n" : "", size);
d172 1
a172 1
	fprintf(stderr, !scripted ? "%lu\n" : "", size);
@


1.10
log
@Kill unneeded longs; fixes some minor 64 bit issues.  deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.9 2002/01/16 18:44:21 mpech Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: io.c,v 1.9 2002/01/16 18:44:21 mpech Exp $";
d46 1
a46 3
read_file(fn, n)
	char *fn;
	int n;
d77 1
a77 3
read_stream(fp, n)
	FILE *fp;
	int n;
d126 1
a126 2
get_stream_line(fp)
	FILE *fp;
d155 1
a155 5
write_file(fn, mode, n, m)
	char *fn;
	char *mode;
	int n;
	int m;
d179 1
a179 4
write_stream(fp, n, m)
	FILE *fp;
	int n;
	int m;
d208 1
a208 4
put_stream_line(fp, s, len)
	FILE *fp;
	char *s;
	int len;
d221 1
a221 3
get_extended_line(sizep, nonl)
	int *sizep;
	int nonl;
d239 2
a240 1
	if (nonl) l--; 			/* strip newline */
d265 1
a265 1
get_tty_line()
d313 1
a313 5
put_tty_line(s, l, n, gflag)
	char *s;
	int l;
	int n;
	int gflag;
@


1.9
log
@missed some registers, kill'em!

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.8 2001/01/16 03:04:45 deraadt Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: io.c,v 1.8 2001/01/16 03:04:45 deraadt Exp $";
d45 1
a45 1
long
d48 1
a48 1
	long n;
d51 1
a51 1
	long size;
d78 1
a78 1
long
d81 1
a81 1
	long n;
d85 1
a85 1
	unsigned long size = 0;
d159 1
a159 1
long
d163 2
a164 2
	long n;
	long m;
d167 1
a167 1
	long size;
d187 1
a187 1
long
d190 2
a191 2
	long n;
	long m;
d194 1
a194 1
	unsigned long size = 0;
d332 1
a332 1
	long n;
d342 1
a342 1
		printf("%ld\t", n);
@


1.8
log
@cleanup strcpy, strncpy, signal races, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.7 1997/02/01 12:03:07 tholo Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: io.c,v 1.7 1997/02/01 12:03:07 tholo Exp $";
d133 2
a134 2
	register int c;
	register int i = 0;
d283 2
a284 2
	register int oi = 0;
	register int i = 0;
@


1.7
log
@Get precedence right
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.6 1996/12/14 12:17:54 mickey Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: io.c,v 1.6 1996/12/14 12:17:54 mickey Exp $";
d57 1
a57 1
		strcpy(errmsg, "cannot open input file");
d63 1
a63 1
		strcpy(errmsg, "cannot close input file");
d147 1
a147 1
		strcpy(errmsg, "cannot read input file");
d172 1
a172 1
		strcpy(errmsg, "cannot open output file");
d178 1
a178 1
		strcpy(errmsg, "cannot close output file");
d228 1
a228 1
			strcpy(errmsg, "cannot write file");
d261 1
a261 1
			strcpy(errmsg, "unexpected end-of-file");
d302 1
a302 1
				strcpy(errmsg, "cannot read stdin");
@


1.6
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.5 1996/12/12 12:37:53 mickey Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: io.c,v 1.5 1996/12/12 12:37:53 mickey Exp $";
d137 1
a137 1
	    !ferror(fp) && c != '\n'))) {
@


1.5
log
@"stdin" is not a stdin! (perror)
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.4 1996/10/12 19:38:36 millert Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: io.c,v 1.4 1996/10/12 19:38:36 millert Exp $";
d114 1
a114 1
	else if (newline_added && (!appended || !isbinary && !o_isbinary))
d136 2
a137 2
	while (((c = des ? get_des_char(fp) : getc(fp)) != EOF || !feof(fp) &&
	    !ferror(fp)) && c != '\n') {
d336 1
d338 1
@


1.4
log
@Back out my sprintf -> snprintf changes where they don't make sense and
use good ole strcpy() instead.  Also use perror() instead of fprintf()
where it makes sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.3 1996/09/15 22:25:56 millert Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: io.c,v 1.3 1996/09/15 22:25:56 millert Exp $";
d301 1
a301 1
				perror(stdin);
@


1.3
log
@sprintf -> snprintf paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.2 1996/06/23 14:20:02 deraadt Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: io.c,v 1.2 1996/06/23 14:20:02 deraadt Exp $";
d56 2
a57 2
		fprintf(stderr, "%s: %s\n", fn, strerror(errno));
		snprintf(errmsg, sizeof(errmsg), "cannot open input file");
d62 2
a63 2
		fprintf(stderr, "%s: %s\n", fn, strerror(errno));
		snprintf(errmsg, sizeof(errmsg), "cannot close input file");
d146 2
a147 2
		fprintf(stderr, "%s\n", strerror(errno));
		snprintf(errmsg, sizeof(errmsg), "cannot read input file");
d171 2
a172 2
		fprintf(stderr, "%s: %s\n", fn, strerror(errno));
		snprintf(errmsg, sizeof(errmsg), "cannot open output file");
d177 2
a178 2
		fprintf(stderr, "%s: %s\n", fn, strerror(errno));
		snprintf(errmsg, sizeof(errmsg), "cannot close output file");
d227 2
a228 2
			fprintf(stderr, "%s\n", strerror(errno));
			snprintf(errmsg, sizeof(errmsg), "cannot write file");
d261 1
a261 1
			snprintf(errmsg, sizeof(errmsg), "unexpected end-of-file");
d301 2
a302 2
				fprintf(stderr, "stdin: %s\n", strerror(errno));
				snprintf(errmsg, sizeof(errmsg), "cannot read stdin");
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.2 1995/03/21 09:04:43 cgd Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: io.c,v 1.2 1995/03/21 09:04:43 cgd Exp $";
d57 1
a57 1
		sprintf(errmsg, "cannot open input file");
d63 1
a63 1
		sprintf(errmsg, "cannot close input file");
d147 1
a147 1
		sprintf(errmsg, "cannot read input file");
d172 1
a172 1
		sprintf(errmsg, "cannot open output file");
d178 1
a178 1
		sprintf(errmsg, "cannot close output file");
d228 1
a228 1
			sprintf(errmsg, "cannot write file");
d261 1
a261 1
			sprintf(errmsg, "unexpected end-of-file");
d302 1
a302 1
				sprintf(errmsg, "cannot read stdin");
@


1.1
log
@Initial revision
@
text
@d1 1
d35 1
a35 1
static char rcsid[] = "$NetBSD: io.c,v 1.2 1995/03/21 09:04:43 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
