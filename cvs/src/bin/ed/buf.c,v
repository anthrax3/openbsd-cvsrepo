head	1.23;
access;
symbols
	OPENBSD_6_0:1.23.0.2
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.22
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.20
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.16
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.10
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.10
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.8
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.6
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.03.22.17.58.28;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	dG9FDzJpMhZLrmQQ;

1.22
date	2015.10.09.19.47.02;	author millert;	state Exp;
branches;
next	1.21;
commitid	z8ymRwVMvCsHkr2w;

1.21
date	2015.07.28.17.46.52;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	g3kCI6mUnNZgOIuA;

1.20
date	2014.11.20.15.22.39;	author tedu;	state Exp;
branches;
next	1.19;
commitid	HIbf8HnT4wFtIrOp;

1.19
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2008.02.12.07.57.29;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.25.15.41.07;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.18.19.15.43;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.07.22.13.43;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.11.23.42.12;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.24.22.17.04;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.16.03.04.45;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.01.17.19.09;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.07.03.06.01.17;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.04.30.05.55.04;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.03.10.17.55.38;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.10.12.19.38.28;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.15.22.25.54;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.06.25.00.26.02;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.24.21.13.50;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.07;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@header cleanup

from Edgar Pettijohn, correction from deraadt@@
@
text
@/*	$OpenBSD: buf.c,v 1.22 2015/10/09 19:47:02 millert Exp $	*/
/*	$NetBSD: buf.c,v 1.15 1995/04/23 10:07:28 cgd Exp $	*/

/* buf.c: This file contains the scratch-file buffer routines for the
   ed line editor. */
/*-
 * Copyright (c) 1993 Andrew Moore, Talke Studio.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <limits.h>
#include <regex.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "ed.h"


static FILE *sfp;			/* scratch file pointer */
static off_t sfseek;			/* scratch file position */
static int seek_write;			/* seek before writing */
static line_t buffer_head;		/* incore buffer */

/* get_sbuf_line: get a line of text from the scratch file; return pointer
   to the text */
char *
get_sbuf_line(line_t *lp)
{
	static char *sfbuf = NULL;	/* buffer */
	static int sfbufsz = 0;		/* buffer size */

	int len, ct;

	if (lp == &buffer_head)
		return NULL;
	seek_write = 1;				/* force seek on write */
	/* out of position */
	if (sfseek != lp->seek) {
		sfseek = lp->seek;
		if (fseeko(sfp, sfseek, SEEK_SET) < 0) {
			perror(NULL);
			seterrmsg("cannot seek temp file");
			return NULL;
		}
	}
	len = lp->len;
	REALLOC(sfbuf, sfbufsz, len + 1, NULL);
	if ((ct = fread(sfbuf, sizeof(char), len, sfp)) <  0 || ct != len) {
		perror(NULL);
		seterrmsg("cannot read temp file");
		return NULL;
	}
	sfseek += len;				/* update file position */
	sfbuf[len] = '\0';
	return sfbuf;
}


/* put_sbuf_line: write a line of text to the scratch file and add a line node
   to the editor buffer;  return a pointer to the end of the text */
char *
put_sbuf_line(char *cs)
{
	line_t *lp;
	int len, ct;
	char *s;

	if ((lp = malloc(sizeof(line_t))) == NULL) {
		perror(NULL);
		seterrmsg("out of memory");
		return NULL;
	}
	/* assert: cs is '\n' terminated */
	for (s = cs; *s != '\n'; s++)
		;
	if (s - cs >= LINECHARS) {
		seterrmsg("line too long");
		free(lp);
		return NULL;
	}
	len = s - cs;
	/* out of position */
	if (seek_write) {
		if (fseek(sfp, 0L, SEEK_END) < 0) {
			perror(NULL);
			seterrmsg("cannot seek temp file");
			free(lp);
			return NULL;
		}
		sfseek = ftello(sfp);
		seek_write = 0;
	}
	/* assert: SPL1() */
	if ((ct = fwrite(cs, sizeof(char), len, sfp)) < 0 || ct != len) {
		sfseek = -1;
		perror(NULL);
		seterrmsg("cannot write temp file");
		free(lp);
		return NULL;
	}
	lp->len = len;
	lp->seek  = sfseek;
	add_line_node(lp);
	sfseek += len;			/* update file position */
	return ++s;
}


/* add_line_node: add a line node in the editor buffer after the current line */
void
add_line_node(line_t *lp)
{
	line_t *cp;

	/* this get_addressed_line_node last! */
	cp = get_addressed_line_node(current_addr);
	INSQUE(lp, cp);
	addr_last++;
	current_addr++;
}


/* get_line_node_addr: return line number of pointer */
int
get_line_node_addr(line_t *lp)
{
	line_t *cp = &buffer_head;
	int n = 0;

	while (cp != lp && (cp = cp->q_forw) != &buffer_head)
		n++;
	if (n && cp == &buffer_head) {
		seterrmsg("invalid address");
		return ERR;
	 }
	 return n;
}


/* get_addressed_line_node: return pointer to a line node in the editor buffer */
line_t *
get_addressed_line_node(int n)
{
	static line_t *lp = &buffer_head;
	static int on = 0;

	SPL1();
	if (n > on) {
		if (n <= (on + addr_last) >> 1)
			for (; on < n; on++)
				lp = lp->q_forw;
		else {
			lp = buffer_head.q_back;
			for (on = addr_last; on > n; on--)
				lp = lp->q_back;
		}
	} else {
		if (n >= on >> 1)
			for (; on > n; on--)
				lp = lp->q_back;
		else {
			lp = &buffer_head;
			for (on = 0; on < n; on++)
				lp = lp->q_forw;
		}
	}
	SPL0();
	return lp;
}


extern int newline_added;

#define SCRATCH_TEMPLATE      "/tmp/ed.XXXXXXXXXX"
static char sfn[sizeof(SCRATCH_TEMPLATE)+1] = "";	/* scratch file name */

/* open_sbuf: open scratch file */
int
open_sbuf(void)
{
	int fd = -1;

	isbinary = newline_added = 0;
	strlcpy(sfn, SCRATCH_TEMPLATE, sizeof sfn);
	if ((fd = mkstemp(sfn)) == -1 ||
	    (sfp = fdopen(fd, "w+")) == NULL) {
		if (fd != -1)
			close(fd);
		perror(sfn);
		seterrmsg("cannot open temp file");
		return ERR;
	}
	return 0;
}


/* close_sbuf: close scratch file */
int
close_sbuf(void)
{
	if (sfp) {
		if (fclose(sfp) < 0) {
			perror(sfn);
			seterrmsg("cannot close temp file");
			return ERR;
		}
		sfp = NULL;
		unlink(sfn);
	}
	sfseek = seek_write = 0;
	return 0;
}


/* quit: remove_lines scratch file and exit */
void
quit(int n)
{
	if (sfp) {
		fclose(sfp);
		unlink(sfn);
	}
	exit(n);
}


static unsigned char ctab[256];		/* character translation table */

/* init_buffers: open scratch buffer; initialize line queue */
void
init_buffers(void)
{
	int i = 0;

	/* Read stdin one character at a time to avoid i/o contention
	   with shell escapes invoked by nonterminal input, e.g.,
	   ed - <<EOF
	   !cat
	   hello, world
	   EOF */
	setvbuf(stdin, NULL, _IONBF, 0);
	if (open_sbuf() < 0)
		quit(2);
	REQUE(&buffer_head, &buffer_head);
	for (i = 0; i < 256; i++)
		ctab[i] = i;
}


/* translit_text: translate characters in a string */
char *
translit_text(char *s, int len, int from, int to)
{
	static int i = 0;

	unsigned char *us;

	ctab[i] = i;			/* restore table to initial state */
	ctab[i = from] = to;
	for (us = (unsigned char *) s; len-- > 0; us++)
		*us = ctab[*us];
	return s;
}
@


1.22
log
@Mark static globals that are only used in their respective .c files.
Also make stdin unbuffered since that is the same as using a
single-byte buffer.  OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.21 2015/07/28 17:46:52 deraadt Exp $	*/
d32 1
d34 8
@


1.21
log
@remove gratuitous casts
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.20 2014/11/20 15:22:39 tedu Exp $	*/
d37 4
a40 4
FILE *sfp;				/* scratch file pointer */
off_t sfseek;				/* scratch file position */
int seek_write;				/* seek before writing */
line_t buffer_head;			/* incore buffer */
d193 1
a193 1
char	sfn[sizeof(SCRATCH_TEMPLATE)+1] = "";	/* scratch file name */
d245 1
a245 1
unsigned char ctab[256];		/* character translation table */
d259 1
a259 1
	setbuffer(stdin, stdinbuf, 1);
@


1.20
log
@remove sys/file.h includes in favor of fcntl.h where needed.
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.19 2009/10/27 23:59:21 deraadt Exp $	*/
d86 1
a86 1
	if ((lp = (line_t *) malloc(sizeof(line_t))) == NULL) {
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.18 2008/02/12 07:57:29 otto Exp $	*/
a31 1
#include <sys/file.h>
@


1.18
log
@use ftello instead of ftell; from Davil Hill; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.17 2006/04/25 15:41:07 deraadt Exp $	*/
a30 8

#ifndef lint
#if 0
static char *rcsid = "@@(#)buf.c,v 1.4 1994/02/01 00:34:35 alm Exp";
#else
static char rcsid[] = "$OpenBSD: buf.c,v 1.17 2006/04/25 15:41:07 deraadt Exp $";
#endif
#endif /* not lint */
@


1.17
log
@various small lint cleanups; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.16 2003/10/18 19:15:43 jmc Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.16 2003/10/18 19:15:43 jmc Exp $";
d117 1
a117 1
		sfseek = ftell(sfp);
@


1.16
log
@typos in comments;
from Jared Yanovich
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.15 2003/08/07 22:13:43 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.15 2003/08/07 22:13:43 millert Exp $";
d67 1
a67 1
		if (fseek(sfp, sfseek, SEEK_SET) < 0) {
@


1.15
log
@plug some obvious memory leaks; Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.14 2003/06/11 23:42:12 deraadt Exp $	*/
d4 1
a4 1
/* buf.c: This file contains the scratch-file buffer rountines for the
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.14 2003/06/11 23:42:12 deraadt Exp $";
@


1.14
log
@ansification, art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.13 2002/06/09 05:47:27 todd Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.13 2002/06/09 05:47:27 todd Exp $";
d105 1
d114 1
d125 1
@


1.13
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.12 2002/03/24 22:17:04 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.12 2002/03/24 22:17:04 millert Exp $";
d54 1
a54 2
get_sbuf_line(lp)
	line_t *lp;
d89 1
a89 2
put_sbuf_line(cs)
	char *cs;
d135 1
a135 2
add_line_node(lp)
	line_t *lp;
d139 2
a140 1
	cp = get_addressed_line_node(current_addr);				/* this get_addressed_line_node last! */
d149 1
a149 2
get_line_node_addr(lp)
	line_t *lp;
d166 1
a166 2
get_addressed_line_node(n)
	int n;
d203 1
a203 1
open_sbuf()
d223 1
a223 1
close_sbuf()
d241 1
a241 2
quit(n)
	int n;
d255 1
a255 1
init_buffers()
d276 1
a276 5
translit_text(s, len, from, to)
	char *s;
	int len;
	int from;
	int to;
@


1.12
log
@Kill unneeded longs; fixes some minor 64 bit issues.  deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.11 2001/01/16 03:04:45 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.11 2001/01/16 03:04:45 deraadt Exp $";
d264 1
a264 1
	/* Read stdin one character at a time to avoid i/o contention 
@


1.11
log
@cleanup strcpy, strncpy, signal races, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.10 2000/04/01 17:19:09 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.10 2000/04/01 17:19:09 deraadt Exp $";
d150 1
a150 1
long
d155 1
a155 1
	long n = 0;
d170 1
a170 1
	long n;
d173 1
a173 1
	static long on = 0;
@


1.10
log
@buf oflow; ath@@algonet.se
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.9 1998/07/03 06:01:17 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.9 1998/07/03 06:01:17 deraadt Exp $";
d70 1
a70 1
			strcpy(errmsg, "cannot seek temp file");
d78 1
a78 1
		strcpy(errmsg, "cannot read temp file");
d99 1
a99 1
		strcpy(errmsg, "out of memory");
d106 1
a106 1
		strcpy(errmsg, "line too long");
d114 1
a114 1
			strcpy(errmsg, "cannot seek temp file");
d124 1
a124 1
		strcpy(errmsg, "cannot write temp file");
d160 1
a160 1
		strcpy(errmsg, "invalid address");
d218 1
a218 1
		strcpy(errmsg, "cannot open temp file");
d232 1
a232 1
			strcpy(errmsg, "cannot close temp file");
@


1.9
log
@use 10 X in mkstemp string for improved speed at race winning
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.8 1998/04/30 05:55:04 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.8 1998/04/30 05:55:04 deraadt Exp $";
d202 2
a203 1
char sfn[15] = "";				/* scratch file name */
d212 1
a212 1
	strcpy(sfn, "/tmp/ed.XXXXXXXXXX");
@


1.8
log
@Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.7 1998/03/10 17:55:38 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.7 1998/03/10 17:55:38 deraadt Exp $";
d211 1
a211 1
	strcpy(sfn, "/tmp/ed.XXXXXX");
@


1.7
log
@umask manipulation not neccessary
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.6 1996/10/12 19:38:28 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.6 1996/10/12 19:38:28 millert Exp $";
d176 1
a176 1
	if (n > on)
d185 1
a185 1
	else
d194 1
@


1.6
log
@Back out my sprintf -> snprintf changes where they don't make sense and
use good ole strcpy() instead.  Also use perror() instead of fprintf()
where it makes sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.5 1996/09/15 22:25:54 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.5 1996/09/15 22:25:54 millert Exp $";
a206 1
	int u;
a209 1
	u = umask(077);
a216 1
		umask(u);
a218 1
	umask(u);
@


1.5
log
@sprintf -> snprintf paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.4 1996/06/25 00:26:02 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.4 1996/06/25 00:26:02 deraadt Exp $";
d69 2
a70 2
			fprintf(stderr, "%s\n", strerror(errno));
			snprintf(errmsg, sizeof(errmsg), "cannot seek temp file");
d77 2
a78 2
		fprintf(stderr, "%s\n", strerror(errno));
		snprintf(errmsg, sizeof(errmsg), "cannot read temp file");
d98 2
a99 2
		fprintf(stderr, "%s\n", strerror(errno));
		snprintf(errmsg, sizeof(errmsg), "out of memory");
d106 1
a106 1
		snprintf(errmsg, sizeof(errmsg), "line too long");
d113 2
a114 2
			fprintf(stderr, "%s\n", strerror(errno));
			snprintf(errmsg, sizeof(errmsg), "cannot seek temp file");
d123 2
a124 2
		fprintf(stderr, "%s\n", strerror(errno));
		snprintf(errmsg, sizeof(errmsg), "cannot write temp file");
d160 1
a160 1
		snprintf(errmsg, sizeof(errmsg), "invalid address");
d217 2
a218 2
		fprintf(stderr, "%s: %s\n", sfn, strerror(errno));
		snprintf(errmsg, sizeof(errmsg), "cannot open temp file");
d233 2
a234 2
			fprintf(stderr, "%s: %s\n", sfn, strerror(errno));
			snprintf(errmsg, sizeof(errmsg), "cannot close temp file");
@


1.4
log
@mkstemp
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.3 1996/06/24 21:13:50 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.3 1996/06/24 21:13:50 deraadt Exp $";
d70 1
a70 1
			sprintf(errmsg, "cannot seek temp file");
d78 1
a78 1
		sprintf(errmsg, "cannot read temp file");
d99 1
a99 1
		sprintf(errmsg, "out of memory");
d106 1
a106 1
		sprintf(errmsg, "line too long");
d114 1
a114 1
			sprintf(errmsg, "cannot seek temp file");
d124 1
a124 1
		sprintf(errmsg, "cannot write temp file");
d160 1
a160 1
		sprintf(errmsg, "invalid address");
d218 1
a218 1
		sprintf(errmsg, "cannot open temp file");
d234 1
a234 1
			sprintf(errmsg, "cannot close temp file");
@


1.3
log
@use temp file more carefully
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.2 1996/06/23 14:19:58 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.2 1996/06/23 14:19:58 deraadt Exp $";
d213 1
a213 2
	if (mktemp(sfn) == NULL ||
	    (fd = open(sfn, O_RDWR|O_CREAT|O_EXCL, 0666)) == -1 ||
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.15 1995/04/23 10:07:28 cgd Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: buf.c,v 1.15 1995/04/23 10:07:28 cgd Exp $";
d208 1
d213 5
a217 1
	if (mktemp(sfn) == NULL || (sfp = fopen(sfn, "w+")) == NULL) {
@


1.1
log
@Initial revision
@
text
@d1 1
d36 1
a36 1
static char rcsid[] = "$NetBSD: buf.c,v 1.15 1995/04/23 10:07:28 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

