head	1.60;
access;
symbols
	OPENBSD_6_2:1.60.0.2
	OPENBSD_6_2_BASE:1.60
	OPENBSD_6_1:1.59.0.4
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.57.0.2
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.35.0.4
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.2
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.34.0.8
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.6
	OPENBSD_5_0:1.34.0.4
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.6
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.2
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.30.0.8
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.6
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.4
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.28.0.12
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.10
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.8
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.6
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.28.0.4
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.27.0.4
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_8:1.19.0.4
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	OPENBSD_2_6:1.14.0.6
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.13.0.4
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.60
date	2017.04.26.21.25.43;	author naddy;	state Exp;
branches;
next	1.59;
commitid	WHn0y7VnaSVIug1C;

1.59
date	2017.01.03.20.24.29;	author tb;	state Exp;
branches;
next	1.58;
commitid	26cmjGilqU4c7rEC;

1.58
date	2016.08.16.20.04.46;	author natano;	state Exp;
branches;
next	1.57;
commitid	aKdFQGpWSPNmzbOr;

1.57
date	2016.03.22.17.58.28;	author mmcc;	state Exp;
branches;
next	1.56;
commitid	dG9FDzJpMhZLrmQQ;

1.56
date	2015.11.20.08.53.28;	author tb;	state Exp;
branches;
next	1.55;
commitid	1QcVlhpVnahoxjiN;

1.55
date	2015.10.25.03.40.58;	author guenther;	state Exp;
branches;
next	1.54;
commitid	4N2zZqdsRkq1qxZv;

1.54
date	2015.10.21.16.06.57;	author millert;	state Exp;
branches;
next	1.53;
commitid	s2DZTdNXdq9anJGE;

1.53
date	2015.10.09.21.24.05;	author tobias;	state Exp;
branches;
next	1.52;
commitid	lMLGwZnIoP49Tk0o;

1.52
date	2015.10.09.20.27.28;	author tobias;	state Exp;
branches;
next	1.51;
commitid	75UxTlTgsWoFG3EU;

1.51
date	2015.10.09.19.47.02;	author millert;	state Exp;
branches;
next	1.50;
commitid	z8ymRwVMvCsHkr2w;

1.50
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	sbrB3Q5CNxcwZpfU;

1.49
date	2015.10.07.05.37.42;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	zAaECBce8wvjeYMd;

1.48
date	2015.10.04.15.23.24;	author millert;	state Exp;
branches;
next	1.47;
commitid	DzhpkCptJKskzdTA;

1.47
date	2015.10.04.15.03.24;	author millert;	state Exp;
branches;
next	1.46;
commitid	bSiRNka8EjZW40u3;

1.46
date	2015.07.28.17.46.52;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	g3kCI6mUnNZgOIuA;

1.45
date	2015.07.14.19.16.33;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	GMOLaDTE4ZEs4fp9;

1.44
date	2015.07.11.16.33.48;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	hNESzpuPkMScppvv;

1.43
date	2015.01.16.06.39.32;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	Uu5nFG3wCl0LACBb;

1.42
date	2014.12.04.08.34.04;	author daniel;	state Exp;
branches;
next	1.41;
commitid	nrcmWcWH0d6W0BKK;

1.41
date	2014.11.26.18.34.51;	author millert;	state Exp;
branches;
next	1.40;
commitid	9QOFSShUOtA0kQLF;

1.40
date	2014.07.12.02.47.51;	author guenther;	state Exp;
branches;
next	1.39;
commitid	GhhP8tY8naZgXxKf;

1.39
date	2014.05.24.01.35.55;	author daniel;	state Exp;
branches;
next	1.38;

1.38
date	2014.04.14.23.19.51;	author jmc;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.14.22.12.01;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2013.11.21.15.54.45;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2013.01.15.20.26.28;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2010.08.12.02.00.28;	author kevlo;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.28.22.17.30;	author sobrado;	state Exp;
branches;
next	1.31;

1.31
date	2008.04.21.11.22.14;	author tobias;	state Exp;
branches;
next	1.30;

1.30
date	2006.04.25.15.41.07;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.17.16.17.03;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.11.23.42.12;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.24.22.17.04;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.16.01.28.54;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.17.19.54.56;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.11.07.36.40;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.22.23.53.53;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.17.19.19.31;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.16.03.04.45;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2000.05.01.18.30.52;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.01.17.20.10;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.22.20.24.49;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.12.05.02.37.55;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.12.04.23.45.36;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	98.05.18.20.36.14;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.09.12.04.35.18;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.09.01.18.29.30;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.08.05.22.22.55;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.07.23.14.42.33;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.07.08.19.30.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.08.18.56.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.08.17.36.43;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.40.23;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.12.17.56;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.12.19.38.38;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.15.22.25.57;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.20.02;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.07;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.60
log
@silence clang warnings: add an extra pair of parentheses and stop
passing empty format strings to printf-family functions; ok millert@@
@
text
@/*	$OpenBSD: main.c,v 1.59 2017/01/03 20:24:29 tb Exp $	*/
/*	$NetBSD: main.c,v 1.3 1995/03/21 09:04:44 cgd Exp $	*/

/* main.c: This file contains the main control and user-interface routines
   for the ed line editor. */
/*-
 * Copyright (c) 1993 Andrew Moore, Talke Studio.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * CREDITS
 *
 *	This program is based on the editor algorithm described in
 *	Brian W. Kernighan and P. J. Plauger's book "Software Tools
 *	in Pascal," Addison-Wesley, 1981.
 *
 *	The buffering algorithm is attributed to Rodney Ruddock of
 *	the University of Guelph, Guelph, Ontario.
 *
 */

#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/wait.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <pwd.h>
#include <regex.h>
#include <setjmp.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ed.h"

void signal_hup(int);
void signal_int(int);
void handle_winch(int);

static int next_addr(void);
static int check_addr_range(int, int);
static int get_matching_node_addr(regex_t *, int);
static char *get_filename(void);
static int get_shell_command(void);
static int append_lines(int);
static int join_lines(int, int);
static int move_lines(int);
static int copy_lines(int);
static int mark_line_node(line_t *, int);
static int get_marked_node_addr(int);
static line_t *dup_line_node(line_t *);

sigjmp_buf env;

/* static buffers */
static char errmsg[PATH_MAX + 40];	/* error message buffer */
static char *shcmd;		/* shell command buffer */
static int shcmdsz;		/* shell command buffer size */
static int shcmdi;		/* shell command buffer index */
static char old_filename[PATH_MAX];	/* default filename */

/* global buffers */
char *ibuf;			/* ed command-line buffer */
int ibufsz;			/* ed command-line buffer size */
char *ibufp;			/* pointer to ed command-line buffer */

/* global flags */
int garrulous = 0;		/* if set, print all error messages */
int isbinary;			/* if set, buffer contains ASCII NULs */
int isglobal;			/* if set, doing a global command */
int modified;			/* if set, buffer modified since last write */
int scripted = 0;		/* if set, suppress diagnostics */
int interactive = 0;		/* if set, we are in interactive mode */

volatile sig_atomic_t mutex = 0;  /* if set, signals set flags */
volatile sig_atomic_t sighup = 0; /* if set, sighup received while mutex set */
volatile sig_atomic_t sigint = 0; /* if set, sigint received while mutex set */

/* if set, signal handlers are enabled */
volatile sig_atomic_t sigactive = 0;

int current_addr;		/* current address in editor buffer */
int addr_last;			/* last address in editor buffer */
int lineno;			/* script line number */
static char *prompt;		/* command-line prompt */
static char *dps = "*";		/* default command-line prompt */

static const char usage[] = "usage: %s [-] [-s] [-p string] [file]\n";

static char *home;		/* home directory */

void
seterrmsg(char *s)
{
	strlcpy(errmsg, s, sizeof(errmsg));
}

/* ed: line editor */
int
main(volatile int argc, char ** volatile argv)
{
	int c, n;
	int status = 0;

	if (pledge("stdio rpath wpath cpath proc exec tty", NULL) == -1)
		err(1, "pledge");

	home = getenv("HOME");

top:
	while ((c = getopt(argc, argv, "p:sx")) != -1)
		switch (c) {
		case 'p':				/* set prompt */
			dps = prompt = optarg;
			break;
		case 's':				/* run script */
			scripted = 1;
			break;
		case 'x':				/* use crypt */
			fprintf(stderr, "crypt unavailable\n?\n");
			break;
		default:
			fprintf(stderr, usage, argv[0]);
			exit(1);
		}
	argv += optind;
	argc -= optind;
	if (argc && **argv == '-') {
		scripted = 1;
		if (argc > 1) {
			optind = 1;
			goto top;
		}
		argv++;
		argc--;
	}

	if (!(interactive = isatty(0))) {
		struct stat sb;

		/* assert: pipes show up as fifo's when fstat'd */
		if (fstat(STDIN_FILENO, &sb) || !S_ISFIFO(sb.st_mode)) {
			if (lseek(STDIN_FILENO, 0, SEEK_CUR)) {
				interactive = 1;
				setvbuf(stdout, NULL, _IOLBF, 0);
			}
		}
	}

	/* assert: reliable signals! */
	if (isatty(STDIN_FILENO)) {
		handle_winch(SIGWINCH);
		signal(SIGWINCH, handle_winch);
	}
	signal(SIGHUP, signal_hup);
	signal(SIGQUIT, SIG_IGN);
	signal(SIGINT, signal_int);
	if (sigsetjmp(env, 1)) {
		status = -1;
		fputs("\n?\n", stderr);
		seterrmsg("interrupt");
	} else {
		init_buffers();
		sigactive = 1;			/* enable signal handlers */
		if (argc && **argv) {
			if (read_file(*argv, 0) < 0 && !interactive)
				quit(2);
			else if (**argv != '!')
				strlcpy(old_filename, *argv,
				    sizeof old_filename);
		} else if (argc) {
			fputs("?\n", stderr);
			if (**argv == '\0')
				seterrmsg("invalid filename");
			if (!interactive)
				quit(2);
		}
	}
	for (;;) {
		if (status < 0 && garrulous)
			fprintf(stderr, "%s\n", errmsg);
		if (prompt) {
			fputs(prompt, stdout);
			fflush(stdout);
		}
		if ((n = get_tty_line()) < 0) {
			status = ERR;
			continue;
		} else if (n == 0) {
			if (modified && !scripted) {
				fputs("?\n", stderr);
				seterrmsg("warning: file modified");
				if (!interactive) {
					if (garrulous)
						fprintf(stderr,
						    "script, line %d: %s\n",
						    lineno, errmsg);
					quit(2);
				}
				clearerr(stdin);
				modified = 0;
				status = EMOD;
				continue;
			} else
				quit(0);
		} else if (ibuf[n - 1] != '\n') {
			/* discard line */
			seterrmsg("unexpected end-of-file");
			clearerr(stdin);
			status = ERR;
			continue;
		}
		isglobal = 0;
		if ((status = extract_addr_range()) >= 0 &&
		    (status = exec_command()) >= 0)
			if (!status || (status &&
			    (status = display_lines(current_addr, current_addr,
				status)) >= 0))
				continue;
		switch (status) {
		case EOF:
			quit(0);
			break;
		case EMOD:
			modified = 0;
			fputs("?\n", stderr);		/* give warning */
			seterrmsg("warning: file modified");
			if (!interactive) {
				if (garrulous)
					fprintf(stderr,
					    "script, line %d: %s\n",
					    lineno, errmsg);
				quit(2);
			}
			break;
		case FATAL:
			if (!interactive) {
				if (garrulous)
					fprintf(stderr,
					    "script, line %d: %s\n",
					    lineno, errmsg);
			} else if (garrulous)
				fprintf(stderr, "%s\n", errmsg);
			quit(3);
			break;
		default:
			fputs("?\n", stderr);
			if (!interactive) {
				if (garrulous)
					fprintf(stderr,
					    "script, line %d: %s\n",
					    lineno, errmsg);
				quit(2);
			}
			break;
		}
	}
	/*NOTREACHED*/
}

int first_addr, second_addr, addr_cnt;

/* extract_addr_range: get line addresses from the command buffer until an
   illegal address is seen; return status */
int
extract_addr_range(void)
{
	int addr;

	addr_cnt = 0;
	first_addr = second_addr = current_addr;
	while ((addr = next_addr()) >= 0) {
		addr_cnt++;
		first_addr = second_addr;
		second_addr = addr;
		if (*ibufp != ',' && *ibufp != ';')
			break;
		else if (*ibufp++ == ';')
			current_addr = addr;
	}
	if ((addr_cnt = min(addr_cnt, 2)) == 1 || second_addr != addr)
		first_addr = second_addr;
	return (addr == ERR) ? ERR : 0;
}


#define	SKIP_BLANKS() \
	do { \
		while (isspace((unsigned char)*ibufp) && *ibufp != '\n') \
			ibufp++; \
	} while (0)

#define MUST_BE_FIRST() \
	do { \
		if (!first) { \
			seterrmsg("invalid address"); \
			return ERR; \
		} \
	} while (0)
	

/*  next_addr: return the next line address in the command buffer */
static int
next_addr(void)
{
	char *hd;
	int addr = current_addr;
	int n;
	int first = 1;
	int c;

	SKIP_BLANKS();
	for (hd = ibufp;; first = 0)
		switch ((c = (unsigned char)*ibufp)) {
		case '+':
		case '\t':
		case ' ':
		case '-':
		case '^':
			ibufp++;
			SKIP_BLANKS();
			if (isdigit((unsigned char)*ibufp)) {
				STRTOI(n, ibufp);
				addr += (c == '-' || c == '^') ? -n : n;
			} else if (!isspace(c))
				addr += (c == '-' || c == '^') ? -1 : 1;
			break;
		case '0': case '1': case '2':
		case '3': case '4': case '5':
		case '6': case '7': case '8': case '9':
			MUST_BE_FIRST();
			STRTOI(addr, ibufp);
			break;
		case '.':
		case '$':
			MUST_BE_FIRST();
			ibufp++;
			addr = (c == '.') ? current_addr : addr_last;
			break;
		case '/':
		case '?':
			MUST_BE_FIRST();
			if ((addr = get_matching_node_addr(
			    get_compiled_pattern(), c == '/')) < 0)
				return ERR;
			else if (c == *ibufp)
				ibufp++;
			break;
		case '\'':
			MUST_BE_FIRST();
			ibufp++;
			if ((addr = get_marked_node_addr((unsigned char)*ibufp++)) < 0)
				return ERR;
			break;
		case '%':
		case ',':
		case ';':
			if (first) {
				ibufp++;
				addr_cnt++;
				second_addr = (c == ';') ? current_addr : 1;
				if ((addr = next_addr()) < 0)
					addr = addr_last;
				break;
			}
			/* FALLTHROUGH */
		default:
			if (ibufp == hd)
				return EOF;
			else if (addr < 0 || addr_last < addr) {
				seterrmsg("invalid address");
				return ERR;
			} else
				return addr;
		}
	/* NOTREACHED */
}


#ifdef BACKWARDS
/* GET_THIRD_ADDR: get a legal address from the command buffer */
#define GET_THIRD_ADDR(addr) \
	do { \
		int ol1, ol2; \
		\
		ol1 = first_addr; \
		ol2 = second_addr; \
		if (extract_addr_range() < 0) \
			return ERR; \
		else if (addr_cnt == 0) { \
			seterrmsg("destination expected"); \
			return ERR; \
		} else if (second_addr < 0 || addr_last < second_addr) { \
			seterrmsg("invalid address"); \
			return ERR; \
		} \
		addr = second_addr; \
		first_addr = ol1; \
		second_addr = ol2; \
	} while (0)

#else	/* BACKWARDS */
/* GET_THIRD_ADDR: get a legal address from the command buffer */
#define GET_THIRD_ADDR(addr) \
	do { \
		int ol1, ol2; \
		\
		ol1 = first_addr; \
		ol2 = second_addr; \
		if (extract_addr_range() < 0) \
			return ERR; \
		if (second_addr < 0 || addr_last < second_addr) { \
			seterrmsg("invalid address"); \
			return ERR; \
		} \
		addr = second_addr; \
		first_addr = ol1; \
		second_addr = ol2; \
	} while (0)
#endif


/* GET_COMMAND_SUFFIX: verify the command suffix in the command buffer */
#define GET_COMMAND_SUFFIX() \
	do { \
		int done = 0; \
		do { \
			switch (*ibufp) { \
			case 'p': \
				gflag |= GPR; \
				ibufp++; \
				break; \
			case 'l': \
				gflag |= GLS; \
				ibufp++; \
				break; \
			case 'n': \
				gflag |= GNP; \
				ibufp++; \
				break; \
			default: \
				done++; \
			} \
		} while (!done); \
		if (*ibufp++ != '\n') { \
			seterrmsg("invalid command suffix"); \
			return ERR; \
		} \
	} while (0)

/* sflags */
#define SGG 001		/* complement previous global substitute suffix */
#define SGP 002		/* complement previous print suffix */
#define SGR 004		/* use last regex instead of last pat */
#define SGF 010		/* repeat last substitution */

int patlock = 0;	/* if set, pattern not freed by get_compiled_pattern() */

volatile sig_atomic_t rows = 22;	/* scroll length: ws_row - 2 */
volatile sig_atomic_t cols = 72;	/* wrap column */

/* exec_command: execute the next command in command buffer; return print
   request, if any */
int
exec_command(void)
{
	extern int u_current_addr;
	extern int u_addr_last;

	static regex_t *pat = NULL;
	static int sgflag = 0;
	static int sgnum = 0;

	regex_t *tpat;
	char *fnp;
	int gflag = 0;
	int sflags = 0;
	int addr = 0;
	int n = 0;
	int c;

	SKIP_BLANKS();
	switch ((c = (unsigned char)*ibufp++)) {
	case 'a':
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (append_lines(second_addr) < 0)
			return ERR;
		break;
	case 'c':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (delete_lines(first_addr, second_addr) < 0 ||
		    append_lines(current_addr) < 0)
			return ERR;
		break;
	case 'd':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (delete_lines(first_addr, second_addr) < 0)
			return ERR;
		else if ((addr = INC_MOD(current_addr, addr_last)) != 0)
			current_addr = addr;
		break;
	case 'e':
		if (modified && !scripted)
			return EMOD;
		/* FALLTHROUGH */
	case 'E':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		} else if (!isspace((unsigned char)*ibufp)) {
			seterrmsg("unexpected command suffix");
			return ERR;
		} else if ((fnp = get_filename()) == NULL)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (delete_lines(1, addr_last) < 0)
			return ERR;
		clear_undo_stack();
		if (close_sbuf() < 0)
			return ERR;
		else if (open_sbuf() < 0)
			return FATAL;
		if (*fnp && *fnp != '!')
			strlcpy(old_filename, fnp, sizeof old_filename);
#ifdef BACKWARDS
		if (*fnp == '\0' && *old_filename == '\0') {
			seterrmsg("no current filename");
			return ERR;
		}
#endif
		if (read_file(*fnp ? fnp : old_filename, 0) < 0)
			return ERR;
		clear_undo_stack();
		modified = 0;
		u_current_addr = u_addr_last = -1;
		break;
	case 'f':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		} else if (!isspace((unsigned char)*ibufp)) {
			seterrmsg("unexpected command suffix");
			return ERR;
		} else if ((fnp = get_filename()) == NULL)
			return ERR;
		else if (*fnp == '!') {
			seterrmsg("invalid redirection");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (*fnp)
			strlcpy(old_filename, fnp, sizeof old_filename);
		puts(strip_escapes(old_filename));
		break;
	case 'g':
	case 'v':
	case 'G':
	case 'V':
		if (isglobal) {
			seterrmsg("cannot nest global commands");
			return ERR;
		} else if (check_addr_range(1, addr_last) < 0)
			return ERR;
		else if (build_active_list(c == 'g' || c == 'G') < 0)
			return ERR;
		else if ((n = (c == 'G' || c == 'V')))
			GET_COMMAND_SUFFIX();
		isglobal++;
		if (exec_global(n, gflag) < 0)
			return ERR;
		break;
	case 'h':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (*errmsg) fprintf(stderr, "%s\n", errmsg);
		break;
	case 'H':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if ((garrulous = 1 - garrulous) && *errmsg)
			fprintf(stderr, "%s\n", errmsg);
		break;
	case 'i':
		if (second_addr == 0) {
			second_addr = 1;
		}
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (append_lines(second_addr - 1) < 0)
			return ERR;
		break;
	case 'j':
		if (check_addr_range(current_addr, current_addr + 1) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (first_addr != second_addr &&
		    join_lines(first_addr, second_addr) < 0)
			return ERR;
		break;
	case 'k':
		c = (unsigned char)*ibufp++;
		if (second_addr == 0) {
			seterrmsg("invalid address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (mark_line_node(get_addressed_line_node(second_addr), c) < 0)
			return ERR;
		break;
	case 'l':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (display_lines(first_addr, second_addr, gflag | GLS) < 0)
			return ERR;
		gflag = 0;
		break;
	case 'm':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_THIRD_ADDR(addr);
		if (first_addr <= addr && addr < second_addr) {
			seterrmsg("invalid destination");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (move_lines(addr) < 0)
			return ERR;
		break;
	case 'n':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (display_lines(first_addr, second_addr, gflag | GNP) < 0)
			return ERR;
		gflag = 0;
		break;
	case 'p':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (display_lines(first_addr, second_addr, gflag | GPR) < 0)
			return ERR;
		gflag = 0;
		break;
	case 'P':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		prompt = prompt ? NULL : optarg ? optarg : dps;
		break;
	case 'q':
	case 'Q':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		gflag =  (modified && !scripted && c == 'q') ? EMOD : EOF;
		break;
	case 'r':
		if (!isspace((unsigned char)*ibufp)) {
			seterrmsg("unexpected command suffix");
			return ERR;
		} else if (addr_cnt == 0)
			second_addr = addr_last;
		if ((fnp = get_filename()) == NULL)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (*old_filename == '\0' && *fnp != '!')
			strlcpy(old_filename, fnp, sizeof old_filename);
#ifdef BACKWARDS
		if (*fnp == '\0' && *old_filename == '\0') {
			seterrmsg("no current filename");
			return ERR;
		}
#endif
		if ((addr = read_file(*fnp ? fnp : old_filename,
		    second_addr)) < 0)
			return ERR;
		else if (addr && addr != addr_last)
			modified = 1;
		break;
	case 's':
		do {
			switch (*ibufp) {
			case '\n':
				sflags |=SGF;
				break;
			case 'g':
				sflags |= SGG;
				ibufp++;
				break;
			case 'p':
				sflags |= SGP;
				ibufp++;
				break;
			case 'r':
				sflags |= SGR;
				ibufp++;
				break;
			case '0': case '1': case '2': case '3': case '4':
			case '5': case '6': case '7': case '8': case '9':
				STRTOI(sgnum, ibufp);
				sflags |= SGF;
				sgflag &= ~GSG;		/* override GSG */
				break;
			default:
				if (sflags) {
					seterrmsg("invalid command suffix");
					return ERR;
				}
			}
		} while (sflags && *ibufp != '\n');
		if (sflags && !pat) {
			seterrmsg("no previous substitution");
			return ERR;
		} else if (sflags & SGG)
			sgnum = 0;		/* override numeric arg */
		if (*ibufp != '\n' && *(ibufp + 1) == '\n') {
			seterrmsg("invalid pattern delimiter");
			return ERR;
		}
		tpat = pat;
		SPL1();
		if ((!sflags || (sflags & SGR)) &&
		    (tpat = get_compiled_pattern()) == NULL) {
		 	SPL0();
			return ERR;
		} else if (tpat != pat) {
			if (pat) {
				regfree(pat);
				free(pat);
			}
			pat = tpat;
			patlock = 1;		/* reserve pattern */
		}
		SPL0();
		if (!sflags && extract_subst_tail(&sgflag, &sgnum) < 0)
			return ERR;
		else if (isglobal)
			sgflag |= GLB;
		else
			sgflag &= ~GLB;
		if (sflags & SGG)
			sgflag ^= GSG;
		if (sflags & SGP) {
			sgflag ^= GPR;
			sgflag &= ~(GLS | GNP);
		}
		do {
			switch (*ibufp) {
			case 'p':
				sgflag |= GPR;
				ibufp++;
				break;
			case 'l':
				sgflag |= GLS;
				ibufp++;
				break;
			case 'n':
				sgflag |= GNP;
				ibufp++;
				break;
			default:
				n++;
			}
		} while (!n);
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (search_and_replace(pat, sgflag, sgnum) < 0)
			return ERR;
		break;
	case 't':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_THIRD_ADDR(addr);
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (copy_lines(addr) < 0)
			return ERR;
		break;
	case 'u':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (pop_undo_stack() < 0)
			return ERR;
		break;
	case 'w':
	case 'W':
		if ((n = *ibufp) == 'q' || n == 'Q') {
			gflag = EOF;
			ibufp++;
		}
		if (!isspace((unsigned char)*ibufp)) {
			seterrmsg("unexpected command suffix");
			return ERR;
		} else if ((fnp = get_filename()) == NULL)
			return ERR;
		if (addr_cnt == 0 && !addr_last)
			first_addr = second_addr = 0;
		else if (check_addr_range(1, addr_last) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (*old_filename == '\0' && *fnp != '!')
			strlcpy(old_filename, fnp, sizeof old_filename);
#ifdef BACKWARDS
		if (*fnp == '\0' && *old_filename == '\0') {
			seterrmsg("no current filename");
			return ERR;
		}
#endif
		if ((addr = write_file(*fnp ? fnp : old_filename,
		    (c == 'W') ? "a" : "w", first_addr, second_addr)) < 0)
			return ERR;
		else if (addr == addr_last && *fnp != '!')
			modified = 0;
		else if (modified && !scripted && n == 'q')
			gflag = EMOD;
		break;
	case 'x':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		seterrmsg("crypt unavailable");
		return ERR;
	case 'z':
		first_addr = 1;
#ifdef BACKWARDS
		if (check_addr_range(first_addr, current_addr + 1) < 0)
#else
		if (check_addr_range(first_addr, current_addr + !isglobal) < 0)
#endif
			return ERR;
		else if ('0' < *ibufp && *ibufp <= '9')
			STRTOI(rows, ibufp);
		GET_COMMAND_SUFFIX();
		if (display_lines(second_addr, min(addr_last,
		    second_addr + rows), gflag) < 0)
			return ERR;
		gflag = 0;
		break;
	case '=':
		GET_COMMAND_SUFFIX();
		printf("%d\n", addr_cnt ? second_addr : addr_last);
		break;
	case '!':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		} else if ((sflags = get_shell_command()) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (sflags) printf("%s\n", shcmd + 1);
		system(shcmd + 1);
		if (!scripted) printf("!\n");
		break;
	case '\n':
		first_addr = 1;
#ifdef BACKWARDS
		if (check_addr_range(first_addr, current_addr + 1) < 0
#else
		if (check_addr_range(first_addr, current_addr + !isglobal) < 0
#endif
		 || display_lines(second_addr, second_addr, 0) < 0)
			return ERR;
		break;
	default:
		seterrmsg("unknown command");
		return ERR;
	}
	return gflag;
}


/* check_addr_range: return status of address range check */
static int
check_addr_range(int n, int m)
{
	if (addr_cnt == 0) {
		first_addr = n;
		second_addr = m;
	}
	if (first_addr > second_addr || 1 > first_addr ||
	    second_addr > addr_last) {
		seterrmsg("invalid address");
		return ERR;
	}
	return 0;
}


/* get_matching_node_addr: return the address of the next line matching a
   pattern in a given direction.  wrap around begin/end of editor buffer if
   necessary */
static int
get_matching_node_addr(regex_t *pat, int dir)
{
	char *s;
	int n = current_addr;
	line_t *lp;

	if (!pat) return ERR;
	do {
		if ((n = dir ? INC_MOD(n, addr_last) : DEC_MOD(n, addr_last))) {
			lp = get_addressed_line_node(n);
			if ((s = get_sbuf_line(lp)) == NULL)
				return ERR;
			if (isbinary)
				NUL_TO_NEWLINE(s, lp->len);
			if (!regexec(pat, s, 0, NULL, 0))
				return n;
		}
	} while (n != current_addr);
	seterrmsg("no match");
	return  ERR;
}


/* get_filename: return pointer to copy of filename in the command buffer */
static char *
get_filename(void)
{
	static char *file = NULL;
	static int filesz = 0;
	int n;

	if (*ibufp != '\n') {
		SKIP_BLANKS();
		if (*ibufp == '\n') {
			seterrmsg("invalid filename");
			return NULL;
		} else if ((ibufp = get_extended_line(&n, 1)) == NULL)
			return NULL;
		else if (*ibufp == '!') {
			ibufp++;
			if ((n = get_shell_command()) < 0)
				return NULL;
			if (n) printf("%s\n", shcmd + 1);
			return shcmd;
		} else if (n >= PATH_MAX) {
			seterrmsg("filename too long");
			return  NULL;
		}
	}
#ifndef BACKWARDS
	else if (*old_filename == '\0') {
		seterrmsg("no current filename");
		return  NULL;
	}
#endif
	REALLOC(file, filesz, PATH_MAX, NULL);
	for (n = 0; *ibufp != '\n';)
		file[n++] = *ibufp++;
	file[n] = '\0';
	return file;
}


/* get_shell_command: read a shell command from stdin; return substitution
   status */
static int
get_shell_command(void)
{
	static char *buf = NULL;
	static int n = 0;

	char *s;			/* substitution char pointer */
	int i = 0;
	int j = 0;

	if ((s = ibufp = get_extended_line(&j, 1)) == NULL)
		return ERR;
	REALLOC(buf, n, j + 1, ERR);
	buf[i++] = '!';			/* prefix command w/ bang */
	while (*ibufp != '\n')
		switch (*ibufp) {
		default:
			REALLOC(buf, n, i + 2, ERR);
			buf[i++] = *ibufp;
			if (*ibufp++ == '\\')
				buf[i++] = *ibufp++;
			break;
		case '!':
			if (s != ibufp) {
				REALLOC(buf, n, i + 1, ERR);
				buf[i++] = *ibufp++;
			}
#ifdef BACKWARDS
			else if (shcmd == NULL || *(shcmd + 1) == '\0')
#else
			else if (shcmd == NULL)
#endif
			{
				seterrmsg("no previous command");
				return ERR;
			} else {
				REALLOC(buf, n, i + shcmdi, ERR);
				for (s = shcmd + 1; s < shcmd + shcmdi;)
					buf[i++] = *s++;
				s = ibufp++;
			}
			break;
		case '%':
			if (*old_filename  == '\0') {
				seterrmsg("no current filename");
				return ERR;
			}
			j = strlen(s = strip_escapes(old_filename));
			REALLOC(buf, n, i + j, ERR);
			while (j--)
				buf[i++] = *s++;
			s = ibufp++;
			break;
		}
	REALLOC(shcmd, shcmdsz, i + 1, ERR);
	memcpy(shcmd, buf, i);
	shcmd[shcmdi = i] = '\0';
	return *s == '!' || *s == '%';
}


/* append_lines: insert text from stdin to after line n; stop when either a
   single period is read or EOF; return status */
static int
append_lines(int n)
{
	int l;
	char *lp = ibuf;
	char *eot;
	undo_t *up = NULL;

	for (current_addr = n;;) {
		if (!isglobal) {
			if ((l = get_tty_line()) < 0)
				return ERR;
			else if (l == 0 || ibuf[l - 1] != '\n') {
				clearerr(stdin);
				return  l ? EOF : 0;
			}
			lp = ibuf;
		} else if (*(lp = ibufp) == '\0')
			return 0;
		else {
			while (*ibufp++ != '\n')
				;
			l = ibufp - lp;
		}
		if (l == 2 && lp[0] == '.' && lp[1] == '\n') {
			return 0;
		}
		eot = lp + l;
		SPL1();
		do {
			if ((lp = put_sbuf_line(lp)) == NULL) {
				SPL0();
				return ERR;
			} else if (up)
				up->t = get_addressed_line_node(current_addr);
			else if ((up = push_undo_stack(UADD, current_addr,
			    current_addr)) == NULL) {
				SPL0();
				return ERR;
			}
		} while (lp != eot);
		modified = 1;
		SPL0();
	}
	/* NOTREACHED */
}


/* join_lines: replace a range of lines with the joined text of those lines */
static int
join_lines(int from, int to)
{
	static char *buf = NULL;
	static int n;

	char *s;
	int size = 0;
	line_t *bp, *ep;

	ep = get_addressed_line_node(INC_MOD(to, addr_last));
	bp = get_addressed_line_node(from);
	for (; bp != ep; bp = bp->q_forw) {
		if ((s = get_sbuf_line(bp)) == NULL)
			return ERR;
		REALLOC(buf, n, size + bp->len, ERR);
		memcpy(buf + size, s, bp->len);
		size += bp->len;
	}
	REALLOC(buf, n, size + 2, ERR);
	memcpy(buf + size, "\n", 2);
	if (delete_lines(from, to) < 0)
		return ERR;
	current_addr = from - 1;
	SPL1();
	if (put_sbuf_line(buf) == NULL ||
	    push_undo_stack(UADD, current_addr, current_addr) == NULL) {
		SPL0();
		return ERR;
	}
	modified = 1;
	SPL0();
	return 0;
}


/* move_lines: move a range of lines */
static int
move_lines(int addr)
{
	line_t *b1, *a1, *b2, *a2;
	int n = INC_MOD(second_addr, addr_last);
	int p = first_addr - 1;
	int done = (addr == first_addr - 1 || addr == second_addr);

	SPL1();
	if (done) {
		a2 = get_addressed_line_node(n);
		b2 = get_addressed_line_node(p);
		current_addr = second_addr;
	} else if (push_undo_stack(UMOV, p, n) == NULL ||
	    push_undo_stack(UMOV, addr, INC_MOD(addr, addr_last)) == NULL) {
		SPL0();
		return ERR;
	} else {
		a1 = get_addressed_line_node(n);
		if (addr < first_addr) {
			b1 = get_addressed_line_node(p);
			b2 = get_addressed_line_node(addr);
					/* this get_addressed_line_node last! */
		} else {
			b2 = get_addressed_line_node(addr);
			b1 = get_addressed_line_node(p);
					/* this get_addressed_line_node last! */
		}
		a2 = b2->q_forw;
		REQUE(b2, b1->q_forw);
		REQUE(a1->q_back, a2);
		REQUE(b1, a1);
		current_addr = addr + ((addr < first_addr) ?
		    second_addr - first_addr + 1 : 0);
	}
	if (isglobal)
		unset_active_nodes(b2->q_forw, a2);
	modified = 1;
	SPL0();
	return 0;
}


/* copy_lines: copy a range of lines; return status */
static int
copy_lines(int addr)
{
	line_t *lp, *np = get_addressed_line_node(first_addr);
	undo_t *up = NULL;
	int n = second_addr - first_addr + 1;
	int m = 0;

	current_addr = addr;
	if (first_addr <= addr && addr < second_addr) {
		n =  addr - first_addr + 1;
		m = second_addr - addr;
	}
	for (; n > 0; n=m, m=0, np = get_addressed_line_node(current_addr + 1))
		for (; n-- > 0; np = np->q_forw) {
			SPL1();
			if ((lp = dup_line_node(np)) == NULL) {
				SPL0();
				return ERR;
			}
			add_line_node(lp);
			if (up)
				up->t = lp;
			else if ((up = push_undo_stack(UADD, current_addr,
			    current_addr)) == NULL) {
				SPL0();
				return ERR;
			}
			modified = 1;
			SPL0();
		}
	return 0;
}


/* delete_lines: delete a range of lines */
int
delete_lines(int from, int to)
{
	line_t *n, *p;

	SPL1();
	if (push_undo_stack(UDEL, from, to) == NULL) {
		SPL0();
		return ERR;
	}
	n = get_addressed_line_node(INC_MOD(to, addr_last));
	p = get_addressed_line_node(from - 1);
					/* this get_addressed_line_node last! */
	if (isglobal)
		unset_active_nodes(p->q_forw, n);
	REQUE(p, n);
	addr_last -= to - from + 1;
	current_addr = from - 1;
	modified = 1;
	SPL0();
	return 0;
}


/* display_lines: print a range of lines to stdout */
int
display_lines(int from, int to, int gflag)
{
	line_t *bp;
	line_t *ep;
	char *s;

	if (!from) {
		seterrmsg("invalid address");
		return ERR;
	}
	ep = get_addressed_line_node(INC_MOD(to, addr_last));
	bp = get_addressed_line_node(from);
	for (; bp != ep; bp = bp->q_forw) {
		if ((s = get_sbuf_line(bp)) == NULL)
			return ERR;
		if (put_tty_line(s, bp->len, current_addr = from++, gflag) < 0)
			return ERR;
	}
	return 0;
}


#define MAXMARK 26			/* max number of marks */

static line_t *mark[MAXMARK];		/* line markers */
static int markno;			/* line marker count */

/* mark_line_node: set a line node mark */
static int
mark_line_node(line_t *lp, int n)
{
	if (!islower(n)) {
		seterrmsg("invalid mark character");
		return ERR;
	} else if (mark[n - 'a'] == NULL)
		markno++;
	mark[n - 'a'] = lp;
	return 0;
}


/* get_marked_node_addr: return address of a marked line */
static int
get_marked_node_addr(int n)
{
	if (!islower(n)) {
		seterrmsg("invalid mark character");
		return ERR;
	}
	return get_line_node_addr(mark[n - 'a']);
}


/* unmark_line_node: clear line node mark */
void
unmark_line_node(line_t *lp)
{
	int i;

	for (i = 0; markno && i < MAXMARK; i++)
		if (mark[i] == lp) {
			mark[i] = NULL;
			markno--;
		}
}


/* dup_line_node: return a pointer to a copy of a line node */
static line_t *
dup_line_node(line_t *lp)
{
	line_t *np;

	if ((np = malloc(sizeof(line_t))) == NULL) {
		perror(NULL);
		seterrmsg("out of memory");
		return NULL;
	}
	np->seek = lp->seek;
	np->len = lp->len;
	return np;
}


/* has_trailing_escape:  return the parity of escapes preceding a character
   in a string */
int
has_trailing_escape(char *s, char *t)
{
    return (s == t || *(t - 1) != '\\') ? 0 : !has_trailing_escape(s, t - 1);
}


/* strip_escapes: return copy of escaped string of at most length PATH_MAX */
char *
strip_escapes(char *s)
{
	static char *file = NULL;
	static int filesz = 0;

	int i = 0;

	REALLOC(file, filesz, PATH_MAX, NULL);
	/* assert: no trailing escape */
	while ((file[i++] = (*s == '\\') ? *++s : *s) != '\0' &&
	       i < PATH_MAX-1)
		s++;
	file[PATH_MAX-1] = '\0';
	return file;
}


void
signal_hup(int signo)
{
	int save_errno = errno;

	if (mutex)
		sighup = 1;
	else
		handle_hup(signo);
	errno = save_errno;
}


void
signal_int(int signo)
{
	int save_errno = errno;

	if (mutex)
		sigint = 1;
	else
		handle_int(signo);
	errno = save_errno;
}


void
handle_hup(int signo)
{
	char hup[PATH_MAX];

	if (!sigactive)
		quit(1);		/* XXX signal race */
	sighup = 0;
	/* XXX signal race */
	if (addr_last && write_file("ed.hup", "w", 1, addr_last) < 0 &&
	    home != NULL && home[0] == '/') {
		if (strlcpy(hup, home, sizeof(hup)) < sizeof(hup) &&
		    strlcat(hup, "/ed.hup", sizeof(hup)) < sizeof(hup))
			write_file(hup, "w", 1, addr_last);
	}
	_exit(2);
}


void
handle_int(int signo)
{
	if (!sigactive)
		_exit(1);
	sigint = 0;
	siglongjmp(env, -1);
}


void
handle_winch(int signo)
{
	int save_errno = errno;
	struct winsize ws;		/* window size structure */

	if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) >= 0) {
		if (ws.ws_row > 2)
			rows = ws.ws_row - 2;
		if (ws.ws_col > 8)
			cols = ws.ws_col - 8;
	}
	errno = save_errno;
}
@


1.59
log
@Allow the omission of one address in (.,.) and (.;.) address ranges
as per POSIX. With this patch, ",n" is an abbreviation for "1,n",
";n" abbreviates ".;n". The "n," and "n;" variants mean "n,n" and "n;n",
respectively.

Patch from Jerome FRGAGIC; ok stefan, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.58 2016/08/16 20:04:46 natano Exp $	*/
d221 4
a224 3
					fprintf(stderr, garrulous ?
					    "script, line %d: %s\n" :
					    "", lineno, errmsg);
d256 4
a259 3
				fprintf(stderr, garrulous ?
				    "script, line %d: %s\n" :
				    "", lineno, errmsg);
d264 7
a270 7
			if (!interactive)
				fprintf(stderr, garrulous ?
				    "script, line %d: %s\n" : "",
				    lineno, errmsg);
			else
				fprintf(stderr, garrulous ? "%s\n" : "",
				    errmsg);
d276 4
a279 3
				fprintf(stderr, garrulous ?
				    "script, line %d: %s\n" : "",
				    lineno, errmsg);
@


1.58
log
@Piping to a shell command does not count as a save, so don't reset the
modified flag.
from Jerome Frgacic (jerome.frgacic (at) yahoo.fr)
ok tb
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.57 2016/03/22 17:58:28 mmcc Exp $	*/
d386 2
a387 1
				addr = addr_last;
@


1.57
log
@header cleanup

from Edgar Pettijohn, correction from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.56 2015/11/20 08:53:28 tb Exp $	*/
d862 1
a862 1
		else if (addr == addr_last)
@


1.56
log
@make ed restore the user defined prompt (specified with -p) when it was turned
off and then on again with 'P'.

ok daniel@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.55 2015/10/25 03:40:58 guenther Exp $	*/
d47 1
d49 5
d55 4
a59 2
#include <pwd.h>
#include <err.h>
@


1.55
log
@POSIX says that you can't capture the return value of sigsetjmp().
Fortunately, we don't need it as we only pass siglongjmp() a single value.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.54 2015/10/21 16:06:57 millert Exp $	*/
d133 1
a133 1
			prompt = optarg;
@


1.54
log
@Style fixes; from Ilya Kaliman
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.53 2015/10/09 21:24:05 tobias Exp $	*/
d177 2
a178 1
	if ((status = sigsetjmp(env, 1))) {
@


1.53
log
@The variable errmsg can be static in main.c if code in re.c uses an own
buffer to construct error messages.

with input by and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.52 2015/10/09 20:27:28 tobias Exp $	*/
d177 1
a177 1
	if (status = sigsetjmp(env, 1)) {
@


1.52
log
@Define functions as static when they are not used outside their own c-files.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.51 2015/10/09 19:47:02 millert Exp $	*/
d75 1
@


1.51
log
@Mark static globals that are only used in their respective .c files.
Also make stdin unbuffered since that is the same as using a
single-byte buffer.  OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.50 2015/10/09 01:37:06 deraadt Exp $	*/
d55 16
d317 1
a317 1
int
d915 1
a915 1
int
d934 1
a934 1
int
d959 1
a959 1
char *
d1000 1
a1000 1
int
d1063 1
a1063 1
int
d1112 1
a1112 1
int
d1149 1
a1149 1
int
d1193 1
a1193 1
int
d1283 1
a1283 1
int
d1297 1
a1297 1
int
d1323 1
a1323 1
line_t *
@


1.50
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.49 2015/10/07 05:37:42 deraadt Exp $	*/
d59 6
a64 4
char stdinbuf[1];		/* stdin buffer */
char *shcmd;			/* shell command buffer */
int shcmdsz;			/* shell command buffer size */
int shcmdi;			/* shell command buffer index */
a83 1
char old_filename[PATH_MAX] = "";	/* default filename */
d87 2
a88 2
char *prompt;			/* command-line prompt */
char *dps = "*";		/* default command-line prompt */
d90 1
a90 1
const char usage[] = "usage: %s [-] [-s] [-p string] [file]\n";
d92 1
a92 1
char *home;		/* home directory */
d1263 2
a1264 2
line_t	*mark[MAXMARK];			/* line markers */
int markno;				/* line marker count */
@


1.49
log
@tame "stdio rpath wpath cpath proc exec tty".  proc and exec because ed
it is a shell (it has a !command).  tty because it uses TIOCGWINSZ in
a SIGWINCH handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.48 2015/10/04 15:23:24 millert Exp $	*/
d106 2
a107 2
	if (tame("stdio rpath wpath cpath proc exec tty", NULL) == -1)
		err(1, "tame");
@


1.48
log
@Remove useless pattern_t typedef, POSIX regex is here to stay so
just use regex_t directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47 2015/10/04 15:03:24 millert Exp $	*/
d51 1
d105 3
@


1.47
log
@Remove #ifdefs for non-POSIX systems.  Also remove #ifdef for
SIGWINCH, it is not POSIX but it is a defacto standard.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.46 2015/07/28 17:46:52 deraadt Exp $	*/
d462 1
a462 1
	static pattern_t *pat = NULL;
d466 1
a466 1
	pattern_t *tpat;
d914 1
a914 1
get_matching_node_addr(pattern_t *pat, int dir)
@


1.46
log
@remove gratuitous casts
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.45 2015/07/14 19:16:33 deraadt Exp $	*/
a54 1
#ifdef _POSIX_SOURCE
a55 3
#else
jmp_buf env;
#endif
a147 1
#ifdef SIGWINCH
a151 1
#endif
d155 1
a155 6
#ifdef _POSIX_SOURCE
	if (status = sigsetjmp(env, 1))
#else
	if ((status = setjmp(env)) != 0)
#endif
	{
a1396 1
#ifdef _POSIX_SOURCE
a1397 3
#else
	longjmp(env, -1);
#endif
@


1.45
log
@use atomic operations on sig_atomic_t variables inside the signal handlers,
rather than sharing one variable unsafely.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.44 2015/07/11 16:33:48 deraadt Exp $	*/
d1318 1
a1318 1
	if ((np = (line_t *) malloc(sizeof(line_t))) == NULL) {
@


1.44
log
@XXX annotate another signal race
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.43 2015/01/16 06:39:32 deraadt Exp $	*/
a74 1
int mutex = 0;			/* if set, signals set "sigflags" */
a75 1
int sigflags = 0;		/* if set, signals received while mutex set */
d78 4
d229 1
d250 1
d1363 1
a1363 1
		sigflags |= (1 << (signo - 1));
d1376 1
a1376 1
		sigflags |= (1 << (signo - 1));
d1390 1
a1390 1
	sigflags &= ~(1 << (signo - 1));
d1407 1
a1407 1
	sigflags &= ~(1 << (signo - 1));
a1421 1
	sigflags &= ~(1 << (signo - 1));
@


1.43
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.42 2014/12/04 08:34:04 daniel Exp $	*/
d1385 1
a1385 1
		quit(1);
@


1.42
log
@Allow POSIX 0i; from Jeremy Mates.

Tested to match gnu by sobrado@@; on solaris you probably need to use xpg6
utils to get this behaviour.

ok krw@@, deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.41 2014/11/26 18:34:51 millert Exp $	*/
d83 1
a83 1
char old_filename[MAXPATHLEN] = "";	/* default filename */
d965 1
a965 1
		} else if (n >= MAXPATHLEN) {
d976 1
a976 1
	REALLOC(file, filesz, MAXPATHLEN, NULL);
d1334 1
a1334 1
/* strip_escapes: return copy of escaped string of at most length MAXPATHLEN */
d1343 1
a1343 1
	REALLOC(file, filesz, MAXPATHLEN, NULL);
d1346 1
a1346 1
	       i < MAXPATHLEN-1)
d1348 1
a1348 1
	file[MAXPATHLEN-1] = '\0';
d1382 1
a1382 1
	char hup[MAXPATHLEN];
@


1.41
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.40 2014/07/12 02:47:51 guenther Exp $	*/
d597 1
a597 2
			seterrmsg("invalid address");
			return ERR;
@


1.40
log
@If a constant string needs a name, use a static const array instead
of a pointer or non-const array, as that minimizes the symbols,
maximizes the placement into read-only memory, and avoids warnings
from gcc -Wformat=2 when they're used as format strings.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.39 2014/05/24 01:35:55 daniel Exp $	*/
d144 1
a144 1
				setlinebuf(stdout);
@


1.39
log
@delete restricted ed. no one will ever use this. never documented or enabled.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.38 2014/04/14 23:19:51 jmc Exp $	*/
d90 1
a90 1
char *usage = "usage: %s [-] [-s] [-p string] [file]\n";
@


1.38
log
@more x removal;
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 2014/04/14 22:12:01 tedu Exp $	*/
a75 1
int red = 0;			/* if set, restrict shell/directory access */
a108 1
	red = (n = strlen(argv[0])) > 2 && argv[0][n - 3] == 'r';
d170 1
a170 1
		if (argc && **argv && is_legal_filename(*argv)) {
d981 1
a981 1
	return is_legal_filename(file) ? file : NULL;
d997 1
a997 4
	if (red) {
		seterrmsg("shell access restricted");
		return ERR;
	} else if ((s = ibufp = get_extended_line(&j, 1)) == NULL)
a1426 12
}


/* is_legal_filename: return a legal filename */
int
is_legal_filename(char *s)
{
	if (red && (*s == '!' || !strcmp(s, "..") || strchr(s, '/'))) {
		seterrmsg("shell access restricted");
		return 0;
	}
	return 1;
@


1.37
log
@remove nonstandard DES support because DES. ok beck deraadt miod
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.36 2013/11/21 15:54:45 deraadt Exp $	*/
d91 1
a91 1
char *usage = "usage: %s [-] [-sx] [-p string] [file]\n";
@


1.36
log
@add unsigned char casts for specific calls to ctype.h macros.
ok guenther step
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.35 2013/01/15 20:26:28 espie Exp $	*/
a41 4
 *	The cbc.c encryption code is adapted from
 *	the bdes program by Matt Bishop of Dartmouth College,
 *	Hanover, NH.
 *
a70 1
int des = 0;			/* if set, use crypt(3) for i/o */
a120 3
#ifdef DES
			des = get_keyword();
#else
a121 1
#endif
a122 1

a851 3
#ifdef DES
		des = get_keyword();
#else
a853 2
#endif
		break;
@


1.35
log
@tidy
okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2010/08/12 02:00:28 kevlo Exp $	*/
d301 1
a301 1
		while (isspace(*ibufp) && *ibufp != '\n') \
d326 1
a326 1
		switch ((c = *ibufp)) {
d334 1
a334 1
			if (isdigit(*ibufp)) {
d364 1
a364 1
			if ((addr = get_marked_node_addr(*ibufp++)) < 0)
d494 1
a494 1
	switch ((c = *ibufp++)) {
d528 1
a528 1
		} else if (!isspace(*ibufp)) {
d559 1
a559 1
		} else if (!isspace(*ibufp)) {
d627 1
a627 1
		c = *ibufp++;
d691 1
a691 1
		if (!isspace(*ibufp)) {
d830 1
a830 1
		if (!isspace(*ibufp)) {
@


1.34
log
@Use symbolic names for the file descriptors rather than numeric values.
Some from damien@@, millert@@

ok phessler@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 2009/10/27 23:59:21 deraadt Exp $	*/
d163 2
a164 2
	handle_winch(SIGWINCH);
	if (isatty(0))
d166 1
@


1.33
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2009/01/28 22:17:30 sobrado Exp $	*/
d153 2
a154 2
		if (fstat(0, &sb) || !S_ISFIFO(sb.st_mode)) {
			if (lseek(0, 0, SEEK_CUR)) {
d1439 1
a1439 1
	if (ioctl(0, TIOCGWINSZ, &ws) >= 0) {
@


1.32
log
@synchronize synopsis and usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2008/04/21 11:22:14 tobias Exp $	*/
a30 14

#ifndef lint
char *copyright =
"@@(#) Copyright (c) 1993 Andrew Moore, Talke Studio. \n\
 All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char *rcsid = "@@(#)main.c,v 1.1 1994/02/01 00:34:42 alm Exp";
#else
static char rcsid[] = "$OpenBSD: main.c,v 1.31 2008/04/21 11:22:14 tobias Exp $";
#endif
#endif /* not lint */
@


1.31
log
@Initialize the correct variable in HUP handler if ed.hup in current
directory cannot be written and ~/ed.hup path has to be built up.  Also
pay special care that HOME is an absolute path name.

With input by millert.

ok deraadt, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2006/04/25 15:41:07 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.30 2006/04/25 15:41:07 deraadt Exp $";
d110 1
a110 1
char *usage = "usage: %s [-] [-sx] [-p string] [name]\n";
@


1.30
log
@various small lint cleanups; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2006/04/17 16:17:03 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.29 2006/04/17 16:17:03 deraadt Exp $";
d1416 1
a1416 2
	char path[MAXPATHLEN];
	char *hup = NULL;		/* hup filename */
d1423 4
a1426 5
	    home != NULL &&
	    strlen(home) + sizeof("/ed.hup") <= MAXPATHLEN) {
		strlcpy(path, home, sizeof(path));
		strlcat(path, "/ed.hup", sizeof(path));
		write_file(hup, "w", 1, addr_last);
@


1.29
log
@mark signal race
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2003/06/11 23:42:12 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.28 2003/06/11 23:42:12 deraadt Exp $";
d390 1
a390 1
			/* FALL THROUGH */
d536 1
a536 1
		/* fall through */
d1455 1
a1455 1
	if (ioctl(0, TIOCGWINSZ, (char *) &ws) >= 0) {
@


1.28
log
@ansification, art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 2002/06/09 05:47:27 todd Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.27 2002/06/09 05:47:27 todd Exp $";
a97 1
int sigactive = 0;		/* if set, signal handlers are enabled */
d100 3
d1422 1
@


1.27
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 2002/03/24 22:17:04 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.26 2002/03/24 22:17:04 millert Exp $";
d120 1
a120 3
main(argc, argv)
	volatile int argc;
	char ** volatile argv;
d289 1
a289 1
extract_addr_range()
d327 1
a327 1
next_addr()
d487 1
a487 1
exec_command()
d931 1
a931 2
check_addr_range(n, m)
	int n, m;
d950 1
a950 3
get_matching_node_addr(pat, dir)
	pattern_t *pat;
	int dir;
d975 1
a975 1
get_filename()
d1016 1
a1016 1
get_shell_command()
d1082 1
a1082 2
append_lines(n)
	int n;
d1131 1
a1131 3
join_lines(from, to)
	int from;
	int to;
d1168 1
a1168 2
move_lines(addr)
	int addr;
d1212 1
a1212 2
copy_lines(addr)
	int addr;
d1248 1
a1248 2
delete_lines(from, to)
	int from, to;
d1273 1
a1273 4
display_lines(from, to, gflag)
	int from;
	int to;
	int gflag;
d1302 1
a1302 3
mark_line_node(lp, n)
	line_t *lp;
	int n;
d1316 1
a1316 2
get_marked_node_addr(n)
	int n;
d1328 1
a1328 2
unmark_line_node(lp)
	line_t *lp;
d1342 1
a1342 2
dup_line_node(lp)
	line_t *lp;
d1360 1
a1360 3
has_trailing_escape(s, t)
	char *s;
	char *t;
d1368 1
a1368 2
strip_escapes(s)
	char *s;
d1386 1
a1386 2
signal_hup(signo)
	int signo;
d1399 1
a1399 2
signal_int(signo)
	int signo;
d1412 1
a1412 2
handle_hup(signo)
	int signo;
d1432 1
a1432 2
handle_int(signo)
	int signo;
d1446 1
a1446 2
handle_winch(signo)
	int signo;
d1464 1
a1464 2
is_legal_filename(s)
	char *s;
@


1.26
log
@Kill unneeded longs; fixes some minor 64 bit issues.  deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2002/01/16 01:28:54 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.25 2002/01/16 01:28:54 millert Exp $";
d50 1
a50 1
 *	Brian W. Kernighan and P. J. Plauger's book "Software Tools 
d288 1
a288 1
/* extract_addr_range: get line addresses from the command buffer until an 
d949 1
a949 1
/* get_matching_node_addr: return the address of the next line matching a 
d1399 1
a1399 1
	while ((file[i++] = (*s == '\\') ? *++s : *s) != '\0' && 
@


1.25
log
@Use the volatile specifier to fix warnings about variables being
clobbered by longjmp / vfork instead of the gcc "(void)&foo;" hack.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2001/11/17 19:54:56 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.24 2001/11/17 19:54:56 deraadt Exp $";
d102 2
a103 2
long current_addr;		/* current address in editor buffer */
long addr_last;			/* last address in editor buffer */
d125 1
a125 1
	long status = 0;
d286 1
a286 1
long first_addr, second_addr, addr_cnt;
d293 1
a293 1
	long addr;
d328 1
a328 1
long
d332 2
a333 2
	long addr = current_addr;
	long n;
d348 1
a348 1
				STRTOL(n, ibufp);
d357 1
a357 1
			STRTOL(addr, ibufp);
d408 1
a408 1
		long ol1, ol2; \
d430 1
a430 1
		long ol1, ol2; \
d491 2
a492 2
	extern long u_current_addr;
	extern long u_addr_last;
d496 1
a496 1
	static long sgnum = 0;
d502 1
a502 1
	long addr = 0;
d747 1
a747 1
				STRTOL(sgnum, ibufp);
d891 1
a891 1
			STRTOL(rows, ibufp);
d900 1
a900 1
		printf("%ld\n", addr_cnt ? second_addr : addr_last);
d934 1
a934 1
	long n, m;
d952 1
a952 1
long
d958 1
a958 1
	long n = current_addr;
d1088 1
a1088 1
	long n;
d1138 2
a1139 2
	long from;
	long to;
d1177 1
a1177 1
	long addr;
d1180 2
a1181 2
	long n = INC_MOD(second_addr, addr_last);
	long p = first_addr - 1;
d1222 1
a1222 1
	long addr;
d1226 2
a1227 2
	long n = second_addr - first_addr + 1;
	long m = 0;
d1259 1
a1259 1
	long from, to;
d1285 2
a1286 2
	long from;
	long to;
d1331 1
a1331 1
long
@


1.24
log
@volatile sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2001/11/11 07:36:40 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.23 2001/11/11 07:36:40 deraadt Exp $";
d121 2
a122 2
	int argc;
	char **argv;
a125 5

#ifdef __GNUC__
	(void)&argc;
	(void)&argv;
#endif
@


1.23
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2001/06/22 23:53:53 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.22 2001/06/22 23:53:53 deraadt Exp $";
d488 2
a489 2
sig_atomic_t rows = 22;	/* scroll length: ws_row - 2 */
sig_atomic_t cols = 72;	/* wrap column */
@


1.22
log
@exit() from a signal handler is a sin
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2001/01/17 19:19:31 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.21 2001/01/17 19:19:31 deraadt Exp $";
a1480 1

@


1.21
log
@use sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2001/01/16 03:04:45 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.20 2001/01/16 03:04:45 deraadt Exp $";
d1457 1
a1457 1
	quit(2);
d1466 1
a1466 1
		quit(1);
@


1.20
log
@cleanup strcpy, strncpy, signal races, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2000/05/01 18:30:52 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.19 2000/05/01 18:30:52 deraadt Exp $";
d488 2
a489 2
volatile int rows = 22;	/* scroll length: ws_row - 2 */
volatile int cols = 72;	/* wrap column */
@


1.19
log
@MAXPATHLEN, not MAXPATHLEN+1; millert agrees
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2000/04/01 17:20:10 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.18 2000/04/01 17:20:10 deraadt Exp $";
d110 8
d132 2
d137 1
a137 1
		switch(c) {
d196 1
a196 1
		strcpy(errmsg, "interrupt");
d203 3
a205 4
			else if (**argv != '!') {
				strncpy(old_filename, *argv, sizeof old_filename-1);
				old_filename[sizeof old_filename-1] = '\0';
			}
d209 1
a209 1
				strcpy(errmsg, "invalid filename");
d227 1
a227 1
				strcpy(errmsg, "warning: file modified");
d242 1
a242 1
			strcpy(errmsg, "unexpected end-of-file");
d260 1
a260 1
			strcpy(errmsg, "warning: file modified");
d317 5
a321 1
#define	SKIP_BLANKS() while (isspace(*ibufp) && *ibufp != '\n') ibufp++
d324 7
a330 1
	if (!first) { strcpy(errmsg, "invalid address"); return ERR; }
d344 1
a344 1
		switch (c = *ibufp) {
d400 1
a400 1
				strcpy(errmsg, "invalid address");
d412 19
a430 16
{ \
	long ol1, ol2; \
\
	ol1 = first_addr, ol2 = second_addr; \
	if (extract_addr_range() < 0) \
		return ERR; \
	else if (addr_cnt == 0) { \
		strcpy(errmsg, "destination expected"); \
		return ERR; \
	} else if (second_addr < 0 || addr_last < second_addr) { \
		strcpy(errmsg, "invalid address"); \
		return ERR; \
	} \
	addr = second_addr; \
	first_addr = ol1, second_addr = ol2; \
}
d434 15
a448 13
{ \
	long ol1, ol2; \
\
	ol1 = first_addr, ol2 = second_addr; \
	if (extract_addr_range() < 0) \
		return ERR; \
	if (second_addr < 0 || addr_last < second_addr) { \
		strcpy(errmsg, "invalid address"); \
		return ERR; \
	} \
	addr = second_addr; \
	first_addr = ol1, second_addr = ol2; \
}
d453 1
a453 2
#define GET_COMMAND_SUFFIX() { \
	int done = 0; \
d455 22
a476 12
		switch(*ibufp) { \
		case 'p': \
			gflag |= GPR, ibufp++; \
			break; \
		case 'l': \
			gflag |= GLS, ibufp++; \
			break; \
		case 'n': \
			gflag |= GNP, ibufp++; \
			break; \
		default: \
			done++; \
d478 1
a478 7
	} while (!done); \
	if (*ibufp++ != '\n') { \
		strcpy(errmsg, "invalid command suffix"); \
		return ERR; \
	} \
}

d488 2
a489 1
int rows = 22;		/* scroll length: ws_row - 2 */
d512 1
a512 1
	switch(c = *ibufp++) {
d544 1
a544 1
			strcpy(errmsg, "unexpected address");
d547 1
a547 1
			strcpy(errmsg, "unexpected command suffix");
d559 2
a560 4
		if (*fnp && *fnp != '!') {
			strncpy(old_filename, fnp, sizeof old_filename-1);
			old_filename[sizeof old_filename-1] = '\0';
		}
d563 1
a563 1
			strcpy(errmsg, "no current filename");
d575 1
a575 1
			strcpy(errmsg, "unexpected address");
d578 1
a578 1
			strcpy(errmsg, "unexpected command suffix");
d583 1
a583 1
			strcpy(errmsg, "invalid redirection");
d587 2
a588 4
		if (*fnp) {
			strncpy(old_filename, fnp, sizeof old_filename-1);
			old_filename[sizeof old_filename-1] = '\0';
		}
d596 1
a596 1
			strcpy(errmsg, "cannot nest global commands");
d610 1
a610 1
			strcpy(errmsg, "unexpected address");
d618 1
a618 1
			strcpy(errmsg, "unexpected address");
d627 1
a627 1
			strcpy(errmsg, "invalid address");
d647 1
a647 1
			strcpy(errmsg, "invalid address");
d667 1
a667 1
			strcpy(errmsg, "invalid destination");
d693 1
a693 1
			strcpy(errmsg, "unexpected address");
d702 1
a702 1
			strcpy(errmsg, "unexpected address");
d710 1
a710 1
			strcpy(errmsg, "unexpected command suffix");
d718 2
a719 4
		if (*old_filename == '\0' && *fnp != '!') {
			strncpy(old_filename, fnp, sizeof old_filename-1);
			old_filename[sizeof old_filename-1] = '\0';
		}
d722 1
a722 1
			strcpy(errmsg, "no current filename");
d726 2
a727 1
		if ((addr = read_file(*fnp ? fnp : old_filename, second_addr)) < 0)
d734 1
a734 1
			switch(*ibufp) {
d758 1
a758 1
					strcpy(errmsg, "invalid command suffix");
d764 1
a764 1
			strcpy(errmsg, "no previous substitution");
d769 1
a769 1
			strcpy(errmsg, "invalid pattern delimiter");
d795 4
a798 2
		if (sflags & SGP)
			sgflag ^= GPR, sgflag &= ~(GLS | GNP);
d800 1
a800 1
			switch(*ibufp) {
d802 2
a803 1
				sgflag |= GPR, ibufp++;
d806 2
a807 1
				sgflag |= GLS, ibufp++;
d810 2
a811 1
				sgflag |= GNP, ibufp++;
d835 1
a835 1
			strcpy(errmsg, "unexpected address");
d849 1
a849 1
			strcpy(errmsg, "unexpected command suffix");
d858 2
a859 4
		if (*old_filename == '\0' && *fnp != '!') {
			strncpy(old_filename, fnp, sizeof old_filename-1);
			old_filename[sizeof old_filename-1] = '\0';
		}
d862 1
a862 1
			strcpy(errmsg, "no current filename");
d876 1
a876 1
			strcpy(errmsg, "unexpected address");
d883 1
a883 1
		strcpy(errmsg, "crypt unavailable");
d888 1
d890 1
a890 1
		if (check_addr_range(first_addr = 1, current_addr + 1) < 0)
d892 1
a892 1
		if (check_addr_range(first_addr = 1, current_addr + !isglobal) < 0)
d909 1
a909 1
			strcpy(errmsg, "unexpected address");
d919 1
d921 1
a921 1
		if (check_addr_range(first_addr = 1, current_addr + 1) < 0
d923 1
a923 1
		if (check_addr_range(first_addr = 1, current_addr + !isglobal) < 0
d929 1
a929 1
		strcpy(errmsg, "unknown command");
d947 1
a947 1
		strcpy(errmsg, "invalid address");
d978 1
a978 1
	strcpy(errmsg, "no match");
d994 1
a994 1
			strcpy(errmsg, "invalid filename");
d1005 1
a1005 1
			strcpy(errmsg, "filename too long");
d1011 1
a1011 1
		strcpy(errmsg, "no current filename");
d1036 1
a1036 1
		strcpy(errmsg, "shell access restricted");
d1061 1
a1061 1
				strcpy(errmsg, "no previous command");
d1072 1
a1072 1
				strcpy(errmsg, "no current filename");
d1299 1
a1299 1
		strcpy(errmsg, "invalid address");
d1326 1
a1326 1
		strcpy(errmsg, "invalid mark character");
d1341 1
a1341 1
		strcpy(errmsg, "invalid mark character");
d1372 1
a1372 1
		strcpy(errmsg, "out of memory");
d1416 2
d1422 1
d1430 2
d1436 1
d1444 1
a1445 2
	char *s;
	int n;
d1451 4
a1454 9
	    (s = getenv("HOME")) != NULL &&
	    (n = strlen(s)) + 8 <= MAXPATHLEN &&	/* "ed.hup" + '/' */
	    (hup = (char *) malloc(n + 10)) != NULL) {
		strcpy(hup, s);
		if (hup[n - 1] != '/') {
			hup[n] = '/';
			hup[n+1] = '\0';
		}
		strcat(hup, "ed.hup");
a1475 2
int cols = 72;				/* wrap column */

d1486 4
a1489 2
		if (ws.ws_row > 2) rows = ws.ws_row - 2;
		if (ws.ws_col > 8) cols = ws.ws_col - 8;
d1501 1
a1501 1
		strcpy(errmsg, "shell access restricted");
@


1.18
log
@commons type mismatch; ath@@algonet.se
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2000/01/22 20:24:49 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.17 2000/01/22 20:24:49 deraadt Exp $";
a960 1

d976 1
a976 1
		} else if (n - 1 > MAXPATHLEN) {
d987 1
a987 1
	REALLOC(file, filesz, MAXPATHLEN + 1, NULL);
@


1.17
log
@remove extra externs not needed because of unistd.h (rest of tree will be done later.. contact me if you want to help)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 1999/12/05 02:37:55 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.16 1999/12/05 02:37:55 deraadt Exp $";
d461 1
a461 1
long rows = 22;		/* scroll length: ws_row - 2 */
@


1.16
log
@not MAXPATHLEN+1
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 1999/12/04 23:45:36 provos Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.15 1999/12/04 23:45:36 provos Exp $";
d67 1
a108 3

extern int optind;
extern char *optarg;
@


1.15
log
@remove oflow in strip_escapes...
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 1998/05/18 20:36:14 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.14 1998/05/18 20:36:14 deraadt Exp $";
d1377 1
a1377 1
	REALLOC(file, filesz, MAXPATHLEN + 1, NULL);
d1380 1
a1380 1
	       i < MAXPATHLEN)
d1382 1
a1382 1
	file[MAXPATHLEN] = '\0';
@


1.14
log
@buf oflows
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 1997/09/12 04:35:18 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.13 1997/09/12 04:35:18 millert Exp $";
d1379 2
a1380 1
	while ((file[i++] = (*s == '\\') ? *++s : *s) != '\0')
d1382 1
@


1.13
log
@Avoid longjmp/vfork clobbering.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 1997/09/01 18:29:30 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.12 1997/09/01 18:29:30 deraadt Exp $";
d100 1
a100 1
char old_filename[MAXPATHLEN + 1] = "";	/* default filename */
d195 4
a198 2
			else if (**argv != '!')
				strcpy(old_filename, *argv);
d533 4
a536 1
		if (*fnp && *fnp != '!') strcpy(old_filename, fnp);
d563 4
a566 1
		if (*fnp) strcpy(old_filename, fnp);
d696 4
a699 2
		if (*old_filename == '\0' && *fnp != '!')
			strcpy(old_filename, fnp);
d832 4
a835 2
		if (*old_filename == '\0' && *fnp != '!')
			strcpy(old_filename, fnp);
d1423 4
a1426 2
		if (hup[n - 1] != '/')
			hup[n] = '/', hup[n+1] = '\0';
@


1.12
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 1997/08/05 22:22:55 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.11 1997/08/05 22:22:55 deraadt Exp $";
d120 5
@


1.11
log
@make signal handlers errno safe
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 1997/07/23 14:42:33 kstailey Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.10 1997/07/23 14:42:33 kstailey Exp $";
d215 1
a215 1
					fprintf(stderr, garrulous ? 
d248 2
a249 2
				fprintf(stderr, garrulous ? 
				    "script, line %d: %s\n" : 
d256 2
a257 2
				fprintf(stderr, garrulous ? 
				    "script, line %d: %s\n" : "", 
d266 1
a266 1
				fprintf(stderr, garrulous ? 
d571 1
a571 1
			return ERR; 
d714 1
a714 1
			case '0': case '1': case '2': case '3': case '4': 
d825 1
a825 1
		if ((addr = write_file(*fnp ? fnp : old_filename, 
d1171 1
a1171 1
		current_addr = addr + ((addr < first_addr) ? 
@


1.10
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 1997/07/08 19:30:27 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.9 1997/07/08 19:30:27 millert Exp $";
d1374 2
a1375 1
	else	handle_hup(signo);
d1385 2
a1386 1
	else	handle_int(signo);
d1436 2
d1445 1
@


1.9
log
@Pipes are not interactive, eh.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1997/07/08 18:56:27 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.8 1997/07/08 18:56:27 millert Exp $";
d238 1
a238 1
			        status)) >= 0))
@


1.8
log
@If stdin is not a tty and not seekable assume we are being used
interactively.  Fixes all known problems with using ed over rsh.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 1997/07/08 17:36:43 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.7 1997/07/08 17:36:43 millert Exp $";
d63 1
a67 1
#include <unistd.h>
d156 8
a163 4
		/* not seekable so default to interactive */
		if (lseek(0, 0, SEEK_CUR)) {
			interactive = 1;
			setlinebuf(stdout);
@


1.7
log
@Use line-buffered output if no tty is present.  Makes ed work
correctly when there is no tty.  Close PR#281
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 1997/01/15 23:40:23 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.6 1997/01/15 23:40:23 millert Exp $";
d67 1
d98 1
d154 9
d166 2
a167 1
	if (isatty(0)) signal(SIGWINCH, handle_winch);
a168 2
	if (!isatty(0))
		setlinebuf(stdout);
d184 1
a184 1
			if (read_file(*argv, 0) < 0 && !isatty(0))
d192 1
a192 1
			if (!isatty(0))
d210 1
a210 1
				if (!isatty(0)) {
d243 1
a243 1
			if (!isatty(0)) {
d251 1
a251 1
			if (!isatty(0))
d261 1
a261 1
			if (!isatty(0)) {
@


1.6
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1996/12/14 12:17:56 mickey Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.5 1996/12/14 12:17:56 mickey Exp $";
d157 2
@


1.5
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 1996/10/12 19:38:38 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.4 1996/10/12 19:38:38 millert Exp $";
d121 1
a121 1
	while ((c = getopt(argc, argv, "p:sx")) != EOF)
@


1.4
log
@Back out my sprintf -> snprintf changes where they don't make sense and
use good ole strcpy() instead.  Also use perror() instead of fprintf()
where it makes sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 1996/09/15 22:25:57 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.3 1996/09/15 22:25:57 millert Exp $";
d163 1
a163 1
	if (status = setjmp(env))
d220 1
a220 1
			if (!status || status &&
d222 1
a222 1
			        status)) >= 0)
d551 1
a551 1
		else if (n = (c == 'G' || c == 'V'))
d847 1
a847 1
		printf("%d\n", addr_cnt ? second_addr : addr_last);
d909 1
a909 1
		if (n = dir ? INC_MOD(n, addr_last) : DEC_MOD(n, addr_last)) {
d1346 1
a1346 1
	while (file[i++] = (*s == '\\') ? *++s : *s)
@


1.3
log
@sprintf -> snprintf paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.2 1996/06/23 14:20:02 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.2 1996/06/23 14:20:02 deraadt Exp $";
d167 1
a167 1
		snprintf(errmsg, sizeof(errmsg), "interrupt");
d179 1
a179 1
				snprintf(errmsg, sizeof(errmsg), "invalid filename");
d188 1
a188 1
			printf("%s", prompt);
d197 1
a197 1
				snprintf(errmsg, sizeof(errmsg), "warning: file modified");
d212 1
a212 1
			snprintf(errmsg, sizeof(errmsg), "unexpected end-of-file");
d230 1
a230 1
			snprintf(errmsg, sizeof(errmsg), "warning: file modified");
d290 1
a290 1
	if (!first) { snprintf(errmsg, sizeof(errmsg), "invalid address"); return ERR; }
d360 1
a360 2
				snprintf(errmsg, sizeof(errmsg),
					 "invalid address");
d379 1
a379 1
		snprintf(errmsg, sizeof(errmsg), "destination expected"); \
d382 1
a382 1
		snprintf(errmsg, sizeof(errmsg), "invalid address"); \
d398 1
a398 1
		snprintf(errmsg, sizeof(errmsg), "invalid address"); \
d426 1
a426 1
		snprintf(errmsg, sizeof(errmsg), "invalid command suffix"); \
d495 1
a495 1
			snprintf(errmsg, sizeof(errmsg), "unexpected address");
d498 1
a498 2
			snprintf(errmsg, sizeof(errmsg),
				 "unexpected command suffix");
d513 1
a513 1
			snprintf(errmsg, sizeof(errmsg), "no current filename");
d525 1
a525 1
			snprintf(errmsg, sizeof(errmsg), "unexpected address");
d528 1
a528 2
			snprintf(errmsg, sizeof(errmsg),
				 "unexpected command suffix");
d533 1
a533 1
			snprintf(errmsg, sizeof(errmsg), "invalid redirection");
d538 1
a538 1
		printf("%s\n", strip_escapes(old_filename));
d545 1
a545 2
			snprintf(errmsg, sizeof(errmsg),
				 "cannot nest global commands");
d559 1
a559 1
			snprintf(errmsg, sizeof(errmsg), "unexpected address");
d567 1
a567 1
			snprintf(errmsg, sizeof(errmsg), "unexpected address");
d576 1
a576 1
			snprintf(errmsg, sizeof(errmsg), "invalid address");
d596 1
a596 1
			snprintf(errmsg, sizeof(errmsg), "invalid address");
d616 1
a616 1
			snprintf(errmsg, sizeof(errmsg), "invalid destination");
d642 1
a642 1
			snprintf(errmsg, sizeof(errmsg), "unexpected address");
d651 1
a651 1
			snprintf(errmsg, sizeof(errmsg), "unexpected address");
d659 1
a659 2
			snprintf(errmsg, sizeof(errmsg),
				 "unexpected command suffix");
d671 1
a671 1
			snprintf(errmsg, sizeof(errmsg), "no current filename");
d706 1
a706 2
					snprintf(errmsg, sizeof(errmsg),
						 "invalid command suffix");
d712 1
a712 2
			snprintf(errmsg, sizeof(errmsg),
				 "no previous substitution");
d717 1
a717 2
			snprintf(errmsg, sizeof(errmsg),
				 "invalid pattern delimiter");
d778 1
a778 1
			snprintf(errmsg, sizeof(errmsg), "unexpected address");
d792 1
a792 2
			snprintf(errmsg, sizeof(errmsg),
				 "unexpected command suffix");
d805 1
a805 1
			snprintf(errmsg, sizeof(errmsg), "no current filename");
d819 1
a819 1
			snprintf(errmsg, sizeof(errmsg), "unexpected address");
d826 1
a826 1
		snprintf(errmsg, sizeof(errmsg), "crypt unavailable");
d851 1
a851 1
			snprintf(errmsg, sizeof(errmsg), "unexpected address");
d870 1
a870 1
		snprintf(errmsg, sizeof(errmsg), "unknown command");
d888 1
a888 1
		snprintf(errmsg, sizeof(errmsg), "invalid address");
d919 1
a919 1
	snprintf(errmsg, sizeof(errmsg), "no match");
d936 1
a936 1
			snprintf(errmsg, sizeof(errmsg), "invalid filename");
d947 1
a947 1
			snprintf(errmsg, sizeof(errmsg), "filename too long");
d953 1
a953 1
		snprintf(errmsg, sizeof(errmsg), "no current filename");
d978 1
a978 1
		snprintf(errmsg, sizeof(errmsg), "shell access restricted");
d1003 1
a1003 2
				snprintf(errmsg, sizeof(errmsg),
					 "no previous command");
d1014 1
a1014 2
				snprintf(errmsg, sizeof(errmsg),
					 "no current filename");
d1241 1
a1241 1
		snprintf(errmsg, sizeof(errmsg), "invalid address");
d1268 1
a1268 1
		snprintf(errmsg, sizeof(errmsg), "invalid mark character");
d1283 1
a1283 1
		snprintf(errmsg, sizeof(errmsg), "invalid mark character");
d1313 2
a1314 2
		fprintf(stderr, "%s\n", strerror(errno));
		snprintf(errmsg, sizeof(errmsg), "out of memory");
d1434 1
a1434 1
		snprintf(errmsg, sizeof(errmsg), "shell access restricted");
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 1995/03/21 09:04:44 cgd Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: main.c,v 1.3 1995/03/21 09:04:44 cgd Exp $";
a106 1
extern char errmsg[];
d167 1
a167 1
		sprintf(errmsg, "interrupt");
d179 1
a179 1
				sprintf(errmsg, "invalid filename");
d197 1
a197 1
				sprintf(errmsg, "warning: file modified");
d212 1
a212 1
			sprintf(errmsg, "unexpected end-of-file");
d230 1
a230 1
			sprintf(errmsg, "warning: file modified");
d290 1
a290 1
	if (!first) { sprintf(errmsg, "invalid address"); return ERR; }
d360 2
a361 1
				sprintf(errmsg, "invalid address");
d380 1
a380 1
		sprintf(errmsg, "destination expected"); \
d383 1
a383 1
		sprintf(errmsg, "invalid address"); \
d399 1
a399 1
		sprintf(errmsg, "invalid address"); \
d427 1
a427 1
		sprintf(errmsg, "invalid command suffix"); \
d496 1
a496 1
			sprintf(errmsg, "unexpected address");
d499 2
a500 1
			sprintf(errmsg, "unexpected command suffix");
d515 1
a515 1
			sprintf(errmsg, "no current filename");
d527 1
a527 1
			sprintf(errmsg, "unexpected address");
d530 2
a531 1
			sprintf(errmsg, "unexpected command suffix");
d536 1
a536 1
			sprintf(errmsg, "invalid redirection");
d548 2
a549 1
			sprintf(errmsg, "cannot nest global commands");
d563 1
a563 1
			sprintf(errmsg, "unexpected address");
d571 1
a571 1
			sprintf(errmsg, "unexpected address");
d580 1
a580 1
			sprintf(errmsg, "invalid address");
d600 1
a600 1
			sprintf(errmsg, "invalid address");
d620 1
a620 1
			sprintf(errmsg, "invalid destination");
d646 1
a646 1
			sprintf(errmsg, "unexpected address");
d655 1
a655 1
			sprintf(errmsg, "unexpected address");
d663 2
a664 1
			sprintf(errmsg, "unexpected command suffix");
d676 1
a676 1
			sprintf(errmsg, "no current filename");
d711 2
a712 1
					sprintf(errmsg, "invalid command suffix");
d718 2
a719 1
			sprintf(errmsg, "no previous substitution");
d724 2
a725 1
			sprintf(errmsg, "invalid pattern delimiter");
d786 1
a786 1
			sprintf(errmsg, "unexpected address");
d800 2
a801 1
			sprintf(errmsg, "unexpected command suffix");
d814 1
a814 1
			sprintf(errmsg, "no current filename");
d828 1
a828 1
			sprintf(errmsg, "unexpected address");
d835 1
a835 1
		sprintf(errmsg, "crypt unavailable");
d860 1
a860 1
			sprintf(errmsg, "unexpected address");
d879 1
a879 1
		sprintf(errmsg, "unknown command");
d897 1
a897 1
		sprintf(errmsg, "invalid address");
d928 1
a928 1
	sprintf(errmsg, "no match");
d945 1
a945 1
			sprintf(errmsg, "invalid filename");
d956 1
a956 1
			sprintf(errmsg, "filename too long");
d962 1
a962 1
		sprintf(errmsg, "no current filename");
d987 1
a987 1
		sprintf(errmsg, "shell access restricted");
d1012 2
a1013 1
				sprintf(errmsg, "no previous command");
d1024 2
a1025 1
				sprintf(errmsg, "no current filename");
d1252 1
a1252 1
		sprintf(errmsg, "invalid address");
d1279 1
a1279 1
		sprintf(errmsg, "invalid mark character");
d1294 1
a1294 1
		sprintf(errmsg, "invalid mark character");
d1325 1
a1325 1
		sprintf(errmsg, "out of memory");
d1445 1
a1445 1
		sprintf(errmsg, "shell access restricted");
@


1.1
log
@Initial revision
@
text
@d1 1
d42 1
a42 1
static char rcsid[] = "$NetBSD: main.c,v 1.3 1995/03/21 09:04:44 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
