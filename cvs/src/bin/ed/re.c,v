head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.6
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.22
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.20
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.28
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.24
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.22
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.20
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.18
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.16
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.14
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.6
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.12
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.10
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.03.22.17.58.28;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	dG9FDzJpMhZLrmQQ;

1.16
date	2015.10.09.21.24.05;	author tobias;	state Exp;
branches;
next	1.15;
commitid	lMLGwZnIoP49Tk0o;

1.15
date	2015.10.09.20.27.28;	author tobias;	state Exp;
branches;
next	1.14;
commitid	75UxTlTgsWoFG3EU;

1.14
date	2015.10.04.15.23.24;	author millert;	state Exp;
branches;
next	1.13;
commitid	DzhpkCptJKskzdTA;

1.13
date	2015.07.28.17.46.52;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	g3kCI6mUnNZgOIuA;

1.12
date	2015.01.16.06.39.32;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	Uu5nFG3wCl0LACBb;

1.11
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.11.23.42.12;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.16.03.04.46;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.01.21.03.51.50;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.01.18.22.02.45;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.12.17.57;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.12.19.38.40;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.15.22.25.57;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.20.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.07;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@header cleanup

from Edgar Pettijohn, correction from deraadt@@
@
text
@/*	$OpenBSD: re.c,v 1.16 2015/10/09 21:24:05 tobias Exp $	*/
/*	$NetBSD: re.c,v 1.14 1995/03/21 09:04:48 cgd Exp $	*/

/* re.c: This file contains the regular expression interface routines for
   the ed line editor. */
/*-
 * Copyright (c) 1993 Andrew Moore, Talke Studio.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <regex.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ed.h"

static char *extract_pattern(int);
static char *parse_char_class(char *);

extern int patlock;


/* get_compiled_pattern: return pointer to compiled pattern from command
   buffer */
regex_t *
get_compiled_pattern(void)
{
	static regex_t *exp = NULL;
	char errbuf[128] = "";

	char *exps;
	char delimiter;
	int n;

	if ((delimiter = *ibufp) == ' ') {
		seterrmsg("invalid pattern delimiter");
		return NULL;
	} else if (delimiter == '\n' || *++ibufp == '\n' || *ibufp == delimiter) {
		if (!exp)
			seterrmsg("no previous pattern");
		return exp;
	} else if ((exps = extract_pattern(delimiter)) == NULL)
		return NULL;
	/* buffer alloc'd && not reserved */
	if (exp && !patlock)
		regfree(exp);
	else if ((exp = malloc(sizeof(regex_t))) == NULL) {
		perror(NULL);
		seterrmsg("out of memory");
		return NULL;
	}
	patlock = 0;
	if ((n = regcomp(exp, exps, 0)) != 0) {
		regerror(n, exp, errbuf, sizeof errbuf);
		seterrmsg(errbuf);
		free(exp);
		return exp = NULL;
	}
	return exp;
}


/* extract_pattern: copy a pattern string from the command buffer; return
   pointer to the copy */
static char *
extract_pattern(int delimiter)
{
	static char *lhbuf = NULL;	/* buffer */
	static int lhbufsz = 0;		/* buffer size */

	char *nd;
	int len;

	for (nd = ibufp; *nd != delimiter && *nd != '\n'; nd++)
		switch (*nd) {
		default:
			break;
		case '[':
			if ((nd = parse_char_class(++nd)) == NULL) {
				seterrmsg("unbalanced brackets ([])");
				return NULL;
			}
			break;
		case '\\':
			if (*++nd == '\n') {
				seterrmsg("trailing backslash (\\)");
				return NULL;
			}
			break;
		}
	len = nd - ibufp;
	REALLOC(lhbuf, lhbufsz, len + 1, NULL);
	memcpy(lhbuf, ibufp, len);
	lhbuf[len] = '\0';
	ibufp = nd;
	return (isbinary) ? NUL_TO_NEWLINE(lhbuf, len) : lhbuf;
}


/* parse_char_class: expand a POSIX character class */
static char *
parse_char_class(char *s)
{
	int c, d;

	if (*s == '^')
		s++;
	if (*s == ']')
		s++;
	for (; *s != ']' && *s != '\n'; s++)
		if (*s == '[' && ((d = *(s+1)) == '.' || d == ':' || d == '='))
			for (s++, c = *++s; *s != ']' || c != d; s++)
				if ((c = *s) == '\n')
					return NULL;
	return  (*s == ']') ? s : NULL;
}
@


1.16
log
@The variable errmsg can be static in main.c if code in re.c uses an own
buffer to construct error messages.

with input by and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.15 2015/10/09 20:27:28 tobias Exp $	*/
d31 6
@


1.15
log
@Define functions as static when they are not used outside their own c-files.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.14 2015/10/04 15:23:24 millert Exp $	*/
a38 1
char errmsg[PATH_MAX + 40] = "";
d46 1
d71 2
a72 1
		regerror(n, exp, errmsg, sizeof errmsg);
@


1.14
log
@Remove useless pattern_t typedef, POSIX regex is here to stay so
just use regex_t directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.13 2015/07/28 17:46:52 deraadt Exp $	*/
d34 2
d81 1
a81 1
char *
d117 1
a117 1
char *
@


1.13
log
@remove gratuitous casts
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.12 2015/01/16 06:39:32 deraadt Exp $	*/
d41 1
a41 1
pattern_t *
d44 1
a44 1
	static pattern_t *exp = NULL;
d62 1
a62 1
	else if ((exp = malloc(sizeof(pattern_t))) == NULL) {
@


1.12
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.11 2009/10/27 23:59:21 deraadt Exp $	*/
d62 1
a62 1
	else if ((exp = (pattern_t *) malloc(sizeof(pattern_t))) == NULL) {
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.10 2003/06/11 23:42:12 deraadt Exp $	*/
d37 1
a37 1
char errmsg[MAXPATHLEN + 40] = "";
@


1.10
log
@ansification, art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.9 2002/06/09 05:47:27 todd Exp $	*/
a30 8

#ifndef lint
#if 0
static char *rcsid = "@@(#)re.c,v 1.6 1994/02/01 00:34:43 alm Exp";
#else
static char rcsid[] = "$OpenBSD: re.c,v 1.9 2002/06/09 05:47:27 todd Exp $";
#endif
#endif /* not lint */
@


1.9
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.8 2001/01/16 03:04:46 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: re.c,v 1.8 2001/01/16 03:04:46 deraadt Exp $";
d50 1
a50 1
get_compiled_pattern()
d88 1
a88 2
extract_pattern(delimiter)
	int delimiter;
d124 1
a124 2
parse_char_class(s)
	char *s;
@


1.8
log
@cleanup strcpy, strncpy, signal races, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.7 1998/01/21 03:51:50 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: re.c,v 1.7 1998/01/21 03:51:50 millert Exp $";
d47 1
a47 1
/* get_compiled_pattern: return pointer to compiled pattern from command 
@


1.7
log
@Back out last change.  ed and sed should not use extended regular expressions.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.6 1998/01/18 22:02:45 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: re.c,v 1.6 1998/01/18 22:02:45 millert Exp $";
d59 1
a59 1
		strcpy(errmsg, "invalid pattern delimiter");
d63 1
a63 1
			strcpy(errmsg, "no previous pattern");
d72 1
a72 1
		strcpy(errmsg, "out of memory");
d103 1
a103 1
				strcpy(errmsg, "unbalanced brackets ([])");
d109 1
a109 1
				strcpy(errmsg, "trailing backslash (\\)");
@


1.6
log
@Support extended (modern) instead of basic (obsolescent) regular expressions.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.5 1996/12/14 12:17:57 mickey Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: re.c,v 1.5 1996/12/14 12:17:57 mickey Exp $";
d76 1
a76 1
	if ((n = regcomp(exp, exps, REG_EXTENDED)) != 0) {
@


1.5
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.4 1996/10/12 19:38:40 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: re.c,v 1.4 1996/10/12 19:38:40 millert Exp $";
d76 1
a76 1
	if ((n = regcomp(exp, exps, 0)) != 0) {
@


1.4
log
@Back out my sprintf -> snprintf changes where they don't make sense and
use good ole strcpy() instead.  Also use perror() instead of fprintf()
where it makes sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.3 1996/09/15 22:25:57 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: re.c,v 1.3 1996/09/15 22:25:57 millert Exp $";
d76 1
a76 1
	if (n = regcomp(exp, exps, 0)) {
@


1.3
log
@sprintf -> snprintf paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.2 1996/06/23 14:20:03 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: re.c,v 1.2 1996/06/23 14:20:03 deraadt Exp $";
d59 1
a59 1
		snprintf(errmsg, sizeof(errmsg), "invalid pattern delimiter");
d63 1
a63 1
			snprintf(errmsg, sizeof(errmsg), "no previous pattern");
d71 2
a72 2
		fprintf(stderr, "%s\n", strerror(errno));
		snprintf(errmsg, sizeof(errmsg), "out of memory");
d103 1
a103 2
				snprintf(errmsg, sizeof(errmsg),
					 "unbalanced brackets ([])");
d109 1
a109 2
				snprintf(errmsg, sizeof(errmsg),
					 "trailing backslash (\\)");
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: re.c,v 1.14 1995/03/21 09:04:48 cgd Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: re.c,v 1.14 1995/03/21 09:04:48 cgd Exp $";
d59 1
a59 1
		sprintf(errmsg, "invalid pattern delimiter");
d62 2
a63 1
		if (!exp) sprintf(errmsg, "no previous pattern");
d72 1
a72 1
		sprintf(errmsg, "out of memory");
d103 2
a104 1
				sprintf(errmsg, "unbalanced brackets ([])");
d110 2
a111 1
				sprintf(errmsg, "trailing backslash (\\)");
@


1.1
log
@Initial revision
@
text
@d1 1
d36 1
a36 1
static char rcsid[] = "$NetBSD: re.c,v 1.14 1995/03/21 09:04:48 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
