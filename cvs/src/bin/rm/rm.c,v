head	1.42;
access;
symbols
	OPENBSD_6_2:1.42.0.2
	OPENBSD_6_2_BASE:1.42
	OPENBSD_6_1:1.40.0.4
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.39.0.2
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.6
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.25.0.2
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.4
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.9.0.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.8
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2017.06.27.21.49.47;	author tedu;	state Exp;
branches;
next	1.41;
commitid	UcCI5eGbs5Q3hHLP;

1.41
date	2017.06.27.21.43.46;	author tedu;	state Exp;
branches;
next	1.40;
commitid	ffGkl3dPIrdhYvXu;

1.40
date	2016.10.14.10.51.57;	author schwarze;	state Exp;
branches;
next	1.39;
commitid	qsakiiSeXz4WMSIa;

1.39
date	2016.06.28.18.00.59;	author tedu;	state Exp;
branches;
next	1.38;
commitid	hxokW79am9Wgc8Ml;

1.38
date	2016.06.28.15.20.13;	author tedu;	state Exp;
branches;
next	1.37;
commitid	TEr0jzWoNIVKyNMK;

1.37
date	2016.04.15.23.09.57;	author tedu;	state Exp;
branches;
next	1.36;
commitid	EwCyrPbn4Wmz27i3;

1.36
date	2016.02.01.22.34.19;	author gsoares;	state Exp;
branches;
next	1.35;
commitid	ceBoE1nvcM0QzkRY;

1.35
date	2015.11.17.17.17.24;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	u14e7GciC0XG0i2j;

1.34
date	2015.10.13.04.30.53;	author daniel;	state Exp;
branches;
next	1.33;
commitid	oCY7bi07PlQHbhWZ;

1.33
date	2015.10.11.03.08.46;	author daniel;	state Exp;
branches;
next	1.32;
commitid	JkYXVHPI1ZMWxP1g;

1.32
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	sbrB3Q5CNxcwZpfU;

1.31
date	2015.10.08.13.17.06;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	dd3id5k2EvTLDRcB;

1.30
date	2015.01.16.06.39.32;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	Uu5nFG3wCl0LACBb;

1.29
date	2014.05.21.06.23.02;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.23.18.41.08;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2012.09.05.19.49.08;	author naddy;	state Exp;
branches;
next	1.26;

1.26
date	2012.09.04.22.22.50;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2012.06.18.01.03.05;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2012.06.18.00.33.47;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.10.17.14.16;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.06.00.08.57;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.21.20.28.52;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.30.21.00.05;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.14.19.15.35;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.02.06.58.54;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.31.17.18.59;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.32.09;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.11.11.03.53;	author hugh;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.04.04.26.40;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.06.13.29.08;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.08.13.40.20;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.01.02.08.38.58;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.01.02.08.30.27;	author weingart;	state Exp;
branches;
next	1.7;

1.7
date	98.11.04.21.52.41;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	97.09.01.18.30.26;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.06.18.19.08.44;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.12.14.12.18.15;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.08.02.12.41.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.20.59;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.20;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.20;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.42
log
@fix a few lines of unusual length
@
text
@/*	$OpenBSD: rm.c,v 1.41 2017/06/27 21:43:46 tedu Exp $	*/
/*	$NetBSD: rm.c,v 1.19 1995/09/07 06:48:50 jtc Exp $	*/

/*-
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mount.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <fts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <pwd.h>
#include <grp.h>

#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

extern char *__progname;

int dflag, eval, fflag, iflag, Pflag, vflag, stdin_ok;

int	check(char *, char *, struct stat *);
void	checkdot(char **);
void	rm_file(char **);
int	rm_overwrite(char *, struct stat *);
int	pass(int, off_t, char *, size_t);
void	rm_tree(char **);
void	usage(void);

/*
 * rm --
 *	This rm is different from historic rm's, but is expected to match
 *	POSIX 1003.2 behavior.  The most visible difference is that -f
 *	has two specific effects now, ignore non-existent files and force
 * 	file removal.
 */
int
main(int argc, char *argv[])
{
	int ch, rflag;

	Pflag = rflag = 0;
	while ((ch = getopt(argc, argv, "dfiPRrv")) != -1)
		switch(ch) {
		case 'd':
			dflag = 1;
			break;
		case 'f':
			fflag = 1;
			iflag = 0;
			break;
		case 'i':
			fflag = 0;
			iflag = 1;
			break;
		case 'P':
			Pflag = 1;
			break;
		case 'R':
		case 'r':			/* Compatibility. */
			rflag = 1;
			break;
		case 'v':
			vflag = 1;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (Pflag) {
		if (pledge("stdio rpath wpath cpath getpw", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio rpath cpath getpw", NULL) == -1)
			err(1, "pledge");
	}

	if (argc < 1 && fflag == 0)
		usage();

	checkdot(argv);

	if (*argv) {
		stdin_ok = isatty(STDIN_FILENO);

		if (rflag)
			rm_tree(argv);
		else
			rm_file(argv);
	}

	return (eval);
}

void
rm_tree(char **argv)
{
	FTS *fts;
	FTSENT *p;
	int needstat;
	int flags;

	/*
	 * Remove a file hierarchy.  If forcing removal (-f), or interactive
	 * (-i) or can't ask anyway (stdin_ok), don't stat the file.
	 */
	needstat = !fflag && !iflag && stdin_ok;

	/*
	 * If the -i option is specified, the user can skip on the pre-order
	 * visit.  The fts_number field flags skipped directories.
	 */
#define	SKIPPED	1

	flags = FTS_PHYSICAL;
	if (!needstat)
		flags |= FTS_NOSTAT;
	if (!(fts = fts_open(argv, flags, NULL)))
		err(1, NULL);
	while ((p = fts_read(fts)) != NULL) {
		switch (p->fts_info) {
		case FTS_DNR:
			if (!fflag || p->fts_errno != ENOENT) {
				warnx("%s: %s",
				    p->fts_path, strerror(p->fts_errno));
				eval = 1;
			}
			continue;
		case FTS_ERR:
			errc(1, p->fts_errno, "%s", p->fts_path);
		case FTS_NS:
			/*
			 * FTS_NS: assume that if can't stat the file, it
			 * can't be unlinked.
			 */
			if (!needstat)
				break;
			if (!fflag || p->fts_errno != ENOENT) {
				warnx("%s: %s",
				    p->fts_path, strerror(p->fts_errno));
				eval = 1;
			}
			continue;
		case FTS_D:
			/* Pre-order: give user chance to skip. */
			if (!fflag && !check(p->fts_path, p->fts_accpath,
			    p->fts_statp)) {
				(void)fts_set(fts, p, FTS_SKIP);
				p->fts_number = SKIPPED;
			}
			continue;
		case FTS_DP:
			/* Post-order: see if user skipped. */
			if (p->fts_number == SKIPPED)
				continue;
			break;
		default:
			if (!fflag &&
			    !check(p->fts_path, p->fts_accpath, p->fts_statp))
				continue;
		}

		/*
		 * If we can't read or search the directory, may still be
		 * able to remove it.  Don't print out the un{read,search}able
		 * message unless the remove fails.
		 */
		switch (p->fts_info) {
		case FTS_DP:
		case FTS_DNR:
			if (!rmdir(p->fts_accpath) ||
			    (fflag && errno == ENOENT)) {
				if (vflag)
					fprintf(stdout, "%s\n", p->fts_path);
				continue;
			}
			break;

		case FTS_F:
		case FTS_NSOK:
			if (Pflag)
				rm_overwrite(p->fts_accpath, p->fts_info ==
				    FTS_NSOK ? NULL : p->fts_statp);
			/* FALLTHROUGH */
		default:
			if (!unlink(p->fts_accpath) ||
			    (fflag && errno == ENOENT)) {
				if (vflag)
					fprintf(stdout, "%s\n", p->fts_path);
				continue;
			}
		}
		warn("%s", p->fts_path);
		eval = 1;
	}
	if (errno)
		err(1, "fts_read");
	fts_close(fts);
}

void
rm_file(char **argv)
{
	struct stat sb;
	int rval;
	char *f;

	/*
	 * Remove a file.  POSIX 1003.2 states that, by default, attempting
	 * to remove a directory is an error, so must always stat the file.
	 */
	while ((f = *argv++) != NULL) {
		/* Assume if can't stat the file, can't unlink it. */
		if (lstat(f, &sb)) {
			if (!fflag || errno != ENOENT) {
				warn("%s", f);
				eval = 1;
			}
			continue;
		}

		if (S_ISDIR(sb.st_mode) && !dflag) {
			warnx("%s: is a directory", f);
			eval = 1;
			continue;
		}
		if (!fflag && !check(f, f, &sb))
			continue;
		else if (S_ISDIR(sb.st_mode))
			rval = rmdir(f);
		else {
			if (Pflag)
				rm_overwrite(f, &sb);
			rval = unlink(f);
		}
		if (rval && (!fflag || errno != ENOENT)) {
			warn("%s", f);
			eval = 1;
		} else if (vflag)
			(void)fprintf(stdout, "%s\n", f);
	}
}

/*
 * rm_overwrite --
 *	Overwrite the file with varying bit patterns.
 *
 * XXX
 * This is a cheap way to *really* delete files.  Note that only regular
 * files are deleted, directories (and therefore names) will remain.
 * Also, this assumes a fixed-block file system (like FFS, or a V7 or a
 * System V file system).  In a logging file system, you'll have to have
 * kernel support.
 * Returns 1 for success.
 */
int
rm_overwrite(char *file, struct stat *sbp)
{
	struct stat sb, sb2;
	struct statfs fsb;
	size_t bsize;
	int fd;
	char *buf = NULL;

	fd = -1;
	if (sbp == NULL) {
		if (lstat(file, &sb))
			goto err;
		sbp = &sb;
	}
	if (!S_ISREG(sbp->st_mode))
		return (1);
	if (sbp->st_nlink > 1) {
		warnx("%s (inode %llu): not overwritten due to multiple links",
		    file, (unsigned long long)sbp->st_ino);
		return (0);
	}
	if ((fd = open(file, O_WRONLY|O_NONBLOCK|O_NOFOLLOW, 0)) == -1)
		goto err;
	if (fstat(fd, &sb2))
		goto err;
	if (sb2.st_dev != sbp->st_dev || sb2.st_ino != sbp->st_ino ||
	    !S_ISREG(sb2.st_mode)) {
		errno = EPERM;
		goto err;
	}
	if (fstatfs(fd, &fsb) == -1)
		goto err;
	bsize = MAXIMUM(fsb.f_iosize, 1024U);
	if ((buf = malloc(bsize)) == NULL)
		err(1, "%s: malloc", file);

	if (!pass(fd, sbp->st_size, buf, bsize))
		goto err;
	if (fsync(fd))
		goto err;
	close(fd);
	free(buf);
	return (1);

err:
	warn("%s", file);
	close(fd);
	eval = 1;
	free(buf);
	return (0);
}

int
pass(int fd, off_t len, char *buf, size_t bsize)
{
	size_t wlen;

	for (; len > 0; len -= wlen) {
		wlen = len < bsize ? len : bsize;
		arc4random_buf(buf, wlen);
		if (write(fd, buf, wlen) != wlen)
			return (0);
	}
	return (1);
}

int
check(char *path, char *name, struct stat *sp)
{
	int ch, first;
	char modep[15];

	/* Check -i first. */
	if (iflag)
		(void)fprintf(stderr, "remove %s? ", path);
	else {
		/*
		 * If it's not a symbolic link and it's unwritable and we're
		 * talking to a terminal, ask.  Symbolic links are excluded
		 * because their permissions are meaningless.  Check stdin_ok
		 * first because we may not have stat'ed the file.
		 */
		if (!stdin_ok || S_ISLNK(sp->st_mode) || !access(name, W_OK) ||
		    errno != EACCES)
			return (1);
		strmode(sp->st_mode, modep);
		(void)fprintf(stderr, "override %s%s%s/%s for %s? ",
		    modep + 1, modep[9] == ' ' ? "" : " ",
		    user_from_uid(sp->st_uid, 0),
		    group_from_gid(sp->st_gid, 0), path);
	}
	(void)fflush(stderr);

	first = ch = getchar();
	while (ch != '\n' && ch != EOF)
		ch = getchar();
	return (first == 'y' || first == 'Y');
}

/*
 * POSIX.2 requires that if "." or ".." are specified as the basename
 * portion of an operand, a diagnostic message be written to standard
 * error and nothing more be done with such operands.
 *
 * Since POSIX.2 defines basename as the final portion of a path after
 * trailing slashes have been removed, we'll remove them here.
 */
#define ISDOT(a) ((a)[0] == '.' && (!(a)[1] || ((a)[1] == '.' && !(a)[2])))
void
checkdot(char **argv)
{
	char *p, **save, **t;
	int complained;
	struct stat sb, root;

	stat("/", &root);
	complained = 0;
	for (t = argv; *t;) {
		if (lstat(*t, &sb) == 0 &&
		    root.st_ino == sb.st_ino && root.st_dev == sb.st_dev) {
			if (!complained++)
				warnx("\"/\" may not be removed");
			goto skip;
		}
		/* strip trailing slashes */
		p = strrchr(*t, '\0');
		while (--p > *t && *p == '/')
			*p = '\0';

		/* extract basename */
		if ((p = strrchr(*t, '/')) != NULL)
			++p;
		else
			p = *t;

		if (ISDOT(p)) {
			if (!complained++)
				warnx("\".\" and \"..\" may not be removed");
skip:
			eval = 1;
			for (save = t; (t[0] = t[1]) != NULL; ++t)
				continue;
			t = save;
		} else
			++t;
	}
}

void
usage(void)
{
	(void)fprintf(stderr, "usage: %s [-dfiPRrv] file ...\n", __progname);
	exit(1);
}
@


1.41
log
@add a -v verbose flag to cp, mv, and rm. useful for monitoring progress,
and present on several other systems. some ok, some less ok.
from Job Snijders
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.40 2016/10/14 10:51:57 schwarze Exp $	*/
d209 1
a209 1
					(void)fprintf(stdout, "%s\n", p->fts_path);
d224 1
a224 1
					(void)fprintf(stdout, "%s\n", p->fts_path);
d399 1
a399 1
#define ISDOT(a)	((a)[0] == '.' && (!(a)[1] || ((a)[1] == '.' && !(a)[2])))
@


1.40
log
@delete useless setlocale(3);
noticed by Jan Stary <hans at stare dot cz>;
return from main while here;
feedback and OK tb@@, OK martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.39 2016/06/28 18:00:59 tedu Exp $	*/
d53 1
a53 1
int dflag, eval, fflag, iflag, Pflag, stdin_ok;
d76 1
a76 1
	while ((ch = getopt(argc, argv, "dfiPRr")) != -1)
d96 3
d207 3
a209 1
			    (fflag && errno == ENOENT))
d211 1
d222 3
a224 1
			    (fflag && errno == ENOENT))
d226 1
d274 2
a275 1
		}
d443 1
a443 1
	(void)fprintf(stderr, "usage: %s [-dfiPRr] file ...\n", __progname);
@


1.39
log
@revert previous. better fix applied to fts_open.
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.38 2016/06/28 15:20:13 tedu Exp $	*/
a36 1
#include <locale.h>
a74 2
	setlocale(LC_ALL, "");

d124 1
a124 1
	exit(eval);
@


1.38
log
@don't report errors for 'rm -rf ""'. report by rkitover.
ok benno deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.37 2016/04/15 23:09:57 tedu Exp $	*/
d153 2
a154 5
	if (!(fts = fts_open(argv, flags, NULL))) {
		if (!fflag || errno != ENOENT)
			err(1, NULL);
		return;
	}
@


1.37
log
@don't allow removal of /. more robust approach involving stat this time.
posix uses the language "resolves to the root directory" in this case.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.36 2016/02/01 22:34:19 gsoares Exp $	*/
d153 5
a157 2
	if (!(fts = fts_open(argv, flags, NULL)))
		err(1, NULL);
@


1.36
log
@style nit - do not add a space between function name and bracket
from Edgar Pettijohn <edgar at pettijohn-web.com>

fix another similar space in line 127. (pointed out by/OK jung@@)

OK tb@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.35 2015/11/17 17:17:24 deraadt Exp $	*/
d398 1
d400 1
d403 6
d423 1
@


1.35
log
@Missing "getpw" pledges, these were unnoticed because nobody expects
a user_from_uid(3) call...
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.34 2015/10/13 04:30:53 daniel Exp $	*/
d127 1
a127 1
	exit (eval);
d402 1
a402 1
		p = strrchr (*t, '\0');
@


1.34
log
@revert previous. changes the behaviour of:
rm -f ""
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.32 2015/10/09 01:37:06 deraadt Exp $	*/
d106 1
a106 1
		if (pledge("stdio rpath wpath cpath", NULL) == -1)
d109 1
a109 1
		if (pledge("stdio rpath cpath", NULL) == -1)
@


1.33
log
@Don't allow "rm -rf /"

Patch from Theo Buehler who was inspired by watching Bryan Cantrill
in BSD Now 103.

Minor tweak from me to turn the complained variables into flags instead
of counters.

"i think it's ok" tedu@@
"this isn't 1980 anymore" deraadt@@
ok millert@@
@
text
@d57 1
a57 1
void	checkdotorslash(char **);
d116 1
a116 1
	checkdotorslash(argv);
d394 1
a394 1
checkdotorslash(char **argv)
d397 1
a397 1
	int dotcomplained, slashcomplained;
d399 1
a399 1
	dotcomplained = slashcomplained = 0;
d413 1
a413 2
			if (!dotcomplained) {
				dotcomplained = 1;
d415 5
a419 7
			}
		} else if (*p == '\0') {
			if (!slashcomplained) {
				slashcomplained = 1;
				warnx("\"/\" may not be removed");
			}
		} else {
a420 7
			continue;
		}

		eval = 1;
		for (save = t; (t[0] = t[1]) != NULL; ++t)
			continue;
		t = save;
@


1.32
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.31 2015/10/08 13:17:06 deraadt Exp $	*/
d57 1
a57 1
void	checkdot(char **);
d116 1
a116 1
	checkdot(argv);
d394 1
a394 1
checkdot(char **argv)
d397 1
a397 1
	int complained;
d399 1
a399 1
	complained = 0;
d413 2
a414 1
			if (!complained++)
d416 7
a422 5
			eval = 1;
			for (save = t; (t[0] = t[1]) != NULL; ++t)
				continue;
			t = save;
		} else
d424 7
@


1.31
log
@the -P flag overwrites files, so it needs tame "stdio rpath wpath cpath".
the remaining code paths can use tame "stdio rpath cpath". One again,
the "cpath" request says a path-based system call will be used to
"change" filesystem pathname layout, for instance any of O_CREAT, symlink,
rename, unlink...
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.30 2015/01/16 06:39:32 deraadt Exp $	*/
d106 2
a107 2
		if (tame("stdio rpath wpath cpath", NULL) == -1)
			err(1, "tame");
d109 2
a110 2
		if (tame("stdio rpath cpath", NULL) == -1)
			err(1, "tame");
@


1.30
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.29 2014/05/21 06:23:02 guenther Exp $	*/
d104 8
@


1.29
log
@Use errc/warnc to simplify code.

ok jca@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.28 2013/04/23 18:41:08 deraadt Exp $	*/
a34 1
#include <sys/param.h>
d46 1
d50 2
d309 1
a309 1
	bsize = MAX(fsb.f_iosize, 1024U);
@


1.28
log
@handle large ino_t
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.27 2012/09/05 19:49:08 naddy Exp $	*/
d155 1
a155 1
			errx(1, "%s: %s", p->fts_path, strerror(p->fts_errno));
@


1.27
log
@overwrite with random stream; a repeating chunk of random data isn't
random at all
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.26 2012/09/04 22:22:50 tedu Exp $	*/
d292 2
a293 2
		warnx("%s (inode %u): not overwritten due to multiple links",
		    file, sbp->st_ino);
@


1.26
log
@one random overwrite is sufficient, after some discussion on tech
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.25 2012/06/18 01:03:05 guenther Exp $	*/
a331 1
	arc4random_buf(buf, bsize);
d334 1
@


1.25
log
@Polish the rm -rP turd: if the fts_* routines have lstat()'ed the
directory entry then use the struct stat from that instead of doing
it again, and skip the rm_overwrite() call if fts_read() indicated
that the entry couldn't be a regular file.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.24 2012/06/18 00:33:47 millert Exp $	*/
d58 1
a58 1
int	pass(int, int, off_t, char *, size_t);
d264 1
a264 1
 *	Overwrite the file 3 times with varying bit patterns.
d311 1
a311 2
	if (!pass(0xff, fd, sbp->st_size, buf, bsize) || fsync(fd) ||
	    lseek(fd, (off_t)0, SEEK_SET))
d313 1
a313 4
	if (!pass(0x00, fd, sbp->st_size, buf, bsize) || fsync(fd) ||
	    lseek(fd, (off_t)0, SEEK_SET))
		goto err;
	if (!pass(0xff, fd, sbp->st_size, buf, bsize) || fsync(fd))
d328 1
a328 1
pass(int val, int fd, off_t len, char *buf, size_t bsize)
d332 1
a332 1
	memset(buf, val, bsize);
@


1.24
log
@Fix potential symlink race condition in "rm -P" by adding a check
that the file we have opened is the one we expected.  Also open in
non-blocking mode to avoid a potential hang with FIFOs.  Reported
by Radoslaw A. Zarzynski.  Fix adapted from NetBSD.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.23 2009/10/27 23:59:22 deraadt Exp $	*/
d201 6
a207 2
			if (Pflag)
				rm_overwrite(p->fts_accpath, NULL);
@


1.23
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.22 2008/06/10 17:14:16 otto Exp $	*/
d273 1
a273 1
	struct stat sb;
d292 3
a294 1
	if ((fd = open(file, O_WRONLY, 0)) == -1)
d296 5
@


1.22
log
@do not ask the "override?" question if access fails for other resaons than
EACCES. From Tim van der Molen; ok millert@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.21 2007/06/06 00:08:57 ray Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1990, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)rm.c	8.8 (Berkeley) 4/27/95";
#else
static char rcsid[] = "$OpenBSD: rm.c,v 1.21 2007/06/06 00:08:57 ray Exp $";
#endif
#endif /* not lint */
@


1.21
log
@Unlink files with multiple links when -P flag is specified instead
of just warning and skipping the file.

OK millert and jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.20 2006/03/21 20:28:52 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.20 2006/03/21 20:28:52 otto Exp $";
d364 2
a365 1
		if (!stdin_ok || S_ISLNK(sp->st_mode) || !access(name, W_OK))
@


1.20
log
@Call fts_close() when done; from NetBSD's Coverity scan; ok millert@@
jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.19 2005/08/30 21:00:05 jmc Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.19 2005/08/30 21:00:05 jmc Exp $";
d217 1
a217 2
				if (!rm_overwrite(p->fts_accpath, NULL))
					continue;
d262 1
a262 2
				if (!rm_overwrite(f, &sb))
					continue;
@


1.19
log
@remove -W from synopsis;
from nikolay kalev; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.18 2005/06/14 19:15:35 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.18 2005/06/14 19:15:35 millert Exp $";
d228 1
@


1.18
log
@whiteouts are gone
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.17 2004/06/02 06:58:54 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.17 2004/06/02 06:58:54 otto Exp $";
d424 1
a424 1
	(void)fprintf(stderr, "usage: %s [-dfiPRrW] file ...\n", __progname);
@


1.17
log
@outline PASS; use size_t for sizes; better error message.
ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.16 2004/05/31 17:18:59 tedu Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.16 2004/05/31 17:18:59 tedu Exp $";
d66 1
a66 1
int dflag, eval, fflag, iflag, Pflag, Wflag, stdin_ok;
d91 1
a91 1
	while ((ch = getopt(argc, argv, "dfiPRrW")) != -1)
a110 3
		case 'W':
			Wflag = 1;
			break;
a156 2
	if (Wflag)
		flags |= FTS_WHITEOUT;
a214 6
		case FTS_W:
			if (!undelete(p->fts_accpath) ||
			    (fflag && errno == ENOENT))
				continue;
			break;

d244 3
a246 8
			if (Wflag) {
				sb.st_mode = S_IFWHT|S_IWUSR|S_IRUSR;
			} else {
				if (!fflag || errno != ENOENT) {
					warn("%s", f);
					eval = 1;
				}
				continue;
a247 3
		} else if (Wflag) {
			warnx("%s: %s", f, strerror(EEXIST));
			eval = 1;
d256 1
a256 1
		if (!fflag && !S_ISWHT(sb.st_mode) && !check(f, f, &sb))
a257 2
		if (S_ISWHT(sb.st_mode))
			rval = undelete(f);
@


1.16
log
@better error handling with -P option.  from freebsd (bde@@)
ok beck@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.15 2003/06/02 23:32:09 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.15 2003/06/02 23:32:09 millert Exp $";
d72 1
d311 2
a312 2
	off_t len;
	int bsize, fd, wlen;
d332 1
a332 1
	bsize = MAX(fsb.f_iosize, 1024);
d336 2
a337 10
#define	PASS(byte) {							\
	memset(buf, byte, bsize);					\
	for (len = sbp->st_size; len > 0; len -= wlen) {		\
		wlen = len < bsize ? len : bsize;			\
		if (write(fd, buf, wlen) != wlen)			\
			goto err;					\
	}								\
}
	PASS(0xff);
	if (fsync(fd) || lseek(fd, (off_t)0, SEEK_SET))
d339 2
a340 2
	PASS(0x00);
	if (fsync(fd) || lseek(fd, (off_t)0, SEEK_SET))
d342 1
a342 2
	PASS(0xff);
	if (fsync(fd))
d349 1
d352 1
a352 3
	if (buf)
		free(buf);
	warn("%s", file);
d356 13
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.14 2003/01/11 11:03:53 hugh Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.14 2003/01/11 11:03:53 hugh Exp $";
d71 1
a71 1
void	rm_overwrite(char *, struct stat *);
d227 2
a228 1
				rm_overwrite(p->fts_accpath, NULL);
d282 2
a283 1
				rm_overwrite(f, &sb);
d303 1
d305 1
a305 1
void
d321 1
a321 1
		return;
d325 1
a325 1
		return;
d333 1
a333 1
		err(1, "malloc");
d350 9
a358 6
	if (!fsync(fd) && !close(fd)) {
		free(buf);
		return;
	}

err:	eval = 1;
d362 1
@


1.14
log
@Attempt to do something reasonable when overwrite mode is combined
with hard links, and document it. In consultation with dynamo and
approved by millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.13 2002/07/04 04:26:40 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.13 2002/07/04 04:26:40 deraadt Exp $";
@


1.13
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.12 2002/02/16 21:27:07 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.12 2002/02/16 21:27:07 millert Exp $";
d323 5
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.11 2001/09/06 13:29:08 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.11 2001/09/06 13:29:08 mpech Exp $";
d87 1
a87 3
main(argc, argv)
	int argc;
	char *argv[];
d141 1
a141 2
rm_tree(argv)
	char **argv;
d244 1
a244 2
rm_file(argv)
	char **argv;
d307 1
a307 3
rm_overwrite(file, sbp)
	char *file;
	struct stat *sbp;
d359 1
a359 3
check(path, name, sp)
	char *path, *name;
	struct stat *sp;
d400 1
a400 2
checkdot(argv)
	char **argv;
d431 1
a431 1
usage()
@


1.11
log
@o) __progname aria;

millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.10 2001/06/08 13:40:20 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.10 2001/06/08 13:40:20 millert Exp $";
d72 6
a77 6
int	check __P((char *, char *, struct stat *));
void	checkdot __P((char **));
void	rm_file __P((char **));
void	rm_overwrite __P((char *, struct stat *));
void	rm_tree __P((char **));
void	usage __P((void));
@


1.10
log
@Don't give usage warning for 'rm -f' with no files to remove to be
consistent with other implementations.
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.9 1999/01/02 08:38:58 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.9 1999/01/02 08:38:58 deraadt Exp $";
d68 2
d442 1
a442 2

	(void)fprintf(stderr, "usage: rm [-dfiPRrW] file ...\n");
@


1.9
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.8 1999/01/02 08:30:27 weingart Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.8 1999/01/02 08:30:27 weingart Exp $";
d123 1
a123 1
	if (argc < 1)
@


1.8
log
@Fix possible free() of uninitialized pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.7 1998/11/04 21:52:41 aaron Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.7 1998/11/04 21:52:41 aaron Exp $";
d356 1
a356 1
	if(buf)
@


1.7
log
@use optimal xfer block size in rm_overwrite() instead of assuming 8192
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.6 1997/09/01 18:30:26 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.6 1997/09/01 18:30:26 deraadt Exp $";
d317 1
a317 1
	char *buf;
d356 2
a357 1
	free(buf);
@


1.6
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.5 1997/06/18 19:08:44 kstailey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.5 1997/06/18 19:08:44 kstailey Exp $";
d53 2
d314 1
d316 2
a317 2
	int fd, wlen;
	char buf[8 * 1024];
d329 5
d336 1
a336 1
	memset(buf, byte, sizeof(buf));					\
d338 1
a338 1
		wlen = len < sizeof(buf) ? len : sizeof(buf);		\
d350 2
a351 1
	if (!fsync(fd) && !close(fd))
d353 1
d356 1
@


1.5
log
@(foo *)NULL -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.4 1996/12/14 12:18:15 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.4 1996/12/14 12:18:15 mickey Exp $";
d217 1
a217 1
			if (!rmdir(p->fts_accpath) || 
@


1.4
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.3 1996/08/02 12:41:05 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.3 1996/08/02 12:41:05 deraadt Exp $";
d164 1
a164 1
	if (!(fts = fts_open(argv, flags, (int (*)())NULL)))
@


1.3
log
@zap getopt() case of -?, come on, it is the default!
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.2 1996/06/23 14:20:59 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.2 1996/06/23 14:20:59 deraadt Exp $";
d63 2
d217 2
a218 1
			if (!rmdir(p->fts_accpath) || fflag && errno == ENOENT)
d224 1
a224 1
			    fflag && errno == ENOENT)
d231 2
a232 1
			if (!unlink(p->fts_accpath) || fflag && errno == ENOENT)
d392 1
a392 1
#define ISDOT(a)	((a)[0] == '.' && (!(a)[1] || (a)[1] == '.' && !(a)[2]))
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: rm.c,v 1.19 1995/09/07 06:48:50 jtc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: rm.c,v 1.19 1995/09/07 06:48:50 jtc Exp $";
a112 1
		case '?':
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: rm.c,v 1.19 1995/09/07 06:48:50 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
