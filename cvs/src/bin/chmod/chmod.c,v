head	1.42;
access;
symbols
	OPENBSD_6_2:1.42.0.2
	OPENBSD_6_2_BASE:1.42
	OPENBSD_6_1:1.41.0.4
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.28.0.8
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.4
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.2
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.27.0.6
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.4
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.26.0.6
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.23.0.10
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.8
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.6
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.4
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.18.0.6
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.12.0.6
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.4
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.7.0.10
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2017.05.28.08.03.36;	author awolk;	state Exp;
branches;
next	1.41;
commitid	qZ6PHjxCg9v2GMnm;

1.41
date	2017.02.17.10.14.12;	author tb;	state Exp;
branches;
next	1.40;
commitid	78wwPWOIcMdjTtEL;

1.40
date	2016.10.19.18.20.25;	author schwarze;	state Exp;
branches;
next	1.39;
commitid	0nfxWLL3tqkKYGhB;

1.39
date	2015.12.31.23.38.16;	author guenther;	state Exp;
branches;
next	1.38;
commitid	T6qOYRt5FW0IEdVw;

1.38
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	sbrB3Q5CNxcwZpfU;

1.37
date	2015.10.03.15.00.13;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	HmwbkODQaFC49LGR;

1.36
date	2015.10.03.05.05.06;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	OKiPLpT4t5sJr5tK;

1.35
date	2015.10.03.03.30.04;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	NMksKBT3gRaOCYqw;

1.34
date	2015.06.25.02.04.08;	author uebayasi;	state Exp;
branches;
next	1.33;
commitid	lJr85pywqGCq0vnE;

1.33
date	2014.12.13.20.59.24;	author guenther;	state Exp;
branches;
next	1.32;
commitid	6MhCDIQ3xMWZT3AG;

1.32
date	2014.12.13.10.26.48;	author tobias;	state Exp;
branches;
next	1.31;
commitid	aNew1ETFRTysYGXX;

1.31
date	2014.10.06.17.37.34;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	73S1hX3dX7ZWnwrA;

1.30
date	2014.05.21.06.23.01;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2014.03.16.18.38.30;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2012.12.04.02.24.46;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2011.03.09.12.32.02;	author okan;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.12.19.30.53;	author jasper;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.27.23.59.20;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.21.16.05.39;	author sobrado;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.25.15.41.07;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.25.06.13.27;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.25.05.59.42;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.29.20.32.22;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.15.08.57.21;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.01.18.25.47;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.16.22.12.02;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.32.06;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.01.23.50.02;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.04.04.26.39;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.31.19.02.38;	author ericj;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.19.19.42.31;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.30.16.00.03;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.09.17.50.16;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.09.16.26.51;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.11.08.23.26.39;	author todd;	state Exp;
branches
	1.7.10.1;
next	1.6;

1.6
date	97.06.28.14.45.43;	author grr;	state Exp;
branches;
next	1.5;

1.5
date	97.06.27.18.37.05;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.12.14.12.17.37;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.08.02.12.40.50;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.01;	author deraadt;	state Exp;
branches;
next	;

1.7.10.1
date	2000.10.06.20.21.00;	author jason;	state Exp;
branches;
next	;


desc
@@


1.42
log
@chown: Remove SUPPORT_DOT ifdef - it's on by default for 22 years

The old syntax was deprecated 25 years ago when the utility was
first standardised in IEEE Std 1003.2-1992 ("POSIX.2"). There was
no POSIX version of chown with the dot separator.

Let's stop pretending that it will ever go away.

OK jung@@, deraadt@@, jmc@@
@
text
@/*	$OpenBSD: chmod.c,v 1.41 2017/02/17 10:14:12 tb Exp $	*/
/*	$NetBSD: chmod.c,v 1.12 1995/03/21 09:02:09 cgd Exp $	*/

/*
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <fts.h>
#include <grp.h>
#include <limits.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int ischflags, ischown, ischgrp, ischmod;
extern char *__progname;

gid_t a_gid(const char *);
uid_t a_uid(const char *, int);
static void __dead usage(void);

int
main(int argc, char *argv[])
{
	FTS *ftsp;
	FTSENT *p;
	void *set;
	unsigned long val;
	int oct;
	mode_t omode;
	int Hflag, Lflag, Rflag, ch, fflag, fts_options, hflag, rval, atflags;
	uid_t uid;
	gid_t gid;
	u_int32_t fclear, fset;
	char *ep, *mode, *cp, *flags;

	if (strlen(__progname) > 2) {
		ischown = __progname[2] == 'o';
		ischgrp = __progname[2] == 'g';
		ischmod = __progname[2] == 'm';
		ischflags = __progname[2] == 'f';
	}

	uid = (uid_t)-1;
	gid = (gid_t)-1;
	Hflag = Lflag = Rflag = fflag = hflag = 0;
	while ((ch = getopt(argc, argv, "HLPRXfghorstuwx")) != -1)
		switch (ch) {
		case 'H':
			Hflag = 1;
			Lflag = 0;
			break;
		case 'L':
			Lflag = 1;
			Hflag = 0;
			break;
		case 'P':
			Hflag = Lflag = 0;
			break;
		case 'R':
			Rflag = 1;
			break;
		case 'f':		/* no longer documented. */
			fflag = 1;
			break;
		case 'h':
			hflag = 1;
			break;
		/*
		 * If this is a symbolic mode argument rather than
		 * an option, we are done with option processing.
		 */
		case 'g': case 'o': case 'r': case 's':
		case 't': case 'u': case 'w': case 'X': case 'x':
			if (!ischmod)
				usage();
			/*
			 * If getopt() moved past the argument, back up.
			 * If the argument contains option letters before
			 * mode letters, setmode() will catch them.
			 */
			if (optind > 1) {
				cp = argv[optind - 1];
				if (cp[strlen(cp) - 1] == ch)
					--optind;
			}
			goto done;
		default:
			usage();
		}
done:
	argv += optind;
	argc -= optind;

	if (argc < 2)
		usage();

	/*
	 * We alter the symlink itself if doing -h or -RP, or
	 * if doing -RH and the symlink wasn't a command line arg.
	 */
	atflags = AT_SYMLINK_NOFOLLOW;

	fts_options = FTS_PHYSICAL;
	if (Rflag) {
		if (hflag)
			errx(1,
		"the -R and -h options may not be specified together.");
		if (Hflag)
			fts_options |= FTS_COMFOLLOW;
		if (Lflag) {
			fts_options &= ~FTS_PHYSICAL;
			fts_options |= FTS_LOGICAL;
			atflags = 0;
		}
	} else if (!hflag) {
		fts_options |= FTS_COMFOLLOW;
		atflags = 0;
	}

	if (ischflags) {
		if (pledge("stdio rpath fattr", NULL) == -1)
			err(1, "pledge");

		flags = *argv;
		if (*flags >= '0' && *flags <= '7') {
			errno = 0;
			val = strtoul(flags, &ep, 8);
			if (val > UINT_MAX)
				errno = ERANGE;
			if (errno)
				err(1, "invalid flags: %s", flags);
			if (*ep)
				errx(1, "invalid flags: %s", flags);
			fset = val;
			oct = 1;
		} else {
			if (strtofflags(&flags, &fset, &fclear))
				errx(1, "invalid flag: %s", flags);
			fclear = ~fclear;
			oct = 0;
		}
	} else if (ischmod) {
		mode = *argv;
		if (*mode >= '0' && *mode <= '7') {
			errno = 0;
			val = strtoul(mode, &ep, 8);
			if (val > INT_MAX)
				errno = ERANGE;
			if (errno)
				err(1, "invalid file mode: %s", mode);
			if (*ep)
				errx(1, "invalid file mode: %s", mode);
			omode = val;
			oct = 1;
		} else {
			if ((set = setmode(mode)) == NULL)
				errx(1, "invalid file mode: %s", mode);
			oct = 0;
		}
	} else if (ischown) {
		/* Both UID and GID are given. */
		if ((cp = strchr(*argv, ':')) != NULL) {
			*cp++ = '\0';
			gid = a_gid(cp);
		}
		/*
		 * UID and GID are separated by a dot and UID exists.
		 * required for backwards compatibility pre-dating POSIX.2
		 * likely to stay here forever
		 */
		else if ((cp = strchr(*argv, '.')) != NULL &&
		    (uid = a_uid(*argv, 1)) == (uid_t)-1) {
			*cp++ = '\0';
			gid = a_gid(cp);
		}
		if (uid == (uid_t)-1)
			uid = a_uid(*argv, 0);
	} else
		gid = a_gid(*argv);

	if ((ftsp = fts_open(++argv, fts_options, 0)) == NULL)
		err(1, NULL);
	for (rval = 0; (p = fts_read(ftsp)) != NULL;) {
		switch (p->fts_info) {
		case FTS_D:
			if (!Rflag)
				fts_set(ftsp, p, FTS_SKIP);
			if (ischmod)
				break;
			else
				continue;
		case FTS_DNR:			/* Warn, chmod, continue. */
			warnc(p->fts_errno, "%s", p->fts_path);
			rval = 1;
			break;
		case FTS_DP:			/* Already changed at FTS_D. */
			if (ischmod)
				continue;
			else
				break;
		case FTS_ERR:			/* Warn, continue. */
		case FTS_NS:
			warnc(p->fts_errno, "%s", p->fts_path);
			rval = 1;
			continue;
		case FTS_SL:			/* Ignore. */
		case FTS_SLNONE:
			/*
			 * The only symlinks that end up here are ones that
			 * don't point to anything or that loop and ones
			 * that we found doing a physical walk.
			 */
			if (!hflag && (fts_options & FTS_LOGICAL))
				continue;
			break;
		default:
			break;
		}

		/*
		 * For -RH, the decision of how to handle symlinks depends
		 * on the level: follow it iff it's a command line arg.
		 */
		if (fts_options & FTS_COMFOLLOW) {
			atflags = p->fts_level == FTS_ROOTLEVEL ? 0 : 
			    AT_SYMLINK_NOFOLLOW;
		}

		if (ischmod) {
			if (!fchmodat(AT_FDCWD, p->fts_accpath, oct ? omode :
			    getmode(set, p->fts_statp->st_mode), atflags)
			    || fflag)
				continue;
		} else if (!ischflags) {
			if (!fchownat(AT_FDCWD, p->fts_accpath, uid, gid,
			    atflags) || fflag)
				continue;
		} else {
			if (!chflagsat(AT_FDCWD, p->fts_accpath, oct ? fset :
			    (p->fts_statp->st_flags | fset) & fclear, atflags))
				continue;
		}

		/* error case */
		warn("%s", p->fts_path);
		rval = 1;
	}
	if (errno)
		err(1, "fts_read");
	fts_close(ftsp);
	return (rval);
}

/*
 * Given a UID or user name in a string, return the UID.  If an empty string
 * was given, returns -1.  If silent is 0, exits on invalid user names/UIDs;
 * otherwise, returns -1.
 */
uid_t
a_uid(const char *s, int silent)
{
	struct passwd *pw;
	const char *errstr;
	uid_t uid;

	if (*s == '\0')			/* Argument was "[:.]gid". */
		return ((uid_t)-1);

	/* User name was given. */
	if ((pw = getpwnam(s)) != NULL)
		return (pw->pw_uid);

	/* UID was given. */
	uid = (uid_t)strtonum(s, 0, UID_MAX, &errstr);
	if (errstr) {
		if (silent)
			return ((uid_t)-1);
		else
			errx(1, "user is %s: %s", errstr, s);
	}

	return (uid);
}

/*
 * Given a GID or group name in a string, return the GID.  If an empty string
 * was given, returns -1.  Exits on invalid user names/UIDs.
 */
gid_t
a_gid(const char *s)
{
	struct group *gr;
	const char *errstr;
	gid_t gid;

	if (*s == '\0')			/* Argument was "uid[:.]". */
		return ((gid_t)-1);

	/* Group name was given. */
	if ((gr = getgrnam(s)) != NULL)
		return (gr->gr_gid);

	/* GID was given. */
	gid = (gid_t)strtonum(s, 0, GID_MAX, &errstr);
	if (errstr)
		errx(1, "group is %s: %s", errstr, s);

	return (gid);
}

static void __dead
usage(void)
{
	fprintf(stderr,
	    "usage: %s [-h] [-R [-H | -L | -P]] %s file ...\n",
	    __progname, ischmod ? "mode" : ischflags ? "flags" :
	    ischown ? "owner[:group]" : "group");
	if (ischown)
		fprintf(stderr,
		    "       %s [-h] [-R [-H | -L | -P]] :group file ...\n",
		    __progname);
	exit(1);
}
@


1.41
log
@In chmod's symbolic mode without -h and -R flags, a missing FTS_COMFOLLOW
flag to fts_open led to the following behavior: the symlink's permissions
were read, changed according to the command line, and transferred to the
target file.  chflags had a similar problem while chmod was unaffected.
Regression introduced in r1.33.  Reported by Christopher Wellons, thanks!

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.40 2016/10/19 18:20:25 schwarze Exp $	*/
d200 5
a204 2
#ifdef SUPPORT_DOT
		/* UID and GID are separated by a dot and UID exists. */
a209 1
#endif
@


1.40
log
@Delete useless setlocale(3) in src/bin/.
Minor cleanup while here: return from main, static void __dead usage, etc.
Based on a patch from Jan Stary <hans at stare dot cz>.
Feedback and OK tb@@, OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.39 2015/12/31 23:38:16 guenther Exp $	*/
d149 2
a150 1
	} else if (!hflag)
d152 1
@


1.39
log
@Document the -h option for chmod and chflags, rewording the chgrp(1) and
chown(8) manpages to be consistent and clearer about it as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.38 2015/10/09 01:37:06 deraadt Exp $	*/
a41 1
#include <locale.h>
d53 1
a53 1
__dead void usage(void);
a69 2
	setlocale(LC_ALL, "");

d281 1
a281 1
	exit(rval);
d341 1
a341 1
void
@


1.38
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.37 2015/10/03 15:00:13 deraadt Exp $	*/
d347 4
a350 8
	if (ischmod || ischflags)
		fprintf(stderr,
		    "usage: %s [-R [-H | -L | -P]] %s file ...\n",
		    __progname, ischmod ? "mode" : "flags");
	else
		fprintf(stderr,
		    "usage: %s [-h] [-R [-H | -L | -P]] %s file ...\n",
		    __progname, ischown ? "owner[:group]" : "group");
@


1.37
log
@oops!  cannot tame the chmod case, because the kernel drops the
setuid/setgid bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.36 2015/10/03 05:05:06 deraadt Exp $	*/
d156 2
a157 2
		if (tame("stdio rpath fattr", NULL) == -1)
			err(1, "tame");
@


1.36
log
@the chmod & chflags codepaths can use tame "stdio rpath fattr".  the
chown codepath obviously cannot use tame -- once tame is activated
the kernel prohibits changing uid/gid on a fd/file.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.35 2015/10/03 03:30:04 deraadt Exp $	*/
a177 3
		if (tame("stdio rpath fattr", NULL) == -1)
			err(1, "tame");

@


1.35
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.34 2015/06/25 02:04:08 uebayasi Exp $	*/
d156 3
d178 3
@


1.34
log
@Put fts_close() where missing.

Not bugs in short-lived commands that call exit() -> _exit() immediately,
but for idempotency.

Originally found in ls(1) by Valgrind.  Changes for other commands are
from deraadt@@.  Reviewed by me, tested in snapshots.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d264 1
a264 2
		}
		else if (!ischflags) {
@


1.33
log
@Correct the handling of symbolic links by chmod/chgrp/chown/chflags,
making them more resistant to TOCTOU race conditions too.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.32 2014/12/13 10:26:48 tobias Exp $	*/
d281 1
@


1.32
log
@Properly validate ranges:

- avoid out of boundary access on very short program names
- fix compiler warning when converting values between 0 and INT_MAX

ok deraadt, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.31 2014/10/06 17:37:34 schwarze Exp $	*/
d38 1
d65 1
a65 1
	int Hflag, Lflag, Rflag, ch, fflag, fts_options, hflag, rval;
a102 7
			/*
			 * In System V (and probably POSIX.2) the -h option
			 * causes chmod to change the mode of the symbolic
			 * link.  4.4BSD's symbolic links don't have modes,
			 * so it's an undocumented noop.  Do syntax checking,
			 * though.
			 */
d134 6
d150 1
d152 2
a153 1
	}
d240 2
a241 2
			 * don't point to anything and ones that we found
			 * doing a physical walk.
d243 1
a243 1
			if (ischflags || ischmod || !hflag)
d249 24
a272 21
		if (ischflags) {
			if (oct) {
				if (!chflags(p->fts_accpath, fset))
					continue;
			} else {
				p->fts_statp->st_flags |= fset;
				p->fts_statp->st_flags &= fclear;
				if (!chflags(p->fts_accpath, p->fts_statp->st_flags))
					continue;
			}
			warn("%s", p->fts_path);
			rval = 1;
		} else if (ischmod && chmod(p->fts_accpath, oct ? omode :
		    getmode(set, p->fts_statp->st_mode)) && !fflag) {
			warn("%s", p->fts_path);
			rval = 1;
		} else if (!ischmod && !ischflags &&
		    (hflag ? lchown(p->fts_accpath, uid, gid) :
		    chown(p->fts_accpath, uid, gid)) && !fflag) {
			warn("%s", p->fts_path);
			rval = 1;
d274 4
@


1.31
log
@In case of invalid syntax like "chmod -Pr -w tf" (trailing mode letter
in a group of option letters), do not silently ignore the syntax error
and do something undefined, but instead error out properly.
Found because miod@@ said "read the code" (not to me, though).

ok doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.30 2014/05/21 06:23:01 guenther Exp $	*/
d61 1
a61 1
	long val;
d72 6
a77 4
	ischown = __progname[2] == 'o';
	ischgrp = __progname[2] == 'g';
	ischmod = __progname[2] == 'm';
	ischflags = __progname[2] == 'f';
d176 2
a177 2
			val = strtol(mode, &ep, 8);
			if (val > INT_MAX || val < 0)
@


1.30
log
@Use errc/warnc to simplify code.

ok jca@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.29 2014/03/16 18:38:30 guenther Exp $	*/
d110 2
a111 4
		 * XXX
		 * "-[rwx]" are valid mode commands.  If they are the entire
		 * argument, getopt has moved past them, so decrement optind.
		 * Regardless, we're done argument processing.
d117 10
a126 4
			if (argv[optind - 1][0] == '-' &&
			    argv[optind - 1][1] == ch &&
			    argv[optind - 1][2] == '\0')
				--optind;
@


1.29
log
@lint is dead (long live the lint!), so stop using it as a cpp conditional
(namespace pollution!) or talking about its opinion on code.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.28 2012/12/04 02:24:46 deraadt Exp $	*/
d215 1
a215 1
			warnx("%s: %s", p->fts_path, strerror(p->fts_errno));
d225 1
a225 1
			warnx("%s: %s", p->fts_path, strerror(p->fts_errno));
@


1.28
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.27 2011/03/09 12:32:02 okan Exp $	*/
a68 4
#ifdef lint
	set = NULL;
	oct = omode = 0;
#endif
@


1.27
log
@zap from usage() as well; reminded by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.26 2010/01/12 19:30:53 jasper Exp $	*/
d33 1
a33 1
#include <sys/param.h>
@


1.26
log
@sync comment with reality, -f won't be documented.

as discussed with jmc@@, otto@@ and millert@@
ok otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.25 2009/10/27 23:59:20 deraadt Exp $	*/
d339 1
a339 1
		    "usage: %s [-fh] [-R [-H | -L | -P]] %s file ...\n",
d343 1
a343 1
		    "       %s [-fh] [-R [-H | -L | -P]] :group file ...\n",
@


1.25
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.24 2009/01/21 16:05:39 sobrado Exp $	*/
d100 1
a100 1
		case 'f':		/* XXX: undocumented. */
@


1.24
log
@fix the synopsis for chown(8)
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.23 2006/04/25 15:41:07 deraadt Exp $	*/
a31 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1989, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)chmod.c	8.8 (Berkeley) 4/1/94";
#else
static const char rcsid[] = "$OpenBSD: chmod.c,v 1.23 2006/04/25 15:41:07 deraadt Exp $";
#endif
#endif /* not lint */
@


1.23
log
@various small lint cleanups; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.22 2006/01/25 06:13:27 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: chmod.c,v 1.22 2006/01/25 06:13:27 tedu Exp $";
d354 5
a358 1
		    __progname, ischown ? "[owner][:group]" : "group");
@


1.22
log
@some warning reduction
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.21 2006/01/25 05:59:42 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: chmod.c,v 1.21 2006/01/25 05:59:42 tedu Exp $";
d76 2
a77 1
	int oct, omode;
d255 1
d307 1
a307 1
	uid = strtonum(s, 0, UID_MAX, &errstr);
d337 1
a337 1
	gid = strtonum(s, 0, GID_MAX, &errstr);
@


1.21
log
@an old diff from tech to convert to using strtonum and some other misc
cleanup. from ray at cyth net
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.20 2005/11/29 20:32:22 otto Exp $	*/
d34 1
a34 1
static char copyright[] =
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.20 2005/11/29 20:32:22 otto Exp $";
d94 2
a95 2
	uid = -1;
	gid = -1;
d144 2
a145 1
done:	argv += optind;
d210 1
a210 1
		    (uid = a_uid(*argv, 1)) == -1) {
d215 1
a215 1
		if (uid == -1)
d298 1
a298 1
		return -1;
d302 1
a302 1
		return pw->pw_uid;
d308 1
a308 1
			return -1;
d313 1
a313 1
	return uid;
d328 1
a328 1
		return -1;
d332 1
a332 1
		return gr->gr_gid;
d339 1
a339 1
	return gid;
@


1.20
log
@kill unused var found by lint. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.19 2005/10/15 08:57:21 jmc Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.19 2005/10/15 08:57:21 jmc Exp $";
d53 3
a56 1
#include <grp.h>
a60 2
#include <limits.h>
#include <locale.h>
d67 1
a67 1
void usage(void);
d201 1
d207 1
d284 5
d293 2
a294 2
	char *ep;
	u_long ul;
d296 1
a296 1
	if (*s == '\0')			/* Argument was "gid[:.]". */
d299 2
a300 1
	if ((pw = getpwnam(s)) != NULL) {
d302 8
a309 13
	} else {
		if ((ul = strtoul(s, &ep, 10)) == ULONG_MAX) {
			if (silent)
				return -1;
			err(1, "%s", s);
		}
		if (*ep != '\0') {
			if (silent)
				return -1;
			errx(1, "%s: invalid user name", s);
		}
		/* XXX long -> int */
		return (uid_t)ul;
d311 2
d315 4
d323 2
a324 2
	char *ep;
	u_long ul;
d326 1
a326 1
	if (*s == '\0')			/* Argument was "gid[:.]". */
d329 2
a330 1
	if ((gr = getgrnam(s)) != NULL) {
d332 7
a338 8
	} else {
		if ((ul = strtoul(s, &ep, 10)) == ULONG_MAX)
			err(1, "%s", s);
		if (*ep != '\0')
			errx(1, "%s: invalid group name", s);
		/* XXX long -> int */
		return (gid_t)ul;
	}
d347 1
a347 1
		    __progname, (ischmod? "mode" : "flags"));
@


1.19
log
@sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.18 2004/07/01 18:25:47 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.18 2004/07/01 18:25:47 otto Exp $";
d77 1
a77 1
	int Hflag, Lflag, Pflag, Rflag, ch, fflag, fts_options, hflag, rval;
d96 1
a96 1
	Hflag = Lflag = Pflag = Rflag = fflag = hflag = 0;
d101 1
a101 1
			Lflag = Pflag = 0;
d105 1
a105 1
			Hflag = Pflag = 0;
a107 1
			Pflag = 1;
@


1.18
log
@setmode(3) returns void *, not mode_t *.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.17 2004/02/16 22:12:02 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.17 2004/02/16 22:12:02 millert Exp $";
d342 1
a342 1
		    "usage: %s [-R [-H | -L | -P]] [-f] [-h] %s file ...\n",
@


1.17
log
@If the user does "chown foo.bar" check to see if foo.bar is a username
before picking it apart into a username.group pair.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.16 2003/06/02 23:32:06 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.16 2003/06/02 23:32:06 millert Exp $";
d74 1
a74 1
	mode_t *set;
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.15 2003/06/01 23:50:02 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.15 2003/06/01 23:50:02 millert Exp $";
d66 1
a66 1
uid_t a_uid(const char *);
d207 2
a208 1
		else if ((cp = strchr(*argv, '.')) != NULL) {
d213 2
a214 1
		uid = a_uid(*argv);
d284 1
a284 1
a_uid(const char *s)
d296 3
a298 1
		if ((ul = strtoul(s, &ep, 10)) == ULONG_MAX)
d300 4
a303 1
		if (*ep != '\0')
d305 1
@


1.15
log
@Undo a misguided attempt to fix speling errors from long ago.  UCB
copyrights say "acknowledgement", not "acknowledgment".  You cannot
just go changing the text of a license willy-nilly.
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.14 2002/07/04 04:26:39 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.14 2002/07/04 04:26:39 deraadt Exp $";
@


1.14
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.13 2002/02/16 21:27:06 millert Exp $	*/
d17 1
a17 1
 *    must display the following acknowledgment:
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.13 2002/02/16 21:27:06 millert Exp $";
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.12 2000/07/31 19:02:38 ericj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.12 2000/07/31 19:02:38 ericj Exp $";
d74 1
a74 3
main(argc, argv)
	int argc;
	char *argv[];
d286 1
a286 2
a_uid(s)
	const char *s;
d302 1
d308 1
a308 2
a_gid(s)
	const char *s;
d324 1
d330 1
a330 1
usage()
a339 1

@


1.12
log
@make -h option work again, it was left out on the getopt string
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.11 2000/07/19 19:42:31 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.11 2000/07/19 19:42:31 mickey Exp $";
d69 3
a71 3
gid_t a_gid __P((const char *));
uid_t a_uid __P((const char *));
void usage __P((void));
@


1.11
log
@merge chflags(1) into chmod.
also, use new strtofflags, avoid ls/stat_flags.c usage.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.10 2000/06/30 16:00:03 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.10 2000/06/30 16:00:03 millert Exp $";
d103 1
a103 1
	while ((ch = getopt(argc, argv, "HLPRXfgorstuwx")) != -1)
@


1.10
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.9 2000/06/09 17:50:16 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.9 2000/06/09 17:50:16 mickey Exp $";
d66 1
a66 1
int ischown, ischgrp, ischmod;
d86 2
a87 1
	char *ep, *mode, *cp;
d98 1
d170 20
a189 1
	if (ischmod) {
d254 1
a254 1
			if (ischmod || !hflag)
d259 13
a271 1
		if (ischmod && chmod(p->fts_accpath, oct ? omode :
d275 1
a275 1
		} else if (!ischmod &&
d334 1
a334 1
	if (ischmod)
d336 2
a337 2
		    "usage: %s [-R [-H | -L | -P]] mode file ...\n",
		    __progname);
@


1.9
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.8 2000/06/09 16:26:51 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.8 2000/06/09 16:26:51 mickey Exp $";
d240 1
a240 1
			warn(p->fts_path);
@


1.8
log
@merge chown/chgrp into chmod.
provide symlinks from old location for the time being.
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.7 1997/11/08 23:26:39 todd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.7 1997/11/08 23:26:39 todd Exp $";
d233 1
a233 1
			if (chmod || !hflag)
@


1.7
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.6 1997/06/28 14:45:43 grr Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.6 1997/06/28 14:45:43 grr Exp $";
d51 1
a51 1
#include <sys/types.h>
d57 2
d66 5
d84 3
a86 1
	char *ep, *mode;
d89 1
a89 1
	omode = 0;
d94 6
d139 2
d168 32
a199 17
	mode = *argv;
	if (*mode >= '0' && *mode <= '7') {
		errno = 0;
		val = strtol(mode, &ep, 8);
		if (val > INT_MAX || val < 0)
			errno = ERANGE;
		if (errno)
			err(1, "invalid file mode: %s", mode);
		if (*ep)
			errx(1, "invalid file mode: %s", mode);
		omode = val;
		oct = 1;
	} else {
		if ((set = setmode(mode)) == NULL)
			errx(1, "invalid file mode: %s", mode);
		oct = 0;
	}
d208 4
a211 1
			break;
d217 4
a220 1
			continue;
d233 2
a234 1
			continue;
d238 1
a238 1
		if (chmod(p->fts_accpath, oct ? omode :
d242 5
d254 44
d301 9
a309 2
	(void)fprintf(stderr,
	    "usage: chmod [-R [-H | -L | -P]] mode file ...\n");
@


1.7.10.1
log
@Pull in patch from current:
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.7 1997/11/08 23:26:39 todd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.7 1997/11/08 23:26:39 todd Exp $";
d201 1
a201 1
			warn("%s", p->fts_path);
@


1.6
log
@somebody added setlocale() w/o locale.h
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.5 1997/06/27 18:37:05 deraadt Exp $	*/
d17 1
a17 1
 *    must display the following acknowledgement:
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.5 1997/06/27 18:37:05 deraadt Exp $";
@


1.5
log
@setlocale; kleink
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.4 1996/12/14 12:17:37 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.4 1996/12/14 12:17:37 mickey Exp $";
d62 1
@


1.4
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.3 1996/08/02 12:40:50 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.3 1996/08/02 12:40:50 deraadt Exp $";
d81 3
@


1.3
log
@zap getopt() case of -?, come on, it is the default!
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.2 1996/06/23 14:19:07 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.2 1996/06/23 14:19:07 deraadt Exp $";
d77 4
a80 1

@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: chmod.c,v 1.12 1995/03/21 09:02:09 cgd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chmod.c,v 1.12 1995/03/21 09:02:09 cgd Exp $";
a121 1
		case '?':
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: chmod.c,v 1.12 1995/03/21 09:02:09 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
