head	1.38;
access;
symbols
	OPENBSD_6_1:1.38.0.8
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.36.0.10
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.36.0.6
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.35.0.10
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.8
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.6
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.4
	OPENBSD_5_0:1.35.0.2
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.33.0.6
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.29.0.16
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.12
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.10
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.8
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.6
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.4
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.23.0.8
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.6
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.4
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.18.0.14
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9:1.18.0.12
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.18.0.10
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.18.0.8
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.18.0.6
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.18.0.4
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.18.0.2
	OPENBSD_2_4_BASE:1.18
	OPENBSD_2_3:1.17.0.6
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.17.0.4
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.17.0.2
	OPENBSD_2_1_BASE:1.17
	OPENBSD_2_0:1.15.0.2
	OPENBSD_2_0_BASE:1.15
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2015.12.30.14.59.10;	author tedu;	state Exp;
branches;
next	1.37;
commitid	pcpM0SacneEDdJB8;

1.37
date	2015.12.06.12.00.16;	author tobias;	state Exp;
branches;
next	1.36;
commitid	CoyY8UEEpJPwBza5;

1.36
date	2013.11.12.04.36.02;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2011.05.05.19.51.48;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2011.04.24.01.13.55;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.09.06.42.59;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.07.01.31.38;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.28.05.17.19;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.14.02.14.25;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2006.06.01.05.42.01;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.27.22.37.03;	author beck;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.22.17.23.27;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.01.18.56.36;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.26.16.23.48;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.23.32.08;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.14.15.00.56;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.04.04.26.40;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.16.18.44.21;	author mpech;	state Exp;
branches;
next	1.18;

1.18
date	98.07.16.22.31.14;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.04.16.04.19.07;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.03.29.21.23.10;	author tholo;	state Exp;
branches;
next	1.15;

1.15
date	96.09.14.03.50.46;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	96.09.02.05.37.10;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.08.10.22.43.00;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.08.10.22.25.58;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.08.02.12.40.59;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.06.17.07.54.38;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.06.17.06.36.29;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.06.17.02.21.53;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.06.12.07.58.41;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.06.11.11.20.22;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.06.10.04.35.05;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.22.12.45.49;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.17.17.01.46;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.03.08.22.02.57;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.15;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.15;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.38
log
@rename a few variables/functions to avoid shadowing
@
text
@/*	$OpenBSD: mt.c,v 1.37 2015/12/06 12:00:16 tobias Exp $	*/
/*	$NetBSD: mt.c,v 1.14.2.1 1996/05/27 15:12:11 mrg Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * mt --
 *   magnetic tape manipulation program
 */
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/mtio.h>
#include <sys/stat.h>
#include <sys/disklabel.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include "mt.h"

struct commands {
	char *c_name;
	int c_code;
	int c_ronly;
	int c_mincount;
} com[] = {
	{ "blocksize",	MTSETBSIZ,  1, 0 },
	{ "bsf",	MTBSF,      1, 1 },
	{ "bsr",	MTBSR,      1, 1 },
	{ "density",	MTSETDNSTY, 1, 1 },
	{ "eof",	MTWEOF,     0, 1 },
	{ "eom",	MTEOM,      1, 1 },
	{ "erase",	MTERASE,    0, 1 },
	{ "fsf",	MTFSF,      1, 1 },
	{ "fsr",	MTFSR,      1, 1 },
	{ "offline",	MTOFFL,     1, 1 },
#define COM_EJECT	9	/* element in the above array */
	{ "rewind",	MTREW,      1, 1 },
	{ "rewoffl",	MTOFFL,     1, 1 },
	{ "status",	MTNOP,      1, 1 },
	{ "retension",	MTRETEN,    1, 1 },
#define COM_RETEN	13	/* element in the above array */
	{ "weof",	MTWEOF,     0, 1 },
	{ NULL }
};

void printreg(char *, u_int, char *);
void status(struct mtget *);
void usage(void);

int		_rmtopendev(char *path, int oflags, int dflags, char **realp);
int		_rmtmtioctop(int fd, struct mtop *cmd);
struct mtget	*_rmtstatus(int fd);
void		_rmtclose(void);

extern char	*__progname;

char	*host = NULL;	/* remote host (if any) */

int
_rmtopendev(char *path, int oflags, int dflags, char **realp)
{
#ifdef RMT
	if (host)
		return rmtopen(path, oflags);
#endif
	return opendev(path, oflags, dflags, realp);
}

int
_rmtmtioctop(int fd, struct mtop *cmd)
{
#ifdef RMT
	if (host)
		return rmtioctl(cmd->mt_op, cmd->mt_count);
#endif
	return ioctl(fd, MTIOCTOP, cmd);
}

struct mtget *
_rmtstatus(int fd)
{
	static struct mtget mt_status;

#ifdef RMT
	if (host)
		return rmtstatus();
#endif
	if (ioctl(fd, MTIOCGET, &mt_status) < 0)
		err(2, "ioctl MTIOCGET");
	return &mt_status;
}

void
_rmtclose(void)
{
#ifdef RMT
	if (host)
		rmtclose();
#endif
}

int	eject = 0;

int
main(int argc, char *argv[])
{
	struct commands *comp;
	struct mtop mt_com;
	int ch, mtfd, flags, insert = 0;
	char *p, *tape, *realtape, *opts;
	size_t len;

	if (strcmp(__progname, "eject") == 0) {
		opts = "t";
		eject = 1;
		tape = NULL;
	} else {
		opts = "f:";
		if ((tape = getenv("TAPE")) == NULL)
			tape = _PATH_DEFTAPE;
	}

	while ((ch = getopt(argc, argv, opts)) != -1) {
		switch (ch) {
		case 't':
			insert = 1;
			break;
		case 'f':
			tape = optarg;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (eject) {
		if (argc == 1) {
			tape = *argv++;
			argc--;
		}
		if (argc != 0)
			usage();
	} else if (argc < 1 || argc > 2)
		usage();

	if (tape == NULL)
		usage();

	if (strchr(tape, ':')) {
#ifdef RMT
		host = tape;
		tape = strchr(host, ':');
		*tape++ = '\0';
		if (rmthost(host) == 0)
			exit(X_ABORT);
#else
		err(1, "no remote support");
#endif
	}

	if (eject) {
		if (insert)
			comp = &com[COM_RETEN];
		else
			comp = &com[COM_EJECT];
	} else {
		len = strlen(p = *argv++);
		for (comp = com;; comp++) {
			if (comp->c_name == NULL)
				errx(1, "%s: unknown command", p);
			if (strncmp(p, comp->c_name, len) == 0)
				break;
		}
	}

	flags = comp->c_ronly ? O_RDONLY : O_WRONLY | O_CREAT;
	/* NOTE: OPENDEV_PART required since cd(4) devices go through here. */
	if ((mtfd = _rmtopendev(tape, flags, OPENDEV_PART, &realtape)) < 0) {
		if (errno != 0)
			warn("%s", host ? tape : realtape);
		exit(2);
	}
	if (comp->c_code != MTNOP) {
		mt_com.mt_op = comp->c_code;
		if (*argv) {
			mt_com.mt_count = strtol(*argv, &p, 10);
			if (mt_com.mt_count < comp->c_mincount || *p)
				errx(2, "%s: illegal count", *argv);
		}
		else
			mt_com.mt_count = 1;
		if (_rmtmtioctop(mtfd, &mt_com) < 0) {
			if (eject)
				err(2, "%s", tape);
			else
				err(2, "%s: %s", tape, comp->c_name);
		}
	} else {
		status(_rmtstatus(mtfd));
	}

	_rmtclose();

	exit(X_FINOK);
	/* NOTREACHED */
}

struct tape_desc {
	short	t_type;		/* type of magtape device */
	char	*t_name;	/* printing name */
	char	*t_dsbits;	/* "drive status" register */
	char	*t_erbits;	/* "error" register */
} tapes[] = {
#define SCSI_DS_BITS	"\20\5WriteProtect\2Mounted"
	{ 0x7,		"SCSI",		SCSI_DS_BITS,	"76543210" },
	{ 0 }
};

/*
 * Interpret the status buffer returned
 */
void
status(struct mtget *bp)
{
	struct tape_desc *mt;

	for (mt = tapes;; mt++) {
		if (mt->t_type == 0) {
			(void)printf("%d: unknown tape drive type\n",
			    bp->mt_type);
			return;
		}
		if (mt->t_type == bp->mt_type)
			break;
	}
	(void)printf("%s tape drive, residual=%d\n", mt->t_name, bp->mt_resid);
	printreg("ds", bp->mt_dsreg, mt->t_dsbits);
	printreg("\ner", bp->mt_erreg, mt->t_erbits);
	(void)putchar('\n');
	(void)printf("blocksize: %d (%d)\n", bp->mt_blksiz, bp->mt_mblksiz);
	(void)printf("density: %d (%d)\n", bp->mt_density, bp->mt_mdensity);
}

/*
 * Print a register a la the %b format of the kernel's printf.
 */
void
printreg(char *s, u_int v, char *bits)
{
	int i, any = 0;
	char c;

	if (bits && *bits == 8)
		printf("%s=%o", s, v);
	else
		printf("%s=%x", s, v);
	if (!bits)
		return;
	bits++;
	if (v && *bits) {
		putchar('<');
		while ((i = *bits++)) {
			if (v & (1 << (i-1))) {
				if (any)
					putchar(',');
				any = 1;
				for (; (c = *bits) > 32; bits++)
					putchar(c);
			} else
				for (; *bits > 32; bits++)
					;
		}
		putchar('>');
	}
}

void
usage(void)
{
	if (eject)
		(void)fprintf(stderr, "usage: %s [-t] device\n", __progname);
	else
		(void)fprintf(stderr,
		    "usage: %s [-f device] command [count]\n", __progname);
	exit(X_USAGE);
}
@


1.37
log
@Use __progname instead of manually handling argv[0].

ok deraadt, mmcc, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.36 2013/11/12 04:36:02 deraadt Exp $	*/
d86 2
a87 2
int		_rmtopendev(char *path, int oflags, int dflags, char **realpath);
int		_rmtmtioctop(int fd, struct mtop *com);
d96 1
a96 1
_rmtopendev(char *path, int oflags, int dflags, char **realpath)
d102 1
a102 1
	return opendev(path, oflags, dflags, realpath);
d106 1
a106 1
_rmtmtioctop(int fd, struct mtop *com)
d110 1
a110 1
		return rmtioctl(com->mt_op, com->mt_count);
d112 1
a112 1
	return ioctl(fd, MTIOCTOP, com);
@


1.36
log
@add a variety of missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.35 2011/05/05 19:51:48 krw Exp $	*/
d91 2
a137 1
char	*progname;
d149 1
a149 6
	if ((progname = strrchr(argv[0], '/')))
		progname++;
	else
		progname = argv[0];

	if (strcmp(progname, "eject") == 0) {
d319 1
a319 1
		(void)fprintf(stderr, "usage: %s [-t] device\n", progname);
d322 1
a322 1
		    "usage: %s [-f device] command [count]\n", progname);
@


1.35
log
@Oops. Put back OPENDEV_PART so 'eject cd0' works again. Pointed out
by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.34 2011/04/24 01:13:55 krw Exp $	*/
d85 5
@


1.34
log
@No point in attempting to open the 'c' partition on devices that have
no 'c' partition. So don't call opendev(3) with OPENDEV_PART.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.33 2009/11/09 06:42:59 deraadt Exp $	*/
d214 2
a215 1
	if ((mtfd = _rmtopendev(tape, flags, 0, &realtape)) < 0) {
@


1.33
log
@simplify the sub-ioctl function
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.32 2009/11/07 01:31:38 deraadt Exp $	*/
d214 1
a214 1
	if ((mtfd = _rmtopendev(tape, flags, OPENDEV_PART, &realtape)) < 0) {
@


1.32
log
@repair local operations after the -DRMT changes; from Matthew Clarke
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.31 2009/10/28 05:17:19 deraadt Exp $	*/
d99 1
a99 1
_rmtioctl(int fd, long req, struct mtop *com)
d139 1
a139 1
	int ch, len, mtfd, flags, insert = 0;
d141 1
d228 1
a228 1
		if (_rmtioctl(mtfd, MTIOCTOP, &mt_com) < 0) {
@


1.31
log
@Add a compile option (-DRMT) which decides if remote tape support (via rcmd)
is supported.  If not, disable it.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.30 2009/10/27 23:59:22 deraadt Exp $	*/
d105 1
a105 1
	return ioctl(fd, MTIOCTOP, &com);
@


1.30
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.29 2006/06/14 02:14:25 krw Exp $	*/
d88 43
a137 1
	struct mtget mt_status;
d186 1
d192 3
d213 1
a213 2
	if ((mtfd = host ? rmtopen(tape, flags) : opendev(tape, flags,
	    OPENDEV_PART, &realtape)) < 0) {
d227 1
a227 2
		if ((host ? rmtioctl(mt_com.mt_op, mt_com.mt_count) :
		    ioctl(mtfd, MTIOCTOP, &mt_com)) < 0) {
d234 1
a234 7
		if (host)
			status(rmtstatus());
		else {
			if (ioctl(mtfd, MTIOCGET, &mt_status) < 0)
				err(2, "ioctl MTIOCGET");
			status(&mt_status);
		}
d237 1
a237 2
	if (host)
		rmtclose();
@


1.29
log
@Nuke only two uses of OPENDEV_DRCT in tree. Nuke OPENDEV_DRCT. Long
marked obsolete since the opendev() behaviour it turned on is now the
default.

'it can go' deraadt@@

'no API of mine has ever made it into a standard' downsj@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.28 2006/06/01 05:42:01 krw Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)mt.c	8.2 (Berkeley) 6/6/93";
#else
static char rcsid[] = "$OpenBSD: mt.c,v 1.28 2006/06/01 05:42:01 krw Exp $";
#endif
#endif /* not lint */
@


1.28
log
@We do not create st devices with different density modes. i.e. with device
minor numbers having bits 2 or 3 set.

Eliminate the quirks, etc. used to store info on these non-existant modes.
Also eliminate a couple of 'unimplemented' fields in the ioctl request
structure.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.27 2006/05/27 22:37:03 beck Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.27 2006/05/27 22:37:03 beck Exp $";
d182 1
a182 1
	    OPENDEV_PART | OPENDEV_DRCT, &realtape)) < 0) {
@


1.27
log
@The last time these were relevant I had a mullet.
no binary change, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.26 2005/12/22 17:23:27 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.26 2005/12/22 17:23:27 deraadt Exp $";
d252 2
a253 6
	(void)printf("blocksize: %d (%d, %d, %d, %d)\n",
		bp->mt_blksiz, bp->mt_mblksiz[0], bp->mt_mblksiz[1],
		bp->mt_mblksiz[2], bp->mt_mblksiz[3]);
	(void)printf("density: %d (%d, %d, %d, %d)\n",
		bp->mt_density, bp->mt_mdensity[0], bp->mt_mdensity[1],
		bp->mt_mdensity[2], bp->mt_mdensity[3]);
@


1.26
log
@if in eject mode, do not include command name in error output; bug spotted by drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.25 2005/05/01 18:56:36 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.25 2005/05/01 18:56:36 deraadt Exp $";
a219 9
#ifdef sun
#include <sundev/tmreg.h>
#include <sundev/arreg.h>
#endif

#ifdef tahoe
#include <tahoe/vba/cyreg.h>
#endif

a225 7
#ifdef sun
	{ MT_ISCPC,	"TapeMaster",	TMS_BITS,	0 },
	{ MT_ISAR,	"Archive",	ARCH_CTRL_BITS,	ARCH_BITS },
#endif
#ifdef tahoe
	{ MT_ISCY,	"cipher",	CYS_BITS,	CYCW_BITS },
#endif
@


1.25
log
@add eject -t option: permits tray to be closed (ie. insert a CD).
this uses the MTRETEN option
split out getopt options for mt & eject, fix usage as well.
ok krw (who is about to commit the back end changes for scsi..)
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.24 2005/04/26 16:23:48 jmc Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.24 2005/04/26 16:23:48 jmc Exp $";
d197 6
a202 2
		    ioctl(mtfd, MTIOCTOP, &mt_com)) < 0)
			err(2, "%s: %s", tape, comp->c_name);
@


1.24
log
@- do not list -f option for eject, as it is not necessary
- tidy up the options list somewhat to avoid confusion
- sync usage()

started by a diff from tom@@ and ok'd by him;
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.23 2003/06/02 23:32:08 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.23 2003/06/02 23:32:08 millert Exp $";
d86 1
d91 1
a94 1
#define COM_EJECT	9	/* element in the above array */
d111 2
a112 2
	int ch, len, mtfd, flags;
	char *p, *tape, *realtape;
d120 1
d124 1
d129 1
a129 1
	while ((ch = getopt(argc, argv, "f:")) != -1) {
d131 3
a148 1

d165 6
a170 3
	if (eject)
		comp = &com[COM_EJECT];
	else {
d309 1
a309 1
		(void)fprintf(stderr, "usage: %s device\n", progname);
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.22 2003/03/14 15:00:56 jmc Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.22 2003/03/14 15:00:56 jmc Exp $";
d301 1
a301 1
		(void)fprintf(stderr, "usage: %s [-f] device\n", progname);
d304 1
a304 1
		    "usage: %s [-f device] command [ count ]\n", progname);
@


1.22
log
@document the -f flag
remove the -t flag (it was an alias to -f)
document that eject ignores $TAPE

doc suggestion from Ross Richardson
-t removal suggested by millert@@

fixes PR 3143
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.21 2002/07/04 04:26:40 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.21 2002/07/04 04:26:40 deraadt Exp $";
@


1.21
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.20 2002/02/16 21:27:07 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.20 2002/02/16 21:27:07 millert Exp $";
d130 1
a130 1
	while ((ch = getopt(argc, argv, "f:t:")) != -1) {
a132 1
		case 't':
@


1.20
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.19 2002/01/16 18:44:21 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.19 2002/01/16 18:44:21 mpech Exp $";
d109 1
a109 3
main(argc, argv)
	int argc;
	char *argv[];
d244 1
a244 2
status(bp)
	struct mtget *bp;
d273 1
a273 4
printreg(s, v, bits)
	char *s;
	u_int v;
	char *bits;
d303 1
a303 1
usage()
@


1.19
log
@missed some registers, kill'em!

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.18 1998/07/16 22:31:14 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.18 1998/07/16 22:31:14 deraadt Exp $";
d99 3
a101 3
void printreg __P((char *, u_int, char *));
void status __P((struct mtget *));
void usage __P((void));
@


1.18
log
@support scsi better; fix another weird bug; mjacob
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.17 1997/04/16 04:19:07 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.17 1997/04/16 04:19:07 millert Exp $";
d113 1
a113 1
	register struct commands *comp;
d247 1
a247 1
	register struct mtget *bp;
d249 1
a249 1
	register struct tape_desc *mt;
d278 2
a279 2
	register u_int v;
	register char *bits;
d281 2
a282 2
	register int i, any = 0;
	register char c;
@


1.17
log
@Use _PATH_DEFTAPE not DEFTAPE in mt(1)
Remove DEFTAPE from <sys/mtio.h> and guard against multiple inclusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.16 1997/03/29 21:23:10 tholo Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.16 1997/03/29 21:23:10 tholo Exp $";
d237 2
a238 1
	{ 0x7,		"SCSI",		"76543210",	"76543210" },
d291 1
a291 1
	if (v && bits) {
@


1.16
log
@Allow setting blocksize to 0 (variable size); from Juergen Hannken-Illjes
<hannken@@eis.cs.tu-bs.de> in NetBSD PR 3256
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.15 1996/09/14 03:50:46 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.15 1996/09/14 03:50:46 millert Exp $";
d129 1
a129 1
			tape = DEFTAPE;
@


1.15
log
@WHen we fail to open tape device, only print an error message if errno
is non-zero.  If errno is 0 then the remote mt already did the message...
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.14 1996/09/02 05:37:10 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.14 1996/09/02 05:37:10 deraadt Exp $";
d78 1
d80 15
a94 15
	{ "blocksize",	MTSETBSIZ, 1 },
	{ "bsf",	MTBSF,	1 },
	{ "bsr",	MTBSR,	1 },
	{ "density",	MTSETDNSTY, 1 },
	{ "eof",	MTWEOF,	0 },
	{ "eom",	MTEOM,	1 },
	{ "erase",	MTERASE, 0 },
	{ "fsf",	MTFSF,	1 },
	{ "fsr",	MTFSR,	1 },
	{ "offline",	MTOFFL,	1 },
	{ "rewind",	MTREW,	1 },
	{ "rewoffl",	MTOFFL,	1 },
	{ "status",	MTNOP,	1 },
	{ "retension",	MTRETEN, 1 },
	{ "weof",	MTWEOF,	0 },
d190 1
a190 1
			if (mt_com.mt_count <= 0 || *p)
@


1.14
log
@not setuid, silence TCP_MAXSEG for non-root
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.13 1996/08/10 22:43:00 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.13 1996/08/10 22:43:00 deraadt Exp $";
d180 5
a184 2
	    OPENDEV_PART | OPENDEV_DRCT, &realtape)) < 0)
		err(2, "%s", host ? tape : realtape);
@


1.13
log
@from bde@@freebsd.org; if printregs() sees no bit names, avoid using them
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.12 1996/08/10 22:25:58 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.12 1996/08/10 22:25:58 deraadt Exp $";
a102 2
uid_t	uid;		/* read uid */
uid_t	euid;		/* effective uid */
a117 4
	uid = getuid();
	euid = geteuid();
	(void) seteuid(uid);

a164 1
	(void) setuid(uid); /* rmthost() is the only reason to be setuid */
@


1.12
log
@%d for formats
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.11 1996/08/02 12:40:59 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.11 1996/08/02 12:40:59 deraadt Exp $";
d290 2
@


1.11
log
@zap getopt() case of -?, come on, it is the default!
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.10 1996/06/17 07:54:38 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.10 1996/06/17 07:54:38 downsj Exp $";
d266 1
a266 1
	(void)printf("blocksize: %ld (%ld, %ld, %ld, %ld)\n",
d269 1
a269 1
	(void)printf("density: %ld (%ld, %ld, %ld, %ld)\n",
@


1.10
log
@opendev.h -> util.h
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.9 1996/06/17 06:36:29 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mt.c,v 1.9 1996/06/17 06:36:29 downsj Exp $";
a142 1
		case '?':
@


1.9
log
@Changed to use the opendev(3) in libutil
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.8 1996/06/17 02:21:53 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD$";
a64 1
#include <opendev.h>
d70 1
d188 1
a188 3
	    OPENDEV_PART | OPENDEV_DRCT,
	    S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH,
	    &realtape)) < 0)
@


1.8
log
@The eject half of mt requires a device, instead of defaulting to the tape.
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.7 1996/06/12 07:58:41 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$NetBSD: mt.c,v 1.14.2.1 1996/05/27 15:12:11 mrg Exp $";
d65 1
a97 1
int opendev __P((char *, int, mode_t, char **));
d188 1
a218 40
}

int
opendev(path, flags, mode, realpath)
	char *path;
	int flags;
	mode_t mode;
	char **realpath;
{
	int fd;
	static char namebuf[256];

	*realpath = path;

	fd = open(path, flags, mode);
	if (fd < 0) {
		if (path[0] != '/') {
			/* first try raw partition (for removable drives) */
			(void)snprintf(namebuf, sizeof(namebuf), "%sr%s%c",
			    _PATH_DEV, path, 'a' + RAW_PART);
			fd = open(namebuf, flags, mode);

			if ((fd < 0) && (errno == ENOENT)) {
				/* ..and now no partition (for tapes) */
				namebuf[strlen(namebuf) - 1] = '\0';
				fd = open(namebuf, flags, mode);
			}

			*realpath = namebuf;
		}
	}
	if ((fd < 0) && (errno == ENOENT) && (path[0] != '/')) {
		(void)snprintf(namebuf, sizeof(namebuf), "%sr%s",
		    _PATH_DEV, path);
		fd = open(namebuf, flags, mode);

		*realpath = namebuf;
	}

	return (fd);
@


1.7
log
@ok, so I didn't think of it last night
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.6 1996/06/11 11:20:22 downsj Exp $	*/
d129 1
a129 1
	if (strcmp(progname, "eject") == 0)
d131 5
a135 3

	if ((tape = getenv("TAPE")) == NULL)
		tape = DEFTAPE;
d160 3
@


1.6
log
@Make eject(1) an alias for mt .. offline, and support disklabel(8) short
form device names.
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.5 1996/06/10 04:35:05 deraadt Exp $	*/
a223 1
	const char *parts = "abcdefgh";	/* enough for now */
d232 1
a232 1
			    _PATH_DEV, path, parts[RAW_PART]);
@


1.5
log
@from mrg; grok scsi tapes
@
text
@d1 1
a1 1
/*	$OpenBSD: mt.c,v 1.4 1996/05/22 12:45:49 deraadt Exp $	*/
d59 1
d63 1
d65 1
d95 1
d97 1
d106 3
d118 1
a118 1
	char *p, *tape;
d124 8
d135 1
a135 1
	while ((ch = getopt(argc, argv, "f:t:")) != -1)
d145 1
d149 9
a157 1
	if (argc < 1 || argc > 2)
d169 10
a178 6
	len = strlen(p = *argv++);
	for (comp = com;; comp++) {
		if (comp->c_name == NULL)
			errx(1, "%s: unknown command", p);
		if (strncmp(p, comp->c_name, len) == 0)
			break;
d182 4
a185 3
	if ((mtfd = host ? rmtopen(tape, flags) : open(tape, flags,
	    S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) < 0)
		err(2, "%s", tape);
d215 41
d349 5
a353 1
	(void)fprintf(stderr, "usage: mt [-f device] command [ count ]\n");
@


1.4
log
@add blocksize/density commands; part of #921; from rhialto@@polder.ubc.kun.nl
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mt.c,v 1.14 1996/05/21 10:23:54 mrg Exp $	*/
d47 1
a47 1
static char rcsid[] = "$NetBSD: mt.c,v 1.14 1996/05/21 10:23:54 mrg Exp $";
d207 1
a207 1
	{ 0x7,		"SCSI tape",	"76543210",	"76543210" },
@


1.3
log
@From NetBSD:  Don't open tapes for writing when repositioning.
That clobbers data!
@
text
@d2 1
a2 1
/*	$NetBSD: mt.c,v 1.12 1996/03/28 07:10:05 scottr Exp $	*/
d47 1
a47 1
static char rcsid[] = "$NetBSD: mt.c,v 1.12 1996/03/28 07:10:05 scottr Exp $";
d75 1
d78 1
d207 1
d233 6
@


1.2
log
@From NetBSD:
Add remote tape capabilities.
Since we're setuid, let's be paranoid.
Picked up a little lint in the dryer.
@
text
@d1 2
a2 1
/*	$NetBSD: mt.c,v 1.11 1996/03/06 06:34:20 scottr Exp $	*/
d47 1
a47 1
static char rcsid[] = "$NetBSD: mt.c,v 1.11 1996/03/06 06:34:20 scottr Exp $";
d58 4
d63 1
a63 1
#include <err.h>
a64 2
#include <stdio.h>
#include <ctype.h>
d107 1
a107 1
	int ch, len, mtfd;
d149 4
a152 2
	if ((mtfd = host ? rmtopen(tape, 2) :
	    open(tape, O_WRONLY|O_CREAT, 0666)) < 0)
d167 1
a167 1
		if (host) {
d169 1
a169 1
		} else {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mt.c,v 1.8 1995/09/28 07:18:20 tls Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: mt.c,v 1.8 1995/09/28 07:18:20 tls Exp $";
d63 3
d92 4
d107 4
d130 9
d146 2
a147 1
	if ((mtfd = open(tape, comp->c_ronly ? O_RDONLY : O_RDWR)) < 0)
d158 2
a159 1
		if (ioctl(mtfd, MTIOCTOP, &mt_com) < 0)
d162 7
a168 3
		if (ioctl(mtfd, MTIOCGET, &mt_status) < 0)
			err(2, "ioctl MTIOCGET");
		status(&mt_status);
d170 5
a174 1
	exit (0);
d246 1
a246 1
		while (i = *bits++) {
d265 1
a265 1
	exit(1);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
