head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.6
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.8
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.20.0.10
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.16
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.16
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.14
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.12
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.10
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.8
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.6
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2015.10.11.20.17.49;	author guenther;	state Exp;
branches;
next	1.23;
commitid	8TNRNeBg6gtuCOwT;

1.23
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	sbrB3Q5CNxcwZpfU;

1.22
date	2015.10.03.03.10.38;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	xcimHYkmEgXH5pPx;

1.21
date	2015.09.22.15.37.06;	author tedu;	state Exp;
branches;
next	1.20;
commitid	masa6Wnz2cTsPXXh;

1.20
date	2013.11.21.15.54.46;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.02.13.20.39.58;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.16.08.35.49;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.32.09;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.06.18.16.59;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.04.04.26.40;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.31.05.18.56;	author pjanzen;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.06.13.29.08;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.20.08.04.48;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.05.01.58.03;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	97.09.12.04.44.32;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.08.19.06.27.52;	author denny;	state Exp;
branches;
next	1.6;

1.6
date	97.06.29.08.09.21;	author denny;	state Exp;
branches;
next	1.5;

1.5
date	97.06.29.07.33.08;	author denny;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.40.28;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.08.02.12.41.09;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.21.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Don't return errno from main()

ok beck@@ doug@@ deraadt@@ tedu@@
@
text
@/*	$OpenBSD: sleep.c,v 1.23 2015/10/09 01:37:06 deraadt Exp $	*/
/*	$NetBSD: sleep.c,v 1.8 1995/03/21 09:11:11 cgd Exp $	*/

/*
 * Copyright (c) 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <err.h>

extern char *__progname;

void usage(void);
void alarmh(int);

int
main(int argc, char *argv[])
{
	int ch;
	time_t secs = 0, t;
	char *cp;
	long nsecs = 0;
	struct timespec rqtp;
	int i;

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	signal(SIGALRM, alarmh);

	while ((ch = getopt(argc, argv, "")) != -1)
		switch(ch) {
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (argc != 1)
		usage();

	cp = *argv;
	while ((*cp != '\0') && (*cp != '.')) {
		if (!isdigit((unsigned char)*cp))
			usage();
		t = (secs * 10) + (*cp++ - '0');
		if (t / 10 != secs)	/* oflow */
			return (EINVAL);
		secs = t;
	}

	/* Handle fractions of a second */
	if (*cp == '.') {
		cp++;
		for (i = 100000000; i > 0; i /= 10) {
			if (*cp == '\0')
				break;
			if (!isdigit((unsigned char)*cp))
				usage();
			nsecs += (*cp++ - '0') * i;
		}

		/*
		 * We parse all the way down to nanoseconds
		 * in the above for loop. Be pedantic about
		 * checking the rest of the argument.
		 */
		while (*cp != '\0') {
			if (!isdigit((unsigned char)*cp++))
				usage();
		}
	}

	rqtp.tv_sec = secs;
	rqtp.tv_nsec = nsecs;

	if ((secs > 0) || (nsecs > 0))
		if (nanosleep(&rqtp, NULL))
			err(1, NULL);
	return (0);
}

void
usage(void)
{
	(void)fprintf(stderr, "usage: %s seconds\n", __progname);
	exit(1);
}

/*
 * POSIX 1003.2 says sleep should exit with 0 return code on reception
 * of SIGALRM.
 */
/* ARGSUSED */
void
alarmh(int signo)
{
	/*
	 * exit() flushes stdio buffers, which is not legal in a signal
	 * handler. Use _exit().
	 */
	_exit(0);
}
@


1.23
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.22 2015/10/03 03:10:38 deraadt Exp $	*/
d110 1
a110 1
			return (errno);
@


1.22
log
@So you'd love me to say sleep() can be tighter than tame "stdio".  OK,
there is that pesky usage message...  We could tame "something" in the
non-usage codepath.. but pop quiz, anyone know what happens after main
returns or if exit(3) is called?  atexit completion..  our atexit is
very paranoid with structure management and uses mprotect.  So current
minimum a normal program needs is tame "malloc".

tame "stdio" done before the usage codepath splits is just as good;
tame placement before getopt provides a strong hint about program
behaviour.

I am still hoping someone comes up with a nice solution for atexit,
or a nice tame subset between "" (pure computation) and "malloc".
Ideas have been floated to expose "self", but it lacks mprotect also,
and should continue to lack it (see the ssh tame sandbox).
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.21 2015/09/22 15:37:06 tedu Exp $	*/
d57 2
a58 2
	if (tame("stdio", NULL) == -1)
		err(1, "tame");
@


1.21
log
@sleep doesn't benefit from setting locale. we always want to parse numbers
as our forefathers did, and it doesn't print any error messages in need of
translation.
ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.20 2013/11/21 15:54:46 deraadt Exp $	*/
d40 1
d56 3
@


1.20
log
@add unsigned char casts for specific calls to ctype.h macros.
ok guenther step
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.19 2009/10/27 23:59:22 deraadt Exp $	*/
a34 1
#include <locale.h>
a54 2

	setlocale(LC_ALL, "");
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.18 2009/02/13 20:39:58 deraadt Exp $	*/
d74 1
a74 1
		if (!isdigit(*cp))
d88 1
a88 1
			if (!isdigit(*cp))
d99 1
a99 1
			if (!isdigit(*cp++))
@


1.18
log
@argv space does not need to be trashed during parsing
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.17 2004/09/16 08:35:49 deraadt Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1988, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)sleep.c	8.3 (Berkeley) 4/2/94";
#else
static char rcsid[] = "$OpenBSD: sleep.c,v 1.17 2004/09/16 08:35:49 deraadt Exp $";
#endif
#endif /* not lint */
@


1.17
log
@ARGSUSED on signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.16 2003/06/02 23:32:09 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.16 2003/06/02 23:32:09 millert Exp $";
d98 1
a98 1
		*cp++ = '\0';
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.15 2002/09/06 18:16:59 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.15 2002/09/06 18:16:59 deraadt Exp $";
d138 1
d140 1
a140 1
alarmh(int sigraised)
@


1.15
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.14 2002/07/04 04:26:40 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.14 2002/07/04 04:26:40 deraadt Exp $";
@


1.14
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.13 2002/05/31 05:18:56 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.13 2002/05/31 05:18:56 pjanzen Exp $";
d70 1
a70 1
	unsigned char *cp;
d92 2
a93 1
		if (!isdigit(*cp)) usage();
d104 4
a107 2
			if (*cp == '\0') break;
			if (!isdigit(*cp)) usage();
d117 2
a118 1
			if (!isdigit(*cp++)) usage();
@


1.13
log
@Don't include cases for characters not in optstring; ericj.  Snuck in on my
last commit here.
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.12 2002/02/16 21:27:07 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.12 2002/02/16 21:27:07 millert Exp $";
d66 1
a66 3
main(argc, argv)
	int argc;
	char *argv[];
d128 1
a128 1
usage()
d139 1
a139 2
alarmh(sigraised)
	int sigraised;
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.11 2001/09/06 13:29:08 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.11 2001/09/06 13:29:08 mpech Exp $";
a82 2
		case '?':
		case 'h':
@


1.11
log
@o) __progname aria;

millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.10 2001/05/20 08:04:48 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.10 2001/05/20 08:04:48 mickey Exp $";
d62 2
a63 2
void usage __P((void));
void alarmh __P((int));
@


1.10
log
@trade 3 exits for return
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.9 2000/01/05 01:58:03 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.9 2000/01/05 01:58:03 pjanzen Exp $";
d60 2
d134 1
a134 2

	(void)fprintf(stderr, "usage: sleep seconds\n");
@


1.9
log
@Return EINVAL if we can't sleep for the specified time interval (i.e. it's
too long); problem noted by viha@@vip.fi
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.8 1997/09/12 04:44:32 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.8 1997/09/12 04:44:32 millert Exp $";
d97 1
a97 1
			exit(EINVAL);
d125 2
a126 2
			exit(errno);
	exit(0);
@


1.8
log
@#include <ctype.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.7 1997/08/19 06:27:52 denny Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.7 1997/08/19 06:27:52 denny Exp $";
d51 4
d57 1
a58 4
#include <ctype.h>
#include <locale.h>
#include <time.h>
#include <signal.h>
d69 1
a69 1
	int secs = 0;
d81 2
d95 4
a98 1
		secs = (secs * 10) + (*cp++ - '0');
d120 1
a120 1
	rqtp.tv_sec = (time_t) secs;
d124 2
a125 1
		(void)nanosleep(&rqtp, NULL);
@


1.7
log
@POSIX 1003.2: exit w/ 0 code if receive SIGALRM.
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.6 1997/06/29 08:09:21 denny Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.6 1997/06/29 08:09:21 denny Exp $";
d54 1
@


1.6
log
@Reject non-numeric argument (so can't use atoi).
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.5 1997/06/29 07:33:08 denny Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.5 1997/06/29 07:33:08 denny Exp $";
d56 1
d59 1
d75 2
d102 9
d127 15
@


1.5
log
@Make sleep handle fractions of a second. Why not?
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.4 1997/01/15 23:40:28 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.4 1997/01/15 23:40:28 millert Exp $";
a54 1
#include <string.h>
d66 1
a66 1
	unsigned char *fp;
d69 1
d84 6
d91 2
a92 5
	fp = strchr(*argv, '.');
	if (fp != NULL) {
		int i;

		*fp++ = '\0';
d94 3
a96 2
			if (*fp == '\0') break;
			nsecs += (*fp++ - '0') * i;
a98 2

	secs = atoi(*argv);
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.3 1996/08/02 12:41:09 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.3 1996/08/02 12:41:09 deraadt Exp $";
d55 2
d65 5
a69 1
	int ch, secs;
d84 19
a102 2
	if ((secs = atoi(*argv)) > 0)
		(void)sleep(secs);
@


1.3
log
@zap getopt() case of -?, come on, it is the default!
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.2 1996/06/23 14:21:48 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.2 1996/06/23 14:21:48 deraadt Exp $";
d67 1
a67 1
	while ((ch = getopt(argc, argv, "")) != EOF)
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: sleep.c,v 1.8 1995/03/21 09:11:11 cgd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: sleep.c,v 1.8 1995/03/21 09:11:11 cgd Exp $";
a68 1
		case '?':
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: sleep.c,v 1.8 1995/03/21 09:11:11 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
