head	1.22;
access;
symbols
	OPENBSD_6_1:1.22.0.6
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.13.0.22
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.20
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.16
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.14
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.12
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.10
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.28
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.24
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.22
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.20
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.18
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.16
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.14
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.12
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.10
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.18
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.16
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2015.12.26.13.48.38;	author mestre;	state Exp;
branches;
next	1.21;
commitid	jZMsEASvreUUSdqp;

1.21
date	2015.12.22.08.18.36;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	FjEkvT5GZye1W1a2;

1.20
date	2015.10.26.22.03.06;	author naddy;	state Exp;
branches;
next	1.19;
commitid	jREL04iPW8d08lKc;

1.19
date	2015.10.26.15.01.15;	author naddy;	state Exp;
branches;
next	1.18;
commitid	gs7LRmKw8OfepnU6;

1.18
date	2015.06.17.03.48.21;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	oHdhnDXEPqwM6LiV;

1.17
date	2015.02.08.06.01.25;	author tedu;	state Exp;
branches;
next	1.16;
commitid	tnCfmqNIkMr95MJy;

1.16
date	2015.02.08.05.47.28;	author tedu;	state Exp;
branches;
next	1.15;
commitid	UHj0KNSjy07xS7rI;

1.15
date	2015.01.16.06.39.31;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	Uu5nFG3wCl0LACBb;

1.14
date	2014.10.16.19.43.31;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	jIHreojPTUQy0Zyb;

1.13
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.25.21.12.39;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.11.21.09.50;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.32.07;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.08.06.54.16;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.09.01.18.40.50;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.07.25.18.58.08;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.07.23.14.36.50;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Replace handrolled xfree() function by directly using free(3)

OK mmcc@@
@
text
@/*	$OpenBSD: glob.c,v 1.21 2015/12/22 08:18:36 mmcc Exp $	*/
/*	$NetBSD: glob.c,v 1.10 1995/03/21 09:03:01 cgd Exp $	*/

/*-
 * Copyright (c) 1980, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <glob.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <stdarg.h>

#include "csh.h"
#include "extern.h"

static int noglob;
static int pargsiz, gargsiz;

/*
 * Values for gflag
 */
#define	G_NONE	0		/* No globbing needed			*/
#define	G_GLOB	1		/* string contains *?[] characters	*/
#define	G_CSH	2		/* string contains ~`{ characters	*/

#define	GLOBSPACE	100	/* Alloc increment			*/

#define LBRC '{'
#define RBRC '}'
#define LBRK '['
#define RBRK ']'
#define EOS '\0'

Char  **gargv = NULL;
long    gargc = 0;
Char  **pargv = NULL;
long    pargc = 0;

/*
 * globbing is now done in two stages. In the first pass we expand
 * csh globbing idioms ~`{ and then we proceed doing the normal
 * globbing if needed ?*[
 *
 * Csh type globbing is handled in globexpand() and the rest is
 * handled in glob() which is part of the 4.4BSD libc.
 *
 */
static Char	*globtilde(Char **, Char *);
static Char	**libglob(Char **);
static Char	**globexpand(Char **);
static int	globbrace(Char *, Char *, Char ***);
static void	expbrace(Char ***, Char ***, int);
static int	pmatch(Char *, Char *);
static void	pword(void);
static void	psave(int);
static void	backeval(Char *, bool);


static Char *
globtilde(Char **nv, Char *s)
{
    Char    gbuf[PATH_MAX], *gstart, *b, *u, *e;

    gstart = gbuf;
    *gstart++ = *s++;
    u = s;
    for (b = gstart, e = &gbuf[PATH_MAX - 1];
	 *s && *s != '/' && *s != ':' && b < e;
	 *b++ = *s++)
	 continue;
    *b = EOS;
    if (gethdir(gstart, &gbuf[sizeof(gbuf)/sizeof(Char)] - gstart)) {
	blkfree(nv);
	if (*gstart)
	    stderror(ERR_UNKUSER, vis_str(gstart));
	else
	    stderror(ERR_NOHOME);
    }
    b = &gstart[Strlen(gstart)];
    while (*s)
	*b++ = *s++;
    *b = EOS;
    --u;
    free(u);
    return (Strsave(gstart));
}

static int
globbrace(Char *s, Char *p, Char ***bl)
{
    int     i, len;
    Char   *pm, *pe, *lm, *pl;
    Char  **nv, **vl;
    Char    gbuf[PATH_MAX];
    int     size = GLOBSPACE;

    nv = vl = xreallocarray(NULL, size, sizeof(Char *));
    *vl = NULL;

    len = 0;
    /* copy part up to the brace */
    for (lm = gbuf, p = s; *p != LBRC; *lm++ = *p++)
	continue;

    /* check for balanced braces */
    for (i = 0, pe = ++p; *pe; pe++)
	if (*pe == LBRK) {
	    /* Ignore everything between [] */
	    for (++pe; *pe != RBRK && *pe != EOS; pe++)
		continue;
	    if (*pe == EOS) {
		blkfree(nv);
		return (-RBRK);
	    }
	}
	else if (*pe == LBRC)
	    i++;
	else if (*pe == RBRC) {
	    if (i == 0)
		break;
	    i--;
	}

    if (i != 0 || *pe == '\0') {
	blkfree(nv);
	return (-RBRC);
    }

    for (i = 0, pl = pm = p; pm <= pe; pm++)
	switch (*pm) {
	case LBRK:
	    for (++pm; *pm != RBRK && *pm != EOS; pm++)
		continue;
	    if (*pm == EOS) {
		*vl = NULL;
		blkfree(nv);
		return (-RBRK);
	    }
	    break;
	case LBRC:
	    i++;
	    break;
	case RBRC:
	    if (i) {
		i--;
		break;
	    }
	    /* FALLTHROUGH */
	case ',':
	    if (i && *pm == ',')
		break;
	    else {
		Char    savec = *pm;

		*pm = EOS;
		(void) Strlcpy(lm, pl, &gbuf[sizeof(gbuf)/sizeof(Char)] - lm);
		(void) Strlcat(gbuf, pe + 1, PATH_MAX);
		*pm = savec;
		*vl++ = Strsave(gbuf);
		len++;
		pl = pm + 1;
		if (vl == &nv[size]) {
		    size += GLOBSPACE;
		    nv = xreallocarray(nv, size, sizeof(Char *));
		    vl = &nv[size - GLOBSPACE];
		}
	    }
	    break;
	default:
	    break;
	}
    *vl = NULL;
    *bl = nv;
    return (len);
}


static void
expbrace(Char ***nvp, Char ***elp, int size)
{
    Char **vl, **el, **nv, *s;

    vl = nv = *nvp;
    if (elp != NULL)
	el = *elp;
    else
	for (el = vl; *el; el++)
	    continue;

    for (s = *vl; s; s = *++vl) {
	Char   *b;
	Char  **vp, **bp;

	/* leave {} untouched for find */
	if (s[0] == '{' && (s[1] == '\0' || (s[1] == '}' && s[2] == '\0')))
	    continue;
	if ((b = Strchr(s, '{')) != NULL) {
	    Char  **bl;
	    int     len;

	    if ((len = globbrace(s, b, &bl)) < 0) {
		free(nv);
		stderror(ERR_MISSING, -len);
	    }
	    free(s);
	    if (len == 1) {
		*vl-- = *bl;
		free(bl);
		continue;
	    }
	    len = blklen(bl);
	    if (&el[len] >= &nv[size]) {
		int     l, e;

		l = &el[len] - &nv[size];
		size += GLOBSPACE > l ? GLOBSPACE : l;
		l = vl - nv;
		e = el - nv;
		nv = xreallocarray(nv, size, sizeof(Char *));
		vl = nv + l;
		el = nv + e;
	    }
	    vp = vl--;
	    *vp = *bl;
	    len--;
	    for (bp = el; bp != vp; bp--)
		bp[len] = *bp;
	    el += len;
	    vp++;
	    for (bp = bl + 1; *bp; *vp++ = *bp++)
		continue;
	    free(bl);
	}

    }
    if (elp != NULL)
	*elp = el;
    *nvp = nv;
}

static Char **
globexpand(Char **v)
{
    Char   *s;
    Char  **nv, **vl, **el;
    int     size = GLOBSPACE;


    nv = vl = xreallocarray(NULL, size, sizeof(Char *));
    *vl = NULL;

    /*
     * Step 1: expand backquotes.
     */
    while ((s = *v++) != NULL) {
	if (Strchr(s, '`')) {
	    int     i;

	    (void) dobackp(s, 0);
	    for (i = 0; i < pargc; i++) {
		*vl++ = pargv[i];
		if (vl == &nv[size]) {
		    size += GLOBSPACE;
		    nv = xreallocarray(nv, size, sizeof(Char *));
		    vl = &nv[size - GLOBSPACE];
		}
	    }
	    free(pargv);
	    pargv = NULL;
	}
	else {
	    *vl++ = Strsave(s);
	    if (vl == &nv[size]) {
		size += GLOBSPACE;
		nv = xreallocarray(nv, size, sizeof(Char *));
		vl = &nv[size - GLOBSPACE];
	    }
	}
    }
    *vl = NULL;

    if (noglob)
	return (nv);

    /*
     * Step 2: expand braces
     */
    el = vl;
    expbrace(&nv, &el, size);

    /*
     * Step 3: expand ~
     */
    vl = nv;
    for (s = *vl; s; s = *++vl)
	if (*s == '~')
	    *vl = globtilde(nv, s);
    vl = nv;
    return (vl);
}

static Char *
handleone(Char *str, Char **vl, int action)
{

    Char   *cp, **vlp = vl;

    switch (action) {
    case G_ERROR:
	setname(vis_str(str));
	blkfree(vl);
	stderror(ERR_NAME | ERR_AMBIG);
	break;
    case G_APPEND:
	trim(vlp);
	str = Strsave(*vlp++);
	do {
	    cp = Strspl(str, STRspace);
	    free(str);
	    str = Strspl(cp, *vlp);
	    free(cp);
	}
	while (*++vlp)
	    ;
	blkfree(vl);
	break;
    case G_IGNORE:
	str = Strsave(strip(*vlp));
	blkfree(vl);
	break;
    default:
	break;
    }
    return (str);
}

static Char **
libglob(Char **vl)
{
    int     gflgs = GLOB_QUOTE | GLOB_NOMAGIC;
    glob_t  globv;
    char   *ptr;
    int     nonomatch = adrof(STRnonomatch) != 0, magic = 0, match = 0;

    if (!vl || !vl[0])
	return (vl);

    globv.gl_offs = 0;
    globv.gl_pathv = 0;
    globv.gl_pathc = 0;

    if (nonomatch)
	gflgs |= GLOB_NOCHECK;

    do {
	ptr = short2qstr(*vl);
	switch (glob(ptr, gflgs, 0, &globv)) {
	case GLOB_ABORTED:
	    setname(vis_str(*vl));
	    stderror(ERR_NAME | ERR_GLOB);
	    /* NOTREACHED */
	case GLOB_NOSPACE:
	    stderror(ERR_NOMEM);
	    /* NOTREACHED */
	default:
	    break;
	}
	if (globv.gl_flags & GLOB_MAGCHAR) {
	    match |= (globv.gl_matchc != 0);
	    magic = 1;
	}
	gflgs |= GLOB_APPEND;
    }
    while (*++vl)
	;
    vl = (globv.gl_pathc == 0 || (magic && !match && !nonomatch)) ?
	NULL : blk2short(globv.gl_pathv);
    globfree(&globv);
    return (vl);
}

Char   *
globone(Char *str, int action)
{
    Char   *v[2], **vl, **vo;
    int    gflg;

    noglob = adrof(STRnoglob) != 0;
    gflag = 0;
    v[0] = str;
    v[1] = 0;
    tglob(v);
    gflg = gflag;
    if (gflg == G_NONE)
	return (strip(Strsave(str)));

    if (gflg & G_CSH) {
	/*
	 * Expand back-quote, tilde and brace
	 */
	vo = globexpand(v);
	if (noglob || (gflg & G_GLOB) == 0) {
	    if (vo[0] == NULL) {
		free(vo);
		return (Strsave(STRNULL));
	    }
	    if (vo[1] != NULL)
		return (handleone(str, vo, action));
	    else {
		str = strip(vo[0]);
		free(vo);
		return (str);
	    }
	}
    }
    else if (noglob || (gflg & G_GLOB) == 0)
	return (strip(Strsave(str)));
    else
	vo = v;

    vl = libglob(vo);
    if ((gflg & G_CSH) && vl != vo)
	blkfree(vo);
    if (vl == NULL) {
	setname(vis_str(str));
	stderror(ERR_NAME | ERR_NOMATCH);
    }
    if (vl[0] == NULL) {
	free(vl);
	return (Strsave(STRNULL));
    }
    if (vl[1] != NULL)
	return (handleone(str, vl, action));
    else {
	str = strip(*vl);
	free(vl);
	return (str);
    }
}

Char  **
globall(Char **v)
{
    Char  **vl, **vo;
    int   gflg = gflag;

    if (!v || !v[0]) {
	gargv = saveblk(v);
	gargc = blklen(gargv);
	return (gargv);
    }

    noglob = adrof(STRnoglob) != 0;

    if (gflg & G_CSH)
	/*
	 * Expand back-quote, tilde and brace
	 */
	vl = vo = globexpand(v);
    else
	vl = vo = saveblk(v);

    if (!noglob && (gflg & G_GLOB)) {
	vl = libglob(vo);
	if ((gflg & G_CSH) && vl != vo)
	    blkfree(vo);
    }
    else
	trim(vl);

    gargc = vl ? blklen(vl) : 0;
    return (gargv = vl);
}

void
ginit(void)
{
    gargsiz = GLOBSPACE;
    gargv = xreallocarray(NULL, gargsiz, sizeof(Char *));
    gargv[0] = 0;
    gargc = 0;
}

void
rscan(Char **t, void (*f)(int))
{
    Char *p;

    while ((p = *t++) != NULL)
	while (*p)
	    (*f) (*p++);
}

void
trim(Char **t)
{
    Char *p;

    while ((p = *t++) != NULL)
	while (*p)
	    *p++ &= TRIM;
}

void
tglob(Char **t)
{
    Char *p, c;

    while ((p = *t++) != NULL) {
	if (*p == '~' || *p == '=')
	    gflag |= G_CSH;
	else if (*p == '{' &&
		 (p[1] == '\0' || (p[1] == '}' && p[2] == '\0')))
	    continue;
	while ((c = *p++) != '\0') {
	    /*
	     * eat everything inside the matching backquotes
	     */
	    if (c == '`') {
		gflag |= G_CSH;
		while (*p && *p != '`')
		    if (*p++ == '\\') {
			if (*p)		/* Quoted chars */
			    p++;
			else
			    break;
		    }
		if (*p)			/* The matching ` */
		    p++;
		else
		    break;
	    }
	    else if (c == '{')
		gflag |= G_CSH;
	    else if (isglob(c))
		gflag |= G_GLOB;
	}
    }
}

/*
 * Command substitute cp.  If literal, then this is a substitution from a
 * << redirection, and so we should not crunch blanks and tabs, separating
 * words only at newlines.
 */
Char  **
dobackp(Char *cp, bool literal)
{
    Char *lp, *rp;
    Char   *ep, word[PATH_MAX];

    if (pargv) {
	blkfree(pargv);
    }
    pargsiz = GLOBSPACE;
    pargv = xreallocarray(NULL, pargsiz, sizeof(Char *));
    pargv[0] = NULL;
    pargcp = pargs = word;
    pargc = 0;
    pnleft = PATH_MAX - 4;
    for (;;) {
	for (lp = cp; *lp != '`'; lp++) {
	    if (*lp == 0) {
		if (pargcp != pargs)
		    pword();
		return (pargv);
	    }
	    psave(*lp);
	}
	lp++;
	for (rp = lp; *rp && *rp != '`'; rp++)
	    if (*rp == '\\') {
		rp++;
		if (!*rp)
		    goto oops;
	    }
	if (!*rp)
    oops:  stderror(ERR_UNMATCHED, '`');
	ep = Strsave(lp);
	ep[rp - lp] = 0;
	backeval(ep, literal);
	cp = rp + 1;
    }
}

static void
backeval(Char *cp, bool literal)
{
    int icnt, c;
    Char *ip;
    struct command faket;
    bool    hadnl;
    int     pvec[2], quoted;
    Char   *fakecom[2], ibuf[BUFSIZ];
    char    tibuf[BUFSIZ];

    hadnl = 0;
    icnt = 0;
    quoted = (literal || (cp[0] & QUOTE)) ? QUOTE : 0;
    faket.t_dtyp = NODE_COMMAND;
    faket.t_dflg = 0;
    faket.t_dlef = 0;
    faket.t_drit = 0;
    faket.t_dspr = 0;
    faket.t_dcom = fakecom;
    fakecom[0] = STRfakecom1;
    fakecom[1] = 0;

    /*
     * We do the psave job to temporarily change the current job so that the
     * following fork is considered a separate job.  This is so that when
     * backquotes are used in a builtin function that calls glob the "current
     * job" is not corrupted.  We only need one level of pushed jobs as long as
     * we are sure to fork here.
     */
    psavejob();

    /*
     * It would be nicer if we could integrate this redirection more with the
     * routines in sh.sem.c by doing a fake execute on a builtin function that
     * was piped out.
     */
    mypipe(pvec);
    if (pfork(&faket, -1) == 0) {
	struct wordent paraml;
	struct command *t;

	(void) close(pvec[0]);
	(void) dmove(pvec[1], 1);
	(void) dmove(SHERR, 2);
	initdesc();
	/*
	 * Bugfix for nested backquotes by Michael Greim <greim@@sbsvax.UUCP>,
	 * posted to comp.bugs.4bsd 12 Sep. 1989.
	 */
	if (pargv)		/* mg, 21.dec.88 */
	    blkfree(pargv), pargv = 0, pargsiz = 0;
	/* mg, 21.dec.88 */
	arginp = cp;
	while (*cp)
	    *cp++ &= TRIM;

	/*
	 * In the child ``forget'' everything about current aliases or
	 * eval vectors.
	 */
	alvec = NULL;
	evalvec = NULL;
	alvecp = NULL;
	evalp = NULL;
	(void) lex(&paraml);
	if (seterr)
	    stderror(ERR_OLD);
	alias(&paraml);
	t = syntax(paraml.next, &paraml, 0);
	if (seterr)
	    stderror(ERR_OLD);
	if (t)
	    t->t_dflg |= F_NOFORK;
	(void) signal(SIGTSTP, SIG_IGN);
	(void) signal(SIGTTIN, SIG_IGN);
	(void) signal(SIGTTOU, SIG_IGN);
	execute(t, -1, NULL, NULL);
	exitstat();
    }
    free(cp);
    (void) close(pvec[1]);
    c = 0;
    ip = NULL;
    do {
	int     cnt = 0;

	for (;;) {
	    if (icnt == 0) {
		int     i;

		ip = ibuf;
		do
		    icnt = read(pvec[0], tibuf, BUFSIZ);
		while (icnt == -1 && errno == EINTR);
		if (icnt <= 0) {
		    c = -1;
		    break;
		}
		for (i = 0; i < icnt; i++)
		    ip[i] = (unsigned char) tibuf[i];
	    }
	    if (hadnl)
		break;
	    --icnt;
	    c = (*ip++ & TRIM);
	    if (c == 0)
		break;
	    if (c == '\n') {
		/*
		 * Continue around the loop one more time, so that we can eat
		 * the last newline without terminating this word.
		 */
		hadnl = 1;
		continue;
	    }
	    if (!quoted && (c == ' ' || c == '\t'))
		break;
	    cnt++;
	    psave(c | quoted);
	}
	/*
	 * Unless at end-of-file, we will form a new word here if there were
	 * characters in the word, or in any case when we take text literally.
	 * If we didn't make empty words here when literal was set then we
	 * would lose blank lines.
	 */
	if (c != -1 && (cnt || literal))
	    pword();
	hadnl = 0;
    } while (c >= 0);
    (void) close(pvec[0]);
    pwait();
    prestjob();
}

static void
psave(int c)
{
    if (--pnleft <= 0)
	stderror(ERR_WTOOLONG);
    *pargcp++ = c;
}

static void
pword(void)
{
    psave(0);
    if (pargc == pargsiz - 1) {
	pargsiz += GLOBSPACE;
	pargv = xreallocarray(pargv, pargsiz, sizeof(Char *));
    }
    pargv[pargc++] = Strsave(pargs);
    pargv[pargc] = NULL;
    pargcp = pargs;
    pnleft = PATH_MAX - 4;
}

int
Gmatch(Char *string, Char *pattern)
{
    Char **blk, **p;
    int	   gpol = 1, gres = 0;

    if (*pattern == '^') {
	gpol = 0;
	pattern++;
    }

    blk = xreallocarray(NULL, GLOBSPACE, sizeof(Char *));
    blk[0] = Strsave(pattern);
    blk[1] = NULL;

    expbrace(&blk, NULL, GLOBSPACE);

    for (p = blk; *p; p++)
	gres |= pmatch(string, *p);

    blkfree(blk);
    return(gres == gpol);
}

static int
pmatch(Char *string, Char *pattern)
{
    Char stringc, patternc;
    int     match, negate_range;
    Char    rangec;

    for (;; ++string) {
	stringc = *string & TRIM;
	patternc = *pattern++;
	switch (patternc) {
	case 0:
	    return (stringc == 0);
	case '?':
	    if (stringc == 0)
		return (0);
	    break;
	case '*':
	    if (!*pattern)
		return (1);
	    while (*string)
		if (Gmatch(string++, pattern))
		    return (1);
	    return (0);
	case '[':
	    match = 0;
	    if ((negate_range = (*pattern == '^')) != 0)
		pattern++;
	    while ((rangec = *pattern++) != '\0') {
		if (rangec == ']')
		    break;
		if (match)
		    continue;
		if (rangec == '-' && *(pattern-2) != '[' && *pattern  != ']') {
		    match = (stringc <= (*pattern & TRIM) &&
			      (*(pattern-2) & TRIM) <= stringc);
		    pattern++;
		}
		else
		    match = (stringc == (rangec & TRIM));
	    }
	    if (rangec == 0)
		stderror(ERR_NAME | ERR_MISSING, ']');
	    if (match == negate_range)
		return (0);
	    break;
	default:
	    if ((patternc & TRIM) != stringc)
		return (0);
	    break;

	}
    }
}

void
Gcat(Char *s1, Char *s2)
{
    Char *p, *q;
    int     n;

    for (p = s1; *p++;)
	continue;
    for (q = s2; *q++;)
	continue;
    n = (p - s1) + (q - s2) - 1;
    if (++gargc >= gargsiz) {
	gargsiz += GLOBSPACE;
	gargv = xreallocarray(gargv, gargsiz, sizeof(Char *));
    }
    gargv[gargc] = 0;
    p = gargv[gargc - 1] = xreallocarray(NULL, n, sizeof(Char));
    for (q = s1; (*p++ = *q++) != '\0';)
	continue;
    for (p--, q = s2; (*p++ = *q++) != '\0';)
	continue;
}

int
sortscmp(const void *a, const void *b)
{
    char    buf[2048];

    if (!a)			/* check for NULL */
	return (b ? 1 : 0);
    if (!b)
	return (-1);

    if (!*(Char **)a)			/* check for NULL */
	return (*(Char **)b ? 1 : 0);
    if (!*(Char **)b)
	return (-1);

    (void) strlcpy(buf, short2str(*(Char **)a), sizeof buf);
    return ((int) strcoll(buf, short2str(*(Char **)b)));
}
@


1.21
log
@Remove a needless allocation cast. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.20 2015/10/26 22:03:06 naddy Exp $	*/
d113 1
a113 1
    xfree(u);
d231 1
a231 1
		xfree(nv);
d234 1
a234 1
	    xfree(s);
d237 1
a237 1
		xfree(bl);
d261 1
a261 1
	    xfree(bl);
d297 1
a297 1
	    xfree(pargv);
d348 1
a348 1
	    xfree(str);
d350 1
a350 1
	    xfree(cp);
d433 1
a433 1
		xfree(vo);
d440 1
a440 1
		xfree(vo);
d458 1
a458 1
	xfree(vl);
d465 1
a465 1
	xfree(vl);
d695 1
a695 1
    xfree(cp);
@


1.20
log
@miscellaneous cruft:
* remove lint
* unifdef S_IFLNK, S_ISFIFO, S_ISLNK, S_ISSOCK, O_APPEND
* remove 0, NOTUSED, notdef -- untouched since original import
* remove IIASA
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.19 2015/10/26 15:01:15 naddy Exp $	*/
d868 1
a868 1
    p = gargv[gargc - 1] = (Char *) xreallocarray(NULL, n, sizeof(Char));
@


1.19
log
@unifdef BUILTIN (unused), NLS (always set), SHORT_STRINGS (always set)
and remove a few unused defines; no binary changes; ok tedu@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.18 2015/06/17 03:48:21 deraadt Exp $	*/
a581 3
#ifdef notdef
	abort();
#endif
@


1.18
log
@remove -DFILEC; code does not compile for the -UFILEC case, and anyways,
who wants csh without FILEC??
from Peter Brottveit Bock, but redone using unifdef
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.17 2015/02/08 06:01:25 tedu Exp $	*/
a880 1
#if defined(NLS) && !defined(NOSTRCOLL)
a881 1
#endif
a892 1
#if defined(NLS) && !defined(NOSTRCOLL)
a894 3
#else
    return ((int) Strcmp(*(Char **)a, *(Char **)b));
#endif
@


1.17
log
@remove ptr_t typedef. void * is good enough for csh.
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.16 2015/02/08 05:47:28 tedu Exp $	*/
a877 1
#ifdef FILEC
a901 1
#endif /* FILEC */
@


1.16
log
@delete lots of unnecessary ptr_t casts, and drop a little NULL in as well
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.15 2015/01/16 06:39:31 deraadt Exp $	*/
d880 1
a880 1
sortscmp(ptr_t a, ptr_t b)
@


1.15
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.14 2014/10/16 19:43:31 deraadt Exp $	*/
d113 1
a113 1
    xfree((ptr_t) u);
d231 1
a231 1
		xfree((ptr_t) nv);
d234 1
a234 1
	    xfree((ptr_t) s);
d237 1
a237 1
		xfree((ptr_t) bl);
d261 1
a261 1
	    xfree((ptr_t) bl);
d297 1
a297 1
	    xfree((ptr_t) pargv);
d348 1
a348 1
	    xfree((ptr_t) str);
d350 1
a350 1
	    xfree((ptr_t) cp);
d433 1
a433 1
		xfree((ptr_t) vo);
d440 1
a440 1
		xfree((ptr_t) vo);
d458 1
a458 1
	xfree((ptr_t) vl);
d465 1
a465 1
	xfree((ptr_t) vl);
d698 1
a698 1
    xfree((ptr_t) cp);
@


1.14
log
@Use reallocarray() and remove a few archaic memory allocation practices.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.13 2009/10/27 23:59:21 deraadt Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d39 1
d91 1
a91 1
    Char    gbuf[MAXPATHLEN], *gstart, *b, *u, *e;
d96 1
a96 1
    for (b = gstart, e = &gbuf[MAXPATHLEN - 1];
d123 1
a123 1
    Char    gbuf[MAXPATHLEN];
d186 1
a186 1
		(void) Strlcat(gbuf, pe + 1, MAXPATHLEN);
d579 1
a579 1
    Char   *ep, word[MAXPATHLEN];
d592 1
a592 1
    pnleft = MAXPATHLEN - 4;
d773 1
a773 1
    pnleft = MAXPATHLEN - 4;
@


1.13
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.12 2003/06/25 21:12:39 deraadt Exp $	*/
d125 1
a125 1
    nv = vl = (Char **) xmalloc((size_t) sizeof(Char *) * size);
d192 1
a192 2
		    nv = (Char **) xrealloc((ptr_t) nv, (size_t)
					    size * sizeof(Char *));
d247 1
a247 2
		nv = (Char **) xrealloc((ptr_t) nv, (size_t)
					size * sizeof(Char *));
d277 1
a277 1
    nv = vl = (Char **) xmalloc((size_t) sizeof(Char *) * size);
d292 1
a292 2
		    nv = (Char **) xrealloc((ptr_t) nv,
					    (size_t) size * sizeof(Char *));
d303 1
a303 2
		nv = (Char **) xrealloc((ptr_t) nv, (size_t)
					size * sizeof(Char *));
d507 1
a507 1
    gargv = (Char **) xmalloc((size_t) sizeof(Char *) * gargsiz);
d587 1
a587 1
    pargv = (Char **) xmalloc((size_t) sizeof(Char *) * pargsiz);
d767 1
a767 2
	pargv = (Char **) xrealloc((ptr_t) pargv,
				   (size_t) pargsiz * sizeof(Char *));
d786 1
a786 1
    blk = (Char **) xmalloc(GLOBSPACE * sizeof(Char *));
d867 1
a867 2
	gargv = (Char **) xrealloc((ptr_t) gargv,
				   (size_t) gargsiz * sizeof(Char *));
d870 1
a870 1
    p = gargv[gargc - 1] = (Char *) xmalloc((size_t) n * sizeof(Char));
@


1.12
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.11 2003/06/11 21:09:50 deraadt Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)glob.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: glob.c,v 1.11 2003/06/11 21:09:50 deraadt Exp $";
#endif
#endif /* not lint */
@


1.11
log
@de-register and ansify functions
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.10 2003/06/02 23:32:07 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.10 2003/06/02 23:32:07 millert Exp $";
d525 1
a525 1
rscan(Char **t, void (*f)())
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.9 2003/01/08 06:54:16 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.9 2003/01/08 06:54:16 deraadt Exp $";
d96 1
a96 2
globtilde(nv, s)
    Char  **nv, *s;
d125 1
a125 2
globbrace(s, p, bl)
    Char   *s, *p, ***bl;
d216 1
a216 3
expbrace(nvp, elp, size)
    Char ***nvp, ***elp;
    int size;
d280 1
a280 2
globexpand(v)
    Char  **v;
d343 1
a343 3
handleone(str, vl, action)
    Char   *str, **vl;
    int     action;
d378 1
a378 2
libglob(vl)
    Char  **vl;
d423 1
a423 3
globone(str, action)
    Char   *str;
    int     action;
d482 1
a482 2
globall(v)
    Char  **v;
d516 1
a516 1
ginit()
d525 1
a525 3
rscan(t, f)
    register Char **t;
    void    (*f) ();
d527 1
a527 1
    register Char *p;
d535 1
a535 2
trim(t)
    register Char **t;
d537 1
a537 1
    register Char *p;
d545 1
a545 2
tglob(t)
    register Char **t;
d547 1
a547 1
    register Char *p, c;
d587 1
a587 3
dobackp(cp, literal)
    Char   *cp;
    bool    literal;
d589 1
a589 1
    register Char *lp, *rp;
d630 1
a630 3
backeval(cp, literal)
    Char   *cp;
    bool    literal;
d632 2
a633 2
    register int icnt, c;
    register Char *ip;
d766 1
a766 2
psave(c)
    int    c;
d774 1
a774 1
pword()
d789 1
a789 2
Gmatch(string, pattern)
    Char *string, *pattern;
d813 1
a813 2
pmatch(string, pattern)
    register Char *string, *pattern;
d815 1
a815 1
    register Char stringc, patternc;
d868 1
a868 2
Gcat(s1, s2)
    Char   *s1, *s2;
d870 1
a870 1
    register Char *p, *q;
d893 1
a893 2
sortscmp(a, b)
    register const ptr_t a, b;
@


1.9
log
@bring in strlcpy and strlcat-like things for dealing with Char types,
this fixes at least 15 buffer overflows; some help from dhartmei.
Anyone want to go do the same in ksh, and help with some of the while
(*s++ = *p++) loops in here?
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.8 2002/06/09 05:47:27 todd Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.8 2002/06/09 05:47:27 todd Exp $";
@


1.8
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.7 2002/02/19 19:39:35 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.7 2002/02/19 19:39:35 millert Exp $";
d113 1
a113 1
    if (gethdir(gstart)) {
d198 2
a199 2
		(void) Strcpy(lm, pl);
		(void) Strcat(gbuf, pe + 1);
d374 2
a375 1
	while (*++vlp);
d426 2
a427 1
    while (*++vl);
d938 1
a938 1
    (void) strcpy(buf, short2str(*(Char **)a));
@


1.7
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.6 2002/02/16 21:27:06 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.6 2002/02/16 21:27:06 millert Exp $";
d578 1
a578 1
		while (*p && *p != '`') 
d810 1
a810 1
int 
d833 1
a833 1
} 
d874 1
a874 1
		else 
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.5 1997/09/01 18:40:50 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.5 1997/09/01 18:40:50 millert Exp $";
d51 1
a51 5
#ifdef __STDC__
# include <stdarg.h>
#else
# include <varargs.h>
#endif
@


1.5
log
@GLOB_ABEND -> GLOB_ABORTED
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.4 1997/07/25 18:58:08 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.4 1997/07/25 18:58:08 mickey Exp $";
d92 9
a100 9
static Char	*globtilde __P((Char **, Char *));
static Char	**libglob __P((Char **));
static Char	**globexpand __P((Char **));
static int	globbrace __P((Char *, Char *, Char ***));
static void	expbrace __P((Char ***, Char ***, int));
static int	pmatch __P((Char *, Char *));
static void	pword __P((void));
static void	psave __P((int));
static void	backeval __P((Char *, bool));
@


1.4
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.3 1997/07/23 14:36:50 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.3 1997/07/23 14:36:50 kstailey Exp $";
d413 1
a413 1
	case GLOB_ABEND:
@


1.3
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.2 1996/06/23 14:19:23 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.2 1996/06/23 14:19:23 deraadt Exp $";
d51 1
a51 1
#if __STDC__
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.10 1995/03/21 09:03:01 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.10 1995/03/21 09:03:01 cgd Exp $";
d711 1
a711 1
        /*
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: glob.c,v 1.10 1995/03/21 09:03:01 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
