head	1.16;
access;
symbols
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.10.0.8
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.12
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.10
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	OPENBSD_5_0:1.9.0.6
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.4
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.28
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.24
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.22
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.20
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.18
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.16
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.14
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.3.0.18
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.16
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.14
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.12
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2015.12.26.13.48.38;	author mestre;	state Exp;
branches;
next	1.15;
commitid	jZMsEASvreUUSdqp;

1.15
date	2015.10.26.22.03.06;	author naddy;	state Exp;
branches;
next	1.14;
commitid	jREL04iPW8d08lKc;

1.14
date	2015.10.26.21.57.42;	author naddy;	state Exp;
branches;
next	1.13;
commitid	czPxwIHp6VIIfGKO;

1.13
date	2015.10.26.15.01.15;	author naddy;	state Exp;
branches;
next	1.12;
commitid	gs7LRmKw8OfepnU6;

1.12
date	2015.02.08.06.09.50;	author tedu;	state Exp;
branches;
next	1.11;
commitid	i1nyRcSvJDMCYw84;

1.11
date	2015.02.08.05.51.37;	author tedu;	state Exp;
branches;
next	1.10;
commitid	L3WalZJ5Trtg0ORm;

1.10
date	2013.03.28.08.39.54;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.20.02.13.10;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.11.21.09.50;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.23.32.07;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.07.25.18.58.05;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.20;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Replace handrolled xfree() function by directly using free(3)

OK mmcc@@
@
text
@/*	$OpenBSD: exp.c,v 1.15 2015/10/26 22:03:06 naddy Exp $	*/
/*	$NetBSD: exp.c,v 1.6 1995/03/21 09:02:51 cgd Exp $	*/

/*-
 * Copyright (c) 1980, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <limits.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>

#include "csh.h"
#include "extern.h"

#define IGNORE	1	/* in ignore, it means to ignore value, just parse */
#define NOGLOB	2	/* in ignore, it means not to globone */

#define	ADDOP	1
#define	MULOP	2
#define	EQOP	4
#define	RELOP	8
#define	RESTOP	16
#define	ANYOP	31

#define	EQEQ	1
#define	GTR	2
#define	LSS	4
#define	NOTEQ	6
#define EQMATCH 7
#define NOTEQMATCH 8

static int	exp1(Char ***, bool);
static int	exp2_(Char ***, bool);
static int	exp2a(Char ***, bool);
static int	exp2b(Char ***, bool);
static int	exp2c(Char ***, bool);
static Char *	exp3(Char ***, bool);
static Char *	exp3a(Char ***, bool);
static Char *	exp4(Char ***, bool);
static Char *	exp5(Char ***, bool);
static Char *	exp6(Char ***, bool);
static void	evalav(Char **);
static int	isa(Char *, int);
static int	egetn(Char *);

int
expr(Char ***vp)
{
    return (exp0(vp, 0));
}

int
exp0(Char ***vp, bool ignore)
{
    int p1 = exp1(vp, ignore);

    if (**vp && eq(**vp, STRor2)) {
	int p2;

	(*vp)++;
	p2 = exp0(vp, (ignore & IGNORE) || p1);
	return (p1 || p2);
    }
    return (p1);
}

static int
exp1(Char ***vp, bool ignore)
{
    int p1 = exp2_(vp, ignore);

    if (**vp && eq(**vp, STRand2)) {
	int p2;

	(*vp)++;
	p2 = exp1(vp, (ignore & IGNORE) || !p1);
	return (p1 && p2);
    }
    return (p1);
}

static int
exp2_(Char ***vp, bool ignore)
{
    int p1 = exp2a(vp, ignore);

    if (**vp && eq(**vp, STRor)) {
	int p2;

	(*vp)++;
	p2 = exp2_(vp, ignore);
	return (p1 | p2);
    }
    return (p1);
}

static int
exp2a(Char ***vp, bool ignore)
{
    int p1 = exp2b(vp, ignore);

    if (**vp && eq(**vp, STRcaret)) {
	int p2;

	(*vp)++;
	p2 = exp2a(vp, ignore);
	return (p1 ^ p2);
    }
    return (p1);
}

static int
exp2b(Char ***vp, bool ignore)
{
    int p1 = exp2c(vp, ignore);

    if (**vp && eq(**vp, STRand)) {
	int p2;

	(*vp)++;
	p2 = exp2b(vp, ignore);
	return (p1 & p2);
    }
    return (p1);
}

static int
exp2c(Char ***vp, bool ignore)
{
    Char *p1 = exp3(vp, ignore);
    Char *p2;
    int i;

    if ((i = isa(**vp, EQOP)) != 0) {
	(*vp)++;
	if (i == EQMATCH || i == NOTEQMATCH)
	    ignore |= NOGLOB;
	p2 = exp3(vp, ignore);
	if (!(ignore & IGNORE))
	    switch (i) {

	    case EQEQ:
		i = eq(p1, p2);
		break;

	    case NOTEQ:
		i = !eq(p1, p2);
		break;

	    case EQMATCH:
		i = Gmatch(p1, p2);
		break;

	    case NOTEQMATCH:
		i = !Gmatch(p1, p2);
		break;
	    }
	free(p1);
	free(p2);
	return (i);
    }
    i = egetn(p1);
    free(p1);
    return (i);
}

static Char *
exp3(Char ***vp, bool ignore)
{
    Char *p1, *p2;
    int i;

    p1 = exp3a(vp, ignore);
    if ((i = isa(**vp, RELOP)) != 0) {
	(*vp)++;
	if (**vp && eq(**vp, STRequal))
	    i |= 1, (*vp)++;
	p2 = exp3(vp, ignore);
	if (!(ignore & IGNORE))
	    switch (i) {

	    case GTR:
		i = egetn(p1) > egetn(p2);
		break;

	    case GTR | 1:
		i = egetn(p1) >= egetn(p2);
		break;

	    case LSS:
		i = egetn(p1) < egetn(p2);
		break;

	    case LSS | 1:
		i = egetn(p1) <= egetn(p2);
		break;
	    }
	free(p1);
	free(p2);
	return (putn(i));
    }
    return (p1);
}

static Char *
exp3a(Char ***vp, bool ignore)
{
    Char *p1, *p2, *op;
    int i;

    p1 = exp4(vp, ignore);
    op = **vp;
    if (op && any("<>", op[0]) && op[0] == op[1]) {
	(*vp)++;
	p2 = exp3a(vp, ignore);
	if (op[0] == '<')
	    i = egetn(p1) << egetn(p2);
	else
	    i = egetn(p1) >> egetn(p2);
	free(p1);
	free(p2);
	return (putn(i));
    }
    return (p1);
}

static Char *
exp4(Char ***vp, bool ignore)
{
    Char *p1, *p2;
    int i = 0;

    p1 = exp5(vp, ignore);
    if (isa(**vp, ADDOP)) {
	Char *op = *(*vp)++;

	p2 = exp4(vp, ignore);
	if (!(ignore & IGNORE))
	    switch (op[0]) {

	    case '+':
		i = egetn(p1) + egetn(p2);
		break;

	    case '-':
		i = egetn(p1) - egetn(p2);
		break;
	    }
	free(p1);
	free(p2);
	return (putn(i));
    }
    return (p1);
}

static Char *
exp5(Char ***vp, bool ignore)
{
    Char *p1, *p2;
    int i = 0, l;

    p1 = exp6(vp, ignore);
    if (isa(**vp, MULOP)) {
	Char *op = *(*vp)++;

	p2 = exp5(vp, ignore);
	if (!(ignore & IGNORE))
	    switch (op[0]) {

	    case '*':
		i = egetn(p1) * egetn(p2);
		break;

	    case '/':
		i = egetn(p2);
		if (i == 0)
		    stderror(ERR_DIV0);
		l = egetn(p1);
		if (l == INT_MIN && i == -1)
			i = INT_MIN;
		else
			i = l / i;
		break;

	    case '%':
		i = egetn(p2);
		if (i == 0)
		    stderror(ERR_MOD0);
		l = egetn(p1);
		if (l == INT_MIN && i == -1)
			i = 0;
		else
			i = l % i;
		break;
	    }
	free(p1);
	free(p2);
	return (putn(i));
    }
    return (p1);
}

static Char *
exp6(Char ***vp, bool ignore)
{
    int     ccode, i = 0;
    Char *cp, *dp, *ep;

    if (**vp == 0)
	stderror(ERR_NAME | ERR_EXPRESSION);
    if (eq(**vp, STRbang)) {
	(*vp)++;
	cp = exp6(vp, ignore);
	i = egetn(cp);
	free(cp);
	return (putn(!i));
    }
    if (eq(**vp, STRtilde)) {
	(*vp)++;
	cp = exp6(vp, ignore);
	i = egetn(cp);
	free(cp);
	return (putn(~i));
    }
    if (eq(**vp, STRLparen)) {
	(*vp)++;
	ccode = exp0(vp, ignore);
	if (*vp == 0 || **vp == 0 || ***vp != ')')
	    stderror(ERR_NAME | ERR_EXPRESSION);
	(*vp)++;
	return (putn(ccode));
    }
    if (eq(**vp, STRLbrace)) {
	Char **v;
	struct command faket;
	Char   *fakecom[2];

	faket.t_dtyp = NODE_COMMAND;
	faket.t_dflg = 0;
	faket.t_dcar = faket.t_dcdr = faket.t_dspr = NULL;
	faket.t_dcom = fakecom;
	fakecom[0] = STRfakecom;
	fakecom[1] = NULL;
	(*vp)++;
	v = *vp;
	for (;;) {
	    if (!**vp)
		stderror(ERR_NAME | ERR_MISSING, '}');
	    if (eq(*(*vp)++, STRRbrace))
		break;
	}
	if (ignore & IGNORE)
	    return (Strsave(STRNULL));
	psavejob();
	if (pfork(&faket, -1) == 0) {
	    *--(*vp) = 0;
	    evalav(v);
	    exitstat();
	}
	pwait();
	prestjob();
	return (putn(egetn(value(STRstatus)) == 0));
    }
    if (isa(**vp, ANYOP))
	return (Strsave(STRNULL));
    cp = *(*vp)++;
    if (*cp == '-' && any("erwxfdzopls", cp[1])) {
	struct stat stb;

	if (cp[2] != '\0')
	    stderror(ERR_NAME | ERR_FILEINQ);
	/*
	 * Detect missing file names by checking for operator in the file name
	 * position.  However, if an operator name appears there, we must make
	 * sure that there's no file by that name (e.g., "/") before announcing
	 * an error.  Even this check isn't quite right, since it doesn't take
	 * globbing into account.
	 */
	if (isa(**vp, ANYOP) && stat(short2str(**vp), &stb))
	    stderror(ERR_NAME | ERR_FILENAME);

	dp = *(*vp)++;
	if (ignore & IGNORE)
	    return (Strsave(STRNULL));
	ep = globone(dp, G_ERROR);
	switch (cp[1]) {

	case 'r':
	    i = !access(short2str(ep), R_OK);
	    break;

	case 'w':
	    i = !access(short2str(ep), W_OK);
	    break;

	case 'x':
	    i = !access(short2str(ep), X_OK);
	    break;

	default:
	    if (cp[1] == 'l' ? lstat(short2str(ep), &stb) :
		stat(short2str(ep), &stb)) {
		free(ep);
		return (Strsave(STR0));
	    }
	    switch (cp[1]) {

	    case 'f':
		i = S_ISREG(stb.st_mode);
		break;

	    case 'd':
		i = S_ISDIR(stb.st_mode);
		break;

	    case 'p':
		i = S_ISFIFO(stb.st_mode);
		break;

	    case 'l':
		i = S_ISLNK(stb.st_mode);
		break;

	    case 's':
		i = S_ISSOCK(stb.st_mode);
		break;

	    case 'z':
		i = stb.st_size == 0;
		break;

	    case 'e':
		i = 1;
		break;

	    case 'o':
		i = stb.st_uid == uid;
		break;
	    }
	}
	free(ep);
	return (putn(i));
    }
    return (ignore & NOGLOB ? Strsave(cp) : globone(cp, G_ERROR));
}

static void
evalav(Char **v)
{
    struct wordent paraml1;
    struct wordent *hp = &paraml1;
    struct command *t;
    struct wordent *wdp = hp;

    set(STRstatus, Strsave(STR0));
    hp->prev = hp->next = hp;
    hp->word = STRNULL;
    while (*v) {
	struct wordent *new = xcalloc(1, sizeof *wdp);

	new->prev = wdp;
	new->next = hp;
	wdp->next = new;
	wdp = new;
	wdp->word = Strsave(*v++);
    }
    hp->prev = wdp;
    alias(&paraml1);
    t = syntax(paraml1.next, &paraml1, 0);
    if (seterr)
	stderror(ERR_OLD);
    execute(t, -1, NULL, NULL);
    freelex(&paraml1), freesyn(t);
}

static int
isa(Char *cp, int what)
{
    if (cp == 0)
	return ((what & RESTOP) != 0);
    if (cp[1] == 0) {
	if (what & ADDOP && (*cp == '+' || *cp == '-'))
	    return (1);
	if (what & MULOP && (*cp == '*' || *cp == '/' || *cp == '%'))
	    return (1);
	if (what & RESTOP && (*cp == '(' || *cp == ')' || *cp == '!' ||
			      *cp == '~' || *cp == '^' || *cp == '"'))
	    return (1);
    }
    else if (cp[2] == 0) {
	if (what & RESTOP) {
	    if (cp[0] == '|' && cp[1] == '&')
		return (1);
	    if (cp[0] == '<' && cp[1] == '<')
		return (1);
	    if (cp[0] == '>' && cp[1] == '>')
		return (1);
	}
	if (what & EQOP) {
	    if (cp[0] == '=') {
		if (cp[1] == '=')
		    return (EQEQ);
		if (cp[1] == '~')
		    return (EQMATCH);
	    }
	    else if (cp[0] == '!') {
		if (cp[1] == '=')
		    return (NOTEQ);
		if (cp[1] == '~')
		    return (NOTEQMATCH);
	    }
	}
    }
    if (what & RELOP) {
	if (*cp == '<')
	    return (LSS);
	if (*cp == '>')
	    return (GTR);
    }
    return (0);
}

static int
egetn(Char *cp)
{
    if (*cp && *cp != '-' && !Isdigit(*cp))
	stderror(ERR_NAME | ERR_EXPRESSION);
    return (getn(cp));
}

/* Phew! */
@


1.15
log
@miscellaneous cruft:
* remove lint
* unifdef S_IFLNK, S_ISFIFO, S_ISLNK, S_ISSOCK, O_APPEND
* remove 0, NOTUSED, notdef -- untouched since original import
* remove IIASA
@
text
@d1 1
a1 1
/*	$OpenBSD: exp.c,v 1.14 2015/10/26 21:57:42 naddy Exp $	*/
d186 2
a187 2
	xfree(p1);
	xfree(p2);
d191 1
a191 1
    xfree(p1);
d226 2
a227 2
	xfree(p1);
	xfree(p2);
d248 2
a249 2
	xfree(p1);
	xfree(p2);
d277 2
a278 2
	xfree(p1);
	xfree(p2);
d324 2
a325 2
	xfree(p1);
	xfree(p2);
d343 1
a343 1
	xfree(cp);
d350 1
a350 1
	xfree(cp);
d431 1
a431 1
		xfree(ep);
d469 1
a469 1
	xfree(ep);
@


1.14
log
@remove the profiling and debugging ifdefs; ok zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exp.c,v 1.13 2015/10/26 15:01:15 naddy Exp $	*/
d429 1
a429 4
	    if (
#ifdef S_IFLNK
		cp[1] == 'l' ? lstat(short2str(ep), &stb) :
#endif
a444 1
#ifdef S_ISFIFO
a445 3
#else
		i = 0;
#endif
a448 1
#ifdef S_ISLNK
a449 3
#else
		i = 0;
#endif
a452 1
#ifdef S_ISSOCK
a453 3
#else
		i = 0;
#endif
@


1.13
log
@unifdef BUILTIN (unused), NLS (always set), SHORT_STRINGS (always set)
and remove a few unused defines; no binary changes; ok tedu@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exp.c,v 1.12 2015/02/08 06:09:50 tedu Exp $	*/
a73 5
#ifdef EDEBUG
static void	etracc(char *, Char *, Char ***);
static void	etraci(char *, int, Char ***);
#endif

a84 3
#ifdef EDEBUG
    etraci("exp0 p1", p1, vp);
#endif
a89 3
#ifdef EDEBUG
	etraci("exp0 p2", p2, vp);
#endif
a99 3
#ifdef EDEBUG
    etraci("exp1 p1", p1, vp);
#endif
a104 3
#ifdef EDEBUG
	etraci("exp1 p2", p2, vp);
#endif
a114 3
#ifdef EDEBUG
    etraci("exp3 p1", p1, vp);
#endif
a119 3
#ifdef EDEBUG
	etraci("exp3 p2", p2, vp);
#endif
a129 3
#ifdef EDEBUG
    etraci("exp2a p1", p1, vp);
#endif
a134 3
#ifdef EDEBUG
	etraci("exp2a p2", p2, vp);
#endif
a144 3
#ifdef EDEBUG
    etraci("exp2b p1", p1, vp);
#endif
a149 3
#ifdef EDEBUG
	etraci("exp2b p2", p2, vp);
#endif
a161 3
#ifdef EDEBUG
    etracc("exp2c p1", p1, vp);
#endif
a166 3
#ifdef EDEBUG
	etracc("exp2c p2", p2, vp);
#endif
a201 3
#ifdef EDEBUG
    etracc("exp3 p1", p1, vp);
#endif
a206 3
#ifdef EDEBUG
	etracc("exp3 p2", p2, vp);
#endif
a239 3
#ifdef EDEBUG
    etracc("exp3a p1", p1, vp);
#endif
a243 3
#ifdef EDEBUG
	etracc("exp3a p2", p2, vp);
#endif
a261 3
#ifdef EDEBUG
    etracc("exp4 p1", p1, vp);
#endif
a265 3
#ifdef EDEBUG
	etracc("exp4 p2", p2, vp);
#endif
a290 3
#ifdef EDEBUG
    etracc("exp5 p1", p1, vp);
#endif
a294 3
#ifdef EDEBUG
	etracc("exp5 p2", p2, vp);
#endif
a341 3
#ifdef EDEBUG
	etracc("exp6 ! cp", cp, vp);
#endif
a348 3
#ifdef EDEBUG
	etracc("exp6 ~ cp", cp, vp);
#endif
a355 3
#ifdef EDEBUG
	etraci("exp6 () ccode", ccode, vp);
#endif
a389 3
#ifdef EDEBUG
	etraci("exp6 {} status", egetn(value(STRstatus)), vp);
#endif
a483 3
#ifdef EDEBUG
	etraci("exp6 -? i", i, vp);
#endif
a486 3
#ifdef EDEBUG
    etracc("exp6 default", cp, vp);
#endif
a574 17

#ifdef EDEBUG
static void
etraci(char *str, int i, Char ***vp)
{
    (void) fprintf(csherr, "%s=%d\t", str, i);
    blkpr(csherr, *vp);
    (void) fprintf(csherr, "\n");
}
static void
etracc(char *str, Char *cp, Char ***vp)
{
    (void) fprintf(csherr, "%s=%s\t", str, vis_str(cp));
    blkpr(csherr, *vp);
    (void) fprintf(csherr, "\n");
}
#endif
@


1.12
log
@delete tons more casts
@
text
@d1 1
a1 1
/*	$OpenBSD: exp.c,v 1.11 2015/02/08 05:51:37 tedu Exp $	*/
a37 3
#ifndef SHORT_STRINGS
#include <string.h>
#endif /* SHORT_STRINGS */
@


1.11
log
@delete many more ptr_t casts
@
text
@d1 1
a1 1
/*	$OpenBSD: exp.c,v 1.10 2013/03/28 08:39:54 nicm Exp $	*/
d588 1
a588 2
	struct wordent *new =
	(struct wordent *) xcalloc(1, sizeof *wdp);
@


1.10
log
@Don't die with SIGFPE on INT_MIN / -1 or % -1. Instead make INT_MIN /
-1 == INT_MIN and % -1 == 0.

ok matthew deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exp.c,v 1.9 2010/07/20 02:13:10 deraadt Exp $	*/
d230 2
a231 2
	xfree((ptr_t) p1);
	xfree((ptr_t) p2);
d235 1
a235 1
    xfree((ptr_t) p1);
d276 2
a277 2
	xfree((ptr_t) p1);
	xfree((ptr_t) p2);
d304 2
a305 2
	xfree((ptr_t) p1);
	xfree((ptr_t) p2);
d339 2
a340 2
	xfree((ptr_t) p1);
	xfree((ptr_t) p2);
d392 2
a393 2
	xfree((ptr_t) p1);
	xfree((ptr_t) p2);
d414 1
a414 1
	xfree((ptr_t) cp);
d424 1
a424 1
	xfree((ptr_t) cp);
d514 1
a514 1
		xfree((ptr_t) ep);
d567 1
a567 1
	xfree((ptr_t) ep);
@


1.9
log
@exp2() is a function in libm, so rename the csh one..
@
text
@d1 1
a1 1
/*	$OpenBSD: exp.c,v 1.8 2009/10/27 23:59:21 deraadt Exp $	*/
d35 1
d350 1
a350 1
    int i = 0;
d374 5
a378 1
		i = egetn(p1) / i;
d385 5
a389 1
		i = egetn(p1) % i;
@


1.8
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: exp.c,v 1.7 2003/06/11 21:09:50 deraadt Exp $	*/
d63 1
a63 1
static int	exp2(Char ***, bool);
d111 1
a111 1
    int p1 = exp2(vp, ignore);
d130 1
a130 1
exp2(Char ***vp, bool ignore)
d141 1
a141 1
	p2 = exp2(vp, ignore);
@


1.7
log
@de-register and ansify functions
@
text
@d1 1
a1 1
/*	$OpenBSD: exp.c,v 1.6 2003/06/02 23:32:07 millert Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)exp.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: exp.c,v 1.6 2003/06/02 23:32:07 millert Exp $";
#endif
#endif /* not lint */
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: exp.c,v 1.5 2002/02/19 19:39:35 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: exp.c,v 1.5 2002/02/19 19:39:35 millert Exp $";
d90 1
a90 2
expr(vp)
    register Char ***vp;
d96 1
a96 3
exp0(vp, ignore)
    register Char ***vp;
    bool    ignore;
d98 1
a98 1
    register int p1 = exp1(vp, ignore);
d104 1
a104 1
	register int p2;
d117 1
a117 3
exp1(vp, ignore)
    register Char ***vp;
    bool    ignore;
d119 1
a119 1
    register int p1 = exp2(vp, ignore);
d125 1
a125 1
	register int p2;
d138 1
a138 3
exp2(vp, ignore)
    register Char ***vp;
    bool    ignore;
d140 1
a140 1
    register int p1 = exp2a(vp, ignore);
d146 1
a146 1
	register int p2;
d159 1
a159 3
exp2a(vp, ignore)
    register Char ***vp;
    bool    ignore;
d161 1
a161 1
    register int p1 = exp2b(vp, ignore);
d167 1
a167 1
	register int p2;
d180 1
a180 3
exp2b(vp, ignore)
    register Char ***vp;
    bool    ignore;
d182 1
a182 1
    register int p1 = exp2c(vp, ignore);
d188 1
a188 1
	register int p2;
d201 5
a205 7
exp2c(vp, ignore)
    register Char ***vp;
    bool    ignore;
{
    register Char *p1 = exp3(vp, ignore);
    register Char *p2;
    register int i;
d247 1
a247 3
exp3(vp, ignore)
    register Char ***vp;
    bool    ignore;
d249 2
a250 2
    register Char *p1, *p2;
    register int i;
d291 1
a291 3
exp3a(vp, ignore)
    register Char ***vp;
    bool    ignore;
d293 2
a294 2
    register Char *p1, *p2, *op;
    register int i;
d319 1
a319 3
exp4(vp, ignore)
    register Char ***vp;
    bool    ignore;
d321 2
a322 2
    register Char *p1, *p2;
    register int i = 0;
d329 1
a329 1
	register Char *op = *(*vp)++;
d354 1
a354 3
exp5(vp, ignore)
    register Char ***vp;
    bool    ignore;
d356 2
a357 2
    register Char *p1, *p2;
    register int i = 0;
d364 1
a364 1
	register Char *op = *(*vp)++;
d399 1
a399 3
exp6(vp, ignore)
    register Char ***vp;
    bool    ignore;
d402 1
a402 1
    register Char *cp, *dp, *ep;
d438 1
a438 1
	register Char **v;
d576 1
a576 2
evalav(v)
    register Char **v;
d579 1
a579 1
    register struct wordent *hp = &paraml1;
d581 1
a581 1
    register struct wordent *wdp = hp;
d587 1
a587 1
	register struct wordent *new =
d606 1
a606 3
isa(cp, what)
    register Char *cp;
    register int what;
d653 1
a653 2
egetn(cp)
    register Char *cp;
d664 1
a664 4
etraci(str, i, vp)
    char   *str;
    int     i;
    Char ***vp;
d671 1
a671 4
etracc(str, cp, vp)
    char   *str;
    Char   *cp;
    Char ***vp;
@


1.5
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: exp.c,v 1.4 2002/02/16 21:27:06 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: exp.c,v 1.4 2002/02/16 21:27:06 millert Exp $";
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: exp.c,v 1.3 1997/07/25 18:58:05 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: exp.c,v 1.3 1997/07/25 18:58:05 mickey Exp $";
d52 1
a52 5
#ifdef __STDC__
# include <stdarg.h>
#else
# include <varargs.h>
#endif
@


1.3
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: exp.c,v 1.2 1996/06/23 14:19:20 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: exp.c,v 1.2 1996/06/23 14:19:20 deraadt Exp $";
d78 13
a90 13
static int	exp1	__P((Char ***, bool));
static int	exp2	__P((Char ***, bool));
static int	exp2a	__P((Char ***, bool));
static int	exp2b	__P((Char ***, bool));
static int	exp2c	__P((Char ***, bool));
static Char *	exp3	__P((Char ***, bool));
static Char *	exp3a	__P((Char ***, bool));
static Char *	exp4	__P((Char ***, bool));
static Char *	exp5	__P((Char ***, bool));
static Char *	exp6	__P((Char ***, bool));
static void	evalav	__P((Char **));
static int	isa	__P((Char *, int));
static int	egetn	__P((Char *));
d93 2
a94 2
static void	etracc	__P((char *, Char *, Char ***));
static void	etraci	__P((char *, int, Char ***));
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: exp.c,v 1.6 1995/03/21 09:02:51 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: exp.c,v 1.6 1995/03/21 09:02:51 cgd Exp $";
d52 1
a52 1
#if __STDC__
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: exp.c,v 1.6 1995/03/21 09:02:51 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
