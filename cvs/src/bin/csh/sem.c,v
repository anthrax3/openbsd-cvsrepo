head	1.22;
access;
symbols
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.17.0.18
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.16
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.12
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.10
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.8
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.6
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.28
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.24
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.22
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.20
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.18
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.16
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.14
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.12
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.10
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.6.0.12
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.10
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.6
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.03.19.15.42.38;	author krw;	state Exp;
branches;
next	1.21;
commitid	L7EaSFXU9Zoui3I7;

1.21
date	2015.12.26.13.48.38;	author mestre;	state Exp;
branches;
next	1.20;
commitid	jZMsEASvreUUSdqp;

1.20
date	2015.10.26.22.03.06;	author naddy;	state Exp;
branches;
next	1.19;
commitid	jREL04iPW8d08lKc;

1.19
date	2015.02.08.05.47.28;	author tedu;	state Exp;
branches;
next	1.18;
commitid	UHj0KNSjy07xS7rI;

1.18
date	2015.01.16.06.39.31;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Uu5nFG3wCl0LACBb;

1.17
date	2010.08.12.02.00.27;	author kevlo;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.11.21.09.50;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.32.07;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.15.01.17.33;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.08.06.54.16;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.01.19.10.39;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.22.21.07.35;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.11.18.38.44;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	98.08.26.08.00.07;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.05.18.20.38.21;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.25.18.58.16;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.07.23.14.36.51;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.29;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Turn off the close-on-exec bit with fcntl() instead of ioctl().

Remove some now useless "#include <ioctl.h>" lines.

Inspired by & ok millert@@
@
text
@/*	$OpenBSD: sem.c,v 1.21 2015/12/26 13:48:38 mestre Exp $	*/
/*	$NetBSD: sem.c,v 1.9 1995/09/27 00:38:50 jtc Exp $	*/

/*-
 * Copyright (c) 1980, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <stdarg.h>

#include "csh.h"
#include "proc.h"
#include "extern.h"

static void	 vffree(int);
static Char	*splicepipe(struct command *t, Char *);
static void	 doio(struct command *t, int *, int *);
static void	 chkclob(char *);

void
execute(struct command *t, int wanttty, int *pipein, int *pipeout)
{
    bool    forked = 0;
    struct biltins *bifunc;
    int     pid = 0;
    int     pv[2];
    sigset_t sigset;

    static sigset_t csigset;

    static sigset_t ocsigset;
    static int onosigchld = 0;
    static int nosigchld = 0;

    UNREGISTER(forked);
    UNREGISTER(bifunc);
    UNREGISTER(wanttty);

    if (t == 0)
	return;

    if (t->t_dflg & F_AMPERSAND)
	wanttty = 0;
    switch (t->t_dtyp) {

    case NODE_COMMAND:
	if ((t->t_dcom[0][0] & (QUOTE | TRIM)) == QUOTE)
	    (void) memmove(t->t_dcom[0], t->t_dcom[0] + 1,
		(Strlen(t->t_dcom[0] + 1) + 1) * sizeof(Char));
	if ((t->t_dflg & F_REPEAT) == 0)
	    Dfix(t);		/* $ " ' \ */
	if (t->t_dcom[0] == 0)
	    return;
	/* fall into... */

    case NODE_PAREN:
	if (t->t_dflg & F_PIPEOUT)
	    mypipe(pipeout);
	/*
	 * Must do << early so parent will know where input pointer should be.
	 * If noexec then this is all we do.
	 */
	if (t->t_dflg & F_READ) {
	    (void) close(0);
	    heredoc(t->t_dlef);
	    if (noexec)
		(void) close(0);
	}

	set(STRstatus, Strsave(STR0));

	/*
	 * This mess is the necessary kludge to handle the prefix builtins:
	 * nice, nohup, time.  These commands can also be used by themselves,
	 * and this is not handled here. This will also work when loops are
	 * parsed.
	 */
	while (t->t_dtyp == NODE_COMMAND)
	    if (eq(t->t_dcom[0], STRnice))
		if (t->t_dcom[1])
		    if (strchr("+-", t->t_dcom[1][0]))
			if (t->t_dcom[2]) {
			    setname("nice");
			    t->t_nice =
				getn(t->t_dcom[1]);
			    lshift(t->t_dcom, 2);
			    t->t_dflg |= F_NICE;
			}
			else
			    break;
		    else {
			t->t_nice = 4;
			lshift(t->t_dcom, 1);
			t->t_dflg |= F_NICE;
		    }
		else
		    break;
	    else if (eq(t->t_dcom[0], STRnohup))
		if (t->t_dcom[1]) {
		    t->t_dflg |= F_NOHUP;
		    lshift(t->t_dcom, 1);
		}
		else
		    break;
	    else if (eq(t->t_dcom[0], STRtime))
		if (t->t_dcom[1]) {
		    t->t_dflg |= F_TIME;
		    lshift(t->t_dcom, 1);
		}
		else
		    break;
	    else
		break;

	/* is it a command */
	if (t->t_dtyp == NODE_COMMAND) {
	    /*
	     * Check if we have a builtin function and remember which one.
	     */
	    bifunc = isbfunc(t);
	    if (noexec) {
		/*
		 * Continue for builtins that are part of the scripting language
		 */
		if (bifunc &&
		    bifunc->bfunct != dobreak   && bifunc->bfunct != docontin &&
		    bifunc->bfunct != doelse    && bifunc->bfunct != doend    &&
		    bifunc->bfunct != doforeach && bifunc->bfunct != dogoto   &&
		    bifunc->bfunct != doif      && bifunc->bfunct != dorepeat &&
		    bifunc->bfunct != doswbrk   && bifunc->bfunct != doswitch &&
		    bifunc->bfunct != dowhile   && bifunc->bfunct != dozip)
		    break;
	    }
	}
	else {			/* not a command */
	    bifunc = NULL;
	    if (noexec)
		break;
	}

	/*
	 * We fork only if we are timed, or are not the end of a parenthesized
	 * list and not a simple builtin function. Simple meaning one that is
	 * not pipedout, niced, nohupped, or &'d. It would be nice(?) to not
	 * fork in some of these cases.
	 */
	/*
	 * Prevent forking cd, pushd, popd, chdir cause this will cause the
	 * shell not to change dir!
	 */
	if (bifunc && (bifunc->bfunct == dochngd ||
		       bifunc->bfunct == dopushd ||
		       bifunc->bfunct == dopopd))
	    t->t_dflg &= ~(F_NICE);
	if (((t->t_dflg & F_TIME) || ((t->t_dflg & F_NOFORK) == 0 &&
	     (!bifunc || t->t_dflg &
	      (F_PIPEOUT | F_AMPERSAND | F_NICE | F_NOHUP)))) ||
	/*
	 * We have to fork for eval too.
	 */
	    (bifunc && (t->t_dflg & (F_PIPEIN | F_PIPEOUT)) != 0 &&
	     bifunc->bfunct == doeval)) {
	    if (t->t_dtyp == NODE_PAREN ||
		t->t_dflg & (F_REPEAT | F_AMPERSAND) || bifunc) {
		forked++;
		/*
		 * We need to block SIGCHLD here, so that if the process does
		 * not die before we can set the process group
		 */
		if (wanttty >= 0 && !nosigchld) {
		    sigemptyset(&sigset);
		    sigaddset(&sigset, SIGCHLD);
		    sigprocmask(SIG_BLOCK, &sigset, &csigset);
		    nosigchld = 1;
		}

		pid = pfork(t, wanttty);
		if (pid == 0 && nosigchld) {
		    sigprocmask(SIG_SETMASK, &csigset, NULL);
		    nosigchld = 0;
		}
		else if (pid != 0 && (t->t_dflg & F_AMPERSAND))
		    backpid = pid;

	    }
	    else {
		int     ochild, osetintr, ohaderr, odidfds;
		int     oSHIN, oSHOUT, oSHERR, oOLDSTD, otpgrp;
		sigset_t osigset;

		/*
		 * Prepare for the vfork by saving everything that the child
		 * corrupts before it exec's. Note that in some signal
		 * implementations which keep the signal info in user space
		 * (e.g. Sun's) it will also be necessary to save and restore
		 * the current sigaction's for the signals the child touches
		 * before it exec's.
		 */
		if (wanttty >= 0 && !nosigchld && !noexec) {
		    sigemptyset(&sigset);
		    sigaddset(&sigset, SIGCHLD);
		    sigprocmask(SIG_BLOCK, &sigset, &csigset);
		    nosigchld = 1;
		}
		sigemptyset(&sigset);
		sigaddset(&sigset, SIGCHLD);
		sigaddset(&sigset, SIGINT);
		sigprocmask(SIG_BLOCK, &sigset, &osigset);
		ochild = child;
		osetintr = setintr;
		ohaderr = haderr;
		odidfds = didfds;
		oSHIN = SHIN;
		oSHOUT = SHOUT;
		oSHERR = SHERR;
		oOLDSTD = OLDSTD;
		otpgrp = tpgrp;
		ocsigset = csigset;
		onosigchld = nosigchld;
		Vsav = Vdp = NULL;
		Vexpath = 0;
		Vt = 0;
		pid = vfork();

		if (pid < 0) {
		    sigprocmask(SIG_SETMASK, &osigset, NULL);
		    stderror(ERR_NOPROC);
		}
		forked++;
		if (pid) {	/* parent */
		    child = ochild;
		    setintr = osetintr;
		    haderr = ohaderr;
		    didfds = odidfds;
		    SHIN = oSHIN;
		    SHOUT = oSHOUT;
		    SHERR = oSHERR;
		    OLDSTD = oOLDSTD;
		    tpgrp = otpgrp;
		    csigset = ocsigset;
		    nosigchld = onosigchld;

		    free(Vsav);
		    Vsav = NULL;
		    free(Vdp);
		    Vdp = NULL;
		    free(Vexpath);
		    Vexpath = NULL;
		    blkfree((Char **) Vt);
		    Vt = NULL;
		    /* this is from pfork() */
		    palloc(pid, t);
		    sigprocmask(SIG_SETMASK, &osigset, NULL);
		}
		else {		/* child */
		    /* this is from pfork() */
		    int     pgrp;
		    bool    ignint = 0;

		    if (nosigchld) {
			sigprocmask(SIG_SETMASK, &csigset, NULL);
			nosigchld = 0;
		    }

		    if (setintr)
			ignint =
			    (tpgrp == -1 &&
			     (t->t_dflg & F_NOINTERRUPT))
			    || (gointr && eq(gointr, STRminus));
		    pgrp = pcurrjob ? pcurrjob->p_jobid : getpid();
		    child++;
		    if (setintr) {
			setintr = 0;
			if (ignint) {
			    (void) signal(SIGINT, SIG_IGN);
			    (void) signal(SIGQUIT, SIG_IGN);
			}
			else {
			    (void) signal(SIGINT, vffree);
			    (void) signal(SIGQUIT, SIG_DFL);
			}

			if (wanttty >= 0) {
			    (void) signal(SIGTSTP, SIG_DFL);
			    (void) signal(SIGTTIN, SIG_DFL);
			    (void) signal(SIGTTOU, SIG_DFL);
			}

			(void) signal(SIGTERM, parterm);
		    }
		    else if (tpgrp == -1 &&
			     (t->t_dflg & F_NOINTERRUPT)) {
			(void) signal(SIGINT, SIG_IGN);
			(void) signal(SIGQUIT, SIG_IGN);
		    }

		    pgetty(wanttty, pgrp);
		    if (t->t_dflg & F_NOHUP)
			(void) signal(SIGHUP, SIG_IGN);
		    if (t->t_dflg & F_NICE)
			(void) setpriority(PRIO_PROCESS, 0, t->t_nice);
		}

	    }
	}
	if (pid != 0) {
	    /*
	     * It would be better if we could wait for the whole job when we
	     * knew the last process had been started.  Pwait, in fact, does
	     * wait for the whole job anyway, but this test doesn't really
	     * express our intentions.
	     */
	    if (didfds == 0 && t->t_dflg & F_PIPEIN) {
		(void) close(pipein[0]);
		(void) close(pipein[1]);
	    }
	    if ((t->t_dflg & F_PIPEOUT) == 0) {
		if (nosigchld) {
		    sigprocmask(SIG_SETMASK, &csigset, NULL);
		    nosigchld = 0;
		}
		if ((t->t_dflg & F_AMPERSAND) == 0)
		    pwait();
	    }
	    break;
	}
	doio(t, pipein, pipeout);
	if (t->t_dflg & F_PIPEOUT) {
	    (void) close(pipeout[0]);
	    (void) close(pipeout[1]);
	}
	/*
	 * Perform a builtin function. If we are not forked, arrange for
	 * possible stopping
	 */
	if (bifunc) {
	    func(t, bifunc);
	    if (forked)
		exitstat();
	    break;
	}
	if (t->t_dtyp != NODE_PAREN) {
	    doexec(NULL, t);
	    /* NOTREACHED */
	}
	/*
	 * For () commands must put new 0,1,2 in FSH* and recurse
	 */
	OLDSTD = dcopy(0, FOLDSTD);
	SHOUT = dcopy(1, FSHOUT);
	SHERR = dcopy(2, FSHERR);
	(void) close(SHIN);
	SHIN = -1;
	didfds = 0;
	wanttty = -1;
	t->t_dspr->t_dflg |= t->t_dflg & F_NOINTERRUPT;
	execute(t->t_dspr, wanttty, NULL, NULL);
	exitstat();

    case NODE_PIPE:
	t->t_dcar->t_dflg |= F_PIPEOUT |
	    (t->t_dflg & (F_PIPEIN | F_AMPERSAND | F_STDERR | F_NOINTERRUPT));
	execute(t->t_dcar, wanttty, pipein, pv);
	t->t_dcdr->t_dflg |= F_PIPEIN | (t->t_dflg &
			(F_PIPEOUT | F_AMPERSAND | F_NOFORK | F_NOINTERRUPT));
	if (wanttty > 0)
	    wanttty = 0;	/* got tty already */
	execute(t->t_dcdr, wanttty, pv, pipeout);
	break;

    case NODE_LIST:
	if (t->t_dcar) {
	    t->t_dcar->t_dflg |= t->t_dflg & F_NOINTERRUPT;
	    execute(t->t_dcar, wanttty, NULL, NULL);
	    /*
	     * In strange case of A&B make a new job after A
	     */
	    if (t->t_dcar->t_dflg & F_AMPERSAND && t->t_dcdr &&
		(t->t_dcdr->t_dflg & F_AMPERSAND) == 0)
		pendjob();
	}
	if (t->t_dcdr) {
	    t->t_dcdr->t_dflg |= t->t_dflg &
		(F_NOFORK | F_NOINTERRUPT);
	    execute(t->t_dcdr, wanttty, NULL, NULL);
	}
	break;

    case NODE_OR:
    case NODE_AND:
	if (t->t_dcar) {
	    t->t_dcar->t_dflg |= t->t_dflg & F_NOINTERRUPT;
	    execute(t->t_dcar, wanttty, NULL, NULL);
	    if ((getn(value(STRstatus)) == 0) !=
		(t->t_dtyp == NODE_AND))
		return;
	}
	if (t->t_dcdr) {
	    t->t_dcdr->t_dflg |= t->t_dflg &
		(F_NOFORK | F_NOINTERRUPT);
	    execute(t->t_dcdr, wanttty, NULL, NULL);
	}
	break;
    }
    /*
     * Fall through for all breaks from switch
     *
     * If there will be no more executions of this command, flush all file
     * descriptors. Places that turn on the F_REPEAT bit are responsible for
     * doing donefds after the last re-execution
     */
    if (didfds && !(t->t_dflg & F_REPEAT))
	donefds();
}

static void
vffree(int i)
{
    _exit(i);
}

/*
 * Expand and glob the words after an i/o redirection.
 * If more than one word is generated, then update the command vector.
 *
 * This is done differently in all the shells:
 * 1. in the bourne shell and ksh globbing is not performed
 * 2. Bash/csh say ambiguous
 * 3. zsh does i/o to/from all the files
 * 4. itcsh concatenates the words.
 *
 * I don't know what is best to do. I think that Ambiguous is better
 * than restructuring the command vector, because the user can get
 * unexpected results. In any case, the command vector restructuring
 * code is present and the user can choose it by setting noambiguous
 */
static Char *
splicepipe(struct command *t, Char *cp) /* word after < or > */
{
    Char *blk[2];

    if (adrof(STRnoambiguous)) {
	Char **pv;

	blk[0] = Dfix1(cp); /* expand $ */
	blk[1] = NULL;

	gflag = 0, tglob(blk);
	if (gflag) {
	    pv = globall(blk);
	    if (pv == NULL) {
		setname(vis_str(blk[0]));
		free(blk[0]);
		stderror(ERR_NAME | ERR_NOMATCH);
	    }
	    gargv = NULL;
	    if (pv[1] != NULL) { /* we need to fix the command vector */
		Char **av = blkspl(t->t_dcom, &pv[1]);
		free(t->t_dcom);
		t->t_dcom = av;
	    }
	    free(blk[0]);
	    blk[0] = pv[0];
	    free(pv);
	}
    }
    else {
	blk[0] = globone(blk[1] = Dfix1(cp), G_ERROR);
	free(blk[1]);
    }
    return(blk[0]);
}

/*
 * Perform io redirection.
 * We may or maynot be forked here.
 */
static void
doio(struct command *t, int *pipein, int *pipeout)
{
    int fd;
    Char *cp;
    int flags = t->t_dflg;

    if (didfds || (flags & F_REPEAT))
	return;
    if ((flags & F_READ) == 0) {/* F_READ already done */
	if (t->t_dlef) {
	    char    tmp[PATH_MAX];

	    /*
	     * so < /dev/std{in,out,err} work
	     */
	    (void) dcopy(SHIN, 0);
	    (void) dcopy(SHOUT, 1);
	    (void) dcopy(SHERR, 2);
	    cp = splicepipe(t, t->t_dlef);
	    strlcpy(tmp, short2str(cp), sizeof tmp);
	    free(cp);
	    if ((fd = open(tmp, O_RDONLY)) < 0)
		stderror(ERR_SYSTEM, tmp, strerror(errno));
	    (void) dmove(fd, 0);
	}
	else if (flags & F_PIPEIN) {
	    (void) close(0);
	    (void) dup(pipein[0]);
	    (void) close(pipein[0]);
	    (void) close(pipein[1]);
	}
	else if ((flags & F_NOINTERRUPT) && tpgrp == -1) {
	    (void) close(0);
	    (void) open(_PATH_DEVNULL, O_RDONLY);
	}
	else {
	    (void) close(0);
	    (void) dup(OLDSTD);
	    (void) fcntl(STDIN_FILENO, F_SETFD, 0);
	}
    }
    if (t->t_drit) {
	char    tmp[PATH_MAX];

	cp = splicepipe(t, t->t_drit);
	strlcpy(tmp, short2str(cp), sizeof tmp);
	free(cp);
	/*
	 * so > /dev/std{out,err} work
	 */
	(void) dcopy(SHOUT, 1);
	(void) dcopy(SHERR, 2);
	if ((flags & F_APPEND) &&
	    (fd = open(tmp, O_WRONLY | O_APPEND)) >= 0);
	else {
	    if (!(flags & F_OVERWRITE) && adrof(STRnoclobber)) {
		if (flags & F_APPEND)
		    stderror(ERR_SYSTEM, tmp, strerror(errno));
		chkclob(tmp);
	    }
	    if ((fd = open(tmp, O_WRONLY | O_CREAT | O_TRUNC, 0666)) < 0)
		stderror(ERR_SYSTEM, tmp, strerror(errno));
	}
	(void) dmove(fd, 1);
    }
    else if (flags & F_PIPEOUT) {
	(void) close(1);
	(void) dup(pipeout[1]);
    }
    else {
	(void) close(1);
	(void) dup(SHOUT);
	(void) fcntl(STDOUT_FILENO, F_SETFD, 0);
    }

    (void) close(2);
    if (flags & F_STDERR) {
	(void) dup(1);
    }
    else {
	(void) dup(SHERR);
	(void) fcntl(STDERR_FILENO, F_SETFD, 0);
    }
    didfds = 1;
}

void
mypipe(int *pv)
{

    if (pipe(pv) < 0)
	goto oops;
    pv[0] = dmove(pv[0], -1);
    pv[1] = dmove(pv[1], -1);
    if (pv[0] >= 0 && pv[1] >= 0)
	return;
oops:
    stderror(ERR_PIPE);
}

static void
chkclob(char *cp)
{
    struct stat stb;

    if (stat(cp, &stb) < 0)
	return;
    if (S_ISCHR(stb.st_mode))
	return;
    stderror(ERR_EXISTS, cp);
}
@


1.21
log
@Replace handrolled xfree() function by directly using free(3)

OK mmcc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.20 2015/10/26 22:03:06 naddy Exp $	*/
a33 1
#include <sys/ioctl.h>
d549 1
a549 1
	    (void) ioctl(STDIN_FILENO, FIONCLEX, NULL);
d583 1
a583 1
	(void) ioctl(STDOUT_FILENO, FIONCLEX, NULL);
d592 1
a592 1
	(void) ioctl(STDERR_FILENO, FIONCLEX, NULL);
@


1.20
log
@miscellaneous cruft:
* remove lint
* unifdef S_IFLNK, S_ISFIFO, S_ISLNK, S_ISSOCK, O_APPEND
* remove 0, NOTUSED, notdef -- untouched since original import
* remove IIASA
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.19 2015/02/08 05:47:28 tedu Exp $	*/
d276 1
a276 1
		    xfree(Vsav);
d278 1
a278 1
		    xfree(Vdp);
d280 1
a280 1
		    xfree(Vexpath);
d486 1
a486 1
		xfree(blk[0]);
d492 1
a492 1
		xfree(t->t_dcom);
d495 1
a495 1
	    xfree(blk[0]);
d497 1
a497 1
	    xfree(pv);
d502 1
a502 1
	xfree(blk[1]);
d532 1
a532 1
	    xfree(cp);
d558 1
a558 1
	xfree(cp);
@


1.19
log
@delete lots of unnecessary ptr_t casts, and drop a little NULL in as well
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.18 2015/01/16 06:39:31 deraadt Exp $	*/
a564 1
#ifdef O_APPEND
a565 4
#else
	    (fd = open(tmp, O_WRONLY)) >= 0)
	    (void) lseek(STDOUT_FILENO, (off_t) 0, SEEK_END);
#endif
@


1.18
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.17 2010/08/12 02:00:27 kevlo Exp $	*/
d253 1
a253 1
		Vsav = Vdp = 0;
d276 6
a281 6
		    xfree((ptr_t) Vsav);
		    Vsav = 0;
		    xfree((ptr_t) Vdp);
		    Vdp = 0;
		    xfree((ptr_t) Vexpath);
		    Vexpath = 0;
d283 1
a283 1
		    Vt = 0;
d486 1
a486 1
		xfree((ptr_t) blk[0]);
d492 1
a492 1
		xfree((ptr_t) t->t_dcom);
d495 1
a495 1
	    xfree((ptr_t) blk[0]);
d497 1
a497 1
	    xfree((ptr_t) pv);
d502 1
a502 1
	xfree((ptr_t) blk[1]);
d532 1
a532 1
	    xfree((ptr_t) cp);
d558 1
a558 1
	xfree((ptr_t) cp);
@


1.17
log
@Use symbolic names for the file descriptors rather than numeric values.
Some from damien@@, millert@@

ok phessler@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.16 2009/10/27 23:59:21 deraadt Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d41 1
d522 1
a522 1
	    char    tmp[MAXPATHLEN];
d554 1
a554 1
	char    tmp[MAXPATHLEN];
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.15 2003/06/11 21:09:50 deraadt Exp $	*/
d549 1
a549 1
	    (void) ioctl(0, FIONCLEX, NULL);
d568 1
a568 1
	    (void) lseek(1, (off_t) 0, SEEK_END);
d588 1
a588 1
	(void) ioctl(1, FIONCLEX, NULL);
d597 1
a597 1
	(void) ioctl(2, FIONCLEX, NULL);
@


1.15
log
@de-register and ansify functions
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.14 2003/06/02 23:32:07 millert Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)sem.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: sem.c,v 1.14 2003/06/02 23:32:07 millert Exp $";
#endif
#endif /* not lint */
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.13 2003/04/15 01:17:33 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: sem.c,v 1.13 2003/04/15 01:17:33 deraadt Exp $";
d61 1
a61 3
execute(t, wanttty, pipein, pipeout)
    register struct command *t;
    int     wanttty, *pipein, *pipeout;
d457 1
a457 2
vffree(i)
int i;
d478 1
a478 3
splicepipe(t, cp)
    register struct command *t;
    Char *cp;	/* word after < or > */
d519 1
a519 3
doio(t, pipein, pipeout)
    register struct command *t;
    int    *pipein, *pipeout;
d521 3
a523 3
    register int fd;
    register Char *cp;
    register int flags = t->t_dflg;
d611 1
a611 2
mypipe(pv)
    register int *pv;
d625 1
a625 2
chkclob(cp)
    register char *cp;
@


1.13
log
@remove final call to Strcpy/s_strcpy; some help from tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.12 2003/01/08 06:54:16 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: sem.c,v 1.12 2003/01/08 06:54:16 deraadt Exp $";
@


1.12
log
@bring in strlcpy and strlcat-like things for dealing with Char types,
this fixes at least 15 buffer overflows; some help from dhartmei.
Anyone want to go do the same in ksh, and help with some of the while
(*s++ = *p++) loops in here?
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.11 2002/02/19 19:39:35 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: sem.c,v 1.11 2002/02/19 19:39:35 millert Exp $";
d94 2
a95 1
	    (void) Strcpy(t->t_dcom[0], t->t_dcom[0] + 1); /* safe */
@


1.11
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.10 2002/02/16 21:27:06 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: sem.c,v 1.10 2002/02/16 21:27:06 millert Exp $";
d94 1
a94 1
	    (void) Strcpy(t->t_dcom[0], t->t_dcom[0] + 1);
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.9 2001/12/01 19:10:39 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: sem.c,v 1.9 2001/12/01 19:10:39 deraadt Exp $";
d53 1
a53 5
#ifdef __STDC__
# include <stdarg.h>
#else
# include <varargs.h>
#endif
@


1.9
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.8 2001/06/22 21:07:35 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: sem.c,v 1.8 2001/06/22 21:07:35 deraadt Exp $";
d63 4
a66 4
static void	 vffree __P((int));
static Char	*splicepipe __P((struct command *t, Char *));
static void	 doio __P((struct command *t, int *, int *));
static void	 chkclob __P((char *));
@


1.8
log
@mark signal races, and remove junk
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.7 2001/05/11 18:38:44 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: sem.c,v 1.7 2001/05/11 18:38:44 mickey Exp $";
d211 1
a211 1
	     bifunc->bfunct == doeval))
d354 1
@


1.7
log
@use strlcpy instead of strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.6 1998/08/26 08:00:07 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: sem.c,v 1.6 1998/08/26 08:00:07 deraadt Exp $";
a467 10
    register Char **v;

    if ((v = gargv) != NULL) {
	gargv = 0;
	xfree((ptr_t) v);
    }
    if ((v = pargv) != NULL) {
	pargv = 0;
	xfree((ptr_t) v);
    }
@


1.6
log
@do not *NULL -- i think this patch is right
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.5 1998/05/18 20:38:21 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: sem.c,v 1.5 1998/05/18 20:38:21 deraadt Exp $";
d170 1
a170 1
 	    if (noexec) {
d455 1
a455 1
     * 
d493 1
a493 1
 * unexpected results. In any case, the command vector restructuring 
d561 1
a561 2
	    (void) strncpy(tmp, short2str(cp), sizeof tmp-1);
	    tmp[sizeof tmp-1] = '\0';
d587 1
a587 2
	(void) strncpy(tmp, short2str(cp), sizeof tmp-1);
	tmp[sizeof tmp-1] = '\0';
@


1.5
log
@MAXPATHLEN not MAXPATHLEN+1
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.4 1997/07/25 18:58:16 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: sem.c,v 1.4 1997/07/25 18:58:16 mickey Exp $";
d174 2
a175 1
		if (bifunc->bfunct != dobreak   && bifunc->bfunct != docontin &&
@


1.4
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.3 1997/07/23 14:36:51 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: sem.c,v 1.3 1997/07/23 14:36:51 kstailey Exp $";
d551 1
a551 1
	    char    tmp[MAXPATHLEN+1];
d560 2
a561 2
	    (void) strncpy(tmp, short2str(cp), MAXPATHLEN);
	    tmp[MAXPATHLEN] = '\0';
d584 1
a584 1
	char    tmp[MAXPATHLEN+1];
d587 2
a588 2
	(void) strncpy(tmp, short2str(cp), MAXPATHLEN);
	tmp[MAXPATHLEN] = '\0';
@


1.3
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.2 1996/06/23 14:19:29 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: sem.c,v 1.2 1996/06/23 14:19:29 deraadt Exp $";
d53 1
a53 1
#if __STDC__
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: sem.c,v 1.9 1995/09/27 00:38:50 jtc Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: sem.c,v 1.9 1995/09/27 00:38:50 jtc Exp $";
d309 1
a309 1
		        sigprocmask(SIG_SETMASK, &csigset, NULL);
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: sem.c,v 1.9 1995/09/27 00:38:50 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
