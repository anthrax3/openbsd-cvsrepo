head	1.21;
access;
symbols
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.14.0.20
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.16
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.26
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.22
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.20
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.18
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.16
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.14
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.12
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.10
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.8
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.6
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.4.0.14
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.12
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2015.12.26.13.48.38;	author mestre;	state Exp;
branches;
next	1.20;
commitid	jZMsEASvreUUSdqp;

1.20
date	2015.02.08.06.09.50;	author tedu;	state Exp;
branches;
next	1.19;
commitid	i1nyRcSvJDMCYw84;

1.19
date	2015.02.08.05.51.37;	author tedu;	state Exp;
branches;
next	1.18;
commitid	L3WalZJ5Trtg0ORm;

1.18
date	2015.01.16.06.39.31;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Uu5nFG3wCl0LACBb;

1.17
date	2014.10.16.19.43.31;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	jIHreojPTUQy0Zyb;

1.16
date	2014.07.12.02.47.51;	author guenther;	state Exp;
branches;
next	1.15;
commitid	GhhP8tY8naZgXxKf;

1.15
date	2014.07.11.07.54.04;	author tedu;	state Exp;
branches;
next	1.14;
commitid	T5ptCxh8aIgLJzxQ;

1.14
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.25.15.29.06;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.11.21.09.50;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.32.07;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.08.19.52.56;	author vincent;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.08.06.54.16;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.12.00.42.56;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.05.18.20.37.19;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.07.25.18.58.00;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Replace handrolled xfree() function by directly using free(3)

OK mmcc@@
@
text
@/*	$OpenBSD: dir.c,v 1.20 2015/02/08 06:09:50 tedu Exp $	*/
/*	$NetBSD: dir.c,v 1.9 1995/03/21 09:02:42 cgd Exp $	*/

/*-
 * Copyright (c) 1980, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <stdarg.h>

#include "csh.h"
#include "dir.h"
#include "extern.h"

/* Directory management. */

static struct directory
		*dfind(Char *);
static Char	*dfollow(Char *);
static void	 printdirs(void);
static Char	*dgoto(Char *);
static void	 dnewcwd(struct directory *);
static void	 dset(Char *);

struct directory dhead;		/* "head" of loop */
int     printd;			/* force name to be printed */

static int dirflag = 0;

/*
 * dinit - initialize current working directory
 */
void
dinit(Char *hp)
{
    char *tcp;
    Char *cp;
    struct directory *dp;
    char    path[PATH_MAX];
    static const char emsg[] = "csh: Trying to start from \"%s\"\n";

    /* Don't believe the login shell home, because it may be a symlink */
    tcp = getcwd(path, PATH_MAX);
    if (tcp == NULL || *tcp == '\0') {
	(void) fprintf(csherr, "csh: %s\n", strerror(errno));
	if (hp && *hp) {
	    tcp = short2str(hp);
	    if (chdir(tcp) == -1)
		cp = NULL;
	    else
		cp = hp;
	    (void) fprintf(csherr, emsg, vis_str(hp));
	}
	else
	    cp = NULL;
	if (cp == NULL) {
	    (void) fprintf(csherr, emsg, "/");
	    if (chdir("/") == -1)
		/* I am not even try to print an error message! */
		xexit(1);
	    cp = SAVE("/");
	}
    }
    else {
	struct stat swd, shp;

	/*
	 * See if $HOME is the working directory we got and use that
	 */
	if (hp && *hp &&
	    stat(tcp, &swd) != -1 && stat(short2str(hp), &shp) != -1 &&
	    swd.st_dev == shp.st_dev && swd.st_ino == shp.st_ino)
	    cp = hp;
	else {
	    char   *cwd;

	    /*
	     * use PWD if we have it (for subshells)
	     */
	    if ((cwd = getenv("PWD")) != NULL) {
		if (stat(cwd, &shp) != -1 && swd.st_dev == shp.st_dev &&
		    swd.st_ino == shp.st_ino)
		    tcp = cwd;
	    }
	    cp = dcanon(SAVE(tcp), STRNULL);
	}
    }

    dp = xcalloc(1, sizeof(struct directory));
    dp->di_name = Strsave(cp);
    dp->di_count = 0;
    dhead.di_next = dhead.di_prev = dp;
    dp->di_next = dp->di_prev = &dhead;
    printd = 0;
    dnewcwd(dp);
}

static void
dset(Char *dp)
{
    /*
     * Don't call set() directly cause if the directory contains ` or
     * other junk characters glob will fail.
     */
    Char **vec = xreallocarray(NULL, 2, sizeof(Char **));

    vec[0] = Strsave(dp);
    vec[1] = 0;
    setq(STRcwd, vec, &shvhed);
    Setenv(STRPWD, dp);
}

#define DIR_LONG 1
#define DIR_VERT 2
#define DIR_LINE 4

static void
skipargs(Char ***v, char *str)
{
    Char  **n = *v, *s;

    dirflag = 0;
    for (n++; *n != NULL && (*n)[0] == '-'; n++)
	for (s = &((*n)[1]); *s; s++)
	    switch (*s) {
	    case 'l':
		dirflag |= DIR_LONG;
		break;
	    case 'v':
		dirflag |= DIR_VERT;
		break;
	    case 'n':
		dirflag |= DIR_LINE;
		break;
	    default:
		stderror(ERR_DIRUS, vis_str(**v), str);
		break;
	    }
    *v = n;
}

/*
 * dodirs - list all directories in directory loop
 */
void
/*ARGSUSED*/
dodirs(Char **v, struct command *t)
{
    skipargs(&v, "");

    if (*v != NULL)
	stderror(ERR_DIRUS, "dirs", "");
    printdirs();
}

static void
printdirs(void)
{
    struct directory *dp;
    Char   *s, *hp = value(STRhome);
    int     idx, len, cur;

    if (*hp == '\0')
	hp = NULL;
    dp = dcwd;
    idx = 0;
    cur = 0;
    do {
	if (dp == &dhead)
	    continue;
	if (dirflag & DIR_VERT) {
	    (void) fprintf(cshout, "%d\t", idx++);
	    cur = 0;
	}
	if (!(dirflag & DIR_LONG) && hp != NULL && !eq(hp, STRslash) &&
	    (len = Strlen(hp), Strncmp(hp, dp->di_name, len) == 0) &&
	    (dp->di_name[len] == '\0' || dp->di_name[len] == '/'))
	    len = Strlen(s = (dp->di_name + len)) + 2;
	else
	    len = Strlen(s = dp->di_name) + 1;

	cur += len;
	if ((dirflag & DIR_LINE) && cur >= 80 - 1 && len < 80) {
	    (void) fprintf(cshout, "\n");
	    cur = len;
	}
	(void) fprintf(cshout, s != dp->di_name ? "~%s%c" : "%s%c",
		vis_str(s), (dirflag & DIR_VERT) ? '\n' : ' ');
    } while ((dp = dp->di_prev) != dcwd);
    if (!(dirflag & DIR_VERT))
	(void) fprintf(cshout, "\n");
}

void
dtildepr(Char *home, Char *dir)
{

    if (!eq(home, STRslash) && prefix(home, dir))
	(void) fprintf(cshout, "~%s", vis_str(dir + Strlen(home)));
    else
	(void) fprintf(cshout, "%s", vis_str(dir));
}

void
dtilde(void)
{
    struct directory *d = dcwd;

    do {
	if (d == &dhead)
	    continue;
	d->di_name = dcanon(d->di_name, STRNULL);
    } while ((d = d->di_prev) != dcwd);

    dset(dcwd->di_name);
}


/* dnormalize():
 *	If the name starts with . or .. then we might need to normalize
 *	it depending on the symbolic link flags
 */
Char   *
dnormalize(Char *cp)
{

#define UC (unsigned char)
#define ISDOT(c) (UC(c)[0] == '.' && ((UC(c)[1] == '\0') || (UC(c)[1] == '/')))
#define ISDOTDOT(c) (UC(c)[0] == '.' && ISDOT(&((c)[1])))

    if ((unsigned char) cp[0] == '/')
	return (Strsave(cp));

    if (adrof(STRignore_symlinks)) {
	int     dotdot = 0;
	Char   *dp, *cwd;
	size_t	len;

	len = (size_t) (Strlen(dcwd->di_name) + 3);
	cwd = xreallocarray(NULL, len, sizeof(Char));
	(void) Strlcpy(cwd, dcwd->di_name, len);

	/*
	 * Ignore . and count ..'s
	 */
	while (*cp) {
	    if (ISDOT(cp)) {
		if (*++cp)
		    cp++;
	    }
	    else if (ISDOTDOT(cp)) {
		dotdot++;
		cp += 2;
		if (*cp)
		    cp++;
	    }
	    else
		break;
	}
	while (dotdot > 0)
	    if ((dp = Strrchr(cwd, '/'))) {
		*dp = '\0';
		dotdot--;
	    }
	    else
		break;

	if (*cp) {
	    cwd[dotdot = Strlen(cwd)] = '/';
	    cwd[dotdot + 1] = '\0';
	    dp = Strspl(cwd, cp);
	    free(cwd);
	    return dp;
	}
	else {
	    if (!*cwd) {
		cwd[0] = '/';
		cwd[1] = '\0';
	    }
	    return cwd;
	}
    }
    return Strsave(cp);
}

/*
 * dochngd - implement chdir command.
 */
void
/*ARGSUSED*/
dochngd(Char **v, struct command *t)
{
    Char *cp;
    struct directory *dp;

    skipargs(&v, " [<dir>]");
    printd = 0;
    if (*v == NULL) {
	if ((cp = value(STRhome)) == NULL || *cp == 0)
	    stderror(ERR_NAME | ERR_NOHOMEDIR);
	if (chdir(short2str(cp)) < 0)
	    stderror(ERR_NAME | ERR_CANTCHANGE);
	cp = Strsave(cp);
    }
    else if (v[1] != NULL) {
	stderror(ERR_NAME | ERR_TOOMANY);
	/* NOTREACHED */
	return;
    }
    else if ((dp = dfind(*v)) != 0) {
	char   *tmp;

	printd = 1;
	if (chdir(tmp = short2str(dp->di_name)) < 0)
	    stderror(ERR_SYSTEM, tmp, strerror(errno));
	dcwd->di_prev->di_next = dcwd->di_next;
	dcwd->di_next->di_prev = dcwd->di_prev;
	dfree(dcwd);
	dnewcwd(dp);
	return;
    }
    else
	cp = dfollow(*v);
    dp = xcalloc(1, sizeof(struct directory));
    dp->di_name = cp;
    dp->di_count = 0;
    dp->di_next = dcwd->di_next;
    dp->di_prev = dcwd->di_prev;
    dp->di_prev->di_next = dp;
    dp->di_next->di_prev = dp;
    dfree(dcwd);
    dnewcwd(dp);
}

static Char *
dgoto(Char *cp)
{
    Char   *dp;

    if (*cp != '/') {
	Char *p, *q;
	int     cwdlen;

	for (p = dcwd->di_name; *p++;)
	    continue;
	if ((cwdlen = p - dcwd->di_name - 1) == 1)	/* root */
	    cwdlen = 0;
	for (p = cp; *p++;)
	    continue;
	dp = xreallocarray(NULL, (cwdlen + (p - cp) + 1), sizeof(Char));
	for (p = dp, q = dcwd->di_name; (*p++ = *q++) != '\0';)
	    continue;
	if (cwdlen)
	    p[-1] = '/';
	else
	    p--;		/* don't add a / after root */
	for (q = cp; (*p++ = *q++) != '\0';)
	    continue;
	free(cp);
	cp = dp;
	dp += cwdlen;
    }
    else
	dp = cp;

    cp = dcanon(cp, dp);
    return cp;
}

/*
 * dfollow - change to arg directory; fall back on cdpath if not valid
 */
static Char *
dfollow(Char *cp)
{
    Char *dp;
    struct varent *c;
    char    ebuf[PATH_MAX];
    int serrno;

    cp = globone(cp, G_ERROR);
    /*
     * if we are ignoring symlinks, try to fix relatives now.
     */
    dp = dnormalize(cp);
    if (chdir(short2str(dp)) >= 0) {
	free(cp);
	return dgoto(dp);
    }
    else {
	free(dp);
	if (chdir(short2str(cp)) >= 0)
	    return dgoto(cp);
	serrno = errno;
    }

    if (cp[0] != '/' && !prefix(STRdotsl, cp) && !prefix(STRdotdotsl, cp)
	&& (c = adrof(STRcdpath))) {
	Char  **cdp;
	Char *p;
	Char    buf[PATH_MAX];

	for (cdp = c->vec; *cdp; cdp++) {
	    for (dp = buf, p = *cdp; (*dp++ = *p++) != '\0';)
		continue;
	    dp[-1] = '/';
	    for (p = cp; (*dp++ = *p++) != '\0';)
		continue;
	    if (chdir(short2str(buf)) >= 0) {
		printd = 1;
		free(cp);
		cp = Strsave(buf);
		return dgoto(cp);
	    }
	}
    }
    dp = value(cp);
    if ((dp[0] == '/' || dp[0] == '.') && chdir(short2str(dp)) >= 0) {
	free(cp);
	cp = Strsave(dp);
	printd = 1;
	return dgoto(cp);
    }
    (void) strlcpy(ebuf, short2str(cp), sizeof ebuf);
    free(cp);
    stderror(ERR_SYSTEM, ebuf, strerror(serrno));
    return (NULL);
}


/*
 * dopushd - push new directory onto directory stack.
 *	with no arguments exchange top and second.
 *	with numeric argument (+n) bring it to top.
 */
void
/*ARGSUSED*/
dopushd(Char **v, struct command *t)
{
    struct directory *dp;

    skipargs(&v, " [<dir>|+<n>]");
    printd = 1;
    if (*v == NULL) {
	char   *tmp;

	if ((dp = dcwd->di_prev) == &dhead)
	    dp = dhead.di_prev;
	if (dp == dcwd)
	    stderror(ERR_NAME | ERR_NODIR);
	if (chdir(tmp = short2str(dp->di_name)) < 0)
	    stderror(ERR_SYSTEM, tmp, strerror(errno));
	dp->di_prev->di_next = dp->di_next;
	dp->di_next->di_prev = dp->di_prev;
	dp->di_next = dcwd->di_next;
	dp->di_prev = dcwd;
	dcwd->di_next->di_prev = dp;
	dcwd->di_next = dp;
    }
    else if (v[1] != NULL) {
	stderror(ERR_NAME | ERR_TOOMANY);
	/* NOTREACHED */
	return;
    }
    else if ((dp = dfind(*v)) != NULL) {
	char   *tmp;

	if (chdir(tmp = short2str(dp->di_name)) < 0)
	    stderror(ERR_SYSTEM, tmp, strerror(errno));
    }
    else {
	Char *ccp;

	ccp = dfollow(*v);
	dp = xcalloc(1, sizeof(struct directory));
	dp->di_name = ccp;
	dp->di_count = 0;
	dp->di_prev = dcwd;
	dp->di_next = dcwd->di_next;
	dcwd->di_next = dp;
	dp->di_next->di_prev = dp;
    }
    dnewcwd(dp);
}

/*
 * dfind - find a directory if specified by numeric (+n) argument
 */
static struct directory *
dfind(Char *cp)
{
    struct directory *dp;
    int i;
    Char *ep;

    if (*cp++ != '+')
	return (0);
    for (ep = cp; Isdigit(*ep); ep++)
	continue;
    if (*ep)
	return (0);
    i = getn(cp);
    if (i <= 0)
	return (0);
    for (dp = dcwd; i != 0; i--) {
	if ((dp = dp->di_prev) == &dhead)
	    dp = dp->di_prev;
	if (dp == dcwd)
	    stderror(ERR_NAME | ERR_DEEP);
    }
    return (dp);
}

/*
 * dopopd - pop a directory out of the directory stack
 *	with a numeric argument just discard it.
 */
void
/*ARGSUSED*/
dopopd(Char **v, struct command *t)
{
    struct directory *dp, *p = NULL;

    skipargs(&v, " [+<n>]");
    printd = 1;
    if (*v == NULL)
	dp = dcwd;
    else if (v[1] != NULL) {
	stderror(ERR_NAME | ERR_TOOMANY);
	/* NOTREACHED */
	return;
    }
    else if ((dp = dfind(*v)) == 0)
	stderror(ERR_NAME | ERR_BADDIR);
    if (dp->di_prev == &dhead && dp->di_next == &dhead)
	stderror(ERR_NAME | ERR_EMPTY);
    if (dp == dcwd) {
	char   *tmp;

	if ((p = dp->di_prev) == &dhead)
	    p = dhead.di_prev;
	if (chdir(tmp = short2str(p->di_name)) < 0)
	    stderror(ERR_SYSTEM, tmp, strerror(errno));
    }
    dp->di_prev->di_next = dp->di_next;
    dp->di_next->di_prev = dp->di_prev;
    if (dp == dcwd)
	dnewcwd(p);
    else {
	printdirs();
    }
    dfree(dp);
}

/*
 * dfree - free the directory (or keep it if it still has ref count)
 */
void
dfree(struct directory *dp)
{

    if (dp->di_count != 0) {
	dp->di_next = dp->di_prev = 0;
    }
    else {
	free((char *) dp->di_name);
	free(dp);
    }
}

/*
 * dcanon - canonicalize the pathname, removing excess ./ and ../ etc.
 *	we are of course assuming that the file system is standardly
 *	constructed (always have ..'s, directories have links)
 */
Char   *
dcanon(Char *cp, Char *p)
{
    Char *sp;
    Char *p1, *p2;	/* general purpose */
    bool    slash;

    Char    link[PATH_MAX];
    char    tlink[PATH_MAX];
    int     cc;
    Char   *newcp;

    /*
     * christos: if the path given does not start with a slash prepend cwd. If
     * cwd does not start with a path or the result would be too long abort().
     */
    if (*cp != '/') {
	Char    tmpdir[PATH_MAX];

	p1 = value(STRcwd);
	if (p1 == NULL || *p1 != '/')
	    abort();
	if (Strlen(p1) + Strlen(cp) + 1 >= PATH_MAX)
	    abort();
	(void) Strlcpy(tmpdir, p1, sizeof tmpdir/sizeof(Char));
	(void) Strlcat(tmpdir, STRslash, sizeof tmpdir/sizeof(Char));
	(void) Strlcat(tmpdir, cp, sizeof tmpdir/sizeof(Char));
	free(cp);
	cp = p = Strsave(tmpdir);
    }

    while (*p) {		/* for each component */
	sp = p;			/* save slash address */
	while (*++p == '/')	/* flush extra slashes */
	    continue;
	if (p != ++sp)
	    for (p1 = sp, p2 = p; (*p1++ = *p2++) != '\0';)
		continue;
	p = sp;			/* save start of component */
	slash = 0;
	while (*p)		/* find next slash or end of path */
	    if (*++p == '/') {
		slash = 1;
		*p = 0;
		break;
	    }

	if (*sp == '\0')	/* if component is null */
	    if (--sp == cp)	/* if path is one char (i.e. /) */
		break;
	    else
		*sp = '\0';
	else if (sp[0] == '.' && sp[1] == 0) {
	    if (slash) {
		for (p1 = sp, p2 = p + 1; (*p1++ = *p2++) != '\0';)
		    continue;
		p = --sp;
	    }
	    else if (--sp != cp)
		*sp = '\0';
	}
	else if (sp[0] == '.' && sp[1] == '.' && sp[2] == 0) {
	    /*
	     * We have something like "yyy/xxx/..", where "yyy" can be null or
	     * a path starting at /, and "xxx" is a single component. Before
	     * compressing "xxx/..", we want to expand "yyy/xxx", if it is a
	     * symbolic link.
	     */
	    *--sp = 0;		/* form the pathname for readlink */
	    if (sp != cp && !adrof(STRignore_symlinks) &&
		(cc = readlink(short2str(cp), tlink,
			       sizeof tlink-1)) >= 0) {
		tlink[cc] = '\0';
		(void) Strlcpy(link, str2short(tlink), sizeof link/sizeof(Char));

		if (slash)
		    *p = '/';
		/*
		 * Point p to the '/' in "/..", and restore the '/'.
		 */
		*(p = sp) = '/';
		/*
		 * find length of p
		 */
		for (p1 = p; *p1++;)
		    continue;
		if (*link != '/') {
		    /*
		     * Relative path, expand it between the "yyy/" and the
		     * "/..". First, back sp up to the character past "yyy/".
		     */
		    while (*--sp != '/')
			continue;
		    sp++;
		    *sp = 0;
		    /*
		     * New length is "yyy/" + link + "/.." and rest
		     */
		    p1 = newcp = xreallocarray(NULL,
			(sp - cp) + cc + (p1 - p), sizeof(Char));
		    /*
		     * Copy new path into newcp
		     */
		    for (p2 = cp; (*p1++ = *p2++) != '\0';)
			continue;
		    for (p1--, p2 = link; (*p1++ = *p2++) != '\0';)
			continue;
		    for (p1--, p2 = p; (*p1++ = *p2++) != '\0';)
			continue;
		    /*
		     * Restart canonicalization at expanded "/xxx".
		     */
		    p = sp - cp - 1 + newcp;
		}
		else {
		    /*
		     * New length is link + "/.." and rest
		     */
		    p1 = newcp = xreallocarray(NULL, cc + (p1 - p),
		        sizeof(Char));
		    /*
		     * Copy new path into newcp
		     */
		    for (p2 = link; (*p1++ = *p2++) != '\0';)
			continue;
		    for (p1--, p2 = p; (*p1++ = *p2++) != '\0';)
			continue;
		    /*
		     * Restart canonicalization at beginning
		     */
		    p = newcp;
		}
		free(cp);
		cp = newcp;
		continue;	/* canonicalize the link */
	    }
	    *sp = '/';
	    if (sp != cp)
		while (*--sp != '/')
		    continue;
	    if (slash) {
		for (p1 = sp + 1, p2 = p + 1; (*p1++ = *p2++) != '\0';)
		    continue;
		p = sp;
	    }
	    else if (cp == sp)
		*++sp = '\0';
	    else
		*sp = '\0';
	}
	else {			/* normal dir name (not . or .. or nothing) */

	    if (sp != cp && adrof(STRchase_symlinks) &&
		!adrof(STRignore_symlinks) &&
		(cc = readlink(short2str(cp), tlink,
			       sizeof tlink-1)) >= 0) {
		tlink[cc] = '\0';
		(void) Strlcpy(link, str2short(tlink), sizeof link/sizeof(Char));

		/*
		 * restore the '/'.
		 */
		if (slash)
		    *p = '/';

		/*
		 * point sp to p (rather than backing up).
		 */
		sp = p;

		/*
		 * find length of p
		 */
		for (p1 = p; *p1++;)
		    continue;
		if (*link != '/') {
		    /*
		     * Relative path, expand it between the "yyy/" and the
		     * remainder. First, back sp up to the character past
		     * "yyy/".
		     */
		    while (*--sp != '/')
			continue;
		    sp++;
		    *sp = 0;
		    /*
		     * New length is "yyy/" + link + "/.." and rest
		     */
		    p1 = newcp = xreallocarray(NULL,
			  (sp - cp) + cc + (p1 - p), sizeof(Char));
		    /*
		     * Copy new path into newcp
		     */
		    for (p2 = cp; (*p1++ = *p2++) != '\0';)
			continue;
		    for (p1--, p2 = link; (*p1++ = *p2++) != '\0';)
			continue;
		    for (p1--, p2 = p; (*p1++ = *p2++) != '\0';)
			continue;
		    /*
		     * Restart canonicalization at expanded "/xxx".
		     */
		    p = sp - cp - 1 + newcp;
		}
		else {
		    /*
		     * New length is link + the rest
		     */
		    p1 = newcp = xreallocarray(NULL, cc + (p1 - p), sizeof(Char));
		    /*
		     * Copy new path into newcp
		     */
		    for (p2 = link; (*p1++ = *p2++) != '\0';)
			continue;
		    for (p1--, p2 = p; (*p1++ = *p2++) != '\0';)
			continue;
		    /*
		     * Restart canonicalization at beginning
		     */
		    p = newcp;
		}
		free(cp);
		cp = newcp;
		continue;	/* canonicalize the link */
	    }
	    if (slash)
		*p = '/';
	}
    }

    /*
     * fix home...
     */
    p1 = value(STRhome);
    cc = Strlen(p1);
    /*
     * See if we're not in a subdir of STRhome
     */
    if (p1 && *p1 == '/' &&
	(Strncmp(p1, cp, cc) != 0 || (cp[cc] != '/' && cp[cc] != '\0'))) {
	static ino_t home_ino = -1;
	static dev_t home_dev = -1;
	static Char *home_ptr = NULL;
	struct stat statbuf;

	/*
	 * Get dev and ino of STRhome
	 */
	if (home_ptr != p1 &&
	    stat(short2str(p1), &statbuf) != -1) {
	    home_dev = statbuf.st_dev;
	    home_ino = statbuf.st_ino;
	    home_ptr = p1;
	}
	/*
	 * Start comparing dev & ino backwards
	 */
	Strlcpy(link, cp, sizeof link/sizeof(Char));
	p2 = link;
	for (sp = NULL; *p2 && stat(short2str(p2), &statbuf) != -1;) {
	    if (statbuf.st_dev == home_dev &&
		statbuf.st_ino == home_ino) {
		sp = (Char *) - 1;
		break;
	    }
	    if ((sp = Strrchr(p2, '/')) != NULL)
		*sp = '\0';
	}
	/*
	 * See if we found it
	 */
	if (*p2 && sp == (Char *) -1) {
	    /*
	     * Use STRhome to make '~' work
	     */
	    newcp = Strspl(p1, cp + Strlen(p2));
	    free(cp);
	    cp = newcp;
	}
    }
    return cp;
}


/*
 * dnewcwd - make a new directory in the loop the current one
 */
static void
dnewcwd(struct directory *dp)
{
    dcwd = dp;
    dset(dcwd->di_name);
    if (printd && !(adrof(STRpushdsilent)))
	printdirs();
}
@


1.20
log
@delete tons more casts
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.19 2015/02/08 05:51:37 tedu Exp $	*/
d302 1
a302 1
	    xfree(cwd);
d389 1
a389 1
	xfree(cp);
d417 1
a417 1
	xfree(cp);
d421 1
a421 1
	xfree(dp);
d441 1
a441 1
		xfree(cp);
d449 1
a449 1
	xfree(cp);
d455 1
a455 1
    xfree(cp);
d596 2
a597 2
	xfree((char *) dp->di_name);
	xfree(dp);
d633 1
a633 1
	xfree(cp);
d738 1
a738 1
		xfree(cp);
d827 1
a827 1
		xfree(cp);
d882 1
a882 1
	    xfree(cp);
@


1.19
log
@delete many more ptr_t casts
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.18 2015/01/16 06:39:31 deraadt Exp $	*/
d119 1
a119 1
    dp = (struct directory *) xcalloc(1, sizeof(struct directory));
d354 1
a354 1
    dp = (struct directory *) xcalloc(1, sizeof(struct directory));
d505 1
a505 1
	dp = (struct directory *) xcalloc(1, sizeof(struct directory));
@


1.18
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.17 2014/10/16 19:43:31 deraadt Exp $	*/
d302 1
a302 1
	    xfree((ptr_t) cwd);
d389 1
a389 1
	xfree((ptr_t) cp);
d417 1
a417 1
	xfree((ptr_t) cp);
d421 1
a421 1
	xfree((ptr_t) dp);
d441 1
a441 1
		xfree((ptr_t) cp);
d449 1
a449 1
	xfree((ptr_t) cp);
d455 1
a455 1
    xfree((ptr_t) cp);
d597 1
a597 1
	xfree((ptr_t) dp);
d633 1
a633 1
	xfree((ptr_t) cp);
d738 1
a738 1
		xfree((ptr_t) cp);
d827 1
a827 1
		xfree((ptr_t) cp);
d882 1
a882 1
	    xfree((ptr_t) cp);
@


1.17
log
@Use reallocarray() and remove a few archaic memory allocation practices.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.16 2014/07/12 02:47:51 guenther Exp $	*/
a32 1
#include <sys/param.h>
d38 1
d69 1
a69 1
    char    path[MAXPATHLEN];
d73 1
a73 1
    tcp = getcwd(path, MAXPATHLEN);
d408 1
a408 1
    char    ebuf[MAXPATHLEN];
d431 1
a431 1
	Char    buf[MAXPATHLEN];
d613 2
a614 2
    Char    link[MAXPATHLEN];
    char    tlink[MAXPATHLEN];
d623 1
a623 1
	Char    tmpdir[MAXPATHLEN];
d628 1
a628 1
	if (Strlen(p1) + Strlen(cp) + 1 >= MAXPATHLEN)
@


1.16
log
@If a constant string needs a name, use a static const array instead
of a pointer or non-const array, as that minimizes the symbols,
maximizes the placement into read-only memory, and avoids warnings
from gcc -Wformat=2 when they're used as format strings.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.15 2014/07/11 07:54:04 tedu Exp $	*/
d135 1
a135 1
    Char **vec = (Char **) xmalloc((size_t) (2 * sizeof(Char **)));
d270 1
a270 1
	cwd = (Char *) xmalloc(len * sizeof(Char));
d380 1
a380 1
	dp = (Char *) xmalloc((size_t)((cwdlen + (p - cp) + 1) * sizeof(Char)));
d704 2
a705 3
		    p1 = newcp = (Char *) xmalloc((size_t)
						(((sp - cp) + cc + (p1 - p)) *
						 sizeof(Char)));
d724 2
a725 2
		    p1 = newcp = (Char *) xmalloc((size_t)
					    ((cc + (p1 - p)) * sizeof(Char)));
d794 2
a795 3
		    p1 = newcp = (Char *) xmalloc((size_t)
						  (((sp - cp) + cc + (p1 - p))
						   * sizeof(Char)));
d814 1
a814 2
		    p1 = newcp = (Char *) xmalloc((size_t)
					    ((cc + (p1 - p)) * sizeof(Char)));
@


1.15
log
@correct readlink termination. from Doug Hogan
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.14 2009/10/27 23:59:21 deraadt Exp $	*/
d70 1
a70 1
    static char *emsg = "csh: Trying to start from \"%s\"\n";
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.13 2003/09/25 15:29:06 millert Exp $	*/
d763 1
a764 1
		link[cc] = '\0';
@


1.13
log
@Fix a bug where one byte past the end of a buffer could be touched
in certain cases; closes PR 3163
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.12 2003/06/11 21:09:50 deraadt Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)dir.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: dir.c,v 1.12 2003/06/11 21:09:50 deraadt Exp $";
#endif
#endif /* not lint */
@


1.12
log
@de-register and ansify functions
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.11 2003/06/02 23:32:07 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.11 2003/06/02 23:32:07 millert Exp $";
d654 2
a655 2
	while (*++p)		/* find next slash or end of path */
	    if (*p == '/') {
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.10 2003/05/08 19:52:56 vincent Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.10 2003/05/08 19:52:56 vincent Exp $";
d72 1
a72 2
dinit(hp)
    Char   *hp;
d74 3
a76 3
    register char *tcp;
    register Char *cp;
    register struct directory *dp;
d137 1
a137 2
dset(dp)
Char *dp;
d143 1
a143 1
    register Char **vec = (Char **) xmalloc((size_t) (2 * sizeof(Char **)));
d156 1
a156 3
skipargs(v, str)
    Char ***v;
    char   *str;
d185 1
a185 3
dodirs(v, t)
    Char **v;
    struct command *t;
d195 1
a195 1
printdirs()
d197 1
a197 1
    register struct directory *dp;
d233 1
a233 2
dtildepr(home, dir)
    register Char *home, *dir;
d243 1
a243 1
dtilde()
d262 1
a262 2
dnormalize(cp)
    Char   *cp;
d329 1
a329 3
dochngd(v, t)
    Char **v;
    struct command *t;
d331 2
a332 2
    register Char *cp;
    register struct directory *dp;
d374 1
a374 2
dgoto(cp)
    Char   *cp;
d379 1
a379 1
	register Char *p, *q;
d412 1
a412 2
dfollow(cp)
    register Char *cp;
d414 1
a414 1
    register Char *dp;
d438 1
a438 1
	register Char *p;
d476 1
a476 3
dopushd(v, t)
    Char **v;
    struct command *t;
d478 1
a478 1
    register struct directory *dp;
d510 1
a510 1
	register Char *ccp;
d528 1
a528 2
dfind(cp)
    register Char *cp;
d530 3
a532 3
    register struct directory *dp;
    register int i;
    register Char *ep;
d558 1
a558 3
dopopd(v, t)
    Char **v;
    struct command *t;
d560 1
a560 1
    register struct directory *dp, *p = NULL;
d597 1
a597 2
dfree(dp)
    register struct directory *dp;
d615 1
a615 2
dcanon(cp, p)
    register Char *cp, *p;
d617 2
a618 2
    register Char *sp;
    register Char *p1, *p2;	/* general purpose */
d905 1
a905 2
dnewcwd(dp)
    register struct directory *dp;
@


1.10
log
@NUL-terminate the buffer returned by readlink() before we use it to Strlcpy()

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.9 2003/01/08 06:54:16 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.9 2003/01/08 06:54:16 deraadt Exp $";
@


1.9
log
@bring in strlcpy and strlcat-like things for dealing with Char types,
this fixes at least 15 buffer overflows; some help from dhartmei.
Anyone want to go do the same in ksh, and help with some of the while
(*s++ = *p++) loops in here?
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.8 2002/08/12 00:42:56 aaron Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.8 2002/08/12 00:42:56 aaron Exp $";
d709 1
a710 1
		link[cc] = '\0';
@


1.8
log
@Swap args to calloc(3) so they are in the correct order; art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.7 2002/06/09 05:47:27 todd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.7 2002/06/09 05:47:27 todd Exp $";
d287 1
d289 3
a291 3
	cwd = (Char *) xmalloc((size_t) ((Strlen(dcwd->di_name) + 3) *
					 sizeof(Char)));
	(void) Strcpy(cwd, dcwd->di_name);
d478 1
a478 1
    (void) strcpy(ebuf, short2str(cp));
d531 1
a531 1
	dp = (struct directory *) xcalloc(sizeof(struct directory), 1);
d661 3
a663 3
	(void) Strcpy(tmpdir, p1);
	(void) Strcat(tmpdir, STRslash);
	(void) Strcat(tmpdir, cp);
d709 1
a709 1
		(void) Strcpy(link, str2short(tlink));
d794 1
a794 1
		(void) Strcpy(link, str2short(tlink));
d897 2
a898 1
	p2 = Strcpy(link, cp);
@


1.7
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.6 2002/02/19 19:39:35 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.6 2002/02/19 19:39:35 millert Exp $";
d132 1
a132 1
    dp = (struct directory *) xcalloc(sizeof(struct directory), 1);
d375 1
a375 1
    dp = (struct directory *) xcalloc(sizeof(struct directory), 1);
@


1.6
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.5 2002/02/16 21:27:06 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.5 2002/02/16 21:27:06 millert Exp $";
d225 1
a225 1
	    (dp->di_name[len] == '\0' || dp->di_name[len] == '/')) 
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.4 1998/05/18 20:37:19 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.4 1998/05/18 20:37:19 deraadt Exp $";
d51 1
a51 5
#ifdef __STDC__
# include <stdarg.h>
#else
# include <varargs.h>
#endif
@


1.4
log
@readlink len-1
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.3 1997/07/25 18:58:00 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.3 1997/07/25 18:58:00 mickey Exp $";
d64 6
a69 6
		*dfind __P((Char *));
static Char	*dfollow __P((Char *));
static void	 printdirs __P((void));
static Char	*dgoto __P((Char *));
static void	 dnewcwd __P((struct directory *));
static void	 dset __P((Char *));
@


1.3
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.2 1996/06/23 14:19:17 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.2 1996/06/23 14:19:17 deraadt Exp $";
d711 1
a711 1
			       sizeof tlink)) >= 0) {
d796 1
a796 1
			       sizeof tlink)) >= 0) {
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.9 1995/03/21 09:02:42 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.9 1995/03/21 09:02:42 cgd Exp $";
d51 1
a51 1
#if __STDC__
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: dir.c,v 1.9 1995/03/21 09:02:42 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
