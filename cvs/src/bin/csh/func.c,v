head	1.33;
access;
symbols
	OPENBSD_6_1:1.33.0.4
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.25.0.22
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.20
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.16
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.14
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.12
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.10
	OPENBSD_5_0:1.25.0.8
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.24
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.20
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.18
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.16
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.14
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.12
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.10
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.8
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.6
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.4
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.9.0.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.8
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2016.08.14.19.46.31;	author guenther;	state Exp;
branches;
next	1.32;
commitid	pewD7rS1euA6iaNY;

1.32
date	2015.12.26.13.48.38;	author mestre;	state Exp;
branches;
next	1.31;
commitid	jZMsEASvreUUSdqp;

1.31
date	2015.10.26.16.27.04;	author naddy;	state Exp;
branches;
next	1.30;
commitid	gkv6HkpvxAbQDUjv;

1.30
date	2015.10.26.15.01.15;	author naddy;	state Exp;
branches;
next	1.29;
commitid	gs7LRmKw8OfepnU6;

1.29
date	2015.09.27.05.25.00;	author guenther;	state Exp;
branches;
next	1.28;
commitid	PQh1CHLROh0mqpnf;

1.28
date	2015.02.08.06.09.50;	author tedu;	state Exp;
branches;
next	1.27;
commitid	i1nyRcSvJDMCYw84;

1.27
date	2015.02.08.05.47.28;	author tedu;	state Exp;
branches;
next	1.26;
commitid	UHj0KNSjy07xS7rI;

1.26
date	2014.10.16.19.43.31;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	jIHreojPTUQy0Zyb;

1.25
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.08.08.12.55.28;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.08.07.16.46.32;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.08.06.19.23.58;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.15.01.49.35;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.25.21.12.39;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.23.16.42.15;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.11.21.09.50;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.23.32.07;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.12.23.26.16;	author jsyn;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.01.19.10.39;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.09.07.02.08;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.25.04.41.25;	author art;	state Exp;
branches;
next	1.9;

1.9
date	98.12.16.17.54.32;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.12.16.17.46.06;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.11.15.21.51.30;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.18.58.07;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.07.23.14.36.50;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.06.18.18.39.38;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.19.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.17.18.22.53;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Don't reinvent rlim_t; when printing it use %llu and cast to
unsigned long long

ok natano@@ tedu@@
@
text
@/*    $OpenBSD: func.c,v 1.32 2015/12/26 13:48:38 mestre Exp $       */
/*    $NetBSD: func.c,v 1.11 1996/02/09 02:28:29 christos Exp $       */

/*-
 * Copyright (c) 1980, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <signal.h>
#include <locale.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdarg.h>

#include "csh.h"
#include "extern.h"
#include "pathnames.h"

extern char **environ;

static int zlast = -1;
static void	islogin(void);
static void	reexecute(struct command *);
static void	preread(void);
static void	doagain(void);
static void	search(int, int, Char *);
static int	getword(Char *);
static int	keyword(Char *);
static void	toend(void);
static void	xecho(int, Char **);
static void	Unsetenv(Char *);

struct biltins *
isbfunc(struct command *t)
{
    Char *cp = t->t_dcom[0];
    struct biltins *bp, *bp1, *bp2;
    static struct biltins label = {"", dozip, 0, 0};
    static struct biltins foregnd = {"%job", dofg1, 0, 0};
    static struct biltins backgnd = {"%job &", dobg1, 0, 0};

    if (lastchr(cp) == ':') {
	label.bname = short2str(cp);
	return (&label);
    }
    if (*cp == '%') {
	if (t->t_dflg & F_AMPERSAND) {
	    t->t_dflg &= ~F_AMPERSAND;
	    backgnd.bname = short2str(cp);
	    return (&backgnd);
	}
	foregnd.bname = short2str(cp);
	return (&foregnd);
    }
    /*
     * Binary search Bp1 is the beginning of the current search range. Bp2 is
     * one past the end.
     */
    for (bp1 = bfunc, bp2 = bfunc + nbfunc; bp1 < bp2;) {
	int i;

	bp = bp1 + ((bp2 - bp1) >> 1);
	if ((i = *cp - *bp->bname) == 0 &&
	    (i = Strcmp(cp, str2short(bp->bname))) == 0)
	    return bp;
	if (i < 0)
	    bp2 = bp;
	else
	    bp1 = bp + 1;
    }
    return (0);
}

void
func(struct command *t, struct biltins *bp)
{
    int     i;

    xechoit(t->t_dcom);
    setname(bp->bname);
    i = blklen(t->t_dcom) - 1;
    if (i < bp->minargs)
	stderror(ERR_NAME | ERR_TOOFEW);
    if (i > bp->maxargs)
	stderror(ERR_NAME | ERR_TOOMANY);
    (*bp->bfunct) (t->t_dcom, t);
}

void
/*ARGSUSED*/
doonintr(Char **v, struct command *t)
{
    Char *cp;
    Char *vv = v[1];
    sigset_t sigset;

    if (parintr == SIG_IGN)
	return;
    if (setintr && intty)
	stderror(ERR_NAME | ERR_TERMINAL);
    cp = gointr;
    gointr = 0;
    free(cp);
    if (vv == 0) {
	if (setintr) {
	    sigemptyset(&sigset);
	    sigaddset(&sigset, SIGINT);
	    sigprocmask(SIG_BLOCK, &sigset, NULL);
	} else
	    (void) signal(SIGINT, SIG_DFL);
	gointr = 0;
    }
    else if (eq((vv = strip(vv)), STRminus)) {
	(void) signal(SIGINT, SIG_IGN);
	gointr = Strsave(STRminus);
    }
    else {
	gointr = Strsave(vv);
	(void) signal(SIGINT, pintr);
    }
}

void
/*ARGSUSED*/
donohup(Char **v, struct command *t)
{
    if (intty)
	stderror(ERR_NAME | ERR_TERMINAL);
    if (setintr == 0) {
	(void) signal(SIGHUP, SIG_IGN);
    }
}

void
/*ARGSUSED*/
dozip(Char **v, struct command *t)
{
    ;
}

void
prvars(void)
{
    plist(&shvhed);
}

void
/*ARGSUSED*/
doalias(Char **v, struct command *t)
{
    struct varent *vp;
    Char *p;

    v++;
    p = *v++;
    if (p == 0)
	plist(&aliases);
    else if (*v == 0) {
	vp = adrof1(strip(p), &aliases);
	if (vp) {
	    blkpr(cshout, vp->vec);
	    fputc('\n', cshout);
	}
    }
    else {
	if (eq(p, STRalias) || eq(p, STRunalias)) {
	    setname(vis_str(p));
	    stderror(ERR_NAME | ERR_DANGER);
	}
	set1(strip(p), saveblk(v), &aliases);
    }
}

void
/*ARGSUSED*/
unalias(Char **v, struct command *t)
{
    unset1(v, &aliases);
}

void
/*ARGSUSED*/
dologout(Char **v, struct command *t)
{
    islogin();
    goodbye();
}

void
/*ARGSUSED*/
dologin(Char **v, struct command *t)
{
    islogin();
    rechist();
    (void) signal(SIGTERM, parterm);
    (void) execl(_PATH_LOGIN, "login", short2str(v[1]), (char *)NULL);
    untty();
    xexit(1);
}

static void
islogin(void)
{
    if (chkstop == 0 && setintr)
	panystop(0);
    if (loginsh)
	return;
    stderror(ERR_NOTLOGIN);
}

void
doif(Char **v, struct command *kp)
{
    int i;
    Char **vv;

    v++;
    i = expr(&v);
    vv = v;
    if (*vv == NULL)
	stderror(ERR_NAME | ERR_EMPTYIF);
    if (eq(*vv, STRthen)) {
	if (*++vv)
	    stderror(ERR_NAME | ERR_IMPRTHEN);
	setname(vis_str(STRthen));
	/*
	 * If expression was zero, then scan to else, otherwise just fall into
	 * following code.
	 */
	if (!i)
	    search(T_IF, 0, NULL);
	return;
    }
    /*
     * Simple command attached to this if. Left shift the node in this tree,
     * munging it so we can reexecute it.
     */
    if (i) {
	lshift(kp->t_dcom, vv - kp->t_dcom);
	reexecute(kp);
	donefds();
    }
}

/*
 * Reexecute a command, being careful not
 * to redo i/o redirection, which is already set up.
 */
static void
reexecute(struct command *kp)
{
    kp->t_dflg &= F_SAVE;
    kp->t_dflg |= F_REPEAT;
    /*
     * If tty is still ours to arbitrate, arbitrate it; otherwise dont even set
     * pgrp's as the jobs would then have no way to get the tty (we can't give
     * it to them, and our parent wouldn't know their pgrp, etc.
     */
    execute(kp, (tpgrp > 0 ? tpgrp : -1), NULL, NULL);
}

void
/*ARGSUSED*/
doelse(Char **v, struct command *t)
{
    search(T_ELSE, 0, NULL);
}

void
/*ARGSUSED*/
dogoto(Char **v, struct command *t)
{
    Char   *lp;

    gotolab(lp = globone(v[1], G_ERROR));
    free(lp);
}

void
gotolab(Char *lab)
{
    struct whyle *wp;
    /*
     * While we still can, locate any unknown ends of existing loops. This
     * obscure code is the WORST result of the fact that we don't really parse.
     */
    zlast = T_GOTO;
    for (wp = whyles; wp; wp = wp->w_next)
	if (wp->w_end.type == F_SEEK && wp->w_end.f_seek == 0) {
	    search(T_BREAK, 0, NULL);
	    btell(&wp->w_end);
	}
	else
	    bseek(&wp->w_end);
    search(T_GOTO, 0, lab);
    /*
     * Eliminate loops which were exited.
     */
    wfree();
}

void
/*ARGSUSED*/
doswitch(Char **v, struct command *t)
{
    Char *cp, *lp;

    v++;
    if (!*v || *(*v++) != '(')
	stderror(ERR_SYNTAX);
    cp = **v == ')' ? STRNULL : *v++;
    if (*(*v++) != ')')
	v--;
    if (*v)
	stderror(ERR_SYNTAX);
    search(T_SWITCH, 0, lp = globone(cp, G_ERROR));
    free(lp);
}

void
/*ARGSUSED*/
dobreak(Char **v, struct command *t)
{
    if (whyles)
	toend();
    else
	stderror(ERR_NAME | ERR_NOTWHILE);
}

void
/*ARGSUSED*/
doexit(Char **v, struct command *t)
{
    if (chkstop == 0 && (intty || intact) && evalvec == 0)
	panystop(0);
    /*
     * Don't DEMAND parentheses here either.
     */
    v++;
    if (*v) {
	set(STRstatus, putn(expr(&v)));
	if (*v)
	    stderror(ERR_NAME | ERR_EXPRESSION);
    }
    btoeof();
    if (intty)
	(void) close(SHIN);
}

void
/*ARGSUSED*/
doforeach(Char **v, struct command *t)
{
    Char *cp, *sp;
    struct whyle *nwp;

    v++;
    sp = cp = strip(*v);
    if (!letter(*sp))
	stderror(ERR_NAME | ERR_VARBEGIN);
    while (*cp && alnum(*cp))
	cp++;
    if (*cp)
	stderror(ERR_NAME | ERR_VARALNUM);
    if ((cp - sp) > MAXVARLEN)
	stderror(ERR_NAME | ERR_VARTOOLONG);
    cp = *v++;
    if (v[0][0] != '(' || v[blklen(v) - 1][0] != ')')
	stderror(ERR_NAME | ERR_NOPAREN);
    v++;
    gflag = 0, tglob(v);
    v = globall(v);
    if (v == 0)
	stderror(ERR_NAME | ERR_NOMATCH);
    nwp = xcalloc(1, sizeof *nwp);
    nwp->w_fe = nwp->w_fe0 = v;
    gargv = 0;
    btell(&nwp->w_start);
    nwp->w_fename = Strsave(cp);
    nwp->w_next = whyles;
    nwp->w_end.type = F_SEEK;
    whyles = nwp;
    /*
     * Pre-read the loop so as to be more comprehensible to a terminal user.
     */
    zlast = T_FOREACH;
    if (intty)
	preread();
    doagain();
}

void
/*ARGSUSED*/
dowhile(Char **v, struct command *t)
{
    int status;
    bool again = whyles != 0 && SEEKEQ(&whyles->w_start, &lineloc) &&
    whyles->w_fename == 0;

    v++;
    /*
     * Implement prereading here also, taking care not to evaluate the
     * expression before the loop has been read up from a terminal.
     */
    if (intty && !again)
	status = !exp0(&v, 1);
    else
	status = !expr(&v);
    if (*v)
	stderror(ERR_NAME | ERR_EXPRESSION);
    if (!again) {
	struct whyle *nwp = xcalloc(1, sizeof(*nwp));

	nwp->w_start = lineloc;
	nwp->w_end.type = F_SEEK;
	nwp->w_end.f_seek = 0;
	nwp->w_next = whyles;
	whyles = nwp;
	zlast = T_WHILE;
	if (intty) {
	    /*
	     * The tty preread
	     */
	    preread();
	    doagain();
	    return;
	}
    }
    if (status)
	/* We ain't gonna loop no more, no more! */
	toend();
}

static void
preread(void)
{
    sigset_t sigset;

    whyles->w_end.type = I_SEEK;
    if (setintr) {
	sigemptyset(&sigset);
	sigaddset(&sigset, SIGINT);
	sigprocmask(SIG_UNBLOCK, &sigset, NULL);
    }

    search(T_BREAK, 0, NULL);		/* read the expression in */
    if (setintr)
	sigprocmask(SIG_BLOCK, &sigset, NULL);
    btell(&whyles->w_end);
}

void
/*ARGSUSED*/
doend(Char **v, struct command *t)
{
    if (!whyles)
	stderror(ERR_NAME | ERR_NOTWHILE);
    btell(&whyles->w_end);
    doagain();
}

void
/*ARGSUSED*/
docontin(Char **v, struct command *t)
{
    if (!whyles)
	stderror(ERR_NAME | ERR_NOTWHILE);
    doagain();
}

static void
doagain(void)
{
    /* Repeating a while is simple */
    if (whyles->w_fename == 0) {
	bseek(&whyles->w_start);
	return;
    }
    /*
     * The foreach variable list actually has a spurious word ")" at the end of
     * the w_fe list.  Thus we are at the of the list if one word beyond this
     * is 0.
     */
    if (!whyles->w_fe[1]) {
	dobreak(NULL, NULL);
	return;
    }
    set(whyles->w_fename, Strsave(*whyles->w_fe++));
    bseek(&whyles->w_start);
}

void
dorepeat(Char **v, struct command *kp)
{
    int i;
    sigset_t sigset;

    i = getn(v[1]);
    if (setintr) {
	sigemptyset(&sigset);
	sigaddset(&sigset, SIGINT);
	sigprocmask(SIG_BLOCK, &sigset, NULL);
    }
    lshift(v, 2);
    while (i > 0) {
	if (setintr)
	    sigprocmask(SIG_UNBLOCK, &sigset, NULL);
	reexecute(kp);
	--i;
    }
    donefds();
    if (setintr)
	sigprocmask(SIG_UNBLOCK, &sigset, NULL);
}

void
/*ARGSUSED*/
doswbrk(Char **v, struct command *t)
{
    search(T_BRKSW, 0, NULL);
}

int
srchx(Char *cp)
{
    struct srch *sp, *sp1, *sp2;
    int i;

    /*
     * Binary search Sp1 is the beginning of the current search range. Sp2 is
     * one past the end.
     */
    for (sp1 = srchn, sp2 = srchn + nsrchn; sp1 < sp2;) {
	sp = sp1 + ((sp2 - sp1) >> 1);
	if ((i = *cp - *sp->s_name) == 0 &&
	    (i = Strcmp(cp, str2short(sp->s_name))) == 0)
	    return sp->s_value;
	if (i < 0)
	    sp2 = sp;
	else
	    sp1 = sp + 1;
    }
    return (-1);
}

static Char Stype;
static Char *Sgoal;

static void
search(int type, int level, Char *goal)
{
    Char    wordbuf[BUFSIZ];
    Char *aword = wordbuf;
    Char *cp;

    Stype = type;
    Sgoal = goal;
    if (type == T_GOTO) {
	struct Ain a;
	a.type = F_SEEK;
	a.f_seek = 0;
	bseek(&a);
    }
    do {
	if (intty && fseekp == feobp && aret == F_SEEK)
	    (void) fprintf(cshout, "? "), (void) fflush(cshout);
	aword[0] = 0;
	(void) getword(aword);
	switch (srchx(aword)) {

	case T_ELSE:
	    if (level == 0 && type == T_IF)
		return;
	    break;

	case T_IF:
	    while (getword(aword))
		continue;
	    if ((type == T_IF || type == T_ELSE) &&
		eq(aword, STRthen))
		level++;
	    break;

	case T_ENDIF:
	    if (type == T_IF || type == T_ELSE)
		level--;
	    break;

	case T_FOREACH:
	case T_WHILE:
	    if (type == T_BREAK)
		level++;
	    break;

	case T_END:
	    if (type == T_BREAK)
		level--;
	    break;

	case T_SWITCH:
	    if (type == T_SWITCH || type == T_BRKSW)
		level++;
	    break;

	case T_ENDSW:
	    if (type == T_SWITCH || type == T_BRKSW)
		level--;
	    break;

	case T_LABEL:
	    if (type == T_GOTO && getword(aword) && eq(aword, goal))
		level = -1;
	    break;

	default:
	    if (type != T_GOTO && (type != T_SWITCH || level != 0))
		break;
	    if (lastchr(aword) != ':')
		break;
	    aword[Strlen(aword) - 1] = 0;
	    if ((type == T_GOTO && eq(aword, goal)) ||
		(type == T_SWITCH && eq(aword, STRdefault)))
		level = -1;
	    break;

	case T_CASE:
	    if (type != T_SWITCH || level != 0)
		break;
	    (void) getword(aword);
	    if (lastchr(aword) == ':')
		aword[Strlen(aword) - 1] = 0;
	    cp = strip(Dfix1(aword));
	    if (Gmatch(goal, cp))
		level = -1;
	    free(cp);
	    break;

	case T_DEFAULT:
	    if (type == T_SWITCH && level == 0)
		level = -1;
	    break;
	}
	(void) getword(NULL);
    } while (level >= 0);
}

static int
getword(Char *wp)
{
    int found = 0;
    int c, d;
    int     kwd = 0;
    Char   *owp = wp;

    c = readc(1);
    d = 0;
    do {
	while (c == ' ' || c == '\t')
	    c = readc(1);
	if (c == '#')
	    do
		c = readc(1);
	    while (c >= 0 && c != '\n');
	if (c < 0)
	    goto past;
	if (c == '\n') {
	    if (wp)
		break;
	    return (0);
	}
	unreadc(c);
	found = 1;
	do {
	    c = readc(1);
	    if (c == '\\' && (c = readc(1)) == '\n')
		c = ' ';
	    if (c == '\'' || c == '"') {
		if (d == 0)
		    d = c;
		else if (d == c)
		    d = 0;
	    }
	    if (c < 0)
		goto past;
	    if (wp) {
		*wp++ = c;
		*wp = 0;	/* end the string b4 test */
	    }
	} while ((d || (!(kwd = keyword(owp)) && c != ' '
		  && c != '\t')) && c != '\n');
    } while (wp == 0);

    /*
     * if we have read a keyword ( "if", "switch" or "while" ) then we do not
     * need to unreadc the look-ahead char
     */
    if (!kwd) {
	unreadc(c);
	if (found)
	    *--wp = 0;
    }

    return (found);

past:
    switch (Stype) {

    case T_IF:
	stderror(ERR_NAME | ERR_NOTFOUND, "then/endif");

    case T_ELSE:
	stderror(ERR_NAME | ERR_NOTFOUND, "endif");

    case T_BRKSW:
    case T_SWITCH:
	stderror(ERR_NAME | ERR_NOTFOUND, "endsw");

    case T_BREAK:
	stderror(ERR_NAME | ERR_NOTFOUND, "end");

    case T_GOTO:
	setname(vis_str(Sgoal));
	stderror(ERR_NAME | ERR_NOTFOUND, "label");
    }
    /* NOTREACHED */
    return (0);
}

/*
 * keyword(wp) determines if wp is one of the built-n functions if,
 * switch or while. It seems that when an if statement looks like
 * "if(" then getword above sucks in the '(' and so the search routine
 * never finds what it is scanning for. Rather than rewrite doword, I hack
 * in a test to see if the string forms a keyword. Then doword stops
 * and returns the word "if" -strike
 */

static int
keyword(Char *wp)
{
    static Char STRif[] = {'i', 'f', '\0'};
    static Char STRwhile[] = {'w', 'h', 'i', 'l', 'e', '\0'};
    static Char STRswitch[] = {'s', 'w', 'i', 't', 'c', 'h', '\0'};

    if (!wp)
	return (0);

    if ((Strcmp(wp, STRif) == 0) || (Strcmp(wp, STRwhile) == 0)
	|| (Strcmp(wp, STRswitch) == 0))
	return (1);

    return (0);
}

static void
toend(void)
{
    if (whyles->w_end.type == F_SEEK && whyles->w_end.f_seek == 0) {
	search(T_BREAK, 0, NULL);
	btell(&whyles->w_end);
	whyles->w_end.f_seek--;
    }
    else
	bseek(&whyles->w_end);
    wfree();
}

void
wfree(void)
{
    struct Ain    o;
    struct whyle *nwp;

    btell(&o);

    for (; whyles; whyles = nwp) {
	struct whyle *wp = whyles;
	nwp = wp->w_next;

	/*
	 * We free loops that have different seek types.
	 */
	if (wp->w_end.type != I_SEEK && wp->w_start.type == wp->w_end.type &&
	    wp->w_start.type == o.type) {
	    if (wp->w_end.type == F_SEEK) {
		if (o.f_seek >= wp->w_start.f_seek &&
		    (wp->w_end.f_seek == 0 || o.f_seek < wp->w_end.f_seek))
		    break;
	    }
	    else {
		if (o.a_seek >= wp->w_start.a_seek &&
		    (wp->w_end.a_seek == 0 || o.a_seek < wp->w_end.a_seek))
		    break;
	    }
	}

	if (wp->w_fe0)
	    blkfree(wp->w_fe0);
	if (wp->w_fename)
	    free(wp->w_fename);
	free(wp);
    }
}

void
/*ARGSUSED*/
doecho(Char **v, struct command *t)
{
    xecho(' ', v);
}

void
/*ARGSUSED*/
doglob(Char **v, struct command *t)
{
    xecho(0, v);
    (void) fflush(cshout);
}

static void
xecho(int sep, Char **v)
{
    Char *cp;
    int     nonl = 0;
    sigset_t sigset;

    if (setintr) {
	sigemptyset(&sigset);
	sigaddset(&sigset, SIGINT);
	sigprocmask(SIG_UNBLOCK, &sigset, NULL);
    }
    v++;
    if (*v == 0)
	return;
    gflag = 0, tglob(v);
    if (gflag) {
	v = globall(v);
	if (v == 0)
	    stderror(ERR_NAME | ERR_NOMATCH);
    }
    else {
	v = gargv = saveblk(v);
	trim(v);
    }
    if (sep == ' ' && *v && eq(*v, STRmn))
	nonl++, v++;
    while ((cp = *v++) != NULL) {
	int c;

	while ((c = *cp++) != '\0')
	    (void) vis_fputc(c | QUOTE, cshout);

	if (*v)
	    (void) vis_fputc(sep | QUOTE, cshout);
    }
    if (sep && nonl == 0)
	(void) fputc('\n', cshout);
    else
	(void) fflush(cshout);
    if (setintr)
	sigprocmask(SIG_BLOCK, &sigset, NULL);
    if (gargv)
	blkfree(gargv), gargv = 0;
}

void
/*ARGSUSED*/
dosetenv(Char **v, struct command *t)
{
    Char   *vp, *lp;
    sigset_t sigset;

    v++;
    if ((vp = *v++) == 0) {
	Char **ep;

	if (setintr) {
	    sigemptyset(&sigset);
	    sigaddset(&sigset, SIGINT);
	    sigprocmask(SIG_UNBLOCK, &sigset, NULL);
	}
	for (ep = STR_environ; *ep; ep++)
	    (void) fprintf(cshout, "%s\n", vis_str(*ep));
	return;
    }
    if ((lp = *v++) == 0)
	lp = STRNULL;
    Setenv(vp, lp = globone(lp, G_APPEND));
    if (eq(vp, STRPATH)) {
	importpath(lp);
	dohash(NULL, NULL);
    }
    free(lp);
}

void
/*ARGSUSED*/
dounsetenv(Char **v, struct command *t)
{
    Char  **ep, *p, *n;
    int     i, maxi;
    static Char *name = NULL;

    if (name)
	free(name);
    /*
     * Find the longest environment variable
     */
    for (maxi = 0, ep = STR_environ; *ep; ep++) {
	for (i = 0, p = *ep; *p && *p != '='; p++, i++)
	    continue;
	if (i > maxi)
	    maxi = i;
    }

    name = xreallocarray(NULL, maxi + 1, sizeof(Char));

    while (++v && *v)
	for (maxi = 1; maxi;)
	    for (maxi = 0, ep = STR_environ; *ep; ep++) {
		for (n = name, p = *ep; *p && *p != '='; *n++ = *p++)
		    continue;
		*n = '\0';
		if (!Gmatch(name, *v))
		    continue;
		maxi = 1;
		/*
		 * Delete name, and start again cause the environment changes
		 */
		Unsetenv(name);
		break;
	    }
    free(name);
    name = NULL;
}

void
Setenv(Char *name, Char *val)
{
    Char **ep = STR_environ;
    Char *cp, *dp;
    Char   *blk[2];
    Char  **oep = ep;

    for (; *ep; ep++) {
	for (cp = name, dp = *ep; *cp && *cp == *dp; cp++, dp++)
	    continue;
	if (*cp != 0 || *dp != '=')
	    continue;
	cp = Strspl(STRequal, val);
	free(* ep);
	*ep = strip(Strspl(name, cp));
	free(cp);
	blkfree((Char **) environ);
	environ = short2blk(STR_environ);
	return;
    }
    cp = Strspl(name, STRequal);
    blk[0] = strip(Strspl(cp, val));
    free(cp);
    blk[1] = 0;
    STR_environ = blkspl(STR_environ, blk);
    blkfree((Char **) environ);
    environ = short2blk(STR_environ);
    free(oep);
}

static void
Unsetenv(Char *name)
{
    Char **ep = STR_environ;
    Char *cp, *dp;
    Char  **oep = ep;

    for (; *ep; ep++) {
	for (cp = name, dp = *ep; *cp && *cp == *dp; cp++, dp++)
	    continue;
	if (*cp != 0 || *dp != '=')
	    continue;
	cp = *ep;
	*ep = 0;
	STR_environ = blkspl(STR_environ, ep + 1);
	environ = short2blk(STR_environ);
	*ep = cp;
	free(cp);
	free(oep);
	return;
    }
}

void
/*ARGSUSED*/
doumask(Char **v, struct command *t)
{
    Char *cp = v[1];
    int i;

    if (cp == 0) {
	i = umask(0);
	(void) umask(i);
	(void) fprintf(cshout, "%o\n", i);
	return;
    }
    i = 0;
    while (Isdigit(*cp) && *cp != '8' && *cp != '9')
	i = i * 8 + *cp++ - '0';
    if (*cp || i < 0 || i > 0777)
	stderror(ERR_NAME | ERR_MASK);
    (void) umask(i);
}

static struct limits {
    int     limconst;
    char   *limname;
    int     limdiv;
    char   *limscale;
}       limits[] = {
    { RLIMIT_CPU,	"cputime",	1,	"seconds" },
    { RLIMIT_FSIZE,	"filesize",	1024,	"kbytes" },
    { RLIMIT_DATA,	"datasize",	1024,	"kbytes" },
    { RLIMIT_STACK,	"stacksize",	1024,	"kbytes" },
    { RLIMIT_CORE,	"coredumpsize", 1024,	"kbytes" },
    { RLIMIT_RSS,	"memoryuse",	1024,	"kbytes" },
#ifdef RLIMIT_VMEM
    { RLIMIT_VMEM,	"vmemoryuse",	1024,	"kbytes" },
#endif
    { RLIMIT_MEMLOCK,	"memorylocked",	1024,	"kbytes" },
    { RLIMIT_NPROC,	"maxproc",	1,	"" },
    { RLIMIT_NOFILE,	"openfiles",	1,	"" },
    { -1,		NULL,		0,	NULL }
};

static struct limits *findlim(Char *);
static rlim_t getval(struct limits *, Char **);
static void limtail(Char *, char *);
static void plim(struct limits *, Char);
static int setlim(struct limits *, Char, rlim_t);

static struct limits *
findlim(Char *cp)
{
    struct limits *lp, *res;

    res = NULL;
    for (lp = limits; lp->limconst >= 0; lp++)
	if (prefix(cp, str2short(lp->limname))) {
	    if (res)
		stderror(ERR_NAME | ERR_AMBIG);
	    res = lp;
	}
    if (res)
	return (res);
    stderror(ERR_NAME | ERR_LIMIT);
    /* NOTREACHED */
    return (0);
}

void
/*ARGSUSED*/
dolimit(Char **v, struct command *t)
{
    struct limits *lp;
    rlim_t limit;
    char    hard = 0;

    v++;
    if (*v && eq(*v, STRmh)) {
	hard = 1;
	v++;
    }
    if (*v == 0) {
	for (lp = limits; lp->limconst >= 0; lp++)
	    plim(lp, hard);
	return;
    }
    lp = findlim(v[0]);
    if (v[1] == 0) {
	plim(lp, hard);
	return;
    }
    limit = getval(lp, v + 1);
    if (setlim(lp, hard, limit) < 0)
	stderror(ERR_SILENT);
}

static  rlim_t
getval(struct limits *lp, Char **v)
{
    float f;
    Char   *cp = *v++;

    f = atof(short2str(cp));

    while (Isdigit(*cp) || *cp == '.' || *cp == 'e' || *cp == 'E')
	cp++;
    if (*cp == 0) {
	if (*v == 0)
	    return ((rlim_t) ((f + 0.5) * lp->limdiv));
	cp = *v;
    }
    switch (*cp) {
    case ':':
	if (lp->limconst != RLIMIT_CPU)
	    goto badscal;
	return ((rlim_t) (f * 60.0 + atof(short2str(cp + 1))));
    case 'h':
	if (lp->limconst != RLIMIT_CPU)
	    goto badscal;
	limtail(cp, "hours");
	f *= 3600.0;
	break;
    case 'm':
	if (lp->limconst == RLIMIT_CPU) {
	    limtail(cp, "minutes");
	    f *= 60.0;
	    break;
	}
	*cp = 'm';
	limtail(cp, "megabytes");
	f *= 1024.0 * 1024.0;
	break;
    case 's':
	if (lp->limconst != RLIMIT_CPU)
	    goto badscal;
	limtail(cp, "seconds");
	break;
    case 'M':
	if (lp->limconst == RLIMIT_CPU)
	    goto badscal;
	*cp = 'm';
	limtail(cp, "megabytes");
	f *= 1024.0 * 1024.0;
	break;
    case 'k':
	if (lp->limconst == RLIMIT_CPU)
	    goto badscal;
	limtail(cp, "kbytes");
	f *= 1024.0;
	break;
    case 'u':
	limtail(cp, "unlimited");
	return (RLIM_INFINITY);
    default:
badscal:
	stderror(ERR_NAME | ERR_SCALEF);
    }
    f += 0.5;
    if (f > (float) RLIM_INFINITY)
	return RLIM_INFINITY;
    else
	return ((rlim_t) f);
}

static void
limtail(Char *cp, char *str)
{
    char *origstr = str;

    while (*cp && *cp == *str)
	cp++, str++;
    if (*cp)
	stderror(ERR_BADSCALE, origstr);
}

/*ARGSUSED*/
static void
plim(struct limits *lp, Char hard)
{
    struct rlimit rlim;
    rlim_t limit;

    (void) fprintf(cshout, "%s \t", lp->limname);

    (void) getrlimit(lp->limconst, &rlim);
    limit = hard ? rlim.rlim_max : rlim.rlim_cur;

    if (limit == RLIM_INFINITY)
	(void) fprintf(cshout, "unlimited");
    else if (lp->limconst == RLIMIT_CPU)
	psecs((long) limit);
    else
	(void) fprintf(cshout, "%llu %s",
	    (unsigned long long) (limit / lp->limdiv), lp->limscale);
    (void) fputc('\n', cshout);
}

void
/*ARGSUSED*/
dounlimit(Char **v, struct command *t)
{
    struct limits *lp;
    int     lerr = 0;
    Char    hard = 0;

    v++;
    if (*v && eq(*v, STRmh)) {
	hard = 1;
	v++;
    }
    if (*v == 0) {
	for (lp = limits; lp->limconst >= 0; lp++)
	    if (setlim(lp, hard, RLIM_INFINITY) < 0)
		lerr++;
	if (lerr)
	    stderror(ERR_SILENT);
	return;
    }
    while (*v) {
	lp = findlim(*v++);
	if (setlim(lp, hard, RLIM_INFINITY) < 0)
	    stderror(ERR_SILENT);
    }
}

static int
setlim(struct limits *lp, Char hard, rlim_t limit)
{
    struct rlimit rlim;

    (void) getrlimit(lp->limconst, &rlim);

    if (hard)
	rlim.rlim_max = limit;
    else if (limit == RLIM_INFINITY && geteuid() != 0)
	rlim.rlim_cur = rlim.rlim_max;
    else
	rlim.rlim_cur = limit;

    if (setrlimit(lp->limconst, &rlim) < 0) {
	(void) fprintf(csherr, "%s: %s: Can't %s%s limit\n", bname, lp->limname,
		       limit == RLIM_INFINITY ? "remove" : "set",
		       hard ? " hard" : "");
	return (-1);
    }
    return (0);
}

void
/*ARGSUSED*/
dosuspend(Char **v, struct command *t)
{
    int     ctpgrp;

    void    (*old) (int);

    if (loginsh)
	stderror(ERR_SUSPLOG);
    untty();

    old = signal(SIGTSTP, SIG_DFL);
    (void) kill(0, SIGTSTP);
    /* the shell stops here */
    (void) signal(SIGTSTP, old);

    if (tpgrp != -1) {
retry:
	ctpgrp = tcgetpgrp(FSHTTY);
      if  (ctpgrp != opgrp) {
	    old = signal(SIGTTIN, SIG_DFL);
	    (void) kill(0, SIGTTIN);
	    (void) signal(SIGTTIN, old);
	  goto retry;
	}
	(void) setpgid(0, shpgrp);
	(void) tcsetpgrp(FSHTTY, shpgrp);
    }
}

/* This is the dreaded EVAL built-in.
 *   If you don't fiddle with file descriptors, and reset didfds,
 *   this command will either ignore redirection inside or outside
 *   its arguments, e.g. eval "date >x"  vs.  eval "date" >x
 *   The stuff here seems to work, but I did it by trial and error rather
 *   than really knowing what was going on.  If tpgrp is zero, we are
 *   probably a background eval, e.g. "eval date &", and we want to
 *   make sure that any processes we start stay in our pgrp.
 *   This is also the case for "time eval date" -- stay in same pgrp.
 *   Otherwise, under stty tostop, processes will stop in the wrong
 *   pgrp, with no way for the shell to get them going again.  -IAN!
 */

static Char **gv = NULL;

void
/*ARGSUSED*/
doeval(Char **v, struct command *t)
{
    Char  **oevalvec;
    Char   *oevalp;
    int     odidfds;
    jmp_buf osetexit;
    int     my_reenter;
    Char  **savegv = gv;
    int     saveIN;
    int     saveOUT;
    int     saveERR;
    int     oSHIN;
    int     oSHOUT;
    int     oSHERR;

    UNREGISTER(v);

    oevalvec = evalvec;
    oevalp = evalp;
    odidfds = didfds;
    oSHIN = SHIN;
    oSHOUT = SHOUT;
    oSHERR = SHERR;

    v++;
    if (*v == 0)
	return;
    gflag = 0, tglob(v);
    if (gflag) {
	gv = v = globall(v);
	gargv = 0;
	if (v == 0)
	    stderror(ERR_NOMATCH);
	v = copyblk(v);
    }
    else {
	gv = NULL;
	v = copyblk(v);
	trim(v);
    }

    saveIN = dcopy(SHIN, -1);
    saveOUT = dcopy(SHOUT, -1);
    saveERR = dcopy(SHERR, -1);

    getexit(osetexit);

    if ((my_reenter = setexit()) == 0) {
	evalvec = v;
	evalp = 0;
	SHIN = dcopy(0, -1);
	SHOUT = dcopy(1, -1);
	SHERR = dcopy(2, -1);
	didfds = 0;
	process(0);
    }

    evalvec = oevalvec;
    evalp = oevalp;
    doneinp = 0;
    didfds = odidfds;
    (void) close(SHIN);
    (void) close(SHOUT);
    (void) close(SHERR);
    SHIN = dmove(saveIN, oSHIN);
    SHOUT = dmove(saveOUT, oSHOUT);
    SHERR = dmove(saveERR, oSHERR);
    if (gv)
	blkfree(gv), gv = NULL;
    resexit(osetexit);
    gv = savegv;
    if (my_reenter)
	stderror(ERR_SILENT);
}
@


1.32
log
@Replace handrolled xfree() function by directly using free(3)

OK mmcc@@
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.31 2015/10/26 16:27:04 naddy Exp $       */
a1038 2
typedef quad_t RLIM_TYPE;

d1061 1
a1061 1
static RLIM_TYPE getval(struct limits *, Char **);
d1064 1
a1064 1
static int setlim(struct limits *, Char, RLIM_TYPE);
d1090 1
a1090 1
    RLIM_TYPE limit;
d1113 1
a1113 1
static  RLIM_TYPE
d1125 1
a1125 1
	    return ((RLIM_TYPE) ((f + 0.5) * lp->limdiv));
d1132 1
a1132 1
	return ((RLIM_TYPE) (f * 60.0 + atof(short2str(cp + 1))));
d1178 1
a1178 1
	return ((RLIM_TYPE) f);
d1197 1
a1197 1
    RLIM_TYPE limit;
d1209 2
a1210 2
	(void) fprintf(cshout, "%ld %s", (long) (limit / lp->limdiv),
		       lp->limscale);
d1229 1
a1229 1
	    if (setlim(lp, hard, (RLIM_TYPE) RLIM_INFINITY) < 0)
d1237 1
a1237 1
	if (setlim(lp, hard, (RLIM_TYPE) RLIM_INFINITY) < 0)
d1243 1
a1243 1
setlim(struct limits *lp, Char hard, RLIM_TYPE limit)
@


1.31
log
@Clean up cruft made visible by the NLS unifdefing:
* remove setlocale() calls
* remove write-only variable AsciiOnly
* remove now unused string constants STRLANG, STRLC_CTYPE
* remove hardcoded support for ISO8859-1

ok millert@@
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.30 2015/10/26 15:01:15 naddy Exp $       */
d130 1
a130 1
    xfree(cp);
d303 1
a303 1
    xfree(lp);
d344 1
a344 1
    xfree(lp);
d662 1
a662 1
	    xfree(cp);
d827 2
a828 2
	    xfree(wp->w_fename);
	xfree(wp);
d920 1
a920 1
    xfree(lp);
d932 1
a932 1
	xfree(name);
d960 1
a960 1
    xfree(name);
d978 1
a978 1
	xfree(* ep);
d980 1
a980 1
	xfree(cp);
d987 1
a987 1
    xfree(cp);
d992 1
a992 1
    xfree(oep);
d1012 2
a1013 2
	xfree(cp);
	xfree(oep);
@


1.30
log
@unifdef BUILTIN (unused), NLS (always set), SHORT_STRINGS (always set)
and remove a few unused defines; no binary changes; ok tedu@@ zhuk@@
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.29 2015/09/27 05:25:00 guenther Exp $       */
a919 8
    else if (eq(vp, STRLANG) || eq(vp, STRLC_CTYPE)) {
	int     k;

	(void) setlocale(LC_ALL, "");
	for (k = 0200; k <= 0377 && !Isprint(k); k++)
		continue;
	AsciiOnly = k > 0377;
    }
a953 8
		if (eq(name, STRLANG) || eq(name, STRLC_CTYPE)) {
		    int     k;

		    (void) setlocale(LC_ALL, "");
		    for (k = 0200; k <= 0377 && !Isprint(k); k++)
			continue;
		    AsciiOnly = k > 0377;
		}
@


1.29
log
@lint is dead: delete the trivial uses of /* VARARGS[0-9]+ */
(others require more care)
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.28 2015/02/08 06:09:50 tedu Exp $       */
a920 1
#ifdef NLS
a926 3
#else
	AsciiOnly = 0;
#endif				/* NLS */
a962 1
#ifdef NLS
a968 4
#else
		    AsciiOnly = getenv("LANG") == NULL &&
			getenv("LC_CTYPE") == NULL;
#endif				/* NLS */
@


1.28
log
@delete tons more casts
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.27 2015/02/08 05:47:28 tedu Exp $       */
a575 1
/*VARARGS2*/
@


1.27
log
@delete lots of unnecessary ptr_t casts, and drop a little NULL in as well
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.26 2014/10/16 19:43:31 deraadt Exp $       */
d402 1
a402 1
    nwp = (struct whyle *) xcalloc(1, sizeof *nwp);
d439 1
a439 2
	struct whyle *nwp =
	(struct whyle *) xcalloc(1, sizeof(*nwp));
@


1.26
log
@Use reallocarray() and remove a few archaic memory allocation practices.
ok deraadt
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.25 2009/10/27 23:59:21 deraadt Exp $       */
d130 1
a130 1
    xfree((ptr_t) cp);
d303 1
a303 1
    xfree((ptr_t) lp);
d344 1
a344 1
    xfree((ptr_t) lp);
d664 1
a664 1
	    xfree((ptr_t) cp);
d829 2
a830 2
	    xfree((ptr_t) wp->w_fename);
	xfree((ptr_t) wp);
d934 1
a934 1
    xfree((ptr_t) lp);
d946 1
a946 1
	xfree((ptr_t) name);
d987 1
a987 1
    xfree((ptr_t) name);
d1005 1
a1005 1
	xfree((ptr_t) * ep);
d1007 1
a1007 1
	xfree((ptr_t) cp);
d1014 1
a1014 1
    xfree((ptr_t) cp);
d1019 1
a1019 1
    xfree((ptr_t) oep);
d1039 2
a1040 2
	xfree((ptr_t) cp);
	xfree((ptr_t) oep);
@


1.25
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.24 2004/08/08 12:55:28 millert Exp $       */
d957 1
a957 1
    name = (Char *) xmalloc((size_t) (maxi + 1) * sizeof(Char));
@


1.24
log
@print vmemoryuse immediately after vmemoryuse in limit output
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.23 2004/08/07 16:46:32 millert Exp $       */
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)func.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: func.c,v 1.23 2004/08/07 16:46:32 millert Exp $";
#endif
#endif /* not lint */
@


1.23
log
@vmemsize -> vmemoryuse for consistency with tcsh and document. mickey@@ OK
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.22 2004/08/06 19:23:58 mickey Exp $       */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: func.c,v 1.22 2004/08/06 19:23:58 mickey Exp $";
d1088 3
a1093 3
#ifdef RLIMIT_VMEM
    { RLIMIT_VMEM,	"vmemoryuse",	1024,	"kbytes" },
#endif
@


1.22
log
@conditional use of RLIMIT_VMEM (like ksh)
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.21 2004/05/15 01:49:35 tedu Exp $       */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: func.c,v 1.21 2004/05/15 01:49:35 tedu Exp $";
d1092 1
a1092 1
    { RLIMIT_VMEM,	"vmemsize",	1024,	"kbytes" },
@


1.21
log
@print the whole hint for bad limit modifiers. ok otto pedro
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.20 2003/06/25 21:12:39 deraadt Exp $       */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: func.c,v 1.20 2003/06/25 21:12:39 deraadt Exp $";
d1091 3
@


1.20
log
@protos
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.19 2003/06/23 16:42:15 deraadt Exp $       */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: func.c,v 1.19 2003/06/23 16:42:15 deraadt Exp $";
d1218 2
d1223 1
a1223 1
	stderror(ERR_BADSCALE, str);
@


1.19
log
@kill printf builtin.  no reason to be a builtin, but furthermore, the
handling of format strings is quite non-compliant.
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.18 2003/06/11 21:09:50 deraadt Exp $       */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: func.c,v 1.18 2003/06/11 21:09:50 deraadt Exp $";
a1150 1
    double  atof();
d1303 1
a1303 1
    void    (*old) ();
@


1.18
log
@de-register and ansify functions
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.17 2003/06/02 23:32:07 millert Exp $       */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: func.c,v 1.17 2003/06/02 23:32:07 millert Exp $";
a1417 30
	stderror(ERR_SILENT);
}

void
/*ARGSUSED*/
doprintf(Char **v, struct command *t)
{
    Char **newv;
    char **c;
    extern int progprintf(int, char **);
    int ret;

    gflag = 0;
    tglob(v);
    if (gflag) {
	newv = globall(v);
	if (newv == 0) {
	    stderror(ERR_NAME | ERR_NOMATCH);
	    return;
	}
	v = newv;
	gargv = 0;
    }

    ret = progprintf(blklen(v), c = short2blk(v));
    (void) fflush(cshout);
    (void) fflush(csherr);

    blkfree((Char **) c);
    if (ret)
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.16 2003/05/12 23:26:16 jsyn Exp $       */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: func.c,v 1.16 2003/05/12 23:26:16 jsyn Exp $";
d71 2
a72 2
    register Char *cp = t->t_dcom[0];
    register struct biltins *bp, *bp1, *bp2;
d95 1
a95 1
	register int i;
d110 1
a110 1
func(register struct command *t, register struct biltins *bp)
d128 2
a129 2
    register Char *cp;
    register Char *vv = v[1];
d177 1
a177 1
prvars()
d186 2
a187 2
    register struct varent *vp;
    register Char *p;
d237 1
a237 1
islogin()
d249 2
a250 2
    register int i;
    register Char **vv;
d285 1
a285 1
reexecute(register struct command *kp)
d317 1
a317 1
    register struct whyle *wp;
d341 1
a341 1
    register Char *cp, *lp;
d389 2
a390 2
    register Char *cp, *sp;
    register struct whyle *nwp;
d431 2
a432 2
    register int status;
    register bool again = whyles != 0 && SEEKEQ(&whyles->w_start, &lineloc) &&
d447 1
a447 1
	register struct whyle *nwp =
d471 1
a471 1
preread()
d508 1
a508 1
doagain()
d531 1
a531 1
    register int i;
d560 1
a560 1
srchx(register Char *cp)
d562 2
a563 2
    register struct srch *sp, *sp1, *sp2;
    register int i;
d587 1
a587 1
search(int type, register int level, Char *goal)
d590 2
a591 2
    register Char *aword = wordbuf;
    register Char *cp;
d685 1
a685 1
getword(register Char *wp)
d687 2
a688 2
    register int found = 0;
    register int c, d;
d793 1
a793 1
toend()
d806 1
a806 1
wfree()
d814 1
a814 1
	register struct whyle *wp = whyles;
d858 1
a858 1
xecho(int sep, register Char **v)
d860 1
a860 1
    register Char *cp;
d885 1
a885 1
	register int c;
d912 1
a912 1
	register Char **ep;
d1002 2
a1003 2
    register Char **ep = STR_environ;
    register Char *cp, *dp;
d1033 2
a1034 2
    register Char **ep = STR_environ;
    register Char *cp, *dp;
d1057 2
a1058 2
    register Char *cp = v[1];
    register int i;
d1103 1
a1103 1
    register struct limits *lp, *res;
d1123 2
a1124 2
    register struct limits *lp;
    register RLIM_TYPE limit;
d1148 1
a1148 1
getval(register struct limits *lp, Char **v)
d1150 1
a1150 1
    register float f;
d1227 1
a1227 1
plim(register struct limits *lp, Char hard)
d1251 1
a1251 1
    register struct limits *lp;
d1276 1
a1276 1
setlim(register struct limits *lp, Char hard, RLIM_TYPE limit)
@


1.16
log
@ansify functions, eliminating prototype declaration warnings; ok deraadt@@
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.15 2002/06/09 05:47:27 todd Exp $       */
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: func.c,v 1.15 2002/06/09 05:47:27 todd Exp $";
@


1.15
log
@knf
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.14 2002/02/19 19:39:35 millert Exp $       */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: func.c,v 1.14 2002/02/19 19:39:35 millert Exp $";
d73 1
a73 2
isbfunc(t)
    struct command *t;
d114 1
a114 3
func(t, bp)
    register struct command *t;
    register struct biltins *bp;
d130 1
a130 3
doonintr(v, t)
    Char **v;
    struct command *t;
d164 1
a164 3
donohup(v, t)
    Char **v;
    struct command *t;
d175 1
a175 3
dozip(v, t)
    Char **v;
    struct command *t;
d188 1
a188 3
doalias(v, t)
    Char **v;
    struct command *t;
d215 1
a215 3
unalias(v, t)
    Char **v;
    struct command *t;
d222 1
a222 3
dologout(v, t)
    Char **v;
    struct command *t;
d230 1
a230 3
dologin(v, t)
    Char **v;
    struct command *t;
d251 1
a251 3
doif(v, kp)
    Char  **v;
    struct command *kp;
d289 1
a289 2
reexecute(kp)
    register struct command *kp;
d303 1
a303 3
doelse(v, t)
    Char **v;
    struct command *t;
d310 1
a310 3
dogoto(v, t)
    Char **v;
    struct command *t;
d319 1
a319 2
gotolab(lab)
    Char *lab;
d343 1
a343 3
doswitch(v, t)
    Char **v;
    struct command *t;
d361 1
a361 3
dobreak(v, t)
    Char **v;
    struct command *t;
d371 1
a371 3
doexit(v, t)
    Char **v;
    struct command *t;
d391 1
a391 3
doforeach(v, t)
    Char **v;
    struct command *t;
d433 1
a433 3
dowhile(v, t)
    Char **v;
    struct command *t;
d494 1
a494 3
doend(v, t)
    Char **v;
    struct command *t;
d504 1
a504 3
docontin(v, t)
    Char **v;
    struct command *t;
d533 1
a533 3
dorepeat(v, kp)
    Char  **v;
    struct command *kp;
d558 1
a558 3
doswbrk(v, t)
    Char **v;
    struct command *t;
d564 1
a564 2
srchx(cp)
    register Char *cp;
d591 1
a591 4
search(type, level, goal)
    int     type;
    register int level;
    Char   *goal;
d689 1
a689 2
getword(wp)
    register Char *wp;
d780 1
a780 2
keyword(wp)
    Char   *wp;
d848 1
a848 3
doecho(v, t)
    Char **v;
    struct command *t;
d855 1
a855 3
doglob(v, t)
    Char **v;
    struct command *t;
d862 1
a862 3
xecho(sep, v)
    int    sep;
    register Char **v;
d909 1
a909 3
dosetenv(v, t)
    Char **v;
    struct command *t;
d951 1
a951 3
dounsetenv(v, t)
    Char **v;
    struct command *t;
d1004 1
a1004 2
Setenv(name, val)
    Char   *name, *val;
a1010 1

d1035 1
a1035 2
Unsetenv(name)
    Char   *name;
d1059 1
a1059 3
doumask(v, t)
    Char **v;
    struct command *t;
d1105 1
a1105 2
findlim(cp)
    Char   *cp;
d1125 1
a1125 3
dolimit(v, t)
    Char **v;
    struct command *t;
d1152 1
a1152 3
getval(lp, v)
    register struct limits *lp;
    Char  **v;
d1221 1
a1221 3
limtail(cp, str)
    Char   *cp;
    char   *str;
a1228 1

d1231 1
a1231 3
plim(lp, hard)
    register struct limits *lp;
    Char    hard;
d1253 1
a1253 3
dounlimit(v, t)
    Char **v;
    struct command *t;
d1280 1
a1280 4
setlim(lp, hard, limit)
    register struct limits *lp;
    Char    hard;
    RLIM_TYPE limit;
d1304 1
a1304 3
dosuspend(v, t)
    Char **v;
    struct command *t;
d1345 1
d1347 1
d1350 1
a1350 3
doeval(v, t)
    Char **v;
    struct command *t;
d1427 1
a1427 3
doprintf(v, t)
    Char **v;
    struct command *t;
@


1.14
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.13 2002/02/16 21:27:06 millert Exp $       */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: func.c,v 1.13 2002/02/16 21:27:06 millert Exp $";
d876 1
a876 1
		if (o.f_seek >= wp->w_start.f_seek && 
d881 1
a881 1
		if (o.a_seek >= wp->w_start.a_seek && 
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.12 2001/12/01 19:10:39 deraadt Exp $       */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: func.c,v 1.12 2001/12/01 19:10:39 deraadt Exp $";
d52 1
a52 5
#ifdef __STDC__
# include <stdarg.h>
#else
# include <varargs.h>
#endif
@


1.12
log
@KNF
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.11 2001/07/09 07:02:08 deraadt Exp $       */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: func.c,v 1.11 2001/07/09 07:02:08 deraadt Exp $";
d65 10
a74 10
static void	islogin __P((void));
static void	reexecute __P((struct command *));
static void	preread __P((void));
static void	doagain __P((void));
static void	search __P((int, int, Char *));
static int	getword __P((Char *));
static int	keyword __P((Char *));
static void	toend __P((void));
static void	xecho __P((int, Char **));
static void	Unsetenv __P((Char *));
d1166 5
a1170 5
static struct limits *findlim __P((Char *));
static RLIM_TYPE getval __P((struct limits *, Char **));
static void limtail __P((Char *, char *));
static void plim __P((struct limits *, Char));
static int setlim __P((struct limits *, Char, RLIM_TYPE));
d1518 1
a1518 1
    extern int progprintf __P((int, char **));
@


1.11
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.10 2001/06/25 04:41:25 art Exp $       */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: func.c,v 1.10 2001/06/25 04:41:25 art Exp $";
d104 1
a104 1
	register i;
d615 1
a615 1
    register i;
@


1.10
log
@fix obvious warnings.
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.9 1998/12/16 17:54:32 deraadt Exp $       */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: func.c,v 1.9 1998/12/16 17:54:32 deraadt Exp $";
d256 1
a256 1
    (void) execl(_PATH_LOGIN, "login", short2str(v[1]), NULL);
@


1.9
log
@indent
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.8 1998/12/16 17:46:06 deraadt Exp $       */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: func.c,v 1.8 1998/12/16 17:46:06 deraadt Exp $";
d770 1
a770 1
	    if (c == '\'' || c == '"')
d775 1
@


1.8
log
@fix built-in printf argument expansion (ie. printf '%d\n' `echo 23`);
gjm11@@dpmms.cam.ac.uk
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.7 1997/11/15 21:51:30 todd Exp $       */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: func.c,v 1.7 1997/11/15 21:51:30 todd Exp $";
d1523 7
a1529 7
        newv = globall(v);
        if (newv == 0) {
            stderror(ERR_NAME | ERR_NOMATCH);
            return;
        }
        v = newv;
        gargv=0;
@


1.7
log
@spelling
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.6 1997/07/25 18:58:07 mickey Exp $       */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: func.c,v 1.6 1997/07/25 18:58:07 mickey Exp $";
d1515 1
d1519 12
@


1.6
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.5 1997/07/23 14:36:50 kstailey Exp $       */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: func.c,v 1.5 1997/07/23 14:36:50 kstailey Exp $";
d1420 1
a1420 1
 *   its aguments, e.g. eval "date >x"  vs.  eval "date" >x
@


1.5
log
@tabify
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.4 1997/06/18 18:39:38 kstailey Exp $       */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: func.c,v 1.4 1997/06/18 18:39:38 kstailey Exp $";
d52 1
a52 1
#if __STDC__
@


1.4
log
@(foo *)NULL -> NULL
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.3 1996/06/23 14:19:22 deraadt Exp $       */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: func.c,v 1.3 1996/06/23 14:19:22 deraadt Exp $";
d1410 1
a1410 1
          goto retry;
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*    $OpenBSD: func.c,v 1.11 1996/02/09 02:28:29 christos Exp $       */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: func.c,v 1.11 1996/02/09 02:28:29 christos Exp $";
d1177 1
a1177 1
    res = (struct limits *) NULL;
@


1.2
log
@From netbsd:
fix bug where
child% suspend
parent% bg
parent% fg
Fg would not work anymore, it would say Suspended (tty input).
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: func.c,v 1.11 1996/02/09 02:28:29 christos Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: func.c,v 1.10 1995/03/21 18:35:42 mycroft Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: func.c,v 1.10 1995/03/21 18:35:42 mycroft Exp $";
d1403 1
d1405 1
a1405 1
	while  (ctpgrp != opgrp) {
d1409 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
