head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.8
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.12
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.8
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.6
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.4
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.2
	OPENBSD_5_0:1.21.0.8
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.26
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.22
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.20
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.18
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.16
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.14
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.12
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.10
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.8
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.6
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.4
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.12.0.6
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.4
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.6
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2015.12.26.13.48.38;	author mestre;	state Exp;
branches;
next	1.29;
commitid	jZMsEASvreUUSdqp;

1.29
date	2015.10.26.22.03.06;	author naddy;	state Exp;
branches;
next	1.28;
commitid	jREL04iPW8d08lKc;

1.28
date	2015.10.26.21.57.42;	author naddy;	state Exp;
branches;
next	1.27;
commitid	czPxwIHp6VIIfGKO;

1.27
date	2015.04.18.18.28.36;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	6b2lLILbgCR1fvia;

1.26
date	2015.02.08.06.09.50;	author tedu;	state Exp;
branches;
next	1.25;
commitid	i1nyRcSvJDMCYw84;

1.25
date	2015.02.08.05.51.37;	author tedu;	state Exp;
branches;
next	1.24;
commitid	L3WalZJ5Trtg0ORm;

1.24
date	2014.10.13.20.55.16;	author chl;	state Exp;
branches;
next	1.23;
commitid	lyXto0SVNcpGWB3e;

1.23
date	2014.07.14.05.53.29;	author guenther;	state Exp;
branches;
next	1.22;
commitid	R8tDNKzjP3trvD90;

1.22
date	2011.11.06.01.43.50;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.19.03.18.52;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.11.21.09.50;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.23.32.07;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.07.22.45.59;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.08.06.54.16;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.01.19.10.39;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.28.19.41.10;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.12.21.05.53.26;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.12.21.05.44.32;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.05.17.19.13.44;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.05.13.06.50.14;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.09.22.05.09.15;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.08.04.19.24.02;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.25.18.58.15;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.07.23.14.36.51;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.12.14.12.17.42;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Replace handrolled xfree() function by directly using free(3)

OK mmcc@@
@
text
@/*	$OpenBSD: proc.c,v 1.29 2015/10/26 22:03:06 naddy Exp $	*/
/*	$NetBSD: proc.c,v 1.9 1995/04/29 23:21:33 mycroft Exp $	*/

/*-
 * Copyright (c) 1980, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <errno.h>
#include <unistd.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#include "csh.h"
#include "dir.h"
#include "proc.h"
#include "extern.h"

#define BIGINDEX	9	/* largest desirable job index */

static struct rusage zru;

static void	 pflushall(void);
static void	 pflush(struct process *);
static void	 pclrcurr(struct process *);
static void	 padd(struct command *);
static int	 pprint(struct process *, int);
static void	 ptprint(struct process *);
static void	 pads(Char *);
static void	 pkill(Char **v, int);
static struct	process
		*pgetcurr(struct process *);
static void	 okpcntl(void);

/*
 * pchild - called at interrupt level by the SIGCHLD signal
 *	indicating that at least one child has terminated or stopped
 *	thus at least one wait system call will definitely return a
 *	childs status.  Top level routines (like pwait) must be sure
 *	to mask interrupts when playing with the proclist data structures!
 */
/* ARGUSED */
void
pchild(int notused)
{
    struct process *pp;
    struct process *fp;
    int pid;
    extern int insource;
    int save_errno = errno;
    int w;
    int     jobflags;
    struct rusage ru;

loop:
    errno = 0;			/* reset, just in case */
    pid = wait3(&w,
       (setintr && (intty || insource) ? WNOHANG | WUNTRACED : WNOHANG), &ru);

    if (pid <= 0) {
	if (errno == EINTR) {
	    errno = 0;
	    goto loop;
	}
	pnoprocesses = pid == -1;
	errno = save_errno;
	return;
    }
    for (pp = proclist.p_next; pp != NULL; pp = pp->p_next)
	if (pid == pp->p_pid)
	    goto found;
    goto loop;
found:
    if (pid == atoi(short2str(value(STRchild))))
	unsetv(STRchild);
    pp->p_flags &= ~(PRUNNING | PSTOPPED | PREPORTED);
    if (WIFSTOPPED(w)) {
	pp->p_flags |= PSTOPPED;
	pp->p_reason = WSTOPSIG(w);
    }
    else {
	if (pp->p_flags & (PTIME | PPTIME) || adrof(STRtime))
	    (void) gettimeofday(&pp->p_etime, NULL);

	pp->p_rusage = ru;
	if (WIFSIGNALED(w)) {
	    if (WTERMSIG(w) == SIGINT)
		pp->p_flags |= PINTERRUPTED;
	    else
		pp->p_flags |= PSIGNALED;
	    if (WCOREDUMP(w))
		pp->p_flags |= PDUMPED;
	    pp->p_reason = WTERMSIG(w);
	}
	else {
	    pp->p_reason = WEXITSTATUS(w);
	    if (pp->p_reason != 0)
		pp->p_flags |= PAEXITED;
	    else
		pp->p_flags |= PNEXITED;
	}
    }
    jobflags = 0;
    fp = pp;
    do {
	if ((fp->p_flags & (PPTIME | PRUNNING | PSTOPPED)) == 0 &&
	    !child && adrof(STRtime) &&
	    fp->p_rusage.ru_utime.tv_sec + fp->p_rusage.ru_stime.tv_sec
	    >= atoi(short2str(value(STRtime))))
	    fp->p_flags |= PTIME;
	jobflags |= fp->p_flags;
    } while ((fp = fp->p_friends) != pp);
    pp->p_flags &= ~PFOREGND;
    if (pp == pp->p_friends && (pp->p_flags & PPTIME)) {
	pp->p_flags &= ~PPTIME;
	pp->p_flags |= PTIME;
    }
    if ((jobflags & (PRUNNING | PREPORTED)) == 0) {
	fp = pp;
	do {
	    if (fp->p_flags & PSTOPPED)
		fp->p_flags |= PREPORTED;
	} while ((fp = fp->p_friends) != pp);
	while (fp->p_pid != fp->p_jobid)
	    fp = fp->p_friends;
	if (jobflags & PSTOPPED) {
	    if (pcurrent && pcurrent != fp)
		pprevious = pcurrent;
	    pcurrent = fp;
	}
	else
	    pclrcurr(fp);
	if (jobflags & PFOREGND) {
	    if (jobflags & (PSIGNALED | PSTOPPED | PPTIME) ||
		!eq(dcwd->di_name, fp->p_cwd->di_name)) {
		;		/* print in pjwait */
	    }
	    /* PWP: print a newline after ^C */
	    else if (jobflags & PINTERRUPTED) {
		(void) vis_fputc('\r' | QUOTE, cshout);
		(void) fputc('\n', cshout);
	    }
	}
	else {
	    if (jobflags & PNOTIFY || adrof(STRnotify)) {
		(void) vis_fputc('\r' | QUOTE, cshout);
		(void) fputc('\n', cshout);
		(void) pprint(pp, NUMBER | NAME | REASON);
		if ((jobflags & PSTOPPED) == 0)
		    pflush(pp);
	    }
	    else {
		fp->p_flags |= PNEEDNOTE;
		neednote++;
	    }
	}
    }
    goto loop;
}

void
pnote(void)
{
    struct process *pp;
    int     flags;
    sigset_t sigset, osigset;

    neednote = 0;
    sigemptyset(&sigset);
    sigaddset(&sigset, SIGCHLD);
    for (pp = proclist.p_next; pp != NULL; pp = pp->p_next) {
	if (pp->p_flags & PNEEDNOTE) {
	    sigprocmask(SIG_BLOCK, &sigset, &osigset);
	    pp->p_flags &= ~PNEEDNOTE;
	    flags = pprint(pp, NUMBER | NAME | REASON);
	    if ((flags & (PRUNNING | PSTOPPED)) == 0)
		pflush(pp);
	    sigprocmask(SIG_SETMASK, &osigset, NULL);
	}
    }
}

/*
 * pwait - wait for current job to terminate, maintaining integrity
 *	of current and previous job indicators.
 */
void
pwait(void)
{
    struct process *fp, *pp;
    sigset_t sigset, osigset;

    /*
     * Here's where dead procs get flushed.
     */
    sigemptyset(&sigset);
    sigaddset(&sigset, SIGCHLD);
    sigprocmask(SIG_BLOCK, &sigset, &osigset);
    for (pp = (fp = &proclist)->p_next; pp != NULL; pp = (fp = pp)->p_next)
	if (pp->p_pid == 0) {
	    fp->p_next = pp->p_next;
	    free(pp->p_command);
	    if (pp->p_cwd && --pp->p_cwd->di_count == 0)
		if (pp->p_cwd->di_next == 0)
		    dfree(pp->p_cwd);
	    free(pp);
	    pp = fp;
	}
    sigprocmask(SIG_SETMASK, &osigset, NULL);
    pjwait(pcurrjob);
}


/*
 * pjwait - wait for a job to finish or become stopped
 *	It is assumed to be in the foreground state (PFOREGND)
 */
void
pjwait(struct process *pp)
{
    struct process *fp;
    int     jobflags, reason;
    sigset_t sigset, osigset;

    while (pp->p_pid != pp->p_jobid)
	pp = pp->p_friends;
    fp = pp;

    do {
	if ((fp->p_flags & (PFOREGND | PRUNNING)) == PRUNNING)
	    (void) fprintf(csherr, "BUG: waiting for background job!\n");
    } while ((fp = fp->p_friends) != pp);
    /*
     * Now keep pausing as long as we are not interrupted (SIGINT), and the
     * target process, or any of its friends, are running
     */
    fp = pp;
    sigemptyset(&sigset);
    sigaddset(&sigset, SIGCHLD);
    sigprocmask(SIG_BLOCK, &sigset, &osigset);
    for (;;) {
	sigemptyset(&sigset);
	sigaddset(&sigset, SIGCHLD);
	sigprocmask(SIG_BLOCK, &sigset, NULL);
	jobflags = 0;
	do
	    jobflags |= fp->p_flags;
	while ((fp = (fp->p_friends)) != pp);
	if ((jobflags & PRUNNING) == 0)
	    break;
	sigset = osigset;
	sigdelset(&sigset, SIGCHLD);
	sigsuspend(&sigset);
    }
    sigprocmask(SIG_SETMASK, &osigset, NULL);
    if (tpgrp > 0)		/* get tty back */
	(void) tcsetpgrp(FSHTTY, tpgrp);
    if ((jobflags & (PSIGNALED | PSTOPPED | PTIME)) ||
	!eq(dcwd->di_name, fp->p_cwd->di_name)) {
	if (jobflags & PSTOPPED) {
	    (void) fputc('\n', cshout);
	    if (adrof(STRlistjobs)) {
		Char   *jobcommand[3];

		jobcommand[0] = STRjobs;
		if (eq(value(STRlistjobs), STRlong))
		    jobcommand[1] = STRml;
		else
		    jobcommand[1] = NULL;
		jobcommand[2] = NULL;

		dojobs(jobcommand, NULL);
		(void) pprint(pp, SHELLDIR);
	    }
	    else
		(void) pprint(pp, AREASON | SHELLDIR);
	}
	else
	    (void) pprint(pp, AREASON | SHELLDIR);
    }
    if ((jobflags & (PINTERRUPTED | PSTOPPED)) && setintr &&
	(!gointr || !eq(gointr, STRminus))) {
	if ((jobflags & PSTOPPED) == 0)
	    pflush(pp);
	pintr1(0);
	/* NOTREACHED */
    }
    reason = 0;
    fp = pp;
    do {
	if (fp->p_reason)
	    reason = fp->p_flags & (PSIGNALED | PINTERRUPTED) ?
		fp->p_reason | META : fp->p_reason;
    } while ((fp = fp->p_friends) != pp);
    if ((reason != 0) && (adrof(STRprintexitvalue))) {
	(void) fprintf(cshout, "Exit %d\n", reason);
    }
    set(STRstatus, putn(reason));
    if (reason && exiterr)
	exitstat();
    pflush(pp);
}

/*
 * dowait - wait for all processes to finish
 */
void
/*ARGSUSED*/
dowait(Char **v, struct command *t)
{
    struct process *pp;
    sigset_t sigset, osigset;

    pjobs++;
    sigemptyset(&sigset);
    sigaddset(&sigset, SIGCHLD);
    sigprocmask(SIG_BLOCK, &sigset, &osigset);
loop:
    for (pp = proclist.p_next; pp; pp = pp->p_next)
	if (pp->p_pid &&	/* pp->p_pid == pp->p_jobid && */
	    pp->p_flags & PRUNNING) {
	    sigemptyset(&sigset);
	    sigsuspend(&sigset);
	    goto loop;
	}
    sigprocmask(SIG_SETMASK, &osigset, NULL);
    pjobs = 0;
}

/*
 * pflushall - flush all jobs from list (e.g. at fork())
 */
static void
pflushall(void)
{
    struct process *pp;

    for (pp = proclist.p_next; pp != NULL; pp = pp->p_next)
	if (pp->p_pid)
	    pflush(pp);
}

/*
 * pflush - flag all process structures in the same job as the
 *	the argument process for deletion.  The actual free of the
 *	space is not done here since pflush is called at interrupt level.
 */
static void
pflush(struct process *pp)
{
    struct process *np;
    int idx;

    if (pp->p_pid == 0) {
	(void) fprintf(csherr, "BUG: process flushed twice");
	return;
    }
    while (pp->p_pid != pp->p_jobid)
	pp = pp->p_friends;
    pclrcurr(pp);
    if (pp == pcurrjob)
	pcurrjob = 0;
    idx = pp->p_index;
    np = pp;
    do {
	np->p_index = np->p_pid = 0;
	np->p_flags &= ~PNEEDNOTE;
    } while ((np = np->p_friends) != pp);
    if (idx == pmaxindex) {
	for (np = proclist.p_next, idx = 0; np; np = np->p_next)
	    if (np->p_index > idx)
		idx = np->p_index;
	pmaxindex = idx;
    }
}

/*
 * pclrcurr - make sure the given job is not the current or previous job;
 *	pp MUST be the job leader
 */
static void
pclrcurr(struct process *pp)
{

    if (pp == pcurrent)
	if (pprevious != NULL) {
	    pcurrent = pprevious;
	    pprevious = pgetcurr(pp);
	}
	else {
	    pcurrent = pgetcurr(pp);
	    pprevious = pgetcurr(pp);
	}
    else if (pp == pprevious)
	pprevious = pgetcurr(pp);
}

/* +4 here is 1 for '\0', 1 ea for << >& >> */
static Char command[PMAXLEN + 4];
static int cmdlen;
static Char *cmdp;

/*
 * palloc - allocate a process structure and fill it up.
 *	an important assumption is made that the process is running.
 */
void
palloc(int pid, struct command *t)
{
    struct process *pp;
    int     i;

    pp = xcalloc(1, (size_t) sizeof(struct process));
    pp->p_pid = pid;
    pp->p_flags = t->t_dflg & F_AMPERSAND ? PRUNNING : PRUNNING | PFOREGND;
    if (t->t_dflg & F_TIME)
	pp->p_flags |= PPTIME;
    cmdp = command;
    cmdlen = 0;
    padd(t);
    *cmdp++ = 0;
    if (t->t_dflg & F_PIPEOUT) {
	pp->p_flags |= PPOU;
	if (t->t_dflg & F_STDERR)
	    pp->p_flags |= PERR;
    }
    pp->p_command = Strsave(command);
    if (pcurrjob) {
	struct process *fp;

	/* careful here with interrupt level */
	pp->p_cwd = 0;
	pp->p_index = pcurrjob->p_index;
	pp->p_friends = pcurrjob;
	pp->p_jobid = pcurrjob->p_pid;
	for (fp = pcurrjob; fp->p_friends != pcurrjob; fp = fp->p_friends)
	    continue;
	fp->p_friends = pp;
    }
    else {
	pcurrjob = pp;
	pp->p_jobid = pid;
	pp->p_friends = pp;
	pp->p_cwd = dcwd;
	dcwd->di_count++;
	if (pmaxindex < BIGINDEX)
	    pp->p_index = ++pmaxindex;
	else {
	    struct process *np;

	    for (i = 1;; i++) {
		for (np = proclist.p_next; np; np = np->p_next)
		    if (np->p_index == i)
			goto tryagain;
		pp->p_index = i;
		if (i > pmaxindex)
		    pmaxindex = i;
		break;
	tryagain:;
	    }
	}
	if (pcurrent == NULL)
	    pcurrent = pp;
	else if (pprevious == NULL)
	    pprevious = pp;
    }
    pp->p_next = proclist.p_next;
    proclist.p_next = pp;
    (void) gettimeofday(&pp->p_btime, NULL);
}

static void
padd(struct command *t)
{
    Char  **argp;

    if (t == 0)
	return;
    switch (t->t_dtyp) {

    case NODE_PAREN:
	pads(STRLparensp);
	padd(t->t_dspr);
	pads(STRspRparen);
	break;

    case NODE_COMMAND:
	for (argp = t->t_dcom; *argp; argp++) {
	    pads(*argp);
	    if (argp[1])
		pads(STRspace);
	}
	break;

    case NODE_OR:
    case NODE_AND:
    case NODE_PIPE:
    case NODE_LIST:
	padd(t->t_dcar);
	switch (t->t_dtyp) {
	case NODE_OR:
	    pads(STRspor2sp);
	    break;
	case NODE_AND:
	    pads(STRspand2sp);
	    break;
	case NODE_PIPE:
	    pads(STRsporsp);
	    break;
	case NODE_LIST:
	    pads(STRsemisp);
	    break;
	}
	padd(t->t_dcdr);
	return;
    }
    if ((t->t_dflg & F_PIPEIN) == 0 && t->t_dlef) {
	pads((t->t_dflg & F_READ) ? STRspLarrow2sp : STRspLarrowsp);
	pads(t->t_dlef);
    }
    if ((t->t_dflg & F_PIPEOUT) == 0 && t->t_drit) {
	pads((t->t_dflg & F_APPEND) ? STRspRarrow2 : STRspRarrow);
	if (t->t_dflg & F_STDERR)
	    pads(STRand);
	pads(STRspace);
	pads(t->t_drit);
    }
}

static void
pads(Char *cp)
{
    int i;

    /*
     * Avoid the Quoted Space alias hack! Reported by:
     * sam@@john-bigboote.ICS.UCI.EDU (Sam Horrocks)
     */
    if (cp[0] == STRQNULL[0])
	cp++;

    i = Strlen(cp);

    if (cmdlen >= PMAXLEN)
	return;
    if (cmdlen + i >= PMAXLEN) {
	(void) Strlcpy(cmdp, STRsp3dots, PMAXLEN - cmdlen);
	cmdlen = PMAXLEN;
	cmdp += 4;
	return;
    }
    (void) Strlcpy(cmdp, cp, PMAXLEN - cmdlen);
    cmdp += i;
    cmdlen += i;
}

/*
 * psavejob - temporarily save the current job on a one level stack
 *	so another job can be created.  Used for { } in exp6
 *	and `` in globbing.
 */
void
psavejob(void)
{

    pholdjob = pcurrjob;
    pcurrjob = NULL;
}

/*
 * prestjob - opposite of psavejob.  This may be missed if we are interrupted
 *	somewhere, but pendjob cleans up anyway.
 */
void
prestjob(void)
{

    pcurrjob = pholdjob;
    pholdjob = NULL;
}

/*
 * pendjob - indicate that a job (set of commands) has been completed
 *	or is about to begin.
 */
void
pendjob(void)
{
    struct process *pp, *tp;

    if (pcurrjob && (pcurrjob->p_flags & (PFOREGND | PSTOPPED)) == 0) {
	pp = pcurrjob;
	while (pp->p_pid != pp->p_jobid)
	    pp = pp->p_friends;
	(void) fprintf(cshout, "[%d]", pp->p_index);
	tp = pp;
	do {
	    (void) fprintf(cshout, " %d", pp->p_pid);
	    pp = pp->p_friends;
	} while (pp != tp);
	(void) fputc('\n', cshout);
    }
    pholdjob = pcurrjob = 0;
}

/*
 * pprint - print a job
 */
static int
pprint(struct process *pp, bool flag)
{
    int status, reason;
    struct process *tp;
    int     jobflags, pstatus;
    bool hadnl = 1;	/* did we just have a newline */

    (void) fpurge(cshout);

    while (pp->p_pid != pp->p_jobid)
	pp = pp->p_friends;
    if (pp == pp->p_friends && (pp->p_flags & PPTIME)) {
	pp->p_flags &= ~PPTIME;
	pp->p_flags |= PTIME;
    }
    tp = pp;
    status = reason = -1;
    jobflags = 0;
    do {
	jobflags |= pp->p_flags;
	pstatus = pp->p_flags & PALLSTATES;
	if (tp != pp && !hadnl && !(flag & FANCY) &&
	    ((pstatus == status && pp->p_reason == reason) ||
	     !(flag & REASON))) {
	    (void) fputc(' ', cshout);
	    hadnl = 0;
	}
	else {
	    if (tp != pp && !hadnl) {
		(void) fputc('\n', cshout);
		hadnl = 1;
	    }
	    if (flag & NUMBER) {
		if (pp == tp)
		    (void) fprintf(cshout, "[%d]%s %c ", pp->p_index,
			    pp->p_index < 10 ? " " : "",
			    pp == pcurrent ? '+' :
			    (pp == pprevious ? '-' : ' '));
		else
		    (void) fprintf(cshout, "       ");
		hadnl = 0;
	    }
	    if (flag & FANCY) {
		(void) fprintf(cshout, "%5d ", pp->p_pid);
		hadnl = 0;
	    }
	    if (flag & (REASON | AREASON)) {
		int width = 0;
		if (flag & NAME)
		    width = -23;
		if (pstatus == status)
		    if (pp->p_reason == reason) {
			(void) fprintf(cshout, "%*s", width, "");
			hadnl = 0;
			goto prcomd;
		    }
		    else
			reason = pp->p_reason;
		else {
		    status = pstatus;
		    reason = pp->p_reason;
		}
		switch (status) {

		case PRUNNING:
		    (void) fprintf(cshout, "%*s", width, "Running ");
		    hadnl = 0;
		    break;

		case PINTERRUPTED:
		case PSTOPPED:
		case PSIGNALED:
		    /*
		     * tell what happened to the background job
		     * From: Michael Schroeder
		     * <mlschroe@@immd4.informatik.uni-erlangen.de>
		     */
		    if ((flag & REASON)
			|| ((flag & AREASON)
			    && reason != SIGINT
			    && (reason != SIGPIPE
				|| (pp->p_flags & PPOU) == 0))) {
			(void) fprintf(cshout, "%*s", width,
				       sys_siglist[(unsigned char)
						   pp->p_reason]);
			hadnl = 0;
		    }
		    break;

		case PNEXITED:
		case PAEXITED:
		    if (flag & REASON) {
			if (pp->p_reason)
			    (void) fprintf(cshout, "Exit %-18d", pp->p_reason);
			else
			    (void) fprintf(cshout, "%*s", width, "Done");
			hadnl = 0;
		    }
		    break;

		default:
		    (void) fprintf(csherr, "BUG: status=%-9o", status);
		}
	    }
	}
prcomd:
	if (flag & NAME) {
	    (void) fprintf(cshout, "%s", vis_str(pp->p_command));
	    if (pp->p_flags & PPOU)
		(void) fprintf(cshout, " |");
	    if (pp->p_flags & PERR)
		(void) fputc('&', cshout);
	    hadnl = 0;
	}
	if (flag & (REASON | AREASON) && pp->p_flags & PDUMPED) {
	    (void) fprintf(cshout, " (core dumped)");
	    hadnl = 0;
	}
	if (tp == pp->p_friends) {
	    if (flag & AMPERSAND) {
		(void) fprintf(cshout, " &");
		hadnl = 0;
	    }
	    if (flag & JOBDIR &&
		!eq(tp->p_cwd->di_name, dcwd->di_name)) {
		(void) fprintf(cshout, " (wd: ");
		dtildepr(value(STRhome), tp->p_cwd->di_name);
		(void) fputc(')', cshout);
		hadnl = 0;
	    }
	}
	if (pp->p_flags & PPTIME && !(status & (PSTOPPED | PRUNNING))) {
	    if (!hadnl)
		(void) fprintf(cshout, "\n\t");
	    prusage(&zru, &pp->p_rusage, &pp->p_etime,
		    &pp->p_btime);
	    hadnl = 1;
	}
	if (tp == pp->p_friends) {
	    if (!hadnl) {
		(void) fputc('\n', cshout);
		hadnl = 1;
	    }
	    if (flag & SHELLDIR && !eq(tp->p_cwd->di_name, dcwd->di_name)) {
		(void) fprintf(cshout, "(wd now: ");
		dtildepr(value(STRhome), dcwd->di_name);
		(void) fprintf(cshout, ")\n");
		hadnl = 1;
	    }
	}
    } while ((pp = pp->p_friends) != tp);
    if (jobflags & PTIME && (jobflags & (PSTOPPED | PRUNNING)) == 0) {
	if (jobflags & NUMBER)
	    (void) fprintf(cshout, "       ");
	ptprint(tp);
	hadnl = 1;
    }
    (void) fflush(cshout);
    return (jobflags);
}

static void
ptprint(struct process *tp)
{
    struct timeval tetime, diff;
    static struct timeval ztime;
    struct rusage ru;
    static struct rusage zru;
    struct process *pp = tp;

    ru = zru;
    tetime = ztime;
    do {
	ruadd(&ru, &pp->p_rusage);
	timersub(&pp->p_etime, &pp->p_btime, &diff);
	if (timercmp(&diff, &tetime, >))
	    tetime = diff;
    } while ((pp = pp->p_friends) != tp);
    prusage(&zru, &ru, &tetime, &ztime);
}

/*
 * dojobs - print all jobs
 */
void
/*ARGSUSED*/
dojobs(Char **v, struct command *t)
{
    struct process *pp;
    int flag = NUMBER | NAME | REASON;
    int     i;

    if (chkstop)
	chkstop = 2;
    if (*++v) {
	if (v[1] || !eq(*v, STRml))
	    stderror(ERR_JOBS);
	flag |= FANCY | JOBDIR;
    }
    for (i = 1; i <= pmaxindex; i++)
	for (pp = proclist.p_next; pp; pp = pp->p_next)
	    if (pp->p_index == i && pp->p_pid == pp->p_jobid) {
		pp->p_flags &= ~PNEEDNOTE;
		if (!(pprint(pp, flag) & (PRUNNING | PSTOPPED)))
		    pflush(pp);
		break;
	    }
}

/*
 * dofg - builtin - put the job into the foreground
 */
void
/*ARGSUSED*/
dofg(Char **v, struct command *t)
{
    struct process *pp;

    okpcntl();
    ++v;
    do {
	pp = pfind(*v);
	pstart(pp, 1);
	pjwait(pp);
    } while (*v && *++v);
}

/*
 * %... - builtin - put the job into the foreground
 */
void
/*ARGSUSED*/
dofg1(Char **v, struct command *t)
{
    struct process *pp;

    okpcntl();
    pp = pfind(v[0]);
    pstart(pp, 1);
    pjwait(pp);
}

/*
 * dobg - builtin - put the job into the background
 */
void
/*ARGSUSED*/
dobg(Char **v, struct command *t)
{
    struct process *pp;

    okpcntl();
    ++v;
    do {
	pp = pfind(*v);
	pstart(pp, 0);
    } while (*v && *++v);
}

/*
 * %... & - builtin - put the job into the background
 */
void
/*ARGSUSED*/
dobg1(Char **v, struct command *t)
{
    struct process *pp;

    pp = pfind(v[0]);
    pstart(pp, 0);
}

/*
 * dostop - builtin - stop the job
 */
void
/*ARGSUSED*/
dostop(Char **v, struct command *t)
{
    pkill(++v, SIGSTOP);
}

/*
 * dokill - builtin - superset of kill (1)
 */
void
/*ARGSUSED*/
dokill(Char **v, struct command *t)
{
    int signum = SIGTERM;
    const char *errstr;
    char *name;

    v++;
    if (v[0] && v[0][0] == '-') {
	if (v[0][1] == 'l') {
	    if (v[1]) {
		if (!Isdigit(v[1][0]))
		    stderror(ERR_NAME | ERR_BADSIG);

		signum = strtonum(short2str(v[1]), 0, NSIG-1, &errstr);
		if (errstr)
		    stderror(ERR_NAME | ERR_BADSIG);
		else if (signum == 0)
		    (void) fputc('0', cshout); /* 0's symbolic name is '0' */
		else
		    (void) fprintf(cshout, "%s ", sys_signame[signum]);
	    } else {
		for (signum = 1; signum < NSIG; signum++) {
		    (void) fprintf(cshout, "%s ", sys_signame[signum]);
		    if (signum == NSIG / 2)
			(void) fputc('\n', cshout);
	    	}
	    }
	    (void) fputc('\n', cshout);
	    return;
	}
	if (Isdigit(v[0][1])) {
	    signum = strtonum(short2str(v[0] + 1), 0, NSIG-1, &errstr);
	    if (errstr)
		stderror(ERR_NAME | ERR_BADSIG);
	}
	else {
	    if (v[0][1] == 's' && (Isspace(v[0][2]) || v[0][2] == '\0')) {
		v++;
		name = short2str(&v[0][0]);
	    } else {
		name = short2str(&v[0][1]);
	    }

	    if (v[0] == NULL || v[1] == NULL) {
		stderror(ERR_NAME | ERR_TOOFEW);
		return;
	    }

	    for (signum = 1; signum < NSIG; signum++)
		if (!strcasecmp(sys_signame[signum], name) ||
		    (strlen(name) > 3 && !strncasecmp("SIG", name, 3) &&
		     !strcasecmp(sys_signame[signum], name + 3)))
			break;

	    if (signum == NSIG) {
		if (name[0] == '0')
		    signum = 0;
		else {
		    setname(vis_str(&v[0][0]));
		    stderror(ERR_NAME | ERR_UNKSIG);
		}
	    }
	}
	v++;
    }
    pkill(v, signum);
}

static void
pkill(Char **v, int signum)
{
    struct process *pp, *np;
    int jobflags = 0;
    int     pid, err1 = 0;
    sigset_t sigset;
    Char   *cp;

    sigemptyset(&sigset);
    sigaddset(&sigset, SIGCHLD);
    if (setintr)
	sigaddset(&sigset, SIGINT);
    sigprocmask(SIG_BLOCK, &sigset, NULL);
    gflag = 0, tglob(v);
    if (gflag) {
	v = globall(v);
	if (v == 0)
	    stderror(ERR_NAME | ERR_NOMATCH);
    }
    else {
	v = gargv = saveblk(v);
	trim(v);
    }

    while (v && (cp = *v)) {
	if (*cp == '%') {
	    np = pp = pfind(cp);
	    do
		jobflags |= np->p_flags;
	    while ((np = np->p_friends) != pp);
	    switch (signum) {

	    case SIGSTOP:
	    case SIGTSTP:
	    case SIGTTIN:
	    case SIGTTOU:
		if ((jobflags & PRUNNING) == 0) {
		    (void) fprintf(csherr, "%s: Already suspended\n",
				   vis_str(cp));
		    err1++;
		    goto cont;
		}
		break;
		/*
		 * suspend a process, kill -CONT %, then type jobs; the shell
		 * says it is suspended, but it is running; thanks jaap..
		 */
	    case SIGCONT:
		pstart(pp, 0);
		goto cont;
	    }
	    if (kill(-pp->p_jobid, signum) < 0) {
		(void) fprintf(csherr, "%s: %s\n", vis_str(cp),
			       strerror(errno));
		err1++;
	    }
	    if (signum == SIGTERM || signum == SIGHUP)
		(void) kill(-pp->p_jobid, SIGCONT);
	}
	else if (!(Isdigit(*cp) || *cp == '-'))
	    stderror(ERR_NAME | ERR_JOBARGS);
	else {
	    char *ep;
	    char *pidnam = short2str(cp);

	    pid = strtol(pidnam, &ep, 10);
	    if (!*pidnam || *ep) {
		(void) fprintf(csherr, "%s: illegal process id\n", pidnam);
		err1++;
		goto cont;
	    }
	    if (kill((pid_t) pid, signum) < 0) {
		(void) fprintf(csherr, "%d: %s\n", pid, strerror(errno));
		err1++;
		goto cont;
	    }
	    if (signum == SIGTERM || signum == SIGHUP)
		(void) kill((pid_t) pid, SIGCONT);
	}
cont:
	v++;
    }
    if (gargv)
	blkfree(gargv), gargv = 0;
    sigprocmask(SIG_UNBLOCK, &sigset, NULL);
    if (err1)
	stderror(ERR_SILENT);
}

/*
 * pstart - start the job in foreground/background
 */
void
pstart(struct process *pp, int foregnd)
{
    struct process *np;
    sigset_t sigset, osigset;
    long    jobflags = 0;

    sigemptyset(&sigset);
    sigaddset(&sigset, SIGCHLD);
    sigprocmask(SIG_BLOCK, &sigset, &osigset);
    np = pp;
    do {
	jobflags |= np->p_flags;
	if (np->p_flags & (PRUNNING | PSTOPPED)) {
	    np->p_flags |= PRUNNING;
	    np->p_flags &= ~PSTOPPED;
	    if (foregnd)
		np->p_flags |= PFOREGND;
	    else
		np->p_flags &= ~PFOREGND;
	}
    } while ((np = np->p_friends) != pp);
    if (!foregnd)
	pclrcurr(pp);
    (void) pprint(pp, foregnd ? NAME | JOBDIR : NUMBER | NAME | AMPERSAND);
    if (foregnd)
	(void) tcsetpgrp(FSHTTY, pp->p_jobid);
    if (jobflags & PSTOPPED)
	(void) kill(-pp->p_jobid, SIGCONT);
    sigprocmask(SIG_SETMASK, &osigset, NULL);
}

void
panystop(bool neednl)
{
    struct process *pp;

    chkstop = 2;
    for (pp = proclist.p_next; pp; pp = pp->p_next)
	if (pp->p_flags & PSTOPPED)
	    stderror(ERR_STOPPED, neednl ? "\n" : "");
}

struct process *
pfind(Char *cp)
{
    struct process *pp, *np;

    if (cp == 0 || cp[1] == 0 || eq(cp, STRcent2) || eq(cp, STRcentplus)) {
	if (pcurrent == NULL)
	    stderror(ERR_NAME | ERR_JOBCUR);
	return (pcurrent);
    }
    if (eq(cp, STRcentminus) || eq(cp, STRcenthash)) {
	if (pprevious == NULL)
	    stderror(ERR_NAME | ERR_JOBPREV);
	return (pprevious);
    }
    if (Isdigit(cp[1])) {
	const char *errstr;
	int     idx = strtonum(short2str(cp + 1), 1, INT_MAX, &errstr);

	if (errstr) {
		stderror(ERR_NAME | ERR_NOSUCHJOB);
		return (0);
	}
	for (pp = proclist.p_next; pp; pp = pp->p_next)
	    if (pp->p_index == idx && pp->p_pid == pp->p_jobid)
		return (pp);
	stderror(ERR_NAME | ERR_NOSUCHJOB);
	return (0);
    }
    np = NULL;
    for (pp = proclist.p_next; pp; pp = pp->p_next)
	if (pp->p_pid == pp->p_jobid) {
	    if (cp[1] == '?') {
		Char *dp;

		for (dp = pp->p_command; *dp; dp++) {
		    if (*dp != cp[2])
			continue;
		    if (prefix(cp + 2, dp))
			goto match;
		}
	    }
	    else if (prefix(cp + 1, pp->p_command)) {
	match:
		if (np)
		    stderror(ERR_NAME | ERR_AMBIG);
		np = pp;
	    }
	}
    if (np)
	return (np);
    stderror(ERR_NAME | (cp[1] == '?' ? ERR_JOBPAT : ERR_NOSUCHJOB));
    /* NOTREACHED */
    return (0);
}


/*
 * pgetcurr - find most recent job that is not pp, preferably stopped
 */
static struct process *
pgetcurr(struct process *pp)
{
    struct process *np;
    struct process *xp = NULL;

    for (np = proclist.p_next; np; np = np->p_next)
	if (np != pcurrent && np != pp && np->p_pid &&
	    np->p_pid == np->p_jobid) {
	    if (np->p_flags & PSTOPPED)
		return (np);
	    if (xp == NULL)
		xp = np;
	}
    return (xp);
}

/*
 * donotify - flag the job so as to report termination asynchronously
 */
void
/*ARGSUSED*/
donotify(Char **v, struct command *t)
{
    struct process *pp;

    pp = pfind(*++v);
    pp->p_flags |= PNOTIFY;
}

/*
 * Do the fork and whatever should be done in the child side that
 * should not be done if we are not forking at all (like for simple builtin's)
 * Also do everything that needs any signals fiddled with in the parent side
 *
 * Wanttty tells whether process and/or tty pgrps are to be manipulated:
 *	-1:	leave tty alone; inherit pgrp from parent
 *	 0:	already have tty; manipulate process pgrps only
 *	 1:	want to claim tty; manipulate process and tty pgrps
 * It is usually just the value of tpgrp.
 */

int
pfork(struct command *t, int wanttty)
{
    int pid;
    bool    ignint = 0;
    int     pgrp;
    sigset_t sigset, osigset;

    /*
     * A child will be uninterruptible only under very special conditions.
     * Remember that the semantics of '&' is implemented by disconnecting the
     * process from the tty so signals do not need to ignored just for '&'.
     * Thus signals are set to default action for children unless: we have had
     * an "onintr -" (then specifically ignored) we are not playing with
     * signals (inherit action)
     */
    if (setintr)
	ignint = (tpgrp == -1 && (t->t_dflg & F_NOINTERRUPT))
	    || (gointr && eq(gointr, STRminus));
    /*
     * Check for maximum nesting of 16 processes to avoid Forking loops
     */
    if (child == 16)
	stderror(ERR_NESTING, 16);
    /*
     * Hold SIGCHLD until we have the process installed in our table.
     */
    sigemptyset(&sigset);
    sigaddset(&sigset, SIGCHLD);
    sigprocmask(SIG_BLOCK, &sigset, &osigset);
    while ((pid = fork()) < 0)
	if (setintr == 0)
	    (void) sleep(FORKSLEEP);
	else {
	    sigprocmask(SIG_SETMASK, &osigset, NULL);
	    stderror(ERR_NOPROC);
	}
    if (pid == 0) {
	settimes();
	pgrp = pcurrjob ? pcurrjob->p_jobid : getpid();
	pflushall();
	pcurrjob = NULL;
	child++;
	if (setintr) {
	    setintr = 0;	/* until I think otherwise */
	    /*
	     * Children just get blown away on SIGINT, SIGQUIT unless "onintr
	     * -" seen.
	     */
	    (void) signal(SIGINT, ignint ? SIG_IGN : SIG_DFL);
	    (void) signal(SIGQUIT, ignint ? SIG_IGN : SIG_DFL);
	    if (wanttty >= 0) {
		/* make stoppable */
		(void) signal(SIGTSTP, SIG_DFL);
		(void) signal(SIGTTIN, SIG_DFL);
		(void) signal(SIGTTOU, SIG_DFL);
	    }
	    (void) signal(SIGTERM, parterm);
	}
	else if (tpgrp == -1 && (t->t_dflg & F_NOINTERRUPT)) {
	    (void) signal(SIGINT, SIG_IGN);
	    (void) signal(SIGQUIT, SIG_IGN);
	}
	pgetty(wanttty, pgrp);
	/*
	 * Nohup and nice apply only to NODE_COMMAND's but it would be nice
	 * (?!?) if you could say "nohup (foo;bar)" Then the parser would have
	 * to know about nice/nohup/time
	 */
	if (t->t_dflg & F_NOHUP)
	    (void) signal(SIGHUP, SIG_IGN);
	if (t->t_dflg & F_NICE)
	    (void) setpriority(PRIO_PROCESS, 0, t->t_nice);
    }
    else {
	if (wanttty >= 0)
	    (void) setpgid(pid, pcurrjob ? pcurrjob->p_jobid : pid);
	palloc(pid, t);
	sigprocmask(SIG_SETMASK, &osigset, NULL);
    }

    return (pid);
}

static void
okpcntl(void)
{
    if (tpgrp == -1)
	stderror(ERR_JOBCONTROL);
    if (tpgrp == 0)
	stderror(ERR_JOBCTRLSUB);
}

/*
 * if we don't have vfork(), things can still go in the wrong order
 * resulting in the famous 'Stopped (tty output)'. But some systems
 * don't permit the setpgid() call, (these are more recent secure
 * systems such as ibm's aix). Then we'd rather print an error message
 * than hang the shell!
 * I am open to suggestions how to fix that.
 */
void
pgetty(int wanttty, int pgrp)
{
    sigset_t sigset, osigset;

    /*
     * christos: I am blocking the tty signals till I've set things
     * correctly....
     */
    if (wanttty > 0) {
	sigemptyset(&sigset);
	sigaddset(&sigset, SIGTSTP);
	sigaddset(&sigset, SIGTTIN);
	sigaddset(&sigset, SIGTTOU);
	sigprocmask(SIG_BLOCK, &sigset, &osigset);
    }
    /*
     * From: Michael Schroeder <mlschroe@@immd4.informatik.uni-erlangen.de>
     * Don't check for tpgrp >= 0 so even non-interactive shells give
     * background jobs process groups Same for the comparison in the other part
     * of the #ifdef
     */
    if (wanttty >= 0)
	if (setpgid(0, pgrp) == -1) {
	    (void) fprintf(csherr, "csh: setpgid error.\n");
	    xexit(0);
	}

    if (wanttty > 0) {
	(void) tcsetpgrp(FSHTTY, pgrp);
	sigprocmask(SIG_SETMASK, &osigset, NULL);
    }

    if (tpgrp > 0)
	tpgrp = 0;		/* gave tty away */
}
@


1.29
log
@miscellaneous cruft:
* remove lint
* unifdef S_IFLNK, S_ISFIFO, S_ISLNK, S_ISSOCK, O_APPEND
* remove 0, NOTUSED, notdef -- untouched since original import
* remove IIASA
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.28 2015/10/26 21:57:42 naddy Exp $	*/
d230 1
a230 1
	    xfree(pp->p_command);
d234 1
a234 1
	    xfree(pp);
@


1.28
log
@remove the profiling and debugging ifdefs; ok zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.27 2015/04/18 18:28:36 deraadt Exp $	*/
a162 3
#ifdef IIASA
		jobflags & PAEXITED ||
#endif
@


1.27
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.26 2015/02/08 06:09:50 tedu Exp $	*/
a281 4
#ifdef JOBDEBUG
	(void) fprintf(csherr, "starting to sigsuspend for  SIGCHLD on %d\n",
		       fp->p_pid);
#endif				/* JOBDEBUG */
@


1.26
log
@delete tons more casts
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.25 2015/02/08 05:51:37 tedu Exp $	*/
d37 1
d935 1
d945 2
a946 2
		signum = atoi(short2str(v[1]));
		if (signum < 0 || signum >= NSIG)
d963 2
a964 2
	    signum = atoi(short2str(v[0] + 1));
	    if (signum < 0 || signum >= NSIG)
d1152 2
a1153 1
	int     idx = atoi(short2str(cp + 1));
d1155 4
d1163 1
@


1.25
log
@delete many more ptr_t casts
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.24 2014/10/13 20:55:16 chl Exp $	*/
d447 1
a447 1
    pp = (struct process *) xcalloc(1, (size_t) sizeof(struct process));
@


1.24
log
@remove unused variable

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.23 2014/07/14 05:53:29 guenther Exp $	*/
d232 1
a232 1
	    xfree((ptr_t) pp->p_command);
d236 1
a236 1
	    xfree((ptr_t) pp);
@


1.23
log
@Instead of using a variable format string to change the field width,
use %*s and just put the width in a variable
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.22 2011/11/06 01:43:50 guenther Exp $	*/
a649 1
    char   *format;
@


1.22
log
@union wait is dead, ancient history; stop using it

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.21 2009/10/27 23:59:21 deraadt Exp $	*/
d692 1
d694 1
a694 3
		    format = "%-23s";
		else
		    format = "%s";
d697 1
a697 1
			(void) fprintf(cshout, format, "");
d710 1
a710 1
		    (void) fprintf(cshout, format, "Running ");
d727 1
a727 1
			(void) fprintf(cshout, format,
d740 1
a740 1
			    (void) fprintf(cshout, format, "Done");
@


1.21
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.20 2003/09/19 03:18:52 millert Exp $	*/
d78 1
a78 1
    union wait w;
d84 1
a84 1
    pid = wait3(&w.w_status,
d106 1
a106 1
	pp->p_reason = w.w_stopsig;
d114 1
a114 1
	    if (w.w_termsig == SIGINT)
d118 1
a118 1
	    if (w.w_coredump)
d120 1
a120 1
	    pp->p_reason = w.w_termsig;
d123 1
a123 1
	    pp->p_reason = w.w_retcode;
@


1.20
log
@When sanity checking signal numbers, error out on signal >= NSIG,
not > NSIG.  This makes cvs give a nice error message for "kill
-NSIG 666" instead of EINVAL.  From aaron@@monkey.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.19 2003/06/11 21:09:50 deraadt Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)proc.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: proc.c,v 1.19 2003/06/11 21:09:50 deraadt Exp $";
#endif
#endif /* not lint */
@


1.19
log
@de-register and ansify functions
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.18 2003/06/02 23:32:07 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.18 2003/06/02 23:32:07 millert Exp $";
d972 1
a972 1
	    if (signum < 0 || signum > NSIG)
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.17 2003/04/07 22:45:59 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.17 2003/04/07 22:45:59 tedu Exp $";
d79 1
a79 2
pchild(notused)
	int notused;
d81 3
a83 3
    register struct process *pp;
    register struct process *fp;
    register int pid;
d200 1
a200 1
pnote()
d202 1
a202 1
    register struct process *pp;
d226 1
a226 1
pwait()
d228 1
a228 1
    register struct process *fp, *pp;
d257 1
a257 2
pjwait(pp)
    register struct process *pp;
d259 1
a259 1
    register struct process *fp;
d351 1
a351 3
dowait(v, t)
    Char **v;
    struct command *t;
d353 1
a353 1
    register struct process *pp;
d376 1
a376 1
pflushall()
d378 1
a378 1
    register struct process *pp;
d391 1
a391 2
pflush(pp)
    register struct process *pp;
d393 2
a394 2
    register struct process *np;
    register int idx;
d424 1
a424 2
pclrcurr(pp)
    register struct process *pp;
d450 1
a450 3
palloc(pid, t)
    int     pid;
    register struct command *t;
d452 1
a452 1
    register struct process *pp;
d515 1
a515 2
padd(t)
    register struct command *t;
d573 1
a573 2
pads(cp)
    Char   *cp;
d575 1
a575 1
    register int i;
d605 1
a605 1
psavejob()
d617 1
a617 1
prestjob()
d629 1
a629 1
pendjob()
d631 1
a631 1
    register struct process *pp, *tp;
d652 1
a652 3
pprint(pp, flag)
    register struct process *pp;
    bool    flag;
d654 1
a654 1
    register int status, reason;
d816 1
a816 2
ptprint(tp)
    register struct process *tp;
d822 1
a822 1
    register struct process *pp = tp;
d840 1
a840 3
dojobs(v, t)
    Char **v;
    struct command *t;
d842 2
a843 2
    register struct process *pp;
    register int flag = NUMBER | NAME | REASON;
d868 1
a868 3
dofg(v, t)
    Char **v;
    struct command *t;
d870 1
a870 1
    register struct process *pp;
d886 1
a886 3
dofg1(v, t)
    Char **v;
    struct command *t;
d888 1
a888 1
    register struct process *pp;
d901 1
a901 3
dobg(v, t)
    Char **v;
    struct command *t;
d903 1
a903 1
    register struct process *pp;
d918 1
a918 3
dobg1(v, t)
    Char **v;
    struct command *t;
d920 1
a920 1
    register struct process *pp;
d931 1
a931 3
dostop(v, t)
    Char **v;
    struct command *t;
d941 1
a941 3
dokill(v, t)
    Char **v;
    struct command *t;
d943 2
a944 2
    register int signum = SIGTERM;
    register char *name;
d1009 1
a1009 3
pkill(v, signum)
    Char  **v;
    int     signum;
d1011 2
a1012 2
    register struct process *pp, *np;
    register int jobflags = 0;
d1102 1
a1102 3
pstart(pp, foregnd)
    register struct process *pp;
    int     foregnd;
d1104 1
a1104 1
    register struct process *np;
d1134 1
a1134 2
panystop(neednl)
    bool    neednl;
d1136 1
a1136 1
    register struct process *pp;
d1145 1
a1145 2
pfind(cp)
    Char   *cp;
d1147 1
a1147 1
    register struct process *pp, *np;
d1171 1
a1171 1
		register Char *dp;
d1199 1
a1199 2
pgetcurr(pp)
    register struct process *pp;
d1201 2
a1202 2
    register struct process *np;
    register struct process *xp = NULL;
d1220 1
a1220 3
donotify(v, t)
    Char **v;
    struct command *t;
d1222 1
a1222 1
    register struct process *pp;
d1241 1
a1241 3
pfork(t, wanttty)
    struct command *t;		/* command we are forking for */
    int     wanttty;
d1243 1
a1243 1
    register int pid;
d1325 1
a1325 1
okpcntl()
d1342 1
a1342 2
pgetty(wanttty, pgrp)
    int     wanttty, pgrp;
@


1.17
log
@Strlcpy improvements.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.16 2003/01/08 06:54:16 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.16 2003/01/08 06:54:16 deraadt Exp $";
@


1.16
log
@bring in strlcpy and strlcat-like things for dealing with Char types,
this fixes at least 15 buffer overflows; some help from dhartmei.
Anyone want to go do the same in ksh, and help with some of the while
(*s++ = *p++) loops in here?
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.15 2002/02/19 19:39:35 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.15 2002/02/19 19:39:35 millert Exp $";
d603 1
a603 1
	(void) Strlcpy(cmdp, STRsp3dots, PMAXLEN - i);	/* XXX? */
d608 1
a608 1
    (void) Strlcpy(cmdp, cp, PMAXLEN);
@


1.15
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.14 2002/02/16 21:27:06 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.14 2002/02/16 21:27:06 millert Exp $";
d603 1
a603 1
	(void) Strcpy(cmdp, STRsp3dots);
d608 1
a608 1
    (void) Strcpy(cmdp, cp);
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.13 2001/12/01 19:10:39 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.13 2001/12/01 19:10:39 deraadt Exp $";
d51 1
a51 5
#ifdef __STDC__
# include <stdarg.h>
#else
# include <varargs.h>
#endif
@


1.13
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.12 2000/06/28 19:41:10 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.12 2000/06/28 19:41:10 millert Exp $";
d66 8
a73 8
static void	 pflushall __P((void));
static void	 pflush __P((struct process *));
static void	 pclrcurr __P((struct process *));
static void	 padd __P((struct command *));
static int	 pprint __P((struct process *, int));
static void	 ptprint __P((struct process *));
static void	 pads __P((Char *));
static void	 pkill __P((Char **v, int));
d75 2
a76 2
		*pgetcurr __P((struct process *));
static void	 okpcntl __P((void));
@


1.12
log
@Use strtol(), not atoi() when converting a decimal string to an integer.
That way we can catch typos when people say 'kill -HUP 65Q' and not send
the signal to process 65.  Theo and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.11 1998/12/21 05:53:26 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.11 1998/12/21 05:53:26 deraadt Exp $";
d674 1
a674 1
    register status, reason;
@


1.11
log
@correct built-in kill
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.10 1998/12/21 05:44:32 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.10 1998/12/21 05:44:32 deraadt Exp $";
d1108 9
a1116 1
	    pid = atoi(short2str(cp));
@


1.10
log
@like kill(1), have csh builtin handle -SIGxxx names; kleink
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.9 1998/05/17 19:13:44 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.9 1998/05/17 19:13:44 deraadt Exp $";
d1025 1
a1025 1
		    (!strncasecmp("SIG", name, 3) &&    /* skip "SIG" prefix */
@


1.9
log
@do not advance pointer that free() will happen to
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.8 1998/05/13 06:50:14 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.8 1998/05/13 06:50:14 deraadt Exp $";
d1024 4
a1027 2
		if (!strcasecmp(sys_signame[signum], name))
		    break;
@


1.8
log
@support POSIX "kill [-s signame] pid" syntax, fix the "kill -l [exitstatus]"
syntax, sync documentation, no longer permit of full signal names in the
"kill [-sig] pid" syntax, e.g. -SIGHUP; kleink
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.7 1997/09/22 05:09:15 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.7 1997/09/22 05:09:15 millert Exp $";
d1011 1
a1011 1
	    if (v[0][1] == 's' && (Isspace(v[0][2]) || v[0][2] == '\0'))
d1013 4
a1016 2
	    else
		(*v)++;
a1022 1
	    name = short2str(&v[0][0]);
d1028 1
a1028 1
		if (v[0][0] == '0')
@


1.7
log
@err.[ch] -> error.[ch] and fix err/warn usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.6 1997/08/04 19:24:02 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.6 1997/08/04 19:24:02 deraadt Exp $";
d984 17
a1000 4
	    for (signum = 1; signum < NSIG; signum++) {
		(void) fprintf(cshout, "%s ", sys_signame[signum]);
		if (signum == NSIG / 2)
		    (void) fputc('\n', cshout);
d1011 9
a1019 3
	    name = short2str(&v[0][1]);
	    if (!strncasecmp(name, "sig", 3))
		name += 3;
d1021 1
d1027 6
a1032 2
		setname(vis_str(&v[0][1]));
		stderror(ERR_NAME | ERR_UNKSIG);
@


1.6
log
@save errno in sigchld handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.5 1997/07/25 18:58:15 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.5 1997/07/25 18:58:15 mickey Exp $";
a55 1
#include <err.h>
@


1.5
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.4 1997/07/23 14:36:51 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.4 1997/07/23 14:36:51 kstailey Exp $";
d95 1
d111 1
@


1.4
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.3 1996/12/14 12:17:42 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.3 1996/12/14 12:17:42 mickey Exp $";
d51 1
a51 1
#if __STDC__
@


1.3
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.2 1996/06/23 14:19:28 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.2 1996/06/23 14:19:28 deraadt Exp $";
d745 10
a754 10
                    /*
                     * tell what happened to the background job
                     * From: Michael Schroeder
                     * <mlschroe@@immd4.informatik.uni-erlangen.de>
                     */
                    if ((flag & REASON)
                        || ((flag & AREASON)
                            && reason != SIGINT
                            && (reason != SIGPIPE
                                || (pp->p_flags & PPOU) == 0))) {
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.9 1995/04/29 23:21:33 mycroft Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: proc.c,v 1.9 1995/04/29 23:21:33 mycroft Exp $";
d56 1
d1194 1
a1194 1
    stderror(ERR_NAME | cp[1] == '?' ? ERR_JOBPAT : ERR_NOSUCHJOB);
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: proc.c,v 1.9 1995/04/29 23:21:33 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
