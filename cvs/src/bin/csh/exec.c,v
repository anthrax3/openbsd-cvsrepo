head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.6
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.8
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.15.0.22
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.20
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.22
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.18
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.16
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.14
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.12
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.10
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.8
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.7.0.14
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.12
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.10
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.8
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.12.26.13.48.38;	author mestre;	state Exp;
branches;
next	1.18;
commitid	jZMsEASvreUUSdqp;

1.18
date	2015.10.28.22.18.53;	author naddy;	state Exp;
branches;
next	1.17;
commitid	foGVltwqKPeRCaEM;

1.17
date	2015.02.08.05.51.37;	author tedu;	state Exp;
branches;
next	1.16;
commitid	L3WalZJ5Trtg0ORm;

1.16
date	2015.01.16.06.39.31;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	Uu5nFG3wCl0LACBb;

1.15
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.25.16.07.10;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.11.21.09.50;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.23.32.07;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.08.06.54.16;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.05.18.20.38.19;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.11.15.22.01.06;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	97.11.15.21.51.29;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	97.07.25.18.58.04;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.11.02.01.00.31;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.20;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Replace handrolled xfree() function by directly using free(3)

OK mmcc@@
@
text
@/*	$OpenBSD: exec.c,v 1.18 2015/10/28 22:18:53 naddy Exp $	*/
/*	$NetBSD: exec.c,v 1.9 1996/09/30 20:03:54 christos Exp $	*/

/*-
 * Copyright (c) 1980, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <dirent.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <stdarg.h>

#include "csh.h"
#include "extern.h"

/*
 * System level search and execute of a command.  We look in each directory
 * for the specified command name.  If the name contains a '/' then we
 * execute only the full path name.  If there is no search path then we
 * execute only full path names.
 */
extern char **environ;

/*
 * As we search for the command we note the first non-trivial error
 * message for presentation to the user.  This allows us often
 * to show that a file has the wrong mode/no access when the file
 * is not in the last component of the search path, so we must
 * go on after first detecting the error.
 */
static char *exerr;		/* Execution error message */
static Char *expath;		/* Path for exerr */

/*
 * Xhash is an array of HSHSIZ bits (HSHSIZ / 8 chars), which are used
 * to hash execs.  If it is allocated (havhash true), then to tell
 * whether ``name'' is (possibly) present in the i'th component
 * of the variable path, you look at the bit in xhash indexed by
 * hash(hashname("name"), i).  This is setup automatically
 * after .login is executed, and recomputed whenever ``path'' is
 * changed.
 * The two part hash function is designed to let texec() call the
 * more expensive hashname() only once and the simple hash() several
 * times (once for each path component checked).
 * Byte size is assumed to be 8.
 */
#define	HSHSIZ		8192	/* 1k bytes */
#define HSHMASK		(HSHSIZ - 1)
#define HSHMUL		243
static char xhash[HSHSIZ / 8];

#define hash(a, b)	(((a) * HSHMUL + (b)) & HSHMASK)
#define bit(h, b)	((h)[(b) >> 3] & 1 << ((b) & 7))	/* bit test */
#define bis(h, b)	((h)[(b) >> 3] |= 1 << ((b) & 7))	/* bit set */
static int hits, misses;

/* Dummy search path for just absolute search when no path */
static Char *justabs[] = {STRNULL, 0};

static void	pexerr(void);
static void	texec(Char *, Char **);
static int	hashname(Char *);
static int	tellmewhat(struct wordent *, Char *, int len);
static int	executable(Char *, Char *, bool);
static int	iscommand(Char *);


void
/*ARGSUSED*/
doexec(Char **v, struct command *t)
{
    Char *dp, **pv, **av, *sav;
    struct varent *pathv;
    bool slash;
    int hashval = 0, hashval1, i;
    Char   *blk[2];
    sigset_t sigset;

    /*
     * Glob the command name. We will search $path even if this does something,
     * as in sh but not in csh.  One special case: if there is no PATH, then we
     * execute only commands which start with '/'.
     */
    blk[0] = t->t_dcom[0];
    blk[1] = 0;
    gflag = 0, tglob(blk);
    if (gflag) {
	pv = globall(blk);
	if (pv == 0) {
	    setname(vis_str(blk[0]));
	    stderror(ERR_NAME | ERR_NOMATCH);
	}
	gargv = 0;
    }
    else
	pv = saveblk(blk);

    trim(pv);

    exerr = 0;
    expath = Strsave(pv[0]);
    Vexpath = expath;

    pathv = adrof(STRpath);
    if (pathv == 0 && expath[0] != '/') {
	blkfree(pv);
	pexerr();
    }
    slash = any(short2str(expath), '/');

    /*
     * Glob the argument list, if necessary. Otherwise trim off the quote bits.
     */
    gflag = 0;
    av = &t->t_dcom[1];
    tglob(av);
    if (gflag) {
	av = globall(av);
	if (av == 0) {
	    blkfree(pv);
	    setname(vis_str(expath));
	    stderror(ERR_NAME | ERR_NOMATCH);
	}
	gargv = 0;
    }
    else
	av = saveblk(av);

    blkfree(t->t_dcom);
    t->t_dcom = blkspl(pv, av);
    free(pv);
    free(av);
    av = t->t_dcom;
    trim(av);

    if (*av == NULL || **av == '\0')
	pexerr();

    xechoit(av);		/* Echo command if -x */
    /*
     * Since all internal file descriptors are set to close on exec, we don't
     * need to close them explicitly here.  Just reorient ourselves for error
     * messages.
     */
    SHIN = 0;
    SHOUT = 1;
    SHERR = 2;
    OLDSTD = 0;
    /*
     * We must do this AFTER any possible forking (like `foo` in glob) so that
     * this shell can still do subprocesses.
     */
    sigemptyset(&sigset);
    sigprocmask(SIG_SETMASK, &sigset, NULL);
    /*
     * If no path, no words in path, or a / in the filename then restrict the
     * command search.
     */
    if (pathv == 0 || pathv->vec[0] == 0 || slash)
	pv = justabs;
    else
	pv = pathv->vec;
    sav = Strspl(STRslash, *av);/* / command name for postpending */
    Vsav = sav;
    if (havhash)
	hashval = hashname(*av);
    i = 0;
    hits++;
    do {
	/*
	 * Try to save time by looking at the hash table for where this command
	 * could be.  If we are doing delayed hashing, then we put the names in
	 * one at a time, as the user enters them.  This is kinda like Korn
	 * Shell's "tracked aliases".
	 */
	if (!slash && pv[0][0] == '/' && havhash) {
	    hashval1 = hash(hashval, i);
	    if (!bit(xhash, hashval1))
		goto cont;
	}
	if (pv[0][0] == 0 || eq(pv[0], STRdot))	/* don't make ./xxx */
	    texec(*av, av);
	else {
	    dp = Strspl(*pv, sav);
	    Vdp = dp;
	    texec(dp, av);
	    Vdp = 0;
	    free(dp);
	}
	misses++;
cont:
	pv++;
	i++;
    } while (*pv);
    hits--;
    Vsav = 0;
    free(sav);
    pexerr();
}

static void
pexerr(void)
{
    /* Couldn't find the damn thing */
    if (expath) {
	setname(vis_str(expath));
	Vexpath = 0;
	free(expath);
	expath = 0;
    }
    else
	setname("");
    if (exerr)
	stderror(ERR_NAME | ERR_STRING, exerr);
    stderror(ERR_NAME | ERR_COMMAND);
}

/*
 * Execute command f, arg list t.
 * Record error message if not found.
 * Also do shell scripts here.
 */
static void
texec(Char *sf, Char **st)
{
    char **t;
    char *f;
    struct varent *v;
    Char **vp;
    Char   *lastsh[2];
    int     fd;
    unsigned char c;
    Char   *st0, **ost;

    /* The order for the conversions is significant */
    t = short2blk(st);
    f = short2str(sf);
    Vt = t;
    errno = 0;			/* don't use a previous error */
    (void) execve(f, t, environ);
    Vt = 0;
    blkfree((Char **) t);
    switch (errno) {

    case ENOEXEC:
	/*
	 * From: casper@@fwi.uva.nl (Casper H.S. Dik) If we could not execute
	 * it, don't feed it to the shell if it looks like a binary!
	 */
	if ((fd = open(f, O_RDONLY)) != -1) {
	    if (read(fd, (char *) &c, 1) == 1) {
		if (!Isprint(c) && (c != '\n' && c != '\t')) {
		    (void) close(fd);
		    /*
		     * We *know* what ENOEXEC means.
		     */
		    stderror(ERR_ARCH, f, strerror(errno));
		}
	    }
	    else
		c = '#';
	    (void) close(fd);
	}
	/*
	 * If there is an alias for shell, then put the words of the alias in
	 * front of the argument list replacing the command name. Note no
	 * interpretation of the words at this point.
	 */
	v = adrof1(STRshell, &aliases);
	if (v == 0) {
	    vp = lastsh;
	    vp[0] = adrof(STRshell) ? value(STRshell) : STR_SHELLPATH;
	    vp[1] = NULL;
	    if (fd != -1 && c != '#')
		vp[0] = STR_BSHELL;
	}
	else
	    vp = v->vec;
	st0 = st[0];
	st[0] = sf;
	ost = st;
	st = blkspl(vp, st);	/* Splice up the new arglst */
	ost[0] = st0;
	sf = *st;
	/* The order for the conversions is significant */
	t = short2blk(st);
	f = short2str(sf);
	free(st);
	Vt = t;
	(void) execve(f, t, environ);
	Vt = 0;
	blkfree((Char **) t);
	/* The sky is falling, the sky is falling! */

    case ENOMEM:
	stderror(ERR_SYSTEM, f, strerror(errno));

    case ENOENT:
	break;

    default:
	if (exerr == 0) {
	    exerr = strerror(errno);
	    if (expath)
		free(expath);
	    expath = Strsave(sf);
	    Vexpath = expath;
	}
    }
}

/*ARGSUSED*/
void
execash(Char **t, struct command *kp)
{
    int     saveIN, saveOUT, saveDIAG, saveSTD;
    int     oSHIN;
    int     oSHOUT;
    int     oSHERR;
    int     oOLDSTD;
    jmp_buf osetexit;
    int	    my_reenter;
    int     odidfds;
    sig_t   osigint, osigquit, osigterm;

    if (chkstop == 0 && setintr)
	panystop(0);
    /*
     * Hmm, we don't really want to do that now because we might
     * fail, but what is the choice
     */
    rechist();

    osigint  = signal(SIGINT, parintr);
    osigquit = signal(SIGQUIT, parintr);
    osigterm = signal(SIGTERM, parterm);

    odidfds = didfds;
    oSHIN = SHIN;
    oSHOUT = SHOUT;
    oSHERR = SHERR;
    oOLDSTD = OLDSTD;

    saveIN = dcopy(SHIN, -1);
    saveOUT = dcopy(SHOUT, -1);
    saveDIAG = dcopy(SHERR, -1);
    saveSTD = dcopy(OLDSTD, -1);

    lshift(kp->t_dcom, 1);

    getexit(osetexit);

    if ((my_reenter = setexit()) == 0) {
	SHIN = dcopy(0, -1);
	SHOUT = dcopy(1, -1);
	SHERR = dcopy(2, -1);
	didfds = 0;
	doexec(t, kp);
    }

    (void) signal(SIGINT, osigint);
    (void) signal(SIGQUIT, osigquit);
    (void) signal(SIGTERM, osigterm);

    doneinp = 0;
    didfds = odidfds;
    (void) close(SHIN);
    (void) close(SHOUT);
    (void) close(SHERR);
    (void) close(OLDSTD);
    SHIN = dmove(saveIN, oSHIN);
    SHOUT = dmove(saveOUT, oSHOUT);
    SHERR = dmove(saveDIAG, oSHERR);
    OLDSTD = dmove(saveSTD, oOLDSTD);

    resexit(osetexit);
    if (my_reenter)
	stderror(ERR_SILENT);
}

void
xechoit(Char **t)
{
    if (adrof(STRecho)) {
	(void) fflush(csherr);
	blkpr(csherr, t);
	(void) fputc('\n', csherr);
    }
}

void
/*ARGSUSED*/
dohash(Char **v, struct command *t)
{
    DIR    *dirp;
    struct dirent *dp;
    int cnt;
    int     i = 0;
    struct varent *pathv = adrof(STRpath);
    Char  **pv;
    int     hashval;

    havhash = 1;
    for (cnt = 0; cnt < sizeof xhash; cnt++)
	xhash[cnt] = 0;
    if (pathv == 0)
	return;
    for (pv = pathv->vec; *pv; pv++, i++) {
	if (pv[0][0] != '/')
	    continue;
	dirp = opendir(short2str(*pv));
	if (dirp == NULL)
	    continue;
	while ((dp = readdir(dirp)) != NULL) {
	    if (dp->d_ino == 0)
		continue;
	    if (dp->d_name[0] == '.' &&
		(dp->d_name[1] == '\0' ||
		 (dp->d_name[1] == '.' && dp->d_name[2] == '\0')))
		continue;
	    hashval = hash(hashname(str2short(dp->d_name)), i);
	    bis(xhash, hashval);
	    /* tw_add_comm_name (dp->d_name); */
	}
	(void) closedir(dirp);
    }
}

void
/*ARGSUSED*/
dounhash(Char **v, struct command *t)
{
    havhash = 0;
}

void
/*ARGSUSED*/
hashstat(Char **v, struct command *t)
{
    if (hits + misses)
	(void) fprintf(cshout, "%d hits, %d misses, %d%%\n",
		       hits, misses, 100 * hits / (hits + misses));
}

/*
 * Hash a command name.
 */
static int
hashname(Char *cp)
{
    long h = 0;

    while (*cp)
	h = hash(h, *cp++);
    return ((int) h);
}

static int
iscommand(Char *name)
{
    Char **pv;
    Char *sav;
    struct varent *v;
    bool slash = any(short2str(name), '/');
    int hashval = 0, hashval1, i;

    v = adrof(STRpath);
    if (v == 0 || v->vec[0] == 0 || slash)
	pv = justabs;
    else
	pv = v->vec;
    sav = Strspl(STRslash, name);	/* / command name for postpending */
    if (havhash)
	hashval = hashname(name);
    i = 0;
    do {
	if (!slash && pv[0][0] == '/' && havhash) {
	    hashval1 = hash(hashval, i);
	    if (!bit(xhash, hashval1))
		goto cont;
	}
	if (pv[0][0] == 0 || eq(pv[0], STRdot)) {	/* don't make ./xxx */
	    if (executable(NULL, name, 0)) {
		free(sav);
		return i + 1;
	    }
	}
	else {
	    if (executable(*pv, sav, 0)) {
		free(sav);
		return i + 1;
	    }
	}
cont:
	pv++;
	i++;
    } while (*pv);
    free(sav);
    return 0;
}

/* Also by:
 *  Andreas Luik <luik@@isaak.isa.de>
 *  I S A  GmbH - Informationssysteme fuer computerintegrierte Automatisierung
 *  Azenberstr. 35
 *  D-7000 Stuttgart 1
 *  West-Germany
 * is the executable() routine below and changes to iscommand().
 * Thanks again!!
 */

/*
 * executable() examines the pathname obtained by concatenating dir and name
 * (dir may be NULL), and returns 1 either if it is executable by us, or
 * if dir_ok is set and the pathname refers to a directory.
 * This is a bit kludgy, but in the name of optimization...
 */
static int
executable(Char *dir, Char *name, bool dir_ok)
{
    struct stat stbuf;
    Char    path[PATH_MAX], *dp, *sp;
    char   *strname;

    if (dir && *dir) {
	for (dp = path, sp = dir; *sp; *dp++ = *sp++)
	    if (dp == &path[PATH_MAX]) {
		*--dp = '\0';
		break;
	    }
	for (sp = name; *sp; *dp++ = *sp++)
	    if (dp == &path[PATH_MAX]) {
		*--dp = '\0';
		break;
	    }
	*dp = '\0';
	strname = short2str(path);
    }
    else
	strname = short2str(name);
    return (stat(strname, &stbuf) != -1 &&
	    ((S_ISREG(stbuf.st_mode) &&
    /* save time by not calling access() in the hopeless case */
	      (stbuf.st_mode & (S_IXOTH | S_IXGRP | S_IXUSR)) &&
	      access(strname, X_OK) == 0) ||
	     (dir_ok && S_ISDIR(stbuf.st_mode))));
}

/* The dowhich() is by:
 *  Andreas Luik <luik@@isaak.isa.de>
 *  I S A  GmbH - Informationssysteme fuer computerintegrierte Automatisierung
 *  Azenberstr. 35
 *  D-7000 Stuttgart 1
 *  West-Germany
 * Thanks!!
 */
/*ARGSUSED*/
void
dowhich(Char **v, struct command *c)
{
    struct wordent lex[3];
    struct varent *vp;

    lex[0].next = &lex[1];
    lex[1].next = &lex[2];
    lex[2].next = &lex[0];

    lex[0].prev = &lex[2];
    lex[1].prev = &lex[0];
    lex[2].prev = &lex[1];

    lex[0].word = STRNULL;
    lex[2].word = STRret;

    while (*++v) {
	if ((vp = adrof1(*v, &aliases)) != NULL) {
	    (void) fprintf(cshout, "%s: \t aliased to ", vis_str(*v));
	    blkpr(cshout, vp->vec);
	    (void) fputc('\n', cshout);
	    set(STRstatus, Strsave(STR0));
	}
	else {
	    lex[1].word = *v;
	    set(STRstatus, Strsave(tellmewhat(lex, NULL, 0) ? STR0 : STR1));
	}
    }
}

static int
tellmewhat(struct wordent *lexp, Char *str, int len)
{
    int i;
    struct biltins *bptr;
    struct wordent *sp = lexp->next;
    bool    aliased = 0, found;
    Char   *s0, *s1, *s2, *cmd;
    Char    qc;

    if (adrof1(sp->word, &aliases)) {
	alias(lexp);
	sp = lexp->next;
	aliased = 1;
    }

    s0 = sp->word;		/* to get the memory freeing right... */

    /* handle quoted alias hack */
    if ((*(sp->word) & (QUOTE | TRIM)) == QUOTE)
	(sp->word)++;

    /* do quoting, if it hasn't been done */
    s1 = s2 = sp->word;
    while (*s2)
	switch (*s2) {
	case '\'':
	case '"':
	    qc = *s2++;
	    while (*s2 && *s2 != qc)
		*s1++ = *s2++ | QUOTE;
	    if (*s2)
		s2++;
	    break;
	case '\\':
	    if (*++s2)
		*s1++ = *s2++ | QUOTE;
	    break;
	default:
	    *s1++ = *s2++;
	}
    *s1 = '\0';

    for (bptr = bfunc; bptr < &bfunc[nbfunc]; bptr++) {
	if (eq(sp->word, str2short(bptr->bname))) {
	    if (str == NULL) {
	        if (aliased)
		        prlex(cshout, lexp);
	        (void) fprintf(cshout, "%s: shell built-in command.\n",
			   vis_str(sp->word));
	    }
	    else
		(void) Strlcpy(str, sp->word, len/sizeof(Char));
	    sp->word = s0;	/* we save and then restore this */
	    return 1;
	}
    }

    sp->word = cmd = globone(sp->word, G_IGNORE);

    if ((i = iscommand(sp->word)) != 0) {
	Char **pv;
	struct varent *v;
	bool    slash = any(short2str(sp->word), '/');

	v = adrof(STRpath);
	if (v == 0 || v->vec[0] == 0 || slash)
	    pv = justabs;
	else
	    pv = v->vec;

	while (--i)
	    pv++;
	if (pv[0][0] == 0 || eq(pv[0], STRdot)) {
	    if (!slash) {
		sp->word = Strspl(STRdotsl, sp->word);
		prlex(cshout, lexp);
		free(sp->word);
	    }
	    else
		prlex(cshout, lexp);
	}
	else {
	    s1 = Strspl(*pv, STRslash);
	    sp->word = Strspl(s1, sp->word);
	    free(s1);
	    if (str == NULL)
		prlex(cshout, lexp);
	    else
		(void) Strlcpy(str, sp->word, len/sizeof(Char));
	    free(sp->word);
        }
	found = 1;
    }
    else {
	if (str == NULL) {
	    if (aliased)
		prlex(cshout, lexp);
	    (void) fprintf(csherr,
			   "%s: Command not found.\n", vis_str(sp->word));
	}
	else
	    (void) Strlcpy(str, sp->word, len/sizeof(Char));
	found = 0;
    }
    sp->word = s0;		/* we save and then restore this */
    free(cmd);
    return found;
}
@


1.18
log
@unifdef _PATH_*
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.17 2015/02/08 05:51:37 tedu Exp $	*/
d162 2
a163 2
    xfree(pv);
    xfree(av);
d219 1
a219 1
	    xfree(dp);
d228 1
a228 1
    xfree(sav);
d239 1
a239 1
	xfree(expath);
d319 1
a319 1
	xfree(st);
d336 1
a336 1
		xfree(expath);
d515 1
a515 1
		xfree(sav);
d521 1
a521 1
		xfree(sav);
d529 1
a529 1
    xfree(sav);
d697 1
a697 1
		xfree(sp->word);
d705 1
a705 1
	    xfree(s1);
d710 1
a710 1
	    xfree(sp->word);
d726 1
a726 1
    xfree(cmd);
@


1.17
log
@delete many more ptr_t casts
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.16 2015/01/16 06:39:31 deraadt Exp $	*/
a290 1
#ifdef _PATH_BSHELL
a292 1
#endif
a304 1
#ifdef _PATH_BSHELL
a306 1
#endif
@


1.16
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.15 2009/10/27 23:59:21 deraadt Exp $	*/
d162 2
a163 2
    xfree((ptr_t) pv);
    xfree((ptr_t) av);
d219 1
a219 1
	    xfree((ptr_t) dp);
d228 1
a228 1
    xfree((ptr_t) sav);
d239 1
a239 1
	xfree((ptr_t) expath);
d323 1
a323 1
	xfree((ptr_t) st);
d340 1
a340 1
		xfree((ptr_t) expath);
d519 1
a519 1
		xfree((ptr_t) sav);
d525 1
a525 1
		xfree((ptr_t) sav);
d533 1
a533 1
    xfree((ptr_t) sav);
d701 1
a701 1
		xfree((ptr_t) sp->word);
d709 1
a709 1
	    xfree((ptr_t) s1);
d714 1
a714 1
	    xfree((ptr_t) sp->word);
d730 1
a730 1
    xfree((ptr_t) cmd);
@


1.15
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.14 2005/02/25 16:07:10 deraadt Exp $	*/
a33 1
#include <sys/param.h>
d41 1
d557 1
a557 1
    Char    path[MAXPATHLEN], *dp, *sp;
d562 1
a562 1
	    if (dp == &path[MAXPATHLEN]) {
d567 1
a567 1
	    if (dp == &path[MAXPATHLEN]) {
@


1.14
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.13 2003/06/11 21:09:50 deraadt Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)exec.c	8.3 (Berkeley) 5/23/95";
#else
static char rcsid[] = "$OpenBSD: exec.c,v 1.13 2003/06/11 21:09:50 deraadt Exp $";
#endif
#endif /* not lint */
@


1.13
log
@de-register and ansify functions
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.12 2003/06/02 23:32:07 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.12 2003/06/02 23:32:07 millert Exp $";
d102 1
a102 1
static int 	tellmewhat(struct wordent *, Char *, int len);
d727 1
a727 1
 	if (str == NULL) {
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.11 2003/01/08 06:54:16 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.11 2003/01/08 06:54:16 deraadt Exp $";
d109 6
a114 8
doexec(v, t)
    Char **v;
    struct command *t;
{
    register Char *dp, **pv, **av, *sav;
    register struct varent *pathv;
    register bool slash;
    register int hashval = 0, hashval1, i;
d241 1
a241 1
pexerr()
d263 6
a268 8
texec(sf, st)
    Char   *sf;
    register Char **st;
{
    register char **t;
    register char *f;
    register struct varent *v;
    register Char **vp;
d357 1
a357 3
execash(t, kp)
    Char  **t;
    register struct command *kp;
d425 1
a425 2
xechoit(t)
    Char  **t;
d436 1
a436 3
dohash(v, t)
    Char **v;
    struct command *t;
d439 2
a440 2
    register struct dirent *dp;
    register int cnt;
d474 1
a474 3
dounhash(v, t)
    Char **v;
    struct command *t;
d481 1
a481 3
hashstat(v, t)
    Char **v;
    struct command *t;
d492 1
a492 2
hashname(cp)
    register Char *cp;
d494 1
a494 1
    register long h = 0;
d502 1
a502 2
iscommand(name)
    Char   *name;
d504 5
a508 5
    register Char **pv;
    register Char *sav;
    register struct varent *v;
    register bool slash = any(short2str(name), '/');
    register int hashval = 0, hashval1, i;
d562 1
a562 3
executable(dir, name, dir_ok)
    Char   *dir, *name;
    bool    dir_ok;
d602 1
a602 3
dowhich(v, c)
    register Char **v;
    struct command *c;
d633 5
a637 8
tellmewhat(lexp, str, len)
    struct wordent *lexp;
    Char *str;
    int len;
{
    register int i;
    register struct biltins *bptr;
    register struct wordent *sp = lexp->next;
d693 2
a694 2
	register Char **pv;
	register struct varent *v;
@


1.11
log
@bring in strlcpy and strlcat-like things for dealing with Char types,
this fixes at least 15 buffer overflows; some help from dhartmei.
Anyone want to go do the same in ksh, and help with some of the while
(*s++ = *p++) loops in here?
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.10 2002/06/09 05:47:27 todd Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.10 2002/06/09 05:47:27 todd Exp $";
@


1.10
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.9 2002/02/19 19:39:35 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.9 2002/02/19 19:39:35 millert Exp $";
d106 1
a106 1
static int 	tellmewhat(struct wordent *, Char *);
d650 1
a650 1
	    set(STRstatus, Strsave(tellmewhat(lex, NULL) ? STR0 : STR1));
d656 1
a656 1
tellmewhat(lexp, str)
d659 1
d704 3
a706 3
	    if (aliased)
		    prlex(cshout, lexp);
	    (void) fprintf(cshout, "%s: shell built-in command.\n",
d710 1
a710 1
		(void) Strcpy(str, sp->word);
d741 3
a743 3
	s1 = Strspl(*pv, STRslash);
	sp->word = Strspl(s1, sp->word);
	xfree((ptr_t) s1);
d747 3
a749 3
		(void) Strcpy(str, sp->word);
	xfree((ptr_t) sp->word);
    }
d754 1
a754 1
	if (aliased)
d760 1
a760 1
	    (void) Strcpy(str, sp->word);
@


1.9
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.8 2002/02/16 21:27:06 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.8 2002/02/16 21:27:06 millert Exp $";
d705 1
a705 1
	    (void) fprintf(cshout, "%s: shell built-in command.\n", 
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.7 1998/05/18 20:38:19 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.7 1998/05/18 20:38:19 deraadt Exp $";
d54 1
a54 5
#ifdef __STDC__
# include <stdarg.h>
#else
# include <varargs.h>
#endif 
@


1.7
log
@MAXPATHLEN not MAXPATHLEN+1
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.6 1997/11/15 22:01:06 todd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.6 1997/11/15 22:01:06 todd Exp $";
d107 6
a112 6
static void	pexerr __P((void));
static void	texec __P((Char *, Char **));
static int	hashname __P((Char *));
static int 	tellmewhat __P((struct wordent *, Char *));
static int	executable __P((Char *, Char *, bool));
static int	iscommand __P((Char *));
@


1.6
log
@slipped through the cracks.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.5 1997/11/15 21:51:29 todd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.5 1997/11/15 21:51:29 todd Exp $";
d590 1
a590 1
    Char    path[MAXPATHLEN + 1], *dp, *sp;
d595 1
a595 1
	    if (dp == &path[MAXPATHLEN + 1]) {
d600 1
a600 1
	    if (dp == &path[MAXPATHLEN + 1]) {
@


1.5
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.4 1997/07/25 18:58:04 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.4 1997/07/25 18:58:04 mickey Exp $";
d582 1
a582 1
 * This is a bit kludgey, but in the name of optimization...
@


1.4
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.3 1996/11/02 01:00:31 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.3 1996/11/02 01:00:31 millert Exp $";
d582 1
a582 1
 * This is a bit kludgy, but in the name of optimization...
@


1.3
log
@Update from NetBSD (christos)
Quote all imported environment variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.2 1996/06/23 14:19:20 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.2 1996/06/23 14:19:20 deraadt Exp $";
d54 1
a54 1
#if __STDC__
@


1.2
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: exec.c,v 1.8 1995/05/23 19:47:16 christos Exp $	*/
/*	$NetBSD: exec.c,v 1.8 1995/05/23 19:47:16 christos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.8 1995/05/23 19:47:16 christos Exp $";
d110 1
a110 1
static void 	tellmewhat __P((struct wordent *));
d650 1
d654 1
a654 1
	    tellmewhat(lex);
d659 4
a662 3
static void
tellmewhat(lex)
    struct wordent *lex;
d666 2
a667 2
    register struct wordent *sp = lex->next;
    bool    aliased = 0;
d672 2
a673 2
	alias(lex);
	sp = lex->next;
d706 1
d708 1
a708 1
		prlex(cshout, lex);
d711 3
d715 1
a715 1
	    return;
d721 1
a721 1
    if ((i = iscommand(strip(sp->word))) != 0) {
d737 1
a737 1
		prlex(cshout, lex);
d741 1
a741 4
		prlex(cshout, lex);
	    sp->word = s0;	/* we save and then restore this */
	    xfree((ptr_t) cmd);
	    return;
d743 1
d747 4
a750 1
	prlex(cshout, lex);
d753 2
d756 1
d758 7
a764 2
	    prlex(cshout, lex);
	(void) fprintf(csherr, "%s: Command not found.\n", vis_str(sp->word));
d768 1
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: exec.c,v 1.8 1995/05/23 19:47:16 christos Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
