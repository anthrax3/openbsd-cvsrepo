head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.6
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.16.0.22
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.20
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.28
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.24
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.22
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.20
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.18
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.16
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.14
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.12
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.10
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.6.0.14
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.12
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.10
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.6
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2015.12.26.13.48.38;	author mestre;	state Exp;
branches;
next	1.22;
commitid	jZMsEASvreUUSdqp;

1.22
date	2015.10.26.15.01.15;	author naddy;	state Exp;
branches;
next	1.21;
commitid	gs7LRmKw8OfepnU6;

1.21
date	2015.06.17.03.48.21;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	oHdhnDXEPqwM6LiV;

1.20
date	2015.06.03.01.49.35;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	G0QoAB2EGeHbSaNz;

1.19
date	2015.02.08.05.47.28;	author tedu;	state Exp;
branches;
next	1.18;
commitid	UHj0KNSjy07xS7rI;

1.18
date	2015.01.16.06.39.31;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Uu5nFG3wCl0LACBb;

1.17
date	2014.10.16.19.43.31;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	jIHreojPTUQy0Zyb;

1.16
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.11.21.09.50;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.32.07;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.08.06.54.16;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.24.19.53.50;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.15.22.10.13;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.01.19.10.39;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.05.18.20.38.20;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.11.15.21.51.29;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	97.07.25.18.58.06;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.12.04.17.46.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.22;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Replace handrolled xfree() function by directly using free(3)

OK mmcc@@
@
text
@/*	$OpenBSD: file.c,v 1.22 2015/10/26 15:01:15 naddy Exp $	*/
/*	$NetBSD: file.c,v 1.11 1996/11/08 19:34:37 christos Exp $	*/

/*-
 * Copyright (c) 1980, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <termios.h>
#include <dirent.h>
#include <pwd.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <stdarg.h>

#include "csh.h"
#include "extern.h"

/*
 * Tenex style file name recognition, .. and more.
 * History:
 *	Author: Ken Greer, Sept. 1975, CMU.
 *	Finally got around to adding to the Cshell., Ken Greer, Dec. 1981.
 */

#define ON	1
#define OFF	0
#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif

#define ESC	'\033'

typedef enum {
    LIST, RECOGNIZE
}       COMMAND;

static void	 setup_tty(int);
static void	 back_to_col_1(void);
static void	 pushback(Char *);
static void	 catn(Char *, Char *, int);
static void	 copyn(Char *, Char *, int);
static Char	 filetype(Char *, Char *);
static void	 print_by_column(Char *, Char *[], int);
static Char	*tilde(Char *, Char *);
static void	 retype(void);
static void	 beep(void);
static void	 print_recognized_stuff(Char *);
static void	 extract_dir_and_name(Char *, Char *, Char *);
static Char	*getentry(DIR *, int);
static void	 free_items(Char **, int);
static int	 tsearch(Char *, COMMAND, int);
static int	 recognize(Char *, Char *, int, int);
static int	 is_prefix(Char *, Char *);
static int	 is_suffix(Char *, Char *);
static int	 ignored(Char *);

/*
 * Put this here so the binary can be patched with adb to enable file
 * completion by default.  Filec controls completion, nobeep controls
 * ringing the terminal bell on incomplete expansions.
 */
bool    filec = 0;

static void
setup_tty(int on)
{
    struct termios tchars;

    (void) tcgetattr(SHIN, &tchars);

    if (on) {
	tchars.c_cc[VEOL] = ESC;
	if (tchars.c_lflag & ICANON)
	    on = TCSADRAIN;
	else {
	    tchars.c_lflag |= ICANON;
	    on = TCSAFLUSH;
	}
    }
    else {
	tchars.c_cc[VEOL] = _POSIX_VDISABLE;
	on = TCSADRAIN;
    }

    (void) tcsetattr(SHIN, on, &tchars);
}

/*
 * Move back to beginning of current line
 */
static void
back_to_col_1(void)
{
    struct termios tty, tty_normal;
    sigset_t sigset, osigset;

    sigemptyset(&sigset);
    sigaddset(&sigset, SIGINT);
    sigprocmask(SIG_BLOCK, &sigset, &osigset);
    (void) tcgetattr(SHOUT, &tty);
    tty_normal = tty;
    tty.c_iflag &= ~INLCR;
    tty.c_oflag &= ~ONLCR;
    (void) tcsetattr(SHOUT, TCSADRAIN, &tty);
    (void) write(SHOUT, "\r", 1);
    (void) tcsetattr(SHOUT, TCSADRAIN, &tty_normal);
    sigprocmask(SIG_SETMASK, &osigset, NULL);
}

/*
 * Push string contents back into tty queue
 */
static void
pushback(Char *string)
{
    Char *p;
    struct termios tty, tty_normal;
    sigset_t sigset, osigset;
    char    c;

    sigemptyset(&sigset);
    sigaddset(&sigset, SIGINT);
    sigprocmask(SIG_BLOCK, &sigset, &osigset);
    (void) tcgetattr(SHOUT, &tty);
    tty_normal = tty;
    tty.c_lflag &= ~(ECHOKE | ECHO | ECHOE | ECHOK | ECHONL | ECHOPRT | ECHOCTL);
    (void) tcsetattr(SHOUT, TCSADRAIN, &tty);

    for (p = string; (c = *p) != '\0'; p++)
	(void) ioctl(SHOUT, TIOCSTI, (ioctl_t) & c);
    (void) tcsetattr(SHOUT, TCSADRAIN, &tty_normal);
    sigprocmask(SIG_SETMASK, &osigset, NULL);
}

/*
 * Concatenate src onto tail of des.
 * Des is a string whose maximum length is count.
 * Always null terminate.
 */
static void
catn(Char *des, Char *src, int count)
{
    while (--count >= 0 && *des)
	des++;
    while (--count >= 0)
	if ((*des++ = *src++) == 0)
	    return;
    *des = '\0';
}

/*
 * Places Char's like strlcpy, but no special return value.
 */
static void
copyn(Char *des, Char *src, int count)
{
    while (--count >= 0)
	if ((*des++ = *src++) == 0)
	    return;
    *des = '\0';
}

static  Char
filetype(Char *dir, Char *file)
{
    Char    path[PATH_MAX];
    struct stat statb;

    Strlcpy(path, dir, sizeof path/sizeof(Char));
    catn(path, file, sizeof(path) / sizeof(Char));
    if (lstat(short2str(path), &statb) == 0) {
	switch (statb.st_mode & S_IFMT) {
	case S_IFDIR:
	    return ('/');

	case S_IFLNK:
	    if (stat(short2str(path), &statb) == 0 &&	/* follow it out */
		S_ISDIR(statb.st_mode))
		return ('>');
	    else
		return ('@@');

	case S_IFSOCK:
	    return ('=');

	default:
	    if (statb.st_mode & 0111)
		return ('*');
	}
    }
    return (' ');
}

static struct winsize win;

/*
 * Print sorted down columns
 */
static void
print_by_column(Char *dir, Char *items[], int count)
{
    int i, rows, r, c, maxwidth = 0, columns;

    if (ioctl(SHOUT, TIOCGWINSZ, (ioctl_t) & win) < 0 || win.ws_col == 0)
	win.ws_col = 80;
    for (i = 0; i < count; i++)
	maxwidth = maxwidth > (r = Strlen(items[i])) ? maxwidth : r;
    maxwidth += 2;		/* for the file tag and space */
    columns = win.ws_col / maxwidth;
    if (columns == 0)
	columns = 1;
    rows = (count + (columns - 1)) / columns;
    for (r = 0; r < rows; r++) {
	for (c = 0; c < columns; c++) {
	    i = c * rows + r;
	    if (i < count) {
		int w;

		(void) fprintf(cshout, "%s", vis_str(items[i]));
		(void) fputc(dir ? filetype(dir, items[i]) : ' ', cshout);
		if (c < columns - 1) {	/* last column? */
		    w = Strlen(items[i]) + 1;
		    for (; w < maxwidth; w++)
			(void) fputc(' ', cshout);
		}
	    }
	}
	(void) fputc('\r', cshout);
	(void) fputc('\n', cshout);
    }
}

/*
 * Expand file name with possible tilde usage
 *	~person/mumble
 * expands to
 *	home_directory_of_person/mumble
 */
static Char *
tilde(Char *new, Char *old)
{
    Char *o, *p;
    struct passwd *pw;
    static Char person[40];

    if (old[0] != '~') {
	Strlcpy(new, old, PATH_MAX);
	return new;
    }

    for (p = person, o = &old[1]; *o && *o != '/'; *p++ = *o++)
	continue;
    *p = '\0';
    if (person[0] == '\0')
	(void) Strlcpy(new, value(STRhome), PATH_MAX);
    else {
	pw = getpwnam(short2str(person));
	if (pw == NULL)
	    return (NULL);
	(void) Strlcpy(new, str2short(pw->pw_dir), PATH_MAX);
    }
    (void) Strlcat(new, o, PATH_MAX);
    return (new);
}

/*
 * Cause pending line to be printed
 */
static void
retype(void)
{
    struct termios tty;

    (void) tcgetattr(SHOUT, &tty);
    tty.c_lflag |= PENDIN;
    (void) tcsetattr(SHOUT, TCSADRAIN, &tty);
}

static void
beep(void)
{
    if (adrof(STRnobeep) == 0)
	(void) write(SHOUT, "\007", 1);
}

/*
 * Erase that silly ^[ and
 * print the recognized part of the string
 */
static void
print_recognized_stuff(Char *recognized_part)
{
    /* An optimized erasing of that silly ^[ */
    (void) fputc('\b', cshout);
    (void) fputc('\b', cshout);
    switch (Strlen(recognized_part)) {

    case 0:			/* erase two Characters: ^[ */
	(void) fputc(' ', cshout);
	(void) fputc(' ', cshout);
	(void) fputc('\b', cshout);
	(void) fputc('\b', cshout);
	break;

    case 1:			/* overstrike the ^, erase the [ */
	(void) fprintf(cshout, "%s", vis_str(recognized_part));
	(void) fputc(' ', cshout);
	(void) fputc('\b', cshout);
	break;

    default:			/* overstrike both Characters ^[ */
	(void) fprintf(cshout, "%s", vis_str(recognized_part));
	break;
    }
    (void) fflush(cshout);
}

/*
 * Parse full path in file into 2 parts: directory and file names
 * Should leave final slash (/) at end of dir.
 */
static void
extract_dir_and_name(Char *path, Char *dir, Char *name)
{
    Char *p;

    p = Strrchr(path, '/');
    if (p == NULL) {
	copyn(name, path, MAXNAMLEN);
	dir[0] = '\0';
    }
    else {
	copyn(name, ++p, MAXNAMLEN);
	copyn(dir, path, p - path);
    }
}

static Char *
getentry(DIR *dir_fd, int looking_for_lognames)
{
    struct passwd *pw;
    struct dirent *dirp;

    if (looking_for_lognames) {
	if ((pw = getpwent()) == NULL)
	    return (NULL);
	return (str2short(pw->pw_name));
    }
    if ((dirp = readdir(dir_fd)) != NULL)
	return (str2short(dirp->d_name));
    return (NULL);
}

static void
free_items(Char **items, int numitems)
{
    int i;

    for (i = 0; i < numitems; i++)
	free(items[i]);
    free(items);
}

#define FREE_ITEMS(items) { \
	sigset_t sigset, osigset;\
\
	sigemptyset(&sigset);\
	sigaddset(&sigset, SIGINT);\
	sigprocmask(SIG_BLOCK, &sigset, &osigset);\
	free_items(items, numitems);\
	sigprocmask(SIG_SETMASK, &osigset, NULL);\
}

/*
 * Perform a RECOGNIZE or LIST command on string "word".
 */
static int
tsearch(Char *word, COMMAND command, int max_word_length)
{
    DIR *dir_fd;
    int numitems = 0, ignoring = TRUE, nignored = 0;
    int name_length, looking_for_lognames;
    Char    tilded_dir[PATH_MAX], dir[PATH_MAX];
    Char    name[MAXNAMLEN + 1], extended_name[MAXNAMLEN + 1];
    Char   *entry;
    Char   **items = NULL;
    size_t  maxitems = 0;

    looking_for_lognames = (*word == '~') && (Strchr(word, '/') == NULL);
    if (looking_for_lognames) {
	(void) setpwent();
	copyn(name, &word[1], MAXNAMLEN);	/* name sans ~ */
	dir_fd = NULL;
    }
    else {
	extract_dir_and_name(word, dir, name);
	if (tilde(tilded_dir, dir) == 0)
	    return (0);
	dir_fd = opendir(*tilded_dir ? short2str(tilded_dir) : ".");
	if (dir_fd == NULL)
	    return (0);
    }

again:				/* search for matches */
    name_length = Strlen(name);
    for (numitems = 0; (entry = getentry(dir_fd, looking_for_lognames)) != NULL;) {
	if (!is_prefix(name, entry))
	    continue;
	/* Don't match . files on null prefix match */
	if (name_length == 0 && entry[0] == '.' &&
	    !looking_for_lognames)
	    continue;
	if (command == LIST) {
	    if (numitems >= maxitems) {
		maxitems += 1024;
		items = xreallocarray(items, maxitems, sizeof(*items));
	    }
	    items[numitems] = xreallocarray(NULL, (Strlen(entry) + 1), sizeof(Char));
	    copyn(items[numitems], entry, MAXNAMLEN);
	    numitems++;
	}
	else {			/* RECOGNIZE command */
	    if (ignoring && ignored(entry))
		nignored++;
	    else if (recognize(extended_name,
			       entry, name_length, ++numitems))
		break;
	}
    }
    if (ignoring && numitems == 0 && nignored > 0) {
	ignoring = FALSE;
	nignored = 0;
	if (looking_for_lognames)
	    (void) setpwent();
	else
	    rewinddir(dir_fd);
	goto again;
    }

    if (looking_for_lognames)
	(void) endpwent();
    else
	(void) closedir(dir_fd);
    if (numitems == 0)
	return (0);
    if (command == RECOGNIZE) {
	if (looking_for_lognames)
	    copyn(word, STRtilde, 1);
	else
	    /* put back dir part */
	    copyn(word, dir, max_word_length);
	/* add extended name */
	catn(word, extended_name, max_word_length);
	return (numitems);
    }
    else {			/* LIST */
	qsort(items, numitems, sizeof(*items),
		(int (*)(const void *, const void *)) sortscmp);
	print_by_column(looking_for_lognames ? NULL : tilded_dir,
			items, numitems);
	if (items != NULL)
	    FREE_ITEMS(items);
    }
    return (0);
}

/*
 * Object: extend what user typed up to an ambiguity.
 * Algorithm:
 * On first match, copy full entry (assume it'll be the only match)
 * On subsequent matches, shorten extended_name to the first
 * Character mismatch between extended_name and entry.
 * If we shorten it back to the prefix length, stop searching.
 */
static int
recognize(Char *extended_name, Char *entry, int name_length, int numitems)
{
    if (numitems == 1)		/* 1st match */
	copyn(extended_name, entry, MAXNAMLEN);
    else {			/* 2nd & subsequent matches */
	Char *x, *ent;
	int len = 0;

	x = extended_name;
	for (ent = entry; *x && *x == *ent++; x++, len++)
	    continue;
	*x = '\0';		/* Shorten at 1st Char diff */
	if (len == name_length)	/* Ambiguous to prefix? */
	    return (-1);	/* So stop now and save time */
    }
    return (0);
}

/*
 * Return true if check matches initial Chars in template.
 * This differs from PWB imatch in that if check is null
 * it matches anything.
 */
static int
is_prefix(Char *check, Char *template)
{
    do
	if (*check == 0)
	    return (TRUE);
    while (*check++ == *template++);
    return (FALSE);
}

/*
 *  Return true if the Chars in template appear at the
 *  end of check, I.e., are it's suffix.
 */
static int
is_suffix(Char *check, Char *template)
{
    Char *c, *t;

    for (c = check; *c++;)
	continue;
    for (t = template; *t++;)
	continue;
    for (;;) {
	if (t == template)
	    return 1;
	if (c == check || *--t != *--c)
	    return 0;
    }
}

int
tenex(Char *inputline, int inputline_size)
{
    int numitems, num_read;
    char    tinputline[BUFSIZ];

    setup_tty(ON);

    while ((num_read = read(SHIN, tinputline, BUFSIZ)) > 0) {
	int     i;
	static Char delims[] = {' ', '\'', '"', '\t', ';', '&', '<',
	'>', '(', ')', '|', '^', '%', '\0'};
	Char *str_end, *word_start, last_Char, should_retype;
	int space_left;
	COMMAND command;

	for (i = 0; i < num_read; i++)
	    inputline[i] = (unsigned char) tinputline[i];
	last_Char = inputline[num_read - 1] & ASCII;

	if (last_Char == '\n' || num_read == inputline_size)
	    break;
	command = (last_Char == ESC) ? RECOGNIZE : LIST;
	if (command == LIST)
	    (void) fputc('\n', cshout);
	str_end = &inputline[num_read];
	if (last_Char == ESC)
	    --str_end;		/* wipeout trailing cmd Char */
	*str_end = '\0';
	/*
	 * Find LAST occurrence of a delimiter in the inputline. The word start
	 * is one Character past it.
	 */
	for (word_start = str_end; word_start > inputline; --word_start)
	    if (Strchr(delims, word_start[-1]))
		break;
	space_left = inputline_size - (word_start - inputline) - 1;
	numitems = tsearch(word_start, command, space_left);

	if (command == RECOGNIZE) {
	    /* print from str_end on */
	    print_recognized_stuff(str_end);
	    if (numitems != 1)	/* Beep = No match/ambiguous */
		beep();
	}

	/*
	 * Tabs in the input line cause trouble after a pushback. tty driver
	 * won't backspace over them because column positions are now
	 * incorrect. This is solved by retyping over current line.
	 */
	should_retype = FALSE;
	if (Strchr(inputline, '\t')) {	/* tab Char in input line? */
	    back_to_col_1();
	    should_retype = TRUE;
	}
	if (command == LIST)	/* Always retype after a LIST */
	    should_retype = TRUE;
	if (should_retype)
	    printprompt();
	pushback(inputline);
	if (should_retype)
	    retype();
    }
    setup_tty(OFF);
    return (num_read);
}

static int
ignored(Char *entry)
{
    struct varent *vp;
    Char **cp;

    if ((vp = adrof(STRfignore)) == NULL || (cp = vp->vec) == NULL)
	return (FALSE);
    for (; *cp != NULL; cp++)
	if (is_suffix(entry, *cp))
	    return (TRUE);
    return (FALSE);
}
@


1.22
log
@unifdef BUILTIN (unused), NLS (always set), SHORT_STRINGS (always set)
and remove a few unused defines; no binary changes; ok tedu@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.21 2015/06/17 03:48:21 deraadt Exp $	*/
d393 2
a394 2
	xfree(items[i]);
    xfree(items);
@


1.21
log
@remove -DFILEC; code does not compile for the -UFILEC case, and anyways,
who wants csh without FILEC??
from Peter Brottveit Bock, but redone using unifdef
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.20 2015/06/03 01:49:35 deraadt Exp $	*/
a42 3
#ifndef SHORT_STRINGS
#include <string.h>
#endif /* SHORT_STRINGS */
@


1.20
log
@better description of internal copyn() function
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.19 2015/02/08 05:47:28 tedu Exp $	*/
a32 1
#ifdef FILEC
a646 1
#endif				/* FILEC */
@


1.19
log
@delete lots of unnecessary ptr_t casts, and drop a little NULL in as well
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.18 2015/01/16 06:39:31 deraadt Exp $	*/
d189 1
a189 2
 * Like strncpy but always leave room for trailing \0
 * and always null terminate.
@


1.18
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.17 2014/10/16 19:43:31 deraadt Exp $	*/
d398 2
a399 2
	xfree((ptr_t) items[i]);
    xfree((ptr_t) items);
d495 1
a495 1
	qsort((ptr_t) items, numitems, sizeof(*items),
@


1.17
log
@Use reallocarray() and remove a few archaic memory allocation practices.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.16 2009/10/27 23:59:21 deraadt Exp $	*/
d35 1
a35 1
#include <sys/param.h>
d43 1
d204 1
a204 1
    Char    path[MAXPATHLEN];
d285 1
a285 1
	Strlcpy(new, old, MAXPATHLEN);
d293 1
a293 1
	(void) Strlcpy(new, value(STRhome), MAXPATHLEN);
d298 1
a298 1
	(void) Strlcpy(new, str2short(pw->pw_dir), MAXPATHLEN);
d300 1
a300 1
    (void) Strlcat(new, o, MAXPATHLEN);
d421 1
a421 1
    Char    tilded_dir[MAXPATHLEN], dir[MAXPATHLEN];
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.15 2003/06/11 21:09:50 deraadt Exp $	*/
d453 1
a453 5
		if (items == NULL)
			items = (Char **) xmalloc(sizeof(*items) * maxitems);
		else
			items = (Char **) xrealloc((ptr_t) items,
			    sizeof(*items) * maxitems);
d455 1
a455 2
	    items[numitems] = (Char *) xmalloc((size_t) (Strlen(entry) + 1) *
					       sizeof(Char));
@


1.15
log
@de-register and ansify functions
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.14 2003/06/02 23:32:07 millert Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)file.c	8.2 (Berkeley) 3/19/94";
#else
static char rcsid[] = "$OpenBSD: file.c,v 1.14 2003/06/02 23:32:07 millert Exp $";
#endif
#endif /* not lint */
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.13 2003/01/08 06:54:16 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: file.c,v 1.13 2003/01/08 06:54:16 deraadt Exp $";
d109 1
a109 2
setup_tty(on)
    int     on;
d136 1
a136 1
back_to_col_1()
d158 1
a158 2
pushback(string)
    Char   *string;
d160 1
a160 1
    register Char *p;
d185 1
a185 3
catn(des, src, count)
    register Char *des, *src;
    register int count;
d200 1
a200 3
copyn(des, src, count)
    register Char *des, *src;
    register int count;
d209 1
a209 2
filetype(dir, file)
    Char   *dir, *file;
d245 1
a245 3
print_by_column(dir, items, count)
    Char   *dir, *items[];
    int     count;
d247 1
a247 1
    register int i, rows, r, c, maxwidth = 0, columns;
d262 1
a262 1
		register int w;
d285 1
a285 2
tilde(new, old)
    Char   *new, *old;
d287 2
a288 2
    register Char *o, *p;
    register struct passwd *pw;
d315 1
a315 1
retype()
d325 1
a325 1
beep()
d336 1
a336 2
print_recognized_stuff(recognized_part)
    Char   *recognized_part;
d368 1
a368 2
extract_dir_and_name(path, dir, name)
    Char   *path, *dir, *name;
d370 1
a370 1
    register Char *p;
d384 1
a384 3
getentry(dir_fd, looking_for_lognames)
    DIR    *dir_fd;
    int     looking_for_lognames;
d386 2
a387 2
    register struct passwd *pw;
    register struct dirent *dirp;
d400 1
a400 3
free_items(items, numitems)
    Char **items;
    int numitems;
d423 5
a427 8
tsearch(word, command, max_word_length)
    Char   *word;
    COMMAND command;
    int     max_word_length;
{
    register DIR *dir_fd;
    register int numitems = 0, ignoring = TRUE, nignored = 0;
    register int name_length, looking_for_lognames;
d526 1
a526 3
recognize(extended_name, entry, name_length, numitems)
    Char   *extended_name, *entry;
    int     name_length, numitems;
d531 2
a532 2
	register Char *x, *ent;
	register int len = 0;
d550 1
a550 2
is_prefix(check, template)
    register Char *check, *template;
d564 1
a564 2
is_suffix(check, template)
    Char   *check, *template;
d566 1
a566 1
    register Char *c, *t;
d581 1
a581 3
tenex(inputline, inputline_size)
    Char   *inputline;
    int     inputline_size;
d583 1
a583 1
    register int numitems, num_read;
a585 1

d592 2
a593 2
	register Char *str_end, *word_start, last_Char, should_retype;
	register int space_left;
d649 1
a649 2
ignored(entry)
    register Char *entry;
d652 1
a652 1
    register Char **cp;
@


1.13
log
@bring in strlcpy and strlcat-like things for dealing with Char types,
this fixes at least 15 buffer overflows; some help from dhartmei.
Anyone want to go do the same in ksh, and help with some of the while
(*s++ = *p++) loops in here?
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.12 2002/07/24 19:53:50 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: file.c,v 1.12 2002/07/24 19:53:50 millert Exp $";
@


1.12
log
@Fix a bug I inadvertanly introduced while fixing the last problem in here.
The item list really did want to be zero-filled since free_items() relies
on this to find the end point.  However, this is really pretty dumb since
we *know* how many items are in the list.

This highlights the elusive bug I was trying to fix--free_items() expects
the list to be NULL-terminated which was not the case if the list was full.
The fix is to simply pass free_items() the number of elements in the list.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.11 2002/07/15 22:10:13 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.11 2002/07/15 22:10:13 millert Exp $";
d225 2
a226 1
    catn(Strcpy(path, dir), file, sizeof(path) / sizeof(Char));
d305 4
a308 2
    if (old[0] != '~')
	return (Strcpy(new, old));
d314 1
a314 1
	(void) Strcpy(new, value(STRhome));
d319 1
a319 1
	(void) Strcpy(new, str2short(pw->pw_dir));
d321 1
a321 1
    (void) Strcat(new, o);
@


1.11
log
@Remove 1024 directory entry limit for tenex-style file completion.
This fixes a mysterious segv when doing file completion twice in
directories w/ more than 1024 files.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.10 2002/06/09 05:47:27 todd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.10 2002/06/09 05:47:27 todd Exp $";
d98 1
a98 1
static void	 free_items(Char **);
d415 3
a417 2
free_items(items)
    register Char **items;
d419 1
a419 1
    register int i;
d421 1
a421 1
    for (i = 0; items[i]; i++)
d432 1
a432 1
	free_items(items);\
d482 1
a482 1
			items = (Char **) xmalloc(sizeof(items[0]) * maxitems);
d485 1
a485 1
			    sizeof(items[0]) * maxitems);
d527 1
a527 1
	qsort((ptr_t) items, numitems, sizeof(items[0]),
@


1.10
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.9 2002/02/19 19:39:35 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.9 2002/02/19 19:39:35 millert Exp $";
a431 1
	items = NULL;\
a443 1
    static Char **items = NULL;
d450 2
a451 5

#define MAXITEMS 1024

    if (items != NULL)
	FREE_ITEMS(items);
d478 7
a484 5
	    if (numitems >= MAXITEMS) {
		(void) fprintf(csherr, "\nYikes!! Too many %s!!\n",
			       looking_for_lognames ?
			       "names in password file" : "files");
		break;
a485 2
	    if (items == NULL)
		items = (Char **) xcalloc(sizeof(items[0]), MAXITEMS);
@


1.9
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.8 2002/02/16 21:27:06 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.8 2002/02/16 21:27:06 millert Exp $";
d531 1
a531 1
	qsort((ptr_t) items, numitems, sizeof(items[0]), 
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.7 2001/12/01 19:10:39 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.7 2001/12/01 19:10:39 deraadt Exp $";
d58 1
a58 5
#ifdef __STDC__
# include <stdarg.h>
#else
# include <varargs.h>
#endif
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.6 1998/05/18 20:38:20 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.6 1998/05/18 20:38:20 deraadt Exp $";
d89 19
a107 19
static void	 setup_tty __P((int));
static void	 back_to_col_1 __P((void));
static void	 pushback __P((Char *));
static void	 catn __P((Char *, Char *, int));
static void	 copyn __P((Char *, Char *, int));
static Char	 filetype __P((Char *, Char *));
static void	 print_by_column __P((Char *, Char *[], int));
static Char	*tilde __P((Char *, Char *));
static void	 retype __P((void));
static void	 beep __P((void));
static void	 print_recognized_stuff __P((Char *));
static void	 extract_dir_and_name __P((Char *, Char *, Char *));
static Char	*getentry __P((DIR *, int));
static void	 free_items __P((Char **));
static int	 tsearch __P((Char *, COMMAND, int));
static int	 recognize __P((Char *, Char *, int, int));
static int	 is_prefix __P((Char *, Char *));
static int	 is_suffix __P((Char *, Char *));
static int	 ignored __P((Char *));
d536 1
a536 1
		(int (*) __P((const void *, const void *))) sortscmp);
@


1.6
log
@MAXPATHLEN not MAXPATHLEN+1
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.5 1997/11/15 21:51:29 todd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.5 1997/11/15 21:51:29 todd Exp $";
d451 2
a452 2
    register numitems = 0, ignoring = TRUE, nignored = 0;
    register name_length, looking_for_lognames;
@


1.5
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.4 1997/07/25 18:58:06 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.4 1997/07/25 18:58:06 mickey Exp $";
d453 1
a453 1
    Char    tilded_dir[MAXPATHLEN + 1], dir[MAXPATHLEN + 1];
@


1.4
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.3 1996/12/04 17:46:07 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.3 1996/12/04 17:46:07 millert Exp $";
d645 1
a645 1
	 * Find LAST occurence of a delimiter in the inputline. The word start
@


1.3
log
@use TCSADRAIN instead of TCSANOW, to avoid dropping characters.
Fix from NetBSD (christos), reported by Chris Torek.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.2 1996/06/23 14:19:22 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.2 1996/06/23 14:19:22 deraadt Exp $";
d58 1
a58 1
#if __STDC__
@


1.2
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: file.c,v 1.10 1995/03/21 18:35:39 mycroft Exp $	*/
/*	$NetBSD: file.c,v 1.10 1995/03/21 18:35:39 mycroft Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.10 1995/03/21 18:35:39 mycroft Exp $";
d157 1
a157 1
    (void) tcsetattr(SHOUT, TCSANOW, &tty);
d159 1
a159 1
    (void) tcsetattr(SHOUT, TCSANOW, &tty_normal);
d181 1
a181 1
    (void) tcsetattr(SHOUT, TCSANOW, &tty);
d185 1
a185 1
    (void) tcsetattr(SHOUT, TCSANOW, &tty_normal);
d336 1
a336 1
    (void) tcsetattr(SHOUT, TCSANOW, &tty);
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: file.c,v 1.10 1995/03/21 18:35:39 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
