head	1.35;
access;
symbols
	OPENBSD_6_1:1.23.0.8
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.16.0.22
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.20
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.28
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.24
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.22
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.20
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.18
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.16
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.14
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.12
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.10
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.6.0.14
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.12
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.10
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.6
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2017.08.30.06.57.48;	author anton;	state Exp;
branches;
next	1.34;
commitid	phJZeMaHld4qWGEp;

1.34
date	2017.08.30.06.42.21;	author anton;	state Exp;
branches;
next	1.33;
commitid	lSSIqVE6vCZN2o5S;

1.33
date	2017.07.26.19.20.51;	author anton;	state Exp;
branches;
next	1.32;
commitid	V0jnRyk1CHH3yT7L;

1.32
date	2017.07.26.19.15.09;	author anton;	state Exp;
branches;
next	1.31;
commitid	GbFR3x4vhghrR34B;

1.31
date	2017.07.18.17.24.42;	author anton;	state Exp;
branches;
next	1.30;
commitid	VQXXwJI00R2BMMk6;

1.30
date	2017.06.29.04.23.12;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	IoisttiJbB629sR7;

1.29
date	2017.06.27.15.02.18;	author anton;	state Exp;
branches;
next	1.28;
commitid	I4Osw1uCpW5frSYz;

1.28
date	2017.06.27.14.37.08;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	WXH9a9myJMqiZwjr;

1.27
date	2017.06.22.18.05.31;	author anton;	state Exp;
branches;
next	1.26;
commitid	IkWPHARPwrMZdYV5;

1.26
date	2017.06.21.19.36.23;	author anton;	state Exp;
branches;
next	1.25;
commitid	zFkmakZe1pTH9aHi;

1.25
date	2017.06.21.18.55.15;	author anton;	state Exp;
branches;
next	1.24;
commitid	xItRuNgkwRD0PQhz;

1.24
date	2017.06.17.18.14.47;	author anton;	state Exp;
branches;
next	1.23;
commitid	ZdfwQlaveQzV9khl;

1.23
date	2015.12.26.13.48.38;	author mestre;	state Exp;
branches;
next	1.22;
commitid	jZMsEASvreUUSdqp;

1.22
date	2015.10.26.15.01.15;	author naddy;	state Exp;
branches;
next	1.21;
commitid	gs7LRmKw8OfepnU6;

1.21
date	2015.06.17.03.48.21;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	oHdhnDXEPqwM6LiV;

1.20
date	2015.06.03.01.49.35;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	G0QoAB2EGeHbSaNz;

1.19
date	2015.02.08.05.47.28;	author tedu;	state Exp;
branches;
next	1.18;
commitid	UHj0KNSjy07xS7rI;

1.18
date	2015.01.16.06.39.31;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Uu5nFG3wCl0LACBb;

1.17
date	2014.10.16.19.43.31;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	jIHreojPTUQy0Zyb;

1.16
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.11.21.09.50;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.32.07;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.08.06.54.16;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.24.19.53.50;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.15.22.10.13;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.01.19.10.39;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.05.18.20.38.20;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.11.15.21.51.29;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	97.07.25.18.58.06;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.12.04.17.46.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.22;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Respect inputline_size argument. No functional change since tenex() only has one
call site where `inputline_size == sizeof(buf)`.
@
text
@/*	$OpenBSD: file.c,v 1.34 2017/08/30 06:42:21 anton Exp $	*/
/*	$NetBSD: file.c,v 1.11 1996/11/08 19:34:37 christos Exp $	*/

/*-
 * Copyright (c) 1980, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>

#include <dirent.h>
#include <errno.h>
#include <limits.h>
#include <pwd.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#include "csh.h"
#include "extern.h"

/*
 * Tenex style file name recognition, .. and more.
 * History:
 *	Author: Ken Greer, Sept. 1975, CMU.
 *	Finally got around to adding to the Cshell., Ken Greer, Dec. 1981.
 */

#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif

#define	ESC		'\033'
#define	TABWIDTH	8

typedef enum {
	LIST,
	RECOGNIZE
} COMMAND;

struct cmdline {
	int	 fdin;
	int	 fdout;
	int	 flags;
#define	CL_ALTWERASE	0x1
#define	CL_PROMPT	0x2
	char	*buf;
	size_t	 len;
	size_t	 size;
	size_t	 cursor;
};

/* Command line auxiliary functions. */
static void	 cl_beep(struct cmdline *);
static void	 cl_flush(struct cmdline *);
static int	 cl_getc(struct cmdline *);
static Char	*cl_lastw(struct cmdline *);
static void	 cl_putc(struct cmdline *, int);
static void	 cl_visc(struct cmdline *, int);

/* Command line editing functions. */
static int	cl_abort(struct cmdline *, int);
static int	cl_erasec(struct cmdline *, int);
static int	cl_erasew(struct cmdline *, int);
static int	cl_insert(struct cmdline *, int);
static int	cl_kill(struct cmdline *, int);
static int	cl_list(struct cmdline *, int);
static int	cl_literal(struct cmdline *, int);
static int	cl_recognize(struct cmdline *, int);
static int	cl_reprint(struct cmdline *, int);
static int	cl_status(struct cmdline *, int);

static const struct termios	*setup_tty(int);

static void	 catn(Char *, Char *, int);
static void	 copyn(Char *, Char *, int);
static Char	 filetype(Char *, Char *);
static void	 print_by_column(Char *, Char *[], int);
static Char	*tilde(Char *, Char *);
static void	 extract_dir_and_name(Char *, Char *, Char *);
static Char	*getentry(DIR *, int);
static void	 free_items(Char **, int);
static int	 tsearch(Char *, COMMAND, int);
static int	 recognize(Char *, Char *, int, int);
static int	 is_prefix(Char *, Char *);
static int	 is_suffix(Char *, Char *);
static int	 ignored(Char *);

/*
 * Put this here so the binary can be patched with adb to enable file
 * completion by default.  Filec controls completion, nobeep controls
 * ringing the terminal bell on incomplete expansions.
 */
bool    filec = 0;

static void
cl_flush(struct cmdline *cl)
{
	size_t	i, len;
	int	c;

	if (cl->flags & CL_PROMPT) {
		cl->flags &= ~CL_PROMPT;
		printprompt();
	}

	if (cl->cursor < cl->len) {
		for (; cl->cursor < cl->len; cl->cursor++)
			cl_visc(cl, cl->buf[cl->cursor]);
	} else if (cl->cursor > cl->len) {
		len = cl->cursor - cl->len;
		for (i = len; i > 0; i--) {
			c = cl->buf[--cl->cursor];
			if (c == '\t')
				len += TABWIDTH - 1;
			else if (iscntrl(c))
				len++;	/* account for leading ^ */
		}
		for (i = 0; i < len; i++)
			cl_putc(cl, '\b');
		for (i = 0; i < len; i++)
			cl_putc(cl, ' ');
		for (i = 0; i < len; i++)
			cl_putc(cl, '\b');
		cl->cursor = cl->len;
	}
}

static int
cl_getc(struct cmdline *cl)
{
	ssize_t		n;
	unsigned char	c;

	for (;;) {
		n = read(cl->fdin, &c, 1);
		switch (n) {
		case -1:
			if (errno == EINTR)
				continue;
			/* FALLTHROUGH */
		case 0:
			return 0;
		default:
			return c & 0x7F;
		}
	}
}

static Char *
cl_lastw(struct cmdline *cl)
{
	static Char		 word[BUFSIZ];
	const unsigned char	*delimiters = " '\"\t;&<>()|^%";
	Char			*cp;
	size_t			 i;

	for (i = cl->len; i > 0; i--)
		if (strchr(delimiters, cl->buf[i - 1]) != NULL)
			break;

	cp = word;
	for (; i < cl->len; i++)
		*cp++ = cl->buf[i];
	*cp = '\0';

	return word;
}

static void
cl_putc(struct cmdline *cl, int c)
{
	unsigned char	cc = c;

	write(cl->fdout, &cc, 1);
}

static void
cl_visc(struct cmdline *cl, int c)
{
#define	UNCNTRL(x)	((x) == 0x7F ? '?' : ((x) | 0x40))
	int	i;

	if (c == '\t') {
		for (i = 0; i < TABWIDTH; i++)
			cl_putc(cl, ' ');
	} else if (c != '\n' && iscntrl(c)) {
		cl_putc(cl, '^');
		cl_putc(cl, UNCNTRL(c));
	} else {
		cl_putc(cl, c);
	}
}

static int
cl_abort(struct cmdline *cl, int c)
{
	cl_visc(cl, c);

	/* Abort while/foreach loop prematurely. */
	if (whyles) {
		setup_tty(0);
		kill(getpid(), SIGINT);
	}

	cl_putc(cl, '\n');
	cl->len = cl->cursor = 0;
	cl->flags |= CL_PROMPT;

	return 0;
}

static int
cl_erasec(struct cmdline *cl, int c)
{
	if (cl->len > 0)
		cl->len--;

	return 0;
}

static int
cl_erasew(struct cmdline *cl, int c)
{
	const unsigned char	*ws = " \t";

	for (; cl->len > 0; cl->len--)
		if (strchr(ws, cl->buf[cl->len - 1]) == NULL &&
		    ((cl->flags & CL_ALTWERASE) == 0 ||
		     isalpha(cl->buf[cl->len - 1])))
			break;
	for (; cl->len > 0; cl->len--)
		if (strchr(ws, cl->buf[cl->len - 1]) != NULL ||
		    ((cl->flags & CL_ALTWERASE) &&
		     !isalpha(cl->buf[cl->len - 1])))
			break;

	return 0;
}

static void
cl_beep(struct cmdline *cl)
{
	if (adrof(STRnobeep) == 0)
		cl_putc(cl, '\007');
}

static int
cl_insert(struct cmdline *cl, int c)
{
	if (cl->len == cl->size)
		return 1;

	cl->buf[cl->len++] = c;

	if (c == '\n')
		return 1;

	return 0;
}

static int
cl_kill(struct cmdline *cl, int c)
{
	cl->len = 0;

	return 0;
}

static int
cl_list(struct cmdline *cl, int c)
{
	Char	*word;
	size_t	 len;

	if (adrof(STRignoreeof) || cl->len > 0)
		cl_visc(cl, c);

	if (cl->len == 0)
		return 1;

	cl_putc(cl, '\n');
	cl->cursor = 0;
	cl->flags |= CL_PROMPT;

	word = cl_lastw(cl);
	len = Strlen(word);
	tsearch(word, LIST, BUFSIZ - len - 1);	/* NUL */

	return 0;
}

static int
cl_literal(struct cmdline *cl, int c)
{
	int	literal;

	literal = cl_getc(cl);
	if (literal == '\n')
		literal = '\r';
	cl_insert(cl, literal);

	return 0;
}

static int
cl_recognize(struct cmdline *cl, int c)
{
	Char	*word;
	size_t	 len;
	int	 nitems;

	if (cl->len == 0) {
		cl_beep(cl);
		return 0;
	}

	word = cl_lastw(cl);
	len = Strlen(word);
	nitems = tsearch(word, RECOGNIZE, BUFSIZ - len - 1);	/* NUL */
	for (word += len; *word != '\0'; word++)
		cl_insert(cl, *word);
	if (nitems != 1)
		cl_beep(cl);

	return 0;
}

static int
cl_reprint(struct cmdline *cl, int c)
{
	cl_visc(cl, c);
	cl_putc(cl, '\n');
	cl->cursor = 0;

	return 0;
}

static int
cl_status(struct cmdline *cl, int c)
{
	cl->cursor = 0;
	ioctl(cl->fdin, TIOCSTAT);

	return 0;
}

const struct termios *
setup_tty(int on)
{
	static struct termios	newtio, oldtio;

	if (on) {
		tcgetattr(SHIN, &oldtio);

		newtio = oldtio;
		newtio.c_lflag &= ~(ECHO | ICANON | ISIG);
		newtio.c_cc[VEOL] = ESC;
		newtio.c_cc[VLNEXT] = _POSIX_VDISABLE;
		newtio.c_cc[VMIN] = 1;
		newtio.c_cc[VTIME] = 0;
	} else {
		newtio = oldtio;
	}

	tcsetattr(SHIN, TCSADRAIN, &newtio);

	/*
	 * Since VLNEXT is disabled, restore its previous value in order to make
	 * the key detectable.
	 */
	newtio.c_cc[VLNEXT] = oldtio.c_cc[VLNEXT];

	return &newtio;
}

/*
 * Concatenate src onto tail of des.
 * Des is a string whose maximum length is count.
 * Always null terminate.
 */
static void
catn(Char *des, Char *src, int count)
{
    while (--count >= 0 && *des)
	des++;
    while (--count >= 0)
	if ((*des++ = *src++) == 0)
	    return;
    *des = '\0';
}

/*
 * Places Char's like strlcpy, but no special return value.
 */
static void
copyn(Char *des, Char *src, int count)
{
    while (--count >= 0)
	if ((*des++ = *src++) == 0)
	    return;
    *des = '\0';
}

static  Char
filetype(Char *dir, Char *file)
{
    Char    path[PATH_MAX];
    struct stat statb;

    Strlcpy(path, dir, sizeof path/sizeof(Char));
    catn(path, file, sizeof(path) / sizeof(Char));
    if (lstat(short2str(path), &statb) == 0) {
	switch (statb.st_mode & S_IFMT) {
	case S_IFDIR:
	    return ('/');

	case S_IFLNK:
	    if (stat(short2str(path), &statb) == 0 &&	/* follow it out */
		S_ISDIR(statb.st_mode))
		return ('>');
	    else
		return ('@@');

	case S_IFSOCK:
	    return ('=');

	default:
	    if (statb.st_mode & 0111)
		return ('*');
	}
    }
    return (' ');
}

/*
 * Print sorted down columns
 */
static void
print_by_column(Char *dir, Char *items[], int count)
{
    struct winsize win;
    int i, rows, r, c, maxwidth = 0, columns;

    if (ioctl(SHOUT, TIOCGWINSZ, (ioctl_t) & win) < 0 || win.ws_col == 0)
	win.ws_col = 80;
    for (i = 0; i < count; i++)
	maxwidth = maxwidth > (r = Strlen(items[i])) ? maxwidth : r;
    maxwidth += 2;		/* for the file tag and space */
    columns = win.ws_col / maxwidth;
    if (columns == 0)
	columns = 1;
    rows = (count + (columns - 1)) / columns;
    for (r = 0; r < rows; r++) {
	for (c = 0; c < columns; c++) {
	    i = c * rows + r;
	    if (i < count) {
		int w;

		(void) fprintf(cshout, "%s", vis_str(items[i]));
		(void) fputc(dir ? filetype(dir, items[i]) : ' ', cshout);
		if (c < columns - 1) {	/* last column? */
		    w = Strlen(items[i]) + 1;
		    for (; w < maxwidth; w++)
			(void) fputc(' ', cshout);
		}
	    }
	}
	(void) fputc('\r', cshout);
	(void) fputc('\n', cshout);
    }
}

/*
 * Expand file name with possible tilde usage
 *	~person/mumble
 * expands to
 *	home_directory_of_person/mumble
 */
static Char *
tilde(Char *new, Char *old)
{
    Char *o, *p;
    struct passwd *pw;
    static Char person[40];

    if (old[0] != '~') {
	Strlcpy(new, old, PATH_MAX);
	return new;
    }

    for (p = person, o = &old[1]; *o && *o != '/'; *p++ = *o++)
	continue;
    *p = '\0';
    if (person[0] == '\0')
	(void) Strlcpy(new, value(STRhome), PATH_MAX);
    else {
	pw = getpwnam(short2str(person));
	if (pw == NULL)
	    return (NULL);
	(void) Strlcpy(new, str2short(pw->pw_dir), PATH_MAX);
    }
    (void) Strlcat(new, o, PATH_MAX);
    return (new);
}

/*
 * Parse full path in file into 2 parts: directory and file names
 * Should leave final slash (/) at end of dir.
 */
static void
extract_dir_and_name(Char *path, Char *dir, Char *name)
{
    Char *p;

    p = Strrchr(path, '/');
    if (p == NULL) {
	copyn(name, path, MAXNAMLEN);
	dir[0] = '\0';
    }
    else {
	copyn(name, ++p, MAXNAMLEN);
	copyn(dir, path, p - path);
    }
}

static Char *
getentry(DIR *dir_fd, int looking_for_lognames)
{
    struct passwd *pw;
    struct dirent *dirp;

    if (looking_for_lognames) {
	if ((pw = getpwent()) == NULL)
	    return (NULL);
	return (str2short(pw->pw_name));
    }
    if ((dirp = readdir(dir_fd)) != NULL)
	return (str2short(dirp->d_name));
    return (NULL);
}

static void
free_items(Char **items, int numitems)
{
    int i;

    for (i = 0; i < numitems; i++)
	free(items[i]);
    free(items);
}

#define FREE_ITEMS(items) { \
	sigset_t sigset, osigset;\
\
	sigemptyset(&sigset);\
	sigaddset(&sigset, SIGINT);\
	sigprocmask(SIG_BLOCK, &sigset, &osigset);\
	free_items(items, numitems);\
	sigprocmask(SIG_SETMASK, &osigset, NULL);\
}

/*
 * Perform a RECOGNIZE or LIST command on string "word".
 */
static int
tsearch(Char *word, COMMAND command, int max_word_length)
{
    DIR *dir_fd;
    int numitems = 0, ignoring = TRUE, nignored = 0;
    int name_length, looking_for_lognames;
    Char    tilded_dir[PATH_MAX], dir[PATH_MAX];
    Char    name[MAXNAMLEN + 1], extended_name[MAXNAMLEN + 1];
    Char   *entry;
    Char   **items = NULL;
    size_t  maxitems = 0;

    looking_for_lognames = (*word == '~') && (Strchr(word, '/') == NULL);
    if (looking_for_lognames) {
	(void) setpwent();
	copyn(name, &word[1], MAXNAMLEN);	/* name sans ~ */
	dir_fd = NULL;
    }
    else {
	extract_dir_and_name(word, dir, name);
	if (tilde(tilded_dir, dir) == 0)
	    return (0);
	dir_fd = opendir(*tilded_dir ? short2str(tilded_dir) : ".");
	if (dir_fd == NULL)
	    return (0);
    }

again:				/* search for matches */
    name_length = Strlen(name);
    for (numitems = 0; (entry = getentry(dir_fd, looking_for_lognames)) != NULL;) {
	if (!is_prefix(name, entry))
	    continue;
	/* Don't match . files on null prefix match */
	if (name_length == 0 && entry[0] == '.' &&
	    !looking_for_lognames)
	    continue;
	if (command == LIST) {
	    if (numitems >= maxitems) {
		maxitems += 1024;
		items = xreallocarray(items, maxitems, sizeof(*items));
	    }
	    items[numitems] = xreallocarray(NULL, (Strlen(entry) + 1), sizeof(Char));
	    copyn(items[numitems], entry, MAXNAMLEN);
	    numitems++;
	}
	else {			/* RECOGNIZE command */
	    if (ignoring && ignored(entry))
		nignored++;
	    else if (recognize(extended_name,
			       entry, name_length, ++numitems))
		break;
	}
    }
    if (ignoring && numitems == 0 && nignored > 0) {
	ignoring = FALSE;
	nignored = 0;
	if (looking_for_lognames)
	    (void) setpwent();
	else
	    rewinddir(dir_fd);
	goto again;
    }

    if (looking_for_lognames)
	(void) endpwent();
    else
	(void) closedir(dir_fd);
    if (numitems == 0)
	return (0);
    if (command == RECOGNIZE) {
	if (looking_for_lognames)
	    copyn(word, STRtilde, 1);
	else
	    /* put back dir part */
	    copyn(word, dir, max_word_length);
	/* add extended name */
	catn(word, extended_name, max_word_length);
	return (numitems);
    }
    else {			/* LIST */
	qsort(items, numitems, sizeof(*items),
		(int (*)(const void *, const void *)) sortscmp);
	print_by_column(looking_for_lognames ? NULL : tilded_dir,
			items, numitems);
	if (items != NULL)
	    FREE_ITEMS(items);
    }
    return (0);
}

/*
 * Object: extend what user typed up to an ambiguity.
 * Algorithm:
 * On first match, copy full entry (assume it'll be the only match)
 * On subsequent matches, shorten extended_name to the first
 * Character mismatch between extended_name and entry.
 * If we shorten it back to the prefix length, stop searching.
 */
static int
recognize(Char *extended_name, Char *entry, int name_length, int numitems)
{
    if (numitems == 1)		/* 1st match */
	copyn(extended_name, entry, MAXNAMLEN);
    else {			/* 2nd & subsequent matches */
	Char *x, *ent;
	int len = 0;

	x = extended_name;
	for (ent = entry; *x && *x == *ent++; x++, len++)
	    continue;
	*x = '\0';		/* Shorten at 1st Char diff */
	if (len == name_length)	/* Ambiguous to prefix? */
	    return (-1);	/* So stop now and save time */
    }
    return (0);
}

/*
 * Return true if check matches initial Chars in template.
 * This differs from PWB imatch in that if check is null
 * it matches anything.
 */
static int
is_prefix(Char *check, Char *template)
{
    do
	if (*check == 0)
	    return (TRUE);
    while (*check++ == *template++);
    return (FALSE);
}

/*
 *  Return true if the Chars in template appear at the
 *  end of check, I.e., are it's suffix.
 */
static int
is_suffix(Char *check, Char *template)
{
    Char *c, *t;

    for (c = check; *c++;)
	continue;
    for (t = template; *t++;)
	continue;
    for (;;) {
	if (t == template)
	    return 1;
	if (c == check || *--t != *--c)
	    return 0;
    }
}

int
tenex(Char *inputline, int inputline_size)
{
	static struct {
		int	(*fn)(struct cmdline *, int);
		int	idx;
	}			 keys[] = {
		{ cl_abort,	VINTR },
		{ cl_erasec,	VERASE },
		{ cl_erasew,	VWERASE },
		{ cl_kill,	VKILL },
		{ cl_list,	VEOF },
		{ cl_literal,	VLNEXT },
		{ cl_recognize,	VEOL },
		{ cl_reprint,	VREPRINT },
		{ cl_status,	VSTATUS },
		{ cl_insert,	-1 }
	};
	unsigned char		 buf[BUFSIZ];
	const struct termios	*tio;
	struct cmdline		 cl;
	size_t			 i;
	int			 c, ret;

	tio = setup_tty(1);

	memset(&cl, 0, sizeof(cl));
	cl.fdin = SHIN;
	cl.fdout = SHOUT;
	cl.buf = buf;
	cl.size = sizeof(buf);
	if (inputline_size < cl.size)
		cl.size = inputline_size;
	if (tio->c_lflag & ALTWERASE)
		cl.flags |= CL_ALTWERASE;
	if (needprompt) {
		needprompt = 0;
		cl.flags |= CL_PROMPT;
		cl_flush(&cl);
	}

	for (;;) {
		if ((c = cl_getc(&cl)) == 0)
			break;

		for (i = 0; keys[i].idx >= 0; i++)
			if (CCEQ(tio->c_cc[keys[i].idx], c))
				break;
		ret = keys[i].fn(&cl, c);
		cl_flush(&cl);
		if (ret)
			break;
	}

	setup_tty(0);

	for (i = 0; i < cl.len; i++)
		inputline[i] = cl.buf[i];
	/*
	 * NUL-terminating the buffer implies that it contains a complete
	 * command ready to be executed. Therefore, don't terminate if the
	 * buffer is full since more characters must be read in order to form a
	 * complete command.
	 */
	if (i < sizeof(buf))
		inputline[i] = '\0';

	return cl.len;
}

static int
ignored(Char *entry)
{
    struct varent *vp;
    Char **cp;

    if ((vp = adrof(STRfignore)) == NULL || (cp = vp->vec) == NULL)
	return (FALSE);
    for (; *cp != NULL; cp++)
	if (is_suffix(entry, *cp))
	    return (TRUE);
    return (FALSE);
}
@


1.34
log
@Fix pasting of long (>BUFSIZ) lines in csh with filec enabled. NUL-terminating
the input buffer instructs csh that the buffer contains a complete command. This
is wrong and should only happen when buffer is not full, otherwise more data has
to be read in order form a complete command.

While here, do not print the prompt again when the input exceeds the input
buffer and while inserting a line continuation (backslash).
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.33 2017/07/26 19:20:51 anton Exp $	*/
d780 2
@


1.33
log
@Align variables and put logical operators at EOL. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.32 2017/07/26 19:15:09 anton Exp $	*/
d782 5
a786 2
	cl.flags |= CL_PROMPT;
	cl_flush(&cl);	/* print prompt */
d805 8
a812 1
	inputline[i] = '\0';
@


1.32
log
@Postpone printing of prompt if filec is enabled in csh. Any I/O should be
performed first when canonical mode has been disabled on the tty just like ksh
does. Discovered by the regress tests.

Joint work with bluhm@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.31 2017/07/18 17:24:42 anton Exp $	*/
d183 4
a186 4
	static Char	 word[BUFSIZ];
	const unsigned char *delimiters = " '\"\t;&<>()|^%";
	Char	*cp;
	size_t		 i;
d203 1
a203 1
	unsigned char cc = c;
d258 3
a260 3
		if (strchr(ws, cl->buf[cl->len - 1]) == NULL
		    && ((cl->flags & CL_ALTWERASE) == 0
			    || isalpha(cl->buf[cl->len - 1])))
d263 3
a265 3
		if (strchr(ws, cl->buf[cl->len - 1]) != NULL
		    || ((cl->flags & CL_ALTWERASE)
			    && !isalpha(cl->buf[cl->len - 1])))
@


1.31
log
@Restore tty when aborting loop.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.30 2017/06/29 04:23:12 deraadt Exp $	*/
d782 2
@


1.30
log
@Switch TIOCSTAT to _IO().  Two decades ago it was mistakenly defined to
take an argument.  Discussed with millert and tedu.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.29 2017/06/27 15:02:18 anton Exp $	*/
d231 2
a232 1
	if (whyles)
d234 1
@


1.29
log
@Tweak previous: align declarations and rename local variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.28 2017/06/27 14:37:08 deraadt Exp $	*/
a369 2
	int	nothing = 0;

d371 1
a371 1
	ioctl(cl->fdin, TIOCSTAT, &nothing);
@


1.28
log
@in recently commited TIOCSTI replacement code, do not assume
little-endian or unsigned char :-)
ok anton
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.27 2017/06/22 18:05:31 anton Exp $	*/
d162 2
a163 2
	ssize_t	n;
	unsigned char c;
d201 1
a201 1
cl_putc(struct cmdline *cl, int ci)
d203 1
a203 1
	unsigned char c = ci;
d205 1
a205 1
	write(cl->fdout, &c, 1);
@


1.27
log
@
Make sure to abort loops when pressing ^C in csh.

Regression found by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.26 2017/06/21 19:36:23 anton Exp $	*/
d163 1
a163 1
	int	c;
d184 2
a185 2
	const char	*delimiters = " '\"\t;&<>()|^%";
	Char		*cp;
d201 1
a201 1
cl_putc(struct cmdline *cl, int c)
d203 2
d253 1
a253 1
	const char	*ws = " \t";
d767 1
a767 1
	char			 buf[BUFSIZ];
@


1.26
log
@Minor style(9) corrections and whitespace cleanup to csh.

ok deraadt@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.25 2017/06/21 18:55:15 anton Exp $	*/
d227 5
@


1.25
log
@Replace usage of TIOCSTI in csh using a more common IO-loop where ICANON is
disabled and a single char of input is read at a time. This requires the line
editing capabilities provided when ICANON is enabled to be implemented.

With help and feedback from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.24 2017/06/17 18:14:47 anton Exp $	*/
a32 2

#include <sys/types.h>
d35 2
a36 1
#include <termios.h>
d39 1
d43 1
a44 2
#include <limits.h>
#include <stdarg.h>
d63 1
a63 2
#define ESC	'\033'

d67 3
a69 2
    LIST, RECOGNIZE
}       COMMAND;
@


1.24
log
@Move win variable.

ok deraadt@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.23 2015/12/26 13:48:38 mestre Exp $	*/
d39 1
d42 1
a56 2
#define ON	1
#define OFF	0
d66 2
d72 34
a105 3
static void	 setup_tty(int);
static void	 back_to_col_1(void);
static void	 pushback(Char *);
a110 3
static void	 retype(void);
static void	 beep(void);
static void	 print_recognized_stuff(Char *);
d128 1
a128 1
setup_tty(int on)
d130 2
a131 1
    struct termios tchars;
d133 4
a136 1
    (void) tcgetattr(SHIN, &tchars);
d138 19
a156 7
    if (on) {
	tchars.c_cc[VEOL] = ESC;
	if (tchars.c_lflag & ICANON)
	    on = TCSADRAIN;
	else {
	    tchars.c_lflag |= ICANON;
	    on = TCSAFLUSH;
d158 42
a199 5
    }
    else {
	tchars.c_cc[VEOL] = _POSIX_VDISABLE;
	on = TCSADRAIN;
    }
d201 4
a204 1
    (void) tcsetattr(SHIN, on, &tchars);
a206 3
/*
 * Move back to beginning of current line
 */
d208 18
a225 1
back_to_col_1(void)
d227 4
a230 2
    struct termios tty, tty_normal;
    sigset_t sigset, osigset;
d232 29
a260 11
    sigemptyset(&sigset);
    sigaddset(&sigset, SIGINT);
    sigprocmask(SIG_BLOCK, &sigset, &osigset);
    (void) tcgetattr(SHOUT, &tty);
    tty_normal = tty;
    tty.c_iflag &= ~INLCR;
    tty.c_oflag &= ~ONLCR;
    (void) tcsetattr(SHOUT, TCSADRAIN, &tty);
    (void) write(SHOUT, "\r", 1);
    (void) tcsetattr(SHOUT, TCSADRAIN, &tty_normal);
    sigprocmask(SIG_SETMASK, &osigset, NULL);
a262 3
/*
 * Push string contents back into tty queue
 */
d264 53
a316 1
pushback(Char *string)
d318 81
a398 17
    Char *p;
    struct termios tty, tty_normal;
    sigset_t sigset, osigset;
    char    c;

    sigemptyset(&sigset);
    sigaddset(&sigset, SIGINT);
    sigprocmask(SIG_BLOCK, &sigset, &osigset);
    (void) tcgetattr(SHOUT, &tty);
    tty_normal = tty;
    tty.c_lflag &= ~(ECHOKE | ECHO | ECHOE | ECHOK | ECHONL | ECHOPRT | ECHOCTL);
    (void) tcsetattr(SHOUT, TCSADRAIN, &tty);

    for (p = string; (c = *p) != '\0'; p++)
	(void) ioctl(SHOUT, TIOCSTI, (ioctl_t) & c);
    (void) tcsetattr(SHOUT, TCSADRAIN, &tty_normal);
    sigprocmask(SIG_SETMASK, &osigset, NULL);
a531 52
 * Cause pending line to be printed
 */
static void
retype(void)
{
    struct termios tty;

    (void) tcgetattr(SHOUT, &tty);
    tty.c_lflag |= PENDIN;
    (void) tcsetattr(SHOUT, TCSADRAIN, &tty);
}

static void
beep(void)
{
    if (adrof(STRnobeep) == 0)
	(void) write(SHOUT, "\007", 1);
}

/*
 * Erase that silly ^[ and
 * print the recognized part of the string
 */
static void
print_recognized_stuff(Char *recognized_part)
{
    /* An optimized erasing of that silly ^[ */
    (void) fputc('\b', cshout);
    (void) fputc('\b', cshout);
    switch (Strlen(recognized_part)) {

    case 0:			/* erase two Characters: ^[ */
	(void) fputc(' ', cshout);
	(void) fputc(' ', cshout);
	(void) fputc('\b', cshout);
	(void) fputc('\b', cshout);
	break;

    case 1:			/* overstrike the ^, erase the [ */
	(void) fprintf(cshout, "%s", vis_str(recognized_part));
	(void) fputc(' ', cshout);
	(void) fputc('\b', cshout);
	break;

    default:			/* overstrike both Characters ^[ */
	(void) fprintf(cshout, "%s", vis_str(recognized_part));
	break;
    }
    (void) fflush(cshout);
}

/*
d746 43
a788 2
    int numitems, num_read;
    char    tinputline[BUFSIZ];
d790 1
a790 1
    setup_tty(ON);
d792 3
a794 37
    while ((num_read = read(SHIN, tinputline, BUFSIZ)) > 0) {
	int     i;
	static Char delims[] = {' ', '\'', '"', '\t', ';', '&', '<',
	'>', '(', ')', '|', '^', '%', '\0'};
	Char *str_end, *word_start, last_Char, should_retype;
	int space_left;
	COMMAND command;

	for (i = 0; i < num_read; i++)
	    inputline[i] = (unsigned char) tinputline[i];
	last_Char = inputline[num_read - 1] & ASCII;

	if (last_Char == '\n' || num_read == inputline_size)
	    break;
	command = (last_Char == ESC) ? RECOGNIZE : LIST;
	if (command == LIST)
	    (void) fputc('\n', cshout);
	str_end = &inputline[num_read];
	if (last_Char == ESC)
	    --str_end;		/* wipeout trailing cmd Char */
	*str_end = '\0';
	/*
	 * Find LAST occurrence of a delimiter in the inputline. The word start
	 * is one Character past it.
	 */
	for (word_start = str_end; word_start > inputline; --word_start)
	    if (Strchr(delims, word_start[-1]))
		break;
	space_left = inputline_size - (word_start - inputline) - 1;
	numitems = tsearch(word_start, command, space_left);

	if (command == RECOGNIZE) {
	    /* print from str_end on */
	    print_recognized_stuff(str_end);
	    if (numitems != 1)	/* Beep = No match/ambiguous */
		beep();
	}
d796 1
a796 20
	/*
	 * Tabs in the input line cause trouble after a pushback. tty driver
	 * won't backspace over them because column positions are now
	 * incorrect. This is solved by retyping over current line.
	 */
	should_retype = FALSE;
	if (Strchr(inputline, '\t')) {	/* tab Char in input line? */
	    back_to_col_1();
	    should_retype = TRUE;
	}
	if (command == LIST)	/* Always retype after a LIST */
	    should_retype = TRUE;
	if (should_retype)
	    printprompt();
	pushback(inputline);
	if (should_retype)
	    retype();
    }
    setup_tty(OFF);
    return (num_read);
@


1.23
log
@Replace handrolled xfree() function by directly using free(3)

OK mmcc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.22 2015/10/26 15:01:15 naddy Exp $	*/
a226 2
static struct winsize win;

d233 1
@


1.22
log
@unifdef BUILTIN (unused), NLS (always set), SHORT_STRINGS (always set)
and remove a few unused defines; no binary changes; ok tedu@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.21 2015/06/17 03:48:21 deraadt Exp $	*/
d393 2
a394 2
	xfree(items[i]);
    xfree(items);
@


1.21
log
@remove -DFILEC; code does not compile for the -UFILEC case, and anyways,
who wants csh without FILEC??
from Peter Brottveit Bock, but redone using unifdef
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.20 2015/06/03 01:49:35 deraadt Exp $	*/
a42 3
#ifndef SHORT_STRINGS
#include <string.h>
#endif /* SHORT_STRINGS */
@


1.20
log
@better description of internal copyn() function
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.19 2015/02/08 05:47:28 tedu Exp $	*/
a32 1
#ifdef FILEC
a646 1
#endif				/* FILEC */
@


1.19
log
@delete lots of unnecessary ptr_t casts, and drop a little NULL in as well
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.18 2015/01/16 06:39:31 deraadt Exp $	*/
d189 1
a189 2
 * Like strncpy but always leave room for trailing \0
 * and always null terminate.
@


1.18
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.17 2014/10/16 19:43:31 deraadt Exp $	*/
d398 2
a399 2
	xfree((ptr_t) items[i]);
    xfree((ptr_t) items);
d495 1
a495 1
	qsort((ptr_t) items, numitems, sizeof(*items),
@


1.17
log
@Use reallocarray() and remove a few archaic memory allocation practices.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.16 2009/10/27 23:59:21 deraadt Exp $	*/
d35 1
a35 1
#include <sys/param.h>
d43 1
d204 1
a204 1
    Char    path[MAXPATHLEN];
d285 1
a285 1
	Strlcpy(new, old, MAXPATHLEN);
d293 1
a293 1
	(void) Strlcpy(new, value(STRhome), MAXPATHLEN);
d298 1
a298 1
	(void) Strlcpy(new, str2short(pw->pw_dir), MAXPATHLEN);
d300 1
a300 1
    (void) Strlcat(new, o, MAXPATHLEN);
d421 1
a421 1
    Char    tilded_dir[MAXPATHLEN], dir[MAXPATHLEN];
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.15 2003/06/11 21:09:50 deraadt Exp $	*/
d453 1
a453 5
		if (items == NULL)
			items = (Char **) xmalloc(sizeof(*items) * maxitems);
		else
			items = (Char **) xrealloc((ptr_t) items,
			    sizeof(*items) * maxitems);
d455 1
a455 2
	    items[numitems] = (Char *) xmalloc((size_t) (Strlen(entry) + 1) *
					       sizeof(Char));
@


1.15
log
@de-register and ansify functions
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.14 2003/06/02 23:32:07 millert Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)file.c	8.2 (Berkeley) 3/19/94";
#else
static char rcsid[] = "$OpenBSD: file.c,v 1.14 2003/06/02 23:32:07 millert Exp $";
#endif
#endif /* not lint */
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.13 2003/01/08 06:54:16 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: file.c,v 1.13 2003/01/08 06:54:16 deraadt Exp $";
d109 1
a109 2
setup_tty(on)
    int     on;
d136 1
a136 1
back_to_col_1()
d158 1
a158 2
pushback(string)
    Char   *string;
d160 1
a160 1
    register Char *p;
d185 1
a185 3
catn(des, src, count)
    register Char *des, *src;
    register int count;
d200 1
a200 3
copyn(des, src, count)
    register Char *des, *src;
    register int count;
d209 1
a209 2
filetype(dir, file)
    Char   *dir, *file;
d245 1
a245 3
print_by_column(dir, items, count)
    Char   *dir, *items[];
    int     count;
d247 1
a247 1
    register int i, rows, r, c, maxwidth = 0, columns;
d262 1
a262 1
		register int w;
d285 1
a285 2
tilde(new, old)
    Char   *new, *old;
d287 2
a288 2
    register Char *o, *p;
    register struct passwd *pw;
d315 1
a315 1
retype()
d325 1
a325 1
beep()
d336 1
a336 2
print_recognized_stuff(recognized_part)
    Char   *recognized_part;
d368 1
a368 2
extract_dir_and_name(path, dir, name)
    Char   *path, *dir, *name;
d370 1
a370 1
    register Char *p;
d384 1
a384 3
getentry(dir_fd, looking_for_lognames)
    DIR    *dir_fd;
    int     looking_for_lognames;
d386 2
a387 2
    register struct passwd *pw;
    register struct dirent *dirp;
d400 1
a400 3
free_items(items, numitems)
    Char **items;
    int numitems;
d423 5
a427 8
tsearch(word, command, max_word_length)
    Char   *word;
    COMMAND command;
    int     max_word_length;
{
    register DIR *dir_fd;
    register int numitems = 0, ignoring = TRUE, nignored = 0;
    register int name_length, looking_for_lognames;
d526 1
a526 3
recognize(extended_name, entry, name_length, numitems)
    Char   *extended_name, *entry;
    int     name_length, numitems;
d531 2
a532 2
	register Char *x, *ent;
	register int len = 0;
d550 1
a550 2
is_prefix(check, template)
    register Char *check, *template;
d564 1
a564 2
is_suffix(check, template)
    Char   *check, *template;
d566 1
a566 1
    register Char *c, *t;
d581 1
a581 3
tenex(inputline, inputline_size)
    Char   *inputline;
    int     inputline_size;
d583 1
a583 1
    register int numitems, num_read;
a585 1

d592 2
a593 2
	register Char *str_end, *word_start, last_Char, should_retype;
	register int space_left;
d649 1
a649 2
ignored(entry)
    register Char *entry;
d652 1
a652 1
    register Char **cp;
@


1.13
log
@bring in strlcpy and strlcat-like things for dealing with Char types,
this fixes at least 15 buffer overflows; some help from dhartmei.
Anyone want to go do the same in ksh, and help with some of the while
(*s++ = *p++) loops in here?
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.12 2002/07/24 19:53:50 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: file.c,v 1.12 2002/07/24 19:53:50 millert Exp $";
@


1.12
log
@Fix a bug I inadvertanly introduced while fixing the last problem in here.
The item list really did want to be zero-filled since free_items() relies
on this to find the end point.  However, this is really pretty dumb since
we *know* how many items are in the list.

This highlights the elusive bug I was trying to fix--free_items() expects
the list to be NULL-terminated which was not the case if the list was full.
The fix is to simply pass free_items() the number of elements in the list.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.11 2002/07/15 22:10:13 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.11 2002/07/15 22:10:13 millert Exp $";
d225 2
a226 1
    catn(Strcpy(path, dir), file, sizeof(path) / sizeof(Char));
d305 4
a308 2
    if (old[0] != '~')
	return (Strcpy(new, old));
d314 1
a314 1
	(void) Strcpy(new, value(STRhome));
d319 1
a319 1
	(void) Strcpy(new, str2short(pw->pw_dir));
d321 1
a321 1
    (void) Strcat(new, o);
@


1.11
log
@Remove 1024 directory entry limit for tenex-style file completion.
This fixes a mysterious segv when doing file completion twice in
directories w/ more than 1024 files.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.10 2002/06/09 05:47:27 todd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.10 2002/06/09 05:47:27 todd Exp $";
d98 1
a98 1
static void	 free_items(Char **);
d415 3
a417 2
free_items(items)
    register Char **items;
d419 1
a419 1
    register int i;
d421 1
a421 1
    for (i = 0; items[i]; i++)
d432 1
a432 1
	free_items(items);\
d482 1
a482 1
			items = (Char **) xmalloc(sizeof(items[0]) * maxitems);
d485 1
a485 1
			    sizeof(items[0]) * maxitems);
d527 1
a527 1
	qsort((ptr_t) items, numitems, sizeof(items[0]),
@


1.10
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.9 2002/02/19 19:39:35 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.9 2002/02/19 19:39:35 millert Exp $";
a431 1
	items = NULL;\
a443 1
    static Char **items = NULL;
d450 2
a451 5

#define MAXITEMS 1024

    if (items != NULL)
	FREE_ITEMS(items);
d478 7
a484 5
	    if (numitems >= MAXITEMS) {
		(void) fprintf(csherr, "\nYikes!! Too many %s!!\n",
			       looking_for_lognames ?
			       "names in password file" : "files");
		break;
a485 2
	    if (items == NULL)
		items = (Char **) xcalloc(sizeof(items[0]), MAXITEMS);
@


1.9
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.8 2002/02/16 21:27:06 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.8 2002/02/16 21:27:06 millert Exp $";
d531 1
a531 1
	qsort((ptr_t) items, numitems, sizeof(items[0]), 
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.7 2001/12/01 19:10:39 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.7 2001/12/01 19:10:39 deraadt Exp $";
d58 1
a58 5
#ifdef __STDC__
# include <stdarg.h>
#else
# include <varargs.h>
#endif
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.6 1998/05/18 20:38:20 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.6 1998/05/18 20:38:20 deraadt Exp $";
d89 19
a107 19
static void	 setup_tty __P((int));
static void	 back_to_col_1 __P((void));
static void	 pushback __P((Char *));
static void	 catn __P((Char *, Char *, int));
static void	 copyn __P((Char *, Char *, int));
static Char	 filetype __P((Char *, Char *));
static void	 print_by_column __P((Char *, Char *[], int));
static Char	*tilde __P((Char *, Char *));
static void	 retype __P((void));
static void	 beep __P((void));
static void	 print_recognized_stuff __P((Char *));
static void	 extract_dir_and_name __P((Char *, Char *, Char *));
static Char	*getentry __P((DIR *, int));
static void	 free_items __P((Char **));
static int	 tsearch __P((Char *, COMMAND, int));
static int	 recognize __P((Char *, Char *, int, int));
static int	 is_prefix __P((Char *, Char *));
static int	 is_suffix __P((Char *, Char *));
static int	 ignored __P((Char *));
d536 1
a536 1
		(int (*) __P((const void *, const void *))) sortscmp);
@


1.6
log
@MAXPATHLEN not MAXPATHLEN+1
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.5 1997/11/15 21:51:29 todd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.5 1997/11/15 21:51:29 todd Exp $";
d451 2
a452 2
    register numitems = 0, ignoring = TRUE, nignored = 0;
    register name_length, looking_for_lognames;
@


1.5
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.4 1997/07/25 18:58:06 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.4 1997/07/25 18:58:06 mickey Exp $";
d453 1
a453 1
    Char    tilded_dir[MAXPATHLEN + 1], dir[MAXPATHLEN + 1];
@


1.4
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.3 1996/12/04 17:46:07 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.3 1996/12/04 17:46:07 millert Exp $";
d645 1
a645 1
	 * Find LAST occurence of a delimiter in the inputline. The word start
@


1.3
log
@use TCSADRAIN instead of TCSANOW, to avoid dropping characters.
Fix from NetBSD (christos), reported by Chris Torek.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.2 1996/06/23 14:19:22 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.2 1996/06/23 14:19:22 deraadt Exp $";
d58 1
a58 1
#if __STDC__
@


1.2
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: file.c,v 1.10 1995/03/21 18:35:39 mycroft Exp $	*/
/*	$NetBSD: file.c,v 1.10 1995/03/21 18:35:39 mycroft Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: file.c,v 1.10 1995/03/21 18:35:39 mycroft Exp $";
d157 1
a157 1
    (void) tcsetattr(SHOUT, TCSANOW, &tty);
d159 1
a159 1
    (void) tcsetattr(SHOUT, TCSANOW, &tty_normal);
d181 1
a181 1
    (void) tcsetattr(SHOUT, TCSANOW, &tty);
d185 1
a185 1
    (void) tcsetattr(SHOUT, TCSANOW, &tty_normal);
d336 1
a336 1
    (void) tcsetattr(SHOUT, TCSANOW, &tty);
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: file.c,v 1.10 1995/03/21 18:35:39 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
