head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.8
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.22
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.20
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.22
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.20
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.18
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.16
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.14
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.12
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.10
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.18
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.16
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.10.26.16.31.09;	author naddy;	state Exp;
branches;
next	1.18;
commitid	n73n1wzdFRm9vCM1;

1.18
date	2015.10.26.16.27.04;	author naddy;	state Exp;
branches;
next	1.17;
commitid	gkv6HkpvxAbQDUjv;

1.17
date	2015.10.26.15.01.15;	author naddy;	state Exp;
branches;
next	1.16;
commitid	gs7LRmKw8OfepnU6;

1.16
date	2014.10.16.19.43.31;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	jIHreojPTUQy0Zyb;

1.15
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.03.19.45.34;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.11.21.09.50;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.23.32.07;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.12.20.54.49;	author jsyn;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.30.21.06.10;	author vincent;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.15.01.17.33;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.08.01.46.53;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.08.06.54.16;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.07.25.18.58.18;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.07.23.14.36.52;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Remove the #define Strfoo() s_strfoo() redirection and move everything
directly to Strfoo().  Purely mechanical.  ok deraadt@@
@
text
@/*	$OpenBSD: str.c,v 1.18 2015/10/26 16:27:04 naddy Exp $	*/
/*	$NetBSD: str.c,v 1.6 1995/03/21 09:03:24 cgd Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define MALLOC_INCR	128

/*
 * tc.str.c: Short string package
 *	     This has been a lesson of how to write buggy code!
 */

#include <sys/types.h>
#include <stdarg.h>
#include <vis.h>

#include "csh.h"
#include "extern.h"

Char  **
blk2short(char **src)
{
    size_t     n;
    Char **sdst, **dst;

    /*
     * Count
     */
    for (n = 0; src[n] != NULL; n++)
	continue;
    sdst = dst = xreallocarray(NULL, n + 1, sizeof(Char *));

    for (; *src != NULL; src++)
	*dst++ = SAVE(*src);
    *dst = NULL;
    return (sdst);
}

char  **
short2blk(Char **src)
{
    size_t     n;
    char **sdst, **dst;

    /*
     * Count
     */
    for (n = 0; src[n] != NULL; n++)
	continue;
    sdst = dst = xreallocarray(NULL, n + 1, sizeof(char *));

    for (; *src != NULL; src++)
	*dst++ = strsave(short2str(*src));
    *dst = NULL;
    return (sdst);
}

Char   *
str2short(char *src)
{
    static Char *sdst;
    static size_t dstsize = 0;
    Char *dst, *edst;

    if (src == NULL)
	return (NULL);

    if (sdst == (NULL)) {
	dstsize = MALLOC_INCR;
	sdst = xreallocarray(NULL, dstsize, sizeof(Char));
    }

    dst = sdst;
    edst = &dst[dstsize];
    while (*src) {
	*dst++ = (Char) ((unsigned char) *src++);
	if (dst == edst) {
	    dstsize += MALLOC_INCR;
	    sdst = xreallocarray(sdst, dstsize, sizeof(Char));
	    edst = &sdst[dstsize];
	    dst = &edst[-MALLOC_INCR];
	}
    }
    *dst = 0;
    return (sdst);
}

char   *
short2str(Char *src)
{
    static char *sdst = NULL;
    static size_t dstsize = 0;
    char *dst, *edst;

    if (src == NULL)
	return (NULL);

    if (sdst == NULL) {
	dstsize = MALLOC_INCR;
	sdst = xreallocarray(NULL, dstsize, sizeof(char));
    }
    dst = sdst;
    edst = &dst[dstsize];
    while (*src) {
	*dst++ = (char) *src++;
	if (dst == edst) {
	    dstsize += MALLOC_INCR;
	    sdst = xreallocarray(sdst, dstsize, sizeof(char));
	    edst = &sdst[dstsize];
	    dst = &edst[-MALLOC_INCR];
	}
    }
    *dst = 0;
    return (sdst);
}

size_t
Strlcpy(Char *dst, const Char *src, size_t siz)
{
        Char *d = dst;
        const Char *s = src;
        size_t n = siz;

        /* Copy as many bytes as will fit */
        if (n != 0 && --n != 0) {
                do {
                        if ((*d++ = *s++) == 0)
                                break;
                } while (--n != 0);
        }

        /* Not enough room in dst, add NUL and traverse rest of src */
        if (n == 0) {
                if (siz != 0)
                        *d = '\0';              /* NUL-terminate dst */
                while (*s++)
                        ;
        }

        return(s - src - 1);    /* count does not include NUL */
}

size_t
Strlcat(Char *dst, const Char *src, size_t siz)
{
        Char *d = dst;
        const Char *s = src;
        size_t n = siz;
        size_t dlen;

        /* Find the end of dst and adjust bytes left but don't go past end */
        while (n-- != 0 && *d != '\0')
                d++;
        dlen = d - dst;
        n = siz - dlen;

        if (n == 0)
                return(dlen + Strlen((Char *)s));
        while (*s != '\0') {
                if (n != 1) {
                        *d++ = *s;
                        n--;
                }
                s++;
        }
        *d = '\0';

        return(dlen + (s - src));       /* count does not include NUL */
}

Char   *
Strchr(Char *str, int ch)
{
    do
	if (*str == ch)
	    return (str);
    while (*str++)
	;
    return (NULL);
}

Char   *
Strrchr(Char *str, int ch)
{
    Char *rstr;

    rstr = NULL;
    do
	if (*str == ch)
	    rstr = str;
    while (*str++)
	;
    return (rstr);
}

size_t
Strlen(Char *str)
{
    size_t n;

    for (n = 0; *str++; n++)
	continue;
    return (n);
}

int
Strcmp(Char *str1, Char *str2)
{
    for (; *str1 && *str1 == *str2; str1++, str2++)
	continue;
    /*
     * The following case analysis is necessary so that characters which look
     * negative collate low against normal characters but high against the
     * end-of-string NUL.
     */
    if (*str1 == '\0' && *str2 == '\0')
	return (0);
    else if (*str1 == '\0')
	return (-1);
    else if (*str2 == '\0')
	return (1);
    else
	return (*str1 - *str2);
}

int
Strncmp(Char *str1, Char *str2, size_t n)
{
    if (n == 0)
	return (0);
    do {
	if (*str1 != *str2) {
	    /*
	     * The following case analysis is necessary so that characters
	     * which look negative collate low against normal characters
	     * but high against the end-of-string NUL.
	     */
	    if (*str1 == '\0')
		return (-1);
	    else if (*str2 == '\0')
		return (1);
	    else
		return (*str1 - *str2);
	    break;
	}
	if (*str1 == '\0')
	    return(0);
	str1++, str2++;
    } while (--n != 0);
    return(0);
}

Char   *
Strsave(Char *s)
{
    Char   *n;
    Char *p;

    if (s == 0)
	s = STRNULL;
    for (p = s; *p++;)
	continue;
    n = p = xreallocarray(NULL, p - s, sizeof(Char));
    while ((*p++ = *s++) != '\0')
	continue;
    return (n);
}

Char   *
Strspl(Char *cp, Char *dp)
{
    Char   *ep;
    Char *p, *q;

    if (!cp)
	cp = STRNULL;
    if (!dp)
	dp = STRNULL;
    for (p = cp; *p++;)
	continue;
    for (q = dp; *q++;)
	continue;
    ep = xreallocarray(NULL, ((p - cp) + (q - dp) - 1), sizeof(Char));
    for (p = ep, q = cp; (*p++ = *q++) != '\0';)
	continue;
    for (p--, q = dp; (*p++ = *q++) != '\0';)
	continue;
    return (ep);
}

Char   *
Strend(Char *cp)
{
    if (!cp)
	return (cp);
    while (*cp)
	cp++;
    return (cp);
}

Char   *
Strstr(Char *s, Char *t)
{
    do {
	Char *ss = s;
	Char *tt = t;

	do
	    if (*tt == '\0')
		return (s);
	while (*ss++ == *tt++);
    } while (*s++ != '\0');
    return (NULL);
}

char   *
short2qstr(Char *src)
{
    static char *sdst = NULL;
    static size_t dstsize = 0;
    char *dst, *edst;

    if (src == NULL)
	return (NULL);

    if (sdst == NULL) {
	dstsize = MALLOC_INCR;
	sdst = xreallocarray(NULL, dstsize, sizeof(char));
    }
    dst = sdst;
    edst = &dst[dstsize];
    while (*src) {
	if (*src & QUOTE) {
	    *dst++ = '\\';
	    if (dst == edst) {
		dstsize += MALLOC_INCR;
		sdst = xreallocarray(sdst, dstsize, sizeof(char));
		edst = &sdst[dstsize];
		dst = &edst[-MALLOC_INCR];
	    }
	}
	*dst++ = (char) *src++;
	if (dst == edst) {
	    dstsize += MALLOC_INCR;
	    sdst = xreallocarray(sdst, dstsize, sizeof(char));
	    edst = &sdst[dstsize];
	    dst = &edst[-MALLOC_INCR];
	}
    }
    *dst = 0;
    return (sdst);
}

/*
 * XXX: Should we worry about QUOTE'd chars?
 */
char *
vis_str(Char *cp)
{
    static char *sdst = NULL;
    static size_t dstsize = 0;
    size_t n;
    Char *dp;

    if (cp == NULL)
	return (NULL);

    for (dp = cp; *dp++;)
	continue;
    n = ((dp - cp) << 2) + 1; /* 4 times + NUL */
    if (dstsize < n) {
	sdst = xreallocarray(sdst, n, sizeof(char));
	dstsize = n;
    }
    (void) strnvis(sdst, short2str(cp), dstsize, VIS_NOSLASH);
    return (sdst);
}

@


1.18
log
@Clean up cruft made visible by the NLS unifdefing:
* remove setlocale() calls
* remove write-only variable AsciiOnly
* remove now unused string constants STRLANG, STRLC_CTYPE
* remove hardcoded support for ISO8859-1

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.17 2015/10/26 15:01:15 naddy Exp $	*/
d145 1
a145 1
s_strlcpy(Char *dst, const Char *src, size_t siz)
d171 1
a171 1
s_strlcat(Char *dst, const Char *src, size_t siz)
d185 1
a185 1
                return(dlen + s_strlen((Char *)s));
d199 1
a199 1
s_strchr(Char *str, int ch)
d210 1
a210 1
s_strrchr(Char *str, int ch)
d224 1
a224 1
s_strlen(Char *str)
d234 1
a234 1
s_strcmp(Char *str1, Char *str2)
d254 1
a254 1
s_strncmp(Char *str1, Char *str2, size_t n)
d281 1
a281 1
s_strsave(Char *s)
d297 1
a297 1
s_strspl(Char *cp, Char *dp)
d319 1
a319 1
s_strend(Char *cp)
d329 1
a329 1
s_strstr(Char *s, Char *t)
@


1.17
log
@unifdef BUILTIN (unused), NLS (always set), SHORT_STRINGS (always set)
and remove a few unused defines; no binary changes; ok tedu@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.16 2014/10/16 19:43:31 deraadt Exp $	*/
a401 4
    /*
     * XXX: When we are in AsciiOnly we want all characters >= 0200 to
     * be encoded, but currently there is no way in vis to do that.
     */
@


1.16
log
@Use reallocarray() and remove a few archaic memory allocation practices.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.15 2009/10/27 23:59:21 deraadt Exp $	*/
a46 2
#ifdef SHORT_STRINGS

a341 1
#endif				/* SHORT_STRINGS */
@


1.15
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.14 2008/10/03 19:45:34 deraadt Exp $	*/
d60 1
a60 1
    sdst = dst = (Char **) xmalloc((size_t) ((n + 1) * sizeof(Char *)));
d79 1
a79 1
    sdst = dst = (char **) xmalloc((size_t) ((n + 1) * sizeof(char *)));
d99 1
a99 1
	sdst = (Char *) xmalloc((size_t) dstsize * sizeof(Char));
d108 1
a108 2
	    sdst = (Char *) xrealloc((ptr_t) sdst,
				     (size_t) dstsize * sizeof(Char));
d129 1
a129 1
	sdst = (char *) xmalloc((size_t) dstsize * sizeof(char));
d137 1
a137 2
	    sdst = (char *) xrealloc((ptr_t) sdst,
				     (size_t) dstsize * sizeof(char));
d292 1
a292 1
    n = p = (Char *) xmalloc((size_t) ((p - s) * sizeof(Char)));
d312 1
a312 2
    ep = (Char *) xmalloc((size_t)
			  (((p - cp) + (q - dp) - 1) * sizeof(Char)));
d358 1
a358 1
	sdst = (char *) xmalloc((size_t) dstsize * sizeof(char));
d367 1
a367 2
		sdst = (char *) xrealloc((ptr_t) sdst,
					 (size_t) dstsize * sizeof(char));
d375 1
a375 2
	    sdst = (char *) xrealloc((ptr_t) sdst,
				     (size_t) dstsize * sizeof(char));
d402 1
a402 3
	sdst = (char *) (dstsize ?
			    xrealloc(sdst, (size_t) n * sizeof(char)) :
			    xmalloc((size_t) n * sizeof(char)));
@


1.14
log
@NUL not NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.13 2003/06/11 21:09:50 deraadt Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)str.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: str.c,v 1.13 2003/06/11 21:09:50 deraadt Exp $";
#endif
#endif /* not lint */
@


1.13
log
@de-register and ansify functions
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.12 2003/06/02 23:32:07 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: str.c,v 1.12 2003/06/02 23:32:07 millert Exp $";
d413 1
a413 1
    n = ((dp - cp) << 2) + 1; /* 4 times + NULL */
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.11 2003/05/12 20:54:49 jsyn Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: str.c,v 1.11 2003/05/12 20:54:49 jsyn Exp $";
d58 1
a58 2
blk2short(src)
    register char **src;
d61 1
a61 1
    register Char **sdst, **dst;
d77 1
a77 2
short2blk(src)
    register Char **src;
d80 1
a80 1
    register char **sdst, **dst;
d96 1
a96 2
str2short(src)
    register char *src;
d100 1
a100 1
    register Char *dst, *edst;
d127 1
a127 2
short2str(src)
    register Char *src;
d131 1
a131 1
    register char *dst, *edst;
d157 5
a161 8
s_strlcpy(dst, src, siz)
        Char *dst;
        const Char *src;
        size_t siz;
{
        register Char *d = dst;
        register const Char *s = src;
        register size_t n = siz;
d183 5
a187 8
s_strlcat(dst, src, siz)
        Char *dst;
        const Char *src;
        size_t siz;
{
        register Char *d = dst;
        register const Char *s = src;
        register size_t n = siz;
d211 1
a211 3
s_strchr(str, ch)
    register Char *str;
    int ch;
d222 1
a222 3
s_strrchr(str, ch)
    register Char *str;
    int ch;
d224 1
a224 1
    register Char *rstr;
d236 1
a236 2
s_strlen(str)
    register Char *str;
d238 1
a238 1
    register size_t n;
d246 1
a246 2
s_strcmp(str1, str2)
    register Char *str1, *str2;
d266 1
a266 3
s_strncmp(str1, str2, n)
    register Char *str1, *str2;
    register size_t n;
d293 1
a293 2
s_strsave(s)
    register Char *s;
d296 1
a296 1
    register Char *p;
d309 1
a309 2
s_strspl(cp, dp)
    Char   *cp, *dp;
d312 1
a312 1
    register Char *p, *q;
d332 1
a332 2
s_strend(cp)
    register Char *cp;
d342 1
a342 2
s_strstr(s, t)
    register Char *s, *t;
d345 2
a346 2
	register Char *ss = s;
	register Char *tt = t;
d358 1
a358 2
short2qstr(src)
    register Char *src;
d362 1
a362 1
    register char *dst, *edst;
d401 1
a401 2
vis_str(cp)
    Char *cp;
@


1.11
log
@s_strn{cpy,cat} are no longer used; remove them.  also, kill NOTUSED.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.10 2003/04/30 21:06:10 vincent Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: str.c,v 1.10 2003/04/30 21:06:10 vincent Exp $";
@


1.10
log
@strvis -> strnvis

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.9 2003/04/15 01:17:33 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: str.c,v 1.9 2003/04/15 01:17:33 deraadt Exp $";
a222 51

Char   *
s_strncpy(dst, src, n)
    register Char *dst, *src;
    register size_t n;
{
    register Char *sdst;

    if (n == 0)
	return(dst);

    sdst = dst;
    do
	if ((*dst++ = *src++) == '\0') {
	    while (--n != 0)
		*dst++ = '\0';
	    return(sdst);
	}
    while (--n != 0)
	;
    return (sdst);
}

#ifdef NOTUSED
Char   *
s_strncat(dst, src, n)
    register Char *dst, *src;
    register size_t n;
{
    register Char *sdst;

    if (n == 0)
	return (dst);

    sdst = dst;

    while (*dst++)
	continue;
    --dst;

    do
	if ((*dst++ = *src++) == '\0')
	    return(sdst);
    while (--n != 0)
	continue;

    *dst = '\0';
    return (sdst);
}

#endif
@


1.9
log
@remove final call to Strcpy/s_strcpy; some help from tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.8 2003/04/08 01:46:53 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: str.c,v 1.8 2003/04/08 01:46:53 deraadt Exp $";
d503 1
a503 1
    (void) strvis(sdst, short2str(cp), VIS_NOSLASH);
@


1.8
log
@Strcat/s_strcat is unused
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.7 2003/01/08 06:54:16 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: str.c,v 1.7 2003/01/08 06:54:16 deraadt Exp $";
a160 12
    return (sdst);
}

Char   *
s_strcpy(dst, src)
    register Char *dst, *src;
{
    register Char *sdst;

    sdst = dst;
    while ((*dst++ = *src++) != '\0')
	continue;
@


1.7
log
@bring in strlcpy and strlcat-like things for dealing with Char types,
this fixes at least 15 buffer overflows; some help from dhartmei.
Anyone want to go do the same in ksh, and help with some of the while
(*s++ = *p++) loops in here?
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.6 2002/06/09 05:47:27 todd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: str.c,v 1.6 2002/06/09 05:47:27 todd Exp $";
a254 15
    return (sdst);
}

Char   *
s_strcat(dst, src)
    register Char *dst, *src;
{
    register short *sdst;

    sdst = dst;
    while (*dst++)
	continue;
    --dst;
    while ((*dst++ = *src++) != '\0')
	continue;
@


1.6
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.5 2002/02/19 19:39:35 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: str.c,v 1.5 2002/02/19 19:39:35 millert Exp $";
d176 60
d253 2
a254 1
    while (--n != 0);
d310 2
a311 1
    while (*str++);
d326 2
a327 1
    while (*str++);
@


1.5
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.4 1997/07/25 18:58:18 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: str.c,v 1.4 1997/07/25 18:58:18 mickey Exp $";
d453 1
a453 1
    
d458 1
a458 1
	sdst = (char *) (dstsize ? 
d463 1
a463 1
    /* 
d470 1
a470 1
    
@


1.4
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.3 1997/07/23 14:36:52 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: str.c,v 1.3 1997/07/23 14:36:52 kstailey Exp $";
d53 1
a53 5
#ifdef __STDC__
# include <stdarg.h>
#else
# include <varargs.h>
#endif
@


1.3
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.2 1996/06/23 14:19:31 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: str.c,v 1.2 1996/06/23 14:19:31 deraadt Exp $";
d53 1
a53 1
#if __STDC__
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.6 1995/03/21 09:03:24 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: str.c,v 1.6 1995/03/21 09:03:24 cgd Exp $";
d326 1
a326 1
        if (*str1 == '\0')
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: str.c,v 1.6 1995/03/21 09:03:24 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
