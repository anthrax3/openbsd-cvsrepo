head	1.16;
access;
symbols
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2003.06.23.16.42.15;	author deraadt;	state dead;
branches;
next	1.15;

1.15
date	2003.06.23.16.40.44;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.11.21.09.50;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.32.07;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.14.20.47.32;	author jsyn;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.22.22.53.10;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.22.20.24.47;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.08.25.13.35.17;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.09.22.05.09.14;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.40.22;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.12.17.41;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.09.15.22.00.26;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.08.02.12.40.52;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@kill printf builtin.  no reason to be a builtin, but furthermore, the
handling of format strings is quite non-compliant.
@
text
@/*	$OpenBSD: printf.c,v 1.15 2003/06/23 16:40:44 millert Exp $	*/
/*	$NetBSD: printf.c,v 1.6 1995/03/21 09:03:15 cgd Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if !defined(BUILTIN)
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */
#endif

#ifndef lint
#if 0
static char sccsid[] = "@@(#)printf.c	8.1 (Berkeley) 7/20/93";
#else
static char rcsid[] = "$OpenBSD: printf.c,v 1.15 2003/06/23 16:40:44 millert Exp $";
#endif
#endif /* not lint */

#include <sys/types.h>

#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <err.h>

#define PF(f, func) { \
	if (fieldwidth) \
		if (precision) \
			(void)printf(f, fieldwidth, precision, func); \
		else \
			(void)printf(f, fieldwidth, func); \
	else if (precision) \
		(void)printf(f, precision, func); \
	else \
		(void)printf(f, func); \
}

static int	 asciicode(void);
static void	 escape(char *);
static int	 getchr(void);
static double	 getdouble(void);
static int	 getint(int *);
static int	 getlong(long *);
static char	*getstr(void);
static char	*mklong(char *, int);
#ifdef BUILTIN
int		 progprintf(int, char **);
#endif /* BUILTIN */
static void	 usage(void);

static char **gargv;

int
#ifdef BUILTIN
progprintf(int argc, char *argv[])
#else
main(int argc, char *argv[])
#endif
{
	static char *skip1, *skip2;
	int ch, end, fieldwidth, precision;
	char convch, nextch, *format, *fmt, *start;

	if (argc < 2) {
		usage();
		return (1);
	}

	/*
	 * Basic algorithm is to scan the format string for conversion
	 * specifications -- once one is found, find out if the field
	 * width or precision is a '*'; if it is, gather up value.  Note,
	 * format strings are reused as necessary to use up the provided
	 * arguments, arguments of zero/null string are provided to use
	 * up the format string.
	 */
	skip1 = "#-+ 0";
	skip2 = "*0123456789";

	escape(fmt = format = *++argv);		/* backslash interpretation */
	gargv = ++argv;
	for (;;) {
		end = 0;
		/* find next format specification */
next:		for (start = fmt;; ++fmt) {
			if (!*fmt) {
				/* avoid infinite loop */
				if (end == 1) {
					warnx("missing format character");
					return (1);
				}
				end = 1;
				if (fmt > start)
					(void)printf("%s", start);
				if (!*gargv)
					return (0);
				fmt = format;
				goto next;
			}
			/* %% prints a % */
			if (*fmt == '%') {
				if (*++fmt != '%')
					break;
				*fmt++ = '\0';
				(void)printf("%s", start);
				goto next;
			}
		}

		/* skip to field width */
		for (; strchr(skip1, *fmt); ++fmt);
		if (*fmt == '*') {
			if (getint(&fieldwidth))
				return (1);
		} else
			fieldwidth = 0;

		/* skip to possible '.', get following precision */
		for (; strchr(skip2, *fmt); ++fmt);
		if (*fmt == '.')
			++fmt;
		if (*fmt == '*') {
			if (getint(&precision))
				return (1);
		} else
			precision = 0;

		/* skip to conversion char */
		for (; strchr(skip2, *fmt); ++fmt);
		if (!*fmt) {
			warnx("missing format character");
			return (1);
		}

		convch = *fmt;
		nextch = *++fmt;
		*fmt = '\0';
		switch(convch) {
		case 'c': {
			char p;

			p = getchr();
			PF(start, p);
			break;
		}
		case 's': {
			char *p;

			p = getstr();
			PF(start, p);
			break;
		}
		case 'd': case 'i': case 'o': case 'u': case 'x': case 'X': {
			long p;
			char *f;
			
			if ((f = mklong(start, convch)) == NULL)
				return (1);
			if (getlong(&p))
				return (1);
			PF(f, p);
			break;
		}
		case 'e': case 'E': case 'f': case 'g': case 'G': {
			double p;

			p = getdouble();
			PF(start, p);
			break;
		}
		default:
			warnx("illegal format character");
			return (1);
		}
		*fmt = nextch;
	}
	/* NOTREACHED */
}

static char *
mklong(char *str, int ch)
{
	static char *copy;
	static int copysize;
	int len;

	len = strlen(str) + 2;
	if (copysize < len) {
		char *newcopy;
		copysize = len + 256;

		newcopy = realloc(copy, copysize);
		if (newcopy == NULL) {
			copysize = 0;
			free(copy);
			copy = NULL;
			return (NULL);
		}
		copy = newcopy;
	}
	memmove(copy, str, len - 3);
	copy[len - 3] = 'l';
	copy[len - 2] = ch;
	copy[len - 1] = '\0';
	return (copy);
}

static void
escape(char *fmt)
{
	char *store;
	int value, c;

	for (store = fmt; (c = *fmt) != 0; ++fmt, ++store) {
		if (c != '\\') {
			*store = c;
			continue;
		}
		switch (*++fmt) {
		case '\0':		/* EOS, user error */
			*store = '\\';
			*++store = '\0';
			return;
		case '\\':		/* backslash */
		case '\'':		/* single quote */
			*store = *fmt;
			break;
		case 'a':		/* bell/alert */
			*store = '\7';
			break;
		case 'e':		/* escape */
			*store = '\033';
			break;
		case 'b':		/* backspace */
			*store = '\b';
			break;
		case 'f':		/* form-feed */
			*store = '\f';
			break;
		case 'n':		/* newline */
			*store = '\n';
			break;
		case 'r':		/* carriage-return */
			*store = '\r';
			break;
		case 't':		/* horizontal tab */
			*store = '\t';
			break;
		case 'v':		/* vertical tab */
			*store = '\13';
			break;
					/* octal constant */
		case '0': case '1': case '2': case '3':
		case '4': case '5': case '6': case '7':
			for (c = 3, value = 0;
			    c-- && *fmt >= '0' && *fmt <= '7'; ++fmt) {
				value <<= 3;
				value += *fmt - '0';
			}
			--fmt;
			*store = value;
			break;
		default:
			*store = *fmt;
			break;
		}
	}
	*store = '\0';
}

static int
getchr(void)
{
	if (!*gargv)
		return ('\0');
	return ((int)**gargv++);
}

static char *
getstr(void)
{
	if (!*gargv)
		return ("");
	return (*gargv++);
}

static char *Number = "+-.0123456789";
static int
getint(int *ip)
{
	long val;

	if (getlong(&val))
		return (1);
	if (val > INT_MAX) {
		warnx("%s: %s", *gargv, strerror(ERANGE));
		return (1);
	}
	*ip = val;
	return (0);
}

static int
getlong(long *lp)
{
	long val;
	char *ep;

	if (!*gargv) {
		*lp = 0;
		return (0);
	}
	if (strchr(Number, **gargv)) {
		errno = 0;
		val = strtol(*gargv, &ep, 0);
		if (*ep != '\0') {
			warnx("%s: illegal number", *gargv);
			return (1);
		}
		if (errno == ERANGE)
			if (val == LONG_MAX) {
				warnx("%s: %s", *gargv, strerror(ERANGE));
				return (1);
			}
			if (val == LONG_MIN) {
				warnx("%s: %s", *gargv, strerror(ERANGE));
				return (1);
			}
			
		*lp = val;
		++gargv;
		return (0);
	}
	*lp =  (long)asciicode();
	return (0);
}

static double
getdouble(void)
{
	if (!*gargv)
		return ((double)0);
	if (strchr(Number, **gargv))
		return (atof(*gargv++));
	return ((double)asciicode());
}

static int
asciicode(void)
{
	int ch;

	ch = **gargv;
	if (ch == '\'' || ch == '"')
		ch = (*gargv)[1];
	++gargv;
	return (ch);
}

static void
usage(void)
{
	(void)fprintf(stderr, "usage: printf format [arg ...]\n");
}
@


1.15
log
@Don't not use getopt() in printf(1) since it causes formats beginning
with a '-' to be interpreted as flags.  Noticed by Alan Barrett.
There is really no reason for this to be a builtin in csh...
@
text
@d1 1
a1 1
/*	$OpenBSD: printf.c,v 1.14 2003/06/11 21:09:50 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: printf.c,v 1.14 2003/06/11 21:09:50 deraadt Exp $";
@


1.14
log
@de-register and ansify functions
@
text
@d1 1
a1 1
/*	$OpenBSD: printf.c,v 1.13 2003/06/02 23:32:07 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: printf.c,v 1.13 2003/06/02 23:32:07 millert Exp $";
d97 1
a97 10
	while ((ch = getopt(argc, argv, "")) != -1)
		switch (ch) {
		default:
			usage();
			return (1);
		}
	argc -= optind;
	argv += optind;

	if (argc < 1) {
d113 1
a113 1
	escape(fmt = format = *argv);		/* backslash interpretation */
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: printf.c,v 1.12 2003/05/14 20:47:32 jsyn Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: printf.c,v 1.12 2003/05/14 20:47:32 jsyn Exp $";
d88 1
a88 1
progprintf(argc, argv)
d90 1
a90 1
main(argc, argv)
a91 2
	int argc;
	char *argv[];
d223 1
a223 3
mklong(str, ch)
	char *str;
	int ch;
d251 1
a251 2
escape(fmt)
	register char *fmt;
d253 2
a254 2
	register char *store;
	register int value, c;
d314 1
a314 1
getchr()
d322 1
a322 1
getstr()
d331 1
a331 2
getint(ip)
	int *ip;
d346 1
a346 2
getlong(lp)
	long *lp;
d381 1
a381 1
getdouble()
d391 1
a391 1
asciicode()
d393 1
a393 1
	register int ch;
d403 1
a403 1
usage()
@


1.12
log
@add missing prototype; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printf.c,v 1.11 2002/02/16 21:27:06 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d45 1
a45 1
static char rcsid[] = "$OpenBSD: printf.c,v 1.11 2002/02/16 21:27:06 millert Exp $";
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: printf.c,v 1.10 2000/12/22 22:53:10 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: printf.c,v 1.10 2000/12/22 22:53:10 deraadt Exp $";
d83 3
@


1.10
log
@repair same static buf oflow in printf(1) and printf(1) internal inside csh(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: printf.c,v 1.9 2000/01/22 20:24:47 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: printf.c,v 1.9 2000/01/22 20:24:47 deraadt Exp $";
d75 9
a83 9
static int	 asciicode __P((void));
static void	 escape __P((char *));
static int	 getchr __P((void));
static double	 getdouble __P((void));
static int	 getint __P((int *));
static int	 getlong __P((long *));
static char	*getstr __P((void));
static char	*mklong __P((char *, int));
static void	 usage __P((void));
@


1.9
log
@remove extra externs not needed because of unistd.h (rest of tree will be done later.. contact me if you want to help)
@
text
@d1 1
a1 1
/*	$OpenBSD: printf.c,v 1.8 1998/08/25 13:35:17 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: printf.c,v 1.8 1998/08/25 13:35:17 deraadt Exp $";
d230 2
a231 1
	static char copy[64];
d235 13
@


1.8
log
@support \e in built-in printf
@
text
@d1 1
a1 1
/*	$OpenBSD: printf.c,v 1.7 1997/09/22 05:09:14 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: printf.c,v 1.7 1997/09/22 05:09:14 millert Exp $";
d59 1
a95 1
	extern int optind;
@


1.7
log
@err.[ch] -> error.[ch] and fix err/warn usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: printf.c,v 1.6 1997/01/15 23:40:22 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: printf.c,v 1.6 1997/01/15 23:40:22 millert Exp $";
d264 3
@


1.6
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: printf.c,v 1.5 1996/12/14 12:17:41 mickey Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: printf.c,v 1.5 1996/12/14 12:17:41 mickey Exp $";
d134 1
a134 2
					warnx("missing format character",
					    NULL, NULL);
d176 1
a176 1
			warnx("missing format character", NULL, NULL);
d217 1
a217 1
			warnx("illegal format character", NULL, NULL);
d350 1
a350 1
			warnx("%s: illegal number", *gargv, NULL);
@


1.5
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: printf.c,v 1.4 1996/09/15 22:00:26 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: printf.c,v 1.4 1996/09/15 22:00:26 millert Exp $";
d100 1
a100 1
	while ((ch = getopt(argc, argv, "")) != EOF)
@


1.4
log
@fix a typo and vsprintf -> vsnprintf paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: printf.c,v 1.3 1996/08/02 12:40:52 deraadt Exp $	*/
d37 1
a37 1
#if !defined(BUILTIN) && !defined(SHELL)
d49 1
a49 1
static char rcsid[] = "$OpenBSD: printf.c,v 1.3 1996/08/02 12:40:52 deraadt Exp $";
a54 1
#include <err.h>
a56 3
#ifdef SHELL
#define	EOF	-1
#else
a57 1
#endif
d60 1
a60 14

/*
 * XXX
 * This *has* to go away.  TK.
 */
#ifdef SHELL
#define main printfcmd
#define warnx(a, b, c) {						\
	char buf[64];							\
	(void)snprintf(buf, sizeof(buf), a, b, c);			\
	error(buf);							\
}
#include "../../bin/sh/bltin/bltin.h"
#endif
d249 1
a249 1
	for (store = fmt; c = *fmt; ++fmt, ++store) {
@


1.3
log
@zap getopt() case of -?, come on, it is the default!
@
text
@d1 1
a1 1
/*	$OpenBSD: printf.c,v 1.2 1996/06/23 14:19:27 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: printf.c,v 1.2 1996/06/23 14:19:27 deraadt Exp $";
d74 1
a74 1
	(void)sprintf(buf, sizeof(buf), a, b, c);			\
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: printf.c,v 1.6 1995/03/21 09:03:15 cgd Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: printf.c,v 1.6 1995/03/21 09:03:15 cgd Exp $";
a119 1
		case '?':
@


1.1
log
@Initial revision
@
text
@d1 1
d49 1
a49 1
static char rcsid[] = "$NetBSD: printf.c,v 1.6 1995/03/21 09:03:15 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
