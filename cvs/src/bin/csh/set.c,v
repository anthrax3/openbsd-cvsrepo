head	1.19;
access;
symbols
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.12.0.22
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.20
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.10.0.28
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.24
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.22
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.20
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.18
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.16
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.14
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.4.0.16
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.14
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.12
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.10
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.8
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.12.26.13.48.38;	author mestre;	state Exp;
branches;
next	1.18;
commitid	jZMsEASvreUUSdqp;

1.18
date	2015.10.26.22.03.06;	author naddy;	state Exp;
branches;
next	1.17;
commitid	jREL04iPW8d08lKc;

1.17
date	2015.10.26.15.01.15;	author naddy;	state Exp;
branches;
next	1.16;
commitid	gs7LRmKw8OfepnU6;

1.16
date	2015.09.29.20.10.41;	author guenther;	state Exp;
branches;
next	1.15;
commitid	RXDjmViCsFkFp2WB;

1.15
date	2015.06.17.03.48.21;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	oHdhnDXEPqwM6LiV;

1.14
date	2015.02.08.05.47.28;	author tedu;	state Exp;
branches;
next	1.13;
commitid	UHj0KNSjy07xS7rI;

1.13
date	2014.10.16.19.43.31;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	jIHreojPTUQy0Zyb;

1.12
date	2009.10.28.02.03.47;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.11.21.09.50;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.32.07;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.08.06.54.16;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.01.19.10.39;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.11.15.21.51.30;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	97.07.25.18.58.17;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.30;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Replace handrolled xfree() function by directly using free(3)

OK mmcc@@
@
text
@/*	$OpenBSD: set.c,v 1.18 2015/10/26 22:03:06 naddy Exp $	*/
/*	$NetBSD: set.c,v 1.8 1995/03/21 18:35:52 mycroft Exp $	*/

/*-
 * Copyright (c) 1980, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <stdlib.h>
#include <stdarg.h>

#include "csh.h"
#include "extern.h"

static Char	*getinx(Char *, int *);
static void	 asx(Char *, int, Char *);
static struct varent
		*getvx(Char *, int);
static Char	*xset(Char *, Char ***);
static Char	*operate(int, Char *, Char *);
static struct varent
		*madrof(Char *, struct varent *);
static void	 unsetv1(struct varent *);
static void	 exportpath(Char **);
static void	 balance(struct varent *, int, int);


/*
 * C Shell
 */

void
/*ARGSUSED*/
doset(Char **v, struct command *t)
{
    Char *p;
    Char   *vp, op;
    Char  **vecp;
    bool    hadsub;
    int     subscr;

    v++;
    p = *v++;
    if (p == 0) {
	prvars();
	return;
    }
    do {
	hadsub = 0;
	vp = p;
	if (letter(*p))
	    for (; alnum(*p); p++)
		continue;
	if (vp == p || !letter(*vp))
	    stderror(ERR_NAME | ERR_VARBEGIN);
	if ((p - vp) > MAXVARLEN) {
	    stderror(ERR_NAME | ERR_VARTOOLONG);
	    return;
	}
	if (*p == '[') {
	    hadsub++;
	    p = getinx(p, &subscr);
	}
	if ((op = *p) != '\0') {
	    *p++ = 0;
	    if (*p == 0 && *v && **v == '(')
		p = *v++;
	}
	else if (*v && eq(*v, STRequal)) {
	    op = '=', v++;
	    if (*v)
		p = *v++;
	}
	if (op && op != '=')
	    stderror(ERR_NAME | ERR_SYNTAX);
	if (eq(p, STRLparen)) {
	    Char **e = v;

	    if (hadsub)
		stderror(ERR_NAME | ERR_SYNTAX);
	    for (;;) {
		if (!*e)
		    stderror(ERR_NAME | ERR_MISSING, ')');
		if (**e == ')')
		    break;
		e++;
	    }
	    p = *e;
	    *e = 0;
	    vecp = saveblk(v);
	    set1(vp, vecp, &shvhed);
	    *e = p;
	    v = e + 1;
	}
	else if (hadsub)
	    asx(vp, subscr, Strsave(p));
	else
	    set(vp, Strsave(p));
	if (eq(vp, STRpath)) {
	    exportpath(adrof(STRpath)->vec);
	    dohash(NULL, NULL);
	}
	else if (eq(vp, STRhistchars)) {
	    Char *pn = value(STRhistchars);

	    HIST = *pn++;
	    HISTSUB = *pn;
	}
	else if (eq(vp, STRuser)) {
	    Setenv(STRUSER, value(vp));
	    Setenv(STRLOGNAME, value(vp));
	}
	else if (eq(vp, STRwordchars)) {
	    word_chars = value(vp);
	}
	else if (eq(vp, STRterm))
	    Setenv(STRTERM, value(vp));
	else if (eq(vp, STRhome)) {
	    Char *cp;

	    cp = Strsave(value(vp));	/* get the old value back */

	    /*
	     * convert to canonical pathname (possibly resolving symlinks)
	     */
	    cp = dcanon(cp, cp);

	    set(vp, Strsave(cp));	/* have to save the new val */

	    /* and now mirror home with HOME */
	    Setenv(STRHOME, cp);
	    /* fix directory stack for new tilde home */
	    dtilde();
	    free(cp);
	}
	else if (eq(vp, STRfilec))
	    filec = 1;
    } while ((p = *v++) != NULL);
}

static Char *
getinx(Char *cp, int *ip)
{

    *ip = 0;
    *cp++ = 0;
    while (*cp && Isdigit(*cp))
	*ip = *ip * 10 + *cp++ - '0';
    if (*cp++ != ']')
	stderror(ERR_NAME | ERR_SUBSCRIPT);
    return (cp);
}

static void
asx(Char *vp, int subscr, Char *p)
{
    struct varent *v = getvx(vp, subscr);

    free(v->vec[subscr - 1]);
    v->vec[subscr - 1] = globone(p, G_APPEND);
}

static struct varent *
getvx(Char *vp, int subscr)
{
    struct varent *v = adrof(vp);

    if (v == 0)
	udvar(vp);
    if (subscr < 1 || subscr > blklen(v->vec))
	stderror(ERR_NAME | ERR_RANGE);
    return (v);
}

void
/*ARGSUSED*/
dolet(Char **v, struct command *t)
{
    Char *p;
    Char   *vp, c, op;
    bool    hadsub;
    int     subscr;

    v++;
    p = *v++;
    if (p == 0) {
	prvars();
	return;
    }
    do {
	hadsub = 0;
	vp = p;
	if (letter(*p))
	    for (; alnum(*p); p++)
		continue;
	if (vp == p || !letter(*vp))
	    stderror(ERR_NAME | ERR_VARBEGIN);
	if ((p - vp) > MAXVARLEN)
	    stderror(ERR_NAME | ERR_VARTOOLONG);
	if (*p == '[') {
	    hadsub++;
	    p = getinx(p, &subscr);
	}
	if (*p == 0 && *v)
	    p = *v++;
	if ((op = *p) != '\0')
	    *p++ = 0;
	else
	    stderror(ERR_NAME | ERR_ASSIGN);

	if (*p == '\0' && *v == NULL)
	    stderror(ERR_NAME | ERR_ASSIGN);

	vp = Strsave(vp);
	if (op == '=') {
	    c = '=';
	    p = xset(p, &v);
	}
	else {
	    c = *p++;
	    if (any("+-", c)) {
		if (c != op || *p)
		    stderror(ERR_NAME | ERR_UNKNOWNOP);
		p = Strsave(STR1);
	    }
	    else {
		if (any("<>", op)) {
		    if (c != op)
			stderror(ERR_NAME | ERR_UNKNOWNOP);
		    c = *p++;
		    stderror(ERR_NAME | ERR_SYNTAX);
		}
		if (c != '=')
		    stderror(ERR_NAME | ERR_UNKNOWNOP);
		p = xset(p, &v);
	    }
	}
	if (op == '=')
	    if (hadsub)
		asx(vp, subscr, p);
	    else
		set(vp, p);
	else if (hadsub) {
	    struct varent *gv = getvx(vp, subscr);

	    asx(vp, subscr, operate(op, gv->vec[subscr - 1], p));
	}
	else
	    set(vp, operate(op, value(vp), p));
	if (eq(vp, STRpath)) {
	    exportpath(adrof(STRpath)->vec);
	    dohash(NULL, NULL);
	}
	free(vp);
	if (c != '=')
	    free(p);
    } while ((p = *v++) != NULL);
}

static Char *
xset(Char *cp, Char ***vp)
{
    Char *dp;

    if (*cp) {
	dp = Strsave(cp);
	--(*vp);
	free(** vp);
	**vp = dp;
    }
    return (putn(expr(vp)));
}

static Char *
operate(int op, Char *vp, Char *p)
{
    Char    opr[2];
    Char   *vec[5];
    Char **v = vec;
    Char  **vecp = v;
    int i;

    if (op != '=') {
	if (*vp)
	    *v++ = vp;
	opr[0] = op;
	opr[1] = 0;
	*v++ = opr;
	if (op == '<' || op == '>')
	    *v++ = opr;
    }
    *v++ = p;
    *v++ = 0;
    i = expr(&vecp);
    if (*vecp)
	stderror(ERR_NAME | ERR_EXPRESSION);
    return (putn(i));
}

Char   *
putn(int n)
{
    char number[15];
    int i;

    i = snprintf(number, sizeof(number), "%d", n);
    if (i == -1 || i >= sizeof(number))
	return (STRNULL);
    return (SAVE(number));
}

int
getn(Char *cp)
{
    int n;
    int     sign;

    sign = 0;
    if (cp[0] == '+' && cp[1])
	cp++;
    if (*cp == '-') {
	sign++;
	cp++;
	if (!Isdigit(*cp))
	    stderror(ERR_NAME | ERR_BADNUM);
    }
    n = 0;
    while (Isdigit(*cp))
	n = n * 10 + *cp++ - '0';
    if (*cp)
	stderror(ERR_NAME | ERR_BADNUM);
    return (sign ? -n : n);
}

Char   *
value1(Char *var, struct varent *head)
{
    struct varent *vp;

    vp = adrof1(var, head);
    return (vp == 0 || vp->vec[0] == 0 ? STRNULL : vp->vec[0]);
}

static struct varent *
madrof(Char *pat, struct varent *vp)
{
    struct varent *vp1;

    for (; vp; vp = vp->v_right) {
	if (vp->v_left && (vp1 = madrof(pat, vp->v_left)))
	    return vp1;
	if (Gmatch(vp->v_name, pat))
	    return vp;
    }
    return vp;
}

struct varent *
adrof1(Char *name, struct varent *v)
{
    int cmp;

    v = v->v_left;
    while (v && ((cmp = *name - *v->v_name) ||
		 (cmp = Strcmp(name, v->v_name))))
	if (cmp < 0)
	    v = v->v_left;
	else
	    v = v->v_right;
    return v;
}

/*
 * The caller is responsible for putting value in a safe place
 */
void
set(Char *var, Char *val)
{
    Char **vec = xreallocarray(NULL, 2, sizeof(Char **));

    vec[0] = val;
    vec[1] = 0;
    set1(var, vec, &shvhed);
}

void
set1(Char *var, Char **vec, struct varent *head)
{
    Char **oldv = vec;

    gflag = 0;
    tglob(oldv);
    if (gflag) {
	vec = globall(oldv);
	if (vec == 0) {
	    blkfree(oldv);
	    stderror(ERR_NAME | ERR_NOMATCH);
	    return;
	}
	blkfree(oldv);
	gargv = 0;
    }
    setq(var, vec, head);
}


void
setq(Char *name, Char **vec, struct varent *p)
{
    struct varent *c;
    int f;

    f = 0;			/* tree hangs off the header's left link */
    while ((c = p->v_link[f]) != NULL) {
	if ((f = *name - *c->v_name) == 0 &&
	    (f = Strcmp(name, c->v_name)) == 0) {
	    blkfree(c->vec);
	    goto found;
	}
	p = c;
	f = f > 0;
    }
    p->v_link[f] = c = (struct varent *) xmalloc((size_t) sizeof(struct varent));
    c->v_name = Strsave(name);
    c->v_bal = 0;
    c->v_left = c->v_right = 0;
    c->v_parent = p;
    balance(p, f, 0);
found:
    trim(c->vec = vec);
}

void
/*ARGSUSED*/
unset(Char **v, struct command *t)
{
    unset1(v, &shvhed);
    if (adrof(STRfilec) == 0)
	filec = 0;
    if (adrof(STRhistchars) == 0) {
	HIST = '!';
	HISTSUB = '^';
    }
    if (adrof(STRwordchars) == 0)
	word_chars = STR_WORD_CHARS;
}

void
unset1(Char *v[], struct varent *head)
{
    struct varent *vp;
    int cnt;

    while (*++v) {
	cnt = 0;
	while ((vp = madrof(*v, head->v_left)) != NULL)
	    unsetv1(vp), cnt++;
	if (cnt == 0)
	    setname(vis_str(*v));
    }
}

void
unsetv(Char *var)
{
    struct varent *vp;

    if ((vp = adrof1(var, &shvhed)) == 0)
	udvar(var);
    unsetv1(vp);
}

static void
unsetv1(struct varent *p)
{
    struct varent *c, *pp;
    int f;

    /*
     * Free associated memory first to avoid complications.
     */
    blkfree(p->vec);
    free(p->v_name);
    /*
     * If p is missing one child, then we can move the other into where p is.
     * Otherwise, we find the predecessor of p, which is guaranteed to have no
     * right child, copy it into p, and move it's left child into it.
     */
    if (p->v_right == 0)
	c = p->v_left;
    else if (p->v_left == 0)
	c = p->v_right;
    else {
	for (c = p->v_left; c->v_right; c = c->v_right)
	    continue;
	p->v_name = c->v_name;
	p->vec = c->vec;
	p = c;
	c = p->v_left;
    }
    /*
     * Move c into where p is.
     */
    pp = p->v_parent;
    f = pp->v_right == p;
    if ((pp->v_link[f] = c) != NULL)
	c->v_parent = pp;
    /*
     * Free the deleted node, and rebalance.
     */
    free(p);
    balance(pp, f, 1);
}

void
setNS(Char *cp)
{
    set(cp, Strsave(STRNULL));
}

void
/*ARGSUSED*/
shift(Char **v, struct command *t)
{
    struct varent *argv;
    Char *name;

    v++;
    name = *v;
    if (name == 0)
	name = STRargv;
    else
	(void) strip(name);
    argv = adrof(name);
    if (argv == 0)
	udvar(name);
    if (argv->vec[0] == 0)
	stderror(ERR_NAME | ERR_NOMORE);
    lshift(argv->vec, 1);
}

static void
exportpath(Char **val)
{
    Char    exppath[BUFSIZ];

    exppath[0] = 0;
    if (val)
	while (*val) {
	    if (Strlen(*val) + Strlen(exppath) + 2 > BUFSIZ) {
		(void) fprintf(csherr,
			       "Warning: ridiculously long PATH truncated\n");
		break;
	    }
	    (void) Strlcat(exppath, *val++, sizeof exppath/sizeof(Char));
	    if (*val == 0 || eq(*val, STRRparen))
		break;
	    (void) Strlcat(exppath, STRcolon, sizeof exppath/sizeof(Char));
	}
    Setenv(STRPATH, exppath);
}

/* macros to do single rotations on node p */
#define rright(p) (\
	t = (p)->v_left,\
	(t)->v_parent = (p)->v_parent,\
	((p)->v_left = t->v_right) ? (t->v_right->v_parent = (p)) : 0,\
	(t->v_right = (p))->v_parent = t,\
	(p) = t)
#define rleft(p) (\
	t = (p)->v_right,\
	(t)->v_parent = (p)->v_parent,\
	((p)->v_right = t->v_left) ? (t->v_left->v_parent = (p)) : 0,\
	(t->v_left = (p))->v_parent = t,\
	(p) = t)

/*
 * Rebalance a tree, starting at p and up.
 * F == 0 means we've come from p's left child.
 * D == 1 means we've just done a delete, otherwise an insert.
 */
static void
balance(struct varent *p, int f, int d)
{
    struct varent *pp;
    struct varent *t;	/* used by the rotate macros */
    int ff;

    /*
     * Ok, from here on, p is the node we're operating on; pp is it's parent; f
     * is the branch of p from which we have come; ff is the branch of pp which
     * is p.
     */
    for (; (pp = p->v_parent) != NULL; p = pp, f = ff) {
	ff = pp->v_right == p;
	if (f ^ d) {		/* right heavy */
	    switch (p->v_bal) {
	    case -1:		/* was left heavy */
		p->v_bal = 0;
		break;
	    case 0:		/* was balanced */
		p->v_bal = 1;
		break;
	    case 1:		/* was already right heavy */
		switch (p->v_right->v_bal) {
		case 1:	/* single rotate */
		    pp->v_link[ff] = rleft(p);
		    p->v_left->v_bal = 0;
		    p->v_bal = 0;
		    break;
		case 0:	/* single rotate */
		    pp->v_link[ff] = rleft(p);
		    p->v_left->v_bal = 1;
		    p->v_bal = -1;
		    break;
		case -1:	/* double rotate */
		    (void) rright(p->v_right);
		    pp->v_link[ff] = rleft(p);
		    p->v_left->v_bal =
			p->v_bal < 1 ? 0 : -1;
		    p->v_right->v_bal =
			p->v_bal > -1 ? 0 : 1;
		    p->v_bal = 0;
		    break;
		}
		break;
	    }
	}
	else {			/* left heavy */
	    switch (p->v_bal) {
	    case 1:		/* was right heavy */
		p->v_bal = 0;
		break;
	    case 0:		/* was balanced */
		p->v_bal = -1;
		break;
	    case -1:		/* was already left heavy */
		switch (p->v_left->v_bal) {
		case -1:	/* single rotate */
		    pp->v_link[ff] = rright(p);
		    p->v_right->v_bal = 0;
		    p->v_bal = 0;
		    break;
		case 0:	/* single rotate */
		    pp->v_link[ff] = rright(p);
		    p->v_right->v_bal = -1;
		    p->v_bal = 1;
		    break;
		case 1:	/* double rotate */
		    (void) rleft(p->v_left);
		    pp->v_link[ff] = rright(p);
		    p->v_left->v_bal =
			p->v_bal < 1 ? 0 : -1;
		    p->v_right->v_bal =
			p->v_bal > -1 ? 0 : 1;
		    p->v_bal = 0;
		    break;
		}
		break;
	    }
	}
	/*
	 * If from insert, then we terminate when p is balanced. If from
	 * delete, then we terminate when p is unbalanced.
	 */
	if ((p->v_bal == 0) ^ d)
	    break;
    }
}

void
plist(struct varent *p)
{
    struct varent *c;
    int len;
    sigset_t sigset;

    if (setintr) {
	sigemptyset(&sigset);
	sigaddset(&sigset, SIGINT);
	sigprocmask(SIG_UNBLOCK, &sigset, NULL);
    }

    for (;;) {
	while (p->v_left)
	    p = p->v_left;
x:
	if (p->v_parent == 0)	/* is it the header? */
	    return;
	len = blklen(p->vec);
	(void) fprintf(cshout, "%s\t", short2str(p->v_name));
	if (len != 1)
	    (void) fputc('(', cshout);
	blkpr(cshout, p->vec);
	if (len != 1)
	    (void) fputc(')', cshout);
	(void) fputc('\n', cshout);
	if (p->v_right) {
	    p = p->v_right;
	    continue;
	}
	do {
	    c = p;
	    p = p->v_parent;
	} while (p->v_right == c);
	goto x;
    }
}
@


1.18
log
@miscellaneous cruft:
* remove lint
* unifdef S_IFLNK, S_ISFIFO, S_ISLNK, S_ISSOCK, O_APPEND
* remove 0, NOTUSED, notdef -- untouched since original import
* remove IIASA
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.17 2015/10/26 15:01:15 naddy Exp $	*/
d159 1
a159 1
	    xfree(cp);
d184 1
a184 1
    xfree(v->vec[subscr - 1]);
d279 1
a279 1
	xfree(vp);
d281 1
a281 1
	    xfree(p);
d293 1
a293 1
	xfree(** vp);
d508 1
a508 1
    xfree(p->v_name);
d536 1
a536 1
    xfree(p);
@


1.17
log
@unifdef BUILTIN (unused), NLS (always set), SHORT_STRINGS (always set)
and remove a few unused defines; no binary changes; ok tedu@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.16 2015/09/29 20:10:41 guenther Exp $	*/
d588 1
a588 5
#ifndef lint
 /*
  * Lint thinks these have null effect
  */
 /* macros to do single rotations on node p */
a600 14
#else
struct varent *
rleft(struct varent *p)
{
    return (p);
}
struct varent *
rright(struct varent *p)
{
    return (p);
}

#endif				/* ! lint */

a610 2

#ifndef lint
a611 2

#endif
@


1.16
log
@Score a hat trick in code cleanup: #ifdef pdp11, /* confuse lint */,
and recursive formatting of integers.  Just use snprintf() and a hammer.

ok beck@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.15 2015/06/17 03:48:21 deraadt Exp $	*/
a34 3
#ifndef SHORT_STRINGS
#include <string.h>
#endif /* SHORT_STRINGS */
@


1.15
log
@remove -DFILEC; code does not compile for the -UFILEC case, and anyways,
who wants csh without FILEC??
from Peter Brottveit Bock, but redone using unifdef
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.14 2015/02/08 05:47:28 tedu Exp $	*/
a48 1
static void	 putn1(int);
a327 2
static Char *putp;

d331 2
a332 2
    int     num;
    static Char number[15];
d334 4
a337 32
    putp = number;
    if (n < 0) {
	n = -n;
	*putp++ = '-';
    }
    num = 2;			/* confuse lint */
    if (sizeof(int) == num && ((unsigned int) n) == 0x8000) {
	*putp++ = '3';
	n = 2768;
#ifdef pdp11
    }
#else
    }
    else {
	num = 4;		/* confuse lint */
	if (sizeof(int) == num && ((unsigned int) n) == 0x80000000) {
	    *putp++ = '2';
	    n = 147483648;
	}
    }
#endif
    putn1(n);
    *putp = 0;
    return (Strsave(number));
}

static void
putn1(int n)
{
    if (n > 9)
	putn1(n / 10);
    *putp++ = n % 10 + '0';
@


1.14
log
@delete lots of unnecessary ptr_t casts, and drop a little NULL in as well
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.13 2014/10/16 19:43:31 deraadt Exp $	*/
a164 1
#ifdef FILEC
a166 1
#endif
a496 1
#ifdef FILEC
a498 1
#endif
@


1.13
log
@Use reallocarray() and remove a few archaic memory allocation practices.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.12 2009/10/28 02:03:47 schwarze Exp $	*/
d163 1
a163 1
	    xfree((ptr_t) cp);
d190 1
a190 1
    xfree((ptr_t) v->vec[subscr - 1]);
d285 1
a285 1
	xfree((ptr_t) vp);
d287 1
a287 1
	    xfree((ptr_t) p);
d299 1
a299 1
	xfree((ptr_t) ** vp);
d546 1
a546 1
    xfree((ptr_t) p->v_name);
d574 1
a574 1
    xfree((ptr_t) p);
@


1.12
log
@some includes got lost in the previous commit;
"go ahead, put it back" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.11 2009/10/27 23:59:21 deraadt Exp $	*/
d440 1
a440 1
    Char **vec = (Char **) xmalloc((size_t) (2 * sizeof(Char **)));
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.10 2003/06/11 21:09:50 deraadt Exp $	*/
d32 7
@


1.10
log
@de-register and ansify functions
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.9 2003/06/02 23:32:07 millert Exp $	*/
a31 15

#ifndef lint
#if 0
static char sccsid[] = "@@(#)set.c	8.1 (Berkeley) 5/31/93";
#else
static char rcsid[] = "$OpenBSD: set.c,v 1.9 2003/06/02 23:32:07 millert Exp $";
#endif
#endif /* not lint */

#include <sys/types.h>
#include <stdlib.h>
#ifndef SHORT_STRINGS
#include <string.h>
#endif /* SHORT_STRINGS */
#include <stdarg.h>
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.8 2003/01/08 06:54:16 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: set.c,v 1.8 2003/01/08 06:54:16 deraadt Exp $";
d71 1
a71 3
doset(v, t)
    Char **v;
    struct command *t;
d73 1
a73 1
    register Char *p;
d114 1
a114 1
	    register Char **e = v;
d141 1
a141 1
	    register Char *pn = value(STRhistchars);
d156 1
a156 1
	    register Char *cp;
d181 1
a181 3
getinx(cp, ip)
    register Char *cp;
    register int *ip;
d194 1
a194 4
asx(vp, subscr, p)
    Char   *vp;
    int     subscr;
    Char   *p;
d196 1
a196 1
    register struct varent *v = getvx(vp, subscr);
d203 1
a203 3
getvx(vp, subscr)
    Char   *vp;
    int     subscr;
d205 1
a205 1
    register struct varent *v = adrof(vp);
d216 1
a216 3
dolet(v, t)
    Char **v;
    struct command *t;
d218 1
a218 1
    register Char *p;
d300 1
a300 2
xset(cp, vp)
    Char   *cp, ***vp;
d302 1
a302 1
    register Char *dp;
d314 1
a314 3
operate(op, vp, p)
    int    op;
    Char  *vp, *p;
d318 1
a318 1
    register Char **v = vec;
d320 1
a320 1
    register int i;
d342 1
a342 2
putn(n)
    register int n;
d374 1
a374 2
putn1(n)
    register int n;
d382 1
a382 2
getn(cp)
    register Char *cp;
d384 1
a384 1
    register int n;
d405 1
a405 3
value1(var, head)
    Char   *var;
    struct varent *head;
d407 1
a407 1
    register struct varent *vp;
d414 1
a414 3
madrof(pat, vp)
    Char   *pat;
    register struct varent *vp;
d416 1
a416 1
    register struct varent *vp1;
d428 1
a428 3
adrof1(name, v)
    register Char *name;
    register struct varent *v;
d430 1
a430 1
    register int cmp;
d446 1
a446 2
set(var, val)
    Char   *var, *val;
d448 1
a448 1
    register Char **vec = (Char **) xmalloc((size_t) (2 * sizeof(Char **)));
d456 1
a456 3
set1(var, vec, head)
    Char   *var, **vec;
    struct varent *head;
d458 1
a458 1
    register Char **oldv = vec;
d477 1
a477 3
setq(name, vec, p)
    Char   *name, **vec;
    register struct varent *p;
d479 2
a480 2
    register struct varent *c;
    register int f;
d504 1
a504 3
unset(v, t)
    Char **v;
    struct command *t;
d520 1
a520 3
unset1(v, head)
    register Char *v[];
    struct varent *head;
d522 2
a523 2
    register struct varent *vp;
    register int cnt;
d535 1
a535 2
unsetv(var)
    Char   *var;
d537 1
a537 1
    register struct varent *vp;
d545 1
a545 2
unsetv1(p)
    register struct varent *p;
d547 2
a548 2
    register struct varent *c, *pp;
    register int f;
d587 1
a587 2
setNS(cp)
    Char   *cp;
d594 1
a594 3
shift(v, t)
    Char **v;
    struct command *t;
d596 2
a597 2
    register struct varent *argv;
    register Char *name;
d614 1
a614 2
exportpath(val)
    Char  **val;
d653 1
a653 2
rleft(p)
    struct varent *p;
d658 1
a658 2
rright(p)
    struct varent *p;
d672 1
a672 3
balance(p, f, d)
    register struct varent *p;
    register int f, d;
d674 1
a674 1
    register struct varent *pp;
d677 1
a677 1
    register struct varent *t;	/* used by the rotate macros */
d680 1
a680 1
    register int ff;
d765 1
a765 2
plist(p)
    register struct varent *p;
d767 2
a768 2
    register struct varent *c;
    register int len;
@


1.8
log
@bring in strlcpy and strlcat-like things for dealing with Char types,
this fixes at least 15 buffer overflows; some help from dhartmei.
Anyone want to go do the same in ksh, and help with some of the while
(*s++ = *p++) loops in here?
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.7 2002/02/19 19:39:35 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: set.c,v 1.7 2002/02/19 19:39:35 millert Exp $";
@


1.7
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.6 2002/02/16 21:27:06 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: set.c,v 1.6 2002/02/16 21:27:06 millert Exp $";
d668 1
a668 1
	    (void) Strcat(exppath, *val++);
d671 1
a671 1
	    (void) Strcat(exppath, STRcolon);
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.5 2001/12/01 19:10:39 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: set.c,v 1.5 2001/12/01 19:10:39 deraadt Exp $";
d50 1
a50 5
#ifdef __STDC__
# include <stdarg.h>
#else
# include <varargs.h>
#endif
@


1.5
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.4 1997/11/15 21:51:30 todd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: set.c,v 1.4 1997/11/15 21:51:30 todd Exp $";
d59 2
a60 2
static Char	*getinx __P((Char *, int *));
static void	 asx __P((Char *, int, Char *));
d62 4
a65 4
		*getvx __P((Char *, int));
static Char	*xset __P((Char *, Char ***));
static Char	*operate __P((int, Char *, Char *));
static void	 putn1 __P((int));
d67 4
a70 4
		*madrof __P((Char *, struct varent *));
static void	 unsetv1 __P((struct varent *));
static void	 exportpath __P((Char **));
static void	 balance __P((struct varent *, int, int));
@


1.4
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.3 1997/07/25 18:58:17 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: set.c,v 1.3 1997/07/25 18:58:17 mickey Exp $";
d461 1
a461 1
    register cmp;
d516 1
a516 1
    register f;
d590 1
a590 1
    register f;
d730 1
a730 1
    register ff;
d819 1
a819 1
    register len;
@


1.3
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.2 1996/06/23 14:19:30 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: set.c,v 1.2 1996/06/23 14:19:30 deraadt Exp $";
d171 1
a171 1
	     * convert to cononical pathname (possibly resolving symlinks)
d749 1
a749 1
		case 1:	/* sigle rotate */
d787 1
a787 1
		case 0:	/* signle rotate */
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: set.c,v 1.8 1995/03/21 18:35:52 mycroft Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: set.c,v 1.8 1995/03/21 18:35:52 mycroft Exp $";
d50 1
a50 1
#if __STDC__
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: set.c,v 1.8 1995/03/21 18:35:52 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
