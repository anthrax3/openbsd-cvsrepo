head	1.45;
access;
symbols
	OPENBSD_6_1:1.44.0.4
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.35.0.20
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.16
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.14
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.12
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.10
	OPENBSD_5_0:1.35.0.8
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.6
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.4
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.34.0.12
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.8
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.6
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.4
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.32.0.6
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.32.0.4
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.30.0.2
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.29.0.6
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.27.0.2
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_8:1.15.0.4
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2017.06.27.21.43.46;	author tedu;	state Exp;
branches;
next	1.44;
commitid	ffGkl3dPIrdhYvXu;

1.44
date	2016.10.11.16.16.44;	author millert;	state Exp;
branches;
next	1.43;
commitid	HjUfxTpU3xGwvXYa;

1.43
date	2015.11.17.18.34.00;	author tedu;	state Exp;
branches;
next	1.42;
commitid	cqIUPQK5q1zVzI4p;

1.42
date	2015.11.17.17.24.26;	author tedu;	state Exp;
branches;
next	1.41;
commitid	Y1miGpZco6SDTv9c;

1.41
date	2015.10.06.16.51.15;	author tedu;	state Exp;
branches;
next	1.40;
commitid	70MRrQ5BLBdu8nA0;

1.40
date	2015.08.24.00.10.59;	author guenther;	state Exp;
branches;
next	1.39;
commitid	k7W6ZjKQavKFXyDm;

1.39
date	2015.05.03.19.44.59;	author guenther;	state Exp;
branches;
next	1.38;
commitid	EhByHUPhmNVyA3OR;

1.38
date	2015.01.16.06.39.32;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	Uu5nFG3wCl0LACBb;

1.37
date	2014.07.21.19.55.33;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	jOpg0URsKqXFYkwm;

1.36
date	2014.05.21.06.23.02;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.07.27.02.49.38;	author ray;	state Exp;
branches;
next	1.33;

1.33
date	2007.02.16.09.04.34;	author moritz;	state Exp;
branches;
next	1.32;

1.32
date	2005.06.30.15.13.24;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.08.20.09.36;	author jaredy;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.13.20.22.52;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2003.07.29.00.24.15;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.02.23.32.08;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.21.15.49.39;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.13.22.17.04;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.13.09.09.24;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.04.04.26.40;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.25.07.10.04;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.16.18.44.21;	author mpech;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.01.19.10.39;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.06.13.29.08;	author mpech;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.09.07.04.26;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.08.16.12.57;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.06.19.38.21;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	99.12.24.22.38.06;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	99.07.26.21.29.45;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	99.01.12.04.42.23;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	98.07.02.18.46.34;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.07.02.15.58.52;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	98.05.18.19.11.45;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.09.28.22.54.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.04.12.17.30.23;	author michaels;	state Exp;
branches;
next	1.7;

1.7
date	97.03.01.20.43.51;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.02.02.10.16.58;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.12.18.05;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.08.02.12.41.00;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.30.12.26.46;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.20.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.16;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.45
log
@add a -v verbose flag to cp, mv, and rm. useful for monitoring progress,
and present on several other systems. some ok, some less ok.
from Job Snijders
@
text
@/*	$OpenBSD: mv.c,v 1.44 2016/10/11 16:16:44 millert Exp $	*/
/*	$NetBSD: mv.c,v 1.9 1995/03/21 09:06:52 cgd Exp $	*/

/*
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ken Smith of The State University of New York at Buffalo.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/time.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/mount.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <pwd.h>
#include <grp.h>

extern char *__progname;

int fflg, iflg, vflg;
int stdin_ok;

extern int cpmain(int argc, char **argv);
extern int rmmain(int argc, char **argv);

int	mvcopy(char *, char *);
int	do_move(char *, char *);
int	fastcopy(char *, char *, struct stat *);
void	usage(void);

int
main(int argc, char *argv[])
{
	int baselen, len, rval;
	char *p, *endp;
	struct stat sb;
	int ch;
	char path[PATH_MAX];

	while ((ch = getopt(argc, argv, "ifv")) != -1)
		switch (ch) {
		case 'i':
			fflg = 0;
			iflg = 1;
			break;
		case 'f':
			iflg = 0;
			fflg = 1;
			break;
		case 'v':
			vflg = 1;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (argc < 2)
		usage();

	stdin_ok = isatty(STDIN_FILENO);

	/*
	 * If the stat on the target fails or the target isn't a directory,
	 * try the move.  More than 2 arguments is an error in this case.
	 */
	if (stat(argv[argc - 1], &sb) || !S_ISDIR(sb.st_mode)) {
		if (argc > 2)
			usage();
		exit(do_move(argv[0], argv[1]));
	}

	/* It's a directory, move each file into it. */
	if (strlcpy(path, argv[argc - 1], sizeof path) >= sizeof path)
		errx(1, "%s: destination pathname too long", *argv);
	baselen = strlen(path);
	endp = &path[baselen];
	if (*(endp - 1) != '/') {
		*endp++ = '/';
		++baselen;
	}
	for (rval = 0; --argc; ++argv) {
		char *current_arg = *argv;

		/*
		 * Get the name of the file to create from
		 * the argument. This is a bit tricky because
		 * in the case of b/ we actually want b and empty
		 * string
		 */
		if ((p = strrchr(current_arg, '/')) == NULL)
			p = current_arg;
		else {
			/* Special case foo/ */
			if (!*(p+1)) {
				while (p >= current_arg && *p == '/')
					p--;

				while (p >= current_arg && *p != '/')
					p--;
			}

			p++;
		}

		if ((baselen + (len = strlen(p))) >= PATH_MAX) {
			warnx("%s: destination pathname too long", *argv);
			rval = 1;
		} else {
			memmove(endp, p, len + 1);
			if (do_move(current_arg, path))
				rval = 1;
		}
	}
	exit(rval);
}

int
do_move(char *from, char *to)
{
	struct stat sb, fsb;
	char modep[15];

	/* Source path must exist (symlink is OK). */
	if (lstat(from, &fsb)) {
		warn("%s", from);
		return (1);
	}

	/*
	 * (1)	If the destination path exists, the -f option is not specified
	 *	and either of the following conditions are true:
	 *
	 *	(a) The permissions of the destination path do not permit
	 *	    writing and the standard input is a terminal.
	 *	(b) The -i option is specified.
	 *
	 *	the mv utility shall write a prompt to standard error and
	 *	read a line from standard input.  If the response is not
	 *	affirmative, mv shall do nothing more with the current
	 *	source file...
	 */
	if (!fflg && !access(to, F_OK)) {
		int ask = 1;
		int ch, first;

		if (iflg && !access(from, F_OK)) {
			(void)fprintf(stderr, "overwrite %s? ", to);
		} else if (stdin_ok && access(to, W_OK) && !stat(to, &sb)) {
			strmode(sb.st_mode, modep);
			(void)fprintf(stderr, "override %s%s%s/%s for %s? ",
			    modep + 1, modep[9] == ' ' ? "" : " ",
			    user_from_uid(sb.st_uid, 0),
			    group_from_gid(sb.st_gid, 0), to);
		} else
			ask = 0;
		if (ask) {
			first = ch = getchar();
			while (ch != '\n' && ch != EOF)
				ch = getchar();
			if (first != 'y' && first != 'Y')
				return (0);
		}
	}

	/*
	 * (2)	If rename() succeeds, mv shall do nothing more with the
	 *	current source file.  If it fails for any other reason than
	 *	EXDEV, mv shall write a diagnostic message to the standard
	 *	error and do nothing more with the current source file.
	 *
	 * (3)	If the destination path exists, and it is a file of type
	 *	directory and source_file is not a file of type directory,
	 *	or it is a file not of type directory, and source file is
	 *	a file of type directory, mv shall write a diagnostic
	 *	message to standard error, and do nothing more with the
	 *	current source file...
	 */
	if (!rename(from, to)) {
		if (vflg)
			(void)fprintf(stdout, "%s -> %s\n", from, to);
		return (0);
	}

	if (errno != EXDEV) {
		warn("rename %s to %s", from, to);
		return (1);
	}

	/* Disallow moving a mount point. */
	if (S_ISDIR(fsb.st_mode)) {
		struct statfs sfs;
		char path[PATH_MAX];

		if (realpath(from, path) == NULL) {
			warnx("cannot resolve %s", from);
			return (1);
		}
		if (!statfs(path, &sfs) && !strcmp(path, sfs.f_mntonname)) {
			warnx("cannot rename a mount point");
			return (1);
		}
	}

	/*
	 * (4)	If the destination path exists, mv shall attempt to remove it.
	 *	If this fails for any reason, mv shall write a diagnostic
	 *	message to the standard error and do nothing more with the
	 *	current source file...
	 */
	if (!lstat(to, &sb)) {
		if ((S_ISDIR(sb.st_mode)) ? rmdir(to) : unlink(to)) {
			warn("can't remove %s", to);
			return (1);
		}
	}

	/*
	 * (5)	The file hierarchy rooted in source_file shall be duplicated
	 *	as a file hierarchy rooted in the destination path...
	 */
	return (S_ISREG(fsb.st_mode) ?
	    fastcopy(from, to, &fsb) : mvcopy(from, to));
}

int
fastcopy(char *from, char *to, struct stat *sbp)
{
	struct timespec ts[2];
	static u_int32_t blen;
	static char *bp;
	int nread, from_fd, to_fd;
	int badchown = 0, serrno = 0;

	if (!blen) {
		blen = sbp->st_blksize;
		if ((bp = malloc(blen)) == NULL) {
			warn(NULL);
			blen = 0;
			return (1);
		}
	}

	if ((from_fd = open(from, O_RDONLY, 0)) < 0) {
		warn("%s", from);
		return (1);
	}
	if ((to_fd = open(to, O_CREAT | O_TRUNC | O_WRONLY, 0600)) < 0) {
		warn("%s", to);
		(void)close(from_fd);
		return (1);
	}

	if (fchown(to_fd, sbp->st_uid, sbp->st_gid)) {
		serrno = errno;
		badchown = 1;
	}
	(void) fchmod(to_fd, sbp->st_mode & ~(S_ISUID|S_ISGID));

	while ((nread = read(from_fd, bp, blen)) > 0)
		if (write(to_fd, bp, nread) != nread) {
			warn("%s", to);
			goto err;
		}
	if (nread < 0) {
		warn("%s", from);
err:		if (unlink(to))
			warn("%s: remove", to);
		(void)close(from_fd);
		(void)close(to_fd);
		return (1);
	}
	(void)close(from_fd);

	if (badchown) {
		if ((sbp->st_mode & (S_ISUID|S_ISGID)))  {
			warnc(serrno,
			    "%s: set owner/group; not setting setuid/setgid",
			    to);
			sbp->st_mode &= ~(S_ISUID|S_ISGID);
		} else if (!fflg)
			warnc(serrno, "%s: set owner/group", to);
	}
	if (fchmod(to_fd, sbp->st_mode))
		warn("%s: set mode", to);

	/*
	 * XXX
	 * NFS doesn't support chflags; ignore errors unless there's reason
	 * to believe we're losing bits.  (Note, this still won't be right
	 * if the server supports flags and we were trying to *remove* flags
	 * on a file that we copied, i.e., that we didn't create.)
	 */
	errno = 0;
	if (fchflags(to_fd, sbp->st_flags))
		if (errno != EOPNOTSUPP || sbp->st_flags != 0)
			warn("%s: set flags", to);

	ts[0] = sbp->st_atim;
	ts[1] = sbp->st_mtim;
	if (futimens(to_fd, ts))
		warn("%s: set times", to);

	if (close(to_fd)) {
		warn("%s", to);
		return (1);
	}

	if (unlink(from)) {
		warn("%s: remove", from);
		return (1);
	}

	if (vflg)
		(void)fprintf(stdout, "%s -> %s\n", from, to);

	return (0);
}

int
mvcopy(char *from, char *to)
{
	char *argv[3];

	argv[0] = from;
	argv[1] = to;
	argv[2] = NULL;
	if (cpmain(2, argv)) {
		warn("cp failed");
		_exit(1);
	}

	argv[0] = from;
	argv[1] = NULL;
	if (rmmain(1, argv)) {
		warn("rm failed");
		_exit(1);
	}

	/*
	 * XXX
	 * The external cpmain(), rmmain() approach (to avoid
	 * fork+exec) hides some of the details on what was moved.
	 * This can be improved upon during a refactor.
	 */
	if (vflg)
		(void)fprintf(stdout, "%s -> %s\n", from, to);

	return (0);
}

void
usage(void)
{
	(void)fprintf(stderr, "usage: %s [-fiv] source target\n", __progname);
	(void)fprintf(stderr, "       %s [-fiv] source ... directory\n",
	    __progname);
	exit(1);
}
@


1.44
log
@Remove now-unused pathnames.h, from Jan Stary
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.43 2015/11/17 18:34:00 tedu Exp $	*/
d54 1
a54 1
int fflg, iflg;
d74 1
a74 1
	while ((ch = getopt(argc, argv, "if")) != -1)
d84 3
d214 3
a216 1
	if (!rename(from, to))
d218 1
d348 4
d375 9
d390 2
a391 2
	(void)fprintf(stderr, "usage: %s [-fi] source target\n", __progname);
	(void)fprintf(stderr, "       %s [-fi] source ... directory\n",
@


1.43
log
@remove getopt() from the nested cp and rm mains
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.42 2015/11/17 17:24:26 tedu Exp $	*/
a50 2

#include "pathnames.h"
@


1.42
log
@direct copy of cp and rm code into mv, so it can avoid fork+exec.
some or even most of the code can still be streamlined more.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.41 2015/10/06 16:51:15 tedu Exp $	*/
d350 1
a350 1
	char *argv[6];
d352 4
a355 10
	argv[0] = "cp";
	argv[1] = "-PRp";
	argv[2] = "--";
	argv[3] = from;
	argv[4] = to;
	argv[5] = NULL;

	optind = 1;
	optreset = 1;
	if (cpmain(5, argv)) {
d360 3
a362 9
	argv[0] = "rm";
	argv[1] = "-rf";
	argv[2] = "--";
	argv[3] = from;
	argv[4] = NULL;

	optind = 1;
	optreset = 1;
	if (rmmain(4, argv)) {
@


1.41
log
@we're running rm. call it rm too.
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.40 2015/08/24 00:10:59 guenther Exp $	*/
d59 4
a62 1
int	copy(char *, char *);
d254 1
a254 1
	    fastcopy(from, to, &fsb) : copy(from, to));
d348 1
a348 1
copy(char *from, char *to)
d350 1
a350 2
	int status;
	pid_t pid;
d352 11
a362 3
	if ((pid = vfork()) == 0) {
		execl(_PATH_CP, "cp", "-PRp", "--", from, to, (char *)NULL);
		warn("%s", _PATH_CP);
d365 11
a375 16
	if (waitpid(pid, &status, 0) == -1) {
		warn("%s: waitpid", _PATH_CP);
		return (1);
	}
	if (!WIFEXITED(status)) {
		warnx("%s: did not terminate normally", _PATH_CP);
		return (1);
	}
	if (WEXITSTATUS(status)) {
		warnx("%s: terminated with %d (non-zero) status",
		    _PATH_CP, WEXITSTATUS(status));
		return (1);
	}
	if (!(pid = vfork())) {
		execl(_PATH_RM, "rm", "-rf", "--", from, (char *)NULL);
		warn("%s", _PATH_RM);
d378 1
a378 13
	if (waitpid(pid, &status, 0) == -1) {
		warn("%s: waitpid", _PATH_RM);
		return (1);
	}
	if (!WIFEXITED(status)) {
		warnx("%s: did not terminate normally", _PATH_RM);
		return (1);
	}
	if (WEXITSTATUS(status)) {
		warnx("%s: terminated with %d (non-zero) status",
		    _PATH_RM, WEXITSTATUS(status));
		return (1);
	}
@


1.40
log
@In fastcopy(), do the required malloc() before opening input or output file.

problem noted by Martijn van Duren (martijn987 (at) gmail.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.39 2015/05/03 19:44:59 guenther Exp $	*/
d369 1
a369 1
		execl(_PATH_RM, "cp", "-rf", "--", from, (char *)NULL);
@


1.39
log
@Preserve times to nanosecond precision instead of just microsecond.
Prefer to set attributes by fd for regular files, and not follwing
symlinks for others.

ok brynet@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.38 2015/01/16 06:39:32 deraadt Exp $	*/
d263 9
a287 8
	if (!blen) {
		blen = sbp->st_blksize;
		if ((bp = malloc(blen)) == NULL) {
			warn(NULL);
			blen = 0;
			return (1);
		}
	}
@


1.38
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.37 2014/07/21 19:55:33 deraadt Exp $	*/
d257 1
a257 1
	struct timeval tval[2];
d326 3
a328 3
	TIMESPEC_TO_TIMEVAL(&tval[0], &sbp->st_atimespec);
	TIMESPEC_TO_TIMEVAL(&tval[1], &sbp->st_mtimespec);
	if (utimes(to, tval))
@


1.37
log
@don't try to be clever and name the _PATH_CP exec "mv", since this
breaks the instbin argv[0] mechanism
found by landry, ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.36 2014/05/21 06:23:02 guenther Exp $	*/
a35 1
#include <sys/param.h>
d48 1
d71 1
a71 1
	char path[MAXPATHLEN];
d137 1
a137 1
		if ((baselen + (len = strlen(p))) >= MAXPATHLEN) {
d221 1
a221 1
		char path[MAXPATHLEN];
@


1.36
log
@Use errc/warnc to simplify code.

ok jca@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.35 2009/10/27 23:59:22 deraadt Exp $	*/
d350 1
a350 1
		execl(_PATH_CP, "mv", "-PRp", "--", from, to, (char *)NULL);
d368 1
a368 1
		execl(_PATH_RM, "mv", "-rf", "--", from, (char *)NULL);
@


1.35
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.34 2007/07/27 02:49:38 ray Exp $	*/
a302 1
		errno = serrno;
d304 2
a305 1
			warn("%s: set owner/group; not setting setuid/setgid",
d309 1
a309 1
			warn("%s: set owner/group", to);
@


1.34
log
@Separate code a little, making it clearer.  From Gilles Chehade
<root at evilkittens dot org>.

Reset blen on malloc failure.

Match blen type with st_blksize.

OK moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.33 2007/02/16 09:04:34 moritz Exp $	*/
a34 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)mv.c	8.2 (Berkeley) 4/2/94";
#else
static char rcsid[] = "$OpenBSD: mv.c,v 1.33 2007/02/16 09:04:34 moritz Exp $";
#endif
#endif /* not lint */
@


1.33
log
@Allow moving files starting with a dash across
file system boundaries. Noticed by Roland Illig.

ok otto@@ millert@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.32 2005/06/30 15:13:24 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.32 2005/06/30 15:13:24 millert Exp $";
d272 1
a272 1
	static u_int blen;
d293 7
a299 3
	if (!blen && !(bp = malloc(blen = sbp->st_blksize))) {
		warn(NULL);
		return (1);
@


1.32
log
@Set tv_usec sensibly when calling utimes() instead of just zeroing it.
We have nsec file times so we may as well use them...
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.31 2005/04/08 20:09:36 jaredy Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.31 2005/04/08 20:09:36 jaredy Exp $";
d360 1
a360 1
		execl(_PATH_CP, "mv", "-PRp", from, to, (char *)NULL);
d378 1
a378 1
		execl(_PATH_RM, "mv", "-rf", from, (char *)NULL);
@


1.31
log
@Sync with recent realpath(3) changes:  on failure, don't use the second
argument "resolved", since it is undefined.

ok and help millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.30 2004/12/13 20:22:52 otto Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.30 2004/12/13 20:22:52 otto Exp $";
d336 2
a337 3
	tval[0].tv_sec = sbp->st_atime;
	tval[1].tv_sec = sbp->st_mtime;
	tval[0].tv_usec = tval[1].tv_usec = 0;
@


1.30
log
@Use warnx() instead of warn() in four places where we know errno is zero.
ok henning@@ fgsch@@ pedro@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.29 2003/07/29 00:24:15 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.29 2003/07/29 00:24:15 deraadt Exp $";
d238 1
a238 1
			warnx("cannot resolve %s: %s", from, path);
@


1.29
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.28 2003/06/02 23:32:08 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.28 2003/06/02 23:32:08 millert Exp $";
d370 1
a370 1
		warn("%s: did not terminate normally", _PATH_CP);
d374 1
a374 1
		warn("%s: terminated with %d (non-zero) status",
d388 1
a388 1
		warn("%s: did not terminate normally", _PATH_RM);
d392 1
a392 1
		warn("%s: terminated with %d (non-zero) status",
@


1.28
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.27 2003/03/21 15:49:39 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.27 2003/03/21 15:49:39 millert Exp $";
d404 1
a404 1
            __progname);
@


1.27
log
@Fix some typos in comments; Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.26 2003/03/13 22:17:04 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.26 2003/03/13 22:17:04 millert Exp $";
@


1.26
log
@Use the return value of strcpy() to detect ENAMETOOLONG instead of
doing an extra strlen; deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.25 2003/03/13 09:09:24 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.25 2003/03/13 09:09:24 deraadt Exp $";
d183 1
a183 1
	 *	(a) The perimissions of the destination path do not permit
d266 1
a266 1
	 *	as a file hiearchy rooted in the destination path...
@


1.25
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.24 2002/07/04 04:26:40 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.24 2002/07/04 04:26:40 deraadt Exp $";
d123 1
a123 1
	if (strlen(argv[argc - 1]) > sizeof path - 1)
a124 1
	(void)strlcpy(path, argv[argc - 1], sizeof path);
@


1.24
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.23 2002/02/16 21:27:07 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.23 2002/02/16 21:27:07 millert Exp $";
d125 1
a125 1
	(void)strcpy(path, argv[argc - 1]);
@


1.23
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.22 2002/01/25 07:10:04 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.22 2002/01/25 07:10:04 millert Exp $";
d83 1
a83 3
main(argc, argv)
	int argc;
	char *argv[];
d169 1
a169 2
do_move(from, to)
	char *from, *to;
d274 1
a274 3
fastcopy(from, to, sbp)
	char *from, *to;
	struct stat *sbp;
d360 1
a360 2
copy(from, to)
	char *from, *to;
d405 1
a405 1
usage()
@


1.22
log
@Stat source path at the top of do_move() and return an error if
this fails.  Previously, "mv nonexistent file_with_no_write_perms"
would prompt whether or not to overwrite the file w/o write perms
even though 'nonexistent' would fail to lstat() later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.21 2002/01/16 18:44:21 mpech Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.21 2002/01/16 18:44:21 mpech Exp $";
d77 4
a80 4
int	copy __P((char *, char *));
int	do_move __P((char *, char *));
int	fastcopy __P((char *, char *, struct stat *));
void	usage __P((void));
@


1.21
log
@missed some registers, kill'em!

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.20 2001/12/01 19:10:39 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.20 2001/12/01 19:10:39 deraadt Exp $";
d177 6
a236 5
		return (1);
	}

	if (lstat(from, &fsb)) {
		warn("%s", from);
@


1.20
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.19 2001/09/06 13:29:08 mpech Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.19 2001/09/06 13:29:08 mpech Exp $";
d87 2
a88 2
	register int baselen, len, rval;
	register char *p, *endp;
d283 1
a283 1
	register int nread, from_fd, to_fd;
@


1.19
log
@o) __progname aria;

millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.18 2001/07/09 07:04:26 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.18 2001/07/09 07:04:26 deraadt Exp $";
d284 1
a284 1
	int badchown = 0, serrno;
@


1.18
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.17 2001/01/08 16:12:57 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.17 2001/01/08 16:12:57 millert Exp $";
d72 2
d412 3
a414 3

	(void)fprintf(stderr, "usage: mv [-fi] source target\n");
	(void)fprintf(stderr, "       mv [-fi] source ... directory\n");
@


1.17
log
@Fix a bug in previous commit; we need a separate stat buffer for
the "from" file due to changing the order of stat calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.16 2001/01/06 19:38:21 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.16 2001/01/06 19:38:21 millert Exp $";
d369 1
a369 1
		execl(_PATH_CP, "mv", "-PRp", from, to, NULL);
d387 1
a387 1
		execl(_PATH_RM, "mv", "-rf", from, NULL);
@


1.16
log
@Fix 3 cases related to symbolic links when moving between filesystes:
1) incorrectly refused to move a symlink to a mount point
2) refused to move a symlink to a non-existent file
3) copied the contents of a symlink instead of the link itself.

Closes PR 1368; james@@oaktree.co.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.15 1999/12/24 22:38:06 angelos Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.15 1999/12/24 22:38:06 angelos Exp $";
d172 1
a172 1
	struct stat sb;
d232 1
a232 1
	if (lstat(from, &sb)) {
d238 1
a238 1
	if (S_ISDIR(sb.st_mode)) {
d269 2
a270 2
	return (S_ISREG(sb.st_mode) ?
	    fastcopy(from, to, &sb) : copy(from, to));
@


1.15
log
@Try to preserve file flags in mv (Kamo Hiroyasu <wd@@ics.nara-wu.ac.jp>)
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.14 1999/07/26 21:29:45 aaron Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.14 1999/07/26 21:29:45 aaron Exp $";
d227 12
a238 1
	if (errno == EXDEV) {
a241 1
		/* Can't mv(1) a mount point. */
a249 3
	} else {
		warn("rename %s to %s", from, to);
		return (1);
d258 1
a258 1
	if (!stat(to, &sb)) {
a268 4
	if (stat(from, &sb)) {
		warn("%s", from);
		return (1);
	}
@


1.14
log
@When using the -i option, check for the existence of the source file before
asking for confirmation, and if it doesn't exist, just complain and exit. This
is NetBSD PR/8073; deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.13 1999/01/12 04:42:23 aaron Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.13 1999/01/12 04:42:23 aaron Exp $";
d327 12
@


1.13
log
@use pid_t
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.12 1998/07/02 18:46:34 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.12 1998/07/02 18:46:34 deraadt Exp $";
d192 1
a192 1
		if (iflg) {
@


1.12
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.11 1998/07/02 15:58:52 csapuntz Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.11 1998/07/02 15:58:52 csapuntz Exp $";
d350 2
a351 1
	int pid, status;
@


1.11
log
@

Fix mv b/ a where a is a directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.10 1998/05/18 19:11:45 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.10 1998/05/18 19:11:45 deraadt Exp $";
d135 6
a140 4
		/* Get the name of the file to create from
		   the argument. This is a bit tricky because
		   in the case of b/ we actually want b and empty
		   string */
d146 1
a146 2
				while ((p >= current_arg) &&
				       *p == '/')
d149 1
a149 2
				while ((p >= current_arg) &&
				       *p != '/')
@


1.10
log
@MAXPATHLEN not MAXPATHLEN+1, no buf oflow of targdir
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.9 1997/09/28 22:54:29 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.9 1997/09/28 22:54:29 deraadt Exp $";
d133 23
a155 4
		if ((p = strrchr(*argv, '/')) == NULL)
			p = *argv;
		else
			++p;
d161 1
a161 1
			if (do_move(*argv, path))
@


1.9
log
@avoid looping on question; wosch@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.8 1997/04/12 17:30:23 michaels Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.8 1997/04/12 17:30:23 michaels Exp $";
d89 1
a89 1
	char path[MAXPATHLEN + 1];
d123 2
@


1.8
log
@don't print more directory slashes than user specified on error.
Reported by Nick Sayer (nsayer@@quack.kfu.com) in FreeBSD pr bin/3025.
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.7 1997/03/01 20:43:51 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.7 1997/03/01 20:43:51 millert Exp $";
d169 1
a169 1
		int ch;
d182 4
a185 3
			if ((ch = getchar()) != EOF && ch != '\n')
				while (getchar() != '\n');
			if (ch != 'y' && ch != 'Y')
@


1.7
log
@Error out if someone tries to mv a mount point.  Old behavior was to
move all files contained in the mounted filesystem to the dest. dir
which could be quite nasty.  Personally, I think rename(2) should
return EPERM or EINVAL instead of EXDEV.
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.6 1997/02/02 10:16:58 tholo Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.6 1997/02/02 10:16:58 tholo Exp $";
d126 4
a129 2
	*endp++ = '/';
	++baselen;
@


1.6
log
@Remember errno if fchown() fails so we get correct warnings
Only warn about not being able to restore user/group owner if not -f
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.5 1996/12/14 12:18:05 mickey Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.5 1996/12/14 12:18:05 mickey Exp $";
d58 1
d203 14
a216 1
	if (errno != EXDEV) {
@


1.5
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.4 1996/08/02 12:41:00 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.4 1996/08/02 12:41:00 deraadt Exp $";
d241 1
a241 1
	int badchown = 0;
d253 2
a254 1
	if (fchown(to_fd, sbp->st_uid, sbp->st_gid))
d256 1
d279 1
d284 1
a284 1
		} else
@


1.4
log
@zap getopt() case of -?, come on, it is the default!
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.3 1996/07/30 12:26:46 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.3 1996/07/30 12:26:46 deraadt Exp $";
d66 2
@


1.3
log
@regarding freebsd pr#1351 & pr#1377 re: fastcopy(); kill "wrong gid but
group-readable" window; do not setuid/setgid if fchown() fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.2 1996/06/23 14:20:26 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.2 1996/06/23 14:20:26 deraadt Exp $";
a97 1
		case '?':
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: mv.c,v 1.9 1995/03/21 09:06:52 cgd Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mv.c,v 1.9 1995/03/21 09:06:52 cgd Exp $";
d240 1
d246 1
a246 2
	if ((to_fd =
	    open(to, O_CREAT | O_TRUNC | O_WRONLY, sbp->st_mode)) < 0) {
d251 5
d275 8
a282 2
	if (fchown(to_fd, sbp->st_uid, sbp->st_gid))
		warn("%s: set owner/group", to);
@


1.1
log
@Initial revision
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: mv.c,v 1.9 1995/03/21 09:06:52 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
