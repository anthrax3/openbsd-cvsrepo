head	1.17;
access;
symbols
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.9.0.12
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.18
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.16
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2017.01.21.11.03.42;	author krw;	state Exp;
branches;
next	1.16;
commitid	HPiN5WFu7IHVS6QO;

1.16
date	2016.01.13.13.13.04;	author gsoares;	state Exp;
branches;
next	1.15;
commitid	gRn5fFv7o2b1rqnH;

1.15
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	sbrB3Q5CNxcwZpfU;

1.14
date	2015.10.03.23.34.01;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	kBu5QmotV2F8kSw4;

1.13
date	2014.12.02.18.32.05;	author tedu;	state Exp;
branches;
next	1.12;
commitid	HL6lPua5IgqItkfW;

1.12
date	2013.11.21.15.54.46;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.01.20.11.06;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.25.04.39.04;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.25.21.12.50;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.04.04.26.40;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	97.09.01.18.30.38;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.06.18.20.34.45;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.12.14.12.18.27;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.21.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.26;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Add an explicit syntax() call to indicate that no binary op was
found. Makes gcc happier. Add __dead to function prototype as we
go by.

ok guenther@@
@
text
@/*	$OpenBSD: test.c,v 1.16 2016/01/13 13:13:04 gsoares Exp $	*/
/*	$NetBSD: test.c,v 1.15 1995/03/21 07:04:06 cgd Exp $	*/

/*
 * test(1); version 7-like  --  author Erik Baalbergen
 * modified by Eric Gisin to be used as built-in.
 * modified by Arnold Robbins to add SVR3 compatibility
 * (-x -c -b -p -u -g -k) plus Korn's -L -nt -ot -ef and new -S (socket).
 * modified by J.T. Conklin for NetBSD.
 *
 * This program is in the Public Domain.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <err.h>

/* test(1) accepts the following grammar:
	oexpr	::= aexpr | aexpr "-o" oexpr ;
	aexpr	::= nexpr | nexpr "-a" aexpr ;
	nexpr	::= primary | "!" primary
	primary	::= unary-operator operand
		| operand binary-operator operand
		| operand
		| "(" oexpr ")"
		;
	unary-operator ::= "-r"|"-w"|"-x"|"-f"|"-d"|"-c"|"-b"|"-p"|
		"-u"|"-g"|"-k"|"-s"|"-t"|"-z"|"-n"|"-o"|"-O"|"-G"|"-L"|"-S";

	binary-operator ::= "="|"!="|"-eq"|"-ne"|"-ge"|"-gt"|"-le"|"-lt"|
			"-nt"|"-ot"|"-ef";
	operand ::= <any legal UNIX file name>
*/

enum token {
	EOI,
	FILRD,
	FILWR,
	FILEX,
	FILEXIST,
	FILREG,
	FILDIR,
	FILCDEV,
	FILBDEV,
	FILFIFO,
	FILSOCK,
	FILSYM,
	FILGZ,
	FILTT,
	FILSUID,
	FILSGID,
	FILSTCK,
	FILNT,
	FILOT,
	FILEQ,
	FILUID,
	FILGID,
	STREZ,
	STRNZ,
	STREQ,
	STRNE,
	STRLT,
	STRGT,
	INTEQ,
	INTNE,
	INTGE,
	INTGT,
	INTLE,
	INTLT,
	UNOT,
	BAND,
	BOR,
	LPAREN,
	RPAREN,
	OPERAND
};

enum token_types {
	UNOP,
	BINOP,
	BUNOP,
	BBINOP,
	PAREN
};

struct t_op {
	const char *op_text;
	short op_num, op_type;
} const ops [] = {
	{"-r",	FILRD,	UNOP},
	{"-w",	FILWR,	UNOP},
	{"-x",	FILEX,	UNOP},
	{"-e",	FILEXIST,UNOP},
	{"-f",	FILREG,	UNOP},
	{"-d",	FILDIR,	UNOP},
	{"-c",	FILCDEV,UNOP},
	{"-b",	FILBDEV,UNOP},
	{"-p",	FILFIFO,UNOP},
	{"-u",	FILSUID,UNOP},
	{"-g",	FILSGID,UNOP},
	{"-k",	FILSTCK,UNOP},
	{"-s",	FILGZ,	UNOP},
	{"-t",	FILTT,	UNOP},
	{"-z",	STREZ,	UNOP},
	{"-n",	STRNZ,	UNOP},
	{"-h",	FILSYM,	UNOP},		/* for backwards compat */
	{"-O",	FILUID,	UNOP},
	{"-G",	FILGID,	UNOP},
	{"-L",	FILSYM,	UNOP},
	{"-S",	FILSOCK,UNOP},
	{"=",	STREQ,	BINOP},
	{"!=",	STRNE,	BINOP},
	{"<",	STRLT,	BINOP},
	{">",	STRGT,	BINOP},
	{"-eq",	INTEQ,	BINOP},
	{"-ne",	INTNE,	BINOP},
	{"-ge",	INTGE,	BINOP},
	{"-gt",	INTGT,	BINOP},
	{"-le",	INTLE,	BINOP},
	{"-lt",	INTLT,	BINOP},
	{"-nt",	FILNT,	BINOP},
	{"-ot",	FILOT,	BINOP},
	{"-ef",	FILEQ,	BINOP},
	{"!",	UNOT,	BUNOP},
	{"-a",	BAND,	BBINOP},
	{"-o",	BOR,	BBINOP},
	{"(",	LPAREN,	PAREN},
	{")",	RPAREN,	PAREN},
	{0,	0,	0}
};

char **t_wp;
struct t_op const *t_wp_op;

static enum token t_lex(char *);
static enum token t_lex_type(char *);
static int oexpr(enum token n);
static int aexpr(enum token n);
static int nexpr(enum token n);
static int binop(void);
static int primary(enum token n);
static int filstat(char *nm, enum token mode);
static int getn(const char *s);
static int newerf(const char *, const char *);
static int olderf(const char *, const char *);
static int equalf(const char *, const char *);
static __dead void syntax(const char *op, char *msg);

int
main(int argc, char *argv[])
{
	extern char *__progname;
	int	res;

	if (pledge("stdio rpath", NULL) == -1)
		err(2, "pledge");

	if (strcmp(__progname, "[") == 0) {
		if (strcmp(argv[--argc], "]"))
			errx(2, "missing ]");
		argv[argc] = NULL;
	}

	/* Implement special cases from POSIX.2, section 4.62.4 */
	switch (argc) {
	case 1:
		return 1;
	case 2:
		return (*argv[1] == '\0');
	case 3:
		if (argv[1][0] == '!' && argv[1][1] == '\0') {
			return !(*argv[2] == '\0');
		}
		break;
	case 4:
		if (argv[1][0] != '!' || argv[1][1] != '\0') {
			if (t_lex(argv[2]),
			    t_wp_op && t_wp_op->op_type == BINOP) {
				t_wp = &argv[1];
				return (binop() == 0);
			}
		}
		break;
	case 5:
		if (argv[1][0] == '!' && argv[1][1] == '\0') {
			if (t_lex(argv[3]),
			    t_wp_op && t_wp_op->op_type == BINOP) {
				t_wp = &argv[2];
				return !(binop() == 0);
			}
		}
		break;
	}

	t_wp = &argv[1];
	res = !oexpr(t_lex(*t_wp));

	if (*t_wp != NULL && *++t_wp != NULL)
		syntax(*t_wp, "unknown operand");

	return res;
}

static __dead void
syntax(const char *op, char *msg)
{
	if (op && *op)
		errx(2, "%s: %s", op, msg);
	else
		errx(2, "%s", msg);
}

static int
oexpr(enum token n)
{
	int res;

	res = aexpr(n);
	if (t_lex(*++t_wp) == BOR)
		return oexpr(t_lex(*++t_wp)) || res;
	t_wp--;
	return res;
}

static int
aexpr(enum token n)
{
	int res;

	res = nexpr(n);
	if (t_lex(*++t_wp) == BAND)
		return aexpr(t_lex(*++t_wp)) && res;
	t_wp--;
	return res;
}

static int
nexpr(enum token n)
{
	if (n == UNOT)
		return !nexpr(t_lex(*++t_wp));
	return primary(n);
}

static int
primary(enum token n)
{
	int res;

	if (n == EOI)
		syntax(NULL, "argument expected");
	if (n == LPAREN) {
		res = oexpr(t_lex(*++t_wp));
		if (t_lex(*++t_wp) != RPAREN)
			syntax(NULL, "closing paren expected");
		return res;
	}
	/*
	 * We need this, if not binary operations with more than 4
	 * arguments will always fall into unary.
	 */
	if(t_lex_type(t_wp[1]) == BINOP) {
		t_lex(t_wp[1]);
		if (t_wp_op && t_wp_op->op_type == BINOP)
			return binop();
	}

	if (t_wp_op && t_wp_op->op_type == UNOP) {
		/* unary expression */
		if (*++t_wp == NULL)
			syntax(t_wp_op->op_text, "argument expected");
		switch (n) {
		case STREZ:
			return strlen(*t_wp) == 0;
		case STRNZ:
			return strlen(*t_wp) != 0;
		case FILTT:
			return isatty(getn(*t_wp));
		default:
			return filstat(*t_wp, n);
		}
	}

	return strlen(*t_wp) > 0;
}

static int
binop(void)
{
	const char *opnd1, *opnd2;
	struct t_op const *op;

	opnd1 = *t_wp;
	(void) t_lex(*++t_wp);
	op = t_wp_op;

	if ((opnd2 = *++t_wp) == NULL)
		syntax(op->op_text, "argument expected");

	switch (op->op_num) {
	case STREQ:
		return strcmp(opnd1, opnd2) == 0;
	case STRNE:
		return strcmp(opnd1, opnd2) != 0;
	case STRLT:
		return strcmp(opnd1, opnd2) < 0;
	case STRGT:
		return strcmp(opnd1, opnd2) > 0;
	case INTEQ:
		return getn(opnd1) == getn(opnd2);
	case INTNE:
		return getn(opnd1) != getn(opnd2);
	case INTGE:
		return getn(opnd1) >= getn(opnd2);
	case INTGT:
		return getn(opnd1) > getn(opnd2);
	case INTLE:
		return getn(opnd1) <= getn(opnd2);
	case INTLT:
		return getn(opnd1) < getn(opnd2);
	case FILNT:
		return newerf(opnd1, opnd2);
	case FILOT:
		return olderf(opnd1, opnd2);
	case FILEQ:
		return equalf(opnd1, opnd2);
	}

	syntax(op->op_text, "not a binary operator");
}

static enum token
t_lex_type(char *s)
{
	struct t_op const *op = ops;

	if (s == NULL)
		return -1;

	while (op->op_text) {
		if (strcmp(s, op->op_text) == 0)
			return op->op_type;
		op++;
	}
	return -1;
}

static int
filstat(char *nm, enum token mode)
{
	struct stat s;
	mode_t i;

	if (mode == FILSYM) {
#ifdef S_IFLNK
		if (lstat(nm, &s) == 0) {
			i = S_IFLNK;
			goto filetype;
		}
#endif
		return 0;
	}

	if (stat(nm, &s) != 0)
		return 0;

	switch (mode) {
	case FILRD:
		return access(nm, R_OK) == 0;
	case FILWR:
		return access(nm, W_OK) == 0;
	case FILEX:
		return access(nm, X_OK) == 0;
	case FILEXIST:
		return access(nm, F_OK) == 0;
	case FILREG:
		i = S_IFREG;
		goto filetype;
	case FILDIR:
		i = S_IFDIR;
		goto filetype;
	case FILCDEV:
		i = S_IFCHR;
		goto filetype;
	case FILBDEV:
		i = S_IFBLK;
		goto filetype;
	case FILFIFO:
#ifdef S_IFIFO
		i = S_IFIFO;
		goto filetype;
#else
		return 0;
#endif
	case FILSOCK:
#ifdef S_IFSOCK
		i = S_IFSOCK;
		goto filetype;
#else
		return 0;
#endif
	case FILSUID:
		i = S_ISUID;
		goto filebit;
	case FILSGID:
		i = S_ISGID;
		goto filebit;
	case FILSTCK:
		i = S_ISVTX;
		goto filebit;
	case FILGZ:
		return s.st_size > 0L;
	case FILUID:
		return s.st_uid == geteuid();
	case FILGID:
		return s.st_gid == getegid();
	default:
		return 1;
	}

filetype:
	return ((s.st_mode & S_IFMT) == i);

filebit:
	return ((s.st_mode & i) != 0);
}

static enum token
t_lex(char *s)
{
	struct t_op const *op = ops;

	if (s == 0) {
		t_wp_op = NULL;
		return EOI;
	}
	while (op->op_text) {
		if (strcmp(s, op->op_text) == 0) {
			t_wp_op = op;
			return op->op_num;
		}
		op++;
	}
	t_wp_op = NULL;
	return OPERAND;
}

/* atoi with error detection */
static int
getn(const char *s)
{
	char *p;
	long r;

	errno = 0;
	r = strtol(s, &p, 10);

	if (errno != 0)
		errx(2, "%s: out of range", s);

	while (isspace((unsigned char)*p))
		p++;

	if (*p)
		errx(2, "%s: bad number", s);

	return (int) r;
}

static int
newerf(const char *f1, const char *f2)
{
	struct stat b1, b2;

	return (stat(f1, &b1) == 0 &&
	    stat(f2, &b2) == 0 &&
	    b1.st_mtime > b2.st_mtime);
}

static int
olderf(const char *f1, const char *f2)
{
	struct stat b1, b2;

	return (stat(f1, &b1) == 0 &&
	    stat(f2, &b2) == 0 &&
	    b1.st_mtime < b2.st_mtime);
}

static int
equalf(const char *f1, const char *f2)
{
	struct stat b1, b2;

	return (stat(f1, &b1) == 0 &&
	    stat(f2, &b2) == 0 &&
	    b1.st_dev == b2.st_dev &&
	    b1.st_ino == b2.st_ino);
}
@


1.16
log
@fix exit status on pledge fail, eval here should be 2.

OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.15 2015/10/09 01:37:06 deraadt Exp $	*/
d153 1
a153 1
static void syntax(const char *op, char *msg);
d334 2
a335 1
	/* NOTREACHED */
@


1.15
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.14 2015/10/03 23:34:01 deraadt Exp $	*/
d162 1
a162 1
		err(1, "pledge");
@


1.14
log
@tame "stdio rpath" is sufficient for all the operations done by test(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.13 2014/12/02 18:32:05 tedu Exp $	*/
d161 2
a162 2
	if (tame("stdio rpath", NULL) == -1)
		err(1, "tame");
@


1.13
log
@posix fix: should behave like [ when invoked as /bin/[
matches freebsd and other implementations
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.12 2013/11/21 15:54:46 deraadt Exp $	*/
d160 3
@


1.12
log
@add unsigned char casts for specific calls to ctype.h macros.
ok guenther step
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.11 2009/10/27 23:59:22 deraadt Exp $	*/
d158 1
d161 1
a161 1
	if (strcmp(argv[0], "[") == 0) {
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.10 2009/03/01 20:11:06 otto Exp $	*/
d462 1
a462 1
	while (isspace(*p))
@


1.10
log
@Fix PR #723: test(1) operator precedence inconsistent with POSIX
Make sure ksh builtin test and test(1) do not differ.
From Christiano Farina Haesbaert. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.9 2006/04/25 04:39:04 deraadt Exp $	*/
a12 4

#ifndef lint
static char rcsid[] = "$OpenBSD: test.c,v 1.9 2006/04/25 04:39:04 deraadt Exp $";
#endif
@


1.9
log
@mode_t is your friend
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.8 2003/06/25 21:12:50 deraadt Exp $	*/
d15 1
a15 1
static char rcsid[] = "$OpenBSD: test.c,v 1.8 2003/06/25 21:12:50 deraadt Exp $";
d146 1
d264 10
a289 4
	if (t_lex(t_wp[1]), t_wp_op && t_wp_op->op_type == BINOP) {
		return binop();
	}

d335 16
@


1.8
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.7 2002/07/04 04:26:40 deraadt Exp $	*/
d15 1
a15 1
static char rcsid[] = "$OpenBSD: test.c,v 1.7 2002/07/04 04:26:40 deraadt Exp $";
d334 1
a334 1
	int i;
@


1.7
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.6 2001/11/05 07:39:16 mpech Exp $	*/
d15 1
a15 1
static char rcsid[] = "$OpenBSD: test.c,v 1.6 2001/11/05 07:39:16 mpech Exp $";
d145 1
a145 1
static enum token t_lex();
d153 3
a155 3
static int newerf();
static int olderf();
static int equalf();
d453 1
a453 1
newerf(char *f1, char *f2)
d463 1
a463 1
olderf(char *f1, char *f2)
d473 1
a473 1
equalf(char *f1, char *f2)
@


1.6
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.5 1997/09/01 18:30:38 deraadt Exp $	*/
d15 1
a15 1
static char rcsid[] = "$OpenBSD: test.c,v 1.5 1997/09/01 18:30:38 deraadt Exp $";
d146 7
a152 7
static int oexpr();
static int aexpr();
static int nexpr();
static int binop();
static int primary();
static int filstat();
static int getn();
d156 1
a156 1
static void syntax();
d159 1
a159 3
main(argc, argv)
	int argc;
	char **argv;
d210 1
a210 3
syntax(op, msg)
	char	*op;
	char	*msg;
d219 1
a219 2
oexpr(n)
	enum token n;
d231 1
a231 2
aexpr(n)
	enum token n;
d243 1
a243 2
nexpr(n)
	enum token n;			/* token */
d251 1
a251 2
primary(n)
	enum token n;
d287 1
a287 1
binop()
d321 1
a321 1
		return newerf (opnd1, opnd2);
d323 1
a323 1
		return olderf (opnd1, opnd2);
d325 1
a325 1
		return equalf (opnd1, opnd2);
d331 1
a331 3
filstat(nm, mode)
	char *nm;
	enum token mode;
d411 1
a411 2
t_lex(s)
	char *s;
d432 1
a432 2
getn(s)
	char *s;
d441 1
a441 1
	  errx(2, "%s: out of range", s);
d444 1
a444 1
	  p++;
d447 1
a447 1
	  errx(2, "%s: bad number", s);
d453 1
a453 2
newerf (f1, f2)
char *f1, *f2;
d457 3
a459 3
	return (stat (f1, &b1) == 0 &&
		stat (f2, &b2) == 0 &&
		b1.st_mtime > b2.st_mtime);
d463 1
a463 2
olderf (f1, f2)
char *f1, *f2;
d467 3
a469 3
	return (stat (f1, &b1) == 0 &&
		stat (f2, &b2) == 0 &&
		b1.st_mtime < b2.st_mtime);
d473 1
a473 2
equalf (f1, f2)
char *f1, *f2;
d477 4
a480 4
	return (stat (f1, &b1) == 0 &&
		stat (f2, &b2) == 0 &&
		b1.st_dev == b2.st_dev &&
		b1.st_ino == b2.st_ino);
@


1.5
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.4 1997/06/18 20:34:45 kstailey Exp $	*/
d15 1
a15 1
static char rcsid[] = "$OpenBSD: test.c,v 1.4 1997/06/18 20:34:45 kstailey Exp $";
d297 1
a297 1
	register const char *opnd1, *opnd2;
d422 1
a422 1
	register char *s;
d424 1
a424 1
	register struct t_op const *op = ops;
@


1.4
log
@(foo *)0 -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.3 1996/12/14 12:18:27 mickey Exp $	*/
d15 1
a15 1
static char rcsid[] = "$OpenBSD: test.c,v 1.3 1996/12/14 12:18:27 mickey Exp $";
d184 1
a184 1
			if (t_lex(argv[2]), 
d193 1
a193 1
			if (t_lex(argv[3]), 
d289 1
a289 1
	}	  
d306 1
a306 1
		
d356 1
a356 1
	if (stat(nm, &s) != 0) 
d457 1
a457 1
	
@


1.3
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.2 1996/06/23 14:21:58 deraadt Exp $	*/
d15 1
a15 1
static char rcsid[] = "$OpenBSD: test.c,v 1.2 1996/06/23 14:21:58 deraadt Exp $";
d304 1
a304 1
	if ((opnd2 = *++t_wp) == (char *)0)
d427 1
a427 1
		t_wp_op = (struct t_op *)0;
d437 1
a437 1
	t_wp_op = (struct t_op *)0;
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.15 1995/03/21 07:04:06 cgd Exp $	*/
d15 1
a15 1
static char rcsid[] = "$OpenBSD: test.c,v 1.15 1995/03/21 07:04:06 cgd Exp $";
d211 1
a211 1
static void
@


1.1
log
@Initial revision
@
text
@d1 1
d15 1
a15 1
static char rcsid[] = "$NetBSD: test.c,v 1.15 1995/03/21 07:04:06 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
