head	1.23;
access;
symbols
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.18.0.8
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.6
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.4
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.2
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.18
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.16
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.14
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.12
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.8.0.12
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	sbrB3Q5CNxcwZpfU;

1.22
date	2015.10.04.15.01.47;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	Ed6QCkWlXVI8FCAs;

1.21
date	2015.01.16.06.39.31;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Uu5nFG3wCl0LACBb;

1.20
date	2015.01.05.13.52.47;	author tedu;	state Exp;
branches;
next	1.19;
commitid	T8ysyNQRt0arnpdn;

1.19
date	2014.12.11.20.39.06;	author tedu;	state Exp;
branches;
next	1.18;
commitid	hA0tUa9ZSMInZpm5;

1.18
date	2013.06.01.16.46.49;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2012.07.12.14.28.13;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.10.13.45.17;	author chl;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.11.23.42.12;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.32.07;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.06.22.31.54;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.04.20.32.27;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.07.14.39.27;	author hugh;	state Exp;
branches;
next	1.8;

1.8
date	98.04.30.05.55.02;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.11.15.22.10.22;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	97.08.25.15.24.07;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.02.14.07.05.20;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.12.14.12.17.49;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.19.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.12.38.51;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.06;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Change all tame callers to namechange to pledge(2).
@
text
@/*	$OpenBSD: dd.c,v 1.22 2015/10/04 15:01:47 deraadt Exp $	*/
/*	$NetBSD: dd.c,v 1.6 1996/02/20 19:29:06 jtc Exp $	*/

/*-
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego and Lance
 * Visser of Convex Computer Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/mtio.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "dd.h"
#include "extern.h"

static void dd_close(void);
static void dd_in(void);
static void getfdtype(IO *);
static void setup(void);

#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

IO	in, out;		/* input/output state */
STAT	st;			/* statistics */
void	(*cfunc)(void);		/* conversion function */
size_t	cpy_cnt;		/* # of blocks to copy */
u_int	ddflags;		/* conversion options */
size_t	cbsz;			/* conversion block size */
size_t	files_cnt = 1;		/* # of files to copy */
const	u_char	*ctab;		/* conversion table */

int
main(int argc, char *argv[])
{
	jcl(argv);
	setup();

	(void)signal(SIGINFO, summaryx);
	(void)signal(SIGINT, terminate);

	atexit(summary);

	if (cpy_cnt != (size_t)-1) {
		while (files_cnt--)
			dd_in();
	}

	dd_close();
	exit(0);
}

static void
setup(void)
{
	if (in.name == NULL) {
		in.name = "stdin";
		in.fd = STDIN_FILENO;
	} else {
		in.fd = open(in.name, O_RDONLY, 0);
		if (in.fd < 0)
			err(1, "%s", in.name);
	}

	getfdtype(&in);

	if (files_cnt > 1 && !(in.flags & ISTAPE))
		errx(1, "files is not supported for non-tape devices");

	if (out.name == NULL) {
		/* No way to check for read access here. */
		out.fd = STDOUT_FILENO;
		out.name = "stdout";
	} else {
#define	OFLAGS \
    (O_CREAT | (ddflags & (C_SEEK | C_NOTRUNC) ? 0 : O_TRUNC))
		out.fd = open(out.name, O_RDWR | OFLAGS, DEFFILEMODE);
		/*
		 * May not have read access, so try again with write only.
		 * Without read we may have a problem if output also does
		 * not support seeks.
		 */
		if (out.fd < 0) {
			out.fd = open(out.name, O_WRONLY | OFLAGS, DEFFILEMODE);
			out.flags |= NOREAD;
		}
		if (out.fd < 0)
			err(1, "%s", out.name);
	}

	getfdtype(&out);

	/*
	 * Allocate space for the input and output buffers.  If not doing
	 * record oriented I/O, only need a single buffer.
	 */
	if (!(ddflags & (C_BLOCK|C_UNBLOCK))) {
		if ((in.db = malloc(out.dbsz + in.dbsz - 1)) == NULL)
			err(1, "input buffer");
		out.db = in.db;
	} else if ((in.db =
	    malloc((u_int)(MAXIMUM(in.dbsz, cbsz) + cbsz))) == NULL ||
	    (out.db = malloc((u_int)(out.dbsz + cbsz))) == NULL)
		err(1, "output buffer");
	in.dbp = in.db;
	out.dbp = out.db;

	/* Position the input/output streams. */
	if (in.offset)
		pos_in();
	if (out.offset)
		pos_out();

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	/*
	 * Truncate the output file; ignore errors because it fails on some
	 * kinds of output files, tapes, for example.
	 */
	if ((ddflags & (C_OF | C_SEEK | C_NOTRUNC)) == (C_OF | C_SEEK))
		(void)ftruncate(out.fd, out.offset * out.dbsz);

	/*
	 * If converting case at the same time as another conversion, build a
	 * table that does both at once.  If just converting case, use the
	 * built-in tables.
	 */
	if (ddflags & (C_LCASE|C_UCASE)) {
#ifdef	NO_CONV
		/* Should not get here, but just in case... */
		errx(1, "case conv and -DNO_CONV");
#else	/* NO_CONV */
		u_int cnt;
		if (ddflags & C_ASCII || ddflags & C_EBCDIC) {
			if (ddflags & C_LCASE) {
				for (cnt = 0; cnt < 0377; ++cnt)
					casetab[cnt] = tolower(ctab[cnt]);
			} else {
				for (cnt = 0; cnt < 0377; ++cnt)
					casetab[cnt] = toupper(ctab[cnt]);
			}
		} else {
			if (ddflags & C_LCASE) {
				for (cnt = 0; cnt < 0377; ++cnt)
					casetab[cnt] = tolower(cnt);
			} else {
				for (cnt = 0; cnt < 0377; ++cnt)
					casetab[cnt] = toupper(cnt);
			}
		}

		ctab = casetab;
#endif	/* NO_CONV */
	}

	/* Statistics timestamp. */
	(void)gettimeofday(&st.startv, (struct timezone *)NULL);
}

static void
getfdtype(IO *io)
{
	struct mtget mt;
	struct stat sb;

	if (fstat(io->fd, &sb))
		err(1, "%s", io->name);
	if (S_ISCHR(sb.st_mode))
		io->flags |= ioctl(io->fd, MTIOCGET, &mt) ? ISCHR : ISTAPE;
	if (S_ISFIFO(sb.st_mode) || S_ISSOCK(sb.st_mode))
		io->flags |= ISPIPE;
}

static void
swapbytes(void *v, size_t len)
{
	unsigned char *p = v;
	unsigned char t;

	while (len > 1) {
		t = p[0];
		p[0] = p[1];
		p[1] = t;
		p += 2;
		len -= 2;
	}
}


static void
dd_in(void)
{
	ssize_t n;

	for (;;) {
		if (cpy_cnt && (st.in_full + st.in_part) >= cpy_cnt)
			return;

		/*
		 * Zero the buffer first if sync; if doing block operations
		 * use spaces.
		 */
		if (ddflags & C_SYNC) {
			if (ddflags & (C_BLOCK|C_UNBLOCK))
				(void)memset(in.dbp, ' ', in.dbsz);
			else
				(void)memset(in.dbp, 0, in.dbsz);
		}

		n = read(in.fd, in.dbp, in.dbsz);
		if (n == 0) {
			in.dbrcnt = 0;
			return;
		}

		/* Read error. */
		if (n < 0) {
			/*
			 * If noerror not specified, die.  POSIX requires that
			 * the warning message be followed by an I/O display.
			 */
			if (!(ddflags & C_NOERROR))
				err(1, "%s", in.name);
			warn("%s", in.name);
			summary();

			/*
			 * If it's not a tape drive or a pipe, seek past the
			 * error.  If your OS doesn't do the right thing for
			 * raw disks this section should be modified to re-read
			 * in sector size chunks.
			 */
			if (!(in.flags & (ISPIPE|ISTAPE)) &&
			    lseek(in.fd, (off_t)in.dbsz, SEEK_CUR))
				warn("%s", in.name);

			/* If sync not specified, omit block and continue. */
			if (!(ddflags & C_SYNC))
				continue;

			/* Read errors count as full blocks. */
			in.dbcnt += in.dbrcnt = in.dbsz;
			++st.in_full;

		/* Handle full input blocks. */
		} else if (n == in.dbsz) {
			in.dbcnt += in.dbrcnt = n;
			++st.in_full;

		/* Handle partial input blocks. */
		} else {
			/* If sync, use the entire block. */
			if (ddflags & C_SYNC)
				in.dbcnt += in.dbrcnt = in.dbsz;
			else
				in.dbcnt += in.dbrcnt = n;
			++st.in_part;
		}

		/*
		 * POSIX states that if bs is set and no other conversions
		 * than noerror, notrunc or sync are specified, the block
		 * is output without buffering as it is read.
		 */
		if (ddflags & C_BS) {
			out.dbcnt = in.dbcnt;
			dd_out(1);
			in.dbcnt = 0;
			continue;
		}

		if (ddflags & C_SWAB) {
			if ((n = in.dbrcnt) & 1) {
				++st.swab;
				--n;
			}
			swapbytes(in.dbp, n);
		}

		in.dbp += in.dbrcnt;
		(*cfunc)();
	}
}

/*
 * Cleanup any remaining I/O and flush output.  If necessary, output file
 * is truncated.
 */
static void
dd_close(void)
{
	if (cfunc == def)
		def_close();
	else if (cfunc == block)
		block_close();
	else if (cfunc == unblock)
		unblock_close();
	if (ddflags & C_OSYNC && out.dbcnt && out.dbcnt < out.dbsz) {
		if (ddflags & (C_BLOCK|C_UNBLOCK))
			memset(out.dbp, ' ', out.dbsz - out.dbcnt);
		else
			memset(out.dbp, 0, out.dbsz - out.dbcnt);
		out.dbcnt = out.dbsz;
	}
	if (out.dbcnt)
		dd_out(1);
}

void
dd_out(int force)
{
	static int warned;
	size_t cnt, n;
	ssize_t nw;
	u_char *outp;

	/*
	 * Write one or more blocks out.  The common case is writing a full
	 * output block in a single write; increment the full block stats.
	 * Otherwise, we're into partial block writes.  If a partial write,
	 * and it's a character device, just warn.  If a tape device, quit.
	 *
	 * The partial writes represent two cases.  1: Where the input block
	 * was less than expected so the output block was less than expected.
	 * 2: Where the input block was the right size but we were forced to
	 * write the block in multiple chunks.  The original versions of dd(1)
	 * never wrote a block in more than a single write, so the latter case
	 * never happened.
	 *
	 * One special case is if we're forced to do the write -- in that case
	 * we play games with the buffer size, and it's usually a partial write.
	 */
	outp = out.db;
	for (n = force ? out.dbcnt : out.dbsz;; n = out.dbsz) {
		for (cnt = n;; cnt -= nw) {
			nw = write(out.fd, outp, cnt);
			if (nw <= 0) {
				if (nw == 0)
					errx(1, "%s: end of device", out.name);
				if (errno != EINTR)
					err(1, "%s", out.name);
				nw = 0;
			}
			outp += nw;
			st.bytes += nw;
			if (nw == n) {
				if (n != out.dbsz)
					++st.out_part;
				else
					++st.out_full;
				break;
			}
			++st.out_part;
			if (nw == cnt)
				break;
			if (out.flags & ISCHR && !warned) {
				warned = 1;
				warnx("%s: short write on character device",
				    out.name);
			}
			if (out.flags & ISTAPE)
				errx(1, "%s: short write on tape device", out.name);
		}
		if ((out.dbcnt -= n) < out.dbsz)
			break;
	}

	/* Reassemble the output block. */
	if (out.dbcnt)
		(void)memmove(out.db, out.dbp - out.dbcnt, out.dbcnt);
	out.dbp = out.db + out.dbcnt;
}
@


1.22
log
@after dd has opened it's files and done the tape positioning ioctl, we
can tame "stdio" it.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.21 2015/01/16 06:39:31 deraadt Exp $	*/
d152 2
a153 2
	if (tame("stdio", NULL) == -1)
		err(1, "tame");
@


1.21
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.20 2015/01/05 13:52:47 tedu Exp $	*/
d151 3
@


1.20
log
@use the correct read count when determining how swabbing is necessary.
bug report from Martin Wolters
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.19 2014/12/11 20:39:06 tedu Exp $	*/
d37 1
a37 1
#include <sys/param.h>
d60 2
d140 1
a140 1
	    malloc((u_int)(MAX(in.dbsz, cbsz) + cbsz))) == NULL ||
@


1.19
log
@use a local swapbytes function instead of relying on undefined
overlapping swab behavior. vaguely ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.18 2013/06/01 16:46:49 tedu Exp $	*/
d307 1
a307 1
			if ((n = in.dbcnt) & 1) {
@


1.18
log
@consolidate ifdef blocks by moving a variable
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.17 2012/07/12 14:28:13 millert Exp $	*/
d209 16
d311 1
a311 1
			swab(in.dbp, in.dbp, n);
@


1.17
log
@Use S_ISFIFO and S_ISSOCK instead of lseek() to determine whether
an fd is a socket, pipe or named pipe.  OK deraadt@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.16 2009/10/27 23:59:21 deraadt Exp $	*/
a91 4
#ifndef NO_CONV
	u_int cnt;
#endif

d167 1
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.15 2007/11/10 13:45:17 chl Exp $	*/
d207 2
a208 2
	else if (lseek(io->fd, (off_t)0, SEEK_CUR) == -1 && errno == ESPIPE)
		io->flags |= ISPIPE;		/* XXX fixed in 4.4BSD */
@


1.15
log
@remove "unused variable" warning appearing when building release

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.14 2003/06/11 23:42:12 deraadt Exp $	*/
a35 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1991, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)dd.c	8.5 (Berkeley) 4/2/94";
#else
static char rcsid[] = "$OpenBSD: dd.c,v 1.14 2003/06/11 23:42:12 deraadt Exp $";
#endif
#endif /* not lint */
@


1.14
log
@ansification, art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.13 2003/06/02 23:32:07 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dd.c,v 1.13 2003/06/02 23:32:07 millert Exp $";
d106 1
d108 1
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.12 2002/02/16 21:27:06 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dd.c,v 1.12 2002/02/16 21:27:06 millert Exp $";
d84 1
a84 3
main(argc, argv)
	int argc;
	char *argv[];
d104 1
a104 1
setup()
d210 1
a210 2
getfdtype(io)
	IO *io;
d224 1
a224 1
dd_in()
d323 1
a323 1
dd_close()
d343 1
a343 2
dd_out(force)
	int force;
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.11 2001/10/06 22:31:54 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dd.c,v 1.11 2001/10/06 22:31:54 millert Exp $";
@


1.11
log
@Fix ``echo foo |dd'' which was broken by the last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.10 2001/10/04 20:32:27 millert Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: dd.c,v 1.10 2001/10/04 20:32:27 millert Exp $";
d73 4
a76 4
static void dd_close __P((void));
static void dd_in __P((void));
static void getfdtype __P((IO *));
static void setup __P((void));
d80 1
a80 1
void	(*cfunc) __P((void));	/* conversion function */
@


1.10
log
@Move check for count=0 into dd's main.  We want to do normal setup
in this case and just don't want to actually copy any data.
Fixes a problem noted by aaron@@ where the time portion of the summary
would be wrong and also gives us sane behavior when seek is non-zero
but count is 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.9 2001/08/07 14:39:27 hugh Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: dd.c,v 1.9 2001/08/07 14:39:27 hugh Exp $";
d100 1
a100 1
	if (cpy_cnt > 0) {
@


1.9
log
@Modify timekeeping in an effort to produce a sane bandwidth measure
for a short running dd process. Some floating point is used so that
microsecond precision can be kept without shortening the off_t
excessively. millert says ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.8 1998/04/30 05:55:02 deraadt Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: dd.c,v 1.8 1998/04/30 05:55:02 deraadt Exp $";
d100 4
a103 2
	while (files_cnt--)
		dd_in();
@


1.8
log
@Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.7 1997/11/15 22:10:22 todd Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: dd.c,v 1.7 1997/11/15 22:10:22 todd Exp $";
d209 2
a210 1
	(void)time(&st.start);			/* Statistics timestamp. */
@


1.7
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.6 1997/08/25 15:24:07 deraadt Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: dd.c,v 1.6 1997/08/25 15:24:07 deraadt Exp $";
d240 1
a240 1
		if (ddflags & C_SYNC)
d245 1
@


1.6
log
@clear input buffer to ' ' or \0 correctly; jlemon@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.5 1997/02/14 07:05:20 millert Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: dd.c,v 1.5 1997/02/14 07:05:20 millert Exp $";
d322 1
a322 1
 * Cleanup any remaining I/O and flush output.  If necesssary, output file
@


1.5
log
@Deal with 64-bit offsets and report bytes copied as a 64-bit quantity.
Closes OpenBSD PR system/107.
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.4 1996/12/14 12:17:49 mickey Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: dd.c,v 1.4 1996/12/14 12:17:49 mickey Exp $";
a229 1
	int flags;
d232 1
a232 1
	for (flags = ddflags;;) {
d237 1
a237 2
		 * Zero the buffer first if trying to recover from errors so
		 * lose the minimum amount of data.  If doing block operations
d240 2
a241 2
		if ((flags & (C_NOERROR|C_SYNC)) == (C_NOERROR|C_SYNC))
			if (flags & (C_BLOCK|C_UNBLOCK))
d258 1
a258 1
			if (!(flags & C_NOERROR))
d334 5
a338 2
	if (ddflags & C_OSYNC && out.dbcnt < out.dbsz) {
		(void)memset(out.dbp, 0, out.dbsz - out.dbcnt);
@


1.4
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.3 1996/06/23 14:19:47 deraadt Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: dd.c,v 1.3 1996/06/23 14:19:47 deraadt Exp $";
d81 1
a81 1
u_long	cpy_cnt;		/* # of blocks to copy */
d83 3
a85 3
u_int	cbsz;			/* conversion block size */
u_int	files_cnt = 1;		/* # of files to copy */
const u_char	*ctab;		/* conversion table */
d175 1
a175 1
		(void)ftruncate(out.fd, (off_t)out.offset * out.dbsz);
d230 2
a231 1
	int flags, n;
d244 1
a244 1
				memset(in.dbp, ' ', in.dbsz);
d246 1
a246 1
				memset(in.dbp, 0, in.dbsz);
d337 1
a337 1
		memset(out.dbp, 0, out.dbsz - out.dbcnt);
d349 2
a350 1
	int cnt, n, nw;
d406 1
a406 1
		memmove(out.db, out.dbp - out.dbcnt, out.dbcnt);
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: dd.c,v 1.6 1996/02/20 19:29:06 jtc Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: dd.c,v 1.6 1996/02/20 19:29:06 jtc Exp $";
d155 1
a155 1
			err(1, NULL);
d160 1
a160 1
		err(1, NULL);
d174 1
a174 1
	if (ddflags & (C_OF | C_SEEK | C_NOTRUNC) == (C_OF | C_SEEK))
@


1.2
log
@From NetBSD: Use const qualifier with conversion, args and clist tables
@
text
@d1 1
d51 1
a51 1
static char rcsid[] = "$NetBSD: dd.c,v 1.6 1996/02/20 19:29:06 jtc Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: dd.c,v 1.5 1995/10/08 23:01:24 gwr Exp $	*/
d50 1
a50 1
static char rcsid[] = "$NetBSD: dd.c,v 1.5 1995/10/08 23:01:24 gwr Exp $";
d84 1
a84 1
u_char	*ctab;			/* conversion table */
d186 1
a186 1
		if (ddflags & C_ASCII)
d189 1
a189 2
					if (isupper(ctab[cnt]))
						ctab[cnt] = tolower(ctab[cnt]);
d192 1
a192 2
					if (islower(ctab[cnt]))
						ctab[cnt] = toupper(ctab[cnt]);
d194 1
a194 1
		else if (ddflags & C_EBCDIC)
d197 1
a197 2
					if (isupper(cnt))
						ctab[cnt] = ctab[tolower(cnt)];
d200 1
a200 2
					if (islower(cnt))
						ctab[cnt] = ctab[toupper(cnt)];
d202 3
a204 2
		else
			ctab = ddflags & C_LCASE ? u2l : l2u;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
