head	1.28;
access;
symbols
	OPENBSD_6_0:1.26.0.8
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.4
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.19.0.6
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.4
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.2
	OPENBSD_5_0:1.18.0.8
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.14
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.10
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.8
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.6
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.8.0.12
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2016.08.16.16.44.55;	author krw;	state Exp;
branches;
next	1.27;
commitid	7RqJkd00r8P43axL;

1.27
date	2016.08.14.13.40.55;	author tedu;	state Exp;
branches;
next	1.26;
commitid	3sYFkL96EvxXCi9s;

1.26
date	2014.09.14.22.44.47;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	G5na6TwVXhNAvwB0;

1.25
date	2014.05.21.06.23.02;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2014.03.27.15.32.13;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2014.03.24.21.42.41;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2014.02.12.01.18.36;	author bluhm;	state Exp;
branches;
next	1.21;

1.21
date	2013.11.11.23.07.28;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.01.18.57.59;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2011.10.18.09.37.35;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.11.01.05.46.20;	author ray;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.22.18.08.04;	author dhill;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.08.01.46.45;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.11.23.42.12;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.32.07;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.06.22.31.54;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.04.20.32.27;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.07.14.39.27;	author hugh;	state Exp;
branches;
next	1.8;

1.8
date	98.07.09.18.39.23;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.11.15.22.10.22;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	97.02.14.07.05.18;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.12.17.47;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.14.19.45;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.15.01.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.12.38.48;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Nuke a bunch of whitespace nits seen while '%q' hunting.
@
text
@/*	$OpenBSD: args.c,v 1.27 2016/08/14 13:40:55 tedu Exp $	*/
/*	$NetBSD: args.c,v 1.7 1996/03/01 01:18:58 jtc Exp $	*/

/*-
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego and Lance
 * Visser of Convex Computer Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/time.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "dd.h"
#include "extern.h"

static int	c_arg(const void *, const void *);
static void	f_bs(char *);
static void	f_cbs(char *);
static void	f_conv(char *);
static void	f_count(char *);
static void	f_files(char *);
static void	f_ibs(char *);
static void	f_if(char *);
static void	f_obs(char *);
static void	f_of(char *);
static void	f_seek(char *);
static void	f_skip(char *);
static void	f_status(char *);
static size_t	get_bsz(char *);
static off_t	get_off(char *);

static const struct arg {
	const char *name;
	void (*f)(char *);
	u_int set, noset;
} args[] = {
	{ "bs",		f_bs,		C_BS,	 C_BS|C_IBS|C_OBS|C_OSYNC },
	{ "cbs",	f_cbs,		C_CBS,	 C_CBS },
	{ "conv",	f_conv,		0,	 0 },
	{ "count",	f_count,	C_COUNT, C_COUNT },
	{ "files",	f_files,	C_FILES, C_FILES },
	{ "ibs",	f_ibs,		C_IBS,	 C_BS|C_IBS },
	{ "if",		f_if,		C_IF,	 C_IF },
	{ "obs",	f_obs,		C_OBS,	 C_BS|C_OBS },
	{ "of",		f_of,		C_OF,	 C_OF },
	{ "seek",	f_seek,		C_SEEK,	 C_SEEK },
	{ "skip",	f_skip,		C_SKIP,	 C_SKIP },
	{ "status",	f_status,	C_STATUS,C_STATUS },
};

static char *oper;

/*
 * args -- parse JCL syntax of dd.
 */
void
jcl(char **argv)
{
	struct arg *ap, tmp;
	char *arg;

	in.dbsz = out.dbsz = 512;

	while ((oper = *++argv) != NULL) {
		if ((oper = strdup(oper)) == NULL)
			errx(1, "out of memory");
		if ((arg = strchr(oper, '=')) == NULL)
			errx(1, "unknown operand %s", oper);
		*arg++ = '\0';
		if (!*arg)
			errx(1, "no value specified for %s", oper);
		tmp.name = oper;
		if (!(ap = (struct arg *)bsearch(&tmp, args,
		    sizeof(args)/sizeof(struct arg), sizeof(struct arg),
		    c_arg)))
			errx(1, "unknown operand %s", tmp.name);
		if (ddflags & ap->noset)
			errx(1, "%s: illegal argument combination or already set",
			    tmp.name);
		ddflags |= ap->set;
		ap->f(arg);
	}

	/* Final sanity checks. */

	if (ddflags & C_BS) {
		/*
		 * Bs is turned off by any conversion -- we assume the user
		 * just wanted to set both the input and output block sizes
		 * and didn't want the bs semantics, so we don't warn.
		 */
		if (ddflags & (C_BLOCK|C_LCASE|C_SWAB|C_UCASE|C_UNBLOCK))
			ddflags &= ~C_BS;

		/* Bs supersedes ibs and obs. */
		if (ddflags & C_BS && ddflags & (C_IBS|C_OBS))
			warnx("bs supersedes ibs and obs");
	}

	/*
	 * Ascii/ebcdic and cbs implies block/unblock.
	 * Block/unblock requires cbs and vice-versa.
	 */
	if (ddflags & (C_BLOCK|C_UNBLOCK)) {
		if (!(ddflags & C_CBS))
			errx(1, "record operations require cbs");
		if (cbsz == 0)
			errx(1, "cbs cannot be zero");
		cfunc = ddflags & C_BLOCK ? block : unblock;
	} else if (ddflags & C_CBS) {
		if (ddflags & (C_ASCII|C_EBCDIC)) {
			if (ddflags & C_ASCII) {
				ddflags |= C_UNBLOCK;
				cfunc = unblock;
			} else {
				ddflags |= C_BLOCK;
				cfunc = block;
			}
		} else
			errx(1, "cbs meaningless if not doing record operations");
		if (cbsz == 0)
			errx(1, "cbs cannot be zero");
	} else
		cfunc = def;

	if (in.dbsz == 0 || out.dbsz == 0)
		errx(1, "buffer sizes cannot be zero");

	/*
	 * Read and write take size_t's as arguments.  Lseek, however,
	 * takes an off_t.
	 */
	if (cbsz > SSIZE_MAX || in.dbsz > SSIZE_MAX || out.dbsz > SSIZE_MAX)
		errx(1, "buffer sizes cannot be greater than %zd",
		    (ssize_t)SSIZE_MAX);
	if (in.offset > LLONG_MAX / in.dbsz || out.offset > LLONG_MAX / out.dbsz)
		errx(1, "seek offsets cannot be larger than %lld", LLONG_MAX);
}

static int
c_arg(const void *a, const void *b)
{

	return (strcmp(((struct arg *)a)->name, ((struct arg *)b)->name));
}

static void
f_bs(char *arg)
{

	in.dbsz = out.dbsz = get_bsz(arg);
}

static void
f_cbs(char *arg)
{

	cbsz = get_bsz(arg);
}

static void
f_count(char *arg)
{

	if ((cpy_cnt = get_bsz(arg)) == 0)
		cpy_cnt = (size_t)-1;
}

static void
f_files(char *arg)
{

	files_cnt = get_bsz(arg);
}

static void
f_ibs(char *arg)
{

	if (!(ddflags & C_BS))
		in.dbsz = get_bsz(arg);
}

static void
f_if(char *arg)
{

	in.name = arg;
}

static void
f_obs(char *arg)
{

	if (!(ddflags & C_BS))
		out.dbsz = get_bsz(arg);
}

static void
f_of(char *arg)
{

	out.name = arg;
}

static void
f_seek(char *arg)
{

	out.offset = get_off(arg);
}

static void
f_skip(char *arg)
{

	in.offset = get_off(arg);
}

static void
f_status(char *arg)
{

	if (strcmp(arg, "none") == 0)
		ddflags |= C_NOINFO;
	else if (strcmp(arg, "noxfer") == 0)
		ddflags |= C_NOXFER;
	else
		errx(1, "unknown status %s", arg);
}


static const struct conv {
	const char *name;
	u_int set, noset;
	const u_char *ctab;
} clist[] = {
#ifndef	NO_CONV
	{ "ascii",	C_ASCII,	C_EBCDIC,	e2a_POSIX },
	{ "block",	C_BLOCK,	C_UNBLOCK,	NULL },
	{ "ebcdic",	C_EBCDIC,	C_ASCII,	a2e_POSIX },
	{ "ibm",	C_EBCDIC,	C_ASCII,	a2ibm_POSIX },
	{ "lcase",	C_LCASE,	C_UCASE,	NULL },
	{ "osync",	C_OSYNC,	C_BS,		NULL },
	{ "swab",	C_SWAB,		0,		NULL },
	{ "sync",	C_SYNC,		0,		NULL },
	{ "ucase",	C_UCASE,	C_LCASE,	NULL },
	{ "unblock",	C_UNBLOCK,	C_BLOCK,	NULL },
#endif
	{ "noerror",	C_NOERROR,	0,		NULL },
	{ "notrunc",	C_NOTRUNC,	0,		NULL },
	{ NULL,		0,		0,		NULL }
};

static void
f_conv(char *arg)
{
	const struct conv *cp;
	const char *name;

	while (arg != NULL) {
		name = strsep(&arg, ",");
		for (cp = &clist[0]; cp->name; cp++)
			if (strcmp(name, cp->name) == 0)
				break;
		if (!cp->name)
			errx(1, "unknown conversion %s", name);
		if (ddflags & cp->noset)
			errx(1, "%s: illegal conversion combination", name);
		ddflags |= cp->set;
		if (cp->ctab)
			ctab = cp->ctab;
	}
}

/*
 * Convert an expression of the following forms to a size_t
 *	1) A positive decimal number, optionally followed by
 *		b - multiply by 512.
 *		k, m or g - multiply by 1024 each.
 *		w - multiply by sizeof int
 *	2) Two or more of the above, separated by x
 *	   (or * for backwards compatibility), specifying
 *	   the product of the indicated values.
 */
static size_t
get_bsz(char *val)
{
	size_t num, t;
	char *expr;

	if (strchr(val, '-'))
		errx(1, "%s: illegal numeric value", oper);

	errno = 0;
	num = strtoul(val, &expr, 0);
	if (num == ULONG_MAX && errno == ERANGE)	/* Overflow. */
		err(1, "%s", oper);
	if (expr == val)			/* No digits. */
		errx(1, "%s: illegal numeric value", oper);

	switch(*expr) {
	case 'b':
		t = num;
		num *= 512;
		if (t > num)
			goto erange;
		++expr;
		break;
	case 'g':
	case 'G':
		t = num;
		num *= 1024;
		if (t > num)
			goto erange;
		/* fallthrough */
	case 'm':
	case 'M':
		t = num;
		num *= 1024;
		if (t > num)
			goto erange;
		/* fallthrough */
	case 'k':
	case 'K':
		t = num;
		num *= 1024;
		if (t > num)
			goto erange;
		++expr;
		break;
	case 'w':
		t = num;
		num *= sizeof(int);
		if (t > num)
			goto erange;
		++expr;
		break;
	}

	switch(*expr) {
		case '\0':
			break;
		case '*':			/* Backward compatible. */
		case 'x':
			t = num;
			num *= get_bsz(expr + 1);
			if (t > num)
				goto erange;
			break;
		default:
			errx(1, "%s: illegal numeric value", oper);
	}
	return (num);
erange:
	errc(1, ERANGE, "%s", oper);
}

/*
 * Convert an expression of the following forms to an off_t
 *	1) A positive decimal number, optionally followed by
 *		b - multiply by 512.
 *		k, m or g - multiply by 1024 each.
 *		w - multiply by sizeof int
 *	2) Two or more of the above, separated by x
 *	   (or * for backwards compatibility), specifying
 *	   the product of the indicated values.
 */
static off_t
get_off(char *val)
{
	off_t num, t;
	char *expr;

	num = strtoll(val, &expr, 0);
	if (num == LLONG_MAX)			/* Overflow. */
		err(1, "%s", oper);
	if (expr == val)			/* No digits. */
		errx(1, "%s: illegal numeric value", oper);

	switch(*expr) {
	case 'b':
		t = num;
		num *= 512;
		if (t > num)
			goto erange;
		++expr;
		break;
	case 'g':
	case 'G':
		t = num;
		num *= 1024;
		if (t > num)
			goto erange;
		/* fallthrough */
	case 'm':
	case 'M':
		t = num;
		num *= 1024;
		if (t > num)
			goto erange;
		/* fallthrough */
	case 'k':
	case 'K':
		t = num;
		num *= 1024;
		if (t > num)
			goto erange;
		++expr;
		break;
	case 'w':
		t = num;
		num *= sizeof(int);
		if (t > num)
			goto erange;
		++expr;
		break;
	}

	switch(*expr) {
		case '\0':
			break;
		case '*':			/* Backward compatible. */
		case 'x':
			t = num;
			num *= get_off(expr + 1);
			if (t > num)
				goto erange;
			break;
		default:
			errx(1, "%s: illegal numeric value", oper);
	}
	return (num);
erange:
	errc(1, ERANGE, "%s", oper);
}
@


1.27
log
@replace strtoq with strtoll. ok openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.26 2014/09/14 22:44:47 schwarze Exp $	*/
d312 1
a312 1
 * 	1) A positive decimal number, optionally followed by
d395 1
a395 1
 * 	1) A positive decimal number, optionally followed by
@


1.26
log
@Error out when negative values are given for sizes on the command line.
Do not error out when the maximum permissible value is given,
but only when it is exceeded.
Patch from William Orr <will at worrbase dot com> using feedback from tedu@@.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.25 2014/05/21 06:23:02 guenther Exp $	*/
d165 1
a165 1
	 * takes an off_t (quad).
d170 2
a171 2
	if (in.offset > QUAD_MAX / in.dbsz || out.offset > QUAD_MAX / out.dbsz)
		errx(1, "seek offsets cannot be larger than %qd", QUAD_MAX);
d409 2
a410 2
	num = strtoq(val, &expr, 0);
	if (num == QUAD_MAX)			/* Overflow. */
@


1.25
log
@Use errc/warnc to simplify code.

ok jca@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.24 2014/03/27 15:32:13 tedu Exp $	*/
d326 4
d331 1
a331 1
	if (num == SIZE_T_MAX)			/* Overflow. */
@


1.24
log
@The "old" conversions are not mandated by any standard and are
underspecified. The man page offers little guidance as to their use.
Remove them and spare people the (likely poor) decision to use them.
ok deraadt jmc millert
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.23 2014/03/24 21:42:41 tedu Exp $	*/
d386 1
a386 1
	errx(1, "%s: %s", oper, strerror(ERANGE));
d465 1
a465 1
	errx(1, "%s: %s", oper, strerror(ERANGE));
@


1.23
log
@support gigabytes. also update some comments and make goto label nicer.
ok deraadt jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.22 2014/02/12 01:18:36 bluhm Exp $	*/
a277 3
	{ "oldascii",	C_ASCII,	C_EBCDIC,	e2a_32V },
	{ "oldebcdic",	C_EBCDIC,	C_ASCII,	a2e_32V },
	{ "oldibm",	C_EBCDIC,	C_ASCII,	a2ibm_32V },
@


1.22
log
@Add an operand to /bin/dd that suppresses the status lines printed
to stderr after transfer.  Use the GNU syntax status=noxfer and
status=none to make dd quiet.  The output is annoying in some
situations, so people redirect stderr to /dev/null.  This approach
also suppresses the error messages and bugs in shell scripts remain
undetected.  The new feature status=none is the better alternative.
OK mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.21 2013/11/11 23:07:28 deraadt Exp $	*/
d315 6
a320 7
 * 	1) A positive decimal number.
 *	2) A positive decimal number followed by a b (mult by 512).
 *	3) A positive decimal number followed by a k (mult by 1024).
 *	4) A positive decimal number followed by a m (mult by 1048576).
 *	5) A positive decimal number followed by a w (mult by sizeof int)
 *	6) Two or more positive decimal numbers (with/without k,b or w).
 *	   separated by x (also * for backwards compatibility), specifying
d343 2
a344 2
	case 'k':
	case 'K':
d349 1
a349 2
		++expr;
		break;
d353 8
a360 1
		num *= 1048576;
d382 1
a382 1
erange:				errx(1, "%s: %s", oper, strerror(ERANGE));
d388 2
d394 6
a399 7
 * 	1) A positive decimal number.
 *	2) A positive decimal number followed by a b (mult by 512).
 *	3) A positive decimal number followed by a k (mult by 1024).
 *	4) A positive decimal number followed by a m (mult by 1048576).
 *	5) A positive decimal number followed by a w (mult by sizeof int)
 *	6) Two or more positive decimal numbers (with/without k,b or w).
 *	   separated by x (also * for backwards compatibility), specifying
d422 2
a423 2
	case 'k':
	case 'K':
d428 1
a428 2
		++expr;
		break;
d432 8
a439 1
		num *= 1048576;
d461 1
a461 1
erange:				errx(1, "%s: %s", oper, strerror(ERANGE));
d467 2
@


1.21
log
@unused prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.20 2013/06/01 18:57:59 tedu Exp $	*/
d62 1
d82 1
d252 12
@


1.20
log
@fiddle with the NO_CONV code to allow notrunc and noerror to still work.
ok halex
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.19 2011/10/18 09:37:35 nicm Exp $	*/
a50 1
static int	c_conv(const void *, const void *);
@


1.19
log
@Support K and M as well as k and m for sizes. From Thomas Pfaff.

ok millert jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.18 2009/10/27 23:59:21 deraadt Exp $	*/
a252 8
#ifdef	NO_CONV
/* Build a small version (i.e. for a ramdisk root) */
static void
f_conv(char *arg)
{
	errx(1, "conv option disabled");
}
#else	/* NO_CONV */
d259 1
a264 2
	{ "noerror",	C_NOERROR,	0,		NULL },
	{ "notrunc",	C_NOTRUNC,	0,		NULL },
d273 4
d282 2
a283 1
	struct conv *cp, tmp;
d286 6
a291 5
		tmp.name = strsep(&arg, ",");
		if (!(cp = (struct conv *)bsearch(&tmp, clist,
		    sizeof(clist)/sizeof(struct conv), sizeof(struct conv),
		    c_conv)))
			errx(1, "unknown conversion %s", tmp.name);
d293 1
a293 1
			errx(1, "%s: illegal conversion combination", tmp.name);
a298 9

static int
c_conv(const void *a, const void *b)
{

	return (strcmp(((struct conv *)a)->name, ((struct conv *)b)->name));
}

#endif	/* NO_CONV */
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.17 2006/11/01 05:46:20 ray Exp $	*/
d344 1
d352 1
d416 1
d424 1
@


1.17
log
@Fix range checking for in.dbsz and out.dbsz.
Add range checking for cbsz.
Change type in format string to %zd and cast SSIZE_MAX to ssize_t.

Fixes PR 5278 submitted by malaler at gmail dot com.

OK otto@@ and millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.16 2006/03/22 18:08:04 dhill Exp $	*/
a35 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)args.c	8.3 (Berkeley) 4/2/94";
#else
static char rcsid[] = "$OpenBSD: args.c,v 1.16 2006/03/22 18:08:04 dhill Exp $";
#endif
#endif /* not lint */
@


1.16
log
@change %u to %zu to correctly print size_t

ok ray@@ jaredy@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.15 2005/04/08 01:46:45 jsg Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: args.c,v 1.15 2005/04/08 01:46:45 jsg Exp $";
d174 3
a176 2
	if (in.dbsz > SIZE_T_MAX || out.dbsz > SIZE_T_MAX)
		errx(1, "buffer sizes cannot be greater than %u", SIZE_T_MAX);
@


1.15
log
@Correct comment about using m in blocksize (multiplies by 1048576 not 512).
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.14 2003/06/11 23:42:12 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: args.c,v 1.14 2003/06/11 23:42:12 deraadt Exp $";
d75 1
a75 1
	char *name;
d270 1
a270 1
	char *name;
@


1.14
log
@ansification, art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.13 2003/06/02 23:32:07 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: args.c,v 1.13 2003/06/02 23:32:07 millert Exp $";
d324 1
a324 1
 *	4) A positive decimal number followed by a m (mult by 512).
d394 1
a394 1
 *	4) A positive decimal number followed by a m (mult by 512).
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.12 2002/02/16 21:27:06 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: args.c,v 1.12 2002/02/16 21:27:06 millert Exp $";
d98 1
a98 2
jcl(argv)
	char **argv;
d181 1
a181 2
c_arg(a, b)
	const void *a, *b;
d188 1
a188 2
f_bs(arg)
	char *arg;
d195 1
a195 2
f_cbs(arg)
	char *arg;
d202 1
a202 2
f_count(arg)
	char *arg;
d210 1
a210 2
f_files(arg)
	char *arg;
d217 1
a217 2
f_ibs(arg)
	char *arg;
d225 1
a225 2
f_if(arg)
	char *arg;
d232 1
a232 2
f_obs(arg)
	char *arg;
d240 1
a240 2
f_of(arg)
	char *arg;
d247 1
a247 2
f_seek(arg)
	char *arg;
d254 1
a254 2
f_skip(arg)
	char *arg;
d263 1
a263 2
f_conv(arg)
	char *arg;
d292 1
a292 2
f_conv(arg)
	char *arg;
d311 1
a311 2
c_conv(a, b)
	const void *a, *b;
d331 1
a331 2
get_bsz(val)
	char *val;
d401 1
a401 2
get_off(val)
	char *val;
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.11 2001/10/06 22:31:54 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static char rcsid[] = "$OpenBSD: args.c,v 1.11 2001/10/06 22:31:54 millert Exp $";
@


1.11
log
@Fix ``echo foo |dd'' which was broken by the last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.10 2001/10/04 20:32:27 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: args.c,v 1.10 2001/10/04 20:32:27 millert Exp $";
d62 15
a76 15
static int	c_arg __P((const void *, const void *));
static int	c_conv __P((const void *, const void *));
static void	f_bs __P((char *));
static void	f_cbs __P((char *));
static void	f_conv __P((char *));
static void	f_count __P((char *));
static void	f_files __P((char *));
static void	f_ibs __P((char *));
static void	f_if __P((char *));
static void	f_obs __P((char *));
static void	f_of __P((char *));
static void	f_seek __P((char *));
static void	f_skip __P((char *));
static size_t	get_bsz __P((char *));
static off_t	get_off __P((char *));
d80 1
a80 1
	void (*f) __P((char *));
@


1.10
log
@Move check for count=0 into dd's main.  We want to do normal setup
in this case and just don't want to actually copy any data.
Fixes a problem noted by aaron@@ where the time portion of the summary
would be wrong and also gives us sane behavior when seek is non-zero
but count is 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.9 2001/08/07 14:39:27 hugh Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: args.c,v 1.9 2001/08/07 14:39:27 hugh Exp $";
d214 2
a215 1
	cpy_cnt = get_bsz(arg);
@


1.9
log
@Modify timekeeping in an effort to produce a sane bandwidth measure
for a short running dd process. Some floating point is used so that
microsecond precision can be kept without shortening the off_t
excessively. millert says ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.8 1998/07/09 18:39:23 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: args.c,v 1.8 1998/07/09 18:39:23 deraadt Exp $";
a214 2
	if (!cpy_cnt)
		terminate(0);
@


1.8
log
@why bother; msaitoh
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.7 1997/11/15 22:10:22 todd Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: args.c,v 1.7 1997/11/15 22:10:22 todd Exp $";
d50 1
@


1.7
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.6 1997/02/14 07:05:18 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: args.c,v 1.6 1997/02/14 07:05:18 millert Exp $";
d77 1
a77 1
const static struct arg {
d286 1
a286 1
const static struct conv {
@


1.6
log
@Deal with 64-bit offsets and report bytes copied as a 64-bit quantity.
Closes OpenBSD PR system/107.
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.5 1996/12/14 12:17:47 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: args.c,v 1.5 1996/12/14 12:17:47 mickey Exp $";
d346 1
a346 1
 *	   seperated by x (also * for backwards compatibility), specifying
d417 1
a417 1
 *	   seperated by x (also * for backwards compatibility), specifying
@


1.5
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.4 1996/06/23 14:19:45 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: args.c,v 1.4 1996/06/23 14:19:45 deraadt Exp $";
d74 2
a75 1
static u_long	get_bsz __P((char *));
d110 2
a111 1
		oper = strdup(oper);
d175 2
a176 3
	 * Read, write and seek calls take ints as arguments.  Seek sizes
	 * could be larger if we wanted to do it in stages or check only
	 * regular files, but it's probably not worth it.
d178 4
a181 4
	if (in.dbsz > INT_MAX || out.dbsz > INT_MAX)
		errx(1, "buffer sizes cannot be greater than %d", INT_MAX);
	if (in.offset > INT_MAX / in.dbsz || out.offset > INT_MAX / out.dbsz)
		errx(1, "seek offsets cannot be larger than %d", INT_MAX);
d197 1
a197 1
	in.dbsz = out.dbsz = (int)get_bsz(arg);
d205 1
a205 1
	cbsz = (int)get_bsz(arg);
d213 1
a213 1
	cpy_cnt = (u_int)get_bsz(arg);
d223 1
a223 1
	files_cnt = (int)get_bsz(arg);
d232 1
a232 1
		in.dbsz = (int)get_bsz(arg);
d249 1
a249 1
		out.dbsz = (int)get_bsz(arg);
d265 1
a265 1
	out.offset = (u_int)get_bsz(arg);
d273 1
a273 1
	in.offset = (u_int)get_bsz(arg);
d339 1
a339 1
 * Convert an expression of the following forms to an unsigned long.
d349 1
a349 1
static u_long
d353 1
a353 1
	u_long num, t;
d357 1
a357 1
	if (num == ULONG_MAX)			/* Overflow. */
d400 71
@


1.4
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: args.c,v 1.7 1996/03/01 01:18:58 jtc Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: args.c,v 1.7 1996/03/01 01:18:58 jtc Exp $";
d108 1
a108 1
	while (oper = *++argv) {
@


1.3
log
@don't munge argv strings -- copy them first. avoids 'w' showing:
    deraadt  p8 zeus.theos.com    8:26AM     3 dd if of bs
@
text
@d1 1
d45 1
a45 1
static char rcsid[] = "$NetBSD: args.c,v 1.7 1996/03/01 01:18:58 jtc Exp $";
@


1.2
log
@From NetBSD: Use const qualifier with conversion, args and clist tables
@
text
@d108 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: args.c,v 1.5 1995/10/08 23:01:22 gwr Exp $	*/
d44 1
a44 1
static char rcsid[] = "$NetBSD: args.c,v 1.5 1995/10/08 23:01:22 gwr Exp $";
d75 1
a75 1
static struct arg {
d283 1
a283 1
static struct conv {
d286 1
a286 1
	u_char *ctab;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
