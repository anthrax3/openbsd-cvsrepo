head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.2
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.19.0.10
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.28
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.26
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.24
	OPENBSD_5_0:1.17.0.22
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.20
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.18
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.14
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.16
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.12
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.10
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.10
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.16
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.14
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.12
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.10
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.8
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2016.10.19.18.20.25;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	0nfxWLL3tqkKYGhB;

1.25
date	2016.01.07.21.17.05;	author tedu;	state Exp;
branches;
next	1.24;
commitid	ya3mUCZqdQAqmu6l;

1.24
date	2016.01.06.17.53.14;	author tedu;	state Exp;
branches;
next	1.23;
commitid	u1ktNPg1TreSvG6x;

1.23
date	2015.12.29.19.06.16;	author gsoares;	state Exp;
branches;
next	1.22;
commitid	RoiLVgDfQM8nsHEN;

1.22
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	sbrB3Q5CNxcwZpfU;

1.21
date	2015.10.04.16.01.07;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	X84v2AMKdtJHywqp;

1.20
date	2015.08.11.17.15.46;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	JBCytQQeITQ0hWdp;

1.19
date	2013.11.21.15.54.45;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.28.08.40.31;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.21.18.28.24;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.12.00.49.55;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.11.23.42.12;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.14.01.15.01;	author jsyn;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.15.08.34.04;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.04.04.26.39;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.11.13.07.57.17;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.09.01.18.29.33;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.08.19.06.35.13;	author denny;	state Exp;
branches;
next	1.6;

1.6
date	97.07.23.14.44.21;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.12.17.59;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.09.15.22.27.38;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.20.10;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.04.34.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.13;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Delete useless setlocale(3) in src/bin/.
Minor cleanup while here: return from main, static void __dead usage, etc.
Based on a patch from Jan Stary <hans at stare dot cz>.
Feedback and OK tb@@, OK millert@@.
@
text
@/*	$OpenBSD: expr.c,v 1.25 2016/01/07 21:17:05 tedu Exp $	*/
/*	$NetBSD: expr.c,v 1.3.6.1 1996/06/04 20:41:47 cgd Exp $	*/

/*
 * Written by J.T. Conklin <jtc@@netbsd.org>.
 * Public domain.
 */

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <ctype.h>
#include <unistd.h>
#include <regex.h>
#include <err.h>

struct val	*make_int(int64_t);
struct val	*make_str(char *);
void		 free_value(struct val *);
int		 is_integer(struct val *, int64_t *);
int		 to_integer(struct val *);
void		 to_string(struct val *);
int		 is_zero_or_null(struct val *);
void		 nexttoken(int);
__dead void	 error(void);
struct val	*eval6(void);
struct val	*eval5(void);
struct val	*eval4(void);
struct val	*eval3(void);
struct val	*eval2(void);
struct val	*eval1(void);
struct val	*eval0(void);

enum token {
	OR, AND, EQ, LT, GT, ADD, SUB, MUL, DIV, MOD, MATCH, RP, LP,
	NE, LE, GE, OPERAND, EOI
};

struct val {
	enum {
		integer,
		string
	} type;

	union {
		char	       *s;
		int64_t		i;
	} u;
};

enum token	token;
struct val     *tokval;
char	      **av;

struct val *
make_int(int64_t i)
{
	struct val     *vp;

	vp = malloc(sizeof(*vp));
	if (vp == NULL) {
		err(3, NULL);
	}
	vp->type = integer;
	vp->u.i = i;
	return vp;
}


struct val *
make_str(char *s)
{
	struct val     *vp;

	vp = malloc(sizeof(*vp));
	if (vp == NULL || ((vp->u.s = strdup(s)) == NULL)) {
		err(3, NULL);
	}
	vp->type = string;
	return vp;
}


void
free_value(struct val *vp)
{
	if (vp->type == string)
		free(vp->u.s);
	free(vp);
}


/* determine if vp is an integer; if so, return it's value in *r */
int
is_integer(struct val *vp, int64_t *r)
{
	char	       *s;
	int		neg;
	int64_t		i;

	if (vp->type == integer) {
		*r = vp->u.i;
		return 1;
	}

	/*
	 * POSIX.2 defines an "integer" as an optional unary minus
	 * followed by digits.
	 */
	s = vp->u.s;
	i = 0;

	neg = (*s == '-');
	if (neg)
		s++;

	while (*s) {
		if (!isdigit((unsigned char)*s))
			return 0;

		i *= 10;
		i += *s - '0';

		s++;
	}

	if (neg)
		i *= -1;

	*r = i;
	return 1;
}


/* coerce to vp to an integer */
int
to_integer(struct val *vp)
{
	int64_t		r;

	if (vp->type == integer)
		return 1;

	if (is_integer(vp, &r)) {
		free(vp->u.s);
		vp->u.i = r;
		vp->type = integer;
		return 1;
	}

	return 0;
}


/* coerce to vp to an string */
void
to_string(struct val *vp)
{
	char	       *tmp;

	if (vp->type == string)
		return;

	if (asprintf(&tmp, "%lld", vp->u.i) == -1)
		err(3, NULL);

	vp->type = string;
	vp->u.s = tmp;
}

int
is_zero_or_null(struct val *vp)
{
	if (vp->type == integer)
		return vp->u.i == 0;
	else
		return *vp->u.s == 0 || (to_integer(vp) && vp->u.i == 0);
}

void
nexttoken(int pat)
{
	char	       *p;

	if ((p = *av) == NULL) {
		token = EOI;
		return;
	}
	av++;

	
	if (pat == 0 && p[0] != '\0') {
		if (p[1] == '\0') {
			const char     *x = "|&=<>+-*/%:()";
			char	       *i;	/* index */

			if ((i = strchr(x, *p)) != NULL) {
				token = i - x;
				return;
			}
		} else if (p[1] == '=' && p[2] == '\0') {
			switch (*p) {
			case '<':
				token = LE;
				return;
			case '>':
				token = GE;
				return;
			case '!':
				token = NE;
				return;
			}
		}
	}
	tokval = make_str(p);
	token = OPERAND;
	return;
}

__dead void
error(void)
{
	errx(2, "syntax error");
}

struct val *
eval6(void)
{
	struct val     *v;

	if (token == OPERAND) {
		nexttoken(0);
		return tokval;
	} else if (token == RP) {
		nexttoken(0);
		v = eval0();
		if (token != LP)
			error();
		nexttoken(0);
		return v;
	} else
		error();
}

/* Parse and evaluate match (regex) expressions */
struct val *
eval5(void)
{
	regex_t		rp;
	regmatch_t	rm[2];
	char		errbuf[256];
	int		eval;
	struct val     *l, *r;
	struct val     *v;

	l = eval6();
	while (token == MATCH) {
		nexttoken(1);
		r = eval6();

		/* coerce to both arguments to strings */
		to_string(l);
		to_string(r);

		/* compile regular expression */
		if ((eval = regcomp(&rp, r->u.s, 0)) != 0) {
			regerror(eval, &rp, errbuf, sizeof(errbuf));
			errx(2, "%s", errbuf);
		}

		/* compare string against pattern --  remember that patterns
		   are anchored to the beginning of the line */
		if (regexec(&rp, l->u.s, 2, rm, 0) == 0 && rm[0].rm_so == 0) {
			if (rm[1].rm_so >= 0) {
				*(l->u.s + rm[1].rm_eo) = '\0';
				v = make_str(l->u.s + rm[1].rm_so);

			} else {
				v = make_int(rm[0].rm_eo - rm[0].rm_so);
			}
		} else {
			if (rp.re_nsub == 0) {
				v = make_int(0);
			} else {
				v = make_str("");
			}
		}

		/* free arguments and pattern buffer */
		free_value(l);
		free_value(r);
		regfree(&rp);

		l = v;
	}

	return l;
}

/* Parse and evaluate multiplication and division expressions */
struct val *
eval4(void)
{
	struct val     *l, *r;
	enum token	op;

	l = eval5();
	while ((op = token) == MUL || op == DIV || op == MOD) {
		nexttoken(0);
		r = eval5();

		if (!to_integer(l) || !to_integer(r)) {
			errx(2, "non-numeric argument");
		}

		if (op == MUL) {
			l->u.i *= r->u.i;
		} else {
			if (r->u.i == 0) {
				errx(2, "division by zero");
			}
			if (op == DIV) {
				if (l->u.i != INT64_MIN || r->u.i != -1)
					l->u.i /= r->u.i;
			} else {
				if (l->u.i != INT64_MIN || r->u.i != -1)
					l->u.i %= r->u.i;
				else
					l->u.i = 0;
			}
		}

		free_value(r);
	}

	return l;
}

/* Parse and evaluate addition and subtraction expressions */
struct val *
eval3(void)
{
	struct val     *l, *r;
	enum token	op;

	l = eval4();
	while ((op = token) == ADD || op == SUB) {
		nexttoken(0);
		r = eval4();

		if (!to_integer(l) || !to_integer(r)) {
			errx(2, "non-numeric argument");
		}

		if (op == ADD) {
			l->u.i += r->u.i;
		} else {
			l->u.i -= r->u.i;
		}

		free_value(r);
	}

	return l;
}

/* Parse and evaluate comparison expressions */
struct val *
eval2(void)
{
	struct val     *l, *r;
	enum token	op;
	int64_t		v = 0, li, ri;

	l = eval3();
	while ((op = token) == EQ || op == NE || op == LT || op == GT ||
	    op == LE || op == GE) {
		nexttoken(0);
		r = eval3();

		if (is_integer(l, &li) && is_integer(r, &ri)) {
			switch (op) {
			case GT:
				v = (li >  ri);
				break;
			case GE:
				v = (li >= ri);
				break;
			case LT:
				v = (li <  ri);
				break;
			case LE:
				v = (li <= ri);
				break;
			case EQ:
				v = (li == ri);
				break;
			case NE:
				v = (li != ri);
				break;
			default:
				break;
			}
		} else {
			to_string(l);
			to_string(r);

			switch (op) {
			case GT:
				v = (strcoll(l->u.s, r->u.s) > 0);
				break;
			case GE:
				v = (strcoll(l->u.s, r->u.s) >= 0);
				break;
			case LT:
				v = (strcoll(l->u.s, r->u.s) < 0);
				break;
			case LE:
				v = (strcoll(l->u.s, r->u.s) <= 0);
				break;
			case EQ:
				v = (strcoll(l->u.s, r->u.s) == 0);
				break;
			case NE:
				v = (strcoll(l->u.s, r->u.s) != 0);
				break;
			default:
				break;
			}
		}

		free_value(l);
		free_value(r);
		l = make_int(v);
	}

	return l;
}

/* Parse and evaluate & expressions */
struct val *
eval1(void)
{
	struct val     *l, *r;

	l = eval2();
	while (token == AND) {
		nexttoken(0);
		r = eval2();

		if (is_zero_or_null(l) || is_zero_or_null(r)) {
			free_value(l);
			free_value(r);
			l = make_int(0);
		} else {
			free_value(r);
		}
	}

	return l;
}

/* Parse and evaluate | expressions */
struct val *
eval0(void)
{
	struct val     *l, *r;

	l = eval1();
	while (token == OR) {
		nexttoken(0);
		r = eval1();

		if (is_zero_or_null(l)) {
			free_value(l);
			l = r;
		} else {
			free_value(r);
		}
	}

	return l;
}


int
main(int argc, char *argv[])
{
	struct val     *vp;

	if (pledge("stdio", NULL) == -1)
		err(2, "pledge");

	if (argc > 1 && !strcmp(argv[1], "--"))
		argv++;

	av = argv + 1;

	nexttoken(0);
	vp = eval0();

	if (token != EOI)
		error();

	if (vp->type == integer)
		printf("%lld\n", vp->u.i);
	else
		printf("%s\n", vp->u.s);

	return is_zero_or_null(vp);
}
@


1.25
log
@need to increase INT_MAX to 64 bits too. from Nathan Holstein
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.24 2016/01/06 17:53:14 tedu Exp $	*/
a13 1
#include <locale.h>
d176 4
a179 6
	if (vp->type == integer) {
		return (vp->u.i == 0);
	} else {
		return (*vp->u.s == 0 || (to_integer(vp) && vp->u.i == 0));
	}
	/* NOTREACHED */
a225 1
	/* NOTREACHED */
a235 1

d239 1
a239 2

		if (token != LP) {
a240 2
			/* NOTREACHED */
		}
d243 1
a243 1
	} else {
a244 2
	}
	/* NOTREACHED */
a492 2
	(void) setlocale(LC_ALL, "");

d504 1
a504 1
	if (token != EOI) {
a505 2
		/* NOTREACHED */
	}
d512 1
a512 1
	exit(is_zero_or_null(vp));
@


1.24
log
@use int64_t for arithmetic. 64 bits ought to be enough for anyone.
ok deraadt millert schwarze
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.23 2015/12/29 19:06:16 gsoares Exp $	*/
d10 1
d335 1
a335 1
				if (l->u.i != INT_MIN || r->u.i != -1)
d338 1
a338 1
				if (l->u.i != INT_MIN || r->u.i != -1)
@


1.23
log
@fix exit status on pledge(2) failure.

OK tb@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.22 2015/10/09 01:37:06 deraadt Exp $	*/
d19 1
a19 1
struct val	*make_int(int);
d22 1
a22 1
int		 is_integer(struct val *, int *);
d49 1
a49 1
		int		i;
d58 1
a58 1
make_int(int i)
d97 1
a97 1
is_integer(struct val *vp, int *r)
d101 1
a101 1
	int		i;
d141 1
a141 1
	int		r;
d166 1
a166 1
	if (asprintf(&tmp, "%d", vp->u.i) == -1)
d290 1
a290 1
				v = make_int((int)(rm[0].rm_eo - rm[0].rm_so));
d384 1
a384 1
	int		v = 0, li, ri;
d521 1
a521 1
		printf("%d\n", vp->u.i);
@


1.22
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.21 2015/10/04 16:01:07 deraadt Exp $	*/
d505 1
a505 1
		err(1, "pledge");
@


1.21
log
@expr can use tame "stdio"
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.20 2015/08/11 17:15:46 deraadt Exp $	*/
d504 2
a505 2
	if (tame("stdio", NULL) == -1)
		err(1, "tame");
@


1.20
log
@avoid casts of malloc() if stdlib.h is present
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.19 2013/11/21 15:54:45 deraadt Exp $	*/
d15 1
d503 3
@


1.19
log
@add unsigned char casts for specific calls to ctype.h macros.
ok guenther step
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.18 2013/03/28 08:40:31 nicm Exp $	*/
d61 1
a61 1
	vp = (struct val *) malloc(sizeof(*vp));
d76 1
a76 1
	vp = (struct val *) malloc(sizeof(*vp));
@


1.18
log
@Don't die with SIGFPE on INT_MIN / -1 or % -1. Instead make INT_MIN /
-1 == INT_MIN and % -1 == 0.

ok matthew deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.17 2006/06/21 18:28:24 deraadt Exp $	*/
d119 1
a119 1
		if (!isdigit(*s))
@


1.17
log
@handle -- as POSIX requires; from kili@@outback.escape.de; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.16 2005/11/12 00:49:55 deraadt Exp $	*/
d12 1
d333 2
a334 1
				l->u.i /= r->u.i;
d336 4
a339 1
				l->u.i %= r->u.i;
@


1.16
log
@use asprintf instead; dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.15 2003/06/11 23:42:12 deraadt Exp $	*/
d497 4
@


1.15
log
@ansification, art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.14 2003/05/14 01:15:01 jsyn Exp $	*/
a159 1
	size_t		len;
d164 1
a164 3
	len = 25;
	tmp = malloc(len);
	if (tmp == NULL) {
d166 1
a166 2
	}
	snprintf(tmp, len, "%d", vp->u.i);
@


1.14
log
@add prototypes; ok millert@@ w/ 'static', 'no static', deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.13 2003/04/15 08:34:04 deraadt Exp $	*/
d227 1
a227 1
error()
@


1.13
log
@use a variable
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.12 2002/07/04 04:26:39 deraadt Exp $	*/
d17 16
a235 1
	struct val     *eval0(void);
@


1.12
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.11 2002/06/09 05:47:27 todd Exp $	*/
d144 1
d149 2
a150 1
	tmp = malloc(25);
d154 1
a154 1
	snprintf(tmp, 25, "%d", vp->u.i);
@


1.11
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.10 2002/02/16 21:27:07 millert Exp $	*/
a38 1

d40 1
a40 2
make_int(i)
	int		i;
d55 1
a55 2
make_str(s)
	char	       *s;
d69 1
a69 2
free_value(vp)
	struct val     *vp;
d79 1
a79 3
is_integer(vp, r)
	struct val     *vp;
	int	       *r;
d121 1
a121 2
to_integer(vp)
	struct val     *vp;
d141 1
a141 2
to_string(vp)
	struct val     *vp;
d158 1
a158 2
is_zero_or_null(vp)
	struct val     *vp;
d169 1
a169 2
nexttoken(pat)
	int pat;
d216 1
a216 1
eval6()
d243 1
a243 1
eval5()
d298 1
a298 1
eval4()
d333 1
a333 1
eval3()
d361 1
a361 1
eval2()
d434 1
a434 1
eval1()
d457 1
a457 1
eval0()
d479 1
a479 3
main(argc, argv)
	int		argc;
	char	      **argv;
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.9 1997/11/13 07:57:17 deraadt Exp $	*/
d97 1
a97 1
	 * POSIX.2 defines an "integer" as an optional unary minus 
d277 1
a277 1
		/* compare string against pattern --  remember that patterns 
@


1.9
log
@let "expr a : /" work. Mark the next token after the match operator as a
pattern, causing the lexical analyzer to short-circuit around operator
parsing.  my fix to netbsd pr#4187, augustss@@cs.chalmers.se
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.8 1997/09/01 18:29:33 deraadt Exp $	*/
d228 1
a228 1
	struct val     *eval0 __P((void));
@


1.8
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.7 1997/08/19 06:35:13 denny Exp $	*/
d178 2
a179 1
nexttoken()
d189 2
a190 1
	if (p[0] != '\0') {
d232 1
a232 1
		nexttoken();
d236 1
a236 1
		nexttoken();
d243 1
a243 1
		nexttoken();
d264 1
a264 1
		nexttoken();
d315 1
a315 1
		nexttoken();
d350 1
a350 1
		nexttoken();
d378 3
a380 2
	while ((op = token) == EQ || op == NE || op == LT || op == GT || op == LE || op == GE) {
		nexttoken();
d450 1
a450 1
		nexttoken();
d473 1
a473 1
		nexttoken();
d498 1
a498 1
	nexttoken();
@


1.7
log
@POSIX 1003.2: exit code is 3 if memory allocation fails, 2 if expr invalid.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.6 1997/07/23 14:44:21 kstailey Exp $	*/
d429 1
a429 1
		} 
@


1.6
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.5 1996/12/14 12:17:59 mickey Exp $	*/
d48 1
a48 1
		err(2, NULL);
d64 1
a64 1
		err(2, NULL);
d158 1
a158 1
		err(2, NULL);
@


1.5
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.4 1996/09/15 22:27:38 millert Exp $	*/
d30 2
a31 2
		char           *s;
		int             i;
d37 1
a37 1
char          **av;
d42 1
a42 1
	int             i;
d58 1
a58 1
	char           *s;
d87 3
a89 3
	char           *s;
	int             neg;
	int             i;
d130 1
a130 1
	int             r;
d151 1
a151 1
	char           *tmp;
d180 1
a180 1
	char           *p;
d191 1
a191 1
			char           *i;	/* index */
d253 4
a256 4
	regex_t         rp;
	regmatch_t      rm[2];
	char            errbuf[256];
	int             eval;
d373 1
a373 1
	int             v = 0, li, ri;
d487 2
a488 2
	int             argc;
	char          **argv;
@


1.4
log
@sprintf -> snprintf paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.3 1996/06/23 14:20:10 deraadt Exp $	*/
d216 1
a216 1
void
d373 1
a373 1
	int             v, li, ri;
d400 2
d425 2
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.3.6.1 1996/06/04 20:41:47 cgd Exp $	*/
d160 1
a160 1
	sprintf(tmp, "%d", vp->u.i);
@


1.2
log
@handle locale being incorrect
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: expr.c,v 1.3 1995/04/28 23:27:15 jtc Exp $	*/
d487 1
a487 4
	if (!setlocale(LC_ALL, "")) {
		fprintf(stderr,
			"setlocale failed, continuing with \"C\" locale.");
	}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
