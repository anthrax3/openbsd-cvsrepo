head	1.56;
access;
symbols
	OPENBSD_5_5:1.54.0.4
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.52.0.2
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.50.0.2
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.49.0.12
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.10
	OPENBSD_5_0:1.49.0.8
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.49.0.6
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.4
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.48.0.4
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.47.0.6
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.47.0.4
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.46.0.2
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.45.0.4
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.45.0.2
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.40.0.4
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.40.0.2
	OPENBSD_3_6_BASE:1.40
	OPENBSD_3_5:1.38.0.4
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.38.0.2
	OPENBSD_3_4_BASE:1.38
	OPENBSD_3_3:1.33.0.2
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.31.0.2
	OPENBSD_3_2_BASE:1.31
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_8:1.18.0.12
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.18.0.10
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.18.0.8
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.18.0.6
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.18.0.4
	OPENBSD_2_4_BASE:1.18
	OPENBSD_2_3:1.18.0.2
	OPENBSD_2_3_BASE:1.18
	OPENBSD_2_2:1.16.0.2
	OPENBSD_2_2_BASE:1.16
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.56
date	2014.03.19.14.44.17;	author tedu;	state dead;
branches;
next	1.55;

1.55
date	2014.03.16.05.30.13;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2013.11.20.20.53.55;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2013.11.12.04.36.02;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2013.06.17.04.48.42;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2013.06.01.20.59.25;	author dtucker;	state Exp;
branches;
next	1.50;

1.50
date	2012.12.04.02.24.46;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2009.10.27.23.59.22;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2009.03.01.13.47.02;	author sobrado;	state Exp;
branches;
next	1.47;

1.47
date	2008.01.01.09.10.25;	author dtucker;	state Exp;
branches;
next	1.46;

1.46
date	2007.03.20.18.50.11;	author jmc;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.17.12.44.16;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.23.02.48.57;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.12.01.51.15;	author djm;	state Exp;
branches;
next	1.42;

1.42
date	2005.11.12.18.34.25;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.31.18.39.21;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2004.07.08.12.53.42;	author dtucker;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.01.12.19.57;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2003.07.29.00.24.16;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2003.07.28.06.05.35;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.18.00.44.50;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.02.23.32.09;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.04.13.18.04.41;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.03.08.17.18.25;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2003.01.10.10.29.35;	author djm;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.04.04.26.40;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.09.05.30.08;	author todd;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.09.18.44.46;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.19.19.39.35;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.17.19.42.19;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.21.15.35.28;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.01.08.06.28;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.06.13.29.08;	author mpech;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.13.09.03.18;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.13.08.52.42;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.11.18.43.40;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.06.16.46.59;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.12.08.05.15.29;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.11.05.00.09.36;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.09.12.04.43.18;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.09.01.18.30.22;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.07.25.18.58.41;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	97.07.23.19.19.33;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	97.06.29.11.10.28;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	97.06.06.11.02.21;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.03.26.01.19.49;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.01.15.23.40.25;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.12.22.02.57.51;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.12.14.12.18.13;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.08.02.12.41.04;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.02.12.17.04;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.03.02.00.35.17;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.02.16.47;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.16.22.20.17;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.19;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.19;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Thulsa Doom says "Infidel Defilers. They shall all drown in lakes of blood."
@
text
@/*	$OpenBSD: rcp.c,v 1.55 2014/03/16 05:30:13 deraadt Exp $	*/
/*	$NetBSD: rcp.c,v 1.9 1995/03/21 08:19:06 cgd Exp $	*/

/*
 * Copyright (c) 1983, 1990, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>

#include <ctype.h>
#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "pathnames.h"
#include "extern.h"

#ifdef KERBEROS
#include <des.h>
#include <kerberosIV/krb.h>

char	dst_realm_buf[REALM_SZ];
char	*dest_realm = NULL;
int	use_kerberos = 1;
CREDENTIALS	cred;
Key_schedule	schedule;
extern	char	*krb_realmofhost();
int	doencrypt = 0;
#define	OPTIONS	"dfKk:prtx"
#else
#define	OPTIONS "dfprt"
#endif

struct passwd *pwd;
u_short	port;
uid_t	userid;
gid_t	groupid;
int errs, rem;
int pflag, iamremote, iamrecursive, targetshouldbedirectory;

#define	CMDNEEDS	64
char cmd[CMDNEEDS];		/* must hold "rcp -r -p -d\0" */

#ifdef KERBEROS
int	 kerberos(char **, char *, char *, char *);
void	 oldw(const char *, ...);
/* XXX from ../../usr.bin/rlogin/krcmd.c */
int krcmd(char **, u_short, char *, char *, int *, char *);
int krcmd_mutual(char **, u_short, char *, char *, int *,
		 char *, CREDENTIALS *, Key_schedule);
#endif
int	 response(void);
void	 rsource(char *, struct stat *);
void	 sink(int, char *[]);
void	 source(int, char *[]);
void	 tolocal(int, char *[]);
void	 toremote(char *, int, char *[]);
int	 do_times(int fd, const struct stat *sb);
void	 usage(void);

int
main(int argc, char *argv[])
{
	struct servent *sp;
	int ch, fflag, tflag;
	char *targ, *shell;

	fflag = tflag = 0;
	while ((ch = getopt(argc, argv, OPTIONS)) != -1)
		switch(ch) {			/* User-visible flags. */
		case 'K':
#ifdef KERBEROS
			use_kerberos = 0;
#endif
			break;
#ifdef	KERBEROS
		case 'k':
			dest_realm = dst_realm_buf;
			strlcpy(dst_realm_buf, optarg, sizeof(dst_realm_buf));
			break;
		case 'x':
			doencrypt = 1;
			/* des_set_key(cred.session, schedule); */
			break;
#endif
		case 'p':
			pflag = 1;
			break;
		case 'r':
			iamrecursive = 1;
			break;
						/* Server options. */
		case 'd':
			targetshouldbedirectory = 1;
			break;
		case 'f':			/* "from" */
			iamremote = 1;
			fflag = 1;
			break;
		case 't':			/* "to" */
			iamremote = 1;
			tflag = 1;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

#ifdef KERBEROS
	if (use_kerberos) {
		shell = doencrypt ? "ekshell" : "kshell";
		if ((sp = getservbyname(shell, "tcp")) == NULL) {
			use_kerberos = 0;
			oldw("can't get entry for %s/tcp service", shell);
			sp = getservbyname(shell = "shell", "tcp");
		}
	} else
		sp = getservbyname(shell = "shell", "tcp");
#else
	sp = getservbyname(shell = "shell", "tcp");
#endif
	if (sp == NULL)
		errx(1, "%s/tcp: unknown service", shell);
	port = sp->s_port;

	if ((pwd = getpwuid(userid = getuid())) == NULL)
		errx(1, "unknown user %u", userid);
	groupid = pwd->pw_gid;

	unsetenv("RSH");		/* Force the use of /usr/bin/rsh */

	rem = STDIN_FILENO;		/* XXX */

	if (fflag) {			/* Follow "protocol", send data. */
		(void)response();
		(void)setresgid(groupid, groupid, groupid);
		(void)setgroups(1, &groupid);
		(void)setresuid(userid, userid, userid);
		source(argc, argv);
		exit(errs != 0);
	}

	if (tflag) {			/* Receive data. */
		(void)setresgid(groupid, groupid, groupid);
		(void)setgroups(1, &groupid);
		(void)setresuid(userid, userid, userid);
		sink(argc, argv);
		exit(errs != 0);
	}

	if (argc < 2)
		usage();
	if (argc > 2)
		targetshouldbedirectory = 1;

	rem = -1;
	/* Command to be executed on remote system using "rsh". */
#ifdef	KERBEROS
	(void)snprintf(cmd, sizeof(cmd),
	    "rcp%s%s%s%s", iamrecursive ? " -r" : "",
	    (doencrypt && use_kerberos ? " -x" : ""),
	    pflag ? " -p" : "", targetshouldbedirectory ? " -d" : "");
#else
	(void)snprintf(cmd, sizeof(cmd), "rcp%s%s%s",
	    iamrecursive ? " -r" : "", pflag ? " -p" : "",
	    targetshouldbedirectory ? " -d" : "");
#endif

	(void)signal(SIGPIPE, lostconn);

	if ((targ = colon(argv[argc - 1])))	/* Dest is remote host. */
		toremote(targ, argc, argv);
	else {
		tolocal(argc, argv);		/* Dest is local host. */
		if (targetshouldbedirectory)
			verifydir(argv[argc - 1]);
	}
	exit(errs != 0);
}

void
toremote(char *targ, int argc, char *argv[])
{
	int i, tos;
	char *bp, *host, *src, *suser, *thost, *tuser, *user, *arg;
	arglist alist;

	memset(&alist, '\0', sizeof(alist));
	alist.list = NULL;

	if ((user = strdup(pwd->pw_name)) == NULL)
		err(1, "strdup");

	*targ++ = 0;
	if (*targ == 0)
		targ = ".";

	arg = strdup(argv[argc - 1]);
	if (!arg)
		err(1, "strdup");
	if ((thost = strchr(arg, '@@'))) {
		/* user@@host */
		*thost++ = 0;
		tuser = arg;
		if (*tuser == '\0')
			tuser = NULL;
		else if (!okname(tuser))
			exit(1);
	} else {
		thost = arg;
		tuser = NULL;
	}

	for (i = 0; i < argc - 1; i++) {
		src = colon(argv[i]);
		if (src) {			/* remote to remote */
			freeargs(&alist);
			addargs(&alist, "%s", _PATH_OLD_RSH);
			addargs(&alist, "%s", "-n");

			*src++ = 0;
			if (*src == 0)
				src = ".";

			host = strchr(argv[i], '@@');
			if (host) {
				*host++ = 0;
				suser = argv[i];
				if (*suser == '\0')
					suser = user;
				else if (!okname(suser))
					continue;

				addargs(&alist, "-l");
				addargs(&alist, "%s", suser);
			} else
				host = argv[1];
			addargs(&alist, "%s", host);
			addargs(&alist, "%s", cmd);
			addargs(&alist, "%s", src);
			addargs(&alist, "%s%s%s:%s",
			    tuser ? tuser : "", tuser ? "@@" : "",
			    thost, targ);
			do_local_cmd(&alist, userid, groupid);
		} else {			/* local to remote */
			if (rem == -1) {
				if (asprintf(&bp, "%s -t %s", cmd, targ) == -1)
					err(1, NULL);
				host = thost;
#ifdef KERBEROS
				if (use_kerberos)
					rem = kerberos(&host, bp, user,
					    tuser ? tuser : pwd->pw_name);
				else
#endif
					rem = rcmd(&host, port, user,
					    tuser ? tuser : user, bp, 0);
				if (rem < 0)
					exit(1);
				tos = IPTOS_THROUGHPUT;
				if (setsockopt(rem, IPPROTO_IP, IP_TOS,
				    &tos, sizeof(int)) < 0 &&
				    errno != ENOPROTOOPT)
					warn("TOS (ignored)");
				if (response() < 0)
					exit(1);
				(void)free(bp);
				(void)setresgid(groupid, groupid, groupid);
				(void)setgroups(1, &groupid);
				(void)setresuid(userid, userid, userid);
			}
			source(1, argv+i);
		}
	}
	free(user);
	free(arg);
}

void
tolocal(int argc, char *argv[])
{
	int i, tos;
	char *bp, *host, *src, *suser, *user;
	arglist alist;

	memset(&alist, '\0', sizeof(alist));
	alist.list = NULL;

	if ((user = strdup(pwd->pw_name)) == NULL)
		err(1, "strdup");

	for (i = 0; i < argc - 1; i++) {
		if (!(src = colon(argv[i]))) {		/* Local to local. */
			freeargs(&alist);
			addargs(&alist, "%s", _PATH_CP);
			if (iamrecursive)
				addargs(&alist, "-R");
			if (pflag)
				addargs(&alist, "-p");
			addargs(&alist, "%s", argv[i]);
			addargs(&alist, "%s", argv[argc-1]);
			if (do_local_cmd(&alist, userid, groupid))
				++errs;
			continue;
		}
		*src++ = 0;
		if (*src == 0)
			src = ".";
		if ((host = strchr(argv[i], '@@')) == NULL) {
			host = argv[i];
			suser = user;
		} else {
			*host++ = 0;
			suser = argv[i];
			if (*suser == '\0')
				suser = user;
			else if (!okname(suser))
				continue;
		}
		if (asprintf(&bp, "%s -f %s", cmd, src) == -1)
			err(1, NULL);
		rem =
#ifdef KERBEROS
		    use_kerberos ?
			kerberos(&host, bp, user, suser) :
#endif
			rcmd(&host, port, user, suser, bp, 0);
		(void)free(bp);
		if (rem < 0) {
			++errs;
			continue;
		}
		(void)seteuid(userid);
		tos = IPTOS_THROUGHPUT;
		if (setsockopt(rem, IPPROTO_IP, IP_TOS, &tos, sizeof(int)) < 0
		    && errno != ENOPROTOOPT)
			warn("TOS (ignored)");
		sink(1, argv + argc - 1);
		(void)seteuid(0);
		(void)close(rem);
		rem = -1;
	}
	free(user);
}

int
do_times(int fd, const struct stat *sb)
{
	/* strlen(2^64) == 20; strlen(10^6) == 7 */
	char buf[(20 + 7 + 2) * 2 + 2];

	(void)snprintf(buf, sizeof(buf), "T%llu 0 %llu 0\n",
	    (unsigned long long) (sb->st_mtime < 0 ? 0 : sb->st_mtime),
	    (unsigned long long) (sb->st_atime < 0 ? 0 : sb->st_atime));
	(void)write(fd, buf, strlen(buf));
	return (response());
}

void
source(int argc, char *argv[])
{
	struct stat stb;
	static BUF buffer;
	BUF *bp;
	off_t i;
	int amt, fd = -1, haderr, indx, result;
	char *last, *name, buf[BUFSIZ];
	int len;

	for (indx = 0; indx < argc; ++indx) {
		name = argv[indx];
		len = strlen(name);
		while (len > 1 && name[len-1] == '/')
			name[--len] = '\0';
		if (strchr(name, '\n') != NULL) {
			run_err("%s: skipping, filename contains a newline",
			    name);
			goto next;
		}
		if ((fd = open(name, O_RDONLY, 0)) < 0)
			goto syserr;
		if (fstat(fd, &stb)) {
syserr:
			run_err("%s: %s", name, strerror(errno));
			goto next;
		}
		switch (stb.st_mode & S_IFMT) {
		case S_IFREG:
			break;
		case S_IFDIR:
			if (iamrecursive) {
				rsource(name, &stb);
				goto next;
			}
			/* FALLTHROUGH */
		default:
			run_err("%s: not a regular file", name);
			goto next;
		}
		if ((last = strrchr(name, '/')) == NULL)
			last = name;
		else
			++last;
		if (pflag) {
			if (do_times(rem, &stb) < 0)
				goto next;
		}
#define	MODEMASK	(S_ISUID|S_ISGID|S_ISTXT|S_IRWXU|S_IRWXG|S_IRWXO)
		(void)snprintf(buf, sizeof(buf), "C%04o %qd %s\n",
		    stb.st_mode & MODEMASK, stb.st_size, last);
		(void)write(rem, buf, strlen(buf));
		if (response() < 0)
			goto next;
		if ((bp = allocbuf(&buffer, fd, BUFSIZ)) == NULL) {
next:			if (fd != -1) {
				(void)close(fd);
				fd = -1;
			}
			continue;
		}

		/* Keep writing after an error so that we stay sync'd up. */
		for (haderr = i = 0; i < stb.st_size; i += bp->cnt) {
			amt = bp->cnt;
			if (i + amt > stb.st_size)
				amt = stb.st_size - i;
			if (!haderr) {
				result = read(fd, bp->buf, amt);
				if (result != amt)
					haderr = result >= 0 ? EIO : errno;
			}
			if (haderr)
				(void)write(rem, bp->buf, amt);
			else {
				result = write(rem, bp->buf, amt);
				if (result != amt)
					haderr = result >= 0 ? EIO : errno;
			}
		}
		if (fd != -1) {
			if (close(fd) && !haderr)
				haderr = errno;
			fd = -1;
		}
		if (!haderr)
			(void)write(rem, "", 1);
		else
			run_err("%s: %s", name, strerror(haderr));
		(void)response();
	}
}

void
rsource(char *name, struct stat *statp)
{
	DIR *dirp;
	struct dirent *dp;
	char *last, *vect[1], path[MAXPATHLEN];

	if (!(dirp = opendir(name))) {
		run_err("%s: %s", name, strerror(errno));
		return;
	}
	last = strrchr(name, '/');
	if (last == NULL)
		last = name;
	else
		last++;
	if (pflag) {
		if (do_times(rem, statp) < 0) {
			closedir(dirp);
			return;
		}
	}
	(void)snprintf(path, sizeof(path),
	    "D%04o %d %s\n", statp->st_mode & MODEMASK, 0, last);
	(void)write(rem, path, strlen(path));
	if (response() < 0) {
		closedir(dirp);
		return;
	}
	while ((dp = readdir(dirp)) != NULL) {
		if (dp->d_ino == 0)
			continue;
		if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, ".."))
			continue;
		if (strlen(name) + 1 + strlen(dp->d_name) >= MAXPATHLEN - 1) {
			run_err("%s/%s: name too long", name, dp->d_name);
			continue;
		}
		(void)snprintf(path, sizeof(path), "%s/%s", name, dp->d_name);
		vect[0] = path;
		source(1, vect);
	}
	(void)closedir(dirp);
	(void)write(rem, "E\n", 2);
	(void)response();
}

void
sink(int argc, char *argv[])
{
	static BUF buffer;
	struct stat stb;
	struct timeval tv[2];
	enum { YES, NO, DISPLAYED } wrerr;
	BUF *bp;
	off_t i, j, size;
	unsigned long long ull;
	int amt, count, exists, first, mask, mode, ofd, omode;
	int setimes, targisdir, wrerrno = 0;
	char ch, *cp, *np, *targ, *why, *vect[1], buf[BUFSIZ];

#define	atime	tv[0]
#define	mtime	tv[1]
#define	SCREWUP(str)	{ why = str; goto screwup; }

	setimes = targisdir = 0;
	mask = umask(0);
	if (!pflag)
		(void)umask(mask);
	if (argc != 1) {
		run_err("ambiguous target");
		exit(1);
	}
	targ = *argv;
	if (targetshouldbedirectory)
		verifydir(targ);
	(void)write(rem, "", 1);
	if (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))
		targisdir = 1;
	for (first = 1;; first = 0) {
		cp = buf;
		if (read(rem, cp, 1) <= 0)
			return;
		if (*cp++ == '\n')
			SCREWUP("unexpected <newline>");
		do {
			if (read(rem, &ch, sizeof(ch)) != sizeof(ch))
				SCREWUP("lost connection");
			*cp++ = ch;
		} while (cp < &buf[BUFSIZ - 1] && ch != '\n');
		*cp = 0;

		if (buf[0] == '\01' || buf[0] == '\02') {
			if (iamremote == 0)
				(void)write(STDERR_FILENO,
				    buf + 1, strlen(buf + 1));
			if (buf[0] == '\02')
				exit(1);
			++errs;
			continue;
		}
		if (buf[0] == 'E') {
			(void)write(rem, "", 1);
			return;
		}

		if (ch == '\n')
			*--cp = 0;

		cp = buf;
		if (*cp == 'T') {
			setimes++;
			cp++;
			if (!isdigit((unsigned char)*cp))
				SCREWUP("mtime.sec not present");
			ull = strtoull(cp, &cp, 10);
			if (!cp || *cp++ != ' ')
				SCREWUP("mtime.sec not delimited");
			if ((time_t)ull < 0 || (time_t)ull != ull)
				setimes = 0;	/* out of range */
			mtime.tv_sec = ull;
			mtime.tv_usec = strtol(cp, &cp, 10);
			if (!cp || *cp++ != ' ' || mtime.tv_usec < 0 ||
			    mtime.tv_usec > 999999)
				SCREWUP("mtime.usec not delimited");
			if (!isdigit((unsigned char)*cp))
				SCREWUP("atime.sec not present");
			ull = strtoull(cp, &cp, 10);
			if (!cp || *cp++ != ' ')
				SCREWUP("atime.sec not delimited");
			if ((time_t)ull < 0 || (time_t)ull != ull)
				setimes = 0;	/* out of range */
			atime.tv_sec = ull;
			atime.tv_usec = strtol(cp, &cp, 10);
			if (!cp || *cp++ != '\0' || atime.tv_usec < 0 ||
			    atime.tv_usec > 999999)
				SCREWUP("atime.usec not delimited");
			(void)write(rem, "", 1);
			continue;
		}
		if (*cp != 'C' && *cp != 'D') {
			/*
			 * Check for the case "rcp remote:foo\* local:bar".
			 * In this case, the line "No match." can be returned
			 * by the shell before the rcp command on the remote is
			 * executed so the ^Aerror_message convention isn't
			 * followed.
			 */
			if (first) {
				run_err("%s", cp);
				exit(1);
			}
			SCREWUP("expected control record");
		}
		mode = 0;
		for (++cp; cp < buf + 5; cp++) {
			if (*cp < '0' || *cp > '7')
				SCREWUP("bad mode");
			mode = (mode << 3) | (*cp - '0');
		}
		if (*cp++ != ' ')
			SCREWUP("mode not delimited");

		for (size = 0; isdigit((unsigned char)*cp);)
			size = size * 10 + (*cp++ - '0');
		if (*cp++ != ' ')
			SCREWUP("size not delimited");
		if ((strchr(cp, '/') != NULL) || (strcmp(cp, "..") == 0)) {
			run_err("error: unexpected filename: %s", cp);
			exit(1);
		}
		if (targisdir) {
			static char *namebuf;
			static int cursize;
			size_t need;

			need = strlen(targ) + strlen(cp) + 250;
			if (need > cursize) {
				if (!(namebuf = malloc(need)))
					run_err("%s", strerror(errno));
			}
			(void)snprintf(namebuf, need, "%s%s%s", targ,
			    *targ ? "/" : "", cp);
			np = namebuf;
		} else
			np = targ;
		exists = stat(np, &stb) == 0;
		if (buf[0] == 'D') {
			int mod_flag = pflag;
			if (!iamrecursive)
				SCREWUP("received directory without -r");
			if (exists) {
				if (!S_ISDIR(stb.st_mode)) {
					errno = ENOTDIR;
					goto bad;
				}
				if (pflag)
					(void)chmod(np, mode);
			} else {
				/* Handle copying from a read-only directory */
				mod_flag = 1;
				if (mkdir(np, mode | S_IRWXU) < 0)
					goto bad;
			}
			vect[0] = np;
			sink(1, vect);
			if (setimes) {
				setimes = 0;
				if (utimes(np, tv) < 0)
				    run_err("%s: set times: %s",
					np, strerror(errno));
			}
			if (mod_flag)
				(void)chmod(np, mode);
			continue;
		}
		omode = mode;
		mode |= S_IWUSR;
		if ((ofd = open(np, O_WRONLY|O_CREAT, mode)) < 0) {
bad:			run_err("%s: %s", np, strerror(errno));
			continue;
		}
		(void)write(rem, "", 1);
		if ((bp = allocbuf(&buffer, ofd, BUFSIZ)) == NULL) {
			(void)close(ofd);
			continue;
		}
		cp = bp->buf;
		wrerr = NO;
		for (count = i = 0; i < size; i += BUFSIZ) {
			amt = BUFSIZ;
			if (i + amt > size)
				amt = size - i;
			count += amt;
			do {
				j = read(rem, cp, amt);
				if (j <= 0) {
					run_err("%s", j ? strerror(errno) :
					    "dropped connection");
					exit(1);
				}
				amt -= j;
				cp += j;
			} while (amt > 0);
			if (count == bp->cnt) {
				/* Keep reading so we stay sync'd up. */
				if (wrerr == NO) {
					j = write(ofd, bp->buf, count);
					if (j != count) {
						wrerr = YES;
						wrerrno = j >= 0 ? EIO : errno;
					}
				}
				count = 0;
				cp = bp->buf;
			}
		}
		if (count != 0 && wrerr == NO &&
		    (j = write(ofd, bp->buf, count)) != count) {
			wrerr = YES;
			wrerrno = j >= 0 ? EIO : errno;
		}
		if (wrerr == NO && ftruncate(ofd, size) != 0) {
			run_err("%s: truncate: %s", np, strerror(errno));
			wrerr = DISPLAYED;
		}
		if (pflag) {
			if (exists || omode != mode)
				if (fchmod(ofd, omode)) {
					run_err("%s: set mode: %s",
					    np, strerror(errno));
					wrerr = DISPLAYED;
				}
		} else {
			if (!exists && omode != mode)
				if (fchmod(ofd, omode & ~mask)) {
					run_err("%s: set mode: %s",
					    np, strerror(errno));
					wrerr = DISPLAYED;
				}
		}
		(void)close(ofd);
		(void)response();
		if (setimes && wrerr == NO) {
			setimes = 0;
			if (utimes(np, tv) < 0) {
				run_err("%s: set times: %s",
				    np, strerror(errno));
				wrerr = DISPLAYED;
			}
		}
		switch(wrerr) {
		case YES:
			run_err("%s: %s", np, strerror(wrerrno));
			break;
		case NO:
			(void)write(rem, "", 1);
			break;
		case DISPLAYED:
			break;
		}
	}
screwup:
	run_err("protocol error: %s", why);
	exit(1);
}

#ifdef KERBEROS
int
kerberos(char **host, char *bp, char *locuser, char *user)
{
	struct servent *sp;

again:
	if (use_kerberos) {
		rem = KSUCCESS;
		errno = 0;
		if (dest_realm == NULL)
			dest_realm = krb_realmofhost(*host);
		rem =
		    doencrypt ?
			krcmd_mutual(host,
			    port, user, bp, 0, dest_realm, &cred, schedule) :
			krcmd(host, port, user, bp, 0, dest_realm);

		if (rem < 0) {
			use_kerberos = 0;
			if ((sp = getservbyname("shell", "tcp")) == NULL)
				errx(1, "unknown service shell/tcp");
			if (errno == ECONNREFUSED)
			    oldw("remote host doesn't support Kerberos");
			else if (errno == ENOENT)
			    oldw("can't provide Kerberos authentication data");
			port = sp->s_port;
			goto again;
		}
	} else {
		if (doencrypt)
			errx(1,
			   "the -x option requires Kerberos authentication");
		rem = rcmd(host, port, locuser, user, bp, 0);
	}
	return (rem);
}
#endif /* KERBEROS */

int
response(void)
{
	char ch, *cp, resp, rbuf[BUFSIZ];

	if (read(rem, &resp, sizeof(resp)) != sizeof(resp))
		lostconn(0);

	cp = rbuf;
	switch(resp) {
	case 0:				/* ok */
		return (0);
	default:
		*cp++ = resp;
		/* FALLTHROUGH */
	case 1:				/* error, followed by error msg */
	case 2:				/* fatal error, "" */
		do {
			if (read(rem, &ch, sizeof(ch)) != sizeof(ch))
				lostconn(0);
			*cp++ = ch;
		} while (cp < &rbuf[BUFSIZ] && ch != '\n');

		if (!iamremote)
			(void)write(STDERR_FILENO, rbuf, cp - rbuf);
		++errs;
		if (resp == 1)
			return (-1);
		exit(1);
	}
	/* NOTREACHED */
}

void
usage(void)
{
	(void)fprintf(stderr,
	    "usage: %s [-p] file1 file2\n"
	    "       %s [-pr] file ... directory\n",
	    __progname, __progname);
	exit(1);
}

#include <stdarg.h>

#ifdef KERBEROS
void
oldw(const char *fmt, ...)
{
	char realm[REALM_SZ];
	va_list ap;

	if (krb_get_lrealm(realm, 1) != KSUCCESS)
		return;
	va_start(ap, fmt);
	(void)fprintf(stderr, "rcp: ");
	(void)vfprintf(stderr, fmt, ap);
	(void)fprintf(stderr, ", using standard rcp\n");
	va_end(ap);
}
#endif

void
run_err(const char *fmt, ...)
{
	static FILE *fp;
	va_list ap;

	++errs;
	if (fp == NULL && !(fp = fdopen(rem, "w")))
		return;
	(void)fprintf(fp, "%c", 0x01);
	(void)fprintf(fp, "rcp: ");
	va_start(ap, fmt);
	(void)vfprintf(fp, fmt, ap);
	va_end(ap);
	(void)fprintf(fp, "\n");
	(void)fflush(fp);

	if (!iamremote) {
		va_start(ap, fmt);
		vwarnx(fmt, ap);
		va_end(ap);
	}
}
@


1.55
log
@cope with the renaming of default _PATH_RSH
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.54 2013/11/20 20:53:55 deraadt Exp $	*/
@


1.54
log
@unsigned casts for ctype macros where neccessary
ok guenther millert markus
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.53 2013/11/12 04:36:02 deraadt Exp $	*/
d257 1
a257 1
			addargs(&alist, "%s", _PATH_RSH);
@


1.53
log
@add a variety of missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.52 2013/06/17 04:48:42 guenther Exp $	*/
d655 1
a655 1
		for (size = 0; isdigit(*cp);)
@


1.52
log
@Handle time_t values as long long's when formatting them and when
parsing them from remote servers.
Improve error checking in parsing of 'T' lines.

ok dtucker@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.51 2013/06/01 20:59:25 dtucker Exp $	*/
d96 1
@


1.51
log
@Replace S_IWRITE, which isn't standardized, with S_IWUSR, which is.  Patch
from Nathan Osman via bz#2085.  ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.50 2012/12/04 02:24:46 deraadt Exp $	*/
d384 13
d443 1
a443 9
			/*
			 * Make it compatible with possible future
			 * versions expecting microseconds.
			 */
			(void)snprintf(buf, sizeof(buf), "T%lu 0 %lu 0\n",
			    (u_long) (stb.st_mtime < 0 ? 0 : stb.st_mtime),
			    (u_long) (stb.st_atime < 0 ? 0 : stb.st_atime));
			(void)write(rem, buf, strlen(buf));
			if (response() < 0)
d508 1
a508 5
		(void)snprintf(path, sizeof(path), "T%ld 0 %ld 0\n",
		    (long)statp->st_mtimespec.tv_sec,
		    (long)statp->st_atimespec.tv_sec);
		(void)write(rem, path, strlen(path));
		if (response() < 0) {
d547 1
d604 3
a606 1
			mtime.tv_sec = strtol(cp, &cp, 10);
d609 3
d613 2
a614 1
			if (!cp || *cp++ != ' ')
d616 3
a618 1
			atime.tv_sec = strtol(cp, &cp, 10);
d621 3
d625 2
a626 1
			if (!cp || *cp++ != '\0')
@


1.50
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.49 2009/10/27 23:59:22 deraadt Exp $	*/
d694 1
a694 1
		mode |= S_IWRITE;
@


1.49
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.48 2009/03/01 13:47:02 sobrado Exp $	*/
a32 1
#include <sys/param.h>
@


1.48
log
@fix double space in synopsis and usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.47 2008/01/01 09:10:25 dtucker Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1983, 1990, 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)rcp.c	8.2 (Berkeley) 4/2/94";
#else
static const char rcsid[] = "$OpenBSD: rcp.c,v 1.47 2008/01/01 09:10:25 dtucker Exp $";
#endif
#endif /* not lint */
@


1.47
log
@If rcp -p encounters a pre-epoch timestamp, use the epoch which is
as close as we can get given that it's used unsigned.  Matches
recent change to scp.c, prompted by djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.46 2007/03/20 18:50:11 jmc Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: rcp.c,v 1.46 2007/03/20 18:50:11 jmc Exp $";
d876 1
a876 1
	    "       %s [-pr] file ...  directory\n",
@


1.46
log
@sync usage(); from Igor Sobrado
i also ripped some kerberos ifdefs out of usage(), which is ok biorn
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.45 2006/05/17 12:44:16 markus Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: rcp.c,v 1.45 2006/05/17 12:44:16 markus Exp $";
d449 3
a451 3
			(void)snprintf(buf, sizeof(buf), "T%ld 0 %ld 0\n",
			    (long)stb.st_mtimespec.tv_sec,
			    (long)stb.st_atimespec.tv_sec);
@


1.45
log
@fix leak
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.44 2006/03/23 02:48:57 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: rcp.c,v 1.44 2006/03/23 02:48:57 deraadt Exp $";
a873 6
#ifdef KERBEROS
	(void)fprintf(stderr, "usage: %s [-Kpx] [-k realm] f1 f2\n",
	    __progname);
 	(void)fprintf(stderr, "       %s [-Kprx] [-k realm] f1 ... fn directory\n",
	    __progname);
#else
d875 3
a877 3
	    "usage: %s [-p] f1 f2; or: rcp [-pr] f1 ... fn directory\n",
	    __progname);
#endif
@


1.44
log
@give correct err string; adobriyan@@gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.43 2006/03/12 01:51:15 djm Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: rcp.c,v 1.43 2006/03/12 01:51:15 djm Exp $";
d329 1
@


1.43
log
@fix double shell expansion issue found in scp in rcp too; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.42 2005/11/12 18:34:25 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: rcp.c,v 1.42 2005/11/12 18:34:25 deraadt Exp $";
d245 1
a245 1
		err(1, "malloc");
d253 1
a253 1
		err(1, "malloc");
d342 1
a342 1
		err(1, "malloc");
@


1.42
log
@move to asprintf; ok dhill cloder
also fix a close(random data) which changed a saved errno, ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.41 2005/03/31 18:39:21 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: rcp.c,v 1.41 2005/03/31 18:39:21 deraadt Exp $";
d90 1
d181 1
d189 3
a191 2
		(void)seteuid(userid);
		(void)setuid(userid);
d197 3
a199 2
		(void)seteuid(userid);
		(void)setuid(userid);
d239 4
d270 4
d277 1
d286 12
a297 16
				if (asprintf(&bp,
				    "%s %s -l %s -n %s %s '%s%s%s:%s'",
				    _PATH_RSH, host, suser, cmd, src,
				    tuser ? tuser : "", tuser ? "@@" : "",
				    thost, targ) == -1)
					err(1, NULL);
			} else {
				if (asprintf(&bp,
				    "exec %s %s -n %s %s '%s%s%s:%s'",
				    _PATH_RSH, argv[i], cmd, src,
				    tuser ? tuser : "", tuser ? "@@" : "",
				    thost, targ) == -1)
					err(1, NULL);
			}
			(void)susystem(bp, userid);
			(void)free(bp);
d321 3
a323 2
				(void)seteuid(userid);
				(void)setuid(userid);
d336 4
d346 9
a354 5
			if (asprintf(&bp, "exec %s%s%s %s %s", _PATH_CP,
			    iamrecursive ? " -R" : "", pflag ? " -p" : "",
			    argv[i], argv[argc - 1]) == -1)
				err(1, NULL);
			if (susystem(bp, userid))
a355 1
			(void)free(bp);
@


1.41
log
@copy argv[] element instead of smashing the one that ps will see; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.40 2004/07/08 12:53:42 dtucker Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: rcp.c,v 1.40 2004/07/08 12:53:42 dtucker Exp $";
d233 1
a233 1
	int i, len, tos;
a265 5
			len = strlen(_PATH_RSH) + strlen(argv[i]) +
			    strlen(src) + (tuser ? strlen(tuser) : 0) +
			    strlen(thost) + strlen(targ) + CMDNEEDS + 20;
			if (!(bp = malloc(len)))
				err(1, NULL);
d273 1
a273 1
				(void)snprintf(bp, len,
d277 4
a280 3
				    thost, targ);
			} else
				(void)snprintf(bp, len,
d284 3
a286 1
				    thost, targ);
d291 1
a291 2
				len = strlen(targ) + CMDNEEDS + 20;
				if (!(bp = malloc(len)))
a292 1
				(void)snprintf(bp, len, "%s -t %s", cmd, targ);
d324 1
a324 1
	int i, len, tos;
d332 3
a334 3
			len = strlen(_PATH_CP) + strlen(argv[i]) +
			    strlen(argv[argc - 1]) + 20;
			if (!(bp = malloc(len)))
a335 3
			(void)snprintf(bp, len, "exec %s%s%s %s %s", _PATH_CP,
			    iamrecursive ? " -R" : "", pflag ? " -p" : "",
			    argv[i], argv[argc - 1]);
d355 1
a355 2
		len = strlen(src) + CMDNEEDS + 20;
		if ((bp = malloc(len)) == NULL)
a356 1
		(void)snprintf(bp, len, "%s -f %s", cmd, src);
d388 1
a388 1
	int amt, fd, haderr, indx, result;
d405 2
a406 1
syserr:			run_err("%s: %s", name, strerror(errno));
d445 4
a448 1
next:			(void)close(fd);
d470 5
a474 2
		if (close(fd) && !haderr)
			haderr = errno;
@


1.40
log
@Prevent rcp from skipping the file following a double-error.  Matches scp.c
rev 1.116, prompted by & ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.39 2004/04/01 12:19:57 markus Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: rcp.c,v 1.39 2004/04/01 12:19:57 markus Exp $";
d234 1
a234 1
	char *bp, *host, *src, *suser, *thost, *tuser, *user;
d243 4
a246 1
	if ((thost = strchr(argv[argc - 1], '@@'))) {
d249 1
a249 1
		tuser = argv[argc - 1];
d255 1
a255 1
		thost = argv[argc - 1];
@


1.39
log
@limit trust between local and remote rcp/scp process,
noticed by lcamtuf; ok deraadt@@, djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.38 2003/07/29 00:24:16 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: rcp.c,v 1.38 2003/07/29 00:24:16 deraadt Exp $";
d741 1
a741 1
				if (fchmod(ofd, omode))
d744 2
d748 1
a748 1
				if (fchmod(ofd, omode & ~mask))
d751 2
@


1.38
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.37 2003/07/28 06:05:35 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: rcp.c,v 1.37 2003/07/28 06:05:35 tedu Exp $";
d640 4
d662 2
@


1.37
log
@rcsid should say openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.36 2003/07/18 00:44:50 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD$";
d847 1
a847 1
            __progname);
d849 1
a849 1
            __progname);
d853 1
a853 1
             __progname);
@


1.36
log
@unsigned uid; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.35 2003/06/02 23:32:09 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$NetBSD: rcp.c,v 1.9 1995/03/21 08:19:06 cgd Exp $";
@


1.35
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.34 2003/04/13 18:04:41 deraadt Exp $	*/
d179 1
a179 1
		errx(1, "unknown user %d", (int)userid);
@


1.34
log
@0 vs NULL; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.33 2003/03/08 17:18:25 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.33
log
@duplicate include; andrushock@@pisem.net
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.32 2003/01/10 10:29:35 djm Exp $	*/
d498 1
a498 1
	if (last == 0)
@


1.32
log
@Don't ftruncate after write error, creating sparse files of incorrect length
mindrot bug #403, reported by rusr@@cup.hp.com; ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.31 2002/07/04 04:26:40 deraadt Exp $	*/
a68 1
#include <string.h>
@


1.31
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.30 2002/06/09 05:30:08 todd Exp $	*/
d734 1
a734 1
		if (ftruncate(ofd, size)) {
@


1.30
log
@some knf.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.29 2002/05/09 18:44:46 millert Exp $	*/
d118 1
a118 3
main(argc, argv)
	int argc;
	char *argv[];
d236 1
a236 3
toremote(targ, argc, argv)
	char *targ, *argv[];
	int argc;
d328 1
a328 3
tolocal(argc, argv)
	int argc;
	char *argv[];
d393 1
a393 3
source(argc, argv)
	int argc;
	char *argv[];
d488 1
a488 3
rsource(name, statp)
	char *name;
	struct stat *statp;
d539 1
a539 3
sink(argc, argv)
	int argc;
	char *argv[];
d777 1
a777 2
kerberos(host, bp, locuser, user)
	char **host, *bp, *locuser, *user;
d815 1
a815 1
response()
d848 1
a848 1
usage()
@


1.29
log
@Remove setuid bit; non-root uses will have rsh(1) invoked on their behalf.
This does mean that we cannot set IPTOS_THROUGHPUT.  If this is a problem
we may be able to add an option to rsh(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.28 2002/02/19 19:39:35 millert Exp $	*/
d864 1
a864 1
	(void)fprintf(stderr, "usage: %s [-Kpx] [-k realm] f1 f2\n", 
@


1.28
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.27 2002/02/17 19:42:19 millert Exp $	*/
d188 2
d316 2
a317 1
				    &tos, sizeof(int)) < 0)
d387 2
a388 1
		if (setsockopt(rem, IPPROTO_IP, IP_TOS, &tos, sizeof(int)) < 0)
@


1.27
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.26 2002/02/16 21:27:07 millert Exp $	*/
a871 1
#ifdef __STDC__
a872 3
#else
#include <varargs.h>
#endif
a875 1
#ifdef __STDC__
a876 5
#else
oldw(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
a882 1
#ifdef __STDC__
a883 3
#else
	va_start(ap);
#endif
a891 1
#ifdef __STDC__
a892 5
#else
run_err(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
a901 1
#ifdef __STDC__
a902 3
#else
	va_start(ap);
#endif
a908 1
#ifdef __STDC__
a909 3
#else
		va_start(ap);
#endif
@


1.26
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.25 2001/11/21 15:35:28 markus Exp $	*/
d106 2
a107 2
int krcmd_mutual __P((char **, u_short, char *, char *, int *,
		       char *, CREDENTIALS *, Key_schedule));
@


1.25
log
@2GB fix (int->off_t) similar to scp; daniel@@lucq.org
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.24 2001/10/01 08:06:28 markus Exp $	*/
d102 2
a103 2
int	 kerberos __P((char **, char *, char *, char *));
void	 oldw __P((const char *, ...));
d105 1
a105 1
int krcmd __P((char **, u_short, char *, char *, int *, char *));
d109 7
a115 7
int	 response __P((void));
void	 rsource __P((char *, struct stat *));
void	 sink __P((int, char *[]));
void	 source __P((int, char *[]));
void	 tolocal __P((int, char *[]));
void	 toremote __P((char *, int, char *[]));
void	 usage __P((void));
@


1.24
log
@skip filenames containing \n; report jdamery@@chiark.greenend.org.uk
and matthew@@debian.org
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.23 2001/09/06 13:29:08 mpech Exp $	*/
d554 1
a554 1
	off_t i, j;
d556 1
a556 1
	int setimes, size, targisdir, wrerrno = 0;
@


1.23
log
@o) __progname aria;

millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.22 2001/06/13 09:03:18 markus Exp $	*/
d412 5
@


1.22
log
@exit(errs) -> exit(errs!=0); sync with scp.c, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.21 2001/06/13 08:52:42 markus Exp $	*/
d855 4
a858 3
	(void)fprintf(stderr, "%s\n%s\n",
	    "usage: rcp [-Kpx] [-k realm] f1 f2",
	    "   or: rcp [-Kprx] [-k realm] f1 ... fn directory");
d861 2
a862 1
	    "usage: rcp [-p] f1 f2; or: rcp [-pr] f1 ... fn directory\n");
@


1.21
log
@va_start/end for every call to vfprintf and friends, from scp.c
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.20 2001/05/11 18:43:40 mickey Exp $	*/
d195 1
a195 1
		exit(errs);
d202 1
a202 1
		exit(errs);
d232 1
a232 1
	exit(errs);
@


1.20
log
@use strlcpy instead of strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: rcp.c,v 1.19 2001/04/06 16:46:59 deraadt Exp $	*/
a908 5
#ifdef __STDC__
	va_start(ap, fmt);
#else
	va_start(ap);
#endif
d915 5
d921 1
d925 6
a930 1
	if (!iamremote)
d932 2
a933 2

	va_end(ap);
@


1.19
log
@remove trailing / from source paths; fixes pr#1756
@
text
@d1 1
a2 1
/*	$OpenBSD: rcp.c,v 1.18 1997/12/08 05:15:29 deraadt Exp $	*/
d83 1
a83 1
CREDENTIALS 	cred;
d137 1
a137 2
			(void)strncpy(dst_realm_buf, optarg, REALM_SZ-1);
			dst_realm_buf[REALM_SZ-1] = '\0';
@


1.18
log
@use cp -R for local copies
@
text
@d2 1
a2 1
/*	$OpenBSD: rcp.c,v 1.17 1997/11/05 00:09:36 deraadt Exp $	*/
d406 1
d410 3
@


1.17
log
@avoid having pw_ information active when calling rcmd(); tacha@@tera.fukui-med.ac.jp
@
text
@d2 1
a2 1
/*	$OpenBSD: rcp.c,v 1.16 1997/09/12 04:43:18 millert Exp $	*/
d347 1
a347 1
			    iamrecursive ? " -r" : "", pflag ? " -p" : "",
@


1.16
log
@-Wall
@
text
@d2 1
a2 1
/*	$OpenBSD: rcp.c,v 1.15 1997/09/01 18:30:22 deraadt Exp $	*/
d242 4
a245 1
	char *bp, *host, *src, *suser, *thost, *tuser;
d280 1
a280 1
					suser = pwd->pw_name;
d305 1
a305 2
					rem = kerberos(&host, bp,
					    pwd->pw_name,
d309 2
a310 3
					rem = rcmd(&host, port, pwd->pw_name,
					    tuser ? tuser : pwd->pw_name,
					    bp, 0);
d326 1
d335 4
a338 1
	char *bp, *host, *src, *suser;
d359 1
a359 1
			suser = pwd->pw_name;
d364 1
a364 1
				suser = pwd->pw_name;
d375 1
a375 1
			kerberos(&host, bp, pwd->pw_name, suser) :
d377 1
a377 1
			rcmd(&host, port, pwd->pw_name, suser, bp, 0);
d392 1
@


1.15
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d2 1
a2 1
/*	$OpenBSD: rcp.c,v 1.14 1997/07/25 18:58:41 mickey Exp $	*/
d432 2
a433 1
			    stb.st_mtimespec.tv_sec, stb.st_atimespec.tv_sec);
d497 2
a498 1
		    statp->st_mtimespec.tv_sec, statp->st_atimespec.tv_sec);
@


1.14
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d2 1
a2 1
/*	$OpenBSD: rcp.c,v 1.13 1997/07/23 19:19:33 kstailey Exp $	*/
d106 1
a106 1
int krcmd_mutual __P((char **, u_short, char *, char *, int *, 
d367 1
a367 1
		rem = 
d369 2
a370 2
		    use_kerberos ? 
			kerberos(&host, bp, pwd->pw_name, suser) : 
d714 1
a714 1
						wrerrno = j >= 0 ? EIO : errno; 
d724 1
a724 1
			wrerrno = j >= 0 ? EIO : errno; 
d780 2
a781 2
		rem = 
		    doencrypt ? 
@


1.13
log
@tabify
@
text
@d2 1
a2 1
/*	$OpenBSD: rcp.c,v 1.12 1997/06/29 11:10:28 provos Exp $	*/
d854 1
a854 1
#if __STDC__
d862 1
a862 1
#if __STDC__
d875 1
a875 1
#if __STDC__
d888 1
a888 1
#if __STDC__
d898 1
a898 1
#if __STDC__
@


1.12
log
@new location of des.h
@
text
@d2 1
a2 1
/*	$OpenBSD: rcp.c,v 1.11 1997/06/06 11:02:21 deraadt Exp $	*/
d402 1
a402 1
                name = argv[indx];
d867 1
a867 1
        va_dcl
d893 1
a893 1
        va_dcl
@


1.11
log
@fix
@
text
@d2 1
a2 1
/*	$OpenBSD: rcp.c,v 1.10 1997/03/26 01:19:49 deraadt Exp $	*/
d77 1
a77 1
#include <kerberosIV/des.h>
@


1.10
log
@unterminated buffer; charnier@@xp11.frmug.org
@
text
@d2 1
a2 1
/*	$OpenBSD: rcp.c,v 1.9 1997/01/15 23:40:25 millert Exp $	*/
d844 1
a844 1
	(void)fprintf(stderr, "%s\n\t%s\n",
d846 1
a846 1
	    "or: rcp [-Kprx] [-k realm] f1 ... fn directory");
@


1.9
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d2 1
a2 1
/*	$OpenBSD: rcp.c,v 1.8 1996/12/22 02:57:51 tholo Exp $	*/
d137 2
a138 1
			(void)strncpy(dst_realm_buf, optarg, REALM_SZ);
@


1.8
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d2 1
a2 1
/*	$OpenBSD: rcp.c,v 1.7 1996/12/14 12:18:13 mickey Exp $	*/
d127 1
a127 1
	while ((ch = getopt(argc, argv, OPTIONS)) != EOF)
@


1.7
log
@-Wall'ing.
@
text
@d2 1
a2 1
/*	$OpenBSD: rcp.c,v 1.6 1996/08/02 12:41:04 deraadt Exp $	*/
d192 1
d199 1
d318 1
@


1.6
log
@zap getopt() case of -?, come on, it is the default!
@
text
@d2 1
a2 1
/*	$OpenBSD: rcp.c,v 1.5 1996/08/02 12:17:04 deraadt Exp $	*/
d104 4
d223 1
a223 1
	if (targ = colon(argv[argc - 1]))	/* Dest is remote host. */
d245 1
a245 1
	if (thost = strchr(argv[argc - 1], '@@')) {
d506 1
a506 1
	while (dp = readdir(dirp)) {
d536 1
a536 1
	int setimes, size, targisdir, wrerrno;
@


1.5
log
@more robust deliting, and handle negative timestamps; from freebsd
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
a157 1
		case '?':
@


1.4
log
@timespec members are now named tv_{,u}sec again
@
text
@a583 1
#define getnum(t) (t) = 0; while (isdigit(*cp)) (t) = (t) * 10 + (*cp++ - '0');
d588 2
a589 2
			getnum(mtime.tv_sec);
			if (*cp++ != ' ')
d591 2
a592 2
			getnum(mtime.tv_usec);
			if (*cp++ != ' ')
d594 2
a595 2
			getnum(atime.tv_sec);
			if (*cp++ != ' ')
d597 2
a598 2
			getnum(atime.tv_usec);
			if (*cp++ != '\0')
@


1.3
log
@Only warn about non-kerberos protocol if kerberos has been configured with
a local realm (/etc/kerberosIV/krb.conf is set up).
@
text
@d2 1
d425 1
a425 1
			    stb.st_mtimespec.ts_sec, stb.st_atimespec.ts_sec);
d489 1
a489 1
		    statp->st_mtimespec.ts_sec, statp->st_atimespec.ts_sec);
@


1.2
log
@Make it possible to build without SKEY support
Add support for building with kerberosIV
@
text
@d863 1
d865 3
@


1.1
log
@Initial revision
@
text
@a84 1
#ifdef CRYPT
a87 3
#define	OPTIONS	"dfKk:prt"
#endif
#else
a133 1
#ifdef CRYPT
a138 1
#endif
a165 1
#ifdef CRYPT
a166 3
#else
		shell = "kshell";
#endif
a208 1
#ifdef CRYPT
a209 3
#else
	    "",
#endif
a773 1
#ifdef CRYPT
a776 1
#endif
a790 1
#ifdef CRYPT
a793 1
#endif
a836 1
#ifdef CRYPT
a839 5
#else
	(void)fprintf(stderr, "%s\n\t%s\n",
	    "usage: rcp [-Kp] [-k realm] f1 f2",
	    "or: rcp [-Kpr] [-k realm] f1 ... fn directory");
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
