head	1.12;
access;
symbols
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.6.0.44
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.36
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.40
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.38
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.34
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.32
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.30
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.28
	OPENBSD_5_0:1.6.0.26
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.24
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.22
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.18
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.20
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.16
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.14
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.12
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.10
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.8
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.6
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.4
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.3.0.16
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.14
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.12
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.10
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.8
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.6
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.6
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.4
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.11.08.17.52.43;	author mmcc;	state Exp;
branches;
next	1.11;
commitid	8Hvya6CZ8kksl9uq;

1.11
date	2015.11.05.18.39.34;	author mmcc;	state Exp;
branches;
next	1.10;
commitid	farEPxBMl3ksOgyr;

1.10
date	2015.11.01.16.03.11;	author mmcc;	state Exp;
branches;
next	1.9;
commitid	KAa7NKTKUU4mXmkX;

1.9
date	2015.11.01.15.38.53;	author mmcc;	state Exp;
branches;
next	1.8;
commitid	Fr9nr0FBz2YkAWdK;

1.8
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.7;
commitid	v5QjoxUgKU2iUTFz;

1.7
date	2015.09.01.13.12.31;	author tedu;	state Exp;
branches;
next	1.6;
commitid	sKGEDet4KOfGjsIb;

1.6
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.26.16.19.45;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	98.06.25.19.01.56;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Tweak a reallocarray call to be more overflow-resistant. From Theo Buehler.

ok nicm@@
@
text
@/*	$OpenBSD: expand.h,v 1.11 2015/11/05 18:39:34 mmcc Exp $	*/

/*
 * Expanding strings
 */

#define X_EXTRA		8	/* this many extra bytes in X string */

#if 0				/* Usage */
	XString xs;
	char *xp;

	Xinit(xs, xp, 128, ATEMP); /* allocate initial string */
	while ((c = generate()) {
		Xcheck(xs, xp);	/* expand string if necessary */
		Xput(xs, xp, c); /* add character */
	}
	return Xclose(xs, xp);	/* resize string */
/*
 * NOTE:
 *     The Xcheck and Xinit macros have a magic + X_EXTRA in the lengths.
 *     This is so that you can put up to X_EXTRA characters in a XString
 *     before calling Xcheck. (See yylex in lex.c)
 */
#endif /* 0 */

typedef struct XString {
	char   *end, *beg;	/* end, begin of string */
	size_t	len;		/* length */
	Area	*areap;		/* area to allocate/free from */
} XString;

typedef char * XStringP;

/* initialize expandable string */
#define	Xinit(xs, xp, length, area) do { \
			(xs).len = length; \
			(xs).areap = (area); \
			(xs).beg = alloc((xs).len + X_EXTRA, (xs).areap); \
			(xs).end = (xs).beg + (xs).len; \
			xp = (xs).beg; \
		} while (0)

/* stuff char into string */
#define	Xput(xs, xp, c)	(*xp++ = (c))

/* check if there are at least n bytes left */
#define	XcheckN(xs, xp, n) do { \
		    int more = ((xp) + (n)) - (xs).end; \
		    if (more > 0) \
			xp = Xcheck_grow_(&xs, xp, more); \
		} while (0)

/* check for overflow, expand string */
#define Xcheck(xs, xp)	XcheckN(xs, xp, 1)

/* free string */
#define	Xfree(xs, xp)	afree((xs).beg, (xs).areap)

/* close, return string */
#define	Xclose(xs, xp)	aresize((xs).beg, ((xp) - (xs).beg), (xs).areap)
/* begin of string */
#define	Xstring(xs, xp)	((xs).beg)

#define Xnleft(xs, xp) ((xs).end - (xp))	/* may be less than 0 */
#define	Xlength(xs, xp) ((xp) - (xs).beg)
#define Xsize(xs, xp) ((xs).end - (xs).beg)
#define	Xsavepos(xs, xp) ((xp) - (xs).beg)
#define	Xrestpos(xs, xp, n) ((xs).beg + (n))

char *	Xcheck_grow_(XString *xsp, char *xp, int more);

/*
 * expandable vector of generic pointers
 */

typedef struct XPtrV {
	void  **cur;		/* next avail pointer */
	void  **beg, **end;	/* begin, end of vector */
} XPtrV;

#define	XPinit(x, n) do { \
			void **vp__; \
			vp__ = areallocarray(NULL, n, sizeof(void *), ATEMP); \
			(x).cur = (x).beg = vp__; \
			(x).end = vp__ + n; \
		} while (0)

#define	XPput(x, p) do { \
			if ((x).cur >= (x).end) { \
				int n = XPsize(x); \
				(x).beg = areallocarray((x).beg, n, \
						   2 * sizeof(void *), ATEMP); \
				(x).cur = (x).beg + n; \
				(x).end = (x).cur + n; \
			} \
			*(x).cur++ = (p); \
		} while (0)

#define	XPptrv(x)	((x).beg)
#define	XPsize(x)	((x).cur - (x).beg)

#define	XPclose(x)	areallocarray((x).beg, XPsize(x), \
					 sizeof(void *), ATEMP)

#define	XPfree(x)	afree((x).beg, ATEMP)
@


1.11
log
@Clean up an Xstring macro. Submitted by Theo Buehler.

ok and suggestions from nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.h,v 1.10 2015/11/01 16:03:11 mmcc Exp $	*/
d92 2
a93 2
				(x).beg = areallocarray((x).beg, n*2, \
						   sizeof(void *), ATEMP); \
@


1.10
log
@Remove two casts of void* return types.
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.h,v 1.9 2015/11/01 15:38:53 mmcc Exp $	*/
d61 1
a61 2
#define	Xclose(xs, xp)	(char*) aresize((void*)(xs).beg, \
					(size_t)((xp) - (xs).beg), (xs).areap)
@


1.9
log
@Add uses of areallocarray(). mksh and Bitrig ksh already have similar
functions. With help from Theo Buehler.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.h,v 1.8 2015/09/17 14:21:33 nicm Exp $	*/
d93 1
a93 1
				(x).beg = (void**) areallocarray((x).beg, n*2, \
d104 1
a104 1
#define	XPclose(x)	(void**) areallocarray((x).beg, XPsize(x), \
@


1.8
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.h,v 1.7 2015/09/01 13:12:31 tedu Exp $	*/
d85 1
a85 1
			vp__ = alloc(sizeofN(void*, n), ATEMP); \
d93 2
a94 2
				(x).beg = (void**) aresize((void*) (x).beg, \
						   sizeofN(void*, n*2), ATEMP); \
d104 2
a105 2
#define	XPclose(x)	(void**) aresize((void*)(x).beg, \
					 sizeofN(void*, XPsize(x)), ATEMP)
@


1.7
log
@remove casts and null checks before free. from Michael McConville
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.h,v 1.6 2005/03/30 17:16:37 deraadt Exp $	*/
d85 1
a85 1
			vp__ = (void**) alloc(sizeofN(void*, n), ATEMP); \
@


1.6
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.h,v 1.5 2004/12/18 21:25:44 millert Exp $	*/
d58 1
a58 1
#define	Xfree(xs, xp)	afree((void*) (xs).beg, (xs).areap)
d107 1
a107 1
#define	XPfree(x)	afree((void*) (x).beg, ATEMP)
@


1.5
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.h,v 1.4 2004/12/18 20:55:52 millert Exp $	*/
d88 1
a88 1
		    } while (0)
@


1.4
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.h,v 1.3 2001/03/26 16:19:45 todd Exp $	*/
d84 1
a84 1
			register void **vp__; \
@


1.3
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.h,v 1.2 1998/06/25 19:01:56 millert Exp $	*/
d72 1
a72 1
char *	Xcheck_grow_	ARGS((XString *xsp, char *xp, int more));
@


1.2
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.h,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
d15 1
a15 1
		Xcheck(xs, xp);	/* expand string if neccessary */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d7 1
d21 3
a23 3
 *	The Xcheck and Xinit macros have a magic + 8 in the lengths.  This is
 *	so that you can put up to 4 characters in a XString before calling
 *	Xcheck.  (See yylex in lex.c)
d39 1
a39 1
			(xs).beg = alloc((xs).len + 8, (xs).areap); \
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
