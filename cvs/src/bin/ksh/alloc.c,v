head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.8.0.32
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.24
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.28
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.26
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.22
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.20
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.18
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.16
	OPENBSD_5_0:1.8.0.14
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.12
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.10
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.6
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.8
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.4
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.7.0.18
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.16
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.14
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.12
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.10
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.8
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2016.06.01.10.29.20;	author espie;	state Exp;
branches;
next	1.14;
commitid	WzMFiZ91yGAG79JM;

1.14
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.13;
commitid	btTCreDA00YdaFhU;

1.13
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.12;
commitid	16HUr75moyUNtKR8;

1.12
date	2015.10.17.13.32.46;	author mmcc;	state Exp;
branches;
next	1.11;
commitid	nmnYqATNGmNkjVuZ;

1.11
date	2015.10.17.13.27.55;	author mmcc;	state Exp;
branches;
next	1.10;
commitid	nnZwYpyxyJd9632A;

1.10
date	2015.10.16.23.13.35;	author mmcc;	state Exp;
branches;
next	1.9;
commitid	pH2ZR66ewZFleMfF;

1.9
date	2015.10.16.03.17.56;	author mmcc;	state Exp;
branches;
next	1.8;
commitid	ZwOt8I9Eg3l8dvUb;

1.8
date	2008.07.21.17.30.08;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.19.18.51.17;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.05.20.52.27;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.01.13.06.18;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	99.07.14.13.37.23;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.06.29.20.06.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	98.06.25.19.01.43;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.10;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.10;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.15
log
@put this in the public domain as well. reminded by theo. we discussed
this before previous release, and I plain forgot about it.
@
text
@/*	$OpenBSD: alloc.c,v 1.14 2015/12/14 13:59:42 tb Exp $	*/

/* Public domain, like most of the rest of ksh */

/*
 * area-based allocation built on malloc/free
 */

#include <stdint.h>
#include <stdlib.h>

#include "sh.h"

struct link {
	struct link *prev;
	struct link *next;
};

Area *
ainit(Area *ap)
{
	ap->freelist = NULL;
	return ap;
}

void
afreeall(Area *ap)
{
	struct link *l, *l2;

	for (l = ap->freelist; l != NULL; l = l2) {
		l2 = l->next;
		free(l);
	}
	ap->freelist = NULL;
}

#define L2P(l)	( (void *)(((char *)(l)) + sizeof(struct link)) )
#define P2L(p)	( (struct link *)(((char *)(p)) - sizeof(struct link)) )

void *
alloc(size_t size, Area *ap)
{
	struct link *l;

	/* ensure that we don't overflow by allocating space for link */
	if (size > SIZE_MAX - sizeof(struct link))
		internal_errorf(1, "unable to allocate memory");

	l = malloc(sizeof(struct link) + size);
	if (l == NULL)
		internal_errorf(1, "unable to allocate memory");
	l->next = ap->freelist;
	l->prev = NULL;
	if (ap->freelist)
		ap->freelist->prev = l;
	ap->freelist = l;

	return L2P(l);
}

/*
 * Copied from calloc().
 *
 * This is sqrt(SIZE_MAX+1), as s1*s2 <= SIZE_MAX
 * if both s1 < MUL_NO_OVERFLOW and s2 < MUL_NO_OVERFLOW
 */
#define MUL_NO_OVERFLOW	(1UL << (sizeof(size_t) * 4))

void *
areallocarray(void *ptr, size_t nmemb, size_t size, Area *ap)
{
	/* condition logic cloned from calloc() */
	if ((nmemb >= MUL_NO_OVERFLOW || size >= MUL_NO_OVERFLOW) &&
	    nmemb > 0 && SIZE_MAX / nmemb < size) {
		internal_errorf(1, "unable to allocate memory");
	}

	return aresize(ptr, nmemb * size, ap);
}

void *
aresize(void *ptr, size_t size, Area *ap)
{
	struct link *l, *l2, *lprev, *lnext;

	if (ptr == NULL)
		return alloc(size, ap);

	/* ensure that we don't overflow by allocating space for link */
	if (size > SIZE_MAX - sizeof(struct link))
		internal_errorf(1, "unable to allocate memory");

	l = P2L(ptr);
	lprev = l->prev;
	lnext = l->next;

	l2 = realloc(l, sizeof(struct link) + size);
	if (l2 == NULL)
		internal_errorf(1, "unable to allocate memory");
	if (lprev)
		lprev->next = l2;
	else
		ap->freelist = l2;
	if (lnext)
		lnext->prev = l2;

	return L2P(l2);
}

void
afree(void *ptr, Area *ap)
{
	struct link *l, *l2;

	if (!ptr)
		return;

	l = P2L(ptr);

	for (l2 = ap->freelist; l2 != NULL; l2 = l2->next) {
		if (l == l2)
			break;
	}
	if (l2 == NULL)
		internal_errorf(1, "afree: %p not present in area %p", ptr, ap);

	if (l->prev)
		l->prev->next = l->next;
	else
		ap->freelist = l->next;
	if (l->next)
		l->next->prev = l->prev;

	free(l);
}
@


1.14
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 3
a3 25
/*	$OpenBSD: alloc.c,v 1.13 2015/10/19 02:15:45 mmcc Exp $	*/
/*
 * Copyright (c) 2002 Marc Espie.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
@


1.13
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.12 2015/10/17 13:32:46 mmcc Exp $	*/
d32 1
@


1.12
log
@Change allocarray() to areallocarray(), a full reallocarray clone. All
the logic is already in aresize().

"Sure" nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.11 2015/10/17 13:27:55 mmcc Exp $	*/
d32 1
@


1.11
log
@Copy alloc()'s overflow check to aresize().

Suggested by nicm@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.10 2015/10/16 23:13:35 mmcc Exp $	*/
d91 1
a91 1
allocarray(size_t nmemb, size_t size, Area *ap)
d99 1
a99 1
	return alloc(nmemb * size, ap);
@


1.10
log
@Move the overflow check to alloc() so that the link struct overhead can
never bite us.

Suggested by Theo Buehler, inspired by Bitrig's natano@@.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.9 2015/10/16 03:17:56 mmcc Exp $	*/
d109 4
@


1.9
log
@Add allocarray(), an overflow-safe allocation function.

We avoided reallocation support because it demands more fancy footwork
to deal with the prepended link struct.

This has been on my mind for a while, and a 2010 security review of mksh
by the Android security team's Chris Palmer suggested it.

ok nicm@@. Also discussed with millert@@ and tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.8 2008/07/21 17:30:08 millert Exp $	*/
d66 4
a97 4

	/* additional check because alloc() allocates space for link */
	if (nmemb * size > SIZE_MAX - sizeof(struct link))
		internal_errorf(1, "unable to allocate memory");
@


1.8
log
@Extra sanity checking for afree();  OK deraadt@@ and pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.7 2004/02/19 18:51:17 deraadt Exp $	*/
d31 1
d76 24
@


1.7
log
@basic knf
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.6 2003/08/05 20:52:27 millert Exp $	*/
d105 1
a105 1
	struct link *l;
d111 7
@


1.6
log
@Don't allow alloc() and aresize() to fail.  Their return value was
only checked in two place (both in conjunction with str_save).  Upon
malloc/realloc failure we call internal_errorf() which pops throws
and error and pops back to the last good state.  OK deraadt@@ pval@@ fgs@@
Original problem noted by mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.5 2002/03/01 13:06:18 espie Exp $	*/
d65 1
a65 1
	l = malloc(size + sizeof(struct link));
d89 1
a89 1
	l2 = realloc(l, size+sizeof(struct link));
d93 1
a93 1
	    lprev->next = l2;
d95 1
a95 1
	    ap->freelist = l2;
d97 1
a97 1
	    lnext->prev = l2;
@


1.5
log
@Kill hand-made memory allocation code, that is definitely buggy.
Replace with simple wrapper around malloc, at least this works,
and it's easier to debug anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.4 1999/07/14 13:37:23 millert Exp $	*/
d66 2
a67 2
	if (!l)
		return NULL;
d90 9
a98 8
	if (l2) {
		if (lprev)
		    lprev->next = l2;
	    	else
		    ap->freelist = l2;
		if (lnext)
		    lnext->prev = l2;
		}
@


1.4
log
@pdksh-5.2.14
@
text
@d1 25
a25 1
/*	$OpenBSD: alloc.c,v 1.3 1998/06/29 20:06:19 deraadt Exp $	*/
d33 3
a35 106
#ifdef TEST_ALLOC
# define shellf	printf
# ifndef DEBUG_ALLOC
#  define DEBUG_ALLOC
# endif /* DEBUG_ALLOC */
#endif /* TEST_ALLOC */

#ifdef MEM_DEBUG

/*
 * Special versions of alloc routines if doing mem_debug
 */
Area *
_chmem_ainit(ap, file, line)
	Area *ap;
	const char *file;
	int line;
{
	ap->freelist = (struct Block *) _chmem_newpool("ainit", (char *) 0, -1,
						file, line);
	if (!ap->freelist)
	    aerror(ap, "ainit failed (ie, newpool)");
	return ap;
}

/* free all object in Area */
void
_chmem_afreeall(ap, file, line)
	Area *ap;
	const char *file;
	int line;
{
	_chmem_delpool((Chmem_poolp) ap->freelist, 0, file, line);
	/* Kind of ugly, but it works */
	_chmem_ainit(ap, file, line);
}

/* allocate object from Area */
void *
_chmem_alloc(size, ap, file, line)
	size_t size;
	Area *ap;
	const char *file;
	int line;
{
	return _chmem_mallocp((Chmem_poolp) ap->freelist, size, file, line);
}

/* change size of object -- like realloc */
void *
_chmem_aresize(ptr, size, ap, file, line)
	void *ptr;
	size_t size;
	Area *ap;
	const char *file;
	int line;
{
	if (!ptr)
		/* Done as realloc(0, size) is not portable */
		return _chmem_mallocp((Chmem_poolp) ap->freelist, size,
					file, line);
	else
		return _chmem_reallocp((Chmem_poolp) ap->freelist, ptr, size,
					file, line);
}

void
_chmem_afree(ptr, ap, file, line)
	void *ptr;
	Area *ap;
	const char *file;
	int line;
{
	return _chmem_freep((Chmem_poolp) ap->freelist, ptr, file, line);
}

#else /* MEM_DEBUG */

# if DEBUG_ALLOC
void acheck ARGS((Area *ap));
#  define ACHECK(ap)	acheck(ap)
# else /* DEBUG_ALLOC */
#  define ACHECK(ap)
# endif /* DEBUG_ALLOC */

#define	ICELLS	200		/* number of Cells in small Block */

typedef union Cell Cell;
typedef struct Block Block;

/*
 * The Cells in a Block are organized as a set of objects.
 * Each object (pointed to by dp) begins with the block it is in
 * (dp-2)->block, then has a size in (dp-1)->size, which is
 * followed with "size" data Cells.  Free objects are
 * linked together via dp->next.
 */

#define NOBJECT_FIELDS	2	/* the block and size `fields' */

union Cell {
	size_t	size;
	Cell   *next;
	Block  *block;
	struct {int _;} junk;	/* alignment */
	double djunk;		/* alignment */
a37 14
struct Block {
	Block  *next;		/* list of Blocks in Area */
	Block  *prev;		/* previous block in list */
	Cell   *freelist;	/* object free list */
	Cell   *last;		/* &b.cell[size] */
	Cell	cell [1];	/* [size] Cells for allocation */
};

static Block aempty = {&aempty, &aempty, aempty.cell, aempty.cell};

static void ablockfree ARGS((Block *bp, Area *ap));
static void *asplit ARGS((Area *ap, Block *bp, Cell *fp, Cell *fpp, int cells));

/* create empty Area */
d39 1
a39 2
ainit(ap)
	register Area *ap;
d41 1
a41 2
	ap->freelist = &aempty;
	ACHECK(ap);
a44 1
/* free all object in Area */
d46 1
a46 2
afreeall(ap)
	register Area *ap;
d48 1
a48 2
	register Block *bp;
	register Block *tmp;
d50 3
a52 9
	ACHECK(ap);
	bp = ap->freelist;
	if (bp != NULL && bp != &aempty) {
		do {
			tmp = bp;
			bp = bp->next;
			free((void*)tmp);
		} while (bp != ap->freelist);
		ap->freelist = &aempty;
d54 1
a54 1
	ACHECK(ap);
d57 3
a59 1
/* allocate object from Area */
d61 1
a61 3
alloc(size, ap)
	size_t size;
	register Area *ap;
d63 1
a63 55
	int cells, acells;
	Block *bp = 0;
	Cell *fp = 0, *fpp = 0;

	ACHECK(ap);
	if (size <= 0)
		aerror(ap, "allocate bad size");
	cells = (unsigned)(size + sizeof(Cell) - 1) / sizeof(Cell);

	/* allocate at least this many cells */
	acells = cells + NOBJECT_FIELDS;

	/*
	 * Only attempt to track small objects - let malloc deal
	 * with larger objects. (this way we don't have to deal with
	 * coalescing memory, or with releasing it to the system)
	 */
	if (cells <= ICELLS) {
		/* find free Cell large enough */
		for (bp = ap->freelist; ; bp = bp->next) {
			for (fpp = NULL, fp = bp->freelist;
			     fp != bp->last; fpp = fp, fp = fp->next)
			{
				if ((fp-1)->size >= cells)
					goto Found;
			}
			/* wrapped around Block list, create new Block */
			if (bp->next == ap->freelist) {
				bp = 0;
				break;
			}
		}
		/* Not much free space left?  Allocate a big object this time */
		acells += ICELLS;
	}
	if (bp == 0) {
		bp = (Block*) malloc(offsetof(Block, cell[acells]));
		if (bp == NULL)
			aerror(ap, "cannot allocate");
		if (ap->freelist == &aempty) {
			ap->freelist = bp->next = bp->prev = bp;
		} else {
			bp->next = ap->freelist->next;
			ap->freelist->next->prev = bp;
			ap->freelist->next = bp;
			bp->prev = ap->freelist;
		}
		bp->last = bp->cell + acells;
		/* initial free list */
		fp = bp->freelist = bp->cell + NOBJECT_FIELDS;
		(fp-1)->size = acells - NOBJECT_FIELDS;
		(fp-2)->block = bp;
		fp->next = bp->last;
		fpp = NULL;
	}
d65 8
a72 3
  Found:
	return asplit(ap, bp, fp, fpp, cells);
}
d74 1
a74 34
/* Do the work of splitting an object into allocated and (possibly) unallocated
 * objects.  Returns the `allocated' object.
 */
static void *
asplit(ap, bp, fp, fpp, cells)
	Area *ap;
	Block *bp;
	Cell *fp;
	Cell *fpp;
	int cells;
{
	Cell *dp = fp;	/* allocated object */
	int split = (fp-1)->size - cells;

	ACHECK(ap);
	if (split < 0)
		aerror(ap, "allocated object too small");
	if (split <= NOBJECT_FIELDS) {	/* allocate all */
		fp = fp->next;
	} else {		/* allocate head, free tail */
		Cell *next = fp->next; /* needed, as cells may be 0 */
		ap->freelist = bp; /* next time, start looking for space here */
		(fp-1)->size = cells;
		fp += cells + NOBJECT_FIELDS;
		(fp-1)->size = split - NOBJECT_FIELDS;
		(fp-2)->block = bp;
		fp->next = next;
	}
	if (fpp == NULL)
		bp->freelist = fp;
	else
		fpp->next = fp;
	ACHECK(ap);
	return (void*) dp;
a76 1
/* change size of object -- like realloc */
d78 1
a78 4
aresize(ptr, size, ap)
	register void *ptr;
	size_t size;
	Area *ap;
d80 1
a80 58
	int cells;
	Cell *dp = (Cell*) ptr;
	int oldcells = dp ? (dp-1)->size : 0;

	ACHECK(ap);
	if (size <= 0)
		aerror(ap, "allocate bad size");
	/* New size (in cells) */
	cells = (unsigned)(size - 1) / sizeof(Cell) + 1;

	/* Is this a large object?  If so, let malloc deal with it
	 * directly (unless we are crossing the ICELLS border, in
	 * which case the alloc/free below handles it - this should
	 * cut down on fragmentation, and will also keep the code
	 * working (as it assumes size < ICELLS means it is not
	 * a `large object').
	 */
	if (oldcells > ICELLS && cells > ICELLS) {
		Block *bp = (dp-2)->block;
		Block *nbp;
		/* Saved in case realloc fails.. */
		Block *next = bp->next, *prev = bp->prev;

		if (bp->freelist != bp->last)
			aerror(ap, "allocation resizing free pointer");
		nbp = realloc((void *) bp,
			      offsetof(Block, cell[cells + NOBJECT_FIELDS]));
		if (!nbp) {
			/* Have to clean up... */
			/* NOTE: If this code changes, similar changes may be
			 * needed in ablockfree().
			 */
			if (next == bp) /* only block */
				ap->freelist = &aempty;
			else {
				next->prev = prev;
				prev->next = next;
				if (ap->freelist == bp)
					ap->freelist = next;
			}
			aerror(ap, "cannot re-allocate");
		}
		/* If location changed, keep pointers straight... */
		if (nbp != bp) {
			if (next == bp) /* only one block */
				nbp->next = nbp->prev = nbp;
			else {
				next->prev = nbp;
				prev->next = nbp;
			}
			if (ap->freelist == bp)
				ap->freelist = nbp;
			dp = nbp->cell + NOBJECT_FIELDS;
			(dp-2)->block = nbp;
		}
		(dp-1)->size = cells;
		nbp->last = nbp->cell + cells + NOBJECT_FIELDS;
		nbp->freelist = nbp->last;
d82 2
a83 3
		ACHECK(ap);
		return (void*) dp;
	}
d85 3
a87 29
	/* Check if we can just grow this cell
	 * (need to check that cells < ICELLS so we don't make an
	 * object a `large' - that would mess everything up).
	 */
	if (dp && cells > oldcells && cells <= ICELLS) {
		Cell *fp, *fpp;
		Block *bp = (dp-2)->block;
		int need = cells - oldcells - NOBJECT_FIELDS;

		/* XXX if we had a flag in an object indicating
		 * if the object was free/allocated, we could
		 * avoid this loop (perhaps)
		 */
		for (fpp = NULL, fp = bp->freelist;
		     fp != bp->last
		     && dp + oldcells + NOBJECT_FIELDS <= fp
		     ; fpp = fp, fp = fp->next)
		{
			if (dp + oldcells + NOBJECT_FIELDS == fp
			    && (fp-1)->size >= need)
			{
				Cell *np = asplit(ap, bp, fp, fpp, need);
				/* May get more than we need here */
				(dp-1)->size += (np-1)->size + NOBJECT_FIELDS;
				ACHECK(ap);
				return ptr;
			}
		}
	}
d89 8
a96 19
	/* Check if we can just shrink this cell
	 * (if oldcells > ICELLS, this is a large object and we leave
	 * it to malloc...)
	 * Note: this also handles cells == oldcells (a no-op).
	 */
	if (dp && cells <= oldcells && oldcells <= ICELLS) {
		int split;

		split = oldcells - cells;
		if (split <= NOBJECT_FIELDS) /* cannot split */
			;
		else {		/* shrink head, free tail */
			Block *bp = (dp-2)->block;

			(dp-1)->size = cells;
			dp += cells + NOBJECT_FIELDS;
			(dp-1)->size = split - NOBJECT_FIELDS;
			(dp-2)->block = bp;
			afree((void*)dp, ap);
d98 1
a98 15
		/* ACHECK() done in afree() */
		return ptr;
	}

	/* Have to do it the hard way... */
	ptr = alloc(size, ap);
	if (dp != NULL) {
		size_t s = (dp-1)->size * sizeof(Cell);
		if (s > size)
			s = size;
		memcpy(ptr, dp, s);
		afree((void *) dp, ap);
	}
	/* ACHECK() done in alloc()/afree() */
	return ptr;
d102 1
a102 3
afree(ptr, ap)
	void *ptr;
	register Area *ap;
d104 1
a104 16
	register Block *bp;
	register Cell *fp, *fpp;
	register Cell *dp = (Cell*)ptr;

	ACHECK(ap);
	if (ptr == 0)
		aerror(ap, "freeing null pointer");
	bp = (dp-2)->block;

	/* If this is a large object, just free it up... */
	/* Release object... */
	if ((dp-1)->size > ICELLS) {
		ablockfree(bp, ap);
		ACHECK(ap);
		return;
	}
d106 1
a106 70
	if (dp < &bp->cell[NOBJECT_FIELDS] || dp >= bp->last)
		aerror(ap, "freeing memory outside of block (corrupted?)");

	/* find position in free list */
	/* XXX if we had prev/next pointers for objects, this loop could go */
	for (fpp = NULL, fp = bp->freelist; fp < dp; fpp = fp, fp = fp->next)
		;

	if (fp == dp)
		aerror(ap, "freeing free object");

	/* join object with next */
	if (dp + (dp-1)->size == fp-NOBJECT_FIELDS) { /* adjacent */
		(dp-1)->size += (fp-1)->size + NOBJECT_FIELDS;
		dp->next = fp->next;
	} else			/* non-adjacent */
		dp->next = fp;

	/* join previous with object */
	if (fpp == NULL)
		bp->freelist = dp;
	else if (fpp + (fpp-1)->size == dp-NOBJECT_FIELDS) { /* adjacent */
		(fpp-1)->size += (dp-1)->size + NOBJECT_FIELDS;
		fpp->next = dp->next;
	} else			/* non-adjacent */
		fpp->next = dp;

	/* If whole block is free (and we have some other blocks
	 * around), release this block back to the system...
	 */
	if (bp->next != bp && bp->freelist == bp->cell + NOBJECT_FIELDS
	    && bp->freelist + (bp->freelist-1)->size == bp->last
	    /* XXX and the other block has some free memory? */
	    )
		ablockfree(bp, ap);
	ACHECK(ap);
}

static void
ablockfree(bp, ap)
	Block *bp;
	Area *ap;
{
	/* NOTE: If this code changes, similar changes may be
	 * needed in alloc() (where realloc fails).
	 */

	if (bp->next == bp) /* only block */
		ap->freelist = &aempty;
	else {
		bp->next->prev = bp->prev;
		bp->prev->next = bp->next;
		if (ap->freelist == bp)
			ap->freelist = bp->next;
	}
	free((void*) bp);
}

# if DEBUG_ALLOC
void
acheck(ap)
	Area *ap;
{
	Block *bp, *bpp;
	Cell *dp, *dptmp, *fp;
	int ok = 1;
	int isfree;
	static int disabled;

	if (disabled)
d109 1
a109 4
	if (!ap) {
		disabled = 1;
		aerror(ap, "acheck: null area pointer");
	}
d111 6
a116 9
	bp = ap->freelist;
	if (!bp) {
		disabled = 1;
		aerror(ap, "acheck: null area freelist");
	}

	/* Nothing to check... */
	if (bp == &aempty)
		return;
d118 1
a118 257
	bpp = ap->freelist->prev;
	while (1) {
		if (bp->prev != bpp) {
			shellf("acheck: bp->prev != previous\n");
			ok = 0;
		}
		fp = bp->freelist;
		for (dp = &bp->cell[NOBJECT_FIELDS]; dp != bp->last; ) {
			if ((dp-2)->block != bp) {
				shellf("acheck: fragment's block is wrong\n");
				ok = 0;
			}
			isfree = dp == fp;
			if ((dp-1)->size == 0 && isfree) {
				shellf("acheck: 0 size frag\n");
				ok = 0;
			}
			if ((dp-1)->size > ICELLS
			    && !isfree
			    && (dp != &bp->cell[NOBJECT_FIELDS]
				|| dp + (dp-1)->size != bp->last))
			{
				shellf("acheck: big cell doesn't make up whole block\n");
				ok = 0;
			}
			if (isfree) {
				if (dp->next <= dp) {
					shellf("acheck: free fragment's next <= self\n");
					ok = 0;
				}
				if (dp->next > bp->last) {
					shellf("acheck: free fragment's next > last\n");
					ok = 0;
				}
				fp = dp->next;
			}
			dptmp = dp + (dp-1)->size;
			if (dptmp > bp->last) {
				shellf("acheck: next frag out of range\n");
				ok = 0;
				break;
			} else if (dptmp != bp->last) {
				dptmp += NOBJECT_FIELDS;
				if (dptmp > bp->last) {
					shellf("acheck: next frag just out of range\n");
					ok = 0;
					break;
				}
			}
			if (isfree && dptmp == fp && dptmp != bp->last) {
				shellf("acheck: adjacent free frags\n");
				ok = 0;
			} else if (dptmp > fp) {
				shellf("acheck: free frag list messed up\n");
				ok = 0;
			}
			dp = dptmp;
		}
		bpp = bp;
		bp = bp->next;
		if (bp == ap->freelist)
			break;
	}
	if (!ok) {
		disabled = 1;
		aerror(ap, "acheck failed");
	}
}

void
aprint(ap, ptr, size)
	register Area *ap;
	void *ptr;
	size_t size;
{
	Block *bp;

	if (!ap)
		shellf("aprint: null area pointer\n");
	else if (!(bp = ap->freelist))
		shellf("aprint: null area freelist\n");
	else if (bp == &aempty)
		shellf("aprint: area is empty\n");
	else {
		int i;
		Cell *dp, *fp;
		Block *bpp;

		bpp = ap->freelist->prev;
		for (i = 0; ; i++) {
			if (ptr) {
				void *eptr = (void *) (((char *) ptr) + size);
				/* print block only if it overlaps ptr/size */
				if (!((ptr >= (void *) bp
				       && ptr <= (void *) bp->last)
				      || (eptr >= (void *) bp
				         && eptr <= (void *) bp->last)))
					continue;
				shellf("aprint: overlap of 0x%p .. 0x%p\n",
					ptr, eptr);
			}
			if (bp->prev != bpp || bp->next->prev != bp)
				shellf(
	"aprint: BAD prev pointer: bp %p, bp->prev %p, bp->next %p, bpp=%p\n",
					bp, bp->prev, bp->next, bpp);
			shellf("aprint: block %2d (p=%p,%p,n=%p): 0x%p .. 0x%p (%ld)\n", i,
				bp->prev, bp, bp->next,
				bp->cell, bp->last,
				(long) ((char *) bp->last - (char *) bp->cell));
			fp = bp->freelist;
			if (bp->last <= bp->cell + NOBJECT_FIELDS)
				shellf(
			"aprint: BAD bp->last too small: %p <= %p\n",
					bp->last, bp->cell + NOBJECT_FIELDS);
			if (bp->freelist < bp->cell + NOBJECT_FIELDS
			    || bp->freelist > bp->last)
				shellf(
			"aprint: BAD bp->freelist %p out of range: %p .. %p\n",
					bp->freelist,
					bp->cell + NOBJECT_FIELDS, bp->last);
			for (dp = bp->cell; dp != bp->last ; ) {
				dp += NOBJECT_FIELDS;
				shellf(
				    "aprint:   0x%p .. 0x%p (%ld) %s\n",
					(dp-NOBJECT_FIELDS),
					(dp-NOBJECT_FIELDS) + (dp-1)->size
						+ NOBJECT_FIELDS,
					(long) ((dp-1)->size + NOBJECT_FIELDS)
						* sizeof(Cell),
					dp == fp ? "free" : "allocated");
				if ((dp-2)->block != bp)
					shellf(
					"aprint: BAD dp->block %p != bp %p\n",
						(dp-2)->block, bp);
				if (dp > bp->last)
					shellf(
				"aprint: BAD dp gone past block: %p > %p\n",
						dp, bp->last);
				if (dp > fp)
					shellf(
				"aprint: BAD dp gone past free: %p > %p\n",
						dp, fp);
				if (dp == fp) {
					fp = fp->next;
					if (fp < dp || fp > bp->last)
						shellf(
			"aprint: BAD free object %p out of range: %p .. %p\n",
							fp,
							dp, bp->last);
				}
				dp += (dp-1)->size;
			}
			bpp = bp;
			bp = bp->next;
			if (bp == ap->freelist)
				break;
		}
	}
}
# endif /* DEBUG_ALLOC */

# ifdef TEST_ALLOC

Area a;
FILE *myout;

int
main(int argc, char **argv)
{
	char buf[1024];
	struct info {
		int size;
		void *value;
	};
	struct info info[1024 * 2];
	int size, ident;
	int lineno = 0;

	myout = stdout;
	ainit(&a);
	while (fgets(buf, sizeof(buf), stdin)) {
		lineno++;
		if (buf[0] == '\n' || buf[0] == '#')
			continue;
		if (sscanf(buf, " alloc %d = i%d", &size, &ident) == 2) {
			if (ident < 0 || ident > NELEM(info)) {
				fprintf(stderr, "bad ident (%d) on line %d\n",
					ident, lineno);
				exit(1);
			}
			info[ident].value = alloc(info[ident].size = size, &a);
			printf("%p = alloc(%d) [%d,i%d]\n", 
				info[ident].value, info[ident].size,
				lineno, ident);
			memset(info[ident].value, 1, size);
			continue;
		}
		if (sscanf(buf, " afree i%d", &ident) == 1) {
			if (ident < 0 || ident > NELEM(info)) {
				fprintf(stderr, "bad ident (%d) on line %d\n",
					ident, lineno);
				exit(1);
			}
			afree(info[ident].value, &a);
			printf("afree(%p) [%d,i%d]\n", info[ident].value,
				lineno, ident);
			continue;
		}
		if (sscanf(buf, " aresize i%d , %d", &ident, &size) == 2) {
			void *value;
			if (ident < 0 || ident > NELEM(info)) {
				fprintf(stderr, "bad ident (%d) on line %d\n",
					ident, lineno);
				exit(1);
			}
			value = info[ident].value;
			info[ident].value = aresize(value,
						    info[ident].size = size,
						    &a);
			printf("%p = aresize(%p, %d) [%d,i%d]\n", 
				info[ident].value, value, info[ident].size,
				lineno, ident);
			memset(info[ident].value, 1, size);
			continue;
		}
		if (sscanf(buf, " aprint i%d , %d", &ident, &size) == 2) {
			if (ident < 0 || ident > NELEM(info)) {
				fprintf(stderr, "bad ident (%d) on line %d\n",
					ident, lineno);
				exit(1);
			}
			printf("aprint(%p, %d) [%d,i%d]\n",
				info[ident].value, size, lineno, ident);
			aprint(&a, info[ident].value, size);
			continue;
		}
		if (sscanf(buf, " aprint %d", &ident) == 1) {
			if (ident < 0 || ident > NELEM(info)) {
				fprintf(stderr, "bad ident (%d) on line %d\n",
					ident, lineno);
				exit(1);
			}
			printf("aprint(0, 0) [%d]\n", lineno);
			aprint(&a, 0, 0);
			continue;
		}
		if (sscanf(buf, " afreeall %d", &ident) == 1) {
			printf("afreeall() [%d]\n", lineno);
			afreeall(&a);
			memset(info, 0, sizeof(info));
			continue;
		}
		fprintf(stderr, "unrecognized line (line %d)\n",
			lineno);
		exit(1);
	}
	return 0;
a119 12

void
aerror(Area *ap, const char *msg)
{
	printf("aerror: %s\n", msg);
	fflush(stdout);
	abort();
}

# endif /* TEST_ALLOC */

#endif /* MEM_DEBUG */
@


1.3
log
@overflow fix; michael@@cs.mun.ca
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.2 1998/06/25 19:01:43 millert Exp $	*/
d174 1
a174 1
	cells = (unsigned)(size - 1) / sizeof(Cell) + 1;
@


1.2
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc.c,v 1.1.1.1 1996/08/14 06:19:10 downsj Exp $	*/
d393 1
a393 1
		memcpy(ptr, dp, size);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d8 8
a16 4
# undef alloc
# undef aresize
# undef afree
#endif /* MEM_DEBUG */
d18 77
a94 1
#define	ICELLS	100		/* number of Cells in small Block */
d101 2
a102 1
 * Each object (pointed to by dp) begins with a size in (dp-1)->size,
d107 2
d112 1
d114 1
d119 1
d125 4
a128 1
static Block aempty = {&aempty, aempty.cell, aempty.cell};
d136 1
d148 1
d152 3
a154 3
			tmp = bp->next;
			free((void*)bp);
			bp = tmp;
d158 1
d167 3
a169 3
	int cells, split;
	register Block *bp;
	register Cell *dp, *fp, *fpp;
d171 2
a172 1
	if (size <= 0) {
a173 2
		return NULL;
	}
d176 16
a191 14
	/* find Cell large enough */
	for (bp = ap->freelist; ; bp = bp->next) {
		for (fpp = NULL, fp = bp->freelist;
		     fp != bp->last; fpp = fp, fp = fpp->next)
			if ((fp-1)->size >= cells)
				goto Found;

		/* wrapped around Block list, create new Block */
		if (bp->next == ap->freelist) {
			bp = (Block*) malloc(offsetof(Block, cell[ICELLS])
					     + sizeof(bp->cell[0]) * cells);
			if (bp == NULL) {
				aerror(ap, "cannot allocate");
				return NULL;
d193 4
a196 5
			if (ap->freelist == &aempty)
				bp->next = bp;
			else {
				bp->next = ap->freelist->next;
				ap->freelist->next = bp;
a197 6
			bp->last = bp->cell + ICELLS + cells;
			fp = bp->freelist = bp->cell + 1; /* initial free list */
			(fp-1)->size = ICELLS + cells - 1;
			fp->next = bp->last;
			fpp = NULL;
			break;
d199 22
d222 1
d224 18
a241 3
	ap->freelist = bp;
	dp = fp;		/* allocated object */
	split = (dp-1)->size - cells;
d244 1
a244 1
	if (--split <= 0) {	/* allocate all */
d247 2
d250 4
a253 3
		fp += cells + 1;
		(fp-1)->size = split;
		fp->next = dp->next;
d259 1
d271 2
a272 1
	register Cell *dp = (Cell*) ptr;
d274 2
a275 1
	if (size <= 0) {
d277 54
a330 1
		return NULL;
a331 1
	cells = (unsigned)(size - 1) / sizeof(Cell) + 1;
d333 27
a359 6
	if (dp == NULL || (dp-1)->size < cells) { /* enlarge object */
		/* XXX check for available adjacent free block */
		ptr = alloc(size, ap);
		if (dp != NULL) {
			memcpy(ptr, dp, (dp-1)->size * sizeof(Cell));
			afree((void *) dp, ap);
d361 8
a368 1
	} else {		/* shrink object */
d371 2
a372 2
		split = (dp-1)->size - cells;
		if (--split <= 0) /* cannot split */
d375 2
d378 3
a380 2
			dp += cells + 1;
			(dp-1)->size = split;
d383 2
d386 12
a397 1
	return (void*) ptr;
d409 11
a419 8
	/* find Block containing Cell */
	for (bp = ap->freelist; ; bp = bp->next) {
		if (bp->cell <= dp && dp < bp->last)
			break;
		if (bp->next == ap->freelist) {
			aerror(ap, "freeing with invalid area");
			return;
		}
d422 3
d426 2
a427 1
	for (fpp = NULL, fp = bp->freelist; fp < dp; fpp = fp, fp = fpp->next)
d430 1
a430 1
	if (fp == dp) {
a431 2
		return;
	}
d434 2
a435 2
	if (dp + (dp-1)->size == fp-1) { /* adjacent */
		(dp-1)->size += (fp-1)->size + 1;
d443 2
a444 2
	else if (fpp + (fpp-1)->size == dp-1) { /* adjacent */
		(fpp-1)->size += (dp-1)->size + 1;
d448 128
a577 1
#if DEBUG_ALLOC
d594 2
a595 1
		Cell *fp;
d597 2
a598 1
		for (i = 0; !i || bp != ap->freelist; bp = bp->next, i++) {
d610 6
a615 1
			shellf("aprint: block %2d: 0x%p .. 0x%p (%d)\n", i,
d617 3
a619 2
				(char *) bp->last - (char *) bp->cell);
			for (fp = bp->freelist; fp != bp->last; fp = fp->next)
d621 44
a664 3
				    "aprint:   0x%p .. 0x%p (%d) free\n",
					(fp-1), (fp-1) + (fp-1)->size,
					(fp-1)->size * sizeof(Cell));
d668 1
a668 1
#endif /* DEBUG_ALLOC */
d670 1
a670 2

#ifdef TEST_ALLOC
d673 1
d675 11
a685 3
main(int argc, char **argv) {
	int i;
	char *p [9];
d687 1
d689 76
a764 7
	for (i = 0; i < 9; i++) {
		p[i] = alloc(124, &a);
		printf("alloc: %x\n", p[i]);
	}
	for (i = 1; i < argc; i++)
		afree(p[atoi(argv[i])], &a);
	afreeall(&a);
d768 5
a772 1
void aerror(Area *ap, const char *msg) {
d776 1
a776 1
#endif
d778 1
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
