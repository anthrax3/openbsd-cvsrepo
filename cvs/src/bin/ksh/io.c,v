head	1.35;
access;
symbols
	OPENBSD_6_2:1.35.0.8
	OPENBSD_6_2_BASE:1.35
	OPENBSD_6_1:1.35.0.6
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.35.0.2
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.30
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.28
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.26
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.24
	OPENBSD_5_0:1.22.0.22
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.20
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.18
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.14
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.16
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.12
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.10
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.8
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.6
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.21.0.4
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.4
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2016.03.20.00.01.21;	author krw;	state Exp;
branches;
next	1.34;
commitid	vrVXbedfAlzCTHmf;

1.34
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.33;
commitid	btTCreDA00YdaFhU;

1.33
date	2015.11.07.20.48.28;	author mmcc;	state Exp;
branches;
next	1.32;
commitid	LNpDH2JXvGGJYld5;

1.32
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.31;
commitid	C4W85jmosThChWA2;

1.31
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.30;
commitid	16HUr75moyUNtKR8;

1.30
date	2015.09.22.21.50.40;	author millert;	state Exp;
branches;
next	1.29;
commitid	ZWmS69dzJnkF6rox;

1.29
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.28;
commitid	7fgq4YTZG4xZ0uN0;

1.28
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.27;
commitid	v5QjoxUgKU2iUTFz;

1.27
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.26;
commitid	lBs9un9sXhbdfVrQ;

1.26
date	2015.09.11.08.00.27;	author guenther;	state Exp;
branches;
next	1.25;
commitid	EkxJZcbLJnmogseY;

1.25
date	2014.08.11.20.28.47;	author guenther;	state Exp;
branches;
next	1.24;
commitid	MfDVoJ2BsbJhkpRj;

1.24
date	2014.08.10.02.44.26;	author guenther;	state Exp;
branches;
next	1.23;
commitid	SIExam23nZ4vUfMf;

1.23
date	2013.12.17.16.37.06;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.17.16.30.13;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.30.21.34.24;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.18.22.35.41;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.18.21.04.52;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.10.21.26.39;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.10.03.48.16;	author david;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.19.10.58.07;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.20.22.14.32;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.06.15.01.18.34;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.01.10.17.55.02;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.01.08.20.24.59;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.06.25.19.02.00;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.06.19.13.58.42;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.06.18.22.42.36;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.51;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Currently we have about a 50/50 split over fcntl(n, F_GETFL [,0])
idioms.

Adopt the more concise fcntl(n, F_GETFL) over fcntl(n, F_GETFL, 0)
where it is obvious further investigation will not yield and
even better way.

Obviousness evaluation and ok guenther@@
@
text
@/*	$OpenBSD: io.c,v 1.34 2015/12/14 13:59:42 tb Exp $	*/

/*
 * shell buffered IO and formatted output
 */

#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>

#include "sh.h"

static int initio_done;

/*
 * formatted output functions
 */


/* A shell error occurred (eg, syntax error, etc.) */
void
errorf(const char *fmt, ...)
{
	va_list va;

	shl_stdout_ok = 0;	/* debugging: note that stdout not valid */
	exstat = 1;
	if (fmt != NULL && *fmt != '\0') {
		error_prefix(true);
		va_start(va, fmt);
		shf_vfprintf(shl_out, fmt, va);
		va_end(va);
		shf_putchar('\n', shl_out);
	}
	shf_flush(shl_out);
	unwind(LERROR);
}

/* like errorf(), but no unwind is done */
void
warningf(bool show_lineno, const char *fmt, ...)
{
	va_list va;

	error_prefix(show_lineno);
	va_start(va, fmt);
	shf_vfprintf(shl_out, fmt, va);
	va_end(va);
	shf_putchar('\n', shl_out);
	shf_flush(shl_out);
}

/* Used by built-in utilities to prefix shell and utility name to message
 * (also unwinds environments for special builtins).
 */
void
bi_errorf(const char *fmt, ...)
{
	va_list va;

	shl_stdout_ok = 0;	/* debugging: note that stdout not valid */
	exstat = 1;
	if (fmt != NULL && *fmt != '\0') {
		error_prefix(true);
		/* not set when main() calls parse_args() */
		if (builtin_argv0)
			shf_fprintf(shl_out, "%s: ", builtin_argv0);
		va_start(va, fmt);
		shf_vfprintf(shl_out, fmt, va);
		va_end(va);
		shf_putchar('\n', shl_out);
	}
	shf_flush(shl_out);
	/* POSIX special builtins and ksh special builtins cause
	 * non-interactive shells to exit.
	 * XXX odd use of KEEPASN; also may not want LERROR here
	 */
	if ((builtin_flag & SPEC_BI) ||
	    (Flag(FPOSIX) && (builtin_flag & KEEPASN))) {
		builtin_argv0 = NULL;
		unwind(LERROR);
	}
}

/* Called when something that shouldn't happen does */
void
internal_errorf(int jump, const char *fmt, ...)
{
	va_list va;

	error_prefix(true);
	shf_fprintf(shl_out, "internal error: ");
	va_start(va, fmt);
	shf_vfprintf(shl_out, fmt, va);
	va_end(va);
	shf_putchar('\n', shl_out);
	shf_flush(shl_out);
	if (jump)
		unwind(LERROR);
}

/* used by error reporting functions to print "ksh: .kshrc[25]: " */
void
error_prefix(int fileline)
{
	/* Avoid foo: foo[2]: ... */
	if (!fileline || !source || !source->file ||
	    strcmp(source->file, kshname) != 0)
		shf_fprintf(shl_out, "%s: ", kshname + (*kshname == '-'));
	if (fileline && source && source->file != NULL) {
		shf_fprintf(shl_out, "%s[%d]: ", source->file,
		    source->errline > 0 ? source->errline : source->line);
		source->errline = 0;
	}
}

/* printf to shl_out (stderr) with flush */
void
shellf(const char *fmt, ...)
{
	va_list va;

	if (!initio_done) /* shl_out may not be set up yet... */
		return;
	va_start(va, fmt);
	shf_vfprintf(shl_out, fmt, va);
	va_end(va);
	shf_flush(shl_out);
}

/* printf to shl_stdout (stdout) */
void
shprintf(const char *fmt, ...)
{
	va_list va;

	if (!shl_stdout_ok)
		internal_errorf(1, "shl_stdout not valid");
	va_start(va, fmt);
	shf_vfprintf(shl_stdout, fmt, va);
	va_end(va);
}

#ifdef KSH_DEBUG
static struct shf *kshdebug_shf;

void
kshdebug_init_(void)
{
	if (kshdebug_shf)
		shf_close(kshdebug_shf);
	kshdebug_shf = shf_open("/tmp/ksh-debug.log",
	    O_WRONLY|O_APPEND|O_CREAT, 0600, SHF_WR|SHF_MAPHI);
	if (kshdebug_shf) {
		shf_fprintf(kshdebug_shf, "\nNew shell[pid %d]\n", getpid());
		shf_flush(kshdebug_shf);
	}
}

/* print to debugging log */
void
kshdebug_printf_(const char *fmt, ...)
{
	va_list va;

	if (!kshdebug_shf)
		return;
	va_start(va, fmt);
	shf_fprintf(kshdebug_shf, "[%d] ", getpid());
	shf_vfprintf(kshdebug_shf, fmt, va);
	va_end(va);
	shf_flush(kshdebug_shf);
}

void
kshdebug_dump_(const char *str, const void *mem, int nbytes)
{
	int i, j;
	int nprow = 16;

	if (!kshdebug_shf)
		return;
	shf_fprintf(kshdebug_shf, "[%d] %s:\n", getpid(), str);
	for (i = 0; i < nbytes; i += nprow) {
		char c = '\t';

		for (j = 0; j < nprow && i + j < nbytes; j++) {
			shf_fprintf(kshdebug_shf, "%c%02x", c,
			    ((const unsigned char *) mem)[i + j]);
			c = ' ';
		}
		shf_fprintf(kshdebug_shf, "\n");
	}
	shf_flush(kshdebug_shf);
}
#endif /* KSH_DEBUG */

/* test if we can seek backwards fd (returns 0 or SHF_UNBUF) */
int
can_seek(int fd)
{
	struct stat statb;

	return fstat(fd, &statb) == 0 && !S_ISREG(statb.st_mode) ?
	    SHF_UNBUF : 0;
}

struct shf	shf_iob[3];

void
initio(void)
{
	shf_fdopen(1, SHF_WR, shl_stdout);	/* force buffer allocation */
	shf_fdopen(2, SHF_WR, shl_out);
	shf_fdopen(2, SHF_WR, shl_spare);	/* force buffer allocation */
	initio_done = 1;
	kshdebug_init();
}

/* A dup2() with error checking */
int
ksh_dup2(int ofd, int nfd, int errok)
{
	int ret = dup2(ofd, nfd);

	if (ret < 0 && errno != EBADF && !errok)
		errorf("too many files open in shell");

	return ret;
}

/*
 * move fd from user space (0<=fd<10) to shell space (fd>=10),
 * set close-on-exec flag.
 */
int
savefd(int fd)
{
	int nfd;

	if (fd < FDBASE) {
		nfd = fcntl(fd, F_DUPFD_CLOEXEC, FDBASE);
		if (nfd < 0) {
			if (errno == EBADF)
				return -1;
			else
				errorf("too many files open in shell");
		}
	} else {
		nfd = fd;
		fcntl(nfd, F_SETFD, FD_CLOEXEC);
	}
	return nfd;
}

void
restfd(int fd, int ofd)
{
	if (fd == 2)
		shf_flush(&shf_iob[fd]);
	if (ofd < 0)		/* original fd closed */
		close(fd);
	else if (fd != ofd) {
		ksh_dup2(ofd, fd, true); /* XXX: what to do if this fails? */
		close(ofd);
	}
}

void
openpipe(int *pv)
{
	int lpv[2];

	if (pipe(lpv) < 0)
		errorf("can't create pipe - try again");
	pv[0] = savefd(lpv[0]);
	if (pv[0] != lpv[0])
		close(lpv[0]);
	pv[1] = savefd(lpv[1]);
	if (pv[1] != lpv[1])
		close(lpv[1]);
}

void
closepipe(int *pv)
{
	close(pv[0]);
	close(pv[1]);
}

/* Called by iosetup() (deals with 2>&4, etc.), c_read, c_print to turn
 * a string (the X in 2>&X, read -uX, print -uX) into a file descriptor.
 */
int
check_fd(char *name, int mode, const char **emsgp)
{
	int fd, fl;

	if (isdigit((unsigned char)name[0]) && !name[1]) {
		fd = name[0] - '0';
		if ((fl = fcntl(fd, F_GETFL)) < 0) {
			if (emsgp)
				*emsgp = "bad file descriptor";
			return -1;
		}
		fl &= O_ACCMODE;
		/* X_OK is a kludge to disable this check for dups (x<&1):
		 * historical shells never did this check (XXX don't know what
		 * posix has to say).
		 */
		if (!(mode & X_OK) && fl != O_RDWR &&
		    (((mode & R_OK) && fl != O_RDONLY) ||
		    ((mode & W_OK) && fl != O_WRONLY))) {
			if (emsgp)
				*emsgp = (fl == O_WRONLY) ?
				    "fd not open for reading" :
				    "fd not open for writing";
			return -1;
		}
		return fd;
	} else if (name[0] == 'p' && !name[1])
		return coproc_getfd(mode, emsgp);
	if (emsgp)
		*emsgp = "illegal file descriptor name";
	return -1;
}

/* Called once from main */
void
coproc_init(void)
{
	coproc.read = coproc.readw = coproc.write = -1;
	coproc.njobs = 0;
	coproc.id = 0;
}

/* Called by c_read() when eof is read - close fd if it is the co-process fd */
void
coproc_read_close(int fd)
{
	if (coproc.read >= 0 && fd == coproc.read) {
		coproc_readw_close(fd);
		close(coproc.read);
		coproc.read = -1;
	}
}

/* Called by c_read() and by iosetup() to close the other side of the
 * read pipe, so reads will actually terminate.
 */
void
coproc_readw_close(int fd)
{
	if (coproc.readw >= 0 && coproc.read >= 0 && fd == coproc.read) {
		close(coproc.readw);
		coproc.readw = -1;
	}
}

/* Called by c_print when a write to a fd fails with EPIPE and by iosetup
 * when co-process input is dup'd
 */
void
coproc_write_close(int fd)
{
	if (coproc.write >= 0 && fd == coproc.write) {
		close(coproc.write);
		coproc.write = -1;
	}
}

/* Called to check for existence of/value of the co-process file descriptor.
 * (Used by check_fd() and by c_read/c_print to deal with -p option).
 */
int
coproc_getfd(int mode, const char **emsgp)
{
	int fd = (mode & R_OK) ? coproc.read : coproc.write;

	if (fd >= 0)
		return fd;
	if (emsgp)
		*emsgp = "no coprocess";
	return -1;
}

/* called to close file descriptors related to the coprocess (if any)
 * Should be called with SIGCHLD blocked.
 */
void
coproc_cleanup(int reuse)
{
	/* This to allow co-processes to share output pipe */
	if (!reuse || coproc.readw < 0 || coproc.read < 0) {
		if (coproc.read >= 0) {
			close(coproc.read);
			coproc.read = -1;
		}
		if (coproc.readw >= 0) {
			close(coproc.readw);
			coproc.readw = -1;
		}
	}
	if (coproc.write >= 0) {
		close(coproc.write);
		coproc.write = -1;
	}
}


/*
 * temporary files
 */

struct temp *
maketemp(Area *ap, Temp_type type, struct temp **tlist)
{
	struct temp *tp;
	int len;
	int fd;
	char *path;
	const char *dir;

	dir = tmpdir ? tmpdir : "/tmp";
	/* The 20 + 20 is a paranoid worst case for pid/inc */
	len = strlen(dir) + 3 + 20 + 20 + 1;
	tp = alloc(sizeof(struct temp) + len, ap);
	tp->name = path = (char *) &tp[1];
	tp->shf = NULL;
	tp->type = type;
	shf_snprintf(path, len, "%s/shXXXXXXXX", dir);
	fd = mkstemp(path);
	if (fd >= 0)
		tp->shf = shf_fdopen(fd, SHF_WR, NULL);
	tp->pid = procpid;

	tp->next = *tlist;
	*tlist = tp;
	return tp;
}
@


1.34
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.33 2015/11/07 20:48:28 mmcc Exp $	*/
d305 1
a305 1
		if ((fl = fcntl(fd, F_GETFL, 0)) < 0) {
@


1.33
log
@Make it clearer that warningf()'s first argument determines whether the
lineno is printed.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.32 2015/10/19 14:42:16 mmcc Exp $	*/
d10 2
d13 1
@


1.32
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.31 2015/10/19 02:15:45 mmcc Exp $	*/
d42 1
a42 1
warningf(int fileline, const char *fmt, ...)
d46 1
a46 1
	error_prefix(fileline);
@


1.31
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.30 2015/09/22 21:50:40 millert Exp $	*/
d10 1
@


1.30
log
@Make errorf() and bi_errorf() handle a NULL argument.
From Michael McConville; OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.29 2015/09/18 07:28:24 nicm Exp $	*/
d7 2
d10 1
a11 1
#include <sys/stat.h>
@


1.29
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.28 2015/09/17 14:21:33 nicm Exp $	*/
d26 1
a26 1
	if (*fmt) {
d61 1
a61 1
	if (*fmt) {
@


1.28
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.27 2015/09/15 18:15:05 tedu Exp $	*/
d427 1
a427 1
	tp->shf = (struct shf *) 0;
d432 1
a432 1
		tp->shf = shf_fdopen(fd, SHF_WR, (struct shf *) 0);
@


1.27
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.26 2015/09/11 08:00:27 guenther Exp $	*/
d425 1
a425 1
	tp = (struct temp *) alloc(sizeof(struct temp) + len, ap);
@


1.26
log
@Remove redundant assignment

from Michael McConville (mmcconv1 (at) sccs.swarthmore.edu)
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.25 2014/08/11 20:28:47 guenther Exp $	*/
d78 1
a78 1
		builtin_argv0 = (char *) 0;
@


1.25
log
@Still need to separately set FD_CLOEXEC if the new fd was >= FDBASE.
Affects scripts that directly use 9 of the first 10 fds.

noted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.24 2014/08/10 02:44:26 guenther Exp $	*/
d299 1
a299 1
		if ((fl = fcntl(fd = name[0] - '0', F_GETFL, 0)) < 0) {
@


1.24
log
@Replace F_DUPFD followed by setting FD_CLOEXEC with just F_DUPFD_CLOEXEC

ok matthew@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.23 2013/12/17 16:37:06 deraadt Exp $	*/
d247 1
a247 1
	} else
d249 2
@


1.23
log
@ctype cleanups.  Repeated re-audits of this sensitive area by okan and
myself, with a variety of other people spending some time as well.
Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.22 2006/03/17 16:30:13 millert Exp $	*/
d240 1
a240 1
		nfd = fcntl(fd, F_DUPFD, FDBASE);
a248 1
	fcntl(nfd, F_SETFD, FD_CLOEXEC);
@


1.22
log
@Simplify savefd() by removing the "noclose" flag and make noclose
behavior the default.  Almost all uses of savefd() are followed
by an implicit or explicit close.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.21 2005/03/30 17:16:37 deraadt Exp $	*/
d296 1
a296 1
	if (isdigit(name[0]) && !name[1]) {
@


1.21
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.20 2004/12/30 21:34:24 otto Exp $	*/
d235 1
a235 1
savefd(int fd, int noclose)
a246 2
		if (!noclose)
			close(fd);
d269 3
a271 1
	if (pipe(pv) < 0)
d273 6
a278 2
	pv[0] = savefd(pv[0], 0);
	pv[1] = savefd(pv[1], 0);
@


1.20
log
@Remove -Wno-unused form CFLAGS and kill some unused vars found as a result of
that. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.19 2004/12/22 17:14:34 millert Exp $	*/
d76 2
a77 3
	if ((builtin_flag & SPEC_BI)
	    || (Flag(FPOSIX) && (builtin_flag & KEEPASN)))
	{
d105 2
a106 2
	if (!fileline || !source || !source->file
	    || strcmp(source->file, kshname) != 0)
d110 1
a110 1
			source->errline > 0 ? source->errline : source->line);
d151 1
a151 2
				O_WRONLY|O_APPEND|O_CREAT, 0600,
				SHF_WR|SHF_MAPHI);
d184 1
d186 2
a187 2
			shf_fprintf(kshdebug_shf, "%c%02x",
				c, ((const unsigned char *) mem)[i + j]);
d203 1
a203 1
		SHF_UNBUF : 0;
d304 3
a306 4
		if (!(mode & X_OK) && fl != O_RDWR
		    && (((mode & R_OK) && fl != O_RDONLY)
			|| ((mode & W_OK) && fl != O_WRONLY)))
		{
d309 2
a310 2
						"fd not open for reading"
					      : "fd not open for writing";
a431 1

@


1.19
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.18 2004/12/20 11:34:26 otto Exp $	*/
a412 1
	static unsigned int inc;
@


1.18
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.17 2004/12/18 22:35:41 millert Exp $	*/
d27 1
a27 1
		error_prefix(TRUE);
d62 1
a62 1
		error_prefix(TRUE);
d90 1
a90 1
	error_prefix(TRUE);
d264 1
a264 1
		ksh_dup2(ofd, fd, TRUE); /* XXX: what to do if this fails? */
@


1.17
log
@Replace fd_clexec() with calls to fcntl(fd, F_SETFD, FD_CLOEXEC)
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.16 2004/12/18 21:25:44 millert Exp $	*/
d103 1
a103 2
error_prefix(fileline)
	int fileline;
d147 1
a147 1
kshdebug_init_()
d176 1
a176 4
kshdebug_dump_(str, mem, nbytes)
	const char *str;
	const void *mem;
	int nbytes;
d199 1
a199 2
can_seek(fd)
	int fd;
d210 1
a210 1
initio()
d221 1
a221 4
ksh_dup2(ofd, nfd, errok)
	int ofd;
	int nfd;
	int errok;
d236 1
a236 3
savefd(fd, noclose)
	int fd;
	int noclose;
d257 1
a257 2
restfd(fd, ofd)
	int fd, ofd;
d270 1
a270 2
openpipe(pv)
	int *pv;
d279 1
a279 2
closepipe(pv)
	int *pv;
d289 1
a289 4
check_fd(name, mode, emsgp)
	char *name;
	int mode;
	const char **emsgp;
d325 1
a325 1
coproc_init()
d334 1
a334 2
coproc_read_close(fd)
	int fd;
d347 1
a347 2
coproc_readw_close(fd)
	int fd;
d359 1
a359 2
coproc_write_close(fd)
	int fd;
d371 1
a371 3
coproc_getfd(mode, emsgp)
	int mode;
	const char **emsgp;
d386 1
a386 2
coproc_cleanup(reuse)
	int reuse;
d411 1
a411 4
maketemp(ap, type, tlist)
	Area *ap;
	Temp_type type;
	struct temp **tlist;
@


1.16
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.15 2004/12/18 21:04:52 millert Exp $	*/
d262 1
a262 1
	fd_clexec(nfd);
@


1.15
log
@Get rid of #ifdef KSH since we don't care about building a V7 style sh and
the #ifdef KSH code is required to make a POSIX sh.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.14 2004/12/18 20:55:52 millert Exp $	*/
d282 1
a282 1
	register int *pv;
d292 1
a292 1
	register int *pv;
@


1.14
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.13 2003/11/10 21:26:39 millert Exp $	*/
d332 1
a332 3
	}
#ifdef KSH
	else if (name[0] == 'p' && !name[1])
a333 1
#endif /* KSH */
a338 1
#ifdef KSH
a425 1
#endif /* KSH */
@


1.13
log
@If "from fd" == "to fd" don't call dup2() or close "from fd".
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.12 2003/03/10 03:48:16 david Exp $	*/
d9 1
a9 1
#include "ksh_stat.h"
a19 1
#ifdef HAVE_PROTOTYPES
a20 5
#else
errorf(fmt, va_alist)
	const char *fmt;
	va_dcl
#endif
d28 1
a28 1
		SH_VA_START(va, fmt);
a38 1
#ifdef HAVE_PROTOTYPES
a39 6
#else
warningf(fileline, fmt, va_alist)
	int fileline;
	const char *fmt;
	va_dcl
#endif
d44 1
a44 1
	SH_VA_START(va, fmt);
a54 1
#ifdef HAVE_PROTOTYPES
a55 5
#else
bi_errorf(fmt, va_alist)
	const char *fmt;
	va_dcl
#endif
d66 1
a66 1
		SH_VA_START(va, fmt);
a85 1
#ifdef HAVE_PROTOTYPES
a86 6
#else
internal_errorf(jump, fmt, va_alist)
	int jump;
	const char *fmt;
	va_dcl
#endif
d92 1
a92 1
	SH_VA_START(va, fmt);
a118 1
#ifdef HAVE_PROTOTYPES
a119 5
#else
shellf(fmt, va_alist)
	const char *fmt;
	va_dcl
#endif
d125 1
a125 1
	SH_VA_START(va, fmt);
a132 1
#ifdef HAVE_PROTOTYPES
a133 5
#else
shprintf(fmt, va_alist)
	const char *fmt;
	va_dcl
#endif
d139 1
a139 1
	SH_VA_START(va, fmt);
a162 1
# ifdef HAVE_PROTOTYPES
a163 5
# else
kshdebug_printf_(fmt, va_alist)
	const char *fmt;
	va_dcl
# endif
d169 1
a169 1
	SH_VA_START(va, fmt);
a235 6
#ifdef DUP2_BROKEN
	/* Ultrix systems like to preserve the close-on-exec flag */
	if (ret >= 0)
		(void) fcntl(nfd, F_SETFD, 0);
#endif /* DUP2_BROKEN */

d251 1
a251 1
		nfd = ksh_dupbase(fd, FDBASE);
a316 14
#ifdef OS2
		if (mode == W_OK ) {
		       if (setmode(fd, O_TEXT) == -1) {
				if (emsgp)
					*emsgp = "couldn't set write mode";
				return -1;
			}
		 } else if (mode == R_OK)
	      		if (setmode(fd, O_BINARY) == -1) {
				if (emsgp)
					*emsgp = "couldn't set read mode";
				return -1;
			}
#else /* OS2 */
a330 1
#endif /* OS2 */
a456 1
#ifdef __OpenBSD__
a460 27
#else
	while (1) {
		/* Note that temp files need to fit 8.3 DOS limits */
		shf_snprintf(path, len, "%s/sh%05u.%03x",
			     dir, (unsigned) procpid, inc++);
		/* Mode 0600 to be paranoid, O_TRUNC in case O_EXCL isn't
		 * really there.
		 */
		fd = open(path, O_RDWR|O_CREAT|O_EXCL|O_TRUNC, 0600);
		if (fd >= 0) {
			tp->shf = shf_fdopen(fd, SHF_WR, (struct shf *) 0);
			break;
		}
		if (errno != EINTR
#ifdef EEXIST
		    && errno != EEXIST
#endif /* EEXIST */
#ifdef EISDIR
		    && errno != EISDIR
#endif /* EISDIR */
			)
			/* Error must be printed by caller: don't know here if
			 * errorf() or bi_errorf() should be used.
			 */
			break;
	}
#endif /* __OpenBSD__ */
@


1.12
log
@spelling fixes
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.11 2002/06/09 05:47:27 todd Exp $	*/
d324 1
a324 1
	else {
@


1.11
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.10 2001/09/19 10:58:07 mpech Exp $	*/
d455 1
a455 1
/* Called to check for existance of/value of the co-process file descriptor.
@


1.10
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok

p.s. Next commit will fix a typo in the sys/
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.9 2000/08/20 22:14:32 millert Exp $	*/
d368 1
a368 1
		if (mode == W_OK ) { 
d378 1
a378 1
				return -1; 
@


1.9
log
@Use mkstemp(), ryker@@ryker.org
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.8 1999/06/15 01:18:34 millert Exp $	*/
d18 1
a18 1
/* A shell error occured (eg, syntax error, etc.) */
@


1.8
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.7 1999/01/10 17:55:02 millert Exp $	*/
d522 6
d553 1
a553 1
	tp->next = NULL;
@


1.7
log
@sync with pdksh-unstable-5.2.13.6
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.6 1999/01/08 20:24:59 millert Exp $	*/
d497 1
d503 1
a503 1
maketemp(ap)
d505 2
d513 1
a513 1
	const char *tmp;
d515 1
a515 1
	tmp = tmpdir ? tmpdir : "/tmp";
d517 1
a517 1
	len = strlen(tmp) + 3 + 20 + 20 + 1;
d521 1
d525 1
a525 1
			tmp, (unsigned) procpid, inc++);
d542 1
a542 1
			/* Error must be printed by called: don't know here if
d549 4
@


1.6
log
@bug fixes from pdksh-unstable-5.2.13.5; some of which we already had.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.5 1998/06/25 19:02:00 millert Exp $	*/
d302 1
a302 1
		if (nfd < 0)
d307 1
@


1.5
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.4 1997/06/19 13:58:42 kstailey Exp $	*/
d182 63
d265 1
@


1.4
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.2 1996/08/19 20:08:51 downsj Exp $	*/
d11 2
d132 4
a135 1
	shf_fprintf(shl_out, "%s: ", kshname + (*kshname == '-'));
d155 2
d201 1
@


1.3
log
@(foo *)0 -> NULL
@
text
@d96 1
a96 1
		builtin_argv0 = NULL;
d444 1
a444 1
	tp->shf = NULL;
d454 1
a454 1
			tp->shf = shf_fdopen(fd, SHF_WR, NULL);
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
d96 1
a96 1
		builtin_argv0 = (char *) 0;
d444 1
a444 1
	tp->shf = (struct shf *) 0;
d454 1
a454 1
			tp->shf = shf_fdopen(fd, SHF_WR, (struct shf *) 0);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d327 1
a327 1
		return get_coproc_fd(mode, emsgp);
d340 2
d350 1
a352 4
		if (coproc.readw >= 0) {
			close(coproc.readw);
			coproc.readw = -1;
		}
d363 1
a363 1
	if (coproc.read >= 0 && fd == coproc.read && coproc.readw >= 0) {
d386 1
a386 1
get_coproc_fd(mode, emsgp)
d399 3
a401 1
/* called to close file descriptors related to the coprocess (if any) */
d403 1
a403 1
cleanup_coproc(reuse)
a405 1
	coproc.job = (void *) 0;
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
