head	1.68;
access;
symbols
	OPENBSD_6_1:1.68.0.2
	OPENBSD_6_1_BASE:1.68
	OPENBSD_6_0:1.64.0.4
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.64.0.2
	OPENBSD_5_9_BASE:1.64
	OPENBSD_5_8:1.51.0.4
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.50.0.4
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.50.0.8
	OPENBSD_5_6_BASE:1.50
	OPENBSD_5_5:1.50.0.6
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.50.0.2
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.49.0.18
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.49.0.16
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.14
	OPENBSD_5_0:1.49.0.12
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.49.0.10
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.8
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.4
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.49.0.6
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.49.0.2
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.48.0.4
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.47.0.2
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.46.0.4
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.46.0.2
	OPENBSD_4_0_BASE:1.46
	OPENBSD_3_9:1.44.0.2
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.39.0.2
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.31.0.4
	OPENBSD_3_6_BASE:1.31
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.27.0.4
	OPENBSD_3_4_BASE:1.27
	OPENBSD_3_3:1.27.0.2
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_8:1.21.0.6
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.21.0.4
	OPENBSD_2_7_BASE:1.21
	OPENBSD_2_6:1.21.0.2
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.68
date	2016.12.11.17.49.19;	author millert;	state Exp;
branches;
next	1.67;
commitid	loDaMBwWcXzrduhy;

1.67
date	2016.12.11.17.44.48;	author millert;	state Exp;
branches;
next	1.66;
commitid	XNrFcTfx2kWFD6Zh;

1.66
date	2016.12.11.17.37.38;	author millert;	state Exp;
branches;
next	1.65;
commitid	WAKbaBUpd8zZHo2F;

1.65
date	2016.12.11.17.31.58;	author millert;	state Exp;
branches;
next	1.64;
commitid	i4IJqcbgaCLVeb43;

1.64
date	2015.12.30.09.07.00;	author tedu;	state Exp;
branches;
next	1.63;
commitid	WTwPzlskFufQpRQz;

1.63
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.62;
commitid	btTCreDA00YdaFhU;

1.62
date	2015.11.01.15.38.53;	author mmcc;	state Exp;
branches;
next	1.61;
commitid	Fr9nr0FBz2YkAWdK;

1.61
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.60;
commitid	C4W85jmosThChWA2;

1.60
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.59;
commitid	16HUr75moyUNtKR8;

1.59
date	2015.10.17.18.43.22;	author mmcc;	state Exp;
branches;
next	1.58;
commitid	cfZiQLTOGilosr6B;

1.58
date	2015.10.17.18.26.24;	author mmcc;	state Exp;
branches;
next	1.57;
commitid	cg0YOIB6IojdTdEq;

1.57
date	2015.09.22.21.50.40;	author millert;	state Exp;
branches;
next	1.56;
commitid	ZWmS69dzJnkF6rox;

1.56
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.55;
commitid	7fgq4YTZG4xZ0uN0;

1.55
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.54;
commitid	v5QjoxUgKU2iUTFz;

1.54
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.53;
commitid	lBs9un9sXhbdfVrQ;

1.53
date	2015.09.14.16.08.50;	author nicm;	state Exp;
branches;
next	1.52;
commitid	ahedYHs8fav8xOPq;

1.52
date	2015.09.10.22.48.58;	author nicm;	state Exp;
branches;
next	1.51;
commitid	stJ3KRI2o7F5OBtF;

1.51
date	2015.04.18.18.28.36;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	6b2lLILbgCR1fvia;

1.50
date	2013.06.10.21.09.27;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2009.01.29.23.27.26;	author jaredy;	state Exp;
branches;
next	1.48;

1.48
date	2007.09.05.19.02.01;	author otto;	state Exp;
branches;
next	1.47;

1.47
date	2007.08.02.10.52.10;	author fgsch;	state Exp;
branches;
next	1.46;

1.46
date	2006.04.10.14.38.59;	author jaredy;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.17.16.30.13;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.11.20.31.21;	author otto;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.11.18.53.51;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2005.09.11.18.02.27;	author otto;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.28.21.28.22;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2004.12.22.18.57.28;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.36;

1.36
date	2004.12.19.04.14.20;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.18.22.35.41;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2004.12.18.21.04.52;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.15.05.25.52;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.10.21.26.39;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2003.11.10.21.24.30;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2003.10.22.07.40.38;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.16.01.28.54;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.07.19.16.46.27;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.03.21.28.03;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.19.09.49.52;	author camield;	state Exp;
branches;
next	1.21;

1.21
date	99.07.15.20.35.33;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	99.07.14.15.05.27;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	99.07.14.13.37.23;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	99.06.23.10.30.51;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	99.06.15.01.18.33;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	99.01.19.20.41.52;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	99.01.10.17.55.02;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.01.08.20.24.59;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.10.29.04.09.20;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.06.27.15.23.29;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.06.25.19.01.54;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.09.12.04.38.05;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.06.19.13.58.41;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.06.18.22.42.34;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.01.02.17.37.25;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.01.02.09.33.56;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.11.21.07.59.28;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.10.01.02.05.34;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.08.25.12.38.00;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.50;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.68
log
@I missed a bit of the indentation fix from Kartik Agaram.
@
text
@/*	$OpenBSD: exec.c,v 1.67 2016/12/11 17:44:48 millert Exp $	*/

/*
 * execute command tree
 */

#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "sh.h"
#include "c_test.h"

/* Does ps4 get parameter substitutions done? */
# define PS4_SUBSTITUTE(s)	substitute((s), 0)

static int	comexec(struct op *, struct tbl *volatile, char **,
		    int volatile, volatile int *);
static void	scriptexec(struct op *, char **);
static int	call_builtin(struct tbl *, char **);
static int	iosetup(struct ioword *, struct tbl *);
static int	herein(const char *, int);
static char	*do_selectargs(char **, bool);
static int	dbteste_isa(Test_env *, Test_meta);
static const char *dbteste_getopnd(Test_env *, Test_op, int);
static int	dbteste_eval(Test_env *, Test_op, const char *, const char *,
		    int);
static void	dbteste_error(Test_env *, int, const char *);


/*
 * execute command tree
 */
int
execute(struct op *volatile t,
    volatile int flags,		/* if XEXEC don't fork */
    volatile int *xerrok)	/* inform recursive callers in -e mode that
				 * short-circuit && or || shouldn't be treated
				 * as an error */
{
	int i, dummy = 0, save_xerrok = 0;
	volatile int rv = 0;
	int pv[2];
	char ** volatile ap;
	char *s, *cp;
	struct ioword **iowp;
	struct tbl *tp = NULL;

	if (t == NULL)
		return 0;

	/* Caller doesn't care if XERROK should propagate. */
	if (xerrok == NULL)
		xerrok = &dummy;

	/* Is this the end of a pipeline?  If so, we want to evaluate the
	 * command arguments
	bool eval_done = false;
	if ((flags&XFORK) && !(flags&XEXEC) && (flags&XPCLOSE)) {
		eval_done = true;
		tp = eval_execute_args(t, &ap);
	}
	 */
	if ((flags&XFORK) && !(flags&XEXEC) && t->type != TPIPE)
		return exchild(t, flags & ~XTIME, xerrok, -1); /* run in sub-process */

	newenv(E_EXEC);
	if (trap)
		runtraps(0);

	if (t->type == TCOM) {
		/* Clear subst_exstat before argument expansion.  Used by
		 * null commands (see comexec() and c_eval()) and by c_set().
		 */
		subst_exstat = 0;

		current_lineno = t->lineno;	/* for $LINENO */

		/* POSIX says expand command words first, then redirections,
		 * and assignments last..
		 */
		ap = eval(t->args, t->u.evalflags | DOBLANK | DOGLOB | DOTILDE);
		if (flags & XTIME)
			/* Allow option parsing (bizarre, but POSIX) */
			timex_hook(t, &ap);
		if (Flag(FXTRACE) && ap[0]) {
			shf_fprintf(shl_out, "%s",
				PS4_SUBSTITUTE(str_val(global("PS4"))));
			for (i = 0; ap[i]; i++)
				shf_fprintf(shl_out, "%s%s", ap[i],
				    ap[i + 1] ? " " : "\n");
			shf_flush(shl_out);
		}
		if (ap[0])
			tp = findcom(ap[0], FC_BI|FC_FUNC);
	}
	flags &= ~XTIME;

	if (t->ioact != NULL || t->type == TPIPE || t->type == TCOPROC) {
		genv->savefd = areallocarray(NULL, NUFILE, sizeof(short), ATEMP);
		/* initialize to not redirected */
		memset(genv->savefd, 0, NUFILE * sizeof(short));
	}

	/* do redirection, to be restored in quitenv() */
	if (t->ioact != NULL)
		for (iowp = t->ioact; *iowp != NULL; iowp++) {
			if (iosetup(*iowp, tp) < 0) {
				exstat = rv = 1;
				/* Redirection failures for special commands
				 * cause (non-interactive) shell to exit.
				 */
				if (tp && tp->type == CSHELL &&
				    (tp->flag & SPEC_BI))
					errorf(NULL);
				/* Deal with FERREXIT, quitenv(), etc. */
				goto Break;
			}
		}

	switch (t->type) {
	case TCOM:
		rv = comexec(t, tp, ap, flags, xerrok);
		break;

	case TPAREN:
		rv = execute(t->left, flags|XFORK, xerrok);
		break;

	case TPIPE:
		flags |= XFORK;
		flags &= ~XEXEC;
		genv->savefd[0] = savefd(0);
		genv->savefd[1] = savefd(1);
		while (t->type == TPIPE) {
			openpipe(pv);
			(void) ksh_dup2(pv[1], 1, false); /* stdout of curr */
			/* Let exchild() close pv[0] in child
			 * (if this isn't done, commands like
			 *    (: ; cat /etc/termcap) | sleep 1
			 *  will hang forever).
			 */
			exchild(t->left, flags|XPIPEO|XCCLOSE, NULL, pv[0]);
			(void) ksh_dup2(pv[0], 0, false); /* stdin of next */
			closepipe(pv);
			flags |= XPIPEI;
			t = t->right;
		}
		restfd(1, genv->savefd[1]); /* stdout of last */
		genv->savefd[1] = 0; /* no need to re-restore this */
		/* Let exchild() close 0 in parent, after fork, before wait */
		i = exchild(t, flags|XPCLOSE, xerrok, 0);
		if (!(flags&XBGND) && !(flags&XXCOM))
			rv = i;
		break;

	case TLIST:
		while (t->type == TLIST) {
			execute(t->left, flags & XERROK, NULL);
			t = t->right;
		}
		rv = execute(t, flags & XERROK, xerrok);
		break;

	case TCOPROC:
	    {
		sigset_t	omask;

		/* Block sigchild as we are using things changed in the
		 * signal handler
		 */
		sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
		genv->type = E_ERRH;
		i = sigsetjmp(genv->jbuf, 0);
		if (i) {
			sigprocmask(SIG_SETMASK, &omask, NULL);
			quitenv(NULL);
			unwind(i);
			/* NOTREACHED */
		}
		/* Already have a (live) co-process? */
		if (coproc.job && coproc.write >= 0)
			errorf("coprocess already exists");

		/* Can we re-use the existing co-process pipe? */
		coproc_cleanup(true);

		/* do this before opening pipes, in case these fail */
		genv->savefd[0] = savefd(0);
		genv->savefd[1] = savefd(1);

		openpipe(pv);
		if (pv[0] != 0) {
			ksh_dup2(pv[0], 0, false);
			close(pv[0]);
		}
		coproc.write = pv[1];
		coproc.job = NULL;

		if (coproc.readw >= 0)
			ksh_dup2(coproc.readw, 1, false);
		else {
			openpipe(pv);
			coproc.read = pv[0];
			ksh_dup2(pv[1], 1, false);
			coproc.readw = pv[1];	 /* closed before first read */
			coproc.njobs = 0;
			/* create new coprocess id */
			++coproc.id;
		}
		sigprocmask(SIG_SETMASK, &omask, NULL);
		genv->type = E_EXEC; /* no more need for error handler */

		/* exchild() closes coproc.* in child after fork,
		 * will also increment coproc.njobs when the
		 * job is actually created.
		 */
		flags &= ~XEXEC;
		exchild(t->left, flags|XBGND|XFORK|XCOPROC|XCCLOSE,
		    NULL, coproc.readw);
		break;
	    }

	case TASYNC:
		/* XXX non-optimal, I think - "(foo &)", forks for (),
		 * forks again for async...  parent should optimize
		 * this to "foo &"...
		 */
		rv = execute(t->left, (flags&~XEXEC)|XBGND|XFORK, xerrok);
		break;

	case TOR:
	case TAND:
		rv = execute(t->left, XERROK, xerrok);
		if ((rv == 0) == (t->type == TAND))
			rv = execute(t->right, flags & XERROK, xerrok);
		else {
			flags |= XERROK;
			*xerrok = 1;
		}
		break;

	case TBANG:
		rv = !execute(t->right, XERROK, xerrok);
		flags |= XERROK;
		*xerrok = 1;
		break;

	case TDBRACKET:
	    {
		Test_env te;

		te.flags = TEF_DBRACKET;
		te.pos.wp = t->args;
		te.isa = dbteste_isa;
		te.getopnd = dbteste_getopnd;
		te.eval = dbteste_eval;
		te.error = dbteste_error;

		rv = test_parse(&te);
		break;
	    }

	case TFOR:
	case TSELECT:
	    {
		volatile bool is_first = true;
		ap = (t->vars != NULL) ? eval(t->vars, DOBLANK|DOGLOB|DOTILDE) :
		    genv->loc->argv + 1;
		genv->type = E_LOOP;
		while (1) {
			i = sigsetjmp(genv->jbuf, 0);
			if (!i)
				break;
			if ((genv->flags&EF_BRKCONT_PASS) ||
			    (i != LBREAK && i != LCONTIN)) {
				quitenv(NULL);
				unwind(i);
			} else if (i == LBREAK) {
				rv = 0;
				goto Break;
			}
		}
		rv = 0; /* in case of a continue */
		if (t->type == TFOR) {
			save_xerrok = *xerrok;
			while (*ap != NULL) {
				setstr(global(t->str), *ap++, KSH_UNWIND_ERROR);
				/* undo xerrok in all iterations except the
				 * last */
				*xerrok = save_xerrok;
				rv = execute(t->left, flags & XERROK, xerrok);
			}
			/* ripple xerrok set at final iteration */
		} else { /* TSELECT */
			for (;;) {
				if (!(cp = do_selectargs(ap, is_first))) {
					rv = 1;
					break;
				}
				is_first = false;
				setstr(global(t->str), cp, KSH_UNWIND_ERROR);
				rv = execute(t->left, flags & XERROK, xerrok);
			}
		}
	    }
		break;

	case TWHILE:
	case TUNTIL:
		genv->type = E_LOOP;
		while (1) {
			i = sigsetjmp(genv->jbuf, 0);
			if (!i)
				break;
			if ((genv->flags&EF_BRKCONT_PASS) ||
			    (i != LBREAK && i != LCONTIN)) {
				quitenv(NULL);
				unwind(i);
			} else if (i == LBREAK) {
				rv = 0;
				goto Break;
			}
		}
		rv = 0; /* in case of a continue */
		while ((execute(t->left, XERROK, NULL) == 0) == (t->type == TWHILE))
			rv = execute(t->right, flags & XERROK, xerrok);
		break;

	case TIF:
	case TELIF:
		if (t->right == NULL)
			break;	/* should be error */
		rv = execute(t->left, XERROK, NULL) == 0 ?
		    execute(t->right->left, flags & XERROK, xerrok) :
		    execute(t->right->right, flags & XERROK, xerrok);
		break;

	case TCASE:
		cp = evalstr(t->str, DOTILDE);
		for (t = t->left; t != NULL && t->type == TPAT; t = t->right) {
			for (ap = t->vars; *ap; ap++) {
				if ((s = evalstr(*ap, DOTILDE|DOPAT)) &&
				    gmatch(cp, s, false))
					goto Found;
			}
		}
		break;
	  Found:
		rv = execute(t->left, flags & XERROK, xerrok);
		break;

	case TBRACE:
		rv = execute(t->left, flags & XERROK, xerrok);
		break;

	case TFUNCT:
		rv = define(t->str, t);
		break;

	case TTIME:
		/* Clear XEXEC so nested execute() call doesn't exit
		 * (allows "ls -l | time grep foo").
		 */
		rv = timex(t, flags & ~XEXEC, xerrok);
		break;

	case TEXEC:		/* an eval'd TCOM */
		s = t->args[0];
		ap = makenv();
		restoresigs();
		cleanup_proc_env();
		execve(t->str, t->args, ap);
		if (errno == ENOEXEC)
			scriptexec(t, ap);
		else
			errorf("%s: %s", s, strerror(errno));
	}
    Break:
	exstat = rv;

	quitenv(NULL);		/* restores IO */
	if ((flags&XEXEC))
		unwind(LEXIT);	/* exit child */
	if (rv != 0 && !(flags & XERROK) && !*xerrok) {
		trapsig(SIGERR_);
		if (Flag(FERREXIT))
			unwind(LERROR);
	}
	return rv;
}

/*
 * execute simple command
 */

static int
comexec(struct op *t, struct tbl *volatile tp, char **ap, volatile int flags,
    volatile int *xerrok)
{
	int i;
	volatile int rv = 0;
	char *cp;
	char **lastp;
	static struct op texec; /* Must be static (XXX but why?) */
	int type_flags;
	int keepasn_ok;
	int fcflags = FC_BI|FC_FUNC|FC_PATH;
	int bourne_function_call = 0;

	/* snag the last argument for $_ XXX not the same as at&t ksh,
	 * which only seems to set $_ after a newline (but not in
	 * functions/dot scripts, but in interactive and script) -
	 * perhaps save last arg here and set it in shell()?.
	 */
	if (!Flag(FSH) && Flag(FTALKING) && *(lastp = ap)) {
		while (*++lastp)
			;
		/* setstr() can't fail here */
		setstr(typeset("_", LOCAL, 0, INTEGER, 0), *--lastp,
		    KSH_RETURN_ERROR);
	}

	/* Deal with the shell builtins builtin, exec and command since
	 * they can be followed by other commands.  This must be done before
	 * we know if we should create a local block, which must be done
	 * before we can do a path search (in case the assignments change
	 * PATH).
	 * Odd cases:
	 *   FOO=bar exec > /dev/null		FOO is kept but not exported
	 *   FOO=bar exec foobar		FOO is exported
	 *   FOO=bar command exec > /dev/null	FOO is neither kept nor exported
	 *   FOO=bar command			FOO is neither kept nor exported
	 *   PATH=... foobar			use new PATH in foobar search
	 */
	keepasn_ok = 1;
	while (tp && tp->type == CSHELL) {
		fcflags = FC_BI|FC_FUNC|FC_PATH;/* undo effects of command */
		if (tp->val.f == c_builtin) {
			if ((cp = *++ap) == NULL) {
				tp = NULL;
				break;
			}
			tp = findcom(cp, FC_BI);
			if (tp == NULL)
				errorf("builtin: %s: not a builtin", cp);
			continue;
		} else if (tp->val.f == c_exec) {
			if (ap[1] == NULL)
				break;
			ap++;
			flags |= XEXEC;
		} else if (tp->val.f == c_command) {
			int optc, saw_p = 0;

			/* Ugly dealing with options in two places (here and
			 * in c_command(), but such is life)
			 */
			ksh_getopt_reset(&builtin_opt, 0);
			while ((optc = ksh_getopt(ap, &builtin_opt, ":p")) == 'p')
				saw_p = 1;
			if (optc != EOF)
				break;	/* command -vV or something */
			/* don't look for functions */
			fcflags = FC_BI|FC_PATH;
			if (saw_p) {
				if (Flag(FRESTRICTED)) {
					warningf(true,
					    "command -p: restricted");
					rv = 1;
					goto Leave;
				}
				fcflags |= FC_DEFPATH;
			}
			ap += builtin_opt.optind;
			/* POSIX says special builtins lose their status
			 * if accessed using command.
			 */
			keepasn_ok = 0;
			if (!ap[0]) {
				/* ensure command with no args exits with 0 */
				subst_exstat = 0;
				break;
			}
		} else
			break;
		tp = findcom(ap[0], fcflags & (FC_BI|FC_FUNC));
	}
	if (keepasn_ok && (!ap[0] || (tp && (tp->flag & KEEPASN))))
		type_flags = 0;
	else {
		/* create new variable/function block */
		newblock();
		/* ksh functions don't keep assignments, POSIX functions do. */
		if (keepasn_ok && tp && tp->type == CFUNC &&
		    !(tp->flag & FKSH)) {
			bourne_function_call = 1;
			type_flags = 0;
		} else
			type_flags = LOCAL|LOCAL_COPY|EXPORT;
	}
	if (Flag(FEXPORT))
		type_flags |= EXPORT;
	for (i = 0; t->vars[i]; i++) {
		cp = evalstr(t->vars[i], DOASNTILDE);
		if (Flag(FXTRACE)) {
			if (i == 0)
				shf_fprintf(shl_out, "%s",
				    PS4_SUBSTITUTE(str_val(global("PS4"))));
			shf_fprintf(shl_out, "%s%s", cp,
			    t->vars[i + 1] ? " " : "\n");
			if (!t->vars[i + 1])
				shf_flush(shl_out);
		}
		typeset(cp, type_flags, 0, 0, 0);
		if (bourne_function_call && !(type_flags & EXPORT))
			typeset(cp, LOCAL|LOCAL_COPY|EXPORT, 0, 0, 0);
	}

	if ((cp = *ap) == NULL) {
		rv = subst_exstat;
		goto Leave;
	} else if (!tp) {
		if (Flag(FRESTRICTED) && strchr(cp, '/')) {
			warningf(true, "%s: restricted", cp);
			rv = 1;
			goto Leave;
		}
		tp = findcom(cp, fcflags);
	}

	switch (tp->type) {
	case CSHELL:			/* shell built-in */
		rv = call_builtin(tp, ap);
		break;

	case CFUNC:			/* function call */
	    {
		volatile int old_xflag, old_inuse;
		const char *volatile old_kshname;

		if (!(tp->flag & ISSET)) {
			struct tbl *ftp;

			if (!tp->u.fpath) {
				if (tp->u2.errno_) {
					warningf(true,
					    "%s: can't find function "
					    "definition file - %s",
					    cp, strerror(tp->u2.errno_));
					rv = 126;
				} else {
					warningf(true,
					    "%s: can't find function "
					    "definition file", cp);
					rv = 127;
				}
				break;
			}
			if (include(tp->u.fpath, 0, NULL, 0) < 0) {
				warningf(true,
				    "%s: can't open function definition file %s - %s",
				    cp, tp->u.fpath, strerror(errno));
				rv = 127;
				break;
			}
			if (!(ftp = findfunc(cp, hash(cp), false)) ||
			    !(ftp->flag & ISSET)) {
				warningf(true,
				    "%s: function not defined by %s",
				    cp, tp->u.fpath);
				rv = 127;
				break;
			}
			tp = ftp;
		}

		/* ksh functions set $0 to function name, POSIX functions leave
		 * $0 unchanged.
		 */
		old_kshname = kshname;
		if (tp->flag & FKSH)
			kshname = ap[0];
		else
			ap[0] = (char *) kshname;
		genv->loc->argv = ap;
		for (i = 0; *ap++ != NULL; i++)
			;
		genv->loc->argc = i - 1;
		/* ksh-style functions handle getopts sanely,
		 * bourne/posix functions are insane...
		 */
		if (tp->flag & FKSH) {
			genv->loc->flags |= BF_DOGETOPTS;
			genv->loc->getopts_state = user_opt;
			getopts_reset(1);
		}

		old_xflag = Flag(FXTRACE);
		Flag(FXTRACE) = tp->flag & TRACE ? true : false;

		old_inuse = tp->flag & FINUSE;
		tp->flag |= FINUSE;

		genv->type = E_FUNC;
		i = sigsetjmp(genv->jbuf, 0);
		if (i == 0) {
			/* seems odd to pass XERROK here, but at&t ksh does */
			exstat = execute(tp->val.t, flags & XERROK, xerrok);
			i = LRETURN;
		}
		kshname = old_kshname;
		Flag(FXTRACE) = old_xflag;
		tp->flag = (tp->flag & ~FINUSE) | old_inuse;
		/* Were we deleted while executing?  If so, free the execution
		 * tree.  todo: Unfortunately, the table entry is never re-used
		 * until the lookup table is expanded.
		 */
		if ((tp->flag & (FDELETE|FINUSE)) == FDELETE) {
			if (tp->flag & ALLOC) {
				tp->flag &= ~ALLOC;
				tfree(tp->val.t, tp->areap);
			}
			tp->flag = 0;
		}
		switch (i) {
		case LRETURN:
		case LERROR:
			rv = exstat;
			break;
		case LINTR:
		case LEXIT:
		case LLEAVE:
		case LSHELL:
			quitenv(NULL);
			unwind(i);
			/* NOTREACHED */
		default:
			quitenv(NULL);
			internal_errorf(1, "CFUNC %d", i);
		}
		break;
	    }

	case CEXEC:		/* executable command */
	case CTALIAS:		/* tracked alias */
		if (!(tp->flag&ISSET)) {
			/* errno_ will be set if the named command was found
			 * but could not be executed (permissions, no execute
			 * bit, directory, etc).  Print out a (hopefully)
			 * useful error message and set the exit status to 126.
			 */
			if (tp->u2.errno_) {
				warningf(true, "%s: cannot execute - %s", cp,
				    strerror(tp->u2.errno_));
				rv = 126;	/* POSIX */
			} else {
				warningf(true, "%s: not found", cp);
				rv = 127;
			}
			break;
		}

		if (!Flag(FSH)) {
			/* set $_ to program's full path */
			/* setstr() can't fail here */
			setstr(typeset("_", LOCAL|EXPORT, 0, INTEGER, 0),
			    tp->val.s, KSH_RETURN_ERROR);
		}

		if (flags&XEXEC) {
			j_exit();
			if (!(flags&XBGND) || Flag(FMONITOR)) {
				setexecsig(&sigtraps[SIGINT], SS_RESTORE_ORIG);
				setexecsig(&sigtraps[SIGQUIT], SS_RESTORE_ORIG);
			}
		}

		/* to fork we set up a TEXEC node and call execute */
		texec.type = TEXEC;
		texec.left = t;	/* for tprint */
		texec.str = tp->val.s;
		texec.args = ap;
		rv = exchild(&texec, flags, xerrok, -1);
		break;
	}
  Leave:
	if (flags & XEXEC) {
		exstat = rv;
		unwind(LLEAVE);
	}
	return rv;
}

static void
scriptexec(struct op *tp, char **ap)
{
	char *shell;

	shell = str_val(global("EXECSHELL"));
	if (shell && *shell)
		shell = search(shell, path, X_OK, NULL);
	if (!shell || !*shell)
		shell = _PATH_BSHELL;

	*tp->args-- = tp->str;
	*tp->args = shell;

	execve(tp->args[0], tp->args, ap);

	/* report both the program that was run and the bogus shell */
	errorf("%s: %s: %s", tp->str, shell, strerror(errno));
}

int
shcomexec(char **wp)
{
	struct tbl *tp;

	tp = ktsearch(&builtins, *wp, hash(*wp));
	if (tp == NULL)
		internal_errorf(1, "shcomexec: %s", *wp);
	return call_builtin(tp, wp);
}

/*
 * Search function tables for a function.  If create set, a table entry
 * is created if none is found.
 */
struct tbl *
findfunc(const char *name, unsigned int h, int create)
{
	struct block *l;
	struct tbl *tp = NULL;

	for (l = genv->loc; l; l = l->next) {
		tp = ktsearch(&l->funs, name, h);
		if (tp)
			break;
		if (!l->next && create) {
			tp = ktenter(&l->funs, name, h);
			tp->flag = DEFINED;
			tp->type = CFUNC;
			tp->val.t = NULL;
			break;
		}
	}
	return tp;
}

/*
 * define function.  Returns 1 if function is being undefined (t == 0) and
 * function did not exist, returns 0 otherwise.
 */
int
define(const char *name, struct op *t)
{
	struct tbl *tp;
	int was_set = 0;

	while (1) {
		tp = findfunc(name, hash(name), true);

		if (tp->flag & ISSET)
			was_set = 1;
		/* If this function is currently being executed, we zap this
		 * table entry so findfunc() won't see it
		 */
		if (tp->flag & FINUSE) {
			tp->name[0] = '\0';
			tp->flag &= ~DEFINED; /* ensure it won't be found */
			tp->flag |= FDELETE;
		} else
			break;
	}

	if (tp->flag & ALLOC) {
		tp->flag &= ~(ISSET|ALLOC);
		tfree(tp->val.t, tp->areap);
	}

	if (t == NULL) {		/* undefine */
		ktdelete(tp);
		return was_set ? 0 : 1;
	}

	tp->val.t = tcopy(t->left, tp->areap);
	tp->flag |= (ISSET|ALLOC);
	if (t->u.ksh_func)
		tp->flag |= FKSH;

	return 0;
}

/*
 * add builtin
 */
void
builtin(const char *name, int (*func) (char **))
{
	struct tbl *tp;
	int flag;

	/* see if any flags should be set for this builtin */
	for (flag = 0; ; name++) {
		if (*name == '=')	/* command does variable assignment */
			flag |= KEEPASN;
		else if (*name == '*')	/* POSIX special builtin */
			flag |= SPEC_BI;
		else if (*name == '+')	/* POSIX regular builtin */
			flag |= REG_BI;
		else
			break;
	}

	tp = ktenter(&builtins, name, hash(name));
	tp->flag = DEFINED | flag;
	tp->type = CSHELL;
	tp->val.f = func;
}

/*
 * find command
 * either function, hashed command, or built-in (in that order)
 */
struct tbl *
findcom(const char *name, int flags)
{
	static struct tbl temp;
	unsigned int h = hash(name);
	struct tbl *tp = NULL, *tbi;
	int insert = Flag(FTRACKALL);	/* insert if not found */
	char *fpath;			/* for function autoloading */
	char *npath;

	if (strchr(name, '/') != NULL) {
		insert = 0;
		/* prevent FPATH search below */
		flags &= ~FC_FUNC;
		goto Search;
	}
	tbi = (flags & FC_BI) ? ktsearch(&builtins, name, h) : NULL;
	/* POSIX says special builtins first, then functions, then
	 * POSIX regular builtins, then search path...
	 */
	if ((flags & FC_SPECBI) && tbi && (tbi->flag & SPEC_BI))
		tp = tbi;
	if (!tp && (flags & FC_FUNC)) {
		tp = findfunc(name, h, false);
		if (tp && !(tp->flag & ISSET)) {
			if ((fpath = str_val(global("FPATH"))) == null) {
				tp->u.fpath = NULL;
				tp->u2.errno_ = 0;
			} else
				tp->u.fpath = search(name, fpath, R_OK,
				    &tp->u2.errno_);
		}
	}
	if (!tp && (flags & FC_REGBI) && tbi && (tbi->flag & REG_BI))
		tp = tbi;
	/* todo: posix says non-special/non-regular builtins must
	 * be triggered by some user-controllable means like a
	 * special directory in PATH.  Requires modifications to
	 * the search() function.  Tracked aliases should be
	 * modified to allow tracking of builtin commands.
	 * This should be under control of the FPOSIX flag.
	 * If this is changed, also change c_whence...
	 */
	if (!tp && (flags & FC_UNREGBI) && tbi)
		tp = tbi;
	if (!tp && (flags & FC_PATH) && !(flags & FC_DEFPATH)) {
		tp = ktsearch(&taliases, name, h);
		if (tp && (tp->flag & ISSET) && access(tp->val.s, X_OK) != 0) {
			if (tp->flag & ALLOC) {
				tp->flag &= ~ALLOC;
				afree(tp->val.s, APERM);
			}
			tp->flag &= ~ISSET;
		}
	}

  Search:
	if ((!tp || (tp->type == CTALIAS && !(tp->flag&ISSET))) &&
	    (flags & FC_PATH)) {
		if (!tp) {
			if (insert && !(flags & FC_DEFPATH)) {
				tp = ktenter(&taliases, name, h);
				tp->type = CTALIAS;
			} else {
				tp = &temp;
				tp->type = CEXEC;
			}
			tp->flag = DEFINED;	/* make ~ISSET */
		}
		npath = search(name, flags & FC_DEFPATH ? def_path : path,
		    X_OK, &tp->u2.errno_);
		if (npath) {
			if (tp == &temp) {
				tp->val.s = npath;
			} else {
				tp->val.s = str_save(npath, APERM);
				if (npath != name)
					afree(npath, ATEMP);
			}
			tp->flag |= ISSET|ALLOC;
		} else if ((flags & FC_FUNC) &&
		    (fpath = str_val(global("FPATH"))) != null &&
		    (npath = search(name, fpath, R_OK,
		    &tp->u2.errno_)) != NULL) {
			/* An undocumented feature of at&t ksh is that it
			 * searches FPATH if a command is not found, even
			 * if the command hasn't been set up as an autoloaded
			 * function (ie, no typeset -uf).
			 */
			tp = &temp;
			tp->type = CFUNC;
			tp->flag = DEFINED; /* make ~ISSET */
			tp->u.fpath = npath;
		}
	}
	return tp;
}

/*
 * flush executable commands with relative paths
 */
void
flushcom(int all)	/* just relative or all */
{
	struct tbl *tp;
	struct tstate ts;

	for (ktwalk(&ts, &taliases); (tp = ktnext(&ts)) != NULL; )
		if ((tp->flag&ISSET) && (all || tp->val.s[0] != '/')) {
			if (tp->flag&ALLOC) {
				tp->flag &= ~(ALLOC|ISSET);
				afree(tp->val.s, APERM);
			}
			tp->flag &= ~ISSET;
		}
}

/* Check if path is something we want to find.  Returns -1 for failure. */
int
search_access(const char *path, int mode,
    int *errnop)	/* set if candidate found, but not suitable */
{
	int ret, err = 0;
	struct stat statb;

	if (stat(path, &statb) < 0)
		return -1;
	ret = access(path, mode);
	if (ret < 0)
		err = errno; /* File exists, but we can't access it */
	else if (mode == X_OK && (!S_ISREG(statb.st_mode) ||
	    !(statb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)))) {
	    /* This 'cause access() says root can execute everything */
		ret = -1;
		err = S_ISDIR(statb.st_mode) ? EISDIR : EACCES;
	}
	if (err && errnop && !*errnop)
		*errnop = err;
	return ret;
}

/*
 * search for command with PATH
 */
char *
search(const char *name, const char *path,
    int mode,		/* R_OK or X_OK */
    int *errnop)	/* set if candidate found, but not suitable */
{
	const char *sp, *p;
	char *xp;
	XString xs;
	int namelen;

	if (errnop)
		*errnop = 0;
	if (strchr(name, '/')) {
		if (search_access(name, mode, errnop) == 0)
			return (char *) name;
		return NULL;
	}

	namelen = strlen(name) + 1;
	Xinit(xs, xp, 128, ATEMP);

	sp = path;
	while (sp != NULL) {
		xp = Xstring(xs, xp);
		if (!(p = strchr(sp, ':')))
			p = sp + strlen(sp);
		if (p != sp) {
			XcheckN(xs, xp, p - sp);
			memcpy(xp, sp, p - sp);
			xp += p - sp;
			*xp++ = '/';
		}
		sp = p;
		XcheckN(xs, xp, namelen);
		memcpy(xp, name, namelen);
		if (search_access(Xstring(xs, xp), mode, errnop) == 0)
			return Xclose(xs, xp + namelen);
		if (*sp++ == '\0')
			sp = NULL;
	}
	Xfree(xs, xp);
	return NULL;
}

static int
call_builtin(struct tbl *tp, char **wp)
{
	int rv;

	builtin_argv0 = wp[0];
	builtin_flag = tp->flag;
	shf_reopen(1, SHF_WR, shl_stdout);
	shl_stdout_ok = 1;
	ksh_getopt_reset(&builtin_opt, GF_ERROR);
	rv = (*tp->val.f)(wp);
	shf_flush(shl_stdout);
	shl_stdout_ok = 0;
	builtin_flag = 0;
	builtin_argv0 = NULL;
	return rv;
}

/*
 * set up redirection, saving old fd's in e->savefd
 */
static int
iosetup(struct ioword *iop, struct tbl *tp)
{
	int u = -1;
	char *cp = iop->name;
	int iotype = iop->flag & IOTYPE;
	int do_open = 1, do_close = 0, flags = 0;
	struct ioword iotmp;
	struct stat statb;

	if (iotype != IOHERE)
		cp = evalonestr(cp, DOTILDE|(Flag(FTALKING_I) ? DOGLOB : 0));

	/* Used for tracing and error messages to print expanded cp */
	iotmp = *iop;
	iotmp.name = (iotype == IOHERE) ? NULL : cp;
	iotmp.flag |= IONAMEXP;

	if (Flag(FXTRACE))
		shellf("%s%s\n",
		    PS4_SUBSTITUTE(str_val(global("PS4"))),
		    snptreef(NULL, 32, "%R", &iotmp));

	switch (iotype) {
	case IOREAD:
		flags = O_RDONLY;
		break;

	case IOCAT:
		flags = O_WRONLY | O_APPEND | O_CREAT;
		break;

	case IOWRITE:
		flags = O_WRONLY | O_CREAT | O_TRUNC;
		/* The stat() is here to allow redirections to
		 * things like /dev/null without error.
		 */
		if (Flag(FNOCLOBBER) && !(iop->flag & IOCLOB) &&
		    (stat(cp, &statb) < 0 || S_ISREG(statb.st_mode)))
			flags |= O_EXCL;
		break;

	case IORDWR:
		flags = O_RDWR | O_CREAT;
		break;

	case IOHERE:
		do_open = 0;
		/* herein() returns -2 if error has been printed */
		u = herein(iop->heredoc, iop->flag & IOEVAL);
		/* cp may have wrong name */
		break;

	case IODUP:
	    {
		const char *emsg;

		do_open = 0;
		if (*cp == '-' && !cp[1]) {
			u = 1009;	 /* prevent error return below */
			do_close = 1;
		} else if ((u = check_fd(cp,
		    X_OK | ((iop->flag & IORDUP) ? R_OK : W_OK),
		    &emsg)) < 0) {
			warningf(true, "%s: %s",
			    snptreef(NULL, 32, "%R", &iotmp), emsg);
			return -1;
		}
		if (u == iop->unit)
			return 0;		/* "dup from" == "dup to" */
		break;
	    }
	}

	if (do_open) {
		if (Flag(FRESTRICTED) && (flags & O_CREAT)) {
			warningf(true, "%s: restricted", cp);
			return -1;
		}
		u = open(cp, flags, 0666);
	}
	if (u < 0) {
		/* herein() may already have printed message */
		if (u == -1)
			warningf(true, "cannot %s %s: %s",
			    iotype == IODUP ? "dup" :
			    (iotype == IOREAD || iotype == IOHERE) ?
			    "open" : "create", cp, strerror(errno));
		return -1;
	}
	/* Do not save if it has already been redirected (i.e. "cat >x >y"). */
	if (genv->savefd[iop->unit] == 0) {
		/* If these are the same, it means unit was previously closed */
		if (u == iop->unit)
			genv->savefd[iop->unit] = -1;
		else
			/* c_exec() assumes e->savefd[fd] set for any
			 * redirections.  Ask savefd() not to close iop->unit;
			 * this allows error messages to be seen if iop->unit
			 * is 2; also means we can't lose the fd (eg, both
			 * dup2 below and dup2 in restfd() failing).
			 */
			genv->savefd[iop->unit] = savefd(iop->unit);
	}

	if (do_close)
		close(iop->unit);
	else if (u != iop->unit) {
		if (ksh_dup2(u, iop->unit, true) < 0) {
			warningf(true,
			    "could not finish (dup) redirection %s: %s",
			    snptreef(NULL, 32, "%R", &iotmp),
			    strerror(errno));
			if (iotype != IODUP)
				close(u);
			return -1;
		}
		if (iotype != IODUP)
			close(u);
		/* Touching any co-process fd in an empty exec
		 * causes the shell to close its copies
		 */
		else if (tp && tp->type == CSHELL && tp->val.f == c_exec) {
			if (iop->flag & IORDUP)	/* possible exec <&p */
				coproc_read_close(u);
			else			/* possible exec >&p */
				coproc_write_close(u);
		}
	}
	if (u == 2) /* Clear any write errors */
		shf_reopen(2, SHF_WR, shl_out);
	return 0;
}

/*
 * open here document temp file.
 * if unquoted here, expand here temp file into second temp file.
 */
static int
herein(const char *content, int sub)
{
	volatile int fd = -1;
	struct source *s, *volatile osource;
	struct shf *volatile shf;
	struct temp *h;
	int i;

	/* ksh -c 'cat << EOF' can cause this... */
	if (content == NULL) {
		warningf(true, "here document missing");
		return -2; /* special to iosetup(): don't print error */
	}

	/* Create temp file to hold content (done before newenv so temp
	 * doesn't get removed too soon).
	 */
	h = maketemp(ATEMP, TT_HEREDOC_EXP, &genv->temps);
	if (!(shf = h->shf) || (fd = open(h->name, O_RDONLY, 0)) < 0) {
		warningf(true, "can't %s temporary file %s: %s",
		    !shf ? "create" : "open",
		    h->name, strerror(errno));
		if (shf)
			shf_close(shf);
		return -2 /* special to iosetup(): don't print error */;
	}

	osource = source;
	newenv(E_ERRH);
	i = sigsetjmp(genv->jbuf, 0);
	if (i) {
		source = osource;
		quitenv(shf);
		close(fd);
		return -2; /* special to iosetup(): don't print error */
	}
	if (sub) {
		/* Do substitutions on the content of heredoc */
		s = pushs(SSTRING, ATEMP);
		s->start = s->str = content;
		source = s;
		if (yylex(ONEWORD|HEREDOC) != LWORD)
			internal_errorf(1, "herein: yylex");
		source = osource;
		shf_puts(evalstr(yylval.cp, 0), shf);
	} else
		shf_puts(content, shf);

	quitenv(NULL);

	if (shf_close(shf) == EOF) {
		close(fd);
		warningf(true, "error writing %s: %s", h->name,
		    strerror(errno));
		return -2; /* special to iosetup(): don't print error */
	}

	return fd;
}

#ifdef EDIT
/*
 *	ksh special - the select command processing section
 *	print the args in column form - assuming that we can
 */
static char *
do_selectargs(char **ap, bool print_menu)
{
	static const char *const read_args[] = {
		"read", "-r", "REPLY", NULL
	};
	const char *errstr;
	char *s;
	int i, argct;

	for (argct = 0; ap[argct]; argct++)
		;
	while (1) {
		/* Menu is printed if
		 *	- this is the first time around the select loop
		 *	- the user enters a blank line
		 *	- the REPLY parameter is empty
		 */
		if (print_menu || !*str_val(global("REPLY")))
			pr_menu(ap);
		shellf("%s", str_val(global("PS3")));
		if (call_builtin(findcom("read", FC_BI), (char **) read_args))
			return NULL;
		s = str_val(global("REPLY"));
		if (*s) {
			i = strtonum(s, 1, argct, &errstr);
			if (errstr)
				return null;
			return ap[i - 1];
		}
		print_menu = 1;
	}
}

struct select_menu_info {
	char	*const *args;
	int	arg_width;
	int	num_width;
};

static char *select_fmt_entry(void *arg, int i, char *buf, int buflen);

/* format a single select menu item */
static char *
select_fmt_entry(void *arg, int i, char *buf, int buflen)
{
	struct select_menu_info *smi = (struct select_menu_info *) arg;

	shf_snprintf(buf, buflen, "%*d) %s",
	    smi->num_width, i + 1, smi->args[i]);
	return buf;
}

/*
 *	print a select style menu
 */
int
pr_menu(char *const *ap)
{
	struct select_menu_info smi;
	char *const *pp;
	int nwidth, dwidth;
	int i, n;

	/* Width/column calculations were done once and saved, but this
	 * means select can't be used recursively so we re-calculate each
	 * time (could save in a structure that is returned, but its probably
	 * not worth the bother).
	 */

	/*
	 * get dimensions of the list
	 */
	for (n = 0, nwidth = 0, pp = ap; *pp; n++, pp++) {
		i = strlen(*pp);
		nwidth = (i > nwidth) ? i : nwidth;
	}
	/*
	 * we will print an index of the form
	 *	%d)
	 * in front of each entry
	 * get the max width of this
	 */
	for (i = n, dwidth = 1; i >= 10; i /= 10)
		dwidth++;

	smi.args = ap;
	smi.arg_width = nwidth;
	smi.num_width = dwidth;
	print_columns(shl_out, n, select_fmt_entry, (void *) &smi,
	    dwidth + nwidth + 2, 1);

	return n;
}

/* XXX: horrible kludge to fit within the framework */

static char *plain_fmt_entry(void *arg, int i, char *buf, int buflen);

static char *
plain_fmt_entry(void *arg, int i, char *buf, int buflen)
{
	shf_snprintf(buf, buflen, "%s", ((char *const *)arg)[i]);
	return buf;
}

int
pr_list(char *const *ap)
{
	char *const *pp;
	int nwidth;
	int i, n;

	for (n = 0, nwidth = 0, pp = ap; *pp; n++, pp++) {
		i = strlen(*pp);
		nwidth = (i > nwidth) ? i : nwidth;
	}
	print_columns(shl_out, n, plain_fmt_entry, (void *) ap, nwidth + 1, 0);

	return n;
}
#endif /* EDIT */

/*
 *	[[ ... ]] evaluation routines
 */

extern const char *const dbtest_tokens[];
extern const char db_close[];

/* Test if the current token is a whatever.  Accepts the current token if
 * it is.  Returns 0 if it is not, non-zero if it is (in the case of
 * TM_UNOP and TM_BINOP, the returned value is a Test_op).
 */
static int
dbteste_isa(Test_env *te, Test_meta meta)
{
	int ret = 0;
	int uqword;
	char *p;

	if (!*te->pos.wp)
		return meta == TM_END;

	/* unquoted word? */
	for (p = *te->pos.wp; *p == CHAR; p += 2)
		;
	uqword = *p == EOS;

	if (meta == TM_UNOP || meta == TM_BINOP) {
		if (uqword) {
			char buf[8];	/* longer than the longest operator */
			char *q = buf;
			for (p = *te->pos.wp;
			    *p == CHAR && q < &buf[sizeof(buf) - 1]; p += 2)
				*q++ = p[1];
			*q = '\0';
			ret = (int) test_isop(te, meta, buf);
		}
	} else if (meta == TM_END)
		ret = 0;
	else
		ret = uqword &&
		    strcmp(*te->pos.wp, dbtest_tokens[(int) meta]) == 0;

	/* Accept the token? */
	if (ret)
		te->pos.wp++;

	return ret;
}

static const char *
dbteste_getopnd(Test_env *te, Test_op op, int do_eval)
{
	char *s = *te->pos.wp;

	if (!s)
		return NULL;

	te->pos.wp++;

	if (!do_eval)
		return null;

	if (op == TO_STEQL || op == TO_STNEQ)
		s = evalstr(s, DOTILDE | DOPAT);
	else
		s = evalstr(s, DOTILDE);

	return s;
}

static int
dbteste_eval(Test_env *te, Test_op op, const char *opnd1, const char *opnd2,
    int do_eval)
{
	return test_eval(te, op, opnd1, opnd2, do_eval);
}

static void
dbteste_error(Test_env *te, int offset, const char *msg)
{
	te->flags |= TEF_ERROR;
	internal_errorf(0, "dbteste_error: %s (offset %d)", msg, offset);
}
@


1.67
log
@When ERREXIT (set -e) is in effect, don't disable it after a
short-circuited `&&` or `||` chain in later iterations of `for`
loops.  It should be disabled after a short-circuited `&&` or `||`
chain only in the *final* iteration of loops (as well as in
conditionals, which was already working).  From Kartik Agaram.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.66 2016/12/11 17:37:38 millert Exp $	*/
d350 3
a352 3
			    if ((s = evalstr(*ap, DOTILDE|DOPAT)) &&
				gmatch(cp, s, false))
				    goto Found;
@


1.66
log
@In execute() we assign xerrorok to a dummy value if it is NULL
so there is no need to check xerrorok for NULL after that.
From Kartik Agaram.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.65 2016/12/11 17:31:58 millert Exp $	*/
d43 4
a46 1
    volatile int flags, volatile int *xerrok)		/* if XEXEC don't fork */
d48 1
a48 1
	int i, dummy = 0;
d293 1
d296 3
d301 1
@


1.65
log
@Fix for() loop indentation for TCASE  in execute() and add some
braces for improved readability.  Based on a diff from Kartik Agaram.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.64 2015/12/30 09:07:00 tedu Exp $	*/
d243 1
a243 2
			if (xerrok)
				*xerrok = 1;
d250 1
a250 2
		if (xerrok)
			*xerrok = 1;
d384 1
a384 2
	if (rv != 0 && !(flags & XERROK) &&
	    (xerrok == NULL || !*xerrok)) {
@


1.64
log
@rename global "e" to genv to avoid accidental shadowing and aliasing.
ok millert nicm tb
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.63 2015/12/14 13:59:42 tb Exp $	*/
d342 7
a348 5
		for (t = t->left; t != NULL && t->type == TPAT; t = t->right)
		    for (ap = t->vars; *ap; ap++)
			if ((s = evalstr(*ap, DOTILDE|DOPAT)) &&
			    gmatch(cp, s, false))
				goto Found;
@


1.63
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.62 2015/11/01 15:38:53 mmcc Exp $	*/
d104 1
a104 1
		e->savefd = areallocarray(NULL, NUFILE, sizeof(short), ATEMP);
d106 1
a106 1
		memset(e->savefd, 0, NUFILE * sizeof(short));
d137 2
a138 2
		e->savefd[0] = savefd(0);
		e->savefd[1] = savefd(1);
d153 2
a154 2
		restfd(1, e->savefd[1]); /* stdout of last */
		e->savefd[1] = 0; /* no need to re-restore this */
d177 2
a178 2
		e->type = E_ERRH;
		i = sigsetjmp(e->jbuf, 0);
d193 2
a194 2
		e->savefd[0] = savefd(0);
		e->savefd[1] = savefd(1);
d216 1
a216 1
		e->type = E_EXEC; /* no more need for error handler */
d275 2
a276 2
		    e->loc->argv + 1;
		e->type = E_LOOP;
d278 1
a278 1
			i = sigsetjmp(e->jbuf, 0);
d281 1
a281 1
			if ((e->flags&EF_BRKCONT_PASS) ||
d312 1
a312 1
		e->type = E_LOOP;
d314 1
a314 1
			i = sigsetjmp(e->jbuf, 0);
d317 1
a317 1
			if ((e->flags&EF_BRKCONT_PASS) ||
d586 1
a586 1
		e->loc->argv = ap;
d589 1
a589 1
		e->loc->argc = i - 1;
d594 2
a595 2
			e->loc->flags |= BF_DOGETOPTS;
			e->loc->getopts_state = user_opt;
d605 2
a606 2
		e->type = E_FUNC;
		i = sigsetjmp(e->jbuf, 0);
d736 1
a736 1
	for (l = e->loc; l; l = l->next) {
d1126 1
a1126 1
	if (e->savefd[iop->unit] == 0) {
d1129 1
a1129 1
			e->savefd[iop->unit] = -1;
d1137 1
a1137 1
			e->savefd[iop->unit] = savefd(iop->unit);
d1191 1
a1191 1
	h = maketemp(ATEMP, TT_HEREDOC_EXP, &e->temps);
d1203 1
a1203 1
	i = sigsetjmp(e->jbuf, 0);
@


1.62
log
@Add uses of areallocarray(). mksh and Bitrig ksh already have similar
functions. With help from Theo Buehler.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.61 2015/10/19 14:42:16 mmcc Exp $	*/
d10 2
d13 2
d16 1
@


1.61
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.60 2015/10/19 02:15:45 mmcc Exp $	*/
d99 1
a99 1
		e->savefd = alloc(sizeofN(short, NUFILE), ATEMP);
d101 1
a101 1
		memset(e->savefd, 0, sizeofN(short, NUFILE));
@


1.60
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.59 2015/10/17 18:43:22 mmcc Exp $	*/
d11 1
@


1.59
log
@Drop two useless defines.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.58 2015/10/17 18:26:24 mmcc Exp $	*/
d7 5
a13 3
#include <ctype.h>
#include <sys/stat.h>
#include <paths.h>
@


1.58
log
@Move a system header include from the global header (sh.h) into the
files that need it. No binary change.

"This looks fine" -nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.57 2015/09/22 21:50:40 millert Exp $	*/
d692 1
a692 1
	shell = str_val(global(EXECSHELL_STR));
d696 1
a696 1
		shell = EXECSHELL;
@


1.57
log
@Make errorf() and bi_errorf() handle a NULL argument.
From Michael McConville; OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.56 2015/09/18 07:28:24 nicm Exp $	*/
d11 1
@


1.56
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.55 2015/09/17 14:21:33 nicm Exp $	*/
d110 1
a110 1
					errorf(null);
@


1.55
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.54 2015/09/15 18:15:05 tedu Exp $	*/
d171 1
a171 1
			sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d193 1
a193 1
		coproc.job = (void *) 0;
d206 1
a206 1
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d551 1
a551 1
			if (include(tp->u.fpath, 0, (char **) 0, 0) < 0) {
d693 1
a693 1
		shell = search(shell, path, X_OK, (int *) 0);
d725 1
a725 1
	struct tbl *tp = (struct tbl *) 0;
d735 1
a735 1
			tp->val.t = (struct op *) 0;
@


1.54
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.53 2015/09/14 16:08:50 nicm Exp $	*/
d95 1
a95 1
		e->savefd = (short *) alloc(sizeofN(short, NUFILE), ATEMP);
@


1.53
log
@Replace Tflag typedef with just int; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.52 2015/09/10 22:48:58 nicm Exp $	*/
d843 1
a843 1
				tp->u.fpath = (char *) 0;
d900 1
a900 1
		    &tp->u2.errno_)) != (char *) 0) {
d1019 1
a1019 1
	builtin_argv0 = (char *) 0;
d1041 1
a1041 1
	iotmp.name = (iotype == IOHERE) ? (char *) 0 : cp;
d1047 1
a1047 1
		    snptreef((char *) 0, 32, "%R", &iotmp));
d1091 1
a1091 1
			    snptreef((char *) 0, 32, "%R", &iotmp), emsg);
d1137 1
a1137 1
			    snptreef((char *) 0, 32, "%R", &iotmp),
d1174 1
a1174 1
	if (content == (char *) 0) {
d1234 1
a1234 1
		"read", "-r", "REPLY", (char *) 0
d1252 1
a1252 1
			return (char *) 0;
d1408 1
a1408 1
		return (char *) 0;
@


1.52
log
@Replace newline and space defines by "\n" and " " directly, from Michael
McConville. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.51 2015/04/18 18:28:36 deraadt Exp $	*/
d530 1
a530 2
		volatile int old_xflag;
		volatile Tflag old_inuse;
d793 1
a793 1
	Tflag flag;
@


1.51
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.50 2013/06/10 21:09:27 millert Exp $	*/
d86 1
a86 1
				    ap[i + 1] ? space : newline);
d502 1
a502 1
			    t->vars[i + 1] ? space : newline);
@


1.50
log
@POSIX specifies that for an AND/OR list, only the last command's
exit status matters for "set -e".  Revert the part of revision 1.49
that always sets xerrok for AND/OR.  This makes sh/ksh pass the
updated regress tests.  OK espie@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.49 2009/01/29 23:27:26 jaredy Exp $	*/
d1237 1
d1256 4
a1259 2
			i = atoi(s);
			return (i >= 1 && i <= argct) ? ap[i - 1] : null;
@


1.49
log
@pass "xerrok" status across the execution call stack to more closely
match what both POSIX and ksh.1 already describe in regards to set
-e/errexit's behavior in determining when to exit from nonzero return
values.

specifically, the truth values tested as operands to `&&' and `||', as
well as the resulting compound expression itself, along with the truth
value resulting from a negated command (i.e. a pipeline prefixed `!'),
should not make the shell exit when -e is in effect.

issue reported by matthieu.
testing matthieu, naddy.
ok miod (earlier version), otto.
man page ok jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.48 2007/09/05 19:02:01 otto Exp $	*/
d231 6
a236 4
			rv = execute(t->right, XERROK, xerrok);
		flags |= XERROK;
		if (xerrok)
			*xerrok = 1;
@


1.48
log
@Call ERR trap _before_ doing exit handling. Otherwise it's too late
and the ERR trap won't get called at all. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.47 2007/08/02 10:52:10 fgsch Exp $	*/
d16 1
a16 1
		    int volatile);
d34 1
a34 1
    volatile int flags)		/* if XEXEC don't fork */
d36 1
a36 1
	int i;
d47 4
d60 1
a60 1
		return exchild(t, flags & ~XTIME, -1); /* run in sub-process */
d118 1
a118 1
		rv = comexec(t, tp, ap, flags);
d122 1
a122 1
		rv = execute(t->left, flags|XFORK);
d138 1
a138 1
			exchild(t->left, flags|XPIPEO|XCCLOSE, pv[0]);
d147 1
a147 1
		i = exchild(t, flags|XPCLOSE, 0);
d154 1
a154 1
			execute(t->left, flags & XERROK);
d157 1
a157 1
		rv = execute(t, flags & XERROK);
d215 1
a215 1
		    coproc.readw);
d224 1
a224 1
		rv = execute(t->left, (flags&~XEXEC)|XBGND|XFORK);
d229 6
a234 5
		rv = execute(t->left, XERROK);
		if (t->right != NULL && (rv == 0) == (t->type == TAND))
			rv = execute(t->right, flags & XERROK);
		else
			flags |= XERROK;
d238 4
a241 1
		rv = !execute(t->right, XERROK);
d283 1
a283 1
				rv = execute(t->left, flags & XERROK);
d293 1
a293 1
				rv = execute(t->left, flags & XERROK);
d316 2
a317 2
		while ((execute(t->left, XERROK) == 0) == (t->type == TWHILE))
			rv = execute(t->right, flags & XERROK);
d324 3
a326 3
		rv = execute(t->left, XERROK) == 0 ?
		    execute(t->right->left, flags & XERROK) :
		    execute(t->right->right, flags & XERROK);
d338 1
a338 1
		rv = execute(t->left, flags & XERROK);
d342 1
a342 1
		rv = execute(t->left, flags & XERROK);
d353 1
a353 1
		rv = timex(t, flags & ~XEXEC);
d373 2
a374 1
	if (rv != 0 && !(flags & XERROK)) {
d387 2
a388 1
comexec(struct op *t, struct tbl *volatile tp, char **ap, volatile int flags)
d599 1
a599 1
			exstat = execute(tp->val.t, flags & XERROK);
d674 1
a674 1
		rv = exchild(&texec, flags, -1);
@


1.47
log
@another memory leak fix found by coverity. from netbsd but modified.
millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.46 2006/04/10 14:38:59 jaredy Exp $	*/
d366 1
a368 1
		trapsig(SIGERR_);
@


1.46
log
@fix lint comments, no functional changes; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.45 2006/03/17 16:30:13 millert Exp $	*/
d878 7
a884 1
			tp->val.s = tp == &temp ? npath : str_save(npath, APERM);
@


1.45
log
@Simplify savefd() by removing the "noclose" flag and make noclose
behavior the default.  Almost all uses of savefd() are followed
by an implicit or explicit close.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.44 2005/12/11 20:31:21 otto Exp $	*/
d170 1
a170 1
			/*NOTREACHED*/
d617 1
a617 1
			/*NOTREACHED*/
@


1.44
log
@fix a few name clashes with libc; found by lint. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.43 2005/12/11 18:53:51 deraadt Exp $	*/
d124 2
a125 3
		e->savefd[0] = savefd(0, 0);
		(void) ksh_dup2(e->savefd[0], 0, false); /* stdin of first */
		e->savefd[1] = savefd(1, 0);
d180 2
a181 2
		e->savefd[0] = savefd(0, 0);
		e->savefd[1] = savefd(1, 0);
d1111 1
a1111 1
			e->savefd[iop->unit] = savefd(iop->unit, 1);
@


1.43
log
@remove unused variables and functions
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.42 2005/09/11 18:02:27 otto Exp $	*/
d701 1
a701 1
	tp = tsearch(&builtins, *wp, hash(*wp));
d718 1
a718 1
		tp = tsearch(&l->funs, name, h);
d722 1
a722 1
			tp = tenter(&l->funs, name, h);
d764 1
a764 1
		tdelete(tp);
d797 1
a797 1
	tp = tenter(&builtins, name, hash(name));
d823 1
a823 1
	tbi = (flags & FC_BI) ? tsearch(&builtins, name, h) : NULL;
d853 1
a853 1
		tp = tsearch(&taliases, name, h);
d868 1
a868 1
				tp = tenter(&taliases, name, h);
d908 1
a908 1
	for (twalk(&ts, &taliases); (tp = tnext(&ts)) != NULL; )
@


1.42
log
@Fix " handling in here documents. POSIX says they are not special, so
cat << EOF
\"
EOF
should print \"
Fixes PR 4472; testing jmc@@ and Adam Montague. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.41 2005/03/30 17:16:37 deraadt Exp $	*/
d1249 1
a1249 1
} info;
@


1.41
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.40 2005/03/28 21:28:22 deraadt Exp $	*/
d1190 1
a1190 1
		if (yylex(ONEWORD) != LWORD)
@


1.40
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.39 2004/12/22 18:57:28 otto Exp $	*/
d82 1
a82 1
					ap[i + 1] ? space : newline);
d104 2
a105 2
				if (tp && tp->type == CSHELL
				    && (tp->flag & SPEC_BI))
d112 2
a113 2
	switch(t->type) {
	  case TCOM:
d117 1
a117 1
	  case TPAREN:
d121 1
a121 1
	  case TPIPE:
d149 1
a149 1
	  case TLIST:
d157 2
a158 2
	  case TCOPROC:
	  {
d212 1
a212 1
			coproc.readw);
d214 1
a214 1
	  }
d216 1
a216 1
	  case TASYNC:
d224 2
a225 2
	  case TOR:
	  case TAND:
d233 1
a233 1
	  case TBANG:
d237 1
a237 1
	  case TDBRACKET:
d252 2
a253 2
	  case TFOR:
	  case TSELECT:
d256 2
a257 3
		ap = (t->vars != NULL) ?
			  eval(t->vars, DOBLANK|DOGLOB|DOTILDE)
			: e->loc->argv + 1;
d263 2
a264 3
			if ((e->flags&EF_BRKCONT_PASS)
			    || (i != LBREAK && i != LCONTIN))
			{
d292 2
a293 2
	  case TWHILE:
	  case TUNTIL:
d299 2
a300 3
			if ((e->flags&EF_BRKCONT_PASS)
			    || (i != LBREAK && i != LCONTIN))
			{
d313 2
a314 2
	  case TIF:
	  case TELIF:
d318 2
a319 2
			execute(t->right->left, flags & XERROK) :
			execute(t->right->right, flags & XERROK);
d322 1
a322 1
	  case TCASE:
d326 2
a327 2
			if ((s = evalstr(*ap, DOTILDE|DOPAT))
			    && gmatch(cp, s, false))
d334 1
a334 1
	  case TBRACE:
d338 1
a338 1
	  case TFUNCT:
d342 1
a342 1
	  case TTIME:
d349 1
a349 1
	  case TEXEC:		/* an eval'd TCOM */
d401 1
a401 1
		       KSH_RETURN_ERROR);
d440 1
a440 2
			while ((optc = ksh_getopt(ap, &builtin_opt, ":p"))
									== 'p')
d449 1
a449 1
						"command -p: restricted");
d475 2
a476 2
		if (keepasn_ok && tp && tp->type == CFUNC
		    && !(tp->flag & FKSH)) {
d489 1
a489 1
					PS4_SUBSTITUTE(str_val(global("PS4"))));
d491 1
a491 1
				t->vars[i + 1] ? space : newline);
d513 1
a513 1
	  case CSHELL:			/* shell built-in */
d517 2
a518 2
	  case CFUNC:			/* function call */
	  {
d529 3
a531 2
				"%s: can't find function definition file - %s",
						cp, strerror(tp->u2.errno_));
d535 2
a536 1
				"%s: can't find function definition file", cp);
d543 2
a544 2
			    "%s: can't open function definition file %s - %s",
					cp, tp->u.fpath, strerror(errno));
d548 2
a549 3
			if (!(ftp = findfunc(cp, hash(cp), false))
			    || !(ftp->flag & ISSET))
			{
d551 2
a552 2
					"%s: function not defined by %s",
					cp, tp->u.fpath);
d608 2
a609 2
		  case LRETURN:
		  case LERROR:
d612 4
a615 4
		  case LINTR:
		  case LEXIT:
		  case LLEAVE:
		  case LSHELL:
d619 1
a619 1
		  default:
d624 1
a624 1
	  }
d626 2
a627 2
	  case CEXEC:		/* executable command */
	  case CTALIAS:		/* tracked alias */
d636 1
a636 1
					strerror(tp->u2.errno_));
d649 1
a649 1
			       tp->val.s, KSH_RETURN_ERROR);
d837 1
a837 1
					&tp->u2.errno_);
d864 2
a865 3
	if ((!tp || (tp->type == CTALIAS && !(tp->flag&ISSET)))
	    && (flags & FC_PATH))
	{
d877 1
a877 1
				X_OK, &tp->u2.errno_);
d881 4
a884 5
		} else if ((flags & FC_FUNC)
			   && (fpath = str_val(global("FPATH"))) != null
			   && (npath = search(name, fpath, R_OK,
					      &tp->u2.errno_)) != (char *) 0)
		{
d931 3
a933 5
	else if (mode == X_OK
		 && (!S_ISREG(statb.st_mode)
		     /* This 'cause access() says root can execute everything */
		     || !(statb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH))))
	{
d1030 2
a1031 2
			PS4_SUBSTITUTE(str_val(global("PS4"))),
			snptreef((char *) 0, 32, "%R", &iotmp));
d1034 1
a1034 1
	  case IOREAD:
d1038 1
a1038 1
	  case IOCAT:
d1042 1
a1042 1
	  case IOWRITE:
d1047 2
a1048 2
		if (Flag(FNOCLOBBER) && !(iop->flag & IOCLOB)
		    && (stat(cp, &statb) < 0 || S_ISREG(statb.st_mode)))
d1052 1
a1052 1
	  case IORDWR:
d1056 1
a1056 1
	  case IOHERE:
d1063 2
a1064 2
	  case IODUP:
	  {
d1072 2
a1073 3
				X_OK | ((iop->flag & IORDUP) ? R_OK : W_OK),
				&emsg)) < 0)
		{
d1075 1
a1075 1
				snptreef((char *) 0, 32, "%R", &iotmp), emsg);
d1081 1
a1081 1
	  }
d1083 1
d1095 3
a1097 3
			       iotype == IODUP ? "dup"
				: (iotype == IOREAD || iotype == IOHERE) ?
				    "open" : "create", cp, strerror(errno));
d1120 3
a1122 3
				"could not finish (dup) redirection %s: %s",
				snptreef((char *) 0, 32, "%R", &iotmp),
				strerror(errno));
d1169 2
a1170 2
			!shf ? "create" : "open",
			h->name, strerror(errno));
d1202 1
a1202 1
			strerror(errno));
d1218 2
a1219 2
					"read", "-r", "REPLY", (char *) 0
				    };
d1260 1
a1260 1
		smi->num_width, i + 1, smi->args[i]);
d1301 1
a1301 1
		dwidth + nwidth + 2, 1);
d1364 2
a1365 3
			for (p = *te->pos.wp; *p == CHAR
					      && q < &buf[sizeof(buf) - 1];
					      p += 2)
d1373 2
a1374 2
		ret = uqword
			&& strcmp(*te->pos.wp, dbtest_tokens[(int) meta]) == 0;
@


1.39
log
@Fix a use-after-free, that causs core dumps if a shell is killed
running with strict malloc.conf options. Problem spotted by hshoexer@@;
fix by me with some help from millert@@.

ok millert@@ hshoexer@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.38 2004/12/22 17:14:34 millert Exp $	*/
d21 1
a21 1
static char 	*do_selectargs(char **, bool);
a811 2
	                 
	   	      		/* FC_* */
d908 1
a908 2
flushcom(int all)
	        		/* just relative or all */
@


1.38
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.37 2004/12/20 11:34:26 otto Exp $	*/
d169 1
a169 1
			quitenv();
d267 1
a267 1
				quitenv();
d304 1
a304 1
				quitenv();
d366 1
a366 1
	quitenv();		/* restores IO */
d619 1
a619 1
			quitenv();
d623 1
a623 1
			quitenv();
d1191 1
a1191 2
		quitenv();
		shf_close(shf);	/* after quitenv */
d1207 1
a1207 1
	quitenv();
@


1.37
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.36 2004/12/19 04:14:20 deraadt Exp $	*/
d21 1
a21 1
static char 	*do_selectargs(char **, bool_t);
d49 1
a49 1
	bool_t eval_done = FALSE;
d51 1
a51 1
		eval_done = TRUE;
d125 1
a125 1
		(void) ksh_dup2(e->savefd[0], 0, FALSE); /* stdin of first */
d129 1
a129 1
			(void) ksh_dup2(pv[1], 1, FALSE); /* stdout of curr */
d136 1
a136 1
			(void) ksh_dup2(pv[0], 0, FALSE); /* stdin of next */
d178 1
a178 1
		coproc_cleanup(TRUE);
d186 1
a186 1
			ksh_dup2(pv[0], 0, FALSE);
d193 1
a193 1
			ksh_dup2(coproc.readw, 1, FALSE);
d197 1
a197 1
			ksh_dup2(pv[1], 1, FALSE);
d255 1
a255 1
		volatile bool_t is_first = TRUE;
d286 1
a286 1
				is_first = FALSE;
d330 1
a330 1
			    && gmatch(cp, s, FALSE))
d452 1
a452 1
					warningf(TRUE,
d509 1
a509 1
			warningf(TRUE, "%s: restricted", cp);
d532 1
a532 1
					warningf(TRUE,
d537 1
a537 1
					warningf(TRUE,
d544 1
a544 1
				warningf(TRUE,
d550 1
a550 1
			if (!(ftp = findfunc(cp, hash(cp), FALSE))
d553 1
a553 1
				warningf(TRUE,
d584 1
a584 1
		Flag(FXTRACE) = tp->flag & TRACE ? TRUE : FALSE;
d638 1
a638 1
				warningf(TRUE, "%s: cannot execute - %s", cp,
d642 1
a642 1
				warningf(TRUE, "%s: not found", cp);
d746 1
a746 1
		tp = findfunc(name, hash(name), TRUE);
d835 1
a835 1
		tp = findfunc(name, h, FALSE);
d1085 1
a1085 1
			warningf(TRUE, "%s: %s",
d1096 1
a1096 1
			warningf(TRUE, "%s: restricted", cp);
d1104 1
a1104 1
			warningf(TRUE, "cannot %s %s: %s",
d1128 2
a1129 2
		if (ksh_dup2(u, iop->unit, TRUE) < 0) {
			warningf(TRUE,
d1169 1
a1169 1
		warningf(TRUE, "here document missing");
d1178 1
a1178 1
		warningf(TRUE, "can't %s temporary file %s: %s",
d1212 1
a1212 1
		warningf(TRUE, "error writing %s: %s", h->name,
d1226 1
a1226 1
do_selectargs(char **ap, bool_t print_menu)
@


1.36
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.35 2004/12/18 22:35:41 millert Exp $	*/
d15 12
a26 13
static int	comexec(struct op *t, struct tbl *volatile tp, char **ap,
			      int volatile flags);
static void	scriptexec(struct op *tp, char **ap);
static int	call_builtin(struct tbl *tp, char **wp);
static int	iosetup(struct ioword *iop, struct tbl *tp);
static int	herein(const char *content, int sub);
static char 	*do_selectargs(char **ap, bool_t print_menu);
static int	dbteste_isa(Test_env *te, Test_meta meta);
static const char *dbteste_getopnd(Test_env *te, Test_op op,
					 int do_eval);
static int	dbteste_eval(Test_env *te, Test_op op, const char *opnd1,
				const char *opnd2, int do_eval);
static void	dbteste_error(Test_env *te, int offset, const char *msg);
d33 2
a34 3
execute(t, flags)
	struct op * volatile t;
	volatile int flags;	/* if XEXEC don't fork */
d382 1
a382 5
comexec(t, tp, ap, flags)
	struct op *t;
	struct tbl *volatile tp;
	char **ap;
	int volatile flags;
d680 1
a680 3
scriptexec(tp, ap)
	struct op *tp;
	char **ap;
d700 1
a700 2
shcomexec(wp)
	char **wp;
d715 1
a715 4
findfunc(name, h, create)
	const char *name;
	unsigned int h;
	int create;
d740 1
a740 3
define(name, t)
	const char *name;
	struct op *t;
d783 1
a783 3
builtin(name, func)
	const char *name;
	int (*func)(char **);
d811 3
a813 3
findcom(name, flags)
	const char *name;
	int	flags;		/* FC_* */
d910 2
a911 2
flushcom(all)
	int all;		/* just relative or all */
d928 2
a929 4
search_access(path, mode, errnop)
	const char *path;
	int mode;
	int *errnop;		/* set if candidate found, but not suitable */
d956 3
a958 5
search(name, path, mode, errnop)
	const char *name;
	const char *path;
	int mode;		/* R_OK or X_OK */
	int *errnop;		/* set if candidate found, but not suitable */
d1000 1
a1000 3
call_builtin(tp, wp)
	struct tbl *tp;
	char **wp;
d1021 1
a1021 3
iosetup(iop, tp)
	struct ioword *iop;
	struct tbl *tp;
d1159 1
a1159 3
herein(content, sub)
	const char *content;
	int sub;
d1226 1
a1226 3
do_selectargs(ap, print_menu)
	char **ap;
	bool_t print_menu;
d1266 1
a1266 5
select_fmt_entry(arg, i, buf, buflen)
	void *arg;
	int i;
	char *buf;
	int buflen;
d1279 1
a1279 2
pr_menu(ap)
	char *const *ap;
d1322 1
a1322 5
plain_fmt_entry(arg, i, buf, buflen)
	void *arg;
	int i;
	char *buf;
	int buflen;
d1329 1
a1329 2
pr_list(ap)
	char *const *ap;
d1357 1
a1357 3
dbteste_isa(te, meta)
	Test_env *te;
	Test_meta meta;
d1396 1
a1396 4
dbteste_getopnd(te, op, do_eval)
	Test_env *te;
	Test_op op;
	int do_eval;
d1417 2
a1418 6
dbteste_eval(te, op, opnd1, opnd2, do_eval)
	Test_env *te;
	Test_op op;
	const char *opnd1;
	const char *opnd2;
	int do_eval;
d1424 1
a1424 4
dbteste_error(te, offset, msg)
	Test_env *te;
	int offset;
	const char *msg;
@


1.35
log
@Replace fd_clexec() with calls to fcntl(fd, F_SETFD, FD_CLOEXEC)
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.34 2004/12/18 21:25:44 millert Exp $	*/
d113 1
a113 1
	
d1010 1
a1010 1
 		if (search_access(Xstring(xs, xp), mode, errnop) == 0)
@


1.34
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.33 2004/12/18 21:04:52 millert Exp $	*/
a27 11


/*
 * we now use this function always.
 */
int
fd_clexec(fd)
    int fd;
{
	return fcntl(fd, F_SETFD, 1);
}
@


1.33
log
@Get rid of #ifdef KSH since we don't care about building a V7 style sh and
the #ifdef KSH code is required to make a POSIX sh.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.32 2004/12/18 20:55:52 millert Exp $	*/
d398 1
a398 1
	register char **ap;
d403 2
a404 2
	register char *cp;
	register char **lastp;
d698 2
a699 2
	register struct op *tp;
	register char **ap;
d720 1
a720 1
	register char **wp;
d722 1
a722 1
	register struct tbl *tp;
d812 1
a812 1
	register struct tbl *tp;
d1055 1
a1055 1
	register struct ioword *iop;
d1058 1
a1058 1
	register int u = -1;
d1264 1
a1264 1
	register char **ap;
@


1.32
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.31 2003/12/15 05:25:52 otto Exp $	*/
a12 1
#ifdef KSH
a13 3
#else
# define PS4_SUBSTITUTE(s)	(s)
#endif /* KSH */
a20 1
#ifdef KSH
a21 2
#endif /* KSH */
#ifdef KSH
a27 1
#endif /* KSH */
a169 1
#ifdef KSH
a227 1
#endif /* KSH */
a249 1
#ifdef KSH
a263 1
#endif /* KSH */
a265 1
#ifdef KSH
a268 1
#endif /* KSH */
d293 1
a293 3
		}
#ifdef KSH
		else { /* TSELECT */
a304 1
#endif /* KSH */
a410 1
#ifdef KSH
a422 1
#endif /* KSH */
a664 1
#ifdef KSH
a670 1
#endif /* KSH */
a1173 1
#ifdef KSH
a1182 1
#endif /* KSH */
d1257 1
a1257 1
#if defined(KSH) || defined(EDIT)
d1392 1
a1392 2
#endif /* KSH || EDIT */
#ifdef KSH
a1489 1
#endif /* KSH */
@


1.31
log
@Unbreak parameter assignment when calling bourne style functions;
resolves PR 2450.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.30 2003/11/10 21:26:39 millert Exp $	*/
d10 1
a10 1
#include "ksh_stat.h"
d19 6
a24 6
static int	comexec	 ARGS((struct op *t, struct tbl *volatile tp, char **ap,
			      int volatile flags));
static void	scriptexec ARGS((struct op *tp, char **ap));
static int	call_builtin ARGS((struct tbl *tp, char **wp));
static int	iosetup ARGS((struct ioword *iop, struct tbl *tp));
static int	herein ARGS((const char *content, int sub));
d26 1
a26 1
static char 	*do_selectargs ARGS((char **ap, bool_t print_menu));
d29 6
a34 6
static int	dbteste_isa ARGS((Test_env *te, Test_meta meta));
static const char *dbteste_getopnd ARGS((Test_env *te, Test_op op,
					 int do_eval));
static int	dbteste_eval ARGS((Test_env *te, Test_op op, const char *opnd1,
				const char *opnd2, int do_eval));
static void	dbteste_error ARGS((Test_env *te, int offset, const char *msg));
a35 3
#ifdef OS2
static int	search_access1 ARGS((const char *path, int mode, int *errnop));
#endif /* OS2 */
a38 11
 * handle systems that don't have F_SETFD
 */
#ifndef F_SETFD
# ifndef MAXFD
#   define  MAXFD 64
# endif
/* a bit field would be smaller, but this will work */
static char clexec_tab[MAXFD+1];
#endif

/*
a44 7
#ifndef F_SETFD
	if (fd >= 0 && fd < sizeof(clexec_tab)) {
		clexec_tab[fd] = 1;
		return 0;
	}
	return -1;
#else
a45 1
#endif
a180 1
# ifdef JOB_SIGS
a181 1
# endif /* JOB_SIGS */
a182 1
# ifdef JOB_SIGS
d188 1
a188 1
		i = ksh_sigsetjmp(e->jbuf, 0);
a194 1
# endif /* JOB_SIGS */
a224 1
# ifdef JOB_SIGS
a226 1
# endif /* JOB_SIGS */
d288 1
a288 1
			i = ksh_sigsetjmp(e->jbuf, 0);
d328 1
a328 1
			i = ksh_sigsetjmp(e->jbuf, 0);
a384 7
#ifndef F_SETFD
		for (i = 0; i < sizeof(clexec_tab); i++)
			if (clexec_tab[i]) {
				close(i);
				clexec_tab[i] = 0;
			}
#endif
d387 1
a387 2
		/* XINTACT bit is for OS2 */
		ksh_execve(t->str, t->args, ap, (flags & XINTACT) ? 1 : 0);
d544 1
a544 1
		if (Flag(FRESTRICTED) && ksh_strchr_dirsep(cp)) {
d626 1
a626 1
		i = ksh_sigsetjmp(e->jbuf, 0);
a730 92
#ifdef	SHARPBANG
	{
		char buf[LINE];
		register char *cp;
		register int fd, n;

		buf[0] = '\0';
		if ((fd = open(tp->str, O_RDONLY)) >= 0) {
			if ((n = read(fd, buf, LINE - 1)) > 0)
				buf[n] = '\0';
			(void) close(fd);
		}
		if ((buf[0] == '#' && buf[1] == '!' && (cp = &buf[2]))
# ifdef OS2
		    || (strncmp(buf, "extproc", 7) == 0 && isspace(buf[7])
			&& (cp = &buf[7]))
# endif /* OS2 */
		    )
		{
			while (*cp && (*cp == ' ' || *cp == '\t'))
				cp++;
			if (*cp && *cp != '\n') {
				char *a0 = cp, *a1 = (char *) 0;
# ifdef OS2
				char *a2 = cp;
# endif /* OS2 */

				while (*cp && *cp != '\n' && *cp != ' '
				       && *cp != '\t')
				{
# ifdef OS2
			/* Allow shell search without prepended path
			 * if shell with / in pathname cannot be found.
			 * Use / explicitly so \ can be used if explicit
			 * needs to be forced.
			 */
					if (*cp == '/')
						a2 = cp + 1;
# endif /* OS2 */
					cp++;
				}
				if (*cp && *cp != '\n') {
					*cp++ = '\0';
					while (*cp
					       && (*cp == ' ' || *cp == '\t'))
						cp++;
					if (*cp && *cp != '\n') {
						a1 = cp;
						/* all one argument */
						while (*cp && *cp != '\n')
							cp++;
					}
				}
				if (*cp == '\n') {
					*cp = '\0';
					if (a1)
						*tp->args-- = a1;
# ifdef OS2
					if (a0 != a2) {
						char *tmp_a0 = str_nsave(a0,
							strlen(a0) + 5, ATEMP);
						if (search_access(tmp_a0, X_OK,
								(int *) 0))
							a0 = a2;
						afree(tmp_a0, ATEMP);
					}
# endif /* OS2 */
					shell = a0;
				}
			}
# ifdef OS2
		} else {
		        /* Use ksh documented shell default if present
			 * else use OS2_SHELL which is assumed to need
			 * the /c option and '\' as dir separator.
			 */
		         char *p = shell;

			 shell = str_val(global("EXECSHELL"));
			 if (shell && *shell)
				 shell = search(shell, path, X_OK, (int *) 0);
			 if (!shell || !*shell) {
				 shell = p;
				 *tp->args-- = "/c";
				 for (p = tp->str; *p; p++)
					 if (*p == '/')
						 *p = '\\';
			 }
# endif /* OS2 */
		}
	}
#endif	/* SHARPBANG */
d733 1
a733 1
	ksh_execve(tp->args[0], tp->args, ap, 0);
d831 1
a831 1
	int (*func) ARGS((char **));
d870 1
a870 1
	if (ksh_strchr_dirsep(name) != NULL) {
d907 1
a907 1
		if (tp && (tp->flag & ISSET) && eaccess(tp->val.s, X_OK) != 0) {
d965 1
a965 1
		if ((tp->flag&ISSET) && (all || !ISDIRSEP(tp->val.s[0]))) {
a980 1
#ifndef OS2
d986 1
a986 1
	ret = eaccess(path, mode);
a999 41
#else /* !OS2 */
	/*
	 * NOTE: ASSUMES path can be modified and has enough room at the
	 *       end of the string for a suffix (ie, 4 extra characters).
	 *	 Certain code knows this (eg, eval.c(globit()),
	 *	 exec.c(search())).
	 */
	static char *xsuffixes[] = { ".ksh", ".exe", ".", ".sh", ".cmd",
				     ".com", ".bat", (char *) 0
				   };
	static char *rsuffixes[] = { ".ksh", ".", ".sh", ".cmd", ".bat",
				      (char *) 0
				   };
	int i;
	char *mpath = (char *) path;
	char *tp = mpath + strlen(mpath);
	char *p;
	char **sfx;

	/* If a suffix has been specified, check if it is one of the
	 * suffixes that indicate the file is executable - if so, change
	 * the access test to R_OK...
	 * This code assumes OS/2 files can have only one suffix...
	 */
	if ((p = strrchr((p = ksh_strrchr_dirsep(mpath)) ? p : mpath, '.'))) {
		if (mode == X_OK)
			mode = R_OK;
		return search_access1(mpath, mode, errnop);
	}
	/* Try appending the various suffixes.  Different suffixes for
	 * read and execute 'cause we don't want to read an executable...
	 */
	sfx = mode == R_OK ? rsuffixes : xsuffixes;
	for (i = 0; sfx[i]; i++) {
		strcpy(tp, p = sfx[i]);
		if (search_access1(mpath, R_OK, errnop) == 0)
			return 0;
		*tp = '\0';
	}
	return -1;
#endif /* !OS2 */
a1001 25
#ifdef OS2
static int
search_access1(path, mode, errnop)
	const char *path;
	int mode;
	int *errnop;		/* set if candidate found, but not suitable */
{
	int ret, err = 0;
	struct stat statb;

	if (stat(path, &statb) < 0)
		return -1;
	ret = eaccess(path, mode);
	if (ret < 0)
		err = errno; /* File exists, but we can't access it */
	else if (!S_ISREG(statb.st_mode)) {
		ret = -1;
		err = S_ISDIR(statb.st_mode) ? EISDIR : EACCES;
	}
	if (err && errnop && !*errnop)
		*errnop = err;
	return ret;
}
#endif /* OS2 */

d1019 1
a1019 20
#ifdef OS2
	/* Xinit() allocates 8 additional bytes, so appended suffixes won't
	 * overflow the memory.
	 */
	namelen = strlen(name) + 1;
	Xinit(xs, xp, namelen, ATEMP);
	memcpy(Xstring(xs, xp), name, namelen);

 	if (ksh_strchr_dirsep(name)) {
		if (search_access(Xstring(xs, xp), mode, errnop) >= 0)
			return Xstring(xs, xp); /* not Xclose() - see above */
		Xfree(xs, xp);
		return NULL;
	}

	/* Look in current context always. (os2 style) */
	if (search_access(Xstring(xs, xp), mode, errnop) == 0)
		return Xstring(xs, xp); /* not Xclose() - xp may be wrong */
#else /* OS2 */
	if (ksh_strchr_dirsep(name)) {
a1026 1
#endif /* OS2 */
d1031 1
a1031 1
		if (!(p = strchr(sp, PATHSEP)))
d1037 1
a1037 1
			*xp++ = DIRSEP;
a1042 3
#ifdef OS2
 			return Xstring(xs, xp); /* Not Xclose() - see above */
#else /* OS2 */
a1043 1
#endif /* OS2 */
d1082 1
a1082 1
	int do_open = 1, do_close = 0, UNINITIALIZED(flags);
a1155 4
#ifdef OS2
		if (u < 0 && strcmp(cp, "/dev/null") == 0)
			u = open("nul", flags, 0666);
#endif /* OS2 */
d1248 1
a1248 1
	i = ksh_sigsetjmp(e->jbuf, 0);
d1324 1
a1324 1
static char *select_fmt_entry ARGS((void *arg, int i, char *buf, int buflen));
d1386 1
a1386 1
static char *plain_fmt_entry ARGS((void *arg, int i, char *buf, int buflen));
@


1.30
log
@If "from fd" == "to fd" don't call dup2() or close "from fd".
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.29 2003/11/10 21:24:30 millert Exp $	*/
d462 1
d552 2
a553 1
		    && !(tp->flag & FKSH))
d555 1
a555 1
		else
d572 2
@


1.29
log
@For the >& and <& operators, add a check for "dup from" == "dup to" and
just return success if they are the same.  Fixes the "ls 2>&2" problem
miod@@ found.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.28 2003/10/22 07:40:38 jmc Exp $	*/
d233 4
a236 2
		ksh_dup2(pv[0], 0, FALSE);
		close(pv[0]);
@


1.28
log
@typos from Jared Yanovich;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.27 2003/02/28 09:45:09 jmc Exp $	*/
d1358 2
@


1.27
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.26 2002/06/09 05:47:27 todd Exp $	*/
d464 1
a464 1
	 * functions/dot scripts, but in interactive and scipt) -
@


1.26
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.25 2002/01/16 01:28:54 millert Exp $	*/
d835 1
a835 1
			 * the /c option and '\' as dir separater.
@


1.25
log
@Use the volatile specifier to fix warnings about variables being
clobbered by longjmp / vfork instead of the gcc "(void)&foo;" hack.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.24 2001/07/19 16:46:27 millert Exp $	*/
d104 1
a104 1
 
d1141 1
a1141 1
 
d1148 1
a1148 1
		if (mode == X_OK) 
d1224 1
a1224 1
	if (search_access(Xstring(xs, xp), mode, errnop) == 0) 
@


1.24
log
@Back out last change, it caused problems with exit vals.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.22 2001/02/19 09:49:52 camield Exp $	*/
d453 1
a453 1
	int rv = 0;
a459 4

#ifdef __GNUC__
	(void)&rv;
#endif
@


1.23
log
@Merge in pdksh-5.2.14-patches.2 to fix some problems with propagated
return values in multi-command lines.
@
text
@a80 1
	volatile int rv_prop = 0; /* rv being propogated or newly generated? */
a161 1
		rv_prop = 1;
a279 1
		rv_prop = 1;
a327 1
		rv_prop = 1;
a338 1
					rv_prop = 0;
a369 1
		rv_prop = 1;
a378 1
		rv_prop = 1;
a390 1
		rv_prop = 1;
a394 1
		rv_prop = 1;
a405 1
		rv_prop = 1;
d433 1
a433 1
	if (rv != 0 && !rv_prop && !(flags & XERROK)) {
@


1.22
log
@bash-like 'double-tab' completion

- bind TAB (^I) to complete-list by default
- complete-list now lists 'ls style' not 'menu style'
- complete-list first completes; if that does not work, it lists
- fix a memleak in emacs.c, do_complete
- completion now works after '=' (dd), and ':' (ssh) and ` (backtick)
- a command can now start with a subdir from the current dir
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.21 1999/07/15 20:35:33 millert Exp $	*/
d81 1
d163 1
d282 1
d331 1
d343 1
d375 1
d385 1
d398 1
d403 1
d415 1
d443 1
a443 1
	if (rv != 0 && !(flags & XERROK)) {
@


1.21
log
@silence -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.20 1999/07/14 15:05:27 millert Exp $	*/
d1598 33
a1630 1
		dwidth + nwidth + 2);
@


1.20
log
@Official fix for workaround in 1.18
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.19 1999/07/14 13:37:23 millert Exp $	*/
d1386 1
a1386 1
	if (e->savefd[iop->unit] == 0)
d1398 1
@


1.19
log
@pdksh-5.2.14
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.18 1999/06/23 10:30:51 millert Exp $	*/
a1365 2
		int nfd;

a1370 8
		if (u >= 0 && u < 3) {
			/* Don't reuse stdin/stdout/stderr */
			nfd = ksh_dupbase(u, 3);
			if (nfd != -1) {
				close(u);
				u = nfd;
			}
		}
d1387 11
a1397 6
		/* c_exec() assumes e->savefd[fd] set for any redirections.
		 * Ask savefd() not to close iop->unit - allows error messages
		 * to be seen if iop->unit is 2; also means we can't lose
		 * the fd (eg, both dup2 below and dup2 in restfd() failing).
		 */
		e->savefd[iop->unit] = savefd(iop->unit, 1);
@


1.18
log
@When redirecting to a file with stdout closed, don't blithely reuse
fd 1 since that will cause future output on stdout to go to the file
that was redirected.  There is probably a better fix for this.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.17 1999/06/15 01:18:33 millert Exp $	*/
d99 1
a99 1
		return exchild(t, flags, -1); /* run in sub-process */
d117 3
d131 1
@


1.17
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.16 1999/01/19 20:41:52 millert Exp $	*/
d1362 2
d1369 8
@


1.16
log
@Updates from pdksh-unstable-5.2.13.7.  Most notable change is:
    trap: exit traps now executed in subshells (without explicit exit call).
See the Changelog for a full list of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.15 1999/01/10 17:55:02 millert Exp $	*/
d24 1
a24 1
static int	herein ARGS((char *hname, int sub));
d111 2
a324 2
			struct tbl *vq;

d326 1
a326 7
				vq = global(t->str);
				if (vq->flag & RDONLY)
					errorf("%s is read only", t->str);
				/* SETSTR: fail (put readonly check in setstr,
				 * controlled by a flag?)
				 */
				setstr(vq, *ap++);
a331 2
			struct tbl *vq;

d338 1
a338 7
				vq = global(t->str);
				if (vq->flag & RDONLY)
					errorf("%s is read only", t->str);
				/* SETSTR: fail (put readonly check in setstr,
				 * controlled by a flag?)
				 */
				setstr(vq, cp);
d398 4
a401 1
		rv = timex(t, flags);
d470 3
a472 2
		/* SETSTR: can't fail */
		setstr(typeset("_", LOCAL, 0, INTEGER, 0), *--lastp);
d717 3
a719 2
			/* SETSTR: can't fail */
			setstr(typeset("_", LOCAL|EXPORT, 0, 0, 0), tp->val.s);
d880 2
a881 2
	unsigned int	h;
	int	create;
d942 1
a942 1
	    tp->flag |= FKSH;
d1323 3
d1338 1
a1338 1
		u = herein(cp, iop->flag & IOEVAL);
d1426 2
a1427 2
herein(hname, sub)
	char *hname;
d1430 5
a1434 1
	int fd;
d1437 1
a1437 1
	if (hname == (char *) 0) {
d1441 24
d1466 3
a1468 22
		char *cp;
		struct source *s, *volatile osource = source;
		struct temp *h;
		struct shf *volatile shf;
		int i;

		/* must be before newenv() 'cause shf uses ATEMP */
		shf = shf_open(hname, O_RDONLY, 0, SHF_MAPHI|SHF_CLEXEC);
		if (shf == NULL)
			return -1;
		newenv(E_ERRH);
		i = ksh_sigsetjmp(e->jbuf, 0);
		if (i) {
			if (shf)
				shf_close(shf);
			source = osource;
			quitenv(); /* after shf_close() due to alloc */
			return -2; /* special to iosetup(): don't print error */
		}
		/* set up yylex input from here file */
		s = pushs(SFILE, ATEMP);
		s->u.shf = shf;
d1472 12
a1483 24
		shf_close(shf);
		shf = (struct shf *) 0;
		cp = evalstr(yylval.cp, 0);

		/* write expanded input to another temp file */
		h = maketemp(ATEMP);
		h->next = e->temps; e->temps = h;
		if (!(shf = h->shf) || (fd = open(h->name, O_RDONLY, 0)) < 0)
			/* shf closeed by error handler */
			errorf("%s: %s", h->name, strerror(errno));
		shf_puts(cp, shf);
		if (shf_close(shf) == EOF) {
			close(fd);
			shf = (struct shf *) 0;
			errorf("error writing %s: %s", h->name,
				strerror(errno));
		}
		shf = (struct shf *) 0;

		quitenv();
	} else {
		fd = open(hname, O_RDONLY, 0);
		if (fd < 0)
			return -1;
@


1.15
log
@sync with pdksh-unstable-5.2.13.6
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.14 1999/01/08 20:24:59 millert Exp $	*/
d427 2
a428 1
		ksh_execve(t->str, t->args, ap);
d439 1
a439 1
		exit(rv);	/* exit child */
d828 8
a835 2
					if (a0 != a2 && search_access(a0, X_OK, (int *) 0))
						a0 = a2;
d864 1
a864 1
	ksh_execve(tp->args[0], tp->args, ap);
@


1.14
log
@bug fixes from pdksh-unstable-5.2.13.5; some of which we already had.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.13 1998/10/29 04:09:20 millert Exp $	*/
d329 3
d349 3
d480 2
a481 1
		setstr(typeset("_", LOCAL, 0, 0, 0), *--lastp);
d726 1
@


1.13
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.12 1998/06/27 15:23:29 deraadt Exp $	*/
d107 1
a107 1
		 * null commands (see comexec()) and by c_set().
@


1.12
log
@new ksh code stupidly did not permit ". /dev/null"; enable that again
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.11 1998/06/25 19:01:54 millert Exp $	*/
d1086 1
a1086 1
			tp->flag = ~ISSET;
d1106 4
a1109 3
	else if (mode == X_OK && (!S_ISREG(statb.st_mode)
		/* This 'cause access() says root can execute everything */
		   || !(statb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH))))
@


1.11
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.10 1997/09/12 04:38:05 millert Exp $	*/
d1106 3
a1108 4
	else if (!S_ISREG(statb.st_mode)
		 /* This 'cause access() says root can execute everything */
		 || (mode == X_OK
		     && !(statb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH))))
@


1.10
log
@Avoid longjmp/vfork clobbering.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.9 1997/06/19 13:58:41 kstailey Exp $	*/
d465 1
d471 1
a471 1
	if (!Flag(FSH) && *(lastp = ap)) {
d476 1
d636 2
d642 8
a649 1
		getopts_reset(1);
d716 1
d721 1
d1106 4
a1109 3
	else if (mode == X_OK && (!S_ISREG(statb.st_mode)
		   /* This 'cause access() says root can execute everything */
		   || !(statb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH))))
d1114 1
a1114 1
	if (err && errnop)
d1179 1
a1179 1
	if (err && errnop)
d1294 1
a1294 1
		cp = evalonestr(cp, DOTILDE|(Flag(FTALKING) ? DOGLOB : 0));
@


1.9
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.7 1997/01/02 17:37:25 downsj Exp $	*/
d460 4
@


1.8
log
@(foo *)0 -> NULL
@
text
@d209 1
a209 1
			sigprocmask(SIG_SETMASK, &omask, NULL);
d230 1
a230 1
		coproc.job = NULL;
d244 1
a244 1
		sigprocmask(SIG_SETMASK, &omask, NULL);
d605 1
a605 1
			if (include(tp->u.fpath, 0, NULL, 0) < 0) {
d739 1
a739 1
		shell = search(shell, path, X_OK, NULL);
d766 1
a766 1
				char *a0 = cp, *a1 = NULL;
d802 1
a802 2
					if (a0 != a2 && search_access(a0, X_OK,
					    NULL))
d818 1
a818 1
				 shell = search(shell, path, X_OK, NULL);
d861 1
a861 1
	struct tbl *tp = NULL;
d871 1
a871 1
			tp->val.t = NULL;
d985 1
a985 1
				tp->u.fpath = NULL;
d1037 1
a1037 1
					      &tp->u2.errno_)) != NULL)
d1107 1
a1107 1
				     ".com", ".bat", NULL
d1110 1
a1110 1
				      NULL
d1256 1
a1256 1
	builtin_argv0 = NULL;
d1280 1
a1280 1
	iotmp.name = (iotype == IOHERE) ? NULL : cp;
d1286 1
a1286 1
			snptreef(NULL, 32, "%R", &iotmp));
d1328 1
a1328 1
				snptreef(NULL, 32, "%R", &iotmp), emsg);
d1369 1
a1369 1
				snptreef(NULL, 32, "%R", &iotmp),
d1406 1
a1406 1
	if (hname == NULL) {
d1437 1
a1437 1
		shf = NULL;
d1449 1
a1449 1
			shf = NULL;
d1453 1
a1453 1
		shf = NULL;
d1476 1
a1476 1
					"read", "-r", "REPLY", NULL
d1493 1
a1493 1
			return (NULL);
d1632 1
a1632 1
		return (NULL);
@


1.7
log
@After discussing $_ with the maintainer, revert ksh behaviour and completely
eliminate it from sh.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.6 1997/01/02 09:33:56 downsj Exp $	*/
d209 1
a209 1
			sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d230 1
a230 1
		coproc.job = (void *) 0;
d244 1
a244 1
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d605 1
a605 1
			if (include(tp->u.fpath, 0, (char **) 0, 0) < 0) {
d739 1
a739 1
		shell = search(shell, path, X_OK, (int *) 0);
d766 1
a766 1
				char *a0 = cp, *a1 = (char *) 0;
d802 2
a803 1
					if (a0 != a2 && search_access(a0, X_OK, (int *) 0))
d819 1
a819 1
				 shell = search(shell, path, X_OK, (int *) 0);
d862 1
a862 1
	struct tbl *tp = (struct tbl *) 0;
d872 1
a872 1
			tp->val.t = (struct op *) 0;
d986 1
a986 1
				tp->u.fpath = (char *) 0;
d1038 1
a1038 1
					      &tp->u2.errno_)) != (char *) 0)
d1108 1
a1108 1
				     ".com", ".bat", (char *) 0
d1111 1
a1111 1
				      (char *) 0
d1257 1
a1257 1
	builtin_argv0 = (char *) 0;
d1281 1
a1281 1
	iotmp.name = (iotype == IOHERE) ? (char *) 0 : cp;
d1287 1
a1287 1
			snptreef((char *) 0, 32, "%R", &iotmp));
d1329 1
a1329 1
				snptreef((char *) 0, 32, "%R", &iotmp), emsg);
d1370 1
a1370 1
				snptreef((char *) 0, 32, "%R", &iotmp),
d1407 1
a1407 1
	if (hname == (char *) 0) {
d1438 1
a1438 1
		shf = (struct shf *) 0;
d1450 1
a1450 1
			shf = (struct shf *) 0;
d1454 1
a1454 1
		shf = (struct shf *) 0;
d1477 1
a1477 1
					"read", "-r", "REPLY", (char *) 0
d1494 1
a1494 1
			return (char *) 0;
d1633 1
a1633 1
		return (char *) 0;
@


1.6
log
@Add FSH (set -o sh), initialize it if we're /bin/sh, and add the first use:
don't set $_ if we're non-interactive.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.5 1996/11/21 07:59:28 downsj Exp $	*/
a459 1
	volatile int underscore = (!Flag(FSH) || Flag(FTALKING));
d466 1
a466 1
	if (underscore && *(lastp = ap)) {
d701 1
a701 1
		if (underscore) {
@


1.5
log
@Update to 5.2.12.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.4 1996/10/01 02:05:34 downsj Exp $	*/
d460 1
d467 1
a467 1
	if (*(lastp = ap)) {
d702 4
a705 2
		/* set $_ to program's full path */
		setstr(typeset("_", LOCAL|EXPORT, 0, 0, 0), tp->val.s);
@


1.4
log
@Integrate pdksh 5.2.9.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.3 1996/08/25 12:38:00 downsj Exp $	*/
d37 1
a37 1
static int	search_access1 ARGS((const char *path, int mode));
d420 1
@


1.3
log
@Fix problems with compiling without KSH defined, add NOEDIT override.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.2 1996/08/19 20:08:50 downsj Exp $	*/
d524 1
a524 1
			/* POSIX says special builtins loose their status
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
d1462 1
a1462 1
#ifdef KSH
d1565 1
a1565 1
#endif /* KSH */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d12 7
d23 1
a23 1
static int	iosetup ARGS((struct ioword *iop));
d26 1
a26 1
static char 	*do_selectargs ARGS((char **ap));
d90 8
d114 1
a114 1
		ap = eval(t->args, t->evalflags | DOBLANK | DOGLOB | DOTILDE);
d117 1
a117 1
				substitute(str_val(global("PS4")), 0));
d136 1
a136 1
			if (iosetup(*iowp) < 0) {
d197 19
d218 1
d220 2
a221 1
		cleanup_coproc(TRUE);
d230 1
d239 13
a251 3
		}

		/* exchild() closes coproc.* in child after fork */
d271 1
a271 1
			rv = execute(t->right, 0);
d300 2
d338 1
a338 1
				if ((cp = do_selectargs(ap)) == (char *) 0) {
d342 1
d350 1
d402 1
a402 1
		rv = define(t->str, t->left);
d537 1
a537 4
	/* todo: POSIX says assignments preceding a function are kept, at&t
	 * ksh does not do this
	 */
	if (keepasn_ok && (!ap[0] || (tp && tp->flag & KEEPASN)))
d542 6
a547 1
		type_flags = LOCAL|LOCAL_COPY|EXPORT;
d556 1
a556 1
					substitute(str_val(global("PS4")), 0));
d585 1
a585 1
		volatile int old_inuse;
d592 7
a598 2
				/* XXX: exit code 126 vs 127 */
				warningf(TRUE,
d600 2
a601 1
				rv = 127;
d608 1
a608 1
				rv = 126;
d623 3
a625 1
		/* posix says $0 remains unchanged, at&t ksh changes it */
d627 1
a627 1
		if (!Flag(FPOSIX))
d652 2
a653 1
		 * tree.  Unfortunately, the table entry is never re-used.
d684 4
a687 18
			/*
			 * mlj addition:
			 *
			 * If you specify a full path to a file
			 * (or type the name of a file in .) which
			 * doesn't have execute priv's, it used to
			 * just say "not found".  Kind of annoying,
			 * particularly if you just wrote a script
			 * but forgot to say chmod 755 script.
			 *
			 * This should probably be done in eaccess(),
			 * but it works here (at least I haven't noticed
			 * changing errno here breaking something
			 * else).
			 *
			 * So, we assume that if the file exists, it
			 * doesn't have execute privs; else, it really
			 * is not found.
d689 5
a693 1
			if (access(cp, F_OK) < 0)
d695 2
a696 4
			else
				warningf(TRUE, "%s: cannot execute", cp);
			/* XXX posix says 126 if in path and cannot execute */
			rv = 127;
d703 1
a703 1
		if ((flags&XEXEC)) {
d736 1
a736 1
		shell = search(shell, path, X_OK);
d799 1
a799 1
					if (a0 != a2 && search_access(a0, X_OK))
d815 1
a815 1
				 shell = search(shell, path, X_OK);
d862 1
a862 1
		if (tp && (tp->flag & DEFINED))
d876 2
a877 1
 * define function
d884 2
a885 1
	register struct tbl *tp;
d887 2
a888 1
	tp = findfunc(name, hash(name), TRUE);
d890 11
a900 8
	/* If this function is currently being executed, we zap this
	 * table entry so findfunc() won't see it
	 */
	if (tp->flag & FINUSE) {
		tp->name[0] = '\0';
		tp->flag &= ~DEFINED; /* ensure it won't be found */
		tp->flag |= FDELETE;
		return define(name, t);
d910 1
a910 1
		return 0;
d913 1
a913 1
	tp->val.t = tcopy(t, tp->areap);
d915 2
d930 1
a930 1
	int flag;
d981 1
a981 1
			if ((fpath = str_val(global("FPATH"))) == null)
d983 4
a986 2
			else
				tp->u.fpath = search(name, fpath, R_OK);
d1027 1
a1027 1
				X_OK);
d1033 2
a1034 1
			   && (npath = search(name, fpath, R_OK)) != (char *) 0)
d1072 1
a1072 1
search_access(path, mode)
d1075 1
d1078 1
a1078 1
	int ret = eaccess(path, mode);
d1081 9
a1089 5
	/* if executable pipes come along, this will have to change */
	if (ret == 0 && (mode == X_OK)
	    && (stat(path, &statb) < 0 || !S_ISREG(statb.st_mode)
	       /* This 'cause access() says root can execute everything */
	       || !(statb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH))))
d1091 4
d1123 1
a1123 1
		return search_access1(mpath, mode);
d1131 1
a1131 1
		if (search_access1(mpath, R_OK) == 0)
d1141 1
a1141 1
search_access1(path, mode)
d1144 1
d1146 1
a1146 1
	int ret = eaccess(path, mode);
d1149 6
a1154 3
	/* if executable pipes come along, this will have to change */
	if (ret == 0 && (mode == X_OK || mode == R_OK)
	    && (stat(path, &statb) < 0 || !S_ISREG(statb.st_mode)))
d1156 4
d1168 1
a1168 1
search(name, path, mode)
d1172 1
d1179 2
d1190 1
a1190 1
		if (search_access(Xstring(xs, xp), mode) >= 0)
d1197 1
a1197 1
	if (search_access(Xstring(xs, xp), mode) == 0) 
d1201 1
a1201 1
		if (search_access(name, mode) == 0)
d1224 1
a1224 1
 		if (search_access(Xstring(xs, xp), mode) == 0)
d1261 1
a1261 1
iosetup(iop)
d1263 1
d1282 1
a1282 1
			substitute(str_val(global("PS4")), 0),
d1372 2
a1373 1
		if (iotype == IODUP) {
d1375 7
a1381 9
			if (iop->flag & IORDUP)	/* possible <&p */
				/* Ensure other side of read pipe is
				 * closed so EOF can be read properly
				 */
				coproc_readw_close(u);
			else			/* possible >&p */
				/* If co-process input is duped,
				 * close shell's copy
				 */
d1383 1
a1383 2
#else /* KSH */
			;
a1384 2
		} else
			close(u);
d1468 1
a1468 1
do_selectargs(ap)
d1470 1
d1476 1
a1476 1
	int i, UNINITIALIZED(argct);
d1478 2
d1481 7
a1487 1
		argct = pr_menu(ap);
a1491 2
		while (*s && isspace(*s))
			s++;
d1496 1
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
