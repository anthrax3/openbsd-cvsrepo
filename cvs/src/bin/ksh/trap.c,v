head	1.30;
access;
symbols
	OPENBSD_6_2:1.30.0.4
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.30.0.6
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.23.0.24
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.16
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.20
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.18
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.14
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.12
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.10
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.8
	OPENBSD_5_0:1.23.0.6
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.22.0.18
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.20
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.16
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.14
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.12
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.10
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.8
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.6
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.4
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.13.0.8
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.6
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.4
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.8
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.6
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2016.03.17.23.33.23;	author mmcc;	state Exp;
branches;
next	1.29;
commitid	Vulj8lha6PuDYESy;

1.29
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.28;
commitid	btTCreDA00YdaFhU;

1.28
date	2015.11.12.04.04.31;	author mmcc;	state Exp;
branches;
next	1.27;
commitid	QvyWaajN4Lc4MRtd;

1.27
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.26;
commitid	C4W85jmosThChWA2;

1.26
date	2015.10.09.19.36.27;	author tedu;	state Exp;
branches;
next	1.25;
commitid	BqXaWldwtvsixcay;

1.25
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.24;
commitid	7fgq4YTZG4xZ0uN0;

1.24
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.23;
commitid	lBs9un9sXhbdfVrQ;

1.23
date	2010.05.19.17.36.08;	author jasper;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.25.11.21.16;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.28.21.11.22;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.22.17.47.03;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.18.21.58.39;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.18.21.04.52;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.18.01.47.06;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.19.10.58.07;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	99.01.19.20.41.56;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.01.08.20.25.02;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.12.21.05.53.27;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.10.29.04.09.21;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.09.01.18.30.13;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.08.05.22.22.58;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.06.19.13.58.48;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.06.18.22.42.46;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.09.00;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.12;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.12;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.30
log
@remove some ARGSUSED
@
text
@/*	$OpenBSD: trap.c,v 1.29 2015/12/14 13:59:42 tb Exp $	*/

/*
 * signal handling
 */

#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>

#include "sh.h"

Trap sigtraps[NSIG + 1];

static struct sigaction Sigact_ign, Sigact_trap;

void
inittraps(void)
{
	int	i;

	/* Populate sigtraps based on sys_signame and sys_siglist. */
	for (i = 0; i <= NSIG; i++) {
		sigtraps[i].signal = i;
		if (i == SIGERR_) {
			sigtraps[i].name = "ERR";
			sigtraps[i].mess = "Error handler";
		} else {
			sigtraps[i].name = sys_signame[i];
			sigtraps[i].mess = sys_siglist[i];
		}
	}
	sigtraps[SIGEXIT_].name = "EXIT";	/* our name for signal 0 */

	sigemptyset(&Sigact_ign.sa_mask);
	Sigact_ign.sa_flags = 0; /* interruptible */
	Sigact_ign.sa_handler = SIG_IGN;
	Sigact_trap = Sigact_ign;
	Sigact_trap.sa_handler = trapsig;

	sigtraps[SIGINT].flags |= TF_DFL_INTR | TF_TTY_INTR;
	sigtraps[SIGQUIT].flags |= TF_DFL_INTR | TF_TTY_INTR;
	sigtraps[SIGTERM].flags |= TF_DFL_INTR;/* not fatal for interactive */
	sigtraps[SIGHUP].flags |= TF_FATAL;
	sigtraps[SIGCHLD].flags |= TF_SHELL_USES;

	/* these are always caught so we can clean up any temporary files. */
	setsig(&sigtraps[SIGINT], trapsig, SS_RESTORE_ORIG);
	setsig(&sigtraps[SIGQUIT], trapsig, SS_RESTORE_ORIG);
	setsig(&sigtraps[SIGTERM], trapsig, SS_RESTORE_ORIG);
	setsig(&sigtraps[SIGHUP], trapsig, SS_RESTORE_ORIG);
}

static void alarm_catcher(int sig);

void
alarm_init(void)
{
	sigtraps[SIGALRM].flags |= TF_SHELL_USES;
	setsig(&sigtraps[SIGALRM], alarm_catcher,
		SS_RESTORE_ORIG|SS_FORCE|SS_SHTRAP);
}

static void
alarm_catcher(int sig)
{
	int errno_ = errno;

	if (ksh_tmout_state == TMOUT_READING) {
		int left = alarm(0);

		if (left == 0) {
			ksh_tmout_state = TMOUT_LEAVING;
			intrsig = 1;
		} else
			alarm(left);
	}
	errno = errno_;
}

Trap *
gettrap(const char *name, int igncase)
{
	int i;
	Trap *p;

	if (digit(*name)) {
		int n;

		if (getn(name, &n) && 0 <= n && n < NSIG)
			return &sigtraps[n];
		return NULL;
	}
	for (p = sigtraps, i = NSIG+1; --i >= 0; p++)
		if (p->name) {
			if (igncase) {
				if (p->name && (!strcasecmp(p->name, name) ||
				    (strlen(name) > 3 && !strncasecmp("SIG",
				    p->name, 3) &&
				    !strcasecmp(p->name, name + 3))))
					return p;
			} else {
				if (p->name && (!strcmp(p->name, name) ||
				    (strlen(name) > 3 && !strncmp("SIG",
				    p->name, 3) && !strcmp(p->name, name + 3))))
					return p;
			}
		}
	return NULL;
}

/*
 * trap signal handler
 */
void
trapsig(int i)
{
	Trap *p = &sigtraps[i];
	int errno_ = errno;

	trap = p->set = 1;
	if (p->flags & TF_DFL_INTR)
		intrsig = 1;
	if ((p->flags & TF_FATAL) && !p->trap) {
		fatal_trap = 1;
		intrsig = 1;
	}
	if (p->shtrap)
		(*p->shtrap)(i);
	errno = errno_;
}

/* called when we want to allow the user to ^C out of something - won't
 * work if user has trapped SIGINT.
 */
void
intrcheck(void)
{
	if (intrsig)
		runtraps(TF_DFL_INTR|TF_FATAL);
}

/* called after EINTR to check if a signal with normally causes process
 * termination has been received.
 */
int
fatal_trap_check(void)
{
	int i;
	Trap *p;

	/* todo: should check if signal is fatal, not the TF_DFL_INTR flag */
	for (p = sigtraps, i = NSIG+1; --i >= 0; p++)
		if (p->set && (p->flags & (TF_DFL_INTR|TF_FATAL)))
			/* return value is used as an exit code */
			return 128 + p->signal;
	return 0;
}

/* Returns the signal number of any pending traps: ie, a signal which has
 * occurred for which a trap has been set or for which the TF_DFL_INTR flag
 * is set.
 */
int
trap_pending(void)
{
	int i;
	Trap *p;

	for (p = sigtraps, i = NSIG+1; --i >= 0; p++)
		if (p->set && ((p->trap && p->trap[0]) ||
		    ((p->flags & (TF_DFL_INTR|TF_FATAL)) && !p->trap)))
			return p->signal;
	return 0;
}

/*
 * run any pending traps.  If intr is set, only run traps that
 * can interrupt commands.
 */
void
runtraps(int flag)
{
	int i;
	Trap *p;

	if (ksh_tmout_state == TMOUT_LEAVING) {
		ksh_tmout_state = TMOUT_EXECUTING;
		warningf(false, "timed out waiting for input");
		unwind(LEXIT);
	} else
		/* XXX: this means the alarm will have no effect if a trap
		 * is caught after the alarm() was started...not good.
		 */
		ksh_tmout_state = TMOUT_EXECUTING;
	if (!flag)
		trap = 0;
	if (flag & TF_DFL_INTR)
		intrsig = 0;
	if (flag & TF_FATAL)
		fatal_trap = 0;
	for (p = sigtraps, i = NSIG+1; --i >= 0; p++)
		if (p->set && (!flag ||
		    ((p->flags & flag) && p->trap == NULL)))
			runtrap(p);
}

void
runtrap(Trap *p)
{
	int	i = p->signal;
	char	*trapstr = p->trap;
	int	oexstat;
	int	old_changed = 0;

	p->set = 0;
	if (trapstr == NULL) { /* SIG_DFL */
		if (p->flags & TF_FATAL) {
			/* eg, SIGHUP */
			exstat = 128 + i;
			unwind(LLEAVE);
		}
		if (p->flags & TF_DFL_INTR) {
			/* eg, SIGINT, SIGQUIT, SIGTERM, etc. */
			exstat = 128 + i;
			unwind(LINTR);
		}
		return;
	}
	if (trapstr[0] == '\0') /* SIG_IGN */
		return;
	if (i == SIGEXIT_ || i == SIGERR_) {	/* avoid recursion on these */
		old_changed = p->flags & TF_CHANGED;
		p->flags &= ~TF_CHANGED;
		p->trap = NULL;
	}
	oexstat = exstat;
	/* Note: trapstr is fully parsed before anything is executed, thus
	 * no problem with afree(p->trap) in settrap() while still in use.
	 */
	command(trapstr, current_lineno);
	exstat = oexstat;
	if (i == SIGEXIT_ || i == SIGERR_) {
		if (p->flags & TF_CHANGED)
			/* don't clear TF_CHANGED */
			afree(trapstr, APERM);
		else
			p->trap = trapstr;
		p->flags |= old_changed;
	}
}

/* clear pending traps and reset user's trap handlers; used after fork(2) */
void
cleartraps(void)
{
	int i;
	Trap *p;

	trap = 0;
	intrsig = 0;
	fatal_trap = 0;
	for (i = NSIG+1, p = sigtraps; --i >= 0; p++) {
		p->set = 0;
		if ((p->flags & TF_USER_SET) && (p->trap && p->trap[0]))
			settrap(p, NULL);
	}
}

/* restore signals just before an exec(2) */
void
restoresigs(void)
{
	int i;
	Trap *p;

	for (i = NSIG+1, p = sigtraps; --i >= 0; p++)
		if (p->flags & (TF_EXEC_IGN|TF_EXEC_DFL))
			setsig(p, (p->flags & TF_EXEC_IGN) ? SIG_IGN : SIG_DFL,
			    SS_RESTORE_CURR|SS_FORCE);
}

void
settrap(Trap *p, char *s)
{
	sig_t f;

	afree(p->trap, APERM);
	p->trap = str_save(s, APERM); /* handles s == 0 */
	p->flags |= TF_CHANGED;
	f = !s ? SIG_DFL : s[0] ? trapsig : SIG_IGN;

	p->flags |= TF_USER_SET;
	if ((p->flags & (TF_DFL_INTR|TF_FATAL)) && f == SIG_DFL)
		f = trapsig;
	else if (p->flags & TF_SHELL_USES) {
		if (!(p->flags & TF_ORIG_IGN) || Flag(FTALKING)) {
			/* do what user wants at exec time */
			p->flags &= ~(TF_EXEC_IGN|TF_EXEC_DFL);
			if (f == SIG_IGN)
				p->flags |= TF_EXEC_IGN;
			else
				p->flags |= TF_EXEC_DFL;
		}

		/* assumes handler already set to what shell wants it
		 * (normally trapsig, but could be j_sigchld() or SIG_IGN)
		 */
		return;
	}

	/* todo: should we let user know signal is ignored? how? */
	setsig(p, f, SS_RESTORE_CURR|SS_USER);
}

/* Called by c_print() when writing to a co-process to ensure SIGPIPE won't
 * kill shell (unless user catches it and exits)
 */
int
block_pipe(void)
{
	int restore_dfl = 0;
	Trap *p = &sigtraps[SIGPIPE];

	if (!(p->flags & (TF_ORIG_IGN|TF_ORIG_DFL))) {
		setsig(p, SIG_IGN, SS_RESTORE_CURR);
		if (p->flags & TF_ORIG_DFL)
			restore_dfl = 1;
	} else if (p->cursig == SIG_DFL) {
		setsig(p, SIG_IGN, SS_RESTORE_CURR);
		restore_dfl = 1; /* restore to SIG_DFL */
	}
	return restore_dfl;
}

/* Called by c_print() to undo whatever block_pipe() did */
void
restore_pipe(int restore_dfl)
{
	if (restore_dfl)
		setsig(&sigtraps[SIGPIPE], SIG_DFL, SS_RESTORE_CURR);
}

/* Set action for a signal.  Action may not be set if original
 * action was SIG_IGN, depending on the value of flags and
 * FTALKING.
 */
int
setsig(Trap *p, sig_t f, int flags)
{
	struct sigaction sigact;

	if (p->signal == SIGEXIT_ || p->signal == SIGERR_)
		return 1;

	/* First time setting this signal?  If so, get and note the current
	 * setting.
	 */
	if (!(p->flags & (TF_ORIG_IGN|TF_ORIG_DFL))) {
		sigaction(p->signal, &Sigact_ign, &sigact);
		p->flags |= sigact.sa_handler == SIG_IGN ?
		    TF_ORIG_IGN : TF_ORIG_DFL;
		p->cursig = SIG_IGN;
	}

	/* Generally, an ignored signal stays ignored, except if
	 *	- the user of an interactive shell wants to change it
	 *	- the shell wants for force a change
	 */
	if ((p->flags & TF_ORIG_IGN) && !(flags & SS_FORCE) &&
	    (!(flags & SS_USER) || !Flag(FTALKING)))
		return 0;

	setexecsig(p, flags & SS_RESTORE_MASK);

	/* This is here 'cause there should be a way of clearing shtraps, but
	 * don't know if this is a sane way of doing it.  At the moment,
	 * all users of shtrap are lifetime users (SIGCHLD, SIGALRM, SIGWINCH).
	 */
	if (!(flags & SS_USER))
		p->shtrap = NULL;
	if (flags & SS_SHTRAP) {
		p->shtrap = f;
		f = trapsig;
	}

	if (p->cursig != f) {
		p->cursig = f;
		sigemptyset(&sigact.sa_mask);
		sigact.sa_flags = 0 /* interruptible */;
		sigact.sa_handler = f;
		sigaction(p->signal, &sigact, NULL);
	}

	return 1;
}

/* control what signal is set to before an exec() */
void
setexecsig(Trap *p, int restore)
{
	/* XXX debugging */
	if (!(p->flags & (TF_ORIG_IGN|TF_ORIG_DFL)))
		internal_errorf(1, "setexecsig: unset signal %d(%s)",
		    p->signal, p->name);

	/* restore original value for exec'd kids */
	p->flags &= ~(TF_EXEC_IGN|TF_EXEC_DFL);
	switch (restore & SS_RESTORE_MASK) {
	case SS_RESTORE_CURR: /* leave things as they currently are */
		break;
	case SS_RESTORE_ORIG:
		p->flags |= p->flags & TF_ORIG_IGN ? TF_EXEC_IGN : TF_EXEC_DFL;
		break;
	case SS_RESTORE_DFL:
		p->flags |= TF_EXEC_DFL;
		break;
	case SS_RESTORE_IGN:
		p->flags |= TF_EXEC_IGN;
		break;
	}
}
@


1.29
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2015/11/12 04:04:31 mmcc Exp $	*/
a64 1
/* ARGSUSED */
@


1.28
log
@Use isdigit() instead of ksh's homebrewed alternative.

ok nicm@@. Also discussed with millert@@ and guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2015/10/19 14:42:16 mmcc Exp $	*/
d8 1
d10 1
@


1.27
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2015/10/09 19:36:27 tedu Exp $	*/
d7 1
@


1.26
log
@remove null check before afree. from Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2015/09/18 07:28:24 nicm Exp $	*/
d6 2
@


1.25
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2015/09/15 18:15:05 tedu Exp $	*/
d285 1
a285 2
	if (p->trap)
		afree(p->trap, APERM);
@


1.24
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2010/05/19 17:36:08 jasper Exp $	*/
d390 1
a390 1
		sigaction(p->signal, &sigact, (struct sigaction *) 0);
@


1.23
log
@properly keep track of the line number after a trap.
this fixes pr 6195. diff from manuel giraud, thanks.

ok kili@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2005/03/30 17:16:37 deraadt Exp $	*/
d201 1
a201 1
		    ((p->flags & flag) && p->trap == (char *) 0)))
d214 1
a214 1
	if (trapstr == (char *) 0) { /* SIG_DFL */
d232 1
a232 1
		p->trap = (char *) 0;
d263 1
a263 1
			settrap(p, (char *) 0);
@


1.22
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2005/02/25 11:21:16 deraadt Exp $	*/
d238 1
a238 1
	command(trapstr);
@


1.21
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2004/12/28 21:11:22 jsg Exp $	*/
d168 2
a169 3
		if (p->set && ((p->trap && p->trap[0])
			       || ((p->flags & (TF_DFL_INTR|TF_FATAL))
				   && !p->trap)))
d200 2
a201 2
		if (p->set && (!flag
			       || ((p->flags & flag) && p->trap == (char *) 0)))
d277 1
a277 1
				SS_RESTORE_CURR|SS_FORCE);
d303 1
d360 1
a360 1
					TF_ORIG_IGN : TF_ORIG_DFL;
d368 2
a369 2
	if ((p->flags & TF_ORIG_IGN) && !(flags & SS_FORCE)
	    && (!(flags & SS_USER) || !Flag(FTALKING)))
d403 1
a403 1
			p->signal, p->name);
d408 1
a408 1
	  case SS_RESTORE_CURR: /* leave things as they currently are */
d410 1
a410 1
	  case SS_RESTORE_ORIG:
d413 1
a413 1
	  case SS_RESTORE_DFL:
d416 1
a416 1
	  case SS_RESTORE_IGN:
@


1.20
log
@ansi. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 2004/12/22 17:47:03 millert Exp $	*/
d60 1
@


1.19
log
@Use sys_signame and sys_siglist instead of building a list of signal
values and names via an awk script.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2004/12/22 17:14:34 millert Exp $	*/
d14 1
a14 1
inittraps()
d53 1
a53 1
alarm_init()
d61 1
a61 2
alarm_catcher(sig)
	int sig;
d78 1
a78 3
gettrap(name, igncase)
	const char *name;
	int igncase;
d112 1
a112 2
trapsig(i)
	int i;
d133 1
a133 1
intrcheck()
d143 1
a143 1
fatal_trap_check()
d161 1
a161 1
trap_pending()
d179 1
a179 2
runtraps(flag)
	int flag;
d206 1
a206 2
runtrap(p)
	Trap *p;
d252 1
a252 1
cleartraps()
d269 1
a269 1
restoresigs()
d281 1
a281 3
settrap(p, s)
	Trap *p;
	char *s;
d317 1
a317 1
block_pipe()
d335 1
a335 2
restore_pipe(restore_dfl)
	int restore_dfl;
d346 1
a346 4
setsig(p, f, flags)
	Trap *p;
	sig_t f;
	int flags;
d397 1
a397 3
setexecsig(p, restore)
	Trap *p;
	int restore;
@


1.18
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 2004/12/18 21:58:39 millert Exp $	*/
d9 1
a9 10
/* Table is indexed by signal number
 *
 * The script siglist.sh generates siglist.out, which is a sorted, complete
 * list of signals
 */
Trap sigtraps[NSIG+1] = {
	{ SIGEXIT_, "EXIT", "Signal 0" },
#include "siglist.out"	/* generated by siglist.sh */
	{ SIGERR_,  "ERR",  "Error handler" },
    };
d18 8
a25 3
	/* Use system description, if available, for unknown signals... */
	for (i = 0; i < NSIG; i++)
		if (!sigtraps[i].name && sys_siglist[i] && sys_siglist[i][0])
d27 3
@


1.17
log
@Use the BSD sig_t instead of homegrown handler_t
Remove KSH_SA_FLAGS
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 2004/12/18 21:25:44 millert Exp $	*/
d192 1
a192 1
		warningf(FALSE, "timed out waiting for input");
@


1.16
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 2004/12/18 21:04:52 millert Exp $	*/
d33 1
a33 1
	Sigact_ign.sa_flags = KSH_SA_FLAGS;
d292 1
a292 1
	handler_t f;
d358 1
a358 1
	handler_t f;
d391 1
a391 1
		p->shtrap = (handler_t) 0;
d400 1
a400 1
		sigact.sa_flags = KSH_SA_FLAGS;
@


1.15
log
@Get rid of #ifdef KSH since we don't care about building a V7 style sh and
the #ifdef KSH code is required to make a POSIX sh.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 2004/12/18 20:55:52 millert Exp $	*/
d85 1
a85 1
	register Trap *p;
d188 1
a188 1
	register Trap *p;
@


1.14
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 2003/02/28 09:45:09 jmc Exp $	*/
a50 1
#ifdef KSH
a77 1
#endif /* KSH */
a189 1
#ifdef KSH
a198 1
#endif /* KSH */
@


1.13
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 2001/12/18 01:47:06 deraadt Exp $	*/
a6 2
/* Kludge to avoid bogus re-declaration of sigtraps[] error on AIX 3.2.5 */
#define FROM_TRAP_C
d14 1
a14 1
Trap sigtraps[SIGNALS+1] = {
a24 4
#ifdef HAVE_SYS_SIGLIST
# ifndef SYS_SIGLIST_DECLARED
	extern char	*sys_siglist[];
# endif
a30 1
#endif	/* HAVE_SYS_SIGLIST */
d52 1
a52 1
static RETSIGTYPE alarm_catcher ARGS((int sig));
d62 1
a62 1
static RETSIGTYPE
a77 1
	return RETSIGVAL;
d92 1
a92 1
		if (getn(name, &n) && 0 <= n && n < SIGNALS)
d96 1
a96 1
	for (p = sigtraps, i = SIGNALS+1; --i >= 0; p++)
d117 1
a117 1
RETSIGTYPE
a132 4
#ifdef V7_SIGNALS
	if (sigtraps[i].cursig == trapsig) /* this for SIGCHLD,SIGALRM */
		sigaction(i, &Sigact_trap, (struct sigaction *) 0);
#endif /* V7_SIGNALS */
a133 1
	return RETSIGVAL;
d156 1
a156 1
	for (p = sigtraps, i = SIGNALS+1; --i >= 0; p++)
d173 1
a173 1
	for (p = sigtraps, i = SIGNALS+1; --i >= 0; p++)
d209 1
a209 1
	for (p = sigtraps, i = SIGNALS+1; --i >= 0; p++)
d222 1
a222 1
	int	UNINITIALIZED(old_changed);
d271 1
a271 1
	for (i = SIGNALS+1, p = sigtraps; --i >= 0; p++) {
d285 1
a285 1
	for (i = SIGNALS+1, p = sigtraps; --i >= 0; p++)
@


1.12
log
@another errno save situation
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 2001/09/19 10:58:07 mpech Exp $	*/
d51 1
a51 1
	/* these are always caught so we can clean up any temproary files. */
@


1.11
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok

p.s. Next commit will fix a typo in the sys/
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 1999/01/19 20:41:56 millert Exp $	*/
d73 2
d84 1
d130 1
a130 1
	int save_errno = errno;
d145 1
a145 1
	errno = save_errno;
@


1.10
log
@Updates from pdksh-unstable-5.2.13.7.  Most notable change is:
    trap: exit traps now executed in subshells (without explicit exit call).
See the Changelog for a full list of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 1999/01/08 20:25:02 millert Exp $	*/
d174 1
a174 1
 * occured for which a trap has been set or for which the TF_DFL_INTR flag
@


1.9
log
@bug fixes from pdksh-unstable-5.2.13.5; some of which we already had.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8 1998/12/21 05:53:27 deraadt Exp $	*/
d256 3
@


1.8
log
@correct built-in kill
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 1998/10/29 04:09:21 millert Exp $	*/
d87 1
a87 1
gettrap(name)
d89 1
d102 14
a115 4
		if (p->name && (strcasecmp(p->name, name) == 0 ||
		    (strlen(name) > 3 && !strncasecmp("SIG", p->name, 3) &&
		    !strcasecmp(p->name, name + 3))))
			return p;
@


1.7
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.6 1997/09/01 18:30:13 deraadt Exp $	*/
d101 3
a103 1
		if (p->name && strcasecmp(p->name, name) == 0)
@


1.6
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.5 1997/08/05 22:22:58 deraadt Exp $	*/
d35 1
a35 1
		if (!sigtraps[i].name && sys_siglist[i][0])
@


1.5
log
@make signal handlers errno safe
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.4 1997/06/19 13:58:48 kstailey Exp $	*/
d254 1
a254 1
 
@


1.4
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.2 1996/08/19 20:09:00 downsj Exp $	*/
d114 1
d129 1
@


1.3
log
@(foo *)0 -> NULL
@
text
@d126 1
a126 1
		sigaction(i, &Sigact_trap, NULL);
d206 1
a206 1
			       || ((p->flags & flag) && p->trap == NULL)))
d220 1
a220 1
	if (trapstr == NULL) { /* SIG_DFL */
d238 1
a238 1
		p->trap = NULL;
d266 1
a266 1
			settrap(p, NULL);
d398 1
a398 1
		sigaction(p->signal, &sigact, NULL);
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.1.1.1 1996/08/14 06:19:12 downsj Exp $	*/
d126 1
a126 1
		sigaction(i, &Sigact_trap, (struct sigaction *) 0);
d206 1
a206 1
			       || ((p->flags & flag) && p->trap == (char *) 0)))
d220 1
a220 1
	if (trapstr == (char *) 0) { /* SIG_DFL */
d238 1
a238 1
		p->trap = (char *) 0;
d266 1
a266 1
			settrap(p, (char *) 0);
d398 1
a398 1
		sigaction(p->signal, &sigact, (struct sigaction *) 0);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d22 1
a22 3
static RETSIGTYPE alarm_catcher ARGS((int sig));

static struct sigaction Sigact_ign, Sigact_trap, Sigact_alarm;
a43 2
	Sigact_alarm = Sigact_ign;
	Sigact_alarm.sa_handler = alarm_catcher;
d58 3
d66 1
a66 1
		SS_RESTORE_ORIG|SS_FORCE);
a72 2
	trapsig(sig);
#ifdef KSH
a81 4
#endif /* KSH */
#ifdef V7_SIGNALS
	sigaction(sig, &Sigact_alarm, (struct sigaction *) 0);
#endif /* V7_SIGNALS */
d84 1
d122 2
d362 3
d371 7
a377 2
	if ((p->flags & TF_ORIG_IGN) && (flags & SS_USER)
	    && !(flags & SS_FORCE) && !Flag(FTALKING))
a378 4
	if (!(flags & SS_USER)) {
		if (!(flags & SS_FORCE) && (p->flags & TF_ORIG_IGN))
			return 0;
	}
d381 11
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
