head	1.71;
access;
symbols
	OPENBSD_6_1:1.58.0.4
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.56.0.4
	OPENBSD_6_0_BASE:1.56
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.40.0.6
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.39.0.20
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.18
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.14
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.12
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.10
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.8
	OPENBSD_5_0:1.39.0.6
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.39.0.4
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.2
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.37.0.4
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.36.0.4
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.35.0.8
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.35.0.6
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.35.0.4
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.8
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.12.0.6
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.4
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.71
date	2017.09.07.19.08.32;	author jca;	state Exp;
branches;
next	1.70;
commitid	3FGtMarN5GLIipT7;

1.70
date	2017.08.31.11.10.03;	author jca;	state Exp;
branches;
next	1.69;
commitid	kiomdRmC3zv4mDfm;

1.69
date	2017.08.30.17.08.45;	author jca;	state Exp;
branches;
next	1.68;
commitid	DWdXJvJqVZz6aoxS;

1.68
date	2017.08.28.19.41.55;	author jca;	state Exp;
branches;
next	1.67;
commitid	tFGIIrFTSeyUCqLm;

1.67
date	2017.08.28.19.39.13;	author jca;	state Exp;
branches;
next	1.66;
commitid	1gawyLAuRGHbnu0m;

1.66
date	2017.08.27.17.10.32;	author jca;	state Exp;
branches;
next	1.65;
commitid	AY4vfW8mvOZOCaHS;

1.65
date	2017.08.26.12.34.32;	author jca;	state Exp;
branches;
next	1.64;
commitid	n2He2gItvzdwsg8K;

1.64
date	2017.08.11.19.37.58;	author tb;	state Exp;
branches;
next	1.63;
commitid	G59663TxgBHPgAO9;

1.63
date	2017.08.01.14.30.05;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	BIAC2bWaDnF38LwT;

1.62
date	2017.07.24.23.56.37;	author tb;	state Exp;
branches;
next	1.61;
commitid	8eQL2LagxYTspML9;

1.61
date	2017.07.24.22.28.09;	author jca;	state Exp;
branches;
next	1.60;
commitid	aKTxC9dveAVEvFGM;

1.60
date	2017.07.24.22.26.12;	author jca;	state Exp;
branches;
next	1.59;
commitid	UduvytS6l883fv4D;

1.59
date	2017.05.29.13.09.17;	author tb;	state Exp;
branches;
next	1.58;
commitid	5VJDOduqGHsduT45;

1.58
date	2016.08.24.16.09.40;	author millert;	state Exp;
branches;
next	1.57;
commitid	yqz0fCicUgAzW5cc;

1.57
date	2016.08.24.13.32.17;	author millert;	state Exp;
branches;
next	1.56;
commitid	hodUJEYUcJvwHcDR;

1.56
date	2015.12.30.09.07.00;	author tedu;	state Exp;
branches;
next	1.55;
commitid	WTwPzlskFufQpRQz;

1.55
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.54;
commitid	btTCreDA00YdaFhU;

1.54
date	2015.12.14.06.09.43;	author mmcc;	state Exp;
branches;
next	1.53;
commitid	X7XrxRgHwWl96WEl;

1.53
date	2015.11.02.16.38.35;	author mmcc;	state Exp;
branches;
next	1.52;
commitid	RpRkBfO6eLRc9lVf;

1.52
date	2015.11.01.15.38.53;	author mmcc;	state Exp;
branches;
next	1.51;
commitid	Fr9nr0FBz2YkAWdK;

1.51
date	2015.10.21.15.47.41;	author mmcc;	state Exp;
branches;
next	1.50;
commitid	CvcKXIcgVXd3fSOy;

1.50
date	2015.10.21.15.20.37;	author mmcc;	state Exp;
branches;
next	1.49;
commitid	xYVdAoH9LzDsXxBv;

1.49
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.48;
commitid	C4W85jmosThChWA2;

1.48
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.47;
commitid	16HUr75moyUNtKR8;

1.47
date	2015.10.09.19.36.27;	author tedu;	state Exp;
branches;
next	1.46;
commitid	BqXaWldwtvsixcay;

1.46
date	2015.10.08.16.41.26;	author tedu;	state Exp;
branches;
next	1.45;
commitid	gwJOO7UO4Ia7NIz7;

1.45
date	2015.10.08.15.54.59;	author tedu;	state Exp;
branches;
next	1.44;
commitid	2tZ7ZhjIpMjkz2W8;

1.44
date	2015.09.17.21.39.54;	author nicm;	state Exp;
branches;
next	1.43;
commitid	kqHrwR3VHcPphk1W;

1.43
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.42;
commitid	v5QjoxUgKU2iUTFz;

1.42
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.41;
commitid	lBs9un9sXhbdfVrQ;

1.41
date	2015.09.01.13.12.31;	author tedu;	state Exp;
branches;
next	1.40;
commitid	sKGEDet4KOfGjsIb;

1.40
date	2014.11.20.15.22.39;	author tedu;	state Exp;
branches;
next	1.39;
commitid	HIbf8HnT4wFtIrOp;

1.39
date	2010.05.19.17.36.08;	author jasper;	state Exp;
branches;
next	1.38;

1.38
date	2010.05.01.21.09.23;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2009.07.02.16.29.15;	author martynas;	state Exp;
branches;
next	1.36;

1.36
date	2008.05.20.00.30.30;	author fgsch;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.29.18.22.24;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.17.16.30.13;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.12.00.26.58;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.11.18.53.51;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.31.16.12.52;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.12.06.53.13;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.08.03.12.44.59;	author danh;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.16.14.47.31;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.18.01.02.42;	author jsyn;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.17.00.10.52;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.16.19.58.57;	author jsyn;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.15.08.35.34;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.06.23.39.17;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.27.20.53.25;	author pvalchev;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.23.14.23.15;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.06.19.45.14;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.03.17.00.09;	author marc;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.12.10.51.13;	author art;	state Exp;
branches;
next	1.11;

1.11
date	99.06.15.01.18.34;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.01.10.17.55.02;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.10.29.04.09.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.06.25.19.01.58;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.06.19.13.58.42;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.06.18.22.42.35;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.01.02.18.16.52;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.01.02.17.37.26;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.01.02.09.34.00;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.12.29.12.24.05;	author graichen;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.71
log
@Keep histptr inside of the allocated history array

histptr == history -1 means that the history is empty, but the behavior
is then undefined.  Allocate an extra array entry to work around this.
Input & ok tb@@
@
text
@/*	$OpenBSD: history.c,v 1.70 2017/08/31 11:10:03 jca Exp $	*/

/*
 * command history
 */

/*
 *	This file contains
 *	a)	the original in-memory history  mechanism
 *	b)	a more complicated mechanism done by  pc@@hillside.co.uk
 *		that more closely follows the real ksh way of doing
 *		things.
 */

#include <sys/stat.h>
#include <sys/uio.h>

#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <vis.h>

#include "sh.h"

#ifdef HISTORY

static void	history_write(void);
static FILE	*history_open(void);
static int	history_load(Source *);
static void	history_close(void);

static int	hist_execute(char *);
static int	hist_replace(char **, const char *, const char *, int);
static char   **hist_get(const char *, int, int);
static char   **hist_get_oldest(void);
static void	histbackup(void);

static FILE	*histfh;
static char   **histbase;	/* actual start of the history[] allocation */
static char   **current;	/* current position in history[] */
static char    *hname;		/* current name of history file */
static int	hstarted;	/* set after hist_init() called */
static int	ignoredups;	/* ditch duplicated history lines? */
static int	ignorespace;	/* ditch lines starting with a space? */
static Source	*hist_source;
static uint32_t	line_co;

static struct stat last_sb;

int
c_fc(char **wp)
{
	struct shf *shf;
	struct temp *tf = NULL;
	char *p, *editor = NULL;
	int gflag = 0, lflag = 0, nflag = 0, sflag = 0, rflag = 0;
	int optc, ret;
	char *first = NULL, *last = NULL;
	char **hfirst, **hlast, **hp;
	static int depth;

	if (depth != 0) {
		bi_errorf("history function called recursively");
		return 1;
	}

	if (!Flag(FTALKING_I)) {
		bi_errorf("history functions not available");
		return 1;
	}

	while ((optc = ksh_getopt(wp, &builtin_opt,
	    "e:glnrs0,1,2,3,4,5,6,7,8,9,")) != -1)
		switch (optc) {
		case 'e':
			p = builtin_opt.optarg;
			if (strcmp(p, "-") == 0)
				sflag++;
			else {
				size_t len = strlen(p) + 4;
				editor = str_nsave(p, len, ATEMP);
				strlcat(editor, " $_", len);
			}
			break;
		case 'g': /* non-at&t ksh */
			gflag++;
			break;
		case 'l':
			lflag++;
			break;
		case 'n':
			nflag++;
			break;
		case 'r':
			rflag++;
			break;
		case 's':	/* posix version of -e - */
			sflag++;
			break;
		  /* kludge city - accept -num as -- -num (kind of) */
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			p = shf_smprintf("-%c%s",
					optc, builtin_opt.optarg);
			if (!first)
				first = p;
			else if (!last)
				last = p;
			else {
				bi_errorf("too many arguments");
				return 1;
			}
			break;
		case '?':
			return 1;
		}
	wp += builtin_opt.optind;

	/* Substitute and execute command */
	if (sflag) {
		char *pat = NULL, *rep = NULL;

		if (editor || lflag || nflag || rflag) {
			bi_errorf("can't use -e, -l, -n, -r with -s (-e -)");
			return 1;
		}

		/* Check for pattern replacement argument */
		if (*wp && **wp && (p = strchr(*wp + 1, '='))) {
			pat = str_save(*wp, ATEMP);
			p = pat + (p - *wp);
			*p++ = '\0';
			rep = p;
			wp++;
		}
		/* Check for search prefix */
		if (!first && (first = *wp))
			wp++;
		if (last || *wp) {
			bi_errorf("too many arguments");
			return 1;
		}

		hp = first ? hist_get(first, false, false) :
		    hist_get_newest(false);
		if (!hp)
			return 1;
		depth++;
		ret = hist_replace(hp, pat, rep, gflag);
		depth--;
		return ret;
	}

	if (editor && (lflag || nflag)) {
		bi_errorf("can't use -l, -n with -e");
		return 1;
	}

	if (!first && (first = *wp))
		wp++;
	if (!last && (last = *wp))
		wp++;
	if (*wp) {
		bi_errorf("too many arguments");
		return 1;
	}
	if (!first) {
		hfirst = lflag ? hist_get("-16", true, true) :
		    hist_get_newest(false);
		if (!hfirst)
			return 1;
		/* can't fail if hfirst didn't fail */
		hlast = hist_get_newest(false);
	} else {
		/* POSIX says not an error if first/last out of bounds
		 * when range is specified; at&t ksh and pdksh allow out of
		 * bounds for -l as well.
		 */
		hfirst = hist_get(first, (lflag || last) ? true : false,
		    lflag ? true : false);
		if (!hfirst)
			return 1;
		hlast = last ? hist_get(last, true, lflag ? true : false) :
		    (lflag ? hist_get_newest(false) : hfirst);
		if (!hlast)
			return 1;
	}
	if (hfirst > hlast) {
		char **temp;

		temp = hfirst; hfirst = hlast; hlast = temp;
		rflag = !rflag; /* POSIX */
	}

	/* List history */
	if (lflag) {
		char *s, *t;
		const char *nfmt = nflag ? "\t" : "%d\t";

		for (hp = rflag ? hlast : hfirst;
		    hp >= hfirst && hp <= hlast; hp += rflag ? -1 : 1) {
			shf_fprintf(shl_stdout, nfmt,
			    hist_source->line - (int) (histptr - hp));
			/* print multi-line commands correctly */
			for (s = *hp; (t = strchr(s, '\n')); s = t)
				shf_fprintf(shl_stdout, "%.*s\t", ++t - s, s);
			shf_fprintf(shl_stdout, "%s\n", s);
		}
		shf_flush(shl_stdout);
		return 0;
	}

	/* Run editor on selected lines, then run resulting commands */

	tf = maketemp(ATEMP, TT_HIST_EDIT, &genv->temps);
	if (!(shf = tf->shf)) {
		bi_errorf("cannot create temp file %s - %s",
		    tf->name, strerror(errno));
		return 1;
	}
	for (hp = rflag ? hlast : hfirst;
	    hp >= hfirst && hp <= hlast; hp += rflag ? -1 : 1)
		shf_fprintf(shf, "%s\n", *hp);
	if (shf_close(shf) == EOF) {
		bi_errorf("error writing temporary file - %s", strerror(errno));
		return 1;
	}

	/* Ignore setstr errors here (arbitrary) */
	setstr(local("_", false), tf->name, KSH_RETURN_ERROR);

	/* XXX: source should not get trashed by this.. */
	{
		Source *sold = source;

		ret = command(editor ? editor : "${FCEDIT:-/bin/ed} $_", 0);
		source = sold;
		if (ret)
			return ret;
	}

	{
		struct stat statb;
		XString xs;
		char *xp;
		int n;

		if (!(shf = shf_open(tf->name, O_RDONLY, 0, 0))) {
			bi_errorf("cannot open temp file %s", tf->name);
			return 1;
		}

		n = fstat(shf->fd, &statb) < 0 ? 128 :
		    statb.st_size + 1;
		Xinit(xs, xp, n, hist_source->areap);
		while ((n = shf_read(xp, Xnleft(xs, xp), shf)) > 0) {
			xp += n;
			if (Xnleft(xs, xp) <= 0)
				XcheckN(xs, xp, Xlength(xs, xp));
		}
		if (n < 0) {
			bi_errorf("error reading temp file %s - %s",
			    tf->name, strerror(shf->errno_));
			shf_close(shf);
			return 1;
		}
		shf_close(shf);
		*xp = '\0';
		strip_nuls(Xstring(xs, xp), Xlength(xs, xp));
		depth++;
		ret = hist_execute(Xstring(xs, xp));
		depth--;
		return ret;
	}
}

/* Save cmd in history, execute cmd (cmd gets trashed) */
static int
hist_execute(char *cmd)
{
	Source *sold;
	int ret;
	char *p, *q;

	histbackup();

	for (p = cmd; p; p = q) {
		if ((q = strchr(p, '\n'))) {
			*q++ = '\0'; /* kill the newline */
			if (!*q) /* ignore trailing newline */
				q = NULL;
		}
		histsave(++(hist_source->line), p, 1);

		shellf("%s\n", p); /* POSIX doesn't say this is done... */
		if ((p = q)) /* restore \n (trailing \n not restored) */
			q[-1] = '\n';
	}

	/* Commands are executed here instead of pushing them onto the
	 * input 'cause posix says the redirection and variable assignments
	 * in
	 *	X=y fc -e - 42 2> /dev/null
	 * are to effect the repeated commands environment.
	 */
	/* XXX: source should not get trashed by this.. */
	sold = source;
	ret = command(cmd, 0);
	source = sold;
	return ret;
}

static int
hist_replace(char **hp, const char *pat, const char *rep, int global)
{
	char *line;

	if (!pat)
		line = str_save(*hp, ATEMP);
	else {
		char *s, *s1;
		int pat_len = strlen(pat);
		int rep_len = strlen(rep);
		int len;
		XString xs;
		char *xp;
		int any_subst = 0;

		Xinit(xs, xp, 128, ATEMP);
		for (s = *hp; (s1 = strstr(s, pat)) && (!any_subst || global);
		    s = s1 + pat_len) {
			any_subst = 1;
			len = s1 - s;
			XcheckN(xs, xp, len + rep_len);
			memcpy(xp, s, len);		/* first part */
			xp += len;
			memcpy(xp, rep, rep_len);	/* replacement */
			xp += rep_len;
		}
		if (!any_subst) {
			bi_errorf("substitution failed");
			return 1;
		}
		len = strlen(s) + 1;
		XcheckN(xs, xp, len);
		memcpy(xp, s, len);
		xp += len;
		line = Xclose(xs, xp);
	}
	return hist_execute(line);
}

/*
 * get pointer to history given pattern
 * pattern is a number or string
 */
static char **
hist_get(const char *str, int approx, int allow_cur)
{
	char **hp = NULL;
	int n;

	if (getn(str, &n)) {
		hp = histptr + (n < 0 ? n : (n - hist_source->line));
		if ((long)hp < (long)history) {
			if (approx)
				hp = hist_get_oldest();
			else {
				bi_errorf("%s: not in history", str);
				hp = NULL;
			}
		} else if (hp > histptr) {
			if (approx)
				hp = hist_get_newest(allow_cur);
			else {
				bi_errorf("%s: not in history", str);
				hp = NULL;
			}
		} else if (!allow_cur && hp == histptr) {
			bi_errorf("%s: invalid range", str);
			hp = NULL;
		}
	} else {
		int anchored = *str == '?' ? (++str, 0) : 1;

		/* the -1 is to avoid the current fc command */
		n = findhist(histptr - history - 1, 0, str, anchored);
		if (n < 0) {
			bi_errorf("%s: not in history", str);
			hp = NULL;
		} else
			hp = &history[n];
	}
	return hp;
}

/* Return a pointer to the newest command in the history */
char **
hist_get_newest(int allow_cur)
{
	if (histptr < history || (!allow_cur && histptr == history)) {
		bi_errorf("no history (yet)");
		return NULL;
	}
	if (allow_cur)
		return histptr;
	return histptr - 1;
}

/* Return a pointer to the oldest command in the history */
static char **
hist_get_oldest(void)
{
	if (histptr <= history) {
		bi_errorf("no history (yet)");
		return NULL;
	}
	return history;
}

/******************************/
/* Back up over last histsave */
/******************************/
static void
histbackup(void)
{
	static int last_line = -1;

	if (histptr >= history && last_line != hist_source->line) {
		hist_source->line--;
		afree(*histptr, APERM);
		histptr--;
		last_line = hist_source->line;
	}
}

static void
histreset(void)
{
	char **hp;

	for (hp = history; hp <= histptr; hp++)
		afree(*hp, APERM);

	histptr = history - 1;
	hist_source->line = 0;
}

/*
 * Return the current position.
 */
char **
histpos(void)
{
	return current;
}

int
histnum(int n)
{
	int	last = histptr - history;

	if (n < 0 || n >= last) {
		current = histptr;
		return last;
	} else {
		current = &history[n];
		return n;
	}
}

/*
 * This will become unnecessary if hist_get is modified to allow
 * searching from positions other than the end, and in either
 * direction.
 */
int
findhist(int start, int fwd, const char *str, int anchored)
{
	char	**hp;
	int	maxhist = histptr - history;
	int	incr = fwd ? 1 : -1;
	int	len = strlen(str);

	if (start < 0 || start >= maxhist)
		start = maxhist;

	hp = &history[start];
	for (; hp >= history && hp <= histptr; hp += incr)
		if ((anchored && strncmp(*hp, str, len) == 0) ||
		    (!anchored && strstr(*hp, str)))
			return hp - history;

	return -1;
}

int
findhistrel(const char *str)
{
	int	maxhist = histptr - history;
	int	start = maxhist - 1;
	int	rec = atoi(str);

	if (rec == 0)
		return -1;
	if (rec > 0) {
		if (rec > maxhist)
			return -1;
		return rec - 1;
	}
	if (rec > maxhist)
		return -1;
	return start + rec + 1;
}

void
sethistcontrol(const char *str)
{
	char *spec, *tok, *state;

	ignorespace = 0;
	ignoredups = 0;

	if (str == NULL)
		return;

	spec = str_save(str, ATEMP);
	for (tok = strtok_r(spec, ":", &state); tok != NULL;
	     tok = strtok_r(NULL, ":", &state)) {
		if (strcmp(tok, "ignoredups") == 0)
			ignoredups = 1;
		else if (strcmp(tok, "ignorespace") == 0)
			ignorespace = 1;
	}
	afree(spec, ATEMP);
}

/*
 *	set history
 *	this means reallocating the dataspace
 */
void
sethistsize(int n)
{
	if (n > 0 && n != histsize) {
		int offset = histptr - history;

		/* save most recent history */
		if (offset > n - 1) {
			char **hp;

			offset = n - 1;
			for (hp = history; hp < histptr - offset; hp++)
				afree(*hp, APERM);
			memmove(history, histptr - offset, n * sizeof(char *));
		}

		histsize = n;
		histbase = areallocarray(histbase, n + 1, sizeof(char *), APERM);
		history = histbase + 1;
		histptr = history + offset;
	}
}

/*
 *	set history file
 *	This can mean reloading/resetting/starting history file
 *	maintenance
 */
void
sethistfile(const char *name)
{
	/* if not started then nothing to do */
	if (hstarted == 0)
		return;

	/* if the name is the same as the name we have */
	if (hname && strcmp(hname, name) == 0)
		return;
	/*
	 * its a new name - possibly
	 */
	if (hname) {
		afree(hname, APERM);
		hname = NULL;
		histreset();
	}

	history_close();
	hist_init(hist_source);
}

/*
 *	initialise the history vector
 */
void
init_histvec(void)
{
	if (histbase == NULL) {
		histsize = HISTORYSIZE;
		/*
		 * allocate one extra element so that histptr always
		 * lies within array bounds
		 */
		histbase = areallocarray(NULL, histsize + 1, sizeof(char *),
		    APERM);
		history = histbase + 1;
		histptr = history - 1;
	}
}

static void
history_lock(int operation)
{
	while (flock(fileno(histfh), operation) != 0) {
		if (errno == EINTR || errno == EAGAIN)
			continue;
		else
			break;
	}
}

/*
 *	Routines added by Peter Collinson BSDI(Europe)/Hillside Systems to
 *	a) permit HISTSIZE to control number of lines of history stored
 *	b) maintain a physical history file
 *
 *	It turns out that there is a lot of ghastly hackery here
 */


/*
 * save command in history
 */
void
histsave(int lno, const char *cmd, int dowrite)
{
	char		*c, *cp;

	if (ignorespace && cmd[0] == ' ')
		return;

	c = str_save(cmd, APERM);
	if ((cp = strrchr(c, '\n')) != NULL)
		*cp = '\0';

	/*
	 * XXX to properly check for duplicated lines we should first reload
	 * the histfile if needed
	 */
	if (ignoredups && histptr >= history && strcmp(*histptr, c) == 0) {
		afree(c, APERM);
		return;
	}

	if (dowrite && histfh) {
#ifndef SMALL
		struct stat	sb;

		history_lock(LOCK_EX);
		if (fstat(fileno(histfh), &sb) != -1) {
			if (timespeccmp(&sb.st_mtim, &last_sb.st_mtim, ==))
				; /* file is unchanged */
			else {
				histreset();
				history_load(hist_source);
			}
		}
#endif
	}

	if (histptr < history + histsize - 1)
		histptr++;
	else { /* remove oldest command */
		afree(*history, APERM);
		memmove(history, history + 1,
		    (histsize - 1) * sizeof(*history));
	}
	*histptr = c;

	if (dowrite && histfh) {
#ifndef SMALL
		char *encoded;

		/* append to file */
		if (fseeko(histfh, 0, SEEK_END) == 0 &&
		    stravis(&encoded, c, VIS_SAFE | VIS_NL) != -1) {
			fprintf(histfh, "%s\n", encoded);
			fflush(histfh);
			fstat(fileno(histfh), &last_sb);
			line_co++;
			history_write();
			free(encoded);
		}
		history_lock(LOCK_UN);
#endif
	}
}

static FILE *
history_open(void)
{
	FILE		*f = NULL;
#ifndef SMALL
	struct stat	sb;
	int		fd, fddup;

	if ((fd = open(hname, O_RDWR | O_CREAT | O_EXLOCK, 0600)) == -1)
		return NULL;
	if (fstat(fd, &sb) == -1 || sb.st_uid != getuid()) {
		close(fd);
		return NULL;
	}
	fddup = savefd(fd);
	if (fddup != fd)
		close(fd);

	if ((f = fdopen(fddup, "r+")) == NULL)
		close(fddup);
	else
		last_sb = sb;
#endif
	return f;
}

static void
history_close(void)
{
	if (histfh) {
		fflush(histfh);
		fclose(histfh);
		histfh = NULL;
	}
}

static int
history_load(Source *s)
{
	char		*p, encoded[LINE + 1], line[LINE + 1];

	rewind(histfh);

	/* just read it all; will auto resize history upon next command */
	for (line_co = 1; ; line_co++) {
		p = fgets(encoded, sizeof(encoded), histfh);
		if (p == NULL || feof(histfh) || ferror(histfh))
			break;
		if ((p = strchr(encoded, '\n')) == NULL) {
			bi_errorf("history file is corrupt");
			return 1;
		}
		*p = '\0';
		s->line = line_co;
		s->cmd_offset = line_co;
		strunvis(line, encoded);
		histsave(line_co, line, 0);
	}

	history_write();

	return 0;
}

#define HMAGIC1 0xab
#define HMAGIC2 0xcd

void
hist_init(Source *s)
{
	int oldmagic1, oldmagic2;

	if (Flag(FTALKING) == 0)
		return;

	hstarted = 1;

	hist_source = s;

	hname = str_val(global("HISTFILE"));
	if (hname == NULL)
		return;
	hname = str_save(hname, APERM);
	histfh = history_open();
	if (histfh == NULL)
		return;

	oldmagic1 = fgetc(histfh);
	oldmagic2 = fgetc(histfh);

	if (oldmagic1 == EOF || oldmagic2 == EOF) {
		if (!feof(histfh) && ferror(histfh)) {
			history_close();
			return;
		}
	} else if (oldmagic1 == HMAGIC1 && oldmagic2 == HMAGIC2) {
		bi_errorf("ignoring old style history file");
		history_close();
		return;
	}

	rewind(histfh);

	history_load(s);

	history_lock(LOCK_UN);
}

static void
history_write(void)
{
	char		**hp, *encoded;

	/* see if file has grown over 25% */
	if (line_co < histsize + (histsize / 4))
		return;

	/* rewrite the whole caboodle */
	rewind(histfh);
	if (ftruncate(fileno(histfh), 0) == -1) {
		bi_errorf("failed to rewrite history file - %s",
		    strerror(errno));
	}
	for (hp = history; hp <= histptr; hp++) {
		if (stravis(&encoded, *hp, VIS_SAFE | VIS_NL) != -1) {
			if (fprintf(histfh, "%s\n", encoded) == -1) {
				free(encoded);
				return;
			}
			free(encoded);
		}
	}

	line_co = histsize;

	fflush(histfh);
	fstat(fileno(histfh), &last_sb);
}

void
hist_finish(void)
{
	history_close();
}

#else /* HISTORY */

/* No history to be compiled in: dummy routines to avoid lots more ifdefs */
void
init_histvec(void)
{
}
void
hist_init(Source *s)
{
}
void
hist_finish(void)
{
}
void
histsave(int lno, const char *cmd, int dowrite)
{
	errorf("history not enabled");
}
#endif /* HISTORY */
@


1.70
log
@ignoredups implementation quirk

Reminded by tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.69 2017/08/30 17:08:45 jca Exp $	*/
d42 1
a560 1
		history = areallocarray(history, n, sizeof(char *), APERM);
d562 2
d602 1
a602 1
	if (history == NULL) {
d604 7
a610 1
		history = areallocarray(NULL, histsize, sizeof(char *), APERM);
@


1.69
log
@Implement HISTCONTROL ignoredups & ignorespace features

ignoredups: don't save the current line if it is identical to the last
history line.
ignorespace: don't save the current line if it starts with a space

ok anton@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.68 2017/08/28 19:41:55 jca Exp $	*/
d642 4
@


1.68
log
@Don't bother setting freed history lines to NULL.

Dead code that could send the wrong hint to an unsuspicious reader.  The
code should walk use 'history' & 'histptr' to walk the array.
ok millert@@, "go for it" tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.66 2017/08/27 17:10:32 jca Exp $	*/
d45 2
d518 22
d635 12
a661 4

	c = str_save(cmd, APERM);
	if ((cp = strrchr(c, '\n')) != NULL)
		*cp = '\0';
@


1.67
log
@Put history_write() in line with other functions that walk history

One method is enough: only access history lines between 'history' and
'histptr'. Pointers outside these bounds might be invalid.

ok millert@@, "go for it" tb@@
@
text
@d442 1
a442 1
	for (hp = history; hp <= histptr; hp++) {
a443 2
		*hp = NULL;
	}
d531 1
a531 1
			for (hp = history; hp < histptr - offset; hp++) {
a532 2
				*hp = NULL;
			}
@


1.66
log
@Free history entries when resizing/reloading

Cluebat & ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.65 2017/08/26 12:34:32 jca Exp $	*/
d774 1
a774 2
	char		*cmd, *encoded;
	int		i;
d786 2
a787 6
	for (i = 0; i < histsize; i++) {
		cmd = history[i];
		if (cmd == NULL)
			break;

		if (stravis(&encoded, cmd, VIS_SAFE | VIS_NL) != -1) {
@


1.65
log
@Don't lose the latest history line & don't crash when shrinking histsize

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.64 2017/08/11 19:37:58 tb Exp $	*/
d437 14
d530 2
d533 4
d567 1
a567 3
		/* let's reset the history */
		histptr = history - 1;
		hist_source->line = 0;
d624 1
a624 3
				/* reset history */
				histptr = history - 1;
				hist_source->line = 0;
@


1.64
log
@Check whether the first two characters of $HISTFILE are the magic
characters of the old binary ksh history file. In that case ignore
the history file after displaying an error once. Prevents annoying
repeated 'history file is corrupt' messages in $HOME on NFS setups
suffered by henning and makes the migration from the old to the new
history file format safer.

ok henning, tweaks & ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.63 2017/08/01 14:30:05 deraadt Exp $	*/
d512 1
a512 1
		int cursize = histptr - history;
d515 3
a517 3
		if (n < cursize) {
			memmove(history, histptr - n, n * sizeof(char *));
			cursize = n;
a520 1

d522 1
a522 1
		histptr = history + cursize;
@


1.63
log
@Disable ksh VI-editing mode on the install media.  We need the space
savings.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.62 2017/07/24 23:56:37 tb Exp $	*/
d712 3
d718 2
d734 16
@


1.62
log
@Fix off-by-one error introduced in the previous commit.

ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.61 2017/07/24 22:28:09 jca Exp $	*/
d596 1
a596 2
	struct stat	sb;
	char		*c, *cp, *encoded;
d599 3
d613 1
d630 3
d644 1
d651 2
a653 1
	FILE		*f;
d670 1
a670 1

@


1.61
log
@Prettify, simplify

Input & ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.59 2017/05/29 13:09:17 tb Exp $	*/
d617 1
a617 1
	if (histptr < history + histsize)
@


1.60
log
@Use memmove instead of a hand-rolled loop

A tad faster in my HISTFILE "benchmarks".  ok tb@@
@
text
@d597 1
a597 1
	char		**hp, *c, *cp, *encoded;
d617 3
a619 2
	hp = histptr;
	if (++hp >= history + histsize) { /* remove oldest command */
a622 1
		hp = histptr;
d624 1
a624 2
	*hp = c;
	histptr = hp;
@


1.59
log
@Change the mmap(2)-based binary history file with lots of magic and a
tendency for corruption to a simpler plaintext version.

To convert your current ksh history to plaintext, issue

	fc -ln 1 | sed 's/^	//' > ~/ksh_hist.txt

before upgrading and use ksh_hist.txt as HISTFILE after the upgrade.

Original patch by marco in 2011. Ported to current during g2k16 by me.
Testing, bugfixes and improvements in joint work with natano.

Additional testing by anton and mestre. Includes some tweaks by anton.
Committing now to shake out remaining bugs before 6.2 is cut.

ok deraadt, mestre, anton, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.58 2016/08/24 16:09:40 millert Exp $	*/
d620 3
a622 2
		for (hp = history; hp < history + histsize - 1; hp++)
			hp[0] = hp[1];
@


1.58
log
@Use writev(2) to write history records using a single syscall.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.57 2016/08/24 13:32:17 millert Exp $	*/
d12 1
a12 2
 *		things. You need to have the mmap system call for this
 *		to work on your system
d24 1
a28 1
# include <sys/mman.h>
d30 4
a33 13
/*
 *	variables for handling the data file
 */
static int	histfd;
static int	hsize;

static int hist_count_lines(unsigned char *, int);
static int hist_shrink(unsigned char *, int);
static unsigned char *hist_skip_back(unsigned char *,int *,int);
static void histload(Source *, unsigned char *, int);
static void histinsert(Source *, int, unsigned char *);
static void writehistfile(int, char *);
static int sprinkle(int);
d41 1
d46 1
d48 1
a541 1

d545 1
a545 5
	if (histfd) {
		/* yes the file is open */
		(void) close(histfd);
		histfd = 0;
		hsize = 0;
d553 1
d570 10
d596 16
a611 2
	char **hp;
	char *c, *cp;
d614 1
a614 1
	if ((cp = strchr(c, '\n')) != NULL)
a616 3
	if (histfd && dowrite)
		writehistfile(lno, c);

a617 1

d625 14
d641 2
a642 20
/*
 *	Write history data to a file nominated by HISTFILE. If HISTFILE
 *	is unset then history is still recorded, but the data is not
 *	written to a file. All copies of ksh looking at the file will
 *	maintain the same history. This is ksh behaviour.
 */

/*
 *	History file format:
	 * Bytes 1, 2: HMAGIC - just to check that we are dealing with
	   the correct object
	 * Each command, in the format:
	   <command byte><command number(4 bytes)><bytes><null>
 */
#define HMAGIC1		0xab
#define HMAGIC2		0xcd
#define COMMAND		0xff

void
hist_init(Source *s)
d644 3
a646 4
	unsigned char	*base;
	int	lines;
	int	fd;
	struct stat sb;
d648 2
a649 16
	if (Flag(FTALKING) == 0)
		return;

	hstarted = 1;

	hist_source = s;

	hname = str_val(global("HISTFILE"));
	if (hname == NULL)
		return;
	hname = str_save(hname, APERM);

  retry:
	/* we have a file and are interactive */
	if ((fd = open(hname, O_RDWR|O_CREAT|O_APPEND, 0600)) < 0)
		return;
d652 1
a652 1
		return;
d654 2
a655 3

	histfd = savefd(fd);
	if (histfd != fd)
d658 4
a661 1
	(void) flock(histfd, LOCK_EX);
d663 2
a664 1
	hsize = lseek(histfd, 0L, SEEK_END);
d666 7
a672 38
	if (hsize == 0) {
		/* add magic */
		if (sprinkle(histfd)) {
			hist_finish();
			return;
		}
	}
	else if (hsize > 0) {
		/*
		 * we have some data
		 */
		base = mmap(0, hsize, PROT_READ,
		    MAP_FILE|MAP_PRIVATE, histfd, 0);
		/*
		 * check on its validity
		 */
		if (base == MAP_FAILED || *base != HMAGIC1 || base[1] != HMAGIC2) {
			if (base != MAP_FAILED)
				munmap((caddr_t)base, hsize);
			hist_finish();
			if (unlink(hname) != 0)
				return;
			goto retry;
		}
		if (hsize > 2) {
			lines = hist_count_lines(base+2, hsize-2);
			if (lines > histsize) {
				/* we need to make the file smaller */
				if (hist_shrink(base, hsize))
					if (unlink(hname) != 0)
						return;
				munmap((caddr_t)base, hsize);
				hist_finish();
				goto retry;
			}
		}
		histload(hist_source, base+2, hsize-2);
		munmap((caddr_t)base, hsize);
a673 2
	(void) flock(histfd, LOCK_UN);
	hsize = lseek(histfd, 0L, SEEK_END);
a675 7
typedef enum state {
	shdr,		/* expecting a header */
	sline,		/* looking for a null byte to end the line */
	sn1,		/* bytes 1 to 4 of a line no */
	sn2, sn3, sn4
} State;

d677 1
a677 1
hist_count_lines(unsigned char *base, int bytes)
d679 1
a679 2
	State state = shdr;
	int lines = 0;
d681 6
a686 5
	while (bytes--) {
		switch (state) {
		case shdr:
			if (*base == COMMAND)
				state = sn1;
d688 3
a690 11
		case sn1:
			state = sn2; break;
		case sn2:
			state = sn3; break;
		case sn3:
			state = sn4; break;
		case sn4:
			state = sline; break;
		case sline:
			if (*base == '\0')
				lines++, state = shdr;
d692 5
a696 1
		base++;
d698 4
a701 1
	return lines;
d704 2
a705 5
/*
 *	Shrink the history file to histsize lines
 */
static int
hist_shrink(unsigned char *oldbase, int oldbytes)
d707 2
a708 4
	int fd;
	char	nfile[1024];
	unsigned char *nbase = oldbase;
	int nbytes = oldbytes;
d710 3
a712 5
	nbase = hist_skip_back(nbase, &nbytes, histsize);
	if (nbase == NULL)
		return 1;
	if (nbase == oldbase)
		return 0;
d714 7
a720 6
	/*
	 *	create temp file
	 */
	(void) shf_snprintf(nfile, sizeof(nfile), "%s.%d", hname, procpid);
	if ((fd = open(nfile, O_CREAT | O_TRUNC | O_WRONLY, 0600)) < 0)
		return 1;
d722 1
a722 11
	if (sprinkle(fd)) {
		close(fd);
		unlink(nfile);
		return 1;
	}
	if (write(fd, nbase, nbytes) != nbytes) {
		close(fd);
		unlink(nfile);
		return 1;
	}
	close(fd);
d724 1
a724 6
	/*
	 *	rename
	 */
	if (rename(nfile, hname) < 0)
		return 1;
	return 0;
d727 5
d733 3
a735 9
/*
 *	find a pointer to the data `no' back from the end of the file
 *	return the pointer and the number of bytes left
 */
static unsigned char *
hist_skip_back(unsigned char *base, int *bytes, int no)
{
	int lines = 0;
	unsigned char *ep;
d737 9
a745 8
	for (ep = base + *bytes; --ep > base; ) {
		/* this doesn't really work: the 4 byte line number that is
		 * encoded after the COMMAND byte can itself contain the
		 * COMMAND byte....
		 */
		for (; ep > base && *ep != COMMAND; ep--)
			;
		if (ep == base)
a746 7
		if (++lines == no) {
			*bytes = *bytes - ((char *)ep - (char *)base);
			return ep;
		}
	}
	return NULL;
}
d748 4
a751 46
/*
 *	load the history structure from the stored data
 */
static void
histload(Source *s, unsigned char *base, int bytes)
{
	State state;
	int	lno = 0;
	unsigned char	*line = NULL;

	for (state = shdr; bytes-- > 0; base++) {
		switch (state) {
		case shdr:
			if (*base == COMMAND)
				state = sn1;
			break;
		case sn1:
			lno = (((*base)&0xff)<<24);
			state = sn2;
			break;
		case sn2:
			lno |= (((*base)&0xff)<<16);
			state = sn3;
			break;
		case sn3:
			lno |= (((*base)&0xff)<<8);
			state = sn4;
			break;
		case sn4:
			lno |= (*base)&0xff;
			line = base+1;
			state = sline;
			break;
		case sline:
			if (*base == '\0') {
				/* worry about line numbers */
				if (histptr >= history && lno-1 != s->line) {
					/* a replacement ? */
					histinsert(s, lno, line);
				}
				else {
					s->line = lno;
					s->cmd_offset = lno;
					histsave(lno, (char *)line, 0);
				}
				state = shdr;
d753 1
a755 9
}

/*
 *	Insert a line into the history at a specified number
 */
static void
histinsert(Source *s, int lno, unsigned char *line)
{
	char **hp;
d757 1
a757 6
	if (lno >= s->line-(histptr-history) && lno <= s->line) {
		hp = &histptr[lno-s->line];
		afree(*hp, APERM);
		*hp = str_save((char *)line, APERM);
	}
}
d759 2
a760 66
/*
 *	write a command to the end of the history file
 *	This *MAY* seem easy but it's also necessary to check
 *	that the history file has not changed in size.
 *	If it has - then some other shell has written to it
 *	and we should read those commands to update our history
 */
static void
writehistfile(int lno, char *cmd)
{
	int	sizenow;
	unsigned char	*base;
	unsigned char	*new;
	int	bytes;
	unsigned char	hdr[5];
	struct iovec	iov[2];

	(void) flock(histfd, LOCK_EX);
	sizenow = lseek(histfd, 0L, SEEK_END);
	if (sizenow != hsize) {
		/*
		 *	Things have changed
		 */
		if (sizenow > hsize) {
			/* someone has added some lines */
			bytes = sizenow - hsize;
			base = mmap(0, sizenow,
			    PROT_READ, MAP_FILE|MAP_PRIVATE, histfd, 0);
			if (base == MAP_FAILED)
				goto bad;
			new = base + hsize;
			if (*new != COMMAND) {
				munmap((caddr_t)base, sizenow);
				goto bad;
			}
			hist_source->line--;
			histload(hist_source, new, bytes);
			hist_source->line++;
			lno = hist_source->line;
			munmap((caddr_t)base, sizenow);
			hsize = sizenow;
		} else {
			/* it has shrunk */
			/* but to what? */
			/* we'll give up for now */
			goto bad;
		}
	}
	/*
	 *	we can write our bit now
	 */
	hdr[0] = COMMAND;
	hdr[1] = (lno>>24)&0xff;
	hdr[2] = (lno>>16)&0xff;
	hdr[3] = (lno>>8)&0xff;
	hdr[4] = lno&0xff;
	iov[0].iov_base = hdr;
	iov[0].iov_len = 5;
	iov[1].iov_base = cmd;
	iov[1].iov_len = strlen(cmd) + 1;
	(void) writev(histfd, iov, 2);
	hsize = lseek(histfd, 0L, SEEK_END);
	(void) flock(histfd, LOCK_UN);
	return;
bad:
	hist_finish();
d766 1
a766 14
	(void) flock(histfd, LOCK_UN);
	(void) close(histfd);
	histfd = 0;
}

/*
 *	add magic to the history file
 */
static int
sprinkle(int fd)
{
	static unsigned char mag[] = { HMAGIC1, HMAGIC2 };

	return(write(fd, mag, 2) != 2);
@


1.57
log
@Avoid recursively calling c_fc().  Fixes a core dump from "r r" and
other edge cases found by gsoares@@.  OK tb@@ gsoares@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.56 2015/12/30 09:07:00 tedu Exp $	*/
d17 1
d905 1
d946 5
a950 2
	(void) write(histfd, hdr, 5);
	(void) write(histfd, cmd, strlen(cmd)+1);
@


1.56
log
@rename global "e" to genv to avoid accidental shadowing and aliasing.
ok millert nicm tb
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.55 2015/12/14 13:59:42 tb Exp $	*/
d63 1
a63 1
	int optc;
d66 6
d154 4
a157 1
		return hist_replace(hp, pat, rep, gflag);
a240 1
		int ret;
d276 4
a279 1
		return hist_execute(Xstring(xs, xp));
@


1.55
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.54 2015/12/14 06:09:43 mmcc Exp $	*/
d212 1
a212 1
	tf = maketemp(ATEMP, TT_HIST_EDIT, &e->temps);
@


1.54
log
@Remove a superfluous macro. No binary change. ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.53 2015/11/02 16:38:35 mmcc Exp $	*/
d18 4
d23 1
@


1.53
log
@Another aresize() -> areallocarray().

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.52 2015/11/01 15:38:53 mmcc Exp $	*/
d256 1
a256 1
			    tf->name, strerror(shf_errno(shf)));
@


1.52
log
@Add uses of areallocarray(). mksh and Bitrig ksh already have similar
functions. With help from Theo Buehler.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.51 2015/10/21 15:47:41 mmcc Exp $	*/
d510 1
a510 1
		history = (char **)aresize(history, n*sizeof(char *), APERM);
@


1.51
log
@Remove a couple of unhelpful defines.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.50 2015/10/21 15:20:37 mmcc Exp $	*/
d559 1
a559 1
		history = alloc(histsize*sizeof (char *), APERM);
@


1.50
log
@Don't bother casting NULL.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.49 2015/10/19 14:42:16 mmcc Exp $	*/
d246 1
a246 1
		n = fstat(shf_fileno(shf), &statb) < 0 ? 128 :
@


1.49
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.48 2015/10/19 02:15:45 mmcc Exp $	*/
d557 1
a557 1
	if (history == (char **)NULL) {
@


1.48
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.47 2015/10/09 19:36:27 tedu Exp $	*/
d17 2
@


1.47
log
@remove null check before afree. from Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.46 2015/10/08 16:41:26 tedu Exp $	*/
d16 2
a18 1
#include <sys/stat.h>
@


1.46
log
@stop trying to gift history files to the original owner. instead, don't
open history files that don't belong to us. probably much safer.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.45 2015/10/08 15:54:59 tedu Exp $	*/
d865 1
a865 2
		if (*hp)
			afree(*hp, APERM);
@


1.45
log
@little cleanup from Michael McConville, mostly related to stale comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.44 2015/09/17 21:39:54 nicm Exp $	*/
d622 1
d640 4
a739 1
	struct	stat statb;
a765 5
	/*
	 *	worry about who owns this file
	 */
	if (fstat(histfd, &statb) >= 0)
		fchown(fd, statb.st_uid, statb.st_gid);
@


1.44
log
@More (foo *)0 -> NULL, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.43 2015/09/17 14:21:33 nicm Exp $	*/
a4 2
 *
 * only implements in-memory history.
d599 4
a602 8
 *	Write history data to a file nominated by HISTFILE
 *	if HISTFILE is unset then history still happens, but
 *	the data is not written to a file
 *	All copies of ksh looking at the file will maintain the
 *	same history. This is ksh behaviour.
 *
 *	This stuff uses mmap()
 *	if your system ain't got it - then you'll have to undef HISTORYFILE
d606 5
a610 7
 *	Open a history file
 *	Format is:
 *	Bytes 1, 2: HMAGIC - just to check that we are dealing with
 *		    the correct object
 *	Then follows a number of stored commands
 *	Each command is
 *	<command byte><command number(4 bytes)><bytes><null>
d659 1
a659 1
		base = (unsigned char *)mmap(0, hsize, PROT_READ,
d897 1
a897 1
			base = (unsigned char *)mmap(0, sizenow,
@


1.43
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.42 2015/09/15 18:15:05 tedu Exp $	*/
d349 1
a349 1
	char **hp = (char **) 0;
d359 1
a359 1
				hp = (char **) 0;
d366 1
a366 1
				hp = (char **) 0;
d370 1
a370 1
			hp = (char **) 0;
d379 1
a379 1
			hp = (char **) 0;
d392 1
a392 1
		return (char **) 0;
d405 1
a405 1
		return (char **) 0;
@


1.42
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.41 2015/09/01 13:12:31 tedu Exp $	*/
d558 1
a558 1
		history = (char **)alloc(histsize*sizeof (char *), APERM);
@


1.41
log
@remove casts and null checks before free. from Michael McConville
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.40 2014/11/20 15:22:39 tedu Exp $	*/
d55 1
a55 1
	char *p, *editor = (char *) 0;
d58 1
a58 1
	char *first = (char *) 0, *last = (char *) 0;
d115 1
a115 1
		char *pat = (char *) 0, *rep = (char *) 0;
d280 1
a280 1
				q = (char *) 0;
@


1.40
log
@remove sys/file.h includes in favor of fcntl.h where needed.
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.39 2010/05/19 17:36:08 jasper Exp $	*/
d420 1
a420 1
		afree((void*)*histptr, APERM);
d592 1
a592 1
		afree((void*)*history, APERM);
d875 1
a875 1
			afree((void*)*hp, APERM);
@


1.39
log
@properly keep track of the line number after a trap.
this fixes pr 6195. diff from manuel giraud, thanks.

ok kili@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.38 2010/05/01 21:09:23 guenther Exp $	*/
a21 1
# include <sys/file.h>
@


1.38
log
@Correct a comment; from dawedawe (at) gmx.de
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.37 2009/07/02 16:29:15 martynas Exp $	*/
d229 1
a229 1
		ret = command(editor ? editor : "${FCEDIT:-/bin/ed} $_");
d298 1
a298 1
	ret = command(cmd);
@


1.37
log
@avoid infinite recursion if unlink fails.  reported by Stefan Pettersson
ok theo, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.36 2008/05/20 00:30:30 fgsch Exp $	*/
d400 1
a400 1
/* Return a pointer to the newest command in the history */
@


1.36
log
@cast pointer arithmetic to unsigned so we can behave correctly on
underflows. fixes fc -l 1 in my box where line is 1667511151.
krw@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.35 2006/05/29 18:22:24 otto Exp $	*/
d677 2
a678 1
			unlink(hname);
d686 2
a687 1
					unlink(hname);
@


1.35
log
@Implement \$ and \# expansion for PS1. Whoever thought it a clever
idea to assign a special meaning to "\$" -- two chars that are already
(very) special -- deserves a spanking.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.34 2006/03/17 16:30:13 millert Exp $	*/
d355 1
a355 1
		if (hp < history) {
@


1.34
log
@Simplify savefd() by removing the "noclose" flag and make noclose
behavior the default.  Almost all uses of savefd() are followed
by an implicit or explicit close.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.33 2006/03/12 00:26:58 deraadt Exp $	*/
d854 1
@


1.33
log
@might as well make ksh_getopt() match real getopt(), ie. get rid of that
stupid EOF concept that was never true.  adobriyan@@gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.32 2005/12/11 18:53:51 deraadt Exp $	*/
d649 3
a651 1
	histfd = savefd(fd, 0);
@


1.32
log
@remove unused variables and functions
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.31 2005/07/31 16:12:52 espie Exp $	*/
d68 1
a68 1
	    "e:glnrs0,1,2,3,4,5,6,7,8,9,")) != EOF)
@


1.31
log
@say goodbye to creat().
okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.30 2005/03/30 17:16:37 deraadt Exp $	*/
a45 1
static int	curpos;		/* current index in history[] */
a436 6
histN(void)
{
	return curpos;
}

int
a442 1
		curpos = last;
a445 1
		curpos = n;
@


1.30
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.29 2004/12/22 17:14:34 millert Exp $	*/
d763 1
a763 1
	if ((fd = creat(nfile, 0600)) < 0)
@


1.29
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.28 2004/12/20 11:34:26 otto Exp $	*/
d68 2
a69 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "e:glnrs0,1,2,3,4,5,6,7,8,9,")) != EOF)
d71 1
a71 1
		  case 'e':
d81 1
a81 1
		  case 'g': /* non-at&t ksh */
d84 1
a84 1
		  case 'l':
d87 1
a87 1
		  case 'n':
d90 1
a90 1
		  case 'r':
d93 1
a93 1
		  case 's':	/* posix version of -e - */
d97 2
a98 2
		  case '0': case '1': case '2': case '3': case '4':
		  case '5': case '6': case '7': case '8': case '9':
d110 1
a110 1
		  case '?':
d140 2
a141 2
		hp = first ? hist_get(first, false, false)
			   : hist_get_newest(false);
d161 2
a162 2
		hfirst = lflag ? hist_get("-16", true, true)
			       : hist_get_newest(false);
d173 1
a173 1
				lflag ? true : false);
d176 2
a177 2
		hlast = last ? hist_get(last, true, lflag ? true : false)
			    : (lflag ? hist_get_newest(false) : hfirst);
d194 1
a194 2
		     hp >= hfirst && hp <= hlast; hp += rflag ? -1 : 1)
		{
d196 1
a196 1
				hist_source->line - (int) (histptr - hp));
d211 1
a211 1
			tf->name, strerror(errno));
d215 1
a215 1
	     hp >= hfirst && hp <= hlast; hp += rflag ? -1 : 1)
d247 2
a248 2
		n = fstat(shf_fileno(shf), &statb) < 0 ? 128
			: statb.st_size + 1;
d257 1
a257 1
				tf->name, strerror(shf_errno(shf)));
d321 2
a322 3
		for (s = *hp; (s1 = strstr(s, pat))
			      && (!any_subst || global) ; s = s1 + pat_len)
		{
d477 2
a478 2
		if ((anchored && strncmp(*hp, str, len) == 0)
		    || (!anchored && strstr(*hp, str)))
d675 2
a676 1
		base = (unsigned char *)mmap(0, hsize, PROT_READ, MAP_FILE|MAP_PRIVATE, histfd, 0);
d719 1
a719 2
		switch (state)
		{
d910 2
a911 1
			base = (unsigned char *)mmap(0, sizenow, PROT_READ, MAP_FILE|MAP_PRIVATE, histfd, 0);
@


1.28
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.27 2004/12/18 21:25:44 millert Exp $	*/
d139 2
a140 2
		hp = first ? hist_get(first, FALSE, FALSE)
			   : hist_get_newest(FALSE);
d160 2
a161 2
		hfirst = lflag ? hist_get("-16", TRUE, TRUE)
			       : hist_get_newest(FALSE);
d165 1
a165 1
		hlast = hist_get_newest(FALSE);
d171 2
a172 2
		hfirst = hist_get(first, (lflag || last) ? TRUE : FALSE,
				lflag ? TRUE : FALSE);
d175 2
a176 2
		hlast = last ? hist_get(last, TRUE, lflag ? TRUE : FALSE)
			    : (lflag ? hist_get_newest(FALSE) : hfirst);
d223 1
a223 1
	setstr(local("_", FALSE), tf->name, KSH_RETURN_ERROR);
@


1.27
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.26 2004/12/18 20:55:52 millert Exp $	*/
d39 3
a41 4
static int	hist_execute(char *cmd);
static int	hist_replace(char **hp, const char *pat, const char *rep,
				   int global);
static char   **hist_get(const char *str, int approx, int allow_cur);
d53 1
a53 2
c_fc(wp)
	char **wp;
d270 1
a270 2
hist_execute(cmd)
	char *cmd;
d305 1
a305 5
hist_replace(hp, pat, rep, global)
	char **hp;
	const char *pat;
	const char *rep;
	int global;
d350 1
a350 4
hist_get(str, approx, allow_cur)
	const char *str;
	int approx;
	int allow_cur;
d391 1
a391 2
hist_get_newest(allow_cur)
	int allow_cur;
d404 1
a404 1
hist_get_oldest()
d417 1
a417 1
histbackup()
d433 1
a433 1
histpos()
d439 1
a439 1
histN()
d445 1
a445 2
histnum(n)
	int	n;
d466 1
a466 5
findhist(start, fwd, str, anchored)
	int	start;
	int	fwd;
	const char  *str;
	int	anchored;
d486 1
a486 2
findhistrel(str)
	const char  *str;
d509 1
a509 2
sethistsize(n)
	int n;
d533 1
a533 2
sethistfile(name)
	const char *name;
d565 1
a565 1
init_histvec()
d588 1
a588 4
histsave(lno, cmd, dowrite)
	int lno;
	const char *cmd;
	int dowrite;
d636 1
a636 2
hist_init(s)
	Source *s;
d713 1
a713 3
hist_count_lines(base, bytes)
	unsigned char *base;
	int bytes;
d746 1
a746 3
hist_shrink(oldbase, oldbytes)
	unsigned char *oldbase;
	int oldbytes;
d798 1
a798 4
hist_skip_back(base, bytes, no)
	unsigned char *base;
	int *bytes;
	int no;
d824 1
a824 4
histload(s, base, bytes)
	Source *s;
	unsigned char *base;
	int bytes;
d874 1
a874 4
histinsert(s, lno, line)
	Source *s;
	int lno;
	unsigned char *line;
d894 1
a894 3
writehistfile(lno, cmd)
	int lno;
	char *cmd;
d950 1
a950 1
hist_finish()
d961 1
a961 2
sprinkle(fd)
	int fd;
d972 1
a972 1
init_histvec()
d976 1
a976 2
hist_init(s)
	Source *s;
d980 1
a980 1
hist_finish()
d984 1
a984 4
histsave(lno, cmd, dowrite)
	int lno;
	const char *cmd;
	int dowrite;
@


1.26
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.25 2004/12/12 06:53:13 deraadt Exp $	*/
d612 1
a612 1
	register char **hp;
d737 2
a738 2
	register unsigned char *base;
	register int bytes;
d830 2
a831 2
	register int lines = 0;
	register unsigned char *ep;
d856 2
a857 2
	register unsigned char *base;
	register int bytes;
d912 1
a912 1
	register char **hp;
@


1.25
log
@csh-style ! history completion, which can be activated by using
	set -o csh-history (off by default)
this is not feature complete, and likely never will be.  no ^
and ! has some oddities ... ksh's internal history stuff has got
some very odd behaviours that are rather nasty
ok various developers
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.24 2004/08/03 12:44:59 danh Exp $	*/
d12 1
a12 3
 *	b)	a simple file saving history mechanism done by  sjg@@zen
 *		define EASY_HISTORY to get this
 *	c)	a more complicated mechanism done by  pc@@hillside.co.uk
d19 1
a19 1
#include "ksh_stat.h"
d22 2
a23 15
# ifdef EASY_HISTORY

#  ifndef HISTFILE
#   ifdef OS2
#    define HISTFILE "history.ksh"
#   else /* OS2 */
#    define HISTFILE ".pdksh_history"
#   endif /* OS2 */
#  endif

# else
/*	Defines and includes for the complicated case */

#  include <sys/file.h>
#  include <sys/mman.h>
d31 14
a44 22
static int hist_count_lines ARGS((unsigned char *, int));
static int hist_shrink ARGS((unsigned char *, int));
static unsigned char *hist_skip_back ARGS((unsigned char *,int *,int));
static void histload ARGS((Source *, unsigned char *, int));
static void histinsert ARGS((Source *, int, unsigned char *));
static void writehistfile ARGS((int, char *));
static int sprinkle ARGS((int));

#  ifdef MAP_FILE
#   define MAP_FLAGS	(MAP_FILE|MAP_PRIVATE)
#  else
#   define MAP_FLAGS	MAP_PRIVATE
#  endif

# endif	/* of EASY_HISTORY */

static int	hist_execute ARGS((char *cmd));
static int	hist_replace ARGS((char **hp, const char *pat, const char *rep,
				   int global));
static char   **hist_get ARGS((const char *str, int approx, int allow_cur));
static char   **hist_get_oldest ARGS((void));
static void	histbackup ARGS((void));
d58 1
a58 1
	struct temp UNINITIALIZED(*tf);
d287 1
a287 6
#ifdef EASY_HISTORY
		if (p != cmd)
			histappend(p, TRUE);
		else
#endif /* EASY_HISTORY */
			histsave(++(hist_source->line), p, 1);
a564 6
# ifdef EASY_HISTORY
	if (hname) {
		afree(hname, APERM);
		hname = NULL;
	}
# else
a575 1
# endif
a592 150
# ifdef EASY_HISTORY
/*
 * save command in history
 */
void
histsave(lno, cmd, dowrite)
	int lno;	/* ignored (compatibility with COMPLEX_HISTORY) */
	const char *cmd;
	int dowrite;	/* ignored (compatibility with COMPLEX_HISTORY) */
{
	register char **hp = histptr;
	char *cp;

	if (++hp >= history + histsize) { /* remove oldest command */
		afree((void*)history[0], APERM);
		memmove(history, history + 1,
			sizeof(history[0]) * (histsize - 1));
		hp = &history[histsize - 1];
	}
	*hp = str_save(cmd, APERM);
	/* trash trailing newline but allow imbedded newlines */
	cp = *hp + strlen(*hp);
	if (cp > *hp && cp[-1] == '\n')
		cp[-1] = '\0';
	histptr = hp;
}

/*
 * Append an entry to the last saved command. Used for multiline
 * commands
 */
void
histappend(cmd, nl_separate)
	const char *cmd;
	int	nl_separate;
{
	int	hlen, clen;
	char	*p;

	hlen = strlen(*histptr);
	clen = strlen(cmd);
	if (clen > 0 && cmd[clen-1] == '\n')
		clen--;
	p = *histptr = (char *) aresize(*histptr, hlen + clen + 2, APERM);
	p += hlen;
	if (nl_separate)
		*p++ = '\n';
	memcpy(p, cmd, clen);
	p[clen] = '\0';
}

/*
 * 92-04-25 <sjg@@zen>
 * A simple history file implementation.
 * At present we only save the history when we exit.
 * This can cause problems when there are multiple shells are
 * running under the same user-id.  The last shell to exit gets
 * to save its history.
 */
void
hist_init(s)
	Source *s;
{
	char *f;
	FILE *fh;

	if (Flag(FTALKING) == 0)
		return;

	hstarted = 1;

	hist_source = s;

	if ((f = str_val(global("HISTFILE"))) == NULL || *f == '\0') {
# if 1 /* Don't use history file unless the user asks for it */
		hname = NULL;
		return;
# else
		char *home = str_val(global("HOME"));
		int len;

		if (home == NULL)
			home = null;
		f = HISTFILE;
		hname = alloc(len = strlen(home) + strlen(f) + 2, APERM);
		shf_snprintf(hname, len, "%s/%s", home, f);
# endif
	} else
		hname = str_save(f, APERM);

	if ((fh = fopen(hname, "r"))) {
		int pos = 0, nread = 0;
		int contin = 0;		/* continuation of previous command */
		char *end;
		char hline[LINE + 1];

		while (1) {
			if (pos >= nread) {
				pos = 0;
				nread = fread(hline, 1, LINE, fh);
				if (nread <= 0)
					break;
				hline[nread] = '\0';
			}
			end = strchr(hline + pos, 0); /* will always succeed */
			if (contin)
				histappend(hline + pos, 0);
			else {
				hist_source->line++;
				histsave(0, hline + pos, 0);
			}
			pos = end - hline + 1;
			contin = end == &hline[nread];
		}
		fclose(fh);
	}
}

/*
 * save our history.
 * We check that we do not have more than we are allowed.
 * If the history file is read-only we do nothing.
 * Handy for having all shells start with a useful history set.
 */

void
hist_finish()
{
  static int once;
  FILE *fh;
  register int i;
  register char **hp;

  if (once++)
    return;
  /* check how many we have */
  i = histptr - history;
  if (i >= histsize)
    hp = &histptr[-histsize];
  else
    hp = history;
  if (hname && (fh = fopen(hname, "w")))
  {
    for (i = 0; hp + i <= histptr && hp[i]; i++)
      fprintf(fh, "%s%c", hp[i], '\0');
    fclose(fh);
  }
}

# else /* EASY_HISTORY */
d653 3
a655 3
# define HMAGIC1		0xab
# define HMAGIC2		0xcd
# define COMMAND		0xff
d699 1
a699 1
		base = (unsigned char *)mmap(0, hsize, PROT_READ, MAP_FLAGS, histfd, 0);
d949 1
a949 1
			base = (unsigned char *)mmap(0, sizenow, PROT_READ, MAP_FLAGS, histfd, 0);
a1006 1
# endif
@


1.24
log
@only neuter fc builtin if initial shell is not interactive

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.23 2004/07/16 14:47:31 miod Exp $	*/
a65 1
static char   **hist_get_newest ARGS((int allow_cur));
d428 1
a428 1
static char **
d527 20
@


1.23
log
@Neuter the fc builtin on non-interactive shells; inspired by NetBSD PR#26339.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.22 2003/05/18 01:02:42 jsyn Exp $	*/
d89 1
a89 1
	if (!Flag(FTALKING)) {
@


1.22
log
@fix prototype; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.21 2003/05/17 00:10:52 fgsch Exp $	*/
d88 5
@


1.21
log
@use MAP_FAILED rather than -1; millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.20 2003/05/16 19:58:57 jsyn Exp $	*/
d67 1
a67 1
static char   **hist_get_oldest ARGS(());
@


1.20
log
@fix several constant overflows, remove the strerror prototype (shouldn't be
there), and cleanup some whitespace; help from, and okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.19 2003/04/15 08:35:34 deraadt Exp $	*/
d865 1
a865 1
			if (base != (unsigned char *)-1)
@


1.19
log
@cull warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.18 2003/04/06 23:39:17 deraadt Exp $	*/
d1099 1
a1099 1
	char	hdr[5];
d1163 1
a1163 1
	static char mag[] = { HMAGIC1, HMAGIC2 };
@


1.18
log
@strlcat; ok from various people
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.17 2003/02/28 09:45:09 jmc Exp $	*/
d1021 2
a1022 2
	int	lno;
	unsigned char	*line;
@


1.17
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.16 2002/11/27 20:53:25 pvalchev Exp $	*/
d96 3
a98 2
				editor = str_nsave(p, strlen(p) + 4, ATEMP);
				strcat(editor, " $_");
@


1.16
log
@Make fc -e work in "sh-mode" (shell invoked as /bin/sh or -o sh option)
as well; matches Solaris.  "can't hurt anything" marc@@
Original report from PR user/2883
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.15 2002/10/23 14:23:15 millert Exp $	*/
d70 1
a70 1
static char   **current;	/* current postition in history[] */
d496 1
a496 1
 * This will become unecessary if hist_get is modified to allow
@


1.15
log
@Move a cast from LHS to RHS to quiet a "cast from pointer to integer
of different size" warning on 64-bit platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.14 2002/09/06 19:45:14 deraadt Exp $	*/
d242 2
a243 4
	if (!Flag(FSH)) {
		/* Ignore setstr errors here (arbitrary) */
		setstr(local("_", FALSE), tf->name, KSH_RETURN_ERROR);
	}
@


1.14
log
@no , at end of enum
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.13 2002/08/03 17:00:09 marc Exp $	*/
d866 1
a866 1
			if ((int)base !=  -1)
@


1.13
log
@register -> int
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.12 2000/10/12 10:51:13 art Exp $	*/
d894 1
a894 1
	sn2, sn3, sn4,
@


1.12
log
@Compare the return from mmap with MAP_FAILED, do not cast to int and comapre
with -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.11 1999/06/15 01:18:34 millert Exp $	*/
d903 1
a903 1
	register lines = 0;
@


1.11
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.10 1999/01/10 17:55:02 millert Exp $	*/
d865 1
a865 1
		if ((int)base == -1 || *base != HMAGIC1 || base[1] != HMAGIC2) {
d1112 1
a1112 1
			if ((int)base == -1)
@


1.10
log
@sync with pdksh-unstable-5.2.13.6
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.9 1998/10/29 04:09:20 millert Exp $	*/
d228 1
a228 2
	tf = maketemp(ATEMP);
	tf->next = e->temps; e->temps = tf;
d243 2
a244 2
		/* SETSTR: ignore fail (arbitrary) */
		setstr(local("_", FALSE), tf->name);
@


1.9
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.8 1998/06/25 19:01:58 millert Exp $	*/
d243 2
a244 1
	if (!Flag(FSH))
d246 1
@


1.8
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.7 1997/06/19 13:58:42 kstailey Exp $	*/
d636 1
a636 1
histappend(cmd, nl_seperate)
d638 1
a638 1
	int	nl_seperate;
d649 1
a649 1
	if (nl_seperate)
@


1.7
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.5 1997/01/02 18:16:52 downsj Exp $	*/
d30 1
a30 1
#    define HISTFILE ".pdksh_hist"
d489 1
a489 1
	}  else {
@


1.6
log
@(foo *)0 -> NULL
@
text
@d83 1
a83 1
	char *p, *editor = NULL;
d86 1
a86 1
	char *first = NULL, *last = NULL;
d136 1
a136 1
		char *pat = NULL, *rep = NULL;
d304 1
a304 1
				q = NULL;
d386 1
a386 1
	char **hp = NULL;
d396 1
a396 1
				hp = NULL;
d403 1
a403 1
				hp = NULL;
d407 1
a407 1
			hp = NULL;
d416 1
a416 1
			hp = NULL;
d430 1
a430 1
		return (NULL);
d443 1
a443 1
		return (NULL);
d597 1
a597 1
	if (history == NULL) {
@


1.5
log
@Revert HISTFILE.  If anyone wants a differently named history file, they
can set it in their environment.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.4 1997/01/02 17:37:26 downsj Exp $	*/
d83 1
a83 1
	char *p, *editor = (char *) 0;
d86 1
a86 1
	char *first = (char *) 0, *last = (char *) 0;
d136 1
a136 1
		char *pat = (char *) 0, *rep = (char *) 0;
d304 1
a304 1
				q = (char *) 0;
d386 1
a386 1
	char **hp = (char **) 0;
d396 1
a396 1
				hp = (char **) 0;
d403 1
a403 1
				hp = (char **) 0;
d407 1
a407 1
			hp = (char **) 0;
d416 1
a416 1
			hp = (char **) 0;
d430 1
a430 1
		return (char **) 0;
d443 1
a443 1
		return (char **) 0;
d597 1
a597 1
	if (history == (char **)NULL) {
@


1.4
log
@After discussing $_ with the maintainer, revert ksh behaviour and completely
eliminate it from sh.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.3 1997/01/02 09:34:00 downsj Exp $	*/
d29 1
a29 3
#   elif __OpenBSD__ /* OS2 */
#    define HISTFILE ".ksh_history"
#   else /* __OpenBSD__ */
d31 1
a31 1
#   endif /* OS2 and __OpenBSD__ */
@


1.3
log
@Add FSH (set -o sh), initialize it if we're /bin/sh, and add the first use:
don't set $_ if we're non-interactive.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.2 1996/12/29 12:24:05 graichen Exp $	*/
d245 1
a245 1
	if (!Flag(FSH) || Flag(FTALKING))
@


1.2
log
@change the name of the history file from .pdksh_hist to .ksh_history
this way it is clearer where it comes from (pdksh is ksh in OpenBSD)
and it's more consistent with other shells (bash - .bash_history and i
think FreeBSD's sh also used something like .sh_history)
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
d245 2
a246 1
	setstr(local("_", FALSE), tf->name);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d29 3
a31 1
#   else /* OS2 */
d33 1
a33 1
#   endif /* OS2 */
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
