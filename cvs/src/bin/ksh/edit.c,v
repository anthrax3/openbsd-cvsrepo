head	1.57;
access;
symbols
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.53.0.2
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.6
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.37.0.2
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.34.0.10
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.8
	OPENBSD_5_0:1.34.0.6
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.4
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.33.0.10
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.12
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.8
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.6
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.4
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.31.0.6
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.18.0.6
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.13.0.4
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.11.0.4
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.57
date	2016.09.08.12.12.40;	author nicm;	state Exp;
branches;
next	1.56;
commitid	BlPDv4GzAwgxicoy;

1.56
date	2016.09.07.04.42.31;	author dcoppa;	state Exp;
branches;
next	1.55;
commitid	s1Kg1wWFr0SzW4SK;

1.55
date	2016.09.04.17.21.44;	author nicm;	state Exp;
branches;
next	1.54;
commitid	2t0Nlw1SbDcmw7AK;

1.54
date	2016.08.16.15.32.07;	author tb;	state Exp;
branches;
next	1.53;
commitid	jeY6hDSGy3ZCvu8x;

1.53
date	2016.03.17.23.33.23;	author mmcc;	state Exp;
branches;
next	1.52;
commitid	Vulj8lha6PuDYESy;

1.52
date	2015.12.30.09.07.00;	author tedu;	state Exp;
branches;
next	1.51;
commitid	WTwPzlskFufQpRQz;

1.51
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.50;
commitid	btTCreDA00YdaFhU;

1.50
date	2015.11.01.15.38.53;	author mmcc;	state Exp;
branches;
next	1.49;
commitid	Fr9nr0FBz2YkAWdK;

1.49
date	2015.10.21.14.31.28;	author mmcc;	state Exp;
branches;
next	1.48;
commitid	C89fbVjDyymm0pBB;

1.48
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.47;
commitid	C4W85jmosThChWA2;

1.47
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.46;
commitid	16HUr75moyUNtKR8;

1.46
date	2015.10.09.19.36.27;	author tedu;	state Exp;
branches;
next	1.45;
commitid	BqXaWldwtvsixcay;

1.45
date	2015.09.26.23.49.37;	author nicm;	state Exp;
branches;
next	1.44;
commitid	HAZfQz431RuGJ9EZ;

1.44
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.43;
commitid	7fgq4YTZG4xZ0uN0;

1.43
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.42;
commitid	v5QjoxUgKU2iUTFz;

1.42
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.41;
commitid	lBs9un9sXhbdfVrQ;

1.41
date	2015.09.01.13.12.31;	author tedu;	state Exp;
branches;
next	1.40;
commitid	sKGEDet4KOfGjsIb;

1.40
date	2015.03.12.10.20.30;	author sthen;	state Exp;
branches;
next	1.39;
commitid	vgkGEGl7zqZ6UOzR;

1.39
date	2013.12.17.16.37.05;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2013.06.03.15.41.59;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2013.01.21.10.13.24;	author halex;	state Exp;
branches;
next	1.36;

1.36
date	2013.01.20.14.47.46;	author stsp;	state Exp;
branches;
next	1.35;

1.35
date	2012.09.10.01.25.30;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.20.01.13.07;	author fgsch;	state Exp;
branches;
next	1.33;

1.33
date	2007.08.02.10.50.25;	author fgsch;	state Exp;
branches;
next	1.32;

1.32
date	2007.08.01.10.08.56;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.11.20.31.21;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.11.18.08.47;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.13.02.33.08;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.25.11.21.16;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.19.04.14.20;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.18.22.12.23;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.18.22.11.43;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.18.20.58.03;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.04.19.20.07;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.22.18.17.10;	author fgsch;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.26.00.09.45;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.05.22.02.33;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.17.18.08;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.19.19.32.13;	author camield;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.19.09.49.51;	author camield;	state Exp;
branches;
next	1.11;

1.11
date	99.11.14.22.04.02;	author d;	state Exp;
branches;
next	1.10;

1.10
date	99.06.15.01.18.33;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.01.10.17.55.02;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.01.08.20.24.58;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.06.25.19.01.50;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.06.19.13.58.39;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.06.18.22.42.31;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.12.14.12.18.07;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.10.01.02.05.33;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.47;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.10;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.10;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Don't try to look up array names for complete_* that aren't
alphanumeric, spotted by and ok sthen
@
text
@/*	$OpenBSD: edit.c,v 1.56 2016/09/07 04:42:31 dcoppa Exp $	*/

/*
 * Command line editing - common code
 *
 */

#include "config.h"
#ifdef EDIT

#include <sys/ioctl.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <libgen.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "sh.h"
#include "edit.h"
#include "tty.h"

X_chars edchars;

static void x_sigwinch(int);
volatile sig_atomic_t got_sigwinch;
static void check_sigwinch(void);

static int	x_file_glob(int, const char *, int, char ***);
static int	x_command_glob(int, const char *, int, char ***);
static int	x_locate_word(const char *, int, int, int *, int *);


/* Called from main */
void
x_init(void)
{
	/* set to -2 to force initial binding */
	edchars.erase = edchars.kill = edchars.intr = edchars.quit =
	    edchars.eof = -2;
	/* default value for deficient systems */
	edchars.werase = 027;	/* ^W */

	if (setsig(&sigtraps[SIGWINCH], x_sigwinch, SS_RESTORE_ORIG|SS_SHTRAP))
		sigtraps[SIGWINCH].flags |= TF_SHELL_USES;
	got_sigwinch = 1; /* force initial check */
	check_sigwinch();

#ifdef EMACS
	x_init_emacs();
#endif /* EMACS */
}

static void
x_sigwinch(int sig)
{
	got_sigwinch = 1;
}

static void
check_sigwinch(void)
{
	if (got_sigwinch) {
		struct winsize ws;

		got_sigwinch = 0;
		if (procpid == kshpid && ioctl(tty_fd, TIOCGWINSZ, &ws) >= 0) {
			struct tbl *vp;

			/* Do NOT export COLUMNS/LINES.  Many applications
			 * check COLUMNS/LINES before checking ws.ws_col/row,
			 * so if the app is started with C/L in the environ
			 * and the window is then resized, the app won't
			 * see the change cause the environ doesn't change.
			 */
			if (ws.ws_col) {
				x_cols = ws.ws_col < MIN_COLS ? MIN_COLS :
				    ws.ws_col;

				if ((vp = typeset("COLUMNS", 0, 0, 0, 0)))
					setint(vp, (long) ws.ws_col);
			}
			if (ws.ws_row && (vp = typeset("LINES", 0, 0, 0, 0)))
				setint(vp, (long) ws.ws_row);
		}
	}
}

/*
 * read an edited command line
 */
int
x_read(char *buf, size_t len)
{
	int	i;

	x_mode(true);
#ifdef EMACS
	if (Flag(FEMACS) || Flag(FGMACS))
		i = x_emacs(buf, len);
	else
#endif
#ifdef VI
	if (Flag(FVI))
		i = x_vi(buf, len);
	else
#endif
		i = -1;		/* internal error */
	x_mode(false);
	check_sigwinch();
	return i;
}

/* tty I/O */

int
x_getc(void)
{
	char c;
	int n;

	while ((n = blocking_read(STDIN_FILENO, &c, 1)) < 0 && errno == EINTR)
		if (trap) {
			x_mode(false);
			runtraps(0);
			x_mode(true);
		}
	if (n != 1)
		return -1;
	return (int) (unsigned char) c;
}

void
x_flush(void)
{
	shf_flush(shl_out);
}

void
x_putc(int c)
{
	shf_putc(c, shl_out);
}

void
x_puts(const char *s)
{
	while (*s != 0)
		shf_putc(*s++, shl_out);
}

bool
x_mode(bool onoff)
{
	static bool	x_cur_mode;
	bool		prev;

	if (x_cur_mode == onoff)
		return x_cur_mode;
	prev = x_cur_mode;
	x_cur_mode = onoff;

	if (onoff) {
		struct termios	cb;
		X_chars		oldchars;

		oldchars = edchars;
		cb = tty_state;

		edchars.erase = cb.c_cc[VERASE];
		edchars.kill = cb.c_cc[VKILL];
		edchars.intr = cb.c_cc[VINTR];
		edchars.quit = cb.c_cc[VQUIT];
		edchars.eof = cb.c_cc[VEOF];
		edchars.werase = cb.c_cc[VWERASE];
		cb.c_iflag &= ~(INLCR|ICRNL);
		cb.c_lflag &= ~(ISIG|ICANON|ECHO);
		/* osf/1 processes lnext when ~icanon */
		cb.c_cc[VLNEXT] = _POSIX_VDISABLE;
		/* sunos 4.1.x & osf/1 processes discard(flush) when ~icanon */
		cb.c_cc[VDISCARD] = _POSIX_VDISABLE;
		cb.c_cc[VTIME] = 0;
		cb.c_cc[VMIN] = 1;

		tcsetattr(tty_fd, TCSADRAIN, &cb);

		/* Convert unset values to internal `unset' value */
		if (edchars.erase == _POSIX_VDISABLE)
			edchars.erase = -1;
		if (edchars.kill == _POSIX_VDISABLE)
			edchars.kill = -1;
		if (edchars.intr == _POSIX_VDISABLE)
			edchars.intr = -1;
		if (edchars.quit == _POSIX_VDISABLE)
			edchars.quit = -1;
		if (edchars.eof == _POSIX_VDISABLE)
			edchars.eof = -1;
		if (edchars.werase == _POSIX_VDISABLE)
			edchars.werase = -1;
		if (memcmp(&edchars, &oldchars, sizeof(edchars)) != 0) {
#ifdef EMACS
			x_emacs_keys(&edchars);
#endif
		}
	} else {
		tcsetattr(tty_fd, TCSADRAIN, &tty_state);
	}

	return prev;
}

void
set_editmode(const char *ed)
{
	static const enum sh_flag edit_flags[] = {
#ifdef EMACS
		FEMACS, FGMACS,
#endif
#ifdef VI
		FVI,
#endif
	};
	char *rcp;
	int i;

	if ((rcp = strrchr(ed, '/')))
		ed = ++rcp;
	for (i = 0; i < NELEM(edit_flags); i++)
		if (strstr(ed, options[(int) edit_flags[i]].name)) {
			change_flag(edit_flags[i], OF_SPECIAL, 1);
			return;
		}
}

/* ------------------------------------------------------------------------- */
/*           Misc common code for vi/emacs				     */

/* Handle the commenting/uncommenting of a line.
 * Returns:
 *	1 if a carriage return is indicated (comment added)
 *	0 if no return (comment removed)
 *	-1 if there is an error (not enough room for comment chars)
 * If successful, *lenp contains the new length.  Note: cursor should be
 * moved to the start of the line after (un)commenting.
 */
int
x_do_comment(char *buf, int bsize, int *lenp)
{
	int i, j;
	int len = *lenp;

	if (len == 0)
		return 1; /* somewhat arbitrary - it's what at&t ksh does */

	/* Already commented? */
	if (buf[0] == '#') {
		int saw_nl = 0;

		for (j = 0, i = 1; i < len; i++) {
			if (!saw_nl || buf[i] != '#')
				buf[j++] = buf[i];
			saw_nl = buf[i] == '\n';
		}
		*lenp = j;
		return 0;
	} else {
		int n = 1;

		/* See if there's room for the #'s - 1 per \n */
		for (i = 0; i < len; i++)
			if (buf[i] == '\n')
				n++;
		if (len + n >= bsize)
			return -1;
		/* Now add them... */
		for (i = len, j = len + n; --i >= 0; ) {
			if (buf[i] == '\n')
				buf[--j] = '#';
			buf[--j] = buf[i];
		}
		buf[0] = '#';
		*lenp += n;
		return 1;
	}
}

/* ------------------------------------------------------------------------- */
/*           Common file/command completion code for vi/emacs	             */


static char	*add_glob(const char *str, int slen);
static void	glob_table(const char *pat, XPtrV *wp, struct table *tp);
static void	glob_path(int flags, const char *pat, XPtrV *wp,
				const char *path);

void
x_print_expansions(int nwords, char *const *words, int is_command)
{
	int prefix_len;

	/* Check if all matches are in the same directory (in this
	 * case, we want to omit the directory name)
	 */
	if (!is_command &&
	    (prefix_len = x_longest_prefix(nwords, words)) > 0) {
		int i;

		/* Special case for 1 match (prefix is whole word) */
		if (nwords == 1)
			prefix_len = x_basename(words[0], NULL);
		/* Any (non-trailing) slashes in non-common word suffixes? */
		for (i = 0; i < nwords; i++)
			if (x_basename(words[i] + prefix_len, NULL) >
			    prefix_len)
				break;
		/* All in same directory? */
		if (i == nwords) {
			XPtrV l;

			while (prefix_len > 0 && words[0][prefix_len - 1] != '/')
				prefix_len--;
			XPinit(l, nwords + 1);
			for (i = 0; i < nwords; i++)
				XPput(l, words[i] + prefix_len);
			XPput(l, NULL);

			/* Enumerate expansions */
			x_putc('\r');
			x_putc('\n');
			pr_list((char **) XPptrv(l));

			XPfree(l); /* not x_free_words() */
			return;
		}
	}

	/* Enumerate expansions */
	x_putc('\r');
	x_putc('\n');
	pr_list(words);
}

/*
 *  Do file globbing:
 *	- appends * to (copy of) str if no globbing chars found
 *	- does expansion, checks for no match, etc.
 *	- sets *wordsp to array of matching strings
 *	- returns number of matching strings
 */
static int
x_file_glob(int flags, const char *str, int slen, char ***wordsp)
{
	char *toglob;
	char **words;
	int nwords;
	XPtrV w;
	struct source *s, *sold;

	if (slen < 0)
		return 0;

	toglob = add_glob(str, slen);

	/*
	 * Convert "foo*" (toglob) to an array of strings (words)
	 */
	sold = source;
	s = pushs(SWSTR, ATEMP);
	s->start = s->str = toglob;
	source = s;
	if (yylex(ONEWORD|UNESCAPE) != LWORD) {
		source = sold;
		internal_errorf(0, "fileglob: substitute error");
		return 0;
	}
	source = sold;
	XPinit(w, 32);
	expand(yylval.cp, &w, DOGLOB|DOTILDE|DOMARKDIRS);
	XPput(w, NULL);
	words = (char **) XPclose(w);

	for (nwords = 0; words[nwords]; nwords++)
		;
	if (nwords == 1) {
		struct stat statb;

		/* Check if file exists, also, check for empty
		 * result - happens if we tried to glob something
		 * which evaluated to an empty string (e.g.,
		 * "$FOO" when there is no FOO, etc).
		 */
		 if ((lstat(words[0], &statb) < 0) ||
		    words[0][0] == '\0') {
			x_free_words(nwords, words);
			words = NULL;
			nwords = 0;
		}
	}
	afree(toglob, ATEMP);

	if (nwords) {
		*wordsp = words;
	} else if (words) {
		x_free_words(nwords, words);
		*wordsp = NULL;
	}

	return nwords;
}

/* Data structure used in x_command_glob() */
struct path_order_info {
	char *word;
	int base;
	int path_order;
};

static int path_order_cmp(const void *aa, const void *bb);

/* Compare routine used in x_command_glob() */
static int
path_order_cmp(const void *aa, const void *bb)
{
	const struct path_order_info *a = (const struct path_order_info *) aa;
	const struct path_order_info *b = (const struct path_order_info *) bb;
	int t;

	t = strcmp(a->word + a->base, b->word + b->base);
	return t ? t : a->path_order - b->path_order;
}

static int
x_command_glob(int flags, const char *str, int slen, char ***wordsp)
{
	char *toglob;
	char *pat;
	char *fpath;
	int nwords;
	XPtrV w;
	struct block *l;

	if (slen < 0)
		return 0;

	toglob = add_glob(str, slen);

	/* Convert "foo*" (toglob) to a pattern for future use */
	pat = evalstr(toglob, DOPAT|DOTILDE);
	afree(toglob, ATEMP);

	XPinit(w, 32);

	glob_table(pat, &w, &keywords);
	glob_table(pat, &w, &aliases);
	glob_table(pat, &w, &builtins);
	for (l = genv->loc; l; l = l->next)
		glob_table(pat, &w, &l->funs);

	glob_path(flags, pat, &w, path);
	if ((fpath = str_val(global("FPATH"))) != null)
		glob_path(flags, pat, &w, fpath);

	nwords = XPsize(w);

	if (!nwords) {
		*wordsp = NULL;
		XPfree(w);
		return 0;
	}

	/* Sort entries */
	if (flags & XCF_FULLPATH) {
		/* Sort by basename, then path order */
		struct path_order_info *info;
		struct path_order_info *last_info = NULL;
		char **words = (char **) XPptrv(w);
		int path_order = 0;
		int i;

		info = areallocarray(NULL, nwords,
		    sizeof(struct path_order_info), ATEMP);

		for (i = 0; i < nwords; i++) {
			info[i].word = words[i];
			info[i].base = x_basename(words[i], NULL);
			if (!last_info || info[i].base != last_info->base ||
			    strncmp(words[i], last_info->word, info[i].base) != 0) {
				last_info = &info[i];
				path_order++;
			}
			info[i].path_order = path_order;
		}
		qsort(info, nwords, sizeof(struct path_order_info),
			path_order_cmp);
		for (i = 0; i < nwords; i++)
			words[i] = info[i].word;
		afree(info, ATEMP);
	} else {
		/* Sort and remove duplicate entries */
		char **words = (char **) XPptrv(w);
		int i, j;

		qsortp(XPptrv(w), (size_t) nwords, xstrcmp);

		for (i = j = 0; i < nwords - 1; i++) {
			if (strcmp(words[i], words[i + 1]))
				words[j++] = words[i];
			else
				afree(words[i], ATEMP);
		}
		words[j++] = words[i];
		nwords = j;
		w.cur = (void **) &words[j];
	}

	XPput(w, NULL);
	*wordsp = (char **) XPclose(w);

	return nwords;
}

#define IS_WORDC(c)	!( ctype(c, C_LEX1) || (c) == '\'' || (c) == '"' || \
			    (c) == '`' || (c) == '=' || (c) == ':' )

static int
x_locate_word(const char *buf, int buflen, int pos, int *startp,
    int *is_commandp)
{
	int p;
	int start, end;

	/* Bad call?  Probably should report error */
	if (pos < 0 || pos > buflen) {
		*startp = pos;
		*is_commandp = 0;
		return 0;
	}
	/* The case where pos == buflen happens to take care of itself... */

	start = pos;
	/* Keep going backwards to start of word (has effect of allowing
	 * one blank after the end of a word)
	 */
	for (; (start > 0 && IS_WORDC(buf[start - 1])) ||
	    (start > 1 && buf[start-2] == '\\'); start--)
		;
	/* Go forwards to end of word */
	for (end = start; end < buflen && IS_WORDC(buf[end]); end++) {
		if (buf[end] == '\\' && (end+1) < buflen)
			end++;
	}

	if (is_commandp) {
		int iscmd;

		/* Figure out if this is a command */
		for (p = start - 1; p >= 0 && isspace((unsigned char)buf[p]);
		    p--)
			;
		iscmd = p < 0 || strchr(";|&()`", buf[p]);
		if (iscmd) {
			/* If command has a /, path, etc. is not searched;
			 * only current directory is searched, which is just
			 * like file globbing.
			 */
			for (p = start; p < end; p++)
				if (buf[p] == '/')
					break;
			iscmd = p == end;
		}
		*is_commandp = iscmd;
	}

	*startp = start;

	return end - start;
}

static int
x_try_array(const char *buf, int buflen, const char *want, int wantlen,
    int *nwords, char ***words)
{
	const char *cmd, *cp;
	int cmdlen, n, i, slen;
	char *name, *s;
	struct tbl *v, *vp;

	*nwords = 0;
	*words = NULL;

	/* Walk back to find start of command. */
	if (want == buf)
		return 0;
	for (cmd = want; cmd > buf; cmd--) {
		if (strchr(";|&()`", cmd[-1]) != NULL)
			break;
	}
	while (cmd < want && isspace((u_char)*cmd))
		cmd++;
	cmdlen = 0;
	while (cmd + cmdlen < want && !isspace((u_char)cmd[cmdlen]))
		cmdlen++;
	for (i = 0; i < cmdlen; i++) {
		if (!isalnum((u_char)cmd[i]) && cmd[i] != '_')
			return 0;
	}

	/* Take a stab at argument count from here. */
	n = 1;
	for (cp = cmd + cmdlen + 1; cp < want; cp++) {
		if (!isspace((u_char)cp[-1]) && isspace((u_char)*cp))
			n++;
	}

	/* Try to find the array. */
	if (asprintf(&name, "complete_%.*s_%d", cmdlen, cmd, n) < 0)
		internal_errorf(1, "unable to allocate memory");
	v = global(name);
	free(name);
	if (~v->flag & (ISSET|ARRAY)) {
		if (asprintf(&name, "complete_%.*s", cmdlen, cmd) < 0)
			internal_errorf(1, "unable to allocate memory");
		v = global(name);
		free(name);
		if (~v->flag & (ISSET|ARRAY))
			return 0;
	}

	/* Walk the array and build words list. */
	for (vp = v; vp; vp = vp->u.array) {
		if (~vp->flag & ISSET)
			continue;

		s = str_val(vp);
		slen = strlen(s);

		if (slen < wantlen)
			continue;
		if (slen > wantlen)
			slen = wantlen;
		if (slen != 0 && strncmp(s, want, slen) != 0)
			continue;

		*words = areallocarray(*words, (*nwords) + 2, sizeof **words,
		    ATEMP);
		(*words)[(*nwords)++] = str_save(s, ATEMP);
	}
	if (*nwords != 0)
		(*words)[*nwords] = NULL;

	return *nwords != 0;
}

int
x_cf_glob(int flags, const char *buf, int buflen, int pos, int *startp,
    int *endp, char ***wordsp, int *is_commandp)
{
	int len;
	int nwords;
	char **words = NULL;
	int is_command;

	len = x_locate_word(buf, buflen, pos, startp, &is_command);
	if (!(flags & XCF_COMMAND))
		is_command = 0;
	/* Don't do command globing on zero length strings - it takes too
	 * long and isn't very useful.  File globs are more likely to be
	 * useful, so allow these.
	 */
	if (len == 0 && is_command)
		return 0;

	if (is_command)
		nwords = x_command_glob(flags, buf + *startp, len, &words);
	else if (!x_try_array(buf, buflen, buf + *startp, len, &nwords, &words))
		nwords = x_file_glob(flags, buf + *startp, len, &words);
	if (nwords == 0) {
		*wordsp = NULL;
		return 0;
	}

	if (is_commandp)
		*is_commandp = is_command;
	*wordsp = words;
	*endp = *startp + len;

	return nwords;
}

/* Given a string, copy it and possibly add a '*' to the end.  The
 * new string is returned.
 */
static char *
add_glob(const char *str, int slen)
{
	char *toglob;
	char *s;
	bool saw_slash = false;

	if (slen < 0)
		return NULL;

	toglob = str_nsave(str, slen + 1, ATEMP); /* + 1 for "*" */
	toglob[slen] = '\0';

	/*
	 * If the pathname contains a wildcard (an unquoted '*',
	 * '?', or '[') or parameter expansion ('$'), or a ~username
	 * with no trailing slash, then it is globbed based on that
	 * value (i.e., without the appended '*').
	 */
	for (s = toglob; *s; s++) {
		if (*s == '\\' && s[1])
			s++;
		else if (*s == '*' || *s == '[' || *s == '?' || *s == '$' ||
		    (s[1] == '(' /*)*/ && strchr("+@@!", *s)))
			break;
		else if (*s == '/')
			saw_slash = true;
	}
	if (!*s && (*toglob != '~' || saw_slash)) {
		toglob[slen] = '*';
		toglob[slen + 1] = '\0';
	}

	return toglob;
}

/*
 * Find longest common prefix
 */
int
x_longest_prefix(int nwords, char *const *words)
{
	int i, j;
	int prefix_len;
	char *p;

	if (nwords <= 0)
		return 0;

	prefix_len = strlen(words[0]);
	for (i = 1; i < nwords; i++)
		for (j = 0, p = words[i]; j < prefix_len; j++)
			if (p[j] != words[0][j]) {
				prefix_len = j;
				break;
			}
	return prefix_len;
}

void
x_free_words(int nwords, char **words)
{
	int i;

	for (i = 0; i < nwords; i++)
		afree(words[i], ATEMP);
	afree(words, ATEMP);
}

/* Return the offset of the basename of string s (which ends at se - need not
 * be null terminated).  Trailing slashes are ignored.  If s is just a slash,
 * then the offset is 0 (actually, length - 1).
 *	s		Return
 *	/etc		1
 *	/etc/		1
 *	/etc//		1
 *	/etc/fo		5
 *	foo		0
 *	///		2
 *			0
 */
int
x_basename(const char *s, const char *se)
{
	const char *p;

	if (se == NULL)
		se = s + strlen(s);
	if (s == se)
		return 0;

	/* Skip trailing slashes */
	for (p = se - 1; p > s && *p == '/'; p--)
		;
	for (; p > s && *p != '/'; p--)
		;
	if (*p == '/' && p + 1 < se)
		p++;

	return p - s;
}

/*
 *  Apply pattern matching to a table: all table entries that match a pattern
 * are added to wp.
 */
static void
glob_table(const char *pat, XPtrV *wp, struct table *tp)
{
	struct tstate ts;
	struct tbl *te;

	for (ktwalk(&ts, tp); (te = ktnext(&ts)); ) {
		if (gmatch(te->name, pat, false))
			XPput(*wp, str_save(te->name, ATEMP));
	}
}

static void
glob_path(int flags, const char *pat, XPtrV *wp, const char *path)
{
	const char *sp, *p;
	char *xp;
	int staterr;
	int pathlen;
	int patlen;
	int oldsize, newsize, i, j;
	char **words;
	XString xs;

	patlen = strlen(pat) + 1;
	sp = path;
	Xinit(xs, xp, patlen + 128, ATEMP);
	while (sp) {
		xp = Xstring(xs, xp);
		if (!(p = strchr(sp, ':')))
			p = sp + strlen(sp);
		pathlen = p - sp;
		if (pathlen) {
			/* Copy sp into xp, stuffing any MAGIC characters
			 * on the way
			 */
			const char *s = sp;

			XcheckN(xs, xp, pathlen * 2);
			while (s < p) {
				if (ISMAGIC(*s))
					*xp++ = MAGIC;
				*xp++ = *s++;
			}
			*xp++ = '/';
			pathlen++;
		}
		sp = p;
		XcheckN(xs, xp, patlen);
		memcpy(xp, pat, patlen);

		oldsize = XPsize(*wp);
		glob_str(Xstring(xs, xp), wp, 1); /* mark dirs */
		newsize = XPsize(*wp);

		/* Check that each match is executable... */
		words = (char **) XPptrv(*wp);
		for (i = j = oldsize; i < newsize; i++) {
			staterr = 0;
			if ((search_access(words[i], X_OK, &staterr) >= 0) ||
			    (staterr == EISDIR)) {
				words[j] = words[i];
				if (!(flags & XCF_FULLPATH))
					memmove(words[j], words[j] + pathlen,
					    strlen(words[j] + pathlen) + 1);
				j++;
			} else
				afree(words[i], ATEMP);
		}
		wp->cur = (void **) &words[j];

		if (!*sp++)
			break;
	}
	Xfree(xs, xp);
}

/*
 * if argument string contains any special characters, they will
 * be escaped and the result will be put into edit buffer by
 * keybinding-specific function
 */
int
x_escape(const char *s, size_t len, int (*putbuf_func) (const char *, size_t))
{
	size_t add, wlen;
	const char *ifs = str_val(local("IFS", 0));
	int rval = 0;

	for (add = 0, wlen = len; wlen - add > 0; add++) {
		if (strchr("!\"#$&'()*:;<=>?[\\]`{|}", s[add]) ||
		    strchr(ifs, s[add])) {
			if (putbuf_func(s, add) != 0) {
				rval = -1;
				break;
			}

			putbuf_func("\\", 1);
			putbuf_func(&s[add], 1);

			add++;
			wlen -= add;
			s += add;
			add = -1; /* after the increment it will go to 0 */
		}
	}
	if (wlen > 0 && rval == 0)
		rval = putbuf_func(s, wlen);

	return (rval);
}
#endif /* EDIT */
@


1.56
log
@
remove unused variable 'last'

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.55 2016/09/04 17:21:44 nicm Exp $	*/
d587 1
a587 1
	int cmdlen, n;
a588 1
	size_t slen;
d606 4
@


1.55
log
@Allow simple custom completions by creating an array named
"complete_commandname_argnum", for example:

    set -A complete_kill_1 -- -9 -HUP -INFO -KILL -TERM

To set completions for the first argument to kill(1). If no complete_*
arrays are present, the normal filename completion is offered.

positive comments from many; man page ok/tweaks jmc; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.54 2016/08/16 15:32:07 tb Exp $	*/
d586 1
a586 1
	const char *cmd, *cp, *last;
@


1.54
log
@Avoid a compiler warning about use of uninitialized l.beg emitted
when ksh is compiled with -Os (done in distrib/special): move the
bit using XPptrv(l) (which expands to l.beg) where it is actually
used and clearly initialized.

ok tedu, tweak + ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.53 2016/03/17 23:33:23 mmcc Exp $	*/
d18 1
d582 72
d660 1
a660 1
	char **words;
d673 4
a676 2
	nwords = (is_command ? x_command_glob : x_file_glob)(flags,
	    buf + *startp, len, &words);
@


1.53
log
@remove some ARGSUSED
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.52 2015/12/30 09:07:00 tedu Exp $	*/
a300 1
	int use_copy = 0;
a301 1
	XPtrV l;
d320 2
a323 1
			use_copy = 1;
d328 8
d339 1
a339 3
	/*
	 * Enumerate expansions
	 */
d342 1
a342 4
	pr_list(use_copy ? (char **) XPptrv(l) : words);

	if (use_copy)
		XPfree(l); /* not x_free_words() */
@


1.52
log
@rename global "e" to genv to avoid accidental shadowing and aliasing.
ok millert nicm tb
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.51 2015/12/14 13:59:42 tb Exp $	*/
a55 1
/* ARGSUSED */
@


1.51
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.50 2015/11/01 15:38:53 mmcc Exp $	*/
d457 1
a457 1
	for (l = e->loc; l; l = l->next)
@


1.50
log
@Add uses of areallocarray(). mksh and Bitrig ksh already have similar
functions. With help from Theo Buehler.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.49 2015/10/21 14:31:28 mmcc Exp $	*/
d15 1
d17 1
d19 1
@


1.49
log
@Assign pointer to NULL rather than 0.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.48 2015/10/19 14:42:16 mmcc Exp $	*/
d478 2
a479 1
		info = alloc(sizeof(struct path_order_info) * nwords, ATEMP);
@


1.48
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.47 2015/10/19 02:15:45 mmcc Exp $	*/
d473 1
a473 1
		struct path_order_info *last_info = 0;
@


1.47
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.46 2015/10/09 19:36:27 tedu Exp $	*/
d16 1
@


1.46
log
@remove null check before afree. from Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.45 2015/09/26 23:49:37 nicm Exp $	*/
a10 3
#include "sh.h"
#include "tty.h"
#include "edit.h"
d12 2
d16 4
a19 1
#include <sys/stat.h>
@


1.45
log
@Remove EXTERN from edit.[ch], from Michael McConville.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.44 2015/09/18 07:28:24 nicm Exp $	*/
d675 1
a675 2
		if (words[i])
			afree(words[i], ATEMP);
@


1.44
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.43 2015/09/17 14:21:33 nicm Exp $	*/
a12 1
#define EXTERN
a13 1
#undef EXTERN
d19 1
@


1.43
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.42 2015/09/15 18:15:05 tedu Exp $	*/
d462 1
a462 1
		*wordsp = (char **) 0;
d596 1
a596 1
		*wordsp = (char **) 0;
@


1.42
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.41 2015/09/01 13:12:31 tedu Exp $	*/
d476 2
a477 2
		info = (struct path_order_info *)
			alloc(sizeof(struct path_order_info) * nwords, ATEMP);
@


1.41
log
@remove casts and null checks before free. from Michael McConville
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.40 2015/03/12 10:20:30 sthen Exp $	*/
d310 1
a310 1
			prefix_len = x_basename(words[0], (char *) 0);
d313 1
a313 1
			if (x_basename(words[i] + prefix_len, (char *) 0) >
d324 1
a324 1
			XPput(l, (char *) 0);
d480 1
a480 1
			info[i].base = x_basename(words[i], (char *) 0);
d619 1
a619 1
		return (char *) 0;
d698 1
a698 1
	if (se == (char *) 0)
@


1.40
log
@Escape ! characters for tab-completion, required for "set -o csh-history" users.
Tweak to maintain ascii ordering suggested by Simon Nicolussi. OK halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.39 2013/12/17 16:37:05 deraadt Exp $	*/
d492 1
a492 1
		afree((void *) info, ATEMP);
@


1.39
log
@ctype cleanups.  Repeated re-audits of this sensitive area by okan and
myself, with a variety of other people spending some time as well.
Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.38 2013/06/03 15:41:59 tedu Exp $	*/
d808 1
a808 1
		if (strchr("\"#$&'()*:;<=>?[\\]`{|}", s[add]) ||
@


1.38
log
@add : to special chars.
identical diffs from plhk sdf.org and leva ecentrum.hu. ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.37 2013/01/21 10:13:24 halex Exp $	*/
d552 2
a553 1
		for (p = start - 1; p >= 0 && isspace(buf[p]); p--)
@


1.37
log
@revert the tweak part of the last commit which, apart from the
questionable functionality of being able to expand environment
variables that did not match a filename, preserved the annoyance
of having stuff like "~/nonexistant" expanded to "~/nonexistant\* "

ok stsp@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.36 2013/01/20 14:47:46 stsp Exp $	*/
d807 1
a807 1
		if (strchr("\"#$&'()*;<=>?[\\]`{|}", s[add]) ||
@


1.36
log
@Fix backslash escaping during filename tab-completion in ksh.
Diff originally submitted by Alexander Polakov, with a small tweak from me
to avoid breaking tab-completion of environment variables (problem pointed
out by bentley).
ok sthen halex mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.35 2012/09/10 01:25:30 tedu Exp $	*/
d388 1
a388 2
		if ((strcmp(words[0], toglob) == 0 &&
		    lstat(words[0], &statb) < 0) ||
@


1.35
log
@fake a sigwinch after each job, so if the terminal changes size,
we'll notice and update
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.34 2010/05/20 01:13:07 fgsch Exp $	*/
d351 1
a351 1
	int nwords, i, idx, escaping;
a359 14
	/* remove all escaping backward slashes */
	escaping = 0;
	for (i = 0, idx = 0; toglob[i]; i++) {
		if (toglob[i] == '\\' && !escaping) {
			escaping = 1;
			continue;
		}

		toglob[idx] = toglob[i];
		idx++;
		if (escaping) escaping = 0;
	}
	toglob[idx] = '\0';

d367 1
a367 1
	if (yylex(ONEWORD) != LWORD) {
d383 4
a386 6
		/* Check if globbing failed (returned glob pattern),
		 * but be careful (E.g. toglob == "ab*" when the file
		 * "ab*" exists is not an error).
		 * Also, check for empty result - happens if we tried
		 * to glob something which evaluated to an empty
		 * string (e.g., "$FOO" when there is no FOO, etc).
d389 1
a389 1
		    stat(words[0], &statb) < 0) ||
@


1.34
log
@Escape "=", remove if 0'd out code and simplify check in x_print_expansions.
millert@@ ok some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.33 2007/08/02 10:50:25 fgsch Exp $	*/
d23 1
a23 1
static volatile sig_atomic_t got_sigwinch;
@


1.33
log
@fix memory leaks and one potential null deref found by coverity. from netbsd.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.32 2007/08/01 10:08:56 fgsch Exp $	*/
a293 26
#if 0 /* not used... */
int	x_complete_word(const char *str, int slen, int is_command,
	    int *multiple, char **ret);
int
x_complete_word(const char *str, int slen, int is_command, int *multiple,
    char **ret)
{
	int nwords;
	int prefix_len;
	char **words;

	nwords = (is_command ? x_command_glob : x_file_glob)(XCF_FULLPATH,
	    str, slen, &words);
	*nwordsp = nwords;
	if (nwords == 0) {
		*ret = (char *) 0;
		return -1;
	}

	prefix_len = x_longest_prefix(nwords, words);
	*ret = str_nsave(words[0], prefix_len, ATEMP);
	x_free_words(nwords, words);
	return prefix_len;
}
#endif /* 0 */

d649 2
a650 2
		else if (*s == '*' || *s == '[' || *s == '?' || *s == '$'
			 || (s[1] == '(' /*)*/ && strchr("*+?@@!", *s)))
d821 1
a821 1
	int rval=0;
d824 2
a825 1
		if (strchr("\\$(){}[]?*&;#|<>\"'`", s[add]) || strchr(ifs, s[add])) {
@


1.32
log
@escape [, ], and ? as well. from cbiere@@netbsd.
millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.31 2005/12/11 20:31:21 otto Exp $	*/
d434 1
d440 6
a445 1
	*wordsp = nwords ? words : (char **) 0;
@


1.31
log
@fix a few name clashes with libc; found by lint. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.30 2005/09/11 18:08:47 otto Exp $	*/
d844 1
a844 1
		if (strchr("\\$(){}*&;#|<>\"'`", s[add]) || strchr(ifs, s[add])) {
@


1.30
log
@Process window size changes after xread(). [change window size]
echo $COLUMS $LINES; will now print the new sizes immediately, instead
of after the second echo. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.29 2005/04/13 02:33:08 deraadt Exp $	*/
d760 1
a760 1
	for (twalk(&ts, tp); (te = tnext(&ts)); ) {
@


1.29
log
@use STD{IN,OUT,ERR}_FILENO
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.28 2005/03/30 17:16:37 deraadt Exp $	*/
a94 3
	if (got_sigwinch)
		check_sigwinch();

d108 1
@


1.28
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.27 2005/02/25 11:21:16 deraadt Exp $	*/
d122 1
a122 1
	while ((n = blocking_read(0, &c, 1)) < 0 && errno == EINTR)
@


1.27
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.26 2004/12/22 17:14:34 millert Exp $	*/
d36 2
a37 2
	edchars.erase = edchars.kill = edchars.intr = edchars.quit
		= edchars.eof = -2;
d75 2
a76 2
				x_cols = ws.ws_col < MIN_COLS ? MIN_COLS
						: ws.ws_col;
d81 1
a81 2
			if (ws.ws_row
			    && (vp = typeset("LINES", 0, 0, 0, 0)))
d217 1
a217 1
			FEMACS, FGMACS,
d220 1
a220 1
			FVI,
d222 1
a222 1
		    };
d298 1
a298 1
			      int *multiple, char **ret);
d308 1
a308 1
				str, slen, &words);
d332 2
a333 3
	if (!is_command
	    && (prefix_len = x_longest_prefix(nwords, words)) > 0)
	{
d341 2
a342 2
			if (x_basename(words[i] + prefix_len, (char *) 0)
							> prefix_len)
d346 1
a346 2
			while (prefix_len > 0
			       && words[0][prefix_len - 1] != '/')
d390 1
a390 1
	for(i = 0, idx = 0; toglob[i]; i++) {
d432 3
a434 4
		if ((strcmp(words[0], toglob) == 0
		     && stat(words[0], &statb) < 0)
		    || words[0][0] == '\0')
		{
d520 2
a521 4
			if (!last_info || info[i].base != last_info->base
			    || strncmp(words[i],
					last_info->word, info[i].base) != 0)
			{
d556 2
a557 2
#define IS_WORDC(c)	!( ctype(c, C_LEX1) || (c) == '\'' || (c) == '"'  \
			    || (c) == '`' || (c) == '=' || (c) == ':' )
d578 2
a579 2
	for (; (start > 0 && IS_WORDC(buf[start - 1]))
		|| (start > 1 && buf[start-2] == '\\'); start--)
d632 1
a632 1
				    buf + *startp, len, &words);
d815 2
a816 2
			if ((search_access(words[i], X_OK, &staterr) >= 0)
			    || (staterr == EISDIR)) {
d820 1
a820 1
						strlen(words[j] + pathlen) + 1);
@


1.26
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.25 2004/12/20 11:34:26 otto Exp $	*/
d51 1
@


1.25
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.24 2004/12/19 04:14:20 deraadt Exp $	*/
d98 1
a98 1
	x_mode(TRUE);
d110 1
a110 1
	x_mode(FALSE);
d124 1
a124 1
			x_mode(FALSE);
d126 1
a126 1
			x_mode(TRUE);
d152 2
a153 2
bool_t
x_mode(bool_t onoff)
d155 2
a156 2
	static bool_t	x_cur_mode;
	bool_t		prev;
d659 1
a659 1
	bool_t saw_slash = FALSE;
d680 1
a680 1
			saw_slash = TRUE;
d768 1
a768 1
		if (gmatch(te->name, pat, FALSE))
@


1.24
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.23 2004/12/18 22:12:23 millert Exp $	*/
d22 1
a22 1
static void x_sigwinch(int sig);
d26 3
a28 6
static int	x_file_glob(int flags, const char *str, int slen,
				  char ***wordsp);
static int	x_command_glob(int flags, const char *str, int slen,
				     char ***wordsp);
static int	x_locate_word(const char *buf, int buflen, int pos,
				    int *startp, int *is_command);
d33 1
a33 1
x_init()
d52 1
a52 2
x_sigwinch(sig)
	int sig;
d91 1
a91 3
x_read(buf, len)
	char *buf;
	size_t len;
d117 1
a117 1
x_getc()
d134 1
a134 1
x_flush()
d140 1
a140 2
x_putc(c)
	int c;
d146 1
a146 2
x_puts(s)
	const char *s;
d153 1
a153 2
x_mode(onoff)
	bool_t	onoff;
d213 1
a213 2
set_editmode(ed)
	const char *ed;
d247 1
a247 4
x_do_comment(buf, bsize, lenp)
	char *buf;
	int bsize;
	int *lenp;
d300 2
a301 6
x_complete_word(str, slen, is_command, nwordsp, ret)
	const char *str;
	int slen;
	int is_command;
	int *nwordsp;
	char **ret;
d323 1
a323 4
x_print_expansions(nwords, words, is_command)
	int nwords;
	char *const *words;
	int is_command;
d377 1
a377 5
x_file_glob(flags, str, slen, wordsp)
	int flags;
	const char *str;
	int slen;
	char ***wordsp;
d460 1
a460 3
path_order_cmp(aa, bb)
	const void *aa;
	const void *bb;
d471 1
a471 5
x_command_glob(flags, str, slen, wordsp)
	int flags;
	const char *str;
	int slen;
	char ***wordsp;
d565 2
a566 6
x_locate_word(buf, buflen, pos, startp, is_commandp)
	const char *buf;
	int buflen;
	int pos;
	int *startp;
	int *is_commandp;
d618 2
a619 9
x_cf_glob(flags, buf, buflen, pos, startp, endp, wordsp, is_commandp)
	int flags;
	const char *buf;
	int buflen;
	int pos;
	int *startp;
	int *endp;
	char ***wordsp;
	int *is_commandp;
d655 1
a655 3
add_glob(str, slen)
	const char *str;
	int slen;
d694 1
a694 3
x_longest_prefix(nwords, words)
	int nwords;
	char *const *words;
d714 1
a714 3
x_free_words(nwords, words)
	int nwords;
	char **words;
d737 1
a737 3
x_basename(s, se)
	const char *s;
	const char *se;
d762 1
a762 4
glob_table(pat, wp, tp)
	const char *pat;
	XPtrV *wp;
	struct table *tp;
d774 1
a774 5
glob_path(flags, pat, wp, path)
	int flags;
	const char *pat;
	XPtrV *wp;
	const char *path;
d844 1
a844 4
x_escape(s, len, putbuf_func)
	const char *s;
	size_t len;
	int putbuf_func(const char *s, size_t len);
@


1.23
log
@Use struct termios instead of TTY_state typedef
Use tc[gs]etattr() instead of [gs]et_tty() abstraction
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.22 2004/12/18 22:11:43 millert Exp $	*/
d56 1
a56 1
    	int sig;
d80 1
a80 1
				
d175 1
a175 1
		
@


1.22
log
@Flags set in signal handlers should be volatile sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.21 2004/12/18 20:58:03 millert Exp $	*/
d173 1
a173 1
		TTY_state	cb;
d194 1
a194 1
		set_tty(tty_fd, &cb, TF_WAIT);
d215 1
a215 2
		/* TF_WAIT doesn't seem to be necessary when leaving xmode */
		set_tty(tty_fd, &tty_state, TF_NONE);
@


1.21
log
@Use _POSIX_VDISABLE directly instead of assigning it to a variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.20 2004/12/18 20:55:52 millert Exp $	*/
d23 1
a23 1
static int got_sigwinch;
@


1.20
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.19 2004/11/04 19:20:07 deraadt Exp $	*/
a32 2
static char vdisable_c;

a51 2

	vdisable_c = (char) _POSIX_VDISABLE;
d188 1
a188 1
		cb.c_cc[VLNEXT] = vdisable_c;
d190 1
a190 1
		cb.c_cc[VDISCARD] = vdisable_c;
d197 1
a197 1
		if (edchars.erase == vdisable_c)
d199 1
a199 1
		if (edchars.kill == vdisable_c)
d201 1
a201 1
		if (edchars.intr == vdisable_c)
d203 1
a203 1
		if (edchars.quit == vdisable_c)
d205 1
a205 1
		if (edchars.eof == vdisable_c)
d207 1
a207 1
		if (edchars.werase == vdisable_c)
@


1.19
log
@do the variety-pack of bash-style \letter expansions on prompt variables.
a few issues remain with \ and $ and ! because of early variable expansion
done by incorrect eval/substitution, but this change is not responsible
for that.  tested by djm, jmc, and many others
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.18 2003/08/22 18:17:10 fgsch Exp $	*/
a15 4
#ifdef OS_SCO	/* SCO Unix 3.2v4.1 */
# include <sys/stream.h>	/* needed for <sys/ptem.h> */
# include <sys/ptem.h>		/* needed for struct winsize */
#endif /* OS_SCO */
d19 1
a19 1
#include "ksh_stat.h"
d22 1
a22 2
#if defined(TIOCGWINSZ)
static RETSIGTYPE x_sigwinch ARGS((int sig));
d24 1
a24 2
static void check_sigwinch ARGS((void));
#endif /* TIOCGWINSZ */
d26 6
a31 6
static int	x_file_glob ARGS((int flags, const char *str, int slen,
				  char ***wordsp));
static int	x_command_glob ARGS((int flags, const char *str, int slen,
				     char ***wordsp));
static int	x_locate_word ARGS((const char *buf, int buflen, int pos,
				    int *startp, int *is_command));
a45 2
#ifdef TIOCGWINSZ
# ifdef SIGWINCH
a47 1
# endif /* SIGWINCH */
a49 1
#endif /* TIOCGWINSZ */
d55 1
a55 16
	/* Bizarreness to figure out how to disable
	 * a struct termios.c_cc[] char
	 */
#ifdef _POSIX_VDISABLE
	if (_POSIX_VDISABLE >= 0)
		vdisable_c = (char) _POSIX_VDISABLE;
	else
		/* `feature not available' */
		vdisable_c = (char) 0377;
#else
# if defined(HAVE_PATHCONF) && defined(_PC_VDISABLE)
	vdisable_c = fpathconf(tty_fd, _PC_VDISABLE);
# else
	vdisable_c = (char) 0377;	/* default to old BSD value */
# endif
#endif /* _POSIX_VDISABLE */
d58 1
a58 2
#if defined(TIOCGWINSZ)
static RETSIGTYPE
a62 1
	return RETSIGVAL;
d66 1
a66 1
check_sigwinch ARGS((void))
a93 1
#endif /* TIOCGWINSZ */
a104 1
#if defined(TIOCGWINSZ)
a106 1
#endif /* TIOCGWINSZ */
a128 4
#ifdef OS2
	unsigned char c = _read_kbd(0, 1, 0);
	return c == 0 ? 0xE0 : c;
#else /* OS2 */
a140 1
#endif /* OS2 */
a182 1
#if defined(HAVE_TERMIOS_H) || defined(HAVE_TERMIO_H)
a187 1
# ifdef VWERASE
a188 5
# endif
# ifdef _CRAY2		/* brain-damaged terminal handler */
		cb.c_lflag &= ~(ICANON|ECHO);
		/* rely on print routine to map '\n' to CR,LF */
# else
a189 9
#  ifdef _BSD_SYSV	/* need to force CBREAK instead of RAW (need CRMOD on output) */
		cb.c_lflag &= ~(ICANON|ECHO);
#  else
#   ifdef SWTCH	/* need CBREAK to handle swtch char */
		cb.c_lflag &= ~(ICANON|ECHO);
		cb.c_lflag |= ISIG;
		cb.c_cc[VINTR] = vdisable_c;
		cb.c_cc[VQUIT] = vdisable_c;
#   else
a190 3
#   endif
#  endif
#  ifdef VLNEXT
a192 2
#  endif /* VLNEXT */
#  ifdef VDISCARD
a194 1
#  endif /* VDISCARD */
a196 34
# endif	/* _CRAY2 */
#else
	/* Assume BSD tty stuff. */
		edchars.erase = cb.sgttyb.sg_erase;
		edchars.kill = cb.sgttyb.sg_kill;
		cb.sgttyb.sg_flags &= ~ECHO;
		cb.sgttyb.sg_flags |= CBREAK;
#  ifdef TIOCGATC
		edchars.intr = cb.lchars.tc_intrc;
		edchars.quit = cb.lchars.tc_quitc;
		edchars.eof = cb.lchars.tc_eofc;
		edchars.werase = cb.lchars.tc_werasc;
		cb.lchars.tc_suspc = -1;
		cb.lchars.tc_dsuspc = -1;
		cb.lchars.tc_lnextc = -1;
		cb.lchars.tc_statc = -1;
		cb.lchars.tc_intrc = -1;
		cb.lchars.tc_quitc = -1;
		cb.lchars.tc_rprntc = -1;
#  else
		edchars.intr = cb.tchars.t_intrc;
		edchars.quit = cb.tchars.t_quitc;
		edchars.eof = cb.tchars.t_eofc;
		cb.tchars.t_intrc = -1;
		cb.tchars.t_quitc = -1;
#   ifdef TIOCGLTC
		edchars.werase = cb.ltchars.t_werasc;
		cb.ltchars.t_suspc = -1;
		cb.ltchars.t_dsuspc = -1;
		cb.ltchars.t_lnextc = -1;
		cb.ltchars.t_rprntc = -1;
#   endif
#  endif /* TIOCGATC */
#endif /* HAVE_TERMIOS_H || HAVE_TERMIO_H */
a199 5
#ifdef __CYGWIN__
		if (edchars.eof == '\0')
			edchars.eof = '\4';
#endif /* __CYGWIN__ */

d241 1
a241 1
	if ((rcp = ksh_strrchr_dirsep(ed)))
d309 4
a312 4
static char	*add_glob ARGS((const char *str, int slen));
static void	glob_table ARGS((const char *pat, XPtrV *wp, struct table *tp));
static void	glob_path ARGS((int flags, const char *pat, XPtrV *wp,
				const char *path));
d315 2
a316 2
int	x_complete_word ARGS((const char *str, int slen, int is_command,
			      int *multiple, char **ret));
d373 1
a373 1
			       && !ISDIRSEP(words[0][prefix_len - 1]))
d497 1
a497 1
	t = FILECMP(a->word + a->base, b->word + b->base);
d559 1
a559 1
			    || FILENCMP(words[i],
d644 1
a644 1
				if (ISDIRSEP(buf[p]))
d727 1
a727 1
		else if (ISDIRSEP(*s))
d756 1
a756 1
			if (FILECHCONV(p[j]) != FILECHCONV(words[0][j])) {
d801 1
a801 1
	for (p = se - 1; p > s && ISDIRSEP(*p); p--)
d803 1
a803 1
	for (; p > s && !ISDIRSEP(*p); p--)
d805 1
a805 1
	if (ISDIRSEP(*p) && p + 1 < se)
d851 1
a851 1
		if (!(p = strchr(sp, PATHSEP)))
d866 1
a866 1
			*xp++ = DIRSEP;
d908 1
a908 1
	int putbuf_func ARGS((const char *s, size_t len));
@


1.18
log
@in word location, fix forward scanning so it correctly account for any
escaped char and not only spaces.
for "foo (bar.a)" and "foo (bar a)", cd foo\ \(bar.<tab> will correctly
expand to foo\ \(bar.a\).
otto@@ and pval@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.17 2003/06/26 00:09:45 deraadt Exp $	*/
d22 1
a319 53
}

/* NAME:
 *      promptlen - calculate the length of PS1 etc.
 *
 * DESCRIPTION:
 *      This function is based on a fix from guy@@demon.co.uk
 *      It fixes a bug in that if PS1 contains '!', the length
 *      given by strlen() is probably wrong.
 *
 * RETURN VALUE:
 *      length
 */
int
promptlen(cp, spp)
    const char  *cp;
    const char **spp;
{
    int count = 0;
    const char *sp = cp;
    char delimiter = 0;
    int indelimit = 0;

    /* Undocumented AT&T ksh feature:
     * If the second char in the prompt string is \r then the first char
     * is taken to be a non-printing delimiter and any chars between two
     * instances of the delimiter are not considered to be part of the
     * prompt length
     */
    if (*cp && cp[1] == '\r') {
	delimiter = *cp;
	cp += 2;
    }

    for (; *cp; cp++) {
	if (indelimit && *cp != delimiter)
	    ;
	else if (*cp == '\n' || *cp == '\r') {
	    count = 0;
	    sp = cp + 1;
	} else if (*cp == '\t') {
	    count = (count | 7) + 1;
	} else if (*cp == '\b') {
	    if (count > 0)
		count--;
	} else if (*cp == delimiter)
	    indelimit = !indelimit;
	else
	    count++;
    }
    if (spp)
	*spp = sp;
    return count;
@


1.17
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.16 2003/05/05 22:02:33 fgsch Exp $	*/
d775 1
a775 1
		if (buf[end] == '\\' && (end+1) < buflen && buf[end+1] == ' ')
@


1.16
log
@in emacs or vi mode, if vi-tabcomplete or vi-esccomplete mode is on, this
escapes "`" so by instance cd works correctly; millert@@ and pvalchev@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.15 2002/06/09 05:47:27 todd Exp $	*/
d632 2
@


1.15
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.14 2002/02/16 17:18:08 millert Exp $	*/
d1061 1
a1061 1
		if (strchr("\\$(){}*&;#|<>\"'", s[add]) || strchr(ifs, s[add])) {
@


1.14
log
@Add '#' to the list of escaped characters during vi/emacs filename completion.
From Matt Bing.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.13 2001/02/19 19:32:13 camield Exp $	*/
d326 1
a326 1
 *      It fixes a bug in that if PS1 contains '!', the length 
d388 1
a388 1
  
@


1.13
log
@forgot to remove debugging #if 0

messed up completion on e.g. / and ./
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.12 2001/02/19 09:49:51 camield Exp $	*/
d1061 1
a1061 1
		if (strchr("\\$(){}*&;|<>\"'", s[add]) || strchr(ifs, s[add])) {
@


1.12
log
@bash-like 'double-tab' completion

- bind TAB (^I) to complete-list by default
- complete-list now lists 'ls style' not 'menu style'
- complete-list first completes; if that does not work, it lists
- fix a memleak in emacs.c, do_complete
- completion now works after '=' (dd), and ':' (ssh) and ` (backtick)
- a command can now start with a subdir from the current dir
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.11 1999/11/14 22:04:02 d Exp $	*/
a783 1
#if 0
a793 1
#endif
@


1.11
log
@quote metachars when completing filenames from jdolecek@@netbsd. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.10 1999/06/15 01:18:33 millert Exp $	*/
d503 1
a503 1
	 * case, we want to omitt the directory name)
d536 1
a536 1
	pr_menu(use_copy ? (char **) XPptrv(l) : words);
d742 2
a743 1
#define IS_WORDC(c)	!(ctype(c, C_LEX1) || (c) == '\'' || (c) == '"')
d783 2
a784 1
		iscmd = p < 0 || strchr(";|&()", buf[p]);
d795 1
d987 1
d1022 1
a1022 1
		glob_str(Xstring(xs, xp), wp, 0);
d1028 3
a1030 1
			if (search_access(words[i], X_OK, (int *) 0) >= 0) {
@


1.10
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.9 1999/01/10 17:55:02 millert Exp $	*/
d558 1
a558 1
	int nwords;
d567 14
d767 2
a768 1
	for (; start > 0 && IS_WORDC(buf[start - 1]); start--)
d771 4
a774 2
	for (end = start; end < buflen && IS_WORDC(buf[end]); end++)
		;
d1041 36
@


1.9
log
@sync with pdksh-unstable-5.2.13.6
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.8 1999/01/08 20:24:58 millert Exp $	*/
d45 1
a45 1
	/* set to -1 to force initial binding */
d47 1
a47 1
		= edchars.eof = -1;
d290 18
@


1.8
log
@bug fixes from pdksh-unstable-5.2.13.5; some of which we already had.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.7 1998/06/25 19:01:50 millert Exp $	*/
d710 1
a710 1
#define IS_WORDC(c)	!isspace(c)
@


1.7
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.6 1997/06/19 13:58:39 kstailey Exp $	*/
d295 1
a295 1
	} else
d298 1
@


1.6
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.4 1996/12/14 12:18:07 mickey Exp $	*/
d728 1
a728 9

	if (pos == buflen) {
		if (pos == 0) { /* empty buffer? */
			*startp = pos;
			*is_commandp = 1;
			return 0;
		}
		pos--;
	}
@


1.5
log
@(foo *)0 -> NULL
@
text
@d462 1
a462 1
		*ret = NULL;
d493 1
a493 1
			prefix_len = x_basename(words[0], NULL);
d496 1
a496 1
			if (x_basename(words[i] + prefix_len, NULL)
d508 1
a508 1
			XPput(l, NULL);
d588 1
a588 1
	*wordsp = nwords ? words : NULL;
d652 1
a652 1
		*wordsp = NULL;
d670 1
a670 1
			info[i].base = x_basename(words[i], NULL);
d802 1
a802 1
		*wordsp = NULL;
d827 1
a827 1
		return (NULL);
d912 1
a912 1
	if (se == NULL)
d996 1
a996 1
			if (search_access(words[i], X_OK, NULL) >= 0) {
@


1.4
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.3 1996/10/01 02:05:33 downsj Exp $	*/
d462 1
a462 1
		*ret = (char *) 0;
d493 1
a493 1
			prefix_len = x_basename(words[0], (char *) 0);
d496 1
a496 1
			if (x_basename(words[i] + prefix_len, (char *) 0)
d508 1
a508 1
			XPput(l, (char *) 0);
d588 1
a588 1
	*wordsp = nwords ? words : (char **) 0;
d652 1
a652 1
		*wordsp = (char **) 0;
d670 1
a670 1
			info[i].base = x_basename(words[i], (char *) 0);
d802 1
a802 1
		*wordsp = (char **) 0;
d827 1
a827 1
		return (char *) 0;
d912 1
a912 1
	if (se == (char *) 0)
d996 1
a996 1
			if (search_access(words[i], X_OK, (int *) 0) >= 0) {
@


1.3
log
@Integrate pdksh 5.2.9.
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.2 1996/08/19 20:08:47 downsj Exp $	*/
d20 1
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.1.1.1 1996/08/14 06:19:10 downsj Exp $	*/
d55 1
a311 1
 
d319 2
d322 15
a336 2
    while (*cp) {
	if (*cp == '\n' || *cp == '\r') {
d338 1
a338 2
	    cp++;
	    sp = cp;
a340 1
	    cp++;
d344 2
a345 3
	    cp++;
	}
#if 1
a346 6
	  cp++, count++;
#else
	else if (*cp++ != '!')
	  count++;
	else if (*cp == '!') {
	    cp++;
a347 8
	} else {
	    register int i = source->line + 1;

	    do
		count++;
	    while ((i /= 10) > 0);
	}
#endif /* 1 */
d823 1
d833 3
a835 2
	 * '?', or '[') or parameter expansion ('$'), then it is globbed
	 * based on that value (i.e., without the appended '*').
d843 2
d846 1
a846 1
	if (!*s) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d23 15
a37 1
static char	vdisable_c;
d49 1
d51 6
a56 2
	{
		struct winsize ws;
a57 16
		if (ioctl(tty_fd, TIOCGWINSZ, &ws) >= 0) {
			struct tbl *vp;

			if (ws.ws_col) {
				x_cols = ws.ws_col < MIN_COLS ? MIN_COLS
						: ws.ws_col;
				
				if ((vp = typeset("COLUMNS", EXPORT, 0, 0, 0)))
					setint(vp, (long) ws.ws_col);
			}
			if (ws.ws_row
			    && (vp = typeset("LINES", EXPORT, 0, 0, 0)))
				setint(vp, (long) ws.ws_row);
		}
	}
#endif /* TIOCGWINSZ */
d80 40
d130 5
d381 55
d444 3
a446 1
/* XXX not used... */
d472 1
d531 1
a531 2
/* XXX static? */
int
d544 1
a544 1
	if (slen <= 0)
d615 1
a615 2
/* XXX static? */
int
d629 1
a629 1
	if (slen <= 0)
d712 1
a712 2
/* XXX static? */
int
d723 2
a724 3
	if (pos == buflen)
		pos--;
	if (pos < 0 || pos >= buflen) {
d730 14
a743 8
	/* Go backwards 'til we are in a word */
	for (start = pos; start >= 0 && !IS_WORDC(buf[start]); start--)
		;
	/* No word found? */
	if (start < 0)
		return 0;
	/* Keep going backwards to start of word */
	for (; start >= 0 && IS_WORDC(buf[start]); start--)
a744 2
	start++;

d791 7
a797 1
	if (len == 0)
a799 2
	if (!(flags & XCF_COMMAND))
		is_command = 0;
d826 1
a826 1
	if (slen <= 0)
d993 1
a993 1
			if (search_access(words[i], X_OK) >= 0) {
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
