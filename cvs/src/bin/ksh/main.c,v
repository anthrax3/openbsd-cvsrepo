head	1.82;
access;
symbols
	OPENBSD_6_1:1.82.0.2
	OPENBSD_6_1_BASE:1.82
	OPENBSD_6_0:1.79.0.2
	OPENBSD_6_0_BASE:1.79
	OPENBSD_5_9:1.78.0.2
	OPENBSD_5_9_BASE:1.78
	OPENBSD_5_8:1.55.0.6
	OPENBSD_5_8_BASE:1.55
	OPENBSD_5_7:1.55.0.2
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.54.0.6
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.54.0.4
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.52.0.2
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.51.0.2
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.47.0.4
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.2
	OPENBSD_5_0:1.46.0.6
	OPENBSD_5_0_BASE:1.46
	OPENBSD_4_9:1.46.0.4
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.46.0.2
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.45.0.4
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.45.0.6
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.2
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.44.0.2
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.43.0.4
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.43.0.2
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.36.0.2
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.20.0.6
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.20.0.4
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_8:1.19.0.4
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.82
date	2016.10.17.17.44.47;	author schwarze;	state Exp;
branches;
next	1.81;
commitid	yUIPO9ruHzE0GnK9;

1.81
date	2016.10.11.19.52.54;	author schwarze;	state Exp;
branches;
next	1.80;
commitid	PFDfEfGGTUypn9vm;

1.80
date	2016.09.08.15.51.54;	author millert;	state Exp;
branches;
next	1.79;
commitid	a6lnbl5aJlwjDXlq;

1.79
date	2016.03.04.15.11.06;	author deraadt;	state Exp;
branches;
next	1.78;
commitid	lvfr78VLuzkoupSX;

1.78
date	2015.12.30.09.07.00;	author tedu;	state Exp;
branches;
next	1.77;
commitid	WTwPzlskFufQpRQz;

1.77
date	2015.12.27.19.33.26;	author jca;	state Exp;
branches;
next	1.76;
commitid	rpFzSauRadiwTZQA;

1.76
date	2015.12.27.09.24.00;	author halex;	state Exp;
branches;
next	1.75;
commitid	6tjc5NcG1V1dO6ad;

1.75
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.74;
commitid	btTCreDA00YdaFhU;

1.74
date	2015.11.11.02.52.46;	author deraadt;	state Exp;
branches;
next	1.73;
commitid	6fvHpVQjE6wYuHzb;

1.73
date	2015.11.01.15.38.53;	author mmcc;	state Exp;
branches;
next	1.72;
commitid	Fr9nr0FBz2YkAWdK;

1.72
date	2015.10.30.03.13.52;	author guenther;	state Exp;
branches;
next	1.71;
commitid	7BMB3p5AkM8PPwbj;

1.71
date	2015.10.22.15.37.04;	author mmcc;	state Exp;
branches;
next	1.70;
commitid	UF4WZB601GytEPMw;

1.70
date	2015.10.21.14.30.43;	author mmcc;	state Exp;
branches;
next	1.69;
commitid	GfauVznpEDbDQteT;

1.69
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.68;
commitid	C4W85jmosThChWA2;

1.68
date	2015.10.19.14.01.37;	author mmcc;	state Exp;
branches;
next	1.67;
commitid	u5rhHK1DMglSuCSZ;

1.67
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.66;
commitid	16HUr75moyUNtKR8;

1.66
date	2015.10.18.18.05.35;	author mmcc;	state Exp;
branches;
next	1.65;
commitid	N64sMvTaEh7ch3Sh;

1.65
date	2015.10.17.18.26.24;	author mmcc;	state Exp;
branches;
next	1.64;
commitid	cg0YOIB6IojdTdEq;

1.64
date	2015.10.16.14.45.16;	author deraadt;	state Exp;
branches;
next	1.63;
commitid	KWmktD2e3ix6ygah;

1.63
date	2015.10.16.13.37.43;	author millert;	state Exp;
branches;
next	1.62;
commitid	H99PcNtHGZMrNl2r;

1.62
date	2015.10.10.20.35.00;	author deraadt;	state Exp;
branches;
next	1.61;
commitid	m38BXhkh3XknrpM6;

1.61
date	2015.10.10.00.10.07;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	xaTgTtwXn5YGjAmi;

1.60
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.59;
commitid	7fgq4YTZG4xZ0uN0;

1.59
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.58;
commitid	v5QjoxUgKU2iUTFz;

1.58
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.57;
commitid	lBs9un9sXhbdfVrQ;

1.57
date	2015.09.10.22.48.58;	author nicm;	state Exp;
branches;
next	1.56;
commitid	stJ3KRI2o7F5OBtF;

1.56
date	2015.09.01.17.46.31;	author tedu;	state Exp;
branches;
next	1.55;
commitid	4AWMglvsCILmneJ0;

1.55
date	2015.02.09.09.09.30;	author jsg;	state Exp;
branches;
next	1.54;
commitid	uzKTVAHRqy49RYm8;

1.54
date	2013.11.28.10.33.37;	author sobrado;	state Exp;
branches;
next	1.53;

1.53
date	2013.09.04.15.49.19;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2013.06.15.17.25.19;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2012.09.10.01.25.30;	author tedu;	state Exp;
branches;
next	1.50;

1.50
date	2012.09.06.18.04.34;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2012.09.05.22.20.25;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2012.09.05.22.15.29;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2011.09.07.11.33.25;	author otto;	state Exp;
branches;
next	1.46;

1.46
date	2010.05.19.17.36.08;	author jasper;	state Exp;
branches;
next	1.45;

1.45
date	2009.01.29.23.27.26;	author jaredy;	state Exp;
branches;
next	1.44;

1.44
date	2008.07.05.07.25.18;	author djm;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.31.20.47.44;	author otto;	state Exp;
branches;
next	1.42;

1.42
date	2006.11.02.18.21.20;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.10.14.38.59;	author jaredy;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.11.20.31.21;	author otto;	state Exp;
branches;
next	1.39;

1.39
date	2005.12.11.18.53.51;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.28.21.33.01;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2005.02.21.16.01.58;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.22.18.57.28;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2004.12.18.21.08.44;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.18.21.04.52;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.23.14.56.32;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.07.23.20.46;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.08.05.43.14;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.26.00.09.45;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.04.23.12.02;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.10.03.48.16;	author david;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.20;

1.20
date	2000.12.19.21.48.54;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	99.11.14.18.18.39;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	99.11.14.17.56.47;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	99.08.04.19.11.13;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	99.07.15.20.39.40;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	99.06.15.01.18.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.04.27.18.18.19;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.01.10.17.55.03;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.01.08.20.25.00;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.10.29.04.09.21;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.06.25.19.02.10;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.09.12.00.32.53;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.09.01.18.30.09;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.06.19.13.58.45;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.06.18.22.42.40;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.01.02.09.34.03;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.11.21.07.59.33;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.10.01.02.05.45;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.56;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.82
log
@No need to inspect LC_CTYPE:
* It was only used in vi input mode.
* No functional change in case of set -o vi-show8.
* No functional change if LC_CTYPE is set to UTF-8.
* More robust for the default of LC_CTYPE=C on a UTF-8 xterm.

Behaviour changes for the combination LC_CTYPE=C with set +o vi-show8
on non-UTF-8 terminals, but that combination is useless and dangerous
with or without this patch.  If you want to edit individual raw non-ASCII
non-UTF-8 bytes on the shell command line, always use set -o vi-show8.
(Besides, i doubt that you actually want to do that; better use a real
hex editor in the first place.)

OK czarkoff@@.
@
text
@/*	$OpenBSD: main.c,v 1.81 2016/10/11 19:52:54 schwarze Exp $	*/

/*
 * startup, main loop, environments and error handling
 */

#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "sh.h"

extern char **environ;

/*
 * global data
 */

static void	reclaim(void);
static void	remove_temps(struct temp *tp);
static int	is_restricted(char *name);
static void	init_username(void);

const char *kshname;
pid_t	kshpid;
pid_t	procpid;
uid_t	ksheuid;
int	exstat;
int	subst_exstat;
const char *safe_prompt;

Area	aperm;

struct env	*genv;

char	shell_flags[FNFLAGS];

char	null[] = "";

int shl_stdout_ok;

unsigned int	ksh_tmout;
enum tmout_enum	ksh_tmout_state = TMOUT_EXECUTING;

int	really_exit;

int ifs0 = ' ';

volatile sig_atomic_t	trap;
volatile sig_atomic_t	intrsig;
volatile sig_atomic_t	fatal_trap;

Getopt	builtin_opt;
Getopt	user_opt;

struct coproc	coproc;
sigset_t	sm_default, sm_sigchld;

char	*builtin_argv0;
int	 builtin_flag;

char	*current_wd;
int	 current_wd_size;

#ifdef EDIT
int	x_cols = 80;
#endif /* EDIT */

/*
 * shell initialization
 */

static const char initifs[] = "IFS= \t\n";

static const char initsubs[] = "${PS2=> } ${PS3=#? } ${PS4=+ }";

static const char *initcoms [] = {
	"typeset", "-r", "KSH_VERSION", NULL,
	"typeset", "-x", "SHELL", "PATH", "HOME", NULL,
	"typeset", "-ir", "PPID", NULL,
	"typeset", "-i", "OPTIND=1", NULL,
	"eval", "typeset -i RANDOM MAILCHECK=\"${MAILCHECK-600}\" SECONDS=\"${SECONDS-0}\" TMOUT=\"${TMOUT-0}\"", NULL,
	"alias",
	 /* Standard ksh aliases */
	  "hash=alias -t",	/* not "alias -t --": hash -r needs to work */
	  "type=whence -v",
#ifdef JOBS
	  "stop=kill -STOP",
#endif
	  "autoload=typeset -fu",
	  "functions=typeset -f",
#ifdef HISTORY
	  "history=fc -l",
#endif /* HISTORY */
	  "integer=typeset -i",
	  "nohup=nohup ",
	  "local=typeset",
	  "r=fc -s",
	 /* Aliases that are builtin commands in at&t */
	  "login=exec login",
	  NULL,
	/* this is what at&t ksh seems to track, with the addition of emacs */
	"alias", "-tU",
	  "cat", "cc", "chmod", "cp", "date", "ed", "emacs", "grep", "ls",
	  "mail", "make", "mv", "pr", "rm", "sed", "sh", "vi", "who",
	  NULL,
	NULL
};

char username[_PW_NAME_LEN + 1];

#define version_param  (initcoms[2])

/* The shell uses its own variation on argv, to build variables like
 * $0 and $@@.
 * Allocate a new array since modifying the original argv will modify
 * ps output.
 */
static char **
make_argv(int argc, char *argv[])
{
	int i;
	char **nargv;

	nargv = areallocarray(NULL, argc + 1, sizeof(char *), &aperm);
	nargv[0] = (char *) kshname;
	for (i = 1; i < argc; i++)
		nargv[i] = argv[i];
	nargv[i] = NULL;

	return nargv;
}

int
main(int argc, char *argv[])
{
	int i;
	int argi;
	Source *s;
	struct block *l;
	int restricted, errexit;
	char **wp;
	struct env env;
	pid_t ppid;

	kshname = argv[0];

	if (pledge("stdio rpath wpath cpath fattr flock getpw proc exec tty",
	    NULL) == -1) {
		perror("pledge");
		exit(1);
	}

	ainit(&aperm);		/* initialize permanent Area */

	/* set up base environment */
	memset(&env, 0, sizeof(env));
	env.type = E_NONE;
	ainit(&env.area);
	genv = &env;
	newblock();		/* set up global l->vars and l->funs */

	/* Do this first so output routines (eg, errorf, shellf) can work */
	initio();

	initvar();

	initctypes();

	inittraps();

	coproc_init();

	/* set up variable and command dictionaries */
	ktinit(&taliases, APERM, 0);
	ktinit(&aliases, APERM, 0);
	ktinit(&homedirs, APERM, 0);

	/* define shell keywords */
	initkeywords();

	/* define built-in commands */
	ktinit(&builtins, APERM, 64); /* must be 2^n (currently 40 builtins) */
	for (i = 0; shbuiltins[i].name != NULL; i++)
		builtin(shbuiltins[i].name, shbuiltins[i].func);
	for (i = 0; kshbuiltins[i].name != NULL; i++)
		builtin(kshbuiltins[i].name, kshbuiltins[i].func);

	init_histvec();

	def_path = _PATH_DEFPATH;
	{
		size_t len = confstr(_CS_PATH, NULL, 0);
		char *new;

		if (len > 0) {
			confstr(_CS_PATH, new = alloc(len + 1, APERM), len + 1);
			def_path = new;
		}
	}

	/* Set PATH to def_path (will set the path global variable).
	 * (import of environment below will probably change this setting).
	 */
	{
		struct tbl *vp = global("PATH");
		/* setstr can't fail here */
		setstr(vp, def_path, KSH_RETURN_ERROR);
	}


	/* Turn on nohup by default for now - will change to off
	 * by default once people are aware of its existence
	 * (at&t ksh does not have a nohup option - it always sends
	 * the hup).
	 */
	Flag(FNOHUP) = 1;

	/* Turn on brace expansion by default.  At&t ksh's that have
	 * alternation always have it on.  BUT, posix doesn't have
	 * brace expansion, so set this before setting up FPOSIX
	 * (change_flag() clears FBRACEEXPAND when FPOSIX is set).
	 */
#ifdef BRACE_EXPAND
	Flag(FBRACEEXPAND) = 1;
#endif /* BRACE_EXPAND */

	/* set posix flag just before environment so that it will have
	 * exactly the same effect as the POSIXLY_CORRECT environment
	 * variable.  If this needs to be done sooner to ensure correct posix
	 * operation, an initial scan of the environment will also have
	 * done sooner.
	 */
#ifdef POSIXLY_CORRECT
	change_flag(FPOSIX, OF_SPECIAL, 1);
#endif /* POSIXLY_CORRECT */

	/* Check to see if we're /bin/sh. */
	if (!strcmp(kshname, "sh") || !strcmp(kshname, "-sh") ||
	    (strlen(kshname) >= 3 &&
	    !strcmp(&kshname[strlen(kshname) - 3], "/sh"))) {
		Flag(FSH) = 1;
		version_param = "SH_VERSION";
	}

	/* Set edit mode to emacs by default, may be overridden
	 * by the environment or the user.  Also, we want tab completion
	 * on in vi by default. */
#if defined(EDIT) && defined(EMACS)
	change_flag(FEMACS, OF_SPECIAL, 1);
#endif /* EDIT && EMACS */
#if defined(EDIT) && defined(VI)
	Flag(FVITABCOMPLETE) = 1;
#endif /* EDIT && VI */

	/* import environment */
	if (environ != NULL)
		for (wp = environ; *wp != NULL; wp++)
			typeset(*wp, IMPORT|EXPORT, 0, 0, 0);

	kshpid = procpid = getpid();
	typeset(initifs, 0, 0, 0, 0);	/* for security */

	/* assign default shell variable values */
	substitute(initsubs, 0);

	/* Figure out the current working directory and set $PWD */
	{
		struct stat s_pwd, s_dot;
		struct tbl *pwd_v = global("PWD");
		char *pwd = str_val(pwd_v);
		char *pwdx = pwd;

		/* Try to use existing $PWD if it is valid */
		if (pwd[0] != '/' ||
		    stat(pwd, &s_pwd) < 0 || stat(".", &s_dot) < 0 ||
		    s_pwd.st_dev != s_dot.st_dev ||
		    s_pwd.st_ino != s_dot.st_ino)
			pwdx = NULL;
		set_current_wd(pwdx);
		if (current_wd[0])
			simplify_path(current_wd);
		/* Only set pwd if we know where we are or if it had a
		 * bogus value
		 */
		if (current_wd[0] || pwd != null)
			/* setstr can't fail here */
			setstr(pwd_v, current_wd, KSH_RETURN_ERROR);
	}
	ppid = getppid();
	setint(global("PPID"), (long) ppid);
	/* setstr can't fail here */
	setstr(global(version_param), ksh_version, KSH_RETURN_ERROR);

	/* execute initialization statements */
	for (wp = (char**) initcoms; *wp != NULL; wp++) {
		shcomexec(wp);
		for (; *wp != NULL; wp++)
			;
	}


	ksheuid = geteuid();
	init_username();
	safe_prompt = ksheuid ? "$ " : "# ";
	{
		struct tbl *vp = global("PS1");

		/* Set PS1 if it isn't set, or we are root and prompt doesn't
		 * contain a # or \$ (only in ksh mode).
		 */
		if (!(vp->flag & ISSET) ||
		    (!ksheuid && !strchr(str_val(vp), '#') &&
		    (Flag(FSH) || !strstr(str_val(vp), "\\$"))))
			/* setstr can't fail here */
			setstr(vp, safe_prompt, KSH_RETURN_ERROR);
	}

	/* Set this before parsing arguments */
	Flag(FPRIVILEGED) = getuid() != ksheuid || getgid() != getegid();

	/* this to note if monitor is set on command line (see below) */
	Flag(FMONITOR) = 127;
	argi = parse_args(argv, OF_CMDLINE, NULL);
	if (argi < 0)
		exit(1);

	if (Flag(FCOMMAND)) {
		s = pushs(SSTRING, ATEMP);
		if (!(s->start = s->str = argv[argi++]))
			errorf("-c requires an argument");
		if (argv[argi])
			kshname = argv[argi++];
	} else if (argi < argc && !Flag(FSTDIN)) {
		s = pushs(SFILE, ATEMP);
		s->file = argv[argi++];
		s->u.shf = shf_open(s->file, O_RDONLY, 0, SHF_MAPHI|SHF_CLEXEC);
		if (s->u.shf == NULL) {
			exstat = 127; /* POSIX */
			errorf("%s: %s", s->file, strerror(errno));
		}
		kshname = s->file;
	} else {
		Flag(FSTDIN) = 1;
		s = pushs(SSTDIN, ATEMP);
		s->file = "<stdin>";
		s->u.shf = shf_fdopen(0, SHF_RD | can_seek(0), NULL);
		if (isatty(0) && isatty(2)) {
			Flag(FTALKING) = Flag(FTALKING_I) = 1;
			/* The following only if isatty(0) */
			s->flags |= SF_TTY;
			s->u.shf->flags |= SHF_INTERRUPT;
			s->file = NULL;
		}
	}

	/* This bizarreness is mandated by POSIX */
	{
		struct stat s_stdin;

		if (fstat(0, &s_stdin) >= 0 && S_ISCHR(s_stdin.st_mode) &&
		    Flag(FTALKING))
			reset_nonblock(0);
	}

	/* initialize job control */
	i = Flag(FMONITOR) != 127;
	Flag(FMONITOR) = 0;
	j_init(i);
#ifdef EDIT
	/* Do this after j_init(), as tty_fd is not initialized 'til then */
	if (Flag(FTALKING))
		x_init();
#endif

	l = genv->loc;
	l->argv = make_argv(argc - (argi - 1), &argv[argi - 1]);
	l->argc = argc - argi;
	getopts_reset(1);

	/* Disable during .profile/ENV reading */
	restricted = Flag(FRESTRICTED);
	Flag(FRESTRICTED) = 0;
	errexit = Flag(FERREXIT);
	Flag(FERREXIT) = 0;

	/* Do this before profile/$ENV so that if it causes problems in them,
	 * user will know why things broke.
	 */
	if (!current_wd[0] && Flag(FTALKING))
		warningf(false, "Cannot determine current working directory");

	if (Flag(FLOGIN)) {
		include(KSH_SYSTEM_PROFILE, 0, NULL, 1);
		if (!Flag(FPRIVILEGED))
			include(substitute("$HOME/.profile", 0), 0, NULL, 1);
	}

	if (Flag(FPRIVILEGED))
		include("/etc/suid_profile", 0, NULL, 1);
	else if (Flag(FTALKING)) {
		char *env_file;

		/* include $ENV */
		env_file = str_val(global("ENV"));

#ifdef DEFAULT_ENV
		/* If env isn't set, include default environment */
		if (env_file == null)
			env_file = DEFAULT_ENV;
#endif /* DEFAULT_ENV */
		env_file = substitute(env_file, DOTILDE);
		if (*env_file != '\0')
			include(env_file, 0, NULL, 1);
	}

	if (is_restricted(argv[0]) || is_restricted(str_val(global("SHELL"))))
		restricted = 1;
	if (restricted) {
		static const char *const restr_com[] = {
			"typeset", "-r", "PATH",
			"ENV", "SHELL",
			NULL
		};
		shcomexec((char **) restr_com);
		/* After typeset command... */
		Flag(FRESTRICTED) = 1;
	}
	if (errexit)
		Flag(FERREXIT) = 1;

	if (Flag(FTALKING)) {
		hist_init(s);
		alarm_init();
	} else
		Flag(FTRACKALL) = 1;	/* set after ENV */

	shell(s, true);	/* doesn't return */
	return 0;
}

static void
init_username(void)
{
	char *p;
	struct tbl *vp = global("USER");

	if (vp->flag & ISSET)
		p = ksheuid == 0 ? "root" : str_val(vp);
	else
		p = getlogin();

	strlcpy(username, p != NULL ? p : "?", sizeof username);
}

int
include(const char *name, int argc, char **argv, int intr_ok)
{
	Source *volatile s = NULL;
	struct shf *shf;
	char **volatile old_argv;
	volatile int old_argc;
	int i;

	shf = shf_open(name, O_RDONLY, 0, SHF_MAPHI|SHF_CLEXEC);
	if (shf == NULL)
		return -1;

	if (argv) {
		old_argv = genv->loc->argv;
		old_argc = genv->loc->argc;
	} else {
		old_argv = NULL;
		old_argc = 0;
	}
	newenv(E_INCL);
	i = sigsetjmp(genv->jbuf, 0);
	if (i) {
		quitenv(s ? s->u.shf : NULL);
		if (old_argv) {
			genv->loc->argv = old_argv;
			genv->loc->argc = old_argc;
		}
		switch (i) {
		case LRETURN:
		case LERROR:
			return exstat & 0xff; /* see below */
		case LINTR:
			/* intr_ok is set if we are including .profile or $ENV.
			 * If user ^C's out, we don't want to kill the shell...
			 */
			if (intr_ok && (exstat - 128) != SIGTERM)
				return 1;
			/* FALLTHROUGH */
		case LEXIT:
		case LLEAVE:
		case LSHELL:
			unwind(i);
			/* NOTREACHED */
		default:
			internal_errorf(1, "include: %d", i);
			/* NOTREACHED */
		}
	}
	if (argv) {
		genv->loc->argv = argv;
		genv->loc->argc = argc;
	}
	s = pushs(SFILE, ATEMP);
	s->u.shf = shf;
	s->file = str_save(name, ATEMP);
	i = shell(s, false);
	quitenv(s->u.shf);
	if (old_argv) {
		genv->loc->argv = old_argv;
		genv->loc->argc = old_argc;
	}
	return i & 0xff;	/* & 0xff to ensure value not -1 */
}

/*
 * spawn a command into a shell optionally keeping track of line
 * number.
 */
int
command(const char *comm, int line)
{
	Source *s;

	s = pushs(SSTRING, ATEMP);
	s->start = s->str = comm;
	s->line = line;
	return shell(s, false);
}

/*
 * run the commands from the input source, returning status.
 */
int
shell(Source *volatile s, volatile int toplevel)
{
	struct op *t;
	volatile int wastty = s->flags & SF_TTY;
	volatile int attempts = 13;
	volatile int interactive = Flag(FTALKING) && toplevel;
	Source *volatile old_source = source;
	int i;

	newenv(E_PARSE);
	if (interactive)
		really_exit = 0;
	i = sigsetjmp(genv->jbuf, 0);
	if (i) {
		switch (i) {
		case LINTR: /* we get here if SIGINT not caught or ignored */
		case LERROR:
		case LSHELL:
			if (interactive) {
				if (i == LINTR)
					shellf("\n");
				/* Reset any eof that was read as part of a
				 * multiline command.
				 */
				if (Flag(FIGNOREEOF) && s->type == SEOF &&
				    wastty)
					s->type = SSTDIN;
				/* Used by exit command to get back to
				 * top level shell.  Kind of strange since
				 * interactive is set if we are reading from
				 * a tty, but to have stopped jobs, one only
				 * needs FMONITOR set (not FTALKING/SF_TTY)...
				 */
				/* toss any input we have so far */
				s->start = s->str = null;
				break;
			}
			/* FALLTHROUGH */
		case LEXIT:
		case LLEAVE:
		case LRETURN:
			source = old_source;
			quitenv(NULL);
			unwind(i);	/* keep on going */
			/* NOTREACHED */
		default:
			source = old_source;
			quitenv(NULL);
			internal_errorf(1, "shell: %d", i);
			/* NOTREACHED */
		}
	}

	while (1) {
		if (trap)
			runtraps(0);

		if (s->next == NULL) {
			if (Flag(FVERBOSE))
				s->flags |= SF_ECHO;
			else
				s->flags &= ~SF_ECHO;
		}

		if (interactive) {
			got_sigwinch = 1;
			j_notify();
			mcheck();
			set_prompt(PS1, s);
		}

		t = compile(s);
		if (t != NULL && t->type == TEOF) {
			if (wastty && Flag(FIGNOREEOF) && --attempts > 0) {
				shellf("Use `exit' to leave ksh\n");
				s->type = SSTDIN;
			} else if (wastty && !really_exit &&
			    j_stopped_running()) {
				really_exit = 1;
				s->type = SSTDIN;
			} else {
				/* this for POSIX, which says EXIT traps
				 * shall be taken in the environment
				 * immediately after the last command
				 * executed.
				 */
				if (toplevel)
					unwind(LEXIT);
				break;
			}
		}

		if (t && (!Flag(FNOEXEC) || (s->flags & SF_TTY)))
			exstat = execute(t, 0, NULL);

		if (t != NULL && t->type != TEOF && interactive && really_exit)
			really_exit = 0;

		reclaim();
	}
	quitenv(NULL);
	source = old_source;
	return exstat;
}

/* return to closest error handler or shell(), exit if none found */
void
unwind(int i)
{
	/* ordering for EXIT vs ERR is a bit odd (this is what at&t ksh does) */
	if (i == LEXIT || (Flag(FERREXIT) && (i == LERROR || i == LINTR) &&
	    sigtraps[SIGEXIT_].trap)) {
		if (trap)
			runtraps(0);
		runtrap(&sigtraps[SIGEXIT_]);
		i = LLEAVE;
	} else if (Flag(FERREXIT) && (i == LERROR || i == LINTR)) {
		if (trap)
			runtraps(0);
		runtrap(&sigtraps[SIGERR_]);
		i = LLEAVE;
	}
	while (1) {
		switch (genv->type) {
		case E_PARSE:
		case E_FUNC:
		case E_INCL:
		case E_LOOP:
		case E_ERRH:
			siglongjmp(genv->jbuf, i);
			/* NOTREACHED */

		case E_NONE:
			if (i == LINTR)
				genv->flags |= EF_FAKE_SIGDIE;
			/* FALLTHROUGH */

		default:
			quitenv(NULL);
			/*
			 * quitenv() may have reclaimed the memory
			 * used by source which will end badly when
			 * we jump to a function that expects it to
			 * be valid
			 */
			source = NULL;
		}
	}
}

void
newenv(int type)
{
	struct env *ep;

	ep = alloc(sizeof(*ep), ATEMP);
	ep->type = type;
	ep->flags = 0;
	ainit(&ep->area);
	ep->loc = genv->loc;
	ep->savefd = NULL;
	ep->oenv = genv;
	ep->temps = NULL;
	genv = ep;
}

void
quitenv(struct shf *shf)
{
	struct env *ep = genv;
	int fd;

	if (ep->oenv && ep->oenv->loc != ep->loc)
		popblock();
	if (ep->savefd != NULL) {
		for (fd = 0; fd < NUFILE; fd++)
			/* if ep->savefd[fd] < 0, means fd was closed */
			if (ep->savefd[fd])
				restfd(fd, ep->savefd[fd]);
		if (ep->savefd[2]) /* Clear any write errors */
			shf_reopen(2, SHF_WR, shl_out);
	}

	/* Bottom of the stack.
	 * Either main shell is exiting or cleanup_parents_env() was called.
	 */
	if (ep->oenv == NULL) {
		if (ep->type == E_NONE) {	/* Main shell exiting? */
			if (Flag(FTALKING))
				hist_finish();
			j_exit();
			if (ep->flags & EF_FAKE_SIGDIE) {
				int sig = exstat - 128;

				/* ham up our death a bit (at&t ksh
				 * only seems to do this for SIGTERM)
				 * Don't do it for SIGQUIT, since we'd
				 * dump a core..
				 */
				if ((sig == SIGINT || sig == SIGTERM) &&
				    getpgrp() == kshpid) {
					setsig(&sigtraps[sig], SIG_DFL,
					    SS_RESTORE_CURR|SS_FORCE);
					kill(0, sig);
				}
			}
		}
		if (shf)
			shf_close(shf);
		reclaim();
		exit(exstat);
	}
	if (shf)
		shf_close(shf);
	reclaim();

	genv = genv->oenv;
	afree(ep, ATEMP);
}

/* Called after a fork to cleanup stuff left over from parents environment */
void
cleanup_parents_env(void)
{
	struct env *ep;
	int fd;

	/* Don't clean up temporary files - parent will probably need them.
	 * Also, can't easily reclaim memory since variables, etc. could be
	 * anywhere.
	 */

	/* close all file descriptors hiding in savefd */
	for (ep = genv; ep; ep = ep->oenv) {
		if (ep->savefd) {
			for (fd = 0; fd < NUFILE; fd++)
				if (ep->savefd[fd] > 0)
					close(ep->savefd[fd]);
			afree(ep->savefd, &ep->area);
			ep->savefd = NULL;
		}
	}
	genv->oenv = NULL;
}

/* Called just before an execve cleanup stuff temporary files */
void
cleanup_proc_env(void)
{
	struct env *ep;

	for (ep = genv; ep; ep = ep->oenv)
		remove_temps(ep->temps);
}

/* remove temp files and free ATEMP Area */
static void
reclaim(void)
{
	remove_temps(genv->temps);
	genv->temps = NULL;
	afreeall(&genv->area);
}

static void
remove_temps(struct temp *tp)
{

	for (; tp != NULL; tp = tp->next)
		if (tp->pid == procpid) {
			unlink(tp->name);
		}
}

/* Returns true if name refers to a restricted shell */
static int
is_restricted(char *name)
{
	char *p;

	if ((p = strrchr(name, '/')))
		name = p + 1;
	/* accepts rsh, rksh, rpdksh, pdrksh */
	if (strcmp(name, "rsh") && \
		strcmp(name, "rksh") && \
		strcmp(name, "rpdksh") && \
		strcmp(name, "pdrksh"))
		return(0);
	else
		return(1);

}
@


1.81
log
@Partial UTF-8 line editing support for ksh(1) vi input mode;
so far, it covers these commands: a h i l x /
This is an isu8cont()-based hack similar in style to what i did
in emacs input mode, but less elegant and slightly more intrusive
because the vi mode code is much more ugly and less straightforward
than the emacs mode code.  This one required partial rewrites of
a few helper functions, and comments were added while there.

This is not perfect, but hopefully reduces people's cursing
until a more rigorous solution can be devised (much) later.
Some polishing may be useful in tree, in particular adding
utf8cont() support to a few missing commands.

Mostly written shortly after Christmas 2015.
Reminded by and OK czarkoff@@.
Feedback, partial review and testing, no longer any objection by martijn@@.
Feedback and testing by tb@@.
Also read fine to nicm@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.80 2016/09/08 15:51:54 millert Exp $	*/
a10 1
#include <locale.h>
a153 2

	setlocale(LC_CTYPE, "");
@


1.80
log
@Mark PPID read-only as per the manual.  From Anthony Coulter.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.79 2016/03/04 15:11:06 deraadt Exp $	*/
d11 1
d155 2
@


1.79
log
@remove CSRG BSD-licensed mknod builtin code which was previously used to
accelerate install/upgrade time MAKEDEV runs.  That allows ramdisk ksh
to be pledged, without needing "dpath".  We'll solve the performance issues
a different way (soon).
ok otto espie natano tb tobiasu rpe
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.78 2015/12/30 09:07:00 tedu Exp $	*/
d87 1
a87 1
	"typeset", "-i", "PPID", NULL,
@


1.78
log
@rename global "e" to genv to avoid accidental shadowing and aliasing.
ok millert nicm tb
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.77 2015/12/27 19:33:26 jca Exp $	*/
a154 1
#ifndef MKNOD
a159 1
#endif
@


1.77
log
@Tweak comment: we now always make a copy of argv.

ok halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.76 2015/12/27 09:24:00 halex Exp $	*/
d41 1
a41 1
struct env	*e;
d169 1
a169 1
	e = &env;
d385 1
a385 1
	l = e->loc;
d479 2
a480 2
		old_argv = e->loc->argv;
		old_argc = e->loc->argc;
d486 1
a486 1
	i = sigsetjmp(e->jbuf, 0);
d490 2
a491 2
			e->loc->argv = old_argv;
			e->loc->argc = old_argc;
d515 2
a516 2
		e->loc->argv = argv;
		e->loc->argc = argc;
d524 2
a525 2
		e->loc->argv = old_argv;
		e->loc->argc = old_argc;
d561 1
a561 1
	i = sigsetjmp(e->jbuf, 0);
d672 1
a672 1
		switch (e->type) {
d678 1
a678 1
			siglongjmp(e->jbuf, i);
d683 1
a683 1
				e->flags |= EF_FAKE_SIGDIE;
d708 1
a708 1
	ep->loc = e->loc;
d710 1
a710 1
	ep->oenv = e;
d712 1
a712 1
	e = ep;
d718 1
a718 1
	struct env *ep = e;
d765 1
a765 1
	e = e->oenv;
d782 1
a782 1
	for (ep = e; ep; ep = ep->oenv) {
d791 1
a791 1
	e->oenv = NULL;
d800 1
a800 1
	for (ep = e; ep; ep = ep->oenv)
d808 3
a810 3
	remove_temps(e->temps);
	e->temps = NULL;
	afreeall(&e->area);
@


1.76
log
@unconditionally duplicate the argv array on initialization, to make it
resilient against being altered by a subsequent shift operation

tweak and ok semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.75 2015/12/14 13:59:42 tb Exp $	*/
d123 2
a124 2
 * If we need to alter argv, allocate a new array first since
 * modifying the original argv will modify ps output.
@


1.75
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.74 2015/11/11 02:52:46 deraadt Exp $	*/
d130 1
a130 1
	char **nargv = argv;
d132 5
a136 7
	if (strcmp(argv[0], kshname) != 0) {
		nargv = areallocarray(NULL, argc + 1, sizeof(char *), &aperm);
		nargv[0] = (char *) kshname;
		for (i = 1; i < argc; i++)
			nargv[i] = argv[i];
		nargv[i] = NULL;
	}
@


1.74
log
@exit() after perror() for pledge failure.  Perhaps this got introduced
as a test idiom, either when pledge was young or during the transition
to strings.... dunno
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.73 2015/11/01 15:38:53 mmcc Exp $	*/
d9 2
d13 2
d16 1
@


1.73
log
@Add uses of areallocarray(). mksh and Bitrig ksh already have similar
functions. With help from Theo Buehler.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.72 2015/10/30 03:13:52 guenther Exp $	*/
d154 1
a154 1
	    NULL) == -1)
d156 2
@


1.72
log
@'fc -e -' is deprecated in favor of 'fc -s', so update the built-in alias

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.71 2015/10/22 15:37:04 mmcc Exp $	*/
d128 1
a128 1
		nargv = alloc(sizeof(char *) * (argc + 1), &aperm);
@


1.71
log
@Final removal of EXTERN.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.70 2015/10/21 14:30:43 mmcc Exp $	*/
d100 1
a100 1
	  "r=fc -e -",
@


1.70
log
@Penultimate commit to remove EXTERN.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.69 2015/10/19 14:42:16 mmcc Exp $	*/
a6 2
#define	EXTERN				/* define EXTERNs in sh.h */

d57 13
@


1.69
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.68 2015/10/19 14:01:37 mmcc Exp $	*/
d41 18
@


1.68
log
@More removal of EXTERN.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.67 2015/10/19 02:15:45 mmcc Exp $	*/
d13 1
@


1.67
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.66 2015/10/18 18:05:35 mmcc Exp $	*/
d34 6
@


1.66
log
@Move more EXTERN-defined globals from sh.h.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.65 2015/10/17 18:26:24 mmcc Exp $	*/
a8 1
#include "sh.h"
d10 2
d13 2
a14 1
#include <paths.h>
@


1.65
log
@Move a system header include from the global header (sh.h) into the
files that need it. No binary change.

"This looks fine" -nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.64 2015/10/16 14:45:16 deraadt Exp $	*/
d24 8
@


1.64
log
@wrap a long line
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.63 2015/10/16 13:37:43 millert Exp $	*/
d12 1
@


1.63
log
@Implement real "flock" request and add it to userland programs that
use pledge and file locking.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.62 2015/10/10 20:35:00 deraadt Exp $	*/
d106 2
a107 1
	if (pledge("stdio rpath wpath cpath fattr flock getpw proc exec tty", NULL) == -1)
@


1.62
log
@normalize a few more tame request orderings, to help review
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.61 2015/10/10 00:10:07 deraadt Exp $	*/
d106 1
a106 1
	if (pledge("stdio rpath wpath cpath fattr getpw proc exec tty", NULL) == -1)
@


1.61
log
@ksh can run with pledge "stdio rpath wpath cpath getpw fattr proc exec tty"
if the mknod builtin is disabled.  It looks like a lot of abilities, but
hey, this is a shell.  can't open sockets or do other nasty stuff though.
(we'll leave the mknod builtin enabled on the install media for now; there
is work happening to regain the MAKEDEV performance in a different way)
discussions with otto & millert in particular
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.60 2015/09/18 07:28:24 nicm Exp $	*/
d106 1
a106 1
	if (pledge("stdio rpath wpath cpath getpw fattr proc exec tty", NULL) == -1)
@


1.60
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.59 2015/09/17 14:21:33 nicm Exp $	*/
d104 5
@


1.59
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.58 2015/09/15 18:15:05 tedu Exp $	*/
d275 1
a275 1
	argi = parse_args(argv, OF_CMDLINE, (int *) 0);
d298 1
a298 2
		s->u.shf = shf_fdopen(0, SHF_RD | can_seek(0),
		    (struct shf *) 0);
d345 1
a345 1
		include(KSH_SYSTEM_PROFILE, 0, (char **) 0, 1);
d347 1
a347 2
			include(substitute("$HOME/.profile", 0), 0,
			    (char **) 0, 1);
d351 1
a351 1
		include("/etc/suid_profile", 0, (char **) 0, 1);
d365 1
a365 1
			include(env_file, 0, (char **) 0, 1);
d424 1
a424 1
		old_argv = (char **) 0;
d730 1
a730 1
			ep->savefd = (short *) 0;
d733 1
a733 1
	e->oenv = (struct env *) 0;
@


1.58
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.57 2015/09/10 22:48:58 nicm Exp $	*/
d648 1
a648 1
	ep = (struct env *) alloc(sizeof(*ep), ATEMP);
@


1.57
log
@Replace newline and space defines by "\n" and " " directly, from Michael
McConville. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.56 2015/09/01 17:46:31 tedu Exp $	*/
d144 1
a144 1
		size_t len = confstr(_CS_PATH, (char *) 0, 0);
d230 1
a230 1
			pwdx = (char *) 0;
d305 1
a305 1
			s->file = (char *) 0;
d376 1
a376 1
			(char *) 0
@


1.56
log
@no need to check for null argv anymore. from Martijn van Duren
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.55 2015/02/09 09:09:30 jsg Exp $	*/
d513 1
a513 1
					shellf(newline);
@


1.55
log
@If we hit multiple errors while unwinding we'll end up running code that
assumes a pointer is valid when it has been free'd.

This is convoluted as ksh has it's own allocator and uses long jumps.
Set the pointer to NULL after the quitenv() call in unwind() in case we
later hit a long jump in unwind().

Found with afl a while back.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.54 2013/11/28 10:33:37 sobrado Exp $	*/
d103 1
a103 10
	/* make sure argv[] is sane */
	if (!*argv) {
		static const char *empty_argv[] = {
			"ksh", (char *) 0
		};

		argv = (char **) empty_argv;
		argc = 1;
	}
	kshname = *argv;
@


1.54
log
@remove trailing whitespaces; use tabs instead of spaces where appropriate;
no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.53 2013/09/04 15:49:19 millert Exp $	*/
d641 7
@


1.53
log
@Add a proper suspend builtin that saves/restores the tty and pgrp
as needed instead of an alias that just sends SIGSTOP.  Login shells
may be suspended if they are not running in an orphan process group.
OK guenther@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.52 2013/06/15 17:25:19 millert Exp $	*/
d71 1
a71 1
 * If we need to alter argv, allocate a new array first since 
@


1.52
log
@Run any pending traps before calling the EXIT or ERR traps when -e
is set.  Fixes a bug where we would not run the signal trap if,
for example, ^C was pressed and -e was set.  OK espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.51 2012/09/10 01:25:30 tedu Exp $	*/
a43 1
	  "suspend=kill -STOP $$",
@


1.51
log
@fake a sigwinch after each job, so if the terminal changes size,
we'll notice and update
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.50 2012/09/06 18:04:34 millert Exp $	*/
d615 2
d620 2
@


1.50
log
@Avoid modifying argv when building argv for $* and $@@ since it will
affect ps output.  This can happen when command line options are
specified, e.g. "sh -c command".  Based on a diff from espie@@
OK espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.49 2012/09/05 22:20:25 espie Exp $	*/
d568 1
@


1.49
log
@backout, Todd's version may be cleaner, but it's also wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47 2011/09/07 11:33:25 otto Exp $	*/
d70 22
d339 1
a339 1
	l->argv = &argv[argi - 1];
a340 1
	l->argv[0] = (char *) kshname;
@


1.48
log
@sh -c should not munge argv[].
This fixes ps -ww output.

joint work by millert@@ and me@@.

okay otto@@, deraadt@@ "feel free to commit my version" millert@@
@
text
@a69 17
/* modifying argv will modify ps output, so sh -c needs to copy part of it 
 * to be able to parse further options
 */
static char **
copy_argv(int argc, char *argv[])
{
	int i;
	char **nargv;

	nargv = alloc(sizeof(char *) * (argc + 1), &aperm);
	nargv[0] = (char *) kshname;
	for (i = 1; i < argc; i++)
		nargv[i] = argv[i];
	nargv[i] = NULL;
	return nargv;
}

d317 1
d319 1
a319 1
	l->argv = copy_argv(l->argc, &argv[argi - 1]);
@


1.47
log
@beter determination if the shell is restricted; from Alf Schlichting.
ok jasper@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.46 2010/05/19 17:36:08 jasper Exp $	*/
d70 17
a333 1
	l->argv = &argv[argi - 1];
d335 1
a335 1
	l->argv[0] = (char *) kshname;
@


1.46
log
@properly keep track of the line number after a trap.
this fixes pr 6195. diff from manuel giraud, thanks.

ok kili@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.45 2009/01/29 23:27:26 jaredy Exp $	*/
d751 10
a760 3
		name = p;
	/* accepts rsh, rksh, rpdksh, pdrksh, etc. */
	return (p = strchr(name, 'r')) && strstr(p, "sh");
@


1.45
log
@pass "xerrok" status across the execution call stack to more closely
match what both POSIX and ksh.1 already describe in regards to set
-e/errexit's behavior in determining when to exit from nonzero return
values.

specifically, the truth values tested as operands to `&&' and `||', as
well as the resulting compound expression itself, along with the truth
value resulting from a negated command (i.e. a pipeline prefixed `!'),
should not make the shell exit when -e is in effect.

issue reported by matthieu.
testing matthieu, naddy.
ok miod (earlier version), otto.
man page ok jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.44 2008/07/05 07:25:18 djm Exp $	*/
d463 4
d468 1
a468 1
command(const char *comm)
d474 1
@


1.44
log
@ksh starting as root will refuse to import a PS1 prompt unless it
contains a '#' character. Make it also accept the \$ PS1 sequence
(which is supposed to automagically be $ or # depending on the user
running the shell) unless ksh has been started in sh-compatibility
mode.

pointed out by millert@@ when I asked why my SUDO_PS1 was not being
honoured; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.43 2007/05/31 20:47:44 otto Exp $	*/
d569 1
a569 1
			exstat = execute(t, 0);
@


1.43
log
@Only process ENV when in interactive mode as SU says. Started by
tedu to fix make -j, SU thing spotted by naddy@@; ok millert@@ @@tedu
jmc@@ for the man page bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.42 2006/11/02 18:21:20 ray Exp $	*/
d249 1
a249 1
		 * contain a #.
d252 2
a253 1
		    (!ksheuid && !strchr(str_val(vp), '#')))
@


1.42
log
@Only check if last three letters are "/sh" if string is at least
three characters long.

OK moritz@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.41 2006/04/10 14:38:59 jaredy Exp $	*/
d342 1
a342 1
	else {
@


1.41
log
@fix lint comments, no functional changes; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.40 2005/12/11 20:31:21 otto Exp $	*/
d178 3
a180 2
	if (!strcmp(&kshname[strlen(kshname) - 3], "/sh") ||
	    !strcmp(kshname, "sh") || !strcmp(kshname, "-sh")) {
@


1.40
log
@fix a few name clashes with libc; found by lint. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.39 2005/12/11 18:53:51 deraadt Exp $	*/
d434 1
a434 1
			/* fall through... */
d439 1
a439 1
			/*NOREACHED*/
d442 1
a442 1
			/*NOREACHED*/
d512 1
a512 1
			/* fall through... */
d519 1
a519 1
			/*NOREACHED*/
d524 1
a524 1
			/*NOREACHED*/
d600 1
a600 1
			/*NOTREACHED*/
d605 1
a605 1
			/* Fall through... */
@


1.39
log
@remove unused variables and functions
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.38 2005/03/30 17:16:37 deraadt Exp $	*/
d114 3
a116 3
	tinit(&taliases, APERM, 0);
	tinit(&aliases, APERM, 0);
	tinit(&homedirs, APERM, 0);
d122 1
a122 1
	tinit(&builtins, APERM, 64); /* must be 2^n (currently 40 builtins) */
@


1.38
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 2005/03/28 21:33:01 deraadt Exp $	*/
a746 8
}

void
aerror(Area *ap, const char *msg)
{
	internal_errorf(1, "alloc: %s", msg);
	errorf(null); /* this is never executed - keeps gcc quiet */
	/*NOTREACHED*/
@


1.37
log
@if argv[0] not set, do not set it to "pdksh", but to "ksh"
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.36 2005/02/21 16:01:58 otto Exp $	*/
d178 2
a179 2
	if (!strcmp(&kshname[strlen(kshname) - 3], "/sh")
	    || !strcmp(kshname, "sh") || !strcmp(kshname, "-sh")) {
d213 4
a216 4
		if (pwd[0] != '/'
		    || stat(pwd, &s_pwd) < 0 || stat(".", &s_dot) < 0
		    || s_pwd.st_dev != s_dot.st_dev
		    || s_pwd.st_ino != s_dot.st_ino)
d250 2
a251 2
		if (!(vp->flag & ISSET)
		    || (!ksheuid && !strchr(str_val(vp), '#')))
d285 1
a285 1
				      (struct shf *) 0);
d336 1
a336 1
				(char **) 0, 1);
d344 2
a345 2
			/* include $ENV */
			env_file = str_val(global("ENV"));
d361 4
a364 4
						"typeset", "-r", "PATH",
						    "ENV", "SHELL",
						(char *) 0
					    };
d425 2
a426 2
		  case LRETURN:
		  case LERROR:
d428 1
a428 1
		  case LINTR:
d435 3
a437 3
		  case LEXIT:
		  case LLEAVE:
		  case LSHELL:
d440 1
a440 1
		  default:
d490 3
a492 3
		  case LINTR: /* we get here if SIGINT not caught or ignored */
		  case LERROR:
		  case LSHELL:
d499 2
a500 2
				if (Flag(FIGNOREEOF) && s->type == SEOF
				    && wastty)
d513 3
a515 3
		  case LEXIT:
		  case LLEAVE:
		  case LRETURN:
d520 1
a520 1
		  default:
d550 2
a551 3
			} else if (wastty && !really_exit
				   && j_stopped_running())
			{
d584 2
a585 3
	if (i == LEXIT || (Flag(FERREXIT) && (i == LERROR || i == LINTR)
			   && sigtraps[SIGEXIT_].trap))
	{
d594 5
a598 5
		  case E_PARSE:
		  case E_FUNC:
		  case E_INCL:
		  case E_LOOP:
		  case E_ERRH:
d602 1
a602 1
		  case E_NONE:
d607 1
a607 1
		  default:
d665 1
a665 1
						SS_RESTORE_CURR|SS_FORCE);
@


1.36
log
@Set \u in prompt expansion to the right value, while avoiding getpw* calls,
which might be very inconvenient when the yp server is not available.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.35 2004/12/22 18:57:28 otto Exp $	*/
d84 3
a86 3
		static const char	*empty_argv[] = {
					    "pdksh", (char *) 0
					};
@


1.35
log
@Fix a use-after-free, that causs core dumps if a shell is killed
running with strict malloc.conf options. Problem spotted by hshoexer@@;
fix by me with some help from millert@@.

ok millert@@ hshoexer@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2004/12/22 17:14:34 millert Exp $	*/
d11 1
d22 1
d66 2
d242 1
d380 14
@


1.34
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 2004/12/20 11:34:26 otto Exp $	*/
d400 1
a400 3
		if (s) /* Do this before quitenv(), which frees the memory */
			shf_close(s->u.shf);
		quitenv();
d434 1
a434 2
	shf_close(s->u.shf);
	quitenv();
d498 1
a498 1
			quitenv();
d503 1
a503 1
			quitenv();
d556 1
a556 1
	quitenv();
d591 1
a591 1
			quitenv();
d613 1
a613 1
quitenv(void)
a627 1
	reclaim();
d653 3
d658 3
@


1.33
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2004/12/18 21:25:44 millert Exp $	*/
d325 1
a325 1
		warningf(FALSE, "Cannot determine current working directory");
d373 1
a373 1
	shell(s, TRUE);	/* doesn't return */
d435 1
a435 1
	i = shell(s, FALSE);
d452 1
a452 1
	return shell(s, FALSE);
@


1.32
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2004/12/18 21:08:44 millert Exp $	*/
d378 1
a378 5
include(name, argc, argv, intr_ok)
	const char *name;
	int argc;
	char **argv;
	int intr_ok;
d446 1
a446 2
command(comm)
	const char *comm;
d459 1
a459 3
shell(s, toplevel)
	Source *volatile s;		/* input source */
	int volatile toplevel;
d566 1
a566 2
unwind(i)
	int i;
d600 1
a600 2
newenv(type)
	int type;
d616 1
a616 1
quitenv()
d666 1
a666 1
cleanup_parents_env()
d691 1
a691 1
cleanup_proc_env()
d701 1
a701 1
reclaim()
d709 1
a709 2
remove_temps(tp)
	struct temp *tp;
d720 1
a720 2
is_restricted(name)
	char *name;
d731 1
a731 3
aerror(ap, msg)
	Area *ap;
	const char *msg;
@


1.31
log
@When invoked as sh set SH_VERSION, not KSH_VERSION like the man page says.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2004/12/18 21:04:52 millert Exp $	*/
d69 1
a69 1
	register int i;
d384 1
a384 1
	register Source *volatile s = NULL;
d453 1
a453 1
	register Source *s;
d611 1
a611 1
	register struct env *ep;
d627 2
a628 2
	register struct env *ep = e;
	register int fd;
@


1.30
log
@Get rid of #ifdef KSH since we don't care about building a V7 style sh and
the #ifdef KSH code is required to make a POSIX sh.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2004/12/18 20:55:52 millert Exp $	*/
d30 2
a31 3
static const char version_param[] = "KSH_VERSION";

static const char *const initcoms [] = {
a32 1
	"typeset", "-r", version_param, NULL,
d64 2
d175 1
a175 1
	    || !strcmp(kshname, "sh") || !strcmp(kshname, "-sh"))
d177 2
@


1.29
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2004/08/23 14:56:32 millert Exp $	*/
d30 1
a30 7
static const char version_param[] =
#ifdef KSH
	"KSH_VERSION"
#else /* KSH */
	"SH_VERSION"
#endif /* KSH */
	;
a36 1
#ifdef KSH
a37 1
#endif /* KSH */
a45 1
#ifdef KSH
d48 1
a48 1
# ifdef HISTORY
d50 1
a50 1
# endif /* HISTORY */
a54 2
#endif /* KSH */
#ifdef KSH
a56 1
#endif /* KSH */
a106 1
#ifdef KSH
a107 1
#endif /* KSH */
a336 5
#ifndef KSH
		if (!Flag(FPOSIX))
			env_file = null;
		else
#endif /* !KSH */
a366 1
#ifdef KSH
a367 1
#endif /* KSH */
a529 1
#ifdef KSH
a530 1
#endif /* KSH */
@


1.28
log
@Don't send SIGINT or SIGTERM to the entire processes group when the
shell receives SIGINT/SIGTERM unless the shell is the process group
leader.  Fixes PR 3820.  OK danh@@ sturm@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 2004/06/07 23:20:46 deraadt Exp $	*/
d10 1
a10 2
#include "ksh_stat.h"
#include "ksh_time.h"
d18 3
a20 3
static void	reclaim ARGS((void));
static void	remove_temps ARGS((struct temp *tp));
static int	is_restricted ARGS((char *name));
a67 3
#ifndef __OpenBSD__
	  "newgrp=exec newgrp",
#endif /* __OpenBSD__ */
a74 3
#ifdef EXTRA_INITCOMS
	EXTRA_INITCOMS, NULL,
#endif /* EXTRA_INITCOMS */
a89 10
#ifdef MEM_DEBUG
	chmem_set_defaults("ct", 1);
	/* chmem_push("+c", 1); */
#endif /* MEM_DEBUG */

#ifdef OS2
	setmode (0, O_BINARY);
	setmode (1, O_TEXT);
#endif

d140 1
a140 2
	def_path = DEFAULT__PATH;
#if defined(HAVE_CONFSTR) && defined(_CS_PATH)
a149 1
#endif /* HAVE_CONFSTR && _CS_PATH */
d221 1
a221 1
		if (!ISABSPATH(pwd)
a237 3
#if defined(KSH) && !defined(__OpenBSD__)
	setint(global("RANDOM"), (long) (time((time_t *)0) * kshpid * ppid));
#endif /* KSH */
a279 10
#ifdef OS2
		/* a bug in os2 extproc shell processing doesn't
		 * pass full pathnames so we have to search for it.
		 * This changes the behavior of 'ksh arg' to search
		 * the users search path but it can't be helped.
		 */
		s->file = search(argv[argi++], path, R_OK, (int *) 0);
		if (!s->file || !*s->file)
		        s->file = argv[argi - 1];
#else
a280 1
#endif /* OS2 */
a339 16
#ifdef OS2
		char *profile;

		/* Try to find a profile - first see if $INIT has a value,
		 * then try /etc/profile.ksh, then c:/usr/etc/profile.ksh.
		 */
		if (!Flag(FPRIVILEGED)
		    && strcmp(profile = substitute("$INIT/profile.ksh", 0),
			      "/profile.ksh"))
			include(profile, 0, (char **) 0, 1);
		else if (include("/etc/profile.ksh", 0, (char **) 0, 1) < 0)
			include("c:/usr/etc/profile.ksh", 0, (char **) 0, 1);
		if (!Flag(FPRIVILEGED))
			include(substitute("$HOME/profile.ksh", 0), 0,
				(char **) 0, 1);
#else /* OS2 */
a343 1
#endif /* OS2 */
a366 5
#ifdef OS2
		else if (Flag(FTALKING))
			include(substitute("$HOME/kshrc.ksh", 0), 0,
				(char **) 0, 1);
#endif /* OS2 */
d421 1
a421 1
	i = ksh_sigsetjmp(e->jbuf, 0);
d497 1
a497 1
	i = ksh_sigsetjmp(e->jbuf, 0);
d614 1
a614 1
			ksh_siglongjmp(e->jbuf, i);
a685 3
#ifdef MEM_DEBUG
			chmem_allfree();
#endif /* MEM_DEBUG */
a741 14
#ifdef OS2
	static struct temp *delayed_remove;
	struct temp *t, **tprev;

	if (delayed_remove) {
		for (tprev = &delayed_remove, t = delayed_remove; t; t = *tprev)
			/* No need to check t->pid here... */
			if (unlink(t->name) >= 0 || errno == ENOENT) {
				*tprev = t->next;
				afree(t, APERM);
			} else
				tprev = &t->next;
	}
#endif /* OS2 */
a744 19
#ifdef OS2
			/* OS/2 (and dos) do not allow files that are currently
			 * open to be removed, so we cache it away for future
			 * removal.
			 * XXX should only do this if errno
			 *     is Efile-still-open-can't-remove
			 *     (but I don't know what that is...)
			 */
			if (unlink(tp->name) < 0 && errno != ENOENT) {
				t = (struct temp *) alloc(
				    sizeof(struct temp) + strlen(tp->name) + 1,
				    APERM);
				memset(t, 0, sizeof(struct temp));
				t->name = (char *) &t[1];
				strlcpy(t->name, tp->name, strlen(tp->name) + 1);
				t->next = delayed_remove;
				delayed_remove = t;
			}
#else /* OS2 */
a745 1
#endif /* OS2 */
d756 1
a756 1
	if ((p = ksh_strrchr_dirsep(name)))
@


1.27
log
@do not push ksh into stupid-random mode; leave it in arc4random() mode.
oops.  spotted by weerd@@weirdnet.nl
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 2004/01/08 05:43:14 jmc Exp $	*/
d734 2
a735 1
				if (sig == SIGINT || sig == SIGTERM) {
@


1.26
log
@typo; from ray at cyth dot net (PR 3632);
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2003/06/26 00:09:45 deraadt Exp $	*/
d257 1
a257 1
#ifdef KSH
@


1.25
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2003/04/04 23:12:02 deraadt Exp $	*/
d180 1
a180 1
	/* Turn on nohup by default for how - will change to off
@


1.24
log
@two fixes; help from tedu & tdeval
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2003/03/10 03:48:16 david Exp $	*/
d86 1
a86 3
main(argc, argv)
	int argc;
	register char **argv;
@


1.23
log
@spelling fixes
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2003/02/28 09:45:09 jmc Exp $	*/
d832 1
a832 1
				strcpy(t->name, tp->name);
@


1.22
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2002/06/09 05:47:27 todd Exp $	*/
d183 1
a183 1
	 * by default once people are aware of its existance
@


1.21
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2000/12/19 21:48:54 markus Exp $	*/
d762 1
a762 1
	 * anywyere.
@


1.20
log
@do not reset nonblock if shell is not interactive, from crossd@@cs.rpi.edu
(i should have commited this about 6 months ago, ok millert@@).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 1999/11/14 18:18:39 millert Exp $	*/
d342 1
a342 1
		    Flag(FTALKING))     
@


1.19
log
@Better fix for PR #921 (main.c rev 1.18) from the pdksh cvs tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 1999/11/14 17:56:47 millert Exp $	*/
d341 2
a342 1
		if (fstat(0, &s_stdin) >= 0 && S_ISCHR(s_stdin.st_mode))
@


1.18
log
@Fix a core dump caused by a signal race; yval@@hackers.co.il
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 1999/08/04 19:11:13 millert Exp $	*/
a459 1
	Source *volatile sold;
a475 1
	sold = source;
a478 1
		source = sold;
a514 1
	source = sold;
a528 2
	Source *volatile sold;
	int i;
d532 1
a532 4
	sold = source;
	i = shell(s, FALSE);
	source = sold;
	return i;
d547 1
a554 1
		s->start = s->str = null;
d574 2
d582 1
d587 1
d644 1
@


1.17
log
@Turn <tab> completion on by default for people used to bash, tcsh, etc...
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 1999/07/15 20:39:40 millert Exp $	*/
d533 2
d538 4
a541 1
	return shell(s, FALSE);
@


1.16
log
@o Set default line edit mode to emacs (VISUAL/EDITOR or user can override)
o Spell environment correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 1999/06/15 01:18:35 millert Exp $	*/
d214 2
a215 1
	 * by the environment or the user. */
d219 3
@


1.15
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 1999/04/27 18:18:19 millert Exp $	*/
d4 1
a4 1
 * startup, main loop, enviroments and error handling
d122 1
a122 1
	/* set up base enviroment */
d213 7
a219 1
	/* import enviroment */
@


1.14
log
@disable newgrp alias since OpenBSD doesn't have a newgrp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 1999/01/10 17:55:03 millert Exp $	*/
d27 1
a27 1
static const char	initifs [] = "IFS= \t\n"; /* must be R/W */
d29 1
a29 2
static const	char   initsubs [] = 
  "${PS2=> } ${PS3=#? } ${PS4=+ }";
a38 12
/*
MAILCHECK:
    typeset -i MAILCHECK
    : "${MAILCHECK=600}"
SECONDS:
    typeset -i SECONDS
    initialize seconds to $SECONDS
TMOUT:
    typeset -i
    do setspec
*/

d43 1
a43 1
	"typeset", "-i", "OPTIND=1",
d45 1
a45 1
	    "MAILCHECK=600", "RANDOM", "SECONDS=0", "TMOUT=0",
a46 1
	    NULL,
d177 2
a178 2
		/* SETSTR: can't fail */
		setstr(vp, def_path);
d244 2
a245 2
			/* SETSTR: can't fail */
			setstr(pwd_v, current_wd);
d252 2
a253 2
	/* SETSTR: can't fail */
	setstr(global(version_param), ksh_version);
d273 2
a274 2
			/* SETSTR: can't fail */
			setstr(vp, safe_prompt);
d662 4
a665 26
		  case E_NONE: 	/* bottom of the stack */
		  {
			if (Flag(FTALKING))
				hist_finish();
			j_exit();
			remove_temps(func_heredocs);
			if (i == LINTR) {
				int sig = exstat - 128;

				/* ham up our death a bit (at&t ksh
				 * only seems to do this for SIGTERM)
				 * Don't do it for SIGQUIT, since we'd
				 * dump a core..
				 */
				if (sig == SIGINT || sig == SIGTERM) {
					setsig(&sigtraps[sig], SIG_DFL,
						SS_RESTORE_CURR|SS_FORCE);
					kill(0, sig);
				}
			}
#ifdef MEM_DEBUG
			chmem_allfree();
#endif /* MEM_DEBUG */
			exit(exstat);
			/* NOTREACHED */
		  }
d696 1
a696 3
	if (ep->oenv == NULL) /* cleanup_parents_env() was called */
		exit(exstat);	/* exit child */
	if (ep->oenv->loc != ep->loc)
d707 30
d755 1
a755 1
		if (ep->savefd)
d759 3
a773 1
	remove_temps(func_heredocs);
@


1.13
log
@sync with pdksh-unstable-5.2.13.6
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 1999/01/08 20:25:00 millert Exp $	*/
d83 1
d85 1
@


1.12
log
@bug fixes from pdksh-unstable-5.2.13.5; some of which we already had.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 1998/10/29 04:09:21 millert Exp $	*/
d189 1
d256 1
d264 1
d285 1
d600 1
a600 1
		if (s->next == NULL)
d605 1
@


1.11
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 1998/06/25 19:02:10 millert Exp $	*/
d40 12
d55 1
a55 1
	"typeset", "-ri", "PPID", NULL,
d109 1
d257 2
a258 1
	setint(global("PPID"), (long) getppid());
d260 1
a260 1
	setint(global("RANDOM"), (long) time((time_t *)0));
a612 2
				shellf("pgrp=%d, ttypgrp=%d\n",
					getpgrp(), tcgetpgrp(0));
@


1.10
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 1997/09/12 00:32:53 deraadt Exp $	*/
d599 2
@


1.9
log
@do not quitenv() too early, or "s" goes away due to it's temporary nature;
fix found in freebsd ports tree.. original by ejc@@bazzle.com
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1997/09/01 18:30:09 deraadt Exp $	*/
d29 1
a29 1
static const	char   initsubs [] =
d94 1
a94 1
	int restricted;
a96 1
	int euid;
d99 3
a101 3
	chmem_push("+c", 1);
	/*chmem_push("+cd", 1);*/
#endif
d170 8
a177 1
	path = def_path;
d257 3
a259 2
	euid = geteuid();
	safe_prompt = euid ? "$ " : "# ";
d266 2
a267 1
		if (!(vp->flag & ISSET) || (!euid && !strchr(str_val(vp), '#')))
d272 1
a272 1
	Flag(FPRIVILEGED) = getuid() != euid || getgid() != getegid();
d313 1
a313 1
			Flag(FTALKING) = 1;
d348 2
d421 2
a464 1
		quitenv();
d466 1
a466 1
		if (s)
d468 1
d675 3
d804 1
@


1.8
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 1997/06/19 13:58:45 kstailey Exp $	*/
a489 1
	quitenv();
d492 1
@


1.7
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1997/01/02 09:34:03 downsj Exp $	*/
d29 1
a29 1
static const	char   initsubs [] = 
@


1.6
log
@(foo *)0 -> NULL
@
text
@d112 1
a112 1
					    "pdksh", NULL
d162 1
a162 1
		size_t len = confstr(_CS_PATH, NULL, 0);
d228 1
a228 1
			pwdx = NULL;
d240 1
a240 1
	setint(global("RANDOM"), (long) time(NULL));
d268 1
a268 1
	argi = parse_args(argv, OF_CMDLINE, NULL);
d286 1
a286 1
		s->file = search(argv[argi++], path, R_OK, NULL);
d302 2
a303 1
		s->u.shf = shf_fdopen(0, SHF_RD | can_seek(0), NULL);
d309 1
a309 1
			s->file = NULL;
d357 3
a359 3
			include(profile, 0, NULL, 1);
		else if (include("/etc/profile.ksh", 0, NULL, 1) < 0)
			include("c:/usr/etc/profile.ksh", 0, NULL, 1);
d361 2
a362 1
			include(substitute("$HOME/profile.ksh", 0), 0, NULL, 1);
d364 1
a364 1
		include(KSH_SYSTEM_PROFILE, 0, NULL, 1);
d366 2
a367 1
			include(substitute("$HOME/.profile", 0), 0, NULL, 1);
d372 1
a372 1
		include("/etc/suid_profile", 0, NULL, 1);
d391 1
a391 1
			include(env_file, 0, NULL, 1);
d394 2
a395 1
			include(substitute("$HOME/kshrc.ksh", 0), 0, NULL, 1);
d404 2
a405 1
						    "ENV", "SHELL", NULL
d446 1
a446 1
		old_argv = NULL;
d732 1
a732 1
	e->oenv = NULL;
@


1.5
log
@Add FSH (set -o sh), initialize it if we're /bin/sh, and add the first use:
don't set $_ if we're non-interactive.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 1996/11/21 07:59:33 downsj Exp $	*/
d112 1
a112 1
					    "pdksh", (char *) 0
d162 1
a162 1
		size_t len = confstr(_CS_PATH, (char *) 0, 0);
d228 1
a228 1
			pwdx = (char *) 0;
d240 1
a240 1
	setint(global("RANDOM"), (long) time((time_t *)0));
d268 1
a268 1
	argi = parse_args(argv, OF_CMDLINE, (int *) 0);
d286 1
a286 1
		s->file = search(argv[argi++], path, R_OK, (int *) 0);
d302 1
a302 2
		s->u.shf = shf_fdopen(0, SHF_RD | can_seek(0),
				      (struct shf *) 0);
d308 1
a308 1
			s->file = (char *) 0;
d356 3
a358 3
			include(profile, 0, (char **) 0, 1);
		else if (include("/etc/profile.ksh", 0, (char **) 0, 1) < 0)
			include("c:/usr/etc/profile.ksh", 0, (char **) 0, 1);
d360 1
a360 2
			include(substitute("$HOME/profile.ksh", 0), 0,
				(char **) 0, 1);
d362 1
a362 1
		include(KSH_SYSTEM_PROFILE, 0, (char **) 0, 1);
d364 1
a364 2
			include(substitute("$HOME/.profile", 0), 0,
				(char **) 0, 1);
d369 1
a369 1
		include("/etc/suid_profile", 0, (char **) 0, 1);
d388 1
a388 1
			include(env_file, 0, (char **) 0, 1);
d391 1
a391 2
			include(substitute("$HOME/kshrc.ksh", 0), 0,
				(char **) 0, 1);
d400 1
a400 2
						    "ENV", "SHELL",
						(char *) 0
d441 1
a441 1
		old_argv = (char **) 0;
d727 1
a727 1
	e->oenv = (struct env *) 0;
@


1.4
log
@Update to 5.2.12.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 1996/10/01 02:05:45 downsj Exp $	*/
d199 5
@


1.3
log
@Integrate pdksh 5.2.9.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.2 1996/08/19 20:08:56 downsj Exp $	*/
d19 3
a21 3
static	void	reclaim ARGS((void));
static	void	remove_temps ARGS((struct temp *tp));
static	int	is_restricted ARGS((char *name));
d27 1
a27 1
static	const char	initifs [] = "IFS= \t\n"; /* must be R/W */
d29 1
a29 1
static	const	char   initsubs [] = 
d40 1
a40 1
static	const char *const initcoms [] = {
d123 1
a125 3
	env.savefd = NULL;
	env.oenv = NULL;
	env.loc = (struct block *) 0;
d730 11
d755 2
a756 2
  static char tmpfile[30];
  int status;
d758 9
a766 4
  if (strlen (tmpfile) > 0 ) {
    unlink(tmpfile);
    *tmpfile=0;
  }
d770 1
a770 1
		if (tp->pid == procpid)
d772 16
a787 4
		  { status=unlink(tp->name);
		    if (status < 0)
		      strcpy(tmpfile, tp->name);
		  }
d791 1
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
d60 1
d62 1
d361 1
a361 1
		include("/etc/profile", 0, (char **) 0, 1);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
	"typeset", "-i", "OPTIND=1", "MAILCHECK=600",
d46 1
a46 1
	    "SECONDS=0", "RANDOM", "TMOUT=0",
d281 1
a281 1
		s->file = search(argv[argi++], path, R_OK);
d409 1
d411 1
d573 1
d575 1
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
