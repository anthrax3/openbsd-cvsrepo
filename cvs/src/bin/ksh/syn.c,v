head	1.38;
access;
symbols
	OPENBSD_6_2:1.38.0.10
	OPENBSD_6_2_BASE:1.38
	OPENBSD_6_1:1.38.0.8
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.29.0.12
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.4
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.8
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.6
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.28.0.20
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.18
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.16
	OPENBSD_5_0:1.28.0.14
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.12
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.10
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.6
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.8
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.4
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.8
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.6
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.4
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.2
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.6
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.12
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.12.0.10
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.8
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.6
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2015.12.30.09.07.00;	author tedu;	state Exp;
branches;
next	1.37;
commitid	WTwPzlskFufQpRQz;

1.37
date	2015.11.01.15.38.53;	author mmcc;	state Exp;
branches;
next	1.36;
commitid	Fr9nr0FBz2YkAWdK;

1.36
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.35;
commitid	C4W85jmosThChWA2;

1.35
date	2015.10.15.22.53.50;	author mmcc;	state Exp;
branches;
next	1.34;
commitid	yhnRNqadpBr7qnSq;

1.34
date	2015.10.06.21.21.39;	author nicm;	state Exp;
branches;
next	1.33;
commitid	8OQA8LsAZMcro1M0;

1.33
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.32;
commitid	7fgq4YTZG4xZ0uN0;

1.32
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.31;
commitid	v5QjoxUgKU2iUTFz;

1.31
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.30;
commitid	lBs9un9sXhbdfVrQ;

1.30
date	2015.09.01.13.12.31;	author tedu;	state Exp;
branches;
next	1.29;
commitid	sKGEDet4KOfGjsIb;

1.29
date	2013.06.03.18.40.05;	author jca;	state Exp;
branches;
next	1.28;

1.28
date	2008.07.23.16.34.38;	author jaredy;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.10.14.38.59;	author jaredy;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.21.10.41.26;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.20.20.54.08;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.14.22.08.40;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.11.20.31.21;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.28.21.33.04;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.18.22.42.26;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.18.21.04.52;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.22.07.40.38;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.12;

1.12
date	99.06.15.01.18.36;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.10.29.04.09.21;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.10.09.16.21.36;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.06.25.19.02.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.09.01.18.30.12;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.06.19.13.58.47;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.06.18.22.42.45;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.11.21.07.59.35;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.10.13.21.32.20;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.10.01.02.05.50;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.59;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.38
log
@rename global "e" to genv to avoid accidental shadowing and aliasing.
ok millert nicm tb
@
text
@/*	$OpenBSD: syn.c,v 1.37 2015/11/01 15:38:53 mmcc Exp $	*/

/*
 * shell parser (C version)
 */

#include <string.h>

#include "sh.h"
#include "c_test.h"

struct nesting_state {
	int	start_token;	/* token than began nesting (eg, FOR) */
	int	start_line;	/* line nesting began on */
};

static void	yyparse(void);
static struct op *pipeline(int);
static struct op *andor(void);
static struct op *c_list(int);
static struct ioword *synio(int);
static void	musthave(int, int);
static struct op *nested(int, int, int);
static struct op *get_command(int);
static struct op *dogroup(void);
static struct op *thenpart(void);
static struct op *elsepart(void);
static struct op *caselist(void);
static struct op *casepart(int);
static struct op *function_body(char *, int);
static char **	wordlist(void);
static struct op *block(int, struct op *, struct op *, char **);
static struct op *newtp(int);
static void	syntaxerr(const char *) __attribute__((__noreturn__));
static void	nesting_push(struct nesting_state *, int);
static void	nesting_pop(struct nesting_state *);
static int	assign_command(char *);
static int	inalias(struct source *);
static int	dbtestp_isa(Test_env *, Test_meta);
static const char *dbtestp_getopnd(Test_env *, Test_op, int);
static int	dbtestp_eval(Test_env *, Test_op, const char *, const char *,
		    int);
static void	dbtestp_error(Test_env *, int, const char *);

static	struct	op	*outtree; /* yyparse output */

static struct nesting_state nesting;	/* \n changed to ; */

static	int	reject;		/* token(cf) gets symbol again */
static	int	symbol;		/* yylex value */

#define	token(cf) \
	((reject) ? (reject = false, symbol) : (symbol = yylex(cf)))
#define	tpeek(cf) \
	((reject) ? (symbol) : (reject = true, symbol = yylex(cf)))

static void
yyparse(void)
{
	int c;

	reject = false;

	outtree = c_list(source->type == SSTRING);
	c = tpeek(0);
	if (c == 0 && !outtree)
		outtree = newtp(TEOF);
	else if (c != '\n' && c != 0)
		syntaxerr(NULL);
}

static struct op *
pipeline(int cf)
{
	struct op *t, *p, *tl = NULL;

	t = get_command(cf);
	if (t != NULL) {
		while (token(0) == '|') {
			if ((p = get_command(CONTIN)) == NULL)
				syntaxerr(NULL);
			if (tl == NULL)
				t = tl = block(TPIPE, t, p, NULL);
			else
				tl = tl->right = block(TPIPE, tl->right, p, NULL);
		}
		reject = true;
	}
	return (t);
}

static struct op *
andor(void)
{
	struct op *t, *p;
	int c;

	t = pipeline(0);
	if (t != NULL) {
		while ((c = token(0)) == LOGAND || c == LOGOR) {
			if ((p = pipeline(CONTIN)) == NULL)
				syntaxerr(NULL);
			t = block(c == LOGAND? TAND: TOR, t, p, NULL);
		}
		reject = true;
	}
	return (t);
}

static struct op *
c_list(int multi)
{
	struct op *t = NULL, *p, *tl = NULL;
	int c;
	int have_sep;

	while (1) {
		p = andor();
		/* Token has always been read/rejected at this point, so
		 * we don't worry about what flags to pass token()
		 */
		c = token(0);
		have_sep = 1;
		if (c == '\n' && (multi || inalias(source))) {
			if (!p) /* ignore blank lines */
				continue;
		} else if (!p)
			break;
		else if (c == '&' || c == COPROC)
			p = block(c == '&' ? TASYNC : TCOPROC,
				  p, NULL, NULL);
		else if (c != ';')
			have_sep = 0;
		if (!t)
			t = p;
		else if (!tl)
			t = tl = block(TLIST, t, p, NULL);
		else
			tl = tl->right = block(TLIST, tl->right, p, NULL);
		if (!have_sep)
			break;
	}
	reject = true;
	return t;
}

static struct ioword *
synio(int cf)
{
	struct ioword *iop;
	int ishere;

	if (tpeek(cf) != REDIR)
		return NULL;
	reject = false;
	iop = yylval.iop;
	ishere = (iop->flag&IOTYPE) == IOHERE;
	musthave(LWORD, ishere ? HEREDELIM : 0);
	if (ishere) {
		iop->delim = yylval.cp;
		if (*ident != 0) /* unquoted */
			iop->flag |= IOEVAL;
		if (herep >= &heres[HERES])
			yyerror("too many <<'s\n");
		*herep++ = iop;
	} else
		iop->name = yylval.cp;
	return iop;
}

static void
musthave(int c, int cf)
{
	if ((token(cf)) != c)
		syntaxerr(NULL);
}

static struct op *
nested(int type, int smark, int emark)
{
	struct op *t;
	struct nesting_state old_nesting;

	nesting_push(&old_nesting, smark);
	t = c_list(true);
	musthave(emark, KEYWORD|ALIAS);
	nesting_pop(&old_nesting);
	return (block(type, t, NULL, NULL));
}

static struct op *
get_command(int cf)
{
	struct op *t;
	int c, iopn = 0, syniocf;
	struct ioword *iop, **iops;
	XPtrV args, vars;
	struct nesting_state old_nesting;

	iops = areallocarray(NULL, NUFILE + 1,
	    sizeof(struct ioword *), ATEMP);
	XPinit(args, 16);
	XPinit(vars, 16);

	syniocf = KEYWORD|ALIAS;
	switch (c = token(cf|KEYWORD|ALIAS|VARASN)) {
	default:
		reject = true;
		afree(iops, ATEMP);
		XPfree(args);
		XPfree(vars);
		return NULL; /* empty line */

	case LWORD:
	case REDIR:
		reject = true;
		syniocf &= ~(KEYWORD|ALIAS);
		t = newtp(TCOM);
		t->lineno = source->line;
		while (1) {
			cf = (t->u.evalflags ? ARRAYVAR : 0) |
			    (XPsize(args) == 0 ? ALIAS|VARASN : CMDWORD);
			switch (tpeek(cf)) {
			case REDIR:
				if (iopn >= NUFILE)
					yyerror("too many redirections\n");
				iops[iopn++] = synio(cf);
				break;

			case LWORD:
				reject = false;
				/* the iopn == 0 and XPsize(vars) == 0 are
				 * dubious but at&t ksh acts this way
				 */
				if (iopn == 0 && XPsize(vars) == 0 &&
				    XPsize(args) == 0 &&
				    assign_command(ident))
					t->u.evalflags = DOVACHECK;
				if ((XPsize(args) == 0 || Flag(FKEYWORD)) &&
				    is_wdvarassign(yylval.cp))
					XPput(vars, yylval.cp);
				else
					XPput(args, yylval.cp);
				break;

			case '(':
				/* Check for "> foo (echo hi)", which at&t ksh
				 * allows (not POSIX, but not disallowed)
				 */
				afree(t, ATEMP);
				if (XPsize(args) == 0 && XPsize(vars) == 0) {
					reject = false;
					goto Subshell;
				}
				/* Must be a function */
				if (iopn != 0 || XPsize(args) != 1 ||
				    XPsize(vars) != 0)
					syntaxerr(NULL);
				reject = false;
				/*(*/
				musthave(')', 0);
				t = function_body(XPptrv(args)[0], false);
				goto Leave;

			default:
				goto Leave;
			}
		}
	  Leave:
		break;

	  Subshell:
	case '(':
		t = nested(TPAREN, '(', ')');
		break;

	case '{': /*}*/
		t = nested(TBRACE, '{', '}');
		break;

	case MDPAREN:
	  {
		static const char let_cmd[] = {
			CHAR, 'l', CHAR, 'e',
			CHAR, 't', EOS
		};
		/* Leave KEYWORD in syniocf (allow if (( 1 )) then ...) */
		t = newtp(TCOM);
		t->lineno = source->line;
		reject = false;
		XPput(args, wdcopy(let_cmd, ATEMP));
		musthave(LWORD,LETEXPR);
		XPput(args, yylval.cp);
		break;
	  }

	case DBRACKET: /* [[ .. ]] */
		/* Leave KEYWORD in syniocf (allow if [[ -n 1 ]] then ...) */
		t = newtp(TDBRACKET);
		reject = false;
		{
			Test_env te;

			te.flags = TEF_DBRACKET;
			te.pos.av = &args;
			te.isa = dbtestp_isa;
			te.getopnd = dbtestp_getopnd;
			te.eval = dbtestp_eval;
			te.error = dbtestp_error;

			test_parse(&te);
		}
		break;

	case FOR:
	case SELECT:
		t = newtp((c == FOR) ? TFOR : TSELECT);
		musthave(LWORD, ARRAYVAR);
		if (!is_wdvarname(yylval.cp, true))
			yyerror("%s: bad identifier\n",
			    c == FOR ? "for" : "select");
		t->str = str_save(ident, ATEMP);
		nesting_push(&old_nesting, c);
		t->vars = wordlist();
		t->left = dogroup();
		nesting_pop(&old_nesting);
		break;

	case WHILE:
	case UNTIL:
		nesting_push(&old_nesting, c);
		t = newtp((c == WHILE) ? TWHILE : TUNTIL);
		t->left = c_list(true);
		t->right = dogroup();
		nesting_pop(&old_nesting);
		break;

	case CASE:
		t = newtp(TCASE);
		musthave(LWORD, 0);
		t->str = yylval.cp;
		nesting_push(&old_nesting, c);
		t->left = caselist();
		nesting_pop(&old_nesting);
		break;

	case IF:
		nesting_push(&old_nesting, c);
		t = newtp(TIF);
		t->left = c_list(true);
		t->right = thenpart();
		musthave(FI, KEYWORD|ALIAS);
		nesting_pop(&old_nesting);
		break;

	case BANG:
		syniocf &= ~(KEYWORD|ALIAS);
		t = pipeline(0);
		if (t == NULL)
			syntaxerr(NULL);
		t = block(TBANG, NULL, t, NULL);
		break;

	case TIME:
		syniocf &= ~(KEYWORD|ALIAS);
		t = pipeline(0);
		if (t) {
			t->str = alloc(2, ATEMP);
			t->str[0] = '\0'; /* TF_* flags */
			t->str[1] = '\0';
		}
		t = block(TTIME, t, NULL, NULL);
		break;

	case FUNCTION:
		musthave(LWORD, 0);
		t = function_body(yylval.cp, true);
		break;
	}

	while ((iop = synio(syniocf)) != NULL) {
		if (iopn >= NUFILE)
			yyerror("too many redirections\n");
		iops[iopn++] = iop;
	}

	if (iopn == 0) {
		afree(iops, ATEMP);
		t->ioact = NULL;
	} else {
		iops[iopn++] = NULL;
		iops = areallocarray(iops, iopn,
		    sizeof(struct ioword *), ATEMP);
		t->ioact = iops;
	}

	if (t->type == TCOM || t->type == TDBRACKET) {
		XPput(args, NULL);
		t->args = (char **) XPclose(args);
		XPput(vars, NULL);
		t->vars = (char **) XPclose(vars);
	} else {
		XPfree(args);
		XPfree(vars);
	}

	return t;
}

static struct op *
dogroup(void)
{
	int c;
	struct op *list;

	c = token(CONTIN|KEYWORD|ALIAS);
	/* A {...} can be used instead of do...done for for/select loops
	 * but not for while/until loops - we don't need to check if it
	 * is a while loop because it would have been parsed as part of
	 * the conditional command list...
	 */
	if (c == DO)
		c = DONE;
	else if (c == '{')
		c = '}';
	else
		syntaxerr(NULL);
	list = c_list(true);
	musthave(c, KEYWORD|ALIAS);
	return list;
}

static struct op *
thenpart(void)
{
	struct op *t;

	musthave(THEN, KEYWORD|ALIAS);
	t = newtp(0);
	t->left = c_list(true);
	if (t->left == NULL)
		syntaxerr(NULL);
	t->right = elsepart();
	return (t);
}

static struct op *
elsepart(void)
{
	struct op *t;

	switch (token(KEYWORD|ALIAS|VARASN)) {
	case ELSE:
		if ((t = c_list(true)) == NULL)
			syntaxerr(NULL);
		return (t);

	case ELIF:
		t = newtp(TELIF);
		t->left = c_list(true);
		t->right = thenpart();
		return (t);

	default:
		reject = true;
	}
	return NULL;
}

static struct op *
caselist(void)
{
	struct op *t, *tl;
	int c;

	c = token(CONTIN|KEYWORD|ALIAS);
	/* A {...} can be used instead of in...esac for case statements */
	if (c == IN)
		c = ESAC;
	else if (c == '{')
		c = '}';
	else
		syntaxerr(NULL);
	t = tl = NULL;
	while ((tpeek(CONTIN|KEYWORD|ESACONLY)) != c) { /* no ALIAS here */
		struct op *tc = casepart(c);
		if (tl == NULL)
			t = tl = tc, tl->right = NULL;
		else
			tl->right = tc, tl = tc;
	}
	musthave(c, KEYWORD|ALIAS);
	return (t);
}

static struct op *
casepart(int endtok)
{
	struct op *t;
	int c;
	XPtrV ptns;

	XPinit(ptns, 16);
	t = newtp(TPAT);
	c = token(CONTIN|KEYWORD); /* no ALIAS here */
	if (c != '(')
		reject = true;
	do {
		musthave(LWORD, 0);
		XPput(ptns, yylval.cp);
	} while ((c = token(0)) == '|');
	reject = true;
	XPput(ptns, NULL);
	t->vars = (char **) XPclose(ptns);
	musthave(')', 0);

	t->left = c_list(true);
	/* Note: Posix requires the ;; */
	if ((tpeek(CONTIN|KEYWORD|ALIAS)) != endtok)
		musthave(BREAK, CONTIN|KEYWORD|ALIAS);
	return (t);
}

static struct op *
function_body(char *name,
    int ksh_func)		/* function foo { ... } vs foo() { .. } */
{
	char *sname, *p;
	struct op *t;
	int old_func_parse;

	sname = wdstrip(name);
	/* Check for valid characters in name.  posix and ksh93 say only
	 * allow [a-zA-Z_0-9] but this allows more as old pdksh's have
	 * allowed more (the following were never allowed:
	 *	nul space nl tab $ ' " \ ` ( ) & | ; = < >
	 *  C_QUOTE covers all but = and adds # [ ? *)
	 */
	for (p = sname; *p; p++)
		if (ctype(*p, C_QUOTE) || *p == '=')
			yyerror("%s: invalid function name\n", sname);

	t = newtp(TFUNCT);
	t->str = sname;
	t->u.ksh_func = ksh_func;
	t->lineno = source->line;

	/* Note that POSIX allows only compound statements after foo(), sh and
	 * at&t ksh allow any command, go with the later since it shouldn't
	 * break anything.  However, for function foo, at&t ksh only accepts
	 * an open-brace.
	 */
	if (ksh_func) {
		musthave('{', CONTIN|KEYWORD|ALIAS); /* } */
		reject = true;
	}

	old_func_parse = genv->flags & EF_FUNC_PARSE;
	genv->flags |= EF_FUNC_PARSE;
	if ((t->left = get_command(CONTIN)) == NULL) {
		/*
		 * Probably something like foo() followed by eof or ;.
		 * This is accepted by sh and ksh88.
		 * To make "typeset -f foo" work reliably (so its output can
		 * be used as input), we pretend there is a colon here.
		 */
		t->left = newtp(TCOM);
		t->left->args = areallocarray(NULL, 2, sizeof(char *), ATEMP);
		t->left->args[0] = alloc(3, ATEMP);
		t->left->args[0][0] = CHAR;
		t->left->args[0][1] = ':';
		t->left->args[0][2] = EOS;
		t->left->args[1] = NULL;
		t->left->vars = alloc(sizeof(char *), ATEMP);
		t->left->vars[0] = NULL;
		t->left->lineno = 1;
	}
	if (!old_func_parse)
		genv->flags &= ~EF_FUNC_PARSE;

	return t;
}

static char **
wordlist(void)
{
	int c;
	XPtrV args;

	XPinit(args, 16);
	/* Posix does not do alias expansion here... */
	if ((c = token(CONTIN|KEYWORD|ALIAS)) != IN) {
		if (c != ';') /* non-POSIX, but at&t ksh accepts a ; here */
			reject = true;
		return NULL;
	}
	while ((c = token(0)) == LWORD)
		XPput(args, yylval.cp);
	if (c != '\n' && c != ';')
		syntaxerr(NULL);
	XPput(args, NULL);
	return (char **) XPclose(args);
}

/*
 * supporting functions
 */

static struct op *
block(int type, struct op *t1, struct op *t2, char **wp)
{
	struct op *t;

	t = newtp(type);
	t->left = t1;
	t->right = t2;
	t->vars = wp;
	return (t);
}

const	struct tokeninfo {
	const char *name;
	short	val;
	short	reserved;
} tokentab[] = {
	/* Reserved words */
	{ "if",		IF,	true },
	{ "then",	THEN,	true },
	{ "else",	ELSE,	true },
	{ "elif",	ELIF,	true },
	{ "fi",		FI,	true },
	{ "case",	CASE,	true },
	{ "esac",	ESAC,	true },
	{ "for",	FOR,	true },
	{ "select",	SELECT,	true },
	{ "while",	WHILE,	true },
	{ "until",	UNTIL,	true },
	{ "do",		DO,	true },
	{ "done",	DONE,	true },
	{ "in",		IN,	true },
	{ "function",	FUNCTION, true },
	{ "time",	TIME,	true },
	{ "{",		'{',	true },
	{ "}",		'}',	true },
	{ "!",		BANG,	true },
	{ "[[",		DBRACKET, true },
	/* Lexical tokens (0[EOF], LWORD and REDIR handled specially) */
	{ "&&",		LOGAND,	false },
	{ "||",		LOGOR,	false },
	{ ";;",		BREAK,	false },
	{ "((",		MDPAREN, false },
	{ "|&",		COPROC,	false },
	/* and some special cases... */
	{ "newline",	'\n',	false },
	{ 0 }
};

void
initkeywords(void)
{
	struct tokeninfo const *tt;
	struct tbl *p;

	ktinit(&keywords, APERM, 32); /* must be 2^n (currently 20 keywords) */
	for (tt = tokentab; tt->name; tt++) {
		if (tt->reserved) {
			p = ktenter(&keywords, tt->name, hash(tt->name));
			p->flag |= DEFINED|ISSET;
			p->type = CKEYWD;
			p->val.i = tt->val;
		}
	}
}

static void
syntaxerr(const char *what)
{
	char redir[6];	/* 2<<- is the longest redirection, I think */
	const char *s;
	struct tokeninfo const *tt;
	int c;

	if (!what)
		what = "unexpected";
	reject = true;
	c = token(0);
    Again:
	switch (c) {
	case 0:
		if (nesting.start_token) {
			c = nesting.start_token;
			source->errline = nesting.start_line;
			what = "unmatched";
			goto Again;
		}
		/* don't quote the EOF */
		yyerror("syntax error: unexpected EOF\n");
		/* NOTREACHED */

	case LWORD:
		s = snptreef(NULL, 32, "%S", yylval.cp);
		break;

	case REDIR:
		s = snptreef(redir, sizeof(redir), "%R", yylval.iop);
		break;

	default:
		for (tt = tokentab; tt->name; tt++)
			if (tt->val == c)
			    break;
		if (tt->name)
			s = tt->name;
		else {
			if (c > 0 && c < 256) {
				redir[0] = c;
				redir[1] = '\0';
			} else
				shf_snprintf(redir, sizeof(redir),
					"?%d", c);
			s = redir;
		}
	}
	yyerror("syntax error: `%s' %s\n", s, what);
}

static void
nesting_push(struct nesting_state *save, int tok)
{
	*save = nesting;
	nesting.start_token = tok;
	nesting.start_line = source->line;
}

static void
nesting_pop(struct nesting_state *saved)
{
	nesting = *saved;
}

static struct op *
newtp(int type)
{
	struct op *t;

	t = alloc(sizeof(*t), ATEMP);
	t->type = type;
	t->u.evalflags = 0;
	t->args = t->vars = NULL;
	t->ioact = NULL;
	t->left = t->right = NULL;
	t->str = NULL;
	return (t);
}

struct op *
compile(Source *s)
{
	nesting.start_token = 0;
	nesting.start_line = 0;
	herep = heres;
	source = s;
	yyparse();
	return outtree;
}

/* This kludge exists to take care of sh/at&t ksh oddity in which
 * the arguments of alias/export/readonly/typeset have no field
 * splitting, file globbing, or (normal) tilde expansion done.
 * at&t ksh seems to do something similar to this since
 *	$ touch a=a; typeset a=[ab]; echo "$a"
 *	a=[ab]
 *	$ x=typeset; $x a=[ab]; echo "$a"
 *	a=a
 *	$
 */
static int
assign_command(char *s)
{
	if (Flag(FPOSIX) || !*s)
		return 0;
	return (strcmp(s, "alias") == 0) ||
	    (strcmp(s, "export") == 0) ||
	    (strcmp(s, "readonly") == 0) ||
	    (strcmp(s, "typeset") == 0);
}

/* Check if we are in the middle of reading an alias */
static int
inalias(struct source *s)
{
	for (; s && s->type == SALIAS; s = s->next)
		if (!(s->flags & SF_ALIASEND))
			return 1;
	return 0;
}


/* Order important - indexed by Test_meta values
 * Note that ||, &&, ( and ) can't appear in as unquoted strings
 * in normal shell input, so these can be interpreted unambiguously
 * in the evaluation pass.
 */
static const char dbtest_or[] = { CHAR, '|', CHAR, '|', EOS };
static const char dbtest_and[] = { CHAR, '&', CHAR, '&', EOS };
static const char dbtest_not[] = { CHAR, '!', EOS };
static const char dbtest_oparen[] = { CHAR, '(', EOS };
static const char dbtest_cparen[] = { CHAR, ')', EOS };
const char *const dbtest_tokens[] = {
	dbtest_or, dbtest_and, dbtest_not,
	dbtest_oparen, dbtest_cparen
};
const char db_close[] = { CHAR, ']', CHAR, ']', EOS };
const char db_lthan[] = { CHAR, '<', EOS };
const char db_gthan[] = { CHAR, '>', EOS };

/* Test if the current token is a whatever.  Accepts the current token if
 * it is.  Returns 0 if it is not, non-zero if it is (in the case of
 * TM_UNOP and TM_BINOP, the returned value is a Test_op).
 */
static int
dbtestp_isa(Test_env *te, Test_meta meta)
{
	int c = tpeek(ARRAYVAR | (meta == TM_BINOP ? 0 : CONTIN));
	int uqword = 0;
	char *save = NULL;
	int ret = 0;

	/* unquoted word? */
	uqword = c == LWORD && *ident;

	if (meta == TM_OR)
		ret = c == LOGOR;
	else if (meta == TM_AND)
		ret = c == LOGAND;
	else if (meta == TM_NOT)
		ret = uqword && strcmp(yylval.cp, dbtest_tokens[(int) TM_NOT]) == 0;
	else if (meta == TM_OPAREN)
		ret = c == '(' /*)*/;
	else if (meta == TM_CPAREN)
		ret = c == /*(*/ ')';
	else if (meta == TM_UNOP || meta == TM_BINOP) {
		if (meta == TM_BINOP && c == REDIR &&
		    (yylval.iop->flag == IOREAD || yylval.iop->flag == IOWRITE)) {
			ret = 1;
			save = wdcopy(yylval.iop->flag == IOREAD ?
			    db_lthan : db_gthan, ATEMP);
		} else if (uqword && (ret = (int) test_isop(te, meta, ident)))
			save = yylval.cp;
	} else /* meta == TM_END */
		ret = uqword && strcmp(yylval.cp, db_close) == 0;
	if (ret) {
		reject = false;
		if (meta != TM_END) {
			if (!save)
				save = wdcopy(dbtest_tokens[(int) meta], ATEMP);
			XPput(*te->pos.av, save);
		}
	}
	return ret;
}

static const char *
dbtestp_getopnd(Test_env *te, Test_op op, int do_eval)
{
	int c = tpeek(ARRAYVAR);

	if (c != LWORD)
		return NULL;

	reject = false;
	XPput(*te->pos.av, yylval.cp);

	return null;
}

static int
dbtestp_eval(Test_env *te, Test_op op, const char *opnd1, const char *opnd2,
    int do_eval)
{
	return 1;
}

static void
dbtestp_error(Test_env *te, int offset, const char *msg)
{
	te->flags |= TEF_ERROR;

	if (offset < 0) {
		reject = true;
		/* Kludgy to say the least... */
		symbol = LWORD;
		yylval.cp = *(XPptrv(*te->pos.av) + XPsize(*te->pos.av) +
		    offset);
	}
	syntaxerr(msg);
}
@


1.37
log
@Add uses of areallocarray(). mksh and Bitrig ksh already have similar
functions. With help from Theo Buehler.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.36 2015/10/19 14:42:16 mmcc Exp $	*/
d558 2
a559 2
	old_func_parse = e->flags & EF_FUNC_PARSE;
	e->flags |= EF_FUNC_PARSE;
d579 1
a579 1
		e->flags &= ~EF_FUNC_PARSE;
@


1.36
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.35 2015/10/15 22:53:50 mmcc Exp $	*/
d200 2
a201 2
	iops = alloc(sizeofN(struct ioword *, NUFILE+1),
	    ATEMP);
d392 2
a393 2
		iops = (struct ioword **) aresize((void*) iops,
		    sizeofN(struct ioword *, iopn), ATEMP);
d568 2
a569 2
		t->left->args = alloc(sizeof(char *) * 2, ATEMP);
		t->left->args[0] = alloc(sizeof(char) * 3, ATEMP);
@


1.35
log
@Remove three distracting aliases for NULL.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.34 2015/10/06 21:21:39 nicm Exp $	*/
d6 2
@


1.34
log
@Drop the silly and distracting ACCEPT and REJECT macros, from Michael
McConville. No binary change. ok millert tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.33 2015/09/18 07:28:24 nicm Exp $	*/
d81 1
a81 1
				t = tl = block(TPIPE, t, p, NOWORDS);
d83 1
a83 1
				tl = tl->right = block(TPIPE, tl->right, p, NOWORDS);
d101 1
a101 1
			t = block(c == LOGAND? TAND: TOR, t, p, NOWORDS);
d129 1
a129 1
				  p, NOBLOCK, NOWORDS);
d135 1
a135 1
			t = tl = block(TLIST, t, p, NOWORDS);
d137 1
a137 1
			tl = tl->right = block(TLIST, tl->right, p, NOWORDS);
d186 1
a186 1
	return (block(type, t, NOBLOCK, NOWORDS));
d359 1
a359 1
		t = block(TBANG, NOBLOCK, t, NOWORDS);
d370 1
a370 1
		t = block(TTIME, t, NOBLOCK, NOWORDS);
@


1.33
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.32 2015/09/17 14:21:33 nicm Exp $	*/
a49 2
#define	REJECT	(reject = 1)
#define	ACCEPT	(reject = 0)
d51 1
a51 1
	((reject) ? (ACCEPT, symbol) : (symbol = yylex(cf)))
d53 1
a53 1
	((reject) ? (symbol) : (REJECT, symbol = yylex(cf)))
d60 1
a60 1
	ACCEPT;
d85 1
a85 1
		REJECT;
d103 1
a103 1
		REJECT;
d141 1
a141 1
	REJECT;
d153 1
a153 1
	ACCEPT;
d206 1
a206 1
		REJECT;
d214 1
a214 1
		REJECT;
d229 1
a229 1
				ACCEPT;
d250 1
a250 1
					ACCEPT;
d257 1
a257 1
				ACCEPT;
d288 1
a288 1
		ACCEPT;
d298 1
a298 1
		ACCEPT;
d463 1
a463 1
		REJECT;
d505 1
a505 1
		REJECT;
d510 1
a510 1
	REJECT;
d553 1
a553 1
		REJECT;
d592 1
a592 1
			REJECT;
d683 1
a683 1
	REJECT;
d851 1
a851 1
		ACCEPT;
d869 1
a869 1
	ACCEPT;
d888 1
a888 1
		REJECT;
@


1.32
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.31 2015/09/15 18:15:05 tedu Exp $	*/
d359 1
a359 1
		if (t == (struct op *) 0)
d560 1
a560 1
	if ((t->left = get_command(CONTIN)) == (struct op *) 0) {
d869 1
a869 1
		return (const char *) 0;
@


1.31
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.30 2015/09/01 13:12:31 tedu Exp $	*/
d200 1
a200 1
	iops = (struct ioword **) alloc(sizeofN(struct ioword *, NUFILE+1),
d568 1
a568 1
		t->left->args = (char **) alloc(sizeof(char *) * 2, ATEMP);
d574 1
a574 1
		t->left->vars = (char **) alloc(sizeof(char *), ATEMP);
d746 1
a746 1
	t = (struct op *) alloc(sizeof(*t), ATEMP);
@


1.30
log
@remove casts and null checks before free. from Michael McConville
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.29 2013/06/03 18:40:05 jca Exp $	*/
d69 1
a69 1
		syntaxerr((char *) 0);
d81 1
a81 1
				syntaxerr((char *) 0);
d102 1
a102 1
				syntaxerr((char *) 0);
d175 1
a175 1
		syntaxerr((char *) 0);
d258 1
a258 1
					syntaxerr((char *) 0);
d360 1
a360 1
			syntaxerr((char *) 0);
d427 1
a427 1
		syntaxerr((char *) 0);
d442 1
a442 1
		syntaxerr((char *) 0);
d455 1
a455 1
			syntaxerr((char *) 0);
d483 1
a483 1
		syntaxerr((char *) 0);
d573 1
a573 1
		t->left->args[1] = (char *) 0;
d575 1
a575 1
		t->left->vars[0] = (char *) 0;
d600 1
a600 1
		syntaxerr((char *) 0);
d701 1
a701 1
		s = snptreef((char *) 0, 32, "%S", yylval.cp);
d826 1
a826 1
	char *save = (char *) 0;
@


1.29
log
@for var in; do ... shouldn't be interpreted as for var; do ...
Fix by returning an empty token list instead of NULL to consumers.

Brings base ksh more in line with POSIX.
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.28 2008/07/23 16:34:38 jaredy Exp $	*/
d209 1
a209 1
		afree((void*) iops, ATEMP);
d388 1
a388 1
		afree((void*) iops, ATEMP);
@


1.28
log
@fix stack abuse in the `time' commmand, using alloc()'d memory instead.

reported by Thorsten Glaser, thanks.

ok millert@@, earlier version miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.27 2006/04/10 14:38:59 jaredy Exp $	*/
d601 2
a602 7
	if (XPsize(args) == 0) {
		XPfree(args);
		return NULL;
	} else {
		XPput(args, NULL);
		return (char **) XPclose(args);
	}
@


1.27
log
@fix lint comments, no functional changes; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.26 2006/03/21 10:41:26 otto Exp $	*/
d367 5
@


1.26
log
@Revert for the moment, according to Mike Belopuhov this produces
errors in rc and netstart.
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.24 2006/03/14 22:08:40 deraadt Exp $	*/
d698 1
a698 1
		/*NOTREACHED*/
@


1.25
log
@Fix potential null deref and out-of-bound access.
ok millert@@ deraadt@@
@
text
@d854 1
a854 2
		if (meta != TM_END && meta >= 0 &&
		    meta < sizeof(dbtest_tokens) / sizeof(dbtest_tokens[0])) {
@


1.24
log
@remove excessive optimization; from adobriyan@@gmail; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.23 2005/12/11 20:31:21 otto Exp $	*/
d854 2
a855 1
		if (meta != TM_END) {
@


1.23
log
@fix a few name clashes with libc; found by lint. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.22 2005/03/30 17:16:37 deraadt Exp $	*/
a779 2
	char c = *s;

d782 4
a785 4
	return (c == 'a' && strcmp(s, "alias") == 0) ||
	    (c == 'e' && strcmp(s, "export") == 0) ||
	    (c == 'r' && strcmp(s, "readonly") == 0) ||
	    (c == 't' && strcmp(s, "typeset") == 0);
@


1.22
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.21 2005/03/28 21:33:04 deraadt Exp $	*/
d664 1
a664 1
	tinit(&keywords, APERM, 32); /* must be 2^n (currently 20 keywords) */
d667 1
a667 1
			p = tenter(&keywords, tt->name, hash(tt->name));
@


1.21
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.20 2004/12/22 17:14:34 millert Exp $	*/
d201 1
a201 1
					ATEMP);
d207 1
a207 1
	  default:
d214 2
a215 2
	  case LWORD:
	  case REDIR:
d221 2
a222 2
			cf = (t->u.evalflags ? ARRAYVAR : 0)
			     | (XPsize(args) == 0 ? ALIAS|VARASN : CMDWORD);
d224 1
a224 1
			  case REDIR:
d230 1
a230 1
			  case LWORD:
d235 3
a237 3
				if (iopn == 0 && XPsize(vars) == 0
				    && XPsize(args) == 0
				    && assign_command(ident))
d239 2
a240 2
				if ((XPsize(args) == 0 || Flag(FKEYWORD))
				    && is_wdvarassign(yylval.cp))
d246 1
a246 1
			  case '(':
d256 2
a257 2
				if (iopn != 0 || XPsize(args) != 1
				    || XPsize(vars) != 0)
d265 1
a265 1
			  default:
d273 1
a273 1
	  case '(':
d277 1
a277 1
	  case '{': /*}*/
d281 1
a281 1
	  case MDPAREN:
d283 4
a286 2
		static const char let_cmd[] = { CHAR, 'l', CHAR, 'e',
						CHAR, 't', EOS };
d297 1
a297 1
	  case DBRACKET: /* [[ .. ]] */
d315 2
a316 2
	  case FOR:
	  case SELECT:
d321 1
a321 1
				c == FOR ? "for" : "select");
d329 2
a330 2
	  case WHILE:
	  case UNTIL:
d338 1
a338 1
	  case CASE:
d347 1
a347 1
	  case IF:
d356 1
a356 1
	  case BANG:
d364 1
a364 1
	  case TIME:
d370 1
a370 1
	  case FUNCTION:
d388 1
a388 1
					sizeofN(struct ioword *, iopn), ATEMP);
d448 1
a448 1
	  case ELSE:
d453 1
a453 1
	  case ELIF:
d459 1
a459 1
	  default:
d784 4
a787 4
	return     (c == 'a' && strcmp(s, "alias") == 0)
		|| (c == 'e' && strcmp(s, "export") == 0)
		|| (c == 'r' && strcmp(s, "readonly") == 0)
		|| (c == 't' && strcmp(s, "typeset") == 0);
d845 2
a846 4
		if (meta == TM_BINOP && c == REDIR
		    && (yylval.iop->flag == IOREAD
			|| yylval.iop->flag == IOWRITE))
		{
d849 1
a849 1
				db_lthan : db_gthan, ATEMP);
d895 2
a896 2
		yylval.cp = *(XPptrv(*te->pos.av) + XPsize(*te->pos.av)
				+ offset);
@


1.20
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.19 2004/12/20 11:34:26 otto Exp $	*/
d810 3
a812 3
			dbtest_or, dbtest_and, dbtest_not,
			dbtest_oparen, dbtest_cparen
		};
@


1.19
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.18 2004/12/18 22:42:26 millert Exp $	*/
d185 1
a185 1
	t = c_list(TRUE);
d262 1
a262 1
				t = function_body(XPptrv(args)[0], FALSE);
d317 1
a317 1
		if (!is_wdvarname(yylval.cp, TRUE))
d331 1
a331 1
		t->left = c_list(TRUE);
d348 1
a348 1
		t->left = c_list(TRUE);
d370 1
a370 1
		t = function_body(yylval.cp, TRUE);
d421 1
a421 1
	list = c_list(TRUE);
d433 1
a433 1
	t->left = c_list(TRUE);
d447 1
a447 1
		if ((t = c_list(TRUE)) == NULL)
d453 1
a453 1
		t->left = c_list(TRUE);
d510 1
a510 1
	t->left = c_list(TRUE);
d625 20
a644 20
	{ "if",		IF,	TRUE },
	{ "then",	THEN,	TRUE },
	{ "else",	ELSE,	TRUE },
	{ "elif",	ELIF,	TRUE },
	{ "fi",		FI,	TRUE },
	{ "case",	CASE,	TRUE },
	{ "esac",	ESAC,	TRUE },
	{ "for",	FOR,	TRUE },
	{ "select",	SELECT,	TRUE },
	{ "while",	WHILE,	TRUE },
	{ "until",	UNTIL,	TRUE },
	{ "do",		DO,	TRUE },
	{ "done",	DONE,	TRUE },
	{ "in",		IN,	TRUE },
	{ "function",	FUNCTION, TRUE },
	{ "time",	TIME,	TRUE },
	{ "{",		'{',	TRUE },
	{ "}",		'}',	TRUE },
	{ "!",		BANG,	TRUE },
	{ "[[",		DBRACKET, TRUE },
d646 5
a650 5
	{ "&&",		LOGAND,	FALSE },
	{ "||",		LOGOR,	FALSE },
	{ ";;",		BREAK,	FALSE },
	{ "((",		MDPAREN, FALSE },
	{ "|&",		COPROC,	FALSE },
d652 1
a652 1
	{ "newline",	'\n',	FALSE },
@


1.18
log
@remove GCC_FUNC_ATTR/GCC_FUNC_ATTR2 and just use __attribute__ directly
(we define it away in sys/cdefs.h if it is not supported).
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.17 2004/12/18 21:25:44 millert Exp $	*/
d16 1
a16 1
static struct op *pipeline(int cf);
d18 5
a22 5
static struct op *c_list(int multi);
static struct ioword *synio(int cf);
static void	musthave(int c, int cf);
static struct op *nested(int type, int smark, int emark);
static struct op *get_command(int cf);
d27 2
a28 2
static struct op *casepart(int endtok);
static struct op *function_body(char *name, int ksh_func);
d30 12
a41 13
static struct op *block(int type, struct op *t1, struct op *t2, char **wp);
static struct op *newtp(int type);
static void	syntaxerr(const char *what)
		    __attribute__((__noreturn__));
static void	nesting_push(struct nesting_state *save, int tok);
static void	nesting_pop(struct nesting_state *saved);
static int	assign_command(char *s);
static int	inalias(struct source *s);
static int	dbtestp_isa(Test_env *te, Test_meta meta);
static const char *dbtestp_getopnd(Test_env *te, Test_op op, int do_eval);
static int	dbtestp_eval(Test_env *te, Test_op op, const char *opnd1,
				const char *opnd2, int do_eval);
static void	dbtestp_error(Test_env *te, int offset, const char *msg);
d58 1
a58 1
yyparse()
d73 1
a73 2
pipeline(cf)
	int cf;
d93 1
a93 1
andor()
d111 1
a111 2
c_list(multi)
	int multi;
d148 1
a148 2
synio(cf)
	int cf;
d172 1
a172 2
musthave(c, cf)
	int c, cf;
d179 1
a179 2
nested(type, smark, emark)
	int type, smark, emark;
d192 1
a192 2
get_command(cf)
	int cf;
d404 1
a404 1
dogroup()
d427 1
a427 1
thenpart()
d441 1
a441 1
elsepart()
d464 1
a464 1
caselist()
d490 1
a490 2
casepart(endtok)
	int endtok;
d518 2
a519 3
function_body(name, ksh_func)
	char *name;
	int ksh_func;	/* function foo { ... } vs foo() { .. } */
d578 1
a578 1
wordlist()
d608 1
a608 4
block(type, t1, t2, wp)
	int type;
	struct op *t1, *t2;
	char **wp;
d657 1
a657 1
initkeywords()
d674 1
a674 2
syntaxerr(what)
	const char *what;
d726 1
a726 3
nesting_push(save, tok)
	struct nesting_state *save;
	int tok;
d734 1
a734 2
nesting_pop(saved)
	struct nesting_state *saved;
d740 1
a740 2
newtp(type)
	int type;
d755 1
a755 2
compile(s)
	Source *s;
d776 1
a776 2
assign_command(s)
	char *s;
d790 1
a790 2
inalias(s)
	struct source *s;
d822 1
a822 3
dbtestp_isa(te, meta)
	Test_env *te;
	Test_meta meta;
d866 1
a866 4
dbtestp_getopnd(te, op, do_eval)
	Test_env *te;
	Test_op op;
	int do_eval;
d880 2
a881 6
dbtestp_eval(te, op, opnd1, opnd2, do_eval)
	Test_env *te;
	Test_op op;
	const char *opnd1;
	const char *opnd2;
	int do_eval;
d887 1
a887 4
dbtestp_error(te, offset, msg)
	Test_env *te;
	int offset;
	const char *msg;
@


1.17
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.16 2004/12/18 21:04:52 millert Exp $	*/
d30 1
a30 2
static struct op *block(int type, struct op *t1, struct op *t2,
				      char **wp);
d33 1
a33 1
						GCC_FUNC_ATTR(noreturn);
@


1.16
log
@Get rid of #ifdef KSH since we don't care about building a V7 style sh and
the #ifdef KSH code is required to make a POSIX sh.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.15 2004/12/18 20:55:52 millert Exp $	*/
d78 1
a78 1
	register struct op *t, *p, *tl = NULL;
d98 2
a99 2
	register struct op *t, *p;
	register int c;
d117 2
a118 2
	register struct op *t = NULL, *p, *tl = NULL;
	register int c;
d155 1
a155 1
	register struct ioword *iop;
d188 1
a188 1
	register struct op *t;
d202 2
a203 2
	register struct op *t;
	register int c, iopn = 0, syniocf;
d414 2
a415 2
	register int c;
	register struct op *list;
d437 1
a437 1
	register struct op *t;
d451 1
a451 1
	register struct op *t;
d474 1
a474 1
	register struct op *t, *tl;
d501 2
a502 2
	register struct op *t;
	register int c;
d590 1
a590 1
	register int c;
d623 1
a623 1
	register struct op *t;
d672 2
a673 2
	register struct tokeninfo const *tt;
	register struct tbl *p;
d760 1
a760 1
	register struct op *t;
@


1.15
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.14 2003/10/22 07:40:38 jmc Exp $	*/
a38 1
#ifdef KSH
a43 1
#endif /* KSH */
a288 1
#ifdef KSH
a301 1
#endif /* KSH */
a302 1
#ifdef KSH
a319 1
#endif /* KSH */
a645 1
#ifdef KSH
a646 1
#endif /* KSH */
a656 1
#ifdef KSH
a657 1
#endif /* KSH */
a661 1
#ifdef KSH
a663 1
#endif /* KSH */
a819 1
#ifdef KSH
a932 1
#endif /* KSH */
@


1.14
log
@typos from Jared Yanovich;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.13 2002/06/09 05:47:27 todd Exp $	*/
d15 19
a33 19
static void	yyparse		ARGS((void));
static struct op *pipeline	ARGS((int cf));
static struct op *andor		ARGS((void));
static struct op *c_list	ARGS((int multi));
static struct ioword *synio	ARGS((int cf));
static void	musthave	ARGS((int c, int cf));
static struct op *nested	ARGS((int type, int smark, int emark));
static struct op *get_command	ARGS((int cf));
static struct op *dogroup	ARGS((void));
static struct op *thenpart	ARGS((void));
static struct op *elsepart	ARGS((void));
static struct op *caselist	ARGS((void));
static struct op *casepart	ARGS((int endtok));
static struct op *function_body	ARGS((char *name, int ksh_func));
static char **	wordlist	ARGS((void));
static struct op *block		ARGS((int type, struct op *t1, struct op *t2,
				      char **wp));
static struct op *newtp		ARGS((int type));
static void	syntaxerr	ARGS((const char *what))
d35 4
a38 4
static void	nesting_push ARGS((struct nesting_state *save, int tok));
static void	nesting_pop ARGS((struct nesting_state *saved));
static int	assign_command ARGS((char *s));
static int	inalias ARGS((struct source *s));
d40 5
a44 6
static int	dbtestp_isa ARGS((Test_env *te, Test_meta meta));
static const char *dbtestp_getopnd ARGS((Test_env *te, Test_op op,
					int do_eval));
static int	dbtestp_eval ARGS((Test_env *te, Test_op op, const char *opnd1,
				const char *opnd2, int do_eval));
static void	dbtestp_error ARGS((Test_env *te, int offset, const char *msg));
@


1.13
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.12 1999/06/15 01:18:36 millert Exp $	*/
d574 1
a574 1
		 * To make "typset -f foo" work reliably (so its output can
@


1.12
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.11 1998/10/29 04:09:21 millert Exp $	*/
d805 1
a805 1
 *	$ 
@


1.11
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.10 1998/10/09 16:21:36 millert Exp $	*/
d230 1
d299 1
d556 1
d586 1
@


1.10
log
@Initialize the correct fields when creating an empty command.  Fixes bug where a
function with no body ( e.g. "testfun () ;" ) would cause ksh to segfault when
it was called.  Eric Haszlakiewicz <erh@@netbsd.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.9 1998/06/25 19:02:20 millert Exp $	*/
d568 6
a573 1
		/* create empty command so foo(): will work */
d575 6
a580 2
		t->left->args = (char **) alloc(sizeof(char *), ATEMP);
		t->left->args[0] = (char *) 0;
@


1.9
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.8 1997/09/01 18:30:12 deraadt Exp $	*/
d570 4
a573 4
		t->args = (char **) alloc(sizeof(char *), ATEMP);
		t->args[0] = (char *) 0;
		t->vars = (char **) alloc(sizeof(char *), ATEMP);
		t->vars[0] = (char *) 0;
@


1.8
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.7 1997/06/19 13:58:47 kstailey Exp $	*/
d10 3
a12 4
struct multiline_state {
	int	on;		/* set in multiline commands (\n becomes ;) */
	int	start_token;	/* token multiline is for (eg, FOR, {, etc.) */
	int	start_line;	/* line multiline command started on */
d18 1
a18 1
static struct op *c_list	ARGS((void));
d35 2
a36 2
static void	multiline_push ARGS((struct multiline_state *save, int tok));
static void	multiline_pop ARGS((struct multiline_state *saved));
d50 1
a50 1
static struct multiline_state multiline;	/* \n changed to ; */
a67 1
	yynerrs = 0;
d69 1
a69 1
	outtree = c_list();
d117 2
a118 1
c_list()
d120 1
a120 1
	register struct op *t, *p, *tl = NULL;
d122 1
d124 2
a125 2
	t = andor();
	if (t != NULL) {
d127 1
a127 1
		 * we don't worray about what flags to pass token()
d129 20
a148 19
		while ((c = token(0)) == ';' || c == '&' || c == COPROC ||
		       (c == '\n' && (multiline.on || inalias(source))))
		{
			if (c == '&' || c == COPROC) {
				int type = c == '&' ? TASYNC : TCOPROC;
				if (tl)
					tl->right = block(type, tl->right,
							  NOBLOCK, NOWORDS);
				else
					t = block(type, t, NOBLOCK, NOWORDS);
			}
			if ((p = andor()) == NULL)
				return (t);
			if (tl == NULL)
				t = tl = block(TLIST, t, p, NOWORDS);
			else
				tl = tl->right = block(TLIST, tl->right, p, NOWORDS);
		}
		REJECT;
d150 2
a151 1
	return (t);
d192 1
a192 1
	struct multiline_state old_multiline;
d194 2
a195 2
	multiline_push(&old_multiline, smark);
	t = c_list();
d197 1
a197 1
	multiline_pop(&old_multiline);
d209 1
a209 1
	struct multiline_state old_multiline;
a215 5
	/* Don't want to pass CONTIN if reading interactively as just hitting
	 * return would print PS2 instead of PS1.
	 */
	if (multiline.on || inalias(source))
		cf = CONTIN;
d296 1
a296 1
		syniocf &= ~(KEYWORD|ALIAS);
d308 1
a308 1
		syniocf &= ~(KEYWORD|ALIAS);
d334 1
a334 1
		multiline_push(&old_multiline, c);
d337 1
a337 1
		multiline_pop(&old_multiline);
d342 1
a342 1
		multiline_push(&old_multiline, c);
d344 1
a344 1
		t->left = c_list();
d346 1
a346 1
		multiline_pop(&old_multiline);
d353 1
a353 1
		multiline_push(&old_multiline, c);
d355 1
a355 1
		multiline_pop(&old_multiline);
d359 1
a359 1
		multiline_push(&old_multiline, c);
d361 1
a361 1
		t->left = c_list();
d364 1
a364 1
		multiline_pop(&old_multiline);
d434 1
a434 1
	list = c_list();
d446 1
a446 1
	t->left = c_list();
d460 1
a460 1
		if ((t = c_list()) == NULL)
d466 1
a466 1
		t->left = c_list();
d524 2
a525 1
	t->left = c_list();
d536 1
a536 2
	XString xs;
	char *xp, *p;
d540 11
a550 19
	Xinit(xs, xp, 16, ATEMP);
	for (p = name; ; ) {
		if ((*p == EOS && Xlength(xs, xp) == 0)
		    || (*p != EOS && *p != CHAR && *p != QCHAR
			&& *p != OQUOTE && *p != CQUOTE))
		{
			p = snptreef((char *) 0, 32, "%S", name);
			yyerror("%s: invalid function name\n", p);
		}
		Xcheck(xs, xp);
		if (*p == EOS) {
			Xput(xs, xp, '\0');
			break;
		} else if (*p == CHAR || *p == QCHAR) {
			Xput(xs, xp, p[1]);
			p += 2;
		} else
			p++;	/* OQUOTE/CQUOTE */
	}
d552 1
a552 1
	t->str = Xclose(xs, xp);
d588 1
d702 3
a704 4
		if (multiline.on && multiline.start_token) {
			multiline.on = FALSE; /* avoid infinate loops */
			c = multiline.start_token;
			source->errline = multiline.start_line;
d740 2
a741 2
multiline_push(save, tok)
	struct multiline_state *save;
d744 3
a746 4
	*save = multiline;
	multiline.on = TRUE;
	multiline.start_token = tok;
	multiline.start_line = source->line;
d750 2
a751 2
multiline_pop(saved)
	struct multiline_state *saved;
d753 1
a753 1
	multiline = *saved;
d776 2
a777 4
	yynerrs = 0;
	multiline.on = s->type == SSTRING;
	multiline.start_token = 0;
	multiline.start_line = 0;
d792 1
a792 1
 *	$
@


1.7
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.5 1996/11/21 07:59:35 downsj Exp $	*/
d806 1
a806 1
 *	$ 
@


1.6
log
@(foo *)0 -> NULL
@
text
@d76 1
a76 1
		syntaxerr(NULL);
d89 1
a89 1
				syntaxerr(NULL);
d110 1
a110 1
				syntaxerr(NULL);
d182 1
a182 1
		syntaxerr(NULL);
d271 1
a271 1
					syntaxerr(NULL);
d373 2
a374 2
		if (t == NULL)
			syntaxerr(NULL);
d436 1
a436 1
		syntaxerr(NULL);
d451 1
a451 1
		syntaxerr(NULL);
d464 1
a464 1
			syntaxerr(NULL);
d492 1
a492 1
		syntaxerr(NULL);
d549 1
a549 1
			p = snptreef(NULL, 32, "%S", name);
d578 1
a578 1
	if ((t->left = get_command(CONTIN)) == NULL) {
d582 1
a582 1
		t->args[0] = NULL;
d584 1
a584 1
		t->vars[0] = NULL;
d607 1
a607 1
		syntaxerr(NULL);
d724 1
a724 1
		s = snptreef(NULL, 32, "%S", yylval.cp);
d864 1
a864 1
	char *save = NULL;
d912 1
a912 1
		return NULL;
@


1.5
log
@Update to 5.2.12.
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.4 1996/10/13 21:32:20 downsj Exp $	*/
d76 1
a76 1
		syntaxerr((char *) 0);
d89 1
a89 1
				syntaxerr((char *) 0);
d110 1
a110 1
				syntaxerr((char *) 0);
d182 1
a182 1
		syntaxerr((char *) 0);
d271 1
a271 1
					syntaxerr((char *) 0);
d373 2
a374 2
		if (t == (struct op *) 0)
			syntaxerr((char *) 0);
d436 1
a436 1
		syntaxerr((char *) 0);
d451 1
a451 1
		syntaxerr((char *) 0);
d464 1
a464 1
			syntaxerr((char *) 0);
d492 1
a492 1
		syntaxerr((char *) 0);
d549 1
a549 1
			p = snptreef((char *) 0, 32, "%S", name);
d578 1
a578 1
	if ((t->left = get_command(CONTIN)) == (struct op *) 0) {
d582 1
a582 1
		t->args[0] = (char *) 0;
d584 1
a584 1
		t->vars[0] = (char *) 0;
d607 1
a607 1
		syntaxerr((char *) 0);
d724 1
a724 1
		s = snptreef((char *) 0, 32, "%S", yylval.cp);
d864 1
a864 1
	char *save = (char *) 0;
d912 1
a912 1
		return (const char *) 0;
@


1.4
log
@Update to version 5.2.11.
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.3 1996/10/01 02:05:50 downsj Exp $	*/
d126 3
d214 4
a217 1
	if (multiline.on)
@


1.3
log
@Integrate pdksh 5.2.9.
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.2 1996/08/19 20:08:59 downsj Exp $	*/
d39 1
d127 1
a127 1
		       (c == '\n' && (multiline.on || source->type == SALIAS)))
d814 11
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
d287 1
d300 1
d663 1
a664 1
#ifdef KSH
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d227 1
a227 1
			cf = (t->evalflags ? ARRAYVAR : 0)
d244 1
a244 1
					t->evalflags = DOVACHECK;
d257 1
a257 1
				if (XPsize(args) == 0 && XPsize(vars) != 0) {
d337 1
a337 1
		t = newtp((c == WHILE) ? TWHILE: TUNTIL);
d555 1
d767 1
a767 1
	t->evalflags = 0;
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
