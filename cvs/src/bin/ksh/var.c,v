head	1.59;
access;
symbols
	OPENBSD_6_1:1.57.0.4
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.55.0.4
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.38.0.6
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.34.0.22
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.20
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.18
	OPENBSD_5_0:1.34.0.16
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.14
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.12
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.8
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.34.0.10
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.6
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.4
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.30.0.4
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.11.0.8
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.6
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.10.0.6
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.59
date	2017.08.30.17.08.45;	author jca;	state Exp;
branches;
next	1.58;
commitid	DWdXJvJqVZz6aoxS;

1.58
date	2017.08.30.10.18.48;	author jca;	state Exp;
branches;
next	1.57;
commitid	PaIzLEAvflJLMB94;

1.57
date	2016.09.08.15.50.50;	author millert;	state Exp;
branches;
next	1.56;
commitid	tgOuRGlXTus1h8vm;

1.56
date	2016.09.08.15.47.16;	author millert;	state Exp;
branches;
next	1.55;
commitid	nkPgtaPAJntHWnMG;

1.55
date	2015.12.30.09.07.00;	author tedu;	state Exp;
branches;
next	1.54;
commitid	WTwPzlskFufQpRQz;

1.54
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.53;
commitid	btTCreDA00YdaFhU;

1.53
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.52;
commitid	C4W85jmosThChWA2;

1.52
date	2015.10.19.14.03.21;	author mmcc;	state Exp;
branches;
next	1.51;
commitid	TSZF0K3aGmPbKQzz;

1.51
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.50;
commitid	16HUr75moyUNtKR8;

1.50
date	2015.09.22.21.50.40;	author millert;	state Exp;
branches;
next	1.49;
commitid	ZWmS69dzJnkF6rox;

1.49
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.48;
commitid	7fgq4YTZG4xZ0uN0;

1.48
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.47;
commitid	v5QjoxUgKU2iUTFz;

1.47
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.46;
commitid	lBs9un9sXhbdfVrQ;

1.46
date	2015.09.14.16.08.50;	author nicm;	state Exp;
branches;
next	1.45;
commitid	ahedYHs8fav8xOPq;

1.45
date	2015.09.14.09.42.33;	author nicm;	state Exp;
branches;
next	1.44;
commitid	HNyoYgRIsBj18EIi;

1.44
date	2015.09.10.11.37.42;	author jca;	state Exp;
branches;
next	1.43;
commitid	e6KeWjLWemmUTNyf;

1.43
date	2015.09.01.13.12.31;	author tedu;	state Exp;
branches;
next	1.42;
commitid	sKGEDet4KOfGjsIb;

1.42
date	2015.08.19.16.05.46;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	NIv80jflLWtOyoD4;

1.41
date	2015.04.17.17.20.41;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	TNm3GZeTBmyuDaL0;

1.40
date	2014.12.12.05.00.55;	author jsg;	state Exp;
branches;
next	1.39;
commitid	3lVJgiUzshc3oAea;

1.39
date	2014.12.08.21.48.27;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	JFCMhIp0ZJ7U6ccm;

1.38
date	2013.12.20.17.53.09;	author zhuk;	state Exp;
branches;
next	1.37;

1.37
date	2013.12.18.13.53.12;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2013.12.17.16.37.06;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2013.04.05.01.31.30;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.15.02.16.35;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2007.08.02.11.05.54;	author fgsch;	state Exp;
branches;
next	1.32;

1.32
date	2007.08.02.10.56.25;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.02.10.50.25;	author fgsch;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.21.18.40.39;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.13.08.21.37;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.11.20.31.21;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.08.18.02.59;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.28.21.33.04;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.28.21.28.22;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.02.07.53.01;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.18.21.04.52;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.08.19.42.35;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.05.20.52.27;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.26.00.09.45;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.16.23.11.52;	author tdeval;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.13.09.03.07;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.21.23.12.04;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.06.15.01.18.36;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.01.10.17.55.03;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.01.08.20.25.02;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.06.25.19.02.27;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.09.01.18.30.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.06.19.13.58.49;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.06.18.22.42.48;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.10.01.02.05.53;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.09.02;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.12;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.12;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.59
log
@Implement HISTCONTROL ignoredups & ignorespace features

ignoredups: don't save the current line if it is identical to the last
history line.
ignorespace: don't save the current line if it starts with a space

ok anton@@ millert@@
@
text
@/*	$OpenBSD: var.c,v 1.58 2017/08/30 10:18:48 jca Exp $	*/

#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "sh.h"

/*
 * Variables
 *
 * WARNING: unreadable code, needs a rewrite
 *
 * if (flag&INTEGER), val.i contains integer value, and type contains base.
 * otherwise, (val.s + type) contains string value.
 * if (flag&EXPORT), val.s contains "name=value" for E-Z exporting.
 */
static	struct tbl vtemp;
static	struct table specials;
static char	*formatstr(struct tbl *, const char *);
static void	export(struct tbl *, const char *);
static int	special(const char *);
static void	unspecial(const char *);
static void	getspec(struct tbl *);
static void	setspec(struct tbl *);
static void	unsetspec(struct tbl *);
static struct tbl *arraysearch(struct tbl *, int);

/*
 * create a new block for function calls and simple commands
 * assume caller has allocated and set up genv->loc
 */
void
newblock(void)
{
	struct block *l;
	static char *const empty[] = {null};

	l = alloc(sizeof(struct block), ATEMP);
	l->flags = 0;
	ainit(&l->area); /* todo: could use genv->area (l->area => l->areap) */
	if (!genv->loc) {
		l->argc = 0;
		l->argv = (char **) empty;
	} else {
		l->argc = genv->loc->argc;
		l->argv = genv->loc->argv;
	}
	l->exit = l->error = NULL;
	ktinit(&l->vars, &l->area, 0);
	ktinit(&l->funs, &l->area, 0);
	l->next = genv->loc;
	genv->loc = l;
}

/*
 * pop a block handling special variables
 */
void
popblock(void)
{
	struct block *l = genv->loc;
	struct tbl *vp, **vpp = l->vars.tbls, *vq;
	int i;

	genv->loc = l->next;	/* pop block */
	for (i = l->vars.size; --i >= 0; )
		if ((vp = *vpp++) != NULL && (vp->flag&SPECIAL)) {
			if ((vq = global(vp->name))->flag & ISSET)
				setspec(vq);
			else
				unsetspec(vq);
		}
	if (l->flags & BF_DOGETOPTS)
		user_opt = l->getopts_state;
	afreeall(&l->area);
	afree(l, ATEMP);
}

/* called by main() to initialize variable data structures */
void
initvar(void)
{
	static const struct {
		const char *name;
		int v;
	} names[] = {
		{ "COLUMNS",		V_COLUMNS },
		{ "IFS",		V_IFS },
		{ "OPTIND",		V_OPTIND },
		{ "PATH",		V_PATH },
		{ "POSIXLY_CORRECT",	V_POSIXLY_CORRECT },
		{ "TMPDIR",		V_TMPDIR },
#ifdef HISTORY
		{ "HISTCONTROL",	V_HISTCONTROL },
		{ "HISTFILE",		V_HISTFILE },
		{ "HISTSIZE",		V_HISTSIZE },
#endif /* HISTORY */
#ifdef EDIT
		{ "EDITOR",		V_EDITOR },
		{ "VISUAL",		V_VISUAL },
#endif /* EDIT */
		{ "MAIL",		V_MAIL },
		{ "MAILCHECK",		V_MAILCHECK },
		{ "MAILPATH",		V_MAILPATH },
		{ "RANDOM",		V_RANDOM },
		{ "SECONDS",		V_SECONDS },
		{ "TMOUT",		V_TMOUT },
		{ "LINENO",		V_LINENO },
		{ NULL,	0 }
	};
	int i;
	struct tbl *tp;

	ktinit(&specials, APERM, 32); /* must be 2^n (currently 17 specials) */
	for (i = 0; names[i].name; i++) {
		tp = ktenter(&specials, names[i].name, hash(names[i].name));
		tp->flag = DEFINED|ISSET;
		tp->type = names[i].v;
	}
}

/* Used to calculate an array index for global()/local().  Sets *arrayp to
 * non-zero if this is an array, sets *valp to the array index, returns
 * the basename of the array.
 */
static const char *
array_index_calc(const char *n, bool *arrayp, int *valp)
{
	const char *p;
	int len;

	*arrayp = false;
	p = skip_varname(n, false);
	if (p != n && *p == '[' && (len = array_ref_len(p))) {
		char *sub, *tmp;
		long rval;

		/* Calculate the value of the subscript */
		*arrayp = true;
		tmp = str_nsave(p+1, len-2, ATEMP);
		sub = substitute(tmp, 0);
		afree(tmp, ATEMP);
		n = str_nsave(n, p - n, ATEMP);
		evaluate(sub, &rval, KSH_UNWIND_ERROR, true);
		if (rval < 0 || rval > INT_MAX)
			errorf("%s: subscript %ld out of range", n, rval);
		*valp = rval;
		afree(sub, ATEMP);
	}
	return n;
}

/*
 * Search for variable, if not found create globally.
 */
struct tbl *
global(const char *n)
{
	struct block *l = genv->loc;
	struct tbl *vp;
	long	 num;
	int c;
	unsigned int h;
	bool	 array;
	int	 val;

	/* Check to see if this is an array */
	n = array_index_calc(n, &array, &val);
	h = hash(n);
	c = (unsigned char)n[0];
	if (!letter(c)) {
		if (array)
			errorf("bad substitution");
		vp = &vtemp;
		vp->flag = DEFINED;
		vp->type = 0;
		vp->areap = ATEMP;
		*vp->name = c;
		if (digit(c)) {
			errno = 0;
			num = strtol(n, NULL, 10);
			if (errno == 0 && num <= l->argc)
				/* setstr can't fail here */
				setstr(vp, l->argv[num], KSH_RETURN_ERROR);
			vp->flag |= RDONLY;
			return vp;
		}
		vp->flag |= RDONLY;
		if (n[1] != '\0')
			return vp;
		vp->flag |= ISSET|INTEGER;
		switch (c) {
		case '$':
			vp->val.i = kshpid;
			break;
		case '!':
			/* If no job, expand to nothing */
			if ((vp->val.i = j_async()) == 0)
				vp->flag &= ~(ISSET|INTEGER);
			break;
		case '?':
			vp->val.i = exstat;
			break;
		case '#':
			vp->val.i = l->argc;
			break;
		case '-':
			vp->flag &= ~INTEGER;
			vp->val.s = getoptions();
			break;
		default:
			vp->flag &= ~(ISSET|INTEGER);
		}
		return vp;
	}
	for (l = genv->loc; ; l = l->next) {
		vp = ktsearch(&l->vars, n, h);
		if (vp != NULL) {
			if (array)
				return arraysearch(vp, val);
			else
				return vp;
		}
		if (l->next == NULL)
			break;
	}
	vp = ktenter(&l->vars, n, h);
	if (array)
		vp = arraysearch(vp, val);
	vp->flag |= DEFINED;
	if (special(n))
		vp->flag |= SPECIAL;
	return vp;
}

/*
 * Search for local variable, if not found create locally.
 */
struct tbl *
local(const char *n, bool copy)
{
	struct block *l = genv->loc;
	struct tbl *vp;
	unsigned int h;
	bool	 array;
	int	 val;

	/* Check to see if this is an array */
	n = array_index_calc(n, &array, &val);
	h = hash(n);
	if (!letter(*n)) {
		vp = &vtemp;
		vp->flag = DEFINED|RDONLY;
		vp->type = 0;
		vp->areap = ATEMP;
		return vp;
	}
	vp = ktenter(&l->vars, n, h);
	if (copy && !(vp->flag & DEFINED)) {
		struct block *ll = l;
		struct tbl *vq = NULL;

		while ((ll = ll->next) && !(vq = ktsearch(&ll->vars, n, h)))
			;
		if (vq) {
			vp->flag |= vq->flag &
			    (EXPORT | INTEGER | RDONLY | LJUST | RJUST |
			    ZEROFIL | LCASEV | UCASEV_AL | INT_U | INT_L);
			if (vq->flag & INTEGER)
				vp->type = vq->type;
			vp->u2.field = vq->u2.field;
		}
	}
	if (array)
		vp = arraysearch(vp, val);
	vp->flag |= DEFINED;
	if (special(n))
		vp->flag |= SPECIAL;
	return vp;
}

/* get variable string value */
char *
str_val(struct tbl *vp)
{
	char *s;

	if ((vp->flag&SPECIAL))
		getspec(vp);
	if (!(vp->flag&ISSET))
		s = null;		/* special to dollar() */
	else if (!(vp->flag&INTEGER))	/* string source */
		s = vp->val.s + vp->type;
	else {				/* integer source */
		/* worst case number length is when base=2, so use BITS(long) */
		/* minus base #     number    null */
		char strbuf[1 + 2 + 1 + BITS(long) + 1];
		const char *digits = (vp->flag & UCASEV_AL) ?
		    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" :
		    "0123456789abcdefghijklmnopqrstuvwxyz";
		unsigned long n;
		int base;

		s = strbuf + sizeof(strbuf);
		if (vp->flag & INT_U)
			n = (unsigned long) vp->val.i;
		else
			n = (vp->val.i < 0) ? -vp->val.i : vp->val.i;
		base = (vp->type == 0) ? 10 : vp->type;
		if (base < 2 || base > strlen(digits))
			base = 10;

		*--s = '\0';
		do {
			*--s = digits[n % base];
			n /= base;
		} while (n != 0);
		if (base != 10) {
			*--s = '#';
			*--s = digits[base % 10];
			if (base >= 10)
				*--s = digits[base / 10];
		}
		if (!(vp->flag & INT_U) && vp->val.i < 0)
			*--s = '-';
		if (vp->flag & (RJUST|LJUST)) /* case already dealt with */
			s = formatstr(vp, s);
		else
			s = str_save(s, ATEMP);
	}
	return s;
}

/* get variable integer value, with error checking */
long
intval(struct tbl *vp)
{
	long num;
	int base;

	base = getint(vp, &num, false);
	if (base == -1)
		/* XXX check calls - is error here ok by POSIX? */
		errorf("%s: bad number", str_val(vp));
	return num;
}

/* set variable to string value */
int
setstr(struct tbl *vq, const char *s, int error_ok)
{
	const char *fs = NULL;
	int no_ro_check = error_ok & KSH_IGNORE_RDONLY;
	error_ok &= ~KSH_IGNORE_RDONLY;
	if ((vq->flag & RDONLY) && !no_ro_check) {
		warningf(true, "%s: is read only", vq->name);
		if (!error_ok)
			errorf(NULL);
		return 0;
	}
	if (!(vq->flag&INTEGER)) { /* string dest */
		if ((vq->flag&ALLOC)) {
			/* debugging */
			if (s >= vq->val.s &&
			    s <= vq->val.s + strlen(vq->val.s))
				internal_errorf(true,
				    "setstr: %s=%s: assigning to self",
				    vq->name, s);
			afree(vq->val.s, vq->areap);
		}
		vq->flag &= ~(ISSET|ALLOC);
		vq->type = 0;
		if (s && (vq->flag & (UCASEV_AL|LCASEV|LJUST|RJUST)))
			fs = s = formatstr(vq, s);
		if ((vq->flag&EXPORT))
			export(vq, s);
		else {
			vq->val.s = str_save(s, vq->areap);
			vq->flag |= ALLOC;
		}
	} else {		/* integer dest */
		if (!v_evaluate(vq, s, error_ok, true))
			return 0;
	}
	vq->flag |= ISSET;
	if ((vq->flag&SPECIAL))
		setspec(vq);
	afree((void *)fs, ATEMP);
	return 1;
}

/* set variable to integer */
void
setint(struct tbl *vq, long int n)
{
	if (!(vq->flag&INTEGER)) {
		struct tbl *vp = &vtemp;
		vp->flag = (ISSET|INTEGER);
		vp->type = 0;
		vp->areap = ATEMP;
		vp->val.i = n;
		/* setstr can't fail here */
		setstr(vq, str_val(vp), KSH_RETURN_ERROR);
	} else
		vq->val.i = n;
	vq->flag |= ISSET;
	if ((vq->flag&SPECIAL))
		setspec(vq);
}

int
getint(struct tbl *vp, long int *nump, bool arith)
{
	char *s;
	int c;
	int base, neg;
	int have_base = 0;
	long num;

	if (vp->flag&SPECIAL)
		getspec(vp);
	/* XXX is it possible for ISSET to be set and val.s to be 0? */
	if (!(vp->flag&ISSET) || (!(vp->flag&INTEGER) && vp->val.s == NULL))
		return -1;
	if (vp->flag&INTEGER) {
		*nump = vp->val.i;
		return vp->type;
	}
	s = vp->val.s + vp->type;
	if (s == NULL)	/* redundant given initial test */
		s = null;
	base = 10;
	num = 0;
	neg = 0;
	if (arith && *s == '0' && *(s+1)) {
		s++;
		if (*s == 'x' || *s == 'X') {
			s++;
			base = 16;
		} else if (vp->flag & ZEROFIL) {
			while (*s == '0')
				s++;
		} else
			base = 8;
		have_base++;
	}
	for (c = (unsigned char)*s++; c ; c = (unsigned char)*s++) {
		if (c == '-') {
			neg++;
		} else if (c == '#') {
			base = (int) num;
			if (have_base || base < 2 || base > 36)
				return -1;
			num = 0;
			have_base = 1;
		} else if (letnum(c)) {
			if (isdigit(c))
				c -= '0';
			else if (islower(c))
				c -= 'a' - 10; /* todo: assumes ascii */
			else if (isupper(c))
				c -= 'A' - 10; /* todo: assumes ascii */
			else
				c = -1; /* _: force error */
			if (c < 0 || c >= base)
				return -1;
			num = num * base + c;
		} else
			return -1;
	}
	if (neg)
		num = -num;
	*nump = num;
	return base;
}

/* convert variable vq to integer variable, setting its value from vp
 * (vq and vp may be the same)
 */
struct tbl *
setint_v(struct tbl *vq, struct tbl *vp, bool arith)
{
	int base;
	long num;

	if ((base = getint(vp, &num, arith)) == -1)
		return NULL;
	if (!(vq->flag & INTEGER) && (vq->flag & ALLOC)) {
		vq->flag &= ~ALLOC;
		afree(vq->val.s, vq->areap);
	}
	vq->val.i = num;
	if (vq->type == 0) /* default base */
		vq->type = base;
	vq->flag |= ISSET|INTEGER;
	if (vq->flag&SPECIAL)
		setspec(vq);
	return vq;
}

static char *
formatstr(struct tbl *vp, const char *s)
{
	int olen, nlen;
	char *p, *q;

	olen = strlen(s);

	if (vp->flag & (RJUST|LJUST)) {
		if (!vp->u2.field)	/* default field width */
			vp->u2.field = olen;
		nlen = vp->u2.field;
	} else
		nlen = olen;

	p = alloc(nlen + 1, ATEMP);
	if (vp->flag & (RJUST|LJUST)) {
		int slen;

		if (vp->flag & RJUST) {
			const char *q = s + olen;
			/* strip trailing spaces (at&t ksh uses q[-1] == ' ') */
			while (q > s && isspace((unsigned char)q[-1]))
				--q;
			slen = q - s;
			if (slen > vp->u2.field) {
				s += slen - vp->u2.field;
				slen = vp->u2.field;
			}
			shf_snprintf(p, nlen + 1,
				((vp->flag & ZEROFIL) && digit(*s)) ?
					  "%0*s%.*s" : "%*s%.*s",
				vp->u2.field - slen, null, slen, s);
		} else {
			/* strip leading spaces/zeros */
			while (isspace((unsigned char)*s))
				s++;
			if (vp->flag & ZEROFIL)
				while (*s == '0')
					s++;
			shf_snprintf(p, nlen + 1, "%-*.*s",
				vp->u2.field, vp->u2.field, s);
		}
	} else
		memcpy(p, s, olen + 1);

	if (vp->flag & UCASEV_AL) {
		for (q = p; *q; q++)
			if (islower((unsigned char)*q))
				*q = toupper((unsigned char)*q);
	} else if (vp->flag & LCASEV) {
		for (q = p; *q; q++)
			if (isupper((unsigned char)*q))
				*q = tolower((unsigned char)*q);
	}

	return p;
}

/*
 * make vp->val.s be "name=value" for quick exporting.
 */
static void
export(struct tbl *vp, const char *val)
{
	char *xp;
	char *op = (vp->flag&ALLOC) ? vp->val.s : NULL;
	int namelen = strlen(vp->name);
	int vallen = strlen(val) + 1;

	vp->flag |= ALLOC;
	xp = alloc(namelen + 1 + vallen, vp->areap);
	memcpy(vp->val.s = xp, vp->name, namelen);
	xp += namelen;
	*xp++ = '=';
	vp->type = xp - vp->val.s; /* offset to value */
	memcpy(xp, val, vallen);
	afree(op, vp->areap);
}

/*
 * lookup variable (according to (set&LOCAL)),
 * set its attributes (INTEGER, RDONLY, EXPORT, TRACE, LJUST, RJUST, ZEROFIL,
 * LCASEV, UCASEV_AL), and optionally set its value if an assignment.
 */
struct tbl *
typeset(const char *var, int set, int clr, int field, int base)
{
	struct tbl *vp;
	struct tbl *vpbase, *t;
	char *tvar;
	const char *val;

	/* check for valid variable name, search for value */
	val = skip_varname(var, false);
	if (val == var)
		return NULL;
	if (*val == '[') {
		int len;

		len = array_ref_len(val);
		if (len == 0)
			return NULL;
		/* IMPORT is only used when the shell starts up and is
		 * setting up its environment.  Allow only simple array
		 * references at this time since parameter/command substitution
		 * is preformed on the [expression], which would be a major
		 * security hole.
		 */
		if (set & IMPORT) {
			int i;
			for (i = 1; i < len - 1; i++)
				if (!digit(val[i]))
					return NULL;
		}
		val += len;
	}
	if (*val == '=')
		tvar = str_nsave(var, val++ - var, ATEMP);
	else {
		/* Importing from original environment: must have an = */
		if (set & IMPORT)
			return NULL;
		tvar = (char *) var;
		val = NULL;
	}

	/* Prevent typeset from creating a local PATH/ENV/SHELL */
	if (Flag(FRESTRICTED) && (strcmp(tvar, "PATH") == 0 ||
	    strcmp(tvar, "ENV") == 0 || strcmp(tvar, "SHELL") == 0))
		errorf("%s: restricted", tvar);

	vp = (set&LOCAL) ? local(tvar, (set & LOCAL_COPY) ? true : false) :
	    global(tvar);
	set &= ~(LOCAL|LOCAL_COPY);

	vpbase = (vp->flag & ARRAY) ? global(arrayname(var)) : vp;

	/* only allow export flag to be set.  at&t ksh allows any attribute to
	 * be changed, which means it can be truncated or modified
	 * (-L/-R/-Z/-i).
	 */
	if ((vpbase->flag&RDONLY) &&
	    (val || clr || (set & ~EXPORT)))
		/* XXX check calls - is error here ok by POSIX? */
		errorf("%s: is read only", tvar);
	if (val)
		afree(tvar, ATEMP);

	/* most calls are with set/clr == 0 */
	if (set | clr) {
		int ok = 1;
		/* XXX if x[0] isn't set, there will be problems: need to have
		 * one copy of attributes for arrays...
		 */
		for (t = vpbase; t; t = t->u.array) {
			int fake_assign;
			int error_ok = KSH_RETURN_ERROR;
			char *s = NULL;
			char *free_me = NULL;

			fake_assign = (t->flag & ISSET) && (!val || t != vp) &&
			    ((set & (UCASEV_AL|LCASEV|LJUST|RJUST|ZEROFIL)) ||
			    ((t->flag & INTEGER) && (clr & INTEGER)) ||
			    (!(t->flag & INTEGER) && (set & INTEGER)));
			if (fake_assign) {
				if (t->flag & INTEGER) {
					s = str_val(t);
					free_me = NULL;
				} else {
					s = t->val.s + t->type;
					free_me = (t->flag & ALLOC) ? t->val.s :
					    NULL;
				}
				t->flag &= ~ALLOC;
			}
			if (!(t->flag & INTEGER) && (set & INTEGER)) {
				t->type = 0;
				t->flag &= ~ALLOC;
			}
			if (!(t->flag & RDONLY) && (set & RDONLY)) {
				/* allow var to be initialized read-only */
				error_ok |= KSH_IGNORE_RDONLY;
			}
			t->flag = (t->flag | set) & ~clr;
			/* Don't change base if assignment is to be done,
			 * in case assignment fails.
			 */
			if ((set & INTEGER) && base > 0 && (!val || t != vp))
				t->type = base;
			if (set & (LJUST|RJUST|ZEROFIL))
				t->u2.field = field;
			if (fake_assign) {
				if (!setstr(t, s, error_ok)) {
					/* Somewhat arbitrary action here:
					 * zap contents of variable, but keep
					 * the flag settings.
					 */
					ok = 0;
					if (t->flag & INTEGER)
						t->flag &= ~ISSET;
					else {
						if (t->flag & ALLOC)
							afree(t->val.s, t->areap);
						t->flag &= ~(ISSET|ALLOC);
						t->type = 0;
					}
				}
				afree(free_me, t->areap);
			}
		}
		if (!ok)
		    errorf(NULL);
	}

	if (val != NULL) {
		if (vp->flag&INTEGER) {
			/* do not zero base before assignment */
			setstr(vp, val, KSH_UNWIND_ERROR | KSH_IGNORE_RDONLY);
			/* Done after assignment to override default */
			if (base > 0)
				vp->type = base;
		} else
			/* setstr can't fail (readonly check already done) */
			setstr(vp, val, KSH_RETURN_ERROR | KSH_IGNORE_RDONLY);
	}

	/* only x[0] is ever exported, so use vpbase */
	if ((vpbase->flag&EXPORT) && !(vpbase->flag&INTEGER) &&
	    vpbase->type == 0)
		export(vpbase, (vpbase->flag&ISSET) ? vpbase->val.s : null);

	return vp;
}

/* Unset a variable.  array_ref is set if there was an array reference in
 * the name lookup (eg, x[2]).
 */
void
unset(struct tbl *vp, int array_ref)
{
	if (vp->flag & ALLOC)
		afree(vp->val.s, vp->areap);
	if ((vp->flag & ARRAY) && !array_ref) {
		struct tbl *a, *tmp;

		/* Free up entire array */
		for (a = vp->u.array; a; ) {
			tmp = a;
			a = a->u.array;
			if (tmp->flag & ALLOC)
				afree(tmp->val.s, tmp->areap);
			afree(tmp, tmp->areap);
		}
		vp->u.array = NULL;
	}
	/* If foo[0] is being unset, the remainder of the array is kept... */
	vp->flag &= SPECIAL | (array_ref ? ARRAY|DEFINED : 0);
	if (vp->flag & SPECIAL)
		unsetspec(vp);	/* responsible for `unspecial'ing var */
}

/* return a pointer to the first char past a legal variable name (returns the
 * argument if there is no legal name, returns * a pointer to the terminating
 * null if whole string is legal).
 */
char *
skip_varname(const char *s, int aok)
{
	int alen;

	if (s && letter(*s)) {
		while (*++s && letnum(*s))
			;
		if (aok && *s == '[' && (alen = array_ref_len(s)))
			s += alen;
	}
	return (char *) s;
}

/* Return a pointer to the first character past any legal variable name.  */
char *
skip_wdvarname(const char *s,
    int aok)				/* skip array de-reference? */
{
	if (s[0] == CHAR && letter(s[1])) {
		do {
			s += 2;
		} while (s[0] == CHAR && letnum(s[1]));
		if (aok && s[0] == CHAR && s[1] == '[') {
			/* skip possible array de-reference */
			const char *p = s;
			char c;
			int depth = 0;

			while (1) {
				if (p[0] != CHAR)
					break;
				c = p[1];
				p += 2;
				if (c == '[')
					depth++;
				else if (c == ']' && --depth == 0) {
					s = p;
					break;
				}
			}
		}
	}
	return (char *) s;
}

/* Check if coded string s is a variable name */
int
is_wdvarname(const char *s, int aok)
{
	char *p = skip_wdvarname(s, aok);

	return p != s && p[0] == EOS;
}

/* Check if coded string s is a variable assignment */
int
is_wdvarassign(const char *s)
{
	char *p = skip_wdvarname(s, true);

	return p != s && p[0] == CHAR && p[1] == '=';
}

/*
 * Make the exported environment from the exported names in the dictionary.
 */
char **
makenv(void)
{
	struct block *l;
	XPtrV env;
	struct tbl *vp, **vpp;
	int i;

	XPinit(env, 64);
	for (l = genv->loc; l != NULL; l = l->next)
		for (vpp = l->vars.tbls, i = l->vars.size; --i >= 0; )
			if ((vp = *vpp++) != NULL &&
			    (vp->flag&(ISSET|EXPORT)) == (ISSET|EXPORT)) {
				struct block *l2;
				struct tbl *vp2;
				unsigned int h = hash(vp->name);

				/* unexport any redefined instances */
				for (l2 = l->next; l2 != NULL; l2 = l2->next) {
					vp2 = ktsearch(&l2->vars, vp->name, h);
					if (vp2 != NULL)
						vp2->flag &= ~EXPORT;
				}
				if ((vp->flag&INTEGER)) {
					/* integer to string */
					char *val;
					val = str_val(vp);
					vp->flag &= ~(INTEGER|RDONLY);
					/* setstr can't fail here */
					setstr(vp, val, KSH_RETURN_ERROR);
				}
				XPput(env, vp->val.s);
			}
	XPput(env, NULL);
	return (char **) XPclose(env);
}

/*
 * Called after a fork in parent to bump the random number generator.
 * Done to ensure children will not get the same random number sequence
 * if the parent doesn't use $RANDOM.
 */
void
change_random(void)
{
	rand();
}

/*
 * handle special variables with side effects - PATH, SECONDS.
 */

/* Test if name is a special parameter */
static int
special(const char *name)
{
	struct tbl *tp;

	tp = ktsearch(&specials, name, hash(name));
	return tp && (tp->flag & ISSET) ? tp->type : V_NONE;
}

/* Make a variable non-special */
static void
unspecial(const char *name)
{
	struct tbl *tp;

	tp = ktsearch(&specials, name, hash(name));
	if (tp)
		ktdelete(tp);
}

static	time_t	seconds;		/* time SECONDS last set */
static	int	user_lineno;		/* what user set $LINENO to */

static void
getspec(struct tbl *vp)
{
	switch (special(vp->name)) {
	case V_SECONDS:
		vp->flag &= ~SPECIAL;
		/* On start up the value of SECONDS is used before seconds
		 * has been set - don't do anything in this case
		 * (see initcoms[] in main.c).
		 */
		if (vp->flag & ISSET)
			setint(vp, (long)(time(NULL) - seconds)); /* XXX 2038 */
		vp->flag |= SPECIAL;
		break;
	case V_RANDOM:
		vp->flag &= ~SPECIAL;
		setint(vp, (long) (rand() & 0x7fff));
		vp->flag |= SPECIAL;
		break;
#ifdef HISTORY
	case V_HISTSIZE:
		vp->flag &= ~SPECIAL;
		setint(vp, (long) histsize);
		vp->flag |= SPECIAL;
		break;
#endif /* HISTORY */
	case V_OPTIND:
		vp->flag &= ~SPECIAL;
		setint(vp, (long) user_opt.uoptind);
		vp->flag |= SPECIAL;
		break;
	case V_LINENO:
		vp->flag &= ~SPECIAL;
		setint(vp, (long) current_lineno + user_lineno);
		vp->flag |= SPECIAL;
		break;
	}
}

static void
setspec(struct tbl *vp)
{
	char *s;

	switch (special(vp->name)) {
	case V_PATH:
		afree(path, APERM);
		path = str_save(str_val(vp), APERM);
		flushcom(1);	/* clear tracked aliases */
		break;
	case V_IFS:
		setctypes(s = str_val(vp), C_IFS);
		ifs0 = *s;
		break;
	case V_OPTIND:
		vp->flag &= ~SPECIAL;
		getopts_reset((int) intval(vp));
		vp->flag |= SPECIAL;
		break;
	case V_POSIXLY_CORRECT:
		change_flag(FPOSIX, OF_SPECIAL, 1);
		break;
	case V_TMPDIR:
		afree(tmpdir, APERM);
		tmpdir = NULL;
		/* Use tmpdir iff it is an absolute path, is writable and
		 * searchable and is a directory...
		 */
		{
			struct stat statb;

			s = str_val(vp);
			if (s[0] == '/' && access(s, W_OK|X_OK) == 0 &&
			    stat(s, &statb) == 0 && S_ISDIR(statb.st_mode))
				tmpdir = str_save(s, APERM);
		}
		break;
#ifdef HISTORY
	case V_HISTCONTROL:
		sethistcontrol(str_val(vp));
		break;
	case V_HISTSIZE:
		vp->flag &= ~SPECIAL;
		sethistsize((int) intval(vp));
		vp->flag |= SPECIAL;
		break;
	case V_HISTFILE:
		sethistfile(str_val(vp));
		break;
#endif /* HISTORY */
#ifdef EDIT
	case V_VISUAL:
		set_editmode(str_val(vp));
		break;
	case V_EDITOR:
		if (!(global("VISUAL")->flag & ISSET))
			set_editmode(str_val(vp));
		break;
	case V_COLUMNS:
		{
			long l;

			if (getint(vp, &l, false) == -1) {
				x_cols = MIN_COLS;
				break;
			}
			if (l <= MIN_COLS || l > INT_MAX)
				x_cols = MIN_COLS;
			else
				x_cols = l;
		}
		break;
#endif /* EDIT */
	case V_MAIL:
		mbset(str_val(vp));
		break;
	case V_MAILPATH:
		mpset(str_val(vp));
		break;
	case V_MAILCHECK:
		vp->flag &= ~SPECIAL;
		mcset(intval(vp));
		vp->flag |= SPECIAL;
		break;
	case V_RANDOM:
		vp->flag &= ~SPECIAL;
		srand_deterministic((unsigned int)intval(vp));
		vp->flag |= SPECIAL;
		break;
	case V_SECONDS:
		vp->flag &= ~SPECIAL;
		seconds = time(NULL) - intval(vp); /* XXX 2038 */
		vp->flag |= SPECIAL;
		break;
	case V_TMOUT:
		/* at&t ksh seems to do this (only listen if integer) */
		if (vp->flag & INTEGER)
			ksh_tmout = vp->val.i >= 0 ? vp->val.i : 0;
		break;
	case V_LINENO:
		vp->flag &= ~SPECIAL;
		/* The -1 is because line numbering starts at 1. */
		user_lineno = (unsigned int) intval(vp) - current_lineno - 1;
		vp->flag |= SPECIAL;
		break;
	}
}

static void
unsetspec(struct tbl *vp)
{
	switch (special(vp->name)) {
	case V_PATH:
		afree(path, APERM);
		path = str_save(def_path, APERM);
		flushcom(1);	/* clear tracked aliases */
		break;
	case V_IFS:
		setctypes(" \t\n", C_IFS);
		ifs0 = ' ';
		break;
	case V_TMPDIR:
		/* should not become unspecial */
		afree(tmpdir, APERM);
		tmpdir = NULL;
		break;
	case V_MAIL:
		mbset(NULL);
		break;
	case V_MAILPATH:
		mpset(NULL);
		break;
#ifdef HISTORY
	case V_HISTCONTROL:
		sethistcontrol(NULL);
		break;
#endif
	case V_LINENO:
	case V_MAILCHECK:	/* at&t ksh leaves previous value in place */
	case V_RANDOM:
	case V_SECONDS:
	case V_TMOUT:		/* at&t ksh leaves previous value in place */
		unspecial(vp->name);
		break;

	  /* at&t ksh man page says OPTIND, OPTARG and _ lose special meaning,
	   * but OPTARG does not (still set by getopts) and _ is also still
	   * set in various places.
	   * Don't know what at&t does for:
	   *		MAIL, MAILPATH, HISTSIZE, HISTFILE,
	   * Unsetting these in at&t ksh does not loose the `specialness':
	   *    no effect: IFS, COLUMNS, PATH, TMPDIR,
	   *		VISUAL, EDITOR,
	   * pdkshisms: no effect:
	   *		POSIXLY_CORRECT (use set +o posix instead)
	   */
	}
}

/*
 * Search for (and possibly create) a table entry starting with
 * vp, indexed by val.
 */
static struct tbl *
arraysearch(struct tbl *vp, int val)
{
	struct tbl *prev, *curr, *new;
	size_t namelen = strlen(vp->name) + 1;

	vp->flag |= ARRAY|DEFINED;
	vp->index = 0;
	/* The table entry is always [0] */
	if (val == 0)
		return vp;
	prev = vp;
	curr = vp->u.array;
	while (curr && curr->index < val) {
		prev = curr;
		curr = curr->u.array;
	}
	if (curr && curr->index == val) {
		if (curr->flag&ISSET)
			return curr;
		else
			new = curr;
	} else
		new = alloc(sizeof(struct tbl) + namelen,
		    vp->areap);
	strlcpy(new->name, vp->name, namelen);
	new->flag = vp->flag & ~(ALLOC|DEFINED|ISSET|SPECIAL);
	new->type = vp->type;
	new->areap = vp->areap;
	new->u2.field = vp->u2.field;
	new->index = val;
	if (curr != new) {		/* not reusing old array entry */
		prev->u.array = new;
		new->u.array = curr;
	}
	return new;
}

/* Return the length of an array reference (eg, [1+2]) - cp is assumed
 * to point to the open bracket.  Returns 0 if there is no matching closing
 * bracket.
 */
int
array_ref_len(const char *cp)
{
	const char *s = cp;
	int c;
	int depth = 0;

	while ((c = *s++) && (c != ']' || --depth))
		if (c == '[')
			depth++;
	if (!c)
		return 0;
	return s - cp;
}

/*
 * Make a copy of the base of an array name
 */
char *
arrayname(const char *str)
{
	const char *p;

	if ((p = strchr(str, '[')) == 0)
		/* Shouldn't happen, but why worry? */
		return (char *) str;

	return str_nsave(str, p - str, ATEMP);
}

/* Set (or overwrite, if !reset) the array variable var to the values in vals.
 */
void
set_array(const char *var, int reset, char **vals)
{
	struct tbl *vp, *vq;
	int i;

	/* to get local array, use "typeset foo; set -A foo" */
	vp = global(var);

	/* Note: at&t ksh allows set -A but not set +A of a read-only var */
	if ((vp->flag&RDONLY))
		errorf("%s: is read only", var);
	/* This code is quite non-optimal */
	if (reset > 0)
		/* trash existing values and attributes */
		unset(vp, 0);
	/* todo: would be nice for assignment to completely succeed or
	 * completely fail.  Only really effects integer arrays:
	 * evaluation of some of vals[] may fail...
	 */
	for (i = 0; vals[i]; i++) {
		vq = arraysearch(vp, i);
		/* would be nice to deal with errors here... (see above) */
		setstr(vq, vals[i], KSH_RETURN_ERROR);
	}
}
@


1.58
log
@No need for NULL checks before afree()
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.57 2016/09/08 15:50:50 millert Exp $	*/
d101 1
d995 3
d1089 5
@


1.57
log
@Add KSH_IGNORE_RDONLY flag and use it in var.c instead of the 0x4
magic number.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.56 2016/09/08 15:47:16 millert Exp $	*/
d979 2
a980 4
		if (tmpdir) {
			afree(tmpdir, APERM);
			tmpdir = NULL;
		}
d1076 2
a1077 4
		if (tmpdir) {
			afree(tmpdir, APERM);
			tmpdir = NULL;
		}
@


1.56
log
@Allow "typeset -ir FOO" if FOO is not already marked read-only.  OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.55 2015/12/30 09:07:00 tedu Exp $	*/
d359 2
a360 2
	int no_ro_check = error_ok & 0x4;
	error_ok &= ~0x4;
d689 1
a689 1
				error_ok |= 0x4;
d725 1
a725 1
			setstr(vp, val, KSH_UNWIND_ERROR | 0x4);
d731 1
a731 1
			setstr(vp, val, KSH_RETURN_ERROR | 0x4);
@


1.55
log
@rename global "e" to genv to avoid accidental shadowing and aliasing.
ok millert nicm tb
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.54 2015/12/14 13:59:42 tb Exp $	*/
d664 1
d687 4
d700 1
a700 1
				if (!setstr(t, s, KSH_RETURN_ERROR)) {
@


1.54
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.53 2015/10/19 14:42:16 mmcc Exp $	*/
d37 1
a37 1
 * assume caller has allocated and set up e->loc
d47 2
a48 2
	ainit(&l->area); /* todo: could use e->area (l->area => l->areap) */
	if (!e->loc) {
d52 2
a53 2
		l->argc = e->loc->argc;
		l->argv = e->loc->argv;
d58 2
a59 2
	l->next = e->loc;
	e->loc = l;
d68 1
a68 1
	struct block *l = e->loc;
d72 1
a72 1
	e->loc = l->next;	/* pop block */
d165 1
a165 1
	struct block *l = e->loc;
d222 1
a222 1
	for (l = e->loc; ; l = l->next) {
d248 1
a248 1
	struct block *l = e->loc;
d844 1
a844 1
	for (l = e->loc; l != NULL; l = l->next)
@


1.53
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.52 2015/10/19 14:03:21 mmcc Exp $	*/
d6 1
d8 1
d11 1
@


1.52
log
@Move limits.h include from sh.h to the files that actually need it. No
binary change.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.51 2015/10/19 02:15:45 mmcc Exp $	*/
d7 1
@


1.51
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.50 2015/09/22 21:50:40 millert Exp $	*/
d6 1
@


1.50
log
@Make errorf() and bi_errorf() handle a NULL argument.
From Michael McConville; OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.49 2015/09/18 07:28:24 nicm Exp $	*/
a2 2
#include "sh.h"
#include <time.h>
d4 1
d6 3
@


1.49
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.48 2015/09/17 14:21:33 nicm Exp $	*/
d357 1
a357 1
			errorf(null);
d707 1
a707 1
		    errorf(null);
@


1.48
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.47 2015/09/15 18:15:05 tedu Exp $	*/
d260 1
a260 1
		struct tbl *vq = (struct tbl *) 0;
d749 1
a749 1
		vp->u.array = (struct tbl *) 0;
@


1.47
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.46 2015/09/14 16:08:50 nicm Exp $	*/
d38 1
a38 1
	l = (struct block *) alloc(sizeof(struct block), ATEMP);
d515 1
a515 1
	p = (char *) alloc(nlen + 1, ATEMP);
d571 1
a571 1
	xp = (char*)alloc(namelen + 1 + vallen, vp->areap);
d1126 1
a1126 1
		new = (struct tbl *)alloc(sizeof(struct tbl) + namelen,
@


1.46
log
@Replace Tflag typedef with just int; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.45 2015/09/14 09:42:33 nicm Exp $	*/
d108 1
a108 1
		{ (char *) 0,	0 }
d667 1
a667 1
					free_me = (char *) 0;
d671 1
a671 1
					    (char *) 0;
d969 1
a969 1
			tmpdir = (char *) 0;
d1068 1
a1068 1
			tmpdir = (char *) 0;
d1072 1
a1072 1
		mbset((char *) 0);
d1075 1
a1075 1
		mpset((char *) 0);
@


1.45
log
@Apply the ancient art of tedu to ksh_limval.h. ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.44 2015/09/10 11:37:42 jca Exp $	*/
d586 1
a586 1
typeset(const char *var, Tflag set, Tflag clr, int field, int base)
@


1.44
log
@Kill another superfluous variable initialization; from Michael McConville.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.43 2015/09/01 13:12:31 tedu Exp $	*/
a4 1
#include "ksh_limval.h"
@


1.43
log
@remove casts and null checks before free. from Michael McConville
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.41 2015/04/17 17:20:41 deraadt Exp $	*/
d832 1
a832 1
	struct block *l = e->loc;
@


1.42
log
@Don't re-include headers pulled by "sh.h".  (I actually don't like this .h
pulls in system .h pattern)
@
text
@d369 1
a369 1
			afree((void*)vq->val.s, vq->areap);
d388 1
a388 2
	if (fs)
		afree((char *)fs, ATEMP);
d578 1
a578 2
	if (op != NULL)
		afree((void*)op, vp->areap);
d699 1
a699 2
							afree((void*) t->val.s,
							    t->areap);
d704 1
a704 2
				if (free_me)
					afree((void *) free_me, t->areap);
d738 1
a738 1
		afree((void*)vp->val.s, vp->areap);
d747 1
a747 1
				afree((void *) tmp->val.s, tmp->areap);
d951 1
a951 2
		if (path)
			afree(path, APERM);
d1057 1
a1057 2
		if (path)
			afree(path, APERM);
@


1.41
log
@Use getint() instead of intval() for parsing the columns variable,
allowing the addition of more accurate bounds and garbage checks.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.40 2014/12/12 05:00:55 jsg Exp $	*/
a7 2
#include <limits.h>
#include <stdlib.h>
@


1.40
log
@Range check the value of the base for typeset -i base x=y.  Instead of
erroring for values outside of the range switch to base 10 to match the
behaviour of ksh93.  As we have a smaller digit alphabet than ksh93 the
accepted range is smaller (2-36) than ksh93 (2-64).  The other form
of setting a base, typeset -i x=base#y already has a range check that
errors (as ksh93 also does for that syntax).
Fixes a crash found with the afl fuzzer.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.39 2014/12/08 21:48:27 deraadt Exp $	*/
d1010 12
a1021 2
		if ((x_cols = intval(vp)) <= MIN_COLS)
			x_cols = MIN_COLS;
@


1.39
log
@Don't need special complex rand vs arc4random code.  If the
standards-mandated "seed" method is used, simply call
srand_deterministic() and the subsystem switches out of strong
random mode into C89 crap mode.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.38 2013/12/20 17:53:09 zhuk Exp $	*/
d312 2
@


1.38
log
@Fix a crash in ksh when trying to access ${12345678901234567890}

Input from deraadt@@, millert@@ and otto@@.

okay from millert@@ plus a willing from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.37 2013/12/18 13:53:12 millert Exp $	*/
a870 6
 * Someone has set the srand() value, therefore from now on
 * we return values from rand() instead of arc4random()
 */
int use_rand = 0;

/*
d878 1
a878 2
	if (use_rand)
		rand();
d925 1
a925 4
		if (use_rand)
			setint(vp, (long) (rand() & 0x7fff));
		else
			setint(vp, (long) (arc4random() & 0x7fff));
d1025 1
a1025 2
		srand((unsigned int)intval(vp));
		use_rand = 1;
@


1.37
log
@Remove artificial limit on the max array index.
Adapted from a bitrig commit from Martin Natano.
OK zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.36 2013/12/17 16:37:06 deraadt Exp $	*/
d8 2
d163 1
d182 3
a184 3
			for (c = 0; digit(*n); n++)
				c = c*10 + *n-'0';
			if (c <= l->argc)
d186 1
a186 1
				setstr(vp, l->argv[c], KSH_RETURN_ERROR);
@


1.36
log
@ctype cleanups.  Repeated re-audits of this sensitive area by okan and
myself, with a variety of other people spending some time as well.
Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.35 2013/04/05 01:31:30 tedu Exp $	*/
d145 1
a145 1
		if (rval < 0 || rval > ARRAYMAX)
@


1.35
log
@SECONDS is, in a highly theoretical way, not y2k38 safe. comment it.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.34 2007/10/15 02:16:35 deraadt Exp $	*/
d169 1
a169 1
	c = n[0];
d445 1
a445 1
	for (c = *s++; c ; c = *s++) {
d521 1
a521 1
			while (q > s && isspace(q[-1]))
d534 1
a534 1
			while (isspace(*s))
d547 2
a548 2
			if (islower(*q))
				*q = toupper(*q);
d551 2
a552 2
			if (isupper(*q))
				*q = tolower(*q);
@


1.34
log
@specifying int instead of just unsigned is better style
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.33 2007/08/02 11:05:54 fgsch Exp $	*/
d924 1
a924 1
			setint(vp, (long) (time((time_t *)0) - seconds));
d1038 1
a1038 1
		seconds = time((time_t*) 0) - intval(vp);
@


1.33
log
@backout last change; iff is right.
prompted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.31 2007/08/02 10:50:25 fgsch Exp $	*/
d162 1
a162 1
	unsigned h;
d243 1
a243 1
	unsigned h;
d845 1
a845 1
				unsigned h = hash(vp->name);
@


1.32
log
@while i'm here: iff -> if
@
text
@d984 1
a984 1
		/* Use tmpdir if it is an absolute path, is writable and
@


1.31
log
@fix memory leaks and one potential null deref found by coverity. from netbsd.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.30 2006/05/21 18:40:39 otto Exp $	*/
d984 1
a984 1
		/* Use tmpdir iff it is an absolute path, is writable and
@


1.30
log
@Set the index of item[0], since it might not have been set before
(A=0; A[1]=1) and do not use a static buffer in str_val, since the
results might be used in a loop. Report from jared r r spiegel; help
from Matthias Kilian; ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.29 2006/03/13 08:21:37 otto Exp $	*/
d349 1
d371 1
a371 1
			s = formatstr(vq, s);
d385 2
@


1.29
log
@Interpret zero-filled numbers as decimal; PR 4213; from Alexey
Dobriyan; ok millert@@ moritz@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.28 2005/12/11 20:31:21 otto Exp $	*/
d296 1
a296 1
		static char strbuf[1 + 2 + 1 + BITS(long) + 1];
d325 2
d1112 1
a1112 1

d1114 1
a1114 2
	if (val == 0) {
		vp->index = 0;
a1115 1
	}
@


1.28
log
@fix a few name clashes with libc; found by lint. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.27 2005/10/08 18:02:59 otto Exp $	*/
d433 3
@


1.27
log
@Tell user which value of index is out of bounds. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.26 2005/03/30 17:16:37 deraadt Exp $	*/
d50 2
a51 2
	tinit(&l->vars, &l->area, 0);
	tinit(&l->funs, &l->area, 0);
d114 1
a114 1
	tinit(&specials, APERM, 32); /* must be 2^n (currently 17 specials) */
d116 1
a116 1
		tp = tenter(&specials, names[i].name, hash(names[i].name));
d216 1
a216 1
		vp = tsearch(&l->vars, n, h);
d226 1
a226 1
	vp = tenter(&l->vars, n, h);
d257 1
a257 1
	vp = tenter(&l->vars, n, h);
d262 1
a262 1
		while ((ll = ll->next) && !(vq = tsearch(&ll->vars, n, h)))
d841 1
a841 1
					vp2 = tsearch(&l2->vars, vp->name, h);
d887 1
a887 1
	tp = tsearch(&specials, name, hash(name));
d897 1
a897 1
	tp = tsearch(&specials, name, hash(name));
d899 1
a899 1
		tdelete(tp);
@


1.26
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.25 2005/03/28 21:33:04 deraadt Exp $	*/
d146 1
a146 1
			errorf("%s: subscript out of range", n);
@


1.25
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.24 2005/03/28 21:28:22 deraadt Exp $	*/
d192 1
a192 1
		  case '$':
d195 1
a195 1
		  case '!':
d200 1
a200 1
		  case '?':
d203 1
a203 1
		  case '#':
d206 1
a206 1
		  case '-':
d210 1
a210 1
		  default:
d265 3
a267 3
			vp->flag |= vq->flag & (EXPORT|INTEGER|RDONLY
						|LJUST|RJUST|ZEROFIL
						|LCASEV|UCASEV_AL|INT_U|INT_L);
d295 1
a295 1
			     /* minus base #     number    null */
d298 2
a299 2
				  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
				: "0123456789abcdefghijklmnopqrstuvwxyz";
d358 2
a359 2
			if (s >= vq->val.s
			    && s <= vq->val.s + strlen(vq->val.s))
d620 2
a621 3
	if (Flag(FRESTRICTED) && (strcmp(tvar, "PATH") == 0
				  || strcmp(tvar, "ENV") == 0
				  || strcmp(tvar, "SHELL") == 0))
d624 2
a625 2
	vp = (set&LOCAL) ? local(tvar, (set & LOCAL_COPY) ? true : false)
		: global(tvar);
d634 2
a635 2
	if ((vpbase->flag&RDONLY)
	    && (val || clr || (set & ~EXPORT)))
d652 4
a655 4
			fake_assign = (t->flag & ISSET) && (!val || t != vp)
				      && ((set & (UCASEV_AL|LCASEV|LJUST|RJUST|ZEROFIL))
					  || ((t->flag & INTEGER) && (clr & INTEGER))
					  || (!(t->flag & INTEGER) && (set & INTEGER)));
d662 2
a663 2
					free_me = (t->flag & ALLOC) ? t->val.s
								  : (char *) 0;
d691 1
a691 1
							      t->areap);
d717 2
a718 2
	if ((vpbase->flag&EXPORT) && !(vpbase->flag&INTEGER)
	    && vpbase->type == 0)
d775 1
a775 1
		do
d777 1
a777 1
		while (s[0] == CHAR && letnum(s[1]));
d833 2
a834 2
			if ((vp = *vpp++) != NULL
			    && (vp->flag&(ISSET|EXPORT)) == (ISSET|EXPORT)) {
d909 1
a909 1
	  case V_SECONDS:
d919 1
a919 1
	  case V_RANDOM:
d928 1
a928 1
	  case V_HISTSIZE:
d934 1
a934 1
	  case V_OPTIND:
d939 1
a939 1
	  case V_LINENO:
d953 1
a953 1
	  case V_PATH:
d959 1
a959 1
	  case V_IFS:
d963 1
a963 1
	  case V_OPTIND:
d968 1
a968 1
	  case V_POSIXLY_CORRECT:
d971 1
a971 1
	  case V_TMPDIR:
d981 1
d983 2
a984 2
			if (s[0] == '/' && access(s, W_OK|X_OK) == 0
			    && stat(s, &statb) == 0 && S_ISDIR(statb.st_mode))
d989 1
a989 1
	  case V_HISTSIZE:
d994 1
a994 1
	  case V_HISTFILE:
d999 1
a999 1
	  case V_VISUAL:
d1002 1
a1002 1
	  case V_EDITOR:
d1006 1
a1006 1
	  case V_COLUMNS:
d1011 1
a1011 1
	  case V_MAIL:
d1014 1
a1014 1
	  case V_MAILPATH:
d1017 1
a1017 1
	  case V_MAILCHECK:
d1022 1
a1022 1
	  case V_RANDOM:
d1028 1
a1028 1
	  case V_SECONDS:
d1033 1
a1033 1
	  case V_TMOUT:
d1038 1
a1038 1
	  case V_LINENO:
d1051 1
a1051 1
	  case V_PATH:
d1057 1
a1057 1
	  case V_IFS:
d1061 1
a1061 1
	  case V_TMPDIR:
d1068 1
a1068 1
	  case V_MAIL:
d1071 1
a1071 1
	  case V_MAILPATH:
d1074 5
a1078 5
	  case V_LINENO:
	  case V_MAILCHECK:	/* at&t ksh leaves previous value in place */
	  case V_RANDOM:
	  case V_SECONDS:
	  case V_TMOUT:		/* at&t ksh leaves previous value in place */
@


1.24
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.23 2005/02/02 07:53:01 otto Exp $	*/
d88 6
a93 6
			{ "COLUMNS",		V_COLUMNS },
			{ "IFS",		V_IFS },
			{ "OPTIND",		V_OPTIND },
			{ "PATH",		V_PATH },
			{ "POSIXLY_CORRECT",	V_POSIXLY_CORRECT },
			{ "TMPDIR",		V_TMPDIR },
d95 2
a96 2
			{ "HISTFILE",		V_HISTFILE },
			{ "HISTSIZE",		V_HISTSIZE },
d99 2
a100 2
			{ "EDITOR",		V_EDITOR },
			{ "VISUAL",		V_VISUAL },
d102 9
a110 9
			{ "MAIL",		V_MAIL },
			{ "MAILCHECK",		V_MAILCHECK },
			{ "MAILPATH",		V_MAILPATH },
			{ "RANDOM",		V_RANDOM },
			{ "SECONDS",		V_SECONDS },
			{ "TMOUT",		V_TMOUT },
			{ "LINENO",		V_LINENO },
			{ (char *) 0,	0 }
		};
@


1.23
log
@Introduce POSIX hex and octal (0x... and 0...) constants in arithmetic
expressions.  Work by Matthias Kilian, based on an old diff by myself.
Note: MAKEDEV should be updated. Tested by many, thanks.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.22 2004/12/22 17:14:34 millert Exp $	*/
d429 1
a429 1
	    	s++;
d431 1
a431 1
		    	s++;
d434 1
a434 1
		    	base = 8;
@


1.22
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.21 2004/12/20 11:34:26 otto Exp $	*/
d126 1
a126 3
const char *array_index_calc(const char *n, bool *arrayp, int *valp);

const char *
d144 1
a144 1
		evaluate(sub, &rval, KSH_UNWIND_ERROR);
d336 1
a336 1
	base = getint(vp, &num);
d375 2
a376 2
	} else			/* integer dest */
		if (!v_evaluate(vq, s, error_ok))
d378 1
d405 1
a405 1
getint(struct tbl *vp, long int *nump)
d428 9
d471 1
a471 1
setint_v(struct tbl *vq, struct tbl *vp)
d476 1
a476 1
	if ((base = getint(vp, &num)) == -1)
@


1.21
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.20 2004/12/18 21:25:44 millert Exp $	*/
d126 1
a126 1
const char *array_index_calc(const char *n, bool_t *arrayp, int *valp);
d129 1
a129 1
array_index_calc(const char *n, bool_t *arrayp, int *valp)
d134 2
a135 2
	*arrayp = FALSE;
	p = skip_varname(n, FALSE);
d141 1
a141 1
		*arrayp = TRUE;
d165 1
a165 1
	bool_t	 array;
d241 1
a241 1
local(const char *n, bool_t copy)
d246 1
a246 1
	bool_t	 array;
d352 1
a352 1
		warningf(TRUE, "%s: is read only", vq->name);
d362 1
a362 1
				internal_errorf(TRUE,
d578 1
a578 1
	val = skip_varname(var, FALSE);
d617 1
a617 1
	vp = (set&LOCAL) ? local(tvar, (set & LOCAL_COPY) ? TRUE : FALSE)
d807 1
a807 1
	char *p = skip_wdvarname(s, TRUE);
@


1.20
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.19 2004/12/18 21:04:52 millert Exp $	*/
d20 7
a26 7
static char	*formatstr(struct tbl *vp, const char *s);
static void	export(struct tbl *vp, const char *val);
static int	special(const char *name);
static void	unspecial(const char *name);
static void	getspec(struct tbl *vp);
static void	setspec(struct tbl *vp);
static void	unsetspec(struct tbl *vp);
d34 1
a34 1
newblock()
d60 1
a60 1
popblock()
d82 1
a82 1
initvar()
d129 1
a129 4
array_index_calc(n, arrayp, valp)
	const char *n;
	bool_t *arrayp;
	int *valp;
d159 1
a159 2
global(n)
	const char *n;
d241 1
a241 3
local(n, copy)
	const char *n;
	bool_t copy;
d285 1
a285 2
str_val(vp)
	struct tbl *vp;
d333 1
a333 2
intval(vp)
	struct tbl *vp;
d347 1
a347 4
setstr(vq, s, error_ok)
	struct tbl *vq;
	const char *s;
	int error_ok;
d388 1
a388 3
setint(vq, n)
	struct tbl *vq;
	long n;
d406 1
a406 3
getint(vp, nump)
	struct tbl *vp;
	long *nump;
d463 1
a463 2
setint_v(vq, vp)
	struct tbl *vq, *vp;
d484 1
a484 3
formatstr(vp, s)
	struct tbl *vp;
	const char *s;
d546 1
a546 3
export(vp, val)
	struct tbl *vp;
	const char *val;
d570 1
a570 4
typeset(var, set, clr, field, base)
	const char *var;
	Tflag clr, set;
	int field, base;
d721 1
a721 3
unset(vp, array_ref)
	struct tbl *vp;
	int array_ref;
d749 1
a749 3
skip_varname(s, aok)
	const char *s;
	int aok;
d764 2
a765 3
skip_wdvarname(s, aok)
	const char *s;
	int aok;	/* skip array de-reference? */
d796 1
a796 3
is_wdvarname(s, aok)
	const char *s;
	int aok;
d805 1
a805 2
is_wdvarassign(s)
	const char *s;
d816 1
a816 1
makenv()
d864 1
a864 1
change_random()
d876 1
a876 2
special(name)
	const char * name;
d886 1
a886 2
unspecial(name)
	const char * name;
d899 1
a899 2
getspec(vp)
	struct tbl *vp;
d941 1
a941 2
setspec(vp)
	struct tbl *vp;
d1040 1
a1040 2
unsetspec(vp)
	struct tbl *vp;
d1093 1
a1093 3
arraysearch(vp, val)
	struct tbl *vp;
	int val;
d1137 1
a1137 2
array_ref_len(cp)
	const char *cp;
d1155 1
a1155 2
arrayname(str)
	const char *str;
d1169 1
a1169 4
set_array(var, reset, vals)
	const char *var;
	int reset;
	char **vals;
@


1.19
log
@Get rid of #ifdef KSH since we don't care about building a V7 style sh and
the #ifdef KSH code is required to make a POSIX sh.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.18 2004/12/18 20:55:52 millert Exp $	*/
d36 1
a36 1
	register struct block *l;
d62 3
a64 3
	register struct block *l = e->loc;
	register struct tbl *vp, **vpp = l->vars.tbls, *vq;
	register int i;
d163 1
a163 1
	register const char *n;
d165 3
a167 3
	register struct block *l = e->loc;
	register struct tbl *vp;
	register int c;
d246 1
a246 1
	register const char *n;
d249 2
a250 2
	register struct block *l = e->loc;
	register struct tbl *vp;
d292 1
a292 1
	register struct tbl *vp;
d309 2
a310 2
		register unsigned long n;
		register int base;
d341 1
a341 1
	register struct tbl *vp;
d356 1
a356 1
	register struct tbl *vq;
d400 1
a400 1
	register struct tbl *vq;
d404 1
a404 1
		register struct tbl *vp = &vtemp;
d423 2
a424 2
	register char *s;
	register int c;
d479 1
a479 1
	register struct tbl *vq, *vp;
d565 1
a565 1
	register struct tbl *vp;
d568 1
a568 1
	register char *xp;
d591 1
a591 1
	register const char *var;
d595 1
a595 1
	register struct tbl *vp;
d745 1
a745 1
	register struct tbl *vp;
d851 2
a852 2
	register struct tbl *vp, **vpp;
	register int i;
d859 2
a860 2
				register struct block *l2;
				register struct tbl *vp2;
d908 1
a908 1
	register const char * name;
d910 1
a910 1
	register struct tbl *tp;
d919 1
a919 1
	register const char * name;
d921 1
a921 1
	register struct tbl *tp;
d933 1
a933 1
	register struct tbl *vp;
d976 1
a976 1
	register struct tbl *vp;
d1076 1
a1076 1
	register struct tbl *vp;
@


1.18
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.17 2004/05/08 19:42:35 deraadt Exp $	*/
a101 1
#ifdef KSH
a107 1
#endif /* KSH */
a927 1
#ifdef KSH
a928 1
#endif /* KSH */
a935 1
#ifdef KSH
a953 1
#endif /* KSH */
a1037 1
#ifdef KSH
a1064 1
#endif /* KSH */
a1095 1
#ifdef KSH
a1101 2
#endif /* KSH */

a1102 1
#ifdef KSH
a1106 1
#endif /* KSH */
@


1.17
log
@unless specifically requested by setting the seed, use arc4random(); otto ok
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.16 2003/08/05 20:52:27 millert Exp $	*/
d4 1
a4 1
#include "ksh_time.h"
d6 1
a6 1
#include "ksh_stat.h"
d20 8
a27 8
static char	*formatstr	ARGS((struct tbl *vp, const char *s));
static void	export		ARGS((struct tbl *vp, const char *val));
static int	special		ARGS((const char *name));
static void	unspecial	ARGS((const char *name));
static void	getspec		ARGS((struct tbl *vp));
static void	setspec		ARGS((struct tbl *vp));
static void	unsetspec	ARGS((struct tbl *vp));
static struct tbl *arraysearch  ARGS((struct tbl *, int));
d667 2
a668 2
			char UNINITIALIZED(*s);
			char UNINITIALIZED(*free_me);
d1016 1
a1016 1
			if (ISABSPATH(s) && eaccess(s, W_OK|X_OK) == 0
@


1.16
log
@Don't allow alloc() and aresize() to fail.  Their return value was
only checked in two place (both in conjunction with str_save).  Upon
malloc/realloc failure we call internal_errorf() which pops throws
and error and pops back to the last good state.  OK deraadt@@ pval@@ fgs@@
Original problem noted by mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.15 2003/06/26 00:09:45 deraadt Exp $	*/
d886 6
d899 2
a900 1
    rand();
d953 4
a956 1
		setint(vp, (long) (rand() & 0x7fff));
d1059 1
@


1.15
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.14 2003/04/16 23:11:52 tdeval Exp $	*/
d388 1
a388 2
			if (vq->val.s)		/* <sjg> don't lie */
				vq->flag |= ALLOC;
@


1.14
log
@string cleaning.  ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.13 2003/03/13 09:03:07 deraadt Exp $	*/
d128 2
@


1.13
log
@a few strcpy -> strlcpy; a couple people have mailed in a variety of
patches, and i already had this sitting on my laptop at that time.. i used
that as a chance to note that we had all done the same work, more or less
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.13 2003/03/13 08:51:21 deraadt Exp $	*/
d1135 1
d1156 1
a1156 1
		new = (struct tbl *)alloc(sizeof(struct tbl)+strlen(vp->name)+1,
d1158 1
a1158 1
	strcpy(new->name, vp->name);
@


1.12
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.11 2000/11/21 23:12:04 millert Exp $	*/
d1155 2
a1156 1
		new = (struct tbl *)alloc(sizeof(struct tbl)+strlen(vp->name)+1, vp->areap);
@


1.11
log
@Bug fixes from pdksh-5.2.14-patches.1:
 o set -x dumps core (shf.c);
 o "typeset -r foo=bar" fails saying foo is readonly (var.c).
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.10 1999/06/15 01:18:36 millert Exp $	*/
d440 1
a440 1
	if (s == NULL)	/* redundent given initial test */
d628 1
a628 1
		/* Importing from original envirnment: must have an = */
d699 1
a699 1
					 * zap contents of varibale, but keep
@


1.10
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.9 1999/01/10 17:55:03 millert Exp $	*/
d360 3
a362 1
	if (vq->flag & RDONLY) {
d724 1
a724 1
			setstr(vp, val, KSH_UNWIND_ERROR);
d730 1
a730 1
			setstr(vp, val, KSH_RETURN_ERROR);
@


1.9
log
@sync with pdksh-unstable-5.2.13.6
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.8 1999/01/08 20:25:02 millert Exp $	*/
d23 1
d41 1
a41 1
	ainit(&l->area);
d110 1
d116 1
a116 1
	tinit(&specials, APERM, 32); /* must be 2^n (currently 16 speciasl) */
d149 1
a149 1
		evaluate(sub, &rval, FALSE);
d180 1
a180 1
		vp->flag = (DEFINED|RDONLY);
d188 3
a190 2
				/* SETSTR: can't fail */
				setstr(vp, l->argv[c]);
d193 1
d354 2
a355 2
void
setstr(vq, s)
d358 1
d360 6
d388 2
a389 2
		/* XXX is this correct? */
		v_evaluate(vq, s, FALSE);
d393 1
d408 2
a409 2
		/* SETSTR: can't fail */
		setstr(vq, str_val(vp));
d658 1
d695 16
a710 2
				/* SETSTR: XXX make unset, then fail? */
				setstr(t, s);
d715 2
d722 1
a722 2
			/* SETSTR: XXX */
			setstr(vp, val);
d727 2
a728 2
			/* SETSTR: can't fail */
			setstr(vp, val);
d872 3
a874 3
					vp->flag &= ~INTEGER;
					/* SETSTR: can't fail */
					setstr(vp, val);
d905 13
a917 1
	return tp ? tp->type : V_NONE;
d923 1
d933 6
a938 1
		setint(vp, (long) (time((time_t *)0) - seconds));
d959 5
d1039 3
a1041 1
		/* mail_check_set(intval(vp)); */
d1059 6
d1097 10
a1106 8
	  case V_TMOUT:
		/* at&t ksh doesn't do this. TMOUT becomes unspecial so
		 * future assignments don't have effect.  Could be
		 * useful (eg, after "TMOUT=60; unset TMOUT", user
		 * can't get rid of the timeout...).  Should be handled
		 * by generic unset code...
		 */
		ksh_tmout = 0;
d1108 7
a1114 7
#endif /* KSH */
	  /* todo: generic action for specials (at&t says variables
	   * lose their special meaning when unset but global() checks
	   * the name of new vars to see if they are special)
	   * 	lose meaning: _, ERRNO, LINENO, MAILCHECK,
	   *		OPTARG, OPTIND, RANDOM, SECONDS, TMOUT.
	   *	unknown: MAIL, MAILPATH, HISTSIZE, HISTFILE,
d1117 1
d1230 2
a1231 2
		/* SETSTR: XXX */
		setstr(vq, vals[i]);
@


1.8
log
@bug fixes from pdksh-unstable-5.2.13.5; some of which we already had.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.7 1998/06/25 19:02:27 millert Exp $	*/
d67 1
a67 1
		if ((vp = *vpp++) != NULL && (vp->flag&SPECIAL))
d72 1
d186 1
d219 1
a219 1
		if (vp != NULL)
d224 1
d396 1
d682 1
d693 1
d699 1
d845 1
d1168 1
@


1.7
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.6 1997/09/01 18:30:16 deraadt Exp $	*/
d844 11
@


1.6
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.5 1997/06/19 13:58:49 kstailey Exp $	*/
d39 1
d72 2
d889 5
d905 3
a907 1
		path = str_val(vp);
d915 1
d917 1
d996 3
a998 1
		path = def_path;
@


1.5
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.3 1996/10/01 02:05:53 downsj Exp $	*/
d162 1
a162 1
	unsigned h; 
d408 1
a408 1
	
d463 1
a463 1
	
d586 1
a586 1
		
@


1.4
log
@(foo *)0 -> NULL
@
text
@d105 1
a105 1
			{ NULL,			0 }
d258 1
a258 1
		struct tbl *vq = NULL;
d654 1
a654 1
					free_me = NULL;
d658 1
a658 1
								  : NULL;
d722 1
a722 1
		vp->u.array = NULL;
d870 1
a870 1
		setint(vp, (long) (time(NULL) - seconds));
d913 1
a913 1
			tmpdir = NULL;
d966 1
a966 1
		seconds = time(NULL) - intval(vp);
d995 1
a995 1
			tmpdir = NULL;
d1000 1
a1000 1
		mbset(NULL);
d1003 1
a1003 1
		mpset(NULL);
@


1.3
log
@Integrate pdksh 5.2.9.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.2 1996/08/19 20:09:02 downsj Exp $	*/
d105 1
a105 1
			{ (char *) 0,	0 }
d258 1
a258 1
		struct tbl *vq = (struct tbl *) 0;
d654 1
a654 1
					free_me = (char *) 0;
d658 1
a658 1
								  : (char *) 0;
d722 1
a722 1
		vp->u.array = (struct tbl *) 0;
d870 1
a870 1
		setint(vp, (long) (time((time_t *)0) - seconds));
d913 1
a913 1
			tmpdir = (char *) 0;
d966 1
a966 1
		seconds = time((time_t*) 0) - intval(vp);
d995 1
a995 1
			tmpdir = (char *) 0;
d1000 1
a1000 1
		mbset((char *) 0);
d1003 1
a1003 1
		mpset((char *) 0);
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.1.1.1 1996/08/14 06:19:12 downsj Exp $	*/
d760 1
a760 1
		if (aok) {
d1016 1
a1016 1
	   * loose their special meaning when unset but global() checks
d1018 1
a1018 1
	   * 	loose meaning: _, ERRNO, LINENO, MAILCHECK,
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a84 3
			{ "MAIL",		V_MAIL },
			{ "MAILCHECK",		V_MAILCHECK },
			{ "MAILPATH",		V_MAILPATH },
d98 3
d250 1
a250 1
		vp->flag = (DEFINED|RDONLY);
d268 1
a268 1
			vp->field = vq->field;
d355 2
a356 1
				    "setstr: assigning to self");
d490 3
a492 3
		if (!vp->field)	/* default field width */
			vp->field = olen;
		nlen = vp->field;
d506 3
a508 3
			if (slen > vp->field) {
				s += slen - vp->field;
				slen = vp->field;
d513 1
a513 1
				vp->field - slen, null, slen, s);
d522 1
a522 1
				vp->field, vp->field, s);
d572 1
a572 1
	int clr, set;
d620 2
a621 1
	vp = (set&LOCAL) ? local(tvar, set & LOCAL_COPY) : global(tvar);
d673 1
a673 1
				t->field = field;
d724 2
a725 1
	vp->flag &= SPECIAL;	/* Should ``unspecial'' some vars */
d727 1
a727 1
		unsetspec(vp);
a906 9
	  case V_MAIL:
		mbset(str_val(vp));
		break;
	  case V_MAILPATH:
		mpset(str_val(vp));
		break;
	  case V_MAILCHECK:
		/* mail_check_set(intval(vp)); */
		break;
d950 9
a990 6
	  case V_MAIL:
		mbset((char *) 0);
		break;
	  case V_MAILPATH:
		mpset((char *) 0);
		break;
d999 6
d1063 1
a1063 1
	new->field = vp->field;
d1129 4
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
