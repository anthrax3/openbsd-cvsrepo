head	1.27;
access;
symbols
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.20.0.16
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.8
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.12
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.10
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.6
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.4
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.14
	OPENBSD_5_0:1.19.0.12
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.10
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.8
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.4
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.6
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.18.0.10
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.8
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.10.0.12
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.10
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.8
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.10
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.8
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.6
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.11.01.15.38.53;	author mmcc;	state Exp;
branches;
next	1.26;
commitid	Fr9nr0FBz2YkAWdK;

1.26
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.25;
commitid	C4W85jmosThChWA2;

1.25
date	2015.10.09.19.36.27;	author tedu;	state Exp;
branches;
next	1.24;
commitid	BqXaWldwtvsixcay;

1.24
date	2015.09.27.05.25.00;	author guenther;	state Exp;
branches;
next	1.23;
commitid	PQh1CHLROh0mqpnf;

1.23
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.22;
commitid	v5QjoxUgKU2iUTFz;

1.22
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.21;
commitid	lBs9un9sXhbdfVrQ;

1.21
date	2015.09.01.13.12.31;	author tedu;	state Exp;
branches;
next	1.20;
commitid	sKGEDet4KOfGjsIb;

1.20
date	2012.06.27.07.17.19;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2008.08.11.21.50.35;	author jaredy;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.10.14.38.59;	author jaredy;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.28.21.28.22;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.19.04.14.20;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.18.21.04.52;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.27.19.37.09;	author dhartmei;	state Exp;
branches;
next	1.9;

1.9
date	99.07.14.13.37.24;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.06.15.01.18.36;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.10.29.04.09.21;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.06.25.19.02.24;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.09.01.18.30.15;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.06.19.13.58.48;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.06.18.22.42.47;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.09.01;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.12;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.12;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Add uses of areallocarray(). mksh and Bitrig ksh already have similar
functions. With help from Theo Buehler.

ok nicm@@
@
text
@/*	$OpenBSD: tree.c,v 1.26 2015/10/19 14:42:16 mmcc Exp $	*/

/*
 * command tree climbing
 */

#include <string.h>

#include "sh.h"

#define INDENT	4

#define tputc(c, shf)	shf_putchar(c, shf);
static void	ptree(struct op *, int, struct shf *);
static void	pioact(struct shf *, int, struct ioword *);
static void	tputC(int, struct shf *);
static void	tputS(char *, struct shf *);
static void	vfptreef(struct shf *, int, const char *, va_list);
static struct ioword **iocopy(struct ioword **, Area *);
static void     iofree(struct ioword **, Area *);

/*
 * print a command tree
 */

static void
ptree(struct op *t, int indent, struct shf *shf)
{
	char **w;
	struct ioword **ioact;
	struct op *t1;

 Chain:
	if (t == NULL)
		return;
	switch (t->type) {
	case TCOM:
		if (t->vars)
			for (w = t->vars; *w != NULL; )
				fptreef(shf, indent, "%S ", *w++);
		else
			fptreef(shf, indent, "#no-vars# ");
		if (t->args)
			for (w = t->args; *w != NULL; )
				fptreef(shf, indent, "%S ", *w++);
		else
			fptreef(shf, indent, "#no-args# ");
		break;
	case TEXEC:
#if 0 /* ?not useful - can't be called? */
		/* Print original vars */
		if (t->left->vars)
			for (w = t->left->vars; *w != NULL; )
				fptreef(shf, indent, "%S ", *w++);
		else
			fptreef(shf, indent, "#no-vars# ");
		/* Print expanded vars */
		if (t->args)
			for (w = t->args; *w != NULL; )
				fptreef(shf, indent, "%s ", *w++);
		else
			fptreef(shf, indent, "#no-args# ");
		/* Print original io */
		t = t->left;
#else
		t = t->left;
		goto Chain;
#endif
	case TPAREN:
		fptreef(shf, indent + 2, "( %T) ", t->left);
		break;
	case TPIPE:
		fptreef(shf, indent, "%T| ", t->left);
		t = t->right;
		goto Chain;
	case TLIST:
		fptreef(shf, indent, "%T%;", t->left);
		t = t->right;
		goto Chain;
	case TOR:
	case TAND:
		fptreef(shf, indent, "%T%s %T",
		    t->left, (t->type==TOR) ? "||" : "&&", t->right);
		break;
	case TBANG:
		fptreef(shf, indent, "! ");
		t = t->right;
		goto Chain;
	case TDBRACKET:
	  {
		int i;

		fptreef(shf, indent, "[[");
		for (i = 0; t->args[i]; i++)
			fptreef(shf, indent, " %S", t->args[i]);
		fptreef(shf, indent, " ]] ");
		break;
	  }
	case TSELECT:
		fptreef(shf, indent, "select %s ", t->str);
		/* FALLTHROUGH */
	case TFOR:
		if (t->type == TFOR)
			fptreef(shf, indent, "for %s ", t->str);
		if (t->vars != NULL) {
			fptreef(shf, indent, "in ");
			for (w = t->vars; *w; )
				fptreef(shf, indent, "%S ", *w++);
			fptreef(shf, indent, "%;");
		}
		fptreef(shf, indent + INDENT, "do%N%T", t->left);
		fptreef(shf, indent, "%;done ");
		break;
	case TCASE:
		fptreef(shf, indent, "case %S in", t->str);
		for (t1 = t->left; t1 != NULL; t1 = t1->right) {
			fptreef(shf, indent, "%N(");
			for (w = t1->vars; *w != NULL; w++)
				fptreef(shf, indent, "%S%c", *w,
				    (w[1] != NULL) ? '|' : ')');
			fptreef(shf, indent + INDENT, "%;%T%N;;", t1->left);
		}
		fptreef(shf, indent, "%Nesac ");
		break;
	case TIF:
	case TELIF:
		/* 3 == strlen("if ") */
		fptreef(shf, indent + 3, "if %T", t->left);
		for (;;) {
			t = t->right;
			if (t->left != NULL) {
				fptreef(shf, indent, "%;");
				fptreef(shf, indent + INDENT, "then%N%T",
				    t->left);
			}
			if (t->right == NULL || t->right->type != TELIF)
				break;
			t = t->right;
			fptreef(shf, indent, "%;");
			/* 5 == strlen("elif ") */
			fptreef(shf, indent + 5, "elif %T", t->left);
		}
		if (t->right != NULL) {
			fptreef(shf, indent, "%;");
			fptreef(shf, indent + INDENT, "else%;%T", t->right);
		}
		fptreef(shf, indent, "%;fi ");
		break;
	case TWHILE:
	case TUNTIL:
		/* 6 == strlen("while"/"until") */
		fptreef(shf, indent + 6, "%s %T",
		    (t->type==TWHILE) ? "while" : "until",
		    t->left);
		fptreef(shf, indent, "%;do");
		fptreef(shf, indent + INDENT, "%;%T", t->right);
		fptreef(shf, indent, "%;done ");
		break;
	case TBRACE:
		fptreef(shf, indent + INDENT, "{%;%T", t->left);
		fptreef(shf, indent, "%;} ");
		break;
	case TCOPROC:
		fptreef(shf, indent, "%T|& ", t->left);
		break;
	case TASYNC:
		fptreef(shf, indent, "%T& ", t->left);
		break;
	case TFUNCT:
		fptreef(shf, indent,
		    t->u.ksh_func ? "function %s %T" : "%s() %T",
		    t->str, t->left);
		break;
	case TTIME:
		fptreef(shf, indent, "time %T", t->left);
		break;
	default:
		fptreef(shf, indent, "<botch>");
		break;
	}
	if ((ioact = t->ioact) != NULL) {
		int	need_nl = 0;

		while (*ioact != NULL)
			pioact(shf, indent, *ioact++);
		/* Print here documents after everything else... */
		for (ioact = t->ioact; *ioact != NULL; ) {
			struct ioword *iop = *ioact++;

			/* heredoc is 0 when tracing (set -x) */
			if ((iop->flag & IOTYPE) == IOHERE && iop->heredoc) {
				tputc('\n', shf);
				shf_puts(iop->heredoc, shf);
				fptreef(shf, indent, "%s",
				    evalstr(iop->delim, 0));
				need_nl = 1;
			}
		}
		/* Last delimiter must be followed by a newline (this often
		 * leads to an extra blank line, but its not worth worrying
		 * about)
		 */
		if (need_nl)
			tputc('\n', shf);
	}
}

static void
pioact(struct shf *shf, int indent, struct ioword *iop)
{
	int flag = iop->flag;
	int type = flag & IOTYPE;
	int expected;

	expected = (type == IOREAD || type == IORDWR || type == IOHERE) ? 0 :
	    (type == IOCAT || type == IOWRITE) ? 1 :
	    (type == IODUP && (iop->unit == !(flag & IORDUP))) ? iop->unit :
	    iop->unit + 1;
	if (iop->unit != expected)
		tputc('0' + iop->unit, shf);

	switch (type) {
	case IOREAD:
		fptreef(shf, indent, "< ");
		break;
	case IOHERE:
		if (flag&IOSKIP)
			fptreef(shf, indent, "<<- ");
		else
			fptreef(shf, indent, "<< ");
		break;
	case IOCAT:
		fptreef(shf, indent, ">> ");
		break;
	case IOWRITE:
		if (flag&IOCLOB)
			fptreef(shf, indent, ">| ");
		else
			fptreef(shf, indent, "> ");
		break;
	case IORDWR:
		fptreef(shf, indent, "<> ");
		break;
	case IODUP:
		if (flag & IORDUP)
			fptreef(shf, indent, "<&");
		else
			fptreef(shf, indent, ">&");
		break;
	}
	/* name/delim are 0 when printing syntax errors */
	if (type == IOHERE) {
		if (iop->delim)
			fptreef(shf, indent, "%S ", iop->delim);
	} else if (iop->name)
		fptreef(shf, indent, (iop->flag & IONAMEXP) ? "%s " : "%S ",
		    iop->name);
}


/*
 * variants of fputc, fputs for ptreef and snptreef
 */

static void
tputC(int c, struct shf *shf)
{
	if ((c&0x60) == 0) {		/* C0|C1 */
		tputc((c&0x80) ? '$' : '^', shf);
		tputc(((c&0x7F)|0x40), shf);
	} else if ((c&0x7F) == 0x7F) {	/* DEL */
		tputc((c&0x80) ? '$' : '^', shf);
		tputc('?', shf);
	} else
		tputc(c, shf);
}

static void
tputS(char *wp, struct shf *shf)
{
	int c, quoted=0;

	/* problems:
	 *	`...` -> $(...)
	 *	'foo' -> "foo"
	 * could change encoding to:
	 *	OQUOTE ["'] ... CQUOTE ["']
	 *	COMSUB [(`] ...\0	(handle $ ` \ and maybe " in `...` case)
	 */
	while (1)
		switch ((c = *wp++)) {
		case EOS:
			return;
		case CHAR:
			tputC(*wp++, shf);
			break;
		case QCHAR:
			c = *wp++;
			if (!quoted || (c == '"' || c == '`' || c == '$'))
				tputc('\\', shf);
			tputC(c, shf);
			break;
		case COMSUB:
			tputc('$', shf);
			tputc('(', shf);
			while (*wp != 0)
				tputC(*wp++, shf);
			tputc(')', shf);
			wp++;
			break;
		case EXPRSUB:
			tputc('$', shf);
			tputc('(', shf);
			tputc('(', shf);
			while (*wp != 0)
				tputC(*wp++, shf);
			tputc(')', shf);
			tputc(')', shf);
			wp++;
			break;
		case OQUOTE:
			quoted = 1;
			tputc('"', shf);
			break;
		case CQUOTE:
			quoted = 0;
			tputc('"', shf);
			break;
		case OSUBST:
			tputc('$', shf);
			if (*wp++ == '{')
				tputc('{', shf);
			while ((c = *wp++) != 0)
				tputC(c, shf);
			break;
		case CSUBST:
			if (*wp++ == '}')
				tputc('}', shf);
			break;
		case OPAT:
			tputc(*wp++, shf);
			tputc('(', shf);
			break;
		case SPAT:
			tputc('|', shf);
			break;
		case CPAT:
			tputc(')', shf);
			break;
		}
}

void
fptreef(struct shf *shf, int indent, const char *fmt, ...)
{
  va_list	va;

  va_start(va, fmt);
  vfptreef(shf, indent, fmt, va);
  va_end(va);
}

char *
snptreef(char *s, int n, const char *fmt, ...)
{
  va_list va;
  struct shf shf;

  shf_sopen(s, n, SHF_WR | (s ? 0 : SHF_DYNAMIC), &shf);

  va_start(va, fmt);
  vfptreef(&shf, 0, fmt, va);
  va_end(va);

  return shf_sclose(&shf); /* null terminates */
}

static void
vfptreef(struct shf *shf, int indent, const char *fmt, va_list va)
{
	int c;

	while ((c = *fmt++)) {
		if (c == '%') {
			long n;
			char *p;
			int neg;

			switch ((c = *fmt++)) {
			case 'c':
				tputc(va_arg(va, int), shf);
				break;
			case 's':
				p = va_arg(va, char *);
				while (*p)
					tputc(*p++, shf);
				break;
			case 'S':	/* word */
				p = va_arg(va, char *);
				tputS(p, shf);
				break;
			case 'd': case 'u': /* decimal */
				n = (c == 'd') ? va_arg(va, int) :
				    va_arg(va, unsigned int);
				neg = c=='d' && n<0;
				p = ulton((neg) ? -n : n, 10);
				if (neg)
					*--p = '-';
				while (*p)
					tputc(*p++, shf);
				break;
			case 'T':	/* format tree */
				ptree(va_arg(va, struct op *), indent, shf);
				break;
			case ';':	/* newline or ; */
			case 'N':	/* newline or space */
				if (shf->flags & SHF_STRING) {
					if (c == ';')
						tputc(';', shf);
					tputc(' ', shf);
				} else {
					int i;

					tputc('\n', shf);
					for (i = indent; i >= 8; i -= 8)
						tputc('\t', shf);
					for (; i > 0; --i)
						tputc(' ', shf);
				}
				break;
			case 'R':
				pioact(shf, indent, va_arg(va, struct ioword *));
				break;
			default:
				tputc(c, shf);
				break;
			}
		} else
			tputc(c, shf);
	}
}

/*
 * copy tree (for function definition)
 */

struct op *
tcopy(struct op *t, Area *ap)
{
	struct op *r;
	char **tw, **rw;

	if (t == NULL)
		return NULL;

	r = alloc(sizeof(struct op), ap);

	r->type = t->type;
	r->u.evalflags = t->u.evalflags;

	r->str = t->type == TCASE ? wdcopy(t->str, ap) : str_save(t->str, ap);

	if (t->vars == NULL)
		r->vars = NULL;
	else {
		for (tw = t->vars; *tw++ != NULL; )
			;
		rw = r->vars = areallocarray(NULL, tw - t->vars + 1,
		    sizeof(*tw), ap);
		for (tw = t->vars; *tw != NULL; )
			*rw++ = wdcopy(*tw++, ap);
		*rw = NULL;
	}

	if (t->args == NULL)
		r->args = NULL;
	else {
		for (tw = t->args; *tw++ != NULL; )
			;
		rw = r->args = areallocarray(NULL, tw - t->args + 1,
		    sizeof(*tw), ap);
		for (tw = t->args; *tw != NULL; )
			*rw++ = wdcopy(*tw++, ap);
		*rw = NULL;
	}

	r->ioact = (t->ioact == NULL) ? NULL : iocopy(t->ioact, ap);

	r->left = tcopy(t->left, ap);
	r->right = tcopy(t->right, ap);
	r->lineno = t->lineno;

	return r;
}

char *
wdcopy(const char *wp, Area *ap)
{
	size_t len = wdscan(wp, EOS) - wp;
	return memcpy(alloc(len, ap), wp, len);
}

/* return the position of prefix c in wp plus 1 */
char *
wdscan(const char *wp, int c)
{
	int nest = 0;

	while (1)
		switch (*wp++) {
		case EOS:
			return (char *) wp;
		case CHAR:
		case QCHAR:
			wp++;
			break;
		case COMSUB:
		case EXPRSUB:
			while (*wp++ != 0)
				;
			break;
		case OQUOTE:
		case CQUOTE:
			break;
		case OSUBST:
			nest++;
			while (*wp++ != '\0')
				;
			break;
		case CSUBST:
			wp++;
			if (c == CSUBST && nest == 0)
				return (char *) wp;
			nest--;
			break;
		case OPAT:
			nest++;
			wp++;
			break;
		case SPAT:
		case CPAT:
			if (c == wp[-1] && nest == 0)
				return (char *) wp;
			if (wp[-1] == CPAT)
				nest--;
			break;
		default:
			internal_errorf(0,
			    "wdscan: unknown char 0x%x (carrying on)",
			    wp[-1]);
		}
}

/* return a copy of wp without any of the mark up characters and
 * with quote characters (" ' \) stripped.
 * (string is allocated from ATEMP)
 */
char *
wdstrip(const char *wp)
{
	struct shf shf;
	int c;

	shf_sopen(NULL, 32, SHF_WR | SHF_DYNAMIC, &shf);

	/* problems:
	 *	`...` -> $(...)
	 *	x${foo:-"hi"} -> x${foo:-hi}
	 *	x${foo:-'hi'} -> x${foo:-hi}
	 */
	while (1)
		switch ((c = *wp++)) {
		case EOS:
			return shf_sclose(&shf); /* null terminates */
		case CHAR:
		case QCHAR:
			shf_putchar(*wp++, &shf);
			break;
		case COMSUB:
			shf_putchar('$', &shf);
			shf_putchar('(', &shf);
			while (*wp != 0)
				shf_putchar(*wp++, &shf);
			shf_putchar(')', &shf);
			break;
		case EXPRSUB:
			shf_putchar('$', &shf);
			shf_putchar('(', &shf);
			shf_putchar('(', &shf);
			while (*wp != 0)
				shf_putchar(*wp++, &shf);
			shf_putchar(')', &shf);
			shf_putchar(')', &shf);
			break;
		case OQUOTE:
			break;
		case CQUOTE:
			break;
		case OSUBST:
			shf_putchar('$', &shf);
			if (*wp++ == '{')
			    shf_putchar('{', &shf);
			while ((c = *wp++) != 0)
				shf_putchar(c, &shf);
			break;
		case CSUBST:
			if (*wp++ == '}')
				shf_putchar('}', &shf);
			break;
		case OPAT:
			shf_putchar(*wp++, &shf);
			shf_putchar('(', &shf);
			break;
		case SPAT:
			shf_putchar('|', &shf);
			break;
		case CPAT:
			shf_putchar(')', &shf);
			break;
		}
}

static	struct ioword **
iocopy(struct ioword **iow, Area *ap)
{
	struct ioword **ior;
	int i;

	for (ior = iow; *ior++ != NULL; )
		;
	ior = areallocarray(NULL, ior - iow + 1, sizeof(*ior), ap);

	for (i = 0; iow[i] != NULL; i++) {
		struct ioword *p, *q;

		p = iow[i];
		q = alloc(sizeof(*p), ap);
		ior[i] = q;
		*q = *p;
		if (p->name != NULL)
			q->name = wdcopy(p->name, ap);
		if (p->delim != NULL)
			q->delim = wdcopy(p->delim, ap);
		if (p->heredoc != NULL)
			q->heredoc = str_save(p->heredoc, ap);
	}
	ior[i] = NULL;

	return ior;
}

/*
 * free tree (for function definition)
 */

void
tfree(struct op *t, Area *ap)
{
	char **w;

	if (t == NULL)
		return;

	afree(t->str, ap);

	if (t->vars != NULL) {
		for (w = t->vars; *w != NULL; w++)
			afree(*w, ap);
		afree(t->vars, ap);
	}

	if (t->args != NULL) {
		for (w = t->args; *w != NULL; w++)
			afree(*w, ap);
		afree(t->args, ap);
	}

	if (t->ioact != NULL)
		iofree(t->ioact, ap);

	tfree(t->left, ap);
	tfree(t->right, ap);

	afree(t, ap);
}

static	void
iofree(struct ioword **iow, Area *ap)
{
	struct ioword **iop;
	struct ioword *p;

	for (iop = iow; (p = *iop++) != NULL; ) {
		afree(p->name, ap);
		afree(p->delim, ap);
		afree(p->heredoc, ap);
		afree(p, ap);
	}
	afree(iow, ap);
}
@


1.26
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.25 2015/10/09 19:36:27 tedu Exp $	*/
d468 2
a469 1
		rw = r->vars = alloc((tw - t->vars + 1) * sizeof(*tw), ap);
d480 2
a481 1
		rw = r->args = alloc((tw - t->args + 1) * sizeof(*tw), ap);
d631 1
a631 1
	ior = alloc((ior - iow + 1) * sizeof(*ior), ap);
@


1.25
log
@remove null check before afree. from Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.24 2015/09/27 05:25:00 guenther Exp $	*/
d6 2
@


1.24
log
@lint is dead: delete the trivial uses of /* VARARGS[0-9]+ */
(others require more care)
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.23 2015/09/17 14:21:33 nicm Exp $	*/
d660 1
a660 2
	if (t->str != NULL)
		afree(t->str, ap);
d690 3
a692 6
		if (p->name != NULL)
			afree(p->name, ap);
		if (p->delim != NULL)
			afree(p->delim, ap);
		if (p->heredoc != NULL)
			afree(p->heredoc, ap);
@


1.23
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.22 2015/09/15 18:15:05 tedu Exp $	*/
a350 5
/*
 * this is the _only_ way to reliably handle
 * variable args with an ANSI compiler
 */
/* VARARGS */
a360 1
/* VARARGS */
@


1.22
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.21 2015/09/01 13:12:31 tedu Exp $	*/
d460 1
a460 1
	r = (struct op *) alloc(sizeof(struct op), ap);
d472 1
a472 2
		rw = r->vars = (char **)
			alloc((tw - t->vars + 1) * sizeof(*tw), ap);
d483 1
a483 2
		rw = r->args = (char **)
			alloc((tw - t->args + 1) * sizeof(*tw), ap);
d633 1
a633 1
	ior = (struct ioword **) alloc((ior - iow + 1) * sizeof(*ior), ap);
d639 1
a639 1
		q = (struct ioword *) alloc(sizeof(*p), ap);
@


1.21
log
@remove casts and null checks before free. from Michael McConville
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.20 2012/06/27 07:17:19 otto Exp $	*/
d568 1
a568 1
	shf_sopen((char *) 0, 32, SHF_WR | SHF_DYNAMIC, &shf);
d644 1
a644 1
		if (p->name != (char *) 0)
d646 1
a646 1
		if (p->delim != (char *) 0)
d648 1
a648 1
		if (p->heredoc != (char *) 0)
@


1.20
log
@fptreef() always returns 0 and we never use the return value anyway,
so make it void; from Michael W. Bombardieri.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.19 2008/08/11 21:50:35 jaredy Exp $	*/
d669 1
a669 1
		afree((void*)t->str, ap);
d673 2
a674 2
			afree((void*)*w, ap);
		afree((void*)t->vars, ap);
d679 2
a680 2
			afree((void*)*w, ap);
		afree((void*)t->args, ap);
d689 1
a689 1
	afree((void*)t, ap);
d700 1
a700 1
			afree((void*)p->name, ap);
d702 1
a702 1
			afree((void*)p->delim, ap);
d704 2
a705 2
			afree((void*)p->heredoc, ap);
		afree((void*)p, ap);
@


1.19
log
@plug a memleak when freeing io redirection in commands.
the leaked memory is actually reclaimed when the command
finishes but may grow until that happens, e.g. during
command execution.

ok phessler@@.
testing sobrado@@ jmc@@ oga@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.18 2006/04/10 14:38:59 jaredy Exp $	*/
d356 1
a356 1
int
a361 1

a363 1
  return 0;
@


1.18
log
@fix lint comments, no functional changes; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.17 2005/03/30 17:16:37 deraadt Exp $	*/
d709 1
@


1.17
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.16 2005/03/28 21:28:22 deraadt Exp $	*/
d99 1
a99 1
		/* fall through */
@


1.16
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.15 2004/12/20 11:34:26 otto Exp $	*/
d35 1
a35 1
	  case TCOM:
d47 1
a47 1
	  case TEXEC:
d67 1
a67 1
	  case TPAREN:
d70 1
a70 1
	  case TPIPE:
d74 1
a74 1
	  case TLIST:
d78 2
a79 2
	  case TOR:
	  case TAND:
d81 1
a81 1
			t->left, (t->type==TOR) ? "||" : "&&", t->right);
d83 1
a83 1
	  case TBANG:
d87 1
a87 1
	  case TDBRACKET:
d97 1
a97 1
	  case TSELECT:
d100 1
a100 1
	  case TFOR:
d112 1
a112 1
	  case TCASE:
d118 1
a118 1
					(w[1] != NULL) ? '|' : ')');
d123 2
a124 2
	  case TIF:
	  case TELIF:
d132 1
a132 1
					t->left);
d147 2
a148 2
	  case TWHILE:
	  case TUNTIL:
d151 2
a152 2
			(t->type==TWHILE) ? "while" : "until",
			t->left);
d157 1
a157 1
	  case TBRACE:
d161 1
a161 1
	  case TCOPROC:
d164 1
a164 1
	  case TASYNC:
d167 1
a167 1
	  case TFUNCT:
d169 2
a170 2
			t->u.ksh_func ? "function %s %T" : "%s() %T",
				t->str, t->left);
d172 1
a172 1
	  case TTIME:
d175 1
a175 1
	  default:
d193 1
a193 1
					evalstr(iop->delim, 0));
d213 4
a216 5
	expected = (type == IOREAD || type == IORDWR || type == IOHERE) ? 0
		    : (type == IOCAT || type == IOWRITE) ? 1
		    : (type == IODUP && (iop->unit == !(flag & IORDUP))) ?
			iop->unit
		    : iop->unit + 1;
d255 1
a255 1
			iop->name);
d290 1
a290 1
		  case EOS:
d292 1
a292 1
		  case CHAR:
d295 1
a295 1
		  case QCHAR:
d301 1
a301 1
		  case COMSUB:
d309 1
a309 1
		  case EXPRSUB:
d319 1
a319 1
		  case OQUOTE:
d323 1
a323 1
		  case CQUOTE:
d327 1
a327 1
		  case OSUBST:
d334 1
a334 1
		  case CSUBST:
d338 1
a338 1
		  case OPAT:
d342 1
a342 1
		  case SPAT:
d345 1
a345 1
		  case CPAT:
d389 40
a428 40
	while ((c = *fmt++))
	    if (c == '%') {
		long n;
		char *p;
		int neg;

		switch ((c = *fmt++)) {
		  case 'c':
			tputc(va_arg(va, int), shf);
			break;
		  case 's':
			p = va_arg(va, char *);
			while (*p)
				tputc(*p++, shf);
			break;
		  case 'S':	/* word */
			p = va_arg(va, char *);
			tputS(p, shf);
			break;
		  case 'd': case 'u': /* decimal */
			n = (c == 'd') ? va_arg(va, int)
				       : va_arg(va, unsigned int);
			neg = c=='d' && n<0;
			p = ulton((neg) ? -n : n, 10);
			if (neg)
				*--p = '-';
			while (*p)
				tputc(*p++, shf);
			break;
		  case 'T':	/* format tree */
			ptree(va_arg(va, struct op *), indent, shf);
			break;
		  case ';':	/* newline or ; */
		  case 'N':	/* newline or space */
			if (shf->flags & SHF_STRING) {
				if (c == ';')
					tputc(';', shf);
				tputc(' ', shf);
			} else {
				int i;
d430 13
a442 5
				tputc('\n', shf);
				for (i = indent; i >= 8; i -= 8)
					tputc('\t', shf);
				for (; i > 0; --i)
					tputc(' ', shf);
d444 1
a444 5
			break;
		  case 'R':
			pioact(shf, indent, va_arg(va, struct ioword *));
			break;
		  default:
d446 1
a446 4
			break;
		}
	    } else
		tputc(c, shf);
d517 1
a517 1
		  case EOS:
d519 2
a520 2
		  case CHAR:
		  case QCHAR:
d523 2
a524 2
		  case COMSUB:
		  case EXPRSUB:
d528 2
a529 2
		  case OQUOTE:
		  case CQUOTE:
d531 1
a531 1
		  case OSUBST:
d536 1
a536 1
		  case CSUBST:
d542 1
a542 1
		  case OPAT:
d546 2
a547 2
		  case SPAT:
		  case CPAT:
d553 1
a553 1
		  default:
d555 2
a556 2
				"wdscan: unknown char 0x%x (carrying on)",
				wp[-1]);
d579 1
a579 1
		  case EOS:
d581 2
a582 2
		  case CHAR:
		  case QCHAR:
d585 1
a585 1
		  case COMSUB:
d592 1
a592 1
		  case EXPRSUB:
d601 1
a601 1
		  case OQUOTE:
d603 1
a603 1
		  case CQUOTE:
d605 1
a605 1
		  case OSUBST:
d612 1
a612 1
		  case CSUBST:
d616 1
a616 1
		  case OPAT:
d620 1
a620 1
		  case SPAT:
d623 1
a623 1
		  case CPAT:
@


1.15
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.14 2004/12/19 04:14:20 deraadt Exp $	*/
d12 2
a13 2
static void 	ptree(struct op *, int, struct shf *);
static void 	pioact(struct shf *, int, struct ioword *);
d287 1
a287 1
	 * 	COMSUB [(`] ...\0	(handle $ ` \ and maybe " in `...` case)
@


1.14
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.13 2004/12/18 21:25:44 millert Exp $	*/
d12 7
a18 7
static void 	ptree(struct op *t, int indent, struct shf *f);
static void 	pioact(struct shf *f, int indent, struct ioword *iop);
static void	tputC(int c, struct shf *shf);
static void	tputS(char *wp, struct shf *shf);
static void	vfptreef(struct shf *shf, int indent, const char *fmt, va_list va);
static struct ioword **iocopy(struct ioword **iow, Area *ap);
static void     iofree(struct ioword **iow, Area *ap);
d25 1
a25 4
ptree(t, indent, shf)
	struct op *t;
	int indent;
	struct shf *shf;
d207 1
a207 4
pioact(shf, indent, iop)
	struct shf *shf;
	int indent;
	struct ioword *iop;
d265 1
a265 3
tputC(c, shf)
	int c;
	struct shf *shf;
d278 1
a278 3
tputS(wp, shf)
	char *wp;
	struct shf *shf;
d386 1
a386 5
vfptreef(shf, indent, fmt, va)
	struct shf *shf;
	int indent;
	const char *fmt;
	va_list va;
d454 1
a454 3
tcopy(t, ap)
	struct op *t;
	Area *ap;
d503 1
a503 3
wdcopy(wp, ap)
	const char *wp;
	Area *ap;
d511 1
a511 3
wdscan(wp, c)
	const char *wp;
	int c;
d565 1
a565 2
wdstrip(wp)
	const char *wp;
d630 1
a630 3
iocopy(iow, ap)
	struct ioword **iow;
	Area *ap;
d663 1
a663 3
tfree(t, ap)
	struct op *t;
	Area *ap;
d695 1
a695 3
iofree(iow, ap)
	struct ioword **iow;
	Area *ap;
@


1.13
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.12 2004/12/18 21:04:52 millert Exp $	*/
d331 1
a331 1
		  	quoted = 1;
@


1.12
log
@Get rid of #ifdef KSH since we don't care about building a V7 style sh and
the #ifdef KSH code is required to make a POSIX sh.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.11 2004/12/18 20:55:52 millert Exp $	*/
d26 1
a26 1
	register struct op *t;
d28 1
a28 1
	register struct shf *shf;
d30 1
a30 1
	register char **w;
d211 1
a211 1
	register struct shf *shf;
d213 1
a213 1
	register struct ioword *iop;
d272 2
a273 2
	register int c;
	register struct shf *shf;
d287 2
a288 2
	register char *wp;
	register struct shf *shf;
d290 1
a290 1
	register int c, quoted=0;
d397 1
a397 1
	register struct shf *shf;
d400 1
a400 1
	register va_list va;
d402 1
a402 1
	register int c;
d406 2
a407 2
		register long n;
		register char *p;
d469 1
a469 1
	register struct op *t;
d472 2
a473 2
	register struct op *r;
	register char **tw, **rw;
d530 2
a531 2
	register const char *wp;
	register int c;
d533 1
a533 1
	register int nest = 0;
d652 1
a652 1
	register struct ioword **iow;
d655 2
a656 2
	register struct ioword **ior;
	register int i;
d663 1
a663 1
		register struct ioword *p, *q;
d687 1
a687 1
	register struct op *t;
d690 1
a690 1
	register char **w;
d724 2
a725 2
	register struct ioword **iop;
	register struct ioword *p;
@


1.11
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.10 2002/02/27 19:37:09 dhartmei Exp $	*/
a99 1
#ifdef KSH
a102 1
#endif /* KSH */
a348 1
#ifdef KSH
a358 1
#endif /* KSH */
a561 1
#ifdef KSH
a572 1
#endif /* KSH */
a636 1
#ifdef KSH
a646 1
#endif /* KSH */
@


1.10
log
@Fix three off-by-one errors. ok espie@@, millert@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.9 1999/07/14 13:37:24 millert Exp $	*/
d12 7
a18 7
static void 	ptree ARGS((struct op *t, int indent, struct shf *f));
static void 	pioact ARGS((struct shf *f, int indent, struct ioword *iop));
static void	tputC ARGS((int c, struct shf *shf));
static void	tputS ARGS((char *wp, struct shf *shf));
static void	vfptreef ARGS((struct shf *shf, int indent, const char *fmt, va_list va));
static struct ioword **iocopy ARGS((struct ioword **iow, Area *ap));
static void     iofree ARGS((struct ioword **iow, Area *ap));
a371 1
#ifdef HAVE_PROTOTYPES
a372 7
#else
fptreef(shf, indent, fmt, va_alist)
  struct shf *shf;
  int indent;
  const char *fmt;
  va_dcl
#endif
d376 1
a376 1
  SH_VA_START(va, fmt);
a384 1
#ifdef HAVE_PROTOTYPES
a385 7
#else
snptreef(s, n, fmt, va_alist)
  char *s;
  int n;
  const char *fmt;
  va_dcl
#endif
d392 1
a392 1
  SH_VA_START(va, fmt);
@


1.9
log
@pdksh-5.2.14
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.8 1999/06/15 01:18:36 millert Exp $	*/
d511 1
a511 1
			alloc((int)(tw - t->vars) * sizeof(*tw), ap);
d523 1
a523 1
			alloc((int)(tw - t->args) * sizeof(*tw), ap);
d684 1
a684 1
	ior = (struct ioword **) alloc((int)(ior - iow) * sizeof(*ior), ap);
@


1.8
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.7 1998/10/29 04:09:21 millert Exp $	*/
d51 16
d69 1
@


1.7
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.6 1998/06/25 19:02:24 millert Exp $	*/
d176 2
a177 6
			/* name is 0 when tracing (set -x) */
			if ((iop->flag & IOTYPE) == IOHERE && iop->name) {
				struct shf *rshf;
				char buf[1024];
				int n;

d179 3
a181 9
				if ((rshf = shf_open(iop->name, O_RDONLY, 0, 0))) {
					while ((n = shf_read(buf, sizeof(buf), rshf))
										> 0)
						shf_write(buf, n, shf);
					shf_close(rshf);
				} else
					errorf("can't open %s - %s",
						iop->name, strerror(errno));
				fptreef(shf, indent, "%s", evalstr(iop->delim, 0));
d516 1
d578 4
d680 2
d737 4
@


1.6
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.5 1997/09/01 18:30:15 deraadt Exp $	*/
d313 1
d323 1
@


1.5
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.4 1997/06/19 13:58:48 kstailey Exp $	*/
d156 3
a158 1
		fptreef(shf, indent, "function %s %T", t->str, t->left);
d287 7
d333 2
a334 1
			tputc('{', shf);
d339 2
a340 1
			tputc('}', shf);
d567 1
d583 72
@


1.4
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.2 1996/08/19 20:09:01 downsj Exp $	*/
d355 1
a355 1
fptreef(shf, indent, fmt, va_alist) 
d365 1
a365 1
  
@


1.3
log
@(foo *)0 -> NULL
@
text
@d595 1
a595 1
		if (p->name != NULL)
d597 1
a597 1
		if (p->delim != NULL)
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.1.1.1 1996/08/14 06:19:12 downsj Exp $	*/
d595 1
a595 1
		if (p->name != (char *) 0)
d597 1
a597 1
		if (p->delim != (char *) 0)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d481 1
a481 1
	r->evalflags = t->evalflags;
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
