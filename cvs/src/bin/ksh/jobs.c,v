head	1.55;
access;
symbols
	OPENBSD_6_2:1.55.0.4
	OPENBSD_6_2_BASE:1.55
	OPENBSD_6_1:1.55.0.6
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.55.0.2
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.40.0.6
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.39.0.16
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.14
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.12
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.10
	OPENBSD_5_0:1.39.0.8
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.39.0.6
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.4
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.37.0.6
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.36.0.4
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.35.0.8
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.35.0.6
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.35.0.4
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.34.0.2
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.21.0.4
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.19.0.4
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.12
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.16.0.10
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.16.0.8
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_8:1.16.0.6
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.4
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.55
date	2016.03.17.23.33.23;	author mmcc;	state Exp;
branches;
next	1.54;
commitid	Vulj8lha6PuDYESy;

1.54
date	2015.12.30.09.07.00;	author tedu;	state Exp;
branches;
next	1.53;
commitid	WTwPzlskFufQpRQz;

1.53
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.52;
commitid	btTCreDA00YdaFhU;

1.52
date	2015.11.12.22.33.07;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	yL2gco0cO8wLO0qe;

1.51
date	2015.11.12.04.04.31;	author mmcc;	state Exp;
branches;
next	1.50;
commitid	QvyWaajN4Lc4MRtd;

1.50
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.49;
commitid	C4W85jmosThChWA2;

1.49
date	2015.10.19.14.03.21;	author mmcc;	state Exp;
branches;
next	1.48;
commitid	TSZF0K3aGmPbKQzz;

1.48
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.47;
commitid	16HUr75moyUNtKR8;

1.47
date	2015.09.17.21.39.54;	author nicm;	state Exp;
branches;
next	1.46;
commitid	kqHrwR3VHcPphk1W;

1.46
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.45;
commitid	v5QjoxUgKU2iUTFz;

1.45
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.44;
commitid	lBs9un9sXhbdfVrQ;

1.44
date	2015.09.15.18.07.22;	author tedu;	state Exp;
branches;
next	1.43;
commitid	a9KLxOATj99CUewS;

1.43
date	2015.09.10.22.48.58;	author nicm;	state Exp;
branches;
next	1.42;
commitid	stJ3KRI2o7F5OBtF;

1.42
date	2015.09.10.13.04.52;	author nicm;	state Exp;
branches;
next	1.41;
commitid	8HJGYJIXkSSMl2vq;

1.41
date	2015.04.18.18.28.36;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	6b2lLILbgCR1fvia;

1.40
date	2013.09.04.15.49.18;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2009.12.13.04.36.48;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2009.12.12.04.28.44;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.29.23.27.26;	author jaredy;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.06.19.57.47;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2006.02.06.16.47.07;	author jmc;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.28.21.28.22;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2005.02.25.11.21.16;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2004.12.30.21.34.24;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.22.18.48.56;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.19.04.14.20;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.18.22.12.23;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.18.22.11.43;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.18.21.04.52;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.04.19.20.07;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.10.21.26.39;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.22.07.40.38;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.13.09.03.07;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.16;

1.16
date	99.08.04.16.56.42;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	99.08.02.12.37.07;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.07.14.13.37.23;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.01.19.20.41.53;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.01.10.17.55.02;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.01.08.20.24.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.11.19.19.59.09;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.11.19.19.54.34;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.10.29.04.09.20;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.06.25.19.02.02;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.06.19.13.58.43;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.06.18.22.42.37;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.11.21.07.59.29;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.08.25.12.38.03;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.52;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.55
log
@remove some ARGSUSED
@
text
@/*	$OpenBSD: jobs.c,v 1.54 2015/12/30 09:07:00 tedu Exp $	*/

/*
 * Process and job control
 */

/*
 * Reworked/Rewritten version of Eric Gisin's/Ron Natalie's code by
 * Larry Bouzane (larry@@cs.mun.ca) and hacked again by
 * Michael Rendell (michael@@cs.mun.ca)
 *
 * The interface to the rest of the shell should probably be changed
 * to allow use of vfork() when available but that would be way too much
 * work :)
 *
 */

#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "sh.h"
#include "tty.h"

/* Order important! */
#define PRUNNING	0
#define PEXITED		1
#define PSIGNALLED	2
#define PSTOPPED	3

typedef struct proc	Proc;
struct proc {
	Proc	*next;		/* next process in pipeline (if any) */
	int	state;
	int	status;		/* wait status */
	pid_t	pid;		/* process id */
	char	command[48];	/* process command string */
};

/* Notify/print flag - j_print() argument */
#define JP_NONE		0	/* don't print anything */
#define JP_SHORT	1	/* print signals processes were killed by */
#define JP_MEDIUM	2	/* print [job-num] -/+ command */
#define JP_LONG		3	/* print [job-num] -/+ pid command */
#define JP_PGRP		4	/* print pgrp */

/* put_job() flags */
#define PJ_ON_FRONT	0	/* at very front */
#define PJ_PAST_STOPPED	1	/* just past any stopped jobs */

/* Job.flags values */
#define JF_STARTED	0x001	/* set when all processes in job are started */
#define JF_WAITING	0x002	/* set if j_waitj() is waiting on job */
#define JF_W_ASYNCNOTIFY 0x004	/* set if waiting and async notification ok */
#define JF_XXCOM	0x008	/* set for `command` jobs */
#define JF_FG		0x010	/* running in foreground (also has tty pgrp) */
#define JF_SAVEDTTY	0x020	/* j->ttystate is valid */
#define JF_CHANGED	0x040	/* process has changed state */
#define JF_KNOWN	0x080	/* $! referenced */
#define JF_ZOMBIE	0x100	/* known, unwaited process */
#define JF_REMOVE	0x200	/* flagged for removal (j_jobs()/j_noityf()) */
#define JF_USETTYMODE	0x400	/* tty mode saved if process exits normally */
#define JF_SAVEDTTYPGRP	0x800	/* j->saved_ttypgrp is valid */

typedef struct job Job;
struct job {
	Job	*next;		/* next job in list */
	int	job;		/* job number: %n */
	int	flags;		/* see JF_* */
	int	state;		/* job state */
	int	status;		/* exit status of last process */
	pid_t	pgrp;		/* process group of job */
	pid_t	ppid;		/* pid of process that forked job */
	int	age;		/* number of jobs started */
	struct timeval systime;	/* system time used by job */
	struct timeval usrtime;	/* user time used by job */
	Proc	*proc_list;	/* process list */
	Proc	*last_proc;	/* last process in list */
	Coproc_id coproc_id;	/* 0 or id of coprocess output pipe */
#ifdef JOBS
	struct termios ttystate;/* saved tty state for stopped jobs */
	pid_t	saved_ttypgrp;	/* saved tty process group for stopped jobs */
#endif /* JOBS */
};

/* Flags for j_waitj() */
#define JW_NONE		0x00
#define JW_INTERRUPT	0x01	/* ^C will stop the wait */
#define JW_ASYNCNOTIFY	0x02	/* asynchronous notification during wait ok */
#define JW_STOPPEDWAIT	0x04	/* wait even if job stopped */

/* Error codes for j_lookup() */
#define JL_OK		0
#define JL_NOSUCH	1	/* no such job */
#define JL_AMBIG	2	/* %foo or %?foo is ambiguous */
#define JL_INVALID	3	/* non-pid, non-% job id */

static const char	*const lookup_msgs[] = {
	null,
	"no such job",
	"ambiguous",
	"argument must be %job or process id",
	NULL
};

struct timeval	j_systime, j_usrtime;	/* user and system time of last j_waitjed job */

static Job		*job_list;	/* job list */
static Job		*last_job;
static Job		*async_job;
static pid_t		async_pid;

static int		nzombie;	/* # of zombies owned by this process */
int			njobs;		/* # of jobs started */
static int		child_max;	/* CHILD_MAX */


/* held_sigchld is set if sigchld occurs before a job is completely started */
static volatile sig_atomic_t held_sigchld;

#ifdef JOBS
static struct shf	*shl_j;
static int		ttypgrp_ok;	/* set if can use tty pgrps */
static pid_t		restore_ttypgrp = -1;
static pid_t		our_pgrp;
static int const	tt_sigs[] = { SIGTSTP, SIGTTIN, SIGTTOU };
#endif /* JOBS */

static void		j_set_async(Job *);
static void		j_startjob(Job *);
static int		j_waitj(Job *, int, const char *);
static void		j_sigchld(int);
static void		j_print(Job *, int, struct shf *);
static Job		*j_lookup(const char *, int *);
static Job		*new_job(void);
static Proc		*new_proc(void);
static void		check_job(Job *);
static void		put_job(Job *, int);
static void		remove_job(Job *, const char *);
static int		kill_job(Job *, int);

/* initialize job control */
void
j_init(int mflagset)
{
	child_max = CHILD_MAX; /* so syscon() isn't always being called */

	sigemptyset(&sm_default);
	sigprocmask(SIG_SETMASK, &sm_default, NULL);

	sigemptyset(&sm_sigchld);
	sigaddset(&sm_sigchld, SIGCHLD);

	setsig(&sigtraps[SIGCHLD], j_sigchld,
	    SS_RESTORE_ORIG|SS_FORCE|SS_SHTRAP);

#ifdef JOBS
	if (!mflagset && Flag(FTALKING))
		Flag(FMONITOR) = 1;

	/* shl_j is used to do asynchronous notification (used in
	 * an interrupt handler, so need a distinct shf)
	 */
	shl_j = shf_fdopen(2, SHF_WR, NULL);

	if (Flag(FMONITOR) || Flag(FTALKING)) {
		int i;

		/* the TF_SHELL_USES test is a kludge that lets us know if
		 * if the signals have been changed by the shell.
		 */
		for (i = NELEM(tt_sigs); --i >= 0; ) {
			sigtraps[tt_sigs[i]].flags |= TF_SHELL_USES;
			/* j_change() sets this to SS_RESTORE_DFL if FMONITOR */
			setsig(&sigtraps[tt_sigs[i]], SIG_IGN,
			    SS_RESTORE_IGN|SS_FORCE);
		}
	}

	/* j_change() calls tty_init() */
	if (Flag(FMONITOR))
		j_change();
	else
#endif /* JOBS */
		if (Flag(FTALKING))
			tty_init(true);
}

/* suspend the shell */
void
j_suspend(void)
{
	struct sigaction sa, osa;

	/* Restore tty and pgrp. */
	if (ttypgrp_ok) {
		tcsetattr(tty_fd, TCSADRAIN, &tty_state);
		if (restore_ttypgrp >= 0) {
			if (tcsetpgrp(tty_fd, restore_ttypgrp) < 0) {
				warningf(false,
				    "j_suspend: tcsetpgrp() failed: %s",
				    strerror(errno));
			} else {
				if (setpgid(0, restore_ttypgrp) < 0) {
					warningf(false,
					    "j_suspend: setpgid() failed: %s",
					    strerror(errno));
				}
			}
		}
	}

	/* Suspend the shell. */
	memset(&sa, 0, sizeof(sa));
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = SIG_DFL;
	sigaction(SIGTSTP, &sa, &osa);
	kill(0, SIGTSTP);

	/* Back from suspend, reset signals, pgrp and tty. */
	sigaction(SIGTSTP, &osa, NULL);
	if (ttypgrp_ok) {
		if (restore_ttypgrp >= 0) {
			if (setpgid(0, kshpid) < 0) {
				warningf(false,
				    "j_suspend: setpgid() failed: %s",
				    strerror(errno));
				ttypgrp_ok = 0;
			} else {
				if (tcsetpgrp(tty_fd, kshpid) < 0) {
					warningf(false,
					    "j_suspend: tcsetpgrp() failed: %s",
					    strerror(errno));
					ttypgrp_ok = 0;
				}
			}
		}
		tty_init(true);
	}
}

/* job cleanup before shell exit */
void
j_exit(void)
{
	/* kill stopped, and possibly running, jobs */
	Job	*j;
	int	killed = 0;

	for (j = job_list; j != NULL; j = j->next) {
		if (j->ppid == procpid &&
		    (j->state == PSTOPPED ||
		    (j->state == PRUNNING &&
		    ((j->flags & JF_FG) ||
		    (Flag(FLOGIN) && !Flag(FNOHUP) && procpid == kshpid))))) {
			killed = 1;
			if (j->pgrp == 0)
				kill_job(j, SIGHUP);
			else
				killpg(j->pgrp, SIGHUP);
#ifdef JOBS
			if (j->state == PSTOPPED) {
				if (j->pgrp == 0)
					kill_job(j, SIGCONT);
				else
					killpg(j->pgrp, SIGCONT);
			}
#endif /* JOBS */
		}
	}
	if (killed)
		sleep(1);
	j_notify();

#ifdef JOBS
	if (kshpid == procpid && restore_ttypgrp >= 0) {
		/* Need to restore the tty pgrp to what it was when the
		 * shell started up, so that the process that started us
		 * will be able to access the tty when we are done.
		 * Also need to restore our process group in case we are
		 * about to do an exec so that both our parent and the
		 * process we are to become will be able to access the tty.
		 */
		tcsetpgrp(tty_fd, restore_ttypgrp);
		setpgid(0, restore_ttypgrp);
	}
	if (Flag(FMONITOR)) {
		Flag(FMONITOR) = 0;
		j_change();
	}
#endif /* JOBS */
}

#ifdef JOBS
/* turn job control on or off according to Flag(FMONITOR) */
void
j_change(void)
{
	int i;

	if (Flag(FMONITOR)) {
		int use_tty;

		if (Flag(FTALKING)) {
			/* Don't call tcgetattr() 'til we own the tty process group */
			use_tty = 1;
			tty_init(false);
		} else
			use_tty = 0;

		/* no controlling tty, no SIGT* */
		ttypgrp_ok = use_tty && tty_fd >= 0 && tty_devtty;

		if (ttypgrp_ok && (our_pgrp = getpgrp()) < 0) {
			warningf(false, "j_init: getpgrp() failed: %s",
			    strerror(errno));
			ttypgrp_ok = 0;
		}
		if (ttypgrp_ok) {
			setsig(&sigtraps[SIGTTIN], SIG_DFL,
			    SS_RESTORE_ORIG|SS_FORCE);
			/* wait to be given tty (POSIX.1, B.2, job control) */
			while (1) {
				pid_t ttypgrp;

				if ((ttypgrp = tcgetpgrp(tty_fd)) < 0) {
					warningf(false,
					    "j_init: tcgetpgrp() failed: %s",
					    strerror(errno));
					ttypgrp_ok = 0;
					break;
				}
				if (ttypgrp == our_pgrp)
					break;
				kill(0, SIGTTIN);
			}
		}
		for (i = NELEM(tt_sigs); --i >= 0; )
			setsig(&sigtraps[tt_sigs[i]], SIG_IGN,
			    SS_RESTORE_DFL|SS_FORCE);
		if (ttypgrp_ok && our_pgrp != kshpid) {
			if (setpgid(0, kshpid) < 0) {
				warningf(false,
				    "j_init: setpgid() failed: %s",
				    strerror(errno));
				ttypgrp_ok = 0;
			} else {
				if (tcsetpgrp(tty_fd, kshpid) < 0) {
					warningf(false,
					    "j_init: tcsetpgrp() failed: %s",
					    strerror(errno));
					ttypgrp_ok = 0;
				} else
					restore_ttypgrp = our_pgrp;
				our_pgrp = kshpid;
			}
		}
		if (use_tty) {
			if (!ttypgrp_ok)
				warningf(false, "warning: won't have full job control");
		}
		if (tty_fd >= 0)
			tcgetattr(tty_fd, &tty_state);
	} else {
		ttypgrp_ok = 0;
		if (Flag(FTALKING))
			for (i = NELEM(tt_sigs); --i >= 0; )
				setsig(&sigtraps[tt_sigs[i]], SIG_IGN,
				    SS_RESTORE_IGN|SS_FORCE);
		else
			for (i = NELEM(tt_sigs); --i >= 0; ) {
				if (sigtraps[tt_sigs[i]].flags &
				    (TF_ORIG_IGN | TF_ORIG_DFL))
					setsig(&sigtraps[tt_sigs[i]],
					    (sigtraps[tt_sigs[i]].flags & TF_ORIG_IGN) ?
					    SIG_IGN : SIG_DFL,
					    SS_RESTORE_ORIG|SS_FORCE);
			}
		if (!Flag(FTALKING))
			tty_close();
	}
}
#endif /* JOBS */

/* execute tree in child subprocess */
int
exchild(struct op *t, int flags, volatile int *xerrok,
    int close_fd)	/* used if XPCLOSE or XCCLOSE */
{
	static Proc	*last_proc;	/* for pipelines */

	int		i;
	sigset_t	omask;
	Proc		*p;
	Job		*j;
	int		rv = 0;
	int		forksleep;
	int		ischild;

	if (flags & XEXEC)
		/* Clear XFORK|XPCLOSE|XCCLOSE|XCOPROC|XPIPEO|XPIPEI|XXCOM|XBGND
		 * (also done in another execute() below)
		 */
		return execute(t, flags & (XEXEC | XERROK), xerrok);

	/* no SIGCHLD's while messing with job and process lists */
	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);

	p = new_proc();
	p->next = NULL;
	p->state = PRUNNING;
	p->status = 0;
	p->pid = 0;

	/* link process into jobs list */
	if (flags&XPIPEI) {	/* continuing with a pipe */
		if (!last_job)
			internal_errorf(1,
			    "exchild: XPIPEI and no last_job - pid %d",
			    (int) procpid);
		j = last_job;
		last_proc->next = p;
		last_proc = p;
	} else {
		j = new_job(); /* fills in j->job */
		/* we don't consider XXCOM's foreground since they don't get
		 * tty process group and we don't save or restore tty modes.
		 */
		j->flags = (flags & XXCOM) ? JF_XXCOM :
		    ((flags & XBGND) ? 0 : (JF_FG|JF_USETTYMODE));
		timerclear(&j->usrtime);
		timerclear(&j->systime);
		j->state = PRUNNING;
		j->pgrp = 0;
		j->ppid = procpid;
		j->age = ++njobs;
		j->proc_list = p;
		j->coproc_id = 0;
		last_job = j;
		last_proc = p;
		put_job(j, PJ_PAST_STOPPED);
	}

	snptreef(p->command, sizeof(p->command), "%T", t);

	/* create child process */
	forksleep = 1;
	while ((i = fork()) < 0 && errno == EAGAIN && forksleep < 32) {
		if (intrsig)	 /* allow user to ^C out... */
			break;
		sleep(forksleep);
		forksleep <<= 1;
	}
	if (i < 0) {
		kill_job(j, SIGKILL);
		remove_job(j, "fork failed");
		sigprocmask(SIG_SETMASK, &omask, NULL);
		errorf("cannot fork - try again");
	}
	ischild = i == 0;
	if (ischild)
		p->pid = procpid = getpid();
	else
		p->pid = i;

#ifdef JOBS
	/* job control set up */
	if (Flag(FMONITOR) && !(flags&XXCOM)) {
		int	dotty = 0;
		if (j->pgrp == 0) {	/* First process */
			j->pgrp = p->pid;
			dotty = 1;
		}

		/* set pgrp in both parent and child to deal with race
		 * condition
		 */
		setpgid(p->pid, j->pgrp);
		/* YYY: should this be
		   if (ttypgrp_ok && ischild && !(flags&XBGND))
			tcsetpgrp(tty_fd, j->pgrp);
		   instead? (see also YYY below)
		 */
		if (ttypgrp_ok && dotty && !(flags & XBGND))
			tcsetpgrp(tty_fd, j->pgrp);
	}
#endif /* JOBS */

	/* used to close pipe input fd */
	if (close_fd >= 0 && (((flags & XPCLOSE) && !ischild) ||
	    ((flags & XCCLOSE) && ischild)))
		close(close_fd);
	if (ischild) {		/* child */
		/* Do this before restoring signal */
		if (flags & XCOPROC)
			coproc_cleanup(false);
		sigprocmask(SIG_SETMASK, &omask, NULL);
		cleanup_parents_env();
#ifdef JOBS
		/* If FMONITOR or FTALKING is set, these signals are ignored,
		 * if neither FMONITOR nor FTALKING are set, the signals have
		 * their inherited values.
		 */
		if (Flag(FMONITOR) && !(flags & XXCOM)) {
			for (i = NELEM(tt_sigs); --i >= 0; )
				setsig(&sigtraps[tt_sigs[i]], SIG_DFL,
				    SS_RESTORE_DFL|SS_FORCE);
		}
#endif /* JOBS */
		if (Flag(FBGNICE) && (flags & XBGND))
			nice(4);
		if ((flags & XBGND) && !Flag(FMONITOR)) {
			setsig(&sigtraps[SIGINT], SIG_IGN,
			    SS_RESTORE_IGN|SS_FORCE);
			setsig(&sigtraps[SIGQUIT], SIG_IGN,
			    SS_RESTORE_IGN|SS_FORCE);
			if (!(flags & (XPIPEI | XCOPROC))) {
				int fd = open("/dev/null", O_RDONLY);
				if (fd != 0) {
					(void) ksh_dup2(fd, 0, true);
					close(fd);
				}
			}
		}
		remove_job(j, "child");	/* in case of `jobs` command */
		nzombie = 0;
#ifdef JOBS
		ttypgrp_ok = 0;
		Flag(FMONITOR) = 0;
#endif /* JOBS */
		Flag(FTALKING) = 0;
		tty_close();
		cleartraps();
		execute(t, (flags & XERROK) | XEXEC, NULL); /* no return */
		internal_errorf(0, "exchild: execute() returned");
		unwind(LLEAVE);
		/* NOTREACHED */
	}

	/* shell (parent) stuff */
	/* Ensure next child gets a (slightly) different $RANDOM sequence */
	change_random();
	if (!(flags & XPIPEO)) {	/* last process in a job */
#ifdef JOBS
		/* YYY: Is this needed? (see also YYY above)
		   if (Flag(FMONITOR) && !(flags&(XXCOM|XBGND)))
			tcsetpgrp(tty_fd, j->pgrp);
		*/
#endif /* JOBS */
		j_startjob(j);
		if (flags & XCOPROC) {
			j->coproc_id = coproc.id;
			coproc.njobs++; /* n jobs using co-process output */
			coproc.job = (void *) j; /* j using co-process input */
		}
		if (flags & XBGND) {
			j_set_async(j);
			if (Flag(FTALKING)) {
				shf_fprintf(shl_out, "[%d]", j->job);
				for (p = j->proc_list; p; p = p->next)
					shf_fprintf(shl_out, " %d", p->pid);
				shf_putchar('\n', shl_out);
				shf_flush(shl_out);
			}
		} else
			rv = j_waitj(j, JW_NONE, "jw:last proc");
	}

	sigprocmask(SIG_SETMASK, &omask, NULL);

	return rv;
}

/* start the last job: only used for `command` jobs */
void
startlast(void)
{
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);

	if (last_job) { /* no need to report error - waitlast() will do it */
		/* ensure it isn't removed by check_job() */
		last_job->flags |= JF_WAITING;
		j_startjob(last_job);
	}
	sigprocmask(SIG_SETMASK, &omask, NULL);
}

/* wait for last job: only used for `command` jobs */
int
waitlast(void)
{
	int	rv;
	Job	*j;
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);

	j = last_job;
	if (!j || !(j->flags & JF_STARTED)) {
		if (!j)
			warningf(true, "waitlast: no last job");
		else
			internal_errorf(0, "waitlast: not started");
		sigprocmask(SIG_SETMASK, &omask, NULL);
		return 125; /* not so arbitrary, non-zero value */
	}

	rv = j_waitj(j, JW_NONE, "jw:waitlast");

	sigprocmask(SIG_SETMASK, &omask, NULL);

	return rv;
}

/* wait for child, interruptable. */
int
waitfor(const char *cp, int *sigp)
{
	int	rv;
	Job	*j;
	int	ecode;
	int	flags = JW_INTERRUPT|JW_ASYNCNOTIFY;
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);

	*sigp = 0;

	if (cp == NULL) {
		/* wait for an unspecified job - always returns 0, so
		 * don't have to worry about exited/signaled jobs
		 */
		for (j = job_list; j; j = j->next)
			/* at&t ksh will wait for stopped jobs - we don't */
			if (j->ppid == procpid && j->state == PRUNNING)
				break;
		if (!j) {
			sigprocmask(SIG_SETMASK, &omask, NULL);
			return -1;
		}
	} else if ((j = j_lookup(cp, &ecode))) {
		/* don't report normal job completion */
		flags &= ~JW_ASYNCNOTIFY;
		if (j->ppid != procpid) {
			sigprocmask(SIG_SETMASK, &omask, NULL);
			return -1;
		}
	} else {
		sigprocmask(SIG_SETMASK, &omask, NULL);
		if (ecode != JL_NOSUCH)
			bi_errorf("%s: %s", cp, lookup_msgs[ecode]);
		return -1;
	}

	/* at&t ksh will wait for stopped jobs - we don't */
	rv = j_waitj(j, flags, "jw:waitfor");

	sigprocmask(SIG_SETMASK, &omask, NULL);

	if (rv < 0) /* we were interrupted */
		*sigp = 128 + -rv;

	return rv;
}

/* kill (built-in) a job */
int
j_kill(const char *cp, int sig)
{
	Job	*j;
	int	rv = 0;
	int	ecode;
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);

	if ((j = j_lookup(cp, &ecode)) == NULL) {
		sigprocmask(SIG_SETMASK, &omask, NULL);
		bi_errorf("%s: %s", cp, lookup_msgs[ecode]);
		return 1;
	}

	if (j->pgrp == 0) {	/* started when !Flag(FMONITOR) */
		if (kill_job(j, sig) < 0) {
			bi_errorf("%s: %s", cp, strerror(errno));
			rv = 1;
		}
	} else {
#ifdef JOBS
		if (j->state == PSTOPPED && (sig == SIGTERM || sig == SIGHUP))
			(void) killpg(j->pgrp, SIGCONT);
#endif /* JOBS */
		if (killpg(j->pgrp, sig) < 0) {
			bi_errorf("%s: %s", cp, strerror(errno));
			rv = 1;
		}
	}

	sigprocmask(SIG_SETMASK, &omask, NULL);

	return rv;
}

#ifdef JOBS
/* fg and bg built-ins: called only if Flag(FMONITOR) set */
int
j_resume(const char *cp, int bg)
{
	Job	*j;
	Proc	*p;
	int	ecode;
	int	running;
	int	rv = 0;
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);

	if ((j = j_lookup(cp, &ecode)) == NULL) {
		sigprocmask(SIG_SETMASK, &omask, NULL);
		bi_errorf("%s: %s", cp, lookup_msgs[ecode]);
		return 1;
	}

	if (j->pgrp == 0) {
		sigprocmask(SIG_SETMASK, &omask, NULL);
		bi_errorf("job not job-controlled");
		return 1;
	}

	if (bg)
		shprintf("[%d] ", j->job);

	running = 0;
	for (p = j->proc_list; p != NULL; p = p->next) {
		if (p->state == PSTOPPED) {
			p->state = PRUNNING;
			p->status = 0;
			running = 1;
		}
		shprintf("%s%s", p->command, p->next ? "| " : "");
	}
	shprintf("\n");
	shf_flush(shl_stdout);
	if (running)
		j->state = PRUNNING;

	put_job(j, PJ_PAST_STOPPED);
	if (bg)
		j_set_async(j);
	else {
# ifdef JOBS
		/* attach tty to job */
		if (j->state == PRUNNING) {
			if (ttypgrp_ok && (j->flags & JF_SAVEDTTY))
				tcsetattr(tty_fd, TCSADRAIN, &j->ttystate);
			/* See comment in j_waitj regarding saved_ttypgrp. */
			if (ttypgrp_ok &&
			    tcsetpgrp(tty_fd, (j->flags & JF_SAVEDTTYPGRP) ?
			    j->saved_ttypgrp : j->pgrp) < 0) {
				if (j->flags & JF_SAVEDTTY)
					tcsetattr(tty_fd, TCSADRAIN, &tty_state);
				sigprocmask(SIG_SETMASK, &omask, NULL);
				bi_errorf("1st tcsetpgrp(%d, %d) failed: %s",
				    tty_fd,
				    (int) ((j->flags & JF_SAVEDTTYPGRP) ?
				    j->saved_ttypgrp : j->pgrp),
				    strerror(errno));
				return 1;
			}
		}
# endif /* JOBS */
		j->flags |= JF_FG;
		j->flags &= ~JF_KNOWN;
		if (j == async_job)
			async_job = NULL;
	}

	if (j->state == PRUNNING && killpg(j->pgrp, SIGCONT) < 0) {
		int	err = errno;

		if (!bg) {
			j->flags &= ~JF_FG;
# ifdef JOBS
			if (ttypgrp_ok && (j->flags & JF_SAVEDTTY))
				tcsetattr(tty_fd, TCSADRAIN, &tty_state);
			if (ttypgrp_ok && tcsetpgrp(tty_fd, our_pgrp) < 0) {
				warningf(true,
				    "fg: 2nd tcsetpgrp(%d, %d) failed: %s",
				    tty_fd, (int) our_pgrp,
				    strerror(errno));
			}
# endif /* JOBS */
		}
		sigprocmask(SIG_SETMASK, &omask, NULL);
		bi_errorf("cannot continue job %s: %s",
		    cp, strerror(err));
		return 1;
	}
	if (!bg) {
# ifdef JOBS
		if (ttypgrp_ok) {
			j->flags &= ~(JF_SAVEDTTY | JF_SAVEDTTYPGRP);
		}
# endif /* JOBS */
		rv = j_waitj(j, JW_NONE, "jw:resume");
	}
	sigprocmask(SIG_SETMASK, &omask, NULL);
	return rv;
}
#endif /* JOBS */

/* are there any running or stopped jobs ? */
int
j_stopped_running(void)
{
	Job	*j;
	int	which = 0;

	for (j = job_list; j != NULL; j = j->next) {
#ifdef JOBS
		if (j->ppid == procpid && j->state == PSTOPPED)
			which |= 1;
#endif /* JOBS */
		if (Flag(FLOGIN) && !Flag(FNOHUP) && procpid == kshpid &&
		    j->ppid == procpid && j->state == PRUNNING)
			which |= 2;
	}
	if (which) {
		shellf("You have %s%s%s jobs\n",
		    which & 1 ? "stopped" : "",
		    which == 3 ? " and " : "",
		    which & 2 ? "running" : "");
		return 1;
	}

	return 0;
}

int
j_njobs(void)
{
	Job *j;
	int nj = 0;
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
	for (j = job_list; j; j = j->next)
		nj++;

	sigprocmask(SIG_SETMASK, &omask, NULL);
	return nj;
}


/* list jobs for jobs built-in */
int
j_jobs(const char *cp, int slp,
    int nflag)		/* 0: short, 1: long, 2: pgrp */
{
	Job	*j, *tmp;
	int	how;
	int	zflag = 0;
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);

	if (nflag < 0) { /* kludge: print zombies */
		nflag = 0;
		zflag = 1;
	}
	if (cp) {
		int	ecode;

		if ((j = j_lookup(cp, &ecode)) == NULL) {
			sigprocmask(SIG_SETMASK, &omask, NULL);
			bi_errorf("%s: %s", cp, lookup_msgs[ecode]);
			return 1;
		}
	} else
		j = job_list;
	how = slp == 0 ? JP_MEDIUM : (slp == 1 ? JP_LONG : JP_PGRP);
	for (; j; j = j->next) {
		if ((!(j->flags & JF_ZOMBIE) || zflag) &&
		    (!nflag || (j->flags & JF_CHANGED))) {
			j_print(j, how, shl_stdout);
			if (j->state == PEXITED || j->state == PSIGNALLED)
				j->flags |= JF_REMOVE;
		}
		if (cp)
			break;
	}
	/* Remove jobs after printing so there won't be multiple + or - jobs */
	for (j = job_list; j; j = tmp) {
		tmp = j->next;
		if (j->flags & JF_REMOVE)
			remove_job(j, "jobs");
	}
	sigprocmask(SIG_SETMASK, &omask, NULL);
	return 0;
}

/* list jobs for top-level notification */
void
j_notify(void)
{
	Job	*j, *tmp;
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
	for (j = job_list; j; j = j->next) {
#ifdef JOBS
		if (Flag(FMONITOR) && (j->flags & JF_CHANGED))
			j_print(j, JP_MEDIUM, shl_out);
#endif /* JOBS */
		/* Remove job after doing reports so there aren't
		 * multiple +/- jobs.
		 */
		if (j->state == PEXITED || j->state == PSIGNALLED)
			j->flags |= JF_REMOVE;
	}
	for (j = job_list; j; j = tmp) {
		tmp = j->next;
		if (j->flags & JF_REMOVE)
			remove_job(j, "notify");
	}
	shf_flush(shl_out);
	sigprocmask(SIG_SETMASK, &omask, NULL);
}

/* Return pid of last process in last asynchronous job */
pid_t
j_async(void)
{
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);

	if (async_job)
		async_job->flags |= JF_KNOWN;

	sigprocmask(SIG_SETMASK, &omask, NULL);

	return async_pid;
}

/* Make j the last async process
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static void
j_set_async(Job *j)
{
	Job	*jl, *oldest;

	if (async_job && (async_job->flags & (JF_KNOWN|JF_ZOMBIE)) == JF_ZOMBIE)
		remove_job(async_job, "async");
	if (!(j->flags & JF_STARTED)) {
		internal_errorf(0, "j_async: job not started");
		return;
	}
	async_job = j;
	async_pid = j->last_proc->pid;
	while (nzombie > child_max) {
		oldest = NULL;
		for (jl = job_list; jl; jl = jl->next)
			if (jl != async_job && (jl->flags & JF_ZOMBIE) &&
			    (!oldest || jl->age < oldest->age))
				oldest = jl;
		if (!oldest) {
			/* XXX debugging */
			if (!(async_job->flags & JF_ZOMBIE) || nzombie != 1) {
				internal_errorf(0,
				    "j_async: bad nzombie (%d)", nzombie);
				nzombie = 0;
			}
			break;
		}
		remove_job(oldest, "zombie");
	}
}

/* Start a job: set STARTED, check for held signals and set j->last_proc
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static void
j_startjob(Job *j)
{
	Proc	*p;

	j->flags |= JF_STARTED;
	for (p = j->proc_list; p->next; p = p->next)
		;
	j->last_proc = p;

	if (held_sigchld) {
		held_sigchld = 0;
		/* Don't call j_sigchld() as it may remove job... */
		kill(procpid, SIGCHLD);
	}
}

/*
 * wait for job to complete or change state
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static int
j_waitj(Job *j,
    int flags,			/* see JW_* */
    const char *where)
{
	int	rv;

	/*
	 * No auto-notify on the job we are waiting on.
	 */
	j->flags |= JF_WAITING;
	if (flags & JW_ASYNCNOTIFY)
		j->flags |= JF_W_ASYNCNOTIFY;

	if (!Flag(FMONITOR))
		flags |= JW_STOPPEDWAIT;

	while ((volatile int) j->state == PRUNNING ||
	    ((flags & JW_STOPPEDWAIT) && (volatile int) j->state == PSTOPPED)) {
		sigsuspend(&sm_default);
		if (fatal_trap) {
			int oldf = j->flags & (JF_WAITING|JF_W_ASYNCNOTIFY);
			j->flags &= ~(JF_WAITING|JF_W_ASYNCNOTIFY);
			runtraps(TF_FATAL);
			j->flags |= oldf; /* not reached... */
		}
		if ((flags & JW_INTERRUPT) && (rv = trap_pending())) {
			j->flags &= ~(JF_WAITING|JF_W_ASYNCNOTIFY);
			return -rv;
		}
	}
	j->flags &= ~(JF_WAITING|JF_W_ASYNCNOTIFY);

	if (j->flags & JF_FG) {
		int	status;

		j->flags &= ~JF_FG;
#ifdef JOBS
		if (Flag(FMONITOR) && ttypgrp_ok && j->pgrp) {
			/*
			 * Save the tty's current pgrp so it can be restored
			 * when the job is foregrounded.  This is to
			 * deal with things like the GNU su which does
			 * a fork/exec instead of an exec (the fork means
			 * the execed shell gets a different pid from its
			 * pgrp, so naturally it sets its pgrp and gets hosed
			 * when it gets foregrounded by the parent shell, which
			 * has restored the tty's pgrp to that of the su
			 * process).
			 */
			if (j->state == PSTOPPED &&
			    (j->saved_ttypgrp = tcgetpgrp(tty_fd)) >= 0)
				j->flags |= JF_SAVEDTTYPGRP;
			if (tcsetpgrp(tty_fd, our_pgrp) < 0) {
				warningf(true,
				    "j_waitj: tcsetpgrp(%d, %d) failed: %s",
				    tty_fd, (int) our_pgrp,
					strerror(errno));
			}
			if (j->state == PSTOPPED) {
				j->flags |= JF_SAVEDTTY;
				tcgetattr(tty_fd, &j->ttystate);
			}
		}
#endif /* JOBS */
		if (tty_fd >= 0) {
			/* Only restore tty settings if job was originally
			 * started in the foreground.  Problems can be
			 * caused by things like `more foobar &' which will
			 * typically get and save the shell's vi/emacs tty
			 * settings before setting up the tty for itself;
			 * when more exits, it restores the `original'
			 * settings, and things go down hill from there...
			 */
			if (j->state == PEXITED && j->status == 0 &&
			    (j->flags & JF_USETTYMODE)) {
				tcgetattr(tty_fd, &tty_state);
			} else {
				tcsetattr(tty_fd, TCSADRAIN, &tty_state);
				/* Don't use tty mode if job is stopped and
				 * later restarted and exits.  Consider
				 * the sequence:
				 *	vi foo (stopped)
				 *	...
				 *	stty something
				 *	...
				 *	fg (vi; ZZ)
				 * mode should be that of the stty, not what
				 * was before the vi started.
				 */
				if (j->state == PSTOPPED)
					j->flags &= ~JF_USETTYMODE;
			}
		}
#ifdef JOBS
		/* If it looks like user hit ^C to kill a job, pretend we got
		 * one too to break out of for loops, etc.  (at&t ksh does this
		 * even when not monitoring, but this doesn't make sense since
		 * a tty generated ^C goes to the whole process group)
		 */
		status = j->last_proc->status;
		if (Flag(FMONITOR) && j->state == PSIGNALLED &&
		    WIFSIGNALED(status) &&
		    (sigtraps[WTERMSIG(status)].flags & TF_TTY_INTR))
			trapsig(WTERMSIG(status));
#endif /* JOBS */
	}

	j_usrtime = j->usrtime;
	j_systime = j->systime;
	rv = j->status;

	if (!(flags & JW_ASYNCNOTIFY) &&
	    (!Flag(FMONITOR) || j->state != PSTOPPED)) {
		j_print(j, JP_SHORT, shl_out);
		shf_flush(shl_out);
	}
	if (j->state != PSTOPPED &&
	    (!Flag(FMONITOR) || !(flags & JW_ASYNCNOTIFY)))
		remove_job(j, where);

	return rv;
}

/* SIGCHLD handler to reap children and update job states
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static void
j_sigchld(int sig)
{
	int		errno_ = errno;
	Job		*j;
	Proc		*p = NULL;
	int		pid;
	int		status;
	struct rusage	ru0, ru1;

	/* Don't wait for any processes if a job is partially started.
	 * This is so we don't do away with the process group leader
	 * before all the processes in a pipe line are started (so the
	 * setpgid() won't fail)
	 */
	for (j = job_list; j; j = j->next)
		if (j->ppid == procpid && !(j->flags & JF_STARTED)) {
			held_sigchld = 1;
			goto finished;
		}

	getrusage(RUSAGE_CHILDREN, &ru0);
	do {
		pid = waitpid(-1, &status, (WNOHANG|WUNTRACED));

		if (pid <= 0)	/* return if would block (0) ... */
			break;	/* ... or no children or interrupted (-1) */

		getrusage(RUSAGE_CHILDREN, &ru1);

		/* find job and process structures for this pid */
		for (j = job_list; j != NULL; j = j->next)
			for (p = j->proc_list; p != NULL; p = p->next)
				if (p->pid == pid)
					goto found;
found:
		if (j == NULL) {
			/* Can occur if process has kids, then execs shell
			warningf(true, "bad process waited for (pid = %d)",
				pid);
			 */
			ru0 = ru1;
			continue;
		}

		timeradd(&j->usrtime, &ru1.ru_utime, &j->usrtime);
		timersub(&j->usrtime, &ru0.ru_utime, &j->usrtime);
		timeradd(&j->systime, &ru1.ru_stime, &j->systime);
		timersub(&j->systime, &ru0.ru_stime, &j->systime);
		ru0 = ru1;
		p->status = status;
#ifdef JOBS
		if (WIFSTOPPED(status))
			p->state = PSTOPPED;
		else
#endif /* JOBS */
		if (WIFSIGNALED(status))
			p->state = PSIGNALLED;
		else
			p->state = PEXITED;

		check_job(j);	/* check to see if entire job is done */
	} while (1);

finished:
	errno = errno_;
}

/*
 * Called only when a process in j has exited/stopped (ie, called only
 * from j_sigchld()).  If no processes are running, the job status
 * and state are updated, asynchronous job notification is done and,
 * if unneeded, the job is removed.
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static void
check_job(Job *j)
{
	int	jstate;
	Proc	*p;

	/* XXX debugging (nasty - interrupt routine using shl_out) */
	if (!(j->flags & JF_STARTED)) {
		internal_errorf(0, "check_job: job started (flags 0x%x)",
		    j->flags);
		return;
	}

	jstate = PRUNNING;
	for (p=j->proc_list; p != NULL; p = p->next) {
		if (p->state == PRUNNING)
			return;	/* some processes still running */
		if (p->state > jstate)
			jstate = p->state;
	}
	j->state = jstate;

	switch (j->last_proc->state) {
	case PEXITED:
		j->status = WEXITSTATUS(j->last_proc->status);
		break;
	case PSIGNALLED:
		j->status = 128 + WTERMSIG(j->last_proc->status);
		break;
	default:
		j->status = 0;
		break;
	}

	/* Note when co-process dies: can't be done in j_wait() nor
	 * remove_job() since neither may be called for non-interactive
	 * shells.
	 */
	if (j->state == PEXITED || j->state == PSIGNALLED) {
		/* No need to keep co-process input any more
		 * (at least, this is what ksh93d thinks)
		 */
		if (coproc.job == j) {
			coproc.job = NULL;
			/* XXX would be nice to get the closes out of here
			 * so they aren't done in the signal handler.
			 * Would mean a check in coproc_getfd() to
			 * do "if job == 0 && write >= 0, close write".
			 */
			coproc_write_close(coproc.write);
		}
		/* Do we need to keep the output? */
		if (j->coproc_id && j->coproc_id == coproc.id &&
		    --coproc.njobs == 0)
			coproc_readw_close(coproc.read);
	}

	j->flags |= JF_CHANGED;
#ifdef JOBS
	if (Flag(FMONITOR) && !(j->flags & JF_XXCOM)) {
		/* Only put stopped jobs at the front to avoid confusing
		 * the user (don't want finished jobs effecting %+ or %-)
		 */
		if (j->state == PSTOPPED)
			put_job(j, PJ_ON_FRONT);
		if (Flag(FNOTIFY) &&
		    (j->flags & (JF_WAITING|JF_W_ASYNCNOTIFY)) != JF_WAITING) {
			/* Look for the real file descriptor 2 */
			{
				struct env *ep;
				int fd = 2;

				for (ep = genv; ep; ep = ep->oenv)
					if (ep->savefd && ep->savefd[2])
						fd = ep->savefd[2];
				shf_reopen(fd, SHF_WR, shl_j);
			}
			/* Can't call j_notify() as it removes jobs.  The job
			 * must stay in the job list as j_waitj() may be
			 * running with this job.
			 */
			j_print(j, JP_MEDIUM, shl_j);
			shf_flush(shl_j);
			if (!(j->flags & JF_WAITING) && j->state != PSTOPPED)
				remove_job(j, "notify");
		}
	}
#endif /* JOBS */
	if (!Flag(FMONITOR) && !(j->flags & (JF_WAITING|JF_FG)) &&
	    j->state != PSTOPPED) {
		if (j == async_job || (j->flags & JF_KNOWN)) {
			j->flags |= JF_ZOMBIE;
			j->job = -1;
			nzombie++;
		} else
			remove_job(j, "checkjob");
	}
}

/*
 * Print job status in either short, medium or long format.
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static void
j_print(Job *j, int how, struct shf *shf)
{
	Proc	*p;
	int	state;
	int	status;
	int	coredumped;
	char	jobchar = ' ';
	char	buf[64];
	const char *filler;
	int	output = 0;

	if (how == JP_PGRP) {
		/* POSIX doesn't say what to do it there is no process
		 * group leader (ie, !FMONITOR).  We arbitrarily return
		 * last pid (which is what $! returns).
		 */
		shf_fprintf(shf, "%d\n", j->pgrp ? j->pgrp :
		    (j->last_proc ? j->last_proc->pid : 0));
		return;
	}
	j->flags &= ~JF_CHANGED;
	filler = j->job > 10 ?  "\n       " : "\n      ";
	if (j == job_list)
		jobchar = '+';
	else if (j == job_list->next)
		jobchar = '-';

	for (p = j->proc_list; p != NULL;) {
		coredumped = 0;
		switch (p->state) {
		case PRUNNING:
			strlcpy(buf, "Running", sizeof buf);
			break;
		case PSTOPPED:
			strlcpy(buf, sigtraps[WSTOPSIG(p->status)].mess,
			    sizeof buf);
			break;
		case PEXITED:
			if (how == JP_SHORT)
				buf[0] = '\0';
			else if (WEXITSTATUS(p->status) == 0)
				strlcpy(buf, "Done", sizeof buf);
			else
				shf_snprintf(buf, sizeof(buf), "Done (%d)",
				    WEXITSTATUS(p->status));
			break;
		case PSIGNALLED:
			if (WCOREDUMP(p->status))
				coredumped = 1;
			/* kludge for not reporting `normal termination signals'
			 * (ie, SIGINT, SIGPIPE)
			 */
			if (how == JP_SHORT && !coredumped &&
			    (WTERMSIG(p->status) == SIGINT ||
			    WTERMSIG(p->status) == SIGPIPE)) {
				buf[0] = '\0';
			} else
				strlcpy(buf, sigtraps[WTERMSIG(p->status)].mess,
				    sizeof buf);
			break;
		}

		if (how != JP_SHORT) {
			if (p == j->proc_list)
				shf_fprintf(shf, "[%d] %c ", j->job, jobchar);
			else
				shf_fprintf(shf, "%s", filler);
		}

		if (how == JP_LONG)
			shf_fprintf(shf, "%5d ", p->pid);

		if (how == JP_SHORT) {
			if (buf[0]) {
				output = 1;
				shf_fprintf(shf, "%s%s ",
				    buf, coredumped ? " (core dumped)" : "");
			}
		} else {
			output = 1;
			shf_fprintf(shf, "%-20s %s%s%s", buf, p->command,
			    p->next ? "|" : "",
			    coredumped ? " (core dumped)" : "");
		}

		state = p->state;
		status = p->status;
		p = p->next;
		while (p && p->state == state && p->status == status) {
			if (how == JP_LONG)
				shf_fprintf(shf, "%s%5d %-20s %s%s", filler, p->pid,
				    " ", p->command, p->next ? "|" : "");
			else if (how == JP_MEDIUM)
				shf_fprintf(shf, " %s%s", p->command,
				    p->next ? "|" : "");
			p = p->next;
		}
	}
	if (output)
		shf_fprintf(shf, "\n");
}

/* Convert % sequence to job
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static Job *
j_lookup(const char *cp, int *ecodep)
{
	Job		*j, *last_match;
	const char	*errstr;
	Proc		*p;
	int		len, job = 0;

	if (digit(*cp)) {
		job = strtonum(cp, 1, INT_MAX, &errstr);
		if (errstr) {
			if (ecodep)
				*ecodep = JL_NOSUCH;
			return NULL;
		}
		/* Look for last_proc->pid (what $! returns) first... */
		for (j = job_list; j != NULL; j = j->next)
			if (j->last_proc && j->last_proc->pid == job)
				return j;
		/* ...then look for process group (this is non-POSIX),
		 * but should not break anything (so FPOSIX isn't used).
		 */
		for (j = job_list; j != NULL; j = j->next)
			if (j->pgrp && j->pgrp == job)
				return j;
		if (ecodep)
			*ecodep = JL_NOSUCH;
		return NULL;
	}
	if (*cp != '%') {
		if (ecodep)
			*ecodep = JL_INVALID;
		return NULL;
	}
	switch (*++cp) {
	case '\0': /* non-standard */
	case '+':
	case '%':
		if (job_list != NULL)
			return job_list;
		break;

	case '-':
		if (job_list != NULL && job_list->next)
			return job_list->next;
		break;

	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
		job = strtonum(cp, 1, INT_MAX, &errstr);
		if (errstr)
			break;
		for (j = job_list; j != NULL; j = j->next)
			if (j->job == job)
				return j;
		break;

	case '?':		/* %?string */
		last_match = NULL;
		for (j = job_list; j != NULL; j = j->next)
			for (p = j->proc_list; p != NULL; p = p->next)
				if (strstr(p->command, cp+1) != NULL) {
					if (last_match) {
						if (ecodep)
							*ecodep = JL_AMBIG;
						return NULL;
					}
					last_match = j;
				}
		if (last_match)
			return last_match;
		break;

	default:		/* %string */
		len = strlen(cp);
		last_match = NULL;
		for (j = job_list; j != NULL; j = j->next)
			if (strncmp(cp, j->proc_list->command, len) == 0) {
				if (last_match) {
					if (ecodep)
						*ecodep = JL_AMBIG;
					return NULL;
				}
				last_match = j;
			}
		if (last_match)
			return last_match;
		break;
	}
	if (ecodep)
		*ecodep = JL_NOSUCH;
	return NULL;
}

static Job	*free_jobs;
static Proc	*free_procs;

/* allocate a new job and fill in the job number.
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static Job *
new_job(void)
{
	int	i;
	Job	*newj, *j;

	if (free_jobs != NULL) {
		newj = free_jobs;
		free_jobs = free_jobs->next;
	} else
		newj = alloc(sizeof(Job), APERM);

	/* brute force method */
	for (i = 1; ; i++) {
		for (j = job_list; j && j->job != i; j = j->next)
			;
		if (j == NULL)
			break;
	}
	newj->job = i;

	return newj;
}

/* Allocate new process struct
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static Proc *
new_proc(void)
{
	Proc	*p;

	if (free_procs != NULL) {
		p = free_procs;
		free_procs = free_procs->next;
	} else
		p = alloc(sizeof(Proc), APERM);

	return p;
}

/* Take job out of job_list and put old structures into free list.
 * Keeps nzombies, last_job and async_job up to date.
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static void
remove_job(Job *j, const char *where)
{
	Proc	*p, *tmp;
	Job	**prev, *curr;

	prev = &job_list;
	curr = *prev;
	for (; curr != NULL && curr != j; prev = &curr->next, curr = *prev)
		;
	if (curr != j) {
		internal_errorf(0, "remove_job: job not found (%s)", where);
		return;
	}
	*prev = curr->next;

	/* free up proc structures */
	for (p = j->proc_list; p != NULL; ) {
		tmp = p;
		p = p->next;
		tmp->next = free_procs;
		free_procs = tmp;
	}

	if ((j->flags & JF_ZOMBIE) && j->ppid == procpid)
		--nzombie;
	j->next = free_jobs;
	free_jobs = j;

	if (j == last_job)
		last_job = NULL;
	if (j == async_job)
		async_job = NULL;
}

/* put j in a particular location (taking it out job_list if it is there
 * already)
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static void
put_job(Job *j, int where)
{
	Job	**prev, *curr;

	/* Remove job from list (if there) */
	prev = &job_list;
	curr = job_list;
	for (; curr && curr != j; prev = &curr->next, curr = *prev)
		;
	if (curr == j)
		*prev = curr->next;

	switch (where) {
	case PJ_ON_FRONT:
		j->next = job_list;
		job_list = j;
		break;

	case PJ_PAST_STOPPED:
		prev = &job_list;
		curr = job_list;
		for (; curr && curr->state == PSTOPPED; prev = &curr->next,
		    curr = *prev)
			;
		j->next = curr;
		*prev = j;
		break;
	}
}

/* nuke a job (called when unable to start full job).
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static int
kill_job(Job *j, int sig)
{
	Proc	*p;
	int	rval = 0;

	for (p = j->proc_list; p != NULL; p = p->next)
		if (p->pid != 0)
			if (kill(p->pid, sig) < 0)
				rval = -1;
	return rval;
}
@


1.54
log
@rename global "e" to genv to avoid accidental shadowing and aliasing.
ok millert nicm tb
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.53 2015/12/14 13:59:42 tb Exp $	*/
a1146 1
/* ARGSUSED */
@


1.53
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.52 2015/11/12 22:33:07 deraadt Exp $	*/
d1296 1
a1296 1
				for (ep = e; ep; ep = ep->oenv)
@


1.52
log
@use symbolics for flags to open
from Ricardo Mestre
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.51 2015/11/12 04:04:31 mmcc Exp $	*/
d24 2
d27 1
d29 1
@


1.51
log
@Use isdigit() instead of ksh's homebrewed alternative.

ok nicm@@. Also discussed with millert@@ and guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.50 2015/10/19 14:42:16 mmcc Exp $	*/
d523 1
a523 1
				int fd = open("/dev/null", 0);
@


1.50
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.49 2015/10/19 14:03:21 mmcc Exp $	*/
d23 1
@


1.49
log
@Move limits.h include from sh.h to the files that actually need it. No
binary change.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.48 2015/10/19 02:15:45 mmcc Exp $	*/
d24 1
@


1.48
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.47 2015/09/17 21:39:54 nicm Exp $	*/
d22 2
@


1.47
log
@More (foo *)0 -> NULL, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.46 2015/09/17 14:21:33 nicm Exp $	*/
d18 1
a18 1
#include "sh.h"
d20 1
d22 2
a23 2
#include <sys/time.h>
#include <sys/resource.h>
@


1.46
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.45 2015/09/15 18:15:05 tedu Exp $	*/
d149 1
a149 1
	sigprocmask(SIG_SETMASK, &sm_default, (sigset_t *) 0);
d164 1
a164 1
	shl_j = shf_fdopen(2, SHF_WR, (struct shf *) 0);
d250 1
a250 1
	for (j = job_list; j != (Job *) 0; j = j->next) {
d410 1
a410 1
	p->next = (Proc *) 0;
d457 1
a457 1
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d497 1
a497 1
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d569 1
a569 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d587 1
a587 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d606 1
a606 1
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d612 1
a612 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d640 1
a640 1
			sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d647 1
a647 1
			sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d651 1
a651 1
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d660 1
a660 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d679 2
a680 2
	if ((j = j_lookup(cp, &ecode)) == (Job *) 0) {
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d701 1
a701 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d720 2
a721 2
	if ((j = j_lookup(cp, &ecode)) == (Job *) 0) {
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d727 1
a727 1
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d736 1
a736 1
	for (p = j->proc_list; p != (Proc *) 0; p = p->next) {
d764 1
a764 2
				sigprocmask(SIG_SETMASK, &omask,
				    (sigset_t *) 0);
d777 1
a777 1
			async_job = (Job *) 0;
d796 1
a796 1
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d809 1
a809 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d821 1
a821 1
	for (j = job_list; j != (Job *) 0; j = j->next) {
d852 1
a852 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d876 2
a877 2
		if ((j = j_lookup(cp, &ecode)) == (Job *) 0) {
			sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d900 1
a900 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d929 1
a929 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d943 1
a943 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d966 1
a966 1
		oldest = (Job *) 0;
d1170 2
a1171 2
		for (j = job_list; j != (Job *) 0; j = j->next)
			for (p = j->proc_list; p != (Proc *) 0; p = p->next)
d1175 1
a1175 1
		if (j == (Job *) 0) {
d1229 1
a1229 1
	for (p=j->proc_list; p != (Proc *) 0; p = p->next) {
d1258 1
a1258 1
			coproc.job = (void *) 0;
d1347 1
a1347 1
	for (p = j->proc_list; p != (Proc *) 0;) {
d1439 1
a1439 1
			return (Job *) 0;
d1442 1
a1442 1
		for (j = job_list; j != (Job *) 0; j = j->next)
d1448 1
a1448 1
		for (j = job_list; j != (Job *) 0; j = j->next)
d1453 1
a1453 1
		return (Job *) 0;
d1458 1
a1458 1
		return (Job *) 0;
d1464 1
a1464 1
		if (job_list != (Job *) 0)
d1469 1
a1469 1
		if (job_list != (Job *) 0 && job_list->next)
d1478 1
a1478 1
		for (j = job_list; j != (Job *) 0; j = j->next)
d1484 3
a1486 3
		last_match = (Job *) 0;
		for (j = job_list; j != (Job *) 0; j = j->next)
			for (p = j->proc_list; p != (Proc *) 0; p = p->next)
d1491 1
a1491 1
						return (Job *) 0;
d1501 2
a1502 2
		last_match = (Job *) 0;
		for (j = job_list; j != (Job *) 0; j = j->next)
d1507 1
a1507 1
					return (Job *) 0;
d1517 1
a1517 1
	return (Job *) 0;
d1533 1
a1533 1
	if (free_jobs != (Job *) 0) {
d1543 1
a1543 1
		if (j == (Job *) 0)
d1560 1
a1560 1
	if (free_procs != (Proc *) 0) {
d1582 1
a1582 1
	for (; curr != (Job *) 0 && curr != j; prev = &curr->next, curr = *prev)
d1591 1
a1591 1
	for (p = j->proc_list; p != (Proc *) 0; ) {
d1604 1
a1604 1
		last_job = (Job *) 0;
d1606 1
a1606 1
		async_job = (Job *) 0;
d1655 1
a1655 1
	for (p = j->proc_list; p != (Proc *) 0; p = p->next)
@


1.45
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.44 2015/09/15 18:07:22 tedu Exp $	*/
d1538 1
a1538 1
		newj = (Job *) alloc(sizeof(Job), APERM);
d1565 1
a1565 1
		p = (Proc *) alloc(sizeof(Proc), APERM);
@


1.44
log
@stop abusing null (the variable) for an empty string in output formats.
from Michael McConville
ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.43 2015/09/10 22:48:58 nicm Exp $	*/
d103 1
a103 1
	(char *) 0
d631 1
a631 1
	if (cp == (char *) 0) {
d1488 1
a1488 1
				if (strstr(p->command, cp+1) != (char *) 0) {
@


1.43
log
@Replace newline and space defines by "\n" and " " directly, from Michael
McConville. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.42 2015/09/10 13:04:52 nicm Exp $	*/
d742 1
a742 1
		shprintf("%s%s", p->command, p->next ? "| " : null);
d1397 1
a1397 1
				    buf, coredumped ? " (core dumped)" : null);
d1402 2
a1403 2
			    p->next ? "|" : null,
			    coredumped ? " (core dumped)" : null);
d1412 1
a1412 1
				    " ", p->command, p->next ? "|" : null);
d1415 1
a1415 1
				    p->next ? "|" : null);
@


1.42
log
@Remove INT32 define and just use int, from Martijn van Duren and Michael
McConville. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.41 2015/04/18 18:28:36 deraadt Exp $	*/
d744 1
a744 1
	shprintf(newline);
d1412 1
a1412 1
				    space, p->command, p->next ? "|" : null);
d1420 1
a1420 1
		shf_fprintf(shf, newline);
@


1.41
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.40 2013/09/04 15:49:18 millert Exp $	*/
d74 1
a74 1
	INT32	age;		/* number of jobs started */
d114 1
a114 1
INT32			njobs;		/* # of jobs started */
@


1.40
log
@Add a proper suspend builtin that saves/restores the tty and pgrp
as needed instead of an alias that just sends SIGSTOP.  Login shells
may be suspended if they are not running in an orphan process group.
OK guenther@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.39 2009/12/13 04:36:48 deraadt Exp $	*/
d1431 1
d1436 6
a1441 1
		job = atoi(cp);
d1476 3
a1478 1
		job = atoi(cp);
@


1.39
log
@remember to restore errno (ie. stop someone from making a mistake later)
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.38 2009/12/12 04:28:44 deraadt Exp $	*/
d187 53
@


1.38
log
@a dangling do / while that was very very ugly
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.37 2009/01/29 23:27:26 jaredy Exp $	*/
d1105 1
a1105 1
			return;
d1151 1
@


1.37
log
@pass "xerrok" status across the execution call stack to more closely
match what both POSIX and ksh.1 already describe in regards to set
-e/errexit's behavior in determining when to exit from nonzero return
values.

specifically, the truth values tested as operands to `&&' and `||', as
well as the resulting compound expression itself, along with the truth
value resulting from a negated command (i.e. a pipeline prefixed `!'),
should not make the shell exit when -e is in effect.

issue reported by matthieu.
testing matthieu, naddy.
ok miod (earlier version), otto.
man page ok jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.36 2007/09/06 19:57:47 otto Exp $	*/
d1149 1
a1149 2
	}
	while (1);
@


1.36
log
@Be more smart waiting for input for non-interactive scripts.  Fix
based on a diff from debian:  see their bug#296446.  ok millert@@
sobrado@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.35 2006/02/06 16:47:07 jmc Exp $	*/
d334 1
a334 1
exchild(struct op *t, int flags,
d351 1
a351 1
		return execute(t, flags & (XEXEC | XERROK));
d481 1
a481 1
		execute(t, (flags & XERROK) | XEXEC); /* no return */
@


1.35
log
@typos from alexey dobriyan;
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.34 2005/03/30 17:16:37 deraadt Exp $	*/
d249 8
a256 2
		/* Don't call tcgetattr() 'til we own the tty process group */
		tty_init(false);
d259 1
a259 1
		ttypgrp_ok = tty_fd >= 0 && tty_devtty;
d305 4
a308 2
		if (!ttypgrp_ok)
			warningf(false, "warning: won't have full job control");
@


1.34
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.33 2005/03/28 21:28:22 deraadt Exp $	*/
d1483 1
a1483 1
/* Allocate new process strut
@


1.33
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.32 2005/02/25 11:21:16 deraadt Exp $	*/
d99 7
a105 6
				null,
				"no such job",
				"ambiguous",
				"argument must be %job or process id",
				(char *) 0
			    };
d155 1
a155 1
		SS_RESTORE_ORIG|SS_FORCE|SS_SHTRAP);
d176 1
a176 1
				SS_RESTORE_IGN|SS_FORCE);
d185 2
a186 2
	  if (Flag(FTALKING))
		tty_init(true);
d198 5
a202 7
		if (j->ppid == procpid
		    && (j->state == PSTOPPED
			|| (j->state == PRUNNING
			    && ((j->flags & JF_FG)
				|| (Flag(FLOGIN) && !Flag(FNOHUP)
				    && procpid == kshpid)))))
		{
d257 1
a257 1
				strerror(errno));
d262 1
a262 1
				SS_RESTORE_ORIG|SS_FORCE);
d269 2
a270 2
					"j_init: tcgetpgrp() failed: %s",
						strerror(errno));
d281 1
a281 1
				SS_RESTORE_DFL|SS_FORCE);
d285 2
a286 2
					"j_init: setpgid() failed: %s",
					strerror(errno));
d291 2
a292 2
					"j_init: tcsetpgrp() failed: %s",
						strerror(errno));
d308 1
a308 1
					SS_RESTORE_IGN|SS_FORCE);
d311 2
a312 2
				if (sigtraps[tt_sigs[i]].flags & (TF_ORIG_IGN
							          |TF_ORIG_DFL))
d314 3
a316 2
						(sigtraps[tt_sigs[i]].flags & TF_ORIG_IGN) ? SIG_IGN : SIG_DFL,
						SS_RESTORE_ORIG|SS_FORCE);
d357 3
a359 1
			internal_errorf(1, "exchild: XPIPEI and no last_job - pid %d", (int) procpid);
d368 2
a369 2
		j->flags = (flags & XXCOM) ? JF_XXCOM
			: ((flags & XBGND) ? 0 : (JF_FG|JF_USETTYMODE));
d429 2
a430 2
	if (close_fd >= 0 && (((flags & XPCLOSE) && !ischild)
			      || ((flags & XCCLOSE) && ischild)))
d446 1
a446 1
					SS_RESTORE_DFL|SS_FORCE);
d453 1
a453 1
				SS_RESTORE_IGN|SS_FORCE);
d455 1
a455 1
				SS_RESTORE_IGN|SS_FORCE);
d698 3
a700 1
			if (ttypgrp_ok && tcsetpgrp(tty_fd, (j->flags & JF_SAVEDTTYPGRP) ? j->saved_ttypgrp : j->pgrp) < 0) {
d704 1
a704 1
					(sigset_t *) 0);
d706 4
a709 1
					tty_fd, (int) ((j->flags & JF_SAVEDTTYPGRP) ? j->saved_ttypgrp : j->pgrp), strerror(errno));
d730 3
a732 3
				"fg: 2nd tcsetpgrp(%d, %d) failed: %s",
					tty_fd, (int) our_pgrp,
					strerror(errno));
d738 1
a738 1
			cp, strerror(err));
d766 2
a767 2
		if (Flag(FLOGIN) && !Flag(FNOHUP) && procpid == kshpid
		    && j->ppid == procpid && j->state == PRUNNING)
d772 3
a774 3
			which & 1 ? "stopped" : "",
			which == 3 ? " and " : "",
			which & 2 ? "running" : "");
d825 2
a826 3
		if ((!(j->flags & JF_ZOMBIE) || zflag)
		    && (!nflag || (j->flags & JF_CHANGED)))
		{
d908 2
a909 2
			if (jl != async_job && (jl->flags & JF_ZOMBIE)
			    && (!oldest || jl->age < oldest->age))
d914 2
a915 1
				internal_errorf(0, "j_async: bad nzombie (%d)", nzombie);
d967 2
a968 4
	while ((volatile int) j->state == PRUNNING
		|| ((flags & JW_STOPPEDWAIT)
		    && (volatile int) j->state == PSTOPPED))
	{
d1000 2
a1001 2
			if (j->state == PSTOPPED
			    && (j->saved_ttypgrp = tcgetpgrp(tty_fd)) >= 0)
d1005 2
a1006 2
				"j_waitj: tcsetpgrp(%d, %d) failed: %s",
					tty_fd, (int) our_pgrp,
d1024 2
a1025 3
			if (j->state == PEXITED && j->status == 0
			    && (j->flags & JF_USETTYMODE))
			{
d1051 3
a1053 3
		if (Flag(FMONITOR) && j->state == PSIGNALLED
		    && WIFSIGNALED(status)
		    && (sigtraps[WTERMSIG(status)].flags & TF_TTY_INTR))
d1062 2
a1063 3
	if (!(flags & JW_ASYNCNOTIFY)
	    && (!Flag(FMONITOR) || j->state != PSTOPPED))
	{
d1067 2
a1068 2
	if (j->state != PSTOPPED
	    && (!Flag(FMONITOR) || !(flags & JW_ASYNCNOTIFY)))
d1164 1
a1164 1
			j->flags);
d1207 2
a1208 2
		if (j->coproc_id && j->coproc_id == coproc.id
		    && --coproc.njobs == 0)
d1220 2
a1221 3
		if (Flag(FNOTIFY)
		    && (j->flags & (JF_WAITING|JF_W_ASYNCNOTIFY)) != JF_WAITING)
		{
d1243 2
a1244 3
	if (!Flag(FMONITOR) && !(j->flags & (JF_WAITING|JF_FG))
	    && j->state != PSTOPPED)
	{
d1276 2
a1277 2
		shf_fprintf(shf, "%d\n", j->pgrp ? j->pgrp
				: (j->last_proc ? j->last_proc->pid : 0));
d1304 1
a1304 1
					WEXITSTATUS(p->status));
d1312 3
a1314 3
			if (how == JP_SHORT && !coredumped
			    && (WTERMSIG(p->status) == SIGINT
				|| WTERMSIG(p->status) == SIGPIPE)) {
d1336 1
a1336 1
					buf, coredumped ? " (core dumped)" : null);
d1341 2
a1342 2
				p->next ? "|" : null,
				coredumped ? " (core dumped)" : null);
d1348 1
a1348 2
		while (p && p->state == state && p->status == status)
		{
d1351 1
a1351 1
					space, p->command, p->next ? "|" : null);
d1354 1
a1354 1
					p->next ? "|" : null);
d1569 1
a1569 1
							curr = *prev)
@


1.32
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.31 2004/12/30 21:34:24 otto Exp $	*/
a793 1
	   	      
@


1.31
log
@Remove -Wno-unused form CFLAGS and kill some unused vars found as a result of
that. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.30 2004/12/22 18:48:56 millert Exp $	*/
d1076 1
@


1.30
log
@Our times(3) just calls getrusage(2) and gettimeofday(2), converting seconds
to ticks.  Since ksh needs things in seconds it then converted them back.
Avoid the silliness and use the getrusage(2) and gettimeofday(2) directly.
With man page help from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.29 2004/12/22 17:14:34 millert Exp $	*/
a609 1
	Proc	*p;
@


1.29
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.28 2004/12/20 11:34:26 otto Exp $	*/
d21 2
a22 1
#include <sys/times.h>
d75 2
a76 2
	clock_t	systime;	/* system time used by job */
	clock_t	usrtime;	/* user time used by job */
d105 1
a105 1
clock_t	j_systime, j_usrtime;	/* user and system time of last j_waitjed job */
d368 2
a369 1
		j->usrtime = j->systime = 0;
d1085 1
a1085 1
	struct tms	t0, t1;
d1098 1
a1098 1
	times(&t0);
d1105 1
a1105 1
		times(&t1);
d1118 1
a1118 1
			t0 = t1;
d1122 5
a1126 3
		j->usrtime += t1.tms_cutime - t0.tms_cutime;
		j->systime += t1.tms_cstime - t0.tms_cstime;
		t0 = t1;
@


1.28
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.27 2004/12/19 04:14:20 deraadt Exp $	*/
d184 1
a184 1
		tty_init(TRUE);
d250 1
a250 1
		tty_init(FALSE);
d256 1
a256 1
			warningf(FALSE, "j_init: getpgrp() failed: %s",
d268 1
a268 1
					warningf(FALSE,
d284 1
a284 1
				warningf(FALSE,
d290 1
a290 1
					warningf(FALSE,
d300 1
a300 1
			warningf(FALSE, "warning: won't have full job control");
d431 1
a431 1
			coproc_cleanup(FALSE);
d455 1
a455 1
					(void) ksh_dup2(fd, 0, TRUE);
d538 1
a538 1
			warningf(TRUE, "waitlast: no last job");
d721 1
a721 1
				warningf(TRUE,
d999 1
a999 1
				warningf(TRUE,
d1113 1
a1113 1
			warningf(TRUE, "bad process waited for (pid = %d)",
@


1.27
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.26 2004/12/18 22:12:23 millert Exp $	*/
d127 6
a132 6
static void		j_set_async(Job *j);
static void		j_startjob(Job *j);
static int		j_waitj(Job *j, int flags, const char *where);
static void		j_sigchld(int sig);
static void		j_print(Job *j, int how, struct shf *shf);
static Job		*j_lookup(const char *cp, int *ecodep);
d135 4
a138 4
static void		check_job(Job *j);
static void		put_job(Job *j, int where);
static void		remove_job(Job *j, const char *where);
static int		kill_job(Job *j, int sig);
d142 1
a142 2
j_init(mflagset)
	int mflagset;
d189 1
a189 1
j_exit()
d244 1
a244 1
j_change()
d325 2
a326 4
exchild(t, flags, close_fd)
	struct op	*t;
	int		flags;
	int		close_fd;	/* used if XPCLOSE or XCCLOSE */
d511 1
a511 1
startlast()
d527 1
a527 1
waitlast()
d554 1
a554 3
waitfor(cp, sigp)
	const char *cp;
	int	*sigp;
d605 1
a605 3
j_kill(cp, sig)
	const char *cp;
	int	sig;
d645 1
a645 3
j_resume(cp, bg)
	const char *cp;
	int	bg;
d748 1
a748 1
j_stopped_running()
d791 3
a793 4
j_jobs(cp, slp, nflag)
	const char *cp;
	int	slp;		/* 0: short, 1: long, 2: pgrp */
	int	nflag;
d840 1
a840 1
j_notify()
d868 1
a868 1
j_async()
d887 1
a887 2
j_set_async(j)
	Job *j;
d922 1
a922 2
j_startjob(j)
	Job *j;
d944 3
a946 4
j_waitj(j, flags, where)
	Job	*j;
	int	flags;		/* see JW_* */
	const char *where;
d1076 1
a1076 2
j_sigchld(sig)
	int	sig;
d1150 1
a1150 2
check_job(j)
	Job	*j;
d1256 1
a1256 4
j_print(j, how, shf)
	Job		*j;
	int		how;
	struct shf	*shf;
d1364 1
a1364 3
j_lookup(cp, ecodep)
	const char *cp;
	int	*ecodep;
d1457 1
a1457 1
new_job()
d1485 1
a1485 1
new_proc()
d1504 1
a1504 3
remove_job(j, where)
	Job	*j;
	const char *where;
d1544 1
a1544 3
put_job(j, where)
	Job	*j;
	int	where;
d1579 1
a1579 3
kill_job(j, sig)
	Job	*j;
	int	sig;
@


1.26
log
@Use struct termios instead of TTY_state typedef
Use tc[gs]etattr() instead of [gs]et_tty() abstraction
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.25 2004/12/18 22:11:43 millert Exp $	*/
d792 1
a792 1
		
@


1.25
log
@Flags set in signal handlers should be volatile sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.24 2004/12/18 21:04:52 millert Exp $	*/
d80 1
a80 1
	TTY_state ttystate;	/* saved tty state for stopped jobs */
d250 1
a250 1
		/* Don't call get_tty() 'til we own the tty process group */
d303 1
a303 1
			get_tty(tty_fd, &tty_state);
d701 2
a702 3
			if (ttypgrp_ok && (j->flags & JF_SAVEDTTY)) {
				set_tty(tty_fd, &j->ttystate, TF_NONE);
			}
d705 2
a706 3
				if (j->flags & JF_SAVEDTTY) {
					set_tty(tty_fd, &tty_state, TF_NONE);
				}
d727 2
a728 3
			if (ttypgrp_ok && (j->flags & JF_SAVEDTTY)) {
				set_tty(tty_fd, &tty_state, TF_NONE);
			}
d1019 1
a1019 1
				get_tty(tty_fd, &j->ttystate);
d1035 1
a1035 1
				get_tty(tty_fd, &tty_state);
d1037 1
a1037 2
				set_tty(tty_fd, &tty_state,
				    (j->state == PEXITED) ? 0 : TF_MIPSKLUDGE);
@


1.24
log
@Get rid of #ifdef KSH since we don't care about building a V7 style sh and
the #ifdef KSH code is required to make a POSIX sh.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.23 2004/12/18 20:55:52 millert Exp $	*/
d117 1
a117 1
static int		held_sigchld;
@


1.23
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.22 2004/11/04 19:20:07 deraadt Exp $	*/
a77 1
#ifdef KSH
a78 1
#endif /* KSH */
a375 1
#ifdef KSH
a376 1
#endif /* KSH */
a431 1
#ifdef KSH
a434 1
#endif /* KSH */
a488 1
#ifdef KSH
a493 1
#endif /* KSH */
a1201 1
#ifdef KSH
a1223 1
#endif /* KSH */
@


1.22
log
@do the variety-pack of bash-style \letter expansions on prompt variables.
a few issues remain with \ and $ and ! because of early variable expansion
done by incorrect eval/substitution, but this change is not responsible
for that.  tested by djm, jmc, and many others
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.21 2003/11/10 21:26:39 millert Exp $	*/
a15 9
 * Notes regarding the copious ifdefs:
 *	- JOB_SIGS is independent of JOBS - it is defined if there are modern
 *	  signal and wait routines available.  This is preferred, even when
 *	  JOBS is not defined, since the shell will not otherwise notice when
 *	  background jobs die until the shell waits for a foreground process
 *	  to die.
 *	- TTY_PGRP defined iff JOBS is defined - defined if there are tty
 *	  process groups
 *	- NEED_PGRP_SYNC defined iff JOBS is defined - see comment below
d19 3
a21 3
#include "ksh_stat.h"
#include "ksh_wait.h"
#include "ksh_times.h"
a23 57
/* Start of system configuration stuff */

/* We keep CHILD_MAX zombie processes around (exact value isn't critical) */
#ifndef CHILD_MAX
# if defined(HAVE_SYSCONF) && defined(_SC_CHILD_MAX)
#  define CHILD_MAX sysconf(_SC_CHILD_MAX)
# else /* _SC_CHILD_MAX */
#  ifdef _POSIX_CHILD_MAX
#   define CHILD_MAX	((_POSIX_CHILD_MAX) * 2)
#  else /* _POSIX_CHILD_MAX */
#   define CHILD_MAX	20
#  endif /* _POSIX_CHILD_MAX */
# endif /* _SC_CHILD_MAX */
#endif /* !CHILD_MAX */

#ifdef JOBS
# if defined(HAVE_TCSETPGRP) || defined(TIOCSPGRP)
#  define TTY_PGRP
# endif
# ifdef BSD_PGRP
#  define setpgid	setpgrp
#  define getpgID()	getpgrp(0)
# else
#  define getpgID()	getpgrp()
# endif
# if defined(TTY_PGRP) && !defined(HAVE_TCSETPGRP)
int tcsetpgrp ARGS((int fd, pid_t grp));
int tcgetpgrp ARGS((int fd));

int
tcsetpgrp(fd, grp)
	int fd;
	pid_t grp;
{
	return ioctl(fd, TIOCSPGRP, &grp);
}

int
tcgetpgrp(fd)
	int	fd;
{
	int r, grp;

	if ((r = ioctl(fd, TIOCGPGRP, &grp)) < 0)
		return r;
	return grp;
}
# endif /* !HAVE_TCSETPGRP && TIOCSPGRP */
#else /* JOBS */
/* These so we can use ifdef xxx instead of if defined(JOBS) && defined(xxx) */
# undef TTY_PGRP
# undef NEED_PGRP_SYNC
#endif /* JOBS */

/* End of system configuration stuff */


d34 1
a34 1
	WAIT_T	status;		/* wait status */
d81 1
a81 1
#ifdef TTY_PGRP
d84 1
a84 1
#endif /* TTY_PGRP */
a117 1
#ifdef JOB_SIGS
a119 1
#endif /* JOB_SIGS */
a122 16
#endif /* JOBS */

#ifdef NEED_PGRP_SYNC
/* On some systems, the kernel doesn't count zombie processes when checking
 * if a process group is valid, which can cause problems in creating the
 * pipeline "cmd1 | cmd2": if cmd1 can die (and go into the zombie state)
 * before cmd2 is started, the kernel doesn't allow the setpgid() for cmd2
 * to succeed.  Solution is to create a pipe between the parent and the first
 * process; the first process doesn't do anything until the pipe is closed
 * and the parent doesn't close the pipe until all the processes are started.
 */
static int		j_sync_pipe[2];
static int		j_sync_open;
#endif /* NEED_PGRP_SYNC */

#ifdef TTY_PGRP
d127 1
a127 1
#endif /* TTY_PGRP */
d129 12
a140 12
static void		j_set_async ARGS((Job *j));
static void		j_startjob ARGS((Job *j));
static int		j_waitj ARGS((Job *j, int flags, const char *where));
static RETSIGTYPE	j_sigchld ARGS((int sig));
static void		j_print ARGS((Job *j, int how, struct shf *shf));
static Job		*j_lookup ARGS((const char *cp, int *ecodep));
static Job		*new_job ARGS((void));
static Proc		*new_proc ARGS((void));
static void		check_job ARGS((Job *j));
static void		put_job ARGS((Job *j, int where));
static void		remove_job ARGS((Job *j, const char *where));
static int		kill_job ARGS((Job *j, int sig));
a148 1
#ifdef JOB_SIGS
a156 4
#else /* JOB_SIGS */
	/* Make sure SIGCHLD isn't ignored - can do odd things under SYSV */
	setsig(&sigtraps[SIGCHLD], SIG_DFL, SS_RESTORE_ORIG|SS_FORCE);
#endif /* JOB_SIGS */
a166 1
# ifdef TTY_PGRP
a179 1
# endif /* TTY_PGRP */
a225 1
# ifdef TTY_PGRP
a236 1
# endif /* TTY_PGRP */
a254 1
# ifdef TTY_PGRP
d258 1
a258 1
		if (ttypgrp_ok && (our_pgrp = getpgID()) < 0) {
a301 10
#  if defined(NTTYDISC) && defined(TIOCSETD) && !defined(HAVE_TERMIOS_H) && !defined(HAVE_TERMIO_H)
		if (ttypgrp_ok) {
			int ldisc = NTTYDISC;

			if (ioctl(tty_fd, TIOCSETD, &ldisc) < 0)
				warningf(FALSE,
				"j_init: can't set new line discipline: %s",
					strerror(errno));
		}
#  endif /* NTTYDISC && TIOCSETD */
a303 1
# endif /* TTY_PGRP */
a306 1
# ifdef TTY_PGRP
a319 1
# endif /* TTY_PGRP */
a335 1
#ifdef JOB_SIGS
a336 1
#endif /* JOB_SIGS */
a348 1
#ifdef JOB_SIGS
a350 1
#endif /* JOB_SIGS */
d355 1
a355 1
	WSTATUS(p->status) = 0;
a365 11
#ifdef NEED_PGRP_SYNC
		if (j_sync_open) {	/* should never happen */
			j_sync_open = 0;
			closepipe(j_sync_pipe);
		}
		/* don't do the sync pipe business if there is no pipeline */
		if (flags & XPIPEO) {
			openpipe(j_sync_pipe);
			j_sync_open = 1;
		}
#endif /* NEED_PGRP_SYNC */
a398 7
#ifdef NEED_PGRP_SYNC
		if (j_sync_open) {
			closepipe(j_sync_pipe);
			j_sync_open = 0;
		}
#endif /* NEED_PGRP_SYNC */
#ifdef JOB_SIGS
a399 1
#endif /* JOB_SIGS */
a411 23
# ifdef NEED_PGRP_SYNC
		int	first_child_sync = 0;
# endif /* NEED_PGRP_SYNC */

# ifdef NEED_PGRP_SYNC
		if (j_sync_open) {
			/*
			 * The Parent closes 0, keeps 1 open 'til the whole
			 * pipeline is started.  The First child closes 1,
			 * keeps 0 open (reads from it).  The remaining
			 * children just have to close 1 (parent has already
			 * closeed 0).
			 */
			if (j->pgrp == 0) { /* First process */
				close(j_sync_pipe[ischild]);
				j_sync_pipe[ischild] = -1;
				first_child_sync = ischild;
			} else if (ischild) {
				j_sync_open = 0;
				closepipe(j_sync_pipe);
			}
		}
# endif /* NEED_PGRP_SYNC */
a420 1
# ifdef TTY_PGRP
a427 11
# endif /* TTY_PGRP */
# ifdef NEED_PGRP_SYNC
		if (first_child_sync) {
			char c;
			while (read(j_sync_pipe[0], &c, 1) == -1
			       && errno == EINTR)
				;
			close(j_sync_pipe[0]);
			j_sync_open = 0;
		}
# endif /* NEED_PGRP_SYNC */
a440 1
#ifdef JOB_SIGS
a441 1
#endif /* JOB_SIGS */
d443 1
a443 1
#ifdef TTY_PGRP
d453 1
a453 2
#endif /* TTY_PGRP */
#ifdef HAVE_NICE
a455 1
#endif /* HAVE_NICE */
a475 4
#ifdef OS2
		if (tty_fd >= 0)
			flags |= XINTACT;
#endif /* OS2 */
d488 1
a488 1
#ifdef TTY_PGRP
d493 1
a493 1
#endif /* TTY_PGRP */
a514 1
#ifdef JOB_SIGS
a515 1
#endif /* JOB_SIGS */
a523 1
#ifdef JOB_SIGS
a526 1
#endif /* JOB_SIGS */
a532 1
#ifdef JOB_SIGS
a533 1
#endif /* JOB_SIGS */
a541 1
#ifdef JOB_SIGS
a544 1
#endif /* JOB_SIGS */
a551 1
#ifdef JOB_SIGS
a552 1
#endif /* JOB_SIGS */
a557 1
#ifdef JOB_SIGS
a558 1
#endif /* JOB_SIGS */
a572 1
#ifdef JOB_SIGS
a575 1
#endif /* JOB_SIGS */
a587 1
#ifdef JOB_SIGS
a588 1
#endif /* JOB_SIGS */
a594 1
#ifdef JOB_SIGS
a595 1
#endif /* JOB_SIGS */
a598 1
#ifdef JOB_SIGS
a599 1
#endif /* JOB_SIGS */
a607 1
#ifdef JOB_SIGS
a608 1
#endif /* JOB_SIGS */
a625 1
#ifdef JOB_SIGS
a628 1
#endif /* JOB_SIGS */
a630 1
#ifdef JOB_SIGS
a631 1
#endif /* JOB_SIGS */
a651 1
#ifdef JOB_SIGS
a652 1
#endif /* JOB_SIGS */
d692 1
a692 1
			WSTATUS(p->status) = 0;
d706 1
a706 1
# ifdef TTY_PGRP
d724 1
a724 1
# endif /* TTY_PGRP */
d736 1
a736 1
# ifdef TTY_PGRP
d746 1
a746 1
# endif /* TTY_PGRP */
d754 1
a754 1
# ifdef TTY_PGRP
d758 1
a758 1
# endif /* TTY_PGRP */
a797 1
#ifdef JOB_SIGS
a800 1
#endif /* JOB_SIGS */
a803 1
#ifdef JOB_SIGS
a804 1
#endif /* JOB_SIGS */
a818 1
#ifdef JOB_SIGS
a821 1
#endif /* JOB_SIGS */
a830 1
#ifdef JOB_SIGS
a831 1
#endif /* JOB_SIGS */
a854 1
#ifdef JOB_SIGS
a855 1
#endif /* JOB_SIGS */
a863 1
#ifdef JOB_SIGS
a866 1
#endif /* JOB_SIGS */
a883 1
#ifdef JOB_SIGS
a884 1
#endif /* JOB_SIGS */
a890 1
#ifdef JOB_SIGS
a893 1
#endif /* JOB_SIGS */
a897 1
#ifdef JOB_SIGS
a898 1
#endif /* JOB_SIGS */
a953 7
#ifdef NEED_PGRP_SYNC
	if (j_sync_open) {
		j_sync_open = 0;
		closepipe(j_sync_pipe);
	}
#endif /* NEED_PGRP_SYNC */
#ifdef JOB_SIGS
a958 1
#endif /* JOB_SIGS */
a987 1
#ifdef JOB_SIGS
a988 3
#else /* JOB_SIGS */
		j_sigchld(SIGCHLD);
#endif /* JOB_SIGS */
d1003 1
a1003 1
		WAIT_T	status;
d1006 1
a1006 1
#ifdef TTY_PGRP
d1033 1
a1033 1
#endif /* TTY_PGRP */
d1100 1
a1100 1
static RETSIGTYPE
d1106 1
a1106 1
	Proc		UNINITIALIZED(*p);
d1108 1
a1108 1
	WAIT_T		status;
a1110 1
#ifdef JOB_SIGS
d1119 1
a1119 1
			return RETSIGVAL;
a1120 1
#endif /* JOB_SIGS */
d1122 1
a1122 1
	ksh_times(&t0);
d1124 1
a1124 5
#ifdef JOB_SIGS
		pid = ksh_waitpid(-1, &status, (WNOHANG|WUNTRACED));
#else /* JOB_SIGS */
		pid = wait(&status);
#endif /* JOB_SIGS */
d1129 1
a1129 1
		ksh_times(&t1);
a1161 1
#ifdef JOB_SIGS
a1162 3
#else /* JOB_SIGS */
	while (0);
#endif /* JOB_SIGS */
a1164 2

	return RETSIGVAL;
d1292 1
a1292 1
	WAIT_T	status;
d1335 1
a1335 1
			if (WIFCORED(p->status))
d1376 1
a1376 2
		while (p && p->state == state
		       && WSTATUS(p->status) == WSTATUS(status))
@


1.21
log
@If "from fd" == "to fd" don't call dup2() or close "from fd".
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.20 2003/10/22 07:40:38 jmc Exp $	*/
d180 1
a180 1
static INT32		njobs;		/* # of jobs started */
d993 20
@


1.20
log
@typos from Jared Yanovich;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.19 2003/03/13 09:03:07 deraadt Exp $	*/
d632 4
a635 2
				(void) ksh_dup2(fd, 0, TRUE);
				close(fd);
@


1.19
log
@a few strcpy -> strlcpy; a couple people have mailed in a variety of
patches, and i already had this sitting on my laptop at that time.. i used
that as a chance to note that we had all done the same work, more or less
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.19 2003/03/13 08:51:21 deraadt Exp $	*/
d18 1
a18 1
 *	  signal and wait routines available.  This is prefered, even when
d126 1
a126 1
#define JF_REMOVE	0x200	/* flaged for removal (j_jobs()/j_noityf()) */
d1438 1
a1438 1
		 * (at leasst, this is what ksh93d thinks)
@


1.18
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.17 2002/06/09 05:47:27 todd Exp $	*/
d1540 1
a1540 1
			strcpy(buf, "Running");
d1543 2
a1544 1
			strcpy(buf, sigtraps[WSTOPSIG(p->status)].mess);
d1550 1
a1550 1
				strcpy(buf, "Done");
d1566 2
a1567 1
				strcpy(buf, sigtraps[WTERMSIG(p->status)].mess);
d1648 3
a1650 3
	  case '\0': /* non-standard */
	  case '+':
	  case '%':
d1655 1
a1655 1
	  case '-':
d1660 2
a1661 2
	  case '0': case '1': case '2': case '3': case '4':
	  case '5': case '6': case '7': case '8': case '9':
d1668 1
a1668 1
	  case '?':		/* %?string */
d1684 1
a1684 1
	  default:		/* %string */
@


1.17
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.16 1999/08/04 16:56:42 millert Exp $	*/
d1080 1
a1080 1
/* Return pid of last process in last asynchornous job */
d1224 1
a1224 1
			 * when it gets forgrounded by the parent shell, which
@


1.16
log
@o Better fix for not sending a HUP to pg 0 from the pdksh maintainer
o Includes fix for another unrelated problem where output of jobs command
  contains lots of ^A characters
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.15 1999/08/02 12:37:07 millert Exp $	*/
d1292 1
a1292 1
	if (!(flags & JW_ASYNCNOTIFY) 
d1433 1
a1433 1
	 * remove_job() since neither may be called for non-interactive 
@


1.15
log
@Check to make sure process group is not 0 before sending a SIGHUP to
the process group on exit.  This will cause problems if we are not
the process group leader.
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.14 1999/07/14 13:37:23 millert Exp $	*/
d224 1
a224 2
static void		kill_job ARGS((Job *j));
static void	 	fill_command ARGS((char *c, int len, struct op *t));
d290 1
a290 1
		if (j->ppid == procpid && j->pgrp != 0
d298 4
a301 1
			killpg(j->pgrp, SIGHUP);
d303 6
a308 2
			if (j->state == PSTOPPED)
				killpg(j->pgrp, SIGCONT);
d508 1
a508 1
	fill_command(p->command, sizeof(p->command), t);
d519 1
a519 1
		kill_job(j);
d834 4
a837 5
		for (p=j->proc_list; p != (Proc *) 0; p = p->next)
			if (kill(p->pid, sig) < 0) {
				bi_errorf("%s: %s", cp, strerror(errno));
				rv = 1;
			}
d1836 2
a1837 2
static void
kill_job(j)
d1839 1
d1842 1
d1846 3
a1848 38
			(void) kill(p->pid, SIGKILL);
}

/* put a more useful name on a process than snptreef does (in certain cases) */
static void
fill_command(c, len, t)
	char		*c;
	int		len;
	struct op	*t;
{
	int		alen;
	char		**ap;

	if (t->type == TEXEC || t->type == TCOM) {
		/* Causes problems when set -u is in effect, can also
		   cause problems when array indices evaluated (may have
		   side effects, eg, assignment, incr, etc.)
		if (t->type == TCOM)
			ap = eval(t->args, DOBLANK|DONTRUNCOMMAND);
		else
		*/
		ap = t->args;
		--len; /* save room for the null */
		while (len > 0 && *ap != (char *) 0) {
			alen = strlen(*ap);
			if (alen > len)
				alen = len;
			memcpy(c, *ap, alen);
			c += alen;
			len -= alen;
			if (len > 0) {
				*c++ = ' '; len--;
			}
			ap++;
		}
		*c = '\0';
	} else
		snptreef(c, len, "%T", t);
@


1.14
log
@pdksh-5.2.14
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.13 1999/01/19 20:41:53 millert Exp $	*/
d291 1
a291 1
		if (j->ppid == procpid
@


1.13
log
@Updates from pdksh-unstable-5.2.13.7.  Most notable change is:
    trap: exit traps now executed in subshells (without explicit exit call).
See the Changelog for a full list of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.12 1999/01/10 17:55:02 millert Exp $	*/
d1853 3
d1859 2
a1860 1
			ap = t->args;
@


1.12
log
@sync with pdksh-unstable-5.2.13.6
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.11 1999/01/08 20:24:59 millert Exp $	*/
d637 4
@


1.11
log
@bug fixes from pdksh-unstable-5.2.13.5; some of which we already had.
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.10 1998/11/19 19:59:09 millert Exp $	*/
d1560 1
a1560 1
		if (how != JP_SHORT)
d1565 1
@


1.10
log
@better fix
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.9 1998/11/19 19:54:34 millert Exp $	*/
d646 2
d904 1
a904 1
				if (j->flags & JF_SAVEDTTY)
d906 1
d927 1
a927 1
			if (ttypgrp_ok && (j->flags & JF_SAVEDTTY))
d929 1
@


1.9
log
@thou shalt not follow the NULL pointer, that way lies madness
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.8 1998/10/29 04:09:20 millert Exp $	*/
d779 3
a781 3
		if (ecode == JL_NOSUCH)
			return -1;
		bi_errorf("%s: %s", cp, lookup_msgs[ecode]);
d785 1
a785 2
	if (j)
		rv = j_waitj(j, flags, "jw:waitfor");
@


1.8
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.7 1998/06/25 19:02:02 millert Exp $	*/
d785 2
a786 1
	rv = j_waitj(j, flags, "jw:waitfor");
@


1.7
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.6 1997/06/19 13:58:43 kstailey Exp $	*/
d128 1
d149 1
d900 2
a901 1
			if (ttypgrp_ok && tcsetpgrp(tty_fd, j->pgrp) < 0) {
d907 1
a907 1
					tty_fd, (int) j->pgrp, strerror(errno));
d942 1
a942 1
			j->flags &= ~JF_SAVEDTTY;
d1204 14
@


1.6
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.4 1996/11/21 07:59:29 downsj Exp $	*/
a441 1
	int		orig_flags = flags;
a443 1
	flags &= ~(XFORK|XPCLOSE|XCCLOSE|XCOPROC);
d445 4
a448 1
		return execute(t, flags);
d463 2
d589 2
a590 2
	if (close_fd >= 0 && (((orig_flags & XPCLOSE) && !ischild)
			      || ((orig_flags & XCCLOSE) && ischild)))
d595 1
a595 1
		if (orig_flags & XCOPROC)
d622 1
a622 1
			if (!(orig_flags & (XPIPEI | XCOPROC))) {
d637 1
a637 1
		execute(t, flags|XEXEC); /* no return */
d653 1
a653 1
		if (orig_flags & XCOPROC) {
@


1.5
log
@(foo *)0 -> NULL
@
text
@d168 1
a168 1
				NULL
d234 1
a234 1
	sigprocmask(SIG_SETMASK, &sm_default, NULL);
d253 1
a253 1
	shl_j = shf_fdopen(2, SHF_WR, NULL);
d288 1
a288 1
	for (j = job_list; j != NULL; j = j->next) {
d455 1
a455 1
	p->next = NULL;
d517 1
a517 1
		sigprocmask(SIG_SETMASK, &omask, NULL);
d596 1
a596 1
		sigprocmask(SIG_SETMASK, &omask, NULL);
d670 1
a670 1
	sigprocmask(SIG_SETMASK, &omask, NULL);
d692 1
a692 1
	sigprocmask(SIG_SETMASK, &omask, NULL);
d715 1
a715 1
		sigprocmask(SIG_SETMASK, &omask, NULL);
d723 1
a723 1
	sigprocmask(SIG_SETMASK, &omask, NULL);
d747 1
a747 1
	if (cp == NULL) {
d757 1
a757 1
			sigprocmask(SIG_SETMASK, &omask, NULL);
d766 1
a766 1
			sigprocmask(SIG_SETMASK, &omask, NULL);
d772 1
a772 1
		sigprocmask(SIG_SETMASK, &omask, NULL);
d783 1
a783 1
	sigprocmask(SIG_SETMASK, &omask, NULL);
d808 1
a808 1
	if ((j = j_lookup(cp, &ecode)) == NULL) {
d810 1
a810 1
		sigprocmask(SIG_SETMASK, &omask, NULL);
d817 1
a817 1
		for (p=j->proc_list; p != NULL; p = p->next)
d834 1
a834 1
	sigprocmask(SIG_SETMASK, &omask, NULL);
d856 2
a857 2
	if ((j = j_lookup(cp, &ecode)) == NULL) {
		sigprocmask(SIG_SETMASK, &omask, NULL);
d863 1
a863 1
		sigprocmask(SIG_SETMASK, &omask, NULL);
d872 1
a872 1
	for (p = j->proc_list; p != NULL; p = p->next) {
d898 2
a899 1
				sigprocmask(SIG_SETMASK, &omask, NULL);
d909 1
a909 1
			async_job = NULL;
d928 1
a928 1
		sigprocmask(SIG_SETMASK, &omask, NULL);
d941 1
a941 1
	sigprocmask(SIG_SETMASK, &omask, NULL);
d953 1
a953 1
	for (j = job_list; j != NULL; j = j->next) {
d996 1
a996 1
		if ((j = j_lookup(cp, &ecode)) == NULL) {
d998 1
a998 1
			sigprocmask(SIG_SETMASK, &omask, NULL);
d1024 1
a1024 1
	sigprocmask(SIG_SETMASK, &omask, NULL);
d1057 1
a1057 1
	sigprocmask(SIG_SETMASK, &omask, NULL);
d1075 1
a1075 1
	sigprocmask(SIG_SETMASK, &omask, NULL);
d1100 1
a1100 1
		oldest = NULL;
d1314 2
a1315 2
		for (j = job_list; j != NULL; j = j->next)
			for (p = j->proc_list; p != NULL; p = p->next)
d1319 1
a1319 1
		if (j == NULL) {
d1378 1
a1378 1
	for (p=j->proc_list; p != NULL; p = p->next) {
d1408 1
a1408 1
			coproc.job = NULL;
d1503 1
a1503 1
	for (p = j->proc_list; p != NULL;) {
d1593 1
a1593 1
		for (j = job_list; j != NULL; j = j->next)
d1599 1
a1599 1
		for (j = job_list; j != NULL; j = j->next)
d1604 1
a1604 1
		return NULL;
d1609 1
a1609 1
		return NULL;
d1615 1
a1615 1
		if (job_list != NULL)
d1620 1
a1620 1
		if (job_list != NULL && job_list->next)
d1627 1
a1627 1
		for (j = job_list; j != NULL; j = j->next)
d1633 4
a1636 4
		last_match = NULL;
		for (j = job_list; j != NULL; j = j->next)
			for (p = j->proc_list; p != NULL; p = p->next)
				if (strstr(p->command, cp+1) != NULL) {
d1640 1
a1640 1
						return NULL;
d1650 2
a1651 2
		last_match = NULL;
		for (j = job_list; j != NULL; j = j->next)
d1656 1
a1656 1
					return NULL;
d1666 1
a1666 1
	return NULL;
d1682 1
a1682 1
	if (free_jobs != NULL) {
d1692 1
a1692 1
		if (j == NULL)
d1709 1
a1709 1
	if (free_procs != NULL) {
d1733 1
a1733 1
	for (; curr != NULL && curr != j; prev = &curr->next, curr = *prev)
d1742 1
a1742 1
	for (p = j->proc_list; p != NULL; ) {
d1755 1
a1755 1
		last_job = NULL;
d1757 1
a1757 1
		async_job = NULL;
d1808 1
a1808 1
	for (p = j->proc_list; p != NULL; p = p->next)
d1829 1
a1829 1
		while (len > 0 && *ap != NULL) {
@


1.4
log
@Update to 5.2.12.
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.3 1996/08/25 12:38:03 downsj Exp $	*/
d168 1
a168 1
				(char *) 0
d234 1
a234 1
	sigprocmask(SIG_SETMASK, &sm_default, (sigset_t *) 0);
d253 1
a253 1
	shl_j = shf_fdopen(2, SHF_WR, (struct shf *) 0);
d288 1
a288 1
	for (j = job_list; j != (Job *) 0; j = j->next) {
d455 1
a455 1
	p->next = (Proc *) 0;
d517 1
a517 1
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d596 1
a596 1
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d670 1
a670 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d692 1
a692 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d715 1
a715 1
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d723 1
a723 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d747 1
a747 1
	if (cp == (char *) 0) {
d757 1
a757 1
			sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d766 1
a766 1
			sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d772 1
a772 1
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d783 1
a783 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d808 1
a808 1
	if ((j = j_lookup(cp, &ecode)) == (Job *) 0) {
d810 1
a810 1
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d817 1
a817 1
		for (p=j->proc_list; p != (Proc *) 0; p = p->next)
d834 1
a834 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d856 2
a857 2
	if ((j = j_lookup(cp, &ecode)) == (Job *) 0) {
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d863 1
a863 1
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d872 1
a872 1
	for (p = j->proc_list; p != (Proc *) 0; p = p->next) {
d898 1
a898 2
				sigprocmask(SIG_SETMASK, &omask,
					(sigset_t *) 0);
d908 1
a908 1
			async_job = (Job *) 0;
d927 1
a927 1
		sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d940 1
a940 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d952 1
a952 1
	for (j = job_list; j != (Job *) 0; j = j->next) {
d995 1
a995 1
		if ((j = j_lookup(cp, &ecode)) == (Job *) 0) {
d997 1
a997 1
			sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d1023 1
a1023 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d1056 1
a1056 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d1074 1
a1074 1
	sigprocmask(SIG_SETMASK, &omask, (sigset_t *) 0);
d1099 1
a1099 1
		oldest = (Job *) 0;
d1313 2
a1314 2
		for (j = job_list; j != (Job *) 0; j = j->next)
			for (p = j->proc_list; p != (Proc *) 0; p = p->next)
d1318 1
a1318 1
		if (j == (Job *) 0) {
d1377 1
a1377 1
	for (p=j->proc_list; p != (Proc *) 0; p = p->next) {
d1407 1
a1407 1
			coproc.job = (void *) 0;
d1502 1
a1502 1
	for (p = j->proc_list; p != (Proc *) 0;) {
d1592 1
a1592 1
		for (j = job_list; j != (Job *) 0; j = j->next)
d1598 1
a1598 1
		for (j = job_list; j != (Job *) 0; j = j->next)
d1603 1
a1603 1
		return (Job *) 0;
d1608 1
a1608 1
		return (Job *) 0;
d1614 1
a1614 1
		if (job_list != (Job *) 0)
d1619 1
a1619 1
		if (job_list != (Job *) 0 && job_list->next)
d1626 1
a1626 1
		for (j = job_list; j != (Job *) 0; j = j->next)
d1632 4
a1635 4
		last_match = (Job *) 0;
		for (j = job_list; j != (Job *) 0; j = j->next)
			for (p = j->proc_list; p != (Proc *) 0; p = p->next)
				if (strstr(p->command, cp+1) != (char *) 0) {
d1639 1
a1639 1
						return (Job *) 0;
d1649 2
a1650 2
		last_match = (Job *) 0;
		for (j = job_list; j != (Job *) 0; j = j->next)
d1655 1
a1655 1
					return (Job *) 0;
d1665 1
a1665 1
	return (Job *) 0;
d1681 1
a1681 1
	if (free_jobs != (Job *) 0) {
d1691 1
a1691 1
		if (j == (Job *) 0)
d1708 1
a1708 1
	if (free_procs != (Proc *) 0) {
d1732 1
a1732 1
	for (; curr != (Job *) 0 && curr != j; prev = &curr->next, curr = *prev)
d1741 1
a1741 1
	for (p = j->proc_list; p != (Proc *) 0; ) {
d1754 1
a1754 1
		last_job = (Job *) 0;
d1756 1
a1756 1
		async_job = (Job *) 0;
d1807 1
a1807 1
	for (p = j->proc_list; p != (Proc *) 0; p = p->next)
d1828 1
a1828 1
		while (len > 0 && *ap != (char *) 0) {
@


1.3
log
@Fix problems with compiling without KSH defined, add NOEDIT override.
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.2 1996/08/19 20:08:52 downsj Exp $	*/
d467 2
a468 1
		if (j_sync_open) {
a469 1
			j_sync_open = 0;
d532 1
a532 1
		int	dosync = 0;
a534 3
		if (j->pgrp == 0) {	/* First process */
			j->pgrp = p->pid;
			dotty = 1;
d536 9
a544 1
			if (j_sync_open) {
d547 4
a550 1
				dosync = ischild;
d552 1
d554 3
d573 5
a577 7
		if (ischild && j_sync_open) {
			if (dosync) {
				char c;
				while (read(j_sync_pipe[0], &c, 1) == -1
				       && errno == EINTR)
					;
			}
d1134 1
a1135 1
		j_sync_open = 0;
d1141 1
a1141 1
		/* Don't call j_sigchild() as it may remove job... */
d1357 1
a1357 1
 * from j_sigchild()).  If no processes are running, the job status
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
d143 1
d145 1
d489 1
d491 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d143 1
a180 1
static sigset_t		sm_default, sm_sigchld;
d237 2
a238 1
	setsig(&sigtraps[SIGCHLD], j_sigchld, SS_RESTORE_ORIG|SS_FORCE);
d257 3
a259 1
		/* j_change() sets these to SS_RESTORE_DFL if FMONITOR */
d262 1
a403 3
		/* the TF_SHELL_USES test is a kludge that lets us know if
		 * if the signals have been changed by the shell.
		 */
d414 1
a414 1
						SS_RESTORE_CURR|SS_FORCE);
d487 1
a489 4
		if (flags & XXCOM)
			j->flags |= JF_XXCOM;
		else if (!(flags & XBGND))
			j->flags |= JF_FG;
d536 2
a537 2
				close(j_sync_pipe[ischild ? 1 : 0]);
				j_sync_pipe[ischild ? 1 : 0] = -1;
d572 2
a573 2
	if (close_fd >= 0 && (((orig_flags & XPCLOSE) && i != 0)
			      || ((orig_flags & XCCLOSE) && i == 0)))
d575 6
a580 1
	if (i == 0) {		/* child */
a584 4
#ifdef KSH
		if (orig_flags & XCOPROC)
			cleanup_coproc(FALSE);
#endif /* KSH */
d606 3
a608 3
				i = open("/dev/null", 0);
				(void) ksh_dup2(i, 0, TRUE);
				close(i);
d636 5
a640 2
		if (flags & XCOPROC)
			coproc.job = (void *) j;
a1272 2
	trapsig(sig);

d1389 18
a1406 3
	if ((j->state == PEXITED || j->state == PSIGNALLED)
	    && coproc.job == (void *) j)
		coproc.job = (void *) 0;
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
