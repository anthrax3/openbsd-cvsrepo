head	1.59;
access;
symbols
	OPENBSD_6_1:1.59.0.4
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.59.0.2
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.58.0.2
	OPENBSD_5_9_BASE:1.58
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.44.0.6
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.44.0.4
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.43.0.2
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.41.0.12
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.10
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.8
	OPENBSD_5_0:1.41.0.6
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.4
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.2
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.40.0.4
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.39.0.2
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.38.0.2
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.37.0.2
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.35.0.4
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.17.0.8
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.6
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.4
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.12
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.13.0.10
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.13.0.8
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.13.0.6
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.4
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.59
date	2016.03.04.15.11.06;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	lvfr78VLuzkoupSX;

1.58
date	2015.12.30.09.07.00;	author tedu;	state Exp;
branches;
next	1.57;
commitid	WTwPzlskFufQpRQz;

1.57
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.56;
commitid	btTCreDA00YdaFhU;

1.56
date	2015.12.14.06.09.43;	author mmcc;	state Exp;
branches;
next	1.55;
commitid	X7XrxRgHwWl96WEl;

1.55
date	2015.11.12.04.04.31;	author mmcc;	state Exp;
branches;
next	1.54;
commitid	QvyWaajN4Lc4MRtd;

1.54
date	2015.11.01.15.38.53;	author mmcc;	state Exp;
branches;
next	1.53;
commitid	Fr9nr0FBz2YkAWdK;

1.53
date	2015.10.21.15.20.37;	author mmcc;	state Exp;
branches;
next	1.52;
commitid	xYVdAoH9LzDsXxBv;

1.52
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.51;
commitid	C4W85jmosThChWA2;

1.51
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.50;
commitid	16HUr75moyUNtKR8;

1.50
date	2015.10.10.00.10.07;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	xaTgTtwXn5YGjAmi;

1.49
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.48;
commitid	7fgq4YTZG4xZ0uN0;

1.48
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.47;
commitid	v5QjoxUgKU2iUTFz;

1.47
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.46;
commitid	lBs9un9sXhbdfVrQ;

1.46
date	2015.07.20.20.46.24;	author guenther;	state Exp;
branches;
next	1.45;
commitid	NXY7oR0vgXHONEpf;

1.45
date	2014.08.27.08.26.04;	author jmc;	state Exp;
branches;
next	1.44;
commitid	vkBAZhgSp4t3XJIt;

1.44
date	2013.09.04.15.49.18;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2013.04.19.17.39.45;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2013.03.20.21.05.00;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2010.03.27.09.10.01;	author jmc;	state Exp;
branches;
next	1.40;

1.40
date	2009.05.05.17.59.55;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2009.01.29.23.27.26;	author jaredy;	state Exp;
branches;
next	1.38;

1.38
date	2008.07.23.16.34.38;	author jaredy;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.03.13.54.23;	author otto;	state Exp;
branches;
next	1.36;

1.36
date	2007.08.02.10.50.25;	author fgsch;	state Exp;
branches;
next	1.35;

1.35
date	2006.04.10.14.38.59;	author jaredy;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.21.09.00.23;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.20.20.54.08;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.12.00.26.58;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.08.18.07.31;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.06.06.39.35;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2005.02.02.07.53.01;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.28.21.11.21;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.22.18.57.28;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.22.18.48.56;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.19.01.58.04;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.18.22.35.41;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.18.21.04.52;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.13.09.03.07;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.04.22.36.07;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.13;

1.13
date	99.07.14.13.37.23;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.06.15.01.18.33;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.01.10.17.55.02;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.01.10.16.45.49;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.01.08.20.24.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.10.29.04.09.20;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.06.25.19.01.46;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.08.05.21.49.54;	author grr;	state Exp;
branches;
next	1.5;

1.5
date	97.06.19.13.58.38;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.06.18.22.42.28;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.10.13.21.32.18;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.46;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.10;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.10;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.59
log
@remove CSRG BSD-licensed mknod builtin code which was previously used to
accelerate install/upgrade time MAKEDEV runs.  That allows ramdisk ksh
to be pledged, without needing "dpath".  We'll solve the performance issues
a different way (soon).
ok otto espie natano tb tobiasu rpe
@
text
@/*	$OpenBSD: c_sh.c,v 1.58 2015/12/30 09:07:00 tedu Exp $	*/

/*
 * built-in Bourne commands
 */

#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/time.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "sh.h"

static void p_time(struct shf *, int, struct timeval *, int, char *, char *);

/* :, false and true */
int
c_label(char **wp)
{
	return wp[0][0] == 'f' ? 1 : 0;
}

int
c_shift(char **wp)
{
	struct block *l = genv->loc;
	int n;
	long val;
	char *arg;

	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return 1;
	arg = wp[builtin_opt.optind];

	if (arg) {
		evaluate(arg, &val, KSH_UNWIND_ERROR, false);
		n = val;
	} else
		n = 1;
	if (n < 0) {
		bi_errorf("%s: bad number", arg);
		return (1);
	}
	if (l->argc < n) {
		bi_errorf("nothing to shift");
		return (1);
	}
	l->argv[n] = l->argv[0];
	l->argv += n;
	l->argc -= n;
	return 0;
}

int
c_umask(char **wp)
{
	int i;
	char *cp;
	int symbolic = 0;
	mode_t old_umask;
	int optc;

	while ((optc = ksh_getopt(wp, &builtin_opt, "S")) != -1)
		switch (optc) {
		case 'S':
			symbolic = 1;
			break;
		case '?':
			return 1;
		}
	cp = wp[builtin_opt.optind];
	if (cp == NULL) {
		old_umask = umask(0);
		umask(old_umask);
		if (symbolic) {
			char buf[18];
			int j;

			old_umask = ~old_umask;
			cp = buf;
			for (i = 0; i < 3; i++) {
				*cp++ = "ugo"[i];
				*cp++ = '=';
				for (j = 0; j < 3; j++)
					if (old_umask & (1 << (8 - (3*i + j))))
						*cp++ = "rwx"[j];
				*cp++ = ',';
			}
			cp[-1] = '\0';
			shprintf("%s\n", buf);
		} else
			shprintf("%#3.3o\n", old_umask);
	} else {
		mode_t new_umask;

		if (digit(*cp)) {
			for (new_umask = 0; *cp >= '0' && *cp <= '7'; cp++)
				new_umask = new_umask * 8 + (*cp - '0');
			if (*cp) {
				bi_errorf("bad number");
				return 1;
			}
		} else {
			/* symbolic format */
			int positions, new_val;
			char op;

			old_umask = umask(0);
			umask(old_umask); /* in case of error */
			old_umask = ~old_umask;
			new_umask = old_umask;
			positions = 0;
			while (*cp) {
				while (*cp && strchr("augo", *cp))
					switch (*cp++) {
					case 'a':
						positions |= 0111;
						break;
					case 'u':
						positions |= 0100;
						break;
					case 'g':
						positions |= 0010;
						break;
					case 'o':
						positions |= 0001;
						break;
					}
				if (!positions)
					positions = 0111; /* default is a */
				if (!strchr("=+-", op = *cp))
					break;
				cp++;
				new_val = 0;
				while (*cp && strchr("rwxugoXs", *cp))
					switch (*cp++) {
					case 'r': new_val |= 04; break;
					case 'w': new_val |= 02; break;
					case 'x': new_val |= 01; break;
					case 'u': new_val |= old_umask >> 6;
						  break;
					case 'g': new_val |= old_umask >> 3;
						  break;
					case 'o': new_val |= old_umask >> 0;
						  break;
					case 'X': if (old_umask & 0111)
							new_val |= 01;
						  break;
					case 's': /* ignored */
						  break;
					}
				new_val = (new_val & 07) * positions;
				switch (op) {
				case '-':
					new_umask &= ~new_val;
					break;
				case '=':
					new_umask = new_val |
					    (new_umask & ~(positions * 07));
					break;
				case '+':
					new_umask |= new_val;
				}
				if (*cp == ',') {
					positions = 0;
					cp++;
				} else if (!strchr("=+-", *cp))
					break;
			}
			if (*cp) {
				bi_errorf("bad mask");
				return 1;
			}
			new_umask = ~new_umask;
		}
		umask(new_umask);
	}
	return 0;
}

int
c_dot(char **wp)
{
	char *file, *cp;
	char **argv;
	int argc;
	int i;
	int err;

	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return 1;

	if ((cp = wp[builtin_opt.optind]) == NULL)
		return 0;
	file = search(cp, path, R_OK, &err);
	if (file == NULL) {
		bi_errorf("%s: %s", cp, err ? strerror(err) : "not found");
		return 1;
	}

	/* Set positional parameters? */
	if (wp[builtin_opt.optind + 1]) {
		argv = wp + builtin_opt.optind;
		argv[0] = genv->loc->argv[0]; /* preserve $0 */
		for (argc = 0; argv[argc + 1]; argc++)
			;
	} else {
		argc = 0;
		argv = NULL;
	}
	i = include(file, argc, argv, 0);
	if (i < 0) { /* should not happen */
		bi_errorf("%s: %s", cp, strerror(errno));
		return 1;
	}
	return i;
}

int
c_wait(char **wp)
{
	int rv = 0;
	int sig;

	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return 1;
	wp += builtin_opt.optind;
	if (*wp == NULL) {
		while (waitfor(NULL, &sig) >= 0)
			;
		rv = sig;
	} else {
		for (; *wp; wp++)
			rv = waitfor(*wp, &sig);
		if (rv < 0)
			rv = sig ? sig : 127; /* magic exit code: bad job-id */
	}
	return rv;
}

int
c_read(char **wp)
{
	int c = 0;
	int expand = 1, history = 0;
	int expanding;
	int ecode = 0;
	char *cp;
	int fd = 0;
	struct shf *shf;
	int optc;
	const char *emsg;
	XString cs, xs;
	struct tbl *vp;
	char *xp = NULL;

	while ((optc = ksh_getopt(wp, &builtin_opt, "prsu,")) != -1)
		switch (optc) {
		case 'p':
			if ((fd = coproc_getfd(R_OK, &emsg)) < 0) {
				bi_errorf("-p: %s", emsg);
				return 1;
			}
			break;
		case 'r':
			expand = 0;
			break;
		case 's':
			history = 1;
			break;
		case 'u':
			if (!*(cp = builtin_opt.optarg))
				fd = 0;
			else if ((fd = check_fd(cp, R_OK, &emsg)) < 0) {
				bi_errorf("-u: %s: %s", cp, emsg);
				return 1;
			}
			break;
		case '?':
			return 1;
		}
	wp += builtin_opt.optind;

	if (*wp == NULL)
		*--wp = "REPLY";

	/* Since we can't necessarily seek backwards on non-regular files,
	 * don't buffer them so we can't read too much.
	 */
	shf = shf_reopen(fd, SHF_RD | SHF_INTERRUPT | can_seek(fd), shl_spare);

	if ((cp = strchr(*wp, '?')) != NULL) {
		*cp = 0;
		if (isatty(fd)) {
			/* at&t ksh says it prints prompt on fd if it's open
			 * for writing and is a tty, but it doesn't do it
			 * (it also doesn't check the interactive flag,
			 * as is indicated in the Kornshell book).
			 */
			shellf("%s", cp+1);
		}
	}

	/* If we are reading from the co-process for the first time,
	 * make sure the other side of the pipe is closed first.  This allows
	 * the detection of eof.
	 *
	 * This is not compatible with at&t ksh... the fd is kept so another
	 * coproc can be started with same output, however, this means eof
	 * can't be detected...  This is why it is closed here.
	 * If this call is removed, remove the eof check below, too.
	 * coproc_readw_close(fd);
	 */

	if (history)
		Xinit(xs, xp, 128, ATEMP);
	expanding = 0;
	Xinit(cs, cp, 128, ATEMP);
	for (; *wp != NULL; wp++) {
		for (cp = Xstring(cs, cp); ; ) {
			if (c == '\n' || c == EOF)
				break;
			while (1) {
				c = shf_getc(shf);
				if (c == '\0')
					continue;
				if (c == EOF && shf_error(shf) &&
				    shf->errno_ == EINTR) {
					/* Was the offending signal one that
					 * would normally kill a process?
					 * If so, pretend the read was killed.
					 */
					ecode = fatal_trap_check();

					/* non fatal (eg, CHLD), carry on */
					if (!ecode) {
						shf_clearerr(shf);
						continue;
					}
				}
				break;
			}
			if (history) {
				Xcheck(xs, xp);
				Xput(xs, xp, c);
			}
			Xcheck(cs, cp);
			if (expanding) {
				expanding = 0;
				if (c == '\n') {
					c = 0;
					if (Flag(FTALKING_I) && isatty(fd)) {
						/* set prompt in case this is
						 * called from .profile or $ENV
						 */
						set_prompt(PS2, NULL);
						pprompt(prompt, 0);
					}
				} else if (c != EOF)
					Xput(cs, cp, c);
				continue;
			}
			if (expand && c == '\\') {
				expanding = 1;
				continue;
			}
			if (c == '\n' || c == EOF)
				break;
			if (ctype(c, C_IFS)) {
				if (Xlength(cs, cp) == 0 && ctype(c, C_IFSWS))
					continue;
				if (wp[1])
					break;
			}
			Xput(cs, cp, c);
		}
		/* strip trailing IFS white space from last variable */
		if (!wp[1])
			while (Xlength(cs, cp) && ctype(cp[-1], C_IFS) &&
			    ctype(cp[-1], C_IFSWS))
				cp--;
		Xput(cs, cp, '\0');
		vp = global(*wp);
		/* Must be done before setting export. */
		if (vp->flag & RDONLY) {
			shf_flush(shf);
			bi_errorf("%s is read only", *wp);
			return 1;
		}
		if (Flag(FEXPORT))
			typeset(*wp, EXPORT, 0, 0, 0);
		if (!setstr(vp, Xstring(cs, cp), KSH_RETURN_ERROR)) {
		    shf_flush(shf);
		    return 1;
		}
	}

	shf_flush(shf);
	if (history) {
		Xput(xs, xp, '\0');
		source->line++;
		histsave(source->line, Xstring(xs, xp), 1);
		Xfree(xs, xp);
	}
	/* if this is the co-process fd, close the file descriptor
	 * (can get eof if and only if all processes are have died, ie,
	 * coproc.njobs is 0 and the pipe is closed).
	 */
	if (c == EOF && !ecode)
		coproc_read_close(fd);

	return ecode ? ecode : c == EOF;
}

int
c_eval(char **wp)
{
	struct source *s;
	int rv;

	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return 1;
	s = pushs(SWORDS, ATEMP);
	s->u.strv = wp + builtin_opt.optind;
	if (!Flag(FPOSIX)) {
		/*
		 * Handle case where the command is empty due to failed
		 * command substitution, eg, eval "$(false)".
		 * In this case, shell() will not set/change exstat (because
		 * compiled tree is empty), so will use this value.
		 * subst_exstat is cleared in execute(), so should be 0 if
		 * there were no substitutions.
		 *
		 * A strict reading of POSIX says we don't do this (though
		 * it is traditionally done). [from 1003.2-1992]
		 *    3.9.1: Simple Commands
		 *	... If there is a command name, execution shall
		 *	continue as described in 3.9.1.1.  If there
		 *	is no command name, but the command contained a command
		 *	substitution, the command shall complete with the exit
		 *	status of the last command substitution
		 *    3.9.1.1: Command Search and Execution
		 *	...(1)...(a) If the command name matches the name of
		 *	a special built-in utility, that special built-in
		 *	utility shall be invoked.
		 * 3.14.5: Eval
		 *	... If there are no arguments, or only null arguments,
		 *	eval shall return an exit status of zero.
		 */
		exstat = subst_exstat;
	}

	rv = shell(s, false);
	afree(s, ATEMP);
	return (rv);
}

int
c_trap(char **wp)
{
	int i;
	char *s;
	Trap *p;

	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return 1;
	wp += builtin_opt.optind;

	if (*wp == NULL) {
		for (p = sigtraps, i = NSIG+1; --i >= 0; p++) {
			if (p->trap != NULL) {
				shprintf("trap -- ");
				print_value_quoted(p->trap);
				shprintf(" %s\n", p->name);
			}
		}
		return 0;
	}

	/*
	 * Use case sensitive lookup for first arg so the
	 * command 'exit' isn't confused with the pseudo-signal
	 * 'EXIT'.
	 */
	s = (gettrap(*wp, false) == NULL) ? *wp++ : NULL; /* get command */
	if (s != NULL && s[0] == '-' && s[1] == '\0')
		s = NULL;

	/* set/clear traps */
	while (*wp != NULL) {
		p = gettrap(*wp++, true);
		if (p == NULL) {
			bi_errorf("bad signal %s", wp[-1]);
			return 1;
		}
		settrap(p, s);
	}
	return 0;
}

int
c_exitreturn(char **wp)
{
	int how = LEXIT;
	int n;
	char *arg;

	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return 1;
	arg = wp[builtin_opt.optind];

	if (arg) {
		if (!getn(arg, &n)) {
			exstat = 1;
			warningf(true, "%s: bad number", arg);
		} else
			exstat = n;
	}
	if (wp[0][0] == 'r') { /* return */
		struct env *ep;

		/* need to tell if this is exit or return so trap exit will
		 * work right (POSIX)
		 */
		for (ep = genv; ep; ep = ep->oenv)
			if (STOP_RETURN(ep->type)) {
				how = LRETURN;
				break;
			}
	}

	if (how == LEXIT && !really_exit && j_stopped_running()) {
		really_exit = 1;
		how = LSHELL;
	}

	quitenv(NULL);	/* get rid of any i/o redirections */
	unwind(how);
	/* NOTREACHED */
	return 0;
}

int
c_brkcont(char **wp)
{
	int n, quit;
	struct env *ep, *last_ep = NULL;
	char *arg;

	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return 1;
	arg = wp[builtin_opt.optind];

	if (!arg)
		n = 1;
	else if (!bi_getn(arg, &n))
		return 1;
	quit = n;
	if (quit <= 0) {
		/* at&t ksh does this for non-interactive shells only - weird */
		bi_errorf("%s: bad value", arg);
		return 1;
	}

	/* Stop at E_NONE, E_PARSE, E_FUNC, or E_INCL */
	for (ep = genv; ep && !STOP_BRKCONT(ep->type); ep = ep->oenv)
		if (ep->type == E_LOOP) {
			if (--quit == 0)
				break;
			ep->flags |= EF_BRKCONT_PASS;
			last_ep = ep;
		}

	if (quit) {
		/* at&t ksh doesn't print a message - just does what it
		 * can.  We print a message 'cause it helps in debugging
		 * scripts, but don't generate an error (ie, keep going).
		 */
		if (n == quit) {
			warningf(true, "%s: cannot %s", wp[0], wp[0]);
			return 0;
		}
		/* POSIX says if n is too big, the last enclosing loop
		 * shall be used.  Doesn't say to print an error but we
		 * do anyway 'cause the user messed up.
		 */
		if (last_ep)
			last_ep->flags &= ~EF_BRKCONT_PASS;
		warningf(true, "%s: can only %s %d level(s)",
		    wp[0], wp[0], n - quit);
	}

	unwind(*wp[0] == 'b' ? LBREAK : LCONTIN);
	/* NOTREACHED */
}

int
c_set(char **wp)
{
	int argi, setargs;
	struct block *l = genv->loc;
	char **owp = wp;

	if (wp[1] == NULL) {
		static const char *const args [] = { "set", "-", NULL };
		return c_typeset((char **) args);
	}

	argi = parse_args(wp, OF_SET, &setargs);
	if (argi < 0)
		return 1;
	/* set $# and $* */
	if (setargs) {
		owp = wp += argi - 1;
		wp[0] = l->argv[0]; /* save $0 */
		while (*++wp != NULL)
			*wp = str_save(*wp, &l->area);
		l->argc = wp - owp - 1;
		l->argv = areallocarray(NULL, l->argc+2, sizeof(char *), &l->area);
		for (wp = l->argv; (*wp++ = *owp++) != NULL; )
			;
	}
	/* POSIX says set exit status is 0, but old scripts that use
	 * getopt(1), use the construct: set -- `getopt ab:c "$@@"`
	 * which assumes the exit value set will be that of the ``
	 * (subst_exstat is cleared in execute() so that it will be 0
	 * if there are no command substitutions).
	 */
	return Flag(FPOSIX) ? 0 : subst_exstat;
}

int
c_unset(char **wp)
{
	char *id;
	int optc, unset_var = 1;

	while ((optc = ksh_getopt(wp, &builtin_opt, "fv")) != -1)
		switch (optc) {
		case 'f':
			unset_var = 0;
			break;
		case 'v':
			unset_var = 1;
			break;
		case '?':
			return 1;
		}
	wp += builtin_opt.optind;
	for (; (id = *wp) != NULL; wp++)
		if (unset_var) {	/* unset variable */
			struct tbl *vp = global(id);

			if ((vp->flag&RDONLY)) {
				bi_errorf("%s is read only", vp->name);
				return 1;
			}
			unset(vp, strchr(id, '[') ? 1 : 0);
		} else {		/* unset function */
			define(id, NULL);
		}
	return 0;
}

static void
p_time(struct shf *shf, int posix, struct timeval *tv, int width, char *prefix,
    char *suffix)
{
	if (posix)
		shf_fprintf(shf, "%s%*lld.%02ld%s", prefix ? prefix : "",
		    width, (long long)tv->tv_sec, tv->tv_usec / 10000, suffix);
	else
		shf_fprintf(shf, "%s%*lldm%02lld.%02lds%s", prefix ? prefix : "",
		    width, (long long)tv->tv_sec / 60,
		    (long long)tv->tv_sec % 60,
		    tv->tv_usec / 10000, suffix);
}

int
c_times(char **wp)
{
	struct rusage usage;

	(void) getrusage(RUSAGE_SELF, &usage);
	p_time(shl_stdout, 0, &usage.ru_utime, 0, NULL, " ");
	p_time(shl_stdout, 0, &usage.ru_stime, 0, NULL, "\n");

	(void) getrusage(RUSAGE_CHILDREN, &usage);
	p_time(shl_stdout, 0, &usage.ru_utime, 0, NULL, " ");
	p_time(shl_stdout, 0, &usage.ru_stime, 0, NULL, "\n");

	return 0;
}

/*
 * time pipeline (really a statement, not a built-in command)
 */
int
timex(struct op *t, int f, volatile int *xerrok)
{
#define TF_NOARGS	BIT(0)
#define TF_NOREAL	BIT(1)		/* don't report real time */
#define TF_POSIX	BIT(2)		/* report in posix format */
	int rv = 0;
	struct rusage ru0, ru1, cru0, cru1;
	struct timeval usrtime, systime, tv0, tv1;
	int tf = 0;
	extern struct timeval j_usrtime, j_systime; /* computed by j_wait */

	gettimeofday(&tv0, NULL);
	getrusage(RUSAGE_SELF, &ru0);
	getrusage(RUSAGE_CHILDREN, &cru0);
	if (t->left) {
		/*
		 * Two ways of getting cpu usage of a command: just use t0
		 * and t1 (which will get cpu usage from other jobs that
		 * finish while we are executing t->left), or get the
		 * cpu usage of t->left. at&t ksh does the former, while
		 * pdksh tries to do the later (the j_usrtime hack doesn't
		 * really work as it only counts the last job).
		 */
		timerclear(&j_usrtime);
		timerclear(&j_systime);
		rv = execute(t->left, f | XTIME, xerrok);
		if (t->left->type == TCOM)
			tf |= t->left->str[0];
		gettimeofday(&tv1, NULL);
		getrusage(RUSAGE_SELF, &ru1);
		getrusage(RUSAGE_CHILDREN, &cru1);
	} else
		tf = TF_NOARGS;

	if (tf & TF_NOARGS) { /* ksh93 - report shell times (shell+kids) */
		tf |= TF_NOREAL;
		timeradd(&ru0.ru_utime, &cru0.ru_utime, &usrtime);
		timeradd(&ru0.ru_stime, &cru0.ru_stime, &systime);
	} else {
		timersub(&ru1.ru_utime, &ru0.ru_utime, &usrtime);
		timeradd(&usrtime, &j_usrtime, &usrtime);
		timersub(&ru1.ru_stime, &ru0.ru_stime, &systime);
		timeradd(&systime, &j_systime, &systime);
	}

	if (!(tf & TF_NOREAL)) {
		timersub(&tv1, &tv0, &tv1);
		if (tf & TF_POSIX)
			p_time(shl_out, 1, &tv1, 5, "real ", "\n");
		else
			p_time(shl_out, 0, &tv1, 5, NULL, " real ");
	}
	if (tf & TF_POSIX)
		p_time(shl_out, 1, &usrtime, 5, "user ", "\n");
	else
		p_time(shl_out, 0, &usrtime, 5, NULL, " user ");
	if (tf & TF_POSIX)
		p_time(shl_out, 1, &systime, 5, "sys  ", "\n");
	else
		p_time(shl_out, 0, &systime, 5, NULL, " system\n");
	shf_flush(shl_out);

	return rv;
}

void
timex_hook(struct op *t, char **volatile *app)
{
	char **wp = *app;
	int optc;
	int i, j;
	Getopt opt;

	ksh_getopt_reset(&opt, 0);
	opt.optind = 0;	/* start at the start */
	while ((optc = ksh_getopt(wp, &opt, ":p")) != -1)
		switch (optc) {
		case 'p':
			t->str[0] |= TF_POSIX;
			break;
		case '?':
			errorf("time: -%s unknown option", opt.optarg);
		case ':':
			errorf("time: -%s requires an argument",
			    opt.optarg);
		}
	/* Copy command words down over options. */
	if (opt.optind != 0) {
		for (i = 0; i < opt.optind; i++)
			afree(wp[i], ATEMP);
		for (i = 0, j = opt.optind; (wp[i] = wp[j]); i++, j++)
			;
	}
	if (!wp[0])
		t->str[0] |= TF_NOARGS;
	*app = wp;
}

/* exec with no args - args case is taken care of in comexec() */
int
c_exec(char **wp)
{
	int i;

	/* make sure redirects stay in place */
	if (genv->savefd != NULL) {
		for (i = 0; i < NUFILE; i++) {
			if (genv->savefd[i] > 0)
				close(genv->savefd[i]);
			/*
			 * For ksh keep anything > 2 private,
			 * for sh, let them be (POSIX says what
			 * happens is unspecified and the bourne shell
			 * keeps them open).
			 */
			if (!Flag(FSH) && i > 2 && genv->savefd[i])
				fcntl(i, F_SETFD, FD_CLOEXEC);
		}
		genv->savefd = NULL;
	}
	return 0;
}

static int
c_suspend(char **wp)
{
	if (wp[1] != NULL) {
		bi_errorf("too many arguments");
		return 1;
	}
	if (Flag(FLOGIN)) {
		/* Can't suspend an orphaned process group. */
		pid_t parent = getppid();
		if (getpgid(parent) == getpgid(0) ||
		    getsid(parent) != getsid(0)) {
			bi_errorf("can't suspend a login shell");
			return 1;
		}
	}
	j_suspend();
	return 0;
}

/* dummy function, special case in comexec() */
int
c_builtin(char **wp)
{
	return 0;
}

extern	int c_test(char **wp);			/* in c_test.c */
extern	int c_ulimit(char **wp);		/* in c_ulimit.c */

/* A leading = means assignments before command are kept;
 * a leading * means a POSIX special builtin;
 * a leading + means a POSIX regular builtin
 * (* and + should not be combined).
 */
const struct builtin shbuiltins [] = {
	{"*=.", c_dot},
	{"*=:", c_label},
	{"[", c_test},
	{"*=break", c_brkcont},
	{"=builtin", c_builtin},
	{"*=continue", c_brkcont},
	{"*=eval", c_eval},
	{"*=exec", c_exec},
	{"*=exit", c_exitreturn},
	{"+false", c_label},
	{"*=return", c_exitreturn},
	{"*=set", c_set},
	{"*=shift", c_shift},
	{"*=times", c_times},
	{"*=trap", c_trap},
	{"+=wait", c_wait},
	{"+read", c_read},
	{"test", c_test},
	{"+true", c_label},
	{"ulimit", c_ulimit},
	{"+umask", c_umask},
	{"*=unset", c_unset},
	{"suspend", c_suspend},
	{NULL, NULL}
};
@


1.58
log
@rename global "e" to genv to avoid accidental shadowing and aliasing.
ok millert nicm tb
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.57 2015/12/14 13:59:42 tb Exp $	*/
a828 56
#ifdef MKNOD
static int
c_mknod(char **wp)
{
	int argc, optc, ismkfifo = 0, ret;
	char **argv;
	void *set = NULL;
	mode_t mode = 0, oldmode = 0;

	while ((optc = ksh_getopt(wp, &builtin_opt, "m:")) != -1) {
		switch (optc) {
		case 'm':
			set = setmode(builtin_opt.optarg);
			if (set == NULL) {
				bi_errorf("invalid file mode");
				return 1;
			}
			mode = getmode(set, DEFFILEMODE);
			free(set);
			break;
		default:
			goto usage;
		}
	}
	argv = &wp[builtin_opt.optind];
	if (argv[0] == NULL)
		goto usage;
	for (argc = 0; argv[argc]; argc++)
		;
	if (argc == 2 && argv[1][0] == 'p') {
		ismkfifo = 1;
		argc--;
	} else if (argc != 4)
		goto usage;

	if (set)
		oldmode = umask(0);
	else
		mode = DEFFILEMODE;

	if (ismkfifo)
		ret = domkfifo(argc, argv, mode);
	else
		ret = domknod(argc, argv, mode);

	if (set)
		umask(oldmode);
	return ret;
usage:
	builtin_argv0 = NULL;
	bi_errorf("usage: mknod [-m mode] name b|c major minor");
	bi_errorf("usage: mknod [-m mode] name p");
	return 1;
}
#endif /* MKNOD */

a886 3
#ifdef MKNOD
	{"mknod", c_mknod},
#endif
@


1.57
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.56 2015/12/14 06:09:43 mmcc Exp $	*/
d33 1
a33 1
	struct block *l = e->loc;
d211 1
a211 1
		argv[0] = e->loc->argv[0]; /* preserve $0 */
d532 1
a532 1
		for (ep = e; ep; ep = ep->oenv)
d573 1
a573 1
	for (ep = e; ep && !STOP_BRKCONT(ep->type); ep = ep->oenv)
d608 1
a608 1
	struct block *l = e->loc;
d811 1
a811 1
	if (e->savefd != NULL) {
d813 2
a814 2
			if (e->savefd[i] > 0)
				close(e->savefd[i]);
d821 1
a821 1
			if (!Flag(FSH) && i > 2 && e->savefd[i])
d824 1
a824 1
		e->savefd = NULL;
@


1.56
log
@Remove a superfluous macro. No binary change. ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.55 2015/11/12 04:04:31 mmcc Exp $	*/
d12 4
d17 1
@


1.55
log
@Use isdigit() instead of ksh's homebrewed alternative.

ok nicm@@. Also discussed with millert@@ and guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.54 2015/11/01 15:38:53 mmcc Exp $	*/
d330 1
a330 1
				    shf_errno(shf) == EINTR) {
@


1.54
log
@Add uses of areallocarray(). mksh and Bitrig ksh already have similar
functions. With help from Theo Buehler.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.53 2015/10/21 15:20:37 mmcc Exp $	*/
d11 1
@


1.53
log
@Don't bother casting NULL.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.52 2015/10/19 14:42:16 mmcc Exp $	*/
d620 1
a620 1
		l->argv = alloc(sizeofN(char *, l->argc+2), &l->area);
@


1.52
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.51 2015/10/19 02:15:45 mmcc Exp $	*/
d661 1
a661 1
			define(id, (struct op *) NULL);
@


1.51
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.50 2015/10/10 00:10:07 deraadt Exp $	*/
d10 2
@


1.50
log
@ksh can run with pledge "stdio rpath wpath cpath getpw fattr proc exec tty"
if the mknod builtin is disabled.  It looks like a lot of abilities, but
hey, this is a shell.  can't open sockets or do other nasty stuff though.
(we'll leave the mknod builtin enabled on the install media for now; there
is work happening to regain the MAKEDEV performance in a different way)
discussions with otto & millert in particular
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.49 2015/09/18 07:28:24 nicm Exp $	*/
d7 1
a7 1
#include "sh.h"
d10 2
a11 1
#include <sys/resource.h>
@


1.49
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.48 2015/09/17 14:21:33 nicm Exp $	*/
d820 1
d874 1
d934 1
d936 1
@


1.48
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.47 2015/09/15 18:15:05 tedu Exp $	*/
d207 1
a207 1
		argv = (char **) 0;
d354 1
a354 1
						set_prompt(PS2, (Source *) 0);
d545 1
a545 1
	struct env *ep, *last_ep = (struct env *) 0;
@


1.47
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.46 2015/07/20 20:46:24 guenther Exp $	*/
d617 1
a617 1
		l->argv = (char **) alloc(sizeofN(char *, l->argc+2), &l->area);
@


1.46
log
@Zero-pad the seconds in the output of 'time' to make columns line up

ok pirofti@@ halex@@ krw@@ deraadt@@ jca@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.45 2014/08/27 08:26:04 jmc Exp $	*/
d226 2
a227 2
	if (*wp == (char *) 0) {
		while (waitfor((char *) 0, &sig) >= 0)
@


1.45
log
@promote "times" to posix special built-in;
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.44 2013/09/04 15:49:18 millert Exp $	*/
d671 1
a671 1
		shf_fprintf(shf, "%s%*lldm%lld.%02lds%s", prefix ? prefix : "",
@


1.44
log
@Add a proper suspend builtin that saves/restores the tty and pgrp
as needed instead of an alias that just sends SIGSTOP.  Login shells
may be suspended if they are not running in an orphan process group.
OK guenther@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.43 2013/04/19 17:39:45 deraadt Exp $	*/
d923 1
a923 1
	{"=times", c_times},
@


1.43
log
@handle long long time_t
ok millert tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.42 2013/03/20 21:05:00 millert Exp $	*/
d874 20
d933 1
@


1.42
log
@Remove bogus #if 0'd code.  As the comment says, POSIX doesn't need this.
OK martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.41 2010/03/27 09:10:01 jmc Exp $	*/
d668 2
a669 2
		shf_fprintf(shf, "%s%*ld.%02ld%s", prefix ? prefix : "",
		    width, tv->tv_sec, tv->tv_usec / 10000, suffix);
d671 3
a673 2
		shf_fprintf(shf, "%s%*ldm%ld.%02lds%s", prefix ? prefix : "",
		    width, tv->tv_sec / 60, tv->tv_sec % 60,
@


1.41
log
@`b' and `c' arguments to mknod are not optional; from LEVAI Daniel
c_sh.c part from sobrado;

ok millert guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.40 2009/05/05 17:59:55 millert Exp $	*/
a467 2
		int anydfl = 0;

d469 1
a469 3
			if (p->trap == NULL)
				anydfl = 1;
			else {
a474 12
#if 0 /* this is ugly and not clear POSIX needs it */
		/* POSIX may need this so output of trap can be saved and
		 * used to restore trap conditions
		 */
		if (anydfl) {
			shprintf("trap -- -");
			for (p = sigtraps, i = NSIG+1; --i >= 0; p++)
				if (p->trap == NULL && p->name)
					shprintf(" %s", p->name);
			shprintf(newline);
		}
#endif
@


1.40
log
@Fix usage string for mknod builtin.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.39 2009/01/29 23:27:26 jaredy Exp $	*/
d884 1
a884 1
	bi_errorf("usage: mknod [-m mode] name [b | c] major minor");
@


1.39
log
@pass "xerrok" status across the execution call stack to more closely
match what both POSIX and ksh.1 already describe in regards to set
-e/errexit's behavior in determining when to exit from nonzero return
values.

specifically, the truth values tested as operands to `&&' and `||', as
well as the resulting compound expression itself, along with the truth
value resulting from a negated command (i.e. a pipeline prefixed `!'),
should not make the shell exit when -e is in effect.

issue reported by matthieu.
testing matthieu, naddy.
ok miod (earlier version), otto.
man page ok jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.38 2008/07/23 16:34:38 jaredy Exp $	*/
d859 1
a859 1
	if (argv[0] == '\0')
d883 1
@


1.38
log
@fix stack abuse in the `time' commmand, using alloc()'d memory instead.

reported by Thorsten Glaser, thanks.

ok millert@@, earlier version miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.37 2007/09/03 13:54:23 otto Exp $	*/
d712 1
a712 1
timex(struct op *t, int f)
d737 1
a737 1
		rv = execute(t->left, f | XTIME);
@


1.37
log
@Unsetting a non-existent variable is not an error. See
http://www.opengroup.org/onlinepubs/009695399/utilities/unset.html
report from Arkadiusz Miskiewicz; fixed based on
http://cvs.pld-linux.org diff; ok millert@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.36 2007/08/02 10:50:25 fgsch Exp $	*/
a721 1
	char opts[1];
d737 1
d739 1
a739 4
			t->left->str = opts;
		opts[0] = 0;
		rv = execute(t->left, f | XTIME);
		tf |= opts[0];
@


1.36
log
@fix memory leaks and one potential null deref found by coverity. from netbsd.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.35 2006/04/10 14:38:59 jaredy Exp $	*/
a650 1
	int ret = 0;
a667 2
			if (!(vp->flag & ISSET))
			    ret = 1;
d674 1
a674 2
			if (define(id, (struct op *) NULL))
				ret = 1;
d676 1
a676 1
	return ret;
@


1.35
log
@fix lint comments, no functional changes; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.34 2006/03/21 09:00:23 otto Exp $	*/
d417 1
d451 3
a453 1
	return shell(s, false);
d601 2
a602 1
		last_ep->flags &= ~EF_BRKCONT_PASS;
@


1.34
log
@Partially revert last commit; jaredy@@ showed the NULL deref can't
happen and tedu@@ confirmed this is a known bug in Coverity's analysis.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.33 2006/03/20 20:54:08 otto Exp $	*/
d550 1
a550 1
	/*NOTREACHED*/
d604 1
a604 1
	/*NOTREACHED*/
@


1.33
log
@Fix potential null deref and out-of-bound access.
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.32 2006/03/12 00:26:58 deraadt Exp $	*/
d598 1
a598 2
		if (last_ep)
			last_ep->flags &= ~EF_BRKCONT_PASS;
@


1.32
log
@might as well make ksh_getopt() match real getopt(), ie. get rid of that
stupid EOF concept that was never true.  adobriyan@@gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.31 2005/10/08 18:07:31 otto Exp $	*/
d598 2
a599 1
		last_ep->flags &= ~EF_BRKCONT_PASS;
@


1.31
log
@Silence bogus gcc warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.30 2005/10/06 06:39:35 otto Exp $	*/
d61 1
a61 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "S")) != EOF)
d255 1
a255 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "prsu,")) != EOF)
d649 1
a649 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "fv")) != EOF)
d790 1
a790 1
	while ((optc = ksh_getopt(wp, &opt, ":p")) != EOF)
d846 1
a846 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "m:")) != EOF) {
@


1.30
log
@Introducing mknod as a built-in. It might be against the unix
philosophy, but in this case it's worth it. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.29 2005/03/30 17:16:37 deraadt Exp $	*/
d844 1
a844 1
	mode_t mode = 0, oldmode;
@


1.29
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.28 2005/02/02 07:53:01 otto Exp $	*/
d838 53
d929 1
@


1.28
log
@Introduce POSIX hex and octal (0x... and 0...) constants in arithmetic
expressions.  Work by Matthias Kilian, based on an old diff by myself.
Note: MAKEDEV should be updated. Tested by many, thanks.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.27 2004/12/28 21:11:21 jsg Exp $	*/
d63 1
a63 1
		  case 'S':
d66 1
a66 1
		  case '?':
d114 12
a125 4
					case 'a': positions |= 0111; break;
					case 'u': positions |= 0100; break;
					case 'g': positions |= 0010; break;
					case 'o': positions |= 0001; break;
d156 2
a157 2
					new_umask = new_val
					    | (new_umask & ~(positions * 07));
d257 1
a257 1
		  case 'p':
d263 1
a263 1
		  case 'r':
d266 1
a266 1
		  case 's':
d269 1
a269 1
		  case 'u':
d277 1
a277 1
		  case '?':
d325 2
a326 3
				if (c == EOF && shf_error(shf)
				    && shf_errno(shf) == EINTR)
				{
d377 2
a378 2
			while (Xlength(cs, cp) && ctype(cp[-1], C_IFS)
			       && ctype(cp[-1], C_IFSWS))
d524 5
a528 5
	    if (!getn(arg, &n)) {
		    exstat = 1;
		    warningf(true, "%s: bad number", arg);
	    } else
		    exstat = n;
d600 1
a600 1
			wp[0], wp[0], n - quit);
d651 1
a651 1
		  case 'f':
d654 1
a654 1
		  case 'v':
d657 1
a657 1
		  case '?':
d792 1
a792 1
		  case 'p':
d795 1
a795 1
		  case '?':
d797 1
a797 1
		  case ':':
d799 1
a799 1
				opt.optarg);
@


1.27
log
@ansi. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.26 2004/12/22 18:57:28 otto Exp $	*/
d34 1
a34 1
		evaluate(arg, &val, KSH_UNWIND_ERROR);
@


1.26
log
@Fix a use-after-free, that causs core dumps if a shell is killed
running with strict malloc.conf options. Problem spotted by hshoexer@@;
fix by me with some help from millert@@.

ok millert@@ hshoexer@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.25 2004/12/22 18:48:56 millert Exp $	*/
d673 2
a674 7
p_time(shf, posix, tv, width, prefix, suffix)
	struct shf *shf;
	int posix;
	struct timeval *tv;
	int width;
	char *prefix;
	char *suffix;
@


1.25
log
@Our times(3) just calls getrusage(2) and gettimeofday(2), converting seconds
to ticks.  Since ksh needs things in seconds it then converted them back.
Avoid the silliness and use the getrusage(2) and gettimeofday(2) directly.
With man page help from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.24 2004/12/22 17:14:34 millert Exp $	*/
d541 1
a541 1
	quitenv();	/* get rid of any i/o redirections */
@


1.24
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.23 2004/12/20 11:34:26 otto Exp $	*/
d8 3
a10 4
#include <sys/stat.h>	/* umask() */
#include <sys/times.h>

static	char *clocktos(clock_t);
d12 1
d672 18
d693 1
a693 1
	struct tms all;
d695 7
a701 5
	(void) times(&all);
	shprintf("Shell: %8ss user ", clocktos(all.tms_utime));
	shprintf("%8ss system\n", clocktos(all.tms_stime));
	shprintf("Kids:  %8ss user ", clocktos(all.tms_cutime));
	shprintf("%8ss system\n", clocktos(all.tms_cstime));
d716 2
a717 2
	struct tms t0, t1, tms;
	clock_t t0t, t1t = 0;
d719 1
a719 1
	extern clock_t j_usrtime, j_systime; /* computed by j_wait */
d722 3
a724 1
	t0t = times(&t0);
d734 2
a735 1
		j_usrtime = j_systime = 0;
d741 3
a743 1
		t1t = times(&t1);
d749 2
a750 2
		tms.tms_utime = t0.tms_utime + t0.tms_cutime;
		tms.tms_stime = t0.tms_stime + t0.tms_cstime;
d752 21
a772 12
		tms.tms_utime = t1.tms_utime - t0.tms_utime + j_usrtime;
		tms.tms_stime = t1.tms_stime - t0.tms_stime + j_systime;
	}

	if (!(tf & TF_NOREAL))
		shf_fprintf(shl_out,
			tf & TF_POSIX ? "real %8s\n" : "%8ss real ",
			clocktos(t1t - t0t));
	shf_fprintf(shl_out, tf & TF_POSIX ? "user %8s\n" : "%8ss user ",
		clocktos(tms.tms_utime));
	shf_fprintf(shl_out, tf & TF_POSIX ? "sys  %8s\n" : "%8ss system\n",
		clocktos(tms.tms_stime));
a808 24
}

static char *
clocktos(clock_t t)
{
	static char temp[22]; /* enough for 64 bit clock_t */
	int i;
	char *cp = temp + sizeof(temp);

	/* note: posix says must use max precision, ie, if clk_tck is
	 * 1000, must print 3 places after decimal (if non-zero, else 1).
	 */
	if (CLK_TCK != 100)	/* convert to 1/100'ths */
	    t = (t < 1000000000/CLK_TCK) ?
		    (t * 100) / CLK_TCK : (t / CLK_TCK) * 100;

	*--cp = '\0';
	for (i = -2; i <= 0 || t > 0; i++) {
		if (i == 0)
			*--cp = '.';
		*--cp = '0' + (char)(t%10);
		t /= 10;
	}
	return cp;
@


1.23
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.22 2004/12/19 01:58:04 millert Exp $	*/
d443 1
a443 1
	return shell(s, FALSE);
d489 1
a489 1
	s = (gettrap(*wp, FALSE) == NULL) ? *wp++ : NULL; /* get command */
d495 1
a495 1
		p = gettrap(*wp++, TRUE);
d519 1
a519 1
		    warningf(TRUE, "%s: bad number", arg);
d584 1
a584 1
			warningf(TRUE, "%s: cannot %s", wp[0], wp[0]);
d592 1
a592 1
		warningf(TRUE, "%s: can only %s %d level(s)",
@


1.22
log
@umask returns mode_t, not int
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.21 2004/12/18 22:35:41 millert Exp $	*/
d11 1
a11 1
static	char *clocktos(clock_t t);
d16 1
a16 2
c_label(wp)
	char **wp;
d22 1
a22 2
c_shift(wp)
	char **wp;
d53 1
a53 2
c_umask(wp)
	char **wp;
d172 1
a172 2
c_dot(wp)
	char **wp;
d210 1
a210 2
c_wait(wp)
	char **wp;
d232 1
a232 2
c_read(wp)
	char **wp;
d407 1
a407 2
c_eval(wp)
	char **wp;
d447 1
a447 2
c_trap(wp)
	char **wp;
d506 1
a506 2
c_exitreturn(wp)
	char **wp;
d548 1
a548 2
c_brkcont(wp)
	char **wp;
d601 1
a601 2
c_set(wp)
	char **wp;
d636 1
a636 2
c_unset(wp)
	char **wp;
d673 1
a673 2
c_times(wp)
	char **wp;
d690 1
a690 3
timex(t, f)
	struct op *t;
	int f;
d745 1
a745 3
timex_hook(t, app)
	struct op *t;
	char ** volatile *app;
d778 1
a778 2
clocktos(t)
	clock_t t;
d803 1
a803 2
c_exec(wp)
	char ** wp;
d828 1
a828 2
c_builtin(wp)
	char ** wp;
@


1.21
log
@Replace fd_clexec() with calls to fcntl(fd, F_SETFD, FD_CLOEXEC)
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.20 2004/12/18 21:25:44 millert Exp $	*/
d61 1
a61 1
	int old_umask;
d95 1
a95 1
		int new_umask;
@


1.20
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.19 2004/12/18 21:04:52 millert Exp $	*/
d838 1
a838 1
				fd_clexec(i);
@


1.19
log
@Get rid of #ifdef KSH since we don't care about building a V7 style sh and
the #ifdef KSH code is required to make a POSIX sh.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.18 2004/12/18 20:55:52 millert Exp $	*/
d26 2
a27 2
	register struct block *l = e->loc;
	register int n;
d58 2
a59 2
	register int i;
	register char *cp;
d240 1
a240 1
	register int c = 0;
d244 1
a244 1
	register char *cp;
d416 1
a416 1
	register struct source *s;
d459 1
a459 1
	register Trap *p;
d616 1
a616 1
	register char **owp = wp;
d650 1
a650 1
	register char *id;
d799 2
a800 2
	register int i;
	register char *cp = temp + sizeof(temp);
@


1.18
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.17 2003/03/13 09:03:07 deraadt Exp $	*/
a254 1
#ifdef KSH
a260 1
#endif /* KSH */
a299 1
#ifdef KSH
a309 1
#endif /* KSH */
a401 1
#ifdef KSH
a407 1
#endif /* KSH */
a836 1
#ifdef KSH
a838 1
#endif /* KSH */
@


1.17
log
@a few strcpy -> strlcpy; a couple people have mailed in a variety of
patches, and i already had this sitting on my laptop at that time.. i used
that as a chance to note that we had all done the same work, more or less
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.17 2003/03/13 08:51:21 deraadt Exp $	*/
d8 2
a9 3
#include "ksh_stat.h" 	/* umask() */
#include "ksh_time.h"
#include "ksh_times.h"
d11 1
a11 1
static	char *clocktos ARGS((clock_t t));
d217 1
a217 1
	int UNINITIALIZED(rv);
d251 1
a251 1
	char UNINITIALIZED(*xp);
d325 1
a325 5
				if (c == '\0'
#ifdef OS2
				    || c == '\r'
#endif /* OS2 */
				    )
d474 1
a474 1
		for (p = sigtraps, i = SIGNALS+1; --i >= 0; p++) {
d489 1
a489 1
			for (p = sigtraps, i = SIGNALS+1; --i >= 0; p++)
d696 1
a696 1
	(void) ksh_times(&all);
d723 1
a723 1
	t0t = ksh_times(&t0);
d739 1
a739 1
		t1t = ksh_times(&t1);
d861 2
a862 2
extern	int c_test ARGS((char **wp));		/* in c_test.c */
extern	int c_ulimit ARGS((char **wp));		/* in c_ulimit.c */
a891 8
#ifdef OS2
	/* In OS2, the first line of a file can be "extproc name", which
	 * tells the command interpreter (cmd.exe) to use name to execute
	 * the file.  For this to be useful, ksh must ignore commands
	 * starting with extproc and this does the trick...
	 */
	{"extproc", c_label},
#endif /* OS2 */
@


1.16
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.15 2003/01/04 22:36:07 deraadt Exp $	*/
d312 1
a312 1
	* coproc_readw_close(fd);
@


1.15
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.14 2002/06/09 05:47:27 todd Exp $	*/
d308 1
a308 1
	 * This is not compatiable with at&t ksh... the fd is kept so another
@


1.14
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.13 1999/07/14 13:37:23 millert Exp $	*/
d309 1
a309 1
	 * coproc can be started with same ouput, however, this means eof
@


1.13
log
@pdksh-5.2.14
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.12 1999/06/15 01:18:33 millert Exp $	*/
d606 1
a606 1
			return 0; 
d853 1
a853 1
		e->savefd = NULL; 
@


1.12
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.11 1999/01/10 17:55:02 millert Exp $	*/
d433 28
a460 9
	/*
	 * Handle case where command is empty due to failed
	 * command substitution, eg, eval "$(false)".
	 * In this case, shell() will not set/change exstat (cause
	 * compiled tree is empty), so will use this value.  subst_exstat
	 * is cleared in execute(), so should be 0 if there were no
	 * substitutions.
	 */
	exstat = subst_exstat;
d718 1
a718 1
#define TF_NONE		0
d721 1
a721 1
	int rv;
d723 2
a724 3
	clock_t t0t, t1t;
	clock_t real;
	int tf = TF_NONE;
d726 1
d739 5
a743 1
		rv = execute(t->left, f);
d745 4
a748 4
		real = t1t - t0t;
		tms.tms_utime = t1.tms_utime - t0.tms_utime + j_usrtime;
		tms.tms_stime = t1.tms_stime - t0.tms_stime + j_systime;
	} else { /* ksh93 - report shell times (shell+kids) */
a749 1
		real = 0;
d752 3
a754 1
		rv = 0;
d760 1
a760 1
			clocktos(real));
d763 1
a763 1
	shf_fprintf(shl_out, tf & TF_POSIX ? "user %8s\n" : "%8ss system\n",
d768 35
@


1.11
log
@sync with pdksh-unstable-5.2.13.6
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.9 1999/01/08 20:24:57 millert Exp $	*/
d37 1
a37 1
		evaluate(arg, &val, FALSE);
d390 1
d398 4
a401 1
		setstr(vp, Xstring(cs, cp)); /* SETSTR: fail */
a430 7
	/* XXX what is this?
	{
	    int i;
	    for (i = builtin_opt.optind; wp[i]; i++)
		shellf("eval[%s]\n", wp[i]);
	}
	*/
@


1.10
log
@Fix bug in c_sh.c where an unitialized variable could be used.
Bug found by fgsch@@openbsd.org.  Patch mailed to pdksh maintainer.
@
text
@d397 1
a397 1
		setstr(vp, Xstring(cs, cp));
d520 6
a525 6
	if (arg != NULL) {
		if (!getn(arg, &n)) {
			exstat = 1;
			warningf(TRUE, "%s: bad number", arg);
		} else
			exstat = n;
@


1.9
log
@bug fixes from pdksh-unstable-5.2.13.5; some of which we already had.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.8 1998/10/29 04:09:20 millert Exp $	*/
d520 7
a526 5
	if (arg != NULL && !getn(arg, &n)) {
		exstat = 1;
		warningf(TRUE, "%s: bad number", arg);
	} else
		exstat = n;
@


1.8
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.7 1998/06/25 19:01:46 millert Exp $	*/
d436 9
d487 6
a492 1
	s = (gettrap(*wp) == NULL) ? *wp++ : NULL; /* get command */
d498 1
a498 1
		p = gettrap(*wp++);
d513 1
d520 1
a520 1
	if (arg != NULL && !getn(arg, &exstat)) {
d523 2
a524 1
	}
@


1.7
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.6 1997/08/05 21:49:54 grr Exp $	*/
d427 7
@


1.6
log
@Fixes for a variety of pdksh problems:

1) pkksh in sh mode closed fd's other than [012] on exec'ing a command.
	this is a ksh'ism and POSIX sates that open files are part of the
	environment to be passed to the new process.

2) pdksh in sh mode interpets (( as meaning the start of arithmetic
	"quoting", which is incompatible with it's usage as a nested
	sub-shell invocation.  The $(( form for arithmetic substitution
	is stil valid, however.
	PR user/59 millert@@openbsd.org (Todd C. Miller)

3) pdksh sh.1 manpage isn't explicit about the range of input text
	that is subject to field splitting after a substitution.
	PR user/236 Mathieu.Herrb@@mipnet.fr (Mathiew Herrb)
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.5 1997/06/19 13:58:38 kstailey Exp $	*/
d14 1
d183 1
d190 1
a190 1
	file = search(cp, path, R_OK, (int *) 0);
d192 1
a192 1
		bi_errorf("%s: not found", cp);
d358 1
a358 1
					if (Flag(FTALKING) && isatty(fd)) {
d661 4
a664 4
	shprintf("Shell: %8s user ", clocktos(all.tms_utime));
	shprintf("%8s system\n", clocktos(all.tms_stime));
	shprintf("Kids:  %8s user ", clocktos(all.tms_cutime));
	shprintf("%8s system\n", clocktos(all.tms_cstime));
d677 3
d681 1
a681 1
	struct tms t0, t1;
d683 2
a686 1
	j_usrtime = j_systime = 0;
d688 32
a719 9
	rv = execute(t->left, f);
	t1t = ksh_times(&t1);

	shf_fprintf(shl_out, "%8s real ", clocktos(t1t - t0t));
	shf_fprintf(shl_out, "%8s user ",
	       clocktos(t1.tms_utime - t0.tms_utime + j_usrtime));
	shf_fprintf(shl_out, "%8s system ",
	       clocktos(t1.tms_stime - t0.tms_stime + j_systime));
	shf_fprintf(shl_out, newline);
d728 1
a728 1
	static char temp[20];
d732 3
a739 1
	*--cp = 's';
d761 7
a767 1
			/* keep anything > 2 private */
d770 1
@


1.5
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.3 1996/10/13 21:32:18 downsj Exp $	*/
d731 1
a731 1
			if (i > 2 && e->savefd[i])
@


1.4
log
@(foo *)0 -> NULL
@
text
@d188 1
a188 1
	file = search(cp, path, R_OK, NULL);
d202 1
a202 1
		argv = NULL;
d222 2
a223 2
	if (*wp == NULL) {
		while (waitfor(NULL, &sig) >= 0)
d360 1
a360 1
						set_prompt(PS2, NULL);
d529 1
a529 1
	struct env *ep, *last_ep = NULL;
d646 1
a646 1
			if (define(id, NULL))
@


1.3
log
@Update to version 5.2.11.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.2 1996/08/19 20:08:46 downsj Exp $	*/
d188 1
a188 1
	file = search(cp, path, R_OK, (int *) 0);
d202 1
a202 1
		argv = (char **) 0;
d222 2
a223 2
	if (*wp == (char *) 0) {
		while (waitfor((char *) 0, &sig) >= 0)
d360 1
a360 1
						set_prompt(PS2, (Source *) 0);
d529 1
a529 1
	struct env *ep, *last_ep = (struct env *) 0;
d646 1
a646 1
			if (define(id, (struct op *) NULL))
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: c_sh.c,v 1.1.1.1 1996/08/14 06:19:10 downsj Exp $	*/
d291 2
a292 2
		if (Flag(FTALKING)) {
			/* at&t says it prints prompt on fd if its open
d294 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d29 1
d31 6
a36 2
	if (wp[1]) {
		evaluate(wp[1], &val, FALSE);
d41 1
a41 1
		bi_errorf("%s: bad number", wp[1]);
d183 4
a186 1
	if ((cp = wp[1]) == NULL)
d188 1
a188 1
	file = search(cp, path, R_OK);
d195 2
a196 2
	if (wp[2]) {
		argv = ++wp;
d198 1
a198 1
		for (argc = -1; *wp++; argc++)
d256 1
a256 1
			if ((fd = get_coproc_fd(R_OK, &emsg)) < 0) {
d301 8
a308 1
	 * make sure the other side of the pipe is closed first.
a309 1
	coproc_readw_close(fd);
d404 4
a407 1
	/* if this is the co-process fd, close the file descriptor */
d421 2
d424 1
a424 1
	s->u.strv = wp+1;
d488 1
d490 5
a494 1
	if (wp[1] != NULL && !getn(wp[1], &exstat)) {
d496 1
a496 1
		warningf(TRUE, "%s: bad number", wp[1]);
d528 5
d534 1
a534 1
	if (!wp[1])
d536 1
a536 1
	else if (!bi_getn(wp[1], &n))
d541 1
a541 1
		bi_errorf("bad option `%s'", wp[1]);
d618 1
d636 2
d643 5
a647 3
		} else			/* unset function */
			define(id, (struct op *)NULL);
	return 0;
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
