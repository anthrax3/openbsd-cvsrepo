head	1.23;
access;
symbols
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.15.0.16
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.8
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.12
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.10
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.6
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.4
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.13.0.12
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.10
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.12
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.10
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.8
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.6
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.5.0.24
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.22
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.20
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.18
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.16
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.14
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.12
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.10
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.8
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.6
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2015.11.01.15.38.53;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	Fr9nr0FBz2YkAWdK;

1.22
date	2015.10.19.14.43.46;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	SxE6uiB4h4Bylypi;

1.21
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	C4W85jmosThChWA2;

1.20
date	2015.10.19.14.03.21;	author mmcc;	state Exp;
branches;
next	1.19;
commitid	TSZF0K3aGmPbKQzz;

1.19
date	2015.10.05.23.26.58;	author nicm;	state Exp;
branches;
next	1.18;
commitid	oq5rpqwKzYLQ6xxa;

1.18
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.17;
commitid	7fgq4YTZG4xZ0uN0;

1.17
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.16;
commitid	v5QjoxUgKU2iUTFz;

1.16
date	2015.09.01.13.12.31;	author tedu;	state Exp;
branches;
next	1.15;
commitid	sKGEDet4KOfGjsIb;

1.15
date	2012.02.19.07.52.30;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2012.02.02.08.42.46;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.17.22.06.44;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.11.20.31.21;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.28.21.28.22;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.19.04.14.20;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.01.10.17.55.03;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.06.19.13.58.47;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.06.18.22.42.45;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.59;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Add uses of areallocarray(). mksh and Bitrig ksh already have similar
functions. With help from Theo Buehler.

ok nicm@@
@
text
@/*	$OpenBSD: table.c,v 1.22 2015/10/19 14:43:46 mmcc Exp $	*/

/*
 * dynamic hashed associative table for commands and variables
 */

#include <limits.h>
#include <stddef.h>
#include <string.h>

#include "sh.h"

#define	INIT_TBLS	8	/* initial table size (power of 2) */

struct table taliases;	/* tracked aliases */
struct table builtins;	/* built-in commands */
struct table aliases;	/* aliases */
struct table keywords;	/* keywords */
struct table homedirs;	/* homedir() cache */

char *path;		/* copy of either PATH or def_path */
const char *def_path;	/* path to use if PATH not set */
char *tmpdir;		/* TMPDIR value */
const char *prompt;
int cur_prompt;		/* PS1 or PS2 */
int current_lineno;	/* LINENO value */

static void	texpand(struct table *, int);
static int	tnamecmp(const void *, const void *);


unsigned int
hash(const char *n)
{
	unsigned int h = 0;

	while (*n != '\0')
		h = 33*h + (unsigned char)(*n++);
	return h;
}

void
ktinit(struct table *tp, Area *ap, int tsize)
{
	tp->areap = ap;
	tp->tbls = NULL;
	tp->size = tp->nfree = 0;
	if (tsize)
		texpand(tp, tsize);
}

static void
texpand(struct table *tp, int nsize)
{
	int i;
	struct tbl *tblp, **p;
	struct tbl **ntblp, **otblp = tp->tbls;
	int osize = tp->size;

	ntblp = areallocarray(NULL, nsize, sizeof(struct tbl *), tp->areap);
	for (i = 0; i < nsize; i++)
		ntblp[i] = NULL;
	tp->size = nsize;
	tp->nfree = 7*nsize/10;	/* table can get 70% full */
	tp->tbls = ntblp;
	if (otblp == NULL)
		return;
	for (i = 0; i < osize; i++)
		if ((tblp = otblp[i]) != NULL) {
			if ((tblp->flag&DEFINED)) {
				for (p = &ntblp[hash(tblp->name) &
				    (tp->size-1)]; *p != NULL; p--)
					if (p == ntblp) /* wrap */
						p += tp->size;
				*p = tblp;
				tp->nfree--;
			} else if (!(tblp->flag & FINUSE)) {
				afree(tblp, tp->areap);
			}
		}
	afree(otblp, tp->areap);
}

/* table */
/* name to enter */
/* hash(n) */
struct tbl *
ktsearch(struct table *tp, const char *n, unsigned int h)
{
	struct tbl **pp, *p;

	if (tp->size == 0)
		return NULL;

	/* search for name in hashed table */
	for (pp = &tp->tbls[h & (tp->size-1)]; (p = *pp) != NULL; pp--) {
		if (*p->name == *n && strcmp(p->name, n) == 0 &&
		    (p->flag&DEFINED))
			return p;
		if (pp == tp->tbls) /* wrap */
			pp += tp->size;
	}

	return NULL;
}

/* table */
/* name to enter */
/* hash(n) */
struct tbl *
ktenter(struct table *tp, const char *n, unsigned int h)
{
	struct tbl **pp, *p;
	int len;

	if (tp->size == 0)
		texpand(tp, INIT_TBLS);
  Search:
	/* search for name in hashed table */
	for (pp = &tp->tbls[h & (tp->size-1)]; (p = *pp) != NULL; pp--) {
		if (*p->name == *n && strcmp(p->name, n) == 0)
			return p;	/* found */
		if (pp == tp->tbls) /* wrap */
			pp += tp->size;
	}

	if (tp->nfree <= 0) {	/* too full */
		if (tp->size <= INT_MAX/2)
			texpand(tp, 2*tp->size);
		else
			internal_errorf(1, "too many vars");
		goto Search;
	}

	/* create new tbl entry */
	len = strlen(n) + 1;
	p = alloc(offsetof(struct tbl, name[0]) + len,
				 tp->areap);
	p->flag = 0;
	p->type = 0;
	p->areap = tp->areap;
	p->u2.field = 0;
	p->u.array = NULL;
	memcpy(p->name, n, len);

	/* enter in tp->tbls */
	tp->nfree--;
	*pp = p;
	return p;
}

void
ktdelete(struct tbl *p)
{
	p->flag = 0;
}

void
ktwalk(struct tstate *ts, struct table *tp)
{
	ts->left = tp->size;
	ts->next = tp->tbls;
}

struct tbl *
ktnext(struct tstate *ts)
{
	while (--ts->left >= 0) {
		struct tbl *p = *ts->next++;
		if (p != NULL && (p->flag&DEFINED))
			return p;
	}
	return NULL;
}

static int
tnamecmp(const void *p1, const void *p2)
{
	char *name1 = (*(struct tbl **)p1)->name;
	char *name2 = (*(struct tbl **)p2)->name;
	return strcmp(name1, name2);
}

struct tbl **
ktsort(struct table *tp)
{
	int i;
	struct tbl **p, **sp, **dp;

	p = areallocarray(NULL, tp->size + 1,
	    sizeof(struct tbl *), ATEMP);
	sp = tp->tbls;		/* source */
	dp = p;			/* dest */
	for (i = 0; i < tp->size; i++)
		if ((*dp = *sp++) != NULL && (((*dp)->flag&DEFINED) ||
		    ((*dp)->flag&ARRAY)))
			dp++;
	i = dp - p;
	qsortp((void**)p, (size_t)i, tnamecmp);
	p[i] = NULL;
	return p;
}

#ifdef PERF_DEBUG /* performance debugging */

void tprintinfo(struct table *tp);

void
tprintinfo(struct table *tp)
{
	struct tbl *te;
	char *n;
	unsigned int h;
	int ncmp;
	int totncmp = 0, maxncmp = 0;
	int nentries = 0;
	struct tstate ts;

	shellf("table size %d, nfree %d\n", tp->size, tp->nfree);
	shellf("    Ncmp name\n");
	ktwalk(&ts, tp);
	while ((te = ktnext(&ts))) {
		struct tbl **pp, *p;

		h = hash(n = te->name);
		ncmp = 0;

		/* taken from ktsearch() and added counter */
		for (pp = &tp->tbls[h & (tp->size-1)]; (p = *pp); pp--) {
			ncmp++;
			if (*p->name == *n && strcmp(p->name, n) == 0 &&
			    (p->flag&DEFINED))
				break; /* return p; */
			if (pp == tp->tbls) /* wrap */
				pp += tp->size;
		}
		shellf("    %4d %s\n", ncmp, n);
		totncmp += ncmp;
		nentries++;
		if (ncmp > maxncmp)
			maxncmp = ncmp;
	}
	if (nentries)
		shellf("  %d entries, worst ncmp %d, avg ncmp %d.%02d\n",
		    nentries, maxncmp,
		    totncmp / nentries,
		    (totncmp % nentries) * 100 / nentries);
}
#endif /* PERF_DEBUG */
@


1.22
log
@Move stddef.h include from sh.h to the file that uses it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.21 2015/10/19 14:42:16 mmcc Exp $	*/
d60 1
a60 1
	ntblp = alloc(sizeofN(struct tbl *, nsize), tp->areap);
d190 2
a191 1
	p = alloc(sizeofN(struct tbl *, tp->size+1), ATEMP);
@


1.21
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.20 2015/10/19 14:03:21 mmcc Exp $	*/
d8 1
@


1.20
log
@Move limits.h include from sh.h to the files that actually need it. No
binary change.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.19 2015/10/05 23:26:58 nicm Exp $	*/
d8 1
@


1.19
log
@Remove EXTERN from table.h and put the definitions in table.c, from
Michael McConville.
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.18 2015/09/18 07:28:24 nicm Exp $	*/
d6 2
@


1.18
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.17 2015/09/17 14:21:33 nicm Exp $	*/
d10 13
@


1.17
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.16 2015/09/01 13:12:31 tedu Exp $	*/
d126 1
a126 1
	p->u.array = (struct tbl *)0;
@


1.16
log
@remove casts and null checks before free. from Michael McConville
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.15 2012/02/19 07:52:30 otto Exp $	*/
d43 1
a43 1
	ntblp = (struct tbl**) alloc(sizeofN(struct tbl *, nsize), tp->areap);
d120 1
a120 1
	p = (struct tbl *) alloc(offsetof(struct tbl, name[0]) + len,
d173 1
a173 1
	p = (struct tbl **)alloc(sizeofN(struct tbl *, tp->size+1), ATEMP);
@


1.15
log
@Allow for more vars in hash table, improve hash function, increase
hash table size sooner. Based on suggestion from Michael Niedermayer.
ok krw@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.14 2012/02/02 08:42:46 otto Exp $	*/
d61 1
a61 1
				afree((void*)tblp, tp->areap);
d64 1
a64 1
	afree((void*)otblp, tp->areap);
@


1.14
log
@bound chaeck table expansion; problem seen by Michael Niedermayer;
ok deraadt@@ kili@@
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.14 2012/02/02 08:41:03 otto Exp $	*/
d21 2
a22 2
		h = 2*h + *n++;
	return h * 32821;	/* scatter bits */
d47 1
a47 1
	tp->nfree = 8*nsize/10;	/* table can get 80% full */
d111 1
a111 1
		if (tp->size <= SHRT_MAX/2)
@


1.13
log
@Use libc qsort instead of private version.  Tested by several people.
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.12 2005/12/11 20:31:21 otto Exp $	*/
d111 4
a114 1
		texpand(tp, 2*tp->size);
@


1.12
log
@fix a few name clashes with libc; found by lint. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.11 2005/03/30 17:16:37 deraadt Exp $	*/
d12 1
a12 1
static int	tnamecmp(void *, void *);
d157 1
a157 1
tnamecmp(void *p1, void *p2)
d159 3
a161 1
	return strcmp(((struct tbl *)p1)->name, ((struct tbl *)p2)->name);
@


1.11
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.10 2005/03/28 21:28:22 deraadt Exp $	*/
d26 1
a26 1
tinit(struct table *tp, Area *ap, int tsize)
d71 1
a71 1
tsearch(struct table *tp, const char *n, unsigned int h)
d94 1
a94 1
tenter(struct table *tp, const char *n, unsigned int h)
d133 1
a133 1
tdelete(struct tbl *p)
d139 1
a139 1
twalk(struct tstate *ts, struct table *tp)
d146 1
a146 1
tnext(struct tstate *ts)
d163 1
a163 1
tsort(struct table *tp)
d198 2
a199 2
	twalk(&ts, tp);
	while ((te = tnext(&ts))) {
d205 1
a205 1
		/* taken from tsearch() and added counter */
@


1.10
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.9 2004/12/20 11:34:26 otto Exp $	*/
d11 2
a12 2
static void     texpand(struct table *, int);
static int      tnamecmp(void *, void *);
d54 2
a55 3
				for (p = &ntblp[hash(tblp->name)
					  & (tp->size-1)];
				     *p != NULL; p--)
d80 2
a81 2
		if (*p->name == *n && strcmp(p->name, n) == 0
		    && (p->flag&DEFINED))
d173 1
a173 1
					      ((*dp)->flag&ARRAY)))
d208 2
a209 2
			if (*p->name == *n && strcmp(p->name, n) == 0
			    && (p->flag&DEFINED))
d222 3
a224 3
			nentries, maxncmp,
			totncmp / nentries,
			(totncmp % nentries) * 100 / nentries);
@


1.9
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.8 2004/12/19 04:14:20 deraadt Exp $	*/
d68 3
a72 3
	                 	/* table */
	              		/* name to enter */
	               		/* hash(n) */
d91 3
a95 3
	                 	/* table */
	              		/* name to enter */
	               		/* hash(n) */
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.7 2004/12/18 21:25:44 millert Exp $	*/
d11 2
a12 2
static void     texpand(struct table *tp, int nsize);
static int      tnamecmp(void *p1, void *p2);
d16 1
a16 2
hash(n)
	const char * n;
d26 1
a26 4
tinit(tp, ap, tsize)
	struct table *tp;
	Area *ap;
	int tsize;
d36 1
a36 3
texpand(tp, nsize)
	struct table *tp;
	int nsize;
d69 4
a72 4
tsearch(tp, n, h)
	struct table *tp;	/* table */
	const char *n;		/* name to enter */
	unsigned int h;		/* hash(n) */
d92 4
a95 4
tenter(tp, n, h)
	struct table *tp;	/* table */
	const char *n;		/* name to enter */
	unsigned int h;		/* hash(n) */
d134 1
a134 2
tdelete(p)
	struct tbl *p;
d140 1
a140 3
twalk(ts, tp)
	struct tstate *ts;
	struct table *tp;
d147 1
a147 2
tnext(ts)
	struct tstate *ts;
d158 1
a158 2
tnamecmp(p1, p2)
	void *p1, *p2;
d164 1
a164 2
tsort(tp)
	struct table *tp;
d187 1
a187 2
tprintinfo(tp)
	struct table *tp;
@


1.7
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.6 2004/12/18 20:55:52 millert Exp $	*/
d112 1
a112 1
			return p; 	/* found */
@


1.6
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.5 1999/01/10 17:55:03 millert Exp $	*/
d17 1
a17 1
	register const char * n;
d19 1
a19 1
	register unsigned int h = 0;
d28 2
a29 2
	register struct table *tp;
	register Area *ap;
d41 1
a41 1
	register struct table *tp;
d44 3
a46 3
	register int i;
	register struct tbl *tblp, **p;
	register struct tbl **ntblp, **otblp = tp->tbls;
d76 3
a78 3
	register struct table *tp;	/* table */
	register const char *n;		/* name to enter */
	unsigned int h;			/* hash(n) */
d80 1
a80 1
	register struct tbl **pp, *p;
d99 3
a101 3
	register struct table *tp;	/* table */
	register const char *n;		/* name to enter */
	unsigned int h;			/* hash(n) */
d103 2
a104 2
	register struct tbl **pp, *p;
	register int len;
d141 1
a141 1
	register struct tbl *p;
d176 1
a176 1
	register struct table *tp;
d178 2
a179 2
	register int i;
	register struct tbl **p, **sp, **dp;
d214 1
a214 1
		register struct tbl **pp, *p;
@


1.5
log
@sync with pdksh-unstable-5.2.13.6
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.4 1997/06/19 13:58:47 kstailey Exp $	*/
d11 2
a12 2
static void     texpand     ARGS((struct table *tp, int nsize));
static int      tnamecmp    ARGS((void *p1, void *p2));
d196 1
a196 1
void tprintinfo ARGS((struct table *tp));
@


1.4
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.2 1996/08/19 20:08:59 downsj Exp $	*/
d58 1
a58 1
		if ((tblp = otblp[i]) != NULL)
d70 1
@


1.3
log
@(foo *)0 -> NULL
@
text
@d129 1
a129 1
	p->u.array = NULL;
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
d129 1
a129 1
	p->u.array = (struct tbl *)0;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 1
a67 1
			} else {
d128 1
a128 1
	p->field = 0;
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
