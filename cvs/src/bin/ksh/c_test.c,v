head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.8
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.18.0.28
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.20
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.24
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.22
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.18
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.16
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.14
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.12
	OPENBSD_5_0:1.18.0.10
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.8
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.6
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.17.0.16
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.14
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.12
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.10
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.8
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.6
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.4
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.12
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.10
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.22;
commitid	btTCreDA00YdaFhU;

1.22
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	C4W85jmosThChWA2;

1.21
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	16HUr75moyUNtKR8;

1.20
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.19;
commitid	7fgq4YTZG4xZ0uN0;

1.19
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.18;
commitid	lBs9un9sXhbdfVrQ;

1.18
date	2009.03.01.20.11.06;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.28.21.33.04;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.02.07.53.01;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.18.21.04.52;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.10.19.09.07;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.7;

1.7
date	99.07.14.13.37.23;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.06.15.01.18.33;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.06.25.19.01.47;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.06.19.13.58.38;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.06.18.22.42.29;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.47;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.10;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.10;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@/*	$OpenBSD: c_test.c,v 1.22 2015/10/19 14:42:16 mmcc Exp $	*/

/*
 * test(1); version 7-like  --  author Erik Baalbergen
 * modified by Eric Gisin to be used as built-in.
 * modified by Arnold Robbins to add SVR3 compatibility
 * (-x -c -b -p -u -g -k) plus Korn's -L -nt -ot -ef and new -S (socket).
 * modified by Michael Rendell to add Korn's [[ .. ]] expressions.
 * modified by J.T. Conklin to add POSIX compatibility.
 */

#include <sys/stat.h>

#include <string.h>
#include <unistd.h>

#include "sh.h"
#include "c_test.h"

/* test(1) accepts the following grammar:
	oexpr	::= aexpr | aexpr "-o" oexpr ;
	aexpr	::= nexpr | nexpr "-a" aexpr ;
	nexpr	::= primary | "!" nexpr ;
	primary	::= unary-operator operand
		| operand binary-operator operand
		| operand
		| "(" oexpr ")"
		;

	unary-operator ::= "-a"|"-r"|"-w"|"-x"|"-e"|"-f"|"-d"|"-c"|"-b"|"-p"|
			   "-u"|"-g"|"-k"|"-s"|"-t"|"-z"|"-n"|"-o"|"-O"|"-G"|
			   "-L"|"-h"|"-S"|"-H";

	binary-operator ::= "="|"=="|"!="|"-eq"|"-ne"|"-ge"|"-gt"|"-le"|"-lt"|
			    "-nt"|"-ot"|"-ef"|
			    "<"|">"	# rules used for [[ .. ]] expressions
			    ;
	operand ::= <any thing>
*/

#define T_ERR_EXIT	2	/* POSIX says > 1 for errors */

struct t_op {
	char	op_text[4];
	Test_op	op_num;
};
static const struct t_op u_ops [] = {
	{"-a",	TO_FILAXST },
	{"-b",	TO_FILBDEV },
	{"-c",	TO_FILCDEV },
	{"-d",	TO_FILID },
	{"-e",	TO_FILEXST },
	{"-f",	TO_FILREG },
	{"-G",	TO_FILGID },
	{"-g",	TO_FILSETG },
	{"-h",	TO_FILSYM },
	{"-H",	TO_FILCDF },
	{"-k",	TO_FILSTCK },
	{"-L",	TO_FILSYM },
	{"-n",	TO_STNZE },
	{"-O",	TO_FILUID },
	{"-o",	TO_OPTION },
	{"-p",	TO_FILFIFO },
	{"-r",	TO_FILRD },
	{"-s",	TO_FILGZ },
	{"-S",	TO_FILSOCK },
	{"-t",	TO_FILTT },
	{"-u",	TO_FILSETU },
	{"-w",	TO_FILWR },
	{"-x",	TO_FILEX },
	{"-z",	TO_STZER },
	{"",	TO_NONOP }
};
static const struct t_op b_ops [] = {
	{"=",	TO_STEQL },
	{"==",	TO_STEQL },
	{"!=",	TO_STNEQ },
	{"<",	TO_STLT },
	{">",	TO_STGT },
	{"-eq",	TO_INTEQ },
	{"-ne",	TO_INTNE },
	{"-gt",	TO_INTGT },
	{"-ge",	TO_INTGE },
	{"-lt",	TO_INTLT },
	{"-le",	TO_INTLE },
	{"-ef",	TO_FILEQ },
	{"-nt",	TO_FILNT },
	{"-ot",	TO_FILOT },
	{"",	TO_NONOP }
};

static int	test_stat(const char *, struct stat *);
static int	test_eaccess(const char *, int);
static int	test_oexpr(Test_env *, int);
static int	test_aexpr(Test_env *, int);
static int	test_nexpr(Test_env *, int);
static int	test_primary(Test_env *, int);
static int	ptest_isa(Test_env *, Test_meta);
static const char *ptest_getopnd(Test_env *, Test_op, int);
static int	ptest_eval(Test_env *, Test_op, const char *,
		    const char *, int);
static void	ptest_error(Test_env *, int, const char *);

int
c_test(char **wp)
{
	int argc;
	int res;
	Test_env te;

	te.flags = 0;
	te.isa = ptest_isa;
	te.getopnd = ptest_getopnd;
	te.eval = ptest_eval;
	te.error = ptest_error;

	for (argc = 0; wp[argc]; argc++)
		;

	if (strcmp(wp[0], "[") == 0) {
		if (strcmp(wp[--argc], "]") != 0) {
			bi_errorf("missing ]");
			return T_ERR_EXIT;
		}
	}

	te.pos.wp = wp + 1;
	te.wp_end = wp + argc;

	/*
	 * Handle the special cases from POSIX.2, section 4.62.4.
	 * Implementation of all the rules isn't necessary since
	 * our parser does the right thing for the omitted steps.
	 */
	if (argc <= 5) {
		char **owp = wp;
		int invert = 0;
		Test_op	op;
		const char *opnd1, *opnd2;

		while (--argc >= 0) {
			if ((*te.isa)(&te, TM_END))
				return !0;
			if (argc == 3) {
				opnd1 = (*te.getopnd)(&te, TO_NONOP, 1);
				if ((op = (Test_op) (*te.isa)(&te, TM_BINOP))) {
					opnd2 = (*te.getopnd)(&te, op, 1);
					res = (*te.eval)(&te, op, opnd1,
					    opnd2, 1);
					if (te.flags & TEF_ERROR)
						return T_ERR_EXIT;
					if (invert & 1)
						res = !res;
					return !res;
				}
				/* back up to opnd1 */
				te.pos.wp--;
			}
			if (argc == 1) {
				opnd1 = (*te.getopnd)(&te, TO_NONOP, 1);
				/* Historically, -t by itself test if fd 1
				 * is a file descriptor, but POSIX says its
				 * a string test...
				 */
				if (!Flag(FPOSIX) && strcmp(opnd1, "-t") == 0)
				    break;
				res = (*te.eval)(&te, TO_STNZE, opnd1,
				    NULL, 1);
				if (invert & 1)
					res = !res;
				return !res;
			}
			if ((*te.isa)(&te, TM_NOT)) {
				invert++;
			} else
				break;
		}
		te.pos.wp = owp + 1;
	}

	return test_parse(&te);
}

/*
 * Generic test routines.
 */

Test_op
test_isop(Test_env *te, Test_meta meta, const char *s)
{
	char sc1;
	const struct t_op *otab;

	otab = meta == TM_UNOP ? u_ops : b_ops;
	if (*s) {
		sc1 = s[1];
		for (; otab->op_text[0]; otab++)
			if (sc1 == otab->op_text[1] &&
			    strcmp(s, otab->op_text) == 0 &&
			    ((te->flags & TEF_DBRACKET) ||
			    (otab->op_num != TO_STLT && otab->op_num != TO_STGT)))
				return otab->op_num;
	}
	return TO_NONOP;
}

int
test_eval(Test_env *te, Test_op op, const char *opnd1, const char *opnd2,
    int do_eval)
{
	int res;
	int not;
	struct stat b1, b2;

	if (!do_eval)
		return 0;

	switch ((int) op) {
	/*
	 * Unary Operators
	 */
	case TO_STNZE: /* -n */
		return *opnd1 != '\0';
	case TO_STZER: /* -z */
		return *opnd1 == '\0';
	case TO_OPTION: /* -o */
		if ((not = *opnd1 == '!'))
			opnd1++;
		if ((res = option(opnd1)) < 0)
			res = 0;
		else {
			res = Flag(res);
			if (not)
				res = !res;
		}
		return res;
	case TO_FILRD: /* -r */
		return test_eaccess(opnd1, R_OK) == 0;
	case TO_FILWR: /* -w */
		return test_eaccess(opnd1, W_OK) == 0;
	case TO_FILEX: /* -x */
		return test_eaccess(opnd1, X_OK) == 0;
	case TO_FILAXST: /* -a */
		return test_stat(opnd1, &b1) == 0;
	case TO_FILEXST: /* -e */
		/* at&t ksh does not appear to do the /dev/fd/ thing for
		 * this (unless the os itself handles it)
		 */
		return stat(opnd1, &b1) == 0;
	case TO_FILREG: /* -r */
		return test_stat(opnd1, &b1) == 0 && S_ISREG(b1.st_mode);
	case TO_FILID: /* -d */
		return test_stat(opnd1, &b1) == 0 && S_ISDIR(b1.st_mode);
	case TO_FILCDEV: /* -c */
		return test_stat(opnd1, &b1) == 0 && S_ISCHR(b1.st_mode);
	case TO_FILBDEV: /* -b */
		return test_stat(opnd1, &b1) == 0 && S_ISBLK(b1.st_mode);
	case TO_FILFIFO: /* -p */
		return test_stat(opnd1, &b1) == 0 && S_ISFIFO(b1.st_mode);
	case TO_FILSYM: /* -h -L */
		return lstat(opnd1, &b1) == 0 && S_ISLNK(b1.st_mode);
	case TO_FILSOCK: /* -S */
		return test_stat(opnd1, &b1) == 0 && S_ISSOCK(b1.st_mode);
	case TO_FILCDF:/* -H HP context dependent files (directories) */
		return 0;
	case TO_FILSETU: /* -u */
		return test_stat(opnd1, &b1) == 0 &&
		    (b1.st_mode & S_ISUID) == S_ISUID;
	case TO_FILSETG: /* -g */
		return test_stat(opnd1, &b1) == 0 &&
		    (b1.st_mode & S_ISGID) == S_ISGID;
	case TO_FILSTCK: /* -k */
		return test_stat(opnd1, &b1) == 0 &&
		    (b1.st_mode & S_ISVTX) == S_ISVTX;
	case TO_FILGZ: /* -s */
		return test_stat(opnd1, &b1) == 0 && b1.st_size > 0L;
	case TO_FILTT: /* -t */
		if (opnd1 && !bi_getn(opnd1, &res)) {
			te->flags |= TEF_ERROR;
			res = 0;
		} else {
			/* generate error if in FPOSIX mode? */
			res = isatty(opnd1 ? res : 0);
		}
		return res;
	case TO_FILUID: /* -O */
		return test_stat(opnd1, &b1) == 0 && b1.st_uid == ksheuid;
	case TO_FILGID: /* -G */
		return test_stat(opnd1, &b1) == 0 && b1.st_gid == getegid();
	/*
	 * Binary Operators
	 */
	case TO_STEQL: /* = */
		if (te->flags & TEF_DBRACKET)
			return gmatch(opnd1, opnd2, false);
		return strcmp(opnd1, opnd2) == 0;
	case TO_STNEQ: /* != */
		if (te->flags & TEF_DBRACKET)
			return !gmatch(opnd1, opnd2, false);
		return strcmp(opnd1, opnd2) != 0;
	case TO_STLT: /* < */
		return strcmp(opnd1, opnd2) < 0;
	case TO_STGT: /* > */
		return strcmp(opnd1, opnd2) > 0;
	case TO_INTEQ: /* -eq */
	case TO_INTNE: /* -ne */
	case TO_INTGE: /* -ge */
	case TO_INTGT: /* -gt */
	case TO_INTLE: /* -le */
	case TO_INTLT: /* -lt */
		{
			long v1, v2;

			if (!evaluate(opnd1, &v1, KSH_RETURN_ERROR, false) ||
			    !evaluate(opnd2, &v2, KSH_RETURN_ERROR, false)) {
				/* error already printed.. */
				te->flags |= TEF_ERROR;
				return 1;
			}
			switch ((int) op) {
			case TO_INTEQ:
				return v1 == v2;
			case TO_INTNE:
				return v1 != v2;
			case TO_INTGE:
				return v1 >= v2;
			case TO_INTGT:
				return v1 > v2;
			case TO_INTLE:
				return v1 <= v2;
			case TO_INTLT:
				return v1 < v2;
			}
		}
	case TO_FILNT: /* -nt */
		{
			int s2;
			/* ksh88/ksh93 succeed if file2 can't be stated
			 * (subtly different from `does not exist').
			 */
			return stat(opnd1, &b1) == 0 &&
			    (((s2 = stat(opnd2, &b2)) == 0 &&
			    b1.st_mtime > b2.st_mtime) || s2 < 0);
		}
	case TO_FILOT: /* -ot */
		{
			int s1;
			/* ksh88/ksh93 succeed if file1 can't be stated
			 * (subtly different from `does not exist').
			 */
			return stat(opnd2, &b2) == 0 &&
			    (((s1 = stat(opnd1, &b1)) == 0 &&
			    b1.st_mtime < b2.st_mtime) || s1 < 0);
		}
	case TO_FILEQ: /* -ef */
		return stat (opnd1, &b1) == 0 && stat (opnd2, &b2) == 0 &&
		    b1.st_dev == b2.st_dev && b1.st_ino == b2.st_ino;
	}
	(*te->error)(te, 0, "internal error: unknown op");
	return 1;
}

/* Nasty kludge to handle Korn's bizarre /dev/fd hack */
static int
test_stat(const char *path, struct stat *statb)
{
	return stat(path, statb);
}

/* Routine to handle Korn's /dev/fd hack, and to deal with X_OK on
 * non-directories when running as root.
 */
static int
test_eaccess(const char *path, int mode)
{
	int res;

	res = access(path, mode);
	/*
	 * On most (all?) unixes, access() says everything is executable for
	 * root - avoid this on files by using stat().
	 */
	if (res == 0 && ksheuid == 0 && (mode & X_OK)) {
		struct stat statb;

		if (stat(path, &statb) < 0)
			res = -1;
		else if (S_ISDIR(statb.st_mode))
			res = 0;
		else
			res = (statb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) ?
			    0 : -1;
	}

	return res;
}

int
test_parse(Test_env *te)
{
	int res;

	res = test_oexpr(te, 1);

	if (!(te->flags & TEF_ERROR) && !(*te->isa)(te, TM_END))
		(*te->error)(te, 0, "unexpected operator/operand");

	return (te->flags & TEF_ERROR) ? T_ERR_EXIT : !res;
}

static int
test_oexpr(Test_env *te, int do_eval)
{
	int res;

	res = test_aexpr(te, do_eval);
	if (res)
		do_eval = 0;
	if (!(te->flags & TEF_ERROR) && (*te->isa)(te, TM_OR))
		return test_oexpr(te, do_eval) || res;
	return res;
}

static int
test_aexpr(Test_env *te, int do_eval)
{
	int res;

	res = test_nexpr(te, do_eval);
	if (!res)
		do_eval = 0;
	if (!(te->flags & TEF_ERROR) && (*te->isa)(te, TM_AND))
		return test_aexpr(te, do_eval) && res;
	return res;
}

static int
test_nexpr(Test_env *te, int do_eval)
{
	if (!(te->flags & TEF_ERROR) && (*te->isa)(te, TM_NOT))
		return !test_nexpr(te, do_eval);
	return test_primary(te, do_eval);
}

static int
test_primary(Test_env *te, int do_eval)
{
	const char *opnd1, *opnd2;
	int res;
	Test_op op;

	if (te->flags & TEF_ERROR)
		return 0;
	if ((*te->isa)(te, TM_OPAREN)) {
		res = test_oexpr(te, do_eval);
		if (te->flags & TEF_ERROR)
			return 0;
		if (!(*te->isa)(te, TM_CPAREN)) {
			(*te->error)(te, 0, "missing closing paren");
			return 0;
		}
		return res;
	}
	/*
	 * Binary should have precedence over unary in this case
	 * so that something like test \( -f = -f \) is accepted
	 */
	if ((te->flags & TEF_DBRACKET) || (&te->pos.wp[1] < te->wp_end &&
	    !test_isop(te, TM_BINOP, te->pos.wp[1]))) {
		if ((op = (Test_op) (*te->isa)(te, TM_UNOP))) {
			/* unary expression */
			opnd1 = (*te->getopnd)(te, op, do_eval);
			if (!opnd1) {
				(*te->error)(te, -1, "missing argument");
				return 0;
			}

			return (*te->eval)(te, op, opnd1, NULL,
			    do_eval);
		}
	}
	opnd1 = (*te->getopnd)(te, TO_NONOP, do_eval);
	if (!opnd1) {
		(*te->error)(te, 0, "expression expected");
		return 0;
	}
	if ((op = (Test_op) (*te->isa)(te, TM_BINOP))) {
		/* binary expression */
		opnd2 = (*te->getopnd)(te, op, do_eval);
		if (!opnd2) {
			(*te->error)(te, -1, "missing second argument");
			return 0;
		}

		return (*te->eval)(te, op, opnd1, opnd2, do_eval);
	}
	if (te->flags & TEF_DBRACKET) {
		(*te->error)(te, -1, "missing expression operator");
		return 0;
	}
	return (*te->eval)(te, TO_STNZE, opnd1, NULL, do_eval);
}

/*
 * Plain test (test and [ .. ]) specific routines.
 */

/* Test if the current token is a whatever.  Accepts the current token if
 * it is.  Returns 0 if it is not, non-zero if it is (in the case of
 * TM_UNOP and TM_BINOP, the returned value is a Test_op).
 */
static int
ptest_isa(Test_env *te, Test_meta meta)
{
	/* Order important - indexed by Test_meta values */
	static const char *const tokens[] = {
		"-o", "-a", "!", "(", ")"
	};
	int ret;

	if (te->pos.wp >= te->wp_end)
		return meta == TM_END;

	if (meta == TM_UNOP || meta == TM_BINOP)
		ret = (int) test_isop(te, meta, *te->pos.wp);
	else if (meta == TM_END)
		ret = 0;
	else
		ret = strcmp(*te->pos.wp, tokens[(int) meta]) == 0;

	/* Accept the token? */
	if (ret)
		te->pos.wp++;

	return ret;
}

static const char *
ptest_getopnd(Test_env *te, Test_op op, int do_eval)
{
	if (te->pos.wp >= te->wp_end)
		return op == TO_FILTT ? "1" : NULL;
	return *te->pos.wp++;
}

static int
ptest_eval(Test_env *te, Test_op op, const char *opnd1, const char *opnd2,
    int do_eval)
{
	return test_eval(te, op, opnd1, opnd2, do_eval);
}

static void
ptest_error(Test_env *te, int offset, const char *msg)
{
	const char *op = te->pos.wp + offset >= te->wp_end ?
	    NULL : te->pos.wp[offset];

	te->flags |= TEF_ERROR;
	if (op)
		bi_errorf("%s: %s", op, msg);
	else
		bi_errorf("%s", msg);
}
@


1.22
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.21 2015/10/19 02:15:45 mmcc Exp $	*/
d15 1
@


1.21
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.20 2015/09/18 07:28:24 nicm Exp $	*/
d13 2
@


1.20
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.19 2015/09/15 18:15:05 tedu Exp $	*/
d12 2
a14 1
#include <sys/stat.h>
@


1.19
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.18 2009/03/01 20:11:06 otto Exp $	*/
d474 1
a474 1
			return (*te->eval)(te, op, opnd1, (const char *) 0,
d497 1
a497 1
	return (*te->eval)(te, TO_STNZE, opnd1, (const char *) 0, do_eval);
d538 1
a538 1
		return op == TO_FILTT ? "1" : (const char *) 0;
d553 1
a553 1
	    (const char *) 0 : te->pos.wp[offset];
@


1.18
log
@Fix PR #723: test(1) operator precedence inconsistent with POSIX
Make sure ksh builtin test and test(1) do not differ.
From Christiano Farina Haesbaert. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.17 2005/03/30 17:16:37 deraadt Exp $	*/
d164 1
a164 1
				    (char *) 0, 1);
@


1.17
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.16 2005/03/28 21:33:04 deraadt Exp $	*/
d460 16
a475 6
	if ((op = (Test_op) (*te->isa)(te, TM_UNOP))) {
		/* unary expression */
		opnd1 = (*te->getopnd)(te, op, do_eval);
		if (!opnd1) {
			(*te->error)(te, -1, "missing argument");
			return 0;
a476 2

		return (*te->eval)(te, op, opnd1, (const char *) 0, do_eval);
@


1.16
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.15 2005/02/02 07:53:01 otto Exp $	*/
d69 1
a69 1
    };
d86 1
a86 1
    };
d144 2
a145 2
					res = (*te.eval)(&te, op, opnd1, opnd2,
							1);
d164 1
a164 1
						(char *) 0, 1);
d194 4
a197 5
			if (sc1 == otab->op_text[1]
			    && strcmp(s, otab->op_text) == 0
			    && ((te->flags & TEF_DBRACKET)
				|| (otab->op_num != TO_STLT
				    && otab->op_num != TO_STGT)))
d218 1
a218 1
	  case TO_STNZE: /* -n */
d220 1
a220 1
	  case TO_STZER: /* -z */
d222 1
a222 1
	  case TO_OPTION: /* -o */
d233 1
a233 1
	  case TO_FILRD: /* -r */
d235 1
a235 1
	  case TO_FILWR: /* -w */
d237 1
a237 1
	  case TO_FILEX: /* -x */
d239 1
a239 1
	  case TO_FILAXST: /* -a */
d241 1
a241 1
	  case TO_FILEXST: /* -e */
d246 1
a246 1
	  case TO_FILREG: /* -r */
d248 1
a248 1
	  case TO_FILID: /* -d */
d250 1
a250 1
	  case TO_FILCDEV: /* -c */
d252 1
a252 1
	  case TO_FILBDEV: /* -b */
d254 1
a254 1
	  case TO_FILFIFO: /* -p */
d256 1
a256 1
	  case TO_FILSYM: /* -h -L */
d258 1
a258 1
	  case TO_FILSOCK: /* -S */
d260 1
a260 1
	  case TO_FILCDF:/* -H HP context dependent files (directories) */
d262 10
a271 10
	  case TO_FILSETU: /* -u */
		return test_stat(opnd1, &b1) == 0
			&& (b1.st_mode & S_ISUID) == S_ISUID;
	  case TO_FILSETG: /* -g */
		return test_stat(opnd1, &b1) == 0
			&& (b1.st_mode & S_ISGID) == S_ISGID;
	  case TO_FILSTCK: /* -k */
		return test_stat(opnd1, &b1) == 0
			&& (b1.st_mode & S_ISVTX) == S_ISVTX;
	  case TO_FILGZ: /* -s */
d273 1
a273 1
	  case TO_FILTT: /* -t */
d282 1
a282 1
	  case TO_FILUID: /* -O */
d284 1
a284 1
	  case TO_FILGID: /* -G */
d289 1
a289 1
	  case TO_STEQL: /* = */
d293 1
a293 1
	  case TO_STNEQ: /* != */
d297 1
a297 1
	  case TO_STLT: /* < */
d299 1
a299 1
	  case TO_STGT: /* > */
d301 6
a306 6
	  case TO_INTEQ: /* -eq */
	  case TO_INTNE: /* -ne */
	  case TO_INTGE: /* -ge */
	  case TO_INTGT: /* -gt */
	  case TO_INTLE: /* -le */
	  case TO_INTLT: /* -lt */
d310 2
a311 3
			if (!evaluate(opnd1, &v1, KSH_RETURN_ERROR, false)
			    || !evaluate(opnd2, &v2, KSH_RETURN_ERROR, false))
			{
d317 1
a317 1
			  case TO_INTEQ:
d319 1
a319 1
			  case TO_INTNE:
d321 1
a321 1
			  case TO_INTGE:
d323 1
a323 1
			  case TO_INTGT:
d325 1
a325 1
			  case TO_INTLE:
d327 1
a327 1
			  case TO_INTLT:
d331 1
a331 1
	  case TO_FILNT: /* -nt */
d337 3
a339 3
			return stat(opnd1, &b1) == 0
				&& (((s2 = stat(opnd2, &b2)) == 0
				      && b1.st_mtime > b2.st_mtime) || s2 < 0);
d341 1
a341 1
	  case TO_FILOT: /* -ot */
d347 3
a349 3
			return stat(opnd2, &b2) == 0
				&& (((s1 = stat(opnd1, &b1)) == 0
				      && b1.st_mtime < b2.st_mtime) || s1 < 0);
d351 3
a353 4
	  case TO_FILEQ: /* -ef */
		return stat (opnd1, &b1) == 0 && stat (opnd2, &b2) == 0
		       && b1.st_dev == b2.st_dev
		       && b1.st_ino == b2.st_ino;
d387 2
a388 2
			res = (statb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH))
				? 0 : -1;
d545 1
a545 1
				(const char *) 0 : te->pos.wp[offset];
@


1.15
log
@Introduce POSIX hex and octal (0x... and 0...) constants in arithmetic
expressions.  Work by Matthias Kilian, based on an old diff by myself.
Note: MAKEDEV should be updated. Tested by many, thanks.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.14 2004/12/22 17:14:34 millert Exp $	*/
d508 2
a509 2
				"-o", "-a", "!", "(", ")"
			};
@


1.14
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.13 2004/12/20 11:34:26 otto Exp $	*/
d311 2
a312 2
			if (!evaluate(opnd1, &v1, KSH_RETURN_ERROR)
			    || !evaluate(opnd2, &v2, KSH_RETURN_ERROR))
@


1.13
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.12 2004/12/18 21:04:52 millert Exp $	*/
d292 1
a292 1
			return gmatch(opnd1, opnd2, FALSE);
d296 1
a296 1
			return !gmatch(opnd1, opnd2, FALSE);
@


1.12
log
@Get rid of #ifdef KSH since we don't care about building a V7 style sh and
the #ifdef KSH code is required to make a POSIX sh.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.11 2004/12/18 20:55:52 millert Exp $	*/
d88 11
a98 11
static int	test_stat(const char *path, struct stat *statb);
static int	test_eaccess(const char *path, int mode);
static int	test_oexpr(Test_env *te, int do_eval);
static int	test_aexpr(Test_env *te, int do_eval);
static int	test_nexpr(Test_env *te, int do_eval);
static int	test_primary(Test_env *te, int do_eval);
static int	ptest_isa(Test_env *te, Test_meta meta);
static const char *ptest_getopnd(Test_env *te, Test_op op, int do_eval);
static int	ptest_eval(Test_env *te, Test_op op, const char *opnd1,
				const char *opnd2, int do_eval);
static void	ptest_error(Test_env *te, int offset, const char *msg);
d101 1
a101 2
c_test(wp)
	char **wp;
d185 1
a185 4
test_isop(te, meta, s)
	Test_env *te;
	Test_meta meta;
	const char *s;
d205 2
a206 6
test_eval(te, op, opnd1, opnd2, do_eval)
	Test_env *te;
	Test_op op;
	const char *opnd1;
	const char *opnd2;
	int do_eval;
d364 1
a364 3
test_stat(path, statb)
	const char *path;
	struct stat *statb;
d373 1
a373 3
test_eaccess(path, mode)
	const char *path;
	int mode;
d398 1
a398 2
test_parse(te)
	Test_env *te;
d411 1
a411 3
test_oexpr(te, do_eval)
	Test_env *te;
	int do_eval;
d424 1
a424 3
test_aexpr(te, do_eval)
	Test_env *te;
	int do_eval;
d437 1
a437 3
test_nexpr(te, do_eval)
	Test_env *te;
	int do_eval;
d445 1
a445 3
test_primary(te, do_eval)
	Test_env *te;
	int do_eval;
d504 1
a504 3
ptest_isa(te, meta)
	Test_env *te;
	Test_meta meta;
d530 1
a530 4
ptest_getopnd(te, op, do_eval)
	Test_env *te;
	Test_op op;
	int do_eval;
d538 2
a539 6
ptest_eval(te, op, opnd1, opnd2, do_eval)
	Test_env *te;
	Test_op op;
	const char *opnd1;
	const char *opnd2;
	int do_eval;
d545 1
a545 4
ptest_error(te, offset, msg)
	Test_env *te;
	int offset;
	const char *msg;
@


1.11
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.10 2003/10/10 19:09:07 millert Exp $	*/
a71 1
#ifdef KSH
a72 1
#endif /* KSH */
@


1.10
log
@The special case code for "test -x" over NFS was incorrect.  The
right thing to do is to try access(2) first (since that occurs on the
NFS server side) and only check for the absence of an execute bit
when access(2) succeeds.  Closes PR 3465
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.9 2003/02/28 09:45:09 jmc Exp $	*/
d13 1
a13 1
#include "ksh_stat.h"
d90 11
a100 11
static int	test_stat ARGS((const char *path, struct stat *statb));
static int	test_eaccess ARGS((const char *path, int mode));
static int	test_oexpr ARGS((Test_env *te, int do_eval));
static int	test_aexpr ARGS((Test_env *te, int do_eval));
static int	test_nexpr ARGS((Test_env *te, int do_eval));
static int	test_primary ARGS((Test_env *te, int do_eval));
static int	ptest_isa ARGS((Test_env *te, Test_meta meta));
static const char *ptest_getopnd ARGS((Test_env *te, Test_op op, int do_eval));
static int	ptest_eval ARGS((Test_env *te, Test_op op, const char *opnd1,
				const char *opnd2, int do_eval));
static void	ptest_error ARGS((Test_env *te, int offset, const char *msg));
a261 1
#ifdef S_ISCHR
a262 3
#else
		return 0;
#endif
a263 1
#ifdef S_ISBLK
a264 3
#else
		return 0;
#endif
a265 1
#ifdef S_ISFIFO
a266 3
#else
		return 0;
#endif
a267 1
#ifdef S_ISLNK
a268 3
#else
		return 0;
#endif
a269 1
#ifdef S_ISSOCK
a270 3
#else
		return 0;
#endif
a271 18
#ifdef S_ISCDF
	  {
		/* Append a + to filename and check to see if result is a
		 * setuid directory.  CDF stuff in general is hookey, since
		 * it breaks for the following sequence: echo hi > foo+;
		 * mkdir foo; echo bye > foo/default; chmod u+s foo
		 * (foo+ refers to the file with hi in it, there is no way
		 * to get at the file with bye in it - please correct me if
		 * I'm wrong about this).
		 */
		int len = strlen(opnd1);
		char *p = str_nsave(opnd1, len + 1, ATEMP);

		p[len++] = '+';
		p[len] = '\0';
		return stat(p, &b1) == 0 && S_ISCDF(b1.st_mode);
	  }
#else
a272 1
#endif
a273 1
#ifdef S_ISUID
a275 3
#else
		return 0;
#endif
a276 1
#ifdef S_ISGID
a278 3
#else
		return 0;
#endif
a377 7
#if !defined(HAVE_DEV_FD)
	int fd;

	if (strncmp(path, "/dev/fd/", 8) == 0 && getn(path + 8, &fd))
		return fstat(fd, statb);
#endif /* !HAVE_DEV_FD */

d391 1
a391 17
#if !defined(HAVE_DEV_FD)
	int fd;

	/* Note: doesn't handle //dev/fd, etc.. (this is ok) */
	if (strncmp(path, "/dev/fd/", 8) == 0 && getn(path + 8, &fd)) {
		int flags;

		if ((flags = fcntl(fd, F_GETFL, 0)) < 0
		    || (mode & X_OK)
		    || ((mode & W_OK) && (flags & O_ACCMODE) == O_RDONLY)
		    || ((mode & R_OK) && (flags & O_ACCMODE) == O_WRONLY))
			return -1;
		return 0;
	}
#endif /* !HAVE_DEV_FD */

	res = eaccess(path, mode);
@


1.9
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.8 2002/06/09 05:47:27 todd Exp $	*/
d461 3
a463 1
	/* On most (all?) unixes, access() says everything is executable for
d466 1
a466 1
	if ((mode & X_OK) && ksheuid == 0) {
d476 1
a476 7
		/* Need to check other permissions?  If so, use access() as
		 * this will deal with root on NFS.
		 */
		if (res == 0 && (mode & (R_OK|W_OK)))
			res = eaccess(path, mode);
	} else
		res = eaccess(path, mode);
@


1.8
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.7 1999/07/14 13:37:23 millert Exp $	*/
d132 1
a132 1
	 * our parser does the right thing for the ommited steps.
@


1.7
log
@pdksh-5.2.14
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.6 1999/06/15 01:18:33 millert Exp $	*/
d129 1
a129 1
	/* 
d131 1
a131 1
	 * Implementation of all the rules isn't necessary since 
d243 1
a243 1
		return res; 
@


1.6
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.5 1998/06/25 19:01:47 millert Exp $	*/
d391 9
a399 2
		return stat (opnd1, &b1) == 0 && stat (opnd2, &b2) == 0
		       && b1.st_mtime > b2.st_mtime;
d401 9
a409 2
		return stat (opnd1, &b1) == 0 && stat (opnd2, &b2) == 0
		       && b1.st_mtime < b2.st_mtime;
@


1.5
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.4 1997/06/19 13:58:38 kstailey Exp $	*/
d368 2
a369 2
			if (!evaluate(opnd1, &v1, TRUE)
			    || !evaluate(opnd2, &v2, TRUE))
@


1.4
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.2 1996/08/19 20:08:47 downsj Exp $	*/
d160 6
d335 2
a336 1
		} else
d338 1
d341 1
a341 1
		return test_stat(opnd1, &b1) == 0 && b1.st_uid == geteuid();
d421 3
a423 1
/* Another nasty kludge to handle Korn's bizarre /dev/fd hack */
d429 2
d434 1
d447 22
a468 1
	return eaccess(path, mode);
@


1.3
log
@(foo *)0 -> NULL
@
text
@d160 2
a161 1
				res = (*te.eval)(&te, TO_STNZE, opnd1, NULL, 1);
d520 1
a520 1
		return (*te->eval)(te, op, opnd1, NULL, do_eval);
d541 1
a541 1
	return (*te->eval)(te, TO_STNZE, opnd1, NULL, do_eval);
d587 1
a587 1
		return op == TO_FILTT ? "1" : NULL;
d609 1
a609 1
				NULL : te->pos.wp[offset];
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: c_test.c,v 1.1.1.1 1996/08/14 06:19:10 downsj Exp $	*/
d160 1
a160 2
				res = (*te.eval)(&te, TO_STNZE, opnd1,
						(char *) 0, 1);
d519 1
a519 1
		return (*te->eval)(te, op, opnd1, (const char *) 0, do_eval);
d540 1
a540 1
	return (*te->eval)(te, TO_STNZE, opnd1, (const char *) 0, do_eval);
d586 1
a586 1
		return op == TO_FILTT ? "1" : (const char *) 0;
d608 1
a608 1
				(const char *) 0 : te->pos.wp[offset];
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d30 1
a30 1
	binary-operator ::= "="|"!="|"-eq"|"-ne"|"-ge"|"-gt"|"-le"|"-lt"|
d72 3
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
