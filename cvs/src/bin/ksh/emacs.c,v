head	1.73;
access;
symbols
	OPENBSD_6_2:1.73.0.4
	OPENBSD_6_2_BASE:1.73
	OPENBSD_6_1:1.66.0.4
	OPENBSD_6_1_BASE:1.66
	OPENBSD_6_0:1.65.0.4
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.65.0.2
	OPENBSD_5_9_BASE:1.65
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.48.0.6
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.48.0.4
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.46.0.6
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.46.0.4
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.46.0.2
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.2
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.42.0.8
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.42.0.6
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.42.0.2
	OPENBSD_4_7_BASE:1.42
	OPENBSD_4_6:1.42.0.4
	OPENBSD_4_6_BASE:1.42
	OPENBSD_4_5:1.41.0.8
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.41.0.6
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.4
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.41.0.2
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.40.0.4
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.40.0.2
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.39.0.2
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.35.0.2
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.28.0.4
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.4
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.13.0.4
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.73
date	2017.08.30.17.02.53;	author jca;	state Exp;
branches;
next	1.72;
commitid	a9ziUXbpkf6RtIgW;

1.72
date	2017.08.30.16.59.23;	author jca;	state Exp;
branches;
next	1.71;
commitid	0SW45nSg7G9XSfE5;

1.71
date	2017.08.29.23.04.50;	author jca;	state Exp;
branches;
next	1.70;
commitid	KLh0MxJVG3LcRApL;

1.70
date	2017.06.25.17.28.39;	author anton;	state Exp;
branches;
next	1.69;
commitid	T0At7XiotqQ8tKGn;

1.69
date	2017.06.25.08.51.52;	author anton;	state Exp;
branches;
next	1.68;
commitid	vCKNdNLryQ0JO1mc;

1.68
date	2017.06.20.17.32.20;	author brynet;	state Exp;
branches;
next	1.67;
commitid	fEO9WbCsaxInDkte;

1.67
date	2017.05.12.14.37.52;	author schwarze;	state Exp;
branches;
next	1.66;
commitid	M4oGqEgXxjgerPee;

1.66
date	2016.08.09.11.04.46;	author schwarze;	state Exp;
branches;
next	1.65;
commitid	5BoxQ5jfLu0TJ7WT;

1.65
date	2016.01.26.17.39.31;	author mmcc;	state Exp;
branches;
next	1.64;
commitid	1eQJzyXllsiUFmYD;

1.64
date	2016.01.08.13.17.57;	author schwarze;	state Exp;
branches;
next	1.63;
commitid	Lp58HlawVpqS4Wjh;

1.63
date	2015.12.30.15.21.42;	author tedu;	state Exp;
branches;
next	1.62;
commitid	icl4nmJSGGVA49CG;

1.62
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.61;
commitid	btTCreDA00YdaFhU;

1.61
date	2015.12.10.10.00.14;	author schwarze;	state Exp;
branches;
next	1.60;
commitid	rXosLU4DPZxDqEqL;

1.60
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.59;
commitid	C4W85jmosThChWA2;

1.59
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.58;
commitid	16HUr75moyUNtKR8;

1.58
date	2015.10.16.23.18.59;	author mmcc;	state Exp;
branches;
next	1.57;
commitid	twP24vNwzKTyx2pj;

1.57
date	2015.10.16.17.14.04;	author mmcc;	state Exp;
branches;
next	1.56;
commitid	yesNvsZSc6V4Xxih;

1.56
date	2015.10.10.15.31.00;	author millert;	state Exp;
branches;
next	1.55;
commitid	hSFmfQ37guoXupUd;

1.55
date	2015.10.10.07.38.18;	author nicm;	state Exp;
branches;
next	1.54;
commitid	5MVJIInMhIb304P0;

1.54
date	2015.10.09.19.36.27;	author tedu;	state Exp;
branches;
next	1.53;
commitid	BqXaWldwtvsixcay;

1.53
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.52;
commitid	7fgq4YTZG4xZ0uN0;

1.52
date	2015.09.10.22.48.58;	author nicm;	state Exp;
branches;
next	1.51;
commitid	stJ3KRI2o7F5OBtF;

1.51
date	2015.09.01.13.12.31;	author tedu;	state Exp;
branches;
next	1.50;
commitid	sKGEDet4KOfGjsIb;

1.50
date	2015.03.25.12.10.52;	author jca;	state Exp;
branches;
next	1.49;
commitid	gDTR8fRQfqxxe9zw;

1.49
date	2015.02.16.01.44.41;	author tedu;	state Exp;
branches;
next	1.48;
commitid	q22iUuOaXog4MKJl;

1.48
date	2013.12.17.16.37.05;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2013.11.28.10.33.37;	author sobrado;	state Exp;
branches;
next	1.46;

1.46
date	2012.06.10.10.15.01;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2012.04.30.03.51.29;	author djm;	state Exp;
branches;
next	1.44;

1.44
date	2011.09.05.04.50.33;	author marco;	state Exp;
branches;
next	1.43;

1.43
date	2011.03.14.21.20.01;	author okan;	state Exp;
branches;
next	1.42;

1.42
date	2009.06.02.06.47.47;	author halex;	state Exp;
branches;
next	1.41;

1.41
date	2007.08.02.10.50.25;	author fgsch;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.10.17.12.41;	author beck;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.26.19.25.22;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.01.04.27.31;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.28.21.28.22;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.02.17.18.57.04;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2004.12.23.11.29.02;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2004.12.19.04.14.20;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2003.10.22.07.40.38;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.01.15.47.40;	author naddy;	state Exp;
branches;
next	1.26;

1.26
date	2003.08.27.14.56.11;	author fgsch;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.27.14.40.56;	author fgsch;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.26.17.55.01;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.23.02.30.59;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.02.19.44.12;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.02.19.26.15;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.26.00.09.45;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.16.23.11.52;	author tdeval;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2002.10.16.00.13.53;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.17.12.39.31;	author camield;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.19.09.49.52;	author camield;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.24.03.12.12;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.11.14.22.04.02;	author d;	state Exp;
branches;
next	1.11;

1.11
date	99.08.04.19.11.13;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.07.14.13.37.23;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.06.15.01.18.33;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.01.19.20.41.52;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.01.10.17.55.02;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.10.29.04.09.20;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.06.25.19.01.51;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.06.19.13.58.39;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.06.18.22.42.32;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.48;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.10;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.10;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.73
log
@Stop exposing the emacs-usemeta option, and warn when trying to set it.

Unused since 2012, to be removed after 6.2.  Input from anton@@,
ok anton@@ millert@@
@
text
@/*	$OpenBSD: emacs.c,v 1.72 2017/08/30 16:59:23 jca Exp $	*/

/*
 *  Emacs-like command line editing and history
 *
 *  created by Ron Natalie at BRL
 *  modified by Doug Kingston, Doug Gwyn, and Lou Salkind
 *  adapted to PD ksh by Eric Gisin
 *
 * partial rewrite by Marco Peereboom <marco@@openbsd.org>
 * under the same license
 */

#include "config.h"
#ifdef EMACS

#include <sys/queue.h>
#include <sys/stat.h>

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "sh.h"
#include "edit.h"

static	Area	aedit;
#define	AEDIT	&aedit		/* area for kill ring and macro defns */

#define	CTRL(x)		((x) == '?' ? 0x7F : (x) & 0x1F)	/* ASCII */
#define	UNCTRL(x)	((x) == 0x7F ? '?' : (x) | 0x40)	/* ASCII */

/* values returned by keyboard functions */
#define	KSTD	0
#define	KEOL	1		/* ^M, ^J */
#define	KINTR	2		/* ^G, ^C */

struct	x_ftab {
	int		(*xf_func)(int c);
	const char	*xf_name;
	short		xf_flags;
};

#define XF_ARG		1	/* command takes number prefix */
#define	XF_NOBIND	2	/* not allowed to bind to function */
#define	XF_PREFIX	4	/* function sets prefix */

/* Separator for completion */
#define	is_cfs(c)	(c == ' ' || c == '\t' || c == '"' || c == '\'')

/* Separator for motion */
#define	is_mfs(c)	(!(isalnum((unsigned char)c) || \
			c == '_' || c == '$' || c & 0x80))

/* Arguments for do_complete()
 * 0 = enumerate  M-= complete as much as possible and then list
 * 1 = complete   M-Esc
 * 2 = list       M-?
 */
typedef enum {
	CT_LIST,	/* list the possible completions */
	CT_COMPLETE,	/* complete to longest prefix */
	CT_COMPLIST	/* complete and then list (if non-exact) */
} Comp_type;

/* keybindings */
struct kb_entry {
	TAILQ_ENTRY(kb_entry)	entry;
	unsigned char		*seq;
	int			len;
	struct x_ftab		*ftab;
	void			*args;
};
TAILQ_HEAD(kb_list, kb_entry);
struct kb_list			kblist = TAILQ_HEAD_INITIALIZER(kblist);

/* { from 4.9 edit.h */
/*
 * The following are used for my horizontal scrolling stuff
 */
static char    *xbuf;		/* beg input buffer */
static char    *xend;		/* end input buffer */
static char    *xcp;		/* current position */
static char    *xep;		/* current end */
static char    *xbp;		/* start of visible portion of input buffer */
static char    *xlp;		/* last byte visible on screen */
static int	x_adj_ok;
/*
 * we use x_adj_done so that functions can tell
 * whether x_adjust() has been called while they are active.
 */
static int	x_adj_done;

static int	xx_cols;
static int	x_col;
static int	x_displen;
static int	x_arg;		/* general purpose arg */
static int	x_arg_defaulted;/* x_arg not explicitly set; defaulted to 1 */

static int	xlp_valid;
/* end from 4.9 edit.h } */
static	int	x_tty;		/* are we on a tty? */
static	int	x_bind_quiet;	/* be quiet when binding keys */
static int	(*x_last_command)(int);

static	char   **x_histp;	/* history position */
static	int	x_nextcmd;	/* for newline-and-next */
static	char	*xmp;		/* mark pointer */
#define	KILLSIZE	20
static	char	*killstack[KILLSIZE];
static	int	killsp, killtp;
static	int	x_literal_set;
static	int	x_arg_set;
static	char	*macro_args;
static	int	prompt_skip;
static	int	prompt_redraw;

static int	x_ins(char *);
static void	x_delete(int, int);
static int	x_bword(void);
static int	x_fword(void);
static void	x_goto(char *);
static void	x_bs(int);
static int	x_size_str(char *);
static int	x_size(int);
static void	x_zots(char *);
static void	x_zotc(int);
static void	x_load_hist(char **);
static int	x_search(char *, int, int);
static int	x_match(char *, char *);
static void	x_redraw(int);
static void	x_push(int);
static void	x_adjust(void);
static void	x_e_ungetc(int);
static int	x_e_getc(void);
static int	x_e_getu8(char *, int);
static void	x_e_putc(int);
static void	x_e_puts(const char *);
static int	x_comment(int);
static int	x_fold_case(int);
static char	*x_lastcp(void);
static void	do_complete(int, Comp_type);
static int	isu8cont(unsigned char);

/* proto's for keybindings */
static int	x_abort(int);
static int	x_beg_hist(int);
static int	x_comp_comm(int);
static int	x_comp_file(int);
static int	x_complete(int);
static int	x_del_back(int);
static int	x_del_bword(int);
static int	x_del_char(int);
static int	x_del_fword(int);
static int	x_del_line(int);
static int	x_draw_line(int);
static int	x_end_hist(int);
static int	x_end_of_text(int);
static int	x_enumerate(int);
static int	x_eot_del(int);
static int	x_error(int);
static int	x_goto_hist(int);
static int	x_ins_string(int);
static int	x_insert(int);
static int	x_kill(int);
static int	x_kill_region(int);
static int	x_list_comm(int);
static int	x_list_file(int);
static int	x_literal(int);
static int	x_meta_yank(int);
static int	x_mv_back(int);
static int	x_mv_begin(int);
static int	x_mv_bword(int);
static int	x_mv_end(int);
static int	x_mv_forw(int);
static int	x_mv_fword(int);
static int	x_newline(int);
static int	x_next_com(int);
static int	x_nl_next_com(int);
static int	x_noop(int);
static int	x_prev_com(int);
static int	x_prev_histword(int);
static int	x_search_char_forw(int);
static int	x_search_char_back(int);
static int	x_search_hist(int);
static int	x_set_mark(int);
static int	x_transpose(int);
static int	x_version(int);
static int	x_xchg_point_mark(int);
static int	x_yank(int);
static int	x_comp_list(int);
static int	x_expand(int);
static int	x_fold_capitalize(int);
static int	x_fold_lower(int);
static int	x_fold_upper(int);
static int	x_set_arg(int);
static int	x_comment(int);
#ifdef DEBUG
static int	x_debug_info(int);
#endif

static const struct x_ftab x_ftab[] = {
	{ x_abort,		"abort",			0 },
	{ x_beg_hist,		"beginning-of-history",		0 },
	{ x_comp_comm,		"complete-command",		0 },
	{ x_comp_file,		"complete-file",		0 },
	{ x_complete,		"complete",			0 },
	{ x_del_back,		"delete-char-backward",		XF_ARG },
	{ x_del_bword,		"delete-word-backward",		XF_ARG },
	{ x_del_char,		"delete-char-forward",		XF_ARG },
	{ x_del_fword,		"delete-word-forward",		XF_ARG },
	{ x_del_line,		"kill-line",			0 },
	{ x_draw_line,		"redraw",			0 },
	{ x_end_hist,		"end-of-history",		0 },
	{ x_end_of_text,	"eot",				0 },
	{ x_enumerate,		"list",				0 },
	{ x_eot_del,		"eot-or-delete",		XF_ARG },
	{ x_error,		"error",			0 },
	{ x_goto_hist,		"goto-history",			XF_ARG },
	{ x_ins_string,		"macro-string",			XF_NOBIND },
	{ x_insert,		"auto-insert",			XF_ARG },
	{ x_kill,		"kill-to-eol",			XF_ARG },
	{ x_kill_region,	"kill-region",			0 },
	{ x_list_comm,		"list-command",			0 },
	{ x_list_file,		"list-file",			0 },
	{ x_literal,		"quote",			0 },
	{ x_meta_yank,		"yank-pop",			0 },
	{ x_mv_back,		"backward-char",		XF_ARG },
	{ x_mv_begin,		"beginning-of-line",		0 },
	{ x_mv_bword,		"backward-word",		XF_ARG },
	{ x_mv_end,		"end-of-line",			0 },
	{ x_mv_forw,		"forward-char",			XF_ARG },
	{ x_mv_fword,		"forward-word",			XF_ARG },
	{ x_newline,		"newline",			0 },
	{ x_next_com,		"down-history",			XF_ARG },
	{ x_nl_next_com,	"newline-and-next",		0 },
	{ x_noop,		"no-op",			0 },
	{ x_prev_com,		"up-history",			XF_ARG },
	{ x_prev_histword,	"prev-hist-word",		XF_ARG },
	{ x_search_char_forw,	"search-character-forward",	XF_ARG },
	{ x_search_char_back,	"search-character-backward",	XF_ARG },
	{ x_search_hist,	"search-history",		0 },
	{ x_set_mark,		"set-mark-command",		0 },
	{ x_transpose,		"transpose-chars",		0 },
	{ x_version,		"version",			0 },
	{ x_xchg_point_mark,	"exchange-point-and-mark",	0 },
	{ x_yank,		"yank",				0 },
	{ x_comp_list,		"complete-list",		0 },
	{ x_expand,		"expand-file",			0 },
	{ x_fold_capitalize,	"capitalize-word",		XF_ARG },
	{ x_fold_lower,		"downcase-word",		XF_ARG },
	{ x_fold_upper,		"upcase-word",			XF_ARG },
	{ x_set_arg,		"set-arg",			XF_NOBIND },
	{ x_comment,		"comment",			0 },
	{ 0, 0, 0 },
#ifdef DEBUG
	{ x_debug_info,		"debug-info",			0 },
#else
	{ 0, 0, 0 },
#endif
	{ 0, 0, 0 },
};

int
isu8cont(unsigned char c)
{
	return (c & (0x80 | 0x40)) == 0x80;
}

int
x_emacs(char *buf, size_t len)
{
	struct kb_entry		*k, *kmatch = NULL;
	char			line[LINE + 1];
	int			at = 0, ntries = 0, submatch, ret;
	const char		*p;

	xbp = xbuf = buf; xend = buf + len;
	xlp = xcp = xep = buf;
	*xcp = 0;
	xlp_valid = true;
	xmp = NULL;
	x_histp = histptr + 1;

	xx_cols = x_cols;
	x_col = promptlen(prompt, &p);
	prompt_skip = p - prompt;
	x_adj_ok = 1;
	prompt_redraw = 1;
	if (x_col > xx_cols)
		x_col = x_col - (x_col / xx_cols) * xx_cols;
	x_displen = xx_cols - 2 - x_col;
	x_adj_done = 0;

	pprompt(prompt, 0);
	if (x_displen < 1) {
		x_col = 0;
		x_displen = xx_cols - 2;
		x_e_putc('\n');
		prompt_redraw = 0;
	}

	if (x_nextcmd >= 0) {
		int off = source->line - x_nextcmd;
		if (histptr - history >= off)
			x_load_hist(histptr - off);
		x_nextcmd = -1;
	}

	x_literal_set = 0;
	x_arg = -1;
	x_last_command = NULL;
	while (1) {
		x_flush();
		if ((at = x_e_getu8(line, at)) < 0)
			return 0;
		ntries++;

		if (x_arg == -1) {
			x_arg = 1;
			x_arg_defaulted = 1;
		}

		if (x_literal_set) {
			/* literal, so insert it */
			x_literal_set = 0;
			submatch = 0;
		} else {
			submatch = 0;
			kmatch = NULL;
			TAILQ_FOREACH(k, &kblist, entry) {
				if (at > k->len)
					continue;

				if (memcmp(k->seq, line, at) == 0) {
					/* sub match */
					submatch++;
					if (k->len == at)
						kmatch = k;
				}

				/* see if we can abort search early */
				if (submatch > 1)
					break;
			}
		}

		if (submatch == 1 && kmatch) {
			if (kmatch->ftab->xf_func == x_ins_string &&
			    kmatch->args && !macro_args) {
				/* treat macro string as input */
				macro_args = kmatch->args;
				ret = KSTD;
			} else
				ret = kmatch->ftab->xf_func(line[at - 1]);
		} else {
			if (submatch)
				continue;
			if (ntries > 1) {
				ret = x_error(0); /* unmatched meta sequence */
			} else if (at > 1) {
				x_ins(line);
				ret = KSTD;
			} else {
				ret = x_insert(line[0]);
			}
		}

		switch (ret) {
		case KSTD:
			if (kmatch)
				x_last_command = kmatch->ftab->xf_func;
			else
				x_last_command = NULL;
			break;
		case KEOL:
			ret = xep - xbuf;
			return (ret);
			break;
		case KINTR:
			trapsig(SIGINT);
			x_mode(false);
			unwind(LSHELL);
			x_arg = -1;
			break;
		default:
			bi_errorf("invalid return code"); /* can't happen */
		}

		/* reset meta sequence */
		at = ntries = 0;
		if (x_arg_set)
			x_arg_set = 0; /* reset args next time around */
		else
			x_arg = -1;
	}
}

static int
x_insert(int c)
{
	char	str[2];

	/*
	 *  Should allow tab and control chars.
	 */
	if (c == 0) {
		x_e_putc(BEL);
		return KSTD;
	}
	str[0] = c;
	str[1] = '\0';
	while (x_arg--)
		x_ins(str);
	return KSTD;
}

static int
x_ins_string(int c)
{
	return x_insert(c);
}

static int
x_do_ins(const char *cp, size_t len)
{
	if (xep+len >= xend) {
		x_e_putc(BEL);
		return -1;
	}

	memmove(xcp+len, xcp, xep - xcp + 1);
	memmove(xcp, cp, len);
	xcp += len;
	xep += len;
	return 0;
}

static int
x_ins(char *s)
{
	char	*cp = xcp;
	int	adj = x_adj_done;

	if (x_do_ins(s, strlen(s)) < 0)
		return -1;
	/*
	 * x_zots() may result in a call to x_adjust()
	 * we want xcp to reflect the new position.
	 */
	xlp_valid = false;
	x_lastcp();
	x_adj_ok = (xcp >= xlp);
	x_zots(cp);
	if (adj == x_adj_done) {	/* has x_adjust() been called? */
		/* no */
		for (cp = xlp; cp > xcp; )
			x_bs(*--cp);
	}

	x_adj_ok = 1;
	return 0;
}

static int
x_del_back(int c)
{
	int col = xcp - xbuf;

	if (col == 0) {
		x_e_putc(BEL);
		return KSTD;
	}
	if (x_arg > col)
		x_arg = col;
	while (x_arg < col && isu8cont(xcp[-x_arg]))
		x_arg++;
	x_goto(xcp - x_arg);
	x_delete(x_arg, false);
	return KSTD;
}

static int
x_del_char(int c)
{
	int nleft = xep - xcp;

	if (!nleft) {
		x_e_putc(BEL);
		return KSTD;
	}
	if (x_arg > nleft)
		x_arg = nleft;
	while (x_arg < nleft && isu8cont(xcp[x_arg]))
		x_arg++;
	x_delete(x_arg, false);
	return KSTD;
}

/* Delete nc bytes to the right of the cursor (including cursor position) */
static void
x_delete(int nc, int push)
{
	int	i,j;
	char	*cp;

	if (nc == 0)
		return;
	if (xmp != NULL && xmp > xcp) {
		if (xcp + nc > xmp)
			xmp = xcp;
		else
			xmp -= nc;
	}

	/*
	 * This lets us yank a word we have deleted.
	 */
	if (push)
		x_push(nc);

	xep -= nc;
	cp = xcp;
	j = 0;
	i = nc;
	while (i--) {
		j += x_size((unsigned char)*cp++);
	}
	memmove(xcp, xcp+nc, xep - xcp + 1);	/* Copies the null */
	x_adj_ok = 0;			/* don't redraw */
	xlp_valid = false;
	x_zots(xcp);
	/*
	 * if we are already filling the line,
	 * there is no need to ' ','\b'.
	 * But if we must, make sure we do the minimum.
	 */
	if ((i = xx_cols - 2 - x_col) > 0) {
		j = (j < i) ? j : i;
		i = j;
		while (i--)
			x_e_putc(' ');
		i = j;
		while (i--)
			x_e_putc('\b');
	}
	/*x_goto(xcp);*/
	x_adj_ok = 1;
	xlp_valid = false;
	for (cp = x_lastcp(); cp > xcp; )
		x_bs(*--cp);

	return;
}

static int
x_del_bword(int c)
{
	x_delete(x_bword(), true);
	return KSTD;
}

static int
x_mv_bword(int c)
{
	(void)x_bword();
	return KSTD;
}

static int
x_mv_fword(int c)
{
	x_goto(xcp + x_fword());
	return KSTD;
}

static int
x_del_fword(int c)
{
	x_delete(x_fword(), true);
	return KSTD;
}

static int
x_bword(void)
{
	int	nc = 0;
	char	*cp = xcp;

	if (cp == xbuf) {
		x_e_putc(BEL);
		return 0;
	}
	while (x_arg--) {
		while (cp != xbuf && is_mfs(cp[-1])) {
			cp--;
			nc++;
		}
		while (cp != xbuf && !is_mfs(cp[-1])) {
			cp--;
			nc++;
		}
	}
	x_goto(cp);
	return nc;
}

static int
x_fword(void)
{
	int	nc = 0;
	char	*cp = xcp;

	if (cp == xep) {
		x_e_putc(BEL);
		return 0;
	}
	while (x_arg--) {
		while (cp != xep && is_mfs(*cp)) {
			cp++;
			nc++;
		}
		while (cp != xep && !is_mfs(*cp)) {
			cp++;
			nc++;
		}
	}
	return nc;
}

static void
x_goto(char *cp)
{
	if (cp < xbp || cp >= (xbp + x_displen)) {
		/* we are heading off screen */
		xcp = cp;
		x_adjust();
	} else if (cp < xcp) {		/* move back */
		while (cp < xcp)
			x_bs((unsigned char)*--xcp);
	} else if (cp > xcp) {		/* move forward */
		while (cp > xcp)
			x_zotc((unsigned char)*xcp++);
	}
}

static void
x_bs(int c)
{
	int i;

	i = x_size(c);
	while (i--)
		x_e_putc('\b');
}

static int
x_size_str(char *cp)
{
	int size = 0;
	while (*cp)
		size += x_size(*cp++);
	return size;
}

static int
x_size(int c)
{
	if (c=='\t')
		return 4;	/* Kludge, tabs are always four spaces. */
	if (iscntrl(c))		/* control char */
		return 2;
	if (isu8cont(c))
		return 0;
	return 1;
}

static void
x_zots(char *str)
{
	int	adj = x_adj_done;

	if (str > xbuf && isu8cont(*str)) {
		while (str > xbuf && isu8cont(*str))
			str--;
		x_e_putc('\b');
	}
	x_lastcp();
	while (*str && str < xlp && adj == x_adj_done)
		x_zotc(*str++);
}

static void
x_zotc(int c)
{
	if (c == '\t') {
		/*  Kludge, tabs are always four spaces.  */
		x_e_puts("    ");
	} else if (iscntrl(c)) {
		x_e_putc('^');
		x_e_putc(UNCTRL(c));
	} else
		x_e_putc(c);
}

static int
x_mv_back(int c)
{
	int col = xcp - xbuf;

	if (col == 0) {
		x_e_putc(BEL);
		return KSTD;
	}
	if (x_arg > col)
		x_arg = col;
	while (x_arg < col && isu8cont(xcp[-x_arg]))
		x_arg++;
	x_goto(xcp - x_arg);
	return KSTD;
}

static int
x_mv_forw(int c)
{
	int nleft = xep - xcp;

	if (!nleft) {
		x_e_putc(BEL);
		return KSTD;
	}
	if (x_arg > nleft)
		x_arg = nleft;
	while (x_arg < nleft && isu8cont(xcp[x_arg]))
		x_arg++;
	x_goto(xcp + x_arg);
	return KSTD;
}

static int
x_search_char_forw(int c)
{
	char *cp = xcp;

	*xep = '\0';
	c = x_e_getc();
	while (x_arg--) {
		if (c < 0 ||
		    ((cp = (cp == xep) ? NULL : strchr(cp + 1, c)) == NULL &&
		    (cp = strchr(xbuf, c)) == NULL)) {
			x_e_putc(BEL);
			return KSTD;
		}
	}
	x_goto(cp);
	return KSTD;
}

static int
x_search_char_back(int c)
{
	char *cp = xcp, *p;

	c = x_e_getc();
	for (; x_arg--; cp = p)
		for (p = cp; ; ) {
			if (p-- == xbuf)
				p = xep;
			if (c < 0 || p == cp) {
				x_e_putc(BEL);
				return KSTD;
			}
			if (*p == c)
				break;
		}
	x_goto(cp);
	return KSTD;
}

static int
x_newline(int c)
{
	x_e_putc('\r');
	x_e_putc('\n');
	x_flush();
	*xep++ = '\n';
	return KEOL;
}

static int
x_end_of_text(int c)
{
	x_zotc(edchars.eof);
	x_putc('\r');
	x_putc('\n');
	x_flush();
	return KEOL;
}

static int x_beg_hist(int c) { x_load_hist(history); return KSTD;}

static int x_end_hist(int c) { x_load_hist(histptr); return KSTD;}

static int x_prev_com(int c) { x_load_hist(x_histp - x_arg); return KSTD;}

static int x_next_com(int c) { x_load_hist(x_histp + x_arg); return KSTD;}

/* Goto a particular history number obtained from argument.
 * If no argument is given history 1 is probably not what you
 * want so we'll simply go to the oldest one.
 */
static int
x_goto_hist(int c)
{
	if (x_arg_defaulted)
		x_load_hist(history);
	else
		x_load_hist(histptr + x_arg - source->line);
	return KSTD;
}

static void
x_load_hist(char **hp)
{
	int	oldsize;

	if (hp < history || hp > histptr) {
		x_e_putc(BEL);
		return;
	}
	x_histp = hp;
	oldsize = x_size_str(xbuf);
	strlcpy(xbuf, *hp, xend - xbuf);
	xbp = xbuf;
	xep = xcp = xbuf + strlen(xbuf);
	xlp_valid = false;
	if (xep <= x_lastcp())
		x_redraw(oldsize);
	x_goto(xep);
}

static int
x_nl_next_com(int c)
{
	x_nextcmd = source->line - (histptr - x_histp) + 1;
	return (x_newline(c));
}

static int
x_eot_del(int c)
{
	if (xep == xbuf && x_arg_defaulted)
		return (x_end_of_text(c));
	else
		return (x_del_char(c));
}

static void *
kb_find_hist_func(char c)
{
	struct kb_entry		*k;
	char			line[LINE + 1];

	line[0] = c;
	line[1] = '\0';
	TAILQ_FOREACH(k, &kblist, entry)
		if (!strcmp(k->seq, line))
			return (k->ftab->xf_func);

	return (x_insert);
}

/* reverse incremental history search */
static int
x_search_hist(int c)
{
	int offset = -1;	/* offset of match in xbuf, else -1 */
	char pat [256+1];	/* pattern buffer */
	char *p = pat;
	int (*f)(int);

	*p = '\0';
	while (1) {
		if (offset < 0) {
			x_e_puts("\nI-search: ");
			x_e_puts(pat);
		}
		x_flush();
		if ((c = x_e_getc()) < 0)
			return KSTD;
		f = kb_find_hist_func(c);
		if (c == CTRL('[')) {
			x_e_ungetc(c);
			break;
		} else if (f == x_search_hist)
			offset = x_search(pat, 0, offset);
		else if (f == x_del_back) {
			if (p == pat) {
				offset = -1;
				break;
			}
			if (p > pat)
				*--p = '\0';
			if (p == pat)
				offset = -1;
			else
				offset = x_search(pat, 1, offset);
			continue;
		} else if (f == x_insert) {
			/* add char to pattern */
			/* overflow check... */
			if (p >= &pat[sizeof(pat) - 1]) {
				x_e_putc(BEL);
				continue;
			}
			*p++ = c, *p = '\0';
			if (offset >= 0) {
				/* already have partial match */
				offset = x_match(xbuf, pat);
				if (offset >= 0) {
					x_goto(xbuf + offset + (p - pat) -
					    (*pat == '^'));
					continue;
				}
			}
			offset = x_search(pat, 0, offset);
		} else { /* other command */
			x_e_ungetc(c);
			break;
		}
	}
	if (offset < 0)
		x_redraw(-1);
	return KSTD;
}

/* search backward from current line */
static int
x_search(char *pat, int sameline, int offset)
{
	char **hp;
	int i;

	for (hp = x_histp - (sameline ? 0 : 1) ; hp >= history; --hp) {
		i = x_match(*hp, pat);
		if (i >= 0) {
			if (offset < 0)
				x_e_putc('\n');
			x_load_hist(hp);
			x_goto(xbuf + i + strlen(pat) - (*pat == '^'));
			return i;
		}
	}
	x_e_putc(BEL);
	x_histp = histptr;
	return -1;
}

/* return position of first match of pattern in string, else -1 */
static int
x_match(char *str, char *pat)
{
	if (*pat == '^') {
		return (strncmp(str, pat+1, strlen(pat+1)) == 0) ? 0 : -1;
	} else {
		char *q = strstr(str, pat);
		return (q == NULL) ? -1 : q - str;
	}
}

static int
x_del_line(int c)
{
	int	i, j;

	*xep = 0;
	i = xep - xbuf;
	j = x_size_str(xbuf);
	xcp = xbuf;
	x_push(i);
	xlp = xbp = xep = xbuf;
	xlp_valid = true;
	*xcp = 0;
	xmp = NULL;
	x_redraw(j);
	return KSTD;
}

static int
x_mv_end(int c)
{
	x_goto(xep);
	return KSTD;
}

static int
x_mv_begin(int c)
{
	x_goto(xbuf);
	return KSTD;
}

static int
x_draw_line(int c)
{
	x_redraw(-1);
	return KSTD;

}

/* Redraw (part of) the line.  If limit is < 0, the everything is redrawn
 * on a NEW line, otherwise limit is the screen column up to which needs
 * redrawing.
 */
static void
x_redraw(int limit)
{
	int	i, j, truncate = 0;
	char	*cp;

	x_adj_ok = 0;
	if (limit == -1)
		x_e_putc('\n');
	else
		x_e_putc('\r');
	x_flush();
	if (xbp == xbuf) {
		x_col = promptlen(prompt, NULL);
		if (x_col > xx_cols)
			truncate = (x_col / xx_cols) * xx_cols;
		if (prompt_redraw)
			pprompt(prompt + prompt_skip, truncate);
	}
	if (x_col > xx_cols)
		x_col = x_col - (x_col / xx_cols) * xx_cols;
	x_displen = xx_cols - 2 - x_col;
	if (x_displen < 1) {
		x_col = 0;
		x_displen = xx_cols - 2;
	}
	xlp_valid = false;
	cp = x_lastcp();
	x_zots(xbp);
	if (xbp != xbuf || xep > xlp)
		limit = xx_cols;
	if (limit >= 0) {
		if (xep > xlp)
			i = 0;			/* we fill the line */
		else
			i = limit - (xlp - xbp);

		for (j = 0; j < i && x_col < (xx_cols - 2); j++)
			x_e_putc(' ');
		i = ' ';
		if (xep > xlp) {		/* more off screen */
			if (xbp > xbuf)
				i = '*';
			else
				i = '>';
		} else if (xbp > xbuf)
			i = '<';
		x_e_putc(i);
		j++;
		while (j--)
			x_e_putc('\b');
	}
	for (cp = xlp; cp > xcp; )
		x_bs(*--cp);
	x_adj_ok = 1;
#ifdef DEBUG
	x_flush();
#endif
	return;
}

static int
x_transpose(int c)
{
	char	tmp;

	/* What transpose is meant to do seems to be up for debate. This
	 * is a general summary of the options; the text is abcd with the
	 * upper case character or underscore indicating the cursor position:
	 *     Who			Before	After  Before	After
	 *     at&t ksh in emacs mode:	abCd	abdC   abcd_	(bell)
	 *     at&t ksh in gmacs mode:	abCd	baCd   abcd_	abdc_
	 *     gnu emacs:		abCd	acbD   abcd_	abdc_
	 * Pdksh currently goes with GNU behavior since I believe this is the
	 * most common version of emacs, unless in gmacs mode, in which case
	 * it does the at&t ksh gmacs mode.
	 * This should really be broken up into 3 functions so users can bind
	 * to the one they want.
	 */
	if (xcp == xbuf) {
		x_e_putc(BEL);
		return KSTD;
	} else if (xcp == xep || Flag(FGMACS)) {
		if (xcp - xbuf == 1) {
			x_e_putc(BEL);
			return KSTD;
		}
		/* Gosling/Unipress emacs style: Swap two characters before the
		 * cursor, do not change cursor position
		 */
		x_bs(xcp[-1]);
		x_bs(xcp[-2]);
		x_zotc(xcp[-1]);
		x_zotc(xcp[-2]);
		tmp = xcp[-1];
		xcp[-1] = xcp[-2];
		xcp[-2] = tmp;
	} else {
		/* GNU emacs style: Swap the characters before and under the
		 * cursor, move cursor position along one.
		 */
		x_bs(xcp[-1]);
		x_zotc(xcp[0]);
		x_zotc(xcp[-1]);
		tmp = xcp[-1];
		xcp[-1] = xcp[0];
		xcp[0] = tmp;
		x_bs(xcp[0]);
		x_goto(xcp + 1);
	}
	return KSTD;
}

static int
x_literal(int c)
{
	x_literal_set = 1;
	return KSTD;
}

static int
x_kill(int c)
{
	int col = xcp - xbuf;
	int lastcol = xep - xbuf;
	int ndel;

	if (x_arg_defaulted)
		x_arg = lastcol;
	else if (x_arg > lastcol)
		x_arg = lastcol;
	while (x_arg < lastcol && isu8cont(xbuf[x_arg]))
		x_arg++;
	ndel = x_arg - col;
	if (ndel < 0) {
		x_goto(xbuf + x_arg);
		ndel = -ndel;
	}
	x_delete(ndel, true);
	return KSTD;
}

static void
x_push(int nchars)
{
	char	*cp = str_nsave(xcp, nchars, AEDIT);
	afree(killstack[killsp], AEDIT);
	killstack[killsp] = cp;
	killsp = (killsp + 1) % KILLSIZE;
}

static int
x_yank(int c)
{
	if (killsp == 0)
		killtp = KILLSIZE;
	else
		killtp = killsp;
	killtp --;
	if (killstack[killtp] == 0) {
		x_e_puts("\nnothing to yank");
		x_redraw(-1);
		return KSTD;
	}
	xmp = xcp;
	x_ins(killstack[killtp]);
	return KSTD;
}

static int
x_meta_yank(int c)
{
	int	len;
	if ((x_last_command != x_yank && x_last_command != x_meta_yank) ||
	    killstack[killtp] == 0) {
		killtp = killsp;
		x_e_puts("\nyank something first");
		x_redraw(-1);
		return KSTD;
	}
	len = strlen(killstack[killtp]);
	x_goto(xcp - len);
	x_delete(len, false);
	do {
		if (killtp == 0)
			killtp = KILLSIZE - 1;
		else
			killtp--;
	} while (killstack[killtp] == 0);
	x_ins(killstack[killtp]);
	return KSTD;
}

static int
x_abort(int c)
{
	/* x_zotc(c); */
	xlp = xep = xcp = xbp = xbuf;
	xlp_valid = true;
	*xcp = 0;
	return KINTR;
}

static int
x_error(int c)
{
	x_e_putc(BEL);
	return KSTD;
}

static char *
kb_encode(const char *s)
{
	static char		l[LINE + 1];
	int			at = 0;

	l[at] = '\0';
	while (*s) {
		if (*s == '^') {
			s++;
			if (*s >= '?')
				l[at++] = CTRL(*s);
			else {
				l[at++] = '^';
				s--;
			}
		} else
			l[at++] = *s;
		l[at] = '\0';
		s++;
	}
	return (l);
}

static char *
kb_decode(const char *s)
{
	static char		l[LINE + 1];
	int			i, at = 0;

	l[0] = '\0';
	for (i = 0; i < strlen(s); i++) {
		if (iscntrl((unsigned char)s[i])) {
			l[at++] = '^';
			l[at++] = UNCTRL(s[i]);
		} else
			l[at++] = s[i];
		l[at] = '\0';
	}

	return (l);
}

static int
kb_match(char *s)
{
	int			len = strlen(s);
	struct kb_entry		*k;

	TAILQ_FOREACH(k, &kblist, entry) {
		if (len > k->len)
			continue;

		if (memcmp(k->seq, s, len) == 0)
			return (1);
	}

	return (0);
}

static void
kb_del(struct kb_entry *k)
{
	TAILQ_REMOVE(&kblist, k, entry);
	free(k->args);
	afree(k, AEDIT);
}

static struct kb_entry *
kb_add_string(void *func, void *args, char *str)
{
	int			i, count;
	struct kb_entry		*k;
	struct x_ftab		*xf = NULL;

	for (i = 0; i < NELEM(x_ftab); i++)
		if (x_ftab[i].xf_func == func) {
			xf = (struct x_ftab *)&x_ftab[i];
			break;
		}
	if (xf == NULL)
		return (NULL);

	if (kb_match(str)) {
		if (x_bind_quiet == 0)
			bi_errorf("duplicate binding for %s", kb_decode(str));
		return (NULL);
	}
	count = strlen(str);

	k = alloc(sizeof *k + count + 1, AEDIT);
	k->seq = (unsigned char *)(k + 1);
	k->len = count;
	k->ftab = xf;
	k->args = args ? strdup(args) : NULL;

	strlcpy(k->seq, str, count + 1);

	TAILQ_INSERT_TAIL(&kblist, k, entry);

	return (k);
}

static struct kb_entry *
kb_add(void *func, void *args, ...)
{
	va_list			ap;
	int			i, count;
	char			l[LINE + 1];

	va_start(ap, args);
	count = 0;
	while (va_arg(ap, unsigned int) != 0)
		count++;
	va_end(ap);

	va_start(ap, args);
	for (i = 0; i <= count /* <= is correct */; i++)
		l[i] = (unsigned char)va_arg(ap, unsigned int);
	va_end(ap);

	return (kb_add_string(func, args, l));
}

static void
kb_print(struct kb_entry *k)
{
	if (!(k->ftab->xf_flags & XF_NOBIND))
		shprintf("%s = %s\n",
		    kb_decode(k->seq), k->ftab->xf_name);
	else if (k->args) {
		shprintf("%s = ", kb_decode(k->seq));
		shprintf("'%s'\n", kb_decode(k->args));
	}
}

int
x_bind(const char *a1, const char *a2,
	int macro,		/* bind -m */
	int list)		/* bind -l */
{
	int			i;
	struct kb_entry		*k, *kb;
	char			in[LINE + 1];

	if (x_tty == 0) {
		bi_errorf("cannot bind, not a tty");
		return (1);
	}

	if (list) {
		/* show all function names */
		for (i = 0; i < NELEM(x_ftab); i++) {
			if (x_ftab[i].xf_name == NULL)
				continue;
			if (x_ftab[i].xf_name &&
			    !(x_ftab[i].xf_flags & XF_NOBIND))
				shprintf("%s\n", x_ftab[i].xf_name);
		}
		return (0);
	}

	if (a1 == NULL) {
		/* show all bindings */
		TAILQ_FOREACH(k, &kblist, entry)
			kb_print(k);
		return (0);
	}

	snprintf(in, sizeof in, "%s", kb_encode(a1));
	if (a2 == NULL) {
		/* print binding */
		TAILQ_FOREACH(k, &kblist, entry)
			if (!strcmp(k->seq, in)) {
				kb_print(k);
				return (0);
			}
		shprintf("%s = %s\n", kb_decode(a1), "auto-insert");
		return (0);
	}

	if (strlen(a2) == 0) {
		/* clear binding */
		TAILQ_FOREACH_SAFE(k, &kblist, entry, kb)
			if (!strcmp(k->seq, in)) {
				kb_del(k);
				break;
			}
		return (0);
	}

	/* set binding */
	if (macro) {
		/* delete old mapping */
		TAILQ_FOREACH_SAFE(k, &kblist, entry, kb)
			if (!strcmp(k->seq, in)) {
				kb_del(k);
				break;
			}
		kb_add_string(x_ins_string, kb_encode(a2), in);
		return (0);
	}

	/* set non macro binding */
	for (i = 0; i < NELEM(x_ftab); i++) {
		if (x_ftab[i].xf_name == NULL)
			continue;
		if (!strcmp(x_ftab[i].xf_name, a2)) {
			/* delete old mapping */
			TAILQ_FOREACH_SAFE(k, &kblist, entry, kb)
				if (!strcmp(k->seq, in)) {
					kb_del(k);
					break;
				}
			kb_add_string(x_ftab[i].xf_func, NULL, in);
			return (0);
		}
	}
	bi_errorf("%s: no such function", a2);
	return (1);
}

void
x_init_emacs(void)
{
	x_tty = 1;
	ainit(AEDIT);
	x_nextcmd = -1;

	TAILQ_INIT(&kblist);

	/* man page order */
	kb_add(x_abort,			NULL, CTRL('G'), 0);
	kb_add(x_mv_back,		NULL, CTRL('B'), 0);
	kb_add(x_mv_back,		NULL, CTRL('X'), CTRL('D'), 0);
	kb_add(x_mv_bword,		NULL, CTRL('['), 'b', 0);
	kb_add(x_beg_hist,		NULL, CTRL('['), '<', 0);
	kb_add(x_mv_begin,		NULL, CTRL('A'), 0);
	kb_add(x_fold_capitalize,	NULL, CTRL('['), 'C', 0);
	kb_add(x_fold_capitalize,	NULL, CTRL('['), 'c', 0);
	kb_add(x_comment,		NULL, CTRL('['), '#', 0);
	kb_add(x_complete,		NULL, CTRL('['), CTRL('['), 0);
	kb_add(x_comp_comm,		NULL, CTRL('X'), CTRL('['), 0);
	kb_add(x_comp_file,		NULL, CTRL('['), CTRL('X'), 0);
	kb_add(x_comp_list,		NULL, CTRL('I'), 0);
	kb_add(x_comp_list,		NULL, CTRL('['), '=', 0);
	kb_add(x_del_back,		NULL, CTRL('?'), 0);
	kb_add(x_del_back,		NULL, CTRL('H'), 0);
	kb_add(x_del_char,		NULL, CTRL('['), '[', '3', '~', 0); /* delete */
	kb_add(x_del_bword,		NULL, CTRL('['), CTRL('?'), 0);
	kb_add(x_del_bword,		NULL, CTRL('['), CTRL('H'), 0);
	kb_add(x_del_bword,		NULL, CTRL('['), 'h', 0);
	kb_add(x_del_fword,		NULL, CTRL('['), 'd', 0);
	kb_add(x_next_com,		NULL, CTRL('N'), 0);
	kb_add(x_next_com,		NULL, CTRL('X'), 'B', 0);
	kb_add(x_fold_lower,		NULL, CTRL('['), 'L', 0);
	kb_add(x_fold_lower,		NULL, CTRL('['), 'l', 0);
	kb_add(x_end_hist,		NULL, CTRL('['), '>', 0);
	kb_add(x_mv_end,		NULL, CTRL('E'), 0);
	/* how to handle: eot: ^_, underneath copied from original keybindings */
	kb_add(x_end_of_text,		NULL, CTRL('_'), 0);
	kb_add(x_eot_del,		NULL, CTRL('D'), 0);
	/* error */
	kb_add(x_xchg_point_mark,	NULL, CTRL('X'), CTRL('X'), 0);
	kb_add(x_expand,		NULL, CTRL('['), '*', 0);
	kb_add(x_mv_forw,		NULL, CTRL('F'), 0);
	kb_add(x_mv_forw,		NULL, CTRL('X'), 'C', 0);
	kb_add(x_mv_fword,		NULL, CTRL('['), 'f', 0);
	kb_add(x_goto_hist,		NULL, CTRL('['), 'g', 0);
	/* kill-line */
	kb_add(x_del_bword,		NULL, CTRL('W'), 0); /* not what man says */
	kb_add(x_kill,			NULL, CTRL('K'), 0);
	kb_add(x_enumerate,		NULL, CTRL('['), '?', 0);
	kb_add(x_list_comm,		NULL, CTRL('X'), '?', 0);
	kb_add(x_list_file,		NULL, CTRL('X'), CTRL('Y'), 0);
	kb_add(x_newline,		NULL, CTRL('J'), 0);
	kb_add(x_newline,		NULL, CTRL('M'), 0);
	kb_add(x_nl_next_com,		NULL, CTRL('O'), 0);
	/* no-op */
	kb_add(x_prev_histword,		NULL, CTRL('['), '.', 0);
	kb_add(x_prev_histword,		NULL, CTRL('['), '_', 0);
	/* how to handle: quote: ^^ */
	kb_add(x_draw_line,		NULL, CTRL('L'), 0);
	kb_add(x_search_char_back,	NULL, CTRL('['), CTRL(']'), 0);
	kb_add(x_search_char_forw,	NULL, CTRL(']'), 0);
	kb_add(x_search_hist,		NULL, CTRL('R'), 0);
	kb_add(x_set_mark,		NULL, CTRL('['), ' ', 0);
	kb_add(x_transpose,		NULL, CTRL('T'), 0);
	kb_add(x_prev_com,		NULL, CTRL('P'), 0);
	kb_add(x_prev_com,		NULL, CTRL('X'), 'A', 0);
	kb_add(x_fold_upper,		NULL, CTRL('['), 'U', 0);
	kb_add(x_fold_upper,		NULL, CTRL('['), 'u', 0);
	kb_add(x_literal,		NULL, CTRL('V'), 0);
	kb_add(x_literal,		NULL, CTRL('^'), 0);
	kb_add(x_yank,			NULL, CTRL('Y'), 0);
	kb_add(x_meta_yank,		NULL, CTRL('['), 'y', 0);
	/* man page ends here */

	/* arrow keys */
	kb_add(x_prev_com,		NULL, CTRL('['), '[', 'A', 0); /* up */
	kb_add(x_next_com,		NULL, CTRL('['), '[', 'B', 0); /* down */
	kb_add(x_mv_forw,		NULL, CTRL('['), '[', 'C', 0); /* right */
	kb_add(x_mv_back,		NULL, CTRL('['), '[', 'D', 0); /* left */
	kb_add(x_prev_com,		NULL, CTRL('['), 'O', 'A', 0); /* up */
	kb_add(x_next_com,		NULL, CTRL('['), 'O', 'B', 0); /* down */
	kb_add(x_mv_forw,		NULL, CTRL('['), 'O', 'C', 0); /* right */
	kb_add(x_mv_back,		NULL, CTRL('['), 'O', 'D', 0); /* left */

	/* more navigation keys */
	kb_add(x_mv_begin,		NULL, CTRL('['), '[', 'H', 0); /* home */
	kb_add(x_mv_end,		NULL, CTRL('['), '[', 'F', 0); /* end */
	kb_add(x_mv_begin,		NULL, CTRL('['), 'O', 'H', 0); /* home */
	kb_add(x_mv_end,		NULL, CTRL('['), 'O', 'F', 0); /* end */
	kb_add(x_mv_begin,		NULL, CTRL('['), '[', '1', '~', 0); /* home */
	kb_add(x_mv_end,		NULL, CTRL('['), '[', '4', '~', 0); /* end */

	/* can't be bound */
	kb_add(x_set_arg,		NULL, CTRL('['), '0', 0);
	kb_add(x_set_arg,		NULL, CTRL('['), '1', 0);
	kb_add(x_set_arg,		NULL, CTRL('['), '2', 0);
	kb_add(x_set_arg,		NULL, CTRL('['), '3', 0);
	kb_add(x_set_arg,		NULL, CTRL('['), '4', 0);
	kb_add(x_set_arg,		NULL, CTRL('['), '5', 0);
	kb_add(x_set_arg,		NULL, CTRL('['), '6', 0);
	kb_add(x_set_arg,		NULL, CTRL('['), '7', 0);
	kb_add(x_set_arg,		NULL, CTRL('['), '8', 0);
	kb_add(x_set_arg,		NULL, CTRL('['), '9', 0);

	/* ctrl arrow keys */
	kb_add(x_mv_end,		NULL, CTRL('['), '[', '1', ';', '5', 'A', 0); /* ctrl up */
	kb_add(x_mv_begin,		NULL, CTRL('['), '[', '1', ';', '5', 'B', 0); /* ctrl down */
	kb_add(x_mv_fword,		NULL, CTRL('['), '[', '1', ';', '5', 'C', 0); /* ctrl right */
	kb_add(x_mv_bword,		NULL, CTRL('['), '[', '1', ';', '5', 'D', 0); /* ctrl left */
}

void
x_emacs_keys(X_chars *ec)
{
	x_bind_quiet = 1;
	if (ec->erase >= 0) {
		kb_add(x_del_back, NULL, ec->erase, 0);
		kb_add(x_del_bword, NULL, CTRL('['), ec->erase, 0);
	}
	if (ec->kill >= 0)
		kb_add(x_del_line, NULL, ec->kill, 0);
	if (ec->werase >= 0)
		kb_add(x_del_bword, NULL, ec->werase, 0);
	if (ec->intr >= 0)
		kb_add(x_abort, NULL, ec->intr, 0);
	if (ec->quit >= 0)
		kb_add(x_noop, NULL, ec->quit, 0);
	x_bind_quiet = 0;
}

static int
x_set_mark(int c)
{
	xmp = xcp;
	return KSTD;
}

static int
x_kill_region(int c)
{
	int	rsize;
	char	*xr;

	if (xmp == NULL) {
		x_e_putc(BEL);
		return KSTD;
	}
	if (xmp > xcp) {
		rsize = xmp - xcp;
		xr = xcp;
	} else {
		rsize = xcp - xmp;
		xr = xmp;
	}
	x_goto(xr);
	x_delete(rsize, true);
	xmp = xr;
	return KSTD;
}

static int
x_xchg_point_mark(int c)
{
	char	*tmp;

	if (xmp == NULL) {
		x_e_putc(BEL);
		return KSTD;
	}
	tmp = xmp;
	xmp = xcp;
	x_goto( tmp );
	return KSTD;
}

static int
x_version(int c)
{
	char *o_xbuf = xbuf, *o_xend = xend;
	char *o_xbp = xbp, *o_xep = xep, *o_xcp = xcp;
	int lim = x_lastcp() - xbp;

	xbuf = xbp = xcp = (char *) ksh_version + 4;
	xend = xep = (char *) ksh_version + 4 + strlen(ksh_version + 4);
	x_redraw(lim);
	x_flush();

	c = x_e_getc();
	xbuf = o_xbuf;
	xend = o_xend;
	xbp = o_xbp;
	xep = o_xep;
	xcp = o_xcp;
	x_redraw(strlen(ksh_version));

	if (c < 0)
		return KSTD;
	/* This is what at&t ksh seems to do...  Very bizarre */
	if (c != ' ')
		x_e_ungetc(c);

	return KSTD;
}

static int
x_noop(int c)
{
	return KSTD;
}

/*
 *	File/command name completion routines
 */

static int
x_comp_comm(int c)
{
	do_complete(XCF_COMMAND, CT_COMPLETE);
	return KSTD;
}
static int
x_list_comm(int c)
{
	do_complete(XCF_COMMAND, CT_LIST);
	return KSTD;
}
static int
x_complete(int c)
{
	do_complete(XCF_COMMAND_FILE, CT_COMPLETE);
	return KSTD;
}
static int
x_enumerate(int c)
{
	do_complete(XCF_COMMAND_FILE, CT_LIST);
	return KSTD;
}
static int
x_comp_file(int c)
{
	do_complete(XCF_FILE, CT_COMPLETE);
	return KSTD;
}
static int
x_list_file(int c)
{
	do_complete(XCF_FILE, CT_LIST);
	return KSTD;
}
static int
x_comp_list(int c)
{
	do_complete(XCF_COMMAND_FILE, CT_COMPLIST);
	return KSTD;
}
static int
x_expand(int c)
{
	char **words;
	int nwords = 0;
	int start, end;
	int is_command;
	int i;

	nwords = x_cf_glob(XCF_FILE, xbuf, xep - xbuf, xcp - xbuf,
	    &start, &end, &words, &is_command);

	if (nwords == 0) {
		x_e_putc(BEL);
		return KSTD;
	}

	x_goto(xbuf + start);
	x_delete(end - start, false);
	for (i = 0; i < nwords;) {
		if (x_escape(words[i], strlen(words[i]), x_do_ins) < 0 ||
		    (++i < nwords && x_ins(" ") < 0)) {
			x_e_putc(BEL);
			return KSTD;
		}
	}
	x_adjust();

	return KSTD;
}

/* type == 0 for list, 1 for complete and 2 for complete-list */
static void
do_complete(int flags,	/* XCF_{COMMAND,FILE,COMMAND_FILE} */
    Comp_type type)
{
	char **words;
	int nwords;
	int start, end, nlen, olen;
	int is_command;
	int completed = 0;

	nwords = x_cf_glob(flags, xbuf, xep - xbuf, xcp - xbuf,
	    &start, &end, &words, &is_command);
	/* no match */
	if (nwords == 0) {
		x_e_putc(BEL);
		return;
	}

	if (type == CT_LIST) {
		x_print_expansions(nwords, words, is_command);
		x_redraw(0);
		x_free_words(nwords, words);
		return;
	}

	olen = end - start;
	nlen = x_longest_prefix(nwords, words);
	/* complete */
	if (nwords == 1 || nlen > olen) {
		x_goto(xbuf + start);
		x_delete(olen, false);
		x_escape(words[0], nlen, x_do_ins);
		x_adjust();
		completed = 1;
	}
	/* add space if single non-dir match */
	if (nwords == 1 && words[0][nlen - 1] != '/') {
		x_ins(" ");
		completed = 1;
	}

	if (type == CT_COMPLIST && !completed) {
		x_print_expansions(nwords, words, is_command);
		completed = 1;
	}

	if (completed)
		x_redraw(0);

	x_free_words(nwords, words);
}

/* NAME:
 *      x_adjust - redraw the line adjusting starting point etc.
 *
 * DESCRIPTION:
 *      This function is called when we have exceeded the bounds
 *      of the edit window.  It increments x_adj_done so that
 *      functions like x_ins and x_delete know that we have been
 *      called and can skip the x_bs() stuff which has already
 *      been done by x_redraw.
 *
 * RETURN VALUE:
 *      None
 */

static void
x_adjust(void)
{
	x_adj_done++;			/* flag the fact that we were called. */
	/*
	 * we had a problem if the prompt length > xx_cols / 2
	 */
	if ((xbp = xcp - (x_displen / 2)) < xbuf)
		xbp = xbuf;
	xlp_valid = false;
	x_redraw(xx_cols);
	x_flush();
}

static int unget_char = -1;

static void
x_e_ungetc(int c)
{
	unget_char = c;
}

static int
x_e_getc(void)
{
	int c;

	if (unget_char >= 0) {
		c = unget_char;
		unget_char = -1;
	} else if (macro_args) {
		c = *macro_args++;
		if (!c) {
			macro_args = NULL;
			c = x_getc();
		}
	} else
		c = x_getc();

	return c;
}

static int
x_e_getu8(char *buf, int off)
{
	int	c, cc, len;

	c = x_e_getc();
	if (c == -1)
		return -1;
	buf[off++] = c;

	if (c == 0xf4)
		len = 4;
	else if ((c & 0xf0) == 0xe0)
		len = 3;
	else if ((c & 0xe0) == 0xc0 && c > 0xc1)
		len = 2;
	else
		len = 1;

	for (; len > 1; len--) {
		cc = x_e_getc();
		if (cc == -1)
			break;
		if (isu8cont(cc) == 0 ||
		    (c == 0xe0 && len == 3 && cc < 0xa0) ||
		    (c == 0xed && len == 3 && cc & 0x20) ||
		    (c == 0xf4 && len == 4 && cc & 0x30)) {
			x_e_ungetc(cc);
			break;
		}
		buf[off++] = cc;
	}
	buf[off] = '\0';

	return off;
}

static void
x_e_putc(int c)
{
	if (c == '\r' || c == '\n')
		x_col = 0;
	if (x_col < xx_cols) {
		x_putc(c);
		switch (c) {
		case BEL:
			break;
		case '\r':
		case '\n':
			break;
		case '\b':
			x_col--;
			break;
		default:
			if (!isu8cont(c))
				x_col++;
			break;
		}
	}
	if (x_adj_ok && (x_col < 0 || x_col >= (xx_cols - 2)))
		x_adjust();
}

#ifdef DEBUG
static int
x_debug_info(int c)
{
	x_flush();
	shellf("\nksh debug:\n");
	shellf("\tx_col == %d,\t\tx_cols == %d,\tx_displen == %d\n",
	    x_col, xx_cols, x_displen);
	shellf("\txcp == 0x%lx,\txep == 0x%lx\n", (long) xcp, (long) xep);
	shellf("\txbp == 0x%lx,\txbuf == 0x%lx\n", (long) xbp, (long) xbuf);
	shellf("\txlp == 0x%lx\n", (long) xlp);
	shellf("\txlp == 0x%lx\n", (long) x_lastcp());
	shellf("\n");
	x_redraw(-1);
	return 0;
}
#endif

static void
x_e_puts(const char *s)
{
	int	adj = x_adj_done;

	while (*s && adj == x_adj_done)
		x_e_putc(*s++);
}

/* NAME:
 *      x_set_arg - set an arg value for next function
 *
 * DESCRIPTION:
 *      This is a simple implementation of M-[0-9].
 *
 * RETURN VALUE:
 *      KSTD
 */

static int
x_set_arg(int c)
{
	int n = 0;
	int first = 1;

	for (; c >= 0 && isdigit(c); c = x_e_getc(), first = 0)
		n = n * 10 + (c - '0');
	if (c < 0 || first) {
		x_e_putc(BEL);
		x_arg = 1;
		x_arg_defaulted = 1;
	} else {
		x_e_ungetc(c);
		x_arg = n;
		x_arg_defaulted = 0;
		x_arg_set = 1;
	}
	return KSTD;
}


/* Comment or uncomment the current line. */
static int
x_comment(int c)
{
	int oldsize = x_size_str(xbuf);
	int len = xep - xbuf;
	int ret = x_do_comment(xbuf, xend - xbuf, &len);

	if (ret < 0)
		x_e_putc(BEL);
	else {
		xep = xbuf + len;
		*xep = '\0';
		xcp = xbp = xbuf;
		x_redraw(oldsize);
		if (ret > 0)
			return x_newline('\n');
	}
	return KSTD;
}


/* NAME:
 *      x_prev_histword - recover word from prev command
 *
 * DESCRIPTION:
 *      This function recovers the last word from the previous
 *      command and inserts it into the current edit line.  If a
 *      numeric arg is supplied then the n'th word from the
 *      start of the previous command is used.
 *
 *      Bound to M-.
 *
 * RETURN VALUE:
 *      KSTD
 */

static int
x_prev_histword(int c)
{
	char *rcp;
	char *cp;

	cp = *histptr;
	if (!cp)
		x_e_putc(BEL);
	else if (x_arg_defaulted) {
		rcp = &cp[strlen(cp) - 1];
		/*
		 * ignore white-space after the last word
		 */
		while (rcp > cp && is_cfs(*rcp))
			rcp--;
		while (rcp > cp && !is_cfs(*rcp))
			rcp--;
		if (is_cfs(*rcp))
			rcp++;
		x_ins(rcp);
	} else {
		int c;

		rcp = cp;
		/*
		 * ignore white-space at start of line
		 */
		while (*rcp && is_cfs(*rcp))
			rcp++;
		while (x_arg-- > 1) {
			while (*rcp && !is_cfs(*rcp))
				rcp++;
			while (*rcp && is_cfs(*rcp))
				rcp++;
		}
		cp = rcp;
		while (*rcp && !is_cfs(*rcp))
			rcp++;
		c = *rcp;
		*rcp = '\0';
		x_ins(cp);
		*rcp = c;
	}
	return KSTD;
}

/* Uppercase N(1) words */
static int
x_fold_upper(int c)
{
	return x_fold_case('U');
}

/* Lowercase N(1) words */
static int
x_fold_lower(int c)
{
	return x_fold_case('L');
}

/* Lowercase N(1) words */
static int
x_fold_capitalize(int c)
{
	return x_fold_case('C');
}

/* NAME:
 *      x_fold_case - convert word to UPPER/lower/Capital case
 *
 * DESCRIPTION:
 *      This function is used to implement M-U,M-u,M-L,M-l,M-C and M-c
 *      to UPPER case, lower case or Capitalize words.
 *
 * RETURN VALUE:
 *      None
 */

static int
x_fold_case(int c)
{
	char *cp = xcp;

	if (cp == xep) {
		x_e_putc(BEL);
		return KSTD;
	}
	while (x_arg--) {
		/*
		 * first skip over any white-space
		 */
		while (cp != xep && is_mfs(*cp))
			cp++;
		/*
		 * do the first char on its own since it may be
		 * a different action than for the rest.
		 */
		if (cp != xep) {
			if (c == 'L') {		/* lowercase */
				if (isupper((unsigned char)*cp))
					*cp = tolower((unsigned char)*cp);
			} else {		/* uppercase, capitalize */
				if (islower((unsigned char)*cp))
					*cp = toupper((unsigned char)*cp);
			}
			cp++;
		}
		/*
		 * now for the rest of the word
		 */
		while (cp != xep && !is_mfs(*cp)) {
			if (c == 'U') {		/* uppercase */
				if (islower((unsigned char)*cp))
					*cp = toupper((unsigned char)*cp);
			} else {		/* lowercase, capitalize */
				if (isupper((unsigned char)*cp))
					*cp = tolower((unsigned char)*cp);
			}
			cp++;
		}
	}
	x_goto(cp);
	return KSTD;
}

/* NAME:
 *      x_lastcp - last visible byte
 *
 * SYNOPSIS:
 *      x_lastcp()
 *
 * DESCRIPTION:
 *      This function returns a pointer to that byte in the
 *      edit buffer that will be the last displayed on the
 *      screen.  The sequence:
 *
 *      for (cp = x_lastcp(); cp > xcp; cp)
 *        x_bs(*--cp);
 *
 *      Will position the cursor correctly on the screen.
 *
 * RETURN VALUE:
 *      cp or NULL
 */

static char *
x_lastcp(void)
{
	char *rcp;
	int i;

	if (!xlp_valid) {
		for (i = 0, rcp = xbp; rcp < xep && i < x_displen; rcp++)
			i += x_size((unsigned char)*rcp);
		xlp = rcp;
	}
	xlp_valid = true;
	return (xlp);
}

#endif /* EDIT */
@


1.72
log
@Drop needless comment

ok anton@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.71 2017/08/29 23:04:50 jca Exp $	*/
a1453 3

	/* XXX unused */
	Flag(FEMACSUSEMETA) = 1;
@


1.71
log
@Kill a useless setlocale() query

Pointless since the removal of the setlocale() call in main.c:rev1.82,
the emacs-usemeta flag isn't used in the code since 2012.  This kills
a chunk of code in a statically linked ksh.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.70 2017/06/25 17:28:39 anton Exp $	*/
a1457 1
	/* new keybinding stuff */
@


1.70
log
@No need to NUL-terminate the line buffer since it's handled by x_e_getu8() by
now.

ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.69 2017/06/25 08:51:52 anton Exp $	*/
a20 1
#include <locale.h>
a1450 2
	char *locale;

d1455 2
a1456 7
	/* Determine if we can translate meta key or use 8-bit AscII
	 * XXX - It would be nice if there was a locale attribute to
	 * determine if the locale is 7-bit or not.
	 */
	locale = setlocale(LC_CTYPE, NULL);
	if (locale == NULL || !strcmp(locale, "C") || !strcmp(locale, "POSIX"))
		Flag(FEMACSUSEMETA) = 1;
@


1.69
log
@Don't output partial UTF-8 characters in ksh emacs mode. Instead, try to read a
complete UTF-8 character first. Fixes an issue while running ksh in tmux where
UTF-8 characters inserted in columns other than the last one are discarded.

With help from nicm@@ and schwarze@@ who also wrote the UTF-8 validation, thanks!

ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.68 2017/06/20 17:32:20 brynet Exp $	*/
a311 1
	line[0] = '\0';
a393 1
		line[0] = '\0';
@


1.68
log
@'^T' is documented to be bounded to transpose-chars while in emacs
mode, not "stuff". While here, remove the poorly described "stuff"
and "stuff" bind functions as well..

In the unlikely event anyone has those in .kshrc, they'll need to
be removed.

ok anton@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.67 2017/05/12 14:37:52 schwarze Exp $	*/
d138 1
d277 1
a277 1
	int			at = 0, submatch, ret, c;
d318 1
a318 1
		if ((c = x_e_getc()) < 0)
d320 1
a320 3

		line[at++] = c;
		line[at] = '\0';
d358 1
a358 1
				ret = kmatch->ftab->xf_func(c);
d362 8
a369 4
			if (at == 1)
				ret = x_insert(c);
			else
				ret = x_error(c); /* not matched meta sequence */
d394 1
a394 1
		at = 0;
d1858 37
@


1.67
log
@Improve UTF-8 handling on lines that are wider than the terminal,
in two respects:

1. During output in x_e_putc(), when counting display columns,
skip UTF-8 continuation bytes.  Fixes backward movements that
cause horizontal scrolling.

2. After deleting characters, recalculate the last byte that fits
on the line.

Patch from <Anton dot Lindqvist at gmail dot com> on tech@@.
OK millert@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.66 2016/08/09 11:04:46 schwarze Exp $	*/
a187 2
static int	x_stuff(int);
static int	x_stuffreset(int);
a244 2
	{ x_stuff,		"stuff",			0 },
	{ x_stuffreset,		"stuff-reset",			0 },
a1225 30
static int
x_stuffreset(int c)
{
#ifdef TIOCSTI
	(void)x_stuff(c);
	return KINTR;
#else
	x_zotc(c);
	xlp = xcp = xep = xbp = xbuf;
	xlp_valid = true;
	*xcp = 0;
	x_redraw(-1);
	return KSTD;
#endif
}

static int
x_stuff(int c)
{
#ifdef TIOCSTI
	char	ch = c;
	bool	savmode = x_mode(false);

	(void)ioctl(TTY, TIOCSTI, &ch);
	(void)x_mode(savmode);
	x_redraw(-1);
#endif
	return KSTD;
}

a1523 4
#if defined(TIOCSTI)
	kb_add(x_stuff,			NULL, CTRL('T'), 0);
	/* stuff-reset */
#else
a1524 1
#endif
@


1.66
log
@In emacs incremental search mode (^R),
make commands starting with the escape key (^[) work as documented.
Long-standing bug, this time reported by Dave minus Cohen dot com.
OK natano@@ halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.65 2016/01/26 17:39:31 mmcc Exp $	*/
d536 1
d1913 2
a1914 1
			x_col++;
@


1.65
log
@remove a useless macro

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.64 2016/01/08 13:17:57 schwarze Exp $	*/
d896 2
a897 1
		if (c == CTRL('['))
d899 1
a899 1
		else if (f == x_search_hist)
@


1.64
log
@Next step in UTF-8 support:

1. Improve all functions involving words by allowing non-ASCII
characters to be part of words.
2. Allow insertion of non-ASCII characters without screwing up the
display, by backing up to the start byte after inserting a continuation
byte, and starting to re-print there.
3. Fix forward movement which i didn't get quite right in my previous
commit: Always advance to a start byte, never to a final continuation
byte, or the next insertion would split the character in the middle.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.63 2015/12/30 15:21:42 tedu Exp $	*/
d1073 3
a1075 1
	D__(x_flush();)
@


1.63
log
@add another combo for home/end keys that works in tmux.
ok bmercer gsoares nicm sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.62 2015/12/14 13:59:42 tb Exp $	*/
d54 2
a55 1
#define	is_mfs(c)	(!(isalnum((unsigned char)c) || c == '_' || c == '$'))
d687 5
d738 1
a738 1
	while (x_arg < nleft && isu8cont(xcp[x_arg + 1]))
@


1.62
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.61 2015/12/10 10:00:14 schwarze Exp $	*/
d1579 2
@


1.61
log
@In emacs command-line editing mode, make sure that moving left and
right can only move by whole characters, not into the middle of a
character, and that deleting characters can only delete characters
whole, not individual bytes out of characters.
Based on parts of a patch by Frederic Nowak <fnwk at mailbox dot org>,
tweaked by me.
OK tedu@@ semarie@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.60 2015/10/19 14:42:16 mmcc Exp $	*/
d22 2
@


1.60
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.59 2015/10/19 02:15:45 mmcc Exp $	*/
d85 1
a85 1
static char    *xlp;		/* last char visible on screen */
d141 1
d267 6
d478 2
d496 2
d502 1
a502 1
/* Delete nc chars to the right of the cursor (including cursor position) */
d674 2
d713 2
d730 2
d1139 2
d2130 1
a2130 1
 *      x_lastcp - last visible char
d2136 1
a2136 1
 *      This function returns a pointer to that  char in the
@


1.59
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.58 2015/10/16 23:18:59 mmcc Exp $	*/
d22 1
@


1.58
log
@Change x_do_ins()'s arg type from int to size_t for correctness's sake,
and to silence a compiler warning. Also remove its prototype, which is
directly above its definition.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.57 2015/10/16 17:14:04 mmcc Exp $	*/
d17 1
a17 1
#include "sh.h"
d19 1
a19 1
#include <sys/queue.h>
d22 2
@


1.57
log
@Cast iscntrl()'s arg to unsigned char.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.56 2015/10/10 15:31:00 millert Exp $	*/
a415 2
static int x_do_ins(const char *cp, int len);

d417 1
a417 1
x_do_ins(const char *cp, int len)
@


1.56
log
@Replace calls to x_emacs_putbuf() with x_do_ins() since all
x_emacs_putbuf() does is call x_do_ins().
From mksh via Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.55 2015/10/10 07:38:18 nicm Exp $	*/
d1260 1
a1260 1
		if (iscntrl(s[i])) {
@


1.55
log
@Unused macros; from Michael McConville.
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.54 2015/10/09 19:36:27 tedu Exp $	*/
a137 1
static int	x_emacs_putbuf(const char *, size_t);
a458 13
/*
 * this is used for x_escape() in do_complete()
 */
static int
x_emacs_putbuf(const char *s, size_t len)
{
	int rval;

	if ((rval = x_do_ins(s, len)) != 0)
		return (rval);
	return (rval);
}

d1742 1
a1742 1
		if (x_escape(words[i], strlen(words[i]), x_emacs_putbuf) < 0 ||
d1785 1
a1785 1
		x_escape(words[0], nlen, x_emacs_putbuf);
@


1.54
log
@remove null check before afree. from Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.53 2015/09/18 07:28:24 nicm Exp $	*/
a28 3
#define	META(x)		((x) & 0x7f)
#define	ISMETA(x)	(Flag(FEMACSUSEMETA) && ((x) & 0x80))

@


1.53
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.52 2015/09/10 22:48:58 nicm Exp $	*/
d1151 1
a1151 2
	if (killstack[killsp])
		afree(killstack[killsp], AEDIT);
@


1.52
log
@Replace newline and space defines by "\n" and " " directly, from Michael
McConville. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.51 2015/09/01 13:12:31 tedu Exp $	*/
d1022 1
a1022 1
		x_col = promptlen(prompt, (const char **) 0);
@


1.51
log
@remove casts and null checks before free. from Michael McConville
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.50 2015/03/25 12:10:52 jca Exp $	*/
d1761 1
a1761 1
		    (++i < nwords && x_ins(space) < 0)) {
d1809 1
a1809 1
		x_ins(space);
d1917 1
a1917 1
	shellf(newline);
@


1.50
log
@Bind the Delete key (ESC[3~) to delete-char-forward

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.49 2015/02/16 01:44:41 tedu Exp $	*/
d1152 1
a1152 1
		afree((void *)killstack[killsp], AEDIT);
d1310 1
a1310 2
	if (k->args)
		free(k->args);
@


1.49
log
@bcmp to memcmp
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.48 2013/12/17 16:37:05 deraadt Exp $	*/
d1506 1
a1506 1
	/* x_del_char not assigned by default */
@


1.48
log
@ctype cleanups.  Repeated re-audits of this sensitive area by okan and
myself, with a variety of other people spending some time as well.
Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.47 2013/11/28 10:33:37 sobrado Exp $	*/
d334 1
a334 1
				if (!bcmp(k->seq, line, at)) {
d1299 1
a1299 1
		if (!bcmp(k->seq, s, len))
@


1.47
log
@remove trailing whitespaces; use tabs instead of spaces where appropriate;
no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.46 2012/06/10 10:15:01 mpi Exp $	*/
d50 3
a52 1
#define	is_mfs(c)	(!(isalnum(c) || c == '_' || c == '$'))  /* Separator for motion */
d534 1
a534 1
		j += x_size(*cp++);
d646 1
a646 1
			x_bs(*--xcp);
d649 1
a649 1
			x_zotc(*xcp++);
d2102 2
a2103 2
				if (isupper(*cp))
					*cp = tolower(*cp);
d2105 2
a2106 2
				if (islower(*cp))
					*cp = toupper(*cp);
d2115 2
a2116 2
				if (islower(*cp))
					*cp = toupper(*cp);
d2118 2
a2119 2
				if (isupper(*cp))
					*cp = tolower(*cp);
d2156 1
a2156 1
			i += x_size(*rcp);
@


1.46
log
@Correctly expand bindings containing macros. Fix a regression introduced
in the keybinding system rewrite, reported by Lars Engblom.
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.45 2012/04/30 03:51:29 djm Exp $	*/
d78 2
a79 2
static char   *xbuf;		/* beg input buffer */
static char   *xend;		/* end input buffer */
d107 1
a107 1
static	char    *killstack[KILLSIZE];
d111 1
a111 1
static	char    *macro_args;
d115 2
a116 2
static int      x_ins(char *);
static void     x_delete(int, int);
d119 9
a127 9
static void     x_goto(char *);
static void     x_bs(int);
static int      x_size_str(char *);
static int      x_size(int);
static void     x_zots(char *);
static void     x_zotc(int);
static void     x_load_hist(char **);
static int      x_search(char *, int, int);
static int      x_match(char *, char *);
d129 1
a129 1
static void     x_push(int);
d348 1
a348 1
			    	/* treat macro string as input */
@


1.45
log
@generalise ksh keybinding system - bindings are no longer limited in
length and need not start with ESC or ^X; patch from marco@@ feedback mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.44 2011/09/05 04:50:33 marco Exp $	*/
d111 1
d347 6
a352 5
			    kmatch->args) {
				/* insert macro string */
				x_ins(kmatch->args);
			}
			ret = kmatch->ftab->xf_func(c);
d415 1
a415 1
	return KSTD;
d1867 6
@


1.44
log
@Fix hang in emacs mode.  To reproduce the hang go like: "^[16000l" which
would insert 16000 letter l'.  Going over the line limit makes no sense
so limit it's repetition and prevent the hang in the process.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.43 2011/03/14 21:20:01 okan Exp $	*/
d9 3
d19 1
a43 6
struct x_defbindings {
	u_char		xdb_func;	/* XFUNC_* */
	unsigned char	xdb_tab;
	unsigned char	xdb_char;
};

a51 4
# define CHARMASK	0xFF		/* 8-bit character mask */
# define X_NTABS	3		/* normal, meta1, meta2 */
#define X_TABSZ		(CHARMASK+1)	/* size of keydef tables etc */

d63 11
d99 3
a102 1
static	int	x_prefix1 = CTRL('['), x_prefix2 = CTRL('X');
a105 4
static	u_char	x_last_command;
static	u_char	(*x_tab)[X_TABSZ];	/* key definition */
static	char    *(*x_atab)[X_TABSZ];	/* macro definitions */
static	unsigned char	x_bound[(X_TABSZ * X_NTABS + 7) / 8];
d109 2
a110 2
static	int	x_curprefix;
static	char    *macroptr;
a128 3
static char *   x_mapin(const char *, Area *);
static char *   x_mapout(int);
static void     x_print(int, int);
d140 58
a198 9
/* The lines between START-FUNC-TAB .. END-FUNC-TAB are run through a
 * script (emacs-gen.sh) that generates emacs.out which contains:
 *	- function declarations for x_* functions
 *	- defines of the form XFUNC_<name> where <name> is function
 *	  name, sans leading x_.
 * Note that the script treats #ifdef and { 0, 0, 0} specially - use with
 * caution.
 */
#include "emacs.out"
a199 1
/* @@START-FUNC-TAB@@ */
a223 2
	{ x_meta1,		"prefix-1",			XF_PREFIX },
	{ x_meta2,		"prefix-2",			XF_PREFIX },
a260 87
/* @@END-FUNC-TAB@@ */
};

static	struct x_defbindings const x_defbindings[] = {
	{ XFUNC_del_back,		0, CTRL('?') },
	{ XFUNC_del_bword,		1, CTRL('?') },
	{ XFUNC_eot_del,		0, CTRL('D') },
	{ XFUNC_del_back,		0, CTRL('H') },
	{ XFUNC_del_bword,		1, CTRL('H') },
	{ XFUNC_del_bword,		1,      'h'  },
	{ XFUNC_mv_bword,		1,      'b'  },
	{ XFUNC_mv_fword,		1,      'f'  },
	{ XFUNC_del_fword,		1,      'd'  },
	{ XFUNC_mv_back,		0, CTRL('B') },
	{ XFUNC_mv_forw,		0, CTRL('F') },
	{ XFUNC_search_char_forw,	0, CTRL(']') },
	{ XFUNC_search_char_back,	1, CTRL(']') },
	{ XFUNC_newline,		0, CTRL('M') },
	{ XFUNC_newline,		0, CTRL('J') },
	{ XFUNC_end_of_text,		0, CTRL('_') },
	{ XFUNC_abort,			0, CTRL('G') },
	{ XFUNC_prev_com,		0, CTRL('P') },
	{ XFUNC_next_com,		0, CTRL('N') },
	{ XFUNC_nl_next_com,		0, CTRL('O') },
	{ XFUNC_search_hist,		0, CTRL('R') },
	{ XFUNC_beg_hist,		1,      '<'  },
	{ XFUNC_end_hist,		1,      '>'  },
	{ XFUNC_goto_hist,		1,      'g'  },
	{ XFUNC_mv_end,			0, CTRL('E') },
	{ XFUNC_mv_begin,		0, CTRL('A') },
	{ XFUNC_draw_line,		0, CTRL('L') },
	{ XFUNC_meta1,			0, CTRL('[') },
	{ XFUNC_meta2,			0, CTRL('X') },
	{ XFUNC_kill,			0, CTRL('K') },
	{ XFUNC_yank,			0, CTRL('Y') },
	{ XFUNC_meta_yank,		1,      'y'  },
	{ XFUNC_literal,		0, CTRL('^') },
	{ XFUNC_comment,		1,	'#'  },
#if defined(TIOCSTI)
	{ XFUNC_stuff,			0, CTRL('T') },
#else
	{ XFUNC_transpose,		0, CTRL('T') },
#endif
	{ XFUNC_complete,		1, CTRL('[') },
	{ XFUNC_comp_list,		0, CTRL('I') },
	{ XFUNC_comp_list,		1,	'='  },
	{ XFUNC_enumerate,		1,	'?'  },
	{ XFUNC_expand,			1,	'*'  },
	{ XFUNC_comp_file,		1, CTRL('X') },
	{ XFUNC_comp_comm,		2, CTRL('[') },
	{ XFUNC_list_comm,		2,	'?'  },
	{ XFUNC_list_file,		2, CTRL('Y') },
	{ XFUNC_set_mark,		1,	' '  },
	{ XFUNC_kill_region,		0, CTRL('W') },
	{ XFUNC_xchg_point_mark,	2, CTRL('X') },
	{ XFUNC_literal,		0, CTRL('V') },
#ifdef DEBUG
	{ XFUNC_debug_info,		1, CTRL('H') },
#endif
	{ XFUNC_prev_histword,		1,	'.'  },
	{ XFUNC_prev_histword,		1,	'_'  },
	{ XFUNC_set_arg,		1,	'0'  },
	{ XFUNC_set_arg,		1,	'1'  },
	{ XFUNC_set_arg,		1,	'2'  },
	{ XFUNC_set_arg,		1,	'3'  },
	{ XFUNC_set_arg,		1,	'4'  },
	{ XFUNC_set_arg,		1,	'5'  },
	{ XFUNC_set_arg,		1,	'6'  },
	{ XFUNC_set_arg,		1,	'7'  },
	{ XFUNC_set_arg,		1,	'8'  },
	{ XFUNC_set_arg,		1,	'9'  },
	{ XFUNC_fold_upper,		1,	'U'  },
	{ XFUNC_fold_upper,		1,	'u'  },
	{ XFUNC_fold_lower,		1,	'L'  },
	{ XFUNC_fold_lower,		1,	'l'  },
	{ XFUNC_fold_capitalize,	1,	'C'  },
	{ XFUNC_fold_capitalize,	1,	'c'  },
	/* These for ansi arrow keys: arguablely shouldn't be here by
	 * default, but its simpler/faster/smaller than using termcap
	 * entries.
	 */
	{ XFUNC_meta2,			1,	'['  },
	{ XFUNC_meta2,			1,	'O'  },
	{ XFUNC_prev_com,		2,	'A'  },
	{ XFUNC_next_com,		2,	'B'  },
	{ XFUNC_mv_forw,		2,	'C'  },
	{ XFUNC_mv_back,		2,	'D'  },
d266 4
a269 4
	int	c;
	const char *p;
	int	i;
	u_char f;
a275 1
	x_curprefix = 0;
a276 1
	x_last_command = XFUNC_error;
d303 4
d312 6
a317 3
		if (ISMETA(c)) {
			c = META(c);
			x_curprefix = 1;
d320 10
a329 2
		f = x_curprefix == -1 ? XFUNC_insert :
		    x_tab[x_curprefix][c&CHARMASK];
d331 6
a336 2
		if (macroptr && f == XFUNC_ins_string)
		    f = XFUNC_insert;
d338 20
a357 4
		if (!(x_ftab[f].xf_flags & XF_PREFIX) &&
		    x_last_command != XFUNC_set_arg) {
			x_arg = 1;
			x_arg_defaulted = 1;
d359 2
a360 3
		i = c | (x_curprefix << 8);
		x_curprefix = 0;
		switch (i = (*x_ftab[f].xf_func)(i)) {
d362 4
a365 2
			if (!(x_ftab[f].xf_flags & XF_PREFIX))
				x_last_command = f;
d368 4
a371 3
			i = xep - xbuf;
			return i;
		case KINTR:	/* special case for interrupt */
d375 4
d380 8
a412 9
	if (macroptr) {
		x_e_putc(BEL);
		return KSTD;
	}
	macroptr = x_atab[c>>8][c & CHARMASK];
	if (macroptr && !*macroptr) {
		/* XXX bell? */
		macroptr = (char *) 0;
	}
d849 15
d871 1
a871 1
	u_char f;
d882 1
a882 1
		f = x_tab[0][c&CHARMASK];
d885 1
a885 1
		else if (f == XFUNC_search_hist)
d887 1
a887 1
		else if (f == XFUNC_del_back) {
d899 1
a899 1
		} else if (f == XFUNC_insert) {
d1119 1
a1119 15
	x_curprefix = -1;
	return KSTD;
}

static int
x_meta1(int c)
{
	x_curprefix = 1;
	return KSTD;
}

static int
x_meta2(int c)
{
	x_curprefix = 2;
d1175 1
a1175 1
	if ((x_last_command != XFUNC_yank && x_last_command != XFUNC_meta_yank) ||
d1243 1
a1243 1
x_mapin(const char *cp, Area *area)
d1245 2
a1246 1
	char *new, *op;
d1248 6
a1253 7
	op = new = str_save(cp, area);
	while (*cp) {
		/* XXX -- should handle \^ escape? */
		if (*cp == '^') {
			cp++;
			if (*cp >= '?')	/* includes '?'; ASCII */
				*op++ = CTRL(*cp);
d1255 2
a1256 2
				*op++ = '^';
				cp--;
d1259 38
a1296 2
			*op++ = *cp;
		cp++;
a1297 1
	*op = '\0';
d1299 10
a1308 1
	return new;
d1311 37
a1347 2
static char *
x_mapout(int c)
d1349 3
a1351 2
	static char buf[8];
	char *p = buf;
d1353 12
a1364 7
	if (iscntrl(c)) {
		*p++ = '^';
		*p++ = UNCTRL(c);
	} else
		*p++ = c;
	*p = 0;
	return buf;
d1368 1
a1368 1
x_print(int prefix, int key)
d1370 7
a1376 9
	if (prefix == 1)
		shprintf("%s", x_mapout(x_prefix1));
	if (prefix == 2)
		shprintf("%s", x_mapout(x_prefix2));
	shprintf("%s = ", x_mapout(key));
	if (x_tab[prefix][key] != XFUNC_ins_string)
		shprintf("%s\n", x_ftab[x_tab[prefix][key]].xf_name);
	else
		shprintf("'%s'\n", x_atab[prefix][key]);
d1380 1
a1380 1
x_bind( const char *a1, const char *a2,
d1384 3
a1386 4
	u_char f;
	int prefix, key;
	char *sp = NULL;
	char *m1, *m2;
d1388 1
a1388 1
	if (x_tab == NULL) {
d1390 1
a1390 1
		return 1;
a1392 1
	/* List function names */
d1394 9
a1402 5
		for (f = 0; f < NELEM(x_ftab); f++)
			if (x_ftab[f].xf_name &&
			    !(x_ftab[f].xf_flags & XF_NOBIND))
				shprintf("%s\n", x_ftab[f].xf_name);
		return 0;
d1406 13
a1418 7
		for (prefix = 0; prefix < X_NTABS; prefix++)
			for (key = 0; key < X_TABSZ; key++) {
				f = x_tab[prefix][key];
				if (f == XFUNC_insert || f == XFUNC_error ||
				    (macro && f != XFUNC_ins_string))
					continue;
				x_print(prefix, key);
d1420 2
a1421 1
		return 0;
d1424 8
a1431 10
	m2 = m1 = x_mapin(a1, ATEMP);
	prefix = key = 0;
	for (;; m1++) {
		key = *m1 & CHARMASK;
		if (x_tab[prefix][key] == XFUNC_meta1)
			prefix = 1;
		else if (x_tab[prefix][key] == XFUNC_meta2)
			prefix = 2;
		else
			break;
a1432 1
	afree(m2, ATEMP);
d1434 10
a1443 3
	if (a2 == NULL) {
		x_print(prefix, key);
		return 0;
d1446 13
a1458 10
	if (*a2 == 0)
		f = XFUNC_insert;
	else if (!macro) {
		for (f = 0; f < NELEM(x_ftab); f++)
			if (x_ftab[f].xf_name &&
			    strcmp(x_ftab[f].xf_name, a2) == 0)
				break;
		if (f == NELEM(x_ftab) || x_ftab[f].xf_flags & XF_NOBIND) {
			bi_errorf("%s: no such function", a2);
			return 1;
a1459 9
#if 0		/* This breaks the bind commands that map arrow keys */
		if (f == XFUNC_meta1)
			x_prefix1 = key;
		if (f == XFUNC_meta2)
			x_prefix2 = key;
#endif /* 0 */
	} else {
		f = XFUNC_ins_string;
		sp = x_mapin(a2, AEDIT);
d1461 2
a1462 15

	if (x_tab[prefix][key] == XFUNC_ins_string && x_atab[prefix][key])
		afree((void *)x_atab[prefix][key], AEDIT);
	x_tab[prefix][key] = f;
	x_atab[prefix][key] = sp;

	/* Track what the user has bound so x_emacs_keys() won't toast things */
	if (f == XFUNC_insert)
		x_bound[(prefix * X_TABSZ + key) / 8] &=
		    ~(1 << ((prefix * X_TABSZ + key) % 8));
	else
		x_bound[(prefix * X_TABSZ + key) / 8] |=
		    (1 << ((prefix * X_TABSZ + key) % 8));

	return 0;
a1467 1
	int i, j;
d1470 1
a1473 15
	x_tab = (u_char (*)[X_TABSZ]) alloc(sizeofN(*x_tab, X_NTABS), AEDIT);
	for (j = 0; j < X_TABSZ; j++)
		x_tab[0][j] = XFUNC_insert;
	for (i = 1; i < X_NTABS; i++)
		for (j = 0; j < X_TABSZ; j++)
			x_tab[i][j] = XFUNC_error;
	for (i = 0; i < NELEM(x_defbindings); i++)
		x_tab[(unsigned char)x_defbindings[i].xdb_tab][x_defbindings[i].xdb_char]
		    = x_defbindings[i].xdb_func;

	x_atab = (char *(*)[X_TABSZ]) alloc(sizeofN(*x_atab, X_NTABS), AEDIT);
	for (i = 1; i < X_NTABS; i++)
		for (j = 0; j < X_TABSZ; j++)
			x_atab[i][j] = NULL;

a1480 1
}
d1482 2
a1483 1
static void bind_if_not_bound(int p, int k, int func);
d1485 105
a1589 9
static void
bind_if_not_bound(int p, int k, int func)
{
	/* Has user already bound this key?  If so, don't override it */
	if (x_bound[((p) * X_TABSZ + (k)) / 8] &
	    (1 << (((p) * X_TABSZ + (k)) % 8)))
		return;

	x_tab[p][k] = func;
d1595 1
d1597 2
a1598 2
		bind_if_not_bound(0, ec->erase, XFUNC_del_back);
		bind_if_not_bound(1, ec->erase, XFUNC_del_bword);
d1601 1
a1601 1
		bind_if_not_bound(0, ec->kill, XFUNC_del_line);
d1603 1
a1603 1
		bind_if_not_bound(0, ec->werase, XFUNC_del_bword);
d1605 1
a1605 1
		bind_if_not_bound(0, ec->intr, XFUNC_abort);
d1607 2
a1608 1
		bind_if_not_bound(0, ec->quit, XFUNC_noop);
d1865 2
a1866 10
	} else {
		if (macroptr) {
			c = *macroptr++;
			if (!c) {
				macroptr = NULL;
				c = x_getc();
			}
		} else
			c = x_getc();
	}
d1868 1
a1868 1
	return c <= CHARMASK ? c : (c & CHARMASK);
d1939 1
a1939 2
	c &= CHARMASK;	/* strip command prefix */
	for (; c >= 0 && isdigit(c); c = x_e_getc(), first = 0) {
a1940 5
		if (n < 0 || n > LINE) {
			c = -1;
			break;
		}
	}
d1949 1
@


1.43
log
@remove unused SILLY game of life.

no binary change.

sure @@deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.42 2009/06/02 06:47:47 halex Exp $	*/
d1790 1
a1790 1
	for (; c >= 0 && isdigit(c); c = x_e_getc(), first = 0)
d1792 5
@


1.42
log
@fix macro handling
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.41 2007/08/02 10:50:25 fgsch Exp $	*/
a207 3
#ifdef SILLY
	{ x_game_of_life,	"play-game-of-life",		0 },
#else
a208 1
#endif
a1532 52
#ifdef SILLY
static int
x_game_of_life(int c)
{
	char	newbuf [256+1];
	char	*ip, *op;
	int	i, len;

	i = xep - xbuf;
	*xep = 0;
	len = x_size_str(xbuf);
	xcp = xbp = xbuf;
	memmove(newbuf+1, xbuf, i);
	newbuf[0] = 'A';
	newbuf[i] = 'A';
	for (ip = newbuf+1, op = xbuf; --i >= 0; ip++, op++) {
		/*  Empty space  */
		if (*ip < '@@' || *ip == '_' || *ip == 0x7F) {
			/*  Two adults, make whoopee */
			if (ip[-1] < '_' && ip[1] < '_') {
				/*  Make kid look like parents.  */
				*op = '`' + ((ip[-1] + ip[1])/2)%32;
				if (*op == 0x7F) /* Birth defect */
					*op = '`';
			}
			else
				*op = ' ';	/* nothing happens */
			continue;
		}
		/*  Child */
		if (*ip > '`') {
			/*  All alone, dies  */
			if (ip[-1] == ' ' && ip[1] == ' ')
				*op = ' ';
			else	/*  Gets older */
				*op = *ip-'`'+'@@';
			continue;
		}
		/*  Adult  */
		/*  Overcrowded, dies */
		if (ip[-1] >= '@@' && ip[1] >= '@@') {
			*op = ' ';
			continue;
		}
		*op = *ip;
	}
	*op = 0;
	x_redraw(len);
	return KSTD;
}
#endif

a1535 1

@


1.41
log
@fix memory leaks and one potential null deref found by coverity. from netbsd.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.40 2006/07/10 17:12:41 beck Exp $	*/
a321 1
	macroptr = (char *) 0;
d363 3
d1767 4
a1770 2
			if (!*macroptr)
				macroptr = (char *) 0;
@


1.40
log
@fix ksh prompt wrapping, from Marcus Glocker <marcus@@nazgul.ch>.
tested by me and naddy, and others...
ok naddy@@ and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.39 2005/09/26 19:25:22 otto Exp $	*/
d126 1
a126 1
static char *   x_mapin(const char *);
d1247 1
a1247 1
x_mapin(const char *cp)
d1251 1
a1251 1
	op = new = str_save(cp, ATEMP);
d1336 1
a1336 1
	m1 = x_mapin(a1);
d1347 1
d1373 1
a1373 2
		m2 = x_mapin(a2);
		sp = str_save(m2, AEDIT);
@


1.39
log
@Fix a redraw problem that occurs when a recalled history line has
length equal to screen width - 2. Spotted by jmc@@, tested by various.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.38 2005/08/01 04:27:31 deraadt Exp $	*/
d109 1
d330 3
d337 6
d998 1
a998 1
	int	i, j;
a1007 1
		pprompt(prompt + prompt_skip, 0);
d1009 4
d1014 2
d1017 4
@


1.38
log
@pascoe noted that ^V in ksh emacs mode is not what you expect -- literal
next as it is every other canonical mode, or emulation of canonical mode.
change it to act like it should
ok djm david marc tdeval pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.37 2005/03/30 17:16:37 deraadt Exp $	*/
d823 3
a825 4
	if (xep > x_lastcp())
	  x_goto(xep);
	else
	  x_redraw(oldsize);
@


1.37
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.36 2005/03/28 21:28:22 deraadt Exp $	*/
d273 1
a273 1
	{ XFUNC_version,		0, CTRL('V') },
@


1.36
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.35 2005/02/17 18:57:04 otto Exp $	*/
d34 1
a34 1
struct	x_ftab  {
d200 7
a206 7
        { x_comp_list,		"complete-list",		0 },
        { x_expand,		"expand-file",			0 },
        { x_fold_capitalize,	"capitalize-word",		XF_ARG },
        { x_fold_lower,		"downcase-word",		XF_ARG },
        { x_fold_upper,		"upcase-word",			XF_ARG },
        { x_set_arg,		"set-arg",			XF_NOBIND },
        { x_comment,		"comment",			0 },
d213 1
a213 1
        { x_debug_info,		"debug-info",			0 },
d219 1
a219 1
    };
d255 1
a255 1
        { XFUNC_comment,		1,	'#'  },
d263 1
a263 1
        { XFUNC_comp_list,		1,	'='  },
d265 1
a265 1
        { XFUNC_expand,			1,	'*'  },
d275 1
a275 1
        { XFUNC_debug_info,		1, CTRL('H') },
d279 16
a294 16
        { XFUNC_set_arg,		1,	'0'  },
        { XFUNC_set_arg,		1,	'1'  },
        { XFUNC_set_arg,		1,	'2'  },
        { XFUNC_set_arg,		1,	'3'  },
        { XFUNC_set_arg,		1,	'4'  },
        { XFUNC_set_arg,		1,	'5'  },
        { XFUNC_set_arg,		1,	'6'  },
        { XFUNC_set_arg,		1,	'7'  },
        { XFUNC_set_arg,		1,	'8'  },
        { XFUNC_set_arg,		1,	'9'  },
        { XFUNC_fold_upper,		1,	'U'  },
        { XFUNC_fold_upper,		1,	'u'  },
        { XFUNC_fold_lower,		1,	'L'  },
        { XFUNC_fold_lower,		1,	'l'  },
        { XFUNC_fold_capitalize,	1,	'C'  },
        { XFUNC_fold_capitalize,	1,	'c'  },
d299 2
a300 2
        { XFUNC_meta2,			1,	'['  },
        { XFUNC_meta2,			1,	'O'  },
d351 2
a352 2
		f = x_curprefix == -1 ? XFUNC_insert
			: x_tab[x_curprefix][c&CHARMASK];
d354 2
a355 3
		if (!(x_ftab[f].xf_flags & XF_PREFIX)
		    && x_last_command != XFUNC_set_arg)
		{
d361 2
a362 2
		switch (i = (*x_ftab[f].xf_func)(i))  {
		  case KSTD:
d366 1
a366 1
		  case KEOL:
d369 1
a369 1
		  case KINTR:	/* special case for interrupt */
d385 1
a385 1
	if (c == 0)  {
d399 1
a399 1
	if (macroptr)   {
d444 4
a447 5
	if (adj == x_adj_done)	/* has x_adjust() been called? */
	{
	  /* no */
	  for (cp = xlp; cp > xcp; )
	    x_bs(*--cp);
d472 1
a472 1
	if (col == 0)  {
d524 1
a524 1
	while (i--)  {
d535 8
a542 9
	if ((i = xx_cols - 2 - x_col) > 0)
	{
	  j = (j < i) ? j : i;
	  i = j;
	  while (i--)
	    x_e_putc(' ');
	  i = j;
	  while (i--)
	    x_e_putc('\b');
d587 1
a587 1
	if (cp == xbuf)  {
d591 9
a599 12
	while (x_arg--)
	{
	  while (cp != xbuf && is_mfs(cp[-1]))
	  {
	    cp--;
	    nc++;
	  }
	  while (cp != xbuf && !is_mfs(cp[-1]))
	  {
	    cp--;
	    nc++;
	  }
d611 1
a611 1
	if (cp == xep)  {
d615 9
a623 12
	while (x_arg--)
	{
	  while (cp != xep && is_mfs(*cp))
	  {
	    cp++;
	    nc++;
	  }
	  while (cp != xep && !is_mfs(*cp))
	  {
	    cp++;
	    nc++;
	  }
d631 11
a641 22
  if (cp < xbp || cp >= (xbp + x_displen))
  {
    /* we are heading off screen */
    xcp = cp;
    x_adjust();
  }
  else
  {
    if (cp < xcp)		/* move back */
    {
      while (cp < xcp)
	x_bs(*--xcp);
    }
    else
    {
      if (cp > xcp)		/* move forward */
      {
	while (cp > xcp)
	  x_zotc(*xcp++);
      }
    }
  }
d648 1
d686 1
a686 1
	if (c == '\t')  {
d689 1
a689 1
	} else if (iscntrl(c))  {
d701 1
a701 1
	if (col == 0)  {
d734 6
a739 7
	    if (c < 0
	       || ((cp = (cp == xep) ? NULL : strchr(cp + 1, c)) == NULL
		   && (cp = strchr(xbuf, c)) == NULL))
	    {
		    x_e_putc(BEL);
		    return KSTD;
	    }
d892 2
a893 1
					x_goto(xbuf + offset + (p - pat) - (*pat == '^'));
d998 3
a1000 4
	if (xbp == xbuf)
	{
	  pprompt(prompt + prompt_skip, 0);
	  x_col = promptlen(prompt, (const char **) 0);
d1007 21
a1027 25
	  limit = xx_cols;
	if (limit >= 0)
	{
	  if (xep > xlp)
	    i = 0;			/* we fill the line */
	  else
	    i = limit - (xlp - xbp);

	  for (j = 0; j < i && x_col < (xx_cols - 2); j++)
	    x_e_putc(' ');
	  i = ' ';
	  if (xep > xlp)		/* more off screen */
	  {
	    if (xbp > xbuf)
	      i = '*';
	    else
	      i = '>';
	  }
	  else
	    if (xbp > xbuf)
	      i = '<';
	  x_e_putc(i);
	  j++;
	  while (j--)
	    x_e_putc('\b');
d1030 1
a1030 1
	  x_bs(*--cp);
d1147 1
a1147 1
	if (killstack[killtp] == 0)  {
d1161 2
a1162 2
	if ((x_last_command != XFUNC_yank && x_last_command != XFUNC_meta_yank)
	    || killstack[killtp] == 0) {
d1234 1
a1234 1
	while (*cp)  {
d1236 1
a1236 1
		if (*cp == '^')  {
d1240 1
a1240 1
			else  {
d1259 1
a1259 1
	if (iscntrl(c))  {
d1300 2
a1301 2
			if (x_ftab[f].xf_name
			    && !(x_ftab[f].xf_flags & XF_NOBIND))
d1310 2
a1311 2
				if (f == XFUNC_insert || f == XFUNC_error
				    || (macro && f != XFUNC_ins_string))
d1339 2
a1340 2
			if (x_ftab[f].xf_name
			    && strcmp(x_ftab[f].xf_name, a2) == 0)
d1366 1
a1366 1
			~(1 << ((prefix * X_TABSZ + key) % 8));
d1369 1
a1369 1
			(1 << ((prefix * X_TABSZ + key) % 8));
d1391 1
a1391 1
			= x_defbindings[i].xdb_func;
d1413 2
a1414 2
	if (x_bound[((p) * X_TABSZ + (k)) / 8]
	    & (1 << (((p) * X_TABSZ + (k)) % 8)))
d1532 1
a1532 1
	for (ip = newbuf+1, op = xbuf; --i >= 0; ip++, op++)  {
d1534 1
a1534 1
		if (*ip < '@@' || *ip == '_' || *ip == 0x7F)  {
d1536 1
a1536 1
			if (ip[-1] < '_' && ip[1] < '_')  {
d1547 1
a1547 1
		if (*ip > '`')  {
d1557 1
a1557 1
		if (ip[-1] >= '@@' && ip[1] >= '@@')  {
d1625 2
a1626 3
	nwords = x_cf_glob(XCF_FILE,
		xbuf, xep - xbuf, xcp - xbuf,
		&start, &end, &words, &is_command);
d1637 1
a1637 2
		    (++i < nwords && x_ins(space) < 0))
		{
d1659 1
a1659 1
			    &start, &end, &words, &is_command);
d1717 9
a1725 9
  x_adj_done++;			/* flag the fact that we were called. */
  /*
   * we had a problem if the prompt length > xx_cols / 2
   */
  if ((xbp = xcp - (x_displen / 2)) < xbuf)
    xbp = xbuf;
  xlp_valid = false;
  x_redraw(xx_cols);
  x_flush();
d1745 1
a1745 1
		if (macroptr)  {
d1759 20
a1778 24
  if (c == '\r' || c == '\n')
    x_col = 0;
  if (x_col < xx_cols)
  {
    x_putc(c);
    switch(c)
    {
    case BEL:
      break;
    case '\r':
    case '\n':
    break;
    case '\b':
      x_col--;
      break;
    default:
      x_col++;
      break;
    }
  }
  if (x_adj_ok && (x_col < 0 || x_col >= (xx_cols - 2)))
  {
    x_adjust();
  }
d1788 1
a1788 1
		 x_col, xx_cols, x_displen);
d1802 1
a1802 1
  int	adj = x_adj_done;
d1804 2
a1805 2
  while (*s && adj == x_adj_done)
    x_e_putc(*s++);
d1887 5
a1891 5
		  rcp = &cp[strlen(cp) - 1];
		  /*
		   * ignore white-space after the last word
		   */
		  while (rcp > cp && is_cfs(*rcp))
d1893 1
a1893 1
		  while (rcp > cp && !is_cfs(*rcp))
d1895 1
a1895 1
		  if (is_cfs(*rcp))
d1897 1
a1897 1
		  x_ins(rcp);
d1899 1
a1899 1
		  int c;
d1901 5
a1905 5
		  rcp = cp;
		  /*
		   * ignore white-space at start of line
		   */
		  while (*rcp && is_cfs(*rcp))
d1907 1
a1907 1
		  while (x_arg-- > 1) {
d1912 3
a1914 3
		  }
		  cp = rcp;
		  while (*rcp && !is_cfs(*rcp))
d1916 4
a1919 4
		  c = *rcp;
		  *rcp = '\0';
		  x_ins(cp);
		  *rcp = c;
@


1.35
log
@Printt ^D and newline on EOF in emacs mode like in vi mode.
Help and ok jaredy@@ ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.34 2004/12/23 11:29:02 jsg Exp $	*/
d63 5
a67 4
typedef enum { CT_LIST, 	/* list the possible completions */
		 CT_COMPLETE,	/* complete to longest prefix */
		 CT_COMPLIST	/* complete and then list (if non-exact) */
	} Comp_type;
@


1.34
log
@Replace home rolled unsigned char type with u_char.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.33 2004/12/22 17:14:34 millert Exp $	*/
d798 4
@


1.33
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.32 2004/12/20 11:34:26 otto Exp $	*/
a39 3
/* index into struct x_ftab x_ftab[] - small is good */
typedef unsigned char Findex;

d41 1
a41 1
	Findex		xdb_func;	/* XFUNC_* */
d98 2
a99 2
static	Findex   x_last_command;
static	Findex (*x_tab)[X_TABSZ];	/* key definition */
d312 1
a312 1
	Findex	f;
d867 1
a867 1
	Findex f;
d1306 1
a1306 1
	Findex f;
d1402 1
a1402 1
	x_tab = (Findex (*)[X_TABSZ]) alloc(sizeofN(*x_tab, X_NTABS), AEDIT);
@


1.32
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.31 2004/12/19 04:14:20 deraadt Exp $	*/
d320 1
a320 1
	xlp_valid = TRUE;
d374 1
a374 1
			x_mode(FALSE);
d443 1
a443 1
	xlp_valid = FALSE;
d483 1
a483 1
	x_delete(x_arg, FALSE);
d498 1
a498 1
	x_delete(x_arg, FALSE);
d551 1
a551 1
	xlp_valid = FALSE;
d561 1
a561 1
	x_delete(x_bword(), TRUE);
d582 1
a582 1
	x_delete(x_fword(), TRUE);
d840 1
a840 1
	xlp_valid = FALSE;
d970 1
a970 1
	xlp_valid = TRUE;
d1021 1
a1021 1
	xlp_valid = FALSE;
d1147 1
a1147 1
	x_delete(ndel, TRUE);
d1192 1
a1192 1
	x_delete(len, FALSE);
d1208 1
a1208 1
	xlp_valid = TRUE;
d1229 1
a1229 1
	xlp_valid = TRUE;
d1241 1
a1241 1
	bool_t	savmode = x_mode(FALSE);
d1484 1
a1484 1
	x_delete(rsize, TRUE);
d1657 1
a1657 1
	x_delete(end - start, FALSE);
d1702 1
a1702 1
		x_delete(olen, FALSE);
d1747 1
a1747 1
  xlp_valid = FALSE;
d2062 1
a2062 1
	xlp_valid = TRUE;
@


1.31
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.30 2004/12/18 21:25:44 millert Exp $	*/
d112 2
a113 2
static int      x_ins(char *cp);
static void     x_delete(int nc, int push);
d116 14
a129 14
static void     x_goto(char *cp);
static void     x_bs(int c);
static int      x_size_str(char *cp);
static int      x_size(int c);
static void     x_zots(char *str);
static void     x_zotc(int c);
static void     x_load_hist(char **hp);
static int      x_search(char *pat, int sameline, int offset);
static int      x_match(char *str, char *pat);
static void	x_redraw(int limit);
static void     x_push(int nchars);
static char *   x_mapin(const char *cp);
static char *   x_mapout(int c);
static void     x_print(int prefix, int key);
d131 1
a131 1
static void	x_e_ungetc(int c);
d133 4
a136 4
static void	x_e_putc(int c);
static void	x_e_puts(const char *s);
static int	x_comment(int c);
static int	x_fold_case(int c);
d138 2
a139 2
static void	do_complete(int flags, Comp_type type);
static int	x_emacs_putbuf(const char *s, size_t len);
d310 1
a310 3
x_emacs(buf, len)
	char *buf;
	size_t len;
d381 1
a381 2
x_insert(c)
	int c;
d400 1
a400 2
x_ins_string(c)
	int c;
d417 1
a417 3
x_do_ins(cp, len)
	const char *cp;
	int len;
d432 1
a432 2
x_ins(s)
	char	*s;
d462 1
a462 3
x_emacs_putbuf(s, len)
	const char *s;
	size_t len;
d472 1
a472 2
x_del_back(c)
	int c;
d488 1
a488 2
x_del_char(c)
	int c;
d504 1
a504 3
x_delete(nc, push)
	int nc;
	int push;
d559 1
a559 2
x_del_bword(c)
	int c;
d566 1
a566 2
x_mv_bword(c)
	int c;
d573 1
a573 2
x_mv_fword(c)
	int c;
d580 1
a580 2
x_del_fword(c)
	int c;
d587 1
a587 1
x_bword()
d614 1
a614 1
x_fword()
d640 1
a640 2
x_goto(cp)
	char *cp;
d667 1
a667 2
x_bs(c)
	int c;
d676 1
a676 2
x_size_str(cp)
	char *cp;
d685 1
a685 2
x_size(c)
	int c;
d695 1
a695 2
x_zots(str)
	char *str;
d705 1
a705 2
x_zotc(c)
	int c;
d718 1
a718 2
x_mv_back(c)
	int c;
d733 1
a733 2
x_mv_forw(c)
	int c;
d748 1
a748 2
x_search_char_forw(c)
	int c;
d768 1
a768 2
x_search_char_back(c)
	int c;
d789 1
a789 2
x_newline(c)
	int c;
d799 1
a799 2
x_end_of_text(c)
	int c;
d804 1
a804 1
static int x_beg_hist(c) int c; { x_load_hist(history); return KSTD;}
d806 1
a806 1
static int x_end_hist(c) int c; { x_load_hist(histptr); return KSTD;}
d808 1
a808 1
static int x_prev_com(c) int c; { x_load_hist(x_histp - x_arg); return KSTD;}
d810 1
a810 1
static int x_next_com(c) int c; { x_load_hist(x_histp + x_arg); return KSTD;}
d817 1
a817 2
x_goto_hist(c)
	int c;
d827 1
a827 2
x_load_hist(hp)
	char **hp;
d848 1
a848 2
x_nl_next_com(c)
	int	c;
d855 1
a855 2
x_eot_del(c)
	int	c;
d865 1
a865 2
x_search_hist(c)
	int c;
d927 1
a927 4
x_search(pat, sameline, offset)
	char *pat;
	int sameline;
	int offset;
d949 1
a949 2
x_match(str, pat)
	char *str, *pat;
d960 1
a960 2
x_del_line(c)
	int c;
d978 1
a978 2
x_mv_end(c)
	int c;
d985 1
a985 2
x_mv_begin(c)
	int c;
d992 1
a992 2
x_draw_line(c)
	int c;
d1004 1
a1004 2
x_redraw(limit)
  int limit;
d1059 1
a1059 2
x_transpose(c)
	int c;
d1111 1
a1111 2
x_literal(c)
	int c;
d1118 1
a1118 2
x_meta1(c)
	int c;
d1125 1
a1125 2
x_meta2(c)
	int c;
d1132 1
a1132 2
x_kill(c)
	int c;
d1152 1
a1152 2
x_push(nchars)
	int nchars;
d1162 1
a1162 2
x_yank(c)
	int c;
d1180 1
a1180 2
x_meta_yank(c)
	int c;
d1204 1
a1204 2
x_abort(c)
	int c;
d1214 1
a1214 2
x_error(c)
	int c;
d1221 1
a1221 2
x_stuffreset(c)
	int c;
d1237 1
a1237 2
x_stuff(c)
	int c;
d1251 1
a1251 2
x_mapin(cp)
	const char *cp;
d1276 1
a1276 2
x_mapout(c)
	int c;
d1291 1
a1291 2
x_print(prefix, key)
	int prefix, key;
d1305 3
a1307 4
x_bind(a1, a2, macro, list)
	const char *a1, *a2;
	int macro;		/* bind -m */
	int list;		/* bind -l */
d1397 1
a1397 1
x_init_emacs()
d1432 1
a1432 3
bind_if_not_bound(p, k, func)
	int p, k;
	int func;
d1443 1
a1443 2
x_emacs_keys(ec)
	X_chars *ec;
d1460 1
a1460 2
x_set_mark(c)
	int c;
d1467 1
a1467 2
x_kill_region(c)
	int c;
d1490 1
a1490 2
x_xchg_point_mark(c)
	int c;
d1505 1
a1505 2
x_version(c)
	int c;
d1534 1
a1534 2
x_noop(c)
	int c;
d1541 1
a1541 2
x_game_of_life(c)
	int c;
d1597 1
a1597 2
x_comp_comm(c)
	int c;
d1603 1
a1603 2
x_list_comm(c)
	int c;
d1609 1
a1609 2
x_complete(c)
	int c;
d1615 1
a1615 2
x_enumerate(c)
	int c;
d1621 1
a1621 2
x_comp_file(c)
	int c;
d1627 1
a1627 2
x_list_file(c)
	int c;
d1633 1
a1633 2
x_comp_list(c)
	int c;
d1639 1
a1639 2
x_expand(c)
	int c;
d1673 2
a1674 3
do_complete(flags, type)
	int flags;	/* XCF_{COMMAND,FILE,COMMAND_FILE} */
	Comp_type type;
d1739 1
a1739 1
x_adjust()
d1755 1
a1755 2
x_e_ungetc(c)
	int c;
d1761 1
a1761 1
x_e_getc()
d1781 1
a1781 2
x_e_putc(c)
	int c;
d1811 1
a1811 2
x_debug_info(c)
	int c;
d1828 1
a1828 2
x_e_puts(s)
	const char *s;
d1847 1
a1847 2
x_set_arg(c)
	int c;
d1870 1
a1870 2
x_comment(c)
	int c;
d1906 1
a1906 2
x_prev_histword(c)
	int c;
d1954 1
a1954 2
x_fold_upper(c)
  int c;
d1961 1
a1961 2
x_fold_lower(c)
  int c;
d1968 1
a1968 2
x_fold_capitalize(c)
  int c;
d1985 1
a1985 2
x_fold_case(c)
	int c;
d2052 1
a2052 1
x_lastcp()
@


1.30
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.29 2004/12/18 20:55:52 millert Exp $	*/
d521 1
a521 1
	
d568 1
a568 1
	return;	
d1051 1
a1051 1
	
d1479 1
a1479 1
	/* Determine if we can translate meta key or use 8-bit AscII 
d1795 2
a1796 2
	if (completed)	
		x_redraw(0);	
d1842 1
a1842 1
	
d2004 1
a2004 1
		  	rcp--;
d2006 1
a2006 1
		  	rcp--;
d2008 1
a2008 1
		  	rcp++;
d2018 1
a2018 1
		  	rcp++;
d2020 4
a2023 4
		  	while (*rcp && !is_cfs(*rcp))
		  		rcp++;
		  	while (*rcp && is_cfs(*rcp))
		  		rcp++;
d2027 1
a2027 1
		  	rcp++;
d2076 1
a2076 1
	
@


1.29
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.28 2003/10/22 07:40:38 jmc Exp $	*/
d441 2
a442 2
	char *cp = xcp;
	register int	adj = x_adj_done;
d607 1
a607 1
	register char *cp = xcp;
d634 1
a634 1
	register char	*cp = xcp;
d658 1
a658 1
	register char *cp;
d688 1
a688 1
	register int i;
d696 1
a696 1
	register char *cp;
d698 1
a698 1
	register int size = 0;
d717 1
a717 1
	register char *str;
d719 1
a719 1
  register int	adj = x_adj_done;
d721 3
a723 3
  x_lastcp();
  while (*str && str < xlp && adj == x_adj_done)
    x_zotc(*str++);
d858 1
a858 1
	register char **hp;
d903 1
a903 1
	register char *p = pat;
d966 1
a966 1
	register char **hp;
d1336 1
a1336 1
	register char *p = buf;
d1458 1
a1458 1
	register int i, j;
d1612 1
a1612 1
	register char *ip, *op;
d1911 1
a1911 1
  register int	adj = x_adj_done;
d1992 20
a2011 2
  register char *rcp;
  char *cp;
d2013 21
a2033 40
  cp = *histptr;
  if (!cp)
    x_e_putc(BEL);
  else if (x_arg_defaulted) {
    rcp = &cp[strlen(cp) - 1];
    /*
     * ignore white-space after the last word
     */
    while (rcp > cp && is_cfs(*rcp))
      rcp--;
    while (rcp > cp && !is_cfs(*rcp))
      rcp--;
    if (is_cfs(*rcp))
      rcp++;
    x_ins(rcp);
  } else {
    int c;

    rcp = cp;
    /*
     * ignore white-space at start of line
     */
    while (*rcp && is_cfs(*rcp))
      rcp++;
    while (x_arg-- > 1)
    {
      while (*rcp && !is_cfs(*rcp))
	rcp++;
      while (*rcp && is_cfs(*rcp))
	rcp++;
    }
    cp = rcp;
    while (*rcp && !is_cfs(*rcp))
      rcp++;
    c = *rcp;
    *rcp = '\0';
    x_ins(cp);
    *rcp = c;
  }
  return KSTD;
d2142 2
a2143 2
  register char *rcp;
  register int i;
d2145 7
a2151 8
  if (!xlp_valid)
  {
    for (i = 0, rcp = xbp; rcp < xep && i < x_displen; rcp++)
      i += x_size(*rcp);
    xlp = rcp;
  }
  xlp_valid = TRUE;
  return (xlp);
@


1.28
log
@typos from Jared Yanovich;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.27 2003/09/01 15:47:40 naddy Exp $	*/
d15 1
a15 2
#include "ksh_stat.h"
#include "ksh_dir.h"
a22 1
#undef CTRL			/* _BSD brain damage */
d35 1
a35 1
	int		(*xf_func) ARGS((int c));
a56 8
#ifdef OS2
  /* Deal with 8 bit chars & an extra prefix for function key (these two
   * changes increase memory usage from 9,216 bytes to 24,416 bytes...)
   */
# define CHARMASK	0xFF		/* 8-bit ASCII character mask */
# define X_NTABS	4		/* normal, meta1, meta2, meta3 */
static int	x_prefix3 = 0xE0;
#else /* OS2 */
a58 1
#endif /* OS2 */
d112 28
a139 28
static int      x_ins       ARGS((char *cp));
static void     x_delete    ARGS((int nc, int push));
static int	x_bword     ARGS((void));
static int	x_fword     ARGS((void));
static void     x_goto      ARGS((char *cp));
static void     x_bs        ARGS((int c));
static int      x_size_str  ARGS((char *cp));
static int      x_size      ARGS((int c));
static void     x_zots      ARGS((char *str));
static void     x_zotc      ARGS((int c));
static void     x_load_hist ARGS((char **hp));
static int      x_search    ARGS((char *pat, int sameline, int offset));
static int      x_match     ARGS((char *str, char *pat));
static void	x_redraw    ARGS((int limit));
static void     x_push      ARGS((int nchars));
static char *   x_mapin     ARGS((const char *cp));
static char *   x_mapout    ARGS((int c));
static void     x_print     ARGS((int prefix, int key));
static void	x_adjust    ARGS((void));
static void	x_e_ungetc  ARGS((int c));
static int	x_e_getc    ARGS((void));
static void	x_e_putc    ARGS((int c));
static void	x_e_puts    ARGS((const char *s));
static int	x_comment   ARGS((int c));
static int	x_fold_case ARGS((int c));
static char	*x_lastcp ARGS((void));
static void	do_complete ARGS((int flags, Comp_type type));
static int	x_emacs_putbuf	ARGS((const char *s, size_t len));
a218 3
#ifdef OS2
	{ x_meta3,		"prefix-3",			XF_PREFIX },
#else
a219 1
#endif
d258 1
a258 1
#if defined(BRL) && defined(TIOCSTI)
a296 7
#ifdef OS2
	{ XFUNC_meta3,			0,	0xE0 },
	{ XFUNC_mv_back,		3,	'K'  },
	{ XFUNC_mv_forw,		3,	'M'  },
	{ XFUNC_next_com,		3,	'P'  },
	{ XFUNC_prev_com,		3,	'H'  },
#endif /* OS2 */
a1177 10
#ifdef OS2
static int
x_meta3(c)
	int c;
{
	x_curprefix = 3;
	return KSTD;
}
#endif /* OS2 */

d1294 1
a1294 1
#if 0 || defined TIOCSTI
a1315 5
#ifdef OS2
			if (*cp == '0')	/* To define function keys */
				*op++ = 0xE0;
			else
#endif /* OS2 */
a1337 6
#ifdef OS2
	if (c == 0xE0) {
		*p++ = '^';
		*p++ = '0';
	} else
#endif /* OS2 */
a1354 4
#ifdef OS2
	if (prefix == 3)
		shprintf("%s", x_mapout(x_prefix3));
#endif /* OS2 */
a1406 4
#ifdef OS2
		else if (x_tab[prefix][key] == XFUNC_meta3)
			prefix = 3;
#endif /* OS2 */
d1785 1
a1785 1
	if ((nwords == 1) && (!ISDIRSEP(words[0][nlen - 1]))) {
@


1.27
log
@In emacs editing mode, ksh by default interprets a set 8th bit as
meta prefix, i.e. all characters with the top bit set (>= 0x80) are
taken as commands and cannot be entered literally.

Introduce a new shell option, emacs-usemeta, that allows to toggle
this behavior.  The default is the traditional behavior; to enter
8-bit characters use "set +o emacs-usemeta".

ok fgsch@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.26 2003/08/27 14:56:11 fgsch Exp $	*/
d215 1
a215 1
        { x_fold_capitialize,	"capitalize-word",		XF_ARG },
d310 2
a311 2
        { XFUNC_fold_capitialize,	1,	'C'  },
        { XFUNC_fold_capitialize,	1,	'c'  },
d1138 1
a1138 1
	 * it does the at&t ksh gmacs mdoe.
d2106 1
a2106 1
x_fold_capitialize(c)
d2135 1
a2135 1
		 * fisrt skip over any white-space
d2147 1
a2147 1
			} else {		/* uppercase, capitialize */
d2160 1
a2160 1
			} else {		/* lowercase, capitialize */
@


1.26
log
@rename force_push to something more sensible.
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.25 2003/08/27 14:40:56 fgsch Exp $	*/
d28 1
a28 1
#define	ISMETA(x)	(x_usemeta && ((x) & 0x80))
a103 1
static int	x_usemeta;	/* no 8-bit ascii, meta = ESC */
d1536 1
a1536 1
		x_usemeta = 1;
@


1.25
log
@escape on expand under emacs mode; otto@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.23 2003/08/23 02:30:59 fgsch Exp $	*/
d125 1
a125 1
static void     x_delete    ARGS((int nc, int force_push));
d538 1
a538 1
x_delete(nc, force_push)
d540 1
a540 1
	int force_push;
d557 1
a557 1
	if (force_push)
@


1.24
log
@fix backward and forward delete; from wiz@@netbsd.org. many thanks.
@
text
@d1786 3
a1788 2
	for (i = 0; i < nwords; i++)
		if (x_ins(words[i]) < 0 || (i < nwords - 1 && x_ins(space) < 0))
d1793 2
@


1.23
log
@under emacs mode, fix the case when the globbed file and the longest
prefix lenghts are equal ("a .b" and "a ab" by instance).
found and tested by otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.22 2003/08/02 19:44:12 fgsch Exp $	*/
d598 1
a598 1
	x_delete(x_bword(), FALSE);
d622 1
a622 1
	x_delete(x_fword(), FALSE);
@


1.22
log
@don't push things unless force is true; avoid adding text again on yank-pop.
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.21 2003/08/02 19:26:15 fgsch Exp $	*/
d1826 1
a1826 1
	if (nlen > olen) {
@


1.21
log
@On ESC-y ESC-y (yank-pop), also check that there is something to
insert (some text has been killed before). from otto@@, fix PR/3384.

On yank-pop error (no yank before), reset the index to killstack so
another yank-pop does not mangle the prompt if nothing was yanked, and
to avoid replacing a text when it shouldn't
(yank <something> yank-pop yank-pop).
otto@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.20 2003/06/26 00:09:45 deraadt Exp $	*/
d557 1
a557 1
	if (nc > 1 || force_push)
@


1.20
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.19 2003/04/16 23:11:52 tdeval Exp $	*/
d1267 3
a1269 1
	if (x_last_command != XFUNC_yank && x_last_command != XFUNC_meta_yank) {
@


1.19
log
@string cleaning.  ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.18 2003/02/28 09:45:09 jmc Exp $	*/
d441 2
d1537 2
@


1.18
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.17 2002/10/16 00:13:53 millert Exp $	*/
d889 1
a889 1
	(void)strcpy(xbuf, *hp);
d891 1
a891 1
	xep = xcp = xbuf + strlen(*hp);
d1025 1
a1025 1
	i = xep- xbuf;
@


1.17
log
@enable meta key in emacs mode for 7-bit locales; provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.16 2002/06/09 05:47:27 todd Exp $	*/
d1130 1
a1130 1
	 * upper case character or underscore indicating the cursor positiion:
d2105 1
a2105 1
 *      x_fold_case - convert word to UPPER/lower/Capitial case
@


1.16
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.15 2001/07/17 12:39:31 camield Exp $	*/
d18 1
d27 2
d104 1
d373 5
d1507 1
d1526 8
@


1.15
log
@make file-completion work with ~ (tilde)

tested by provos@@ and me
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.14 2001/02/19 09:49:52 camield Exp $	*/
d91 1
a91 1
 * we use x_adj_done so that functions can tell 
d370 1
a370 1
			: x_tab[x_curprefix][c&CHARMASK]; 
d852 1
a852 1
  
d1067 1
a1067 1
	else 
d1830 4
a1833 4
 *      This function is called when we have exceeded the bounds 
 *      of the edit window.  It increments x_adj_done so that 
 *      functions like x_ins and x_delete know that we have been 
 *      called and can skip the x_bs() stuff which has already 
d2002 5
a2006 5
 *      This function recovers the last word from the previous 
 *      command and inserts it into the current edit line.  If a 
 *      numeric arg is supplied then the n'th word from the 
 *      start of the previous command is used.  
 *      
d2037 1
a2037 1
    
d2152 2
a2153 2
 *      This function returns a pointer to that  char in the 
 *      edit buffer that will be the last displayed on the 
d2155 1
a2155 1
 *      
d2158 1
a2158 1
 *      
@


1.14
log
@bash-like 'double-tab' completion

- bind TAB (^I) to complete-list by default
- complete-list now lists 'ls style' not 'menu style'
- complete-list first completes; if that does not work, it lists
- fix a memleak in emacs.c, do_complete
- completion now works after '=' (dd), and ':' (ssh) and ` (backtick)
- a command can now start with a subdir from the current dir
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.13 2000/01/24 03:12:12 millert Exp $	*/
d1801 7
a1807 8
	/* complete single match, or multi-match without globbing chars */
	if ((nlen > olen) &&
	    ((nwords == 1) || (strncmp(words[0], xbuf + start, olen) == 0))) {
			x_goto(xbuf + start);
			x_delete(olen, FALSE);
			x_escape(words[0], nlen, x_emacs_putbuf);
			x_adjust();
			completed = 1;
d1809 1
@


1.13
log
@Make application mode arrow keys work; fixes arrow keys on the console.
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.12 1999/11/14 22:04:02 d Exp $	*/
d276 1
a276 1
	{ XFUNC_complete,		0, CTRL('I') },
d1779 2
a1780 2
	int nwords = 0;
	int start, end;
d1782 5
a1786 40
	int do_glob = 1;
	Comp_type t = type;
	char *comp_word = (char *) 0;

	if (type == CT_COMPLIST) {
		do_glob = 0;
		/* decide what we will do */
		nwords = x_cf_glob(flags,
			xbuf, xep - xbuf, xcp - xbuf,
			&start, &end, &words, &is_command);
		if (nwords > 0) {
			if (nwords > 1) {
				int len = x_longest_prefix(nwords, words);

				t = CT_LIST;
				/* Do completion if prefix matches original
				 * prefix (ie, no globbing chars), otherwise
				 * don't bother
				 */
				if (strncmp(words[0], xbuf + start, end - start)
									== 0)
					comp_word = str_nsave(words[0], len,
						ATEMP);
				else
					type = CT_LIST;
				/* Redo globing to show full paths if this
				 * is a command.
				 */
				if (is_command) {
					do_glob = 1;
					x_free_words(nwords, words);
				}
			} else
				type = t = CT_COMPLETE;
		}
	}
	if (do_glob)
		nwords = x_cf_glob(flags | (t == CT_LIST ? XCF_FULLPATH : 0),
			xbuf, xep - xbuf, xcp - xbuf,
			&start, &end, &words, &is_command);
d1791 2
a1792 2
	switch (type) {
	  case CT_LIST:
d1795 3
a1797 1
		break;
d1799 15
a1813 5
	  case CT_COMPLIST:
		/* Only get here if nwords > 1 && comp_word is set */
		{
			int olen = end - start;
			int nlen = strlen(comp_word);
d1815 4
a1818 6
			x_print_expansions(nwords, words, is_command);
			xcp = xbuf + end;
			x_do_ins(comp_word + olen, nlen - olen);
			x_redraw(0);
		}
		break;
d1820 2
a1821 3
	  case CT_COMPLETE:
		{
			int nlen = x_longest_prefix(nwords, words);
d1823 1
a1823 16
			if (nlen > 0) {
				x_goto(xbuf + start);
				x_delete(end - start, FALSE);
				x_escape(words[0], nlen, x_emacs_putbuf);
				x_adjust();
				/* If single match is not a directory, add a
				 * space to the end...
				 */
				if (nwords == 1
				    && !ISDIRSEP(words[0][nlen - 1]))
					x_ins(space);
			} else
				x_e_putc(BEL);
		}
		break;
	}
@


1.12
log
@quote metachars when completing filenames from jdolecek@@netbsd. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.11 1999/08/04 19:11:13 millert Exp $	*/
d321 1
@


1.11
log
@Turn <tab> completion on by default for people used to bash, tcsh, etc...
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.10 1999/07/14 13:37:23 millert Exp $	*/
d147 1
d476 15
d1851 2
a1852 2
				words[0][nlen] = '\0';
				x_ins(words[0]);
@


1.10
log
@pdksh-5.2.14
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.9 1999/06/15 01:18:33 millert Exp $	*/
d275 1
@


1.9
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.8 1999/01/19 20:41:52 millert Exp $	*/
d44 1
a44 1
	char		xdb_tab;
a60 1
# define X_TABSZ	256		/* size of keydef tables etc */
d64 1
a64 2
# define CHARMASK	0x7F		/* 7-bit ASCII character mask */
# define X_TABSZ	128		/* size of keydef tables etc */
d67 1
d704 1
a704 1
	if (c < ' ' || c == 0x7F) /* ASCII control char */
d727 1
a727 1
	} else if (c < ' ' || c == 0x7F)  { /* ASCII */
a1344 3
	if (c < ' ' || c == 0x7F)  { /* ASCII */
		*p++ = '^';
		*p++ = (c == 0x7F) ? '?' : (c | 0x40);
d1346 1
a1346 1
	} else if (c == 0xE0) {
d1349 1
d1351 3
@


1.8
log
@Updates from pdksh-unstable-5.2.13.7.  Most notable change is:
    trap: exit traps now executed in subshells (without explicit exit call).
See the Changelog for a full list of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.7 1999/01/10 17:55:02 millert Exp $	*/
d113 1
d1465 8
d1500 13
d1517 12
a1528 6
	x_tab[0][ec->erase] = XFUNC_del_back;
	x_tab[0][ec->kill] = XFUNC_del_line;
	x_tab[0][ec->werase] = XFUNC_del_bword;
	x_tab[0][ec->intr] = XFUNC_abort;
	x_tab[0][ec->quit] = XFUNC_noop;
	x_tab[1][ec->erase] = XFUNC_del_bword;
@


1.7
log
@sync with pdksh-unstable-5.2.13.6
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.6 1998/10/29 04:09:20 millert Exp $	*/
d313 1
a313 1
#else /* OS2 */
a322 1
#endif /* OS2 */
@


1.6
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.5 1998/06/25 19:01:51 millert Exp $	*/
d683 1
a683 1
	register i;
d693 1
a693 1
	register size = 0;
d1483 1
a1483 1
		x_tab[x_defbindings[i].xdb_tab][x_defbindings[i].xdb_char]
@


1.5
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.4 1997/06/19 13:58:39 kstailey Exp $	*/
d2017 3
a2019 1
  if (x_arg_defaulted) {
@


1.4
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.2 1996/08/19 20:08:48 downsj Exp $	*/
d1247 1
a1247 1
	do  {
d1252 1
a1252 1
	}  while (killstack[killtp] == 0);
a2014 1
  char **hp;
d2016 1
a2016 7
  hp = x_histp-1;
  if (hp < history || hp > histptr)
  {
    x_e_putc(BEL);
    return KSTD;
  }
  cp = *hp;
@


1.3
log
@(foo *)0 -> NULL
@
text
@d342 1
a342 1
	macroptr = NULL;
d425 1
a425 1
		macroptr = NULL;
d1056 1
a1056 1
	  x_col = promptlen(prompt, NULL);
d1739 1
a1739 1
	char *comp_word = NULL;
d1871 1
a1871 1
				macroptr = NULL;
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.1.1.1 1996/08/14 06:19:10 downsj Exp $	*/
d342 1
a342 1
	macroptr = (char *) 0;
d425 1
a425 1
		macroptr = (char *) 0;
d1056 1
a1056 1
	  x_col = promptlen(prompt, (const char **) 0);
d1739 1
a1739 1
	char *comp_word = (char *) 0;
d1871 1
a1871 1
				macroptr = (char *) 0;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 1
a141 3
#ifdef DEBUG
static int	x_debug_info ARGS((void));
#endif /* DEBUG */
d143 1
d215 1
d268 1
d346 1
d350 1
a350 1
	x_displen = x_cols - 2 - x_col;
d547 1
a547 1
	if ((i = x_cols - 2 - x_col) > 0)
d1036 4
d1058 1
a1058 1
	x_displen = x_cols - 2 - x_col;
d1063 1
a1063 1
	  limit = x_cols;
d1071 1
a1071 1
	  for (j = 0; j < i && x_col < (x_cols - 2); j++)
d1841 1
a1841 1
   * we had a problem if the prompt length > x_cols / 2
d1846 1
a1846 1
  x_redraw(x_cols);
d1885 1
a1885 1
  if (x_col < x_cols)
d1903 1
a1903 1
  if (x_adj_ok && (x_col < 0 || x_col >= (x_cols - 2)))
d1911 2
a1912 1
x_debug_info()
d1914 11
a1924 11
  x_flush();
  printf("\nksh debug:\n");
  printf("\tx_col == %d,\t\tx_cols == %d,\tx_displen == %d\n",
	 x_col, x_cols, x_displen);
  printf("\txcp == 0x%lx,\txep == 0x%lx\n", (long) xcp, (long) xep);
  printf("\txbp == 0x%lx,\txbuf == 0x%lx\n", (long) xbp, (long) xbuf);
  printf("\txlp == 0x%lx\n", (long) xlp);
  printf("\txlp == 0x%lx\n", (long) x_lastcp());
  printf(newline);
  x_redraw(-1);
  return 0;
d1966 23
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
