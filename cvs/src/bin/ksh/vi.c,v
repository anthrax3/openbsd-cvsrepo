head	1.44;
access;
symbols
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.28.0.10
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.26.0.18
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.16
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.14
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.12
	OPENBSD_5_0:1.26.0.10
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.8
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.6
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.4
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.23.0.12
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.10
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.8
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.6
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.4
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.4
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.10
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.8
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2016.10.17.18.39.43;	author schwarze;	state Exp;
branches;
next	1.43;
commitid	1lHhbps6Yf1Zq0Tl;

1.43
date	2016.10.17.17.59.57;	author schwarze;	state Exp;
branches;
next	1.42;
commitid	mh1W6faCbbrxXtPC;

1.42
date	2016.10.17.17.44.47;	author schwarze;	state Exp;
branches;
next	1.41;
commitid	yUIPO9ruHzE0GnK9;

1.41
date	2016.10.17.17.19.08;	author schwarze;	state Exp;
branches;
next	1.40;
commitid	CxA6Fx9d7pGh3wxz;

1.40
date	2016.10.11.19.52.54;	author schwarze;	state Exp;
branches;
next	1.39;
commitid	PFDfEfGGTUypn9vm;

1.39
date	2015.12.22.08.39.26;	author mmcc;	state Exp;
branches;
next	1.38;
commitid	mayuFIj2eBvpZKfb;

1.38
date	2015.11.05.18.41.02;	author mmcc;	state Exp;
branches;
next	1.37;
commitid	LZl0HBj3qDe4fSxn;

1.37
date	2015.11.05.01.24.50;	author mmcc;	state Exp;
branches;
next	1.36;
commitid	WxchFj59VXo15w0M;

1.36
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.35;
commitid	C4W85jmosThChWA2;

1.35
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.34;
commitid	16HUr75moyUNtKR8;

1.34
date	2015.10.15.19.36.50;	author mmcc;	state Exp;
branches;
next	1.33;
commitid	dyn95NuT7ECtD5iZ;

1.33
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.32;
commitid	7fgq4YTZG4xZ0uN0;

1.32
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.31;
commitid	v5QjoxUgKU2iUTFz;

1.31
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.30;
commitid	lBs9un9sXhbdfVrQ;

1.30
date	2015.09.10.22.48.58;	author nicm;	state Exp;
branches;
next	1.29;
commitid	stJ3KRI2o7F5OBtF;

1.29
date	2015.09.01.13.12.31;	author tedu;	state Exp;
branches;
next	1.28;
commitid	sKGEDet4KOfGjsIb;

1.28
date	2013.12.18.16.45.46;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2013.12.17.16.37.06;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2009.06.29.22.50.19;	author martynas;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.10.15.08.46;	author merdely;	state Exp;
branches;
next	1.24;

1.24
date	2009.06.04.04.03.22;	author merdely;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.10.14.38.59;	author jaredy;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.11.20.31.21;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.28.21.28.22;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.27.16.25.06;	author danh;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.19.04.14.20;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.10.16.28.47;	author pvalchev;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.16.22.08.48;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.13.09.03.07;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.29.06.26.50;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	99.11.15.21.26.38;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	99.11.14.22.04.02;	author d;	state Exp;
branches;
next	1.7;

1.7
date	99.07.14.13.37.24;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.01.08.20.25.03;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.06.19.13.58.49;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.06.18.22.42.49;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.11.21.07.59.37;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.09.04;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.12;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.12;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.44
log
@simplify implementation of the '$' command, no functional change;
OK nicm@@ tb@@ czarkoff@@
@
text
@/*	$OpenBSD: vi.c,v 1.43 2016/10/17 17:59:57 schwarze Exp $	*/

/*
 *	vi command editing
 *	written by John Rochester (initially for nsh)
 *	bludgeoned to fit pdksh by Larry Bouzane, Jeff Sparkes & Eric Gisin
 *
 */
#include "config.h"
#ifdef VI

#include <sys/stat.h>		/* completion */

#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "sh.h"
#include "edit.h"

#define CMDLEN		2048
#define CTRL(c)		(c & 0x1f)

struct edstate {
	char	*cbuf;		/* main buffer to build the command line */
	int	cbufsize;	/* number of bytes allocated for cbuf */
	int	linelen;	/* current number of bytes in cbuf */
	int	winleft;	/* first byte# in cbuf to be displayed */
	int	cursor;		/* byte# in cbuf having the cursor */
};


static int	vi_hook(int);
static void	vi_reset(char *, size_t);
static int	nextstate(int);
static int	vi_insert(int);
static int	vi_cmd(int, const char *);
static int	domove(int, const char *, int);
static int	redo_insert(int);
static void	yank_range(int, int);
static int	bracktype(int);
static void	save_cbuf(void);
static void	restore_cbuf(void);
static void	edit_reset(char *, size_t);
static int	putbuf(const char *, int, int);
static void	del_range(int, int);
static int	findch(int, int, int, int);
static int	forwword(int);
static int	backword(int);
static int	endword(int);
static int	Forwword(int);
static int	Backword(int);
static int	Endword(int);
static int	grabhist(int, int);
static int	grabsearch(int, int, int, char *);
static void	redraw_line(int);
static void	refresh(int);
static int	outofwin(void);
static void	rewindow(void);
static int	newcol(int, int);
static void	display(char *, char *, int);
static void	ed_mov_opt(int, char *);
static int	expand_word(int);
static int	complete_word(int, int);
static int	print_expansions(struct edstate *, int);
static int	char_len(int);
static void	x_vi_zotc(int);
static void	vi_pprompt(int);
static void	vi_error(void);
static void	vi_macro_reset(void);
static int	x_vi_putbuf(const char *, size_t);
static int	isu8cont(unsigned char);

#define C_	0x1		/* a valid command that isn't a M_, E_, U_ */
#define M_	0x2		/* movement command (h, l, etc.) */
#define E_	0x4		/* extended command (c, d, y) */
#define X_	0x8		/* long command (@@, f, F, t, T, etc.) */
#define U_	0x10		/* an UN-undoable command (that isn't a M_) */
#define B_	0x20		/* bad command (^@@) */
#define Z_	0x40		/* repeat count defaults to 0 (not 1) */
#define S_	0x80		/* search (/, ?) */

#define is_bad(c)	(classify[(c)&0x7f]&B_)
#define is_cmd(c)	(classify[(c)&0x7f]&(M_|E_|C_|U_))
#define is_move(c)	(classify[(c)&0x7f]&M_)
#define is_extend(c)	(classify[(c)&0x7f]&E_)
#define is_long(c)	(classify[(c)&0x7f]&X_)
#define is_undoable(c)	(!(classify[(c)&0x7f]&U_))
#define is_srch(c)	(classify[(c)&0x7f]&S_)
#define is_zerocount(c)	(classify[(c)&0x7f]&Z_)

const unsigned char	classify[128] = {
   /*       0       1       2       3       4       5       6       7        */
   /*   0   ^@@     ^A      ^B      ^C      ^D      ^E      ^F      ^G        */
	    B_,     0,      0,      0,      0,      C_|U_,  C_|Z_,  0,
   /*  01   ^H     ^I      ^J      ^K      ^L      ^M      ^N      ^O        */
	    M_,     C_|Z_,  0,      0,      C_|U_,  0,      C_,     0,
   /*  02   ^P     ^Q      ^R      ^S      ^T      ^U      ^V      ^W        */
	    C_,     0,      C_|U_,  0,      0,      0,      C_,     0,
   /*  03   ^X     ^Y      ^Z      ^[      ^\      ^]      ^^      ^_        */
	    C_,     0,      0,      C_|Z_,  0,      0,      0,      0,
   /*  04  <space>  !       "       #       $       %       &       '        */
	    M_,     0,      0,      C_,     M_,     M_,     0,      0,
   /*  05   (       )       *       +       ,       -       .       /        */
	    0,      0,      C_,     C_,     M_,     C_,     0,      C_|S_,
   /*  06   0       1       2       3       4       5       6       7        */
	    M_,     0,      0,      0,      0,      0,      0,      0,
   /*  07   8       9       :       ;       <       =       >       ?        */
	    0,      0,      0,      M_,     0,      C_,     0,      C_|S_,
   /* 010   @@       A       B       C       D       E       F       G        */
	    C_|X_,  C_,     M_,     C_,     C_,     M_,     M_|X_,  C_|U_|Z_,
   /* 011   H       I       J       K       L       M       N       O        */
	    0,      C_,     0,      0,      0,      0,      C_|U_,  0,
   /* 012   P       Q       R       S       T       U       V       W        */
	    C_,     0,      C_,     C_,     M_|X_,  C_,     0,      M_,
   /* 013   X       Y       Z       [       \       ]       ^       _        */
	    C_,     C_|U_,  0,      0,      C_|Z_,  0,      M_,     C_|Z_,
   /* 014   `       a       b       c       d       e       f       g        */
	    0,      C_,     M_,     E_,     E_,     M_,     M_|X_,  C_|Z_,
   /* 015   h       i       j       k       l       m       n       o        */
	    M_,     C_,     C_|U_,  C_|U_,  M_,     0,      C_|U_,  0,
   /* 016   p       q       r       s       t       u       v       w        */
	    C_,     0,      X_,     C_,     M_|X_,  C_|U_,  C_|U_|Z_,M_,
   /* 017   x       y       z       {       |       }       ~      ^?        */
	    C_,     E_|U_,  0,      0,      M_|Z_,  0,      C_,     0
};

#define MAXVICMD	3
#define SRCHLEN		40

#define INSERT		1
#define REPLACE		2

#define VNORMAL		0		/* command, insert or replace mode */
#define VARG1		1		/* digit prefix (first, eg, 5l) */
#define VEXTCMD		2		/* cmd + movement (eg, cl) */
#define VARG2		3		/* digit prefix (second, eg, 2c3l) */
#define VXCH		4		/* f, F, t, T, @@ */
#define VFAIL		5		/* bad command */
#define VCMD		6		/* single char command (eg, X) */
#define VREDO		7		/* . */
#define VLIT		8		/* ^V */
#define VSEARCH		9		/* /, ? */
#define VVERSION	10		/* <ESC> ^V */

static char		undocbuf[CMDLEN];

static struct edstate	*save_edstate(struct edstate *old);
static void		restore_edstate(struct edstate *old, struct edstate *new);
static void		free_edstate(struct edstate *old);

static struct edstate	ebuf;
static struct edstate	undobuf = { undocbuf, CMDLEN, 0, 0, 0 };

static struct edstate	*es;			/* current editor state */
static struct edstate	*undo;

static char	ibuf[CMDLEN];		/* input buffer */
static int	first_insert;		/* set when starting in insert mode */
static int	saved_inslen;		/* saved inslen for first insert */
static int	inslen;			/* length of input buffer */
static int	srchlen;		/* number of bytes in search pattern */
static char	ybuf[CMDLEN];		/* yank buffer */
static int	yanklen;		/* length of yank buffer */
static int	fsavecmd = ' ';		/* last find command */
static int	fsavech;		/* character to find */
static char	lastcmd[MAXVICMD];	/* last non-move command */
static int	lastac;			/* argcnt for lastcmd */
static int	lastsearch = ' ';	/* last search command */
static char	srchpat[SRCHLEN];	/* last search pattern */
static int	insert;			/* mode: INSERT, REPLACE, or 0 */
static int	hnum;			/* position in history */
static int	ohnum;			/* history line copied (after mod) */
static int	hlast;			/* 1 past last position in history */
static int	modified;		/* buffer has been "modified" */
static int	state;

/* Information for keeping track of macros that are being expanded.
 * The format of buf is the alias contents followed by a null byte followed
 * by the name (letter) of the alias.  The end of the buffer is marked by
 * a double null.  The name of the alias is stored so recursive macros can
 * be detected.
 */
struct macro_state {
    unsigned char	*p;	/* current position in buf */
    unsigned char	*buf;	/* pointer to macro(s) being expanded */
    int			len;	/* how much data in buffer */
};
static struct macro_state macro;

enum expand_mode { NONE, EXPAND, COMPLETE, PRINT };
static enum expand_mode expanded = NONE;/* last input was expanded */

int
x_vi(char *buf, size_t len)
{
	int	c;

	vi_reset(buf, len > CMDLEN ? CMDLEN : len);
	vi_pprompt(1);
	x_flush();
	while (1) {
		if (macro.p) {
			c = (unsigned char)*macro.p++;
			/* end of current macro? */
			if (!c) {
				/* more macros left to finish? */
				if (*macro.p++)
					continue;
				/* must be the end of all the macros */
				vi_macro_reset();
				c = x_getc();
			}
		} else
			c = x_getc();

		if (c == -1)
			break;
		if (state != VLIT) {
			if (c == edchars.intr || c == edchars.quit) {
				/* pretend we got an interrupt */
				x_vi_zotc(c);
				x_flush();
				trapsig(c == edchars.intr ? SIGINT : SIGQUIT);
				x_mode(false);
				unwind(LSHELL);
			} else if (c == edchars.eof && state != VVERSION) {
				if (es->linelen == 0) {
					x_vi_zotc(edchars.eof);
					c = -1;
					break;
				}
				continue;
			}
		}
		if (vi_hook(c))
			break;
		x_flush();
	}

	x_putc('\r'); x_putc('\n'); x_flush();

	if (c == -1 || len <= es->linelen)
		return -1;

	if (es->cbuf != buf)
		memmove(buf, es->cbuf, es->linelen);

	buf[es->linelen++] = '\n';

	return es->linelen;
}

static int
vi_hook(int ch)
{
	static char	curcmd[MAXVICMD], locpat[SRCHLEN];
	static int	cmdlen, argc1, argc2;

	switch (state) {

	case VNORMAL:
		if (insert != 0) {
			if (ch == CTRL('v')) {
				state = VLIT;
				ch = '^';
			}
			switch (vi_insert(ch)) {
			case -1:
				vi_error();
				state = VNORMAL;
				break;
			case 0:
				if (state == VLIT) {
					es->cursor--;
					refresh(0);
				} else
					refresh(insert != 0);
				break;
			case 1:
				return 1;
			}
		} else {
			if (ch == '\r' || ch == '\n')
				return 1;
			cmdlen = 0;
			argc1 = 0;
			if (ch >= '1' && ch <= '9') {
				argc1 = ch - '0';
				state = VARG1;
			} else {
				curcmd[cmdlen++] = ch;
				state = nextstate(ch);
				if (state == VSEARCH) {
					save_cbuf();
					es->cursor = 0;
					es->linelen = 0;
					if (ch == '/') {
						if (putbuf("/", 1, 0) != 0)
							return -1;
					} else if (putbuf("?", 1, 0) != 0)
						return -1;
					refresh(0);
				}
				if (state == VVERSION) {
					save_cbuf();
					es->cursor = 0;
					es->linelen = 0;
					putbuf(ksh_version + 4,
					    strlen(ksh_version + 4), 0);
					refresh(0);
				}
			}
		}
		break;

	case VLIT:
		if (is_bad(ch)) {
			del_range(es->cursor, es->cursor + 1);
			vi_error();
		} else
			es->cbuf[es->cursor++] = ch;
		refresh(1);
		state = VNORMAL;
		break;

	case VVERSION:
		restore_cbuf();
		state = VNORMAL;
		refresh(0);
		break;

	case VARG1:
		if (isdigit(ch))
			argc1 = argc1 * 10 + ch - '0';
		else {
			curcmd[cmdlen++] = ch;
			state = nextstate(ch);
		}
		break;

	case VEXTCMD:
		argc2 = 0;
		if (ch >= '1' && ch <= '9') {
			argc2 = ch - '0';
			state = VARG2;
			return 0;
		} else {
			curcmd[cmdlen++] = ch;
			if (ch == curcmd[0])
				state = VCMD;
			else if (is_move(ch))
				state = nextstate(ch);
			else
				state = VFAIL;
		}
		break;

	case VARG2:
		if (isdigit(ch))
			argc2 = argc2 * 10 + ch - '0';
		else {
			if (argc1 == 0)
				argc1 = argc2;
			else
				argc1 *= argc2;
			curcmd[cmdlen++] = ch;
			if (ch == curcmd[0])
				state = VCMD;
			else if (is_move(ch))
				state = nextstate(ch);
			else
				state = VFAIL;
		}
		break;

	case VXCH:
		if (ch == CTRL('['))
			state = VNORMAL;
		else {
			curcmd[cmdlen++] = ch;
			state = VCMD;
		}
		break;

	case VSEARCH:
		if (ch == '\r' || ch == '\n' /*|| ch == CTRL('[')*/ ) {
			restore_cbuf();
			/* Repeat last search? */
			if (srchlen == 0) {
				if (!srchpat[0]) {
					vi_error();
					state = VNORMAL;
					refresh(0);
					return 0;
				}
			} else {
				locpat[srchlen] = '\0';
				(void) strlcpy(srchpat, locpat, sizeof srchpat);
			}
			state = VCMD;
		} else if (ch == edchars.erase || ch == CTRL('h')) {
			if (srchlen != 0) {
				do {
					srchlen--;
					es->linelen -= char_len(
					    (unsigned char)locpat[srchlen]);
				} while (srchlen > 0 &&
				    isu8cont(locpat[srchlen]));
				es->cursor = es->linelen;
				refresh(0);
				return 0;
			}
			restore_cbuf();
			state = VNORMAL;
			refresh(0);
		} else if (ch == edchars.kill) {
			srchlen = 0;
			es->linelen = 1;
			es->cursor = 1;
			refresh(0);
			return 0;
		} else if (ch == edchars.werase) {
			struct edstate new_es, *save_es;
			int i;
			int n = srchlen;

			new_es.cursor = n;
			new_es.cbuf = locpat;

			save_es = es;
			es = &new_es;
			n = backword(1);
			es = save_es;

			for (i = srchlen; --i >= n; )
				es->linelen -= char_len((unsigned char)locpat[i]);
			srchlen = n;
			es->cursor = es->linelen;
			refresh(0);
			return 0;
		} else {
			if (srchlen == SRCHLEN - 1)
				vi_error();
			else {
				locpat[srchlen++] = ch;
				if ((ch & 0x80) && Flag(FVISHOW8)) {
					if (es->linelen + 2 > es->cbufsize)
						vi_error();
					es->cbuf[es->linelen++] = 'M';
					es->cbuf[es->linelen++] = '-';
					ch &= 0x7f;
				}
				if (ch < ' ' || ch == 0x7f) {
					if (es->linelen + 2 > es->cbufsize)
						vi_error();
					es->cbuf[es->linelen++] = '^';
					es->cbuf[es->linelen++] = ch ^ '@@';
				} else {
					if (es->linelen >= es->cbufsize)
						vi_error();
					es->cbuf[es->linelen++] = ch;
				}
				es->cursor = es->linelen;
				refresh(0);
			}
			return 0;
		}
		break;
	}

	switch (state) {
	case VCMD:
		state = VNORMAL;
		switch (vi_cmd(argc1, curcmd)) {
		case -1:
			vi_error();
			refresh(0);
			break;
		case 0:
			if (insert != 0)
				inslen = 0;
			refresh(insert != 0);
			break;
		case 1:
			refresh(0);
			return 1;
		case 2:
			/* back from a 'v' command - don't redraw the screen */
			return 1;
		}
		break;

	case VREDO:
		state = VNORMAL;
		if (argc1 != 0)
			lastac = argc1;
		switch (vi_cmd(lastac, lastcmd)) {
		case -1:
			vi_error();
			refresh(0);
			break;
		case 0:
			if (insert != 0) {
				if (lastcmd[0] == 's' || lastcmd[0] == 'c' ||
				    lastcmd[0] == 'C') {
					if (redo_insert(1) != 0)
						vi_error();
				} else {
					if (redo_insert(lastac) != 0)
						vi_error();
				}
			}
			refresh(0);
			break;
		case 1:
			refresh(0);
			return 1;
		case 2:
			/* back from a 'v' command - can't happen */
			break;
		}
		break;

	case VFAIL:
		state = VNORMAL;
		vi_error();
		break;
	}
	return 0;
}

static void
vi_reset(char *buf, size_t len)
{
	state = VNORMAL;
	ohnum = hnum = hlast = histnum(-1) + 1;
	insert = INSERT;
	saved_inslen = inslen;
	first_insert = 1;
	inslen = 0;
	modified = 1;
	vi_macro_reset();
	edit_reset(buf, len);
}

static int
nextstate(int ch)
{
	if (is_extend(ch))
		return VEXTCMD;
	else if (is_srch(ch))
		return VSEARCH;
	else if (is_long(ch))
		return VXCH;
	else if (ch == '.')
		return VREDO;
	else if (ch == CTRL('v'))
		return VVERSION;
	else if (is_cmd(ch))
		return VCMD;
	else
		return VFAIL;
}

static int
vi_insert(int ch)
{
	int	tcursor;

	if (ch == edchars.erase || ch == CTRL('h')) {
		if (insert == REPLACE) {
			if (es->cursor == undo->cursor) {
				vi_error();
				return 0;
			}
		} else {
			if (es->cursor == 0) {
				/* x_putc(BEL); no annoying bell here */
				return 0;
			}
		}
		tcursor = es->cursor - 1;
		while(tcursor > 0 && isu8cont(es->cbuf[tcursor]))
			tcursor--;
		if (insert == INSERT)
			memmove(es->cbuf + tcursor, es->cbuf + es->cursor,
			    es->linelen - es->cursor);
		if (insert == REPLACE && es->cursor < undo->linelen)
			memcpy(es->cbuf + tcursor, undo->cbuf + tcursor,
			    es->cursor - tcursor);
		else
			es->linelen -= es->cursor - tcursor;
		if (inslen < es->cursor - tcursor)
			inslen = 0;
		else
			inslen -= es->cursor - tcursor;
		es->cursor = tcursor;
		expanded = NONE;
		return 0;
	}
	if (ch == edchars.kill) {
		if (es->cursor != 0) {
			inslen = 0;
			memmove(es->cbuf, &es->cbuf[es->cursor],
			    es->linelen - es->cursor);
			es->linelen -= es->cursor;
			es->cursor = 0;
		}
		expanded = NONE;
		return 0;
	}
	if (ch == edchars.werase) {
		if (es->cursor != 0) {
			tcursor = backword(1);
			memmove(&es->cbuf[tcursor], &es->cbuf[es->cursor],
			    es->linelen - es->cursor);
			es->linelen -= es->cursor - tcursor;
			if (inslen < es->cursor - tcursor)
				inslen = 0;
			else
				inslen -= es->cursor - tcursor;
			es->cursor = tcursor;
		}
		expanded = NONE;
		return 0;
	}
	/* If any chars are entered before escape, trash the saved insert
	 * buffer (if user inserts & deletes char, ibuf gets trashed and
	 * we don't want to use it)
	 */
	if (first_insert && ch != CTRL('['))
		saved_inslen = 0;
	switch (ch) {
	case '\0':
		return -1;

	case '\r':
	case '\n':
		return 1;

	case CTRL('['):
		expanded = NONE;
		if (first_insert) {
			first_insert = 0;
			if (inslen == 0) {
				inslen = saved_inslen;
				return redo_insert(0);
			}
			lastcmd[0] = 'a';
			lastac = 1;
		}
		if (lastcmd[0] == 's' || lastcmd[0] == 'c' ||
		    lastcmd[0] == 'C')
			return redo_insert(0);
		else
			return redo_insert(lastac - 1);

	/* { Begin nonstandard vi commands */
	case CTRL('x'):
		expand_word(0);
		break;

	case CTRL('f'):
		complete_word(0, 0);
		break;

	case CTRL('e'):
		print_expansions(es, 0);
		break;

	case CTRL('i'):
		if (Flag(FVITABCOMPLETE)) {
			complete_word(0, 0);
			break;
		}
		/* FALLTHROUGH */
	/* End nonstandard vi commands } */

	default:
		if (es->linelen >= es->cbufsize - 1)
			return -1;
		ibuf[inslen++] = ch;
		if (insert == INSERT) {
			memmove(&es->cbuf[es->cursor+1], &es->cbuf[es->cursor],
			    es->linelen - es->cursor);
			es->linelen++;
		}
		es->cbuf[es->cursor++] = ch;
		if (insert == REPLACE && es->cursor > es->linelen)
			es->linelen++;
		expanded = NONE;
	}
	return 0;
}

static int
vi_cmd(int argcnt, const char *cmd)
{
	int		ncursor;
	int		cur, c1, c2, c3 = 0;
	int		any;
	struct edstate	*t;

	if (argcnt == 0 && !is_zerocount(*cmd))
		argcnt = 1;

	if (is_move(*cmd)) {
		if ((cur = domove(argcnt, cmd, 0)) >= 0) {
			if (cur == es->linelen && cur != 0)
				while (isu8cont(es->cbuf[--cur]))
					continue;
			es->cursor = cur;
		} else
			return -1;
	} else {
		/* Don't save state in middle of macro.. */
		if (is_undoable(*cmd) && !macro.p) {
			undo->winleft = es->winleft;
			memmove(undo->cbuf, es->cbuf, es->linelen);
			undo->linelen = es->linelen;
			undo->cursor = es->cursor;
			lastac = argcnt;
			memmove(lastcmd, cmd, MAXVICMD);
		}
		switch (*cmd) {

		case CTRL('l'):
		case CTRL('r'):
			redraw_line(1);
			break;

		case '@@':
			{
				static char alias[] = "_\0";
				struct tbl *ap;
				int	olen, nlen;
				char	*p, *nbuf;

				/* lookup letter in alias list... */
				alias[1] = cmd[1];
				ap = ktsearch(&aliases, alias, hash(alias));
				if (!cmd[1] || !ap || !(ap->flag & ISSET))
					return -1;
				/* check if this is a recursive call... */
				if ((p = (char *) macro.p))
					while ((p = strchr(p, '\0')) && p[1])
						if (*++p == cmd[1])
							return -1;
				/* insert alias into macro buffer */
				nlen = strlen(ap->val.s) + 1;
				olen = !macro.p ? 2 :
				    macro.len - (macro.p - macro.buf);
				nbuf = alloc(nlen + 1 + olen, APERM);
				memcpy(nbuf, ap->val.s, nlen);
				nbuf[nlen++] = cmd[1];
				if (macro.p) {
					memcpy(nbuf + nlen, macro.p, olen);
					afree(macro.buf, APERM);
					nlen += olen;
				} else {
					nbuf[nlen++] = '\0';
					nbuf[nlen++] = '\0';
				}
				macro.p = macro.buf = (unsigned char *) nbuf;
				macro.len = nlen;
			}
			break;

		case 'a':
			modified = 1; hnum = hlast;
			if (es->linelen != 0)
				while (isu8cont(es->cbuf[++es->cursor]))
					continue;
			insert = INSERT;
			break;

		case 'A':
			modified = 1; hnum = hlast;
			del_range(0, 0);
			es->cursor = es->linelen;
			insert = INSERT;
			break;

		case 'S':
			es->cursor = domove(1, "^", 1);
			del_range(es->cursor, es->linelen);
			modified = 1; hnum = hlast;
			insert = INSERT;
			break;

		case 'Y':
			cmd = "y$";
			/* ahhhhhh... */
		case 'c':
		case 'd':
		case 'y':
			if (*cmd == cmd[1]) {
				c1 = *cmd == 'c' ? domove(1, "^", 1) : 0;
				c2 = es->linelen;
			} else if (!is_move(cmd[1]))
				return -1;
			else {
				if ((ncursor = domove(argcnt, &cmd[1], 1)) < 0)
					return -1;
				if (*cmd == 'c' &&
				    (cmd[1]=='w' || cmd[1]=='W') &&
				    !isspace((unsigned char)es->cbuf[es->cursor])) {
					while (isspace(
					    (unsigned char)es->cbuf[--ncursor]))
						;
					ncursor++;
				}
				if (ncursor > es->cursor) {
					c1 = es->cursor;
					c2 = ncursor;
				} else {
					c1 = ncursor;
					c2 = es->cursor;
					if (cmd[1] == '%')
						c2++;
				}
			}
			if (*cmd != 'c' && c1 != c2)
				yank_range(c1, c2);
			if (*cmd != 'y') {
				del_range(c1, c2);
				es->cursor = c1;
			}
			if (*cmd == 'c') {
				modified = 1; hnum = hlast;
				insert = INSERT;
			}
			break;

		case 'p':
			modified = 1; hnum = hlast;
			if (es->linelen != 0)
				es->cursor++;
			while (putbuf(ybuf, yanklen, 0) == 0 && --argcnt > 0)
				;
			if (es->cursor != 0)
				es->cursor--;
			if (argcnt != 0)
				return -1;
			break;

		case 'P':
			modified = 1; hnum = hlast;
			any = 0;
			while (putbuf(ybuf, yanklen, 0) == 0 && --argcnt > 0)
				any = 1;
			if (any && es->cursor != 0)
				es->cursor--;
			if (argcnt != 0)
				return -1;
			break;

		case 'C':
			modified = 1; hnum = hlast;
			del_range(es->cursor, es->linelen);
			insert = INSERT;
			break;

		case 'D':
			yank_range(es->cursor, es->linelen);
			del_range(es->cursor, es->linelen);
			if (es->cursor != 0)
				es->cursor--;
			break;

		case 'g':
			if (!argcnt)
				argcnt = hlast;
			/* FALLTHROUGH */
		case 'G':
			if (!argcnt)
				argcnt = 1;
			else
				argcnt = hlast - (source->line - argcnt);
			if (grabhist(modified, argcnt - 1) < 0)
				return -1;
			else {
				modified = 0;
				hnum = argcnt - 1;
			}
			break;

		case 'i':
			modified = 1; hnum = hlast;
			insert = INSERT;
			break;

		case 'I':
			modified = 1; hnum = hlast;
			es->cursor = domove(1, "^", 1);
			insert = INSERT;
			break;

		case 'j':
		case '+':
		case CTRL('n'):
			if (grabhist(modified, hnum + argcnt) < 0)
				return -1;
			else {
				modified = 0;
				hnum += argcnt;
			}
			break;

		case 'k':
		case '-':
		case CTRL('p'):
			if (grabhist(modified, hnum - argcnt) < 0)
				return -1;
			else {
				modified = 0;
				hnum -= argcnt;
			}
			break;

		case 'r':
			if (es->linelen == 0)
				return -1;
			modified = 1; hnum = hlast;
			if (cmd[1] == 0)
				vi_error();
			else {
				int	n;

				if (es->cursor + argcnt > es->linelen)
					return -1;
				for (n = 0; n < argcnt; ++n)
					es->cbuf[es->cursor + n] = cmd[1];
				es->cursor += n - 1;
			}
			break;

		case 'R':
			modified = 1; hnum = hlast;
			insert = REPLACE;
			break;

		case 's':
			if (es->linelen == 0)
				return -1;
			modified = 1; hnum = hlast;
			if (es->cursor + argcnt > es->linelen)
				argcnt = es->linelen - es->cursor;
			del_range(es->cursor, es->cursor + argcnt);
			insert = INSERT;
			break;

		case 'v':
			if (es->linelen == 0 && argcnt == 0)
				return -1;
			if (!argcnt) {
				if (modified) {
					es->cbuf[es->linelen] = '\0';
					source->line++;
					histsave(source->line, es->cbuf, 1);
				} else
					argcnt = source->line + 1
						- (hlast - hnum);
			}
			shf_snprintf(es->cbuf, es->cbufsize,
			    argcnt ? "%s %d" : "%s",
			    "fc -e ${VISUAL:-${EDITOR:-vi}} --",
			    argcnt);
			es->linelen = strlen(es->cbuf);
			return 2;

		case 'x':
			if (es->linelen == 0)
				return -1;
			modified = 1; hnum = hlast;
			for (cur = es->cursor; cur < es->linelen; cur++)
				if (!isu8cont(es->cbuf[cur]))
					if (argcnt-- == 0)
						break;
			yank_range(es->cursor, cur);
			del_range(es->cursor, cur);
			break;

		case 'X':
			if (es->cursor == 0)
				return -1;
			modified = 1; hnum = hlast;
			for (cur = es->cursor; cur > 0; cur--)
				if (!isu8cont(es->cbuf[cur]))
					if (argcnt-- == 0)
						break;
			yank_range(cur, es->cursor);
			del_range(cur, es->cursor);
			es->cursor = cur;
			break;

		case 'u':
			t = es;
			es = undo;
			undo = t;
			break;

		case 'U':
			if (!modified)
				return -1;
			if (grabhist(modified, ohnum) < 0)
				return -1;
			modified = 0;
			hnum = ohnum;
			break;

		case '?':
			if (hnum == hlast)
				hnum = -1;
			/* ahhh */
		case '/':
			c3 = 1;
			srchlen = 0;
			lastsearch = *cmd;
			/* FALLTHROUGH */
		case 'n':
		case 'N':
			if (lastsearch == ' ')
				return -1;
			if (lastsearch == '?')
				c1 = 1;
			else
				c1 = 0;
			if (*cmd == 'N')
				c1 = !c1;
			if ((c2 = grabsearch(modified, hnum,
			    c1, srchpat)) < 0) {
				if (c3) {
					restore_cbuf();
					refresh(0);
				}
				return -1;
			} else {
				modified = 0;
				hnum = c2;
				ohnum = hnum;
			}
			break;
		case '_': {
			int	inspace;
			char	*p, *sp;

			if (histnum(-1) < 0)
				return -1;
			p = *histpos();
#define issp(c)		(isspace((unsigned char)(c)) || (c) == '\n')
			if (argcnt) {
				while (*p && issp(*p))
					p++;
				while (*p && --argcnt) {
					while (*p && !issp(*p))
						p++;
					while (*p && issp(*p))
						p++;
				}
				if (!*p)
					return -1;
				sp = p;
			} else {
				sp = p;
				inspace = 0;
				while (*p) {
					if (issp(*p))
						inspace = 1;
					else if (inspace) {
						inspace = 0;
						sp = p;
					}
					p++;
				}
				p = sp;
			}
			modified = 1; hnum = hlast;
			if (es->cursor != es->linelen)
				es->cursor++;
			while (*p && !issp(*p)) {
				argcnt++;
				p++;
			}
			if (putbuf(" ", 1, 0) != 0)
				argcnt = -1;
			else if (putbuf(sp, argcnt, 0) != 0)
				argcnt = -1;
			if (argcnt < 0) {
				if (es->cursor != 0)
					es->cursor--;
				return -1;
			}
			insert = INSERT;
			}
			break;

		case '~': {
			char	*p;
			unsigned char c;
			int	i;

			if (es->linelen == 0)
				return -1;
			for (i = 0; i < argcnt; i++) {
				p = &es->cbuf[es->cursor];
				c = (unsigned char)*p;
				if (islower(c)) {
					modified = 1; hnum = hlast;
					*p = toupper(c);
				} else if (isupper(c)) {
					modified = 1; hnum = hlast;
					*p = tolower(c);
				}
				if (es->cursor < es->linelen - 1)
					es->cursor++;
			}
			break;
			}

		case '#':
		    {
			int ret = x_do_comment(es->cbuf, es->cbufsize,
			    &es->linelen);
			if (ret >= 0)
				es->cursor = 0;
			return ret;
		    }

		case '=':			/* at&t ksh */
		case CTRL('e'):			/* Nonstandard vi/ksh */
			print_expansions(es, 1);
			break;


		case CTRL('i'):			/* Nonstandard vi/ksh */
			if (!Flag(FVITABCOMPLETE))
				return -1;
			complete_word(1, argcnt);
			break;

		case CTRL('['):			/* some annoying at&t ksh's */
			if (!Flag(FVIESCCOMPLETE))
				return -1;
		case '\\':			/* at&t ksh */
		case CTRL('f'):			/* Nonstandard vi/ksh */
			complete_word(1, argcnt);
			break;


		case '*':			/* at&t ksh */
		case CTRL('x'):			/* Nonstandard vi/ksh */
			expand_word(1);
			break;
		}
		if (insert == 0 && es->cursor != 0 && es->cursor >= es->linelen)
			es->cursor--;
	}
	return 0;
}

static int
domove(int argcnt, const char *cmd, int sub)
{
	int	bcount, i = 0, t;
	int	ncursor = 0;

	switch (*cmd) {

	case 'b':
	case 'B':
		if (!sub && es->cursor == 0)
			return -1;
		ncursor = (*cmd == 'b' ? backword : Backword)(argcnt);
		break;

	case 'e':
	case 'E':
		if (!sub && es->cursor + 1 >= es->linelen)
			return -1;
		ncursor = (*cmd == 'e' ? endword : Endword)(argcnt);
		if (!sub)
			while (isu8cont((unsigned char)es->cbuf[--ncursor]))
				continue;
		break;

	case 'f':
	case 'F':
	case 't':
	case 'T':
		fsavecmd = *cmd;
		fsavech = cmd[1];
		/* drop through */

	case ',':
	case ';':
		if (fsavecmd == ' ')
			return -1;
		i = fsavecmd == 'f' || fsavecmd == 'F';
		t = fsavecmd > 'a';
		if (*cmd == ',')
			t = !t;
		if ((ncursor = findch(fsavech, argcnt, t, i)) < 0)
			return -1;
		if (sub && t)
			ncursor++;
		break;

	case 'h':
	case CTRL('h'):
		if (!sub && es->cursor == 0)
			return -1;
		for (ncursor = es->cursor; ncursor > 0; ncursor--)
			if (!isu8cont(es->cbuf[ncursor]))
				if (argcnt-- == 0)
					break;
		break;

	case ' ':
	case 'l':
		if (!sub && es->cursor + 1 >= es->linelen)
			return -1;
		for (ncursor = es->cursor; ncursor < es->linelen; ncursor++)
			if (!isu8cont(es->cbuf[ncursor]))
				if (argcnt-- == 0)
					break;
		break;

	case 'w':
	case 'W':
		if (!sub && es->cursor + 1 >= es->linelen)
			return -1;
		ncursor = (*cmd == 'w' ? forwword : Forwword)(argcnt);
		break;

	case '0':
		ncursor = 0;
		break;

	case '^':
		ncursor = 0;
		while (ncursor < es->linelen - 1 &&
		    isspace((unsigned char)es->cbuf[ncursor]))
			ncursor++;
		break;

	case '|':
		ncursor = argcnt;
		if (ncursor > es->linelen)
			ncursor = es->linelen;
		if (ncursor)
			ncursor--;
		while (isu8cont(es->cbuf[ncursor]))
			ncursor--;
		break;

	case '$':
		ncursor = es->linelen;
		break;

	case '%':
		ncursor = es->cursor;
		while (ncursor < es->linelen &&
		    (i = bracktype(es->cbuf[ncursor])) == 0)
			ncursor++;
		if (ncursor == es->linelen)
			return -1;
		bcount = 1;
		do {
			if (i > 0) {
				if (++ncursor >= es->linelen)
					return -1;
			} else {
				if (--ncursor < 0)
					return -1;
			}
			t = bracktype(es->cbuf[ncursor]);
			if (t == i)
				bcount++;
			else if (t == -i)
				bcount--;
		} while (bcount != 0);
		if (sub && i > 0)
			ncursor++;
		break;

	default:
		return -1;
	}
	return ncursor;
}

static int
redo_insert(int count)
{
	while (count-- > 0)
		if (putbuf(ibuf, inslen, insert==REPLACE) != 0)
			return -1;
	if (es->cursor > 0)
		while (isu8cont(es->cbuf[--es->cursor]))
			continue;
	insert = 0;
	return 0;
}

static void
yank_range(int a, int b)
{
	yanklen = b - a;
	if (yanklen != 0)
		memmove(ybuf, &es->cbuf[a], yanklen);
}

static int
bracktype(int ch)
{
	switch (ch) {

	case '(':
		return 1;

	case '[':
		return 2;

	case '{':
		return 3;

	case ')':
		return -1;

	case ']':
		return -2;

	case '}':
		return -3;

	default:
		return 0;
	}
}

/*
 *	Non user interface editor routines below here
 */

static int	cur_col;		/* current display column */
static int	pwidth;			/* display columns needed for prompt */
static int	prompt_trunc;		/* how much of prompt to truncate */
static int	prompt_skip;		/* how much of prompt to skip */
static int	winwidth;		/* available column positions */
static char	*wbuf[2];		/* current & previous window buffer */
static int	wbuf_len;		/* length of window buffers (x_cols-3)*/
static int	win;			/* number of window buffer in use */
static char	morec;			/* more character at right of window */
static char	holdbuf[CMDLEN];	/* place to hold last edit buffer */
static int	holdlen;		/* length of holdbuf */

static void
save_cbuf(void)
{
	memmove(holdbuf, es->cbuf, es->linelen);
	holdlen = es->linelen;
	holdbuf[holdlen] = '\0';
}

static void
restore_cbuf(void)
{
	es->cursor = 0;
	es->linelen = holdlen;
	memmove(es->cbuf, holdbuf, holdlen);
}

/* return a new edstate */
static struct edstate *
save_edstate(struct edstate *old)
{
	struct edstate *new;

	new = alloc(sizeof(struct edstate), APERM);
	new->cbuf = alloc(old->cbufsize, APERM);
	memcpy(new->cbuf, old->cbuf, old->linelen);
	new->cbufsize = old->cbufsize;
	new->linelen = old->linelen;
	new->cursor = old->cursor;
	new->winleft = old->winleft;
	return new;
}

static void
restore_edstate(struct edstate *new, struct edstate *old)
{
	memcpy(new->cbuf, old->cbuf, old->linelen);
	new->linelen = old->linelen;
	new->cursor = old->cursor;
	new->winleft = old->winleft;
	free_edstate(old);
}

static void
free_edstate(struct edstate *old)
{
	afree(old->cbuf, APERM);
	afree(old, APERM);
}



static void
edit_reset(char *buf, size_t len)
{
	const char *p;

	es = &ebuf;
	es->cbuf = buf;
	es->cbufsize = len;
	undo = &undobuf;
	undo->cbufsize = len;

	es->linelen = undo->linelen = 0;
	es->cursor = undo->cursor = 0;
	es->winleft = undo->winleft = 0;

	cur_col = pwidth = promptlen(prompt, &p);
	prompt_skip = p - prompt;
	if (pwidth > x_cols - 3 - MIN_EDIT_SPACE) {
		cur_col = x_cols - 3 - MIN_EDIT_SPACE;
		prompt_trunc = pwidth - cur_col;
		pwidth -= prompt_trunc;
	} else
		prompt_trunc = 0;
	if (!wbuf_len || wbuf_len != x_cols - 3) {
		wbuf_len = x_cols - 3;
		wbuf[0] = aresize(wbuf[0], wbuf_len, APERM);
		wbuf[1] = aresize(wbuf[1], wbuf_len, APERM);
	}
	(void) memset(wbuf[0], ' ', wbuf_len);
	(void) memset(wbuf[1], ' ', wbuf_len);
	winwidth = x_cols - pwidth - 3;
	win = 0;
	morec = ' ';
	holdlen = 0;
}

/*
 * this is used for calling x_escape() in complete_word()
 */
static int
x_vi_putbuf(const char *s, size_t len)
{
	return putbuf(s, len, 0);
}

static int
putbuf(const char *buf, int len, int repl)
{
	if (len == 0)
		return 0;
	if (repl) {
		if (es->cursor + len >= es->cbufsize)
			return -1;
		if (es->cursor + len > es->linelen)
			es->linelen = es->cursor + len;
	} else {
		if (es->linelen + len >= es->cbufsize)
			return -1;
		memmove(&es->cbuf[es->cursor + len], &es->cbuf[es->cursor],
		    es->linelen - es->cursor);
		es->linelen += len;
	}
	memmove(&es->cbuf[es->cursor], buf, len);
	es->cursor += len;
	return 0;
}

static void
del_range(int a, int b)
{
	if (es->linelen != b)
		memmove(&es->cbuf[a], &es->cbuf[b], es->linelen - b);
	es->linelen -= b - a;
}

static int
findch(int ch, int cnt, int forw, int incl)
{
	int	ncursor;

	if (es->linelen == 0)
		return -1;
	ncursor = es->cursor;
	while (cnt--) {
		do {
			if (forw) {
				if (++ncursor == es->linelen)
					return -1;
			} else {
				if (--ncursor < 0)
					return -1;
			}
		} while (es->cbuf[ncursor] != ch);
	}
	if (!incl) {
		if (forw)
			ncursor--;
		else
			ncursor++;
	}
	return ncursor;
}

/* Move right one character, and then to the beginning of the next word. */
static int
forwword(int argcnt)
{
	int ncursor, skip_space, want_letnum;
	unsigned char uc;

	ncursor = es->cursor;
	while (ncursor < es->linelen && argcnt--) {
		skip_space = 0;
		want_letnum = -1;
		ncursor--;
		while (++ncursor < es->linelen) {
			uc = es->cbuf[ncursor];
			if (isspace(uc)) {
				skip_space = 1;
				continue;
			} else if (skip_space)
				break; 
			if (uc & 0x80)
				continue;
			if (want_letnum == -1)
				want_letnum = letnum(uc);
			else if (want_letnum != letnum(uc))
				break;
		}
	}
	return ncursor;
}

/* Move left one character, and then to the beginning of the word. */
static int
backword(int argcnt)
{
	int ncursor, skip_space, want_letnum;
	unsigned char uc;

	ncursor = es->cursor;
	while (ncursor > 0 && argcnt--) {
		skip_space = 1;
		want_letnum = -1;
		while (ncursor-- > 0) {
			uc = es->cbuf[ncursor];
			if (isspace(uc)) {
				if (skip_space)
					continue;
				else
					break;
			}
			skip_space = 0;
			if (uc & 0x80)
				continue;
			if (want_letnum == -1)
				want_letnum = letnum(uc);
			else if (want_letnum != letnum(uc))
				break;
		}
		ncursor++;
	}
	return ncursor;
}

/* Move right one character, and then to the byte after the word. */
static int
endword(int argcnt)
{
	int ncursor, skip_space, want_letnum;
	unsigned char uc;

	ncursor = es->cursor;
	while (ncursor < es->linelen && argcnt--) {
		skip_space = 1;
		want_letnum = -1;
		while (++ncursor < es->linelen) {
			uc = es->cbuf[ncursor];
			if (isspace(uc)) {
				if (skip_space)
					continue;
				else
					break;
			}
			skip_space = 0;
			if (uc & 0x80)
				continue;
			if (want_letnum == -1)
				want_letnum = letnum(uc);
			else if (want_letnum != letnum(uc))
				break;
		}
	}
	return ncursor;
}

/* Move right one character, and then to the beginning of the next big word. */
static int
Forwword(int argcnt)
{
	int	ncursor;

	ncursor = es->cursor;
	while (ncursor < es->linelen && argcnt--) {
		while (!isspace((unsigned char)es->cbuf[ncursor]) &&
		    ncursor < es->linelen)
			ncursor++;
		while (isspace((unsigned char)es->cbuf[ncursor]) &&
		    ncursor < es->linelen)
			ncursor++;
	}
	return ncursor;
}

/* Move left one character, and then to the beginning of the big word. */
static int
Backword(int argcnt)
{
	int	ncursor;

	ncursor = es->cursor;
	while (ncursor > 0 && argcnt--) {
		while (--ncursor >= 0 &&
		    isspace((unsigned char)es->cbuf[ncursor]))
			;
		while (ncursor >= 0 &&
		    !isspace((unsigned char)es->cbuf[ncursor]))
			ncursor--;
		ncursor++;
	}
	return ncursor;
}

/* Move right one character, and then to the byte after the big word. */
static int
Endword(int argcnt)
{
	int	ncursor;

	ncursor = es->cursor;
	while (ncursor < es->linelen && argcnt--) {
		while (++ncursor < es->linelen &&
		    isspace((unsigned char)es->cbuf[ncursor]))
			;
		while (ncursor < es->linelen &&
		    !isspace((unsigned char)es->cbuf[ncursor]))
			ncursor++;
	}
	return ncursor;
}

static int
grabhist(int save, int n)
{
	char	*hptr;

	if (n < 0 || n > hlast)
		return -1;
	if (n == hlast) {
		restore_cbuf();
		ohnum = n;
		return 0;
	}
	(void) histnum(n);
	if ((hptr = *histpos()) == NULL) {
		internal_errorf(0, "grabhist: bad history array");
		return -1;
	}
	if (save)
		save_cbuf();
	if ((es->linelen = strlen(hptr)) >= es->cbufsize)
		es->linelen = es->cbufsize - 1;
	memmove(es->cbuf, hptr, es->linelen);
	es->cursor = 0;
	ohnum = n;
	return 0;
}

static int
grabsearch(int save, int start, int fwd, char *pat)
{
	char	*hptr;
	int	hist;
	int	anchored;

	if ((start == 0 && fwd == 0) || (start >= hlast-1 && fwd == 1))
		return -1;
	if (fwd)
		start++;
	else
		start--;
	anchored = *pat == '^' ? (++pat, 1) : 0;
	if ((hist = findhist(start, fwd, pat, anchored)) < 0) {
		/* if (start != 0 && fwd && match(holdbuf, pat) >= 0) { */
		/* XXX should strcmp be strncmp? */
		if (start != 0 && fwd && strcmp(holdbuf, pat) >= 0) {
			restore_cbuf();
			return 0;
		} else
			return -1;
	}
	if (save)
		save_cbuf();
	histnum(hist);
	hptr = *histpos();
	if ((es->linelen = strlen(hptr)) >= es->cbufsize)
		es->linelen = es->cbufsize - 1;
	memmove(es->cbuf, hptr, es->linelen);
	es->cursor = 0;
	return hist;
}

static void
redraw_line(int newline)
{
	(void) memset(wbuf[win], ' ', wbuf_len);
	if (newline) {
		x_putc('\r');
		x_putc('\n');
	}
	vi_pprompt(0);
	cur_col = pwidth;
	morec = ' ';
}

static void
refresh(int leftside)
{
	if (outofwin())
		rewindow();
	display(wbuf[1 - win], wbuf[win], leftside);
	win = 1 - win;
}

static int
outofwin(void)
{
	int	cur, col;

	if (es->cursor < es->winleft)
		return 1;
	col = 0;
	cur = es->winleft;
	while (cur < es->cursor)
		col = newcol((unsigned char) es->cbuf[cur++], col);
	if (col >= winwidth)
		return 1;
	return 0;
}

static void
rewindow(void)
{
	int	tcur, tcol;
	int	holdcur1, holdcol1;
	int	holdcur2, holdcol2;

	holdcur1 = holdcur2 = tcur = 0;
	holdcol1 = holdcol2 = tcol = 0;
	while (tcur < es->cursor) {
		if (tcol - holdcol2 > winwidth / 2) {
			holdcur1 = holdcur2;
			holdcol1 = holdcol2;
			holdcur2 = tcur;
			holdcol2 = tcol;
		}
		tcol = newcol((unsigned char) es->cbuf[tcur++], tcol);
	}
	while (tcol - holdcol1 > winwidth / 2)
		holdcol1 = newcol((unsigned char) es->cbuf[holdcur1++],
		    holdcol1);
	es->winleft = holdcur1;
}

/* Printing the byte ch at display column col moves to which column? */
static int
newcol(int ch, int col)
{
	if (ch == '\t')
		return (col | 7) + 1;
	if (isu8cont(ch))
		return col;
	return col + char_len(ch);
}

/* Display wb1 assuming that wb2 is currently displayed. */
static void
display(char *wb1, char *wb2, int leftside)
{
	char	*twb1;	/* pointer into the buffer to display */
	char	*twb2;	/* pointer into the previous display buffer */
	static int lastb = -1; /* last byte# written from wb1, if UTF-8 */
	int	 cur;	/* byte# in the main command line buffer */
	int	 col;	/* display column loop variable */
	int	 ncol;	/* display column of the cursor */
	int	 cnt;	/* remaining display columns to fill */
	int	 moreright;
	char	 mc;	/* new "more character" at the right of window */
	unsigned char ch;

	/*
	 * Fill the current display buffer with data from cbuf.
	 * In this first loop, col does not include the prompt.
	 */

	ncol = col = 0;
	cur = es->winleft;
	moreright = 0;
	twb1 = wb1;
	while (col < winwidth && cur < es->linelen) {
		if (cur == es->cursor && leftside)
			ncol = col + pwidth;
		if ((ch = es->cbuf[cur]) == '\t') {
			do {
				*twb1++ = ' ';
			} while (++col < winwidth && (col & 7) != 0);
		} else {
			if ((ch & 0x80) && Flag(FVISHOW8)) {
				*twb1++ = 'M';
				if (++col < winwidth) {
					*twb1++ = '-';
					col++;
				}
				ch &= 0x7f;
			}
			if (col < winwidth) {
				if (ch < ' ' || ch == 0x7f) {
					*twb1++ = '^';
					if (++col < winwidth) {
						*twb1++ = ch ^ '@@';
						col++;
					}
				} else {
					*twb1++ = ch;
					if (!isu8cont(ch))
						col++;
				}
			}
		}
		if (cur == es->cursor && !leftside)
			ncol = col + pwidth - 1;
		cur++;
	}
	if (cur == es->cursor)
		ncol = col + pwidth;

	/* Pad the current display buffer to the right margin. */

	if (col < winwidth) {
		while (col < winwidth) {
			*twb1++ = ' ';
			col++;
		}
	} else
		moreright++;
	*twb1 = ' ';

	/*
	 * Update the terminal display with data from wb1.
	 * In this final loop, col includes the prompt.
	 */

	col = pwidth;
	cnt = winwidth;
	for (twb1 = wb1, twb2 = wb2; cnt; twb1++, twb2++) {
		if (*twb1 != *twb2) {

			/*
			 * When a byte changes in the middle of a UTF-8
			 * character, back up to the start byte, unless
			 * the previous byte was the last one written.
			 */

			if (col > 0 && isu8cont(*twb1)) {
				col--;
				if (lastb >= 0 && twb1 == wb1 + lastb + 1)
					cur_col = col;
				else while (twb1 > wb1 && isu8cont(*twb1)) {
					twb1--;
					twb2--;
				}
			}

			if (cur_col != col)
				ed_mov_opt(col, wb1);

			/*
			 * Always write complete characters, and
			 * advance all pointers accordingly.
			 */

			x_putc(*twb1);
			while (isu8cont(twb1[1])) {
				x_putc(*++twb1);
				twb2++;
			}
			lastb = *twb1 & 0x80 ? twb1 - wb1 : -1;
			cur_col++;
		} else if (isu8cont(*twb1))
			continue;

		/*
		 * For changed continuation bytes, we backed up.
		 * For unchanged ones, we jumped to the next byte.
		 * So, getting here, we had a real column.
		 */

		col++;
		cnt--;
	}

	/* Update the "more character". */

	if (es->winleft > 0 && moreright)
		/* POSIX says to use * for this but that is a globbing
		 * character and may confuse people; + is more innocuous
		 */
		mc = '+';
	else if (es->winleft > 0)
		mc = '<';
	else if (moreright)
		mc = '>';
	else
		mc = ' ';
	if (mc != morec) {
		ed_mov_opt(pwidth + winwidth + 1, wb1);
		x_putc(mc);
		cur_col++;
		morec = mc;
		lastb = -1;
	}

	/* Move the cursor to its new position. */

	if (cur_col != ncol) {
		ed_mov_opt(ncol, wb1);
		lastb = -1;
	}
}

/* Move the display cursor to display column number col. */
static void
ed_mov_opt(int col, char *wb)
{
	int ci;

	/* The cursor is already at the right place. */

	if (cur_col == col)
		return;

	/* The cursor is too far right. */

	if (cur_col > col) {
		if (cur_col > 2 * col + 1) {
			/* Much too far right, redraw from scratch. */
			x_putc('\r');
			vi_pprompt(0);
			cur_col = pwidth;
		} else {
			/* Slightly too far right, back up. */
			do {
				x_putc('\b');
			} while (--cur_col > col);
			return;
		}
	}

	/* Advance the cursor. */

	for (ci = pwidth; ci < col || isu8cont(*wb);
	     ci = newcol((unsigned char)*wb++, ci))
		if (ci > cur_col || (ci == cur_col && !isu8cont(*wb)))
			x_putc(*wb);
	cur_col = ci;
}


/* replace word with all expansions (ie, expand word*) */
static int
expand_word(int command)
{
	static struct edstate *buf;
	int rval = 0;
	int nwords;
	int start, end;
	char **words;
	int i;

	/* Undo previous expansion */
	if (command == 0 && expanded == EXPAND && buf) {
		restore_edstate(es, buf);
		buf = NULL;
		expanded = NONE;
		return 0;
	}
	if (buf) {
		free_edstate(buf);
		buf = NULL;
	}

	nwords = x_cf_glob(XCF_COMMAND_FILE|XCF_FULLPATH,
	    es->cbuf, es->linelen, es->cursor,
	    &start, &end, &words, NULL);
	if (nwords == 0) {
		vi_error();
		return -1;
	}

	buf = save_edstate(es);
	expanded = EXPAND;
	del_range(start, end);
	es->cursor = start;
	for (i = 0; i < nwords; ) {
		if (x_escape(words[i], strlen(words[i]), x_vi_putbuf) != 0) {
			rval = -1;
			break;
		}
		if (++i < nwords && putbuf(" ", 1, 0) != 0) {
			rval = -1;
			break;
		}
	}
	i = buf->cursor - end;
	if (rval == 0 && i > 0)
		es->cursor += i;
	modified = 1; hnum = hlast;
	insert = INSERT;
	lastac = 0;
	refresh(0);
	return rval;
}

static int
complete_word(int command, int count)
{
	static struct edstate *buf;
	int rval = 0;
	int nwords;
	int start, end;
	char **words;
	char *match;
	int match_len;
	int is_unique;
	int is_command;

	/* Undo previous completion */
	if (command == 0 && expanded == COMPLETE && buf) {
		print_expansions(buf, 0);
		expanded = PRINT;
		return 0;
	}
	if (command == 0 && expanded == PRINT && buf) {
		restore_edstate(es, buf);
		buf = NULL;
		expanded = NONE;
		return 0;
	}
	if (buf) {
		free_edstate(buf);
		buf = NULL;
	}

	/* XCF_FULLPATH for count 'cause the menu printed by print_expansions()
	 * was done this way.
	 */
	nwords = x_cf_glob(XCF_COMMAND_FILE | (count ? XCF_FULLPATH : 0),
	    es->cbuf, es->linelen, es->cursor,
	    &start, &end, &words, &is_command);
	if (nwords == 0) {
		vi_error();
		return -1;
	}
	if (count) {
		int i;

		count--;
		if (count >= nwords) {
			vi_error();
			x_print_expansions(nwords, words, is_command);
			x_free_words(nwords, words);
			redraw_line(0);
			return -1;
		}
		/*
		 * Expand the count'th word to its basename
		 */
		if (is_command) {
			match = words[count] +
			    x_basename(words[count], NULL);
			/* If more than one possible match, use full path */
			for (i = 0; i < nwords; i++)
				if (i != count &&
				    strcmp(words[i] + x_basename(words[i],
				    NULL), match) == 0) {
					match = words[count];
					break;
				}
		} else
			match = words[count];
		match_len = strlen(match);
		is_unique = 1;
		/* expanded = PRINT;	next call undo */
	} else {
		match = words[0];
		match_len = x_longest_prefix(nwords, words);
		expanded = COMPLETE;	/* next call will list completions */
		is_unique = nwords == 1;
	}

	buf = save_edstate(es);
	del_range(start, end);
	es->cursor = start;

	/* escape all shell-sensitive characters and put the result into
	 * command buffer */
	rval = x_escape(match, match_len, x_vi_putbuf);

	if (rval == 0 && is_unique) {
		/* If exact match, don't undo.  Allows directory completions
		 * to be used (ie, complete the next portion of the path).
		 */
		expanded = NONE;

		/* If not a directory, add a space to the end... */
		if (match_len > 0 && match[match_len - 1] != '/')
			rval = putbuf(" ", 1, 0);
	}
	x_free_words(nwords, words);

	modified = 1; hnum = hlast;
	insert = INSERT;
	lastac = 0;	 /* prevent this from being redone... */
	refresh(0);

	return rval;
}

static int
print_expansions(struct edstate *e, int command)
{
	int nwords;
	int start, end;
	char **words;
	int is_command;

	nwords = x_cf_glob(XCF_COMMAND_FILE|XCF_FULLPATH,
	    e->cbuf, e->linelen, e->cursor,
	    &start, &end, &words, &is_command);
	if (nwords == 0) {
		vi_error();
		return -1;
	}
	x_print_expansions(nwords, words, is_command);
	x_free_words(nwords, words);
	redraw_line(0);
	return 0;
}

/*
 * The number of bytes needed to encode byte c.
 * Control bytes get "M-" or "^" prepended.
 * This function does not handle tabs.
 */
static int
char_len(int c)
{
	int len = 1;

	if ((c & 0x80) && Flag(FVISHOW8)) {
		len += 2;
		c &= 0x7f;
	}
	if (c < ' ' || c == 0x7f)
		len++;
	return len;
}

/* Similar to x_zotc(emacs.c), but no tab weirdness */
static void
x_vi_zotc(int c)
{
	if (Flag(FVISHOW8) && (c & 0x80)) {
		x_puts("M-");
		c &= 0x7f;
	}
	if (c < ' ' || c == 0x7f) {
		x_putc('^');
		c ^= '@@';
	}
	x_putc(c);
}

static void
vi_pprompt(int full)
{
	pprompt(prompt + (full ? 0 : prompt_skip), prompt_trunc);
}

static void
vi_error(void)
{
	/* Beem out of any macros as soon as an error occurs */
	vi_macro_reset();
	x_putc(BEL);
	x_flush();
}

static void
vi_macro_reset(void)
{
	if (macro.p) {
		afree(macro.buf, APERM);
		memset((char *) &macro, 0, sizeof(macro));
	}
}

static int
isu8cont(unsigned char c)
{
	return !Flag(FVISHOW8) && (c & (0x80 | 0x40)) == 0x80;
}
#endif	/* VI */
@


1.43
log
@resolve code duplication in domove() for the commands: b B w W
no functional change; suggested by tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.42 2016/10/17 17:44:47 schwarze Exp $	*/
d1259 1
a1259 4
		if (es->linelen != 0)
			ncursor = es->linelen;
		else
			ncursor = 0;
@


1.42
log
@No need to inspect LC_CTYPE:
* It was only used in vi input mode.
* No functional change in case of set -o vi-show8.
* No functional change if LC_CTYPE is set to UTF-8.
* More robust for the default of LC_CTYPE=C on a UTF-8 xterm.

Behaviour changes for the combination LC_CTYPE=C with set +o vi-show8
on non-UTF-8 terminals, but that combination is useless and dangerous
with or without this patch.  If you want to edit individual raw non-ASCII
non-UTF-8 bytes on the shell command line, always use set -o vi-show8.
(Besides, i doubt that you actually want to do that; better use a real
hex editor in the first place.)

OK czarkoff@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.41 2016/10/17 17:19:08 schwarze Exp $	*/
a1171 5
		if (!sub && es->cursor == 0)
			return -1;
		ncursor = backword(argcnt);
		break;

d1175 1
a1175 1
		ncursor = Backword(argcnt);
a1230 5
		if (!sub && es->cursor + 1 >= es->linelen)
			return -1;
		ncursor = forwword(argcnt);
		break;

d1234 1
a1234 1
		ncursor = Forwword(argcnt);
@


1.41
log
@Make sure the cursor goes to the first byte of a UTF-8 character
and not to a continuation byte for these commands: b B e E w W |
Let {e,E}ndword return the position after the word because that is
easier to handle in the caller.
OK tb@@ czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.40 2016/10/11 19:52:54 schwarze Exp $	*/
d2243 1
a2243 1
	return MB_CUR_MAX > 1 && !Flag(FVISHOW8) && (c & (0x80 | 0x40)) == 0x80;
@


1.40
log
@Partial UTF-8 line editing support for ksh(1) vi input mode;
so far, it covers these commands: a h i l x /
This is an isu8cont()-based hack similar in style to what i did
in emacs input mode, but less elegant and slightly more intrusive
because the vi mode code is much more ugly and less straightforward
than the emacs mode code.  This one required partial rewrites of
a few helper functions, and comments were added while there.

This is not perfect, but hopefully reduces people's cursing
until a more rigorous solution can be devised (much) later.
Some polishing may be useful in tree, in particular adding
utf8cont() support to a few missing commands.

Mostly written shortly after Christmas 2015.
Reminded by and OK czarkoff@@.
Feedback, partial review and testing, no longer any objection by martijn@@.
Feedback and testing by tb@@.
Also read fine to nicm@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.39 2015/12/22 08:39:26 mmcc Exp $	*/
d711 2
a712 1
				cur--;
a1183 7
		if (!sub && es->cursor + 1 >= es->linelen)
			return -1;
		ncursor = endword(argcnt);
		if (sub && ncursor < es->linelen)
			ncursor++;
		break;

d1187 4
a1190 3
		ncursor = Endword(argcnt);
		if (sub && ncursor < es->linelen)
			ncursor++;
d1264 2
d1526 1
d1530 2
a1531 1
	int	ncursor;
d1535 17
a1551 12
		if (letnum(es->cbuf[ncursor]))
			while (letnum(es->cbuf[ncursor]) &&
			    ncursor < es->linelen)
				ncursor++;
		else if (!isspace((unsigned char)es->cbuf[ncursor]))
			while (!letnum(es->cbuf[ncursor]) &&
			    !isspace((unsigned char)es->cbuf[ncursor]) &&
			    ncursor < es->linelen)
				ncursor++;
		while (isspace((unsigned char)es->cbuf[ncursor]) &&
		    ncursor < es->linelen)
			ncursor++;
d1556 1
d1560 2
a1561 1
	int	ncursor;
d1565 17
a1581 13
		while (--ncursor > 0 && isspace((unsigned char)es->cbuf[ncursor]))
			;
		if (ncursor > 0) {
			if (letnum(es->cbuf[ncursor]))
				while (--ncursor >= 0 &&
				    letnum(es->cbuf[ncursor]))
					;
			else
				while (--ncursor >= 0 &&
				    !letnum(es->cbuf[ncursor]) &&
				    !isspace((unsigned char)es->cbuf[ncursor]))
					;
			ncursor++;
d1583 1
d1588 1
d1592 2
a1593 1
	int	ncursor;
d1597 17
a1613 14
		while (++ncursor < es->linelen - 1 &&
		    isspace((unsigned char)es->cbuf[ncursor]))
			;
		if (ncursor < es->linelen - 1) {
			if (letnum(es->cbuf[ncursor]))
				while (++ncursor < es->linelen &&
				    letnum(es->cbuf[ncursor]))
					;
			else
				while (++ncursor < es->linelen &&
				    !letnum(es->cbuf[ncursor]) &&
				    !isspace((unsigned char)es->cbuf[ncursor]))
					;
			ncursor--;
d1619 1
d1637 1
d1656 1
d1663 2
a1664 2
	while (ncursor < es->linelen - 1 && argcnt--) {
		while (++ncursor < es->linelen - 1 &&
d1667 3
a1669 6
		if (ncursor < es->linelen - 1) {
			while (++ncursor < es->linelen &&
			    !isspace((unsigned char)es->cbuf[ncursor]))
				;
			ncursor--;
		}
@


1.39
log
@Assign pointer variables to NULL rather than 0. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.38 2015/11/05 18:41:02 mmcc Exp $	*/
d15 1
d25 5
a29 5
	int	winleft;
	char	*cbuf;
	int	cbufsize;
	int	linelen;
	int	cursor;
d72 1
d153 1
a153 1
static struct edstate	undobuf = { 0, undocbuf, CMDLEN, 0, 0 };
d162 1
a162 1
static int	srchlen;		/* length of current search pattern */
d171 1
a171 1
static int	insert;			/* non-zero in insert mode */
d404 6
a409 2
				srchlen--;
				es->linelen -= char_len((unsigned char)locpat[srchlen]);
a576 7
			if (inslen > 0)
				inslen--;
			es->cursor--;
			if (es->cursor >= undo->linelen)
				es->linelen--;
			else
				es->cbuf[es->cursor] = undo->cbuf[es->cursor];
a581 6
			if (inslen > 0)
				inslen--;
			es->cursor--;
			es->linelen--;
			memmove(&es->cbuf[es->cursor], &es->cbuf[es->cursor+1],
			    es->linelen - es->cursor + 1);
d583 16
d772 2
a773 1
				es->cursor++;
d976 6
a981 4
			if (es->cursor + argcnt > es->linelen)
				argcnt = es->linelen - es->cursor;
			yank_range(es->cursor, es->cursor + argcnt);
			del_range(es->cursor, es->cursor + argcnt);
d985 1
a985 8
			if (es->cursor > 0) {
				modified = 1; hnum = hlast;
				if (es->cursor < argcnt)
					argcnt = es->cursor;
				yank_range(es->cursor - argcnt, es->cursor);
				del_range(es->cursor - argcnt, es->cursor);
				es->cursor -= argcnt;
			} else
d987 8
d1224 4
a1227 3
		ncursor = es->cursor - argcnt;
		if (ncursor < 0)
			ncursor = 0;
d1234 4
a1237 5
		if (es->linelen != 0) {
			ncursor = es->cursor + argcnt;
			if (ncursor > es->linelen)
				ncursor = es->linelen;
		}
d1317 2
a1318 1
		es->cursor--;
d1363 2
a1364 2
static int	cur_col;		/* current column on line */
static int	pwidth;			/* width of prompt */
d1367 2
a1368 2
static int	winwidth;		/* width of window */
static char	*wbuf[2];		/* window buffers */
d1370 1
a1370 1
static int	win;			/* window buffer in use */
a1371 1
static int	lastref;		/* argument to last refresh() */
a1458 1
	lastref = 1;
a1734 4
	if (leftside < 0)
		leftside = lastref;
	else
		lastref = leftside;
d1781 1
d1787 2
d1792 1
d1796 9
a1805 4
	char	*twb1, *twb2, mc;
	int	cur, col, cnt;
	int	ncol = 0;
	int	moreright;
d1807 6
a1812 1
	col = 0;
d1841 2
a1842 1
					col++;
d1852 3
d1864 5
d1871 1
a1871 3
	twb1 = wb1;
	twb2 = wb2;
	while (cnt--) {
d1873 17
d1892 6
d1899 5
d1905 9
a1913 3
		}
		twb1++;
		twb2++;
d1915 1
d1917 3
d1936 1
d1938 4
a1941 1
	if (cur_col != ncol)
d1943 2
d1947 1
d1951 12
a1962 2
	if (col < cur_col) {
		if (col + 1 < cur_col - col) {
a1965 2
			while (cur_col++ < col)
				x_putc(*wb++);
d1967 2
a1968 1
			while (cur_col-- > col)
d1970 2
a1972 4
	} else {
		wb = &wb[cur_col - pwidth];
		while (cur_col++ < col)
			x_putc(*wb++);
d1974 8
a1981 1
	cur_col = col;
d2166 5
a2170 1
/* How long is char when displayed (not counting tabs) */
d2224 5
@


1.38
log
@Capitalize entire macro name.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.37 2015/11/05 01:24:50 mmcc Exp $	*/
d1911 1
a1911 1
		buf = 0;
d1917 1
a1917 1
		buf = 0;
d1973 1
a1973 1
		buf = 0;
d1979 1
a1979 1
		buf = 0;
@


1.37
log
@Remove an alias for a macro.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.36 2015/10/19 14:42:16 mmcc Exp $	*/
d21 1
a21 1
#define Ctrl(c)		(c&0x1f)
d262 1
a262 1
			if (ch == Ctrl('v')) {
d376 1
a376 1
		if (ch == Ctrl('['))
d385 1
a385 1
		if (ch == '\r' || ch == '\n' /*|| ch == Ctrl('[')*/ ) {
d400 1
a400 1
		} else if (ch == edchars.erase || ch == Ctrl('h')) {
d552 1
a552 1
	else if (ch == Ctrl('v'))
d565 1
a565 1
	if (ch == edchars.erase || ch == Ctrl('h')) {
d623 1
a623 1
	if (first_insert && ch != Ctrl('['))
d633 1
a633 1
	case Ctrl('['):
d651 1
a651 1
	case Ctrl('x'):
d655 1
a655 1
	case Ctrl('f'):
d659 1
a659 1
	case Ctrl('e'):
d663 1
a663 1
	case Ctrl('i'):
d718 2
a719 2
		case Ctrl('l'):
		case Ctrl('r'):
d891 1
a891 1
		case Ctrl('n'):
d902 1
a902 1
		case Ctrl('p'):
d1118 1
a1118 1
		case Ctrl('e'):			/* Nonstandard vi/ksh */
d1123 1
a1123 1
		case Ctrl('i'):			/* Nonstandard vi/ksh */
d1129 1
a1129 1
		case Ctrl('['):			/* some annoying at&t ksh's */
d1133 1
a1133 1
		case Ctrl('f'):			/* Nonstandard vi/ksh */
d1139 1
a1139 1
		case Ctrl('x'):			/* Nonstandard vi/ksh */
d1208 1
a1208 1
	case Ctrl('h'):
@


1.36
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.35 2015/10/19 02:15:45 mmcc Exp $	*/
a21 1
#define	is_wordch(c)	(letnum(c))
d1524 2
a1525 2
		if (is_wordch(es->cbuf[ncursor]))
			while (is_wordch(es->cbuf[ncursor]) &&
d1529 1
a1529 1
			while (!is_wordch(es->cbuf[ncursor]) &&
d1550 1
a1550 1
			if (is_wordch(es->cbuf[ncursor]))
d1552 1
a1552 1
				    is_wordch(es->cbuf[ncursor]))
d1556 1
a1556 1
				    !is_wordch(es->cbuf[ncursor]) &&
d1576 1
a1576 1
			if (is_wordch(es->cbuf[ncursor]))
d1578 1
a1578 1
				    is_wordch(es->cbuf[ncursor]))
d1582 1
a1582 1
				    !is_wordch(es->cbuf[ncursor]) &&
@


1.35
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.34 2015/10/15 19:36:50 mmcc Exp $	*/
d15 1
@


1.34
log
@Introduce an unsigned char variable for the ctype function calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.33 2015/09/18 07:28:24 nicm Exp $	*/
d12 4
a16 2
#include <ctype.h>
#include <sys/stat.h>		/* completion */
@


1.33
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.32 2015/09/17 14:21:33 nicm Exp $	*/
d1085 1
d1092 2
a1093 1
				if (islower((unsigned char)*p)) {
d1095 2
a1096 2
					*p = toupper(*p);
				} else if (isupper((unsigned char)*p)) {
d1098 1
a1098 1
					*p = tolower(*p);
@


1.32
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.31 2015/09/15 18:15:05 tedu Exp $	*/
d1918 1
a1918 1
	    &start, &end, &words, (int *) 0);
@


1.31
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.30 2015/09/10 22:48:58 nicm Exp $	*/
d1380 1
a1380 1
	new = (struct edstate *)alloc(sizeof(struct edstate), APERM);
@


1.30
log
@Replace newline and space defines by "\n" and " " directly, from Michael
McConville. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.29 2015/09/01 13:12:31 tedu Exp $	*/
d2004 1
a2004 1
			    x_basename(words[count], (char *) 0);
d2009 1
a2009 1
				    (char *) 0), match) == 0) {
@


1.29
log
@remove casts and null checks before free. from Michael McConville
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.28 2013/12/18 16:45:46 deraadt Exp $	*/
d1070 1
a1070 1
			if (putbuf(space, 1, 0) != 0)
d1933 1
a1933 1
		if (++i < nwords && putbuf(space, 1, 0) != 0) {
d2041 1
a2041 1
			rval = putbuf(space, 1, 0);
@


1.28
log
@incorrect cast for ctype, spotted and repaired by LEVAI Daniel
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.27 2013/12/17 16:37:06 deraadt Exp $	*/
d1404 1
a1404 1
	afree((char *)old, APERM);
@


1.27
log
@ctype cleanups.  Repeated re-audits of this sensitive area by okan and
myself, with a variety of other people spending some time as well.
Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.26 2009/06/29 22:50:19 martynas Exp $	*/
d796 2
a797 2
					while ((unsigned char)
					    isspace(es->cbuf[--ncursor]))
@


1.26
log
@make VSEARCH werase act like regular werase after the last change.
vi back-words and emacs kill-region are not completely the same.
ok merdely@@, millert@@.  "Get it in" Darrin Chandler
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.25 2009/06/10 15:08:46 merdely Exp $	*/
d200 1
a200 1
			c = *macro.p++;
d795 3
a797 2
				    !isspace(es->cbuf[es->cursor])) {
					while (isspace(es->cbuf[--ncursor]))
d1036 1
a1036 1
#define issp(c)		(isspace((c)) || (c) == '\n')
d1091 1
a1091 1
				if (islower(*p)) {
d1094 1
a1094 1
				} else if (isupper(*p)) {
d1241 2
a1242 1
		while (ncursor < es->linelen - 1 && isspace(es->cbuf[ncursor]))
d1524 1
a1524 1
		else if (!isspace(es->cbuf[ncursor]))
d1526 1
a1526 1
			    !isspace(es->cbuf[ncursor]) &&
d1529 2
a1530 1
		while (isspace(es->cbuf[ncursor]) && ncursor < es->linelen)
d1543 1
a1543 1
		while (--ncursor > 0 && isspace(es->cbuf[ncursor]))
d1553 1
a1553 1
				    !isspace(es->cbuf[ncursor]))
d1569 1
a1569 1
		    isspace(es->cbuf[ncursor]))
d1579 1
a1579 1
				    !isspace(es->cbuf[ncursor]))
d1594 2
a1595 1
		while (!isspace(es->cbuf[ncursor]) && ncursor < es->linelen)
d1597 2
a1598 1
		while (isspace(es->cbuf[ncursor]) && ncursor < es->linelen)
d1611 2
a1612 1
		while (--ncursor >= 0 && isspace(es->cbuf[ncursor]))
d1614 2
a1615 1
		while (ncursor >= 0 && !isspace(es->cbuf[ncursor]))
d1630 1
a1630 1
		    isspace(es->cbuf[ncursor]))
d1634 1
a1634 1
			    !isspace(es->cbuf[ncursor]))
@


1.25
log
@Fix problem with ^w fix that broke 'B'
Found by Daniel LEVAI
Fix by Darrin Chandler
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.24 2009/06/04 04:03:22 merdely Exp $	*/
d416 1
d420 8
a427 4
			while (n > 0 && !is_wordch(locpat[n - 1]))
				n--;
			while (n > 0 && is_wordch(locpat[n - 1]))
				n--;
@


1.24
log
@"make ksh vi mode handle werase more like vi. It's really irritating to
have whole paths go away on ^W instead of just the last bit."

"That looks right to me" millert@@, "YES kthx bye!" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.23 2006/04/10 14:38:59 jaredy Exp $	*/
d599 1
a599 1
			tcursor = Backword(1);
d1601 1
a1601 1
		while (--ncursor >= 0 && !is_wordch(es->cbuf[ncursor]))
d1603 1
a1603 1
		while (ncursor >= 0 && is_wordch(es->cbuf[ncursor]))
@


1.23
log
@fix lint comments, no functional changes; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.22 2005/12/11 20:31:21 otto Exp $	*/
d419 1
a419 1
			while (n > 0 && isspace(locpat[n - 1]))
d421 1
a421 1
			while (n > 0 && !isspace(locpat[n - 1]))
d1601 1
a1601 1
		while (--ncursor >= 0 && isspace(es->cbuf[ncursor]))
d1603 1
a1603 1
		while (ncursor >= 0 && !isspace(es->cbuf[ncursor]))
@


1.22
log
@fix a few name clashes with libc; found by lint. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.21 2005/03/30 17:16:37 deraadt Exp $	*/
d856 1
a856 1
			/* fall through */
d999 1
a999 1
			/* fall through */
@


1.21
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.20 2005/03/28 21:28:22 deraadt Exp $	*/
d725 1
a725 1
				ap = tsearch(&aliases, alias, hash(alias));
@


1.20
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.19 2005/01/27 16:25:06 danh Exp $	*/
d210 1
a210 1
		} else {
d212 1
a212 1
		}
d253 2
a254 4
	static char	curcmd[MAXVICMD];
	static char	locpat[SRCHLEN];
	static int	cmdlen;
	static int	argc1, argc2;
d295 1
a295 1
						if (putbuf("/", 1, 0) != 0) {
a296 1
						}
d298 1
a298 1
							return -1;
d306 1
a306 1
						strlen(ksh_version + 4), 0);
d401 1
a401 1
				es->linelen -= char_len((unsigned char) locpat[srchlen]);
d424 1
a424 1
				es->linelen -= char_len((unsigned char) locpat[i]);
d493 1
a493 1
						lastcmd[0] == 'C') {
d581 1
a581 1
					es->linelen - es->cursor + 1);
d590 1
a590 1
						es->linelen - es->cursor);
d601 1
a601 1
						es->linelen - es->cursor);
d638 1
a638 1
				lastcmd[0] == 'C')
d670 1
a670 1
					es->linelen - es->cursor);
d735 2
a736 2
				olen = !macro.p ? 2
					: macro.len - (macro.p - macro.buf);
d789 2
a790 2
						(cmd[1]=='w' || cmd[1]=='W') &&
						!isspace(es->cbuf[es->cursor])) {
d948 3
a950 3
					argcnt ? "%s %d" : "%s",
					"fc -e ${VISUAL:-${EDITOR:-vi}} --",
					argcnt);
d1011 1
a1011 1
							c1, srchpat)) < 0) {
d1101 1
a1101 1
					    &es->linelen);
d1257 1
a1257 1
				(i = bracktype(es->cbuf[ncursor])) == 0)
d1462 1
a1462 1
			es->linelen - es->cursor);
d1515 1
a1515 1
					ncursor < es->linelen)
d1519 2
a1520 2
					!isspace(es->cbuf[ncursor]) &&
					ncursor < es->linelen)
d1540 1
a1540 1
				   is_wordch(es->cbuf[ncursor]))
d1544 2
a1545 2
				   !is_wordch(es->cbuf[ncursor]) &&
				   !isspace(es->cbuf[ncursor]))
d1561 1
a1561 1
				isspace(es->cbuf[ncursor]))
d1566 1
a1566 1
					  is_wordch(es->cbuf[ncursor]))
d1570 2
a1571 2
				   !is_wordch(es->cbuf[ncursor]) &&
				   !isspace(es->cbuf[ncursor]))
d1618 1
a1618 1
				isspace(es->cbuf[ncursor]))
d1622 1
a1622 1
					!isspace(es->cbuf[ncursor]))
d1753 1
a1753 1
				  holdcol1);
d1905 2
a1906 2
		es->cbuf, es->linelen, es->cursor,
		&start, &end, &words, (int *) 0);
d1970 2
a1971 2
		es->cbuf, es->linelen, es->cursor,
		&start, &end, &words, &is_command);
d1991 2
a1992 2
			match = words[count]
				+ x_basename(words[count], (char *) 0);
d1996 2
a1997 4
				    strcmp(words[i]
					    + x_basename(words[i], (char *) 0),
					    match) == 0)
				{
d2050 2
a2051 2
		e->cbuf, e->linelen, e->cursor,
		&start, &end, &words, &is_command);
@


1.19
log
@fix some vi-mode bugs spotted by jmc@@

tested by jmc@@, ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.18 2004/12/22 17:14:34 millert Exp $	*/
d31 1
a31 1
static void 	vi_reset(char *, size_t);
d63 2
a64 2
static int 	char_len(int);
static void 	x_vi_zotc(int);
d144 1
a144 1
static struct edstate 	*save_edstate(struct edstate *old);
d146 1
a146 1
static void 		free_edstate(struct edstate *old);
@


1.18
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.17 2004/12/20 11:34:26 otto Exp $	*/
d858 1
a858 1
				argcnt = hlast + 1;
d912 9
a920 2
			else
				es->cbuf[es->cursor] = cmd[1];
d939 1
a939 1
			if (es->linelen == 0)
@


1.17
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.16 2004/12/19 04:14:20 deraadt Exp $	*/
d221 1
a221 1
				x_mode(FALSE);
@


1.16
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.15 2004/12/18 21:25:44 millert Exp $	*/
d30 9
a38 9
static int	vi_hook(int ch);
static void 	vi_reset(char *buf, size_t len);
static int	nextstate(int ch);
static int	vi_insert(int ch);
static int	vi_cmd(int argcnt, const char *cmd);
static int	domove(int argcnt, const char *cmd, int sub);
static int	redo_insert(int count);
static void	yank_range(int a, int b);
static int	bracktype(int ch);
d41 14
a54 14
static void	edit_reset(char *buf, size_t len);
static int	putbuf(const char *buf, int len, int repl);
static void	del_range(int a, int b);
static int	findch(int ch, int cnt, int forw, int incl);
static int	forwword(int argcnt);
static int	backword(int argcnt);
static int	endword(int argcnt);
static int	Forwword(int argcnt);
static int	Backword(int argcnt);
static int	Endword(int argcnt);
static int	grabhist(int save, int n);
static int	grabsearch(int save, int start, int fwd, char *pat);
static void	redraw_line(int newline);
static void	refresh(int leftside);
d57 9
a65 9
static int	newcol(int ch, int col);
static void	display(char *wb1, char *wb2, int leftside);
static void	ed_mov_opt(int col, char *wb);
static int	expand_word(int command);
static int	complete_word(int command, int count);
static int	print_expansions(struct edstate *e, int command);
static int 	char_len(int c);
static void 	x_vi_zotc(int c);
static void	vi_pprompt(int full);
d68 1
a68 1
static int	x_vi_putbuf(const char *s, size_t len);
d191 1
a191 3
x_vi(buf, len)
	char	*buf;
	size_t	len;
d251 1
a251 2
vi_hook(ch)
	int		ch;
d524 1
a524 3
vi_reset(buf, len)
	char	*buf;
	size_t	len;
d538 1
a538 2
nextstate(ch)
	int	ch;
d557 1
a557 2
vi_insert(ch)
	int	ch;
d685 1
a685 3
vi_cmd(argcnt, cmd)
	int		argcnt;
	const char	*cmd;
d1136 1
a1136 4
domove(argcnt, cmd, sub)
	int	argcnt;
	const char *cmd;
	int	sub;
d1283 1
a1283 2
redo_insert(count)
	int	count;
d1295 1
a1295 2
yank_range(a, b)
	int	a, b;
d1303 1
a1303 2
bracktype(ch)
	int	ch;
d1348 1
a1348 1
save_cbuf()
d1356 1
a1356 1
restore_cbuf()
d1365 1
a1365 2
save_edstate(old)
	struct edstate *old;
d1380 1
a1380 2
restore_edstate(new, old)
	struct edstate *old, *new;
d1390 1
a1390 2
free_edstate(old)
	struct edstate *old;
d1399 1
a1399 3
edit_reset(buf, len)
	char	*buf;
	size_t	len;
d1439 1
a1439 3
x_vi_putbuf(s, len)
	const char *s;
	size_t len;
d1445 1
a1445 4
putbuf(buf, len, repl)
	const char *buf;
	int	len;
	int	repl;
d1467 1
a1467 2
del_range(a, b)
	int	a, b;
d1475 1
a1475 5
findch(ch, cnt, forw, incl)
	int	ch;
	int	cnt;
	int	forw;
	int	incl;
d1503 1
a1503 2
forwword(argcnt)
	int	argcnt;
d1525 1
a1525 2
backword(argcnt)
	int	argcnt;
d1550 1
a1550 2
endword(argcnt)
	int	argcnt;
d1576 1
a1576 2
Forwword(argcnt)
	int	argcnt;
d1591 1
a1591 2
Backword(argcnt)
	int	argcnt;
d1607 1
a1607 2
Endword(argcnt)
	int	argcnt;
d1627 1
a1627 3
grabhist(save, n)
	int	save;
	int	n;
d1654 1
a1654 3
grabsearch(save, start, fwd, pat)
	int	save, start, fwd;
	char	*pat;
d1688 1
a1688 2
redraw_line(newline)
	int newline;
d1701 1
a1701 2
refresh(leftside)
	int		leftside;
d1714 1
a1714 1
outofwin()
d1730 1
a1730 1
rewindow()
d1754 1
a1754 2
newcol(ch, col)
	int	ch, col;
d1762 1
a1762 3
display(wb1, wb2, leftside)
	char	*wb1, *wb2;
	int	leftside;
d1855 1
a1855 3
ed_mov_opt(col, wb)
	int	col;
	char	*wb;
d1879 1
a1879 2
expand_word(command)
	int command;
d1933 1
a1933 3
complete_word(command, count)
	int command;
	int count;
d2040 1
a2040 3
print_expansions(e, command)
	struct edstate *e;
	int	command;
d2062 1
a2062 2
char_len(c)
	int c;
d2077 1
a2077 2
x_vi_zotc(c)
	int c;
d2091 1
a2091 2
vi_pprompt(full)
	int full;
d2097 1
a2097 1
vi_error()
d2106 1
a2106 1
vi_macro_reset()
@


1.15
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.14 2004/12/18 20:55:52 millert Exp $	*/
d1112 1
a1112 1
		case '=': 			/* at&t ksh */
@


1.14
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.13 2004/05/10 16:28:47 pvalchev Exp $	*/
d1774 3
a1776 3
	register int	tcur, tcol;
	int		holdcur1, holdcol1;
	int		holdcur2, holdcol2;
@


1.13
log
@double the command line buffer size (1024 -> 2048); ok millert deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.12 2003/10/16 22:08:48 millert Exp $	*/
d14 1
a14 1
#include "ksh_stat.h"		/* completion */
d30 39
a68 39
static int	vi_hook	ARGS((int ch));
static void 	vi_reset ARGS((char *buf, size_t len));
static int	nextstate ARGS((int ch));
static int	vi_insert ARGS((int ch));
static int	vi_cmd ARGS((int argcnt, const char *cmd));
static int	domove ARGS((int argcnt, const char *cmd, int sub));
static int	redo_insert ARGS((int count));
static void	yank_range ARGS((int a, int b));
static int	bracktype ARGS((int ch));
static void	save_cbuf ARGS((void));
static void	restore_cbuf ARGS((void));
static void	edit_reset ARGS((char *buf, size_t len));
static int	putbuf ARGS((const char *buf, int len, int repl));
static void	del_range ARGS((int a, int b));
static int	findch ARGS((int ch, int cnt, int forw, int incl));
static int	forwword ARGS((int argcnt));
static int	backword ARGS((int argcnt));
static int	endword ARGS((int argcnt));
static int	Forwword ARGS((int argcnt));
static int	Backword ARGS((int argcnt));
static int	Endword ARGS((int argcnt));
static int	grabhist ARGS((int save, int n));
static int	grabsearch ARGS((int save, int start, int fwd, char *pat));
static void	redraw_line ARGS((int newline));
static void	refresh ARGS((int leftside));
static int	outofwin ARGS((void));
static void	rewindow ARGS((void));
static int	newcol ARGS((int ch, int col));
static void	display ARGS((char *wb1, char *wb2, int leftside));
static void	ed_mov_opt ARGS((int col, char *wb));
static int	expand_word ARGS((int command));
static int	complete_word ARGS((int command, int count));
static int	print_expansions ARGS((struct edstate *e, int command));
static int 	char_len ARGS((int c));
static void 	x_vi_zotc ARGS((int c));
static void	vi_pprompt ARGS((int full));
static void	vi_error ARGS((void));
static void	vi_macro_reset ARGS((void));
static int	x_vi_putbuf	ARGS((const char *s, size_t len));
d144 3
a146 3
static struct edstate 	*save_edstate ARGS((struct edstate *old));
static void		restore_edstate ARGS((struct edstate *old, struct edstate *new));
static void 		free_edstate ARGS((struct edstate *old));
a270 23
#ifdef OS2
				/* Arrow keys generate 0xe0X, where X is H.. */
				state = VCMD;
				argc1 = 1;
				switch (x_getc()) {
				  case 'H':
					*curcmd='k';
					break;
				  case 'K':
					*curcmd='h';
					break;
				  case 'P':
					*curcmd='j';
					break;
				  case 'M':
					*curcmd='l';
					break;
				  default:
					vi_error();
					state = VNORMAL;
				}
				break;
#else /* OS2 */
a272 1
#endif /* OS2 */
a628 4

#ifdef OS2
	case 224:	 /* function key prefix */
#endif /* OS2 */
d1150 2
a1151 2
	int	bcount, UNINITIALIZED(i), t;
	int	UNINITIALIZED(ncursor);
d1709 2
a1710 2
		/* XXX should FILECMP be strncmp? */
		if (start != 0 && fwd && FILECMP(holdbuf, pat) >= 0) {
d1812 1
a1812 1
	int	UNINITIALIZED(ncol);
d2042 1
a2042 1
				    FILECMP(words[i]
d2076 1
a2076 1
		if (match_len > 0 && !ISDIRSEP(match[match_len - 1]))
@


1.12
log
@Buffers are not strings so use memcpy(), not strlcpy() to copy them.
Found by danh@@ with JG malloc options.  I've also added some further
bounds checks in the name of paranoia.  Tested by danh and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.11 2003/03/13 09:03:07 deraadt Exp $	*/
d17 1
a17 1
#define CMDLEN		1024
@


1.11
log
@a few strcpy -> strlcpy; a couple people have mailed in a variety of
patches, and i already had this sitting on my laptop at that time.. i used
that as a chance to note that we had all done the same work, more or less
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.11 2003/03/13 08:51:21 deraadt Exp $	*/
d241 1
a241 1
	if (c == -1)
d465 2
d472 2
d476 3
a478 1
				} else
d480 1
d703 1
a703 1
		if (es->linelen == es->cbufsize - 1)
d1415 1
a1416 1
	strlcpy(new->cbuf, old->cbuf, new->cbufsize);
d1427 1
a1427 1
	strncpy(new->cbuf, old->cbuf, old->linelen);
@


1.10
log
@wierd -> weird
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.9 1999/11/15 21:26:38 fgsch Exp $	*/
d425 1
a425 1
				(void) strcpy(srchpat, locpat);
d1409 1
a1409 1
	strcpy(new->cbuf, old->cbuf);
@


1.9
log
@Quote metachars on expand_word too; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.8 1999/11/14 22:04:02 d Exp $	*/
d2149 1
a2149 1
/* Similar to x_zotc(emacs.c), but no tab wierdness */
@


1.8
log
@quote metachars when completing filenames from jdolecek@@netbsd. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.7 1999/07/14 13:37:24 millert Exp $	*/
d1982 1
a1982 1
		if (putbuf(words[i], (int) strlen(words[i]), 0) != 0) {
@


1.7
log
@pdksh-5.2.14
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.6 1999/01/08 20:25:03 millert Exp $	*/
d68 1
d1476 11
d2085 6
a2090 3
	if (putbuf(match, match_len, 0) != 0)
		rval = -1;
	else if (is_unique) {
@


1.6
log
@bug fixes from pdksh-unstable-5.2.13.5; some of which we already had.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.5 1997/06/19 13:58:49 kstailey Exp $	*/
d507 1
a507 1
		switch (vi_cmd(lastac, lastcmd) != 0) {
d529 2
a530 2
			/* back from a 'v' command - don't redraw the screen */
			return 1;
@


1.5
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.3 1996/11/21 07:59:37 downsj Exp $	*/
d211 1
a211 1
		} else
d213 1
@


1.4
log
@(foo *)0 -> NULL
@
text
@d1958 1
a1958 1
		&start, &end, &words, NULL);
d2046 1
a2046 1
				+ x_basename(words[count], NULL);
d2051 1
a2051 1
					    + x_basename(words[i], NULL),
@


1.3
log
@Update to 5.2.12.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.2 1996/08/19 20:09:04 downsj Exp $	*/
d1958 1
a1958 1
		&start, &end, &words, (int *) 0);
d2046 1
a2046 1
				+ x_basename(words[count], (char *) 0);
d2051 1
a2051 1
					    + x_basename(words[i], (char *) 0),
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.1.1.1 1996/08/14 06:19:12 downsj Exp $	*/
d1140 2
a1141 1
			/* FALLTHROUGH */
d1847 1
a1847 1
						*twb1++ = es->cbuf[cur] ^ '@@';
d1851 1
a1851 1
					*twb1++ = es->cbuf[cur];
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a59 1
static int	do_comment ARGS((void));
d96 1
a96 1
	    C_,     0,      0,      0,      0,      0,      0,      0,
d1123 7
a1129 1
			return do_comment();
d1143 2
d1897 1
a1897 1
		ed_mov_opt(x_cols - 2, wb1);
a1929 42
/* Handle the commenting/uncommenting of a line */
static int
do_comment()
{
	int i, j;

	if (es->linelen == 0)
		return 1; /* somewhat arbitrary - it's what at&t ksh does */

	/* Already commented? */
	if (es->cbuf[0] == '#') {
		int saw_nl = 0;

		for (j = 0, i = 1; i < es->linelen; i++) {
			if (!saw_nl || es->cbuf[i] != '#')
				es->cbuf[j++] = es->cbuf[i];
			saw_nl = es->cbuf[i] == '\n';
		}
		es->linelen = j;
		es->cursor = 0;
		return 0;
	} else {
		int n = 1;

		/* See if there's room for the #'s - 1 per \n */
		for (i = 0; i < es->linelen; i++)
			if (es->cbuf[i] == '\n')
				n++;
		if (es->linelen + n >= es->cbufsize)
			return -1;
		/* Now add them... */
		for (i = es->linelen, j = es->linelen + n; --i >= 0; ) {
			if (es->cbuf[i] == '\n')
				es->cbuf[--j] = '#';
			es->cbuf[--j] = es->cbuf[i];
		}
		es->cbuf[0] = '#';
		es->linelen += n;
		es->cursor = 0;
		return 1;
	}
}
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
