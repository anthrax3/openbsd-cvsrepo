head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.6
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.36
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.34
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.30
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.28
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.26
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.24
	OPENBSD_5_0:1.9.0.22
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.20
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.18
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.14
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.16
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.12
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.2.0.28
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.26
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.24
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.22
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.20
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.18
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.16
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.14
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.12
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.10
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.15;
commitid	btTCreDA00YdaFhU;

1.15
date	2015.12.02.05.06.26;	author mmcc;	state Exp;
branches;
next	1.14;
commitid	jckb36yulswmgJdk;

1.14
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	C4W85jmosThChWA2;

1.13
date	2015.10.15.20.01.53;	author mmcc;	state Exp;
branches;
next	1.12;
commitid	wcZi2kjerPfYdszh;

1.12
date	2015.09.25.11.58.14;	author nicm;	state Exp;
branches;
next	1.11;
commitid	4wMDiicSiZKBaMWd;

1.11
date	2015.09.13.19.46.36;	author tedu;	state Exp;
branches;
next	1.10;
commitid	GRS59rnONLfSj8Ix;

1.10
date	2014.08.10.02.44.26;	author guenther;	state Exp;
branches;
next	1.9;
commitid	SIExam23nZ4vUfMf;

1.9
date	2006.03.14.22.08.01;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.18.22.35.41;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.18.22.12.23;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.10.01.02.05.51;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.12;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.12;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@/*	$OpenBSD: tty.c,v 1.15 2015/12/02 05:06:26 mmcc Exp $	*/

#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>

#include "sh.h"
#include "tty.h"

int		tty_fd = -1;	/* dup'd tty file descriptor */
int		tty_devtty;	/* true if tty_fd is from /dev/tty */
struct termios	tty_state;	/* saved tty state */

void
tty_close(void)
{
	if (tty_fd >= 0) {
		close(tty_fd);
		tty_fd = -1;
	}
}

/* Initialize tty_fd.  Used for saving/resetting tty modes upon
 * foreground job completion and for setting up tty process group.
 */
void
tty_init(int init_ttystate)
{
	int	do_close = 1;
	int	tfd;

	tty_close();
	tty_devtty = 1;

	tfd = open("/dev/tty", O_RDWR, 0);
	if (tfd < 0) {
		tty_devtty = 0;
		warningf(false, "No controlling tty (open /dev/tty: %s)",
		    strerror(errno));

		do_close = 0;
		if (isatty(0))
			tfd = 0;
		else if (isatty(2))
			tfd = 2;
		else {
			warningf(false, "Can't find tty file descriptor");
			return;
		}
	}
	if ((tty_fd = fcntl(tfd, F_DUPFD_CLOEXEC, FDBASE)) < 0) {
		warningf(false, "j_ttyinit: dup of tty fd failed: %s",
		    strerror(errno));
	} else if (init_ttystate)
		tcgetattr(tty_fd, &tty_state);
	if (do_close)
		close(tfd);
}
@


1.15
log
@comment typo
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.14 2015/10/19 14:42:16 mmcc Exp $	*/
d3 2
d6 1
@


1.14
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.13 2015/10/15 20:01:53 mmcc Exp $	*/
d21 1
a21 1
/* Initialize tty_fd.  Used for saving/reseting tty modes upon
@


1.13
log
@Remove an unused included header (sys/stat.h).
@
text
@d1 3
a3 1
/*	$OpenBSD: tty.c,v 1.12 2015/09/25 11:58:14 nicm Exp $	*/
@


1.12
log
@Remove EXTERN from tty.[ch], from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.11 2015/09/13 19:46:36 tedu Exp $	*/
a3 1
#include <sys/stat.h>
@


1.11
log
@move tty_close up a bit so we can use it.
combine two equiv if blocks.
from Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.10 2014/08/10 02:44:26 guenther Exp $	*/
a4 1
#define EXTERN
d6 4
a9 1
#undef EXTERN
@


1.10
log
@Replace F_DUPFD followed by setting FD_CLOEXEC with just F_DUPFD_CLOEXEC

ok matthew@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.9 2006/03/14 22:08:01 deraadt Exp $	*/
d9 9
d27 1
a27 4
	if (tty_fd >= 0) {
		close(tty_fd);
		tty_fd = -1;
	}
d30 2
a31 1
	if ((tfd = open("/dev/tty", O_RDWR, 0)) < 0) {
a34 1
	}
a35 1
	if (tfd < 0) {
a52 9
}

void
tty_close(void)
{
	if (tty_fd >= 0) {
		close(tty_fd);
		tty_fd = -1;
	}
@


1.9
log
@only santa checks things twice; from adobriyan@@gmail; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.8 2005/03/30 17:16:37 deraadt Exp $	*/
d41 1
a41 1
	if ((tty_fd = fcntl(tfd, F_DUPFD, FDBASE)) < 0) {
a43 5
	} else if (fcntl(tty_fd, F_SETFD, FD_CLOEXEC) < 0) {
		warningf(false, "j_ttyinit: can't set close-on-exec flag: %s",
		    strerror(errno));
		close(tty_fd);
		tty_fd = -1;
@


1.8
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.7 2004/12/22 17:14:34 millert Exp $	*/
d25 3
a27 6
		if (tfd < 0) {
			tty_devtty = 0;
			warningf(false,
			    "No controlling tty (open /dev/tty: %s)",
			    strerror(errno));
		}
@


1.7
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.6 2004/12/20 11:34:26 otto Exp $	*/
a24 1

d28 2
a29 2
				"No controlling tty (open /dev/tty: %s)",
				strerror(errno));
d46 1
a46 1
			strerror(errno));
d49 1
a49 1
			strerror(errno));
@


1.6
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.5 2004/12/18 22:35:41 millert Exp $	*/
d28 1
a28 1
			warningf(FALSE,
d41 1
a41 1
			warningf(FALSE, "Can't find tty file descriptor");
d46 1
a46 1
		warningf(FALSE, "j_ttyinit: dup of tty fd failed: %s",
d49 1
a49 1
		warningf(FALSE, "j_ttyinit: can't set close-on-exec flag: %s",
@


1.5
log
@Replace fd_clexec() with calls to fcntl(fd, F_SETFD, FD_CLOEXEC)
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.4 2004/12/18 22:12:23 millert Exp $	*/
d13 1
a13 2
tty_init(init_ttystate)
	int init_ttystate;
d60 1
a60 1
tty_close()
@


1.4
log
@Use struct termios instead of TTY_state typedef
Use tc[gs]etattr() instead of [gs]et_tty() abstraction
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.3 2004/12/18 20:55:52 millert Exp $	*/
d49 1
a49 1
	} else if (fd_clexec(tty_fd) < 0) {
@


1.3
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.2 1996/10/01 02:05:51 downsj Exp $	*/
a8 18
int
get_tty(fd, ts)
	int fd;
	TTY_state *ts;
{
	return tcgetattr(fd, ts);
}

int
set_tty(fd, ts, flags)
	int fd;
	TTY_state *ts;
	int flags;
{
	return tcsetattr(fd, TCSADRAIN, ts);
}


d55 1
a55 1
		get_tty(tty_fd, &tty_state);
@


1.2
log
@Integrate pdksh 5.2.9.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.1.1.1 1996/08/14 06:19:12 downsj Exp $	*/
d4 1
a4 1
#include "ksh_stat.h"
d14 1
a14 23
	int ret;

# ifdef HAVE_TERMIOS_H
	ret = tcgetattr(fd, ts);
# else /* HAVE_TERIOS_H */
#  ifdef HAVE_TERMIO_H
	ret = ioctl(fd, TCGETA, ts);
#  else /* HAVE_TERMIO_H */
	ret = ioctl(fd, TIOCGETP, &ts->sgttyb);
#   ifdef TIOCGATC
	if (ioctl(fd, TIOCGATC, &ts->lchars) < 0)
		ret = -1;
#   else
	if (ioctl(fd, TIOCGETC, &ts->tchars) < 0)
		ret = -1;
#    ifdef TIOCGLTC
	if (ioctl(fd, TIOCGLTC, &ts->ltchars) < 0)
		ret = -1;
#    endif /* TIOCGLTC */
#   endif /* TIOCGATC */
#  endif /* HAVE_TERMIO_H */
# endif /* HAVE_TERIOS_H */
	return ret;
d23 1
a23 50
	int ret = 0;

# ifdef HAVE_TERMIOS_H
	ret = tcsetattr(fd, TCSADRAIN, ts);
# else /* HAVE_TERIOS_H */
#  ifdef HAVE_TERMIO_H
#   ifndef TCSETAW				/* e.g. Cray-2 */
		/* first wait for output to drain */
#    ifdef TCSBRK
		if (ioctl(tty_fd, TCSBRK, 1) < 0)
			ret = -1;
#    else /* the following kludge is minimally intrusive, but sometimes fails */
		if (flags & TF_WAIT)
			sleep((unsigned)1);	/* fake it */
#    endif
#   endif /* !TCSETAW */
#   if defined(_BSD_SYSV) || !defined(TCSETAW)
/* _BSD_SYSV must force TIOCSETN instead of TIOCSETP (preserve type-ahead) */
		if (ioctl(tty_fd, TCSETA, ts) < 0)
			ret = -1;
#   else
		if (ioctl(tty_fd, TCSETAW, ts) < 0)
			ret = -1;
#   endif
#  else /* HAVE_TERMIO_H */
#   if defined(__mips) && (defined(_SYSTYPE_BSD43) || defined(__SYSTYPE_BSD43))
	/* Under RISC/os 5.00, bsd43 environment, after a tty driver
	 * generated interrupt (eg, INTR, TSTP), all output to tty is
	 * lost until a SETP is done (there must be a better way of
	 * doing this...).
	 */
	if (flags & TF_MIPSKLUDGE)
		ret = ioctl(fd, TIOCSETP, &ts->sgttyb);
	else
#   endif /* _SYSTYPE_BSD43 */
	    ret = ioctl(fd, TIOCSETN, &ts->sgttyb);
#   ifdef TIOCGATC
	if (ioctl(fd, TIOCSATC, &ts->lchars) < 0)
		ret = -1;
#   else
	if (ioctl(fd, TIOCSETC, &ts->tchars) < 0)
		ret = -1;
#    ifdef TIOCGLTC
	if (ioctl(fd, TIOCSLTC, &ts->ltchars) < 0)
		ret = -1;
#    endif /* TIOCGLTC */
#   endif /* TIOCGATC */
#  endif /* HAVE_TERMIO_H */
# endif /* HAVE_TERIOS_H */
	return ret;
a42 2
	/* SCO can't job control on /dev/tty, so don't try... */
#if !defined(__SCO__)
a43 15
#ifdef __NeXT
		/* rlogin on NeXT boxes does not set up the controlling tty,
		 * so force it to be done here...
		 */
		{
			extern char *ttyname ARGS((int));
			char *s = ttyname(isatty(2) ? 2 : 0);
			int fd;

			if (s && (fd = open(s, O_RDWR, 0)) >= 0) {
				close(fd);
				tfd = open("/dev/tty", O_RDWR, 0);
			}
		}
#endif /* __NeXT */
a44 2
/* X11R5 xterm on mips doesn't set controlling tty properly - temporary hack */
# if !defined(__mips) || !(defined(_SYSTYPE_BSD43) || defined(__SYSTYPE_BSD43))
a50 1
# endif /* __mips  */
a51 3
#else /* !__SCO__ */
	tfd = -1;
#endif /* __SCO__ */
d64 1
a64 1
	if ((tty_fd = ksh_dupbase(tfd, FDBASE)) < 0) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d117 16
d135 6
a140 3
		tty_devtty = 0;
		warningf(FALSE, "No controlling tty (open /dev/tty: %s)",
			strerror(errno));
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
