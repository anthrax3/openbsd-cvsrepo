head	1.3;
access;
symbols
	OPENBSD_3_6:1.2.0.28
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.26
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.24
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.22
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.20
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.18
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.16
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.14
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.12
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.10
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.12.18.20.55.52;	author millert;	state dead;
branches;
next	1.2;

1.2
date	96.08.25.12.37.58;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.12;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.12;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@/*	$OpenBSD: conf-end.h,v 1.2 1996/08/25 12:37:58 downsj Exp $	*/

/*
 * End of configuration stuff for PD ksh.
 */

#if defined(EMACS) || defined(VI)
# define	EDIT
#else
# undef		EDIT
#endif

/* Super small configuration-- no editing. */
#if defined(EDIT) && defined(NOEDIT)
# undef EDIT
# undef EMACS
# undef VI
#endif

/* Editing implies history */
#if defined(EDIT) && !defined(HISTORY)
# define HISTORY
#endif /* EDIT */

/*
 * if you don't have mmap() you can't use Peter Collinson's history
 * mechanism.  If that is the case, then define EASY_HISTORY
 */
#if defined(HISTORY) && (!defined(COMPLEX_HISTORY) || !defined(HAVE_MMAP) || !defined(HAVE_FLOCK))
# undef COMPLEX_HISTORY
# define EASY_HISTORY			/* sjg's trivial history file */
#endif

/* Can we safely catch sigchld and wait for processes? */
#if (defined(HAVE_WAITPID) || defined(HAVE_WAIT3)) \
    && (defined(POSIX_SIGNALS) || defined(BSD42_SIGNALS))
# define JOB_SIGS
#endif

#if !defined(JOB_SIGS) || !(defined(POSIX_PGRP) || defined(BSD_PGRP))
# undef JOBS /* if no JOB_SIGS, no job control support */
#endif

/* pdksh assumes system calls return EINTR if a signal happened (this so
 * the signal handler doesn't have to longjmp()).  I don't know if this
 * happens (or can be made to happen) with sigset() et. al. (the bsd41 signal
 * routines), so, the autoconf stuff checks what they do and defines
 * SIGNALS_DONT_INTERRUPT if signals don't interrupt read().
 * If SIGNALS_DONT_INTERRUPT isn't defined and your compiler chokes on this,
 * delete the hash in front of the error (and file a bug report).
 */
#ifdef SIGNALS_DONT_INTERRUPT
  # error pdksh needs interruptable system calls.
#endif /* SIGNALS_DONT_INTERRUPT */

#ifdef HAVE_GCC_FUNC_ATTR
# define GCC_FUNC_ATTR(x)	__attribute__((x))
# define GCC_FUNC_ATTR2(x,y)	__attribute__((x,y))
#else
# define GCC_FUNC_ATTR(x)
# define GCC_FUNC_ATTR2(x,y)
#endif /* HAVE_GCC_FUNC_ATTR */
@


1.2
log
@Fix problems with compiling without KSH defined, add NOEDIT override.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf-end.h,v 1.1.1.1 1996/08/14 06:19:12 downsj Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d11 7
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
