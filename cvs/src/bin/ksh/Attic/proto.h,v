head	1.39;
access;
symbols
	OPENBSD_5_8:1.35.0.10
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.35.0.6
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.34.0.6
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.4
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.2
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.8
	OPENBSD_5_0:1.33.0.6
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.4
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.32.0.4
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.6
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.2
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.30.0.10
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.8
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.6
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.4
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.10
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.8
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.6
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.8.0.6
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2015.10.23.01.14.07;	author mmcc;	state dead;
branches;
next	1.38;
commitid	f4j1VU909xavQPGF;

1.38
date	2015.10.10.07.35.16;	author nicm;	state Exp;
branches;
next	1.37;
commitid	jWSsmii0w84yWEKn;

1.37
date	2015.10.06.21.19.06;	author nicm;	state Exp;
branches;
next	1.36;
commitid	4BHZNbt8IfEXOL1r;

1.36
date	2015.09.14.16.08.50;	author nicm;	state Exp;
branches;
next	1.35;
commitid	ahedYHs8fav8xOPq;

1.35
date	2013.09.04.15.49.19;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2012.06.27.07.17.19;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.19.17.36.08;	author jasper;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.29.23.27.26;	author jaredy;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.17.22.06.44;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.17.16.30.13;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.11.20.31.21;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.11.18.53.51;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.06.06.39.36;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.28.21.28.22;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.02.07.53.01;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.22.19.02.13;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.22.18.57.28;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.22.17.18.51;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.18.22.42.26;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.18.22.35.41;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.18.21.58.39;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.18.21.04.52;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.12.06.53.13;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.04.19.20.07;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.16.19.58.57;	author jsyn;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.16.23.11.52;	author tdeval;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.19.09.49.54;	author camield;	state Exp;
branches;
next	1.8;

1.8
date	99.07.14.13.37.24;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.06.15.01.18.35;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.01.08.20.25.01;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.10.29.04.09.21;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.06.25.19.02.15;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.11.21.07.59.34;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.57;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.39
log
@proto.h contains many function prototypes. It's apparently separate from
sh.h because the pdksh devs used a prototype generator (last run in
1992). Merging it into sh.h makes things clearer.

ok nicm@@
@
text
@/*	$OpenBSD: proto.h,v 1.38 2015/10/10 07:35:16 nicm Exp $	*/

/*
 * prototypes for PD-KSH
 * originally generated using "cproto.c 3.5 92/04/11 19:28:01 cthuang "
 * $From: proto.h,v 1.3 1994/05/19 18:32:40 michael Exp michael $
 */

/* alloc.c */
Area *	ainit(Area *);
void	afreeall(Area *);
void *	alloc(size_t, Area *);
void *	aresize(void *, size_t, Area *);
void	afree(void *, Area *);
/* c_ksh.c */
int	c_hash(char **);
int	c_cd(char **);
int	c_pwd(char **);
int	c_print(char **);
int	c_whence(char **);
int	c_command(char **);
int	c_typeset(char **);
int	c_alias(char **);
int	c_unalias(char **);
int	c_let(char **);
int	c_jobs(char **);
int	c_fgbg(char **);
int	c_kill(char **);
void	getopts_reset(int);
int	c_getopts(char **);
int	c_bind(char **);
/* c_sh.c */
int	c_label(char **);
int	c_shift(char **);
int	c_umask(char **);
int	c_dot(char **);
int	c_wait(char **);
int	c_read(char **);
int	c_eval(char **);
int	c_trap(char **);
int	c_brkcont(char **);
int	c_exitreturn(char **);
int	c_set(char **);
int	c_unset(char **);
int	c_ulimit(char **);
int	c_times(char **);
int	timex(struct op *, int, volatile int *);
void	timex_hook(struct op *, char ** volatile *);
int	c_exec(char **);
int	c_builtin(char **);
/* c_test.c */
int	c_test(char **);
/* edit.c: most prototypes in edit.h */
void	x_init(void);
int	x_read(char *, size_t);
void	set_editmode(const char *);
/* emacs.c: most prototypes in edit.h */
int	x_bind(const char *, const char *, int, int);
/* eval.c */
char *	substitute(const char *, int);
char **	eval(char **, int);
char *	evalstr(char *cp, int);
char *	evalonestr(char *cp, int);
char	*debunk(char *, const char *, size_t);
void	expand(char *, XPtrV *, int);
int	glob_str(char *, XPtrV *, int);
/* exec.c */
int	execute(struct op * volatile, volatile int, volatile int *);
int	shcomexec(char **);
struct tbl * findfunc(const char *, unsigned int, int);
int	define(const char *, struct op *);
void	builtin(const char *, int (*)(char **));
struct tbl *	findcom(const char *, int);
void	flushcom(int);
char *	search(const char *, const char *, int, int *);
int	search_access(const char *, int, int *);
int	pr_menu(char *const *);
int	pr_list(char *const *);
/* expr.c */
int	evaluate(const char *, long *, int, bool);
int	v_evaluate(struct tbl *, const char *, volatile int, bool);
/* history.c */
void	init_histvec(void);
void	hist_init(Source *);
void	hist_finish(void);
void	histsave(int, const char *, int);
#ifdef HISTORY
int	c_fc(char **);
void	sethistsize(int);
void	sethistfile(const char *);
char **	histpos(void);
int	histnum(int);
int	findhist(int, int, const char *, int);
int	findhistrel(const char *);
char  **hist_get_newest(int);

#endif /* HISTORY */
/* io.c */
void	errorf(const char *, ...)
	    __attribute__((__noreturn__, __format__ (printf, 1, 2)));
void	warningf(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	bi_errorf(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	internal_errorf(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	error_prefix(int);
void	shellf(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	shprintf(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
#ifdef KSH_DEBUG
void	kshdebug_init_(void);
void	kshdebug_printf_(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	kshdebug_dump_(const char *, const void *, int);
#endif /* KSH_DEBUG */
int	can_seek(int);
void	initio(void);
int	ksh_dup2(int, int, int);
int	savefd(int);
void	restfd(int, int);
void	openpipe(int *);
void	closepipe(int *);
int	check_fd(char *, int, const char **);
void	coproc_init(void);
void	coproc_read_close(int);
void	coproc_readw_close(int);
void	coproc_write_close(int);
int	coproc_getfd(int, const char **);
void	coproc_cleanup(int);
struct temp *maketemp(Area *, Temp_type, struct temp **);
/* jobs.c */
void	j_init(int);
void	j_suspend(void);
void	j_exit(void);
void	j_change(void);
int	exchild(struct op *, int, volatile int *, int);
void	startlast(void);
int	waitlast(void);
int	waitfor(const char *, int *);
int	j_kill(const char *, int);
int	j_resume(const char *, int);
int	j_jobs(const char *, int, int);
int	j_njobs(void);
void	j_notify(void);
pid_t	j_async(void);
int	j_stopped_running(void);
/* mail.c */
void	mcheck(void);
void	mcset(long);
void	mbset(char *);
void	mpset(char *);
/* main.c */
int	include(const char *, int, char **, int);
int	command(const char *, int);
int	shell(Source *volatile, int volatile);
void	unwind(int) __attribute__((__noreturn__));
void	newenv(int);
void	quitenv(struct shf *);
void	cleanup_parents_env(void);
void	cleanup_proc_env(void);
/* misc.c */
void	setctypes(const char *, int);
void	initctypes(void);
char *	ulton(unsigned long, int);
char *	str_save(const char *, Area *);
char *	str_nsave(const char *, int, Area *);
int	option(const char *);
char *	getoptions(void);
void	change_flag(enum sh_flag, int, int);
int	parse_args(char **, int, int *);
int	getn(const char *, int *);
int	bi_getn(const char *, int *);
int	gmatch(const char *, const char *, int);
int	has_globbing(const char *, const char *);
const unsigned char *pat_scan(const unsigned char *, const unsigned char *,
    int);
void	qsortp(void **, size_t, int (*)(const void *, const void *));
int	xstrcmp(const void *, const void *);
void	ksh_getopt_reset(Getopt *, int);
int	ksh_getopt(char **, Getopt *, const char *);
void	print_value_quoted(const char *);
void	print_columns(struct shf *, int, char *(*)(void *, int, char *, int),
    void *, int, int prefcol);
int	strip_nuls(char *, int);
int	blocking_read(int, char *, int);
int	reset_nonblock(int);
char	*ksh_get_wd(char *, int);
/* mknod.c */
int domknod(int, char **, mode_t);
int domkfifo(int, char **, mode_t);
/* path.c */
int	make_path(const char *, const char *, char **, XString *, int *);
void	simplify_path(char *);
char	*get_phys_path(const char *);
void	set_current_wd(char *);
/* syn.c */
void	initkeywords(void);
struct op * compile(Source *);
/* trace.c */
/* trap.c */
void	inittraps(void);
void	alarm_init(void);
Trap *	gettrap(const char *, int);
void	trapsig(int);
void	intrcheck(void);
int	fatal_trap_check(void);
int	trap_pending(void);
void	runtraps(int intr);
void	runtrap(Trap *);
void	cleartraps(void);
void	restoresigs(void);
void	settrap(Trap *, char *);
int	block_pipe(void);
void	restore_pipe(int);
int	setsig(Trap *, sig_t, int);
void	setexecsig(Trap *, int);
/* var.c */
void	newblock(void);
void	popblock(void);
void	initvar(void);
struct tbl *	global(const char *);
struct tbl *	local(const char *, bool);
char *	str_val(struct tbl *);
long	intval(struct tbl *);
int	setstr(struct tbl *, const char *, int);
struct tbl *setint_v(struct tbl *, struct tbl *, bool);
void	setint(struct tbl *, long);
int	getint(struct tbl *, long *, bool);
struct tbl *typeset(const char *, int, int, int, int);
void	unset(struct tbl *, int);
char  * skip_varname(const char *, int);
char	*skip_wdvarname(const char *, int);
int	is_wdvarname(const char *, int);
int	is_wdvarassign(const char *);
char **	makenv(void);
void	change_random(void);
int	array_ref_len(const char *);
char *	arrayname(const char *);
void    set_array(const char *, int, char **);
/* version.c */
/* vi.c: see edit.h */
@


1.38
log
@Move more declarations out of proto.h into better headers, from Michael
McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.37 2015/10/06 21:19:06 nicm Exp $	*/
@


1.37
log
@Move tree.c protos into tree.h, from Michael McConville, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.36 2015/09/14 16:08:50 nicm Exp $	*/
a148 7
/* lex.c */
int	yylex(int);
void	yyerror(const char *, ...)
	    __attribute__((__noreturn__, __format__ (printf, 1, 2)));
Source * pushs(int, Area *);
void	set_prompt(int, Source *);
void	pprompt(const char *, int);
a200 9
/* table.c */
unsigned int	hash(const char *);
void		ktinit(struct table *, Area *, int);
struct tbl *	ktsearch(struct table *, const char *, unsigned int);
struct tbl *	ktenter(struct table *, const char *, unsigned int);
void		ktdelete(struct tbl *);
void		ktwalk(struct tstate *, struct table *);
struct tbl *	ktnext(struct tstate *);
struct tbl **	ktsort(struct table *);
@


1.36
log
@Replace Tflag typedef with just int; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.35 2013/09/04 15:49:19 millert Exp $	*/
a234 8
/* tree.c */
void	fptreef(struct shf *, int, const char *, ...);
char *	snptreef(char *, int, const char *, ...);
struct op *	tcopy(struct op *, Area *);
char *	wdcopy(const char *, Area *);
char *	wdscan(const char *, int);
char *	wdstrip(const char *);
void	tfree(struct op *, Area *);
@


1.35
log
@Add a proper suspend builtin that saves/restores the tty and pgrp
as needed instead of an alias that just sends SIGSTOP.  Login shells
may be suspended if they are not running in an orphan process group.
OK guenther@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.34 2012/06/27 07:17:19 otto Exp $	*/
d255 1
a255 1
struct tbl *	typeset(const char *, Tflag, Tflag, int, int);
@


1.34
log
@fptreef() always returns 0 and we never use the return value anyway,
so make it void; from Michael W. Bombardieri.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.33 2010/05/19 17:36:08 jasper Exp $	*/
d135 1
@


1.33
log
@properly keep track of the line number after a trap.
this fixes pr 6195. diff from manuel giraud, thanks.

ok kili@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.32 2009/01/29 23:27:26 jaredy Exp $	*/
d235 1
a235 1
int	fptreef(struct shf *, int, const char *, ...);
@


1.32
log
@pass "xerrok" status across the execution call stack to more closely
match what both POSIX and ksh.1 already describe in regards to set
-e/errexit's behavior in determining when to exit from nonzero return
values.

specifically, the truth values tested as operands to `&&' and `||', as
well as the resulting compound expression itself, along with the truth
value resulting from a negated command (i.e. a pipeline prefixed `!'),
should not make the shell exit when -e is in effect.

issue reported by matthieu.
testing matthieu, naddy.
ok miod (earlier version), otto.
man page ok jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.31 2009/01/17 22:06:44 millert Exp $	*/
d162 1
a162 1
int	command(const char *);
@


1.31
log
@Use libc qsort instead of private version.  Tested by several people.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.30 2006/03/17 16:30:13 millert Exp $	*/
d47 1
a47 1
int	timex(struct op *, int);
d68 1
a68 1
int	execute(struct op * volatile, volatile int);
d137 1
a137 1
int	exchild(struct op *, int, int);
@


1.30
log
@Simplify savefd() by removing the "noclose" flag and make noclose
behavior the default.  Almost all uses of savefd() are followed
by an implicit or explicit close.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.29 2005/12/11 20:31:21 otto Exp $	*/
d185 2
a186 2
void	qsortp(void **, size_t, int (*)(void *, void *));
int	xstrcmp(void *, void *);
@


1.29
log
@fix a few name clashes with libc; found by lint. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.28 2005/12/11 18:53:51 deraadt Exp $	*/
d121 1
a121 1
int	savefd(int, int);
@


1.28
log
@remove unused variables and functions
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.27 2005/10/06 06:39:36 otto Exp $	*/
d209 7
a215 7
void		tinit(struct table *, Area *, int);
struct tbl *	tsearch(struct table *, const char *, unsigned int);
struct tbl *	tenter(struct table *, const char *, unsigned int);
void		tdelete(struct tbl *);
void		twalk(struct tstate *, struct table *);
struct tbl *	tnext(struct tstate *);
struct tbl **	tsort(struct table *);
@


1.27
log
@Introducing mknod as a built-in. It might be against the unix
philosophy, but in this case it's worth it. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.26 2005/03/28 21:28:22 deraadt Exp $	*/
a91 1
int	histN(void);
a168 1
void	aerror(Area *, const char *) __attribute__((__noreturn__));
@


1.26
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.25 2005/02/02 07:53:01 otto Exp $	*/
d198 3
@


1.25
log
@Introduce POSIX hex and octal (0x... and 0...) constants in arithmetic
expressions.  Work by Matthias Kilian, based on an old diff by myself.
Note: MAKEDEV should be updated. Tested by many, thanks.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.24 2004/12/22 19:02:13 millert Exp $	*/
d11 1
a11 1
void 	afreeall(Area *);
d14 1
a14 1
void 	afree(void *, Area *);
d16 13
a28 13
int 	c_hash(char **);
int 	c_cd(char **);
int 	c_pwd(char **);
int 	c_print(char **);
int 	c_whence(char **);
int 	c_command(char **);
int 	c_typeset(char **);
int 	c_alias(char **);
int 	c_unalias(char **);
int 	c_let(char **);
int 	c_jobs(char **);
int 	c_fgbg(char **);
int 	c_kill(char **);
d31 1
a31 1
int 	c_bind(char **);
d33 15
a47 15
int 	c_label(char **);
int 	c_shift(char **);
int 	c_umask(char **);
int 	c_dot(char **);
int 	c_wait(char **);
int 	c_read(char **);
int 	c_eval(char **);
int 	c_trap(char **);
int 	c_brkcont(char **);
int 	c_exitreturn(char **);
int 	c_set(char **);
int 	c_unset(char **);
int 	c_ulimit(char **);
int 	c_times(char **);
int 	timex(struct op *, int);
d49 2
a50 2
int 	c_exec(char **);
int 	c_builtin(char **);
d52 1
a52 1
int 	c_test(char **);
d54 2
a55 2
void 	x_init(void);
int 	x_read(char *, size_t);
d58 1
a58 1
int 	x_bind(const char *, const char *, int, int);
d68 2
a69 2
int 	execute(struct op * volatile, volatile int);
int 	shcomexec(char **);
d71 2
a72 2
int 	define(const char *, struct op *);
void 	builtin(const char *, int (*)(char **));
d74 1
a74 1
void 	flushcom(int);
d80 1
a80 1
int 	evaluate(const char *, long *, int, bool);
d84 2
a85 2
void 	hist_init(Source *);
void 	hist_finish(void);
d88 1
a88 1
int 	c_fc(char **);
d92 2
a93 2
int 	histN(void);
int 	histnum(int);
d100 1
a100 1
void 	errorf(const char *, ...)
d102 1
a102 1
void 	warningf(int, const char *, ...)
d104 1
a104 1
void 	bi_errorf(const char *, ...)
d106 1
a106 1
void 	internal_errorf(int, const char *, ...)
d109 1
a109 1
void 	shellf(const char *, ...)
d111 1
a111 1
void 	shprintf(const char *, ...)
d114 2
a115 2
void 	kshdebug_init_(void);
void 	kshdebug_printf_(const char *, ...)
d117 1
a117 1
void 	kshdebug_dump_(const char *, const void *, int);
d122 4
a125 4
int 	savefd(int, int);
void 	restfd(int, int);
void 	openpipe(int *);
void 	closepipe(int *);
d135 10
a144 10
void 	j_init(int);
void 	j_exit(void);
void 	j_change(void);
int 	exchild(struct op *, int, int);
void 	startlast(void);
int 	waitlast(void);
int 	waitfor(const char *, int *);
int 	j_kill(const char *, int);
int 	j_resume(const char *, int);
int 	j_jobs(const char *, int, int);
d146 1
a146 1
void 	j_notify(void);
d148 1
a148 1
int 	j_stopped_running(void);
d150 2
a151 2
int 	yylex(int);
void 	yyerror(const char *, ...)
d155 1
a155 1
void 	pprompt(const char *, int);
d157 4
a160 4
void 	mcheck(void);
void 	mcset(long);
void 	mbset(char *);
void 	mpset(char *);
d162 6
a167 6
int 	include(const char *, int, char **, int);
int 	command(const char *);
int 	shell(Source *volatile, int volatile);
void 	unwind(int) __attribute__((__noreturn__));
void 	newenv(int);
void 	quitenv(struct shf *);
d170 1
a170 1
void 	aerror(Area *, const char *) __attribute__((__noreturn__));
d172 2
a173 2
void 	setctypes(const char *, int);
void 	initctypes(void);
d181 3
a183 3
int 	getn(const char *, int *);
int 	bi_getn(const char *, int *);
int 	gmatch(const char *, const char *, int);
d187 2
a188 2
void 	qsortp(void **, size_t, int (*)(void *, void *));
int 	xstrcmp(void *, void *);
d204 1
a204 1
void 	initkeywords(void);
d207 2
a208 2
unsigned int 	hash(const char *);
void 		tinit(struct table *, Area *, int);
d211 2
a212 2
void 		tdelete(struct tbl *);
void 		twalk(struct tstate *, struct table *);
d224 4
a227 4
void 	runtraps(int intr);
void 	runtrap(Trap *);
void 	cleartraps(void);
void 	restoresigs(void);
d234 1
a234 1
int 	fptreef(struct shf *, int, const char *, ...);
d240 1
a240 1
void 	tfree(struct op *, Area *);
d242 2
a243 2
void 	newblock(void);
void 	popblock(void);
d248 2
a249 2
long 	intval(struct tbl *);
int 	setstr(struct tbl *, const char *, int);
d251 1
a251 1
void 	setint(struct tbl *, long);
d254 1
a254 1
void 	unset(struct tbl *, int);
@


1.24
log
@quitenv() proto should have the variable type only, not the name.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.23 2004/12/22 18:57:28 otto Exp $	*/
d80 2
a81 2
int 	evaluate(const char *, long *, int);
int	v_evaluate(struct tbl *, const char *, volatile int);
d250 1
a250 1
struct tbl *setint_v(struct tbl *, struct tbl *);
d252 1
a252 1
int	getint(struct tbl *, long *);
@


1.23
log
@Fix a use-after-free, that causs core dumps if a shell is killed
running with strict malloc.conf options. Problem spotted by hshoexer@@;
fix by me with some help from millert@@.

ok millert@@ hshoexer@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.22 2004/12/22 17:18:51 millert Exp $	*/
d167 1
a167 1
void 	quitenv(struct shf *shf);
@


1.22
log
@g/c str_zcpy()
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.21 2004/12/22 17:14:34 millert Exp $	*/
d167 1
a167 1
void 	quitenv(void);
@


1.21
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.20 2004/12/20 11:34:26 otto Exp $	*/
a194 1
char	*str_zcpy(char *, const char *, int);
@


1.20
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.19 2004/12/18 22:42:26 millert Exp $	*/
d247 1
a247 1
struct tbl *	local(const char *, bool_t);
@


1.19
log
@remove GCC_FUNC_ATTR/GCC_FUNC_ATTR2 and just use __attribute__ directly
(we define it away in sys/cdefs.h if it is not supported).
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.18 2004/12/18 22:35:41 millert Exp $	*/
d10 5
a14 5
Area *	ainit(Area *ap);
void 	afreeall(Area *ap);
void *	alloc(size_t size, Area *ap);
void *	aresize(void *ptr, size_t size, Area *ap);
void 	afree(void *ptr, Area *ap);
d16 16
a31 16
int 	c_hash(char **wp);
int 	c_cd(char **wp);
int 	c_pwd(char **wp);
int 	c_print(char **wp);
int 	c_whence(char **wp);
int 	c_command(char **wp);
int 	c_typeset(char **wp);
int 	c_alias(char **wp);
int 	c_unalias(char **wp);
int 	c_let(char **wp);
int 	c_jobs(char **wp);
int 	c_fgbg(char **wp);
int 	c_kill(char **wp);
void	getopts_reset(int val);
int	c_getopts(char **wp);
int 	c_bind(char **wp);
d33 18
a50 18
int 	c_label(char **wp);
int 	c_shift(char **wp);
int 	c_umask(char **wp);
int 	c_dot(char **wp);
int 	c_wait(char **wp);
int 	c_read(char **wp);
int 	c_eval(char **wp);
int 	c_trap(char **wp);
int 	c_brkcont(char **wp);
int 	c_exitreturn(char **wp);
int 	c_set(char **wp);
int 	c_unset(char **wp);
int 	c_ulimit(char **wp);
int 	c_times(char **wp);
int 	timex(struct op *t, int f);
void	timex_hook(struct op *t, char ** volatile *app);
int 	c_exec(char **wp);
int 	c_builtin(char **wp);
d52 1
a52 1
int 	c_test(char **wp);
d55 2
a56 2
int 	x_read(char *buf, size_t len);
void	set_editmode(const char *ed);
d58 1
a58 1
int 	x_bind(const char *a1, const char *a2, int macro, int list);
d60 7
a66 7
char *	substitute(const char *cp, int f);
char **	eval(char **ap, int f);
char *	evalstr(char *cp, int f);
char *	evalonestr(char *cp, int f);
char	*debunk(char *dp, const char *sp, size_t dlen);
void	expand(char *cp, XPtrV *wp, int f);
int	glob_str(char *cp, XPtrV *wp, int markdirs);
d68 11
a78 11
int 	execute(struct op * volatile t, volatile int flags);
int 	shcomexec(char **wp);
struct tbl * findfunc(const char *name, unsigned int h, int create);
int 	define(const char *name, struct op *t);
void 	builtin(const char *name, int (*func)(char **));
struct tbl *	findcom(const char *name, int flags);
void 	flushcom(int all);
char *	search(const char *name, const char *path, int mode, int *errnop);
int	search_access(const char *path, int mode, int *errnop);
int	pr_menu(char *const *ap);
int	pr_list(char *const *ap);
d80 2
a81 2
int 	evaluate(const char *expr, long *rval, int error_ok);
int	v_evaluate(struct tbl *vp, const char *expr, volatile int error_ok);
d84 1
a84 1
void 	hist_init(Source *s);
d86 1
a86 1
void	histsave(int lno, const char *cmd, int dowrite);
d88 3
a90 3
int 	c_fc(char **wp);
void	sethistsize(int n);
void	sethistfile(const char *name);
d93 4
a96 4
int 	histnum(int n);
int	findhist(int start, int fwd, const char *str, int anchored);
int	findhistrel(const char *str);
char  **hist_get_newest(int allow_cur);
d100 1
a100 1
void 	errorf(const char *fmt, ...)
d102 1
a102 1
void 	warningf(int fileline, const char *fmt, ...)
d104 1
a104 1
void 	bi_errorf(const char *fmt, ...)
d106 1
a106 1
void 	internal_errorf(int jump, const char *fmt, ...)
d108 2
a109 2
void	error_prefix(int fileline);
void 	shellf(const char *fmt, ...)
d111 1
a111 1
void 	shprintf(const char *fmt, ...)
d115 1
a115 1
void 	kshdebug_printf_(const char *fmt, ...)
d117 1
a117 1
void 	kshdebug_dump_(const char *str, const void *mem, int nbytes);
d119 1
a119 1
int	can_seek(int fd);
d121 6
a126 6
int	ksh_dup2(int ofd, int nfd, int errok);
int 	savefd(int fd, int noclose);
void 	restfd(int fd, int ofd);
void 	openpipe(int *pv);
void 	closepipe(int *pv);
int	check_fd(char *name, int mode, const char **emsgp);
d128 6
a133 6
void	coproc_read_close(int fd);
void	coproc_readw_close(int fd);
void	coproc_write_close(int fd);
int	coproc_getfd(int mode, const char **emsgp);
void	coproc_cleanup(int reuse);
struct temp *maketemp(Area *ap, Temp_type type, struct temp **tlist);
d135 1
a135 1
void 	j_init(int mflagset);
d138 1
a138 1
int 	exchild(struct op *t, int flags, int close_fd);
d141 4
a144 4
int 	waitfor(const char *cp, int *sigp);
int 	j_kill(const char *cp, int sig);
int 	j_resume(const char *cp, int bg);
int 	j_jobs(const char *cp, int slp, int nflag);
d150 2
a151 2
int 	yylex(int cf);
void 	yyerror(const char *fmt, ...)
d153 3
a155 3
Source * pushs(int type, Area *areap);
void	set_prompt(int to, Source *s);
void 	pprompt(const char *cp, int ntruncate);
d158 3
a160 3
void 	mcset(long interval);
void 	mbset(char *p);
void 	mpset(char *mptoparse);
d162 5
a166 5
int 	include(const char *name, int argc, char **argv, int intr_ok);
int 	command(const char *comm);
int 	shell(Source *volatile s, int volatile toplevel);
void 	unwind(int i) __attribute__((__noreturn__));
void 	newenv(int type);
d170 1
a170 2
void 	aerror(Area *ap, const char *msg)
	    __attribute__((__noreturn__));
d172 1
a172 1
void 	setctypes(const char *s, int t);
d174 4
a177 4
char *	ulton(unsigned long n, int base);
char *	str_save(const char *s, Area *ap);
char *	str_nsave(const char *s, int n, Area *ap);
int	option(const char *n);
d179 20
a198 21
void	change_flag(enum sh_flag f, int what, int newval);
int	parse_args(char **argv, int what, int *setargsp);
int 	getn(const char *as, int *ai);
int 	bi_getn(const char *as, int *ai);
int 	gmatch(const char *s, const char *p, int isfile);
int	has_globbing(const char *xp, const char *xpe);
const unsigned char *pat_scan(const unsigned char *p,
				const unsigned char *pe, int match_sep);
void 	qsortp(void **base, size_t n, int (*f)(void *, void *));
int 	xstrcmp(void *p1, void *p2);
void	ksh_getopt_reset(Getopt *go, int);
int	ksh_getopt(char **argv, Getopt *go, const char *options);
void	print_value_quoted(const char *s);
void	print_columns(struct shf *shf, int n,
			  char *(*func)(void *, int, char *, int),
			  void *arg, int max_width, int prefcol);
int	strip_nuls(char *buf, int nbytes);
char	*str_zcpy(char *dst, const char *src, int dsize);
int	blocking_read(int fd, char *buf, int nbytes);
int	reset_nonblock(int fd);
char	*ksh_get_wd(char *buf, int bsize);
d200 4
a203 5
int	make_path(const char *cwd, const char *file,
		      char **pathlist, XString *xsp, int *phys_pathp);
void	simplify_path(char *path);
char	*get_phys_path(const char *path);
void	set_current_wd(char *path);
d206 1
a206 1
struct op * compile(Source *s);
d208 8
a215 8
unsigned int 	hash(const char *n);
void 		tinit(struct table *tp, Area *ap, int tsize);
struct tbl *	tsearch(struct table *tp, const char *n, unsigned int h);
struct tbl *	tenter(struct table *tp, const char *n, unsigned int h);
void 		tdelete(struct tbl *p);
void 		twalk(struct tstate *ts, struct table *tp);
struct tbl *	tnext(struct tstate *ts);
struct tbl **	tsort(struct table *tp);
d220 2
a221 2
Trap *	gettrap(const char *name, int igncase);
void	trapsig(int i);
d226 1
a226 1
void 	runtrap(Trap *p);
d229 1
a229 1
void	settrap(Trap *p, char *s);
d231 3
a233 3
void	restore_pipe(int restore_dfl);
int	setsig(Trap *p, sig_t f, int flags);
void	setexecsig(Trap *p, int restore);
d235 7
a241 7
int 	fptreef(struct shf *f, int indent, const char *fmt, ...);
char *	snptreef(char *s, int n, const char *fmt, ...);
struct op *	tcopy(struct op *t, Area *ap);
char *	wdcopy(const char *wp, Area *ap);
char *	wdscan(const char *wp, int c);
char *	wdstrip(const char *wp);
void 	tfree(struct op *t, Area *ap);
d246 14
a259 14
struct tbl *	global(const char *n);
struct tbl *	local(const char *n, bool_t copy);
char *	str_val(struct tbl *vp);
long 	intval(struct tbl *vp);
int 	setstr(struct tbl *vq, const char *s, int error_ok);
struct tbl *setint_v(struct tbl *vq, struct tbl *vp);
void 	setint(struct tbl *vq, long n);
int	getint(struct tbl *vp, long *nump);
struct tbl *	typeset(const char *var, Tflag set, Tflag clr, int field, int base);
void 	unset(struct tbl *vp, int array_ref);
char  * skip_varname(const char *s, int aok);
char	*skip_wdvarname(const char *s, int aok);
int	is_wdvarname(const char *s, int aok);
int	is_wdvarassign(const char *s);
d262 3
a264 3
int	array_ref_len(const char *cp);
char *	arrayname(const char *str);
void    set_array(const char *var, int reset, char **vals);
@


1.18
log
@Replace fd_clexec() with calls to fcntl(fd, F_SETFD, FD_CLOEXEC)
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.17 2004/12/18 21:58:39 millert Exp $	*/
d101 1
a101 1
	    GCC_FUNC_ATTR2(noreturn, format(printf, 1, 2));
d103 1
a103 1
	    GCC_FUNC_ATTR(format(printf, 2, 3));
d105 1
a105 1
	    GCC_FUNC_ATTR(format(printf, 1, 2));
d107 1
a107 1
	    GCC_FUNC_ATTR(format(printf, 2, 3));
d110 1
a110 1
	    GCC_FUNC_ATTR(format(printf, 1, 2));
d112 1
a112 1
	    GCC_FUNC_ATTR(format(printf, 1, 2));
d116 1
a116 1
	    GCC_FUNC_ATTR(format(printf, 1, 2));
d152 1
a152 1
	    GCC_FUNC_ATTR2(noreturn, format(printf, 1, 2));
d165 1
a165 1
void 	unwind(int i) GCC_FUNC_ATTR(noreturn);
d171 1
a171 1
	    GCC_FUNC_ATTR(noreturn);
@


1.17
log
@Use the BSD sig_t instead of homegrown handler_t
Remove KSH_SA_FLAGS
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.16 2004/12/18 21:25:44 millert Exp $	*/
a67 1
int	fd_clexec(int fd);
@


1.16
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.15 2004/12/18 21:04:52 millert Exp $	*/
d236 1
a236 1
int	setsig(Trap *p, handler_t f, int flags);
@


1.15
log
@Get rid of #ifdef KSH since we don't care about building a V7 style sh and
the #ifdef KSH code is required to make a POSIX sh.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.14 2004/12/18 20:55:52 millert Exp $	*/
d89 1
a89 1
int 	c_fc(register char **wp);
@


1.14
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.13 2004/12/12 06:53:13 deraadt Exp $	*/
a127 1
#ifdef KSH
a133 1
#endif /* KSH */
a157 1
#ifdef KSH
a161 1
#endif /* KSH */
a222 1
#ifdef KSH
a223 1
#endif /* KSH */
@


1.13
log
@csh-style ! history completion, which can be activated by using
	set -o csh-history (off by default)
this is not feature complete, and likely never will be.  no ^
and ! has some oddities ... ksh's internal history stuff has got
some very odd behaviours that are rather nasty
ok various developers
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.12 2004/11/04 19:20:07 deraadt Exp $	*/
d10 5
a14 5
Area *	ainit		ARGS((Area *ap));
void 	afreeall	ARGS((Area *ap));
void *	alloc		ARGS((size_t size, Area *ap));
void *	aresize		ARGS((void *ptr, size_t size, Area *ap));
void 	afree		ARGS((void *ptr, Area *ap));
d16 16
a31 16
int 	c_hash		ARGS((char **wp));
int 	c_cd		ARGS((char **wp));
int 	c_pwd		ARGS((char **wp));
int 	c_print		ARGS((char **wp));
int 	c_whence	ARGS((char **wp));
int 	c_command	ARGS((char **wp));
int 	c_typeset	ARGS((char **wp));
int 	c_alias		ARGS((char **wp));
int 	c_unalias	ARGS((char **wp));
int 	c_let		ARGS((char **wp));
int 	c_jobs		ARGS((char **wp));
int 	c_fgbg		ARGS((char **wp));
int 	c_kill		ARGS((char **wp));
void	getopts_reset	ARGS((int val));
int	c_getopts	ARGS((char **wp));
int 	c_bind		ARGS((char **wp));
d33 18
a50 18
int 	c_label		ARGS((char **wp));
int 	c_shift		ARGS((char **wp));
int 	c_umask		ARGS((char **wp));
int 	c_dot		ARGS((char **wp));
int 	c_wait		ARGS((char **wp));
int 	c_read		ARGS((char **wp));
int 	c_eval		ARGS((char **wp));
int 	c_trap		ARGS((char **wp));
int 	c_brkcont	ARGS((char **wp));
int 	c_exitreturn	ARGS((char **wp));
int 	c_set		ARGS((char **wp));
int 	c_unset		ARGS((char **wp));
int 	c_ulimit	ARGS((char **wp));
int 	c_times		ARGS((char **wp));
int 	timex		ARGS((struct op *t, int f));
void	timex_hook	ARGS((struct op *t, char ** volatile *app));
int 	c_exec		ARGS((char **wp));
int 	c_builtin	ARGS((char **wp));
d52 1
a52 1
int 	c_test		ARGS((char **wp));
d54 3
a56 3
void 	x_init		ARGS((void));
int 	x_read		ARGS((char *buf, size_t len));
void	set_editmode	ARGS((const char *ed));
d58 1
a58 2
int 	x_bind		ARGS((const char *a1, const char *a2, int macro,
			      int list));
d60 7
a66 7
char *	substitute	ARGS((const char *cp, int f));
char **	eval		ARGS((char **ap, int f));
char *	evalstr		ARGS((char *cp, int f));
char *	evalonestr	ARGS((char *cp, int f));
char	*debunk		ARGS((char *dp, const char *sp, size_t dlen));
void	expand		ARGS((char *cp, XPtrV *wp, int f));
int glob_str		ARGS((char *cp, XPtrV *wp, int markdirs));
d68 12
a79 13
int	fd_clexec	ARGS((int fd));
int 	execute		ARGS((struct op * volatile t, volatile int flags));
int 	shcomexec	ARGS((char **wp));
struct tbl * findfunc	ARGS((const char *name, unsigned int h, int create));
int 	define		ARGS((const char *name, struct op *t));
void 	builtin		ARGS((const char *name, int (*func)(char **)));
struct tbl *	findcom	ARGS((const char *name, int flags));
void 	flushcom	ARGS((int all));
char *	search		ARGS((const char *name, const char *path, int mode,
			      int *errnop));
int	search_access	ARGS((const char *path, int mode, int *errnop));
int	pr_menu		ARGS((char *const *ap));
int	pr_list		ARGS((char *const *ap));
d81 2
a82 2
int 	evaluate	ARGS((const char *expr, long *rval, int error_ok));
int	v_evaluate	ARGS((struct tbl *vp, const char *expr, volatile int error_ok));
d84 4
a87 4
void	init_histvec	ARGS((void));
void 	hist_init	ARGS((Source *s));
void 	hist_finish	ARGS((void));
void	histsave	ARGS((int lno, const char *cmd, int dowrite));
d89 9
a97 13
int 	c_fc	 	ARGS((register char **wp));
void	sethistsize	ARGS((int n));
void	sethistfile	ARGS((const char *name));
# ifdef EASY_HISTORY
void 	histappend	ARGS((const char *cmd, int nl_separate));
# endif
char **	histpos	 	ARGS((void));
int 	histN	 	ARGS((void));
int 	histnum	 	ARGS((int n));
int	findhist	ARGS((int start, int fwd, const char *str,
			      int anchored));
int	findhistrel	ARGS((const char *str));
char  **hist_get_newest ARGS((int allow_cur));
d101 13
a113 13
void 	errorf		ARGS((const char *fmt, ...))
				GCC_FUNC_ATTR2(noreturn, format(printf, 1, 2));
void 	warningf	ARGS((int fileline, const char *fmt, ...))
				GCC_FUNC_ATTR(format(printf, 2, 3));
void 	bi_errorf	ARGS((const char *fmt, ...))
				GCC_FUNC_ATTR(format(printf, 1, 2));
void 	internal_errorf	ARGS((int jump, const char *fmt, ...))
				GCC_FUNC_ATTR(format(printf, 2, 3));
void	error_prefix	ARGS((int fileline));
void 	shellf		ARGS((const char *fmt, ...))
				GCC_FUNC_ATTR(format(printf, 1, 2));
void 	shprintf	ARGS((const char *fmt, ...))
				GCC_FUNC_ATTR(format(printf, 1, 2));
d115 4
a118 4
void 	kshdebug_init_	ARGS((void));
void 	kshdebug_printf_ ARGS((const char *fmt, ...))
				GCC_FUNC_ATTR(format(printf, 1, 2));
void 	kshdebug_dump_	ARGS((const char *str, const void *mem, int nbytes));
d120 8
a127 8
int	can_seek	ARGS((int fd));
void	initio		ARGS((void));
int	ksh_dup2	ARGS((int ofd, int nfd, int errok));
int 	savefd		ARGS((int fd, int noclose));
void 	restfd		ARGS((int fd, int ofd));
void 	openpipe	ARGS((int *pv));
void 	closepipe	ARGS((int *pv));
int	check_fd	ARGS((char *name, int mode, const char **emsgp));
d129 6
a134 6
void	coproc_init	ARGS((void));
void	coproc_read_close ARGS((int fd));
void	coproc_readw_close ARGS((int fd));
void	coproc_write_close ARGS((int fd));
int	coproc_getfd	ARGS((int mode, const char **emsgp));
void	coproc_cleanup	ARGS((int reuse));
d136 1
a136 1
struct temp *maketemp	ARGS((Area *ap, Temp_type type, struct temp **tlist));
d138 14
a151 14
void 	j_init		ARGS((int mflagset));
void 	j_exit		ARGS((void));
void 	j_change	ARGS((void));
int 	exchild		ARGS((struct op *t, int flags, int close_fd));
void 	startlast	ARGS((void));
int 	waitlast	ARGS((void));
int 	waitfor		ARGS((const char *cp, int *sigp));
int 	j_kill		ARGS((const char *cp, int sig));
int 	j_resume	ARGS((const char *cp, int bg));
int 	j_jobs		ARGS((const char *cp, int slp, int nflag));
int	j_njobs		ARGS((void));
void 	j_notify	ARGS((void));
pid_t	j_async		ARGS((void));
int 	j_stopped_running	ARGS((void));
d153 6
a158 6
int 	yylex		ARGS((int cf));
void 	yyerror		ARGS((const char *fmt, ...))
				GCC_FUNC_ATTR2(noreturn, format(printf, 1, 2));
Source * pushs		ARGS((int type, Area *areap));
void	set_prompt	ARGS((int to, Source *s));
void 	pprompt		ARGS((const char *cp, int ntruncate));
d161 4
a164 4
void 	mcheck		ARGS((void));
void 	mcset		ARGS((long interval));
void 	mbset		ARGS((char *p));
void 	mpset		ARGS((char *mptoparse));
d167 10
a176 11
int 	include		ARGS((const char *name, int argc, char **argv,
			      int intr_ok));
int 	command		ARGS((const char *comm));
int 	shell		ARGS((Source *volatile s, int volatile toplevel));
void 	unwind		ARGS((int i)) GCC_FUNC_ATTR(noreturn);
void 	newenv		ARGS((int type));
void 	quitenv		ARGS((void));
void	cleanup_parents_env ARGS((void));
void	cleanup_proc_env ARGS((void));
void 	aerror		ARGS((Area *ap, const char *msg))
				GCC_FUNC_ATTR(noreturn);
d178 28
a205 28
void 	setctypes	ARGS((const char *s, int t));
void 	initctypes	ARGS((void));
char *	ulton		ARGS((unsigned long n, int base));
char *	str_save	ARGS((const char *s, Area *ap));
char *	str_nsave	ARGS((const char *s, int n, Area *ap));
int	option		ARGS((const char *n));
char *	getoptions	ARGS((void));
void	change_flag	ARGS((enum sh_flag f, int what, int newval));
int	parse_args	ARGS((char **argv, int what, int *setargsp));
int 	getn		ARGS((const char *as, int *ai));
int 	bi_getn		ARGS((const char *as, int *ai));
int 	gmatch		ARGS((const char *s, const char *p, int isfile));
int	has_globbing	ARGS((const char *xp, const char *xpe));
const unsigned char *pat_scan ARGS((const unsigned char *p,
				const unsigned char *pe, int match_sep));
void 	qsortp		ARGS((void **base, size_t n, int (*f)(void *, void *)));
int 	xstrcmp		ARGS((void *p1, void *p2));
void	ksh_getopt_reset ARGS((Getopt *go, int));
int	ksh_getopt	ARGS((char **argv, Getopt *go, const char *options));
void	print_value_quoted ARGS((const char *s));
void	print_columns	ARGS((struct shf *shf, int n,
			      char *(*func)(void *, int, char *, int),
			      void *arg, int max_width, int prefcol));
int	strip_nuls	ARGS((char *buf, int nbytes));
char	*str_zcpy	ARGS((char *dst, const char *src, int dsize));
int	blocking_read	ARGS((int fd, char *buf, int nbytes));
int	reset_nonblock	ARGS((int fd));
char	*ksh_get_wd	ARGS((char *buf, int bsize));
d207 5
a211 5
int	make_path	ARGS((const char *cwd, const char *file,
			      char **pathlist, XString *xsp, int *phys_pathp));
void	simplify_path	ARGS((char *path));
char	*get_phys_path	ARGS((const char *path));
void	set_current_wd	ARGS((char *path));
d213 2
a214 2
void 	initkeywords	ARGS((void));
struct op * compile	ARGS((Source *s));
d216 8
a223 8
unsigned int 	hash	ARGS((const char *n));
void 	tinit		ARGS((struct table *tp, Area *ap, int tsize));
struct tbl *	tsearch	ARGS((struct table *tp, const char *n, unsigned int h));
struct tbl *	tenter	ARGS((struct table *tp, const char *n, unsigned int h));
void 	tdelete		ARGS((struct tbl *p));
void 	twalk		ARGS((struct tstate *ts, struct table *tp));
struct tbl *	tnext	ARGS((struct tstate *ts));
struct tbl **	tsort	ARGS((struct table *tp));
d226 1
a226 1
void	inittraps	ARGS((void));
d228 1
a228 1
void	alarm_init	ARGS((void));
d230 14
a243 14
Trap *	gettrap		ARGS((const char *name, int igncase));
RETSIGTYPE trapsig	ARGS((int i));
void	intrcheck	ARGS((void));
int	fatal_trap_check ARGS((void));
int	trap_pending	ARGS((void));
void 	runtraps	ARGS((int intr));
void 	runtrap		ARGS((Trap *p));
void 	cleartraps	ARGS((void));
void 	restoresigs	ARGS((void));
void	settrap		ARGS((Trap *p, char *s));
int	block_pipe	ARGS((void));
void	restore_pipe	ARGS((int restore_dfl));
int	setsig		ARGS((Trap *p, handler_t f, int flags));
void	setexecsig	ARGS((Trap *p, int restore));
d245 7
a251 7
int 	fptreef		ARGS((struct shf *f, int indent, const char *fmt, ...));
char *	snptreef	ARGS((char *s, int n, const char *fmt, ...));
struct op *	tcopy	ARGS((struct op *t, Area *ap));
char *	wdcopy		ARGS((const char *wp, Area *ap));
char *	wdscan		ARGS((const char *wp, int c));
char *	wdstrip		ARGS((const char *wp));
void 	tfree		ARGS((struct op *t, Area *ap));
d253 22
a274 22
void 	newblock	ARGS((void));
void 	popblock	ARGS((void));
void	initvar		ARGS((void));
struct tbl *	global	ARGS((const char *n));
struct tbl *	local	ARGS((const char *n, bool_t copy));
char *	str_val		ARGS((struct tbl *vp));
long 	intval		ARGS((struct tbl *vp));
int 	setstr		ARGS((struct tbl *vq, const char *s, int error_ok));
struct tbl *setint_v	ARGS((struct tbl *vq, struct tbl *vp));
void 	setint		ARGS((struct tbl *vq, long n));
int	getint		ARGS((struct tbl *vp, long *nump));
struct tbl *	typeset	ARGS((const char *var, Tflag set, Tflag clr, int field, int base));
void 	unset		ARGS((struct tbl *vp, int array_ref));
char  * skip_varname	ARGS((const char *s, int aok));
char	*skip_wdvarname ARGS((const char *s, int aok));
int	is_wdvarname	ARGS((const char *s, int aok));
int	is_wdvarassign	ARGS((const char *s));
char **	makenv		ARGS((void));
void	change_random	ARGS((void));
int	array_ref_len	ARGS((const char *cp));
char *	arrayname	ARGS((const char *str));
void    set_array	ARGS((const char *var, int reset, char **vals));
a276 23


/* Hack to avoid billions of compile warnings on SunOS 4.1.x */
#if defined(MUN) && defined(sun) && !defined(__svr4__)
extern void bcopy ARGS((const void *src, void *dst, size_t size));
extern int fclose ARGS((FILE *fp));
extern int fprintf ARGS((FILE *fp, const char *fmt, ...));
extern int fread ARGS((void *buf, int size, int num, FILE *fp));
extern int ioctl ARGS((int fd, int request, void *arg));
extern int killpg ARGS((int pgrp, int sig));
extern int nice ARGS((int n));
extern int readlink ARGS((const char *path, char *buf, int bufsize));
extern int setpgrp ARGS((int pid, int pgrp));
extern int strcasecmp ARGS((const char *s1, const char *s2));
extern int tolower ARGS((int));
extern int toupper ARGS((int));
/*  Include files aren't included yet */
extern int getrlimit ARGS(( /* int resource, struct rlimit *rpl */ ));
extern int getrusage ARGS(( /* int who, struct rusage *rusage */ ));
extern int gettimeofday ARGS(( /* struct timeval *tv, struct timezone *tz */ ));
extern int setrlimit ARGS(( /* int resource, struct rlimit *rlp */ ));
extern int lstat ARGS(( /* const char *path, struct stat *buf */ ));
#endif
@


1.12
log
@do the variety-pack of bash-style \letter expansions on prompt variables.
a few issues remain with \ and $ and ! because of early variable expansion
done by incorrect eval/substitution, but this change is not responsible
for that.  tested by djm, jmc, and many others
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.11 2003/05/16 19:58:57 jsyn Exp $	*/
d102 3
@


1.11
log
@fix several constant overflows, remove the strerror prototype (shouldn't be
there), and cleanup some whitespace; help from, and okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.10 2003/04/16 23:11:52 tdeval Exp $	*/
d151 1
@


1.10
log
@string cleaning.  ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.9 2001/02/19 09:49:54 camield Exp $	*/
a191 1
char *	strerror	ARGS((int i));
@


1.9
log
@bash-like 'double-tab' completion

- bind TAB (^I) to complete-list by default
- complete-list now lists 'ls style' not 'menu style'
- complete-list first completes; if that does not work, it lists
- fix a memleak in emacs.c, do_complete
- completion now works after '=' (dd), and ':' (ssh) and ` (backtick)
- a command can now start with a subdir from the current dir
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.8 1999/07/14 13:37:24 millert Exp $	*/
d65 1
a65 1
char	*debunk		ARGS((char *dp, const char *sp));
@


1.8
log
@pdksh-5.2.14
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.7 1999/06/15 01:18:35 millert Exp $	*/
d81 1
d204 1
a204 1
			      void *arg, int max_width));
@


1.7
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.6 1999/01/08 20:25:01 millert Exp $	*/
d48 1
@


1.6
log
@bug fixes from pdksh-unstable-5.2.13.5; some of which we already had.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.5 1998/10/29 04:09:21 millert Exp $	*/
d137 1
a137 1
struct temp *maketemp	ARGS((Area *ap));
d162 1
d262 1
a262 1
void 	setstr		ARGS((struct tbl *vq, const char *s));
@


1.5
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.4 1998/06/25 19:02:15 millert Exp $	*/
d115 6
d231 1
a231 1
Trap *	gettrap		ARGS((const char *name));
d272 1
@


1.4
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.3 1996/11/21 07:59:34 downsj Exp $	*/
d93 1
a93 1
void 	histappend	ARGS((const char *cmd, int nl_seperate));
@


1.3
log
@Update to 5.2.12.
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.2 1996/08/19 20:08:57 downsj Exp $	*/
d245 1
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: proto.h,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
d168 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d76 3
a78 2
char *	search		ARGS((const char *name, const char *path, int mode));
int	search_access	ARGS((const char *path, int mode));
d128 2
a129 2
int	get_coproc_fd	ARGS((int mode, const char **emsgp));
void	cleanup_coproc	ARGS((int reuse));
d154 1
d158 1
d221 1
d223 1
d257 1
a257 1
struct tbl *	typeset	ARGS((const char *var, int set, int clr, int field, int base));
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
