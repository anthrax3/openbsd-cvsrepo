head	1.70;
access;
symbols
	OPENBSD_6_1:1.69.0.6
	OPENBSD_6_1_BASE:1.69
	OPENBSD_6_0:1.69.0.2
	OPENBSD_6_0_BASE:1.69
	OPENBSD_5_9:1.67.0.2
	OPENBSD_5_9_BASE:1.67
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.49.0.6
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.49.0.4
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.47.0.2
	OPENBSD_5_4_BASE:1.47
	OPENBSD_5_3:1.46.0.2
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.45.0.6
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.4
	OPENBSD_5_0:1.45.0.2
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.44.0.12
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.44.0.10
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.44.0.6
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.44.0.8
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.4
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.44.0.2
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.43.0.4
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.43.0.2
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.42.0.4
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.42.0.2
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.36.0.2
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.35.0.2
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.18.0.6
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.14.0.10
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.14.0.8
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.14.0.6
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.4
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.70
date	2017.07.04.07.29.32;	author anton;	state Exp;
branches;
next	1.69;
commitid	EAU5Bw3i4umUy47M;

1.69
date	2016.04.27.12.46.23;	author naddy;	state Exp;
branches;
next	1.68;
commitid	EHPtSUUq8Vnp5NOd;

1.68
date	2016.03.04.09.37.23;	author czarkoff;	state Exp;
branches;
next	1.67;
commitid	xxKZ0npZEo4raGLS;

1.67
date	2015.12.30.09.07.00;	author tedu;	state Exp;
branches;
next	1.66;
commitid	WTwPzlskFufQpRQz;

1.66
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.65;
commitid	btTCreDA00YdaFhU;

1.65
date	2015.12.14.06.09.43;	author mmcc;	state Exp;
branches;
next	1.64;
commitid	X7XrxRgHwWl96WEl;

1.64
date	2015.11.18.15.31.21;	author nicm;	state Exp;
branches;
next	1.63;
commitid	SRPQjZjItqJFVKpA;

1.63
date	2015.11.12.04.04.31;	author mmcc;	state Exp;
branches;
next	1.62;
commitid	QvyWaajN4Lc4MRtd;

1.62
date	2015.11.01.15.38.53;	author mmcc;	state Exp;
branches;
next	1.61;
commitid	Fr9nr0FBz2YkAWdK;

1.61
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.60;
commitid	C4W85jmosThChWA2;

1.60
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.59;
commitid	16HUr75moyUNtKR8;

1.59
date	2015.10.10.22.09.23;	author nicm;	state Exp;
branches;
next	1.58;
commitid	3qU7FRcjIbm8XWEE;

1.58
date	2015.10.09.19.49.08;	author millert;	state Exp;
branches;
next	1.57;
commitid	UeirfxfK0LXU7WhG;

1.57
date	2015.10.05.23.32.15;	author nicm;	state Exp;
branches;
next	1.56;
commitid	sFJRHdJrtB2k6s65;

1.56
date	2015.09.30.14.33.41;	author tedu;	state Exp;
branches;
next	1.55;
commitid	Yv0vpfJmiJJOvS1L;

1.55
date	2015.09.22.21.50.40;	author millert;	state Exp;
branches;
next	1.54;
commitid	ZWmS69dzJnkF6rox;

1.54
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.53;
commitid	7fgq4YTZG4xZ0uN0;

1.53
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.52;
commitid	v5QjoxUgKU2iUTFz;

1.52
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.51;
commitid	lBs9un9sXhbdfVrQ;

1.51
date	2015.09.10.22.48.58;	author nicm;	state Exp;
branches;
next	1.50;
commitid	stJ3KRI2o7F5OBtF;

1.50
date	2015.07.30.14.59.12;	author zhuk;	state Exp;
branches;
next	1.49;
commitid	Dr1BockdFWKpUfaF;

1.49
date	2013.12.17.16.37.06;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2013.11.12.04.36.02;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2013.03.03.19.11.34;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2013.01.20.14.47.46;	author stsp;	state Exp;
branches;
next	1.45;

1.45
date	2011.03.09.09.30.39;	author okan;	state Exp;
branches;
next	1.44;

1.44
date	2008.07.03.17.52.08;	author otto;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.02.16.40.59;	author moritz;	state Exp;
branches;
next	1.42;

1.42
date	2006.07.10.17.12.41;	author beck;	state Exp;
branches;
next	1.41;

1.41
date	2006.06.16.20.34.22;	author drahn;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.29.18.22.24;	author otto;	state Exp;
branches;
next	1.39;

1.39
date	2006.04.10.14.38.59;	author jaredy;	state Exp;
branches;
next	1.38;

1.38
date	2005.12.11.20.31.21;	author otto;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.11.18.02.27;	author otto;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.02.21.16.01.58;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2005.01.10.17.52.04;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2004.12.30.21.34.24;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2004.12.30.21.11.40;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2004.12.29.06.59.42;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.22.18.57.28;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.19.04.14.20;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.18.21.04.52;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.12.06.53.13;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.10.21.13.54;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.06.20.36.44;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.06.20.33.00;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.04.19.20.07;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.06.21.08.05;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.16.01.28.54;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.06.15.01.18.34;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.01.19.20.41.55;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.01.10.17.55.03;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.06.25.19.02.06;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.09.12.04.39.32;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.09.01.18.30.08;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.08.05.21.49.55;	author grr;	state Exp;
branches;
next	1.7;

1.7
date	97.06.19.13.58.44;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.06.18.22.42.38;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.11.21.07.59.32;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.10.13.21.32.19;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.10.01.02.05.42;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.55;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.70
log
@Add support for pattern substitution to variables in ksh using a common syntax
borrowed from ksh93.

Survived a ports build performed by naddy@@ and encouraged by many.
@
text
@/*	$OpenBSD: lex.c,v 1.69 2016/04/27 12:46:23 naddy Exp $	*/

/*
 * lexical analysis and source input
 */

#include <ctype.h>
#include <errno.h>
#include <libgen.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "sh.h"

/*
 * states while lexing word
 */
#define	SINVALID	-1	/* invalid state */
#define	SBASE	0		/* outside any lexical constructs */
#define	SWORD	1		/* implicit quoting for substitute() */
#define	SLETPAREN 2		/* inside (( )), implicit quoting */
#define	SSQUOTE	3		/* inside '' */
#define	SDQUOTE	4		/* inside "" */
#define	SBRACE	5		/* inside ${} */
#define	SCSPAREN 6		/* inside $() */
#define	SBQUOTE	7		/* inside `` */
#define	SASPAREN 8		/* inside $(( )) */
#define SHEREDELIM 9		/* parsing <<,<<- delimiter */
#define SHEREDQUOTE 10		/* parsing " in <<,<<- delimiter */
#define SPATTERN 11		/* parsing *(...|...) pattern (*+?@@!) */
#define STBRACE 12		/* parsing ${..[#%]..} */
#define	SBRACEQ	13		/* inside "${}" */

/* Structure to keep track of the lexing state and the various pieces of info
 * needed for each particular state.
 */
typedef struct lex_state Lex_state;
struct lex_state {
	int ls_state;
	union {
		/* $(...) */
		struct scsparen_info {
			int nparen;	/* count open parenthesis */
			int csstate;	/* XXX remove */
#define ls_scsparen ls_info.u_scsparen
		} u_scsparen;

		/* $((...)) */
		struct sasparen_info {
			int nparen;	/* count open parenthesis */
			int start;	/* marks start of $(( in output str */
#define ls_sasparen ls_info.u_sasparen
		} u_sasparen;

		/* ((...)) */
		struct sletparen_info {
			int nparen;	/* count open parenthesis */
#define ls_sletparen ls_info.u_sletparen
		} u_sletparen;

		/* `...` */
		struct sbquote_info {
			int indquotes;	/* true if in double quotes: "`...`" */
#define ls_sbquote ls_info.u_sbquote
		} u_sbquote;

		Lex_state *base;	/* used to point to next state block */
	} ls_info;
};

typedef struct State_info State_info;
struct State_info {
	Lex_state	*base;
	Lex_state	*end;
};


static void	readhere(struct ioword *);
static int	getsc__(void);
static void	getsc_line(Source *);
static int	getsc_bn(void);
static char	*get_brace_var(XString *, char *);
static int	arraysub(char **);
static const char *ungetsc(int);
static void	gethere(void);
static Lex_state *push_state_(State_info *, Lex_state *);
static Lex_state *pop_state_(State_info *, Lex_state *);
static char	*special_prompt_expand(char *);
static int	dopprompt(const char *, int, const char **, int);
int		promptlen(const char *cp, const char **spp);

static int backslash_skip;
static int ignore_backslash_newline;

Source *source;		/* yyparse/yylex source */
YYSTYPE	yylval;		/* result from yylex */
struct ioword *heres[HERES], **herep;
char	ident[IDENT+1];

char  **history;	/* saved commands */
char  **histptr;	/* last history item */
int	histsize;	/* history size */

/* optimized getsc_bn() */
#define getsc()		(*source->str != '\0' && *source->str != '\\' \
			 && !backslash_skip ? *source->str++ : getsc_bn())
/* optimized getsc__() */
#define	getsc_()	((*source->str != '\0') ? *source->str++ : getsc__())

#define STATE_BSIZE	32

#define PUSH_STATE(s)	do { \
			    if (++statep == state_info.end) \
				statep = push_state_(&state_info, statep); \
			    state = statep->ls_state = (s); \
			} while (0)

#define POP_STATE()	do { \
			    if (--statep == state_info.base) \
				statep = pop_state_(&state_info, statep); \
			    state = statep->ls_state; \
			} while (0)



/*
 * Lexical analyzer
 *
 * tokens are not regular expressions, they are LL(1).
 * for example, "${var:-${PWD}}", and "$(size $(whence ksh))".
 * hence the state stack.
 */

int
yylex(int cf)
{
	Lex_state states[STATE_BSIZE], *statep;
	State_info state_info;
	int c, state;
	XString ws;		/* expandable output word */
	char *wp;		/* output word pointer */
	char *sp, *dp;
	int c2;


  Again:
	states[0].ls_state = SINVALID;
	states[0].ls_info.base = NULL;
	statep = &states[1];
	state_info.base = states;
	state_info.end = &states[STATE_BSIZE];

	Xinit(ws, wp, 64, ATEMP);

	backslash_skip = 0;
	ignore_backslash_newline = 0;

	if (cf&ONEWORD)
		state = SWORD;
	else if (cf&LETEXPR) {
		*wp++ = OQUOTE;	 /* enclose arguments in (double) quotes */
		state = SLETPAREN;
		statep->ls_sletparen.nparen = 0;
	} else {		/* normal lexing */
		state = (cf & HEREDELIM) ? SHEREDELIM : SBASE;
		while ((c = getsc()) == ' ' || c == '\t')
			;
		if (c == '#') {
			ignore_backslash_newline++;
			while ((c = getsc()) != '\0' && c != '\n')
				;
			ignore_backslash_newline--;
		}
		ungetsc(c);
	}
	if (source->flags & SF_ALIAS) {	/* trailing ' ' in alias definition */
		source->flags &= ~SF_ALIAS;
		/* In POSIX mode, a trailing space only counts if we are
		 * parsing a simple command
		 */
		if (!Flag(FPOSIX) || (cf & CMDWORD))
			cf |= ALIAS;
	}

	/* Initial state: one of SBASE SHEREDELIM SWORD SASPAREN */
	statep->ls_state = state;

	/* collect non-special or quoted characters to form word */
	while (!((c = getsc()) == 0 ||
	    ((state == SBASE || state == SHEREDELIM) && ctype(c, C_LEX1)))) {
		Xcheck(ws, wp);
		switch (state) {
		case SBASE:
			if (Flag(FCSHHISTORY) && (source->flags & SF_TTY) &&
			    c == '!') {
				char **replace = NULL;
				int get, i;
				char match[200] = { 0 }, *str = match;
				size_t mlen;

				c2 = getsc();
				if (c2 == '\0' || c2 == ' ' || c2 == '\t')
					;
				else if (c2 == '!')
					replace = hist_get_newest(0);
				else if (isdigit(c2) || c2 == '-' ||
				    isalpha(c2)) {
					get = !isalpha(c2);

					*str++ = c2;
					do {
						if ((c2 = getsc()) == '\0')
							break;
						if (c2 == '\t' || c2 == ' ' ||
						    c2 == '\n') {
							ungetsc(c2);
							break;
						}
						*str++ = c2;
					} while (str < &match[sizeof(match)-1]);
					*str = '\0';

					if (get) {
						int h = findhistrel(match);
						if (h >= 0)
							replace = &history[h];
					} else {
						int h = findhist(-1, 0, match, true);
						if (h >= 0)
							replace = &history[h];
					}
				}

				/*
				 * XXX ksh history buffer saves un-expanded
				 * commands. Until the history buffer code is
				 * changed to contain expanded commands, we
				 * ignore the bad commands (spinning sucks)
				 */
				if (replace && **replace == '!')
					ungetsc(c2);
				else if (replace) {
					Source *s;

					/* do not strdup replacement via alloc */
					s = pushs(SREREAD, source->areap);
					s->start = s->str = *replace;
					s->next = source;
					s->u.freeme = NULL;
					source = s;
					continue;
				} else if (*match != '\0') {
					/* restore what followed the '!' */
					mlen = strlen(match);
					for (i = mlen-1; i >= 0; i--)
						ungetsc(match[i]);
				} else
					ungetsc(c2);
			}
			if (c == '[' && (cf & (VARASN|ARRAYVAR))) {
				*wp = EOS; /* temporary */
				if (is_wdvarname(Xstring(ws, wp), false)) {
					char *p, *tmp;

					if (arraysub(&tmp)) {
						*wp++ = CHAR;
						*wp++ = c;
						for (p = tmp; *p; ) {
							Xcheck(ws, wp);
							*wp++ = CHAR;
							*wp++ = *p++;
						}
						afree(tmp, ATEMP);
						break;
					} else {
						Source *s;

						s = pushs(SREREAD,
							  source->areap);
						s->start = s->str
							= s->u.freeme = tmp;
						s->next = source;
						source = s;
					}
				}
				*wp++ = CHAR;
				*wp++ = c;
				break;
			}
			/* FALLTHROUGH */
		  Sbase1:	/* includes *(...|...) pattern (*+?@@!) */
			if (c == '*' || c == '@@' || c == '+' || c == '?' ||
			    c == '!') {
				c2 = getsc();
				if (c2 == '(' /*)*/ ) {
					*wp++ = OPAT;
					*wp++ = c;
					PUSH_STATE(SPATTERN);
					break;
				}
				ungetsc(c2);
			}
			/* FALLTHROUGH */
		  Sbase2:	/* doesn't include *(...|...) pattern (*+?@@!) */
			switch (c) {
			case '\\':
				c = getsc();
				if (c) /* trailing \ is lost */
					*wp++ = QCHAR, *wp++ = c;
				break;
			case '\'':
				if ((cf & HEREDOC) || state == SBRACEQ) {
					*wp++ = CHAR, *wp++ = c;
					break;
				}
				*wp++ = OQUOTE;
				ignore_backslash_newline++;
				PUSH_STATE(SSQUOTE);
				break;
			case '"':
				*wp++ = OQUOTE;
				PUSH_STATE(SDQUOTE);
				break;
			default:
				goto Subst;
			}
			break;

		  Subst:
			switch (c) {
			case '\\':
				c = getsc();
				switch (c) {
				case '\\':
				case '$': case '`':
					*wp++ = QCHAR, *wp++ = c;
					break;
				case '"':
					if ((cf & HEREDOC) == 0) {
						*wp++ = QCHAR, *wp++ = c;
						break;
					}
					/* FALLTHROUGH */
				default:
					if (cf & UNESCAPE) {
						*wp++ = QCHAR, *wp++ = c;
						break;
					}
					Xcheck(ws, wp);
					if (c) { /* trailing \ is lost */
						*wp++ = CHAR, *wp++ = '\\';
						*wp++ = CHAR, *wp++ = c;
					}
					break;
				}
				break;
			case '$':
				c = getsc();
				if (c == '(') /*)*/ {
					c = getsc();
					if (c == '(') /*)*/ {
						PUSH_STATE(SASPAREN);
						statep->ls_sasparen.nparen = 2;
						statep->ls_sasparen.start =
						    Xsavepos(ws, wp);
						*wp++ = EXPRSUB;
					} else {
						ungetsc(c);
						PUSH_STATE(SCSPAREN);
						statep->ls_scsparen.nparen = 1;
						statep->ls_scsparen.csstate = 0;
						*wp++ = COMSUB;
					}
				} else if (c == '{') /*}*/ {
					*wp++ = OSUBST;
					*wp++ = '{'; /*}*/
					wp = get_brace_var(&ws, wp);
					c = getsc();
					/* allow :# and :% (ksh88 compat) */
					if (c == ':') {
						*wp++ = CHAR, *wp++ = c;
						c = getsc();
					}
					/* If this is a trim operation,
					 * treat (,|,) specially in STBRACE.
					 */
					if (c == '#' || c == '%' || c == '/') {
						ungetsc(c);
						PUSH_STATE(STBRACE);
					} else {
						ungetsc(c);
						if (state == SDQUOTE ||
						    state == SBRACEQ)
							PUSH_STATE(SBRACEQ);
						else
							PUSH_STATE(SBRACE);
					}
				} else if (ctype(c, C_ALPHA)) {
					*wp++ = OSUBST;
					*wp++ = 'X';
					do {
						Xcheck(ws, wp);
						*wp++ = c;
						c = getsc();
					} while (ctype(c, C_ALPHA) || digit(c));
					*wp++ = '\0';
					*wp++ = CSUBST;
					*wp++ = 'X';
					ungetsc(c);
				} else if (ctype(c, C_VAR1) || digit(c)) {
					Xcheck(ws, wp);
					*wp++ = OSUBST;
					*wp++ = 'X';
					*wp++ = c;
					*wp++ = '\0';
					*wp++ = CSUBST;
					*wp++ = 'X';
				} else {
					*wp++ = CHAR, *wp++ = '$';
					ungetsc(c);
				}
				break;
			case '`':
				PUSH_STATE(SBQUOTE);
				*wp++ = COMSUB;
				/* Need to know if we are inside double quotes
				 * since sh/at&t-ksh translate the \" to " in
				 * "`..\"..`".
				 */
				statep->ls_sbquote.indquotes = 0;
				Lex_state *s = statep;
				Lex_state *base = state_info.base;
				while (1) {
					for (; s != base; s--) {
						if (s->ls_state == SDQUOTE) {
							statep->ls_sbquote.indquotes = 1;
							break;
						}
					}
					if (s != base)
						break;
					if (!(s = s->ls_info.base))
						break;
					base = s-- - STATE_BSIZE;
				}
				break;
			default:
				*wp++ = CHAR, *wp++ = c;
			}
			break;

		case SSQUOTE:
			if (c == '\'') {
				POP_STATE();
				if (state == SBRACEQ) {
					*wp++ = CHAR, *wp++ = c;
					break;
				}
				*wp++ = CQUOTE;
				ignore_backslash_newline--;
			} else
				*wp++ = QCHAR, *wp++ = c;
			break;

		case SDQUOTE:
			if (c == '"') {
				POP_STATE();
				*wp++ = CQUOTE;
			} else
				goto Subst;
			break;

		case SCSPAREN: /* $( .. ) */
			/* todo: deal with $(...) quoting properly
			 * kludge to partly fake quoting inside $(..): doesn't
			 * really work because nested $(..) or ${..} inside
			 * double quotes aren't dealt with.
			 */
			switch (statep->ls_scsparen.csstate) {
			case 0: /* normal */
				switch (c) {
				case '(':
					statep->ls_scsparen.nparen++;
					break;
				case ')':
					statep->ls_scsparen.nparen--;
					break;
				case '\\':
					statep->ls_scsparen.csstate = 1;
					break;
				case '"':
					statep->ls_scsparen.csstate = 2;
					break;
				case '\'':
					statep->ls_scsparen.csstate = 4;
					ignore_backslash_newline++;
					break;
				}
				break;

			case 1: /* backslash in normal mode */
			case 3: /* backslash in double quotes */
				--statep->ls_scsparen.csstate;
				break;

			case 2: /* double quotes */
				if (c == '"')
					statep->ls_scsparen.csstate = 0;
				else if (c == '\\')
					statep->ls_scsparen.csstate = 3;
				break;

			case 4: /* single quotes */
				if (c == '\'') {
					statep->ls_scsparen.csstate = 0;
					ignore_backslash_newline--;
				}
				break;
			}
			if (statep->ls_scsparen.nparen == 0) {
				POP_STATE();
				*wp++ = 0; /* end of COMSUB */
			} else
				*wp++ = c;
			break;

		case SASPAREN: /* $(( .. )) */
			/* todo: deal with $((...); (...)) properly */
			/* XXX should nest using existing state machine
			 * (embed "..", $(...), etc.) */
			if (c == '(')
				statep->ls_sasparen.nparen++;
			else if (c == ')') {
				statep->ls_sasparen.nparen--;
				if (statep->ls_sasparen.nparen == 1) {
					/*(*/
					if ((c2 = getsc()) == ')') {
						POP_STATE();
						*wp++ = 0; /* end of EXPRSUB */
						break;
					} else {
						char *s;

						ungetsc(c2);
						/* mismatched parenthesis -
						 * assume we were really
						 * parsing a $(..) expression
						 */
						s = Xrestpos(ws, wp,
						    statep->ls_sasparen.start);
						memmove(s + 1, s, wp - s);
						*s++ = COMSUB;
						*s = '('; /*)*/
						wp++;
						statep->ls_scsparen.nparen = 1;
						statep->ls_scsparen.csstate = 0;
						state = statep->ls_state =
						    SCSPAREN;
					}
				}
			}
			*wp++ = c;
			break;

		case SBRACEQ:
			/*{*/
			if (c == '}') {
				POP_STATE();
				*wp++ = CSUBST;
				*wp++ = /*{*/ '}';
			} else
				goto Sbase2;
			break;

		case SBRACE:
			/*{*/
			if (c == '}') {
				POP_STATE();
				*wp++ = CSUBST;
				*wp++ = /*{*/ '}';
			} else
				goto Sbase1;
			break;

		case STBRACE:
			/* Same as SBRACE, except (,|,) treated specially */
			/*{*/
			if (c == '}') {
				POP_STATE();
				*wp++ = CSUBST;
				*wp++ = /*{*/ '}';
			} else if (c == '|') {
				*wp++ = SPAT;
			} else if (c == '(') {
				*wp++ = OPAT;
				*wp++ = ' ';	/* simile for @@ */
				PUSH_STATE(SPATTERN);
			} else
				goto Sbase1;
			break;

		case SBQUOTE:
			if (c == '`') {
				*wp++ = 0;
				POP_STATE();
			} else if (c == '\\') {
				switch (c = getsc()) {
				case '\\':
				case '$': case '`':
					*wp++ = c;
					break;
				case '"':
					if (statep->ls_sbquote.indquotes) {
						*wp++ = c;
						break;
					}
					/* FALLTHROUGH */
				default:
					if (c) { /* trailing \ is lost */
						*wp++ = '\\';
						*wp++ = c;
					}
					break;
				}
			} else
				*wp++ = c;
			break;

		case SWORD:	/* ONEWORD */
			goto Subst;

		case SLETPAREN:	/* LETEXPR: (( ... )) */
			/*(*/
			if (c == ')') {
				if (statep->ls_sletparen.nparen > 0)
				    --statep->ls_sletparen.nparen;
				/*(*/
				else if ((c2 = getsc()) == ')') {
					c = 0;
					*wp++ = CQUOTE;
					goto Done;
				} else
					ungetsc(c2);
			} else if (c == '(')
				/* parenthesis inside quotes and backslashes
				 * are lost, but at&t ksh doesn't count them
				 * either
				 */
				++statep->ls_sletparen.nparen;
			goto Sbase2;

		case SHEREDELIM:	/* <<,<<- delimiter */
			/* XXX chuck this state (and the next) - use
			 * the existing states ($ and \`..` should be
			 * stripped of their specialness after the
			 * fact).
			 */
			/* here delimiters need a special case since
			 * $ and `..` are not to be treated specially
			 */
			if (c == '\\') {
				c = getsc();
				if (c) { /* trailing \ is lost */
					*wp++ = QCHAR;
					*wp++ = c;
				}
			} else if (c == '\'') {
				PUSH_STATE(SSQUOTE);
				*wp++ = OQUOTE;
				ignore_backslash_newline++;
			} else if (c == '"') {
				state = statep->ls_state = SHEREDQUOTE;
				*wp++ = OQUOTE;
			} else {
				*wp++ = CHAR;
				*wp++ = c;
			}
			break;

		case SHEREDQUOTE:	/* " in <<,<<- delimiter */
			if (c == '"') {
				*wp++ = CQUOTE;
				state = statep->ls_state = SHEREDELIM;
			} else {
				if (c == '\\') {
					switch (c = getsc()) {
					case '\\': case '"':
					case '$': case '`':
						break;
					default:
						if (c) { /* trailing \ lost */
							*wp++ = CHAR;
							*wp++ = '\\';
						}
						break;
					}
				}
				*wp++ = CHAR;
				*wp++ = c;
			}
			break;

		case SPATTERN:	/* in *(...|...) pattern (*+?@@!) */
			if ( /*(*/ c == ')') {
				*wp++ = CPAT;
				POP_STATE();
			} else if (c == '|') {
				*wp++ = SPAT;
			} else if (c == '(') {
				*wp++ = OPAT;
				*wp++ = ' ';	/* simile for @@ */
				PUSH_STATE(SPATTERN);
			} else
				goto Sbase1;
			break;
		}
	}
Done:
	Xcheck(ws, wp);
	if (statep != &states[1])
		/* XXX figure out what is missing */
		yyerror("no closing quote\n");

	/* This done to avoid tests for SHEREDELIM wherever SBASE tested */
	if (state == SHEREDELIM)
		state = SBASE;

	dp = Xstring(ws, wp);
	if ((c == '<' || c == '>') && state == SBASE &&
	    ((c2 = Xlength(ws, wp)) == 0 ||
	    (c2 == 2 && dp[0] == CHAR && digit(dp[1])))) {
		struct ioword *iop = alloc(sizeof(*iop), ATEMP);

		if (c2 == 2)
			iop->unit = dp[1] - '0';
		else
			iop->unit = c == '>'; /* 0 for <, 1 for > */

		c2 = getsc();
		/* <<, >>, <> are ok, >< is not */
		if (c == c2 || (c == '<' && c2 == '>')) {
			iop->flag = c == c2 ?
			    (c == '>' ? IOCAT : IOHERE) : IORDWR;
			if (iop->flag == IOHERE) {
				if ((c2 = getsc()) == '-')
					iop->flag |= IOSKIP;
				else
					ungetsc(c2);
			}
		} else if (c2 == '&')
			iop->flag = IODUP | (c == '<' ? IORDUP : 0);
		else {
			iop->flag = c == '>' ? IOWRITE : IOREAD;
			if (c == '>' && c2 == '|')
				iop->flag |= IOCLOB;
			else
				ungetsc(c2);
		}

		iop->name = NULL;
		iop->delim = NULL;
		iop->heredoc = NULL;
		Xfree(ws, wp);	/* free word */
		yylval.iop = iop;
		return REDIR;
	}

	if (wp == dp && state == SBASE) {
		Xfree(ws, wp);	/* free word */
		/* no word, process LEX1 character */
		switch (c) {
		default:
			return c;

		case '|':
		case '&':
		case ';':
			if ((c2 = getsc()) == c)
				c = (c == ';') ? BREAK :
				    (c == '|') ? LOGOR :
				    (c == '&') ? LOGAND :
				    YYERRCODE;
			else if (c == '|' && c2 == '&')
				c = COPROC;
			else
				ungetsc(c2);
			return c;

		case '\n':
			gethere();
			if (cf & CONTIN)
				goto Again;
			return c;

		case '(':  /*)*/
			if (!Flag(FSH)) {
				if ((c2 = getsc()) == '(') /*)*/
					/* XXX need to handle ((...); (...)) */
					c = MDPAREN;
				else
					ungetsc(c2);
			}
			return c;
		  /*(*/
		case ')':
			return c;
		}
	}

	*wp++ = EOS;		/* terminate word */
	yylval.cp = Xclose(ws, wp);
	if (state == SWORD || state == SLETPAREN)	/* ONEWORD? */
		return LWORD;
	ungetsc(c);		/* unget terminator */

	/* copy word to unprefixed string ident */
	for (sp = yylval.cp, dp = ident; dp < ident+IDENT && (c = *sp++) == CHAR; )
		*dp++ = *sp++;
	/* Make sure the ident array stays '\0' padded */
	memset(dp, 0, (ident+IDENT) - dp + 1);
	if (c != EOS)
		*ident = '\0';	/* word is not unquoted */

	if (*ident != '\0' && (cf&(KEYWORD|ALIAS))) {
		struct tbl *p;
		int h = hash(ident);

		/* { */
		if ((cf & KEYWORD) && (p = ktsearch(&keywords, ident, h)) &&
		    (!(cf & ESACONLY) || p->val.i == ESAC || p->val.i == '}')) {
			afree(yylval.cp, ATEMP);
			return p->val.i;
		}
		if ((cf & ALIAS) && (p = ktsearch(&aliases, ident, h)) &&
		    (p->flag & ISSET)) {
			Source *s;

			for (s = source; s->type == SALIAS; s = s->next)
				if (s->u.tblp == p)
					return LWORD;
			/* push alias expansion */
			s = pushs(SALIAS, source->areap);
			s->start = s->str = p->val.s;
			s->u.tblp = p;
			s->next = source;
			source = s;
			afree(yylval.cp, ATEMP);
			goto Again;
		}
	}

	return LWORD;
}

static void
gethere(void)
{
	struct ioword **p;

	for (p = heres; p < herep; p++)
		readhere(*p);
	herep = heres;
}

/*
 * read "<<word" text into temp file
 */

static void
readhere(struct ioword *iop)
{
	int c;
	char *volatile eof;
	char *eofp;
	int skiptabs;
	XString xs;
	char *xp;
	int xpos;

	eof = evalstr(iop->delim, 0);

	if (!(iop->flag & IOEVAL))
		ignore_backslash_newline++;

	Xinit(xs, xp, 256, ATEMP);

	for (;;) {
		eofp = eof;
		skiptabs = iop->flag & IOSKIP;
		xpos = Xsavepos(xs, xp);
		while ((c = getsc()) != 0) {
			if (skiptabs) {
				if (c == '\t')
					continue;
				skiptabs = 0;
			}
			if (c != *eofp)
				break;
			Xcheck(xs, xp);
			Xput(xs, xp, c);
			eofp++;
		}
		/* Allow EOF here so commands with out trailing newlines
		 * will work (eg, ksh -c '...', $(...), etc).
		 */
		if (*eofp == '\0' && (c == 0 || c == '\n')) {
			xp = Xrestpos(xs, xp, xpos);
			break;
		}
		ungetsc(c);
		while ((c = getsc()) != '\n') {
			if (c == 0)
				yyerror("here document `%s' unclosed\n", eof);
			Xcheck(xs, xp);
			Xput(xs, xp, c);
		}
		Xcheck(xs, xp);
		Xput(xs, xp, c);
	}
	Xput(xs, xp, '\0');
	iop->heredoc = Xclose(xs, xp);

	if (!(iop->flag & IOEVAL))
		ignore_backslash_newline--;
}

void
yyerror(const char *fmt, ...)
{
	va_list va;

	/* pop aliases and re-reads */
	while (source->type == SALIAS || source->type == SREREAD)
		source = source->next;
	source->str = null;	/* zap pending input */

	error_prefix(true);
	va_start(va, fmt);
	shf_vfprintf(shl_out, fmt, va);
	va_end(va);
	errorf(NULL);
}

/*
 * input for yylex with alias expansion
 */

Source *
pushs(int type, Area *areap)
{
	Source *s;

	s = alloc(sizeof(Source), areap);
	s->type = type;
	s->str = null;
	s->start = NULL;
	s->line = 0;
	s->cmd_offset = 0;
	s->errline = 0;
	s->file = NULL;
	s->flags = 0;
	s->next = NULL;
	s->areap = areap;
	if (type == SFILE || type == SSTDIN) {
		char *dummy;
		Xinit(s->xs, dummy, 256, s->areap);
	} else
		memset(&s->xs, 0, sizeof(s->xs));
	return s;
}

static int
getsc__(void)
{
	Source *s = source;
	int c;

	while ((c = *s->str++) == 0) {
		s->str = NULL;		/* return 0 for EOF by default */
		switch (s->type) {
		case SEOF:
			s->str = null;
			return 0;

		case SSTDIN:
		case SFILE:
			getsc_line(s);
			break;

		case SWSTR:
			break;

		case SSTRING:
			break;

		case SWORDS:
			s->start = s->str = *s->u.strv++;
			s->type = SWORDSEP;
			break;

		case SWORDSEP:
			if (*s->u.strv == NULL) {
				s->start = s->str = "\n";
				s->type = SEOF;
			} else {
				s->start = s->str = " ";
				s->type = SWORDS;
			}
			break;

		case SALIAS:
			if (s->flags & SF_ALIASEND) {
				/* pass on an unused SF_ALIAS flag */
				source = s->next;
				source->flags |= s->flags & SF_ALIAS;
				s = source;
			} else if (*s->u.tblp->val.s &&
			    isspace((unsigned char)strchr(s->u.tblp->val.s, 0)[-1])) {
				source = s = s->next;	/* pop source stack */
				/* Note that this alias ended with a space,
				 * enabling alias expansion on the following
				 * word.
				 */
				s->flags |= SF_ALIAS;
			} else {
				/* At this point, we need to keep the current
				 * alias in the source list so recursive
				 * aliases can be detected and we also need
				 * to return the next character.  Do this
				 * by temporarily popping the alias to get
				 * the next character and then put it back
				 * in the source list with the SF_ALIASEND
				 * flag set.
				 */
				source = s->next;	/* pop source stack */
				source->flags |= s->flags & SF_ALIAS;
				c = getsc__();
				if (c) {
					s->flags |= SF_ALIASEND;
					s->ugbuf[0] = c; s->ugbuf[1] = '\0';
					s->start = s->str = s->ugbuf;
					s->next = source;
					source = s;
				} else {
					s = source;
					/* avoid reading eof twice */
					s->str = NULL;
					break;
				}
			}
			continue;

		case SREREAD:
			if (s->start != s->ugbuf) /* yuck */
				afree(s->u.freeme, ATEMP);
			source = s = s->next;
			continue;
		}
		if (s->str == NULL) {
			s->type = SEOF;
			s->start = s->str = null;
			return '\0';
		}
		if (s->flags & SF_ECHO) {
			shf_puts(s->str, shl_out);
			shf_flush(shl_out);
		}
	}
	return c;
}

static void
getsc_line(Source *s)
{
	char *xp = Xstring(s->xs, xp);
	int interactive = Flag(FTALKING) && s->type == SSTDIN;
	int have_tty = interactive && (s->flags & SF_TTY);

	/* Done here to ensure nothing odd happens when a timeout occurs */
	XcheckN(s->xs, xp, LINE);
	*xp = '\0';
	s->start = s->str = xp;

	if (have_tty && ksh_tmout) {
		ksh_tmout_state = TMOUT_READING;
		alarm(ksh_tmout);
	}
#ifdef EDIT
	if (have_tty && (0
# ifdef VI
	    || Flag(FVI)
# endif /* VI */
# ifdef EMACS
	    || Flag(FEMACS) || Flag(FGMACS)
# endif /* EMACS */
	    )) {
		int nread;

		nread = x_read(xp, LINE);
		if (nread < 0)	/* read error */
			nread = 0;
		xp[nread] = '\0';
		xp += nread;
	}
	else
#endif /* EDIT */
	{
		if (interactive) {
			pprompt(prompt, 0);
		} else
			s->line++;

		while (1) {
			char *p = shf_getse(xp, Xnleft(s->xs, xp), s->u.shf);

			if (!p && shf_error(s->u.shf) &&
			    s->u.shf->errno_ == EINTR) {
				shf_clearerr(s->u.shf);
				if (trap)
					runtraps(0);
				continue;
			}
			if (!p || (xp = p, xp[-1] == '\n'))
				break;
			/* double buffer size */
			xp++; /* move past null so doubling works... */
			XcheckN(s->xs, xp, Xlength(s->xs, xp));
			xp--; /* ...and move back again */
		}
		/* flush any unwanted input so other programs/builtins
		 * can read it.  Not very optimal, but less error prone
		 * than flushing else where, dealing with redirections,
		 * etc..
		 * todo: reduce size of shf buffer (~128?) if SSTDIN
		 */
		if (s->type == SSTDIN)
			shf_flush(s->u.shf);
	}
	/* XXX: temporary kludge to restore source after a
	 * trap may have been executed.
	 */
	source = s;
	if (have_tty && ksh_tmout) {
		ksh_tmout_state = TMOUT_EXECUTING;
		alarm(0);
	}
	s->start = s->str = Xstring(s->xs, xp);
	strip_nuls(Xstring(s->xs, xp), Xlength(s->xs, xp));
	/* Note: if input is all nulls, this is not eof */
	if (Xlength(s->xs, xp) == 0) { /* EOF */
		if (s->type == SFILE)
			shf_fdclose(s->u.shf);
		s->str = NULL;
	} else if (interactive) {
#ifdef HISTORY
		char *p = Xstring(s->xs, xp);
		if (cur_prompt == PS1)
			while (*p && ctype(*p, C_IFS) && ctype(*p, C_IFSWS))
				p++;
		if (*p) {
			s->line++;
			histsave(s->line, s->str, 1);
		}
#endif /* HISTORY */
	}
	if (interactive)
		set_prompt(PS2, NULL);
}

static char *
special_prompt_expand(char *str)
{
	char *p = str;

	while ((p = strstr(p, "\\$")) != NULL) {
		*(p+1) = 'p';
	}
	return str;
}

void
set_prompt(int to, Source *s)
{
	char *ps1;
	Area *saved_atemp;

	cur_prompt = to;

	switch (to) {
	case PS1: /* command */
		ps1 = str_save(str_val(global("PS1")), ATEMP);
		saved_atemp = ATEMP;	/* ps1 is freed by substitute() */
		newenv(E_ERRH);
		if (sigsetjmp(genv->jbuf, 0)) {
			prompt = safe_prompt;
			/* Don't print an error - assume it has already
			 * been printed.  Reason is we may have forked
			 * to run a command and the child may be
			 * unwinding its stack through this code as it
			 * exits.
			 */
		} else {
			/* expand \$ before other substitutions are done */
			char *tmp = special_prompt_expand(ps1);
			prompt = str_save(substitute(tmp, 0), saved_atemp);
		}
		quitenv(NULL);
		break;
	case PS2: /* command continuation */
		prompt = str_val(global("PS2"));
		break;
	}
}

static int
dopprompt(const char *sp, int ntruncate, const char **spp, int doprint)
{
	char strbuf[1024], tmpbuf[1024], *p, *str, nbuf[32], delimiter = '\0';
	int len, c, n, totlen = 0, indelimit = 0, counting = 1, delimitthis;
	const char *cp = sp;
	struct tm *tm;
	time_t t;

	if (*cp && cp[1] == '\r') {
		delimiter = *cp;
		cp += 2;
	}

	while (*cp != 0) {
		delimitthis = 0;
		if (indelimit && *cp != delimiter)
			;
		else if (*cp == '\n' || *cp == '\r') {
			totlen = 0;
			sp = cp + 1;
		} else if (*cp == '\t') {
			if (counting)
				totlen = (totlen | 7) + 1;
		} else if (*cp == delimiter) {
			indelimit = !indelimit;
			delimitthis = 1;
		}

		if (*cp == '\\') {
			cp++;
			if (!*cp)
				break;
			if (Flag(FSH))
				snprintf(strbuf, sizeof strbuf, "\\%c", *cp);
			else switch (*cp) {
			case 'a':	/* '\' 'a' bell */
				strbuf[0] = '\007';
				strbuf[1] = '\0';
				break;
			case 'd':	/* '\' 'd' Dow Mon DD */
				time(&t);
				tm = localtime(&t);
				strftime(strbuf, sizeof strbuf, "%a %b %d", tm);
				break;
			case 'D': /* '\' 'D' '{' strftime format '}' */
				p = strchr(cp + 2, '}');
				if (cp[1] != '{' || p == NULL) {
					snprintf(strbuf, sizeof strbuf,
					    "\\%c", *cp);
					break;
				}
				strlcpy(tmpbuf, cp + 2, sizeof tmpbuf);
				p = strchr(tmpbuf, '}');
				if (p)
					*p = '\0';
				time(&t);
				tm = localtime(&t);
				strftime(strbuf, sizeof strbuf, tmpbuf, tm);
				cp = strchr(cp + 2, '}');
				break;
			case 'e':	/* '\' 'e' escape */
				strbuf[0] = '\033';
				strbuf[1] = '\0';
				break;
			case 'h':	/* '\' 'h' shortened hostname */
				gethostname(strbuf, sizeof strbuf);
				p = strchr(strbuf, '.');
				if (p)
					*p = '\0';
				break;
			case 'H':	/* '\' 'H' full hostname */
				gethostname(strbuf, sizeof strbuf);
				break;
			case 'j':	/* '\' 'j' number of jobs */
				snprintf(strbuf, sizeof strbuf, "%d",
				    j_njobs());
				break;
			case 'l':	/* '\' 'l' basename of tty */
				p = ttyname(0);
				if (p)
					p = basename(p);
				if (p)
					strlcpy(strbuf, p, sizeof strbuf);
				break;
			case 'n':	/* '\' 'n' newline */
				strbuf[0] = '\n';
				strbuf[1] = '\0';
				totlen = 0;	/* reset for prompt re-print */
				sp = cp + 1;
				break;
			case 'p':	/* '\' '$' $ or # */
				strbuf[0] = ksheuid ? '$' : '#';
				strbuf[1] = '\0';
				break;
			case 'r':	/* '\' 'r' return */
				strbuf[0] = '\r';
				strbuf[1] = '\0';
				totlen = 0;	/* reset for prompt re-print */
				sp = cp + 1;
				break;
			case 's':	/* '\' 's' basename $0 */
				strlcpy(strbuf, kshname, sizeof strbuf);
				break;
			case 't':	/* '\' 't' 24 hour HH:MM:SS */
				time(&t);
				tm = localtime(&t);
				strftime(strbuf, sizeof strbuf, "%T", tm);
				break;
			case 'T':	/* '\' 'T' 12 hour HH:MM:SS */
				time(&t);
				tm = localtime(&t);
				strftime(strbuf, sizeof strbuf, "%l:%M:%S", tm);
				break;
			case '@@':	/* '\' '@@' 12 hour am/pm format */
				time(&t);
				tm = localtime(&t);
				strftime(strbuf, sizeof strbuf, "%r", tm);
				break;
			case 'A':	/* '\' 'A' 24 hour HH:MM */
				time(&t);
				tm = localtime(&t);
				strftime(strbuf, sizeof strbuf, "%R", tm);
				break;
			case 'u':	/* '\' 'u' username */
				strlcpy(strbuf, username, sizeof strbuf);
				break;
			case 'v':	/* '\' 'v' version (short) */
				p = strchr(ksh_version, ' ');
				if (p)
					p = strchr(p + 1, ' ');
				if (p) {
					p++;
					strlcpy(strbuf, p, sizeof strbuf);
					p = strchr(strbuf, ' ');
					if (p)
						*p = '\0';
				}
				break;
			case 'V':	/* '\' 'V' version (long) */
				strlcpy(strbuf, ksh_version, sizeof strbuf);
				break;
			case 'w':	/* '\' 'w' cwd */
				p = str_val(global("PWD"));
				n = strlen(str_val(global("HOME")));
				if (strcmp(p, "/") == 0) {
					strlcpy(strbuf, p, sizeof strbuf);
				} else if (strcmp(p, str_val(global("HOME"))) == 0) {
					strbuf[0] = '~';
					strbuf[1] = '\0';
				} else if (strncmp(p, str_val(global("HOME")), n)
				    == 0 && p[n] == '/') {
					snprintf(strbuf, sizeof strbuf, "~/%s",
					    str_val(global("PWD")) + n + 1);
				} else
					strlcpy(strbuf, p, sizeof strbuf);
				break;
			case 'W':	/* '\' 'W' basename(cwd) */
				p = str_val(global("PWD"));
				if (strcmp(p, str_val(global("HOME"))) == 0) {
					strbuf[0] = '~';
					strbuf[1] = '\0';
				} else
					strlcpy(strbuf, basename(p), sizeof strbuf);
				break;
			case '!':	/* '\' '!' history line number */
				snprintf(strbuf, sizeof strbuf, "%d",
				    source->line + 1);
				break;
			case '#':	/* '\' '#' command line number */
				snprintf(strbuf, sizeof strbuf, "%d",
				    source->line - source->cmd_offset + 1);
				break;
			case '0':	/* '\' '#' '#' ' #' octal numeric handling */
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
				if ((cp[1] > '7' || cp[1] < '0') ||
				    (cp[2] > '7' || cp[2] < '0')) {
					snprintf(strbuf, sizeof strbuf,
					    "\\%c", *cp);
					break;
				}
				n = (cp[0] - '0') * 8 * 8 + (cp[1] - '0') * 8 +
				    (cp[2] - '0');
				snprintf(strbuf, sizeof strbuf, "%c", n);
				cp += 2;
				break;
			case '\\':	/* '\' '\' */
				strbuf[0] = '\\';
				strbuf[1] = '\0';
				break;
			case '[': /* '\' '[' .... stop counting */
				strbuf[0] = '\0';
				counting = 0;
				break;
			case ']': /* '\' ']' restart counting */
				strbuf[0] = '\0';
				counting = 1;
				break;

			default:
				snprintf(strbuf, sizeof strbuf, "\\%c", *cp);
				break;
			}
			cp++;

			str = strbuf;
			len = strlen(str);
			if (ntruncate) {
				if (ntruncate >= len) {
					ntruncate -= len;
					continue;
				}
				str += ntruncate;
				len -= ntruncate;
				ntruncate = 0;
			}
			if (doprint)
				shf_write(str, len, shl_out);
			if (counting && !indelimit && !delimitthis)
				totlen += len;
			continue;
		} else if (*cp != '!')
			c = *cp++;
		else if (*++cp == '!')
			c = *cp++;
		else {
			char *p;

			shf_snprintf(p = nbuf, sizeof(nbuf), "%d",
			    source->line + 1);
			len = strlen(nbuf);
			if (ntruncate) {
				if (ntruncate >= len) {
					ntruncate -= len;
					continue;
				}
				p += ntruncate;
				len -= ntruncate;
				ntruncate = 0;
			}
			if (doprint)
				shf_write(p, len, shl_out);
			if (counting && !indelimit && !delimitthis)
				totlen += len;
			continue;
		}
		if (counting && ntruncate)
			--ntruncate;
		else if (doprint) {
			shf_putc(c, shl_out);
		}
		if (counting && !indelimit && !delimitthis)
			totlen++;
	}
	if (doprint)
		shf_flush(shl_out);
	if (spp)
		*spp = sp;
	return (totlen);
}

void
pprompt(const char *cp, int ntruncate)
{
	dopprompt(cp, ntruncate, NULL, 1);
}

int
promptlen(const char *cp, const char **spp)
{
	return dopprompt(cp, 0, spp, 0);
}

/* Read the variable part of a ${...} expression (ie, up to but not including
 * the :[-+?=#%] or close-brace.
 */
static char *
get_brace_var(XString *wsp, char *wp)
{
	enum parse_state {
			   PS_INITIAL, PS_SAW_HASH, PS_IDENT,
			   PS_NUMBER, PS_VAR1, PS_END
			 }
		state;
	char c;

	state = PS_INITIAL;
	while (1) {
		c = getsc();
		/* State machine to figure out where the variable part ends. */
		switch (state) {
		case PS_INITIAL:
			if (c == '#') {
				state = PS_SAW_HASH;
				break;
			}
			/* FALLTHROUGH */
		case PS_SAW_HASH:
			if (letter(c))
				state = PS_IDENT;
			else if (digit(c))
				state = PS_NUMBER;
			else if (ctype(c, C_VAR1))
				state = PS_VAR1;
			else
				state = PS_END;
			break;
		case PS_IDENT:
			if (!letnum(c)) {
				state = PS_END;
				if (c == '[') {
					char *tmp, *p;

					if (!arraysub(&tmp))
						yyerror("missing ]\n");
					*wp++ = c;
					for (p = tmp; *p; ) {
						Xcheck(*wsp, wp);
						*wp++ = *p++;
					}
					afree(tmp, ATEMP);
					c = getsc(); /* the ] */
				}
			}
			break;
		case PS_NUMBER:
			if (!digit(c))
				state = PS_END;
			break;
		case PS_VAR1:
			state = PS_END;
			break;
		case PS_END: /* keep gcc happy */
			break;
		}
		if (state == PS_END) {
			*wp++ = '\0';	/* end of variable part */
			ungetsc(c);
			break;
		}
		Xcheck(*wsp, wp);
		*wp++ = c;
	}
	return wp;
}

/*
 * Save an array subscript - returns true if matching bracket found, false
 * if eof or newline was found.
 * (Returned string double null terminated)
 */
static int
arraysub(char **strp)
{
	XString ws;
	char	*wp;
	char	c;
	int	depth = 1;	/* we are just past the initial [ */

	Xinit(ws, wp, 32, ATEMP);

	do {
		c = getsc();
		Xcheck(ws, wp);
		*wp++ = c;
		if (c == '[')
			depth++;
		else if (c == ']')
			depth--;
	} while (depth > 0 && c && c != '\n');

	*wp++ = '\0';
	*strp = Xclose(ws, wp);

	return depth == 0 ? 1 : 0;
}

/* Unget a char: handles case when we are already at the start of the buffer */
static const char *
ungetsc(int c)
{
	if (backslash_skip)
		backslash_skip--;
	/* Don't unget eof... */
	if (source->str == null && c == '\0')
		return source->str;
	if (source->str > source->start)
		source->str--;
	else {
		Source *s;

		s = pushs(SREREAD, source->areap);
		s->ugbuf[0] = c; s->ugbuf[1] = '\0';
		s->start = s->str = s->ugbuf;
		s->next = source;
		source = s;
	}
	return source->str;
}


/* Called to get a char that isn't a \newline sequence. */
static int
getsc_bn(void)
{
	int c, c2;

	if (ignore_backslash_newline)
		return getsc_();

	if (backslash_skip == 1) {
		backslash_skip = 2;
		return getsc_();
	}

	backslash_skip = 0;

	while (1) {
		c = getsc_();
		if (c == '\\') {
			if ((c2 = getsc_()) == '\n')
				/* ignore the \newline; get the next char... */
				continue;
			ungetsc(c2);
			backslash_skip = 1;
		}
		return c;
	}
}

static Lex_state *
push_state_(State_info *si, Lex_state *old_end)
{
	Lex_state *new = areallocarray(NULL, STATE_BSIZE,
	    sizeof(Lex_state), ATEMP);

	new[0].ls_info.base = old_end;
	si->base = &new[0];
	si->end = &new[STATE_BSIZE];
	return &new[1];
}

static Lex_state *
pop_state_(State_info *si, Lex_state *old_end)
{
	Lex_state *old_base = si->base;

	si->base = old_end->ls_info.base - STATE_BSIZE;
	si->end = old_end->ls_info.base;

	afree(old_base, ATEMP);

	return si->base + STATE_BSIZE - 1;
}
@


1.69
log
@Do not handle echo "`echo \"hi\"`" in POSIX mode differently than in
traditional mode.  This aligns ksh's behavior with bash and FreeBSD sh.
The interpretation of the POSIX text is disputed, but it is unlikely
that a change from the traditional behavior was intended.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.68 2016/03/04 09:37:23 czarkoff Exp $	*/
d388 1
a388 1
					if (c == '#' || c == '%') {
@


1.68
log
@don't parse (...|...) patterns in variable substitution inside double quotes

fixes posix compatibility issue

OK millert@@, nicm@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.67 2015/12/30 09:07:00 tedu Exp $	*/
a429 16
				 * This is not done in posix mode (section
				 * 3.2.3, Double Quotes: "The backquote shall
				 * retain its special meaning introducing the
				 * other form of command substitution (see
				 * 3.6.3). The portion of the quoted string
				 * from the initial backquote and the
				 * characters up to the next backquote that
				 * is not preceded by a backslash (having
				 * escape characters removed) defines that
				 * command whose output replaces `...` when
				 * the word is expanded."
				 * Section 3.6.3, Command Substitution:
				 * "Within the backquoted style of command
				 * substitution, backslash shall retain its
				 * literal meaning, except when followed by
				 * $ ` \.").
d432 7
a438 9
				if (!Flag(FPOSIX)) {
					Lex_state *s = statep;
					Lex_state *base = state_info.base;
					while (1) {
						for (; s != base; s--) {
							if (s->ls_state == SDQUOTE) {
								statep->ls_sbquote.indquotes = 1;
								break;
							}
a439 5
						if (s != base)
							break;
						if (!(s = s->ls_info.base))
							break;
						base = s-- - STATE_BSIZE;
d441 5
@


1.67
log
@rename global "e" to genv to avoid accidental shadowing and aliasing.
ok millert nicm tb
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.66 2015/12/14 13:59:42 tb Exp $	*/
d585 9
@


1.66
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.65 2015/12/14 06:09:43 mmcc Exp $	*/
d1204 1
a1204 1
		if (sigsetjmp(e->jbuf, 0)) {
@


1.65
log
@Remove a superfluous macro. No binary change. ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.64 2015/11/18 15:31:21 nicm Exp $	*/
d8 1
d10 1
d12 1
@


1.64
log
@Only unget match[] if it has been used, ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.63 2015/11/12 04:04:31 mmcc Exp $	*/
d1124 1
a1124 1
			    shf_errno(s->u.shf) == EINTR) {
@


1.63
log
@Use isdigit() instead of ksh's homebrewed alternative.

ok nicm@@. Also discussed with millert@@ and guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.62 2015/11/01 15:38:53 mmcc Exp $	*/
d196 1
a196 1
				char match[200], *str = match;
d250 1
a250 1
				} else {
d255 2
a256 1
				}
@


1.62
log
@Add uses of areallocarray(). mksh and Bitrig ksh already have similar
functions. With help from Theo Buehler.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.61 2015/10/19 14:42:16 mmcc Exp $	*/
d402 1
a402 1
					} while (ctype(c, C_ALPHA|C_DIGIT));
d407 1
a407 1
				} else if (ctype(c, C_DIGIT|C_VAR1)) {
@


1.61
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.60 2015/10/19 02:15:45 mmcc Exp $	*/
d1660 2
a1661 1
	Lex_state	*new = alloc(sizeof(Lex_state) * STATE_BSIZE, ATEMP);
@


1.60
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.59 2015/10/10 22:09:23 nicm Exp $	*/
d9 1
@


1.59
log
@Add a define for the invalid state, from mksh via Michael McConville.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.58 2015/10/09 19:49:08 millert Exp $	*/
d7 1
a7 1
#include "sh.h"
a8 1
#include <ctype.h>
d10 1
@


1.58
log
@Lexer states are not needed outside of lex.c.
From mksh via Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.57 2015/10/05 23:32:15 nicm Exp $	*/
d15 1
d144 1
a144 1
	states[0].ls_state = -1;
@


1.57
log
@Remove EXTERN from lex.h and put the definitions in lex.c, from Michael
McConville.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.56 2015/09/30 14:33:41 tedu Exp $	*/
d11 18
@


1.56
log
@fix error message for csh-history. the lexer needs to back up more.
from Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.55 2015/09/22 21:50:40 millert Exp $	*/
d72 9
@


1.55
log
@Make errorf() and bi_errorf() handle a NULL argument.
From Michael McConville; OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.54 2015/09/18 07:28:24 nicm Exp $	*/
d166 3
d177 1
a177 2
					int get = !isalpha(c2);
					char match[200], *str = match;
d221 6
a226 2
				} else
					ungetsc(c2);
@


1.54
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.53 2015/09/17 14:21:33 nicm Exp $	*/
d912 1
a912 1
	errorf(null);
@


1.53
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.52 2015/09/15 18:15:05 tedu Exp $	*/
d1138 1
a1138 1
		set_prompt(PS2, (Source *) 0);
@


1.52
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.51 2015/09/10 22:48:58 nicm Exp $	*/
d703 1
a703 1
		struct ioword *iop = (struct ioword *) alloc(sizeof(*iop), ATEMP);
d924 1
a924 1
	s = (Source *) alloc(sizeof(Source), areap);
@


1.51
log
@Replace newline and space defines by "\n" and " " directly, from Michael
McConville. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.50 2015/07/30 14:59:12 zhuk Exp $	*/
d731 3
a733 3
		iop->name = (char *) 0;
		iop->delim = (char *) 0;
		iop->heredoc = (char *) 0;
@


1.50
log
@Fix the baskslash-escaped codes ('\nnn') usage in PS1.

Report and initial proposal from Vadim Ushakov on bugs@@, tweaked by me.

okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.49 2013/12/17 16:37:06 deraadt Exp $	*/
d974 1
a974 1
				s->start = s->str = newline;
d977 1
a977 1
				s->start = s->str = space;
@


1.49
log
@ctype cleanups.  Repeated re-audits of this sensitive area by okan and
myself, with a variety of other people spending some time as well.
Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.48 2013/11/12 04:36:02 deraadt Exp $	*/
d1373 2
a1374 1
				n = cp[0] * 8 * 8 + cp[1] * 8 + cp[2];
@


1.48
log
@add a variety of missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.47 2013/03/03 19:11:34 guenther Exp $	*/
d989 1
a989 1
			    isspace(strchr(s->u.tblp->val.s, 0)[-1])) {
@


1.47
log
@Fix quoting in word part of ${var+word} (and similar) when entire thing
is quoted or in a here-doc.

Patch from Alexander Polakov (plhk (at) sdf.org).
ok mpi@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.46 2013/01/20 14:47:46 stsp Exp $	*/
d68 1
@


1.46
log
@Fix backslash escaping during filename tab-completion in ksh.
Diff originally submitted by Alexander Polakov, with a small tweak from me
to avoid breaking tab-completion of environment variables (problem pointed
out by bentley).
ok sthen halex mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.45 2011/03/09 09:30:39 okan Exp $	*/
d116 1
a116 1
	states[0].ls_info.base = (Lex_state *) 0;
d273 4
d353 5
a357 1
						PUSH_STATE(SBRACE);
d434 4
d544 1
@


1.45
log
@substitute '~' for $HOME in the \W prompt case; matches bash's behavior.

feedback from Dan Harnett

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.44 2008/07/03 17:52:08 otto Exp $	*/
d302 4
@


1.44
log
@fix inifinite loop with set -o csh-history and !<space> as input.
report and testing by david@@; ok millert@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.43 2007/06/02 16:40:59 moritz Exp $	*/
d1327 5
a1331 1
				strlcpy(strbuf, basename(p), sizeof strbuf);
@


1.43
log
@s/FALLTROUGH/FALLTHROUGH/
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.42 2006/07/10 17:12:41 beck Exp $	*/
d167 1
a167 1
				if (c2 == '\0')
a168 2
				else if (c2 == ' ' || c2 == '\t')
					ungetsc(c2);
@


1.42
log
@fix ksh prompt wrapping, from Marcus Glocker <marcus@@nazgul.ch>.
tested by me and naddy, and others...
ok naddy@@ and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.41 2006/06/16 20:34:22 drahn Exp $	*/
d302 1
a302 1
					/* FALLTROUGH */
@


1.41
log
@Work around a problem with \$ expansion where \$\$ turned into pid ($$)
expansion. otto and I cannot think of anything better.  ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.40 2006/05/29 18:22:24 otto Exp $	*/
d1417 1
a1417 1
		if (ntruncate)
@


1.40
log
@Implement \$ and \# expansion for PS1. Whoever thought it a clever
idea to assign a special meaning to "\$" -- two chars that are already
(very) special -- deserves a spanking.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.39 2006/04/10 14:38:59 jaredy Exp $	*/
d1131 1
a1131 2
		memmove(p, p + 1, strlen(p));
		*p = ksheuid ? '$' : '#';
d1260 4
@


1.39
log
@fix lint comments, no functional changes; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.38 2005/12/11 20:31:21 otto Exp $	*/
d66 1
d913 1
d1125 12
d1158 5
a1162 3
		} else
			prompt = str_save(substitute(ps1, 0),
			    saved_atemp);
d1328 1
a1328 1
			case '!':	/* '\' '!' history line number XXX busted */
d1332 1
a1332 1
			case '#':	/* '\' '#' command line number XXX busted */
d1334 1
a1334 5
				    source->line + 1);
				break;
			case '$':	/* '\' '$' $ or # XXX busted */
				strbuf[0] = ksheuid ? '$' : '#';
				strbuf[1] = '\0';
@


1.38
log
@fix a few name clashes with libc; found by lint. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.37 2005/09/11 18:02:27 otto Exp $	*/
d252 1
a252 1
			/* fall through.. */
d265 1
a265 1
			/* fall through.. */
d571 1
a571 1
					/* fall through.. */
d1452 1
a1452 1
			/* fall through.. */
@


1.37
log
@Fix " handling in here documents. POSIX says they are not special, so
cat << EOF
\"
EOF
should print \"
Fixes PR 4472; testing jmc@@ and Adam Montague. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.36 2005/03/30 17:16:37 deraadt Exp $	*/
d783 1
a783 1
		if ((cf & KEYWORD) && (p = tsearch(&keywords, ident, h)) &&
d788 1
a788 1
		if ((cf & ALIAS) && (p = tsearch(&aliases, ident, h)) &&
@


1.36
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.35 2005/02/21 16:01:58 otto Exp $	*/
d292 1
a292 1
				case '"': case '\\':
d296 6
@


1.35
log
@Set \u in prompt expansion to the right value, while avoiding getpw* calls,
which might be very inconvenient when the yp server is not available.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.34 2005/01/10 17:52:04 millert Exp $	*/
d19 4
a22 4
	    /* $(...) */
	    struct scsparen_info {
		    int nparen;		/* count open parenthesis */
		    int csstate; /* XXX remove */
d24 1
a24 1
	    } u_scsparen;
d26 4
a29 4
	    /* $((...)) */
	    struct sasparen_info {
		    int nparen;		/* count open parenthesis */
		    int start;		/* marks start of $(( in output str */
d31 1
a31 1
	    } u_sasparen;
d33 3
a35 3
	    /* ((...)) */
	    struct sletparen_info {
		    int nparen;		/* count open parenthesis */
d37 1
a37 1
	    } u_sletparen;
d39 3
a41 3
	    /* `...` */
	    struct sbquote_info {
		    int indquotes;	/* true if in double quotes: "`...`" */
d43 1
a43 1
	    } u_sbquote;
d45 1
a45 1
	    Lex_state *base;		/* used to point to next state block */
d156 2
a157 4
	while (!((c = getsc()) == 0
		 || ((state == SBASE || state == SHEREDELIM)
		     && ctype(c, C_LEX1))))
	{
d160 3
a162 2
		  case SBASE:
			if (Flag(FCSHHISTORY) && (source->flags & SF_TTY) && c == '!') {
d213 1
a213 2
					s = pushs(SREREAD,
					      source->areap);
d224 1
a224 2
				if (is_wdvarname(Xstring(ws, wp), false))
				{
d254 2
a255 3
			if (c == '*' || c == '@@' || c == '+' || c == '?'
			    || c == '!')
			{
d268 1
a268 1
			  case '\\':
d273 1
a273 1
			  case '\'':
d278 1
a278 1
			  case '"':
d282 1
a282 1
			  default:
d289 1
a289 1
			  case '\\':
d292 2
a293 2
				  case '"': case '\\':
				  case '$': case '`':
d296 1
a296 1
				  default:
d305 1
a305 1
			  case '$':
d313 1
a313 1
							Xsavepos(ws, wp);
d367 1
a367 1
			  case '`':
d409 1
a409 1
			  default:
d414 1
a414 1
		  case SSQUOTE:
d423 1
a423 1
		  case SDQUOTE:
d431 1
a431 1
		  case SCSPAREN: /* $( .. ) */
d438 1
a438 1
			  case 0: /* normal */
d440 1
a440 1
				  case '(':
d443 1
a443 1
				  case ')':
d446 1
a446 1
				  case '\\':
d449 1
a449 1
				  case '"':
d452 1
a452 1
				  case '\'':
d459 2
a460 2
			  case 1: /* backslash in normal mode */
			  case 3: /* backslash in double quotes */
d464 1
a464 1
			  case 2: /* double quotes */
d471 1
a471 1
			  case 4: /* single quotes */
d485 1
a485 1
		  case SASPAREN: /* $(( .. )) */
d488 1
a488 1
			 *     (embed "..", $(...), etc.) */
d508 1
a508 1
						     statep->ls_sasparen.start);
d515 2
a516 2
						state = statep->ls_state
							= SCSPAREN;
d523 1
a523 1
		  case SBRACE:
d533 1
a533 1
		  case STBRACE:
d550 1
a550 1
		  case SBQUOTE:
d556 2
a557 2
				  case '\\':
				  case '$': case '`':
d560 1
a560 1
				  case '"':
d566 1
a566 1
				  default:
d577 1
a577 1
		  case SWORD:	/* ONEWORD */
d580 1
a580 1
		  case SLETPAREN:	/* LETEXPR: (( ... )) */
d600 1
a600 1
		  case SHEREDELIM:	/* <<,<<- delimiter */
d628 1
a628 1
		  case SHEREDQUOTE:	/* " in <<,<<- delimiter */
d635 2
a636 2
					  case '\\': case '"':
					  case '$': case '`':
d638 1
a638 1
					  default:
d651 1
a651 1
		  case SPATTERN:	/* in *(...|...) pattern (*+?@@!) */
d677 4
a680 6
	if ((c == '<' || c == '>') && state == SBASE
	    && ((c2 = Xlength(ws, wp)) == 0
	        || (c2 == 2 && dp[0] == CHAR && digit(dp[1]))))
	{
		struct ioword *iop =
				(struct ioword *) alloc(sizeof(*iop), ATEMP);
d691 1
a691 1
				  (c == '>' ? IOCAT : IOHERE) : IORDWR;
d720 1
a720 1
		  default:
d723 3
a725 3
		  case '|':
		  case '&':
		  case ';':
d737 1
a737 1
		  case '\n':
d743 1
a743 1
		  case '(':  /*)*/
d753 1
a753 1
		  case ')':
d777 2
a778 3
		if ((cf & KEYWORD) && (p = tsearch(&keywords, ident, h))
		    && (!(cf & ESACONLY) || p->val.i == ESAC || p->val.i == '}'))
		{
d782 2
a783 3
		if ((cf & ALIAS) && (p = tsearch(&aliases, ident, h))
		    && (p->flag & ISSET))
		{
d928 1
a928 1
		  case SEOF:
d932 2
a933 2
		  case SSTDIN:
		  case SFILE:
d937 1
a937 1
		  case SWSTR:
d940 1
a940 1
		  case SSTRING:
d943 1
a943 1
		  case SWORDS:
d948 1
a948 1
		  case SWORDSEP:
d958 1
a958 1
		  case SALIAS:
d964 2
a965 3
			} else if (*s->u.tblp->val.s
				 && isspace(strchr(s->u.tblp->val.s, 0)[-1]))
			{
d1000 1
a1000 1
		  case SREREAD:
d1038 1
a1038 1
			 || Flag(FVI)
d1041 1
a1041 1
			 || Flag(FEMACS) || Flag(FGMACS)
d1043 1
a1043 2
		))
	{
d1063 2
a1064 3
			if (!p && shf_error(s->u.shf)
			    && shf_errno(s->u.shf) == EINTR)
			{
d1140 1
a1140 1
					 saved_atemp);
d1441 1
a1441 1
		  case PS_INITIAL:
d1447 1
a1447 1
		  case PS_SAW_HASH:
d1457 1
a1457 1
		  case PS_IDENT:
d1475 1
a1475 1
		  case PS_NUMBER:
d1479 1
a1479 1
		  case PS_VAR1:
d1482 1
a1482 1
		  case PS_END: /* keep gcc happy */
@


1.34
log
@In csh-style history expansion, initialize s->u.freeme to NULL so we
don't try to free garbage on cleanup.  Fixes problem noticed by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.33 2004/12/30 21:34:24 otto Exp $	*/
d1281 1
a1281 5
				p = getlogin();
				if (p)
					strlcpy(strbuf, p, sizeof strbuf);
				else
					strbuf[0] = '\0';
@


1.33
log
@Remove -Wno-unused form CFLAGS and kill some unused vars found as a result of
that. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.32 2004/12/30 21:11:40 millert Exp $	*/
d218 1
@


1.32
log
@Simplify local copying of PS1 environment variable.  Since we no
longer call shf_fprintf() we don't need to jump through hoops using
shf_sopen/shf_sclose and can simply use str_save.
OK otto@@ and tested by several ksh users
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.31 2004/12/29 06:59:42 deraadt Exp $	*/
d1164 1
a1164 2
	const char *cp = sp, *ccp;
	extern INT32 njobs;
@


1.31
log
@in prompt variable parsing, if either \n or \r (the two character
sequences) are detected reset the "pointer to first character in
last line of prompt" and "length of last line of prompt" variables,
just like how it done for \n (the literal character).  this fixes
cursor movement for prompts with those sequences embedded within
ok jmc pval
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.30 2004/12/22 18:57:28 otto Exp $	*/
d1130 1
a1130 2
	struct shf *shf;
	char * volatile ps1;
d1137 2
a1138 7
		ps1 = str_val(global("PS1"));
		shf = shf_sopen((char *) 0, strlen(ps1) * 2,
			SHF_WR | SHF_DYNAMIC, (struct shf *) 0);
		while (*ps1)
			shf_putchar(*ps1++, shf);
		ps1 = shf_sclose(shf);
		saved_atemp = ATEMP;
@


1.30
log
@Fix a use-after-free, that causs core dumps if a shell is killed
running with strict malloc.conf options. Problem spotted by hshoexer@@;
fix by me with some help from millert@@.

ok millert@@ hshoexer@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.29 2004/12/22 17:14:34 millert Exp $	*/
d1254 2
d1260 2
@


1.29
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.28 2004/12/20 11:34:26 otto Exp $	*/
d1157 1
a1157 1
		quitenv();
@


1.28
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.27 2004/12/19 04:14:20 deraadt Exp $	*/
d196 1
a196 1
						int h = findhist(-1, 0, match, TRUE);
d225 1
a225 1
				if (is_wdvarname(Xstring(ws, wp), FALSE))
d892 1
a892 1
	error_prefix(TRUE);
@


1.27
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.26 2004/12/18 21:25:44 millert Exp $	*/
d56 1
a56 1
static void	readhere(struct ioword *iop);
d58 1
a58 1
static void	getsc_line(Source *s);
d60 3
a62 3
static char	*get_brace_var(XString *wsp, char *wp);
static int	arraysub(char **strp);
static const char *ungetsc(int c);
d64 3
a66 2
static Lex_state *push_state_(State_info *si, Lex_state *old_end);
static Lex_state *pop_state_(State_info *si, Lex_state *old_end);
d102 1
a102 2
yylex(cf)
	int cf;
d811 1
a811 1
gethere()
d825 1
a825 2
readhere(iop)
	struct ioword *iop;
d904 1
a904 3
pushs(type, areap)
	int type;
	Area *areap;
d927 1
a927 1
getsc__()
d1028 1
a1028 2
getsc_line(s)
	Source *s;
d1128 1
a1128 3
set_prompt(to, s)
	int to;
	Source *s;
d1166 1
a1166 5
dopprompt(sp, ntruncate, spp, doprint)
	const char *sp;
	int ntruncate;
	const char **spp;
	int doprint;
d1429 1
a1429 3
pprompt(cp, ntruncate)
	const char *cp;
	int ntruncate;
d1435 1
a1435 3
promptlen(cp, spp)
    const char  *cp;
    const char **spp;
d1444 1
a1444 3
get_brace_var(wsp, wp)
	XString *wsp;
	char *wp;
d1519 1
a1519 2
arraysub(strp)
	char **strp;
d1546 1
a1546 2
ungetsc(c)
	int c;
d1598 1
a1598 3
push_state_(si, old_end)
	State_info *si;
	Lex_state *old_end;
d1609 1
a1609 3
pop_state_(si, old_end)
	State_info *si;
	Lex_state *old_end;
@


1.26
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.25 2004/12/18 21:04:52 millert Exp $	*/
d129 1
a129 1
		state = SLETPAREN;	
a519 1
						
d1216 1
a1216 1
			case 'd':	/* '\' 'd' Dow Mon DD */ 
d1541 1
a1541 1
	int 	depth = 1;	/* we are just past the initial [ */
@


1.25
log
@Get rid of #ifdef KSH since we don't care about building a V7 style sh and
the #ifdef KSH code is required to make a POSIX sh.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.24 2004/12/18 20:55:52 millert Exp $	*/
d106 1
a106 1
	register int c, state;
d108 1
a108 1
	register char *wp;	/* output word pointer */
d792 1
a792 1
			register Source *s;
d814 1
a814 1
	register struct ioword **p;
d829 1
a829 1
	register int c;
d910 1
a910 1
	register Source *s;
d933 2
a934 2
	register Source *s = source;
	register int c;
@


1.24
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.23 2004/12/12 06:53:13 deraadt Exp $	*/
a126 1
#ifdef KSH
d131 1
a131 3
	}
#endif /* KSH */
	else {		/* normal lexing */
a255 1
#ifdef KSH
a267 1
#endif /* KSH */
a583 1
#ifdef KSH
a602 1
#endif /* KSH */
a736 1
#ifdef KSH
a738 1
#endif /* KSH */
a749 1
#ifdef KSH
a756 1
#endif /* KSH */
d766 1
a766 5
	if (state == SWORD
#ifdef KSH
		|| state == SLETPAREN
#endif /* KSH */
		)	/* ONEWORD? */
a1043 1
#ifdef KSH
a1047 1
#endif /* KSH */
d1105 1
a1105 3
#ifdef KSH
	if (have_tty && ksh_tmout)
	{
a1108 1
#endif /* KSH */
d1137 4
d1145 20
a1164 30
#ifdef KSH
		{
			struct shf *shf;
			char * volatile ps1;
			Area *saved_atemp;

			ps1 = str_val(global("PS1"));
			shf = shf_sopen((char *) 0, strlen(ps1) * 2,
				SHF_WR | SHF_DYNAMIC, (struct shf *) 0);
			while (*ps1)
				shf_putchar(*ps1++, shf);
			ps1 = shf_sclose(shf);
			saved_atemp = ATEMP;
			newenv(E_ERRH);
			if (sigsetjmp(e->jbuf, 0)) {
				prompt = safe_prompt;
				/* Don't print an error - assume it has already
				 * been printed.  Reason is we may have forked
				 * to run a command and the child may be
				 * unwinding its stack through this code as it
				 * exits.
				 */
			} else
				prompt = str_save(substitute(ps1, 0),
						 saved_atemp);
			quitenv();
		}
#else /* KSH */
		prompt = str_val(global("PS1"));
#endif /* KSH */
a1165 1

@


1.23
log
@csh-style ! history completion, which can be activated by using
	set -o csh-history (off by default)
this is not feature complete, and likely never will be.  no ^
and ! has some oddities ... ksh's internal history stuff has got
some very odd behaviours that are rather nasty
ok various developers
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.22 2004/11/10 21:13:54 deraadt Exp $	*/
d56 10
a65 10
static void	readhere ARGS((struct ioword *iop));
static int	getsc__ ARGS((void));
static void	getsc_line ARGS((Source *s));
static int	getsc_bn ARGS((void));
static char	*get_brace_var ARGS((XString *wsp, char *wp));
static int	arraysub ARGS((char **strp));
static const char *ungetsc ARGS((int c));
static void	gethere ARGS((void));
static Lex_state *push_state_ ARGS((State_info *si, Lex_state *old_end));
static Lex_state *pop_state_ ARGS((State_info *si, Lex_state *old_end));
a277 6
#ifdef OS2
				if (isalnum(c)) {
					*wp++ = CHAR, *wp++ = '\\';
					*wp++ = CHAR, *wp++ = c;
				} else
#endif
a899 1
#ifdef HAVE_PROTOTYPES
a900 5
#else
yyerror(fmt, va_alist)
	const char *fmt;
	va_dcl
#endif
d910 1
a910 1
	SH_VA_START(va, fmt);
d1143 2
a1144 9
# ifdef EASY_HISTORY
			if (cur_prompt == PS2)
				histappend(Xstring(s->xs, xp), 1);
			else
# endif /* EASY_HISTORY */
			{
				s->line++;
				histsave(s->line, s->str, 1);
			}
d1175 1
a1175 1
			if (ksh_sigsetjmp(e->jbuf, 0)) {
d1616 1
a1616 1
getsc_bn ARGS((void))
@


1.22
log
@defer ! and !! handling till prompt printing, like real ksh, and this now
means even less fallout from the prompt expansion changes; ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.21 2004/11/06 20:36:44 deraadt Exp $	*/
d166 60
@


1.21
log
@\[ and \] delimit blocks of characters which are processed just like
regular things, except that character counting is turned off temporarily.
character counting is needed so that the shell can handle editing beyond
end-of-line and such
as well, ksh hack: prompts prefixed with [delimitchar]\r means that any blocks
between later matching [delimitchar] toggle counting on and off
semantics corrected based on input from naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.19 2004/11/04 19:20:07 deraadt Exp $	*/
a1120 5
		/* Substitute ! and !! here, before substitutions are done
		 * so ! in expanded variables are not expanded.
		 * NOTE: this is not what at&t ksh does (it does it after
		 * substitutions, POSIX doesn't say which is to be done.
		 */
d1129 2
a1130 7
			while (*ps1) {
				if (*ps1 != '!' || *++ps1 == '!')
					shf_putchar(*ps1++, shf);
				else
					shf_fprintf(shf, "%d",
						s ? s->line + 1 : 0);
			}
@


1.20
log
@change \w to output ~/subpath type things, except for root of course
naddy ok
@
text
@d1176 1
a1176 1
	int len, c, n, totlen = 0, indelimit = 0;
d1188 1
d1194 4
a1197 3
		} else if (*cp == '\t')
			totlen = (totlen | 7) + 1;
		else if (*cp == delimiter)
d1199 2
d1364 7
a1370 17
			case '[': /* '\' '[' text '\' ']' */
				ccp = ++cp;
				while (ccp[0] != '\\' && ccp[1] != ']') {
					if (ccp[0] == '\0')
						break;
					ccp++;
				}
				if (ccp[0] == '\0') {
					snprintf(strbuf, sizeof strbuf,
					    "\\%c", *cp);
					break;
				}
				n = ccp - cp;
				strlcpy(strbuf, cp, sizeof strbuf);
				if (n < sizeof strbuf)
					strbuf[n] = '\0';
				cp = ccp + 1;
d1392 2
a1393 1
			totlen += len;
d1416 2
a1417 1
			totlen += len;
d1425 2
a1426 1
		totlen++;
@


1.19
log
@do the variety-pack of bash-style \letter expansions on prompt variables.
a few issues remain with \ and $ and ! because of early variable expansion
done by incorrect eval/substitution, but this change is not responsible
for that.  tested by djm, jmc, and many others
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.18 2003/08/06 21:08:05 millert Exp $	*/
d1309 4
a1312 1
				if (strcmp(p, str_val(global("HOME"))) == 0) {
d1315 4
@


1.18
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.17 2003/02/28 09:45:09 jmc Exp $	*/
d8 1
d1168 3
a1170 4
/* See also related routine, promptlen() in edit.c */
void
pprompt(cp, ntruncate)
	const char *cp;
d1172 2
d1175 11
a1185 3
#if 0
	char nbuf[32];
	int c;
d1188 206
a1393 1
		if (*cp != '!')
a1397 1
			int len;
d1401 1
a1401 1
				source->line + 1);
d1412 3
a1414 1
			shf_write(p, len, shl_out);
d1419 1
a1419 1
		else
d1421 2
d1424 21
a1444 3
#endif /* 0 */
	shf_puts(cp + ntruncate, shl_out);
	shf_flush(shl_out);
@


1.17
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.16 2002/06/09 05:47:27 todd Exp $	*/
d1397 1
a1397 1
	return si->base + STATE_BSIZE - 1;;
@


1.16
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.15 2002/01/16 01:28:54 millert Exp $	*/
d733 1
a733 1
	/* Make sure the ident array stays '\0' paded */
@


1.15
log
@Use the volatile specifier to fix warnings about variables being
clobbered by longjmp / vfork instead of the gcc "(void)&foo;" hack.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.14 1999/06/15 01:18:34 millert Exp $	*/
d221 1
a221 1
				} else 
@


1.14
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.13 1999/01/19 20:41:55 millert Exp $	*/
d1127 1
a1127 1
			char *ps1;
d1129 1
a1129 3
#ifdef __GNUC__
			(void)&ps1;
#endif
@


1.13
log
@Updates from pdksh-unstable-5.2.13.7.  Most notable change is:
    trap: exit traps now executed in subshells (without explicit exit call).
See the Changelog for a full list of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.12 1999/01/10 17:55:03 millert Exp $	*/
d668 1
d787 1
a787 1
	register struct ioword *iop;
a788 2
	struct shf *volatile shf;
	struct temp *h;
d793 3
a795 1
	int i;
a798 22
	if (e->flags & EF_FUNC_PARSE) {
		h = maketemp(APERM);
		h->next = func_heredocs;
		func_heredocs = h;
	} else {
		h = maketemp(ATEMP);
		h->next = e->temps;
		e->temps = h;
	}
	iop->name = h->name;
	if (!(shf = h->shf))
		yyerror("cannot create temporary file %s - %s\n",
			h->name, strerror(errno));

	newenv(E_ERRH);
	i = ksh_sigsetjmp(e->jbuf, 0);
	if (i) {
		quitenv();
		shf_close(shf);
		unwind(i);
	}

d802 2
d807 1
d816 2
d823 2
a824 1
		if (*eofp == '\0' && (c == 0 || c == '\n'))
d826 1
a827 1
		shf_write(eof, eofp - eof, shf);
d831 2
a832 1
			shf_putc(c, shf);
d834 2
a835 1
		shf_putc(c, shf);
d837 3
a839 7
	shf_flush(shf);
	if (shf_error(shf))
		yyerror("error saving here document `%s': %s\n",
			eof, strerror(shf_errno(shf)));
	/*XXX add similar checks for write errors everywhere */
	quitenv();
	shf_close(shf);
@


1.12
log
@sync with pdksh-unstable-5.2.13.6
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.11 1998/06/25 19:02:06 millert Exp $	*/
a1055 3
#ifdef OS2
			setmode (0, O_TEXT);
#endif /* OS2 */
a1076 3
#ifdef OS2
		setmode(0, O_BINARY);
#endif /* OS2 */
@


1.11
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.10 1997/09/12 04:39:32 millert Exp $	*/
d650 1
a650 1
			if (iop->flag == IOHERE)
d655 1
@


1.10
log
@Avoid longjmp/vfork clobbering.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.9 1997/09/01 18:30:08 deraadt Exp $	*/
d10 45
d58 1
a61 1
static int	getsc_bn ARGS((void));
d63 2
d75 15
d103 2
a105 1
	char states [64], *statep = states; /* XXX overflow check */
d108 2
a109 7
	register char *sp, *dp;
	char UNINITIALIZED(*ddparen_start);
	int istate;
	int UNINITIALIZED(c2);
	int UNINITIALIZED(nparen), UNINITIALIZED(csstate);
	int UNINITIALIZED(ndparen);
	int UNINITIALIZED(indquotes);
d113 6
d125 1
a125 1
		istate = SWORD;
d129 2
a130 2
		istate = SDPAREN;
		ndparen = 0;
d134 1
a134 1
		istate = (cf & HEREDELIM) ? SHEREDELIM : SBASE;
d154 3
d158 3
a160 3
	for (*statep = state = istate;
	     !((c = getsc()) == 0 || ((state == SBASE || state == SHEREDELIM)
				      && ctype(c, C_LEX1))); )
d206 1
a206 1
					*++statep = state = SPATTERN;
a226 1
				*++statep = state = SSQUOTE;
d229 1
a231 1
				*++statep = state = SDQUOTE;
d233 1
d263 4
a266 3
						*++statep = state = SDDPAREN;
						nparen = 2;
						ddparen_start = wp;
d270 3
a272 3
						*++statep = state = SPAREN;
						nparen = 1;
						csstate = 0;
d277 1
d279 6
d286 1
a286 2
					 * wrap @@(...) around the pattern
					 * (allows easy handling of ${a#b|c})
a287 1
					c = getsc();
d289 2
a290 7
						*wp++ = CHAR, *wp++ = c;
						if ((c2 = getsc()) == c)
							*wp++ = CHAR, *wp++ = c;
						else
							ungetsc(c2);
						*wp++ = OPAT, *wp++ = '@@';
						*++statep = state = STBRACE;
d293 1
a293 1
						*++statep = state = SBRACE;
d297 1
d305 1
d310 1
d314 1
d321 1
a321 1
				*++statep = state = SBQUOTE;
d326 16
d343 18
a360 5
				indquotes = 0;
				if (!Flag(FPOSIX))
					for (sp = statep; sp > states; --sp)
						if (*sp == SDQUOTE)
							indquotes = 1;
d369 1
a369 1
				state = *--statep;
d378 1
a378 1
				state = *--statep;
d384 1
a384 1
		  case SPAREN: /* $( .. ) */
d390 1
a390 1
			switch (csstate) {
d394 1
a394 1
					nparen++;
d397 1
a397 1
					nparen--;
d400 1
a400 1
					csstate = 1;
d403 1
a403 1
					csstate = 2;
d406 1
a406 1
					csstate = 4;
d414 1
a414 1
				--csstate;
d419 1
a419 1
					csstate = 0;
d421 1
a421 1
					csstate = 3;
d426 1
a426 1
					csstate = 0;
d431 2
a432 2
			if (nparen == 0) {
				state = *--statep;
d438 1
a438 1
		  case SDDPAREN: /* $(( .. )) */
d443 1
a443 1
				nparen++;
d445 2
a446 2
				nparen--;
				if (nparen == 1) {
d449 1
a449 1
						state = *--statep;
d453 2
d460 5
a464 5
						memmove(ddparen_start + 1,
							ddparen_start,
							wp - ddparen_start);
						*ddparen_start++ = COMSUB;
						*ddparen_start = '('; /*)*/
d466 5
a470 2
						csstate = 0;
						*statep = state = SPAREN;
d480 1
a480 1
				state = *--statep;
d482 1
d488 1
a488 3
			/* same as SBRACE, except | is saved as SPAT and
			 * CPAT is added at the end.
			 */
d491 1
a491 2
				state = *--statep;
				*wp++ = CPAT;
d493 1
d496 4
d507 1
a507 1
				state = *--statep;
d515 1
a515 1
					if (indquotes) {
d535 1
a535 1
		  case SDPAREN:	/* LETEXPR: (( ... )) */
d538 2
a539 2
				if (ndparen > 0)
				    --ndparen;
d552 1
a552 1
				++ndparen;
d572 1
a572 1
				*++statep = state = SSQUOTE;
d576 1
a576 1
				state = SHEREDQUOTE;
d587 1
a587 1
				state = SHEREDELIM;
d610 2
a611 2
				state = *--statep;
			} else if (c == '|')
d613 5
a617 1
			else
d624 2
a625 1
	if (state != istate)
d632 38
a669 7
	if ((c == '<' || c == '>') && state == SBASE) {
		char *cp = Xstring(ws, wp);
		if (Xlength(ws, wp) == 2 && cp[0] == CHAR && digit(cp[1])) {
			wp = cp; /* throw away word */
			c2/*unit*/ = cp[1] - '0';
		} else
			c2/*unit*/ = c == '>'; /* 0 for <, 1 for > */
d672 1
a672 1
	if (wp == Xstring(ws, wp) && state == SBASE) {
a694 32
		  case '>':
		  case '<': {
			register struct ioword *iop;

			iop = (struct ioword *) alloc(sizeof(*iop), ATEMP);
			iop->unit = c2/*unit*/;

			c2 = getsc();
			/* <<, >>, <> are ok, >< is not */
			if (c == c2 || (c == '<' && c2 == '>')) {
				iop->flag = c == c2 ?
					  (c == '>' ? IOCAT : IOHERE) : IORDWR;
				if (iop->flag == IOHERE)
					if ((c2 = getsc()) == '-')
						iop->flag |= IOSKIP;
					else
						ungetsc(c2);
			} else if (c2 == '&')
				iop->flag = IODUP | (c == '<' ? IORDUP : 0);
			else {
				iop->flag = c == '>' ? IOWRITE : IOREAD;
				if (c == '>' && c2 == '|')
					iop->flag |= IOCLOB;
				else
					ungetsc(c2);
			}

			iop->name = (char *) 0;
			iop->delim = (char *) 0;
			yylval.iop = iop;
			return REDIR;
		    }
d705 1
d722 1
a722 1
		|| state == SDPAREN
a870 1
	yynerrs++;
d1394 28
@


1.9
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.8 1997/08/05 21:49:55 grr Exp $	*/
d1038 3
a1040 1

@


1.8
log
@Fixes for a variety of pdksh problems:

1) pkksh in sh mode closed fd's other than [012] on exec'ing a command.
	this is a ksh'ism and POSIX sates that open files are part of the
	environment to be passed to the new process.

2) pdksh in sh mode interpets (( as meaning the start of arithmetic
	"quoting", which is incompatible with it's usage as a nested
	sub-shell invocation.  The $(( form for arithmetic substitution
	is stil valid, however.
	PR user/59 millert@@openbsd.org (Todd C. Miller)

3) pdksh sh.1 manpage isn't explicit about the range of input text
	that is subject to field splitting after a substitution.
	PR user/236 Mathieu.Herrb@@mipnet.fr (Mathiew Herrb)
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.7 1997/06/19 13:58:44 kstailey Exp $	*/
d65 1
a65 1
		istate = SDPAREN;	
@


1.7
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.5 1996/11/21 07:59:32 downsj Exp $	*/
d590 6
a595 4
			if ((c2 = getsc()) == '(') /*)*/
				c = MDPAREN;
			else
				ungetsc(c2);
@


1.6
log
@(foo *)0 -> NULL
@
text
@d577 2
a578 2
			iop->name = NULL;
			iop->delim = NULL;
d1014 1
a1014 1
		set_prompt(PS2, NULL);
d1038 2
a1039 2
			shf = shf_sopen(NULL, strlen(ps1) * 2,
				SHF_WR | SHF_DYNAMIC, NULL);
@


1.5
log
@Update to 5.2.12.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.4 1996/10/13 21:32:19 downsj Exp $	*/
d577 2
a578 2
			iop->name = (char *) 0;
			iop->delim = (char *) 0;
d1014 1
a1014 1
		set_prompt(PS2, (Source *) 0);
d1038 2
a1039 2
			shf = shf_sopen((char *) 0, strlen(ps1) * 2,
				SHF_WR | SHF_DYNAMIC, (struct shf *) 0);
@


1.4
log
@Update to version 5.2.11.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.3 1996/10/01 02:05:42 downsj Exp $	*/
d874 1
@


1.3
log
@Integrate pdksh 5.2.9.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.2 1996/08/19 20:08:55 downsj Exp $	*/
d11 1
a11 1
static int	getsc_ ARGS((void));
d15 12
a26 10
static const char *ungetsc_ ARGS((int c));
static int	getsc_bn_ ARGS((void));

static void gethere ARGS((void));

/* optimized getsc_() */
#define	getsc()	((*source->str != '\0') ? *source->str++ : getsc_())
#define getsc_bn() (*source->str != '\0' && *source->str != '\\' \
			? *source->str++ : getsc_bn_())
#define	ungetsc(c) (source->str > source->start ? source->str-- : ungetsc_(c))
d57 3
d73 2
a74 1
		if (c == '#')
d77 2
a149 1
				if (c != '\n') {
d151 4
a154 4
					if (isalnum(c)) {
						*wp++ = CHAR, *wp++ = '\\';
						*wp++ = CHAR, *wp++ = c;
					} else
d156 2
a157 6
						*wp++ = QCHAR, *wp++ = c;
				} else
					if (wp == Xstring(ws, wp)) {
						Xfree(ws, wp);	/* free word */
						goto Again;
					}
d162 1
a177 2
				  case '\n':
					break;
d184 4
a187 2
					*wp++ = CHAR, *wp++ = '\\';
					*wp++ = CHAR, *wp++ = c;
d214 1
a214 1
					c = getsc_bn();
d217 1
a217 1
						if ((c2 = getsc_bn()) == c)
d270 1
d306 1
d324 1
a324 1
				if (c == '\'')
d326 2
a400 2
				  case '\n':
					break;
d412 4
a415 2
					*wp++ = '\\';
					*wp++ = c;
d458 1
a458 1
				if (c != '\n') {
d465 1
d480 13
a492 2
				if (c == '\\' && (c = getsc()) == '\n')
					break;
d563 1
a563 1
					if (getsc() == '-')
d676 1
a676 1
	int skiptabs, bn;
d703 3
a705 1
	bn = iop->flag & IOEVAL;
d709 1
a709 1
		while ((c = (bn ? getsc_bn() : getsc())) != 0) {
d726 1
a726 1
		while ((c = (bn ? getsc_bn() : getsc())) != '\n') {
d740 2
d798 1
a798 1
getsc_()
d846 4
d852 8
a859 5
				/* put a fake space at the end of the alias.
				 * This keeps the current alias in the source
				 * list so recursive aliases can be detected.
				 * The addition of a space after an alias
				 * never affects anything (I think).
d861 14
a874 2
				s->flags |= SF_ALIASEND;
				s->start = s->str = space;
d879 1
a879 1
			if (s->start != s->u.ugbuf) /* yuck */
d1134 1
a1134 1
		c = getsc_bn();
d1167 1
a1167 1
					c = getsc();
d1209 1
a1209 1
		c = getsc_bn();
d1226 1
a1226 1
ungetsc_(c)
d1229 2
d1240 2
a1241 2
		s->u.ugbuf[0] = c; s->u.ugbuf[1] = '\0';
		s->start = s->str = s->u.ugbuf;
d1248 1
d1251 1
a1251 1
getsc_bn_ ARGS((void))
d1253 11
a1263 1
	int c;
d1267 6
a1272 6
		if (c != '\\')
			return c;
		c = getsc();
		if (c != '\n') {
			ungetsc(c);
			return '\\';
d1274 1
a1274 1
		/* ignore the \newline; get the next char... */
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
d57 1
d62 3
a64 1
	} else {		/* normal lexing */
d417 1
d437 1
d569 1
d574 1
d584 5
a588 1
	if (state == SWORD || state == SDPAREN)	/* ONEWORD? */
d1070 2
a1071 6
	if (ntruncate)
		shellf("%.*s", ntruncate, cp);
	else {
		shf_puts(cp, shl_out);
		shf_flush(shl_out);
	}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d971 1
d997 6
a1002 1
				warningf(TRUE, "error during expansion of PS1");
d1008 3
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
