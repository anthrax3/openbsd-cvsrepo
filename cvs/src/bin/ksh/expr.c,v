head	1.32;
access;
symbols
	OPENBSD_6_1:1.32.0.8
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.16
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.14
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.12
	OPENBSD_5_0:1.21.0.10
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.8
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.6
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.19.0.12
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.10
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.8
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.4
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.14
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.12
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.10
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2015.12.30.09.07.00;	author tedu;	state Exp;
branches;
next	1.31;
commitid	WTwPzlskFufQpRQz;

1.31
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.30;
commitid	C4W85jmosThChWA2;

1.30
date	2015.10.19.14.03.21;	author mmcc;	state Exp;
branches;
next	1.29;
commitid	TSZF0K3aGmPbKQzz;

1.29
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.28;
commitid	16HUr75moyUNtKR8;

1.28
date	2015.09.22.21.50.40;	author millert;	state Exp;
branches;
next	1.27;
commitid	ZWmS69dzJnkF6rox;

1.27
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.26;
commitid	7fgq4YTZG4xZ0uN0;

1.26
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.25;
commitid	v5QjoxUgKU2iUTFz;

1.25
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.24;
commitid	lBs9un9sXhbdfVrQ;

1.24
date	2014.12.08.14.26.31;	author otto;	state Exp;
branches;
next	1.23;
commitid	MVASUuD0D1dhoQWq;

1.23
date	2013.12.17.16.37.06;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2013.03.28.08.39.28;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.01.19.00.57;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.01.18.20.33;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.10.14.38.59;	author jaredy;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.02.07.53.01;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.22.18.57.28;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.18.22.42.26;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.18.21.04.52;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.22.07.40.38;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.7;

1.7
date	99.06.15.01.18.34;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.01.19.20.41.52;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.01.10.17.55.02;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.06.19.13.58.41;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.06.18.22.42.34;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.50;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.32
log
@rename global "e" to genv to avoid accidental shadowing and aliasing.
ok millert nicm tb
@
text
@/*	$OpenBSD: expr.c,v 1.31 2015/10/19 14:42:16 mmcc Exp $	*/

/*
 * Korn expression evaluation
 */
/*
 * todo: better error handling: if in builtin, should be builtin error, etc.
 */

#include <ctype.h>
#include <limits.h>
#include <string.h>

#include "sh.h"

/* The order of these enums is constrained by the order of opinfo[] */
enum token {
	/* some (long) unary operators */
	O_PLUSPLUS = 0, O_MINUSMINUS,
	/* binary operators */
	O_EQ, O_NE,
	/* assignments are assumed to be in range O_ASN .. O_BORASN */
	O_ASN, O_TIMESASN, O_DIVASN, O_MODASN, O_PLUSASN, O_MINUSASN,
	O_LSHIFTASN, O_RSHIFTASN, O_BANDASN, O_BXORASN, O_BORASN,
	O_LSHIFT, O_RSHIFT,
	O_LE, O_GE, O_LT, O_GT,
	O_LAND,
	O_LOR,
	O_TIMES, O_DIV, O_MOD,
	O_PLUS, O_MINUS,
	O_BAND,
	O_BXOR,
	O_BOR,
	O_TERN,
	O_COMMA,
	/* things after this aren't used as binary operators */
	/* unary that are not also binaries */
	O_BNOT, O_LNOT,
	/* misc */
	OPEN_PAREN, CLOSE_PAREN, CTERN,
	/* things that don't appear in the opinfo[] table */
	VAR, LIT, END, BAD
};
#define IS_BINOP(op) (((int)op) >= (int)O_EQ && ((int)op) <= (int)O_COMMA)
#define IS_ASSIGNOP(op)	((int)(op) >= (int)O_ASN && (int)(op) <= (int)O_BORASN)

enum prec {
	P_PRIMARY = 0,		/* VAR, LIT, (), ~ ! - + */
	P_MULT,			/* * / % */
	P_ADD,			/* + - */
	P_SHIFT,		/* << >> */
	P_RELATION,		/* < <= > >= */
	P_EQUALITY,		/* == != */
	P_BAND,			/* & */
	P_BXOR,			/* ^ */
	P_BOR,			/* | */
	P_LAND,			/* && */
	P_LOR,			/* || */
	P_TERN,			/* ?: */
	P_ASSIGN,		/* = *= /= %= += -= <<= >>= &= ^= |= */
	P_COMMA			/* , */
};
#define MAX_PREC	P_COMMA

struct opinfo {
	char		name[4];
	int		len;	/* name length */
	enum prec	prec;	/* precedence: lower is higher */
};

/* Tokens in this table must be ordered so the longest are first
 * (eg, += before +).  If you change something, change the order
 * of enum token too.
 */
static const struct opinfo opinfo[] = {
	{ "++",	 2, P_PRIMARY },	/* before + */
	{ "--",	 2, P_PRIMARY },	/* before - */
	{ "==",	 2, P_EQUALITY },	/* before = */
	{ "!=",	 2, P_EQUALITY },	/* before ! */
	{ "=",	 1, P_ASSIGN },		/* keep assigns in a block */
	{ "*=",	 2, P_ASSIGN },
	{ "/=",	 2, P_ASSIGN },
	{ "%=",	 2, P_ASSIGN },
	{ "+=",	 2, P_ASSIGN },
	{ "-=",	 2, P_ASSIGN },
	{ "<<=", 3, P_ASSIGN },
	{ ">>=", 3, P_ASSIGN },
	{ "&=",	 2, P_ASSIGN },
	{ "^=",	 2, P_ASSIGN },
	{ "|=",	 2, P_ASSIGN },
	{ "<<",	 2, P_SHIFT },
	{ ">>",	 2, P_SHIFT },
	{ "<=",	 2, P_RELATION },
	{ ">=",	 2, P_RELATION },
	{ "<",	 1, P_RELATION },
	{ ">",	 1, P_RELATION },
	{ "&&",	 2, P_LAND },
	{ "||",	 2, P_LOR },
	{ "*",	 1, P_MULT },
	{ "/",	 1, P_MULT },
	{ "%",	 1, P_MULT },
	{ "+",	 1, P_ADD },
	{ "-",	 1, P_ADD },
	{ "&",	 1, P_BAND },
	{ "^",	 1, P_BXOR },
	{ "|",	 1, P_BOR },
	{ "?",	 1, P_TERN },
	{ ",",	 1, P_COMMA },
	{ "~",	 1, P_PRIMARY },
	{ "!",	 1, P_PRIMARY },
	{ "(",	 1, P_PRIMARY },
	{ ")",	 1, P_PRIMARY },
	{ ":",	 1, P_PRIMARY },
	{ "",	 0, P_PRIMARY } /* end of table */
};


typedef struct expr_state Expr_state;
struct expr_state {
	const char *expression;		/* expression being evaluated */
	const char *tokp;		/* lexical position */
	enum token  tok;		/* token from token() */
	int	    noassign;		/* don't do assigns (for ?:,&&,||) */
	bool	    arith;		/* true if evaluating an $(())
					 * expression
					 */
	struct tbl *val;		/* value from token() */
	struct tbl *evaling;		/* variable that is being recursively
					 * expanded (EXPRINEVAL flag set)
					 */
};

enum error_type {
	ET_UNEXPECTED, ET_BADLIT, ET_RECURSIVE,
	ET_LVALUE, ET_RDONLY, ET_STR
};

static void	   evalerr(Expr_state *, enum error_type, const char *)
		    __attribute__((__noreturn__));
static struct tbl *evalexpr(Expr_state *, enum prec);
static void	   token(Expr_state *);
static struct tbl *do_ppmm(Expr_state *, enum token, struct tbl *, bool);
static void	   assign_check(Expr_state *, enum token, struct tbl *);
static struct tbl *tempvar(void);
static struct tbl *intvar(Expr_state *, struct tbl *);

/*
 * parse and evaluate expression
 */
int
evaluate(const char *expr, long int *rval, int error_ok, bool arith)
{
	struct tbl v;
	int ret;

	v.flag = DEFINED|INTEGER;
	v.type = 0;
	ret = v_evaluate(&v, expr, error_ok, arith);
	*rval = v.val.i;
	return ret;
}

/*
 * parse and evaluate expression, storing result in vp.
 */
int
v_evaluate(struct tbl *vp, const char *expr, volatile int error_ok,
    bool arith)
{
	struct tbl *v;
	Expr_state curstate;
	Expr_state * const es = &curstate;
	int i;

	/* save state to allow recursive calls */
	curstate.expression = curstate.tokp = expr;
	curstate.noassign = 0;
	curstate.arith = arith;
	curstate.evaling = NULL;
	curstate.val = NULL;

	newenv(E_ERRH);
	i = sigsetjmp(genv->jbuf, 0);
	if (i) {
		/* Clear EXPRINEVAL in of any variables we were playing with */
		if (curstate.evaling)
			curstate.evaling->flag &= ~EXPRINEVAL;
		quitenv(NULL);
		if (i == LAEXPR) {
			if (error_ok == KSH_RETURN_ERROR)
				return 0;
			errorf(NULL);
		}
		unwind(i);
		/* NOTREACHED */
	}

	token(es);
#if 1 /* ifdef-out to disallow empty expressions to be treated as 0 */
	if (es->tok == END) {
		es->tok = LIT;
		es->val = tempvar();
	}
#endif /* 0 */
	v = intvar(es, evalexpr(es, MAX_PREC));

	if (es->tok != END)
		evalerr(es, ET_UNEXPECTED, NULL);

	if (vp->flag & INTEGER)
		setint_v(vp, v, es->arith);
	else
		/* can fail if readonly */
		setstr(vp, str_val(v), error_ok);

	quitenv(NULL);

	return 1;
}

static void
evalerr(Expr_state *es, enum error_type type, const char *str)
{
	char tbuf[2];
	const char *s;

	es->arith = false;
	switch (type) {
	case ET_UNEXPECTED:
		switch (es->tok) {
		case VAR:
			s = es->val->name;
			break;
		case LIT:
			s = str_val(es->val);
			break;
		case END:
			s = "end of expression";
			break;
		case BAD:
			tbuf[0] = *es->tokp;
			tbuf[1] = '\0';
			s = tbuf;
			break;
		default:
			s = opinfo[(int)es->tok].name;
		}
		warningf(true, "%s: unexpected `%s'", es->expression, s);
		break;

	case ET_BADLIT:
		warningf(true, "%s: bad number `%s'", es->expression, str);
		break;

	case ET_RECURSIVE:
		warningf(true, "%s: expression recurses on parameter `%s'",
		    es->expression, str);
		break;

	case ET_LVALUE:
		warningf(true, "%s: %s requires lvalue",
		    es->expression, str);
		break;

	case ET_RDONLY:
		warningf(true, "%s: %s applied to read only variable",
		    es->expression, str);
		break;

	default: /* keep gcc happy */
	case ET_STR:
		warningf(true, "%s: %s", es->expression, str);
		break;
	}
	unwind(LAEXPR);
}

static struct tbl *
evalexpr(Expr_state *es, enum prec prec)
{
	struct tbl *vl, *vr = NULL, *vasn;
	enum token op;
	long res = 0;

	if (prec == P_PRIMARY) {
		op = es->tok;
		if (op == O_BNOT || op == O_LNOT || op == O_MINUS ||
		    op == O_PLUS) {
			token(es);
			vl = intvar(es, evalexpr(es, P_PRIMARY));
			if (op == O_BNOT)
				vl->val.i = ~vl->val.i;
			else if (op == O_LNOT)
				vl->val.i = !vl->val.i;
			else if (op == O_MINUS)
				vl->val.i = -vl->val.i;
			/* op == O_PLUS is a no-op */
		} else if (op == OPEN_PAREN) {
			token(es);
			vl = evalexpr(es, MAX_PREC);
			if (es->tok != CLOSE_PAREN)
				evalerr(es, ET_STR, "missing )");
			token(es);
		} else if (op == O_PLUSPLUS || op == O_MINUSMINUS) {
			token(es);
			vl = do_ppmm(es, op, es->val, true);
			token(es);
		} else if (op == VAR || op == LIT) {
			vl = es->val;
			token(es);
		} else {
			evalerr(es, ET_UNEXPECTED, NULL);
			/* NOTREACHED */
		}
		if (es->tok == O_PLUSPLUS || es->tok == O_MINUSMINUS) {
			vl = do_ppmm(es, es->tok, vl, false);
			token(es);
		}
		return vl;
	}
	vl = evalexpr(es, ((int) prec) - 1);
	for (op = es->tok; IS_BINOP(op) && opinfo[(int) op].prec == prec;
	    op = es->tok) {
		token(es);
		vasn = vl;
		if (op != O_ASN) /* vl may not have a value yet */
			vl = intvar(es, vl);
		if (IS_ASSIGNOP(op)) {
			assign_check(es, op, vasn);
			vr = intvar(es, evalexpr(es, P_ASSIGN));
		} else if (op != O_TERN && op != O_LAND && op != O_LOR)
			vr = intvar(es, evalexpr(es, ((int) prec) - 1));
		if ((op == O_DIV || op == O_MOD || op == O_DIVASN ||
		    op == O_MODASN) && vr->val.i == 0) {
			if (es->noassign)
				vr->val.i = 1;
			else
				evalerr(es, ET_STR, "zero divisor");
		}
		switch ((int) op) {
		case O_TIMES:
		case O_TIMESASN:
			res = vl->val.i * vr->val.i;
			break;
		case O_DIV:
		case O_DIVASN:
			if (vl->val.i == LONG_MIN && vr->val.i == -1)
				res = LONG_MIN;
			else
				res = vl->val.i / vr->val.i;
			break;
		case O_MOD:
		case O_MODASN:
			if (vl->val.i == LONG_MIN && vr->val.i == -1)
				res = 0;
			else
				res = vl->val.i % vr->val.i;
			break;
		case O_PLUS:
		case O_PLUSASN:
			res = vl->val.i + vr->val.i;
			break;
		case O_MINUS:
		case O_MINUSASN:
			res = vl->val.i - vr->val.i;
			break;
		case O_LSHIFT:
		case O_LSHIFTASN:
			res = vl->val.i << vr->val.i;
			break;
		case O_RSHIFT:
		case O_RSHIFTASN:
			res = vl->val.i >> vr->val.i;
			break;
		case O_LT:
			res = vl->val.i < vr->val.i;
			break;
		case O_LE:
			res = vl->val.i <= vr->val.i;
			break;
		case O_GT:
			res = vl->val.i > vr->val.i;
			break;
		case O_GE:
			res = vl->val.i >= vr->val.i;
			break;
		case O_EQ:
			res = vl->val.i == vr->val.i;
			break;
		case O_NE:
			res = vl->val.i != vr->val.i;
			break;
		case O_BAND:
		case O_BANDASN:
			res = vl->val.i & vr->val.i;
			break;
		case O_BXOR:
		case O_BXORASN:
			res = vl->val.i ^ vr->val.i;
			break;
		case O_BOR:
		case O_BORASN:
			res = vl->val.i | vr->val.i;
			break;
		case O_LAND:
			if (!vl->val.i)
				es->noassign++;
			vr = intvar(es, evalexpr(es, ((int) prec) - 1));
			res = vl->val.i && vr->val.i;
			if (!vl->val.i)
				es->noassign--;
			break;
		case O_LOR:
			if (vl->val.i)
				es->noassign++;
			vr = intvar(es, evalexpr(es, ((int) prec) - 1));
			res = vl->val.i || vr->val.i;
			if (vl->val.i)
				es->noassign--;
			break;
		case O_TERN:
			{
				int e = vl->val.i != 0;

				if (!e)
					es->noassign++;
				vl = evalexpr(es, MAX_PREC);
				if (!e)
					es->noassign--;
				if (es->tok != CTERN)
					evalerr(es, ET_STR, "missing :");
				token(es);
				if (e)
					es->noassign++;
				vr = evalexpr(es, P_TERN);
				if (e)
					es->noassign--;
				vl = e ? vl : vr;
			}
			break;
		case O_ASN:
			res = vr->val.i;
			break;
		case O_COMMA:
			res = vr->val.i;
			break;
		}
		if (IS_ASSIGNOP(op)) {
			vr->val.i = res;
			if (vasn->flag & INTEGER)
				setint_v(vasn, vr, es->arith);
			else
				setint(vasn, res);
			vl = vr;
		} else if (op != O_TERN)
			vl->val.i = res;
	}
	return vl;
}

static void
token(Expr_state *es)
{
	const char *cp;
	int c;
	char *tvar;

	/* skip white space */
	for (cp = es->tokp; (c = *cp), isspace((unsigned char)c); cp++)
		;
	es->tokp = cp;

	if (c == '\0')
		es->tok = END;
	else if (letter(c)) {
		for (; letnum(c); c = *cp)
			cp++;
		if (c == '[') {
			int len;

			len = array_ref_len(cp);
			if (len == 0)
				evalerr(es, ET_STR, "missing ]");
			cp += len;
		} else if (c == '(' /*)*/ ) {
			/* todo: add math functions (all take single argument):
			 * abs acos asin atan cos cosh exp int log sin sinh sqrt
			 * tan tanh
			 */
			;
		}
		if (es->noassign) {
			es->val = tempvar();
			es->val->flag |= EXPRLVALUE;
		} else {
			tvar = str_nsave(es->tokp, cp - es->tokp, ATEMP);
			es->val = global(tvar);
			afree(tvar, ATEMP);
		}
		es->tok = VAR;
	} else if (digit(c)) {
		for (; c != '_' && (letnum(c) || c == '#'); c = *cp++)
			;
		tvar = str_nsave(es->tokp, --cp - es->tokp, ATEMP);
		es->val = tempvar();
		es->val->flag &= ~INTEGER;
		es->val->type = 0;
		es->val->val.s = tvar;
		if (setint_v(es->val, es->val, es->arith) == NULL)
			evalerr(es, ET_BADLIT, tvar);
		afree(tvar, ATEMP);
		es->tok = LIT;
	} else {
		int i, n0;

		for (i = 0; (n0 = opinfo[i].name[0]); i++)
			if (c == n0 &&
			    strncmp(cp, opinfo[i].name, opinfo[i].len) == 0) {
				es->tok = (enum token) i;
				cp += opinfo[i].len;
				break;
			}
		if (!n0)
			es->tok = BAD;
	}
	es->tokp = cp;
}

/* Do a ++ or -- operation */
static struct tbl *
do_ppmm(Expr_state *es, enum token op, struct tbl *vasn, bool is_prefix)
{
	struct tbl *vl;
	int oval;

	assign_check(es, op, vasn);

	vl = intvar(es, vasn);
	oval = op == O_PLUSPLUS ? vl->val.i++ : vl->val.i--;
	if (vasn->flag & INTEGER)
		setint_v(vasn, vl, es->arith);
	else
		setint(vasn, vl->val.i);
	if (!is_prefix)		/* undo the inc/dec */
		vl->val.i = oval;

	return vl;
}

static void
assign_check(Expr_state *es, enum token op, struct tbl *vasn)
{
	if (es->tok == END || vasn == NULL ||
	    (vasn->name[0] == '\0' && !(vasn->flag & EXPRLVALUE)))
		evalerr(es, ET_LVALUE, opinfo[(int) op].name);
	else if (vasn->flag & RDONLY)
		evalerr(es, ET_RDONLY, opinfo[(int) op].name);
}

static struct tbl *
tempvar(void)
{
	struct tbl *vp;

	vp = alloc(sizeof(struct tbl), ATEMP);
	vp->flag = ISSET|INTEGER;
	vp->type = 0;
	vp->areap = ATEMP;
	vp->val.i = 0;
	vp->name[0] = '\0';
	return vp;
}

/* cast (string) variable to temporary integer variable */
static struct tbl *
intvar(Expr_state *es, struct tbl *vp)
{
	struct tbl *vq;

	/* try to avoid replacing a temp var with another temp var */
	if (vp->name[0] == '\0' &&
	    (vp->flag & (ISSET|INTEGER|EXPRLVALUE)) == (ISSET|INTEGER))
		return vp;

	vq = tempvar();
	if (setint_v(vq, vp, es->arith) == NULL) {
		if (vp->flag & EXPRINEVAL)
			evalerr(es, ET_RECURSIVE, vp->name);
		es->evaling = vp;
		vp->flag |= EXPRINEVAL;
		v_evaluate(vq, str_val(vp), KSH_UNWIND_ERROR, es->arith);
		vp->flag &= ~EXPRINEVAL;
		es->evaling = NULL;
	}
	return vq;
}
@


1.31
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.30 2015/10/19 14:03:21 mmcc Exp $	*/
d183 1
a183 1
	i = sigsetjmp(e->jbuf, 0);
@


1.30
log
@Move limits.h include from sh.h to the files that actually need it. No
binary change.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.29 2015/10/19 02:15:45 mmcc Exp $	*/
d12 1
@


1.29
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.28 2015/09/22 21:50:40 millert Exp $	*/
d11 1
@


1.28
log
@Make errorf() and bi_errorf() handle a NULL argument.
From Michael McConville; OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.27 2015/09/18 07:28:24 nicm Exp $	*/
a9 1
#include "sh.h"
d12 1
@


1.27
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.26 2015/09/17 14:21:33 nicm Exp $	*/
d190 1
a190 1
			errorf(null);
@


1.26
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.25 2015/09/15 18:15:05 tedu Exp $	*/
d177 2
a178 2
	curstate.evaling = (struct tbl *) 0;
	curstate.val = (struct tbl *) 0;
d591 1
a591 1
		es->evaling = (struct tbl *) 0;
@


1.25
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.24 2014/12/08 14:26:31 otto Exp $	*/
d563 1
a563 1
	vp = (struct tbl*) alloc(sizeof(struct tbl), ATEMP);
@


1.24
log
@fix crash when trying to apply ++ without an lvalue; ok millert@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.23 2013/12/17 16:37:06 deraadt Exp $	*/
d206 1
a206 1
		evalerr(es, ET_UNEXPECTED, (char *) 0);
d310 1
a310 1
			evalerr(es, ET_UNEXPECTED, (char *) 0);
@


1.23
log
@ctype cleanups.  Repeated re-audits of this sensitive area by okan and
myself, with a variety of other people spending some time as well.
Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.22 2013/03/28 08:39:28 nicm Exp $	*/
d178 1
d551 1
a551 1
	if (es->tok == END ||
@


1.22
log
@Don't die with SIGFPE on LONG_MIN / -1 or % -1. Instead make LONG_MIN /
-1 == LONG_MIN and % -1 == 0.

ok matthew deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.21 2009/06/01 19:00:57 deraadt Exp $	*/
d466 1
a466 1
	for (cp = es->tokp; (c = *cp), isspace(c); cp++)
@


1.21
log
@please sthen the 80 character pedant
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.20 2009/06/01 18:20:33 deraadt Exp $	*/
d344 4
a347 1
			res = vl->val.i / vr->val.i;
d351 4
a354 1
			res = vl->val.i % vr->val.i;
@


1.20
log
@"let --" was crashing ksh; found by phy0@@rambler.ru.  Various other expressions
involving ++ and -- also ran into this. Insufficient checks for end of parse in
the tokenizer made it assume that an lvalue had been found
ok millert otto
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.19 2006/04/10 14:38:59 jaredy Exp $	*/
d544 2
a545 1
	if (es->tok == END || (vasn->name[0] == '\0' && !(vasn->flag & EXPRLVALUE)))
@


1.19
log
@fix lint comments, no functional changes; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.18 2005/03/30 17:16:37 deraadt Exp $	*/
d544 1
a544 1
	if (vasn->name[0] == '\0' && !(vasn->flag & EXPRLVALUE))
@


1.18
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.17 2005/02/02 07:53:01 otto Exp $	*/
d192 1
a192 1
		/*NOTREACHED*/
d310 1
a310 1
			/*NOTREACHED*/
@


1.17
log
@Introduce POSIX hex and octal (0x... and 0...) constants in arithmetic
expressions.  Work by Matthias Kilian, based on an old diff by myself.
Note: MAKEDEV should be updated. Tested by many, thanks.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.16 2004/12/22 18:57:28 otto Exp $	*/
d22 1
a22 1
	       O_LSHIFTASN, O_RSHIFTASN, O_BANDASN, O_BXORASN, O_BORASN,
d41 1
a41 1
    };
d60 1
a60 1
    };
d74 40
a113 40
		{ "++",	 2, P_PRIMARY },	/* before + */
		{ "--",	 2, P_PRIMARY },	/* before - */
		{ "==",	 2, P_EQUALITY },	/* before = */
		{ "!=",	 2, P_EQUALITY },	/* before ! */
		{ "=",	 1, P_ASSIGN },		/* keep assigns in a block */
		{ "*=",	 2, P_ASSIGN },
		{ "/=",	 2, P_ASSIGN },
		{ "%=",	 2, P_ASSIGN },
		{ "+=",	 2, P_ASSIGN },
		{ "-=",	 2, P_ASSIGN },
		{ "<<=", 3, P_ASSIGN },
		{ ">>=", 3, P_ASSIGN },
		{ "&=",	 2, P_ASSIGN },
		{ "^=",	 2, P_ASSIGN },
		{ "|=",	 2, P_ASSIGN },
		{ "<<",	 2, P_SHIFT },
		{ ">>",	 2, P_SHIFT },
		{ "<=",	 2, P_RELATION },
		{ ">=",	 2, P_RELATION },
		{ "<",	 1, P_RELATION },
		{ ">",	 1, P_RELATION },
		{ "&&",	 2, P_LAND },
		{ "||",	 2, P_LOR },
		{ "*",	 1, P_MULT },
		{ "/",	 1, P_MULT },
		{ "%",	 1, P_MULT },
		{ "+",	 1, P_ADD },
		{ "-",	 1, P_ADD },
		{ "&",	 1, P_BAND },
		{ "^",	 1, P_BXOR },
		{ "|",	 1, P_BOR },
		{ "?",	 1, P_TERN },
		{ ",",	 1, P_COMMA },
		{ "~",	 1, P_PRIMARY },
		{ "!",	 1, P_PRIMARY },
		{ "(",	 1, P_PRIMARY },
		{ ")",	 1, P_PRIMARY },
		{ ":",	 1, P_PRIMARY },
		{ "",	 0, P_PRIMARY } /* end of table */
	    };
d131 4
a134 2
enum error_type { ET_UNEXPECTED, ET_BADLIT, ET_RECURSIVE,
		  ET_LVALUE, ET_RDONLY, ET_STR };
d136 2
a137 2
static void        evalerr(Expr_state *, enum error_type, const char *)
		       __attribute__((__noreturn__));
d139 1
a139 1
static void        token(Expr_state *);
d254 1
a254 1
			es->expression, str);
d259 1
a259 1
			es->expression, str);
d264 1
a264 1
			es->expression, str);
d284 2
a285 3
		if (op == O_BNOT || op == O_LNOT || op == O_MINUS
		    || op == O_PLUS)
		{
d320 1
a320 2
		op = es->tok)
	{
d330 2
a331 3
		if ((op == O_DIV || op == O_MOD || op == O_DIVASN
		     || op == O_MODASN) && vr->val.i == 0)
		{
d415 1
d477 5
a481 5
		    /* todo: add math functions (all take single argument):
		     * abs acos asin atan cos cosh exp int log sin sinh sqrt
		     * tan tanh
		     */
		    ;
d508 2
a509 3
			if (c == n0
			    && strncmp(cp, opinfo[i].name, opinfo[i].len) == 0)
			{
d571 2
a572 2
	if (vp->name[0] == '\0'
	    && (vp->flag & (ISSET|INTEGER|EXPRLVALUE)) == (ISSET|INTEGER))
@


1.16
log
@Fix a use-after-free, that causs core dumps if a shell is killed
running with strict malloc.conf options. Problem spotted by hshoexer@@;
fix by me with some help from millert@@.

ok millert@@ hshoexer@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.15 2004/12/22 17:14:34 millert Exp $	*/
d122 3
d147 1
a147 1
evaluate(const char *expr, long int *rval, int error_ok)
d154 1
a154 1
	ret = v_evaluate(&v, expr, error_ok);
d163 2
a164 1
v_evaluate(struct tbl *vp, const char *expr, volatile int error_ok)
d174 1
d206 1
a206 1
		setint_v(vp, v);
d222 1
d442 1
a442 1
				setint_v(vasn, vr);
d500 1
a500 1
		if (setint_v(es->val, es->val) == NULL)
d533 1
a533 1
		setint_v(vasn, vl);
d577 1
a577 1
	if (setint_v(vq, vp) == NULL) {
d582 1
a582 1
		v_evaluate(vq, str_val(vp), KSH_UNWIND_ERROR);
@


1.15
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.14 2004/12/20 11:34:26 otto Exp $	*/
d178 1
a178 1
		quitenv();
d206 1
a206 1
	quitenv();
@


1.14
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.13 2004/12/18 22:42:26 millert Exp $	*/
d135 1
a135 1
static struct tbl *do_ppmm(Expr_state *, enum token, struct tbl *, bool_t);
d237 1
a237 1
		warningf(TRUE, "%s: unexpected `%s'", es->expression, s);
d241 1
a241 1
		warningf(TRUE, "%s: bad number `%s'", es->expression, str);
d245 1
a245 1
		warningf(TRUE, "%s: expression recurses on parameter `%s'",
d250 1
a250 1
		warningf(TRUE, "%s: %s requires lvalue",
d255 1
a255 1
		warningf(TRUE, "%s: %s applied to read only variable",
d261 1
a261 1
		warningf(TRUE, "%s: %s", es->expression, str);
d296 1
a296 1
			vl = do_ppmm(es, op, es->val, TRUE);
d306 1
a306 1
			vl = do_ppmm(es, es->tok, vl, FALSE);
d517 1
a517 1
do_ppmm(Expr_state *es, enum token op, struct tbl *vasn, bool_t is_prefix)
@


1.13
log
@remove GCC_FUNC_ATTR/GCC_FUNC_ATTR2 and just use __attribute__ directly
(we define it away in sys/cdefs.h if it is not supported).
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.12 2004/12/18 21:25:44 millert Exp $	*/
d131 6
a136 8
static void        evalerr(Expr_state *es, enum error_type type,
		    const char *str) __attribute__((__noreturn__));
static struct tbl *evalexpr(Expr_state *es, enum prec prec);
static void        token(Expr_state *es);
static struct tbl *do_ppmm(Expr_state *es, enum token op,
				  struct tbl *vasn, bool_t is_prefix);
static void	   assign_check(Expr_state *es, enum token op,
				      struct tbl *vasn);
d138 1
a138 1
static struct tbl *intvar(Expr_state *es, struct tbl *vp);
d144 1
a144 4
evaluate(expr, rval, error_ok)
	const char *expr;
	long *rval;
	int error_ok;
d160 1
a160 4
v_evaluate(vp, expr, error_ok)
	struct tbl *vp;
	const char *expr;
	volatile int error_ok;
d212 1
a212 4
evalerr(es, type, str)
	Expr_state *es;
	enum error_type type;
	const char *str;
d268 1
a268 3
evalexpr(es, prec)
	Expr_state *es;
	enum prec prec;
d447 1
a447 2
token(es)
	Expr_state *es;
d517 1
a517 5
do_ppmm(es, op, vasn, is_prefix)
	Expr_state *es;
	enum token op;
	struct tbl *vasn;
	bool_t is_prefix;
d537 1
a537 4
assign_check(es, op, vasn)
	Expr_state *es;
	enum token op;
	struct tbl *vasn;
d546 1
a546 1
tempvar()
d561 1
a561 3
intvar(es, vp)
	Expr_state *es;
	struct tbl *vp;
@


1.12
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.11 2004/12/18 21:04:52 millert Exp $	*/
d132 1
a132 1
				  const char *str) GCC_FUNC_ATTR(noreturn);
@


1.11
log
@Get rid of #ifdef KSH since we don't care about building a V7 style sh and
the #ifdef KSH code is required to make a POSIX sh.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.10 2004/12/18 20:55:52 millert Exp $	*/
d569 1
a569 1
	register struct tbl *vp;
@


1.10
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.9 2003/10/22 07:40:38 jmc Exp $	*/
d484 1
a484 3
		}
#ifdef KSH
		else if (c == '(' /*)*/ ) {
a490 1
#endif /* KSH */
@


1.9
log
@typos from Jared Yanovich;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.8 2003/02/28 09:45:09 jmc Exp $	*/
d131 10
a140 10
static void        evalerr  ARGS((Expr_state *es, enum error_type type,
				  const char *str)) GCC_FUNC_ATTR(noreturn);
static struct tbl *evalexpr ARGS((Expr_state *es, enum prec prec));
static void        token    ARGS((Expr_state *es));
static struct tbl *do_ppmm  ARGS((Expr_state *es, enum token op,
				  struct tbl *vasn, bool_t is_prefix));
static void	   assign_check ARGS((Expr_state *es, enum token op,
				      struct tbl *vasn));
static struct tbl *tempvar  ARGS((void));
static struct tbl *intvar   ARGS((Expr_state *es, struct tbl *vp));
d181 1
a181 1
	i = ksh_sigsetjmp(e->jbuf, 0);
d283 1
a283 1
	struct tbl *vl, UNINITIALIZED(*vr), *vasn;
d285 1
a285 1
	long UNINITIALIZED(res);
@


1.8
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.7 1999/06/15 01:18:34 millert Exp $	*/
d143 1
a143 1
 * parse and evalute expression
d162 1
a162 1
 * parse and evalute expression, storing result in vp.
d211 1
a211 1
		/* can fail if readony */
@


1.7
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.6 1999/01/19 20:41:52 millert Exp $	*/
d66 1
a66 1
	enum prec	prec;	/* precidence: lower is higher */
@


1.6
log
@Updates from pdksh-unstable-5.2.13.7.  Most notable change is:
    trap: exit traps now executed in subshells (without explicit exit call).
See the Changelog for a full list of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.5 1999/01/10 17:55:02 millert Exp $	*/
d42 1
a42 1
#define IS_BINOP(op) (((int)op) >= O_EQ && ((int)op) <= O_COMMA)
d188 1
a188 1
			if (error_ok)
d211 2
a212 2
		/* SETSTR: can't fail; if pretending, allow fail */
		setstr(vp, str_val(v));
d485 9
d564 1
a564 1
		evalerr(es, ET_LVALUE, opinfo[op].name);
d566 1
a566 1
		evalerr(es, ET_RDONLY, opinfo[op].name);
d602 1
a602 1
		v_evaluate(vq, str_val(vp), FALSE);
@


1.5
log
@sync with pdksh-unstable-5.2.13.6
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.4 1997/06/19 13:58:41 kstailey Exp $	*/
a125 1
	Expr_state *volatile prev;	/* previous state */
d131 8
a138 9
static Expr_state *es;

static void        evalerr  ARGS((enum error_type type, const char *str))
						GCC_FUNC_ATTR(noreturn);
static struct tbl *evalexpr ARGS((enum prec prec));
static void        token    ARGS((void));
static struct tbl *do_ppmm  ARGS((enum token op, struct tbl *vasn,
				  bool_t is_prefix));
static void	   assign_check ARGS((enum token op, struct tbl *vasn));
d140 1
a140 1
static struct tbl *intvar   ARGS((struct tbl *vp));
d172 1
a177 1
	curstate.prev = es;
a178 1
	es = &curstate;
a186 1
		es = curstate.prev;
d196 1
a196 1
	token();
d203 1
a203 1
	v = intvar(evalexpr(MAX_PREC));
d206 1
a206 1
		evalerr(ET_UNEXPECTED, (char *) 0);
a213 1
	es = curstate.prev;
d220 2
a221 1
evalerr(type, str)
d279 2
a280 1
evalexpr(prec)
d283 2
a284 2
	register struct tbl *vl, UNINITIALIZED(*vr), *vasn;
	register enum token op;
d292 2
a293 2
			token();
			vl = intvar(evalexpr(P_PRIMARY));
d302 2
a303 2
			token();
			vl = evalexpr(MAX_PREC);
d305 2
a306 2
				evalerr(ET_STR, "missing )");
			token();
d308 3
a310 3
			token();
			vl = do_ppmm(op, es->val, TRUE);
			token();
d313 1
a313 1
			token();
d315 1
a315 1
			evalerr(ET_UNEXPECTED, (char *) 0);
d319 2
a320 2
			vl = do_ppmm(es->tok, vl, FALSE);
			token();
d324 1
a324 1
	vl = evalexpr(((int) prec) - 1);
d328 1
a328 1
		token();
d331 1
a331 1
			vl = intvar(vl);
d333 2
a334 2
			assign_check(op, vasn);
			vr = intvar(evalexpr(P_ASSIGN));
d336 1
a336 1
			vr = intvar(evalexpr(((int) prec) - 1));
d343 1
a343 1
				evalerr(ET_STR, "zero divisor");
d407 1
a407 1
			vr = intvar(evalexpr(((int) prec) - 1));
d415 1
a415 1
			vr = intvar(evalexpr(((int) prec) - 1));
d425 1
a425 1
				vl = evalexpr(MAX_PREC);
d429 2
a430 2
					evalerr(ET_STR, "missing :");
				token();
d433 1
a433 1
				vr = evalexpr(P_TERN);
d460 2
a461 1
token()
d463 2
a464 2
	register const char *cp;
	register int c;
d482 1
a482 1
				evalerr(ET_STR, "missing ]");
d503 1
a503 1
			evalerr(ET_BADLIT, tvar);
d525 2
a526 1
do_ppmm(op, vasn, is_prefix)
d534 1
a534 1
	assign_check(op, vasn);
d536 1
a536 1
	vl = intvar(vasn);
d549 2
a550 1
assign_check(op, vasn)
d555 1
a555 1
		evalerr(ET_LVALUE, opinfo[op].name);
d557 1
a557 1
		evalerr(ET_RDONLY, opinfo[op].name);
d576 3
a578 2
intvar(vp)
	register struct tbl *vp;
d580 1
a580 1
	register struct tbl *vq;
d590 1
a590 1
			evalerr(ET_RECURSIVE, vp->name);
@


1.4
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.2 1996/08/19 20:08:50 downsj Exp $	*/
d215 1
@


1.3
log
@(foo *)0 -> NULL
@
text
@d180 1
a180 1
	curstate.evaling = NULL;
d210 1
a210 1
		evalerr(ET_UNEXPECTED, NULL);
d317 1
a317 1
			evalerr(ET_UNEXPECTED, NULL);
d593 1
a593 1
		es->evaling = NULL;
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
d180 1
a180 1
	curstate.evaling = (struct tbl *) 0;
d210 1
a210 1
		evalerr(ET_UNEXPECTED, (char *) 0);
d317 1
a317 1
			evalerr(ET_UNEXPECTED, (char *) 0);
d593 1
a593 1
		es->evaling = (struct tbl *) 0;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a7 11
 * todo: add ++ --
 * todo: recursive variable expansion (y=1;x=y; let x)
    how to deal with allowing:
	i=0
	set -A x 'x[1]' 'x[2]' 'x[3]' 99
	let z=x[i+=1]
	echo $z
	99
    and disallowing:
	x='y[x]'
	let z=x
d16 2
d19 1
a19 1
	O_EQ = 0, O_NE,
d33 1
d42 1
a42 1
#define LAST_BINOP O_TERN
d58 2
a59 1
	P_ASSIGN		/* = *= /= %= += -= <<= >>= &= ^= |= */
d61 1
a61 1
#define MAX_PREC	P_ASSIGN
d74 2
d106 1
d121 1
a121 1
	int	    noassign;		/* don't do assignments (for ?:) */
d123 3
d129 2
a130 1
enum error_type { ET_UNEXPECTED, ET_BADLIT, ET_BADVAR, ET_STR };
d138 3
d180 1
d186 3
d258 12
a269 2
	case ET_BADVAR:
		warningf(TRUE, "%s: value of variable `%s' not a number",
d309 4
d320 4
d327 3
a329 1
	while ((int) (op = es->tok) <= (int) LAST_BINOP && opinfo[(int) op].prec == prec) {
d335 1
a335 5
			if (vasn->name[0] == '\0')
				evalerr(ET_STR, "assignment to non-lvalue");
			else if (vasn->flag & RDONLY)
				evalerr(ET_STR,
					"assignment to read only variable");
d435 1
a435 1
				vr = evalexpr(MAX_PREC);
d444 3
d476 2
a477 2
		for (; letnum(c); c = *cp++)
			;
d481 1
a481 1
			len = array_ref_len(cp - 1);
d486 1
a486 1
		if (es->noassign)
d488 3
a490 2
		else {
			tvar = str_nsave(es->tokp, --cp - es->tokp, ATEMP);
d524 35
d582 1
a582 1
	    && (vp->flag & (ISSET|INTEGER)) == (ISSET|INTEGER))
a585 1
	vq->type = 0;
d587 7
a593 10
		evalerr(ET_BADVAR, vp->name);
		/*
		if ((vp->flag&ISSET) && vp->val.s && *(vp->val.s)) {
			evalerr("bad number");
		} else {
			vq->flag |= (ISSET|INTEGER);
			vq->type = 10;
			vq->val.i = 0;
		}
		*/
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
