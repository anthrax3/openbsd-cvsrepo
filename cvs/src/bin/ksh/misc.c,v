head	1.59;
access;
symbols
	OPENBSD_6_2:1.59.0.4
	OPENBSD_6_2_BASE:1.59
	OPENBSD_6_1:1.55.0.6
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.55.0.2
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.38.0.6
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.37.0.18
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.16
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.14
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.12
	OPENBSD_5_0:1.37.0.10
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.8
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.6
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.37.0.4
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.34.0.2
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.32.0.4
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.30.0.4
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.28.0.4
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.20.0.4
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.8
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.6
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.59
date	2017.08.30.17.15.36;	author jca;	state Exp;
branches;
next	1.58;
commitid	NZK5AAbZSxJJaAL8;

1.58
date	2017.08.30.17.02.53;	author jca;	state Exp;
branches;
next	1.57;
commitid	a9ziUXbpkf6RtIgW;

1.57
date	2017.07.04.11.46.15;	author anton;	state Exp;
branches;
next	1.56;
commitid	b3F6k48viABAc9JE;

1.56
date	2017.07.04.07.29.32;	author anton;	state Exp;
branches;
next	1.55;
commitid	EAU5Bw3i4umUy47M;

1.55
date	2016.03.20.00.01.21;	author krw;	state Exp;
branches;
next	1.54;
commitid	vrVXbedfAlzCTHmf;

1.54
date	2016.03.06.11.56.20;	author natano;	state Exp;
branches;
next	1.53;
commitid	78GxDpfQfjCaF98F;

1.53
date	2015.12.21.04.57.50;	author mmcc;	state Exp;
branches;
next	1.52;
commitid	z6N1HgC18GjYD7GZ;

1.52
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.51;
commitid	btTCreDA00YdaFhU;

1.51
date	2015.11.12.04.04.31;	author mmcc;	state Exp;
branches;
next	1.50;
commitid	QvyWaajN4Lc4MRtd;

1.50
date	2015.10.19.17.15.53;	author mmcc;	state Exp;
branches;
next	1.49;
commitid	zuJ55EJoQ0lgfTwv;

1.49
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.48;
commitid	C4W85jmosThChWA2;

1.48
date	2015.10.19.14.03.21;	author mmcc;	state Exp;
branches;
next	1.47;
commitid	TSZF0K3aGmPbKQzz;

1.47
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.46;
commitid	16HUr75moyUNtKR8;

1.46
date	2015.09.22.21.50.40;	author millert;	state Exp;
branches;
next	1.45;
commitid	ZWmS69dzJnkF6rox;

1.45
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.44;
commitid	7fgq4YTZG4xZ0uN0;

1.44
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.43;
commitid	v5QjoxUgKU2iUTFz;

1.43
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.42;
commitid	lBs9un9sXhbdfVrQ;

1.42
date	2015.09.15.18.07.22;	author tedu;	state Exp;
branches;
next	1.41;
commitid	a9KLxOATj99CUewS;

1.41
date	2015.09.10.22.48.58;	author nicm;	state Exp;
branches;
next	1.40;
commitid	stJ3KRI2o7F5OBtF;

1.40
date	2015.03.18.15.12.36;	author tedu;	state Exp;
branches;
next	1.39;
commitid	WIAG2DVbHJYATHd8;

1.39
date	2015.01.16.06.39.32;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	Uu5nFG3wCl0LACBb;

1.38
date	2013.11.28.10.33.37;	author sobrado;	state Exp;
branches;
next	1.37;

1.37
date	2009.04.19.20.34.05;	author sthen;	state Exp;
branches;
next	1.36;

1.36
date	2009.03.03.20.01.01;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2009.01.17.22.06.44;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2008.07.12.12.33.42;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2008.03.21.12.51.19;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2007.08.02.11.05.54;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.02.10.56.25;	author fgsch;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.12.00.26.58;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.06.10.44.10;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.28.21.28.22;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.22.17.18.51;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.12.06.53.13;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.22.07.40.38;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.01.15.47.40;	author naddy;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.06.21.08.05;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.05.20.52.27;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.16.23.11.52;	author tdeval;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.04.23.12.02;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.13.09.03.07;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.19.09.49.53;	author camield;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.28.20.36.37;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	99.06.15.01.18.35;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.01.08.20.25.01;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.10.29.04.09.21;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.06.25.19.02.11;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.06.19.13.58.45;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.06.18.22.42.40;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.01.02.09.34.07;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.12.22.02.57.49;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.57;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.59
log
@Guard FEMACSUSEMETA uses behind #ifdef EMACS
@
text
@/*	$OpenBSD: misc.c,v 1.58 2017/08/30 17:02:53 jca Exp $	*/

/*
 * Miscellaneous functions
 */

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "sh.h"
#include "charclass.h"

short ctypes [UCHAR_MAX+1];	/* type bits for unsigned char */

static int	do_gmatch(const unsigned char *, const unsigned char *,
		    const unsigned char *, const unsigned char *);
static const unsigned char *cclass(const unsigned char *, int);

/*
 * Fast character classes
 */
void
setctypes(const char *s, int t)
{
	int i;

	if (t & C_IFS) {
		for (i = 0; i < UCHAR_MAX+1; i++)
			ctypes[i] &= ~C_IFS;
		ctypes[0] |= C_IFS; /* include \0 in C_IFS */
	}
	while (*s != 0)
		ctypes[(unsigned char) *s++] |= t;
}

void
initctypes(void)
{
	int c;

	for (c = 'a'; c <= 'z'; c++)
		ctypes[c] |= C_ALPHA;
	for (c = 'A'; c <= 'Z'; c++)
		ctypes[c] |= C_ALPHA;
	ctypes['_'] |= C_ALPHA;
	setctypes(" \t\n|&;<>()", C_LEX1); /* \0 added automatically */
	setctypes("*@@#!$-?", C_VAR1);
	setctypes(" \t\n", C_IFSWS);
	setctypes("=-+?", C_SUBOP1);
	setctypes("#%", C_SUBOP2);
	setctypes(" \n\t\"#$&'()*;<>?[\\`|", C_QUOTE);
}

/* convert unsigned long to base N string */

char *
ulton(long unsigned int n, int base)
{
	char *p;
	static char buf [20];

	p = &buf[sizeof(buf)];
	*--p = '\0';
	do {
		*--p = "0123456789ABCDEF"[n%base];
		n /= base;
	} while (n != 0);
	return p;
}

char *
str_save(const char *s, Area *ap)
{
	size_t len;
	char *p;

	if (!s)
		return NULL;
	len = strlen(s)+1;
	p = alloc(len, ap);
	strlcpy(p, s, len);
	return (p);
}

/* Allocate a string of size n+1 and copy upto n characters from the possibly
 * null terminated string s into it.  Always returns a null terminated string
 * (unless n < 0).
 */
char *
str_nsave(const char *s, int n, Area *ap)
{
	char *ns;

	if (n < 0)
		return 0;
	ns = alloc(n + 1, ap);
	ns[0] = '\0';
	return strncat(ns, s, n);
}

/* called from expand.h:XcheckN() to grow buffer */
char *
Xcheck_grow_(XString *xsp, char *xp, int more)
{
	char *old_beg = xsp->beg;

	xsp->len += more > xsp->len ? more : xsp->len;
	xsp->beg = aresize(xsp->beg, xsp->len + 8, xsp->areap);
	xsp->end = xsp->beg + xsp->len;
	return xsp->beg + (xp - old_beg);
}

const struct option options[] = {
	/* Special cases (see parse_args()): -A, -o, -s.
	 * Options are sorted by their longnames - the order of these
	 * entries MUST match the order of sh_flag F* enumerations in sh.h.
	 */
	{ "allexport",	'a',		OF_ANY },
#ifdef BRACE_EXPAND
	{ "braceexpand",  0,		OF_ANY }, /* non-standard */
#endif
	{ "bgnice",	  0,		OF_ANY },
	{ NULL,	'c',	    OF_CMDLINE },
	{ "csh-history",  0,		OF_ANY }, /* non-standard */
#ifdef EMACS
	{ "emacs",	  0,		OF_ANY },
	{ "emacs-usemeta",  0,		OF_ANY }, /* XXX delete after 6.2 */
#endif
	{ "errexit",	'e',		OF_ANY },
#ifdef EMACS
	{ "gmacs",	  0,		OF_ANY },
#endif
	{ "ignoreeof",	  0,		OF_ANY },
	{ "interactive",'i',	    OF_CMDLINE },
	{ "keyword",	'k',		OF_ANY },
	{ "login",	'l',	    OF_CMDLINE },
	{ "markdirs",	'X',		OF_ANY },
#ifdef JOBS
	{ "monitor",	'm',		OF_ANY },
#else /* JOBS */
	{ NULL,	'm',		     0 }, /* so FMONITOR not ifdef'd */
#endif /* JOBS */
	{ "noclobber",	'C',		OF_ANY },
	{ "noexec",	'n',		OF_ANY },
	{ "noglob",	'f',		OF_ANY },
	{ "nohup",	  0,		OF_ANY },
	{ "nolog",	  0,		OF_ANY }, /* no effect */
#ifdef	JOBS
	{ "notify",	'b',		OF_ANY },
#endif	/* JOBS */
	{ "nounset",	'u',		OF_ANY },
	{ "physical",	  0,		OF_ANY }, /* non-standard */
	{ "posix",	  0,		OF_ANY }, /* non-standard */
	{ "privileged",	'p',		OF_ANY },
	{ "restricted",	'r',	    OF_CMDLINE },
	{ "sh",		  0,		OF_ANY }, /* non-standard */
	{ "stdin",	's',	    OF_CMDLINE }, /* pseudo non-standard */
	{ "trackall",	'h',		OF_ANY },
	{ "verbose",	'v',		OF_ANY },
#ifdef VI
	{ "vi",		  0,		OF_ANY },
	{ "viraw",	  0,		OF_ANY }, /* no effect */
	{ "vi-show8",	  0,		OF_ANY }, /* non-standard */
	{ "vi-tabcomplete",  0,		OF_ANY }, /* non-standard */
	{ "vi-esccomplete",  0,		OF_ANY }, /* non-standard */
#endif
	{ "xtrace",	'x',		OF_ANY },
	/* Anonymous flags: used internally by shell only
	 * (not visible to user)
	 */
	{ NULL,	0,		OF_INTERNAL }, /* FTALKING_I */
};

/*
 * translate -o option into F* constant (also used for test -o option)
 */
int
option(const char *n)
{
	int i;

	for (i = 0; i < NELEM(options); i++)
		if (options[i].name && strcmp(options[i].name, n) == 0) {
#ifdef EMACS
			if (i == FEMACSUSEMETA)
				warningf(true, "%s: deprecated option", n);
#endif
			return i;
		}

	return -1;
}

struct options_info {
	int opt_width;
	struct {
		const char *name;
		int	flag;
	} opts[NELEM(options)];
};

static char *options_fmt_entry(void *arg, int i, char *buf, int buflen);
static void printoptions(int verbose);

/* format a single select menu item */
static char *
options_fmt_entry(void *arg, int i, char *buf, int buflen)
{
	struct options_info *oi = (struct options_info *) arg;

	shf_snprintf(buf, buflen, "%-*s %s",
	    oi->opt_width, oi->opts[i].name,
	    Flag(oi->opts[i].flag) ? "on" : "off");
	return buf;
}

static void
printoptions(int verbose)
{
	int i;

	if (verbose) {
		struct options_info oi;
		int n, len;

		/* verbose version */
		shprintf("Current option settings\n");

		for (i = n = oi.opt_width = 0; i < NELEM(options); i++) {
#ifdef EMACS
			if (i == FEMACSUSEMETA)
				continue;
#endif
			if (options[i].name) {
				len = strlen(options[i].name);
				oi.opts[n].name = options[i].name;
				oi.opts[n++].flag = i;
				if (len > oi.opt_width)
					oi.opt_width = len;
			}
		}
		print_columns(shl_stdout, n, options_fmt_entry, &oi,
		    oi.opt_width + 5, 1);
	} else {
		/* short version ala ksh93 */
		shprintf("set");
		for (i = 0; i < NELEM(options); i++) {
#ifdef EMACS
			if (i == FEMACSUSEMETA)
				continue;
#endif
			if (options[i].name)
				shprintf(" %co %s",
					 Flag(i) ? '-' : '+',
					 options[i].name);
		}
		shprintf("\n");
	}
}

char *
getoptions(void)
{
	int i;
	char m[(int) FNFLAGS + 1];
	char *cp = m;

	for (i = 0; i < NELEM(options); i++)
		if (options[i].c && Flag(i))
			*cp++ = options[i].c;
	*cp = 0;
	return str_save(m, ATEMP);
}

/* change a Flag(*) value; takes care of special actions */
void
change_flag(enum sh_flag f,
    int what,		/* flag to change */
    int newval)		/* what is changing the flag (command line vs set) */
{
	int oldval;

	oldval = Flag(f);
	Flag(f) = newval;
#ifdef JOBS
	if (f == FMONITOR) {
		if (what != OF_CMDLINE && newval != oldval)
			j_change();
	} else
#endif /* JOBS */
#ifdef EDIT
	if (0
# ifdef VI
	    || f == FVI
# endif /* VI */
# ifdef EMACS
	    || f == FEMACS || f == FGMACS
# endif /* EMACS */
	   )
	{
		if (newval) {
# ifdef VI
			Flag(FVI) = 0;
# endif /* VI */
# ifdef EMACS
			Flag(FEMACS) = Flag(FGMACS) = 0;
# endif /* EMACS */
			Flag(f) = newval;
		}
	} else
#endif /* EDIT */
	/* Turning off -p? */
	if (f == FPRIVILEGED && oldval && !newval) {
		gid_t gid = getgid();

		setresgid(gid, gid, gid);
		setgroups(1, &gid);
		setresuid(ksheuid, ksheuid, ksheuid);
	} else if (f == FPOSIX && newval) {
#ifdef BRACE_EXPAND
		Flag(FBRACEEXPAND) = 0
#endif /* BRACE_EXPAND */
		;
	}
	/* Changing interactive flag? */
	if (f == FTALKING) {
		if ((what == OF_CMDLINE || what == OF_SET) && procpid == kshpid)
			Flag(FTALKING_I) = newval;
	}
}

/* parse command line & set command arguments.  returns the index of
 * non-option arguments, -1 if there is an error.
 */
int
parse_args(char **argv,
    int what,			/* OF_CMDLINE or OF_SET */
    int *setargsp)
{
	static char cmd_opts[NELEM(options) + 3]; /* o:\0 */
	static char set_opts[NELEM(options) + 5]; /* Ao;s\0 */
	char *opts;
	char *array = NULL;
	Getopt go;
	int i, optc, set, sortargs = 0, arrayset = 0;

	/* First call?  Build option strings... */
	if (cmd_opts[0] == '\0') {
		char *p, *q;

		/* see cmd_opts[] declaration */
		strlcpy(cmd_opts, "o:", sizeof cmd_opts);
		p = cmd_opts + strlen(cmd_opts);
		/* see set_opts[] declaration */
		strlcpy(set_opts, "A:o;s", sizeof set_opts);
		q = set_opts + strlen(set_opts);
		for (i = 0; i < NELEM(options); i++) {
			if (options[i].c) {
				if (options[i].flags & OF_CMDLINE)
					*p++ = options[i].c;
				if (options[i].flags & OF_SET)
					*q++ = options[i].c;
			}
		}
		*p = '\0';
		*q = '\0';
	}

	if (what == OF_CMDLINE) {
		char *p;
		/* Set FLOGIN before parsing options so user can clear
		 * flag using +l.
		 */
		Flag(FLOGIN) = (argv[0][0] == '-' ||
		    ((p = strrchr(argv[0], '/')) && *++p == '-'));
		opts = cmd_opts;
	} else
		opts = set_opts;
	ksh_getopt_reset(&go, GF_ERROR|GF_PLUSOPT);
	while ((optc = ksh_getopt(argv, &go, opts)) != -1) {
		set = (go.info & GI_PLUS) ? 0 : 1;
		switch (optc) {
		case 'A':
			arrayset = set ? 1 : -1;
			array = go.optarg;
			break;

		case 'o':
			if (go.optarg == NULL) {
				/* lone -o: print options
				 *
				 * Note that on the command line, -o requires
				 * an option (ie, can't get here if what is
				 * OF_CMDLINE).
				 */
				printoptions(set);
				break;
			}
			i = option(go.optarg);
			if (i >= 0 && set == Flag(i))
				/* Don't check the context if the flag
				 * isn't changing - makes "set -o interactive"
				 * work if you're already interactive.  Needed
				 * if the output of "set +o" is to be used.
				 */
				;
			else if (i >= 0 && (options[i].flags & what))
				change_flag((enum sh_flag) i, what, set);
			else {
				bi_errorf("%s: bad option", go.optarg);
				return -1;
			}
			break;

		case '?':
			return -1;

		default:
			/* -s: sort positional params (at&t ksh stupidity) */
			if (what == OF_SET && optc == 's') {
				sortargs = 1;
				break;
			}
			for (i = 0; i < NELEM(options); i++)
				if (optc == options[i].c &&
				    (what & options[i].flags)) {
					change_flag((enum sh_flag) i, what,
					    set);
					break;
				}
			if (i == NELEM(options)) {
				internal_errorf(1, "parse_args: `%c'", optc);
				return -1; /* not reached */
			}
		}
	}
	if (!(go.info & GI_MINUSMINUS) && argv[go.optind] &&
	    (argv[go.optind][0] == '-' || argv[go.optind][0] == '+') &&
	    argv[go.optind][1] == '\0') {
		/* lone - clears -v and -x flags */
		if (argv[go.optind][0] == '-' && !Flag(FPOSIX))
			Flag(FVERBOSE) = Flag(FXTRACE) = 0;
		/* set skips lone - or + option */
		go.optind++;
	}
	if (setargsp)
		/* -- means set $#/$* even if there are no arguments */
		*setargsp = !arrayset && ((go.info & GI_MINUSMINUS) ||
		    argv[go.optind]);

	if (arrayset && (!*array || *skip_varname(array, false))) {
		bi_errorf("%s: is not an identifier", array);
		return -1;
	}
	if (sortargs) {
		for (i = go.optind; argv[i]; i++)
			;
		qsortp((void **) &argv[go.optind], (size_t) (i - go.optind),
		    xstrcmp);
	}
	if (arrayset) {
		set_array(array, arrayset, argv + go.optind);
		for (; argv[go.optind]; go.optind++)
			;
	}

	return go.optind;
}

/* parse a decimal number: returns 0 if string isn't a number, 1 otherwise */
int
getn(const char *as, int *ai)
{
	char *p;
	long n;

	n = strtol(as, &p, 10);

	if (!*as || *p || INT_MIN >= n || n >= INT_MAX)
		return 0;

	*ai = (int)n;
	return 1;
}

/* getn() that prints error */
int
bi_getn(const char *as, int *ai)
{
	int rv = getn(as, ai);

	if (!rv)
		bi_errorf("%s: bad number", as);
	return rv;
}

/* -------- gmatch.c -------- */

/*
 * int gmatch(string, pattern)
 * char *string, *pattern;
 *
 * Match a pattern as in sh(1).
 * pattern character are prefixed with MAGIC by expand.
 */

int
gmatch(const char *s, const char *p, int isfile)
{
	const char *se, *pe;

	if (s == NULL || p == NULL)
		return 0;
	se = s + strlen(s);
	pe = p + strlen(p);
	/* isfile is false iff no syntax check has been done on
	 * the pattern.  If check fails, just to a strcmp().
	 */
	if (!isfile && !has_globbing(p, pe)) {
		int len = pe - p + 1;
		char tbuf[64];
		char *t = len <= sizeof(tbuf) ? tbuf :
		    alloc(len, ATEMP);
		debunk(t, p, len);
		return !strcmp(t, s);
	}
	return do_gmatch((const unsigned char *) s, (const unsigned char *) se,
	    (const unsigned char *) p, (const unsigned char *) pe);
}

/* Returns if p is a syntacticly correct globbing pattern, false
 * if it contains no pattern characters or if there is a syntax error.
 * Syntax errors are:
 *	- [ with no closing ]
 *	- imbalanced $(...) expression
 *	- [...] and *(...) not nested (eg, [a$(b|]c), *(a[b|c]d))
 */
/*XXX
- if no magic,
	if dest given, copy to dst
	return ?
- if magic && (no globbing || syntax error)
	debunk to dst
	return ?
- return ?
*/
int
has_globbing(const char *xp, const char *xpe)
{
	const unsigned char *p = (const unsigned char *) xp;
	const unsigned char *pe = (const unsigned char *) xpe;
	int c;
	int nest = 0, bnest = 0;
	int saw_glob = 0;
	int in_bracket = 0; /* inside [...] */

	for (; p < pe; p++) {
		if (!ISMAGIC(*p))
			continue;
		if ((c = *++p) == '*' || c == '?')
			saw_glob = 1;
		else if (c == '[') {
			if (!in_bracket) {
				saw_glob = 1;
				in_bracket = 1;
				if (ISMAGIC(p[1]) && p[2] == '!')
					p += 2;
				if (ISMAGIC(p[1]) && p[2] == ']')
					p += 2;
			}
			/* XXX Do we need to check ranges here? POSIX Q */
		} else if (c == ']') {
			if (in_bracket) {
				if (bnest)		/* [a*(b]) */
					return 0;
				in_bracket = 0;
			}
		} else if ((c & 0x80) && strchr("*+?@@! ", c & 0x7f)) {
			saw_glob = 1;
			if (in_bracket)
				bnest++;
			else
				nest++;
		} else if (c == '|') {
			if (in_bracket && !bnest)	/* *(a[foo|bar]) */
				return 0;
		} else if (c == /*(*/ ')') {
			if (in_bracket) {
				if (!bnest--)		/* *(a[b)c] */
					return 0;
			} else if (nest)
				nest--;
		}
		/* else must be a MAGIC-MAGIC, or MAGIC-!, MAGIC--, MAGIC-]
			 MAGIC-{, MAGIC-,, MAGIC-} */
	}
	return saw_glob && !in_bracket && !nest;
}

/* Function must return either 0 or 1 (assumed by code for 0x80|'!') */
static int
do_gmatch(const unsigned char *s, const unsigned char *se,
    const unsigned char *p, const unsigned char *pe)
{
	int sc, pc;
	const unsigned char *prest, *psub, *pnext;
	const unsigned char *srest;

	if (s == NULL || p == NULL)
		return 0;
	while (p < pe) {
		pc = *p++;
		sc = s < se ? *s : '\0';
		s++;
		if (!ISMAGIC(pc)) {
			if (sc != pc)
				return 0;
			continue;
		}
		switch (*p++) {
		case '[':
			if (sc == 0 || (p = cclass(p, sc)) == NULL)
				return 0;
			break;

		case '?':
			if (sc == 0)
				return 0;
			break;

		case '*':
			if (p == pe)
				return 1;
			s--;
			do {
				if (do_gmatch(s, se, p, pe))
					return 1;
			} while (s++ < se);
			return 0;

		  /*
		   * [*+?@@!](pattern|pattern|..)
		   *
		   * Not ifdef'd KSH as this is needed for ${..%..}, etc.
		   */
		case 0x80|'+': /* matches one or more times */
		case 0x80|'*': /* matches zero or more times */
			if (!(prest = pat_scan(p, pe, 0)))
				return 0;
			s--;
			/* take care of zero matches */
			if (p[-1] == (0x80 | '*') &&
			    do_gmatch(s, se, prest, pe))
				return 1;
			for (psub = p; ; psub = pnext) {
				pnext = pat_scan(psub, pe, 1);
				for (srest = s; srest <= se; srest++) {
					if (do_gmatch(s, srest, psub, pnext - 2) &&
					    (do_gmatch(srest, se, prest, pe) ||
					    (s != srest && do_gmatch(srest,
					    se, p - 2, pe))))
						return 1;
				}
				if (pnext == prest)
					break;
			}
			return 0;

		case 0x80|'?': /* matches zero or once */
		case 0x80|'@@': /* matches one of the patterns */
		case 0x80|' ': /* simile for @@ */
			if (!(prest = pat_scan(p, pe, 0)))
				return 0;
			s--;
			/* Take care of zero matches */
			if (p[-1] == (0x80 | '?') &&
			    do_gmatch(s, se, prest, pe))
				return 1;
			for (psub = p; ; psub = pnext) {
				pnext = pat_scan(psub, pe, 1);
				srest = prest == pe ? se : s;
				for (; srest <= se; srest++) {
					if (do_gmatch(s, srest, psub, pnext - 2) &&
					    do_gmatch(srest, se, prest, pe))
						return 1;
				}
				if (pnext == prest)
					break;
			}
			return 0;

		case 0x80|'!': /* matches none of the patterns */
			if (!(prest = pat_scan(p, pe, 0)))
				return 0;
			s--;
			for (srest = s; srest <= se; srest++) {
				int matched = 0;

				for (psub = p; ; psub = pnext) {
					pnext = pat_scan(psub, pe, 1);
					if (do_gmatch(s, srest, psub,
					    pnext - 2)) {
						matched = 1;
						break;
					}
					if (pnext == prest)
						break;
				}
				if (!matched &&
				    do_gmatch(srest, se, prest, pe))
					return 1;
			}
			return 0;

		default:
			if (sc != p[-1])
				return 0;
			break;
		}
	}
	return s == se;
}

static int
posix_cclass(const unsigned char *pattern, int test, const unsigned char **ep)
{
	struct cclass *cc;
	const unsigned char *colon;
	size_t len;
	int rval = 0;

	if ((colon = strchr(pattern, ':')) == NULL || colon[1] != MAGIC) {
		*ep = pattern - 2;
		return -1;
	}
	*ep = colon + 3; /* skip MAGIC */
	len = (size_t)(colon - pattern);

	for (cc = cclasses; cc->name != NULL; cc++) {
		if (!strncmp(pattern, cc->name, len) && cc->name[len] == '\0') {
			if (cc->isctype(test))
				rval = 1;
			break;
		}
	}
	if (cc->name == NULL) {
		rval = -2;	/* invalid character class */
	}
	return rval;
}

static const unsigned char *
cclass(const unsigned char *p, int sub)
{
	int c, d, rv, not, found = 0;
	const unsigned char *orig_p = p;

	if ((not = (ISMAGIC(*p) && *++p == '!')))
		p++;
	do {
		/* check for POSIX character class (e.g. [[:alpha:]]) */
		if ((p[0] == MAGIC && p[1] == '[' && p[2] == ':') ||
		    (p[0] == '[' && p[1] == ':')) {
			do {
				const char *pp = p + (*p == MAGIC) + 2;
				rv = posix_cclass(pp, sub, &p);
				switch (rv) {
				case 1:
					found = 1;
					break;
				case -2:
					return NULL;
				}
			} while (rv != -1 && p[0] == MAGIC && p[1] == '[' && p[2] == ':');
			if (p[0] == MAGIC && p[1] == ']')
				break;
		}

		c = *p++;
		if (ISMAGIC(c)) {
			c = *p++;
			if ((c & 0x80) && !ISMAGIC(c)) {
				c &= 0x7f;/* extended pattern matching: *+?@@! */
				/* XXX the ( char isn't handled as part of [] */
				if (c == ' ') /* simile for @@: plain (..) */
					c = '(' /*)*/;
			}
		}
		if (c == '\0')
			/* No closing ] - act as if the opening [ was quoted */
			return sub == '[' ? orig_p : NULL;
		if (ISMAGIC(p[0]) && p[1] == '-' &&
		    (!ISMAGIC(p[2]) || p[3] != ']')) {
			p += 2; /* MAGIC- */
			d = *p++;
			if (ISMAGIC(d)) {
				d = *p++;
				if ((d & 0x80) && !ISMAGIC(d))
					d &= 0x7f;
			}
			/* POSIX says this is an invalid expression */
			if (c > d)
				return NULL;
		} else
			d = c;
		if (c == sub || (c <= sub && sub <= d))
			found = 1;
	} while (!(ISMAGIC(p[0]) && p[1] == ']'));

	return (found != not) ? p+2 : NULL;
}

/* Look for next ) or | (if match_sep) in *(foo|bar) pattern */
const unsigned char *
pat_scan(const unsigned char *p, const unsigned char *pe, int match_sep)
{
	int nest = 0;

	for (; p < pe; p++) {
		if (!ISMAGIC(*p))
			continue;
		if ((*++p == /*(*/ ')' && nest-- == 0) ||
		    (*p == '|' && match_sep && nest == 0))
			return ++p;
		if ((*p & 0x80) && strchr("*+?@@! ", *p & 0x7f))
			nest++;
	}
	return NULL;
}

/*
 * quick sort of array of generic pointers to objects.
 */
void
qsortp(void **base,			/* base address */
    size_t n,				/* elements */
    int (*f) (const void *, const void *)) /* compare function */
{
	qsort(base, n, sizeof(char *), f);
}

int
xstrcmp(const void *p1, const void *p2)
{
	return (strcmp(*(char **)p1, *(char **)p2));
}

/* Initialize a Getopt structure */
void
ksh_getopt_reset(Getopt *go, int flags)
{
	go->optind = 1;
	go->optarg = NULL;
	go->p = 0;
	go->flags = flags;
	go->info = 0;
	go->buf[1] = '\0';
}


/* getopt() used for shell built-in commands, the getopts command, and
 * command line options.
 * A leading ':' in options means don't print errors, instead return '?'
 * or ':' and set go->optarg to the offending option character.
 * If GF_ERROR is set (and option doesn't start with :), errors result in
 * a call to bi_errorf().
 *
 * Non-standard features:
 *	- ';' is like ':' in options, except the argument is optional
 *	  (if it isn't present, optarg is set to 0).
 *	  Used for 'set -o'.
 *	- ',' is like ':' in options, except the argument always immediately
 *	  follows the option character (optarg is set to the null string if
 *	  the option is missing).
 *	  Used for 'read -u2', 'print -u2' and fc -40.
 *	- '#' is like ':' in options, expect that the argument is optional
 *	  and must start with a digit or be the string "unlimited".  If the
 *	  argument doesn't match, it is assumed to be missing and normal option
 *	  processing continues (optarg is set to 0 if the option is missing).
 *	  Used for 'typeset -LZ4' and 'ulimit -adunlimited'.
 *	- accepts +c as well as -c IF the GF_PLUSOPT flag is present.  If an
 *	  option starting with + is accepted, the GI_PLUS flag will be set
 *	  in go->info.
 */
int
ksh_getopt(char **argv, Getopt *go, const char *options)
{
	char c;
	char *o;

	if (go->p == 0 || (c = argv[go->optind - 1][go->p]) == '\0') {
		char *arg = argv[go->optind], flag = arg ? *arg : '\0';

		go->p = 1;
		if (flag == '-' && arg[1] == '-' && arg[2] == '\0') {
			go->optind++;
			go->p = 0;
			go->info |= GI_MINUSMINUS;
			return -1;
		}
		if (arg == NULL ||
		    ((flag != '-' ) && /* neither a - nor a + (if + allowed) */
		    (!(go->flags & GF_PLUSOPT) || flag != '+')) ||
		    (c = arg[1]) == '\0') {
			go->p = 0;
			return -1;
		}
		go->optind++;
		go->info &= ~(GI_MINUS|GI_PLUS);
		go->info |= flag == '-' ? GI_MINUS : GI_PLUS;
	}
	go->p++;
	if (c == '?' || c == ':' || c == ';' || c == ',' || c == '#' ||
	    !(o = strchr(options, c))) {
		if (options[0] == ':') {
			go->buf[0] = c;
			go->optarg = go->buf;
		} else {
			warningf(true, "%s%s-%c: unknown option",
			    (go->flags & GF_NONAME) ? "" : argv[0],
			    (go->flags & GF_NONAME) ? "" : ": ", c);
			if (go->flags & GF_ERROR)
				bi_errorf(NULL);
		}
		return '?';
	}
	/* : means argument must be present, may be part of option argument
	 *   or the next argument
	 * ; same as : but argument may be missing
	 * , means argument is part of option argument, and may be null.
	 */
	if (*++o == ':' || *o == ';') {
		if (argv[go->optind - 1][go->p])
			go->optarg = argv[go->optind - 1] + go->p;
		else if (argv[go->optind])
			go->optarg = argv[go->optind++];
		else if (*o == ';')
			go->optarg = NULL;
		else {
			if (options[0] == ':') {
				go->buf[0] = c;
				go->optarg = go->buf;
				return ':';
			}
			warningf(true, "%s%s-`%c' requires argument",
			    (go->flags & GF_NONAME) ? "" : argv[0],
			    (go->flags & GF_NONAME) ? "" : ": ", c);
			if (go->flags & GF_ERROR)
				bi_errorf(NULL);
			return '?';
		}
		go->p = 0;
	} else if (*o == ',') {
		/* argument is attached to option character, even if null */
		go->optarg = argv[go->optind - 1] + go->p;
		go->p = 0;
	} else if (*o == '#') {
		/* argument is optional and may be attached or unattached
		 * but must start with a digit.  optarg is set to 0 if the
		 * argument is missing.
		 */
		if (argv[go->optind - 1][go->p]) {
			if (digit(argv[go->optind - 1][go->p]) ||
			    !strcmp(&argv[go->optind - 1][go->p], "unlimited")) {
				go->optarg = argv[go->optind - 1] + go->p;
				go->p = 0;
			} else
				go->optarg = NULL;
		} else {
			if (argv[go->optind] && (digit(argv[go->optind][0]) ||
			    !strcmp(argv[go->optind], "unlimited"))) {
				go->optarg = argv[go->optind++];
				go->p = 0;
			} else
				go->optarg = NULL;
		}
	}
	return c;
}

/* print variable/alias value using necessary quotes
 * (POSIX says they should be suitable for re-entry...)
 * No trailing newline is printed.
 */
void
print_value_quoted(const char *s)
{
	const char *p;
	int inquote = 0;

	/* Test if any quotes are needed */
	for (p = s; *p; p++)
		if (ctype(*p, C_QUOTE))
			break;
	if (!*p) {
		shprintf("%s", s);
		return;
	}
	for (p = s; *p; p++) {
		if (*p == '\'') {
			shprintf(inquote ? "'\\'" : "\\'");
			inquote = 0;
		} else {
			if (!inquote) {
				shprintf("'");
				inquote = 1;
			}
			shf_putc(*p, shl_stdout);
		}
	}
	if (inquote)
		shprintf("'");
}

/* Print things in columns and rows - func() is called to format the ith
 * element
 */
void
print_columns(struct shf *shf, int n, char *(*func) (void *, int, char *, int),
    void *arg, int max_width, int prefcol)
{
	char *str = alloc(max_width + 1, ATEMP);
	int i;
	int r, c;
	int rows, cols;
	int nspace;
	int col_width;

	/* max_width + 1 for the space.  Note that no space
	 * is printed after the last column to avoid problems
	 * with terminals that have auto-wrap.
	 */
	cols = x_cols / (max_width + 1);
	if (!cols)
		cols = 1;
	rows = (n + cols - 1) / cols;
	if (prefcol && n && cols > rows) {
		int tmp = rows;

		rows = cols;
		cols = tmp;
		if (rows > n)
			rows = n;
	}

	col_width = max_width;
	if (cols == 1)
		col_width = 0; /* Don't pad entries in single column output. */
	nspace = (x_cols - max_width * cols) / cols;
	if (nspace <= 0)
		nspace = 1;
	for (r = 0; r < rows; r++) {
		for (c = 0; c < cols; c++) {
			i = c * rows + r;
			if (i < n) {
				shf_fprintf(shf, "%-*s",
				    col_width,
				    (*func)(arg, i, str, max_width + 1));
				if (c + 1 < cols)
					shf_fprintf(shf, "%*s", nspace, "");
			}
		}
		shf_putchar('\n', shf);
	}
	afree(str, ATEMP);
}

/* Strip any nul bytes from buf - returns new length (nbytes - # of nuls) */
int
strip_nuls(char *buf, int nbytes)
{
	char *dst;

	if ((dst = memchr(buf, '\0', nbytes))) {
		char *end = buf + nbytes;
		char *p, *q;

		for (p = dst; p < end; p = q) {
			/* skip a block of nulls */
			while (++p < end && *p == '\0')
				;
			/* find end of non-null block */
			if (!(q = memchr(p, '\0', end - p)))
				q = end;
			memmove(dst, p, q - p);
			dst += q - p;
		}
		*dst = '\0';
		return dst - buf;
	}
	return nbytes;
}

/* Like read(2), but if read fails due to non-blocking flag, resets flag
 * and restarts read.
 */
int
blocking_read(int fd, char *buf, int nbytes)
{
	int ret;
	int tried_reset = 0;

	while ((ret = read(fd, buf, nbytes)) < 0) {
		if (!tried_reset && errno == EAGAIN) {
			int oerrno = errno;
			if (reset_nonblock(fd) > 0) {
				tried_reset = 1;
				continue;
			}
			errno = oerrno;
		}
		break;
	}
	return ret;
}

/* Reset the non-blocking flag on the specified file descriptor.
 * Returns -1 if there was an error, 0 if non-blocking wasn't set,
 * 1 if it was.
 */
int
reset_nonblock(int fd)
{
	int flags;

	if ((flags = fcntl(fd, F_GETFL)) < 0)
		return -1;
	if (!(flags & O_NONBLOCK))
		return 0;
	flags &= ~O_NONBLOCK;
	if (fcntl(fd, F_SETFL, flags) < 0)
		return -1;
	return 1;
}


/* Like getcwd(), except bsize is ignored if buf is 0 (PATH_MAX is used) */
char *
ksh_get_wd(char *buf, int bsize)
{
	char *b;
	char *ret;

	/* Note: we could just use plain getcwd(), but then we'd had to
	 * inject possibly allocated space into the ATEMP area. */
	/* Assume getcwd() available */
	if (!buf) {
		bsize = PATH_MAX;
		b = alloc(PATH_MAX + 1, ATEMP);
	} else
		b = buf;

	ret = getcwd(b, bsize);

	if (!buf) {
		if (ret)
			ret = aresize(b, strlen(b) + 1, ATEMP);
		else
			afree(b, ATEMP);
	}

	return ret;
}
@


1.58
log
@Stop exposing the emacs-usemeta option, and warn when trying to set it.

Unused since 2012, to be removed after 6.2.  Input from anton@@,
ok anton@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.57 2017/07/04 11:46:15 anton Exp $	*/
d189 1
d192 1
d235 1
d238 1
d253 1
d256 1
@


1.57
log
@Backout previous due to a bug discovered by zhuk@@ that requires some tinkering
and is not an easy fix for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.56 2017/07/04 07:29:32 anton Exp $	*/
d132 1
a132 1
	{ "emacs-usemeta",  0,		OF_ANY }, /* non-standard */
d188 3
a190 1
		if (options[i].name && strcmp(options[i].name, n) == 0)
d192 1
d232 3
a234 1
		for (i = n = oi.opt_width = 0; i < NELEM(options); i++)
d242 1
d248 3
a250 1
		for (i = 0; i < NELEM(options); i++)
d255 1
@


1.56
log
@Add support for pattern substitution to variables in ksh using a common syntax
borrowed from ksh93.

Survived a ports build performed by naddy@@ and encouraged by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.55 2016/03/20 00:01:21 krw Exp $	*/
d55 1
a55 1
	setctypes("#%/", C_SUBOP2);
a518 13
}

int
gnmatch(char *s, size_t n, const char *p, int isfile)
{
	int	c, match;

	c = s[n];
	s[n] = '\0';
	match = gmatch(s, p, isfile);
	s[n] = c;

	return match;
@


1.55
log
@Currently we have about a 50/50 split over fcntl(n, F_GETFL [,0])
idioms.

Adopt the more concise fcntl(n, F_GETFL) over fcntl(n, F_GETFL, 0)
where it is obvious further investigation will not yield and
even better way.

Obviousness evaluation and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.54 2016/03/06 11:56:20 natano Exp $	*/
d55 1
a55 1
	setctypes("#%", C_SUBOP2);
d519 13
@


1.54
log
@Make set +o conform with POSIX.

It should be possible to use set +o to save the current shell options,
then modify them at will and later restore them to the saved value.
Therefore the output must not only contain the options which are
currently set, but also the ones that are _not_ set, so a restore
disables them if they are enabled.

from Martijn Dekker (martijn (at) inlv (dot) org)
ok sthen@@, tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.53 2015/12/21 04:57:50 mmcc Exp $	*/
d1116 1
a1116 1
	if ((flags = fcntl(fd, F_GETFL, 0)) < 0)
@


1.53
log
@Replace an ugly bit of pointer arithmetic with a conditional expression.

"seems sound" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.52 2015/12/14 13:59:42 tb Exp $	*/
d243 4
a246 2
			if (Flag(i) && options[i].name)
				shprintf(" -o %s", options[i].name);
@


1.52
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.51 2015/11/12 04:04:31 mmcc Exp $	*/
d989 1
a989 1
			shprintf("'\\'" + 1 - inquote);
@


1.51
log
@Use isdigit() instead of ksh's homebrewed alternative.

ok nicm@@. Also discussed with millert@@ and guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.50 2015/10/19 17:15:53 mmcc Exp $	*/
d8 2
d11 1
d13 1
@


1.50
log
@Remove the define NOT, replace it with '!'. No binary change.

"The ^ is used in regular expressions and many versions of fnmatch(3)
accept both ! and ^. However, we are never going to accept ^ instead of
! so I think this makes sense" -millert@@

"go for it" -nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.49 2015/10/19 14:42:16 mmcc Exp $	*/
a46 1
	setctypes("0123456789", C_DIGIT);
@


1.49
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.48 2015/10/19 14:03:21 mmcc Exp $	*/
d551 1
a551 1
				if (ISMAGIC(p[1]) && p[2] == NOT)
d743 1
a743 1
	if ((not = (ISMAGIC(*p) && *++p == NOT)))
@


1.48
log
@Move limits.h include from sh.h to the files that actually need it. No
binary change.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.47 2015/10/19 02:15:45 mmcc Exp $	*/
d9 1
@


1.47
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.46 2015/09/22 21:50:40 millert Exp $	*/
d8 1
@


1.46
log
@Make errorf() and bi_errorf() handle a NULL argument.
From Michael McConville; OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.45 2015/09/18 07:28:24 nicm Exp $	*/
d7 2
a9 1
#include <ctype.h>
@


1.45
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.44 2015/09/17 14:21:33 nicm Exp $	*/
d905 1
a905 1
				bi_errorf(null);
d931 1
a931 1
				bi_errorf(null);
@


1.44
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.43 2015/09/15 18:15:05 tedu Exp $	*/
d810 1
a810 1
	return (const unsigned char *) 0;
@


1.43
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.42 2015/09/15 18:07:22 tedu Exp $	*/
d505 1
a505 1
		    (char *) alloc(len, ATEMP);
d1004 1
a1004 1
	char *str = (char *) alloc(max_width + 1, ATEMP);
@


1.42
log
@stop abusing null (the variable) for an empty string in output formats.
from Michael McConville
ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.41 2015/09/10 22:48:58 nicm Exp $	*/
d122 1
a122 1
	{ (char *) 0,	'c',	    OF_CMDLINE },
d140 1
a140 1
	{ (char *) 0,	'm',		     0 }, /* so FMONITOR not ifdef'd */
d170 1
a170 1
	{ (char *) 0,	0,		OF_INTERNAL }, /* FTALKING_I */
d325 1
a325 1
	char *array = (char *) 0;
d371 1
a371 1
			if (go.optarg == (char *) 0) {
d835 1
a835 1
	go->optarg = (char *) 0;
d883 1
a883 1
		if (arg == (char *) 0 ||
d920 1
a920 1
			go->optarg = (char *) 0;
d950 1
a950 1
				go->optarg = (char *) 0;
d957 1
a957 1
				go->optarg = (char *) 0;
@


1.41
log
@Replace newline and space defines by "\n" and " " directly, from Michael
McConville. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.40 2015/03/18 15:12:36 tedu Exp $	*/
d1042 1
a1042 1
					shf_fprintf(shf, "%*s", nspace, null);
@


1.40
log
@not necessary to work around an apparent bug on ancient freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.39 2015/01/16 06:39:32 deraadt Exp $	*/
d239 1
a239 1
		shprintf(newline);
@


1.39
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.38 2013/11/28 10:33:37 sobrado Exp $	*/
d1056 1
a1056 4
	/* nbytes check because some systems (older freebsd's) have a buggy
	 * memchr()
	 */
	if (nbytes && (dst = memchr(buf, '\0', nbytes))) {
@


1.38
log
@remove trailing whitespaces; use tabs instead of spaces where appropriate;
no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.37 2009/04/19 20:34:05 sthen Exp $	*/
a8 1
#include <sys/param.h>	/* for MAXPATHLEN */
d1122 1
a1122 1
/* Like getcwd(), except bsize is ignored if buf is 0 (MAXPATHLEN is used) */
d1133 2
a1134 2
		bsize = MAXPATHLEN;
		b = alloc(MAXPATHLEN + 1, ATEMP);
@


1.37
log
@don't print extraneous padding characters when tab-completion file/command
lists encounter a name too long for the width of the terminal.

from Matthew Haub, no objections krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.36 2009/03/03 20:01:01 millert Exp $	*/
d714 1
a714 1
	 
@


1.36
log
@Add POSIX character class support ([:alpha:] and friends) to ksh globbing.
OK deraadt@@ krw@@ jmc@@ sobrado@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.35 2009/01/17 22:06:44 millert Exp $	*/
d1010 1
d1029 3
d1040 1
a1040 1
				    max_width,
@


1.35
log
@Use libc qsort instead of private version.  Tested by several people.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.34 2008/07/12 12:33:42 miod Exp $	*/
d8 1
a8 1
#include <ctype.h>	/* ??? Removing this changes generated code! */
d10 1
d707 28
d738 1
a738 1
	int c, d, not, found = 0;
d744 18
@


1.34
log
@Fix a strlcpy() bound.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.33 2008/03/21 12:51:19 millert Exp $	*/
a766 3

/* -------- qsort.c -------- */

a769 2
static void qsort1(void **base, void **lim, int (*f)(void *, void *));

d773 1
a773 14
    int (*f) (void *, void *))		/* compare function */
{
	qsort1(base, base + n, f);
}

#define	swap2(a, b)	{\
	void *t; t = *(a); *(a) = *(b); *(b) = t;\
}
#define	swap3(a, b, c)	{\
	void *t; t = *(a); *(a) = *(c); *(c) = *(b); *(b) = t;\
}

static void
qsort1(void **base, void **lim, int (*f) (void *, void *))
d775 1
a775 64
	void **i, **j;
	void **lptr, **hptr;
	size_t n;
	int c;

  top:
	n = (lim - base) / 2;
	if (n == 0)
		return;
	hptr = lptr = base+n;
	i = base;
	j = lim - 1;

	for (;;) {
		if (i < lptr) {
			if ((c = (*f)(*i, *lptr)) == 0) {
				lptr --;
				swap2(i, lptr);
				continue;
			}
			if (c < 0) {
				i += 1;
				continue;
			}
		}

	  begin:
		if (j > hptr) {
			if ((c = (*f)(*hptr, *j)) == 0) {
				hptr ++;
				swap2(hptr, j);
				goto begin;
			}
			if (c > 0) {
				if (i == lptr) {
					hptr ++;
					swap3(i, hptr, j);
					i = lptr += 1;
					goto begin;
				}
				swap2(i, j);
				j -= 1;
				i += 1;
				continue;
			}
			j -= 1;
			goto begin;
		}

		if (i == lptr) {
			if (lptr-base >= lim-hptr) {
				qsort1(hptr+1, lim, f);
				lim = lptr;
			} else {
				qsort1(base, lptr, f);
				base = hptr+1;
			}
			goto top;
		}

		lptr -= 1;
		swap3(j, lptr, i);
		j = hptr -= 1;
	}
d779 1
a779 1
xstrcmp(void *p1, void *p2)
d781 1
a781 1
	return (strcmp((char *)p1, (char *)p2));
@


1.33
log
@Make ulimit able to get and set multiple limits in a single invocation
like bash and zsh do.  Requested by espie@@, OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.32 2007/08/02 11:05:54 fgsch Exp $	*/
d80 1
a80 1
	strlcpy(p, s, len+1);
@


1.32
log
@backout last change; iff is right.
prompted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.30 2006/03/12 00:26:58 deraadt Exp $	*/
d894 4
a897 4
 *	  and must start with a digit.  If the argument doesn't start with a
 *	  digit, it is assumed to be missing and normal option processing
 *	  continues (optarg is set to 0 if the option is missing).
 *	  Used for 'typeset -LZ4'.
d980 2
a981 1
			if (digit(argv[go->optind - 1][go->p])) {
d987 2
a988 1
			if (argv[go->optind] && digit(argv[go->optind][0])) {
@


1.31
log
@while i'm here: iff -> if
@
text
@d498 1
a498 1
	/* isfile is false if no syntax check has been done on
@


1.30
log
@might as well make ksh_getopt() match real getopt(), ie. get rid of that
stupid EOF concept that was never true.  adobriyan@@gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.29 2006/03/06 10:44:10 djm Exp $	*/
d498 1
a498 1
	/* isfile is false iff no syntax check has been done on
@


1.29
log
@convert permanent privilege revocation to use setresuid/setresgid;
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.28 2005/03/30 17:16:37 deraadt Exp $	*/
d362 1
a362 1
	while ((optc = ksh_getopt(argv, &go, opts)) != EOF) {
d916 1
a916 1
			return EOF;
d923 1
a923 1
			return EOF;
@


1.28
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.27 2005/03/28 21:28:22 deraadt Exp $	*/
d296 5
a300 4
		seteuid(ksheuid = getuid());
		setuid(ksheuid);
		setegid(getgid());
		setgid(getgid());
@


1.27
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.26 2004/12/22 17:18:51 millert Exp $	*/
d206 2
a207 2
		oi->opt_width, oi->opts[i].name,
		Flag(oi->opts[i].flag) ? "on" : "off");
d232 1
a232 1
			      oi.opt_width + 5, 1);
d355 2
a356 3
		Flag(FLOGIN) = (argv[0][0] == '-'
				|| ((p = strrchr(argv[0], '/'))
				     && *++p == '-'));
d364 1
a364 1
		  case 'A':
d369 1
a369 1
		  case 'o':
d396 1
a396 1
		  case '?':
d399 1
a399 1
		  default:
d406 2
a407 3
				if (optc == options[i].c
				    && (what & options[i].flags))
				{
d409 1
a409 1
						    set);
d418 3
a420 4
	if (!(go.info & GI_MINUSMINUS) && argv[go.optind]
	    && (argv[go.optind][0] == '-' || argv[go.optind][0] == '+')
	    && argv[go.optind][1] == '\0')
	{
d429 2
a430 2
		*setargsp = !arrayset && ((go.info & GI_MINUSMINUS)
					  || argv[go.optind]);
d440 1
a440 1
			xstrcmp);
d503 2
a504 2
		char *t = len <= sizeof(tbuf) ? tbuf
				: (char *) alloc(len, ATEMP);
d509 1
a509 1
			 (const unsigned char *) p, (const unsigned char *) pe);
d602 1
a602 1
		  case '[':
d607 1
a607 1
		  case '?':
d612 1
a612 1
		  case '*':
d627 2
a628 2
		  case 0x80|'+': /* matches one or more times */
		  case 0x80|'*': /* matches zero or more times */
d633 2
a634 2
			if (p[-1] == (0x80 | '*')
			    && do_gmatch(s, se, prest, pe))
d639 4
a642 7
					if (do_gmatch(s, srest,
						psub, pnext - 2)
					    && (do_gmatch(srest, se,
							  prest, pe)
						|| (s != srest
						    && do_gmatch(srest, se,
							p - 2, pe))))
d650 3
a652 3
		  case 0x80|'?': /* matches zero or once */
		  case 0x80|'@@': /* matches one of the patterns */
		  case 0x80|' ': /* simile for @@ */
d657 2
a658 2
			if (p[-1] == (0x80 | '?')
			    && do_gmatch(s, se, prest, pe))
d664 2
a665 4
					if (do_gmatch(s, srest,
						      psub, pnext - 2)
					    && do_gmatch(srest, se,
							 prest, pe))
d673 1
a673 1
		  case 0x80|'!': /* matches none of the patterns */
d682 2
a683 3
					if (do_gmatch(s, srest,
						      psub, pnext - 2))
					{
d690 2
a691 2
				if (!matched && do_gmatch(srest, se,
							  prest, pe))
d696 1
a696 1
		  default:
d727 2
a728 3
		if (ISMAGIC(p[0]) && p[1] == '-'
		    && (!ISMAGIC(p[2]) || p[3] != ']'))
		{
d757 2
a758 2
		if ((*++p == /*(*/ ')' && nest-- == 0)
		    || (*p == '|' && match_sep && nest == 0))
d917 4
a920 5
		if (arg == (char *) 0
		    || ((flag != '-' ) /* neither a - nor a + (if + allowed) */
			&& (!(go->flags & GF_PLUSOPT) || flag != '+'))
		    || (c = arg[1]) == '\0')
		{
d929 2
a930 3
	if (c == '?' || c == ':' || c == ';' || c == ',' || c == '#'
	    || !(o = strchr(options, c)))
	{
d936 2
a937 2
				(go->flags & GF_NONAME) ? "" : argv[0],
				(go->flags & GF_NONAME) ? "" : ": ", c);
d962 2
a963 2
				(go->flags & GF_NONAME) ? "" : argv[0],
				(go->flags & GF_NONAME) ? "" : ": ", c);
d1067 2
a1068 2
					max_width,
					(*func)(arg, i, str, max_width + 1));
@


1.26
log
@g/c str_zcpy()
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.25 2004/12/22 17:14:34 millert Exp $	*/
d122 1
a122 1
	{ (char *) 0, 	'c',	    OF_CMDLINE },
d163 2
a164 2
	{ "vi-tabcomplete",  0, 	OF_ANY }, /* non-standard */
	{ "vi-esccomplete",  0, 	OF_ANY }, /* non-standard */
@


1.25
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.24 2004/12/20 11:34:26 otto Exp $	*/
a1116 17
}

/* Copy at most dsize-1 bytes from src to dst, ensuring dst is null terminated.
 * Returns dst.
 */
char *
str_zcpy(char *dst, const char *src, int dsize)
{
	if (dsize > 0) {
		int len = strlen(src);

		if (len >= dsize)
			len = dsize - 1;
		memcpy(dst, src, len);
		dst[len] = '\0';
	}
	return dst;
@


1.24
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.23 2004/12/18 21:25:44 millert Exp $	*/
d435 1
a435 1
	if (arrayset && (!*array || *skip_varname(array, FALSE))) {
d947 1
a947 1
			warningf(TRUE, "%s%s-%c: unknown option",
d973 1
a973 1
			warningf(TRUE, "%s%s-`%c' requires argument",
@


1.23
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.22 2004/12/18 20:55:52 millert Exp $	*/
d13 3
a15 3
static int	do_gmatch(const unsigned char *s, const unsigned char *p,
			const unsigned char *se, const unsigned char *pe);
static const unsigned char *cclass(const unsigned char *p, int sub);
d21 1
a21 3
setctypes(s, t)
	const char *s;
	int t;
d35 1
a35 1
initctypes()
d56 1
a56 3
ulton(n, base)
	unsigned long n;
	int base;
d71 1
a71 3
str_save(s, ap)
	const char *s;
	Area *ap;
d89 1
a89 4
str_nsave(s, n, ap)
	const char *s;
	int n;
	Area *ap;
d102 1
a102 4
Xcheck_grow_(xsp, xp, more)
	XString *xsp;
	char *xp;
	int more;
d177 1
a177 2
option(n)
	const char *n;
d201 1
a201 5
options_fmt_entry(arg, i, buf, buflen)
	void *arg;
	int i;
	char *buf;
	int buflen;
d212 1
a212 2
printoptions(verbose)
	int verbose;
d244 1
a244 1
getoptions()
d259 3
a261 4
change_flag(f, what, newval)
	enum sh_flag f;	/* flag to change */
	int what;	/* what is changing the flag (command line vs set) */
	int newval;
d317 3
a319 4
parse_args(argv, what, setargsp)
	char **argv;
	int	what;		/* OF_CMDLINE or OF_SET */
	int	*setargsp;
d456 1
a456 3
getn(as, ai)
	const char *as;
	int *ai;
d472 1
a472 3
bi_getn(as, ai)
	const char *as;
	int *ai;
d492 1
a492 3
gmatch(s, p, isfile)
	const char *s, *p;
	int isfile;
d532 1
a532 2
has_globbing(xp, xpe)
	const char *xp, *xpe;
d586 2
a587 3
do_gmatch(s, se, p, pe)
	const unsigned char *s, *p;
	const unsigned char *se, *pe;
d715 1
a715 3
cclass(p, sub)
	const unsigned char *p;
	int sub;
d760 1
a760 4
pat_scan(p, pe, match_sep)
	const unsigned char *p;
	const unsigned char *pe;
	int match_sep;
d785 3
a787 4
qsortp(base, n, f)
	void **base;				/* base address */
	size_t n;				/* elements */
	int (*f)(void *, void *);		/* compare function */
d800 1
a800 3
qsort1(base, lim, f)
	void **base, **lim;
	int (*f)(void *, void *);
d869 1
a869 2
xstrcmp(p1, p2)
	void *p1, *p2;
d876 1
a876 3
ksh_getopt_reset(go, flags)
	Getopt *go;
	int flags;
d912 1
a912 4
ksh_getopt(argv, go, options)
	char **argv;
	Getopt *go;
	const char *options;
d1012 1
a1012 2
print_value_quoted(s)
	const char *s;
d1045 2
a1046 7
print_columns(shf, n, func, arg, max_width, prefcol)
	struct shf *shf;
	int n;
	char *(*func)(void *, int, char *, int);
	void *arg;
	int max_width;
	int prefcol;
d1092 1
a1092 3
strip_nuls(buf, nbytes)
	char *buf;
	int nbytes;
d1123 1
a1123 4
str_zcpy(dst, src, dsize)
	char *dst;
	const char *src;
	int dsize;
d1140 1
a1140 4
blocking_read(fd, buf, nbytes)
	int fd;
	char *buf;
	int nbytes;
d1164 1
a1164 2
reset_nonblock(fd)
	int fd;
d1181 1
a1181 3
ksh_get_wd(buf, bsize)
	char *buf;
	int bsize;
@


1.22
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.21 2004/12/12 06:53:13 deraadt Exp $	*/
d22 2
a23 2
	register const char *s;
	register int t;
d25 1
a25 1
	register int i;
d39 1
a39 1
	register int c;
d59 1
a59 1
	register unsigned long n;
d62 1
a62 1
	register char *p;
d76 1
a76 1
	register const char *s;
d96 1
a96 1
	register const char *s;
d266 1
a266 1
	register char *cp = m;
d617 1
a617 1
	register int sc, pc;
d745 1
a745 1
	register int sub;
d747 1
a747 1
	register int c, d, not, found = 0;
d827 1
a827 1
	register void *t; t = *(a); *(a) = *(b); *(b) = t;\
d830 1
a830 1
	register void *t; t = *(a); *(a) = *(c); *(c) = *(b); *(b) = t;\
d838 2
a839 2
	register void **i, **j;
	register void **lptr, **hptr;
@


1.21
log
@csh-style ! history completion, which can be activated by using
	set -o csh-history (off by default)
this is not feature complete, and likely never will be.  no ^
and ! has some oddities ... ksh's internal history stuff has got
some very odd behaviours that are rather nasty
ok various developers
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.20 2003/10/22 07:40:38 jmc Exp $	*/
d8 2
a9 8
#include <ctype.h>	/* for FILECHCONV */
#ifdef HAVE_LIMITS_H
# include <limits.h>
#endif

#ifndef UCHAR_MAX
# define UCHAR_MAX	0xFF
#endif
d13 3
a15 4
static int	do_gmatch ARGS((const unsigned char *s, const unsigned char *p,
			const unsigned char *se, const unsigned char *pe,
			int isfile));
static const unsigned char *cclass ARGS((const unsigned char *p, int sub));
d209 2
a210 2
static char *options_fmt_entry ARGS((void *arg, int i, char *buf, int buflen));
static void printoptions ARGS((int verbose));
a314 3
#ifdef OS2
		;
#else /* OS2 */
a318 1
#endif /* OS2 */
d376 1
a376 1
				|| ((p = ksh_strrchr_dirsep(argv[0]))
d538 1
a538 2
			 (const unsigned char *) p, (const unsigned char *) pe,
			 isfile);
d613 1
a613 1
do_gmatch(s, se, p, pe, isfile)
a615 1
	int isfile;
a626 4
		if (isfile) {
			sc = FILECHCONV(sc);
			pc = FILECHCONV(pc);
		}
d648 1
a648 1
				if (do_gmatch(s, se, p, pe, isfile))
d665 1
a665 1
			    && do_gmatch(s, se, prest, pe, isfile))
d671 1
a671 1
						psub, pnext - 2, isfile)
d673 1
a673 1
							  prest, pe, isfile)
d676 1
a676 1
							p - 2, pe, isfile))))
d692 1
a692 1
			    && do_gmatch(s, se, prest, pe, isfile))
d699 1
a699 1
						      psub, pnext - 2, isfile)
d701 1
a701 1
							 prest, pe, isfile))
d719 1
a719 1
						      psub, pnext - 2, isfile))
d728 1
a728 1
							  prest, pe, isfile))
d815 1
a815 1
static void qsort1 ARGS((void **base, void **lim, int (*f)(void *, void *)));
d821 1
a821 1
	int (*f) ARGS((void *, void *));	/* compare function */
d836 1
a836 1
	int (*f) ARGS((void *, void *));
d1091 1
a1091 1
	char *(*func) ARGS((void *, int, char *, int));
d1202 1
a1202 6
		if (!tried_reset && (errno == EAGAIN
#ifdef EWOULDBLOCK
				     || errno == EWOULDBLOCK
#endif /* EWOULDBLOCK */
				    ))
		{
a1223 1
	int blocking_flags;
d1227 1
a1227 13
	/* With luck, the C compiler will reduce this to a constant */
	blocking_flags = 0;
#ifdef O_NONBLOCK
	blocking_flags |= O_NONBLOCK;
#endif /* O_NONBLOCK */
#ifdef O_NDELAY
	blocking_flags |= O_NDELAY;
#else /* O_NDELAY */
# ifndef O_NONBLOCK
	blocking_flags |= FNDELAY; /* hope this exists... */
# endif /* O_NONBLOCK */
#endif /* O_NDELAY */
	if (!(flags & blocking_flags))
d1229 1
a1229 1
	flags &= ~blocking_flags;
a1235 26
#ifdef HAVE_SYS_PARAM_H
# include <sys/param.h>
#endif /* HAVE_SYS_PARAM_H */
#ifndef MAXPATHLEN
# define MAXPATHLEN PATH
#endif /* MAXPATHLEN */

#ifdef HPUX_GETWD_BUG
# include "ksh_dir.h"

/*
 * Work around bug in hpux 10.x C library - getwd/getcwd dump core
 * if current directory is not readable.  Done in macro 'cause code
 * is needed in GETWD and GETCWD cases.
 */
# define HPUX_GETWD_BUG_CODE \
	{ \
	    DIR *d = ksh_opendir("."); \
	    if (!d) \
		return (char *) 0; \
	    closedir(d); \
	}
#else /* HPUX_GETWD_BUG */
# define HPUX_GETWD_BUG_CODE
#endif /* HPUX_GETWD_BUG */

a1241 1
#ifdef HAVE_GETCWD
d1245 2
a1246 3
	/* Before memory allocated */
	HPUX_GETWD_BUG_CODE

a1263 33
#else /* HAVE_GETCWD */
	extern char *getwd ARGS((char *));
	char *b;
	int len;

	/* Before memory allocated */
	HPUX_GETWD_BUG_CODE

	if (buf && bsize > MAXPATHLEN)
		b = buf;
	else
		b = alloc(MAXPATHLEN + 1, ATEMP);
	if (!getwd(b)) {
		errno = EACCES;
		if (b != buf)
			afree(b, ATEMP);
		return (char *) 0;
	}
	len = strlen(b) + 1;
	if (!buf)
		b = aresize(b, len, ATEMP);
	else if (buf != b) {
		if (len > bsize) {
			errno = ERANGE;
			return (char *) 0;
		}
		memcpy(buf, b, len);
		afree(b, ATEMP);
		b = buf;
	}

	return b;
#endif /* HAVE_GETCWD */
@


1.20
log
@typos from Jared Yanovich;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.19 2003/09/01 15:47:40 naddy Exp $	*/
d142 1
@


1.19
log
@In emacs editing mode, ksh by default interprets a set 8th bit as
meta prefix, i.e. all characters with the top bit set (>= 0x80) are
taken as commands and cannot be entered literally.

Introduce a new shell option, emacs-usemeta, that allows to toggle
this behavior.  The default is the traditional behavior; to enter
8-bit characters use "set +o emacs-usemeta".

ok fgsch@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.18 2003/08/06 21:08:05 millert Exp $	*/
d186 1
a186 1
	 * (not visable to user)
@


1.18
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.17 2003/08/05 20:52:27 millert Exp $	*/
d144 1
@


1.17
log
@Don't allow alloc() and aresize() to fail.  Their return value was
only checked in two place (both in conjunction with str_save).  Upon
malloc/realloc failure we call internal_errorf() which pops throws
and error and pops back to the last good state.  OK deraadt@@ pval@@ fgs@@
Original problem noted by mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.16 2003/04/16 23:11:52 tdeval Exp $	*/
d1052 1
a1052 1
				go->optarg = (char *) 0;;
d1058 1
a1058 1
				go->optarg = (char *) 0;;
@


1.16
log
@string cleaning.  ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.15 2003/04/04 23:12:02 deraadt Exp $	*/
a92 2
	if (!p)
		return NULL;
@


1.15
log
@two fixes; help from tedu & tdeval
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.14 2003/03/13 09:03:07 deraadt Exp $	*/
d545 1
a545 1
		debunk(t, p);
@


1.14
log
@a few strcpy -> strlcpy; a couple people have mailed in a variety of
patches, and i already had this sitting on my laptop at that time.. i used
that as a chance to note that we had all done the same work, more or less
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.14 2003/03/13 08:51:21 deraadt Exp $	*/
d86 11
a96 1
	return s ? strcpy((char*) alloc((size_t)strlen(s)+1, ap), s) : NULL;
@


1.13
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.12 2001/02/19 09:49:53 camield Exp $	*/
d353 2
a354 1
		strcpy(cmd_opts, "o:"); /* see cmd_opts[] declaration */
d356 2
a357 1
		strcpy(set_opts, "A:o;s"); /* see set_opts[] declaration */
@


1.12
log
@bash-like 'double-tab' completion

- bind TAB (^I) to complete-list by default
- complete-list now lists 'ls style' not 'menu style'
- complete-list first completes; if that does not work, it lists
- fix a memleak in emacs.c, do_complete
- completion now works after '=' (dd), and ':' (ssh) and ` (backtick)
- a command can now start with a subdir from the current dir
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.11 2000/06/28 20:36:37 mickey Exp $	*/
d545 1
a545 1
 *	- imballenced $(...) expression
d1029 1
a1029 1
		/* argument is attatched to option character, even if null */
d1033 1
a1033 1
		/* argument is optional and may be attatched or unattatched
@


1.11
log
@use strtol() in getn(); millert@@ and me
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.10 1999/06/15 01:18:35 millert Exp $	*/
d247 1
a247 1
			      oi.opt_width + 5);
d1093 1
a1093 1
print_columns(shf, n, func, arg, max_width)
d1099 1
d1115 1
a1115 1
	if (n && cols > rows) {
@


1.10
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.9 1999/01/08 20:25:01 millert Exp $	*/
d479 6
a484 11
	const char *s;
	register int n;
	int sawdigit = 0;

	s = as;
	if (*s == '-' || *s == '+')
		s++;
	for (n = 0; digit(*s); s++, sawdigit = 1)
		n = n * 10 + (*s - '0');
	*ai = (*as == '-') ? -n : n;
	if (*s || !sawdigit)
d486 2
@


1.9
log
@bug fixes from pdksh-unstable-5.2.13.5; some of which we already had.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.8 1998/10/29 04:09:21 millert Exp $	*/
d262 1
a262 1
	char m[FNFLAGS + 1];
@


1.8
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.7 1998/06/25 19:02:11 millert Exp $	*/
d1268 19
d1293 25
a1317 1
#ifdef HAVE_GETWD
d1322 3
d1349 1
a1349 22
#else /* HAVE_GETWD */
	char *b;
	char *ret;

	/* Assume getcwd() available */
	if (!buf) {
		bsize = MAXPATHLEN;
		b = alloc(MAXPATHLEN + 1, ATEMP);
	} else
		b = buf;

	ret = getcwd(b, bsize);

	if (!buf) {
		if (ret)
			ret = aresize(b, strlen(b) + 1, ATEMP);
		else
			afree(b, ATEMP);
	}

	return ret;
#endif /* HAVE_GETWD */
@


1.7
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.6 1997/06/19 13:58:45 kstailey Exp $	*/
d133 1
a133 1
	{ null,	 	'c',	    OF_CMDLINE },
d149 1
a149 1
	{ null,		'm',		     0 }, /* so FMONITOR not ifdef'd */
@


1.6
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.4 1997/01/02 09:34:07 downsj Exp $	*/
d176 4
a179 1
	{ NULL,		  0,		     0 }
d191 2
a192 2
	for (i = 0; options[i].name; i++)
		if (strcmp(options[i].name, n) == 0)
d238 2
a239 2
		for (i = n = oi.opt_width = 0; options[i].name; i++)
			if (options[i].name[0]) {
d251 2
a252 2
		for (i = 0; options[i].name; i++)
			if (Flag(i) && options[i].name[0])
d265 1
a265 1
	for (i = 0; options[i].name; i++)
d315 2
a316 2
		seteuid(getuid());
		setuid(getuid());
d326 5
d345 1
a345 1
	char *array;
d351 1
a351 1
		char *p;
a352 1
		/* c is also in options[], but it needs a trailing : */
d355 10
a364 10
		for (i = 0; options[i].name; i++)
			if (options[i].c && (options[i].flags & OF_CMDLINE))
				*p++ = options[i].c;
		*p = '\0';

		strcpy(set_opts, "Ao;s"); /* see set_opts[] declaration */
		p = set_opts + strlen(set_opts);
		for (i = 0; options[i].name; i++)
			if (options[i].c && (options[i].flags & OF_SET))
				*p++ = options[i].c;
d366 1
d386 1
d425 1
a425 1
			for (i = 0; options[i].name; i++)
d433 1
a433 1
			if (!options[i].name) {
d454 4
a457 12
	if (arrayset) {
		array = argv[go.optind++];
		if (!array) {
			bi_errorf("-A: missing array name");
			return -1;
		}
		if (!*array || *skip_varname(array, FALSE)) {
			bi_errorf("%s: is not an identifier", array);
			return -1;
		}
	} else
		array = (char *) 0;	/* keep gcc happy */
d592 1
a592 1
		} else if ((c & 0x80) && strchr("*+?@@!", c & 0x7f)) {
d661 5
a665 2
#ifdef KSH
		  /* [*+?@@!](pattern|pattern|..) */
d694 1
a739 1
#endif /* KSH */
d764 1
a764 1
			if ((c & 0x80) && !ISMAGIC(c))
d766 4
d811 1
a811 1
		if ((*p & 0x80) && strchr("*+?@@!", *p & 0x7f))
d956 1
a956 2
 *	  in go->info.  Once a - or + has been seen, all other options must
 *	  start with the same character.
d978 2
a979 3
		    || ((flag != '-' || (go->info & GI_PLUS))
			&& (!(go->flags & GF_PLUSOPT) || (go->info & GI_MINUS)
			    || flag != '+'))
d986 1
@


1.5
log
@(foo *)0 -> NULL
@
text
@d381 1
a381 1
			if (go.optarg == NULL) {
d456 1
a456 1
		array = NULL;	/* keep gcc happy */
d806 1
a806 1
	return NULL;
d918 1
a918 1
	go->optarg = NULL;
d970 1
a970 1
		if (arg == NULL
d1009 1
a1009 1
			go->optarg = NULL;
d1038 1
a1038 1
				go->optarg = NULL;
d1044 1
a1044 1
				go->optarg = NULL;
d1280 1
a1280 1
		return NULL;
d1288 1
a1288 1
			return NULL;
@


1.4
log
@Add FSH (set -o sh), initialize it if we're /bin/sh, and add the first use:
don't set $_ if we're non-interactive.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.3 1996/12/22 02:57:49 tholo Exp $	*/
d381 1
a381 1
			if (go.optarg == (char *) 0) {
d456 1
a456 1
		array = (char *) 0;	/* keep gcc happy */
d806 1
a806 1
	return (const unsigned char *) 0;
d918 1
a918 1
	go->optarg = (char *) 0;
d970 1
a970 1
		if (arg == (char *) 0
d1009 1
a1009 1
			go->optarg = (char *) 0;
d1038 1
a1038 1
				go->optarg = (char *) 0;;
d1044 1
a1044 1
				go->optarg = (char *) 0;;
d1280 1
a1280 1
		return (char *) 0;
d1288 1
a1288 1
			return (char *) 0;
@


1.3
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.2 1996/08/19 20:08:57 downsj Exp $	*/
d164 1
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
d311 1
d313 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d17 1
a17 1
char ctypes [UCHAR_MAX+1];	/* type bits for unsigned char */
d34 1
a34 1
	if ((t&C_IFS)) {
d59 1
d172 1
d987 1
a987 1
			warningf(TRUE, "%s%s-%c: bad option",
d1060 1
a1060 1
		if (!letnum(*p) && *p != '/')
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
