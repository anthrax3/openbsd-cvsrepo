head	1.19;
access;
symbols
	OPENBSD_6_1:1.18.0.8
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.12.0.44
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.36
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.40
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.38
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.34
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.32
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.30
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.28
	OPENBSD_5_0:1.12.0.26
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.24
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.22
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.18
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.20
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.16
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.14
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.12
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.10
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.8
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.6
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.12
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.10
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.8
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.6
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2017.09.03.11.52.01;	author jca;	state Exp;
branches;
next	1.18;
commitid	hY9pKLTbOjQJ8uf0;

1.18
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.17;
commitid	btTCreDA00YdaFhU;

1.17
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	C4W85jmosThChWA2;

1.16
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	16HUr75moyUNtKR8;

1.15
date	2015.10.06.21.35.16;	author nicm;	state Exp;
branches;
next	1.14;
commitid	i63EIF9V5BBWUkXz;

1.14
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.13;
commitid	lBs9un9sXhbdfVrQ;

1.13
date	2015.09.05.09.47.08;	author jsg;	state Exp;
branches;
next	1.12;
commitid	AWjHn4VUyqwdq4dE;

1.12
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.22.07.40.38;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.01.23.10.58;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	99.06.15.01.18.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.10.29.04.09.21;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.06.25.19.02.14;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.06.19.13.58.46;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	97.06.18.22.42.42;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Use PATH_MAX instead of a local define

okk deraadt@@ millert@@ anton@@
@
text
@/*	$OpenBSD: path.c,v 1.18 2015/12/14 13:59:42 tb Exp $	*/

#include <sys/stat.h>

#include <errno.h>
#include <string.h>
#include <unistd.h>

#include "sh.h"

/*
 *	Contains a routine to search a : separated list of
 *	paths (a la CDPATH) and make appropriate file names.
 *	Also contains a routine to simplify .'s and ..'s out of
 *	a path name.
 *
 *	Larry Bouzane (larry@@cs.mun.ca)
 */

static char	*do_phys_path(XString *, char *, const char *);

/*
 *	Makes a filename into result using the following algorithm.
 *	- make result NULL
 *	- if file starts with '/', append file to result & set cdpathp to NULL
 *	- if file starts with ./ or ../ append cwd and file to result
 *	  and set cdpathp to NULL
 *	- if the first element of cdpathp doesnt start with a '/' xx or '.' xx
 *	  then cwd is appended to result.
 *	- the first element of cdpathp is appended to result
 *	- file is appended to result
 *	- cdpathp is set to the start of the next element in cdpathp (or NULL
 *	  if there are no more elements.
 *	The return value indicates whether a non-null element from cdpathp
 *	was appended to result.
 */
int
make_path(const char *cwd, const char *file,
    char **cdpathp,		/* & of : separated list */
    XString *xsp,
    int *phys_pathp)
{
	int	rval = 0;
	int	use_cdpath = 1;
	char	*plist;
	int	len;
	int	plen = 0;
	char	*xp = Xstring(*xsp, xp);

	if (!file)
		file = null;

	if (file[0] == '/') {
		*phys_pathp = 0;
		use_cdpath = 0;
	} else {
		if (file[0] == '.') {
			char c = file[1];

			if (c == '.')
				c = file[2];
			if (c == '/' || c == '\0')
				use_cdpath = 0;
		}

		plist = *cdpathp;
		if (!plist)
			use_cdpath = 0;
		else if (use_cdpath) {
			char *pend;

			for (pend = plist; *pend && *pend != ':'; pend++)
				;
			plen = pend - plist;
			*cdpathp = *pend ? ++pend : NULL;
		}

		if ((use_cdpath == 0 || !plen || plist[0] != '/') &&
		    (cwd && *cwd)) {
			len = strlen(cwd);
			XcheckN(*xsp, xp, len);
			memcpy(xp, cwd, len);
			xp += len;
			if (cwd[len - 1] != '/')
				Xput(*xsp, xp, '/');
		}
		*phys_pathp = Xlength(*xsp, xp);
		if (use_cdpath && plen) {
			XcheckN(*xsp, xp, plen);
			memcpy(xp, plist, plen);
			xp += plen;
			if (plist[plen - 1] != '/')
				Xput(*xsp, xp, '/');
			rval = 1;
		}
	}

	len = strlen(file) + 1;
	XcheckN(*xsp, xp, len);
	memcpy(xp, file, len);

	if (!use_cdpath)
		*cdpathp = NULL;

	return rval;
}

/*
 * Simplify pathnames containing "." and ".." entries.
 * ie, simplify_path("/a/b/c/./../d/..") returns "/a/b"
 */
void
simplify_path(char *path)
{
	char	*cur;
	char	*t;
	int	isrooted;
	char	*very_start = path;
	char	*start;

	if (!*path)
		return;

	if ((isrooted = (path[0] == '/')))
		very_start++;

	/* Before			After
	 *  /foo/			/foo
	 *  /foo/../../bar		/bar
	 *  /foo/./blah/..		/foo
	 *  .				.
	 *  ..				..
	 *  ./foo			foo
	 *  foo/../../../bar		../../bar
	 */

	for (cur = t = start = very_start; ; ) {
		/* treat multiple '/'s as one '/' */
		while (*t == '/')
			t++;

		if (*t == '\0') {
			if (cur == path)
				/* convert empty path to dot */
				*cur++ = '.';
			*cur = '\0';
			break;
		}

		if (t[0] == '.') {
			if (!t[1] || t[1] == '/') {
				t += 1;
				continue;
			} else if (t[1] == '.' && (!t[2] || t[2] == '/')) {
				if (!isrooted && cur == start) {
					if (cur != very_start)
						*cur++ = '/';
					*cur++ = '.';
					*cur++ = '.';
					start = cur;
				} else if (cur != start)
					while (--cur > start && *cur != '/')
						;
				t += 2;
				continue;
			}
		}

		if (cur != very_start)
			*cur++ = '/';

		/* find/copy next component of pathname */
		while (*t && *t != '/')
			*cur++ = *t++;
	}
}


void
set_current_wd(char *path)
{
	int len;
	char *p = path;

	if (!p && !(p = ksh_get_wd(NULL, 0)))
		p = null;

	len = strlen(p) + 1;

	if (len > current_wd_size)
		current_wd = aresize(current_wd, current_wd_size = len, APERM);
	memcpy(current_wd, p, len);
	if (p != path && p != null)
		afree(p, ATEMP);
}

char *
get_phys_path(const char *path)
{
	XString xs;
	char *xp;

	Xinit(xs, xp, strlen(path) + 1, ATEMP);

	xp = do_phys_path(&xs, xp, path);

	if (!xp)
		return NULL;

	if (Xlength(xs, xp) == 0)
		Xput(xs, xp, '/');
	Xput(xs, xp, '\0');

	return Xclose(xs, xp);
}

static char *
do_phys_path(XString *xsp, char *xp, const char *path)
{
	const char *p, *q;
	int len, llen;
	int savepos;
	char lbuf[PATH_MAX];

	Xcheck(*xsp, xp);
	for (p = path; p; p = q) {
		while (*p == '/')
			p++;
		if (!*p)
			break;
		len = (q = strchr(p, '/')) ? q - p : strlen(p);
		if (len == 1 && p[0] == '.')
			continue;
		if (len == 2 && p[0] == '.' && p[1] == '.') {
			while (xp > Xstring(*xsp, xp)) {
				xp--;
				if (*xp == '/')
					break;
			}
			continue;
		}

		savepos = Xsavepos(*xsp, xp);
		Xput(*xsp, xp, '/');
		XcheckN(*xsp, xp, len + 1);
		memcpy(xp, p, len);
		xp += len;
		*xp = '\0';

		llen = readlink(Xstring(*xsp, xp), lbuf, sizeof(lbuf) - 1);
		if (llen < 0) {
			/* EINVAL means it wasn't a symlink... */
			if (errno != EINVAL)
				return NULL;
			continue;
		}
		lbuf[llen] = '\0';

		/* If absolute path, start from scratch.. */
		xp = lbuf[0] == '/' ? Xstring(*xsp, xp) :
		    Xrestpos(*xsp, xp, savepos);
		if (!(xp = do_phys_path(xsp, xp, lbuf)))
			return NULL;
	}
	return xp;
}
@


1.18
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: path.c,v 1.17 2015/10/19 14:42:16 mmcc Exp $	*/
d223 1
a223 1
	char lbuf[PATH];
@


1.17
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: path.c,v 1.16 2015/10/19 02:15:45 mmcc Exp $	*/
d5 1
d7 1
@


1.16
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: path.c,v 1.15 2015/10/06 21:35:16 nicm Exp $	*/
d4 2
@


1.15
log
@Remove an old and broken test snippet, from Michael McConville. ok millert
@
text
@d1 3
a3 1
/*	$OpenBSD: path.c,v 1.14 2015/09/15 18:15:05 tedu Exp $	*/
a5 1
#include <sys/stat.h>
@


1.14
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: path.c,v 1.13 2015/09/05 09:47:08 jsg Exp $	*/
a261 24

#ifdef	TEST

int
main(void)
{
	int	rv;
	char	*cp, cdpath[256], pwd[256], file[256], result[256];

	printf("enter CDPATH: "); gets(cdpath);
	printf("enter PWD: "); gets(pwd);
	while (1) {
		if (printf("Enter file: "), gets(file) == 0)
			return 0;
		cp = cdpath;
		do {
			rv = make_path(pwd, file, &cp, result, sizeof(result));
			printf("make_path returns (%d), \"%s\" ", rv, result);
			simplify_path(result);
			printf("(simpifies to \"%s\")\n", result);
		} while (cp);
	}
}
#endif	/* TEST */
@


1.13
log
@Add brackets to clarify assignments that are the result of a test operator.

ok deraadt@@ looks correct millert@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: path.c,v 1.12 2005/03/30 17:16:37 deraadt Exp $	*/
d70 1
a70 1
			*cdpathp = *pend ? ++pend : (char *) 0;
d98 1
a98 1
		*cdpathp = (char *) 0;
d180 1
a180 1
	if (!p && !(p = ksh_get_wd((char *) 0, 0)))
d203 1
a203 1
		return (char *) 0;
d249 1
a249 1
				return (char *) 0;
d258 1
a258 1
			return (char *) 0;
@


1.12
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: path.c,v 1.11 2004/12/20 11:34:26 otto Exp $	*/
d119 1
a119 1
	if ((isrooted = path[0] == '/'))
@


1.11
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: path.c,v 1.10 2004/12/18 20:55:52 millert Exp $	*/
d73 2
a74 3
		if ((use_cdpath == 0 || !plen || plist[0] != '/')
		    && (cwd && *cwd))
		{
d255 2
a256 2
		xp = lbuf[0] == '/' ? Xstring(*xsp, xp)
				    : Xrestpos(*xsp, xp, savepos);
@


1.10
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: path.c,v 1.9 2003/10/22 07:40:38 jmc Exp $	*/
d15 1
a15 1
static char	*do_phys_path(XString *xsp, char *xp, const char *path);
d33 4
a36 6
make_path(cwd, file, cdpathp, xsp, phys_pathp)
	const char *cwd;
	const char *file;
	char	**cdpathp;	/* & of : separated list */
	XString	*xsp;
	int	*phys_pathp;
d109 1
a109 2
simplify_path(path)
	char	*path;
d176 1
a176 2
set_current_wd(path)
	char *path;
d194 1
a194 2
get_phys_path(path)
	const char *path;
d214 1
a214 4
do_phys_path(xsp, xp, path)
	XString *xsp;
	char *xp;
	const char *path;
d266 2
a267 1
main(argc, argv)
@


1.9
log
@typos from Jared Yanovich;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: path.c,v 1.8 2003/02/28 09:45:09 jmc Exp $	*/
d4 1
a4 1
#include "ksh_stat.h"
d15 1
a15 3
#ifdef S_ISLNK
static char	*do_phys_path ARGS((XString *xsp, char *xp, const char *path));
#endif /* S_ISLNK */
d50 1
a50 1
	if (!ISRELPATH(file)) {
d59 1
a59 1
			if (ISDIRSEP(c) || c == '\0')
d69 1
a69 1
			for (pend = plist; *pend && *pend != PATHSEP; pend++)
d75 1
a75 1
		if ((use_cdpath == 0 || !plen || ISRELPATH(plist))
d82 2
a83 2
			if (!ISDIRSEP(cwd[len - 1]))
				Xput(*xsp, xp, DIRSEP);
d90 2
a91 2
			if (!ISDIRSEP(plist[plen - 1]))
				Xput(*xsp, xp, DIRSEP);
d123 1
a123 1
	if ((isrooted = ISROOTEDPATH(path)))
a124 4
#if defined (OS2) || defined (__CYGWIN__)
	if (path[0] && path[1] == ':')	/* skip a: */
		very_start += 2;
#endif /* OS2 || __CYGWIN__ */
a133 5
	 * OS2 and CYGWIN:
	 *  a:/foo/../..		a:/
	 *  a:.				a:
	 *  a:..			a:..
	 *  a:foo/../../blah		a:../blah
a135 6
#ifdef __CYGWIN__
       /* preserve leading double-slash on pathnames (for UNC paths) */
       if (path[0] && ISDIRSEP(path[0]) && path[1] && ISDIRSEP(path[1]))
               very_start++;
#endif /* __CYGWIN__ */

d138 1
a138 1
		while (ISDIRSEP(*t))
d150 1
a150 1
			if (!t[1] || ISDIRSEP(t[1])) {
d153 1
a153 1
			} else if (t[1] == '.' && (!t[2] || ISDIRSEP(t[2]))) {
d156 1
a156 1
						*cur++ = DIRSEP;
d161 1
a161 1
					while (--cur > start && !ISDIRSEP(*cur))
d169 1
a169 1
			*cur++ = DIRSEP;
d172 1
a172 1
		while (*t && !ISDIRSEP(*t))
a196 1
#ifdef S_ISLNK
d212 1
a212 1
		Xput(xs, xp, DIRSEP);
d231 1
a231 1
		while (ISDIRSEP(*p))
d235 1
a235 1
		len = (q = ksh_strchr_dirsep(p)) ? q - p : strlen(p);
d241 1
a241 1
				if (ISDIRSEP(*xp))
d248 1
a248 1
		Xput(*xsp, xp, DIRSEP);
d264 2
a265 2
		xp = ISABSPATH(lbuf) ? Xstring(*xsp, xp)
				     : Xrestpos(*xsp, xp, savepos);
a270 1
#endif /* S_ISLNK */
@


1.8
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: path.c,v 1.7 2000/03/01 23:10:58 todd Exp $	*/
d32 1
a32 1
 *	was appened to result.
@


1.7
log
@rm $Log$
@
text
@d1 1
a1 1
/*	$OpenBSD: path.c,v 1.6 1999/06/15 01:18:35 millert Exp $	*/
d8 1
a8 1
 *	paths (a la CDPATH) and make appropiate file names.
@


1.6
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: path.c,v 1.5 1998/10/29 04:09:21 millert Exp $	*/
a12 55
 */

/*
 * $Log: path.c,v $
 * Revision 1.5  1998/10/29 04:09:21  millert
 * Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
 * some that we had already fixed locally.
 *  o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 *  o when re-allocating memory, too much may be copied from old memory.
 *  o set -o printed some options sans names.
 *  o emacs mode: <esc>. in very fist command causes core dump.
 *  o pdksh dumps core after a cd command.
 *  o typeset -i reports on array elements that have no value
 *    (at&t ksh reports on array base name - no index).
 *  o ulimit -ctn unlimittttted kills shell (resource exceeded).
 *  o ". /dev/null" says access denied.
 *  o flag field in aliases incorrectly changed (all flags set instead of
 *    clearing ISSET) in exec.c(flushcom).
 *  o ${#array[*]} prints largest index instead of number of (set) elements
 *    in an array (ksh88 does the former).
 *  o sys_siglist[] doesn't always have NSIG non-null entries...
 *
 * Revision 1.4  1998/06/25 19:02:14  millert
 * pdksh-5.2.13 + local changes
 *
 * Revision 1.2  1994/05/19  18:32:40  michael
 * Merge complete, stdio replaced, various fixes. (pre autoconf)
 *
 * Revision 1.1  1994/04/06  13:14:03  michael
 * Initial revision
 *
 * Revision 4.2  1990/12/06  18:05:24  larry
 * Updated test code to reflect parameter change.
 * Fixed problem with /a/./.dir being simplified to /a and not /a/.dir due
 * to *(cur+2) == *f test instead of the correct cur+2 == f
 *
 * Revision 4.1  90/10/29  14:42:19  larry
 * base MUN version
 * 
 * Revision 3.1.0.4  89/02/16  20:28:36  larry
 * Forgot to set *pathlist to NULL when last changed make_path().
 * 
 * Revision 3.1.0.3  89/02/13  20:29:55  larry
 * Fixed up cd so that it knew when a node from CDPATH was used and would
 * print a message only when really necessary.
 * 
 * Revision 3.1.0.2  89/02/13  17:51:22  larry
 * Merged with Eric Gisin's version.
 * 
 * Revision 3.1.0.1  89/02/13  17:50:58  larry
 * *** empty log message ***
 * 
 * Revision 3.1  89/02/13  17:49:28  larry
 * *** empty log message ***
 * 
@


1.5
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: path.c,v 1.4 1998/06/25 19:02:14 millert Exp $	*/
d17 18
d182 1
a182 1
#ifdef OS2
d185 1
a185 1
#endif /* OS2 */
d195 1
a195 1
	 * OS2:
d201 6
@


1.4
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: path.c,v 1.3 1997/06/19 13:58:46 kstailey Exp $	*/
d7 1
a7 1
 *	Contains a routine to search a : seperated list of
d17 3
d75 1
a75 1
	char	**cdpathp;	/* & of : seperated list */
@


1.3
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: path.c,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
a16 3
 * Revision 1.1.1.1  1996/08/14 06:19:11  downsj
 * Import pdksh 5.2.7.
 *
@


1.2
log
@(foo *)0 -> NULL
@
text
@d111 1
a111 1
			*cdpathp = *pend ? ++pend : NULL;
d140 1
a140 1
		*cdpathp = NULL;
d233 1
a233 1
	if (!p && !(p = ksh_get_wd(NULL, 0)))
d258 1
a258 1
		return NULL;
d307 1
a307 1
				return NULL;
d316 1
a316 1
			return NULL;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d17 3
d111 1
a111 1
			*cdpathp = *pend ? ++pend : (char *) 0;
d140 1
a140 1
		*cdpathp = (char *) 0;
d233 1
a233 1
	if (!p && !(p = ksh_get_wd((char *) 0, 0)))
d258 1
a258 1
		return (char *) 0;
d307 1
a307 1
				return (char *) 0;
d316 1
a316 1
			return (char *) 0;
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
