head	1.31;
access;
symbols
	OPENBSD_6_2:1.31.0.8
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.31.0.6
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.16.0.12
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.4
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.8
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.28
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.26
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.24
	OPENBSD_5_0:1.15.0.22
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.20
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.18
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.14
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.16
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.8.0.8
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.6
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.8
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.6
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.03.20.00.01.21;	author krw;	state Exp;
branches;
next	1.30;
commitid	vrVXbedfAlzCTHmf;

1.30
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.29;
commitid	btTCreDA00YdaFhU;

1.29
date	2015.11.12.04.04.31;	author mmcc;	state Exp;
branches;
next	1.28;
commitid	QvyWaajN4Lc4MRtd;

1.28
date	2015.11.01.23.31.54;	author mmcc;	state Exp;
branches;
next	1.27;
commitid	PRgLRpDiTzU9sSZq;

1.27
date	2015.11.01.15.43.55;	author mmcc;	state Exp;
branches;
next	1.26;
commitid	4NSYdCorEko3SIMp;

1.26
date	2015.10.23.17.22.43;	author mmcc;	state Exp;
branches;
next	1.25;
commitid	p91Wh1pcWpDI2EXt;

1.25
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.24;
commitid	C4W85jmosThChWA2;

1.24
date	2015.10.19.14.03.21;	author mmcc;	state Exp;
branches;
next	1.23;
commitid	TSZF0K3aGmPbKQzz;

1.23
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	16HUr75moyUNtKR8;

1.22
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.21;
commitid	7fgq4YTZG4xZ0uN0;

1.21
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.20;
commitid	v5QjoxUgKU2iUTFz;

1.20
date	2015.09.15.20.59.05;	author nicm;	state Exp;
branches;
next	1.19;
commitid	7LIaEGyUxazLMwdA;

1.19
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.18;
commitid	lBs9un9sXhbdfVrQ;

1.18
date	2015.09.14.09.42.33;	author nicm;	state Exp;
branches;
next	1.17;
commitid	HNyoYgRIsBj18EIi;

1.17
date	2015.09.13.19.43.42;	author tedu;	state Exp;
branches;
next	1.16;
commitid	wKM9cjerwNu20hUj;

1.16
date	2013.04.19.17.36.09;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.02.00.48.33;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.11.18.53.51;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.28.21.28.22;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.18.22.35.41;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.21.23.12.04;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.06.15.01.18.36;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.01.19.20.41.56;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.10.29.04.09.21;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.06.19.13.58.46;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	97.06.18.22.42.43;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Currently we have about a 50/50 split over fcntl(n, F_GETFL [,0])
idioms.

Adopt the more concise fcntl(n, F_GETFL) over fcntl(n, F_GETFL, 0)
where it is obvious further investigation will not yield and
even better way.

Obviousness evaluation and ok guenther@@
@
text
@/*	$OpenBSD: shf.c,v 1.30 2015/12/14 13:59:42 tb Exp $	*/

/*
 *  Shell file I/O routines
 */

#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "sh.h"

/* flags to shf_emptybuf() */
#define EB_READSW	0x01	/* about to switch to reading */
#define EB_GROW		0x02	/* grow buffer if necessary (STRING+DYNAMIC) */

/*
 * Replacement stdio routines.  Stdio is too flakey on too many machines
 * to be useful when you have multiple processes using the same underlying
 * file descriptors.
 */

static int	shf_fillbuf(struct shf *);
static int	shf_emptybuf(struct shf *, int);

/* Open a file.  First three args are for open(), last arg is flags for
 * this package.  Returns NULL if file could not be opened, or if a dup
 * fails.
 */
struct shf *
shf_open(const char *name, int oflags, int mode, int sflags)
{
	struct shf *shf;
	int bsize = sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
	int fd;

	/* Done before open so if alloca fails, fd won't be lost. */
	shf = alloc(sizeof(struct shf) + bsize, ATEMP);
	shf->areap = ATEMP;
	shf->buf = (unsigned char *) &shf[1];
	shf->bsize = bsize;
	shf->flags = SHF_ALLOCS;
	/* Rest filled in by reopen. */

	fd = open(name, oflags, mode);
	if (fd < 0) {
		afree(shf, shf->areap);
		return NULL;
	}
	if ((sflags & SHF_MAPHI) && fd < FDBASE) {
		int nfd;

		nfd = fcntl(fd, F_DUPFD, FDBASE);
		close(fd);
		if (nfd < 0) {
			afree(shf, shf->areap);
			return NULL;
		}
		fd = nfd;
	}
	sflags &= ~SHF_ACCMODE;
	sflags |= (oflags & O_ACCMODE) == O_RDONLY ? SHF_RD :
	    ((oflags & O_ACCMODE) == O_WRONLY ? SHF_WR : SHF_RDWR);

	return shf_reopen(fd, sflags, shf);
}

/* Set up the shf structure for a file descriptor.  Doesn't fail. */
struct shf *
shf_fdopen(int fd, int sflags, struct shf *shf)
{
	int bsize = sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;

	/* use fcntl() to figure out correct read/write flags */
	if (sflags & SHF_GETFL) {
		int flags = fcntl(fd, F_GETFL);

		if (flags < 0)
			/* will get an error on first read/write */
			sflags |= SHF_RDWR;
		else {
			switch (flags & O_ACCMODE) {
			case O_RDONLY:
				sflags |= SHF_RD;
				break;
			case O_WRONLY:
				sflags |= SHF_WR;
				break;
			case O_RDWR:
				sflags |= SHF_RDWR;
				break;
			}
		}
	}

	if (!(sflags & (SHF_RD | SHF_WR)))
		internal_errorf(1, "shf_fdopen: missing read/write");

	if (shf) {
		if (bsize) {
			shf->buf = alloc(bsize, ATEMP);
			sflags |= SHF_ALLOCB;
		} else
			shf->buf = NULL;
	} else {
		shf = alloc(sizeof(struct shf) + bsize, ATEMP);
		shf->buf = (unsigned char *) &shf[1];
		sflags |= SHF_ALLOCS;
	}
	shf->areap = ATEMP;
	shf->fd = fd;
	shf->rp = shf->wp = shf->buf;
	shf->rnleft = 0;
	shf->rbsize = bsize;
	shf->wnleft = 0; /* force call to shf_emptybuf() */
	shf->wbsize = sflags & SHF_UNBUF ? 0 : bsize;
	shf->flags = sflags;
	shf->errno_ = 0;
	shf->bsize = bsize;
	if (sflags & SHF_CLEXEC)
		fcntl(fd, F_SETFD, FD_CLOEXEC);
	return shf;
}

/* Set up an existing shf (and buffer) to use the given fd */
struct shf *
shf_reopen(int fd, int sflags, struct shf *shf)
{
	int bsize = sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;

	/* use fcntl() to figure out correct read/write flags */
	if (sflags & SHF_GETFL) {
		int flags = fcntl(fd, F_GETFL);

		if (flags < 0)
			/* will get an error on first read/write */
			sflags |= SHF_RDWR;
		else {
			switch (flags & O_ACCMODE) {
			case O_RDONLY:
				sflags |= SHF_RD;
				break;
			case O_WRONLY:
				sflags |= SHF_WR;
				break;
			case O_RDWR:
				sflags |= SHF_RDWR;
				break;
			}
		}
	}

	if (!(sflags & (SHF_RD | SHF_WR)))
		internal_errorf(1, "shf_reopen: missing read/write");
	if (!shf || !shf->buf || shf->bsize < bsize)
		internal_errorf(1, "shf_reopen: bad shf/buf/bsize");

	/* assumes shf->buf and shf->bsize already set up */
	shf->fd = fd;
	shf->rp = shf->wp = shf->buf;
	shf->rnleft = 0;
	shf->rbsize = bsize;
	shf->wnleft = 0; /* force call to shf_emptybuf() */
	shf->wbsize = sflags & SHF_UNBUF ? 0 : bsize;
	shf->flags = (shf->flags & (SHF_ALLOCS | SHF_ALLOCB)) | sflags;
	shf->errno_ = 0;
	if (sflags & SHF_CLEXEC)
		fcntl(fd, F_SETFD, FD_CLOEXEC);
	return shf;
}

/* Open a string for reading or writing.  If reading, bsize is the number
 * of bytes that can be read.  If writing, bsize is the maximum number of
 * bytes that can be written.  If shf is not null, it is filled in and
 * returned, if it is null, shf is allocated.  If writing and buf is null
 * and SHF_DYNAMIC is set, the buffer is allocated (if bsize > 0, it is
 * used for the initial size).  Doesn't fail.
 * When writing, a byte is reserved for a trailing null - see shf_sclose().
 */
struct shf *
shf_sopen(char *buf, int bsize, int sflags, struct shf *shf)
{
	/* can't have a read+write string */
	if (!(sflags & (SHF_RD | SHF_WR)) ||
	    (sflags & (SHF_RD | SHF_WR)) == (SHF_RD | SHF_WR))
		internal_errorf(1, "shf_sopen: flags 0x%x", sflags);

	if (!shf) {
		shf = alloc(sizeof(struct shf), ATEMP);
		sflags |= SHF_ALLOCS;
	}
	shf->areap = ATEMP;
	if (!buf && (sflags & SHF_WR) && (sflags & SHF_DYNAMIC)) {
		if (bsize <= 0)
			bsize = 64;
		sflags |= SHF_ALLOCB;
		buf = alloc(bsize, shf->areap);
	}
	shf->fd = -1;
	shf->buf = shf->rp = shf->wp = (unsigned char *) buf;
	shf->rnleft = bsize;
	shf->rbsize = bsize;
	shf->wnleft = bsize - 1;	/* space for a '\0' */
	shf->wbsize = bsize;
	shf->flags = sflags | SHF_STRING;
	shf->errno_ = 0;
	shf->bsize = bsize;

	return shf;
}

/* Flush and close file descriptor, free the shf structure */
int
shf_close(struct shf *shf)
{
	int ret = 0;

	if (shf->fd >= 0) {
		ret = shf_flush(shf);
		if (close(shf->fd) < 0)
			ret = EOF;
	}
	if (shf->flags & SHF_ALLOCS)
		afree(shf, shf->areap);
	else if (shf->flags & SHF_ALLOCB)
		afree(shf->buf, shf->areap);

	return ret;
}

/* Flush and close file descriptor, don't free file structure */
int
shf_fdclose(struct shf *shf)
{
	int ret = 0;

	if (shf->fd >= 0) {
		ret = shf_flush(shf);
		if (close(shf->fd) < 0)
			ret = EOF;
		shf->rnleft = 0;
		shf->rp = shf->buf;
		shf->wnleft = 0;
		shf->fd = -1;
	}

	return ret;
}

/* Close a string - if it was opened for writing, it is null terminated;
 * returns a pointer to the string and frees shf if it was allocated
 * (does not free string if it was allocated).
 */
char *
shf_sclose(struct shf *shf)
{
	unsigned char *s = shf->buf;

	/* null terminate */
	if (shf->flags & SHF_WR) {
		shf->wnleft++;
		shf_putc('\0', shf);
	}
	if (shf->flags & SHF_ALLOCS)
		afree(shf, shf->areap);
	return (char *) s;
}

/* Un-read what has been read but not examined, or write what has been
 * buffered.  Returns 0 for success, EOF for (write) error.
 */
int
shf_flush(struct shf *shf)
{
	if (shf->flags & SHF_STRING)
		return (shf->flags & SHF_WR) ? EOF : 0;

	if (shf->fd < 0)
		internal_errorf(1, "shf_flush: no fd");

	if (shf->flags & SHF_ERROR) {
		errno = shf->errno_;
		return EOF;
	}

	if (shf->flags & SHF_READING) {
		shf->flags &= ~(SHF_EOF | SHF_READING);
		if (shf->rnleft > 0) {
			lseek(shf->fd, (off_t) -shf->rnleft, SEEK_CUR);
			shf->rnleft = 0;
			shf->rp = shf->buf;
		}
		return 0;
	} else if (shf->flags & SHF_WRITING)
		return shf_emptybuf(shf, 0);

	return 0;
}

/* Write out any buffered data.  If currently reading, flushes the read
 * buffer.  Returns 0 for success, EOF for (write) error.
 */
static int
shf_emptybuf(struct shf *shf, int flags)
{
	int ret = 0;

	if (!(shf->flags & SHF_STRING) && shf->fd < 0)
		internal_errorf(1, "shf_emptybuf: no fd");

	if (shf->flags & SHF_ERROR) {
		errno = shf->errno_;
		return EOF;
	}

	if (shf->flags & SHF_READING) {
		if (flags & EB_READSW) /* doesn't happen */
			return 0;
		ret = shf_flush(shf);
		shf->flags &= ~SHF_READING;
	}
	if (shf->flags & SHF_STRING) {
		unsigned char	*nbuf;

		/* Note that we assume SHF_ALLOCS is not set if SHF_ALLOCB
		 * is set... (changing the shf pointer could cause problems)
		 */
		if (!(flags & EB_GROW) || !(shf->flags & SHF_DYNAMIC) ||
		    !(shf->flags & SHF_ALLOCB))
			return EOF;
		/* allocate more space for buffer */
		nbuf = areallocarray(shf->buf, 2, shf->wbsize, shf->areap);
		shf->rp = nbuf + (shf->rp - shf->buf);
		shf->wp = nbuf + (shf->wp - shf->buf);
		shf->rbsize += shf->wbsize;
		shf->wnleft += shf->wbsize;
		shf->wbsize *= 2;
		shf->buf = nbuf;
	} else {
		if (shf->flags & SHF_WRITING) {
			int ntowrite = shf->wp - shf->buf;
			unsigned char *buf = shf->buf;
			int n;

			while (ntowrite > 0) {
				n = write(shf->fd, buf, ntowrite);
				if (n < 0) {
					if (errno == EINTR &&
					    !(shf->flags & SHF_INTERRUPT))
						continue;
					shf->flags |= SHF_ERROR;
					shf->errno_ = errno;
					shf->wnleft = 0;
					if (buf != shf->buf) {
						/* allow a second flush
						 * to work */
						memmove(shf->buf, buf,
						    ntowrite);
						shf->wp = shf->buf + ntowrite;
					}
					return EOF;
				}
				buf += n;
				ntowrite -= n;
			}
			if (flags & EB_READSW) {
				shf->wp = shf->buf;
				shf->wnleft = 0;
				shf->flags &= ~SHF_WRITING;
				return 0;
			}
		}
		shf->wp = shf->buf;
		shf->wnleft = shf->wbsize;
	}
	shf->flags |= SHF_WRITING;

	return ret;
}

/* Fill up a read buffer.  Returns EOF for a read error, 0 otherwise. */
static int
shf_fillbuf(struct shf *shf)
{
	if (shf->flags & SHF_STRING)
		return 0;

	if (shf->fd < 0)
		internal_errorf(1, "shf_fillbuf: no fd");

	if (shf->flags & (SHF_EOF | SHF_ERROR)) {
		if (shf->flags & SHF_ERROR)
			errno = shf->errno_;
		return EOF;
	}

	if ((shf->flags & SHF_WRITING) && shf_emptybuf(shf, EB_READSW) == EOF)
		return EOF;

	shf->flags |= SHF_READING;

	shf->rp = shf->buf;
	while (1) {
		shf->rnleft = blocking_read(shf->fd, (char *) shf->buf,
		    shf->rbsize);
		if (shf->rnleft < 0 && errno == EINTR &&
		    !(shf->flags & SHF_INTERRUPT))
			continue;
		break;
	}
	if (shf->rnleft <= 0) {
		if (shf->rnleft < 0) {
			shf->flags |= SHF_ERROR;
			shf->errno_ = errno;
			shf->rnleft = 0;
			shf->rp = shf->buf;
			return EOF;
		}
		shf->flags |= SHF_EOF;
	}
	return 0;
}

/* Read a buffer from shf.  Returns the number of bytes read into buf,
 * if no bytes were read, returns 0 if end of file was seen, EOF if
 * a read error occurred.
 */
int
shf_read(char *buf, int bsize, struct shf *shf)
{
	int orig_bsize = bsize;
	int ncopy;

	if (!(shf->flags & SHF_RD))
		internal_errorf(1, "shf_read: flags %x", shf->flags);

	if (bsize <= 0)
		internal_errorf(1, "shf_read: bsize %d", bsize);

	while (bsize > 0) {
		if (shf->rnleft == 0 &&
		    (shf_fillbuf(shf) == EOF || shf->rnleft == 0))
			break;
		ncopy = shf->rnleft;
		if (ncopy > bsize)
			ncopy = bsize;
		memcpy(buf, shf->rp, ncopy);
		buf += ncopy;
		bsize -= ncopy;
		shf->rp += ncopy;
		shf->rnleft -= ncopy;
	}
	/* Note: fread(3S) returns 0 for errors - this doesn't */
	return orig_bsize == bsize ? (shf_error(shf) ? EOF : 0) :
	    orig_bsize - bsize;
}

/* Read up to a newline or EOF.  The newline is put in buf; buf is always
 * null terminated.  Returns NULL on read error or if nothing was read before
 * end of file, returns a pointer to the null byte in buf otherwise.
 */
char *
shf_getse(char *buf, int bsize, struct shf *shf)
{
	unsigned char *end;
	int ncopy;
	char *orig_buf = buf;

	if (!(shf->flags & SHF_RD))
		internal_errorf(1, "shf_getse: flags %x", shf->flags);

	if (bsize <= 0)
		return NULL;

	--bsize;	/* save room for null */
	do {
		if (shf->rnleft == 0) {
			if (shf_fillbuf(shf) == EOF)
				return NULL;
			if (shf->rnleft == 0) {
				*buf = '\0';
				return buf == orig_buf ? NULL : buf;
			}
		}
		end = (unsigned char *) memchr((char *) shf->rp, '\n',
		    shf->rnleft);
		ncopy = end ? end - shf->rp + 1 : shf->rnleft;
		if (ncopy > bsize)
			ncopy = bsize;
		memcpy(buf, (char *) shf->rp, ncopy);
		shf->rp += ncopy;
		shf->rnleft -= ncopy;
		buf += ncopy;
		bsize -= ncopy;
	} while (!end && bsize);
	*buf = '\0';
	return buf;
}

/* Returns the char read.  Returns EOF for error and end of file. */
int
shf_getchar(struct shf *shf)
{
	if (!(shf->flags & SHF_RD))
		internal_errorf(1, "shf_getchar: flags %x", shf->flags);

	if (shf->rnleft == 0 && (shf_fillbuf(shf) == EOF || shf->rnleft == 0))
		return EOF;
	--shf->rnleft;
	return *shf->rp++;
}

/* Put a character back in the input stream.  Returns the character if
 * successful, EOF if there is no room.
 */
int
shf_ungetc(int c, struct shf *shf)
{
	if (!(shf->flags & SHF_RD))
		internal_errorf(1, "shf_ungetc: flags %x", shf->flags);

	if ((shf->flags & SHF_ERROR) || c == EOF ||
	    (shf->rp == shf->buf && shf->rnleft))
		return EOF;

	if ((shf->flags & SHF_WRITING) && shf_emptybuf(shf, EB_READSW) == EOF)
		return EOF;

	if (shf->rp == shf->buf)
		shf->rp = shf->buf + shf->rbsize;
	if (shf->flags & SHF_STRING) {
		/* Can unget what was read, but not something different - we
		 * don't want to modify a string.
		 */
		if (shf->rp[-1] != c)
			return EOF;
		shf->flags &= ~SHF_EOF;
		shf->rp--;
		shf->rnleft++;
		return c;
	}
	shf->flags &= ~SHF_EOF;
	*--(shf->rp) = c;
	shf->rnleft++;
	return c;
}

/* Write a character.  Returns the character if successful, EOF if
 * the char could not be written.
 */
int
shf_putchar(int c, struct shf *shf)
{
	if (!(shf->flags & SHF_WR))
		internal_errorf(1, "shf_putchar: flags %x", shf->flags);

	if (c == EOF)
		return EOF;

	if (shf->flags & SHF_UNBUF) {
		char cc = c;
		int n;

		if (shf->fd < 0)
			internal_errorf(1, "shf_putchar: no fd");
		if (shf->flags & SHF_ERROR) {
			errno = shf->errno_;
			return EOF;
		}
		while ((n = write(shf->fd, &cc, 1)) != 1)
			if (n < 0) {
				if (errno == EINTR &&
				    !(shf->flags & SHF_INTERRUPT))
					continue;
				shf->flags |= SHF_ERROR;
				shf->errno_ = errno;
				return EOF;
			}
	} else {
		/* Flush deals with strings and sticky errors */
		if (shf->wnleft == 0 && shf_emptybuf(shf, EB_GROW) == EOF)
			return EOF;
		shf->wnleft--;
		*shf->wp++ = c;
	}

	return c;
}

/* Write a string.  Returns the length of the string if successful, EOF if
 * the string could not be written.
 */
int
shf_puts(const char *s, struct shf *shf)
{
	if (!s)
		return EOF;

	return shf_write(s, strlen(s), shf);
}

/* Write a buffer.  Returns nbytes if successful, EOF if there is an error. */
int
shf_write(const char *buf, int nbytes, struct shf *shf)
{
	int orig_nbytes = nbytes;
	int n;
	int ncopy;

	if (!(shf->flags & SHF_WR))
		internal_errorf(1, "shf_write: flags %x", shf->flags);

	if (nbytes < 0)
		internal_errorf(1, "shf_write: nbytes %d", nbytes);

	/* Don't buffer if buffer is empty and we're writting a large amount. */
	if ((ncopy = shf->wnleft) &&
	    (shf->wp != shf->buf || nbytes < shf->wnleft)) {
		if (ncopy > nbytes)
			ncopy = nbytes;
		memcpy(shf->wp, buf, ncopy);
		nbytes -= ncopy;
		buf += ncopy;
		shf->wp += ncopy;
		shf->wnleft -= ncopy;
	}
	if (nbytes > 0) {
		/* Flush deals with strings and sticky errors */
		if (shf_emptybuf(shf, EB_GROW) == EOF)
			return EOF;
		if (nbytes > shf->wbsize) {
			ncopy = nbytes;
			if (shf->wbsize)
				ncopy -= nbytes % shf->wbsize;
			nbytes -= ncopy;
			while (ncopy > 0) {
				n = write(shf->fd, buf, ncopy);
				if (n < 0) {
					if (errno == EINTR &&
					    !(shf->flags & SHF_INTERRUPT))
						continue;
					shf->flags |= SHF_ERROR;
					shf->errno_ = errno;
					shf->wnleft = 0;
					/* Note: fwrite(3S) returns 0 for
					 * errors - this doesn't */
					return EOF;
				}
				buf += n;
				ncopy -= n;
			}
		}
		if (nbytes > 0) {
			memcpy(shf->wp, buf, nbytes);
			shf->wp += nbytes;
			shf->wnleft -= nbytes;
		}
	}

	return orig_nbytes;
}

int
shf_fprintf(struct shf *shf, const char *fmt, ...)
{
	va_list args;
	int n;

	va_start(args, fmt);
	n = shf_vfprintf(shf, fmt, args);
	va_end(args);

	return n;
}

int
shf_snprintf(char *buf, int bsize, const char *fmt, ...)
{
	struct shf shf;
	va_list args;
	int n;

	if (!buf || bsize <= 0)
		internal_errorf(1, "shf_snprintf: buf %lx, bsize %d",
			(long) buf, bsize);

	shf_sopen(buf, bsize, SHF_WR, &shf);
	va_start(args, fmt);
	n = shf_vfprintf(&shf, fmt, args);
	va_end(args);
	shf_sclose(&shf); /* null terminates */
	return n;
}

char *
shf_smprintf(const char *fmt, ...)
{
	struct shf shf;
	va_list args;

	shf_sopen(NULL, 0, SHF_WR|SHF_DYNAMIC, &shf);
	va_start(args, fmt);
	shf_vfprintf(&shf, fmt, args);
	va_end(args);
	return shf_sclose(&shf); /* null terminates */
}

#define	FL_HASH		0x001	/* `#' seen */
#define FL_PLUS		0x002	/* `+' seen */
#define FL_RIGHT	0x004	/* `-' seen */
#define FL_BLANK	0x008	/* ` ' seen */
#define FL_SHORT	0x010	/* `h' seen */
#define FL_LONG		0x020	/* `l' seen */
#define FL_LLONG	0x040	/* `ll' seen */
#define FL_ZERO		0x080	/* `0' seen */
#define FL_DOT		0x100	/* '.' seen */
#define FL_UPPER	0x200	/* format character was uppercase */
#define FL_NUMBER	0x400	/* a number was formated %[douxefg] */

int
shf_vfprintf(struct shf *shf, const char *fmt, va_list args)
{
	char		c, *s;
	int		tmp = 0;
	int		field, precision;
	int		len;
	int		flags;
	unsigned long long	llnum;
					/* %#o produces the longest output */
	char		numbuf[(BITS(long long) + 2) / 3 + 1];
	/* this stuff for dealing with the buffer */
	int		nwritten = 0;

	if (!fmt)
		return 0;

	while ((c = *fmt++)) {
		if (c != '%') {
			shf_putc(c, shf);
			nwritten++;
			continue;
		}
		/*
		 *	This will accept flags/fields in any order - not
		 *  just the order specified in printf(3), but this is
		 *  the way _doprnt() seems to work (on bsd and sysV).
		 *  The only restriction is that the format character must
		 *  come last :-).
		 */
		flags = field = precision = 0;
		for ( ; (c = *fmt++) ; ) {
			switch (c) {
			case '#':
				flags |= FL_HASH;
				continue;

			case '+':
				flags |= FL_PLUS;
				continue;

			case '-':
				flags |= FL_RIGHT;
				continue;

			case ' ':
				flags |= FL_BLANK;
				continue;

			case '0':
				if (!(flags & FL_DOT))
					flags |= FL_ZERO;
				continue;

			case '.':
				flags |= FL_DOT;
				precision = 0;
				continue;

			case '*':
				tmp = va_arg(args, int);
				if (flags & FL_DOT)
					precision = tmp;
				else if ((field = tmp) < 0) {
					field = -field;
					flags |= FL_RIGHT;
				}
				continue;

			case 'l':
				if (*fmt == 'l') {
					fmt++;
					flags |= FL_LLONG;
				} else
					flags |= FL_LONG;
				continue;

			case 'h':
				flags |= FL_SHORT;
				continue;
			}
			if (digit(c)) {
				tmp = c - '0';
				while (c = *fmt++, digit(c))
					tmp = tmp * 10 + c - '0';
				--fmt;
				if (tmp < 0)		/* overflow? */
					tmp = 0;
				if (flags & FL_DOT)
					precision = tmp;
				else
					field = tmp;
				continue;
			}
			break;
		}

		if (precision < 0)
			precision = 0;

		if (!c)		/* nasty format */
			break;

		if (c >= 'A' && c <= 'Z') {
			flags |= FL_UPPER;
			c = c - 'A' + 'a';
		}

		switch (c) {
		case 'p': /* pointer */
			flags &= ~(FL_LLONG | FL_SHORT);
			flags |= FL_LONG;
			/* aaahhh... */
		case 'd':
		case 'i':
		case 'o':
		case 'u':
		case 'x':
			flags |= FL_NUMBER;
			s = &numbuf[sizeof(numbuf)];
			if (flags & FL_LLONG)
				llnum = va_arg(args, unsigned long long);
			else if (flags & FL_LONG) {
				if (c == 'd' || c == 'i')
					llnum = va_arg(args, long);
				else
					llnum = va_arg(args, unsigned long);
			} else {
				if (c == 'd' || c == 'i')
					llnum = va_arg(args, int);
				else
					llnum = va_arg(args, unsigned int);
			}
			switch (c) {
			case 'd':
			case 'i':
				if (0 > (long long) llnum)
					llnum = - (long long) llnum, tmp = 1;
				else
					tmp = 0;
				/* aaahhhh..... */

			case 'u':
				do {
					*--s = llnum % 10 + '0';
					llnum /= 10;
				} while (llnum);

				if (c != 'u') {
					if (tmp)
						*--s = '-';
					else if (flags & FL_PLUS)
						*--s = '+';
					else if (flags & FL_BLANK)
						*--s = ' ';
				}
				break;

			case 'o':
				do {
					*--s = (llnum & 0x7) + '0';
					llnum >>= 3;
				} while (llnum);

				if ((flags & FL_HASH) && *s != '0')
					*--s = '0';
				break;

			case 'p':
			case 'x':
			    {
				const char *digits = (flags & FL_UPPER) ?
				    "0123456789ABCDEF" :
				    "0123456789abcdef";
				do {
					*--s = digits[llnum & 0xf];
					llnum >>= 4;
				} while (llnum);

				if (flags & FL_HASH) {
					*--s = (flags & FL_UPPER) ? 'X' : 'x';
					*--s = '0';
				}
			    }
			}
			len = &numbuf[sizeof(numbuf)] - s;
			if (flags & FL_DOT) {
				if (precision > len) {
					field = precision;
					flags |= FL_ZERO;
				} else
					precision = len; /* no loss */
			}
			break;

		case 's':
			if (!(s = va_arg(args, char *)))
				s = "(null %s)";
			len = strlen(s);
			break;

		case 'c':
			flags &= ~FL_DOT;
			numbuf[0] = va_arg(args, int);
			s = numbuf;
			len = 1;
			break;

		case '%':
		default:
			numbuf[0] = c;
			s = numbuf;
			len = 1;
			break;
		}

		/*
		 *	At this point s should point to a string that is
		 *  to be formatted, and len should be the length of the
		 *  string.
		 */
		if (!(flags & FL_DOT) || len < precision)
			precision = len;
		if (field > precision) {
			field -= precision;
			if (!(flags & FL_RIGHT)) {
				field = -field;
				/* skip past sign or 0x when padding with 0 */
				if ((flags & FL_ZERO) && (flags & FL_NUMBER)) {
					if (*s == '+' || *s == '-' || *s ==' ') {
						shf_putc(*s, shf);
						s++;
						precision--;
						nwritten++;
					} else if (*s == '0') {
						shf_putc(*s, shf);
						s++;
						nwritten++;
						if (--precision > 0 &&
						    (*s | 0x20) == 'x') {
							shf_putc(*s, shf);
							s++;
							precision--;
							nwritten++;
						}
					}
					c = '0';
				} else
					c = flags & FL_ZERO ? '0' : ' ';
				if (field < 0) {
					nwritten += -field;
					for ( ; field < 0 ; field++)
						shf_putc(c, shf);
				}
			} else
				c = ' ';
		} else
			field = 0;

		if (precision > 0) {
			nwritten += precision;
			for ( ; precision-- > 0 ; s++)
				shf_putc(*s, shf);
		}
		if (field > 0) {
			nwritten += field;
			for ( ; field > 0 ; --field)
				shf_putc(c, shf);
		}
	}

	return shf_error(shf) ? EOF : nwritten;
}
@


1.30
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.29 2015/11/12 04:04:31 mmcc Exp $	*/
d82 1
a82 1
		int flags = fcntl(fd, F_GETFL, 0);
d139 1
a139 1
		int flags = fcntl(fd, F_GETFL, 0);
@


1.29
log
@Use isdigit() instead of ksh's homebrewed alternative.

ok nicm@@. Also discussed with millert@@ and guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.28 2015/11/01 23:31:54 mmcc Exp $	*/
d10 2
d13 1
d15 1
@


1.28
log
@aresize() -> areallocarray()

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.27 2015/11/01 15:43:55 mmcc Exp $	*/
d9 1
@


1.27
log
@Drop a needless cast of a void *.
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.26 2015/10/23 17:22:43 mmcc Exp $	*/
d333 1
a333 1
		nbuf = aresize(shf->buf, shf->wbsize * 2, shf->areap);
@


1.26
log
@Remove three strange and unused preproc defines. Submitted by Ilya
Kaliman.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.25 2015/10/19 14:42:16 mmcc Exp $	*/
d333 1
a333 2
		nbuf = (unsigned char *) aresize(shf->buf, shf->wbsize * 2,
		    shf->areap);
@


1.25
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.24 2015/10/19 14:03:21 mmcc Exp $	*/
a709 4
#define BUF_SIZE	128
#define ABIGNUM		32000	/* big number that will fit in a short */
#define LOG2_10		3.321928094887362347870319429	/* log base 2 of 10 */

a720 1

@


1.24
log
@Move limits.h include from sh.h to the files that actually need it. No
binary change.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.23 2015/10/19 02:15:45 mmcc Exp $	*/
d10 1
@


1.23
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.22 2015/09/18 07:28:24 nicm Exp $	*/
d8 2
@


1.22
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.21 2015/09/17 14:21:33 nicm Exp $	*/
a6 1
#include "sh.h"
d9 1
@


1.21
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.20 2015/09/15 20:59:05 nicm Exp $	*/
d102 1
a102 1
			shf->buf = (unsigned char *) 0;
@


1.20
log
@Expand the one use of POP_INT() macro into if()s and fix some errors
(now that llnum is long long, int needs to be sign extended on all
platforms, not just when sizeof(int) < sizeof(long); and sign extend
%ld, %li and %i as well as %d. Also simplify the code for %p since
pointers are always sizeof (long).

ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.19 2015/09/15 18:15:05 tedu Exp $	*/
d36 1
a36 1
	shf = (struct shf *) alloc(sizeof(struct shf) + bsize, ATEMP);
d99 1
a99 1
			shf->buf = (unsigned char *) alloc(bsize, ATEMP);
d104 1
a104 1
		shf = (struct shf *) alloc(sizeof(struct shf) + bsize, ATEMP);
d187 1
a187 1
		shf = (struct shf *) alloc(sizeof(struct shf), ATEMP);
@


1.19
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.18 2015/09/14 09:42:33 nicm Exp $	*/
d708 1
a708 17

/*
 *	What kinda of machine we on?  Hopefully the C compiler will optimize
 *  this out...
 *
 *	For shorts, we want sign extend for %d but not for %[oxu] - on 16 bit
 *  machines it don't matter.  Assumes C compiler has converted shorts to
 *  ints before pushing them.
 */
#define POP_INT(f, s, a) \
	(((f) & FL_LLONG) ? va_arg((a), unsigned long long) :		\
	    ((f) & FL_LONG) ? va_arg((a), unsigned long) :		\
	    (sizeof(int) < sizeof(long) ? ((s) ?			\
	    (long) va_arg((a), int) : va_arg((a), unsigned)) :		\
	    va_arg((a), unsigned)))

#define ABIGNUM		32000	/* big numer that will fit in a short */
d834 2
a835 3
			flags &= ~(FL_LLONG | FL_LONG | FL_SHORT);
			if (sizeof(char *) > sizeof(int))
				flags |= FL_LONG; /* hope it fits.. */
d844 13
a856 1
			llnum = POP_INT(flags, c == 'd', args);
@


1.18
log
@Apply the ancient art of tedu to ksh_limval.h. ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.17 2015/09/13 19:43:42 tedu Exp $	*/
d472 1
a472 1
		return (char *) 0;
d700 1
a700 1
	shf_sopen((char *) 0, 0, SHF_WR|SHF_DYNAMIC, &shf);
@


1.17
log
@zap unused FP support. from Michael McConville. ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.16 2013/04/19 17:36:09 millert Exp $	*/
a8 1
#include "ksh_limval.h"
@


1.16
log
@Add support for printing long long (%lld).  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.15 2006/04/02 00:48:33 deraadt Exp $	*/
a707 2
#undef FP			/* if you want floating point stuff */

a708 6
#define FPBUF_SIZE	(DMAXEXP+16)/* this must be >
				 *	MAX(DMAXEXP, log10(pow(2, DSIGNIF)))
				 *    + ceil(log10(DMAXEXP)) + 8 (I think).
				 * Since this is hard to express as a
				 * constant, just use a large buffer.
				 */
a740 12
#ifdef FP
#include <math.h>

static double
my_ceil(double d)
{
	double		i;

	return d - modf(d, &i) + (d < 0 ? -1 : 1);
}
#endif /* FP */

a753 11
#ifdef FP
	/* should be in <math.h>
	 *  extern double frexp();
	 */
	extern char *ecvt();

	double		fpnum;
	int		expo, decpt;
	char		style;
	char		fpbuf[FPBUF_SIZE];
#endif /* FP */
a923 128

#ifdef FP
		case 'e':
		case 'g':
		case 'f':
		    {
			char *p;

			/*
			 *	This could probably be done better,
			 *  but it seems to work.  Note that gcvt()
			 *  is not used, as you cannot tell it to
			 *  not strip the zeros.
			 */
			flags |= FL_NUMBER;
			if (!(flags & FL_DOT))
				precision = 6;	/* default */
			/*
			 *	Assumes doubles are pushed on
			 *  the stack.  If this is not so, then
			 *  FL_LLONG/FL_LONG/FL_SHORT should be checked.
			 */
			fpnum = va_arg(args, double);
			s = fpbuf;
			style = c;
			/*
			 *  This is the same as
			 *	expo = ceil(log10(fpnum))
			 *  but doesn't need -lm.  This is an
			 *  approximation as expo is rounded up.
			 */
			(void) frexp(fpnum, &expo);
			expo = my_ceil(expo / LOG2_10);

			if (expo < 0)
				expo = 0;

			p = ecvt(fpnum, precision + 1 + expo,
				 &decpt, &tmp);
			if (c == 'g') {
				if (decpt < -4 || decpt > precision)
					style = 'e';
				else
					style = 'f';
				if (decpt > 0 && (precision -= decpt) < 0)
					precision = 0;
			}
			if (tmp)
				*s++ = '-';
			else if (flags & FL_PLUS)
				*s++ = '+';
			else if (flags & FL_BLANK)
				*s++ = ' ';

			if (style == 'e')
				*s++ = *p++;
			else {
				if (decpt > 0) {
					/* Overflow check - should
					 * never have this problem.
					 */
					if (decpt > &fpbuf[sizeof(fpbuf)] - s - 8)
						decpt = &fpbuf[sizeof(fpbuf)] - s - 8;
					(void) memcpy(s, p, decpt);
					s += decpt;
					p += decpt;
				} else
					*s++ = '0';
			}

			/* print the fraction? */
			if (precision > 0) {
				*s++ = '.';
				/* Overflow check - should
				 * never have this problem.
				 */
				if (precision > &fpbuf[sizeof(fpbuf)] - s - 7)
					precision = &fpbuf[sizeof(fpbuf)] - s - 7;
				for (tmp = decpt;  tmp++ < 0 &&
					    precision > 0 ; precision--)
					*s++ = '0';
				tmp = strlen(p);
				if (precision > tmp)
					precision = tmp;
				/* Overflow check - should
				 * never have this problem.
				 */
				if (precision > &fpbuf[sizeof(fpbuf)] - s - 7)
					precision = &fpbuf[sizeof(fpbuf)] - s - 7;
				(void) memcpy(s, p, precision);
				s += precision;
				/*
				 *	`g' format strips trailing
				 *  zeros after the decimal.
				 */
				if (c == 'g' && !(flags & FL_HASH)) {
					while (*--s == '0')
						;
					if (*s != '.')
						s++;
				}
			} else if (flags & FL_HASH)
				*s++ = '.';

			if (style == 'e') {
				*s++ = (flags & FL_UPPER) ? 'E' : 'e';
				if (--decpt >= 0)
					*s++ = '+';
				else {
					*s++ = '-';
					decpt = -decpt;
				}
				p = &numbuf[sizeof(numbuf)];
				for (tmp = 0; tmp < 2 || decpt ; tmp++) {
					*--p = '0' + decpt % 10;
					decpt /= 10;
				}
				tmp = &numbuf[sizeof(numbuf)] - p;
				(void) memcpy(s, p, tmp);
				s += tmp;
			}

			len = s - fpbuf;
			s = fpbuf;
			precision = len;
			break;
		    }
#endif /* FP */
@


1.15
log
@use SEEK_* for lseek()
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.14 2005/12/11 18:53:51 deraadt Exp $	*/
d727 2
a728 1
	(((f) & FL_LONG) ? va_arg((a), unsigned long) :			\
d742 5
a746 4
#define FL_ZERO		0x040	/* `0' seen */
#define FL_DOT		0x080	/* '.' seen */
#define FL_UPPER	0x100	/* format character was uppercase */
#define FL_NUMBER	0x200	/* a number was formated %[douxefg] */
d769 1
a769 1
	unsigned long	lnum;
d771 1
a771 1
	char		numbuf[(BITS(long) + 2) / 3 + 1];
d842 5
a846 1
				flags |= FL_LONG;
d882 1
a882 1
			flags &= ~(FL_LONG | FL_SHORT);
d893 1
a893 1
			lnum = POP_INT(flags, c == 'd', args);
d897 2
a898 2
				if (0 > (long) lnum)
					lnum = - (long) lnum, tmp = 1;
d905 3
a907 3
					*--s = lnum % 10 + '0';
					lnum /= 10;
				} while (lnum);
d921 3
a923 3
					*--s = (lnum & 0x7) + '0';
					lnum >>= 3;
				} while (lnum);
d936 3
a938 3
					*--s = digits[lnum & 0xf];
					lnum >>= 4;
				} while (lnum);
d975 1
a975 1
			 *  FL_LONG/FL_SHORT should be checked.
@


1.14
log
@remove unused variables and functions
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.13 2005/03/30 17:16:37 deraadt Exp $	*/
d288 1
a288 1
			lseek(shf->fd, (off_t) -shf->rnleft, 1);
@


1.13
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.12 2005/03/28 21:28:22 deraadt Exp $	*/
a267 16
/* Flush and free file structure, don't close file descriptor */
int
shf_finish(struct shf *shf)
{
	int ret = 0;

	if (shf->fd >= 0)
		ret = shf_flush(shf);
	if (shf->flags & SHF_ALLOCS)
		afree(shf, shf->areap);
	else if (shf->flags & SHF_ALLOCB)
		afree(shf->buf, shf->areap);

	return ret;
}

a422 44

/* Seek to a new position in the file.  If writing, flushes the buffer
 * first.  If reading, optimizes small relative seeks that stay inside the
 * buffer.  Returns 0 for success, EOF otherwise.
 */
int
shf_seek(struct shf *shf, off_t where, int from)
{
	if (shf->fd < 0) {
		errno = EINVAL;
		return EOF;
	}

	if (shf->flags & SHF_ERROR) {
		errno = shf->errno_;
		return EOF;
	}

	if ((shf->flags & SHF_WRITING) && shf_emptybuf(shf, EB_READSW) == EOF)
		return EOF;

	if (shf->flags & SHF_READING) {
		if (from == SEEK_CUR &&
		    (where < 0 ? -where >= shf->rbsize - shf->rnleft :
		    where < shf->rnleft)) {
			shf->rnleft -= where;
			shf->rp += where;
			return 0;
		}
		shf->rnleft = 0;
		shf->rp = shf->buf;
	}

	shf->flags &= ~(SHF_EOF | SHF_READING | SHF_WRITING);

	if (lseek(shf->fd, where, from) < 0) {
		shf->errno_ = errno;
		shf->flags |= SHF_ERROR;
		return EOF;
	}

	return 0;
}

@


1.12
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.11 2004/12/20 11:34:26 otto Exp $	*/
d61 2
a62 3
	sflags |= (oflags & O_ACCMODE) == O_RDONLY ? SHF_RD
		  : ((oflags & O_ACCMODE) == O_WRONLY ? SHF_WR
		     : SHF_RDWR);
d80 1
a80 1
		else
d82 9
a90 3
			case O_RDONLY: sflags |= SHF_RD; break;
			case O_WRONLY: sflags |= SHF_WR; break;
			case O_RDWR: sflags |= SHF_RDWR; break;
d92 1
d137 1
a137 1
		else
d139 9
a147 3
			case O_RDONLY: sflags |= SHF_RD; break;
			case O_WRONLY: sflags |= SHF_WR; break;
			case O_RDWR: sflags |= SHF_RDWR; break;
d149 1
d183 2
a184 2
	if (!(sflags & (SHF_RD | SHF_WR))
	    || (sflags & (SHF_RD | SHF_WR)) == (SHF_RD | SHF_WR))
d343 2
a344 2
		if (!(flags & EB_GROW) || !(shf->flags & SHF_DYNAMIC)
		    || !(shf->flags & SHF_ALLOCB))
d348 1
a348 1
						shf->areap);
d364 2
a365 2
					if (errno == EINTR
					    && !(shf->flags & SHF_INTERRUPT))
d374 1
a374 1
							ntowrite);
d421 3
a423 3
					    shf->rbsize);
		if (shf->rnleft < 0 && errno == EINTR
		    && !(shf->flags & SHF_INTERRUPT))
d462 2
a463 3
				(where < 0 ?
					-where >= shf->rbsize - shf->rnleft :
					where < shf->rnleft)) {
d501 2
a502 2
		if (shf->rnleft == 0
		    && (shf_fillbuf(shf) == EOF || shf->rnleft == 0))
d514 2
a515 2
	return orig_bsize == bsize ? (shf_error(shf) ? EOF : 0)
				   : orig_bsize - bsize;
d546 1
a546 1
					     shf->rnleft);
d582 2
a583 2
	if ((shf->flags & SHF_ERROR) || c == EOF
	    || (shf->rp == shf->buf && shf->rnleft))
d632 2
a633 2
				if (errno == EINTR
				    && !(shf->flags & SHF_INTERRUPT))
d677 2
a678 3
	if ((ncopy = shf->wnleft)
	    && (shf->wp != shf->buf || nbytes < shf->wnleft))
	{
d699 2
a700 2
					if (errno == EINTR
					    && !(shf->flags & SHF_INTERRUPT))
d786 5
a790 10
#define POP_INT(f, s, a) (((f) & FL_LONG) ?				\
				va_arg((a), unsigned long)		\
			    :						\
				(sizeof(int) < sizeof(long) ?		\
					((s) ?				\
						(long) va_arg((a), int)	\
					    :				\
						va_arg((a), unsigned))	\
				    :					\
					va_arg((a), unsigned)))
d987 2
a988 2
						  "0123456789ABCDEF"
						: "0123456789abcdef";
d1070 2
a1071 6
					if (decpt >
						&fpbuf[sizeof(fpbuf)]
							- s - 8)
						decpt =
						 &fpbuf[sizeof(fpbuf)]
							- s - 8;
d1085 2
a1086 5
				if (precision > &fpbuf[sizeof(fpbuf)]
							- s - 7)
					precision =
						&fpbuf[sizeof(fpbuf)]
						- s - 7;
d1096 2
a1097 5
				if (precision > &fpbuf[sizeof(fpbuf)]
							- s - 7)
					precision =
						&fpbuf[sizeof(fpbuf)]
						- s - 7;
d1172 1
a1172 2
					if (*s == '+' || *s == '-' || *s ==' ')
					{
d1182 1
a1182 2
							(*s | 0x20) == 'x')
						{
@


1.11
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.10 2004/12/18 22:35:41 millert Exp $	*/
d757 1
a757 1
#undef FP  			/* if you want floating point stuff */
@


1.10
log
@Replace fd_clexec() with calls to fcntl(fd, F_SETFD, FD_CLOEXEC)
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.9 2004/12/18 20:55:52 millert Exp $	*/
d22 2
a23 2
static int	shf_fillbuf(struct shf *shf);
static int	shf_emptybuf(struct shf *shf, int flags);
d30 1
a30 5
shf_open(name, oflags, mode, sflags)
	const char *name;
	int oflags;
	int mode;
	int sflags;
d70 1
a70 4
shf_fdopen(fd, sflags, shf)
	int fd;
	int sflags;
	struct shf *shf;
d120 1
a120 4
shf_reopen(fd, sflags, shf)
	int fd;
	int sflags;
	struct shf *shf;
d167 1
a167 5
shf_sopen(buf, bsize, sflags, shf)
	char *buf;
	int bsize;
	int sflags;
	struct shf *shf;
d200 1
a200 2
shf_close(shf)
	struct shf *shf;
d219 1
a219 2
shf_fdclose(shf)
	struct shf *shf;
d241 1
a241 2
shf_sclose(shf)
	struct shf *shf;
d257 1
a257 2
shf_finish(shf)
	struct shf *shf;
d275 1
a275 2
shf_flush(shf)
	struct shf *shf;
d306 1
a306 3
shf_emptybuf(shf, flags)
	struct shf *shf;
	int flags;
d386 1
a386 2
shf_fillbuf(shf)
	struct shf *shf;
d432 1
a432 4
shf_seek(shf, where, from)
	struct shf *shf;
	off_t where;
	int from;
d477 1
a477 4
shf_read(buf, bsize, shf)
	char *buf;
	int bsize;
	struct shf *shf;
d511 1
a511 4
shf_getse(buf, bsize, shf)
	char *buf;
	int bsize;
	struct shf *shf;
d550 1
a550 2
shf_getchar(shf)
	struct shf *shf;
d565 1
a565 3
shf_ungetc(c, shf)
	int c;
	struct shf *shf;
d600 1
a600 3
shf_putchar(c, shf)
	int c;
	struct shf *shf;
d642 1
a642 3
shf_puts(s, shf)
	const char *s;
	struct shf *shf;
d652 1
a652 4
shf_write(buf, nbytes, shf)
	const char *buf;
	int nbytes;
	struct shf *shf;
d805 1
a805 2
my_ceil(d)
	double	d;
d814 1
a814 4
shf_vfprintf(shf, fmt, args)
	struct shf *shf;
	const char *fmt;
	va_list args;
@


1.9
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.8 2003/02/28 09:45:09 jmc Exp $	*/
d121 1
a121 1
		fd_clexec(fd);
d164 1
a164 1
		fd_clexec(fd);
@


1.8
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.7 2000/11/21 23:12:04 millert Exp $	*/
d8 1
a8 1
#include "ksh_stat.h"
d22 2
a23 2
static int	shf_fillbuf	ARGS((struct shf *shf));
static int	shf_emptybuf	ARGS((struct shf *shf, int flags));
d56 1
a56 1
		nfd = ksh_dupbase(fd, FDBASE);
a573 8
#ifdef OS2
		if (end && buf > orig_buf + 1 && buf[-2] == '\r') {
			buf--;
			bsize++;
			buf[-1] = '\n';
		}
#endif

a753 1
#ifdef HAVE_PROTOTYPES
a754 6
#else
shf_fprintf(shf, fmt, va_alist)
	struct shf *shf;
	const char *fmt;
	va_dcl
#endif
d759 1
a759 1
	SH_VA_START(args, fmt);
a766 1
#ifdef HAVE_PROTOTYPES
a767 7
#else
shf_snprintf(buf, bsize, fmt, va_alist)
	char *buf;
	int bsize;
	const char *fmt;
	va_dcl
#endif
d778 1
a778 1
	SH_VA_START(args, fmt);
a785 1
#ifdef HAVE_PROTOTYPES
a786 5
#else
shf_smprintf(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
d792 1
a792 1
	SH_VA_START(args, fmt);
d862 1
a862 1
	int		UNINITIALIZED(tmp);
@


1.7
log
@Bug fixes from pdksh-5.2.14-patches.1:
 o set -x dumps core (shf.c);
 o "typeset -r foo=bar" fails saying foo is readonly (var.c).
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.6 1999/06/15 01:18:36 millert Exp $	*/
d842 1
a842 1
 *  machines it don't matter.  Assmumes C compiler has converted shorts to
d925 1
a925 1
		 *  The only resriction is that the format character must
d1086 1
a1086 1
			 *	This could proabably be done better,
d1106 1
a1106 1
			 *  aproximation as expo is rounded up.
@


1.6
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.5 1999/01/19 20:41:56 millert Exp $	*/
a359 1
		shf->wbsize += shf->wbsize;
@


1.5
log
@Updates from pdksh-unstable-5.2.13.7.  Most notable change is:
    trap: exit traps now executed in subshells (without explicit exit call).
See the Changelog for a full list of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.4 1998/10/29 04:09:21 millert Exp $	*/
d36 2
d40 8
d49 2
a50 1
	if (fd < 0)
d52 1
d58 2
a59 1
		if (nfd < 0)
d61 1
d69 1
a69 1
	return shf_fdopen(fd, sflags, (struct shf *) 0);
d714 4
a717 1
	if ((ncopy = shf->wnleft)) {
@


1.4
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.3 1997/06/19 13:58:46 kstailey Exp $	*/
d561 8
@


1.3
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
d1101 1
a1101 1
				*--s = '-';
d1103 1
a1103 1
				*--s = '+';
d1105 1
a1105 1
				*--s = ' ';
@


1.2
log
@(foo *)0 -> NULL
@
text
@d55 1
a55 1
	return shf_fdopen(fd, sflags, NULL);
d90 1
a90 1
			shf->buf = NULL;
d539 1
a539 1
		return NULL;
d796 1
a796 1
	shf_sopen(NULL, 0, SHF_WR|SHF_DYNAMIC, &shf);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 1
a55 1
	return shf_fdopen(fd, sflags, (struct shf *) 0);
d90 1
a90 1
			shf->buf = (unsigned char *) 0;
d539 1
a539 1
		return (char *) 0;
d796 1
a796 1
	shf_sopen((char *) 0, 0, SHF_WR|SHF_DYNAMIC, &shf);
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
