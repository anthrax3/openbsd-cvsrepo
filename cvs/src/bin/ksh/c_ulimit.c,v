head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.6
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.19.0.10
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.17.0.22
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.20
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.18
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.16
	OPENBSD_5_0:1.17.0.14
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.12
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.10
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.6
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.6
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.12
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.10
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.6
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.23;
commitid	btTCreDA00YdaFhU;

1.23
date	2015.11.12.04.04.31;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	QvyWaajN4Lc4MRtd;

1.22
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	C4W85jmosThChWA2;

1.21
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	16HUr75moyUNtKR8;

1.20
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.19;
commitid	lBs9un9sXhbdfVrQ;

1.19
date	2013.11.28.10.33.37;	author sobrado;	state Exp;
branches;
next	1.18;

1.18
date	2013.11.14.15.23.30;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.21.12.51.19;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2006.11.20.21.53.39;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.12.00.26.58;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.02.07.53.01;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.22.07.40.38;	author jmc;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	99.06.15.01.18.33;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.01.08.20.24.57;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.11.24.04.32.47;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.10.29.04.09.20;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.01.17.19.00.44;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.06.19.13.58.39;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	97.06.18.22.42.30;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.10;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.10;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@/*	$OpenBSD: c_ulimit.c,v 1.23 2015/11/12 04:04:31 mmcc Exp $	*/

/*
	ulimit -- handle "ulimit" builtin

	Reworked to use getrusage() and ulimit() at once (as needed on
	some schizophrenic systems, eg, HP-UX 9.01), made argument parsing
	conform to at&t ksh, added autoconf support.  Michael Rendell, May, '94

	Eric Gisin, September 1988
	Adapted to PD KornShell. Removed AT&T code.

	last edit:	06-Jun-1987	D A Gwyn

	This started out as the BRL UNIX System V system call emulation
	for 4.nBSD, and was later extended by Doug Kingston to handle
	the extended 4.nBSD resource limits.  It now includes the code
	that was originally under case SYSULIMIT in source file "xec.c".
*/

#include <sys/resource.h>

#include <ctype.h>
#include <errno.h>
#include <string.h>

#include "sh.h"

#define SOFT	0x1
#define HARD	0x2

struct limits {
	const char *name;
	int	resource;	/* resource to get/set */
	int	factor;		/* multiply by to get rlim_{cur,max} values */
	char	option;		/* option character (-d, -f, ...) */
};

static void print_ulimit(const struct limits *, int);
static int set_ulimit(const struct limits *, const char *, int);

int
c_ulimit(char **wp)
{
	static const struct limits limits[] = {
		/* Do not use options -H, -S or -a or change the order. */
		{ "time(cpu-seconds)", RLIMIT_CPU, 1, 't' },
		{ "file(blocks)", RLIMIT_FSIZE, 512, 'f' },
		{ "coredump(blocks)", RLIMIT_CORE, 512, 'c' },
		{ "data(kbytes)", RLIMIT_DATA, 1024, 'd' },
		{ "stack(kbytes)", RLIMIT_STACK, 1024, 's' },
		{ "lockedmem(kbytes)", RLIMIT_MEMLOCK, 1024, 'l' },
		{ "memory(kbytes)", RLIMIT_RSS, 1024, 'm' },
		{ "nofiles(descriptors)", RLIMIT_NOFILE, 1, 'n' },
		{ "processes", RLIMIT_NPROC, 1, 'p' },
#ifdef RLIMIT_VMEM
		{ "vmemory(kbytes)", RLIMIT_VMEM, 1024, 'v' },
#endif /* RLIMIT_VMEM */
		{ NULL }
	};
	static char	options[4 + NELEM(limits) * 2];
	int		how = SOFT | HARD;
	const struct limits	*l;
	int		optc, all = 0;

	if (!options[0]) {
		/* build options string on first call - yuck */
		char *p = options;

		*p++ = 'H'; *p++ = 'S'; *p++ = 'a';
		for (l = limits; l->name; l++) {
			*p++ = l->option;
			*p++ = '#';
		}
		*p = '\0';
	}
	/* First check for -a, -H and -S. */
	while ((optc = ksh_getopt(wp, &builtin_opt, options)) != -1)
		switch (optc) {
		case 'H':
			how = HARD;
			break;
		case 'S':
			how = SOFT;
			break;
		case 'a':
			all = 1;
			break;
		case '?':
			return 1;
		default:
			break;
		}

	if (wp[builtin_opt.optind] != NULL) {
		bi_errorf("usage: ulimit [-acdfHlmnpSst] [value]");
		return 1;
	}

	/* Then parse and act on the actual limits, one at a time */
	ksh_getopt_reset(&builtin_opt, GF_ERROR);
	while ((optc = ksh_getopt(wp, &builtin_opt, options)) != -1)
		switch (optc) {
		case 'a':
		case 'H':
		case 'S':
			break;
		case '?':
			return 1;
		default:
			for (l = limits; l->name && l->option != optc; l++)
				;
			if (!l->name) {
				internal_errorf(0, "ulimit: %c", optc);
				return 1;
			}
			if (builtin_opt.optarg) {
				if (set_ulimit(l, builtin_opt.optarg, how))
					return 1;
			} else
				print_ulimit(l, how);
			break;
		}

	wp += builtin_opt.optind;

	if (all) {
		for (l = limits; l->name; l++) {
			shprintf("%-20s ", l->name);
			print_ulimit(l, how);
		}
	} else if (builtin_opt.optind == 1) {
		/* No limit specified, use file size */
		l = &limits[1];
		if (wp[0] != NULL) {
			if (set_ulimit(l, wp[0], how))
				return 1;
			wp++;
		} else {
			print_ulimit(l, how);
		}
	}

	return 0;
}

static int
set_ulimit(const struct limits *l, const char *v, int how)
{
	rlim_t		val = 0;
	struct rlimit	limit;

	if (strcmp(v, "unlimited") == 0)
		val = RLIM_INFINITY;
	else {
		long rval;

		if (!evaluate(v, &rval, KSH_RETURN_ERROR, false))
			return 1;
		/*
		 * Avoid problems caused by typos that evaluate misses due
		 * to evaluating unset parameters to 0...
		 * If this causes problems, will have to add parameter to
		 * evaluate() to control if unset params are 0 or an error.
		 */
		if (!rval && !digit(v[0])) {
			bi_errorf("invalid limit: %s", v);
			return 1;
		}
		val = (rlim_t)rval * l->factor;
	}

	getrlimit(l->resource, &limit);
	if (how & SOFT)
		limit.rlim_cur = val;
	if (how & HARD)
		limit.rlim_max = val;
	if (setrlimit(l->resource, &limit) < 0) {
		if (errno == EPERM)
			bi_errorf("-%c exceeds allowable limit", l->option);
		else
			bi_errorf("bad -%c limit: %s", l->option,
			    strerror(errno));
		return 1;
	}
	return 0;
}

static void
print_ulimit(const struct limits *l, int how)
{
	rlim_t		val = 0;
	struct rlimit	limit;

	getrlimit(l->resource, &limit);
	if (how & SOFT)
		val = limit.rlim_cur;
	else if (how & HARD)
		val = limit.rlim_max;
	if (val == RLIM_INFINITY)
		shprintf("unlimited\n");
	else {
		val /= l->factor;
		shprintf("%ld\n", (long) val);
	}
}
@


1.23
log
@Use isdigit() instead of ksh's homebrewed alternative.

ok nicm@@. Also discussed with millert@@ and guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.22 2015/10/19 14:42:16 mmcc Exp $	*/
d24 1
@


1.22
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.21 2015/10/19 02:15:45 mmcc Exp $	*/
d23 1
@


1.21
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.20 2015/09/15 18:15:05 tedu Exp $	*/
d22 2
@


1.20
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.19 2013/11/28 10:33:37 sobrado Exp $	*/
d21 2
a23 1
#include <sys/resource.h>
@


1.19
log
@remove trailing whitespaces; use tabs instead of spaces where appropriate;
no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.18 2013/11/14 15:23:30 espie Exp $	*/
d54 1
a54 1
		{ (char *) 0 }
@


1.18
log
@be more specific in ulimit error messages.
prompted by henning@@
okay millert@@, krw@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.17 2008/03/21 12:51:19 millert Exp $	*/
d177 1
a177 1
			bi_errorf("bad -%c limit: %s", l->option, 
@


1.17
log
@Make ulimit able to get and set multiple limits in a single invocation
like bash and zsh do.  Requested by espie@@, OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.16 2006/11/20 21:53:39 miod Exp $	*/
d175 1
a175 1
			bi_errorf("exceeds allowable limit");
d177 2
a178 1
			bi_errorf("bad limit: %s", strerror(errno));
@


1.16
log
@Compute user-given ulimit value times ulimit unit as an rlim_t value, not a
long value; catches some 32 bit overflows on 32 bit platforms.

Found by drahn@@, ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.15 2006/03/12 00:26:58 deraadt Exp $	*/
d27 10
d40 14
a53 23
	static const struct limits {
		const char	*name;
		enum { RLIMIT, ULIMIT } which;
		int	gcmd;	/* get command */
		int	scmd;	/* set command (or -1, if no set command) */
		int	factor;	/* multiply by to get rlim_{cur,max} values */
		char	option;
	} limits[] = {
		/* Do not use options -H, -S or -a */
		{ "time(cpu-seconds)", RLIMIT, RLIMIT_CPU, RLIMIT_CPU, 1, 't' },
		{ "file(blocks)", RLIMIT, RLIMIT_FSIZE, RLIMIT_FSIZE, 512, 'f' },
		{ "coredump(blocks)", RLIMIT, RLIMIT_CORE, RLIMIT_CORE, 512, 'c' },
		{ "data(kbytes)", RLIMIT, RLIMIT_DATA, RLIMIT_DATA, 1024, 'd' },
		{ "stack(kbytes)", RLIMIT, RLIMIT_STACK, RLIMIT_STACK, 1024, 's' },
		{ "lockedmem(kbytes)", RLIMIT, RLIMIT_MEMLOCK, RLIMIT_MEMLOCK,
		    1024, 'l' },
		{ "memory(kbytes)", RLIMIT, RLIMIT_RSS, RLIMIT_RSS, 1024, 'm' },
		{ "nofiles(descriptors)", RLIMIT, RLIMIT_NOFILE, RLIMIT_NOFILE,
		    1, 'n' },
		{ "processes", RLIMIT, RLIMIT_NPROC, RLIMIT_NPROC, 1, 'p' },
	#ifdef RLIMIT_VMEM
		{ "vmemory(kbytes)", RLIMIT, RLIMIT_VMEM, RLIMIT_VMEM, 1024, 'v' },
	#endif /* RLIMIT_VMEM */
d56 1
a56 2
	static char	options[3 + NELEM(limits)];
	rlim_t		val = 0;
d59 2
a60 3
	int		set, all = 0;
	int		optc, what;
	struct rlimit	limit;
d66 1
a66 1
		for (l = limits; l->name; l++)
d68 2
d72 1
a72 1
	what = 'f';
d87 1
a87 1
			what = optc;
d90 2
a91 4
	for (l = limits; l->name && l->option != what; l++)
		;
	if (!l->name) {
		internal_errorf(0, "ulimit: %c", what);
d95 9
a103 5
	wp += builtin_opt.optind;
	set = *wp ? 1 : 0;
	if (set) {
		if (all || wp[1]) {
			bi_errorf("too many arguments");
d105 5
a109 17
		}
		if (strcmp(wp[0], "unlimited") == 0)
			val = RLIM_INFINITY;
		else {
			long rval;

			if (!evaluate(wp[0], &rval, KSH_RETURN_ERROR, false))
				return 1;
			/* Avoid problems caused by typos that
			 * evaluate misses due to evaluating unset
			 * parameters to 0...
			 * If this causes problems, will have to
			 * add parameter to evaluate() to control
			 * if unset params are 0 or an error.
			 */
			if (!rval && !digit(wp[0][0])) {
				bi_errorf("invalid limit: %s", wp[0]);
d112 6
a117 1
			val = (rlim_t)rval * l->factor;
d119 3
a121 1
	}
a123 7
			if (l->which == RLIMIT) {
				getrlimit(l->gcmd, &limit);
				if (how & SOFT)
					val = limit.rlim_cur;
				else if (how & HARD)
					val = limit.rlim_max;
			}
d125 1
a125 6
			if (val == RLIM_INFINITY)
				shprintf("unlimited\n");
			else {
				val /= l->factor;
				shprintf("%ld\n", (long) val);
			}
d127 5
a131 15
		return 0;
	}
	if (l->which == RLIMIT) {
		getrlimit(l->gcmd, &limit);
		if (set) {
			if (how & SOFT)
				limit.rlim_cur = val;
			if (how & HARD)
				limit.rlim_max = val;
			if (setrlimit(l->scmd, &limit) < 0) {
				if (errno == EPERM)
					bi_errorf("exceeds allowable limit");
				else
					bi_errorf("bad limit: %s",
					    strerror(errno));
d133 1
a133 1
			}
d135 1
a135 4
			if (how & SOFT)
				val = limit.rlim_cur;
			else if (how & HARD)
				val = limit.rlim_max;
d138 26
a163 6
	if (!set) {
		if (val == RLIM_INFINITY)
			shprintf("unlimited\n");
		else {
			val /= l->factor;
			shprintf("%ld\n", (long) val);
d165 14
d181 19
@


1.15
log
@might as well make ksh_getopt() match real getopt(), ie. get rid of that
stupid EOF concept that was never true.  adobriyan@@gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.14 2005/03/30 17:16:37 deraadt Exp $	*/
d121 1
a121 1
			val = rval * l->factor;
@


1.14
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.13 2005/02/02 07:53:01 otto Exp $	*/
d72 1
a72 1
	while ((optc = ksh_getopt(wp, &builtin_opt, options)) != EOF)
@


1.13
log
@Introduce POSIX hex and octal (0x... and 0...) constants in arithmetic
expressions.  Work by Matthias Kilian, based on an old diff by myself.
Note: MAKEDEV should be updated. Tested by many, thanks.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.12 2004/12/20 11:34:26 otto Exp $	*/
d44 2
a45 1
		{ "lockedmem(kbytes)", RLIMIT, RLIMIT_MEMLOCK, RLIMIT_MEMLOCK, 1024, 'l' },
d47 2
a48 1
		{ "nofiles(descriptors)", RLIMIT, RLIMIT_NOFILE, RLIMIT_NOFILE, 1, 'n' },
d50 1
a50 1
#ifdef RLIMIT_VMEM
d52 1
a52 1
#endif /* RLIMIT_VMEM */
d54 1
a54 1
	    };
a61 1

d74 1
a74 1
		  case 'H':
d77 1
a77 1
		  case 'S':
d80 1
a80 1
		  case 'a':
d83 1
a83 1
		  case '?':
d85 1
a85 1
		  default:
d118 2
a119 2
			    bi_errorf("invalid limit: %s", wp[0]);
			    return 1;
d136 1
a136 2
			else
			{
d155 1
a155 1
						strerror(errno));
d168 1
a168 2
		else
		{
@


1.12
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.11 2004/12/18 20:55:52 millert Exp $	*/
d107 1
a107 1
			if (!evaluate(wp[0], &rval, KSH_RETURN_ERROR))
@


1.11
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.10 2003/10/22 07:40:38 jmc Exp $	*/
d28 1
a28 2
c_ulimit(wp)
	char **wp;
@


1.10
log
@typos from Jared Yanovich;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.9 2002/06/09 05:47:27 todd Exp $	*/
d22 1
a22 11
#include "ksh_time.h"
#ifdef HAVE_SYS_RESOURCE_H
# include <sys/resource.h>
#endif /* HAVE_SYS_RESOURCE_H */
#ifdef HAVE_ULIMIT_H
# include <ulimit.h>
#else /* HAVE_ULIMIT_H */
# ifdef HAVE_ULIMIT
extern	long ulimit();
# endif /* HAVE_ULIMIT */
#endif /* HAVE_ULIMIT_H */
a26 6
#ifdef RLIM_INFINITY
# define KSH_RLIM_INFINITY RLIM_INFINITY
#else
# define KSH_RLIM_INFINITY ((rlim_t) 1 << (sizeof(rlim_t) * 8 - 1) - 1)
#endif /* RLIM_INFINITY */

a39 1
#ifdef RLIMIT_CPU
a40 2
#endif
#ifdef RLIMIT_FSIZE
a41 12
#else /* RLIMIT_FSIZE */
# ifdef UL_GETFSIZE /* x/open */
		{ "file(blocks)", ULIMIT, UL_GETFSIZE, UL_SETFSIZE, 1, 'f' },
# else /* UL_GETFSIZE */
#  ifdef UL_GFILLIM /* svr4/xenix */
		{ "file(blocks)", ULIMIT, UL_GFILLIM, UL_SFILLIM, 1, 'f' },
#  else /* UL_GFILLIM */
		{ "file(blocks)", ULIMIT, 1, 2, 1, 'f' },
#  endif /* UL_GFILLIM */
# endif /* UL_GETFSIZE */
#endif /* RLIMIT_FSIZE */
#ifdef RLIMIT_CORE
a42 2
#endif
#ifdef RLIMIT_DATA
a43 2
#endif
#ifdef RLIMIT_STACK
a44 2
#endif
#ifdef RLIMIT_MEMLOCK
a45 2
#endif
#ifdef RLIMIT_RSS
a46 2
#endif
#ifdef RLIMIT_NOFILE
a47 6
#else /* RLIMIT_NOFILE */
# ifdef UL_GDESLIM /* svr4/xenix */
		{ "nofiles(descriptors)", ULIMIT, UL_GDESLIM, -1, 1, 'n' },
# endif /* UL_GDESLIM */
#endif /* RLIMIT_NOFILE */
#ifdef RLIMIT_NPROC
a48 1
#endif
a50 13
#else /* RLIMIT_VMEM */
  /* These are not quite right - really should subtract etext or something */
# ifdef UL_GMEMLIM /* svr4/xenix */
		{ "vmemory(maxaddr)", ULIMIT, UL_GMEMLIM, -1, 1, 'v' },
# else /* UL_GMEMLIM */
#  ifdef UL_GETBREAK /* osf/1 */
		{ "vmemory(maxaddr)", ULIMIT, UL_GETBREAK, -1, 1, 'v' },
#  else /* UL_GETBREAK */
#   ifdef UL_GETMAXBRK /* hpux */
		{ "vmemory(maxaddr)", ULIMIT, UL_GETMAXBRK, -1, 1, 'v' },
#   endif /* UL_GETMAXBRK */
#  endif /* UL_GETBREAK */
# endif /* UL_GMEMLIM */
a51 3
#ifdef RLIMIT_SWAP
		{ "swap(kbytes)", RLIMIT_SWAP, RLIMIT_SWAP, 1024, 'w' },
#endif
d55 1
a55 1
	rlim_t		UNINITIALIZED(val);
a59 1
#ifdef HAVE_SETRLIMIT
a60 1
#endif /* HAVE_SETRLIMIT */
d104 1
a104 1
			val = KSH_RLIM_INFINITY;
a125 1
#ifdef HAVE_SETRLIMIT
a131 5
			} else
#endif /* HAVE_SETRLIMIT */
#ifdef HAVE_ULIMIT
			{
				val = ulimit(l->gcmd, (rlim_t) 0);
a132 3
#else /* HAVE_ULIMIT */
				;
#endif /* HAVE_ULIMIT */
a133 1
#ifdef RLIM_INFINITY
a136 1
#endif /* RLIM_INFINITY */
a143 1
#ifdef HAVE_SETRLIMIT
a164 14
	} else
#endif /* HAVE_SETRLIMIT */
#ifdef HAVE_ULIMIT
	{
		if (set) {
			if (l->scmd == -1) {
				bi_errorf("can't change limit");
				return 1;
			} else if (ulimit(l->scmd, val) < 0) {
				bi_errorf("bad limit: %s", strerror(errno));
				return 1;
			}
		} else
			val = ulimit(l->gcmd, (rlim_t) 0);
a165 3
#else /* HAVE_ULIMIT */
		;
#endif /* HAVE_ULIMIT */
a166 1
#ifdef RLIM_INFINITY
a169 1
#endif /* RLIM_INFINITY */
@


1.9
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.8 1999/06/15 01:18:33 millert Exp $	*/
d7 1
a7 1
	some schizophenic systems, eg, HP-UX 9.01), made argument parsing
@


1.8
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.7 1999/01/08 20:24:57 millert Exp $	*/
d199 1
a199 1
			} else 
@


1.7
log
@bug fixes from pdksh-unstable-5.2.13.5; some of which we already had.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.6 1998/11/24 04:32:47 millert Exp $	*/
d174 1
a174 1
			if (!evaluate(wp[0], &rval, TRUE))
@


1.6
log
@better error message from ulimit
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.5 1998/10/29 04:09:20 millert Exp $	*/
d234 1
a234 1
					    strerror(errno));
@


1.5
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.4 1998/01/17 19:00:44 millert Exp $	*/
d230 5
a234 1
				bi_errorf("bad limit: %s", strerror(errno));
@


1.4
log
@Make ulimit catch bogosity so that: "ulimit -dflmnpst unlimitted"
Results in: ksh: ulimit: "unlimitted" is not a valid limit
Not: Killed (because it treated the word as 0).
Noticed by mickey@@openbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.3 1997/06/19 13:58:39 kstailey Exp $	*/
d37 6
a164 2
		char *p = *wp;

d169 3
a171 9
#ifdef RLIM_INFINITY
		if (strcmp(p, "unlimited") == 0)
			val = RLIM_INFINITY;
		else
#endif /* RLIM_INFINITY */
		if (!isdigit(*p)) {
			bi_errorf("\"%s\" is not a valid limit", p);
			return 1;
		} else {
d174 1
a174 1
			if (!evaluate(p, &rval, TRUE))
d176 11
@


1.3
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ulimit.c,v 1.1.1.1 1996/08/14 06:19:10 downsj Exp $	*/
d170 4
a173 1
		{
@


1.2
log
@(foo *)0 -> NULL
@
text
@d110 1
a110 1
		{ NULL }
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d110 1
a110 1
		{ (char *) 0 }
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
