head	1.64;
access;
symbols
	OPENBSD_6_2:1.64.0.4
	OPENBSD_6_2_BASE:1.64
	OPENBSD_6_1:1.58.0.4
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.57.0.2
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.33.0.10
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.33.0.6
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.31.0.4
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.2
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.30.0.12
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.10
	OPENBSD_5_0:1.30.0.8
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.6
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.4
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.18
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.14
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.12
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.10
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.8
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.6
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.4
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.10
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.8
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.6
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.64
date	2017.09.03.11.52.01;	author jca;	state Exp;
branches;
next	1.63;
commitid	hY9pKLTbOjQJ8uf0;

1.63
date	2017.08.30.17.08.45;	author jca;	state Exp;
branches;
next	1.62;
commitid	DWdXJvJqVZz6aoxS;

1.62
date	2017.08.30.17.02.53;	author jca;	state Exp;
branches;
next	1.61;
commitid	a9ziUXbpkf6RtIgW;

1.61
date	2017.07.04.11.46.15;	author anton;	state Exp;
branches;
next	1.60;
commitid	b3F6k48viABAc9JE;

1.60
date	2017.07.04.07.29.32;	author anton;	state Exp;
branches;
next	1.59;
commitid	EAU5Bw3i4umUy47M;

1.59
date	2017.06.29.16.49.58;	author martijn;	state Exp;
branches;
next	1.58;
commitid	9iSVXhYqBKDCYEEg;

1.58
date	2016.09.08.15.50.50;	author millert;	state Exp;
branches;
next	1.57;
commitid	tgOuRGlXTus1h8vm;

1.57
date	2016.03.04.15.11.06;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	lvfr78VLuzkoupSX;

1.56
date	2015.12.30.09.07.00;	author tedu;	state Exp;
branches;
next	1.55;
commitid	WTwPzlskFufQpRQz;

1.55
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.54;
commitid	btTCreDA00YdaFhU;

1.54
date	2015.11.20.09.29.53;	author tb;	state Exp;
branches;
next	1.53;
commitid	0ymCf0ojKortDx92;

1.53
date	2015.11.12.04.04.31;	author mmcc;	state Exp;
branches;
next	1.52;
commitid	QvyWaajN4Lc4MRtd;

1.52
date	2015.11.07.20.48.28;	author mmcc;	state Exp;
branches;
next	1.51;
commitid	LNpDH2JXvGGJYld5;

1.51
date	2015.11.01.15.38.53;	author mmcc;	state Exp;
branches;
next	1.50;
commitid	Fr9nr0FBz2YkAWdK;

1.50
date	2015.10.23.01.33.36;	author mmcc;	state Exp;
branches;
next	1.49;
commitid	gN1JGJ4X0YXC50t2;

1.49
date	2015.10.23.01.14.07;	author mmcc;	state Exp;
branches;
next	1.48;
commitid	f4j1VU909xavQPGF;

1.48
date	2015.10.22.15.37.04;	author mmcc;	state Exp;
branches;
next	1.47;
commitid	UF4WZB601GytEPMw;

1.47
date	2015.10.21.14.30.43;	author mmcc;	state Exp;
branches;
next	1.46;
commitid	GfauVznpEDbDQteT;

1.46
date	2015.10.19.17.15.53;	author mmcc;	state Exp;
branches;
next	1.45;
commitid	zuJ55EJoQ0lgfTwv;

1.45
date	2015.10.19.17.10.53;	author mmcc;	state Exp;
branches;
next	1.44;
commitid	5VKIfaSkOIQTLX6K;

1.44
date	2015.10.19.14.43.46;	author mmcc;	state Exp;
branches;
next	1.43;
commitid	SxE6uiB4h4Bylypi;

1.43
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.42;
commitid	C4W85jmosThChWA2;

1.42
date	2015.10.19.14.03.21;	author mmcc;	state Exp;
branches;
next	1.41;
commitid	TSZF0K3aGmPbKQzz;

1.41
date	2015.10.19.14.01.37;	author mmcc;	state Exp;
branches;
next	1.40;
commitid	u5rhHK1DMglSuCSZ;

1.40
date	2015.10.18.18.05.35;	author mmcc;	state Exp;
branches;
next	1.39;
commitid	N64sMvTaEh7ch3Sh;

1.39
date	2015.10.17.18.43.22;	author mmcc;	state Exp;
branches;
next	1.38;
commitid	cfZiQLTOGilosr6B;

1.38
date	2015.10.17.18.26.24;	author mmcc;	state Exp;
branches;
next	1.37;
commitid	cg0YOIB6IojdTdEq;

1.37
date	2015.09.14.16.08.50;	author nicm;	state Exp;
branches;
next	1.36;
commitid	ahedYHs8fav8xOPq;

1.36
date	2015.09.14.09.42.33;	author nicm;	state Exp;
branches;
next	1.35;
commitid	HNyoYgRIsBj18EIi;

1.35
date	2015.09.10.22.48.58;	author nicm;	state Exp;
branches;
next	1.34;
commitid	stJ3KRI2o7F5OBtF;

1.34
date	2015.09.10.13.04.52;	author nicm;	state Exp;
branches;
next	1.33;
commitid	8HJGYJIXkSSMl2vq;

1.33
date	2013.12.18.13.53.12;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2013.11.28.10.33.37;	author sobrado;	state Exp;
branches;
next	1.31;

1.31
date	2012.09.10.01.25.30;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.04.18.07.11;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.11.18.53.51;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.04.20.35.11;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.28.21.33.04;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.21.16.01.58;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.18.22.43.58;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.18.22.11.43;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.18.21.58.39;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.18.21.04.52;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.12.06.53.13;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.31.10.36.35;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.10.16.28.47;	author pvalchev;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.08.19.18.15;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.22.07.40.38;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.01.15.47.40;	author naddy;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.16.19.58.57;	author jsyn;	state Exp;
branches;
next	1.12;

1.12
date	2002.10.07.23.09.32;	author vincent;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.01.13.13.54;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	99.07.15.20.39.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.06.15.01.18.36;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.01.19.20.41.56;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.01.08.20.25.02;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.06.25.19.02.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.01.02.09.34.10;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.12.18.18.28.37;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.10.01.02.05.47;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.58;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.64
log
@Use PATH_MAX instead of a local define

okk deraadt@@ millert@@ anton@@
@
text
@/*	$OpenBSD: sh.h,v 1.63 2017/08/30 17:08:45 jca Exp $	*/

/*
 * Public Domain Bourne/Korn shell
 */

/* $From: sh.h,v 1.2 1994/05/19 18:32:40 michael Exp michael $ */

#include "config.h"	/* system and option configuration info */

/* Start of common headers */

#include <limits.h>
#include <setjmp.h>
#include <stdarg.h>
#include <signal.h>
#include <stdbool.h>

/* end of common headers */

#define	NELEM(a) (sizeof(a) / sizeof((a)[0]))
#define	BIT(i)	(1<<(i))	/* define bit in flag */

#define	NUFILE	32		/* Number of user-accessible files */
#define	FDBASE	10		/* First file usable by Shell */

#define BITS(t)	(CHAR_BIT * sizeof(t))

/* Make MAGIC a char that might be printed to make bugs more obvious, but
 * not a char that is used often.  Also, can't use the high bit as it causes
 * portability problems (calling strchr(x, 0x80|'x') is error prone).
 */
#define	MAGIC		(7)	/* prefix for *?[!{,} during expand */
#define ISMAGIC(c)	((unsigned char)(c) == MAGIC)

#define	LINE	4096		/* input line size */

extern	const char *kshname;	/* $0 */
extern	pid_t	kshpid;		/* $$, shell pid */
extern	pid_t	procpid;	/* pid of executing process */
extern	uid_t	ksheuid;	/* effective uid of shell */
extern	int	exstat;		/* exit status */
extern	int	subst_exstat;	/* exit status of last $(..)/`..` */
extern	const char *safe_prompt; /* safe prompt if PS1 substitution fails */
extern	char	username[];	/* username for \u prompt expansion */

/*
 * Area-based allocation built on malloc/free
 */
typedef struct Area {
	struct link *freelist;	/* free list */
} Area;

extern	Area	aperm;		/* permanent object space */
#define	APERM	&aperm
#define	ATEMP	&genv->area

#ifdef KSH_DEBUG
# define kshdebug_init()	kshdebug_init_()
# define kshdebug_printf(a)	kshdebug_printf_ a
# define kshdebug_dump(a)	kshdebug_dump_ a
#else /* KSH_DEBUG */
# define kshdebug_init()
# define kshdebug_printf(a)
# define kshdebug_dump(a)
#endif /* KSH_DEBUG */

/*
 * parsing & execution environment
 */
struct env {
	short	type;			/* environment type - see below */
	short	flags;			/* EF_* */
	Area	area;			/* temporary allocation area */
	struct	block *loc;		/* local variables and functions */
	short  *savefd;			/* original redirected fd's */
	struct	env *oenv;		/* link to previous environment */
	sigjmp_buf jbuf;		/* long jump back to env creator */
	struct temp *temps;		/* temp files */
};
extern	struct env	*genv;

/* struct env.type values */
#define	E_NONE	0		/* dummy environment */
#define	E_PARSE	1		/* parsing command # */
#define	E_FUNC	2		/* executing function # */
#define	E_INCL	3		/* including a file via . # */
#define	E_EXEC	4		/* executing command tree */
#define	E_LOOP	5		/* executing for/while # */
#define	E_ERRH	6		/* general error handler # */
/* # indicates env has valid jbuf (see unwind()) */

/* struct env.flag values */
#define EF_FUNC_PARSE	BIT(0)	/* function being parsed */
#define EF_BRKCONT_PASS	BIT(1)	/* set if E_LOOP must pass break/continue on */
#define EF_FAKE_SIGDIE	BIT(2)	/* hack to get info from unwind to quitenv */

/* Do breaks/continues stop at env type e? */
#define STOP_BRKCONT(t)	((t) == E_NONE || (t) == E_PARSE \
			 || (t) == E_FUNC || (t) == E_INCL)
/* Do returns stop at env type e? */
#define STOP_RETURN(t)	((t) == E_FUNC || (t) == E_INCL)

/* values for siglongjmp(e->jbuf, 0) */
#define LRETURN	1		/* return statement */
#define	LEXIT	2		/* exit statement */
#define LERROR	3		/* errorf() called */
#define LLEAVE	4		/* untrappable exit/error */
#define LINTR	5		/* ^C noticed */
#define	LBREAK	6		/* break statement */
#define	LCONTIN	7		/* continue statement */
#define LSHELL	8		/* return to interactive shell() */
#define LAEXPR	9		/* error in arithmetic expression */

/* option processing */
#define OF_CMDLINE	0x01	/* command line */
#define OF_SET		0x02	/* set builtin */
#define OF_SPECIAL	0x04	/* a special variable changing */
#define OF_INTERNAL	0x08	/* set internally by shell */
#define OF_ANY		(OF_CMDLINE | OF_SET | OF_SPECIAL | OF_INTERNAL)

struct option {
    const char	*name;	/* long name of option */
    char	c;	/* character flag (if any) */
    short	flags;	/* OF_* */
};
extern const struct option options[];

/*
 * flags (the order of these enums MUST match the order in misc.c(options[]))
 */
enum sh_flag {
	FEXPORT = 0,	/* -a: export all */
#ifdef BRACE_EXPAND
	FBRACEEXPAND,	/* enable {} globbing */
#endif
	FBGNICE,	/* bgnice */
	FCOMMAND,	/* -c: (invocation) execute specified command */
	FCSHHISTORY,	/* csh-style history enabled */
#ifdef EMACS
	FEMACS,		/* emacs command editing */
	FEMACSUSEMETA,	/* XXX delete after 6.2 */
#endif
	FERREXIT,	/* -e: quit on error */
#ifdef EMACS
	FGMACS,		/* gmacs command editing */
#endif
	FIGNOREEOF,	/* eof does not exit */
	FTALKING,	/* -i: interactive */
	FKEYWORD,	/* -k: name=value anywhere */
	FLOGIN,		/* -l: a login shell */
	FMARKDIRS,	/* mark dirs with / in file name completion */
	FMONITOR,	/* -m: job control monitoring */
	FNOCLOBBER,	/* -C: don't overwrite existing files */
	FNOEXEC,	/* -n: don't execute any commands */
	FNOGLOB,	/* -f: don't do file globbing */
	FNOHUP,		/* -H: don't kill running jobs when login shell exits */
	FNOLOG,		/* don't save functions in history (ignored) */
#ifdef	JOBS
	FNOTIFY,	/* -b: asynchronous job completion notification */
#endif
	FNOUNSET,	/* -u: using an unset var is an error */
	FPHYSICAL,	/* -o physical: don't do logical cd's/pwd's */
	FPOSIX,		/* -o posix: be posixly correct */
	FPRIVILEGED,	/* -p: use suid_profile */
	FRESTRICTED,	/* -r: restricted shell */
	FSH,		/* -o sh: favor sh behaviour */
	FSTDIN,		/* -s: (invocation) parse stdin */
	FTRACKALL,	/* -h: create tracked aliases for all commands */
	FVERBOSE,	/* -v: echo input */
#ifdef VI
	FVI,		/* vi command editing */
	FVIRAW,		/* always read in raw mode (ignored) */
	FVISHOW8,	/* display chars with 8th bit set as is (versus M-) */
	FVITABCOMPLETE,	/* enable tab as file name completion char */
	FVIESCCOMPLETE,	/* enable ESC as file name completion in command mode */
#endif
	FXTRACE,	/* -x: execution trace */
	FTALKING_I,	/* (internal): initial shell was interactive */
	FNFLAGS /* (place holder: how many flags are there) */
};

#define Flag(f)	(shell_flags[(int) (f)])

extern	char shell_flags[FNFLAGS];

extern	char	null[];	/* null value for variable */

enum temp_type {
	TT_HEREDOC_EXP,	/* expanded heredoc */
	TT_HIST_EDIT	/* temp file used for history editing (fc -e) */
};
typedef enum temp_type Temp_type;
/* temp/heredoc files.  The file is removed when the struct is freed. */
struct temp {
	struct temp	*next;
	struct shf	*shf;
	int		pid;		/* pid of process parsed here-doc */
	Temp_type	type;
	char		*name;
};

/*
 * stdio and our IO routines
 */

#define shl_spare	(&shf_iob[0])	/* for c_read()/c_print() */
#define shl_stdout	(&shf_iob[1])
#define shl_out		(&shf_iob[2])
extern int shl_stdout_ok;

/*
 * trap handlers
 */
typedef struct trap {
	int	signal;		/* signal number */
	const char *name;	/* short name */
	const char *mess;	/* descriptive name */
	char   *trap;		/* trap command */
	volatile sig_atomic_t set; /* trap pending */
	int	flags;		/* TF_* */
	sig_t cursig;		/* current handler (valid if TF_ORIG_* set) */
	sig_t shtrap;		/* shell signal handler */
} Trap;

/* values for Trap.flags */
#define TF_SHELL_USES	BIT(0)	/* shell uses signal, user can't change */
#define TF_USER_SET	BIT(1)	/* user has (tried to) set trap */
#define TF_ORIG_IGN	BIT(2)	/* original action was SIG_IGN */
#define TF_ORIG_DFL	BIT(3)	/* original action was SIG_DFL */
#define TF_EXEC_IGN	BIT(4)	/* restore SIG_IGN just before exec */
#define TF_EXEC_DFL	BIT(5)	/* restore SIG_DFL just before exec */
#define TF_DFL_INTR	BIT(6)	/* when received, default action is LINTR */
#define TF_TTY_INTR	BIT(7)	/* tty generated signal (see j_waitj) */
#define TF_CHANGED	BIT(8)	/* used by runtrap() to detect trap changes */
#define TF_FATAL	BIT(9)	/* causes termination if not trapped */

/* values for setsig()/setexecsig() flags argument */
#define SS_RESTORE_MASK	0x3	/* how to restore a signal before an exec() */
#define SS_RESTORE_CURR	0	/* leave current handler in place */
#define SS_RESTORE_ORIG	1	/* restore original handler */
#define SS_RESTORE_DFL	2	/* restore to SIG_DFL */
#define SS_RESTORE_IGN	3	/* restore to SIG_IGN */
#define SS_FORCE	BIT(3)	/* set signal even if original signal ignored */
#define SS_USER		BIT(4)	/* user is doing the set (ie, trap command) */
#define SS_SHTRAP	BIT(5)	/* trap for internal use (CHLD,ALRM,WINCH) */

#define SIGEXIT_	0	/* for trap EXIT */
#define SIGERR_		NSIG	/* for trap ERR */

extern	volatile sig_atomic_t trap;	/* traps pending? */
extern	volatile sig_atomic_t intrsig;	/* pending trap interrupts command */
extern	volatile sig_atomic_t fatal_trap;	/* received a fatal signal */
extern	volatile sig_atomic_t got_sigwinch;
extern	Trap	sigtraps[NSIG+1];

/*
 * TMOUT support
 */
/* values for ksh_tmout_state */
enum tmout_enum {
	TMOUT_EXECUTING	= 0,	/* executing commands */
	TMOUT_READING,		/* waiting for input */
	TMOUT_LEAVING		/* have timed out */
};
extern unsigned int ksh_tmout;
extern enum tmout_enum ksh_tmout_state;

/* For "You have stopped jobs" message */
extern int really_exit;

/*
 * fast character classes
 */
#define	C_ALPHA	 BIT(0)		/* a-z_A-Z */
/* was	C_DIGIT */
#define	C_LEX1	 BIT(2)		/* \0 \t\n|&;<>() */
#define	C_VAR1	 BIT(3)		/* *@@#!$-? */
#define	C_IFSWS	 BIT(4)		/* \t \n (IFS white space) */
#define	C_SUBOP1 BIT(5)		/* "=-+?" */
#define	C_SUBOP2 BIT(6)		/* "#%" */
#define	C_IFS	 BIT(7)		/* $IFS */
#define	C_QUOTE	 BIT(8)		/*  \n\t"#$&'()*;<>?[\`| (needing quoting) */

extern	short ctypes [];

#define	ctype(c, t)	!!(ctypes[(unsigned char)(c)]&(t))
#define	letter(c)	ctype(c, C_ALPHA)
#define	digit(c)	isdigit((unsigned char)(c))
#define	letnum(c)	(ctype(c, C_ALPHA) || isdigit((unsigned char)(c)))

extern int ifs0;	/* for "$*" */

/* Argument parsing for built-in commands and getopts command */

/* Values for Getopt.flags */
#define GF_ERROR	BIT(0)	/* call errorf() if there is an error */
#define GF_PLUSOPT	BIT(1)	/* allow +c as an option */
#define GF_NONAME	BIT(2)	/* don't print argv[0] in errors */

/* Values for Getopt.info */
#define GI_MINUS	BIT(0)	/* an option started with -... */
#define GI_PLUS		BIT(1)	/* an option started with +... */
#define GI_MINUSMINUS	BIT(2)	/* arguments were ended with -- */

typedef struct {
	int		optind;
	int		uoptind;/* what user sees in $OPTIND */
	char		*optarg;
	int		flags;	/* see GF_* */
	int		info;	/* see GI_* */
	unsigned int	p;	/* 0 or index into argv[optind - 1] */
	char		buf[2];	/* for bad option OPTARG value */
} Getopt;

extern Getopt builtin_opt;	/* for shell builtin commands */
extern Getopt user_opt;		/* parsing state for getopts builtin command */

/* This for co-processes */

typedef int Coproc_id; /* something that won't (realistically) wrap */
struct coproc {
	int	read;		/* pipe from co-process's stdout */
	int	readw;		/* other side of read (saved temporarily) */
	int	write;		/* pipe to co-process's stdin */
	Coproc_id id;		/* id of current output pipe */
	int	njobs;		/* number of live jobs using output pipe */
	void	*job;		/* 0 or job of co-process using input pipe */
};
extern struct coproc coproc;

/* Used in jobs.c and by coprocess stuff in exec.c */
extern sigset_t		sm_default, sm_sigchld;

extern const char ksh_version[];

/* name of called builtin function (used by error functions) */
extern char	*builtin_argv0;
extern int	builtin_flag;	/* flags of called builtin (SPEC_BI, etc.) */

/* current working directory, and size of memory allocated for same */
extern char	*current_wd;
extern int	current_wd_size;

#ifdef EDIT
/* Minimum required space to work with on a line - if the prompt leaves less
 * space than this on a line, the prompt is truncated.
 */
# define MIN_EDIT_SPACE	7
/* Minimum allowed value for x_cols: 2 for prompt, 3 for " < " at end of line
 */
# define MIN_COLS	(2 + MIN_EDIT_SPACE + 3)
extern	int	x_cols;	/* tty columns */
#else
# define x_cols 80		/* for pr_menu(exec.c) */
#endif

/* These to avoid bracket matching problems */
#define OPAREN	'('
#define CPAREN	')'
#define OBRACK	'['
#define CBRACK	']'
#define OBRACE	'{'
#define CBRACE	'}'

/* Determine the location of the system (common) profile */
#define KSH_SYSTEM_PROFILE "/etc/profile"

/* Used by v_evaluate() and setstr() to control action when error occurs */
#define KSH_UNWIND_ERROR	0x0	/* unwind the stack (longjmp) */
#define KSH_RETURN_ERROR	0x1	/* return 1/0 for success/failure */
#define KSH_IGNORE_RDONLY	0x4	/* ignore the read-only flag */

#include "shf.h"
#include "table.h"
#include "tree.h"
#include "expand.h"
#include "lex.h"

/* alloc.c */
Area *	ainit(Area *);
void	afreeall(Area *);
void *	alloc(size_t, Area *);
void *	areallocarray(void *, size_t, size_t, Area *);
void *	aresize(void *, size_t, Area *);
void	afree(void *, Area *);
/* c_ksh.c */
int	c_cd(char **);
int	c_pwd(char **);
int	c_print(char **);
int	c_whence(char **);
int	c_command(char **);
int	c_typeset(char **);
int	c_alias(char **);
int	c_unalias(char **);
int	c_let(char **);
int	c_jobs(char **);
int	c_fgbg(char **);
int	c_kill(char **);
void	getopts_reset(int);
int	c_getopts(char **);
int	c_bind(char **);
/* c_sh.c */
int	c_label(char **);
int	c_shift(char **);
int	c_umask(char **);
int	c_dot(char **);
int	c_wait(char **);
int	c_read(char **);
int	c_eval(char **);
int	c_trap(char **);
int	c_brkcont(char **);
int	c_exitreturn(char **);
int	c_set(char **);
int	c_unset(char **);
int	c_ulimit(char **);
int	c_times(char **);
int	timex(struct op *, int, volatile int *);
void	timex_hook(struct op *, char ** volatile *);
int	c_exec(char **);
int	c_builtin(char **);
/* c_test.c */
int	c_test(char **);
/* edit.c: most prototypes in edit.h */
void	x_init(void);
int	x_read(char *, size_t);
void	set_editmode(const char *);
/* emacs.c: most prototypes in edit.h */
int	x_bind(const char *, const char *, int, int);
/* eval.c */
char *	substitute(const char *, int);
char **	eval(char **, int);
char *	evalstr(char *cp, int);
char *	evalonestr(char *cp, int);
char	*debunk(char *, const char *, size_t);
void	expand(char *, XPtrV *, int);
int	glob_str(char *, XPtrV *, int);
/* exec.c */
int	execute(struct op * volatile, volatile int, volatile int *);
int	shcomexec(char **);
struct tbl * findfunc(const char *, unsigned int, int);
int	define(const char *, struct op *);
void	builtin(const char *, int (*)(char **));
struct tbl *	findcom(const char *, int);
void	flushcom(int);
char *	search(const char *, const char *, int, int *);
int	search_access(const char *, int, int *);
int	pr_menu(char *const *);
int	pr_list(char *const *);
/* expr.c */
int	evaluate(const char *, long *, int, bool);
int	v_evaluate(struct tbl *, const char *, volatile int, bool);
/* history.c */
void	init_histvec(void);
void	hist_init(Source *);
void	hist_finish(void);
void	histsave(int, const char *, int);
#ifdef HISTORY
int	c_fc(char **);
void	sethistcontrol(const char *);
void	sethistsize(int);
void	sethistfile(const char *);
char **	histpos(void);
int	histnum(int);
int	findhist(int, int, const char *, int);
int	findhistrel(const char *);
char  **hist_get_newest(int);

#endif /* HISTORY */
/* io.c */
void	errorf(const char *, ...)
	    __attribute__((__noreturn__, __format__ (printf, 1, 2)));
void	warningf(bool, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	bi_errorf(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	internal_errorf(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	error_prefix(int);
void	shellf(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	shprintf(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
#ifdef KSH_DEBUG
void	kshdebug_init_(void);
void	kshdebug_printf_(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	kshdebug_dump_(const char *, const void *, int);
#endif /* KSH_DEBUG */
int	can_seek(int);
void	initio(void);
int	ksh_dup2(int, int, int);
int	savefd(int);
void	restfd(int, int);
void	openpipe(int *);
void	closepipe(int *);
int	check_fd(char *, int, const char **);
void	coproc_init(void);
void	coproc_read_close(int);
void	coproc_readw_close(int);
void	coproc_write_close(int);
int	coproc_getfd(int, const char **);
void	coproc_cleanup(int);
struct temp *maketemp(Area *, Temp_type, struct temp **);
/* jobs.c */
void	j_init(int);
void	j_suspend(void);
void	j_exit(void);
void	j_change(void);
int	exchild(struct op *, int, volatile int *, int);
void	startlast(void);
int	waitlast(void);
int	waitfor(const char *, int *);
int	j_kill(const char *, int);
int	j_resume(const char *, int);
int	j_jobs(const char *, int, int);
int	j_njobs(void);
void	j_notify(void);
pid_t	j_async(void);
int	j_stopped_running(void);
/* mail.c */
void	mcheck(void);
void	mcset(long);
void	mbset(char *);
void	mpset(char *);
/* main.c */
int	include(const char *, int, char **, int);
int	command(const char *, int);
int	shell(Source *volatile, int volatile);
void	unwind(int) __attribute__((__noreturn__));
void	newenv(int);
void	quitenv(struct shf *);
void	cleanup_parents_env(void);
void	cleanup_proc_env(void);
/* misc.c */
void	setctypes(const char *, int);
void	initctypes(void);
char *	ulton(unsigned long, int);
char *	str_save(const char *, Area *);
char *	str_nsave(const char *, int, Area *);
int	option(const char *);
char *	getoptions(void);
void	change_flag(enum sh_flag, int, int);
int	parse_args(char **, int, int *);
int	getn(const char *, int *);
int	bi_getn(const char *, int *);
int	gmatch(const char *, const char *, int);
int	has_globbing(const char *, const char *);
const unsigned char *pat_scan(const unsigned char *, const unsigned char *,
    int);
void	qsortp(void **, size_t, int (*)(const void *, const void *));
int	xstrcmp(const void *, const void *);
void	ksh_getopt_reset(Getopt *, int);
int	ksh_getopt(char **, Getopt *, const char *);
void	print_value_quoted(const char *);
void	print_columns(struct shf *, int, char *(*)(void *, int, char *, int),
    void *, int, int prefcol);
int	strip_nuls(char *, int);
int	blocking_read(int, char *, int);
int	reset_nonblock(int);
char	*ksh_get_wd(char *, int);
/* path.c */
int	make_path(const char *, const char *, char **, XString *, int *);
void	simplify_path(char *);
char	*get_phys_path(const char *);
void	set_current_wd(char *);
/* syn.c */
void	initkeywords(void);
struct op * compile(Source *);
/* trap.c */
void	inittraps(void);
void	alarm_init(void);
Trap *	gettrap(const char *, int);
void	trapsig(int);
void	intrcheck(void);
int	fatal_trap_check(void);
int	trap_pending(void);
void	runtraps(int intr);
void	runtrap(Trap *);
void	cleartraps(void);
void	restoresigs(void);
void	settrap(Trap *, char *);
int	block_pipe(void);
void	restore_pipe(int);
int	setsig(Trap *, sig_t, int);
void	setexecsig(Trap *, int);
/* var.c */
void	newblock(void);
void	popblock(void);
void	initvar(void);
struct tbl *	global(const char *);
struct tbl *	local(const char *, bool);
char *	str_val(struct tbl *);
long	intval(struct tbl *);
int	setstr(struct tbl *, const char *, int);
struct tbl *setint_v(struct tbl *, struct tbl *, bool);
void	setint(struct tbl *, long);
int	getint(struct tbl *, long *, bool);
struct tbl *typeset(const char *, int, int, int, int);
void	unset(struct tbl *, int);
char  * skip_varname(const char *, int);
char	*skip_wdvarname(const char *, int);
int	is_wdvarname(const char *, int);
int	is_wdvarassign(const char *);
char **	makenv(void);
void	change_random(void);
int	array_ref_len(const char *);
char *	arrayname(const char *);
void    set_array(const char *, int, char **);
/* vi.c: see edit.h */
@


1.63
log
@Implement HISTCONTROL ignoredups & ignorespace features

ignoredups: don't save the current line if it is identical to the last
history line.
ignorespace: don't save the current line if it starts with a space

ok anton@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.62 2017/08/30 17:02:53 jca Exp $	*/
d13 1
a36 1
#define	PATH	1024		/* pathname size (todo: PATH_MAX/pathconf()) */
@


1.62
log
@Stop exposing the emacs-usemeta option, and warn when trying to set it.

Unused since 2012, to be removed after 6.2.  Input from anton@@,
ok anton@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.61 2017/07/04 11:46:15 anton Exp $	*/
d460 1
@


1.61
log
@Backout previous due to a bug discovered by zhuk@@ that requires some tinkering
and is not an easy fix for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.60 2017/07/04 07:29:32 anton Exp $	*/
d142 1
a142 1
	FEMACSUSEMETA,	/* use 8th bit as meta */
@


1.60
log
@Add support for pattern substitution to variables in ksh using a common syntax
borrowed from ksh93.

Survived a ports build performed by naddy@@ and encouraged by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.59 2017/06/29 16:49:58 martijn Exp $	*/
d281 1
a281 1
#define	C_SUBOP2 BIT(6)		/* "#%/" */
a546 1
int	gnmatch(char *, size_t, const char *, int);
@


1.59
log
@Increase the input line buffer to 4096 bytes.

Sounds good to deraadt@@
OK anton@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.58 2016/09/08 15:50:50 millert Exp $	*/
d281 1
a281 1
#define	C_SUBOP2 BIT(6)		/* "#%" */
d547 1
@


1.58
log
@Add KSH_IGNORE_RDONLY flag and use it in var.c instead of the 0x4
magic number.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.57 2016/03/04 15:11:06 deraadt Exp $	*/
d35 1
a35 1
#define	LINE	2048		/* input line size */
@


1.57
log
@remove CSRG BSD-licensed mknod builtin code which was previously used to
accelerate install/upgrade time MAKEDEV runs.  That allows ramdisk ksh
to be pledged, without needing "dpath".  We'll solve the performance issues
a different way (soon).
ok otto espie natano tb tobiasu rpe
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.56 2015/12/30 09:07:00 tedu Exp $	*/
d370 3
a372 2
#define KSH_UNWIND_ERROR	0	/* unwind the stack (longjmp) */
#define KSH_RETURN_ERROR	1	/* return 1/0 for success/failure */
@


1.56
log
@rename global "e" to genv to avoid accidental shadowing and aliasing.
ok millert nicm tb
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.55 2015/12/14 13:59:42 tb Exp $	*/
a559 3
/* mknod.c */
int domknod(int, char **, mode_t);
int domkfifo(int, char **, mode_t);
@


1.55
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.53 2015/11/12 04:04:31 mmcc Exp $	*/
d56 1
a56 1
#define	ATEMP	&e->area
d81 1
a81 1
extern	struct env	*e;
@


1.54
log
@remove unused prototype

ok mmcc@@
@
text
@a12 3
#include <sys/types.h>

#include <stdio.h>
a13 3
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
a14 4

#include <errno.h>
#include <fcntl.h>

d16 1
@


1.53
log
@Use isdigit() instead of ksh's homebrewed alternative.

ok nicm@@. Also discussed with millert@@ and guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.52 2015/11/07 20:48:28 mmcc Exp $	*/
a395 1
int	c_hash(char **);
@


1.52
log
@Make it clearer that warningf()'s first argument determines whether the
lineno is printed.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.51 2015/11/01 15:38:53 mmcc Exp $	*/
d285 1
a285 1
#define	C_DIGIT	 BIT(1)		/* 0-9 */
d298 2
a299 2
#define	digit(c)	ctype(c, C_DIGIT)
#define	letnum(c)	ctype(c, C_ALPHA|C_DIGIT)
@


1.51
log
@Add uses of areallocarray(). mksh and Bitrig ksh already have similar
functions. With help from Theo Buehler.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.50 2015/10/23 01:33:36 mmcc Exp $	*/
d481 1
a481 1
void	warningf(int, const char *, ...)
@


1.50
log
@Remove two comments listing functionless files. Trivial, no functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.49 2015/10/23 01:14:07 mmcc Exp $	*/
a29 1
#define	sizeofN(type, n) (sizeof(type) * (n))
d392 1
@


1.49
log
@proto.h contains many function prototypes. It's apparently separate from
sh.h because the pdksh devs used a prototype generator (last run in
1992). Merging it into sh.h makes things clearer.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.48 2015/10/22 15:37:04 mmcc Exp $	*/
a580 1
/* trace.c */
a620 1
/* version.c */
@


1.48
log
@Final removal of EXTERN.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.47 2015/10/21 14:30:43 mmcc Exp $	*/
d388 236
a623 1
#include "proto.h"
@


1.47
log
@Penultimate commit to remove EXTERN.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.46 2015/10/19 17:15:53 mmcc Exp $	*/
a28 9
/* some useful #defines */
#ifdef EXTERN
# define I__(i) = i
#else
# define I__(i)
# define EXTERN extern
# define EXTERN_DEFINED
#endif

d340 1
a340 1
EXTERN struct coproc coproc;
d343 1
a343 1
EXTERN sigset_t		sm_default, sm_sigchld;
d348 2
a349 2
EXTERN char	*builtin_argv0;
EXTERN int	builtin_flag;	/* flags of called builtin (SPEC_BI, etc.) */
d352 2
a353 2
EXTERN char	*current_wd;
EXTERN int	current_wd_size;
d363 1
a363 1
EXTERN	int	x_cols I__(80);	/* tty columns */
a388 7

/* be sure not to interfere with anyone else's idea about EXTERN */
#ifdef EXTERN_DEFINED
# undef EXTERN_DEFINED
# undef EXTERN
#endif
#undef I__
@


1.46
log
@Remove the define NOT, replace it with '!'. No binary change.

"The ^ is used in regular expressions and many versions of fnmatch(3)
accept both ! and ^. However, we are never going to accept ^ instead of
! so I think this makes sense" -millert@@

"go for it" -nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.45 2015/10/19 17:10:53 mmcc Exp $	*/
d206 1
a206 1
EXTERN	char	null [] I__("");	/* null value for variable */
d229 1
a229 1
EXTERN int shl_stdout_ok;
d270 3
a272 3
EXTERN	volatile sig_atomic_t trap;	/* traps pending? */
EXTERN	volatile sig_atomic_t intrsig;	/* pending trap interrupts command */
EXTERN	volatile sig_atomic_t fatal_trap;/* received a fatal signal */
d285 2
a286 2
EXTERN unsigned int ksh_tmout;
EXTERN enum tmout_enum ksh_tmout_state I__(TMOUT_EXECUTING);
d289 1
a289 1
EXTERN int really_exit;
d311 1
a311 1
EXTERN int ifs0 I__(' ');	/* for "$*" */
d335 2
a336 2
EXTERN Getopt builtin_opt;	/* for shell builtin commands */
EXTERN Getopt user_opt;		/* parsing state for getopts builtin command */
@


1.45
log
@A little style(9) for sh.h includes

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.44 2015/10/19 14:43:46 mmcc Exp $	*/
a52 1
#define	NOT		'!'	/* might use ^ (ie, [!...] vs [^..]) */
@


1.44
log
@Move stddef.h include from sh.h to the file that uses it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.43 2015/10/19 14:42:16 mmcc Exp $	*/
d13 2
a15 1
#include <sys/types.h>
@


1.43
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.42 2015/10/19 14:03:21 mmcc Exp $	*/
a16 1
#include <stddef.h>
@


1.42
log
@Move limits.h include from sh.h to the files that actually need it. No
binary change.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.41 2015/10/19 14:01:37 mmcc Exp $	*/
a19 1
#include <string.h>
@


1.41
log
@More removal of EXTERN.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.40 2015/10/18 18:05:35 mmcc Exp $	*/
a24 1
#include <limits.h>
@


1.40
log
@Move more EXTERN-defined globals from sh.h.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.39 2015/10/17 18:43:22 mmcc Exp $	*/
d76 1
a76 1
EXTERN	Area	aperm;		/* permanent object space */
d93 1
a93 1
EXTERN	struct env {
d102 2
a103 1
} *e;
d207 1
a207 1
EXTERN	char shell_flags [FNFLAGS];
@


1.39
log
@Drop two useless defines.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.38 2015/10/17 18:26:24 mmcc Exp $	*/
d60 8
a67 8
EXTERN	const char *kshname;	/* $0 */
EXTERN	pid_t	kshpid;		/* $$, shell pid */
EXTERN	pid_t	procpid;	/* pid of executing process */
EXTERN	uid_t	ksheuid;	/* effective uid of shell */
EXTERN	int	exstat;		/* exit status */
EXTERN	int	subst_exstat;	/* exit status of last $(..)/`..` */
EXTERN	const char *safe_prompt; /* safe prompt if PS1 substitution fails */
EXTERN	char	username[];	/* username for \u prompt expansion */
@


1.38
log
@Move a system header include from the global header (sh.h) into the
files that need it. No binary change.

"This looks fine" -nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.37 2015/09/14 16:08:50 nicm Exp $	*/
a38 3

#define EXECSHELL	_PATH_BSHELL
#define EXECSHELL_STR	"EXECSHELL"
@


1.37
log
@Replace Tflag typedef with just int; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.36 2015/09/14 09:42:33 nicm Exp $	*/
a27 2

#include <paths.h>
@


1.36
log
@Apply the ancient art of tedu to ksh_limval.h. ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.35 2015/09/10 22:48:58 nicm Exp $	*/
a48 3
/* Table flag type - needs > 16 and < 32 bits */
typedef int Tflag;

d365 1
a365 1
EXTERN Tflag	builtin_flag;	/* flags of called builtin (SPEC_BI, etc.) */
@


1.35
log
@Replace newline and space defines by "\n" and " " directly, from Michael
McConville. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.34 2015/09/10 13:04:52 nicm Exp $	*/
d54 2
@


1.34
log
@Remove INT32 define and just use int, from Martijn van Duren and Michael
McConville. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.33 2013/12/18 13:53:12 millert Exp $	*/
a214 2
EXTERN	char	space [] I__(" ");
EXTERN	char	newline [] I__("\n");
@


1.33
log
@Remove artificial limit on the max array index.
Adapted from a bitrig commit from Martin Natano.
OK zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.32 2013/11/28 10:33:37 sobrado Exp $	*/
a30 6
/* Find a integer type that is at least 32 bits (or die) - SIZEOF_* defined
 * by autoconf (assumes an 8 bit byte, but I'm not concerned).
 * NOTE: INT32 may end up being more than 32 bits.
 */
# define INT32	int

d50 1
a50 1
typedef INT32 Tflag;
d350 1
a350 1
typedef INT32 Coproc_id; /* something that won't (realisticly) wrap */
@


1.32
log
@remove trailing whitespaces; use tabs instead of spaces where appropriate;
no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.31 2012/09/10 01:25:30 tedu Exp $	*/
a70 1
#define ARRAYMAX (10*1024-1)	/* max array index */
@


1.31
log
@fake a sigwinch after each job, so if the terminal changes size,
we'll notice and update
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.30 2010/01/04 18:07:11 deraadt Exp $	*/
d364 1
a364 1
	void    *job;           /* 0 or job of co-process using input pipe */
@


1.30
log
@Crank max array size in ksh to 10K-1, since 2047 is too restrictive.
Please keep in mind that ksh accesses are not O(1) in any sense.
Needed by todd, ok otto, guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.29 2005/12/11 18:53:51 deraadt Exp $	*/
d290 1
@


1.29
log
@remove unused variables and functions
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.28 2005/10/04 20:35:11 otto Exp $	*/
d71 1
a71 1
#define ARRAYMAX 2047		/* max array index */
@


1.28
log
@Bump max array size. Needed for upcoming MAKEDEV speedup. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.27 2005/03/28 21:33:04 deraadt Exp $	*/
a223 1
EXTERN	char	slash [] I__("/");
@


1.27
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.26 2005/02/21 16:01:58 otto Exp $	*/
d71 1
a71 1
#define ARRAYMAX 1023		/* max array index */
@


1.26
log
@Set \u in prompt expansion to the right value, while avoiding getpw* calls,
which might be very inconvenient when the yp server is not available.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.25 2004/12/22 17:14:34 millert Exp $	*/
d227 2
a228 2
    TT_HEREDOC_EXP,	/* expanded heredoc */
    TT_HIST_EDIT	/* temp file used for history editing (fc -e) */
d298 4
a301 4
		TMOUT_EXECUTING	= 0,	/* executing commands */
		TMOUT_READING,		/* waiting for input */
		TMOUT_LEAVING		/* have timed out */
	};
@


1.25
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.24 2004/12/18 22:43:58 millert Exp $	*/
d80 1
@


1.24
log
@Use _PATH_BSHELL instead of hardcoding "/bin/sh"
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.23 2004/12/18 22:11:43 millert Exp $	*/
d16 1
a49 4

typedef int bool_t;
#define	FALSE	0
#define	TRUE	1
@


1.23
log
@Flags set in signal handlers should be volatile sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.22 2004/12/18 21:58:39 millert Exp $	*/
d47 1
a47 1
#define EXECSHELL	"/bin/sh"
@


1.22
log
@Use the BSD sig_t instead of homegrown handler_t
Remove KSH_SA_FLAGS
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.21 2004/12/18 21:04:52 millert Exp $	*/
d259 1
a259 1
	int	volatile set;	/* trap pending */
d290 3
a292 3
EXTERN	int volatile trap;	/* traps pending? */
EXTERN	int volatile intrsig;	/* pending trap interrupts executing command */
EXTERN	int volatile fatal_trap;/* received a fatal signal */
@


1.21
log
@Get rid of #ifdef KSH since we don't care about building a V7 style sh and
the #ifdef KSH code is required to make a POSIX sh.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.20 2004/12/18 20:55:52 millert Exp $	*/
a27 7
/* struct sigaction.sa_flags is set to KSH_SA_FLAGS.  Used to ensure
 * system calls are interrupted
 */
#define KSH_SA_FLAGS	0

typedef	void (*handler_t)(int);	/* signal handler */

d261 2
a262 2
	handler_t cursig;	/* current handler (valid if TF_ORIG_* set) */
	handler_t shtrap;	/* shell signal handler */
@


1.20
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.19 2004/12/12 06:53:13 deraadt Exp $	*/
a301 1
#ifdef KSH
a312 1
#endif /* KSH */
a363 1
#ifdef KSH
a375 1
#endif /* KSH */
@


1.19
log
@csh-style ! history completion, which can be activated by using
	set -o csh-history (off by default)
this is not feature complete, and likely never will be.  no ^
and ! has some oddities ... ksh's internal history stuff has got
some very odd behaviours that are rather nasty
ok various developers
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.18 2004/05/31 10:36:35 otto Exp $	*/
a10 6
#ifdef HAVE_PROTOTYPES
# define	ARGS(args)	args	/* prototype declaration */
#else
# define	ARGS(args)	()	/* K&R declaration */
#endif

d16 5
a20 96
#ifdef HAVE_STDDEF_H
# include <stddef.h>
#endif

#ifdef HAVE_STDLIB_H
# include <stdlib.h>
#else
/* just a useful subset of what stdlib.h would have */
extern char * getenv  ARGS((const char *));
extern void * malloc  ARGS((size_t));
extern void * realloc ARGS((void *, size_t));
extern int    free    ARGS((void *));
extern int    exit    ARGS((int));
extern int    rand    ARGS((void));
extern void   srand   ARGS((unsigned int));
extern int    atoi    ARGS((const char *));
#endif /* HAVE_STDLIB_H */

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#else
/* just a useful subset of what unistd.h would have */
extern int access ARGS((const char *, int));
extern int open ARGS((const char *, int, ...));
extern int creat ARGS((const char *, mode_t));
extern int read ARGS((int, char *, unsigned));
extern int write ARGS((int, const char *, unsigned));
extern off_t lseek ARGS((int, off_t, int));
extern int close ARGS((int));
extern int pipe ARGS((int []));
extern int dup2 ARGS((int, int));
extern int unlink ARGS((const char *));
extern int fork ARGS((void));
extern int execve ARGS((const char *, char * const[], char * const[]));
extern int chdir ARGS((const char *));
extern int kill ARGS((pid_t, int));
extern char *getcwd();	/* no ARGS here - differs on different machines */
extern int geteuid ARGS((void));
extern int readlink ARGS((const char *, char *, int));
extern int getegid ARGS((void));
extern int getpid ARGS((void));
extern int getppid ARGS((void));
extern unsigned int sleep ARGS((unsigned int));
extern int isatty ARGS((int));
# ifdef POSIX_PGRP
extern int getpgrp ARGS((void));
extern int setpgid ARGS((pid_t, pid_t));
# endif /* POSIX_PGRP */
# ifdef BSD_PGRP
extern int getpgrp ARGS((pid_t));
extern int setpgrp ARGS((pid_t, pid_t));
# endif /* BSD_PGRP */
# ifdef SYSV_PGRP
extern int getpgrp ARGS((void));
extern int setpgrp ARGS((void));
# endif /* SYSV_PGRP */
#endif /* HAVE_UNISTD_H */

#ifdef HAVE_STRING_H
# include <string.h>
#else
# include <strings.h>
# define strchr index
# define strrchr rindex
#endif /* HAVE_STRING_H */
#ifndef HAVE_STRSTR
char *strstr ARGS((const char *s, const char *p));
#endif /* HAVE_STRSTR */
#ifndef HAVE_STRCASECMP
int strcasecmp ARGS((const char *s1, const char *s2));
int strncasecmp ARGS((const char *s1, const char *s2, int n));
#endif /* HAVE_STRCASECMP */

#ifdef HAVE_MEMORY_H
# include <memory.h>
#endif
#ifndef HAVE_MEMSET
# define memcpy(d, s, n)	bcopy(s, d, n)
# define memcmp(s1, s2, n)	bcmp(s1, s2, n)
void *memset ARGS((void *d, int c, size_t n));
#endif /* HAVE_MEMSET */
#ifndef HAVE_MEMMOVE
# ifdef HAVE_BCOPY
#  define memmove(d, s, n)	bcopy(s, d, n)
# else
void *memmove ARGS((void *d, const void *s, size_t n));
# endif
#endif /* HAVE_MEMMOVE */

#ifdef HAVE_PROTOTYPES
# include <stdarg.h>
# define SH_VA_START(va, argn) va_start(va, argn)
#else
# include <varargs.h>
# define SH_VA_START(va, argn) va_start(va)
#endif /* HAVE_PROTOTYPES */
d23 2
d26 1
a26 34
#ifdef HAVE_FCNTL_H
# include <fcntl.h>
#else
# include <sys/file.h>
#endif /* HAVE_FCNTL_H */
#ifndef O_ACCMODE
# define O_ACCMODE	(O_RDONLY|O_WRONLY|O_RDWR)
#endif /* !O_ACCMODE */

#ifndef F_OK 	/* access() arguments */
# define F_OK 0
# define X_OK 1
# define W_OK 2
# define R_OK 4
#endif /* !F_OK */

#ifndef SEEK_SET
# ifdef L_SET
#  define SEEK_SET L_SET
#  define SEEK_CUR L_INCR
#  define SEEK_END L_XTND
# else /* L_SET */
#  define SEEK_SET 0
#  define SEEK_CUR 1
#  define SEEK_END 2
# endif /* L_SET */
#endif /* !SEEK_SET */

/* Some machines (eg, FreeBSD 1.1.5) define CLK_TCK in limits.h
 * (ksh_limval.h assumes limits has been included, if available)
 */
#ifdef HAVE_LIMITS_H
# include <limits.h>
#endif /* HAVE_LIMITS_H */
a27 17
#include <signal.h>
#ifdef	NSIG
# define SIGNALS	NSIG
#else
# ifdef	_MINIX
#  define SIGNALS	(_NSIG+1) /* _NSIG is # of signals used, excluding 0. */
# else
#  ifdef _SIGMAX	/* QNX */
#   define SIGNALS	_SIGMAX
#  else /* _SIGMAX */
#   define SIGNALS	32
#  endif /* _SIGMAX */
# endif	/* _MINIX */
#endif	/* NSIG */
#ifndef SIGCHLD
# define SIGCHLD SIGCLD
#endif
d31 1
a31 11
#ifdef SA_INTERRUPT
# define KSH_SA_FLAGS	SA_INTERRUPT
#else /* SA_INTERRUPT */
# define KSH_SA_FLAGS	0
#endif /* SA_INTERRUPT */

typedef	RETSIGTYPE (*handler_t) ARGS((int));	/* signal handler */

#ifdef USE_FAKE_SIGACT
# include "sigact.h"			/* use sjg's fake sigaction() */
#endif
d33 1
a33 8
#ifdef HAVE_PATHS_H
# include <paths.h>
#endif /* HAVE_PATHS_H */
#ifdef _PATH_DEFPATH
# define DEFAULT__PATH _PATH_DEFPATH
#else /* _PATH_DEFPATH */
# define DEFAULT__PATH DEFAULT_PATH
#endif /* _PATH_DEFPATH */
d35 1
a35 46
#ifndef offsetof
# define offsetof(type,id) ((size_t)&((type*)NULL)->id)
#endif

#ifndef HAVE_KILLPG
# define killpg(p, s)	kill(-(p), (s))
#endif /* !HAVE_KILLPG */

/* Special cases for execve(2) */
#ifdef OS2
extern int ksh_execve(char *cmd, char **args, char **env, int flags);
#else /* OS2 */
# if defined(OS_ISC) && defined(_POSIX_SOURCE)
/* Kludge for ISC 3.2 (and other versions?) so programs will run correctly.  */
#  define ksh_execve(p, av, ev, flags) \
				do { \
					__setostype(0); \
					execve(p, av, ev); \
					__setostype(1); \
				} while (0)
# else /* OS_ISC && _POSIX */
#  define ksh_execve(p, av, ev, flags)	execve(p, av, ev)
# endif /* OS_ISC && _POSIX */
#endif /* OS2 */

/* this is a hang-over from older versions of the os2 port */
#define ksh_dupbase(fd, base) fcntl(fd, F_DUPFD, base)

#ifdef HAVE_SIGSETJMP
# define ksh_sigsetjmp(env,sm)	sigsetjmp((env), (sm))
# define ksh_siglongjmp(env,v)	siglongjmp((env), (v))
# define ksh_jmp_buf		sigjmp_buf
#else /* HAVE_SIGSETJMP */
# ifdef HAVE__SETJMP
#  define ksh_sigsetjmp(env,sm)	_setjmp(env)
#  define ksh_siglongjmp(env,v)	_longjmp((env), (v))
# else /* HAVE__SETJMP */
#  define ksh_sigsetjmp(env,sm)	setjmp(env)
#  define ksh_siglongjmp(env,v)	longjmp((env), (v))
# endif /* HAVE__SETJMP */
# define ksh_jmp_buf		jmp_buf
#endif /* HAVE_SIGSETJMP */

#ifndef HAVE_DUP2
extern int dup2 ARGS((int, int));
#endif /* !HAVE_DUP2 */
a44 7
/* Stop gcc and lint from complaining about possibly uninitialized variables */
#if defined(__GNUC__) || defined(lint)
# define UNINITIALIZED(var)	var = 0
#else
# define UNINITIALIZED(var)	var
#endif /* GNUC || lint */

d54 2
a55 65
#ifdef OS2
# define inDOS() (!(_emx_env & 0x200))
#endif

#ifndef EXECSHELL
/* shell to exec scripts (see also $SHELL initialization in main.c) */
# ifdef OS2
#  define EXECSHELL	(inDOS() ? "c:\\command.com" : "c:\\os2\\cmd.exe")
#  define EXECSHELL_STR	(inDOS() ? "COMSPEC" : "OS2_SHELL")
# else /* OS2 */
#  define EXECSHELL	"/bin/sh"
#  define EXECSHELL_STR	"EXECSHELL"
# endif /* OS2 */
#endif

/* ISABSPATH() means path is fully and completely specified,
 * ISROOTEDPATH() means a .. as the first component is a no-op,
 * ISRELPATH() means $PWD can be tacked on to get an absolute path.
 *
 * OS		Path		ISABSPATH	ISROOTEDPATH	ISRELPATH
 * unix		/foo		yes		yes		no
 * unix		foo		no		no		yes
 * unix		../foo		no		no		yes
 * os2+cyg	a:/foo		yes		yes		no
 * os2+cyg	a:foo		no		no		no
 * os2+cyg	/foo		no		yes		no
 * os2+cyg	foo		no		no		yes
 * os2+cyg	../foo		no		no		yes
 * cyg 		//foo		yes		yes		no
 */
#ifdef OS2
# define PATHSEP        ';'
# define DIRSEP         '/'	/* even though \ is native */
# define DIRSEPSTR      "\\"
# define ISDIRSEP(c)    ((c) == '\\' || (c) == '/')
# define ISABSPATH(s)	(((s)[0] && (s)[1] == ':' && ISDIRSEP((s)[2])))
# define ISROOTEDPATH(s) (ISDIRSEP((s)[0]) || ISABSPATH(s))
# define ISRELPATH(s)	(!(s)[0] || ((s)[1] != ':' && !ISDIRSEP((s)[0])))
# define FILECHCONV(c)	(isascii(c) && isupper(c) ? tolower(c) : c)
# define FILECMP(s1, s2) stricmp(s1, s2)
# define FILENCMP(s1, s2, n) strnicmp(s1, s2, n)
extern char *ksh_strchr_dirsep(const char *path);
extern char *ksh_strrchr_dirsep(const char *path);
# define chdir          _chdir2
# define getcwd         _getcwd2
#else
# define PATHSEP        ':'
# define DIRSEP         '/'
# define DIRSEPSTR      "/"
# define ISDIRSEP(c)    ((c) == '/')
#ifdef __CYGWIN__
#  define ISABSPATH(s) \
       (((s)[0] && (s)[1] == ':' && ISDIRSEP((s)[2])) || ISDIRSEP((s)[0]))
#  define ISRELPATH(s) (!(s)[0] || ((s)[1] != ':' && !ISDIRSEP((s)[0])))
#else /* __CYGWIN__ */
# define ISABSPATH(s)	ISDIRSEP((s)[0])
# define ISRELPATH(s)	(!ISABSPATH(s))
#endif /* __CYGWIN__ */
# define ISROOTEDPATH(s) ISABSPATH(s)
# define FILECHCONV(c)	c
# define FILECMP(s1, s2) strcmp(s1, s2)
# define FILENCMP(s1, s2, n) strncmp(s1, s2, n)
# define ksh_strchr_dirsep(p)   strchr(p, DIRSEP)
# define ksh_strrchr_dirsep(p)  strrchr(p, DIRSEP)
#endif
a70 3
/* you're not going to run setuid shell scripts, are you? */
#define	eaccess(path, mode)	access(path, mode)

a101 4
#ifdef MEM_DEBUG
# include "chmem.h" /* a debugging front end for malloc et. al. */
#endif /* MEM_DEBUG */

d122 1
a122 1
	ksh_jmp_buf jbuf;		/* long jump back to env creator */
d147 1
a147 1
/* values for ksh_siglongjmp(e->jbuf, 0) */
d295 1
a295 1
#define SIGERR_		SIGNALS	/* for trap ERR */
d300 1
a300 4
#ifndef FROM_TRAP_C
/* Kludge to avoid bogus re-declaration of sigtraps[] error on AIX 3.2.5 */
extern	Trap	sigtraps[SIGNALS+1];
#endif /* !FROM_TRAP_C */
a381 1
#ifdef JOB_SIGS
a382 1
#endif /* JOB_SIGS */
d416 1
a416 7
#ifndef KSH_SYSTEM_PROFILE
# ifdef __NeXT
#  define KSH_SYSTEM_PROFILE "/etc/profile.std"
# else /* __NeXT */
#  define KSH_SYSTEM_PROFILE "/etc/profile"
# endif /* __NeXT */
#endif /* KSH_SYSTEM_PROFILE */
@


1.18
log
@Remove redundant errno declaration. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.17 2004/05/10 16:28:47 pvalchev Exp $	*/
d466 1
@


1.17
log
@double the command line buffer size (1024 -> 2048); ok millert deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.16 2004/02/08 19:18:15 deraadt Exp $	*/
a119 1
extern int errno;
@


1.16
log
@forget about 16 bit machines; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.15 2003/10/22 07:40:38 jmc Exp $	*/
d360 1
a360 1
#define	LINE	1024		/* input line size */
@


1.15
log
@typos from Jared Yanovich;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.14 2003/09/01 15:47:40 naddy Exp $	*/
a248 1
#if SIZEOF_INT >= 4
a249 7
#else /* SIZEOF_INT */
# if SIZEOF_LONG >= 4
#  define INT32	long
# else /* SIZEOF_LONG */
   #error cannot find 32 bit type...
# endif /* SIZEOF_LONG */
#endif /* SIZEOF_INT */
@


1.14
log
@In emacs editing mode, ksh by default interprets a set 8th bit as
meta prefix, i.e. all characters with the top bit set (>= 0x80) are
taken as commands and cannot be entered literally.

Introduce a new shell option, emacs-usemeta, that allows to toggle
this behavior.  The default is the traditional behavior; to enter
8-bit characters use "set +o emacs-usemeta".

ok fgsch@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.13 2003/05/16 19:58:57 jsyn Exp $	*/
d485 1
a485 1
	FKEYWORD,	/* -k: name=value anywere */
d502 1
a502 1
	FSH,		/* -o sh: favor sh behavour */
d692 1
a692 1
/* Minimium required space to work with on a line - if the prompt leaves less
d696 1
a696 1
/* Minimium allowed value for x_cols: 2 for prompt, 3 for " < " at end of line
@


1.13
log
@fix several constant overflows, remove the strerror prototype (shouldn't be
there), and cleanup some whitespace; help from, and okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.12 2002/10/07 23:09:32 vincent Exp $	*/
d477 1
@


1.12
log
@int -> uid_t

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.11 2002/03/01 13:13:54 espie Exp $	*/
a16 1

d364 1
a364 1
#define	MAGIC		(7)/* prefix for *?[!{,} during expand */
a379 1

a382 1

a404 1

a450 1

a595 1

a609 1

a612 1

a634 1

a659 1

a701 1

@


1.11
log
@this is needed too
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.10 1999/07/15 20:39:40 millert Exp $	*/
d376 1
a376 1
EXTERN	int	ksheuid;	/* effective uid of shell */
@


1.10
log
@o Set default line edit mode to emacs (VISUAL/EDITOR or user can override)
o Spell environment correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.9 1999/06/15 01:18:36 millert Exp $	*/
d387 1
a387 1
	struct Block *freelist;	/* free list */
@


1.9
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.8 1999/01/19 20:41:56 millert Exp $	*/
d413 1
a413 1
	short	type;			/* enviroment type - see below */
d418 1
a418 1
	struct	env *oenv;		/* link to previous enviroment */
d424 1
a424 1
#define	E_NONE	0		/* dummy enviroment */
@


1.8
log
@Updates from pdksh-unstable-5.2.13.7.  Most notable change is:
    trap: exit traps now executed in subshells (without explicit exit call).
See the Changelog for a full list of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.7 1999/01/08 20:25:02 millert Exp $	*/
d242 4
d297 10
a306 9
 * OS	Path		ISABSPATH	ISROOTEDPATH	ISRELPATH
 * unix	/foo		yes		yes		no
 * unix	foo		no		no		yes
 * unix	../foo		no		no		yes
 * os2	a:/foo		yes		yes		no
 * os2	a:foo		no		no		no
 * os2	/foo		no		yes		no
 * os2	foo		no		no		yes
 * os2	../foo		no		no		yes
d328 5
d334 2
a336 1
# define ISRELPATH(s)	(!ISABSPATH(s))
d436 1
d531 6
a536 1
/* temp/here files. the file is removed when the struct is freed */
d541 1
a544 4
/* here documents in functions are treated specially (the get removed when
 * shell exis) */
EXTERN struct temp	*func_heredocs;

d730 4
@


1.7
log
@bug fixes from pdksh-unstable-5.2.13.5; some of which we already had.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.6 1998/06/25 19:02:19 millert Exp $	*/
d209 1
a209 1
extern int ksh_execve(char *cmd, char **args, char **env);
d213 2
a214 1
#  define ksh_execve(p, av, ev) do { \
d220 1
a220 1
#  define ksh_execve(p, av, ev)	execve(p, av, ev)
d274 4
d281 2
a282 2
#  define EXECSHELL	"c:\\os2\\cmd.exe"
#  define EXECSHELL_STR	"OS2_SHELL"
@


1.6
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.5 1997/01/02 09:34:10 downsj Exp $	*/
d381 10
@


1.5
log
@Add FSH (set -o sh), initialize it if we're /bin/sh, and add the first use:
don't set $_ if we're non-interactive.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.4 1996/12/18 18:28:37 niklas Exp $	*/
d33 1
d242 2
a243 1
 * by autoconf (assumes an 8 bit byte, but I'm not concerned)
d360 1
d433 2
a434 1
#define OF_ANY		(OF_CMDLINE | OF_SET | OF_SPECIAL)
d491 1
d629 1
d638 1
@


1.4
log
@Up limit of available user file descriptors (e.g. for redirections) to 32
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.3 1996/10/01 02:05:47 downsj Exp $	*/
d475 1
@


1.3
log
@Integrate pdksh 5.2.9.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.2 1996/08/19 20:08:58 downsj Exp $	*/
d337 1
a337 1
#define	NUFILE	10		/* Number of user-accessible files */
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
d685 8
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d334 3
d483 1
d530 1
d549 2
a550 2
#define SS_RESTORE_DFL	2	/* restore SIG_DFL */
#define SS_RESTORE_IGN	3	/* restore SIG_IGN */
d553 1
d567 1
d579 1
d589 9
a597 8
#define	C_ALPHA	0x01		/* a-z_A-Z */
#define	C_DIGIT	0x02		/* 0-9 */
#define	C_LEX1	0x04		/* \0 \t\n|&;<>() */
#define	C_VAR1	0x08		/* *@@#!$-? */
#define	C_IFSWS	0x10		/* \t \n (IFS white space) */
#define	C_SUBOP1 0x20		/* "=-+?" */
#define	C_SUBOP2 0x40		/* "#%" */
#define	C_IFS	0x80		/* $IFS */
d599 1
a599 1
extern	char ctypes [];
d635 2
d641 3
a643 1
	void	*job;		/* 0 if no co-process, or co-process died */
d648 5
d657 1
a657 1
EXTERN int	builtin_flag;	/* flags of called builtin (SPEC_BI, etc.) */
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
