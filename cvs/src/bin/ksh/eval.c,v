head	1.52;
access;
symbols
	OPENBSD_6_1:1.50.0.6
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.50.0.2
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.40.0.10
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.40.0.6
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.37.0.6
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.4
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.2
	OPENBSD_5_0:1.36.0.2
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.35.0.4
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.34.0.4
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.34.0.6
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.2
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.33.0.6
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.4
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.30.0.4
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.12
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.10
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.8
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.6
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.52
date	2017.07.04.07.29.32;	author anton;	state Exp;
branches;
next	1.51;
commitid	EAU5Bw3i4umUy47M;

1.51
date	2017.05.01.19.05.49;	author millert;	state Exp;
branches;
next	1.50;
commitid	4IDdWRRTgYpyOJvD;

1.50
date	2016.03.05.12.30.17;	author czarkoff;	state Exp;
branches;
next	1.49;
commitid	p72q8J4cTZGtbPkx;

1.49
date	2015.12.30.09.07.00;	author tedu;	state Exp;
branches;
next	1.48;
commitid	WTwPzlskFufQpRQz;

1.48
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.47;
commitid	btTCreDA00YdaFhU;

1.47
date	2015.11.12.04.04.31;	author mmcc;	state Exp;
branches;
next	1.46;
commitid	QvyWaajN4Lc4MRtd;

1.46
date	2015.10.19.17.15.53;	author mmcc;	state Exp;
branches;
next	1.45;
commitid	zuJ55EJoQ0lgfTwv;

1.45
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.44;
commitid	C4W85jmosThChWA2;

1.44
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.43;
commitid	16HUr75moyUNtKR8;

1.43
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.42;
commitid	7fgq4YTZG4xZ0uN0;

1.42
date	2015.09.17.14.21.33;	author nicm;	state Exp;
branches;
next	1.41;
commitid	v5QjoxUgKU2iUTFz;

1.41
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.40;
commitid	lBs9un9sXhbdfVrQ;

1.40
date	2013.09.14.20.09.30;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2013.07.01.17.25.27;	author jca;	state Exp;
branches;
next	1.38;

1.38
date	2013.06.19.12.19.02;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2011.10.11.14.32.43;	author otto;	state Exp;
branches;
next	1.36;

1.36
date	2011.03.15.08.39.54;	author okan;	state Exp;
branches;
next	1.35;

1.35
date	2010.03.24.08.27.26;	author fgsch;	state Exp;
branches;
next	1.34;

1.34
date	2009.01.29.23.27.26;	author jaredy;	state Exp;
branches;
next	1.33;

1.33
date	2007.08.02.11.05.54;	author fgsch;	state Exp;
branches;
next	1.32;

1.32
date	2007.08.02.10.56.25;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.02.10.50.25;	author fgsch;	state Exp;
branches;
next	1.30;

1.30
date	2006.04.10.14.38.59;	author jaredy;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.17.16.30.13;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.11.20.31.21;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.25.11.21.16;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.02.07.53.01;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.22.18.52.37;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.22.18.39.31;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.13.16.37.06;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.09.11.32.07;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.08.21.23.18;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.25.04.36.47;	author jaredy;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.10.21.26.39;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.16.23.11.52;	author tdeval;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.10.03.48.16;	author david;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	99.06.15.01.18.33;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.01.10.17.55.02;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.01.08.20.24.58;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.10.29.04.09.20;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.06.25.19.01.53;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.06.19.13.58.40;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.06.18.22.42.33;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.49;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.11;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.52
log
@Add support for pattern substitution to variables in ksh using a common syntax
borrowed from ksh93.

Survived a ports build performed by naddy@@ and encouraged by many.
@
text
@/*	$OpenBSD: eval.c,v 1.51 2017/05/01 19:05:49 millert Exp $	*/

/*
 * Expansion - quoting, separation, substitution, globbing
 */

#include <sys/stat.h>

#include <ctype.h>
#include <dirent.h>
#include <fcntl.h>
#include <pwd.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "sh.h"

/*
 * string expansion
 *
 * first pass: quoting, IFS separation, ~, ${}, $() and $(()) substitution.
 * second pass: alternation ({,}), filename expansion (*?[]).
 */

/* expansion generator state */
typedef struct Expand {
	/* int  type; */	/* see expand() */
	const char *str;	/* string */
	union {
		const char **strv;/* string[] */
		struct shf *shf;/* file */
	} u;			/* source */
	struct tbl *var;	/* variable in ${var..} */
	short	split;		/* split "$@@" / call waitlast $() */
} Expand;

#define	XBASE		0	/* scanning original */
#define	XSUB		1	/* expanding ${} string */
#define	XARGSEP		2	/* ifs0 between "$*" */
#define	XARG		3	/* expanding $*, $@@ */
#define	XCOM		4	/* expanding $() */
#define XNULLSUB	5	/* "$@@" when $# is 0 (don't generate word) */
#define XSUBMID		6	/* middle of expanding ${} */

/* States used for field splitting */
#define IFS_WORD	0	/* word has chars (or quotes) */
#define IFS_WS		1	/* have seen IFS white-space */
#define IFS_NWS		2	/* have seen IFS non-white-space */

static	int	varsub(Expand *, char *, char *, int *, int *);
static	int	comsub(Expand *, char *);
static	char   *strsub(char *, char *, int);
static	char   *trimsub(char *, char *, int);
static	void	glob(char *, XPtrV *, int);
static	void	globit(XString *, char **, char *, XPtrV *, int);
static char	*maybe_expand_tilde(char *, XString *, char **, int);
static	char   *tilde(char *);
static	char   *homedir(char *);
#ifdef BRACE_EXPAND
static void	alt_expand(XPtrV *, char *, char *, char *, int);
#endif

/* compile and expand word */
char *
substitute(const char *cp, int f)
{
	struct source *s, *sold;

	sold = source;
	s = pushs(SWSTR, ATEMP);
	s->start = s->str = cp;
	source = s;
	if (yylex(ONEWORD) != LWORD)
		internal_errorf(1, "substitute");
	source = sold;
	afree(s, ATEMP);
	return evalstr(yylval.cp, f);
}

/*
 * expand arg-list
 */
char **
eval(char **ap, int f)
{
	XPtrV w;

	if (*ap == NULL)
		return ap;
	XPinit(w, 32);
	XPput(w, NULL);		/* space for shell name */
	while (*ap != NULL)
		expand(*ap++, &w, f);
	XPput(w, NULL);
	return (char **) XPclose(w) + 1;
}

/*
 * expand string
 */
char *
evalstr(char *cp, int f)
{
	XPtrV w;

	XPinit(w, 1);
	expand(cp, &w, f);
	cp = (XPsize(w) == 0) ? null : (char*) *XPptrv(w);
	XPfree(w);
	return cp;
}

/*
 * expand string - return only one component
 * used from iosetup to expand redirection files
 */
char *
evalonestr(char *cp, int f)
{
	XPtrV w;

	XPinit(w, 1);
	expand(cp, &w, f);
	switch (XPsize(w)) {
	case 0:
		cp = null;
		break;
	case 1:
		cp = (char*) *XPptrv(w);
		break;
	default:
		cp = evalstr(cp, f&~DOGLOB);
		break;
	}
	XPfree(w);
	return cp;
}

/* for nested substitution: ${var:=$var2} */
typedef struct SubType {
	short	stype;		/* [=+-?%#] action after expanded word */
	short	base;		/* begin position of expanded word */
	short	f;		/* saved value of f (DOPAT, etc) */
	struct tbl *var;	/* variable for ${var..} */
	short	quote;		/* saved value of quote (for ${..[%#]..}) */
	int	strsub;		/* set to 1 if pat in /pat/rep has been ended */
	struct SubType *prev;	/* old type */
	struct SubType *next;	/* poped type (to avoid re-allocating) */
} SubType;

void
expand(char *cp,	/* input word */
    XPtrV *wp,		/* output words */
    int f)		/* DO* flags */
{
	int c = 0;
	int type;		/* expansion type */
	int quote = 0;		/* quoted */
	XString ds;		/* destination string */
	char *dp, *sp;		/* dest., source */
	int fdo, word;		/* second pass flags; have word */
	int doblank;		/* field splitting of parameter/command subst */
	Expand x = {
		/* expansion variables */
		NULL, { NULL }, NULL, 0
	};
	SubType st_head, *st;
	int newlines = 0; /* For trailing newlines in COMSUB */
	int saw_eq, tilde_ok;
	int make_magic;
	size_t len;

	if (cp == NULL)
		internal_errorf(1, "expand(NULL)");
	/* for alias, readonly, set, typeset commands */
	if ((f & DOVACHECK) && is_wdvarassign(cp)) {
		f &= ~(DOVACHECK|DOBLANK|DOGLOB|DOTILDE);
		f |= DOASNTILDE;
	}
	if (Flag(FNOGLOB))
		f &= ~DOGLOB;
	if (Flag(FMARKDIRS))
		f |= DOMARKDIRS;
#ifdef BRACE_EXPAND
	if (Flag(FBRACEEXPAND) && (f & DOGLOB))
		f |= DOBRACE_;
#endif /* BRACE_EXPAND */

	Xinit(ds, dp, 128, ATEMP);	/* init dest. string */
	type = XBASE;
	sp = cp;
	fdo = 0;
	saw_eq = 0;
	tilde_ok = (f & (DOTILDE|DOASNTILDE)) ? 1 : 0; /* must be 1/0 */
	doblank = 0;
	make_magic = 0;
	word = (f&DOBLANK) ? IFS_WS : IFS_WORD;
	st_head.next = NULL;
	st = &st_head;

	while (1) {
		Xcheck(ds, dp);

		switch (type) {
		case XBASE:	/* original prefixed string */
			c = *sp++;
			switch (c) {
			case EOS:
				c = 0;
				break;
			case CHAR:
				c = *sp++;
				if (st->strsub == 0 &&
				    (st->stype & 0x7f) == '/' && c == '/') {
					st->strsub = 1;
					/* Write end of pattern. */
					*dp++ = MAGIC;
					*dp++ = ')';
					*dp++ = '\0';
					/*
					 * Reset quote and flags for the
					 * upcoming replacement.
					 */
					quote = 0;
					f = 0;
					continue;
				}
				break;
			case QCHAR:
				quote |= 2; /* temporary quote */
				c = *sp++;
				break;
			case OQUOTE:
				word = IFS_WORD;
				tilde_ok = 0;
				quote = 1;
				continue;
			case CQUOTE:
				quote = 0;
				continue;
			case COMSUB:
				tilde_ok = 0;
				if (f & DONTRUNCOMMAND) {
					word = IFS_WORD;
					*dp++ = '$'; *dp++ = '(';
					while (*sp != '\0') {
						Xcheck(ds, dp);
						*dp++ = *sp++;
					}
					*dp++ = ')';
				} else {
					type = comsub(&x, sp);
					if (type == XCOM && (f&DOBLANK))
						doblank++;
					sp = strchr(sp, 0) + 1;
					newlines = 0;
				}
				continue;
			case EXPRSUB:
				word = IFS_WORD;
				tilde_ok = 0;
				if (f & DONTRUNCOMMAND) {
					*dp++ = '$'; *dp++ = '('; *dp++ = '(';
					while (*sp != '\0') {
						Xcheck(ds, dp);
						*dp++ = *sp++;
					}
					*dp++ = ')'; *dp++ = ')';
				} else {
					struct tbl v;
					char *p;

					v.flag = DEFINED|ISSET|INTEGER;
					v.type = 10; /* not default */
					v.name[0] = '\0';
					v_evaluate(&v, substitute(sp, 0),
					    KSH_UNWIND_ERROR, true);
					sp = strchr(sp, 0) + 1;
					for (p = str_val(&v); *p; ) {
						Xcheck(ds, dp);
						*dp++ = *p++;
					}
				}
				continue;
			case OSUBST: /* ${{#}var{:}[=+-?#%]word} */
			  /* format is:
			   *   OSUBST [{x] plain-variable-part \0
			   *     compiled-word-part CSUBST [}x]
			   * This is where all syntax checking gets done...
			   */
			    {
				char *varname = ++sp; /* skip the { or x (}) */
				int stype;
				int slen = 0;

				sp = strchr(sp, '\0') + 1; /* skip variable */
				type = varsub(&x, varname, sp, &stype, &slen);
				if (type < 0) {
					char endc;
					char *str, *end;

					sp = varname - 2; /* restore sp */
					end = (char *) wdscan(sp, CSUBST);
					/* ({) the } or x is already skipped */
					endc = *end;
					*end = EOS;
					str = snptreef(NULL, 64, "%S", sp);
					*end = endc;
					errorf("%s: bad substitution", str);
				}
				if (f&DOBLANK)
					doblank++;
				tilde_ok = 0;
				if (type == XBASE) {	/* expand? */
					if (!st->next) {
						SubType *newst;

						newst = alloc(
						    sizeof(SubType), ATEMP);
						newst->next = NULL;
						newst->prev = st;
						st->next = newst;
					}
					st = st->next;
					st->stype = stype;
					st->base = Xsavepos(ds, dp);
					st->f = f;
					st->var = x.var;
					st->quote = quote;
					/* skip qualifier(s) */
					if (stype)
						sp += slen;
					switch (stype & 0x7f) {
					case '#':
					case '%':
					case '/':
						/* ! DOBLANK,DOBRACE_,DOTILDE */
						f = DOPAT | (f&DONTRUNCOMMAND) |
						    DOTEMP_;
						quote = 0;
						/* Prepend open pattern (so |
						 * in a trim will work as
						 * expected)
						 */
						*dp++ = MAGIC;
						*dp++ = '@@' + 0x80U;
						break;
					case '=':
						/* Enabling tilde expansion
						 * after :'s here is
						 * non-standard ksh, but is
						 * consistent with rules for
						 * other assignments.  Not
						 * sure what POSIX thinks of
						 * this.
						 * Not doing tilde expansion
						 * for integer variables is a
						 * non-POSIX thing - makes
						 * sense though, since ~ is
						 * a arithmetic operator.
						 */
						if (!(x.var->flag & INTEGER))
							f |= DOASNTILDE|DOTILDE;
						f |= DOTEMP_;
						/* These will be done after the
						 * value has been assigned.
						 */
						f &= ~(DOBLANK|DOGLOB|DOBRACE_);
						tilde_ok = 1;
						break;
					case '?':
						f &= ~DOBLANK;
						f |= DOTEMP_;
						/* FALLTHROUGH */
					default:
						/* Enable tilde expansion */
						tilde_ok = 1;
						f |= DOTILDE;
					}
				} else
					/* skip word */
					sp = (char *) wdscan(sp, CSUBST);
				continue;
			    }
			case CSUBST: /* only get here if expanding word */
				sp++; /* ({) skip the } or x */
				tilde_ok = 0;	/* in case of ${unset:-} */
				*dp = '\0';
				quote = st->quote;
				f = st->f;
				if (f&DOBLANK)
					doblank--;
				switch (st->stype&0x7f) {
				case '#':
				case '%':
					/* Append end-pattern */
					*dp++ = MAGIC; *dp++ = ')'; *dp = '\0';
					/* FALLTHROUGH */
				case '/':
					dp = Xrestpos(ds, dp, st->base);
					/* Must use st->var since calling
					 * global would break things
					 * like x[i+=1].
					 */
					if ((st->stype & 0x7f) == '/')
						x.str = strsub(str_val(st->var),
						    dp, st->stype);
					else
						x.str = trimsub(
						    str_val(st->var),
						    dp, st->stype);
					if (x.str[0] != '\0' || st->quote)
						type = XSUB;
					else
						type = XNULLSUB;
					if (f&DOBLANK)
						doblank++;
					st = st->prev;
					continue;
				case '=':
					/* Restore our position and substitute
					 * the value of st->var (may not be
					 * the assigned value in the presence
					 * of integer/right-adj/etc attributes).
					 */
					dp = Xrestpos(ds, dp, st->base);
					/* Must use st->var since calling
					 * global would cause with things
					 * like x[i+=1] to be evaluated twice.
					 */
					/* Note: not exported by FEXPORT
					 * in at&t ksh.
					 */
					/* XXX POSIX says readonly is only
					 * fatal for special builtins (setstr
					 * does readonly check).
					 */
					len = strlen(dp) + 1;
					setstr(st->var,
					    debunk(alloc(len, ATEMP),
					    dp, len), KSH_UNWIND_ERROR);
					x.str = str_val(st->var);
					type = XSUB;
					if (f&DOBLANK)
						doblank++;
					st = st->prev;
					continue;
				case '?':
				    {
					char *s = Xrestpos(ds, dp, st->base);

					errorf("%s: %s", st->var->name,
					    dp == s ?
					    "parameter null or not set" :
					    (debunk(s, s, strlen(s) + 1), s));
				    }
				}
				st = st->prev;
				type = XBASE;
				continue;

			case OPAT: /* open pattern: *(foo|bar) */
				/* Next char is the type of pattern */
				make_magic = 1;
				c = *sp++ + 0x80;
				break;

			case SPAT: /* pattern separator (|) */
				make_magic = 1;
				c = '|';
				break;

			case CPAT: /* close pattern */
				make_magic = 1;
				c = /*(*/ ')';
				break;
			}
			break;

		case XNULLSUB:
			/* Special case for "$@@" (and "${foo[@@]}") - no
			 * word is generated if $# is 0 (unless there is
			 * other stuff inside the quotes).
			 */
			type = XBASE;
			if (f&DOBLANK) {
				doblank--;
				/* not really correct: x=; "$x$@@" should
				 * generate a null argument and
				 * set A; "${@@:+}" shouldn't.
				 */
				if (dp == Xstring(ds, dp))
					word = IFS_WS;
			}
			continue;

		case XSUB:
		case XSUBMID:
			if ((c = *x.str++) == 0) {
				type = XBASE;
				if (f&DOBLANK)
					doblank--;
				continue;
			}
			break;

		case XARGSEP:
			type = XARG;
			quote = 1;
		case XARG:
			if ((c = *x.str++) == '\0') {
				/* force null words to be created so
				 * set -- '' 2 ''; foo "$@@" will do
				 * the right thing
				 */
				if (quote && x.split)
					word = IFS_WORD;
				if ((x.str = *x.u.strv++) == NULL) {
					type = XBASE;
					if (f&DOBLANK)
						doblank--;
					continue;
				}
				c = ifs0;
				if (c == 0) {
					if (quote && !x.split)
						continue;
					c = ' ';
				}
				if (quote && x.split) {
					/* terminate word for "$@@" */
					type = XARGSEP;
					quote = 0;
				}
			}
			break;

		case XCOM:
			if (x.u.shf == NULL)	/* $(< ...) failed, fake EOF */
				c = EOF;
			else if (newlines) {		/* Spit out saved nl's */
				c = '\n';
				--newlines;
			} else {
				while ((c = shf_getc(x.u.shf)) == 0 || c == '\n')
				    if (c == '\n')
					    newlines++;	/* Save newlines */
				if (newlines && c != EOF) {
					shf_ungetc(c, x.u.shf);
					c = '\n';
					--newlines;
				}
			}
			if (c == EOF) {
				newlines = 0;
				if (x.u.shf != NULL)
					shf_close(x.u.shf);
				if (x.split)
					subst_exstat = waitlast();
				else
					subst_exstat = (x.u.shf == NULL);
				type = XBASE;
				if (f&DOBLANK)
					doblank--;
				continue;
			}
			break;
		}

		/* check for end of word or IFS separation */
		if (c == 0 || (!quote && (f & DOBLANK) && doblank &&
		    !make_magic && ctype(c, C_IFS))) {
			/* How words are broken up:
			 *		   |       value of c
			 *	  word	   |	ws	nws	0
			 *	-----------------------------------
			 *	IFS_WORD	w/WS	w/NWS	w
			 *	IFS_WS		-/WS	w/NWS	-
			 *	IFS_NWS		-/NWS	w/NWS	w
			 *   (w means generate a word)
			 * Note that IFS_NWS/0 generates a word (at&t ksh
			 * doesn't do this, but POSIX does).
			 */
			if (word == IFS_WORD ||
			    (!ctype(c, C_IFSWS) && c && word == IFS_NWS)) {
				char *p;

				*dp++ = '\0';
				p = Xclose(ds, dp);
#ifdef BRACE_EXPAND
				if (fdo & DOBRACE_)
					/* also does globbing */
					alt_expand(wp, p, p,
					    p + Xlength(ds, (dp - 1)),
					    fdo | (f & DOMARKDIRS));
				else
#endif /* BRACE_EXPAND */
				if (fdo & DOGLOB)
					glob(p, wp, f & DOMARKDIRS);
				else if ((f & DOPAT) || !(fdo & DOMAGIC_))
					XPput(*wp, p);
				else
					XPput(*wp, debunk(p, p, strlen(p) + 1));
				fdo = 0;
				saw_eq = 0;
				tilde_ok = (f & (DOTILDE|DOASNTILDE)) ? 1 : 0;
				if (c != 0)
					Xinit(ds, dp, 128, ATEMP);
			}
			if (c == 0)
				return;
			if (word != IFS_NWS)
				word = ctype(c, C_IFSWS) ? IFS_WS : IFS_NWS;
		} else {
			if (type == XSUB) {
				if (word == IFS_NWS &&
				    Xlength(ds, dp) == 0) {
					char *p;

					if ((p = strdup("")) == NULL)
						internal_errorf(1, "unable "
						    "to allocate memory");
					XPput(*wp, p);
				}
				type = XSUBMID;
			}

			/* age tilde_ok info - ~ code tests second bit */
			tilde_ok <<= 1;
			/* mark any special second pass chars */
			if (!quote)
				switch (c) {
				case '[':
				case '!':
				case '-':
				case ']':
					/* For character classes - doesn't hurt
					 * to have magic !,-,]'s outside of
					 * [...] expressions.
					 */
					if (f & (DOPAT | DOGLOB)) {
						fdo |= DOMAGIC_;
						if (c == '[')
							fdo |= f & DOGLOB;
						*dp++ = MAGIC;
					}
					break;
				case '*':
				case '?':
					if (f & (DOPAT | DOGLOB)) {
						fdo |= DOMAGIC_ | (f & DOGLOB);
						*dp++ = MAGIC;
					}
					break;
#ifdef BRACE_EXPAND
				case OBRACE:
				case ',':
				case CBRACE:
					if ((f & DOBRACE_) && (c == OBRACE ||
					    (fdo & DOBRACE_))) {
						fdo |= DOBRACE_|DOMAGIC_;
						*dp++ = MAGIC;
					}
					break;
#endif /* BRACE_EXPAND */
				case '=':
					/* Note first unquoted = for ~ */
					if (!(f & DOTEMP_) && !saw_eq) {
						saw_eq = 1;
						tilde_ok = 1;
					}
					break;
				case ':': /* : */
					/* Note unquoted : for ~ */
					if (!(f & DOTEMP_) && (f & DOASNTILDE))
						tilde_ok = 1;
					break;
				case '~':
					/* tilde_ok is reset whenever
					 * any of ' " $( $(( ${ } are seen.
					 * Note that tilde_ok must be preserved
					 * through the sequence ${A=a=}~
					 */
					if (type == XBASE &&
					    (f & (DOTILDE|DOASNTILDE)) &&
					    (tilde_ok & 2)) {
						char *p, *dp_x;

						dp_x = dp;
						p = maybe_expand_tilde(sp,
						    &ds, &dp_x,
						    f & DOASNTILDE);
						if (p) {
							if (dp != dp_x)
								word = IFS_WORD;
							dp = dp_x;
							sp = p;
							continue;
						}
					}
					break;
				}
			else
				quote &= ~2; /* undo temporary */

			if (make_magic) {
				make_magic = 0;
				fdo |= DOMAGIC_ | (f & DOGLOB);
				*dp++ = MAGIC;
			} else if (ISMAGIC(c)) {
				fdo |= DOMAGIC_;
				*dp++ = MAGIC;
			}
			*dp++ = c; /* save output char */
			word = IFS_WORD;
		}
	}
}

/*
 * Prepare to generate the string returned by ${} substitution.
 */
static int
varsub(Expand *xp, char *sp, char *word,
    int *stypep,	/* becomes qualifier type */
    int *slenp)		/* " " len (=, :=, etc.) valid iff *stypep != 0 */
{
	int c;
	int state;	/* next state: XBASE, XARG, XSUB, XNULLSUB */
	int stype;	/* substitution type */
	int slen;
	char *p;
	struct tbl *vp;
	int zero_ok = 0;

	if (sp[0] == '\0')	/* Bad variable name */
		return -1;

	xp->var = NULL;

	/* ${#var}, string length or array size */
	if (sp[0] == '#' && (c = sp[1]) != '\0') {
		/* Can't have any modifiers for ${#...} */
		if (*word != CSUBST)
			return -1;
		sp++;
		/* Check for size of array */
		if ((p=strchr(sp,'[')) && (p[1]=='*'||p[1]=='@@') && p[2]==']') {
			int n = 0;

			vp = global(arrayname(sp));
			if (vp->flag & (ISSET|ARRAY))
				zero_ok = 1;
			for (; vp; vp = vp->u.array)
				if (vp->flag & ISSET)
					n++;
			c = n; /* ksh88/ksh93 go for number, not max index */
		} else if (c == '*' || c == '@@')
			c = genv->loc->argc;
		else {
			p = str_val(global(sp));
			zero_ok = p != null;
			c = strlen(p);
		}
		if (Flag(FNOUNSET) && c == 0 && !zero_ok)
			errorf("%s: parameter not set", sp);
		*stypep = 0; /* unqualified variable/string substitution */
		xp->str = str_save(ulton((unsigned long)c, 10), ATEMP);
		return XSUB;
	}

	/* Check for qualifiers in word part */
	stype = 0;
	c = word[slen = 0] == CHAR ? word[1] : 0;
	if (c == ':') {
		slen += 2;
		stype = 0x80;
		c = word[slen + 0] == CHAR ? word[slen + 1] : 0;
	}
	if (c == '/' && Flag(FPOSIX))
		return -1;

	if (ctype(c, C_SUBOP1)) {
		slen += 2;
		stype |= c;
	} else if (ctype(c, C_SUBOP2)) { /* Note: ksh88 allows :%, :%%, etc */
		slen += 2;
		stype = c;
		if (word[slen + 0] == CHAR && c == word[slen + 1]) {
			stype |= 0x80;
			slen += 2;
		}
	} else if (stype)	/* : is not ok */
		return -1;
	if (!stype && *word != CSUBST)
		return -1;
	*stypep = stype;
	*slenp = slen;

	c = sp[0];
	if (c == '*' || c == '@@') {
		switch (stype & 0x7f) {
		case '=':	/* can't assign to a vector */
		case '%':	/* can't trim a vector (yet) */
		case '#':
			return -1;
		}
		if (genv->loc->argc == 0) {
			xp->str = null;
			xp->var = global(sp);
			state = c == '@@' ? XNULLSUB : XSUB;
		} else {
			xp->u.strv = (const char **) genv->loc->argv + 1;
			xp->str = *xp->u.strv++;
			xp->split = c == '@@'; /* $@@ */
			state = XARG;
		}
		zero_ok = 1;	/* exempt "$@@" and "$*" from 'set -u' */
	} else {
		if ((p=strchr(sp,'[')) && (p[1]=='*'||p[1]=='@@') && p[2]==']') {
			XPtrV wv;

			switch (stype & 0x7f) {
			case '=':	/* can't assign to a vector */
			case '%':	/* can't trim a vector (yet) */
			case '#':
			case '?':
				return -1;
			}
			XPinit(wv, 32);
			vp = global(arrayname(sp));
			for (; vp; vp = vp->u.array) {
				if (!(vp->flag&ISSET))
					continue;
				XPput(wv, str_val(vp));
			}
			if (XPsize(wv) == 0) {
				xp->str = null;
				state = p[1] == '@@' ? XNULLSUB : XSUB;
				XPfree(wv);
			} else {
				XPput(wv, 0);
				xp->u.strv = (const char **) XPptrv(wv);
				xp->str = *xp->u.strv++;
				xp->split = p[1] == '@@'; /* ${foo[@@]} */
				state = XARG;
			}
		} else {
			/* Can't assign things like $! or $1 */
			if ((stype & 0x7f) == '=' &&
			    (ctype(*sp, C_VAR1) || digit(*sp)))
				return -1;
			xp->var = global(sp);
			xp->str = str_val(xp->var);
			state = XSUB;
		}
	}

	c = stype&0x7f;
	/* test the compiler's code generator */
	if (ctype(c, C_SUBOP2) ||
	    (((stype&0x80) ? *xp->str=='\0' : xp->str==null) ? /* undef? */
	    c == '=' || c == '-' || c == '?' : c == '+'))
		state = XBASE;	/* expand word instead of variable value */
	if (Flag(FNOUNSET) && xp->str == null && !zero_ok &&
	    (ctype(c, C_SUBOP2) || (state != XBASE && c != '+')))
		errorf("%s: parameter not set", sp);
	return state;
}

/*
 * Run the command in $(...) and read its output.
 */
static int
comsub(Expand *xp, char *cp)
{
	Source *s, *sold;
	struct op *t;
	struct shf *shf;

	s = pushs(SSTRING, ATEMP);
	s->start = s->str = cp;
	sold = source;
	t = compile(s);
	afree(s, ATEMP);
	source = sold;

	if (t == NULL)
		return XBASE;

	if (t != NULL && t->type == TCOM && /* $(<file) */
	    *t->args == NULL && *t->vars == NULL && t->ioact != NULL) {
		struct ioword *io = *t->ioact;
		char *name;

		if ((io->flag&IOTYPE) != IOREAD)
			errorf("funny $() command: %s",
			    snptreef(NULL, 32, "%R", io));
		shf = shf_open(name = evalstr(io->name, DOTILDE), O_RDONLY, 0,
			SHF_MAPHI|SHF_CLEXEC);
		if (shf == NULL)
			warningf(!Flag(FTALKING),
			    "%s: cannot open $(<) input", name);
		xp->split = 0;	/* no waitlast() */
	} else {
		int ofd1, pv[2];
		openpipe(pv);
		shf = shf_fdopen(pv[0], SHF_RD, NULL);
		ofd1 = savefd(1);
		if (pv[1] != 1) {
			ksh_dup2(pv[1], 1, false);
			close(pv[1]);
		}
		execute(t, XFORK|XXCOM|XPIPEO, NULL);
		restfd(1, ofd1);
		startlast();
		xp->split = 1;	/* waitlast() */
	}

	xp->u.shf = shf;
	return XCOM;
}

static char *
strsub(char *str, char *pat, int how)
{
	char	*actpat, *dst, *prepat, *rep, *src;
	size_t	 beg, dstlen, dstsiz, end, match, len, patlen, replen;

	len = strlen(str);
	if (len == 0)
		return str;
	src = str;

	dstlen = 0;
	dstsiz = len + 1;	/* NUL */
	dst = alloc(dstsiz, ATEMP);

	actpat = pat;
	patlen = strlen(actpat) + 1;		/* NUL */
	prepat = alloc(patlen + 2, ATEMP);	/* make room for wildcard */
	/*
	 * Copy actpat to prepat and add a wildcard after the open pattern
	 * prefix.
	 */
	memcpy(prepat, actpat, 2);
	prepat[2] = MAGIC;
	prepat[3] = '*';
	memcpy(&prepat[4], &actpat[2], patlen - 2);

	rep = &actpat[patlen];
	replen = strlen(rep);

	for (;;) {
		/*
		 * Find the wildcard prefix in prepat followed by actpat.
		 * This allows occurrences of actpat to be found anywhere in the
		 * string.
		 */
		match = 0;
		for (end = 1; end <= len; end++)
			if (gnmatch(src, end, prepat, 0))
				match = end;
			else if (match)
				break;
		if (!match)
			break;
		end = match;

		/*
		 * Find the prefix, if any, that was matched by the wildcard in
		 * prepat.
		 */
		match = 0;
		for (beg = 0; beg < end; beg++)
			if ((match = gnmatch(src + beg, end - beg, actpat, 0)))
				break;

		/*
		 * At this point, [src, beg) contains the prefix that is present
		 * before the actual pattern and [beg, end) what was matched by
		 * the actual pattern.
		 * The first range will be copied over to dst and the latter
		 * replaced with rep.
		 */
		if (match && beg > 0) {
			if (beg + dstlen >= dstsiz) {
				dst = areallocarray(dst, 1, dstsiz + beg + 1,
				    ATEMP);
				dstsiz += beg + 1;
			}
			memcpy(&dst[dstlen], src, beg);
			dstlen += beg;
		}

		if (replen + dstlen >= dstsiz) {
			dst = areallocarray(dst, 1, dstsiz + replen + 1, ATEMP);
			dstsiz += replen + 1;
		}
		memcpy(&dst[dstlen], rep, replen);
		dstlen += replen;

		src += end;
		len -= end;
		if (len == 0 || how == '/')
			break;
	}

	afree(prepat, ATEMP);

	if (str == src) {
		/* No substitutions performed. */
		afree(dst, ATEMP);

		return str;
	}

	/* Copy unmatched suffix from src. */
	if (len > 0) {
		if (len + dstlen >= dstsiz) {
			dst = areallocarray(dst, 1, dstsiz + len + 1, ATEMP);
			dstsiz += len + 1;
		}
		memcpy(&dst[dstlen], src, len);
		dstlen += len;
	}
	dst[dstlen] = '\0';

	return dst;
}

/*
 * perform #pattern and %pattern substitution in ${}
 */

static char *
trimsub(char *str, char *pat, int how)
{
	char *end = strchr(str, 0);
	char *p, c;

	switch (how&0xff) {	/* UCHAR_MAX maybe? */
	case '#':		/* shortest at beginning */
		for (p = str; p <= end; p++) {
			c = *p; *p = '\0';
			if (gmatch(str, pat, false)) {
				*p = c;
				return p;
			}
			*p = c;
		}
		break;
	case '#'|0x80:	/* longest match at beginning */
		for (p = end; p >= str; p--) {
			c = *p; *p = '\0';
			if (gmatch(str, pat, false)) {
				*p = c;
				return p;
			}
			*p = c;
		}
		break;
	case '%':		/* shortest match at end */
		for (p = end; p >= str; p--) {
			if (gmatch(p, pat, false))
				return str_nsave(str, p - str, ATEMP);
		}
		break;
	case '%'|0x80:	/* longest match at end */
		for (p = str; p <= end; p++) {
			if (gmatch(p, pat, false))
				return str_nsave(str, p - str, ATEMP);
		}
		break;
	}

	return str;		/* no match, return string */
}

/*
 * glob
 * Name derived from V6's /etc/glob, the program that expanded filenames.
 */

/* XXX cp not const 'cause slashes are temporarily replaced with nulls... */
static void
glob(char *cp, XPtrV *wp, int markdirs)
{
	int oldsize = XPsize(*wp);

	if (glob_str(cp, wp, markdirs) == 0)
		XPput(*wp, debunk(cp, cp, strlen(cp) + 1));
	else
		qsortp(XPptrv(*wp) + oldsize, (size_t)(XPsize(*wp) - oldsize),
			xstrcmp);
}

#define GF_NONE		0
#define GF_EXCHECK	BIT(0)		/* do existence check on file */
#define GF_GLOBBED	BIT(1)		/* some globbing has been done */
#define GF_MARKDIR	BIT(2)		/* add trailing / to directories */

/* Apply file globbing to cp and store the matching files in wp.  Returns
 * the number of matches found.
 */
int
glob_str(char *cp, XPtrV *wp, int markdirs)
{
	int oldsize = XPsize(*wp);
	XString xs;
	char *xp;

	Xinit(xs, xp, 256, ATEMP);
	globit(&xs, &xp, cp, wp, markdirs ? GF_MARKDIR : GF_NONE);
	Xfree(xs, xp);

	return XPsize(*wp) - oldsize;
}

static void
globit(XString *xs,	/* dest string */
    char **xpp,		/* ptr to dest end */
    char *sp,		/* source path */
    XPtrV *wp,		/* output list */
    int check)		/* GF_* flags */
{
	char *np;		/* next source component */
	char *xp = *xpp;
	char *se;
	char odirsep;

	/* This to allow long expansions to be interrupted */
	intrcheck();

	if (sp == NULL) {	/* end of source path */
		/* We only need to check if the file exists if a pattern
		 * is followed by a non-pattern (eg, foo*x/bar; no check
		 * is needed for foo* since the match must exist) or if
		 * any patterns were expanded and the markdirs option is set.
		 * Symlinks make things a bit tricky...
		 */
		if ((check & GF_EXCHECK) ||
		    ((check & GF_MARKDIR) && (check & GF_GLOBBED))) {
#define stat_check()	(stat_done ? stat_done : \
			    (stat_done = stat(Xstring(*xs, xp), &statb) < 0 \
				? -1 : 1))
			struct stat lstatb, statb;
			int stat_done = 0;	 /* -1: failed, 1 ok */

			if (lstat(Xstring(*xs, xp), &lstatb) < 0)
				return;
			/* special case for systems which strip trailing
			 * slashes from regular files (eg, /etc/passwd/).
			 * SunOS 4.1.3 does this...
			 */
			if ((check & GF_EXCHECK) && xp > Xstring(*xs, xp) &&
			    xp[-1] == '/' && !S_ISDIR(lstatb.st_mode) &&
			    (!S_ISLNK(lstatb.st_mode) ||
			    stat_check() < 0 || !S_ISDIR(statb.st_mode)))
				return;
			/* Possibly tack on a trailing / if there isn't already
			 * one and if the file is a directory or a symlink to a
			 * directory
			 */
			if (((check & GF_MARKDIR) && (check & GF_GLOBBED)) &&
			    xp > Xstring(*xs, xp) && xp[-1] != '/' &&
			    (S_ISDIR(lstatb.st_mode) ||
			    (S_ISLNK(lstatb.st_mode) && stat_check() > 0 &&
			    S_ISDIR(statb.st_mode)))) {
				*xp++ = '/';
				*xp = '\0';
			}
		}
		XPput(*wp, str_nsave(Xstring(*xs, xp), Xlength(*xs, xp), ATEMP));
		return;
	}

	if (xp > Xstring(*xs, xp))
		*xp++ = '/';
	while (*sp == '/') {
		Xcheck(*xs, xp);
		*xp++ = *sp++;
	}
	np = strchr(sp, '/');
	if (np != NULL) {
		se = np;
		odirsep = *np;	/* don't assume '/', can be multiple kinds */
		*np++ = '\0';
	} else {
		odirsep = '\0'; /* keep gcc quiet */
		se = sp + strlen(sp);
	}


	/* Check if sp needs globbing - done to avoid pattern checks for strings
	 * containing MAGIC characters, open ['s without the matching close ],
	 * etc. (otherwise opendir() will be called which may fail because the
	 * directory isn't readable - if no globbing is needed, only execute
	 * permission should be required (as per POSIX)).
	 */
	if (!has_globbing(sp, se)) {
		XcheckN(*xs, xp, se - sp + 1);
		debunk(xp, sp, Xnleft(*xs, xp));
		xp += strlen(xp);
		*xpp = xp;
		globit(xs, xpp, np, wp, check);
	} else {
		DIR *dirp;
		struct dirent *d;
		char *name;
		int len;
		int prefix_len;

		/* xp = *xpp;	   copy_non_glob() may have re-alloc'd xs */
		*xp = '\0';
		prefix_len = Xlength(*xs, xp);
		dirp = opendir(prefix_len ? Xstring(*xs, xp) : ".");
		if (dirp == NULL)
			goto Nodir;
		while ((d = readdir(dirp)) != NULL) {
			name = d->d_name;
			if (name[0] == '.' &&
			    (name[1] == 0 || (name[1] == '.' && name[2] == 0)))
				continue; /* always ignore . and .. */
			if ((*name == '.' && *sp != '.') ||
			    !gmatch(name, sp, true))
				continue;

			len = strlen(d->d_name) + 1;
			XcheckN(*xs, xp, len);
			memcpy(xp, name, len);
			*xpp = xp + len - 1;
			globit(xs, xpp, np, wp,
				(check & GF_MARKDIR) | GF_GLOBBED
				| (np ? GF_EXCHECK : GF_NONE));
			xp = Xstring(*xs, xp) + prefix_len;
		}
		closedir(dirp);
	  Nodir:;
	}

	if (np != NULL)
		*--np = odirsep;
}

#if 0
/* Check if p contains something that needs globbing; if it does, 0 is
 * returned; if not, p is copied into xs/xp after stripping any MAGICs
 */
static int	copy_non_glob(XString *xs, char **xpp, char *p);
static int
copy_non_glob(XString *xs, char **xpp, char *p)
{
	char *xp;
	int len = strlen(p);

	XcheckN(*xs, *xpp, len);
	xp = *xpp;
	for (; *p; p++) {
		if (ISMAGIC(*p)) {
			int c = *++p;

			if (c == '*' || c == '?')
				return 0;
			if (*p == '[') {
				char *q = p + 1;

				if (ISMAGIC(*q) && q[1] == '!')
					q += 2;
				if (ISMAGIC(*q) && q[1] == ']')
					q += 2;
				for (; *q; q++)
					if (ISMAGIC(*q) && *++q == ']')
						return 0;
				/* pass a literal [ through */
			}
			/* must be a MAGIC-MAGIC, or MAGIC-!, MAGIC--, etc. */
		}
		*xp++ = *p;
	}
	*xp = '\0';
	*xpp = xp;
	return 1;
}
#endif /* 0 */

/* remove MAGIC from string */
char *
debunk(char *dp, const char *sp, size_t dlen)
{
	char *d, *s;

	if ((s = strchr(sp, MAGIC))) {
		if (s - sp >= dlen)
			return dp;
		memcpy(dp, sp, s - sp);
		for (d = dp + (s - sp); *s && (d - dp < dlen); s++)
			if (!ISMAGIC(*s) || !(*++s & 0x80) ||
			    !strchr("*+?@@! ", *s & 0x7f))
				*d++ = *s;
			else {
				/* extended pattern operators: *+?@@! */
				if ((*s & 0x7f) != ' ')
					*d++ = *s & 0x7f;
				if (d - dp < dlen)
					*d++ = '(';
			}
		*d = '\0';
	} else if (dp != sp)
		strlcpy(dp, sp, dlen);
	return dp;
}

/* Check if p is an unquoted name, possibly followed by a / or :.  If so
 * puts the expanded version in *dcp,dp and returns a pointer in p just
 * past the name, otherwise returns 0.
 */
static char *
maybe_expand_tilde(char *p, XString *dsp, char **dpp, int isassign)
{
	XString ts;
	char *dp = *dpp;
	char *tp, *r;

	Xinit(ts, tp, 16, ATEMP);
	/* : only for DOASNTILDE form */
	while (p[0] == CHAR && p[1] != '/' && (!isassign || p[1] != ':'))
	{
		Xcheck(ts, tp);
		*tp++ = p[1];
		p += 2;
	}
	*tp = '\0';
	r = (p[0] == EOS || p[0] == CHAR || p[0] == CSUBST) ?
	    tilde(Xstring(ts, tp)) : NULL;
	Xfree(ts, tp);
	if (r) {
		while (*r) {
			Xcheck(*dsp, dp);
			if (ISMAGIC(*r))
				*dp++ = MAGIC;
			*dp++ = *r++;
		}
		*dpp = dp;
		r = p;
	}
	return r;
}

/*
 * tilde expansion
 *
 * based on a version by Arnold Robbins
 */

static char *
tilde(char *cp)
{
	char *dp;

	if (cp[0] == '\0')
		dp = str_val(global("HOME"));
	else if (cp[0] == '+' && cp[1] == '\0')
		dp = str_val(global("PWD"));
	else if (cp[0] == '-' && cp[1] == '\0')
		dp = str_val(global("OLDPWD"));
	else
		dp = homedir(cp);
	/* If HOME, PWD or OLDPWD are not set, don't expand ~ */
	if (dp == null)
		dp = NULL;
	return dp;
}

/*
 * map userid to user's home directory.
 * note that 4.3's getpw adds more than 6K to the shell,
 * and the YP version probably adds much more.
 * we might consider our own version of getpwnam() to keep the size down.
 */

static char *
homedir(char *name)
{
	struct tbl *ap;

	ap = ktenter(&homedirs, name, hash(name));
	if (!(ap->flag & ISSET)) {
		struct passwd *pw;

		pw = getpwnam(name);
		if (pw == NULL)
			return NULL;
		ap->val.s = str_save(pw->pw_dir, APERM);
		ap->flag |= DEFINED|ISSET|ALLOC;
	}
	return ap->val.s;
}

#ifdef BRACE_EXPAND
static void
alt_expand(XPtrV *wp, char *start, char *exp_start, char *end, int fdo)
{
	int count = 0;
	char *brace_start, *brace_end, *comma = NULL;
	char *field_start;
	char *p;

	/* search for open brace */
	for (p = exp_start; (p = strchr(p, MAGIC)) && p[1] != OBRACE; p += 2)
		;
	brace_start = p;

	/* find matching close brace, if any */
	if (p) {
		comma = NULL;
		count = 1;
		for (p += 2; *p && count; p++) {
			if (ISMAGIC(*p)) {
				if (*++p == OBRACE)
					count++;
				else if (*p == CBRACE)
					--count;
				else if (*p == ',' && count == 1)
					comma = p;
			}
		}
	}
	/* no valid expansions... */
	if (!p || count != 0) {
		/* Note that given a{{b,c} we do not expand anything (this is
		 * what at&t ksh does.  This may be changed to do the {b,c}
		 * expansion. }
		 */
		if (fdo & DOGLOB)
			glob(start, wp, fdo & DOMARKDIRS);
		else
			XPput(*wp, debunk(start, start, end - start));
		return;
	}
	brace_end = p;
	if (!comma) {
		alt_expand(wp, start, brace_end, end, fdo);
		return;
	}

	/* expand expression */
	field_start = brace_start + 2;
	count = 1;
	for (p = brace_start + 2; p != brace_end; p++) {
		if (ISMAGIC(*p)) {
			if (*++p == OBRACE)
				count++;
			else if ((*p == CBRACE && --count == 0) ||
			    (*p == ',' && count == 1)) {
				char *new;
				int l1, l2, l3;

				l1 = brace_start - start;
				l2 = (p - 1) - field_start;
				l3 = end - brace_end;
				new = alloc(l1 + l2 + l3 + 1, ATEMP);
				memcpy(new, start, l1);
				memcpy(new + l1, field_start, l2);
				memcpy(new + l1 + l2, brace_end, l3);
				new[l1 + l2 + l3] = '\0';
				alt_expand(wp, new, new + l1,
				    new + l1 + l2 + l3, fdo);
				field_start = p + 1;
			}
		}
	}
	return;
}
#endif /* BRACE_EXPAND */
@


1.51
log
@Quiet an "implicit conversion from 'int' to 'char' changes value"
warning from clang.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.50 2016/03/05 12:30:17 czarkoff Exp $	*/
d53 1
d147 1
d214 15
d337 1
d399 2
d406 7
a412 2
					x.str = trimsub(str_val(st->var),
						dp, st->stype);
d781 3
d923 108
@


1.50
log
@POSIX-compliant behavior of "set -u" regarding "$*" and "$@@" specials

All work done by Martijn Dekker

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.49 2015/12/30 09:07:00 tedu Exp $	*/
d329 1
a329 1
						*dp++ = '@@' + 0x80;
@


1.49
log
@rename global "e" to genv to avoid accidental shadowing and aliasing.
ok millert nicm tb
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.48 2015/12/14 13:59:42 tb Exp $	*/
d710 1
a718 2
		int zero_ok = 0;

d791 1
d838 1
a838 1
	if (Flag(FNOUNSET) && xp->str == null &&
@


1.48
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.47 2015/11/12 04:04:31 mmcc Exp $	*/
d736 1
a736 1
			c = e->loc->argc;
d782 1
a782 1
		if (e->loc->argc == 0) {
d787 1
a787 1
			xp->u.strv = (const char **) e->loc->argv + 1;
@


1.47
log
@Use isdigit() instead of ksh's homebrewed alternative.

ok nicm@@. Also discussed with millert@@ and guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.46 2015/10/19 17:15:53 mmcc Exp $	*/
d11 1
d13 1
d15 1
@


1.46
log
@Remove the define NOT, replace it with '!'. No binary change.

"The ^ is used in regular expressions and many versions of fnmatch(3)
accept both ! and ^. However, we are never going to accept ^ instead of
! so I think this makes sense" -millert@@

"go for it" -nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.45 2015/10/19 14:42:16 mmcc Exp $	*/
d9 1
@


1.45
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.44 2015/10/19 02:15:45 mmcc Exp $	*/
d606 1
a606 1
				case NOT:
d1129 1
a1129 1
				if (ISMAGIC(*q) && q[1] == NOT)
@


1.44
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.43 2015/09/18 07:28:24 nicm Exp $	*/
d11 1
@


1.43
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.42 2015/09/17 14:21:33 nicm Exp $	*/
d7 5
a12 3
#include <pwd.h>
#include <dirent.h>
#include <sys/stat.h>
@


1.42
log
@Remove unnecessary casts, from Michael McConville. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.41 2015/09/15 18:15:05 tedu Exp $	*/
d190 1
a190 1
	st_head.next = (SubType *) 0;
d297 1
a297 1
						newst->next = (SubType *) 0;
d707 1
a707 1
	xp->var = (struct tbl *) 0;
d874 1
a874 1
		shf = shf_fdopen(pv[0], SHF_RD, (struct shf *) 0);
@


1.41
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.40 2013/09/14 20:09:30 millert Exp $	*/
d295 1
a295 1
						newst = (SubType *) alloc(
d409 1
a409 1
					    debunk((char *) alloc(len, ATEMP),
d1320 1
a1320 1
				new = (char *) alloc(l1 + l2 + l3 + 1, ATEMP);
@


1.40
log
@Back out revision 1.38.  Commands executed via `foo` or $( bar )
actually should inherit "set -e" status according to POSIX.
OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.37 2011/10/11 14:32:43 otto Exp $	*/
d864 1
a864 1
			    snptreef((char *) 0, 32, "%R", io));
d1193 1
a1193 1
	    tilde(Xstring(ts, tp)) : (char *) 0;
d1229 1
a1229 1
		dp = (char *) 0;
d1274 1
a1274 1
		comma = (char *) 0;
@


1.39
log
@Make $(< /nonexistent) have the same behaviour as $(cat /nonexistent)
wrt. errors (do not unwind and do not treat this as fatal if set -e is
used).  This matches what bash does.  Tweak regress tests while here.
ok millert@@, jasper@@ agrees
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.38 2013/06/19 12:19:02 millert Exp $	*/
d872 1
a872 1
		int errexit, ofd1, pv[2];
a879 7
		/*
		 * Clear FERREXIT temporarily while we execute the command.
		 * We cannot simply pass XERROK since the tree might include
		 * its own "set -e".
		 */
		errexit = Flag(FERREXIT);
		Flag(FERREXIT) = 0;
a880 1
		Flag(FERREXIT) = errexit;
@


1.38
log
@Commands executed via `foo` or $( bar ) should not inherit "set -e"
status.  We can't use XERROK for this (since the command might set
-e itself) so just save & restore the value of FERREXIT for the
comsub() call to execute().  OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.37 2011/10/11 14:32:43 otto Exp $	*/
d508 3
a510 1
			if (newlines) {		/* Spit out saved nl's */
d525 2
a526 1
				shf_close(x.u.shf);
d529 2
d868 2
a869 1
			errorf("%s: cannot open $() input", name);
@


1.37
log
@gc unused var; from Michael W. Bombardieri
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.36 2011/03/15 08:39:54 okan Exp $	*/
d866 1
a866 1
		int ofd1, pv[2];
d874 7
d882 1
@


1.36
log
@fix uninitialized variable warnings (lifted from mksh).

noticed by and ok kevlo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.35 2010/03/24 08:27:26 fgsch Exp $	*/
a714 1
			int max = 0;
d720 1
a720 2
				if (vp->flag & ISSET) {
					max = vp->index + 1;
a721 1
				}
@


1.35
log
@fix the cases where ${name#pat} and ${name%pat} will generate an empty word
when they shouldn't. originally from mksh but modified to handle the case
when the expr is quoted as noticed by halex@@.
input from guenther@@ and halex@@, millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.34 2009/01/29 23:27:26 jaredy Exp $	*/
d155 4
a158 1
	Expand x;		/* expansion variables */
d271 1
a271 1
				int slen;
@


1.34
log
@pass "xerrok" status across the execution call stack to more closely
match what both POSIX and ksh.1 already describe in regards to set
-e/errexit's behavior in determining when to exit from nonzero return
values.

specifically, the truth values tested as operands to `&&' and `||', as
well as the resulting compound expression itself, along with the truth
value resulting from a negated command (i.e. a pipeline prefixed `!'),
should not make the shell exit when -e is in effect.

issue reported by matthieu.
testing matthieu, naddy.
ok miod (earlier version), otto.
man page ok jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.33 2007/08/02 11:05:54 fgsch Exp $	*/
d378 4
a381 1
					type = XSUB;
@


1.33
log
@backout last change; iff is right.
prompted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.31 2007/08/02 10:50:25 fgsch Exp $	*/
d871 1
a871 1
		execute(t, XFORK|XXCOM|XPIPEO);
@


1.32
log
@while i'm here: iff -> if
@
text
@d684 1
a684 1
    int *slenp)		/* " " len (=, :=, etc.) valid if *stypep != 0 */
@


1.31
log
@fix memory leaks and one potential null deref found by coverity. from netbsd.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.30 2006/04/10 14:38:59 jaredy Exp $	*/
d684 1
a684 1
    int *slenp)		/* " " len (=, :=, etc.) valid iff *stypep != 0 */
@


1.30
log
@fix lint comments, no functional changes; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.29 2006/03/17 16:30:13 millert Exp $	*/
d843 1
@


1.29
log
@Simplify savefd() by removing the "noclose" flag and make noclose
behavior the default.  Almost all uses of savefd() are followed
by an implicit or explicit close.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.28 2005/12/11 20:31:21 otto Exp $	*/
d347 1
a347 1
						/* fall through */
@


1.28
log
@fix a few name clashes with libc; found by lint. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.27 2005/03/30 17:16:37 deraadt Exp $	*/
d865 1
a865 1
		ofd1 = savefd(1, 0);	/* fd 1 may be closed... */
@


1.27
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.26 2005/02/25 11:21:16 deraadt Exp $	*/
d1235 1
a1235 1
	ap = tenter(&homedirs, name, hash(name));
@


1.26
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.25 2005/02/02 07:53:01 otto Exp $	*/
d194 1
a194 1
		  case XBASE:	/* original prefixed string */
d197 1
a197 1
			  case EOS:
d200 1
a200 1
			  case CHAR:
d203 1
a203 1
			  case QCHAR:
d207 1
a207 1
			  case OQUOTE:
d212 1
a212 1
			  case CQUOTE:
d215 1
a215 1
			  case COMSUB:
d233 1
a233 1
			  case EXPRSUB:
d251 1
a251 1
						KSH_UNWIND_ERROR, true);
d259 1
a259 1
			  case OSUBST: /* ${{#}var{:}[=+-?#%]word} */
d265 1
a265 1
			  {
d293 1
a293 1
							sizeof(SubType), ATEMP);
d308 2
a309 2
					  case '#':
					  case '%':
d311 2
a312 2
						f = DOPAT | (f&DONTRUNCOMMAND)
						    | DOTEMP_;
d321 1
a321 1
					  case '=':
d344 1
a344 1
					  case '?':
d348 1
a348 1
					  default:
d357 2
a358 2
			  }
			  case CSUBST: /* only get here if expanding word */
d367 2
a368 2
				  case '#':
				  case '%':
d383 1
a383 1
				  case '=':
d404 1
a404 2
						dp, len),
					    KSH_UNWIND_ERROR);
d411 1
a411 1
				  case '?':
d417 2
a418 2
					      "parameter null or not set"
					    : (debunk(s, s, strlen(s) + 1), s));
d425 1
a425 1
			  case OPAT: /* open pattern: *(foo|bar) */
d431 1
a431 1
			  case SPAT: /* pattern separator (|) */
d436 1
a436 1
			  case CPAT: /* close pattern */
d443 1
a443 1
		  case XNULLSUB:
d460 2
a461 2
		  case XSUB:
		  case XSUBMID:
d470 1
a470 1
		  case XARGSEP:
d473 1
a473 1
		  case XARG:
d501 1
a501 1
		  case XCOM:
d529 2
a530 3
		if (c == 0 || (!quote && (f & DOBLANK) && doblank && !make_magic
			       && ctype(c, C_IFS)))
		{
d542 2
a543 3
			if (word == IFS_WORD
			    || (!ctype(c, C_IFSWS) && c && word == IFS_NWS))
			{
d552 2
a553 2
						   p + Xlength(ds, (dp - 1)),
						   fdo | (f & DOMARKDIRS));
d591 4
a594 4
				  case '[':
				  case NOT:
				  case '-':
				  case ']':
d606 2
a607 2
				  case '*':
				  case '?':
d614 5
a618 6
				  case OBRACE:
				  case ',':
				  case CBRACE:
					if ((f & DOBRACE_) && (c == OBRACE
						|| (fdo & DOBRACE_)))
					{
d624 1
a624 1
				  case '=':
d631 1
a631 1
				  case ':': /* : */
d636 1
a636 1
				  case '~':
d642 3
a644 4
					if (type == XBASE
					    && (f & (DOTILDE|DOASNTILDE))
					    && (tilde_ok & 2))
					{
d649 2
a650 2
							&ds, &dp_x,
							f & DOASNTILDE);
d762 3
a764 3
		  case '=':	/* can't assign to a vector */
		  case '%':	/* can't trim a vector (yet) */
		  case '#':
d782 4
a785 4
			  case '=':	/* can't assign to a vector */
			  case '%':	/* can't trim a vector (yet) */
			  case '#':
			  case '?':
d808 2
a809 2
			if ((stype & 0x7f) == '='
			    && (ctype(*sp, C_VAR1) || digit(*sp)))
d821 1
a821 1
	     c == '=' || c == '-' || c == '?' : c == '+'))
d823 2
a824 2
	if (Flag(FNOUNSET) && xp->str == null
	    && (ctype(c, C_SUBOP2) || (state != XBASE && c != '+')))
d855 1
a855 1
				snptreef((char *) 0, 32, "%R", io));
d891 1
a891 1
	  case '#':		/* shortest at beginning */
d901 1
a901 1
	  case '#'|0x80:	/* longest match at beginning */
d911 1
a911 1
	  case '%':		/* shortest match at end */
d917 1
a917 1
	  case '%'|0x80:	/* longest match at end */
d990 2
a991 3
		if ((check & GF_EXCHECK)
		    || ((check & GF_MARKDIR) && (check & GF_GLOBBED)))
		{
d1004 4
a1007 6
			if ((check & GF_EXCHECK) && xp > Xstring(*xs, xp)
			    && xp[-1] == '/' && !S_ISDIR(lstatb.st_mode)
			    && (!S_ISLNK(lstatb.st_mode)
				|| stat_check() < 0
				|| !S_ISDIR(statb.st_mode))
				)
d1013 5
a1017 8
			if (((check & GF_MARKDIR) && (check & GF_GLOBBED))
			    && xp > Xstring(*xs, xp) && xp[-1] != '/'
			    && (S_ISDIR(lstatb.st_mode)
				|| (S_ISLNK(lstatb.st_mode)
				    && stat_check() > 0
				    && S_ISDIR(statb.st_mode))
				    ))
			{
d1073 2
a1074 2
			if ((*name == '.' && *sp != '.')
			    || !gmatch(name, sp, true))
d1146 2
a1147 2
			if (!ISMAGIC(*s) || !(*++s & 0x80)
			    || !strchr("*+?@@! ", *s & 0x7f))
d1182 2
a1183 1
	r = (p[0] == EOS || p[0] == CHAR || p[0] == CSUBST) ? tilde(Xstring(ts, tp)) : (char *) 0;
d1302 2
a1303 3
			else if ((*p == CBRACE && --count == 0)
				 || (*p == ',' && count == 1))
			{
d1316 1
a1316 1
					   new + l1 + l2 + l3, fdo);
@


1.25
log
@Introduce POSIX hex and octal (0x... and 0...) constants in arithmetic
expressions.  Work by Matthias Kilian, based on an old diff by myself.
Note: MAKEDEV should be updated. Tested by many, thanks.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.24 2004/12/22 18:52:37 millert Exp $	*/
d715 1
@


1.24
log
@Fix previous commit here, I add the case statement to the wrong switch.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.22 2004/12/22 17:14:34 millert Exp $	*/
d251 1
a251 1
						KSH_UNWIND_ERROR);
@


1.23
log
@Make 'echo ${a[@@]:?foo}' produce an error, not a core dump.
Bug noticed by otto@@.
@
text
@a768 1
		  case '?':
d789 1
@


1.22
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.21 2004/12/20 11:34:26 otto Exp $	*/
d769 1
@


1.21
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.20 2004/12/18 21:25:44 millert Exp $	*/
d870 1
a870 1
			ksh_dup2(pv[1], 1, FALSE);
d897 1
a897 1
			if (gmatch(str, pat, FALSE)) {
d907 1
a907 1
			if (gmatch(str, pat, FALSE)) {
d916 1
a916 1
			if (gmatch(p, pat, FALSE))
d922 1
a922 1
			if (gmatch(p, pat, FALSE))
d1083 1
a1083 1
			    || !gmatch(name, sp, TRUE))
@


1.20
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.19 2004/12/18 20:55:52 millert Exp $	*/
d44 8
a51 10
static	int	varsub(Expand *xp, char *sp, char *word, int *stypep, int *slenp);
static	int	comsub(Expand *xp, char *cp);
static	char   *trimsub(char *str, char *pat, int how);
static	void	glob(char *cp, XPtrV *wp, int markdirs);
static	void	globit(XString *xs, char **xpp, char *sp, XPtrV *wp,
			     int check);
static char	*maybe_expand_tilde(char *p, XString *dsp, char **dpp,
					  int isassign);
static	char   *tilde(char *acp);
static	char   *homedir(char *name);
d53 1
a53 2
static void	alt_expand(XPtrV *wp, char *start, char *exp_start,
				 char *end, int fdo);
d58 1
a58 3
substitute(cp, f)
	const char *cp;
	int f;
d77 1
a77 3
eval(ap, f)
	char **ap;
	int f;
d95 1
a95 3
evalstr(cp, f)
	char *cp;
	int f;
d111 1
a111 3
evalonestr(cp, f)
	char *cp;
	int f;
d144 3
a146 4
expand(cp, wp, f)
	char *cp;		/* input word */
	XPtrV *wp;		/* output words */
	int f;			/* DO* flags */
d687 3
a689 6
varsub(xp, sp, word, stypep, slenp)
	Expand *xp;
	char *sp;
	char *word;
	int *stypep;	/* becomes qualifier type */
	int *slenp;	/* " " len (=, :=, etc.) valid iff *stypep != 0 */
d836 1
a836 3
comsub(xp, cp)
	Expand *xp;
	char *cp;
d888 1
a888 4
trimsub(str, pat, how)
	char *str;
	char *pat;
	int how;
d938 1
a938 4
glob(cp, wp, markdirs)
	char *cp;
	XPtrV *wp;
	int markdirs;
d958 1
a958 4
glob_str(cp, wp, markdirs)
	char *cp;
	XPtrV *wp;
	int markdirs;
d972 5
a976 6
globit(xs, xpp, sp, wp, check)
	XString *xs;		/* dest string */
	char **xpp;		/* ptr to dest end */
	char *sp;		/* source path */
	XPtrV *wp;		/* output list */
	int check;		/* GF_* flags */
d1109 1
a1109 4
copy_non_glob(xs, xpp, p)
	XString *xs;
	char **xpp;
	char *p;
d1146 1
a1146 4
debunk(dp, sp, dlen)
	char *dp;
	const char *sp;
	size_t dlen;
d1176 1
a1176 5
maybe_expand_tilde(p, dsp, dpp, isassign)
	char *p;
	XString *dsp;
	char **dpp;
	int isassign;
d1213 1
a1213 2
tilde(cp)
	char *cp;
d1239 1
a1239 2
homedir(name)
	char *name;
d1258 1
a1258 5
alt_expand(wp, start, exp_start, end, fdo)
	XPtrV *wp;
	char *start, *exp_start;
	char *end;
	int fdo;
@


1.19
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.18 2004/12/13 16:37:06 millert Exp $	*/
d83 1
a83 1
	register char **ap;
d121 1
a121 1
	register char *cp;
d157 1
a157 1
	register XPtrV *wp;	/* output words */
d160 3
a162 3
	register int c = 0;
	register int type;	/* expansion type */
	register int quote = 0;	/* quoted */
d164 1
a164 1
	register char *dp, *sp;	/* dest., source */
d852 1
a852 1
	register Expand *xp;
d856 1
a856 1
	register struct op *t;
d870 1
a870 1
		register struct ioword *io = *t->ioact;
d906 1
a906 1
	register char *str;
d910 2
a911 2
	register char *end = strchr(str, 0);
	register char *p, c;
d960 1
a960 1
	register XPtrV *wp;
d1002 1
a1002 1
	register XPtrV *wp;	/* output list */
d1005 1
a1005 1
	register char *np;	/* next source component */
d1280 1
a1280 1
	register struct tbl *ap;
@


1.18
log
@Restore sp before calling snptreef() so the error message contains
the actual expression that caused the error.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.17 2004/12/09 11:32:07 otto Exp $	*/
d9 2
a10 2
#include "ksh_dir.h"
#include "ksh_stat.h"
d44 10
a53 10
static	int	varsub ARGS((Expand *xp, char *sp, char *word, int *stypep, int *slenp));
static	int	comsub ARGS((Expand *xp, char *cp));
static	char   *trimsub ARGS((char *str, char *pat, int how));
static	void	glob ARGS((char *cp, XPtrV *wp, int markdirs));
static	void	globit ARGS((XString *xs, char **xpp, char *sp, XPtrV *wp,
			     int check));
static char	*maybe_expand_tilde ARGS((char *p, XString *dsp, char **dpp,
					  int isassign));
static	char   *tilde ARGS((char *acp));
static	char   *homedir ARGS((char *name));
d55 2
a56 2
static void	alt_expand ARGS((XPtrV *wp, char *start, char *exp_start,
				 char *end, int fdo));
a91 3
#ifdef	SHARPBANG
	XPput(w, NULL);		/* and space for one arg */
#endif
a94 3
#ifdef	SHARPBANG
	return (char **) XPclose(w) + 2;
#else
a95 1
#endif
d160 1
a160 1
	register int UNINITIALIZED(c);
d169 1
a169 1
	int UNINITIALIZED(newlines); /* For trailing newlines in COMSUB */
d647 1
a647 1
				  case PATHSEP: /* : */
d1036 1
a1036 2
			    && ISDIRSEP(xp[-1]) && !S_ISDIR(lstatb.st_mode)
#ifdef S_ISLNK
a1039 1
#endif /* S_ISLNK */
d1047 1
a1047 1
			    && xp > Xstring(*xs, xp) && !ISDIRSEP(xp[-1])
a1048 1
#ifdef S_ISLNK
a1051 1
#endif /* S_ISLNK */
d1054 1
a1054 1
				*xp++ = DIRSEP;
d1058 1
a1058 11
#ifdef OS2 /* Done this way to avoid bug in gcc 2.7.2... */
    /* Ugly kludge required for command
     * completion - see how search_access()
     * is implemented for OS/2...
     */
# define KLUDGE_VAL	4
#else /* OS2 */
# define KLUDGE_VAL	0
#endif /* OS2 */
		XPput(*wp, str_nsave(Xstring(*xs, xp), Xlength(*xs, xp)
			+ KLUDGE_VAL, ATEMP));
d1063 2
a1064 2
		*xp++ = DIRSEP;
	while (ISDIRSEP(*sp)) {
d1068 1
a1068 1
	np = ksh_strchr_dirsep(sp);
d1071 1
a1071 1
		odirsep = *np;	/* don't assume DIRSEP, can be multiple kinds */
d1101 1
a1101 1
		dirp = ksh_opendir(prefix_len ? Xstring(*xs, xp) : ".");
d1113 1
a1113 1
			len = NLENGTH(d) + 1;
d1134 1
a1134 1
static int	copy_non_glob ARGS((XString *xs, char **xpp, char *p));
d1221 1
a1221 2
	while (p[0] == CHAR && !ISDIRSEP(p[1])
	       && (!isassign || p[1] != PATHSEP))
a1283 4
#ifdef OS2
		/* No usernames in OS2 - punt */
		return NULL;
#else /* OS2 */
a1290 1
#endif /* OS2 */
d1303 2
a1304 2
	int UNINITIALIZED(count);
	char *brace_start, *brace_end, *UNINITIALIZED(comma);
@


1.17
log
@partially backout prevous commit, it breaks eval of ${a[@@]}
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.16 2004/12/08 21:23:18 millert Exp $	*/
d295 1
d300 1
a300 2
					str = snptreef((char *) 0, 64, "%S",
							varname - 1);
@


1.16
log
@Fix core dumps for ${@@:?word} and ${foo[@@]?bar}.  With help from
and OK otto@@.  Closes PR 4023.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.15 2004/11/25 04:36:47 jaredy Exp $	*/
a821 1
				xp->var = global(sp);
@


1.15
log
@Change the behavior of IFS word-splitting:  split words
when the current character is IFS space and the last
character was a word character or it was non-white IFS
space and the current character is non-white IFS space.
This deviates from the previous behavior because the
latter splits words when the last character is any IFS
space and the current is non-white IFS, resulting in
more fields most of the time.

This new behavior follows what the man page describes;
i.e., that a field is delimited by one or more IFS
whitespace characters followed by zero or one non-white
IFS characters.

Requires addition of a new substitution expansion state
to handle the special case of empty fields at the
beginning.

testing by naddy
ok jmc, millert, otto, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.14 2003/11/10 21:26:39 millert Exp $	*/
d795 1
d822 1
@


1.14
log
@If "from fd" == "to fd" don't call dup2() or close "from fd".
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.13 2003/04/16 23:11:52 tdeval Exp $	*/
d37 1
d282 1
a282 1
			   * This is were all syntax checking gets done...
d481 1
d564 1
a564 1
			    || (!ctype(c, C_IFSWS) && (c || word == IFS_NWS)))
d595 13
@


1.13
log
@string cleaning.  ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.12 2003/03/10 03:48:16 david Exp $	*/
d877 4
a880 2
		ksh_dup2(pv[1], 1, FALSE);
		close(pv[1]);
@


1.12
log
@spelling fixes
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.11 2003/02/28 09:45:09 jmc Exp $	*/
d178 1
d419 5
a423 4
					setstr(st->var, debunk(
						(char *) alloc(strlen(dp) + 1,
							ATEMP), dp),
						KSH_UNWIND_ERROR);
d437 1
a437 1
					    : (debunk(s, s), s));
d581 1
a581 1
					XPput(*wp, debunk(p, p));
d955 1
a955 1
		XPput(*wp, debunk(cp, cp));
d1090 1
a1090 1
		debunk(xp, sp);
d1179 1
a1179 1
debunk(dp, sp)
d1182 1
d1187 2
d1190 1
a1190 1
		for (d = dp + (s - sp); *s; s++)
d1198 2
a1199 1
				*d++ = '(';
d1203 1
a1203 1
		strcpy(dp, sp);
d1346 1
a1346 1
			XPput(*wp, debunk(start, start));
@


1.11
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.10 2002/06/09 05:47:27 todd Exp $	*/
d960 1
a960 1
#define GF_EXCHECK	BIT(0)		/* do existance check on file */
@


1.10
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.9 1999/06/15 01:18:33 millert Exp $	*/
d172 1
a172 1
	int doblank;		/* field spliting of parameter/command subst */
d448 1
a448 1
			  case SPAT: /* pattern seperator (|) */
d901 1
a901 1
	  case '#':		/* shortest at begining */
d911 1
a911 1
	  case '#'|0x80:	/* longest match at begining */
@


1.9
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.8 1999/01/10 17:55:02 millert Exp $	*/
d433 1
a433 1
					    dp == s ? 
@


1.8
log
@sync with pdksh-unstable-5.2.13.6
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.7 1999/01/08 20:24:58 millert Exp $	*/
d268 1
a268 1
						FALSE);
a400 6
					if (st->var->flag & RDONLY)
						/* XXX POSIX says this is only
						 * fatal for special builtins
						 */
						errorf("%s: is read only",
							st->var->name);
d411 7
d420 2
a421 2
							ATEMP), dp));
					/* SETSTR: fail operation */
@


1.7
log
@bug fixes from pdksh-unstable-5.2.13.5; some of which we already had.
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.6 1998/10/29 04:09:20 millert Exp $	*/
d420 1
@


1.6
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.5 1998/06/25 19:01:53 millert Exp $	*/
d722 1
a722 1
				if (vp->flag * ISSET) {
@


1.5
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.4 1997/06/19 13:58:40 kstailey Exp $	*/
d716 2
a717 1
			c = 0;
d722 5
a726 2
				if (vp->flag&ISSET)
					c = vp->index+1;
@


1.4
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.2 1996/08/19 20:08:49 downsj Exp $	*/
d43 1
a43 1
static	int	varsub ARGS((Expand *xp, char *sp, char *word, int *stypep));
d278 2
a279 2
			   *   OSUBST plain-variable-part \0
			   *     compiled-word-part CSUBST
d283 1
a283 1
				char *varname = sp;
d285 1
d288 1
a288 1
				type = varsub(&x, varname, sp, &stype);
d294 1
d322 2
a323 6
					if (stype) {
						sp += 2;
						/* :[-+=?] or double [#%] */
						if (stype & 0x80)
							sp += 2;
					}
d331 6
a351 1
#if !defined(__hppa) || __GNUC__ != 2	/* gcc 2.3.3 on hp-pa dies on this - ifdef goes away as soon as I get a new version of gcc.. */
a354 3
#else
						f |= DOTEMP_|DOASNTILDE|DOTILDE;
#endif
d376 1
d386 2
d687 1
a687 1
varsub(xp, sp, word, stypep)
d691 2
a692 1
	int *stypep;
d697 1
d739 1
a739 1
	c = *word == CHAR ? word[1] : 0;
d741 1
d743 1
a743 1
		c = word[2] == CHAR ? word[3] : 0;
d745 2
a746 1
	if (ctype(c, C_SUBOP1))
d748 2
a749 3
	else if (stype)	/* :, :# or :% is not ok */
		return -1;
	else if (ctype(c, C_SUBOP2)) {
d751 1
a751 1
		if (word[2] == CHAR && c == word[3])
d753 4
a756 1
	}
d760 1
d766 1
a766 1
		  case '%':	/* can't trim a vector */
d785 1
a785 1
			  case '%':	/* can't trim a vector */
d1181 1
a1181 1
			    || !strchr("*+?@@!", *s & 0x7f))
d1185 2
a1186 1
				*d++ = *s & 0x7f;
@


1.3
log
@(foo *)0 -> NULL
@
text
@d204 1
a204 1
	st_head.next = NULL;
d295 1
a295 1
					str = snptreef(NULL, 64, "%S",
d309 1
a309 1
						newst->next = NULL;
d699 1
a699 1
	xp->var = NULL;
d848 1
a848 1
				snptreef(NULL, 32, "%R", io));
d857 1
a857 1
		shf = shf_fdopen(pv[0], SHF_RD, NULL);
d1209 1
a1209 1
	r = (p[0] == EOS || p[0] == CHAR || p[0] == CSUBST) ? tilde(Xstring(ts, tp)) : NULL;
d1246 1
a1246 1
		dp = NULL;
d1301 1
a1301 1
		comma = NULL;
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.1.1.1 1996/08/14 06:19:11 downsj Exp $	*/
d204 1
a204 1
	st_head.next = (SubType *) 0;
d295 1
a295 1
					str = snptreef((char *) 0, 64, "%S",
d309 1
a309 1
						newst->next = (SubType *) 0;
d699 1
a699 1
	xp->var = (struct tbl *) 0;
d848 1
a848 1
				snptreef((char *) 0, 32, "%R", io));
d857 1
a857 1
		shf = shf_fdopen(pv[0], SHF_RD, (struct shf *) 0);
d1209 1
a1209 1
	r = (p[0] == EOS || p[0] == CHAR || p[0] == CSUBST) ? tilde(Xstring(ts, tp)) : (char *) 0;
d1246 1
a1246 1
		dp = (char *) 0;
d1301 1
a1301 1
		comma = (char *) 0;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d726 1
a726 1
			errorf("%s: unset variable", sp);
d816 1
a816 1
		errorf("%s: unset variable", sp);
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
