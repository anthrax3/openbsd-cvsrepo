head	1.51;
access;
symbols
	OPENBSD_6_2:1.51.0.4
	OPENBSD_6_2_BASE:1.51
	OPENBSD_6_1:1.50.0.6
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.50.0.2
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.34.0.10
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.34.0.6
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.33.0.20
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.18
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.16
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.14
	OPENBSD_5_0:1.33.0.12
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.10
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.8
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.4
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.6
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.30.0.4
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.29.0.4
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.16.0.4
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.6
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.14.0.4
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.12.0.6
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	pdksh-527:1.1.1.1
	pdksh:1.1.1;
locks; strict;
comment	@ * @;


1.51
date	2017.09.03.11.52.01;	author jca;	state Exp;
branches;
next	1.50;
commitid	hY9pKLTbOjQJ8uf0;

1.50
date	2016.03.21.13.35.00;	author tb;	state Exp;
branches;
next	1.49;
commitid	FT9Onh1aajCRmf70;

1.49
date	2016.01.15.17.55.45;	author mmcc;	state Exp;
branches;
next	1.48;
commitid	9bRLCj2Et5VSWDsr;

1.48
date	2015.12.30.09.07.00;	author tedu;	state Exp;
branches;
next	1.47;
commitid	WTwPzlskFufQpRQz;

1.47
date	2015.12.14.13.59.42;	author tb;	state Exp;
branches;
next	1.46;
commitid	btTCreDA00YdaFhU;

1.46
date	2015.10.21.15.20.37;	author mmcc;	state Exp;
branches;
next	1.45;
commitid	xYVdAoH9LzDsXxBv;

1.45
date	2015.10.19.14.42.16;	author mmcc;	state Exp;
branches;
next	1.44;
commitid	C4W85jmosThChWA2;

1.44
date	2015.10.19.02.15.45;	author mmcc;	state Exp;
branches;
next	1.43;
commitid	16HUr75moyUNtKR8;

1.43
date	2015.10.09.19.36.27;	author tedu;	state Exp;
branches;
next	1.42;
commitid	BqXaWldwtvsixcay;

1.42
date	2015.09.22.21.50.40;	author millert;	state Exp;
branches;
next	1.41;
commitid	ZWmS69dzJnkF6rox;

1.41
date	2015.09.18.07.28.24;	author nicm;	state Exp;
branches;
next	1.40;
commitid	7fgq4YTZG4xZ0uN0;

1.40
date	2015.09.15.18.15.05;	author tedu;	state Exp;
branches;
next	1.39;
commitid	lBs9un9sXhbdfVrQ;

1.39
date	2015.09.15.18.07.22;	author tedu;	state Exp;
branches;
next	1.38;
commitid	a9KLxOATj99CUewS;

1.38
date	2015.09.14.16.08.50;	author nicm;	state Exp;
branches;
next	1.37;
commitid	ahedYHs8fav8xOPq;

1.37
date	2015.09.10.22.48.58;	author nicm;	state Exp;
branches;
next	1.36;
commitid	stJ3KRI2o7F5OBtF;

1.36
date	2015.09.08.11.35.57;	author jca;	state Exp;
branches;
next	1.35;
commitid	vbMjJqhidUqyld9k;

1.35
date	2015.09.01.13.12.31;	author tedu;	state Exp;
branches;
next	1.34;
commitid	sKGEDet4KOfGjsIb;

1.34
date	2013.12.17.16.37.05;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2009.02.07.14.03.24;	author kili;	state Exp;
branches;
next	1.32;

1.32
date	2009.02.07.07.24.37;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2008.05.17.23.31.52;	author sobrado;	state Exp;
branches;
next	1.30;

1.30
date	2007.08.02.10.50.25;	author fgsch;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.12.00.26.58;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.11.20.31.21;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.30.17.16.37;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.28.21.33.04;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.02.07.53.01;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.22.17.14.34;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.20.11.34.26;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.19.04.14.20;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.18.21.25.44;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.18.21.04.52;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.18.20.55.52;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.10.13.03.36;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.22.07.40.38;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.28.09.45.09;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.09.05.47.27;	author todd;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.19.09.49.50;	author camield;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.21.22.41.03;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.06.15.01.18.33;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.01.10.17.55.01;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.01.08.20.24.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.10.29.04.09.19;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.06.25.19.01.44;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.06.19.13.58.37;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.06.18.22.42.27;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.11.21.07.59.27;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.10.01.02.05.32;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.08.25.12.37.55;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.20.08.45;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.06.19.10;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.14.06.19.10;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.51
log
@Use PATH_MAX instead of a local define

okk deraadt@@ millert@@ anton@@
@
text
@/*	$OpenBSD: c_ksh.c,v 1.50 2016/03/21 13:35:00 tb Exp $	*/

/*
 * built-in Korn commands: c_*
 */

#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>

#include "sh.h"

int
c_cd(char **wp)
{
	int optc;
	int physical = Flag(FPHYSICAL);
	int cdnode;			/* was a node from cdpath added in? */
	int printpath = 0;		/* print where we cd'd? */
	int rval;
	struct tbl *pwd_s, *oldpwd_s;
	XString xs;
	char *xp;
	char *dir, *try, *pwd;
	int phys_path;
	char *cdpath;
	char *fdir = NULL;

	while ((optc = ksh_getopt(wp, &builtin_opt, "LP")) != -1)
		switch (optc) {
		case 'L':
			physical = 0;
			break;
		case 'P':
			physical = 1;
			break;
		case '?':
			return 1;
		}
	wp += builtin_opt.optind;

	if (Flag(FRESTRICTED)) {
		bi_errorf("restricted shell - can't cd");
		return 1;
	}

	pwd_s = global("PWD");
	oldpwd_s = global("OLDPWD");

	if (!wp[0]) {
		/* No arguments - go home */
		if ((dir = str_val(global("HOME"))) == null) {
			bi_errorf("no home directory (HOME not set)");
			return 1;
		}
	} else if (!wp[1]) {
		/* One argument: - or dir */
		dir = wp[0];
		if (strcmp(dir, "-") == 0) {
			dir = str_val(oldpwd_s);
			if (dir == null) {
				bi_errorf("no OLDPWD");
				return 1;
			}
			printpath++;
		}
	} else if (!wp[2]) {
		/* Two arguments - substitute arg1 in PWD for arg2 */
		int ilen, olen, nlen, elen;
		char *cp;

		if (!current_wd[0]) {
			bi_errorf("don't know current directory");
			return 1;
		}
		/* substitute arg1 for arg2 in current path.
		 * if the first substitution fails because the cd fails
		 * we could try to find another substitution. For now
		 * we don't
		 */
		if ((cp = strstr(current_wd, wp[0])) == NULL) {
			bi_errorf("bad substitution");
			return 1;
		}
		ilen = cp - current_wd;
		olen = strlen(wp[0]);
		nlen = strlen(wp[1]);
		elen = strlen(current_wd + ilen + olen) + 1;
		fdir = dir = alloc(ilen + nlen + elen, ATEMP);
		memcpy(dir, current_wd, ilen);
		memcpy(dir + ilen, wp[1], nlen);
		memcpy(dir + ilen + nlen, current_wd + ilen + olen, elen);
		printpath++;
	} else {
		bi_errorf("too many arguments");
		return 1;
	}

	Xinit(xs, xp, PATH_MAX, ATEMP);
	/* xp will have a bogus value after make_path() - set it to 0
	 * so that if it's used, it will cause a dump
	 */
	xp = NULL;

	cdpath = str_val(global("CDPATH"));
	do {
		cdnode = make_path(current_wd, dir, &cdpath, &xs, &phys_path);
		if (physical)
			rval = chdir(try = Xstring(xs, xp) + phys_path);
		else {
			simplify_path(Xstring(xs, xp));
			rval = chdir(try = Xstring(xs, xp));
		}
	} while (rval < 0 && cdpath != NULL);

	if (rval < 0) {
		if (cdnode)
			bi_errorf("%s: bad directory", dir);
		else
			bi_errorf("%s - %s", try, strerror(errno));
		afree(fdir, ATEMP);
		return 1;
	}

	/* Clear out tracked aliases with relative paths */
	flushcom(0);

	/* Set OLDPWD (note: unsetting OLDPWD does not disable this
	 * setting in at&t ksh)
	 */
	if (current_wd[0])
		/* Ignore failure (happens if readonly or integer) */
		setstr(oldpwd_s, current_wd, KSH_RETURN_ERROR);

	if (Xstring(xs, xp)[0] != '/') {
		pwd = NULL;
	} else
	if (!physical || !(pwd = get_phys_path(Xstring(xs, xp))))
		pwd = Xstring(xs, xp);

	/* Set PWD */
	if (pwd) {
		char *ptmp = pwd;
		set_current_wd(ptmp);
		/* Ignore failure (happens if readonly or integer) */
		setstr(pwd_s, ptmp, KSH_RETURN_ERROR);
	} else {
		set_current_wd(null);
		pwd = Xstring(xs, xp);
		/* XXX unset $PWD? */
	}
	if (printpath || cdnode)
		shprintf("%s\n", pwd);

	afree(fdir, ATEMP);

	return 0;
}

int
c_pwd(char **wp)
{
	int optc;
	int physical = Flag(FPHYSICAL);
	char *p, *freep = NULL;

	while ((optc = ksh_getopt(wp, &builtin_opt, "LP")) != -1)
		switch (optc) {
		case 'L':
			physical = 0;
			break;
		case 'P':
			physical = 1;
			break;
		case '?':
			return 1;
		}
	wp += builtin_opt.optind;

	if (wp[0]) {
		bi_errorf("too many arguments");
		return 1;
	}
	p = current_wd[0] ? (physical ? get_phys_path(current_wd) : current_wd) :
	    NULL;
	if (p && access(p, R_OK) < 0)
		p = NULL;
	if (!p) {
		freep = p = ksh_get_wd(NULL, 0);
		if (!p) {
			bi_errorf("can't get current directory - %s",
			    strerror(errno));
			return 1;
		}
	}
	shprintf("%s\n", p);
	afree(freep, ATEMP);
	return 0;
}

int
c_print(char **wp)
{
#define PO_NL		BIT(0)	/* print newline */
#define PO_EXPAND	BIT(1)	/* expand backslash sequences */
#define PO_PMINUSMINUS	BIT(2)	/* print a -- argument */
#define PO_HIST		BIT(3)	/* print to history instead of stdout */
#define PO_COPROC	BIT(4)	/* printing to coprocess: block SIGPIPE */
	int fd = 1;
	int flags = PO_EXPAND|PO_NL;
	char *s;
	const char *emsg;
	XString xs;
	char *xp;

	if (wp[0][0] == 'e') {	/* echo command */
		int nflags = flags;

		/* A compromise between sysV and BSD echo commands:
		 * escape sequences are enabled by default, and
		 * -n, -e and -E are recognized if they appear
		 * in arguments with no illegal options (ie, echo -nq
		 * will print -nq).
		 * Different from sysV echo since options are recognized,
		 * different from BSD echo since escape sequences are enabled
		 * by default.
		 */
		wp += 1;
		if (Flag(FPOSIX)) {
			if (*wp && strcmp(*wp, "-n") == 0) {
				flags &= ~PO_NL;
				wp++;
			}
		} else {
			while ((s = *wp) && *s == '-' && s[1]) {
				while (*++s)
					if (*s == 'n')
						nflags &= ~PO_NL;
					else if (*s == 'e')
						nflags |= PO_EXPAND;
					else if (*s == 'E')
						nflags &= ~PO_EXPAND;
					else
						/* bad option: don't use
						 * nflags, print argument
						 */
						break;
				if (*s)
					break;
				wp++;
				flags = nflags;
			}
		}
	} else {
		int optc;
		const char *options = "Rnprsu,";
		while ((optc = ksh_getopt(wp, &builtin_opt, options)) != -1)
			switch (optc) {
			case 'R': /* fake BSD echo command */
				flags |= PO_PMINUSMINUS;
				flags &= ~PO_EXPAND;
				options = "ne";
				break;
			case 'e':
				flags |= PO_EXPAND;
				break;
			case 'n':
				flags &= ~PO_NL;
				break;
			case 'p':
				if ((fd = coproc_getfd(W_OK, &emsg)) < 0) {
					bi_errorf("-p: %s", emsg);
					return 1;
				}
				break;
			case 'r':
				flags &= ~PO_EXPAND;
				break;
			case 's':
				flags |= PO_HIST;
				break;
			case 'u':
				if (!*(s = builtin_opt.optarg))
					fd = 0;
				else if ((fd = check_fd(s, W_OK, &emsg)) < 0) {
					bi_errorf("-u: %s: %s", s, emsg);
					return 1;
				}
				break;
			case '?':
				return 1;
			}
		if (!(builtin_opt.info & GI_MINUSMINUS)) {
			/* treat a lone - like -- */
			if (wp[builtin_opt.optind] &&
			    strcmp(wp[builtin_opt.optind], "-") == 0)
				builtin_opt.optind++;
		} else if (flags & PO_PMINUSMINUS)
			builtin_opt.optind--;
		wp += builtin_opt.optind;
	}

	Xinit(xs, xp, 128, ATEMP);

	while (*wp != NULL) {
		int c;
		s = *wp;
		while ((c = *s++) != '\0') {
			Xcheck(xs, xp);
			if ((flags & PO_EXPAND) && c == '\\') {
				int i;

				switch ((c = *s++)) {
				/* Oddly enough, \007 seems more portable than
				 * \a (due to HP-UX cc, Ultrix cc, old pcc's,
				 * etc.).
				 */
				case 'a': c = '\007'; break;
				case 'b': c = '\b'; break;
				case 'c': flags &= ~PO_NL;
					  continue; /* AT&T brain damage */
				case 'f': c = '\f'; break;
				case 'n': c = '\n'; break;
				case 'r': c = '\r'; break;
				case 't': c = '\t'; break;
				case 'v': c = 0x0B; break;
				case '0':
					/* Look for an octal number: can have
					 * three digits (not counting the
					 * leading 0).  Truly burnt.
					 */
					c = 0;
					for (i = 0; i < 3; i++) {
						if (*s >= '0' && *s <= '7')
							c = c*8 + *s++ - '0';
						else
							break;
					}
					break;
				case '\0': s--; c = '\\'; break;
				case '\\': break;
				default:
					Xput(xs, xp, '\\');
				}
			}
			Xput(xs, xp, c);
		}
		if (*++wp != NULL)
			Xput(xs, xp, ' ');
	}
	if (flags & PO_NL)
		Xput(xs, xp, '\n');

	if (flags & PO_HIST) {
		Xput(xs, xp, '\0');
		source->line++;
		histsave(source->line, Xstring(xs, xp), 1);
		Xfree(xs, xp);
	} else {
		int n, len = Xlength(xs, xp);
		int opipe = 0;

		/* Ensure we aren't killed by a SIGPIPE while writing to
		 * a coprocess.  at&t ksh doesn't seem to do this (seems
		 * to just check that the co-process is alive, which is
		 * not enough).
		 */
		if (coproc.write >= 0 && coproc.write == fd) {
			flags |= PO_COPROC;
			opipe = block_pipe();
		}
		for (s = Xstring(xs, xp); len > 0; ) {
			n = write(fd, s, len);
			if (n < 0) {
				if (flags & PO_COPROC)
					restore_pipe(opipe);
				if (errno == EINTR) {
					/* allow user to ^C out */
					intrcheck();
					if (flags & PO_COPROC)
						opipe = block_pipe();
					continue;
				}
				/* This doesn't really make sense - could
				 * break scripts (print -p generates
				 * error message).
				*if (errno == EPIPE)
				*	coproc_write_close(fd);
				 */
				return 1;
			}
			s += n;
			len -= n;
		}
		if (flags & PO_COPROC)
			restore_pipe(opipe);
	}

	return 0;
}

int
c_whence(char **wp)
{
	struct tbl *tp;
	char *id;
	int pflag = 0, vflag = 0, Vflag = 0;
	int ret = 0;
	int optc;
	int iam_whence = wp[0][0] == 'w';
	int fcflags;
	const char *options = iam_whence ? "pv" : "pvV";

	while ((optc = ksh_getopt(wp, &builtin_opt, options)) != -1)
		switch (optc) {
		case 'p':
			pflag = 1;
			break;
		case 'v':
			vflag = 1;
			break;
		case 'V':
			Vflag = 1;
			break;
		case '?':
			return 1;
		}
	wp += builtin_opt.optind;


	fcflags = FC_BI | FC_PATH | FC_FUNC;
	if (!iam_whence) {
		/* Note that -p on its own is dealt with in comexec() */
		if (pflag)
			fcflags |= FC_DEFPATH;
		/* Convert command options to whence options.  Note that
		 * command -pV and command -pv use a different path search
		 * than whence -v or whence -pv.  This should be considered
		 * a feature.
		 */
		vflag = Vflag;
	} else if (pflag)
		fcflags &= ~(FC_BI | FC_FUNC);

	while ((vflag || ret == 0) && (id = *wp++) != NULL) {
		tp = NULL;
		if (!iam_whence || !pflag)
			tp = ktsearch(&keywords, id, hash(id));
		if (!tp && (!iam_whence || !pflag)) {
			tp = ktsearch(&aliases, id, hash(id));
			if (tp && !(tp->flag & ISSET))
				tp = NULL;
		}
		if (!tp)
			tp = findcom(id, fcflags);
		if (vflag || (tp->type != CALIAS && tp->type != CEXEC &&
		    tp->type != CTALIAS))
			shprintf("%s", id);
		switch (tp->type) {
		case CKEYWD:
			if (vflag)
				shprintf(" is a reserved word");
			break;
		case CALIAS:
			if (vflag)
				shprintf(" is an %salias for ",
				    (tp->flag & EXPORT) ? "exported " : "");
			if (!iam_whence && !vflag)
				shprintf("alias %s=", id);
			print_value_quoted(tp->val.s);
			break;
		case CFUNC:
			if (vflag) {
				shprintf(" is a");
				if (tp->flag & EXPORT)
					shprintf("n exported");
				if (tp->flag & TRACE)
					shprintf(" traced");
				if (!(tp->flag & ISSET)) {
					shprintf(" undefined");
					if (tp->u.fpath)
						shprintf(" (autoload from %s)",
						    tp->u.fpath);
				}
				shprintf(" function");
			}
			break;
		case CSHELL:
			if (vflag)
				shprintf(" is a%s shell builtin",
				    (tp->flag & SPEC_BI) ? " special" : "");
			break;
		case CTALIAS:
		case CEXEC:
			if (tp->flag & ISSET) {
				if (vflag) {
					shprintf(" is ");
					if (tp->type == CTALIAS)
						shprintf("a tracked %salias for ",
						    (tp->flag & EXPORT) ?
						    "exported " : "");
				}
				shprintf("%s", tp->val.s);
			} else {
				if (vflag)
					shprintf(" not found");
				ret = 1;
			}
			break;
		default:
			shprintf("%s is *GOK*", id);
			break;
		}
		if (vflag || !ret)
			shprintf("\n");
	}
	return ret;
}

/* Deal with command -vV - command -p dealt with in comexec() */
int
c_command(char **wp)
{
	/* Let c_whence do the work.  Note that c_command() must be
	 * a distinct function from c_whence() (tested in comexec()).
	 */
	return c_whence(wp);
}

/* typeset, export, and readonly */
int
c_typeset(char **wp)
{
	struct block *l;
	struct tbl *vp, **p;
	int fset = 0, fclr = 0, thing = 0, func = 0, local = 0, pflag = 0;
	const char *options = "L#R#UZ#fi#lprtux";	/* see comment below */
	char *fieldstr, *basestr;
	int field, base, optc, flag;

	switch (**wp) {
	case 'e':		/* export */
		fset |= EXPORT;
		options = "p";
		break;
	case 'r':		/* readonly */
		fset |= RDONLY;
		options = "p";
		break;
	case 's':		/* set */
		/* called with 'typeset -' */
		break;
	case 't':		/* typeset */
		local = 1;
		break;
	}

	fieldstr = basestr = NULL;
	builtin_opt.flags |= GF_PLUSOPT;
	/* at&t ksh seems to have 0-9 as options, which are multiplied
	 * to get a number that is used with -L, -R, -Z or -i (eg, -1R2
	 * sets right justify in a field of 12).  This allows options
	 * to be grouped in an order (eg, -Lu12), but disallows -i8 -L3 and
	 * does not allow the number to be specified as a separate argument
	 * Here, the number must follow the RLZi option, but is optional
	 * (see the # kludge in ksh_getopt()).
	 */
	while ((optc = ksh_getopt(wp, &builtin_opt, options)) != -1) {
		flag = 0;
		switch (optc) {
		case 'L':
			flag = LJUST;
			fieldstr = builtin_opt.optarg;
			break;
		case 'R':
			flag = RJUST;
			fieldstr = builtin_opt.optarg;
			break;
		case 'U':
			/* at&t ksh uses u, but this conflicts with
			 * upper/lower case.  If this option is changed,
			 * need to change the -U below as well
			 */
			flag = INT_U;
			break;
		case 'Z':
			flag = ZEROFIL;
			fieldstr = builtin_opt.optarg;
			break;
		case 'f':
			func = 1;
			break;
		case 'i':
			flag = INTEGER;
			basestr = builtin_opt.optarg;
			break;
		case 'l':
			flag = LCASEV;
			break;
		case 'p':
			/* posix export/readonly -p flag.
			 * typeset -p is the same as typeset (in pdksh);
			 * here for compatibility with ksh93.
			 */
			pflag = 1;
			break;
		case 'r':
			flag = RDONLY;
			break;
		case 't':
			flag = TRACE;
			break;
		case 'u':
			flag = UCASEV_AL;	/* upper case / autoload */
			break;
		case 'x':
			flag = EXPORT;
			break;
		case '?':
			return 1;
		}
		if (builtin_opt.info & GI_PLUS) {
			fclr |= flag;
			fset &= ~flag;
			thing = '+';
		} else {
			fset |= flag;
			fclr &= ~flag;
			thing = '-';
		}
	}

	field = 0;
	if (fieldstr && !bi_getn(fieldstr, &field))
		return 1;
	base = 0;
	if (basestr && !bi_getn(basestr, &base))
		return 1;

	if (!(builtin_opt.info & GI_MINUSMINUS) && wp[builtin_opt.optind] &&
	    (wp[builtin_opt.optind][0] == '-' ||
	    wp[builtin_opt.optind][0] == '+') &&
	    wp[builtin_opt.optind][1] == '\0') {
		thing = wp[builtin_opt.optind][0];
		builtin_opt.optind++;
	}

	if (func && ((fset|fclr) & ~(TRACE|UCASEV_AL|EXPORT))) {
		bi_errorf("only -t, -u and -x options may be used with -f");
		return 1;
	}
	if (wp[builtin_opt.optind]) {
		/* Take care of exclusions.
		 * At this point, flags in fset are cleared in fclr and vise
		 * versa.  This property should be preserved.
		 */
		if (fset & LCASEV)	/* LCASEV has priority over UCASEV_AL */
			fset &= ~UCASEV_AL;
		if (fset & LJUST)	/* LJUST has priority over RJUST */
			fset &= ~RJUST;
		if ((fset & (ZEROFIL|LJUST)) == ZEROFIL) { /* -Z implies -ZR */
			fset |= RJUST;
			fclr &= ~RJUST;
		}
		/* Setting these attributes clears the others, unless they
		 * are also set in this command
		 */
		if (fset & (LJUST | RJUST | ZEROFIL | UCASEV_AL | LCASEV |
		    INTEGER | INT_U | INT_L))
			fclr |= ~fset & (LJUST | RJUST | ZEROFIL | UCASEV_AL |
			    LCASEV | INTEGER | INT_U | INT_L);
	}

	/* set variables and attributes */
	if (wp[builtin_opt.optind]) {
		int i;
		int rval = 0;
		struct tbl *f;

		if (local && !func)
			fset |= LOCAL;
		for (i = builtin_opt.optind; wp[i]; i++) {
			if (func) {
				f = findfunc(wp[i], hash(wp[i]),
				    (fset&UCASEV_AL) ? true : false);
				if (!f) {
					/* at&t ksh does ++rval: bogus */
					rval = 1;
					continue;
				}
				if (fset | fclr) {
					f->flag |= fset;
					f->flag &= ~fclr;
				} else
					fptreef(shl_stdout, 0,
					    f->flag & FKSH ?
					    "function %s %T\n" :
					    "%s() %T\n", wp[i], f->val.t);
			} else if (!typeset(wp[i], fset, fclr, field, base)) {
				bi_errorf("%s: not identifier", wp[i]);
				return 1;
			}
		}
		return rval;
	}

	/* list variables and attributes */
	flag = fset | fclr; /* no difference at this point.. */
	if (func) {
		for (l = genv->loc; l; l = l->next) {
			for (p = ktsort(&l->funs); (vp = *p++); ) {
				if (flag && (vp->flag & flag) == 0)
					continue;
				if (thing == '-')
					fptreef(shl_stdout, 0, vp->flag & FKSH ?
					    "function %s %T\n" : "%s() %T\n",
					    vp->name, vp->val.t);
				else
					shprintf("%s\n", vp->name);
			}
		}
	} else {
		for (l = genv->loc; l; l = l->next) {
			for (p = ktsort(&l->vars); (vp = *p++); ) {
				struct tbl *tvp;
				int any_set = 0;
				/*
				 * See if the parameter is set (for arrays, if any
				 * element is set).
				 */
				for (tvp = vp; tvp; tvp = tvp->u.array)
					if (tvp->flag & ISSET) {
						any_set = 1;
						break;
					}

				/*
				 * Check attributes - note that all array elements
				 * have (should have?) the same attributes, so checking
				 * the first is sufficient.
				 *
				 * Report an unset param only if the user has
				 * explicitly given it some attribute (like export);
				 * otherwise, after "echo $FOO", we would report FOO...
				 */
				if (!any_set && !(vp->flag & USERATTRIB))
					continue;
				if (flag && (vp->flag & flag) == 0)
					continue;
				for (; vp; vp = vp->u.array) {
					/* Ignore array elements that aren't
					 * set unless there are no set elements,
					 * in which case the first is reported on */
					if ((vp->flag&ARRAY) && any_set &&
					    !(vp->flag & ISSET))
						continue;
					/* no arguments */
					if (thing == 0 && flag == 0) {
						/* at&t ksh prints things
						 * like export, integer,
						 * leftadj, zerofill, etc.,
						 * but POSIX says must
						 * be suitable for re-entry...
						 */
						shprintf("typeset ");
						if ((vp->flag&INTEGER))
							shprintf("-i ");
						if ((vp->flag&EXPORT))
							shprintf("-x ");
						if ((vp->flag&RDONLY))
							shprintf("-r ");
						if ((vp->flag&TRACE))
							shprintf("-t ");
						if ((vp->flag&LJUST))
							shprintf("-L%d ", vp->u2.field);
						if ((vp->flag&RJUST))
							shprintf("-R%d ", vp->u2.field);
						if ((vp->flag&ZEROFIL))
							shprintf("-Z ");
						if ((vp->flag&LCASEV))
							shprintf("-l ");
						if ((vp->flag&UCASEV_AL))
							shprintf("-u ");
						if ((vp->flag&INT_U))
							shprintf("-U ");
						shprintf("%s\n", vp->name);
						    if (vp->flag&ARRAY)
						break;
					} else {
						if (pflag)
							shprintf("%s ",
							    (flag & EXPORT) ?
							    "export" : "readonly");
						if ((vp->flag&ARRAY) && any_set)
							shprintf("%s[%d]",
							    vp->name, vp->index);
						else
							shprintf("%s", vp->name);
						if (thing == '-' && (vp->flag&ISSET)) {
							char *s = str_val(vp);

							shprintf("=");
							/* at&t ksh can't have
							 * justified integers.. */
							if ((vp->flag &
							    (INTEGER|LJUST|RJUST)) ==
							    INTEGER)
								shprintf("%s", s);
							else
								print_value_quoted(s);
						}
						shprintf("\n");
					}
					/* Only report first `element' of an array with
					* no set elements.
					*/
					if (!any_set)
						break;
				}
			}
		}
	}
	return 0;
}

int
c_alias(char **wp)
{
	struct table *t = &aliases;
	int rv = 0, rflag = 0, tflag, Uflag = 0, pflag = 0, prefix = 0;
	int xflag = 0;
	int optc;

	builtin_opt.flags |= GF_PLUSOPT;
	while ((optc = ksh_getopt(wp, &builtin_opt, "dprtUx")) != -1) {
		prefix = builtin_opt.info & GI_PLUS ? '+' : '-';
		switch (optc) {
		case 'd':
			t = &homedirs;
			break;
		case 'p':
			pflag = 1;
			break;
		case 'r':
			rflag = 1;
			break;
		case 't':
			t = &taliases;
			break;
		case 'U':
			/*
			 * kludge for tracked alias initialization
			 * (don't do a path search, just make an entry)
			 */
			Uflag = 1;
			break;
		case 'x':
			xflag = EXPORT;
			break;
		case '?':
			return 1;
		}
	}
	wp += builtin_opt.optind;

	if (!(builtin_opt.info & GI_MINUSMINUS) && *wp &&
	    (wp[0][0] == '-' || wp[0][0] == '+') && wp[0][1] == '\0') {
		prefix = wp[0][0];
		wp++;
	}

	tflag = t == &taliases;

	/* "hash -r" means reset all the tracked aliases.. */
	if (rflag) {
		static const char *const args[] = {
			"unalias", "-ta", NULL
		};

		if (!tflag || *wp) {
			shprintf("alias: -r flag can only be used with -t"
			    " and without arguments\n");
			return 1;
		}
		ksh_getopt_reset(&builtin_opt, GF_ERROR);
		return c_unalias((char **) args);
	}

	if (*wp == NULL) {
		struct tbl *ap, **p;

		for (p = ktsort(t); (ap = *p++) != NULL; )
			if ((ap->flag & (ISSET|xflag)) == (ISSET|xflag)) {
				if (pflag)
					shf_puts("alias ", shl_stdout);
				shf_puts(ap->name, shl_stdout);
				if (prefix != '+') {
					shf_putc('=', shl_stdout);
					print_value_quoted(ap->val.s);
				}
				shprintf("\n");
			}
	}

	for (; *wp != NULL; wp++) {
		char *alias = *wp;
		char *val = strchr(alias, '=');
		char *newval;
		struct tbl *ap;
		int h;

		if (val)
			alias = str_nsave(alias, val++ - alias, ATEMP);
		h = hash(alias);
		if (val == NULL && !tflag && !xflag) {
			ap = ktsearch(t, alias, h);
			if (ap != NULL && (ap->flag&ISSET)) {
				if (pflag)
					shf_puts("alias ", shl_stdout);
				shf_puts(ap->name, shl_stdout);
				if (prefix != '+') {
					shf_putc('=', shl_stdout);
					print_value_quoted(ap->val.s);
				}
				shprintf("\n");
			} else {
				shprintf("%s alias not found\n", alias);
				rv = 1;
			}
			continue;
		}
		ap = ktenter(t, alias, h);
		ap->type = tflag ? CTALIAS : CALIAS;
		/* Are we setting the value or just some flags? */
		if ((val && !tflag) || (!val && tflag && !Uflag)) {
			if (ap->flag&ALLOC) {
				ap->flag &= ~(ALLOC|ISSET);
				afree(ap->val.s, APERM);
			}
			/* ignore values for -t (at&t ksh does this) */
			newval = tflag ? search(alias, path, X_OK, NULL) :
			    val;
			if (newval) {
				ap->val.s = str_save(newval, APERM);
				ap->flag |= ALLOC|ISSET;
			} else
				ap->flag &= ~ISSET;
		}
		ap->flag |= DEFINED;
		if (prefix == '+')
			ap->flag &= ~xflag;
		else
			ap->flag |= xflag;
		if (val)
			afree(alias, ATEMP);
	}

	return rv;
}

int
c_unalias(char **wp)
{
	struct table *t = &aliases;
	struct tbl *ap;
	int rv = 0, all = 0;
	int optc;

	while ((optc = ksh_getopt(wp, &builtin_opt, "adt")) != -1)
		switch (optc) {
		case 'a':
			all = 1;
			break;
		case 'd':
			t = &homedirs;
			break;
		case 't':
			t = &taliases;
			break;
		case '?':
			return 1;
		}
	wp += builtin_opt.optind;

	for (; *wp != NULL; wp++) {
		ap = ktsearch(t, *wp, hash(*wp));
		if (ap == NULL) {
			rv = 1;	/* POSIX */
			continue;
		}
		if (ap->flag&ALLOC) {
			ap->flag &= ~(ALLOC|ISSET);
			afree(ap->val.s, APERM);
		}
		ap->flag &= ~(DEFINED|ISSET|EXPORT);
	}

	if (all) {
		struct tstate ts;

		for (ktwalk(&ts, t); (ap = ktnext(&ts)); ) {
			if (ap->flag&ALLOC) {
				ap->flag &= ~(ALLOC|ISSET);
				afree(ap->val.s, APERM);
			}
			ap->flag &= ~(DEFINED|ISSET|EXPORT);
		}
	}

	return rv;
}

int
c_let(char **wp)
{
	int rv = 1;
	long val;

	if (wp[1] == NULL) /* at&t ksh does this */
		bi_errorf("no arguments");
	else
		for (wp++; *wp; wp++)
			if (!evaluate(*wp, &val, KSH_RETURN_ERROR, true)) {
				rv = 2;	/* distinguish error from zero result */
				break;
			} else
				rv = val == 0;
	return rv;
}

int
c_jobs(char **wp)
{
	int optc;
	int flag = 0;
	int nflag = 0;
	int rv = 0;

	while ((optc = ksh_getopt(wp, &builtin_opt, "lpnz")) != -1)
		switch (optc) {
		case 'l':
			flag = 1;
			break;
		case 'p':
			flag = 2;
			break;
		case 'n':
			nflag = 1;
			break;
		case 'z':	/* debugging: print zombies */
			nflag = -1;
			break;
		case '?':
			return 1;
		}
	wp += builtin_opt.optind;
	if (!*wp) {
		if (j_jobs(NULL, flag, nflag))
			rv = 1;
	} else {
		for (; *wp; wp++)
			if (j_jobs(*wp, flag, nflag))
				rv = 1;
	}
	return rv;
}

#ifdef JOBS
int
c_fgbg(char **wp)
{
	int bg = strcmp(*wp, "bg") == 0;
	int rv = 0;

	if (!Flag(FMONITOR)) {
		bi_errorf("job control not enabled");
		return 1;
	}
	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return 1;
	wp += builtin_opt.optind;
	if (*wp)
		for (; *wp; wp++)
			rv = j_resume(*wp, bg);
	else
		rv = j_resume("%%", bg);
	/* POSIX says fg shall return 0 (unless an error occurs).
	 * at&t ksh returns the exit value of the job...
	 */
	return (bg || Flag(FPOSIX)) ? 0 : rv;
}
#endif

struct kill_info {
	int num_width;
	int name_width;
};
static char *kill_fmt_entry(void *arg, int i, char *buf, int buflen);

/* format a single kill item */
static char *
kill_fmt_entry(void *arg, int i, char *buf, int buflen)
{
	struct kill_info *ki = (struct kill_info *) arg;

	i++;
	if (sigtraps[i].name)
		shf_snprintf(buf, buflen, "%*d %*s %s",
		    ki->num_width, i,
		    ki->name_width, sigtraps[i].name,
		    sigtraps[i].mess);
	else
		shf_snprintf(buf, buflen, "%*d %*d %s",
		    ki->num_width, i,
		    ki->name_width, sigtraps[i].signal,
		    sigtraps[i].mess);
	return buf;
}


int
c_kill(char **wp)
{
	Trap *t = NULL;
	char *p;
	int lflag = 0;
	int i, n, rv, sig;

	/* assume old style options if -digits or -UPPERCASE */
	if ((p = wp[1]) && *p == '-' &&
	    (digit(p[1]) || isupper((unsigned char)p[1]))) {
		if (!(t = gettrap(p + 1, true))) {
			bi_errorf("bad signal `%s'", p + 1);
			return 1;
		}
		i = (wp[2] && strcmp(wp[2], "--") == 0) ? 3 : 2;
	} else {
		int optc;

		while ((optc = ksh_getopt(wp, &builtin_opt, "ls:")) != -1)
			switch (optc) {
			case 'l':
				lflag = 1;
				break;
			case 's':
				if (!(t = gettrap(builtin_opt.optarg, true))) {
					bi_errorf("bad signal `%s'",
					    builtin_opt.optarg);
					return 1;
				}
				break;
			case '?':
				return 1;
			}
		i = builtin_opt.optind;
	}
	if ((lflag && t) || (!wp[i] && !lflag)) {
		shf_fprintf(shl_out,
		    "usage: kill [-s signame | -signum | -signame] { job | pid | pgrp } ...\n"
		    "       kill -l [exit_status ...]\n");
		bi_errorf(NULL);
		return 1;
	}

	if (lflag) {
		if (wp[i]) {
			for (; wp[i]; i++) {
				if (!bi_getn(wp[i], &n))
					return 1;
				if (n > 128 && n < 128 + NSIG)
					n -= 128;
				if (n > 0 && n < NSIG && sigtraps[n].name)
					shprintf("%s\n", sigtraps[n].name);
				else
					shprintf("%d\n", n);
			}
		} else if (Flag(FPOSIX)) {
			p = null;
			for (i = 1; i < NSIG; i++, p = " ")
				if (sigtraps[i].name)
					shprintf("%s%s", p, sigtraps[i].name);
			shprintf("\n");
		} else {
			int mess_width = 0, w, i;
			struct kill_info ki = {
				.num_width = 1,
				.name_width = 0,
			};

			for (i = NSIG; i >= 10; i /= 10)
				ki.num_width++;

			for (i = 0; i < NSIG; i++) {
				w = sigtraps[i].name ? strlen(sigtraps[i].name) :
				    ki.num_width;
				if (w > ki.name_width)
					ki.name_width = w;
				w = strlen(sigtraps[i].mess);
				if (w > mess_width)
					mess_width = w;
			}

			print_columns(shl_stdout, NSIG - 1,
			    kill_fmt_entry, (void *) &ki,
			    ki.num_width + ki.name_width + mess_width + 3, 1);
		}
		return 0;
	}
	rv = 0;
	sig = t ? t->signal : SIGTERM;
	for (; (p = wp[i]); i++) {
		if (*p == '%') {
			if (j_kill(p, sig))
				rv = 1;
		} else if (!getn(p, &n)) {
			bi_errorf("%s: arguments must be jobs or process IDs",
			    p);
			rv = 1;
		} else {
			/* use killpg if < -1 since -1 does special things for
			 * some non-killpg-endowed kills
			 */
			if ((n < -1 ? killpg(-n, sig) : kill(n, sig)) < 0) {
				bi_errorf("%s: %s", p, strerror(errno));
				rv = 1;
			}
		}
	}
	return rv;
}

void
getopts_reset(int val)
{
	if (val >= 1) {
		ksh_getopt_reset(&user_opt,
		    GF_NONAME | (Flag(FPOSIX) ? 0 : GF_PLUSOPT));
		user_opt.optind = user_opt.uoptind = val;
	}
}

int
c_getopts(char **wp)
{
	int	argc;
	const char *options;
	const char *var;
	int	optc;
	int	ret;
	char	buf[3];
	struct tbl *vq, *voptarg;

	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return 1;
	wp += builtin_opt.optind;

	options = *wp++;
	if (!options) {
		bi_errorf("missing options argument");
		return 1;
	}

	var = *wp++;
	if (!var) {
		bi_errorf("missing name argument");
		return 1;
	}
	if (!*var || *skip_varname(var, true)) {
		bi_errorf("%s: is not an identifier", var);
		return 1;
	}

	if (genv->loc->next == NULL) {
		internal_errorf(0, "c_getopts: no argv");
		return 1;
	}
	/* Which arguments are we parsing... */
	if (*wp == NULL)
		wp = genv->loc->next->argv;
	else
		*--wp = genv->loc->next->argv[0];

	/* Check that our saved state won't cause a core dump... */
	for (argc = 0; wp[argc]; argc++)
		;
	if (user_opt.optind > argc ||
	    (user_opt.p != 0 &&
	    user_opt.p > strlen(wp[user_opt.optind - 1]))) {
		bi_errorf("arguments changed since last call");
		return 1;
	}

	user_opt.optarg = NULL;
	optc = ksh_getopt(wp, &user_opt, options);

	if (optc >= 0 && optc != '?' && (user_opt.info & GI_PLUS)) {
		buf[0] = '+';
		buf[1] = optc;
		buf[2] = '\0';
	} else {
		/* POSIX says var is set to ? at end-of-options, at&t ksh
		 * sets it to null - we go with POSIX...
		 */
		buf[0] = optc < 0 ? '?' : optc;
		buf[1] = '\0';
	}

	/* at&t ksh does not change OPTIND if it was an unknown option.
	 * Scripts counting on this are prone to break... (ie, don't count
	 * on this staying).
	 */
	if (optc != '?') {
		user_opt.uoptind = user_opt.optind;
	}

	voptarg = global("OPTARG");
	voptarg->flag &= ~RDONLY;	/* at&t ksh clears ro and int */
	/* Paranoia: ensure no bizarre results. */
	if (voptarg->flag & INTEGER)
	    typeset("OPTARG", 0, INTEGER, 0, 0);
	if (user_opt.optarg == NULL)
		unset(voptarg, 0);
	else
		/* This can't fail (have cleared readonly/integer) */
		setstr(voptarg, user_opt.optarg, KSH_RETURN_ERROR);

	ret = 0;

	vq = global(var);
	/* Error message already printed (integer, readonly) */
	if (!setstr(vq, buf, KSH_RETURN_ERROR))
	    ret = 1;
	if (Flag(FEXPORT))
		typeset(var, EXPORT, 0, 0, 0);

	return optc < 0 ? 1 : ret;
}

#ifdef EMACS
int
c_bind(char **wp)
{
	int optc, rv = 0, macro = 0, list = 0;
	char *cp;

	while ((optc = ksh_getopt(wp, &builtin_opt, "lm")) != -1)
		switch (optc) {
		case 'l':
			list = 1;
			break;
		case 'm':
			macro = 1;
			break;
		case '?':
			return 1;
		}
	wp += builtin_opt.optind;

	if (*wp == NULL)	/* list all */
		rv = x_bind(NULL, NULL, 0, list);

	for (; *wp != NULL; wp++) {
		cp = strchr(*wp, '=');
		if (cp != NULL)
			*cp++ = '\0';
		if (x_bind(*wp, cp, macro, 0))
			rv = 1;
	}

	return rv;
}
#endif

/* A leading = means assignments before command are kept;
 * a leading * means a POSIX special builtin;
 * a leading + means a POSIX regular builtin
 * (* and + should not be combined).
 */
const struct builtin kshbuiltins [] = {
	{"+alias", c_alias},	/* no =: at&t manual wrong */
	{"+cd", c_cd},
	{"+command", c_command},
	{"echo", c_print},
	{"*=export", c_typeset},
#ifdef HISTORY
	{"+fc", c_fc},
#endif /* HISTORY */
	{"+getopts", c_getopts},
	{"+jobs", c_jobs},
	{"+kill", c_kill},
	{"let", c_let},
	{"print", c_print},
	{"pwd", c_pwd},
	{"*=readonly", c_typeset},
	{"=typeset", c_typeset},
	{"+unalias", c_unalias},
	{"whence", c_whence},
#ifdef JOBS
	{"+bg", c_fgbg},
	{"+fg", c_fgbg},
#endif
#ifdef EMACS
	{"bind", c_bind},
#endif
	{NULL, NULL}
};
@


1.50
log
@More ksh POSIX compliance fixes by Martijn Dekker:

This simple patch makes the 'command' builtin POSIX-compliant and
consistent with other current shells. It fixes two things:

   a) 'command -v' does not find shell reserved words (a.k.a. keywords).
For instance, 'command -v select' outputs nothing but should output
'select'.

   b) 'command -pv' always outputs the path of an external command, even
if 'command -p' would execute a builtin. For instance, 'command -p kill'
executes the 'kill' builtin, as expected, but 'command -pv kill' outputs
'/bin/kill'. The '-v' option is supposed to reflect what would actually
be executed, so 'command -pv kill' should output 'kill'. The -p option
sets the PATH to a default system value before doing the search, but
that has no bearing on the fact that builtins take precedence over
external commands.

The patch fixes both issues for 'command' without affecting the
behaviour of the ksh-specific builtin 'whence', which is handled by the
same C function.

Regression test added to obsd-regress.t.

Issues found and fixed by Martijn Dekker, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.49 2016/01/15 17:55:45 mmcc Exp $	*/
d102 1
a102 1
	Xinit(xs, xp, PATH, ATEMP);
@


1.49
log
@Initialize a struct kill_info and an associated int in the declarations
instead of scattering their initialization through the body. This makes
the body simpler and avoids an uninitialized use false positive.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.48 2015/12/30 09:07:00 tedu Exp $	*/
d436 1
a436 1
		/* Note that -p on its own is deal with in comexec() */
d439 4
a442 3
		/* Convert command options to whence options - note that
		 * command -pV uses a different path search than whence -v
		 * or whence -pv.  This should be considered a feature.
d445 1
a445 2
	}
	if (pflag)
d450 1
a450 1
		if ((iam_whence || vflag) && !pflag)
d452 1
a452 1
		if (!tp && !pflag) {
@


1.48
log
@rename global "e" to genv to avoid accidental shadowing and aliasing.
ok millert nicm tb
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.47 2015/12/14 13:59:42 tb Exp $	*/
d1187 5
a1191 3
			int w, i;
			int mess_width;
			struct kill_info ki;
d1193 1
a1193 1
			for (i = NSIG, ki.num_width = 1; i >= 10; i /= 10)
d1195 1
a1195 1
			ki.name_width = mess_width = 0;
@


1.47
log
@Move system headers from sh.h to those files that actually need them.

ok mmcc@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.46 2015/10/21 15:20:37 mmcc Exp $	*/
d713 1
a713 1
		for (l = e->loc; l; l = l->next) {
d726 1
a726 1
		for (l = e->loc; l; l = l->next) {
d1274 1
a1274 1
	if (e->loc->next == NULL) {
d1280 1
a1280 1
		wp = e->loc->next->argv;
d1282 1
a1282 1
		*--wp = e->loc->next->argv[0];
@


1.46
log
@Don't bother casting NULL.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.45 2015/10/19 14:42:16 mmcc Exp $	*/
d10 1
d12 1
@


1.45
log
@Move string.h include from sh.h to the files that use it.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.44 2015/10/19 02:15:45 mmcc Exp $	*/
d1359 1
a1359 1
		rv = x_bind((char*)NULL, (char*)NULL, 0, list);
@


1.44
log
@Apply style(9) to header includes.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.43 2015/10/09 19:36:27 tedu Exp $	*/
d10 1
@


1.43
log
@remove null check before afree. from Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.42 2015/09/22 21:50:40 millert Exp $	*/
a6 1
#include "sh.h"
d8 1
d11 1
@


1.42
log
@Make errorf() and bi_errorf() handle a NULL argument.
From Michael McConville; OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.41 2015/09/18 07:28:24 nicm Exp $	*/
d120 1
a120 2
		if (fdir)
			afree(fdir, ATEMP);
d154 1
a154 2
	if (fdir)
		afree(fdir, ATEMP);
d196 1
a196 2
	if (freep)
		afree(freep, ATEMP);
@


1.41
log
@Last of the (thing *)0 -> NULL, from Michael McConville. No binary
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.40 2015/09/15 18:15:05 tedu Exp $	*/
d1163 1
a1163 1
		bi_errorf(null);
@


1.40
log
@correct spelling of NULL from (char *)0. from Michael McConville.
ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.39 2015/09/15 18:07:22 tedu Exp $	*/
d879 1
a879 1
			"unalias", "-ta", (const char *) 0
d943 1
a943 1
			newval = tflag ? search(alias, path, X_OK, (int *) 0) :
d1126 1
a1126 1
	Trap *t = (Trap *) 0;
d1273 1
a1273 1
	if (e->loc->next == (struct block *) 0) {
@


1.39
log
@stop abusing null (the variable) for an empty string in output formats.
from Michael McConville
ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.38 2015/09/14 16:08:50 nicm Exp $	*/
d80 1
a80 1
		if ((cp = strstr(current_wd, wp[0])) == (char *) 0) {
d102 1
a102 1
	xp = (char *) 0;
d113 1
a113 1
	} while (rval < 0 && cdpath != (char *) 0);
d136 1
a136 1
		pwd = (char *) 0;
d186 1
a186 1
	    (char *) 0;
d188 1
a188 1
		p = (char *) 0;
d190 1
a190 1
		freep = p = ksh_get_wd((char *) 0, 0);
d560 1
a560 1
	fieldstr = basestr = (char *) 0;
d1021 1
a1021 1
	if (wp[1] == (char *) 0) /* at&t ksh does this */
d1060 1
a1060 1
		if (j_jobs((char *) 0, flag, nflag))
d1278 1
a1278 1
	if (*wp == (char *) 0)
d1293 1
a1293 1
	user_opt.optarg = (char *) 0;
d1321 1
a1321 1
	if (user_opt.optarg == (char *) 0)
@


1.38
log
@Replace Tflag typedef with just int; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.37 2015/09/10 22:48:58 nicm Exp $	*/
d469 1
a469 2
				    (tp->flag & EXPORT) ? "exported " :
				    null);
d493 1
a493 1
				    (tp->flag & SPEC_BI) ? " special" : null);
d503 1
a503 1
						    "exported " : null);
@


1.37
log
@Replace newline and space defines by "\n" and " " directly, from Michael
McConville. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.36 2015/09/08 11:35:57 jca Exp $	*/
d539 1
a539 2
	Tflag fset = 0, fclr = 0;
	int thing = 0, func = 0, local = 0;
d542 1
a542 4
	int field, base;
	int optc;
	Tflag flag;
	int pflag = 0;
d833 2
a834 3
	int rv = 0, rflag = 0, tflag, Uflag = 0, pflag = 0;
	int prefix = 0;
	Tflag xflag = 0;
@


1.36
log
@Remove superfluous variable initialization; from Michael McConville.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.35 2015/09/01 13:12:31 tedu Exp $	*/
d518 1
a518 1
			shprintf(newline);
d819 1
a819 1
						shprintf(newline);
d909 1
a909 1
				shprintf(newline);
d933 1
a933 1
				shprintf(newline);
d1187 1
a1187 1
			for (i = 1; i < NSIG; i++, p = space)
d1190 1
a1190 1
			shprintf(newline);
@


1.35
log
@remove casts and null checks before free. from Michael McConville
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.34 2013/12/17 16:37:05 deraadt Exp $	*/
d537 1
a537 1
	struct block *l = e->loc;
@


1.34
log
@ctype cleanups.  Repeated re-audits of this sensitive area by okan and
myself, with a variety of other people spending some time as well.
Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.33 2009/02/07 14:03:24 kili Exp $	*/
d946 1
a946 1
				afree((void*)ap->val.s, APERM);
d1001 1
a1001 1
			afree((void*)ap->val.s, APERM);
d1012 1
a1012 1
				afree((void*)ap->val.s, APERM);
@


1.33
log
@
Ensure that *wp isn't NULL.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.32 2009/02/07 07:24:37 guenther Exp $	*/
d1138 2
a1139 1
	if ((p = wp[1]) && *p == '-' && (digit(p[1]) || isupper(p[1]))) {
@


1.32
log
@Make built-in echo behave according to POSIX when set -o posix is in effect:
the only option is -n, and only one of those is parsed.

diff from Ingo Schwarze
ok otto@@ kili@@; manpage changes ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.31 2008/05/17 23:31:52 sobrado Exp $	*/
d232 1
a232 1
			if (strcmp(*wp, "-n") == 0) {
@


1.31
log
@documentation tweaks.

ok (some time ago) jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.30 2007/08/02 10:50:25 fgsch Exp $	*/
d231 20
a250 12
		while ((s = *wp) && *s == '-' && s[1]) {
			while (*++s)
				if (*s == 'n')
					nflags &= ~PO_NL;
				else if (*s == 'e')
					nflags |= PO_EXPAND;
				else if (*s == 'E')
					nflags &= ~PO_EXPAND;
				else
					/* bad option: don't use nflags, print
					 * argument
					 */
d252 3
a254 4
			if (*s)
				break;
			wp++;
			flags = nflags;
@


1.30
log
@fix memory leaks and one potential null deref found by coverity. from netbsd.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.29 2006/03/12 00:26:58 deraadt Exp $	*/
d1159 2
a1160 2
		    "Usage: kill [ -s signame | -signum | -signame ] {pid|job}...\n"
		    "       kill -l [exit_status]\n");
@


1.29
log
@might as well make ksh_getopt() match real getopt(), ie. get rid of that
stupid EOF concept that was never true.  adobriyan@@gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.28 2005/12/11 20:31:21 otto Exp $	*/
d26 1
d88 1
a88 1
		dir = alloc(ilen + nlen + elen, ATEMP);
d120 2
d155 3
d166 1
a166 1
	char *p;
d190 1
a190 1
		p = ksh_get_wd((char *) 0, 0);
d198 2
@


1.28
log
@fix a few name clashes with libc; found by lint. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.27 2005/03/30 17:16:37 deraadt Exp $	*/
d27 1
a27 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "LP")) != EOF)
d162 1
a162 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "LP")) != EOF)
d244 1
a244 1
		while ((optc = ksh_getopt(wp, &builtin_opt, options)) != EOF)
d401 1
a401 1
	while ((optc = ksh_getopt(wp, &builtin_opt, options)) != EOF)
d560 1
a560 1
	while ((optc = ksh_getopt(wp, &builtin_opt, options)) != EOF) {
d828 1
a828 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "dprtUx")) != EOF) {
d962 1
a962 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "adt")) != EOF)
d1032 1
a1032 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "lpnz")) != EOF)
d1132 1
a1132 1
		while ((optc = ksh_getopt(wp, &builtin_opt, "ls:")) != EOF)
d1336 1
a1336 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "lm")) != EOF)
@


1.27
log
@lots of indentation cleanup, now ksh is readable like our other code.
double checked to make sure no binaries change, and eyed by niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.26 2005/03/28 21:33:04 deraadt Exp $	*/
d435 1
a435 1
			tp = tsearch(&keywords, id, hash(id));
d437 1
a437 1
			tp = tsearch(&aliases, id, hash(id));
d703 1
a703 1
			for (p = tsort(&l->funs); (vp = *p++); ) {
d716 1
a716 1
			for (p = tsort(&l->vars); (vp = *p++); ) {
d885 1
a885 1
		for (p = tsort(t); (ap = *p++) != NULL; )
d909 1
a909 1
			ap = tsearch(t, alias, h);
d925 1
a925 1
		ap = tenter(t, alias, h);
d979 1
a979 1
		ap = tsearch(t, *wp, hash(*wp));
d994 1
a994 1
		for (twalk(&ts, t); (ap = tnext(&ts)); ) {
@


1.26
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.25 2005/02/02 07:53:01 otto Exp $	*/
d108 1
a108 2
		else
		{
d179 2
a180 2
	p = current_wd[0] ? (physical ? get_phys_path(current_wd) : current_wd)
			  : (char *) 0;
d187 1
a187 1
				strerror(errno));
d246 1
a246 1
			  case 'R': /* fake BSD echo command */
d251 1
a251 1
			  case 'e':
d254 1
a254 1
			  case 'n':
d257 1
a257 1
			  case 'p':
d263 1
a263 1
			  case 'r':
d266 1
a266 1
			  case 's':
d269 1
a269 1
			  case 'u':
d277 1
a277 1
			  case '?':
d282 2
a283 2
			if (wp[builtin_opt.optind]
			    && strcmp(wp[builtin_opt.optind], "-") == 0)
d443 2
a444 2
		if (vflag || (tp->type != CALIAS && tp->type != CEXEC
			      && tp->type != CTALIAS))
d447 1
a447 1
		  case CKEYWD:
d451 1
a451 1
		  case CALIAS:
d454 2
a455 2
					(tp->flag & EXPORT) ? "exported "
							    : null);
d460 1
a460 1
		  case CFUNC:
d471 1
a471 1
							tp->u.fpath);
d476 1
a476 1
		  case CSHELL:
d481 2
a482 2
		  case CTALIAS:
		  case CEXEC:
d487 3
a489 5
						shprintf(
						    "a tracked %salias for ",
							(tp->flag & EXPORT) ?
								"exported "
							      : null);
d498 1
a498 1
		  default:
d534 1
a534 1
	  case 'e':		/* export */
d538 1
a538 1
	  case 'r':		/* readonly */
d542 1
a542 1
	  case 's':		/* set */
d545 1
a545 1
	  case 't':		/* typeset */
d563 1
a563 1
		  case 'L':
d567 1
a567 1
		  case 'R':
d571 1
a571 1
		  case 'U':
d578 1
a578 1
		  case 'Z':
d582 1
a582 1
		  case 'f':
d585 1
a585 1
		  case 'i':
d589 1
a589 1
		  case 'l':
d592 5
a596 4
		  case 'p': /* posix export/readonly -p flag.
			     * typeset -p is the same as typeset (in pdksh);
			     * here for compatibility with ksh93.
			     */
d599 1
a599 1
		  case 'r':
d602 1
a602 1
		  case 't':
d605 1
a605 1
		  case 'u':
d608 1
a608 1
		  case 'x':
d611 1
a611 1
		  case '?':
d632 4
a635 5
	if (!(builtin_opt.info & GI_MINUSMINUS) && wp[builtin_opt.optind]
	    && (wp[builtin_opt.optind][0] == '-'
		|| wp[builtin_opt.optind][0] == '+')
	    && wp[builtin_opt.optind][1] == '\0')
	{
d660 4
a663 5
		if (fset & (LJUST|RJUST|ZEROFIL|UCASEV_AL|LCASEV|INTEGER
			    |INT_U|INT_L))
			fclr |= ~fset &
				(LJUST|RJUST|ZEROFIL|UCASEV_AL|LCASEV|INTEGER
				 |INT_U|INT_L);
d677 1
a677 1
					     (fset&UCASEV_AL) ? true : false);
d688 3
a690 5
						f->flag & FKSH ?
						    "function %s %T\n"
						    : "%s() %T\n"
						,
						wp[i], f->val.t);
d702 11
a712 11
	    for (l = e->loc; l; l = l->next) {
		for (p = tsort(&l->funs); (vp = *p++); ) {
		    if (flag && (vp->flag & flag) == 0)
			    continue;
		    if (thing == '-')
			fptreef(shl_stdout, 0, vp->flag & FKSH ?
						    "function %s %T\n"
						    : "%s() %T\n",
				vp->name, vp->val.t);
		    else
			shprintf("%s\n", vp->name);
a713 1
	    }
d715 97
a811 12
	    for (l = e->loc; l; l = l->next) {
		for (p = tsort(&l->vars); (vp = *p++); ) {
		    struct tbl *tvp;
		    int any_set = 0;
		    /*
		     * See if the parameter is set (for arrays, if any
		     * element is set).
		     */
		    for (tvp = vp; tvp; tvp = tvp->u.array)
			if (tvp->flag & ISSET) {
			    any_set = 1;
			    break;
a812 77
		    /*
		     * Check attributes - note that all array elements
		     * have (should have?) the same attributes, so checking
		     * the first is sufficient.
		     *
		     * Report an unset param only if the user has
		     * explicitly given it some attribute (like export);
		     * otherwise, after "echo $FOO", we would report FOO...
		     */
		    if (!any_set && !(vp->flag & USERATTRIB))
			continue;
		    if (flag && (vp->flag & flag) == 0)
			continue;
		    for (; vp; vp = vp->u.array) {
			/* Ignore array elements that aren't set unless there
			 * are no set elements, in which case the first is
			 * reported on
			 */
			if ((vp->flag&ARRAY) && any_set && !(vp->flag & ISSET))
			    continue;
			/* no arguments */
			if (thing == 0 && flag == 0) {
			    /* at&t ksh prints things like export, integer,
			     * leftadj, zerofill, etc., but POSIX says must
			     * be suitable for re-entry...
			     */
			    shprintf("typeset ");
			    if ((vp->flag&INTEGER))
				shprintf("-i ");
			    if ((vp->flag&EXPORT))
				shprintf("-x ");
			    if ((vp->flag&RDONLY))
				shprintf("-r ");
			    if ((vp->flag&TRACE))
				shprintf("-t ");
			    if ((vp->flag&LJUST))
				shprintf("-L%d ", vp->u2.field);
			    if ((vp->flag&RJUST))
				shprintf("-R%d ", vp->u2.field);
			    if ((vp->flag&ZEROFIL))
				shprintf("-Z ");
			    if ((vp->flag&LCASEV))
				shprintf("-l ");
			    if ((vp->flag&UCASEV_AL))
				shprintf("-u ");
			    if ((vp->flag&INT_U))
				shprintf("-U ");
			    shprintf("%s\n", vp->name);
			    if (vp->flag&ARRAY)
				break;
			} else {
			    if (pflag)
				shprintf("%s ",
				    (flag & EXPORT) ?  "export" : "readonly");
			    if ((vp->flag&ARRAY) && any_set)
				shprintf("%s[%d]", vp->name, vp->index);
			    else
				shprintf("%s", vp->name);
			    if (thing == '-' && (vp->flag&ISSET)) {
				char *s = str_val(vp);

				shprintf("=");
				/* at&t ksh can't have justified integers.. */
				if ((vp->flag & (INTEGER|LJUST|RJUST))
								== INTEGER)
				    shprintf("%s", s);
				else
				    print_value_quoted(s);
			    }
			    shprintf(newline);
			}
			/* Only report first `element' of an array with
			 * no set elements.
			 */
			if (!any_set)
			    break;
		    }
a813 1
	    }
d831 1
a831 1
		  case 'd':
d834 1
a834 1
		  case 'p':
d837 1
a837 1
		  case 'r':
d840 1
a840 1
		  case 't':
d843 5
a847 3
		  case 'U': /* kludge for tracked alias initialization
			     * (don't do a path search, just make an entry)
			     */
d850 1
a850 1
		  case 'x':
d853 1
a853 1
		  case '?':
d859 2
a860 3
	if (!(builtin_opt.info & GI_MINUSMINUS) && *wp
	    && (wp[0][0] == '-' || wp[0][0] == '+') && wp[0][1] == '\0')
	{
d874 2
a875 2
			shprintf(
	    "alias: -r flag can only be used with -t and without arguments\n");
d934 2
a935 2
			newval = tflag ? search(alias, path, X_OK, (int *) 0)
					: val;
d964 1
a964 1
		  case 'a':
d967 1
a967 1
		  case 'd':
d970 1
a970 1
		  case 't':
d973 1
a973 1
		  case '?':
d1034 1
a1034 1
		  case 'l':
d1037 1
a1037 1
		  case 'p':
d1040 1
a1040 1
		  case 'n':
d1043 1
a1043 1
		  case 'z':	/* debugging: print zombies */
d1046 1
a1046 1
		  case '?':
d1102 3
a1104 3
			ki->num_width, i,
			ki->name_width, sigtraps[i].name,
			sigtraps[i].mess);
d1107 3
a1109 3
			ki->num_width, i,
			ki->name_width, sigtraps[i].signal,
			sigtraps[i].mess);
d1134 1
a1134 1
			  case 'l':
d1137 1
a1137 1
			  case 's':
d1140 1
a1140 1
						builtin_opt.optarg);
d1144 1
a1144 1
			  case '?':
d1151 2
a1152 3
"Usage: kill [ -s signame | -signum | -signame ] {pid|job}...\n\
       kill -l [exit_status]\n"
			);
d1184 2
a1185 2
				w = sigtraps[i].name ? strlen(sigtraps[i].name)
						     : ki.num_width;
d1194 2
a1195 2
				kill_fmt_entry, (void *) &ki,
				ki.num_width + ki.name_width + mess_width + 3, 1);
d1207 1
a1207 1
				p);
d1227 1
a1227 1
			GF_NONAME | (Flag(FPOSIX) ? 0 : GF_PLUSOPT));
d1276 5
a1280 6
	if (user_opt.optind > argc
	    || (user_opt.p != 0
		&& user_opt.p > strlen(wp[user_opt.optind - 1])))
	{
	      bi_errorf("arguments changed since last call");
	      return 1;
d1338 1
a1338 1
		  case 'l':
d1341 1
a1341 1
		  case 'm':
d1344 1
a1344 1
		  case '?':
@


1.25
log
@Introduce POSIX hex and octal (0x... and 0...) constants in arithmetic
expressions.  Work by Matthias Kilian, based on an old diff by myself.
Note: MAKEDEV should be updated. Tested by many, thanks.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.24 2004/12/22 17:14:34 millert Exp $	*/
d869 2
a870 2
			    "unalias", "-ta", (const char *) 0
			};
@


1.24
log
@Use stdbool.h instead of rolling our own bools.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.23 2004/12/20 11:34:26 otto Exp $	*/
d1015 1
a1015 1
			if (!evaluate(*wp, &val, KSH_RETURN_ERROR)) {
@


1.23
log
@Ansification plus some minor knf. No binary change on i386 and
sparc64, binary change in lex.o on macppc due to introduction of
dopprompt() prototype. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.22 2004/12/19 04:14:20 deraadt Exp $	*/
d681 1
a681 1
					     (fset&UCASEV_AL) ? TRUE : FALSE);
d1123 1
a1123 1
		if (!(t = gettrap(p + 1, TRUE))) {
d1137 1
a1137 1
				if (!(t = gettrap(builtin_opt.optarg, TRUE))) {
d1258 1
a1258 1
	if (!*var || *skip_varname(var, TRUE)) {
@


1.22
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.21 2004/12/18 21:25:44 millert Exp $	*/
d13 1
a13 2
c_cd(wp)
	char	**wp;
d157 1
a157 2
c_pwd(wp)
	char	**wp;
d197 1
a197 2
c_print(wp)
	char **wp;
d391 1
a391 2
c_whence(wp)
	char **wp;
d513 1
a513 2
c_command(wp)
	char **wp;
d523 1
a523 2
c_typeset(wp)
	char **wp;
d819 1
a819 2
c_alias(wp)
	char **wp;
d954 1
a954 2
c_unalias(wp)
	char **wp;
d1006 1
a1006 2
c_let(wp)
	char **wp;
d1024 1
a1024 2
c_jobs(wp)
	char **wp;
d1062 1
a1062 2
c_fgbg(wp)
	char **wp;
d1094 1
a1094 5
kill_fmt_entry(arg, i, buf, buflen)
	void *arg;
	int i;
	char *buf;
	int buflen;
d1114 1
a1114 2
c_kill(wp)
	char **wp;
d1223 1
a1223 2
getopts_reset(val)
	int val;
d1233 1
a1233 2
c_getopts(wp)
	char **wp;
d1332 1
a1332 2
c_bind(wp)
	char **wp;
@


1.21
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.20 2004/12/18 21:04:52 millert Exp $	*/
d543 2
a544 2
 	  case 'e':		/* export */
 		fset |= EXPORT;
d546 3
a548 3
 		break;
 	  case 'r':		/* readonly */
 		fset |= RDONLY;
d550 1
a550 1
 		break;
d554 4
a557 4
 	  case 't':		/* typeset */
 		local = 1;
 		break;
 	}
d823 1
a823 1
	
a887 1
	
d1394 1
a1394 1
 	{"*=export", c_typeset},
d1404 1
a1404 1
 	{"*=readonly", c_typeset},
@


1.20
log
@Get rid of #ifdef KSH since we don't care about building a V7 style sh and
the #ifdef KSH code is required to make a POSIX sh.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.19 2004/12/18 20:55:52 millert Exp $	*/
d297 1
a297 1
		register int c;
d965 2
a966 2
	register struct table *t = &aliases;
	register struct tbl *ap;
d1354 2
a1355 3
	int rv = 0, macro = 0, list = 0;
	register char *cp;
	int optc;
@


1.19
log
@Remove unused OS dependent #ifdef blocks, #defines and macro abstraction.
First step in making the ksh code easier to read.  From Matthias Kilian
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.18 2004/02/10 13:03:36 jmc Exp $	*/
a260 1
#ifdef KSH
a266 1
#endif /* KSH */
a352 1
#ifdef KSH
a362 1
#endif /* KSH */
a365 1
#ifdef KSH
a367 1
#endif /* KSH */
a370 1
#ifdef KSH
a372 1
#endif /* KSH */
a374 1
#ifdef KSH
a380 1
#endif /* KSH */
a385 1
#ifdef KSH
a387 1
#endif /* KSH */
a1013 1
#ifdef KSH
a1031 1
#endif /* KSH */
a1402 1
#ifdef KSH
a1403 1
#endif /* KSH */
@


1.18
log
@upper case id;
from Mathias K. Straede (PR 3680);
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.17 2003/10/22 07:40:38 jmc Exp $	*/
d8 1
a8 1
#include "ksh_stat.h"
a10 3
#ifdef __CYGWIN__
#include <sys/cygwin.h>
#endif /* __CYGWIN__ */
a106 1
#ifdef S_ISLNK
a109 1
#endif /* S_ISLNK */
d134 1
a134 8
	if (!ISABSPATH(Xstring(xs, xp))) {
#ifdef OS2
		/* simplify_path() doesn't know about os/2's drive contexts,
		 * so it can't set current_wd when changing to a:foo.
		 * Handle this by calling getcwd()...
		 */
		pwd = ksh_get_wd((char *) 0, 0);
#else /* OS2 */
a135 1
#endif /* OS2 */
a136 1
#ifdef S_ISLNK
a137 1
#endif /* S_ISLNK */
a141 4
#ifdef __CYGWIN__
		char ptmp[PATH];  /* larger than MAX_PATH */
		cygwin_conv_to_full_posix_path(pwd, ptmp);
#else /* __CYGWIN__ */
a142 1
#endif /* __CYGWIN__ */
a181 1
#ifdef S_ISLNK
d184 1
a184 4
#else /* S_ISLNK */
	p = current_wd[0] ? current_wd : (char *) 0;
#endif /* S_ISLNK */
	if (p && eaccess(p, R_OK) < 0)
a206 1
#define PO_FSLASH	BIT(5)  /* swap slash for backslash (for os2 ) */
a246 3
#if OS2
		const char *options = "Rnpfrsu,"; /* added f flag */
#else
a247 1
#endif
a257 5
#ifdef OS2
			  case 'f':
				flags |= PO_FSLASH;
				break;
#endif
a302 7
#ifdef OS2
			if ((flags & PO_FSLASH) && c == '\\')
				if (*s == '\\')
					*s++;
				else
					c = '/';
#endif /* OS2 */
d354 1
a354 1
		int UNINITIALIZED(opipe);
d1091 1
a1091 1
	int UNINITIALIZED(rv);
d1116 1
a1116 1
static char *kill_fmt_entry ARGS((void *arg, int i, char *buf, int buflen));
d1193 1
a1193 1
				if (n > 128 && n < 128 + SIGNALS)
d1195 1
a1195 1
				if (n > 0 && n < SIGNALS && sigtraps[n].name)
d1202 1
a1202 1
			for (i = 1; i < SIGNALS; i++, p = space)
d1211 1
a1211 1
			for (i = SIGNALS, ki.num_width = 1; i >= 10; i /= 10)
d1214 1
a1214 1
			for (i = 0; i < SIGNALS; i++) {
d1224 1
a1224 1
			print_columns(shl_stdout, SIGNALS - 1,
@


1.17
log
@typos from Jared Yanovich;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.16 2003/02/28 09:45:09 jmc Exp $	*/
d1278 1
a1278 1
			bi_errorf("%s: arguments must be jobs or process ids",
@


1.16
log
@typos; from Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.15 2002/06/09 05:47:27 todd Exp $	*/
d78 1
a78 1
		/* substitue arg1 for arg2 in current path.
d655 1
a655 1
			     * typset -p is the same as typeset (in pdksh);
@


1.15
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.14 2001/02/19 09:49:50 camield Exp $	*/
d364 1
a364 1
					 * leading 0).  Truely burnt.
d656 1
a656 1
			     * here for compatability with ksh93.
@


1.14
log
@bash-like 'double-tab' completion

- bind TAB (^I) to complete-list by default
- complete-list now lists 'ls style' not 'menu style'
- complete-list first completes; if that does not work, it lists
- fix a memleak in emacs.c, do_complete
- completion now works after '=' (dd), and ':' (ssh) and ` (backtick)
- a command can now start with a subdir from the current dir
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.13 2000/11/21 22:41:03 millert Exp $	*/
d338 1
a338 1
			if ((flags & PO_FSLASH) && c == '\\') 
d611 1
a611 1
 
d707 1
a707 1
		/* Take care of exclusions.  
d827 1
a827 1
			    if ((vp->flag&TRACE)) 
d829 1
a829 1
			    if ((vp->flag&LJUST)) 
d831 1
a831 1
			    if ((vp->flag&RJUST)) 
d833 1
a833 1
			    if ((vp->flag&ZEROFIL)) 
d835 1
a835 1
			    if ((vp->flag&LCASEV)) 
d837 1
a837 1
			    if ((vp->flag&UCASEV_AL)) 
d839 1
a839 1
			    if ((vp->flag&INT_U)) 
@


1.13
log
@Add missing break that broke 'kill -s SIGNAME', PR #1495
Fix from Hiroyuki.HORINOKUCHI@@nrj.ericsson.se
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.12 1999/06/15 01:18:33 millert Exp $	*/
d1267 1
a1267 1
				ki.num_width + ki.name_width + mess_width + 3);
@


1.12
log
@patches from pdksh 5.2.13.11
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.11 1999/01/10 17:55:01 millert Exp $	*/
d1214 1
@


1.11
log
@sync with pdksh-unstable-5.2.13.6
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.10 1999/01/08 20:24:57 millert Exp $	*/
d11 4
d136 2
a137 1
		setstr(oldpwd_s, current_wd); /* SETSTR no die, don't set */
d157 9
a165 2
		set_current_wd(pwd);
		setstr(pwd_s, pwd);	/* SETSTR no die, leave unchanged */
d1079 1
a1079 1
			if (!evaluate(*wp, &val, TRUE)) {
d1312 1
d1314 1
a1314 1
	struct tbl *vq;
d1380 5
d1386 1
a1386 1
		unset(global("OPTARG"), 0);
d1388 4
a1391 1
		setstr(global("OPTARG"), user_opt.optarg); /* SETSTR: no fail, cause exit code to be non-zero */
d1394 3
a1396 4
	if (vq->flag & RDONLY) {
		bi_errorf("%s is readonly", var);
		return 1;
	}
a1398 1
	setstr(vq, buf);	/* SETSTR: no fail, cause exit code to be !0 */
d1400 1
a1400 1
	return optc < 0 ? 1 : 0;
@


1.10
log
@bug fixes from pdksh-unstable-5.2.13.5; some of which we already had.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.9 1998/10/29 04:09:19 millert Exp $	*/
d128 3
a130 1
	/* Set OLDPWD */
d132 1
a132 1
		setstr(oldpwd_s, current_wd);
d153 1
a153 1
		setstr(pwd_s, pwd);
d1103 1
a1103 1
	if (!*wp)
d1106 1
a1106 1
	else
d1110 1
d1370 1
a1370 1
		setstr(global("OPTARG"), user_opt.optarg);
d1379 1
a1379 1
	setstr(vq, buf);
@


1.9
log
@Bug fixes from pdksh-unstable-5.2.13.4, including "official" versions of
some that we had already fixed locally.
 o typeset -f FUNC doesn't print follows command (and expression) substitutions.
 o when re-allocating memory, too much may be copied from old memory.
 o set -o printed some options sans names.
 o emacs mode: <esc>. in very fist command causes core dump.
 o pdksh dumps core after a cd command.
 o typeset -i reports on array elements that have no value
   (at&t ksh reports on array base name - no index).
 o ulimit -ctn unlimittttted kills shell (resource exceeded).
 o ". /dev/null" says access denied.
 o flag field in aliases incorrectly changed (all flags set instead of
   clearing ISSET) in exec.c(flushcom).
 o ${#array[*]} prints largest index instead of number of (set) elements
   in an array (ksh88 does the former).
 o sys_siglist[] doesn't always have NSIG non-null entries...
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.8 1998/06/25 19:01:44 millert Exp $	*/
d1180 1
a1180 1
		if (!(t = gettrap(p + 1))) {
d1194 1
a1194 1
				if (!(t = gettrap(builtin_opt.optarg))) {
@


1.8
log
@pdksh-5.2.13 + local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.7 1997/06/19 13:58:37 kstailey Exp $	*/
d604 1
a604 1
	 * does not allow the number to be specified as a seperate argument
d768 25
a792 1
		for (p = tsort(&l->vars); (vp = *p++); )
d794 3
a796 3
			/* Report an unset param only if the user has
			 * explicitly given it some attribute (like export);
			 * otherwise, after "echo $FOO", we would report FOO...
d798 1
a798 3
			if (!(vp->flag & ISSET) && !(vp->flag & USERATTRIB))
			    continue;
			if (flag && (vp->flag & flag) == 0)
d827 1
d829 1
a829 3
				shprintf("%s[%d]\n", vp->name, vp->index);
			    else
				shprintf("%s\n", vp->name);
d834 1
a834 1
			    if (vp->flag&ARRAY)
d851 5
d857 1
@


1.7
log
@back out
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.5 1996/11/21 07:59:27 downsj Exp $	*/
d574 1
a574 1
	const char *options = "L#R#UZ#fi#lrtux";	/* see comment below */
d612 1
a612 1
			flag |= LJUST;
d616 1
a616 1
			flag |= RJUST;
d624 1
a624 1
			flag |= INT_U;
d627 1
a627 1
			flag |= ZEROFIL;
d634 1
a634 1
			flag |= INTEGER;
d638 1
a638 1
			flag |= LCASEV;
d640 4
a643 1
		  case 'p': /* posix export/readonly -p flag */
d647 1
a647 1
			flag |= RDONLY;
d650 1
a650 1
			flag |= TRACE;
d653 1
a653 1
			flag |= UCASEV_AL;	/* upper case / autoload */
d656 1
a656 1
			flag |= EXPORT;
d693 13
a705 2
		/* Take care of exclusions */
		/* setting these attributes clears the others, unless they
a712 20
		fclr &= ~fset;	/* set wins */
		if ((fset & (ZEROFIL|LJUST)) == ZEROFIL) {
			fset |= RJUST;
			fclr &= ~RJUST;
		}
		if (fset & LCASEV)	/* LCASEV has priority */
			fclr |= UCASEV_AL;
		else if (fset & UCASEV_AL)
			fclr |= LCASEV;
		if (fset & LJUST)	/* LJUST has priority */
			fclr |= RJUST;
		else if (fset & RJUST)
			fclr |= LJUST;
		if ((fset | fclr) & INTEGER) {
			if (!(fset | fclr) & INT_U)
				fclr |= INT_U;
			if (!(fset | fclr) & INT_L)
				fclr |= INT_L;
		}
		fset &= ~fclr; /* in case of something like -LR */
d737 4
a740 1
						"function %s %T\n",
d758 3
a760 1
			fptreef(shl_stdout, 0, "function %s %T\n",
d806 1
a806 1
				shprintf("%s[%d]\n", vp->name,vp->index);
d841 2
a842 1
	int rv = 0, rflag = 0, tflag, Uflag = 0;
d846 3
a848 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "drtUx")) != EOF)
d853 3
d873 1
d876 7
d900 1
d906 7
a912 2
				shprintf("%s=", ap->name);
				print_value_quoted(ap->val.s);
d930 7
a936 2
				shprintf("%s=", ap->name);
				print_value_quoted(ap->val.s);
d961 5
a965 1
		ap->flag |= DEFINED|xflag;
a1250 3
static Getopt	user_opt;	/* parsing state for getopts builtin command */
static int	getopts_noset;	/* stop OPTIND assign from resetting state */

d1255 1
a1255 1
	if (!getopts_noset && val >= 1) {
d1258 1
a1258 1
		user_opt.optind = val;
d1334 1
a1334 3
		getopts_noset = 1;
		setint(global("OPTIND"), (long) user_opt.optind);
		getopts_noset = 0;
@


1.6
log
@(foo *)0 -> NULL
@
text
@d79 1
a79 1
		if ((cp = strstr(current_wd, wp[0])) == NULL) {
d98 1
a98 1
	/* xp will have a bogus value after make_path() - set it to NULL
d101 1
a101 1
	xp = NULL;
d115 1
a115 1
	} while (rval < 0 && cdpath != NULL);
d138 1
a138 1
		pwd = ksh_get_wd(NULL, 0);
d140 1
a140 1
		pwd = NULL;
d190 1
a190 1
			  : NULL;
d192 1
a192 1
	p = current_wd[0] ? current_wd : NULL;
d195 1
a195 1
		p = NULL;
d197 1
a197 1
		p = ksh_get_wd(NULL, 0);
d598 1
a598 1
	fieldstr = basestr = NULL;
d875 1
a875 1
			    "unalias", "-ta", NULL
d929 1
a929 1
			newval = tflag ? search(alias, path, X_OK, NULL)
d1006 1
a1006 1
	if (wp[1] == NULL) /* at&t ksh does this */
d1047 1
a1047 1
		if (j_jobs(NULL, flag, nflag))
d1118 1
a1118 1
	Trap *t = NULL;
d1268 1
a1268 1
	if (e->loc->next == NULL) {
d1273 1
a1273 1
	if (*wp == NULL)
d1289 1
a1289 1
	user_opt.optarg = NULL;
d1314 1
a1314 1
	if (user_opt.optarg == NULL)
d1354 1
a1354 1
		rv = x_bind(NULL, NULL, 0, list);
@


1.5
log
@Update to 5.2.12.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.4 1996/10/01 02:05:32 downsj Exp $	*/
d79 1
a79 1
		if ((cp = strstr(current_wd, wp[0])) == (char *) 0) {
d98 1
a98 1
	/* xp will have a bogus value after make_path() - set it to 0
d101 1
a101 1
	xp = (char *) 0;
d115 1
a115 1
	} while (rval < 0 && cdpath != (char *) 0);
d138 1
a138 1
		pwd = ksh_get_wd((char *) 0, 0);
d140 1
a140 1
		pwd = (char *) 0;
d190 1
a190 1
			  : (char *) 0;
d192 1
a192 1
	p = current_wd[0] ? current_wd : (char *) 0;
d195 1
a195 1
		p = (char *) 0;
d197 1
a197 1
		p = ksh_get_wd((char *) 0, 0);
d598 1
a598 1
	fieldstr = basestr = (char *) 0;
d875 1
a875 1
			    "unalias", "-ta", (const char *) 0
d929 1
a929 1
			newval = tflag ? search(alias, path, X_OK, (int *) 0)
d1006 1
a1006 1
	if (wp[1] == (char *) 0) /* at&t ksh does this */
d1047 1
a1047 1
		if (j_jobs((char *) 0, flag, nflag))
d1118 1
a1118 1
	Trap *t = (Trap *) 0;
d1268 1
a1268 1
	if (e->loc->next == (struct block *) 0) {
d1273 1
a1273 1
	if (*wp == (char *) 0)
d1289 1
a1289 1
	user_opt.optarg = (char *) 0;
d1314 1
a1314 1
	if (user_opt.optarg == (char *) 0)
d1354 1
a1354 1
		rv = x_bind((char*)NULL, (char*)NULL, 0, list);
@


1.4
log
@Integrate pdksh 5.2.9.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.3 1996/08/25 12:37:55 downsj Exp $	*/
d771 6
@


1.3
log
@Fix problems with compiling without KSH defined, add NOEDIT override.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.2 1996/08/19 20:08:45 downsj Exp $	*/
d397 1
d400 1
d404 1
d407 1
d992 1
d1011 1
d1379 1
d1381 1
@


1.2
log
@update to pdksh-5.2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.1.1.1 1996/08/14 06:19:10 downsj Exp $	*/
d381 1
a382 1
		int UNINITIALIZED(opipe);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d283 1
a283 1
				if ((fd = get_coproc_fd(W_OK, &emsg)) < 0) {
d381 1
a383 1
#ifdef KSH
d407 6
a412 2
				if (errno == EPIPE)
					coproc_write_close(fd);
d419 1
d422 1
d568 1
a568 1
	int fset = 0, fclr = 0;
d573 2
a574 1
	int optc, flag;
a766 2
			if (!(vp->flag&ISSET))
			    continue;
d785 1
a785 1
				shprintf("-L%d ", vp->field);
d787 1
a787 1
				shprintf("-R%d ", vp->field);
d808 1
a808 1
			    if (thing == '-') {
d832 2
a833 1
	int rv = 0, rflag = 0, tflag, Uflag = 0, xflag = 0;
d919 2
a920 1
			newval = tflag ? search(alias, path, X_OK) : val;
a1290 6
	vq = global(var);
	if (vq->flag & RDONLY)
		bi_errorf("%s is readonly", var);
	if (Flag(FEXPORT))
		typeset(var, EXPORT, 0, 0, 0);
	setstr(vq, buf);
d1292 9
a1300 3
	getopts_noset = 1;
	setint(global("OPTIND"), (long) user_opt.optind);
	getopts_noset = 0;
d1307 3
a1309 1
	if (optc < 0)
d1311 4
d1316 1
a1316 1
	return 0;
@


1.1.1.1
log
@Import pdksh 5.2.7.
@
text
@@
