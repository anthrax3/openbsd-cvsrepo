head	1.48;
access;
symbols
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.46.0.2
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.38.0.6
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.37.0.8
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.6
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.4
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.35.0.4
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.34.0.4
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.29.0.6
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.4
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.28.0.4
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.17.0.6
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.14.0.4
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.4
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2016.08.16.16.13.32;	author krw;	state Exp;
branches;
next	1.47;
commitid	8Y4juH3XcPsG1zH4;

1.47
date	2016.08.16.16.09.24;	author krw;	state Exp;
branches;
next	1.46;
commitid	GvVhwA30AwBzznd8;

1.46
date	2016.03.28.11.25.35;	author chl;	state Exp;
branches;
next	1.45;
commitid	ZOhLgJPM61GWcYQI;

1.45
date	2016.03.17.05.27.10;	author bentley;	state Exp;
branches;
next	1.44;
commitid	0afdJPZPXUfvItJV;

1.44
date	2015.12.01.18.36.13;	author schwarze;	state Exp;
branches;
next	1.43;
commitid	JYEMpgNqkF0UVWhk;

1.43
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	sbrB3Q5CNxcwZpfU;

1.42
date	2015.10.04.16.00.43;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	GLApIoI8Hi9X9cYy;

1.41
date	2015.06.25.02.04.07;	author uebayasi;	state Exp;
branches;
next	1.40;
commitid	lJr85pywqGCq0vnE;

1.40
date	2015.04.18.18.28.36;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	6b2lLILbgCR1fvia;

1.39
date	2014.03.31.20.54.37;	author sobrado;	state Exp;
branches;
next	1.38;

1.38
date	2013.05.30.16.34.32;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2011.03.04.21.03.19;	author okan;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.12.20.16.29;	author sobrado;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2009.05.06.18.47.32;	author todd;	state Exp;
branches;
next	1.33;

1.33
date	2008.12.30.15.37.30;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2008.12.29.14.49.27;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2008.12.24.20.57.21;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2008.09.04.15.44.41;	author jmc;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.07.18.39.28;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2006.04.13.03.14.18;	author dhill;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.30.00.57.25;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.29.20.33.01;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.25.20.37.45;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.15.17.47.17;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.10.00.22.08;	author jaredy;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.02.07.31.06;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.06.19.09.09;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.11.23.42.12;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.23.32.08;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.02.19.43.52;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.12.01.05.15;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.16.21.27.07;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.09.00.37.53;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.19.19.27.36;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	99.05.01.23.54.47;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.02.24.16.48.02;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	99.02.23.23.54.17;	author art;	state Exp;
branches;
next	1.10;

1.10
date	99.02.20.18.59.25;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.08.07.19.45.06;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.09.18.07.58.41;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.04.01.22.59.38;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.03.22.36.08;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.12.18.03;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.08.02.12.40.57;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.20.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.17.18.49.22;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.14;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.14;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Nuke some erroneous leading whitespace.
@
text
@/*	$OpenBSD: ls.c,v 1.47 2016/08/16 16:09:24 krw Exp $	*/
/*	$NetBSD: ls.c,v 1.18 1996/07/09 09:16:29 mycroft Exp $	*/

/*
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Michael Fischbein.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>

#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <fts.h>
#include <grp.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <locale.h>
#include <util.h>

#include "ls.h"
#include "extern.h"

static void	 display(FTSENT *, FTSENT *);
static int	 mastercmp(const FTSENT **, const FTSENT **);
static void	 traverse(int, char **, int);

static void (*printfcn)(DISPLAY *);
static int (*sortfcn)(const FTSENT *, const FTSENT *);

#define	BY_NAME 0
#define	BY_SIZE 1
#define	BY_TIME	2

long blocksize;			/* block size units */
int termwidth;			/* default terminal width */
int sortkey = BY_NAME;

/* flags */
int f_accesstime;		/* use time of last access */
int f_column;			/* columnated format */
int f_columnacross;		/* columnated format, sorted across */
int f_flags;			/* show flags associated with a file */
int f_grouponly;		/* long listing format without owner */
int f_humanval;			/* show human-readable file sizes */
int f_inode;			/* print inode */
int f_listdir;			/* list actual directory, not contents */
int f_listdot;			/* list files beginning with . */
int f_longform;			/* long listing format */
int f_nonprint;			/* show unprintables as ? */
int f_nosort;			/* don't sort output */
int f_numericonly;		/* don't expand uid to symbolic name */
int f_recursive;		/* ls subdirectories also */
int f_reversesort;		/* reverse whatever sort is used */
int f_sectime;			/* print the real time for all files */
int f_singlecol;		/* use single column output */
int f_size;			/* list size in short listing */
int f_statustime;		/* use time of last mode change */
int f_stream;			/* stream format */
int f_type;			/* add type character for non-regular files */
int f_typedir;			/* add type character for directories */

int rval;

int
ls_main(int argc, char *argv[])
{
	static char dot[] = ".", *dotav[] = { dot, NULL };
	struct winsize win;
	int ch, fts_options, notused;
	int kflag = 0;
	char *p;

#ifndef SMALL
	setlocale(LC_CTYPE, "");
#endif

	/* Terminal defaults to -Cq, non-terminal defaults to -1. */
	if (isatty(STDOUT_FILENO)) {
		f_column = f_nonprint = 1;
	} else {
		f_singlecol = 1;
	}

	termwidth = 0;
	if ((p = getenv("COLUMNS")) != NULL)
		termwidth = strtonum(p, 1, INT_MAX, NULL);
	if (termwidth == 0 && ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) == 0 &&
	    win.ws_col > 0)
		termwidth = win.ws_col;
	if (termwidth == 0)
		termwidth = 80;

	if (pledge("stdio rpath getpw", NULL) == -1)
		err(1, "pledge");

	/* Root is -A automatically. */
	if (!getuid())
		f_listdot = 1;

	fts_options = FTS_PHYSICAL;
	while ((ch = getopt(argc, argv, "1ACFHLRSTacdfghiklmnopqrstux")) != -1) {
		switch (ch) {
		/*
		 * The -1, -C and -l, -m, -n and -x options all override each
		 * other so shell aliasing works right.
		 */
		case '1':
			f_singlecol = 1;
			f_column = f_columnacross = f_longform = 0;
			f_numericonly = f_stream = 0;
			break;
		case 'C':
			f_column = 1;
			f_columnacross = f_longform = f_numericonly = 0;
			f_singlecol = f_stream = 0;
			break;
		case 'g':
			f_longform = 1;
			if (f_grouponly != -1)
				f_grouponly = 1;
			f_column = f_columnacross = f_singlecol = f_stream = 0;
			break;
		case 'l':
			f_longform = 1;
			f_grouponly = -1;	/* -l always overrides -g */
			f_column = f_columnacross = f_singlecol = f_stream = 0;
			break;
		case 'm':
			f_stream = 1;
			f_column = f_columnacross = f_longform = 0;
			f_numericonly = f_singlecol = 0;
			break;
		case 'x':
			f_columnacross = 1;
			f_column = f_longform = f_numericonly = 0;
			f_singlecol = f_stream = 0;
			break;
		case 'n':
			f_longform = 1;
			f_numericonly = 1;
			f_column = f_columnacross = f_singlecol = f_stream = 0;
			break;
		/* The -c and -u options override each other. */
		case 'c':
			f_statustime = 1;
			f_accesstime = 0;
			break;
		case 'u':
			f_accesstime = 1;
			f_statustime = 0;
			break;
		case 'F':
			f_type = 1;
			break;
		case 'H':
			fts_options |= FTS_COMFOLLOW;
			break;
		case 'L':
			fts_options &= ~FTS_PHYSICAL;
			fts_options |= FTS_LOGICAL;
			break;
		case 'R':
			f_recursive = 1;
			break;
		case 'f':
			f_nosort = 1;
			/* FALLTHROUGH */
		case 'a':
			fts_options |= FTS_SEEDOT;
			/* FALLTHROUGH */
		case 'A':
			f_listdot = 1;
			break;
		/* The -d option turns off the -R option. */
		case 'd':
			f_listdir = 1;
			f_recursive = 0;
			break;
		case 'h':
			f_humanval = 1;
			break;
		case 'i':
			f_inode = 1;
			break;
		case 'k':
			blocksize = 1024;
			kflag = 1;
			break;
		case 'o':
			f_flags = 1;
			break;
		case 'p':
			f_typedir = 1;
			break;
		case 'q':
			f_nonprint = 1;
			break;
		case 'r':
			f_reversesort = 1;
			break;
		case 'S':
			sortkey = BY_SIZE;
			break;
		case 's':
			f_size = 1;
			break;
		case 'T':
			f_sectime = 1;
			break;
		case 't':
			sortkey = BY_TIME;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	/*
	 * If both -g and -l options, let -l take precedence.
	 * This preserves compatibility with the historic BSD ls -lg.
	 */
	if (f_grouponly == -1)
		f_grouponly = 0;

	/*
	 * If not -F, -i, -l, -p, -S, -s or -t options, don't require stat
	 * information.
	 */
	if (!f_longform && !f_inode && !f_size && !f_type && !f_typedir &&
	    sortkey == BY_NAME)
		fts_options |= FTS_NOSTAT;

	/*
	 * If not -F, -d or -l options, follow any symbolic links listed on
	 * the command line.
	 */
	if (!f_longform && !f_listdir && !f_type)
		fts_options |= FTS_COMFOLLOW;

	/* If -l or -s, figure out block size. */
	if (f_longform || f_size) {
		if (!kflag)
			(void)getbsize(&notused, &blocksize);
		blocksize /= 512;
	}

	/* Select a sort function. */
	if (f_reversesort) {
		switch (sortkey) {
		case BY_NAME:
			sortfcn = revnamecmp;
			break;
		case BY_SIZE:
			sortfcn = revsizecmp;
			break;
		case BY_TIME:
			if (f_accesstime)
				sortfcn = revacccmp;
			else if (f_statustime)
				sortfcn = revstatcmp;
			else /* Use modification time. */
				sortfcn = revmodcmp;
			break;
		}
	} else {
		switch (sortkey) {
		case BY_NAME:
			sortfcn = namecmp;
			break;
		case BY_SIZE:
			sortfcn = sizecmp;
			break;
		case BY_TIME:
			if (f_accesstime)
				sortfcn = acccmp;
			else if (f_statustime)
				sortfcn = statcmp;
			else /* Use modification time. */
				sortfcn = modcmp;
			break;
		}
	}

	/* Select a print function. */
	if (f_singlecol)
		printfcn = printscol;
	else if (f_columnacross)
		printfcn = printacol;
	else if (f_longform)
		printfcn = printlong;
	else if (f_stream)
		printfcn = printstream;
	else
		printfcn = printcol;

	if (argc)
		traverse(argc, argv, fts_options);
	else
		traverse(1, dotav, fts_options);
	return (rval);
}

static int output;			/* If anything output. */

/*
 * Traverse() walks the logical directory structure specified by the argv list
 * in the order specified by the mastercmp() comparison function.  During the
 * traversal it passes linked lists of structures to display() which represent
 * a superset (may be exact set) of the files to be displayed.
 */
static void
traverse(int argc, char *argv[], int options)
{
	FTS *ftsp;
	FTSENT *p, *chp;
	int ch_options, saved_errno;

	if ((ftsp =
	    fts_open(argv, options, f_nosort ? NULL : mastercmp)) == NULL)
		err(1, NULL);

	display(NULL, fts_children(ftsp, 0));
	if (f_listdir)
		return;

	/*
	 * If not recursing down this tree and don't need stat info, just get
	 * the names.
	 */
	ch_options = !f_recursive && options & FTS_NOSTAT ? FTS_NAMEONLY : 0;

	while ((p = fts_read(ftsp)) != NULL)
		switch (p->fts_info) {
		case FTS_D:
			if (p->fts_name[0] == '.' &&
			    p->fts_level != FTS_ROOTLEVEL && !f_listdot)
				break;

			/*
			 * If already output something, put out a newline as
			 * a separator.  If multiple arguments, precede each
			 * directory with its name.
			 */
			if (output)
				(void)printf("\n%s:\n", p->fts_path);
			else if (argc > 1) {
				(void)printf("%s:\n", p->fts_path);
				output = 1;
			}

			chp = fts_children(ftsp, ch_options);
			saved_errno = errno;
			display(p, chp);

			/*
			 * On fts_children() returning error do recurse to see
			 * the error.
			 */
			if (!f_recursive && !(chp == NULL && saved_errno != 0))
				(void)fts_set(ftsp, p, FTS_SKIP);
			break;
		case FTS_DC:
			warnx("%s: directory causes a cycle", p->fts_name);
			break;
		case FTS_DNR:
		case FTS_ERR:
			warnx("%s: %s", p->fts_name[0] == '\0' ? p->fts_path :
			    p->fts_name, strerror(p->fts_errno));
			rval = 1;
			break;
		}
	if (errno)
		err(1, "fts_read");

	fts_close(ftsp);
}

/*
 * Display() takes a linked list of FTSENT structures and passes the list
 * along with any other necessary information to the print function.  P
 * points to the parent directory of the display list.
 */
static void
display(FTSENT *p, FTSENT *list)
{
	struct stat *sp;
	DISPLAY d;
	FTSENT *cur;
	NAMES *np;
	off_t maxsize;
	nlink_t maxnlink;
	unsigned long long btotal;
	blkcnt_t maxblock;
	ino_t maxinode;
	int bcfile, flen, glen, ulen, maxflags, maxgroup, maxuser, maxlen;
	int entries, needstats;
	int width;
	char *user, *group, buf[21];	/* 64 bits == 20 digits */
	char nuser[12], ngroup[12];
	char *flags = NULL;

	/*
	 * If list is NULL there are two possibilities: that the parent
	 * directory p has no children, or that fts_children() returned an
	 * error.  We ignore the error case since it will be replicated
	 * on the next call to fts_read() on the post-order visit to the
	 * directory p, and will be signalled in traverse().
	 */
	if (list == NULL)
		return;

	needstats = f_inode || f_longform || f_size;
	flen = 0;
	btotal = maxblock = maxinode = maxlen = maxnlink = 0;
	bcfile = 0;
	maxuser = maxgroup = maxflags = 0;
	maxsize = 0;
	for (cur = list, entries = 0; cur != NULL; cur = cur->fts_link) {
		if (cur->fts_info == FTS_ERR || cur->fts_info == FTS_NS) {
			warnx("%s: %s",
			    cur->fts_name, strerror(cur->fts_errno));
			cur->fts_number = NO_PRINT;
			rval = 1;
			continue;
		}

		/*
		 * P is NULL if list is the argv list, to which different rules
		 * apply.
		 */
		if (p == NULL) {
			/* Directories will be displayed later. */
			if (cur->fts_info == FTS_D && !f_listdir) {
				cur->fts_number = NO_PRINT;
				continue;
			}
		} else {
			/* Only display dot file if -a/-A set. */
			if (cur->fts_name[0] == '.' && !f_listdot) {
				cur->fts_number = NO_PRINT;
				continue;
			}
		}
		if ((width = mbsprint(cur->fts_name, 0)) > maxlen)
			maxlen = width;
		if (needstats) {
			sp = cur->fts_statp;
			if (sp->st_blocks > maxblock)
				maxblock = sp->st_blocks;
			if (sp->st_ino > maxinode)
				maxinode = sp->st_ino;
			if (sp->st_nlink > maxnlink)
				maxnlink = sp->st_nlink;
			if (sp->st_size > maxsize)
				maxsize = sp->st_size;

			btotal += sp->st_blocks;
			if (f_longform) {
				if (f_numericonly) {
					snprintf(nuser, 12, "%u", sp->st_uid);
					snprintf(ngroup, 12, "%u", sp->st_gid);
					user = nuser;
					group = ngroup;
				} else {
					user = user_from_uid(sp->st_uid, 0);
					group = group_from_gid(sp->st_gid, 0);
				}
				if ((ulen = strlen(user)) > maxuser)
					maxuser = ulen;
				if ((glen = strlen(group)) > maxgroup)
					maxgroup = glen;
				if (f_flags) {
					flags = fflagstostr(sp->st_flags);
					if (*flags == '\0')
						flags = "-";
					if ((flen = strlen(flags)) > maxflags)
						maxflags = flen;
				} else
					flen = 0;

				if ((np = malloc(sizeof(NAMES) +
				    ulen + 1 + glen + 1 + flen + 1)) == NULL)
					err(1, NULL);

				np->user = &np->data[0];
				(void)strlcpy(np->user, user, ulen + 1);
				np->group = &np->data[ulen + 1];
				(void)strlcpy(np->group, group, glen + 1);

				if (S_ISCHR(sp->st_mode) ||
				    S_ISBLK(sp->st_mode))
					bcfile = 1;

				if (f_flags) {
					np->flags = &np->data[ulen + 1 + glen + 1];
					(void)strlcpy(np->flags, flags, flen + 1);
					if (*flags != '-')
						free(flags);
				}
				cur->fts_pointer = np;
			}
		}
		++entries;
	}

	if (!entries)
		return;

	d.list = list;
	d.entries = entries;
	d.maxlen = maxlen;
	if (needstats) {
		d.bcfile = bcfile;
		d.btotal = btotal;
		(void)snprintf(buf, sizeof(buf), "%llu",
		   (unsigned long long)maxblock);
		d.s_block = strlen(buf);
		d.s_flags = maxflags;
		d.s_group = maxgroup;
		(void)snprintf(buf, sizeof(buf), "%llu",
		    (unsigned long long)maxinode);
		d.s_inode = strlen(buf);
		(void)snprintf(buf, sizeof(buf), "%lu",
		    (unsigned long)maxnlink);
		d.s_nlink = strlen(buf);
		if (!f_humanval) {
			(void)snprintf(buf, sizeof(buf), "%lld",
				(long long) maxsize);
			d.s_size = strlen(buf);
		} else
			d.s_size = FMT_SCALED_STRSIZE-2; /* no - or '\0' */
		d.s_user = maxuser;
	}

	printfcn(&d);
	output = 1;

	if (f_longform)
		for (cur = list; cur != NULL; cur = cur->fts_link)
			free(cur->fts_pointer);
}

/*
 * Ordering for mastercmp:
 * If ordering the argv (fts_level = FTS_ROOTLEVEL) return non-directories
 * as larger than directories.  Within either group, use the sort function.
 * All other levels use the sort function.  Error entries remain unsorted.
 */
static int
mastercmp(const FTSENT **a, const FTSENT **b)
{
	int a_info, b_info;

	a_info = (*a)->fts_info;
	if (a_info == FTS_ERR)
		return (0);
	b_info = (*b)->fts_info;
	if (b_info == FTS_ERR)
		return (0);

	if (a_info == FTS_NS || b_info == FTS_NS) {
		if (b_info != FTS_NS)
			return (1);
		else if (a_info != FTS_NS)
			return (-1);
		else
			return (namecmp(*a, *b));
	}

	if (a_info != b_info &&
	    (*a)->fts_level == FTS_ROOTLEVEL && !f_listdir) {
		if (a_info == FTS_D)
			return (1);
		if (b_info == FTS_D)
			return (-1);
	}
	return (sortfcn(*a, *b));
}
@


1.47
log
@Bring types of variables used with struct stat into the modern world.

Replace a couple of u_long paramaters with int as they were only passed int
values and the function re-cast them to (int) anyway. Weird.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.46 2016/03/28 11:25:35 chl Exp $	*/
d532 1
a532 1
				  	(void)strlcpy(np->flags, flags, flen + 1);
@


1.46
log
@remove unused variable

ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.45 2016/03/17 05:27:10 bentley Exp $	*/
d427 3
a429 2
	u_long maxlen, maxnlink;
	unsigned long long btotal, maxblock;
d431 1
a431 1
	int bcfile, flen, glen, ulen, maxflags, maxgroup, maxuser;
d551 2
a552 1
		(void)snprintf(buf, sizeof(buf), "%llu", maxblock);
d559 2
a560 1
		(void)snprintf(buf, sizeof(buf), "%lu", maxnlink);
@


1.45
log
@Switch (non-curses, non-ksh) programs that use COLUMNS to a single idiom.

Previously behaviors were all over the map. This changes them to
use COLUMNS first, and either terminal width or a hardcoded value
(typically 80) as appropriate.

ok deraadt@@; man bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.44 2015/12/01 18:36:13 schwarze Exp $	*/
d104 1
a104 1
	int kflag = 0, width = 0;
@


1.44
log
@Support UTF-8: use wcwidth(3) for column adjustment and replace
non-printable Unicode codepoints and invalid bytes with ASCII
question marks.  No change for the SMALL version.

Using ideas developed by tedu@@, phessler@@, bentley@@ and feedback from many.
OK yasuoka@@ czarkoff@@ sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.43 2015/10/09 01:37:06 deraadt Exp $	*/
d69 1
a69 1
int termwidth = 80;		/* default terminal width */
a112 8
		if ((p = getenv("COLUMNS")) != NULL)
			width = strtonum(p, 1, INT_MAX, NULL);
		if (width == 0 &&
		    ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) == 0 &&
		    win.ws_col > 0)
			width = win.ws_col;
		if (width)
			termwidth = width;
a115 5
		/* retrieve environment variable, in case of explicit -C */
		if ((p = getenv("COLUMNS")) != NULL)
			width = strtonum(p, 0, INT_MAX, NULL);
		if (width)
			termwidth = width;
d117 9
@


1.43
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.42 2015/10/04 16:00:43 deraadt Exp $	*/
d51 1
d107 4
d436 1
d483 2
a484 2
		if (cur->fts_namelen > maxlen)
			maxlen = cur->fts_namelen;
@


1.42
log
@ls can use tame "stdio rpath getpw".  It does uid/gid lookups, using
the 4.4bsd libc caching varients called user_from_uid/group_from_uid,
which are backed by getpw*/getgr* type functions.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.41 2015/06/25 02:04:07 uebayasi Exp $	*/
d126 2
a127 2
	if (tame("stdio rpath getpw", NULL) == -1)
		err(1, "tame");
@


1.41
log
@Put fts_close() where missing.

Not bugs in short-lived commands that call exit() -> _exit() immediately,
but for idempotency.

Originally found in ls(1) by Valgrind.  Changes for other commands are
from deraadt@@.  Reviewed by me, tested in snapshots.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d125 3
@


1.40
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.39 2014/03/31 20:54:37 sobrado Exp $	*/
d406 2
@


1.39
log
@restore the traditional behavior of -f implying -a; apparently Keith Bostic
forgot to restore it when the -f flag was put back on 2nd of September 1989,
after being removed on 16th of August as a consequence of issues getting it
working over NFS, so deviation from traditional UNIX behavior in all BSDs
looks like an historical accident; as a side effect, this change accommodates
behavior of this option to IEEE Std 1003.1-2008 (``POSIX.1'').

joint work with jmc@@ (who found the inaccuracy in our implementation),
schwarze@@ (who provided a detailed tracking of historical facts) and millert@@

ok millert@@, schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.38 2013/05/30 16:34:32 guenther Exp $	*/
d50 1
d103 1
a103 1
	int kflag = 0;
d109 3
a111 2
			termwidth = atoi(p);
		else if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) == 0 &&
d113 3
a115 1
			termwidth = win.ws_col;
d121 3
a123 1
			termwidth = atoi(p);
@


1.38
log
@Fix column padding of inode numbers and block counts >2^32, as well as
display of directory block totals >2^32

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.37 2011/03/04 21:03:19 okan Exp $	*/
d189 3
a201 3
			break;
		case 'f':
			f_nosort = 1;
@


1.37
log
@add support for the (POSIX) -H flag

feedback and ok millert@@, sobrado@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.36 2010/09/12 20:16:29 sobrado Exp $	*/
d415 3
a417 1
	u_long btotal, maxblock, maxinode, maxlen, maxnlink;
d537 1
a537 1
		(void)snprintf(buf, sizeof(buf), "%lu", maxblock);
d541 2
a542 1
		(void)snprintf(buf, sizeof(buf), "%lu", maxinode);
@


1.36
log
@remove trailing spaces and tabs from source code; no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.35 2009/10/27 23:59:21 deraadt Exp $	*/
d125 1
a125 1
	while ((ch = getopt(argc, argv, "1ACFLRSTacdfghiklmnopqrstux")) != -1) {
d178 3
@


1.35
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.34 2009/05/06 18:47:32 todd Exp $	*/
d541 1
a541 1
			(void)snprintf(buf, sizeof(buf), "%lld", 
@


1.34
log
@do not ignore COLUMNS in -C mode, even if !isatty(STDOUT_FILENO)
from FreeBSD
ok millert@@, posix checked by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.33 2008/12/30 15:37:30 otto Exp $	*/
a34 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)ls.c	8.7 (Berkeley) 8/5/94";
#else
static char rcsid[] = "$OpenBSD: ls.c,v 1.33 2008/12/30 15:37:30 otto Exp $";
#endif
#endif /* not lint */
@


1.33
log
@add a comment explaining the rather obscure decision when to recurse
or not; ok millert@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.32 2008/12/29 14:49:27 otto Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.32 2008/12/29 14:49:27 otto Exp $";
d127 1
a127 1
	} else
d129 4
@


1.32
log
@fix previous; e.g. ls /var/spool/mqueue as an oridinary user. ok
millert@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.31 2008/12/24 20:57:21 otto Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.31 2008/12/24 20:57:21 otto Exp $";
d388 4
@


1.31
log
@Kill a race condition which occurs when listing a directory containing
an empty dir non-recursively. By not setting FTS_SKIP on the empty
subdir, a next iteration of the fts_read loop recurses into the
subdir, which might not be empty any more.  Report by jacekm@@,
troublespot identified by pedro@@; ok pedro@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.30 2008/09/04 15:44:41 jmc Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.30 2008/09/04 15:44:41 jmc Exp $";
d349 1
a349 1
	int ch_options;
d385 1
d388 1
a388 1
			if (!f_recursive)
@


1.30
log
@- make -ln and -nl combinations behave identically. currently -l overrides -n.
behaviour now similar to netbsd/freebsd/solaris.

- make -gn and -ng combinations behave identically: long listing, numeric
group ID, no user ID. currently -g overrides -n. behaviour now similar to
netbsd/solaris.

- allow -m and -x to override -1Cgln (and each other) if specified last.
currently -m and -x can be overriden even if they are specified last.
behaviour now similar to netbsd/freebsd. fixes PR 5785 from
Jacek Masiulaniec.

- update man page to reflect reality.

ls.c diff based on Jacek Masiulaniec's diff from PR 5785, and extended by
sobrado. this work is really a joint effort from sobrado and myself.
i don't know about igor, but this particular diff has nearly killed me...

ok millert otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.29 2007/05/07 18:39:28 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.29 2007/05/07 18:39:28 millert Exp $";
d387 1
a387 1
			if (!f_recursive && chp != NULL)
@


1.29
log
@Change the -g flag from a no-op to be POSIX conforming.  We allow the
-l flag to override -g regardless of its position on the command line
for backwards compat with 4.3BSD.  From NetBSD.
OK jmc@@, tom@@, sobrado@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.28 2006/04/13 03:14:18 dhill Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.28 2006/04/13 03:14:18 dhill Exp $";
d138 1
a138 1
		 * The -1, -C and -l, -m and -x options all override each
d143 2
a144 1
			f_column = f_columnacross = f_longform = f_stream = 0;
d148 2
a149 1
			f_longform = f_columnacross = f_singlecol = f_stream = 0;
a154 1
			f_numericonly = 0;
a159 1
			f_numericonly = 0;
d164 2
a165 2
			f_column = f_columnacross = f_singlecol = 0;
			f_singlecol = 0;
d169 2
a170 1
			f_column = f_longform = f_singlecol = f_stream = 0;
d175 1
a175 1
			f_column = f_singlecol = 0;
@


1.28
log
@Change maxsize to type off_t.
Add a cast for portability's sake.

"Right..." @@deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.27 2005/11/30 00:57:25 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.27 2005/11/30 00:57:25 deraadt Exp $";
d89 1
d149 7
d158 1
a208 2
		case 'g':		/* Compatibility with 4.3BSD. */
			break;
d249 7
@


1.27
log
@another unused variable found by lint
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.26 2005/11/29 20:33:01 otto Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.26 2005/11/29 20:33:01 otto Exp $";
d401 1
a401 1
	u_quad_t maxsize;
d531 2
a532 1
			(void)snprintf(buf, sizeof(buf), "%qu", maxsize);
@


1.26
log
@kill unused var found by lint. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.25 2005/11/25 20:37:45 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.25 2005/11/25 20:37:45 deraadt Exp $";
a103 1
int f_dirname;			/* if precede with directory name */
@


1.25
log
@do not exit from ls_main() but return; spotted by lint
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.24 2005/06/15 17:47:17 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.24 2005/06/15 17:47:17 millert Exp $";
a93 1
int f_newline;			/* if precede with newline */
@


1.24
log
@remove whiteout support
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.23 2005/03/10 00:22:08 jaredy Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.23 2005/03/10 00:22:08 jaredy Exp $";
d320 1
a320 1
	exit(rval);
@


1.23
log
@use fts_path if fts_name is not available, tweak and ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.22 2004/04/02 07:31:06 otto Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.22 2004/04/02 07:31:06 otto Exp $";
a107 1
int f_whiteout;			/* show whiteout entries */
d136 1
a136 1
	while ((ch = getopt(argc, argv, "1ACFLRSTWacdfghiklmnopqrstux")) != -1) {
a237 3
		case 'W':
			f_whiteout = 1;
			break;
a258 8

	/*
	 * If -W, show whiteout entries
	 */
#ifdef FTS_WHITEOUT
	if (f_whiteout)
		fts_options |= FTS_WHITEOUT;
#endif
@


1.22
log
@Unbreak alignment of fields when using -lh.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.21 2003/08/06 19:09:09 tedu Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.21 2003/08/06 19:09:09 tedu Exp $";
d394 2
a395 1
			warnx("%s: %s", p->fts_name, strerror(p->fts_errno));
@


1.21
log
@-h, human readable sizes.  from a jonathon gray mail to tech@@
ok ian@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.20 2003/06/11 23:42:12 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.20 2003/06/11 23:42:12 deraadt Exp $";
d64 1
d543 5
a547 2
		(void)snprintf(buf, sizeof(buf), "%qu", maxsize);
		d.s_size = strlen(buf);
@


1.20
log
@ansification, art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.19 2003/06/02 23:32:08 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.19 2003/06/02 23:32:08 millert Exp $";
d88 1
d136 1
a136 1
	while ((ch = getopt(argc, argv, "1ACFLRSTWacdfgiklmnopqrstux")) != -1) {
d203 3
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.18 2003/04/02 19:43:52 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.18 2003/04/02 19:43:52 deraadt Exp $";
d111 1
a111 3
ls_main(argc, argv)
	int argc;
	char *argv[];
d339 1
a339 3
traverse(argc, argv, options)
	int argc, options;
	char *argv[];
d403 1
a403 2
display(p, list)
	FTSENT *p, *list;
d558 1
a558 2
mastercmp(a, b)
	const FTSENT **a, **b;
@


1.18
log
@strlcpy; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.17 2002/03/12 01:05:15 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.17 2002/03/12 01:05:15 millert Exp $";
@


1.17
log
@o Remove local prototypes for group_from_gid() and user_from_uid()
  since they are prototyped in grp.h and pwd.h.
o Increase size of 'buf' to 21 since we store the string representation
  of a u_quad_t in it (max 20 chars + the NUL).
o Minor KNF wrt pointers in boolean context.
From Denis Afonin
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.16 2002/02/16 21:27:07 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.16 2002/02/16 21:27:07 millert Exp $";
d506 1
a506 1
				    ulen + glen + flen + 3)) == NULL)
d510 1
a510 1
				(void)strcpy(np->user, user);
d512 1
a512 1
				(void)strcpy(np->group, group);
d519 2
a520 2
					np->flags = &np->data[ulen + glen + 2];
				  	(void)strcpy(np->flags, flags);
@


1.16
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.15 2001/07/09 00:37:53 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.15 2001/07/09 00:37:53 deraadt Exp $";
d62 2
a71 3
char	*group_from_gid(u_int, int);
char	*user_from_uid(u_int, int);

d422 1
a422 1
	char *user, *group, buf[20];	/* 32 bits == 10 digits */
d442 1
a442 1
	for (cur = list, entries = 0; cur; cur = cur->fts_link) {
d556 1
a556 1
		for (cur = list; cur; cur = cur->fts_link)
@


1.15
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.14 2000/07/19 19:27:36 mickey Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.14 2000/07/19 19:27:36 mickey Exp $";
d70 2
a71 2
char	*group_from_gid __P((u_int, int));
char	*user_from_uid __P((u_int, int));
d73 3
a75 3
static void	 display __P((FTSENT *, FTSENT *));
static int	 mastercmp __P((const FTSENT **, const FTSENT **));
static void	 traverse __P((int, char **, int));
d77 2
a78 2
static void (*printfcn) __P((DISPLAY *));
static int (*sortfcn) __P((const FTSENT *, const FTSENT *));
@


1.14
log
@new strtofflags/fflagstostr
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.13 1999/05/01 23:54:47 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.13 1999/05/01 23:54:47 deraadt Exp $";
d580 1
a580 1
	if (a_info == FTS_NS || b_info == FTS_NS)
d587 1
@


1.13
log
@defer conversion of unprintable filenames till final display, permitting
badly named symbolic links to be handled; bug noted by dm@@ fixed by d@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.12 1999/02/24 16:48:02 aaron Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.12 1999/02/24 16:48:02 aaron Exp $";
d498 3
a500 2
					flags =
					    flags_to_string(sp->st_flags, "-");
d522 2
@


1.12
log
@save cpu cycles by being more sensible about how we check conditionals
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.11 1999/02/23 23:54:17 art Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.11 1999/02/23 23:54:17 art Exp $";
a468 2
		if (f_nonprint)
			prcopy(cur->fts_name, cur->fts_name, cur->fts_namelen);
@


1.11
log
@Break out main to an own file so we can include ls in ftpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.10 1999/02/20 18:59:25 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.10 1999/02/20 18:59:25 deraadt Exp $";
d255 1
a255 1
	if (!f_inode && !f_longform && !f_size && !f_type && !f_typedir &&
a369 8
		case FTS_DC:
			warnx("%s: directory causes a cycle", p->fts_name);
			break;
		case FTS_DNR:
		case FTS_ERR:
			warnx("%s: %s", p->fts_name, strerror(p->fts_errno));
			rval = 1;
			break;
d371 2
a372 2
			if (p->fts_level != FTS_ROOTLEVEL &&
			    p->fts_name[0] == '.' && !f_listdot)
d392 8
@


1.10
log
@add -x, -p, and -m options, based on netbsd work
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.9 1998/08/07 19:45:06 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.9 1998/08/07 19:45:06 deraadt Exp $";
d116 1
a116 1
main(argc, argv)
@


1.9
log
@fix exit code; problem reported by jsh@@sun470.rd.qms.com; fix from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.8 1997/09/18 07:58:41 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.8 1997/09/18 07:58:41 deraadt Exp $";
d91 1
d107 1
d110 1
d142 1
a142 1
	while ((ch = getopt(argc, argv, "1ACFLRSTWacdfgiklnoqrstu")) != -1) {
d145 2
a146 2
		 * The -1, -C and -l options all override each other so shell
		 * aliasing works right.
d150 1
a150 1
			f_column = f_longform = 0;
d154 1
a154 1
			f_longform = f_singlecol = 0;
d159 10
a168 1
			f_column = f_singlecol = 0;
d220 3
d252 1
a252 1
	 * If not -F, -i, -l, -S, -s or -t options, don't require stat
d255 1
a255 1
	if (!f_inode && !f_longform && !f_size && !f_type &&
d321 2
d325 2
@


1.8
log
@make ls -d still sort files in the regular order; reported by
roberte@@MEP.Ruhr-Uni-Bochum.de, fixed by sef@@Kithrup.COM
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.7 1997/04/01 22:59:38 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.7 1997/04/01 22:59:38 deraadt Exp $";
d110 2
d315 1
a315 1
	exit(0);
d357 1
d429 1
@


1.7
log
@option 'n' was unused, so let's come up with a feature to use it!!! YEAH!!
add -n (numeric uid/gid), fix some man page errors; tv@@pobox.com
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.6 1997/01/03 22:36:08 millert Exp $";
d564 2
a565 4
	if (a_info == b_info)
		return (sortfcn(*a, *b));

	if ((*a)->fts_level == FTS_ROOTLEVEL)
d568 1
a568 1
		else if (b_info == FTS_D)
d570 2
a571 4
		else
			return (sortfcn(*a, *b));
	else
		return (sortfcn(*a, *b));
@


1.6
log
@From NetBSD:
    - Correct sorting behaviour.
    - Do multicolumn output in a way that's a more likely to line up evenly.
      From D'Arcy J.M. Cain <darcy@@druid.com>, NetBSD PR #2965.
@
text
@d1 1
a1 1
/*	$OpenBSD: ls.c,v 1.5 1996/12/14 12:18:03 mickey Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.18 1996/07/09 09:16:29 mycroft Exp $";
d99 1
d137 1
a137 1
	while ((ch = getopt(argc, argv, "1ACFLRSTWacdfgikloqrstu")) != -1) {
d153 6
d402 1
d463 9
a471 1
				user = user_from_uid(sp->st_uid, 0);
a473 1
				group = group_from_gid(sp->st_gid, 0);
@


1.5
log
@-Wall'ing.
@
text
@d1 2
a2 2
/*    $OpenBSD: ls.c,v 1.4 1996/08/02 12:40:57 deraadt Exp $      */
/*    $NetBSD: ls.c,v 1.16 1996/02/14 05:58:53 jtc Exp $      */
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.4 1996/08/02 12:40:57 deraadt Exp $";
d122 4
a125 4
              if ((p = getenv("COLUMNS")) != NULL)
                      termwidth = atoi(p);
              else if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) == 0 &&
                  win.ws_col > 0)
d394 2
a395 5
	char *user, *group, *flags, buf[20];	/* 32 bits == 10 digits */

#ifdef lint
	flags = NULL;
#endif
d542 6
a547 1
		return (namecmp(*a, *b));
@


1.4
log
@zap getopt() case of -?, come on, it is the default!
@
text
@d1 1
a1 1
/*    $OpenBSD: ls.c,v 1.3 1996/06/23 14:20:19 deraadt Exp $      */
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.3 1996/06/23 14:20:19 deraadt Exp $";
d395 4
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*    $OpenBSD: ls.c,v 1.16 1996/02/14 05:58:53 jtc Exp $      */
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ls.c,v 1.16 1996/02/14 05:58:53 jtc Exp $";
a220 1
		case '?':
@


1.2
log
@From netbsd:
Changed so that COLUMNS environment variable will override the value
obtained via the TIOCGWINSIZ ioctl.  This is required by POSIX.2, see
section 4.39.5.3.
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: ls.c,v 1.16 1996/02/14 05:58:53 jtc Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ls.c,v 1.15 1995/09/07 06:42:58 jtc Exp $	*/
d49 1
a49 1
static char rcsid[] = "$NetBSD: ls.c,v 1.15 1995/09/07 06:42:58 jtc Exp $";
d121 4
a124 6
		if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) == -1 ||
		    !win.ws_col) {
			if ((p = getenv("COLUMNS")) != NULL)
				termwidth = atoi(p);
		}
		else
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
