head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.12
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.10
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.6
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.8
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.8
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.14
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.12
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.8
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.10
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.6
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.4
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.20.0.6
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.11.0.16
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.14
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.12
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.10
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.8
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.25
date	2014.03.16.18.38.30;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2012.12.04.02.24.46;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.24.01.13.55;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.27.16.22.12;	author martynas;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.16.20.19.26;	author sobrado;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.14.02.14.25;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.13.19.35.17;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.01.00.30.30;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.31.05.01.59;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.31.03.04.52;	author beck;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.29.01.39.38;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.29.01.35.42;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.29.01.21.38;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.25.15.41.05;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.04.04.26.39;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.21.22.23.58;	author art;	state Exp;
branches;
next	1.8;

1.8
date	98.06.23.18.26.36;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.11.08.23.22.40;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	97.09.01.18.29.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.12.17.35;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.11.02.03.47.10;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.09.15.21.56.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.04;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.04.19.02.19.39;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.25
log
@lint is dead (long live the lint!), so stop using it as a cpp conditional
(namespace pollution!) or talking about its opinion on code.

ok krw@@
@
text
@/*	$OpenBSD: chio.c,v 1.24 2012/12/04 02:24:46 deraadt Exp $	*/
/*	$NetBSD: chio.c,v 1.1.1.1 1996/04/03 00:34:38 thorpej Exp $	*/

/*
 * Copyright (c) 1996 Jason R. Thorpe <thorpej@@and.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgments:
 *	This product includes software developed by Jason R. Thorpe
 *	for And Communications, http://www.and.com/
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/mtio.h>
#include <sys/chio.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include "defs.h"
#include "pathnames.h"

#define _PATH_CH_CONF	"/etc/chio.conf"
extern	char *parse_tapedev(const char *, const char *, int); /* parse.y */
extern	char *__progname;	/* from crt0.o */

static	void usage(void);
static	int parse_element_type(char *);
static	int parse_element_unit(char *);
static	int parse_special(char *);
static	int is_special(char *);
static	char *bits_to_string(int, const char *);
static	void find_voltag(char *, int *, int *);
static	void check_source_drive(int);

static	int do_move(char *, int, char **);
static	int do_exchange(char *, int, char **);
static	int do_position(char *, int, char **);
static	int do_params(char *, int, char **);
static	int do_getpicker(char *, int, char **);
static	int do_setpicker(char *, int, char **);
static	int do_status(char *, int, char **);

/* Valid changer element types. */
const struct element_type elements[] = {
	{ "drive",		CHET_DT },
	{ "picker",		CHET_MT },
	{ "portal",		CHET_IE },
	{ "slot",		CHET_ST },
	{ NULL,			0 },
};

/* Valid commands. */
const struct changer_command commands[] = {
	{ "exchange",		do_exchange },
	{ "getpicker",		do_getpicker },
	{ "move",		do_move },
	{ "params",		do_params },
	{ "position",		do_position },
	{ "setpicker",		do_setpicker },
	{ "status",		do_status },
	{ NULL,			0 },
};

/* Valid special words. */
const struct special_word specials[] = {
	{ "inv",		SW_INVERT },
	{ "inv1",		SW_INVERT1 },
	{ "inv2",		SW_INVERT2 },
	{ NULL,			0 },
};

static	int changer_fd;
static	char *changer_name;
static int avoltag;
static int pvoltag;

int
main(int argc, char *argv[])
{
	int ch, i;

	while ((ch = getopt(argc, argv, "f:")) != -1) {
		switch (ch) {
		case 'f':
			changer_name = optarg;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc == 0)
		usage();

	/* Get the default changer if not already specified. */
	if (changer_name == NULL)
		if ((changer_name = getenv(CHANGER_ENV_VAR)) == NULL)
			changer_name = _PATH_CH;

	/* Open the changer device. */
	if ((changer_fd = open(changer_name, O_RDWR, 0600)) == -1)
		err(1, "%s: open", changer_name);

	/* Find the specified command. */
	for (i = 0; commands[i].cc_name != NULL; ++i)
		if (strcmp(*argv, commands[i].cc_name) == 0)
			break;
	if (commands[i].cc_name == NULL) {
		/* look for abbreviation */
		for (i = 0; commands[i].cc_name != NULL; ++i)
			if (strncmp(*argv, commands[i].cc_name,
			    strlen(*argv)) == 0)
				break;
	}
	if (commands[i].cc_name == NULL)
		errx(1, "unknown command: %s", *argv);

	exit((*commands[i].cc_handler)(commands[i].cc_name, argc, argv));
}

static int
do_move(char *cname, int argc, char *argv[])
{
	struct changer_move cmd;
	int val;

	/*
	 * On a move command, we expect the following:
	 *
	 * <from ET> <from EU> <to ET> <to EU> [inv]
	 *
	 * where ET == element type and EU == element unit.
	 */

	++argv; --argc;

	if (argc < 4) {
		warnx("%s: too few arguments", cname);
		goto usage;
	} else if (argc > 5) {
		warnx("%s: too many arguments", cname);
		goto usage;
	}
	bzero(&cmd, sizeof(cmd));

	/*
	 * Get the from ET and EU - we search for it if the ET is
	 * "voltag", otherwise, we just use the ET and EU given to us.
	 */
	if (strcmp(*argv, "voltag") == 0) {
		++argv; --argc;
		find_voltag(*argv, &cmd.cm_fromtype, &cmd.cm_fromunit);
		++argv; --argc;
	} else {
		cmd.cm_fromtype = parse_element_type(*argv);
		++argv; --argc;
		cmd.cm_fromunit = parse_element_unit(*argv);
		++argv; --argc;
	}

	if (cmd.cm_fromtype == CHET_DT)
		check_source_drive(cmd.cm_fromunit);

	/*
	 * Don't allow voltag on the to ET, using a volume
	 * as a destination makes no sense on a move
	 */
	cmd.cm_totype = parse_element_type(*argv);
	++argv; --argc;
	cmd.cm_tounit = parse_element_unit(*argv);
	++argv; --argc;

	/* Deal with optional command modifier. */
	if (argc) {
		val = parse_special(*argv);
		switch (val) {
		case SW_INVERT:
			cmd.cm_flags |= CM_INVERT;
			break;

		default:
			errx(1, "%s: inappropriate modifier `%s'",
			    cname, *argv);
			/* NOTREACHED */
		}
	}

	/* Send command to changer. */
	if (ioctl(changer_fd, CHIOMOVE, &cmd))
		err(1, "%s: CHIOMOVE", changer_name);

	return (0);

 usage:
	fprintf(stderr, "usage: %s %s "
	    "<from ET> <from EU> <to ET> <to EU> [inv]\n", __progname, cname);
	return (1);
}

static int
do_exchange(char *cname, int argc, char *argv[])
{
	struct changer_exchange cmd;
	int val;

	/*
	 * On an exchange command, we expect the following:
	 *
  * <src ET> <src EU> <dst1 ET> <dst1 EU> [<dst2 ET> <dst2 EU>] [inv1] [inv2]
	 *
	 * where ET == element type and EU == element unit.
	 */

	++argv; --argc;

	if (argc < 4) {
		warnx("%s: too few arguments", cname);
		goto usage;
	} else if (argc > 8) {
		warnx("%s: too many arguments", cname);
		goto usage;
	}
	bzero(&cmd, sizeof(cmd));

	/* <src ET>  */
	cmd.ce_srctype = parse_element_type(*argv);
	++argv; --argc;

	/* <src EU> */
	cmd.ce_srcunit = parse_element_unit(*argv);
	++argv; --argc;

	/* <dst1 ET> */
	cmd.ce_fdsttype = parse_element_type(*argv);
	++argv; --argc;

	/* <dst1 EU> */
	cmd.ce_fdstunit = parse_element_unit(*argv);
	++argv; --argc;

	/*
	 * If the next token is a special word or there are no more
	 * arguments, then this is a case of simple exchange.
	 * dst2 == src.
	 */
	if ((argc == 0) || is_special(*argv)) {
		cmd.ce_sdsttype = cmd.ce_srctype;
		cmd.ce_sdstunit = cmd.ce_srcunit;
		goto do_special;
	}

	/* <dst2 ET> */
	cmd.ce_sdsttype = parse_element_type(*argv);
	++argv; --argc;

	/* <dst2 EU> */
	cmd.ce_sdstunit = parse_element_unit(*argv);
	++argv; --argc;

 do_special:
	/* Deal with optional command modifiers. */
	while (argc) {
		val = parse_special(*argv);
		++argv; --argc;
		switch (val) {
		case SW_INVERT1:
			cmd.ce_flags |= CE_INVERT1;
			break;

		case SW_INVERT2:
			cmd.ce_flags |= CE_INVERT2;
			break;

		default:
			errx(1, "%s: inappropriate modifier `%s'",
			    cname, *argv);
			/* NOTREACHED */
		}
	}

	/* Send command to changer. */
	if (ioctl(changer_fd, CHIOEXCHANGE, &cmd))
		err(1, "%s: CHIOEXCHANGE", changer_name);

	return (0);

 usage:
	fprintf(stderr, "usage: %s %s <src ET> <src EU> <dst1 ET> <dst1 EU>\n"
	    "       [<dst2 ET> <dst2 EU>] [inv1] [inv2]\n",
	    __progname, cname);
	return (1);
}

static int
do_position(char *cname, int argc, char *argv[])
{
	struct changer_position cmd;
	int val;

	/*
	 * On a position command, we expect the following:
	 *
	 * <to ET> <to EU> [inv]
	 *
	 * where ET == element type and EU == element unit.
	 */

	++argv; --argc;

	if (argc < 2) {
		warnx("%s: too few arguments", cname);
		goto usage;
	} else if (argc > 3) {
		warnx("%s: too many arguments", cname);
		goto usage;
	}
	bzero(&cmd, sizeof(cmd));

	/* <to ET>  */
	cmd.cp_type = parse_element_type(*argv);
	++argv; --argc;

	/* <to EU> */
	cmd.cp_unit = parse_element_unit(*argv);
	++argv; --argc;

	/* Deal with optional command modifier. */
	if (argc) {
		val = parse_special(*argv);
		switch (val) {
		case SW_INVERT:
			cmd.cp_flags |= CP_INVERT;
			break;

		default:
			errx(1, "%s: inappropriate modifier `%s'",
			    cname, *argv);
			/* NOTREACHED */
		}
	}

	/* Send command to changer. */
	if (ioctl(changer_fd, CHIOPOSITION, &cmd))
		err(1, "%s: CHIOPOSITION", changer_name);

	return (0);

 usage:
	fprintf(stderr, "usage: %s %s <to ET> <to EU> [inv]\n",
	    __progname, cname);
	return (1);
}

static int
do_params(char *cname, int argc, char *argv[])
{
	struct changer_params data;

	/* No arguments to this command. */

	++argv; --argc;

	if (argc) {
		warnx("%s: no arguments expected", cname);
		goto usage;
	}

	/* Get params from changer and display them. */
	bzero(&data, sizeof(data));
	if (ioctl(changer_fd, CHIOGPARAMS, &data))
		err(1, "%s: CHIOGPARAMS", changer_name);

	printf("%s: %d slot%s, %d drive%s, %d picker%s",
	    changer_name,
	    data.cp_nslots, (data.cp_nslots > 1) ? "s" : "",
	    data.cp_ndrives, (data.cp_ndrives > 1) ? "s" : "",
	    data.cp_npickers, (data.cp_npickers > 1) ? "s" : "");
	if (data.cp_nportals)
		printf(", %d portal%s", data.cp_nportals,
		    (data.cp_nportals > 1) ? "s" : "");
	printf("\n%s: current picker: %d\n", changer_name, data.cp_curpicker);

	return (0);

 usage:
	fprintf(stderr, "usage: %s %s\n", __progname, cname);
	return (1);
}

static int
do_getpicker(char *cname, int argc, char *argv[])
{
	int picker;

	/* No arguments to this command. */

	++argv; --argc;

	if (argc) {
		warnx("%s: no arguments expected", cname);
		goto usage;
	}

	/* Get current picker from changer and display it. */
	if (ioctl(changer_fd, CHIOGPICKER, &picker))
		err(1, "%s: CHIOGPICKER", changer_name);

	printf("%s: current picker: %d\n", changer_name, picker);

	return (0);

 usage:
	fprintf(stderr, "usage: %s %s\n", __progname, cname);
	return (1);
}

static int
do_setpicker(char *cname, int argc, char *argv[])
{
	int picker;

	++argv; --argc;

	if (argc < 1) {
		warnx("%s: too few arguments", cname);
		goto usage;
	} else if (argc > 1) {
		warnx("%s: too many arguments", cname);
		goto usage;
	}

	picker = parse_element_unit(*argv);

	/* Set the changer picker. */
	if (ioctl(changer_fd, CHIOSPICKER, &picker))
		err(1, "%s: CHIOSPICKER", changer_name);

	return (0);

 usage:
	fprintf(stderr, "usage: %s %s <picker>\n", __progname, cname);
	return (1);
}

static int
do_status(char *cname, int argc, char *argv[])
{
	struct changer_element_status_request cmd;
	struct changer_params data;
	int i, chet, schet, echet, c;
	char *description;
	size_t count;

	optreset = 1;
	optind = 1;
	while ((c = getopt(argc, argv, "vVa")) != -1) {
		switch (c) {
		case 'v':
			pvoltag = 1;
			break;
		case 'V':
			avoltag = 1;
			break;
		case 'a':
			pvoltag = avoltag = 1;
			break;
		default:
			goto usage;
		}
	}

	argc -= optind;
	argv += optind;

	/*
	 * On a status command, we expect the following:
	 *
	 * [<ET>]
	 *
	 * where ET == element type.
	 *
	 * If we get no arguments, we get the status of all
	 * known element types.
	 */
	if (argc > 1) {
		warnx("%s: too many arguments", cname);
		goto usage;
	}

	/*
	 * Get params from changer.  Specifically, we need the element
	 * counts.
	 */
	bzero(&data, sizeof(data));
	if (ioctl(changer_fd, CHIOGPARAMS, &data))
		err(1, "%s: CHIOGPARAMS", changer_name);

	if (argc)
		schet = echet = parse_element_type(*argv);
	else {
		schet = CHET_MT;
		echet = CHET_DT;
	}

	for (chet = schet; chet <= echet; ++chet) {
		switch (chet) {
		case CHET_MT:
			count = data.cp_npickers;
			description = "picker";
			break;

		case CHET_ST:
			count = data.cp_nslots;
			description = "slot";
			break;

		case CHET_IE:
			count = data.cp_nportals;
			description = "portal";
			break;

		case CHET_DT:
			count = data.cp_ndrives;
			description = "drive";
			break;
		}

		if (count == 0) {
			if (argc == 0)
				continue;
			else {
				printf("%s: no %s elements\n",
				    changer_name, description);
				return (0);
			}
		}

		bzero(&cmd, sizeof(cmd));

		cmd.cesr_type = chet;
		/* Allocate storage for the status info. */
		cmd.cesr_data = calloc(count, sizeof(*cmd.cesr_data));
		if ((cmd.cesr_data) == NULL)
			errx(1, "can't allocate status storage");
		if (avoltag || pvoltag)
			cmd.cesr_flags |= CESR_VOLTAGS;

		if (ioctl(changer_fd, CHIOGSTATUS, &cmd)) {
			free(cmd.cesr_data);
			err(1, "%s: CHIOGSTATUS", changer_name);
		}

		/* Dump the status for each element of this type. */
		for (i = 0; i < count; ++i) {
			struct changer_element_status *ces =
			         &(cmd.cesr_data[i]);
			printf("%s %d: %s", description, i,
			    bits_to_string(ces->ces_flags, CESTATUS_BITS));
			if (pvoltag)
				printf(" voltag: <%s:%d>",
				       ces->ces_pvoltag.cv_volid,
				       ces->ces_pvoltag.cv_serial);
			if (avoltag)
				printf(" avoltag: <%s:%d>",
				       ces->ces_avoltag.cv_volid,
				       ces->ces_avoltag.cv_serial);
			printf("\n");
		}

		free(cmd.cesr_data);
	}

	return (0);

 usage:
	fprintf(stderr, "usage: %s %s [<element type>]\n", __progname,
	    cname);
	return (1);
}

/*
 * Check a drive unit as the source for a move or exchange
 * operation. If the drive is not accessible, we attempt
 * to unmount the tape in it before moving to avoid
 * errors in "disconnected" type pickers where the drive
 * is on a separate target from the changer.
 */
static void
check_source_drive(int unit)
{
	struct mtop mtoffl =  { MTOFFL, 1 };
	struct changer_element_status_request cmd;
	struct changer_element_status *ces;
	struct changer_params data;
	size_t count = 0;
	int mtfd;
	char *tapedev;

	/*
	 * Get params from changer.  Specifically, we need the element
	 * counts.
	 */
	bzero(&data, sizeof(data));
	if (ioctl(changer_fd, CHIOGPARAMS, &data))
		err(1, "%s: CHIOGPARAMS", changer_name);

	count = data.cp_ndrives;
	if (unit < 0 || unit >= count)
		err(1, "%s: invalid drive: drive %d", changer_name, unit);

	bzero(&cmd, sizeof(cmd));
	cmd.cesr_type = CHET_DT;
	/* Allocate storage for the status info. */
	cmd.cesr_data = calloc(count, sizeof(*cmd.cesr_data));
	if ((cmd.cesr_data) == NULL)
		errx(1, "can't allocate status storage");

	if (ioctl(changer_fd, CHIOGSTATUS, &cmd)) {
		free(cmd.cesr_data);
		err(1, "%s: CHIOGSTATUS", changer_name);
	}
	ces = &(cmd.cesr_data[unit]);

	if ((ces->ces_flags & CESTATUS_FULL) != CESTATUS_FULL)
		err(1, "%s: drive %d is empty!", changer_name, unit);

	if ((ces->ces_flags & CESTATUS_ACCESS) == CESTATUS_ACCESS)
		return; /* changer thinks all is well - trust it */

	/*
	 * Otherwise, drive is FULL, but not accessible.
	 * Try to make it accessible by doing an mt offline.
	 */
	tapedev = parse_tapedev(_PATH_CH_CONF, changer_name, unit);
	mtfd = opendev(tapedev, O_RDONLY, 0, NULL);
	if (mtfd == -1)
		err(1, "%s drive %d (%s): open", changer_name, unit, tapedev);
	if (ioctl(mtfd, MTIOCTOP, &mtoffl) == -1)
		err(1, "%s drive %d (%s): rewoffl", changer_name, unit,
		    tapedev);
	close(mtfd);
}

void
find_voltag(char *voltag, int *type, int *unit)
{
	struct changer_element_status_request cmd;
	struct changer_params data;
	int i, chet, schet, echet, found;
	size_t count = 0;

	/*
	 * Get params from changer.  Specifically, we need the element
	 * counts.
	 */
	bzero(&data, sizeof(data));
	if (ioctl(changer_fd, CHIOGPARAMS, &data))
		err(1, "%s: CHIOGPARAMS", changer_name);

	found = 0;
	schet = CHET_MT;
	echet = CHET_DT;

	/*
	 * For each type of element, iterate through each one until
	 * we find the correct volume id.
	 */
	for (chet = schet; chet <= echet; ++chet) {
		switch (chet) {
		case CHET_MT:
			count = data.cp_npickers;
			break;
		case CHET_ST:
			count = data.cp_nslots;
			break;
		case CHET_IE:
			count = data.cp_nportals;
			break;
		case CHET_DT:
			count = data.cp_ndrives;
			break;
		}
		if (count == 0 || found)
			continue;

		bzero(&cmd, sizeof(cmd));
		cmd.cesr_type = chet;
		/* Allocate storage for the status info. */
		cmd.cesr_data = calloc(count, sizeof(*cmd.cesr_data));
		if ((cmd.cesr_data) == NULL)
			errx(1, "can't allocate status storage");
		cmd.cesr_flags |= CESR_VOLTAGS;

		if (ioctl(changer_fd, CHIOGSTATUS, &cmd)) {
			free(cmd.cesr_data);
			err(1, "%s: CHIOGSTATUS", changer_name);
		}

		/*
		 * look through each element to see if it has our desired
		 * volume tag.
		 */
		for (i = 0; i < count; ++i) {
			struct changer_element_status *ces =
			    &(cmd.cesr_data[i]);
			if ((ces->ces_flags & CESTATUS_FULL) != CESTATUS_FULL)
				continue; /* no tape in drive */
			if (strcasecmp(voltag, ces->ces_pvoltag.cv_volid)
			    == 0) {
				*type = chet;
				*unit = i;
				found = 1;
				free(cmd.cesr_data);
				return;
			}
		}
		free(cmd.cesr_data);
	}
	errx(1, "%s: unable to locate voltag: %s", changer_name, voltag);
}


static int
parse_element_type(char *cp)
{
	int i;

	for (i = 0; elements[i].et_name != NULL; ++i)
		if (strcmp(elements[i].et_name, cp) == 0)
			return (elements[i].et_type);

	errx(1, "invalid element type `%s'", cp);
}

static int
parse_element_unit(char *cp)
{
	int i;
	char *p;

	i = (int)strtol(cp, &p, 10);
	if ((i < 0) || (*p != '\0'))
		errx(1, "invalid unit number `%s'", cp);

	return (i);
}

static int
parse_special(char *cp)
{
	int val;

	val = is_special(cp);
	if (val)
		return (val);

	errx(1, "invalid modifier `%s'", cp);
}

static int
is_special(char *cp)
{
	int i;

	for (i = 0; specials[i].sw_name != NULL; ++i)
		if (strcmp(specials[i].sw_name, cp) == 0)
			return (specials[i].sw_value);

	return (0);
}

static char *
bits_to_string(int v, const char *cp)
{
	const char *np;
	char f, sep, *bp;
	static char buf[128];

	bp = buf;
	bzero(buf, sizeof(buf));

	for (sep = '<'; (f = *cp++) != 0; cp = np) {
		for (np = cp; *np >= ' ';)
			np++;
		if ((v & (1 << (f - 1))) == 0)
			continue;
		(void)snprintf(bp, sizeof(buf) - (bp - &buf[0]),
		    "%c%.*s", sep, (int)(np - cp), cp);
		bp += strlen(bp);
		sep = ',';
	}
	if (sep != '<')
		*bp = '>';

	return (buf);
}

static void
usage(void)
{
	int i;

	fprintf(stderr, "usage: %s [-f changer] command [arg ...]\n",
	    __progname);
	fprintf(stderr, "commands:");
	for (i = 0; commands[i].cc_name; i++)
		fprintf(stderr, " %s", commands[i].cc_name);
	fprintf(stderr, "\n");
	exit(1);
}
@


1.24
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.23 2011/04/24 01:13:55 krw Exp $	*/
a485 5

#ifdef lint
	count = 0;
	description = NULL;
#endif
@


1.23
log
@No point in attempting to open the 'c' partition on devices that have
no 'c' partition. So don't call opendev(3) with OPENDEV_PART.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.22 2007/11/27 16:22:12 martynas Exp $	*/
d36 1
a36 1
#include <sys/param.h>
@


1.22
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.21 2007/10/16 20:19:26 sobrado Exp $	*/
d673 1
a673 1
	mtfd = opendev(tapedev, O_RDONLY, OPENDEV_PART, NULL);
@


1.21
log
@sync the synopsis and usage of commands

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.20 2006/06/14 02:14:25 krw Exp $	*/
d624 1
a624 1
 * is on a seperate target from the changer.
@


1.20
log
@Nuke only two uses of OPENDEV_DRCT in tree. Nuke OPENDEV_DRCT. Long
marked obsolete since the opendev() behaviour it turned on is now the
default.

'it can go' deraadt@@

'no API of mine has ever made it into a standard' downsj@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.19 2006/06/13 19:35:17 deraadt Exp $	*/
d841 1
a841 1
	fprintf(stderr, "usage: %s [-f device] command [args ...]\n",
@


1.19
log
@make -avV only be suboptions of the status command, as documented, by using
nested getopt() calls.  ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.18 2006/06/01 00:30:30 beck Exp $	*/
d673 1
a673 2
	mtfd = opendev(tapedev, O_RDONLY, OPENDEV_PART | OPENDEV_DRCT,
	    NULL);
@


1.18
log
@ Move mtio drive prep to a function, and makes the changer
check it's notion of access, avoiding problems on more tightly
coupled changers if the tape is already ejected - currently
these stupid devices return "Initialization Command Required"
sense codes but there is (as yet) no way to tell userland
that. checking the ACCESS changer flag appears safe in both
cases.

 Adds support for "voltag" type for the source for a move, so
you can do "chio move voltag 0003B72 drive 0" to move a tape
with the corresponding bar code.

Documents the above, as well as status -vVa in the man page.

partly from freebsd, man page tweaks by jmc@@
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.17 2006/05/31 05:01:59 deraadt Exp $	*/
d64 1
a64 1
static 	void check_source_drive(int);
d113 1
a113 1
	while ((ch = getopt(argc, argv, "af:vV")) != -1) {
a114 6
		case 'v':
			pvoltag = 1;
			break;
		case 'V':
			avoltag = 1;
			break;
a117 3
		case 'a':
			pvoltag = avoltag = 1;
			break;
a150 2
	/* Skip over the command name and call handler. */
	++argv; --argc;
d167 3
d179 1
a179 1
	/* 
d187 1
a187 1
	} else {		
d197 1
a197 1
	/* 
d199 1
a199 1
	 * as a destination makes no sense on a move 
d246 3
d340 3
d393 3
d429 3
d455 2
d483 1
a483 1
	int i, chet, schet, echet;
d492 21
d624 1
a624 1
 * is on a seperate target from the changer. 
d627 2
a628 1
check_source_drive(int unit) {
d661 1
a661 1
	
a671 1
	
d703 1
a703 1
	/* 
d706 1
a706 2
	 */ 
	
d723 1
a723 1
			continue;		  
d842 1
a842 1
	fprintf(stderr, "usage: %s [-avV] [-f device] command [args ...]\n",
@


1.17
log
@prettier
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.16 2006/05/31 03:04:52 beck Exp $	*/
d63 2
d187 14
a200 3
	/* <from ET>  */
	cmd.cm_fromtype = parse_element_type(*argv);
	++argv; --argc;
d202 2
a203 3
	/* <from EU> */
	cmd.cm_fromunit = parse_element_unit(*argv);
	++argv; --argc;
d205 4
a208 26
	if (cmd.cm_fromtype == CHET_DT) {
		/*
		 * from unit is a drive - make sure the tape
		 * in it is unmounted before we attempt to move
		 * it to avoid errors in "disconnected" type
		 * pickers where the drive is on a seperate target
		 * from the changer.
		 */
		struct mtop mtoffl =  { MTOFFL, 1 };
		char *tapedev;
		int mtfd;

		tapedev = parse_tapedev(_PATH_CH_CONF, changer_name,
		    cmd.cm_fromunit);
		mtfd = opendev(tapedev, O_RDONLY, OPENDEV_PART | OPENDEV_DRCT,
		    NULL);
		if (mtfd == -1)
			err(1, "%s drive %d (%s): open", changer_name,
			    cmd.cm_fromunit, tapedev);
		if (ioctl(mtfd, MTIOCTOP, &mtoffl) == -1)
			err(1, "%s drive %d (%s): rewoffl", changer_name,
			    cmd.cm_fromunit, tapedev);
		close(mtfd);
	}

	/* <to ET> */
a210 2

	/* <to EU> */
d591 144
@


1.16
log
@	This adds support for retrieving volume tags in chio(8) with the
status command and options -v to request the primary volume tag, -V for
the alternate volume tag. Man page will follow shortly, along with move
support by volume tag.
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.15 2006/05/29 01:39:38 deraadt Exp $	*/
d201 2
d204 3
a206 3
		struct mtop mtoffl =  { MTOFFL, 1 };
		char *tapedev =
		    parse_tapedev(_PATH_CH_CONF, changer_name, cmd.cm_fromunit);
d583 1
a583 1
				printf(" voltag: <%s:%d>", 
d587 1
a587 1
				printf(" avoltag: <%s:%d>", 
@


1.15
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.14 2006/05/29 01:35:42 henning Exp $	*/
d103 2
d111 1
a111 1
	while ((ch = getopt(argc, argv, "f:")) != -1) {
d113 6
d122 3
a124 1

d485 1
a485 1
	struct changer_element_status cmd;
a486 1
	u_int8_t *statusp;
a558 5
		/* Allocate storage for the status bytes. */
		if ((statusp = malloc(count)) == NULL)
			errx(1, "can't allocate status storage");

		bzero(statusp, count);
d561 7
a567 2
		cmd.ces_type = chet;
		cmd.ces_data = statusp;
d570 1
a570 1
			free(statusp);
d576 13
a588 2
			printf("%s %d: %s\n", description, i,
			    bits_to_string(statusp[i], CESTATUS_BITS));
d591 1
a591 1
		free(statusp);
d682 1
a682 1
	fprintf(stderr, "usage: %s [-f device] command [args ...]\n",
@


1.14
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.13 2006/05/29 01:21:38 beck Exp $	*/
d184 1
a184 1
		/* 
d186 2
a187 2
		 * in it is unmounted before we attempt to move 
		 * it to avoid errors in "disconnected" type 
@


1.13
log
@Make chio have a connection between st(4) devices and "drives" in a
changer - chio will then attempt to open the /dev/rstX device when doing
a move from a source of drive X, and will attempt to unload the tape.
this avoids issues where pickers madly attempt to grab a busy tape on
completely decoupled libraries, or fail to grab an unloaded tape
on tightly coupled libraries, the extra unload being harmless if the
media has already been ejected.

The mapping between st(4) devices and ch drives is by default a
simple mapping between picker drive X being mapped to /dev/rstX, however
for non-obvious or complicated configurations, we support a /etc/chio.conf
file in which the drives for a changer may have their corresponding
st(4) devices defined individually. chio will use the default
mapping if the /etc/chio.conf file is not present, or does not define
a st(4) device for a changer drive.

(example chio.conf and man page changes to come)
yacc parser for chio.conf written by henning@@,

ok henning@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.12 2006/04/25 15:41:05 deraadt Exp $	*/
d150 1
a150 1
	exit ((*commands[i].cc_handler)(commands[i].cc_name, argc, argv));
d193 2
a194 1
		char * tapedev = parse_tapedev(_PATH_CH_CONF, changer_name, cmd.cm_fromunit);
d197 1
a197 1
		if (mtfd == -1) 
d647 1
a647 1
			       "%c%.*s", sep, (int)(np - cp), cp);
@


1.12
log
@various small lint cleanups; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.11 2002/07/04 04:26:39 deraadt Exp $	*/
d38 1
d48 1
d53 2
d182 22
@


1.11
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.10 2002/02/16 21:27:06 millert Exp $	*/
d203 1
a203 1
	if (ioctl(changer_fd, CHIOMOVE, (char *)&cmd))
d293 1
a293 1
	if (ioctl(changer_fd, CHIOEXCHANGE, (char *)&cmd))
d351 1
a351 1
	if (ioctl(changer_fd, CHIOPOSITION, (char *)&cmd))
d375 1
a375 1
	if (ioctl(changer_fd, CHIOGPARAMS, (char *)&data))
d407 1
a407 1
	if (ioctl(changer_fd, CHIOGPICKER, (char *)&picker))
d435 1
a435 1
	if (ioctl(changer_fd, CHIOSPICKER, (char *)&picker))
d451 1
a451 1
	int i, count, chet, schet, echet;
d453 1
d480 1
a480 1
	if (ioctl(changer_fd, CHIOGPARAMS, (char *)&data))
d524 1
a524 1
		if ((statusp = (u_int8_t *)malloc(count)) == NULL)
d533 1
a533 1
		if (ioctl(changer_fd, CHIOGSTATUS, (char *)&cmd)) {
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.9 2001/03/21 22:23:58 art Exp $	*/
a53 1
static	void cleanup(void);
d101 1
a101 3
main(argc, argv)
	int argc;
	char **argv;
a129 4
	/* Register cleanup function. */
	if (atexit(cleanup))
		err(1, "can't register cleanup function");

d150 1
a150 4
do_move(cname, argc, argv)
	char *cname;
	int argc;
	char **argv;
d215 1
a215 4
do_exchange(cname, argc, argv)
	char *cname;
	int argc;
	char **argv;
d306 1
a306 4
do_position(cname, argc, argv)
	char *cname;
	int argc;
	char **argv;
d363 1
a363 4
do_params(cname, argc, argv)
	char *cname;
	int argc;
	char **argv;
d396 1
a396 4
do_getpicker(cname, argc, argv)
	char *cname;
	int argc;
	char **argv;
d420 1
a420 4
do_setpicker(cname, argc, argv)
	char *cname;
	int argc;
	char **argv;
d446 1
a446 4
do_status(cname, argc, argv)
	char *cname;
	int argc;
	char **argv;
d555 1
a555 2
parse_element_type(cp)
	char *cp;
d567 1
a567 2
parse_element_unit(cp)
	char *cp;
d580 1
a580 2
parse_special(cp)
	char *cp;
d592 1
a592 2
is_special(cp)
	char *cp;
d604 1
a604 3
bits_to_string(v, cp)
	int v;
	const char *cp;
d630 1
a630 9
cleanup()
{

	/* Simple enough... */
	(void)close(changer_fd);
}

static void
usage()
@


1.9
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.8 1998/06/23 18:26:36 millert Exp $	*/
d53 15
a67 15
static	void usage __P((void));
static	void cleanup __P((void));
static	int parse_element_type __P((char *));
static	int parse_element_unit __P((char *));
static	int parse_special __P((char *));
static	int is_special __P((char *));
static	char *bits_to_string __P((int, const char *));

static	int do_move __P((char *, int, char **));
static	int do_exchange __P((char *, int, char **));
static	int do_position __P((char *, int, char **));
static	int do_params __P((char *, int, char **));
static	int do_getpicker __P((char *, int, char **));
static	int do_setpicker __P((char *, int, char **));
static	int do_status __P((char *, int, char **));
@


1.8
log
@snprintf returns bytes it wanted to print, not the number it actually did
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.7 1997/11/08 23:22:40 todd Exp $	*/
a641 1
	size_t n;
d653 1
a653 1
			       "%c%.*s", sep, np - cp, cp);
@


1.7
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.6 1997/09/01 18:29:12 deraadt Exp $	*/
d642 1
d653 1
a653 1
		bp += snprintf(bp, sizeof(buf) - (bp - &buf[0]),
d655 1
@


1.6
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.5 1996/12/14 12:17:35 mickey Exp $	*/
d17 1
a17 1
 *    must display the following acknowledgements:
d388 1
a388 1
		warnx("%s: no arguements expected", cname);
@


1.5
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.4 1996/11/02 03:47:10 deraadt Exp $	*/
d38 1
a38 1
#include <sys/chio.h> 
@


1.4
log
@useful useage, abbreviateable commands
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.3 1996/09/15 21:56:11 millert Exp $	*/
a106 1
	char *cp;
d480 6
a485 1
	char *cmdname, *description;
@


1.3
log
@sprintf -> snprintf paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.2 1996/06/23 14:19:04 deraadt Exp $	*/
d71 1
d73 1
a74 2
	{ "portal",		CHET_IE },
	{ "drive",		CHET_DT },
d80 2
d83 1
a83 1
	{ "exchange",		do_exchange },
a84 2
	{ "params",		do_params },
	{ "getpicker",		do_getpicker },
d142 7
d669 1
d671 6
a676 1
	fprintf(stderr, "usage: %s command arg1 arg2 ...\n", __progname);
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: chio.c,v 1.1.1.1 1996/04/03 00:34:38 thorpej Exp $	*/
d641 2
a642 1
		bp += sprintf(bp, "%c%.*s", sep, np - cp, cp);
@


1.1
log
@Utility to control media changers from the command line; corresponds
to new SCSI changer driver.
@
text
@d1 1
@
