head	1.92;
access;
symbols
	OPENBSD_6_1:1.89.0.4
	OPENBSD_6_1_BASE:1.89
	OPENBSD_6_0:1.84.0.4
	OPENBSD_6_0_BASE:1.84
	OPENBSD_5_9:1.84.0.2
	OPENBSD_5_9_BASE:1.84
	OPENBSD_5_8:1.79.0.6
	OPENBSD_5_8_BASE:1.79
	OPENBSD_5_7:1.79.0.2
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.76.0.4
	OPENBSD_5_6_BASE:1.76
	OPENBSD_5_5:1.71.0.4
	OPENBSD_5_5_BASE:1.71
	OPENBSD_5_4:1.56.0.2
	OPENBSD_5_4_BASE:1.56
	OPENBSD_5_3:1.54.0.2
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.53.0.6
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.4
	OPENBSD_5_0:1.53.0.2
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.52.0.2
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.50.0.8
	OPENBSD_4_8_BASE:1.50
	OPENBSD_4_7:1.50.0.4
	OPENBSD_4_7_BASE:1.50
	OPENBSD_4_6:1.50.0.6
	OPENBSD_4_6_BASE:1.50
	OPENBSD_4_5:1.50.0.2
	OPENBSD_4_5_BASE:1.50
	OPENBSD_4_4:1.49.0.2
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.46.0.2
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.39.0.2
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.9.0.8
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.6
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.6
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.4
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.92
date	2017.09.11.16.35.38;	author millert;	state Exp;
branches;
next	1.91;
commitid	UF6XHt5DweFVYCVc;

1.91
date	2017.05.22.16.00.47;	author deraadt;	state Exp;
branches;
next	1.90;
commitid	28ObyG5itOLioMoQ;

1.90
date	2017.04.26.21.10.42;	author millert;	state Exp;
branches;
next	1.89;
commitid	hJK92PXo0uJ7JxJB;

1.89
date	2016.12.16.17.55.26;	author krw;	state Exp;
branches;
next	1.88;
commitid	aq5Xw68MoNfuzy8C;

1.88
date	2016.12.16.17.44.59;	author krw;	state Exp;
branches;
next	1.87;
commitid	q7MaMOobu9Z5raUb;

1.87
date	2016.09.03.17.01.01;	author tedu;	state Exp;
branches;
next	1.86;
commitid	kjEgOA8VDME59FHg;

1.86
date	2016.08.26.05.50.29;	author guenther;	state Exp;
branches;
next	1.85;
commitid	wCWzBcWw7ZwWxKyz;

1.85
date	2016.07.29.18.35.45;	author tedu;	state Exp;
branches;
next	1.84;
commitid	V5hzBfYGVQSWtRJL;

1.84
date	2015.12.09.19.36.17;	author mmcc;	state Exp;
branches;
next	1.83;
commitid	8oyfVibTyuKjsb15;

1.83
date	2015.10.10.20.18.30;	author deraadt;	state Exp;
branches;
next	1.82;
commitid	QjQod45GFoW0lZGP;

1.82
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.81;
commitid	sbrB3Q5CNxcwZpfU;

1.81
date	2015.10.04.04.56.50;	author deraadt;	state Exp;
branches;
next	1.80;
commitid	eqnuRUvFqXxvWybg;

1.80
date	2015.10.03.03.28.35;	author deraadt;	state Exp;
branches;
next	1.79;
commitid	CSipuwoSUHgmnRFx;

1.79
date	2015.01.19.16.43.28;	author deraadt;	state Exp;
branches;
next	1.78;
commitid	nAkYn3YihBov0iXw;

1.78
date	2015.01.16.06.39.32;	author deraadt;	state Exp;
branches;
next	1.77;
commitid	Uu5nFG3wCl0LACBb;

1.77
date	2014.09.13.16.06.36;	author doug;	state Exp;
branches;
next	1.76;
commitid	jdBY2kKXhfcoQitp;

1.76
date	2014.06.19.15.30.49;	author millert;	state Exp;
branches;
next	1.75;
commitid	5Ha0QdFRaeupCpoa;

1.75
date	2014.03.26.03.16.39;	author lteo;	state Exp;
branches;
next	1.74;

1.74
date	2014.03.20.22.03.56;	author tedu;	state Exp;
branches;
next	1.73;

1.73
date	2014.03.20.20.32.42;	author naddy;	state Exp;
branches;
next	1.72;

1.72
date	2014.03.07.04.10.55;	author lteo;	state Exp;
branches;
next	1.71;

1.71
date	2014.01.15.16.07.27;	author jmc;	state Exp;
branches;
next	1.70;

1.70
date	2014.01.15.04.43.36;	author lteo;	state Exp;
branches;
next	1.69;

1.69
date	2014.01.12.04.37.51;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2014.01.11.04.01.13;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2014.01.10.20.14.08;	author jmc;	state Exp;
branches;
next	1.66;

1.66
date	2014.01.10.18.51.05;	author lteo;	state Exp;
branches;
next	1.65;

1.65
date	2014.01.10.05.34.46;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2014.01.08.16.23.21;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2014.01.08.16.16.44;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2014.01.08.16.13.11;	author millert;	state Exp;
branches;
next	1.61;

1.61
date	2014.01.08.15.54.09;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2014.01.08.14.19.25;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2014.01.08.14.15.54;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2013.12.23.23.00.38;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2013.11.21.15.54.45;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2013.04.15.15.54.17;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2013.03.30.02.42.24;	author lteo;	state Exp;
branches;
next	1.54;

1.54
date	2012.12.04.02.38.51;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2011.07.05.23.39.27;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2010.10.27.15.24.10;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2010.10.25.19.05.52;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2008.09.06.12.01.34;	author djm;	state Exp;
branches;
next	1.49;

1.49
date	2008.07.29.18.24.31;	author sobrado;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.07.09.52.25;	author chl;	state Exp;
branches;
next	1.47;

1.47
date	2007.10.31.20.47.39;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2007.04.14.23.04.10;	author grunk;	state Exp;
branches;
next	1.45;

1.45
date	2007.04.13.13.57.01;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2007.03.29.15.20.51;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2007.03.29.13.02.17;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2007.03.28.11.30.15;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2007.03.27.13.12.41;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2007.03.20.12.06.48;	author thib;	state Exp;
branches;
next	1.39;

1.39
date	2007.01.09.18.06.07;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2006.11.17.16.02.18;	author jmc;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.16.23.53.41;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.10.15.03.44;	author tom;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.15.03.15.07;	author dhill;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.20.02.09.23;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2005.08.17.11.34.16;	author mpf;	state Exp;
branches;
next	1.32;

1.32
date	2004.12.29.17.32.44;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2004.12.10.19.35.53;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.04.18.41.57;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.02.17.53.29;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.28.23.58.41;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.03.22.00.06;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.07.21.00.11.03;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.25.21.23.01;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.17.21.56.23;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.11.23.42.12;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.03.01.52.39;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.28.19.13.51;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.23.16.00.43;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.23.00.31.23;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.13.02.38.22;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.12.21.29.48;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.14.17.15.53;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.20.13.32.04;	author camield;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.06.13.29.08;	author mpech;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.03.18.04.16;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.03.17.02.53;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.02.21.04.53;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.02.20.38.06;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.10.07.16.56.33;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	98.01.02.07.04.23;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.08.01.10.07.11;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.17.05.45.01;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.07.12.21.09.02;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.06.20.20.35.29;	author flipk;	state Exp;
branches;
next	1.3;

1.3
date	96.11.24.02.26.00;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.11.12.23.33.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.11.10.37.38;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.92
log
@Use getrusage(2) for the built-in time trial instead of getttimeofday(2).
This makes it possible to measure just the ellapsed user time, which
is what we really care about when benchmarking an algorithm.
OK deraadt@@
@
text
@/*	$OpenBSD: md5.c,v 1.91 2017/05/22 16:00:47 deraadt Exp $	*/

/*
 * Copyright (c) 2001,2003,2005-2007,2010,2013,2014
 *	Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/queue.h>
#include <sys/resource.h>
#include <netinet/in.h>
#include <ctype.h>
#include <err.h>
#include <fcntl.h>
#include <resolv.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <time.h>
#include <unistd.h>
#include <errno.h>

#include <md5.h>
#include <rmd160.h>
#include <sha1.h>
#include <sha2.h>
#include <crc.h>

#define STYLE_MD5	0
#define STYLE_CKSUM	1
#define STYLE_TERSE	2

#define MAX_DIGEST_LEN	128

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))
#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

union ANY_CTX {
#if !defined(SHA2_ONLY)
	CKSUM_CTX cksum;
	MD5_CTX md5;
	RMD160_CTX rmd160;
	SHA1_CTX sha1;
#endif /* !defined(SHA2_ONLY) */
	SHA2_CTX sha2;
};

struct hash_function {
	const char *name;
	size_t digestlen;
	int style;
	int base64;
	void *ctx;	/* XXX - only used by digest_file() */
	void (*init)(void *);
	void (*update)(void *, const unsigned char *, size_t);
	void (*final)(unsigned char *, void *);
	char * (*end)(void *, char *);
	TAILQ_ENTRY(hash_function) tailq;
} functions[] = {
#if !defined(SHA2_ONLY)
	{
		"CKSUM",
		CKSUM_DIGEST_LENGTH,
		STYLE_CKSUM,
		-1,
		NULL,
		(void (*)(void *))CKSUM_Init,
		(void (*)(void *, const unsigned char *, size_t))CKSUM_Update,
		(void (*)(unsigned char *, void *))CKSUM_Final,
		(char *(*)(void *, char *))CKSUM_End
	},
	{
		"MD5",
		MD5_DIGEST_LENGTH,
		STYLE_MD5,
		0,
		NULL,
		(void (*)(void *))MD5Init,
		(void (*)(void *, const unsigned char *, size_t))MD5Update,
		(void (*)(unsigned char *, void *))MD5Final,
		(char *(*)(void *, char *))MD5End
	},
	{
		"RMD160",
		RMD160_DIGEST_LENGTH,
		STYLE_MD5,
		0,
		NULL,
		(void (*)(void *))RMD160Init,
		(void (*)(void *, const unsigned char *, size_t))RMD160Update,
		(void (*)(unsigned char *, void *))RMD160Final,
		(char *(*)(void *, char *))RMD160End
	},
	{
		"SHA1",
		SHA1_DIGEST_LENGTH,
		STYLE_MD5,
		0,
		NULL,
		(void (*)(void *))SHA1Init,
		(void (*)(void *, const unsigned char *, size_t))SHA1Update,
		(void (*)(unsigned char *, void *))SHA1Final,
		(char *(*)(void *, char *))SHA1End
	},
	{
		"SHA224",
		SHA224_DIGEST_LENGTH,
		STYLE_MD5,
		0,
		NULL,
		(void (*)(void *))SHA224Init,
		(void (*)(void *, const unsigned char *, size_t))SHA224Update,
		(void (*)(unsigned char *, void *))SHA224Final,
		(char *(*)(void *, char *))SHA224End
	},
#endif /* !defined(SHA2_ONLY) */
	{
		"SHA256",
		SHA256_DIGEST_LENGTH,
		STYLE_MD5,
		0,
		NULL,
		(void (*)(void *))SHA256Init,
		(void (*)(void *, const unsigned char *, size_t))SHA256Update,
		(void (*)(unsigned char *, void *))SHA256Final,
		(char *(*)(void *, char *))SHA256End
	},
#if !defined(SHA2_ONLY)
	{
		"SHA384",
		SHA384_DIGEST_LENGTH,
		STYLE_MD5,
		0,
		NULL,
		(void (*)(void *))SHA384Init,
		(void (*)(void *, const unsigned char *, size_t))SHA384Update,
		(void (*)(unsigned char *, void *))SHA384Final,
		(char *(*)(void *, char *))SHA384End
	},
	{
		"SHA512/256",
		SHA512_256_DIGEST_LENGTH,
		STYLE_MD5,
		0,
		NULL,
		(void (*)(void *))SHA512_256Init,
		(void (*)(void *, const unsigned char *, size_t))SHA512_256Update,
		(void (*)(unsigned char *, void *))SHA512_256Final,
		(char *(*)(void *, char *))SHA512_256End
	},
#endif /* !defined(SHA2_ONLY) */
	{
		"SHA512",
		SHA512_DIGEST_LENGTH,
		STYLE_MD5,
		0,
		NULL,
		(void (*)(void *))SHA512Init,
		(void (*)(void *, const unsigned char *, size_t))SHA512Update,
		(void (*)(unsigned char *, void *))SHA512Final,
		(char *(*)(void *, char *))SHA512End
	},
	{
		NULL,
	}
};

TAILQ_HEAD(hash_list, hash_function);

void digest_end(const struct hash_function *, void *, char *, size_t, int);
int  digest_file(const char *, struct hash_list *, int);
void digest_print(const struct hash_function *, const char *, const char *);
#if !defined(SHA2_ONLY)
int  digest_filelist(const char *, struct hash_function *, int, char **);
void digest_printstr(const struct hash_function *, const char *, const char *);
void digest_string(char *, struct hash_list *);
void digest_test(struct hash_list *);
void digest_time(struct hash_list *, int);
#endif /* !defined(SHA2_ONLY) */
void hash_insert(struct hash_list *, struct hash_function *, int);
void usage(void) __attribute__((__noreturn__));

extern char *__progname;
int qflag = 0;
FILE *ofile = NULL;

int
main(int argc, char **argv)
{
	struct hash_function *hf, *hftmp;
	struct hash_list hl;
	size_t len;
	char *cp, *input_string, *selective_checklist;
	const char *optstr;
	int fl, error, base64;
	int bflag, cflag, pflag, rflag, tflag, xflag;

	if (pledge("stdio rpath wpath cpath", NULL) == -1)
		err(1, "pledge");

	TAILQ_INIT(&hl);
	input_string = NULL;
	selective_checklist = NULL;
	error = bflag = cflag = pflag = qflag = rflag = tflag = xflag = 0;

#if !defined(SHA2_ONLY)
	if (strcmp(__progname, "cksum") == 0)
		optstr = "a:bC:ch:pqrs:tx";
	else
#endif /* !defined(SHA2_ONLY) */
		optstr = "bC:ch:pqrs:tx";

	/* Check for -b option early since it changes behavior. */
	while ((fl = getopt(argc, argv, optstr)) != -1) {
		switch (fl) {
		case 'b':
			bflag = 1;
			break;
		case '?':
			usage();
		}
	}
	optind = 1;
	optreset = 1;
	while ((fl = getopt(argc, argv, optstr)) != -1) {
		switch (fl) {
		case 'a':
			while ((cp = strsep(&optarg, " \t,")) != NULL) {
				if (*cp == '\0')
					continue;
				base64 = -1;
				for (hf = functions; hf->name != NULL; hf++) {
					len = strlen(hf->name);
					if (strncasecmp(cp, hf->name, len) != 0)
						continue;
					if (cp[len] == '\0') {
						if (hf->base64 != -1)
							base64 = bflag;
						break;	/* exact match */
					}
					if (cp[len + 1] == '\0' &&
					    (cp[len] == 'b' || cp[len] == 'x')) {
						base64 =
						    cp[len] == 'b' ?  1 : 0;
						break;	/* match w/ suffix */
					}
				}
				if (hf->name == NULL) {
					warnx("unknown algorithm \"%s\"", cp);
					usage();
				}
				if (hf->base64 == -1 && base64 != -1) {
					warnx("%s doesn't support %s",
					    hf->name,
					    base64 ? "base64" : "hex");
					usage();
				}
				/* Check for dupes. */
				TAILQ_FOREACH(hftmp, &hl, tailq) {
					if (hftmp->base64 == base64 &&
					    strcmp(hf->name, hftmp->name) == 0)
						break;
				}
				if (hftmp == NULL)
					hash_insert(&hl, hf, base64);
			}
			break;
		case 'b':
			/* has already been parsed */
			break;
		case 'h':
			ofile = fopen(optarg, "w");
			if (ofile == NULL)
				err(1, "%s", optarg);
			break;
#if !defined(SHA2_ONLY)
		case 'C':
			selective_checklist = optarg;
			break;
		case 'c':
			cflag = 1;
			break;
#endif /* !defined(SHA2_ONLY) */
		case 'p':
			pflag = 1;
			break;
		case 'q':
			qflag = 1;
			break;
		case 'r':
			rflag = 1;
			break;
		case 's':
			input_string = optarg;
			break;
		case 't':
			tflag++;
			break;
		case 'x':
			xflag = 1;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (ofile == NULL)
		ofile = stdout;

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	/* Most arguments are mutually exclusive */
	fl = pflag + (tflag ? 1 : 0) + xflag + cflag + (input_string != NULL);
	if (fl > 1 || (fl && argc && cflag == 0) || (rflag && qflag) ||
	    (selective_checklist != NULL && argc == 0))
		usage();
	if (selective_checklist || cflag) {
		if (TAILQ_FIRST(&hl) != TAILQ_LAST(&hl, hash_list))
			errx(1, "only a single algorithm may be specified "
			    "in -C or -c mode");
	}

	/* No algorithm specified, check the name we were called as. */
	if (TAILQ_EMPTY(&hl)) {
		for (hf = functions; hf->name != NULL; hf++) {
			if (strcasecmp(hf->name, __progname) == 0)
				break;
		}
		if (hf->name == NULL)
			hf = &functions[0];	/* default to cksum */
		hash_insert(&hl, hf, (hf->base64 == -1 ? 0 : bflag));
	}

	if (rflag || qflag) {
		const int new_style = rflag ? STYLE_CKSUM : STYLE_TERSE;
		TAILQ_FOREACH(hf, &hl, tailq) {
			hf->style = new_style;
		}
	}

#if !defined(SHA2_ONLY)
	if (tflag)
		digest_time(&hl, tflag);
	else if (xflag)
		digest_test(&hl);
	else if (input_string)
		digest_string(input_string, &hl);
	else if (selective_checklist) {
		int i;

		error = digest_filelist(selective_checklist, TAILQ_FIRST(&hl),
		    argc, argv);
		for (i = 0; i < argc; i++) {
			if (argv[i] != NULL) {
				warnx("%s does not exist in %s", argv[i],
				    selective_checklist);
				error++;
			}
		}
	} else if (cflag) {
		if (argc == 0)
			error = digest_filelist("-", TAILQ_FIRST(&hl), 0, NULL);
		else
			while (argc--)
				error += digest_filelist(*argv++,
				    TAILQ_FIRST(&hl), 0, NULL);
	} else
#endif /* !defined(SHA2_ONLY) */
	if (pflag || argc == 0)
		error = digest_file("-", &hl, pflag);
	else
		while (argc--)
			error += digest_file(*argv++, &hl, 0);

	return(error ? EXIT_FAILURE : EXIT_SUCCESS);
}

void
hash_insert(struct hash_list *hl, struct hash_function *hf, int base64)
{
	struct hash_function *hftmp;

	hftmp = malloc(sizeof(*hftmp));
	if (hftmp == NULL)
		err(1, NULL);
	*hftmp = *hf;
	hftmp->base64 = base64;
	TAILQ_INSERT_TAIL(hl, hftmp, tailq);
}

void
digest_end(const struct hash_function *hf, void *ctx, char *buf, size_t bsize,
    int base64)
{
	u_char *digest;

	if (base64 == 1) {
		if ((digest = malloc(hf->digestlen)) == NULL)
			err(1, NULL);
		hf->final(digest, ctx);
		if (b64_ntop(digest, hf->digestlen, buf, bsize) == -1)
			errx(1, "error encoding base64");
		freezero(digest, hf->digestlen);
	} else {
		hf->end(ctx, buf);
	}
}

#if !defined(SHA2_ONLY)
void
digest_string(char *string, struct hash_list *hl)
{
	struct hash_function *hf;
	char digest[MAX_DIGEST_LEN + 1];
	union ANY_CTX context;

	TAILQ_FOREACH(hf, hl, tailq) {
		hf->init(&context);
		hf->update(&context, string, strlen(string));
		digest_end(hf, &context, digest, sizeof(digest),
		    hf->base64);
		digest_printstr(hf, string, digest);
	}
}
#endif /* !defined(SHA2_ONLY) */

void
digest_print(const struct hash_function *hf, const char *what,
    const char *digest)
{
	switch (hf->style) {
	case STYLE_MD5:
		(void)fprintf(ofile, "%s (%s) = %s\n", hf->name, what, digest);
		break;
	case STYLE_CKSUM:
		(void)fprintf(ofile, "%s %s\n", digest, what);
		break;
	case STYLE_TERSE:
		(void)fprintf(ofile, "%s\n", digest);
		break;
	}
}

#if !defined(SHA2_ONLY)
void
digest_printstr(const struct hash_function *hf, const char *what,
    const char *digest)
{
	switch (hf->style) {
	case STYLE_MD5:
		(void)fprintf(ofile, "%s (\"%s\") = %s\n", hf->name, what, digest);
		break;
	case STYLE_CKSUM:
		(void)fprintf(ofile, "%s %s\n", digest, what);
		break;
	case STYLE_TERSE:
		(void)fprintf(ofile, "%s\n", digest);
		break;
	}
}
#endif /* !defined(SHA2_ONLY) */

int
digest_file(const char *file, struct hash_list *hl, int echo)
{
	struct hash_function *hf;
	FILE *fp;
	size_t nread;
	u_char data[32 * 1024];
	char digest[MAX_DIGEST_LEN + 1];

	if (strcmp(file, "-") == 0)
		fp = stdin;
	else if ((fp = fopen(file, "r")) == NULL) {
		warn("cannot open %s", file);
		return(1);
	}

	TAILQ_FOREACH(hf, hl, tailq) {
		if ((hf->ctx = malloc(sizeof(union ANY_CTX))) == NULL)
			err(1, NULL);
		hf->init(hf->ctx);
	}
	while ((nread = fread(data, 1UL, sizeof(data), fp)) != 0) {
		if (echo) {
			(void)fwrite(data, nread, 1UL, stdout);
			if (fflush(stdout) != 0)
				err(1, "stdout: write error");
		}
		TAILQ_FOREACH(hf, hl, tailq)
			hf->update(hf->ctx, data, nread);
	}
	if (ferror(fp)) {
		warn("%s: read error", file);
		if (fp != stdin)
			fclose(fp);
		TAILQ_FOREACH(hf, hl, tailq) {
			free(hf->ctx);
			hf->ctx = NULL;
		}
		return(1);
	}
	if (fp != stdin)
		fclose(fp);
	TAILQ_FOREACH(hf, hl, tailq) {
		digest_end(hf, hf->ctx, digest, sizeof(digest), hf->base64);
		free(hf->ctx);
		hf->ctx = NULL;
		if (fp == stdin)
			fprintf(ofile, "%s\n", digest);
		else
			digest_print(hf, file, digest);
	}
	return(0);
}

#if !defined(SHA2_ONLY)
/*
 * Parse through the input file looking for valid lines.
 * If one is found, use this checksum and file as a reference and
 * generate a new checksum against the file on the filesystem.
 * Print out the result of each comparison.
 */
int
digest_filelist(const char *file, struct hash_function *defhash, int selcount,
    char **sel)
{
	int found, base64, error, cmp, i;
	size_t algorithm_max, algorithm_min;
	const char *algorithm;
	char *filename, *checksum, *buf, *p;
	char digest[MAX_DIGEST_LEN + 1];
	char *lbuf = NULL;
	FILE *listfp, *fp;
	size_t len, nread;
	int *sel_found = NULL;
	u_char data[32 * 1024];
	union ANY_CTX context;
	struct hash_function *hf;

	if (strcmp(file, "-") == 0) {
		listfp = stdin;
	} else if ((listfp = fopen(file, "r")) == NULL) {
		warn("cannot open %s", file);
		return(1);
	}

	if (sel != NULL) {
		sel_found = calloc((size_t)selcount, sizeof(*sel_found));
		if (sel_found == NULL)
			err(1, NULL);
	}

	algorithm_max = algorithm_min = strlen(functions[0].name);
	for (hf = &functions[1]; hf->name != NULL; hf++) {
		len = strlen(hf->name);
		algorithm_max = MAXIMUM(algorithm_max, len);
		algorithm_min = MINIMUM(algorithm_min, len);
	}

	error = found = 0;
	while ((buf = fgetln(listfp, &len))) {
		base64 = 0;
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else {
			if ((lbuf = malloc(len + 1)) == NULL)
				err(1, NULL);

			(void)memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}
		while (isspace((unsigned char)*buf))
			buf++;

		/*
		 * Crack the line into an algorithm, filename, and checksum.
		 * Lines are of the form:
		 *  ALGORITHM (FILENAME) = CHECKSUM
		 *
		 * Fallback on GNU form:
		 *  CHECKSUM  FILENAME
		 */
		p = strchr(buf, ' ');
		if (p != NULL && *(p + 1) == '(') {
			/* BSD form */
			*p = '\0';
			algorithm = buf;
			len = strlen(algorithm);
			if (len > algorithm_max || len < algorithm_min)
				continue;

			filename = p + 2;
			p = strrchr(filename, ')');
			if (p == NULL || strncmp(p + 1, " = ", (size_t)3) != 0)
				continue;
			*p = '\0';

			checksum = p + 4;
			p = strpbrk(checksum, " \t\r");
			if (p != NULL)
				*p = '\0';

			/*
			 * Check that the algorithm is one we recognize.
			 */
			for (hf = functions; hf->name != NULL; hf++) {
				if (strcasecmp(algorithm, hf->name) == 0)
					break;
			}
			if (hf->name == NULL || *checksum == '\0')
				continue;
			/*
			 * Check the length to see if this could be
			 * a valid checksum.  If hex, it will be 2x the
			 * size of the binary data.  For base64, we have
			 * to check both with and without the '=' padding.
			 */
			len = strlen(checksum);
			if (len != hf->digestlen * 2) {
				size_t len2;

				if (checksum[len - 1] == '=') {
					/* use padding */
					len2 = 4 * ((hf->digestlen + 2) / 3);
				} else {
					/* no padding */
					len2 = (4 * hf->digestlen + 2) / 3;
				}
				if (len != len2)
					continue;
				base64 = 1;
			}
		} else {
			/* could be GNU form */
			if ((hf = defhash) == NULL)
				continue;
			algorithm = hf->name;
			checksum = buf;
			if ((p = strchr(checksum, ' ')) == NULL)
				continue;
			if (hf->style == STYLE_CKSUM) {
				if ((p = strchr(p + 1, ' ')) == NULL)
					continue;
			}
			*p++ = '\0';
			while (isspace((unsigned char)*p))
				p++;
			if (*p == '\0')
				continue;
			filename = p;
			p = strpbrk(filename, "\t\r");
			if (p != NULL)
				*p = '\0';
		}
		found = 1;

		/*
		 * If only a selection of files is wanted, proceed only
		 * if the filename matches one of those in the selection.
		 */
		if (sel != NULL) {
			for (i = 0; i < selcount; i++) {
				if (strcmp(sel[i], filename) == 0) {
					sel_found[i] = 1;
					break;
				}
			}
			if (i == selcount)
				continue;
		}

		if ((fp = fopen(filename, "r")) == NULL) {
			warn("cannot open %s", filename);
			(void)printf("(%s) %s: %s\n", algorithm, filename,
			    (errno == ENOENT ? "MISSING" : "FAILED"));
			error = 1;
			continue;
		}

		hf->init(&context);
		while ((nread = fread(data, 1UL, sizeof(data), fp)) > 0)
			hf->update(&context, data, nread);
		if (ferror(fp)) {
			warn("%s: read error", file);
			error = 1;
			fclose(fp);
			continue;
		}
		fclose(fp);
		digest_end(hf, &context, digest, sizeof(digest), base64);

		if (base64)
			cmp = strncmp(checksum, digest, len);
		else
			cmp = strcasecmp(checksum, digest);
		if (cmp == 0) {
			if (qflag == 0)
				(void)printf("(%s) %s: OK\n", algorithm,
				    filename);
		} else {
			(void)printf("(%s) %s: FAILED\n", algorithm, filename);
			error = 1;
		}
	}
	if (listfp != stdin)
		fclose(listfp);
	if (!found)
		warnx("%s: no properly formatted checksum lines found", file);
	free(lbuf);
	if (sel_found != NULL) {
		/*
		 * Mark found files by setting them to NULL so that we can
		 * detect files that are missing from the checklist later.
		 */
		for (i = 0; i < selcount; i++) {
			if (sel_found[i])
				sel[i] = NULL;
		}
		free(sel_found);
	}
	return(error || !found);
}

#define TEST_BLOCK_LEN 10000
#define TEST_BLOCK_COUNT 10000

void
digest_time(struct hash_list *hl, int times)
{
	struct hash_function *hf;
	struct rusage start, stop;
	struct timeval res;
	union ANY_CTX context;
	u_int i;
	u_char data[TEST_BLOCK_LEN];
	char digest[MAX_DIGEST_LEN + 1];
	double elapsed;
	int count = TEST_BLOCK_COUNT;
	while (--times > 0 && count < INT_MAX / 10)
		count *= 10;

	TAILQ_FOREACH(hf, hl, tailq) {
		(void)printf("%s time trial.  Processing %d %d-byte blocks...",
		    hf->name, count, TEST_BLOCK_LEN);
		fflush(stdout);

		/* Initialize data based on block number. */
		for (i = 0; i < TEST_BLOCK_LEN; i++)
			data[i] = (u_char)(i & 0xff);

		getrusage(RUSAGE_SELF, &start);
		hf->init(&context);
		for (i = 0; i < count; i++)
			hf->update(&context, data, (size_t)TEST_BLOCK_LEN);
		digest_end(hf, &context, digest, sizeof(digest), hf->base64);
		getrusage(RUSAGE_SELF, &stop);
		timersub(&stop.ru_utime, &start.ru_utime, &res);
		elapsed = res.tv_sec + res.tv_usec / 1000000.0;

		(void)printf("\nDigest = %s\n", digest);
		(void)printf("Time   = %f seconds\n", elapsed);
		(void)printf("Speed  = %f bytes/second\n",
		    (double)TEST_BLOCK_LEN * count / elapsed);
	}
}

void
digest_test(struct hash_list *hl)
{
	struct hash_function *hf;
	union ANY_CTX context;
	int i;
	char digest[MAX_DIGEST_LEN + 1];
	unsigned char buf[1000];
	unsigned const char *test_strings[] = {
		"",
		"a",
		"abc",
		"message digest",
		"abcdefghijklmnopqrstuvwxyz",
		"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
		    "0123456789",
		"12345678901234567890123456789012345678901234567890123456789"
		    "012345678901234567890",
	};

	TAILQ_FOREACH(hf, hl, tailq) {
		(void)printf("%s test suite:\n", hf->name);

		for (i = 0; i < 8; i++) {
			hf->init(&context);
			hf->update(&context, test_strings[i],
			    strlen(test_strings[i]));
			digest_end(hf, &context, digest, sizeof(digest),
			    hf->base64);
			digest_printstr(hf, test_strings[i], digest);
		}

		/* Now simulate a string of a million 'a' characters. */
		memset(buf, 'a', sizeof(buf));
		hf->init(&context);
		for (i = 0; i < 1000; i++)
			hf->update(&context, buf, sizeof(buf));
		digest_end(hf, &context, digest, sizeof(digest), hf->base64);
		digest_print(hf, "one million 'a' characters",
		    digest);
	}
}
#endif /* !defined(SHA2_ONLY) */

void
usage(void)
{
#if !defined(SHA2_ONLY)
	if (strcmp(__progname, "cksum") == 0)
		fprintf(stderr, "usage: %s [-bcpqrtx] [-a algorithms] [-C checklist] "
		    "[-h hashfile]\n"
		    "	[-s string] [file ...]\n",
		    __progname);
	else
#endif /* !defined(SHA2_ONLY) */
		fprintf(stderr, "usage:"
		    "\t%s [-bcpqrtx] [-C checklist] [-h hashfile] [-s string] "
		    "[file ...]\n",
		    __progname);

	exit(EXIT_FAILURE);
}
@


1.91
log
@obvious use for freezero()
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.90 2017/04/26 21:10:42 millert Exp $	*/
d27 1
d754 2
a755 1
	struct timeval start, stop, res;
d774 1
a774 1
		gettimeofday(&start, NULL);
d779 2
a780 2
		gettimeofday(&stop, NULL);
		timersub(&stop, &start, &res);
@


1.90
log
@In -C mode, process all checksums that match the specified file(s),
not just the first one that matches.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.89 2016/12/16 17:55:26 krw Exp $	*/
d423 1
a423 2
		memset(digest, 0, hf->digestlen);
		free(digest);
@


1.89
log
@Move declaration of an 'i' inside the scope of its use. Which in
turn is inside an #ifdef. Thus making the code clearer by eliminating
an #ifdef in the middle of the declarations.

Suggested by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.88 2016/12/16 17:44:59 krw Exp $	*/
d557 1
d569 6
a682 2
		 * Mark found files by setting them to NULL so that we can
		 * detect files that are missing from the checklist later.
d684 1
a684 1
		if (sel) {
d686 2
a687 2
				if (sel[i] && strcmp(sel[i], filename) == 0) {
					sel[i] = NULL;
d733 11
@


1.88
log
@Eliminate some gcc warnings about 'unused variables', mostly by
adding appropriate #ifdef's around declarations.

ok millert@@ (with a tweak I will commit separately)
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.87 2016/09/03 17:01:01 tedu Exp $	*/
a212 3
#if !defined(SHA2_ONLY)
	int i;
#endif
d369 2
@


1.87
log
@add sha512/256 support to check that the libc code is right :)
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.86 2016/08/26 05:50:29 guenther Exp $	*/
d212 4
a215 1
	int fl, error, base64, i;
@


1.86
log
@Pull in <sys/time.h> for gettimeofday()
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.85 2016/07/29 18:35:45 tedu Exp $	*/
d156 11
@


1.85
log
@all of the update functions take a size_t. correct type and casts.
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.84 2015/12/09 19:36:17 mmcc Exp $	*/
d25 1
@


1.84
log
@Remove NULL-check before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.83 2015/10/10 20:18:30 deraadt Exp $	*/
d71 1
a71 1
	void (*update)(void *, const unsigned char *, unsigned int);
d84 1
a84 1
		(void (*)(void *, const unsigned char *, unsigned int))CKSUM_Update,
d95 1
a95 1
		(void (*)(void *, const unsigned char *, unsigned int))MD5Update,
d106 1
a106 1
		(void (*)(void *, const unsigned char *, unsigned int))RMD160Update,
d117 1
a117 1
		(void (*)(void *, const unsigned char *, unsigned int))SHA1Update,
d128 1
a128 1
		(void (*)(void *, const unsigned char *, unsigned int))SHA224Update,
d140 1
a140 1
		(void (*)(void *, const unsigned char *, unsigned int))SHA256Update,
d152 1
a152 1
		(void (*)(void *, const unsigned char *, unsigned int))SHA384Update,
d164 1
a164 1
		(void (*)(void *, const unsigned char *, unsigned int))SHA512Update,
d426 1
a426 1
		hf->update(&context, string, (unsigned int)strlen(string));
d498 1
a498 1
			hf->update(hf->ctx, data, (unsigned int)nread);
d686 1
a686 1
			hf->update(&context, data, (unsigned int)nread);
d746 1
a746 1
			hf->update(&context, data, TEST_BLOCK_LEN);
d785 2
a786 2
			hf->update((void *)&context, test_strings[i],
			    (unsigned int)strlen(test_strings[i]));
d796 1
a796 2
			hf->update(&context, buf,
			    (unsigned int)sizeof(buf));
@


1.83
log
@normalize the ordering of tame requests (particularily, "rpath wpath cpath",
which i have put in that order). this is not important, but helps look
for outliers which might be strange.  it hints that "ioctl" should be
reassessed in a few places, to see if "tty" is better; that "unix" may
be used in some places where "route" could now work.
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.82 2015/10/09 01:37:06 deraadt Exp $	*/
d713 1
a713 2
	if (lbuf != NULL)
		free(lbuf);
@


1.82
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.81 2015/10/04 04:56:50 deraadt Exp $	*/
d203 1
a203 1
	if (pledge("stdio cpath rpath wpath", NULL) == -1)
@


1.81
log
@Repair tame() error check to be == -1
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.80 2015/10/03 03:28:35 deraadt Exp $	*/
d203 2
a204 2
	if (tame("stdio cpath rpath wpath", NULL) == -1)
		err(1, "tame");
d317 2
a318 2
	if (tame("stdio rpath", NULL) == -1)
		err(1, "tame");
@


1.80
log
@right at startup, this can tame "stdio cpath rpath wpath".  after getopt
-h has handled write/creating a file, we can drop to tame "stdio rpath"
since md5 will only read files after that.
i believe i involved lteo for this.
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.79 2015/01/19 16:43:28 deraadt Exp $	*/
d317 1
a317 1
	if (tame("stdio rpath", NULL) != 0)
@


1.79
log
@cleanup of the SMALL hiding from Mathias Svensson
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.78 2015/01/16 06:39:32 deraadt Exp $	*/
d203 3
d316 3
@


1.78
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.77 2014/09/13 16:06:36 doug Exp $	*/
a176 1
int  digest_filelist(const char *, struct hash_function *, int, char **);
d179 1
d445 1
d462 1
@


1.77
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.76 2014/06/19 15:30:49 millert Exp $	*/
d51 2
a52 2
#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))
d549 2
a550 2
		algorithm_max = MAX(algorithm_max, len);
		algorithm_min = MIN(algorithm_min, len);
@


1.76
log
@Fix memory leak in digest_file() on ferror().  OK tedu@@ lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.75 2014/03/26 03:16:39 lteo Exp $	*/
d266 1
a266 1
				if (hftmp == TAILQ_END(&hl))
@


1.75
log
@Ignore the -b option if cksum is called as-is (e.g. "cksum -b /bsd")
as documented on the cksum(1) man page.

"looks right" deraadt@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.74 2014/03/20 22:03:56 tedu Exp $	*/
d496 4
@


1.74
log
@purge sum and sysvsum code. ok deraadt jmc lteo millert
a few initial leftovers spotted by naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.73 2014/03/20 20:32:42 naddy Exp $	*/
d333 1
a333 1
		hash_insert(&hl, hf, bflag);
@


1.73
log
@remove insecure MD4 checksum algorithm; ok tedu@@, man page ok jmc@@

"A collision attack published in 2007 can find collisions for full
MD4 in less than two hash operations."
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.72 2014/03/07 04:10:55 lteo Exp $	*/
a55 2
	SUM_CTX sum;
	SYSVSUM_CTX sysvsum;
a88 22
		"SUM",
		SUM_DIGEST_LENGTH,
		STYLE_CKSUM,
		-1,
		NULL,
		(void (*)(void *))SUM_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SUM_Update,
		(void (*)(unsigned char *, void *))SUM_Final,
		(char *(*)(void *, char *))SUM_End
	},
	{
		"SYSVSUM",
		SYSVSUM_DIGEST_LENGTH,
		STYLE_CKSUM,
		-1,
		NULL,
		(void (*)(void *))SYSVSUM_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SYSVSUM_Update,
		(void (*)(unsigned char *, void *))SYSVSUM_Final,
		(char *(*)(void *, char *))SYSVSUM_End
	},
	{
d209 2
a210 2
	if (strcmp(__progname, "cksum") == 0 || strcmp(__progname, "sum") == 0)
		optstr = "a:bC:ch:o:pqrs:tx";
a284 17
		case 'o':
			if (strcmp(optarg, "1") == 0)
				hf = &functions[1];
			else if (strcmp(optarg, "2") == 0)
				hf = &functions[2];
			else {
				warnx("illegal argument to -o option");
				usage();
			}
			/* Check for dupes. */
			TAILQ_FOREACH(hftmp, &hl, tailq) {
				if (strcmp(hf->name, hftmp->name) == 0)
					break;
			}
			if (hftmp == TAILQ_END(&hl))
				hash_insert(&hl, hf, 0);
			break;
d798 1
a798 1
	if (strcmp(__progname, "cksum") == 0 || strcmp(__progname, "sum") == 0)
d800 1
a800 1
		    "[-h hashfile] [-o 1 | 2]\n"
@


1.72
log
@When using the -C option, exit with an exit status of 1 if any of the
files specified on the command line do not exist in the checklist.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.71 2014/01/15 16:07:27 jmc Exp $	*/
a38 1
#include <md4.h>
a58 1
	MD4_CTX md4;
a112 10
		"MD4",
		MD4_DIGEST_LENGTH,
		STYLE_MD5,
		0,
		NULL,
		(void (*)(void *))MD4Init,
		(void (*)(void *, const unsigned char *, unsigned int))MD4Update,
		(void (*)(unsigned char *, void *))MD4Final,
		(char *(*)(void *, char *))MD4End
	}, {
@


1.71
log
@add -C to the man page, and adjust usage();
ok lteo
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.70 2014/01/15 04:43:36 lteo Exp $	*/
d213 1
a213 1
int  digest_filelist(const char *, struct hash_function *, char **);
d236 1
a236 1
	int fl, error, base64;
d403 11
a413 3
	else if (selective_checklist)
		error = digest_filelist(selective_checklist, TAILQ_FIRST(&hl), argv);
	else if (cflag) {
d415 1
a415 1
			error = digest_filelist("-", TAILQ_FIRST(&hl), NULL);
d419 1
a419 1
				    TAILQ_FIRST(&hl), NULL);
d573 2
a574 1
digest_filelist(const char *file, struct hash_function *defhash, char **sel)
d576 1
a576 1
	int found, base64, error, cmp;
d579 1
a579 1
	char *filename, *checksum, *buf, *p, **sp;
d703 2
d707 3
a709 2
			for (sp = sel; *sp; sp++) {
				if (strcmp(*sp, filename) == 0)
d711 1
d713 1
a713 1
			if (*sp == NULL)
@


1.70
log
@Add support for a -C option.  It works on a checklist like -c but only
does the checksum comparison for selected files that are specified on
the command line.

idea discussed with deraadt@@ and tedu@@
manpage feedback jmc@@
feedback/OK deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.69 2014/01/12 04:37:51 deraadt Exp $	*/
d839 3
a841 3
		fprintf(stderr, "usage: %s [-bcpqrtx] [-C checklist] [-a algorithms] "
		    "[-h hashfile] [-o 1 | 2] [-s string]\n"
		    "	[file ...]\n",
@


1.69
log
@Also move case 'c' into the #ifdef for a smaller binary.  It will fall into
default, giving a nice failure.  I have not removed -c from the usage()
or getopt() because it is too much butchering...
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.68 2014/01/11 04:01:13 deraadt Exp $	*/
d213 1
a213 1
int  digest_filelist(const char *, struct hash_function *);
d234 1
a234 1
	char *cp, *input_string;
d241 1
d246 1
a246 1
		optstr = "a:bch:o:pqrs:tx";
d249 1
a249 1
		optstr = "bch:pqrs:tx";
d315 3
d369 2
a370 1
	if (fl > 1 || (fl && argc && cflag == 0) || (rflag && qflag))
d372 1
a372 1
	if (cflag != 0) {
d375 1
a375 1
			    "in -c mode");
d403 2
d407 1
a407 1
			error = digest_filelist("-", TAILQ_FIRST(&hl));
d411 1
a411 1
				    TAILQ_FIRST(&hl));
d565 1
a565 1
digest_filelist(const char *file, struct hash_function *defhash)
d570 1
a570 1
	char *filename, *checksum, *buf, *p;
d691 13
d839 1
a839 1
		fprintf(stderr, "usage: %s [-bcpqrtx] [-a algorithms] "
d846 2
a847 1
		    "\t%s [-bcpqrtx] [-h hashfile] [-s string] [file ...]\n",
@


1.68
log
@use -DSHA2_ONLY to be more clear about what we are butchering
idea from tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.67 2014/01/10 20:14:08 jmc Exp $	*/
a307 3
		case 'c':
			cflag = 1;
			break;
d314 3
@


1.67
log
@catch up to the fact that md5/sha* got merged, and document -c consistently;
some style and cleanup tweaks while here

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.66 2014/01/10 18:51:05 lteo Exp $	*/
d56 1
a56 1
#if !defined(SMALL)
d64 1
a64 1
#endif /* !defined(SMALL) */
d80 1
a80 1
#if !defined(SMALL)
d168 1
a168 1
#endif /* !defined(SMALL) */
d180 1
a180 1
#if !defined(SMALL)
d192 1
a192 1
#endif /* !defined(SMALL) */
d215 1
a215 1
#if !defined(SMALL)
d220 1
a220 1
#endif /* !defined(SMALL) */
d243 1
a243 1
#if !defined(SMALL)
d247 1
a247 1
#endif /* !defined(SMALL) */
d316 1
a316 1
#if !defined(SMALL)
d334 1
a334 1
#endif /* !defined(SMALL) */
d391 1
a391 1
#if !defined(SMALL)
d406 1
a406 1
#endif /* !defined(SMALL) */
d448 1
a448 1
#if !defined(SMALL)
d464 1
a464 1
#endif /* !defined(SMALL) */
d550 1
a550 1
#if !defined(SMALL)
d812 1
a812 1
#endif /* !defined(SMALL) */
d817 1
a817 1
#if !defined(SMALL)
d824 1
a824 1
#endif /* !defined(SMALL) */
@


1.66
log
@When using a checklist, print MISSING for non-existent files.

Based on an earlier diff by tedu@@
Requested by deraadt@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.65 2014/01/10 05:34:46 tedu Exp $	*/
d819 4
a822 4
		fprintf(stderr, "usage: %s [-bpqrtx] [-a algorithms] "
		    "[-c [checklist ...]] [-h hashfile]\n"
		    "       %*s [-o 1 | 2] [-s string] [file ...]\n",
		    __progname, (int)strlen(__progname), "");
d826 2
a827 3
		    "\t%s [-bprtx] [-h hashfile] [-s string] [file ...]\n"
		    "\t%s [-q] -c [checklist ...]\n",
		    __progname, __progname);
@


1.65
log
@the -c option is really a mode change, incompatible with other options.
(there are some others too, but -c is particularly misleading.) split it
out in synopsis and usage.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.64 2014/01/08 16:23:21 millert Exp $	*/
d37 1
d686 2
a687 1
			(void)printf("(%s) %s: FAILED\n", algorithm, filename);
@


1.64
log
@Fix wrapping of usage message for cksum.
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.63 2014/01/08 16:16:44 millert Exp $	*/
d823 4
a826 2
		fprintf(stderr, "usage: %s [-bpqrtx] [-c [checklist ...]] "
		    "[-h hashfile] [-s string] [file ...]\n", __progname);
@


1.63
log
@err() not errx() when fopen fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.61 2014/01/08 15:54:09 millert Exp $	*/
d818 2
a819 2
		    "[-c [checklist ...]] [-h hashfile] [-o 1 | 2]\n"
		    "       %*s [-s string] [file ...]\n",
@


1.62
log
@Remove NHASHES, it is not needed and is incompatible with #ifdef SMALL.
Remove style_hash and style_cksum, adjust the style of the selected
algorithms based on rflag and qflag instead.
@
text
@d310 5
a333 5
		case 'h':
			ofile = fopen(optarg, "w");
			if (ofile == NULL)
				errx(1, "%s", optarg);
			break;
@


1.61
log
@Remove pmode, fix hfile open mode, check return value when writing
file name to stdout.
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.60 2014/01/08 14:19:25 deraadt Exp $	*/
d45 2
a46 2
#define STYLE_NORMAL	0
#define STYLE_REVERSE	1
a66 7
/* Default print style for hash and chksum functions. */
int style_hash = STYLE_NORMAL;
#if !defined(SMALL)
int style_cksum = STYLE_REVERSE;
#endif /* !defined(SMALL) */

#define NHASHES	11
d70 1
a70 1
	int *style;
d78 1
a78 1
} functions[NHASHES + 1] = {
d83 1
a83 1
		&style_cksum,
d94 1
a94 1
		&style_cksum,
d105 1
a105 1
		&style_cksum,
d116 1
a116 1
		&style_hash,
d126 1
a126 1
		&style_hash,
d137 1
a137 1
		&style_hash,
d148 1
a148 1
		&style_hash,
d159 1
a159 1
		&style_hash,
d171 1
a171 1
		&style_hash,
d183 1
a183 1
		&style_hash,
d195 1
a195 1
		&style_hash,
d383 5
a387 7
	if (rflag)
		style_hash = STYLE_REVERSE;
	if (qflag) {
		style_hash = STYLE_TERSE;
#if !defined(SMALL)
		style_cksum = STYLE_TERSE;
#endif /* !defined(SMALL) */
d469 2
a470 2
	switch (*hf->style) {
	case STYLE_NORMAL:
d473 1
a473 1
	case STYLE_REVERSE:
d486 2
a487 2
	switch (*hf->style) {
	case STYLE_NORMAL:
d490 1
a490 1
	case STYLE_REVERSE:
d667 1
a667 1
			if (*hf->style & STYLE_REVERSE) {
@


1.60
log
@Add -DSMALL support to kill a lot of the unncecessary hashes and checksums
that the install media won't need
ok millert, but he used the word butcher!
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.58 2013/12/23 23:00:38 tedu Exp $	*/
d4 2
a5 1
 * Copyright (c) 2001,2003,2005-2006 Todd C. Miller <Todd.Miller@@courtesan.com>
a53 7
enum program_mode {
	MODE_MD5,
#if !defined(SMALL)
	MODE_CKSUM,
#endif
} pmode;

d56 2
a64 4
#if !defined(SMALL)
	SUM_CTX sum;
	SYSVSUM_CTX sysvsum;
#endif /* !defined(SMALL) */
d241 1
a244 7
	static const char *optstr[2] = {
		"bch:pqrs:tx",
#if !defined(SMALL)
		"a:bch:o:pqrs:tx"
#endif /* !defined(SMALL) */
	};

a248 1
	pmode = MODE_MD5;
d251 2
a252 1
		pmode = MODE_CKSUM;
d254 1
d257 1
a257 1
	while ((fl = getopt(argc, argv, optstr[pmode])) != -1) {
d268 1
a268 1
	while ((fl = getopt(argc, argv, optstr[pmode])) != -1) {
d337 1
a337 1
			ofile = fopen(optarg, "w+");
a523 3
	if (echo)
		fflush(stdout);

d530 5
a534 2
		if (echo)
			write(STDOUT_FILENO, data, (size_t)nread);
a823 5
	switch (pmode) {
	case MODE_MD5:
		fprintf(stderr, "usage: %s [-bpqrtx] [-c [checklist ...]] "
		    "[-h hashfile] [-s string] [file ...]\n", __progname);
		break;
d825 1
a825 1
	case MODE_CKSUM:
d830 1
a830 1
		break;
d832 2
a833 1
	}
@


1.59
log
@Add support for -h hashfile.  This is very useful with with -p, in a pipeline,
to deliver the hash output to a different location.
ok millert
@
text
@d55 1
d57 1
d61 1
d67 1
d69 1
d72 1
d77 1
d79 1
d94 1
d105 2
a106 1
	}, {
d116 2
a117 1
	}, {
d127 2
a128 1
	}, {
d148 2
a149 1
	}, {
d159 2
a160 1
	}, {
d170 2
a171 1
	}, {
d181 3
a183 1
	}, {
d193 3
a195 1
	}, {
d205 3
a207 1
	}, {
d217 2
a218 1
	}, {
d229 1
d234 1
d254 1
d256 1
d264 1
d267 1
d330 1
d348 1
d407 1
d409 1
d412 1
d426 3
a428 1
	} else if (pflag || argc == 0)
d469 1
d485 1
d499 1
a499 1
		(void)fprintf(ofile,"%s\n", digest);
d571 1
d832 1
d842 1
d849 1
@


1.58
log
@install a link as sha512. simplify program internals; there are only
two modes. ok deraadt gilles jca
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.57 2013/11/21 15:54:45 deraadt Exp $	*/
d216 1
d229 2
a230 2
		"bcpqrs:tx",
		"a:bco:pqrs:tx"
d319 5
d349 3
d456 1
a456 1
		(void)printf("%s (%s) = %s\n", hf->name, what, digest);
d459 1
a459 1
		(void)printf("%s %s\n", digest, what);
d462 1
a462 1
		(void)printf("%s\n", digest);
d473 1
a473 1
		(void)printf("%s (\"%s\") = %s\n", hf->name, what, digest);
d476 1
a476 1
		(void)printf("%s %s\n", digest, what);
d479 1
a479 1
		(void)printf("%s\n", digest);
d527 1
a527 1
			(void)puts(digest);
d801 1
a801 1
		    "[-s string] [file ...]\n", __progname);
d805 1
a805 1
		    "[-c [checklist ...]] [-o 1 | 2]\n"
@


1.57
log
@add unsigned char casts for specific calls to ctype.h macros.
ok guenther step
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.56 2013/04/15 15:54:17 millert Exp $	*/
a54 2
	MODE_SHA1,
	MODE_RMD160,
a55 1
	MODE_SUM
d227 1
a227 1
	static const char *optstr[5] = {
a228 3
		"bcpqrs:tx",
		"bcpqrs:tx",
		"a:bco:pqrs:tx",
d237 1
a237 7
	if (strcmp(__progname, "md5") == 0)
		pmode = MODE_MD5;
	else if (strcmp(__progname, "sha1") == 0)
		pmode = MODE_SHA1;
	else if (strcmp(__progname, "rmd160") == 0)
		pmode = MODE_RMD160;
	else if (strcmp(__progname, "cksum") == 0)
a238 2
	else if (strcmp(__progname, "sum") == 0)
		pmode = MODE_SUM;
a790 2
	case MODE_SHA1:
	case MODE_RMD160:
a794 1
	case MODE_SUM:
@


1.56
log
@SHA-224 is to SHA-256 as SHA-384 is to SHA-512.  It was added in a
later revision of FIPS-180.  OK miod@@ jmc@@ guenther@@ djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.55 2013/03/30 02:42:24 lteo Exp $	*/
d587 1
a587 1
		while (isspace(*buf))
d661 1
a661 1
			while (isspace(*p))
@


1.55
log
@Return an exit code of 1 if the file cannot be opened (e.g. file does
not exist), or if there is an error reading the file stream.

From Patrik Lundin, thanks!

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.54 2012/12/04 02:38:51 deraadt Exp $	*/
d76 1
a76 1
#define NHASHES	10
d159 10
@


1.54
log
@replace sys/param.h with sys/types.h (and sometimes add limits.h if needed)
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.53 2011/07/05 23:39:27 tedu Exp $	*/
d197 1
a197 1
void digest_file(const char *, struct hash_list *, int);
d389 1
a389 1
		digest_file("-", &hl, pflag);
d392 1
a392 1
			digest_file(*argv++, &hl, 0);
d479 1
a479 1
void
d492 1
a492 1
		return;
d513 1
a513 1
		return;
d526 1
@


1.53
log
@fix memset sizeof, found by jsg. ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.52 2010/10/27 15:24:10 millert Exp $	*/
d23 1
a23 1
#include <sys/param.h>
d33 1
d49 3
@


1.52
log
@Use a 32KB data buffer instead of a 1KB buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.51 2010/10/25 19:05:52 millert Exp $	*/
d418 2
a419 1
		memset(digest, 0, sizeof(digest));
@


1.51
log
@Use stdio when reading in the file to be checksummed.  This can improve
performance due to the internal buffering stdio does wrt the optimal
read size (st_blksize).  OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.50 2008/09/06 12:01:34 djm Exp $	*/
d480 1
a480 1
	u_char data[BUFSIZ];
d540 1
a540 1
	u_char data[BUFSIZ];
@


1.50
log
@adapt to sha2(3) API changes; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.49 2008/07/29 18:24:31 sobrado Exp $	*/
d478 2
a479 2
	int fd;
	ssize_t nread;
d484 2
a485 2
		fd = STDIN_FILENO;
	else if ((fd = open(file, O_RDONLY, 0)) == -1) {
d498 1
a498 1
	while ((nread = read(fd, data, sizeof(data))) > 0) {
d504 1
a504 1
	if (nread == -1) {
d506 2
a507 2
		if (fd != STDIN_FILENO)
			close(fd);
d510 2
a511 2
	if (fd != STDIN_FILENO)
		close(fd);
d516 1
a516 1
		if (fd == STDIN_FILENO)
d532 1
a532 1
	int fd, found, base64, error, cmp;
d538 2
a539 3
	FILE *fp;
	ssize_t nread;
	size_t len;
d545 2
a546 2
		fp = stdin;
	} else if ((fp = fopen(file, "r")) == NULL) {
d559 1
a559 1
	while ((buf = fgetln(fp, &len))) {
d656 1
a656 1
		if ((fd = open(filename, O_RDONLY, 0)) == -1) {
d664 1
a664 1
		while ((nread = read(fd, data, sizeof(data))) > 0)
d666 1
a666 1
		if (nread == -1) {
d669 1
a669 1
			close(fd);
d672 1
a672 1
		close(fd);
d688 2
a689 2
	if (fp != stdin)
		fclose(fp);
@


1.49
log
@md5(1), sha1(1), rmd160(1), cksum(1) and sum(1) have different options;
while here, some KNF improvements.

based on a diff for compress(1) written by millert@@,
fixes from guenther@@ and pyr@@.

ok millert@@, pyr@@; (for the manual page tweaks) jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.48 2007/11/07 09:52:25 chl Exp $	*/
d63 1
a63 3
	SHA256_CTX sha256;
	SHA384_CTX sha384;
	SHA512_CTX sha512;
d161 4
a164 4
		(void (*)(void *))SHA256_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SHA256_Update,
		(void (*)(unsigned char *, void *))SHA256_Final,
		(char *(*)(void *, char *))SHA256_End
d171 4
a174 4
		(void (*)(void *))SHA384_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SHA384_Update,
		(void (*)(unsigned char *, void *))SHA384_Final,
		(char *(*)(void *, char *))SHA384_End
d181 4
a184 4
		(void (*)(void *))SHA512_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SHA512_Update,
		(void (*)(unsigned char *, void *))SHA512_Final,
		(char *(*)(void *, char *))SHA512_End
@


1.48
log
@properly exit >0 when encountering bad md5 in cheklist

ok gilles@@ millert@@

From Tim van der Molen <tbvdm.lists at xs4all.nl>
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.47 2007/10/31 20:47:39 deraadt Exp $	*/
d49 8
a207 2
#define	OPTSTRING	"a:bco:pqrs:tx"

d218 8
d230 12
d243 3
a245 2
	while ((fl = getopt(argc, argv, ":" OPTSTRING)) != -1) {
		if (fl == 'b')
d247 4
d254 1
a254 1
	while ((fl = getopt(argc, argv, OPTSTRING)) != -1) {
d283 2
a284 1
					    hf->name, base64 ? "base64" : "hex");
d684 2
a685 1
				(void)printf("(%s) %s: OK\n", algorithm, filename);
d790 15
a804 4
	fprintf(stderr, "usage: %s [-bpqrtx] [-c [checklist ...]] "
	    "[-s string] [file ...]\n", __progname);
	if (strcmp(__progname, "cksum") == 0)
		fprintf(stderr, "             [-a algorithms]] [-o 1 | 2]\n");
@


1.47
log
@clamp -ttttttttt test counter to 1B, so that it does not wrap negative;
from Nicholas Marriott, ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.46 2007/04/14 23:04:10 grunk Exp $	*/
d502 1
a502 1
	int fd, found, base64, error;
d647 1
a647 1
			error = strncmp(checksum, digest, len);
d649 2
a650 2
			error = strcasecmp(checksum, digest);
		if (error == 0) {
@


1.46
log
@if we define a constant for the OPTSTRING, we can as well use it.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.45 2007/04/13 13:57:01 tedu Exp $	*/
d681 1
a681 1
	while (--times > 0)
@


1.45
log
@allow multiple -t to increase the test count.  cpus are getting too fast.
ok grunk. with manpage from grunk and jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.44 2007/03/29 15:20:51 millert Exp $	*/
d223 1
a223 1
	while ((fl = getopt(argc, argv, "a:bco:pqrs:tx")) != -1) {
@


1.44
log
@Fix a cust & pasto
Correctly compute amount of base64 padding in checklist mode
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.43 2007/03/29 13:02:17 millert Exp $	*/
d193 1
a193 1
void digest_time(struct hash_list *);
d301 1
a301 1
			tflag = 1;
d314 1
a314 1
	fl = pflag + tflag + xflag + cflag + (input_string != NULL);
d342 1
a342 1
		digest_time(&hl);
d671 1
a671 1
digest_time(struct hash_list *hl)
d680 3
d686 1
a686 1
		    hf->name, TEST_BLOCK_COUNT, TEST_BLOCK_LEN);
d695 1
a695 1
		for (i = 0; i < TEST_BLOCK_COUNT; i++)
d705 1
a705 1
		    TEST_BLOCK_LEN * TEST_BLOCK_COUNT / elapsed);
@


1.43
log
@Do not print a warning that no valid checksums were found if there
was a single fingerprint for a file that could not be opened.
The warning that the file could not be opened is sufficient.
From espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.42 2007/03/28 11:30:15 millert Exp $	*/
d111 1
a111 1
		MD5_DIGEST_LENGTH,
d590 10
a599 3
				size_t len2 = (8 * hf->digestlen + 5) / 6;
				if (len != len2 &&
				    (len != len2 + 1 || checksum[len - 1] != '='))
d646 1
a646 2
		if (base64) {
			len = strlen(digest) - 1;	/* remove padding '=' */
d648 1
a648 1
		} else
@


1.42
log
@Supress warnings for the first getopt() pass.  Otherwise,
any "unknown option" messages get printed twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.41 2007/03/27 13:12:41 millert Exp $	*/
d529 1
a529 1
	base64 = error = found = 0;
d531 1
d618 1
a626 1
		found = 1;
@


1.41
log
@Add base64 support to cksum and friends.  Output encoding can
be set globally or on a per-algorithm basis when using multiple
hash functions.  OK espie@@ simon@@ deraadt@@; man help from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.40 2007/03/20 12:06:48 thib Exp $	*/
d217 1
a217 1
	while ((fl = getopt(argc, argv, OPTSTRING)) != -1) {
@


1.40
log
@augment the -q option, now if specifed with -c (checklist)
it will only print out the failed cases.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.39 2007/01/09 18:06:07 deraadt Exp $	*/
d24 2
d29 1
d43 2
a44 2
#define STYLE_HASH	0
#define STYLE_CKSUM	1
d63 2
a64 2
int style_hash = STYLE_HASH;
int style_cksum = STYLE_CKSUM;
d67 1
a67 1
struct hash_functions {
d71 1
d75 1
d77 1
d81 1
a81 1
		CKSUM_DIGEST_LENGTH * 2,
d83 1
d87 1
d91 1
a91 1
		SUM_DIGEST_LENGTH * 2,
d93 1
d97 1
d101 1
a101 1
		SYSVSUM_DIGEST_LENGTH * 2,
d103 1
d107 1
d111 1
a111 1
		MD5_DIGEST_LENGTH * 2,
d113 1
d117 1
d121 1
a121 1
		MD5_DIGEST_LENGTH * 2,
d123 1
d127 1
d131 1
a131 1
		RMD160_DIGEST_LENGTH * 2,
d133 1
d137 1
d141 1
a141 1
		SHA1_DIGEST_LENGTH * 2,
d143 1
d147 1
d151 1
a151 1
		SHA256_DIGEST_LENGTH * 2,
d153 1
d157 1
d161 1
a161 1
		SHA384_DIGEST_LENGTH * 2,
d163 1
d167 1
d171 1
a171 1
		SHA512_DIGEST_LENGTH * 2,
d173 1
d177 1
d184 11
a195 7
void digest_file(const char *, struct hash_functions **, int);
int digest_filelist(const char *, struct hash_functions *);
void digest_print(const struct hash_functions *, const char *, const char *);
void digest_printstr(const struct hash_functions *, const char *, const char *);
void digest_string(char *, struct hash_functions **);
void digest_test(struct hash_functions **);
void digest_time(struct hash_functions **);
d200 2
d205 3
a207 3
	struct hash_functions *hf, *hashes[NHASHES + 1];
	int fl, i, error;
	int cflag, pflag, rflag, tflag, xflag;
d209 2
d212 1
d214 10
a223 3
	error = cflag = pflag = qflag = rflag = tflag = xflag = 0;
	memset(hashes, 0, sizeof(hashes));
	while ((fl = getopt(argc, argv, "a:co:pqrs:tx")) != -1) {
d229 17
a245 3
				for (hf = functions; hf->name != NULL; hf++)
					if (strcasecmp(hf->name, cp) == 0)
						break;
d250 9
a258 3
				for (i = 0; i < NHASHES && hashes[i] != hf; i++)
					if (hashes[i] == NULL) {
						hashes[i] = hf;
d260 3
a262 1
					}
d265 3
d280 3
a282 3
			for (i = 0; i < NHASHES && hashes[i] != hf; i++) {
				if (hashes[i] == NULL) {
					hashes[i] = hf;
a283 1
				}
d285 2
d318 1
a318 1
		if (hashes[1] != NULL)
d324 1
a324 1
	if (hashes[0] == NULL) {
d326 1
a326 2
			if (strcasecmp(hf->name, __progname) == 0) {
				hashes[0] = hf;
a327 1
			}
d329 3
a331 2
		if (hashes[0] == NULL)
			hashes[0] = &functions[0];	/* default to cksum */
d335 1
a335 1
		style_hash = STYLE_CKSUM;		/* reverse print */
d342 1
a342 1
		digest_time(hashes);
d344 1
a344 1
		digest_test(hashes);
d346 1
a346 1
		digest_string(input_string, hashes);
d349 1
a349 1
			error = digest_filelist("-", hashes[0]);
d352 2
a353 1
				error += digest_filelist(*argv++, hashes[0]);
d355 1
a355 1
		digest_file("-", hashes, pflag);
d358 1
a358 1
			digest_file(*argv++, hashes, 0);
d364 1
a364 1
digest_string(char *string, struct hash_functions **hashes)
d366 32
a397 1
	struct hash_functions *hf;
d401 1
a401 2
	while (*hashes != NULL) {
		hf = *hashes++;
d404 2
a405 1
		(void)hf->end(&context, digest);
d411 1
a411 1
digest_print(const struct hash_functions *hf, const char *what,
d415 1
a415 1
	case STYLE_HASH:
d418 1
a418 1
	case STYLE_CKSUM:
d428 1
a428 1
digest_printstr(const struct hash_functions *hf, const char *what,
d432 1
a432 1
	case STYLE_HASH:
d435 1
a435 1
	case STYLE_CKSUM:
d445 1
a445 1
digest_file(const char *file, struct hash_functions **hashes, int echo)
d447 1
a447 1
	struct hash_functions **hfp;
d463 2
a464 2
	for (hfp = hashes; *hfp != NULL; hfp++) {
		if (((*hfp)->ctx = malloc(sizeof(union ANY_CTX))) == NULL)
d466 1
a466 1
		(*hfp)->init((*hfp)->ctx);
d471 2
a472 2
		for (hfp = hashes; *hfp != NULL; hfp++)
			(*hfp)->update((*hfp)->ctx, data, (unsigned int)nread);
d482 4
a485 3
	for (hfp = hashes; *hfp != NULL; hfp++) {
		(void)(*hfp)->end((*hfp)->ctx, digest);
		free((*hfp)->ctx);
d489 1
a489 1
			digest_print(*hfp, file, digest);
d500 1
a500 1
digest_filelist(const char *file, struct hash_functions *defhash)
d502 1
a502 1
	int fd, found, error;
d513 1
a513 1
	struct hash_functions *hf;
d529 1
a529 1
	error = found = 0;
d579 1
a579 2
			if (hf->name == NULL ||
			    strlen(checksum) != hf->digestlen)
d581 14
d603 1
a603 1
			if (*hf->style == STYLE_CKSUM) {
d636 1
a636 1
		(void)hf->end(&context, digest);
d638 6
a643 1
		if (strcasecmp(checksum, digest) == 0) {
d664 1
a664 1
digest_time(struct hash_functions **hashes)
d666 1
a666 1
	struct hash_functions *hf;
d674 1
a674 2
	while (*hashes != NULL) {
		hf = *hashes++;
d687 1
a687 1
		(void)hf->end(&context, digest);
d700 1
a700 1
digest_test(struct hash_functions **hashes)
d702 1
a702 1
	struct hash_functions *hf;
d720 1
a720 2
	while (*hashes != NULL) {
		hf = *hashes++;
d727 2
a728 1
			(void)hf->end(&context, digest);
d738 1
a738 1
		(void)hf->end(&context, digest);
d747 1
a747 1
	fprintf(stderr, "usage: %s [-pqrtx] [-c [checklist ...]] "
@


1.39
log
@align usage message correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.38 2006/11/17 16:02:18 jmc Exp $	*/
d168 1
d175 1
a175 1
	int cflag, pflag, qflag, rflag, tflag, xflag;
a252 2
		if (qflag)
			errx(1, "the -q and -c flags are mutually exclusive");
d525 4
a528 3
		if (strcasecmp(checksum, digest) == 0)
			(void)printf("(%s) %s: OK\n", algorithm, filename);
		else {
@


1.38
log
@simplify synopsis and usage(); ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.37 2006/11/16 23:53:41 millert Exp $	*/
d633 1
a633 1
		fprintf(stderr, "\t[-a algorithms]] [-o 1 | 2]\n");
@


1.37
log
@Add -r and -q options similar to what is supported by FreeBSD's md5
OK deraadt@@ ckuethe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.36 2006/11/10 15:03:44 tom Exp $	*/
d630 2
a631 2
	fprintf(stderr, "usage: %s [-p | -t | -x | -c [checklist ...] | "
	    "-s string | file ...]\n", __progname);
d633 1
a633 1
		fprintf(stderr, "             [-a algorithms]] [-o 1 | 2] [-q | -r]\n");
@


1.36
log
@Accept upper and lower case letters in a checksum, since this doesn't
alter the value of the digest.  Nor, for that matter, does case affect
the name of the algorithm used.

Partly from Matthew Clarke, clamat (at) telus (dot) net.

ok djm@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.35 2006/03/15 03:15:07 dhill Exp $	*/
d4 1
a4 1
 * Copyright (c) 2001, 2003, 2005 Todd C. Miller <Todd.Miller@@courtesan.com>
d40 1
d42 1
a42 1
#define STYLE_HASH	2
d59 4
d67 1
a67 1
	int style;
d76 1
a76 1
		STYLE_CKSUM,
d84 1
a84 1
		STYLE_CKSUM,
d92 1
a92 1
		STYLE_CKSUM,
d100 1
a100 1
		STYLE_HASH,
d108 1
a108 1
		STYLE_HASH,
d116 1
a116 1
		STYLE_HASH,
d124 1
a124 1
		STYLE_HASH,
d132 1
a132 1
		STYLE_HASH,
d140 1
a140 1
		STYLE_HASH,
d148 1
a148 1
		STYLE_HASH,
d174 1
a174 1
	int cflag, pflag, tflag, xflag;
d178 1
a178 1
	error = cflag = pflag = tflag = xflag = 0;
d180 1
a180 1
	while ((fl = getopt(argc, argv, "a:co:ps:tx")) != -1) {
d222 6
d246 1
a246 1
	if (fl > 1 || (fl && argc && cflag == 0))
d248 7
a254 2
	if (cflag != 0 && hashes[1] != NULL)
		errx(1, "only a single algorithm may be specified in -c mode");
d268 7
d316 5
a320 1
	if (hf->style == STYLE_CKSUM)
d322 5
a326 2
	else
		(void)printf("%s (%s) = %s\n", hf->name, what, digest);
d333 5
a337 1
	if (hf->style == STYLE_CKSUM)
d339 5
a343 2
	else
		(void)printf("%s (\"%s\") = %s\n", hf->name, what, digest);
d491 1
a491 1
			if (hf->style == STYLE_CKSUM) {
d633 1
a633 1
		fprintf(stderr, "             [-a algorithms]] [-o 1 | 2]\n");
@


1.35
log
@Fix signed/unsigned comparisons by using size_t
Sprinkle some const

ok ray@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.34 2005/12/20 02:09:23 millert Exp $	*/
d440 1
a440 1
				if (strcmp(algorithm, hf->name) == 0)
d489 1
a489 1
		if (strcmp(checksum, digest) == 0)
@


1.34
log
@Make "cksum -c" grok checklists generated with cksum, sum and sysvsum.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.33 2005/08/17 11:34:16 mpf Exp $	*/
d60 2
a61 2
	char *name;
	int digestlen;
d150 1
a150 1
	},
d367 3
a369 2
	int algorithm_max, algorithm_min;
	char *algorithm, *filename, *checksum, *buf, *p;
d553 1
a553 1
	unsigned char *test_strings[] = {
@


1.33
log
@Exit unsuccessfully when comparing against a checklist file fails.
OK markus@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.32 2004/12/29 17:32:44 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 2001, 2003 Todd C. Miller <Todd.Miller@@courtesan.com>
d40 3
a57 4
void digest_print(const char *, const char *, const char *);
void digest_print_short(const char *, const char *, const char *);
void digest_print_string(const char *, const char *, const char *);

d62 1
a66 2
	void (*print)(const char *, const char *, const char *);
	void (*printstr)(const char *, const char *, const char *);
d71 1
d75 1
a75 3
		(char *(*)(void *, char *))CKSUM_End,
		digest_print_short,
		digest_print_short
d79 1
d83 1
a83 3
		(char *(*)(void *, char *))SUM_End,
		digest_print_short,
		digest_print_short
d87 1
d91 1
a91 3
		(char *(*)(void *, char *))SYSVSUM_End,
		digest_print_short,
		digest_print_short
d95 1
d99 1
a99 3
		(char *(*)(void *, char *))MD4End,
		digest_print,
		digest_print_string
d103 1
d107 1
a107 3
		(char *(*)(void *, char *))MD5End,
		digest_print,
		digest_print_string
d111 1
d115 1
a115 3
		(char *(*)(void *, char *))RMD160End,
		digest_print,
		digest_print_string
d119 1
d123 1
a123 3
		(char *(*)(void *, char *))SHA1End,
		digest_print,
		digest_print_string
d127 1
d131 1
a131 3
		(char *(*)(void *, char *))SHA256_End,
		digest_print,
		digest_print_string
d135 1
d139 1
a139 3
		(char *(*)(void *, char *))SHA384_End,
		digest_print,
		digest_print_string
d143 1
d147 1
a147 3
		(char *(*)(void *, char *))SHA512_End,
		digest_print,
		digest_print_string
d156 2
d285 1
a285 1
		hf->printstr(hf->name, string, digest);
d290 2
a291 1
digest_print(const char *name, const char *what, const char *digest)
d293 4
a296 1
	(void)printf("%s (%s) = %s\n", name, what, digest);
d300 2
a301 1
digest_print_string(const char *name, const char *what, const char *digest)
d303 4
a306 7
	(void)printf("%s (\"%s\") = %s\n", name, what, digest);
}

void
digest_print_short(const char *name, const char *what, const char *digest)
{
	(void)printf("%s %s\n", digest, what);
d353 1
a353 1
			(*hfp)->print((*hfp)->name, file, digest);
a384 3
	if (defhash < &functions[3])
		defhash = NULL;	/* No GNU format for sum, cksum, sysvsum */

d453 4
d574 1
a574 1
			hf->printstr(hf->name, test_strings[i], digest);
d584 1
a584 1
		hf->print(hf->name, "one million 'a' characters",
@


1.32
log
@Add support for multiple using algorithms.  OK'd by several people
a while ago so get this out of my tree...
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.31 2004/12/10 19:35:53 millert Exp $	*/
d497 1
a497 1
		else
d499 2
@


1.31
log
@GNU md5sum uses tab not space to separate filename and hash.  Fixes
parsing of GNU-style checklist files for files with spaces in them.
From Emil Mikulic; closes PR 4027
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.30 2004/05/04 18:41:57 millert Exp $	*/
d59 1
d63 1
d69 1
a69 3
};

struct hash_functions functions[] = {
d73 1
d80 18
d100 1
d109 1
d118 1
d127 1
d136 1
d145 1
d154 1
a160 16
		"SUM",
		SUM_DIGEST_LENGTH * 2,
		(void (*)(void *))SUM_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SUM_Update,
		(char *(*)(void *, char *))SUM_End,
		digest_print_short,
		digest_print_short
	}, {
		"SYSVSUM",
		SYSVSUM_DIGEST_LENGTH * 2,
		(void (*)(void *))SYSVSUM_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SYSVSUM_Update,
		(char *(*)(void *, char *))SYSVSUM_End,
		digest_print_short,
		digest_print_short
	}, {
d165 6
a170 6
__dead void usage(void);
void digest_file(char *, struct hash_functions *, int);
int digest_filelist(int, char *);
void digest_string(char *, struct hash_functions *);
void digest_test(struct hash_functions *);
void digest_time(struct hash_functions *);
d177 2
a178 1
	int fl, digest_type, error;
d180 1
a180 1
	char *digest_name, *input_string;
a182 1
	digest_name = __progname;
d184 1
d188 16
a203 1
			digest_name = optarg;
d210 1
a210 1
				digest_name = "sum";
d212 1
a212 1
				digest_name = "sysvsum";
d217 6
a242 14
	for (digest_type = 0; functions[digest_type].name != NULL;
	    digest_type++) {
		if (strcasecmp(functions[digest_type].name, digest_name) == 0)
			break;
	}
	if (functions[digest_type].name == NULL) {
		if (digest_name != __progname) {
			/* Unsupported algorithm specified, exit */
			warnx("unknown algorithm \"%s\"", digest_name);
			usage();
		}
		digest_type = 0;	/* default to cksum */
	}

d247 14
d263 1
a263 1
		digest_time(&functions[digest_type]);
d265 1
a265 1
		digest_test(&functions[digest_type]);
d267 2
a268 2
		digest_string(input_string, &functions[digest_type]);
	else if (cflag)
d270 1
a270 1
			error = digest_filelist(digest_type, "-");
d273 3
a275 3
				error += digest_filelist(digest_type, *argv++);
	else if (pflag || argc == 0)
		digest_file("-", &functions[digest_type], pflag);
d278 1
a278 1
			digest_file(*argv++, &functions[digest_type], 0);
d284 1
a284 1
digest_string(char *string, struct hash_functions *hf)
d286 1
d290 7
a296 4
	hf->init(&context);
	hf->update(&context, string, (unsigned int)strlen(string));
	(void)hf->end(&context, digest);
	hf->printstr(hf->name, string, digest);
d318 1
a318 1
digest_file(char *file, struct hash_functions *hf, int echo)
d320 1
a324 1
	union ANY_CTX context;
d336 5
a340 1
	hf->init(&context);
d344 2
a345 1
		hf->update(&context, data, (unsigned int)nread);
d353 1
a353 5
	(void)hf->end(&context, digest);

	if (fd == STDIN_FILENO) {
		(void)puts(digest);
	} else {
d355 7
a361 1
		hf->print(hf->name, file, digest);
d372 1
a372 1
digest_filelist(int algorithm_def, char *file)
d393 3
d458 2
a459 1
			hf = &functions[algorithm_def];
d513 1
a513 1
digest_time(struct hash_functions *hf)
d515 1
d523 24
a546 21
	(void)printf("%s time trial.  Processing %d %d-byte blocks...",
	    hf->name, TEST_BLOCK_COUNT, TEST_BLOCK_LEN);
	fflush(stdout);

	/* Initialize data based on block number. */
	for (i = 0; i < TEST_BLOCK_LEN; i++)
		data[i] = (u_char)(i & 0xff);

	gettimeofday(&start, NULL);
	hf->init(&context);
	for (i = 0; i < TEST_BLOCK_COUNT; i++)
		hf->update(&context, data, TEST_BLOCK_LEN);
	(void)hf->end(&context, digest);
	gettimeofday(&stop, NULL);
	timersub(&stop, &start, &res);
	elapsed = res.tv_sec + res.tv_usec / 1000000.0;

	(void)printf("\nDigest = %s\n", digest);
	(void)printf("Time   = %f seconds\n", elapsed);
	(void)printf("Speed  = %f bytes/second\n",
	    TEST_BLOCK_LEN * TEST_BLOCK_COUNT / elapsed);
d550 1
a550 1
digest_test(struct hash_functions *hf)
d552 1
d557 1
a557 1
	char *test_strings[] = {
d570 11
a580 1
	(void)printf("%s test suite:\n", hf->name);
d582 2
a583 1
	for (i = 0; i < 8; i++) {
d585 3
a587 2
		hf->update((void *)&context, (unsigned char *)test_strings[i],
		    (unsigned int)strlen(test_strings[i]));
d589 2
a590 1
		hf->printstr(hf->name, test_strings[i], digest);
a591 9

	/* Now simulate a string of a million 'a' characters. */
	memset(buf, 'a', sizeof(buf));
	hf->init(&context);
	for (i = 0; i < 1000; i++)
		hf->update(&context, (unsigned char *)buf,
		    (unsigned int)sizeof(buf));
	(void)hf->end(&context, digest);
	hf->print(hf->name, "one million 'a' characters", digest);
d594 1
a594 1
__dead void
d600 1
a600 1
		fprintf(stderr, "             [-a algorithm] [-o 1 | 2]\n");
@


1.30
log
@sync usage w/ man page
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.29 2004/05/02 17:53:29 millert Exp $	*/
d423 1
a423 1
			p = strpbrk(filename, " \t\r");
@


1.29
log
@Add support for cksum (3 varieties), md4, sha256, sha384, and sha512.
Consequently, cksum moves becomes a link to md5 and moves to /bin.
The cksum man page could use some polishing.
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.28 2004/04/28 23:58:41 millert Exp $	*/
d541 2
a542 1
	/* We only list the algorithms when invoked as cksum. */
d544 2
a545 7
		fprintf(stderr,
		    "usage: cksum [-a cksum|md4|md5|rmd160|sha1|sha256|sha384|"
		    "sha512|sum|sysvsum]\n             [-o 1|2] ");
	else
		fprintf(stderr, "usage: %s ", __progname);
	fprintf(stderr, "[-p | -t | -x | -c [checklist ...] | "
	    "-s string | file ...]\n");
@


1.28
log
@Use the FOO_DIGEST_LENGTH macros
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.27 2004/03/03 22:00:06 millert Exp $	*/
d33 1
d35 1
d37 2
a38 1
#include <rmd160.h>
d40 1
a40 1
#define MAX_DIGEST_LEN	40
d43 2
d48 5
d55 4
d65 2
a66 2
	char * (*file)(char *, char *);
	char * (*data)(const unsigned char *, unsigned int, char *);
d71 16
d92 2
a93 2
		(char *(*)(char *, char *))MD5File,
		(char *(*)(const unsigned char *, unsigned int, char *))MD5Data
d100 2
a101 2
		(char *(*)(char *, char *))RMD160File,
		(char *(*)(const unsigned char *, unsigned int, char *))RMD160Data
d108 42
a149 2
		(char *(*)(char *, char *))SHA1File,
		(char *(*)(const unsigned char *, unsigned int, char *))SHA1Data
d155 7
a162 6
static void usage(void);
static void digest_file(char *, struct hash_functions *, int);
static int digest_filelist(int, char *);
static void digest_string(char *, struct hash_functions *);
static void digest_test(struct hash_functions *);
static void digest_time(struct hash_functions *);
d169 1
a169 10
	char *input_string;

	/* Set digest type based on program name, defaults to MD5. */
	for (digest_type = 0; functions[digest_type].name != NULL;
	    digest_type++) {
		if (strcasecmp(functions[digest_type].name, __progname) == 0)
			break;
	}
	if (functions[digest_type].name == NULL)
		digest_type = 0;
d172 1
d174 1
a174 1
	while ((fl = getopt(argc, argv, "pctxs:")) != -1) {
d176 3
d182 10
d211 15
a225 1
	/* All arguments are mutually exclusive */
d251 1
a251 1
static void
d255 1
d257 4
a260 3
	(void)hf->data((unsigned char *)string, (unsigned int)strlen(string),
	    digest);
	(void)printf("%s (\"%s\") = %s\n", hf->name, string, digest);
d263 19
a281 1
static void
d318 1
a318 1
		(void)printf("%s (%s) = %s\n", hf->name, file, digest);
d328 1
a328 1
static int
d465 1
a465 1
static void
d498 1
a498 1
static void
d525 1
a525 2
		(void)printf("%s (\"%s\") = %s\n", hf->name, test_strings[i],
		    digest);
d535 1
a535 2
	(void)printf("%s (one million 'a' characters) = %s\n",
	    hf->name, digest);
d538 1
a538 1
static void
d541 9
a549 3
	fprintf(stderr, "usage: %s [-p | -t | -x | -c [ checksum_file ... ]",
	    __progname);
	fprintf(stderr, " | -s string | file ...]\n");
@


1.27
log
@Extend "md5 -c" to parse the output of GNU md5sum.
Adapted from patches by Lawrence Teo and tedu@@.  OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.26 2003/07/21 00:11:03 millert Exp $	*/
d41 1
a42 1
	RMD160_CTX rmd160;
d58 1
a58 1
		32,
d65 8
d74 1
a74 1
		40,
a80 8
		"RMD160",
		40,
		(void (*)(void *))RMD160Init,
		(void (*)(void *, const unsigned char *, unsigned int))RMD160Update,
		(char *(*)(void *, char *))RMD160End,
		(char *(*)(char *, char *))RMD160File,
		(char *(*)(const unsigned char *, unsigned int, char *))RMD160Data
	}, {
d198 1
a198 1
		if (fd != STDIN_FILENO)  
@


1.26
log
@Fix typo: unsigned -> unsigned char; from Thorsten Glaser
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.25 2003/06/25 21:23:01 deraadt Exp $	*/
d88 1
a88 1
static int digest_filelist(char *);
d148 1
a148 1
			error = digest_filelist("-");
d151 1
a151 1
				error += digest_filelist(*argv++);
d219 1
a219 1
digest_filelist(char *file)
d266 3
d270 13
a282 18
		algorithm = buf;
		p = strchr(algorithm, ' ');
		if (p == NULL || *(p + 1) != '(')
			continue;
		*p = '\0';
		len = strlen(algorithm);
		if (len > algorithm_max || len < algorithm_min)
			continue;

		filename = p + 2;
		p = strrchr(filename, ')');
		if (p == NULL || strncmp(p + 1, " = ", (size_t)3) != 0)
			continue;
		*p = '\0';

		checksum = p + 4;
		p = strpbrk(checksum, " \t\r");
		if (p != NULL)
d285 31
a315 6
		/*
		 * Check that the algorithm is one we recognize.
		 */
		for (hf = functions; hf->name != NULL; hf++) {
			if (strcmp(algorithm, hf->name) == 0)
				break;
a316 2
		if (hf->name == NULL || strlen(checksum) != hf->digestlen)
			continue;
@


1.25
log
@fix lots of proto issues
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.24 2003/06/17 21:56:23 millert Exp $	*/
d373 1
a373 1
	unsigned buf[1000];
@


1.24
log
@Sync with share/misc/license.template and add missing DARPA credit
where applicable.
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.23 2003/06/11 23:42:12 deraadt Exp $	*/
d48 5
a52 5
	void (*init)();
	void (*update)();
	char * (*end)();
	char * (*file)();
	char * (*data)();
d59 5
a63 1
		MD5Init, MD5Update, MD5End, MD5File, MD5Data
d67 5
a71 1
		SHA1Init, SHA1Update, SHA1End, SHA1File, SHA1Data
d75 5
a79 1
		RMD160Init, RMD160Update, RMD160End, RMD160File, RMD160Data
d166 2
a167 1
	(void)hf->data(string, strlen(string), digest);
d194 1
a194 1
		hf->update(&context, data, nread);
d307 1
a307 1
			hf->update(&context, data, nread);
d372 2
a373 1
	char digest[MAX_DIGEST_LEN + 1], buf[1000];
d391 2
a392 1
		hf->update(&context, test_strings[i], strlen(test_strings[i]));
d402 2
a403 1
		hf->update(&context, buf, sizeof(buf));
@


1.23
log
@ansification, art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.22 2003/06/03 01:52:39 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 2001,2003 Todd C. Miller <Todd.Miller@@courtesan.com>
d10 11
a20 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.22
log
@Use an ISC-tyle license for all my code; it is simpler and more permissive.
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.21 2003/04/28 19:13:51 deraadt Exp $	*/
d50 1
d390 1
a390 1
usage()
@


1.21
log
@return from main
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.20 2003/04/23 16:00:43 millert Exp $	*/
a4 1
 * All rights reserved.
d6 3
a8 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.20
log
@strchr() should be strrchr(); zyrnix
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.19 2003/03/23 00:31:23 millert Exp $	*/
d152 1
a152 1
	exit(error ? EXIT_FAILURE : EXIT_SUCCESS);
@


1.19
log
@Do not closed stdin; Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.18 2003/03/13 02:38:22 millert Exp $	*/
d270 1
a270 1
		p = strchr(filename, ')');
@


1.18
log
@Cast 3 to size_t to shut up stupid gcc on 64bit platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.17 2003/03/12 21:29:48 millert Exp $	*/
d315 2
a316 1
	(void)fclose(fp);
@


1.17
log
@Add -c option similar to GNU md5sum.
Original patch from zyrnix but significantly modified by me.
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.16 2003/01/14 17:15:53 millert Exp $	*/
d271 1
a271 1
		if (p == NULL || strncmp(p + 1, " = ", 3) != 0)
@


1.16
log
@Report read() errors; noticed and OK by fgs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.15 2002/01/20 13:32:04 camield Exp $	*/
d4 1
a4 1
 * Copyright (c) 2001 Todd C. Miller <Todd.Miller@@courtesan.com>
d31 1
d44 1
a44 3
#define DIGEST_MD5	0
#define DIGEST_SHA1	1
#define DIGEST_RMD160	2
d54 1
d64 1
d68 1
d72 1
d74 2
d82 1
d90 2
a91 2
	int fl, digest_type;
	int pflag, tflag, xflag;
d95 7
a101 6
	if (strcmp(__progname, "rmd160") == 0)
		digest_type = DIGEST_RMD160;
	else if (strcmp(__progname, "sha1") == 0)
		digest_type = DIGEST_SHA1;
	else
		digest_type = DIGEST_MD5;
d104 2
a105 2
	pflag = tflag = xflag = 0;
	while ((fl = getopt(argc, argv, "ps:tx")) != -1) {
d107 3
d130 2
a131 2
	fl = pflag + tflag + xflag + (input_string != NULL);
	if (fl > 1 || (fl && argc))
d140 6
d152 1
a152 1
	exit(0);
d158 1
a158 1
	char *digest;
d160 1
a160 1
	digest = hf->data(string, strlen(string), NULL);
a161 1
	free(digest);
d170 1
a170 1
	char *digest;
d191 1
a191 1
		if (fd != STDIN_FILENO)
d195 1
a195 1
	digest = hf->end(&context, NULL);
d203 118
a320 1
	free(digest);
d333 1
a333 1
	char *digest;
d348 1
a348 1
	digest = hf->end(&context, NULL);
a356 1
	free(digest);
d364 1
a364 1
	char *digest, buf[1000];
d383 1
a383 1
		digest = hf->end(&context, NULL);
a385 1
		free(digest);
d393 1
a393 1
	digest = hf->end(&context, NULL);
a395 2
	free(digest);

d401 1
a401 1
	fprintf(stderr, "usage: %s [-p | -t | -x | -s string | file ...]\n",
d403 2
a404 1
	exit(1);
@


1.15
log
@Swap TEST_BLOCK_LEN and TEST_BLOCK_COUNT in benchmark printf.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.14 2001/09/06 13:29:08 mpech Exp $	*/
d173 6
@


1.14
log
@o) __progname aria;

millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.13 2001/06/03 18:04:16 millert Exp $	*/
d199 1
a199 1
	    hf->name, TEST_BLOCK_LEN, TEST_BLOCK_COUNT);
@


1.13
log
@Nope, that's not right either.  Fix check for mutually exclusive args.
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.12 2001/06/03 17:02:53 espie Exp $	*/
a266 1

@


1.12
log
@Obvious thinko: command line is wrong if it's too short, not too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.11 2001/06/02 21:04:53 millert Exp $	*/
d84 1
a84 1
	int ch, digest_type;
d98 2
a99 2
	while ((ch = getopt(argc, argv, "ps:tx")) != -1) {
		switch (ch) {
d119 3
a121 1
	if (pflag + tflag + xflag + argc < 1)
@


1.11
log
@Fix some typos and add missing test for string of 1 million a's.
@
text
@d1 1
a1 1
/*	$OpenBSD: md5.c,v 1.10 2001/06/02 20:38:06 millert Exp $	*/
d119 1
a119 1
	if (pflag + tflag + xflag + argc > 1)
@


1.10
log
@New md5/sha1/rmd160 driver with a BSD copyright.  Improvements:
o options that should be mutually exclusive are
o time trial works reasonably when it finishes in < 1 sec
o uses a function table instead of a bunch of globals
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d140 1
a140 1
	char *digtest;
d142 3
a144 3
	digtest = hf->data(string, strlen(string), NULL);
	(void)printf("%s (\"%s\") = %s\n", hf->name, string, digtest);
	free(digtest);
d223 15
a238 1
	/* XXX - different test data for different hashes? */
d241 19
a259 12
	/* MD5 test suite as per RFC 1321 */
	digest_string("", hf);
	digest_string("a", hf);
	digest_string("abc", hf);
	digest_string("message digest", hf);
	digest_string("abcdefghijklmnopqrstuvwxyz", hf);
	digest_string("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
	    "0123456789", hf);
	digest_string("1234567890123456789012345678901234567890123456789"
	    "0123456789012345678901234567890", hf);
	digest_string("abcdbcdecdefdefgefghfghighijhijkijkljklmklmn"
	    "lmnomnopnopq", hf);
@


1.9
log
@One single malloc, with a union to get the largest needed size,
should be enough.
@
text
@d1 1
a1 6
/*
 * $OpenBSD: md5.c,v 1.8 1998/01/02 07:04:23 deraadt Exp $
 *
 * Derived from:
 *	MDDRIVER.C - test driver for MD2, MD4 and MD5
 */
d4 2
a5 2
 *  Copyright (C) 1990-2, RSA Data Security, Inc. Created 1990. All
 *  rights reserved.
d7 10
a16 4
 *  RSA Data Security, Inc. makes no representations concerning either
 *  the merchantability of this software or the suitability of this
 *  software for any particular purpose. It is provided "as is"
 *  without express or implied warranty of any kind.
d18 10
a27 2
 *  These notices must be retained in any copies of any part of this
 *  documentation and/or software.
d30 1
d32 1
d35 1
d37 1
a37 1
#include <string.h>
d43 3
a45 5
/*
 * Length of test block, number of test blocks.
 */
#define TEST_BLOCK_LEN 10000
#define TEST_BLOCK_COUNT 10000
d48 24
a71 3
	RMD160_CTX a; 
	SHA1_CTX b; 
	MD5_CTX c;
d75 5
a80 25
static void MDString __P((char *));
static void MDTimeTrial __P((void *));
static void MDTestSuite __P((void));
static void MDFilter __P((int, void *));
static void usage __P((char *));

/*
 * Globals for indirection...
 */
void (*MDInit)();
void (*MDUpdate)();
char * (*MDEnd)();
char * (*MDFile)();
char * (*MDData)();
char *MDType;

/* Main driver.
 *
 * Arguments (may be any combination):
 *   -sstring - digests string
 *   -t       - runs time trial
 *   -x       - runs test script
 *   filename - digests file
 *   (none)   - digests standard input
 */
d82 33
a114 34
main(argc, argv)
	int     argc;
	char   *argv[];
{
	int     ch;
	char   *p;
	char	buf[41];
	void   *context;

	if ((context = malloc(sizeof(union ANY_CTX))) == NULL)
			err(1, "malloc");

	/* What were we called as?  Default to md5 */
	if (strcmp(__progname, "rmd160") == 0) {
		MDType = "RMD160";
		MDInit = RMD160Init;
		MDUpdate = RMD160Update;
		MDEnd = RMD160End;
		MDFile = RMD160File;
		MDData = RMD160Data;
	} else if (strcmp(__progname, "sha1") == 0) {
		MDType = "SHA1";
		MDInit = SHA1Init;
		MDUpdate = SHA1Update;
		MDEnd = SHA1End;
		MDFile = SHA1File;
		MDData = SHA1Data;
	} else {
		MDType = "MD5";
		MDInit = MD5Init;
		MDUpdate = MD5Update;
		MDEnd = MD5End;
		MDFile = MD5File;
		MDData = MD5Data;
d116 2
d119 14
a132 30
	if (argc > 1) {
		while ((ch = getopt(argc, argv, "ps:tx")) != -1) {
			switch (ch) {
			case 'p':
				MDFilter(1, context);
				break;
			case 's':
				MDString(optarg);
				break;
			case 't':
				MDTimeTrial(context);
				break;
			case 'x':
				MDTestSuite();
				break;
			default:
				usage(MDType);
			}
		}
		while (optind < argc) {
			p = MDFile(argv[optind], buf);
			if (!p)
				perror(argv[optind]);
			else
				printf("%s (%s) = %s\n", MDType,
				    argv[optind], p);
			optind++;
		}
	} else
		MDFilter(0, context);
d136 11
a146 3
/*
 * Digests a string and prints the result.
 */
d148 1
a148 2
MDString(string)
	char   *string;
d150 23
a172 2
	size_t len = strlen(string);
	char buf[41];
d174 7
a180 2
	(void)printf("%s (\"%s\") = %s\n", MDType, string,
	    MDData(string, len, buf));
d182 4
a185 3
/*
 * Measures the time to digest TEST_BLOCK_COUNT TEST_BLOCK_LEN-byte blocks.
 */
d187 1
a187 2
MDTimeTrial(context)
	void *context;
d189 6
a194 4
	time_t  endTime, startTime;
	unsigned char block[TEST_BLOCK_LEN];
	unsigned int i;
	char   *p, buf[41];
d196 2
a197 2
	(void)printf("%s time trial. Digesting %d %d-byte blocks ...", MDType,
	    TEST_BLOCK_LEN, TEST_BLOCK_COUNT);
d200 1
a200 1
	/* Initialize block */
d202 1
a202 1
		block[i] = (unsigned char) (i & 0xff);
d204 2
a205 5
	/* Start timer */
	time(&startTime);

	/* Digest blocks */
	MDInit(context);
d207 12
a218 2
		MDUpdate(context, block, (size_t)TEST_BLOCK_LEN);
	p = MDEnd(context,buf);
a219 16
	/* Stop timer */
	time(&endTime);

	(void)printf(" done\nDigest = %s", p);
	(void)printf("\nTime = %ld seconds\n", (long) (endTime - startTime));
	/*
	 * Be careful that endTime-startTime is not zero.
	 * (Bug fix from Ric Anderson <ric@@Artisoft.COM>)
	 */
	(void)printf("Speed = %ld bytes/second\n",
	    (long) TEST_BLOCK_LEN * (long) TEST_BLOCK_COUNT /
	    ((endTime - startTime) != 0 ? (endTime - startTime) : 1));
}
/*
 * Digests a reference suite of strings and prints the results.
 */
d221 1
a221 1
MDTestSuite()
a222 1
	(void)printf("%s test suite:\n", MDType);
d224 2
a225 12
	MDString("");
	MDString("a");
	MDString("abc");
	MDString("message digest");
	MDString("abcdefghijklmnopqrstuvwxyz");
	MDString
	    ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
	MDString
	    ("1234567890123456789012345678901234567890\
1234567890123456789012345678901234567890");
	MDString("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
}
d227 12
a238 19
/*
 * Digests the standard input and prints the result.
 */
static void
MDFilter(pipe, context)
	int pipe;
	void *context;
{
	size_t	len;
	unsigned char buffer[BUFSIZ];
	char buf[41];

	MDInit(context);
	while ((len = fread(buffer, (size_t)1, (size_t)BUFSIZ, stdin)) > 0) {
		if (pipe && (len != fwrite(buffer, (size_t)1, len, stdout)))
			err(1, "stdout");
		MDUpdate(context, buffer, len);
	}
	(void)printf("%s\n", MDEnd(context,buf));
d242 1
a242 2
usage(type)
char *type;
d244 3
a246 1
	fprintf(stderr, "usage: %s [-ptx] [-s string] [file ...]\n", type);
@


1.8
log
@use getopt; mph@@pobox.com
@
text
@d2 1
a2 1
 * $OpenBSD: md5.c,v 1.7 1997/08/01 10:07:11 deraadt Exp $
d37 6
a50 2
int main __P((int, char *[]));

d80 3
a90 2
		if ((context = malloc(sizeof(RMD160_CTX))) == NULL)
			err(1, "malloc");
a97 2
		if ((context = malloc(sizeof(SHA1_CTX))) == NULL)
			err(1, "malloc");
a104 2
		if ((context = malloc(sizeof(MD5_CTX))) == NULL)
			err(1, "malloc");
@


1.7
log
@warn not warnx
@
text
@d2 1
a2 1
 * $OpenBSD: md5.c,v 1.6 1997/07/17 05:45:01 millert Exp $
d43 1
d71 1
a71 1
	int     i;
d106 10
a115 5
	if (argc > 1)
		for (i = 1; i < argc; i++)
			if (argv[i][0] == '-' && argv[i][1] == 's')
				MDString(argv[i] + 2);
			else if (strcmp(argv[i], "-t") == 0)
d117 2
a118 3
			else if (strcmp(argv[i], "-p") == 0)
				MDFilter(1, context);
			else if (strcmp(argv[i], "-x") == 0)
d120 3
a122 7
			else {
				p = MDFile(argv[i], buf);
				if (!p)
					warn(argv[i]);
				else
					(void)printf("%s (%s) = %s\n", MDType,
					    argv[i], p);
d124 11
a134 1
	else
d234 8
@


1.6
log
@Adds rmd160 functionality.
@
text
@d2 1
a2 1
 * $OpenBSD: md5.c,v 1.5 1997/07/12 21:09:02 millert Exp $
d118 1
a118 1
					warnx(argv[i]);
@


1.5
log
@md5(1) is now capable of doing md4, md5 and sha1 digests.  Currently
only md5 and sha1 are used.
@
text
@d2 1
a2 1
 * $OpenBSD$
a26 1
#include <md4.h>
d29 1
d76 10
a85 1
	if (strcmp(__progname, "sha1") == 0) {
a92 9
			err(1, "malloc");
	} else if (strcmp(__progname, "md4") == 0) {
		MDType = "MD4";
		MDInit = MD4Init;
		MDUpdate = MD4Update;
		MDEnd = MD4End;
		MDFile = MD4File;
		MDData = MD4Data;
		if ((context = malloc(sizeof(MD4_CTX))) == NULL)
@


1.4
log
@boost TEST_BLOCK_LEN and TEST_BLOCK_COUNT a bit. this makes '-t' more
useful on fast boxes.
also fflush(stdout) after printing the first test message so
the user knows its actually doing something
@
text
@d2 1
a2 1
 * $OpenBSD: md5.c,v 1.3 1996/11/24 02:26:00 niklas Exp $
d5 1
a5 4
 */

/*
 * MDDRIVER.C - test driver for MD2, MD4 and MD5
d21 1
d23 1
d26 2
a27 1
#include "global.h"
d29 1
d37 8
a44 4
static void MDString PROTO_LIST((char *));
static void MDTimeTrial PROTO_LIST((void));
static void MDTestSuite PROTO_LIST((void));
static void MDFilter PROTO_LIST((int));
d46 9
a54 1
int main PROTO_LIST((int, char *[]));
d57 7
a63 7

Arguments (may be any combination):
  -sstring - digests string
  -t       - runs time trial
  -x       - runs test script
  filename - digests file
  (none)   - digests standard input
d72 32
a103 1
	char	buf[33];
d110 1
a110 1
				MDTimeTrial();
d112 1
a112 1
				MDFilter(1);
d116 1
a116 1
				p = MD5File(argv[i],buf);
d118 1
a118 1
					perror(argv[i]);
d120 2
a121 1
					printf("MD5 (%s) = %s\n", argv[i], p);
d124 1
a124 1
		MDFilter(0);
d126 1
a126 1
	return (0);
d136 1
a136 1
	char buf[33];
d138 2
a139 1
	printf("MD5 (\"%s\") = %s\n", string, MD5Data(string, len, buf));
d145 2
a146 1
MDTimeTrial()
a147 1
	MD5_CTX context;
d151 1
a151 1
	char   *p, buf[33];
d153 1
a153 2
	printf
	    ("MD5 time trial. Digesting %d %d-byte blocks ...",
d165 1
a165 1
	MD5Init(&context);
d167 2
a168 2
		MD5Update(&context, block, (size_t)TEST_BLOCK_LEN);
	p = MD5End(&context,buf);
d173 9
a181 8
	printf(" done\n");
	printf("Digest = %s", p);
	printf("\nTime = %ld seconds\n", (long) (endTime - startTime));
	/* Be careful that endTime-startTime is not zero. (Bug fix from Ric
	 * Anderson, ric@@Artisoft.COM.) */
	printf
	    ("Speed = %ld bytes/second\n",
	    (long) TEST_BLOCK_LEN * (long) TEST_BLOCK_COUNT / ((endTime - startTime) != 0 ? (endTime - startTime) : 1));
d189 1
a189 1
	printf("MD5 test suite:\n");
d201 1
d208 3
a210 1
MDFilter(int pipe)
a211 1
	MD5_CTX context;
d214 1
a214 1
	char buf[33];
d216 1
a216 1
	MD5Init(&context);
d218 3
a220 5
		if(pipe && (len != fwrite(buffer, (size_t)1, len, stdout))) {
			perror("stdout");
			exit(1);
		}
		MD5Update(&context, buffer, len);
d222 1
a222 1
	printf("%s\n", MD5End(&context,buf));
@


1.3
log
@64-bit cleanup + pedantic -W flags
@
text
@d2 1
a2 1
 * $OpenBSD: md5.c,v 1.2 1996/11/12 23:33:02 niklas Exp $
d33 2
a34 2
#define TEST_BLOCK_LEN 1000
#define TEST_BLOCK_COUNT 1000
d110 1
@


1.2
log
@-Wall happiness
@
text
@d2 1
a2 1
 * $OpenBSD: md5.c,v 1.1 1996/06/11 10:37:38 deraadt Exp $
d41 2
d90 1
a90 1
	unsigned int len = strlen(string);
d121 1
a121 1
		MD5Update(&context, block, TEST_BLOCK_LEN);
d163 1
a163 1
	int     len;
d168 2
a169 2
	while ((len = fread(buffer, 1, BUFSIZ, stdin)) > 0) {
		if(pipe && (len != fwrite(buffer, 1, len, stdout))) {
@


1.1
log
@move to bin/md5 for `greater accessibility'
@
text
@d2 1
a2 1
 * $OpenBSD: md5.c,v 1.1 1996/06/03 22:08:27 niklas Exp $
d162 1
a162 1
	unsigned char buffer[BUFSIZ], digest[16];
d166 1
a166 1
	while (len = fread(buffer, 1, BUFSIZ, stdin)) {
@
