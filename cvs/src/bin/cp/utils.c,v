head	1.39;
access;
symbols
	OPENBSD_6_1:1.39.0.8
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.33.0.10
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.6
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.4
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.2
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.4
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.30.0.6
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.4
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.10
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.6
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.4
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.26.0.10
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.8
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.6
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.4
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.25.0.4
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.14.0.8
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.14.0.6
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.4
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.13.0.4
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2015.12.26.18.11.43;	author guenther;	state Exp;
branches;
next	1.38;
commitid	HGmieU3gxciwwhhR;

1.38
date	2015.11.16.21.35.58;	author tedu;	state Exp;
branches;
next	1.37;
commitid	dwAipzivqgQvxKgb;

1.37
date	2015.05.03.19.44.58;	author guenther;	state Exp;
branches;
next	1.36;
commitid	EhByHUPhmNVyA3OR;

1.36
date	2015.01.19.00.41.44;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	STKPVQt48diNyNP8;

1.35
date	2015.01.16.06.39.31;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	Uu5nFG3wCl0LACBb;

1.34
date	2014.04.24.01.34.35;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2012.07.11.16.19.24;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	2012.04.11.09.45.47;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2011.06.23.11.43.13;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.22.21.10.49;	author sobrado;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.16.18.13.57;	author sobrado;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.06.06.50.00;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.10.10.23.30;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.24.04.22.44;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.06.21.08.05;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.29.00.24.14;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.23.32.06;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.01.23.50.02;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.04.04.26.39;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.30.06.20.27;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.06.13.29.08;	author mpech;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.25.04.35.31;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.11.14.01.50;	author art;	state Exp;
branches;
next	1.14;

1.14
date	99.05.06.17.19.47;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.09.26.21.53.16;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.06.07.05.16.34;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.05.18.09.58.05;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.11.08.23.17.12;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	97.09.01.18.29.19;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.07.31.17.00.58;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.05.28.21.53.32;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.04.05.04.37.40;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	97.02.25.02.27.28;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.02.24.20.43.27;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.26.22.04.45;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.10;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Set the times, mode, and flags on symlinks when doing cp -p (or mv across
filesystems)

problem noted by Carsten Kunze (carsten.kunze (at) arcor.de)
@
text
@/*	$OpenBSD: utils.c,v 1.38 2015/11/16 21:35:58 tedu Exp $	*/
/*	$NetBSD: utils.c,v 1.6 1997/02/26 14:40:51 cgd Exp $	*/

/*-
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>		/* MAXBSIZE */
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/time.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <fts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "extern.h"

int
copy_file(FTSENT *entp, int dne)
{
	static char *buf;
	static char *zeroes;
	struct stat to_stat, *fs;
	int ch, checkch, from_fd, rcount, rval, to_fd, wcount;
#ifdef VM_AND_BUFFER_CACHE_SYNCHRONIZED
	char *p;
#endif

	if (!buf) {
		buf = malloc(MAXBSIZE);
		if (!buf)
			err(1, "malloc");
	}
	if (!zeroes) {
		zeroes = calloc(1, MAXBSIZE);
		if (!zeroes)
			err(1, "calloc");
	}

	if ((from_fd = open(entp->fts_path, O_RDONLY, 0)) == -1) {
		warn("%s", entp->fts_path);
		return (1);
	}

	fs = entp->fts_statp;

	/*
	 * In -f (force) mode, we always unlink the destination first
	 * if it exists.  Note that -i and -f are mutually exclusive.
	 */
	if (!dne && fflag)
		(void)unlink(to.p_path);

	/*
	 * If the file exists and we're interactive, verify with the user.
	 * If the file DNE, set the mode to be the from file, minus setuid
	 * bits, modified by the umask; arguably wrong, but it makes copying
	 * executables work right and it's been that way forever.  (The
	 * other choice is 666 or'ed with the execute bits on the from file
	 * modified by the umask.)
	 */
	if (!dne && !fflag) {
		if (iflag) {
			(void)fprintf(stderr, "overwrite %s? ", to.p_path);
			checkch = ch = getchar();
			while (ch != '\n' && ch != EOF)
				ch = getchar();
			if (checkch != 'y' && checkch != 'Y') {
				(void)close(from_fd);
				return (0);
			}
		}
		to_fd = open(to.p_path, O_WRONLY | O_TRUNC, 0);
	} else
		to_fd = open(to.p_path, O_WRONLY | O_TRUNC | O_CREAT,
		    fs->st_mode & ~(S_ISTXT | S_ISUID | S_ISGID));

	if (to_fd == -1) {
		warn("%s", to.p_path);
		(void)close(from_fd);
		return (1);
	}

	rval = 0;

	/*
	 * Mmap and write if less than 8M (the limit is so we don't totally
	 * trash memory on big files.  This is really a minor hack, but it
	 * wins some CPU back.
	 */
#ifdef VM_AND_BUFFER_CACHE_SYNCHRONIZED
	/* XXX broken for 0-size mmap */
	if (fs->st_size <= 8 * 1048576) {
		if ((p = mmap(NULL, (size_t)fs->st_size, PROT_READ,
		    MAP_FILE|MAP_SHARED, from_fd, (off_t)0)) == MAP_FAILED) {
			warn("mmap: %s", entp->fts_path);
			rval = 1;
		} else {
			madvise(p, fs->st_size, MADV_SEQUENTIAL);
			if (write(to_fd, p, fs->st_size) != fs->st_size) {
				warn("%s", to.p_path);
				rval = 1;
			}
			/* Some systems don't unmap on close(2). */
			if (munmap(p, fs->st_size) < 0) {
				warn("%s", entp->fts_path);
				rval = 1;
			}
		}
	} else
#endif
	{
		int skipholes = 0;
		struct stat tosb;
		if (!fstat(to_fd, &tosb) && S_ISREG(tosb.st_mode))
			skipholes = 1;
		while ((rcount = read(from_fd, buf, MAXBSIZE)) > 0) {
			if (skipholes && memcmp(buf, zeroes, rcount) == 0)
				wcount = lseek(to_fd, rcount, SEEK_CUR) == -1 ? -1 : rcount;
			else
				wcount = write(to_fd, buf, rcount);
			if (rcount != wcount || wcount == -1) {
				warn("%s", to.p_path);
				rval = 1;
				break;
			}
		}
		if (skipholes && rcount >= 0)
			rcount = ftruncate(to_fd, lseek(to_fd, 0, SEEK_CUR));
		if (rcount < 0) {
			warn("%s", entp->fts_path);
			rval = 1;
		}
	}

	if (rval == 1) {
		(void)close(from_fd);
		(void)close(to_fd);
		return (1);
	}

	if (pflag && setfile(fs, to_fd))
		rval = 1;
	/*
	 * If the source was setuid or setgid, lose the bits unless the
	 * copy is owned by the same user and group.
	 */
#define	RETAINBITS \
	(S_ISUID | S_ISGID | S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
	if (!pflag && dne &&
	    fs->st_mode & (S_ISUID | S_ISGID) && fs->st_uid == myuid) {
		if (fstat(to_fd, &to_stat)) {
			warn("%s", to.p_path);
			rval = 1;
		} else if (fs->st_gid == to_stat.st_gid &&
		    fchmod(to_fd, fs->st_mode & RETAINBITS & ~myumask)) {
			warn("%s", to.p_path);
			rval = 1;
		}
	}
	(void)close(from_fd);
	if (close(to_fd)) {
		warn("%s", to.p_path);
		rval = 1;
	}
	return (rval);
}

int
copy_link(FTSENT *p, int exists)
{
	int len;
	char name[PATH_MAX];

	if ((len = readlink(p->fts_path, name, sizeof(name)-1)) == -1) {
		warn("readlink: %s", p->fts_path);
		return (1);
	}
	name[len] = '\0';
	if (exists && unlink(to.p_path)) {
		warn("unlink: %s", to.p_path);
		return (1);
	}
	if (symlink(name, to.p_path)) {
		warn("symlink: %s", name);
		return (1);
	}
	return (pflag ? setfile(p->fts_statp, -1) : 0);
}

int
copy_fifo(struct stat *from_stat, int exists)
{
	if (exists && unlink(to.p_path)) {
		warn("unlink: %s", to.p_path);
		return (1);
	}
	if (mkfifo(to.p_path, from_stat->st_mode)) {
		warn("mkfifo: %s", to.p_path);
		return (1);
	}
	return (pflag ? setfile(from_stat, -1) : 0);
}

int
copy_special(struct stat *from_stat, int exists)
{
	if (exists && unlink(to.p_path)) {
		warn("unlink: %s", to.p_path);
		return (1);
	}
	if (mknod(to.p_path, from_stat->st_mode, from_stat->st_rdev)) {
		warn("mknod: %s", to.p_path);
		return (1);
	}
	return (pflag ? setfile(from_stat, -1) : 0);
}


int
setfile(struct stat *fs, int fd)
{
	struct timespec ts[2];
	int rval;

	rval = 0;
	fs->st_mode &= S_ISTXT | S_ISUID | S_ISGID | S_IRWXU | S_IRWXG | S_IRWXO;

	ts[0] = fs->st_atim;
	ts[1] = fs->st_mtim;
	if (fd >= 0 ? futimens(fd, ts) :
	    utimensat(AT_FDCWD, to.p_path, ts, AT_SYMLINK_NOFOLLOW)) {
		warn("update times: %s", to.p_path);
		rval = 1;
	}
	/*
	 * Changing the ownership probably won't succeed, unless we're root
	 * or POSIX_CHOWN_RESTRICTED is not set.  Set uid/gid before setting
	 * the mode; current BSD behavior is to remove all setuid bits on
	 * chown.  If chown fails, lose setuid/setgid bits.
	 */
	if (fd >= 0 ? fchown(fd, fs->st_uid, fs->st_gid) :
	    lchown(to.p_path, fs->st_uid, fs->st_gid)) {
		if (errno != EPERM) {
			warn("chown: %s", to.p_path);
			rval = 1;
		}
		fs->st_mode &= ~(S_ISTXT | S_ISUID | S_ISGID);
	}
	if (fd >= 0 ? fchmod(fd, fs->st_mode) :
	    fchmodat(AT_FDCWD, to.p_path, fs->st_mode, AT_SYMLINK_NOFOLLOW)) {
		warn("chmod: %s", to.p_path);
		rval = 1;
	}

	/*
	 * XXX
	 * NFS doesn't support chflags; ignore errors unless there's reason
	 * to believe we're losing bits.  (Note, this still won't be right
	 * if the server supports flags and we were trying to *remove* flags
	 * on a file that we copied, i.e., that we didn't create.)
	 */
	errno = 0;
	if (fd >= 0 ? fchflags(fd, fs->st_flags) :
	    chflagsat(AT_FDCWD, to.p_path, fs->st_flags, AT_SYMLINK_NOFOLLOW))
		if (errno != EOPNOTSUPP || fs->st_flags != 0) {
			warn("chflags: %s", to.p_path);
			rval = 1;
		}
	return (rval);
}


void
usage(void)
{
	(void)fprintf(stderr,
	    "usage: %s [-fip] [-R [-H | -L | -P]] source target\n", __progname);
	(void)fprintf(stderr,
	    "       %s [-fip] [-R [-H | -L | -P]] source ... directory\n",
	    __progname);
	exit(1);
}
@


1.38
log
@rename link to name to avoid shadowing the function
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.37 2015/05/03 19:44:58 guenther Exp $	*/
d220 1
a220 1
	return (pflag ? setlink(p->fts_statp) : 0);
a302 14
}


int
setlink(struct stat *fs)
{

	if (lchown(to.p_path, fs->st_uid, fs->st_gid)) {
		if (errno != EPERM) {
			warn("lchown: %s", to.p_path);
			return (1);
		}
	}
	return (0);
@


1.37
log
@Preserve times to nanosecond precision instead of just microsecond.
Prefer to set attributes by fd for regular files, and not follwing
symlinks for others.

ok brynet@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.36 2015/01/19 00:41:44 deraadt Exp $	*/
d205 1
a205 1
	char link[PATH_MAX];
d207 1
a207 1
	if ((len = readlink(p->fts_path, link, sizeof(link)-1)) == -1) {
d211 1
a211 1
	link[len] = '\0';
d216 2
a217 2
	if (symlink(link, to.p_path)) {
		warn("symlink: %s", link);
@


1.36
log
@cleanup sys/param.h comment
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.35 2015/01/16 06:39:31 deraadt Exp $	*/
d234 1
a234 1
	return (pflag ? setfile(from_stat, 0) : 0);
d248 1
a248 1
	return (pflag ? setfile(from_stat, 0) : 0);
d255 1
a255 1
	static struct timeval tv[2];
d261 5
a265 4
	TIMESPEC_TO_TIMEVAL(&tv[0], &fs->st_atimespec);
	TIMESPEC_TO_TIMEVAL(&tv[1], &fs->st_mtimespec);
	if (utimes(to.p_path, tv)) {
		warn("utimes: %s", to.p_path);
d274 2
a275 2
	if (fd ? fchown(fd, fs->st_uid, fs->st_gid) :
	    chown(to.p_path, fs->st_uid, fs->st_gid)) {
d282 2
a283 1
	if (fd ? fchmod(fd, fs->st_mode) : chmod(to.p_path, fs->st_mode)) {
d296 2
a297 1
	if (fd ? fchflags(fd, fs->st_flags) : chflags(to.p_path, fs->st_flags))
@


1.35
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.34 2014/04/24 01:34:35 tedu Exp $	*/
d33 1
a33 1
#include <sys/param.h>		/* for MAXBSIZE */
@


1.34
log
@calloc is better. from Peter Malone
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.33 2012/07/11 16:19:24 matthew Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d46 1
d205 1
a205 1
	char link[MAXPATHLEN];
@


1.33
log
@When copying a file sparsely, truncate the resulting file based on the
current seek offset rather than what fstat() reported the original
file's length was.  This fixes things like "cp /dev/ksyms /tmp" so
that we don't truncate the file to 0 bytes after copying all of the
data.

ok tedu, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.32 2012/04/11 09:45:47 espie Exp $	*/
d66 1
a66 1
		zeroes = malloc(MAXBSIZE);
d68 1
a68 2
			err(1, "malloc");
		memset(zeroes, 0, MAXBSIZE);
@


1.32
log
@if we ever activate that, this may need fixing
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.31 2011/06/23 11:43:13 otto Exp $	*/
d161 1
a161 1
			rcount = ftruncate(to_fd, fs->st_size);
@


1.31
log
@set set*id bits only if the target did not exist and -p was not used;
from netbsd, prompted by Jesus Sanchez. ok miller@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.30 2009/10/27 23:59:21 deraadt Exp $	*/
d124 1
@


1.30
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.29 2007/09/22 21:10:49 sobrado Exp $	*/
d181 2
a182 1
	else if (fs->st_mode & (S_ISUID | S_ISGID) && fs->st_uid == myuid) {
@


1.29
log
@warn should return an error message for chmod, not for chown

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.28 2007/09/16 18:13:57 sobrado Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)utils.c	8.3 (Berkeley) 4/1/94";
#else
static char rcsid[] = "$OpenBSD: utils.c,v 1.28 2007/09/16 18:13:57 sobrado Exp $";
#endif
#endif /* not lint */
@


1.28
log
@"source" and "target" can be either files or directories;
cp(1) and ln(1) must have a synopsis consistent with mkdir(1),
mv(1), rmdir(1) and others

ok jmc@@, millert@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.27 2007/04/06 06:50:00 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.27 2007/04/06 06:50:00 tedu Exp $";
d288 1
a288 1
		warn("chown: %s", to.p_path);
@


1.27
log
@when copying regular files, look for blocks of zeroes.  when we see them,
just lseek ahead to create a sparse file.  saves disk and time.
note this behavior in the man page.
ok? deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.26 2004/12/10 10:23:30 jmc Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.26 2004/12/10 10:23:30 jmc Exp $";
d327 1
a327 1
	    "usage: %s [-fip] [-R [-H | -L | -P]] source_file target_file\n", __progname);
d329 1
a329 1
	    "       %s [-fip] [-R [-H | -L | -P]] source_file ... target_directory\n",
@


1.26
log
@sort options + sync usage();
standard EXAMPLES;
various other tweaks;

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.25 2003/11/24 04:22:44 mickey Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.25 2003/11/24 04:22:44 mickey Exp $";
d60 2
a61 1
	static char buf[MAXBSIZE];
d68 12
d152 4
d157 4
a160 1
			wcount = write(to_fd, buf, rcount);
d167 2
@


1.25
log
@madvise mmapped memory (not used code)
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.24 2003/08/06 21:08:05 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.24 2003/08/06 21:08:05 millert Exp $";
d305 1
a305 1
	    "usage: %s [-R [-H | -L | -P]] [-fip] src target\n", __progname);
d307 1
a307 1
	    "       %s [-R [-H | -L | -P]] [-fip] src1 ... srcN directory\n",
@


1.24
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.23 2003/07/29 00:24:14 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.23 2003/07/29 00:24:14 deraadt Exp $";
d125 1
@


1.23
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.22 2003/06/02 23:32:06 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.22 2003/06/02 23:32:06 millert Exp $";
d108 1
a108 1
		return (1);;
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.21 2003/06/01 23:50:02 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.21 2003/06/01 23:50:02 millert Exp $";
d304 1
a304 1
            "usage: %s [-R [-H | -L | -P]] [-fip] src target\n", __progname);
d306 2
a307 2
            "       %s [-R [-H | -L | -P]] [-fip] src1 ... srcN directory\n",
             __progname);
@


1.21
log
@Undo a misguided attempt to fix speling errors from long ago.  UCB
copyrights say "acknowledgement", not "acknowledgment".  You cannot
just go changing the text of a license willy-nilly.
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.20 2002/07/04 04:26:39 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.20 2002/07/04 04:26:39 deraadt Exp $";
@


1.20
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.19 2002/05/30 06:20:27 deraadt Exp $	*/
d17 1
a17 1
 *    must display the following acknowledgment:
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.19 2002/05/30 06:20:27 deraadt Exp $";
@


1.19
log
@typo; moritz@@jodeit.org
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.18 2001/11/05 07:39:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.18 2001/11/05 07:39:16 mpech Exp $";
d62 1
a62 3
copy_file(entp, dne)
	FTSENT *entp;
	int dne;
d189 1
a189 3
copy_link(p, exists)
	FTSENT *p;
	int exists;
d211 1
a211 3
copy_fifo(from_stat, exists)
	struct stat *from_stat;
	int exists;
d225 1
a225 3
copy_special(from_stat, exists)
	struct stat *from_stat;
	int exists;
d240 1
a240 3
setfile(fs, fd)
	struct stat *fs;
	int fd;
d291 1
a291 2
setlink(fs)
	struct stat *fs;
d305 1
a305 1
usage()
@


1.18
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.17 2001/09/06 13:29:08 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.17 2001/09/06 13:29:08 mpech Exp $";
d82 1
a82 1
	 * if it exists.  Note that -i and -f are mututally exclusive.
@


1.17
log
@o) __progname aria;

millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.16 2001/06/25 04:35:31 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.16 2001/06/25 04:35:31 art Exp $";
d302 1
a302 1
	register struct stat *fs;
@


1.16
log
@explicit braces to avoid ambiguous else
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.15 2001/05/11 14:01:50 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.15 2001/05/11 14:01:50 art Exp $";
d318 5
a322 3
	(void)fprintf(stderr, "%s\n%s\n",
	    "usage: cp [-R [-H | -L | -P]] [-fip] src target",
	    "       cp [-R [-H | -L | -P]] [-fip] src1 ... srcN directory");
@


1.15
log
@Explicit mapping type to mmap. (not used yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.14 1999/05/06 17:19:47 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.14 1999/05/06 17:19:47 millert Exp $";
d172 1
a172 1
	else if (fs->st_mode & (S_ISUID | S_ISGID) && fs->st_uid == myuid)
d181 1
@


1.14
log
@"cp -f" should unlink the destination before copying.  Similar to
a patch from FreeBSD (but this is simpler).  Closes PR #821
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.13 1998/09/26 21:53:16 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.13 1998/09/26 21:53:16 deraadt Exp $";
d127 1
a127 1
		    0, from_fd, (off_t)0)) == MAP_FAILED) {
@


1.13
log
@for -p preserve sticky bit
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.12 1998/06/07 05:16:34 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.12 1998/06/07 05:16:34 deraadt Exp $";
d81 7
d95 1
a95 1
	if (!dne) {
@


1.12
log
@use MAP_FAILED
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.11 1998/05/18 09:58:05 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.11 1998/05/18 09:58:05 deraadt Exp $";
d102 1
a102 1
		    fs->st_mode & ~(S_ISUID | S_ISGID));
d248 1
a248 1
	fs->st_mode &= S_ISUID | S_ISGID | S_IRWXU | S_IRWXG | S_IRWXO;
d268 1
a268 1
		fs->st_mode &= ~(S_ISUID | S_ISGID);
@


1.11
log
@readlink(path, buf, sizeof buf-1).  Never forget that -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.10 1997/11/08 23:17:12 todd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.10 1997/11/08 23:17:12 todd Exp $";
d120 1
a120 1
		    0, from_fd, (off_t)0)) == (char *)-1) {
@


1.10
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.9 1997/09/01 18:29:19 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.9 1997/09/01 18:29:19 deraadt Exp $";
d190 1
a190 1
	if ((len = readlink(p->fts_path, link, sizeof(link))) == -1) {
@


1.9
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.8 1997/07/31 17:00:58 kstailey Exp $	*/
d17 1
a17 1
 *    must display the following acknowledgement:
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.8 1997/07/31 17:00:58 kstailey Exp $";
@


1.8
log
@improve error message (yes I know mmap(2) isn't used yet.)
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.7 1997/05/28 21:53:32 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.7 1997/05/28 21:53:32 deraadt Exp $";
d72 1
a72 1
	
@


1.7
log
@bad usage line; oster@@cs.usask.ca
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.6 1997/04/05 04:37:40 tholo Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.6 1997/04/05 04:37:40 tholo Exp $";
d121 1
a121 1
			warn("%s", entp->fts_path);
@


1.6
log
@Patch from BSDI (via Keith Bostic, via NetBSD):
>NFS doesn't support chflags; ignore errors unless there's reason
>to believe we're losing bits.  (Note, this still won't be right
>if the server supports flags and we were trying to *remove* flags
>on a file that we copied, i.e., that we didn't create.)
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.5 1997/02/25 02:27:28 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.5 1997/02/25 02:27:28 millert Exp $";
d311 2
a312 2
"usage: cp [-R [-H | -L | -P] [-fip] src target",
"       cp [-R [-H | -L | -P] [-fip] src1 ... srcN directory");
@


1.5
log
@Better fix for -p and links.
@
text
@d1 2
a2 2
/*	$OpenBSD: utils.c,v 1.4 1997/02/24 20:43:27 millert Exp $	*/
/*	$NetBSD: utils.c,v 1.4 1995/08/02 07:17:02 jtc Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.4 1997/02/24 20:43:27 millert Exp $";
d241 1
a241 1
	register struct stat *fs;
d245 1
a245 1
	int rval = 0;
d247 1
d271 1
a271 1
		warn("chmod: %s", to.p_path);
d275 13
a287 5
	if (fd ?
	    fchflags(fd, fs->st_flags) : chflags(to.p_path, fs->st_flags)) {
		warn("chflags: %s", to.p_path);
		rval = 1;
	}
@


1.4
log
@Only update owner (via lchown) when dealing with symbolic links.
Fixes core dump problem with ``-p'' and symbolic links.  Noted by
Carsten Hammer <chammer@@post.uni-bielefeld.de>.
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.3 1997/01/26 22:04:45 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.3 1997/01/26 22:04:45 kstailey Exp $";
d203 1
a203 1
	return (pflag ? setfile(p->fts_statp, 0) : 0);
a246 11
	/* Only change the owner for symbolic links. */
	if (S_ISLNK(fs->st_mode)) {
		if (lchown(to.p_path, fs->st_uid, fs->st_gid)) {
			if (errno != EPERM) {
				warn("lchown: %s", to.p_path);
				rval = 1;
			}
		}
		return (rval);
	}

d281 16
@


1.3
log
@support for lchown(2) if "-p" is used
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.2 1996/06/23 14:19:10 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.2 1996/06/23 14:19:10 deraadt Exp $";
d203 1
a203 1
	return (pflag ? setfile(NULL, 0) : 0);
d245 1
a245 1
	int rval;
d247 12
a258 3
	rval = 0;
	if (fs != NULL) {
		fs->st_mode &= S_ISUID | S_ISGID | S_IRWXU | S_IRWXG | S_IRWXO;
d260 5
a264 6
		TIMESPEC_TO_TIMEVAL(&tv[0], &fs->st_atimespec);
		TIMESPEC_TO_TIMEVAL(&tv[1], &fs->st_mtimespec);
		if (utimes(to.p_path, tv)) {
			warn("utimes: %s", to.p_path);
			rval = 1;
		}
d273 1
a273 1
	    lchown(to.p_path, fs->st_uid, fs->st_gid)) {
d275 1
a275 1
			warn("lchown: %s", to.p_path);
a277 2
		if (fs == NULL)
			return (rval);
d281 1
a281 1
		warn("chown: %s", to.p_path);
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.4 1995/08/02 07:17:02 jtc Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utils.c,v 1.4 1995/08/02 07:17:02 jtc Exp $";
d203 1
a203 1
	return (0);
d248 2
a249 1
	fs->st_mode &= S_ISUID | S_ISGID | S_IRWXU | S_IRWXG | S_IRWXO;
d251 6
a256 5
	TIMESPEC_TO_TIMEVAL(&tv[0], &fs->st_atimespec);
	TIMESPEC_TO_TIMEVAL(&tv[1], &fs->st_mtimespec);
	if (utimes(to.p_path, tv)) {
		warn("utimes: %s", to.p_path);
		rval = 1;
d265 1
a265 1
	    chown(to.p_path, fs->st_uid, fs->st_gid)) {
d267 1
a267 1
			warn("chown: %s", to.p_path);
d270 2
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: utils.c,v 1.4 1995/08/02 07:17:02 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
