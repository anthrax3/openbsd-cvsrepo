head	1.46;
access;
symbols
	OPENBSD_6_2:1.46.0.2
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.44.0.4
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.43.0.2
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.38.0.4
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.35.0.8
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.4
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.2
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.34.0.20
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.18
	OPENBSD_5_0:1.34.0.16
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.14
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.12
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.8
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.34.0.10
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.6
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.4
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.29.0.4
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.28.0.4
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.14.0.6
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.14.0.4
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2017.06.27.21.49.47;	author tedu;	state Exp;
branches;
next	1.45;
commitid	UcCI5eGbs5Q3hHLP;

1.45
date	2017.06.27.21.43.46;	author tedu;	state Exp;
branches;
next	1.44;
commitid	ffGkl3dPIrdhYvXu;

1.44
date	2016.10.14.10.51.57;	author schwarze;	state Exp;
branches;
next	1.43;
commitid	qsakiiSeXz4WMSIa;

1.43
date	2016.03.07.18.56.33;	author tb;	state Exp;
branches;
next	1.42;
commitid	VAXqzfPCOm8cAu03;

1.42
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	sbrB3Q5CNxcwZpfU;

1.41
date	2015.10.08.04.39.24;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	vHIEy1hwxm9NNAZd;

1.40
date	2015.10.08.00.07.20;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	Vspm4XBLhL8NK6D1;

1.39
date	2015.10.07.15.44.58;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	OiK8upzQk771qDLI;

1.38
date	2015.05.07.17.32.20;	author guenther;	state Exp;
branches;
next	1.37;
commitid	cpXqd0xoFYqXj9iw;

1.37
date	2015.01.16.06.39.31;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	Uu5nFG3wCl0LACBb;

1.36
date	2014.05.21.06.23.02;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2012.08.28.06.02.58;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.04.02.01.57;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2007.07.26.17.15.46;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2006.04.25.15.41.07;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.17.23.05.32;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.09.20.03.29;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.13.20.25.34;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2003.10.30.16.01.43;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.29.00.24.14;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.23.32.06;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.01.23.50.02;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.02.20.31.42;	author nino;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.13.22.17.04;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.13.09.09.20;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.06.01.52.52;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.04.04.26.39;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.09.05.47.26;	author todd;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.25.04.35.31;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.22.22.51.22;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.06.16.06.33;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.20.23.03.55;	author ericj;	state Exp;
branches;
next	1.13;

1.13
date	99.05.06.17.19.45;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.07.03.16.43.56;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	97.11.08.23.17.11;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	97.09.20.17.34.34;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.09.01.18.29.17;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.08.23.00.01.38;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.23.14.32.37;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.40.20;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.12.17.38;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.28.02.55.05;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.08.02.12.40.51;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.19.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.46
log
@fix a few lines of unusual length
@
text
@/*	$OpenBSD: cp.c,v 1.45 2017/06/27 21:43:46 tedu Exp $	*/
/*	$NetBSD: cp.c,v 1.14 1995/09/07 06:14:51 jtc Exp $	*/

/*
 * Copyright (c) 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * David Hitz of Auspex Systems Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Cp copies source files to target files.
 *
 * The global PATH_T structure "to" always contains the path to the
 * current target file.  Since fts(3) does not change directories,
 * this path can be either absolute or dot-relative.
 *
 * The basic algorithm is to initialize "to" and use fts(3) to traverse
 * the file hierarchy rooted in the argument list.  A trivial case is the
 * case of 'cp file1 file2'.  The more interesting case is the case of
 * 'cp file1 file2 ... fileN dir' where the hierarchy is traversed and the
 * path (relative to the root of the traversal) is appended to dir (stored
 * in "to") to form the final target path.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/time.h>

#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <fts.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "extern.h"

#define	fts_dne(_x)	(_x->fts_pointer != NULL)

PATH_T to = { to.p_path, "" };

uid_t myuid;
int Rflag, fflag, iflag, pflag, rflag, vflag;
mode_t myumask;

enum op { FILE_TO_FILE, FILE_TO_DIR, DIR_TO_DNE };

int copy(char *[], enum op, int);
char *find_last_component(char *);

int
main(int argc, char *argv[])
{
	struct stat to_stat, tmp_stat;
	enum op type;
	int Hflag, Lflag, Pflag, ch, fts_options, r;
	char *target;

	Hflag = Lflag = Pflag = Rflag = 0;
	while ((ch = getopt(argc, argv, "HLPRfiprv")) != -1)
		switch (ch) {
		case 'H':
			Hflag = 1;
			Lflag = Pflag = 0;
			break;
		case 'L':
			Lflag = 1;
			Hflag = Pflag = 0;
			break;
		case 'P':
			Pflag = 1;
			Hflag = Lflag = 0;
			break;
		case 'R':
			Rflag = 1;
			break;
		case 'f':
			fflag = 1;
			iflag = 0;
			break;
		case 'i':
			iflag = 1;
			fflag = 0;
			break;
		case 'p':
			pflag = 1;
			break;
		case 'r':
			rflag = 1;
			break;
		case 'v':
			vflag = 1;
			break;
		default:
			usage();
			break;
		}
	argc -= optind;
	argv += optind;

	/*
	 * Unfortunately, -R will use mkfifo & mknod;
	 * -p will use fchown, fchmod, lchown, fchflags..
	 */
	if (Rflag == 0 && pflag == 0)
		if (pledge("stdio rpath wpath cpath fattr", NULL) == -1)
			err(1, "pledge");

	if (argc < 2)
		usage();

	fts_options = FTS_NOCHDIR | FTS_PHYSICAL;
	if (rflag) {
		if (Rflag)
			errx(1,
		    "the -R and -r options may not be specified together.");
		if (Hflag || Lflag || Pflag)
			errx(1,
	"the -H, -L, and -P options may not be specified with the -r option.");
		fts_options &= ~FTS_PHYSICAL;
		fts_options |= FTS_LOGICAL;
	}
	if (Rflag) {
		if (Hflag)
			fts_options |= FTS_COMFOLLOW;
		if (Lflag) {
			fts_options &= ~FTS_PHYSICAL;
			fts_options |= FTS_LOGICAL;
		}
	} else {
		fts_options &= ~FTS_PHYSICAL;
		fts_options |= FTS_LOGICAL;
	}

	myuid = getuid();

	/* Copy the umask for explicit mode setting. */
	myumask = umask(0);
	(void)umask(myumask);

	/* Save the target base in "to". */
	target = argv[--argc];
	if (strlcpy(to.p_path, target, sizeof to.p_path) >= sizeof(to.p_path))
		errx(1, "%s: name too long", target);
	to.p_end = to.p_path + strlen(to.p_path);
	if (to.p_path == to.p_end) {
		*to.p_end++ = '.';
		*to.p_end = '\0';
	}
	to.target_end = to.p_end;

	/* Set end of argument list for fts(3). */
	argv[argc] = NULL;

	/*
	 * Cp has two distinct cases:
	 *
	 * cp [-R] source target
	 * cp [-R] source1 ... sourceN directory
	 *
	 * In both cases, source can be either a file or a directory.
	 *
	 * In (1), the target becomes a copy of the source. That is, if the
	 * source is a file, the target will be a file, and likewise for
	 * directories.
	 *
	 * In (2), the real target is not directory, but "directory/source".
	 */
	r = stat(to.p_path, &to_stat);
	if (r == -1 && errno != ENOENT)
		err(1, "%s", to.p_path);
	if (r == -1 || !S_ISDIR(to_stat.st_mode)) {
		/*
		 * Case (1).  Target is not a directory.
		 */
		if (argc > 1)
			usage();
		/*
		 * Need to detect the case:
		 *	cp -R dir foo
		 * Where dir is a directory and foo does not exist, where
		 * we want pathname concatenations turned on but not for
		 * the initial mkdir().
		 */
		if (r == -1) {
			if (rflag || (Rflag && (Lflag || Hflag)))
				stat(*argv, &tmp_stat);
			else
				lstat(*argv, &tmp_stat);

			if (S_ISDIR(tmp_stat.st_mode) && (Rflag || rflag))
				type = DIR_TO_DNE;
			else
				type = FILE_TO_FILE;
		} else
			type = FILE_TO_FILE;
	} else {
		/*
		 * Case (2).  Target is a directory.
		 */
		type = FILE_TO_DIR;
	}

	return (copy(argv, type, fts_options));
}

char *
find_last_component(char *path)
{
	char *p;

	if ((p = strrchr(path, '/')) == NULL)
		p = path;
	else {
		/* Special case foo/ */
		if (!*(p+1)) {
			while ((p >= path) && *p == '/')
				p--;

			while ((p >= path) && *p != '/')
				p--;
		}

		p++;
	}

	return (p);
}

int
copy(char *argv[], enum op type, int fts_options)
{
	struct stat to_stat;
	FTS *ftsp;
	FTSENT *curr;
	int base, nlen, rval;
	char *p, *target_mid;
	base = 0;

	if ((ftsp = fts_open(argv, fts_options, NULL)) == NULL)
		err(1, NULL);
	for (rval = 0; (curr = fts_read(ftsp)) != NULL;) {
		switch (curr->fts_info) {
		case FTS_NS:
		case FTS_DNR:
		case FTS_ERR:
			warnx("%s: %s",
			    curr->fts_path, strerror(curr->fts_errno));
			rval = 1;
			continue;
		case FTS_DC:
			warnx("%s: directory causes a cycle", curr->fts_path);
			rval = 1;
			continue;
		}

		/*
		 * If we are in case (2) or (3) above, we need to append the
		 * source name to the target name.
		 */
		if (type != FILE_TO_FILE) {
			/*
			 * Need to remember the roots of traversals to create
			 * correct pathnames.  If there's a directory being
			 * copied to a non-existent directory, e.g.
			 *	cp -R a/dir noexist
			 * the resulting path name should be noexist/foo, not
			 * noexist/dir/foo (where foo is a file in dir), which
			 * is the case where the target exists.
			 *
			 * Also, check for "..".  This is for correct path
			 * concatenation for paths ending in "..", e.g.
			 *	cp -R .. /tmp
			 * Paths ending in ".." are changed to ".".  This is
			 * tricky, but seems the easiest way to fix the problem.
			 *
			 * XXX
			 * Since the first level MUST be FTS_ROOTLEVEL, base
			 * is always initialized.
			 */
			if (curr->fts_level == FTS_ROOTLEVEL) {
				if (type != DIR_TO_DNE) {
					p = find_last_component(curr->fts_path);
					base = p - curr->fts_path;
					
					if (!strcmp(&curr->fts_path[base],
					    ".."))
						base += 1;
				} else
					base = curr->fts_pathlen;
			}

			p = &curr->fts_path[base];
			nlen = curr->fts_pathlen - base;
			target_mid = to.target_end;
			if (*p != '/' && target_mid[-1] != '/')
				*target_mid++ = '/';
			*target_mid = '\0';
			if (target_mid - to.p_path + nlen >= PATH_MAX) {
				warnx("%s%s: name too long (not copied)",
				    to.p_path, p);
				rval = 1;
				continue;
			}
			(void)strncat(target_mid, p, nlen);
			to.p_end = target_mid + nlen;
			*to.p_end = '\0';
		}

		/* Not an error but need to remember it happened */
		if (stat(to.p_path, &to_stat) == -1) {
			if (curr->fts_info == FTS_DP)
				continue;
			/*
			 * We use fts_pointer as a boolean to indicate that
			 * we created this directory ourselves.  We'll use
			 * this later on via the fts_dne macro to decide
			 * whether or not to set the directory mode during
			 * the post-order pass.
			 */
			curr->fts_pointer = (void *)1;
		} else {
			/*
			 * Set directory mode/user/times on the post-order
			 * pass.  We can't do this earlier because the mode
			 * may not allow us write permission.  Furthermore,
			 * if we set the times during the pre-order pass,
			 * they will get changed later when the directory
			 * is populated.
			 */
			if (curr->fts_info == FTS_DP) {
				if (!S_ISDIR(to_stat.st_mode))
					continue;
				/*
				 * If not -p and directory didn't exist, set
				 * it to be the same as the from directory,
				 * unmodified by the umask; arguably wrong,
				 * but it's been that way forever.
				 */
				if (pflag && setfile(curr->fts_statp, -1))
					rval = 1;
				else if (fts_dne(curr))
					(void)chmod(to.p_path,
					    curr->fts_statp->st_mode);
				continue;
			}
			if (to_stat.st_dev == curr->fts_statp->st_dev &&
			    to_stat.st_ino == curr->fts_statp->st_ino) {
				warnx("%s and %s are identical (not copied).",
				    to.p_path, curr->fts_path);
				rval = 1;
				if (S_ISDIR(curr->fts_statp->st_mode))
					(void)fts_set(ftsp, curr, FTS_SKIP);
				continue;
			}
			if (!S_ISDIR(curr->fts_statp->st_mode) &&
			    S_ISDIR(to_stat.st_mode)) {
		warnx("cannot overwrite directory %s with non-directory %s",
				    to.p_path, curr->fts_path);
				rval = 1;
				continue;
			}
		}

		switch (curr->fts_statp->st_mode & S_IFMT) {
		case S_IFLNK:
			if (copy_link(curr, !fts_dne(curr)))
				rval = 1;
			else if (vflag)
				(void)fprintf(stdout, "%s -> %s\n",
				    curr->fts_path, to.p_path);
			break;
		case S_IFDIR:
			if (!Rflag && !rflag) {
				warnx("%s is a directory (not copied).",
				    curr->fts_path);
				(void)fts_set(ftsp, curr, FTS_SKIP);
				rval = 1;
				break;
			}
			/*
			 * If the directory doesn't exist, create the new
			 * one with the from file mode plus owner RWX bits,
			 * modified by the umask.  Trade-off between being
			 * able to write the directory (if from directory is
			 * 555) and not causing a permissions race.  If the
			 * umask blocks owner writes, we fail..
			 */
			if (fts_dne(curr)) {
				if (mkdir(to.p_path,
				    curr->fts_statp->st_mode | S_IRWXU) < 0)
					err(1, "%s", to.p_path);
				else if (vflag)
					(void)fprintf(stdout, "%s -> %s\n",
					    curr->fts_path, to.p_path);
			} else if (!S_ISDIR(to_stat.st_mode))
				errc(1, ENOTDIR, "%s", to.p_path);
			break;
		case S_IFBLK:
		case S_IFCHR:
			if (Rflag) {
				if (copy_special(curr->fts_statp,
				    !fts_dne(curr)))
					rval = 1;
			} else
				if (copy_file(curr, fts_dne(curr)))
					rval = 1;
			if (!rval && vflag)
				(void)fprintf(stdout, "%s -> %s\n",
				    curr->fts_path, to.p_path);
			break;
		case S_IFIFO:
			if (Rflag) {
				if (copy_fifo(curr->fts_statp, !fts_dne(curr)))
					rval = 1;
			} else
				if (copy_file(curr, fts_dne(curr)))
					rval = 1;
			if (!rval && vflag)
				(void)fprintf(stdout, "%s -> %s\n",
				    curr->fts_path, to.p_path);
			break;
		case S_IFSOCK:
			warnc(EOPNOTSUPP, "%s", curr->fts_path);
			break;
		default:
			if (copy_file(curr, fts_dne(curr)))
				rval = 1;
			else if (vflag)
				(void)fprintf(stdout, "%s -> %s\n",
				    curr->fts_path, to.p_path);
			break;
		}
	}
	if (errno)
		err(1, "fts_read");
	(void)fts_close(ftsp);
	return (rval);
}
@


1.45
log
@add a -v verbose flag to cp, mv, and rm. useful for monitoring progress,
and present on several other systems. some ok, some less ok.
from Job Snijders
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.44 2016/10/14 10:51:57 schwarze Exp $	*/
d433 2
a434 1
				if (copy_special(curr->fts_statp, !fts_dne(curr)))
d462 1
a462 1
					curr->fts_path, to.p_path);
@


1.44
log
@delete useless setlocale(3);
noticed by Jan Stary <hans at stare dot cz>;
return from main while here;
feedback and OK tb@@, OK martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.43 2016/03/07 18:56:33 tb Exp $	*/
d74 1
a74 1
int Rflag, fflag, iflag, pflag, rflag;
d91 1
a91 1
	while ((ch = getopt(argc, argv, "HLPRfipr")) != -1)
d122 3
d400 3
d424 3
d438 3
d449 3
d459 3
@


1.43
log
@Make cp -i behave as mv -i or rm -i, independently of whether stdin
is a tty or not. From Timo Buhrmester.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.42 2015/10/09 01:37:06 deraadt Exp $	*/
d61 1
a61 1
#include <locale.h>
a65 1
#include <limits.h>
a89 2
	(void)setlocale(LC_ALL, "");

d232 1
a232 1
	exit(copy(argv, type, fts_options));
@


1.42
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.41 2015/10/08 04:39:24 deraadt Exp $	*/
d116 1
a116 1
			iflag = isatty(STDIN_FILENO);
@


1.41
log
@Try again.  Both -R and -p prevent use of tame, but other cases can use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.39 2015/10/07 15:44:58 deraadt Exp $	*/
d137 2
a138 2
		if (tame("stdio rpath wpath cpath fattr", NULL) == -1)
			err(1, "tame");
@


1.40
log
@ah, fchflags.  We will come back to this issue later
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.38 2015/05/07 17:32:20 guenther Exp $	*/
d131 8
@


1.39
log
@We cannot tame if -R is specified, because mknod and mkfifo may be called.
But in other cases, we can use tame "stdio rpath wpath cpath fattr", including
for the historical -r option.
@
text
@a131 5
	/* unfortunately, -R will use mkfifo & mknod */
	if (Rflag == 0)
		if (tame("stdio rpath wpath cpath fattr", NULL) == -1)
			err(1, "tame");

@


1.38
log
@Whoops; missed updating a setfile() call.

problem reported dcoppa; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.37 2015/01/16 06:39:31 deraadt Exp $	*/
d131 5
@


1.37
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.36 2014/05/21 06:23:02 guenther Exp $	*/
d363 1
a363 1
				if (pflag && setfile(curr->fts_statp, 0))
@


1.36
log
@Use errc/warnc to simplify code.

ok jca@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.35 2012/08/28 06:02:58 otto Exp $	*/
d51 1
a51 1
#include <sys/param.h>
d66 1
d322 1
a322 1
			if (target_mid - to.p_path + nlen >= MAXPATHLEN) {
@


1.35
log
@Don't order file and dir creation, no measurable effect, ffs
allocation strategy has changed since a long time and added to that
cp(1) should not try to be smart and guess things it shouldn't know.
ok guenther@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.34 2007/11/04 02:01:57 tedu Exp $	*/
d412 2
a413 4
			} else if (!S_ISDIR(to_stat.st_mode)) {
				errno = ENOTDIR;
				err(1, "%s", to.p_path);
			}
d433 1
a433 1
			warnx("%s: %s", curr->fts_path, strerror(EOPNOTSUPP));
@


1.34
log
@some small nonfunctional tweaks.  ok beck millert
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.33 2007/07/26 17:15:46 deraadt Exp $	*/
a79 1
int mastercmp(const FTSENT **, const FTSENT **);
d262 1
a262 1
	if ((ftsp = fts_open(argv, fts_options, mastercmp)) == NULL)
a446 26
}

/*
 * mastercmp --
 *	The comparison function for the copy order.  The order is to copy
 *	non-directory files before directory files.  The reason for this
 *	is because files tend to be in the same cylinder group as their
 *	parent directory, whereas directories tend not to be.  Copying the
 *	files first reduces seeking.
 */
int
mastercmp(const FTSENT **a, const FTSENT **b)
{
	int a_info, b_info;

	a_info = (*a)->fts_info;
	if (a_info == FTS_ERR || a_info == FTS_NS || a_info == FTS_DNR)
		return (0);
	b_info = (*b)->fts_info;
	if (b_info == FTS_ERR || b_info == FTS_NS || b_info == FTS_DNR)
		return (0);
	if (a_info == FTS_D)
		return (-1);
	if (b_info == FTS_D)
		return (1);
	return (0);
@


1.33
log
@STDIN_FILENO is better than fileno(stdin); zinovik@@cs.karelia.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.32 2006/04/25 15:41:07 deraadt Exp $	*/
a35 14
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1988, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)cp.c	8.5 (Berkeley) 4/29/95";
#else
static char rcsid[] = "$OpenBSD: cp.c,v 1.32 2006/04/25 15:41:07 deraadt Exp $";
#endif
#endif /* not lint */

d220 1
a220 1
	} else
d225 1
d227 1
a227 1
	exit (copy(argv, type, fts_options));
a260 1
#ifdef lint
d262 1
a262 1
#endif
@


1.32
log
@various small lint cleanups; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.31 2006/03/17 23:05:32 otto Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.31 2006/03/17 23:05:32 otto Exp $";
d130 1
a130 1
			iflag = isatty(fileno(stdin));
@


1.31
log
@Call fts_close(); from NetBSD's Coverity analysis; ok jaredy@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.30 2005/11/09 20:03:29 otto Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.30 2005/11/09 20:03:29 otto Exp $";
d89 1
a89 1
int myumask;
@


1.30
log
@Handle dir not readable case. Problem noted by chefren. ok hshoexer@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.29 2004/12/13 20:25:34 otto Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.29 2004/12/13 20:25:34 otto Exp $";
d460 1
@


1.29
log
@Only warn if we try to cp(1) a socket. Consequently, this makes
mv(1)ing trees containing sockets across filesystems much more
smooth. ok millert@@ tedu@@ fgsch@@ pedro@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.28 2003/10/30 16:01:43 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.28 2003/10/30 16:01:43 millert Exp $";
d282 1
@


1.28
log
@Fix typo in comment; Bruno Rohee
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.27 2003/07/29 00:24:14 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.27 2003/07/29 00:24:14 deraadt Exp $";
d447 3
@


1.27
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.26 2003/06/02 23:32:06 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.26 2003/06/02 23:32:06 millert Exp $";
d364 1
a364 1
			 * the they will get changed later when the directory
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.25 2003/06/01 23:50:02 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.25 2003/06/01 23:50:02 millert Exp $";
d252 2
a253 3
	        if (!*(p+1)) {
			while ((p >= path) &&
			       *p == '/')
d256 1
a256 2
			while ((p >= path) &&
			       *p != '/')
@


1.25
log
@Undo a misguided attempt to fix speling errors from long ago.  UCB
copyrights say "acknowledgement", not "acknowledgment".  You cannot
just go changing the text of a license willy-nilly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.24 2003/05/02 20:31:42 nino Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.24 2003/05/02 20:31:42 nino Exp $";
@


1.24
log
@Zap unused STRIP_TRAILING_SLASH macro.

Ok millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.22 2003/03/13 09:09:20 deraadt Exp $	*/
d20 1
a20 1
 *    must display the following acknowledgment:
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.22 2003/03/13 09:09:20 deraadt Exp $";
@


1.23
log
@Use the return value of strcpy() to detect ENAMETOOLONG instead of
doing an extra strlen; deraadt@@ OK
@
text
@a86 5
#define	STRIP_TRAILING_SLASH(p) {					\
	while ((p).p_end > (p).p_path + 1 && (p).p_end[-1] == '/')	\
		*--(p).p_end = '\0';					\
}

@


1.22
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.21 2003/01/06 01:52:52 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.21 2003/01/06 01:52:52 millert Exp $";
d189 1
a189 1
	if (strlen(target) >= sizeof(to.p_path))
a190 1
	(void)strlcpy(to.p_path, target, sizeof to.p_path);
@


1.21
log
@Set directory mode/user/times on the post-order pass, not pre-order.
Fixes a problem with "cp -R" (and probably cp -p) with directories
that do not grant the owner write permission.  However, we need to
know whether or not we created the directory ourselves so stash
that fact in fts_pointer (treat it as a boolean) but add a macro
to access it for readability.  This also allows me to remove the
duplicated file times setting code for "cp -p".

Closes PR 3058; deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.20 2002/07/04 04:26:39 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.20 2002/07/04 04:26:39 deraadt Exp $";
d191 1
a191 1
	(void)strcpy(to.p_path, target);
@


1.20
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.19 2002/06/09 05:47:26 todd Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.19 2002/06/09 05:47:26 todd Exp $";
d92 2
d284 1
a284 1
	int base, dne, nlen, rval;
d362 8
a369 1
			dne = 1;
d372 6
a377 4
			 * For -p mode, we need to reset the directory
			 * times in the post-order pass since the times
			 * will have been changed when we added files to
			 * the directory in the pre-order pass.
d380 13
a392 10
				if (pflag && S_ISDIR(to_stat.st_mode)) {
					struct timeval tv[2];

					TIMESPEC_TO_TIMEVAL(&tv[0],
					    &curr->fts_statp->st_atimespec);
					TIMESPEC_TO_TIMEVAL(&tv[1],
					    &curr->fts_statp->st_mtimespec);
					if (utimes(to.p_path, tv))
						warn("utimes: %s", to.p_path);
				}
a410 1
			dne = 0;
d415 1
a415 1
			if (copy_link(curr, !dne))
d434 1
a434 1
			if (dne) {
a441 11
			/*
			 * If not -p and directory didn't exist, set it to be
			 * the same as the from directory, unmodified by the
			 * umask; arguably wrong, but it's been that way
			 * forever.
			 */
			if (pflag && setfile(curr->fts_statp, 0))
				rval = 1;
			else if (dne)
				(void)chmod(to.p_path,
				    curr->fts_statp->st_mode);
d446 1
a446 1
				if (copy_special(curr->fts_statp, !dne))
d449 1
a449 1
				if (copy_file(curr, dne))
d454 1
a454 1
				if (copy_fifo(curr->fts_statp, !dne))
d457 1
a457 1
				if (copy_file(curr, dne))
d461 1
a461 1
			if (copy_file(curr, dne))
@


1.19
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.18 2002/02/16 21:27:06 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.18 2002/02/16 21:27:06 millert Exp $";
d105 1
a105 3
main(argc, argv)
	int argc;
	char *argv[];
d252 1
a252 3
find_last_component(path)
	char *path;

d277 1
a277 4
copy(argv, type, fts_options)
	char *argv[];
	enum op type;
	int fts_options;
d478 1
a478 2
mastercmp(a, b)
	const FTSENT **a, **b;
@


1.18
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.17 2001/06/25 04:35:31 art Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.17 2001/06/25 04:35:31 art Exp $";
d56 1
a56 1
 * 
d60 1
a60 1
 * 
d223 1
a223 1
		if (argc > 1) 
d257 1
a257 1
{ 
d311 2
a312 2
		 * If we are in case (2) or (3) above, we need to append the 
		 * source name to the target name.  
d438 2
a439 2
			 * the same as the from directory, unmodified by the 
			 * umask; arguably wrong, but it's been that way 
@


1.17
log
@explicit braces to avoid ambiguous else
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.16 2001/06/22 22:51:22 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.16 2001/06/22 22:51:22 millert Exp $";
d100 3
a102 3
int copy __P((char *[], enum op, int));
int mastercmp __P((const FTSENT **, const FTSENT **));
char *find_last_component __P((char *));
@


1.16
log
@Avoid printing warnings about things like "is a directory" twice.
Found by fgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.15 2001/06/06 16:06:33 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.15 2001/06/06 16:06:33 millert Exp $";
d334 1
a334 1
			if (curr->fts_level == FTS_ROOTLEVEL)
d344 1
@


1.15
log
@In -p mode, set directory times in post-order pass since otherwise the
times get squashed when we add files to the dir.  Problem found by
Christophe.Deroulers@@ens.fr, fix by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.14 2000/02/20 23:03:55 ericj Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.14 2000/02/20 23:03:55 ericj Exp $";
d363 3
a365 1
		if (stat(to.p_path, &to_stat) == -1)
d367 1
a367 1
		else {
@


1.14
log
@setlocale and get rid of unneeded exit() call. millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.13 1999/05/06 17:19:45 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.13 1999/05/06 17:19:45 millert Exp $";
d304 1
a304 1
		case FTS_DC:			/* Warn, continue. */
a307 2
		case FTS_DP:			/* Ignore, continue. */
			continue;
d366 19
@


1.13
log
@"cp -f" should unlink the destination before copying.  Similar to
a patch from FreeBSD (but this is simpler).  Closes PR #821
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.12 1998/07/03 16:43:56 csapuntz Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.12 1998/07/03 16:43:56 csapuntz Exp $";
d79 1
d114 2
d223 1
a223 1
		if (argc > 1) {
a224 2
			exit(1);
		}
@


1.12
log
@

Fix handling of trailing slashes. Don't ever strip them, because that's
the way the user tells us that he really wants a directory. Also, a
trailing slash does not mean that the last component is null (in fact,
according to POSIX, a component can't be 0 bytes). Rather, the last
component is the one directly preceding the trailing slashes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.11 1997/11/08 23:17:11 todd Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.11 1997/11/08 23:17:11 todd Exp $";
d94 1
a94 1
int Rflag, iflag, pflag, rflag;
d132 1
d137 1
@


1.11
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.10 1997/09/20 17:34:34 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.10 1997/09/20 17:34:34 millert Exp $";
d101 1
a191 1
	STRIP_TRAILING_SLASH(to);
d250 27
d335 3
a337 4
					p = strrchr(curr->fts_path, '/');
					base = (p == NULL) ? 0 :
					    (int)(p - curr->fts_path + 1);

a358 1
			STRIP_TRAILING_SLASH(to);
@


1.10
log
@Don't strip trailing '/' in source, fts(3) now does this for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.9 1997/09/01 18:29:17 deraadt Exp $	*/
d20 1
a20 1
 *    must display the following acknowledgement:
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.9 1997/09/01 18:29:17 deraadt Exp $";
d297 1
a297 1
			 * concatentation for paths ending in "..", e.g.
d390 1
a390 1
			 * the same as the from directory, umodified by the 
@


1.9
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.8 1997/08/23 00:01:38 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.8 1997/08/23 00:01:38 millert Exp $";
d110 1
a110 1
	char *p, **av;
d182 4
a185 4
	p = argv[--argc];
	if (strlen(p) >= sizeof(to.p_path))
		errx(1, "%s: name too long", p);
	(void)strcpy(to.p_path, p);
a195 7

	/* Strip trailing slashes from source files */
	for (av = argv; *av != NULL; av++) {
		p = *av + strlen(*av);
		while (p > *av + 1 && p[-1] == '/')
			*--p = '\0';
	}
@


1.8
log
@Strip trailing slashes from source (we already did dest).
Also, use MAXPATHLEN, not MAXPATHLEN+1
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.7 1997/07/23 14:32:37 kstailey Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.7 1997/07/23 14:32:37 kstailey Exp $";
d113 1
a113 1
	while ((ch = getopt(argc, argv, "HLPRfipr")) != -1) 
d195 1
a195 1
	argv[argc] = NULL;     
d224 1
a224 1
		 */ 
d241 1
a241 1
			
d316 1
a316 1
					base = (p == NULL) ? 0 : 
d319 1
a319 1
					if (!strcmp(&curr->fts_path[base], 
d332 1
a332 1
				warnx("%s%s: name too long (not copied)", 
d388 1
a388 1
				if (mkdir(to.p_path, 
d404 1
a404 1
				(void)chmod(to.p_path, 
d420 1
a420 1
			} else 
@


1.7
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.6 1997/01/15 23:40:20 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.6 1997/01/15 23:40:20 millert Exp $";
d88 1
a88 1
		*--(p).p_end = 0;					\
d110 1
a110 1
	char *target;
d182 4
a185 4
	target = argv[--argc];
	if (strlen(target) > MAXPATHLEN)
		errx(1, "%s: name too long", target);
	(void)strcpy(to.p_path, target);
d189 1
a189 1
		*to.p_end = 0;
d196 8
a203 1
	
d330 2
a331 2
			*target_mid = 0;
			if (target_mid - to.p_path + nlen > MAXPATHLEN) {
d339 1
a339 1
			*to.p_end = 0;
@


1.6
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.5 1996/12/14 12:17:38 mickey Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.5 1996/12/14 12:17:38 mickey Exp $";
d87 2
a88 2
        while ((p).p_end > (p).p_path + 1 && (p).p_end[-1] == '/')	\
                *--(p).p_end = 0;					\
d187 1
a187 1
        if (to.p_path == to.p_end) {
d191 1
a191 1
        STRIP_TRAILING_SLASH(to);
d284 2
a285 2
                 * source name to the target name.  
                 */
d391 2
a392 2
                         * umask; arguably wrong, but it's been that way 
                         * forever.
@


1.5
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.4 1996/10/28 02:55:05 tholo Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.4 1996/10/28 02:55:05 tholo Exp $";
d113 1
a113 1
	while ((ch = getopt(argc, argv, "HLPRfipr")) != EOF) 
@


1.4
log
@Don't strip off the last slash in the pathname "/".  cp used to
stat the pathname "" in order to decide that the pathname "/" is
a directory.  This caused `cp kernel /' to fail if the kernel has
the POSIX behaviour of not allowing the pathname "" to be an alias
for ".".  It presumably also caused `cp /etc/motd /' to fail in
the unlikely event that "." is not stat'able.

Be more careful about concatenating pathnames: don't check that
the pathname fits until prefixes have been discarded (the check
was too strict).  Print the final pathname in error messages.
Terminate the target directory name properly for error messages.
Don't add a slash between components if there is already a slash.

Fix from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.3 1996/08/02 12:40:51 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.3 1996/08/02 12:40:51 deraadt Exp $";
d261 3
a263 1

@


1.3
log
@zap getopt() case of -?, come on, it is the default!
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.2 1996/06/23 14:19:09 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.2 1996/06/23 14:19:09 deraadt Exp $";
d87 1
a87 1
        while ((p).p_end > (p).p_path && (p).p_end[-1] == '/')		\
d260 1
a260 1
	char *p;
a284 8
			if ((curr->fts_namelen +
			    to.target_end - to.p_path + 1) > MAXPATHLEN) {
				warnx("%s/%s: name too long (not copied)", 
				    to.p_path, curr->fts_name);
				rval = 1;
				continue;
			}

a315 4
			if (to.target_end[-1] != '/') {
				*to.target_end = '/';
				*(to.target_end + 1) = 0;
			}
d318 12
a329 3

			(void)strncat(to.target_end + 1, p, nlen);
			to.p_end = to.target_end + nlen + 1;
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: cp.c,v 1.14 1995/09/07 06:14:51 jtc Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cp.c,v 1.14 1995/09/07 06:14:51 jtc Exp $";
a141 1
		case '?':
@


1.1
log
@Initial revision
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: cp.c,v 1.14 1995/09/07 06:14:51 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
