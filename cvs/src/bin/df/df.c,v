head	1.59;
access;
symbols
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.58.0.2
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.52.0.6
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.51.0.4
	OPENBSD_5_6_BASE:1.51
	OPENBSD_5_5:1.50.0.20
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.50.0.16
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.50.0.14
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.50.0.12
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.10
	OPENBSD_5_0:1.50.0.8
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.50.0.6
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.50.0.4
	OPENBSD_4_8_BASE:1.50
	OPENBSD_4_7:1.50.0.2
	OPENBSD_4_7_BASE:1.50
	OPENBSD_4_6:1.49.0.8
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.49.0.4
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.49.0.2
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.46.0.4
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.46.0.2
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.43.0.6
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.43.0.4
	OPENBSD_3_8_BASE:1.43
	OPENBSD_3_7:1.43.0.2
	OPENBSD_3_7_BASE:1.43
	OPENBSD_3_6:1.37.0.6
	OPENBSD_3_6_BASE:1.37
	OPENBSD_3_5:1.37.0.4
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.37.0.2
	OPENBSD_3_4_BASE:1.37
	OPENBSD_3_3:1.33.0.2
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9:1.28.0.2
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_8:1.27.0.2
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.26.0.2
	OPENBSD_2_7_BASE:1.26
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.23.0.2
	OPENBSD_2_5_BASE:1.23
	OPENBSD_2_4:1.22.0.2
	OPENBSD_2_4_BASE:1.22
	OPENBSD_2_3:1.20.0.2
	OPENBSD_2_3_BASE:1.20
	OPENBSD_2_2:1.19.0.2
	OPENBSD_2_2_BASE:1.19
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.59
date	2016.08.14.21.07.40;	author krw;	state Exp;
branches;
next	1.58;
commitid	36reSQ5vkKMyn2EV;

1.58
date	2016.03.14.14.44.03;	author mmcc;	state Exp;
branches;
next	1.57;
commitid	XT996NNT9D5zwfVC;

1.57
date	2016.03.07.01.19.46;	author mmcc;	state Exp;
branches;
next	1.56;
commitid	7bLlcTEjZiCacaHb;

1.56
date	2016.03.01.18.00.42;	author mmcc;	state Exp;
branches;
next	1.55;
commitid	GVj6PM84NO1l9EtM;

1.55
date	2016.02.08.16.23.54;	author mmcc;	state Exp;
branches;
next	1.54;
commitid	iyb7TGlGquuwT1tz;

1.54
date	2015.10.09.01.37.06;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	sbrB3Q5CNxcwZpfU;

1.53
date	2015.10.04.15.54.15;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	vf9SSjvxuYX7hu9P;

1.52
date	2015.01.16.06.39.31;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	Uu5nFG3wCl0LACBb;

1.51
date	2014.05.20.21.11.16;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.27.23.59.21;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2008.03.16.20.04.35;	author otto;	state Exp;
branches;
next	1.48;

1.48
date	2007.12.22.17.37.36;	author chl;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.02.15.19.07;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2006.10.29.19.20.01;	author otto;	state Exp;
branches;
next	1.45;

1.45
date	2006.09.21.20.06.33;	author pedro;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.11.15.06.51;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2005.02.20.01.34.56;	author pedro;	state Exp;
branches;
next	1.42;

1.42
date	2005.01.28.16.44.17;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2004.11.18.16.11.06;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2004.10.15.20.15.47;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2004.09.14.22.51.47;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2004.09.14.22.47.18;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2003.07.29.00.24.15;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.02.21.19.33;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.02.23.32.07;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.26.18.02.32;	author ian;	state Exp;
branches;
next	1.33;

1.33
date	2003.02.19.07.32.03;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2002.07.04.04.26.39;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.16.21.27.06;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.06.13.29.08;	author mpech;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.09.22.37.56;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.23.02.52.37;	author pjanzen;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.18.20.37.42;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.24.19.07.49;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	99.12.31.05.00.04;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	99.05.31.17.34.39;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	99.01.31.18.28.29;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	98.08.18.23.03.32;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	98.08.17.21.33.05;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.11.20.21.19.00;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.09.01.18.29.24;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.08.19.06.44.54;	author denny;	state Exp;
branches;
next	1.17;

1.17
date	97.07.23.14.41.03;	author kstailey;	state Exp;
branches;
next	1.16;

1.16
date	97.06.16.04.37.49;	author denny;	state Exp;
branches;
next	1.15;

1.15
date	97.06.01.07.03.18;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	97.04.14.20.25.37;	author kstailey;	state Exp;
branches;
next	1.13;

1.13
date	97.04.14.17.38.22;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	97.04.14.17.35.58;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	97.04.14.17.34.03;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	97.04.14.17.23.38;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.04.12.16.32.10;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.04.04.18.41.25;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.12.24.20.04.14;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.12.14.12.17.52;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.12.07.09.09.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.02.12.40.53;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.19.51;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.06.21.06.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.06;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.59
log
@Another %qd -> %lld + (long long) for off_t's.
@
text
@/*	$OpenBSD: df.c,v 1.58 2016/03/14 14:44:03 mmcc Exp $	*/
/*	$NetBSD: df.c,v 1.21.2.1 1995/11/01 00:06:11 jtc Exp $	*/

/*
 * Copyright (c) 1980, 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/mount.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

int		 bread(int, off_t, void *, int);
static void	 bsdprint(struct statfs *, long, int);
char		*getmntpt(char *);
static void	 maketypelist(char *);
static void	 posixprint(struct statfs *, long, int);
static void	 prthuman(struct statfs *sfsp, unsigned long long);
static void	 prthumanval(long long);
static void	 prtstat(struct statfs *, int, int, int);
static long	 regetmntinfo(struct statfs **, long);
static int	 selected(const char *);
static __dead void usage(void);

extern int	 e2fs_df(int, char *, struct statfs *);
extern int	 ffs_df(int, char *, struct statfs *);
static int	 raw_df(char *, struct statfs *);

int	hflag, iflag, kflag, lflag, nflag, Pflag;
char	**typelist = NULL;

int
main(int argc, char *argv[])
{
	struct stat stbuf;
	struct statfs *mntbuf;
	long mntsize;
	int ch, i;
	int width, maxwidth;
	char *mntpt;

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "hiklnPt:")) != -1)
		switch (ch) {
		case 'h':
			hflag = 1;
			kflag = 0;
			break;
		case 'i':
			iflag = 1;
			break;
		case 'k':
			kflag = 1;
			hflag = 0;
			break;
		case 'l':
			lflag = 1;
			break;
		case 'n':
			nflag = 1;
			break;
		case 'P':
			Pflag = 1;
			break;
		case 't':
			if (typelist != NULL)
				errx(1, "only one -t option may be specified.");
			maketypelist(optarg);
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if ((iflag || hflag) && Pflag) {
		warnx("-h and -i are incompatible with -P");
		usage();
	}

	mntsize = getmntinfo(&mntbuf, MNT_NOWAIT);
	if (mntsize == 0)
		err(1, "retrieving information on mounted file systems");

	if (!*argv) {
		mntsize = regetmntinfo(&mntbuf, mntsize);
	} else {
		mntbuf = calloc(argc, sizeof(struct statfs));
		if (mntbuf == NULL)
			err(1, NULL);
		mntsize = 0;
		for (; *argv; argv++) {
			if (stat(*argv, &stbuf) < 0) {
				if ((mntpt = getmntpt(*argv)) == 0) {
					warn("%s", *argv);
					continue;
				}
			} else if (S_ISCHR(stbuf.st_mode) || S_ISBLK(stbuf.st_mode)) {
				if (!raw_df(*argv, &mntbuf[mntsize]))
					++mntsize;
				continue;
			} else
				mntpt = *argv;
			/*
			 * Statfs does not take a `wait' flag, so we cannot
			 * implement nflag here.
			 */
			if (!statfs(mntpt, &mntbuf[mntsize]))
				if (lflag && (mntbuf[mntsize].f_flags & MNT_LOCAL) == 0)
					warnx("%s is not a local file system",
					    *argv);
				else if (!selected(mntbuf[mntsize].f_fstypename))
					warnx("%s mounted as a %s file system",
					    *argv, mntbuf[mntsize].f_fstypename);
				else
					++mntsize;
			else
				warn("%s", *argv);
		}
	}

	if (mntsize) {
		maxwidth = 11;
		for (i = 0; i < mntsize; i++) {
			width = strlen(mntbuf[i].f_mntfromname);
			if (width > maxwidth)
				maxwidth = width;
		}

		if (Pflag)
			posixprint(mntbuf, mntsize, maxwidth);
		else
			bsdprint(mntbuf, mntsize, maxwidth);
	}

	return (mntsize ? 0 : 1);
}

char *
getmntpt(char *name)
{
	long mntsize, i;
	struct statfs *mntbuf;

	mntsize = getmntinfo(&mntbuf, MNT_NOWAIT);
	for (i = 0; i < mntsize; i++) {
		if (!strcmp(mntbuf[i].f_mntfromname, name))
			return (mntbuf[i].f_mntonname);
	}
	return (0);
}

static enum { IN_LIST, NOT_IN_LIST } which;

static int
selected(const char *type)
{
	char **av;

	/* If no type specified, it's always selected. */
	if (typelist == NULL)
		return (1);
	for (av = typelist; *av != NULL; ++av)
		if (!strncmp(type, *av, MFSNAMELEN))
			return (which == IN_LIST ? 1 : 0);
	return (which == IN_LIST ? 0 : 1);
}

static void
maketypelist(char *fslist)
{
	int i;
	char *nextcp, **av;

	if ((fslist == NULL) || (fslist[0] == '\0'))
		errx(1, "empty type list");

	/*
	 * XXX
	 * Note: the syntax is "noxxx,yyy" for no xxx's and
	 * no yyy's, not the more intuitive "noyyy,noyyy".
	 */
	if (fslist[0] == 'n' && fslist[1] == 'o') {
		fslist += 2;
		which = NOT_IN_LIST;
	} else
		which = IN_LIST;

	/* Count the number of types. */
	for (i = 1, nextcp = fslist; (nextcp = strchr(nextcp, ',')) != NULL; i++)
		++nextcp;

	/* Build an array of that many types. */
	if ((av = typelist = calloc(i + 1, sizeof(char *))) == NULL)
		err(1, NULL);
	av[0] = fslist;
	for (i = 1, nextcp = fslist; (nextcp = strchr(nextcp, ',')) != NULL; i++) {
		*nextcp = '\0';
		av[i] = ++nextcp;
	}
	/* Terminate the array. */
	av[i] = NULL;
}

/*
 * Make a pass over the filesystem info in ``mntbuf'' filtering out
 * filesystem types not in ``fsmask'' and possibly re-stating to get
 * current (not cached) info.  Returns the new count of valid statfs bufs.
 */
static long
regetmntinfo(struct statfs **mntbufp, long mntsize)
{
	int i, j;
	struct statfs *mntbuf;

	if (!lflag && typelist == NULL)
		return (nflag ? mntsize : getmntinfo(mntbufp, MNT_WAIT));

	mntbuf = *mntbufp;
	j = 0;
	for (i = 0; i < mntsize; i++) {
		if (lflag && (mntbuf[i].f_flags & MNT_LOCAL) == 0)
			continue;
		if (!selected(mntbuf[i].f_fstypename))
			continue;
		if (nflag)
			mntbuf[j] = mntbuf[i];
		else
			(void)statfs(mntbuf[i].f_mntonname, &mntbuf[j]);
		j++;
	}
	return (j);
}

/*
 * "human-readable" output: use 3 digits max.--put unit suffixes at
 * the end.  Makes output compact and easy-to-read esp. on huge disks.
 * Code moved into libutil; this is now just a wrapper.
 */
static void
prthumanval(long long bytes)
{
	char ret[FMT_SCALED_STRSIZE];

	if (fmt_scaled(bytes, ret) == -1) {
		(void)printf(" %lld", bytes);
		return;
	}
	(void)printf(" %7s", ret);
}

static void
prthuman(struct statfs *sfsp, unsigned long long used)
{
	prthumanval(sfsp->f_blocks * sfsp->f_bsize);
	prthumanval(used * sfsp->f_bsize);
	prthumanval(sfsp->f_bavail * sfsp->f_bsize);
}

/*
 * Convert statfs returned filesystem size into BLOCKSIZE units.
 * Attempts to avoid overflow for large filesystems.
 */
#define fsbtoblk(num, fsbs, bs) \
	(((fsbs) != 0 && (fsbs) < (bs)) ? \
		(num) / ((bs) / (fsbs)) : (num) * ((fsbs) / (bs)))

/*
 * Print out status about a filesystem.
 */
static void
prtstat(struct statfs *sfsp, int maxwidth, int headerlen, int blocksize)
{
	u_int64_t used, inodes;
	int64_t availblks;

	(void)printf("%-*.*s", maxwidth, maxwidth, sfsp->f_mntfromname);
	used = sfsp->f_blocks - sfsp->f_bfree;
	availblks = sfsp->f_bavail + used;
	if (hflag)
		prthuman(sfsp, used);
	else
		(void)printf(" %*llu %9llu %9lld", headerlen,
		    fsbtoblk(sfsp->f_blocks, sfsp->f_bsize, blocksize),
		    fsbtoblk(used, sfsp->f_bsize, blocksize),
		    fsbtoblk(sfsp->f_bavail, sfsp->f_bsize, blocksize));
	(void)printf(" %5.0f%%",
	    availblks == 0 ? 100.0 : (double)used / (double)availblks * 100.0);
	if (iflag) {
		inodes = sfsp->f_files;
		used = inodes - sfsp->f_ffree;
		(void)printf(" %7llu %7llu %5.0f%% ", used, sfsp->f_ffree,
		   inodes == 0 ? 100.0 : (double)used / (double)inodes * 100.0);
	} else
		(void)printf("  ");
	(void)printf("  %s\n", sfsp->f_mntonname);
}

/*
 * Print in traditional BSD format.
 */
static void
bsdprint(struct statfs *mntbuf, long mntsize, int maxwidth)
{
	int i;
	char *header;
	int headerlen;
	long blocksize;

	/* Print the header line */
	if (hflag) {
		header = "   Size";
		headerlen = strlen(header);
		(void)printf("%-*.*s %s    Used   Avail Capacity",
			     maxwidth, maxwidth, "Filesystem", header);
	} else {
		if (kflag) {
			blocksize = 1024;
			header = "1K-blocks";
			headerlen = strlen(header);
		} else
			header = getbsize(&headerlen, &blocksize);
		(void)printf("%-*.*s %s      Used     Avail Capacity",
			     maxwidth, maxwidth, "Filesystem", header);
	}
	if (iflag)
		(void)printf(" iused   ifree  %%iused");
	(void)printf("  Mounted on\n");


	for (i = 0; i < mntsize; i++)
		prtstat(&mntbuf[i], maxwidth, headerlen, blocksize);
	return;
}

/*
 * Print in format defined by POSIX 1002.2, invoke with -P option.
 */
static void
posixprint(struct statfs *mntbuf, long mntsize, int maxwidth)
{
	int i;
	int blocksize;
	char *blockstr;
	struct statfs *sfsp;
	long long used, avail;
	double percentused;

	if (kflag) {
		blocksize = 1024;
		blockstr = "1024-blocks";
	} else {
		blocksize = 512;
		blockstr = " 512-blocks";
	}

	(void)printf(
	    "%-*.*s %s       Used   Available Capacity Mounted on\n",
	    maxwidth, maxwidth, "Filesystem", blockstr);

	for (i = 0; i < mntsize; i++) {
		sfsp = &mntbuf[i];
		used = sfsp->f_blocks - sfsp->f_bfree;
		avail = sfsp->f_bavail + used;
		if (avail == 0)
			percentused = 100.0;
		else
			percentused = (double)used / (double)avail * 100.0;

		(void) printf ("%-*.*s %*lld %10lld %11lld %5.0f%%   %s\n",
			maxwidth, maxwidth, sfsp->f_mntfromname,
			(int)strlen(blockstr),
			fsbtoblk(sfsp->f_blocks, sfsp->f_bsize, blocksize),
			fsbtoblk(used, sfsp->f_bsize, blocksize),
			fsbtoblk(sfsp->f_bavail, sfsp->f_bsize, blocksize),
			percentused, sfsp->f_mntonname);
	}
}

static int
raw_df(char *file, struct statfs *sfsp)
{
	int rfd, ret = -1;

	if ((rfd = open(file, O_RDONLY)) < 0) {
		warn("%s", file);
		return (-1);
	}

	if (ffs_df(rfd, file, sfsp) == 0) {
		ret = 0;
	} else if (e2fs_df(rfd, file, sfsp) == 0) {
		ret = 0;
	}

	close (rfd);
	return (ret);
}

int
bread(int rfd, off_t off, void *buf, int cnt)
{
	int nr;

	if ((nr = pread(rfd, buf, cnt, off)) != cnt) {
		/* Probably a dismounted disk if errno == EIO. */
		if (errno != EIO)
			(void)fprintf(stderr, "\ndf: %lld: %s\n",
			    (long long)off, strerror(nr > 0 ? EIO : errno));
		return (0);
	}
	return (1);
}

static __dead void
usage(void)
{
	(void)fprintf(stderr,
	    "usage: %s [-hiklnP] [-t type] [[file | file_system] ...]\n",
	    getprogname());
	exit(1);
}
@


1.58
log
@replace __progname with getprogname(3)

from Michal Mazurek, ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.57 2016/03/07 01:19:46 mmcc Exp $	*/
d447 2
a448 2
			(void)fprintf(stderr, "\ndf: %qd: %s\n",
			    off, strerror(nr > 0 ? EIO : errno));
@


1.57
log
@simplify print formatting logic, replace exit() in main() with return

from Michal Mazurek, ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.56 2016/03/01 18:00:42 mmcc Exp $	*/
a49 2
extern	char *__progname;

d459 1
a459 1
	    __progname);
@


1.56
log
@tidy up function declarations and definitions

from Michal Mazurek, ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.55 2016/02/08 16:23:54 mmcc Exp $	*/
d164 1
a164 1
		maxwidth = 0;
a170 3
		if (maxwidth < 11)
			maxwidth = 11;

d177 1
a177 1
	exit(mntsize ? 0 : 1);
@


1.55
log
@remove needless headers

ok tb@@, from Michal Mazurek
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.54 2015/10/09 01:37:06 deraadt Exp $	*/
d52 15
a66 15
char	*getmntpt(char *);
int	 selected(const char *);
void	 maketypelist(char *);
long	 regetmntinfo(struct statfs **, long);
void	 bsdprint(struct statfs *, long, int);
void	 prtstat(struct statfs *, int, int, int);
void	 posixprint(struct statfs *, long, int);
int 	 bread(int, off_t, void *, int);
void	 usage(void);
void	 prthumanval(long long);
void	 prthuman(struct statfs *sfsp, unsigned long long);

int		raw_df(char *, struct statfs *);
extern int	ffs_df(int, char *, struct statfs *);
extern int	e2fs_df(int, char *, struct statfs *);
d199 1
a199 1
int
d213 1
a213 1
void
d254 1
a254 1
long
d284 1
a284 1
void
d296 1
a296 1
void
d315 1
a315 1
void
d346 1
a346 1
void
d383 1
a383 1
void
d424 1
a424 1
int
d459 1
a459 1
void
@


1.54
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.53 2015/10/04 15:54:15 deraadt Exp $	*/
a43 1
#include <math.h>
@


1.53
log
@df is a tame "stdio rpath" program, the rpath due to getfsstat and statfs.
those two system calls were put into the "rpath" catagory because they
expose pathname information.
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.52 2015/01/16 06:39:31 deraadt Exp $	*/
d82 2
a83 2
	if (tame("stdio rpath", NULL) == -1)
		err(1, "tame");
@


1.52
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.51 2014/05/20 21:11:16 krw Exp $	*/
d81 3
@


1.51
log
@As suggested by guenther@@ and millert@@, replace seek+[read|write] with
p[read|write].  Makes the code much clearer by eliminating extra error
checking and verbiage.

No intentional functional change.

Tweaks by and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.50 2009/10/27 23:59:21 deraadt Exp $	*/
a37 1
#include <sys/param.h>
@


1.50
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.49 2008/03/16 20:04:35 otto Exp $	*/
d448 1
a448 2
	(void)lseek(rfd, off, SEEK_SET);
	if ((nr = read(rfd, buf, cnt)) != cnt) {
@


1.49
log
@actually print the now available large numbers
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.48 2007/12/22 17:37:36 chl Exp $	*/
a36 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1990, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)df.c	8.7 (Berkeley) 4/2/94";
#else
static char rcsid[] = "$OpenBSD: df.c,v 1.48 2007/12/22 17:37:36 chl Exp $";
#endif
#endif /* not lint */
@


1.48
log
@fix df posix mode bug

from otto@@

prompted by otto@@ who is aftk for now
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.47 2007/09/02 15:19:07 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: df.c,v 1.47 2007/09/02 15:19:07 deraadt Exp $";
d78 1
a78 1
void	 prthuman(struct statfs *sfsp, unsigned long);
d310 1
a310 1
prthuman(struct statfs *sfsp, unsigned long used)
d312 3
a314 3
	prthumanval((long long)sfsp->f_blocks * (long long)sfsp->f_bsize);
	prthumanval((long long)used * (long long)sfsp->f_bsize);
	prthumanval((long long)sfsp->f_bavail * (long long)sfsp->f_bsize);
d331 1
a331 1
	u_int32_t used, inodes;
d340 1
a340 1
		(void)printf(" %*u %9u %9d", headerlen,
d349 1
a349 1
		(void)printf(" %7u %7u %5.0f%% ", used, sfsp->f_ffree,
d403 1
a403 1
	long used, avail;
d427 1
a427 1
		(void) printf ("%-*.*s %*d %10ld %11d %5.0f%%   %s\n",
@


1.47
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.46 2006/10/29 19:20:01 otto Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: df.c,v 1.46 2006/10/29 19:20:01 otto Exp $";
d429 1
a429 1
			strlen(blockstr),
@


1.46
log
@like -i, -h is incompatible with -P; suggested by jmc@@; ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.45 2006/09/21 20:06:33 pedro Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: df.c,v 1.45 2006/09/21 20:06:33 pedro Exp $";
d251 1
a251 1
	if ((av = typelist = malloc((i + 1) * sizeof(char *))) == NULL)
@


1.45
log
@Remove LFS-related code, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.44 2006/05/11 15:06:51 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: df.c,v 1.44 2006/05/11 15:06:51 deraadt Exp $";
d130 2
a131 2
	if (iflag && Pflag) {
		warnx("-i is incompatible with -P");
@


1.44
log
@handle malloc failure; jan.niemann@@tu-bs.de
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.43 2005/02/20 01:34:56 pedro Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: df.c,v 1.43 2005/02/20 01:34:56 pedro Exp $";
a81 1
extern int	lfs_df(int, char *, struct statfs *);
a448 4
#if 0
	} else if (lfs_df(rfd, file, sfsp) == 0) {
		ret = 0;
#endif
@


1.43
log
@Better handling of large filesystems, okay henning@@ and millert@@, with
input from martin@@ and miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.42 2005/01/28 16:44:17 mickey Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: df.c,v 1.42 2005/01/28 16:44:17 mickey Exp $";
d144 2
@


1.42
log
@widen the avail/used columns by one space to accomodate for >100g filesystems. the total is already wide enough due to the header length; dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.41 2004/11/18 16:11:06 millert Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: df.c,v 1.41 2004/11/18 16:11:06 millert Exp $";
d78 1
a78 1
void	 prthuman(struct statfs *sfsp, long);
d309 1
a309 1
prthuman(struct statfs *sfsp, long used)
d331 1
a331 1
	int32_t availblks;
@


1.41
log
@Sync usage with man page; Paul de Weerd
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.40 2004/10/15 20:15:47 millert Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: df.c,v 1.40 2004/10/15 20:15:47 millert Exp $";
d305 1
a305 1
	(void)printf(" %6s", ret);
d339 1
a339 1
		(void)printf(" %*u %8u %8d", headerlen,
d368 1
a368 1
		header = "  Size";
d370 1
a370 1
		(void)printf("%-*.*s %s   Used  Avail Capacity",
d379 1
a379 1
		(void)printf("%-*.*s %s     Used    Avail Capacity",
@


1.40
log
@Don't print header if we didn't print any usage lines.  Noticed and
tested by robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.39 2004/09/14 22:51:47 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: df.c,v 1.39 2004/09/14 22:51:47 deraadt Exp $";
d480 1
a480 1
	    "usage: %s [-hiklnP] [-t type] [file | file_system ...]\n",
@


1.39
log
@fd leak (and who said lint never finds real bugs)
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.38 2004/09/14 22:47:18 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: df.c,v 1.38 2004/09/14 22:47:18 deraadt Exp $";
d175 7
a181 6
	maxwidth = 0;
	for (i = 0; i < mntsize; i++) {
		width = strlen(mntbuf[i].f_mntfromname);
		if (width > maxwidth)
			maxwidth = width;
	}
d183 2
a184 2
	if (maxwidth < 11)
		maxwidth = 11;
d186 5
a190 4
	if (Pflag)
		posixprint(mntbuf, mntsize, maxwidth);
	else
		bsdprint(mntbuf, mntsize, maxwidth);
d192 1
a192 1
	exit(0);
@


1.38
log
@remove unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.37 2003/07/29 00:24:15 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: df.c,v 1.37 2003/07/29 00:24:15 deraadt Exp $";
d437 1
a437 1
	int rfd;
d445 1
a445 1
		return (0);
d448 1
a448 1
		return (0);
d451 1
a451 3
		return (0);
	} else {
		return (-1);
d455 1
a455 1

@


1.37
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.36 2003/07/02 21:19:33 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: df.c,v 1.36 2003/07/02 21:19:33 deraadt Exp $";
a396 1
	int blocklen;
a409 1
	blocklen = strlen(blockstr);
d412 2
a413 2
		"%-*.*s %s       Used   Available Capacity Mounted on\n",
		maxwidth, maxwidth, "Filesystem", blockstr);
@


1.36
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.35 2003/06/02 23:32:07 millert Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: df.c,v 1.35 2003/06/02 23:32:07 millert Exp $";
d482 2
a483 2
            "usage: %s [-hiklnP] [-t type] [file | file_system ...]\n",
             __progname);
@


1.35
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.34 2003/05/26 18:02:32 ian Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: df.c,v 1.34 2003/05/26 18:02:32 ian Exp $";
d77 2
@


1.34
log
@Use prt_scaled from libutil. ok pjanzen@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.33 2003/02/19 07:32:03 tedu Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d48 1
a48 1
static char rcsid[] = "$OpenBSD: df.c,v 1.33 2003/02/19 07:32:03 tedu Exp $";
@


1.33
log
@LFS is dead.  saves some space on install floppies too.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.32 2002/07/04 04:26:39 deraadt Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.32 2002/07/04 04:26:39 deraadt Exp $";
d68 1
a71 1
int	 bread(int, off_t, void *, int);
a72 2
void	 bsdprint(struct statfs *, long, int);
void	 posixprint(struct statfs *, long, int);
d76 4
d294 1
d296 2
a297 5

typedef enum { NONE = 0, KILO, MEGA, GIGA, TERA, PETA /* , EXA */ } unit_t;

unit_t
unit_adjust(double *val)
d299 1
a299 2
	double abval;
	unit_t unit;
d301 3
a303 18
	abval = fabs(*val);
	if (abval < 1024)
		unit = NONE;
	else if (abval < 1048576ULL) {
		unit = KILO;
		*val /= 1024;
	} else if (abval < 1073741824ULL) {
		unit = MEGA;
		*val /= 1048576;
	} else if (abval < 1099511627776ULL) {
		unit = GIGA;
		*val /= 1073741824ULL;
	} else if (abval < 1125899906842624ULL) {
		unit = TERA;
		*val /= 1099511627776ULL;
	} else /* if (abval < 1152921504606846976ULL) */ {
		unit = PETA;
		*val /= 1125899906842624ULL;
d305 1
a305 16
	return (unit);
}

void
prthumanval(double bytes)
{
	unit_t unit;

	unit = unit_adjust(&bytes);

	if (bytes == 0)
		(void)printf("     0B");
	else if (bytes > 10)
		(void)printf(" %5.0f%c", bytes, "BKMGTPE"[unit]);
	else
		(void)printf(" %5.1f%c", bytes, "BKMGTPE"[unit]);
d311 3
a313 3
	prthumanval((double)(sfsp->f_blocks) * (double)(sfsp->f_bsize));
	prthumanval((double)(used) * (double)(sfsp->f_bsize));
	prthumanval((double)(sfsp->f_bavail) * (double)(sfsp->f_bsize));
@


1.32
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.31 2002/02/16 21:27:06 millert Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.31 2002/02/16 21:27:06 millert Exp $";
d481 1
d484 1
@


1.31
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.30 2001/09/06 13:29:08 mpech Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.30 2001/09/06 13:29:08 mpech Exp $";
d89 1
a89 3
main(argc, argv)
	int argc;
	char *argv[];
d194 1
a194 2
getmntpt(name)
	char *name;
d210 1
a210 2
selected(type)
	const char *type;
d224 1
a224 2
maketypelist(fslist)
	char *fslist;
d265 1
a265 3
regetmntinfo(mntbufp, mntsize)
	struct statfs **mntbufp;
	long mntsize;
d297 1
a297 2
unit_adjust(val)
	double *val;
d325 1
a325 2
prthumanval(bytes)
	double bytes;
d340 1
a340 3
prthuman(sfsp, used)
	struct statfs *sfsp;
	long used;
d359 1
a359 3
prtstat(sfsp, maxwidth, headerlen, blocksize)
	struct statfs *sfsp;
	int maxwidth, headerlen, blocksize;
d390 1
a390 4
bsdprint(mntbuf, mntsize, maxwidth)
	struct statfs *mntbuf;
	long mntsize;
	int maxwidth;
d427 1
a427 4
posixprint(mntbuf, mntsize, maxwidth)
	struct statfs *mntbuf;
	long mntsize;
	int maxwidth;
d470 1
a470 3
raw_df(file, sfsp)
	char *file;
	struct statfs *sfsp;
d494 1
a494 5
bread(rfd, off, buf, cnt)
	int rfd;
	off_t off;
	void *buf;
	int cnt;
d510 1
a510 1
usage()
@


1.30
log
@o) __progname aria;

millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.29 2001/07/09 22:37:56 millert Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.29 2001/07/09 22:37:56 millert Exp $";
d71 13
a83 13
int	 bread __P((int, off_t, void *, int));
char	*getmntpt __P((char *));
void	 bsdprint __P((struct statfs *, long, int));
void	 posixprint __P((struct statfs *, long, int));
int	 selected __P((const char *));
void	 maketypelist __P((char *));
long	 regetmntinfo __P((struct statfs **, long));
void	 usage __P((void));

int		raw_df __P((char *, struct statfs *));
extern int	ffs_df __P((int, char *, struct statfs *));
extern int	lfs_df __P((int, char *, struct statfs *));
extern int	e2fs_df __P((int, char *, struct statfs *));
@


1.29
log
@Compute %used in -P mode as a double, just like we do in normal printing
mode.  Fixes an int wraparound problem noted by mike@@erdelynet.com
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.28 2001/02/23 02:52:37 pjanzen Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.28 2001/02/23 02:52:37 pjanzen Exp $";
d69 2
d537 3
a539 1
	(void)fprintf(stderr, "usage: df [-hiklnP] [-t type] [file | file_system ...]\n");
@


1.28
log
@Avoid potential uninitialized variable
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.27 2000/10/18 20:37:42 mickey Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.27 2000/10/18 20:37:42 mickey Exp $";
d452 1
a452 1
	int percentused;
d472 1
a472 1
			percentused = 100;
d474 1
a474 2
			percentused = (used * 100 / avail) +
			    ((used % avail) ? 1 : 0);
d476 1
a476 1
		(void) printf ("%-*.*s %*d %10ld %11d %5d%%   %s\n",
a484 1

@


1.27
log
@sort out printf formats according to types, 64bit arithmetics in ffs_df; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.26 2000/03/24 19:07:49 millert Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.26 2000/03/24 19:07:49 millert Exp $";
d323 1
a323 1
	} else if (abval < 1152921504606846976ULL) {
@


1.26
log
@Make f_bsize signed.  Having it unsigned causes surprising (and unwanted)
type coercions.  With this fixed I can back out the hack in df.
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.25 1999/12/31 05:00:04 millert Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.25 1999/12/31 05:00:04 millert Exp $";
d370 1
a370 2
	int maxwidth, headerlen;
	long blocksize;
d390 1
a390 1
		(void)printf(" %7ld %7ld %5.0f%% ", used, sfsp->f_ffree,
d448 1
a448 1
	long blocksize;
d477 1
a477 1
		(void) printf ("%-*.*s %*ld %10ld %11ld %5d%%   %s\n",
@


1.25
log
@In prtstat() use u_int32_t and int32_t, not long and cast
sfsp->f_bsize to be signed when using the fsbtoblk() macro so
we get signed divide, not unsigned divide.  Fixes a bug in df
when the filesystem has < 0 blocks available to the user.
Guess I should have just made f_bsize signed when struct statfs
was changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.24 1999/05/31 17:34:39 millert Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.24 1999/05/31 17:34:39 millert Exp $";
d385 1
a385 1
		    fsbtoblk(sfsp->f_bavail, (int)sfsp->f_bsize, blocksize));
@


1.24
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.23 1999/01/31 18:28:29 millert Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.23 1999/01/31 18:28:29 millert Exp $";
d373 2
a374 1
	long used, availblks, inodes;
d382 1
a382 1
		(void)printf(" %*ld %8ld %8ld", headerlen,
d385 1
a385 1
		    fsbtoblk(sfsp->f_bavail, sfsp->f_bsize, blocksize));
@


1.23
log
@When adjusting units for -h mode, use the absolute value to check for
kb, mega, giga, etc.  Based on a change from kstailey@@openbsd.org but
fixed differently.
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.22 1998/08/18 23:03:32 deraadt Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.22 1998/08/18 23:03:32 deraadt Exp $";
d143 1
a143 1
		mntbuf = malloc(argc * sizeof(struct statfs));
@


1.22
log
@people who fail to update man pages and usage lines will henceforth be shot on sight
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.21 1998/08/17 21:33:05 deraadt Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.21 1998/08/17 21:33:05 deraadt Exp $";
d63 1
d305 1
d308 2
a309 1
	if (*val < 1024)
d311 1
a311 1
	else if (*val < 1048576ULL) {
d314 1
a314 1
	} else if (*val < 1073741824ULL) {
d317 1
a317 1
	} else if (*val < 1099511627776ULL) {
d320 1
a320 1
	} else if (*val < 1125899906842624ULL) {
d323 1
a323 1
	} else if (*val < 1152921504606846976ULL) {
@


1.21
log
@fix df -P on 0-size filesystems
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.20 1997/11/20 21:19:00 millert Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.20 1997/11/20 21:19:00 millert Exp $";
d534 1
a534 1
	(void)fprintf(stderr, "usage: df [-iklnP] [-t type] [file | file_system ...]\n");
@


1.20
log
@Fix units conversion wrt -h flag to be correct (and consistent with
the GNU df's -h flag).
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.19 1997/09/01 18:29:24 deraadt Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.19 1997/09/01 18:29:24 deraadt Exp $";
d468 5
a472 2
		percentused = (used * 100 / avail)
			+ ((used % avail) ? 1 : 0);
@


1.19
log
@i am bored enough to fix terminal space/tab uglies
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.18 1997/08/19 06:44:54 denny Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.18 1997/08/19 06:44:54 denny Exp $";
d308 1
a308 1
	else if (*val < 1024000ULL) {
d311 1
a311 1
	} else if (*val < 1024000000ULL) {
d313 2
a314 2
		*val /= 1024000;
	} else if (*val < 1024000000000ULL) {
d316 2
a317 2
		*val /= 1024000000ULL;
	} else if (*val < 1024000000000000ULL) {
d319 2
a320 2
		*val /= 1024000000000ULL;
	} else if (*val < 1024000000000000000ULL) {
d322 1
a322 1
		*val /= 1024000000000000ULL;
@


1.18
log
@Add -P option, the POSIX 1003.2 output format (strictly specified for parsing).
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.17 1997/07/23 14:41:03 kstailey Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.17 1997/07/23 14:41:03 kstailey Exp $";
d389 1
a389 1
	} else 
@


1.17
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.16 1997/06/16 04:37:49 denny Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.16 1997/06/16 04:37:49 denny Exp $";
d70 2
a71 1
void	 prtstat __P((struct statfs *, int));
d82 1
a82 1
int	hflag, iflag, kflag, lflag, nflag;
a83 1
struct	ufs_args mdev;
d93 2
a94 1
	int ch, i, maxwidth, width;
d97 1
a97 1
	while ((ch = getopt(argc, argv, "hiklnt:")) != -1)
d116 3
d130 5
d180 9
a188 2
	for (i = 0; i < mntsize; i++)
		prtstat(&mntbuf[i], maxwidth);
d365 1
a365 1
prtstat(sfsp, maxwidth)
d367 2
a368 1
	int maxwidth;
a369 3
	static long blocksize;
	static int headerlen, timesthrough;
	static char *header;
a371 22
	if (maxwidth < 11)
		maxwidth = 11;
	if (++timesthrough == 1) {
		if (hflag) {
			header = "  Size";
			headerlen = strlen(header);
			(void)printf("%-*.*s %s   Used  Avail Capacity",
				     maxwidth, maxwidth, "Filesystem", header);
		} else {
			if (kflag) {
				blocksize = 1024;
				header = "1K-blocks";
				headerlen = strlen(header);
			} else
				header = getbsize(&headerlen, &blocksize);
			(void)printf("%-*.*s %s     Used    Avail Capacity",
				     maxwidth, maxwidth, "Filesystem", header);
		}
		if (iflag)
			(void)printf(" iused   ifree  %%iused");
		(void)printf("  Mounted on\n");
	}
d394 88
d531 1
a531 1
	(void)fprintf(stderr, "usage: df [-ikln] [-t type] [file | file_system ...]\n");
@


1.16
log
@Better support for unmounted filesystems (i.e. df /dev/rsd0a):
- interpret the superblock of lfs, ext2fs, and ffs filesystems.
- never mount() an offline filesystem, always read its superblock.
- use the same algorithm as statfs() for ffs, get the same answers.

  Even so, now I'm really unsure this code should remain in df.
  Similar functionality should be added to dumpfs or fsck instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.14 1997/04/14 20:25:37 kstailey Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.14 1997/04/14 20:25:37 kstailey Exp $";
d128 1
a128 1
	        err(1, "retrieving information on mounted file systems");
d152 2
a153 2
			        if (lflag && (mntbuf[mntsize].f_flags & MNT_LOCAL) == 0)
			                warnx("%s is not a local file system",
d155 2
a156 2
			        else if (!selected(mntbuf[mntsize].f_fstypename))
			                warnx("%s mounted as a %s file system",
d158 1
a158 1
			        else
@


1.15
log
@From denny@@c200234-a.frmt1.sfba.home.com, check superblock magic number.

I'm unsure if this code should even remain in df.
@
text
@d68 1
a68 1
int	 bread __P((off_t, void *, int));
a70 1
int	 ufs_df __P((char *, struct statfs *));
d76 5
d141 2
a142 2
			} else if (S_ISCHR(stbuf.st_mode)) {
				if (!ufs_df(*argv, &mntbuf[mntsize]))
a144 24
			} else if (S_ISBLK(stbuf.st_mode)) {
				if ((mntpt = getmntpt(*argv)) == 0) {
					/* XXX can be DOS'd, not very important */
					mntpt = mktemp(strdup("/tmp/df.XXXXXXXXXX"));
					mdev.fspec = *argv;
					if (mkdir(mntpt, DEFFILEMODE) != 0) {
						warn("%s", mntpt);
						continue;
					}
					if (mount(MOUNT_FFS, mntpt, MNT_RDONLY,
					    &mdev) != 0) {
						(void)rmdir(mntpt);
						if (!ufs_df(*argv, &mntbuf[mntsize]))
							++mntsize;
						continue;
					} else if (!statfs(mntpt, &mntbuf[mntsize])) {
						mntbuf[mntsize].f_mntonname[0] = '\0';
						++mntsize;
					} else
						warn("%s", *argv);
					(void)unmount(mntpt, 0);
					(void)rmdir(mntpt);
					continue;
				}
a401 16
/*
 * This code constitutes the pre-system call Berkeley df code for extracting
 * information from filesystem superblocks.
 */
#include <ufs/ffs/fs.h>
#include <errno.h>
#include <fstab.h>

union {
	struct fs iu_fs;
	char dummy[SBSIZE];
} sb;
#define sblock sb.iu_fs

int	rfd;

d403 1
a403 1
ufs_df(file, sfsp)
d407 1
a407 5
	char *mntpt;
	static int synced;

	if (synced++ == 0)
		sync();
d413 8
a420 2
	if (bread((off_t)SBOFF, &sblock, SBSIZE) == 0) {
		(void)close(rfd);
d423 3
a425 26
	if (sblock.fs_magic != FS_MAGIC) {
		(void)close(rfd);
		return (-1);
	}
	sfsp->f_type = 0;
	sfsp->f_flags = 0;
	sfsp->f_bsize = sblock.fs_fsize;
	sfsp->f_iosize = sblock.fs_bsize;
	sfsp->f_blocks = sblock.fs_dsize;
	sfsp->f_bfree = sblock.fs_cstotal.cs_nbfree * sblock.fs_frag +
		sblock.fs_cstotal.cs_nffree;
	sfsp->f_bavail = (sblock.fs_dsize * (100 - sblock.fs_minfree) / 100) -
		(sblock.fs_dsize - sfsp->f_bfree);
	if (sfsp->f_bavail < 0)
		sfsp->f_bavail = 0;
	sfsp->f_files =  sblock.fs_ncg * sblock.fs_ipg;
	sfsp->f_ffree = sblock.fs_cstotal.cs_nifree;
	sfsp->f_fsid.val[0] = 0;
	sfsp->f_fsid.val[1] = 0;
	if ((mntpt = getmntpt(file)) == 0)
		mntpt = "";
	memmove(&sfsp->f_mntonname[0], mntpt, MNAMELEN);
	memmove(&sfsp->f_mntfromname[0], file, MNAMELEN);
	strncpy(sfsp->f_fstypename, MOUNT_FFS, MFSNAMELEN);
	(void)close(rfd);
	return (0);
d429 2
a430 1
bread(off, buf, cnt)
@


1.14
log
@make -h columns more compact
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.13 1997/04/14 17:38:22 kstailey Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.13 1997/04/14 17:38:22 kstailey Exp $";
d454 4
@


1.13
log
@switch from <blank> to "B" for byte suffix; columns look too ugly otherwise
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.12 1997/04/14 17:35:58 kstailey Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.12 1997/04/14 17:35:58 kstailey Exp $";
d340 1
a340 1
		(void)printf("     0B  ");
d342 1
a342 1
		(void)printf(" %5.0f%c  ", bytes, "BKMGTPE"[unit]);
d344 1
a344 1
		(void)printf(" %5.1f%c  ", bytes, "BKMGTPE"[unit]);
d384 12
a395 8
		} else if (kflag) {
			blocksize = 1024;
			header = "1K-blocks";
			headerlen = strlen(header);
		} else
			header = getbsize(&headerlen, &blocksize);
		(void)printf("%-*.*s %s     Used    Avail Capacity",
		    maxwidth, maxwidth, "Filesystem", header);
@


1.12
log
@fix Avail column in -h mode (again)
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.11 1997/04/14 17:34:03 kstailey Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.11 1997/04/14 17:34:03 kstailey Exp $";
d340 1
a340 1
		(void)printf("     0   ");
d342 1
a342 1
		(void)printf(" %5.0f%c  ", bytes, " KMGTPE"[unit]);
d344 1
a344 1
		(void)printf(" %5.1f%c  ", bytes, " KMGTPE"[unit]);
@


1.11
log
@fix Avail column in -h mode
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.10 1997/04/14 17:23:38 kstailey Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.10 1997/04/14 17:23:38 kstailey Exp $";
d340 1
a340 1
		(void)printf("      0   ");
@


1.10
log
@new "-h" (human-readable) output flag now works, please test. thx
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.9 1997/04/12 16:32:10 kstailey Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.9 1997/04/12 16:32:10 kstailey Exp $";
d339 3
a341 1
	if (bytes > 10)
d348 1
a348 1
prthuman(sfsp, used, availblks)
d350 1
a350 1
	long used, availblks;
d354 1
a354 1
	prthumanval((double)(availblks) * (double)(sfsp->f_bsize));
d400 1
a400 1
		prthuman(sfsp, used, availblks);
@


1.9
log
@start of -h (human readable) flag.  more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.8 1997/04/04 18:41:25 deraadt Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.8 1997/04/04 18:41:25 deraadt Exp $";
d297 48
d350 3
a352 1
	
d380 1
a380 2
			blocksize = 1024; /* temp */
			header = "Size";
@


1.8
log
@when mktemp() is hard to fix, use 10 X
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.7 1996/12/24 20:04:14 deraadt Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.7 1996/12/24 20:04:14 deraadt Exp $";
d77 1
a77 1
int	iflag, kflag, lflag, nflag;
d92 1
a92 1
	while ((ch = getopt(argc, argv, "iklnt:")) != -1)
d94 4
d103 1
d297 8
d329 5
a333 1
		if (kflag) {
d348 7
a354 4
	(void)printf(" %*ld %8ld %8ld", headerlen,
	    fsbtoblk(sfsp->f_blocks, sfsp->f_bsize, blocksize),
	    fsbtoblk(used, sfsp->f_bsize, blocksize),
	    fsbtoblk(sfsp->f_bavail, sfsp->f_bsize, blocksize));
@


1.7
log
@indicate this mktemp is vulnerable to a DOS attack, however the impact is very low
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.6 1996/12/14 12:17:52 mickey Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.6 1996/12/14 12:17:52 mickey Exp $";
d139 1
a139 1
					mntpt = mktemp(strdup("/tmp/df.XXXXXX"));
@


1.6
log
@-Wall'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.5 1996/12/07 09:09:06 deraadt Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.5 1996/12/07 09:09:06 deraadt Exp $";
d138 1
@


1.5
log
@handle -t & -l in more cases; netbsd pr#2869, hubert.feyrer@@rz.uni-regensburg.de
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.4 1996/08/02 12:40:53 deraadt Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.4 1996/08/02 12:40:53 deraadt Exp $";
d244 1
a244 1
	for (i = 1, nextcp = fslist; nextcp = strchr(nextcp, ','); i++)
d251 1
a251 1
	for (i = 1, nextcp = fslist; nextcp = strchr(nextcp, ','); i++) {
@


1.4
log
@zap getopt() case of -?, come on, it is the default!
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.3 1996/06/23 14:19:51 deraadt Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.3 1996/06/23 14:19:51 deraadt Exp $";
a116 3
	if (*argv && (lflag || typelist != NULL))
		errx(1, "-l or -t does not make sense with list of mount points");

d166 8
a173 1
				++mntsize;
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: df.c,v 1.21.2.1 1995/11/01 00:06:11 jtc Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: df.c,v 1.21.2.1 1995/11/01 00:06:11 jtc Exp $";
a110 1
		case '?':
@


1.2
log
@complete ufs -> ffs change (From John Kohl; PR #1403)
@
text
@d1 1
d52 1
a52 1
static char rcsid[] = "$NetBSD: df.c,v 1.21.2.1 1995/11/01 00:06:11 jtc Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: df.c,v 1.21 1995/08/11 00:38:15 jtc Exp $	*/
d51 1
a51 1
static char rcsid[] = "$NetBSD: df.c,v 1.21 1995/08/11 00:38:15 jtc Exp $";
d147 1
a147 1
					if (mount(MOUNT_UFS, mntpt, MNT_RDONLY,
d396 1
a396 1
	strncpy(sfsp->f_fstypename, MOUNT_UFS, MFSNAMELEN);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
