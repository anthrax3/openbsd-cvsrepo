head	1.28;
access;
symbols
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.20.0.10
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.4
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.16.0.14
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.10
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.8
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.6
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.16
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.14
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.12
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.10
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.8
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.6
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.4
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.3.0.8
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@# @;


1.28
date	2017.07.15.07.11.42;	author tb;	state Exp;
branches;
next	1.27;
commitid	mSlmgouc5eYP44We;

1.27
date	2016.09.14.18.34.51;	author rpe;	state Exp;
branches;
next	1.26;
commitid	Xv4Tt70HWi4OP4nD;

1.26
date	2016.09.10.12.50.20;	author rpe;	state Exp;
branches;
next	1.25;
commitid	lc5wEX38aIhNRouW;

1.25
date	2016.09.10.09.44.49;	author rpe;	state Exp;
branches;
next	1.24;
commitid	yVUnhf6PGt3a1oJo;

1.24
date	2016.09.10.08.42.06;	author rpe;	state Exp;
branches;
next	1.23;
commitid	uuPEwrjvAmvd78PN;

1.23
date	2016.09.10.08.00.12;	author rpe;	state Exp;
branches;
next	1.22;
commitid	2m6IS5zKNVs0nhPO;

1.22
date	2016.09.09.16.25.37;	author rpe;	state Exp;
branches;
next	1.21;
commitid	1O1ufQrnwwnSNlQM;

1.21
date	2016.09.09.16.11.12;	author rpe;	state Exp;
branches;
next	1.20;
commitid	RmvNoEgZqfgVGp1Q;

1.20
date	2015.02.18.08.39.32;	author rpe;	state Exp;
branches;
next	1.19;
commitid	vSH8wWekQtc0fy5f;

1.19
date	2014.07.11.21.12.39;	author halex;	state Exp;
branches;
next	1.18;
commitid	ovocPoPljDB8rXVq;

1.18
date	2014.07.11.16.41.16;	author halex;	state Exp;
branches;
next	1.17;
commitid	12dV0bzN5dYlHLUg;

1.17
date	2014.07.09.15.41.16;	author halex;	state Exp;
branches;
next	1.16;
commitid	GCLdaM9gKu89MIRt;

1.16
date	2011.07.04.19.52.37;	author halex;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.26.09.04.15;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.07.09.05.24;	author martynas;	state Exp;
branches;
next	1.13;

1.13
date	2008.08.24.15.22.08;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.07.06.08.10;	author david;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.08.22.40.45;	author marc;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.16.15.39.10;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.30.06.44.07;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.19.03.03.33;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.30.18.24.21;	author marc;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.21.17.24.41;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.27.02.36.06;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.11.20.04.11.11;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.03.22.03.39.10;	author marc;	state Exp;
branches;
next	1.2;

1.2
date	96.12.16.03.49.50;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.08.28.04;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Replace some `eval` with $(eval) for consistency and use
parameter expansion instead of basename(1). From Raf Czlonka

ok rpe
@
text
@:
#	$OpenBSD: ksh.kshrc,v 1.27 2016/09/14 18:34:51 rpe Exp $
#
# NAME:
#	ksh.kshrc - global initialization for ksh
#
# DESCRIPTION:
#	Each invocation of /bin/ksh processes the file pointed
#	to by $ENV (usually $HOME/.kshrc).
#	This file is intended as a global .kshrc file for the
#	Korn shell.  A user's $HOME/.kshrc file simply requires
#	the line:
#		. /etc/ksh.kshrc
#	at or near the start to pick up the defaults in this
#	file which can then be overridden as desired.
#
# SEE ALSO:
#	$HOME/.kshrc
#

# RCSid:
#	$From: ksh.kshrc,v 1.4 1992/12/05 13:14:48 sjg Exp $
#
#	@@(#)Copyright (c) 1991 Simon J. Gerraty
#
#	This file is provided in the hope that it will
#	be of use.  There is absolutely NO WARRANTY.
#	Permission to copy, redistribute or otherwise
#	use this file is hereby granted provided that
#	the above copyright notice and this notice are
#	left intact.

case "$-" in
*i*)	# we are interactive
	# we may have su'ed so reset these
	USER=$(id -un)
	UID=$(id -u)
	case $UID in
	0) PS1S='# ';;
	esac
	PS1S=${PS1S:-'$ '}
	HOSTNAME=${HOSTNAME:-$(uname -n)}
	HOST=${HOSTNAME%%.*}

	PROMPT="$USER:!$PS1S"
	#PROMPT="<$USER@@$HOST:!>$PS1S"
	PPROMPT='$USER:$PWD:!'"$PS1S"
	#PPROMPT='<$USER@@$HOST:$PWD:!>'"$PS1S"
	PS1=$PPROMPT
	# $TTY is the tty we logged in on,
	# $tty is that which we are in now (might by pty)
	tty=$(tty)
	tty=${tty##*/}
	TTY=${TTY:-$tty}
	# $console is the system console device
	console=$(sysctl kern.consdev)
	console=${console#*=}

	set -o emacs

	alias ls='ls -CF'
	alias h='fc -l | more'

	case "$TERM" in
	sun*-s)
		# sun console with status line
		if [[ $tty != $console ]]; then
			# ilabel
			ILS='\033]L'; ILE='\033\\'
			# window title bar
			WLS='\033]l'; WLE='\033\\'
		fi
		;;
	xterm*)
		ILS='\033]1;'; ILE='\007'
		WLS='\033]2;'; WLE='\007'
		if ps -p $PPID -o command | grep -q telnet; then
			export TERM=xterms
		fi
		;;
	*)	;;
	esac
	# do we want window decorations?
	if [[ -n $ILS ]]; then
		function ilabel { print -n "${ILS}$*${ILE}">/dev/tty; }
		function label { print -n "${WLS}$*${WLE}">/dev/tty; }

		alias stripe='label "$USER@@$HOST ($tty) - $PWD"'
		alias istripe='ilabel "$USER@@$HOST ($tty)"'

		# Run stuff through this to preserve the exit code
		function _ignore { local rc=$?; "$@@"; return $rc; }

		function wftp { ilabel "ftp $*"; "ftp" "$@@"; _ignore eval istripe; }

		function wcd     { \cd "$@@";     _ignore eval stripe; }

		function wssh    { \ssh "$@@";    _ignore eval 'istripe; stripe'; }
		function wtelnet { \telnet "$@@"; _ignore eval 'istripe; stripe'; }
		function wsu     { \su "$@@";     _ignore eval 'istripe; stripe'; }

		alias su=wsu
		alias cd=wcd
		alias ftp=wftp
		alias ssh=wssh
		alias telnet=wtelnet
		eval stripe
		eval istripe
		PS1=$PROMPT
	fi
	alias quit=exit
	alias cls=clear
	alias logout=exit
	alias bye=exit
	alias p='ps -l'
	alias j=jobs
	alias o='fg %-'
	alias df='df -k'
	alias du='du -k'
	alias rsize='eval $(resize)'
;;
*)	# non-interactive
;;
esac
# commands for both interactive and non-interactive shells

# is $1 missing from $2 (or PATH) ?
function no_path {
	eval _v="\$${2:-PATH}"
	case :$_v: in
	*:$1:*) return 1;;		# no we have it
	esac
	return 0
}
# if $1 exists and is not in path, append it
function add_path {
	[[ -d ${1:-.} ]] && no_path $* && eval ${2:-PATH}="\$${2:-PATH}:$1"
}
# if $1 exists and is not in path, prepend it
function pre_path {
	[[ -d ${1:-.} ]] && no_path $* && eval ${2:-PATH}="$1:\$${2:-PATH}"
}
# if $1 is in path, remove it
function del_path {
	no_path $* || eval ${2:-PATH}=$(eval echo :'$'${2:-PATH}: |
		sed -e "s;:$1:;:;g" -e "s;^:;;" -e "s;:\$;;")
}
@


1.27
log
@Do the same with less code.

OK halex
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.26 2016/09/10 12:50:20 rpe Exp $
d42 1
a42 1
	HOSTNAME=${HOSTNAME:-`uname -n`}
d52 2
a53 2
	tty=`tty`
	tty=`basename $tty`
d120 1
a120 1
	alias rsize='eval `resize`'
d145 2
a146 2
	no_path $* || eval ${2:-PATH}=`eval echo :'$'${2:-PATH}: |
		sed -e "s;:$1:;:;g" -e "s;^:;;" -e "s;:\$;;"`
@


1.26
log
@Unbreak ksh.kshrc by using a MI way of finding out the console device name.

Found by landry
OK deraadt
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.25 2016/09/10 09:44:49 rpe Exp $
d77 3
a79 5
		parent="`ps -ax 2>/dev/null | grep $PPID | grep -v grep`"
		case "$parent" in
		*telnet*)
		export TERM=xterms;;
		esac
@


1.25
log
@Simplify setting the USER and UID variables.
While here, convert `` to $().

OK halex
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.24 2016/09/10 08:42:06 rpe Exp $
d56 1
a56 1
	console=$(sysctl machdep.console_device)
@


1.24
log
@Remove remnants of rlogin, it's long gone (2002).

OK halex
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.23 2016/09/10 08:00:12 rpe Exp $
d36 2
a37 3
	USER=`whoami 2>/dev/null`
	USER=${USER:-`id | sed 's/^[^(]*(\([^)]*\)).*/\1/'`}
	UID=`id -u`
@


1.23
log
@Identation

OK halex, krw
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.22 2016/09/09 16:25:37 rpe Exp $
a102 1
		function wrlogin { \rlogin "$@@"; _ignore eval 'istripe; stripe'; }
a109 1
		alias rlogin=wrlogin
@


1.22
log
@Convert [] to ksh style [[]] tests.
Based on a diff from Anthony Coulter.

OK krw, halex
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.21 2016/09/09 16:11:12 rpe Exp $
d134 5
a138 5
  eval _v="\$${2:-PATH}"
  case :$_v: in
  *:$1:*) return 1;;		# no we have it
  esac
  return 0
d142 1
a142 1
  [[ -d ${1:-.} ]] && no_path $* && eval ${2:-PATH}="\$${2:-PATH}:$1"
d146 1
a146 1
  [[ -d ${1:-.} ]] && no_path $* && eval ${2:-PATH}="$1:\$${2:-PATH}"
d150 2
a151 2
  no_path $* || eval ${2:-PATH}=`eval echo :'$'${2:-PATH}: |
    sed -e "s;:$1:;:;g" -e "s;^:;;" -e "s;:\$;;"`
@


1.21
log
@Resurrect the detection of the console device that got lost a long time ago.

OK tb
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.20 2015/02/18 08:39:32 rpe Exp $
d68 1
a68 1
		if [ "$tty" != "$console" ]; then
d87 1
a87 1
	if [ "$ILS" ]; then
d142 1
a142 1
  [ -d ${1:-.} ] && no_path $* && eval ${2:-PATH}="\$${2:-PATH}:$1"
d146 1
a146 1
  [ -d ${1:-.} ] && no_path $* && eval ${2:-PATH}="$1:\$${2:-PATH}"
@


1.20
log
@Remove old cruft, that make no sense at all on OpenBSD.
- comments relevant to other brands of UNIX
- the no-op KSH_VERSION case-block, we only have pdksh
- the case-block for setting aliases based on UNIX brand
  together with a comment that falsely encourages to modify this
  file instead of putting stuff in $HOME/.kshrc

OK krw@@ halex@@
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.19 2014/07/11 21:12:39 halex Exp $
d56 3
@


1.19
log
@Introducing a nifty _ignore function makes the file neater and easier
to maintain. The eval's must stay to make the aliases expand at run
time instead of at parse time.

ok krw@@
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.18 2014/07/11 16:41:16 halex Exp $
a35 2
	# NOTE: SCO-UNIX doesn't have whoami,
	#	install whoami.sh
d61 1
a61 9
	# the PD ksh is not 100% compatible
	case "$KSH_VERSION" in
	*PD*)	# PD ksh
		;;
	*)	# real ksh ?
		[ -r $HOME/.functions ] && . $HOME/.functions
		set -o trackall
		;;
	esac
d120 2
a121 12

# add your favourite aliases here
	OS=${OS:-`uname -s`}
	case $OS in
	HP-UX)
		alias ls='ls -CF'
		;;
	*BSD)
		alias df='df -k'
		alias du='du -k'
		;;
	esac
@


1.18
log
@revert last commit

eval seems to be needed for reaching the aliases which otherwise aren't
available from within functions...
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.16 2011/07/04 19:52:37 halex Exp $
d101 12
a112 38
		function wftp { ilabel "ftp $*"; "ftp" "$@@"; eval istripe; }
		function wcd { \cd "$@@" && eval stripe; }
		function wssh
		{
			local rc
			"ssh" "$@@"
			rc=$?
			eval istripe
			eval stripe
			return $rc
		}
		function wtelnet
		{
			local rc
			"telnet" "$@@"
			rc=$?
			eval istripe
			eval stripe
			return $rc
		}
		function wrlogin
		{
			local rc
			"rlogin" "$@@"
			rc=$?
			eval istripe
			eval stripe
			return $rc
		}
		function wsu
		{
			local rc
			"su" "$@@"
			rc=$?
			eval istripe
			eval stripe
			return $rc
		}
@


1.17
log
@I hate eval. Apart from when it's really needed.
Eval'ing constant expressions is not such a case.

"...fine with me" krw@@
@
text
@d101 2
a102 2
		function wftp { ilabel "ftp $*"; "ftp" "$@@"; istripe; }
		function wcd { \cd "$@@" && stripe; }
d108 2
a109 2
			istripe
			stripe
d117 2
a118 2
			istripe
			stripe
d126 2
a127 2
			istripe
			stripe
d135 2
a136 2
			istripe
			stripe
d145 2
a146 2
		stripe
		istripe
@


1.16
log
@use "function X" rather than "X ()" since for the former, preceding parameter
assignments function calls are not surprisingly polluting your shell environment

"makes sense" krw@@, ok tedu@@ guenther@@
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.15 2010/04/26 09:04:15 otto Exp $
d101 2
a102 2
		function wftp { ilabel "ftp $*"; "ftp" "$@@"; eval istripe; }
		function wcd { \cd "$@@" && eval stripe; }
d108 2
a109 2
			eval istripe
			eval stripe
d117 2
a118 2
			eval istripe
			eval stripe
d126 2
a127 2
			eval istripe
			eval stripe
d135 2
a136 2
			eval istripe
			eval stripe
d145 2
a146 2
		eval stripe
		eval istripe
@


1.15
log
@don't throw away exit status of various commands; ok sthen@@ dcoppa@@ halex@@
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.14 2009/08/07 09:05:24 martynas Exp $
d95 2
a96 2
		ilabel () { print -n "${ILS}$*${ILE}">/dev/tty; }
		label () { print -n "${WLS}$*${WLE}">/dev/tty; }
d101 3
a103 3
		wftp () { ilabel "ftp $*"; "ftp" "$@@"; eval istripe; }
		wcd () { \cd "$@@" && eval stripe; }
		wssh ()
d112 1
a112 1
		wtelnet ()
d121 1
a121 1
		wrlogin ()
d130 1
a130 1
		wsu ()
d176 1
a176 1
no_path () {
d184 1
a184 1
add_path () {
d188 1
a188 1
pre_path () {
d192 1
a192 1
del_path () {
@


1.14
log
@fix ksh ftp wrapper so argvs aren't split before passing;  making
urls with spaces work.  ok sthen@@
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.13 2008/08/24 15:22:08 jmc Exp $
d105 1
d107 1
d110 1
d114 1
d116 1
d119 1
d123 1
d125 1
d128 1
d132 1
d134 1
d137 1
@


1.13
log
@remove the ls=ls -gCF alias: we already have an alias for ls (-CF),
and now that the behaviour of -g has changed to be more in line
with posix, we get group ID by default anyway;

kick started by PR 5784 from Jacek Masiulaniec;
discussed with otto and sobrado;
ok deraadt millert
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.12 2005/02/07 06:08:10 david Exp $
d101 1
a101 1
		wftp () { ilabel "ftp $*"; "ftp" $*; eval istripe; }
@


1.12
log
@indentation whitespace nits
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.11 2002/12/08 22:40:45 marc Exp $
a143 1
	alias ls='ls -gCF'
@


1.11
log
@
Remove special case code for sun/xterm that faked a DISPLAY and
set the erase character to something other than probably desired.
'I don't object' millert@@
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.10 2002/10/16 15:39:10 todd Exp $
d39 1
a39 1
        USER=${USER:-`id | sed 's/^[^(]*(\([^)]*\)).*/\1/'`}
d44 1
a44 1
        PS1S=${PS1S:-'$ '}
d57 1
a57 1
        TTY=${TTY:-$tty}
d85 2
a86 2
                parent="`ps -ax 2>/dev/null | grep $PPID | grep -v grep`"
                case "$parent" in
d88 1
a88 1
                  export TERM=xterms;;
d151 1
a151 1
                ;;
@


1.10
log
@when using this file, label and ilabel set the term 'title' and icon labels.
they do this by sending to stdout. commands like: 'ftp -o - ftp://blah/foo>foo'
do not like having data added to the output stream.
since we only define these two functions in an environment where /dev/tty
exists, send output to /dev/tty to make sure it does not corrupt the output
stream of commands.
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.9 2002/05/30 06:44:07 deraadt Exp $
a157 24

	case "$TERM" in
	sun*|xterm*)
		case $tty in
		tty[p-w]*)
			case "$DISPLAY" in
			"")
				DISPLAY="`who | grep $TTY | sed -n 's/.*(\([^:)]*\)[:)].*/\1/p' | sed 's/\([a-zA-Z][^.]*\).*/\1/'`:0"
				;;
			esac
			;;
		esac
		case "$DISPLAY" in
		ozen*|:*)
			stty erase "^?"
			;;
		*)
			stty erase "^h"
			;;
		esac
		export DISPLAY
		;;
	esac

@


1.9
log
@space nits
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.8 2001/11/19 03:03:33 deraadt Exp $
d95 2
a96 2
		ilabel () { print -n "${ILS}$*${ILE}"; }
		label () { print -n "${WLS}$*${WLE}"; }
@


1.8
log
@zap trailing spaces and tabs
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.7 2001/04/30 18:24:21 marc Exp $
d150 1
a150 1
        	alias ls='ls -CF'
@


1.7
log
@fix function wcd so "cd x && y" returns an appropriate error when x does not exist
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.6 2000/09/21 17:24:41 todd Exp $
d5 1
a5 1
#	ksh.kshrc - global initialization for ksh 
d29 1
a29 1
#	use this file is hereby granted provided that 
d31 1
a31 1
#	left intact. 
d58 1
a58 1
 
d156 1
a156 1
	esac	
d162 1
a162 1
		tty[p-w]*)		
d206 1
a206 1
  no_path $* || eval ${2:-PATH}=`eval echo :'$'${2:-PATH}: | 
@


1.6
log
@add ssh to the list of apps to 'cleanup titles afterwards' when used with an
xterm or equivalent
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.5 2000/01/27 02:36:06 millert Exp $
d102 1
a102 1
		wcd () { \cd "$@@"; eval stripe; }
@


1.5
log
@Don't bind arrow keys in pdksh, the binding are already there by default.
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.4 1999/11/20 04:11:11 millert Exp $
d103 6
d130 1
@


1.4
log
@Fix cd/wcd aliases.  Closes PR #981
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.3 1998/03/22 03:39:10 marc Exp $
a65 10
		case "$TERM" in
		pc3|pcvt*|xterm*)
			# bind arrow keys
			bind '^[['=prefix-2
			bind '^XA'=up-history
			bind '^XB'=down-history
			bind '^XC'=forward-char
			bind '^XD'=backward-char
			;;
		esac
@


1.3
log
@fix ksh.kshrc; check ksh.kshrc, .kshrc for owner/mode/path
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.2 1996/12/16 03:49:50 kstailey Exp $
a62 1
	_cd() { "cd" $*; }
d112 1
a112 1
		wcd () { _cd $*; eval stripe; }
@


1.2
log
@changed not to hardcode sun console name as "console"
@
text
@d2 1
a2 1
#	$OpenBSD: ksh.kshrc,v 1.1 1996/08/14 08:28:04 downsj Exp $
d40 1
a57 2
	# console is the system console device
	console=`sysctl machdep.console_device | cut -d' ' -f3`
d84 2
a85 2
	sun*)
		# these are not as neat as their csh equivalents
@


1.1
log
@Add /etc/ksh.kshrc.
@
text
@d2 1
a2 1
#	$OpenBSD$
d57 3
a59 1
        
d87 1
a87 1
		if [ "$tty" != console ]; then
@
