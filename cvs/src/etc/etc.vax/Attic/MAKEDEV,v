head	1.136;
access;
symbols
	OPENBSD_5_9:1.135.0.2
	OPENBSD_5_9_BASE:1.135
	OPENBSD_5_8:1.132.0.6
	OPENBSD_5_8_BASE:1.132
	OPENBSD_5_7:1.132.0.2
	OPENBSD_5_7_BASE:1.132
	OPENBSD_5_6:1.131.0.4
	OPENBSD_5_6_BASE:1.131
	OPENBSD_5_5:1.130.0.4
	OPENBSD_5_5_BASE:1.130
	OPENBSD_5_4:1.127.0.2
	OPENBSD_5_4_BASE:1.127
	OPENBSD_5_3:1.124.0.2
	OPENBSD_5_3_BASE:1.124
	OPENBSD_5_2:1.121.0.2
	OPENBSD_5_2_BASE:1.121
	OPENBSD_5_1_BASE:1.120
	OPENBSD_5_1:1.120.0.2
	OPENBSD_5_0:1.117.0.2
	OPENBSD_5_0_BASE:1.117
	OPENBSD_4_9:1.114.0.2
	OPENBSD_4_9_BASE:1.114
	OPENBSD_4_8:1.112.0.2
	OPENBSD_4_8_BASE:1.112
	OPENBSD_4_7:1.106.0.2
	OPENBSD_4_7_BASE:1.106
	OPENBSD_4_6:1.104.0.4
	OPENBSD_4_6_BASE:1.104
	OPENBSD_4_5:1.102.0.2
	OPENBSD_4_5_BASE:1.102
	OPENBSD_4_4:1.99.0.2
	OPENBSD_4_4_BASE:1.99
	OPENBSD_4_3:1.97.0.4
	OPENBSD_4_3_BASE:1.97
	OPENBSD_4_2:1.97.0.2
	OPENBSD_4_2_BASE:1.97
	OPENBSD_4_1:1.91.0.2
	OPENBSD_4_1_BASE:1.91
	OPENBSD_4_0:1.88.0.2
	OPENBSD_4_0_BASE:1.88
	OPENBSD_3_9:1.82.0.2
	OPENBSD_3_9_BASE:1.82
	OPENBSD_3_8:1.77.0.2
	OPENBSD_3_8_BASE:1.77
	OPENBSD_3_7:1.75.0.2
	OPENBSD_3_7_BASE:1.75
	OPENBSD_3_6:1.70.0.2
	OPENBSD_3_6_BASE:1.70
	OPENBSD_3_5:1.62.0.2
	OPENBSD_3_5_BASE:1.62
	OPENBSD_3_4:1.51.0.2
	OPENBSD_3_4_BASE:1.51
	OPENBSD_3_3:1.50.0.2
	OPENBSD_3_3_BASE:1.50
	OPENBSD_3_2:1.48.0.2
	OPENBSD_3_2_BASE:1.48
	OPENBSD_3_1:1.45.0.2
	OPENBSD_3_1_BASE:1.45
	OPENBSD_3_0:1.32.0.2
	OPENBSD_3_0_BASE:1.32
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_8:1.19.0.4
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	OPENBSD_2_6:1.17.0.4
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.136
date	2016.03.09.16.28.46;	author deraadt;	state dead;
branches;
next	1.135;
commitid	OSDG2O3Cgeifnf1W;

1.135
date	2015.11.10.21.50.02;	author sthen;	state Exp;
branches;
next	1.134;
commitid	cbpQoyIQoLnKxXlo;

1.134
date	2015.11.10.21.44.03;	author sthen;	state Exp;
branches;
next	1.133;
commitid	xjeR06qiavDtFv9k;

1.133
date	2015.10.23.15.14.47;	author claudio;	state Exp;
branches;
next	1.132;
commitid	D8oDiiCrSjVktjLG;

1.132
date	2014.10.09.04.38.02;	author tedu;	state Exp;
branches;
next	1.131;
commitid	M66ALjcyb37tQVMc;

1.131
date	2014.07.11.22.04.52;	author tedu;	state Exp;
branches;
next	1.130;
commitid	xQhhmJP574n3YeP9;

1.130
date	2014.01.05.01.27.59;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2013.11.21.11.06.09;	author kettenis;	state Exp;
branches;
next	1.128;

1.128
date	2013.11.05.16.06.29;	author deraadt;	state Exp;
branches;
next	1.127;

1.127
date	2013.06.21.21.34.33;	author syl;	state Exp;
branches;
next	1.126;

1.126
date	2013.06.15.23.21.02;	author halex;	state Exp;
branches;
next	1.125;

1.125
date	2013.06.03.16.39.41;	author tedu;	state Exp;
branches;
next	1.124;

1.124
date	2013.01.30.02.02.02;	author yasuoka;	state Exp;
branches;
next	1.123;

1.123
date	2012.11.26.08.08.00;	author jasper;	state Exp;
branches;
next	1.122;

1.122
date	2012.08.23.06.17.00;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2012.04.06.15.32.57;	author jsing;	state Exp;
branches;
next	1.120;

1.120
date	2011.10.22.19.31.41;	author miod;	state Exp;
branches;
next	1.119;

1.119
date	2011.10.06.20.50.54;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2011.09.03.20.46.05;	author miod;	state Exp;
branches;
next	1.117;

1.117
date	2011.07.06.18.34.33;	author miod;	state Exp;
branches;
next	1.116;

1.116
date	2011.06.26.23.42.28;	author tedu;	state Exp;
branches;
next	1.115;

1.115
date	2011.04.18.16.52.11;	author thib;	state Exp;
branches;
next	1.114;

1.114
date	2010.09.30.15.29.23;	author claudio;	state Exp;
branches;
next	1.113;

1.113
date	2010.09.04.12.18.42;	author miod;	state Exp;
branches;
next	1.112;

1.112
date	2010.08.03.20.16.23;	author miod;	state Exp;
branches;
next	1.111;

1.111
date	2010.07.22.00.59.56;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2010.07.03.04.08.11;	author krw;	state Exp;
branches;
next	1.109;

1.109
date	2010.06.27.00.00.51;	author jsing;	state Exp;
branches;
next	1.108;

1.108
date	2010.06.14.14.08.45;	author todd;	state Exp;
branches;
next	1.107;

1.107
date	2010.06.09.16.11.42;	author todd;	state Exp;
branches;
next	1.106;

1.106
date	2009.09.23.15.40.18;	author miod;	state Exp;
branches;
next	1.105;

1.105
date	2009.08.13.15.13.09;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2009.06.03.15.36.55;	author todd;	state Exp;
branches;
next	1.103;

1.103
date	2009.06.03.14.45.40;	author jj;	state Exp;
branches;
next	1.102;

1.102
date	2009.01.25.17.31.11;	author miod;	state Exp;
branches;
next	1.101;

1.101
date	2008.10.10.20.16.10;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2008.09.24.17.38.31;	author todd;	state Exp;
branches;
next	1.99;

1.99
date	2008.06.13.21.09.11;	author todd;	state Exp;
branches;
next	1.98;

1.98
date	2008.06.12.18.55.05;	author todd;	state Exp;
branches;
next	1.97;

1.97
date	2007.08.02.16.42.19;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2007.05.28.22.29.57;	author todd;	state Exp;
branches;
next	1.95;

1.95
date	2007.05.27.02.00.20;	author todd;	state Exp;
branches;
next	1.94;

1.94
date	2007.05.26.20.19.33;	author todd;	state Exp;
branches;
next	1.93;

1.93
date	2007.05.18.14.07.16;	author jmc;	state Exp;
branches;
next	1.92;

1.92
date	2007.04.04.17.23.27;	author todd;	state Exp;
branches;
next	1.91;

1.91
date	2007.03.07.02.58.41;	author krw;	state Exp;
branches;
next	1.90;

1.90
date	2007.02.16.02.16.34;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2006.12.15.21.03.56;	author kettenis;	state Exp;
branches;
next	1.88;

1.88
date	2006.08.28.21.23.34;	author tsi;	state Exp;
branches;
next	1.87;

1.87
date	2006.08.27.17.34.48;	author miod;	state Exp;
branches;
next	1.86;

1.86
date	2006.08.24.20.22.02;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2006.08.02.19.09.10;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2006.07.30.12.33.09;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2006.07.24.22.59.54;	author miod;	state Exp;
branches;
next	1.82;

1.82
date	2005.12.27.19.03.10;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2005.10.06.06.44.00;	author otto;	state Exp;
branches;
next	1.80;

1.80
date	2005.10.04.18.34.30;	author otto;	state Exp;
branches;
next	1.79;

1.79
date	2005.10.04.18.12.00;	author otto;	state Exp;
branches;
next	1.78;

1.78
date	2005.10.04.07.40.35;	author otto;	state Exp;
branches;
next	1.77;

1.77
date	2005.08.01.22.22.38;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2005.06.02.20.14.00;	author tholo;	state Exp;
branches;
next	1.75;

1.75
date	2005.03.01.13.37.10;	author otto;	state Exp;
branches;
next	1.74;

1.74
date	2005.02.07.08.23.42;	author david;	state Exp;
branches;
next	1.73;

1.73
date	2005.02.07.06.24.45;	author david;	state Exp;
branches;
next	1.72;

1.72
date	2005.01.28.18.59.43;	author danh;	state Exp;
branches;
next	1.71;

1.71
date	2005.01.10.07.58.01;	author dlg;	state Exp;
branches;
next	1.70;

1.70
date	2004.08.20.00.18.42;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2004.08.20.00.17.31;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2004.08.19.07.05.50;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2004.06.03.18.40.17;	author grange;	state Exp;
branches;
next	1.66;

1.66
date	2004.05.30.08.24.12;	author grange;	state Exp;
branches;
next	1.65;

1.65
date	2004.05.29.04.08.53;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2004.04.11.18.15.24;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2004.04.11.18.06.04;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2004.03.12.04.54.33;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2004.02.20.19.13.49;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2004.02.17.11.19.21;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2004.02.16.19.05.06;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2004.02.14.17.24.59;	author todd;	state Exp;
branches;
next	1.57;

1.57
date	2004.02.13.23.35.04;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2004.02.10.02.46.22;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2004.02.10.01.31.20;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2004.02.05.22.23.31;	author todd;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.12.23.58.18;	author todd;	state Exp;
branches;
next	1.52;

1.52
date	2003.10.11.03.32.15;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2003.04.15.20.10.46;	author jmc;	state Exp;
branches;
next	1.50;

1.50
date	2003.01.06.05.57.40;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2002.12.05.03.00.27;	author kjc;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.24.10.43.31;	author hugh;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.09.05.58.39;	author todd;	state Exp;
branches;
next	1.46;

1.46
date	2002.05.16.21.14.49;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2002.04.04.19.57.48;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.21.18.34.11;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2002.02.21.13.44.13;	author todd;	state Exp;
branches;
next	1.42;

1.42
date	2002.02.21.13.19.07;	author todd;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.14.22.53.11;	author hugh;	state Exp;
branches;
next	1.40;

1.40
date	2002.02.14.17.46.15;	author todd;	state Exp;
branches;
next	1.39;

1.39
date	2002.02.14.14.32.50;	author todd;	state Exp;
branches;
next	1.38;

1.38
date	2002.02.14.13.27.04;	author todd;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.14.04.58.36;	author todd;	state Exp;
branches;
next	1.36;

1.36
date	2002.02.14.04.39.56;	author todd;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.09.17.55.53;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2002.02.09.17.01.41;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2001.12.07.03.08.51;	author hugh;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.13.00.06.30;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.28.02.58.57;	author kjc;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.25.03.20.24;	author kjell;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.24.23.36.11;	author kjell;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.30.02.11.27;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.01.20.14.40;	author hugh;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.31.02.51.26;	author hugh;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.05.07.27.36;	author hugh;	state Exp;
branches;
next	1.24;

1.24
date	2000.12.04.09.56.06;	author hugh;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.24.20.32.40;	author hugh;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.24.20.29.10;	author hugh;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.24.20.13.10;	author hugh;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.24.19.14.03;	author hugh;	state Exp;
branches;
next	1.19;

1.19
date	2000.05.01.01.48.36;	author bjc;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.22.07.34.30;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	98.11.19.08.18.58;	author dugsong;	state Exp;
branches;
next	1.16;

1.16
date	98.09.15.10.23.23;	author pattonme;	state Exp;
branches;
next	1.15;

1.15
date	98.05.14.17.07.22;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	98.01.26.04.19.52;	author dgregor;	state Exp;
branches;
next	1.13;

1.13
date	97.09.20.14.36.58;	author maja;	state Exp;
branches;
next	1.12;

1.12
date	97.09.08.06.12.26;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.05.14.15.41.23;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.05.13.05.35.00;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.12.14.18.24.03;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.09.18.22.03.48;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.08.28.08.55.30;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.23.06.33.00;	author etheisen;	state Exp;
branches;
next	1.5;

1.5
date	96.07.23.06.15.20;	author etheisen;	state Exp;
branches;
next	1.4;

1.4
date	96.07.15.14.59.21;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.01.08.18.48.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.07.07.41.29;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.38.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.38.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.136
log
@We are done providing support for the vax.
lots of agreement.
@
text
@#!/bin/sh -
#
# THIS FILE AUTOMATICALLY GENERATED.  DO NOT EDIT.
# generated from:
#
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.54 2015/10/23 15:14:12 claudio Exp 
#	OpenBSD: MAKEDEV.common,v 1.81 2015/11/10 21:49:18 sthen Exp 
#	OpenBSD: MAKEDEV.mi,v 1.81 2012/11/05 08:07:09 jasper Exp 
#	OpenBSD: MAKEDEV.sub,v 1.14 2005/02/07 06:14:18 david Exp 
#
#
# Copyright (c) 2001-2004 Todd T. Fries <todd@@OpenBSD.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
# Device "make" file.  Valid arguments:
#	all	makes all known devices, including local devices.
#		Tries to make the ``standard'' number of each type.
#	ramdisk	Ramdisk kernel devices
#	std	Standard devices
#	local	Configuration specific devices
# Disks:
#	cd*	ATAPI and SCSI CD-ROM drives
#	hd*	HDC9224 disks
#	ra*	MSCP disks
#	rd*	"rd" pseudo-disks
#	rx*	RX02 floppy disks
#	sd*	SCSI disks, including flopticals
#	vnd*	"file" pseudo-disk devices
# Tapes:
#	ch*	SCSI media changers
#	mt*	(Magnetic) 9-track reel tape drives
#	st*	SCSI tape drives
# Terminal ports:
#	dhu*	UNIBUS DHU11
#	dl*	UNIBUS DL11
#	dz*	UNIBUS DZ11 and DZ32
#	qsc*	VXT2000 serial ports
# Pseudo terminals:
#	ptm	pty master device
#	pty*	Set of 62 master pseudo terminals
#	tty*	Set of 62 slave pseudo terminals
# Console ports:
#	ttyC-J*	wscons display devices
#	wscons	Minimal wscons devices
#	wskbd*	wscons keyboards
# Pointing devices:
#	wsmouse*	wscons mice
# Special purpose devices:
#	audio*	Audio devices
#	bio	ioctl tunnel pseudo-device
#	bpf*	Berkeley Packet Filter
#	diskmap	Disk mapper
#	fd	fd/* nodes
#	fuse	Userland Filesystem
#	pf*	Packet Filter
#	pppx*	PPP Multiplexer
#	*random	In-kernel random data source
#	systrace*	System call tracing device
#	tun*	Network tunnel driver
#	tap*	Ethernet tunnel driver
#	uk*	Unknown SCSI devices
#	vscsi*	Virtual SCSI controller
PATH=/sbin:/usr/sbin:/bin:/usr/bin
T=$0

# set this to echo for Echo-Only debugging
[ "$eo" ] || eo=

hex()
{
	case $1 in
	[0-9]) echo -n $1;;
	10) echo -n a;;
	11) echo -n b;;
	12) echo -n c;;
	13) echo -n d;;
	14) echo -n e;;
	15) echo -n f;;
	esac
}

alph2d()
{
	local t="$1"
	local p="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	local sub=${p%${t}*}
	echo ${#sub}
}

h2d()
{
	local s="$1"
	local f=${s%*[0-9a-f]} n=${s#[0-9a-f]*}

	echo $(($(_h2d $f)*16+ $(_h2d $n) ))
}

_h2d()
{
	case $1 in
	[0-9]) echo -n $1;;
	a) echo -n 10;;
	b) echo -n 11;;
	c) echo -n 12;;
	d) echo -n 13;;
	e) echo -n 14;;
	f) echo -n 15;;
	esac
}

unt()
{
	# XXX pdksh can't seem to deal with locally scoped variables
	# in ${foo#$bar} expansions
	arg="$1"
	tmp="${arg#[a-zA-Z]*}"
	tmp="${tmp%*[a-zA-Z]}"
	while [ "$tmp" != "$arg" ]
	do
		arg=$tmp
		tmp="${arg#[a-zA-Z]*}"
		tmp="${tmp%*[a-zA-Z]}"
	done
	echo $arg
}

dodisk()
{
	[ "$DEBUG" ] && set -x
	n=$(($((${5}*${7:-16}))+${6})) count=0
	[ 0$7 -ne 8 ] && l="i j k l m n o p"
	for d in a b c d e f g h $l
	do
		M $1$2$d	b $3 $(($n+$count)) 640 operator
		M r$1$2$d	c $4 $(($n+$count)) 640 operator
		let count=count+1
	done
}

dodisk2()
{
	n=$(($(($5*${7:-16}))+$6))
	M $1$2a b $3 $n 640 operator
	M r$1$2a c $4 $n 640 operator
	n=$(($n+2))
	M $1$2c b $3 $n 640 operator
	M r$1$2c c $4 $n 640 operator
}

# M name b/c major minor [mode] [group]
RMlist[0]="rm -f"

mkl() {
	mklist[${#mklist[*]}]=";mknod -m $1 $2 $3 $4 $5"
}

M() {
	RMlist[${#RMlist[*]}]=$1
	mkl ${5-666} $1 $2 $3 $4
	G=${6:-wheel}
	[ "$7" ] && {
		MKlist[${#MKlist[*]}]="&& chown $7:$G $1"
	} || {
		case $G in
		wheel)
			[ ${#whlist[*]} = 0 ] && whlist[0]="&& chgrp wheel"
			whlist[${#whlist[*]}]="$1"
		;;
		operator)
			[ ${#oplist[*]} = 0 ] && oplist[0]="&& chgrp operator"
			oplist[${#oplist[*]}]="$1"
		;;
		*)
			MKlist[${#MKlist[*]}]="&& chgrp $G $1";
		esac
	}
	return 0
}

R() {
[ "$DEBUG" ] && set -x
for i in "$@@"
do
U=`unt $i`
[ "$U" ] || U=0

case $i in
ramdisk)
	R std bpf0 bio diskmap
	R fd0 sd0 sd1 rd0 random
	;;

std)
	M console	c 0 0 600
	M tty		c 2 0
	M mem		c 3 0 640 kmem
	M kmem		c 3 1 640 kmem
	M null		c 3 2
	M zero		c 3 12
	M stdin		c 53 0
	M stdout	c 53 1
	M stderr	c 53 2
	M ksyms		c 50 0 640 kmem
	M klog		c 33 0 600
	M ttyg0		c 25 0 600
	M ttyg1		c 25 1 600
	M ttyg2		c 25 2 600
	M ttyg3		c 25 3 600
	;;

mt*)
	case $U in
	[0-7])
		four=$(($U+4))
		eight=$(($U+8))
		twelve=$(($U+12))
		twenty=$(($U+20))
		M mt$U		b 15 $U	660 operator
		M mt$four	b 15 $four	660 operator
		M mt$eight	b 15 $eight	660 operator
		M mt$twelve	b 15 $twelve	660 operator
		M nmt$U		b 15 $four	660 operator;: sanity w/pdp11 v7
		M nmt$eight	b 15 $twelve	660 operator;: ditto
		M nrmt$U	c 38 $four	660 operator;: ditto
		M nrmt$eight	c 38 $twelve	660 operator;: ditto
		M rmt$U		c 38 $U		660 operator
		M rmt$four	c 38 $four	660 operator
		M rmt$eight	c 38 $eight	660 operator
		M rmt$twelve	c 38 $twelve	660 operator
		;;
	*)
		echo bad unit for tape in: $i
		;;
	esac
	umask 77
	;;


vscsi*)
	M vscsi$U c 78 $U 600
	;;

uk*)
	M uk$U c 65 $U 640 operator
	;;

tap*)
	M tap$U c 83 $U 600
	;;

tun*)
	M tun$U c 57 $U 600
	;;

systrace)
	M systrace c 49 0 644
	;;

*random)
	n=0
	for pre in " " s u a
	do
		M ${pre}random c 67 $n 644
		n=$(($n+1))
	done
	;;

pppx*)
	M pppx$U c 80 $U 600
	;;

pf*)
	M pf c 42 0 600
	;;

fuse)
	M fuse$U c 82 $U 600
	;;

fd)
	RMlist[${#RMlist[*]}]=";mkdir -p fd;rm -f" n=0
	while [ $n -lt 64 ];do M fd/$n c 53 $n;n=$(($n+1));done
	MKlist[${#MKlist[*]}]=";chmod 555 fd"
	;;

diskmap)
	M diskmap c 79 0 640 operator
	;;

bpf*)
	M bpf$U c 56 $U 600
	;;

bio)
	M bio c 72 0 600
	;;

audio*)
	M sound$U	c 81 $U
	M mixer$U	c 81 $(($U+16))
	M audio$U	c 81 $(($U+128))
	M audioctl$U	c 81 $(($U+192))
	MKlist[${#MKlist[*]}]=";[ -e audio ] || ln -s audio$U audio"
	MKlist[${#MKlist[*]}]=";[ -e mixer ] || ln -s mixer$U mixer"
	MKlist[${#MKlist[*]}]=";[ -e sound ] || ln -s sound$U sound"
	MKlist[${#MKlist[*]}]=";[ -e audioctl ] || ln -s audioctl$U audioctl"
	;;

wsmouse[0-9]*)
	M wsmouse$U c 70 $U 600
	;;

wskbd[0-9]*)
	M wskbd$U c 69 $U 600
	;;

wscons)
	R wsmouse0 wsmouse1 wsmouse2 wsmouse3 wskbd0 wskbd1 wskbd2
	R wskbd3 ttyCcfg ttyC0 ttyC1 ttyC2 ttyC3 ttyC4 ttyC5 ttyC6
	R ttyC7 ttyC8 ttyC9 ttyCa ttyCb
	;;

tty[C-J]*)
	U=${i##tty[C-J]}
	case $i in
	ttyC*) n=C m=0;;
	ttyD*) n=D m=256;;
	ttyE*) n=E m=512;;
	ttyF*) n=F m=768;;
	ttyG*) n=G m=1024;;
	ttyH*) n=H m=1280;;
	ttyI*) n=I m=1536;;
	ttyJ*) n=J m=1792;;
	esac
	case $U in
	[0-9a-f]) M tty$n$U c 68 $((16#$U+$m)) 600;;
	cfg) M tty${n}cfg c 68 $((255+$m)) 600;;
	*) echo bad unit $U for $i; exit 1;;
	esac
	;;

pty*)
	if [ $U -gt 15 ]; then
		echo bad unit for pty in: $i
		continue
	fi
	set -A letters p q r s t u v w x y z P Q R S T
	set -A suffixes 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q \
	    r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X \
	    Y Z

	name=${letters[$U]}
	n=0
	while [ $n -lt 62 ]
	do
		nam=$name${suffixes[$n]}
		off=$(($U*62))
		M tty$nam c 20 $(($off+$n))
		M pty$nam c 21 $(($off+$n))
		n=$(($n+1))
	done
	;;

ptm)
	M ptm c 75 0 666
	;;

qsc*)
	
	case $U in
	0)
		for i in 0 1 2 3; do
			M ttyb${i} c 48 ${i} 600
		done
	;;
	*)
		echo bad unit for qsc in: $i
	;;
	esac
	;;

dz*)
	case $U in
	[0-7])
		i=0
		while [ $i -lt 8 ]; do
			no=$(($(($U*8))+$i))
			if [ $no -lt 10 ]; then
				no="0${no}"
			fi
			M tty${no} c 1 $no 600
			i="$(( $i + 1 ))"
		done
	;;
	*)
		echo bad unit for dz in: $i
		;;
	esac
	;;

dl*)
	set -A cnvtbl 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v
	let=${cnvtbl[$U]}
	if [ -n "$let" ] ;then
		M ttyJ${let} c 66 $U 600
	else
		echo bad unit for dl in: $i
	fi
	;;

dhu*)
	set -A cnvtbl 0 1 2 3 4 5 6 7 8 9 a b c d e f
	case $U in
	[0-7])
		case $U in
		0) ch=S ;; 1) ch=T ;; 2) ch=U ;; 3) ch=V ;;
		4) ch=W ;; 5) ch=X ;; 6) ch=Y ;; 7) ch=Z ;;
		esac
		i=0
		while [ $i -lt 16 ]; do
			let=${cnvtbl[$i]}
			M tty${ch}${let} c 34 $(($(($U*16))+$i)) 600
			i="$(( $i + 1 ))"
		done
	;;
	*)
		echo bad unit for dhu in: $i
	;;
	esac
	;;

st*)
	n=$(($U*16))
	for pre in " " n e en
	do
		M ${pre}st$U	b 21 $n 660 operator
		M ${pre}rst$U	c 60 $n 660 operator
		n=$(($n+1))
	done
	;;

ch*)
	M ch$U c 63 $U 660 operator
	;;

vnd*)
	dodisk vnd $U 18 55 $U 0
	;;

rd*)
	dodisk2 rd $U 23 62 $U 0
	;;

cd*)
	dodisk2 cd $U 22 61 $U 0
	;;

local)
	test -s $T.local && sh $T.local
	;;

all)
	R qsc0 dl0 dz0 dhu0 mt0 mt1 hd0 hd1 hd2 vnd0 sd0 sd1 sd2 sd3
	R cd0 tap0 tap1 tun0 tun1 bio bpf0 bpf1 bpf2 bpf3 bpf4 bpf5
	R bpf6 bpf7 pty0 diskmap vscsi0 ch0 audio0 fuse pppx ptm local
	R wscons uk0 random pf systrace rx0 rx1 ra0 ra1 ra2 ra3 std
	R st0 st1 fd
	;;

sd*|rx*|ra*|hd*)
	case $i in
	sd*) dodisk sd $U 20 59 $U 0;;
	rx*) dodisk rx $U 12 30 $U 0;;
	ra*) dodisk ra $U 9 9 $U 0;;
	hd*) dodisk hd $U 19 58 $U 0;;
	esac
	;;

*)
	echo $i: unknown device
	;;
esac
done
}
R "$@@"
{
echo -n ${RMlist[*]}
echo -n ${mklist[*]}
echo -n ${MKlist[*]}
echo -n ${whlist[*]}
echo ${oplist[*]}
} | if [ "$eo" = "echo" ]; then
        cat
else
	sh
fi
@


1.135
log
@sync
@
text
@@


1.134
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.80 2015/11/10 21:42:28 sthen Exp 
@


1.133
log
@Sync (after tap addition)
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.79 2015/10/23 15:14:11 claudio Exp 
@


1.132
log
@regen
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.52 2014/03/19 15:28:16 miod Exp 
#	OpenBSD: MAKEDEV.common,v 1.76 2014/08/20 11:23:40 mikeb Exp 
d71 1
d258 4
d475 4
a478 4
	R cd0 tun0 tun1 bio bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7
	R pty0 diskmap vscsi0 ch0 audio0 fuse pppx ptm local wscons
	R uk0 random pf systrace rx0 rx1 ra0 ra1 ra2 ra3 std st0 st1
	R fd
@


1.131
log
@regen
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.74 2014/07/11 21:58:32 tedu Exp 
a65 1
#	lkm	Loadable kernel modules interface
a281 4
lkm)
	M lkm c 28 0 640 _lkm
	;;

d472 2
a473 2
	R uk0 random lkm pf systrace rx0 rx1 ra0 ra1 ra2 ra3 std st0
	R st1 fd
@


1.130
log
@sync
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.51 2014/01/05 01:16:52 deraadt Exp 
#	OpenBSD: MAKEDEV.common,v 1.73 2013/11/21 11:04:44 kettenis Exp 
@


1.129
log
@regen
@
text
@d6 1
a6 1
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.50 2013/06/03 16:06:42 tedu Exp 
d201 1
a201 1
	R fd0 sd0 sd1 rd0
@


1.128
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.72 2013/11/05 16:05:30 deraadt Exp 
@


1.127
log
@regen
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.66 2013/06/21 21:30:38 syl Exp 
@


1.126
log
@regen
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.65 2013/06/15 23:09:36 halex Exp 
d65 1
a65 1
#	fuse*	Userland Filesystem
d287 1
a287 1
fuse*)
d476 3
a478 3
	R pty0 diskmap vscsi0 ch0 audio0 fuse0 fuse1 fuse2 fuse3 pppx
	R ptm local wscons uk0 random lkm pf systrace rx0 rx1 ra0 ra1
	R ra2 ra3 std st0 st1 fd
@


1.125
log
@regen. reminded by miod
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.64 2013/06/03 16:06:42 tedu Exp 
d65 1
a65 1
#	fuse	Userland Filesystem
d287 1
a287 1
fuse)
d476 3
a478 3
	R pty0 diskmap vscsi0 ch0 audio0 fuse pppx ptm local wscons
	R uk0 random lkm pf systrace rx0 rx1 ra0 ra1 ra2 ra3 std st0
	R st1 fd
@


1.124
log
@regen
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.49 2012/08/23 06:15:28 deraadt Exp 
#	OpenBSD: MAKEDEV.common,v 1.60 2012/08/23 06:15:28 deraadt Exp 
d65 1
d287 4
d476 3
a478 3
	R pty0 diskmap vscsi0 ch0 audio0 pppx ptm local wscons uk0
	R random lkm pf systrace rx0 rx1 ra0 ra1 ra2 ra3 std st0 st1
	R fd
@


1.123
log
@regen
@
text
@d471 3
a473 2
	R pty0 diskmap vscsi0 ch0 audio0 ptm local wscons uk0 random
	R lkm pf systrace rx0 rx1 ra0 ra1 ra2 ra3 std st0 st1 fd
@


1.122
log
@sync
@
text
@d8 1
a8 1
#	OpenBSD: MAKEDEV.mi,v 1.80 2011/04/18 16:52:10 thib Exp 
d172 1
a172 1
		MKlist[${#MKlist[*]}]=";chown $7:$G $1"
d176 1
a176 1
			[ ${#whlist[*]} = 0 ] && whlist[0]=";chgrp wheel"
d180 1
a180 1
			[ ${#oplist[*]} = 0 ] && oplist[0]=";chgrp operator"
d184 1
a184 1
			MKlist[${#MKlist[*]}]=";chgrp $G $1";
@


1.121
log
@Regen.
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.48 2012/04/06 15:18:41 jsing Exp 
#	OpenBSD: MAKEDEV.common,v 1.59 2012/04/06 15:18:41 jsing Exp 
a65 1
#	nnpfs*	NNPFS filesystem node
a281 4
nnpfs*)
	M nnpfs$U c 74 $U 600
	;;

d471 2
a472 3
	R pty0 diskmap vscsi0 nnpfs0 ch0 audio0 ptm local wscons uk0
	R random lkm pf systrace rx0 rx1 ra0 ra1 ra2 ra3 std st0 st1
	R fd
@


1.120
log
@regen
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.47 2011/10/22 19:31:23 miod Exp 
#	OpenBSD: MAKEDEV.common,v 1.58 2011/10/22 19:31:20 miod Exp 
a35 1
#	raid*	RAIDframe disk devices
d477 2
a478 2
	R random lkm pf systrace rx0 rx1 ra0 ra1 ra2 ra3 raid0 raid1
	R raid2 raid3 std st0 st1 fd
d481 1
a481 1
sd*|rx*|raid*|ra*|hd*)
a484 1
	raid*) dodisk raid $U 25 73 $U 0;;
@


1.119
log
@sync
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.46 2011/10/06 20:49:27 deraadt Exp 
#	OpenBSD: MAKEDEV.common,v 1.57 2011/10/06 20:49:25 deraadt Exp 
d250 1
d477 3
a479 3
	R pty0 diskmap vscsi0 nnpfs0 ch0 ptm local wscons audio0
	R audio1 audio2 uk0 random lkm pf systrace rx0 rx1 ra0 ra1 ra2
	R ra3 raid0 raid1 raid2 raid3 std st0 st1 fd
@


1.118
log
@regen
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.45 2011/09/03 20:45:17 miod Exp 
#	OpenBSD: MAKEDEV.common,v 1.56 2011/07/06 18:34:20 miod Exp 
a32 1
#	ccd*	Concatenated disk devices
d474 3
a476 3
	R qsc0 dl0 dz0 dhu0 mt0 mt1 hd0 hd1 hd2 ccd0 vnd0 sd0 sd1 sd2
	R sd3 cd0 tun0 tun1 bio bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6
	R bpf7 pty0 diskmap vscsi0 nnpfs0 ch0 ptm local wscons audio0
d481 1
a481 1
sd*|rx*|raid*|ra*|hd*|ccd*)
a487 1
	ccd*) dodisk ccd $U 17 54 $U 0;;
@


1.117
log
@Regen
@
text
@d6 1
a6 1
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.44 2011/07/06 18:32:58 miod Exp 
d62 1
d310 11
d477 3
a479 3
	R bpf7 pty0 diskmap vscsi0 nnpfs0 ch0 ptm local wscons uk0
	R random lkm pf systrace rx0 rx1 ra0 ra1 ra2 ra3 raid0 raid1
	R raid2 raid3 std st0 st1 fd
@


1.116
log
@regen makedev
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.43 2010/09/30 15:27:54 claudio Exp 
#	OpenBSD: MAKEDEV.common,v 1.54 2011/04/18 16:52:10 thib Exp 
a34 1
#	fd*	Floppy disk drives (3 1/2", 5 1/4")
a35 2
#	hk*	UNIBUS RK06 and RK07 disks
#	hp*	MASSBUS disks
a37 1
#	rb*	730 IDC w/ RB80 and/or RB02
a38 1
#	rl*	UNIBUS RL02
a40 1
#	up*	Other UNIBUS devices
a43 1
#	ht*	MASSBUS TM03 and TU?? devices
a45 3
#	tm*	UNIBUS TM11 and TE10 emulations (e.g. Emulex TC-11)
#	ts*	UNIBUS TS11
#	ut*	UNIBUS TU45 emulations (e.g. 9700)
a220 6
	M crl		c 35 0 600
	M csa1		c 51 0 600
	M csa2		c 51 1 600
	M tu0		b 8 0 600
	M tu1		b 8 1 600
	M floppy	c 8 0 600
d223 1
a223 8
ht*|tm*|mt*|ts*|ut*)
	case $i in
	ht*) n=ht b=1 c=5;;
	mt*) n=mt b=15 c=38;;
	tm*) n=tm b=5 c=14;;
	ts*) n=ts b=6 c=16;;
	ut*) n=ut b=10 c=17;;
	esac
d230 12
a241 17
		M $n$U		b $b $U	660 operator
		M $n$four	b $b $four	660 operator
		M $n$eight	b $b $eight	660 operator
		M $n$twelve	b $b $twelve	660 operator
		M n$n$U		b $b $four	660 operator;: sanity w/pdp11 v7
		M n$n$eight	b $b $twelve	660 operator;: ditto
		M nr$n$U	c $c $four	660 operator;: ditto
		M nr$n$eight	c $c $twelve	660 operator;: ditto
		M r$n$U		c $c $U		660 operator
		M r$n$four	c $c $four	660 operator
		M r$n$eight	c $c $eight	660 operator
		M r$n$twelve	c $c $twelve	660 operator
		if [ "$i" = "ut" ];
		then
			M $n$twenty	b $b $twenty 660 operator
			M r$n$twenty	c $b $twenty 660 operator
		fi
a453 30
fd*)
	typnam=$U${i#fd[01]*}
	case $typnam in
	0|1)	typnum=0;; # no type specified, assume A
	*A)	typnum=0; typnam=0;;
	*B)	typnum=1;;
	*C)	typnum=2;;
	*D)	typnum=3;;
	*E)	typnum=4;;
	*F)	typnum=5;;
	*G)	typnum=6;;
	*H)	typnum=7;;
	*)	echo bad type $typnam for $i; exit 1;;
	esac
	case $U in
	0|1)	blk=16; chr=54;;
	*)	echo bad unit $U for $i; exit 1;;
	esac
	nam=fd${typnam}
	n=$(($(($U*128))+$(($typnum*16))))
	M ${nam}a	b $blk $n 640 operator
	M ${nam}b	b $blk $(($n+1)) 640 operator
	M ${nam}c	b $blk $(($n+2)) 640 operator
	M ${nam}i	b $blk $(($n+8)) 640 operator
	M r${nam}a	c $chr $n 640 operator
	M r${nam}b	c $chr $(($n+1)) 640 operator
	M r${nam}c	c $chr $(($n+2)) 640 operator
	M r${nam}i	c $chr $(($n+8)) 640 operator
	;;

d463 5
a467 5
	R dl0 dz0 dhu0 ts0 ts1 mt0 mt1 hd0 hd1 hd2 ccd0 vnd0 sd0 sd1
	R sd2 sd3 cd0 tun0 tun1 bio bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6
	R bpf7 pty0 diskmap vscsi0 nnpfs0 ptm local wscons uk0 random
	R lkm pf systrace rx0 rx1 ra0 ra1 ra2 ra3 hp0 hp1 hp2 hp3
	R raid0 raid1 raid2 raid3 std st0 st1 fd
d470 1
a470 1
up*|sd*|rx*|rl*|rb*|raid*|ra*|hp*|hk*|hd*|ccd*)
a471 1
	up*) dodisk up $U 2 13 $U 0;;
a473 2
	rl*) dodisk rl $U 14 32 $U 0;;
	rb*) dodisk rb $U 11 23 $U 0;;
a475 2
	hp*) dodisk hp $U 0 4 $U 0;;
	hk*) dodisk hk $U 3 11 $U 0;;
@


1.115
log
@Deprecate vnds in favour of svnds.

In effect, this removes the "old" vndX nodes, and renames
the svndX nodes to vndX.

Old svndX nodes will still continue to work though, for now.

Cleanup accordingly.

ok deraadt@@, todd@@
comments and ok on the man page bits from jmc@@
@
text
@d7 2
a8 2
#	OpenBSD: MAKEDEV.common,v 1.53 2010/09/30 15:27:54 claudio Exp 
#	OpenBSD: MAKEDEV.mi,v 1.79 2009/01/25 17:30:48 miod Exp 
@


1.114
log
@regen
@
text
@a475 1
	dodisk svnd $U 18 55 $U 2048
@


1.113
log
@Regen
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.41 2010/07/03 03:59:15 krw Exp 
#	OpenBSD: MAKEDEV.common,v 1.51 2010/08/03 20:12:01 miod Exp 
d79 1
d301 4
@


1.112
log
@regen
@
text
@d36 1
a37 1
#	hd*	HDC9224 disks
d66 1
a67 1
#	ttyC-J*	wscons display devices
d74 1
d77 1
a82 1
#	nnpfs*	NNPFS filesystem node
a83 1
#	diskmap	Disk mapper
a276 4
diskmap)
	M diskmap c 79 0 640 operator
	;;

a280 4
nnpfs*)
	M nnpfs$U c 74 $U 600
	;;

d306 4
d320 4
d340 6
a362 6
	;;

wscons)
	R wsmouse0 wsmouse1 wsmouse2 wsmouse3 wskbd0 wskbd1 wskbd2
	R wskbd3 ttyCcfg ttyC0 ttyC1 ttyC2 ttyC3 ttyC4 ttyC5 ttyC6
	R ttyC7 ttyC8 ttyC9 ttyCa ttyCb
@


1.111
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.49 2010/07/21 23:40:26 nicm Exp 
@


1.110
log
@Regen.
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.48 2010/06/14 14:07:49 todd Exp 
@


1.109
log
@Regen.
@
text
@d6 4
a9 4
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.40 2010/06/26 23:49:50 jsing Exp 
#	OpenBSD: MAKEDEV.common,v 1.47 2010/06/09 16:10:24 todd Exp 
#	OpenBSD: MAKEDEV.mi,v 1.78 2008/06/14 23:09:05 todd Exp 
#	OpenBSD: MAKEDEV.sub,v 1.13 2005/01/28 18:51:38 danh Exp 
a77 1
#	ss*	SCSI scanners
a300 8
ss*)
	M ss$U c 64 $(($U*16)) 640 operator
	M nss$U c 64 $(($(($U*16))+1)) 640 operator
	M enss$U c 64 $(($(($U*16))+3)) 640 operator
	RMlist[${#RMlist[*]}]="scan$U"
	MKlist[${#MKlist[*]}]=";umask 77;ln -s ss$U scan$U"
	;;

d519 3
a521 3
	R bpf7 pty0 diskmap vscsi0 nnpfs0 ss0 ptm local wscons uk0
	R random lkm pf systrace rx0 rx1 ra0 ra1 ra2 ra3 hp0 hp1 hp2
	R hp3 raid0 raid1 raid2 raid3 std st0 st1 fd
@


1.108
log
@sync
@
text
@d6 4
a9 4
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.39 2010/06/09 16:10:25 todd Exp 
#	OpenBSD: MAKEDEV.common,v 1.48 2010/06/14 14:07:49 todd Exp 
#	OpenBSD: MAKEDEV.mi,v 1.79 2009/01/25 17:30:48 miod Exp 
#	OpenBSD: MAKEDEV.sub,v 1.14 2005/02/07 06:14:18 david Exp 
d211 1
a211 1
	R std bpf0 bio
@


1.107
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.47 2010/06/09 16:10:24 todd Exp 
d279 1
a279 1
	M diskmap b 79 0 640 operator
@


1.106
log
@regen
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.38 2009/08/13 15:12:36 deraadt Exp 
#	OpenBSD: MAKEDEV.common,v 1.46 2009/09/23 15:39:56 miod Exp 
d84 1
d278 4
d528 3
a530 3
	R bpf7 pty0 vscsi0 nnpfs0 ss0 ptm local wscons uk0 random lkm
	R pf systrace rx0 rx1 ra0 ra1 ra2 ra3 hp0 hp1 hp2 hp3 raid0
	R raid1 raid2 raid3 std st0 st1 fd
@


1.105
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.45 2009/08/13 15:12:36 deraadt Exp 
d336 1
a336 1
wsmouse*)
d340 1
a340 1
wskbd*)
@


1.104
log
@sync
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.37 2009/06/03 14:45:40 jj Exp 
#	OpenBSD: MAKEDEV.common,v 1.43 2009/06/03 14:45:39 jj Exp 
d83 1
d277 4
d523 3
a525 3
	R bpf7 pty0 nnpfs0 ss0 ptm local wscons uk0 random lkm pf
	R systrace rx0 rx1 ra0 ra1 ra2 ra3 hp0 hp1 hp2 hp3 raid0 raid1
	R raid2 raid3 std st0 st1 fd
@


1.103
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.36 2009/01/25 17:30:48 miod Exp 
#	OpenBSD: MAKEDEV.common,v 1.41 2008/11/30 03:33:09 jakemsr Exp 
@


1.102
log
@regen
@
text
@d82 1
a82 1
#	xfs*	XFS filesystem node
d276 2
a277 2
xfs*)
	M xfs$U c 74 $U 600
d518 1
a518 1
	R bpf7 pty0 xfs0 ss0 ptm local wscons uk0 random lkm pf
@


1.101
log
@sync
@
text
@d6 3
a8 3
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.35 2008/09/24 17:38:04 todd Exp 
#	OpenBSD: MAKEDEV.common,v 1.40 2008/10/10 20:15:23 deraadt Exp 
#	OpenBSD: MAKEDEV.mi,v 1.78 2008/06/14 23:09:05 todd Exp 
a223 1
	M drum		c 7 0 640 kmem
@


1.100
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.39 2008/07/14 16:22:23 miod Exp 
d303 1
a303 1
	for pre in " " s u p a
@


1.99
log
@sync
@
text
@d6 3
a8 3
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.33 2008/06/13 21:07:28 todd Exp 
#	OpenBSD: MAKEDEV.common,v 1.38 2008/06/12 22:38:14 todd Exp 
#	OpenBSD: MAKEDEV.mi,v 1.77 2005/10/06 06:43:19 otto Exp 
d519 3
a521 3
	R bpf7 pty0 ss0 ptm local wscons uk0 random lkm pf systrace
	R rx0 rx1 ra0 ra1 ra2 ra3 hp0 hp1 hp2 hp3 raid0 raid1 raid2
	R raid3 std st0 st1 fd
@


1.98
log
@sync
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.32 2008/06/12 18:52:46 todd Exp 
#	OpenBSD: MAKEDEV.common,v 1.37 2008/06/10 07:12:24 mglocker Exp 
d209 1
a209 1
	R std bpf0
@


1.97
log
@sync
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.31 2007/05/28 22:26:02 todd Exp 
#	OpenBSD: MAKEDEV.common,v 1.36 2007/07/23 23:21:25 todd Exp 
d209 1
a209 1
	R std bpf0 random
@


1.96
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.34 2007/05/18 14:05:33 jmc Exp 
a25 1

@


1.95
log
@sync
@
text
@d6 1
a6 1
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.30 2007/05/27 01:50:36 todd Exp 
d73 1
d329 4
d519 1
a519 1
	R sd2 sd3 cd0 tun0 tun1 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6
@


1.94
log
@sync
@
text
@d6 1
a6 1
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.29 2007/05/26 19:54:24 todd Exp 
a72 1
#	bio	ioctl tunnel pseudo-device
a327 4
bio)
	M bio c 5 0 600
	;;

d514 1
a514 1
	R sd2 sd3 cd0 tun0 tun1 bio bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6
@


1.93
log
@regen;
@
text
@d6 1
a6 1
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.28 2007/04/04 17:20:17 todd Exp 
d26 1
d73 1
d329 4
d519 1
a519 1
	R sd2 sd3 cd0 tun0 tun1 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6
@


1.92
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.33 2007/03/07 02:51:17 krw Exp 
a25 1

d38 1
a38 1
#	hp*	MASSBUSS disks
@


1.91
log
@regen
@
text
@d6 1
a6 1
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.27 2006/08/27 17:34:29 miod Exp 
d26 1
d278 1
a278 1
	M xfs$U c 51 $U 600
@


1.90
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.32 2007/02/16 02:16:20 deraadt Exp 
@


1.89
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.31 2006/12/15 20:42:19 kettenis Exp 
d496 1
d500 1
@


1.88
log
@Resync MAKEDEV scripts and man pages
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.29 2006/08/28 21:04:04 tsi Exp 
@


1.87
log
@Regen
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.28 2006/06/11 10:58:57 mk Exp 
d67 1
a67 1
#	ttyC-F*	wscons display devices
d335 2
a336 2
tty[C-F]*)
	U=${i##tty[C-F]}
d342 4
@


1.86
log
@Regen
@
text
@d6 1
a6 1
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.26 2006/08/24 20:21:53 miod Exp 
d60 1
d380 14
@


1.85
log
@Regen
@
text
@d6 1
a6 1
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.25 2006/08/02 19:08:42 miod Exp 
a233 1
	M kUmem		c 3 3 600
@


1.84
log
@Regen
@
text
@d6 1
a6 1
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.24 2006/07/30 12:32:41 miod Exp 
a56 1
#	dh*	UNIBUS DH11 and emulations (e.g. Able dmax, Emulex CS-11)
a58 2
#	dmf*	UNIBUS DMF32
#	dmz*	UNIBUS DMZ32
a59 1
#	vt*	console
d384 11
a394 11
       [0-7])
	       i=0
	       while [ $i -lt 8 ]; do
		       no=$(($(($U*8))+$i))
		       if [ $no -lt 10 ]; then
			       no="0${no}"
		       fi
		       M tty${no} c 1 $no 600
		       let i=i+1
	       done
	       ;;
d396 2
a397 36
	       echo bad unit for dz in: $i
	       ;;
       esac
	;;

dhu*|dmz*|dmf*|dh*|vt*)
	set -A cnvtbl 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v
	case $i in
	vt*)    name=vt; major=68; count=8;
		case $U in
		0) ch=w ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dmz*)   name=dmz; major=37; count=24;
		case $U in
		0) ch=a ;; 1) ch=b ;; 2) ch=c ;; 3) ch=e ;; 4) ch=f ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dmf*)   name=dmf; major=22; count=8;
		case $U in
		0) ch=A ;; 1) ch=B ;; 2) ch=C ;; 3) ch=E ;;
		4) ch=F ;; 5) ch=G ;; 6) ch=H ;; 7) ch=I ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dhu*)   name=dhu; major=34; count=16;
		case $U in
		0) ch=S ;; 1) ch=T ;; 2) ch=U ;; 3) ch=V ;;
		4) ch=W ;; 5) ch=X ;; 6) ch=Y ;; 7) ch=Z ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dh*)    name=dh; major=12; count=16;
		case $U in
		0) ch=h ;; 1) ch=i ;; 2) ch=j ;; 3) ch=k ;;
		4) ch=l ;; 5) ch=m ;; 6) ch=n ;; 7) ch=o ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
a398 10
	i=0
	while [ $i -lt $count ]; do
		let=${cnvtbl[$i]}
		if [ -n "$let" ] ;then
			M tty${ch}${let} c $major $(($(($U*$count))+$i)) 600
		else
			echo bad count for ${name}: $U, $count, $i
		fi
		let i=i+1
	done
d402 1
a402 1
	major=66
d405 1
a405 1
		M ttyJ${let} c $major $U 600
d407 1
a407 1
		echo bad number for ${name}: $U
d411 21
d492 2
a493 2
	R vt0 dl0 dz0 dhu0 ts0 ts1 mt0 mt1 hd0 hd1 hd2 ccd0 vnd0 sd0
	R sd1 sd2 sd3 cd0 tun0 tun1 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6
@


1.83
log
@regen
@
text
@d6 1
a6 1
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.23 2006/07/24 22:59:22 miod Exp 
d71 3
d331 8
d355 3
a357 2
	R ttyCcfg ttyC0 ttyC1 ttyC2 ttyC3 ttyC4 ttyC5 ttyC6 ttyC7
	R ttyC8 ttyC9 ttyCa ttyCb
d521 3
a523 3
	R bpf7 pty0 ss0 ptm local uk0 random lkm pf systrace rx0 rx1
	R ra0 ra1 ra2 ra3 hp0 hp1 hp2 hp3 raid0 raid1 raid2 raid3 std
	R st0 st1 fd
@


1.82
log
@Regen
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.21 2005/08/01 22:22:14 deraadt Exp 
#	OpenBSD: MAKEDEV.common,v 1.23 2005/12/27 19:02:42 miod Exp 
d68 3
d326 20
@


1.81
log
@regen
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.21 2005/10/06 06:43:19 otto Exp 
d70 1
a70 1
#	fd	fd/* nodes for fdescfs
@


1.80
log
@regen
@
text
@d7 2
a8 2
#	OpenBSD: MAKEDEV.common,v 1.20 2005/08/01 22:22:12 deraadt Exp 
#	OpenBSD: MAKEDEV.mi,v 1.76 2005/10/04 18:33:52 otto Exp 
d167 1
a167 2
RMlist="rm -f"
MKlist=":"
d170 1
a170 6
	[ "${mklist[$1]}" ] && {
		mklist[$1]="${mklist[$1]};mknod -m $1 $2 $3 $4 $5"
	} || {
		mklist[$1]="mknod -m $1 $2 $3 $4 $5"
		modes="$modes $1"
	}
d174 1
a174 1
	RMlist="$RMlist $1"
d178 1
a178 1
		MKlist="$MKlist;chown $7:$G $1"
d181 10
a190 1
		wheel)g=0;;kmem)g=2;;operator)g=5;;tty)g=4;;dialer)g=117;;_lkm)g=61;;
a191 6
		[ "${grplist[$g]}" ] && {
			grplist[$g]="${grplist[$g]} $1"
		} || {
			groups="$groups $g"
			grplist[$g]="chgrp $G $1"
		}
d294 2
a295 2
	RMlist="$RMlist scan$U"
	MKlist="$MKlist;umask 77;ln -s ss$U scan$U"
d316 1
a316 1
	RMlist="mkdir -p fd;$RMlist" n=0
d318 1
a318 1
	MKlist="$MKlist;chmod 555 fd"
d514 8
a521 10
list="$RMlist"
for mode in $modes; do
	list="$list;${mklist[$mode]}"
done
for group in $groups; do
	list="$list;${grplist[$group]}"
done
list="$list;$MKlist"
if [ "$eo" = "echo" ]; then
	$eo "$list"
d523 1
a523 1
	echo "$list" | sh
@


1.79
log
@regen
@
text
@d8 1
a8 1
#	OpenBSD: MAKEDEV.mi,v 1.75 2005/10/04 18:11:10 otto Exp 
d150 1
a150 1
		M $1$2$d	b $3 $(($n+$count)) 640 operaror
@


1.78
log
@regen
@
text
@d8 1
a8 1
#	OpenBSD: MAKEDEV.mi,v 1.74 2005/10/04 07:39:37 otto Exp 
a146 1
	RMlist="$RMlist $1$2? r$1$2?"
d150 2
a151 2
		M $1$2$d	b $3 $(($n+$count)) 640
		M r$1$2$d	c $4 $(($n+$count)) 640
a153 1
	MKlist="$MKlist;chown root:operator $1$2? r$1$2?"
@


1.77
log
@sync
@
text
@d8 1
a8 1
#	OpenBSD: MAKEDEV.mi,v 1.73 2005/02/07 06:14:18 david Exp 
a183 1
	mklist="$mklist $1"
@


1.76
log
@Regen
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.20 2004/08/20 00:18:08 deraadt Exp 
#	OpenBSD: MAKEDEV.common,v 1.18 2005/06/02 20:09:38 tholo Exp 
a73 1
#	ses*	SES/SAF-TE SCSI devices
a301 4
	;;

ses*)
	M ses$U c 124 $U 640 operator
@


1.75
log
@regen
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.16 2005/03/01 13:35:59 otto Exp 
@


1.74
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.15 2005/01/28 18:56:27 danh Exp 
@


1.73
log
@sync
@
text
@d8 2
a9 2
#	OpenBSD: MAKEDEV.mi,v 1.72 2004/02/16 18:58:53 miod Exp 
#	OpenBSD: MAKEDEV.sub,v 1.13 2005/01/28 18:51:38 danh Exp 
@


1.72
log
@sync
@
text
@d101 1
a101 1
	local t="$1"  
@


1.71
log
@regen
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.13 2005/01/10 07:53:57 dlg Exp 
d9 1
a9 1
#	OpenBSD: MAKEDEV.sub,v 1.12 2004/02/20 19:13:01 miod Exp 
@


1.70
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.12 2004/08/19 07:05:20 miod Exp 
@


1.69
log
@bpf0 on ramdisk; from hugh
@
text
@d6 1
a6 1
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.19 2004/04/11 18:05:23 millert Exp 
@


1.68
log
@Regen.
@
text
@d212 1
a212 1
	R std random
@


1.67
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.10 2004/06/03 18:36:59 grange Exp 
d78 1
a78 1
#	uk*	SCSI unknown devices
@


1.66
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.9 2004/05/30 08:17:17 grange Exp 
@


1.65
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.8 2004/05/29 04:07:30 deraadt Exp 
@


1.64
log
@regen
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.7 2004/04/11 18:14:59 millert Exp 
@


1.63
log
@Regen for for pty changes (62 per letter instead of just 16)
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.6 2004/04/11 18:05:22 millert Exp 
d66 2
a67 2
#	pty*	Set of 62 pseudo terminals
tty_dev
@


1.62
log
@sync
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.18 2004/02/20 19:13:08 miod Exp 
#	OpenBSD: MAKEDEV.common,v 1.4 2004/03/12 04:54:04 deraadt Exp 
d66 2
a67 2
#	pty*	Set of 16 master pseudo terminals
#	tty*	Set of 16 slave pseudo terminals
d341 6
a346 2
	set -A tbl p q r s t u v w x y z P Q R S T
	name=${tbl[$U]}
d348 1
a348 1
	while [ $n -lt 16 ]
d350 2
a351 2
		nam=$name$(hex $n)
		off=$(($U*16))
d497 3
a499 3
	R bpf7 pty0 pty1 ss0 ptm local uk0 random lkm pf systrace rx0
	R rx1 ra0 ra1 ra2 ra3 hp0 hp1 hp2 hp3 raid0 raid1 raid2 raid3
	R std st0 st1 fd
@


1.61
log
@Regen; except for alpha, the only changes are in comments.
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.common,v 1.3 2004/02/20 19:13:01 miod Exp 
@


1.60
log
@Regen with correct hd(4) description.
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.17 2004/02/17 11:18:08 miod Exp 
#	OpenBSD: MAKEDEV.common,v 1.2 2004/02/17 11:18:03 miod Exp 
d9 1
a9 1
#	OpenBSD: MAKEDEV.sub,v 1.11 2004/02/16 18:58:53 miod Exp 
d34 1
a34 1
#	cd*	SCSI cdrom drives
d40 1
d45 1
a45 1
#	sd*	SCSI disks
a72 1
#	raid*	RAIDframe disk devices
@


1.59
log
@Regen
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.16 2004/02/16 19:01:02 miod Exp 
#	OpenBSD: MAKEDEV.common,v 1.1 2004/02/16 18:58:54 miod Exp 
d37 1
a37 1
#	hd*	HP300 HP-IB disks
@


1.58
log
@sync
@
text
@d6 4
a9 3
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.15 2004/02/14 17:24:31 todd Exp 
#	OpenBSD: MAKEDEV.mi,v 1.71 2004/02/14 17:24:30 todd Exp 
#	OpenBSD: MAKEDEV.sub,v 1.10 2004/02/14 17:24:31 todd Exp 
a25 1

d29 3
a31 9
#	std	standard devices
#	local	configuration specific devices
# Tapes:
#	st*	SCSI tapes
#	mt*	(Magnetic) 9-track reel tape
#	ht*	massbus tm03 & tu??
#	tm*	unibus tm11 & te10 emulations (e.g. Emulex tc-11)
#	ts*	unibus ts11
#	ut*	unibus tu45 emulations (e.g.si 9700)
d33 4
a36 7
#	hp*	massbuss rm??
#	hk*	unibus rk06 and rk07
#	up*	other unibus devices (e.g. on Emulex sc-21v controller)
#	ra*	MSCP disks (ra??, hd??)
#	rb*	730 idc w/ rb80 and/or rb02
#	rx*	MSCP floppy disk (rx33/50/...)
#	rl*	unibus r102
d38 6
d45 18
a62 8
#	cd*	SCSI cdrom drives
#	ch*	SCSI media changer
#	ss*	SCSI scanners
#	uk*	SCSI Unknown device
#	rd*	"rd" pseudo-disks
#	fd*	Floppy disk drives (3 1/2", 5 1/4")
#	vnd*	"file" pseudo-disks
#	ccd*	concatenated disk devices
a63 2
#	tty*	set of 16 slave pseudo terminals
#	pty*	set of 16 master pseudo terminals
d65 2
a66 9
# Printers:
# Terminal ports:
#	dhu*	unibus dhu11
#	dh*	unibus dh11 and emulations (e.g. Able dmax, Emulex cs-11)
#	dmf*	unibus dmf32
#	dmz*	unibus dmz32
#	vt*	console
#	dz*	unibus dz11 and dz32
#	dl*	unibus dl11
a67 1
#	openprom	
d69 2
a71 5
#	lkm	loadable kernel modules interface
#	tun*	network tunnel driver
#	*random	inkernel random data source
#	magma*	magma card (makes 16 tty and 2 bpp)
#	xfs*	XFS filesystem devices
d73 1
a73 1
#	fd	makes fd/* for the fdescfs
d75 5
a79 1
#	systrace*	system call tracing device
d281 6
a286 2
systrace)
	M systrace c 49 0 644
d289 2
a290 2
ses*)
	M ses$U c 124 $U 640 operator
d293 2
a294 4
fd)
	RMlist="mkdir -p fd;$RMlist" n=0
	while [ $n -lt 64 ];do M fd/$n c 53 $n;n=$(($n+1));done
	MKlist="$MKlist;chmod 555 fd"
d297 6
a302 2
xfs*)
	M xfs$U c 51 $U 600
d305 2
a306 17
magma*)
	case $U in
	0)	offset=0  nam=m;;
	1)	offset=16 nam=n;;
	2)	offset=32 nam=o;;
	*)	echo "bad unit for $i: $U"; exit 127;;
	esac
	offset=$(($U*64))
	n=0
	while [ $n -lt 16 ]
	do
		name=${nam}`hex $n`
		M tty$name c major_mag_c $(($offset+$n)) 660 dialer uucp
		n=$(($n+1))
	done
	M bpp${nam}0 c major_bppmag_c $(($offset+0)) 600
	M bpp${nam}1 c major_bppmag_c $(($offset+1)) 600
d318 2
a319 2
tun*)
	M tun$U c 57 $U 600
d326 4
a329 2
pf*)
	M pf c 42 0 600
d336 20
a355 2
openprom)
	M openprom c 70 0  
d431 3
a433 13
ptm)
	M ptm c 75 0 666
	;;

pty*)
	if [ $U -gt 15 ]; then
		echo bad unit for pty in: $i
		continue
	fi
	set -A tbl p q r s t u v w x y z P Q R S T
	name=${tbl[$U]}
	n=0
	while [ $n -lt 16 ]
d435 2
a436 4
		nam=$name$(hex $n)
		off=$(($U*16))
		M tty$nam c 20 $(($off+$n))
		M pty$nam c 21 $(($off+$n))
d441 4
d450 4
a481 20
rd*)
	dodisk2 rd $U 23 62 $U 0
	;;

uk*)
	M uk$U c 65 $U 640 operator
	;;

ss*)
	M ss$U c 64 $(($U*16)) 640 operator
	M nss$U c 64 $(($(($U*16))+1)) 640 operator
	M enss$U c 64 $(($(($U*16))+3)) 640 operator
	RMlist="$RMlist scan$U"
	MKlist="$MKlist;umask 77;ln -s ss$U scan$U"
	;;

ch*)
	M ch$U c 63 $U 660 operator
	;;

a485 10
st*)
	n=$(($U*16))
	for pre in " " n e en
	do
		M ${pre}st$U	b 21 $n 660 operator
		M ${pre}rst$U	c 60 $n 660 operator
		n=$(($n+1))
	done
	;;

d493 3
a495 3
	R bpf7 pty0 pty1 ss0 ptm uk0 random lkm pf systrace rx0 rx1
	R ra0 ra1 ra2 ra3 hp0 hp1 hp2 hp3 raid0 raid1 raid2 raid3 std
	R st0 st1 fd
@


1.57
log
@Regen.
@
text
@d6 3
a8 3
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.14 2004/02/10 01:31:20 millert Exp 
#	OpenBSD: MAKEDEV.mi,v 1.70 2004/02/13 23:34:13 miod Exp 
#	OpenBSD: MAKEDEV.sub,v 1.9 2004/01/12 22:18:24 todd Exp 
d11 1
a11 1
# Copyright (c) 2001,2002,2003 Todd T. Fries <todd@@OpenBSD.org>
@


1.56
log
@regen properly
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.mi,v 1.68 2004/02/10 01:31:20 millert Exp 
d57 1
a57 1
#	tty*	set of 16 slave psuedo terminals
@


1.55
log
@Add the ptm device to pty(4).  By opening /dev/ptm and using the PTMGET
ioctl(2), an unprivileged process may allocate a pty and have its owner
and mode set appropriately.  This means that programs such as xterm and
screen no longer need to be setuid.  Programs using the openpty()
function require zero changes and will "just work".

Designed by beck@@ and deraadt@@; changes by beck@@ with cleanup (and
a rewrite of the vnode bits) by art@@ and tweaks/bugfixes by me.
Tested by many.
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.13 2003/06/18 18:08:59 todd Exp 
#	OpenBSD: MAKEDEV.mi,v 1.67 2004/02/05 22:22:15 todd Exp 
@


1.54
log
@sync
@
text
@d59 1
d422 4
d518 3
a520 3
	R bpf7 pty0 pty1 ss0 uk0 random lkm pf systrace rx0 rx1 ra0
	R ra1 ra2 ra3 hp0 hp1 hp2 hp3 raid0 raid1 raid2 raid3 std st0
	R st1 fd
@


1.53
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.mi,v 1.65 2004/01/12 22:31:34 todd Exp 
a540 16
if [ "$os" = "SunOS" ]; then
	eo=transform
	transform() {
		case $mode in
		600) mask=077;;
		640) mask=027;;
		660) mask=007;;
		644) mask=022;;
		666) mask=0;;
		440) mask=227;;
		esac
		echo `echo "$@@"|sed \
		    's/mknod -m \([0-9]*\) /umask '$mask';mknod /;s/-m [0-9]* //g;\
		    s/operator/5/g;s/root.kmem/root.2/g;s/root\./root:/g'`
	}
fi
d549 1
a549 1
if [ "$eo" = "echo" -o "$eo" = "transform" ]; then
@


1.52
log
@larger svnd gap
@
text
@d3 2
a4 2
#	$OpenBSD: MAKEDEV,v 1.51 2003/04/15 20:10:46 jmc Exp $
#	$NetBSD: MAKEDEV,v 1.30 2000/01/21 12:28:29 tsutsui Exp $
d6 3
a8 1
#	@@(#)MAKEDEV	8.1 (Berkeley) 6/9/93
d10 16
d27 2
a30 1
#	all	create a reasonable amount of all files
a31 6
#	ht*	MASSBUS TM03 & TU??
#	tm*	UNIBUS TM11 & TE10 emulations (e.g. Emulex TC-11)
#	mt*	MSCP tapes (e.g. TU81, TK50)
#	ts*	UNIBUS TS11
#	ut*	UNIBUS TU45 emulations (e.g.si 9700)
#	uu*	TU58 cassettes on DL11 controller
d33 5
d39 3
a41 3
#	hp*	MASSBUS RM??
#	hk*	UNIBUS RK06 and RK07
#	up*	other UNIBUS devices (e.g. on Emulex SC-21V controller)
d43 11
a53 5
#	rx*	MSCP floppy disk (RX33/50/...)
#	rl*	UNIBUS RL02
#	rb*	730 IDC w/ RB80 and/or RB02
#	ccd*	"concatenated" pseudo-disks
#	raid*	RAIDframe disk driver
d55 1
a55 11
#	rd*	memory pseudo-disk devices
#	sd*	SCSI disks
#	cd*	SCSI CD-ROM
#	hd*	HDC9224 hd disks on VS2000
# Terminal multiplexors:
#	dz*	UNIBUS DZ11 and DZ32
#	dh*	UNIBUS DH11 and emulations (e.g. Able dmax, Emulex CS-11)
#	dmf*	UNIBUS DMF32
#	dhu*    UNIBUS DHU11
#	dmz*    UNIBUS DMZ32
#	dl*	UNIBUS DL11
d57 2
a58 1
#	pty*	set of 16 master and slave pseudo terminals
d60 8
a67 6
#	ct*	UNIBUS parallel interface to CAT typesetter
#	lp*	UNIBUS LP11 parallel interface
#	va*	UNIBUS Varian parallel interface
#	vp*	UNIBUS Versatec parallel interface
# Call units:
#	dn*	UNIBUS DN11 and emulations (e.g. Able Quadracall)
d69 12
a80 14
#	ik*	UNIBUS interface to Ikonas frame buffer
#	ps*	UNIBUS interface to E&S Picture System 2
#	ad*	UNIBUS interface to Data Translation A/D converter
#	np*	UNIBUS Ethernet co-processor interface, for downloading.
#	qv*	QVSS (MicroVAX) display
#	lkm	loadable kernel modules
#	bpf*	berkeley packet filter
#	tun*	network tunnel device
#	ss*	SCSI scanner
#	uk*	SCSI unknown
#	ch*	SCSI changer
#	*random	Random number generator
#	systrace* system call tracing device
#
d82 62
a143 5
set -A cnvtbl 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v
umask 77
for i
do
case $i in
d145 14
a158 9
all)
	sh $0 std fd vnd0 ccd0 pty0 pty1 lkm random
	sh $0 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7 pf tun0 tun1
	sh $0 mt0 mt1 ts0 ts1 st0 st1 uk0 ss0 cd0 vt0
	sh $0 ra0 ra1 ra2 ra3 hp0 hp1 hp2 hp3 sd0 sd1 sd2 sd3 hd0 hd1 hd2
	sh $0 dz0 dl0 dhu0 rx0 rx1 raid0 raid1 raid2 raid3
	sh $0 ttyg0 ttyg1 ttyg2 ttyg3
	sh $0 crl std-extra systrace
	;;
d160 50
a209 4
floppy)
	sh $0 std random
	sh $0 sd0 sd1
	;;
d211 1
d213 2
a214 3
	sh $0 std random
	sh $0 rd0 sd0 sd1 sd2 ra0 ra1 ra2 rx0 cd0 st0
	sh $0 bpf0 ttyg0
d218 23
a240 43
	rm -f console drum
	rm -f kUmem kmem mem null zero tty klog
	rm -f stdin stdout stderr ksyms
	mknod console		c 0 0
	mknod drum		c 7 0	; chmod 640 drum ; chgrp kmem drum
	mknod kUmem		c 3 3	; chmod 600 kUmem
	mknod kmem		c 3 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 3 0	; chmod 640 mem ; chgrp kmem mem
	mknod null		c 3 2	; chmod 666 null
	mknod zero		c 3 12  ; chmod 666 zero
	mknod tty		c 2 0	; chmod 666 tty
	mknod klog		c 33 0	; chmod 600 klog
	mknod stdin		c 53 0	; chmod 666 stdin
	mknod stdout		c 53 1	; chmod 666 stdout
	mknod stderr		c 53 2	; chmod 666 stderr
	mknod ksyms		c 50 0	; chmod 640 ksyms ; chown root.kmem ksyms
	;;

std-extra)
	rm -f floppy csa1 csa2 tu0 tu1
	mknod floppy		c 8 0
	mknod csa1		c 51 0
	mknod csa2		c 51 1
	mknod tu0		b 8 0
	mknod tu1		b 8 1
	;;

crl)
	rm -f crl
	mknod crl		c 35 0
	;;

fd)
	rm -f fd/*
	mkdir fd > /dev/null 2>&1
	n=0
	while [ $n -lt 64 ]; do
		mknod fd/$n c 53 $n
		n=$(($n + 1))
	done
	chown -R root.wheel fd
	chmod 755 fd
	chmod 666 fd/*
d245 5
a249 5
	ht*) name=ht;	unit=${i#ht};	blk=1; chr=5 ;;
	mt*) name=mt;	unit=${i#mt};	blk=15;	chr=38;;
	tm*) name=tm;	unit=${i#tm};	blk=5; chr=14;;
	ts*) name=ts;	unit=${i#ts};	blk=6; chr=16;;
	ut*) name=ut;	unit=${i#ut};	blk=10; chr=17;;
d251 1
a251 1
	case $unit in
d253 17
a269 22
		four=$(($unit + 4)) ; eight=$(($unit + 8))
		twelve=$(($unit + 12)) ; twenty=$(($unit + 20))
		rm -f $name$unit $name$four $name$eight $name$twelve \
		    n$name$unit n$name$eight nr$name$unit nr$name$eight \
		    r$name$unit r$name$four r$name$eight r$name$twelve
		mknod $name$unit	b $blk $unit
		mknod $name$four	b $blk $four
		mknod $name$eight	b $blk $eight
		mknod $name$twelve	b $blk $twelve
		mknod n$name$unit	b $blk $four ;: sanity w/pdp11 v7
		mknod n$name$eight	b $blk $twelve ;: ditto
		mknod nr$name$unit	c $chr $four ;: sanity w/pdp11 v7
		mknod nr$name$eight	c $chr $twelve ;: ditto
		mknod r$name$unit	c $chr $unit
		mknod r$name$four	c $chr $four
		mknod r$name$eight	c $chr $eight
		mknod r$name$twelve	c $chr $twelve
		chown root.operator {,n,r,nr}$name{$unit,$eight}
		chown root.operator {,r}$name{$four,$twelve}
		chmod 660 {,n,r,nr}$name{$unit,$eight}
		chmod 660 {,r}$name{$four,$twelve}
		if [ $i = ut ]
d271 2
a272 23
			rm -f $name$twenty r$name$twenty
			mknod $name$twenty	b $blk $twenty
			mknod r$name$twenty	c $chr $twenty
			chown root.operator {,r}$name$twenty
			chmod 660 {,r}$name$twenty
		fi
		if [ ! -e rmt$eight ]	# compatibility stuff
		then
			rm -f mt$unit mt$four mt$eight mt$twelve \
			    nmt$unit nmt$eight nrmt$unit nrmt$eight \
			    rmt$unit rmt$four rmt$eight rmt$twelve
			ln -s $name$unit mt$unit
			ln -s $name$four mt$four
			ln -s $name$eight mt$eight
			ln -s $name$twelve mt$twelve
			ln -s n$name$unit nmt$unit
			ln -s n$name$eight nmt$eight
			ln -s nr$name$unit nrmt$unit
			ln -s nr$name$eight nrmt$eight
			ln -s r$name$unit rmt$unit
			ln -s r$name$four rmt$four
			ln -s r$name$eight rmt$eight
			ln -s r$name$twelve rmt$twelve
d276 1
a276 1
		echo bad unit for tape in: $1
d282 2
a283 22
st*)
	umask 2
	unit=${i#st};	blk=21; chr=60;
	case $unit in
	0|1|2|3|4|5|6|7)
		rm -f {e,}{n,}{r,}st${unit}
		mknod st${unit}		b $blk $(($unit * 16 + 0))
		mknod nst${unit}	b $blk $(($unit * 16 + 1))
		mknod est${unit}	b $blk $(($unit * 16 + 2))
		mknod enst${unit}	b $blk $(($unit * 16 + 3))
		mknod rst${unit}	c $chr $(($unit * 16 + 0))
		mknod nrst${unit}	c $chr $(($unit * 16 + 1))
		mknod erst${unit}	c $chr $(($unit * 16 + 2))
		mknod enrst${unit}	c $chr $(($unit * 16 + 3))
		chown root.operator {e,}{n,}{r,}st${unit}
		chmod 660 {e,}{n,}{r,}st${unit}
		;;
	*)
		echo bad tape unit: $i - $unit
		;;
	esac
	umask 77
d286 2
a287 35
mt*)
	umask 0 ; unit=`expr $i : '..\(.*\)'`
	case $i in
	mt*) blk=7; chr=19;;
	esac
	case $unit in
	0|1|2|3|4|5|6|7)
		eight=`expr $unit + 0`;
		twelve=`expr $unit + 4`;
		sixteen=`expr $unit + 8`;
		twenty=`expr $unit + 12`;
		rm -f mt8 mt12 mt16 mt20 nmt8 nrmt8 rmt8 rmt12 rmt16 rmt20
		rm -f nmt16 nrmt16
		mknod mt8		b $blk $eight
		mknod mt12		b $blk $twelve
		mknod mt16		b $blk $sixteen
		mknod mt20		b $blk $twenty
		mknod nmt8		b $blk $twelve ;: ditto
		mknod nrmt8		c $chr $twelve ;: ditto
		mknod rmt8		c $chr $eight
		mknod rmt12		c $chr $twelve
		mknod rmt16		c $chr $sixteen
		mknod rmt20		c $chr $twenty
		mknod nmt16		b $blk $twenty ;: ditto
		mknod nrmt16		c $chr $twenty ;: ditto
		chown root.operator {,n,r,nr}mt{8,16}
		chown root.operator {,r}mt{12,20}
		chmod 660 {,n,r,nr}mt{8,16}
		chmod 660 {,r}mt{12,20}
		;;
	*)
		echo bad unit for tape in: $1
		;;
	esac
	umask 77
d290 4
a293 9
random|srandom|urandom|prandom|arandom)
	rm -f random urandom srandom prandom arandom
	mknod  random c 67 0
	mknod srandom c 67 1
	mknod urandom c 67 2
	mknod prandom c 67 3
	mknod arandom c 67 4
	chown root.wheel random srandom urandom prandom arandom
	chmod 644 random srandom urandom prandom arandom
d296 2
a297 26
vnd*)
	umask 2
	unit=${i#vnd}
	if [ -z "$unit" -o 0$unit -gt 7 ]
	then
		echo bad disk unit: $i - $unit
		exit 127
	fi
	blk=18; chr=55;
	for name in vnd svnd; do
		case $name in
		vnd) off=0;;
		svnd) off=2048;;
		esac
		rm -f {r,}${name}${unit}[a-p]
		minor=$(($unit * 16 + $off))
		for slice in a b c d e f g h i j k l m n o p
		do
			mknod ${name}${unit}${slice}  b $blk $minor
			mknod r${name}${unit}${slice} c $chr $minor
			minor=$(($minor + 1))
		done
		chown root.operator {r,}${name}${unit}?
		chmod 640 {r,}${name}${unit}?
	done
	umask 77
d300 6
a305 14
hp*|hk*|up*|ra*|rl*|rb*|ccd*|hd*|sd*|rx*|raid*)
	umask 2
	case $i in
	hp*) name=hp;	unit=${i#hp};	blk=0; chr=4;;
	hk*) name=hk;	unit=${i#hk};	blk=3; chr=11;;
	up*) name=up;	unit=${i#up};	blk=2; chr=13;;
	raid*) name=raid; unit=${i#raid}; blk=25; chr=73;;
	ra*) name=ra;	unit=${i#ra};	blk=9;	chr=9;;
	rb*) name=rb;	unit=${i#rb};	blk=11; chr=23;;
	rx*) name=rx;	unit=${i#rx};	blk=12; chr=30;;
	rl*) name=rl;	unit=${i#rl};	blk=14; chr=32;;
	ccd*) name=ccd;	unit=${i#ccd};	blk=17; chr=54;;
	hd*) name=hd;	unit=${i#hd};	blk=19; chr=58;;
	sd*) name=sd;	unit=${i#sd};	blk=20; chr=59;;
d307 10
a316 18
	case $unit in
	[0-9]|[12][0-9]|3[01])
		minor=$(($unit * 16))
		rm -f {r,}${name}${unit}[a-p]
		for slice in a b c d e f g h i j k l m n o p
		do
			mknod ${name}${unit}${slice}  b $blk $minor
			mknod r${name}${unit}${slice} c $chr $minor
			minor=$(($minor + 1))
		done
		chgrp operator ${name}${unit}[a-p] r${name}${unit}[a-p]
		chmod 640 ${name}${unit}[a-p] r${name}${unit}[a-p]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
d319 7
a325 11
cd*)
	case $i in
	cd*) name=cd;   unit=${i#cd};   chr=61; blk=22;;
	esac
	rm -f {r,}${name}${unit}{a,c}
	mknod ${name}${unit}a   b $blk $(($unit * 16 + 0))
	mknod ${name}${unit}c   b $blk $(($unit * 16 + 2))
	mknod r${name}${unit}a  c $chr $(($unit * 16 + 0))
	mknod r${name}${unit}c  c $chr $(($unit * 16 + 2))
	chgrp operator {r,}${name}${unit}?
	chmod 640 {r,}${name}${unit}?
d328 2
a329 10
ss*)
	case $i in
	ss*) name=ss;   unit=${i#ss};   chr=64;;
	esac
	rm -f {,n,en}${name}${unit}
	mknod $name$unit	c $chr $(($unit * 16 + 0))
	mknod n$name$unit	c $chr $(($unit * 16 + 1))
	mknod en$name$unit	c $chr $(($unit * 16 + 3))
	chgrp operator {,n,en}${name}${unit}
	chmod 640 {,n,en}${name}${unit}
d332 2
a333 9
ch*|uk*)
	case $i in
	ch*) name=ch;   unit=${i#ch};   chr=63;;
	uk*) name=uk;   unit=${i#uk};   chr=65;;
	esac
	rm -f $name$unit
	mknod $name$unit        c $chr $unit
	chgrp operator $name$unit
	chmod 640 $name$unit
d336 2
a337 6
xfs*)
	unit=${i#xfs}
	rm -f xfs$unit
	mknod xfs$unit c 74 $unit 
	chmod 600 xfs$unit 
	chown root.wheel xfs$unit
d340 2
a341 24
rd*)
	unit=${i#rd}; blk=23; chr=62;
	rm -f rd${unit}{a,c} #rrd${unit}{a,c}
	mknod rd${unit}a  b $blk $(($unit * 16 + 0))
	mknod rd${unit}c  b $blk $(($unit * 16 + 2))
#	mknod rrd${unit}a c $chr $(($unit * 16 + 0))
#	mknod rrd${unit}c c $chr $(($unit * 16 + 2))
	chgrp operator rd${unit}? #rrd${unit}?
	chmod 640 rd${unit}? #rrd${unit}?
	;;

uu*)
	unit=${i#uu}
	name=uu; blk=13;
	case $unit in
	[0-3])
		rm -f ${name}${unit}{,a}
		mknod ${name}${unit}	b $blk $(($unit * 2 + 0))
		mknod ${name}${unit}a	b $blk $(($unit * 2 + 1))
		;;
	*)
		echo bad unit for uu cassette in: $i
		;;
	esac
d344 2
a345 11
ttyg*)
	unit=${i#ttyg};
	case $unit in
	[0-3])
		rm -f ttyg${unit}
		mknod ttyg$unit	c 25 $unit
		;;
	*)
		echo bad unit for ttyg: $i
		;;
	esac
d349 12
a360 14
	unit=${i#dz};
	case $unit in
	[0-7])
		i=0
		while [ $i -lt 8 ]; do
			no=$(($unit * 8 + $i))
			if [ $no -lt 10 ]; then
				no="0${no}"
			fi
			rm -f tty${no}
			mknod tty${no} c 1 $no
			i=$(($i + 1))
		done
		;;
d362 3
a364 3
		echo bad unit for dz in: $i
		;;
	esac
d367 2
a368 1
dhu*|dh*|dmf*|dmz*|vt*)
d370 2
a371 3
	vt*)	name=vt; major=68; count=8;
		unit=${i#vt}
		case $unit in
d375 2
a376 3
	dmz*)	name=dmz; major=37; count=24;
		unit=${i#dmz}
		case $unit in
d380 2
a381 3
	dmf*)	name=dmf; major=22; count=8;
		unit=${i#dmf}
		case $unit in
d386 2
a387 3
	dhu*)	name=dhu; major=34; count=16;
		unit=${i#dhu}
		case $unit in
d392 2
a393 3
	dh*)	name=dh; major=12; count=16;
		unit=${i#dh}
		case $unit in
d403 1
a403 2
			rm -f tty${ch}${let}
			mknod tty${ch}${let} c $major $(($unit * $count + $i))
d405 1
a405 1
			echo bad count for ${name}: $unit, $count, $i
d407 1
a407 1
		i=$(($i + 1))
a408 1

a411 1
	unit=${i#dl}
d413 1
a413 1
	let=${cnvtbl[$unit]}
d415 1
a415 2
		rm -f ttyJ${let}
		mknod ttyJ${let} c $major $unit
d417 1
a417 1
		echo bad number for ${name}: $unit
a420 18
lp*|va*|vp*)
	case $i in
	lp*) name=lp; unit=${i#lp}; major=15;;
	va*) name=va; unit=${i#va}; major=10;;
	vp*) name=vp; unit=${i#vp}; major=6;;
	esac
	case $unit in
	[0-7])
		rm -f $i
		mknod $i c $major $unit;
		chmod 666 $i
		;;
	*)
		echo bad unit for $name in: $i
		;;
	esac
	;;

d422 8
a429 25
	class=${i#pty};
	case $class in
	0)	name=p;;
	1)	name=q;;
	2)	name=r;;
	3)	name=s;;
	4)	name=t;;
	5)	name=u;;
	6)	name=v
		echo "$0: $i: pty unit conflicts with another use."
		continue;;
	7)	name=w;;
	8)	name=x;;
	9)	name=y;;
	10)	name=z;;
	11)	name=P;;
	12)	name=Q;;
	13)	name=R;;
	14)	name=S;;
	15)	name=T;;
	*)	echo "$0: $i: pty unit must be between 0 and 15"
	        continue ;;
	esac
	rm -f tty$name[0-9a-f] pty$name[0-9a-f]
	for j in 0 1 2 3 4 5 6 7 8 9 a b c d e f
d431 5
a435 12
		case $j in
		[0-9])	jn=$j ;;
		a)	jn=10 ;;
		b)	jn=11 ;;
		c)	jn=12 ;;
		d)	jn=13 ;;
		e)	jn=14 ;;
		f)	jn=15 ;;
		esac
		unit=$(($class * 16 + $jn))
		mknod tty$name$j c 20 $unit
		mknod pty$name$j c 21 $unit
a436 2
	chgrp wheel tty$name? pty$name?
	chmod 666 tty$name? pty$name?
d439 31
a469 21
np*)
	class=${i#np}
	case $class in
	0)	offset=0  name=0;;
	1)	offset=16 name=1;;
	2)	offset=32 name=2;;
	*)	echo bad unit for np in: $i;;
	esac
	case $class in
	0|1|2)
	i=0
	while [ $i -lt 4 ]; do
		no=$(($offset + $i))
		if [ $no -lt 10 ]; then
			no="0${no}"
		fi
		rm -f np${no}
		mknod np${no} c 39 $no
		i=$(($i + 1))
	done
	esac
d472 2
a473 19
dn*|ik*|ps*|ad*|ct*)
	case $i in
	ct*) name=ct; unit=${i#ct}; chr=18;;
	dn*) name=cu; unit=${i#dn}; chr=24;;
	ps*) name=ps; unit=${i#ps}; chr=27;;
	ad*) name=ad; unit=${i#ad}; chr=29;;
	ik*) name=ik; unit=${i#ik}; chr=31;;
	esac
	case $unit in
	[0-7])
		umask 0
		rm -f ${name}${unit}
		mknod ${name}${unit} c ${chr} ${unit}
		umask 77
		;;
	*)
		echo bad unit for ${name} in: $i
		;;
	esac
d476 2
a477 20
bpf*)
	unit=${i#bpf};
	rm -f bpf$unit
	mknod bpf$unit c 56 $unit
	chmod 600 bpf$unit
	chown root.wheel bpf$unit
	;;

qd*)
	unit=${i#qd}
	rm -f q{c,d}$unit
	mknod qc$unit c 40 $(($unit * 4))
	mknod qd$unit c 40 $(($unit * 4 + 2))
	;;

pf)
	rm -f pf
	mknod pf c 42 0
	chown root.wheel pf
	chmod 600 pf
d480 6
a485 6
tun*)
	unit=${i#tun}
	rm -f tun$unit
	mknod tun$unit c 57 $unit
	chmod 600 tun$unit
	chown root.wheel tun$unit
d488 2
a489 5
lkm)
	rm -f lkm
	mknod lkm c 28 0
	chown root._lkm lkm
	chmod 640 lkm
d492 2
a493 5
qv0)
	rm -f qv0 qvcons mouse
	mknod qv0 c 40 0
	mknod qvcons c 40 1
	mknod mouse c 40 2
d496 8
a503 5
systrace)
	rm -f systrace
	mknod systrace c 49 0
	chown root.wheel systrace
	chmod 644 systrace
d507 25
a531 3
	umask 0
	sh $0.local all
	umask 77
d533 1
d535 1
a535 1
	echo $i: invalid device
a536 1

d539 31
@


1.51
log
@some spelling corrections from NetBSD (Igor Sobrado);

ok hugh@@
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.50 2003/01/06 05:57:40 deraadt Exp $
d289 1
a289 1
		svnd) off=128;;
@


1.50
log
@sync
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.49 2002/12/05 03:00:27 kjc Exp $
d13 2
a14 2
#	ht*	massbus tm03 & tu??
#	tm*	unibus tm11 & te10 emulations (e.g. Emulex tc-11)
d16 3
a18 3
#	ts*	unibus ts11
#	ut*	unibus tu45 emulations (e.g.si 9700)
#	uu*	tu58 cassettes on dl11 controller
d21 3
a23 3
#	hp*	massbus rm??
#	hk*	unibus rk06 and rk07
#	up*	other unibus devices (e.g. on Emulex sc-21v controller)
d25 3
a27 3
#	rx*	MSCP floppy disk (rx33/50/...)
#	rl*	unibus rl02
#	rb*	730 idc w/ rb80 and/or rb02
d36 6
a41 6
#	dz*	unibus dz11 and dz32
#	dh*	unibus dh11 and emulations (e.g. Able dmax, Emulex cs-11)
#	dmf*	unibus dmf32
#	dhu*    unibus dhu11
#	dmz*    unibus dmz32
#	dl*	unibus dl11
d45 4
a48 4
#	ct*	unibus parallel interface to CAT typesetter
#	lp*	unibus lp11 parallel interface
#	va*	unibus varian parallel interface
#	vp*	unibus versatec parallel interface
d50 1
a50 1
#	dn*	unibus dn11 and emulations (e.g. Able Quadracall)
d52 5
a56 5
#	ik*	unibus interface to ikonas frame buffer
#	ps*	unibus interface to e&s picture system 2
#	ad*	unibus interface to data translation a/d converter
#	np*	unibus ethernet co-processor interface, for downloading.
#	qv*	qvss (microvax) display
@


1.49
log
@remove altq entries. altq is now handled through pf.
ok, deraadt@@
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.48 2002/06/24 10:43:31 hugh Exp $
d645 1
a645 1
	chown root.kmem lkm
@


1.48
log
@Add xfs device; seems to work.
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.47 2002/06/09 05:58:39 todd Exp $
a63 1
#	altq	ALTQ control interface
d74 1
a74 1
	sh $0 std fd vnd0 ccd0 pty0 pty1 lkm random altq
a653 13
	;;

altq)
	mkdir -p altq
	chmod 755 altq
	unit=0
	for dev in altq cbq wfq afm fifoq red rio localq hfsc \
	    cdnr blue priq; do
		rm -f altq/$dev
		mknod altq/$dev c 75 $unit
		chmod 644 altq/$dev
		unit=$(($unit + 1))
	done
@


1.47
log
@sync
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.46 2002/05/16 21:14:49 miod Exp $
d375 8
@


1.46
log
@Add systrace devices until vax is converted to new MAKEDEV scheme (soon)
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.45 2002/04/04 19:57:48 deraadt Exp $
d172 1
a172 1
		if [ $i = ut ] 
d238 1
a238 1
		twelve=`expr $unit + 4`; 
d380 4
a383 4
	mknod rd${unit}a  b $blk $(($unit * 16 + 0)) 
	mknod rd${unit}c  b $blk $(($unit * 16 + 2)) 
#	mknod rrd${unit}a c $chr $(($unit * 16 + 0)) 
#	mknod rrd${unit}c c $chr $(($unit * 16 + 2)) 
@


1.45
log
@shrink things in ramdisk; hugh ok
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.44 2002/02/21 18:34:11 deraadt Exp $
d65 1
d81 1
a81 1
	sh $0 crl std-extra
d660 7
@


1.44
log
@Remove uncommited garbage.  I am sorry, but this was just not tested. It
crashes sh, EVEN after that possible fix.  It appears to overflow the
ramdisk _before_ it dumps core.  Noone was shown these changes.  They were
just tossed in.  This is not a development process that will work, so I
am just backing out all the changes in the last 24 hours.
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.41 2002/02/14 22:53:11 hugh Exp $
a56 1
#	ttyv0	qvss (microvax) display reserved pty
d79 2
d90 2
a91 2
	sh $0 rd0 sd0 sd1 sd2 sd3 ra0 ra1 ra2 rx0 cd0 st0 st1
	sh $0 bpf0
d95 2
a96 2
	rm -f console drum floppy crl csa1 csa2 tu0 tu1
	rm -f kUmem kmem mem null zero tty klog ttyg[0-3]
a98 4
	mknod ttyg0		c 25 0
	mknod ttyg1		c 25 1
	mknod ttyg2		c 25 2
	mknod ttyg3		c 25 3
a99 6
	mknod floppy		c 8 0
	mknod crl		c 35 0
	mknod csa1		c 51 0
	mknod csa2		c 51 1
	mknod tu0		b 8 0
	mknod tu1		b 8 1
d113 14
d402 13
a645 6
	;;

ttyv0)
	if [ ! -f ttyqe ]; then sh ./$0 pty1; fi
	mv ttyqf ttyv0
	mv ptyqf ptyv0
@


1.43
log
@sync
@
text
@d3 2
a4 2
# THIS FILE AUTOMATICALLY GENERATED.  DO NOT EDIT.
# generated from:
d6 1
a6 3
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.8 2002/02/21 13:17:30 todd Exp 
#	OpenBSD: MAKEDEV.mi,v 1.38 2002/02/21 13:41:55 todd Exp 
#	OpenBSD: MAKEDEV.sub,v 1.7 2002/02/16 01:19:52 deraadt Exp 
a7 26
#	$OpenBSD$
#
# Copyright (c) 2001,2002 Todd T. Fries <todd@@OpenBSD.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
# THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#


a8 2
#	all	makes all known devices, including local devices.
#		Tries to make the ``standard'' number of each type.
d11 1
a12 2
#	st*	SCSI tapes
#	mt*	(Magnetic) 9-track reel tape
d15 1
d18 2
d21 1
a21 1
#	hp*	massbuss rm??
d25 2
d28 4
a31 3
#	rx*	MSCP floppy disk (rx33/50/...)
#	rl*	unibus r102
#	hd*	HP300 HP-IB disks
d33 4
a36 14
#	cd*	SCSI cdrom drives
#	ch*	SCSI media changer
#	ss*	SCSI scanners
#	uk*	SCSI Unknown device
#	rd*	"rd" pseudo-disks
#	fd*	Floppy disk drives (3 1/2", 5 1/4")
#	vnd*	"file" pseudo-disks
#	ccd*	concatenated disk devices
# Pseudo terminals:
#	tty*	set of 16 slave psuedo terminals
#	pty*	set of 16 master pseudo terminals
# Printers:
# Terminal ports:
#	dhu*	unibus dhu11
d39 2
a40 3
#	dmz*	unibus dmz32
#	vt*	console
#	dz*	unibus dz11 and dz32
d42 9
d52 15
a66 12
#	openprom	
#	bpf*	Berkeley Packet Filter
#	pf*	Packet Filter
#	altq/	ALTQ control interface
#	lkm	loadable kernel modules interface
#	tun*	network tunnel driver
#	*random	inkernel random data source
#	magma*	magma card (makes 16 tty and 2 bpp)
#	xfs*	XFS filesystem devices
#	raid*	RAIDframe disk devices
#	fd	makes fd/* for the fdescfs
#	ses*	SES/SAF-TE SCSI devices
d68 5
a72 1
T=$0
d74 7
a80 2
# set this to echo for Echo-Only debugging
[ "$eo" ] || eo=
d82 4
a85 55
hex()
{
	case $1 in
	[0-9]) echo -n $1;;
	10) echo -n a;;
	11) echo -n b;;
	12) echo -n c;;
	13) echo -n d;;
	14) echo -n e;;
	15) echo -n f;;
	esac
}

trunc()
{
	# XXX pdksh can't seem to deal with locally scoped variables
	# in ${foo#$bar} expansions
	arg1="$1"
	arg2="$2"
	case $3 in
	l)   echo ${arg2#$arg1} ;;
	r|*) echo ${arg1#$arg2} ;;
	esac
}

unt()
{
	# XXX pdksh can't seem to deal with locally scoped variables
	# in ${foo#$bar} expansions
	arg="$1"
	tmp="${arg#[a-zA-Z]*}"
	tmp="${tmp%*[a-zA-Z]}"
	while [ "$tmp" != "$arg" ]
	do
		arg=$tmp
		tmp="${arg#[a-zA-Z]*}"
		tmp="${tmp%*[a-zA-Z]}"
	done
	echo $arg
}

dodisk()
{
	[ "$DEBUG" ] && set -x
	n=$(($((${5}*${7:-16}))+${6})) count=0
	RMlist="$RMlist $1$2? r$1$2?"
	[ 0$7 -ne 8 ] && l="i j k l m n o p"
	for d in a b c d e f g h $l
	do
		M $1$2$d	b $3 $(($n+$count)) 640
		M r$1$2$d	c $4 $(($n+$count)) 640
		let count=count+1
	done
	MKlist="$MKlist;chown root.operator $1$2? r$1$2?"
}
a86 52
dodisk2()
{
	n=$(($(($5*${7:-16}))+$6))
	M $1$2a b $3 $n 640 operator
	M r$1$2a c $4 $n 640 operator
	n=$(($n+2))
	M $1$2c b $3 $n 640 operator
	M r$1$2c c $4 $n 640 operator
}

# M name b/c major minor [mode] [group]
RMlist="rm -f"
MKlist=":"

mkl() {
	[ "${mklist[$1]}" ] && {
		mklist[$1]="${mklist[$1]};mknod -m $1 $2 $3 $4 $5"
	} || {
		mklist[$1]="mknod -m $1 $2 $3 $4 $5"
		modes="$modes $1"
	}
}

M() {
	RMlist="$RMlist $1"
	mkl ${5-666} $1 $2 $3 $4
	mklist="$mklist $1"
	G=${6:-wheel}
	[ "$7" ] && {
		MKlist="$MKlist;chown $7.$G $1"
	} || {
		case $G in
		wheel)g=0;;kmem)g=2;;operator)g=5;;tty)g=4;;dialer)g=117;;
		esac
		[ "${grplist[$g]}" ] && {
			grplist[$g]="${grplist[$g]} $1"
		} || {
			groups="$groups $g"
			grplist[$g]="chgrp $G $1"
		}
	}
	return 0
}

R() {
[ "$DEBUG" ] && set -x
for i in "$@@"
do
U=`unt $i`
[ "$U" ] || U=0

case $i in
d88 3
a90 2
	R std random st0 st1 rx0 bpf0 rd0
	R sd0 sd1 sd2 sd3 cd0 ra0 ra1 ra2
d94 39
a132 23
	M console	c 0 0 600
	M tty		c 2 0
	M mem		c 3 0 640 kmem
	M kmem		c 3 1 640 kmem
	M null		c 3 2
	M zero		c 3 12
	M stdin		c 53 0
	M stdout	c 53 1
	M stderr	c 53 2
	M ksyms		c 50 0 640 kmem
	M drum		c 7 0 640 kmem
	M klog		c 33 0 600
	M ttyg0		c 25 0 600
	M ttyg1		c 25 1 600
	M ttyg2		c 25 2 600
	M ttyg3		c 25 3 600
	M crl		c 35 0 600
	M csa1		c 51 0 600
	M csa2		c 51 1 600
	M tu0		b 8 0 600
	M tu1		b 8 1 600
	M floppy	c 8 0 600
	M kUmem		c 3 3 600
d137 5
a141 5
	ht*) n=ht b=1 c=5;;
	mt*) n=mt b=15 c=38;;
	tm*) n=tm b=5 c=14;;
	ts*) n=ts b=6 c=16;;
	ut*) n=ut b=10 c=17;;
d143 1
a143 1
	case $U in
d145 22
a166 17
		four=$(($U+4))
		eight=$(($U+8))
		twelve=$(($U+12))
		twenty=$(($U+20))
		M $n$U		b $b $U	660 operator
		M $n$four	b $b $four	660 operator
		M $n$eight	b $b $eight	660 operator
		M $n$twelve	b $b $twelve	660 operator
		M n$n$U		b $b $four	660 operator;: sanity w/pdp11 v7
		M n$n$eight	b $b $twelve	660 operator;: ditto
		M nr$n$U	c $c $four	660 operator;: ditto
		M nr$n$eight	c $c $twelve	660 operator;: ditto
		M r$n$U		c $c $U		660 operator
		M r$n$four	c $c $four	660 operator
		M r$n$eight	c $c $eight	660 operator
		M r$n$twelve	c $c $twelve	660 operator
		if [ "$i" = "ut" ];
d168 23
a190 2
			M $n$twenty	b $b $twenty 660 operator
			M r$n$twenty	c $b $twenty 660 operator
d194 1
a194 1
		echo bad unit for tape in: $i
d200 22
a221 2
ses*)
	M ses$U c 124 $U 640 operator
d224 35
a258 4
fd)
	RMlist="mkdir -p fd;$RMlist" n=0
	while [ $n -lt 64 ];do M fd/$n c 53 $n;n=$(($n+1));done
	MKlist="$MKlist;chmod 555 fd"
d261 9
a269 2
xfs*)
	M xfs$U c 51 $U 600
d272 24
a295 14
magma*)
	case $U in
	0)	offset=0  nam=m;;
	1)	offset=16 nam=n;;
	2)	offset=32 nam=o;;
	*)	echo "bad unit for $i: $U"; exit 127;;
	esac
	offset=$(($U*64))
	n=0
	while [ $n -lt 16 ]
	do
		name=${nam}`hex $n`
		M tty$name c major_mag_c $(($offset+$n)) 660 dialer uucp
		n=$(($n+1))
d297 1
a297 2
	M bpp${nam}0 c major_bppmag_c $(($offset+0)) 600
	M bpp${nam}1 c major_bppmag_c $(($offset+1)) 600
d300 33
a332 7
*random)
	n=0
	for pre in " " s u p a
	do
		M ${pre}random c 67 $n 644
		n=$(($n+1))
	done
d335 11
a345 2
tun*)
	M tun$U c 57 $U 600
d348 10
a357 2
lkm)
	M lkm c 28 0 640 kmem
d360 9
a368 6
altq)
	RMlist="mkdir -p altq;$RMlist"
	for d in altq cbq wfq afm fifoq red rio localq hfsc cdnr blue priq; do
		M altq/$d c 75 $U 644
		U=$(($U+1))
	done
d371 24
a394 10
pf*)
	M pf c 42 0 600
	;;

bpf*)
	M bpf$U c 56 $U 600
	;;

openprom)
	M openprom c 70 0  
d398 14
a411 12
	case $U in
       [0-7])
	       i=0
	       while [ $i -lt 8 ]; do
		       no=$(($(($U*8))+$i))
		       if [ $no -lt 10 ]; then
			       no="0${no}"
		       fi
		       M tty${no} c 1 $no 600
		       let i=i+1
	       done
	       ;;
d413 3
a415 3
	       echo bad unit for dz in: $i
	       ;;
       esac
d418 1
a418 2
dhu*|dmz*|dmf*|dh*|vt*)
	set -A cnvtbl 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v
d420 3
a422 2
	vt*)    name=vt; major=68; count=8;
		case $U in
d426 3
a428 2
	dmz*)   name=dmz; major=37; count=24;
		case $U in
d432 3
a434 2
	dmf*)   name=dmf; major=22; count=8;
		case $U in
d439 3
a441 2
	dhu*)   name=dhu; major=34; count=16;
		case $U in
d446 3
a448 2
	dh*)    name=dh; major=12; count=16;
		case $U in
d458 2
a459 1
			M tty${ch}${let} c $major $(($(($U*$count))+$i)) 600
d461 1
a461 1
			echo bad count for ${name}: $U, $count, $i
d463 1
a463 1
		let i=i+1
d465 1
d469 1
d471 1
a471 1
	let=${cnvtbl[$U]}
d473 2
a474 1
		M ttyJ${let} c $major $U 600
d476 1
a476 1
		echo bad number for ${name}: $U
d480 18
d499 25
a523 8
	if [ $U -gt 15 ]; then
		echo bad unit for pty in: $i
		continue
	fi
	set -A tbl p q r s t u v w x y z P Q R S T
	name=${tbl[$U]}
	n=0
	while [ $n -lt 16 ]
d525 12
a536 5
		nam=$name$(hex $n)
		off=$(($U*16))
		M tty$nam c 20 $(($off+$n))
		M pty$nam c 21 $(($off+$n))
		n=$(($n+1))
d538 2
d542 21
a562 3
vnd*)
	dodisk vnd $U 18 55 $U 0
	dodisk svnd $U 18 55 $U 128
d565 19
a583 26
fd*)
	typnam=$U${i#fd[01]*}
	case $typnam in
	0|1)	typnum=0;; # no type specified, assume A
	*A)	typnum=0; typnam=0;;
	*B)	typnum=1;;
	*C)	typnum=2;;
	*D)	typnum=3;;
	*E)	typnum=4;;
	*F)	typnum=5;;
	*G)	typnum=6;;
	*H)	typnum=7;;
	*)	echo bad type $typnam for $i; exit 1;;
	esac
	case $U in
	0|1)	blk=16; chr=54;;
	*)	echo bad unit $U for $i; exit 1;;
	esac
	nam=fd${typnam}
	n=$(($(($U*128))+$(($typnum*16))))
	M ${nam}a	b $blk $n 640 operator
	M ${nam}b	b $blk $(($n+1)) 640 operator
	M ${nam}c	b $blk $(($n+2)) 640 operator
	M r${nam}a	c $chr $n 640 operator
	M r${nam}b	c $chr $(($n+1)) 640 operator
	M r${nam}c	c $chr $(($n+2)) 640 operator
d586 20
a605 2
rd*)
	dodisk2 rd $U 23 62 $U 0
d608 6
a613 2
uk*)
	M uk$U c 65 $U 640 operator
d616 18
a633 6
ss*)
	M ss$U c 64 $(($U*16)) 640 operator
	M nss$U c 64 $(($(($U*16))+1)) 640 operator
	M enss$U c 64 $(($(($U*16))+3)) 640 operator
	RMlist="$RMlist scan$U"
	MKlist="$MKlist;umask 77;ln -s ss$U scan$U"
d636 10
a645 15
ch*)
	M ch$U c 63 $U 660 operator
	;;

cd*)
	dodisk2 cd $U 22 61 $U 0
	;;

st*)
	n=$(($U*16))
	for pre in " " n e en
	do
		M ${pre}st$U	b 21 $n 660 operator
		M ${pre}rst$U	c 60 $n 660 operator
		n=$(($n+1))
d650 3
a652 1
	test -s $T.local && sh $T.local
d654 2
a655 7

all)
	R vt0 dl0 dz0 dhu0 ts0 ts1 mt0 mt1 hd0 hd1 hd2 ccd0 vnd0 sd0
	R sd1 sd2 sd3 cd0 tun0 tun1 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6
	R bpf7 pty0 pty1 ss0 uk0 random lkm pf altq rx0 rx1 ra0 ra1
	R ra2 ra3 hp0 hp1 hp2 hp3 raid0 raid1 raid2 raid3 std st0 st1
	R fd
a657 19
up*|sd*|rx*|rl*|rb*|raid*|ra*|hp*|hk*|hd*|ccd*)
	case $i in
	up*) dodisk up $U 2 13 $U 0;;
	sd*) dodisk sd $U 20 59 $U 0;;
	rx*) dodisk rx $U 12 30 $U 0;;
	rl*) dodisk rl $U 14 32 $U 0;;
	rb*) dodisk rb $U 11 23 $U 0;;
	raid*) dodisk raid $U 25 73 $U 0;;
	ra*) dodisk ra $U 9 9 $U 0;;
	hp*) dodisk hp $U 0 4 $U 0;;
	hk*) dodisk hk $U 3 11 $U 0;;
	hd*) dodisk hd $U 19 58 $U 0;;
	ccd*) dodisk ccd $U 17 54 $U 0;;
	esac
	;;

*)
	echo $i: unknown device
	;;
a659 31
}
R "$@@"
if [ "$os" = "SunOS" ]; then
	eo=transform
	transform() {
		case $mode in
		600) mask=077;;
		640) mask=027;;
		660) mask=007;;
		644) mask=022;;
		666) mask=0;;
		440) mask=227;;
		esac
		echo `echo "$@@"|sed \
		    's/mknod -m \([0-9]*\) /umask '$mask';mknod /;s/-m [0-9]* //g;\
		    s/operator/5/g;s/root.kmem/root.2/g;s/root\./root:/g'`
	}
fi
list="$RMlist"
for mode in $modes; do
	list="$list;${mklist[$mode]}"
done
for group in $groups; do
	list="$list;${grplist[$group]}"
done
list="$list;$MKlist"
if [ "$eo" = "echo" -o "$eo" = "transform" ]; then
	$eo "$list"
else
	echo "$list" | sh
fi
@


1.42
log
@sync
@
text
@d7 1
a7 1
#	OpenBSD: MAKEDEV.mi,v 1.37 2002/02/21 13:03:00 todd Exp 
d510 1
a510 1
	R bpf7 pty0 pty1 ss0 uk0 rndrandom lkm pf altq rx0 rx1 ra0 ra1
@


1.41
log
@M4 generated MAKEDEV still premature.
@
text
@d3 2
a4 2
#	$OpenBSD: MAKEDEV,v 1.37 2002/02/14 04:58:36 todd Exp $
#	$NetBSD: MAKEDEV,v 1.30 2000/01/21 12:28:29 tsutsui Exp $
d6 3
a8 1
#	@@(#)MAKEDEV	8.1 (Berkeley) 6/9/93
d10 26
d37 2
a40 1
#	all	create a reasonable amount of all files
d42 2
a45 1
#	mt*	MSCP tapes (e.g. TU81, TK50)
a47 2
#	uu*	tu58 cassettes on dl11 controller
#	st*	SCSI tapes
d49 1
a49 1
#	hp*	massbus rm??
d53 1
d55 9
a63 4
#	rl*	unibus rl02
#	rb*	730 idc w/ rb80 and/or rb02
#	ccd*	"concatenated" pseudo-disks
#	raid*	RAIDframe disk driver
d65 7
a71 6
#	rd*	memory pseudo-disk devices
#	sd*	SCSI disks
#	cd*	SCSI CD-ROM
#	hd*	HDC9224 hd disks on VS2000
# Terminal multiplexors:
#	dz*	unibus dz11 and dz32
d74 3
a76 2
#	dhu*    unibus dhu11
#	dmz*    unibus dmz32
a77 9
# Pseudo terminals:
#	pty*	set of 16 master and slave pseudo terminals
# Printers:
#	ct*	unibus parallel interface to CAT typesetter
#	lp*	unibus lp11 parallel interface
#	va*	unibus varian parallel interface
#	vp*	unibus versatec parallel interface
# Call units:
#	dn*	unibus dn11 and emulations (e.g. Able Quadracall)
d79 12
a90 15
#	ik*	unibus interface to ikonas frame buffer
#	ps*	unibus interface to e&s picture system 2
#	ad*	unibus interface to data translation a/d converter
#	np*	unibus ethernet co-processor interface, for downloading.
#	qv*	qvss (microvax) display
#	ttyv0	qvss (microvax) display reserved pty
#	lkm	loadable kernel modules
#	bpf*	berkeley packet filter
#	tun*	network tunnel device
#	ss*	SCSI scanner
#	uk*	SCSI unknown
#	ch*	SCSI changer
#	*random	Random number generator
#	altq	ALTQ control interface
#
d92 45
a136 5
set -A cnvtbl 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v
umask 77
for i
do
case $i in
d138 14
a151 7
all)
	sh $0 std fd vnd0 ccd0 pty0 pty1 lkm random altq
	sh $0 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7 pf tun0 tun1
	sh $0 mt0 mt1 ts0 ts1 st0 st1 uk0 ss0 cd0 vt0
	sh $0 ra0 ra1 ra2 ra3 hp0 hp1 hp2 hp3 sd0 sd1 sd2 sd3 hd0 hd1 hd2
	sh $0 dz0 dl0 dhu0 rx0 rx1 raid0 raid1 raid2 raid3
	;;
d153 50
a202 4
floppy)
	sh $0 std random
	sh $0 sd0 sd1
	;;
d204 1
d206 2
a207 3
	sh $0 std random
	sh $0 rd0 sd0 sd1 sd2 sd3 ra0 ra1 ra2 rx0 cd0 st0 st1
	sh $0 bpf0
d211 23
a233 39
	rm -f console drum floppy crl csa1 csa2 tu0 tu1
	rm -f kUmem kmem mem null zero tty klog ttyg[0-3]
	rm -f stdin stdout stderr ksyms
	mknod console		c 0 0
	mknod ttyg0		c 25 0
	mknod ttyg1		c 25 1
	mknod ttyg2		c 25 2
	mknod ttyg3		c 25 3
	mknod drum		c 7 0	; chmod 640 drum ; chgrp kmem drum
	mknod floppy		c 8 0
	mknod crl		c 35 0
	mknod csa1		c 51 0
	mknod csa2		c 51 1
	mknod tu0		b 8 0
	mknod tu1		b 8 1
	mknod kUmem		c 3 3	; chmod 600 kUmem
	mknod kmem		c 3 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 3 0	; chmod 640 mem ; chgrp kmem mem
	mknod null		c 3 2	; chmod 666 null
	mknod zero		c 3 12  ; chmod 666 zero
	mknod tty		c 2 0	; chmod 666 tty
	mknod klog		c 33 0	; chmod 600 klog
	mknod stdin		c 53 0	; chmod 666 stdin
	mknod stdout		c 53 1	; chmod 666 stdout
	mknod stderr		c 53 2	; chmod 666 stderr
	mknod ksyms		c 50 0	; chmod 640 ksyms ; chown root.kmem ksyms
	;;

fd)
	rm -f fd/*
	mkdir fd > /dev/null 2>&1
	n=0
	while [ $n -lt 64 ]; do
		mknod fd/$n c 53 $n
		n=$(($n + 1))
	done
	chown -R root.wheel fd
	chmod 755 fd
	chmod 666 fd/*
d238 5
a242 5
	ht*) name=ht;	unit=${i#ht};	blk=1; chr=5 ;;
	mt*) name=mt;	unit=${i#mt};	blk=15;	chr=38;;
	tm*) name=tm;	unit=${i#tm};	blk=5; chr=14;;
	ts*) name=ts;	unit=${i#ts};	blk=6; chr=16;;
	ut*) name=ut;	unit=${i#ut};	blk=10; chr=17;;
d244 1
a244 1
	case $unit in
d246 17
a262 22
		four=$(($unit + 4)) ; eight=$(($unit + 8))
		twelve=$(($unit + 12)) ; twenty=$(($unit + 20))
		rm -f $name$unit $name$four $name$eight $name$twelve \
		    n$name$unit n$name$eight nr$name$unit nr$name$eight \
		    r$name$unit r$name$four r$name$eight r$name$twelve
		mknod $name$unit	b $blk $unit
		mknod $name$four	b $blk $four
		mknod $name$eight	b $blk $eight
		mknod $name$twelve	b $blk $twelve
		mknod n$name$unit	b $blk $four ;: sanity w/pdp11 v7
		mknod n$name$eight	b $blk $twelve ;: ditto
		mknod nr$name$unit	c $chr $four ;: sanity w/pdp11 v7
		mknod nr$name$eight	c $chr $twelve ;: ditto
		mknod r$name$unit	c $chr $unit
		mknod r$name$four	c $chr $four
		mknod r$name$eight	c $chr $eight
		mknod r$name$twelve	c $chr $twelve
		chown root.operator {,n,r,nr}$name{$unit,$eight}
		chown root.operator {,r}$name{$four,$twelve}
		chmod 660 {,n,r,nr}$name{$unit,$eight}
		chmod 660 {,r}$name{$four,$twelve}
		if [ $i = ut ] 
d264 2
a265 23
			rm -f $name$twenty r$name$twenty
			mknod $name$twenty	b $blk $twenty
			mknod r$name$twenty	c $chr $twenty
			chown root.operator {,r}$name$twenty
			chmod 660 {,r}$name$twenty
		fi
		if [ ! -e rmt$eight ]	# compatibility stuff
		then
			rm -f mt$unit mt$four mt$eight mt$twelve \
			    nmt$unit nmt$eight nrmt$unit nrmt$eight \
			    rmt$unit rmt$four rmt$eight rmt$twelve
			ln -s $name$unit mt$unit
			ln -s $name$four mt$four
			ln -s $name$eight mt$eight
			ln -s $name$twelve mt$twelve
			ln -s n$name$unit nmt$unit
			ln -s n$name$eight nmt$eight
			ln -s nr$name$unit nrmt$unit
			ln -s nr$name$eight nrmt$eight
			ln -s r$name$unit rmt$unit
			ln -s r$name$four rmt$four
			ln -s r$name$eight rmt$eight
			ln -s r$name$twelve rmt$twelve
d269 1
a269 1
		echo bad unit for tape in: $1
d275 12
a286 22
st*)
	umask 2
	unit=${i#st};	blk=21; chr=60;
	case $unit in
	0|1|2|3|4|5|6|7)
		rm -f {e,}{n,}{r,}st${unit}
		mknod st${unit}		b $blk $(($unit * 16 + 0))
		mknod nst${unit}	b $blk $(($unit * 16 + 1))
		mknod est${unit}	b $blk $(($unit * 16 + 2))
		mknod enst${unit}	b $blk $(($unit * 16 + 3))
		mknod rst${unit}	c $chr $(($unit * 16 + 0))
		mknod nrst${unit}	c $chr $(($unit * 16 + 1))
		mknod erst${unit}	c $chr $(($unit * 16 + 2))
		mknod enrst${unit}	c $chr $(($unit * 16 + 3))
		chown root.operator {e,}{n,}{r,}st${unit}
		chmod 660 {e,}{n,}{r,}st${unit}
		;;
	*)
		echo bad tape unit: $i - $unit
		;;
	esac
	umask 77
d289 6
a294 4
mt*)
	umask 0 ; unit=`expr $i : '..\(.*\)'`
	case $i in
	mt*) blk=7; chr=19;;
d296 10
a305 30
	case $unit in
	0|1|2|3|4|5|6|7)
		eight=`expr $unit + 0`;
		twelve=`expr $unit + 4`; 
		sixteen=`expr $unit + 8`;
		twenty=`expr $unit + 12`;
		rm -f mt8 mt12 mt16 mt20 nmt8 nrmt8 rmt8 rmt12 rmt16 rmt20
		rm -f nmt16 nrmt16
		mknod mt8		b $blk $eight
		mknod mt12		b $blk $twelve
		mknod mt16		b $blk $sixteen
		mknod mt20		b $blk $twenty
		mknod nmt8		b $blk $twelve ;: ditto
		mknod nrmt8		c $chr $twelve ;: ditto
		mknod rmt8		c $chr $eight
		mknod rmt12		c $chr $twelve
		mknod rmt16		c $chr $sixteen
		mknod rmt20		c $chr $twenty
		mknod nmt16		b $blk $twenty ;: ditto
		mknod nrmt16		c $chr $twenty ;: ditto
		chown root.operator {,n,r,nr}mt{8,16}
		chown root.operator {,r}mt{12,20}
		chmod 660 {,n,r,nr}mt{8,16}
		chmod 660 {,r}mt{12,20}
		;;
	*)
		echo bad unit for tape in: $1
		;;
	esac
	umask 77
d308 7
a314 9
random|srandom|urandom|prandom|arandom)
	rm -f random urandom srandom prandom arandom
	mknod  random c 67 0
	mknod srandom c 67 1
	mknod urandom c 67 2
	mknod prandom c 67 3
	mknod arandom c 67 4
	chown root.wheel random srandom urandom prandom arandom
	chmod 644 random srandom urandom prandom arandom
d317 2
a318 26
vnd*)
	umask 2
	unit=${i#vnd}
	if [ -z "$unit" -o 0$unit -gt 7 ]
	then
		echo bad disk unit: $i - $unit
		exit 127
	fi
	blk=18; chr=55;
	for name in vnd svnd; do
		case $name in
		vnd) off=0;;
		svnd) off=128;;
		esac
		rm -f {r,}${name}${unit}[a-p]
		minor=$(($unit * 16 + $off))
		for slice in a b c d e f g h i j k l m n o p
		do
			mknod ${name}${unit}${slice}  b $blk $minor
			mknod r${name}${unit}${slice} c $chr $minor
			minor=$(($minor + 1))
		done
		chown root.operator {r,}${name}${unit}?
		chmod 640 {r,}${name}${unit}?
	done
	umask 77
d321 2
a322 33
hp*|hk*|up*|ra*|rl*|rb*|ccd*|hd*|sd*|rx*|raid*)
	umask 2
	case $i in
	hp*) name=hp;	unit=${i#hp};	blk=0; chr=4;;
	hk*) name=hk;	unit=${i#hk};	blk=3; chr=11;;
	up*) name=up;	unit=${i#up};	blk=2; chr=13;;
	raid*) name=raid; unit=${i#raid}; blk=25; chr=73;;
	ra*) name=ra;	unit=${i#ra};	blk=9;	chr=9;;
	rb*) name=rb;	unit=${i#rb};	blk=11; chr=23;;
	rx*) name=rx;	unit=${i#rx};	blk=12; chr=30;;
	rl*) name=rl;	unit=${i#rl};	blk=14; chr=32;;
	ccd*) name=ccd;	unit=${i#ccd};	blk=17; chr=54;;
	hd*) name=hd;	unit=${i#hd};	blk=19; chr=58;;
	sd*) name=sd;	unit=${i#sd};	blk=20; chr=59;;
	esac
	case $unit in
	[0-9]|[12][0-9]|3[01])
		minor=$(($unit * 16))
		rm -f {r,}${name}${unit}[a-p]
		for slice in a b c d e f g h i j k l m n o p
		do
			mknod ${name}${unit}${slice}  b $blk $minor
			mknod r${name}${unit}${slice} c $chr $minor
			minor=$(($minor + 1))
		done
		chgrp operator ${name}${unit}[a-p] r${name}${unit}[a-p]
		chmod 640 ${name}${unit}[a-p] r${name}${unit}[a-p]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
d325 6
a330 11
cd*)
	case $i in
	cd*) name=cd;   unit=${i#cd};   chr=61; blk=22;;
	esac
	rm -f {r,}${name}${unit}{a,c}
	mknod ${name}${unit}a   b $blk $(($unit * 16 + 0))
	mknod ${name}${unit}c   b $blk $(($unit * 16 + 2))
	mknod r${name}${unit}a  c $chr $(($unit * 16 + 0))
	mknod r${name}${unit}c  c $chr $(($unit * 16 + 2))
	chgrp operator {r,}${name}${unit}?
	chmod 640 {r,}${name}${unit}?
d333 2
a334 10
ss*)
	case $i in
	ss*) name=ss;   unit=${i#ss};   chr=64;;
	esac
	rm -f {,n,en}${name}${unit}
	mknod $name$unit	c $chr $(($unit * 16 + 0))
	mknod n$name$unit	c $chr $(($unit * 16 + 1))
	mknod en$name$unit	c $chr $(($unit * 16 + 3))
	chgrp operator {,n,en}${name}${unit}
	chmod 640 {,n,en}${name}${unit}
d337 2
a338 9
ch*|uk*)
	case $i in
	ch*) name=ch;   unit=${i#ch};   chr=63;;
	uk*) name=uk;   unit=${i#uk};   chr=65;;
	esac
	rm -f $name$unit
	mknod $name$unit        c $chr $unit
	chgrp operator $name$unit
	chmod 640 $name$unit
d341 2
a342 24
rd*)
	unit=${i#rd}; blk=23; chr=62;
	rm -f rd${unit}{a,c} #rrd${unit}{a,c}
	mknod rd${unit}a  b $blk $(($unit * 16 + 0)) 
	mknod rd${unit}c  b $blk $(($unit * 16 + 2)) 
#	mknod rrd${unit}a c $chr $(($unit * 16 + 0)) 
#	mknod rrd${unit}c c $chr $(($unit * 16 + 2)) 
	chgrp operator rd${unit}? #rrd${unit}?
	chmod 640 rd${unit}? #rrd${unit}?
	;;

uu*)
	unit=${i#uu}
	name=uu; blk=13;
	case $unit in
	[0-3])
		rm -f ${name}${unit}{,a}
		mknod ${name}${unit}	b $blk $(($unit * 2 + 0))
		mknod ${name}${unit}a	b $blk $(($unit * 2 + 1))
		;;
	*)
		echo bad unit for uu cassette in: $i
		;;
	esac
d346 12
a357 14
	unit=${i#dz};
	case $unit in
	[0-7])
		i=0
		while [ $i -lt 8 ]; do
			no=$(($unit * 8 + $i))
			if [ $no -lt 10 ]; then
				no="0${no}"
			fi
			rm -f tty${no}
			mknod tty${no} c 1 $no
			i=$(($i + 1))
		done
		;;
d359 3
a361 3
		echo bad unit for dz in: $i
		;;
	esac
d364 2
a365 1
dhu*|dh*|dmf*|dmz*|vt*)
d367 2
a368 3
	vt*)	name=vt; major=68; count=8;
		unit=${i#vt}
		case $unit in
d372 2
a373 3
	dmz*)	name=dmz; major=37; count=24;
		unit=${i#dmz}
		case $unit in
d377 2
a378 3
	dmf*)	name=dmf; major=22; count=8;
		unit=${i#dmf}
		case $unit in
d383 2
a384 3
	dhu*)	name=dhu; major=34; count=16;
		unit=${i#dhu}
		case $unit in
d389 2
a390 3
	dh*)	name=dh; major=12; count=16;
		unit=${i#dh}
		case $unit in
d400 1
a400 2
			rm -f tty${ch}${let}
			mknod tty${ch}${let} c $major $(($unit * $count + $i))
d402 1
a402 1
			echo bad count for ${name}: $unit, $count, $i
d404 1
a404 1
		i=$(($i + 1))
a405 1

a408 1
	unit=${i#dl}
d410 1
a410 1
	let=${cnvtbl[$unit]}
d412 1
a412 2
		rm -f ttyJ${let}
		mknod ttyJ${let} c $major $unit
d414 1
a414 1
		echo bad number for ${name}: $unit
a417 18
lp*|va*|vp*)
	case $i in
	lp*) name=lp; unit=${i#lp}; major=15;;
	va*) name=va; unit=${i#va}; major=10;;
	vp*) name=vp; unit=${i#vp}; major=6;;
	esac
	case $unit in
	[0-7])
		rm -f $i
		mknod $i c $major $unit;
		chmod 666 $i
		;;
	*)
		echo bad unit for $name in: $i
		;;
	esac
	;;

d419 8
a426 25
	class=${i#pty};
	case $class in
	0)	name=p;;
	1)	name=q;;
	2)	name=r;;
	3)	name=s;;
	4)	name=t;;
	5)	name=u;;
	6)	name=v
		echo "$0: $i: pty unit conflicts with another use."
		continue;;
	7)	name=w;;
	8)	name=x;;
	9)	name=y;;
	10)	name=z;;
	11)	name=P;;
	12)	name=Q;;
	13)	name=R;;
	14)	name=S;;
	15)	name=T;;
	*)	echo "$0: $i: pty unit must be between 0 and 15"
	        continue ;;
	esac
	rm -f tty$name[0-9a-f] pty$name[0-9a-f]
	for j in 0 1 2 3 4 5 6 7 8 9 a b c d e f
d428 5
a432 12
		case $j in
		[0-9])	jn=$j ;;
		a)	jn=10 ;;
		b)	jn=11 ;;
		c)	jn=12 ;;
		d)	jn=13 ;;
		e)	jn=14 ;;
		f)	jn=15 ;;
		esac
		unit=$(($class * 16 + $jn))
		mknod tty$name$j c 20 $unit
		mknod pty$name$j c 21 $unit
a433 2
	chgrp wheel tty$name? pty$name?
	chmod 666 tty$name? pty$name?
d436 35
a470 21
np*)
	class=${i#np}
	case $class in
	0)	offset=0  name=0;;
	1)	offset=16 name=1;;
	2)	offset=32 name=2;;
	*)	echo bad unit for np in: $i;;
	esac
	case $class in
	0|1|2)
	i=0
	while [ $i -lt 4 ]; do
		no=$(($offset + $i))
		if [ $no -lt 10 ]; then
			no="0${no}"
		fi
		rm -f np${no}
		mknod np${no} c 39 $no
		i=$(($i + 1))
	done
	esac
d473 2
a474 19
dn*|ik*|ps*|ad*|ct*)
	case $i in
	ct*) name=ct; unit=${i#ct}; chr=18;;
	dn*) name=cu; unit=${i#dn}; chr=24;;
	ps*) name=ps; unit=${i#ps}; chr=27;;
	ad*) name=ad; unit=${i#ad}; chr=29;;
	ik*) name=ik; unit=${i#ik}; chr=31;;
	esac
	case $unit in
	[0-7])
		umask 0
		rm -f ${name}${unit}
		mknod ${name}${unit} c ${chr} ${unit}
		umask 77
		;;
	*)
		echo bad unit for ${name} in: $i
		;;
	esac
d477 6
a482 20
bpf*)
	unit=${i#bpf};
	rm -f bpf$unit
	mknod bpf$unit c 56 $unit
	chmod 600 bpf$unit
	chown root.wheel bpf$unit
	;;

qd*)
	unit=${i#qd}
	rm -f q{c,d}$unit
	mknod qc$unit c 40 $(($unit * 4))
	mknod qd$unit c 40 $(($unit * 4 + 2))
	;;

pf)
	rm -f pf
	mknod pf c 42 0
	chown root.wheel pf
	chmod 600 pf
d485 2
a486 6
tun*)
	unit=${i#tun}
	rm -f tun$unit
	mknod tun$unit c 57 $unit
	chmod 600 tun$unit
	chown root.wheel tun$unit
d489 2
a490 18
lkm)
	rm -f lkm
	mknod lkm c 28 0
	chown root.kmem lkm
	chmod 640 lkm
	;;

qv0)
	rm -f qv0 qvcons mouse
	mknod qv0 c 40 0
	mknod qvcons c 40 1
	mknod mouse c 40 2
	;;

ttyv0)
	if [ ! -f ttyqe ]; then sh ./$0 pty1; fi
	mv ttyqf ttyv0
	mv ptyqf ptyv0
d493 7
a499 10
altq)
	mkdir -p altq
	chmod 755 altq
	unit=0
	for dev in altq cbq wfq afm fifoq red rio localq hfsc \
	    cdnr blue priq; do
		rm -f altq/$dev
		mknod altq/$dev c 75 $unit
		chmod 644 altq/$dev
		unit=$(($unit + 1))
d504 25
a528 3
	umask 0
	sh $0.local all
	umask 77
d530 1
d532 1
a532 1
	echo $i: invalid device
a533 1

d536 31
@


1.40
log
@sync
@
text
@d3 2
a4 2
# THIS FILE AUTOMATICALLY GENERATED.  DO NOT EDIT.
# generated from:
d6 1
a6 3
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.5 2002/02/14 17:44:38 todd Exp 
#	OpenBSD: MAKEDEV.mi,v 1.31 2002/02/14 17:44:38 todd Exp 
#	OpenBSD: MAKEDEV.sub,v 1.6 2002/02/14 05:50:37 todd Exp 
a7 26
#	$OpenBSD$
#
# Copyright (c) 2001 Todd T. Fries <todd@@OpenBSD.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
# THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#


a8 2
#	all	makes all known devices, including local devices.
#		Tries to make the ``standard'' number of each type.
d11 1
a12 2
#	st*	SCSI tapes
#	mt*	(Magnetic) 9-track reel tape
d15 1
d18 2
d21 1
a21 1
#	hp*	massbuss rm??
d25 2
d28 4
a31 3
#	rx*	MSCP floppy disk (rx33/50/...)
#	rl*	unibus r102
#	hd*	HP300 HP-IB disks
d33 4
a36 16
#	cd*	SCSI cdrom drives
#	ch*	SCSI media changer
#	ss*	SCSI scanners
#	uk*	SCSI Unknown device
#	xy*	Xylogic 450/451 disks
#	rd*	"ramdisk" pseudo-disks
#	xd*	Xylogic 753/7053 disks
#	fd*	Floppy disk drives (3 1/2", 5 1/4")
#	vnd*	"file" pseudo-disks
#	ccd*	concatenated disk devices
# Pseudo terminals:
#	tty*	set of 16 slave psuedo terminals
#	pty*	set of 16 master pseudo terminals
# Printers:
# Terminal ports:
#	dhu*	unibus dhu11
d39 2
a40 3
#	dmz*	unibus dmz32
#	vt*	console
#	dz*	unibus dz11 and dz32
d42 9
d52 15
a66 12
#	openprom	
#	bpf*	Berkeley Packet Filter
#	pf*	Packet Filter
#	altq/	ALTQ control interface
#	lkm	loadable kernel modules interface
#	tun*	network tunnel driver
#	*random	inkernel random data source
#	magma*	magma card (makes 16 tty and 2 bpp)
#	xfs*	XFS filesystem devices
#	raid*	RAIDframe disk devices
#	fd	makes fd/* for the fdescfs
#	ses*	SES/SAF-TE SCSI devices
d68 5
a72 1
T=$0
d74 7
a80 2
# set this to echo for Echo-Only debugging
[ "$eo" ] || eo=
d82 4
a85 55
hex()
{
	case $1 in
	[0-9]) echo -n $1;;
	10) echo -n a;;
	11) echo -n b;;
	12) echo -n c;;
	13) echo -n d;;
	14) echo -n e;;
	15) echo -n f;;
	esac
}

trunc()
{
	# XXX pdksh can't seem to deal with locally scoped variables
	# in ${foo#$bar} expansions
	arg1="$1"
	arg2="$2"
	case $3 in
	l)   echo ${arg2#$arg1} ;;
	r|*) echo ${arg1#$arg2} ;;
	esac
}

unt()
{
	# XXX pdksh can't seem to deal with locally scoped variables
	# in ${foo#$bar} expansions
	arg="$1"
	tmp="${arg#[a-zA-Z]*}"
	tmp="${tmp%*[a-zA-Z]}"
	while [ "$tmp" != "$arg" ]
	do
		arg=$tmp
		tmp="${arg#[a-zA-Z]*}"
		tmp="${tmp%*[a-zA-Z]}"
	done
	echo $arg
}

dodisk()
{
	[ "$DEBUG" ] && set -x
	n=$(($((${5}*${7:-16}))+${6})) count=0
	RMlist="$RMlist $1$2? r$1$2?"
	[ 0$7 -ne 8 ] && l="i j k l m n o p"
	for d in a b c d e f g h $l
	do
		M $1$2$d	b $3 $(($n+$count)) 640
		M r$1$2$d	c $4 $(($n+$count)) 640
		let count=count+1
	done
	MKlist="$MKlist;chown root.operator $1$2? r$1$2?"
}
a86 52
dodisk2()
{
	n=$(($(($5*${7:-16}))+$6))
	M $1$2a b $3 $n 640 operator
	M r$1$2a c $4 $n 640 operator
	n=$(($n+2))
	M $1$2c b $3 $n 640 operator
	M r$1$2c c $4 $n 640 operator
}

# M name b/c major minor [mode] [group]
RMlist="rm -f"
MKlist=":"

mkl() {
	[ "${mklist[$1]}" ] && {
		mklist[$1]="${mklist[$1]};mknod -m $1 $2 $3 $4 $5"
	} || {
		mklist[$1]="mknod -m $1 $2 $3 $4 $5"
		modes="$modes $1"
	}
}

M() {
	RMlist="$RMlist $1"
	mkl ${5-666} $1 $2 $3 $4
	mklist="$mklist $1"
	G=${6:-wheel}
	[ "$7" ] && {
		MKlist="$MKlist;chown $7.$G $1"
	} || {
		case $G in
		wheel)g=0;;kmem)g=2;;operator)g=5;;tty)g=4;;dialer)g=117;;
		esac
		[ "${grplist[$g]}" ] && {
			grplist[$g]="${grplist[$g]} $1"
		} || {
			groups="$groups $g"
			grplist[$g]="chgrp $G $1"
		}
	}
	return 0
}

R() {
[ "$DEBUG" ] && set -x
for i in "$@@"
do
U=`unt $i`
[ "$U" ] || U=0

case $i in
d88 3
a90 2
	R std random
	R fd0 sd0 sd1 rd0
d94 39
a132 23
	M console	c 0 0 600
	M tty		c 2 0
	M mem		c 3 0 640 kmem
	M kmem		c 3 1 640 kmem
	M null		c 3 2
	M zero		c 3 12
	M stdin		c 53 0
	M stdout	c 53 1
	M stderr	c 53 2
	M ksyms		c 50 0 640 kmem
	M drum		c 7 0 640 kmem
	M klog		c 33 0 600
	M ttyg0		c 25 0 600
	M ttyg1		c 25 1 600
	M ttyg2		c 25 2 600
	M ttyg3		c 25 3 600
	M crl		c 35 0 600
	M csa1		c 51 0 600
	M csa2		c 51 1 600
	M tu0		b 8 0 600
	M tu1		b 8 1 600
	M floppy	c 8 0 600
	M kUmem		c 3 3 600
d137 5
a141 5
	ht*) n=ht b=1 c=5;;
	mt*) n=mt b=15 c=38;;
	tm*) n=tm b=5 c=14;;
	ts*) n=ts b=6 c=16;;
	ut*) n=ut b=10 c=17;;
d143 1
a143 1
	case $U in
d145 22
a166 17
		four=$(($U+4))
		eight=$(($U+8))
		twelve=$(($U+12))
		twenty=$(($U+20))
		M $n$U		b $b $U	660 operator
		M $n$four	b $b $four	660 operator
		M $n$eight	b $b $eight	660 operator
		M $n$twelve	b $b $twelve	660 operator
		M n$n$U		b $b $four	660 operator;: sanity w/pdp11 v7
		M n$n$eight	b $b $twelve	660 operator;: ditto
		M nr$n$U	c $c $four	660 operator;: ditto
		M nr$n$twelve	c $c $twelve	660 operator;: ditto
		M r$n$U		c $c $U		660 operator
		M r$n$four	c $c $four	660 operator
		M r$n$eight	c $c $eight	660 operator
		M r$n$twelve	c $c $twelve	660 operator
		if [ "$i" = "ut" ];
d168 23
a190 2
			M $n$twenty	b $b $twenty 660 operator
			M r$n$twenty	c $b $twenty 660 operator
a191 4
		#RMlist="$RMlist mt$U mt$four mt$eight mt$twelve"
		#RMlist="$RMlist nmt$U nmt$eight nrmt$eight"
		#RMlist="$RMlist nrmt$unit nrmt$eight"
		#RMlist="$RMlist rmt$unit rmt$four rmt$eight rmt$twelve"
d194 1
a194 1
		echo bad unit for tape in: $i
d200 22
a221 2
ses*)
	M ses$U c 124 $U 640 operator
d224 35
a258 4
fd)
	RMlist="mkdir -p fd;$RMlist" n=0
	while [ $n -lt 64 ];do M fd/$n c 53 $n;n=$(($n+1));done
	MKlist="$MKlist;chmod 555 fd"
d261 9
a269 2
xfs*)
	M xfs$U c 51 $U 600
d272 24
a295 14
magma*)
	case $U in
	0)	offset=0  nam=m;;
	1)	offset=16 nam=n;;
	2)	offset=32 nam=o;;
	*)	echo "bad unit for $i: $U"; exit 127;;
	esac
	offset=$(($U*64))
	n=0
	while [ $n -lt 16 ]
	do
		name=${nam}`hex $n`
		M tty$name c major_mag_c $(($offset+$n)) 660 dialer uucp
		n=$(($n+1))
d297 1
a297 2
	M bpp${nam}0 c major_bppmag_c $(($offset+0)) 600
	M bpp${nam}1 c major_bppmag_c $(($offset+1)) 600
d300 33
a332 7
*random)
	n=0
	for pre in " " s u p a
	do
		M ${pre}random c 67 $n 644
		n=$(($n+1))
	done
d335 11
a345 2
tun*)
	M tun$U c 57 $U 600
d348 10
a357 2
lkm)
	M lkm c 28 0 640 kmem
d360 9
a368 6
altq)
	RMlist="mkdir -p altq;$RMlist"
	for d in altq cbq wfq afm fifoq red rio localq hfsc cdnr blue priq; do
		M altq/$d c 75 $U 644
		U=$(($U+1))
	done
d371 24
a394 10
pf*)
	M pf c 42 0 600
	;;

bpf*)
	M bpf$U c 56 $U 600
	;;

openprom)
	M openprom c 70 0  
d398 14
a411 12
	case $U in
       [0-7])
	       i=0
	       while [ $i -lt 8 ]; do
		       no=$(($(($U*8))+$i))
		       if [ $no -lt 10 ]; then
			       no="0${no}"
		       fi
		       M tty${no} c 1 $no 600
		       let i=i+1
	       done
	       ;;
d413 3
a415 3
	       echo bad unit for dz in: $i
	       ;;
       esac
d418 1
a418 2
dhu*|dmz*|dmf*|dh*|vt*)
	set -A cnvtbl 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v
d420 3
a422 2
	vt*)    name=vt; major=68; count=8;
		case $U in
d426 3
a428 2
	dmz*)   name=dmz; major=37; count=24;
		case $U in
d432 3
a434 2
	dmf*)   name=dmf; major=22; count=8;
		case $U in
d439 3
a441 2
	dhu*)   name=dhu; major=34; count=16;
		case $U in
d446 3
a448 2
	dh*)    name=dh; major=12; count=16;
		case $U in
d458 2
a459 1
			M tty${ch}${let} c $major $(($(($U*$count))+$i)) 600
d461 1
a461 1
			echo bad count for ${name}: $U, $count, $i
d463 1
a463 1
		let i=i+1
d465 1
d469 1
d471 1
a471 1
	let=${cnvtbl[$U]}
d473 2
a474 1
		M ttyJ${let} c $major $U 600
d476 1
a476 1
		echo bad number for ${name}: $U
d480 18
d499 25
a523 8
	if [ $U -gt 15 ]; then
		echo bad unit for pty in: $i
		continue
	fi
	set -A tbl p q r s t u v w x y z P Q R S T
	name=${tbl[$U]}
	n=0
	while [ $n -lt 16 ]
d525 12
a536 5
		nam=$name$(hex $n)
		off=$(($U*16))
		M tty$nam c 20 $(($off+$n))
		M pty$nam c 21 $(($off+$n))
		n=$(($n+1))
d538 2
d542 21
a562 3
vnd*)
	dodisk vnd $U 18 55 $U 0
	dodisk svnd $U 18 55 $U 128
d565 19
a583 26
fd*)
	typnam=$U${i#fd[01]*}
	case $typnam in
	0|1)	typnum=0;; # no type specified, assume A
	*A)	typnum=0; typnam=0;;
	*B)	typnum=1;;
	*C)	typnum=2;;
	*D)	typnum=3;;
	*E)	typnum=4;;
	*F)	typnum=5;;
	*G)	typnum=6;;
	*H)	typnum=7;;
	*)	echo bad type $typnam for $i; exit 1;;
	esac
	case $U in
	0|1)	blk=16; chr=54;;
	*)	echo bad unit $U for $i; exit 1;;
	esac
	nam=fd${typnam}
	n=$(($(($U*128))+$(($typnum*16))))
	M ${nam}a	b $blk $n 640 operator
	M ${nam}b	b $blk $(($n+1)) 640 operator
	M ${nam}c	b $blk $(($n+2)) 640 operator
	M r${nam}a	c $chr $n 640 operator
	M r${nam}b	c $chr $(($n+1)) 640 operator
	M r${nam}c	c $chr $(($n+2)) 640 operator
d586 20
a605 2
rd*)
	dodisk2 rd $U 23 106 $U 0
d608 6
a613 2
uk*)
	M uk$U c 65 $U 640 operator
d616 18
a633 6
ss*)
	M ss$U c 64 $(($U*16)) 640 operator
	M nss$U c 64 $(($(($U*16))+1)) 640 operator
	M enss$U c 64 $(($(($U*16))+3)) 640 operator
	RMlist="$RMlist scan$U"
	MKlist="$MKlist;umask 77;ln -s ss$U scan$U"
d636 10
a645 15
ch*)
	M ch$U c 63 $U 660 operator
	;;

cd*)
	dodisk2 cd $U 22 61 $U 0
	;;

st*)
	n=$(($U*16))
	for pre in " " n e en
	do
		M ${pre}st$U	b 21 $n 660 operator
		M ${pre}rst$U	c 60 $n 660 operator
		n=$(($n+1))
d650 3
a652 1
	test -s $T.local && sh $T.local
d654 2
a655 11

all)
	R vt0 dl0 dz0 dh0 dmf0 dmz0 dhu0 ts0 ts1 mt0 mt1 hd0 hd1 hd2
	R xfs0 ss0 ss1 uk0 ses0 rndrandom lkm pf altq tun0 tun1 tun2
	R tun3 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7 bpf8 bpf9 fd1
	R fd1B fd1C fd1D fd1E fd1F fd1G fd1H fd0 fd0B fd0C fd0D fd0E
	R fd0F fd0G fd0H xd0 xd1 xd2 xd3 xy0 xy1 xy2 xy3 ut0 up0 up1
	R up2 up3 tm0 rx0 rx1 rl0 rl1 rl2 rl3 rb0 rb1 rb2 rb3 ra0 ra1
	R ra2 ra3 ht0 hp0 hp1 hp2 hp3 hk0 hk1 hk2 hk3 rd0 raid0 raid1
	R raid2 raid3 ccd0 ccd1 ccd2 ccd3 vnd0 vnd1 vnd2 vnd3 std cd0
	R cd1 ch0 st0 st1 pty0 pty1 pty2 fd sd0 sd1 sd2 sd3 sd4
a657 21
up*|xd*|xy*|sd*|rx*|rl*|rb*|raid*|ra*|hp*|hk*|hd*|ccd*)
	case $i in
	up*) dodisk up $U 2 13 $U 0;;
	xd*) dodisk xd $U 10 42 $U 0;;
	xy*) dodisk xy $U 3 9 $U 0;;
	sd*) dodisk sd $U 20 59 $U 0;;
	rx*) dodisk rx $U 12 30 $U 0;;
	rl*) dodisk rl $U 14 32 $U 0;;
	rb*) dodisk rb $U 11 23 $U 0;;
	raid*) dodisk raid $U 25 73 $U 0;;
	ra*) dodisk ra $U 9 9 $U 0;;
	hp*) dodisk hp $U 0 4 $U 0;;
	hk*) dodisk hk $U 3 11 $U 0;;
	hd*) dodisk hd $U 19 58 $U 0;;
	ccd*) dodisk ccd $U 17 54 $U 0;;
	esac
	;;

*)
	echo $i: unknown device
	;;
a659 31
}
R "$@@"
if [ "$os" = "SunOS" ]; then
	eo=transform
	transform() {
		case $mode in
		600) mask=077;;
		640) mask=027;;
		660) mask=007;;
		644) mask=022;;
		666) mask=0;;
		440) mask=227;;
		esac
		echo `echo "$@@"|sed \
		    's/mknod -m \([0-9]*\) /umask '$mask';mknod /;s/-m [0-9]* //g;\
		    s/operator/5/g;s/root.kmem/root.2/g;s/root\./root:/g'`
	}
fi
list="$RMlist"
for mode in $modes; do
	list="$list;${mklist[$mode]}"
done
for group in $groups; do
	list="$list;${grplist[$group]}"
done
list="$list;$MKlist"
if [ "$eo" = "echo" -o "$eo" = "transform" ]; then
	$eo "$list"
else
	echo "$list" | sh
fi
@


1.39
log
@sync
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.4 2002/02/14 14:32:26 todd Exp 
#	OpenBSD: MAKEDEV.mi,v 1.30 2002/02/14 14:32:26 todd Exp 
d79 1
a80 1
#	audio*	audio device
d225 5
a229 5
	M ttyg0		c 25 0
	M ttyg1		c 25 1
	M ttyg2		c 25 2
	M ttyg3		c 25 3
	M crl		c 35 0
d232 4
a235 3
	M tu0		b 8 0
	M tu1		b 8 1
	M kUmem		c 3 3 660
d248 4
a251 2
		four=$(($U+4)) eight=$(($U+8))
		twelve=$(($U+12)) twenty=$(($U+20))
d256 4
a259 4
		M n$n$four	b $b $four	660 operator
		M n$n$twelve	b $b $twelve	660 operator
		M nr$n$four	c $c $four	660 operator
		M nr$n$twelve	c $c $twelve	660 operator
d264 1
a264 1
		if [ $i = ut ]; : XXXX
a350 11
audio*)
	M sound$U	c 69 $U
	M mixer$U	c 69 $(($U+16))
	M audio$U	c 69 $(($U+128))
	M audioctl$U	c 69 $(($U+192))
	MKlist="$MKlist;[ -e audio ] || ln -s audio$U audio"
	MKlist="$MKlist;[ -e mixer ] || ln -s mixer$U mixer"
	MKlist="$MKlist;[ -e sound ] || ln -s sound$U sound"
	MKlist="$MKlist;[ -e audioctl ] || ln -s audioctl$U audioctl"
	;;

d352 1
a352 2
	unit=${i#dz};
       case $unit in
d356 1
a356 1
		       no=$(($unit * 8 + $i))
d360 2
a361 3
		       rm -f tty${no}
		       mknod tty${no} c 1 $no
		       i=$(($i + 1))
d370 1
a370 1
dhu*|dmz*|dmf*|dh*)
d374 1
a374 2
		unit=${i#vt}
		case $unit in
d379 1
a379 2
		unit=${i#dmz}
		case $unit in
d384 1
a384 2
		unit=${i#dmf}
		case $unit in
d390 1
a390 2
		unit=${i#dhu}
		case $unit in
d396 1
a396 2
		unit=${i#dh}
		case $unit in
d406 1
a406 2
			rm -f tty${ch}${let}
			mknod tty${ch}${let} c $major $(($unit * $count + $i))
d408 1
a408 1
			echo bad count for ${name}: $unit, $count, $i
d410 1
a410 1
		i=$(($i + 1))
a414 1
	unit=${i#dl}
d416 1
a416 1
	let=${cnvtbl[$unit]}
d418 1
a418 2
		rm -f ttyJ${let}
		mknod ttyJ${let} c $major $unit
d420 1
a420 1
		echo bad number for ${name}: $unit
d425 6
a430 19
	case $U in
	0) off=0 name=p;;
	1) off=16 name=q;;
	2) off=32 name=r;;
	3) off=48 name=s;;
	4) off=64 name=t;;
	5) off=80 name=u;;
	6) off=96 name=v;;
	7) off=112 name=w;;
	8) off=128 name=x;;
	9) off=144 name=y;;
	10) off=160 name=z;;
	11) off=176 name=P;;
	12) off=192 name=Q;;
	13) off=206 name=R;;
	14) off=224 name=S;;
	15) off=240 name=T;;
	*) echo bad unit for pty in: $i; continue;;
	esac
d435 1
d484 3
a486 1
	M ss$U c 64 $U 440 operator
d504 1
a504 1
		M ${pre}rst$U	c 38 $n 660 operator
d514 9
a522 9
	R dz0 dh0 dmf0 dmz0 dhu0 mt0 hd0 hd1 hd2 audio0 xfs0 ss0 ss1
	R uk0 ses0 rndrandom lkm pf altq tun0 tun1 tun2 tun3 bpf0 bpf1
	R bpf2 bpf3 bpf4 bpf5 bpf6 bpf7 bpf8 bpf9 fd1 fd1B fd1C fd1D
	R fd1E fd1F fd1G fd1H fd0 fd0B fd0C fd0D fd0E fd0F fd0G fd0H
	R xd0 xd1 xd2 xd3 xy0 xy1 xy2 xy3 ut0 up0 up1 up2 up3 ts0 tm0
	R rx0 rx1 rl0 rl1 rl2 rl3 rb0 rb1 rb2 rb3 ra0 ra1 ra2 ra3 ht0
	R hp0 hp1 hp2 hp3 hk0 hk1 hk2 hk3 rd0 raid0 raid1 raid2 raid3
	R ccd0 ccd1 ccd2 ccd3 vnd0 vnd1 vnd2 vnd3 std cd0 cd1 ch0 st0
	R st1 pty0 pty1 pty2 fd sd0 sd1 sd2 sd3 sd4
@


1.38
log
@sync
@
text
@d6 2
a7 2
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.3 2002/02/14 13:24:45 todd Exp 
#	OpenBSD: MAKEDEV.mi,v 1.29 2002/02/14 05:38:22 todd Exp 
d35 1
d60 1
a61 1
#	ss*	SCSI scanners
d73 6
d230 2
a231 2
	M csa1		c 51 0
	M csa2		c 51 1
d315 1
a315 1
		M ${pre}random c 119 $n 644
d321 1
a321 1
	M tun$U c 111 $U 600
d325 1
a325 1
	M lkm c 112 0 640 kmem
d359 83
d473 2
a474 2
	dodisk vnd $U 8 55 $U 0
	dodisk svnd $U 8 55 $U 128
d509 4
d514 1
a514 1
	M ss$U c 121 $U 440 operator
a518 4
uk*)
	M uk$U c 120 $U 640 operator
	;;

d520 1
a520 1
	M ch$U c 19 $U 660 operator
d524 1
a524 1
	dodisk2 cd $U 22 58 $U 0
d542 9
a550 9
	R hd0 hd1 hd2 audio0 xfs0 ss0 ss1 uk0 ses0 rndrandom lkm pf
	R altq tun0 tun1 tun2 tun3 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6
	R bpf7 bpf8 bpf9 fd1 fd1B fd1C fd1D fd1E fd1F fd1G fd1H fd0
	R fd0B fd0C fd0D fd0E fd0F fd0G fd0H xd0 xd1 xd2 xd3 xy0 xy1
	R xy2 xy3 ut0 up0 up1 up2 up3 ts0 tm0 rx0 rx1 rl0 rl1 rl2 rl3
	R rb0 rb1 rb2 rb3 ra0 ra1 ra2 ra3 ht0 hp0 hp1 hp2 hp3 hk0 hk1
	R hk2 hk3 rd0 raid0 raid1 raid2 raid3 ccd0 ccd1 ccd2 ccd3 vnd0
	R vnd1 vnd2 vnd3 std cd0 cd1 ch0 st0 st1 pty0 pty1 pty2 fd sd0
	R sd1 sd2 sd3 sd4
@


1.37
log
@escapees; it is not yet time (but soon)
@
text
@d3 2
a4 2
#	$OpenBSD: MAKEDEV,v 1.35 2002/02/09 17:55:53 deraadt Exp $
#	$NetBSD: MAKEDEV,v 1.30 2000/01/21 12:28:29 tsutsui Exp $
d6 3
a8 1
#	@@(#)MAKEDEV	8.1 (Berkeley) 6/9/93
d10 25
d36 2
a39 1
#	all	create a reasonable amount of all files
d41 2
a44 1
#	mt*	MSCP tapes (e.g. TU81, TK50)
a46 2
#	uu*	tu58 cassettes on dl11 controller
#	st*	SCSI tapes
d48 1
a48 1
#	hp*	massbus rm??
d52 1
d54 11
a64 4
#	rl*	unibus rl02
#	rb*	730 idc w/ rb80 and/or rb02
#	ccd*	"concatenated" pseudo-disks
#	raid*	RAIDframe disk driver
d66 1
a66 11
#	rd*	memory pseudo-disk devices
#	sd*	SCSI disks
#	cd*	SCSI CD-ROM
#	hd*	HDC9224 hd disks on VS2000
# Terminal multiplexors:
#	dz*	unibus dz11 and dz32
#	dh*	unibus dh11 and emulations (e.g. Able dmax, Emulex cs-11)
#	dmf*	unibus dmf32
#	dhu*    unibus dhu11
#	dmz*    unibus dmz32
#	dl*	unibus dl11
d68 2
a69 1
#	pty*	set of 16 master and slave pseudo terminals
d71 1
a71 6
#	ct*	unibus parallel interface to CAT typesetter
#	lp*	unibus lp11 parallel interface
#	va*	unibus varian parallel interface
#	vp*	unibus versatec parallel interface
# Call units:
#	dn*	unibus dn11 and emulations (e.g. Able Quadracall)
d73 13
a85 15
#	ik*	unibus interface to ikonas frame buffer
#	ps*	unibus interface to e&s picture system 2
#	ad*	unibus interface to data translation a/d converter
#	np*	unibus ethernet co-processor interface, for downloading.
#	qv*	qvss (microvax) display
#	ttyv0	qvss (microvax) display reserved pty
#	lkm	loadable kernel modules
#	bpf*	berkeley packet filter
#	tun*	network tunnel device
#	ss*	SCSI scanner
#	uk*	SCSI unknown
#	ch*	SCSI changer
#	*random	Random number generator
#	altq	ALTQ control interface
#
d87 45
a131 5
set -A cnvtbl 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v
umask 77
for i
do
case $i in
d133 14
a146 7
all)
	sh $0 std fd vnd0 ccd0 pty0 pty1 lkm random altq
	sh $0 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7 pf tun0 tun1
	sh $0 mt0 mt1 ts0 ts1 st0 st1 uk0 ss0 cd0 vt0
	sh $0 ra0 ra1 ra2 ra3 hp0 hp1 hp2 hp3 sd0 sd1 sd2 sd3 hd0 hd1 hd2
	sh $0 dz0 dl0 dhu0 rx0 rx1 raid0 raid1 raid2 raid3
	;;
d148 50
a197 4
floppy)
	sh $0 std random
	sh $0 sd0 sd1
	;;
d199 1
d201 2
a202 3
	sh $0 std random
	sh $0 rd0 sd0 sd1 sd2 sd3 ra0 ra1 ra2 rx0 cd0 st0 st1
	sh $0 bpf0
d206 22
a227 39
	rm -f console drum floppy crl csa1 csa2 tu0 tu1
	rm -f kUmem kmem mem null zero tty klog ttyg[0-3]
	rm -f stdin stdout stderr ksyms
	mknod console		c 0 0
	mknod ttyg0		c 25 0
	mknod ttyg1		c 25 1
	mknod ttyg2		c 25 2
	mknod ttyg3		c 25 3
	mknod drum		c 7 0	; chmod 640 drum ; chgrp kmem drum
	mknod floppy		c 8 0
	mknod crl		c 35 0
	mknod csa1		c 51 0
	mknod csa2		c 51 1
	mknod tu0		b 8 0
	mknod tu1		b 8 1
	mknod kUmem		c 3 3	; chmod 600 kUmem
	mknod kmem		c 3 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 3 0	; chmod 640 mem ; chgrp kmem mem
	mknod null		c 3 2	; chmod 666 null
	mknod zero		c 3 12  ; chmod 666 zero
	mknod tty		c 2 0	; chmod 666 tty
	mknod klog		c 33 0	; chmod 600 klog
	mknod stdin		c 53 0	; chmod 666 stdin
	mknod stdout		c 53 1	; chmod 666 stdout
	mknod stderr		c 53 2	; chmod 666 stderr
	mknod ksyms		c 50 0	; chmod 640 ksyms ; chown root.kmem ksyms
	;;

fd)
	rm -f fd/*
	mkdir fd > /dev/null 2>&1
	n=0
	while [ $n -lt 64 ]; do
		mknod fd/$n c 53 $n
		n=$(($n + 1))
	done
	chown -R root.wheel fd
	chmod 755 fd
	chmod 666 fd/*
d232 5
a236 5
	ht*) name=ht;	unit=${i#ht};	blk=1; chr=5 ;;
	mt*) name=mt;	unit=${i#mt};	blk=15;	chr=38;;
	tm*) name=tm;	unit=${i#tm};	blk=5; chr=14;;
	ts*) name=ts;	unit=${i#ts};	blk=6; chr=16;;
	ut*) name=ut;	unit=${i#ut};	blk=10; chr=17;;
d238 1
a238 1
	case $unit in
d240 15
a254 22
		four=$(($unit + 4)) ; eight=$(($unit + 8))
		twelve=$(($unit + 12)) ; twenty=$(($unit + 20))
		rm -f $name$unit $name$four $name$eight $name$twelve \
		    n$name$unit n$name$eight nr$name$unit nr$name$eight \
		    r$name$unit r$name$four r$name$eight r$name$twelve
		mknod $name$unit	b $blk $unit
		mknod $name$four	b $blk $four
		mknod $name$eight	b $blk $eight
		mknod $name$twelve	b $blk $twelve
		mknod n$name$unit	b $blk $four ;: sanity w/pdp11 v7
		mknod n$name$eight	b $blk $twelve ;: ditto
		mknod nr$name$unit	c $chr $four ;: sanity w/pdp11 v7
		mknod nr$name$eight	c $chr $twelve ;: ditto
		mknod r$name$unit	c $chr $unit
		mknod r$name$four	c $chr $four
		mknod r$name$eight	c $chr $eight
		mknod r$name$twelve	c $chr $twelve
		chown root.operator {,n,r,nr}$name{$unit,$eight}
		chown root.operator {,r}$name{$four,$twelve}
		chmod 660 {,n,r,nr}$name{$unit,$eight}
		chmod 660 {,r}$name{$four,$twelve}
		if [ $i = ut ] 
d256 2
a257 23
			rm -f $name$twenty r$name$twenty
			mknod $name$twenty	b $blk $twenty
			mknod r$name$twenty	c $chr $twenty
			chown root.operator {,r}$name$twenty
			chmod 660 {,r}$name$twenty
		fi
		if [ ! -e rmt$eight ]	# compatibility stuff
		then
			rm -f mt$unit mt$four mt$eight mt$twelve \
			    nmt$unit nmt$eight nrmt$unit nrmt$eight \
			    rmt$unit rmt$four rmt$eight rmt$twelve
			ln -s $name$unit mt$unit
			ln -s $name$four mt$four
			ln -s $name$eight mt$eight
			ln -s $name$twelve mt$twelve
			ln -s n$name$unit nmt$unit
			ln -s n$name$eight nmt$eight
			ln -s nr$name$unit nrmt$unit
			ln -s nr$name$eight nrmt$eight
			ln -s r$name$unit rmt$unit
			ln -s r$name$four rmt$four
			ln -s r$name$eight rmt$eight
			ln -s r$name$twelve rmt$twelve
d259 4
d265 1
a265 1
		echo bad unit for tape in: $1
d271 2
a272 22
st*)
	umask 2
	unit=${i#st};	blk=21; chr=60;
	case $unit in
	0|1|2|3|4|5|6|7)
		rm -f {e,}{n,}{r,}st${unit}
		mknod st${unit}		b $blk $(($unit * 16 + 0))
		mknod nst${unit}	b $blk $(($unit * 16 + 1))
		mknod est${unit}	b $blk $(($unit * 16 + 2))
		mknod enst${unit}	b $blk $(($unit * 16 + 3))
		mknod rst${unit}	c $chr $(($unit * 16 + 0))
		mknod nrst${unit}	c $chr $(($unit * 16 + 1))
		mknod erst${unit}	c $chr $(($unit * 16 + 2))
		mknod enrst${unit}	c $chr $(($unit * 16 + 3))
		chown root.operator {e,}{n,}{r,}st${unit}
		chmod 660 {e,}{n,}{r,}st${unit}
		;;
	*)
		echo bad tape unit: $i - $unit
		;;
	esac
	umask 77
d275 4
a278 35
mt*)
	umask 0 ; unit=`expr $i : '..\(.*\)'`
	case $i in
	mt*) blk=7; chr=19;;
	esac
	case $unit in
	0|1|2|3|4|5|6|7)
		eight=`expr $unit + 0`;
		twelve=`expr $unit + 4`; 
		sixteen=`expr $unit + 8`;
		twenty=`expr $unit + 12`;
		rm -f mt8 mt12 mt16 mt20 nmt8 nrmt8 rmt8 rmt12 rmt16 rmt20
		rm -f nmt16 nrmt16
		mknod mt8		b $blk $eight
		mknod mt12		b $blk $twelve
		mknod mt16		b $blk $sixteen
		mknod mt20		b $blk $twenty
		mknod nmt8		b $blk $twelve ;: ditto
		mknod nrmt8		c $chr $twelve ;: ditto
		mknod rmt8		c $chr $eight
		mknod rmt12		c $chr $twelve
		mknod rmt16		c $chr $sixteen
		mknod rmt20		c $chr $twenty
		mknod nmt16		b $blk $twenty ;: ditto
		mknod nrmt16		c $chr $twenty ;: ditto
		chown root.operator {,n,r,nr}mt{8,16}
		chown root.operator {,r}mt{12,20}
		chmod 660 {,n,r,nr}mt{8,16}
		chmod 660 {,r}mt{12,20}
		;;
	*)
		echo bad unit for tape in: $1
		;;
	esac
	umask 77
d281 2
a282 9
random|srandom|urandom|prandom|arandom)
	rm -f random urandom srandom prandom arandom
	mknod  random c 67 0
	mknod srandom c 67 1
	mknod urandom c 67 2
	mknod prandom c 67 3
	mknod arandom c 67 4
	chown root.wheel random srandom urandom prandom arandom
	chmod 644 random srandom urandom prandom arandom
d285 14
a298 24
vnd*)
	umask 2
	unit=${i#vnd}
	if [ -z "$unit" -o 0$unit -gt 7 ]
	then
		echo bad disk unit: $i - $unit
		exit 127
	fi
	blk=18; chr=55;
	for name in vnd svnd; do
		case $name in
		vnd) off=0;;
		svnd) off=128;;
		esac
		rm -f {r,}${name}${unit}[a-p]
		minor=$(($unit * 16 + $off))
		for slice in a b c d e f g h i j k l m n o p
		do
			mknod ${name}${unit}${slice}  b $blk $minor
			mknod r${name}${unit}${slice} c $chr $minor
			minor=$(($minor + 1))
		done
		chown root.operator {r,}${name}${unit}?
		chmod 640 {r,}${name}${unit}?
d300 2
a301 1
	umask 77
d304 7
a310 33
hp*|hk*|up*|ra*|rl*|rb*|ccd*|hd*|sd*|rx*|raid*)
	umask 2
	case $i in
	hp*) name=hp;	unit=${i#hp};	blk=0; chr=4;;
	hk*) name=hk;	unit=${i#hk};	blk=3; chr=11;;
	up*) name=up;	unit=${i#up};	blk=2; chr=13;;
	raid*) name=raid; unit=${i#raid}; blk=25; chr=73;;
	ra*) name=ra;	unit=${i#ra};	blk=9;	chr=9;;
	rb*) name=rb;	unit=${i#rb};	blk=11; chr=23;;
	rx*) name=rx;	unit=${i#rx};	blk=12; chr=30;;
	rl*) name=rl;	unit=${i#rl};	blk=14; chr=32;;
	ccd*) name=ccd;	unit=${i#ccd};	blk=17; chr=54;;
	hd*) name=hd;	unit=${i#hd};	blk=19; chr=58;;
	sd*) name=sd;	unit=${i#sd};	blk=20; chr=59;;
	esac
	case $unit in
	[0-9]|[12][0-9]|3[01])
		minor=$(($unit * 16))
		rm -f {r,}${name}${unit}[a-p]
		for slice in a b c d e f g h i j k l m n o p
		do
			mknod ${name}${unit}${slice}  b $blk $minor
			mknod r${name}${unit}${slice} c $chr $minor
			minor=$(($minor + 1))
		done
		chgrp operator ${name}${unit}[a-p] r${name}${unit}[a-p]
		chmod 640 ${name}${unit}[a-p] r${name}${unit}[a-p]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
d313 2
a314 11
cd*)
	case $i in
	cd*) name=cd;   unit=${i#cd};   chr=61; blk=22;;
	esac
	rm -f {r,}${name}${unit}{a,c}
	mknod ${name}${unit}a   b $blk $(($unit * 16 + 0))
	mknod ${name}${unit}c   b $blk $(($unit * 16 + 2))
	mknod r${name}${unit}a  c $chr $(($unit * 16 + 0))
	mknod r${name}${unit}c  c $chr $(($unit * 16 + 2))
	chgrp operator {r,}${name}${unit}?
	chmod 640 {r,}${name}${unit}?
d317 2
a318 10
ss*)
	case $i in
	ss*) name=ss;   unit=${i#ss};   chr=64;;
	esac
	rm -f {,n,en}${name}${unit}
	mknod $name$unit	c $chr $(($unit * 16 + 0))
	mknod n$name$unit	c $chr $(($unit * 16 + 1))
	mknod en$name$unit	c $chr $(($unit * 16 + 3))
	chgrp operator {,n,en}${name}${unit}
	chmod 640 {,n,en}${name}${unit}
d321 6
a326 9
ch*|uk*)
	case $i in
	ch*) name=ch;   unit=${i#ch};   chr=63;;
	uk*) name=uk;   unit=${i#uk};   chr=65;;
	esac
	rm -f $name$unit
	mknod $name$unit        c $chr $unit
	chgrp operator $name$unit
	chmod 640 $name$unit
d329 2
a330 24
rd*)
	unit=${i#rd}; blk=23; chr=62;
	rm -f rd${unit}{a,c} #rrd${unit}{a,c}
	mknod rd${unit}a  b $blk $(($unit * 16 + 0)) 
	mknod rd${unit}c  b $blk $(($unit * 16 + 2)) 
#	mknod rrd${unit}a c $chr $(($unit * 16 + 0)) 
#	mknod rrd${unit}c c $chr $(($unit * 16 + 2)) 
	chgrp operator rd${unit}? #rrd${unit}?
	chmod 640 rd${unit}? #rrd${unit}?
	;;

uu*)
	unit=${i#uu}
	name=uu; blk=13;
	case $unit in
	[0-3])
		rm -f ${name}${unit}{,a}
		mknod ${name}${unit}	b $blk $(($unit * 2 + 0))
		mknod ${name}${unit}a	b $blk $(($unit * 2 + 1))
		;;
	*)
		echo bad unit for uu cassette in: $i
		;;
	esac
d333 2
a334 19
dz*)
	unit=${i#dz};
	case $unit in
	[0-7])
		i=0
		while [ $i -lt 8 ]; do
			no=$(($unit * 8 + $i))
			if [ $no -lt 10 ]; then
				no="0${no}"
			fi
			rm -f tty${no}
			mknod tty${no} c 1 $no
			i=$(($i + 1))
		done
		;;
	*)
		echo bad unit for dz in: $i
		;;
	esac
d337 2
a338 48
dhu*|dh*|dmf*|dmz*|vt*)
	case $i in
	vt*)	name=vt; major=68; count=8;
		unit=${i#vt}
		case $unit in
		0) ch=w ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dmz*)	name=dmz; major=37; count=24;
		unit=${i#dmz}
		case $unit in
		0) ch=a ;; 1) ch=b ;; 2) ch=c ;; 3) ch=e ;; 4) ch=f ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dmf*)	name=dmf; major=22; count=8;
		unit=${i#dmf}
		case $unit in
		0) ch=A ;; 1) ch=B ;; 2) ch=C ;; 3) ch=E ;;
		4) ch=F ;; 5) ch=G ;; 6) ch=H ;; 7) ch=I ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dhu*)	name=dhu; major=34; count=16;
		unit=${i#dhu}
		case $unit in
		0) ch=S ;; 1) ch=T ;; 2) ch=U ;; 3) ch=V ;;
		4) ch=W ;; 5) ch=X ;; 6) ch=Y ;; 7) ch=Z ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dh*)	name=dh; major=12; count=16;
		unit=${i#dh}
		case $unit in
		0) ch=h ;; 1) ch=i ;; 2) ch=j ;; 3) ch=k ;;
		4) ch=l ;; 5) ch=m ;; 6) ch=n ;; 7) ch=o ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	esac
	i=0
	while [ $i -lt $count ]; do
		let=${cnvtbl[$i]}
		if [ -n "$let" ] ;then
			rm -f tty${ch}${let}
			mknod tty${ch}${let} c $major $(($unit * $count + $i))
		else
			echo bad count for ${name}: $unit, $count, $i
		fi
		i=$(($i + 1))
	done

d341 9
a349 28
dl*)
	unit=${i#dl}
	major=66
	let=${cnvtbl[$unit]}
	if [ -n "$let" ] ;then
		rm -f ttyJ${let}
		mknod ttyJ${let} c $major $unit
	else
		echo bad number for ${name}: $unit
	fi
	;;

lp*|va*|vp*)
	case $i in
	lp*) name=lp; unit=${i#lp}; major=15;;
	va*) name=va; unit=${i#va}; major=10;;
	vp*) name=vp; unit=${i#vp}; major=6;;
	esac
	case $unit in
	[0-7])
		rm -f $i
		mknod $i c $major $unit;
		chmod 666 $i
		;;
	*)
		echo bad unit for $name in: $i
		;;
	esac
d353 18
a370 22
	class=${i#pty};
	case $class in
	0)	name=p;;
	1)	name=q;;
	2)	name=r;;
	3)	name=s;;
	4)	name=t;;
	5)	name=u;;
	6)	name=v
		echo "$0: $i: pty unit conflicts with another use."
		continue;;
	7)	name=w;;
	8)	name=x;;
	9)	name=y;;
	10)	name=z;;
	11)	name=P;;
	12)	name=Q;;
	13)	name=R;;
	14)	name=S;;
	15)	name=T;;
	*)	echo "$0: $i: pty unit must be between 0 and 15"
	        continue ;;
d372 2
a373 2
	rm -f tty$name[0-9a-f] pty$name[0-9a-f]
	for j in 0 1 2 3 4 5 6 7 8 9 a b c d e f
d375 4
a378 12
		case $j in
		[0-9])	jn=$j ;;
		a)	jn=10 ;;
		b)	jn=11 ;;
		c)	jn=12 ;;
		d)	jn=13 ;;
		e)	jn=14 ;;
		f)	jn=15 ;;
		esac
		unit=$(($class * 16 + $jn))
		mknod tty$name$j c 20 $unit
		mknod pty$name$j c 21 $unit
a379 2
	chgrp wheel tty$name? pty$name?
	chmod 666 tty$name? pty$name?
d382 35
a416 21
np*)
	class=${i#np}
	case $class in
	0)	offset=0  name=0;;
	1)	offset=16 name=1;;
	2)	offset=32 name=2;;
	*)	echo bad unit for np in: $i;;
	esac
	case $class in
	0|1|2)
	i=0
	while [ $i -lt 4 ]; do
		no=$(($offset + $i))
		if [ $no -lt 10 ]; then
			no="0${no}"
		fi
		rm -f np${no}
		mknod np${no} c 39 $no
		i=$(($i + 1))
	done
	esac
d419 4
a422 19
dn*|ik*|ps*|ad*|ct*)
	case $i in
	ct*) name=ct; unit=${i#ct}; chr=18;;
	dn*) name=cu; unit=${i#dn}; chr=24;;
	ps*) name=ps; unit=${i#ps}; chr=27;;
	ad*) name=ad; unit=${i#ad}; chr=29;;
	ik*) name=ik; unit=${i#ik}; chr=31;;
	esac
	case $unit in
	[0-7])
		umask 0
		rm -f ${name}${unit}
		mknod ${name}${unit} c ${chr} ${unit}
		umask 77
		;;
	*)
		echo bad unit for ${name} in: $i
		;;
	esac
d425 2
a426 20
bpf*)
	unit=${i#bpf};
	rm -f bpf$unit
	mknod bpf$unit c 56 $unit
	chmod 600 bpf$unit
	chown root.wheel bpf$unit
	;;

qd*)
	unit=${i#qd}
	rm -f q{c,d}$unit
	mknod qc$unit c 40 $(($unit * 4))
	mknod qd$unit c 40 $(($unit * 4 + 2))
	;;

pf)
	rm -f pf
	mknod pf c 42 0
	chown root.wheel pf
	chmod 600 pf
d429 2
a430 6
tun*)
	unit=${i#tun}
	rm -f tun$unit
	mknod tun$unit c 57 $unit
	chmod 600 tun$unit
	chown root.wheel tun$unit
d433 2
a434 18
lkm)
	rm -f lkm
	mknod lkm c 28 0
	chown root.kmem lkm
	chmod 640 lkm
	;;

qv0)
	rm -f qv0 qvcons mouse
	mknod qv0 c 40 0
	mknod qvcons c 40 1
	mknod mouse c 40 2
	;;

ttyv0)
	if [ ! -f ttyqe ]; then sh ./$0 pty1; fi
	mv ttyqf ttyv0
	mv ptyqf ptyv0
d437 7
a443 10
altq)
	mkdir -p altq
	chmod 755 altq
	unit=0
	for dev in altq cbq wfq afm fifoq red rio localq hfsc \
	    cdnr blue priq; do
		rm -f altq/$dev
		mknod altq/$dev c 75 $unit
		chmod 644 altq/$dev
		unit=$(($unit + 1))
d448 31
a478 3
	umask 0
	sh $0.local all
	umask 77
d480 1
d482 1
a482 1
	echo $i: invalid device
a483 1

d486 31
@


1.36
log
@sync
@
text
@d3 2
a4 2
# THIS FILE AUTOMATICALLY GENERATED.  DO NOT EDIT.
# generated from:
d6 1
a6 3
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.2 2002/02/09 16:59:50 deraadt Exp 
#	OpenBSD: MAKEDEV.mi,v 1.26 2002/02/10 21:52:30 deraadt Exp 
#	OpenBSD: MAKEDEV.sub,v 1.5 2002/01/23 06:02:19 todd Exp 
a7 25
#	$OpenBSD$
#
# Copyright (c) 2001 Todd T. Fries <todd@@OpenBSD.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
# THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

a8 2
#	all	makes all known devices, including local devices.
#		Tries to make the ``standard'' number of each type.
d11 1
a12 2
#	st*	SCSI tapes
#	mt*	(Magnetic) 9-track reel tape
d15 1
d18 2
d21 1
a21 1
#	hp*	massbuss rm??
d25 2
d28 4
a31 3
#	rx*	MSCP floppy disk (rx33/50/...)
#	rl*	unibus r102
#	hd*	HP300 HP-IB disks
d33 9
a41 10
#	cd*	SCSI cdrom drives
#	ch*	SCSI media changer
#	uk*	SCSI Unknown device
#	ss*	SCSI scanners
#	xy*	Xylogic 450/451 disks
#	rd*	"ramdisk" pseudo-disks
#	xd*	Xylogic 753/7053 disks
#	fd*	Floppy disk drives (3 1/2", 5 1/4")
#	vnd*	"file" pseudo-disks
#	ccd*	concatenated disk devices
d43 1
a43 2
#	tty*	set of 16 slave psuedo terminals
#	pty*	set of 16 master pseudo terminals
d45 6
a50 1
# Terminal ports:
d52 15
a66 13
#	audio*	audio device
#	openprom	
#	bpf*	Berkeley Packet Filter
#	pf*	Packet Filter
#	altq/	ALTQ control interface
#	lkm	loadable kernel modules interface
#	tun*	network tunnel driver
#	*random	inkernel random data source
#	magma*	magma card (makes 16 tty and 2 bpp)
#	xfs*	XFS filesystem devices
#	raid*	RAIDframe disk devices
#	fd	makes fd/* for the fdescfs
#	ses*	SES/SAF-TE SCSI devices
d68 5
a72 1
T=$0
d74 7
a80 2
# set this to echo for Echo-Only debugging
[ "$eo" ] || eo=
d82 4
a85 40
hex()
{
	case $1 in
	[0-9]) echo -n $1;;
	10) echo -n a;;
	11) echo -n b;;
	12) echo -n c;;
	13) echo -n d;;
	14) echo -n e;;
	15) echo -n f;;
	esac
}

trunc()
{
	# XXX pdksh can't seem to deal with locally scoped variables
	# in ${foo#$bar} expansions
	arg1="$1"
	arg2="$2"
	case $3 in
	l)   echo ${arg2#$arg1} ;;
	r|*) echo ${arg1#$arg2} ;;
	esac
}

unt()
{
	# XXX pdksh can't seem to deal with locally scoped variables
	# in ${foo#$bar} expansions
	arg="$1"
	tmp="${arg#[a-zA-Z]*}"
	tmp="${tmp%*[a-zA-Z]}"
	while [ "$tmp" != "$arg" ]
	do
		arg=$tmp
		tmp="${arg#[a-zA-Z]*}"
		tmp="${tmp%*[a-zA-Z]}"
	done
	echo $arg
}
a86 67
dodisk()
{
	[ "$DEBUG" ] && set -x
	n=$(($((${5}*${7:-16}))+${6})) count=0
	RMlist="$RMlist $1$2? r$1$2?"
	[ 0$7 -ne 8 ] && l="i j k l m n o p"
	for d in a b c d e f g h $l
	do
		M $1$2$d	b $3 $(($n+$count)) 640
		M r$1$2$d	c $4 $(($n+$count)) 640
		let count=count+1
	done
	MKlist="$MKlist;chown root.operator $1$2? r$1$2?"
}

dodisk2()
{
	n=$(($(($5*${7:-16}))+$6))
	M $1$2a b $3 $n 640 operator
	M r$1$2a c $4 $n 640 operator
	n=$(($n+2))
	M $1$2c b $3 $n 640 operator
	M r$1$2c c $4 $n 640 operator
}

# M name b/c major minor [mode] [group]
RMlist="rm -f"
MKlist=":"

mkl() {
	[ "${mklist[$1]}" ] && {
		mklist[$1]="${mklist[$1]};mknod -m $1 $2 $3 $4 $5"
	} || {
		mklist[$1]="mknod -m $1 $2 $3 $4 $5"
		modes="$modes $1"
	}
}

M() {
	RMlist="$RMlist $1"
	mkl ${5-666} $1 $2 $3 $4
	mklist="$mklist $1"
	G=${6:-wheel}
	[ "$7" ] && {
		MKlist="$MKlist;chown $7.$G $1"
	} || {
		case $G in
		wheel)g=0;;kmem)g=2;;operator)g=5;;tty)g=4;;dialer)g=117;;
		esac
		[ "${grplist[$g]}" ] && {
			grplist[$g]="${grplist[$g]} $1"
		} || {
			groups="$groups $g"
			grplist[$g]="chgrp $G $1"
		}
	}
	return 0
}

R() {
[ "$DEBUG" ] && set -x
for i in "$@@"
do
U=`unt $i`
[ "$U" ] || U=0

case $i in
d88 3
a90 2
	R std random
	R fd0 sd0 sd1 rd0
d94 39
a132 22
	M console	c 0 0 600
	M tty		c 2 0
	M mem		c 3 0 640 kmem
	M kmem		c 3 1 640 kmem
	M null		c 3 2
	M zero		c 3 12
	M stdin		c 53 0
	M stdout	c 53 1
	M stderr	c 53 2
	M ksyms		c 50 0 640 kmem
	M drum		c 7 0 640 kmem
	M klog		c 33 0 600
	M ttyg0		c 25 0
	M ttyg1		c 25 1
	M ttyg2		c 25 2
	M ttyg3		c 25 3
	M crl		c 35 0
	M csa1		c 51 0
	M csa2		c 51 1
	M tu0		b 8 0
	M tu1		b 8 1
	M kUmem		c 3 3 660
d137 5
a141 5
	ht*) n=ht b=1 c=5;;
	mt*) n=mt b=15 c=38;;
	tm*) n=tm b=5 c=14;;
	ts*) n=ts b=6 c=16;;
	ut*) n=ut b=10 c=17;;
d143 1
a143 1
	case $U in
d145 22
a166 15
		four=$(($U+4)) eight=$(($U+8))
		twelve=$(($U+12)) twenty=$(($U+20))
		M $n$U		b $b $U	660 operator
		M $n$four	b $b $four	660 operator
		M $n$eight	b $b $eight	660 operator
		M $n$twelve	b $b $twelve	660 operator
		M n$n$four	b $b $four	660 operator
		M n$n$twelve	b $b $twelve	660 operator
		M nr$n$four	c $c $four	660 operator
		M nr$n$twelve	c $c $twelve	660 operator
		M r$n$U		c $c $U		660 operator
		M r$n$four	c $c $four	660 operator
		M r$n$eight	c $c $eight	660 operator
		M r$n$twelve	c $c $twelve	660 operator
		if [ $i = ut ]; : XXXX
d168 5
a172 2
			M $n$twenty	b $b $twenty 660 operator
			M r$n$twenty	c $b $twenty 660 operator
d174 42
a215 4
		#RMlist="$RMlist mt$U mt$four mt$eight mt$twelve"
		#RMlist="$RMlist nmt$U nmt$eight nrmt$eight"
		#RMlist="$RMlist nrmt$unit nrmt$eight"
		#RMlist="$RMlist rmt$unit rmt$four rmt$eight rmt$twelve"
d218 1
a218 1
		echo bad unit for tape in: $i
d224 35
a258 2
ses*)
	M ses$U c 124 $U 640 operator
d261 9
a269 4
fd)
	RMlist="mkdir -p fd;$RMlist" n=0
	while [ $n -lt 64 ];do M fd/$n c 53 $n;n=$(($n+1));done
	MKlist="$MKlist;chmod 555 fd"
d272 26
a297 2
xfs*)
	M xfs$U c 51 $U 600
d300 31
a330 6
magma*)
	case $U in
	0)	offset=0  nam=m;;
	1)	offset=16 nam=n;;
	2)	offset=32 nam=o;;
	*)	echo "bad unit for $i: $U"; exit 127;;
d332 1
a332 10
	offset=$(($U*64))
	n=0
	while [ $n -lt 16 ]
	do
		name=${nam}`hex $n`
		M tty$name c major_mag_c $(($offset+$n)) 660 dialer uucp
		n=$(($n+1))
	done
	M bpp${nam}0 c major_bppmag_c $(($offset+0)) 600
	M bpp${nam}1 c major_bppmag_c $(($offset+1)) 600
d335 11
a345 7
*random)
	n=0
	for pre in " " s u p a
	do
		M ${pre}random c 119 $n 644
		n=$(($n+1))
	done
d348 10
a357 2
tun*)
	M tun$U c 111 $U 600
d360 9
a368 2
lkm)
	M lkm c 112 0 640 kmem
d371 24
a394 6
altq)
	RMlist="mkdir -p altq;$RMlist"
	for d in altq cbq wfq afm fifoq red rio localq hfsc cdnr blue priq; do
		M altq/$d c 75 $U 644
		U=$(($U+1))
	done
d397 19
a415 2
pf*)
	M pf c 42 0 600
d418 48
a465 2
bpf*)
	M bpf$U c 56 $U 600
d468 10
a477 2
openprom)
	M openprom c 70 0  
d480 16
a495 9
audio*)
	M sound$U	c 69 $U
	M mixer$U	c 69 $(($U+16))
	M audio$U	c 69 $(($U+128))
	M audioctl$U	c 69 $(($U+192))
	MKlist="$MKlist;[ -e audio ] || ln -s audio$U audio"
	MKlist="$MKlist;[ -e mixer ] || ln -s mixer$U mixer"
	MKlist="$MKlist;[ -e sound ] || ln -s sound$U sound"
	MKlist="$MKlist;[ -e audioctl ] || ln -s audioctl$U audioctl"
d499 22
a520 18
	case $U in
	0) off=0 name=p;;
	1) off=16 name=q;;
	2) off=32 name=r;;
	3) off=48 name=s;;
	4) off=64 name=t;;
	5) off=80 name=u;;
	6) off=96 name=v;;
	7) off=112 name=w;;
	8) off=128 name=x;;
	9) off=144 name=y;;
	10) off=160 name=z;;
	11) off=176 name=P;;
	12) off=192 name=Q;;
	13) off=206 name=R;;
	14) off=224 name=S;;
	15) off=240 name=T;;
	*) echo bad unit for pty in: $i; continue;;
d522 2
a523 2
	n=0
	while [ $n -lt 16 ]
d525 12
a536 4
		nam=$name$(hex $n)
		M tty$nam c 20 $(($off+$n))
		M pty$nam c 21 $(($off+$n))
		n=$(($n+1))
d538 2
d542 21
a562 3
vnd*)
	dodisk vnd $U 8 55 $U 0
	dodisk svnd $U 8 55 $U 128
d565 19
a583 26
fd*)
	typnam=$U${i#fd[01]*}
	case $typnam in
	0|1)	typnum=0;; # no type specified, assume A
	*A)	typnum=0; typnam=0;;
	*B)	typnum=1;;
	*C)	typnum=2;;
	*D)	typnum=3;;
	*E)	typnum=4;;
	*F)	typnum=5;;
	*G)	typnum=6;;
	*H)	typnum=7;;
	*)	echo bad type $typnam for $i; exit 1;;
	esac
	case $U in
	0|1)	blk=16; chr=54;;
	*)	echo bad unit $U for $i; exit 1;;
	esac
	nam=fd${typnam}
	n=$(($(($U*128))+$(($typnum*16))))
	M ${nam}a	b $blk $n 640 operator
	M ${nam}b	b $blk $(($n+1)) 640 operator
	M ${nam}c	b $blk $(($n+2)) 640 operator
	M r${nam}a	c $chr $n 640 operator
	M r${nam}b	c $chr $(($n+1)) 640 operator
	M r${nam}c	c $chr $(($n+2)) 640 operator
d586 20
a605 2
rd*)
	dodisk2 rd $U 23 106 $U 0
d608 6
a613 4
ss*)
	M ss$U c 121 $U 440 operator
	RMlist="$RMlist scan$U"
	MKlist="$MKlist;umask 77;ln -s ss$U scan$U"
d616 18
a633 2
uk*)
	M uk$U c 120 $U 640 operator
d636 10
a645 15
ch*)
	M ch$U c 19 $U 660 operator
	;;

cd*)
	dodisk2 cd $U 22 58 $U 0
	;;

st*)
	n=$(($U*16))
	for pre in " " n e en
	do
		M ${pre}st$U	b 21 $n 660 operator
		M ${pre}rst$U	c 38 $n 660 operator
		n=$(($n+1))
d650 3
a652 1
	test -s $T.local && sh $T.local
d654 2
a655 11

all)
	R audio0 xfs0 ss0 ss1 uk0 ses0 rndrandom lkm pf altq tun0
	R tun1 tun2 tun3 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7 bpf8
	R bpf9 fd1 fd1B fd1C fd1D fd1E fd1F fd1G fd1H fd0 fd0B fd0C
	R fd0D fd0E fd0F fd0G fd0H xd0 xd1 xd2 xd3 xy0 xy1 xy2 xy3 ut0
	R up0 up1 up2 up3 ts0 tm0 rx0 rx1 rl0 rl1 rl2 rl3 rb0 rb1 rb2
	R rb3 ra0 ra1 ra2 ra3 ht0 hp0 hp1 hp2 hp3 hk0 hk1 hk2 hk3 rd0
	R hd0 hd1 hd2 hd3 hd4 raid0 raid1 raid2 raid3 ccd0 ccd1 ccd2
	R ccd3 vnd0 vnd1 vnd2 vnd3 std cd0 cd1 ch0 st0 st1 pty0 pty1
	R fd sd0 sd1 sd2 sd3 sd4
a657 21
up*|xd*|xy*|sd*|rx*|rl*|rb*|raid*|ra*|hp*|hk*|hd*|ccd*)
	case $i in
	up*) dodisk up $U 2 13 $U 0;;
	xd*) dodisk xd $U 10 42 $U 0;;
	xy*) dodisk xy $U 3 9 $U 0;;
	sd*) dodisk sd $U 20 59 $U 0;;
	rx*) dodisk rx $U 12 30 $U 0;;
	rl*) dodisk rl $U 14 32 $U 0;;
	rb*) dodisk rb $U 11 23 $U 0;;
	raid*) dodisk raid $U 25 73 $U 0;;
	ra*) dodisk ra $U 9 9 $U 0;;
	hp*) dodisk hp $U 0 4 $U 0;;
	hk*) dodisk hk $U 3 11 $U 0;;
	hd*) dodisk hd $U 19 58 $U 0;;
	ccd*) dodisk ccd $U 17 54 $U 0;;
	esac
	;;

*)
	echo $i: unknown device
	;;
a659 31
}
R "$@@"
if [ "$os" = "SunOS" ]; then
	eo=transform
	transform() {
		case $mode in
		600) mask=077;;
		640) mask=027;;
		660) mask=007;;
		644) mask=022;;
		666) mask=0;;
		440) mask=227;;
		esac
		echo `echo "$@@"|sed \
		    's/mknod -m \([0-9]*\) /umask '$mask';mknod /;s/-m [0-9]* //g;\
		    s/operator/5/g;s/root.kmem/root.2/g;s/root\./root:/g'`
	}
fi
list="$RMlist"
for mode in $modes; do
	list="$list;${mklist[$mode]}"
done
for group in $groups; do
	list="$list;${grplist[$group]}"
done
list="$list;$MKlist"
if [ "$eo" = "echo" -o "$eo" = "transform" ]; then
	$eo "$list"
else
	echo "$list" | sh
fi
@


1.35
log
@not ready for MAKEDEV.md
@
text
@d3 2
a4 2
#	$OpenBSD: MAKEDEV,v 1.33 2001/12/07 03:08:51 hugh Exp $
#	$NetBSD: MAKEDEV,v 1.30 2000/01/21 12:28:29 tsutsui Exp $
d6 3
a8 1
#	@@(#)MAKEDEV	8.1 (Berkeley) 6/9/93
d10 25
d36 2
a39 1
#	all	create a reasonable amount of all files
d41 2
a44 1
#	mt*	MSCP tapes (e.g. TU81, TK50)
a46 2
#	uu*	tu58 cassettes on dl11 controller
#	st*	SCSI tapes
d48 1
a48 1
#	hp*	massbus rm??
d52 1
d54 11
a64 4
#	rl*	unibus rl02
#	rb*	730 idc w/ rb80 and/or rb02
#	ccd*	"concatenated" pseudo-disks
#	raid*	RAIDframe disk driver
d66 1
a66 11
#	rd*	memory pseudo-disk devices
#	sd*	SCSI disks
#	cd*	SCSI CD-ROM
#	hd*	HDC9224 hd disks on VS2000
# Terminal multiplexors:
#	dz*	unibus dz11 and dz32
#	dh*	unibus dh11 and emulations (e.g. Able dmax, Emulex cs-11)
#	dmf*	unibus dmf32
#	dhu*    unibus dhu11
#	dmz*    unibus dmz32
#	dl*	unibus dl11
d68 2
a69 1
#	pty*	set of 16 master and slave pseudo terminals
d71 1
a71 6
#	ct*	unibus parallel interface to CAT typesetter
#	lp*	unibus lp11 parallel interface
#	va*	unibus varian parallel interface
#	vp*	unibus versatec parallel interface
# Call units:
#	dn*	unibus dn11 and emulations (e.g. Able Quadracall)
d73 13
a85 15
#	ik*	unibus interface to ikonas frame buffer
#	ps*	unibus interface to e&s picture system 2
#	ad*	unibus interface to data translation a/d converter
#	np*	unibus ethernet co-processor interface, for downloading.
#	qv*	qvss (microvax) display
#	ttyv0	qvss (microvax) display reserved pty
#	lkm	loadable kernel modules
#	bpf*	berkeley packet filter
#	tun*	network tunnel device
#	ss*	SCSI scanner
#	uk*	SCSI unknown
#	ch*	SCSI changer
#	*random	Random number generator
#	altq	ALTQ control interface
#
d87 45
a131 5
set -A cnvtbl 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v
umask 77
for i
do
case $i in
d133 14
a146 7
all)
	sh $0 std fd vnd0 ccd0 pty0 pty1 lkm random altq
	sh $0 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7 pf tun0 tun1
	sh $0 mt0 mt1 ts0 ts1 st0 st1 uk0 ss0 cd0 vt0
	sh $0 ra0 ra1 ra2 ra3 hp0 hp1 hp2 hp3 sd0 sd1 sd2 sd3 hd0 hd1 hd2
	sh $0 dz0 dl0 dhu0 rx0 rx1 raid0 raid1 raid2 raid3
	;;
d148 50
a197 4
floppy)
	sh $0 std random
	sh $0 sd0 sd1
	;;
d199 1
d201 2
a202 3
	sh $0 std random
	sh $0 rd0 sd0 sd1 sd2 sd3 ra0 ra1 ra2 rx0 cd0 st0 st1
	sh $0 bpf0
d206 22
a227 39
	rm -f console drum floppy crl csa1 csa2 tu0 tu1
	rm -f kUmem kmem mem null zero tty klog ttyg[0-3]
	rm -f stdin stdout stderr ksyms
	mknod console		c 0 0
	mknod ttyg0		c 25 0
	mknod ttyg1		c 25 1
	mknod ttyg2		c 25 2
	mknod ttyg3		c 25 3
	mknod drum		c 7 0	; chmod 640 drum ; chgrp kmem drum
	mknod floppy		c 8 0
	mknod crl		c 35 0
	mknod csa1		c 51 0
	mknod csa2		c 51 1
	mknod tu0		b 8 0
	mknod tu1		b 8 1
	mknod kUmem		c 3 3	; chmod 600 kUmem
	mknod kmem		c 3 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 3 0	; chmod 640 mem ; chgrp kmem mem
	mknod null		c 3 2	; chmod 666 null
	mknod zero		c 3 12  ; chmod 666 zero
	mknod tty		c 2 0	; chmod 666 tty
	mknod klog		c 33 0	; chmod 600 klog
	mknod stdin		c 53 0	; chmod 666 stdin
	mknod stdout		c 53 1	; chmod 666 stdout
	mknod stderr		c 53 2	; chmod 666 stderr
	mknod ksyms		c 50 0	; chmod 640 ksyms ; chown root.kmem ksyms
	;;

fd)
	rm -f fd/*
	mkdir fd > /dev/null 2>&1
	n=0
	while [ $n -lt 64 ]; do
		mknod fd/$n c 53 $n
		n=$(($n + 1))
	done
	chown -R root.wheel fd
	chmod 755 fd
	chmod 666 fd/*
d232 5
a236 5
	ht*) name=ht;	unit=${i#ht};	blk=1; chr=5 ;;
	mt*) name=mt;	unit=${i#mt};	blk=15;	chr=38;;
	tm*) name=tm;	unit=${i#tm};	blk=5; chr=14;;
	ts*) name=ts;	unit=${i#ts};	blk=6; chr=16;;
	ut*) name=ut;	unit=${i#ut};	blk=10; chr=17;;
d238 1
a238 1
	case $unit in
d240 15
a254 22
		four=$(($unit + 4)) ; eight=$(($unit + 8))
		twelve=$(($unit + 12)) ; twenty=$(($unit + 20))
		rm -f $name$unit $name$four $name$eight $name$twelve \
		    n$name$unit n$name$eight nr$name$unit nr$name$eight \
		    r$name$unit r$name$four r$name$eight r$name$twelve
		mknod $name$unit	b $blk $unit
		mknod $name$four	b $blk $four
		mknod $name$eight	b $blk $eight
		mknod $name$twelve	b $blk $twelve
		mknod n$name$unit	b $blk $four ;: sanity w/pdp11 v7
		mknod n$name$eight	b $blk $twelve ;: ditto
		mknod nr$name$unit	c $chr $four ;: sanity w/pdp11 v7
		mknod nr$name$eight	c $chr $twelve ;: ditto
		mknod r$name$unit	c $chr $unit
		mknod r$name$four	c $chr $four
		mknod r$name$eight	c $chr $eight
		mknod r$name$twelve	c $chr $twelve
		chown root.operator {,n,r,nr}$name{$unit,$eight}
		chown root.operator {,r}$name{$four,$twelve}
		chmod 660 {,n,r,nr}$name{$unit,$eight}
		chmod 660 {,r}$name{$four,$twelve}
		if [ $i = ut ] 
d256 2
a257 23
			rm -f $name$twenty r$name$twenty
			mknod $name$twenty	b $blk $twenty
			mknod r$name$twenty	c $chr $twenty
			chown root.operator {,r}$name$twenty
			chmod 660 {,r}$name$twenty
		fi
		if [ ! -e rmt$eight ]	# compatibility stuff
		then
			rm -f mt$unit mt$four mt$eight mt$twelve \
			    nmt$unit nmt$eight nrmt$unit nrmt$eight \
			    rmt$unit rmt$four rmt$eight rmt$twelve
			ln -s $name$unit mt$unit
			ln -s $name$four mt$four
			ln -s $name$eight mt$eight
			ln -s $name$twelve mt$twelve
			ln -s n$name$unit nmt$unit
			ln -s n$name$eight nmt$eight
			ln -s nr$name$unit nrmt$unit
			ln -s nr$name$eight nrmt$eight
			ln -s r$name$unit rmt$unit
			ln -s r$name$four rmt$four
			ln -s r$name$eight rmt$eight
			ln -s r$name$twelve rmt$twelve
d259 4
d265 1
a265 1
		echo bad unit for tape in: $1
d271 2
a272 22
st*)
	umask 2
	unit=${i#st};	blk=21; chr=60;
	case $unit in
	0|1|2|3|4|5|6|7)
		rm -f {e,}{n,}{r,}st${unit}
		mknod st${unit}		b $blk $(($unit * 16 + 0))
		mknod nst${unit}	b $blk $(($unit * 16 + 1))
		mknod est${unit}	b $blk $(($unit * 16 + 2))
		mknod enst${unit}	b $blk $(($unit * 16 + 3))
		mknod rst${unit}	c $chr $(($unit * 16 + 0))
		mknod nrst${unit}	c $chr $(($unit * 16 + 1))
		mknod erst${unit}	c $chr $(($unit * 16 + 2))
		mknod enrst${unit}	c $chr $(($unit * 16 + 3))
		chown root.operator {e,}{n,}{r,}st${unit}
		chmod 660 {e,}{n,}{r,}st${unit}
		;;
	*)
		echo bad tape unit: $i - $unit
		;;
	esac
	umask 77
d275 4
a278 35
mt*)
	umask 0 ; unit=`expr $i : '..\(.*\)'`
	case $i in
	mt*) blk=7; chr=19;;
	esac
	case $unit in
	0|1|2|3|4|5|6|7)
		eight=`expr $unit + 0`;
		twelve=`expr $unit + 4`; 
		sixteen=`expr $unit + 8`;
		twenty=`expr $unit + 12`;
		rm -f mt8 mt12 mt16 mt20 nmt8 nrmt8 rmt8 rmt12 rmt16 rmt20
		rm -f nmt16 nrmt16
		mknod mt8		b $blk $eight
		mknod mt12		b $blk $twelve
		mknod mt16		b $blk $sixteen
		mknod mt20		b $blk $twenty
		mknod nmt8		b $blk $twelve ;: ditto
		mknod nrmt8		c $chr $twelve ;: ditto
		mknod rmt8		c $chr $eight
		mknod rmt12		c $chr $twelve
		mknod rmt16		c $chr $sixteen
		mknod rmt20		c $chr $twenty
		mknod nmt16		b $blk $twenty ;: ditto
		mknod nrmt16		c $chr $twenty ;: ditto
		chown root.operator {,n,r,nr}mt{8,16}
		chown root.operator {,r}mt{12,20}
		chmod 660 {,n,r,nr}mt{8,16}
		chmod 660 {,r}mt{12,20}
		;;
	*)
		echo bad unit for tape in: $1
		;;
	esac
	umask 77
d281 2
a282 9
random|srandom|urandom|prandom|arandom)
	rm -f random urandom srandom prandom arandom
	mknod  random c 67 0
	mknod srandom c 67 1
	mknod urandom c 67 2
	mknod prandom c 67 3
	mknod arandom c 67 4
	chown root.wheel random srandom urandom prandom arandom
	chmod 644 random srandom urandom prandom arandom
d285 14
a298 24
vnd*)
	umask 2
	unit=${i#vnd}
	if [ -z "$unit" -o 0$unit -gt 7 ]
	then
		echo bad disk unit: $i - $unit
		exit 127
	fi
	blk=18; chr=55;
	for name in vnd svnd; do
		case $name in
		vnd) off=0;;
		svnd) off=128;;
		esac
		rm -f {r,}${name}${unit}[a-p]
		minor=$(($unit * 16 + $off))
		for slice in a b c d e f g h i j k l m n o p
		do
			mknod ${name}${unit}${slice}  b $blk $minor
			mknod r${name}${unit}${slice} c $chr $minor
			minor=$(($minor + 1))
		done
		chown root.operator {r,}${name}${unit}?
		chmod 640 {r,}${name}${unit}?
d300 2
a301 1
	umask 77
d304 7
a310 33
hp*|hk*|up*|ra*|rl*|rb*|ccd*|hd*|sd*|rx*|raid*)
	umask 2
	case $i in
	hp*) name=hp;	unit=${i#hp};	blk=0; chr=4;;
	hk*) name=hk;	unit=${i#hk};	blk=3; chr=11;;
	up*) name=up;	unit=${i#up};	blk=2; chr=13;;
	raid*) name=raid; unit=${i#raid}; blk=25; chr=73;;
	ra*) name=ra;	unit=${i#ra};	blk=9;	chr=9;;
	rb*) name=rb;	unit=${i#rb};	blk=11; chr=23;;
	rx*) name=rx;	unit=${i#rx};	blk=12; chr=30;;
	rl*) name=rl;	unit=${i#rl};	blk=14; chr=32;;
	ccd*) name=ccd;	unit=${i#ccd};	blk=17; chr=54;;
	hd*) name=hd;	unit=${i#hd};	blk=19; chr=58;;
	sd*) name=sd;	unit=${i#sd};	blk=20; chr=59;;
	esac
	case $unit in
	[0-9]|[12][0-9]|3[01])
		minor=$(($unit * 16))
		rm -f {r,}${name}${unit}[a-p]
		for slice in a b c d e f g h i j k l m n o p
		do
			mknod ${name}${unit}${slice}  b $blk $minor
			mknod r${name}${unit}${slice} c $chr $minor
			minor=$(($minor + 1))
		done
		chgrp operator ${name}${unit}[a-p] r${name}${unit}[a-p]
		chmod 640 ${name}${unit}[a-p] r${name}${unit}[a-p]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
d313 2
a314 11
cd*)
	case $i in
	cd*) name=cd;   unit=${i#cd};   chr=61; blk=22;;
	esac
	rm -f {r,}${name}${unit}{a,c}
	mknod ${name}${unit}a   b $blk $(($unit * 16 + 0))
	mknod ${name}${unit}c   b $blk $(($unit * 16 + 2))
	mknod r${name}${unit}a  c $chr $(($unit * 16 + 0))
	mknod r${name}${unit}c  c $chr $(($unit * 16 + 2))
	chgrp operator {r,}${name}${unit}?
	chmod 640 {r,}${name}${unit}?
d317 2
a318 10
ss*)
	case $i in
	ss*) name=ss;   unit=${i#ss};   chr=64;;
	esac
	rm -f {,n,en}${name}${unit}
	mknod $name$unit	c $chr $(($unit * 16 + 0))
	mknod n$name$unit	c $chr $(($unit * 16 + 1))
	mknod en$name$unit	c $chr $(($unit * 16 + 3))
	chgrp operator {,n,en}${name}${unit}
	chmod 640 {,n,en}${name}${unit}
d321 6
a326 9
ch*|uk*)
	case $i in
	ch*) name=ch;   unit=${i#ch};   chr=63;;
	uk*) name=uk;   unit=${i#uk};   chr=65;;
	esac
	rm -f $name$unit
	mknod $name$unit        c $chr $unit
	chgrp operator $name$unit
	chmod 640 $name$unit
d329 2
a330 24
rd*)
	unit=${i#rd}; blk=23; chr=62;
	rm -f rd${unit}{a,c} #rrd${unit}{a,c}
	mknod rd${unit}a  b $blk $(($unit * 16 + 0)) 
	mknod rd${unit}c  b $blk $(($unit * 16 + 2)) 
#	mknod rrd${unit}a c $chr $(($unit * 16 + 0)) 
#	mknod rrd${unit}c c $chr $(($unit * 16 + 2)) 
	chgrp operator rd${unit}? #rrd${unit}?
	chmod 640 rd${unit}? #rrd${unit}?
	;;

uu*)
	unit=${i#uu}
	name=uu; blk=13;
	case $unit in
	[0-3])
		rm -f ${name}${unit}{,a}
		mknod ${name}${unit}	b $blk $(($unit * 2 + 0))
		mknod ${name}${unit}a	b $blk $(($unit * 2 + 1))
		;;
	*)
		echo bad unit for uu cassette in: $i
		;;
	esac
d333 2
a334 19
dz*)
	unit=${i#dz};
	case $unit in
	[0-7])
		i=0
		while [ $i -lt 8 ]; do
			no=$(($unit * 8 + $i))
			if [ $no -lt 10 ]; then
				no="0${no}"
			fi
			rm -f tty${no}
			mknod tty${no} c 1 $no
			i=$(($i + 1))
		done
		;;
	*)
		echo bad unit for dz in: $i
		;;
	esac
d337 2
a338 48
dhu*|dh*|dmf*|dmz*|vt*)
	case $i in
	vt*)	name=vt; major=68; count=8;
		unit=${i#vt}
		case $unit in
		0) ch=w ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dmz*)	name=dmz; major=37; count=24;
		unit=${i#dmz}
		case $unit in
		0) ch=a ;; 1) ch=b ;; 2) ch=c ;; 3) ch=e ;; 4) ch=f ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dmf*)	name=dmf; major=22; count=8;
		unit=${i#dmf}
		case $unit in
		0) ch=A ;; 1) ch=B ;; 2) ch=C ;; 3) ch=E ;;
		4) ch=F ;; 5) ch=G ;; 6) ch=H ;; 7) ch=I ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dhu*)	name=dhu; major=34; count=16;
		unit=${i#dhu}
		case $unit in
		0) ch=S ;; 1) ch=T ;; 2) ch=U ;; 3) ch=V ;;
		4) ch=W ;; 5) ch=X ;; 6) ch=Y ;; 7) ch=Z ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dh*)	name=dh; major=12; count=16;
		unit=${i#dh}
		case $unit in
		0) ch=h ;; 1) ch=i ;; 2) ch=j ;; 3) ch=k ;;
		4) ch=l ;; 5) ch=m ;; 6) ch=n ;; 7) ch=o ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	esac
	i=0
	while [ $i -lt $count ]; do
		let=${cnvtbl[$i]}
		if [ -n "$let" ] ;then
			rm -f tty${ch}${let}
			mknod tty${ch}${let} c $major $(($unit * $count + $i))
		else
			echo bad count for ${name}: $unit, $count, $i
		fi
		i=$(($i + 1))
	done

d341 9
a349 28
dl*)
	unit=${i#dl}
	major=66
	let=${cnvtbl[$unit]}
	if [ -n "$let" ] ;then
		rm -f ttyJ${let}
		mknod ttyJ${let} c $major $unit
	else
		echo bad number for ${name}: $unit
	fi
	;;

lp*|va*|vp*)
	case $i in
	lp*) name=lp; unit=${i#lp}; major=15;;
	va*) name=va; unit=${i#va}; major=10;;
	vp*) name=vp; unit=${i#vp}; major=6;;
	esac
	case $unit in
	[0-7])
		rm -f $i
		mknod $i c $major $unit;
		chmod 666 $i
		;;
	*)
		echo bad unit for $name in: $i
		;;
	esac
d353 18
a370 22
	class=${i#pty};
	case $class in
	0)	name=p;;
	1)	name=q;;
	2)	name=r;;
	3)	name=s;;
	4)	name=t;;
	5)	name=u;;
	6)	name=v
		echo "$0: $i: pty unit conflicts with another use."
		continue;;
	7)	name=w;;
	8)	name=x;;
	9)	name=y;;
	10)	name=z;;
	11)	name=P;;
	12)	name=Q;;
	13)	name=R;;
	14)	name=S;;
	15)	name=T;;
	*)	echo "$0: $i: pty unit must be between 0 and 15"
	        continue ;;
d372 2
a373 2
	rm -f tty$name[0-9a-f] pty$name[0-9a-f]
	for j in 0 1 2 3 4 5 6 7 8 9 a b c d e f
d375 4
a378 12
		case $j in
		[0-9])	jn=$j ;;
		a)	jn=10 ;;
		b)	jn=11 ;;
		c)	jn=12 ;;
		d)	jn=13 ;;
		e)	jn=14 ;;
		f)	jn=15 ;;
		esac
		unit=$(($class * 16 + $jn))
		mknod tty$name$j c 20 $unit
		mknod pty$name$j c 21 $unit
a379 2
	chgrp wheel tty$name? pty$name?
	chmod 666 tty$name? pty$name?
d382 35
a416 21
np*)
	class=${i#np}
	case $class in
	0)	offset=0  name=0;;
	1)	offset=16 name=1;;
	2)	offset=32 name=2;;
	*)	echo bad unit for np in: $i;;
	esac
	case $class in
	0|1|2)
	i=0
	while [ $i -lt 4 ]; do
		no=$(($offset + $i))
		if [ $no -lt 10 ]; then
			no="0${no}"
		fi
		rm -f np${no}
		mknod np${no} c 39 $no
		i=$(($i + 1))
	done
	esac
d419 4
a422 19
dn*|ik*|ps*|ad*|ct*)
	case $i in
	ct*) name=ct; unit=${i#ct}; chr=18;;
	dn*) name=cu; unit=${i#dn}; chr=24;;
	ps*) name=ps; unit=${i#ps}; chr=27;;
	ad*) name=ad; unit=${i#ad}; chr=29;;
	ik*) name=ik; unit=${i#ik}; chr=31;;
	esac
	case $unit in
	[0-7])
		umask 0
		rm -f ${name}${unit}
		mknod ${name}${unit} c ${chr} ${unit}
		umask 77
		;;
	*)
		echo bad unit for ${name} in: $i
		;;
	esac
d425 2
a426 20
bpf*)
	unit=${i#bpf};
	rm -f bpf$unit
	mknod bpf$unit c 56 $unit
	chmod 600 bpf$unit
	chown root.wheel bpf$unit
	;;

qd*)
	unit=${i#qd}
	rm -f q{c,d}$unit
	mknod qc$unit c 40 $(($unit * 4))
	mknod qd$unit c 40 $(($unit * 4 + 2))
	;;

pf)
	rm -f pf
	mknod pf c 42 0
	chown root.wheel pf
	chmod 600 pf
d429 2
a430 6
tun*)
	unit=${i#tun}
	rm -f tun$unit
	mknod tun$unit c 57 $unit
	chmod 600 tun$unit
	chown root.wheel tun$unit
d433 2
a434 18
lkm)
	rm -f lkm
	mknod lkm c 28 0
	chown root.kmem lkm
	chmod 640 lkm
	;;

qv0)
	rm -f qv0 qvcons mouse
	mknod qv0 c 40 0
	mknod qvcons c 40 1
	mknod mouse c 40 2
	;;

ttyv0)
	if [ ! -f ttyqe ]; then sh ./$0 pty1; fi
	mv ttyqf ttyv0
	mv ptyqf ptyv0
d437 7
a443 10
altq)
	mkdir -p altq
	chmod 755 altq
	unit=0
	for dev in altq cbq wfq afm fifoq red rio localq hfsc \
	    cdnr blue priq; do
		rm -f altq/$dev
		mknod altq/$dev c 75 $unit
		chmod 644 altq/$dev
		unit=$(($unit + 1))
d448 31
a478 3
	umask 0
	sh $0.local all
	umask 77
d480 1
d482 1
a482 1
	echo $i: invalid device
a483 1

d486 31
@


1.34
log
@sync, and update, to make "ramdisk" target disk
@
text
@d3 2
a4 2
# THIS FILE AUTOMATICALLY GENERATED.  DO NOT EDIT.
# generated from:
d6 1
a6 3
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.1 2002/02/08 20:26:36 todd Exp 
#	OpenBSD: MAKEDEV.mi,v 1.23 2002/02/08 20:26:36 todd Exp 
#	OpenBSD: MAKEDEV.sub,v 1.5 2002/01/23 06:02:19 todd Exp 
a7 25
#	$OpenBSD$
#
# Copyright (c) 2001 Todd T. Fries <todd@@OpenBSD.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
# THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

a8 2
#	all	makes all known devices, including local devices.
#		Tries to make the ``standard'' number of each type.
d11 1
a12 2
#	st*	SCSI tapes
#	mt*	(Magnetic) 9-track reel tape
d15 1
d18 2
d21 1
a21 1
#	hp*	massbuss rm??
d25 2
d28 4
a31 3
#	rx*	MSCP floppy disk (rx33/50/...)
#	rl*	unibus r102
#	hd*	HP300 HP-IB disks
d33 9
a41 10
#	cd*	SCSI cdrom drives
#	ch*	SCSI media changer
#	uk*	SCSI Unknown device
#	ss*	SCSI scanners
#	xy*	Xylogic 450/451 disks
#	rd*	"ramdisk" pseudo-disks
#	xd*	Xylogic 753/7053 disks
#	fd*	Floppy disk drives (3 1/2", 5 1/4")
#	vnd*	"file" pseudo-disks
#	ccd*	concatenated disk devices
d43 1
a43 2
#	tty*	set of 16 slave psuedo terminals
#	pty*	set of 16 master pseudo terminals
d45 6
a50 1
# Terminal ports:
d52 15
a66 13
#	audio*	audio device
#	openprom	
#	bpf*	Berkeley Packet Filter
#	pf*	Packet Filter
#	altq/	ALTQ control interface
#	lkm	loadable kernel modules interface
#	tun*	network tunnel driver
#	*random	inkernel random data source
#	magma*	magma card (makes 16 tty and 2 bpp)
#	xfs*	XFS filesystem devices
#	raid*	RAIDframe disk devices
#	fd	makes fd/* for the fdescfs
#	ses*	SES/SAF-TE SCSI devices
d68 5
a72 1
T=$0
d74 7
a80 2
# set this to echo for Echo-Only debugging
[ "$eo" ] || eo=
d82 4
a85 98
hex()
{
	case $1 in
		[0-9]) echo -n $1;;
		10) echo -n a;;
		11) echo -n b;;
		12) echo -n c;;
		13) echo -n d;;
		14) echo -n e;;
		15) echo -n f;;
	esac
}
trunc()
{
	# XXX pdksh can't seem to deal with locally scoped variables
	# in ${foo#$bar} expansions
	arg1="$1"
	arg2="$2"
	case $3 in
	l)   echo ${arg2#$arg1} ;;
	r|*) echo ${arg1#$arg2} ;;
	esac
}
unt()
{
	# XXX pdksh can't seem to deal with locally scoped variables
	# in ${foo#$bar} expansions
	arg="$1"
	tmp="${arg#[a-zA-Z]*}"
	tmp="${tmp%*[a-zA-Z]}"
	while [ "$tmp" != "$arg" ]
	do
		arg=$tmp
		tmp="${arg#[a-zA-Z]*}"
		tmp="${tmp%*[a-zA-Z]}"
	done
	echo $arg
}
dodisk()
{
	n=$(($((${5}*${7:-16}))+${6})) count=0
	RMlist="$RMlist $1$2? r$1$2?"
	[ 0$7 -ne 8 ] && l="i j k l m n o p"
	for d in a b c d e f g h $l
	do
		M $1$2$d	b $3 $(($n+$count)) 640
		M r$1$2$d	c $4 $(($n+$count)) 640
		let count=count+1
	done
	MKlist="$MKlist;chown root.operator $1$2? r$1$2?"
}
dodisk2()
{
	n=$(($(($5*${7:-16}))+$6))
	M $1$2a b $3 $n 640 operator
	M r$1$2a c $4 $n 640 operator
	n=$(($n+2))
	M $1$2c b $3 $n 640 operator
	M r$1$2c c $4 $n 640 operator
}

# M name b/c major minor [mode] [group]
RMlist="rm -f"
MKlist=":"
mkl() {
 [ "${mklist[$1]}" ] && {
  mklist[$1]="${mklist[$1]};mknod -m $1 $2 $3 $4 $5"
 } || {
  mklist[$1]="mknod -m $1 $2 $3 $4 $5"
  modes="$modes $1"
 }
}
M() {
	RMlist="$RMlist $1"
	mkl ${5-666} $1 $2 $3 $4
	mklist="$mklist $1"
	G=${6:-wheel}
	[ "$7" ] && {
		MKlist="$MKlist;chown $7.$G $1"
	} || {
		case $G in
		wheel)g=0;;kmem)g=2;;operator)g=5;;tty)g=4;;dialer)g=117;;
		esac
		[ "${grplist[$g]}" ] && {
			grplist[$g]="${grplist[$g]} $1"
		} || {
			groups="$groups $g"
			grplist[$g]="chgrp $G $1"
		}
	}
	return 0
}
R() {
[ "$DEBUG" ] && set -x
for i in "$@@"
do
U=`unt $i`
[ "$U" ] || U=0
a86 1
case $i in
d88 3
a90 2
	R std random rd0
	R fd0 sd0 sd1
d94 39
a132 22
	M console	c 0 0 600
	M tty		c 2 0
	M mem		c 3 0 640 kmem
	M kmem		c 3 1 640 kmem
	M null		c 3 2
	M zero		c 3 12
	M stdin		c 53 0
	M stdout	c 53 1
	M stderr	c 53 2
	M ksyms		c 50 0 640 kmem
	M drum		c 7 0 640 kmem
	M klog		c 33 0 600
	M ttyg0		c 25 0
	M ttyg1		c 25 1
	M ttyg2		c 25 2
	M ttyg3		c 25 3
	M crl		c 35 0
	M csa1		c 51 0
	M csa2		c 51 1
	M tu0		b 8 0
	M tu1		b 8 1
	M kUmem		c 3 3 660
d137 5
a141 5
	ht*) n=ht b=1 c=5;;
	mt*) n=mt b=15 c=38;;
	tm*) n=tm b=5 c=14;;
	ts*) n=ts b=6 c=16;;
	ut*) n=ut b=10 c=17;;
d143 1
a143 1
	case $U in
d145 30
a174 15
		four=$(($U+4)) eight=$(($U+8))
		twelve=$(($U+12)) twenty=$(($U+20))
		M $n$U		b $b $U	660 operator
		M $n$four	b $b $four	660 operator
		M $n$eight	b $b $eight	660 operator
		M $n$twelve	b $b $twelve	660 operator
		M n$n$four	b $b $four	660 operator
		M n$n$twelve	b $b $twelve	660 operator
		M nr$n$four	c $c $four	660 operator
		M nr$n$twelve	c $c $twelve	660 operator
		M r$n$U		c $c $U		660 operator
		M r$n$four	c $c $four	660 operator
		M r$n$eight	c $c $eight	660 operator
		M r$n$twelve	c $c $twelve	660 operator
		if [ $i = ut ]; : XXXX
d176 15
a190 2
			M $n$twenty	b $b $twenty 660 operator
			M r$n$twenty	c $b $twenty 660 operator
a191 4
		#RMlist="$RMlist mt$U mt$four mt$eight mt$twelve"
		#RMlist="$RMlist nmt$U nmt$eight nrmt$eight"
		#RMlist="$RMlist nrmt$unit nrmt$eight"
		#RMlist="$RMlist rmt$unit rmt$four rmt$eight rmt$twelve"
d194 1
a194 1
		echo bad unit for tape in: $i
d200 22
a221 2
ses*)
	M ses$U c 124 $U 640 operator
d224 46
a269 4
fd)
	RMlist="mkdir -p fd;$RMlist" n=0
	while [ $n -lt 64 ];do M fd/$n c 53 $n;n=$(($n+1));done
	MKlist="$MKlist;chmod 555 fd"
d272 26
a297 2
xfs*)
	M xfs$U c 51 $U 600
d300 14
a313 6
magma*)
	case $U in
	0)	offset=0  nam=m;;
	1)	offset=16 nam=n;;
	2)	offset=32 nam=o;;
	*)	echo "bad unit for $i: $U"; exit 127;;
d315 18
a332 10
	offset=$(($U*64))
	n=0
	while [ $n -lt 16 ]
	do
		name=${nam}`hex $n`
		M tty$name c major_mag_c $(($offset+$n)) 660 dialer uucp
		n=$(($n+1))
	done
	M bpp${nam}0 c major_bppmag_c $(($offset+0)) 600
	M bpp${nam}1 c major_bppmag_c $(($offset+1)) 600
d335 11
a345 7
*random)
	n=0
	for pre in " " s u p a
	do
		M ${pre}random c 119 $n 644
		n=$(($n+1))
	done
d348 10
a357 2
tun*)
	M tun$U c 111 $U 600
d360 9
a368 2
lkm)
	M lkm c 112 0 640 kmem
d371 24
a394 6
altq)
	RMlist="mkdir -p altq;$RMlist"
	for d in altq cbq wfq afm fifoq red rio localq hfsc cdnr blue priq; do
		M altq/$d c 75 $U 644
		U=$(($U+1))
	done
d397 19
a415 2
pf*)
	M pf c 42 0 600
d418 48
a465 2
bpf*)
	M bpf$U c 56 $U 600
d468 10
a477 2
openprom)
	M openprom c 70 0  
d480 16
a495 9
audio*)
	M sound$U	c 69 $U
	M mixer$U	c 69 $(($U+16))
	M audio$U	c 69 $(($U+128))
	M audioctl$U	c 69 $(($U+192))
	MKlist="$MKlist;[ -e audio ] || ln -s audio$U audio"
	MKlist="$MKlist;[ -e mixer ] || ln -s mixer$U mixer"
	MKlist="$MKlist;[ -e sound ] || ln -s sound$U sound"
	MKlist="$MKlist;[ -e audioctl ] || ln -s audioctl$U audioctl"
d499 22
a520 19
	case $U in
	0) off=0 name=p;;
	1) off=16 name=q;;
	2) off=32 name=r;;
	3) off=48 name=s;;
# Note that telnetd, rlogind, and xterm (at least) only look at p-s.
	4) off=64 name=t;;
	5) off=80 name=u;;
	6) off=96 name=v;;
	7) off=112 name=w;;
	8) off=128 name=x;;
	9) off=144 name=y;;
	10) off=160 name=z;;
	11) off=176 name=P;;
	12) off=192 name=Q;;
	13) off=206 name=R;;
	14) off=224 name=S;;
	15) off=240 name=T;;
	*) echo bad unit for pty in: $i; continue;;
d522 2
a523 2
	n=0
	while [ $n -lt 16 ]
d525 12
a536 4
		nam=$name$(hex $n)
		M tty$nam c 20 $(($off+$n))
		M pty$nam c 21 $(($off+$n))
		n=$(($n+1))
d538 2
d542 21
a562 3
vnd*)
	dodisk vnd $U 8 55 $U 0
	dodisk svnd $U 8 55 $U 128
d565 19
a583 26
fd*)
	typnam=$U${i#fd[01]*}
	case $typnam in
	0|1)	typnum=0;; # no type specified, assume A
	*A)		typnam=0; typnum=0;;
	*B)		typnum=1;;
	*C)		typnum=2;;
	*D)		typnum=3;;
	*E)		typnum=4;;
	*F)		typnum=5;;
	*G)		typnum=6;;
	*H)		typnum=7;;
	*)		echo bad type $typnam for $i; exit 1;;
	esac
	case $U in
	0|1)	blk=16; chr=54;;
	*)	echo bad unit $U for $i; exit 1;;
	esac
	nam=fd${typnam}
	n=$(($(($U*128))+$(($typnum*16))))
	M ${nam}a	b $blk $n 640 operator
	M ${nam}b	b $blk $(($n+1)) 640 operator
	M ${nam}c	b $blk $(($n+2)) 640 operator
	M r${nam}a	c $chr $n 640 operator
	M r${nam}b	c $chr $(($n+1)) 640 operator
	M r${nam}c	c $chr $(($n+2)) 640 operator
d586 20
a605 2
rd*)
	dodisk2 rd $U 23 106 $U 0
d608 6
a613 4
ss*)
	M ss$U c 121 $U 440 operator
	RMlist="$RMlist scan$U"
	MKlist="$MKlist;umask 77;ln -s ss$U scan$U"
d616 18
a633 2
uk*)
	M uk$U c 120 $U 640 operator
d636 10
a645 15
ch*)
	M ch$U c 19 $U 660 operator
	;;

cd*)
	dodisk2 cd $U 22 58 $U 0
	;;

st*)
	n=$(($U*16))
	for pre in " " n e en
	do
		M ${pre}st$U	b 21 $n 660 operator
		M ${pre}rst$U	c 38 $n 660 operator
		n=$(($n+1))
d650 3
a652 1
	test -s $T.local && sh $T.local
d654 2
a655 11

all)
	R audio0 xfs0 ss0 ss1 uk0 ses0 rndrandom lkm pf altq tun0
	R tun1 tun2 tun3 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7 bpf8
	R bpf9 fd1 fd1B fd1C fd1D fd1E fd1F fd1G fd1H fd0 fd0B fd0C
	R fd0D fd0E fd0F fd0G fd0H xd0 xd1 xd2 xd3 xy0 xy1 xy2 xy3 ut0
	R up0 up1 up2 up3 ts0 tm0 rx0 rx1 rl0 rl1 rl2 rl3 rb0 rb1 rb2
	R rb3 ra0 ra1 ra2 ra3 ht0 hp0 hp1 hp2 hp3 hk0 hk1 hk2 hk3 rd0
	R hd0 hd1 hd2 hd3 hd4 raid0 raid1 raid2 raid3 ccd0 ccd1 ccd2
	R ccd3 vnd0 vnd1 vnd2 vnd3 std cd0 cd1 ch0 st0 st1 pty0 pty1
	R fd sd0 sd1 sd2 sd3 sd4
a657 21
up*|xd*|xy*|sd*|rx*|rl*|rb*|raid*|ra*|hp*|hk*|hd*|ccd*)
	case $i in
	up*) dodisk up $U 2 13 $U 0;;
	xd*) dodisk xd $U 10 42 $U 0;;
	xy*) dodisk xy $U 3 9 $U 0;;
	sd*) dodisk sd $U 20 59 $U 0;;
	rx*) dodisk rx $U 12 30 $U 0;;
	rl*) dodisk rl $U 14 32 $U 0;;
	rb*) dodisk rb $U 11 23 $U 0;;
	raid*) dodisk raid $U 25 73 $U 0;;
	ra*) dodisk ra $U 9 9 $U 0;;
	hp*) dodisk hp $U 0 4 $U 0;;
	hk*) dodisk hk $U 3 11 $U 0;;
	hd*) dodisk hd $U 19 58 $U 0;;
	ccd*) dodisk ccd $U 17 54 $U 0;;
	esac
	;;

*)
	echo $i: unknown device
	;;
a659 31
}
R "$@@"
if [ "$os" = "SunOS" ]; then
	eo=transform
	transform() {
		case $mode in
		600) mask=077;;
		640) mask=027;;
		660) mask=007;;
		644) mask=022;;
		666) mask=0;;
		440) mask=227;;
		esac
		echo `echo "$@@"|sed \
			's/mknod -m \([0-9]*\) /umask '$mask';mknod /;s/-m [0-9]* //g;\
			 s/operator/5/g;s/root.kmem/root.2/g;s/root\./root:/g'`
	}
fi
list="$RMlist"
for mode in $modes; do
	list="$list;${mklist[$mode]}"
done
for group in $groups; do
	list="$list;${grplist[$group]}"
done
list="$list;$MKlist"
if [ "$eo" = "echo" -o "$eo" = "transform" ]; then
	$eo "$list"
else
	echo "$list" | sh
fi
@


1.33
log
@Add ra and rx entries to the ramdisk.
@
text
@d3 2
a4 2
#	$OpenBSD: MAKEDEV,v 1.32 2001/07/13 00:06:30 miod Exp $
#	$NetBSD: MAKEDEV,v 1.30 2000/01/21 12:28:29 tsutsui Exp $
d6 3
a8 1
#	@@(#)MAKEDEV	8.1 (Berkeley) 6/9/93
d10 25
d36 2
a39 1
#	all	create a reasonable amount of all files
d41 2
a44 1
#	mt*	MSCP tapes (e.g. TU81, TK50)
a46 2
#	uu*	tu58 cassettes on dl11 controller
#	st*	SCSI tapes
d48 1
a48 1
#	hp*	massbus rm??
d52 1
d54 11
a64 4
#	rl*	unibus rl02
#	rb*	730 idc w/ rb80 and/or rb02
#	ccd*	"concatenated" pseudo-disks
#	raid*	RAIDframe disk driver
d66 1
a66 11
#	rd*	memory pseudo-disk devices
#	sd*	SCSI disks
#	cd*	SCSI CD-ROM
#	hd*	HDC9224 hd disks on VS2000
# Terminal multiplexors:
#	dz*	unibus dz11 and dz32
#	dh*	unibus dh11 and emulations (e.g. Able dmax, Emulex cs-11)
#	dmf*	unibus dmf32
#	dhu*    unibus dhu11
#	dmz*    unibus dmz32
#	dl*	unibus dl11
d68 2
a69 1
#	pty*	set of 16 master and slave pseudo terminals
d71 1
a71 6
#	ct*	unibus parallel interface to CAT typesetter
#	lp*	unibus lp11 parallel interface
#	va*	unibus varian parallel interface
#	vp*	unibus versatec parallel interface
# Call units:
#	dn*	unibus dn11 and emulations (e.g. Able Quadracall)
d73 13
a85 15
#	ik*	unibus interface to ikonas frame buffer
#	ps*	unibus interface to e&s picture system 2
#	ad*	unibus interface to data translation a/d converter
#	np*	unibus ethernet co-processor interface, for downloading.
#	qv*	qvss (microvax) display
#	ttyv0	qvss (microvax) display reserved pty
#	lkm	loadable kernel modules
#	bpf*	berkeley packet filter
#	tun*	network tunnel device
#	ss*	SCSI scanner
#	uk*	SCSI unknown
#	ch*	SCSI changer
#	*random	Random number generator
#	altq	ALTQ control interface
#
d87 1
a87 5
set -A cnvtbl 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v
umask 77
for i
do
case $i in
d89 2
a90 7
all)
	sh $0 std fd vnd0 ccd0 pty0 pty1 lkm random altq
	sh $0 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7 pf tun0 tun1
	sh $0 mt0 mt1 ts0 ts1 st0 st1 uk0 ss0 cd0 vt0
	sh $0 ra0 ra1 ra2 ra3 hp0 hp1 hp2 hp3 sd0 sd1 sd2 sd3 hd0 hd1 hd2
	sh $0 dz0 dl0 dhu0 rx0 rx1 raid0 raid1 raid2 raid3
	;;
d92 98
a189 4
floppy)
	sh $0 std random
	sh $0 sd0 sd1
	;;
d191 1
d193 2
a194 3
	sh $0 std random
	sh $0 rd0 sd0 sd1 sd2 sd3 ra0 ra1 ra2 rx0 cd0 st0 st1
	sh $0 bpf0
d198 22
a219 39
	rm -f console drum floppy crl csa1 csa2 tu0 tu1
	rm -f kUmem kmem mem null zero tty klog ttyg[0-3]
	rm -f stdin stdout stderr ksyms
	mknod console		c 0 0
	mknod ttyg0		c 25 0
	mknod ttyg1		c 25 1
	mknod ttyg2		c 25 2
	mknod ttyg3		c 25 3
	mknod drum		c 7 0	; chmod 640 drum ; chgrp kmem drum
	mknod floppy		c 8 0
	mknod crl		c 35 0
	mknod csa1		c 51 0
	mknod csa2		c 51 1
	mknod tu0		b 8 0
	mknod tu1		b 8 1
	mknod kUmem		c 3 3	; chmod 600 kUmem
	mknod kmem		c 3 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 3 0	; chmod 640 mem ; chgrp kmem mem
	mknod null		c 3 2	; chmod 666 null
	mknod zero		c 3 12  ; chmod 666 zero
	mknod tty		c 2 0	; chmod 666 tty
	mknod klog		c 33 0	; chmod 600 klog
	mknod stdin		c 53 0	; chmod 666 stdin
	mknod stdout		c 53 1	; chmod 666 stdout
	mknod stderr		c 53 2	; chmod 666 stderr
	mknod ksyms		c 50 0	; chmod 640 ksyms ; chown root.kmem ksyms
	;;

fd)
	rm -f fd/*
	mkdir fd > /dev/null 2>&1
	n=0
	while [ $n -lt 64 ]; do
		mknod fd/$n c 53 $n
		n=$(($n + 1))
	done
	chown -R root.wheel fd
	chmod 755 fd
	chmod 666 fd/*
d224 5
a228 5
	ht*) name=ht;	unit=${i#ht};	blk=1; chr=5 ;;
	mt*) name=mt;	unit=${i#mt};	blk=15;	chr=38;;
	tm*) name=tm;	unit=${i#tm};	blk=5; chr=14;;
	ts*) name=ts;	unit=${i#ts};	blk=6; chr=16;;
	ut*) name=ut;	unit=${i#ut};	blk=10; chr=17;;
d230 1
a230 1
	case $unit in
d232 15
a246 30
		four=$(($unit + 4)) ; eight=$(($unit + 8))
		twelve=$(($unit + 12)) ; twenty=$(($unit + 20))
		rm -f $name$unit $name$four $name$eight $name$twelve \
		    n$name$unit n$name$eight nr$name$unit nr$name$eight \
		    r$name$unit r$name$four r$name$eight r$name$twelve
		mknod $name$unit	b $blk $unit
		mknod $name$four	b $blk $four
		mknod $name$eight	b $blk $eight
		mknod $name$twelve	b $blk $twelve
		mknod n$name$unit	b $blk $four ;: sanity w/pdp11 v7
		mknod n$name$eight	b $blk $twelve ;: ditto
		mknod nr$name$unit	c $chr $four ;: sanity w/pdp11 v7
		mknod nr$name$eight	c $chr $twelve ;: ditto
		mknod r$name$unit	c $chr $unit
		mknod r$name$four	c $chr $four
		mknod r$name$eight	c $chr $eight
		mknod r$name$twelve	c $chr $twelve
		chown root.operator {,n,r,nr}$name{$unit,$eight}
		chown root.operator {,r}$name{$four,$twelve}
		chmod 660 {,n,r,nr}$name{$unit,$eight}
		chmod 660 {,r}$name{$four,$twelve}
		if [ $i = ut ] 
		then
			rm -f $name$twenty r$name$twenty
			mknod $name$twenty	b $blk $twenty
			mknod r$name$twenty	c $chr $twenty
			chown root.operator {,r}$name$twenty
			chmod 660 {,r}$name$twenty
		fi
		if [ ! -e rmt$eight ]	# compatibility stuff
d248 2
a249 15
			rm -f mt$unit mt$four mt$eight mt$twelve \
			    nmt$unit nmt$eight nrmt$unit nrmt$eight \
			    rmt$unit rmt$four rmt$eight rmt$twelve
			ln -s $name$unit mt$unit
			ln -s $name$four mt$four
			ln -s $name$eight mt$eight
			ln -s $name$twelve mt$twelve
			ln -s n$name$unit nmt$unit
			ln -s n$name$eight nmt$eight
			ln -s nr$name$unit nrmt$unit
			ln -s nr$name$eight nrmt$eight
			ln -s r$name$unit rmt$unit
			ln -s r$name$four rmt$four
			ln -s r$name$eight rmt$eight
			ln -s r$name$twelve rmt$twelve
d251 4
d257 1
a257 1
		echo bad unit for tape in: $1
d263 2
a264 22
st*)
	umask 2
	unit=${i#st};	blk=21; chr=60;
	case $unit in
	0|1|2|3|4|5|6|7)
		rm -f {e,}{n,}{r,}st${unit}
		mknod st${unit}		b $blk $(($unit * 16 + 0))
		mknod nst${unit}	b $blk $(($unit * 16 + 1))
		mknod est${unit}	b $blk $(($unit * 16 + 2))
		mknod enst${unit}	b $blk $(($unit * 16 + 3))
		mknod rst${unit}	c $chr $(($unit * 16 + 0))
		mknod nrst${unit}	c $chr $(($unit * 16 + 1))
		mknod erst${unit}	c $chr $(($unit * 16 + 2))
		mknod enrst${unit}	c $chr $(($unit * 16 + 3))
		chown root.operator {e,}{n,}{r,}st${unit}
		chmod 660 {e,}{n,}{r,}st${unit}
		;;
	*)
		echo bad tape unit: $i - $unit
		;;
	esac
	umask 77
d267 4
a270 35
mt*)
	umask 0 ; unit=`expr $i : '..\(.*\)'`
	case $i in
	mt*) blk=7; chr=19;;
	esac
	case $unit in
	0|1|2|3|4|5|6|7)
		eight=`expr $unit + 0`;
		twelve=`expr $unit + 4`; 
		sixteen=`expr $unit + 8`;
		twenty=`expr $unit + 12`;
		rm -f mt8 mt12 mt16 mt20 nmt8 nrmt8 rmt8 rmt12 rmt16 rmt20
		rm -f nmt16 nrmt16
		mknod mt8		b $blk $eight
		mknod mt12		b $blk $twelve
		mknod mt16		b $blk $sixteen
		mknod mt20		b $blk $twenty
		mknod nmt8		b $blk $twelve ;: ditto
		mknod nrmt8		c $chr $twelve ;: ditto
		mknod rmt8		c $chr $eight
		mknod rmt12		c $chr $twelve
		mknod rmt16		c $chr $sixteen
		mknod rmt20		c $chr $twenty
		mknod nmt16		b $blk $twenty ;: ditto
		mknod nrmt16		c $chr $twenty ;: ditto
		chown root.operator {,n,r,nr}mt{8,16}
		chown root.operator {,r}mt{12,20}
		chmod 660 {,n,r,nr}mt{8,16}
		chmod 660 {,r}mt{12,20}
		;;
	*)
		echo bad unit for tape in: $1
		;;
	esac
	umask 77
d273 2
a274 9
random|srandom|urandom|prandom|arandom)
	rm -f random urandom srandom prandom arandom
	mknod  random c 67 0
	mknod srandom c 67 1
	mknod urandom c 67 2
	mknod prandom c 67 3
	mknod arandom c 67 4
	chown root.wheel random srandom urandom prandom arandom
	chmod 644 random srandom urandom prandom arandom
d277 14
a290 24
vnd*)
	umask 2
	unit=${i#vnd}
	if [ -z "$unit" -o 0$unit -gt 7 ]
	then
		echo bad disk unit: $i - $unit
		exit 127
	fi
	blk=18; chr=55;
	for name in vnd svnd; do
		case $name in
		vnd) off=0;;
		svnd) off=128;;
		esac
		rm -f {r,}${name}${unit}[a-p]
		minor=$(($unit * 16 + $off))
		for slice in a b c d e f g h i j k l m n o p
		do
			mknod ${name}${unit}${slice}  b $blk $minor
			mknod r${name}${unit}${slice} c $chr $minor
			minor=$(($minor + 1))
		done
		chown root.operator {r,}${name}${unit}?
		chmod 640 {r,}${name}${unit}?
d292 2
a293 1
	umask 77
d296 7
a302 33
hp*|hk*|up*|ra*|rl*|rb*|ccd*|hd*|sd*|rx*|raid*)
	umask 2
	case $i in
	hp*) name=hp;	unit=${i#hp};	blk=0; chr=4;;
	hk*) name=hk;	unit=${i#hk};	blk=3; chr=11;;
	up*) name=up;	unit=${i#up};	blk=2; chr=13;;
	raid*) name=raid; unit=${i#raid}; blk=25; chr=73;;
	ra*) name=ra;	unit=${i#ra};	blk=9;	chr=9;;
	rb*) name=rb;	unit=${i#rb};	blk=11; chr=23;;
	rx*) name=rx;	unit=${i#rx};	blk=12; chr=30;;
	rl*) name=rl;	unit=${i#rl};	blk=14; chr=32;;
	ccd*) name=ccd;	unit=${i#ccd};	blk=17; chr=54;;
	hd*) name=hd;	unit=${i#hd};	blk=19; chr=58;;
	sd*) name=sd;	unit=${i#sd};	blk=20; chr=59;;
	esac
	case $unit in
	[0-9]|[12][0-9]|3[01])
		minor=$(($unit * 16))
		rm -f {r,}${name}${unit}[a-p]
		for slice in a b c d e f g h i j k l m n o p
		do
			mknod ${name}${unit}${slice}  b $blk $minor
			mknod r${name}${unit}${slice} c $chr $minor
			minor=$(($minor + 1))
		done
		chgrp operator ${name}${unit}[a-p] r${name}${unit}[a-p]
		chmod 640 ${name}${unit}[a-p] r${name}${unit}[a-p]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
d305 2
a306 11
cd*)
	case $i in
	cd*) name=cd;   unit=${i#cd};   chr=61; blk=22;;
	esac
	rm -f {r,}${name}${unit}{a,c}
	mknod ${name}${unit}a   b $blk $(($unit * 16 + 0))
	mknod ${name}${unit}c   b $blk $(($unit * 16 + 2))
	mknod r${name}${unit}a  c $chr $(($unit * 16 + 0))
	mknod r${name}${unit}c  c $chr $(($unit * 16 + 2))
	chgrp operator {r,}${name}${unit}?
	chmod 640 {r,}${name}${unit}?
d309 2
a310 10
ss*)
	case $i in
	ss*) name=ss;   unit=${i#ss};   chr=64;;
	esac
	rm -f {,n,en}${name}${unit}
	mknod $name$unit	c $chr $(($unit * 16 + 0))
	mknod n$name$unit	c $chr $(($unit * 16 + 1))
	mknod en$name$unit	c $chr $(($unit * 16 + 3))
	chgrp operator {,n,en}${name}${unit}
	chmod 640 {,n,en}${name}${unit}
d313 6
a318 9
ch*|uk*)
	case $i in
	ch*) name=ch;   unit=${i#ch};   chr=63;;
	uk*) name=uk;   unit=${i#uk};   chr=65;;
	esac
	rm -f $name$unit
	mknod $name$unit        c $chr $unit
	chgrp operator $name$unit
	chmod 640 $name$unit
d321 2
a322 24
rd*)
	unit=${i#rd}; blk=23; chr=62;
	rm -f rd${unit}{a,c} #rrd${unit}{a,c}
	mknod rd${unit}a  b $blk $(($unit * 16 + 0)) 
	mknod rd${unit}c  b $blk $(($unit * 16 + 2)) 
#	mknod rrd${unit}a c $chr $(($unit * 16 + 0)) 
#	mknod rrd${unit}c c $chr $(($unit * 16 + 2)) 
	chgrp operator rd${unit}? #rrd${unit}?
	chmod 640 rd${unit}? #rrd${unit}?
	;;

uu*)
	unit=${i#uu}
	name=uu; blk=13;
	case $unit in
	[0-3])
		rm -f ${name}${unit}{,a}
		mknod ${name}${unit}	b $blk $(($unit * 2 + 0))
		mknod ${name}${unit}a	b $blk $(($unit * 2 + 1))
		;;
	*)
		echo bad unit for uu cassette in: $i
		;;
	esac
d325 2
a326 19
dz*)
	unit=${i#dz};
	case $unit in
	[0-7])
		i=0
		while [ $i -lt 8 ]; do
			no=$(($unit * 8 + $i))
			if [ $no -lt 10 ]; then
				no="0${no}"
			fi
			rm -f tty${no}
			mknod tty${no} c 1 $no
			i=$(($i + 1))
		done
		;;
	*)
		echo bad unit for dz in: $i
		;;
	esac
d329 2
a330 48
dhu*|dh*|dmf*|dmz*|vt*)
	case $i in
	vt*)	name=vt; major=68; count=8;
		unit=${i#vt}
		case $unit in
		0) ch=w ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dmz*)	name=dmz; major=37; count=24;
		unit=${i#dmz}
		case $unit in
		0) ch=a ;; 1) ch=b ;; 2) ch=c ;; 3) ch=e ;; 4) ch=f ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dmf*)	name=dmf; major=22; count=8;
		unit=${i#dmf}
		case $unit in
		0) ch=A ;; 1) ch=B ;; 2) ch=C ;; 3) ch=E ;;
		4) ch=F ;; 5) ch=G ;; 6) ch=H ;; 7) ch=I ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dhu*)	name=dhu; major=34; count=16;
		unit=${i#dhu}
		case $unit in
		0) ch=S ;; 1) ch=T ;; 2) ch=U ;; 3) ch=V ;;
		4) ch=W ;; 5) ch=X ;; 6) ch=Y ;; 7) ch=Z ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dh*)	name=dh; major=12; count=16;
		unit=${i#dh}
		case $unit in
		0) ch=h ;; 1) ch=i ;; 2) ch=j ;; 3) ch=k ;;
		4) ch=l ;; 5) ch=m ;; 6) ch=n ;; 7) ch=o ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	esac
	i=0
	while [ $i -lt $count ]; do
		let=${cnvtbl[$i]}
		if [ -n "$let" ] ;then
			rm -f tty${ch}${let}
			mknod tty${ch}${let} c $major $(($unit * $count + $i))
		else
			echo bad count for ${name}: $unit, $count, $i
		fi
		i=$(($i + 1))
	done

d333 9
a341 28
dl*)
	unit=${i#dl}
	major=66
	let=${cnvtbl[$unit]}
	if [ -n "$let" ] ;then
		rm -f ttyJ${let}
		mknod ttyJ${let} c $major $unit
	else
		echo bad number for ${name}: $unit
	fi
	;;

lp*|va*|vp*)
	case $i in
	lp*) name=lp; unit=${i#lp}; major=15;;
	va*) name=va; unit=${i#va}; major=10;;
	vp*) name=vp; unit=${i#vp}; major=6;;
	esac
	case $unit in
	[0-7])
		rm -f $i
		mknod $i c $major $unit;
		chmod 666 $i
		;;
	*)
		echo bad unit for $name in: $i
		;;
	esac
d345 19
a363 22
	class=${i#pty};
	case $class in
	0)	name=p;;
	1)	name=q;;
	2)	name=r;;
	3)	name=s;;
	4)	name=t;;
	5)	name=u;;
	6)	name=v
		echo "$0: $i: pty unit conflicts with another use."
		continue;;
	7)	name=w;;
	8)	name=x;;
	9)	name=y;;
	10)	name=z;;
	11)	name=P;;
	12)	name=Q;;
	13)	name=R;;
	14)	name=S;;
	15)	name=T;;
	*)	echo "$0: $i: pty unit must be between 0 and 15"
	        continue ;;
d365 2
a366 2
	rm -f tty$name[0-9a-f] pty$name[0-9a-f]
	for j in 0 1 2 3 4 5 6 7 8 9 a b c d e f
d368 4
a371 12
		case $j in
		[0-9])	jn=$j ;;
		a)	jn=10 ;;
		b)	jn=11 ;;
		c)	jn=12 ;;
		d)	jn=13 ;;
		e)	jn=14 ;;
		f)	jn=15 ;;
		esac
		unit=$(($class * 16 + $jn))
		mknod tty$name$j c 20 $unit
		mknod pty$name$j c 21 $unit
a372 2
	chgrp wheel tty$name? pty$name?
	chmod 666 tty$name? pty$name?
d375 35
a409 21
np*)
	class=${i#np}
	case $class in
	0)	offset=0  name=0;;
	1)	offset=16 name=1;;
	2)	offset=32 name=2;;
	*)	echo bad unit for np in: $i;;
	esac
	case $class in
	0|1|2)
	i=0
	while [ $i -lt 4 ]; do
		no=$(($offset + $i))
		if [ $no -lt 10 ]; then
			no="0${no}"
		fi
		rm -f np${no}
		mknod np${no} c 39 $no
		i=$(($i + 1))
	done
	esac
d412 4
a415 19
dn*|ik*|ps*|ad*|ct*)
	case $i in
	ct*) name=ct; unit=${i#ct}; chr=18;;
	dn*) name=cu; unit=${i#dn}; chr=24;;
	ps*) name=ps; unit=${i#ps}; chr=27;;
	ad*) name=ad; unit=${i#ad}; chr=29;;
	ik*) name=ik; unit=${i#ik}; chr=31;;
	esac
	case $unit in
	[0-7])
		umask 0
		rm -f ${name}${unit}
		mknod ${name}${unit} c ${chr} ${unit}
		umask 77
		;;
	*)
		echo bad unit for ${name} in: $i
		;;
	esac
d418 2
a419 20
bpf*)
	unit=${i#bpf};
	rm -f bpf$unit
	mknod bpf$unit c 56 $unit
	chmod 600 bpf$unit
	chown root.wheel bpf$unit
	;;

qd*)
	unit=${i#qd}
	rm -f q{c,d}$unit
	mknod qc$unit c 40 $(($unit * 4))
	mknod qd$unit c 40 $(($unit * 4 + 2))
	;;

pf)
	rm -f pf
	mknod pf c 42 0
	chown root.wheel pf
	chmod 600 pf
d422 2
a423 6
tun*)
	unit=${i#tun}
	rm -f tun$unit
	mknod tun$unit c 57 $unit
	chmod 600 tun$unit
	chown root.wheel tun$unit
d426 2
a427 18
lkm)
	rm -f lkm
	mknod lkm c 28 0
	chown root.kmem lkm
	chmod 640 lkm
	;;

qv0)
	rm -f qv0 qvcons mouse
	mknod qv0 c 40 0
	mknod qvcons c 40 1
	mknod mouse c 40 2
	;;

ttyv0)
	if [ ! -f ttyqe ]; then sh ./$0 pty1; fi
	mv ttyqf ttyv0
	mv ptyqf ptyv0
d430 7
a436 10
altq)
	mkdir -p altq
	chmod 755 altq
	unit=0
	for dev in altq cbq wfq afm fifoq red rio localq hfsc \
	    cdnr blue priq; do
		rm -f altq/$dev
		mknod altq/$dev c 75 $unit
		chmod 644 altq/$dev
		unit=$(($unit + 1))
d441 31
a471 3
	umask 0
	sh $0.local all
	umask 77
d473 1
d475 1
a475 1
	echo $i: invalid device
a476 1

d479 31
@


1.32
log
@Don't remove innocent files by accident, but on the other hand,
be sure to remove filres before mknod'ing them again.
Also speed up some rm constructs.
Discussed with hugh@@
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.31 2001/06/28 02:58:57 kjc Exp $
d89 1
a89 1
	sh $0 sd0 sd1 sd2 sd3 rd0 cd0 st0 st1
@


1.31
log
@add an entry for ALTQ.
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.30 2001/06/25 03:20:24 kjell Exp $
d94 1
a94 1
	rm -f console drum floppy crl csa1 csa2 tu0 tu1 g0 g1 g2 g3
d286 1
a286 1
		rm -f {r,}${name}${unit}?
d318 1
a318 1
		rm -f ${name}${unit}[a-p] r${name}${unit}[a-p]
d339 1
a339 1
	rm -f {r,}${name}${unit}?
d373 1
a373 1
	rm -f rd${unit}? rrd${unit}?
d387 1
d407 1
d458 1
d473 1
d488 1
d576 1
d596 1
a596 1
	rm -f qd$unit
d624 1
@


1.30
log
@add pf device on all architectures.
fix my previously bogus MAKEDEVs.
If you used pf on a non-i386. the major device number has changed,
and you'll need to recreate /dev/pf
ok theo
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.29 2001/06/24 23:36:11 kjell Exp $
d65 1
d75 1
a75 1
	sh $0 std fd vnd0 ccd0 pty0 pty1 lkm random
d627 13
@


1.29
log
@Add the pf device for the shiny new packet filter
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.28 2001/05/30 02:11:27 deraadt Exp $
d596 1
a596 1
	mknod pf c 73 0
@


1.28
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.27 2001/04/01 20:14:40 hugh Exp $
d75 1
a75 1
	sh $0 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7 tun0 tun1
d592 7
@


1.27
log
@Braces and spaces.
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.26 2001/03/31 02:51:26 hugh Exp $
d95 1
a95 1
	rm -f stdin stdout stderr ksyms ipl ipnat ipstate ipauth
a117 1
	mknod ipl		c 42 0	; chmod 600 ipl
a118 3
	mknod ipnat		c 42 1	; chmod 600 ipnat
	mknod ipstate		c 42 2	; chmod 600 ipstate
	mknod ipauth		c 42 3	; chmod 600 ipauth
@


1.26
log
@Build SCSI tape eject devices.  Spotted while testing beckish slag?
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.25 2000/12/05 07:27:36 hugh Exp $
d112 1
a112 1
	mknod zero              c 3 12  ; chmod 666 zero
d118 2
a119 2
    mknod ipl		c 42 0	; chmod 600 ipl
	mknod ksyms		c 50 0  ; chmod 640 ksyms ; chown root.kmem ksyms
d208 1
a208 2
		rm -f st${unit} nst${unit} est${unit} enst${unit} \
		    rst${unit} nrst${unit} erst${unit} enrst${unit}
d217 2
a218 6
		chown root.operator \
		    st${unit} nst${unit} est${unit} enst${unit} \
		    rst${unit} nrst${unit} erst${unit} enrst${unit}
		chmod 660 \
		    st${unit} nst${unit} est${unit} enst${unit} \
		    rst${unit} nrst${unit} erst${unit} enrst${unit}
d289 1
a289 1
		rm -f $name$unit? r$name$unit?
d297 2
a298 2
		chown root.operator $name$unit? r$name$unit?
		chmod 640 $name$unit? r$name$unit?
d342 1
a342 1
	rm -f $name$unit? r$name$unit?
d347 2
a348 2
	chgrp operator $name$unit? r$name$unit?
	chmod 640 $name$unit? r$name$unit?
d355 1
a355 1
	rm -f $name$unit n$name$unit en$name$unit
d359 2
a360 2
	chgrp operator $name$unit n$name$unit en$name$unit
	chmod 640 $name$unit n$name$unit en$name$unit
d499 7
a505 7
	0)      name=p;;
	1)      name=q;;
	2)      name=r;;
	3)      name=s;;
	4)      name=t;;
	5)      name=u;;
	6)      name=v
d508 10
a517 10
	7)      name=w;;
	8)      name=x;;
	9)      name=y;;
	10)     name=z;;
	11)     name=P;;
	12)     name=Q;;
	13)     name=R;;
	14)     name=S;;
	15)     name=T;;
	*)      echo "$0: $i: pty unit must be between 0 and 15"
d524 7
a530 7
		[0-9])  jn=$j ;;
		a)      jn=10 ;;
		b)      jn=11 ;;
		c)      jn=12 ;;
		d)      jn=13 ;;
		e)      jn=14 ;;
		f)      jn=15 ;;
d536 2
a537 2
        chgrp wheel tty$name? pty$name?
        chmod 666 tty$name? pty$name?
d543 4
a546 4
	0) offset=0 name=0;;
	1) offset=16 name=1;;
	2) offset=32 name=2;;
	*) echo bad unit for np in: $i;;
d556 1
@


1.25
log
@Avoid dependency on printf(1) by replacing it with a ksh array.
Has side effect of constraining dmz dev entries to the ttyXX convention.
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.24 2000/12/04 09:56:06 hugh Exp $
d138 1
a138 1
ht*|tm*|mt*|ts*|ut*|st*)
a144 1
	st*) name=st;	unit=${i#st};	blk=21; chr=60;;
d198 29
@


1.24
log
@Build network tunnel devices.
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.23 2000/11/24 20:32:40 hugh Exp $
d67 1
d382 6
a387 3
		  no=$(($unit * 8 + $i))
		  `printf "mknod tty%02d c 1 %d\n" $no $no`
		  i=$(($i + 1))
d434 7
a440 3
	  `printf "mknod tty%s%x c %d %d\n" \
	     $ch $i $major $(($unit * $count + $i))`
	  i=$(($i + 1))
d448 6
a453 1
	`printf "mknod ttyJ%x c %d %d\n" $unit $major $unit`
d529 6
a534 2
	  `printf "mknod np%02d c 39 %d\n" $(($offset + $i)) $(($offset + $i))`
	  i=$(($i + 1))
@


1.23
log
@Add entries to build nodes required for "floppy", and "ramdisk".
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.22 2000/11/24 20:29:10 hugh Exp $
d74 1
a74 1
	sh $0 bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7
@


1.22
log
@Rename "md" to "rd", consquently moving the hdHDC9224 disk dev to "hd".
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.21 2000/11/24 20:13:10 hugh Exp $
d78 11
@


1.21
log
@build the 'safe' vnode device
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.19 2000/05/01 01:48:36 bjc Exp $
d24 1
a24 1
#	ra*	MSCP disks (ra??, rd??)
d31 1
a31 1
#	rd*	HDC9224 rd disks on VS2000
d34 1
a34 1
#	md*	memory pseudo-disk devices
d76 1
a76 1
	sh $0 ra0 ra1 ra2 ra3 hp0 hp1 hp2 hp3 sd0 sd1 sd2 sd3 rd0 rd1 rd2
d268 1
a268 1
hp*|hk*|up*|ra*|rl*|rb*|ccd*|rd*|sd*|rx*|raid*)
d280 1
a280 1
	rd*) name=rd;	unit=${i#rd};	blk=19; chr=58;;
d339 9
a347 9
md*)
	unit=${i#md}; blk=23; chr=62;
	rm -f md${unit}? rmd${unit}?
	mknod md${unit}a  b $blk $(($unit * 16 + 0)) 
	mknod md${unit}c  b $blk $(($unit * 16 + 2)) 
#	mknod rmd${unit}a c $chr $(($unit * 16 + 0)) 
#	mknod rmd${unit}c c $chr $(($unit * 16 + 2)) 
	chgrp operator md${unit}? #rmd${unit}?
	chmod 640 md${unit}? #rmd${unit}?
@


1.20
log
@Support 16 slices per device, like the other OpenBSD arches.
@
text
@d240 29
a268 1
hp*|hk*|up*|ra*|rl*|rb*|ccd*|vnd*|rd*|sd*|rx*|raid*)
a279 1
	vnd*) name=vnd;	unit=${i#vnd};	blk=18; chr=55;;
@


1.19
log
@new makedev, partly from netbsd
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.18 2000/03/22 07:34:30 niklas Exp $
d258 10
a267 19
		rm -f ${name}${unit}[a-h] r${name}${unit}[a-h]
		mknod ${name}${unit}a	b $blk $(($unit * 8 + 0))
		mknod ${name}${unit}b	b $blk $(($unit * 8 + 1))
		mknod ${name}${unit}c	b $blk $(($unit * 8 + 2))
		mknod ${name}${unit}d	b $blk $(($unit * 8 + 3))
		mknod ${name}${unit}e	b $blk $(($unit * 8 + 4))
		mknod ${name}${unit}f	b $blk $(($unit * 8 + 5))
		mknod ${name}${unit}g	b $blk $(($unit * 8 + 6))
		mknod ${name}${unit}h	b $blk $(($unit * 8 + 7))
		mknod r${name}${unit}a	c $chr $(($unit * 8 + 0))
		mknod r${name}${unit}b	c $chr $(($unit * 8 + 1))
		mknod r${name}${unit}c	c $chr $(($unit * 8 + 2))
		mknod r${name}${unit}d	c $chr $(($unit * 8 + 3))
		mknod r${name}${unit}e	c $chr $(($unit * 8 + 4))
		mknod r${name}${unit}f	c $chr $(($unit * 8 + 5))
		mknod r${name}${unit}g	c $chr $(($unit * 8 + 6))
		mknod r${name}${unit}h	c $chr $(($unit * 8 + 7))
		chgrp operator ${name}${unit}[a-h] r${name}${unit}[a-h]
		chmod 640 ${name}${unit}[a-h] r${name}${unit}[a-h]
d281 4
a284 4
	mknod ${name}${unit}a   b $blk $(($unit * 8 + 0))
	mknod ${name}${unit}d   b $blk $(($unit * 8 + 3))
	mknod r${name}${unit}a  c $chr $(($unit * 8 + 0))
	mknod r${name}${unit}d  c $chr $(($unit * 8 + 3))
d315 4
a318 4
	mknod md${unit}a  b $blk $(($unit * 8 + 0)) 
	mknod md${unit}c  b $blk $(($unit * 8 + 2)) 
#	mknod rmd${unit}a c $chr $(($unit * 8 + 0)) 
#	mknod rmd${unit}c c $chr $(($unit * 8 + 2)) 
@


1.18
log
@operator should have perms to write and change tapes.  ch* is still missing
in some MAKEDEVs, will see to them in a separate commit.
@
text
@d3 2
a4 2
#	$OpenBSD: MAKEDEV,v 1.17 1998/11/19 08:18:58 dugsong Exp $
#	$NetBSD: MAKEDEV,v 1.3 1996/01/07 16:53:15 ragge Exp $
d15 1
a15 1
#	tms*	unibus/qbus TMSCP (e.g. TU81, TK50)
a16 1
#	mt*	massbus tu78
d24 2
a25 2
#	ra*	unibus uda50 w/ ra??
#	kra*	bi kdb50 w/ ra??
a27 1
#	rx*	unibus rx211 floppy disk 
d29 1
d31 1
a31 1
#	hd*	HDC9224 rd disks on VS2000
d34 1
d41 1
d57 1
d59 6
a64 1
#	*random	random data source
d73 5
a77 4
	sh MAKEDEV std vnd0 ccd0 pty0 lkm ipl
	sh MAKEDEV tms0 ts0 st0 st1
	sh MAKEDEV ra0 ra1 ra2 ra3 ra4 ra5 ra6 ra7 hp0 hp1 random
	sh MAKEDEV sd0 sd1 sd2 sd3 hd0 hd1 hd2
d81 3
a83 2
	rm -f console drum floppy crl csa1 csa2 tu0 tu1 kUmem kmem mem null
	rm -f zero tty klog stdin stdout stderr
d85 5
a89 1
	mknod drum		c 7 0	; chmod 640 drum ; chown root.kmem drum
d97 2
a98 2
	mknod kmem		c 3 1	; chmod 640 kmem ; chown root.kmem kmem
	mknod mem		c 3 0	; chmod 640 mem ; chown root.kmem mem
d106 9
d116 5
a120 3
	(cd fd && eval `echo "" | awk ' BEGIN { \
		for (i = 0; i < 64; i++) \
			printf("rm -f %d; mknod %d c 53 %d;", i, i, i)}'`)
d122 1
a122 1
	chmod 555 fd
d126 1
a126 2
ht*|tm*|tms*|ts*|ut*|st*)
	umask 0 ; unit=`expr $i : '[^0-9]*\(.*\)'`
d128 6
a133 6
	ht*) name=ht; blk=1; chr=5 ;;
	tms*) name=tms; blk=15; chr=38;;
	tm*) name=tm; blk=5; chr=14;;
	ts*) name=ts; blk=6; chr=16;;
	ut*) name=ut; blk=10; chr=17;;
	st*) name=st; blk=21; chr=60;;
d136 6
a141 6
	0|1|2|3|4|5|6|7)
		four=`expr $unit + 4` ; eight=`expr $unit + 8`
		twelve=`expr $unit + 12`; twenty=`expr $unit + 20`
		rm -f $name$unit $name$four  $name$eight $name$twelve
		rm -f n$name$unit n$name$eight  nr$name$unit nr$name$eight
		rm -f r$name$unit r$name$four  r$name$eight r$name$twelve
d168 3
a170 3
			rm -f mt$unit mt$four mt$eight mt$twelve
			rm -f nmt$unit nmt$eight nrmt$unit nrmt$eight
			rm -f rmt$unit rmt$four rmt$eight rmt$twelve
d231 5
a235 5
	mknod  random c 58 0
	mknod srandom c 58 1
	mknod urandom c 58 2
	mknod prandom c 58 3
	mknod arandom c 58 4
d240 2
a241 2
hp*|hk*|up*|ra*|kra*|rl*|rb*|ccd*|hd*|sd*)
	umask 2 ; unit=`expr $i : '.*[^0-9]\([0-9]*\)'`
d243 12
a254 10
	hp*) name=hp; blk=0; chr=4;;
	hk*) name=hk; blk=3; chr=11;;
	up*) name=up; blk=2; chr=13;;
	ra*) name=ra; blk=9; chr=9;;
	kra*) name=kra; blk=16; chr=52;;
	rb*) name=rb; blk=11; chr=23;;
	rl*) name=rl; blk=14; chr=32;;
	ccd*) name=ccd; blk=17; chr=54;;
	hd*) name=hd; blk=19; chr=58;;
	sd*) name=sd; blk=20; chr=59;;
d257 19
a275 24
	0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|\
	17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)
		rm -f ${name}${unit}[abcg] r${name}${unit}[abcg]
		mknod ${name}${unit}a	b $blk `expr $unit '*' 8 + 0`
		mknod ${name}${unit}b	b $blk `expr $unit '*' 8 + 1`
		mknod ${name}${unit}c	b $blk `expr $unit '*' 8 + 2`
		mknod ${name}${unit}g	b $blk `expr $unit '*' 8 + 6`
		mknod r${name}${unit}a	c $chr `expr $unit '*' 8 + 0`
		mknod r${name}${unit}b	c $chr `expr $unit '*' 8 + 1`
		mknod r${name}${unit}c	c $chr `expr $unit '*' 8 + 2`
		mknod r${name}${unit}g	c $chr `expr $unit '*' 8 + 6`
		if [ $name != hk ]
		then
		rm -f ${name}${unit}[defh] r${name}${unit}[defh]
		mknod ${name}${unit}d	b $blk `expr $unit '*' 8 + 3`
		mknod ${name}${unit}e	b $blk `expr $unit '*' 8 + 4`
		mknod ${name}${unit}f	b $blk `expr $unit '*' 8 + 5`
		mknod ${name}${unit}h	b $blk `expr $unit '*' 8 + 7`
		mknod r${name}${unit}d	c $chr `expr $unit '*' 8 + 3`
		mknod r${name}${unit}e	c $chr `expr $unit '*' 8 + 4`
		mknod r${name}${unit}f	c $chr `expr $unit '*' 8 + 5`
		mknod r${name}${unit}h	c $chr `expr $unit '*' 8 + 7`
		fi
		chown root.operator ${name}${unit}[a-h] r${name}${unit}[a-h]
d285 11
a295 29
vnd*)
	umask 2 ; unit=`expr $i : 'vnd\(.*\)'`
	for name in vnd svnd; do
		blk=18; chr=55;
		case $name in
		vnd)	off=0;;
		svnd)	off=128;;
		esac
		rm -f $name$unit? r$name$unit?
		mknod ${name}${unit}a	b $blk `expr $unit '*' 8 + $off + 0`
		mknod ${name}${unit}b	b $blk `expr $unit '*' 8 + $off + 1`
		mknod ${name}${unit}c	b $blk `expr $unit '*' 8 + $off + 2`
		mknod ${name}${unit}d	b $blk `expr $unit '*' 8 + $off + 3`
		mknod ${name}${unit}e	b $blk `expr $unit '*' 8 + $off + 4`
		mknod ${name}${unit}f	b $blk `expr $unit '*' 8 + $off + 5`
		mknod ${name}${unit}g	b $blk `expr $unit '*' 8 + $off + 6`
		mknod ${name}${unit}h	b $blk `expr $unit '*' 8 + $off + 7`
		mknod r${name}${unit}a	c $chr `expr $unit '*' 8 + $off + 0`
		mknod r${name}${unit}b	c $chr `expr $unit '*' 8 + $off + 1`
		mknod r${name}${unit}c	c $chr `expr $unit '*' 8 + $off + 2`
		mknod r${name}${unit}d	c $chr `expr $unit '*' 8 + $off + 3`
		mknod r${name}${unit}e	c $chr `expr $unit '*' 8 + $off + 4`
		mknod r${name}${unit}f	c $chr `expr $unit '*' 8 + $off + 5`
		mknod r${name}${unit}g	c $chr `expr $unit '*' 8 + $off + 6`
		mknod r${name}${unit}h	c $chr `expr $unit '*' 8 + $off + 7`
		chown root.operator ${name}${unit}[a-h] r${name}${unit}[a-h]
		chmod 640 ${name}${unit}[a-h] r${name}${unit}[a-h]
	done
	umask 77
d298 1
a298 2
cd*)
	umask 2 ; unit=`expr $i : '.*cd\(.*\)'`
d300 1
a300 1
	cd*) name=cd; blk=22; chr=61;;
d302 6
a307 8
	rm -f $name$unit? r$name$unit?
	mknod ${name}${unit}a	b $blk `expr $unit '*' 8 + 0`
	mknod ${name}${unit}c	b $blk `expr $unit '*' 8 + 2`
	mknod r${name}${unit}a	c $chr `expr $unit '*' 8 + 0`
	mknod r${name}${unit}c	c $chr `expr $unit '*' 8 + 2`
	chown root.operator ${name}${unit}[a-h] r${name}${unit}[a-h]
	chmod 640 ${name}${unit}[a-h] r${name}${unit}[a-h]
	umask 77
d310 4
a313 15
rx*)
	unit=`expr $i : '..\(.*\)'`
	name=rx; chr=30; blk=12;
	case $unit in
	0|1|2|3|4|5|6|7)
		rm -f ${name}{${unit} r${name}${unit}[abcd]
		mknod ${name}${unit}	b $blk `expr $unit '*' 8 + 0`
		mknod r${name}${unit}a	c $chr `expr $unit '*' 8 + 0`
		mknod r${name}${unit}b	c $chr `expr $unit '*' 8 + 1`
		mknod r${name}${unit}c	c $chr `expr $unit '*' 8 + 2`
		mknod r${name}${unit}d	c $chr `expr $unit '*' 8 + 3`
		;;
	*)
		echo bad unit for floppy disk in: $i
		;;
d315 15
d333 1
a333 1
	unit=`expr $i : '..\(.*\)'`
d336 3
a338 4
	0|1|2|3)
		rm -f ${name}${unit} ${name}${unit}a
		mknod ${name}${unit}	b $blk `expr $unit '*' 2 + 0`
		mknod ${name}${unit}a	b $blk `expr $unit '*' 2 + 1`
d347 1
a347 1
	unit=`expr $i : 'dz\(.*\)'`
d349 7
a355 4
	0|1|2|3|4|5|6|7)
		eval `echo $unit | awk ' { u = $1 } END {
		    for (i = 0; i < 8; i++)
			printf("rm -f tty%02d; mknod tty%02d c 1 %d; ", u * 8 + i, u * 8 + i, u * 8 + i); }'`
d363 1
a363 1
dhu*|dh*|dmf*|dmz*)
d365 6
d372 1
a372 1
		unit=`expr $i : "$name\(.*\)"`
d374 1
a374 2
		0) ch=a ;; 1) ch=b ;; 2) ch=c ;; 3) ch=e ;;
		4) ch=f ;; 5) ch=g ;;
d378 1
a378 1
		unit=`expr $i : "$name\(.*\)"`
d385 1
a385 1
		unit=`expr $i : "$name\(.*\)"`;
d392 1
a392 1
		unit=`expr $i : "$name\(.*\)"`
d399 13
a411 7
	eval `echo $ch $unit $major $count |
	  awk ' { ch = $1; u = $4 * $2; m = $3; cnt = $4 } END {
	    for (i = 0; i < cnt; i++)
	      if (i < 10)
		printf("rm -f tty%s%x; mknod tty%s%x c %d %d; ", ch, i, ch, i, m, u + i);
	      else
		printf("rm -f tty%s%c; mknod tty%s%c c %d %d; ", ch, 87 + i, ch, 87 + i, m, u + i); }'`
d416 3
a418 3
	lp*) name=lp; major=15;;
	va*) name=va; major=10;;
	vp*) name=vp; major=6;;
a419 1
	unit=`expr $i : "$name\(.*\)"`
d421 1
a421 2
	0|1|2|3|4|5|6|7)
		rm -f $i
d432 1
a432 1
	class=`expr $i : 'pty\(.*\)'`
d434 39
a472 38
	0) offset=0 name=p;;
	1) offset=16 name=q;;
	2) offset=32 name=r;;
	3) offset=48 name=s;;
	4) offset=64 name=t;;
	5) offset=80 name=u;;
	6) offset=96 name=v;;
	7) offset=112 name=w;;
	8) offset=128 name=x;;
	9) offset=144 name=y;;
	10) offset=160 name=z;;
	11) offset=176 name=P;;
 	12) offset=192 name=Q;;
	13) offset=208 name=R;;
	14) offset=224 name=S;;
	15) offset=240 name=T;;
	*) echo bad unit for pty in: $i;;
	esac
	case $class in
	0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15)
		umask 0
		eval `echo $offset $name | awk ' { b=$1; n=$2 } END {
			for (i = 0; i < 16; i++)
				printf("rm -f tty%s%x; mknod tty%s%x c 20 %d;" \
					"rm -f pty%s%x; mknod pty%s%x c 21 %d; ", \
					n, i, n, i, b + i, n, i, n, i, b + i); }'`
		umask 77
		;;
	esac
	;;

ipl)
	rm -f ipl ipnat ipstate ipauth
	mknod ipl c 50 0
	mknod ipnat c 50 1
	mknod ipstate c 50 2
	mknod ipauth c 50 3
	chown root.wheel ipl ipnat ipstate ipauth
d476 1
a476 1
	class=`expr $i : 'np\(.*\)'`
d485 5
a489 5
		eval `echo $offset | awk ' { b=$1 } END {
			for (i = 0; i < 4; i++)
				printf("rm -f np%02d; mknod np%02d c 39 %d;", \
					b + i, b + i, b + i); }'`
		;;
a493 1
	unit=`expr $i : '..\(.*\)'`
d495 5
a499 5
	ct*) name=ct; chr=18;;
	dn*) name=cu; chr=24;;
	ps*) name=ps; chr=27;;
	ad*) name=ad; chr=29;;
	ik*) name=ik; chr=31;;
d502 1
a502 1
	0|1|2|3|4|5|6|7)
a503 1
		rm -f ${name}${unit}
d513 23
a543 1
	rm -f qv0 qvcons mouse
d549 6
d556 6
a561 1
	test -s MAKEDEV.local && sh MAKEDEV.local
d563 1
@


1.17
log
@add support for more ptys
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.16 1998/09/15 10:23:23 pattonme Exp $
d131 4
d140 2
d194 4
@


1.16
log
@Added definition for ipauth, a new piece for IPFilter v3.2.9
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.15 1998/05/14 17:07:22 niklas Exp $
d416 10
d429 1
a429 1
	0|1|2|3|4|5)
@


1.15
log
@random before ra*, and rm -f before mknod
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.14 1998/01/26 04:19:52 dgregor Exp $
d432 1
a432 1
	rm -f ipl ipnat ipstate 
d436 2
a437 1
	chown root.wheel ipl ipnat ipstate 
@


1.14
log
@Add /dev/ipnat and /dev/ipstate for IPF 3.2.3
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.13 1997/09/20 14:36:58 maja Exp $
d73 2
d96 1
a96 1
			printf("mknod %d c 53 %d;", i, i)}'`)
d116 3
d133 1
d139 3
d174 2
d196 11
d224 1
d235 1
d306 1
d324 1
d340 1
a340 1
			printf("mknod tty%02d c 1 %d; ",u*8+i,u*8+i); }'`
d383 1
a383 1
		printf("mknod tty%s%x c %d %d; ",ch,i,m,u+i);
d385 1
a385 1
		printf("mknod tty%s%c c %d %d; ",ch,87+i,m,u+i); }'`
d397 1
d423 3
a425 3
				printf("mknod tty%s%x c 20 %d;" \
					"mknod pty%s%x c 21 %d; ", \
					n, i, b+i, n, i, b+i); }'`
d451 2
a452 2
				printf("mknod np%02d c 39 %d;", \
					b+i, b+i); }'`
d469 1
d480 1
d487 1
a490 11
	;;

random|srandom|urandom|prandom|arandom)
	rm -f random urandom srandom prandom arandom
	mknod  random c 58 0
	mknod srandom c 58 1
	mknod urandom c 58 2
	mknod prandom c 58 3
	mknod arandom c 58 4
	chown root.wheel random srandom urandom prandom arandom
	chmod 644 random srandom urandom prandom arandom
@


1.13
log
@Add some missing device (hd, sd, cd and st). -moj
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.12 1997/09/08 06:12:26 deraadt Exp $
d405 1
d407 3
a409 1
	chown root.wheel ipl
@


1.12
log
@ttyv0 stupidity goes away
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.11 1997/05/14 15:41:23 niklas Exp $
d20 1
d32 3
d67 1
a67 1
	sh MAKEDEV tms0 ts0
d69 1
d100 1
a100 1
ht*|tm*|tms*|ts*|ut*)
d108 1
d185 1
a185 1
hp*|hk*|up*|ra*|kra*|rl*|rb*|ccd*)
d196 2
d259 15
@


1.11
log
@Make svnd nodes too, please test this on your port
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.10 1997/05/13 05:35:00 millert Exp $
a51 1
#	ttyv0	qvss (microvax) display reserved pty
a434 6
	;;

ttyv0)
	if [ ! -f ttyqe ]; then sh ./MAKEDEV pty1; fi
	mv ttyqf ttyv0
	mv ptyqf ptyv0
@


1.10
log
@Only run MAKEDEV.local if it exists.  Avoids an error message
during installs where there is no MAKEDEV.local.
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.9 1996/12/14 18:24:03 millert Exp $
d180 1
a180 1
hp*|hk*|up*|ra*|kra*|rl*|rb*|ccd*|vnd*)
a190 1
	vnd*) name=vnd; blk=18; chr=55;;
d221 31
@


1.9
log
@/dev/fd should be owned by root.wheel
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.8 1996/09/18 22:03:48 deraadt Exp $
d426 1
a426 1
	sh MAKEDEV.local
@


1.8
log
@do not use chgrp
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.7 1996/08/28 08:55:30 deraadt Exp $
d91 1
a91 1
	chown -R bin.bin fd
@


1.7
log
@fix all random device node entry stuff
@
text
@d3 1
a3 1
#	$OpenBSD: MAKEDEV,v 1.6 1996/07/23 06:33:00 etheisen Exp $
d70 1
a70 1
	mknod drum		c 7 0	; chmod 640 drum ; chgrp kmem drum
d78 2
a79 2
	mknod kmem		c 3 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 3 0	; chmod 640 mem ; chgrp kmem mem
d215 1
a215 1
		chgrp operator ${name}${unit}[a-h] r${name}${unit}[a-h]
@


1.6
log
@OpenBSD'ify
@
text
@d3 1
a3 1
#	$OpenBSD$
d54 1
a54 1
#	*rnd	random data source
d65 1
a65 1
	sh MAKEDEV ra0 ra1 ra2 ra3 ra4 ra5 ra6 ra7 hp0 hp1 rnd
d414 9
a422 8
rnd|srnd|urnd|prnd)
	rm -f rnd urnd srnd prnd
	mknod  rnd c 58 0
	mknod srnd c 58 1
	mknod urnd c 58 2
	mknod prnd c 58 3
	chown root.wheel rnd srnd urnd prnd
	chmod 644 rnd srnd urnd prnd
@


1.5
log
@Backslash continuation of literal strings causes nawk to barf.
@
text
@d2 2
@


1.4
log
@ad rnd devices.
@
text
@d342 2
a343 2
				printf("mknod tty%s%x c 20 %d; \
					mknod pty%s%x c 21 %d; ", \
@


1.3
log
@from ragge:
Added 'all' option to create a reasonable amount of standard devices.
Tape devices now called after their kernel names, (ie. ts0, ht0) and
not mt? for all of them. mt? names are kept as symbolic links anyway
so that it don't break anything.
@
text
@d52 2
d63 1
a63 1
	sh MAKEDEV ra0 ra1 ra2 ra3 ra4 ra5 ra6 ra7 hp0 hp1
d410 10
@


1.2
log
@created devices for the IP filter log on all architectures
@
text
@d2 1
a2 1
#	$NetBSD: MAKEDEV,v 1.2 1995/09/05 19:53:01 ragge Exp $
d9 1
d52 1
a52 1
PATH=/sbin:/bin:/usr/bin
d58 6
d95 5
a99 5
	ht*) blk=1; chr=5 ;;
	tms*) blk=15; chr=38;;
	tm*) blk=5; chr=14;;
	ts*) blk=6; chr=16;;
	ut*) blk=10; chr=17;;
d105 12
a116 12
		mknod mt$unit		b $blk $unit
		mknod mt$four		b $blk $four
		mknod mt$eight		b $blk $eight
		mknod mt$twelve		b $blk $twelve
		mknod nmt$unit		b $blk $four ;: sanity w/pdp11 v7
		mknod nmt$eight		b $blk $twelve ;: ditto
		mknod nrmt$unit		c $chr $four ;: sanity w/pdp11 v7
		mknod nrmt$eight	c $chr $twelve ;: ditto
		mknod rmt$unit		c $chr $unit
		mknod rmt$four		c $chr $four
		mknod rmt$eight		c $chr $eight
		mknod rmt$twelve	c $chr $twelve
d119 17
a135 2
			mknod mt$twenty		b $blk $twenty
			mknod rmt$twenty	c $chr $twenty
@


1.1
log
@Initial revision
@
text
@d326 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
