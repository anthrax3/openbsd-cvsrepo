head	1.89;
access;
symbols
	OPENBSD_4_9:1.88.0.8
	OPENBSD_4_9_BASE:1.88
	OPENBSD_4_8:1.88.0.6
	OPENBSD_4_8_BASE:1.88
	OPENBSD_4_7:1.88.0.2
	OPENBSD_4_7_BASE:1.88
	OPENBSD_4_6:1.88.0.4
	OPENBSD_4_6_BASE:1.88
	OPENBSD_4_5:1.81.0.4
	OPENBSD_4_5_BASE:1.81
	OPENBSD_4_4:1.81.0.2
	OPENBSD_4_4_BASE:1.81
	OPENBSD_4_3:1.79.0.2
	OPENBSD_4_3_BASE:1.79
	OPENBSD_4_2:1.77.0.4
	OPENBSD_4_2_BASE:1.77
	OPENBSD_4_1:1.77.0.2
	OPENBSD_4_1_BASE:1.77
	OPENBSD_4_0:1.75.0.2
	OPENBSD_4_0_BASE:1.75
	OPENBSD_3_9:1.74.0.2
	OPENBSD_3_9_BASE:1.74
	OPENBSD_3_8:1.71.0.4
	OPENBSD_3_8_BASE:1.71
	OPENBSD_3_7:1.71.0.2
	OPENBSD_3_7_BASE:1.71
	OPENBSD_3_6:1.68.0.2
	OPENBSD_3_6_BASE:1.68
	OPENBSD_3_5:1.66.0.2
	OPENBSD_3_5_BASE:1.66
	OPENBSD_3_4:1.64.0.2
	OPENBSD_3_4_BASE:1.64
	OPENBSD_3_3:1.55.0.2
	OPENBSD_3_3_BASE:1.55
	OPENBSD_3_2:1.53.0.2
	OPENBSD_3_2_BASE:1.53
	OPENBSD_3_1:1.50.0.2
	OPENBSD_3_1_BASE:1.50
	OPENBSD_3_0:1.49.0.2
	OPENBSD_3_0_BASE:1.49
	OPENBSD_2_9:1.48.0.2
	OPENBSD_2_9_BASE:1.48
	OPENBSD_2_8:1.41.0.2
	OPENBSD_2_8_BASE:1.41
	OPENBSD_2_7:1.35.0.2
	OPENBSD_2_7_BASE:1.35
	OPENBSD_2_6:1.32.0.2
	OPENBSD_2_6_BASE:1.32
	OPENBSD_2_5:1.31.0.2
	OPENBSD_2_5_BASE:1.31
	OPENBSD_2_4:1.30.0.2
	OPENBSD_2_4_BASE:1.30
	OPENBSD_2_3:1.27.0.2
	OPENBSD_2_3_BASE:1.27
	OPENBSD_2_2:1.23.0.2
	OPENBSD_2_2_BASE:1.23
	OPENBSD_2_1:1.18.0.2
	OPENBSD_2_1_BASE:1.18
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.89
date	2011.04.17.21.35.22;	author schwarze;	state dead;
branches;
next	1.88;

1.88
date	2009.06.03.14.45.39;	author jj;	state Exp;
branches;
next	1.87;

1.87
date	2009.05.24.22.25.12;	author schwarze;	state Exp;
branches;
next	1.86;

1.86
date	2009.05.18.19.37.47;	author schwarze;	state Exp;
branches;
next	1.85;

1.85
date	2009.05.16.23.40.13;	author schwarze;	state Exp;
branches;
next	1.84;

1.84
date	2009.05.14.21.24.33;	author schwarze;	state Exp;
branches;
next	1.83;

1.83
date	2009.05.04.00.37.03;	author schwarze;	state Exp;
branches;
next	1.82;

1.82
date	2009.03.23.15.14.50;	author ajacoutot;	state Exp;
branches;
next	1.81;

1.81
date	2008.07.23.16.05.47;	author sthen;	state Exp;
branches;
next	1.80;

1.80
date	2008.04.17.19.49.16;	author sthen;	state Exp;
branches;
next	1.79;

1.79
date	2007.10.23.11.19.58;	author sthen;	state Exp;
branches;
next	1.78;

1.78
date	2007.08.22.12.03.26;	author henning;	state Exp;
branches;
next	1.77;

1.77
date	2006.10.31.01.38.22;	author dlg;	state Exp;
branches;
next	1.76;

1.76
date	2006.10.13.20.12.16;	author otto;	state Exp;
branches;
next	1.75;

1.75
date	2006.03.21.19.59.28;	author david;	state Exp;
branches;
next	1.74;

1.74
date	2005.12.06.20.18.56;	author pedro;	state Exp;
branches;
next	1.73;

1.73
date	2005.11.24.12.08.15;	author pedro;	state Exp;
branches;
next	1.72;

1.72
date	2005.11.11.18.15.07;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2005.02.22.10.50.55;	author otto;	state Exp;
branches;
next	1.70;

1.70
date	2005.02.07.06.08.10;	author david;	state Exp;
branches;
next	1.69;

1.69
date	2005.01.06.00.00.38;	author jmc;	state Exp;
branches;
next	1.68;

1.68
date	2004.08.25.19.59.29;	author millert;	state Exp;
branches;
next	1.67;

1.67
date	2004.08.25.19.17.30;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2003.12.28.19.51.31;	author otto;	state Exp;
branches;
next	1.65;

1.65
date	2003.11.28.07.32.12;	author sturm;	state Exp;
branches;
next	1.64;

1.64
date	2003.07.07.15.35.55;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2003.07.03.23.05.42;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2003.07.01.22.12.50;	author millert;	state Exp;
branches;
next	1.61;

1.61
date	2003.07.01.21.52.39;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2003.06.30.23.47.14;	author avsm;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.15.22.12.32;	author grange;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.13.15.55.57;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.12.19.11.57;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	2003.04.08.20.42.42;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2002.12.30.13.59.54;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2002.12.15.13.25.27;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2002.07.23.18.26.35;	author pvalchev;	state Exp;
branches;
next	1.52;

1.52
date	2002.07.17.01.32.04;	author jcs;	state Exp;
branches;
next	1.51;

1.51
date	2002.05.22.03.57.24;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2002.02.18.18.13.06;	author pvalchev;	state Exp;
branches;
next	1.49;

1.49
date	2001.10.01.16.52.18;	author jakob;	state Exp;
branches;
next	1.48;

1.48
date	2001.04.06.17.13.37;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2001.04.05.18.47.00;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2001.03.25.04.50.27;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2001.03.16.15.38.13;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2001.01.31.19.12.10;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2000.12.22.08.04.48;	author todd;	state Exp;
branches;
next	1.42;

1.42
date	2000.12.17.22.35.19;	author marc;	state Exp;
branches;
next	1.41;

1.41
date	2000.10.20.16.27.16;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2000.10.18.16.45.27;	author hugh;	state Exp;
branches;
next	1.39;

1.39
date	2000.10.06.17.35.30;	author aaron;	state Exp;
branches;
next	1.38;

1.38
date	2000.07.23.19.49.17;	author rohee;	state Exp;
branches;
next	1.37;

1.37
date	2000.06.18.06.33.34;	author todd;	state Exp;
branches;
next	1.36;

1.36
date	2000.05.26.14.54.17;	author aaron;	state Exp;
branches;
next	1.35;

1.35
date	2000.04.16.20.46.22;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2000.02.29.20.36.25;	author aaron;	state Exp;
branches;
next	1.33;

1.33
date	99.11.22.15.48.07;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	99.06.19.17.14.31;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	98.11.22.22.15.42;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	98.08.17.16.43.47;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	98.07.11.05.01.11;	author marc;	state Exp;
branches;
next	1.28;

1.28
date	98.05.10.18.11.04;	author todd;	state Exp;
branches;
next	1.27;

1.27
date	98.03.22.03.39.11;	author marc;	state Exp;
branches;
next	1.26;

1.26
date	98.02.25.16.00.29;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	97.12.28.23.26.25;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	97.11.17.08.35.42;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	97.10.05.11.49.14;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.09.29.22.15.58;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.09.02.06.46.42;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.06.23.02.54.31;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.06.02.02.02.25;	author flipk;	state Exp;
branches;
next	1.18;

1.18
date	97.03.17.20.17.57;	author gene;	state Exp;
branches;
next	1.17;

1.17
date	96.12.10.07.26.01;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.12.06.18.12.57;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	96.12.06.17.51.49;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	96.12.06.17.17.13;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	96.11.30.17.50.58;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	96.11.23.19.10.43;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	96.10.22.07.58.30;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	96.09.20.20.35.37;	author bitblt;	state Exp;
branches;
next	1.9;

1.9
date	96.09.16.19.40.27;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.09.15.20.29.41;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.09.15.20.12.18;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.19.16.55.51;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.07.12.00.06.50;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.07.09.35.26;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.26.10.25.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.18.16.56.37;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.37.57;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.37.57;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.89
log
@Replaced by src/libexec/security a few minutes ago;
deraadt@@ suggests to remove the old file right away.
@
text
@#
#	$OpenBSD: security,v 1.88 2009/06/03 14:45:39 jj Exp $
#	from: @@(#)security	8.1 (Berkeley) 6/9/93
#

PATH=/bin:/usr/bin:/sbin:/usr/sbin

umask 077

DIR=`mktemp -d /tmp/_secure.XXXXXXXXXX` || exit 1
TMP1=$DIR/_secure2
TMP2=$DIR/_secure3
LIST=$DIR/_secure5

trap 'rm -rf $DIR; exit 1' 0 1 2 3 13 15

# Check the master password file syntax.
MP=/etc/master.passwd
next_part "Checking the ${MP} file:"
awk -F: '{
	if ($0 ~ /^[	 ]*$/) {
		printf("Line %d is a blank line.\n", NR);
		next;
	}
	if (NF != 10)
		printf("Line %d has the wrong number of fields:\n%s\n", NR, $0);
	if ($1 ~ /^[+-]/)
		next;
	if ($1 == "")
		printf("Line %d has an empty login field:\n%s\n", NR, $0);
	else if ($1 !~ /^[A-Za-z0-9_][A-Za-z0-9_\-\.]*\$?$/)
		printf("Login %s has non-alphanumeric characters.\n", $1);
	if (length($1) > 31)
		printf("Login %s has more than 31 characters.\n", $1);
	if ($2 == "")
		printf("Login %s has no password.\n", $1);
	if ($2 != "" && length($2) != 13 && ($10 ~ /.*sh$/ || $10 == "") &&
	   ($2 !~ /^\$[0-9a-f]+\$/) && ($2 != "skey")) {
		if (system("test -s /etc/skey/"$1"") == 0)
			printf("Login %s is off but still has a valid shell and an entry in /etc/skey.\n", $1);
		if (system("test -d "$9" -a ! -r "$9"") == 0)
			printf("Login %s is off but still has valid shell and home directory is unreadable\n\t by root; cannot check for existence of alternate access files.\n", $1);
		else if (system("for file in .ssh .rhosts .shosts .klogin; do if test -e "$9"/$file; then if ((ls -ld "$9"/$file | cut -b 2-10 | grep -q r) && (test ! -O "$9"/$file)) ; then exit 1; fi; fi; done"))
			 printf("Login %s is off but still has a valid shell and alternate access files in\n\t home directory are still readable.\n",$1);
	}
	if ($3 == 0 && $1 != "root")
		printf("Login %s has a user ID of 0.\n", $1);
	if ($3 < 0)
		printf("Login %s has a negative user ID.\n", $1);
	if ($4 < 0)
		printf("Login %s has a negative group ID.\n", $1);
	if (int($7) != 0 && system("test "$7" -lt `date +%s`") == 0)
		printf("Login %s has expired.\n", $1);
}' < $MP

next_part "${MP} has duplicate user names."
awk -F: '{ print $1 }' $MP | sort | uniq -d | column

next_part "${MP} has duplicate user IDs."
awk -F: '/^[^\+]/ { print $1 " " $3 }' $MP | sort -n +1 | tee $TMP1 |
uniq -d -f 1 | awk '{ print $2 }' > $TMP2
if [ -s $TMP2 ] ; then
	while read uid; do
		grep -w $uid $TMP1
	done < $TMP2 | column
fi

# Backup the master password file; a special case, the normal backup
# mechanisms also print out file differences and we don't want to do
# that because this file has encrypted passwords in it.
if [ ! -d /var/backups ] ; then
	mkdir /var/backups
	chmod 700 /var/backups
fi
CUR=/var/backups/`basename $MP`.current
BACK=/var/backups/`basename $MP`.backup
if [ -s $CUR ] ; then
	if cmp -s $CUR $MP; then
		:
	else
		cp -p $CUR $BACK
		cp -p $MP $CUR
		chown root:wheel $CUR
	fi
else
	cp -p $MP $CUR
	chown root:wheel $CUR
fi

# Check the group file syntax.
GRP=/etc/group
next_part "Checking the ${GRP} file:"
awk -F: '{
	if ($0 ~ /^[	 ]*$/) {
		printf("Line %d is a blank line.\n", NR);
		next;
	}
	if ($1 ~ /^[+-].*$/)
		next;
	if (NF != 4)
		printf("Line %d has the wrong number of fields:\n%s\n", NR, $0);
	if ($1 !~ /^[A-Za-z0-9_][A-Za-z0-9_\-\.]*$/)
		printf("Group %s has non-alphanumeric characters.\n", $1);
	if (length($1) > 31)
		printf("Group %s has more than 31 characters.\n", $1);
	if ($3 !~ /^[0-9]*$/)
		printf("Group %s has an invalid group ID.\n", $1);
}' < $GRP

next_part "${GRP} has duplicate group names."
awk -F: '{ print $1 }' $GRP | sort | uniq -d | column

# Check for root paths, umask values in startup files.
# The check for the root paths is problematical -- it's likely to fail
# in other environments.  Once the shells have been modified to warn
# of '.' in the path, the path tests should go away.
rhome=/root
umaskset=no
list="/etc/csh.cshrc /etc/csh.login ${rhome}/.cshrc ${rhome}/.login"
next_part "Checking root csh paths, umask values:\n${list}"
for i in $list ; do
	if [ -s $i ] ; then
		if egrep -aq '[[:space:]]*umask[[:space:]]' $i ; then
			umaskset=yes
		fi
		awk '{
		    if ($1 == "umask") {
			 if ($2 % 100 / 10 ~ /^[0145]/)
			    print "Root umask is group writable";
			 if ($2 % 10 ~ /^[0145]/)
			    print "Root umask is other writable";
		    }
		}' < $i
		SAVE_PATH=$PATH
		unset PATH
		/bin/csh -f -s << end-of-csh > /dev/null 2>&1
			source $i
			if (\$?path) then
				/bin/ls -ldgT \$path > $TMP1
			else
				cat /dev/null > $TMP1
			endif
end-of-csh
		PATH=$SAVE_PATH
		awk '{
			if ($10 ~ /^\.$/) {
				print "The root path includes .";
				next;
			}
		     }
		     $1 ~ /^d....w/ \
	{ print "Root path directory " $10 " is group writable." } \
		     $1 ~ /^d.......w/ \
	{ print "Root path directory " $10 " is other writable." }' \
		< $TMP1
	fi
done
if [ $umaskset = "no" ] ; then
	echo "\nRoot csh startup files do not set the umask."
fi

> $TMP2
rhome=/root
umaskset=no
list="/etc/profile ${rhome}/.profile"
next_part "Checking root sh paths, umask values:\n${list}"
for i in $list; do
	if [ -s $i ] ; then
		if egrep -a umask $i > /dev/null ; then
			umaskset=yes
		fi
		egrep -a umask $i |
		awk '$2 % 100 < 20 \
			{ print "Root umask is group writable" } \
		     $2 % 10 < 2 \
			{ print "Root umask is other writable" }'
		SAVE_PATH=$PATH
		SAVE_ENV=$ENV
		unset PATH ENV
		/bin/sh << end-of-sh > /dev/null 2>&1
			. $i
			if [ X"\$PATH" != "X" ]; then
				list=\`echo \$PATH | /usr/bin/sed -e 's/:/ /g'\`
				/bin/ls -ldgT \$list > $TMP1
			else
				> $TMP1
			fi
			echo \$ENV >> $TMP2
end-of-sh
		PATH=$SAVE_PATH
		ENV=$SAVE_ENV
		awk '{
			if ($10 ~ /^\.$/) {
				print "The root path includes .";
				next;
			}
		     }
		     $1 ~ /^d....w/ \
	{ print "Root path directory " $10 " is group writable." } \
		     $1 ~ /^d.......w/ \
	{ print "Root path directory " $10 " is other writable." }' \
		< $TMP1

	fi
done
if [ $umaskset = "no" ] ; then
	echo "\nRoot sh startup files do not set the umask."
fi

# A good .kshrc will not have a umask or path, that being set in .profile
# check anyway.
rhome=/root
list="/etc/ksh.kshrc `cat $TMP2`"
next_part "Checking root ksh paths, umask values:\n${list}"
(cd $rhome
 for i in $list; do
	if [ -s $i ] ; then
		egrep -a umask $i |
		awk '$2 % 100 < 20 \
			{ print "Root umask is group writable" } \
		     $2 % 10 < 2 \
			{ print "Root umask is other writable" }'
		if egrep -a PATH= $i > /dev/null ; then
			SAVE_PATH=$PATH
			unset PATH
			/bin/ksh << end-of-sh > /dev/null 2>&1
				. $i
				if [ X"\$PATH" != "X" ]; then
					list=\`echo \$PATH | /usr/bin/sed -e 's/:/ /g'\`
					/bin/ls -ldgT \$list > $TMP1
				else
					> $TMP1
				fi
end-of-sh
			PATH=$SAVE_PATH
			awk '{
				if ($10 ~ /^\.$/) {
					print "The root path includes .";
					next;
				}
			    }
			    $1 ~ /^d....w/ \
		{ print "Root path directory " $10 " is group writable." } \
			    $1 ~ /^d.......w/ \
		{ print "Root path directory " $10 " is other writable." }' \
			< $TMP1
		fi

	fi
 done
)

next_part "Checking configuration files:"
# Root and uucp should both be in /etc/ftpusers.
if egrep root /etc/ftpusers > /dev/null ; then
	:
else
	echo "Root not listed in /etc/ftpusers file."
fi
if egrep uucp /etc/ftpusers > /dev/null ; then
	:
else
	echo "Uucp not listed in /etc/ftpusers file."
fi

# Uudecode should not be in the /etc/mail/aliases file.
if egrep 'uudecode|decode' /etc/mail/aliases; then
	echo "There is an entry for uudecode in the /etc/mail/aliases file."
fi

# hostname.if files may contain secrets and should not be
# world-readable.

for f in /etc/hostname.* ; do
	if [ ! -e $f ]; then
		continue
	fi
	if [ "$(stat -Lf "%SLp" $f)" != "---" ]; then
		echo "$f is world readable."
	fi
done

# Files that should not have + signs.
list="/etc/hosts.equiv /etc/shosts.equiv /etc/hosts.lpd"
for f in $list ; do
	if [ -s $f ] ; then
		awk '{
			if ($0 ~ /^\+@@.*$/)
				next;
			if ($0 ~ /^\+.*$/)
				printf("Plus sign in %s file.\n", FILENAME);
		}' $f
	fi
done

# Check for special users with .rhosts/.shosts files.  Only root
# should have .rhosts/.shosts files.  Also, .rhosts/.shosts
# files should not have plus signs.
next_part "Checking for special users with .rhosts/.shosts files."
awk -F: '$1 != "root" && $1 !~ /^[+-]/ && \
	($3 < 100 || $1 == "ftp" || $1 == "uucp") \
		{ print $1 " " $6 }' /etc/passwd |
while read uid homedir; do
	for j in .rhosts .shosts; do
		# Root owned .rhosts/.shosts files are ok.
		if [ -s ${homedir}/$j -a ! -O ${homedir}/$j ] ; then
			rhost=`ls -ldgT ${homedir}/$j`
			echo "${uid}: ${rhost}"
		fi
	done
done

next_part "Checking .rhosts/.shosts files syntax."
awk -F: '/^[^+-]/ { print $1 " " $6 }' /etc/passwd | \
while read uid homedir; do
	for j in .rhosts .shosts; do
		if [ -s ${homedir}/$j ] ; then
			awk '{
				if ($0 ~ /^+@@.*$/ )
					next;
				if ($0 ~ /^\+[ 	]*$/ )
					printf("%s has + sign in it.\n",
						FILENAME);
			}' ${homedir}/$j
		fi
	done
done

# Check home directories.  Directories should not be owned by someone else
# or writeable.
next_part "Checking home directories."
awk -F: '/^[^+-]/ { print $1 " " $6 }' /etc/passwd | \
while read uid homedir; do
	if [ -d ${homedir}/ ] ; then
		file=`ls -ldgT ${homedir}`
		echo "${uid} ${file}"
	fi
done |
awk '$1 != $4 && $4 != "root" \
	{ print "user " $1 " home directory is owned by " $4 }
     $2 ~ /^-....w/ \
	{ print "user " $1 " home directory is group writable" }
     $2 ~ /^-.......w/ \
	{ print "user " $1 " home directory is other writable" }'

# Files that should not be owned by someone else or readable.
list=".netrc .rhosts .gnupg/secring.gpg .gnupg/random_seed \
	.pgp/secring.pgp .shosts .ssh/identity .ssh/id_dsa .ssh/id_rsa"
next_part "Checking dot files."
awk -F: '/^[^+-]/ { print $1 " " $6 }' /etc/passwd | \
while read uid homedir; do
	for f in $list ; do
		file=${homedir}/${f}
		if [ -f $file ] ; then
			echo "${uid} ${f} `ls -ldgT ${file}`"
		fi
	done
done |
awk '$1 != $5 && $5 != "root" \
	{ print "user " $1 " " $2 " file is owned by " $5 }
     $3 ~ /^-...r/ \
	{ print "user " $1 " " $2 " file is group readable" }
     $3 ~ /^-......r/ \
	{ print "user " $1 " " $2 " file is other readable" }
     $3 ~ /^-....w/ \
	{ print "user " $1 " " $2 " file is group writable" }
     $3 ~ /^-.......w/ \
	{ print "user " $1 " " $2 " file is other writable" }'

# Files that should not be owned by someone else or writeable.
list=".bashrc .bash_profile .bash_login .bash_logout .cshrc \
      .emacs .exrc .forward .fvwmrc .inputrc .klogin .kshrc .login \
      .logout .nexrc .profile .screenrc .ssh .ssh/config \
      .ssh/authorized_keys .ssh/authorized_keys2 .ssh/environment \
      .ssh/known_hosts .ssh/rc .tcshrc .twmrc .xsession .xinitrc \
      .Xdefaults .Xauthority"
awk -F: '/^[^+-]/ { print $1 " " $6 }' /etc/passwd | \
while read uid homedir; do
	for f in $list ; do
		file=${homedir}/${f}
		if [ -f $file ] ; then
			echo "${uid} ${f} `ls -ldgT ${file}`"
		fi
	done
done |
awk '$1 != $5 && $5 != "root" \
	{ print "user " $1 " " $2 " file is owned by " $5 }
     $3 ~ /^-....w/ \
	{ print "user " $1 " " $2 " file is group writable" }
     $3 ~ /^-.......w/ \
	{ print "user " $1 " " $2 " file is other writable" }'

# Mailboxes should be owned by user and unreadable.
next_part "Checking mailbox ownership."
ls -l /var/mail | sed 1d | \
awk '$3 != $9 \
	{ print "user " $9 " mailbox is owned by " $3 }
     $1 != "-rw-------" \
	{ print "user " $9 " mailbox is " $1 ", group " $4 }'

# File systems should not be globally exported.
next_part "Checking for globally exported file systems."
if [ -s /etc/exports ] ; then
	awk '{
		if (($1 ~ /^#/) || ($1 ~ /^$/))
			next;
		readonly = 0;
		for (i = 2; i <= NF; ++i) {
			if ($i ~ /^-ro$/)
				readonly = 1;
			else if ($i !~ /^-/ || $i ~ /^-network/)
				next;
		}
		if (readonly)
			print "File system " $1 " globally exported, read-only."
		else
			print "File system " $1 " globally exported, read-write."
	}' < /etc/exports
fi

# Display any changes in setuid/setgid files and devices.
next_part "Setuid/device find errors:"
( set -o noglob
  find / \
	\( ! -fstype local -o -fstype procfs -o -fstype afs -o -fstype nnpfs \
	   `for f in $SUIDSKIP; do echo -o -path $f; done` \
	\) -a -prune -o \
	-type f -a \( -perm -u+s -o -perm -g+s \) -print0 -o \
	! -type d -a ! -type f -a ! -type l -a ! -type s -a ! -type p \
	-print0 | xargs -0 -r ls -ldgT | sort +9 > $LIST
)

# Display any changes in the setuid/setgid file list.
next_part "Checking setuid/setgid files and devices:"
FIELDS1=1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,0
FIELDS2=2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,0
egrep -av '^[bc]' $LIST | join -o $FIELDS2 -110 -210 -v2 /dev/null - > $TMP1
if [ -s $TMP1 ] ; then
	# Check to make sure uudecode isn't setuid.
	if grep -aw uudecode $TMP1 > /dev/null ; then
		echo "Uudecode is setuid."
	fi

	CUR=/var/backups/setuid.current
	BACK=/var/backups/setuid.backup

	if [ -s $CUR ] ; then
		if cmp -s $CUR $TMP1 ; then
			:
		else
			next_part "Setuid additions:"
			join -o $FIELDS2 -110 -210 -v2 $CUR $TMP1 | \
				tee $TMP2 | column -t

			next_part "Setuid deletions:"
			join -o $FIELDS1 -110 -210 -v1 $CUR $TMP1 | \
				tee -a $TMP2 | column -t

			next_part "Setuid changes:"
			sort +9 $TMP2 $CUR $TMP1 | \
			    sed -e 's/[	 ][	 ]*/ /g' | uniq -u | column -t

			cp $CUR $BACK
			cp $TMP1 $CUR
		fi
	else
		next_part "Setuid additions:"
		column -t $TMP1
		cp $TMP1 $CUR
	fi
fi

# Check for block and character disk devices that are readable or writeable
# or not owned by root.operator.
next_part "Checking disk ownership and permissions."
>$TMP1
DISKLIST="ccd dk fd hd hk hp jb kra ra rb rd rl rx rz sd up vnd wd xd"
for i in $DISKLIST; do
	egrep "^b.*/${i}[0-9][0-9]*[B-H]?[a-p]$"  $LIST >> $TMP1
	egrep "^c.*/r${i}[0-9][0-9]*[B-H]?[a-p]$"  $LIST >> $TMP1
done

awk '$3 != "root" || $4 != "operator" || $1 !~ /.rw-r-----/ \
	{ printf("Disk %s is user %s, group %s, permissions %s.\n", \
	    $11, $3, $4, $1); }' < $TMP1

FIELDS1=1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,1.10,0
FIELDS2=2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,2.10,0
# Display any changes in the device file list.
egrep -a '^[bc]' $LIST | sort +10 | \
    join -o $FIELDS2 -111 -211 -v2 /dev/null - > $TMP1
if [ -s $TMP1 ] ; then
	CUR=/var/backups/device.current
	BACK=/var/backups/device.backup

	if [ -s $CUR ] ; then
		if cmp -s $CUR $TMP1 ; then
			:
		else
			next_part "Device additions:"
			join -o $FIELDS2 -111 -211 -v2 $CUR $TMP1 | \
				tee $TMP2 | column -t

			next_part "Device deletions:"
			join -o $FIELDS1 -111 -211 -v1 $CUR $TMP1 | \
				tee -a $TMP2 | column -t

			# Report any block device change.  Ignore character
			# devices, only the name is significant.
			next_part "Block device changes:"
			cat $TMP2 $CUR $TMP1 | \
			sed -e '/^c/d' | \
			sort +10 | \
			sed -e 's/[	 ][	 ]*/ /g' | \
			uniq -u | \
			column -t

			cp $CUR $BACK
			cp $TMP1 $CUR
		fi
	else
		next_part "Device additions:"
		column -t $TMP1
		cp $TMP1 $CUR
	fi
fi

# Check special files.
# Check system binaries.
#
# Create the mtree tree specifications using:
#
#	mtree -cx -p DIR -K md5digest,type >/etc/mtree/DIR.secure
#	chown root:wheel /etc/mtree/DIR.secure
#	chmod 600 /etc/mtree/DIR.secure
#
# Note, this is not complete protection against Trojan horsed binaries, as
# the hacker can modify the tree specification to match the replaced binary.
# For details on really protecting yourself against modified binaries, see
# the mtree(8) manual page.
next_part "Checking special files and directories.
Output format is:\n\tfilename:\n\t\tcriteria (shouldbe, reallyis)"
if [ -d /etc/mtree ] ; then
	cd /etc/mtree
	mtree -e -l -p / -f /etc/mtree/special
	for file in *.secure; do
		[ $file = '*.secure' ] && continue
		tree=`sed -n -e '3s/.* //p' -e 3q $file`
		next_part "Checking system binaries in ${tree}:"
		mtree -f $file -p $tree
	done
else
	echo /etc/mtree is missing
fi

# List of files that get backed up and checked for any modifications.  Each
# file is expected to have two backups, /var/backups/file.{current,backup}.
# Any changes cause the files to rotate.
_fnchg() {
	echo "$1" | sed 's/^\///;s/\//_/g'
}
if [ -s /etc/changelist ] ; then
	for file in `egrep -v "^(#|\+|$MP)" /etc/changelist`; do
		CUR=/var/backups/$(_fnchg  "$file").current
		BACK=/var/backups/$(_fnchg "$file").backup
		next_part "======\n${file} diffs (-OLD  +NEW)\n======"
		if [ -s $file -a ! -d $file ] ; then
			if [ -s $CUR ] ; then
				diff -ua $CUR $file
				if [ -s $PARTOUT ] ; then
					cp -p $CUR $BACK
					cp -p $file $CUR
					chown root:wheel $CUR $BACK
				fi
			else
				diff -u /dev/null $file
				cp -p $file $CUR
				chown root:wheel $CUR
			fi
		fi
		if [ ! -s $file -a -s $CUR ]; then
			diff -u $CUR /dev/null
			cp -p $CUR $BACK
			rm -f $CUR
			chown root:wheel $BACK
		fi
	done
	for file in `sed -n 's/^+//p' /etc/changelist`; do
		CUR=/var/backups/$(_fnchg  "$file").current.md5
		BACK=/var/backups/$(_fnchg "$file").backup.md5
		if [ -s $file -a ! -d $file ] ; then
			MD5_NEW=`md5 $file | sed 's/^.* //'`
			if [ -s $CUR ] ; then
				MD5_OLD="`cat $CUR`"
				if [ "$MD5_NEW" != "$MD5_OLD" ]; then
		next_part "======\n${file} MD5 checksums\n======"
					echo "OLD: $MD5_OLD"
					echo "NEW: $MD5_NEW"
					cp -p $CUR $BACK
					echo $MD5_NEW > $CUR
					chown root:wheel $CUR $BACK
					chmod 600 $CUR
				fi
			else
		next_part "======\n${file} new MD5 checksum\n======"
				echo "NEW: $MD5_NEW"
				echo $MD5_NEW > $CUR
				chown root:wheel $CUR
				chmod 600 $CUR
			fi
		fi
		if [ ! -s $file -a -s $CUR ]; then
			MD5_OLD="`cat $CUR`"
		next_part "======\n${file} removed MD5 checksum\n======"
			echo "OLD: $MD5_OLD"
			cp -p $CUR $BACK
			rm $CUR
			chown root:wheel $BACK
		fi
	done
fi

# Make backups of the labels for any mounted disks and produce diffs
# when they change.
for d in `df -ln | sed -n 's:^/dev/\([a-z]*[0-9]*\)[a-p].*$:\1:p' | sort -u`; do
	file=/var/backups/disklabel.$d
	CUR=$file.current
	BACK=$file.backup
	next_part "======\n${d} diffs (-OLD  +NEW)\n======"
	if disklabel $d > $file 2>&1 ; then
		if [ -s $CUR ] ; then
			diff -u $CUR $file
			if [ -s $PARTOUT ] ; then
				cp -p $CUR $BACK
				cp -p $file $CUR
				chown root:wheel $CUR $BACK
			fi
		else
			cp -p $file $CUR
			chown root:wheel $CUR
		fi
	fi
	rm -f $file
done

# Backup the list of installed packages and produce diffs when it changes.
next_part "======\nPackage list changes (-OLD  +NEW)\n======"
file=/var/backups/pkglist
CUR=$file.current
BACK=$file.backup
if pkg_info > $file 2>&1 ; then
	if [ -s $CUR ] ; then
		diff -u $CUR $file
		if [ -s $PARTOUT ] ; then
			cp -p $CUR $BACK
			cp -p $file $CUR
			chown root:wheel $CUR $BACK
		fi
	else
		cp -p $file $CUR
		chown root:wheel $CUR
	fi
fi
rm -f $file
@


1.88
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@d2 1
a2 1
#	$OpenBSD: security,v 1.87 2009/05/24 22:25:12 schwarze Exp $
@


1.87
log
@new variable SUIDSKIP to exclude paths from setuid and device checks,
useful for example for release(8) DESTDIRs, ro-mounted foreign OS
partitions, nosuid+nodev-mounted backup areas and the like
while here, do not call ls w/o args in case find returns nothing
based on a patch from halex@@, re-implemented by me; variable naming by jmc@@
ok halex@@ jmc@@
@
text
@d2 1
a2 1
#	$OpenBSD: security,v 1.86 2009/05/18 19:37:47 schwarze Exp $
d425 1
a425 1
	\( ! -fstype local -o -fstype procfs -o -fstype afs -o -fstype xfs \
@


1.86
log
@support shell globs on ^+ lines in changelist(5)
based on a patch from John Wong, johnw at wonghome dot net, tweaked by me
while here, document globbing for normal lines, too
"i like that" okan@@;  feedback and ok jmc@@
@
text
@d2 1
a2 1
#	$OpenBSD: security,v 1.85 2009/05/16 23:40:13 schwarze Exp $
d423 5
a427 2
find / \( ! -fstype local \
	-o -fstype procfs -o -fstype afs -o -fstype xfs \) -a -prune -o \
d430 2
a431 1
	-print0 | xargs -0 ls -ldgT | sort +9 > $LIST
@


1.85
log
@fix a couple of obvious echo -> next_part conversions i forgot;
found while investigating an unrelated bug report from John Wong
@
text
@d2 1
a2 1
#	$OpenBSD: security,v 1.84 2009/05/14 21:24:33 schwarze Exp $
d584 1
a584 2
	for file in `egrep "^\+" /etc/changelist`; do
		file="${file#+}"
@


1.84
log
@replace the $OUTPUT idiom by the new next_part function from daily(8)
shortening the script by 100 lines and making it easier to understand
no functional change intended
feedback and ok  sthen@@ ajacoutot@@ okan@@
@
text
@d2 1
a2 1
#	$OpenBSD: security,v 1.83 2009/05/04 00:37:03 schwarze Exp $
d463 1
a463 1
		echo "Setuid additions:"
d518 1
a518 1
		echo "Device additions:"
a519 1
		echo ""
d593 1
a593 1
		echo "\n======\n${file} MD5 checksums\n======"
d602 1
a602 1
			echo "\n======\n${file} new MD5 checksum\n======"
d611 1
a611 1
		echo "\n======\n${file} removed MD5 checksum\n======"
@


1.83
log
@The strings "x5y" and "-42" are not valid group IDs, so fix the regex,
and fix two pastos in the printf(1) reporting bad group IDs;
ok okan@@
@
text
@a0 1
#!/bin/sh -
d2 1
a2 1
#	$OpenBSD: security,v 1.82 2009/03/23 15:14:50 ajacoutot Exp $
a10 1
ERR=$DIR/_secure1
a12 1
TMP3=$DIR/_secure4
a13 1
OUTPUT=$DIR/_secure6
d19 1
d54 1
a54 5
}' < $MP > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking the ${MP} file:"
	cat $OUTPUT
fi
d56 2
a57 5
awk -F: '{ print $1 }' $MP | sort | uniq -d > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\n${MP} has duplicate user names."
	column $OUTPUT
fi
d59 1
a62 1
	echo "\n${MP} has duplicate user IDs."
d92 1
d108 1
a108 5
}' < $GRP > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking the ${GRP} file:"
	cat $OUTPUT
fi
d110 2
a111 5
awk -F: '{ print $1 }' $GRP | sort | uniq -d > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\n${GRP} has duplicate group names."
	column $OUTPUT
fi
a116 1
> $OUTPUT
d120 1
d133 1
a133 1
		}' < $i >> $OUTPUT
d155 1
a155 1
		< $TMP1 >> $OUTPUT
d158 2
a159 8
if [ $umaskset = "no" -o -s $OUTPUT ] ; then
	echo "\nChecking root csh paths, umask values:\n${list}"
	if [ -s $OUTPUT ] ; then
		cat $OUTPUT
	fi
	if [ $umaskset = "no" ] ; then
		echo "\nRoot csh startup files do not set the umask."
	fi
a161 1
> $OUTPUT
d166 1
d176 1
a176 1
			{ print "Root umask is other writable" }' >> $OUTPUT
d202 1
a202 1
		< $TMP1 >> $OUTPUT
d206 2
a207 8
if [ $umaskset = "no" -o -s $OUTPUT ] ; then
	echo "\nChecking root sh paths, umask values:\n${list}"
	if [ -s $OUTPUT ] ; then
		cat $OUTPUT
	fi
	if [ $umaskset = "no" ] ; then
		echo "\nRoot sh startup files do not set the umask."
	fi
a211 1
> $OUTPUT
d214 1
d222 1
a222 1
			{ print "Root umask is other writable" }' >> $OUTPUT
d246 1
a246 1
			< $TMP1 >> $OUTPUT
a251 4
if [ -s $OUTPUT ] ; then
	echo "\nChecking root ksh paths, umask values:\n${list}"
	cat $OUTPUT
fi
d253 1
d258 1
a258 1
	echo "\nRoot not listed in /etc/ftpusers file."
d263 1
a263 1
	echo "\nUucp not listed in /etc/ftpusers file."
d268 1
a268 1
	echo "\nThere is an entry for uudecode in the /etc/mail/aliases file."
d279 1
a279 1
		echo "\n$f is world readable."
d291 1
a291 1
				printf("\nPlus sign in %s file.\n", FILENAME);
d299 1
d311 1
a311 5
done > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking for special users with .rhosts/.shosts files."
	cat $OUTPUT
fi
d313 1
d327 1
a327 5
done > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking .rhosts/.shosts files syntax."
	cat $OUTPUT
fi
d331 1
d344 1
a344 5
	{ print "user " $1 " home directory is other writable" }' > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking home directories."
	cat $OUTPUT
fi
d349 1
d368 1
a368 1
	{ print "user " $1 " " $2 " file is other writable" }' > $OUTPUT
d391 1
a391 5
	{ print "user " $1 " " $2 " file is other writable" }' >> $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking dot files."
	cat $OUTPUT
fi
d394 1
d399 1
a399 5
	{ print "user " $9 " mailbox is " $1 ", group " $4 }' > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking mailbox ownership."
	cat $OUTPUT
fi
d402 1
d418 1
a418 5
	}' < /etc/exports > $OUTPUT
	if [ -s $OUTPUT ] ; then
		echo "\nChecking for globally exported file systems."
		cat $OUTPUT
	fi
d422 2
a423 2
pending="\nChecking setuid/setgid files and devices:\n"
(find / \( ! -fstype local \
d427 1
a427 9
	-print0 | xargs -0 ls -ldgT | sort +9 > $LIST) 2> $OUTPUT

# Display any errors that occurred during system file walk.
if [ -s $OUTPUT ] ; then
	echo "${pending}Setuid/device find errors:"
	pending=
	cat $OUTPUT
	echo ""
fi
d430 1
d437 1
a437 2
		echo "${pending}\nUudecode is setuid."
		pending=
d447 7
a453 16
			> $TMP2
			join -o $FIELDS2 -110 -210 -v2 $CUR $TMP1 > $OUTPUT
			if [ -s $OUTPUT ] ; then
				echo "${pending}Setuid additions:"
				pending=
				tee -a $TMP2 < $OUTPUT | column -t
				echo ""
			fi

			join -o $FIELDS1 -110 -210 -v1 $CUR $TMP1 > $OUTPUT
			if [ -s $OUTPUT ] ; then
				echo "${pending}Setuid deletions:"
				pending=
				tee -a $TMP2 < $OUTPUT | column -t
				echo ""
			fi
d455 1
d457 1
a457 7
			    sed -e 's/[	 ][	 ]*/ /g' | uniq -u > $OUTPUT
			if [ -s $OUTPUT ] ; then
				echo "${pending}Setuid changes:"
				pending=
				column -t $OUTPUT
				echo ""
			fi
d463 1
a463 2
		echo "${pending}Setuid additions:"
		pending=
a464 1
		echo ""
d471 1
d481 1
a481 6
	    $11, $3, $4, $1); }' < $TMP1 > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking disk ownership and permissions."
	cat $OUTPUT
	echo ""
fi
d496 7
a502 14
			> $TMP2
			join -o $FIELDS2 -111 -211 -v2 $CUR $TMP1 > $OUTPUT
			if [ -s $OUTPUT ] ; then
				echo "Device additions:"
				tee -a $TMP2 < $OUTPUT | column -t
				echo ""
			fi

			join -o $FIELDS1 -111 -211 -v1 $CUR $TMP1 > $OUTPUT
			if [ -s $OUTPUT ] ; then
				echo "Device deletions:"
				tee -a $TMP2 < $OUTPUT | column -t
				echo ""
			fi
d506 1
d511 2
a512 6
			uniq -u > $OUTPUT
			if [ -s $OUTPUT ] ; then
				echo "Block device changes:"
				column -t $OUTPUT
				echo ""
			fi
d538 2
d542 1
a542 9
	mtree -e -l -p / -f /etc/mtree/special > $OUTPUT
	if [ -s $OUTPUT ] ; then
		echo "\nChecking special files and directories."
		echo "Output format is:\n\tfilename:"
		echo "\t\tcriteria (shouldbe, reallyis)"
		cat $OUTPUT
	fi

	> $OUTPUT
d546 2
a547 5
		mtree -f $file -p $tree > $TMP1
		if [ -s $TMP1 ] ; then
			echo "\nChecking ${tree}:" >> $OUTPUT
			cat $TMP1 >> $OUTPUT
		fi
a548 4
	if [ -s $OUTPUT ] ; then
		echo "\nChecking system binaries:"
		cat $OUTPUT
	fi
d563 1
d566 2
a567 4
				diff -ua $CUR $file > $OUTPUT
				if [ -s $OUTPUT ] ; then
		echo "\n======\n${file} diffs (-OLD  +NEW)\n======"
					cat $OUTPUT
a572 1
		echo "\n======\n${file} diffs (-OLD  +NEW)\n======"
a578 1
		echo "\n======\n${file} diffs (-OLD  +NEW)\n======"
d627 1
d630 2
a631 4
			diff -u $CUR $file > $OUTPUT
			if [ -s $OUTPUT ] ; then
	echo "\n======\n${d} diffs (-OLD  +NEW)\n======"
				cat $OUTPUT
d645 1
d651 2
a652 4
		diff -u $CUR $file > $OUTPUT
		if [ -s $OUTPUT ] ; then
			echo "\n======\nPackage list changes (-OLD  +NEW)\n======"
			cat $OUTPUT
@


1.82
log
@Small rewording to remove ambiguity.
A package can actually "change" after an update even if its version does
not and yet it will not appear in the security(8) output.

wording by eric@@
ok mbalmer@@
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.81 2008/07/23 16:05:47 sthen Exp $
d115 2
a116 2
	if ($3 !~ /[0-9]*/)
		printf("Login %s has a negative group ID.\n", $1);
@


1.81
log
@Prevent warning about insecure hostnames where no /etc/hostname.*
exists. From wcmaier@@.

Check target of symbolic links to avoid noise at boot and in
seucrity output where you have several interfaces symlinked to one
config file.

"If you think this is the right thing to do" deraadt@@
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.80 2008/04/17 19:49:16 sthen Exp $
d756 1
a756 1
			echo "\n======\nInstalled package changes (-OLD  +NEW)\n======"
@


1.80
log
@Teach security(8) to check for world-readable hostname.if files.
An increasing number of types of these files (e.g. ppp, carp and
wlan adapters) may contain secrets.

ok deraadt oga johan
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.79 2007/10/23 11:19:58 sthen Exp $
d306 4
a309 1
	if [ "$(stat -f "%SLp" $f)" != "---" ]; then
@


1.79
log
@list package changes in daily insecurity output

ok henning
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.78 2007/08/22 12:03:26 henning Exp $
d301 9
@


1.78
log
@plural of ID is IDs, not ID's, ok mk jmc
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.77 2006/10/31 01:38:22 dlg Exp $
d735 21
@


1.77
log
@generate diffs for files listed in /etc/changelist as they are created
and deleted. previously this script only generated diffs for existing
files.

ok lots of people including millert@@ msf@@ mcbride@@ todd@@ and probably more.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.76 2006/10/13 20:12:16 otto Exp $
d72 1
a72 1
	echo "\n${MP} has duplicate user ID's."
@


1.76
log
@changelist files are ascii, even if they contain a few funny chars.
Encountered by henning@@; ok millert@@ robert@@ deraadt@@
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.75 2006/03/21 19:59:28 david Exp $
d662 2
d668 7
d694 2
d700 8
@


1.75
log
@Fix for PR 5043: shell startup scripts might contain binary characters but
grep should assume ASCII text, fixes umask detection
ok millert@@ jaredy@@
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.74 2005/12/06 20:18:56 pedro Exp $
d653 1
a653 1
				diff -u $CUR $file > $OUTPUT
@


1.74
log
@Remove fdescfs
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.73 2005/11/24 12:08:15 pedro Exp $
d139 1
a139 1
		if egrep -q '[[:space:]]*umask[[:space:]]' $i ; then
d191 1
a191 1
		if egrep umask $i > /dev/null ; then
d194 1
a194 1
		egrep umask $i |
d246 1
a246 1
		egrep umask $i |
d251 1
a251 1
		if egrep PATH= $i > /dev/null ; then
@


1.73
log
@Remove kernfs, okay deraadt@@.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.72 2005/11/11 18:15:07 deraadt Exp $
d460 1
a460 1
(find / \( ! -fstype local -o -fstype fdesc \
@


1.72
log
@do not scan afs/xfs directories; chris.kuethe
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.71 2005/02/22 10:50:55 otto Exp $
d460 1
a460 1
(find / \( ! -fstype local -o -fstype fdesc -o -fstype kernfs \
@


1.71
log
@Avoid spurious "globally exported" warning. Noted by jared r r spiegel.
ok henning@@
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.70 2005/02/07 06:08:10 david Exp $
d461 1
a461 1
	-o -fstype procfs \) -a -prune -o \
@


1.70
log
@indentation whitespace nits
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.69 2005/01/06 00:00:38 jmc Exp $
d444 1
a444 1
			else if ($i !~ /^-/)
@


1.69
log
@- document /etc/security's .secure hooks
- sync the comments in /etc/security

ok millert@@
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.68 2004/08/25 19:59:29 millert Exp $
d41 1
a41 1
           ($2 !~ /^\$[0-9a-f]+\$/) && ($2 != "skey")) {
d73 3
a75 3
        while read uid; do
                grep -w $uid $TMP1
        done < $TMP2 | column
d168 1
a168 1
        { print "Root path directory " $10 " is group writable." } \
d170 1
a170 1
        { print "Root path directory " $10 " is other writable." }' \
d221 1
a221 1
        { print "Root path directory " $10 " is group writable." } \
d223 1
a223 1
        { print "Root path directory " $10 " is other writable." }' \
@


1.68
log
@Use $file shorthand instead of specifying /var/backups/disklabel.$d.
Noticed by ian@@
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.67 2004/08/25 19:17:30 millert Exp $
d605 3
a607 3
#	mtree -cx -pDIR -kcksum,gid,mode,nlink,size,link,time,uid > DIR.secure
#	chown root:wheel DIR.secure
#	chmod 600 DIR.secure
@


1.67
log
@store a copy of the disklabel for mounted filesystems and report changes
OK deraadt@@
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.66 2003/12/28 19:51:31 otto Exp $
d699 1
a699 1
	if disklabel $d > /var/backups/disklabel.$d 2>&1 ; then
@


1.66
log
@Update based on PR 2208:
o Prepare for the update to join(1).
o Handle non-ascii chars in pathnames for setuid and device checks.

ok millert@@ deraadt@@
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.65 2003/11/28 07:32:12 sturm Exp $
d692 24
@


1.65
log
@fix regexp for group names

ok millert@@
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.64 2003/07/07 15:35:55 millert Exp $
d475 3
a477 1
egrep -v '^[bc]' $LIST > $TMP1
d480 1
a480 1
	if grep -w uudecode $TMP1 > /dev/null ; then
d493 1
a493 1
			join -110 -210 -v2 $CUR $TMP1 > $OUTPUT
d497 1
a497 1
				tee -a $TMP2 < $OUTPUT
d501 1
a501 1
			join -110 -210 -v1 $CUR $TMP1 > $OUTPUT
d505 1
a505 1
				tee -a $TMP2 < $OUTPUT
d548 2
d551 2
a552 1
egrep '^[bc]' $LIST | sort +10 > $TMP1
d562 1
a562 1
			join -111 -211 -v2 $CUR $TMP1 > $OUTPUT
d565 1
a565 1
				tee -a $TMP2 < $OUTPUT
d569 1
a569 1
			join -111 -211 -v1 $CUR $TMP1 > $OUTPUT
d572 1
a572 1
				tee -a $TMP2 < $OUTPUT
@


1.64
log
@when testing passwd(5) expire field, force its value to an int before
checking for non-zero since an empty field is equivalent to 0.
Problem noted by Graeme Lee.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.63 2003/07/03 23:05:42 millert Exp $
d111 1
a111 1
	if ($1 !~ /^[A-za-z0-9][A-za-z0-9_-]*$/)
@


1.63
log
@Fix setting of umaskset.  Also, there is no need to use TMP3 for
umask detection.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.62 2003/07/01 22:12:50 millert Exp $
d55 1
a55 1
	if ($7 != 0 && system("test "$7" -lt `date +%s`") == 0)
@


1.62
log
@We need the "/ 10" in the group writability check after all; marc@@
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.61 2003/07/01 21:52:39 millert Exp $
d139 3
d149 1
a149 5
		}' < $i > $TMP3
		if [ -s $TMP3 ]; then
			umaskset=yes
			cat $TMP3 >> $OUTPUT
		fi
@


1.61
log
@Make the test for unsafe umask more bullet-proof.  With help from marc@@
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.60 2003/06/30 23:47:14 avsm Exp $
d141 1
a141 1
			 if ($2 % 100 ~ /^[0145]/)
@


1.60
log
@some more extra mktemp randomness; millert@@ ok
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.59 2003/06/15 22:12:32 grange Exp $
d139 9
a147 1
		if egrep umask $i > /dev/null ; then
d149 1
a150 5
		egrep umask $i |
		awk '$2 % 100 < 20 \
			{ print "Root umask is group writable" }
		     $2 % 10 < 2 \
			{ print "Root umask is other writable" }' >> $OUTPUT
@


1.59
log
@The hyphen in regexp should really be escaped
ok millert@@
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.58 2003/06/13 15:55:57 millert Exp $
d11 1
a11 1
DIR=`mktemp -d /tmp/_secure.XXXXXX` || exit 1
@


1.58
log
@Add dot ('.') in usernames too for consistency with adduser/useradd.
Noted by Brian Poole
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.57 2003/06/12 19:11:57 millert Exp $
d34 1
a34 1
	else if ($1 !~ /^[A-Za-z0-9_][A-Za-z0-9_-\.]*\$?$/)
@


1.57
log
@Don't complain about usernames that end in '$' which may be needed by
samba; this is consistent with useradd and adduser.  From Dan Brosemer.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.56 2003/04/08 20:42:42 millert Exp $
d34 1
a34 1
	else if ($1 !~ /^[A-Za-z0-9_][A-Za-z0-9_-]*\$?$/)
@


1.56
log
@Use POSIX chown semantics (user:group); noted by Leandro Costa
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.55 2002/12/30 13:59:54 millert Exp $
d34 1
a34 1
	else if ($1 !~ /^[A-Za-z0-9_][A-Za-z0-9_-]*$/)
@


1.55
log
@put bin dirs before sbin dirs in PATH for consistency with other cron scripts
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.54 2002/12/15 13:25:27 henning Exp $
d93 1
a93 1
		chown root.wheel $CUR
d97 1
a97 1
	chown root.wheel $CUR
d598 1
a598 1
#	chown root.wheel DIR.secure
d651 1
a651 1
					chown root.wheel $CUR $BACK
d655 1
a655 1
				chown root.wheel $CUR
d673 1
a673 1
					chown root.wheel $CUR $BACK
d678 1
a678 1
				chown root.wheel $CUR
@


1.54
log
@writeable -> writable; torh at bogus dot net
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.53 2002/07/23 18:26:35 pvalchev Exp $
d7 1
a7 1
PATH=/sbin:/usr/sbin:/bin:/usr/bin
@


1.53
log
@check account expiration time as well; from hamajima@@nagoya.ydc.co.jp pr2835
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.52 2002/07/17 01:32:04 jcs Exp $
d144 1
a144 1
			{ print "Root umask is group writeable" }
d146 1
a146 1
			{ print "Root umask is other writeable" }' >> $OUTPUT
d165 1
a165 1
        { print "Root path directory " $10 " is group writeable." } \
d167 1
a167 1
        { print "Root path directory " $10 " is other writeable." }' \
d193 1
a193 1
			{ print "Root umask is group writeable" } \
d195 1
a195 1
			{ print "Root umask is other writeable" }' >> $OUTPUT
d218 1
a218 1
        { print "Root path directory " $10 " is group writeable." } \
d220 1
a220 1
        { print "Root path directory " $10 " is other writeable." }' \
d245 1
a245 1
			{ print "Root umask is group writeable" } \
d247 1
a247 1
			{ print "Root umask is other writeable" }' >> $OUTPUT
d268 1
a268 1
		{ print "Root path directory " $10 " is group writeable." } \
d270 1
a270 1
		{ print "Root path directory " $10 " is other writeable." }' \
d363 1
a363 1
	{ print "user " $1 " home directory is group writeable" }
d365 1
a365 1
	{ print "user " $1 " home directory is other writeable" }' > $OUTPUT
d390 1
a390 1
	{ print "user " $1 " " $2 " file is group writeable" }
d392 1
a392 1
	{ print "user " $1 " " $2 " file is other writeable" }' > $OUTPUT
d413 1
a413 1
	{ print "user " $1 " " $2 " file is group writeable" }
d415 1
a415 1
	{ print "user " $1 " " $2 " file is other writeable" }' >> $OUTPUT
@


1.52
log
@don't complain about our new usernames that start with underscores

deraadt and millert ok
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.51 2002/05/22 03:57:24 millert Exp $
d55 2
@


1.51
log
@Check for S/Key entries in /etc/skey, not /etc/skeyeys; David Krause
We could use skeyinfo(1) to check but this is much cheaper.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.50 2002/02/18 18:13:06 pvalchev Exp $
d34 1
a34 1
	else if ($1 !~ /^[A-Za-z0-9][A-Za-z0-9_-]*$/)
@


1.50
log
@use mktemp; help & ok millert
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.49 2001/10/01 16:52:18 jakob Exp $
d42 2
a43 2
		if (system("test -s /etc/skeykeys && grep -q \"^"$1" \" /etc/skeykeys") == 0)
			printf("Login %s is off but still has a valid shell and an entry in /etc/skeykeys.\n", $1);
@


1.49
log
@mtree -l (loose permissions check) on /etc/mtree/special. ok millert@@.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.48 2001/04/06 17:13:37 brad Exp $
d11 1
a11 1
DIR=/tmp/_secure$$
a17 6

if ! mkdir $DIR ; then
	echo "tmp directory ${DIR} already exists, looks like:"
	ls -alqF $DIR
	exit 1
fi
@


1.48
log
@fix username and groupname length checks.
--
Patch from: wilfried@@ via PR#1761
Ok'd by: deraadt@@
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.47 2001/04/05 18:47:00 millert Exp $
d611 1
a611 1
	mtree -e -p / -f /etc/mtree/special > $OUTPUT
@


1.47
log
@Skip entries starting with '+' in duplicate user ID check so we don't
get false positives for YP stuff.  Closes PR 1755
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.46 2001/03/25 04:50:27 millert Exp $
d42 2
a43 2
	if (length($1) > 32)
		printf("Login %s has more than 32 characters.\n", $1);
d117 2
a118 2
	if (length($1) > 8)
		printf("Group %s has more than 8 characters.\n", $1);
@


1.46
log
@Don't provide diffs of sensitive files like ssh host keys.  Instead,
just save the md5 checksums so we can still determine when something
change.  Entries in /etc/changelist that are prefixed with a '+'
will only have their md5 checksums saved, not the actual files.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.45 2001/03/16 15:38:13 millert Exp $
d73 1
a73 1
awk -F: '{ print $1 " " $3 }' $MP | sort -n +1 | tee $TMP1 |
@


1.45
log
@Add ~/.ssh/id_dsa and ~/.ssh/id_rsa to the "must be owned by user and
not readable by other" block.  Remove ~/.ssh/random_seed as it is
not used in OpenSSH.

Add ~/.ssh/authorized_keys2, and ~/.ssh/known_hosts to the "must be
owned by user and not writable"  block.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.44 2001/01/31 19:12:10 deraadt Exp $
d644 1
a644 1
	for file in `egrep -v "^#|$MP" /etc/changelist`; do
d660 24
@


1.44
log
@more fat utmp; ianm@@cit.uws.edu.au
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.43 2000/12/22 08:04:48 todd Exp $
d377 1
a377 1
	.pgp/secring.pgp .shosts .ssh/identity .ssh/random_seed"
d402 3
a404 2
      .ssh/authorized_keys .ssh/environment .ssh/known_hosts .ssh/rc \
      .tcshrc .twmrc .xsession .xinitrc .Xdefaults .Xauthority"
@


1.43
log
@gnupg ring/data ownership/permission checking added; ok millert@@
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.42 2000/12/17 22:35:19 marc Exp $
d42 2
a43 2
	if (length($1) > 8)
		printf("Login %s has more than 8 characters.\n", $1);
@


1.42
log
@Todd, Aaron, Dug, and me all prefer unidiff
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.41 2000/10/20 16:27:16 millert Exp $
d376 2
a377 1
list=".netrc .rhosts .pgp/secring.pgp .shosts .ssh/identity .ssh/random_seed"
@


1.41
log
@Since sh's bulitin echo(1) supports /t and /n there is no reason to
use printf(1) here.  This way there is no possibility of format
string problems and we use a shell builtin instead of an external
command.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.40 2000/10/18 16:45:27 hugh Exp $
d647 1
a647 1
				diff $CUR $file > $OUTPUT
d649 1
a649 1
		echo "\n======\n${file} diffs (OLD < > NEW)\n======"
@


1.40
log
@printf(1) format string fixes! checked by theo.
inspiration from dynamo@@ime.net.
also a typo fix.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.39 2000/10/06 17:35:30 aaron Exp $
d20 1
a20 1
	printf "tmp directory %s already exists, looks like:\n" $DIR
d63 1
a63 1
	printf "\nChecking the %s file:\n" "$MP"
d69 1
a69 1
	printf "\n%s has duplicate user names.\n" "$MP"
d76 1
a76 1
	printf "\n%s has duplicate user ID's.\n" "$MP"
d123 1
a123 1
	printf "\nChecking the %s file:\n" "$GRP"
d129 1
a129 1
	printf "\n%s has duplicate group names.\n" "$GRP"
d176 1
a176 1
	printf "\nChecking root csh paths, umask values:\n%s\n" "$list"
d181 1
a181 1
		printf "\nRoot csh startup files do not set the umask.\n"
d230 1
a230 1
	printf "\nChecking root sh paths, umask values:\n%s\n" "$list"
d235 1
a235 1
		printf "\nRoot sh startup files do not set the umask.\n"
d282 1
a282 1
	printf "\nChecking root ksh paths, umask values:\n%s\n" "$list"
d290 1
a290 1
	printf "\nRoot not listed in /etc/ftpusers file.\n"
d295 1
a295 1
	printf "\nUucp not listed in /etc/ftpusers file.\n"
d300 1
a300 1
	printf "\nThere is an entry for uudecode in the /etc/mail/aliases file.\n"
d327 1
a327 1
			printf "%s: %s\n" "$uid" "$rhost"
d332 1
a332 1
	printf "\nChecking for special users with .rhosts/.shosts files.\n"
d351 1
a351 1
	printf "\nChecking .rhosts/.shosts files syntax.\n"
d361 1
a361 1
		printf "%s %s\n" "$uid" "$file"
d371 1
a371 1
	printf "\nChecking home directories.\n"
d382 1
a382 1
			printf "%s %s %s\n" "$uid" "$f" "`ls -ldgT $file`"
d408 1
a408 1
			printf "%s %s %s\n" "$uid" "$f" "`ls -ldgT $file`"
d419 1
a419 1
	printf "\nChecking dot files.\n"
d430 1
a430 1
	printf "\nChecking mailbox ownership.\n"
d452 1
a452 1
		printf "\nChecking for globally exported file systems.\n"
d467 1
a467 1
	printf "%sSetuid/device find errors:\n" "$pending"
d470 1
a470 1
	printf "\n"
d478 1
a478 1
		printf "%s\nUudecode is setuid.\n" "$pending"
d492 1
a492 1
				printf "%sSetuid additions:\n" "$pending"
d495 1
a495 1
				printf "\n"
d500 1
a500 1
				printf "%sSetuid deletions:\n" "$pending"
d503 1
a503 1
				printf "\n"
d509 1
a509 1
				printf "%sSetuid changes:\n" "$pending"
d512 1
a512 1
				printf "\n"
d519 1
a519 1
		printf "%sSetuid additions:\n" "$pending"
d522 1
a522 1
		printf "\n"
d540 1
a540 1
	printf "\nChecking disk ownership and permissions.\n"
d542 1
a542 1
	printf "\n"
d558 1
a558 1
				printf "Device additions:\n"
d560 1
a560 1
				printf "\n"
d565 1
a565 1
				printf "Device deletions:\n"
d567 1
a567 1
				printf "\n"
d578 1
a578 1
				printf "Block device changes:\n"
d580 1
a580 1
				printf "\n"
d587 1
a587 1
		printf "Device additions:\n"
d589 1
a589 1
		printf "\n"
d611 3
a613 3
		printf "\nChecking special files and directories.\n"
		printf "Output format is:\n\tfilename:\n"
		printf "\t\tcriteria (shouldbe, reallyis)\n"
d623 1
a623 1
			printf "\nChecking %s:\n" "$tree" >> $OUTPUT
d628 1
a628 1
		printf "\nChecking system binaries:\n"
d649 1
a649 1
		printf "\n======\n%s diffs (OLD < > NEW)\n======\n" $file
@


1.39
log
@When including the listing of a directory in root's security mail, pass the
-q flag to ls(1) so that non-printable characters will appear as '?'. This
prevents a malicious user from fooling the administrator into thinking the
contents of a file name are actually valid script output (note that you can
put newlines in file names); deraadt@@ ok
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.38 2000/07/23 19:49:17 rohee Exp $
d51 1
a51 1
			printf("Login %s if off but still has valid shell and home directory is unreadable\n\t by root; cannot check for existence of alternate access files.\n", $1);
d63 1
a63 1
	printf "\nChecking the $MP file:\n"
d69 1
a69 1
	printf "\n$MP has duplicate user names.\n"
d76 1
a76 1
	printf "\n$MP has duplicate user ID's.\n"
d123 1
a123 1
	printf "\nChecking the $GRP file:\n"
d129 1
a129 1
	printf "\n$GRP has duplicate group names.\n"
d176 1
a176 1
	printf "\nChecking root csh paths, umask values:\n$list\n"
d230 1
a230 1
	printf "\nChecking root sh paths, umask values:\n$list\n"
d282 1
a282 1
	printf "\nChecking root ksh paths, umask values:\n$list\n"
d327 1
a327 1
			printf "$uid: $rhost\n"
d361 1
a361 1
		printf "$uid $file\n"
d382 1
a382 1
			printf "$uid $f `ls -ldgT $file`\n"
d408 1
a408 1
			printf "$uid $f `ls -ldgT $file`\n"
d467 1
a467 1
	printf "${pending}Setuid/device find errors:\n"
d478 1
a478 1
		printf "${pending}\nUudecode is setuid.\n"
d492 1
a492 1
				printf "${pending}Setuid additions:\n"
d500 1
a500 1
				printf "${pending}Setuid deletions:\n"
d509 1
a509 1
				printf "${pending}Setuid changes:\n"
d519 1
a519 1
		printf "${pending}Setuid additions:\n"
d623 1
a623 1
			printf "\nChecking $tree:\n" >> $OUTPUT
@


1.38
log
@Add a little blurb explaing the meaning of mtree's output.
millert@@ ok.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.37 2000/06/18 06:33:34 todd Exp $
d21 1
a21 1
	ls -alF $DIR
@


1.37
log
@fix inspired by pr 744 from karls@@inet.no
changed so files are e.g. backups/etc_passwd not backups/_etc_passwd
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.36 2000/05/26 14:54:17 aaron Exp $
d612 2
@


1.36
log
@Capitalize 'id' to be consistent with our man pages.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.35 2000/04/16 20:46:22 millert Exp $
d636 3
d641 3
a643 3
		CUR=/var/backups/`basename $file`.current
		BACK=/var/backups/`basename $file`.backup
		if [ -s $file ] ; then
@


1.35
log
@sendmail support files now live in /etc/mail
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.34 2000/02/29 20:36:25 aaron Exp $
d56 1
a56 1
		printf("Login %s has a user id of 0.\n", $1);
d58 1
a58 1
		printf("Login %s has a negative user id.\n", $1);
d60 1
a60 1
		printf("Login %s has a negative group id.\n", $1);
d76 1
a76 1
	printf "\n$MP has duplicate user id's.\n"
d120 1
a120 1
		printf("Login %s has a negative group id.\n", $1);
@


1.34
log
@existance -> existence
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.33 1999/11/22 15:48:07 millert Exp $
d298 3
a300 3
# Uudecode should not be in the /etc/aliases file.
if egrep 'uudecode|decode' /etc/aliases; then
	printf "\nThere is an entry for uudecode in the /etc/aliases file.\n"
@


1.33
log
@match /dev/fd{0,1,2,3}{,B,C,D,E,F,G,H}[abcdefghijklmnop] when doing device checks; closes PR #750
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.32 1999/06/19 17:14:31 espie Exp $
d51 1
a51 1
			printf("Login %s if off but still has valid shell and home directory is unreadable\n\t by root; cannot check for existance of alternate access files.\n", $1);
@


1.32
log
@Give line printout along with line number.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.31 1998/11/22 22:15:42 deraadt Exp $
d532 2
a533 2
	egrep "^b.*/${i}[0-9][0-9]*[a-p]$"  $LIST >> $TMP1
	egrep "^c.*/r${i}[0-9][0-9]*[a-p]$"  $LIST >> $TMP1
@


1.31
log
@make /var/backups same as mtree says; mickey
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.30 1998/08/17 16:43:47 millert Exp $
d35 1
a35 1
		printf("Line %d has the wrong number of fields.\n", NR);
d39 1
a39 1
		printf("Line %d has an empty login field.\n", NR);
d114 1
a114 1
		printf("Line %d has the wrong number of fields.\n", NR);
@


1.30
log
@don't include FIFOs in check for set[ug]id files and devices; andrew@@nfr.net
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.29 1998/07/11 05:01:11 marc Exp $
d87 1
a87 1
	chmod 755 /var/backups
@


1.29
log
@better checks for . in path from "Denis A. Doroshenko" <cyxob@@isl.vtu.lt>
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.28 1998/05/10 18:11:04 todd Exp $
d462 2
a463 2
	! -type d -a ! -type f -a ! -type l -a ! -type s -print0 | \
xargs -0 ls -ldgT | sort +9 > $LIST) 2> $OUTPUT
@


1.28
log
@Check a few more DOTfiles that could potentially compromise security on a per
user basis.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.27 1998/03/22 03:39:11 marc Exp $
d155 5
a159 1
			/bin/ls -ldgT \$path > $TMP1
d186 1
d201 2
a202 1
		unset PATH
d205 7
a211 2
			list=\`echo \$PATH | /usr/bin/sed -e 's/:/ /g'\`
			/bin/ls -ldgT \$list > $TMP1
d214 1
d243 3
a245 2
list="/etc/ksh.kshrc ${rhome}/.kshrc"
for i in $list; do
d257 6
a262 2
				list=\`echo \$PATH | /usr/bin/sed -e 's/:/ /g'\`
				/bin/ls -ldgT \$list > $TMP1
d279 2
a280 1
done
@


1.27
log
@fix ksh.kshrc; check ksh.kshrc, .kshrc for owner/mode/path
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.26 1998/02/25 16:00:29 millert Exp $
d358 1
a358 1
list=".netrc .rhosts .shosts"
d380 5
a384 2
list=".bashrc .cshrc .emacs .exrc .forward .klogin .login .logout \
      .profile .tcshrc .kshrc .xsession"
@


1.26
log
@Deal with non-existent /etc/skeykeys
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.25 1997/12/28 23:26:25 deraadt Exp $
d227 41
d381 1
a381 1
      .profile .tcshrc"
@


1.25
log
@be more careful during termination
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.24 1997/11/17 08:35:42 deraadt Exp $
d48 1
a48 1
		if (system("grep -q \"^"$1" \" /etc/skeykeys") == 0)
@


1.24
log
@completely avoid master.passwd in the changelist processing; jbernard@@tater.mines.edu
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.23 1997/10/05 11:49:14 deraadt Exp $
d25 1
a25 1
trap 'rm -rf $DIR' 0 1 15
@


1.23
log
@handling for closed home directories;  yensid@@afri.imsa.edu
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.22 1997/09/29 22:15:58 deraadt Exp $
d575 1
a575 1
	for file in `cat /etc/changelist`; do
@


1.22
log
@oops, detect blowfish-a as OK; yensid@@imsa.edu, PR#321
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.21 1997/09/02 06:46:42 deraadt Exp $
d46 9
a54 2
	if ((length($2) != 13 && ($10 ~ /.*sh$/ || $10 == "")) && ($2 !~ /^\$[0-9a-f]+\$/) && system("if grep -q \"^"$1" \" /etc/skeykeys || test -d "$9"/.ssh -a ! -O "$9"/.ssh ; then exit 1 ; fi ; for i in .rhosts .shosts .klogin ; do test -s "$9"/$i -a ! -O "$9"/$i && exit 1 ; done ; exit 0") != 0)
		printf("Login %s is off but still has a valid shell.\n", $1);
@


1.21
log
@better path handling; jbernard@@tater.mines.edu, netbsd pr#3995
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.20 1997/06/23 02:54:31 millert Exp $
d46 1
a46 1
	if ((length($2) != 13 && ($10 ~ /.*sh$/ || $10 == "")) && ($2 !~ /^\$[0-9]+\$/) && system("if grep -q \"^"$1" \" /etc/skeykeys || test -d "$9"/.ssh -a ! -O "$9"/.ssh ; then exit 1 ; fi ; for i in .rhosts .shosts .klogin ; do test -s "$9"/$i -a ! -O "$9"/$i && exit 1 ; done ; exit 0") != 0)
@


1.20
log
@/etc/profile should be checked along with .profile for consistency with
/etc/csh.login and .login.  From Chris Jones <cjones@@rupert.oscs.montana.edu>
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.19 1997/06/02 02:02:25 flipk Exp $
d144 2
a146 1
			unset path
d150 1
d188 2
a190 1
			PATH=
d195 1
@


1.19
log
@1. ignore blank lines
2. /-ro/   ->  /^-ro$/ : allows hostnames containing "*-ro*" and
   ignores "-root"
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.18 1997/03/17 20:17:57 gene Exp $
d175 1
a175 1
list="${rhome}/.profile"
@


1.18
log
@Don't consider an account disabled just because the password length != 13.
Also, take into account users w/ the blowfish cypher.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.17 1996/12/10 07:26:01 deraadt Exp $
d364 1
a364 1
		if ($1 ~ /^#/)
d368 1
a368 1
			if ($i ~ /-ro/)
@


1.17
log
@blow away tmp dir on more traps
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.16 1996/12/06 18:12:57 millert Exp $
d46 1
a46 1
	if ((length($2) != 13 && ($10 ~ /.*sh$/ || $10 == "")) && system("if grep -q \"^"$1" \" /etc/skeykeys || test -d "$9"/.ssh -a ! -O "$9"/.ssh ; then exit 1 ; fi ; for i in .rhosts .shosts .klogin ; do test -s "$9"/$i -a ! -O "$9"/$i && exit 1 ; done ; exit 0") != 0)
@


1.16
log
@check for entry in /etc/skeykeys and ~/.ssh in evil system()
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.15 1996/12/06 17:51:49 millert Exp $
d25 1
a25 1
trap 'rm -rf $DIR' 0
@


1.15
log
@Change some "test -f" to "test -s"
Don't bitch about star'd out logins unless they have a .rhosts/.shosts/.klogin
file (ie: something that would let them in via rsh/ssh).
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.14 1996/12/06 17:17:13 millert Exp $
d46 1
a46 1
	if ((length($2) != 13 && ($10 ~ /.*sh$/ || $10 == "")) && system("for i in .rhosts .shosts .klogin ; do test -s "$9"/$i -a ! -O "$9"/$i && exit 1 ; done ; exit 0") != 0)
@


1.14
log
@skip lines in /etc/passwd that start with + or -.
don't bitch about root-owned .rhosts since multiple system accounts
share root's homedir.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.13 1996/11/30 17:50:58 millert Exp $
d36 1
a36 1
	if ($1 ~ /^[+-].*$/)
d46 1
a46 1
	if (length($2) != 13 && ($10 ~ /.*sh$/ || $10 == ""))
d135 1
a135 1
	if [ -f $i ] ; then
d177 1
a177 1
	if [ -f $i ] ; then
d255 1
a255 1
		if [ -f ${homedir}/$j -a ! -O ${homedir}/$j ] ; then
@


1.13
log
@Merged our changes back into 4.4BSD version.
Can't do "find -ls" since we need to store the date in an absolute format
(ls -T).  Use "find -print0" | xargs -0 instead.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.12 1996/11/23 19:10:43 millert Exp $
d249 1
a249 1
awk -F: '$1 != "root" && $1 !~ /^[+-].*$/ && \
d254 2
a255 1
		if [ -f ${homedir}/$j ] ; then
d266 1
a266 1
awk -F: '{ print $1 " " $6 }' /etc/passwd | \
d287 1
a287 1
awk -F: '{ if ($1 !~ /^[+-].*$/) print $1 " " $6 }' /etc/passwd | \
d307 1
a307 1
awk -F: '{ print $1 " " $6 }' /etc/passwd | \
d330 1
a330 1
awk -F: '{ print $1 " " $6 }' /etc/passwd | \
@


1.12
log
@Deal with leading whitespace in find output.  Fixes problem of devices
showing up in the setuid list ;-)
@
text
@d3 2
a4 1
#	$OpenBSD: security,v 1.11 1996/10/22 07:58:30 tholo Exp $
d6 1
a18 1

d39 1
a39 1
		printf("Line %d has an empty login field.\n",NR);
d108 1
a108 1
	if ($1 !~ /^[A-za-z0-9]*$/)
d164 1
a164 1
	if [ -s $OUTPUT ]; then
d208 1
a208 1
	if [ -s $OUTPUT ]; then
d238 1
a238 1
			if ($0 ~ /^\+@@.*$/ )
d240 1
a240 1
			if ($0 ~ /^\+.*$/ )
d246 3
a248 3
# Check for special users with .rhosts/.shosts files.  Only root should
# have .rhosts/.shosts files.  Also, .rhosts/.shosts files
# should not have plus signs.
d268 1
a268 1
		if [ -f ${homedir}/$j ] ; then
d274 1
a274 1
					    FILENAME);
d286 1
a286 1
awk -F: '{ if ( $1 !~ /^[+-].*$/ ) print $1 " " $6 }' /etc/passwd | \
d317 2
d360 4
a363 10
if [ -f /etc/exports ]; then
    # File systems should not be globally exported.
    awk '{
	if ($1 ~ /^#/)
		next;
	readonly = 0;
	for (i = 2; i <= NF; ++i) {
		if ($i ~ /-ro/)
			readonly = 1;
		else if ($i !~ /^-/)
d365 16
a380 10
	}
	if (readonly)
		print "File system " $1 " globally exported, read-only."
	else
		print "File system " $1 " globally exported, read-write."
    }' < /etc/exports > $OUTPUT
    if [ -s $OUTPUT ] ; then
	printf "\nChecking for globally exported file systems.\n"
	cat $OUTPUT
    fi
d386 4
a389 4
		-o -fstype procfs \) -a -prune -o \
	-type f -a \( -perm -u+s -o -perm -g+s \) -ls -o \
	! -type d -a ! -type f -a ! -type l -a ! -type s -ls | \
sort > $LIST) 2> $OUTPUT
d400 1
a400 1
egrep -v '^ *[0-9]+ +[0-9]+ +[bc]' $LIST > $TMP1
d416 1
a416 1
			join -112 -212 -v2 $CUR $TMP1 > $OUTPUT
d424 1
a424 1
			join -112 -212 -v1 $CUR $TMP1 > $OUTPUT
d432 1
a432 1
			sort +11 $TMP2 $CUR $TMP1 | \
d456 1
a456 1
DISKLIST="dk fd hd hk hp jb kra ra rb rd rl rx xd rz sd up wd vnd ccd"
d533 1
a533 1
if [ -d /etc/mtree ]; then
d546 1
a546 1
		if [ -s $TMP1 ]; then
d566 1
a566 1
		if [ -s $file ]; then
@


1.11
log
@Update to work properly with output from find -ls; also skip commented out
lines in /etc/exports
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.10 1996/09/20 20:35:37 bitblt Exp $
d396 2
a397 2
# Display any changes in the setuid file list.
egrep -v '^[0-9]+ +[0-9]+ +[bc]' $LIST > $TMP1
@


1.10
log
@names of set-uid files are no longer passed to a shell.
Thanks to deraadt for pointing out the -ls flag on find.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.9 1996/09/16 19:40:27 deraadt Exp $
d360 2
d384 1
a384 1
	-type f -a \( -perm -u+s -o -perm -g+s \) -print -o \
d397 1
a397 1
egrep -v '^[bc]' $LIST > $TMP1
d413 1
a413 1
			join -110 -210 -v2 $CUR $TMP1 > $OUTPUT
d421 1
a421 1
			join -110 -210 -v1 $CUR $TMP1 > $OUTPUT
d429 1
a429 1
			sort +9 $TMP2 $CUR $TMP1 | \
d455 2
a456 2
	egrep "^b.*/${i}[0-9][0-9]*[a-h]$"  $LIST >> $TMP1
	egrep "^c.*/r${i}[0-9][0-9]*[a-h]$"  $LIST >> $TMP1
@


1.9
log
@toor is gone; thanks bibtlt
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.8 1996/09/15 20:29:41 deraadt Exp $
d383 2
a384 2
	! -type d -a ! -type f -a ! -type l -a ! -type s -print | \
sort | sed -e 's/^/ls -ldgT /' | sh > $LIST) 2> $OUTPUT
@


1.8
log
@setup trap after mkdir
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.7 1996/09/15 20:12:18 deraadt Exp $
d47 1
a47 1
	if ($3 == 0 && $1 != "root" && $1 != "toor")
d65 1
a65 1
awk -F: '$1 != "toor" { print $1 " " $3 }' $MP | sort -n +1 | tee $TMP1 |
d245 2
a246 2
# Check for special users with .rhosts/.shosts files.  Only root and
# toor should have .rhosts/.shosts files.  Also, .rhosts/.shosts files
d248 1
a248 1
awk -F: '$1 != "root" && $1 != "toor" && $1 !~ /^[+-].*$/ && \
@


1.7
log
@kill the races; found by bitblt
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.6 1996/07/19 16:55:51 millert Exp $
a16 1
trap 'rm -rf $DIR' 0
a17 1
umask 077
d23 2
@


1.6
log
@Would give complain that /etc/hosts.equiv /etc/shosts.equiv /etc/hosts.lpd
have '+' in them even when they don't.  Escaped the + to fix.
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.5 1996/07/12 00:06:50 deraadt Exp $
d9 7
a15 6
ERR=/tmp/_secure1.$$
TMP1=/tmp/_secure2.$$
TMP2=/tmp/_secure3.$$
TMP3=/tmp/_secure4.$$
LIST=/tmp/_secure5.$$
OUTPUT=/tmp/_secure6.$$
d17 8
a24 1
trap 'rm -f $ERR $TMP1 $TMP2 $TMP3 $LIST $OUTPUT' 0
@


1.5
log
@setgid too
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.4 1996/07/07 09:35:26 deraadt Exp $
d227 1
a227 1
	if [ -f $f ] ; then
d229 1
a229 1
			if ($0 ~ /^+@@.*$/ )
d231 1
a231 1
			if ($0 ~ /^+.*$/ )
@


1.4
log
@only watch for pure + entries
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.3 1996/05/26 10:25:29 deraadt Exp $
d370 2
a371 2
# Display any changes in setuid files and devices.
pending="\nChecking setuid files and devices:\n"
@


1.3
log
@sync & label
@
text
@d3 1
a3 1
#	$OpenBSD$
d263 1
a263 1
				if ($0 ~ /^+.*$/ )
@


1.2
log
@numerous improvements by arnej@@pvv.unit.no, david@@city.ac.uk, and myself.
complain less in normal situations, and deal better with netgroups, YP,
ssh configuration files, and other rather normal configurations.
@
text
@d3 1
a3 2
#	from: @@(#)security	8.1 (Berkeley) 6/9/93
#	$Id: security,v 1.1.1.1 1995/10/18 08:37:57 deraadt Exp $
a4 1

@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
#	$Id: security,v 1.11 1995/01/31 16:09:45 jtc Exp $
d29 5
a33 1
	if ($1 !~ /^[A-Za-z0-9]*$/)
d59 1
a59 1
awk -F: '{ print $1 " " $3 }' $MP | sort -n +1 | tee $TMP1 |
d71 4
d97 2
d227 1
a227 1
list="/etc/hosts.equiv /etc/hosts.lpd"
d229 7
a235 2
	if egrep '\+' $f > /dev/null ; then
		printf "\nPlus sign in $f file.\n"
d239 4
a242 3
# Check for special users with .rhosts files.  Only root and toor should
# have a .rhosts files.  Also, .rhosts files should not plus signs.
awk -F: '$1 != "root" && $1 != "toor" && \
d246 6
a251 4
	if [ -f ${homedir}/.rhosts ] ; then
		rhost=`ls -ldgT ${homedir}/.rhosts`
		printf "$uid: $rhost\n"
	fi
d254 1
a254 1
	printf "\nChecking for special users with .rhosts files.\n"
d260 11
a270 4
	if [ -f ${homedir}/.rhosts ] && \
	    egrep '\+' ${homedir}/.rhosts > /dev/null ; then
		printf "$uid: + in .rhosts file.\n"
	fi
d273 1
a273 1
	printf "\nChecking .rhosts files syntax.\n"
d279 1
a279 1
awk -F: '{ print $1 " " $6 }' /etc/passwd | \
d298 1
a298 1
list=".netrc .rhosts"
a309 2
     $3 ~ /^-...r/ \
	{ print "user " $1 " " $2 " file is group readable" }
d351 3
a353 2
# File systems should not be globally exported.
awk '{
d365 2
a366 2
}' < /etc/exports > $OUTPUT
if [ -s $OUTPUT ] ; then
d369 1
d373 1
a373 1
printf "\nChecking setuid files and devices:\n"
d376 2
a377 2
    \( -perm -u+s -o -perm -g+s -o ! -type d -a ! -type f -a ! -type l -a \
       ! -type s \) | \
d382 2
a383 1
	printf "Setuid/device find errors:\n"
d393 2
a394 1
		printf "\nUudecode is setuid.\n"
d407 2
a408 1
				printf "Setuid additions:\n"
d415 2
a416 1
				printf "Setuid deletions:\n"
d424 2
a425 1
				printf "Setuid changes:\n"
d434 2
a435 1
		printf "Setuid additions:\n"
d445 1
a445 1
DISKLIST="dk fd hd hk hp jb kra ra rb rd rl rx rz sd up wd"
d515 2
a516 2
#	chown root.wheel DIR.SECURE
#	chmod 600 DIR.SECURE
d522 2
a523 1
if cd /etc/mtree; then
d532 1
d544 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

