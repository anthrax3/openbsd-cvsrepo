head	1.7;
access;
symbols
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.12
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.10
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.8
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.5.0.40
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.38
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.36
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.34
	OPENBSD_5_0:1.5.0.32
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.30
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.28
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.24
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.26
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.22
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.20
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.18
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2013.12.21.05.39.21;	author guenther;	state Exp;
branches;
next	1.6;

1.6
date	2013.10.29.02.56.15;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.27.19.38.19;	author marc;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.31.21.48.05;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.08.00.15.06;	author marc;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.20.16.43.15;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.15.14.37.12;	author fgsch;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.08.15.14.37.12;	author fgsch;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Use timespec and CLOCK_MONOTONIC for a timing test
@
text
@/*	$OpenBSD: pthread_cond_timedwait.c,v 1.6 2013/10/29 02:56:15 jsg Exp $	*/
/*
 * Copyright (c) 1993, 1994, 1995, 1996 by Chris Provenzano and contributors, 
 * proven@@mit.edu All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Chris Provenzano,
 *	the University of California, Berkeley, and contributors.
 * 4. Neither the name of Chris Provenzano, the University, nor the names of
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY CHRIS PROVENZANO AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL CHRIS PROVENZANO, THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ 

/* ==== test_pthread_cond.c =========================================
 * Copyright (c) 1993 by Chris Provenzano, proven@@athena.mit.edu
 *
 * Description : Test pthread_cond(). Run this after test_create()
 *
 *  1.23 94/05/04 proven
 *      -Started coding this file.
 */

#include <pthread.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include "test.h"

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond;

static void *
thread_1(void * new_buf)
{
	CHECKr(pthread_mutex_lock(&mutex));
	CHECKr(pthread_cond_signal(&cond));
	CHECKr(pthread_mutex_unlock(&mutex));
	pthread_exit(NULL);
}

static void *
thread_2(void * new_buf)
{
	sleep(1);
	CHECKr(pthread_mutex_lock(&mutex));
	CHECKr(pthread_cond_signal(&cond));
	CHECKr(pthread_mutex_unlock(&mutex));
	pthread_exit(NULL);
}

int
main(int argc, char *argv[])
{
	struct timespec abstime;
	struct timespec begtime;
	struct timespec endtime;
	pthread_t thread;
	pthread_condattr_t condattr;
	int ret;
	int ix;

	printf("pthread_cond_timedwait START\n");

	CHECKr(pthread_condattr_init(&condattr));
	CHECKr(pthread_condattr_setclock(&condattr, CLOCK_MONOTONIC));
	CHECKr(pthread_cond_init(&cond, &condattr));

	CHECKr(pthread_mutex_lock(&mutex));
	CHECKe(clock_gettime(CLOCK_MONOTONIC, &begtime));
	abstime = begtime;

	for (ix = 0; ix < 2; ix++) {
		abstime.tv_sec += 5; 

		/* Test a condition timeout */
		switch((ret = pthread_cond_timedwait(&cond, &mutex, &abstime))) {
		case 0:
			PANIC("pthread_cond_timedwait #0 failed to timeout");
			/* NOTREACHED */
		case ETIMEDOUT:
			/* expected behaviour */
			CHECKe(clock_gettime(CLOCK_MONOTONIC, &endtime));
			timespecsub(&endtime, &begtime, &endtime);
			printf("Got timeout %d in %lld.%09ld seconds\n", ix,
			       (long long)endtime.tv_sec, endtime.tv_nsec);
			break;
		default:
			DIE(ret, "pthread_cond_timedwait");
			/* NOTREACHED */
		}
	}

	/* Test a normal condition signal */
	CHECKr(pthread_create(&thread, NULL, thread_1, NULL));

	abstime.tv_sec += 5;
	CHECKr(pthread_cond_timedwait(&cond, &mutex, &abstime));

	/* Test a normal condition signal after a sleep */
	CHECKr(pthread_create(&thread, NULL, thread_2, NULL));

	pthread_yield();

	CHECKr(pthread_cond_timedwait(&cond, &mutex, &abstime));

	SUCCEED;
}
@


1.6
log
@use lld format string and a cast for time_t
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_cond_timedwait.c,v 1.5 2003/11/27 19:38:19 marc Exp $	*/
d52 1
a52 1
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
d77 2
a78 2
	struct timeval begtime;
	struct timeval endtime;
d80 1
d86 4
d91 2
a92 2
	CHECKe(gettimeofday(&begtime, NULL));
	TIMEVAL_TO_TIMESPEC(&begtime, &abstime);
d104 4
a107 4
			CHECKe(gettimeofday(&endtime, NULL));
			timersub(&endtime, &begtime, &endtime);
			printf("Got timeout %d in %lld.%06ld seconds\n", ix,
			       (long long)endtime.tv_sec, endtime.tv_usec);
@


1.5
log
@
Reduce iterations so test runs faster.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_cond_timedwait.c,v 1.4 2003/07/31 21:48:05 deraadt Exp $	*/
d101 2
a102 2
			printf("Got timeout %d in %ld.%06ld seconds\n", ix,
			       endtime.tv_sec, endtime.tv_usec);
@


1.4
log
@various cleanups; david says results are same
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_cond_timedwait.c,v 1.3 2003/07/08 00:15:06 marc Exp $	*/
d89 1
a89 1
	for (ix = 0; ix < 5; ix++) {
@


1.3
log
@
Give some feedback during the pthread_cond_timedwait test
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_cond_timedwait.c,v 1.2 2001/09/20 16:43:15 todd Exp $	*/
d54 2
a55 1
void* thread_1(void * new_buf)
d63 2
a64 1
void* thread_2(void * new_buf)
d74 1
a74 1
main()
@


1.2
log
@per man page and gcc 3.0.1, exit requires prototype from stdlib.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_cond_timedwait.c,v 1.1.1.1 2001/08/15 14:37:12 fgsch Exp $	*/
d74 3
a76 2
	struct timespec abstime = { 0, 0 };
	struct timeval curtime;
d79 1
d84 2
a85 2
	CHECKe(gettimeofday(&curtime, NULL));
	abstime.tv_sec = curtime.tv_sec + 5; 
d87 19
a105 12
	/* Test a condition timeout */
	switch((ret = pthread_cond_timedwait(&cond, &mutex, &abstime))) {
	case 0:
		PANIC("pthread_cond_timedwait #0 failed to timeout");
		/* NOTREACHED */
	case ETIMEDOUT:
		/* expected behaviour */
		printf("Got first timeout ok\n");	/* Added by monty */
		break;
	default:
		DIE(ret, "pthread_cond_timedwait");
		/* NOTREACHED */
d111 1
a111 1
	abstime.tv_sec = curtime.tv_sec + 10; 
a118 1
	abstime.tv_sec = curtime.tv_sec + 10; 
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: test_pthread_cond_timedwait.c,v 1.3 2000/01/06 06:58:34 d Exp $	*/
d48 1
@


1.1.1.1
log
@Regression tests for libc_r (pthreads) library.
Thanks to pval@@ for resolving the license stuff.
@
text
@@
