head	1.5;
access;
symbols
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.22
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.18
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.8
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.16
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.14
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.12
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.10
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.14
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.12
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.10
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.6
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.8
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.2.0.20
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.18
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.16
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.14
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.12
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.10
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.8
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.6
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2012.02.20.01.49.09;	author guenther;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.01.11.00.38;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2008.04.24.03.31.33;	author kurt;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.14.22.01.42;	author marc;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.10.21.02.12;	author marc;	state Exp;
branches;
next	;


desc
@@


1.5
log
@pthread_sigmask() was fixed to return the errno value on failure
@
text
@/* $OpenBSD: sigmask.c,v 1.4 2011/10/01 11:00:38 fgsch Exp $ */
/* PUBLIC DOMAIN July 2003 Marco S Hyman <marc@@snafu.org> */

#include <sys/time.h>

#include <pthread.h>
#include <signal.h>
#include <unistd.h>

#include "test.h"

/*
 * Test that masked signals with a default action of terminate process
 * do NOT terminate the process.
 */
int main (int argc, char *argv[])
{
	sigset_t mask;
	int sig;
	int r;

	/* any two (or more) command line args should cause the program
	   to die */
	if (argc > 2) {
		printf("trigger sigalrm[1] [test should die]\n");
		ualarm(100000, 0);
		CHECKe(sleep(1));
	}

	/* mask sigalrm */
	CHECKe(sigemptyset(&mask));
	CHECKe(sigaddset(&mask, SIGALRM));
	CHECKr(pthread_sigmask(SIG_BLOCK, &mask, NULL));

	/* make sure pthread_sigmask() returns the right value on failure */
	r = pthread_sigmask(-1, &mask, NULL);
	ASSERTe(r, == EINVAL);

	/* now trigger sigalrm and wait for it */
	printf("trigger sigalrm[2] [masked, test should not die]\n");
	ualarm(100000, 0);
	CHECKe(sleep(1));

	/* sigwait for sigalrm, it should be pending.   If it is not
	   the test will hang. */
	CHECKr(sigwait(&mask, &sig));
	ASSERT(sig == SIGALRM);

	/* make sure sigwait didn't muck with the mask by triggering
	   sigalrm, again */
	printf("trigger sigalrm[3] after sigwait [masked, test should not die]\n");
	ualarm(100000, 0);
	CHECKe(sleep(1));

	/* any single command line arg will run this code wich unmasks the
	   signal and then makes sure the program terminates when sigalrm
	   is triggered. */
	if (argc > 1) {
		printf("trigger sigalrm[4] [unmasked, test should die]\n");
		CHECKr(pthread_sigmask(SIG_UNBLOCK, &mask, NULL));
		ualarm(100000, 0);
		CHECKe(sleep(1));
	}
	
	SUCCEED;
}
@


1.4
log
@fix some checks.
@
text
@d1 1
a1 1
/* $OpenBSD: sigmask.c,v 1.3 2008/04/24 03:31:33 kurt Exp $ */
d20 1
d36 2
a37 1
	CHECKr(pthread_sigmask(-1, &mask, NULL));
@


1.3
log
@Return the proper values upon failure per POSIX for pthread_sigmask(3) and
sigprocmask(2) in threaded programs.

From Philip Guenther <guenther at sendmail.com> via PR library/5795.
okay marc@@
@
text
@d1 1
a1 1
/* $OpenBSD: sigmask.c,v 1.2 2003/07/14 22:01:42 marc Exp $ */
d35 1
a35 1
	CHECKe(pthread_sigmask(-1, &mask, NULL));
@


1.2
log
@improve test.  fails with current code
@
text
@d1 1
a1 1
/* $OpenBSD: sigmask.c,v 1.1 2003/07/10 21:02:12 marc Exp $ */
d32 4
a35 1
	CHECKe(pthread_sigmask(SIG_BLOCK, &mask, NULL));
d44 1
a44 1
	CHECKe(sigwait(&mask, &sig));
d58 1
a58 1
		CHECKe(pthread_sigmask(SIG_UNBLOCK, &mask, NULL));
@


1.1
log
@
Add test to ensure that a masked signal with a default action of
terminate process doesn't terminate the process.   It will until
a libpthread fix is verify and commited.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d19 9
d34 2
a35 1
	/* now trigger sigalrm */
d37 1
d39 9
a47 1
	/* wait for it -- we shouldn't see it. */
d50 10
@

