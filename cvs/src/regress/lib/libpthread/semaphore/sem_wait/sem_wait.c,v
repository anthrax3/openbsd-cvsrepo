head	1.3;
access;
symbols
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.22
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.18
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.8
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.16
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.14
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.12
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.10
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	mpi_20120104:1.1.1.1
	mpi:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2012.03.03.09.51.00;	author guenther;	state Exp;
branches;
next	1.2;

1.2
date	2012.03.03.09.36.26;	author guenther;	state Exp;
branches;
next	1.1;

1.1
date	2012.01.04.17.36.40;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.01.04.17.36.40;	author mpi;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Verify that sem_wait() doesn't return zero without decrementing the
semaphore when a signal is received.  It should either resume waiting
or return EINTR, preferrably the former.
@
text
@/*	$OpenBSD: sem_wait.c,v 1.2 2012/03/03 09:36:26 guenther Exp $	*/
/*
 * Martin Pieuchot <mpi@@openbsd.org>, 2011. Public Domain.
 */

#include <err.h>
#include <errno.h>
#include <unistd.h>
#include <semaphore.h>
#include <signal.h>
#include <pthread.h>
#include "test.h"


void *waiter(void *arg);

void
handler(int sig)
{
	static char message[] = "got sig\n";

	write(STDERR_FILENO, message, sizeof(message) - 1);
}

sem_t sem;
volatile int posted = 0, eintr_ok = 0;

int
main(int argc, char **argv)
{
	pthread_t th;
	struct sigaction sa;

	CHECKn(sem_wait(&sem));
	ASSERT(errno == EINVAL);

	CHECKr(sem_init(&sem, 0, 0));

	CHECKr(pthread_create(&th, NULL, waiter, &sem));

	sleep(1);

	printf("expect: sem_destroy on semaphore with waiters!\n");
	CHECKn(sem_destroy(&sem));
	ASSERT(errno == EBUSY);

	posted = 1;
	CHECKr(sem_post(&sem));
	CHECKr(pthread_join(th, NULL));

	/* test that sem_wait() resumes after handling a signal */
	memset(&sa, 0, sizeof sa);
	sa.sa_handler = &handler;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if (sigaction(SIGUSR1, &sa, NULL))
		err(1, "sigaction");
	posted = 0;
	CHECKr(pthread_create(&th, NULL, waiter, &sem));
	sleep(1);
	fprintf(stderr, "sending sig\n");
	eintr_ok = 1;
	pthread_kill(th, SIGUSR1);
	sleep(1);
	fprintf(stderr, "posting\n");
	posted = 1;
	eintr_ok = 0;
	CHECKr(sem_post(&sem));
	CHECKr(pthread_join(th, NULL));

	CHECKe(sem_destroy(&sem));

	SUCCEED;
}

void *
waiter(void *arg)
{
	sem_t *semp = arg;
	int value;
	int r;

	r = sem_wait(semp);
	CHECKr(sem_getvalue(semp, &value));
	if (r == 0) {
		ASSERT(value == 0);
		ASSERT(posted != 0);
	} else {
		ASSERT(r == -1);
		ASSERT(errno == EINTR);
		ASSERT(eintr_ok);
		if (posted)
			ASSERT(value == 1);
		else
			ASSERT(value == 0);
	}

	return (NULL);
}
@


1.2
log
@While we guarantee that a zero-filled sem_t variable will trigger
EINVAL errors, a sem_t on the stack may have garbage, so make the
tests portable by moving the sem_t from function to file scope.

problem found by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sem_wait.c,v 1.1.1.1 2012/01/04 17:36:40 mpi Exp $	*/
d6 1
d10 1
d17 8
d26 1
d32 1
d43 1
d47 21
d80 2
d83 14
a96 1
	CHECKr(sem_wait(semp));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d15 2
a20 1
	sem_t sem;
@


1.1.1.1
log
@Basic semaphore tests

ok guenther@@
@
text
@@
