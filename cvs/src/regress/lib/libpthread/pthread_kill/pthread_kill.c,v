head	1.5;
access;
symbols
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.6
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.2
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.4.0.44
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.52
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.50
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.48
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.46
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.42
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.40
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.38
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.36
	OPENBSD_5_0:1.4.0.34
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.32
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.30
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.26
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.28
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.24
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2016.05.10.04.04.34;	author guenther;	state Exp;
branches;
next	1.4;
commitid	BFymL9WYQLOtk47I;

1.4
date	2003.07.31.21.48.05;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.19.00.59.54;	author pvalchev;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.23.22.30.04;	author marc;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.21.18.44.11;	author marc;	state Exp;
branches;
next	;


desc
@@


1.5
log
@In a signal handler use snprintf()+local buffer instead of asprintf+free
@
text
@/* $OpenBSD: pthread_kill.c,v 1.4 2003/07/31 21:48:05 deraadt Exp $ */
/* PUBLIC DOMAIN Oct 2002 <marc@@snafu.org> */

/*
 * Verify that pthread_kill does the right thing, i.e. the signal
 * is delivered to the correct thread and proper signal processing
 * is performed.
 */

#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

#include "test.h"

static void
act_handler(int signal, siginfo_t *siginfo, void *context)
{
	struct sigaction sa;
	char buf[200];

	CHECKe(sigaction(SIGUSR1, NULL, &sa));
	ASSERT(sa.sa_handler == SIG_DFL);
	ASSERT(siginfo != NULL);
	snprintf(buf, sizeof buf,
	    "act_handler: signal %d, siginfo %p, context %p\n",
	    signal, siginfo, context);
	write(STDOUT_FILENO, buf, strlen(buf));
}
 
static void *
thread(void * arg)
{
	sigset_t run_mask;
	sigset_t suspender_mask;

	/* wait for sigusr1 */
	SET_NAME(arg);

	/* Run with all signals blocked, then suspend for SIGUSR1 */
	sigfillset(&run_mask);
	CHECKe(sigprocmask(SIG_SETMASK, &run_mask, NULL));
	sigfillset(&suspender_mask);
	sigdelset(&suspender_mask, SIGUSR1);
	for (;;) {
		sigsuspend(&suspender_mask);
		ASSERT(errno == EINTR);
		printf("Thread %s woke up\n", (char*) arg);
	}
		
}

int
main(int argc, char **argv)
{
	pthread_t thread1;
	pthread_t thread2;
	struct sigaction act;

	act.sa_sigaction = act_handler;
	sigemptyset(&act.sa_mask);
	act.sa_flags = SA_SIGINFO | SA_RESETHAND | SA_NODEFER;
	CHECKe(sigaction(SIGUSR1, &act, NULL));
	CHECKr(pthread_create(&thread1, NULL, thread, "T1"));
	CHECKr(pthread_create(&thread2, NULL, thread, "T2"));
	sleep(1);

	/* Signal handler should run once, both threads should awaken */
	CHECKe(kill(getpid(), SIGUSR1));
	sleep(1);

	/* Signal handler run once, only T1 should awaken */
	CHECKe(sigaction(SIGUSR1, &act, NULL));
	CHECKr(pthread_kill(thread1, SIGUSR1));
	sleep(1);

	/* Signal handler run once, only T2 should awaken */
	CHECKe(sigaction(SIGUSR1, &act, NULL));
	CHECKr(pthread_kill(thread2, SIGUSR1));
	sleep(1);

	SUCCEED;
}
@


1.4
log
@various cleanups; david says results are same
@
text
@d1 1
a1 1
/* $OpenBSD: pthread_kill.c,v 1.3 2003/06/19 00:59:54 pvalchev Exp $ */
d21 1
a21 1
	char *str;
d26 4
a29 4
	asprintf(&str, "act_handler: signal %d, siginfo %p, context %p\n",
		 signal, siginfo, context);
	write(STDOUT_FILENO, str, strlen(str));
	free(str);
@


1.3
log
@free memory allocated by asprintf; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: pthread_kill.c,v 1.2 2002/10/23 22:30:04 marc Exp $ */
d13 1
d17 1
a17 1
void
d32 1
a32 1
void *
@


1.2
log
@remove 0x in front of %p -- not needed
@
text
@d1 1
a1 1
/* $OpenBSD: pthread_kill.c,v 1.1 2002/10/21 18:44:11 marc Exp $ */
d28 1
@


1.1
log
@
Add test for pthread_kill.   The test currently fails as thread
specific delivery semantics are incorrect.   Fix in progress.
@
text
@d1 1
a1 1
/* $OpenBSD: siginfo.c,v 1.5 2002/10/12 03:37:45 marc Exp $ */
d25 1
a25 1
	asprintf(&str, "act_handler: signal %d, siginfo 0x%p, context 0x%p\n",
@

