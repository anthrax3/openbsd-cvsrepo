head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.3.0.2
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.2.0.42
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.50
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.48
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.46
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.44
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.40
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.38
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.36
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.34
	OPENBSD_5_0:1.2.0.32
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.30
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.28
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.24
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.26
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.22
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.20
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.18
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.16
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.14
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.12
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.10
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.8
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.6
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.1.0.4
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.2
	OPENBSD_3_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2016.09.01.10.56.45;	author deraadt;	state Exp;
branches;
next	1.3;
commitid	HzJta88xKCDy1q89;

1.3
date	2016.03.20.00.01.22;	author krw;	state Exp;
branches;
next	1.2;
commitid	vrVXbedfAlzCTHmf;

1.2
date	2003.11.27.22.51.36;	author marc;	state Exp;
branches;
next	1.1;

1.1
date	2003.02.04.21.21.00;	author marc;	state Exp;
branches;
next	;


desc
@@


1.4
log
@delete wrong cvs $ tags
@
text
@/* $OpenBSD: stdfiles.c,v 1.3 2016/03/20 00:01:22 krw Exp $ */
/* PUBLIC DOMAIN Oct 2002 Marco S Hyman <marc@@snafu.org> */

#include <assert.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>

/*
 * test what happens to blocking/non-blocking mode on stdout/stderr when
 * it is changed on stdin.   A comment in the pthreads code implies that
 * all three files are linked.   Check it out.
 */

int
main(int argc, char *argv[])
{
	int dup_stdout;
	int stdin_flags;
	int stdout_flags;
	int dup_flags;
	int stderr_flags;
	int new_flags;
	int new_fd;

	/* dup stdout for the fun of it. */
	dup_stdout = dup(STDOUT_FILENO);

	/* read std in/out/err flags */
	stdin_flags = fcntl(STDIN_FILENO, F_GETFL);
	assert(stdin_flags != -1);
	stdout_flags = fcntl(STDOUT_FILENO, F_GETFL);
	assert(stdout_flags != -1);
	dup_flags = fcntl(dup_stdout, F_GETFL);
	assert(dup_flags != -1);
	stderr_flags = fcntl(STDERR_FILENO, F_GETFL);
	assert(stderr_flags != -1);
	printf("starting flags: in = %x, out = %x, dup = %x, err = %x\n",
	       stdin_flags, stdout_flags, dup_flags, stderr_flags);

	/* set stdin to non-blocking mode and see if stdout/stderr change */
	new_flags = stdin_flags | O_NONBLOCK;
	printf("forcing stdin to O_NONBLOCK (flags %x)\n", new_flags);
	assert(fcntl(STDIN_FILENO, F_SETFL, new_flags) != -1);

	new_flags = fcntl(STDIN_FILENO, F_GETFL);
	assert(new_flags != -1);
	if (new_flags != stdin_flags) {
		printf("stdin flags changed %x -> %x\n", stdin_flags,
		       new_flags);
		stdin_flags = new_flags;
	}

	new_flags = fcntl(STDOUT_FILENO, F_GETFL);
	assert(new_flags != -1);
	if (new_flags != stdout_flags) {
		printf("stdout flags changed %x -> %x\n", stdout_flags,
		       new_flags);
		stdout_flags = new_flags;
	}

	new_flags = fcntl(dup_stdout, F_GETFL);
	assert(new_flags != -1);
	if (new_flags != dup_flags) {
		printf("dup_stdout flags changed %x -> %x\n", dup_flags,
		       new_flags);
		dup_flags = new_flags;
	}

	new_flags = fcntl(STDERR_FILENO, F_GETFL);
	assert(new_flags != -1);
	if (new_flags != stderr_flags) {
		printf("stderr flags changed %x -> %x\n", stderr_flags,
		       new_flags);
		stderr_flags = new_flags;
	}

	/*
	 * Close stderr and open /dev/tty.   See what it's flags
	 * are.   Set the file to non blocking.
	 */
	printf("close stderr and open /dev/tty\n");
	assert(close(STDERR_FILENO) != -1);
	new_fd = open("/dev/tty", O_RDWR|O_CREAT, 0666);
	assert(new_fd == STDERR_FILENO);
	new_flags = fcntl(STDERR_FILENO, F_GETFL);
	assert(new_flags != -1);
	printf("/dev/tty [STDERR_FILENO] flags are %x\n", new_flags);
	stderr_flags = new_flags | O_NONBLOCK;
	printf("forcing /dev/tty to O_NONBLOCK (flags %x)\n", stderr_flags);
	assert(fcntl(STDERR_FILENO, F_SETFL, stdin_flags) != -1);

	/* now turn off non blocking mode on stdin */
	stdin_flags &= ~O_NONBLOCK;
	printf("turning off O_NONBLOCK on stdin (flags %x)\n", stdin_flags);
	assert(fcntl(STDIN_FILENO, F_SETFL, stdin_flags) != -1);

	new_flags = fcntl(STDIN_FILENO, F_GETFL);
	assert(new_flags != -1);
	assert(new_flags == stdin_flags);

	new_flags = fcntl(STDOUT_FILENO, F_GETFL);
	assert(new_flags != -1);
	if (new_flags != stdout_flags) {
		printf("stdout flags changed %x -> %x\n", stdout_flags,
		       new_flags);
		stdout_flags = new_flags;
	}

	new_flags = fcntl(dup_stdout, F_GETFL);
	assert(new_flags != -1);
	if (new_flags != dup_flags) {
		printf("dup_stdout flags changed %x -> %x\n", dup_flags,
		       new_flags);
		dup_flags = new_flags;
	}

	new_flags = fcntl(STDERR_FILENO, F_GETFL);
	assert(new_flags != -1);
	if (new_flags != stderr_flags) {
		printf("stderr flags changed %x -> %x\n", stderr_flags,
		       new_flags);
		stderr_flags = new_flags;
	}

	return 0;
}
@


1.3
log
@Currently we have about a 50/50 split over fcntl(n, F_GETFL [,0])
idioms.

Adopt the more concise fcntl(n, F_GETFL) over fcntl(n, F_GETFL, 0)
where it is obvious further investigation will not yield and
even better way.

Obviousness evaluation and ok guenther@@
@
text
@d1 1
a1 2
/* $OpenBSD: stdfiles.c,v 1.2 2003/11/27 22:51:36 marc Exp $ */
/* $snafu: stdfiles.c,v 1.3 2003/02/03 21:22:26 marc Exp $ */
@


1.2
log
@openbsd tag
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d31 1
a31 1
	stdin_flags = fcntl(STDIN_FILENO, F_GETFL, 0);
d33 1
a33 1
	stdout_flags = fcntl(STDOUT_FILENO, F_GETFL, 0);
d35 1
a35 1
	dup_flags = fcntl(dup_stdout, F_GETFL, 0);
d37 1
a37 1
	stderr_flags = fcntl(STDERR_FILENO, F_GETFL, 0);
d47 1
a47 1
	new_flags = fcntl(STDIN_FILENO, F_GETFL, 0);
d55 1
a55 1
	new_flags = fcntl(STDOUT_FILENO, F_GETFL, 0);
d63 1
a63 1
	new_flags = fcntl(dup_stdout, F_GETFL, 0);
d71 1
a71 1
	new_flags = fcntl(STDERR_FILENO, F_GETFL, 0);
d87 1
a87 1
	new_flags = fcntl(STDERR_FILENO, F_GETFL, 0);
d99 1
a99 1
	new_flags = fcntl(STDIN_FILENO, F_GETFL, 0);
d103 1
a103 1
	new_flags = fcntl(STDOUT_FILENO, F_GETFL, 0);
d111 1
a111 1
	new_flags = fcntl(dup_stdout, F_GETFL, 0);
d119 1
a119 1
	new_flags = fcntl(STDERR_FILENO, F_GETFL, 0);
@


1.1
log
@
Add test to compare threaded vs non-threaded fd handling.
Test not enabled (yet).
@
text
@d1 1
d3 1
a3 1
/* PUBLIC DOMAIN Oct 2002 <marc@@snafu.org> */
@

