head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.50
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.48
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.44
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.34
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.42
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.40
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.38
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.36
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.32
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.30
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.28
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.26
	OPENBSD_5_0:1.3.0.24
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.22
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.20
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.16
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.18
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.14
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.12
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.10
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.8
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.6
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.4
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3;
locks; strict;
comment	@ * @;


1.3
date	2005.11.05.04.28.46;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.31.04.55.39;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.31.01.01.29;	author fgsch;	state Exp;
branches;
next	;


desc
@@


1.3
log
@zap unused var.
@
text
@/*	$OpenBSD: pthread_atfork.c,v 1.2 2005/10/31 04:55:39 fgsch Exp $	*/

/*
 * Federico Schwindt <fgsch@@openbsd.org>, 2005. Public Domain.
 */

#include <sys/types.h>
#include <pthread.h>
#include <unistd.h>

#include "test.h"

int cnt;

void
prepare1(void)
{
	ASSERT(cnt == 1);
	cnt--;
}

void
prepare2(void)
{
	ASSERT(cnt == 2);
	cnt--;
}

void
parent1(void)
{
	ASSERT(cnt == 0);
	cnt += 2;
}

void
parent2(void)
{
	ASSERT(cnt == 2);
	cnt -= 2;
}

void
child1(void)
{
	ASSERT(cnt == 0);
	cnt += 3;
}

void
child2(void)
{
	ASSERT(cnt == 3);
	cnt++;
}

void *
forker1(void *arg)
{
	CHECKr(pthread_atfork(prepare1, parent1, child1));

	cnt = 1;
	switch (fork()) {
	case -1:
		PANIC("fork");
		break;

	case 0:
		ASSERT(cnt == 3);
		_exit(0);

	default:
		ASSERT(cnt == 2);
		break;
	}

	cnt = 1;

	return (NULL);
}

void *
forker2(void *arg)
{
	CHECKr(pthread_atfork(prepare2, parent2, child2));

	cnt = 2;
	switch (fork()) {
	case -1:
		PANIC("fork");
		break;

	case 0:
		ASSERT(cnt == 4);
		_exit(0);

	default:
		ASSERT(cnt == 0);
		break;
	}

	cnt = 0;

	return (NULL);
}

int
main(int argc, char **argv)
{
	pthread_t tid;

	CHECKr(pthread_create(&tid, NULL, forker1, NULL));
	CHECKr(pthread_join(tid, NULL));
	ASSERT(cnt == 1);
	CHECKr(pthread_create(&tid, NULL, forker2, NULL));
	CHECKr(pthread_join(tid, NULL));
	ASSERT(cnt == 0);
	SUCCEED;
}
@


1.2
log
@and panic if fork(2) fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_atfork.c,v 1.1 2005/10/31 01:01:29 fgsch Exp $	*/
a12 1
pthread_mutex_t	atfork_mutex;
@


1.1
log
@pthread_atfork(3) regression.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 1
d91 1
@

