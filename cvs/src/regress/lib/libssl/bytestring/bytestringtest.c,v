head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.8
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.10
date	2015.10.25.20.15.06;	author doug;	state Exp;
branches;
next	1.9;
commitid	hqqfjowfG3QUrAoD;

1.9
date	2015.07.18.21.57.00;	author bcook;	state Exp;
branches;
next	1.8;
commitid	4k4HTtJVtyd1cM3M;

1.8
date	2015.06.23.05.58.28;	author doug;	state Exp;
branches;
next	1.7;
commitid	MSIxeB3IPB9767R5;

1.7
date	2015.06.23.01.20.24;	author doug;	state Exp;
branches;
next	1.6;
commitid	hAmGQnnsJ3FSb2QV;

1.6
date	2015.06.17.07.15.52;	author doug;	state Exp;
branches;
next	1.5;
commitid	0qA9ArAfPnaY5a9O;

1.5
date	2015.06.16.06.37.58;	author doug;	state Exp;
branches;
next	1.4;
commitid	WgdxVRW6Pa7qLDpc;

1.4
date	2015.04.25.15.28.47;	author doug;	state Exp;
branches;
next	1.3;
commitid	7doRAKue8v1m0MMw;

1.3
date	2015.02.16.06.48.17;	author doug;	state Exp;
branches;
next	1.2;
commitid	rg0yJhMb1e1TRPqr;

1.2
date	2015.02.06.22.22.33;	author doug;	state Exp;
branches;
next	1.1;
commitid	I6v8UUW6Pnk2wCv3;

1.1
date	2015.02.06.09.36.16;	author doug;	state Exp;
branches;
next	;
commitid	t6BPqtyhmeNgetxc;


desc
@@


1.10
log
@Change test to use length 128 (shortest long-form encoding).

From BoringSSL commit: d13a5e15d4e4eb51513be665306a2beba39869df
@
text
@/*	$OpenBSD: bytestringtest.c,v 1.9 2015/07/18 21:57:00 bcook Exp $	*/
/*
 * Copyright (c) 2014, Google Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/crypto.h>

#include "bytestring.h"

/* This is from <openssl/base.h> in boringssl */
#define OPENSSL_U64(x) x##ULL

#define PRINT_ERROR printf("Error in %s [%s:%d]\n", __func__, __FILE__, \
		__LINE__)

#define CHECK(a) do {							\
	if (!(a)) {							\
		PRINT_ERROR;						\
		return 0;						\
	}								\
} while (0)

#define CHECK_GOTO(a) do {						\
	if (!(a)) {							\
		PRINT_ERROR;						\
		goto err;						\
	}								\
} while (0)

static int
test_skip(void)
{
	static const uint8_t kData[] = {1, 2, 3};
	CBS data;

	CBS_init(&data, kData, sizeof(kData));

	CHECK(CBS_len(&data) == 3);
	CHECK(CBS_skip(&data, 1));
	CHECK(CBS_len(&data) == 2);
	CHECK(CBS_skip(&data, 2));
	CHECK(CBS_len(&data) == 0);
	CHECK(!CBS_skip(&data, 1));

	return 1;
}

static int
test_get_u(void)
{
	static const uint8_t kData[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	uint8_t u8;
	uint16_t u16;
	uint32_t u32;
	CBS data;

	CBS_init(&data, kData, sizeof(kData));

	CHECK(CBS_get_u8(&data, &u8));
	CHECK(u8 == 1);
	CHECK(CBS_get_u16(&data, &u16));
	CHECK(u16 == 0x203);
	CHECK(CBS_get_u24(&data, &u32));
	CHECK(u32 == 0x40506);
	CHECK(CBS_get_u32(&data, &u32));
	CHECK(u32 == 0x708090a);
	CHECK(!CBS_get_u8(&data, &u8));

	return 1;
}

static int
test_get_prefixed(void)
{
	static const uint8_t kData[] = {1, 2, 0, 2, 3, 4, 0, 0, 3, 3, 2, 1};
	uint8_t u8;
	uint16_t u16;
	uint32_t u32;
	CBS data, prefixed;

	CBS_init(&data, kData, sizeof(kData));

	CHECK(CBS_get_u8_length_prefixed(&data, &prefixed));
	CHECK(CBS_len(&prefixed) == 1);
	CHECK(CBS_get_u8(&prefixed, &u8));
	CHECK(u8 == 2);
	CHECK(CBS_get_u16_length_prefixed(&data, &prefixed));
	CHECK(CBS_len(&prefixed) == 2);
	CHECK(CBS_get_u16(&prefixed, &u16));
	CHECK(u16 == 0x304);
	CHECK(CBS_get_u24_length_prefixed(&data, &prefixed));
	CHECK(CBS_len(&prefixed) == 3);
	CHECK(CBS_get_u24(&prefixed, &u32));
	CHECK(u32 == 0x30201);

	return 1;
}

static int
test_get_prefixed_bad(void)
{
	static const uint8_t kData1[] = {2, 1};
	static const uint8_t kData2[] = {0, 2, 1};
	static const uint8_t kData3[] = {0, 0, 2, 1};
	CBS data, prefixed;

	CBS_init(&data, kData1, sizeof(kData1));
	CHECK(!CBS_get_u8_length_prefixed(&data, &prefixed));

	CBS_init(&data, kData2, sizeof(kData2));
	CHECK(!CBS_get_u16_length_prefixed(&data, &prefixed));

	CBS_init(&data, kData3, sizeof(kData3));
	CHECK(!CBS_get_u24_length_prefixed(&data, &prefixed));

	return 1;
}

static int
test_get_asn1(void)
{
	static const uint8_t kData1[] = {0x30, 2, 1, 2};
	static const uint8_t kData2[] = {0x30, 3, 1, 2};
	static const uint8_t kData3[] = {0x30, 0x80};
	static const uint8_t kData4[] = {0x30, 0x81, 1, 1};
	static const uint8_t kData5[4 + 0x80] = {0x30, 0x82, 0, 0x80};
	static const uint8_t kData6[] = {0xa1, 3, 0x4, 1, 1};
	static const uint8_t kData7[] = {0xa1, 3, 0x4, 2, 1};
	static const uint8_t kData8[] = {0xa1, 3, 0x2, 1, 1};
	static const uint8_t kData9[] = {0xa1, 3, 0x2, 1, 0xff};

	CBS data, contents;
	int present;
	uint64_t value;

	CBS_init(&data, kData1, sizeof(kData1));

	CHECK(!CBS_peek_asn1_tag(&data, 0x1));
	CHECK(CBS_peek_asn1_tag(&data, 0x30));

	CHECK(CBS_get_asn1(&data, &contents, 0x30));
	CHECK(CBS_len(&contents) == 2);
	CHECK(memcmp(CBS_data(&contents), "\x01\x02", 2) == 0);

	CBS_init(&data, kData2, sizeof(kData2));
	/* data is truncated */
	CHECK(!CBS_get_asn1(&data, &contents, 0x30));

	CBS_init(&data, kData3, sizeof(kData3));
	/* zero byte length of length */
	CHECK(!CBS_get_asn1(&data, &contents, 0x30));

	CBS_init(&data, kData4, sizeof(kData4));
	/* long form mistakenly used. */
	CHECK(!CBS_get_asn1(&data, &contents, 0x30));

	CBS_init(&data, kData5, sizeof(kData5));
	/* length takes too many bytes. */
	CHECK(!CBS_get_asn1(&data, &contents, 0x30));

	CBS_init(&data, kData1, sizeof(kData1));
	/* wrong tag. */
	CHECK(!CBS_get_asn1(&data, &contents, 0x31));

	CBS_init(&data, NULL, 0);
	/* peek at empty data. */
	CHECK(!CBS_peek_asn1_tag(&data, 0x30));

	CBS_init(&data, NULL, 0);
	/* optional elements at empty data. */
	CHECK(CBS_get_optional_asn1(&data, &contents, &present, 0xa0));
	CHECK(!present);
	CHECK(CBS_get_optional_asn1_octet_string(&data, &contents, &present,
	    0xa0));
	CHECK(!present);
	CHECK(CBS_len(&contents) == 0);
	CHECK(CBS_get_optional_asn1_octet_string(&data, &contents, NULL, 0xa0));
	CHECK(CBS_len(&contents) == 0);
	CHECK(CBS_get_optional_asn1_uint64(&data, &value, 0xa0, 42));
	CHECK(value == 42);

	CBS_init(&data, kData6, sizeof(kData6));
	/* optional element. */
	CHECK(CBS_get_optional_asn1(&data, &contents, &present, 0xa0));
	CHECK(!present);
	CHECK(CBS_get_optional_asn1(&data, &contents, &present, 0xa1));
	CHECK(present);
	CHECK(CBS_len(&contents) == 3);
	CHECK(memcmp(CBS_data(&contents), "\x04\x01\x01", 3) == 0);

	CBS_init(&data, kData6, sizeof(kData6));
	/* optional octet string. */
	CHECK(CBS_get_optional_asn1_octet_string(&data, &contents, &present,
	    0xa0));
	CHECK(!present);
	CHECK(CBS_len(&contents) == 0);
	CHECK(CBS_get_optional_asn1_octet_string(&data, &contents, &present,
	    0xa1));
	CHECK(present);
	CHECK(CBS_len(&contents) == 1);
	CHECK(CBS_data(&contents)[0] == 1);

	CBS_init(&data, kData7, sizeof(kData7));
	/* invalid optional octet string. */
	CHECK(!CBS_get_optional_asn1_octet_string(&data, &contents, &present,
	    0xa1));

	CBS_init(&data, kData8, sizeof(kData8));
	/* optional octet string. */
	CHECK(CBS_get_optional_asn1_uint64(&data, &value, 0xa0, 42));
	CHECK(value == 42);
	CHECK(CBS_get_optional_asn1_uint64(&data, &value, 0xa1, 42));
	CHECK(value == 1);

	CBS_init(&data, kData9, sizeof(kData9));
	/* invalid optional integer. */
	CHECK(!CBS_get_optional_asn1_uint64(&data, &value, 0xa1, 42));

	return 1;
}

static int
test_get_optional_asn1_bool(void)
{
	CBS data;
	int val;

	static const uint8_t kTrue[] = {0x0a, 3, CBS_ASN1_BOOLEAN, 1, 0xff};
	static const uint8_t kFalse[] = {0x0a, 3, CBS_ASN1_BOOLEAN, 1, 0x00};
	static const uint8_t kInvalid[] = {0x0a, 3, CBS_ASN1_BOOLEAN, 1, 0x01};

	CBS_init(&data, NULL, 0);
	val = 2;
	CHECK(CBS_get_optional_asn1_bool(&data, &val, 0x0a, 0));
	CHECK(val == 0);

	CBS_init(&data, kTrue, sizeof(kTrue));
	val = 2;
	CHECK(CBS_get_optional_asn1_bool(&data, &val, 0x0a, 0));
	CHECK(val == 1);

	CBS_init(&data, kFalse, sizeof(kFalse));
	val = 2;
	CHECK(CBS_get_optional_asn1_bool(&data, &val, 0x0a, 1));
	CHECK(val == 0);

	CBS_init(&data, kInvalid, sizeof(kInvalid));
	CHECK(!CBS_get_optional_asn1_bool(&data, &val, 0x0a, 1));

	return 1;
}

static int
test_cbb_basic(void)
{
	static const uint8_t kExpected[] = {1, 2, 3, 4, 5, 6, 7, 8};
	uint8_t *buf = NULL;
	size_t buf_len;
	int ret = 0;
	CBB cbb;

	CHECK(CBB_init(&cbb, 100));

	CBB_cleanup(&cbb);

	CHECK(CBB_init(&cbb, 0));
	CHECK_GOTO(CBB_add_u8(&cbb, 1));
	CHECK_GOTO(CBB_add_u16(&cbb, 0x203));
	CHECK_GOTO(CBB_add_u24(&cbb, 0x40506));
	CHECK_GOTO(CBB_add_bytes(&cbb, (const uint8_t*) "\x07\x08", 2));
	CHECK_GOTO(CBB_finish(&cbb, &buf, &buf_len));

	ret = (buf_len == sizeof(kExpected)
	    && memcmp(buf, kExpected, buf_len) == 0);

	if (0) {
err:
		CBB_cleanup(&cbb);
	}
	free(buf);
	return ret;
}

static int
test_cbb_fixed(void)
{
	CBB cbb;
	uint8_t buf[1];
	uint8_t *out_buf = NULL;
	size_t out_size;
	int ret = 0;

	CHECK(CBB_init_fixed(&cbb, NULL, 0));
	CHECK_GOTO(!CBB_add_u8(&cbb, 1));
	CHECK_GOTO(CBB_finish(&cbb, &out_buf, &out_size));
	CHECK(out_buf == NULL && out_size == 0);

	CHECK(CBB_init_fixed(&cbb, buf, 1));
	CHECK_GOTO(CBB_add_u8(&cbb, 1));
	CHECK_GOTO(!CBB_add_u8(&cbb, 2));
	CHECK_GOTO(CBB_finish(&cbb, &out_buf, &out_size));

	ret = (out_buf == buf && out_size == 1 && buf[0] == 1);

	if (0) {
err:
		CBB_cleanup(&cbb);
	}

	return ret;
}

static int
test_cbb_finish_child(void)
{
	CBB cbb, child;
	uint8_t *out_buf = NULL;
	size_t out_size;
	int ret = 0;

	CHECK(CBB_init(&cbb, 16));
	CHECK_GOTO(CBB_add_u8_length_prefixed(&cbb, &child));
	CHECK_GOTO(!CBB_finish(&child, &out_buf, &out_size));
	CHECK_GOTO(CBB_finish(&cbb, &out_buf, &out_size));

	ret = (out_size == 1 && out_buf[0] == 0);

err:
	free(out_buf);
	return ret;
}

static int
test_cbb_prefixed(void)
{
	static const uint8_t kExpected[] = {0, 1, 1, 0, 2, 2, 3, 0, 0, 3,
	    4, 5, 6, 5, 4, 1, 0, 1, 2};
	uint8_t *buf = NULL;
	size_t buf_len;
	CBB cbb, contents, inner_contents, inner_inner_contents;
	int ret = 0;

	CHECK(CBB_init(&cbb, 0));
	CHECK_GOTO(CBB_add_u8_length_prefixed(&cbb, &contents));
	CHECK_GOTO(CBB_add_u8_length_prefixed(&cbb, &contents));
	CHECK_GOTO(CBB_add_u8(&contents, 1));
	CHECK_GOTO(CBB_add_u16_length_prefixed(&cbb, &contents));
	CHECK_GOTO(CBB_add_u16(&contents, 0x203));
	CHECK_GOTO(CBB_add_u24_length_prefixed(&cbb, &contents));
	CHECK_GOTO(CBB_add_u24(&contents, 0x40506));
	CHECK_GOTO(CBB_add_u8_length_prefixed(&cbb, &contents));
	CHECK_GOTO(CBB_add_u8_length_prefixed(&contents, &inner_contents));
	CHECK_GOTO(CBB_add_u8(&inner_contents, 1));
	CHECK_GOTO(CBB_add_u16_length_prefixed(&inner_contents,
	    &inner_inner_contents));
	CHECK_GOTO(CBB_add_u8(&inner_inner_contents, 2));
	CHECK_GOTO(CBB_finish(&cbb, &buf, &buf_len));

	ret = (buf_len == sizeof(kExpected)
	    && memcmp(buf, kExpected, buf_len) == 0);

	if (0) {
err:
		CBB_cleanup(&cbb);
	}
	free(buf);
	return ret;
}

static int
test_cbb_misuse(void)
{
	CBB cbb, child, contents;
	uint8_t *buf = NULL;
	size_t buf_len;
	int ret = 0;

	CHECK(CBB_init(&cbb, 0));
	CHECK_GOTO(CBB_add_u8_length_prefixed(&cbb, &child));
	CHECK_GOTO(CBB_add_u8(&child, 1));
	CHECK_GOTO(CBB_add_u8(&cbb, 2));

	/*
	 * Since we wrote to |cbb|, |child| is now invalid and attempts to write
	 * to it should fail.
	 */
	CHECK_GOTO(!CBB_add_u8(&child, 1));
	CHECK_GOTO(!CBB_add_u16(&child, 1));
	CHECK_GOTO(!CBB_add_u24(&child, 1));
	CHECK_GOTO(!CBB_add_u8_length_prefixed(&child, &contents));
	CHECK_GOTO(!CBB_add_u16_length_prefixed(&child, &contents));
	CHECK_GOTO(!CBB_add_asn1(&child, &contents, 1));
	CHECK_GOTO(!CBB_add_bytes(&child, (const uint8_t*) "a", 1));
	CHECK_GOTO(CBB_finish(&cbb, &buf, &buf_len));

	ret = (buf_len == 3 && memcmp(buf, "\x01\x01\x02", 3) == 0);

	if (0) {
err:
		CBB_cleanup(&cbb);
	}
	free(buf);
	return ret;
}

static int
test_cbb_asn1(void)
{
	static const uint8_t kExpected[] = {0x30, 3, 1, 2, 3};
	uint8_t *buf = NULL, *test_data = NULL;
	size_t buf_len;
	CBB cbb, contents, inner_contents;
	int ret = 0;
	int alloc = 0;

	CHECK_GOTO(CBB_init(&cbb, 0));
	alloc = 1;
	CHECK_GOTO(CBB_add_asn1(&cbb, &contents, 0x30));
	CHECK_GOTO(CBB_add_bytes(&contents, (const uint8_t*) "\x01\x02\x03",
	    3));
	CHECK_GOTO(CBB_finish(&cbb, &buf, &buf_len));
	alloc = 0;

	CHECK_GOTO(buf_len == sizeof(kExpected));
	CHECK_GOTO(memcmp(buf, kExpected, buf_len) == 0);

	free(buf);
	buf = NULL;

	CHECK_GOTO(((test_data = malloc(100000)) != NULL));
	memset(test_data, 0x42, 100000);

	CHECK_GOTO(CBB_init(&cbb, 0));
	alloc = 1;
	CHECK_GOTO(CBB_add_asn1(&cbb, &contents, 0x30));
	CHECK_GOTO(CBB_add_bytes(&contents, test_data, 130));
	CHECK_GOTO(CBB_finish(&cbb, &buf, &buf_len));
	alloc = 0;

	CHECK_GOTO(buf_len == 3 + 130);
	CHECK_GOTO(memcmp(buf, "\x30\x81\x82", 3) == 0);
	CHECK_GOTO(memcmp(buf + 3, test_data, 130) == 0);

	free(buf);
	buf = NULL;

	CHECK_GOTO(CBB_init(&cbb, 0));
	alloc = 1;
	CHECK_GOTO(CBB_add_asn1(&cbb, &contents, 0x30));
	CHECK_GOTO(CBB_add_bytes(&contents, test_data, 1000));
	CHECK_GOTO(CBB_finish(&cbb, &buf, &buf_len));
	alloc = 0;

	CHECK_GOTO(buf_len == 4 + 1000);
	CHECK_GOTO(memcmp(buf, "\x30\x82\x03\xe8", 4) == 0);
	CHECK_GOTO(!memcmp(buf + 4, test_data, 1000));

	free(buf);
	buf = NULL;

	CHECK_GOTO(CBB_init(&cbb, 0));
	alloc = 1;
	CHECK_GOTO(CBB_add_asn1(&cbb, &contents, 0x30));
	CHECK_GOTO(CBB_add_asn1(&contents, &inner_contents, 0x30));
	CHECK_GOTO(CBB_add_bytes(&inner_contents, test_data, 100000));
	CHECK_GOTO(CBB_finish(&cbb, &buf, &buf_len));
	alloc = 0;

	CHECK_GOTO(buf_len == 5 + 5 + 100000);
	CHECK_GOTO(memcmp(buf, "\x30\x83\x01\x86\xa5\x30\x83\x01\x86\xa0", 10)
	    == 0);
	CHECK_GOTO(!memcmp(buf + 10, test_data, 100000));

	ret = 1;

	if (0) {
err:
		if (alloc)
			CBB_cleanup(&cbb);
	}
	free(buf);
	free(test_data);
	return ret;
}

static int
do_indefinite_convert(const char *name, const uint8_t *definite_expected,
    size_t definite_len, const uint8_t *indefinite, size_t indefinite_len)
{
	CBS in;
	uint8_t *out = NULL;
	size_t out_len;
	int ret = 0;

	CBS_init(&in, indefinite, indefinite_len);

	CHECK_GOTO(CBS_asn1_indefinite_to_definite(&in, &out, &out_len));

	if (out == NULL) {

		if (indefinite_len != definite_len ||
		    memcmp(definite_expected, indefinite, indefinite_len) != 0) {
			PRINT_ERROR;
			goto err;
		}

		return 1;
	}

	if (out_len != definite_len ||
	    memcmp(out, definite_expected, definite_len) != 0) {
		PRINT_ERROR;
		goto err;
	}

	ret = 1;
err:
	free(out);
	return ret;
}

static int
test_indefinite_convert(void)
{
	static const uint8_t kSimpleBER[] = {0x01, 0x01, 0x00};

	/* kIndefBER contains a SEQUENCE with an indefinite length. */
	static const uint8_t kIndefBER[] = {0x30, 0x80, 0x01, 0x01, 0x02, 0x00,
	    0x00};
	static const uint8_t kIndefDER[] = {0x30, 0x03, 0x01, 0x01, 0x02};

	/*
	 * kOctetStringBER contains an indefinite length OCTETSTRING with two
	 * parts.  These parts need to be concatenated in DER form.
	 */
	static const uint8_t kOctetStringBER[] = {0x24, 0x80, 0x04, 0x02, 0,
	    1, 0x04, 0x02, 2,    3,    0x00, 0x00};
	static const uint8_t kOctetStringDER[] = {0x04, 0x04, 0, 1, 2, 3};

	/*
	 * kNSSBER is part of a PKCS#12 message generated by NSS that uses
	 * indefinite length elements extensively.
	 */
	static const uint8_t kNSSBER[] = {
	    0x30, 0x80, 0x02, 0x01, 0x03, 0x30, 0x80, 0x06, 0x09, 0x2a, 0x86,
	    0x48, 0x86, 0xf7, 0x0d, 0x01, 0x07, 0x01, 0xa0, 0x80, 0x24, 0x80,
	    0x04, 0x04, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x30, 0x39, 0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e,
	    0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14, 0x84, 0x98, 0xfc, 0x66,
	    0x33, 0xee, 0xba, 0xe7, 0x90, 0xc1, 0xb6, 0xe8, 0x8f, 0xfe, 0x1d,
	    0xc5, 0xa5, 0x97, 0x93, 0x3e, 0x04, 0x10, 0x38, 0x62, 0xc6, 0x44,
	    0x12, 0xd5, 0x30, 0x00, 0xf8, 0xf2, 0x1b, 0xf0, 0x6e, 0x10, 0x9b,
	    0xb8, 0x02, 0x02, 0x07, 0xd0, 0x00, 0x00,
	};

	static const uint8_t kNSSDER[] = {
	    0x30, 0x53, 0x02, 0x01, 0x03, 0x30, 0x13, 0x06, 0x09, 0x2a, 0x86,
	    0x48, 0x86, 0xf7, 0x0d, 0x01, 0x07, 0x01, 0xa0, 0x06, 0x04, 0x04,
	    0x01, 0x02, 0x03, 0x04, 0x30, 0x39, 0x30, 0x21, 0x30, 0x09, 0x06,
	    0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14, 0x84,
	    0x98, 0xfc, 0x66, 0x33, 0xee, 0xba, 0xe7, 0x90, 0xc1, 0xb6, 0xe8,
	    0x8f, 0xfe, 0x1d, 0xc5, 0xa5, 0x97, 0x93, 0x3e, 0x04, 0x10, 0x38,
	    0x62, 0xc6, 0x44, 0x12, 0xd5, 0x30, 0x00, 0xf8, 0xf2, 0x1b, 0xf0,
	    0x6e, 0x10, 0x9b, 0xb8, 0x02, 0x02, 0x07, 0xd0,
	};

	CHECK(do_indefinite_convert("kSimpleBER", kSimpleBER, sizeof(kSimpleBER),
	    kSimpleBER, sizeof(kSimpleBER)));
	CHECK(do_indefinite_convert("kIndefBER", kIndefDER, sizeof(kIndefDER),
	    kIndefBER, sizeof(kIndefBER)));
	CHECK(do_indefinite_convert("kOctetStringBER", kOctetStringDER,
	    sizeof(kOctetStringDER), kOctetStringBER,
	    sizeof(kOctetStringBER)));
	CHECK(do_indefinite_convert("kNSSBER", kNSSDER, sizeof(kNSSDER), kNSSBER,
	    sizeof(kNSSBER)));

	return 1;
}

typedef struct {
	uint64_t value;
	const char *encoding;
	size_t encoding_len;
} ASN1_UINT64_TEST;

static const ASN1_UINT64_TEST kAsn1Uint64Tests[] = {
	{0, "\x02\x01\x00", 3},
	{1, "\x02\x01\x01", 3},
	{127, "\x02\x01\x7f", 3},
	{128, "\x02\x02\x00\x80", 4},
	{0xdeadbeef, "\x02\x05\x00\xde\xad\xbe\xef", 7},
	{OPENSSL_U64(0x0102030405060708),
	    "\x02\x08\x01\x02\x03\x04\x05\x06\x07\x08", 10},
	{OPENSSL_U64(0xffffffffffffffff),
	    "\x02\x09\x00\xff\xff\xff\xff\xff\xff\xff\xff", 11},
};

typedef struct {
	const char *encoding;
	size_t encoding_len;
} ASN1_INVALID_UINT64_TEST;

static const ASN1_INVALID_UINT64_TEST kAsn1InvalidUint64Tests[] = {
	/* Bad tag. */
	{"\x03\x01\x00", 3},
	/* Empty contents. */
	{"\x02\x00", 2},
	/* Negative number. */
	{"\x02\x01\x80", 3},
	/* Overflow. */
	{"\x02\x09\x01\x00\x00\x00\x00\x00\x00\x00\x00", 11},
	/* Leading zeros. */
	{"\x02\x02\x00\x01", 4},
};

static int
test_asn1_uint64(void)
{
	CBB cbb;
	uint8_t *out = NULL;
	size_t i;
	int ret = 0;
	int alloc = 0;

	for (i = 0; i < sizeof(kAsn1Uint64Tests) / sizeof(kAsn1Uint64Tests[0]);
	     i++) {
		const ASN1_UINT64_TEST *test = &kAsn1Uint64Tests[i];
		CBS cbs;
		uint64_t value;
		size_t len;

		CBS_init(&cbs, (const uint8_t *)test->encoding,
		    test->encoding_len);

		CHECK(CBS_get_asn1_uint64(&cbs, &value));
		CHECK(CBS_len(&cbs) == 0);
		CHECK(value == test->value);

		CHECK(CBB_init(&cbb, 0));
		alloc = 1;
		CHECK_GOTO(CBB_add_asn1_uint64(&cbb, test->value));
		CHECK_GOTO(CBB_finish(&cbb, &out, &len));
		alloc = 0;

		CHECK_GOTO(len == test->encoding_len);
		CHECK_GOTO(memcmp(out, test->encoding, len) == 0);
		free(out);
		out = NULL;
	}

	for (i = 0; i < sizeof(kAsn1InvalidUint64Tests)
	    / sizeof(kAsn1InvalidUint64Tests[0]); i++) {
		const ASN1_INVALID_UINT64_TEST *test =
		    &kAsn1InvalidUint64Tests[i];
		CBS cbs;
		uint64_t value;

		CBS_init(&cbs, (const uint8_t *)test->encoding,
		    test->encoding_len);
		CHECK(!CBS_get_asn1_uint64(&cbs, &value));
	}

	ret = 1;

	if (0) {
err:
		if (alloc)
			CBB_cleanup(&cbb);
	}
	free(out);

	return ret;
}

static int
test_offset(void)
{
	uint8_t v;
	static const uint8_t input[] = {1, 2, 3, 4, 5};
	CBS data;

	CBS_init(&data, input, sizeof(input));
	CHECK(sizeof(input) == 5);
	CHECK(CBS_len(&data) == 5);
	CHECK(CBS_offset(&data) == 0);
	CHECK(CBS_get_u8(&data, &v));
	CHECK(v == 1);
	CHECK(CBS_len(&data) == 4);
	CHECK(CBS_offset(&data) == 1);
	CHECK(CBS_skip(&data, 2));
	CHECK(CBS_len(&data) == 2);
	CHECK(CBS_offset(&data) == 3);
	CHECK(CBS_get_u8(&data, &v));
	CHECK(v == 4);
	CHECK(CBS_get_u8(&data, &v));
	CHECK(v == 5);
	CHECK(CBS_len(&data) == 0);
	CHECK(CBS_offset(&data) == 5);
	CHECK(!CBS_skip(&data, 1));

	CBS_init(&data, input, sizeof(input));
	CHECK(CBS_skip(&data, 2));
	CHECK(CBS_len(&data) == 3);
	CHECK(CBS_offset(&data) == 2);
	CHECK(CBS_skip(&data, 3));
	CHECK(CBS_len(&data) == 0);
	CHECK(CBS_offset(&data) == 5);
	CHECK(!CBS_get_u8(&data, &v));

	return 1;
}

static int
test_write_bytes(void)
{
	int ret = 0;
	uint8_t v;
	size_t len;
	static const uint8_t input[] = {'f', 'o', 'o', 'b', 'a', 'r'};
	CBS data;
	char *tmp = NULL;

	CHECK_GOTO((tmp = malloc(sizeof(input))) != NULL);
	memset(tmp, 100, sizeof(input));

	CBS_init(&data, input, sizeof(input));
	CHECK_GOTO(CBS_len(&data) == 6);
	CHECK_GOTO(CBS_offset(&data) == 0);
	CHECK_GOTO(CBS_get_u8(&data, &v));
	CHECK_GOTO(v == 102 /* f */);
	CHECK_GOTO(CBS_skip(&data, 1));
	CHECK_GOTO(!CBS_skip(&data, 15));
	CHECK_GOTO(CBS_write_bytes(&data, tmp, sizeof(input), &len));
	CHECK_GOTO(len == 4);
	CHECK_GOTO(memcmp(input + 2, tmp, len) == 0);
	CHECK_GOTO(tmp[4] == 100 && tmp[5] == 100);

	ret = 1;

err:
	free(tmp);
	return ret;
}

static int
test_cbs_dup(void)
{
	CBS data, check;
	static const uint8_t input[] = {'f', 'o', 'o', 'b', 'a', 'r'};

	CBS_init(&data, input, sizeof(input));
	CHECK(CBS_len(&data) == 6);
	CBS_dup(&data, &check);
	CHECK(CBS_len(&check) == 6);
	CHECK(CBS_data(&data) == CBS_data(&check));
	CHECK(CBS_skip(&data, 1));
	CHECK(CBS_len(&data) == 5);
	CHECK(CBS_len(&check) == 6);
	CHECK(CBS_data(&data) == CBS_data(&check) + 1);
	CHECK(CBS_skip(&check, 1));
	CHECK(CBS_len(&data) == 5);
	CHECK(CBS_len(&check) == 5);
	CHECK(CBS_data(&data) == CBS_data(&check));
	CHECK(CBS_offset(&data) == 1);
	CHECK(CBS_offset(&check) == 1);

	CBS_init(&data, input, sizeof(input));
	CHECK(CBS_skip(&data, 5));
	CBS_dup(&data, &check);
	CHECK(CBS_len(&data) == 1);
	CHECK(CBS_len(&check) == 1);
	CHECK(CBS_data(&data) == input + 5);
	CHECK(CBS_data(&data) == CBS_data(&check));
	CHECK(CBS_offset(&data) == 5);
	CHECK(CBS_offset(&check) == 5);

	return 1;
}

int
main(void)
{
	int failed = 0;

	failed |= !test_skip();
	failed |= !test_get_u();
	failed |= !test_get_prefixed();
	failed |= !test_get_prefixed_bad();
	failed |= !test_get_asn1();
	failed |= !test_cbb_basic();
	failed |= !test_cbb_fixed();
	failed |= !test_cbb_finish_child();
	failed |= !test_cbb_misuse();
	failed |= !test_cbb_prefixed();
	failed |= !test_cbb_asn1();
	failed |= !test_indefinite_convert();
	failed |= !test_asn1_uint64();
	failed |= !test_get_optional_asn1_bool();
	failed |= !test_offset();
	failed |= !test_write_bytes();
	failed |= !test_cbs_dup();

	if (!failed)
		printf("PASS\n");
	return failed;
}
@


1.9
log
@simplify length checking in do_indefinite_convert

Fixes Coverity 117506, 117507, 117508
ok doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bytestringtest.c,v 1.8 2015/06/23 05:58:28 doug Exp $	*/
d141 1
a141 1
	static const uint8_t kData5[] = {0x30, 0x82, 0, 1, 1};
@


1.8
log
@Change CBS_dup() to also sync the offset.

Previously, CBS_dup() had its own offset.  However, it is more consistent
to copy everything.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bytestringtest.c,v 1.7 2015/06/23 01:20:24 doug Exp $	*/
d28 3
d33 1
a33 2
		printf("Error in %s [%s:%d]\n", __func__, __FILE__,	\
		    __LINE__);						\
d40 1
a40 2
		printf("Error in %s [%s:%d]\n", __func__, __FILE__,	\
		    __LINE__);						\
d515 6
a520 3
		CHECK_GOTO(indefinite_len == definite_len);
		CHECK_GOTO(memcmp(definite_expected, indefinite, indefinite_len)
		    == 0);
d525 5
a529 2
	CHECK_GOTO(out_len == definite_len);
	CHECK_GOTO(memcmp(out, definite_expected, definite_len) == 0);
a531 1

@


1.7
log
@Convert bytestringtest to individual checks and don't short circuit.

The statements were chained together with OR which makes it more annoying
to debug.  Also, it was short circuiting all tests as soon as one function
failed.  Since the functions are independent, they should each run until
error.

Discussed with miod@@ and jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bytestringtest.c,v 1.6 2015/06/17 07:15:52 doug Exp $	*/
d754 35
d810 1
@


1.6
log
@Add tests for CBS_offset() and CBS_write_bytes().

"no problem" miod@@, tweak + ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bytestringtest.c,v 1.5 2015/06/16 06:37:58 doug Exp $	*/
d28 16
d51 9
a59 6
	return CBS_len(&data) == 3 &&
	    CBS_skip(&data, 1) &&
	    CBS_len(&data) == 2 &&
	    CBS_skip(&data, 2) &&
	    CBS_len(&data) == 0 &&
	    !CBS_skip(&data, 1);
d72 12
a83 9
	return CBS_get_u8(&data, &u8) &&
	    u8 == 1 &&
	    CBS_get_u16(&data, &u16) &&
	    u16 == 0x203 &&
	    CBS_get_u24(&data, &u32) &&
	    u32 == 0x40506 &&
	    CBS_get_u32(&data, &u32) &&
	    u32 == 0x708090a &&
	    !CBS_get_u8(&data, &u8);
d96 15
a110 12
	return CBS_get_u8_length_prefixed(&data, &prefixed) &&
	    CBS_len(&prefixed) == 1 &&
	    CBS_get_u8(&prefixed, &u8) &&
	    u8 == 2 &&
	    CBS_get_u16_length_prefixed(&data, &prefixed) &&
	    CBS_len(&prefixed) == 2 &&
	    CBS_get_u16(&prefixed, &u16) &&
	    u16 == 0x304 &&
	    CBS_get_u24_length_prefixed(&data, &prefixed) &&
	    CBS_len(&prefixed) == 3 &&
	    CBS_get_u24(&prefixed, &u32) &&
	    u32 == 0x30201;
d122 1
a122 2
	if (CBS_get_u8_length_prefixed(&data, &prefixed))
		return 0;
d125 1
a125 2
	if (CBS_get_u16_length_prefixed(&data, &prefixed))
		return 0;
d128 1
a128 2
	if (CBS_get_u24_length_prefixed(&data, &prefixed))
		return 0;
a150 2
	if (CBS_peek_asn1_tag(&data, 0x1) || !CBS_peek_asn1_tag(&data, 0x30))
		return 0;
d152 6
a157 4
	if (!CBS_get_asn1(&data, &contents, 0x30) ||
	    CBS_len(&contents) != 2 ||
	    memcmp(CBS_data(&contents), "\x01\x02", 2) != 0)
		return 0;
d161 1
a161 2
	if (CBS_get_asn1(&data, &contents, 0x30))
		return 0;
d165 1
a165 2
	if (CBS_get_asn1(&data, &contents, 0x30))
		return 0;
d169 1
a169 2
	if (CBS_get_asn1(&data, &contents, 0x30))
		return 0;
d173 1
a173 2
	if (CBS_get_asn1(&data, &contents, 0x30))
		return 0;
d177 1
a177 2
	if (CBS_get_asn1(&data, &contents, 0x31))
		return 0;
d181 1
a181 2
	if (CBS_peek_asn1_tag(&data, 0x30))
		return 0;
d185 10
a194 11
	if (!CBS_get_optional_asn1(&data, &contents, &present, 0xa0) ||
	    present ||
	    !CBS_get_optional_asn1_octet_string(&data, &contents, &present,
	    0xa0) ||
	    present ||
	    CBS_len(&contents) != 0 ||
	    !CBS_get_optional_asn1_octet_string(&data, &contents, NULL, 0xa0) ||
	    CBS_len(&contents) != 0 ||
	    !CBS_get_optional_asn1_uint64(&data, &value, 0xa0, 42) ||
	    value != 42)
		return 0;
d198 6
a203 7
	if (!CBS_get_optional_asn1(&data, &contents, &present, 0xa0) ||
	    present ||
	    !CBS_get_optional_asn1(&data, &contents, &present, 0xa1) ||
	    !present ||
	    CBS_len(&contents) != 3 ||
	    memcmp(CBS_data(&contents), "\x04\x01\x01", 3) != 0)
		return 0;
d207 9
a215 10
	if (!CBS_get_optional_asn1_octet_string(&data, &contents, &present,
	    0xa0) ||
	    present ||
	    CBS_len(&contents) != 0 ||
	    !CBS_get_optional_asn1_octet_string(&data, &contents, &present,
	    0xa1) ||
	    !present ||
	    CBS_len(&contents) != 1 ||
	    CBS_data(&contents)[0] != 1)
		return 0;
d219 2
a220 3
	if (CBS_get_optional_asn1_octet_string(&data, &contents, &present,
	    0xa1))
		return 0;
d224 4
a227 5
	if (!CBS_get_optional_asn1_uint64(&data, &value, 0xa0, 42) ||
	    value != 42 ||
	    !CBS_get_optional_asn1_uint64(&data, &value, 0xa1, 42) ||
	    value != 1)
		return 0;
d231 1
a231 2
	if (CBS_get_optional_asn1_uint64(&data, &value, 0xa1, 42))
		return 0;
d248 2
a249 2
	if (!CBS_get_optional_asn1_bool(&data, &val, 0x0a, 0) || val != 0)
		return 0;
d253 2
a254 2
	if (!CBS_get_optional_asn1_bool(&data, &val, 0x0a, 0) || val != 1)
		return 0;
d258 2
a259 2
	if (!CBS_get_optional_asn1_bool(&data, &val, 0x0a, 1) || val != 0)
		return 0;
d262 1
a262 2
	if (CBS_get_optional_asn1_bool(&data, &val, 0x0a, 1))
		return 0;
d271 1
a271 1
	uint8_t *buf;
d273 1
a273 1
	int ok;
d276 1
a276 2
	if (!CBB_init(&cbb, 100))
		return 0;
d280 6
a285 7
	if (!CBB_init(&cbb, 0) ||
	    !CBB_add_u8(&cbb, 1) ||
	    !CBB_add_u16(&cbb, 0x203) ||
	    !CBB_add_u24(&cbb, 0x40506) ||
	    !CBB_add_bytes(&cbb, (const uint8_t*) "\x07\x08", 2) ||
	    !CBB_finish(&cbb, &buf, &buf_len))
		return 0;
d287 7
a293 2
	ok = buf_len == sizeof(kExpected) && memcmp(buf, kExpected, buf_len)
	    == 0;
d295 1
a295 1
	return ok;
d303 1
a303 1
	uint8_t *out_buf;
d305 13
d319 4
a322 15
	if (!CBB_init_fixed(&cbb, NULL, 0) ||
	    CBB_add_u8(&cbb, 1) ||
	    !CBB_finish(&cbb, &out_buf, &out_size) ||
	    out_buf != NULL ||
	    out_size != 0)
		return 0;

	if (!CBB_init_fixed(&cbb, buf, 1) ||
	    !CBB_add_u8(&cbb, 1) ||
	    CBB_add_u8(&cbb, 2) ||
	    !CBB_finish(&cbb, &out_buf, &out_size) ||
	    out_buf != buf ||
	    out_size != 1 ||
	    buf[0] != 1)
		return 0;
d324 1
a324 1
	return 1;
d335 4
a338 7
	if (!CBB_init(&cbb, 16) ||
	    !CBB_add_u8_length_prefixed(&cbb, &child) ||
	    CBB_finish(&child, &out_buf, &out_size) ||
	    !CBB_finish(&cbb, &out_buf, &out_size) ||
	    out_size != 1 ||
	    out_buf[0] != 0)
		goto err;
d340 1
a340 1
	ret = 1;
d355 1
a355 1
	int ok = 0;
d357 15
a371 16
	if (!CBB_init(&cbb, 0) ||
	    !CBB_add_u8_length_prefixed(&cbb, &contents) ||
	    !CBB_add_u8_length_prefixed(&cbb, &contents) ||
	    !CBB_add_u8(&contents, 1) ||
	    !CBB_add_u16_length_prefixed(&cbb, &contents) ||
	    !CBB_add_u16(&contents, 0x203) ||
	    !CBB_add_u24_length_prefixed(&cbb, &contents) ||
	    !CBB_add_u24(&contents, 0x40506) ||
	    !CBB_add_u8_length_prefixed(&cbb, &contents) ||
	    !CBB_add_u8_length_prefixed(&contents, &inner_contents) ||
	    !CBB_add_u8(&inner_contents, 1) ||
	    !CBB_add_u16_length_prefixed(&inner_contents,
	    &inner_inner_contents) ||
	    !CBB_add_u8(&inner_inner_contents, 2) ||
	    !CBB_finish(&cbb, &buf, &buf_len))
		goto err;
d373 2
a374 2
	ok = buf_len == sizeof(kExpected) && memcmp(buf, kExpected, buf_len)
	    == 0;
d376 1
d378 2
d381 1
a381 1
	return ok;
d392 4
a395 5
	if (!CBB_init(&cbb, 0) ||
	    !CBB_add_u8_length_prefixed(&cbb, &child) ||
	    !CBB_add_u8(&child, 1) ||
	    !CBB_add_u8(&cbb, 2))
		return 0;
d401 8
a408 14
	if (CBB_add_u8(&child, 1) ||
	    CBB_add_u16(&child, 1) ||
	    CBB_add_u24(&child, 1) ||
	    CBB_add_u8_length_prefixed(&child, &contents) ||
	    CBB_add_u16_length_prefixed(&child, &contents) ||
	    CBB_add_asn1(&child, &contents, 1) ||
	    CBB_add_bytes(&child, (const uint8_t*) "a", 1)) {
		fprintf(stderr, "CBB operation on invalid CBB did not fail.\n");
		return 0;
	}

	if (!CBB_finish(&cbb, &buf, &buf_len) || buf_len != 3 ||
	    memcmp(buf, "\x01\x01\x02", 3) != 0)
		goto err;
d410 1
a410 1
	ret = 1;
d412 1
d414 2
d428 1
d430 10
a439 9
	if (!CBB_init(&cbb, 0) ||
	    !CBB_add_asn1(&cbb, &contents, 0x30) ||
	    !CBB_add_bytes(&contents, (const uint8_t*) "\x01\x02\x03", 3) ||
	    !CBB_finish(&cbb, &buf, &buf_len))
		goto err;

	if (buf_len != sizeof(kExpected) || memcmp(buf, kExpected, buf_len)
	    != 0)
		goto err;
d444 1
a444 2
	if ((test_data = malloc(100000)) == NULL)
		goto err;
d447 11
a457 11
	if (!CBB_init(&cbb, 0) ||
	    !CBB_add_asn1(&cbb, &contents, 0x30) ||
	    !CBB_add_bytes(&contents, test_data, 130) ||
	    !CBB_finish(&cbb, &buf, &buf_len))
		goto err;

	if (buf_len != 3 + 130 ||
	    memcmp(buf, "\x30\x81\x82", 3) != 0 ||
	    memcmp(buf + 3, test_data, 130) != 0) {
		goto err;
	}
d461 11
a471 11
	if (!CBB_init(&cbb, 0) ||
	    !CBB_add_asn1(&cbb, &contents, 0x30) ||
	    !CBB_add_bytes(&contents, test_data, 1000) ||
	    !CBB_finish(&cbb, &buf, &buf_len))
		goto err;

	if (buf_len != 4 + 1000 ||
	    memcmp(buf, "\x30\x82\x03\xe8", 4) != 0 ||
	    memcmp(buf + 4, test_data, 1000)) {
		goto err;
	}
d475 12
a486 11
	if (!CBB_init(&cbb, 0) ||
	    !CBB_add_asn1(&cbb, &contents, 0x30) ||
	    !CBB_add_asn1(&contents, &inner_contents, 0x30) ||
	    !CBB_add_bytes(&inner_contents, test_data, 100000) ||
	    !CBB_finish(&cbb, &buf, &buf_len))
		goto err;

	if (buf_len != 5 + 5 + 100000 ||
	    memcmp(buf, "\x30\x83\x01\x86\xa5\x30\x83\x01\x86\xa0", 10) != 0 ||
	    memcmp(buf + 10, test_data, 100000))
		goto err;
d490 1
d492 3
a496 1

d510 2
a511 5
	if (!CBS_asn1_indefinite_to_definite(&in, &out, &out_len)) {
		fprintf(stderr, "%s: CBS_asn1_indefinite_to_definite failed.\n",
		    name);
		goto end;
	}
d514 3
a516 7
		if (indefinite_len != definite_len ||
		    memcmp(definite_expected, indefinite, indefinite_len)
		    != 0) {
			fprintf(stderr, "%s: incorrect unconverted result.\n",
			    name);
			return 0;
		}
d521 2
a522 5
	if (out_len != definite_len || memcmp(out, definite_expected,
	    definite_len) != 0) {
		fprintf(stderr, "%s: incorrect converted result.\n", name);
		goto end;
	}
d526 1
a526 1
end:
d576 5
a580 5
	return do_indefinite_convert("kSimpleBER", kSimpleBER, sizeof(kSimpleBER),
	    kSimpleBER, sizeof(kSimpleBER)) &&
	    do_indefinite_convert("kIndefBER", kIndefDER, sizeof(kIndefDER), kIndefBER,
	    sizeof(kIndefBER)) &&
	    do_indefinite_convert("kOctetStringBER", kOctetStringDER,
d582 5
a586 3
	    sizeof(kOctetStringBER)) &&
	    do_indefinite_convert("kNSSBER", kNSSDER, sizeof(kNSSDER), kNSSBER,
	    sizeof(kNSSBER));
d628 2
d631 2
a638 2
		CBB cbb;
		uint8_t *out;
d644 9
a652 13
		if (!CBS_get_asn1_uint64(&cbs, &value) ||
		    CBS_len(&cbs) != 0 ||
		    value != test->value)
			return 0;

		if (!CBB_init(&cbb, 0))
			return 0;

		if (!CBB_add_asn1_uint64(&cbb, test->value) ||
		    !CBB_finish(&cbb, &out, &len)) {
			CBB_cleanup(&cbb);
			return 0;
		}
d654 2
a655 5
		if (len != test->encoding_len || memcmp(out, test->encoding,
		    len) != 0) {
			free(out);
			return 0;
		}
d657 1
d669 9
a677 2
		if (CBS_get_asn1_uint64(&cbs, &value))
			return 0;
d679 1
d681 1
a681 1
	return 1;
d692 17
a708 13
	if (sizeof(input) != 5)
		return 0;

	if (!(CBS_len(&data) == 5 && CBS_offset(&data) == 0 &&
	    CBS_get_u8(&data, &v) && v == 1 &&
	    CBS_len(&data) == 4 && CBS_offset(&data) == 1 &&
	    CBS_skip(&data, 2) &&
	    CBS_len(&data) == 2 && CBS_offset(&data) == 3 &&
	    CBS_get_u8(&data, &v) && v == 4 &&
	    CBS_get_u8(&data, &v) && v == 5 &&
	    CBS_len(&data) == 0 && CBS_offset(&data) == 5 &&
	    !CBS_skip(&data, 1)))
		return 0;
d711 7
a717 6
	if (!(CBS_skip(&data, 2) &&
	    CBS_len(&data) == 3 && CBS_offset(&data) == 2 &&
	    CBS_skip(&data, 3) &&
	    CBS_len(&data) == 0 && CBS_offset(&data) == 5 &&
	    !CBS_get_u8(&data, &v)))
		return 0;
d732 1
a732 4
	if ((tmp = malloc(sizeof(input))) == NULL) {
		fprintf(stderr, "failed to malloc\n");
		goto err;
	}
d736 10
a745 8
	if (!(CBS_len(&data) == 6 && CBS_offset(&data) == 0 &&
	    CBS_get_u8(&data, &v) && v == 102 /* f */ &&
	    CBS_skip(&data, 1) &&
	    !CBS_skip(&data, 15) &&
	    CBS_write_bytes(&data, tmp, sizeof(input), &len) &&
	    len == 4 && memcmp(input + 2, tmp, len) == 0 &&
	    tmp[4] == 100 && tmp[5] == 100))
		goto err;
d757 1
a757 17
	if (!test_skip() ||
	    !test_get_u() ||
	    !test_get_prefixed() ||
	    !test_get_prefixed_bad() ||
	    !test_get_asn1() ||
	    !test_cbb_basic() ||
	    !test_cbb_fixed() ||
	    !test_cbb_finish_child() ||
	    !test_cbb_misuse() ||
	    !test_cbb_prefixed() ||
	    !test_cbb_asn1() ||
	    !test_indefinite_convert() ||
	    !test_asn1_uint64() ||
	    !test_get_optional_asn1_bool() ||
	    !test_offset() ||
	    !test_write_bytes())
		return 1;
d759 20
a778 2
	printf("PASS\n");
	return 0;
@


1.5
log
@Be more strict about BER and DER terminology.

bs_ber.c does not convert BER to DER.  It's a hack to convert a DER-like
encoding with one violation (indefinite form) to strict DER.  Rename
the functions to reflect this.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bytestringtest.c,v 1.4 2015/04/25 15:28:47 doug Exp $	*/
d674 66
d756 3
a758 1
	    !test_get_optional_asn1_bool())
@


1.4
log
@Check for invalid leading zeros in CBS_get_asn1_uint64.

ASN.1 integers cannot have all zeros or all ones for the first 9 bits.
This rule ensures the numbers are encoded with the smallest number of
content octets (see ITU-T Rec X.690 section 8.3.2).

Based on BoringSSL commit 5933723b7b592e9914f703d630b596e140c93e16

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bytestringtest.c,v 1.3 2015/02/16 06:48:17 doug Exp $	*/
d487 2
a488 2
do_ber_convert(const char *name, const uint8_t *der_expected, size_t der_len,
    const uint8_t *ber, size_t ber_len)
d495 4
a498 3
	CBS_init(&in, ber, ber_len);
	if (!CBS_asn1_ber_to_der(&in, &out, &out_len)) {
		fprintf(stderr, "%s: CBS_asn1_ber_to_der failed.\n", name);
d503 3
a505 2
		if (ber_len != der_len ||
		    memcmp(der_expected, ber, ber_len) != 0) {
d514 2
a515 1
	if (out_len != der_len || memcmp(out, der_expected, der_len) != 0) {
d528 1
a528 1
test_ber_convert(void)
d572 1
a572 1
	return do_ber_convert("kSimpleBER", kSimpleBER, sizeof(kSimpleBER),
d574 1
a574 1
	    do_ber_convert("kIndefBER", kIndefDER, sizeof(kIndefDER), kIndefBER,
d576 1
a576 1
	    do_ber_convert("kOctetStringBER", kOctetStringDER,
d579 1
a579 1
	    do_ber_convert("kNSSBER", kNSSDER, sizeof(kNSSDER), kNSSBER,
d688 1
a688 1
	    !test_ber_convert() ||
@


1.3
log
@Add more error checking and free resources in bytestringtest.
@
text
@d1 1
a1 1
/*	$OpenBSD: bytestringtest.c,v 1.2 2015/02/06 22:22:33 doug Exp $	*/
d610 1
a610 1
	/* Overflow */
d612 2
@


1.2
log
@KNF bytestring files.

I checked that this doesn't change anything.  Compiled with clang using
-Wno-pointer-sign -g0  to reduce the differences.  Only difference in the
asm is due to assert(0) line number changes in bs_cbs.c and bs_cbb.c.

miod is ok with the general process.
@
text
@d1 1
a1 1
/*	$OpenBSD: bytestringtest.c,v 1.1 2015/02/06 09:36:16 doug Exp $	*/
d317 1
a317 1
	uint8_t *out_buf;
d319 1
d327 3
a329 1
		return 0;
d331 1
d333 1
a333 1
	return 1;
d341 1
a341 1
	uint8_t *buf;
d344 1
a344 1
	int ok;
d361 1
a361 1
		return 0;
d365 2
d375 1
a375 1
	uint8_t *buf;
d377 1
d402 3
a404 1
		return 0;
d406 1
d408 1
a408 2

	return 1;
d415 1
a415 1
	uint8_t *buf, *test_data;
d418 1
d424 1
a424 1
		return 0;
d428 1
a428 1
		return 0;
d431 1
d433 2
a434 1
	test_data = malloc(100000);
d441 1
a441 1
		return 0;
d446 1
a446 1
		return 0;
d449 1
d455 1
a455 1
		return 0;
d460 1
a460 1
		return 0;
d463 1
d470 1
a470 1
		return 0;
d475 3
a477 1
		return 0;
d479 1
d483 1
a483 1
	return 1;
d491 1
a491 1
	uint8_t *out;
d493 1
d498 1
a498 1
		return 0;
d514 1
a514 1
		return 0;
d517 3
d521 1
a521 1
	return 1;
@


1.1
log
@Import BoringSSL's crypto bytestring and crypto bytebuilder APIs.

This is imported with as few changes as possible for the initial commit.
I removed OPENSSL_EXPORT, replaced OPENSSL_malloc() etc with malloc()
and changed a few header includes.

BoringSSL has this as part of their public API.  We're leaving it internal
to libssl for now.

Based on BoringSSL's CBB/CBS API as of commit
c5cc15b4f5b1d6e9b9112cb8d30205a638aa2c54.

input + ok jsing@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d28 529
a556 522
static int test_skip(void) {
  static const uint8_t kData[] = {1, 2, 3};
  CBS data;

  CBS_init(&data, kData, sizeof(kData));
  return CBS_len(&data) == 3 &&
      CBS_skip(&data, 1) &&
      CBS_len(&data) == 2 &&
      CBS_skip(&data, 2) &&
      CBS_len(&data) == 0 &&
      !CBS_skip(&data, 1);
}

static int test_get_u(void) {
  static const uint8_t kData[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  uint8_t u8;
  uint16_t u16;
  uint32_t u32;
  CBS data;

  CBS_init(&data, kData, sizeof(kData));
  return CBS_get_u8(&data, &u8) &&
    u8 == 1 &&
    CBS_get_u16(&data, &u16) &&
    u16 == 0x203 &&
    CBS_get_u24(&data, &u32) &&
    u32 == 0x40506 &&
    CBS_get_u32(&data, &u32) &&
    u32 == 0x708090a &&
    !CBS_get_u8(&data, &u8);
}

static int test_get_prefixed(void) {
  static const uint8_t kData[] = {1, 2, 0, 2, 3, 4, 0, 0, 3, 3, 2, 1};
  uint8_t u8;
  uint16_t u16;
  uint32_t u32;
  CBS data, prefixed;

  CBS_init(&data, kData, sizeof(kData));
  return CBS_get_u8_length_prefixed(&data, &prefixed) &&
    CBS_len(&prefixed) == 1 &&
    CBS_get_u8(&prefixed, &u8) &&
    u8 == 2 &&
    CBS_get_u16_length_prefixed(&data, &prefixed) &&
    CBS_len(&prefixed) == 2 &&
    CBS_get_u16(&prefixed, &u16) &&
    u16 == 0x304 &&
    CBS_get_u24_length_prefixed(&data, &prefixed) &&
    CBS_len(&prefixed) == 3 &&
    CBS_get_u24(&prefixed, &u32) &&
    u32 == 0x30201;
}

static int test_get_prefixed_bad(void) {
  static const uint8_t kData1[] = {2, 1};
  static const uint8_t kData2[] = {0, 2, 1};
  static const uint8_t kData3[] = {0, 0, 2, 1};
  CBS data, prefixed;

  CBS_init(&data, kData1, sizeof(kData1));
  if (CBS_get_u8_length_prefixed(&data, &prefixed)) {
    return 0;
  }

  CBS_init(&data, kData2, sizeof(kData2));
  if (CBS_get_u16_length_prefixed(&data, &prefixed)) {
    return 0;
  }

  CBS_init(&data, kData3, sizeof(kData3));
  if (CBS_get_u24_length_prefixed(&data, &prefixed)) {
    return 0;
  }

  return 1;
}

static int test_get_asn1(void) {
  static const uint8_t kData1[] = {0x30, 2, 1, 2};
  static const uint8_t kData2[] = {0x30, 3, 1, 2};
  static const uint8_t kData3[] = {0x30, 0x80};
  static const uint8_t kData4[] = {0x30, 0x81, 1, 1};
  static const uint8_t kData5[] = {0x30, 0x82, 0, 1, 1};
  static const uint8_t kData6[] = {0xa1, 3, 0x4, 1, 1};
  static const uint8_t kData7[] = {0xa1, 3, 0x4, 2, 1};
  static const uint8_t kData8[] = {0xa1, 3, 0x2, 1, 1};
  static const uint8_t kData9[] = {0xa1, 3, 0x2, 1, 0xff};

  CBS data, contents;
  int present;
  uint64_t value;

  CBS_init(&data, kData1, sizeof(kData1));
  if (CBS_peek_asn1_tag(&data, 0x1) ||
      !CBS_peek_asn1_tag(&data, 0x30)) {
    return 0;
  }
  if (!CBS_get_asn1(&data, &contents, 0x30) ||
      CBS_len(&contents) != 2 ||
      memcmp(CBS_data(&contents), "\x01\x02", 2) != 0) {
    return 0;
  }

  CBS_init(&data, kData2, sizeof(kData2));
  /* data is truncated */
  if (CBS_get_asn1(&data, &contents, 0x30)) {
    return 0;
  }

  CBS_init(&data, kData3, sizeof(kData3));
  /* zero byte length of length */
  if (CBS_get_asn1(&data, &contents, 0x30)) {
    return 0;
  }

  CBS_init(&data, kData4, sizeof(kData4));
  /* long form mistakenly used. */
  if (CBS_get_asn1(&data, &contents, 0x30)) {
    return 0;
  }

  CBS_init(&data, kData5, sizeof(kData5));
  /* length takes too many bytes. */
  if (CBS_get_asn1(&data, &contents, 0x30)) {
    return 0;
  }

  CBS_init(&data, kData1, sizeof(kData1));
  /* wrong tag. */
  if (CBS_get_asn1(&data, &contents, 0x31)) {
    return 0;
  }

  CBS_init(&data, NULL, 0);
  /* peek at empty data. */
  if (CBS_peek_asn1_tag(&data, 0x30)) {
    return 0;
  }

  CBS_init(&data, NULL, 0);
  /* optional elements at empty data. */
  if (!CBS_get_optional_asn1(&data, &contents, &present, 0xa0) ||
      present ||
      !CBS_get_optional_asn1_octet_string(&data, &contents, &present, 0xa0) ||
      present ||
      CBS_len(&contents) != 0 ||
      !CBS_get_optional_asn1_octet_string(&data, &contents, NULL, 0xa0) ||
      CBS_len(&contents) != 0 ||
      !CBS_get_optional_asn1_uint64(&data, &value, 0xa0, 42) ||
      value != 42) {
    return 0;
  }

  CBS_init(&data, kData6, sizeof(kData6));
  /* optional element. */
  if (!CBS_get_optional_asn1(&data, &contents, &present, 0xa0) ||
      present ||
      !CBS_get_optional_asn1(&data, &contents, &present, 0xa1) ||
      !present ||
      CBS_len(&contents) != 3 ||
      memcmp(CBS_data(&contents), "\x04\x01\x01", 3) != 0) {
    return 0;
  }

  CBS_init(&data, kData6, sizeof(kData6));
  /* optional octet string. */
  if (!CBS_get_optional_asn1_octet_string(&data, &contents, &present, 0xa0) ||
      present ||
      CBS_len(&contents) != 0 ||
      !CBS_get_optional_asn1_octet_string(&data, &contents, &present, 0xa1) ||
      !present ||
      CBS_len(&contents) != 1 ||
      CBS_data(&contents)[0] != 1) {
    return 0;
  }

  CBS_init(&data, kData7, sizeof(kData7));
  /* invalid optional octet string. */
  if (CBS_get_optional_asn1_octet_string(&data, &contents, &present, 0xa1)) {
    return 0;
  }

  CBS_init(&data, kData8, sizeof(kData8));
  /* optional octet string. */
  if (!CBS_get_optional_asn1_uint64(&data, &value, 0xa0, 42) ||
      value != 42 ||
      !CBS_get_optional_asn1_uint64(&data, &value, 0xa1, 42) ||
      value != 1) {
    return 0;
  }

  CBS_init(&data, kData9, sizeof(kData9));
  /* invalid optional integer. */
  if (CBS_get_optional_asn1_uint64(&data, &value, 0xa1, 42)) {
    return 0;
  }

  return 1;
}

static int test_get_optional_asn1_bool(void) {
  CBS data;
  int val;

  static const uint8_t kTrue[] = {0x0a, 3, CBS_ASN1_BOOLEAN, 1, 0xff};
  static const uint8_t kFalse[] = {0x0a, 3, CBS_ASN1_BOOLEAN, 1, 0x00};
  static const uint8_t kInvalid[] = {0x0a, 3, CBS_ASN1_BOOLEAN, 1, 0x01};

  CBS_init(&data, NULL, 0);
  val = 2;
  if (!CBS_get_optional_asn1_bool(&data, &val, 0x0a, 0) ||
      val != 0) {
    return 0;
  }

  CBS_init(&data, kTrue, sizeof(kTrue));
  val = 2;
  if (!CBS_get_optional_asn1_bool(&data, &val, 0x0a, 0) ||
      val != 1) {
    return 0;
  }

  CBS_init(&data, kFalse, sizeof(kFalse));
  val = 2;
  if (!CBS_get_optional_asn1_bool(&data, &val, 0x0a, 1) ||
      val != 0) {
    return 0;
  }

  CBS_init(&data, kInvalid, sizeof(kInvalid));
  if (CBS_get_optional_asn1_bool(&data, &val, 0x0a, 1)) {
    return 0;
  }

  return 1;
}

static int test_cbb_basic(void) {
  static const uint8_t kExpected[] = {1, 2, 3, 4, 5, 6, 7, 8};
  uint8_t *buf;
  size_t buf_len;
  int ok;
  CBB cbb;

  if (!CBB_init(&cbb, 100)) {
    return 0;
  }
  CBB_cleanup(&cbb);

  if (!CBB_init(&cbb, 0) ||
      !CBB_add_u8(&cbb, 1) ||
      !CBB_add_u16(&cbb, 0x203) ||
      !CBB_add_u24(&cbb, 0x40506) ||
      !CBB_add_bytes(&cbb, (const uint8_t*) "\x07\x08", 2) ||
      !CBB_finish(&cbb, &buf, &buf_len)) {
    return 0;
  }

  ok = buf_len == sizeof(kExpected) && memcmp(buf, kExpected, buf_len) == 0;
  free(buf);
  return ok;
}

static int test_cbb_fixed(void) {
  CBB cbb;
  uint8_t buf[1];
  uint8_t *out_buf;
  size_t out_size;

  if (!CBB_init_fixed(&cbb, NULL, 0) ||
      CBB_add_u8(&cbb, 1) ||
      !CBB_finish(&cbb, &out_buf, &out_size) ||
      out_buf != NULL ||
      out_size != 0) {
    return 0;
  }

  if (!CBB_init_fixed(&cbb, buf, 1) ||
      !CBB_add_u8(&cbb, 1) ||
      CBB_add_u8(&cbb, 2) ||
      !CBB_finish(&cbb, &out_buf, &out_size) ||
      out_buf != buf ||
      out_size != 1 ||
      buf[0] != 1) {
    return 0;
  }

  return 1;
}

static int test_cbb_finish_child(void) {
  CBB cbb, child;
  uint8_t *out_buf;
  size_t out_size;

  if (!CBB_init(&cbb, 16) ||
      !CBB_add_u8_length_prefixed(&cbb, &child) ||
      CBB_finish(&child, &out_buf, &out_size) ||
      !CBB_finish(&cbb, &out_buf, &out_size) ||
      out_size != 1 ||
      out_buf[0] != 0) {
    return 0;
  }

  free(out_buf);
  return 1;
}

static int test_cbb_prefixed(void) {
  static const uint8_t kExpected[] = {0, 1, 1, 0, 2, 2, 3, 0, 0, 3,
                                      4, 5, 6, 5, 4, 1, 0, 1, 2};
  uint8_t *buf;
  size_t buf_len;
  CBB cbb, contents, inner_contents, inner_inner_contents;
  int ok;

  if (!CBB_init(&cbb, 0) ||
      !CBB_add_u8_length_prefixed(&cbb, &contents) ||
      !CBB_add_u8_length_prefixed(&cbb, &contents) ||
      !CBB_add_u8(&contents, 1) ||
      !CBB_add_u16_length_prefixed(&cbb, &contents) ||
      !CBB_add_u16(&contents, 0x203) ||
      !CBB_add_u24_length_prefixed(&cbb, &contents) ||
      !CBB_add_u24(&contents, 0x40506) ||
      !CBB_add_u8_length_prefixed(&cbb, &contents) ||
      !CBB_add_u8_length_prefixed(&contents, &inner_contents) ||
      !CBB_add_u8(&inner_contents, 1) ||
      !CBB_add_u16_length_prefixed(&inner_contents, &inner_inner_contents) ||
      !CBB_add_u8(&inner_inner_contents, 2) ||
      !CBB_finish(&cbb, &buf, &buf_len)) {
    return 0;
  }

  ok = buf_len == sizeof(kExpected) && memcmp(buf, kExpected, buf_len) == 0;
  free(buf);
  return ok;
}

static int test_cbb_misuse(void) {
  CBB cbb, child, contents;
  uint8_t *buf;
  size_t buf_len;

  if (!CBB_init(&cbb, 0) ||
      !CBB_add_u8_length_prefixed(&cbb, &child) ||
      !CBB_add_u8(&child, 1) ||
      !CBB_add_u8(&cbb, 2)) {
    return 0;
  }

  /* Since we wrote to |cbb|, |child| is now invalid and attempts to write to
   * it should fail. */
  if (CBB_add_u8(&child, 1) ||
      CBB_add_u16(&child, 1) ||
      CBB_add_u24(&child, 1) ||
      CBB_add_u8_length_prefixed(&child, &contents) ||
      CBB_add_u16_length_prefixed(&child, &contents) ||
      CBB_add_asn1(&child, &contents, 1) ||
      CBB_add_bytes(&child, (const uint8_t*) "a", 1)) {
    fprintf(stderr, "CBB operation on invalid CBB did not fail.\n");
    return 0;
  }

  if (!CBB_finish(&cbb, &buf, &buf_len) ||
      buf_len != 3 ||
      memcmp(buf, "\x01\x01\x02", 3) != 0) {
    return 0;
  }

  free(buf);

  return 1;
}

static int test_cbb_asn1(void) {
  static const uint8_t kExpected[] = {0x30, 3, 1, 2, 3};
  uint8_t *buf, *test_data;
  size_t buf_len;
  CBB cbb, contents, inner_contents;

  if (!CBB_init(&cbb, 0) ||
      !CBB_add_asn1(&cbb, &contents, 0x30) ||
      !CBB_add_bytes(&contents, (const uint8_t*) "\x01\x02\x03", 3) ||
      !CBB_finish(&cbb, &buf, &buf_len)) {
    return 0;
  }

  if (buf_len != sizeof(kExpected) || memcmp(buf, kExpected, buf_len) != 0) {
    return 0;
  }
  free(buf);

  test_data = malloc(100000);
  memset(test_data, 0x42, 100000);

  if (!CBB_init(&cbb, 0) ||
      !CBB_add_asn1(&cbb, &contents, 0x30) ||
      !CBB_add_bytes(&contents, test_data, 130) ||
      !CBB_finish(&cbb, &buf, &buf_len)) {
    return 0;
  }

  if (buf_len != 3 + 130 ||
      memcmp(buf, "\x30\x81\x82", 3) != 0 ||
      memcmp(buf + 3, test_data, 130) != 0) {
    return 0;
  }
  free(buf);

  if (!CBB_init(&cbb, 0) ||
      !CBB_add_asn1(&cbb, &contents, 0x30) ||
      !CBB_add_bytes(&contents, test_data, 1000) ||
      !CBB_finish(&cbb, &buf, &buf_len)) {
    return 0;
  }

  if (buf_len != 4 + 1000 ||
      memcmp(buf, "\x30\x82\x03\xe8", 4) != 0 ||
      memcmp(buf + 4, test_data, 1000)) {
    return 0;
  }
  free(buf);

  if (!CBB_init(&cbb, 0) ||
      !CBB_add_asn1(&cbb, &contents, 0x30) ||
      !CBB_add_asn1(&contents, &inner_contents, 0x30) ||
      !CBB_add_bytes(&inner_contents, test_data, 100000) ||
      !CBB_finish(&cbb, &buf, &buf_len)) {
    return 0;
  }

  if (buf_len != 5 + 5 + 100000 ||
      memcmp(buf, "\x30\x83\x01\x86\xa5\x30\x83\x01\x86\xa0", 10) != 0 ||
      memcmp(buf + 10, test_data, 100000)) {
    return 0;
  }
  free(buf);

  free(test_data);
  return 1;
}

static int do_ber_convert(const char *name,
                          const uint8_t *der_expected, size_t der_len,
                          const uint8_t *ber, size_t ber_len) {
  CBS in;
  uint8_t *out;
  size_t out_len;

  CBS_init(&in, ber, ber_len);
  if (!CBS_asn1_ber_to_der(&in, &out, &out_len)) {
    fprintf(stderr, "%s: CBS_asn1_ber_to_der failed.\n", name);
    return 0;
  }

  if (out == NULL) {
    if (ber_len != der_len ||
        memcmp(der_expected, ber, ber_len) != 0) {
      fprintf(stderr, "%s: incorrect unconverted result.\n", name);
      return 0;
    }

    return 1;
  }

  if (out_len != der_len ||
      memcmp(out, der_expected, der_len) != 0) {
    fprintf(stderr, "%s: incorrect converted result.\n", name);
    return 0;
  }

  free(out);
  return 1;
}

static int test_ber_convert(void) {
  static const uint8_t kSimpleBER[] = {0x01, 0x01, 0x00};

  /* kIndefBER contains a SEQUENCE with an indefinite length. */
  static const uint8_t kIndefBER[] = {0x30, 0x80, 0x01, 0x01, 0x02, 0x00, 0x00};
  static const uint8_t kIndefDER[] = {0x30, 0x03, 0x01, 0x01, 0x02};

  /* kOctetStringBER contains an indefinite length OCTETSTRING with two parts.
   * These parts need to be concatenated in DER form. */
  static const uint8_t kOctetStringBER[] = {0x24, 0x80, 0x04, 0x02, 0,    1,
                                            0x04, 0x02, 2,    3,    0x00, 0x00};
  static const uint8_t kOctetStringDER[] = {0x04, 0x04, 0, 1, 2, 3};

  /* kNSSBER is part of a PKCS#12 message generated by NSS that uses indefinite
   * length elements extensively. */
  static const uint8_t kNSSBER[] = {
      0x30, 0x80, 0x02, 0x01, 0x03, 0x30, 0x80, 0x06, 0x09, 0x2a, 0x86, 0x48,
      0x86, 0xf7, 0x0d, 0x01, 0x07, 0x01, 0xa0, 0x80, 0x24, 0x80, 0x04, 0x04,
      0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x39,
      0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05,
      0x00, 0x04, 0x14, 0x84, 0x98, 0xfc, 0x66, 0x33, 0xee, 0xba, 0xe7, 0x90,
      0xc1, 0xb6, 0xe8, 0x8f, 0xfe, 0x1d, 0xc5, 0xa5, 0x97, 0x93, 0x3e, 0x04,
      0x10, 0x38, 0x62, 0xc6, 0x44, 0x12, 0xd5, 0x30, 0x00, 0xf8, 0xf2, 0x1b,
      0xf0, 0x6e, 0x10, 0x9b, 0xb8, 0x02, 0x02, 0x07, 0xd0, 0x00, 0x00,
  };

  static const uint8_t kNSSDER[] = {
      0x30, 0x53, 0x02, 0x01, 0x03, 0x30, 0x13, 0x06, 0x09, 0x2a, 0x86,
      0x48, 0x86, 0xf7, 0x0d, 0x01, 0x07, 0x01, 0xa0, 0x06, 0x04, 0x04,
      0x01, 0x02, 0x03, 0x04, 0x30, 0x39, 0x30, 0x21, 0x30, 0x09, 0x06,
      0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14, 0x84,
      0x98, 0xfc, 0x66, 0x33, 0xee, 0xba, 0xe7, 0x90, 0xc1, 0xb6, 0xe8,
      0x8f, 0xfe, 0x1d, 0xc5, 0xa5, 0x97, 0x93, 0x3e, 0x04, 0x10, 0x38,
      0x62, 0xc6, 0x44, 0x12, 0xd5, 0x30, 0x00, 0xf8, 0xf2, 0x1b, 0xf0,
      0x6e, 0x10, 0x9b, 0xb8, 0x02, 0x02, 0x07, 0xd0,
  };

  return do_ber_convert("kSimpleBER", kSimpleBER, sizeof(kSimpleBER),
                        kSimpleBER, sizeof(kSimpleBER)) &&
         do_ber_convert("kIndefBER", kIndefDER, sizeof(kIndefDER), kIndefBER,
                        sizeof(kIndefBER)) &&
         do_ber_convert("kOctetStringBER", kOctetStringDER,
                        sizeof(kOctetStringDER), kOctetStringBER,
                        sizeof(kOctetStringBER)) &&
         do_ber_convert("kNSSBER", kNSSDER, sizeof(kNSSDER), kNSSBER,
                        sizeof(kNSSBER));
d560 3
a562 3
  uint64_t value;
  const char *encoding;
  size_t encoding_len;
d566 9
a574 9
  {0, "\x02\x01\x00", 3},
  {1, "\x02\x01\x01", 3},
  {127, "\x02\x01\x7f", 3},
  {128, "\x02\x02\x00\x80", 4},
  {0xdeadbeef, "\x02\x05\x00\xde\xad\xbe\xef", 7},
  {OPENSSL_U64(0x0102030405060708),
   "\x02\x08\x01\x02\x03\x04\x05\x06\x07\x08", 10},
  {OPENSSL_U64(0xffffffffffffffff),
    "\x02\x09\x00\xff\xff\xff\xff\xff\xff\xff\xff", 11},
d578 2
a579 2
  const char *encoding;
  size_t encoding_len;
d583 8
a590 8
  /* Bad tag. */
  {"\x03\x01\x00", 3},
  /* Empty contents. */
  {"\x02\x00", 2},
  /* Negative number. */
  {"\x02\x01\x80", 3},
  /* Overflow */
  {"\x02\x09\x01\x00\x00\x00\x00\x00\x00\x00\x00", 11},
d593 73
a665 2
static int test_asn1_uint64(void) {
  size_t i;
d667 2
a668 66
  for (i = 0; i < sizeof(kAsn1Uint64Tests) / sizeof(kAsn1Uint64Tests[0]); i++) {
    const ASN1_UINT64_TEST *test = &kAsn1Uint64Tests[i];
    CBS cbs;
    uint64_t value;
    CBB cbb;
    uint8_t *out;
    size_t len;

    CBS_init(&cbs, (const uint8_t *)test->encoding, test->encoding_len);
    if (!CBS_get_asn1_uint64(&cbs, &value) ||
        CBS_len(&cbs) != 0 ||
        value != test->value) {
      return 0;
    }

    if (!CBB_init(&cbb, 0)) {
      return 0;
    }
    if (!CBB_add_asn1_uint64(&cbb, test->value) ||
        !CBB_finish(&cbb, &out, &len)) {
      CBB_cleanup(&cbb);
      return 0;
    }
    if (len != test->encoding_len || memcmp(out, test->encoding, len) != 0) {
      free(out);
      return 0;
    }
    free(out);
  }

  for (i = 0;
       i < sizeof(kAsn1InvalidUint64Tests) / sizeof(kAsn1InvalidUint64Tests[0]);
       i++) {
    const ASN1_INVALID_UINT64_TEST *test = &kAsn1InvalidUint64Tests[i];
    CBS cbs;
    uint64_t value;

    CBS_init(&cbs, (const uint8_t *)test->encoding, test->encoding_len);
    if (CBS_get_asn1_uint64(&cbs, &value)) {
      return 0;
    }
  }

  return 1;
}

int main(void) {
  if (!test_skip() ||
      !test_get_u() ||
      !test_get_prefixed() ||
      !test_get_prefixed_bad() ||
      !test_get_asn1() ||
      !test_cbb_basic() ||
      !test_cbb_fixed() ||
      !test_cbb_finish_child() ||
      !test_cbb_misuse() ||
      !test_cbb_prefixed() ||
      !test_cbb_asn1() ||
      !test_ber_convert() ||
      !test_asn1_uint64() ||
      !test_get_optional_asn1_bool()) {
    return 1;
  }

  printf("PASS\n");
  return 0;
@

