head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.4
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.3.0.8
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2016.12.26.15.31.38;	author jsing;	state Exp;
branches;
next	1.5;
commitid	8hDUP4oLukML2LLJ;

1.5
date	2016.12.26.15.24.03;	author jsing;	state Exp;
branches;
next	1.4;
commitid	5bY5W3dVqYcriOuz;

1.4
date	2016.12.21.15.13.29;	author jsing;	state Exp;
branches;
next	1.3;
commitid	NVAY1p6rzY2NP4O3;

1.3
date	2014.12.07.20.00.13;	author bcook;	state Exp;
branches;
next	1.2;
commitid	TQH44MraKy6ovKzJ;

1.2
date	2014.07.16.17.38.19;	author miod;	state Exp;
branches;
next	1.1;
commitid	5vRKogJDxTEqX4Bb;

1.1
date	2014.07.13.16.03.54;	author jsing;	state Exp;
branches;
next	;
commitid	cr5n55nO6YEqVMjh;


desc
@@


1.6
log
@Extend regress to include a peer certificate in the session.
@
text
@/*	$OpenBSD: asn1test.c,v 1.4 2016/12/21 15:13:29 jsing Exp $	*/
/*
 * Copyright (c) 2014, 2016 Joel Sing <jsing@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <err.h>
#include <stdlib.h>

#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/ssl.h>
#include <openssl/tls1.h>

int i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp);
SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp,
    long length);

X509 *peer_cert;

unsigned char *peer_cert_pem =
    "-----BEGIN CERTIFICATE-----\n"
    "MIIBcTCCARugAwIBAgIJAPYhaZJAvUuUMA0GCSqGSIb3DQEBBQUAMBQxEjAQBgNV\n"
    "BAoMCVRlc3QgUGVlcjAeFw0xNjEyMjYxNDQ3NDdaFw0yNjEyMjQxNDQ3NDdaMBQx\n"
    "EjAQBgNVBAoMCVRlc3QgUGVlcjBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQCyhAdJ\n"
    "wojHv/uKONh8MbmR2U2+VF1HQusnLfSfHPqkJfvDzLWJ41TG7QcXkx2rIJVtAFrO\n"
    "U9yNdFYJLA/hsrbjAgMBAAGjUDBOMB0GA1UdDgQWBBS3bZOw7fvaortdsdE2TPMq\n"
    "IRXFRzAfBgNVHSMEGDAWgBS3bZOw7fvaortdsdE2TPMqIRXFRzAMBgNVHRMEBTAD\n"
    "AQH/MA0GCSqGSIb3DQEBBQUAA0EAHsxNS+rNUZbopeDMhVIviOfUmelDjJrT56Rc\n"
    "VJoFN3Gc1cV8nQAHm9aJs71uksC+MN04Pzh0WqmYX9XXrnYPcg==\n"
    "-----END CERTIFICATE-----\n";

struct ssl_asn1_test {
	SSL_SESSION session;
	int peer_cert;
	const unsigned char asn1[1024];
	int asn1_len;
};

unsigned char tlsext_tick[] = {
	0x43, 0x56, 0x45, 0x2d, 0x32, 0x30, 0x31, 0x34,
	0x2d, 0x30, 0x31, 0x36, 0x30, 0x3a, 0x20, 0x37,
	0x74, 0x68, 0x20, 0x41, 0x70, 0x72, 0x69, 0x6c,
	0x20, 0x32, 0x30, 0x31, 0x34, 0x0a, 0x43, 0x56,
	0x45, 0x2d, 0x32, 0x30, 0x31, 0x30, 0x2d, 0x35,
	0x32, 0x39, 0x38, 0x3a, 0x20, 0x38, 0x74, 0x68,
	0x20, 0x41, 0x70, 0x72, 0x69, 0x6c, 0x20, 0x32,
	0x30, 0x31, 0x34, 0x0a, 0x43, 0x56, 0x45, 0x2d,
	0x32, 0x30, 0x31, 0x34, 0x2d, 0x30, 0x31, 0x39,
	0x38, 0x3a, 0x20, 0x32, 0x31, 0x73, 0x74, 0x20,
	0x41, 0x70, 0x72, 0x69, 0x6c, 0x20, 0x32, 0x30,
	0x31, 0x34, 0x0a, 0x43, 0x56, 0x45, 0x2d, 0x32,
	0x30, 0x31, 0x34, 0x2d, 0x33, 0x34, 0x37, 0x30,
	0x3a, 0x20, 0x33, 0x30, 0x74, 0x68, 0x20, 0x4d,
	0x61, 0x79, 0x20, 0x32, 0x30, 0x31, 0x34, 0x0a,
	0x43, 0x56, 0x45, 0x2d, 0x32, 0x30, 0x31, 0x34,
	0x2d, 0x30, 0x31, 0x39, 0x35, 0x3a, 0x20, 0x35,
	0x74, 0x68, 0x20, 0x4a, 0x75, 0x6e, 0x65, 0x20,
	0x32, 0x30, 0x31, 0x34, 0x0a, 0x43, 0x56, 0x45,
	0x2d, 0x32, 0x30, 0x31, 0x34, 0x2d, 0x30, 0x32,
	0x32, 0x31, 0x3a, 0x20, 0x35, 0x74, 0x68, 0x20,
	0x4a, 0x75, 0x6e, 0x65, 0x20, 0x32, 0x30, 0x31,
	0x34, 0x0a, 0x43, 0x56, 0x45, 0x2d, 0x32, 0x30,
	0x31, 0x34, 0x2d, 0x30, 0x32, 0x32, 0x34, 0x3a,
	0x20, 0x35, 0x74, 0x68, 0x20, 0x4a, 0x75, 0x6e,
	0x65, 0x20, 0x32, 0x30, 0x31, 0x34, 0x0a,
};

struct ssl_asn1_test ssl_asn1_tests[] = {
	{
		.session = {
			.cipher_id = 0x03000000L | 1,
			.ssl_version = TLS1_2_VERSION,
		},
		.asn1 = {
			0x30, 0x13, 0x02, 0x01, 0x01, 0x02, 0x02, 0x03,
			0x03, 0x04, 0x02, 0x00, 0x01, 0x04, 0x00, 0x04,
			0x00, 0xa4, 0x02, 0x04, 0x00,
		},
		.asn1_len = 21,
	},
	{
		.session = {
			.cipher_id = 0x03000000L | 1,
			.ssl_version = TLS1_2_VERSION,
			.master_key_length = 26,
			.session_id = "0123456789",
			.session_id_length = 10,
			.sid_ctx = "abcdefghijklmnopqrstuvwxyz",
			.sid_ctx_length = 26,
		},
		.asn1 = {
			0x30, 0x51, 0x02, 0x01, 0x01, 0x02, 0x02, 0x03,
			0x03, 0x04, 0x02, 0x00, 0x01, 0x04, 0x0a, 0x30,
			0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
			0x39, 0x04, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x1c, 0x04,
			0x1a, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
			0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
			0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
			0x78, 0x79, 0x7a,
		},
		.asn1_len = 83,
	},
	{
		.session = {
			.cipher_id = 0x03000000L | 1,
			.ssl_version = TLS1_2_VERSION,
			.master_key_length = 26,
			.session_id = "0123456789",
			.session_id_length = 10,
			.sid_ctx = "abcdefghijklmnopqrstuvwxyz",
			.sid_ctx_length = 26,
			.time = 1405266069,
			.timeout = 5,
			.verify_result = 42,
			.tlsext_hostname = "libressl.openbsd.org",
			.tlsext_tick_lifetime_hint = 0x7abbccdd,
			.tlsext_tick = tlsext_tick,
			.tlsext_ticklen = sizeof(tlsext_tick),
		},
		.peer_cert = 1,
		.asn1 = {
			0x30, 0x82, 0x02, 0xd1, 0x02, 0x01, 0x01, 0x02,
			0x02, 0x03, 0x03, 0x04, 0x02, 0x00, 0x01, 0x04,
			0x0a, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
			0x37, 0x38, 0x39, 0x04, 0x1a, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa1,
			0x06, 0x02, 0x04, 0x53, 0xc2, 0xa8, 0x95, 0xa2,
			0x03, 0x02, 0x01, 0x05, 0xa3, 0x82, 0x01, 0x75,
			0x30, 0x82, 0x01, 0x71, 0x30, 0x82, 0x01, 0x1b,
			0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x09, 0x00,
			0xf6, 0x21, 0x69, 0x92, 0x40, 0xbd, 0x4b, 0x94,
			0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
			0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30,
			0x14, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55,
			0x04, 0x0a, 0x0c, 0x09, 0x54, 0x65, 0x73, 0x74,
			0x20, 0x50, 0x65, 0x65, 0x72, 0x30, 0x1e, 0x17,
			0x0d, 0x31, 0x36, 0x31, 0x32, 0x32, 0x36, 0x31,
			0x34, 0x34, 0x37, 0x34, 0x37, 0x5a, 0x17, 0x0d,
			0x32, 0x36, 0x31, 0x32, 0x32, 0x34, 0x31, 0x34,
			0x34, 0x37, 0x34, 0x37, 0x5a, 0x30, 0x14, 0x31,
			0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x0a,
			0x0c, 0x09, 0x54, 0x65, 0x73, 0x74, 0x20, 0x50,
			0x65, 0x65, 0x72, 0x30, 0x5c, 0x30, 0x0d, 0x06,
			0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
			0x01, 0x01, 0x05, 0x00, 0x03, 0x4b, 0x00, 0x30,
			0x48, 0x02, 0x41, 0x00, 0xb2, 0x84, 0x07, 0x49,
			0xc2, 0x88, 0xc7, 0xbf, 0xfb, 0x8a, 0x38, 0xd8,
			0x7c, 0x31, 0xb9, 0x91, 0xd9, 0x4d, 0xbe, 0x54,
			0x5d, 0x47, 0x42, 0xeb, 0x27, 0x2d, 0xf4, 0x9f,
			0x1c, 0xfa, 0xa4, 0x25, 0xfb, 0xc3, 0xcc, 0xb5,
			0x89, 0xe3, 0x54, 0xc6, 0xed, 0x07, 0x17, 0x93,
			0x1d, 0xab, 0x20, 0x95, 0x6d, 0x00, 0x5a, 0xce,
			0x53, 0xdc, 0x8d, 0x74, 0x56, 0x09, 0x2c, 0x0f,
			0xe1, 0xb2, 0xb6, 0xe3, 0x02, 0x03, 0x01, 0x00,
			0x01, 0xa3, 0x50, 0x30, 0x4e, 0x30, 0x1d, 0x06,
			0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14,
			0xb7, 0x6d, 0x93, 0xb0, 0xed, 0xfb, 0xda, 0xa2,
			0xbb, 0x5d, 0xb1, 0xd1, 0x36, 0x4c, 0xf3, 0x2a,
			0x21, 0x15, 0xc5, 0x47, 0x30, 0x1f, 0x06, 0x03,
			0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80,
			0x14, 0xb7, 0x6d, 0x93, 0xb0, 0xed, 0xfb, 0xda,
			0xa2, 0xbb, 0x5d, 0xb1, 0xd1, 0x36, 0x4c, 0xf3,
			0x2a, 0x21, 0x15, 0xc5, 0x47, 0x30, 0x0c, 0x06,
			0x03, 0x55, 0x1d, 0x13, 0x04, 0x05, 0x30, 0x03,
			0x01, 0x01, 0xff, 0x30, 0x0d, 0x06, 0x09, 0x2a,
			0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05,
			0x05, 0x00, 0x03, 0x41, 0x00, 0x1e, 0xcc, 0x4d,
			0x4b, 0xea, 0xcd, 0x51, 0x96, 0xe8, 0xa5, 0xe0,
			0xcc, 0x85, 0x52, 0x2f, 0x88, 0xe7, 0xd4, 0x99,
			0xe9, 0x43, 0x8c, 0x9a, 0xd3, 0xe7, 0xa4, 0x5c,
			0x54, 0x9a, 0x05, 0x37, 0x71, 0x9c, 0xd5, 0xc5,
			0x7c, 0x9d, 0x00, 0x07, 0x9b, 0xd6, 0x89, 0xb3,
			0xbd, 0x6e, 0x92, 0xc0, 0xbe, 0x30, 0xdd, 0x38,
			0x3f, 0x38, 0x74, 0x5a, 0xa9, 0x98, 0x5f, 0xd5,
			0xd7, 0xae, 0x76, 0x0f, 0x72, 0xa4, 0x1c, 0x04,
			0x1a, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
			0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
			0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
			0x78, 0x79, 0x7a, 0xa5, 0x03, 0x02, 0x01, 0x2a,
			0xa6, 0x16, 0x04, 0x14, 0x6c, 0x69, 0x62, 0x72,
			0x65, 0x73, 0x73, 0x6c, 0x2e, 0x6f, 0x70, 0x65,
			0x6e, 0x62, 0x73, 0x64, 0x2e, 0x6f, 0x72, 0x67,
			0xa9, 0x06, 0x02, 0x04, 0x7a, 0xbb, 0xcc, 0xdd,
			0xaa, 0x81, 0xd2, 0x04, 0x81, 0xcf, 0x43, 0x56,
			0x45, 0x2d, 0x32, 0x30, 0x31, 0x34, 0x2d, 0x30,
			0x31, 0x36, 0x30, 0x3a, 0x20, 0x37, 0x74, 0x68,
			0x20, 0x41, 0x70, 0x72, 0x69, 0x6c, 0x20, 0x32,
			0x30, 0x31, 0x34, 0x0a, 0x43, 0x56, 0x45, 0x2d,
			0x32, 0x30, 0x31, 0x30, 0x2d, 0x35, 0x32, 0x39,
			0x38, 0x3a, 0x20, 0x38, 0x74, 0x68, 0x20, 0x41,
			0x70, 0x72, 0x69, 0x6c, 0x20, 0x32, 0x30, 0x31,
			0x34, 0x0a, 0x43, 0x56, 0x45, 0x2d, 0x32, 0x30,
			0x31, 0x34, 0x2d, 0x30, 0x31, 0x39, 0x38, 0x3a,
			0x20, 0x32, 0x31, 0x73, 0x74, 0x20, 0x41, 0x70,
			0x72, 0x69, 0x6c, 0x20, 0x32, 0x30, 0x31, 0x34,
			0x0a, 0x43, 0x56, 0x45, 0x2d, 0x32, 0x30, 0x31,
			0x34, 0x2d, 0x33, 0x34, 0x37, 0x30, 0x3a, 0x20,
			0x33, 0x30, 0x74, 0x68, 0x20, 0x4d, 0x61, 0x79,
			0x20, 0x32, 0x30, 0x31, 0x34, 0x0a, 0x43, 0x56,
			0x45, 0x2d, 0x32, 0x30, 0x31, 0x34, 0x2d, 0x30,
			0x31, 0x39, 0x35, 0x3a, 0x20, 0x35, 0x74, 0x68,
			0x20, 0x4a, 0x75, 0x6e, 0x65, 0x20, 0x32, 0x30,
			0x31, 0x34, 0x0a, 0x43, 0x56, 0x45, 0x2d, 0x32,
			0x30, 0x31, 0x34, 0x2d, 0x30, 0x32, 0x32, 0x31,
			0x3a, 0x20, 0x35, 0x74, 0x68, 0x20, 0x4a, 0x75,
			0x6e, 0x65, 0x20, 0x32, 0x30, 0x31, 0x34, 0x0a,
			0x43, 0x56, 0x45, 0x2d, 0x32, 0x30, 0x31, 0x34,
			0x2d, 0x30, 0x32, 0x32, 0x34, 0x3a, 0x20, 0x35,
			0x74, 0x68, 0x20, 0x4a, 0x75, 0x6e, 0x65, 0x20,
			0x32, 0x30, 0x31, 0x34, 0x0a,
		},
		.asn1_len = 725,
	},
	{
		.session = {
			.cipher_id = 0x03000000L | 1,
			.ssl_version = TLS1_2_VERSION,
			.timeout = -1,
		},
		.asn1 = {
			0x0,
		},
		.asn1_len = -1,
	},
	{
		.session = {
			.cipher_id = 0x03000000L | 1,
			.ssl_version = TLS1_2_VERSION,
			.time = -1,
		},
		.asn1 = {
			0x0,
		},
		.asn1_len = -1,
	},
};

#define N_SSL_ASN1_TESTS \
    (sizeof(ssl_asn1_tests) / sizeof(*ssl_asn1_tests))

static int
session_strcmp(const unsigned char *o1, const unsigned char *o2, size_t len)
{
	if (o1 == NULL && o2 == NULL)
		return (0);
	if (o1 == NULL || o2 == NULL)
		return (1);
	return memcmp(o1, o2, len);
}

static int
session_cmp(SSL_SESSION *s1, SSL_SESSION *s2)
{
	/* Compare the ASN.1 encoded values from two sessions. */
	if (s1->ssl_version != s2->ssl_version) {
		fprintf(stderr, "ssl_version differs: %i != %i\n",
		    s1->ssl_version, s2->ssl_version);
		return (1);
	}
	if (s1->cipher_id != s2->cipher_id) {
		fprintf(stderr, "cipher_id differs: %li != %li\n",
		    s1->cipher_id, s2->cipher_id);
		return (1);
	}

	if (s1->master_key_length != s2->master_key_length) {
		fprintf(stderr, "master_key_length differs: %i != %i\n",
		    s1->master_key_length, s2->master_key_length);
		return (1);
	}
	if (session_strcmp(s1->master_key, s2->master_key,
	    s1->master_key_length) != 0) {
		fprintf(stderr, "master_key differs\n");
		return (1);
	}

	if (s1->session_id_length != s2->session_id_length) {
		fprintf(stderr, "session_id_length differs: %i != %i\n",
		    s1->session_id_length, s2->session_id_length);
		return (1);
	}
	if (session_strcmp(s1->session_id, s2->session_id,
	    s1->session_id_length) != 0) {
		fprintf(stderr, "session_id differs\n");
		return (1);
	}

	if (s1->sid_ctx_length != s2->sid_ctx_length) {
		fprintf(stderr, "sid_ctx_length differs: %i != %i\n",
		    s1->sid_ctx_length, s2->sid_ctx_length);
		return (1);
	}
	if (session_strcmp(s1->sid_ctx, s2->sid_ctx,
	    s1->sid_ctx_length) != 0) {
		fprintf(stderr, "sid_ctx differs\n");
		return (1);
	}

	/* d2i_SSL_SESSION uses the current time if decoding a zero value. */
	if ((s1->time != s2->time) && s1->time != 0 && s2->time != 0) {
		fprintf(stderr, "time differs: %lli != %lli\n",
		    (long long)s1->time, (long long)s2->time);
		return (1);
	}
	/* d2i_SSL_SESSION uses a timeout of 3 if decoding a zero value. */
	if ((s1->timeout != s2->timeout) &&
	    s1->timeout != 3 && s2->timeout != 3) {
		fprintf(stderr, "timeout differs: %li != %li\n",
		    s1->timeout, s2->timeout);
		return (1);
	}

	/* Ensure that a certificate is or is not present in both. */
	if ((s1->peer != NULL || s2->peer != NULL) &&
	    (s1->peer == NULL || s2->peer == NULL ||
	     X509_cmp(s1->peer, s2->peer) != 0)) {
		fprintf(stderr, "peer differs\n");
		return (1);
	}
	
	if (s1->verify_result != s2->verify_result) {
		fprintf(stderr, "verify_result differs: %li != %li\n",
		    s1->verify_result, s2->verify_result);
		return (1);
	}

	if (session_strcmp(s1->tlsext_hostname, s2->tlsext_hostname,
	    (s1->tlsext_hostname ? strlen(s1->tlsext_hostname) : 0)) != 0) {
		fprintf(stderr, "sid_ctx differs\n");
		return (1);
	}
	if (s1->tlsext_tick_lifetime_hint != s2->tlsext_tick_lifetime_hint) {
		fprintf(stderr, "tlsext_tick_lifetime_hint differs: "
		    "%li != %li\n", s1->tlsext_tick_lifetime_hint,
		    s2->tlsext_tick_lifetime_hint);
		return (1);
	}
	if (s1->tlsext_ticklen != s2->tlsext_ticklen) {
		fprintf(stderr, "tlsext_ticklen differs: %zu != %zu\n",
		    s1->tlsext_ticklen, s2->tlsext_ticklen);
		return (1);
	}
	if (session_strcmp(s1->tlsext_tick, s2->tlsext_tick,
	    s1->tlsext_ticklen) != 0) {
		fprintf(stderr, "tlsext_tick differs\n");
		return (1);
	}

	return (0);
}

static int
do_ssl_asn1_test(int test_no, struct ssl_asn1_test *sat)
{
	SSL_SESSION session, *sp = NULL;
	unsigned char *ap, *asn1 = NULL;
	const unsigned char *pp;
	int i, len, rv = 1;

	if (sat->peer_cert)
		sat->session.peer = peer_cert;

	len = i2d_SSL_SESSION(&sat->session, NULL);
	if (len != sat->asn1_len) {
		fprintf(stderr, "FAIL: test %i returned ASN1 length %i, "
		    "want %i\n", test_no, len, sat->asn1_len);
		goto failed;
	}

	/* See if the test is expected to fail... */
	if (sat->asn1_len == -1)
		return (0);

	if ((asn1 = malloc(len)) == NULL)
		errx(1, "failed to allocate memory");

	ap = asn1;
	len = i2d_SSL_SESSION(&sat->session, &ap);

	/* Check the length again since the code path is different. */
	if (len != sat->asn1_len) {
		fprintf(stderr, "FAIL: test %i returned ASN1 length %i, "
		    "want %i\n", test_no, len, sat->asn1_len);
		goto failed;
	}
	/* ap should now point at the end of the buffer. */
	if (ap - asn1 != len) {
		fprintf(stderr, "FAIL: test %i pointer increment does not "
		    "match length (%i != %i)\n", test_no, (int)(ap - asn1), len);
		goto failed;
	}

	if (memcmp(asn1, &sat->asn1, len) != 0) {
		fprintf(stderr, "FAIL: test %i - encoding differs:\n", test_no);
		fprintf(stderr, "encoding:\n");
		for (i = 1; i <= len; i++) {
			fprintf(stderr, " 0x%02hhx,", asn1[i - 1]);
			if (i % 8 == 0)
				fprintf(stderr, "\n");
		}
		fprintf(stderr, "\n");
		fprintf(stderr, "test data:\n");
		for (i = 1; i <= sat->asn1_len; i++) {
			fprintf(stderr, " 0x%02hhx,", sat->asn1[i - 1]);
			if (i % 8 == 0)
				fprintf(stderr, "\n");
		}
		fprintf(stderr, "\n");
		goto failed;
	}

	sp = &session;
	memset(sp, 0, sizeof(*sp));
	pp = sat->asn1;

	if ((sp = d2i_SSL_SESSION(&sp, &pp, sat->asn1_len)) == NULL) {
		fprintf(stderr, "FAIL: test %i - decoding failed\n", test_no);
		goto failed;
	}

	if (session_cmp(sp, &sat->session) != 0) {
		fprintf(stderr, "FAIL: test %i - decoding differs\n", test_no);
		goto failed;
	}

	rv = 0;

failed:
	ERR_print_errors(BIO_new_fp(stderr, BIO_NOCLOSE));

	free(asn1);

	return (rv);
}

int
main(int argc, char **argv)
{
	BIO *bio = NULL;
	int failed = 0;
	size_t i;

	SSL_library_init();
	SSL_load_error_strings();

	bio = BIO_new_mem_buf(peer_cert_pem, -1);
	if (bio == NULL)
		errx(1, "failed to create bio");

	peer_cert = PEM_read_bio_X509(bio, NULL, NULL, NULL);
	if (peer_cert == NULL)
		errx(1, "failed to read peer cert");

	for (i = 0; i < N_SSL_ASN1_TESTS; i++)
		failed += do_ssl_asn1_test(i, &ssl_asn1_tests[i]);

	X509_free(peer_cert);
	BIO_free(bio);

	return (failed);
}
@


1.5
log
@Ensure that after an i2d_SSL_SESSION() call, the passed pointer now points
to the end of the buffer.
@
text
@d3 1
a3 1
 * Copyright (c) 2014 Joel Sing <jsing@@openbsd.org>
d30 14
d46 2
a47 1
	const unsigned char asn1[512];
d82 1
a82 1
		{
d86 1
a86 1
		{
d91 1
a91 1
		21,
d94 1
a94 1
		{
d103 1
a103 1
		{
d116 1
a116 1
		83,
d119 1
a119 1
		{
d133 1
a133 1
			.tlsext_ticklen = 207,
d135 3
a137 2
		{
			0x30, 0x82, 0x01, 0x58, 0x02, 0x01, 0x01, 0x02,
d145 67
a211 16
			0x03, 0x02, 0x01, 0x05, 0xa4, 0x1c, 0x04, 0x1a,
			0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
			0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,
			0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
			0x79, 0x7a, 0xa5, 0x03, 0x02, 0x01, 0x2a, 0xa6,
			0x16, 0x04, 0x14, 0x6c, 0x69, 0x62, 0x72, 0x65,
			0x73, 0x73, 0x6c, 0x2e, 0x6f, 0x70, 0x65, 0x6e,
			0x62, 0x73, 0x64, 0x2e, 0x6f, 0x72, 0x67, 0xa9,
			0x06, 0x02, 0x04, 0x7a, 0xbb, 0xcc, 0xdd, 0xaa,
			0x81, 0xd2, 0x04, 0x81, 0xcf, 0x43, 0x56, 0x45,
			0x2d, 0x32, 0x30, 0x31, 0x34, 0x2d, 0x30, 0x31,
			0x36, 0x30, 0x3a, 0x20, 0x37, 0x74, 0x68, 0x20,
			0x41, 0x70, 0x72, 0x69, 0x6c, 0x20, 0x32, 0x30,
			0x31, 0x34, 0x0a, 0x43, 0x56, 0x45, 0x2d, 0x32,
			0x30, 0x31, 0x30, 0x2d, 0x35, 0x32, 0x39, 0x38,
			0x3a, 0x20, 0x38, 0x74, 0x68, 0x20, 0x41, 0x70,
d214 10
a223 3
			0x34, 0x2d, 0x30, 0x31, 0x39, 0x38, 0x3a, 0x20,
			0x32, 0x31, 0x73, 0x74, 0x20, 0x41, 0x70, 0x72,
			0x69, 0x6c, 0x20, 0x32, 0x30, 0x31, 0x34, 0x0a,
d225 3
a227 14
			0x2d, 0x33, 0x34, 0x37, 0x30, 0x3a, 0x20, 0x33,
			0x30, 0x74, 0x68, 0x20, 0x4d, 0x61, 0x79, 0x20,
			0x32, 0x30, 0x31, 0x34, 0x0a, 0x43, 0x56, 0x45,
			0x2d, 0x32, 0x30, 0x31, 0x34, 0x2d, 0x30, 0x31,
			0x39, 0x35, 0x3a, 0x20, 0x35, 0x74, 0x68, 0x20,
			0x4a, 0x75, 0x6e, 0x65, 0x20, 0x32, 0x30, 0x31,
			0x34, 0x0a, 0x43, 0x56, 0x45, 0x2d, 0x32, 0x30,
			0x31, 0x34, 0x2d, 0x30, 0x32, 0x32, 0x31, 0x3a,
			0x20, 0x35, 0x74, 0x68, 0x20, 0x4a, 0x75, 0x6e,
			0x65, 0x20, 0x32, 0x30, 0x31, 0x34, 0x0a, 0x43,
			0x56, 0x45, 0x2d, 0x32, 0x30, 0x31, 0x34, 0x2d,
			0x30, 0x32, 0x32, 0x34, 0x3a, 0x20, 0x35, 0x74,
			0x68, 0x20, 0x4a, 0x75, 0x6e, 0x65, 0x20, 0x32,
			0x30, 0x31, 0x34, 0x0a,
d229 1
a229 1
		348,
d232 1
a232 1
		{
d237 1
a237 1
		{
d240 1
a240 1
		-1,
d243 1
a243 1
		{
d248 1
a248 1
		{
d251 1
a251 1
		-1,
d332 2
a333 1
	    (s1->peer == NULL || s2->peer == NULL)) {
d377 3
d397 1
a397 4
	/*
	 * Length *should* be the same, but check it again since the code
	 * path is different.
	 */
d456 1
d463 8
d473 3
@


1.4
log
@Ensure negative time/timeout are handled appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: asn1test.c,v 1.3 2014/12/07 20:00:13 bcook Exp $	*/
d208 1
a208 1
	/* Compare two sessions, from the perspective of ASN1. */
d323 1
a323 1
		
a328 5
	if ((ap - asn1) > len) {
		fprintf(stderr, "FAIL: test %i overflowed ticket buffer "
		    "(%i > %i)\n", test_no, (int)(ap - asn1), len);
		goto failed;
	}
d337 6
@


1.3
log
@remove duplicate initialization of .sid_ctx in test
@
text
@d1 1
a1 1
/*	$OpenBSD: asn1test.c,v 1.2 2014/07/16 17:38:19 miod Exp $	*/
d168 22
d320 4
@


1.2
log
@Fix tlsext_tick_lifetime_hint value in test #2 to make sure the
(tlsext_tick_lifetime_hint > 0) test also passes on 32-bit platforms
(tlsext_tick_lifetime_hint is a long).
@
text
@d1 1
a1 1
/*	$OpenBSD: asn1test.c,v 1.1 2014/07/13 16:03:54 jsing Exp $	*/
a81 1
			.sid_ctx = "abcdefghijklmnopqrstuvwxyz",
a106 1
			.sid_ctx = "abcdefghijklmnopqrstuvwxyz",
@


1.1
log
@Add a regress test for the ASN1 handling of SSL session tickets.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d118 1
a118 1
			.tlsext_tick_lifetime_hint = 0xaabbccdd,
d123 1
a123 1
			0x30, 0x82, 0x01, 0x59, 0x02, 0x01, 0x01, 0x02,
d139 8
a146 12
			0x07, 0x02, 0x05, 0x00, 0xaa, 0xbb, 0xcc, 0xdd,
			0xaa, 0x81, 0xd2, 0x04, 0x81, 0xcf, 0x43, 0x56,
			0x45, 0x2d, 0x32, 0x30, 0x31, 0x34, 0x2d, 0x30,
			0x31, 0x36, 0x30, 0x3a, 0x20, 0x37, 0x74, 0x68,
			0x20, 0x41, 0x70, 0x72, 0x69, 0x6c, 0x20, 0x32,
			0x30, 0x31, 0x34, 0x0a, 0x43, 0x56, 0x45, 0x2d,
			0x32, 0x30, 0x31, 0x30, 0x2d, 0x35, 0x32, 0x39,
			0x38, 0x3a, 0x20, 0x38, 0x74, 0x68, 0x20, 0x41,
			0x70, 0x72, 0x69, 0x6c, 0x20, 0x32, 0x30, 0x31,
			0x34, 0x0a, 0x43, 0x56, 0x45, 0x2d, 0x32, 0x30,
			0x31, 0x34, 0x2d, 0x30, 0x31, 0x39, 0x38, 0x3a,
			0x20, 0x32, 0x31, 0x73, 0x74, 0x20, 0x41, 0x70,
d149 3
a151 10
			0x34, 0x2d, 0x33, 0x34, 0x37, 0x30, 0x3a, 0x20,
			0x33, 0x30, 0x74, 0x68, 0x20, 0x4d, 0x61, 0x79,
			0x20, 0x32, 0x30, 0x31, 0x34, 0x0a, 0x43, 0x56,
			0x45, 0x2d, 0x32, 0x30, 0x31, 0x34, 0x2d, 0x30,
			0x31, 0x39, 0x35, 0x3a, 0x20, 0x35, 0x74, 0x68,
			0x20, 0x4a, 0x75, 0x6e, 0x65, 0x20, 0x32, 0x30,
			0x31, 0x34, 0x0a, 0x43, 0x56, 0x45, 0x2d, 0x32,
			0x30, 0x31, 0x34, 0x2d, 0x30, 0x32, 0x32, 0x31,
			0x3a, 0x20, 0x35, 0x74, 0x68, 0x20, 0x4a, 0x75,
			0x6e, 0x65, 0x20, 0x32, 0x30, 0x31, 0x34, 0x0a,
d153 14
a166 3
			0x2d, 0x30, 0x32, 0x32, 0x34, 0x3a, 0x20, 0x35,
			0x74, 0x68, 0x20, 0x4a, 0x75, 0x6e, 0x65, 0x20,
			0x32, 0x30, 0x31, 0x34, 0x0a,
d168 1
a168 1
		349,
@

