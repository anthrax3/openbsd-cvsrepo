head	1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.12
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.2
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.10
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.8
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.6
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.4
	OPENBSD_5_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.1
date	2013.11.03.00.20.24;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Add a second test, shortseek(), to make sure that seekdir() also works
correctly when moving the directory pointer by small distances.
This is currently failing, i will send an updated libc/gen patch
to fix this right afterwards.

Move the functions createfiles() and delfiles() to utils.{h,c} for reuse.
Minor cleanup in telldir.c.
@
text
@/*	$OpenBSD$	*/

/*	Written by Otto Moerbeek, 2006,  Public domain.	*/
/*	Modified by Ingo Schwarze, 2013,  Public domain. */

#include <sys/types.h>
#include <dirent.h>
#include <err.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>

#include "utils.h"

#define NFILES 5

static void
shortloop(DIR *dp, int iend, int iback)
{
	struct dirent *f;
	char fend[PATH_MAX], fback[PATH_MAX];
	long pos, t, remember = -1;
	int i;

	rewinddir(dp);
	snprintf(fend, sizeof fend, "%d", iend);
	snprintf(fback, sizeof fback, "%d", iback);

	/* Scan to iend, remember where iback is. */

	for (;;) {
		pos = telldir(dp);
		f = readdir(dp);
		if (f == NULL)
			errx(1, "file %s not found", fend);
		if (strcmp(fback, f->d_name) == 0)
			remember = pos;
		if (strcmp(fend, f->d_name) == 0)
			break;
	}
	if (remember == -1)
		errx(1, "file %s not found", fback);

	/* Go back to iback, checking seekdir, telldir and readdir. */

	seekdir(dp, remember);
	if ((t = telldir(dp)) != remember)
		errx(1, "tell after seek %s %ld != %ld", fback, t, remember);
	if ((t = telldir(dp)) != remember)
		errx(1, "tell after tell %s %ld != %ld", fback, t, remember);
	f = readdir(dp);
	if (f == NULL)
		errx(1, "readdir %s at %ld", fback, remember);

	if (strcmp(f->d_name, fback))
		errx(1, "name mismatch: %s != %s", f->d_name, fback);

	/* Check that readdir can iterate the remaining files. */

	for (i = iback + 1; i < NFILES; i++) {
		f = readdir(dp);
		if (f == NULL)
			errx(1, "readdir %i failed", i);
	}

	/* Check that readdir stops at the right place. */

	f = readdir(dp);
	if (f != NULL)
		errx(1, "readdir %i returned %s", NFILES, f->d_name);
}

void
shortseek(void)
{
	DIR *dp;
	int iend, iback;

	createfiles(NFILES);

	dp = opendir("d");
	if (dp == NULL)
		err(1, "shortseek: opendir");

	for (iend = 0; iend < NFILES; iend++)
		for (iback = 0; iback <= iend; iback++)
			shortloop(dp, iend, iback);

	closedir(dp);
	delfiles();
}
@
