head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.26
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.24
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.14
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.22
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.20
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.18
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.16
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.12
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.10
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.8
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4;
locks; strict;
comment	@ * @;


1.4
date	2010.09.18.20.29.15;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2010.09.18.17.24.10;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.18.12.46.44;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.17.19.51.38;	author millert;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Add cvs tag, author name and year
@
text
@/*	$OpenBSD$	*/

/*
 * Public domain, 2010, Todd C. Miller <Todd.Miller@@courtesan.com>
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static struct test_vector {
	double d;
	int ndig;
	char *expect;
} test_vectors[] = {
	/* adapted from perl's Configure test */
	{ 0.1, 8, "0.1" },
	{ 0.01, 8, "0.01" },
	{ 0.001, 8, "0.001" },
	{ 0.0001, 8, "0.0001" },
	{ 0.00009, 8, "9e-05" },
	{ 1.0, 8, "1" },
	{ 1.1, 8, "1.1" },
	{ 1.01, 8, "1.01" },
	{ 1.001, 8, "1.001" },
	{ 1.0001, 8, "1.0001" },
	{ 1.00001, 8, "1.00001" },
	{ 1.000001, 8, "1.000001" },
	{ 0.0, 8, "0" },
	{ -1.0, 8, "-1" },
	{ 100000.0, 8, "100000" },
	{ -100000.0, 8, "-100000" },
	{ 123.456, 8, "123.456" },
	{ 1e34, 8, "1e+34" },
	/* adapted from emx */
	{ 0.0, -1, "0" },
	{ 0.0, 0, "0" },
	{ 0.0, 1, "0" },
	{ 0.0, 2, "0" },
	{ 1.0, -1, "1" },
	{ 1.0, 0, "1" },
	{ 1.0, 2, "1" },
	{ 1.0, 10, "1" },
	{ 1.236, -1, "1.236" },
	{ 1.236, 0, "1" },
	{ 1.236, 1, "1" },
	{ 1.236, 2, "1.2" },
	{ 1.236, 3, "1.24" },
	{ 1.236, 4, "1.236" },
	{ 1.236, 5, "1.236" },
	{ 1.236, 6, "1.236" },
	{ 12.36, -1, "12.36" },
	{ 12.36, 0, "1e+01" },
	{ 12.36, 1, "1e+01" },
	{ 12.36, 2, "12" },
	{ 12.36, 3, "12.4" },
	{ 12.36, 4, "12.36" },
	{ 12.36, 5, "12.36" },
	{ 12.36, 6, "12.36" },
	{ 123.6, -1, "123.6" },
	{ 123.6, 0, "1e+02" },
	{ 123.6, 1, "1e+02" },
	{ 123.6, 2, "1.2e+02" },
	{ 123.6, 3, "124" },
	{ 123.6, 4, "123.6" },
	{ 123.6, 5, "123.6" },
	{ 123.6, 6, "123.6" },
	{ 1236.0, -1, "1236" },
	{ 1236.0, 0, "1e+03" },
	{ 1236.0, 1, "1e+03" },
	{ 1236.0, 2, "1.2e+03" },
	{ 1236.0, 3, "1.24e+03" },
	{ 1236.0, 4, "1236" },
	{ 1236.0, 5, "1236" },
	{ 1236.0, 6, "1236" },
	{ 1e100, 10, "1e+100" },
	{ 1e100, 20, "1.0000000000000000159e+100" },
	{ 0.01236, -1, "0.01236" },
	{ 0.01236, 0, "0.01" },
	{ 0.01236, 1, "0.01" },
	{ 0.01236, 2, "0.012" },
	{ 0.01236, 3, "0.0124" },
	{ 0.01236, 4, "0.01236" },
	{ 1e-100, 20, "1.00000000000000002e-100" },
	{ 1e-100, -1, "1e-100" },
	{ -1.2, 5, "-1.2" },
	{ -0.03, 5, "-0.03" },
	{ 0.1, 1, "0.1" },
	{ 0.1, 0, "0.1" },
	{ 0.099999, 10, "0.099999" },
	{ 0.99999, 10, "0.99999" },
};

#define NTESTVEC (sizeof(test_vectors) / sizeof(test_vectors[0]))

static int
dotest(struct test_vector *tv)
{
	char buf[256], *got;

	got = gcvt(tv->d, tv->ndig, buf);
	if (strcmp(tv->expect, got) != 0) {
		fprintf(stderr, "%g @@ %d: expected %s, got %s\n",
		    tv->d, tv->ndig, tv->expect, got);
		return 1;
	}
	return 0;
}

int
main(int argc, char *argv[])
{
	int i, failures = 0;

	for (i = 0; i < NTESTVEC; i++) {
		failures += dotest(&test_vectors[i]);
	}

	return failures;
}
@


1.3
log
@Test default precision when ndigit is negative.
@
text
@d1 5
a5 1
/* Public domain */
@


1.2
log
@Add more test vectors.
@
text
@d40 1
d48 1
d56 1
d64 1
d74 1
d81 1
@


1.1
log
@Add gcvt() regress with test vectors derived from perl regress.
Does not currently pass, which is why perl can't use it to format
doubles.
@
text
@d12 1
d31 51
a81 1
	{ 0.0, 0, NULL }
d84 2
d89 1
a89 1
	char buf[64];
d91 4
a94 3
	gcvt(tv->d, tv->ndig, buf);
	if (strcmp(tv->expect, buf) != 0) {
		fprintf(stderr, "gcvt: expected %s, got %s\n", tv->expect, buf);
d105 1
a105 1
	for (i = 0; test_vectors[i].expect != NULL; i++) {
@

