head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.14
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.12
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.8
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.3.0.8
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.14
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.12
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.10
	OPENBSD_5_0:1.2.0.8
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.6
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.4
date	2014.09.27.06.28.45;	author doug;	state Exp;
branches;
next	1.3;
commitid	f4Emp3aOD3XoUoYk;

1.3
date	2013.03.12.15.01.19;	author guenther;	state Exp;
branches;
next	1.2;

1.2
date	2010.02.11.16.39.05;	author guenther;	state Exp;
branches;
next	1.1;

1.1
date	2010.02.11.07.35.38;	author guenther;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Fix mmap() calls that check for a result other than MAP_FAILED.

ok tedu@@
@
text
@/*
 * Copyright (c) 2010  Philip Guenther <guenther@@openbsd.org>
 *
 * Public domain.
 *
 * Verify that mkstemp() and mkstemps() doesn't overrun or underrun
 * the template buffer and that it can generate names that don't
 * contain any X's
 */

#include <sys/param.h>
#include <sys/mman.h>
#include <sys/stat.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define MAX_TEMPLATE_LEN	10
#define MAX_TRIES		100
#define MIN_Xs			6

#define SUFFIX	".suff"
#define SLEN	(sizeof SUFFIX - 1)

long pg;

/*
 * verify that a path generated by mkstemp() or mkstemp() looks like a
 * reasonable expansion of the template and matches the fd.  Returns true
 * if all the X's were replaced with non-X's
 */
int
check(int fd, char const *path, char const *prefix, size_t plen,
    char const *suffix, size_t slen, int tlen)
{
	struct stat sb, fsb;
	char const *p;

	if (tlen < MIN_Xs) {
		if (fd >= 0)
			errx(1, "mkstemp(%s) succeed with too few Xs", path);
		if (errno != EINVAL)
			err(1, "mkstemp(%s) failed with wrong errno", path);
		return 1;
	}
	if (fd < 0)
		err(1, "mkstemp(%s)", path);
	if (stat(path, &sb))
		err(1, "stat(%s)", path);
	if (fstat(fd, &fsb))
		err(1, "fstat(%d==%s)", fd, path);
	if (sb.st_dev != fsb.st_dev || sb.st_ino != fsb.st_ino)
		errx(1, "stat mismatch");
	close(fd);
	if (memcmp(path, prefix, plen) != 0)
		errx(1, "prefix changed!  %s vs %s", prefix, path);
	if (memcmp(path + plen + tlen, suffix, slen + 1) != 0)
		errx(1, "suffix changed!  %s vs %s", suffix, path);
	for (p = path + plen; p < path + plen + tlen; p++)
		if (*p == '\0')
			errx(1, "unexpected truncation");
		else if (*p == 'X')
			return 0;
	return 1;
}


void
try_mkstemp(char *p, char const *prefix, int len)
{
	char *q;
	size_t plen = strlen(prefix);
	int tries, fd;

	for (tries = 0; tries < MAX_TRIES; tries++) {
		memcpy(p, prefix, plen);
		memset(p + plen, 'X', len);
		p[plen + len] = '\0';
		fd = mkstemp(p);
		if (check(fd, p, prefix, plen, "", 0, len))
			return;
	}
	errx(1, "exceeded MAX_TRIES");
}

void
try_mkstemps(char *p, char const *prefix, int len, char const *suffix)
{
	char *q;
	size_t plen = strlen(prefix);
	size_t slen = strlen(suffix);
	int tries, fd;

	for (tries = 0; tries < MAX_TRIES; tries++) {
		memcpy(p, prefix, plen);
		memset(p + plen, 'X', len);
		memcpy(p + plen + len, suffix, slen + 1);
		fd = mkstemps(p, slen);
		if (check(fd, p, prefix, plen, suffix, slen, len))
			return;
	}
	errx(1, "exceeded MAX_TRIES");
}

int
main(void)
{
	struct stat sb, fsb;
	char cwd[MAXPATHLEN + 1];
	char *p;
	size_t clen;
	int i;

	pg = sysconf(_SC_PAGESIZE);
	if (getcwd(cwd, sizeof cwd - 1) == NULL)
		err(1, "getcwd");
	clen = strlen(cwd);
	cwd[clen++] = '/';
	cwd[clen] = '\0';
	p = mmap(NULL, pg * 3, PROT_READ | PROT_WRITE, MAP_ANON, -1, 0);
	if (p == MAP_FAILED)
		err(1, "mmap");
	if (mprotect(p, pg, PROT_NONE) || mprotect(p + pg * 2, pg, PROT_NONE))
		err(1, "mprotect");
	p += pg;

	i = MAX_TEMPLATE_LEN + 1;
	while (i-- > 0) {
		/* try first at the start of a page, no prefix */
		try_mkstemp(p, "", i);
		/* now at the end of the page, no prefix */
		try_mkstemp(p + pg - i - 1, "", i);
		/* start of the page, prefixed with the cwd */
		try_mkstemp(p, cwd, i);
		/* how about at the end of the page, prefixed with cwd? */
		try_mkstemp(p + pg - clen - i - 1, cwd, i);

		/* again, with mkstemps() and an empty suffix */
		/* try first at the start of a page, no prefix */
		try_mkstemps(p, "", i, "");
		/* now at the end of the page, no prefix */
		try_mkstemps(p + pg - i - 1, "", i, "");
		/* start of the page, prefixed with the cwd */
		try_mkstemps(p, cwd, i, "");
		/* how about at the end of the page, prefixed with cwd? */
		try_mkstemps(p + pg - clen - i - 1, cwd, i, "");

		/* mkstemps() and a non-empty suffix */
		/* try first at the start of a page, no prefix */
		try_mkstemps(p, "", i, SUFFIX);
		/* now at the end of the page, no prefix */
		try_mkstemps(p + pg - i - SLEN - 1, "", i, SUFFIX);
		/* start of the page, prefixed with the cwd */
		try_mkstemps(p, cwd, i, SUFFIX);
		/* how about at the end of the page, prefixed with cwd? */
		try_mkstemps(p + pg - clen - i - SLEN - 1, cwd, i, SUFFIX);

	}

	return 0;
}
@


1.3
log
@Add check that mkstemp() fails with EINVAL if the string has fewer than
6 Xs
@
text
@d125 1
a125 1
	if (p == NULL)
@


1.2
log
@Test mkstemps() too
@
text
@d12 2
d16 1
a19 2
#include <sys/mman.h>
#include <sys/stat.h>
d24 1
d43 7
d51 1
a51 1
		err(1, "mkstemp");
d132 1
a132 1
	while (i-- > 1) {
@


1.1
log
@Add a regression suite for mkstemp(), verifying that it neither overruns
no underruns the supplied template buffer, that it can generate names that
don't contain any X's, and that all open() calls that pass O_CREAT also
pass O_EXCL
@
text
@d6 3
a8 2
 * Verify that mkstemp() doesn't overrun or underrun the template buffer
 * and that it can generate names that don't contain any X's
d24 3
d29 34
d64 1
a64 1
try(char *p, const char *prefix, int len)
a65 1
	struct stat sb, fsb;
d75 21
a95 18
		if (fd < 0)
			err(1, "mkstemp");
		if (stat(p, &sb))
			err(1, "stat(%s)", p);
		if (fstat(fd, &fsb))
			err(1, "fstat(%d==%s)", fd, p);
		if (sb.st_dev != fsb.st_dev || sb.st_ino != fsb.st_ino)
			errx(1, "stat mismatch");
		close(fd);
		for (q = p + plen; *q != 'X'; q++) {
			if (*q == '\0') {
				if (q != p + plen + len)
					errx(1, "unexpected truncation");
				return;
			}
		}
		if (q >= p + plen + len)
			errx(1, "overrun?");
d125 1
a125 1
		try(p, "", i);
d127 1
a127 1
		try(p + pg - i - 1, "", i);
d129 1
a129 1
		try(p, cwd, i);
d131 22
a152 1
		try(p + pg - i - 1 - clen, cwd, i);
@

