head	1.2;
access;
symbols;
locks; strict;
comment	@ * @;


1.2
date	2017.08.15.23.46.51;	author schwarze;	state Exp;
branches;
next	1.1;
commitid	PwLhyfuMtfuNS4uj;

1.1
date	2017.08.10.14.45.42;	author schwarze;	state Exp;
branches;
next	;
commitid	1O11P33oKR17iQPf;


desc
@@


1.2
log
@refactor in preparation for testing more functions; no functional change
@
text
@/* $OpenBSD: uselocale.c,v 1.1 2017/08/10 14:45:42 schwarze Exp $ */
/*
 * Copyright (c) 2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <err.h>
#include <errno.h>
#include <locale.h>
#include <pthread.h>
#include <stdlib.h>
#include <string.h>

/* Keep in sync with /usr/src/lib/libc/locale/rune.h. */
#define	_LOCALE_NONE	 (locale_t)0
#define	_LOCALE_C	 (locale_t)1
#define	_LOCALE_UTF8	 (locale_t)2
#define	_LOCALE_BAD	 (locale_t)3

/* Options for switch_thread() below. */
#define	SWITCH_SIGNAL	 1	/* Call pthread_cond_signal(3). */
#define	SWITCH_WAIT	 2	/* Call pthread_cond_timedwait(3). */

/* Options for TESTFUNC(). */
#define	TOPT_ERR	 (1 << 0)
#define	TOPT_STR	 (1 << 1)

/*
 * Generate one test function for a specific interface.
 * Fn =		function name
 * Ft =		function return type
 * FUNCPARA =	function parameter list with types and names
 * FUNCARGS =	function argument list, names only, no types
 * Af =		format string to print the arguments
 * Rf =		format string to print the return value
 * Op =		options for the test function, see above
 * line =	source code line number in this test file
 * ee =		expected error number
 * er =		expected return value
 * ar =		actual return value
 * errno =	actual error number (global)
 */
#define	TESTFUNC(Fn, Ft, Af, Rf, Op)					\
static void								\
_test_##Fn(int line, int ee, Ft er, FUNCPARA)				\
{									\
	Ft ar;								\
	errno = 0;							\
	ar = Fn(FUNCARGS);						\
	if (Op & TOPT_STR) {						\
		if (er == (Ft)NULL)					\
			er = (Ft)"NULL";				\
		if (ar == (Ft)NULL)					\
			ar = (Ft)"NULL";				\
	}								\
	if (Op & TOPT_STR ? strcmp((const char *)er, (const char *)ar)	\
	    : ar != er)							\
		errx(1, "[%d] %s(" Af ")=" Rf " [exp: " Rf "]",		\
		    line, #Fn, FUNCARGS, ar, er);			\
	if (Op & TOPT_ERR && errno != ee)				\
		errx(1, "[%d] %s(" Af ") errno=%d [exp: %d]",		\
		    line, #Fn, FUNCARGS, errno, ee);			\
}

/*
 * Test functions for all tested interfaces.
 */
#define	FUNCPARA	int mask, const char *locname
#define	FUNCARGS	mask, locname, _LOCALE_NONE
TESTFUNC(newlocale, locale_t, "%d, %s, %p", "%p", TOPT_ERR)

#define	FUNCPARA	locale_t locale
#define	FUNCARGS	locale
TESTFUNC(duplocale, locale_t, "%p", "%p", TOPT_ERR)
TESTFUNC(uselocale, locale_t, "%p", "%p", TOPT_ERR)

#define	FUNCPARA	int category, char *locname
#define	FUNCARGS	category, locname
TESTFUNC(setlocale, const char *, "%d, %s", "%s", TOPT_STR)

static void
_test_MB_CUR_MAX(int line, int ee, size_t ar)
{
	if (MB_CUR_MAX != ar)
		errx(1, "[%d] MB_CUR_MAX=%zd [exp: %zd]",
		    line, MB_CUR_MAX, ar);
}

/*
 * Test macros:
 * TEST_R(funcname, er, arguments) if you expect errno == 0.
 * TEST_ER(funcname, ee, er, arguments) otherwise.
 */
#define	TEST_R(Fn, ...)		_test_##Fn(__LINE__, 0, __VA_ARGS__)
#define	TEST_ER(Fn, ...)	_test_##Fn(__LINE__, __VA_ARGS__)

/*
 * SWITCH_SIGNAL wakes the other thread.
 * SWITCH_WAIT goes to sleep.
 * Both can be combined.
 * The step argument is used for error reporting only.
 */
static void
switch_thread(int step, int flags)
{
	static pthread_mutexattr_t	 ma;
	static struct timespec		 t;
	static pthread_cond_t		*c;
	static pthread_mutex_t		*m;
	int				 irc;

	if (m == NULL) {
		if ((m = malloc(sizeof(*m))) == NULL)
			err(1, NULL);
		if ((irc = pthread_mutexattr_init(&ma)) != 0)
			errc(1, irc, "pthread_mutexattr_init");
		if ((irc = pthread_mutexattr_settype(&ma,
		    PTHREAD_MUTEX_STRICT_NP)) != 0)
			errc(1, irc, "pthread_mutexattr_settype");
		if ((irc = pthread_mutex_init(m, &ma)) != 0)
			errc(1, irc, "pthread_mutex_init");
	}
	if (c == NULL) {
		if ((c = malloc(sizeof(*c))) == NULL)
			err(1, NULL);
		if ((irc = pthread_cond_init(c, NULL)) != 0)
			errc(1, irc, "pthread_cond_init");
	}
	if (flags & SWITCH_SIGNAL) {
		if ((irc = pthread_cond_signal(c)) != 0)
			errc(1, irc, "pthread_cond_signal(%d)", step);
	}
	if (flags & SWITCH_WAIT) {
		if ((irc = pthread_mutex_trylock(m)) != 0)
			errc(1, irc, "pthread_mutex_trylock(%d)", step);
		t.tv_sec = time(NULL) + 2;
		if ((irc = pthread_cond_timedwait(c, m, &t)) != 0)
			errc(1, irc, "pthread_cond_timedwait(%d)", step);
		if ((irc = pthread_mutex_unlock(m)) != 0)
			errc(1, irc, "pthread_mutex_unlock(%d)", step);
	}
}

static void *
child_func(void *arg)
{
	/* Test invalid newlocale(3) arguments. */
	TEST_ER(newlocale, EINVAL, _LOCALE_NONE, LC_CTYPE_MASK, NULL);
	TEST_R(MB_CUR_MAX, 1);
	TEST_ER(newlocale, EINVAL, _LOCALE_NONE, LC_ALL_MASK + 1, "C.UTF-8");
	TEST_R(MB_CUR_MAX, 1);
	TEST_ER(newlocale, ENOENT, _LOCALE_NONE, LC_COLLATE_MASK, "C.INV");
	TEST_R(MB_CUR_MAX, 1);
	setenv("LC_TIME", "C.INV", 1);
	TEST_ER(newlocale, ENOENT, _LOCALE_NONE, LC_TIME_MASK, "");
	unsetenv("LC_TIME");
	TEST_R(MB_CUR_MAX, 1);
	setenv("LC_CTYPE", "C.INV", 1);
	TEST_ER(newlocale, ENOENT, _LOCALE_NONE, LC_CTYPE_MASK, "");
	TEST_R(MB_CUR_MAX, 1);

	/* Test duplocale(3). */
	TEST_ER(duplocale, EINVAL, _LOCALE_NONE, _LOCALE_UTF8);
	TEST_R(duplocale, _LOCALE_C, _LOCALE_C);
	TEST_R(duplocale, _LOCALE_C, LC_GLOBAL_LOCALE);

	/* Test premature UTF-8 uselocale(3). */
	TEST_ER(uselocale, EINVAL, _LOCALE_NONE, _LOCALE_UTF8);
	TEST_R(MB_CUR_MAX, 1);
	TEST_R(uselocale, LC_GLOBAL_LOCALE, _LOCALE_NONE);

	/* Test UTF-8 initialization. */
	setenv("LC_CTYPE", "C.UTF-8", 1);
	TEST_R(newlocale, _LOCALE_UTF8, LC_CTYPE_MASK, "");
	unsetenv("LC_CTYPE");
	TEST_R(MB_CUR_MAX, 1);
	TEST_R(duplocale, _LOCALE_UTF8, _LOCALE_UTF8);

	/* Test invalid uselocale(3) argument. */
	TEST_ER(uselocale, EINVAL, _LOCALE_NONE, _LOCALE_BAD);
	TEST_R(MB_CUR_MAX, 1);
	TEST_R(uselocale, LC_GLOBAL_LOCALE, _LOCALE_NONE);

	/* Test switching the thread locale. */
	TEST_R(uselocale, LC_GLOBAL_LOCALE, _LOCALE_UTF8);
	TEST_R(MB_CUR_MAX, 4);
	TEST_R(uselocale, _LOCALE_UTF8, _LOCALE_NONE);

	/* Test non-ctype newlocale(3). */
	TEST_R(newlocale, _LOCALE_C, LC_MESSAGES_MASK, "en_US.UTF-8");

	/* Temporarily switch to the main thread. */
	switch_thread(2, SWITCH_SIGNAL | SWITCH_WAIT);

	/* Test displaying the global locale while a local one is set. */
	TEST_R(setlocale, "C/C.UTF-8/C/C/C/C", LC_ALL, NULL);

	/* Test switching the thread locale back. */
	TEST_R(MB_CUR_MAX, 4);
	TEST_R(duplocale, _LOCALE_UTF8, LC_GLOBAL_LOCALE);
	TEST_R(uselocale, _LOCALE_UTF8, _LOCALE_C);
	TEST_R(MB_CUR_MAX, 1);
	TEST_R(uselocale, _LOCALE_C, _LOCALE_NONE);

	/* Test switching back to the global locale. */
	TEST_R(uselocale, _LOCALE_C, LC_GLOBAL_LOCALE);
	TEST_R(MB_CUR_MAX, 4);
	TEST_R(uselocale, LC_GLOBAL_LOCALE, _LOCALE_NONE);

	/* Hand control back to the main thread. */
	switch_thread(4, SWITCH_SIGNAL);
	return NULL;
}

int
main(void)
{
	pthread_t	 child_thread;
	int		 irc;

	/* Initialize environment. */
	unsetenv("LC_ALL");
	unsetenv("LC_COLLATE");
	unsetenv("LC_CTYPE");
	unsetenv("LC_MONETARY");
	unsetenv("LC_NUMERIC");
	unsetenv("LC_TIME");
	unsetenv("LC_MESSAGES");
	unsetenv("LANG");

	/* First let the child do some tests. */
	if ((irc = pthread_create(&child_thread, NULL, child_func, NULL)) != 0)
		errc(1, irc, "pthread_create");
	switch_thread(1, SWITCH_WAIT);

	/* Check that the global locale is undisturbed. */
	TEST_R(setlocale, "C", LC_ALL, NULL);
	TEST_R(MB_CUR_MAX, 1);

	/* Test setting the globale locale. */
	TEST_R(setlocale, "C.UTF-8", LC_CTYPE, "C.UTF-8");
	TEST_R(MB_CUR_MAX, 4);
	TEST_R(uselocale, LC_GLOBAL_LOCALE, _LOCALE_NONE);

	/* Let the child do some more tests, then clean up. */
	switch_thread(3, SWITCH_SIGNAL);
	if ((irc = pthread_join(child_thread, NULL)) != 0)
		errc(1, irc, "pthread_join");
	return 0;
}
@


1.1
log
@first draft of tests for newlocale(3), duplocale(3), uselocale(3)
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a3 1
 * Copyright (c) 2015 Sebastien Marie <semarie@@openbsd.org>
a23 1
#include <time.h>
d25 1
d27 11
a37 6
#define _LOCALE_C	 (locale_t)1
#define _LOCALE_UTF8	 (locale_t)2
#define _LOCALE_BAD	 (locale_t)3

#define	SWITCH_SIGNAL	 1
#define SWITCH_WAIT	 2
d40 13
a52 1
 * test helpers for __LINE__
d54 20
a73 21
#define test_newlocale(_e, _ee, _m, _l) \
	_test_newlocale(_e, _ee, _m, _l, __LINE__)
#define	test_duplocale(_e, _ee, _l) _test_duplocale(_e, _ee, _l, __LINE__)
#define	test_uselocale(_e, _ee, _l) _test_uselocale(_e, _ee, _l, __LINE__)
#define test_setlocale(_e, _c, _l) _test_setlocale(_e, _c, _l, __LINE__)
#define test_MB_CUR_MAX(_e) _test_MB_CUR_MAX(_e, __LINE__)


static void
_test_newlocale(locale_t expected, int exp_err,
    int mask, const char *locname, int line)
{
	locale_t result = newlocale(mask, locname, _LOCALE_NONE);

	if (result != expected)
		errx(1, "[%d] newlocale(%d, \"%s\")=\"%d\" [expected: \"%d\"]",
		    line, mask, locname, (int)result, (int)expected);
	if (errno != exp_err)
		errx(1, "[%d] newlocale(%d, \"%s\") errno=\"%d\" [expected:"
		    " \"%d\"]", line, mask, locname, errno, exp_err);
	errno = 0;
d76 6
a81 4
static void
_test_duplocale(locale_t expected, int exp_err, locale_t oldloc, int line)
{
	locale_t result = duplocale(oldloc);
d83 4
a86 8
	if (result != expected)
		errx(1, "[%d] duplocale(%d)=\"%d\" [expected: \"%d\"]",
		    line, (int)oldloc, (int)result, (int)expected);
	if (errno != exp_err)
		errx(1, "[%d] duplocale(%d) errno=\"%d\" [expected:"
		    " \"%d\"]", line, (int)oldloc, errno, exp_err);
	errno = 0;
}
d88 3
a90 13
static void
_test_uselocale(locale_t expected, int exp_err, locale_t newloc, int line)
{
	locale_t result = uselocale(newloc);

	if (result != expected)
		errx(1, "[%d] uselocale(%d)=\"%d\" [expected: \"%d\"]",
		    line, (int)newloc, (int)result, (int)expected);
	if (errno != exp_err)
		errx(1, "[%d] uselocale(%d) errno=\"%d\" [expected:"
		    " \"%d\"]", line, (int)newloc, errno, exp_err);
	errno = 0;
}
d93 1
a93 1
_test_setlocale(const char *expected, int category, char *locale, int line)
d95 3
a97 10
	const char *result = setlocale(category, locale);

	if (expected == NULL)
		expected = "(null)";
	if (result == NULL)
		result = "(null)";
	if (strcmp(expected, result) != 0)
		errx(1, "[%d] setlocale(%d, \"%s\")=\"%s\" [expected: \"%s\"]",
		    line, category, locale, result, expected);
	errno = 0;
d100 7
a106 7
static void
_test_MB_CUR_MAX(size_t expected, int line)
{
	if (MB_CUR_MAX != expected)
		errx(1, "[%d] MB_CUR_MAX=%ld [expected %ld]", 
			line, MB_CUR_MAX, expected);
}
d108 6
d159 6
a164 6
	test_newlocale(_LOCALE_NONE, EINVAL, LC_CTYPE_MASK, NULL);
	test_MB_CUR_MAX(1);
	test_newlocale(_LOCALE_NONE, EINVAL, LC_ALL_MASK + 1, "C.UTF-8");
	test_MB_CUR_MAX(1);
	test_newlocale(_LOCALE_NONE, ENOENT, LC_COLLATE_MASK, "C.INV");
	test_MB_CUR_MAX(1);
d166 1
a166 1
	test_newlocale(_LOCALE_NONE, ENOENT, LC_TIME_MASK, "");
d168 1
a168 1
	test_MB_CUR_MAX(1);
d170 2
a171 2
	test_newlocale(_LOCALE_NONE, ENOENT, LC_CTYPE_MASK, "");
	test_MB_CUR_MAX(1);
d174 3
a176 3
	test_duplocale(_LOCALE_NONE, EINVAL, _LOCALE_UTF8);
	test_duplocale(_LOCALE_C, 0, _LOCALE_C);
	test_duplocale(_LOCALE_C, 0, LC_GLOBAL_LOCALE);
d179 3
a181 3
	test_uselocale(_LOCALE_NONE, EINVAL, _LOCALE_UTF8);
	test_MB_CUR_MAX(1);
	test_uselocale(LC_GLOBAL_LOCALE, 0, _LOCALE_NONE);
d185 1
a185 1
	test_newlocale(_LOCALE_UTF8, 0, LC_CTYPE_MASK, "");
d187 2
a188 2
	test_MB_CUR_MAX(1);
	test_duplocale(_LOCALE_UTF8, 0, _LOCALE_UTF8);
d191 3
a193 3
	test_uselocale(_LOCALE_NONE, EINVAL, _LOCALE_BAD);
	test_MB_CUR_MAX(1);
	test_uselocale(LC_GLOBAL_LOCALE, 0, _LOCALE_NONE);
d196 3
a198 3
	test_uselocale(LC_GLOBAL_LOCALE, 0, _LOCALE_UTF8);
	test_MB_CUR_MAX(4);
	test_uselocale(_LOCALE_UTF8, 0, _LOCALE_NONE);
d201 1
a201 1
	test_newlocale(_LOCALE_C, 0, LC_MESSAGES_MASK, "en_US.UTF-8");
d207 1
a207 1
	test_setlocale("C/C.UTF-8/C/C/C/C", LC_ALL, NULL);
d210 5
a214 5
	test_MB_CUR_MAX(4);
	test_duplocale(_LOCALE_UTF8, 0, LC_GLOBAL_LOCALE);
	test_uselocale(_LOCALE_UTF8, 0, _LOCALE_C);
	test_MB_CUR_MAX(1);
	test_uselocale(_LOCALE_C, 0, _LOCALE_NONE);
d217 3
a219 3
	test_uselocale(_LOCALE_C, 0, LC_GLOBAL_LOCALE);
	test_MB_CUR_MAX(4);
	test_uselocale(LC_GLOBAL_LOCALE, 0, _LOCALE_NONE);
d248 2
a249 2
	test_setlocale("C", LC_ALL, NULL);
	test_MB_CUR_MAX(1);
d252 3
a254 3
	test_setlocale("C.UTF-8", LC_CTYPE, "C.UTF-8");
	test_MB_CUR_MAX(4);
	test_uselocale(LC_GLOBAL_LOCALE, 0, _LOCALE_NONE);
@

