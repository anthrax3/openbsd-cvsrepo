head	1.7;
access;
symbols
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.10
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.8
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.42
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.40
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.38
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.36
	OPENBSD_5_0:1.5.0.34
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.32
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.30
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.7
date	2016.05.29.20.03.54;	author beck;	state dead;
branches;
next	1.6;
commitid	zOoAhg6ydqcWOEsL;

1.6
date	2013.12.21.05.17.29;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.31.21.48.04;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.30.01.59.47;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.02.23.26.57;	author marc;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.17.03.31.11;	author marc;	state Exp;
branches;
next	1.1;

1.1
date	2001.12.17.02.36.00;	author marc;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Nuke sigret.c
ok deraadt@@ kettenis@@
@
text
@/*
 * $OpenBSD: sigret.c,v 1.6 2013/12/21 05:17:29 guenther Exp $
 *
 * Public Domain
 *
 * Playing games with sigreturn.   Check if calling sigreturn from a
 * signal handler screws anything up.
 *
 * Run with:
 *	-a:	use an alternate signal stack
 *
 *	-b:	call sigreturn from outside of a signal handler
 *		An error is OK
 *
 *	-c:	clobber the sigcontext before calling sigreturn
 *		the program should die
 *
 *	-f:	don't use sigreturn -- fall through the signal handler
 *		-c, and -i options ignored when used
 *
 *	-i:	call sigreturn from a function called by the signal handler
 *
 */

#include <sys/time.h>

#include <err.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/*
 * sigalarm occurs 100 times/second.  Stop running after 5 seconds
 */
#define MAX_INTERRUPTS	500

int failed;
int altstack;
int badcall;
int clobbercall;
int fallthru;
int indirect;

volatile int count;
struct sigcontext gscp;
int gscp_loaded;

static void
usage(const char * err, ...)
{
	extern const char * __progname;

	if (err) {
		va_list ap;
		va_start(ap, err);
		vwarnx(err, ap);
		va_end(ap);
	}
	fprintf(stderr, "usage: %s [-abcfi]\n", __progname);
	exit(1);
}

static void
indirect_return(struct sigcontext * scp)
{
	sigreturn(scp);
}

static void
sig_handler(int sig, siginfo_t *blah, void *x)
{
	struct sigcontext * scp = x;

	count++;

	if (!fallthru) {
		if (clobbercall)
			memset(scp, 0, sizeof *scp);
		if (indirect)
			indirect_return(scp);
		else if (badcall) {
			gscp = *scp;
			gscp_loaded = 1;
		} else
			sigreturn(scp);
	}
}

static void
test2(char *fmt)
{
	char *ofmt = fmt;

	if (gscp_loaded) {
		gscp_loaded = 0;
		sigreturn(&gscp);
	}

	for (; *fmt; fmt++)
	  switch (*fmt) {
	  case 'i':
	  case 'c':
	  case 'l':
	  case 'p':
	    break;
	  default:
	    failed = 1;
	    fprintf(stderr,
		    "unexpected character 0x%02x `%c' in %s: count %d\n",
		    *fmt, *fmt, ofmt, count);
	  }
}

int
main(int argc, char * argv[])
{
	extern char *optarg;
	extern int optind;

	int opt;

	struct sigaction act;
	struct sigaltstack ss;

	while ((opt = getopt(argc, argv, "abcfi")) != -1) {
		switch (opt) {
		case 'a':
			/* use sigaltstack */
			altstack = 1;
			break;
		case 'b':
			/* call outside of sig_handler */
			badcall = 1;
			break;
		case 'c':
			/* force error by munging sigcontext */
			clobbercall = 1;
			break;
		case 'f':
			/* don't use sigreturn */
			fallthru = 1;
			break;
		case 'i':
			/* call sigreturn indirectly */
			indirect = 1;
			break;
		}
	}

	/* make sure there is no other cruft left on the command line */
	if (optind != argc)
		usage("unknown argument -- %s", argv[ optind ]);

	if (altstack) {
		if ((ss.ss_sp = malloc(SIGSTKSZ)) == NULL)
			errx(1, "ss_sp malloc");

		ss.ss_size = SIGSTKSZ;
		ss.ss_flags = 0;
		if (sigaltstack(&ss,0) == -1)
			err(1, "sigaltstack");
	}

	sigfillset(&act.sa_mask);
	act.sa_sigaction = sig_handler;
	act.sa_flags = SA_RESTART;
	if (altstack)
		act.sa_flags |= SA_ONSTACK;
	sigaction(SIGALRM, &act, NULL);

	ualarm(10000, 10000);

	while (count < MAX_INTERRUPTS)
		test2("iclp");

	return failed;
}
@


1.6
log
@Fix a comment
@
text
@d2 1
a2 1
 * $OpenBSD: sigret.c,v 1.5 2003/07/31 21:48:04 deraadt Exp $
@


1.5
log
@various cleanups; david says results are same
@
text
@d2 1
a2 1
 * $OpenBSD: sigret.c,v 1.4 2002/04/30 01:59:47 deraadt Exp $
d36 1
a36 2
 * sigalarm occurs 50 times/second.  Stop running after 10 seconds
 * (100 interrupts).
@


1.4
log
@arguement -> argument
@
text
@d2 1
a2 1
 * $OpenBSD: sigret.c,v 1.3 2002/01/02 23:26:57 marc Exp $
d67 1
a67 1
void
d73 1
a73 1
void
d93 1
a93 1
void
@


1.3
log
@convert test prog into real regression test
@
text
@d2 1
a2 1
 * $OpenBSD: sigret.c,v 1.2 2001/12/17 03:31:11 marc Exp $
d156 1
a156 1
		usage("unknown arguement -- %s", argv[ optind ]);
@


1.2
log
@OpenBSD tag, explicit public domain notice
@
text
@d2 1
a2 1
 * $OpenBSD$
a22 1
 * Program should not exit until killed.
d35 7
d111 1
d177 1
a177 1
	while (1)
d179 2
@


1.1
log
@sigreturn test program
@
text
@d2 4
@

