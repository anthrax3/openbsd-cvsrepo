head	1.12;
access;
symbols
	OPENBSD_6_0:1.12.0.26
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.16
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.24
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.22
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.20
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.18
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.14
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.12
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.10
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.8
	OPENBSD_5_0:1.12.0.6
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.4
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.11.0.8
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.10
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.6
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.3.0.10
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.8
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.6
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.16
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.14
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2010.05.08.19.16.33;	author naddy;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.22.21.07.10;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.15.14.00.22;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.22.00.54.39;	author david;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.10.03.06.42;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.22.19.29.42;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.02.03.06.12;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.02.23.52.16;	author david;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.31.21.48.03;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.02.05.42;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.12.21.22.23.41;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.33;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.12
log
@* add #includes to pull in missing prototypes, as pointed out by gcc4
* fix CFLAGS syntax for make depend

ok blambert@@
@
text
@/*	$OpenBSD: except.c,v 1.11 2007/10/22 21:07:10 miod Exp $	*/

#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <assert.h>
#include <ieeefp.h>
#include <float.h>
#include <err.h>

volatile sig_atomic_t signal_status;

volatile const double one  = 1.0;
volatile const double zero = 0.0;
volatile const double huge = DBL_MAX;
volatile const double tiny = DBL_MIN;

void
sigfpe(int sig, siginfo_t *si, void *v)
{
	char buf[132];

	if (si) {
		snprintf(buf, sizeof(buf), "sigfpe: addr=%p, code=%d\n",
		    si->si_addr, si->si_code);
		write(1, buf, strlen(buf));
	}
	_exit(signal_status);
}


int
main(int argc, char *argv[])
{
	struct sigaction sa;
	volatile double x;

	if (argc != 2) {
		fprintf(stderr, "usage: %s condition\n", argv[0]);
		exit(1);
	}

	/*
	 * check to make sure that all exceptions are masked and 
	 * that the accumulated exception status is clear.
 	 */
	assert(fpgetmask() == 0);
	assert(fpgetsticky() == 0);

	memset(&sa, 0, sizeof(sa));
	sa.sa_sigaction = sigfpe;
	sa.sa_flags = SA_SIGINFO;
	sigaction(SIGFPE, &sa, NULL);
	signal_status = 1;

	if (strcmp(argv[1], "fltdiv") == 0) {
		/* trip divide by zero */
		x = one / zero;
		assert(fpgetsticky() & FP_X_DZ);
		fpsetsticky(0);

		/* and now unmask to get a signal */
		signal_status = 0;
		fpsetmask(FP_X_DZ);
		x = one / zero;
	} else if (strcmp(argv[1], "fltinv") == 0) {
		/* trip invalid operation */
		x = zero / zero;
		assert(fpgetsticky() & FP_X_INV);
		fpsetsticky(0);

		/* and now unmask to get a signal */
		signal_status = 0;
		fpsetmask(FP_X_INV);
		x = zero / zero;
	} else if (strcmp(argv[1], "fltovf") == 0) {
		/* trip overflow */
		x = huge * huge;
		assert(fpgetsticky() & FP_X_OFL);
		fpsetsticky(0);

		/* and now unmask to get a signal */
		signal_status = 0;
		fpsetmask(FP_X_OFL);
		x = huge * huge;
	} else if (strcmp(argv[1], "fltund") == 0) {
		/* trip underflow */
		x = tiny * tiny;
		assert(fpgetsticky() & FP_X_UFL);
		fpsetsticky(0);

		/* and now unmask to get a signal */
		signal_status = 0;
		fpsetmask(FP_X_UFL);
		x = tiny * tiny;
	} else {
		errx(1, "unrecognized condition %s", argv[1]);
	}

	/*
	 * attempt to trigger the exception on machines where
	 * floating-point exceptions are deferred.
	 */
	x = one * one;

	errx(1, "signal wasn't caught");
}
@


1.11
log
@Only test one condition per invocation flavour, instead of testing all
of them with exceptions disabled and then only one with exceptions enabled.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: except.c,v 1.10 2006/05/15 14:00:22 kettenis Exp $	*/
d7 1
@


1.10
log
@Try harder to trigger an exception.  On architectures where floating-point
exceptions are deferred, we might not see the exception before another
floating-point instruction is executed.  This is especially true on the i387
where we don't see underflow/overflow until the result is stored into memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: except.c,v 1.9 2004/12/22 00:54:39 david Exp $	*/
d58 5
a62 21
	/* trip divide by zero */
	x = one / zero;
	assert(fpgetsticky() & FP_X_DZ);
	fpsetsticky(0);

	/* trip invalid operation */
	x = zero / zero;
	assert(fpgetsticky() & FP_X_INV);
	fpsetsticky(0);

	/* trip overflow */
	x = huge * huge;
	assert(fpgetsticky() & FP_X_OFL);
	fpsetsticky(0);

	/* trip underflow */
	x = tiny * tiny;
	assert(fpgetsticky() & FP_X_UFL);
	fpsetsticky(0);

	signal_status = 0;
d64 2
a65 2
	if (strcmp(argv[1], "fltdiv") == 0) {
		/* unmask and then trip divide by zero */
d69 7
a75 1
		/* unmask and then trip invalid operation */
d79 7
a85 1
		/* unmask and then trip overflow */
d89 7
a95 1
		/* unmask and then trip underflow */
@


1.9
log
@some -Wimplicit-function-declaration cleaning; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: except.c,v 1.8 2004/10/10 03:06:42 mickey Exp $	*/
d99 6
@


1.8
log
@use sig_atomic_t instead of int
@
text
@d1 1
a1 1
/*	$OpenBSD: except.c,v 1.7 2004/07/22 19:29:42 kettenis Exp $	*/
d3 2
@


1.7
log
@Split and modify tests to prevent infinite loops on platforms with precise
floating-point exceptions like amd64.
ok deraadt@@, david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: except.c,v 1.6 2004/04/02 03:06:12 mickey Exp $	*/
d11 1
a11 1
volatile int signal_status;
@


1.6
log
@check the signals for exceptions and do siginfo in the signal handler; also some style
@
text
@d1 1
a1 1
/*	$OpenBSD: except.c,v 1.5 2003/09/02 23:52:16 david Exp $	*/
d9 1
d11 1
a11 1
volatile sig_atomic_t signal_caught;
d28 1
a28 1
	signal_caught = 1;
d38 5
d54 1
a54 1
	signal_caught = 0;
a58 1
	assert(signal_caught == 0);
a63 1
	assert(signal_caught == 0);
a68 1
	assert(signal_caught == 0);
a73 1
	assert(signal_caught == 0);
d76 1
a76 5
	/* unmask and then trip divide by zero */
	fpsetmask(FP_X_DZ);
	x = one / zero;
	assert(signal_caught == 1);
	signal_caught = 0;
d78 19
a96 5
	/* unmask and then trip invalid operation */
	fpsetmask(FP_X_INV);
	x = zero / zero;
	assert(signal_caught == 1);
	signal_caught = 0;
d98 1
a98 13
	/* unmask and then trip overflow */
	fpsetmask(FP_X_OFL);
	x = huge * huge;
	assert(signal_caught == 1);
	signal_caught = 0;

	/* unmask and then trip underflow */
	fpsetmask(FP_X_UFL);
	x = tiny * tiny;
	assert (signal_caught == 1);
	signal_caught = 0;

	exit(0);
a99 1

@


1.5
log
@add missing includes
ok deraadt@@ tedu@@ dhartmei@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: except.c,v 1.4 2003/07/31 21:48:03 deraadt Exp $	*/
d10 1
a10 1
volatile sig_atomic_t signal_cought;
d12 4
a15 4
static volatile const double one  = 1.0;
static volatile const double zero = 0.0;
static volatile const double huge = DBL_MAX;
static volatile const double tiny = DBL_MIN;
d17 2
a18 2
static void
sigfpe(int signo)
d20 8
a27 1
	signal_cought = 1;
d30 1
d34 1
d44 5
a48 3
	/* set up signal handler */
	signal (SIGFPE, sigfpe);
	signal_cought = 0;
d52 2
a53 2
	assert (fpgetsticky() & FP_X_DZ);
	assert (signal_cought == 0);
d58 2
a59 2
	assert (fpgetsticky() & FP_X_INV);
	assert (signal_cought == 0);
d64 2
a65 2
	assert (fpgetsticky() & FP_X_OFL);
	assert (signal_cought == 0);
d70 2
a71 2
	assert (fpgetsticky() & FP_X_UFL);
	assert (signal_cought == 0);
a73 1
#if 0
d77 2
a78 2
	assert (signal_cought == 1);
	signal_cought = 0;
d83 2
a84 2
	assert (signal_cought == 1);
	signal_cought = 0;
d89 2
a90 2
	assert (signal_cought == 1);
	signal_cought = 0;
d95 2
a96 3
	assert (signal_cought == 1);
	signal_cought = 0;
#endif
@


1.4
log
@various cleanups; david says results are same
@
text
@d1 1
a1 1
/*	$OpenBSD: except.c,v 1.3 2001/01/29 02:05:42 niklas Exp $	*/
d4 1
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a8 1
void sigfpe();
d16 6
d23 1
a23 1
main()
a90 5
void
sigfpe()
{
	signal_cought = 1;
}
@


1.2
log
@-Wall madness.
@
text
@d1 2
@


1.1
log
@Initial revision
@
text
@d15 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
