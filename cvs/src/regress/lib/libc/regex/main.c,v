head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.7.0.26
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.34
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.32
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.30
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.28
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.24
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.22
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.20
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.18
	OPENBSD_5_0:1.7.0.16
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.14
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.12
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.8
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.10
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.6
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.26
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.24
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.22
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.20
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.18
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.07.13.06.17.11;	author guenther;	state Exp;
branches;
next	1.9;
commitid	S8tUHHYUH2tGuXqk;

1.9
date	2016.05.26.14.17.58;	author schwarze;	state Exp;
branches;
next	1.8;
commitid	QxQFZuDhKlTFkepi;

1.8
date	2016.05.26.13.33.53;	author schwarze;	state Exp;
branches;
next	1.7;
commitid	UbmfeHyreg9L88DZ;

1.7
date	2007.09.12.19.32.35;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.09.23.25.12;	author chl;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.28.08.06.46;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.31.21.48.03;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.41.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.12.21.22.23.42;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.33;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Fix usage() output and getopt sorting
@
text
@/*	$OpenBSD: main.c,v 1.9 2016/05/26 14:17:58 schwarze Exp $	*/
/*	$NetBSD: main.c,v 1.2 1995/04/20 22:39:51 cgd Exp $	*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <regex.h>
#include <assert.h>
#include <unistd.h>

#include "main.ih"

char *progname;
int debug = 0;
int line = 0;
int status = 0;

int copts = REG_EXTENDED;
int eopts = 0;
regoff_t startoff = 0;
regoff_t endoff = 0;


extern int split(char *, char *[], int, char *);
extern void regprint(regex_t *, FILE *);

/*
 - main - do the simple case, hand off to regress() for regression
 */
int
main(int argc, char *argv[])

{
	regex_t re;
#	define	NS	10
	regmatch_t subs[NS];
	char erbuf[100];
	int err;
	size_t len;
	int c;
	int errflg = 0;
	register int i;
	extern int optind;
	extern char *optarg;

	progname = argv[0];

	while ((c = getopt(argc, argv, "c:E:e:S:x")) != -1)
		switch (c) {
		case 'c':	/* compile options */
			copts = options('c', optarg);
			break;
		case 'E':	/* end offset */
			endoff = (regoff_t)atoi(optarg);
			break;
		case 'e':	/* execute options */
			eopts = options('e', optarg);
			break;
		case 'S':	/* start offset */
			startoff = (regoff_t)atoi(optarg);
			break;
		case 'x':	/* Debugging. */
			debug++;
			break;
		case '?':
		default:
			errflg++;
			break;
		}
	if (errflg) {
		fprintf(stderr, "usage: %s ", progname);
		fprintf(stderr, "[-x] [-c copt] [-E endoff] [-e eopt] [-S startoff] [re]\n");
		exit(2);
	}

	if (optind >= argc) {
		regress(stdin);
		exit(status);
	}

	err = regcomp(&re, argv[optind++], copts);
	if (err) {
		len = regerror(err, &re, erbuf, sizeof(erbuf));
		fprintf(stderr, "error %s, %zu/%zu `%s'\n",
			eprint(err), len, sizeof(erbuf), erbuf);
		exit(status);
	}
	regprint(&re, stdout);	

	if (optind >= argc) {
		regfree(&re);
		exit(status);
	}

	if (eopts&REG_STARTEND) {
		subs[0].rm_so = startoff;
		subs[0].rm_eo = strlen(argv[optind]) - endoff;
	}
	err = regexec(&re, argv[optind], (size_t)NS, subs, eopts);
	if (err) {
		len = regerror(err, &re, erbuf, sizeof(erbuf));
		fprintf(stderr, "error %s, %zu/%zu `%s'\n",
			eprint(err), len, sizeof(erbuf), erbuf);
		exit(status);
	}
	if (!(copts&REG_NOSUB)) {
		len = (size_t)(subs[0].rm_eo - subs[0].rm_so);
		if (subs[0].rm_so != -1) {
			if (len != 0)
				printf("match `%.*s'\n", (int)len,
					argv[optind] + subs[0].rm_so);
			else
				printf("match `'@@%.1s\n",
					argv[optind] + subs[0].rm_so);
		}
		for (i = 1; i < NS; i++)
			if (subs[i].rm_so != -1)
				printf("(%d) `%.*s'\n", i,
					(int)(subs[i].rm_eo - subs[i].rm_so),
					argv[optind] + subs[i].rm_so);
	}
	exit(status);
}

/*
 - regress - main loop of regression test
 == void regress(FILE *in);
 */
void
regress(in)
FILE *in;
{
	char inbuf[1000];
#	define	MAXF	10
	char *f[MAXF];
	int nf;
	int i;
	char erbuf[100];
	size_t ne;
	char *badpat = "invalid regular expression";
#	define	SHORT	10
	char *bpname = "REG_BADPAT";
	regex_t re;

	while (fgets(inbuf, sizeof(inbuf), in) != NULL) {
		line++;
		if (inbuf[0] == '#' || inbuf[0] == '\n')
			continue;			/* NOTE CONTINUE */
		inbuf[strcspn(inbuf, "\n")] = '\0';	/* get rid of stupid \n */
		if (debug)
			fprintf(stdout, "%d:\n", line);
		nf = split(inbuf, f, MAXF, "\t\t");
		if (nf < 3) {
			fprintf(stderr, "bad input, line %d\n", line);
			exit(1);
		}
		for (i = 0; i < nf; i++)
			if (strcmp(f[i], "\"\"") == 0)
				f[i] = "";
		if (nf <= 3)
			f[3] = NULL;
		if (nf <= 4)
			f[4] = NULL;
		try(f[0], f[1], f[2], f[3], f[4], options('c', f[1]));
		if (opt('&', f[1]))	/* try with either type of RE */
			try(f[0], f[1], f[2], f[3], f[4],
					options('c', f[1]) &~ REG_EXTENDED);
	}

	ne = regerror(REG_BADPAT, (regex_t *)NULL, erbuf, sizeof(erbuf));
	if (strcmp(erbuf, badpat) != 0 || ne != strlen(badpat)+1) {
		fprintf(stderr, "end: regerror() test gave `%s' not `%s'\n",
							erbuf, badpat);
		status = 1;
	}
	ne = regerror(REG_BADPAT, (regex_t *)NULL, erbuf, (size_t)SHORT);
	if (strncmp(erbuf, badpat, SHORT-1) != 0 || erbuf[SHORT-1] != '\0' ||
						ne != strlen(badpat)+1) {
		fprintf(stderr, "end: regerror() short test gave `%s' not `%.*s'\n",
						erbuf, SHORT-1, badpat);
		status = 1;
	}
	ne = regerror(REG_ITOA|REG_BADPAT, (regex_t *)NULL, erbuf, sizeof(erbuf));
	if (strcmp(erbuf, bpname) != 0 || ne != strlen(bpname)+1) {
		fprintf(stderr, "end: regerror() ITOA test gave `%s' not `%s'\n",
						erbuf, bpname);
		status = 1;
	}
	re.re_endp = bpname;
	ne = regerror(REG_ATOI, &re, erbuf, sizeof(erbuf));
	if (atoi(erbuf) != (int)REG_BADPAT) {
		fprintf(stderr, "end: regerror() ATOI test gave `%s' not `%ld'\n",
						erbuf, (long)REG_BADPAT);
		status = 1;
	} else if (ne != strlen(erbuf)+1) {
		fprintf(stderr, "end: regerror() ATOI test len(`%s') = %ld\n",
						erbuf, (long)REG_BADPAT);
		status = 1;
	}
}

/*
 - try - try it, and report on problems
 == void try(char *f0, char *f1, char *f2, char *f3, char *f4, int opts);
 */
void
try(f0, f1, f2, f3, f4, opts)
char *f0;
char *f1;
char *f2;
char *f3;
char *f4;
int opts;			/* may not match f1 */
{
	regex_t re;
#	define	NSUBS	10
	regmatch_t subs[NSUBS];
#	define	NSHOULD	15
	char *should[NSHOULD];
	int nshould;
	char erbuf[100];
	int err;
	int len;
	char *type = (opts & REG_EXTENDED) ? "ERE" : "BRE";
	register int i;
	char *grump;
	char f0copy[1000];
	char f2copy[1000];

	strlcpy(f0copy, f0, sizeof f0copy);
	re.re_endp = (opts&REG_PEND) ? f0copy + strlen(f0copy) : NULL;
	fixstr(f0copy);
	err = regcomp(&re, f0copy, opts);
	if (err != 0 && (!opt('C', f1) || err != efind(f2))) {
		/* unexpected error or wrong error */
		len = regerror(err, &re, erbuf, sizeof(erbuf));
		fprintf(stderr, "%d: %s error %s, %d/%zu `%s'\n",
					line, type, eprint(err), len,
					sizeof(erbuf), erbuf);
		status = 1;
	} else if (err == 0 && opt('C', f1)) {
		/* unexpected success */
		fprintf(stderr, "%d: %s should have given REG_%s\n",
						line, type, f2);
		status = 1;
		err = 1;	/* so we won't try regexec */
	}

	if (err != 0) {
		regfree(&re);
		return;
	}

	strlcpy(f2copy, f2, sizeof f2copy);
	fixstr(f2copy);

	if (options('e', f1)&REG_STARTEND) {
		if (strchr(f2, '(') == NULL || strchr(f2, ')') == NULL)
			fprintf(stderr, "%d: bad STARTEND syntax\n", line);
		subs[0].rm_so = strchr(f2, '(') - f2 + 1;
		subs[0].rm_eo = strchr(f2, ')') - f2;
		/* the preceding character is relevant with REG_NOTBOL */
		f2copy[subs[0].rm_so - 1] = subs[0].rm_so > 1 ?
		    f2copy[subs[0].rm_so - 2] : 'X';
	}
	err = regexec(&re, f2copy, NSUBS, subs, options('e', f1));

	if (err != 0 && (f3 != NULL || err != REG_NOMATCH)) {
		/* unexpected error or wrong error */
		len = regerror(err, &re, erbuf, sizeof(erbuf));
		fprintf(stderr, "%d: %s exec error %s, %d/%zu `%s'\n",
					line, type, eprint(err), len,
					sizeof(erbuf), erbuf);
		status = 1;
	} else if (err != 0) {
		/* nothing more to check */
	} else if (f3 == NULL) {
		/* unexpected success */
		fprintf(stderr, "%d: %s exec should have failed\n",
						line, type);
		status = 1;
		err = 1;		/* just on principle */
	} else if (opts&REG_NOSUB) {
		/* nothing more to check */
	} else if ((grump = check(f2, subs[0], f3)) != NULL) {
		fprintf(stderr, "%d: %s %s\n", line, type, grump);
		status = 1;
		err = 1;
	}

	if (err != 0 || f4 == NULL) {
		regfree(&re);
		return;
	}

	for (i = 1; i < NSHOULD; i++)
		should[i] = NULL;
	nshould = split(f4, should+1, NSHOULD-1, ",");
	if (nshould == 0) {
		nshould = 1;
		should[1] = "";
	}
	for (i = 1; i < NSUBS; i++) {
		grump = check(f2, subs[i], should[i]);
		if (grump != NULL) {
			fprintf(stderr, "%d: %s $%d %s\n", line,
							type, i, grump);
			status = 1;
			err = 1;
		}
	}

	regfree(&re);
}

/*
 - options - pick options out of a regression-test string
 == int options(int type, char *s);
 */
int
options(type, s)
int type;			/* 'c' compile, 'e' exec */
char *s;
{
	register char *p;
	register int o = (type == 'c') ? copts : eopts;
	register char *legal = (type == 'c') ? "bisnmp" : "^$#tl";

	for (p = s; *p != '\0'; p++)
		if (strchr(legal, *p) != NULL)
			switch (*p) {
			case 'b':
				o &= ~REG_EXTENDED;
				break;
			case 'i':
				o |= REG_ICASE;
				break;
			case 's':
				o |= REG_NOSUB;
				break;
			case 'n':
				o |= REG_NEWLINE;
				break;
			case 'm':
				o &= ~REG_EXTENDED;
				o |= REG_NOSPEC;
				break;
			case 'p':
				o |= REG_PEND;
				break;
			case '^':
				o |= REG_NOTBOL;
				break;
			case '$':
				o |= REG_NOTEOL;
				break;
			case '#':
				o |= REG_STARTEND;
				break;
			case 't':	/* trace */
				o |= REG_TRACE;
				break;
			case 'l':	/* force long representation */
				o |= REG_LARGE;
				break;
			case 'r':	/* force backref use */
				o |= REG_BACKR;
				break;
			}
	return(o);
}

/*
 - opt - is a particular option in a regression string?
 == int opt(int c, char *s);
 */
int				/* predicate */
opt(c, s)
int c;
char *s;
{
	return(strchr(s, c) != NULL);
}

/*
 - fixstr - transform magic characters in strings
 == void fixstr(register char *p);
 */
void
fixstr(p)
register char *p;
{
	if (p == NULL)
		return;

	for (; *p != '\0'; p++)
		if (*p == 'N')
			*p = '\n';
		else if (*p == 'T')
			*p = '\t';
		else if (*p == 'S')
			*p = ' ';
		else if (*p == 'Z')
			*p = '\0';
}

/*
 - check - check a substring match
 == char *check(char *str, regmatch_t sub, char *should);
 */
char *				/* NULL or complaint */
check(str, sub, should)
char *str;
regmatch_t sub;
char *should;
{
	register int len;
	register int shlen;
	register char *p;
	static char grump[500];
	register char *at = NULL;

	if (should != NULL && strcmp(should, "-") == 0)
		should = NULL;
	if (should != NULL && should[0] == '@@') {
		at = should + 1;
		should = "";
	}

	/* check rm_so and rm_eo for consistency */
	if (sub.rm_so > sub.rm_eo || (sub.rm_so == -1 && sub.rm_eo != -1) ||
				(sub.rm_so != -1 && sub.rm_eo == -1) ||
				(sub.rm_so != -1 && sub.rm_so < 0) ||
				(sub.rm_eo != -1 && sub.rm_eo < 0) ) {
		snprintf(grump, sizeof grump,
		    "start %ld end %ld", (long)sub.rm_so,
		    (long)sub.rm_eo);
		return(grump);
	}

	/* check for no match */
	if (sub.rm_so == -1 && should == NULL)
		return(NULL);
	if (sub.rm_so == -1)
		return("did not match");

	/* check for in range */
	if (sub.rm_eo > strlen(str)) {
		snprintf(grump, sizeof grump,
			"start %ld end %ld, past end of string",
			(long)sub.rm_so, (long)sub.rm_eo);
		return(grump);
	}

	len = (int)(sub.rm_eo - sub.rm_so);
	p = str + sub.rm_so;

	/* check for not supposed to match */
	if (should == NULL) {
		snprintf(grump, sizeof grump, "matched `%.*s'", len, p);
		return(grump);
	}

	/* check for wrong match */
	shlen = (int)strlen(should);
	if (len != shlen || strncmp(p, should, (size_t)shlen) != 0) {
		snprintf(grump, sizeof grump, "matched `%.*s' instead", len, p);
		return(grump);
	}
	if (shlen > 0)
		return(NULL);

	/* check null match in right place */
	if (at == NULL)
		return(NULL);
	shlen = strlen(at);
	if (shlen == 0)
		shlen = 1;	/* force check for end-of-string */
	if (strncmp(p, at, shlen) != 0) {
		snprintf(grump, sizeof grump, "matched null at `%.20s'", p);
		return(grump);
	}
	return(NULL);
}

/*
 - eprint - convert error number to name
 == static char *eprint(int err);
 */
static char *
eprint(err)
int err;
{
	static char epbuf[100];
	size_t len;

	len = regerror(REG_ITOA|err, (regex_t *)NULL, epbuf, sizeof(epbuf));
	assert(len <= sizeof(epbuf));
	return(epbuf);
}

/*
 - efind - convert error name to number
 == static int efind(char *name);
 */
static int
efind(name)
char *name;
{
	static char efbuf[100];
	regex_t re;

	snprintf(efbuf, sizeof efbuf, "REG_%s", name);
	assert(strlen(efbuf) < sizeof(efbuf));
	re.re_endp = efbuf;
	(void) regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));
	return(atoi(efbuf));
}
@


1.9
log
@Fix an oversight that caused the test program to segfault:
Don't try to calculate strlen(NULL).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 2016/05/26 13:33:53 schwarze Exp $	*/
d49 1
a49 1
	while ((c = getopt(argc, argv, "c:e:S:E:x")) != -1)
d54 3
a62 3
		case 'E':	/* end offset */
			endoff = (regoff_t)atoi(optarg);
			break;
d73 1
a73 1
		fprintf(stderr, "[-c copt][-C][-d] [re]\n");
@


1.8
log
@support for testing REG_STARTEND together with REG_NOTBOL
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 2007/09/12 19:32:35 otto Exp $	*/
a456 1
	shlen = (int)strlen(should);
d466 1
@


1.7
log
@fix format strings, sizeof() does not return an int
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 2007/09/09 23:25:12 chl Exp $	*/
d263 3
@


1.6
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok moritz@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 2004/02/28 08:06:46 deraadt Exp $	*/
d85 1
a85 1
		fprintf(stderr, "error %s, %d/%d `%s'\n",
d103 1
a103 1
		fprintf(stderr, "error %s, %d/%d `%s'\n",
d238 1
a238 1
		fprintf(stderr, "%d: %s error %s, %d/%d `%s'\n",
d269 1
a269 1
		fprintf(stderr, "%d: %s exec error %s, %d/%d `%s'\n",
@


1.5
log
@kill bad functions; some sort of ok from marc who is trying to confuse me
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 2003/07/31 21:48:03 deraadt Exp $	*/
d150 1
a150 1
		inbuf[strlen(inbuf)-1] = '\0';	/* get rid of stupid \n */
@


1.4
log
@various cleanups; david says results are same
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 1997/01/15 23:41:07 millert Exp $	*/
d231 1
a231 1
	strcpy(f0copy, f0);
d255 1
a255 1
	strcpy(f2copy, f2);
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.2 1996/12/21 22:23:42 millert Exp $	*/
d25 2
a26 2
extern int split();
extern void regprint();
d32 2
a33 3
main(argc, argv)
int argc;
char *argv[];
d433 3
a435 2
		sprintf(grump, "start %ld end %ld", (long)sub.rm_so,
							(long)sub.rm_eo);
d447 3
a449 2
		sprintf(grump, "start %ld end %ld, past end of string",
					(long)sub.rm_so, (long)sub.rm_eo);
d459 1
a459 1
		sprintf(grump, "matched `%.*s'", len, p);
d465 1
a465 1
		sprintf(grump, "matched `%.*s' instead", len, p);
d478 1
a478 1
		sprintf(grump, "matched null at `%.20s'", p);
d511 1
a511 1
	sprintf(efbuf, "REG_%s", name);
@


1.2
log
@-Wall madness.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.2 1995/04/20 22:39:51 cgd Exp $	*/
d50 1
a50 1
	while ((c = getopt(argc, argv, "c:e:S:E:x")) != EOF)
@


1.1
log
@Initial revision
@
text
@d1 1
d5 1
d10 1
d31 1
d109 1
a109 1
		len = (int)(subs[0].rm_eo - subs[0].rm_so);
d112 1
a112 1
				printf("match `%.*s'\n", len,
a507 1
	size_t n;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
