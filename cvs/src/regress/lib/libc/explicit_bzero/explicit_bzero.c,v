head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.10
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.6
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.6
date	2014.07.11.01.10.35;	author matthew;	state Exp;
branches;
next	1.5;
commitid	MdeZBcYXKAKVo2Da;

1.5
date	2014.07.11.00.38.17;	author matthew;	state Exp;
branches;
next	1.4;
commitid	xUv3Z6fQNXLP3MLg;

1.4
date	2014.07.09.23.54.00;	author matthew;	state Exp;
branches;
next	1.3;
commitid	yoXZ5jbigSBprYCO;

1.3
date	2014.07.09.18.02.24;	author matthew;	state Exp;
branches;
next	1.2;
commitid	hJugayLIXbUosXIP;

1.2
date	2014.07.09.14.26.59;	author bcook;	state Exp;
branches;
next	1.1;
commitid	JaIxa3N5hkAsDfC7;

1.1
date	2014.06.12.22.01.55;	author matthew;	state Exp;
branches;
next	;
commitid	G8t1MWjEvkBzIpgv;


desc
@@


1.6
log
@Fix dumb copy/paste mistake.

Noticed testing with clang.
@
text
@/*	$OpenBSD: explicit_bzero.c,v 1.5 2014/07/11 00:38:17 matthew Exp $	*/
/*
 * Copyright (c) 2014 Google Inc.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <assert.h>
#include <errno.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

#define ASSERT_EQ(a, b) assert((a) == (b))
#define ASSERT_NE(a, b) assert((a) != (b))
#define ASSERT_GE(a, b) assert((a) >= (b))

/* 128 bits of random data. */
static const char secret[16] = {
	0xa0, 0x6c, 0x0c, 0x81, 0xba, 0xd8, 0x5b, 0x0c,
	0xb0, 0xd6, 0xd4, 0xe3, 0xeb, 0x52, 0x5f, 0x96,
};

enum {
	SECRETCOUNT = 64,
	SECRETBYTES = SECRETCOUNT * sizeof(secret)
};

static char altstack[SIGSTKSZ + SECRETBYTES];

static void
setup_stack(void)
{
	const stack_t sigstk = {
		.ss_sp = altstack,
		.ss_size = sizeof(altstack),
	};

	ASSERT_EQ(0, sigaltstack(&sigstk, NULL));
}

static void
assert_on_stack(void)
{
	stack_t cursigstk;
	ASSERT_EQ(0, sigaltstack(NULL, &cursigstk));
	ASSERT_EQ(SS_ONSTACK, cursigstk.ss_flags & (SS_DISABLE|SS_ONSTACK));
}

static void
call_on_stack(void (*fn)(int))
{
	/*
	 * This is a bit more complicated than strictly necessary, but
	 * it ensures we don't have any flaky test failures due to
	 * inherited signal masks/actions/etc.
	 *
	 * On systems where SA_ONSTACK is not supported, this could
	 * alternatively be implemented using makecontext() or
	 * pthread_attr_setstack().
	 */

	const struct sigaction sigact = {
		.sa_handler = fn,
		.sa_flags = SA_ONSTACK,
	};
	struct sigaction oldsigact;
	sigset_t sigset, oldsigset;

	/* First, block all signals. */
	ASSERT_EQ(0, sigemptyset(&sigset));
	ASSERT_EQ(0, sigfillset(&sigset));
	ASSERT_EQ(0, sigprocmask(SIG_BLOCK, &sigset, &oldsigset));

	/* Next setup the signal handler for SIGUSR1. */
	ASSERT_EQ(0, sigaction(SIGUSR1, &sigact, &oldsigact));

	/* Raise SIGUSR1 and momentarily unblock it to run the handler. */
	ASSERT_EQ(0, raise(SIGUSR1));
	ASSERT_EQ(0, sigdelset(&sigset, SIGUSR1));
	ASSERT_EQ(-1, sigsuspend(&sigset));
	ASSERT_EQ(EINTR, errno);

	/* Restore the original signal action, stack, and mask. */
	ASSERT_EQ(0, sigaction(SIGUSR1, &oldsigact, NULL));
	ASSERT_EQ(0, sigprocmask(SIG_SETMASK, &oldsigset, NULL));
}

static void
populate_secret(char *buf, size_t len)
{
	int i, fds[2];
	ASSERT_EQ(0, pipe(fds));

	for (i = 0; i < SECRETCOUNT; i++)
		ASSERT_EQ(sizeof(secret), write(fds[1], secret, sizeof(secret)));
	ASSERT_EQ(0, close(fds[1]));

	ASSERT_EQ(len, read(fds[0], buf, len));
	ASSERT_EQ(0, close(fds[0]));
}

static int
count_secrets(const char *buf)
{
	int res = 0;
	size_t i;
	for (i = 0; i < SECRETCOUNT; i++) {
		if (memcmp(buf + i * sizeof(secret), secret,
		    sizeof(secret)) == 0)
			res += 1;
	}
	return (res);
}

static char *
test_without_bzero()
{
	char buf[SECRETBYTES];
	assert_on_stack();
	populate_secret(buf, sizeof(buf));
	char *res = memmem(altstack, sizeof(altstack), buf, sizeof(buf));
	ASSERT_NE(NULL, res);
	return (res);
}

static char *
test_with_bzero()
{
	char buf[SECRETBYTES];
	assert_on_stack();
	populate_secret(buf, sizeof(buf));
	char *res = memmem(altstack, sizeof(altstack), buf, sizeof(buf));
	ASSERT_NE(NULL, res);
	explicit_bzero(buf, sizeof(buf));
	return (res);
}

static void 
do_test_without_bzero(int signo)
{
	char *buf = test_without_bzero();
	ASSERT_GE(count_secrets(buf), 1);
}

static void 
do_test_with_bzero(int signo)
{
	char *buf = test_with_bzero();
	ASSERT_EQ(count_secrets(buf), 0);
}

int
main()
{
	setup_stack();

	/*
	 * Solaris and OS X clobber the signal stack after returning to the
	 * normal stack, so we need to inspect altstack while we're still
	 * running on it.  Unfortunately, this means we risk clobbering the
	 * buffer ourselves.
	 *
	 * To minimize this risk, test_with{,out}_bzero() are responsible for
	 * locating the offset of their buf variable within altstack, and
	 * and returning that address.  Then we can simply memcmp() repeatedly
	 * to count how many instances of secret we found.
	 */

	/*
	 * First, test that if we *don't* call explicit_bzero, that we
	 * *are* able to find at least one instance of the secret data still
	 * on the stack.  This sanity checks that call_on_stack() and
	 * populate_secret() work as intended.
	 */
	memset(altstack, 0, sizeof(altstack));
	call_on_stack(do_test_without_bzero);

	/*
	 * Now test with a call to explicit_bzero() and check that we
	 * *don't* find any instances of the secret data.
	 */
	memset(altstack, 0, sizeof(altstack));
	call_on_stack(do_test_with_bzero);

	return (0);
}
@


1.5
log
@Fix explicit_bzero regress for Solaris and OS X compatibility

Solaris and OS X clobber the signal stack when returning to the main
stack, which caused the original testing strategy (inspecting the
signal stack once we're back on the main stack) to fail.

To be compatible with this behavior, the regress test now inspects the
signal stack space while we're still executing on it.  This is a bit
iffy because we might clobber it ourselves while inspecting it, but we
as long as its not completely clobbered we should be okay.

thx bcook for the Solaris test account
@
text
@d1 1
a1 1
/*	$OpenBSD: explicit_bzero.c,v 1.4 2014/07/09 23:54:00 matthew Exp $	*/
d159 2
a160 2
	char *buf = test_without_bzero();
	ASSERT_GE(count_secrets(buf), 0);
@


1.4
log
@Add some extra sanity checks to make sure the test functions actually
run on altstack.
@
text
@d1 1
a1 1
/*	$OpenBSD: explicit_bzero.c,v 1.3 2014/07/09 18:02:24 matthew Exp $	*/
d28 12
a39 1
static char altstack[SIGSTKSZ];
a98 11
/* 128 bits of random data. */
static const char secret[16] = {
	0xa0, 0x6c, 0x0c, 0x81, 0xba, 0xd8, 0x5b, 0x0c,
	0xb0, 0xd6, 0xd4, 0xe3, 0xeb, 0x52, 0x5f, 0x96,
};

enum {
	SECRETCOUNT = 16,
	SECRETBYTES = SECRETCOUNT * sizeof(secret)
};

d113 15
a127 2
static void
test_without_bzero(int signo)
d132 3
a134 1
	ASSERT_NE(NULL, memmem(altstack, sizeof(altstack), buf, sizeof(buf)));
d137 2
a138 2
static void
test_with_bzero(int signo)
d143 2
a144 1
	ASSERT_NE(NULL, memmem(altstack, sizeof(altstack), buf, sizeof(buf)));
d146 15
d169 12
d182 3
a184 3
	 * *are* able to find the secret data on the stack.  This
	 * sanity checks that call_on_stack() and populare_secret()
	 * work as intended.
d187 1
a187 2
	call_on_stack(test_without_bzero);
	ASSERT_NE(NULL, memmem(altstack, sizeof(altstack), secret, sizeof(secret)));
d191 1
a191 1
	 * *don't* find the secret data.
d194 1
a194 2
	call_on_stack(test_with_bzero);
	ASSERT_EQ(NULL, memmem(altstack, sizeof(altstack), secret, sizeof(secret)));
@


1.3
log
@Better workaround for OS X sigaltstack() bug

OS X's sigaltstack() fails with ENOMEM if ss_size < MINSIGSTKSZ even
if SS_DISABLE is specified in ss_flags.  Rather than add code to try
to cope with this stupidity, just don't bother restoring the original
signal stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: explicit_bzero.c,v 1.2 2014/07/09 14:26:59 bcook Exp $	*/
d42 8
d117 1
d119 1
d126 1
d128 1
@


1.2
log
@check if we were previously on a signal stack before restoring.

OS X fails to restore the old signal stack because the signal stack is
not enabled by default. This causes sigaltstack(2) to fail with ENOMEM
as ss_size is 0, < MINSIGSTCKSZ.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: explicit_bzero.c,v 1.1 2014/06/12 22:01:55 matthew Exp $	*/
d28 13
d42 1
a42 1
call_on_stack(void (*fn)(int), void *stack, size_t stacklen)
a57 4
	const stack_t sigstk = {
		.ss_sp = stack,
		.ss_size = stacklen,
	};
a58 1
	stack_t oldsigstk;
d66 1
a66 2
	/* Next setup the signal stack and handler for SIGUSR1. */
	ASSERT_EQ(0, sigaltstack(&sigstk, &oldsigstk));
a76 2
	if (oldsigstk.ss_flags & SA_ONSTACK)
		ASSERT_EQ(0, sigaltstack(&oldsigstk, NULL));
a119 2
static char altstack[SIGSTKSZ];

d123 2
d132 1
a132 1
	call_on_stack(test_without_bzero, altstack, sizeof(altstack));
d140 1
a140 1
	call_on_stack(test_with_bzero, altstack, sizeof(altstack));
@


1.1
log
@Add regress test for explicit_bzero.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 2
a71 1
	ASSERT_EQ(0, sigaltstack(&oldsigstk, NULL));
@

