head	1.15;
access;
symbols
	OPENBSD_6_1:1.14.0.8
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.4
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.22
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.20
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.28
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.24
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.22
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.20
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.18
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2017.04.16.16.04.48;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	3vQh4rzJ8zPsqPb6;

1.14
date	2015.10.23.18.47.21;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	VCou26XNOx2Y1PpW;

1.13
date	2015.02.06.23.21.58;	author millert;	state Exp;
branches;
next	1.12;
commitid	STdsVrA5MGLlnbLm;

1.12
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.31.21.48.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.19.38.25;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.18.21.40.46;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.32;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.02.05.40;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.07.25.19.43.40;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.01.17.07.12.13;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.41.06;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.05.07.09.02.22;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.32;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Use INT_MAX instead of SIZE_MAX as the maximum file size we can handle.
Fixes this test on 64-bit architectures.

ok visa@@
@
text
@/*	$OpenBSD: dbtest.c,v 1.14 2015/10/23 18:47:21 mmcc Exp $	*/
/*	$NetBSD: dbtest.c,v 1.8 1996/05/03 21:57:48 cgd Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>

#include <db.h>

enum S { COMMAND, COMPARE, GET, PUT, REMOVE, SEQ, SEQFLAG, KEY, DATA };

void	 compare(DBT *, DBT *);
DBTYPE	 dbtype(char *);
void	 dump(DB *, int);
void	 dberr(const char *, ...);
void	 get(DB *, DBT *);
void	 getdata(DB *, DBT *, DBT *);
void	 put(DB *, DBT *, DBT *);
void	 rem(DB *, DBT *);
char	*sflags(int);
void	 synk(DB *);
void	*rfile(char *, size_t *);
void	 seq(DB *, DBT *);
u_int	 setflags(char *);
void	*setinfo(DBTYPE, char *);
void	 usage(void);
void	*xmalloc(char *, size_t);

DBTYPE type;				/* Database type. */
void *infop;				/* Iflags. */
u_long lineno;				/* Current line in test script. */
u_int flags;				/* Current DB flags. */
int ofd = STDOUT_FILENO;		/* Standard output fd. */

DB *XXdbp;				/* Global for gdb. */
int XXlineno;				/* Fast breakpoint for gdb. */

int
main(int argc, char *argv[])
{
	extern int optind;
	extern char *optarg;
	enum S command, state;
	DB *dbp;
	DBT data, key, keydata;
	size_t len;
	int ch, oflags, sflag;
	char *fname, *infoarg, *p, *t, buf[8 * 1024];

	infoarg = NULL;
	fname = NULL;
	oflags = O_CREAT | O_RDWR;
	sflag = 0;
	while ((ch = getopt(argc, argv, "f:i:lo:s")) != -1)
		switch (ch) {
		case 'f':
			fname = optarg;
			break;
		case 'i':
			infoarg = optarg;
			break;
		case 'l':
			oflags |= DB_LOCK;
			break;
		case 'o':
			if ((ofd = open(optarg,
			    O_WRONLY|O_CREAT|O_TRUNC, 0666)) < 0)
				dberr("%s: %s", optarg, strerror(errno));
			break;
		case 's':
			sflag = 1;
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (argc != 2)
		usage();

	/* Set the type. */
	type = dbtype(*argv++);

	/* Open the descriptor file. */
        if (strcmp(*argv, "-") && freopen(*argv, "r", stdin) == NULL)
	    dberr("%s: %s", *argv, strerror(errno));

	/* Set up the db structure as necessary. */
	if (infoarg == NULL)
		infop = NULL;
	else
		for (p = strtok(infoarg, ",\t "); p != NULL;
		    p = strtok(0, ",\t "))
			if (*p != '\0')
				infop = setinfo(type, p);

	/*
	 * Open the DB.  Delete any preexisting copy, you almost never
	 * want it around, and it often screws up tests.
	 */
	if (fname == NULL) {
		p = getenv("TMPDIR");
		if (p == NULL)
			p = "/var/tmp";
		(void)snprintf(buf, sizeof buf, "%s/__dbtest", p);
		fname = buf;
		(void)unlink(buf);
	} else  if (!sflag)
		(void)unlink(fname);

	if ((dbp = dbopen(fname,
	    oflags, S_IRUSR | S_IWUSR, type, infop)) == NULL)
		dberr("dbopen: %s", strerror(errno));
	XXdbp = dbp;

	state = COMMAND;
	for (lineno = 1;
	    (p = fgets(buf, sizeof(buf), stdin)) != NULL; ++lineno) {
		/* Delete the newline, displaying the key/data is easier. */
		if (ofd == STDOUT_FILENO && (t = strchr(p, '\n')) != NULL)
			*t = '\0';
		if ((len = strlen(buf)) == 0 || isspace((unsigned char)*p) || *p == '#')
			continue;

		/* Convenient gdb break point. */
		if (XXlineno == lineno)
			XXlineno = 1;
		switch (*p) {
		case 'c':			/* compare */
			if (state != COMMAND)
				dberr("line %lu: not expecting command",
				    lineno);
			state = KEY;
			command = COMPARE;
			break;
		case 'e':			/* echo */
			if (state != COMMAND)
				dberr("line %lu: not expecting command",
				    lineno);
			/* Don't display the newline, if CR at EOL. */
			if (p[len - 2] == '\r')
				--len;
			if (write(ofd, p + 1, len - 1) != len - 1 ||
			    write(ofd, "\n", 1) != 1)
				dberr("write: %s", strerror(errno));
			break;
		case 'g':			/* get */
			if (state != COMMAND)
				dberr("line %lu: not expecting command",
				    lineno);
			state = KEY;
			command = GET;
			break;
		case 'p':			/* put */
			if (state != COMMAND)
				dberr("line %lu: not expecting command",
				    lineno);
			state = KEY;
			command = PUT;
			break;
		case 'r':			/* remove */
			if (state != COMMAND)
				dberr("line %lu: not expecting command",
				    lineno);
                        if (flags == R_CURSOR) {
				rem(dbp, &key);
				state = COMMAND;
                        } else {
				state = KEY;
				command = REMOVE;
			}
			break;
		case 'S':			/* sync */
			if (state != COMMAND)
				dberr("line %lu: not expecting command",
				    lineno);
			synk(dbp);
			state = COMMAND;
			break;
		case 's':			/* seq */
			if (state != COMMAND)
				dberr("line %lu: not expecting command",
				    lineno);
			if (flags == R_CURSOR) {
				state = KEY;
				command = SEQ;
			} else
				seq(dbp, &key);
			break;
		case 'f':
			flags = setflags(p + 1);
			break;
		case 'D':			/* data file */
			if (state != DATA)
				dberr("line %lu: not expecting data", lineno);
			data.data = rfile(p + 1, &data.size);
			goto ldata;
		case 'd':			/* data */
			if (state != DATA)
				dberr("line %lu: not expecting data", lineno);
			data.data = xmalloc(p + 1, len - 1);
			data.size = len - 1;
ldata:			switch (command) {
			case COMPARE:
				compare(&keydata, &data);
				break;
			case PUT:
				put(dbp, &key, &data);
				break;
			default:
				dberr("line %lu: command doesn't take data",
				    lineno);
			}
			if (type != DB_RECNO)
				free(key.data);
			free(data.data);
			state = COMMAND;
			break;
		case 'K':			/* key file */
			if (state != KEY)
				dberr("line %lu: not expecting a key", lineno);
			if (type == DB_RECNO)
				dberr("line %lu: 'K' not available for recno",
				    lineno);
			key.data = rfile(p + 1, &key.size);
			goto lkey;
		case 'k':			/* key */
			if (state != KEY)
				dberr("line %lu: not expecting a key", lineno);
			if (type == DB_RECNO) {
				static recno_t recno;
				recno = atoi(p + 1);
				key.data = &recno;
				key.size = sizeof(recno);
			} else {
				key.data = xmalloc(p + 1, len - 1);
				key.size = len - 1;
			}
lkey:			switch (command) {
			case COMPARE:
				getdata(dbp, &key, &keydata);
				state = DATA;
				break;
			case GET:
				get(dbp, &key);
				if (type != DB_RECNO)
					free(key.data);
				state = COMMAND;
				break;
			case PUT:
				state = DATA;
				break;
			case REMOVE:
				rem(dbp, &key);
				if ((type != DB_RECNO) && (flags != R_CURSOR))
					free(key.data);
				state = COMMAND;
				break;
			case SEQ:
				seq(dbp, &key);
				if ((type != DB_RECNO) && (flags != R_CURSOR))
					free(key.data);
				state = COMMAND;
				break;
			default:
				dberr("line %lu: command doesn't take a key",
				    lineno);
			}
			break;
		case 'o':
			dump(dbp, p[1] == 'r');
			break;
		default:
			dberr("line %lu: %s: unknown command character",
			    lineno, p);
		}
	}
#ifdef STATISTICS
	/*
	 * -l must be used (DB_LOCK must be set) for this to be
	 * used, otherwise a page will be locked and it will fail.
	 */
	if (type == DB_BTREE && oflags & DB_LOCK)
		__bt_stat(dbp);
#endif
	if (dbp->close(dbp))
		dberr("db->close: %s", strerror(errno));
	(void)close(ofd);
	exit(0);
}

#define	NOOVERWRITE	"put failed, would overwrite key\n"

void
compare(db1, db2)
	DBT *db1, *db2;
{
	register size_t len;
	register u_char *p1, *p2;

	if (db1->size != db2->size)
		printf("compare failed: key->data len %lu != data len %lu\n",
		    db1->size, db2->size);

	len = MIN(db1->size, db2->size);
	for (p1 = db1->data, p2 = db2->data; len--;)
		if (*p1++ != *p2++) {
			printf("compare failed at offset %d\n",
			    p1 - (u_char *)db1->data);
			break;
		}
}

void
get(dbp, kp)
	DB *dbp;
	DBT *kp;
{
	DBT data;

	switch (dbp->get(dbp, kp, &data, flags)) {
	case 0:
		(void)write(ofd, data.data, data.size);
		if (ofd == STDOUT_FILENO)
			(void)write(ofd, "\n", 1);
		break;
	case -1:
		dberr("line %lu: get: %s", lineno, strerror(errno));
		/* NOTREACHED */
	case 1:
#define	NOSUCHKEY	"get failed, no such key\n"
		if (ofd != STDOUT_FILENO)
			(void)write(ofd, NOSUCHKEY, sizeof(NOSUCHKEY) - 1);
		else
			(void)fprintf(stderr, "%d: %.*s: %s",
			    lineno, MIN(kp->size, 20), kp->data, NOSUCHKEY);
#undef	NOSUCHKEY
		break;
	}
}

void
getdata(dbp, kp, dp)
	DB *dbp;
	DBT *kp, *dp;
{
	switch (dbp->get(dbp, kp, dp, flags)) {
	case 0:
		return;
	case -1:
		dberr("line %lu: getdata: %s", lineno, strerror(errno));
		/* NOTREACHED */
	case 1:
		dberr("line %lu: getdata failed, no such key", lineno);
		/* NOTREACHED */
	}
}

void
put(dbp, kp, dp)
	DB *dbp;
	DBT *kp, *dp;
{
	switch (dbp->put(dbp, kp, dp, flags)) {
	case 0:
		break;
	case -1:
		dberr("line %lu: put: %s", lineno, strerror(errno));
		/* NOTREACHED */
	case 1:
		(void)write(ofd, NOOVERWRITE, sizeof(NOOVERWRITE) - 1);
		break;
	}
}

void
rem(dbp, kp)
	DB *dbp;
	DBT *kp;
{
	switch (dbp->del(dbp, kp, flags)) {
	case 0:
		break;
	case -1:
		dberr("line %lu: rem: %s", lineno, strerror(errno));
		/* NOTREACHED */
	case 1:
#define	NOSUCHKEY	"rem failed, no such key\n"
		if (ofd != STDOUT_FILENO)
			(void)write(ofd, NOSUCHKEY, sizeof(NOSUCHKEY) - 1);
		else if (flags != R_CURSOR)
			(void)fprintf(stderr, "%d: %.*s: %s", 
			    lineno, MIN(kp->size, 20), kp->data, NOSUCHKEY);
		else
			(void)fprintf(stderr,
			    "%d: rem of cursor failed\n", lineno);
#undef	NOSUCHKEY
		break;
	}
}

void
synk(dbp)
	DB *dbp;
{
	switch (dbp->sync(dbp, flags)) {
	case 0:
		break;
	case -1:
		dberr("line %lu: synk: %s", lineno, strerror(errno));
		/* NOTREACHED */
	}
}

void
seq(dbp, kp)
	DB *dbp;
	DBT *kp;
{
	DBT data;

	switch (dbp->seq(dbp, kp, &data, flags)) {
	case 0:
		(void)write(ofd, data.data, data.size);
		if (ofd == STDOUT_FILENO)
			(void)write(ofd, "\n", 1);
		break;
	case -1:
		dberr("line %lu: seq: %s", lineno, strerror(errno));
		/* NOTREACHED */
	case 1:
#define	NOSUCHKEY	"seq failed, no such key\n"
		if (ofd != STDOUT_FILENO)
			(void)write(ofd, NOSUCHKEY, sizeof(NOSUCHKEY) - 1);
		else if (flags == R_CURSOR)
			(void)fprintf(stderr, "%d: %.*s: %s", 
			    lineno, MIN(kp->size, 20), kp->data, NOSUCHKEY);
		else
			(void)fprintf(stderr,
			    "%d: seq (%s) failed\n", lineno, sflags(flags));
#undef	NOSUCHKEY
		break;
	}
}

void
dump(dbp, rev)
	DB *dbp;
	int rev;
{
	DBT key, data;
	int flags, nflags;

	if (rev) {
		flags = R_LAST;
		nflags = R_PREV;
	} else {
		flags = R_FIRST;
		nflags = R_NEXT;
	}
	for (;; flags = nflags)
		switch (dbp->seq(dbp, &key, &data, flags)) {
		case 0:
			(void)write(ofd, data.data, data.size);
			if (ofd == STDOUT_FILENO)
				(void)write(ofd, "\n", 1);
			break;
		case 1:
			goto done;
		case -1:
			dberr("line %lu: (dump) seq: %s",
			    lineno, strerror(errno));
			/* NOTREACHED */
		}
done:	return;
}
	
u_int
setflags(s)
	char *s;
{
	char *p;

	for (; isspace((unsigned char)*s); ++s);
	if (*s == '\n' || *s == '\0')
		return (0);
	if ((p = strchr(s, '\n')) != NULL)
		*p = '\0';
	if (!strcmp(s, "R_CURSOR"))		return (R_CURSOR);
	if (!strcmp(s, "R_FIRST"))		return (R_FIRST);
	if (!strcmp(s, "R_IAFTER")) 		return (R_IAFTER);
	if (!strcmp(s, "R_IBEFORE")) 		return (R_IBEFORE);
	if (!strcmp(s, "R_LAST")) 		return (R_LAST);
	if (!strcmp(s, "R_NEXT")) 		return (R_NEXT);
	if (!strcmp(s, "R_NOOVERWRITE"))	return (R_NOOVERWRITE);
	if (!strcmp(s, "R_PREV"))		return (R_PREV);
	if (!strcmp(s, "R_SETCURSOR"))		return (R_SETCURSOR);

	dberr("line %lu: %s: unknown flag", lineno, s);
	/* NOTREACHED */
}

char *
sflags(flags)
	int flags;
{
	switch (flags) {
	case R_CURSOR:		return ("R_CURSOR");
	case R_FIRST:		return ("R_FIRST");
	case R_IAFTER:		return ("R_IAFTER");
	case R_IBEFORE:		return ("R_IBEFORE");
	case R_LAST:		return ("R_LAST");
	case R_NEXT:		return ("R_NEXT");
	case R_NOOVERWRITE:	return ("R_NOOVERWRITE");
	case R_PREV:		return ("R_PREV");
	case R_SETCURSOR:	return ("R_SETCURSOR");
	}

	return ("UNKNOWN!");
}
	
DBTYPE
dbtype(s)
	char *s;
{
	if (!strcmp(s, "btree"))
		return (DB_BTREE);
	if (!strcmp(s, "hash"))
		return (DB_HASH);
	if (!strcmp(s, "recno"))
		return (DB_RECNO);
	dberr("%s: unknown type (use btree, hash or recno)", s);
	/* NOTREACHED */
}

void *
setinfo(type, s)
	DBTYPE type;
	char *s;
{
	static BTREEINFO ib;
	static HASHINFO ih;
	static RECNOINFO rh;
	char *eq;

	if ((eq = strchr(s, '=')) == NULL)
		dberr("%s: illegal structure set statement", s);
	*eq++ = '\0';
	if (!isdigit((unsigned char)*eq))
		dberr("%s: structure set statement must be a number", s);
		
	switch (type) {
	case DB_BTREE:
		if (!strcmp("flags", s)) {
			ib.flags = atoi(eq);
			return (&ib);
		}
		if (!strcmp("cachesize", s)) {
			ib.cachesize = atoi(eq);
			return (&ib);
		}
		if (!strcmp("maxkeypage", s)) {
			ib.maxkeypage = atoi(eq);
			return (&ib);
		}
		if (!strcmp("minkeypage", s)) {
			ib.minkeypage = atoi(eq);
			return (&ib);
		}
		if (!strcmp("lorder", s)) {
			ib.lorder = atoi(eq);
			return (&ib);
		}
		if (!strcmp("psize", s)) {
			ib.psize = atoi(eq);
			return (&ib);
		}
		break;
	case DB_HASH:
		if (!strcmp("bsize", s)) {
			ih.bsize = atoi(eq);
			return (&ih);
		}
		if (!strcmp("ffactor", s)) {
			ih.ffactor = atoi(eq);
			return (&ih);
		}
		if (!strcmp("nelem", s)) {
			ih.nelem = atoi(eq);
			return (&ih);
		}
		if (!strcmp("cachesize", s)) {
			ih.cachesize = atoi(eq);
			return (&ih);
		}
		if (!strcmp("lorder", s)) {
			ih.lorder = atoi(eq);
			return (&ih);
		}
		break;
	case DB_RECNO:
		if (!strcmp("flags", s)) {
			rh.flags = atoi(eq);
			return (&rh);
		}
		if (!strcmp("cachesize", s)) {
			rh.cachesize = atoi(eq);
			return (&rh);
		}
		if (!strcmp("lorder", s)) {
			rh.lorder = atoi(eq);
			return (&rh);
		}
		if (!strcmp("reclen", s)) {
			rh.reclen = atoi(eq);
			return (&rh);
		}
		if (!strcmp("bval", s)) {
			rh.bval = atoi(eq);
			return (&rh);
		}
		if (!strcmp("psize", s)) {
			rh.psize = atoi(eq);
			return (&rh);
		}
		break;
	}
	dberr("%s: unknown structure value", s);
	/* NOTREACHED */
}

void *
rfile(name, lenp)
	char *name;
	size_t *lenp;
{
	struct stat sb;
	void *p;
	int fd;
	char *np;

	for (; isspace((unsigned char)*name); ++name);
	if ((np = strchr(name, '\n')) != NULL)
		*np = '\0';
	if ((fd = open(name, O_RDONLY, 0)) < 0 ||
	    fstat(fd, &sb))
		dberr("%s: %s\n", name, strerror(errno));
	if (sb.st_size > (off_t)INT_MAX)
		dberr("%s: %s\n", name, strerror(E2BIG));
	if ((p = (void *)malloc((u_int)sb.st_size)) == NULL)
		dberr("%s", strerror(errno));
	(void)read(fd, p, (int)sb.st_size);
	*lenp = sb.st_size;
	(void)close(fd);
	return (p);
}

void *
xmalloc(text, len)
	char *text;
	size_t len;
{
	void *p;

	if ((p = (void *)malloc(len)) == NULL)
		dberr("%s", strerror(errno));
	memmove(p, text, len);
	return (p);
}

void
usage()
{
	(void)fprintf(stderr,
	    "usage: dbtest [-l] [-f file] [-i info] [-o file] type script\n");
	exit(1);
}

void
dberr(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	(void)fprintf(stderr, "dbtest: ");
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
	exit(1);
	/* NOTREACHED */
}
@


1.14
log
@Cast ctype functions' arguments to unsigned char.
@
text
@d1 1
a1 1
/*	$OpenBSD: dbtest.c,v 1.13 2015/02/06 23:21:58 millert Exp $	*/
d688 1
a688 1
	if (sb.st_size > (off_t)SIZE_MAX)
@


1.13
log
@SIZE_MAX is standard, we should be using it in preference to the
obsolete SIZE_T_MAX.  OK miod@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dbtest.c,v 1.12 2009/10/27 23:59:32 deraadt Exp $	*/
d162 1
a162 1
		if ((len = strlen(buf)) == 0 || isspace(*p) || *p == '#')
d524 1
a524 1
	for (; isspace(*s); ++s);
d589 1
a589 1
	if (!isdigit(*eq))
d682 1
a682 1
	for (; isspace(*name); ++name);
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: dbtest.c,v 1.11 2003/07/31 21:48:02 deraadt Exp $	*/
d39 1
a39 1
#include <limits.h>
d688 1
a688 2
#ifdef NOT_PORTABLE
	if (sb.st_size > (off_t)SIZE_T_MAX)
a689 1
#endif
@


1.11
log
@various cleanups; david says results are same
@
text
@d1 1
a1 1
/*	$OpenBSD: dbtest.c,v 1.10 2003/06/02 19:38:25 millert Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1992, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)dbtest.c	8.17 (Berkeley) 9/1/94";
#else
static char rcsid[] = "$OpenBSD: dbtest.c,v 1.10 2003/06/02 19:38:25 millert Exp $";
#endif
#endif /* not lint */
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dbtest.c,v 1.9 2002/02/19 19:39:38 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: dbtest.c,v 1.9 2002/02/19 19:39:38 millert Exp $";
d91 1
a91 3
main(argc, argv)
	int argc;
	char *argv[];
d159 1
a159 1
		(void)sprintf(buf, "%s/__dbtest", p);
@


1.9
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: dbtest.c,v 1.8 2002/02/18 21:40:46 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: dbtest.c,v 1.8 2002/02/18 21:40:46 millert Exp $";
@


1.8
log
@Rename private err() function to dberr() to avoid collision with
libc's err().
@
text
@d1 1
a1 1
/*	$OpenBSD: dbtest.c,v 1.7 2002/02/16 21:27:32 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dbtest.c,v 1.7 2002/02/16 21:27:32 millert Exp $";
d61 1
a740 6
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a741 1
#ifdef __STDC__
a742 5
#else
dberr(fmt, va_alist)
	char *fmt;
        va_dcl
#endif
d745 1
a745 1
#ifdef __STDC__
a746 3
#else
	va_start(ap);
#endif
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: dbtest.c,v 1.6 2001/01/29 02:05:40 niklas Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dbtest.c,v 1.6 2001/01/29 02:05:40 niklas Exp $";
d70 1
a70 1
void	 err(const char *, ...);
d125 1
a125 1
				err("%s: %s", optarg, strerror(errno));
d145 1
a145 1
	    err("%s: %s", *argv, strerror(errno));
d172 1
a172 1
		err("dbopen: %s", strerror(errno));
d190 2
a191 1
				err("line %lu: not expecting command", lineno);
d197 2
a198 1
				err("line %lu: not expecting command", lineno);
d204 1
a204 1
				err("write: %s", strerror(errno));
d208 2
a209 1
				err("line %lu: not expecting command", lineno);
d215 2
a216 1
				err("line %lu: not expecting command", lineno);
d222 2
a223 1
				err("line %lu: not expecting command", lineno);
d234 2
a235 1
				err("line %lu: not expecting command", lineno);
d241 2
a242 1
				err("line %lu: not expecting command", lineno);
d254 1
a254 1
				err("line %lu: not expecting data", lineno);
d259 1
a259 1
				err("line %lu: not expecting data", lineno);
d270 1
a270 1
				err("line %lu: command doesn't take data",
d280 1
a280 1
				err("line %lu: not expecting a key", lineno);
d282 1
a282 1
				err("line %lu: 'K' not available for recno",
d288 1
a288 1
				err("line %lu: not expecting a key", lineno);
d325 1
a325 1
				err("line %lu: command doesn't take a key",
d333 1
a333 1
			err("line %lu: %s: unknown command character",
d346 1
a346 1
		err("db->close: %s", strerror(errno));
d387 1
a387 1
		err("line %lu: get: %s", lineno, strerror(errno));
d410 1
a410 1
		err("line %lu: getdata: %s", lineno, strerror(errno));
d413 1
a413 1
		err("line %lu: getdata failed, no such key", lineno);
d427 1
a427 1
		err("line %lu: put: %s", lineno, strerror(errno));
d444 1
a444 1
		err("line %lu: rem: %s", lineno, strerror(errno));
d469 1
a469 1
		err("line %lu: synk: %s", lineno, strerror(errno));
d488 1
a488 1
		err("line %lu: seq: %s", lineno, strerror(errno));
d530 1
a530 1
			err("line %lu: (dump) seq: %s",
d558 1
a558 1
	err("line %lu: %s: unknown flag", lineno, s);
d591 1
a591 1
	err("%s: unknown type (use btree, hash or recno)", s);
d606 1
a606 1
		err("%s: illegal structure set statement", s);
d609 1
a609 1
		err("%s: structure set statement must be a number", s);
d687 1
a687 1
	err("%s: unknown structure value", s);
d706 1
a706 1
		err("%s: %s\n", name, strerror(errno));
d709 1
a709 1
		err("%s: %s\n", name, strerror(E2BIG));
d712 1
a712 1
		err("%s", strerror(errno));
d727 1
a727 1
		err("%s", strerror(errno));
d748 1
a748 1
err(const char *fmt, ...)
d750 1
a750 1
err(fmt, va_alist)
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: dbtest.c,v 1.8 1996/05/03 21:57:48 cgd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dbtest.c,v 1.8 1996/05/03 21:57:48 cgd Exp $";
d67 16
a82 16
void	 compare __P((DBT *, DBT *));
DBTYPE	 dbtype __P((char *));
void	 dump __P((DB *, int));
void	 err __P((const char *, ...));
void	 get __P((DB *, DBT *));
void	 getdata __P((DB *, DBT *, DBT *));
void	 put __P((DB *, DBT *, DBT *));
void	 rem __P((DB *, DBT *));
char	*sflags __P((int));
void	 synk __P((DB *));
void	*rfile __P((char *, size_t *));
void	 seq __P((DB *, DBT *));
u_int	 setflags __P((char *));
void	*setinfo __P((DBTYPE, char *));
void	 usage __P((void));
void	*xmalloc __P((char *, size_t));
@


1.5
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: dbtest.c,v 1.8 1996/05/03 21:57:48 cgd Exp $";
@


1.4
log
@r?index -> strr?chr
@
text
@d732 1
a732 1
#if __STDC__
d739 1
a739 1
#if __STDC__
d748 1
a748 1
#if __STDC__
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d533 1
a533 1
	char *p, *index();
d538 1
a538 1
	if ((p = index(s, '\n')) != NULL)
d595 1
a595 1
	char *eq, *index();
d597 1
a597 1
	if ((eq = index(s, '=')) == NULL)
d691 1
a691 1
	char *np, *index();
d694 1
a694 1
	if ((np = index(name, '\n')) != NULL)
@


1.2
log
@db release 1.85
@
text
@d110 1
a110 1
	while ((ch = getopt(argc, argv, "f:i:lo:s")) != EOF)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: dbtest.c,v 1.7 1995/04/20 22:39:22 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1992, 1993
d38 1
a38 1
"@@(#) Copyright (c) 1992, 1993\n\
d44 1
a44 1
static char sccsid[] = "@@(#)dbtest.c	8.8 (Berkeley) 2/21/94";
d46 1
a46 1
static char rcsid[] = "$NetBSD: dbtest.c,v 1.7 1995/04/20 22:39:22 cgd Exp $";
d74 2
d83 5
a87 5
DBTYPE type;
void *infop;
u_long lineno;
u_int flags;
int ofd = STDOUT_FILENO;
d90 1
d103 2
a104 2
	int ch, oflags;
	char *fname, *infoarg, *p, buf[8 * 1024];
d109 3
a111 2
	while ((ch = getopt(argc, argv, "f:i:lo:")) != EOF)
		switch(ch) {
d126 3
d143 2
a144 2
	if (freopen(*argv, "r", stdin) == NULL)
		err("%s: %s", *argv, strerror(errno));
d155 4
a158 1
	/* Open the DB. */
d166 3
a168 1
	}
d177 10
a186 2
		len = strlen(buf);
		switch(*p) {
d199 2
a200 1
			if (write(ofd, p + 1, len - 1) != len - 1)
d218 13
a230 2
			state = KEY;
			command = REMOVE;
d254 1
a254 1
ldata:			switch(command) {
d290 1
a290 1
lkey:			switch(command) {
d306 1
a306 1
				if (type != DB_RECNO)
d312 1
a312 1
				if (type != DB_RECNO)
d326 1
a326 1
			    p, lineno);
d330 5
a334 1
	if (type == DB_BTREE)
a343 1
#define	NOSUCHKEY	"get failed, no such key\n"
d372 1
a372 1
	switch(dbp->get(dbp, kp, &data, flags)) {
d375 2
d382 7
a388 3
		(void)write(ofd, NOSUCHKEY, sizeof(NOSUCHKEY) - 1);
		(void)fprintf(stderr, "%d: %.*s: %s\n", 
		    lineno, kp->size, kp->data, NOSUCHKEY);
d398 1
a398 1
	switch(dbp->get(dbp, kp, dp, flags)) {
d405 1
a405 1
		err("line %lu: get failed, no such key", lineno);
d415 1
a415 1
	switch(dbp->put(dbp, kp, dp, flags)) {
d432 1
a432 1
	switch(dbp->del(dbp, kp, flags)) {
d436 1
a436 1
		err("line %lu: get: %s", lineno, strerror(errno));
d439 20
a458 1
		(void)write(ofd, NOSUCHKEY, sizeof(NOSUCHKEY) - 1);
d460 3
d473 1
a473 1
	switch(dbp->seq(dbp, kp, &data, flags)) {
d476 2
d483 10
a492 1
		(void)write(ofd, NOSUCHKEY, sizeof(NOSUCHKEY) - 1);
d513 1
a513 1
		switch(dbp->seq(dbp, &key, &data, flags)) {
d516 2
d536 1
a536 1
	if (*s == '\n')
d540 10
a549 18
	if (!strcmp(s, "R_CURSOR"))
		return (R_CURSOR);
	if (!strcmp(s, "R_FIRST"))
		return (R_FIRST);
	if (!strcmp(s, "R_IAFTER"))
		return (R_IAFTER);
	if (!strcmp(s, "R_IBEFORE"))
		return (R_IBEFORE);
	if (!strcmp(s, "R_LAST"))
		return (R_LAST);
	if (!strcmp(s, "R_NEXT"))
		return (R_NEXT);
	if (!strcmp(s, "R_NOOVERWRITE"))
		return (R_NOOVERWRITE);
	if (!strcmp(s, "R_PREV"))
		return (R_PREV);
	if (!strcmp(s, "R_SETCURSOR"))
		return (R_SETCURSOR);
d553 19
d603 1
a603 1
	switch(type) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
