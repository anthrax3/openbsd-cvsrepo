head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.40
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.38
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.34
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.24
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.32
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.30
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.28
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.26
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.22
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.20
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.18
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.16
	OPENBSD_5_0:1.5.0.14
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.12
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.10
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.6
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.8
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.4
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2008.04.13.00.22.17;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.04.12.02.57;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.11.08.16.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.31.21.48.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.15.10.09.37;	author otto;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Use arc4random_buf() when requesting more than a single word of output

Use arc4random_uniform() when the desired random number upper bound
is not a power of two

ok deraadt@@ millert@@
@
text
@/*	$OpenBSD: malloc0test.c,v 1.4 2004/08/04 12:02:57 otto Exp $	*/
/*
 * Public domain.  2001, Theo de Raadt
 */
#include <sys/types.h>
#include <sys/signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <setjmp.h>
#include <limits.h>
#include <errno.h>

volatile sig_atomic_t got;
jmp_buf jmp;

static void
catch(int signo)
{
	got++;
	longjmp(jmp, 1);
}

static int
test(char *p, int size)
{
	signal(SIGSEGV, catch);
	got = 0;
	if (setjmp(jmp) == 0)
		*p = 0;
	if (setjmp(jmp) == 0)
		*(p+size-1) = 0;
	return (got);
}

char *prot_table[] = {
	"unprotected",
	"fuckup",
	"protected"
};

#define SIZE	10

/*
 * Do random memory allocations.
 *
 * For each one, ensure that it is at least 16 bytes in size (that
 * being what our current malloc returns for the minsize of an
 * object, alignment wise);
 *
 * For zero-byte allocations, check that they are still aligned.
 *
 * For each object, ensure that they are correctly protected or not
 * protected.
 *
 * Does not regress test malloc + free combinations ... it should.
 */
int
main(int argc, char *argv[])
{
	caddr_t blob;
	int size, tsize;
	int prot;
	int rval = 0, fuckup = 0;
	long limit = 200000, count;
	int ch, silent = 0;
	char *ep;
	extern char *__progname;

	while ((ch = getopt(argc, argv, "sn:")) != -1) {
		switch (ch) {
		case 's':
			silent = 1;
			break;
		case 'n':
			errno = 0;
			limit = strtol(optarg, &ep, 10);
			if (optarg[0] == '\0' || *ep != '\0' ||
			    (errno == ERANGE &&
			     (limit == LONG_MAX || limit == LONG_MIN)))
				goto usage;
			break;
		default:
usage:
			fprintf(stderr, "Usage: %s [-s][-n <count>]\n",
			    __progname);
			exit(1);
		}
	}

	if (limit == 0)
		limit = LONG_MAX;

	for (count = 0; count < limit; count++) {
		size = arc4random_uniform(SIZE);
		blob = malloc(size);
		if (blob == NULL) {
			fprintf(stderr, "success: out of memory\n");
			exit(rval);
		}

		tsize = size == 0 ? 16 : size;
		fuckup = 0;
		prot = test(blob, tsize);

		if (size == 0 && prot < 2)
			fuckup = 1;

		if (fuckup) {
			printf("%8p %6d %20s %10s\n", blob, size,
			    prot_table[prot], fuckup ? "fuckup" : "");
			rval = 1;
		}

		if (!silent && count % 100000 == 0 && count != 0)
			fprintf(stderr, "count = %ld\n", count);
	}

	return rval;
}
@


1.4
log
@Unbreak malloc0test for use with mmap malloc which allocates objects
in a non-contiguous manner. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malloc0test.c,v 1.3 2004/02/11 08:16:00 deraadt Exp $	*/
d95 1
a95 1
		size = arc4random() % SIZE;
@


1.3
log
@EOL at end
@
text
@d1 1
a1 1
/*	$OpenBSD: malloc0test.c,v 1.2 2003/07/31 21:48:03 deraadt Exp $	*/
d61 2
a62 4
	caddr_t rblob = malloc(1);
	caddr_t zblob = malloc(0);
	caddr_t *blobp, blob;
	int size, rsize, tsize;
d102 2
a103 10
		if (size == 0) {
			blobp = &zblob;
			tsize = 16;
		} else {
			blobp = &rblob;
			tsize = size;
		}

		rsize = blob - *blobp;
		fuckup = SIZE < 16 && size >= rsize;
a105 2
		if (size == 0 && rsize < 16)
			fuckup = 1;
d110 1
a110 1
			printf("%8p %6d %6d %20s %10s\n", blob, size, rsize,
a113 1
		*blobp = blob;
d116 1
a116 1
			fprintf(stderr, "count = %d\n", count);
@


1.2
log
@various cleanups; david says results are same
@
text
@d1 1
a1 1
/*	$OpenBSD: malloc0test.c,v 1.1 2003/07/15 10:09:37 otto Exp $	*/
d133 1
a133 1
}@


1.1
log
@move malloc0test.c to new subdir.
ok tdeval@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: malloc0test.c,v 1.5 2002/02/18 11:29:50 art Exp $	*/
d17 1
a17 1
void
d24 1
a24 1
int
@

