head	1.6;
access;
symbols
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5;
locks; strict;
comment	@ * @;


1.6
date	2003.07.15.10.09.37;	author otto;	state dead;
branches;
next	1.5;

1.5
date	2002.02.18.11.29.50;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.04.12.50.36;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.29.18.59.30;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.22.09.10.14;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.12.05.09.52.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.6
log
@move malloc0test.c to new subdir.
ok tdeval@@ millert@@
@
text
@/*	$OpenBSD: malloc0test.c,v 1.5 2002/02/18 11:29:50 art Exp $	*/
/*
 * Public domain.  2001, Theo de Raadt
 */
#include <sys/types.h>
#include <sys/signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <setjmp.h>
#include <limits.h>
#include <errno.h>

volatile sig_atomic_t got;
jmp_buf jmp;

void
catch(int signo)
{
	got++;
	longjmp(jmp, 1);
}

int
test(char *p, int size)
{
	signal(SIGSEGV, catch);
	got = 0;
	if (setjmp(jmp) == 0)
		*p = 0;
	if (setjmp(jmp) == 0)
		*(p+size-1) = 0;
	return (got);
}

char *prot_table[] = {
	"unprotected",
	"fuckup",
	"protected"
};

#define SIZE	10

/*
 * Do random memory allocations.
 *
 * For each one, ensure that it is at least 16 bytes in size (that
 * being what our current malloc returns for the minsize of an
 * object, alignment wise);
 *
 * For zero-byte allocations, check that they are still aligned.
 *
 * For each object, ensure that they are correctly protected or not
 * protected.
 *
 * Does not regress test malloc + free combinations ... it should.
 */
int
main(int argc, char *argv[])
{
	caddr_t rblob = malloc(1);
	caddr_t zblob = malloc(0);
	caddr_t *blobp, blob;
	int size, rsize, tsize;
	int prot;
	int rval = 0, fuckup = 0;
	long limit = 200000, count;
	int ch, silent = 0;
	char *ep;
	extern char *__progname;

	while ((ch = getopt(argc, argv, "sn:")) != -1) {
		switch (ch) {
		case 's':
			silent = 1;
			break;
		case 'n':
			errno = 0;
			limit = strtol(optarg, &ep, 10);
			if (optarg[0] == '\0' || *ep != '\0' ||
			    (errno == ERANGE &&
			     (limit == LONG_MAX || limit == LONG_MIN)))
				goto usage;
			break;
		default:
usage:
			fprintf(stderr, "Usage: %s [-s][-n <count>]\n",
			    __progname);
			exit(1);
		}
	}

	if (limit == 0)
		limit = LONG_MAX;

	for (count = 0; count < limit; count++) {
		size = arc4random() % SIZE;
		blob = malloc(size);
		if (blob == NULL) {
			fprintf(stderr, "success: out of memory\n");
			exit(rval);
		}

		if (size == 0) {
			blobp = &zblob;
			tsize = 16;
		} else {
			blobp = &rblob;
			tsize = size;
		}

		rsize = blob - *blobp;
		fuckup = SIZE < 16 && size >= rsize;
		prot = test(blob, tsize);

		if (size == 0 && rsize < 16)
			fuckup = 1;
		if (size == 0 && prot < 2)
			fuckup = 1;

		if (fuckup) {
			printf("%8p %6d %6d %20s %10s\n", blob, size, rsize,
			    prot_table[prot], fuckup ? "fuckup" : "");
			rval = 1;
		}
		*blobp = blob;

		if (!silent && count % 100000 == 0 && count != 0)
			fprintf(stderr, "count = %d\n", count);
	}

	return rval;
}@


1.5
log
@tags cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4
log
@A bug in the malloc test uncoveres a bug in longjmp on alpha.
How ironic.
@
text
@d1 1
@


1.3
log
@Add options for slient operation and for specifying a count of rounds
instead of running to the limit.
@
text
@d20 1
a20 1
	longjmp(jmp, 0);
d24 1
a24 1
test(caddr_t p, int size)
@


1.2
log
@add header
@
text
@d10 2
d64 1
a64 1
	int count = 0, prot;
d66 28
d95 1
a95 1
	while (1) {
d127 1
a127 2

		if (++count % 100000 == 0)
d130 2
@


1.1
log
@malloc(n) regression test
@
text
@d1 3
@

