head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.4
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.6
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.5
date	2015.10.30.15.45.57;	author miod;	state Exp;
branches;
next	1.4;
commitid	QhrN3pc9Qw2DDhdM;

1.4
date	2014.07.28.04.17.07;	author bcook;	state Exp;
branches;
next	1.3;
commitid	9j3XtYo6ERK7Ht1k;

1.3
date	2014.07.09.18.19.40;	author matthew;	state Exp;
branches;
next	1.2;
commitid	7Kd7IBaWFWZcvoVc;

1.2
date	2014.07.09.14.32.24;	author bcook;	state Exp;
branches;
next	1.1;
commitid	KcM9v9yWMUqCGnDu;

1.1
date	2014.06.18.08.24.00;	author matthew;	state Exp;
branches;
next	;
commitid	lm9iJ0qfV1AfSIlQ;


desc
@@


1.5
log
@Pull in <sys/types.h> to get ssize_t or <stdint.h> to get uint32_t, instead of
relying upon previously included headers to do this, to enhance portability;
from Pascal Cuoq, libressl github pull request #52
@
text
@/*
 * Copyright (c) 2014 Google Inc.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/mman.h>
#include <sys/wait.h>
#include <assert.h>
#include <err.h>
#include <errno.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>

#define CHECK(x) assert(x)
#define CHECK_EQ(a, b) assert((a) == (b))
#define CHECK_NE(a, b) assert((a) != (b))
#define CHECK_GE(a, b) assert((a) >= (b))
#define CHECK_LE(a, b) assert((a) <= (b))

/* Test arc4random_buf(3) instead of arc4random(3). */
static int flagbuf;

/* Initialize arc4random(3) before forking. */
static int flagprefork;

enum {
	N = 4096
};

typedef struct {
	uint32_t x[N];
} Buf;

static int
isfullbuf(const Buf *buf)
{
	size_t i;
	for (i = 0; i < N; i++)
		if (buf->x[i])
			return (1);
	return (0);
}

static void
fillbuf(Buf *buf)
{
	if (flagbuf) {
		arc4random_buf(buf->x, sizeof(buf->x));
	} else {
		size_t i;
		for (i = 0; i < N; i++)
			buf->x[i] = arc4random();
	}
}

static void
usage()
{
	errx(1, "usage: arc4random-fork [-bp]");
}

static pid_t
safewaitpid(pid_t pid, int *status, int options)
{
	pid_t ret;
	do {
		ret = waitpid(pid, status, options);
	} while (ret == -1 && errno == EINTR);
	return (ret);
}

int
main(int argc, char *argv[])
{
	int opt, status;
	Buf *bufparent, *bufchildone, *bufchildtwo;
	pid_t pidone, pidtwo;
	size_t i, countone = 0, counttwo = 0, countkids = 0;

	/* Ensure SIGCHLD isn't set to SIG_IGN. */
	const struct sigaction sa = {
		.sa_handler = SIG_DFL,
	};
	CHECK_EQ(0, sigaction(SIGCHLD, &sa, NULL));

	while ((opt = getopt(argc, argv, "bp")) != -1) {
		switch (opt) {
		case 'b':
			flagbuf = 1;
			break;
		case 'p':
			flagprefork = 1;
			break;
		default:
			usage();
		}
	}

	if (flagprefork)
		arc4random();

	bufparent = mmap(NULL, sizeof(Buf), PROT_READ|PROT_WRITE,
	    MAP_ANON|MAP_PRIVATE, -1, 0);
	CHECK_NE(MAP_FAILED, bufparent);

	bufchildone = mmap(NULL, sizeof(Buf), PROT_READ|PROT_WRITE,
	    MAP_ANON|MAP_SHARED, -1, 0);
	CHECK_NE(MAP_FAILED, bufchildone);

	bufchildtwo = mmap(NULL, sizeof(Buf), PROT_READ|PROT_WRITE,
	    MAP_ANON|MAP_SHARED, -1, 0);
	CHECK_NE(MAP_FAILED, bufchildtwo);

	pidone = fork();
	CHECK_GE(pidone, 0);
	if (pidone == 0) {
		fillbuf(bufchildone);
		_exit(0);
	}

	pidtwo = fork();
	CHECK_GE(pidtwo, 0);
	if (pidtwo == 0) {
		fillbuf(bufchildtwo);
		_exit(0);
	}

	fillbuf(bufparent);

	CHECK_EQ(pidone, safewaitpid(pidone, &status, 0));
	CHECK(WIFEXITED(status));
	CHECK_EQ(0, WEXITSTATUS(status));

	CHECK_EQ(pidtwo, safewaitpid(pidtwo, &status, 0));
	CHECK(WIFEXITED(status));
	CHECK_EQ(0, WEXITSTATUS(status));

	CHECK(isfullbuf(bufchildone));
	CHECK(isfullbuf(bufchildtwo));

	for (i = 0; i < N; i++) {
		countone += bufparent->x[i] == bufchildone->x[i];
		counttwo += bufparent->x[i] == bufchildtwo->x[i];
		countkids += bufchildone->x[i] == bufchildtwo->x[i];
	}

	/*
	 * These checks are inherently probabilistic and theoretically risk
	 * flaking, but there's less than a 1 in 2^40 chance of more than
	 * one pairwise match between two vectors of 4096 32-bit integers.
	 */
	CHECK_LE(countone, 1);
	CHECK_LE(counttwo, 1);
	CHECK_LE(countkids, 1);

	return (0);
}
@


1.4
log
@remove non-portable __progname extern from arc4random unit test.

ok @@deraadt
@
text
@d26 1
@


1.3
log
@Minor cleanups

Rename _waitpid() to safewaitpid() to avoid POSIX reserved identifier
namespace.

KNF nit: return value expressions should be surrounded by parentheses,
per style(9).

Ensure SIGCHLD is set to SIG_DFL, not SIG_IGN.  POSIX allows (and
requires under XSI) that terminated child processes not leave zombies
if SIGCHLD is set to SIG_IGN, and it also allows execve() to leave
SIGCHLD set to SIG_IGN.
@
text
@d72 1
a72 2
	extern const char *__progname;
	errx(1, "usage: %s [-bp]", __progname);
@


1.2
log
@check for EINTR when calling waitpid.

ok jsing@@
@
text
@d22 1
d77 1
a77 1
_waitpid(pid_t pid, int *stat_loc, int options)
d81 1
a81 1
		ret = waitpid(pid, stat_loc, options);
d83 1
a83 1
	return ret;
d94 6
d144 1
a144 1
	CHECK_EQ(pidone, _waitpid(pidone, &status, 0));
d148 1
a148 1
	CHECK_EQ(pidtwo, _waitpid(pidtwo, &status, 0));
@


1.1
log
@Add regress tests to make sure arc4random(3) is reinitialized
correctly in fork children.
@
text
@d21 1
d75 10
d137 1
a137 1
	CHECK_EQ(pidone, waitpid(pidone, &status, 0));
d141 1
a141 1
	CHECK_EQ(pidtwo, waitpid(pidtwo, &status, 0));
@

