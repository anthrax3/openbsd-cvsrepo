head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.18
date	2017.02.23.14.14.37;	author inoguchi;	state Exp;
branches;
next	1.17;
commitid	rfsMEAAanydeAWKe;

1.17
date	2017.02.07.14.24.34;	author bluhm;	state Exp;
branches;
next	1.16;
commitid	maeaegO7HM0CQU6s;

1.16
date	2017.01.31.13.19.05;	author inoguchi;	state Exp;
branches;
next	1.15;
commitid	jWPl3rfpMhbtEsog;

1.15
date	2017.01.21.09.38.58;	author beck;	state Exp;
branches;
next	1.14;
commitid	iyR9b2itDMsxzmrQ;

1.14
date	2016.12.21.15.51.05;	author jsing;	state Exp;
branches;
next	1.13;
commitid	GAcmh2hIDAaXgRYG;

1.13
date	2016.09.03.17.32.06;	author bcook;	state Exp;
branches;
next	1.12;
commitid	B39plLOp9Mo5nFCU;

1.12
date	2016.07.05.03.55.34;	author bcook;	state Exp;
branches;
next	1.11;
commitid	LWQFONOqWNcHrx2o;

1.11
date	2016.07.05.02.54.35;	author bcook;	state Exp;
branches;
next	1.10;
commitid	NHesUMO050EuY7RN;

1.10
date	2016.03.13.18.22.43;	author bcook;	state Exp;
branches;
next	1.9;
commitid	zT7q7r9ILH478PF9;

1.9
date	2015.07.18.17.36.50;	author bcook;	state Exp;
branches;
next	1.8;
commitid	6tyZ6VeFnA3ifase;

1.8
date	2015.07.18.17.34.39;	author bcook;	state Exp;
branches;
next	1.7;
commitid	F9K7H9trWg5gkKy6;

1.7
date	2015.02.25.15.39.49;	author bcook;	state Exp;
branches;
next	1.6;
commitid	nC7C8zA8FXXV2GZG;

1.6
date	2015.02.19.05.12.01;	author jsing;	state Exp;
branches;
next	1.5;
commitid	657LmKU2w3GtUPA1;

1.5
date	2015.02.19.05.09.19;	author jsing;	state Exp;
branches;
next	1.4;
commitid	fK6Njx4wUHRuLdXJ;

1.4
date	2015.02.15.09.46.47;	author miod;	state Exp;
branches;
next	1.3;
commitid	EbuhvdQPLY4YkigF;

1.3
date	2014.10.22.13.18.16;	author jsing;	state Exp;
branches;
next	1.2;
commitid	HGl8T3xcQ2Bk6NnW;

1.2
date	2014.07.11.20.52.59;	author miod;	state Exp;
branches;
next	1.1;
commitid	ophyc25nfyacjeB6;

1.1
date	2014.06.20.10.30.40;	author miod;	state Exp;
branches;
next	;
commitid	0Iw3GMevDit5qr6R;


desc
@@


1.18
log
@Check return value of every BN_* functions in bntest
- add macro CHECK_GOTO
- unify function return code to rc
- add err: label for error goto
ok bcook@@
@
text
@/* crypto/bn/bntest.c */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 *
 * Portions of the attached software ("Contribution") are developed by
 * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.
 *
 * The Contribution is licensed pursuant to the Eric Young open source
 * license provided above.
 *
 * The binary polynomial arithmetic software is originally written by
 * Sheueling Chang Shantz and Douglas Stebila of Sun Microsystems Laboratories.
 *
 */

/* Until the key-gen callbacks are modified to use newer prototypes, we allow
 * deprecated functions for openssl-internal code */
#ifdef OPENSSL_NO_DEPRECATED
#undef OPENSSL_NO_DEPRECATED
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/bio.h>
#include <openssl/bn.h>
#include <openssl/x509.h>
#include <openssl/err.h>

int BN_mod_exp_ct(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
    const BIGNUM *m, BN_CTX *ctx);
int BN_mod_exp_nonct(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
    const BIGNUM *m, BN_CTX *ctx);
int BN_mod_exp_mont_ct(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
int BN_mod_exp_mont_nonct(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);

int BN_bntest_rand(BIGNUM *rnd, int bits, int top, int bottom);

const int num0 = 100; /* number of tests */
const int num1 = 50;  /* additional tests for some functions */
const int num2 = 5;   /* number of tests for slow functions */

int test_add(BIO *bp);
int test_sub(BIO *bp);
int test_lshift1(BIO *bp);
int test_lshift(BIO *bp, BN_CTX *ctx, BIGNUM *a_);
int test_rshift1(BIO *bp);
int test_rshift(BIO *bp, BN_CTX *ctx);
int test_div(BIO *bp, BN_CTX *ctx);
int test_div_word(BIO *bp);
int test_div_recp(BIO *bp, BN_CTX *ctx);
int test_mul(BIO *bp);
int test_sqr(BIO *bp, BN_CTX *ctx);
int test_mont(BIO *bp, BN_CTX *ctx);
int test_mod(BIO *bp, BN_CTX *ctx);
int test_mod_mul(BIO *bp, BN_CTX *ctx);
int test_mod_exp(BIO *bp, BN_CTX *ctx);
int test_mod_exp_mont_consttime(BIO *bp, BN_CTX *ctx);
int test_mod_exp_mont5(BIO *bp, BN_CTX *ctx);
int test_mod_exp_sizes(BIO *bp, BN_CTX *ctx);
int test_exp(BIO *bp, BN_CTX *ctx);
int test_gf2m_add(BIO *bp);
int test_gf2m_mod(BIO *bp);
int test_gf2m_mod_mul(BIO *bp, BN_CTX *ctx);
int test_gf2m_mod_sqr(BIO *bp, BN_CTX *ctx);
int test_gf2m_mod_inv(BIO *bp, BN_CTX *ctx);
int test_gf2m_mod_div(BIO *bp, BN_CTX *ctx);
int test_gf2m_mod_exp(BIO *bp, BN_CTX *ctx);
int test_gf2m_mod_sqrt(BIO *bp, BN_CTX *ctx);
int test_gf2m_mod_solve_quad(BIO *bp, BN_CTX *ctx);
int test_kron(BIO *bp, BN_CTX *ctx);
int test_sqrt(BIO *bp, BN_CTX *ctx);
int rand_neg(void);
static int results = 0;

static unsigned char lst[] =
	"\xC6\x4F\x43\x04\x2A\xEA\xCA\x6E\x58\x36\x80\x5B\xE8\xC9"
	"\x9B\x04\x5D\x48\x36\xC2\xFD\x16\xC9\x64\xF0";

#define PRINT_ERROR printf("Error in %s [%s:%d]\n", __func__, __FILE__,	\
		__LINE__)

#define CHECK_GOTO(a) do {						\
	if (!(a)) {							\
		PRINT_ERROR;						\
		rc = 0;							\
		goto err;						\
	}								\
} while (0)

static void
message(BIO *out, char *m)
{
	fprintf(stderr, "test %s\n", m);
	BIO_puts(out, "print \"test ");
	BIO_puts(out, m);
	BIO_puts(out, "\\n\"\n");
}

int
main(int argc, char *argv[])
{
	BN_CTX *ctx;
	BIO *out;
	char *outfile = NULL;

	results = 0;

	argc--;
	argv++;
	while (argc >= 1) {
		if (strcmp(*argv, "-results") == 0)
			results = 1;
		else if (strcmp(*argv, "-out") == 0) {
			if (--argc < 1)
				break;
			outfile= *(++argv);
		}
		argc--;
		argv++;
	}


	ctx = BN_CTX_new();
	if (ctx == NULL)
		exit(1);

	out = BIO_new(BIO_s_file());
	if (out == NULL)
		exit(1);
	if (outfile == NULL) {
		BIO_set_fp(out, stdout, BIO_NOCLOSE);
	} else {
		if (!BIO_write_filename(out, outfile)) {
			perror(outfile);
			exit(1);
		}
	}

	if (!results)
		BIO_puts(out, "obase=16\nibase=16\n");

	message(out, "BN_add");
	if (!test_add(out))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_sub");
	if (!test_sub(out))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_lshift1");
	if (!test_lshift1(out))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_lshift (fixed)");
	if (!test_lshift(out, ctx, BN_bin2bn(lst, sizeof(lst) - 1, NULL)))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_lshift");
	if (!test_lshift(out, ctx, NULL))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_rshift1");
	if (!test_rshift1(out))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_rshift");
	if (!test_rshift(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_sqr");
	if (!test_sqr(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_mul");
	if (!test_mul(out))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_div");
	if (!test_div(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_div_word");
	if (!test_div_word(out))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_div_recp");
	if (!test_div_recp(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_mod");
	if (!test_mod(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_mod_mul");
	if (!test_mod_mul(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_mont");
	if (!test_mont(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_mod_exp");
	if (!test_mod_exp(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_mod_exp_mont_consttime");
	if (!test_mod_exp_mont_consttime(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_mod_exp_mont5");
	if (!test_mod_exp_mont5(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_exp");
	if (!test_exp(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_kronecker");
	if (!test_kron(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_mod_sqrt");
	if (!test_sqrt(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "Modexp with different sizes");
	if (!test_mod_exp_sizes(out, ctx))
		goto err;
	(void)BIO_flush(out);

#ifndef OPENSSL_NO_EC2M
	message(out, "BN_GF2m_add");
	if (!test_gf2m_add(out))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_GF2m_mod");
	if (!test_gf2m_mod(out))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_GF2m_mod_mul");
	if (!test_gf2m_mod_mul(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_GF2m_mod_sqr");
	if (!test_gf2m_mod_sqr(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_GF2m_mod_inv");
	if (!test_gf2m_mod_inv(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_GF2m_mod_div");
	if (!test_gf2m_mod_div(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_GF2m_mod_exp");
	if (!test_gf2m_mod_exp(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_GF2m_mod_sqrt");
	if (!test_gf2m_mod_sqrt(out, ctx))
		goto err;
	(void)BIO_flush(out);

	message(out, "BN_GF2m_mod_solve_quad");
	if (!test_gf2m_mod_solve_quad(out, ctx))
		goto err;
	(void)BIO_flush(out);
#endif
	BN_CTX_free(ctx);
	BIO_free(out);

	exit(0);
err:
	BIO_puts(out, "1\n"); /* make sure the Perl script fed by bc notices
	                       * the failure, see test_bn in test/Makefile.ssl*/

	(void)BIO_flush(out);
	ERR_load_crypto_strings();
	ERR_print_errors_fp(stderr);
	exit(1);
}

int
test_add(BIO *bp)
{
	BIGNUM a, b, c;
	int i;
	int rc = 1;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);

	CHECK_GOTO(BN_bntest_rand(&a, 512, 0, 0));
	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_bntest_rand(&b, 450 + i, 0, 0));
		a.neg = rand_neg();
		b.neg = rand_neg();
		CHECK_GOTO(BN_add(&c, &a, &b));
		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, &a));
				BIO_puts(bp, " + ");
				CHECK_GOTO(BN_print(bp, &b));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, &c));
			BIO_puts(bp, "\n");
		}
		a.neg = !a.neg;
		b.neg = !b.neg;
		CHECK_GOTO(BN_add(&c, &c, &b));
		CHECK_GOTO(BN_add(&c, &c, &a));
		if (!BN_is_zero(&c)) {
			fprintf(stderr, "Add test failed!\n");
			rc = 0;
			break;
		}
	}
err:
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	return (rc);
}

int
test_sub(BIO *bp)
{
	BIGNUM a, b, c;
	int i;
	int rc = 1;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);

	for (i = 0; i < num0 + num1; i++) {
		if (i < num1) {
			CHECK_GOTO(BN_bntest_rand(&a, 512, 0, 0));
			CHECK_GOTO(BN_copy(&b, &a));
			if (BN_set_bit(&a, i) == 0) {
				rc = 0;
				break;
			}
			CHECK_GOTO(BN_add_word(&b, i));
		} else {
			CHECK_GOTO(BN_bntest_rand(&b, 400 + i - num1, 0, 0));
			a.neg = rand_neg();
			b.neg = rand_neg();
		}
		CHECK_GOTO(BN_sub(&c, &a, &b));
		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, &a));
				BIO_puts(bp, " - ");
				CHECK_GOTO(BN_print(bp, &b));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, &c));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_add(&c, &c, &b));
		CHECK_GOTO(BN_sub(&c, &c, &a));
		if (!BN_is_zero(&c)) {
			fprintf(stderr, "Subtract test failed!\n");
			rc = 0;
			break;
		}
	}
err:
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	return (rc);
}

int
test_div(BIO *bp, BN_CTX *ctx)
{
	BIGNUM a, b, c, d, e;
	int i;
	int rc = 1;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);

	CHECK_GOTO(BN_one(&a));
	CHECK_GOTO(BN_zero(&b));

	if (BN_div(&d, &c, &a, &b, ctx)) {
		fprintf(stderr, "Division by zero succeeded!\n");
		return (0);
	}

	for (i = 0; i < num0 + num1; i++) {
		if (i < num1) {
			CHECK_GOTO(BN_bntest_rand(&a, 400, 0, 0));
			CHECK_GOTO(BN_copy(&b, &a));
			CHECK_GOTO(BN_lshift(&a, &a, i));
			CHECK_GOTO(BN_add_word(&a, i));
		} else
			CHECK_GOTO(BN_bntest_rand(&b, 50 + 3 * (i - num1), 0, 0));
		a.neg = rand_neg();
		b.neg = rand_neg();
		CHECK_GOTO(BN_div(&d, &c, &a, &b, ctx));
		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, &a));
				BIO_puts(bp, " / ");
				CHECK_GOTO(BN_print(bp, &b));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, &d));
			BIO_puts(bp, "\n");

			if (!results) {
				CHECK_GOTO(BN_print(bp, &a));
				BIO_puts(bp, " % ");
				CHECK_GOTO(BN_print(bp, &b));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, &c));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_mul(&e, &d, &b, ctx));
		CHECK_GOTO(BN_add(&d, &e, &c));
		CHECK_GOTO(BN_sub(&d, &d, &a));
		if (!BN_is_zero(&d)) {
			fprintf(stderr, "Division test failed!\n");
			rc = 0;
			break;
		}
	}
err:
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	return (rc);
}

static void
print_word(BIO *bp, BN_ULONG w)
{
#ifdef SIXTY_FOUR_BIT
	if (sizeof(w) > sizeof(unsigned long)) {
		unsigned long h = (unsigned long)(w >> 32), l = (unsigned long)(w);

		if (h)
			BIO_printf(bp, "%lX%08lX", h, l);
		else
			BIO_printf(bp, "%lX", l);
		return;
	}
#endif
	BIO_printf(bp, BN_HEX_FMT1, w);
}

int
test_div_word(BIO *bp)
{
	BIGNUM a, b;
	BN_ULONG r, rmod, s = 0;
	int i;
	int rc = 1;

	BN_init(&a);
	BN_init(&b);

	for (i = 0; i < num0; i++) {
		do {
			if (!BN_bntest_rand(&a, 512, -1, 0) ||
			    !BN_bntest_rand(&b, BN_BITS2, -1, 0)) {
				rc = 0;
				break;
			}
			s = b.d[0];
		} while (!s);

		if (!BN_copy(&b, &a)) {
			rc = 0;
			break;
		}

		rmod = BN_mod_word(&b, s);
		r = BN_div_word(&b, s);

		if (r == (BN_ULONG)-1 || rmod == (BN_ULONG)-1) {
			rc = 0;
			break;
		}

		if (rmod != r) {
			fprintf(stderr, "Mod (word) test failed!\n");
			rc = 0;
			break;
		}

		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, &a));
				BIO_puts(bp, " / ");
				print_word(bp, s);
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, &b));
			BIO_puts(bp, "\n");

			if (!results) {
				CHECK_GOTO(BN_print(bp, &a));
				BIO_puts(bp, " % ");
				print_word(bp, s);
				BIO_puts(bp, " - ");
			}
			print_word(bp, r);
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_mul_word(&b, s));
		CHECK_GOTO(BN_add_word(&b, r));
		CHECK_GOTO(BN_sub(&b, &a, &b));
		if (!BN_is_zero(&b)) {
			fprintf(stderr, "Division (word) test failed!\n");
			rc = 0;
			break;
		}
	}
err:
	BN_free(&a);
	BN_free(&b);
	return (rc);
}

int
test_div_recp(BIO *bp, BN_CTX *ctx)
{
	BIGNUM a, b, c, d, e;
	BN_RECP_CTX recp;
	int i;
	int rc = 1;

	BN_RECP_CTX_init(&recp);
	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);

	for (i = 0; i < num0 + num1; i++) {
		if (i < num1) {
			CHECK_GOTO(BN_bntest_rand(&a, 400, 0, 0));
			CHECK_GOTO(BN_copy(&b, &a));
			CHECK_GOTO(BN_lshift(&a, &a, i));
			CHECK_GOTO(BN_add_word(&a, i));
		} else
			CHECK_GOTO(BN_bntest_rand(&b, 50 + 3 * (i - num1), 0, 0));
		a.neg = rand_neg();
		b.neg = rand_neg();
		CHECK_GOTO(BN_RECP_CTX_set(&recp, &b, ctx));
		CHECK_GOTO(BN_div_recp(&d, &c, &a, &recp, ctx));
		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, &a));
				BIO_puts(bp, " / ");
				CHECK_GOTO(BN_print(bp, &b));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, &d));
			BIO_puts(bp, "\n");

			if (!results) {
				CHECK_GOTO(BN_print(bp, &a));
				BIO_puts(bp, " % ");
				CHECK_GOTO(BN_print(bp, &b));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, &c));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_mul(&e, &d, &b, ctx));
		CHECK_GOTO(BN_add(&d, &e, &c));
		CHECK_GOTO(BN_sub(&d, &d, &a));
		if (!BN_is_zero(&d)) {
			fprintf(stderr, "Reciprocal division test failed!\n");
			fprintf(stderr, "a=");
			CHECK_GOTO(BN_print_fp(stderr, &a));
			fprintf(stderr, "\nb=");
			CHECK_GOTO(BN_print_fp(stderr, &b));
			fprintf(stderr, "\n");
			rc = 0;
			break;
		}
	}
err:
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	BN_RECP_CTX_free(&recp);
	return (rc);
}

int
test_mul(BIO *bp)
{
	BIGNUM a, b, c, d, e;
	int i;
	int rc = 1;
	BN_CTX *ctx;

	ctx = BN_CTX_new();
	if (ctx == NULL)
		exit(1);

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);

	for (i = 0; i < num0 + num1; i++) {
		if (i <= num1) {
			CHECK_GOTO(BN_bntest_rand(&a, 100, 0, 0));
			CHECK_GOTO(BN_bntest_rand(&b, 100, 0, 0));
		} else
			CHECK_GOTO(BN_bntest_rand(&b, i - num1, 0, 0));
		a.neg = rand_neg();
		b.neg = rand_neg();
		CHECK_GOTO(BN_mul(&c, &a, &b, ctx));
		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, &a));
				BIO_puts(bp, " * ");
				CHECK_GOTO(BN_print(bp, &b));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, &c));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_div(&d, &e, &c, &a, ctx));
		CHECK_GOTO(BN_sub(&d, &d, &b));
		if (!BN_is_zero(&d) || !BN_is_zero(&e)) {
			fprintf(stderr, "Multiplication test failed!\n");
			rc = 0;
			break;
		}
	}
err:
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	BN_CTX_free(ctx);
	return (rc);
}

int
test_sqr(BIO *bp, BN_CTX *ctx)
{
	BIGNUM *a, *c, *d, *e;
	int i, rc = 0;

	a = BN_new();
	c = BN_new();
	d = BN_new();
	e = BN_new();

	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_bntest_rand(a, 40 + i * 10, 0, 0));
		a->neg = rand_neg();
		CHECK_GOTO(BN_sqr(c, a, ctx));
		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, a));
				BIO_puts(bp, " * ");
				CHECK_GOTO(BN_print(bp, a));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, c));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_div(d, e, c, a, ctx));
		CHECK_GOTO(BN_sub(d, d, a));
		if (!BN_is_zero(d) || !BN_is_zero(e)) {
			fprintf(stderr, "Square test failed!\n");
			goto err;
		}
	}

	/* Regression test for a BN_sqr overflow bug. */
	if (!BN_hex2bn(&a, "80000000000000008000000000000001"
	    "FFFFFFFFFFFFFFFE0000000000000000")) {
		fprintf(stderr, "BN_hex2bn failed\n");
		goto err;
	}
	CHECK_GOTO(BN_sqr(c, a, ctx));
	if (bp != NULL) {
		if (!results) {
			CHECK_GOTO(BN_print(bp, a));
			BIO_puts(bp, " * ");
			CHECK_GOTO(BN_print(bp, a));
			BIO_puts(bp, " - ");
		}
		CHECK_GOTO(BN_print(bp, c));
		BIO_puts(bp, "\n");
	}
	CHECK_GOTO(BN_mul(d, a, a, ctx));
	if (BN_cmp(c, d)) {
		fprintf(stderr,
		    "Square test failed: BN_sqr and BN_mul produce "
		    "different results!\n");
		goto err;
	}

	/* Regression test for a BN_sqr overflow bug. */
	if (!BN_hex2bn(&a, "80000000000000000000000080000001"
	    "FFFFFFFE000000000000000000000000")) {
		fprintf(stderr, "BN_hex2bn failed\n");
		goto err;
	}
	CHECK_GOTO(BN_sqr(c, a, ctx));
	if (bp != NULL) {
		if (!results) {
			CHECK_GOTO(BN_print(bp, a));
			BIO_puts(bp, " * ");
			CHECK_GOTO(BN_print(bp, a));
			BIO_puts(bp, " - ");
		}
		CHECK_GOTO(BN_print(bp, c));
		BIO_puts(bp, "\n");
	}
	CHECK_GOTO(BN_mul(d, a, a, ctx));
	if (BN_cmp(c, d)) {
		fprintf(stderr, "Square test failed: BN_sqr and BN_mul produce "
				"different results!\n");
		goto err;
	}
	rc = 1;
err:
	BN_free(a);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return rc;
}

int
test_mont(BIO *bp, BN_CTX *ctx)
{
	BIGNUM a, b, c, d, A, B;
	BIGNUM n;
	int i;
	int rc = 1;
	BN_MONT_CTX *mont;

	mont = BN_MONT_CTX_new();
	if (mont == NULL)
		return 0;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&A);
	BN_init(&B);
	BN_init(&n);

	CHECK_GOTO(BN_zero(&n));
	if (BN_MONT_CTX_set(mont, &n, ctx)) {
		fprintf(stderr, "BN_MONT_CTX_set succeeded for zero modulus!\n");
		return (0);
	}

	CHECK_GOTO(BN_set_word(&n, 16));
	if (BN_MONT_CTX_set(mont, &n, ctx)) {
		fprintf(stderr, "BN_MONT_CTX_set succeeded for even modulus!\n");
		return (0);
	}

	CHECK_GOTO(BN_bntest_rand(&a, 100, 0, 0));
	CHECK_GOTO(BN_bntest_rand(&b, 100, 0, 0));
	for (i = 0; i < num2; i++) {
		int bits = (200 * (i + 1)) / num2;

		if (bits == 0)
			continue;
		CHECK_GOTO(BN_bntest_rand(&n, bits, 0, 1));
		CHECK_GOTO(BN_MONT_CTX_set(mont, &n, ctx));

		CHECK_GOTO(BN_nnmod(&a, &a, &n, ctx));
		CHECK_GOTO(BN_nnmod(&b, &b, &n, ctx));

		CHECK_GOTO(BN_to_montgomery(&A, &a, mont, ctx));
		CHECK_GOTO(BN_to_montgomery(&B, &b, mont, ctx));

		CHECK_GOTO(BN_mod_mul_montgomery(&c, &A, &B, mont, ctx));
		CHECK_GOTO(BN_from_montgomery(&A, &c, mont, ctx));
		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, &a));
				BIO_puts(bp, " * ");
				CHECK_GOTO(BN_print(bp, &b));
				BIO_puts(bp, " % ");
				CHECK_GOTO(BN_print(bp, &(mont->N)));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, &A));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_mod_mul(&d, &a, &b, &n, ctx));
		CHECK_GOTO(BN_sub(&d, &d, &A));
		if (!BN_is_zero(&d)) {
			fprintf(stderr, "Montgomery multiplication test failed!\n");
			rc = 0;
			break;
		}
	}
err:
	BN_MONT_CTX_free(mont);
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&A);
	BN_free(&B);
	BN_free(&n);
	return (rc);
}

int
test_mod(BIO *bp, BN_CTX *ctx)
{
	BIGNUM *a, *b, *c, *d, *e;
	int i;
	int rc = 1;

	a = BN_new();
	b = BN_new();
	c = BN_new();
	d = BN_new();
	e = BN_new();

	CHECK_GOTO(BN_bntest_rand(a, 1024, 0, 0));
	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_bntest_rand(b, 450 + i * 10, 0, 0));
		a->neg = rand_neg();
		b->neg = rand_neg();
		CHECK_GOTO(BN_mod(c, a, b, ctx));
		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, a));
				BIO_puts(bp, " % ");
				CHECK_GOTO(BN_print(bp, b));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, c));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_div(d, e, a, b, ctx));
		CHECK_GOTO(BN_sub(e, e, c));
		if (!BN_is_zero(e)) {
			fprintf(stderr, "Modulo test failed!\n");
			rc = 0;
			break;
		}
	}
err:
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return (rc);
}

int
test_mod_mul(BIO *bp, BN_CTX *ctx)
{
	BIGNUM *a, *b, *c, *d, *e;
	int i, j;
	int rc = 1;

	a = BN_new();
	b = BN_new();
	c = BN_new();
	d = BN_new();
	e = BN_new();

	CHECK_GOTO(BN_one(a));
	CHECK_GOTO(BN_one(b));
	CHECK_GOTO(BN_zero(c));
	if (BN_mod_mul(e, a, b, c, ctx)) {
		fprintf(stderr, "BN_mod_mul with zero modulus succeeded!\n");
		return (0);
	}

	for (j = 0; j < 3; j++) {
		CHECK_GOTO(BN_bntest_rand(c, 1024, 0, 0));
		for (i = 0; i < num0; i++) {
			CHECK_GOTO(BN_bntest_rand(a, 475 + i * 10, 0, 0));
			CHECK_GOTO(BN_bntest_rand(b, 425 + i * 11, 0, 0));
			a->neg = rand_neg();
			b->neg = rand_neg();
			if (!BN_mod_mul(e, a, b, c, ctx)) {
				unsigned long l;

				while ((l = ERR_get_error()))
					fprintf(stderr, "ERROR:%s\n",
					    ERR_error_string(l, NULL));
				exit(1);
			}
			if (bp != NULL) {
				if (!results) {
					CHECK_GOTO(BN_print(bp, a));
					BIO_puts(bp, " * ");
					CHECK_GOTO(BN_print(bp, b));
					BIO_puts(bp, " % ");
					CHECK_GOTO(BN_print(bp, c));
					if ((a->neg ^ b->neg) && !BN_is_zero(e)) {
						/* If  (a*b) % c  is negative,  c  must be added
						 * in order to obtain the normalized remainder
						 * (new with OpenSSL 0.9.7, previous versions of
						 * BN_mod_mul could generate negative results)
						 */
						BIO_puts(bp, " + ");
						CHECK_GOTO(BN_print(bp, c));
					}
					BIO_puts(bp, " - ");
				}
				CHECK_GOTO(BN_print(bp, e));
				BIO_puts(bp, "\n");
			}
			CHECK_GOTO(BN_mul(d, a, b, ctx));
			CHECK_GOTO(BN_sub(d, d, e));
			CHECK_GOTO(BN_div(a, b, d, c, ctx));
			if (!BN_is_zero(b)) {
				fprintf(stderr, "Modulo multiply test failed!\n");
				ERR_print_errors_fp(stderr);
				rc = 0;
				goto err;
			}
		}
	}
err:
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return (rc);
}

int
test_mod_exp(BIO *bp, BN_CTX *ctx)
{
	BIGNUM *a, *b, *c, *d, *e;
	int i;
	int rc = 1;

	a = BN_new();
	b = BN_new();
	c = BN_new();
	d = BN_new();
	e = BN_new();

	CHECK_GOTO(BN_one(a));
	CHECK_GOTO(BN_one(b));
	CHECK_GOTO(BN_zero(c));
	if (BN_mod_exp(d, a, b, c, ctx)) {
		fprintf(stderr, "BN_mod_exp with zero modulus succeeded!\n");
		return (0);
	}
	if (BN_mod_exp_ct(d, a, b, c, ctx)) {
		fprintf(stderr, "BN_mod_exp_ct with zero modulus succeeded!\n");
		return (0);
	}
	if (BN_mod_exp_nonct(d, a, b, c, ctx)) {
		fprintf(stderr, "BN_mod_exp_nonct with zero modulus succeeded!\n");
		return (0);
	}

	CHECK_GOTO(BN_bntest_rand(c, 30, 0, 1)); /* must be odd for montgomery */
	for (i = 0; i < num2; i++) {
		CHECK_GOTO(BN_bntest_rand(a, 20 + i * 5, 0, 0));
		CHECK_GOTO(BN_bntest_rand(b, 2 + i, 0, 0));

		if (!BN_mod_exp(d, a, b, c, ctx)) {
			rc = 0;
			break;
		}

		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, a));
				BIO_puts(bp, " ^ ");
				CHECK_GOTO(BN_print(bp, b));
				BIO_puts(bp, " % ");
				CHECK_GOTO(BN_print(bp, c));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, d));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_exp(e, a, b, ctx));
		CHECK_GOTO(BN_sub(e, e, d));
		CHECK_GOTO(BN_div(a, b, e, c, ctx));
		if (!BN_is_zero(b)) {
			fprintf(stderr, "Modulo exponentiation test failed!\n");
			rc = 0;
			break;
		}
	}

	CHECK_GOTO(BN_bntest_rand(c, 30, 0, 1)); /* must be odd for montgomery */
	for (i = 0; i < num2; i++) {
		CHECK_GOTO(BN_bntest_rand(a, 20 + i * 5, 0, 0));
		CHECK_GOTO(BN_bntest_rand(b, 2 + i, 0, 0));

		if (!BN_mod_exp_ct(d, a, b, c, ctx)) {
			rc = 0;
			break;
		}

		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, a));
				BIO_puts(bp, " ^ ");
				CHECK_GOTO(BN_print(bp, b));
				BIO_puts(bp, " % ");
				CHECK_GOTO(BN_print(bp, c));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, d));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_exp(e, a, b, ctx));
		CHECK_GOTO(BN_sub(e, e, d));
		CHECK_GOTO(BN_div(a, b, e, c, ctx));
		if (!BN_is_zero(b)) {
			fprintf(stderr, "Modulo exponentiation test failed!\n");
			rc = 0;
			break;
		}
	}

	CHECK_GOTO(BN_bntest_rand(c, 30, 0, 1)); /* must be odd for montgomery */
	for (i = 0; i < num2; i++) {
		CHECK_GOTO(BN_bntest_rand(a, 20 + i * 5, 0, 0));
		CHECK_GOTO(BN_bntest_rand(b, 2 + i, 0, 0));

		if (!BN_mod_exp_nonct(d, a, b, c, ctx)) {
			rc = 0;
			break;
		}

		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, a));
				BIO_puts(bp, " ^ ");
				CHECK_GOTO(BN_print(bp, b));
				BIO_puts(bp, " % ");
				CHECK_GOTO(BN_print(bp, c));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, d));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_exp(e, a, b, ctx));
		CHECK_GOTO(BN_sub(e, e, d));
		CHECK_GOTO(BN_div(a, b, e, c, ctx));
		if (!BN_is_zero(b)) {
			fprintf(stderr, "Modulo exponentiation test failed!\n");
			rc = 0;
			break;
		}
	}
err:
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return (rc);
}

int
test_mod_exp_mont_consttime(BIO *bp, BN_CTX *ctx)
{
	BIGNUM *a, *b, *c, *d, *e;
	int i;
	int rc = 1;

	a = BN_new();
	b = BN_new();
	c = BN_new();
	d = BN_new();
	e = BN_new();

	CHECK_GOTO(BN_one(a));
	CHECK_GOTO(BN_one(b));
	CHECK_GOTO(BN_zero(c));
	if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {
		fprintf(stderr, "BN_mod_exp_mont_consttime with zero modulus "
				"succeeded\n");
		rc = 0;
		goto err;
	}

	CHECK_GOTO(BN_set_word(c, 16));
	if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {
		fprintf(stderr, "BN_mod_exp_mont_consttime with even modulus "
				"succeeded\n");
		rc = 0;
		goto err;
	}

	CHECK_GOTO(BN_bntest_rand(c, 30, 0, 1)); /* must be odd for montgomery */
	for (i = 0; i < num2; i++) {
		CHECK_GOTO(BN_bntest_rand(a, 20 + i * 5, 0, 0));
		CHECK_GOTO(BN_bntest_rand(b, 2 + i, 0, 0));

		if (!BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {
			rc = 0;
			break;
		}

		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, a));
				BIO_puts(bp, " ^ ");
				CHECK_GOTO(BN_print(bp, b));
				BIO_puts(bp, " % ");
				CHECK_GOTO(BN_print(bp, c));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, d));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_exp(e, a, b, ctx));
		CHECK_GOTO(BN_sub(e, e, d));
		CHECK_GOTO(BN_div(a, b, e, c, ctx));
		if (!BN_is_zero(b)) {
			fprintf(stderr, "Modulo exponentiation test failed!\n");
			rc = 0;
			break;
		}
	}
err:
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return (rc);
}

/*
 * Test constant-time modular exponentiation with 1024-bit inputs, which on
 * x86_64 cause a different code branch to be taken.
 */
int
test_mod_exp_mont5(BIO *bp, BN_CTX *ctx)
{
	BIGNUM *a, *p, *m, *d, *e, *b, *n, *c;
	int len, rc = 1;
	BN_MONT_CTX *mont;

	a = BN_new();
	p = BN_new();
	m = BN_new();
	d = BN_new();
	e = BN_new();
	b = BN_new();
	n = BN_new();
	c = BN_new();

	CHECK_GOTO(mont = BN_MONT_CTX_new());

	CHECK_GOTO(BN_bntest_rand(m, 1024, 0, 1)); /* must be odd for montgomery */
	/* Zero exponent */
	CHECK_GOTO(BN_bntest_rand(a, 1024, 0, 0));
	CHECK_GOTO(BN_zero(p));
	if (!BN_mod_exp_mont_consttime(d, a, p, m, ctx, NULL)) {
		rc = 0;
		goto err;
	}
	if (!BN_is_one(d)) {
		fprintf(stderr, "Modular exponentiation test failed!\n");
		rc = 0;
		goto err;
	}
	/* Regression test for carry bug in mulx4x_mont */
	len = BN_hex2bn(&a,
	    "7878787878787878787878787878787878787878787878787878787878787878"
	    "7878787878787878787878787878787878787878787878787878787878787878"
	    "7878787878787878787878787878787878787878787878787878787878787878"
	    "7878787878787878787878787878787878787878787878787878787878787878");
	CHECK_GOTO(len);
	len = BN_hex2bn(&b,
	    "095D72C08C097BA488C5E439C655A192EAFB6380073D8C2664668EDDB4060744"
	    "E16E57FB4EDB9AE10A0CEFCDC28A894F689A128379DB279D48A2E20849D68593"
	    "9B7803BCF46CEBF5C533FB0DD35B080593DE5472E3FE5DB951B8BFF9B4CB8F03"
	    "9CC638A5EE8CDD703719F8000E6A9F63BEED5F2FCD52FF293EA05A251BB4AB81");
	CHECK_GOTO(len);
	len = BN_hex2bn(&n,
	    "D78AF684E71DB0C39CFF4E64FB9DB567132CB9C50CC98009FEB820B26F2DED9B"
	    "91B9B5E2B83AE0AE4EB4E0523CA726BFBE969B89FD754F674CE99118C3F2D1C5"
	    "D81FDC7C54E02B60262B241D53C040E99E45826ECA37A804668E690E1AFC1CA4"
	    "2C9A15D84D4954425F0B7642FC0BD9D7B24E2618D2DCC9B729D944BADACFDDAF");
	CHECK_GOTO(len);
	CHECK_GOTO(BN_MONT_CTX_set(mont, n, ctx));
	CHECK_GOTO(BN_mod_mul_montgomery(c, a, b, mont, ctx));
	CHECK_GOTO(BN_mod_mul_montgomery(d, b, a, mont, ctx));
	if (BN_cmp(c, d)) {
		fprintf(stderr, "Montgomery multiplication test failed:"
		    " a*b != b*a.\n");
		rc = 0;
		goto err;
	}
	/* Regression test for carry bug in sqr[x]8x_mont */
	len = BN_hex2bn(&n,
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000FFFFFFFF00"
	    "0000000000000000000000000000000000000000000000000000000000000000"
	    "0000000000000000000000000000000000000000000000000000000000000000"
	    "0000000000000000000000000000000000000000000000000000000000000000"
	    "0000000000000000000000000000000000000000000000000000000000000000"
	    "0000000000000000000000000000000000000000000000000000000000000000"
	    "0000000000000000000000000000000000000000000000000000000000000000"
	    "0000000000000000000000000000000000000000000000000000000000000000"
	    "00000000000000000000000000000000000000000000000000FFFFFFFFFFFFFF");
	CHECK_GOTO(len);
	len = BN_hex2bn(&a,
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
	    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000FFFFFFFF0000000000"
	    "0000000000000000000000000000000000000000000000000000000000000000"
	    "0000000000000000000000000000000000000000000000000000000000000000"
	    "0000000000000000000000000000000000000000000000000000000000000000"
	    "0000000000000000000000000000000000000000000000000000000000000000"
	    "0000000000000000000000000000000000000000000000000000000000000000"
	    "0000000000000000000000000000000000000000000000000000000000000000"
	    "0000000000000000000000000000000000000000000000000000000000000000"
	    "000000000000000000000000000000000000000000FFFFFFFFFFFFFF00000000");
	CHECK_GOTO(len);
	BN_free(b);
	CHECK_GOTO(b = BN_dup(a));
	CHECK_GOTO(BN_MONT_CTX_set(mont, n, ctx));
	CHECK_GOTO(BN_mod_mul_montgomery(c, a, a, mont, ctx));
	CHECK_GOTO(BN_mod_mul_montgomery(d, a, b, mont, ctx));
	if (BN_cmp(c, d)) {
		fprintf(stderr, "Montgomery multiplication test failed:"
		    " a**2 != a*a.\n");
		rc = 0;
		goto err;
	}
	/* Zero input */
	CHECK_GOTO(BN_bntest_rand(p, 1024, 0, 0));
	CHECK_GOTO(BN_zero(a));
	if (!BN_mod_exp_mont_consttime(d, a, p, m, ctx, NULL)) {
		rc = 0;
		goto err;
	}
	if (!BN_is_zero(d)) {
		fprintf(stderr, "Modular exponentiation test failed!\n");
		rc = 0;
		goto err;
	}
	/*
	 * Craft an input whose Montgomery representation is 1, i.e., shorter
	 * than the modulus m, in order to test the const time precomputation
	 * scattering/gathering.
	 */
	CHECK_GOTO(BN_one(a));
	CHECK_GOTO(BN_MONT_CTX_set(mont, m, ctx));
	if (!BN_from_montgomery(e, a, mont, ctx)) {
		rc = 0;
		goto err;
	}
	if (!BN_mod_exp_mont_consttime(d, e, p, m, ctx, NULL)) {
		rc = 0;
		goto err;
	}
	if (!BN_mod_exp_simple(a, e, p, m, ctx)) {
		rc = 0;
		goto err;
	}
	if (BN_cmp(a, d) != 0) {
		fprintf(stderr, "Modular exponentiation test failed!\n");
		rc = 0;
		goto err;
	}
	/* Finally, some regular test vectors. */
	CHECK_GOTO(BN_bntest_rand(e, 1024, 0, 0));
	if (!BN_mod_exp_mont_consttime(d, e, p, m, ctx, NULL)) {
		rc = 0;
		goto err;
	}
	if (!BN_mod_exp_simple(a, e, p, m, ctx)) {
		rc = 0;
		goto err;
	}
	if (BN_cmp(a, d) != 0) {
		fprintf(stderr, "Modular exponentiation test failed!\n");
		rc = 0;
		goto err;
	}
err:
	BN_free(a);
	BN_free(p);
	BN_free(m);
	BN_free(d);
	BN_free(e);
	BN_free(b);
	BN_free(n);
	BN_free(c);
	return (rc);
}

int
test_exp(BIO *bp, BN_CTX *ctx)
{
	BIGNUM *a, *b, *d, *e, *one;
	int i;
	int rc = 1;

	a = BN_new();
	b = BN_new();
	d = BN_new();
	e = BN_new();
	one = BN_new();
	CHECK_GOTO(BN_one(one));

	for (i = 0; i < num2; i++) {
		CHECK_GOTO(BN_bntest_rand(a, 20 + i * 5, 0, 0));
		CHECK_GOTO(BN_bntest_rand(b, 2 + i, 0, 0));

		if (BN_exp(d, a, b, ctx) <= 0) {
			rc = 0;
			break;
		}

		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, a));
				BIO_puts(bp, " ^ ");
				CHECK_GOTO(BN_print(bp, b));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, d));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_one(e));
		for (; !BN_is_zero(b); BN_sub(b, b, one))
			CHECK_GOTO(BN_mul(e, e, a, ctx));
		CHECK_GOTO(BN_sub(e, e, d));
		if (!BN_is_zero(e)) {
			fprintf(stderr, "Exponentiation test failed!\n");
			rc = 0;
			break;
		}
	}
err:
	BN_free(a);
	BN_free(b);
	BN_free(d);
	BN_free(e);
	BN_free(one);
	return (rc);
}

#ifndef OPENSSL_NO_EC2M
int
test_gf2m_add(BIO *bp)
{
	BIGNUM a, b, c;
	int i, rc = 0;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);

	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_rand(&a, 512, 0, 0));
		CHECK_GOTO(BN_copy(&b, BN_value_one()));
		a.neg = rand_neg();
		b.neg = rand_neg();
		CHECK_GOTO(BN_GF2m_add(&c, &a, &b));
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, &a));
				BIO_puts(bp, " ^ ");
				CHECK_GOTO(BN_print(bp, &b));
				BIO_puts(bp, " = ");
			}
			CHECK_GOTO(BN_print(bp, &c));
			BIO_puts(bp, "\n");
		}
#endif
		/* Test that two added values have the correct parity. */
		if ((BN_is_odd(&a) && BN_is_odd(&c))
		    || (!BN_is_odd(&a) && !BN_is_odd(&c))) {
			fprintf(stderr, "GF(2^m) addition test (a) failed!\n");
			goto err;
		}
		CHECK_GOTO(BN_GF2m_add(&c, &c, &c));
		/* Test that c + c = 0. */
		if (!BN_is_zero(&c)) {
			fprintf(stderr, "GF(2^m) addition test (b) failed!\n");
			goto err;
		}
	}
	rc = 1;
err:
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	return rc;
}

int
test_gf2m_mod(BIO *bp)
{
	BIGNUM *a, *b[2], *c, *d, *e;
	int i, j, rc = 0;
	int p0[] = { 163, 7, 6, 3, 0, -1 };
	int p1[] = { 193, 15, 0, -1 };

	a = BN_new();
	b[0] = BN_new();
	b[1] = BN_new();
	c = BN_new();
	d = BN_new();
	e = BN_new();

	CHECK_GOTO(BN_GF2m_arr2poly(p0, b[0]));
	CHECK_GOTO(BN_GF2m_arr2poly(p1, b[1]));

	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_bntest_rand(a, 1024, 0, 0));
		for (j = 0; j < 2; j++) {
			CHECK_GOTO(BN_GF2m_mod(c, a, b[j]));
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL) {
				if (!results) {
					CHECK_GOTO(BN_print(bp, a));
					BIO_puts(bp, " % ");
					CHECK_GOTO(BN_print(bp, b[j]));
					BIO_puts(bp, " - ");
					CHECK_GOTO(BN_print(bp, c));
					BIO_puts(bp, "\n");
				}
			}
#endif
			CHECK_GOTO(BN_GF2m_add(d, a, c));
			CHECK_GOTO(BN_GF2m_mod(e, d, b[j]));
			/* Test that a + (a mod p) mod p == 0. */
			if (!BN_is_zero(e)) {
				fprintf(stderr, "GF(2^m) modulo test failed!\n");
				goto err;
			}
		}
	}
	rc = 1;
err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return rc;
}

int
test_gf2m_mod_mul(BIO *bp, BN_CTX *ctx)
{
	BIGNUM *a, *b[2], *c, *d, *e, *f, *g, *h;
	int i, j, rc = 0;
	int p0[] = { 163, 7, 6, 3, 0, -1 };
	int p1[] = { 193, 15, 0, -1 };

	a = BN_new();
	b[0] = BN_new();
	b[1] = BN_new();
	c = BN_new();
	d = BN_new();
	e = BN_new();
	f = BN_new();
	g = BN_new();
	h = BN_new();

	CHECK_GOTO(BN_GF2m_arr2poly(p0, b[0]));
	CHECK_GOTO(BN_GF2m_arr2poly(p1, b[1]));

	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_bntest_rand(a, 1024, 0, 0));
		CHECK_GOTO(BN_bntest_rand(c, 1024, 0, 0));
		CHECK_GOTO(BN_bntest_rand(d, 1024, 0, 0));
		for (j = 0; j < 2; j++) {
			CHECK_GOTO(BN_GF2m_mod_mul(e, a, c, b[j], ctx));
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL) {
				if (!results) {
					CHECK_GOTO(BN_print(bp, a));
					BIO_puts(bp, " * ");
					CHECK_GOTO(BN_print(bp, c));
					BIO_puts(bp, " % ");
					CHECK_GOTO(BN_print(bp, b[j]));
					BIO_puts(bp, " - ");
					CHECK_GOTO(BN_print(bp, e));
					BIO_puts(bp, "\n");
				}
			}
#endif
			CHECK_GOTO(BN_GF2m_add(f, a, d));
			CHECK_GOTO(BN_GF2m_mod_mul(g, f, c, b[j], ctx));
			CHECK_GOTO(BN_GF2m_mod_mul(h, d, c, b[j], ctx));
			CHECK_GOTO(BN_GF2m_add(f, e, g));
			CHECK_GOTO(BN_GF2m_add(f, f, h));
			/* Test that (a+d)*c = a*c + d*c. */
			if (!BN_is_zero(f)) {
				fprintf(stderr, "GF(2^m) modular multiplication test failed!\n");
				goto err;
			}
		}
	}
	rc = 1;
err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	BN_free(f);
	BN_free(g);
	BN_free(h);
	return rc;
}

int
test_gf2m_mod_sqr(BIO *bp, BN_CTX *ctx)
{
	BIGNUM *a, *b[2], *c, *d;
	int i, j, rc = 0;
	int p0[] = { 163, 7, 6, 3, 0, -1 };
	int p1[] = { 193, 15, 0, -1 };

	a = BN_new();
	b[0] = BN_new();
	b[1] = BN_new();
	c = BN_new();
	d = BN_new();

	CHECK_GOTO(BN_GF2m_arr2poly(p0, b[0]));
	CHECK_GOTO(BN_GF2m_arr2poly(p1, b[1]));

	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_bntest_rand(a, 1024, 0, 0));
		for (j = 0; j < 2; j++) {
			CHECK_GOTO(BN_GF2m_mod_sqr(c, a, b[j], ctx));
			CHECK_GOTO(BN_copy(d, a));
			CHECK_GOTO(BN_GF2m_mod_mul(d, a, d, b[j], ctx));
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL) {
				if (!results) {
					CHECK_GOTO(BN_print(bp, a));
					BIO_puts(bp, " ^ 2 % ");
					CHECK_GOTO(BN_print(bp, b[j]));
					BIO_puts(bp, " = ");
					CHECK_GOTO(BN_print(bp, c));
					BIO_puts(bp, "; a * a = ");
					CHECK_GOTO(BN_print(bp, d));
					BIO_puts(bp, "\n");
				}
			}
#endif
			CHECK_GOTO(BN_GF2m_add(d, c, d));
			/* Test that a*a = a^2. */
			if (!BN_is_zero(d)) {
				fprintf(stderr, "GF(2^m) modular squaring test failed!\n");
				goto err;
			}
		}
	}
	rc = 1;
err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	return rc;
}

int
test_gf2m_mod_inv(BIO *bp, BN_CTX *ctx)
{
	BIGNUM *a, *b[2], *c, *d;
	int i, j, rc = 0;
	int p0[] = { 163, 7, 6, 3, 0, -1 };
	int p1[] = { 193, 15, 0, -1 };

	a = BN_new();
	b[0] = BN_new();
	b[1] = BN_new();
	c = BN_new();
	d = BN_new();

	CHECK_GOTO(BN_GF2m_arr2poly(p0, b[0]));
	CHECK_GOTO(BN_GF2m_arr2poly(p1, b[1]));

	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_bntest_rand(a, 512, 0, 0));
		for (j = 0; j < 2; j++) {
			CHECK_GOTO(BN_GF2m_mod_inv(c, a, b[j], ctx));
			CHECK_GOTO(BN_GF2m_mod_mul(d, a, c, b[j], ctx));
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL) {
				if (!results) {
					CHECK_GOTO(BN_print(bp, a));
					BIO_puts(bp, " * ");
					CHECK_GOTO(BN_print(bp, c));
					BIO_puts(bp, " - 1 % ");
					CHECK_GOTO(BN_print(bp, b[j]));
					BIO_puts(bp, "\n");
				}
			}
#endif
			/* Test that ((1/a)*a) = 1. */
			if (!BN_is_one(d)) {
				fprintf(stderr, "GF(2^m) modular inversion test failed!\n");
				goto err;
			}
		}
	}
	rc = 1;
err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	return rc;
}

int
test_gf2m_mod_div(BIO *bp, BN_CTX *ctx)
{
	BIGNUM *a, *b[2], *c, *d, *e, *f;
	int i, j, rc = 0;
	int p0[] = { 163, 7, 6, 3, 0, -1 };
	int p1[] = { 193, 15, 0, -1 };

	a = BN_new();
	b[0] = BN_new();
	b[1] = BN_new();
	c = BN_new();
	d = BN_new();
	e = BN_new();
	f = BN_new();

	CHECK_GOTO(BN_GF2m_arr2poly(p0, b[0]));
	CHECK_GOTO(BN_GF2m_arr2poly(p1, b[1]));

	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_bntest_rand(a, 512, 0, 0));
		CHECK_GOTO(BN_bntest_rand(c, 512, 0, 0));
		for (j = 0; j < 2; j++) {
			CHECK_GOTO(BN_GF2m_mod_div(d, a, c, b[j], ctx));
			CHECK_GOTO(BN_GF2m_mod_mul(e, d, c, b[j], ctx));
			CHECK_GOTO(BN_GF2m_mod_div(f, a, e, b[j], ctx));
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL) {
				if (!results) {
					CHECK_GOTO(BN_print(bp, a));
					BIO_puts(bp, " = ");
					CHECK_GOTO(BN_print(bp, c));
					BIO_puts(bp, " * ");
					CHECK_GOTO(BN_print(bp, d));
					BIO_puts(bp, " % ");
					CHECK_GOTO(BN_print(bp, b[j]));
					BIO_puts(bp, "\n");
				}
			}
#endif
			/* Test that ((a/c)*c)/a = 1. */
			if (!BN_is_one(f)) {
				fprintf(stderr, "GF(2^m) modular division test failed!\n");
				goto err;
			}
		}
	}
	rc = 1;
err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	BN_free(f);
	return rc;
}

int
test_gf2m_mod_exp(BIO *bp, BN_CTX *ctx)
{
	BIGNUM *a, *b[2], *c, *d, *e, *f;
	int i, j, rc = 0;
	int p0[] = { 163, 7, 6, 3, 0, -1 };
	int p1[] = { 193, 15, 0, -1 };

	a = BN_new();
	b[0] = BN_new();
	b[1] = BN_new();
	c = BN_new();
	d = BN_new();
	e = BN_new();
	f = BN_new();

	CHECK_GOTO(BN_GF2m_arr2poly(p0, b[0]));
	CHECK_GOTO(BN_GF2m_arr2poly(p1, b[1]));

	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_bntest_rand(a, 512, 0, 0));
		CHECK_GOTO(BN_bntest_rand(c, 512, 0, 0));
		CHECK_GOTO(BN_bntest_rand(d, 512, 0, 0));
		for (j = 0; j < 2; j++) {
			CHECK_GOTO(BN_GF2m_mod_exp(e, a, c, b[j], ctx));
			CHECK_GOTO(BN_GF2m_mod_exp(f, a, d, b[j], ctx));
			CHECK_GOTO(BN_GF2m_mod_mul(e, e, f, b[j], ctx));
			CHECK_GOTO(BN_add(f, c, d));
			CHECK_GOTO(BN_GF2m_mod_exp(f, a, f, b[j], ctx));
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL) {
				if (!results) {
					CHECK_GOTO(BN_print(bp, a));
					BIO_puts(bp, " ^ (");
					CHECK_GOTO(BN_print(bp, c));
					BIO_puts(bp, " + ");
					CHECK_GOTO(BN_print(bp, d));
					BIO_puts(bp, ") = ");
					CHECK_GOTO(BN_print(bp, e));
					BIO_puts(bp, "; - ");
					CHECK_GOTO(BN_print(bp, f));
					BIO_puts(bp, " % ");
					CHECK_GOTO(BN_print(bp, b[j]));
					BIO_puts(bp, "\n");
				}
			}
#endif
			CHECK_GOTO(BN_GF2m_add(f, e, f));
			/* Test that a^(c+d)=a^c*a^d. */
			if (!BN_is_zero(f)) {
				fprintf(stderr, "GF(2^m) modular exponentiation test failed!\n");
				goto err;
			}
		}
	}
	rc = 1;
err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	BN_free(f);
	return rc;
}

int
test_gf2m_mod_sqrt(BIO *bp, BN_CTX *ctx)
{
	BIGNUM *a, *b[2], *c, *d, *e, *f;
	int i, j, rc = 0;
	int p0[] = { 163, 7, 6, 3, 0, -1 };
	int p1[] = { 193, 15, 0, -1 };

	a = BN_new();
	b[0] = BN_new();
	b[1] = BN_new();
	c = BN_new();
	d = BN_new();
	e = BN_new();
	f = BN_new();

	CHECK_GOTO(BN_GF2m_arr2poly(p0, b[0]));
	CHECK_GOTO(BN_GF2m_arr2poly(p1, b[1]));

	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_bntest_rand(a, 512, 0, 0));
		for (j = 0; j < 2; j++) {
			CHECK_GOTO(BN_GF2m_mod(c, a, b[j]));
			CHECK_GOTO(BN_GF2m_mod_sqrt(d, a, b[j], ctx));
			CHECK_GOTO(BN_GF2m_mod_sqr(e, d, b[j], ctx));
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL) {
				if (!results) {
					CHECK_GOTO(BN_print(bp, d));
					BIO_puts(bp, " ^ 2 - ");
					CHECK_GOTO(BN_print(bp, a));
					BIO_puts(bp, "\n");
				}
			}
#endif
			CHECK_GOTO(BN_GF2m_add(f, c, e));
			/* Test that d^2 = a, where d = sqrt(a). */
			if (!BN_is_zero(f)) {
				fprintf(stderr, "GF(2^m) modular square root test failed!\n");
				goto err;
			}
		}
	}
	rc = 1;
err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	BN_free(f);
	return rc;
}

int
test_gf2m_mod_solve_quad(BIO *bp, BN_CTX *ctx)
{
	BIGNUM *a, *b[2], *c, *d, *e;
	int i, j, s = 0, t, rc = 0;
	int p0[] = { 163, 7, 6, 3, 0, -1 };
	int p1[] = { 193, 15, 0, -1 };

	a = BN_new();
	b[0] = BN_new();
	b[1] = BN_new();
	c = BN_new();
	d = BN_new();
	e = BN_new();

	CHECK_GOTO(BN_GF2m_arr2poly(p0, b[0]));
	CHECK_GOTO(BN_GF2m_arr2poly(p1, b[1]));

	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_bntest_rand(a, 512, 0, 0));
		for (j = 0; j < 2; j++) {
			t = BN_GF2m_mod_solve_quad(c, a, b[j], ctx);
			if (t) {
				s++;
				CHECK_GOTO(BN_GF2m_mod_sqr(d, c, b[j], ctx));
				CHECK_GOTO(BN_GF2m_add(d, c, d));
				CHECK_GOTO(BN_GF2m_mod(e, a, b[j]));
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
				if (bp != NULL) {
					if (!results) {
						CHECK_GOTO(BN_print(bp, c));
						BIO_puts(bp, " is root of z^2 + z = ");
						CHECK_GOTO(BN_print(bp, a));
						BIO_puts(bp, " % ");
						CHECK_GOTO(BN_print(bp, b[j]));
						BIO_puts(bp, "\n");
					}
				}
#endif
				CHECK_GOTO(BN_GF2m_add(e, e, d));
				/* Test that solution of quadratic c satisfies c^2 + c = a. */
				if (!BN_is_zero(e)) {
					fprintf(stderr, "GF(2^m) modular solve quadratic test failed!\n");
					goto err;
				}

			} else {
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
				if (bp != NULL) {
					if (!results) {
						BIO_puts(bp, "There are no roots of z^2 + z = ");
						CHECK_GOTO(BN_print(bp, a));
						BIO_puts(bp, " % ");
						CHECK_GOTO(BN_print(bp, b[j]));
						BIO_puts(bp, "\n");
					}
				}
#endif
			}
		}
	}
	if (s == 0) {
		fprintf(stderr, "All %i tests of GF(2^m) modular solve quadratic resulted in no roots;\n", num0);
		fprintf(stderr, "this is very unlikely and probably indicates an error.\n");
		goto err;
	}
	rc = 1;
err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return rc;
}
#endif
static int
genprime_cb(int p, int n, BN_GENCB *arg)
{
	char c = '*';

	if (p == 0)
		c = '.';
	if (p == 1)
		c = '+';
	if (p == 2)
		c = '*';
	if (p == 3)
		c = '\n';
	putc(c, stderr);
	fflush(stderr);
	return (1);
}

int
test_kron(BIO *bp, BN_CTX *ctx)
{
	BN_GENCB cb;
	BIGNUM *a, *b, *r, *t;
	int i;
	int legendre, kronecker;
	int rc = 0;

	a = BN_new();
	b = BN_new();
	r = BN_new();
	t = BN_new();
	if (a == NULL || b == NULL || r == NULL || t == NULL)
		goto err;

	BN_GENCB_set(&cb, genprime_cb, NULL);

	/*
	 * We test BN_kronecker(a, b, ctx) just for b odd (Jacobi symbol). In
	 * this case we know that if b is prime, then BN_kronecker(a, b, ctx) is
	 * congruent to $a^{(b-1)/2}$, modulo $b$ (Legendre symbol). So we
	 * generate a random prime b and compare these values for a number of
	 * random a's.  (That is, we run the Solovay-Strassen primality test to
	 * confirm that b is prime, except that we don't want to test whether b
	 * is prime but whether BN_kronecker works.)
	 */

	if (!BN_generate_prime_ex(b, 512, 0, NULL, NULL, &cb))
		goto err;
	b->neg = rand_neg();
	putc('\n', stderr);

	for (i = 0; i < num0; i++) {
		if (!BN_bntest_rand(a, 512, 0, 0))
			goto err;
		a->neg = rand_neg();

		/* t := (|b|-1)/2  (note that b is odd) */
		if (!BN_copy(t, b))
			goto err;
		t->neg = 0;
		if (!BN_sub_word(t, 1))
			goto err;
		if (!BN_rshift1(t, t))
			goto err;
		/* r := a^t mod b */
		b->neg = 0;

		if (!BN_mod_exp_recp(r, a, t, b, ctx))
			goto err;
		b->neg = 1;

		if (BN_is_word(r, 1))
			legendre = 1;
		else if (BN_is_zero(r))
			legendre = 0;
		else {
			if (!BN_add_word(r, 1))
				goto err;
			if (0 != BN_ucmp(r, b)) {
				fprintf(stderr, "Legendre symbol computation failed\n");
				goto err;
			}
			legendre = -1;
		}

		kronecker = BN_kronecker(a, b, ctx);
		if (kronecker < -1)
			goto err;
		/* we actually need BN_kronecker(a, |b|) */
		if (a->neg && b->neg)
			kronecker = -kronecker;

		if (legendre != kronecker) {
			fprintf(stderr, "legendre != kronecker; a = ");
			CHECK_GOTO(BN_print_fp(stderr, a));
			fprintf(stderr, ", b = ");
			CHECK_GOTO(BN_print_fp(stderr, b));
			fprintf(stderr, "\n");
			goto err;
		}

		putc('.', stderr);
		fflush(stderr);
	}

	putc('\n', stderr);
	fflush(stderr);
	rc = 1;
err:
	BN_free(a);
	BN_free(b);
	BN_free(r);
	BN_free(t);
	return rc;
}

int
test_sqrt(BIO *bp, BN_CTX *ctx)
{
	BN_GENCB cb;
	BIGNUM *a, *p, *r;
	int i, j;
	int rc = 0;

	a = BN_new();
	p = BN_new();
	r = BN_new();
	if (a == NULL || p == NULL || r == NULL)
		goto err;

	BN_GENCB_set(&cb, genprime_cb, NULL);

	for (i = 0; i < 16; i++) {
		if (i < 8) {
			unsigned primes[8] = { 2, 3, 5, 7, 11, 13, 17, 19 };

			if (!BN_set_word(p, primes[i]))
				goto err;
		} else {
			if (!BN_set_word(a, 32))
				goto err;
			if (!BN_set_word(r, 2 * i + 1))
				goto err;

			if (!BN_generate_prime_ex(p, 256, 0, a, r, &cb))
				goto err;
			putc('\n', stderr);
		}
		p->neg = rand_neg();

		for (j = 0; j < num2; j++) {
			/*
			 * construct 'a' such that it is a square modulo p, but in
			 * general not a proper square and not reduced modulo p
			 */
			if (!BN_bntest_rand(r, 256, 0, 3))
				goto err;
			if (!BN_nnmod(r, r, p, ctx))
				goto err;
			if (!BN_mod_sqr(r, r, p, ctx))
				goto err;
			if (!BN_bntest_rand(a, 256, 0, 3))
				goto err;
			if (!BN_nnmod(a, a, p, ctx))
				goto err;
			if (!BN_mod_sqr(a, a, p, ctx))
				goto err;
			if (!BN_mul(a, a, r, ctx))
				goto err;
			if (rand_neg())
				if (!BN_sub(a, a, p))
					goto err;

			if (!BN_mod_sqrt(r, a, p, ctx))
				goto err;
			if (!BN_mod_sqr(r, r, p, ctx))
				goto err;

			if (!BN_nnmod(a, a, p, ctx))
				goto err;

			if (BN_cmp(a, r) != 0) {
				fprintf(stderr, "BN_mod_sqrt failed: a = ");
				CHECK_GOTO(BN_print_fp(stderr, a));
				fprintf(stderr, ", r = ");
				CHECK_GOTO(BN_print_fp(stderr, r));
				fprintf(stderr, ", p = ");
				CHECK_GOTO(BN_print_fp(stderr, p));
				fprintf(stderr, "\n");
				goto err;
			}

			putc('.', stderr);
			fflush(stderr);
		}

		putc('\n', stderr);
		fflush(stderr);
	}
	rc = 1;
err:
	BN_free(a);
	BN_free(p);
	BN_free(r);
	return rc;
}

int
test_lshift(BIO *bp, BN_CTX *ctx, BIGNUM *a_)
{
	BIGNUM *a = NULL, *b, *c, *d;
	int i;
	int rc = 1;

	b = BN_new();
	c = BN_new();
	d = BN_new();
	CHECK_GOTO(BN_one(c));

	if (a_)
		a = a_;
	else {
		a = BN_new();
		CHECK_GOTO(BN_bntest_rand(a, 200, 0, 0));
		a->neg = rand_neg();
	}
	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_lshift(b, a, i + 1));
		CHECK_GOTO(BN_add(c, c, c));
		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, a));
				BIO_puts(bp, " * ");
				CHECK_GOTO(BN_print(bp, c));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, b));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_mul(d, a, c, ctx));
		CHECK_GOTO(BN_sub(d, d, b));
		if (!BN_is_zero(d)) {
			fprintf(stderr, "Left shift test failed!\n");
			fprintf(stderr, "a=");
			CHECK_GOTO(BN_print_fp(stderr, a));
			fprintf(stderr, "\nb=");
			CHECK_GOTO(BN_print_fp(stderr, b));
			fprintf(stderr, "\nc=");
			CHECK_GOTO(BN_print_fp(stderr, c));
			fprintf(stderr, "\nd=");
			CHECK_GOTO(BN_print_fp(stderr, d));
			fprintf(stderr, "\n");
			rc = 0;
			break;
		}
	}
err:
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	return (rc);
}

int
test_lshift1(BIO *bp)
{
	BIGNUM *a, *b, *c;
	int i;
	int rc = 1;

	a = BN_new();
	b = BN_new();
	c = BN_new();

	CHECK_GOTO(BN_bntest_rand(a, 200, 0, 0));
	a->neg = rand_neg();
	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_lshift1(b, a));
		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, a));
				BIO_puts(bp, " * 2");
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, b));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_add(c, a, a));
		CHECK_GOTO(BN_sub(a, b, c));
		if (!BN_is_zero(a)) {
			fprintf(stderr, "Left shift one test failed!\n");
			rc = 0;
			break;
		}

		CHECK_GOTO(BN_copy(a, b));
	}
err:
	BN_free(a);
	BN_free(b);
	BN_free(c);
	return (rc);
}

int
test_rshift(BIO *bp, BN_CTX *ctx)
{
	BIGNUM *a, *b, *c, *d, *e;
	int i;
	int rc = 1;

	a = BN_new();
	b = BN_new();
	c = BN_new();
	d = BN_new();
	e = BN_new();
	CHECK_GOTO(BN_one(c));

	CHECK_GOTO(BN_bntest_rand(a, 200, 0, 0));
	a->neg = rand_neg();
	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_rshift(b, a, i + 1));
		CHECK_GOTO(BN_add(c, c, c));
		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, a));
				BIO_puts(bp, " / ");
				CHECK_GOTO(BN_print(bp, c));
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, b));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_div(d, e, a, c, ctx));
		CHECK_GOTO(BN_sub(d, d, b));
		if (!BN_is_zero(d)) {
			fprintf(stderr, "Right shift test failed!\n");
			rc = 0;
			break;
		}
	}
err:
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return (rc);
}

int
test_rshift1(BIO *bp)
{
	BIGNUM *a, *b, *c;
	int i;
	int rc = 1;

	a = BN_new();
	b = BN_new();
	c = BN_new();

	CHECK_GOTO(BN_bntest_rand(a, 200, 0, 0));
	a->neg = rand_neg();
	for (i = 0; i < num0; i++) {
		CHECK_GOTO(BN_rshift1(b, a));
		if (bp != NULL) {
			if (!results) {
				CHECK_GOTO(BN_print(bp, a));
				BIO_puts(bp, " / 2");
				BIO_puts(bp, " - ");
			}
			CHECK_GOTO(BN_print(bp, b));
			BIO_puts(bp, "\n");
		}
		CHECK_GOTO(BN_sub(c, a, b));
		CHECK_GOTO(BN_sub(c, c, b));
		if (!BN_is_zero(c) && !BN_abs_is_word(c, 1)) {
			fprintf(stderr, "Right shift one test failed!\n");
			rc = 0;
			break;
		}
		CHECK_GOTO(BN_copy(a, b));
	}
err:
	BN_free(a);
	BN_free(b);
	BN_free(c);
	return (rc);
}

int
rand_neg(void)
{
	static unsigned int neg = 0;
	static int sign[8] = { 0, 0, 0, 1, 1, 0, 1, 1 };

	return (sign[(neg++) % 8]);
}

int
test_mod_exp_sizes(BIO *bp, BN_CTX *ctx)
{
	BN_MONT_CTX *mont_ctx = NULL;
	BIGNUM *p, *x, *y, *r, *r2;
	int size;
	int rc = 0;

	BN_CTX_start(ctx);
	CHECK_GOTO(p = BN_CTX_get(ctx));
	CHECK_GOTO(x = BN_CTX_get(ctx));
	CHECK_GOTO(y = BN_CTX_get(ctx));
	CHECK_GOTO(r = BN_CTX_get(ctx));
	CHECK_GOTO(r2 = BN_CTX_get(ctx));
	mont_ctx = BN_MONT_CTX_new();

	if (r2 == NULL || mont_ctx == NULL)
		goto err;

	if (!BN_generate_prime_ex(p, 32, 0, NULL, NULL, NULL) ||
	    !BN_MONT_CTX_set(mont_ctx, p, ctx))
		goto err;

	for (size = 32; size < 1024; size += 8) {
		if (!BN_rand(x, size, -1, 0) ||
		    !BN_rand(y, size, -1, 0) ||
		    !BN_mod_exp_mont_consttime(r, x, y, p, ctx, mont_ctx) ||
		    !BN_mod_exp(r2, x, y, p, ctx))
			goto err;

		if (BN_cmp(r, r2) != 0) {
			char *r_str = NULL;
			char *r2_str = NULL;
			CHECK_GOTO(r_str = BN_bn2hex(r));
			CHECK_GOTO(r2_str = BN_bn2hex(r2));

			printf("Incorrect answer at size %d: %s vs %s\n",
			    size, r_str, r2_str);
			free(r_str);
			free(r2_str);
			goto err;
		}
	}

	rc = 1;

err:
	BN_MONT_CTX_free(mont_ctx);
	BN_CTX_end(ctx);
	return rc;
}
@


1.17
log
@Remove unused variable in C source to make the test compile and pass.
@
text
@d139 11
d383 1
a383 1
	BN_bntest_rand(&a, 512, 0, 0);
d385 1
a385 1
		BN_bntest_rand(&b, 450 + i, 0, 0);
d388 1
a388 1
		BN_add(&c, &a, &b);
d391 1
a391 1
				BN_print(bp, &a);
d393 1
a393 1
				BN_print(bp, &b);
d396 1
a396 1
			BN_print(bp, &c);
d401 2
a402 2
		BN_add(&c, &c, &b);
		BN_add(&c, &c, &a);
d409 1
d429 2
a430 2
			BN_bntest_rand(&a, 512, 0, 0);
			BN_copy(&b, &a);
d435 1
a435 1
			BN_add_word(&b, i);
d437 1
a437 1
			BN_bntest_rand(&b, 400 + i - num1, 0, 0);
d441 1
a441 1
		BN_sub(&c, &a, &b);
d444 1
a444 1
				BN_print(bp, &a);
d446 1
a446 1
				BN_print(bp, &b);
d449 1
a449 1
			BN_print(bp, &c);
d452 2
a453 2
		BN_add(&c, &c, &b);
		BN_sub(&c, &c, &a);
d460 1
d480 2
a481 2
	BN_one(&a);
	BN_zero(&b);
d490 4
a493 4
			BN_bntest_rand(&a, 400, 0, 0);
			BN_copy(&b, &a);
			BN_lshift(&a, &a, i);
			BN_add_word(&a, i);
d495 1
a495 1
			BN_bntest_rand(&b, 50 + 3 * (i - num1), 0, 0);
d498 1
a498 1
		BN_div(&d, &c, &a, &b, ctx);
d501 1
a501 1
				BN_print(bp, &a);
d503 1
a503 1
				BN_print(bp, &b);
d506 1
a506 1
			BN_print(bp, &d);
d510 1
a510 1
				BN_print(bp, &a);
d512 1
a512 1
				BN_print(bp, &b);
d515 1
a515 1
			BN_print(bp, &c);
d518 3
a520 3
		BN_mul(&e, &d, &b, ctx);
		BN_add(&d, &e, &c);
		BN_sub(&d, &d, &a);
d527 1
d595 1
a595 1
				BN_print(bp, &a);
d600 1
a600 1
			BN_print(bp, &b);
d604 1
a604 1
				BN_print(bp, &a);
d612 3
a614 3
		BN_mul_word(&b, s);
		BN_add_word(&b, r);
		BN_sub(&b, &a, &b);
d621 1
d644 4
a647 4
			BN_bntest_rand(&a, 400, 0, 0);
			BN_copy(&b, &a);
			BN_lshift(&a, &a, i);
			BN_add_word(&a, i);
d649 1
a649 1
			BN_bntest_rand(&b, 50 + 3 * (i - num1), 0, 0);
d652 2
a653 2
		BN_RECP_CTX_set(&recp, &b, ctx);
		BN_div_recp(&d, &c, &a, &recp, ctx);
d656 1
a656 1
				BN_print(bp, &a);
d658 1
a658 1
				BN_print(bp, &b);
d661 1
a661 1
			BN_print(bp, &d);
d665 1
a665 1
				BN_print(bp, &a);
d667 1
a667 1
				BN_print(bp, &b);
d670 1
a670 1
			BN_print(bp, &c);
d673 3
a675 3
		BN_mul(&e, &d, &b, ctx);
		BN_add(&d, &e, &c);
		BN_sub(&d, &d, &a);
d679 1
a679 1
			BN_print_fp(stderr, &a);
d681 1
a681 1
			BN_print_fp(stderr, &b);
d687 1
d717 2
a718 2
			BN_bntest_rand(&a, 100, 0, 0);
			BN_bntest_rand(&b, 100, 0, 0);
d720 1
a720 1
			BN_bntest_rand(&b, i - num1, 0, 0);
d723 1
a723 1
		BN_mul(&c, &a, &b, ctx);
d726 1
a726 1
				BN_print(bp, &a);
d728 1
a728 1
				BN_print(bp, &b);
d731 1
a731 1
			BN_print(bp, &c);
d734 2
a735 2
		BN_div(&d, &e, &c, &a, ctx);
		BN_sub(&d, &d, &b);
d742 1
d756 1
a756 1
	int i, ret = 0;
d764 1
a764 1
		BN_bntest_rand(a, 40 + i * 10, 0, 0);
d766 1
a766 1
		BN_sqr(c, a, ctx);
d769 1
a769 1
				BN_print(bp, a);
d771 1
a771 1
				BN_print(bp, a);
d774 1
a774 1
			BN_print(bp, c);
d777 2
a778 2
		BN_div(d, e, c, a, ctx);
		BN_sub(d, d, a);
d791 1
a791 1
	BN_sqr(c, a, ctx);
d794 1
a794 1
			BN_print(bp, a);
d796 1
a796 1
			BN_print(bp, a);
d799 1
a799 1
		BN_print(bp, c);
d802 1
a802 1
	BN_mul(d, a, a, ctx);
d816 1
a816 1
	BN_sqr(c, a, ctx);
d819 1
a819 1
			BN_print(bp, a);
d821 1
a821 1
			BN_print(bp, a);
d824 1
a824 1
		BN_print(bp, c);
d827 1
a827 1
	BN_mul(d, a, a, ctx);
d833 1
a833 1
	ret = 1;
d839 1
a839 1
	return ret;
d863 1
a863 1
	BN_zero(&n);
d869 1
a869 1
	BN_set_word(&n, 16);
d875 2
a876 2
	BN_bntest_rand(&a, 100, 0, 0);
	BN_bntest_rand(&b, 100, 0, 0);
d882 2
a883 2
		BN_bntest_rand(&n, bits, 0, 1);
		(void)BN_MONT_CTX_set(mont, &n, ctx);
d885 2
a886 2
		BN_nnmod(&a, &a, &n, ctx);
		BN_nnmod(&b, &b, &n, ctx);
d888 2
a889 2
		BN_to_montgomery(&A, &a, mont, ctx);
		BN_to_montgomery(&B, &b, mont, ctx);
d891 2
a892 2
		BN_mod_mul_montgomery(&c, &A, &B, mont, ctx);
		BN_from_montgomery(&A, &c, mont, ctx);
d895 1
a895 1
				BN_print(bp, &a);
d897 1
a897 1
				BN_print(bp, &b);
d899 1
a899 1
				BN_print(bp, &(mont->N));
d902 1
a902 1
			BN_print(bp, &A);
d905 2
a906 2
		BN_mod_mul(&d, &a, &b, &n, ctx);
		BN_sub(&d, &d, &A);
d913 1
d938 1
a938 1
	BN_bntest_rand(a, 1024, 0, 0);
d940 1
a940 1
		BN_bntest_rand(b, 450 + i * 10, 0, 0);
d943 1
a943 1
		BN_mod(c, a, b, ctx);
d946 1
a946 1
				BN_print(bp, a);
d948 1
a948 1
				BN_print(bp, b);
d951 1
a951 1
			BN_print(bp, c);
d954 2
a955 2
		BN_div(d, e, a, b, ctx);
		BN_sub(e, e, c);
d962 1
d984 3
a986 3
	BN_one(a);
	BN_one(b);
	BN_zero(c);
d993 1
a993 1
		BN_bntest_rand(c, 1024, 0, 0);
d995 2
a996 2
			BN_bntest_rand(a, 475 + i * 10, 0, 0);
			BN_bntest_rand(b, 425 + i * 11, 0, 0);
d1009 1
a1009 1
					BN_print(bp, a);
d1011 1
a1011 1
					BN_print(bp, b);
d1013 1
a1013 1
					BN_print(bp, c);
d1021 1
a1021 1
						BN_print(bp, c);
d1025 1
a1025 1
				BN_print(bp, e);
d1028 3
a1030 3
			BN_mul(d, a, b, ctx);
			BN_sub(d, d, e);
			BN_div(a, b, d, c, ctx);
d1035 1
a1035 1
				goto done;
d1039 1
a1039 1
done:
d1061 3
a1063 3
	BN_one(a);
	BN_one(b);
	BN_zero(c);
d1077 1
a1077 1
	BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */
d1079 2
a1080 2
		BN_bntest_rand(a, 20 + i * 5, 0, 0);
		BN_bntest_rand(b, 2 + i, 0, 0);
d1089 1
a1089 1
				BN_print(bp, a);
d1091 1
a1091 1
				BN_print(bp, b);
d1093 1
a1093 1
				BN_print(bp, c);
d1096 1
a1096 1
			BN_print(bp, d);
d1099 3
a1101 3
		BN_exp(e, a, b, ctx);
		BN_sub(e, e, d);
		BN_div(a, b, e, c, ctx);
d1109 1
a1109 1
	BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */
d1111 2
a1112 2
		BN_bntest_rand(a, 20 + i * 5, 0, 0);
		BN_bntest_rand(b, 2 + i, 0, 0);
d1121 1
a1121 1
				BN_print(bp, a);
d1123 1
a1123 1
				BN_print(bp, b);
d1125 1
a1125 1
				BN_print(bp, c);
d1128 1
a1128 1
			BN_print(bp, d);
d1131 3
a1133 3
		BN_exp(e, a, b, ctx);
		BN_sub(e, e, d);
		BN_div(a, b, e, c, ctx);
d1141 1
a1141 1
	BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */
d1143 2
a1144 2
		BN_bntest_rand(a, 20 + i * 5, 0, 0);
		BN_bntest_rand(b, 2 + i, 0, 0);
d1153 1
a1153 1
				BN_print(bp, a);
d1155 1
a1155 1
				BN_print(bp, b);
d1157 1
a1157 1
				BN_print(bp, c);
d1160 1
a1160 1
			BN_print(bp, d);
d1163 3
a1165 3
		BN_exp(e, a, b, ctx);
		BN_sub(e, e, d);
		BN_div(a, b, e, c, ctx);
d1172 1
d1194 3
a1196 3
	BN_one(a);
	BN_one(b);
	BN_zero(c);
d1204 1
a1204 1
	BN_set_word(c, 16);
d1212 1
a1212 1
	BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */
d1214 2
a1215 2
		BN_bntest_rand(a, 20 + i * 5, 0, 0);
		BN_bntest_rand(b, 2 + i, 0, 0);
d1224 1
a1224 1
				BN_print(bp, a);
d1226 1
a1226 1
				BN_print(bp, b);
d1228 1
a1228 1
				BN_print(bp, c);
d1231 1
a1231 1
			BN_print(bp, d);
d1234 3
a1236 3
		BN_exp(e, a, b, ctx);
		BN_sub(e, e, d);
		BN_div(a, b, e, c, ctx);
d1260 1
a1260 1
	int rc = 1;
d1272 1
a1272 1
	mont = BN_MONT_CTX_new();
d1274 1
a1274 1
	BN_bntest_rand(m, 1024, 0, 1); /* must be odd for montgomery */
d1276 2
a1277 2
	BN_bntest_rand(a, 1024, 0, 0);
	BN_zero(p);
d1288 1
a1288 1
	BN_hex2bn(&a,
d1293 2
a1294 1
	BN_hex2bn(&b,
d1299 2
a1300 1
	BN_hex2bn(&n,
d1305 4
a1308 3
	BN_MONT_CTX_set(mont, n, ctx);
	BN_mod_mul_montgomery(c, a, b, mont, ctx);
	BN_mod_mul_montgomery(d, b, a, mont, ctx);
d1316 1
a1316 1
	BN_hex2bn(&n,
d1333 2
a1334 1
	BN_hex2bn(&a,
d1351 6
a1356 4
	b = BN_dup(a);
	BN_MONT_CTX_set(mont, n, ctx);
	BN_mod_mul_montgomery(c, a, a, mont, ctx);
	BN_mod_mul_montgomery(d, a, b, mont, ctx);
d1364 2
a1365 2
	BN_bntest_rand(p, 1024, 0, 0);
	BN_zero(a);
d1380 2
a1381 2
	BN_one(a);
	BN_MONT_CTX_set(mont, m, ctx);
d1400 1
a1400 1
	BN_bntest_rand(e, 1024, 0, 0);
d1438 1
a1438 1
	BN_one(one);
d1441 2
a1442 2
		BN_bntest_rand(a, 20 + i * 5, 0, 0);
		BN_bntest_rand(b, 2 + i, 0, 0);
d1451 1
a1451 1
				BN_print(bp, a);
d1453 1
a1453 1
				BN_print(bp, b);
d1456 1
a1456 1
			BN_print(bp, d);
d1459 1
a1459 1
		BN_one(e);
d1461 2
a1462 2
			BN_mul(e, e, a, ctx);
		BN_sub(e, e, d);
d1469 1
d1483 1
a1483 1
	int i, ret = 0;
d1490 2
a1491 2
		BN_rand(&a, 512, 0, 0);
		BN_copy(&b, BN_value_one());
d1494 1
a1494 1
		BN_GF2m_add(&c, &a, &b);
d1498 1
a1498 1
				BN_print(bp, &a);
d1500 1
a1500 1
				BN_print(bp, &b);
d1503 1
a1503 1
			BN_print(bp, &c);
d1513 1
a1513 1
		BN_GF2m_add(&c, &c, &c);
d1520 1
a1520 1
	ret = 1;
d1525 1
a1525 1
	return ret;
d1532 1
a1532 1
	int i, j, ret = 0;
d1543 2
a1544 2
	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);
d1547 1
a1547 1
		BN_bntest_rand(a, 1024, 0, 0);
d1549 1
a1549 1
			BN_GF2m_mod(c, a, b[j]);
d1553 1
a1553 1
					BN_print(bp, a);
d1555 1
a1555 1
					BN_print(bp, b[j]);
d1557 1
a1557 1
					BN_print(bp, c);
d1562 2
a1563 2
			BN_GF2m_add(d, a, c);
			BN_GF2m_mod(e, d, b[j]);
d1571 1
a1571 1
	ret = 1;
d1579 1
a1579 1
	return ret;
d1586 1
a1586 1
	int i, j, ret = 0;
d1600 2
a1601 2
	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);
d1604 3
a1606 3
		BN_bntest_rand(a, 1024, 0, 0);
		BN_bntest_rand(c, 1024, 0, 0);
		BN_bntest_rand(d, 1024, 0, 0);
d1608 1
a1608 1
			BN_GF2m_mod_mul(e, a, c, b[j], ctx);
d1612 1
a1612 1
					BN_print(bp, a);
d1614 1
a1614 1
					BN_print(bp, c);
d1616 1
a1616 1
					BN_print(bp, b[j]);
d1618 1
a1618 1
					BN_print(bp, e);
d1623 5
a1627 5
			BN_GF2m_add(f, a, d);
			BN_GF2m_mod_mul(g, f, c, b[j], ctx);
			BN_GF2m_mod_mul(h, d, c, b[j], ctx);
			BN_GF2m_add(f, e, g);
			BN_GF2m_add(f, f, h);
d1635 1
a1635 1
	ret = 1;
d1646 1
a1646 1
	return ret;
d1653 1
a1653 1
	int i, j, ret = 0;
d1663 2
a1664 2
	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);
d1667 1
a1667 1
		BN_bntest_rand(a, 1024, 0, 0);
d1669 3
a1671 3
			BN_GF2m_mod_sqr(c, a, b[j], ctx);
			BN_copy(d, a);
			BN_GF2m_mod_mul(d, a, d, b[j], ctx);
d1675 1
a1675 1
					BN_print(bp, a);
d1677 1
a1677 1
					BN_print(bp, b[j]);
d1679 1
a1679 1
					BN_print(bp, c);
d1681 1
a1681 1
					BN_print(bp, d);
d1686 1
a1686 1
			BN_GF2m_add(d, c, d);
d1694 1
a1694 1
	ret = 1;
d1701 1
a1701 1
	return ret;
d1708 1
a1708 1
	int i, j, ret = 0;
d1718 2
a1719 2
	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);
d1722 1
a1722 1
		BN_bntest_rand(a, 512, 0, 0);
d1724 2
a1725 2
			BN_GF2m_mod_inv(c, a, b[j], ctx);
			BN_GF2m_mod_mul(d, a, c, b[j], ctx);
d1729 1
a1729 1
					BN_print(bp, a);
d1731 1
a1731 1
					BN_print(bp, c);
d1733 1
a1733 1
					BN_print(bp, b[j]);
d1745 1
a1745 1
	ret = 1;
d1752 1
a1752 1
	return ret;
d1759 1
a1759 1
	int i, j, ret = 0;
d1771 2
a1772 2
	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);
d1775 2
a1776 2
		BN_bntest_rand(a, 512, 0, 0);
		BN_bntest_rand(c, 512, 0, 0);
d1778 3
a1780 3
			BN_GF2m_mod_div(d, a, c, b[j], ctx);
			BN_GF2m_mod_mul(e, d, c, b[j], ctx);
			BN_GF2m_mod_div(f, a, e, b[j], ctx);
d1784 1
a1784 1
					BN_print(bp, a);
d1786 1
a1786 1
					BN_print(bp, c);
d1788 1
a1788 1
					BN_print(bp, d);
d1790 1
a1790 1
					BN_print(bp, b[j]);
d1802 1
a1802 1
	ret = 1;
d1811 1
a1811 1
	return ret;
d1818 1
a1818 1
	int i, j, ret = 0;
d1830 2
a1831 2
	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);
d1834 3
a1836 3
		BN_bntest_rand(a, 512, 0, 0);
		BN_bntest_rand(c, 512, 0, 0);
		BN_bntest_rand(d, 512, 0, 0);
d1838 5
a1842 5
			BN_GF2m_mod_exp(e, a, c, b[j], ctx);
			BN_GF2m_mod_exp(f, a, d, b[j], ctx);
			BN_GF2m_mod_mul(e, e, f, b[j], ctx);
			BN_add(f, c, d);
			BN_GF2m_mod_exp(f, a, f, b[j], ctx);
d1846 1
a1846 1
					BN_print(bp, a);
d1848 1
a1848 1
					BN_print(bp, c);
d1850 1
a1850 1
					BN_print(bp, d);
d1852 1
a1852 1
					BN_print(bp, e);
d1854 1
a1854 1
					BN_print(bp, f);
d1856 1
a1856 1
					BN_print(bp, b[j]);
d1861 1
a1861 1
			BN_GF2m_add(f, e, f);
d1869 1
a1869 1
	ret = 1;
d1878 1
a1878 1
	return ret;
d1885 1
a1885 1
	int i, j, ret = 0;
d1897 2
a1898 2
	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);
d1901 1
a1901 1
		BN_bntest_rand(a, 512, 0, 0);
d1903 3
a1905 3
			BN_GF2m_mod(c, a, b[j]);
			BN_GF2m_mod_sqrt(d, a, b[j], ctx);
			BN_GF2m_mod_sqr(e, d, b[j], ctx);
d1909 1
a1909 1
					BN_print(bp, d);
d1911 1
a1911 1
					BN_print(bp, a);
d1916 1
a1916 1
			BN_GF2m_add(f, c, e);
d1924 1
a1924 1
	ret = 1;
d1933 1
a1933 1
	return ret;
d1940 1
a1940 1
	int i, j, s = 0, t, ret = 0;
d1951 2
a1952 2
	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);
d1955 1
a1955 1
		BN_bntest_rand(a, 512, 0, 0);
d1960 3
a1962 3
				BN_GF2m_mod_sqr(d, c, b[j], ctx);
				BN_GF2m_add(d, c, d);
				BN_GF2m_mod(e, a, b[j]);
d1966 1
a1966 1
						BN_print(bp, c);
d1968 1
a1968 1
						BN_print(bp, a);
d1970 1
a1970 1
						BN_print(bp, b[j]);
d1975 1
a1975 1
				BN_GF2m_add(e, e, d);
d1987 1
a1987 1
						BN_print(bp, a);
d1989 1
a1989 1
						BN_print(bp, b[j]);
d2002 1
a2002 1
	ret = 1;
d2010 1
a2010 1
	return ret;
d2038 1
a2038 1
	int ret = 0;
d2107 1
a2107 1
			BN_print_fp(stderr, a);
d2109 1
a2109 1
			BN_print_fp(stderr, b);
d2120 1
a2120 1
	ret = 1;
d2126 1
a2126 1
	return ret;
d2135 1
a2135 1
	int ret = 0;
d2196 1
a2196 1
				BN_print_fp(stderr, a);
d2198 1
a2198 1
				BN_print_fp(stderr, r);
d2200 1
a2200 1
				BN_print_fp(stderr, p);
d2212 1
a2212 1
	ret = 1;
d2217 1
a2217 1
	return ret;
d2223 1
a2223 1
	BIGNUM *a, *b, *c, *d;
d2230 1
a2230 1
	BN_one(c);
d2236 1
a2236 1
		BN_bntest_rand(a, 200, 0, 0);
d2240 2
a2241 2
		(void)BN_lshift(b, a, i + 1);
		BN_add(c, c, c);
d2244 1
a2244 1
				BN_print(bp, a);
d2246 1
a2246 1
				BN_print(bp, c);
d2249 1
a2249 1
			BN_print(bp, b);
d2252 2
a2253 2
		BN_mul(d, a, c, ctx);
		BN_sub(d, d, b);
d2257 1
a2257 1
			BN_print_fp(stderr, a);
d2259 1
a2259 1
			BN_print_fp(stderr, b);
d2261 1
a2261 1
			BN_print_fp(stderr, c);
d2263 1
a2263 1
			BN_print_fp(stderr, d);
d2269 1
d2288 1
a2288 1
	BN_bntest_rand(a, 200, 0, 0);
d2291 1
a2291 1
		(void)BN_lshift1(b, a);
d2294 1
a2294 1
				BN_print(bp, a);
d2298 1
a2298 1
			BN_print(bp, b);
d2301 2
a2302 2
		BN_add(c, a, a);
		BN_sub(a, b, c);
d2309 1
a2309 1
		BN_copy(a, b);
d2311 1
d2330 1
a2330 1
	BN_one(c);
d2332 1
a2332 1
	BN_bntest_rand(a, 200, 0, 0);
d2335 2
a2336 2
		(void)BN_rshift(b, a, i + 1);
		BN_add(c, c, c);
d2339 1
a2339 1
				BN_print(bp, a);
d2341 1
a2341 1
				BN_print(bp, c);
d2344 1
a2344 1
			BN_print(bp, b);
d2347 2
a2348 2
		BN_div(d, e, a, c, ctx);
		BN_sub(d, d, b);
d2355 1
d2375 1
a2375 1
	BN_bntest_rand(a, 200, 0, 0);
d2378 1
a2378 1
		(void)BN_rshift1(b, a);
d2381 1
a2381 1
				BN_print(bp, a);
d2385 1
a2385 1
			BN_print(bp, b);
d2388 2
a2389 2
		BN_sub(c, a, b);
		BN_sub(c, c, b);
d2395 1
a2395 1
		BN_copy(a, b);
d2397 1
d2416 1
a2416 1
	BN_MONT_CTX *mont_ctx;
d2419 1
a2419 1
	int ok = 0;
d2422 5
a2426 5
	p = BN_CTX_get(ctx);
	x = BN_CTX_get(ctx);
	y = BN_CTX_get(ctx);
	r = BN_CTX_get(ctx);
	r2 = BN_CTX_get(ctx);
d2444 4
a2447 2
			char *r_str = BN_bn2hex(r);
			char *r2_str = BN_bn2hex(r2);
d2457 1
a2457 1
	ok = 1;
d2462 1
a2462 1
	return ok;
@


1.16
log
@LibreSSL : regress for carry bug in mulx4x_mont and sqr8x_mont

This regress bntest.c patch is originally from master branch of OpenSSL.
- dca2e0e test/bntest.c: regression test for CVE-2016-7055.
- 3e7a496 test/bntest.c: regression test for carry bug in bn_sqr8x_internal.

These tests were added for these commit.
- 2fac86d bn/asm/x86_64-mont.pl: fix for CVE-2016-7055 (Low severity).
- 3f4bcf5 bn/asm/x86_64-mont5.pl: fix carry bug in bn_sqr8x_internal.

ok beck@@
@
text
@a1241 1
	char *bigstring;
@


1.15
log
@Make explicit _ct and _nonct versions of bn_mod_exp funcitons that
matter for constant time, and make the public interface only used
external to the library.

This moves us to a model where the important things are constant time
versions unless you ask for them not to be, rather than the opposite.
I'll continue with this method by method.

Add regress tests for same.
ok jsing@@
@
text
@d1239 1
a1239 1
	BIGNUM *a, *p, *m, *d, *e;
d1242 1
d1249 3
d1268 70
d1395 3
@


1.14
log
@Update libcrypto regress to handle header and non-exported symbol changes.
@
text
@d87 9
d1049 8
d1064 64
@


1.13
log
@import new BN tests from OpenSSL

New tests that various BIGNUM methods behave correctly on zero/even inputs.
from OpenSSL

ok beck@@
@
text
@d87 2
@


1.12
log
@remove extra assignment of s from 1.11, fix regression test
@
text
@d107 2
a120 1
int test_mod_exp_sizes(BIO *bp, BN_CTX *ctx);
d124 3
a126 2
static const unsigned char lst[]="\xC6\x4F\x43\x04\x2A\xEA\xCA\x6E\x58\x36\x80\x5B\xE8\xC9"
"\x9B\x04\x5D\x48\x36\xC2\xFD\x16\xC9\x64\xF0";
d265 5
a338 1

d341 3
a343 2
	BIO_puts(out,"1\n"); /* make sure the Perl script fed by bc notices
	                      * the failure, see test_bn in test/Makefile.ssl*/
d377 2
a378 2
		a.neg=!a.neg;
		b.neg=!b.neg;
d446 1
a446 1
	BIGNUM a, b,c, d, e;
d456 8
d471 1
a471 1
			BN_bntest_rand(&b, 50 + 3*(i - num1), 0, 0);
d519 1
a519 1
			BIO_printf(bp, "%lX%08lX",h,l);
d521 1
a521 1
			BIO_printf(bp, "%lX",l);
d531 1
a531 1
	BIGNUM   a, b;
d604 1
a604 1
	BIGNUM a, b,c, d, e;
d623 1
a623 1
			BN_bntest_rand(&b, 50 + 3*(i - num1), 0, 0);
d673 1
a673 1
	BIGNUM a, b,c, d, e;
d806 1
a806 1
 err:
d817 1
a817 1
	BIGNUM a, b,c, d,A, B;
d835 14
a848 2
	BN_bntest_rand(&a,100,0,0);
	BN_bntest_rand(&b,100,0,0);
d850 1
a850 1
		int bits = (200*(i + 1))/num2;
d863 2
a864 2
		BN_mod_mul_montgomery(&c,&A,&B,mont,ctx);
		BN_from_montgomery(&A,&c,mont,ctx);
d909 1
a909 1
	BN_bntest_rand(a,1024,0,0);
d911 1
a911 1
		BN_bntest_rand(b,450+i*10,0,0);
d914 1
a914 1
		BN_mod(c,a,b,ctx);
d925 1
a925 1
		BN_div(d, e,a, b, ctx);
d954 8
d963 1
a963 1
		BN_bntest_rand(c,1024,0,0);
d965 2
a966 2
			BN_bntest_rand(a,475+i*10,0,0);
			BN_bntest_rand(b,425+i*11,0,0);
d969 1
a969 1
			if (!BN_mod_mul(e, a,b, c, ctx)) {
d998 1
a998 1
			BN_mul(d, a,b, ctx);
d1000 1
a1000 1
			BN_div(a, b,d, c, ctx);
d1031 9
a1039 1
	BN_bntest_rand(c,30,0,1); /* must be odd for montgomery */
d1041 2
a1042 2
		BN_bntest_rand(a,20+i*5,0,0);
		BN_bntest_rand(b,2+i,0,0);
d1044 1
a1044 1
		if (!BN_mod_exp(d, a,b, c, ctx)) {
d1061 1
a1061 1
		BN_exp(e, a,b, ctx);
d1063 1
a1063 1
		BN_div(a, b,e, c, ctx);
d1091 19
a1109 1
	BN_bntest_rand(c,30,0,1); /* must be odd for montgomery */
d1111 2
a1112 2
		BN_bntest_rand(a,20+i*5,0,0);
		BN_bntest_rand(b,2+i,0,0);
d1114 1
a1114 1
		if (!BN_mod_exp_mont_consttime(d, a,b, c,ctx, NULL)) {
d1131 1
a1131 1
		BN_exp(e, a,b, ctx);
d1133 1
a1133 1
		BN_div(a, b,e, c, ctx);
d1140 1
d1149 92
d1256 2
a1257 2
		BN_bntest_rand(a,20+i*5,0,0);
		BN_bntest_rand(b,2+i,0,0);
d1259 1
a1259 1
		if (BN_exp(d, a,b, ctx) <= 0) {
d1276 1
a1276 1
			BN_mul(e, e,a, ctx);
d1322 2
a1323 1
		if ((BN_is_odd(&a) && BN_is_odd(&c)) || (!BN_is_odd(&a) && !BN_is_odd(&c))) {
d1347 2
a1348 2
	int p0[] = {163, 7,6, 3,0, -1};
	int p1[] = {193, 15, 0, -1};
d1401 2
a1402 2
	int p0[] = {163, 7,6, 3,0, -1};
	int p1[] = {193, 15, 0, -1};
d1468 2
a1469 2
	int p0[] = {163, 7,6, 3,0, -1};
	int p1[] = {193, 15, 0, -1};
d1523 2
a1524 2
	int p0[] = {163, 7,6, 3,0, -1};
	int p1[] = {193, 15, 0, -1};
d1574 2
a1575 2
	int p0[] = {163, 7,6, 3,0, -1};
	int p1[] = {193, 15, 0, -1};
d1633 2
a1634 2
	int p0[] = {163, 7,6, 3,0, -1};
	int p1[] = {193, 15, 0, -1};
d1700 2
a1701 2
	int p0[] = {163, 7,6, 3,0, -1};
	int p1[] = {193, 15, 0, -1};
d1755 2
a1756 2
	int p0[] = {163, 7,6, 3,0, -1};
	int p1[] = {193, 15, 0, -1};
d1795 1
d1811 1
a1811 1
		if (s == 0) {
a1826 1

d1830 1
a1830 1
	char c='*';
d1833 1
a1833 1
		c='.';
d1835 1
a1835 1
		c='+';
d1837 1
a1837 1
		c='*';
d1839 1
a1839 1
		c='\n';
d1842 1
a1842 1
	return 1;
d1863 9
a1871 8
	/* We test BN_kronecker(a, b, ctx) just for  b  odd (Jacobi symbol).
	 * In this case we know that if  b  is prime, then BN_kronecker(a, b, ctx)
	 * is congruent to $a^{(b-1)/2}$, modulo $b$ (Legendre symbol).
	 * So we generate a random prime  b  and compare these values
	 * for a number of random  a's.  (That is, we run the Solovay-Strassen
	 * primality test to confirm that  b  is prime, except that we
	 * don't want to test whether  b  is prime but whether BN_kronecker
	 * works.) */
d1968 1
a1968 1
			if (!BN_set_word(r, 2*i + 1))
d1978 4
a1981 2
			/* construct 'a' such that it is a square modulo p,
			 * but in general not a proper square and not reduced modulo p */
d2050 1
a2050 1
		BN_bntest_rand(a,200,0,0);
d2066 1
a2066 1
		BN_mul(d, a,c, ctx);
d2101 1
a2101 1
	BN_bntest_rand(a,200,0,0);
d2144 1
a2144 1
	BN_bntest_rand(a,200,0,0);
d2159 1
a2159 1
		BN_div(d, e,a, c, ctx);
d2186 1
a2186 1
	BN_bntest_rand(a,200,0,0);
d2218 1
a2218 1
	static int sign[8] = {0, 0,0, 1,1, 0,1, 1};
@


1.11
log
@On systems where we do not have BN_ULLONG defined (most 64-bit systems),
BN_mod_word() can return incorrect results if the supplied modulus is
too big, so we need to fall back to BN_div_word.

Now that BN_mod_word may fail, handle errors properly update the man page.

Thanks to Brian Smith for pointing out these fixes from BoringSSL:

https://boringssl.googlesource.com/boringssl/+/67cb49d045f04973ddba0f92fe8a8ad483c7da89
https://boringssl.googlesource.com/boringssl/+/44bedc348d9491e63c7ed1438db100a4b8a830be

ok beck@@
@
text
@d517 1
a517 1
	BN_ULONG r, rmod, s;
a538 1
		s = b.d[0];
@


1.10
log
@check return value for BN_hex2bn in regression tests
@
text
@d517 1
a517 1
	BN_ULONG r, s;
d526 5
a530 2
			BN_bntest_rand(&a, 512, -1, 0);
			BN_bntest_rand(&b, BN_BITS2, -1, 0);
d534 7
a540 1
		BN_copy(&b, &a);
d542 11
@


1.9
log
@remove mysterious, decorative comment blocklets
@
text
@d724 5
a728 2
	BN_hex2bn(&a, "80000000000000008000000000000001"
	    "FFFFFFFFFFFFFFFE0000000000000000");
d749 5
a753 2
	BN_hex2bn(&a, "80000000000000000000000080000001"
	    "FFFFFFFE000000000000000000000000");
@


1.8
log
@Explicitly mark ignored BN_* return vals in tests.

The tests will fail all the same.
Fixes Coverity 78811 21659 21658 21657. Discussed with beck@@
@
text
@d332 1
a332 1
/**/
d795 2
a796 2
	BN_bntest_rand(&a,100,0,0); /**/
	BN_bntest_rand(&b,100,0,0); /**/
d811 2
a812 2
		BN_mod_mul_montgomery(&c,&A,&B,mont,ctx);/**/
		BN_from_montgomery(&A,&c,mont,ctx);/**/
d857 1
a857 1
	BN_bntest_rand(a,1024,0,0); /**/
d859 1
a859 1
		BN_bntest_rand(b,450+i*10,0,0); /**/
d862 1
a862 1
		BN_mod(c,a,b,ctx);/**/
d903 1
a903 1
		BN_bntest_rand(c,1024,0,0); /**/
d905 2
a906 2
			BN_bntest_rand(a,475+i*10,0,0); /**/
			BN_bntest_rand(b,425+i*11,0,0); /**/
d973 2
a974 2
		BN_bntest_rand(a,20+i*5,0,0); /**/
		BN_bntest_rand(b,2+i,0,0); /**/
d1025 2
a1026 2
		BN_bntest_rand(a,20+i*5,0,0); /**/
		BN_bntest_rand(b,2+i,0,0); /**/
d1077 2
a1078 2
		BN_bntest_rand(a,20+i*5,0,0); /**/
		BN_bntest_rand(b,2+i,0,0); /**/
d1867 1
a1867 1
		BN_bntest_rand(a,200,0,0); /**/
d1918 1
a1918 1
	BN_bntest_rand(a,200,0,0); /**/
d1961 1
a1961 1
	BN_bntest_rand(a,200,0,0); /**/
d2003 1
a2003 1
	BN_bntest_rand(a,200,0,0); /**/
@


1.7
log
@Fix CVE-2014-3570: properly calculate the square of a BIGNUM value.

See https://www.openssl.org/news/secadv_20150108.txt for a more detailed
discussion.

Original OpenSSL patch here:
https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0

The regression test is modified a little for KNF.
ok miod@@
@
text
@d803 1
a803 1
		BN_MONT_CTX_set(mont, &n, ctx);
d1867 1
a1867 1
	    BN_bntest_rand(a,200,0,0); /**/
d1871 1
a1871 1
		BN_lshift(b, a, i + 1);
d1921 1
a1921 1
		BN_lshift1(b, a);
d1964 1
a1964 1
		BN_rshift(b, a, i + 1);
d2006 1
a2006 1
		BN_rshift1(b, a);
@


1.6
log
@BN_free() has its own NULL check.
@
text
@d693 2
a694 3
	BIGNUM a, c,d, e;
	int i;
	int rc = 1;
d696 4
a699 4
	BN_init(&a);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);
d702 3
a704 3
		BN_bntest_rand(&a, 40 + i*10, 0, 0);
		a.neg = rand_neg();
		BN_sqr(&c, &a, ctx);
d707 1
a707 1
				BN_print(bp, &a);
d709 1
a709 1
				BN_print(bp, &a);
d712 1
a712 1
			BN_print(bp, &c);
d715 3
a717 3
		BN_div(&d, &e, &c, &a, ctx);
		BN_sub(&d, &d, &a);
		if (!BN_is_zero(&d) || !BN_is_zero(&e)) {
d719 1
a719 2
			rc = 0;
			break;
d722 50
a771 5
	BN_free(&a);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	return (rc);
@


1.5
log
@KNF.
@
text
@d1712 4
a1715 8
	if (a != NULL)
		BN_free(a);
	if (b != NULL)
		BN_free(b);
	if (r != NULL)
		BN_free(r);
	if (t != NULL)
		BN_free(t);
d1802 3
a1804 6
	if (a != NULL)
		BN_free(a);
	if (p != NULL)
		BN_free(p);
	if (r != NULL)
		BN_free(r);
@


1.4
log
@Fix various memory leaks by not exiting so abruptly from failed tests.
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d61 1
a61 1
 * Portions of the attached software ("Contribution") are developed by 
d67 1
a67 1
 * The binary polynomial arithmetic software is originally written by 
d94 1
a94 1
int test_lshift(BIO *bp,BN_CTX *ctx,BIGNUM *a_);
d96 2
a97 2
int test_rshift(BIO *bp,BN_CTX *ctx);
int test_div(BIO *bp,BN_CTX *ctx);
d99 1
a99 1
int test_div_recp(BIO *bp,BN_CTX *ctx);
d101 7
a107 7
int test_sqr(BIO *bp,BN_CTX *ctx);
int test_mont(BIO *bp,BN_CTX *ctx);
int test_mod(BIO *bp,BN_CTX *ctx);
int test_mod_mul(BIO *bp,BN_CTX *ctx);
int test_mod_exp(BIO *bp,BN_CTX *ctx);
int test_mod_exp_mont_consttime(BIO *bp,BN_CTX *ctx);
int test_exp(BIO *bp,BN_CTX *ctx);
d110 9
a118 9
int test_gf2m_mod_mul(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_sqr(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_inv(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_div(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_exp(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_sqrt(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_solve_quad(BIO *bp,BN_CTX *ctx);
int test_kron(BIO *bp,BN_CTX *ctx);
int test_sqrt(BIO *bp,BN_CTX *ctx);
d121 1
a121 1
static int results=0;
d140 1
a140 1
	char *outfile=NULL;
d147 5
a151 4
		if (strcmp(*argv,"-results") == 0)
			results=1;
		else if (strcmp(*argv,"-out") == 0) {
			if (--argc < 1) break;
d159 3
a161 2
	ctx=BN_CTX_new();
	if (ctx == NULL) exit(1);
d163 3
a165 2
	out=BIO_new(BIO_s_file());
	if (out == NULL) exit(1);
d167 1
a167 1
		BIO_set_fp(out,stdout,BIO_NOCLOSE);
d169 1
a169 1
		if (!BIO_write_filename(out,outfile)) {
d176 1
a176 1
		BIO_puts(out,"obase=16\nibase=16\n");
d178 3
a180 2
	message(out,"BN_add");
	if (!test_add(out)) goto err;
d183 3
a185 2
	message(out,"BN_sub");
	if (!test_sub(out)) goto err;
d188 3
a190 2
	message(out,"BN_lshift1");
	if (!test_lshift1(out)) goto err;
d193 3
a195 3
	message(out,"BN_lshift (fixed)");
	if (!test_lshift(out,ctx,BN_bin2bn(lst,sizeof(lst)-1,NULL)))
	    goto err;
d198 3
a200 2
	message(out,"BN_lshift");
	if (!test_lshift(out,ctx,NULL)) goto err;
d203 3
a205 2
	message(out,"BN_rshift1");
	if (!test_rshift1(out)) goto err;
d208 3
a210 2
	message(out,"BN_rshift");
	if (!test_rshift(out,ctx)) goto err;
d213 3
a215 2
	message(out,"BN_sqr");
	if (!test_sqr(out,ctx)) goto err;
d218 3
a220 2
	message(out,"BN_mul");
	if (!test_mul(out)) goto err;
d223 3
a225 2
	message(out,"BN_div");
	if (!test_div(out,ctx)) goto err;
d228 3
a230 2
	message(out,"BN_div_word");
	if (!test_div_word(out)) goto err;
d233 3
a235 2
	message(out,"BN_div_recp");
	if (!test_div_recp(out,ctx)) goto err;
d238 3
a240 2
	message(out,"BN_mod");
	if (!test_mod(out,ctx)) goto err;
d243 3
a245 2
	message(out,"BN_mod_mul");
	if (!test_mod_mul(out,ctx)) goto err;
d248 3
a250 2
	message(out,"BN_mont");
	if (!test_mont(out,ctx)) goto err;
d253 3
a255 2
	message(out,"BN_mod_exp");
	if (!test_mod_exp(out,ctx)) goto err;
d258 3
a260 2
	message(out,"BN_mod_exp_mont_consttime");
	if (!test_mod_exp_mont_consttime(out,ctx)) goto err;
d263 3
a265 2
	message(out,"BN_exp");
	if (!test_exp(out,ctx)) goto err;
d268 3
a270 2
	message(out,"BN_kronecker");
	if (!test_kron(out,ctx)) goto err;
d273 3
a275 2
	message(out,"BN_mod_sqrt");
	if (!test_sqrt(out,ctx)) goto err;
d284 3
a286 2
	message(out,"BN_GF2m_add");
	if (!test_gf2m_add(out)) goto err;
d289 3
a291 2
	message(out,"BN_GF2m_mod");
	if (!test_gf2m_mod(out)) goto err;
d294 3
a296 2
	message(out,"BN_GF2m_mod_mul");
	if (!test_gf2m_mod_mul(out,ctx)) goto err;
d299 3
a301 2
	message(out,"BN_GF2m_mod_sqr");
	if (!test_gf2m_mod_sqr(out,ctx)) goto err;
d304 3
a306 2
	message(out,"BN_GF2m_mod_inv");
	if (!test_gf2m_mod_inv(out,ctx)) goto err;
d309 3
a311 2
	message(out,"BN_GF2m_mod_div");
	if (!test_gf2m_mod_div(out,ctx)) goto err;
d314 3
a316 2
	message(out,"BN_GF2m_mod_exp");
	if (!test_gf2m_mod_exp(out,ctx)) goto err;
d319 3
a321 2
	message(out,"BN_GF2m_mod_sqrt");
	if (!test_gf2m_mod_sqrt(out,ctx)) goto err;
d324 3
a326 2
	message(out,"BN_GF2m_mod_solve_quad");
	if (!test_gf2m_mod_solve_quad(out,ctx)) goto err;
d346 1
a346 1
	BIGNUM a,b,c;
d354 6
a359 6
	BN_bntest_rand(&a,512,0,0);
	for (i=0; i<num0; i++) {
		BN_bntest_rand(&b,450+i,0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_add(&c,&a,&b);
d362 4
a365 4
				BN_print(bp,&a);
				BIO_puts(bp," + ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
d367 2
a368 2
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
d372 6
a377 6
		BN_add(&c,&c,&b);
		BN_add(&c,&c,&a);
		if(!BN_is_zero(&c)) {
		    fprintf(stderr,"Add test failed!\n");
		    rc = 0;
		    break;
d383 1
a383 1
	return(rc);
d389 1
a389 1
	BIGNUM a,b,c;
d397 1
a397 1
	for (i=0; i<num0+num1; i++) {
d399 3
a401 3
			BN_bntest_rand(&a,512,0,0);
			BN_copy(&b,&a);
			if (BN_set_bit(&a,i)==0) {
d405 1
a405 1
			BN_add_word(&b,i);
d407 3
a409 3
			BN_bntest_rand(&b,400+i-num1,0,0);
			a.neg=rand_neg();
			b.neg=rand_neg();
d411 1
a411 1
		BN_sub(&c,&a,&b);
d414 14
a427 14
				BN_print(bp,&a);
				BIO_puts(bp," - ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
			}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
		}
		BN_add(&c,&c,&b);
		BN_sub(&c,&c,&a);
		if(!BN_is_zero(&c)) {
		    fprintf(stderr,"Subtract test failed!\n");
		    rc = 0;
		    break;
d433 1
a433 1
	return(rc);
d439 1
a439 1
	BIGNUM a,b,c,d,e;
d449 1
a449 1
	for (i=0; i<num0+num1; i++) {
d451 4
a454 4
			BN_bntest_rand(&a,400,0,0);
			BN_copy(&b,&a);
			BN_lshift(&a,&a,i);
			BN_add_word(&a,i);
d456 4
a459 4
			BN_bntest_rand(&b,50+3*(i-num1),0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_div(&d,&c,&a,&b,ctx);
d462 4
a465 4
				BN_print(bp,&a);
				BIO_puts(bp," / ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
d467 2
a468 2
			BN_print(bp,&d);
			BIO_puts(bp,"\n");
d471 15
a485 15
				BN_print(bp,&a);
				BIO_puts(bp," % ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
			}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
		}
		BN_mul(&e,&d,&b,ctx);
		BN_add(&d,&e,&c);
		BN_sub(&d,&d,&a);
		if(!BN_is_zero(&d)) {
		    fprintf(stderr,"Division test failed!\n");
		    rc = 0;
		    break;
d493 1
a493 1
	return(rc);
d497 1
a497 1
print_word(BIO *bp,BN_ULONG w)
d501 1
a501 1
		unsigned long h=(unsigned long)(w>>32), l=(unsigned long)(w);
d504 1
a504 1
			BIO_printf(bp,"%lX%08lX",h,l);
d506 1
a506 1
			BIO_printf(bp,"%lX",l);
d510 1
a510 1
	BIO_printf(bp,BN_HEX_FMT1,w);
d516 2
a517 2
	BIGNUM   a,b;
	BN_ULONG r,s;
d524 1
a524 1
	for (i=0; i<num0; i++) {
d526 2
a527 2
			BN_bntest_rand(&a,512,-1,0);
			BN_bntest_rand(&b,BN_BITS2,-1,0);
d536 4
a539 4
				BN_print(bp,&a);
				BIO_puts(bp," / ");
				print_word(bp,s);
				BIO_puts(bp," - ");
d541 2
a542 2
			BN_print(bp,&b);
			BIO_puts(bp,"\n");
d545 15
a559 15
				BN_print(bp,&a);
				BIO_puts(bp," % ");
				print_word(bp,s);
				BIO_puts(bp," - ");
			}
			print_word(bp,r);
			BIO_puts(bp,"\n");
		}
		BN_mul_word(&b,s);
		BN_add_word(&b,r);
		BN_sub(&b,&a,&b);
		if(!BN_is_zero(&b)) {
		    fprintf(stderr,"Division (word) test failed!\n");
		    rc = 0;
		    break;
d564 1
a564 1
	return(rc);
d570 1
a570 1
	BIGNUM a,b,c,d,e;
d582 1
a582 1
	for (i=0; i<num0+num1; i++) {
d584 4
a587 4
			BN_bntest_rand(&a,400,0,0);
			BN_copy(&b,&a);
			BN_lshift(&a,&a,i);
			BN_add_word(&a,i);
d589 5
a593 5
			BN_bntest_rand(&b,50+3*(i-num1),0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_RECP_CTX_set(&recp,&b,ctx);
		BN_div_recp(&d,&c,&a,&recp,ctx);
d596 4
a599 4
				BN_print(bp,&a);
				BIO_puts(bp," / ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
d601 2
a602 2
			BN_print(bp,&d);
			BIO_puts(bp,"\n");
d605 20
a624 20
				BN_print(bp,&a);
				BIO_puts(bp," % ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
			}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
		}
		BN_mul(&e,&d,&b,ctx);
		BN_add(&d,&e,&c);
		BN_sub(&d,&d,&a);
		if(!BN_is_zero(&d)) {
		    fprintf(stderr,"Reciprocal division test failed!\n");
		    fprintf(stderr,"a=");
		    BN_print_fp(stderr,&a);
		    fprintf(stderr,"\nb=");
		    BN_print_fp(stderr,&b);
		    fprintf(stderr,"\n");
		    rc = 0;
		    break;
d633 1
a633 1
	return(rc);
d639 1
a639 1
	BIGNUM a,b,c,d,e;
d645 3
a647 2
	if (ctx == NULL) exit(1);
	
d654 1
a654 1
	for (i=0; i<num0+num1; i++) {
d656 2
a657 2
			BN_bntest_rand(&a,100,0,0);
			BN_bntest_rand(&b,100,0,0);
d659 4
a662 4
			BN_bntest_rand(&b,i-num1,0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_mul(&c,&a,&b,ctx);
d665 14
a678 14
				BN_print(bp,&a);
				BIO_puts(bp," * ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
			}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
		}
		BN_div(&d,&e,&c,&a,ctx);
		BN_sub(&d,&d,&b);
		if(!BN_is_zero(&d) || !BN_is_zero(&e)) {
		    fprintf(stderr,"Multiplication test failed!\n");
		    rc = 0;
		    break;
d687 1
a687 1
	return(rc);
d693 1
a693 1
	BIGNUM a,c,d,e;
d702 4
a705 4
	for (i=0; i<num0; i++) {
		BN_bntest_rand(&a,40+i*10,0,0);
		a.neg=rand_neg();
		BN_sqr(&c,&a,ctx);
d708 14
a721 14
				BN_print(bp,&a);
				BIO_puts(bp," * ");
				BN_print(bp,&a);
				BIO_puts(bp," - ");
			}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
		}
		BN_div(&d,&e,&c,&a,ctx);
		BN_sub(&d,&d,&a);
		if(!BN_is_zero(&d) || !BN_is_zero(&e)) {
		    fprintf(stderr,"Square test failed!\n");
		    rc = 0;
		    break;
d728 1
a728 1
	return(rc);
d734 1
a734 1
	BIGNUM a,b,c,d,A,B;
d740 1
a740 1
	mont=BN_MONT_CTX_new();
d754 2
a755 2
	for (i=0; i<num2; i++) {
		int bits = (200*(i+1))/num2;
d759 2
a760 2
		BN_bntest_rand(&n,bits,0,1);
		BN_MONT_CTX_set(mont,&n,ctx);
d762 2
a763 2
		BN_nnmod(&a,&a,&n,ctx);
		BN_nnmod(&b,&b,&n,ctx);
d765 2
a766 2
		BN_to_montgomery(&A,&a,mont,ctx);
		BN_to_montgomery(&B,&b,mont,ctx);
d772 16
a787 16
				BN_print(bp,&a);
				BIO_puts(bp," * ");
				BN_print(bp,&b);
				BIO_puts(bp," % ");
				BN_print(bp,&(mont->N));
				BIO_puts(bp," - ");
			}
			BN_print(bp,&A);
			BIO_puts(bp,"\n");
		}
		BN_mod_mul(&d,&a,&b,&n,ctx);
		BN_sub(&d,&d,&A);
		if(!BN_is_zero(&d)) {
		    fprintf(stderr,"Montgomery multiplication test failed!\n");
		    rc = 0;
		    break;
d798 1
a798 1
	return(rc);
d804 1
a804 1
	BIGNUM *a,*b,*c,*d,*e;
d808 5
a812 5
	a=BN_new();
	b=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
d815 1
a815 1
	for (i=0; i<num0; i++) {
d817 2
a818 2
		a->neg=rand_neg();
		b->neg=rand_neg();
d822 14
a835 14
				BN_print(bp,a);
				BIO_puts(bp," % ");
				BN_print(bp,b);
				BIO_puts(bp," - ");
			}
			BN_print(bp,c);
			BIO_puts(bp,"\n");
		}
		BN_div(d,e,a,b,ctx);
		BN_sub(e,e,c);
		if(!BN_is_zero(e)) {
		    fprintf(stderr,"Modulo test failed!\n");
		    rc = 0;
		    break;
d843 1
a843 1
	return(rc);
d849 2
a850 2
	BIGNUM *a,*b,*c,*d,*e;
	int i,j;
d853 5
a857 5
	a=BN_new();
	b=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
d859 1
a859 1
	for (j=0; j<3; j++) {
d861 1
a861 1
		for (i=0; i<num0; i++) {
d864 3
a866 3
			a->neg=rand_neg();
			b->neg=rand_neg();
			if (!BN_mod_mul(e,a,b,c,ctx)) {
d869 3
a871 3
				while ((l=ERR_get_error()))
					fprintf(stderr,"ERROR:%s\n",
					    ERR_error_string(l,NULL));
d876 5
a880 5
					BN_print(bp,a);
					BIO_puts(bp," * ");
					BN_print(bp,b);
					BIO_puts(bp," % ");
					BN_print(bp,c);
d887 2
a888 2
						BIO_puts(bp," + ");
						BN_print(bp,c);
d890 1
a890 1
					BIO_puts(bp," - ");
d892 2
a893 2
				BN_print(bp,e);
				BIO_puts(bp,"\n");
d895 8
a902 8
			BN_mul(d,a,b,ctx);
			BN_sub(d,d,e);
			BN_div(a,b,d,c,ctx);
			if(!BN_is_zero(b)) {
			    fprintf(stderr,"Modulo multiply test failed!\n");
			    ERR_print_errors_fp(stderr);
			    rc = 0;
			    goto done;
d912 1
a912 1
	return(rc);
d918 1
a918 1
	BIGNUM *a,*b,*c,*d,*e;
d922 5
a926 5
	a=BN_new();
	b=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
d929 1
a929 1
	for (i=0; i<num2; i++) {
d933 1
a933 1
		if (!BN_mod_exp(d,a,b,c,ctx)) {
d940 17
a956 17
				BN_print(bp,a);
				BIO_puts(bp," ^ ");
				BN_print(bp,b);
				BIO_puts(bp," % ");
				BN_print(bp,c);
				BIO_puts(bp," - ");
			}
			BN_print(bp,d);
			BIO_puts(bp,"\n");
		}
		BN_exp(e,a,b,ctx);
		BN_sub(e,e,d);
		BN_div(a,b,e,c,ctx);
		if(!BN_is_zero(b)) {
		    fprintf(stderr,"Modulo exponentiation test failed!\n");
		    rc = 0;
		    break;
d964 1
a964 1
	return(rc);
d970 1
a970 1
	BIGNUM *a,*b,*c,*d,*e;
d974 5
a978 5
	a=BN_new();
	b=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
d981 1
a981 1
	for (i=0; i<num2; i++) {
d985 1
a985 1
		if (!BN_mod_exp_mont_consttime(d,a,b,c,ctx,NULL)) {
d992 17
a1008 17
				BN_print(bp,a);
				BIO_puts(bp," ^ ");
				BN_print(bp,b);
				BIO_puts(bp," % ");
				BN_print(bp,c);
				BIO_puts(bp," - ");
			}
			BN_print(bp,d);
			BIO_puts(bp,"\n");
		}
		BN_exp(e,a,b,ctx);
		BN_sub(e,e,d);
		BN_div(a,b,e,c,ctx);
		if(!BN_is_zero(b)) {
		    fprintf(stderr,"Modulo exponentiation test failed!\n");
		    rc = 0;
		    break;
d1016 1
a1016 1
	return(rc);
d1022 1
a1022 1
	BIGNUM *a,*b,*d,*e,*one;
d1026 5
a1030 5
	a=BN_new();
	b=BN_new();
	d=BN_new();
	e=BN_new();
	one=BN_new();
d1033 1
a1033 1
	for (i=0; i<num2; i++) {
d1037 1
a1037 1
		if (BN_exp(d,a,b,ctx) <= 0) {
d1044 4
a1047 4
				BN_print(bp,a);
				BIO_puts(bp," ^ ");
				BN_print(bp,b);
				BIO_puts(bp," - ");
d1049 2
a1050 2
			BN_print(bp,d);
			BIO_puts(bp,"\n");
d1053 7
a1059 7
		for( ; !BN_is_zero(b) ; BN_sub(b,b,one))
		    BN_mul(e,e,a,ctx);
		BN_sub(e,e,d);
		if(!BN_is_zero(e)) {
		    fprintf(stderr,"Exponentiation test failed!\n");
		    rc = 0;
		    break;
d1067 1
a1067 1
	return(rc);
d1074 1
a1074 1
	BIGNUM a,b,c;
d1081 2
a1082 2
	for (i=0; i<num0; i++) {
		BN_rand(&a,512,0,0);
d1084 3
a1086 3
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_GF2m_add(&c,&a,&b);
d1090 4
a1093 4
				BN_print(bp,&a);
				BIO_puts(bp," ^ ");
				BN_print(bp,&b);
				BIO_puts(bp," = ");
d1095 2
a1096 2
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
d1100 2
a1101 2
		if((BN_is_odd(&a) && BN_is_odd(&c)) || (!BN_is_odd(&a) && !BN_is_odd(&c))) {
		    fprintf(stderr,"GF(2^m) addition test (a) failed!\n");
d1104 1
a1104 1
		BN_GF2m_add(&c,&c,&c);
d1106 2
a1107 2
		if(!BN_is_zero(&c)) {
		    fprintf(stderr,"GF(2^m) addition test (b) failed!\n");
d1122 1
a1122 1
	BIGNUM *a,*b[2],*c,*d,*e;
d1124 2
a1125 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
d1127 6
a1132 6
	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
d1137 1
a1137 1
	for (i=0; i<num0; i++) {
d1139 1
a1139 1
		for (j=0; j < 2; j++) {
d1144 6
a1149 6
					BN_print(bp,a);
					BIO_puts(bp," % ");
					BN_print(bp,b[j]);
					BIO_puts(bp," - ");
					BN_print(bp,c);
					BIO_puts(bp,"\n");
d1156 2
a1157 2
			if(!BN_is_zero(e)) {
				fprintf(stderr,"GF(2^m) modulo test failed!\n");
d1174 1
a1174 1
test_gf2m_mod_mul(BIO *bp,BN_CTX *ctx)
d1176 1
a1176 1
	BIGNUM *a,*b[2],*c,*d,*e,*f,*g,*h;
d1178 2
a1179 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
d1181 9
a1189 9
	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	f=BN_new();
	g=BN_new();
	h=BN_new();
d1194 1
a1194 1
	for (i=0; i<num0; i++) {
d1198 1
a1198 1
		for (j=0; j < 2; j++) {
d1203 8
a1210 8
					BN_print(bp,a);
					BIO_puts(bp," * ");
					BN_print(bp,c);
					BIO_puts(bp," % ");
					BN_print(bp,b[j]);
					BIO_puts(bp," - ");
					BN_print(bp,e);
					BIO_puts(bp,"\n");
d1220 2
a1221 2
			if(!BN_is_zero(f)) {
				fprintf(stderr,"GF(2^m) modular multiplication test failed!\n");
d1241 1
a1241 1
test_gf2m_mod_sqr(BIO *bp,BN_CTX *ctx)
d1243 1
a1243 1
	BIGNUM *a,*b[2],*c,*d;
d1245 2
a1246 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
d1248 5
a1252 5
	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
d1257 1
a1257 1
	for (i=0; i<num0; i++) {
d1259 1
a1259 1
		for (j=0; j < 2; j++) {
d1266 3
a1268 3
					BN_print(bp,a);
					BIO_puts(bp," ^ 2 % ");
					BN_print(bp,b[j]);
d1270 4
a1273 4
					BN_print(bp,c);
					BIO_puts(bp,"; a * a = ");
					BN_print(bp,d);
					BIO_puts(bp,"\n");
d1279 2
a1280 2
			if(!BN_is_zero(d)) {
				fprintf(stderr,"GF(2^m) modular squaring test failed!\n");
d1296 1
a1296 1
test_gf2m_mod_inv(BIO *bp,BN_CTX *ctx)
d1298 1
a1298 1
	BIGNUM *a,*b[2],*c,*d;
d1300 2
a1301 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
d1303 5
a1307 5
	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
d1312 3
a1314 3
	for (i=0; i<num0; i++) {
		BN_bntest_rand(a, 512, 0, 0); 
		for (j=0; j < 2; j++) {
d1320 1
a1320 1
					BN_print(bp,a);
d1322 4
a1325 4
					BN_print(bp,c);
					BIO_puts(bp," - 1 % ");
					BN_print(bp,b[j]);
					BIO_puts(bp,"\n");
d1330 2
a1331 2
			if(!BN_is_one(d)) {
				fprintf(stderr,"GF(2^m) modular inversion test failed!\n");
d1347 1
a1347 1
test_gf2m_mod_div(BIO *bp,BN_CTX *ctx)
d1349 1
a1349 1
	BIGNUM *a,*b[2],*c,*d,*e,*f;
d1351 2
a1352 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
d1354 7
a1360 7
	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	f=BN_new();
d1365 2
a1366 2
	for (i=0; i<num0; i++) {
		BN_bntest_rand(a, 512, 0, 0); 
d1368 1
a1368 1
		for (j=0; j < 2; j++) {
d1375 1
a1375 1
					BN_print(bp,a);
d1377 3
a1379 3
					BN_print(bp,c);
					BIO_puts(bp," * ");
					BN_print(bp,d);
d1381 2
a1382 2
					BN_print(bp,b[j]);
					BIO_puts(bp,"\n");
d1387 2
a1388 2
			if(!BN_is_one(f)) {
				fprintf(stderr,"GF(2^m) modular division test failed!\n");
d1406 1
a1406 1
test_gf2m_mod_exp(BIO *bp,BN_CTX *ctx)
d1408 1
a1408 1
	BIGNUM *a,*b[2],*c,*d,*e,*f;
d1410 2
a1411 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
d1413 7
a1419 7
	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	f=BN_new();
d1424 1
a1424 1
	for (i=0; i<num0; i++) {
d1428 1
a1428 1
		for (j=0; j < 2; j++) {
d1437 1
a1437 1
					BN_print(bp,a);
d1439 3
a1441 3
					BN_print(bp,c);
					BIO_puts(bp," + ");
					BN_print(bp,d);
d1443 1
a1443 1
					BN_print(bp,e);
d1445 1
a1445 1
					BN_print(bp,f);
d1447 2
a1448 2
					BN_print(bp,b[j]);
					BIO_puts(bp,"\n");
d1454 2
a1455 2
			if(!BN_is_zero(f)) {
				fprintf(stderr,"GF(2^m) modular exponentiation test failed!\n");
d1473 1
a1473 1
test_gf2m_mod_sqrt(BIO *bp,BN_CTX *ctx)
d1475 1
a1475 1
	BIGNUM *a,*b[2],*c,*d,*e,*f;
d1477 2
a1478 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
d1480 7
a1486 7
	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	f=BN_new();
d1491 1
a1491 1
	for (i=0; i<num0; i++) {
d1493 1
a1493 1
		for (j=0; j < 2; j++) {
d1500 1
a1500 1
					BN_print(bp,d);
d1502 2
a1503 2
					BN_print(bp,a);
					BIO_puts(bp,"\n");
d1509 2
a1510 2
			if(!BN_is_zero(f)) {
				fprintf(stderr,"GF(2^m) modular square root test failed!\n");
d1528 1
a1528 1
test_gf2m_mod_solve_quad(BIO *bp,BN_CTX *ctx)
d1530 1
a1530 1
	BIGNUM *a,*b[2],*c,*d,*e;
d1532 2
a1533 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
d1535 6
a1540 6
	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
d1545 1
a1545 1
	for (i=0; i<num0; i++) {
d1547 1
a1547 1
		for (j=0; j < 2; j++) {
d1557 1
a1557 1
						BN_print(bp,c);
d1559 1
a1559 1
						BN_print(bp,a);
d1561 1
a1561 1
						BN_print(bp,b[j]);
d1568 2
a1569 2
				if(!BN_is_zero(e)) {
					fprintf(stderr,"GF(2^m) modular solve quadratic test failed!\n");
d1577 1
a1577 1
						BN_print(bp,a);
d1579 1
a1579 1
						BN_print(bp,b[j]);
d1587 3
a1589 3
	if (s == 0) {	
		fprintf(stderr,"All %i tests of GF(2^m) modular solve quadratic resulted in no roots;\n", num0);
		fprintf(stderr,"this is very unlikely and probably indicates an error.\n");
d1609 8
a1616 4
	if (p == 0) c='.';
	if (p == 1) c='+';
	if (p == 2) c='*';
	if (p == 3) c='\n';
d1626 1
a1626 1
	BIGNUM *a,*b,*r,*t;
d1635 2
a1636 1
	if (a == NULL || b == NULL || r == NULL || t == NULL) goto err;
d1639 1
a1639 1
	
d1649 2
a1650 1
	if (!BN_generate_prime_ex(b, 512, 0, NULL, NULL, &cb)) goto err;
d1655 2
a1656 1
		if (!BN_bntest_rand(a, 512, 0, 0)) goto err;
d1660 2
a1661 1
		if (!BN_copy(t, b)) goto err;
d1663 4
a1666 2
		if (!BN_sub_word(t, 1)) goto err;
		if (!BN_rshift1(t, t)) goto err;
d1668 5
a1672 4
		b->neg=0;
		
		if (!BN_mod_exp_recp(r, a, t, b, ctx)) goto err;
		b->neg=1;
d1679 2
a1680 1
			if (!BN_add_word(r, 1)) goto err;
d1687 1
a1687 1
		
d1689 2
a1690 1
		if (kronecker < -1) goto err;
d1694 1
a1694 1
		
d1712 8
a1719 4
	if (a != NULL) BN_free(a);
	if (b != NULL) BN_free(b);
	if (r != NULL) BN_free(r);
	if (t != NULL) BN_free(t);
d1727 1
a1727 1
	BIGNUM *a,*p,*r;
d1734 2
a1735 1
	if (a == NULL || p == NULL || r == NULL) goto err;
d1742 3
a1744 2
			
			if (!BN_set_word(p, primes[i])) goto err;
d1746 7
a1752 4
			if (!BN_set_word(a, 32)) goto err;
			if (!BN_set_word(r, 2*i + 1)) goto err;
		
			if (!BN_generate_prime_ex(p, 256, 0, a, r, &cb)) goto err;
d1760 14
a1773 7
			if (!BN_bntest_rand(r, 256, 0, 3)) goto err;
			if (!BN_nnmod(r, r, p, ctx)) goto err;
			if (!BN_mod_sqr(r, r, p, ctx)) goto err;
			if (!BN_bntest_rand(a, 256, 0, 3)) goto err;
			if (!BN_nnmod(a, a, p, ctx)) goto err;
			if (!BN_mod_sqr(a, a, p, ctx)) goto err;
			if (!BN_mul(a, a, r, ctx)) goto err;
d1775 2
a1776 1
				if (!BN_sub(a, a, p)) goto err;
d1778 4
a1781 2
			if (!BN_mod_sqrt(r, a, p, ctx)) goto err;
			if (!BN_mod_sqr(r, r, p, ctx)) goto err;
d1783 2
a1784 1
			if (!BN_nnmod(a, a, p, ctx)) goto err;
d1800 1
a1800 1
		
d1806 6
a1811 3
	if (a != NULL) BN_free(a);
	if (p != NULL) BN_free(p);
	if (r != NULL) BN_free(r);
d1816 1
a1816 1
test_lshift(BIO *bp,BN_CTX *ctx,BIGNUM *a_)
d1818 1
a1818 1
	BIGNUM *a,*b,*c,*d;
d1822 3
a1824 3
	b=BN_new();
	c=BN_new();
	d=BN_new();
d1827 2
a1828 2
	if(a_)
	    a=a_;
d1830 1
a1830 1
	    a=BN_new();
d1832 1
a1832 1
	    a->neg=rand_neg();
d1834 3
a1836 3
	for (i=0; i<num0; i++) {
		BN_lshift(b,a,i+1);
		BN_add(c,c,c);
d1839 23
a1861 23
				BN_print(bp,a);
				BIO_puts(bp," * ");
				BN_print(bp,c);
				BIO_puts(bp," - ");
			}
			BN_print(bp,b);
			BIO_puts(bp,"\n");
		}
		BN_mul(d,a,c,ctx);
		BN_sub(d,d,b);
		if(!BN_is_zero(d)) {
		    fprintf(stderr,"Left shift test failed!\n");
		    fprintf(stderr,"a=");
		    BN_print_fp(stderr,a);
		    fprintf(stderr,"\nb=");
		    BN_print_fp(stderr,b);
		    fprintf(stderr,"\nc=");
		    BN_print_fp(stderr,c);
		    fprintf(stderr,"\nd=");
		    BN_print_fp(stderr,d);
		    fprintf(stderr,"\n");
		    rc = 0;
		    break;
d1868 1
a1868 1
	return(rc);
d1874 1
a1874 1
	BIGNUM *a,*b,*c;
d1878 3
a1880 3
	a=BN_new();
	b=BN_new();
	c=BN_new();
d1883 3
a1885 3
	a->neg=rand_neg();
	for (i=0; i<num0; i++) {
		BN_lshift1(b,a);
d1888 13
a1900 13
				BN_print(bp,a);
				BIO_puts(bp," * 2");
				BIO_puts(bp," - ");
			}
			BN_print(bp,b);
			BIO_puts(bp,"\n");
		}
		BN_add(c,a,a);
		BN_sub(a,b,c);
		if(!BN_is_zero(a)) {
		    fprintf(stderr,"Left shift one test failed!\n");
		    rc = 0;
		    break;
d1902 2
a1903 2
		
		BN_copy(a,b);
d1908 1
a1908 1
	return(rc);
d1912 1
a1912 1
test_rshift(BIO *bp,BN_CTX *ctx)
d1914 1
a1914 1
	BIGNUM *a,*b,*c,*d,*e;
d1918 5
a1922 5
	a=BN_new();
	b=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
d1926 4
a1929 4
	a->neg=rand_neg();
	for (i=0; i<num0; i++) {
		BN_rshift(b,a,i+1);
		BN_add(c,c,c);
d1932 14
a1945 14
				BN_print(bp,a);
				BIO_puts(bp," / ");
				BN_print(bp,c);
				BIO_puts(bp," - ");
			}
			BN_print(bp,b);
			BIO_puts(bp,"\n");
		}
		BN_div(d,e,a,c,ctx);
		BN_sub(d,d,b);
		if(!BN_is_zero(d)) {
		    fprintf(stderr,"Right shift test failed!\n");
		    rc = 0;
		    break;
d1953 1
a1953 1
	return(rc);
d1959 1
a1959 1
	BIGNUM *a,*b,*c;
d1963 3
a1965 3
	a=BN_new();
	b=BN_new();
	c=BN_new();
d1968 3
a1970 3
	a->neg=rand_neg();
	for (i=0; i<num0; i++) {
		BN_rshift1(b,a);
d1973 13
a1985 13
				BN_print(bp,a);
				BIO_puts(bp," / 2");
				BIO_puts(bp," - ");
			}
			BN_print(bp,b);
			BIO_puts(bp,"\n");
		}
		BN_sub(c,a,b);
		BN_sub(c,c,b);
		if(!BN_is_zero(c) && !BN_abs_is_word(c, 1)) {
		    fprintf(stderr,"Right shift one test failed!\n");
		    rc = 0;
		    break;
d1987 1
a1987 1
		BN_copy(a,b);
d1992 1
a1992 1
	return(rc);
d1998 2
a1999 2
	static unsigned int neg=0;
	static int sign[8]={0,0,0,1,1,0,1,1};
d2001 1
a2001 1
	return(sign[(neg++)%8]);
@


1.3
log
@None of these need <openssl/rand.h>
@
text
@d123 1
a123 1
static unsigned char lst[]="\xC6\x4F\x43\x04\x2A\xEA\xCA\x6E\x58\x36\x80\x5B\xE8\xC9"
d126 3
a128 2
static void message(BIO *out, char *m)
	{
d133 1
a133 1
	}
d135 3
a137 2
int main(int argc, char *argv[])
	{
d146 1
a146 2
	while (argc >= 1)
		{
d149 1
a149 2
		else if (strcmp(*argv,"-out") == 0)
			{
d152 1
a152 1
			}
d155 1
a155 1
		}
d163 1
a163 2
	if (outfile == NULL)
		{
d165 2
a166 5
		}
	else
		{
		if (!BIO_write_filename(out,outfile))
			{
a168 1
			}
d170 1
d310 1
a310 1
	}
d312 3
a314 2
int test_add(BIO *bp)
	{
d317 1
d324 1
a324 2
	for (i=0; i<num0; i++)
		{
d329 2
a330 4
		if (bp != NULL)
			{
			if (!results)
				{
d335 1
a335 1
				}
d338 1
a338 1
			}
d343 1
a343 2
		if(!BN_is_zero(&c))
		    {
d345 2
a346 2
		    return 0;
		    }
d348 1
d352 2
a353 2
	return(1);
	}
d355 3
a357 2
int test_sub(BIO *bp)
	{
d360 1
d366 2
a367 4
	for (i=0; i<num0+num1; i++)
		{
		if (i < num1)
			{
d370 4
a373 1
			if (BN_set_bit(&a,i)==0) return(0);
d375 1
a375 3
			}
		else
			{
d379 1
a379 1
			}
d381 2
a382 4
		if (bp != NULL)
			{
			if (!results)
				{
d387 1
a387 1
				}
d390 1
a390 1
			}
d393 1
a393 2
		if(!BN_is_zero(&c))
		    {
d395 2
a396 2
		    return 0;
		    }
d398 1
d402 2
a403 2
	return(1);
	}
d405 3
a407 2
int test_div(BIO *bp, BN_CTX *ctx)
	{
d410 1
d418 2
a419 4
	for (i=0; i<num0+num1; i++)
		{
		if (i < num1)
			{
d424 1
a424 2
			}
		else
d429 2
a430 4
		if (bp != NULL)
			{
			if (!results)
				{
d435 1
a435 1
				}
d439 1
a439 2
			if (!results)
				{
d444 1
a444 1
				}
d447 1
a447 1
			}
d451 1
a451 2
		if(!BN_is_zero(&d))
		    {
d453 2
a454 2
		    return 0;
		    }
d456 1
d462 2
a463 2
	return(1);
	}
d465 3
a467 2
static void print_word(BIO *bp,BN_ULONG w)
	{
d469 2
a470 4
	if (sizeof(w) > sizeof(unsigned long))
		{
		unsigned long	h=(unsigned long)(w>>32),
				l=(unsigned long)(w);
d472 4
a475 2
		if (h)	BIO_printf(bp,"%lX%08lX",h,l);
		else	BIO_printf(bp,"%lX",l);
d477 1
a477 1
		}
d480 1
a480 1
	}
d482 3
a484 2
int test_div_word(BIO *bp)
	{
d488 1
d493 1
a493 2
	for (i=0; i<num0; i++)
		{
d503 2
a504 4
		if (bp != NULL)
			{
			if (!results)
				{
d509 1
a509 1
				}
d513 1
a513 2
			if (!results)
				{
d518 1
a518 1
				}
d521 1
a521 1
			}
d525 1
a525 2
		if(!BN_is_zero(&b))
		    {
d527 2
a528 2
		    return 0;
		    }
d530 1
d533 2
a534 2
	return(1);
	}
d536 3
a538 2
int test_div_recp(BIO *bp, BN_CTX *ctx)
	{
d542 1
d551 2
a552 4
	for (i=0; i<num0+num1; i++)
		{
		if (i < num1)
			{
d557 1
a557 2
			}
		else
d563 2
a564 4
		if (bp != NULL)
			{
			if (!results)
				{
d569 1
a569 1
				}
d573 1
a573 2
			if (!results)
				{
d578 1
a578 1
				}
d581 1
a581 1
			}
d585 1
a585 2
		if(!BN_is_zero(&d))
		    {
d592 2
a593 2
		    return 0;
		    }
d595 1
d602 2
a603 2
	return(1);
	}
d605 3
a607 2
int test_mul(BIO *bp)
	{
d610 1
d622 2
a623 4
	for (i=0; i<num0+num1; i++)
		{
		if (i <= num1)
			{
d626 1
a626 2
			}
		else
d631 2
a632 4
		if (bp != NULL)
			{
			if (!results)
				{
d637 1
a637 1
				}
d640 1
a640 1
			}
d643 1
a643 2
		if(!BN_is_zero(&d) || !BN_is_zero(&e))
		    {
d645 2
a646 2
		    return 0;
		    }
d648 1
d655 2
a656 2
	return(1);
	}
d658 3
a660 2
int test_sqr(BIO *bp, BN_CTX *ctx)
	{
d663 1
d670 1
a670 2
	for (i=0; i<num0; i++)
		{
d674 2
a675 4
		if (bp != NULL)
			{
			if (!results)
				{
d680 1
a680 1
				}
d683 1
a683 1
			}
d686 1
a686 2
		if(!BN_is_zero(&d) || !BN_is_zero(&e))
		    {
d688 2
a689 2
		    return 0;
		    }
d691 1
d696 2
a697 2
	return(1);
	}
d699 3
a701 2
int test_mont(BIO *bp, BN_CTX *ctx)
	{
d705 1
d708 4
a719 4
	mont=BN_MONT_CTX_new();
	if (mont == NULL)
		return 0;

d722 1
a722 2
	for (i=0; i<num2; i++)
		{
d738 2
a739 4
		if (bp != NULL)
			{
			if (!results)
				{
d746 1
a746 1
				}
d749 1
a749 1
			}
d752 1
a752 2
		if(!BN_is_zero(&d))
		    {
d754 2
a755 2
		    return 0;
		    }
d757 1
d766 2
a767 2
	return(1);
	}
d769 3
a771 2
int test_mod(BIO *bp, BN_CTX *ctx)
	{
d774 1
d783 1
a783 2
	for (i=0; i<num0; i++)
		{
d788 2
a789 4
		if (bp != NULL)
			{
			if (!results)
				{
d794 1
a794 1
				}
d797 1
a797 1
			}
d800 1
a800 2
		if(!BN_is_zero(e))
		    {
d802 2
a803 2
		    return 0;
		    }
d805 1
d811 2
a812 2
	return(1);
	}
d814 3
a816 2
int test_mod_mul(BIO *bp, BN_CTX *ctx)
	{
d819 1
d828 13
a840 15
	BN_bntest_rand(c,1024,0,0); /**/
	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a,475+i*10,0,0); /**/
		BN_bntest_rand(b,425+i*11,0,0); /**/
		a->neg=rand_neg();
		b->neg=rand_neg();
		if (!BN_mod_mul(e,a,b,c,ctx))
			{
			unsigned long l;

			while ((l=ERR_get_error()))
				fprintf(stderr,"ERROR:%s\n",
					ERR_error_string(l,NULL));
			exit(1);
d842 6
a847 17
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," * ");
				BN_print(bp,b);
				BIO_puts(bp," % ");
				BN_print(bp,c);
				if ((a->neg ^ b->neg) && !BN_is_zero(e))
					{
					/* If  (a*b) % c  is negative,  c  must be added
					 * in order to obtain the normalized remainder
					 * (new with OpenSSL 0.9.7, previous versions of
					 * BN_mod_mul could generate negative results)
					 */
					BIO_puts(bp," + ");
d849 8
d858 1
a858 1
				BIO_puts(bp," - ");
d860 11
a870 2
			BN_print(bp,e);
			BIO_puts(bp,"\n");
a871 9
		BN_mul(d,a,b,ctx);
		BN_sub(d,d,e);
		BN_div(a,b,d,c,ctx);
		if(!BN_is_zero(b))
		    {
		    fprintf(stderr,"Modulo multiply test failed!\n");
		    ERR_print_errors_fp(stderr);
		    return 0;
		    }
d874 1
d880 2
a881 2
	return(1);
	}
d883 3
a885 2
int test_mod_exp(BIO *bp, BN_CTX *ctx)
	{
d888 1
d897 1
a897 2
	for (i=0; i<num2; i++)
		{
d901 4
a904 2
		if (!BN_mod_exp(d,a,b,c,ctx))
			return(0);
d906 2
a907 4
		if (bp != NULL)
			{
			if (!results)
				{
d914 1
a914 1
				}
d917 1
a917 1
			}
d921 1
a921 2
		if(!BN_is_zero(b))
		    {
d923 2
a924 2
		    return 0;
		    }
d926 1
d932 2
a933 2
	return(1);
	}
d935 3
a937 2
int test_mod_exp_mont_consttime(BIO *bp, BN_CTX *ctx)
	{
d940 1
d949 1
a949 2
	for (i=0; i<num2; i++)
		{
d953 4
a956 2
		if (!BN_mod_exp_mont_consttime(d,a,b,c,ctx,NULL))
			return(00);
d958 2
a959 4
		if (bp != NULL)
			{
			if (!results)
				{
d966 1
a966 1
				}
d969 1
a969 1
			}
d973 1
a973 2
		if(!BN_is_zero(b))
		    {
d975 2
a976 2
		    return 0;
		    }
d978 1
d984 2
a985 2
	return(1);
	}
d987 3
a989 2
int test_exp(BIO *bp, BN_CTX *ctx)
	{
d992 1
d1001 1
a1001 2
	for (i=0; i<num2; i++)
		{
d1005 4
a1008 2
		if (BN_exp(d,a,b,ctx) <= 0)
			return(0);
d1010 2
a1011 4
		if (bp != NULL)
			{
			if (!results)
				{
d1016 1
a1016 1
				}
d1019 1
a1019 1
			}
d1024 1
a1024 2
		if(!BN_is_zero(e))
		    {
d1026 2
a1027 2
		    return 0;
		    }
d1029 1
d1035 3
a1037 2
	return(1);
	}
d1039 3
a1041 2
int test_gf2m_add(BIO *bp)
	{
d1049 1
a1049 2
	for (i=0; i<num0; i++)
		{
d1056 2
a1057 4
		if (bp != NULL)
			{
			if (!results)
				{
d1062 1
a1062 1
				}
d1065 1
a1065 1
			}
d1068 1
a1068 2
		if((BN_is_odd(&a) && BN_is_odd(&c)) || (!BN_is_odd(&a) && !BN_is_odd(&c)))
			{
d1071 1
a1071 1
			}
d1074 1
a1074 2
		if(!BN_is_zero(&c))
		    {
a1076 1
		    }
d1078 1
d1080 1
a1080 1
  err:
d1085 1
a1085 1
	}
d1087 3
a1089 2
int test_gf2m_mod(BIO *bp)
	{
d1105 1
a1105 2
	for (i=0; i<num0; i++)
		{
d1107 1
a1107 2
		for (j=0; j < 2; j++)
			{
d1110 2
a1111 4
			if (bp != NULL)
				{
				if (!results)
					{
a1117 1
					}
d1119 1
d1124 1
a1124 2
			if(!BN_is_zero(e))
				{
a1126 1
				}
d1129 1
d1131 1
a1131 1
  err:
d1139 1
a1139 1
	}
d1141 3
a1143 2
int test_gf2m_mod_mul(BIO *bp,BN_CTX *ctx)
	{
d1162 1
a1162 2
	for (i=0; i<num0; i++)
		{
d1166 1
a1166 2
		for (j=0; j < 2; j++)
			{
d1169 2
a1170 4
			if (bp != NULL)
				{
				if (!results)
					{
a1178 1
					}
d1180 1
d1188 1
a1188 2
			if(!BN_is_zero(f))
				{
a1190 1
				}
d1193 1
d1195 1
a1195 1
  err:
d1206 1
a1206 1
	}
d1208 3
a1210 2
int test_gf2m_mod_sqr(BIO *bp,BN_CTX *ctx)
	{
d1225 1
a1225 2
	for (i=0; i<num0; i++)
		{
d1227 1
a1227 2
		for (j=0; j < 2; j++)
			{
d1232 2
a1233 4
			if (bp != NULL)
				{
				if (!results)
					{
a1241 1
					}
d1243 1
d1247 1
a1247 2
			if(!BN_is_zero(d))
				{
a1249 1
				}
d1252 1
d1254 1
a1254 1
  err:
d1261 1
a1261 1
	}
d1263 3
a1265 2
int test_gf2m_mod_inv(BIO *bp,BN_CTX *ctx)
	{
d1280 1
a1280 2
	for (i=0; i<num0; i++)
		{
d1282 1
a1282 2
		for (j=0; j < 2; j++)
			{
d1286 2
a1287 4
			if (bp != NULL)
				{
				if (!results)
					{
a1293 1
					}
d1295 1
d1298 1
a1298 2
			if(!BN_is_one(d))
				{
a1300 1
				}
d1303 1
d1305 1
a1305 1
  err:
d1312 1
a1312 1
	}
d1314 3
a1316 2
int test_gf2m_mod_div(BIO *bp,BN_CTX *ctx)
	{
d1333 1
a1333 2
	for (i=0; i<num0; i++)
		{
d1336 1
a1336 2
		for (j=0; j < 2; j++)
			{
d1341 2
a1342 4
			if (bp != NULL)
				{
				if (!results)
					{
a1350 1
					}
d1352 1
d1355 1
a1355 2
			if(!BN_is_one(f))
				{
a1357 1
				}
d1360 1
d1362 1
a1362 1
  err:
d1371 1
a1371 1
	}
d1373 3
a1375 2
int test_gf2m_mod_exp(BIO *bp,BN_CTX *ctx)
	{
d1392 1
a1392 2
	for (i=0; i<num0; i++)
		{
d1396 1
a1396 2
		for (j=0; j < 2; j++)
			{
d1403 2
a1404 4
			if (bp != NULL)
				{
				if (!results)
					{
a1416 1
					}
d1418 1
d1422 1
a1422 2
			if(!BN_is_zero(f))
				{
a1424 1
				}
d1427 1
d1429 1
a1429 1
  err:
d1438 1
a1438 1
	}
d1440 3
a1442 2
int test_gf2m_mod_sqrt(BIO *bp,BN_CTX *ctx)
	{
d1459 1
a1459 2
	for (i=0; i<num0; i++)
		{
d1461 1
a1461 2
		for (j=0; j < 2; j++)
			{
d1466 2
a1467 4
			if (bp != NULL)
				{
				if (!results)
					{
a1471 1
					}
d1473 1
d1477 1
a1477 2
			if(!BN_is_zero(f))
				{
a1479 1
				}
d1482 1
d1484 1
a1484 1
  err:
d1493 1
a1493 1
	}
d1495 3
a1497 2
int test_gf2m_mod_solve_quad(BIO *bp,BN_CTX *ctx)
	{
d1513 1
a1513 2
	for (i=0; i<num0; i++)
		{
d1515 1
a1515 2
		for (j=0; j < 2; j++)
			{
d1517 1
a1517 2
			if (t)
				{
d1523 2
a1524 4
				if (bp != NULL)
					{
					if (!results)
						{
a1530 1
						}
d1532 1
d1536 1
a1536 2
				if(!BN_is_zero(e))
					{
a1538 2
					}

d1540 1
a1540 2
			else 
				{
d1542 2
a1543 4
				if (bp != NULL)
					{
					if (!results)
						{
a1548 1
						}
d1550 1
a1551 1
				}
d1554 2
a1555 2
	if (s == 0)
		{	
d1559 1
a1559 1
		}
d1561 1
a1561 1
  err:
d1569 1
a1569 1
	}
d1571 4
a1574 2
static int genprime_cb(int p, int n, BN_GENCB *arg)
	{
d1584 1
a1584 1
	}
d1586 3
a1588 2
int test_kron(BIO *bp, BN_CTX *ctx)
	{
d1616 1
a1616 2
	for (i = 0; i < num0; i++)
		{
d1635 1
a1635 2
		else
			{
d1637 1
a1637 2
			if (0 != BN_ucmp(r, b))
				{
d1640 1
a1640 1
				}
d1642 1
a1642 1
			}
d1650 1
a1650 2
		if (legendre != kronecker)
			{
d1657 1
a1657 1
			}
d1661 1
a1661 1
		}
d1666 1
a1666 1
 err:
d1672 1
a1672 1
	}
d1674 3
a1676 2
int test_sqrt(BIO *bp, BN_CTX *ctx)
	{
d1689 2
a1690 4
	for (i = 0; i < 16; i++)
		{
		if (i < 8)
			{
d1694 1
a1694 3
			}
		else
			{
d1700 1
a1700 1
			}
d1703 1
a1703 2
		for (j = 0; j < num2; j++)
			{
d1721 1
a1721 2
			if (BN_cmp(a, r) != 0)
				{
d1730 1
a1730 1
				}
d1734 1
a1734 1
			}
d1738 1
a1738 1
		}
d1740 1
a1740 1
 err:
d1745 1
a1745 1
	}
d1747 3
a1749 2
int test_lshift(BIO *bp,BN_CTX *ctx,BIGNUM *a_)
	{
d1752 1
d1761 1
a1761 2
	else
	    {
d1765 2
a1766 3
	    }
	for (i=0; i<num0; i++)
		{
d1769 2
a1770 4
		if (bp != NULL)
			{
			if (!results)
				{
d1775 1
a1775 1
				}
d1778 1
a1778 1
			}
d1781 1
a1781 2
		if(!BN_is_zero(d))
		    {
d1792 2
a1793 2
		    return 0;
		    }
d1795 1
d1800 2
a1801 2
	return(1);
	}
d1803 3
a1805 2
int test_lshift1(BIO *bp)
	{
d1808 1
d1816 1
a1816 2
	for (i=0; i<num0; i++)
		{
d1818 2
a1819 4
		if (bp != NULL)
			{
			if (!results)
				{
d1823 1
a1823 1
				}
d1826 1
a1826 1
			}
d1829 1
a1829 2
		if(!BN_is_zero(a))
		    {
d1831 3
a1833 2
		    return 0;
		    }
d1836 1
a1836 1
		}
d1840 2
a1841 2
	return(1);
	}
d1843 3
a1845 2
int test_rshift(BIO *bp,BN_CTX *ctx)
	{
d1848 1
d1859 1
a1859 2
	for (i=0; i<num0; i++)
		{
d1862 2
a1863 4
		if (bp != NULL)
			{
			if (!results)
				{
d1868 1
a1868 1
				}
d1871 1
a1871 1
			}
d1874 1
a1874 2
		if(!BN_is_zero(d))
		    {
d1876 2
a1877 2
		    return 0;
		    }
d1879 1
d1885 2
a1886 2
	return(1);
	}
d1888 3
a1890 2
int test_rshift1(BIO *bp)
	{
d1893 1
d1901 1
a1901 2
	for (i=0; i<num0; i++)
		{
d1903 2
a1904 4
		if (bp != NULL)
			{
			if (!results)
				{
d1908 1
a1908 1
				}
d1911 1
a1911 1
			}
d1914 1
a1914 2
		if(!BN_is_zero(c) && !BN_abs_is_word(c, 1))
		    {
d1916 3
a1918 2
		    return 0;
		    }
d1920 1
a1920 1
		}
d1924 2
a1925 2
	return(1);
	}
d1927 3
a1929 2
int rand_neg(void)
	{
d1934 1
a1934 1
	}
@


1.2
log
@Another regress test for OpenSSL PR #3397 (Joyent 7704), from agl via OpenSSL
RT.
@
text
@a83 1
#include <openssl/rand.h>
@


1.1
log
@Move the crypto/bn regression test one directory deeper in preparation for
it getting siblings.
@
text
@d120 1
d260 6
d2008 50
@

