head	1.5;
access;
symbols
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	pthread_regression:1.1.1.1
	fgsch:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2003.01.19.23.08.32;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2002.02.17.19.42.27;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.16.21.27.32;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.20.15.33.17;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.15.14.37.10;	author fgsch;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.08.15.14.37.10;	author fgsch;	state Exp;
branches;
next	;


desc
@@


1.5
log
@repository move to libpthread
@
text
@/*	$OpenBSD: test.h,v 1.4 2002/02/17 19:42:27 millert Exp $	*/

#ifndef _h_test_
#define _h_test_

#include <stdio.h>
#include <signal.h>
#include <errno.h>
#include <string.h>
#include <stdarg.h>

int	_thread_sys_write(int, const char*, size_t);
__dead void _thread_sys__exit(int) __attribute__((__noreturn__));

static __dead void __vpanic(const char *, const char *, const char *, 
	int, const char *, va_list) __attribute__((__noreturn__));
static __dead void __panic(const char *, const char *, const char *,
	int, const char *, ...) __attribute__((__noreturn__));

#if defined(__OpenBSD__) || defined(__FreeBSD__)
#include <pthread.h>
#include <pthread_np.h>
void	_thread_dump_info(void);
#define SET_NAME(x)	pthread_set_name_np(pthread_self(), x)
#define DUMP_INFO()	_thread_dump_info()
#else
#define SET_NAME(x)	/* nada */
#define DUMP_INFO()	/* nada */
#endif

static void
__vpanic(type, errstr, filenm, lineno, fmt, ap)
	const char *type; 
	const char *errstr;
	const char *filenm;
	int lineno; 
	const char *fmt; 
	va_list ap;
{
	char buf[1024];

	/* "<type> at <filenm>:<lineno>: <fmt ap...>:<errstr>" */
	snprintf(buf, sizeof buf, "%s at %s:%d\n", type, filenm, lineno);
	_thread_sys_write(2, buf, strlen(buf));
	vsnprintf(buf, sizeof buf, fmt, ap);
	if (errstr != NULL) {
		strlcat(buf, ": ", sizeof buf);
		strlcat(buf, errstr, sizeof buf);
	}
	strlcat(buf, "\n", sizeof buf);
	_thread_sys_write(2, buf, strlen(buf));

	DUMP_INFO();
	_thread_sys__exit(1);

	_thread_sys_write(2, "[locking]\n", 10);
	while(1);
}

static void
__panic(type, errstr, filenm, lineno, fmt)
	const char *type;
	const char *errstr;
	const char *filenm;
	int lineno; 
	const char *fmt;
{
	va_list ap;

	va_start(ap, fmt);
	__vpanic(type, errstr, filenm, lineno, fmt, ap);
	va_end(ap);
}

#define DIE(e, m, args...) \
	__panic("died", strerror(e), __FILE__, __LINE__, m , ## args)

#define PANIC(m, args...)  \
	__panic("panic", NULL, __FILE__, __LINE__, m, ## args)

#define ASSERT(x) do { \
	if (!(x)) \
		__panic("assert failed", NULL, __FILE__, __LINE__, "%s", #x); \
} while(0)

#define ASSERTe(x,rhs) do { \
	int _x; \
	_x = (x); \
	if (!(_x rhs)) { \
	    if (_x > 0) \
		__panic("assert failed", strerror(_x), __FILE__, __LINE__,  \
		    "%s %s", #x, #rhs); \
	    else \
		__panic("assert failed", NULL, __FILE__, __LINE__, \
		    "%s [=%d] %s", #x, _x, #rhs); \
	} \
} while(0)

#define _T(x) __builtin_classify_type(x)

#define _CHECK(x, rhs, efn) do { \
	typeof(x) _x; \
	_x = (x); \
	if (!(_x rhs)) \
		__panic("check failed", efn, __FILE__, __LINE__, \
		   ((_T(0) == _T(_x)   )? "failed check %s (=%d) %s " : \
		    (_T("") == _T(_x)  )? "failed check %s (=%s) %s " : \
		    (_T('x') == _T(_x) )? "failed check %s (=%c) %s " : \
		    (_T(0L) == _T(_x)  )? "failed check %s (=%ld) %s " : "?") \
		    , #x, _x, #rhs); \
} while(0)

#define CHECKr(x) _CHECK(x, == 0, strerror(_x))
#define CHECKe(x) _CHECK(x, != -1, strerror(errno))
#define CHECKn(x) _CHECK(x, != 0, strerror(errno))
#define CHECKhn(x) _CHECK(x, != 0, hstrerror(h_errno))

#define SUCCEED 	exit(0)

#define OK		(0)
#define NOTOK		(-1)

#endif /* _h_test_ */
@


1.4
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: test.h,v 1.3 2002/02/16 21:27:32 millert Exp $	*/
@


1.3
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: test.h,v 1.2 2001/09/20 15:33:17 todd Exp $	*/
d15 4
a18 4
static __dead void __vpanic __P((const char *, const char *, const char *, 
	int, const char *, va_list)) __attribute__((__noreturn__));
static __dead void __panic __P((const char *, const char *, const char *,
	int, const char *, ...)) __attribute__((__noreturn__));
@


1.2
log
@comment extra tokens at end of #endif directive
@
text
@d1 1
a1 1
/*	$OpenBSD: test.h,v 1.1.1.1 2001/08/15 14:37:10 fgsch Exp $	*/
d12 2
a13 2
int	_thread_sys_write __P((int, const char*, size_t));
__dead void _thread_sys__exit __P((int)) __attribute__((__noreturn__));
d23 1
a23 1
void	_thread_dump_info __P((void));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d123 1
a123 1
#endif _h_test_
@


1.1.1.1
log
@Regression tests for libc_r (pthreads) library.
Thanks to pval@@ for resolving the license stuff.
@
text
@@
