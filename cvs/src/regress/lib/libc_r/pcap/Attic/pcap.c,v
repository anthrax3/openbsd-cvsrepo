head	1.5;
access;
symbols
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4;
locks; strict;
comment	@ * @;


1.5
date	2003.01.19.23.08.32;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2002.01.08.18.55.46;	author marc;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.11.20.20.53;	author marc;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.11.01.16.26;	author marc;	state dead;
branches;
next	1.1;

1.1
date	2001.11.10.02.44.48;	author marc;	state Exp;
branches;
next	;


desc
@@


1.5
log
@repository move to libpthread
@
text
@/*	$OpenBSD: pcap.c,v 1.4 2002/01/08 18:55:46 marc Exp $ */
/*
 *	Placed in the PUBLIC DOMAIN
 */

#include <pcap.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

#include "test.h"

#define LOOPBACK_IF	"lo0"
#define SNAPLEN		96
#define NO_PROMISC	0
#define	PKTCNT		3

volatile int packet_count = 0;
pthread_mutex_t dummy;
pthread_cond_t syncer;

void
packet_ignore(u_char *tag, const struct pcap_pkthdr *hdr, const u_char *data)
{
	packet_count += 1;
}

void *
pcap_thread(void *arg)
{
	char errbuf[PCAP_ERRBUF_SIZE];
	pcap_t *handle;

	SET_NAME("pcap_thread");
	CHECKr(pthread_mutex_lock(&dummy));
	handle = pcap_open_live(LOOPBACK_IF, SNAPLEN, NO_PROMISC, 0, errbuf);
	if (!handle)
		PANIC("You may need to run this test as UID 0 (root)");
	CHECKr(pthread_mutex_unlock(&dummy));
	CHECKr(pthread_cond_signal(&syncer));
	ASSERT(pcap_loop(handle, PKTCNT, packet_ignore, 0) != -1);
	return 0;
}

void *
ping_thread(void *arg)
{
	SET_NAME("ping_thread");
	CHECKr(pthread_mutex_lock(&dummy));
	ASSERT(system("ping -c 3 127.0.0.1") == 0);
	CHECKr(pthread_mutex_unlock(&dummy));
	CHECKr(pthread_cond_signal(&syncer));
	return 0;
}

int
main(int argc, char **argv)
{
	pthread_t pcap;
	pthread_t ping;

	CHECKr(pthread_mutex_init(&dummy, NULL));
	CHECKr(pthread_cond_init(&syncer, NULL));
	CHECKr(pthread_mutex_lock(&dummy));
	CHECKr(pthread_create(&pcap, NULL, pcap_thread, NULL));
	CHECKr(pthread_cond_wait(&syncer, &dummy));
	CHECKr(pthread_create(&ping, NULL, ping_thread, NULL));
	CHECKr(pthread_cond_wait(&syncer, &dummy));
	CHECKr(pthread_mutex_unlock(&dummy));
	ASSERT(packet_count == 3);
	SUCCEED;
}
@


1.4
log
@
Better version of pcap regression test.  Use mutex and conditions to
sync threads instead of timeouts.   Test passes with recent fgs@@
patches (not commited yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: pcap.c,v 1.3 2001/11/11 20:20:53 marc Exp $ */
@


1.3
log
@bring back test, this time in the public domain
@
text
@d1 1
a1 1
/*	$OpenBSD: pcap.c,v 1.1 2001/11/10 02:44:48 marc Exp $ */
d19 2
d35 1
d39 2
d49 1
d51 3
a53 3
	sleep(2);
	ASSERT(packet_count == 3);
	SUCCEED;
d62 3
d66 1
a66 1
	sleep(1);
d68 4
a71 3
	while (1)
		;
	PANIC("while");
@


1.2
log
@remove files that have a copyright theo doesn't like
@
text
@d3 2
a4 10
 *	Copyright (c) 2001 Marco S. Hyman
 *
 *	Permission to copy all or part of this material with or without
 *	modification for any purpose is granted provided that the above
 *	copyright notice and this paragraph are duplicated in all copies.
 *
 *	THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 *	IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 *	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */ 
@


1.1
log
@Add a pcap/pthread test as it was reported that using
libpcap blocked all threads.   That no longer seems to be a problem
as this test passes using the latest threads lib.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@

