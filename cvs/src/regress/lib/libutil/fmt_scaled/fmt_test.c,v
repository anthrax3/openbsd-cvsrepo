head	1.15;
access;
symbols
	OPENBSD_6_0:1.10.0.16
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.6
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.14
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.12
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.10
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.8
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.9.0.14
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.12
	OPENBSD_5_0:1.9.0.10
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.8
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.6
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.8.0.14
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.12
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.10
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.8
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.6
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.15
date	2017.03.16.02.42.31;	author dtucker;	state Exp;
branches;
next	1.14;
commitid	7Uv406G4uGapc1np;

1.14
date	2017.03.15.05.00.58;	author dtucker;	state Exp;
branches;
next	1.13;
commitid	5EFCQ3N98rbWbU4K;

1.13
date	2017.03.15.04.31.41;	author dtucker;	state Exp;
branches;
next	1.12;
commitid	Uy1lBUPbKN2hLrIJ;

1.12
date	2017.02.25.07.28.32;	author jsg;	state Exp;
branches;
next	1.11;
commitid	o45S2hSKbgrOD8tL;

1.11
date	2016.08.14.23.08.09;	author guenther;	state Exp;
branches;
next	1.10;
commitid	cgcXUqQniIpisTaC;

1.10
date	2012.11.12.14.10.48;	author halex;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.20.14.23.38;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.21.22.23.58;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.09.09.29.47;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.08.15.36.34;	author otto;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.16.10.57.33;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.16.05.51.19;	author david;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.28.06.52.15;	author otto;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.31.21.48.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.15.01.51.01;	author ian;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Enable tests for +/-LLONG_MAX and add tests for other boundary conditions.
ok millert@@
@
text
@/* $OpenBSD: fmt_test.c,v 1.14 2017/03/15 05:00:58 dtucker Exp $ */

/*
 * Combined tests for fmt_scaled and scan_scaled.
 * Ian Darwin, January 2001. Public domain.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <errno.h>
#include <limits.h>
#include <unistd.h>

#include <util.h>

static int fmt_test(void);
static int scan_test(void);

static void print_errno(int e);
static int assert_int(int testnum, int checknum, int expect, int result);
static int assert_errno(int testnum, int checknum, int expect, int result);
static int assert_llong(int testnum, int checknum, long long expect, long long result);
static int assert_str(int testnum, int checknum, char * expect, char * result);

extern char *__progname;
static int verbose = 0;

__dead static void usage(int stat)
{
	fprintf(stderr, "usage: %s [-v]\n", __progname);
	exit(stat);
}

int
main(int argc, char **argv)
{
	extern char *optarg;
	extern int optind;
	int i, ch;
 
	while ((ch = getopt(argc, argv, "hv")) != -1) {
			switch (ch) {
			case 'v':
					verbose = 1;
					break;
			case 'h':
					usage(0);
			case '?':
			default:
					usage(1);
			}
	}
	argc -= optind;
	argv += optind;

	if (verbose)
		printf("Starting fmt_test\n");
	i = fmt_test();
	if (verbose)
		printf("Starting scan_test\n");
	i += scan_test();
	if (i) {
		printf("*** %d errors in libutil/fmt_scaled tests ***\n", i);
	} else {
		if (verbose)
			printf("Tests done; no unexpected errors\n");
	}
	return i;
}

/************** tests for fmt_scaled *******************/

static struct {			/* the test cases */
	long long input;
	char *expect;
	int err;
} ddata[] = {
	{ 0, "0B", 0 },
	{ 1, "1B", 0 },
	{ -1, "-1B", 0 },
	{ 100, "100B", 0},
	{ -100, "-100B", 0},
	{ 999, "999B", 0 },
	{ 1000, "1000B", 0 },
	{ 1023, "1023B", 0 },
	{ -1023, "-1023B", 0 },
	{ 1024, "1.0K", 0 },
	{ 1025, "1.0K", 0 },
	{ 1234, "1.2K", 0 },
	{ -1234, "-1.2K", 0 },
	{ 1484, "1.4K", 0 },		/* rounding boundary, down */
	{ 1485, "1.5K", 0 },		/* rounding boundary, up   */
	{ -1484, "-1.4K", 0 },		/* rounding boundary, down */
	{ -1485, "-1.5K", 0 },		/* rounding boundary, up   */
	{ 1536, "1.5K", 0 },
	{ 1786, "1.7K", 0 },
	{ 1800, "1.8K", 0 },
	{ 2000, "2.0K", 0 },
	{ 123456, "121K", 0 },
	{ 578318, "565K", 0 },
	{ 902948, "882K", 0 },
	{ 1048576, "1.0M", 0},
	{ 1048628, "1.0M", 0},
	{ 1049447, "1.0M", 0},
	{ -102400, "-100K", 0},
	{ -103423, "-101K", 0 },
	{ 7299072, "7.0M", 0 },
	{ 409478144L, "391M", 0 },
	{ -409478144L, "-391M", 0 },
	{ 999999999L, "954M", 0 },
	{ 1499999999L, "1.4G", 0 },
	{ 12475423744LL, "11.6G", 0},
	{ 1LL<<61, "2.0E", 0 },
	{ 1LL<<62, "4.0E", 0 },
	{ 1LL<<63, "", ERANGE },
	{ 1099512676352LL, "1.0T", 0}
};
#	define DDATA_LENGTH (sizeof ddata/sizeof *ddata)

static int
fmt_test(void)
{
	unsigned int i, e, errs = 0;
	int ret;
	char buf[FMT_SCALED_STRSIZE];

	for (i = 0; i < DDATA_LENGTH; i++) {
		strlcpy(buf, "UNSET", FMT_SCALED_STRSIZE);
		errno = 0;
		ret = fmt_scaled(ddata[i].input, buf);
		e = errno;
		if (verbose) {
			printf("%lld --> %s (%d)", ddata[i].input, buf, ret);
			if (ret == -1)
				print_errno(e);
			printf("\n");
		}
		if (ret == -1)
			errs += assert_int(i, 1, ret, ddata[i].err == 0 ? 0 : -1);
		if (ddata[i].err)
			errs += assert_errno(i, 2, ddata[i].err, e);
		else
			errs += assert_str(i, 3, ddata[i].expect, buf);
	}

	return errs;
}

/************** tests for scan_scaled *******************/


#define	IMPROBABLE	(-42)

struct {					/* the test cases */
	char *input;
	long long result;
	int err;
} sdata[] = {
	{ "0",		0, 0 },
	{ "123",	123, 0 },
	{ "1k",		1024, 0 },		/* lower case */
	{ "100.944", 100, 0 },	/* should --> 100 (truncates fraction) */
	{ "10099",	10099LL, 0 },
	{ "1M",		1048576LL, 0 },
	{ "1.1M",	1153433LL, 0 },		/* fractions */
	{ "1.111111111111111111M",	1165084LL, 0 },		/* fractions */
	{ "1.55M",	1625292LL, 0 },	/* fractions */
	{ "1.9M",	1992294LL, 0 },		/* fractions */
	{ "-2K",	-2048LL, 0 },		/* negatives */
	{ "-2.2K",	-2252LL, 0 },	/* neg with fract */
	{ "4.5k", 4608, 0 },
	{ "4.5555555555555555K", 4664, 0 },
	{ "4.5555555555555555555K", 4664, 0 },	/* handle enough digits? */
	{ "4.555555555555555555555555555555K", 4664, 0 }, /* ignores extra digits? */
	{ "1G",		1073741824LL, 0 },
	{ "G", 		0, 0 },			/* should == 0G? */
	{ "1234567890", 1234567890LL, 0 },	/* should work */
	{ "1.5E",	1729382256910270464LL, 0 },		/* big */
	{ "32948093840918378473209480483092", 0, ERANGE },  /* too big */
	{ "1.5Q",	0, EINVAL },		/* invalid multiplier */
	{ "1ab",	0, EINVAL },		/* ditto */
	{ "3&",		0, EINVAL },		/* ditto */
	{ "5.0e3",	0, EINVAL },	/* digits after */
	{ "5.0E3",	0, EINVAL },	/* ditto */
	{ "1..0",	0, EINVAL },		/* bad format */
	{ "",		0, 0 },			/* boundary */
	{ "--1", -1, EINVAL },
	{ "++42", -1, EINVAL },
	{ "SCALE_OVERFLOW", 0, ERANGE },
	{ "SCALE_UNDERFLOW", 0, ERANGE },
	{ "LLONG_MAX_K", (LLONG_MAX / 1024) * 1024, 0 },
	{ "LLONG_MIN_K", (LLONG_MIN / 1024) * 1024, 0 },
	{ "LLONG_MAX", LLONG_MAX, 0 },	/* upper limit */

	/*
	 * Lower limit is a bit special: because scan_scaled accumulates into a
	 * signed long long it can only handle up to the negative value of
	 * LLONG_MAX not LLONG_MIN.
	 */
	{ "NEGATIVE_LLONG_MAX", LLONG_MAX*-1, 0 },	/* lower limit */
	{ "LLONG_MIN", 0, ERANGE },	/* can't handle */
#if LLONG_MAX == 0x7fffffffffffffffLL
	{ "-9223372036854775807", -9223372036854775807, 0 },
	{ "9223372036854775807", 9223372036854775807, 0 },
	{ "9223372036854775808", 0, ERANGE },
	{ "9223372036854775809", 0, ERANGE },
#endif
#if LLONG_MIN == (-0x7fffffffffffffffLL-1)
	{ "-9223372036854775808", 0, ERANGE },
	{ "-9223372036854775809", 0, ERANGE },
	{ "-9223372036854775810", 0, ERANGE },
#endif
};
#	define SDATA_LENGTH (sizeof sdata/sizeof *sdata)

static void
print_errno(int e)
{
	switch(e) {
		case EINVAL: printf("EINVAL"); break;
		case EDOM:   printf("EDOM"); break;
		case ERANGE: printf("ERANGE"); break;
		default: printf("errno %d", e);
	}
}

/** Print one result */
static void
print(char *input, long long result, int ret, int e)
{
	printf("\"%40s\" --> %lld (%d)", input, result, ret);
	if (ret == -1) {
		printf(" -- ");
		print_errno(e);
	}
	printf("\n");
}

static int
scan_test(void)
{
	unsigned int i, errs = 0, e;
	int ret;
	long long result;
	char buf[1024], *input;

	for (i = 0; i < SDATA_LENGTH; i++) {
		result = IMPROBABLE;

		input = sdata[i].input;
		/* some magic values for architecture dependent limits */
		if (strcmp(input, "LLONG_MAX") == 0) {
			snprintf(buf, sizeof buf," %lld", LLONG_MAX);
			input = buf;
		} else if (strcmp(input, "LLONG_MIN") == 0) {
			snprintf(buf, sizeof buf," %lld", LLONG_MIN);
			input = buf;
		} else if (strcmp(input, "LLONG_MAX_K") == 0) {
			snprintf(buf, sizeof buf," %lldK", LLONG_MAX/1024);
			input = buf;
		} else if (strcmp(input, "LLONG_MIN_K") == 0) {
			snprintf(buf, sizeof buf," %lldK", LLONG_MIN/1024);
			input = buf;
		} else if (strcmp(input, "SCALE_OVERFLOW") == 0) {
			snprintf(buf, sizeof buf," %lldK", (LLONG_MAX/1024)+1);
			input = buf;
		} else if (strcmp(input, "SCALE_UNDERFLOW") == 0) {
			snprintf(buf, sizeof buf," %lldK", (LLONG_MIN/1024)-1);
			input = buf;
		} else if (strcmp(input, "NEGATIVE_LLONG_MAX") == 0) {
			snprintf(buf, sizeof buf," %lld", LLONG_MAX*-1);
			input = buf;
		}
		if (verbose && input != sdata[i].input)
			printf("expand '%s' -> '%s'\n", sdata[i].input,
			    input);

		/* printf("Calling scan_scaled(%s, ...)\n", sdata[i].input); */
		errno = 0;
		ret = scan_scaled(input, &result);
		e = errno;	/* protect across printfs &c. */
		if (verbose)
			print(input, result, ret, e);
		if (ret == -1)
			errs += assert_int(i, 1, ret, sdata[i].err == 0 ? 0 : -1);
		if (sdata[i].err)
			errs += assert_errno(i, 2, sdata[i].err, e);
		else 
			errs += assert_llong(i, 3, sdata[i].result, result);
	}
	return errs;
}

/************** common testing stuff *******************/

static int
assert_int(int testnum, int check, int expect, int result)
{
	if (expect == result)
		return 0;
	printf("** FAILURE: test %d check %d, expect %d, result %d **\n",
		testnum, check, expect, result);
	return 1;
}

static int
assert_errno(int testnum, int check, int expect, int result)
{
	if (expect == result)
		return 0;
	printf("** FAILURE: test %d check %d, expect ",
		testnum, check);
	print_errno(expect);
	printf(", got ");
	print_errno(result);
	printf(" **\n");
	return 1;
}

static int
assert_llong(int testnum, int check, long long expect, long long result)
{
	if (expect == result)
		return 0;
	printf("** FAILURE: test %d check %d, expect %lld, result %lld **\n",
		testnum, check, expect, result);
	return 1;
}

static int
assert_str(int testnum, int check, char * expect, char * result)
{
	if (strcmp(expect, result) == 0)
		return 0;
	printf("** FAILURE: test %d check %d, expect %s, result %s **\n",
		testnum, check, expect, result);
	return 1;
}
@


1.14
log
@Add tests for scaled overflow and underflow and the exact overflow and
underflow boundaries for 64bit platforms.  Tests for exactly under the
boundaries disabled pending fixes.  ok millert@@ djm@@ (previous version).
@
text
@d1 1
a1 1
/* $OpenBSD: fmt_test.c,v 1.13 2017/03/15 04:31:41 dtucker Exp $ */
a192 1
#if 0
d196 8
a203 3
	{ "LLONG_MIN", LLONG_MIN, 0 },	/* lower limit */
	/* { "9223372036854775808", -9223372036854775808LL, 0 }, */	/* XXX  */
#endif
d205 2
d211 1
d272 3
d276 3
d280 1
a281 1
		/* printf("Calling scan_scaled(%s, ...)\n", sdata[i].input); */
@


1.13
log
@Clean up errno handling in fmt_scaled test:
 - always clear before calling function under test.
 - save immediately after function under test.
 - always use saved value for validation and reporting.
 - remove "fraction too big" testcase that never atually worked (but looked
   like it did because the previous test's errno was never cleared).
 - delete unecessary "extern int errno".
@
text
@d1 1
a1 1
/* $OpenBSD: fmt_test.c,v 1.12 2017/02/25 07:28:32 jsg Exp $ */
d13 1
d191 7
d199 9
d240 1
d244 23
d269 1
a269 1
		ret = scan_scaled(sdata[i].input, &result);
d272 1
a272 1
			print(sdata[i].input, result, ret, e);
@


1.12
log
@Add missing includes to avoid implicit function declarations.
@
text
@d1 1
a1 1
/* $OpenBSD: fmt_test.c,v 1.11 2016/08/14 23:08:09 guenther Exp $ */
d130 1
d142 1
a142 1
			errs += assert_errno(i, 2, ddata[i].err, errno);
a154 2
extern int errno;

a180 1
	{ "329480938409.8378473209480483092", 0, ERANGE },  /* fraction too big */
d201 1
a201 1
		default: printf("errno %d", errno);
d207 1
a207 1
print(char *input, long long result, int ret)
d209 1
a209 2
	int e = errno;
	printf("\"%10s\" --> %lld (%d)", input, result, ret);
d226 1
d231 1
a231 2
			print(sdata[i].input, result, ret);
		errno = e;
a233 1
		errno = e;
d235 1
a235 1
			errs += assert_errno(i, 2, sdata[i].err, errno);
@


1.11
log
@Convert quad_t to long long
@
text
@d1 1
a1 1
/* $OpenBSD: fmt_test.c,v 1.10 2012/11/12 14:10:48 halex Exp $ */
d13 1
@


1.10
log
@require scan_scaled to set errno to EINVAL rather than ERANGE if it
encounters an invalid multiplier, like the man page says it should

"looks sensible" deraadt@@, ok ian@@
@
text
@d1 1
a1 1
/* $OpenBSD: fmt_test.c,v 1.9 2009/06/20 14:23:38 ian Exp $ */
d22 1
a22 1
static int assert_quad_t(int testnum, int checknum, quad_t expect, quad_t result);
d74 1
a74 1
	quad_t input;
d157 1
a157 1
	quad_t result;
d208 1
a208 1
print(char *input, quad_t result, int ret)
d224 1
a224 1
	quad_t result;
d240 1
a240 1
			errs += assert_quad_t(i, 3, sdata[i].result, result);
d272 1
a272 1
assert_quad_t(int testnum, int check, quad_t expect, quad_t result)
@


1.9
log
@Repair comment ID & typo, no binary change
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d182 3
a184 2
	{ "1.5Q",	0, ERANGE },		/* invalid multiplier (XXX ERANGE??) */
	{ "1ab",	0, ERANGE },		/* ditto */
@


1.8
log
@bullshit test; pointed out by david
@
text
@d1 1
a1 1
/* $OpenBSD */
d91 4
a94 4
	{ 1484, "1.4K", 0 },		/* rouding boundary, down */
	{ 1485, "1.5K", 0 },		/* rouding boundary, up   */
	{ -1484, "-1.4K", 0 },		/* rouding boundary, down */
	{ -1485, "-1.5K", 0 },		/* rouding boundary, up   */
@


1.7
log
@Now that rounding is done properly for fractionless numbers, fix the
regression cases and add a few too.
@
text
@a189 1
	{ NULL,		0, EFAULT }		/* bad input */
a198 1
		case EFAULT: printf("EFAULT"); break;
@


1.6
log
@Some more real-life regression cases.
@
text
@d99 3
a101 1
	{ 123456, "120K", 0 },
d108 3
a110 3
	{ 409478144L, "390M", 0 },
	{ -409478144L, "-390M", 0 },
	{ 999999999L, "953M", 0 },
@


1.5
log
@new regression found in the wild: 1099512676352 -> 2.0T; fixed a minute ago.
@
text
@d100 3
@


1.4
log
@errno -> err in a structure.  OK deraadt@@
@
text
@d111 1
@


1.3
log
@Add a few test cases.

ok ian@@
@
text
@d76 1
a76 1
	int errno;
d132 3
a134 3
			errs += assert_int(i, 1, ret, ddata[i].errno == 0 ? 0 : -1);
		if (ddata[i].errno)
			errs += assert_errno(i, 2, ddata[i].errno, errno);
d152 1
a152 1
	int errno;
d230 1
a230 1
			errs += assert_int(i, 1, ret, sdata[i].errno == 0 ? 0 : -1);
d232 2
a233 2
		if (sdata[i].errno)
			errs += assert_errno(i, 2, sdata[i].errno, errno);
@


1.2
log
@various cleanups; david says results are same
@
text
@d79 4
d93 2
d100 2
@


1.1
log
@Regression for fmt_scaled() and scan_scaled().
@
text
@d16 2
a17 2
static int fmt_test();
static int scan_test();
d107 1
a107 1
fmt_test()
d207 1
a207 1
scan_test()
@

