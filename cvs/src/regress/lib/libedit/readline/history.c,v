head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.5.0.2
	OPENBSD_6_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.6
date	2016.09.06.10.33.13;	author schwarze;	state Exp;
branches;
next	1.5;
commitid	An3Lsdpb4upwWa70;

1.5
date	2016.06.01.21.29.38;	author schwarze;	state Exp;
branches;
next	1.4;
commitid	hacZ9HQ1PEm7678s;

1.4
date	2016.06.01.16.29.00;	author schwarze;	state Exp;
branches;
next	1.3;
commitid	LCddytCpismDeUC8;

1.3
date	2016.05.31.16.02.41;	author schwarze;	state Exp;
branches;
next	1.2;
commitid	1bmfbpZlMhK6SBPA;

1.2
date	2016.05.31.15.54.27;	author schwarze;	state Exp;
branches;
next	1.1;
commitid	46KhyYVMhim2rWu3;

1.1
date	2016.05.06.15.39.42;	author schwarze;	state Exp;
branches;
next	;
commitid	3K5KyF5BF58OWYXp;


desc
@@


1.6
log
@These tests didn't work without setting READLINE because we don't
install <editline/readline.h> by default; make them work by using
the copy from the source tree.
Issue reported by otto@@.
@
text
@/*
 * Copyright (c) 2016 Bastian Maerkisch <bmaerkisch@@web.de>
 * Copyright (c) 2016 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute these tests for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THESE TESTS ARE PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <err.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#ifdef READLINE
#include <readline/history.h>
#else
#include <readline/readline.h>
#endif


/*
 * Test infrastructure function.
 * At the beginning of each test, call as "msg(__func__);".
 * Upon failure, call as "msg(fmt, ...);".
 * At the end of each test, call as "return msg(NULL);".
 */
int
msg(const char *fmt, ...)
{
	static const char *testname = NULL;
	static int failed = 0;
	va_list ap;

	if (testname == NULL) {
		using_history();
		unstifle_history();
		testname = fmt;
		return 0;
	}

	if (fmt == NULL) {
		clear_history();
		unstifle_history();
		testname = NULL;
		if (failed == 0)
			return 0;
		failed = 0;
		return 1;
	}

	fprintf(stderr, "%s: ", testname);
	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	fputc('\n', stderr);
	failed = 1;
	return 1;
}

void
check_current(const char *descr, const char *want)
{
	HIST_ENTRY *he;

	he = current_history();

	if (want == NULL) {
		if (he != NULL)
			msg("Failed to move beyond the newest entry.");
		return;
	}

	if (he == NULL)
		msg("%s is NULL.", descr);
	else if (strcmp(he->line, want) != 0)
		msg("%s is \"%s\" instead of \"%s\".", descr, he->line, want);
}

void
check_get(int idx, const char *want)
{
	HIST_ENTRY *he;

	if ((he = history_get(history_base + idx)) == NULL)
		msg("Get %d+%d returned NULL.", history_base, idx);
	else if (he->line == NULL)
		msg("Get %d+%d returned line == NULL.", history_base, idx);
	else if (strcmp(he->line, want) != 0)
		msg("Get %d+%d returned \"%s\" instead of \"%s\".",
		    history_base, idx, he->line, want);
}


/* Fails if previous and next are interchanged. */
int
test_movement_direction(void)
{
	msg(__func__);
	add_history("111");
	add_history("222");

	while (previous_history() != NULL);
	check_current("Oldest entry", "111");

	/*
	 * Move to the most recent end of the history.
	 * This moves past the newest entry.
	 */
	while (next_history() != NULL);
	check_current(NULL, NULL);

	return msg(NULL);
}


/* Fails if the position is counted from the recent end. */
int
test_where(void)
{
	int		 ret;

	msg(__func__);

	/*
	 * Adding four elements since set_pos(0) doesn't work
	 * for some versions of libedit.
	 */
	add_history("111");
	add_history("222");
	add_history("333");
	add_history("444");

	/* Set the pointer to the element "222". */
	history_set_pos(1);
	if ((ret = where_history()) != 1)
		msg("Where returned %d instead of 1.", ret);

	return msg(NULL);
}


/*
 * Fails if the argument of history_get()
 * does not refer to the zero-based index + history_base.
 */
int
test_get(void)
{
	msg(__func__);
	add_history("111");
	add_history("222");
	add_history("333");
	add_history("444");

	/* Try to retrieve second element. */
	check_get(1, "222");

	return msg(NULL);
}


/* Fails if set_pos returns 0 for success and -1 for failure. */
int
test_set_pos_return_values(void)
{
	int		 ret;

	msg(__func__);
	add_history("111");
	add_history("222");

	/* This should fail. */
	if ((ret = history_set_pos(-1)) != 0)
		msg("Set_pos(-1) returned %d instead of 0.", ret);

	/*
	 * This should succeed.
	 * Note that we do not use the index 0 here, since that
	 * actually fails for some versions of libedit.
	 */
	if ((ret = history_set_pos(1)) != 1)
		msg("Set_pos(1) returned %d instead of 1.", ret);

	return msg(NULL);
}


/* Fails if the index is one-based. */
int
test_set_pos_index(void)
{
	msg(__func__);
	add_history("111");
	add_history("222");

	/* Do not test return value here since that might be broken, too. */
	history_set_pos(0);
	check_current("Entry 0", "111");

	history_set_pos(1);
	check_current("Entry 1", "222");

	return msg(NULL);
}


/* Fails if remove does not renumber. */
int
test_remove(void)
{
	msg(__func__);
	add_history("111");
	add_history("222");
	add_history("333");
	add_history("444");

	/* Remove the second item "222"; the index is zero-based. */
	remove_history(1);

	/*
	 * Try to get the new second element using history_get.
	 * The argument of get is based on history_base.
	 */
	check_get(1, "333");

	/*
	 * Try to get the second element using set_pos/current.
	 * The index is zero-based.
	 */
	history_set_pos(1);
	check_current("Entry 1", "333");

	/* Remove the new second item "333". */
	remove_history(1);
	check_get(1, "444");

	return msg(NULL);
}


/* Fails if stifle doesn't discard existing entries. */
int
test_stifle_size(void)
{
	msg(__func__);
	add_history("111");
	add_history("222");
	add_history("333");

	/* Reduce the size of the history. */
	stifle_history(2);
	if (history_length != 2)
		msg("Length is %d instead of 2.", history_length);

	return msg(NULL);
}


/* Fails if add doesn't increase history_base if the history is full. */
int
test_stifle_base(void)
{
	msg(__func__);
	stifle_history(2);

	/* Add one more than the maximum size. */
	add_history("111");
	add_history("222");
	add_history("333");

	/* The history_base should have changed. */
	if (history_base != 2)
		msg("Base is %d instead of 2.", history_base);

	return msg(NULL);
}


int
main(void)
{
	int		 fail = 0;

	fail += test_movement_direction();
	fail += test_where();
	fail += test_get();
	fail += test_set_pos_return_values();
	fail += test_set_pos_index();
	fail += test_remove();
	fail += test_stifle_size();
	fail += test_stifle_base();

	if (fail)
		errx(1, "%d test(s) failed.", fail);
	return 0;
}
@


1.5
log
@Add detailed error messages and restructure to make the individual
test functions shorter and easier to understand.  The total number
of lines remains unchanged.
@
text
@a22 1
#include <stdio.h>
d25 1
a25 1
#include <editline/readline.h>
@


1.4
log
@Test history_get() return value;
from Bastian Maerkisch <bmaerkisch at web dot de>.
@
text
@d3 1
d18 2
d30 73
d107 1
a107 4
	HIST_ENTRY	*he;
	int		 ok = 1;

	using_history();
a110 1
	/* Move to the oldest entry. */
d112 1
a112 3
	he = current_history();
	if (he == NULL || strcmp(he->line, "111") != 0)
		ok = 0;
d119 1
a119 3
	he = current_history();
	if (he != NULL)
		ok = 0;
d121 1
a121 2
	clear_history();
	return ok;
d129 1
a129 1
	int		 ok = 1;
d131 1
a131 1
	using_history();
d144 2
a145 2
	if (where_history() != 1)
		ok = 0;
d147 1
a147 2
	clear_history();
	return ok;
d158 1
a158 4
	HIST_ENTRY	*he;
	int		 ok = 1;

	using_history();
d165 1
a165 3
	he = history_get(history_base + 1);
	if (he == NULL || he->line == NULL || strcmp(he->line, "222") != 0)
		ok = 0;
d167 1
a167 2
	clear_history();
	return ok;
a174 1
	int		 ok = 1;
d177 1
a177 1
	using_history();
d182 2
a183 3
	ret = history_set_pos(-1);
	if (ret != 0)
		ok = 0;
d190 2
a191 3
	ret = history_set_pos(1);
	if (ret != 1)
		ok = 0;
d193 1
a193 2
	clear_history();
	return ok;
d201 1
a201 4
	HIST_ENTRY	*he;
	int		 ok = 1;

	using_history();
d207 1
a207 3
	he = current_history();
	if (he == NULL || strcmp(he->line, "111") != 0)
		ok = 0;
d210 1
a210 3
	he = current_history();
	if (he == NULL || strcmp(he->line, "222") != 0)
		ok = 0;
d212 1
a212 2
	clear_history();
	return ok;
d220 1
a220 4
	HIST_ENTRY	*he;
	int		 ok = 1;

	using_history();
d233 1
a233 3
	he = history_get(history_base + 1);
	if (he == NULL || strcmp(he->line, "333") != 0)
		ok = 0;
d240 1
a240 3
	he = current_history();
	if (he == NULL || strcmp(he->line, "333") != 0)
		ok = 0;
d244 1
a244 3
	he = history_get(history_base + 1);
	if (he == NULL || strcmp(he->line, "444") != 0)
		ok = 0;
d246 1
a246 2
	clear_history();
	return ok;
d254 1
a254 4
	int		 ok = 1;

	using_history();
	unstifle_history();
d262 1
a262 1
		ok = 0;
d264 1
a264 3
	unstifle_history();
	clear_history();
	return ok;
d272 1
a272 3
	int		 ok = 1;

	using_history();
d282 1
a282 1
		ok = 0;
d284 1
a284 3
	unstifle_history();
	clear_history();
	return ok;
d293 9
a301 32
	if (!test_movement_direction()) {
		warnx("previous or next move to the wrong entry.");
		fail++;
	}
	if (!test_where()) {
		warnx("where returns the wrong history number.");
		fail++;
	}
	if (!test_get()) {
		warnx("retrieving elements with history_get failed.");
		fail++;
	}
	if (!test_set_pos_return_values()) {
		warnx("set_pos returns the wrong history number.");
		fail++;
	}
	if (!test_set_pos_index()) {
		warnx("set_pos moves to the wrong entry.");
		fail++;
	}
	if (!test_remove()) {
		warnx("remove corrupts history numbers.");
		fail++;
	}
	if (!test_stifle_size()) {
		warnx("stifle sets the wrong history size.");
		fail++;
	}
	if (!test_stifle_base()) {
		warnx("add to a stifled history sets the wrong history_base.");
		fail++;
	}
@


1.3
log
@The argument of remove_history() only counts existing entries,
not those that were previously deleted.
@
text
@d85 26
d270 4
@


1.2
log
@Style unification and whitespace cleanup, in part suggested by
Christian Heckendorf.  No functional change.
@
text
@d153 1
d173 6
@


1.1
log
@A few regression tests for libedit readline(3) compat code.
Not linked to the build for now because these tests still fail for
our libedit and because readline compat is not enabled in our build.

Test suite written by Bastian Maerkisch <bmaerkisch@@web.de>.
KNF and some minor tweaks by me.
@
text
@d31 1
a31 1
	HIST_ENTRY	*entry;
d33 1
a33 1
  
d40 2
a41 2
	entry = current_history();
	if (entry == NULL || strcmp(entry->line, "111") != 0)
d49 2
a50 2
	entry = current_history();
	if (entry != NULL)
d54 1
a54 1
	return ok; 
d79 1
a79 1
  
d81 1
a81 1
	return ok; 
d84 1
d91 1
a91 1
  
d106 1
a106 1
	ret = history_set_pos(1); 
d111 2
a112 2
	return ok; 
}  
d119 1
a119 1
	HIST_ENTRY	*entry;
d121 1
a121 1
  
d128 2
a129 2
	entry = current_history();
	if (entry == NULL || strcmp(entry->line, "111") != 0)
d131 1
a131 1
 
d133 2
a134 2
	entry = current_history();
	if (entry == NULL || strcmp(entry->line, "222") != 0)
d138 1
a138 1
	return ok; 
d146 1
a146 1
	HIST_ENTRY	*entry;
d148 1
a148 1
  
d156 1
a156 1
  
d161 2
a162 2
	entry = history_get(history_base + 1);
	if (entry == NULL || strcmp(entry->line, "333") != 0)
d164 1
a164 1
  
d170 2
a171 2
	entry = current_history();
	if (entry == NULL || strcmp(entry->line, "333") != 0)
d175 1
a175 1
	return ok; 
d184 1
a184 1
  
d195 1
a195 1
 
d198 1
a198 1
	return ok; 
d207 1
a207 1
  
d222 1
a222 1
	return ok; 
@

