head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.2
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.22
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.12
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.20
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.18
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.16
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.14
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.10
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.8
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.6
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.4
	OPENBSD_5_0:1.2.0.2
	OPENBSD_5_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.3
date	2016.10.23.18.46.03;	author otto;	state Exp;
branches;
next	1.2;
commitid	kWAmxojEDQqVm7tU;

1.2
date	2011.07.09.03.33.07;	author martynas;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.28.22.38.06;	author martynas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@fix lgamma test on i386 and use symbolic constant; ok martynas@@
@
text
@/*	$OpenBSD: lgamma.c,v 1.2 2011/07/09 03:33:07 martynas Exp $	*/

/*
 * Written by Martynas Venckus.  Public domain
 */

#define __POSIX_VISIBLE 201403

#include <assert.h>
#include <math.h>
#include <float.h>


int
main(int argc, char *argv[])
{
	assert(isnan(lgamma(NAN)));
	assert(isnan(lgammaf(NAN)));

	signgam = 0;
	assert(lgamma(-HUGE_VAL) == HUGE_VAL && signgam == 1);
	signgam = 0;
	assert(lgammaf(-HUGE_VALF) == HUGE_VALF && signgam == 1);
	signgam = 0;
	assert(lgammal(-HUGE_VALL) == HUGE_VALL && signgam == 1);

	signgam = 0;
	assert(lgamma(HUGE_VAL) == HUGE_VAL && signgam == 1);
	signgam = 0;
	assert(lgammaf(HUGE_VALF) == HUGE_VALF && signgam == 1);
	signgam = 0;
	assert(lgammal(HUGE_VALL) == HUGE_VALL && signgam == 1);

	signgam = 0;
	assert(lgamma(-0.0) == HUGE_VAL && signgam == -1);
	signgam = 0;
	assert(lgammaf(-0.0F) == HUGE_VALF && signgam == -1);
	signgam = 0;
	assert(lgammal(-0.0L) == HUGE_VALL && signgam == -1);

	signgam = 0;
	assert(lgamma(0.0) == HUGE_VAL && signgam == 1);
	signgam = 0;
	assert(lgammaf(0.0F) == HUGE_VALF && signgam == 1);
	signgam = 0;
	assert(lgammal(0.0L) == HUGE_VALL && signgam == 1);

	signgam = 0;
	assert(lgamma(1.0) == 0.0 && signgam == 1);
	signgam = 0;
	assert(lgammaf(1.0F) == 0.0F && signgam == 1);
	signgam = 0;
	assert(lgammal(1.0L) == 0.0L && signgam == 1);

	signgam = 0;
	assert(fabs(lgamma(3.0) - M_LN2) < DBL_EPSILON && signgam == 1);
	signgam = 0;
	assert(fabsf(lgammaf(3.0F) - (float)M_LN2) < FLT_EPSILON && signgam == 1);
	signgam = 0;
	assert(fabsl(lgammal(3.0L) - M_LN2l) < LDBL_EPSILON && signgam == 1);

	return (0);
}
@


1.2
log
@Adapt tests for extended-precision.
@
text
@d1 1
a1 1
/*	$OpenBSD: lgamma.c,v 1.1 2011/05/28 22:38:06 martynas Exp $	*/
d7 2
d11 2
d56 1
a56 1
	assert(lgamma(3.0) == M_LN2 && signgam == 1);
d58 1
a58 1
	assert(lgammaf(3.0F) == (float)M_LN2 && signgam == 1);
d60 1
a60 2
	assert(lgammal(3.0L) == 0.6931471805599453094172321214581766L &&
	    signgam == 1);
@


1.1
log
@Add some simple test cases for lgamma, and lgammaf.
Currently the functions return correct results for the input of
negative zero;  however signgam is wrong in this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: nextafter.c,v 1.1 2011/04/16 20:41:23 martynas Exp $	*/
d19 3
a21 1
	assert(lgammaf(-HUGE_VAL) == HUGE_VAL && signgam == 1);
d26 3
a28 1
	assert(lgammaf(HUGE_VAL) == HUGE_VAL && signgam == 1);
d33 3
a35 1
	assert(lgammaf(-0.0) == HUGE_VAL && signgam == -1);
d40 3
a42 1
	assert(lgammaf(0.0) == HUGE_VAL && signgam == 1);
d47 3
a49 1
	assert(lgammaf(1.0) == 0.0 && signgam == 1);
d54 4
a57 1
	assert(lgammaf(3.0) == (float)M_LN2 && signgam == 1);
@

