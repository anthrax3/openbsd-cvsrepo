head	1.2;
access;
symbols
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.26
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.22
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.12
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.20
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.18
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.16
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.14
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.10
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.8
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.6
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.4
	OPENBSD_5_0:1.2.0.2
	OPENBSD_5_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.2
date	2011.07.09.03.33.07;	author martynas;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.17.10.33.09;	author martynas;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Adapt tests for extended-precision.
@
text
@/*	$OpenBSD: round.c,v 1.1 2011/04/17 10:33:09 martynas Exp $	*/

/*	Written by Michael Shalayeff, 2003,  Public domain.	*/

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <math.h>
#include <ieeefp.h>

static void
sigfpe(int sig, siginfo_t *si, void *v)
{
	char buf[132];

	if (si) {
		snprintf(buf, sizeof(buf), "sigfpe: addr=%p, code=%d\n",
		    si->si_addr, si->si_code);
		write(1, buf, strlen(buf));
	}
	_exit(1);
}

int
main(int argc, char *argv[])
{
	struct sigaction sa;

	memset(&sa, 0, sizeof(sa));
	sa.sa_sigaction = sigfpe;
	sa.sa_flags = SA_SIGINFO;
	sigaction(SIGFPE, &sa, NULL);

	assert(round(8.6) == 9.);
	assert(roundf(8.6F) == 9);
	assert(roundl(8.6L) == 9);
 	assert(lround(8.6) == 9L);
 	assert(lroundf(8.6F) == 9L);
 	assert(lroundl(8.6L) == 9L);
 	assert(llround(8.6) == 9LL);
 	assert(llroundf(8.6F) == 9LL);
 	assert(llroundl(8.6L) == 9LL);

	assert(lround(0.0) == 0L);
	assert(lroundf(0.0F) == 0L);
	assert(lroundl(0.0L) == 0L);
	assert(lround(-0.0) == 0L);
	assert(lroundf(-0.0F) == 0L);
	assert(lroundl(-0.0L) == 0L);

	assert(llround(4503599627370496.0) == 4503599627370496LL);
	assert(llroundf(4503599627370496.0F) == 4503599627370496LL);
	assert(llroundl(4503599627370496.0L) == 4503599627370496LL);
	assert(llround(-4503599627370496.0) == -4503599627370496LL);
	assert(llroundf(-4503599627370496.0F) == -4503599627370496LL);
	assert(llroundl(-4503599627370496.0L) == -4503599627370496LL);

	assert(llround(0x7ffffffffffffc00.0p0) == 0x7ffffffffffffc00LL);
	assert(llroundf(0x7fffff8000000000.0p0F) == 0x7fffff8000000000LL);
	assert(llroundl(0x7fffff8000000000.0p0L) == 0x7fffff8000000000LL);
	assert(llround(-0x8000000000000000.0p0) == -0x8000000000000000LL);
	assert(llroundf(-0x8000000000000000.0p0F) == -0x8000000000000000LL);
	assert(llroundl(-0x8000000000000000.0p0L) == -0x8000000000000000LL);

	exit(0);
}
@


1.1
log
@Add tests for {,l,ll}round{,f}.  Same tests as for {,l,ll}rint{,f},
except doesn't test rounding modes.  Fix pending.

Build it with -fno-builtin if you want to test the library
functionality--otherwise GCC4 will decide to use its builtins on
some platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: round.c,v 1.10 2011/04/10 17:06:44 martynas Exp $	*/
d39 1
d42 1
d45 1
d48 2
a49 1
	assert(lroundf(0.0) == 0L);
d51 2
a52 1
	assert(lroundf(-0.0) == 0L);
d56 1
d59 1
d63 1
d66 1
@

