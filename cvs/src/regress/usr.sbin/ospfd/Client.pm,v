head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.4.0.8
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2
	bluhm_20140712:1.1.1.1
	bluhm:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2016.12.26.21.30.10;	author jca;	state Exp;
branches;
next	1.5;
commitid	4EK5zByufjOPkoKe;

1.5
date	2016.09.28.12.40.35;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	p0cTad22OJvaMaNh;

1.4
date	2015.01.16.17.06.43;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	7I9wAy0dkdJu6Go6;

1.3
date	2014.08.18.22.58.19;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	Lrki66TGIJh8PoUM;

1.2
date	2014.07.11.22.28.51;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	lY6wANvFqgpBIoFW;

1.1
date	2014.07.11.22.18.03;	author bluhm;	state Exp;
branches
	1.1.1.1;
next	;
commitid	l11Dew1gaiTo2gTR;

1.1.1.1
date	2014.07.11.22.18.03;	author bluhm;	state Exp;
branches;
next	;
commitid	l11Dew1gaiTo2gTR;


desc
@@


1.6
log
@Typo, "more then" -> "more than"
@
text
@#	$OpenBSD: Client.pm,v 1.5 2016/09/28 12:40:35 bluhm Exp $

# Copyright (c) 2010-2015 Alexander Bluhm <bluhm@@openbsd.org>
# Copyright (c) 2014-2015 Florian Riehm <mail@@friehm.de>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use feature "state";

package Client;
use parent 'Proc';
use Carp;

use Fcntl;
use Data::Dumper;
use YAML;

use AnyEvent;
use AnyEvent::Handle;
use AnyEvent::Strict;

use Packet;
use Tap 'opentap';

my $tap_number;
my $area;
my $hello_interval;
# Parameters for interface state machine of the test
my $ism_mac;
my $ism_ip;
my $ism_rtrid;
# Parameters for ospfd under test
my $ospfd_ip;
my $ospfd_rtrid;

my $handle;
my $check;
my $wait;
my $cv;
my @@isms;

sub handle_arp {
    my %arp = consume_arp(\$handle->{rbuf});
    my %ether = (
	src_str => $ism_mac,
	dst_str => $arp{sha_str},
	type    => 0x0806,
    );
    $arp{op} = 2;
    @@arp{qw(sha_str spa_str tha_str tpa_str)} =
	($ism_mac, @@arp{qw(tpa_str sha_str spa_str)});
    $handle->push_write(
	construct_ether(\%ether,
	construct_arp(\%arp))
    );
}

sub handle_ip {
    my %ip = consume_ip(\$handle->{rbuf});
    unless ($ip{p} == 89) {
	warn "ip proto is not ospf";
	return;
    }
    $ip{src_str} eq $ospfd_ip
	or return $cv->croak(
	"ospfd src ip is $ip{src_str}: expected $ospfd_ip");
    my %ospf = consume_ospf(\$handle->{rbuf});
    $ospf{router_id_str} eq $ospfd_rtrid
	or return $cv->croak(
	"ospfd rtrid is $ospf{router_id_str}: expected $ospfd_rtrid");
    $ospf{area_id_str} eq $area
	or return $cv->croak(
	"ospfd area is $ospf{area_id_str}: expected $area");
    if ($ospf{type} == 1) {
	handle_hello();
    } elsif ($ospf{type} == 2) {
	handle_dd();
    } else {
	warn "ospf type is not supported: $ospf{type}";
    }
}

sub handle_hello {
    my %hello = consume_hello(\$handle->{rbuf});

    my $compare = sub {
	my $expect = shift;
	if ($expect->{dr}) {
	    $hello{designated_router_str} eq $expect->{dr}
		or return "dr is $hello{designated_router_str}: ".
		    "expected $expect->{dr}";
	}
	if ($expect->{bdr}) {
	    $hello{backup_designated_router_str} eq $expect->{bdr}
		or return "bdr is $hello{backup_designated_router_str}: ".
		    "expected $expect->{bdr}";
	}
	if ($expect->{nbrs}) {
	    my @@neighbors = sort @@{$hello{neighbors_str} || []};
	    my @@nbrs = @@{$expect->{nbrs}};
	    "@@neighbors" eq "@@nbrs"
		or return "nbrs [@@neighbors]: expected [@@nbrs]";
	}
	return "";
    };

    my $error = $compare->($check);
    return $cv->croak("check: $error") if $error;
    print "check hello successful\n";

    my $reason;
    if ($wait) {
	$reason = $compare->($wait);
    }
    if ($reason) {
	print "wait for hello because of: $reason\n";
    } elsif (!$wait || $wait->{dr} || $wait->{bdr} || $wait->{nbrs}) {
	$cv->send();
    }
}

sub handle_dd {
    my %dd = consume_dd(\$handle->{rbuf});

    my $compare = sub {
	my $expect = shift;
	foreach my $key (qw(options bits)) {
	    if ($expect->{"dd_$key"}) {
		$dd{$key} == $expect->{"dd_$key"} or
		    return sprintf("dd key '%s' is 0x%x: expected 0x%x\n",
			$key, $dd{$key}, $expect->{"dd_$key"});
	    }
	}
	if ($expect->{dd_seq}) {
	    $dd{dd_sequence_number} == $expect->{dd_seq} or
		return sprintf("dd_sequence_number is 0x%x: expected 0x%x\n",
		    $dd{dd_sequence_number}, $expect->{dd_seq});
	}
	return "";
    };

    my $error = $compare->($check);
    return $cv->croak("check: $error") if $error;
    print "check dd successful\n";

    my $reason;
    if ($wait) {
	$reason = $compare->($wait);
    }
    if ($reason) {
	print "wait for dd because of: $reason\n";
    } elsif (!$wait || $wait->{dd_bits} || $wait->{dd_options} ||
	$wait->{dd_seq}) {
	$cv->send();
    }
}

my $ism_count = 0;
sub interface_state_machine {
    my %state = (
	dr  => "0.0.0.0",
	bdr => "0.0.0.0",
	pri => 1,
    );

    # increment the ip address and router id for each instance of ism
    my $ip_number = unpack("N", pack("C4", split(/\./, $ism_ip)));
    my $ip = join(".", unpack("C4", pack("N", $ip_number + $ism_count)));
    my $rtrid_number = unpack("N", pack("C4", split(/\./, $ism_rtrid)));
    my $rtrid = join(".", unpack("C4", pack("N", $rtrid_number + $ism_count)));
    $ism_count++;

    my $hello_count = 0;
    $state{timer} = AnyEvent->timer(
	after => 3,
	interval => $hello_interval,
	cb => sub {
	    my %ether = (
		src_str => $ism_mac,
		dst_str => "01:00:5e:00:00:05",  # multicast ospf
		type    => 0x0800,               # ipv4
	    );
	    my %ip = (
		v       => 4,               # ipv4
		hlen    => 20,
		tos     => 0xc0,
		id      => $hello_count++,  # increment for debugging
		off     => 0,               # no fragment
		ttl     => 1,               # only for direct connected
		p       => 89,              # protocol ospf
		src_str => $ip,
		dst_str => "224.0.0.5",     # all ospf router multicast
	    );
	    my %ospf = (
		version       => 2,           # ospf v2
		type	      => 1,           # hello
		router_id_str => $rtrid,
		area_id_str   => $area,
		autype        => 0,           # no authentication
	    );
	    my %hello = (
		network_mask_str             => "255.255.255.0",
		hellointerval                => $hello_interval,
		options                      => 0x02,
		rtr_pri		             => $state{pri},
		routerdeadinterval           => 4 * $hello_interval,
		designated_router_str        => $state{dr},
		backup_designated_router_str => $state{bdr},
		neighbors_str                => $state{nbrs},
	    );
	    $handle->push_write(
		construct_ether(\%ether,
		construct_ip(\%ip,
		construct_ospf(\%ospf,
		construct_hello(\%hello))))
	    );
	},
    );

    return \%state;
}

sub send_dd {
    my $state = shift;
    my $ip_number = unpack("N", pack("C4", split(/\./, $ism_ip)));
    my $ip = join(".", unpack("C4", pack("N", $ip_number)));
    my $rtrid_number = unpack("N", pack("C4", split(/\./, $ism_rtrid)));
    my $rtrid = join(".", unpack("C4", pack("N", $rtrid_number)));
    state $dd_count = 0;

    my %ether = (
	src_str => $ism_mac,
	dst_str => "01:00:5e:00:00:05",  # don't know the real dst mac
	type    => 0x0800,               # ipv4
    );
    my %ip = (
	v       => 4,               # ipv4
	hlen    => 20,
	tos     => 0xc0,
	id      => $dd_count++,	    # increment for debugging
	off     => 0,               # no fragment
	ttl     => 1,               # only for direct connected
	p       => 89,              # protocol ospf
	src_str => $ip,
	dst_str => $ospfd_ip,
    );
    my %ospf = (
	version       => 2,           # ospf v2
	type	      => 2,           # dd
	router_id_str => $rtrid,
	area_id_str   => $area,
	autype        => 0,           # no authentication
    );
    my %dd = (
	interface_mtu => 1500,
	options => 0x02,
	bits => $state->{dd_bits},
	dd_sequence_number => 999,	# some value
    );
    $handle->push_write(
	construct_ether(\%ether,
	construct_ip(\%ip,
	construct_ospf(\%ospf,
	construct_dd(\%dd))))
    );
}

sub ism_set_state {
    my $state = shift;

    my @@states = ref($state) eq 'ARRAY' ? @@$state : ( $state || () );
    for (my $i = 0; $i < @@states; $i++) {
	$isms[$i] ||= interface_state_machine();
	%{$isms[$i]} = (%{$isms[$i]}, %{$states[$i]});
	if ($states[$i]{dd_bits}) {
	    send_dd($states[$i]);
	    delete $states[$i]{dd_bits};
	}
    }
}

sub runtest {
    my $self = shift;

    $| = 1;

    ism_set_state($self->{state} || {});

    foreach my $task (@@{$self->{tasks}}) {
	print "Task: $task->{name}\n";
	$check = $task->{check};
	$wait = $task->{wait};
	my $timeout = $task->{timeout};
	my $t;
	if ($timeout) {
	    $t = AnyEvent->timer(
		after => $timeout,
		cb => sub { $cv->croak("timeout after $timeout seconds"); },
	    );
	}
	$cv = AnyEvent->condvar;
	$cv->recv;
	ism_set_state($task->{state});
    }

    print "Terminating\n";
    sleep 1;
}

sub new {
    my ($class, %args) = @@_;
    $args{logfile} ||= "client.log";
    $args{up} = "Starting test client";
    $args{down} = "Terminating";
    $args{func} = \&runtest;
    my $self = Proc::new($class, %args);
    return $self;
}

sub child {
    my $self = shift;

    $area = $self->{area}
	or croak ref($self), " area id missing";
    $hello_interval = $self->{hello_intervall}
	or croak ref($self), " hello_interval missing";
    $ism_mac = $self->{mac_address}
	or croak ref($self), " client mac address missing";
    $ism_ip = $self->{ospf_address}
	or croak ref($self), " client ospf address missing";
    $ism_rtrid = $self->{router_id}
	or croak ref($self), " client router id missing";
    $tap_number =  $self->{tap_number}
	or croak ref($self), " tap device number missing";
    $ospfd_ip = $self->{ospfd_ip}
	or croak ref($self), " ospfd ip missing";
    $ospfd_rtrid = $self->{ospfd_rtrid}
	or croak ref($self), " ospfd router id missing";

    my $tap = opentap($tap_number);

    $handle = AnyEvent::Handle->new(
	fh => $tap,
	read_size => 70000,  # little more than max ip size
	on_error => sub {
	    $cv->croak("error on tap device $tap_number: $!");
	    $handle->destroy();
	    undef $handle;
	},
	on_eof => sub {
	    $cv->croak("end-of-file on tap device $tap_number: $!");
	    $handle->destroy();
	    undef $handle;
	},
	on_read => sub {
	    my %ether = consume_ether(\$handle->{rbuf});
	    if ($ether{type} == 0x0800) {
		handle_ip();
	    } elsif ($ether{type} == 0x0806) {
		handle_arp();
	    } else {
		warn "ether type is not supported: $ether{type_hex}";
	    }
	    $handle->{rbuf} = "";  # packets must not cumulate
	},
    );
}

1;
@


1.5
log
@The tun interface has been renamed to tap(4).  Adapt ospfd test.
@
text
@d1 1
a1 1
#	$OpenBSD: Client.pm,v 1.4 2015/01/16 17:06:43 bluhm Exp $
d356 1
a356 1
	read_size => 70000,  # little more then max ip size
@


1.4
log
@Add test that exchanges database description packets with ospfd.
From Florian Riehm.
@
text
@d1 1
a1 1
#	$OpenBSD: Client.pm,v 1.3 2014/08/18 22:58:19 bluhm Exp $
d35 1
a35 1
use Tun 'opentun';
d37 1
a37 1
my $tun_number;
d345 2
a346 2
    $tun_number =  $self->{tun_number}
	or croak ref($self), " tun device number missing";
d352 1
a352 1
    my $tun = opentun($tun_number);
d355 1
a355 1
	fh => $tun,
d358 1
a358 1
	    $cv->croak("error on tun device $tun_number: $!");
d363 1
a363 1
	    $cv->croak("end-of-file on tun device $tun_number: $!");
@


1.3
log
@Make the perl modules consistent for the multiple regression tests.
This includes coding style, better error messages and variable
naming.
@
text
@d1 1
a1 1
#	$OpenBSD: Client.pm,v 1.2 2014/07/11 22:28:51 bluhm Exp $
d3 2
a4 2
# Copyright (c) 2010-2014 Alexander Bluhm <bluhm@@openbsd.org>
# Copyright (c) 2014 Florian Riehm <mail@@friehm.de>
d20 1
d88 2
d129 37
a165 1
    } else {
d235 45
d287 4
@


1.2
log
@Add OpenBSD RCS id.
@
text
@d1 1
a1 1
#	$OpenBSD$
d247 2
a248 1
    $area = $self->{area} or die "area id missing";
d250 1
a250 1
	or die "hello_interval missing";
d252 1
a252 1
	or die "client mac address missing";
d254 1
a254 1
	or die "client ospf address missing";
d256 1
a256 1
	or die "client router id missing";
d258 1
a258 1
	or die "tun device number missing";
d260 1
a260 1
	or die "ospfd ip missing";
d262 1
a262 1
	or die "ospfd router id missing";
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@Add a test framework for the ospfd routing daemon.  For each test
one fresh daemon is started with an individual config.  It is talking
OSPF via a tun interface.  At the process side of the tun device a
client is running.  This test programm is parsing the OSPF packets
and generates new ones.  It simulates other OSPF daemons.

For now only hello packets are tested.  Each test has a task list
which drives the ospfd through its interface state machine.  The
plan is to extend the framework for the other OSPF packet types and 
state machines.  Eventualy the generated kernel routing messages 
could also be checked.

I have developed this test suite together with Florian Riehm.
@
text
@@
