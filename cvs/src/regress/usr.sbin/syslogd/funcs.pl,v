head	1.33;
access;
symbols
	OPENBSD_6_1:1.30.0.6
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.18.0.4
	OPENBSD_5_7_BASE:1.18
	bluhm_20140820:1.1.1.1
	bluhm:1.1.1;
locks; strict;
comment	@# @;


1.33
date	2017.09.13.00.35.53;	author bluhm;	state Exp;
branches;
next	1.32;
commitid	bWWbEvUtwVmoTxtA;

1.32
date	2017.04.07.15.49.46;	author bluhm;	state Exp;
branches;
next	1.31;
commitid	UeGzQyxdfaHiOc9Q;

1.31
date	2017.04.06.16.56.44;	author bluhm;	state Exp;
branches;
next	1.30;
commitid	ksZqqvb6rOiQTz4j;

1.30
date	2016.03.21.23.23.15;	author bluhm;	state Exp;
branches;
next	1.29;
commitid	ICMd7I0he7hx5htW;

1.29
date	2015.12.30.13.15.52;	author bluhm;	state Exp;
branches;
next	1.28;
commitid	A5ZwhsoQcJtCsd2c;

1.28
date	2015.12.04.13.49.42;	author bluhm;	state Exp;
branches;
next	1.27;
commitid	Png8GPl0MIbEHtve;

1.27
date	2015.10.23.14.06.55;	author bluhm;	state Exp;
branches;
next	1.26;
commitid	zdQFfTKt14DNTjQ1;

1.26
date	2015.10.19.20.16.09;	author bluhm;	state Exp;
branches;
next	1.25;
commitid	kVDnyxLzqDFKPFoO;

1.25
date	2015.10.09.17.07.06;	author bluhm;	state Exp;
branches;
next	1.24;
commitid	m9fthBBZas0yIZjN;

1.24
date	2015.09.09.08.48.46;	author bluhm;	state Exp;
branches;
next	1.23;
commitid	bbarh0dLTKPjADRO;

1.23
date	2015.07.19.20.18.18;	author bluhm;	state Exp;
branches;
next	1.22;
commitid	3V6wL7hT2XianIlr;

1.22
date	2015.07.16.16.34.49;	author bluhm;	state Exp;
branches;
next	1.21;
commitid	0M9ba2ikkjyPND6j;

1.21
date	2015.07.07.18.03.11;	author bluhm;	state Exp;
branches;
next	1.20;
commitid	qTzx3B33iQFlT4Uv;

1.20
date	2015.06.28.18.52.11;	author bluhm;	state Exp;
branches;
next	1.19;
commitid	aM7CthL8OPRsDMFq;

1.19
date	2015.06.15.21.44.57;	author bluhm;	state Exp;
branches;
next	1.18;
commitid	BmPbwQg6idYgxXrC;

1.18
date	2015.02.12.23.16.02;	author bluhm;	state Exp;
branches;
next	1.17;
commitid	trL3czROWP2b0HA5;

1.17
date	2015.02.11.21.51.13;	author bluhm;	state Exp;
branches;
next	1.16;
commitid	oVck3lsrH2XH2G1o;

1.16
date	2015.02.11.17.28.42;	author bluhm;	state Exp;
branches;
next	1.15;
commitid	hkdmk7KSUJ4UFi47;

1.15
date	2015.02.08.15.24.14;	author bluhm;	state Exp;
branches;
next	1.14;
commitid	mltz6ku0toaoDiSH;

1.14
date	2015.02.06.00.27.41;	author bluhm;	state Exp;
branches;
next	1.13;
commitid	8et2usx9CGyR7b0D;

1.13
date	2015.02.02.17.40.24;	author bluhm;	state Exp;
branches;
next	1.12;
commitid	BkvE03kfcbCrYutX;

1.12
date	2015.01.22.00.34.32;	author bluhm;	state Exp;
branches;
next	1.11;
commitid	LuWj56jz2petAB5H;

1.11
date	2015.01.16.11.51.59;	author bluhm;	state Exp;
branches;
next	1.10;
commitid	0LYtCVxwz86nbUES;

1.10
date	2015.01.15.13.15.17;	author bluhm;	state Exp;
branches;
next	1.9;
commitid	mHMJNTj9xtaQr97F;

1.9
date	2015.01.01.19.58.48;	author bluhm;	state Exp;
branches;
next	1.8;
commitid	2YTZ0i51684RZ6xu;

1.8
date	2014.12.28.14.08.01;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	2DOukBo6SZhymWi6;

1.7
date	2014.09.13.23.38.24;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	8abA8sLPTwAOrtQB;

1.6
date	2014.09.03.15.56.07;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	JHHXofVHBjdMTBFz;

1.5
date	2014.09.02.17.43.29;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	uB2qKOs5zbFwXm2E;

1.4
date	2014.09.02.00.26.30;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	9hOtCJWVU54mPrrd;

1.3
date	2014.08.29.21.57.17;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	TS3iFEuacexTkq8M;

1.2
date	2014.08.25.17.55.27;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	YvrBMAbzTxViFsim;

1.1
date	2014.08.20.20.52.14;	author bluhm;	state Exp;
branches
	1.1.1.1;
next	;
commitid	DUvdbfhw6s1btkKk;

1.1.1.1
date	2014.08.20.20.52.14;	author bluhm;	state Exp;
branches;
next	;
commitid	DUvdbfhw6s1btkKk;


desc
@@


1.33
log
@Check that the hostname added by syslogd -h in file and server log
is correct.  Use generic redo functions.  Do syntax check for all
Perl files.
@
text
@#	$OpenBSD: funcs.pl,v 1.32 2017/04/07 15:49:46 bluhm Exp $

# Copyright (c) 2010-2015 Alexander Bluhm <bluhm@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
no warnings 'experimental::smartmatch';
use feature 'switch';
use Errno;
use List::Util qw(first);
use Socket;
use Socket6;
use Sys::Syslog qw(:standard :extended :macros);
use Time::HiRes 'sleep';
use IO::Socket;
use IO::Socket::INET6;

my $firstlog = "syslogd regress test first message";
my $secondlog = "syslogd regress test second message";
my $thirdlog = "syslogd regress test third message";
my $testlog = "syslogd regress test log message";
my $downlog = "syslogd regress client shutdown";
my $charlog = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

sub find_ports {
	my %args = @@_;
	my $num    = delete $args{num}    // 1;
	my $domain = delete $args{domain} // AF_INET;
	my $addr   = delete $args{addr}   // "127.0.0.1";
	my $proto  = delete $args{proto}  // "udp";
	$proto = "tcp" if $proto eq "tls";

	my @@sockets = (1..$num);
	foreach my $s (@@sockets) {
		$s = IO::Socket::INET6->new(
		    Domain    => $domain,
		    LocalAddr => $addr,
		    Proto     => $proto,
		) or die "find_ports: create and bind socket failed: $!";
	}
	my @@ports = map { $_->sockport() } @@sockets;

	return wantarray ? @@ports : $ports[0];
}

########################################################################
# Client funcs
########################################################################

sub write_log {
	my $self = shift;

	write_message($self, $testlog);
	IO::Handle::flush(\*STDOUT);
	${$self->{syslogd}}->loggrep($testlog, 2);
	write_shutdown($self);
}

sub write_between2logs {
	my $self = shift;
	my $func = shift;

	write_message($self, $firstlog);
	$func->($self, @@_);
	write_message($self, $testlog);
	IO::Handle::flush(\*STDOUT);
	${$self->{syslogd}}->loggrep($testlog, 2);
	write_shutdown($self);
}

sub write_message {
	my $self = shift;

	if (defined($self->{connectdomain})) {
		my $msg = join("", @@_);
		if ($self->{connectdomain} eq "sendsyslog") {
			my $flags = $self->{connect}{flags} || 0;
			sendsyslog($msg, $flags) or die ref($self),
			    " sendsyslog failed: $!";
		} elsif ($self->{connectproto} eq "udp") {
			# writing UDP packets works only with syswrite()
			defined(my $n = syswrite(STDOUT, $msg))
			    or die ref($self), " write log line failed: $!";
			$n == length($msg)
			    or die ref($self), " short UDP write";
		} else {
			print $msg;
			print "\n" if $self->{connectproto} =~ /^(tcp|tls)$/;
		}
		print STDERR "<<< $msg\n";
	} else {
		syslog(LOG_INFO, @@_);
	}
}

sub sendsyslog {
	my $msg = shift;
	my $flags = shift;
	require 'sys/syscall.ph';
	return syscall(&SYS_sendsyslog, $msg, length($msg), $flags) != -1;
}

sub write_shutdown {
	my $self = shift;

	setlogsock("native")
	    or die ref($self), " setlogsock native failed: $!";
	syslog(LOG_NOTICE, $downlog);
}

sub write_lines {
	my $self = shift;
	my ($lines, $lenght) = @@_;

	foreach (1..$lines) {
		write_chars($self, $lenght, " $_");
	}
}

sub write_lengths {
	my $self = shift;
	my ($lenghts, $tail) = ref $_[0] ? @@_ : [@@_];

	write_chars($self, $lenghts, $tail);
}

sub generate_chars {
	my ($len) = @@_;

	my $msg = "";
	my $char = '0';
	for (my $i = 0; $i < $len; $i++) {
		$msg .= $char;
		given ($char) {
			when(/9/)       { $char = 'A' }
			when(/Z/)       { $char = 'a' }
			when(/z/)       { $char = '0' }
			default         { $char++ }
		}
	}
	return $msg;
}

sub write_chars {
	my $self = shift;
	my ($length, $tail) = @@_;

	foreach my $len (ref $length ? @@$length : $length) {
		my $t = $tail // "";
		substr($t, 0, length($t) - $len, "")
		    if length($t) && length($t) > $len;
		my $msg = generate_chars($len - length($t));
		$msg .= $t if length($t);
		write_message($self, $msg);
		# if client is sending too fast, syslogd will not see everything
		sleep .01;
	}
}

sub write_unix {
	my $self = shift;
	my $path = shift || "/dev/log";
	my $id = shift // $path;

	my $u = IO::Socket::UNIX->new(
	    Type  => SOCK_DGRAM,
	    Peer => $path,
	) or die ref($self), " connect to $path unix socket failed: $!";
	my $msg = "id $id unix socket: $testlog";
	print $u $msg;
	print STDERR "<<< $msg\n";
}

sub write_tcp {
	my $self = shift;
	my $fh = shift || \*STDOUT;
	my $id = shift // $fh;

	my $msg = "id $id tcp socket: $testlog";
	print $fh "$msg\n";
	print STDERR "<<< $msg\n";
}

sub redo_connect {
	my $self = shift;
	my $func = shift;

	$func->($self, @@_);
	if ($self->{cs}) {
		# wait for possible icmp errors, port is open
		sleep .1;
		close(delete $self->{cs})
		    or die ref($self), " close failed: $!";
	}
	if (my $redo = shift @@{$self->{redo}}) {
		if (my $connect = $redo->{connect}) {
			delete $self->{logsock};
			$self->{connectdomain} = $connect->{domain};
			$self->{connectaddr}   = $connect->{addr};
			$self->{connectproto}  = $connect->{proto};
			$self->{connectport}   = $connect->{port};
		} elsif (my $logsock = $redo->{logsock}) {
			delete $self->{connectdomain};
			delete $self->{connectaddr};
			delete $self->{connectproto};
			delete $self->{connectport};
			$self->{logsock} = $logsock;
		} else {
			die ref($self), " no connect or logsock in redo";
		}
	} else {
		delete $self->{connectdomain};
		delete $self->{connectaddr};
		delete $self->{connectproto};
		delete $self->{connectport};
		$self->{logsock} = { type => "native" };
		setlogsock($self->{logsock})
		    or die ref($self), " setlogsock failed: $!";
		sleep .1;
		write_log($self);
		undef $self->{redo};
	}
}

########################################################################
# Server funcs
########################################################################

sub read_log {
	my $self = shift;

	read_message($self, $downlog);
}

sub read_between2logs {
	my $self = shift;
	my $func = shift;

	read_message($self, $firstlog);
	$func->($self, @@_);
	read_message($self, $testlog);
	read_message($self, $downlog);
}

sub accept_between2logs {
	my $self = shift;
	my $func = shift;

	unless ($self->{redo}) {
		read_message($self, $firstlog);
		$func->($self, @@_);
		$self->{redo} = 1;
	} else {
		$self->{redo} = 0;
		read_message($self, $testlog);
		read_message($self, $downlog);
	}
}

sub read_message {
	my $self = shift;
	my $regex = shift;

	local $_;
	for (;;) {
		if ($self->{listenproto} eq "udp") {
			# reading UDP packets works only with sysread()
			defined(my $n = sysread(STDIN, $_, 8194))
			    or die ref($self), " read log line failed: $!";
			last if $n == 0;
		} else {
			defined($_ = <STDIN>)
			    or last;
		}
		chomp;
		print STDERR ">>> $_\n";
		last if /$regex/;
	}
}

########################################################################
# Script funcs
########################################################################

sub get_testlog {
	return $testlog;
}

sub get_testgrep {
	return qr/$testlog\r*$/;
}

sub get_firstlog {
	return $firstlog;
}

sub get_secondlog {
	return $secondlog;
}

sub get_thirdlog {
	return $thirdlog;
}

sub get_charlog {
	# add a space so that we match at the beginning of the message
	return " $charlog";
}

sub get_between2loggrep {
	return (
	    qr/$firstlog/ => 1,
	    qr/$testlog/ => 1,
	);
}

sub get_downlog {
	return $downlog;
}

sub selector2config {
    my %s2m = @@_;
    my $conf = "";
    my $i = 0;
    foreach my $sel (sort keys %s2m) {
	$conf .= "$sel\t\$objdir/file-$i.log\n";
	$i++;
    }
    return $conf;
}

sub selector2loggrep {
    my %s2m = @@_;
    my %allmsg;
    @@allmsg{map { @@$_} values %s2m} = ();
    my @@loggrep;
    foreach my $sel (sort keys %s2m) {
	my @@m = @@{$s2m{$sel}};
	my %msg;
	$msg{$_}++ foreach (@@m);
	my %nomsg = %allmsg;
	delete @@nomsg{@@m};
	push @@loggrep, {
	    (map { qr/: $_$/ => $msg{$_} } sort keys %msg),
	    (map { qr/: $_$/ => 0 } sort keys %nomsg),
	};
    }
    return @@loggrep;
}

sub check_logs {
	my ($c, $r, $s, $m, %args) = @@_;

	return if $args{nocheck};

	check_log($c, $r, $s, @@$m);
	check_out($r, %args);
	check_fstat($c, $r, $s);
	check_ktrace($c, $r, $s);
	if (my $file = $s->{"outfile"}) {
		my $pattern = $s->{filegrep} || get_testgrep();
		check_pattern(ref $s, $file, $pattern, \&filegrep);
	}
	check_multifile(@@{$args{multifile} || []});
}

sub compare($$) {
	local $_ = $_[1];
	if (/^\d+/) {
		return $_[0] == $_;
	} elsif (/^==(\d+)/) {
		return $_[0] == $1;
	} elsif (/^!=(\d+)/) {
		return $_[0] != $1;
	} elsif (/^>=(\d+)/) {
		return $_[0] >= $1;
	} elsif (/^<=(\d+)/) {
		return $_[0] <= $1;
	} elsif (/^~(\d+)/) {
		return $1 * 0.8 <= $_[0] && $_[0] <= $1 * 1.2;
	}
	die "bad compare operator: $_";
}

sub check_pattern {
	my ($name, $proc, $pattern, $func) = @@_;

	$pattern = [ $pattern ] unless ref($pattern) eq 'ARRAY';
	foreach my $pat (@@$pattern) {
		if (ref($pat) eq 'HASH') {
			foreach my $re (sort keys %$pat) {
				my $num = $pat->{$re};
				my @@matches = $func->($proc, $re);
				compare(@@matches, $num)
				    or die "$name matches '@@matches': ",
				    "'$re' => $num";
			}
		} else {
			$func->($proc, $pat)
			    or die "$name log missing pattern: $pat";
		}
	}
}

sub check_log {
	foreach my $proc (@@_) {
		next unless $proc && !$proc->{nocheck};
		my $pattern = $proc->{loggrep} || get_testgrep();
		check_pattern(ref $proc, $proc, $pattern, \&loggrep);
	}
}

sub loggrep {
	my ($proc, $pattern) = @@_;

	return $proc->loggrep($pattern);
}

sub check_out {
	my ($r, %args) = @@_;

	unless ($args{pipe}{nocheck}) {
		$r->loggrep("bytes transferred", 1) or sleep 1;
	}
	foreach my $dev (qw(console user)) {
		$args{$dev}{nocheck} ||= $args{tty}{nocheck};
		$args{$dev}{loggrep} ||= $args{tty}{loggrep};
		next if $args{$dev}{nocheck};
		my $ctl = $r->{"ctl$dev"};
		close($ctl);
		my $file = $r->{"out$dev"};
		open(my $fh, '<', $file)
		    or die "Open file $file for reading failed: $!";
		grep { /^logout/ or /^console .* off/ } <$fh> or sleep 1;
		close($fh);
	}

	foreach my $name (qw(file pipe console user)) {
		next if $args{$name}{nocheck};
		my $file = $r->{"out$name"} or die;
		my $pattern = $args{$name}{loggrep} || get_testgrep();
		check_pattern($name, $file, $pattern, \&filegrep);
	}
}

sub check_fstat {
	foreach my $proc (@@_) {
		my $pattern = $proc && $proc->{fstat} or next;
		my $file = $proc->{fstatfile} or die;
		check_pattern("fstat", $file, $pattern, \&filegrep);
	}
}

sub filegrep {
	my ($file, $pattern) = @@_;

	open(my $fh, '<', $file)
	    or die "Open file $file for reading failed: $!";
	return wantarray ?
	    grep { /$pattern/ } <$fh> : first { /$pattern/ } <$fh>;
}

sub check_ktrace {
	foreach my $proc (@@_) {
		my $pattern = $proc && $proc->{ktrace} or next;
		my $file = $proc->{ktracefile} or die;
		check_pattern("ktrace", $file, $pattern, \&kdumpgrep);
	}
}

sub kdumpgrep {
	my ($file, $pattern) = @@_;

	my @@sudo = ! -r $file && $ENV{SUDO} ? $ENV{SUDO} : ();
	my @@cmd = (@@sudo, "kdump", "-f", $file);
	open(my $fh, '-|', @@cmd)
	    or die "Open pipe from '@@cmd' failed: $!";
	my @@matches = grep { /$pattern/ } <$fh>;
	close($fh) or die $! ?
	    "Close pipe from '@@cmd' failed: $!" :
	    "Command '@@cmd' failed: $?";
	return wantarray ? @@matches : $matches[0];
}

sub create_multifile {
	for (my $i = 0; $i < @@_; $i++) {
		my $file = "file-$i.log";
		open(my $fh, '>', $file)
		    or die "Create $file failed: $!";
	}
}

sub check_multifile {
	for (my $i = 0; $i < @@_; $i++) {
		my $file = "file-$i.log";
		my $pattern = $_[$i]{loggrep} or die;
		check_pattern("multifile $i", $file, $pattern, \&filegrep);
	}
}

1;
@


1.32
log
@Adapt test to new syslogd's local message priority.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.31 2017/04/06 16:56:44 bluhm Exp $
d196 41
d251 10
d263 4
a266 3
	}
	$func->($self, @@_);
	unless ($self->{redo}) {
@


1.31
log
@Check that local syslog messages have the the expected priority.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.30 2016/03/21 23:23:15 bluhm Exp $
d300 1
a300 1
	@@msg{@@m} = ();
d304 1
a304 1
	    (map { qr/: $_$/ => 1 } sort keys %msg),
@


1.30
log
@System call sendsyslog2 is gone, adapt tests.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.29 2015/12/30 13:15:52 bluhm Exp $
d279 30
@


1.29
log
@Test logging to console by redirecting the system's console into a
file.  All subtests get an additional /dev/console entry in
syslog.conf, then check that messages appear in the console file.
Add a test that stops syslogd, calls sendsyslog2() with LOG_CONS
and checks that the message appears in the console file.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.28 2015/12/04 13:49:42 bluhm Exp $
d89 3
a91 8
			if (($self->{connect}{version} || 0) == 2) {
				my $flags = $self->{connect}{flags} || 0;
				sendsyslog2($msg, $flags) or die ref($self),
				    " sendsyslog2 failed: $!";
			} else {
				sendsyslog($msg) or die ref($self),
				    " sendsyslog failed: $!";
			}
a109 6
	require 'sys/syscall.ph';
	return syscall(&SYS_sendsyslog, $msg, length($msg)) != -1;
}

sub sendsyslog2 {
	my $msg = shift;
d112 1
a112 1
	return syscall(&SYS_sendsyslog2, $msg, length($msg), $flags) != -1;
@


1.28
log
@Add tests that call the syscalls sendsyslog(2) and sendsyslog2(2)
directly.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.27 2015/10/23 14:06:55 bluhm Exp $
d366 10
a375 4
	unless ($args{tty}{nocheck}) {
		open(my $fh, '<', $r->{outtty})
		    or die "Open file $r->{outtty} for reading failed: $!";
		grep { qr/^logout/ } <$fh> or sleep 1;
d379 1
a379 1
	foreach my $name (qw(file pipe tty)) {
@


1.27
log
@Check that syslogd delays a blocking write to tty and that that all
messages still appear on the tty.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.26 2015/10/19 20:16:09 bluhm Exp $
d89 8
a96 2
			sendsyslog($msg)
			    or die ref($self), " sendsyslog failed: $!";
d117 7
@


1.26
log
@Test syslogd logging to a tty which belongs to a user.  This is
done with a utmp entry for a pty fake login.  All messages are read
from the pty and written into a log file.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.25 2015/10/09 17:07:06 bluhm Exp $
d352 6
@


1.25
log
@Add tests for syslogd TLS accept and receive encrypted messages.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.24 2015/09/09 08:48:46 bluhm Exp $
d248 1
a248 1
	return qr/$testlog$/;
d354 1
a354 1
	foreach my $name (qw(file pipe)) {
@


1.24
log
@Test that syslogd can process 8 full size messages from sendsyslog(2)
or UDP socket or UNIX domain socket at once.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.23 2015/07/19 20:18:18 bluhm Exp $
d99 1
a99 1
			print "\n" if $self->{connectproto} eq "tcp";
@


1.23
log
@Test octet counting and non transparent framing.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.22 2015/07/16 16:34:49 bluhm Exp $
d88 4
a91 1
		if ($self->{connectproto} eq "udp") {
d105 6
@


1.22
log
@Test that syslogd does not append white spaces to messages.  Per
default the test pattern is stricter now.  Also do some test cleanup
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.21 2015/07/07 18:03:11 bluhm Exp $
d170 1
a170 1
	my $msg = "$id unix socket: $testlog";
d180 1
a180 1
	my $msg = "$id tcp socket: $testlog";
@


1.21
log
@Add tests for incomming syslog messages over TCP.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.20 2015/06/28 18:52:11 bluhm Exp $
d164 1
d170 1
a170 1
	my $msg = get_testlog(). " $path unix socket";
d175 10
d238 4
d280 1
a280 1
		my $pattern = $s->{filegrep} || $testlog;
d327 1
a327 1
		my $pattern = $proc->{loggrep} || $testlog;
d348 1
a348 1
		my $pattern = $args{$name}{loggrep} || $testlog;
@


1.20
log
@Add tests for the !prog and !!prog and !* keywords in syslog.conf.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.19 2015/06/15 21:44:57 bluhm Exp $
d66 2
d78 2
d87 1
d89 1
a89 2
			# writing udp packets works only with syswrite()
			my $msg = join("", @@_);
a93 1
			print STDERR $msg, "\n";
d95 2
a96 2
			print @@_;
			print STDERR @@_, "\n";
d98 1
d128 17
d153 1
a153 11
		my $msg = "";
		my $char = '0';
		for (my $i = 0; $i < $len - length($t); $i++) {
			$msg .= $char;
			given ($char) {
				when(/9/)       { $char = 'A' }
				when(/Z/)       { $char = 'a' }
				when(/z/)       { $char = '0' }
				default         { $char++ }
			}
		}
d171 1
a171 1
	print STDERR $msg, "\n";
d205 1
a205 1
			# reading udp packets works only with sysread()
@


1.19
log
@Rework how fstat and ktrace pattern are specified in the test
arguments.  Add tests to check wether syslogd privsep works.  This
is done for debug and foreground and daemon mode.  Fstat is checked
for chroot and sockets.  Ktrace dump is grepped for setting uid and
gid.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.18 2015/02/12 23:16:02 bluhm Exp $
d257 1
d364 16
@


1.18
log
@Make syslogd tests more reliable.  Increase the allowed range of
lost log messages.  Improve the synchronisation of client and server.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.17 2015/02/11 21:51:13 bluhm Exp $
d251 2
a252 2
	check_stat($r, %args);
	check_kdump($c, $r, $s);
d326 5
a330 8
sub check_stat {
	my ($r, %args) = @@_;

	foreach my $name (qw(fstat)) {
		next unless $r && $r->{$name};
		my $file = $r->{"${name}file"} or die;
		my $pattern = $args{$name}{loggrep} or die;
		check_pattern($name, $file, $pattern, \&filegrep);
d343 1
a343 1
sub check_kdump {
d345 1
a345 1
		next unless $proc && $proc->{ktrace};
d347 1
a347 2
		my $pattern = $proc->{kdump} or die;
		check_pattern(ref $proc, $file, $pattern, \&kdumpgrep);
@


1.17
log
@Make syslogd tests more reliable.  Allow a range of certain log
messages, in case some got lost.  Slow down client when sending
multiple log messages.  Sort patterns when checking log files.  TLS
error messages have changed, adapt tests.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.16 2015/02/11 17:28:42 bluhm Exp $
d272 1
a272 1
		return $1 * 0.9 <= $_[0] && $_[0] <= $1 * 1.1;
@


1.16
log
@Make syslogd test more reliable.  Use Time::HiRes to sleep .01
seconds in the write_lines() loop.  This slows down the client, so
all messages reach syslogd and flood its buffers.  Increase the
timeout to wait until all buffers are full.  Use this code in all
TCP/TLS buffer and memory overflow tests.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.15 2015/02/08 15:24:14 bluhm Exp $
a113 2
		# if client is sending too fast, syslogd will not see everything
		sleep .01;
d117 7
d126 1
a126 2
	my @@lenghts = shift || @@{$self->{lengths}};
	my $tail = shift // $self->{tail};
d128 1
a128 1
	foreach my $len (@@lenghts) {
d145 2
a149 6
sub write_length {
	my $self = shift;
	write_chars($self, @@_);
	write_log($self);
}

d271 2
d283 2
a284 1
			while (my($re, $num) = each %$pat) {
@


1.15
log
@Change syslog tests from transparent framing to octet counting.
Add tests for truncated buffer handling.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.14 2015/02/06 00:27:41 bluhm Exp $
d26 1
@


1.14
log
@Add syslogd tests for dropped messages.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.13 2015/02/02 17:40:24 bluhm Exp $
d107 1
a107 1
sub write_char {
d109 12
a120 1
	my @@lenghts = @@{shift || $self->{lengths}};
d145 1
a145 1
	write_char($self, @@_);
d228 2
a229 1
	return $charlog;
@


1.13
log
@Test that long syslog messages are truncated correctly.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.12 2015/01/22 00:34:32 bluhm Exp $
d30 2
d34 1
d65 1
a65 1
	write_shutdown($self, @@_);
d75 1
a75 1
	write_shutdown($self, @@_);
d109 2
a110 1
	my @@lenghts = @@_ || @@{$self->{lengths}};
d113 3
a115 3
		my $tail = $self->{tail} // "";
		substr($tail, 0, length($tail) - $len, "")
		    if length($tail) && length($tail) > $len;
d118 1
a118 1
		for (my $i = 0; $i < $len - length($tail); $i++) {
d127 1
a127 1
		$msg .= $tail if length($tail);
d133 3
a135 2
	write_char(@@_);
	write_log(@@_);
d158 1
a158 1
	read_message($self, $downlog, @@_);
d166 1
a166 1
		read_message($self, $firstlog, @@_);
d170 2
a171 2
		read_message($self, $testlog, @@_);
		read_message($self, $downlog, @@_);
d202 16
@


1.12
log
@Make syslogd tests more reliable on slow machines.  All tests pass
on my old sparc64.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.11 2015/01/16 11:51:59 bluhm Exp $
d19 2
d79 12
a90 2
		print @@_;
		print STDERR @@_, "\n";
d102 29
@


1.11
log
@Add regression tests for syslog over TLS.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.10 2015/01/15 13:15:17 bluhm Exp $
d235 4
@


1.10
log
@Add a test for syslogd that reconnects to a TCP syslog server after
an established connection has been closed.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.9 2015/01/01 19:58:48 bluhm Exp $
d37 1
@


1.9
log
@Test that syslogd sending over TCP does not leak a file descriptor
when it receives a SIGHUP.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.8 2014/12/28 14:08:01 bluhm Exp $
d134 9
a142 4
		# reading udp packets works only with sysread()
		defined(my $n = sysread(STDIN, $_, 8194))
		    or die ref($self), " read log line failed: $!";
		last if $n == 0;
@


1.8
log
@Add regression tests where OpenBSD syslogd is sending messages to
rsyslogd from ports.  If the rsyslog package is installed, rsyslogd
is used as drain to test interoperability.  This will be especially
useful for syslog via TCP and TLS.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.7 2014/09/13 23:38:24 bluhm Exp $
d3 1
a3 1
# Copyright (c) 2010-2014 Alexander Bluhm <bluhm@@openbsd.org>
d118 3
a120 1
	read_message($self, $firstlog, @@_);
d122 4
a125 2
	read_message($self, $testlog, @@_);
	read_message($self, $downlog, @@_);
d135 1
a135 1
		defined(sysread(STDIN, $_, 8194))
d137 1
@


1.7
log
@Add tests for syslogd's memory buffer and read it with syslogc.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.6 2014/09/03 15:56:07 bluhm Exp $
d31 20
d167 4
@


1.6
log
@Add tests that send log messages via unix domain sockets to syslogd.
Also check that the maximum number of -a path is handled correctly.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.5 2014/09/02 17:43:29 bluhm Exp $
d79 1
a79 1
	my $msg = get_log(). " $path unix socket";
d123 1
a123 1
sub get_log {
d134 4
d139 1
a139 1
	my ($c, $r, $s, %args) = @@_;
d143 1
a143 1
	check_log($c, $r, $s, %args);
d146 1
a146 1
	check_kdump($c, $r, $s, %args);
d185 4
a188 8
	my ($c, $r, $s, %args) = @@_;

	my %name2proc = (client => $c, syslogd => $r, server => $s);
	foreach my $name (qw(client syslogd server)) {
		next if $args{$name}{nocheck};
		my $p = $name2proc{$name} or next;
		my $pattern = $args{$name}{loggrep} || $testlog;
		check_pattern($name, $p, $pattern, \&loggrep);
d203 1
a203 1
		my $file = $r->{"out$name"} or next;
d213 3
a215 3
		next if $args{$name}{nocheck};
		my $file = $r->{$name} && $r->{"${name}file"} or next;
		my $pattern = $args{$name}{loggrep} or next;
d230 5
a234 9
	my ($c, $r, $s, %args) = @@_;

	my %name2proc = (client => $c, syslogd => $r, server => $s);
	foreach my $name (qw(client syslogd server)) {
		next unless $args{$name}{ktrace};
		my $p = $name2proc{$name} or next;
		my $file = $p->{ktracefile} or next;
		my $pattern = $args{$name}{kdump} or next;
		check_pattern($name, $file, $pattern, \&kdumpgrep);
@


1.5
log
@To examine the operation of the signal handlers, the tests grep in
the ktrace output of syslogd.  Also make the tests work without DNS
and without sudo.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.4 2014/09/02 00:26:30 bluhm Exp $
d69 13
@


1.4
log
@Add tests that run the syslogd signal handlers.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.3 2014/08/29 21:57:17 bluhm Exp $
d129 1
a129 1
	check_kdump($c, $s, %args);
d217 1
a217 1
	my ($c, $s, %args) = @@_;
d219 2
a220 2
	my %name2proc = (client => $c, server => $s);
	foreach my $name (qw(client server)) {
d232 2
a233 1
	my @@cmd = ("kdump", "-f", $file);
@


1.3
log
@Make the syslogd regression tests more reliable.  Other processes
on the system may create log entries during the test run that show
up in the log file.  Ignore those additional lines.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.2 2014/08/25 17:55:27 bluhm Exp $
d27 1
d38 17
d56 2
a57 2
		print $testlog;
		print STDERR $testlog, "\n";
d59 1
a59 1
		syslog(LOG_INFO, $testlog);
a60 1
	write_shutdown($self, @@_);
d78 18
d97 2
a98 1
		defined(sysread(STDIN, my $line, 8194))
d100 3
a102 3
		chomp $line;
		print STDERR ">>> $line\n";
		last if $line =~ /$downlog/;
d112 7
@


1.2
log
@Add tests for syslogd sending and receiving over IPv6 sockets.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.1.1.1 2014/08/20 20:52:14 bluhm Exp $
d89 16
d113 1
a113 1
				@@matches == $num
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#	$OpenBSD$
d37 1
a37 1
	if ($self->{connectdomain}) {
@


1.1.1.1
log
@Run syslogd regressions tests.  As only one syslogd can run per
machine, each test kills any syslogd first.  At the end the system's
syslogd gets restarted.
The test framework runs a client, and a server, and a syslogd.  The
messages are passed via the log socket or via UDP from the client
to syslogd.  From there UDP transport is used to reach the server.
All processes write log files where the message has to show up.
The test arguments are kept in the args-*.pl files.
The content of a log file, the data sent to a pipe process and what
the server received are checked.  The invocation of the sendsyslog(2)
syscall is checked with ktrace, the open file descriptors of syslogd
are checked with fstat.
@
text
@@
