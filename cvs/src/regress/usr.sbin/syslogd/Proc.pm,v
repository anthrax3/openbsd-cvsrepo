head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.4
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.6
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	bluhm_20140820:1.1.1.1
	bluhm:1.1.1;
locks; strict;
comment	@# @;


1.8
date	2016.05.03.19.13.04;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	QUorL89Z4jPT2RKR;

1.7
date	2015.07.09.21.12.44;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	AUvZQYxe8utgq9GX;

1.6
date	2015.02.13.21.40.50;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	tZ8vhc9XWQ8KWPvp;

1.5
date	2015.01.28.19.23.22;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	6n55AVIuWA7LUOak;

1.4
date	2015.01.01.19.58.48;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	2YTZ0i51684RZ6xu;

1.3
date	2014.09.13.23.38.24;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	8abA8sLPTwAOrtQB;

1.2
date	2014.09.02.00.26.30;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	9hOtCJWVU54mPrrd;

1.1
date	2014.08.20.20.52.14;	author bluhm;	state Exp;
branches
	1.1.1.1;
next	;
commitid	DUvdbfhw6s1btkKk;

1.1.1.1
date	2014.08.20.20.52.14;	author bluhm;	state Exp;
branches;
next	;
commitid	DUvdbfhw6s1btkKk;


desc
@@


1.8
log
@Fix some Perl statements perlcritic was bitching about: Variable
declared in conditional statement.
@
text
@#	$OpenBSD: Proc.pm,v 1.7 2015/07/09 21:12:44 bluhm Exp $

# Copyright (c) 2010-2015 Alexander Bluhm <bluhm@@openbsd.org>
# Copyright (c) 2014 Florian Riehm <mail@@friehm.de>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package Proc;
use BSD::Resource qw(getrlimit setrlimit get_rlimits);
use Carp;
use Errno;
use IO::File;
use POSIX;
use Time::HiRes qw(time alarm sleep);

my %CHILDREN;

sub kill_children {
	my @@pids = @@_ ? @@_ : keys %CHILDREN
	    or return;
	my @@perms;
	foreach my $pid (@@pids) {
		if (kill(TERM => $pid) != 1 and $!{EPERM}) {
			push @@perms, $pid;
		}
	}
	if (my $sudo = $ENV{SUDO} and @@perms) {
		local $?;  # do not modify during END block
		my @@cmd = ($sudo, '/bin/kill', '-TERM', @@perms);
		system(@@cmd);
	}
	delete @@CHILDREN{@@pids};
}

BEGIN {
	$SIG{TERM} = $SIG{INT} = sub {
		my $sig = shift;
		kill_children();
		$SIG{TERM} = $SIG{INT} = 'DEFAULT';
		POSIX::raise($sig);
	};
}

END {
	kill_children();
	$SIG{TERM} = $SIG{INT} = 'DEFAULT';
}

sub new {
	my $class = shift;
	my $self = { @@_ };
	$self->{down} ||= "Shutdown";
	$self->{func} && ref($self->{func}) eq 'CODE'
	    or croak "$class func not given";
	!$self->{ktrace} || $self->{ktracefile}
	    or croak "$class ktrace file not given";
	$self->{logfile}
	    or croak "$class log file not given";
	open(my $fh, '>', $self->{logfile})
	    or die "$class log file $self->{logfile} create failed: $!";
	$fh->autoflush;
	$self->{log} = $fh;
	$self->{ppid} = $$;
	return bless $self, $class;
}

sub run {
	my $self = shift;

	pipe(my $reader, my $writer)
	    or die ref($self), " pipe to child failed: $!";
	defined(my $pid = fork())
	    or die ref($self), " fork child failed: $!";
	if ($pid) {
		$CHILDREN{$pid} = 1;
		$self->{pid} = $pid;
		close($reader);
		$self->{pipe} = $writer;
		return $self;
	}
	%CHILDREN = ();
	$SIG{TERM} = $SIG{INT} = 'DEFAULT';
	$SIG{__DIE__} = sub {
		die @@_ if $^S;
		warn @@_;
		IO::Handle::flush(\*STDERR);
		POSIX::_exit(255);
	};
	open(STDERR, '>&', $self->{log})
	    or die ref($self), " dup STDERR failed: $!";
	open(STDOUT, '>&', $self->{log})
	    or die ref($self), " dup STDOUT failed: $!";
	close($writer);
	open(STDIN, '<&', $reader)
	    or die ref($self), " dup STDIN failed: $!";
	close($reader);

	if ($self->{rlimit}) {
		my $rlimits = get_rlimits()
		    or die ref($self), " get_rlimits failed: $!";
		while (my($name, $newsoft) = each %{$self->{rlimit}}) {
			defined(my $resource = $rlimits->{$name})
			    or die ref($self), " rlimit $name does not exists";
			my ($soft, $hard) = getrlimit($resource)
			    or die ref($self), " getrlimit $name failed: $!";
			setrlimit($resource, $newsoft, $hard) or die ref($self),
			    " setrlimit $name to $newsoft failed: $!";
		}
	}
	if ($self->{ktrace}) {
		my @@cmd = ("ktrace", "-f", $self->{ktracefile}, "-p", $$);
		system(@@cmd)
		    and die ref($self), " system '@@cmd' failed: $?";
	}
	do {
		$self->child();
		print STDERR $self->{up}, "\n";
		$self->{func}->($self);
	} while ($self->{redo});
	print STDERR "Shutdown", "\n";

	IO::Handle::flush(\*STDOUT);
	IO::Handle::flush(\*STDERR);
	POSIX::_exit(0);
}

sub wait {
	my $self = shift;
	my $flags = shift;

	# if we a not the parent process, assume the child is still running
	return 0 unless $self->{ppid} == $$;

	my $pid = $self->{pid}
	    or croak ref($self), " no child pid";
	my $kid = waitpid($pid, $flags);
	if ($kid > 0) {
		my $status = $?;
		my $code;
		$code = "exit: ".   WEXITSTATUS($?) if WIFEXITED($?);
		$code = "signal: ". WTERMSIG($?)    if WIFSIGNALED($?);
		$code = "stop: ".   WSTOPSIG($?)    if WIFSTOPPED($?);
		delete $CHILDREN{$pid} if WIFEXITED($?) || WIFSIGNALED($?);
		return wantarray ? ($kid, $status, $code) : $kid;
	}
	return $kid;
}

sub loggrep {
	my $self = shift;
	my($regex, $timeout, $count) = @@_;
	my $exit = ($self->{exit} // 0) << 8;

	my $end;
	$end = time() + $timeout if $timeout;

	do {
		my($kid, $status, $code) = $self->wait(WNOHANG);
		if ($kid > 0 && $status != $exit) {
			# child terminated with failure
			die ref($self), " child status: $status $code";
		}
		open(my $fh, '<', $self->{logfile})
		    or die ref($self), " log file open failed: $!";
		my @@match = grep { /$regex/ } <$fh>;
		return wantarray ? @@match : $match[0]
		    if !$count && @@match or $count && @@match >= $count;
		close($fh);
		# pattern not found
		if ($kid == 0) {
			# child still running, wait for log data
			sleep .1;
		} else {
			# child terminated, no new log data possible
			return;
		}
	} while ($timeout and time() < $end);

	return;
}

sub up {
	my $self = shift;
	my $timeout = shift || 10;
	$self->loggrep(qr/$self->{up}/, $timeout)
	    or croak ref($self), " no '$self->{up}' in $self->{logfile} ".
		"after $timeout seconds";
	return $self;
}

sub down {
	my $self = shift;
	my $timeout = shift || 60;
	$self->loggrep(qr/$self->{down}/, $timeout)
	    or croak ref($self), " no '$self->{down}' in $self->{logfile} ".
		"after $timeout seconds";
	return $self;
}

sub kill_child {
	my $self = shift;
	kill_children($self->{pid});
	return $self;
}

sub kill {
	my $self = shift;
	my $sig = shift // 'TERM';
	my $pid = shift // $self->{pid};

	if (kill($sig => $pid) != 1) {
		my $sudo = $ENV{SUDO};
		$sudo && $!{EPERM}
		    or die ref($self), " kill $pid failed: $!";
		my @@cmd = ($sudo, '/bin/kill', "-$sig", $pid);
		system(@@cmd)
		    and die ref($self), " sudo kill $pid failed: $?";
	}
	return $self;
}

1;
@


1.7
log
@Test syslogd with reduced file descriptor limit.  It has too many
log files in syslog.conf and must close and reopen them at SIGHUP.
@
text
@d1 1
a1 1
#	$OpenBSD: Proc.pm,v 1.6 2015/02/13 21:40:50 bluhm Exp $
d167 2
a168 1
	my $end = time() + $timeout if $timeout;
@


1.6
log
@Adapt the maxunix test, the syslogd -a error semantic has changed.
Increase timeouts and remove races, so that the syslogd tests pass
on my sparc64 machine.
@
text
@d1 1
a1 1
#	$OpenBSD: Proc.pm,v 1.5 2015/01/28 19:23:22 bluhm Exp $
d22 1
d111 12
@


1.5
log
@Test the x509 certificate validation of syslog over TLS.
@
text
@d1 1
a1 1
#	$OpenBSD: Proc.pm,v 1.4 2015/01/01 19:58:48 bluhm Exp $
d192 1
a192 1
	my $timeout = shift || 30;
@


1.4
log
@Test that syslogd sending over TCP does not leak a file descriptor
when it receives a SIGHUP.
@
text
@d1 1
a1 1
#	$OpenBSD: Proc.pm,v 1.3 2014/09/13 23:38:24 bluhm Exp $
d151 1
a151 1
	my($regex, $timeout) = @@_;
d165 2
a166 1
		return wantarray ? @@match : $match[0] if @@match;
@


1.3
log
@Add tests for syslogd's memory buffer and read it with syslogc.
@
text
@d1 1
a1 1
#	$OpenBSD: Proc.pm,v 1.2 2014/09/02 00:26:30 bluhm Exp $
d3 1
a3 1
# Copyright (c) 2010-2014 Alexander Bluhm <bluhm@@openbsd.org>
d115 5
a119 3
	$self->child();
	print STDERR $self->{up}, "\n";
	$self->{func}->($self);
@


1.2
log
@Add tests that run the syslogd signal handlers.
@
text
@d1 1
a1 1
#	$OpenBSD: Proc.pm,v 1.1.1.1 2014/08/20 20:52:14 bluhm Exp $
d150 1
d156 1
a156 1
		if ($kid > 0 && $status != 0) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#	$OpenBSD$
d75 1
d129 3
d198 16
@


1.1.1.1
log
@Run syslogd regressions tests.  As only one syslogd can run per
machine, each test kills any syslogd first.  At the end the system's
syslogd gets restarted.
The test framework runs a client, and a server, and a syslogd.  The
messages are passed via the log socket or via UDP from the client
to syslogd.  From there UDP transport is used to reach the server.
All processes write log files where the message has to show up.
The test arguments are kept in the args-*.pl files.
The content of a log file, the data sent to a pipe process and what
the server received are checked.  The invocation of the sendsyslog(2)
syscall is checked with ktrace, the open file descriptors of syslogd
are checked with fstat.
@
text
@@
