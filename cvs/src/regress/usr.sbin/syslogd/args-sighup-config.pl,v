head	1.7;
access;
symbols
	OPENBSD_6_0:1.6.0.6
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5;
locks; strict;
comment	@# @;


1.7
date	2016.10.06.13.06.14;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	SvZFLcp8z1QgdkQR;

1.6
date	2015.06.15.21.44.57;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	BmPbwQg6idYgxXrC;

1.5
date	2015.02.06.00.27.41;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	8et2usx9CGyR7b0D;

1.4
date	2015.01.28.19.23.22;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	6n55AVIuWA7LUOak;

1.3
date	2014.12.31.14.05.26;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	aJ48QDLYN7gznT6d;

1.2
date	2014.09.02.17.43.29;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	uB2qKOs5zbFwXm2E;

1.1
date	2014.09.02.00.26.30;	author bluhm;	state Exp;
branches;
next	;
commitid	9hOtCJWVU54mPrrd;


desc
@@


1.7
log
@Check that syslogd priv process does exec on itself.
@
text
@# The client writes a message to Sys::Syslog native method.
# The syslogd writes it into a file and through a pipe.
# The syslogd passes it via UDP to the loghost.
# The server receives the message on its UDP socket.
# Find the message in client, file, pipe, syslogd, server log.
# Check that a modified config file restarts syslogd child.

use strict;
use warnings;

our %args = (
    client => {
	func => sub { write_between2logs(shift, sub {
	    my $self = shift;
	    ${$self->{server}}->loggrep("Signal", 8)
		or die ref($self), " no 'Signal' between logs";
	})},
	loggrep => { get_between2loggrep() },
    },
    syslogd => {
	ktrace => {
	    qr/syslogd  PSIG  SIGHUP caught handler/ => 1,
	    qr/syslogd  RET   execve 0/ => 4,
	},
	loggrep => {
	    qr/config file modified: restarting/ => 1,
	    qr/config file changed: dying/ => 1,
	    qr/syslogd: restarted/ => 0,
	    get_between2loggrep(),
	},
    },
    server => {
	func => sub { read_between2logs(shift, sub {
	    my $self = shift;
	    my $conffile = ${$self->{syslogd}}->{conffile};
	    open(my $fh, '>>', $conffile)
		or die ref($self), " append conf file $conffile failed: $!";
	    print $fh "# modified\n";
	    close($fh);
	    ${$self->{syslogd}}->kill_syslogd('HUP');
	    ${$self->{syslogd}}->loggrep("syslogd: started", 5, 2)
		or die ref($self), " no 'syslogd: started' between logs";
	    print STDERR "Signal\n";
	})},
	loggrep => { get_between2loggrep() },
    },
);

1;
@


1.6
log
@Rework how fstat and ktrace pattern are specified in the test
arguments.  Add tests to check wether syslogd privsep works.  This
is done for debug and foreground and daemon mode.  Fstat is checked
for chroot and sockets.  Ktrace dump is grepped for setting uid and
gid.
@
text
@d23 1
a23 1
	    qr/syslogd  RET   execve 0/ => 2,
@


1.5
log
@Add syslogd tests for dropped messages.
@
text
@d21 1
a21 2
	ktrace => 1,
	kdump => {
@


1.4
log
@Test the x509 certificate validation of syslog over TLS.
@
text
@d13 1
a13 1
	func => sub {
d15 3
a17 5
	    write_between2logs($self, sub {
		${$self->{server}}->loggrep("Signal", 8)
		    or die ref($self), " no 'Signal' between logs";
	    });
	},
d34 1
a34 1
	func => sub {
d36 10
a45 12
	    read_between2logs($self, sub {
		my $conffile = ${$self->{syslogd}}->{conffile};
		open(my $fh, '>>', $conffile)
		    or die ref($self), " append conf file $conffile failed: $!";
		print $fh "# modified\n";
		close($fh);
		${$self->{syslogd}}->kill_syslogd('HUP');
		${$self->{syslogd}}->loggrep("syslogd: started", 5, 2)
		    or die ref($self), " no 'syslogd: started' between logs";
		print STDERR "Signal\n";
	    });
	},
@


1.3
log
@Adapt and add regression tests for sending syslog messages over TCP.
@
text
@d45 1
a45 1
		${$self->{syslogd}}->loggrep("syslogd: started", 5)
@


1.2
log
@To examine the operation of the signal handlers, the tests grep in
the ktrace output of syslogd.  Also make the tests work without DNS
and without sudo.
@
text
@d33 1
a33 1
	}
@


1.1
log
@Add tests that run the syslogd signal handlers.
@
text
@d23 5
a50 9
    },
    check => sub {
	my $self = shift;
	my $r = $self->{syslogd};
	foreach my $name (qw(file pipe)) {
		my $file = $r->{"out$name"}.".0";
		my $pattern = (get_between2loggrep())[0];
		check_pattern($name, $file, $pattern, \&filegrep);
	}
@

