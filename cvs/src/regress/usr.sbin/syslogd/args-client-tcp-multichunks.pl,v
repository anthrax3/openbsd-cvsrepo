head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.6
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4;
locks; strict;
comment	@# @;


1.4
date	2015.08.01.14.55.58;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	mKDhz3mFTSL2PZNi;

1.3
date	2015.07.19.20.18.18;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	3V6wL7hT2XianIlr;

1.2
date	2015.07.16.16.34.49;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	0M9ba2ikkjyPND6j;

1.1
date	2015.07.07.18.03.11;	author bluhm;	state Exp;
branches;
next	;
commitid	qTzx3B33iQFlT4Uv;


desc
@@


1.4
log
@Use Socket to make Perl syntax check of single test files pass.
@
text
@# The syslogd listens on 127.0.0.1 TCP socket.
# The client writes a message into a 127.0.0.1 TCP socket in multiple chunks.
# The syslogd writes it into a file and through a pipe.
# The syslogd passes it via UDP to the loghost.
# The server receives the message on its UDP socket.
# Find the message in file, pipe, syslogd, server log.
# Check that the file log contains the complete message.

use strict;
use warnings;
use Socket;

my $msglen = length(get_testlog());
my $framelen = $msglen + 1;

our %args = (
    client => {
	connect => { domain => AF_INET, proto => "tcp", addr => "127.0.0.1",
	    port => 514 },
	func => sub {
	    my $self = shift;
	    local $| = 1;
	    my $n = 0;
	    foreach (get_testlog() =~ /.{1,5}/g) {
		$n += length;
		print;
		print STDERR "<<< $_\n";
		${$self->{syslogd}}->loggrep("tcp logger .* buffer $n bytes", 5)
		    or die ref($self), " syslogd did not buffer $n bytes";
	    }
	    $n++;
	    print "\n";
	    ${$self->{syslogd}}->loggrep("tcp logger .* use $n bytes", 5)
		or die ref($self), " syslogd did not use $n bytes";
	    write_shutdown($self);
	},
	loggrep => {},
    },
    syslogd => {
	options => ["-T", "127.0.0.1:514"],
	loggrep => {
	    qr/tcp logger .* buffer \d+ bytes/ => int(($msglen+4)/5),
	    qr/tcp logger .* non transparent framing, use $framelen bytes/ => 1,
	    get_testgrep() => 1,
	},
    },
);

1;
@


1.3
log
@Test octet counting and non transparent framing.
@
text
@d11 1
@


1.2
log
@Test that syslogd does not append white spaces to messages.  Per
default the test pattern is stricter now.  Also do some test cleanup
@
text
@d12 3
d28 1
a28 1
		    or die ref($self), " syslogd did not receive $n bytes";
d30 1
d32 2
a33 2
	    ${$self->{syslogd}}->loggrep("tcp logger .* complete line", 5)
		or die ref($self), " syslogd did not receive complete line";
d41 2
a42 3
	    qr/tcp logger .* buffer \d+ bytes/ =>
		int((length(get_testlog())+4)/5),
	    qr/tcp logger .* complete line/ => 1,
@


1.1
log
@Add tests for incomming syslog messages over TCP.
@
text
@d40 1
a40 1
	    get_testlog() => 1,
@

