head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.4
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.5.0.8
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.4
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.3.0.4
	OPENBSD_5_8_BASE:1.3;
locks; strict;
comment	@# @;


1.7
date	2017.09.17.23.56.03;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	WAIGPtOcGxhQt5cY;

1.6
date	2017.09.12.15.24.21;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	fQcw2c9T4xGELf8r;

1.5
date	2015.12.30.13.15.52;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	A5ZwhsoQcJtCsd2c;

1.4
date	2015.10.19.20.16.09;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	kVDnyxLzqDFKPFoO;

1.3
date	2015.07.20.05.34.16;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	z0hAhY1IWpp7tf4t;

1.2
date	2015.07.16.16.34.49;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	0M9ba2ikkjyPND6j;

1.1
date	2015.07.09.21.12.44;	author bluhm;	state Exp;
branches;
next	;
commitid	AUvZQYxe8utgq9GX;


desc
@@


1.7
log
@If file descriptors are exhausted during initialization, we see
better log messages on the console now.
@
text
@# The syslogd is started with reduced file descriptor limits.
# The syslogd config is reread after SIGHUP.
# The client writes a message to Sys::Syslog native method.
# The syslogd writes it into a file and through a pipe.
# The syslogd passes it via UDP to the loghost.
# The server receives the message on its UDP socket.
# Find the message in client, file, pipe, syslogd, server log.
# Check the error messages and multiple log file content.

use strict;
use warnings;

our %args = (
    client => {
	func => sub { write_between2logs(shift, sub {
	    my $self = shift;
	    ${$self->{server}}->loggrep("Signal", 8)
		or die ref($self), " no 'Signal' between logs";
	})},
	loggrep => { get_between2loggrep() },
    },
    syslogd => {
	options => ["-u"],
	conf => join("", map { "*.*\t\$objdir/file-$_.log\n" } 0..19),
	rlimit => {
	    RLIMIT_NOFILE => 30,
	},
	loggrep => {
	    # If not in startup, each failed PRIV_OPEN_LOG is logged
	    # to tty, so PRIV_OPEN_TTY fails again.
	    qr/syslogd: receive_fd: recvmsg: Message too long/ => '>='.(4+2*4),
	    # During first initialization the lockpipe is open.  When
	    # SIGHUP happens it is closed and one more file can be opened.
	    qr/X FILE:/ => 1+14+1+15,
	    qr/X UNUSED:/ => 6+5,
	},
    },
    server => {
	func => sub { read_between2logs(shift, sub {
	    my $self = shift;
	    ${$self->{syslogd}}->kill_syslogd('HUP');
	    ${$self->{syslogd}}->loggrep("syslogd: restarted", 5)
		or die ref($self), " no 'syslogd: restarted' between logs";
	    print STDERR "Signal\n";
	})},
	loggrep => {
	    get_between2loggrep(),
	    qr/Signal/ => 1,
	    qr/Accepted/ => 1,
	},
    },
    multifile => [
	(map { { loggrep => get_testgrep() } } 0..14),
	(map { { loggrep => { qr/./s => 0 } } } 15..19),
    ],
    user => {
	loggrep => {
	    get_firstlog() => 1,
	    get_testlog() => 0,
	}
    },
);

1;
@


1.6
log
@Syslogd does no longer keep the *:514 UDP sockets open by default.
Adapt tests.
@
text
@d31 1
a31 1
	    qr/syslogd: receive_fd: recvmsg: Message too long/ => '>='.(4+2*3),
d34 2
a35 2
	    qr/X FILE:/ => 1+15+1+16,
	    qr/X UNUSED:/ => 5+4,
d53 2
a54 2
	(map { { loggrep => get_testgrep() } } 0..15),
	(map { { loggrep => { qr/./s => 0 } } } 16..19),
@


1.5
log
@Test logging to console by redirecting the system's console into a
file.  All subtests get an additional /dev/console entry in
syslog.conf, then check that messages appear in the console file.
Add a test that stops syslogd, calls sendsyslog2() with LOG_CONS
and checks that the message appears in the console file.
@
text
@d23 1
@


1.4
log
@Test syslogd logging to a tty which belongs to a user.  This is
done with a utmp entry for a pty fake login.  All messages are read
from the pty and written into a log file.
@
text
@d33 2
a34 2
	    qr/X FILE:/ => 1+16+1+17,
	    qr/X UNUSED:/ => 4+3,
d52 2
a53 2
	(map { { loggrep => get_testgrep() } } 0..16),
	(map { { loggrep => { qr/./s => 0 } } } 17..19),
d55 1
a55 1
    tty => {
d60 1
a60 1
    }
@


1.3
log
@Allow to use $curdir, $objdir, $host, $hostname in the test config
file.  They are substituted automatically, to avoid this in each
single test.
@
text
@d30 1
a30 1
	    qr/syslogd: receive_fd: recvmsg: Message too long/ => 4+2*3,
d55 6
@


1.2
log
@Test that syslogd does not append white spaces to messages.  Per
default the test pattern is stricter now.  Also do some test cleanup
@
text
@a11 3
use Cwd;

my $objdir = getcwd();
d23 1
a23 1
	conf => join("", map { "*.*\t$objdir/file-$_.log\n" } 0..19),
@


1.1
log
@Test syslogd with reduced file descriptor limit.  It has too many
log files in syslog.conf and must close and reopen them at SIGHUP.
@
text
@d55 1
a55 1
	(map { { loggrep => get_testlog() } } 0..16),
@

