head	1.9;
access;
symbols
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.6
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	bluhm_20140820:1.1.1.1
	bluhm:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2016.05.03.19.13.04;	author bluhm;	state Exp;
branches;
next	1.8;
commitid	QUorL89Z4jPT2RKR;

1.8
date	2015.09.03.18.14.35;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	GU2ZqWl3Jy7Gia9I;

1.7
date	2015.07.07.18.03.11;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	qTzx3B33iQFlT4Uv;

1.6
date	2015.06.28.18.52.11;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	aM7CthL8OPRsDMFq;

1.5
date	2015.02.13.21.40.50;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	tZ8vhc9XWQ8KWPvp;

1.4
date	2014.12.28.14.08.01;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	2DOukBo6SZhymWi6;

1.3
date	2014.09.13.23.38.24;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	8abA8sLPTwAOrtQB;

1.2
date	2014.09.02.00.26.30;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	9hOtCJWVU54mPrrd;

1.1
date	2014.08.20.20.52.14;	author bluhm;	state Exp;
branches
	1.1.1.1;
next	;
commitid	DUvdbfhw6s1btkKk;

1.1.1.1
date	2014.08.20.20.52.14;	author bluhm;	state Exp;
branches;
next	;
commitid	DUvdbfhw6s1btkKk;


desc
@@


1.9
log
@Fix some Perl statements perlcritic was bitching about: Variable
declared in conditional statement.
@
text
@#!/usr/bin/perl
#	$OpenBSD: syslogd.pl,v 1.8 2015/09/03 18:14:35 bluhm Exp $

# Copyright (c) 2010-2014 Alexander Bluhm <bluhm@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use Socket;
use Socket6;

use Client;
use Syslogd;
use Server;
use Syslogc;
use RSyslogd;
require 'funcs.pl';

sub usage {
	die "usage: syslogd.pl [test-args.pl]\n";
}

my $testfile;
our %args;
if (@@ARGV and -f $ARGV[-1]) {
	$testfile = pop;
	do $testfile
	    or die "Do test file $testfile failed: ", $@@ || $!;
}
@@ARGV == 0 or usage();

create_multifile(@@{$args{multifile} || []});
foreach my $name (qw(client syslogd server rsyslogd)) {
	$args{$name} or next;
	foreach my $action (qw(connect listen)) {
		my $h = $args{$name}{$action} or next;
		defined $h->{domain}
		    or die "No domain specified in $name $action";
		foreach my $k (qw(domain proto addr port)) {
			next unless defined $h->{$k};
			$args{$name}{"$action$k"} = $h->{$k};
		}
	}
}
my($s, $c, $r, $rc, @@m);
$s = RSyslogd->new(
    %{$args{rsyslogd}},
    listenport          => scalar find_ports(%{$args{rsyslogd}{listen}}),
    testfile            => $testfile,
) if $args{rsyslogd}{listen} && !$args{rsyslogd}{connect};
$s ||= Server->new(
    func                => \&read_log,
    listendomain        => AF_INET,
    listenaddr          => "127.0.0.1",
    %{$args{server}},
    testfile            => $testfile,
    client              => \$c,
    syslogd             => \$r,
) unless $args{server}{noserver};
$args{syslogc} = [ $args{syslogc} ] if ref $args{syslogc} eq 'HASH';
my $i = 0;
@@m = map { Syslogc->new(
    %{$_},
    testfile            => $testfile,
    ktracefile          => "syslogc-$i.ktrace",
    logfile             => "syslogc-".$i++.".log",
) } @@{$args{syslogc}};
$r = Syslogd->new(
    connectaddr         => "127.0.0.1",
    connectport         => $s && $s->{listenport},
    ctlsock		=> @@m && $m[0]->{ctlsock},
    %{$args{syslogd}},
    testfile            => $testfile,
    client              => \$c,
    server              => \$s,
);
$rc = RSyslogd->new(
    %{$args{rsyslogd}},
    listenport          => scalar find_ports(%{$args{rsyslogd}{listen}}),
    testfile            => $testfile,
) if $args{rsyslogd}{connect};
$c = Client->new(
    func                => \&write_log,
    connectport         => $rc && $rc->{listenport},
    %{$args{client}},
    testfile            => $testfile,
    syslogd             => \$r,
    server              => \$s,
) unless $args{client}{noclient};
($rc, $c) = ($c, $rc) if $rc;  # chain client -> rsyslogd -> syslogd

$c->run->up if !$args{client}{noclient} && $c->{early};
$r->run unless $r->{late};
$s->run->up unless $args{server}{noserver};
$r->run if $r->{late};
$r->up;
my $control = 0;
foreach (@@m) {
	if ($_->{early} || $_->{stop}) {
		$_->run->up;
		$control++;
	}
}
$r->loggrep("Accepting control connection") if $control;
foreach (@@m) {
	if ($_->{stop}) {
		$_->kill('STOP');
	}
}
$c->run->up if !$args{client}{noclient} && !$c->{early};
$rc->run->up if $args{rsyslogd}{connect};

$c->down if !$args{client}{noclient} && !$c->{early};
$s->down unless $args{server}{noserver};
foreach (@@m) {
	if ($_->{stop}) {
		$_->kill('CONT');
		$_->down;
	} elsif ($_->{early}) {
		$_->down;
	} else {
		$_->run->up->down;
	}
}
$r->kill_child;
$r->down;
$c->down if !$args{client}{noclient} && $c->{early};

$args{check}->({client => $c, syslogd => $r, server => $s}) if $args{check};
check_logs($c, $r, $s, \@@m, %args);
@


1.8
log
@Add test for sendsyslog(2) dropped message reporting.
@
text
@d2 1
a2 1
#	$OpenBSD: syslogd.pl,v 1.7 2015/07/07 18:03:11 bluhm Exp $
d56 1
a56 1
my($s, $c, $r, @@m);
d88 1
a88 1
my $rc = RSyslogd->new(
@


1.7
log
@Add tests for incomming syslog messages over TCP.
@
text
@d2 1
a2 1
#	$OpenBSD: syslogd.pl,v 1.6 2015/06/28 18:52:11 bluhm Exp $
d103 1
d121 1
a121 1
$c->run->up unless $args{client}{noclient};
d124 1
a124 1
$c->down unless $args{client}{noclient};
d138 1
@


1.6
log
@Add tests for the !prog and !!prog and !* keywords in syslog.conf.
@
text
@d2 1
a2 1
#	$OpenBSD: syslogd.pl,v 1.5 2015/02/13 21:40:50 bluhm Exp $
a43 5
if ($args{rsyslogd}) {
	$args{rsyslogd}{listen}{domain} ||= AF_INET;
	$args{rsyslogd}{listen}{addr}   ||= "127.0.0.1";
	$args{rsyslogd}{listen}{proto}  ||= "udp";
}
d48 4
a51 1
		foreach my $k (qw(domain addr proto port)) {
d61 1
a61 1
) if $args{rsyslogd};
d88 5
d95 1
d101 1
d121 1
@


1.5
log
@Adapt the maxunix test, the syslogd -a error semantic has changed.
Increase timeouts and remove races, so that the syslogd tests pass
on my sparc64 machine.
@
text
@d2 1
a2 1
#	$OpenBSD: syslogd.pl,v 1.4 2014/12/28 14:08:01 bluhm Exp $
d43 1
@


1.4
log
@Add regression tests where OpenBSD syslogd is sending messages to
rsyslogd from ports.  If the rsyslog package is installed, rsyslogd
is used as drain to test interoperability.  This will be especially
useful for syslog via TCP and TLS.
@
text
@d2 1
a2 1
#	$OpenBSD: syslogd.pl,v 1.3 2014/09/13 23:38:24 bluhm Exp $
d131 1
a132 1
$args{check}->({client => $c, syslogd => $r, server => $s}) if $args{check};
@


1.3
log
@Add tests for syslogd's memory buffer and read it with syslogc.
@
text
@d2 1
a2 1
#	$OpenBSD: syslogd.pl,v 1.2 2014/09/02 00:26:30 bluhm Exp $
d27 1
d43 7
a49 1
foreach my $name (qw(client syslogd server)) {
d52 1
a52 1
		foreach my $k (qw(protocol domain addr port)) {
d58 6
a63 1
$s = Server->new(
d97 1
a97 1
$r->run;
d99 1
@


1.2
log
@Add tests that run the syslogd signal handlers.
@
text
@d2 1
a2 1
#	$OpenBSD: syslogd.pl,v 1.1.1.1 2014/08/20 20:52:14 bluhm Exp $
d26 1
d50 1
a50 1
my($s, $c, $r);
d60 8
d71 1
d88 13
d105 10
d118 1
a118 1
check_logs($c, $r, $s, %args);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
#	$OpenBSD$
d49 2
a50 1
my $s = Server->new(
d56 2
d59 1
a59 1
my $r = Syslogd->new(
d64 2
d67 1
a67 1
my $c = Client->new(
d71 2
a74 1
$s->run unless $args{server}{noserver};
d76 1
a78 1
$s->up unless $args{server}{noserver};
d86 1
@


1.1.1.1
log
@Run syslogd regressions tests.  As only one syslogd can run per
machine, each test kills any syslogd first.  At the end the system's
syslogd gets restarted.
The test framework runs a client, and a server, and a syslogd.  The
messages are passed via the log socket or via UDP from the client
to syslogd.  From there UDP transport is used to reach the server.
All processes write log files where the message has to show up.
The test arguments are kept in the args-*.pl files.
The content of a log file, the data sent to a pipe process and what
the server received are checked.  The invocation of the sendsyslog(2)
syscall is checked with ktrace, the open file descriptors of syslogd
are checked with fstat.
@
text
@@
