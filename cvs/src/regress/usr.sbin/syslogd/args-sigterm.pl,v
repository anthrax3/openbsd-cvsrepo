head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.2
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4;
locks; strict;
comment	@# @;


1.8
date	2016.10.06.13.06.14;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	SvZFLcp8z1QgdkQR;

1.7
date	2015.12.30.13.15.52;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	A5ZwhsoQcJtCsd2c;

1.6
date	2015.10.19.20.16.09;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	kVDnyxLzqDFKPFoO;

1.5
date	2015.06.15.21.44.57;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	BmPbwQg6idYgxXrC;

1.4
date	2015.02.06.00.27.41;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	8et2usx9CGyR7b0D;

1.3
date	2015.01.05.18.48.31;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	eLb66WMTTCFLXoUF;

1.2
date	2014.09.02.17.43.29;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	uB2qKOs5zbFwXm2E;

1.1
date	2014.09.02.00.26.30;	author bluhm;	state Exp;
branches;
next	;
commitid	9hOtCJWVU54mPrrd;


desc
@@


1.8
log
@Check that syslogd priv process does exec on itself.
@
text
@# The client writes a message to Sys::Syslog native method.
# The syslogd writes it into a file and through a pipe.
# The syslogd passes it via UDP to the loghost.
# The server receives the message on its UDP socket.
# Find the message in client, file, pipe, syslogd, server log.
# Check that a SIGTERM terminates the syslogd child process.

use strict;
use warnings;

our %args = (
    client => {
	func => sub {
	    my $self = shift;
	    write_message($self, get_testlog());
	    ${$self->{server}}->loggrep("syslogd: exiting", 8)
		or die ref($self), " no 'syslogd: exiting' server log";
	},
    },
    syslogd => {
	ktrace => {
	    qr/syslogd  PSIG  SIGTERM caught handler/ => 1,
	    qr/syslogd  RET   execve 0/ => 2,
	},
	loggrep => qr/\[unpriv\] syslogd child about to exit/,
    },
    server => {
	func => sub {
	    my $self = shift;
	    read_message($self, get_testgrep());
	    ${$self->{syslogd}}->kill_syslogd('TERM');
	    read_message($self, qr/syslogd: exiting/);
	},
	down => qr/syslogd: exiting on signal 15/,
    },
);

1;
@


1.7
log
@Test logging to console by redirecting the system's console into a
file.  All subtests get an additional /dev/console entry in
syslog.conf, then check that messages appear in the console file.
Add a test that stops syslogd, calls sendsyslog2() with LOG_CONS
and checks that the message appears in the console file.
@
text
@d23 1
a23 1
	    qr/syslogd  RET   execve 0/ => 1,
@


1.6
log
@Test syslogd logging to a tty which belongs to a user.  This is
done with a utmp entry for a pty fake login.  All messages are read
from the pty and written into a log file.
@
text
@d13 1
a13 1
	func => sub { write_between2logs(shift, sub {
d15 4
a18 4
	    ${$self->{server}}->loggrep("Signal", 8)
		or die ref($self), " no 'Signal' between logs";
	})},
	loggrep => { get_between2loggrep() },
d28 1
a28 1
	func => sub { read_between2logs(shift, sub {
d30 1
d32 2
a33 6
	    my $pattern = "syslogd: exiting on signal 15";
	    ${$self->{syslogd}}->loggrep("syslogd: exiting on signal 15", 5)
		or die ref($self),
		" no 'syslogd: exiting on signal 15' between logs";
	    print STDERR "Signal\n";
	})},
a34 4
	loggrep => {
	    (get_between2loggrep())[0] => 1,
	    (get_between2loggrep())[2] => 0,
	},
a35 3
    file => { loggrep => (get_between2loggrep())[0] },
    pipe => { loggrep => (get_between2loggrep())[0] },
    tty => { loggrep => (get_between2loggrep())[0] },
@


1.5
log
@Rework how fstat and ktrace pattern are specified in the test
arguments.  Add tests to check wether syslogd privsep works.  This
is done for debug and foreground and daemon mode.  Fstat is checked
for chroot and sockets.  Ktrace dump is grepped for setting uid and
gid.
@
text
@d45 1
@


1.4
log
@Add syslogd tests for dropped messages.
@
text
@d21 1
a21 2
	ktrace => 1,
	kdump => {
@


1.3
log
@Make syslogd TCP tests more reliable.  Increase timeouts, shutdown
write to trigger connection close, allow errors EPIPE or ECONNRESET.
@
text
@d13 1
a13 1
	func => sub {
d15 3
a17 5
	    write_between2logs($self, sub {
		${$self->{server}}->loggrep("Signal", 8)
		    or die ref($self), " no 'Signal' between logs";
	    });
	},
d29 1
a29 1
	func => sub {
d31 7
a37 9
	    read_between2logs($self, sub {
		${$self->{syslogd}}->kill_syslogd('TERM');
		my $pattern = "syslogd: exiting on signal 15";
		${$self->{syslogd}}->loggrep("syslogd: exiting on signal 15", 5)
		    or die ref($self),
		    " no 'syslogd: exiting on signal 15' between logs";
		print STDERR "Signal\n";
	    });
	},
@


1.2
log
@To examine the operation of the signal handlers, the tests grep in
the ktrace output of syslogd.  Also make the tests work without DNS
and without sudo.
@
text
@d36 2
a37 2
		${$self->{syslogd}}->loggrep("syslogd: exiting on signal 15",
		    5) or die ref($self),
@


1.1
log
@Add tests that run the syslogd signal handlers.
@
text
@d23 5
@

