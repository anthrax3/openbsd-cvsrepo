head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.2
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.4.0.8
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.4
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.3.0.4
	OPENBSD_5_8_BASE:1.3;
locks; strict;
comment	@# @;


1.6
date	2017.09.17.23.56.03;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	WAIGPtOcGxhQt5cY;

1.5
date	2017.04.28.15.04.49;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	0z6zkjUem0HnIVEC;

1.4
date	2015.12.30.13.15.52;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	A5ZwhsoQcJtCsd2c;

1.3
date	2015.07.20.05.34.16;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	z0hAhY1IWpp7tf4t;

1.2
date	2015.07.16.16.34.49;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	0M9ba2ikkjyPND6j;

1.1
date	2015.07.09.21.12.44;	author bluhm;	state Exp;
branches;
next	;
commitid	AUvZQYxe8utgq9GX;


desc
@@


1.6
log
@If file descriptors are exhausted during initialization, we see
better log messages on the console now.
@
text
@# The syslogd is started with reduced file descriptor limits.
# The syslogd config contains more log files than possible.
# The client writes a message to Sys::Syslog native method.
# The syslogd writes it into a file and through a pipe.
# The syslogd passes it via UDP to the loghost.
# The server receives the message on its UDP socket.
# Find the message in client, file, pipe, syslogd, server log.
# Check the error messages and multiple log file content.
# Check that the error messages appear on the console.

use strict;
use warnings;

our %args = (
    syslogd => {
	conf => join("", map { "*.*\t\$objdir/file-$_.log\n" } 0..19),
	rlimit => {
	    RLIMIT_NOFILE => 30,
	},
	loggrep => {
	    qr/syslogd: receive_fd: recvmsg: Message too long/ => 6,
	    # One file is opened by test default config, 20 by multifile.
	    qr/X FILE:/ => 1+14,
	    qr/X UNUSED:/ => 6,
	},
    },
    multifile => [
	(map { { loggrep => get_testgrep() } } 0..13),
	(map { { loggrep => { qr/./s => 0 } } } 14..19),
    ],
    console => {
	loggrep => {
	    get_testgrep() => 1,
	    qr/priv_open_log .*: Message too long/ => 6,
	}
    }
);

1;
@


1.5
log
@Check that non existing log files in syslog.conf are reported to
/dev/console during startup and restart.  Startup warnings contain
the pid now.  Console logging creates additional errors if the file
descriptor limit is exhausted.
@
text
@d9 1
d21 1
a21 1
	    qr/syslogd: receive_fd: recvmsg: Message too long/ => 5*2,
d23 2
a24 2
	    qr/X FILE:/ => 1+15,
	    qr/X UNUSED:/ => 5,
d28 2
a29 2
	(map { { loggrep => get_testgrep() } } 0..14),
	(map { { loggrep => { qr/./s => 0 } } } 15..19),
d31 6
@


1.4
log
@Test logging to console by redirecting the system's console into a
file.  All subtests get an additional /dev/console entry in
syslog.conf, then check that messages appear in the console file.
Add a test that stops syslogd, calls sendsyslog2() with LOG_CONS
and checks that the message appears in the console file.
@
text
@d20 1
a20 1
	    qr/syslogd: receive_fd: recvmsg: Message too long/ => 5,
@


1.3
log
@Allow to use $curdir, $objdir, $host, $hostname in the test config
file.  They are substituted automatically, to avoid this in each
single test.
@
text
@d20 1
a20 1
	    qr/syslogd: receive_fd: recvmsg: Message too long/ => 4,
d22 2
a23 2
	    qr/X FILE:/ => 1+16,
	    qr/X UNUSED:/ => 4,
d27 2
a28 2
	(map { { loggrep => get_testgrep() } } 0..15),
	(map { { loggrep => { qr/./s => 0 } } } 16..19),
@


1.2
log
@Test that syslogd does not append white spaces to messages.  Per
default the test pattern is stricter now.  Also do some test cleanup
@
text
@a11 3
use Cwd;

my $objdir = getcwd();
d15 1
a15 1
	conf => join("", map { "*.*\t$objdir/file-$_.log\n" } 0..19),
@


1.1
log
@Test syslogd with reduced file descriptor limit.  It has too many
log files in syslog.conf and must close and reopen them at SIGHUP.
@
text
@d30 1
a30 1
	(map { { loggrep => get_testlog() } } 0..15),
@

