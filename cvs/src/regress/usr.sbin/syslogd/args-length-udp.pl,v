head	1.5;
access;
symbols
	OPENBSD_6_0:1.5.0.6
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_7_BASE:1.3;
locks; strict;
comment	@# @;


1.5
date	2015.07.07.18.03.11;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	qTzx3B33iQFlT4Uv;

1.4
date	2015.06.15.21.44.57;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	BmPbwQg6idYgxXrC;

1.3
date	2015.02.11.21.51.13;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	oVck3lsrH2XH2G1o;

1.2
date	2015.02.06.00.27.41;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	8et2usx9CGyR7b0D;

1.1
date	2015.02.02.17.40.24;	author bluhm;	state Exp;
branches;
next	;
commitid	BkvE03kfcbCrYutX;


desc
@@


1.5
log
@Add tests for incomming syslog messages over TCP.
@
text
@# The client writes long messages to UDP socket.
# The syslogd writes it into a file and through a pipe.
# The syslogd passes it via UDP to the loghost.
# The server receives the message on its UDP socket.
# Find the message in client, file, pipe, syslogd, server log.
# Check that lines in server have 1180 bytes line length.
# Check that lines in file have 8192 bytes message length after the header.

use strict;
use warnings;
use Socket;
use constant MAX_UDPMSG => 1180;

our %args = (
    client => {
	connect => { domain => AF_UNSPEC, addr => "localhost", port => 514 },
	func => sub {
	    my $self = shift;
	    write_lengths($self, 8190..8193,9000);
	    write_log($self);
	},
    },
    syslogd => {
	options => ["-u"],
	loggrep => {
	    get_charlog() => 5,
	},
    },
    server => {
	# >>> <13>Jan 31 00:10:11 0123456789ABC...lmn
	loggrep => {
	    get_charlog() => 5,
	    qr/^>>> .{19} /.generate_chars(MAX_UDPMSG-20).qr/$/ => 5,
	},
    },
    file => {
	# Jan 31 00:12:39 localhost 0123456789ABC...567
	loggrep => {
	    get_charlog() => 5,
	    qr/^.{25} .{8190}$/ => 1,
	    qr/^.{25} .{8191}$/ => 1,
	    qr/^.{25} .{8192}$/ => 3,
	},
    },
);

1;
@


1.4
log
@Rework how fstat and ktrace pattern are specified in the test
arguments.  Add tests to check wether syslogd privsep works.  This
is done for debug and foreground and daemon mode.  Fstat is checked
for chroot and sockets.  Ktrace dump is grepped for setting uid and
gid.
@
text
@d12 1
d33 1
a33 1
	    qr/^>>> .{1180}$/ => 5,
@


1.3
log
@Make syslogd tests more reliable.  Allow a range of certain log
messages, in case some got lost.  Slow down client when sending
multiple log messages.  Sort patterns when checking log files.  TLS
error messages have changed, adapt tests.
@
text
@d26 1
a26 1
	}
@


1.2
log
@Add syslogd tests for dropped messages.
@
text
@d16 5
a20 2
	func => \&write_length,
	lengths => [ 8190..8193,9000 ],
@


1.1
log
@Test that long syslog messages are truncated correctly.
@
text
@a12 2
my $msg = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

d22 1
a22 1
	    $msg => 5,
d28 1
a28 1
	    $msg => 5,
d35 1
a35 1
	    $msg => 5,
@

