head	1.12;
access;
symbols
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8;
locks; strict;
comment	@# @;


1.12
date	2016.10.13.22.30.45;	author bluhm;	state Exp;
branches;
next	1.11;
commitid	IRUDB2KLRDeris7k;

1.11
date	2016.09.23.14.35.15;	author bluhm;	state Exp;
branches;
next	1.10;
commitid	JKJPtU8AKXFWhQjU;

1.10
date	2015.10.19.20.16.09;	author bluhm;	state Exp;
branches;
next	1.9;
commitid	kVDnyxLzqDFKPFoO;

1.9
date	2015.07.16.16.34.49;	author bluhm;	state Exp;
branches;
next	1.8;
commitid	0M9ba2ikkjyPND6j;

1.8
date	2015.02.25.22.33.38;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	eW5Q0EpT5bjnSjHi;

1.7
date	2015.02.20.01.30.41;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	HOuXsLRktSDx7KPA;

1.6
date	2015.02.13.21.40.50;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	tZ8vhc9XWQ8KWPvp;

1.5
date	2015.02.12.23.16.02;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	trL3czROWP2b0HA5;

1.4
date	2015.02.11.21.51.13;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	oVck3lsrH2XH2G1o;

1.3
date	2015.02.11.17.28.41;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	hkdmk7KSUJ4UFi47;

1.2
date	2015.02.08.15.24.14;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	mltz6ku0toaoDiSH;

1.1
date	2015.02.06.00.27.41;	author bluhm;	state Exp;
branches;
next	;
commitid	8et2usx9CGyR7b0D;


desc
@@


1.12
log
@In rare cases the number of dropped messages changes a bit more.
Make regex less strict.
@
text
@# The client writes 300 messages to Sys::Syslog native method.
# The syslogd writes it into a file and through a pipe.
# The syslogd passes it via TLS to the loghost.
# The server blocks the message on its TLS socket.
# The server waits until the client as written all messages.
# The server sends a SIGTERM to syslogd and reads messages from kernel.
# The client waits until the server has read the first message.
# Find the message in client, file, pipe, syslogd log.
# Check that the 300 messages are in syslogd and file log.
# Check that the dropped message is in file log.

use strict;
use warnings;
use Socket;

our %args = (
    client => {
	func => sub { write_between2logs(shift, sub {
	    my $self = shift;
	    write_message($self, get_secondlog());
	    write_lines($self, 300, 1024);
	    write_message($self, get_thirdlog());
	    ${$self->{server}}->loggrep(get_secondlog(), 8)
		or die ref($self), " server did not receive second log";
	})},
    },
    syslogd => {
	loghost => '@@tls://localhost:$connectport',
	loggrep => {
	    get_charlog() => 300,
	    qr/SSL3_WRITE_PENDING/ => 0,
	},
    },
    server => {
	listen => { domain => AF_UNSPEC, proto => "tls", addr => "localhost" },
	rcvbuf => 2**12,
	redo => 0,
	func => sub {
	    my $self = shift;
	    ${$self->{syslogd}}->loggrep(get_thirdlog(), 20)
		or die ref($self), " syslogd did not receive third log";
	    ${$self->{syslogd}}->kill_syslogd('TERM');
	    ${$self->{syslogd}}->loggrep("syslogd: exiting", 5)
		or die ref($self), " no 'syslogd: exiting' between logs";
	    # syslogd has shut down, read from kernel socket buffer
	    read_log($self);
	},
	loggrep => {
	    get_firstlog() => 1,
	    get_secondlog() => 1,
	    get_thirdlog() => 0,
	    get_testgrep() => 0,
	    qr/syslogd: start/ => 1,
	    get_charlog() => '~88',
	},
    },
    file => {
	loggrep => {
	    get_firstlog() => 1,
	    get_secondlog() => 1,
	    get_thirdlog() => 1,
	    get_testgrep() => 0,
	    qr/syslogd: start/ => 1,
	    get_charlog() => 300,
	    qr/syslogd: dropped 2[0-3][0-9] messages to remote loghost/ => 1,
	},
    },
    pipe => { nocheck => 1 },
    tty => { nocheck => 1 },
);

1;
@


1.11
log
@The TCP socket buffer size for syslogd has changed.  Adapt tests
where we count the dropped messages.  A different number gets stuck
in the kernel buffers now which is not included in the syslogd
statistics.
@
text
@d65 1
a65 1
	    qr/syslogd: dropped 2[0-2][0-9] messages to remote loghost/ => 1,
@


1.10
log
@Test syslogd logging to a tty which belongs to a user.  This is
done with a utmp entry for a pty fake login.  All messages are read
from the pty and written into a log file.
@
text
@d36 1
d54 1
a54 1
	    get_charlog() => '>=10',
d65 1
a65 1
	    qr/syslogd: dropped 2[0-9][0-9] messages to remote loghost/ => 1,
@


1.9
log
@Test that syslogd does not append white spaces to messages.  Per
default the test pattern is stricter now.  Also do some test cleanup
@
text
@a55 3
    pipe => {
	loggrep => {},
    },
d67 2
@


1.8
log
@Do not count the dropped messages strictly, so that the syslogd
tests are depending less on the timing.  Fix a race in the buffer
sync test.  Now make regress of syslogd passes on my amd64, i386,
sparc64, alpha machines.
@
text
@d51 1
a51 1
	    get_testlog() => 0,
d64 1
a64 1
	    get_testlog() => 0,
@


1.7
log
@The write again workaround in syslogd changes the dropped message
counter.  Adapt tests.
@
text
@a30 1
	    qr/ \(dropped.*\)/ => '~42',
d53 1
a53 1
	    get_charlog() => '~40',
d67 1
a67 1
	    qr/syslogd: dropped 2[56][0-9] messages to remote loghost/ => 1,
@


1.6
log
@Adapt the maxunix test, the syslogd -a error semantic has changed.
Increase timeouts and remove races, so that the syslogd tests pass
on my sparc64 machine.
@
text
@d31 1
a31 1
	    qr/ \(dropped\)/ => '~19',
@


1.5
log
@Make syslogd tests more reliable.  Increase the allowed range of
lost log messages.  Improve the synchronisation of client and server.
@
text
@d54 1
a54 1
	    get_charlog() => 40,
@


1.4
log
@Make syslogd tests more reliable.  Allow a range of certain log
messages, in case some got lost.  Slow down client when sending
multiple log messages.  Sort patterns when checking log files.  TLS
error messages have changed, adapt tests.
@
text
@d32 1
d40 2
a41 2
	    ${$self->{client}}->loggrep(get_thirdlog(), 20)
		or die ref($self), " client did not send third log";
@


1.3
log
@Make syslogd test more reliable.  Use Time::HiRes to sleep .01
seconds in the write_lines() loop.  This slows down the client, so
all messages reach syslogd and flood its buffers.  Increase the
timeout to wait until all buffers are full.  Use this code in all
TCP/TLS buffer and memory overflow tests.
@
text
@d31 1
a31 1
	    qr/ \(dropped\)/ => 19,
d67 1
a67 1
	    qr/syslogd: dropped 262 messages to remote loghost/ => 1,
@


1.2
log
@Change syslog tests from transparent framing to octet counting.
Add tests for truncated buffer handling.
@
text
@d39 1
a39 1
	    ${$self->{client}}->loggrep(get_thirdlog(), 5)
@


1.1
log
@Add syslogd tests for dropped messages.
@
text
@d21 1
a21 5
	    foreach (1..300) {
		write_char($self, [1024], $_);
		# if client sends too fast, syslogd will not see everything
		sleep .01;
	    }
d31 1
d53 1
a53 1
	    get_charlog() => 42,
d67 1
a67 1
	    qr/syslogd: dropped 260 messages to remote loghost/ => 1,
@

