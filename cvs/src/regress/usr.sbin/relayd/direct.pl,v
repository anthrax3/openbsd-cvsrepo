head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.12
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.8
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.2.0.10
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.8
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.0.4
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2014.08.18.22.58.19;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	Lrki66TGIJh8PoUM;

1.2
date	2013.01.04.14.01.49;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2011.09.01.17.33.17;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Make the perl modules consistent for the multiple regression tests.
This includes coding style, better error messages and variable
naming.
@
text
@#!/usr/bin/perl
#	$OpenBSD: direct.pl,v 1.2 2013/01/04 14:01:49 bluhm Exp $

# Copyright (c) 2010-2014 Alexander Bluhm <bluhm@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use Socket;
use Socket6;

use Client;
use Server;
require 'funcs.pl';

sub usage {
	die "usage: direct.pl [test-args.pl]\n";
}

my $testfile;
our %args;
if (@@ARGV and -f $ARGV[-1]) {
	$testfile = pop;
	do $testfile
	    or die "Do test file $testfile failed: ", $@@ || $!;
}

@@ARGV == 0 or usage();

my $s = Server->new(
    func		=> \&read_char,
    %{$args{server}},
    listendomain	=> AF_INET,
    listenaddr		=> "127.0.0.1",
);
my $c = Client->new(
    func		=> \&write_char,
    %{$args{client}},
    connectdomain	=> AF_INET,
    connectaddr		=> "127.0.0.1",
    connectport		=> $s->{listenport},
);

$s->run;
$c->run->up;
$s->up;

$c->down;
$s->down;

check_logs($c, undef, $s, %args);
@


1.2
log
@Sync relayd tests with socket splicing tests.
@
text
@d2 1
a2 1
#	$OpenBSD: direct.pl,v 1.1 2011/09/01 17:33:17 bluhm Exp $
d4 1
a4 1
# Copyright (c) 2010-2013 Alexander Bluhm <bluhm@@openbsd.org>
d31 1
a31 1
my $test;
d34 3
a36 3
	$test = pop;
	do $test
	    or die "Do test file $test failed: ", $@@ || $!;
@


1.1
log
@Add regression tests for relaying connections through relayd.  This
is useful to ensure that socket splicing is working correctly.
Server, relayd, client with different config are started for each
subtest.  Data must pass unmodified.
@
text
@d2 1
a2 1
#	$OpenBSD$
d4 1
a4 1
# Copyright (c) 2010,2011 Alexander Bluhm <bluhm@@openbsd.org>
d27 5
d33 2
a34 1
if (my $test = pop) {
d39 1
a39 1
@@ARGV == 0 or die "usage: direct.pl [test-args.pl]\n";
d62 1
a62 20
exit if $args{nocheck} || $args{client}{nocheck};

my $clen = $c->loggrep(qr/^LEN: /) unless $args{client}{nocheck};
my $slen = $s->loggrep(qr/^LEN: /) unless $args{server}{nocheck};
!$clen || !$slen || $clen eq $slen
    or die "client: $clen", "server: $slen", "len mismatch";
!defined($args{len}) || !$clen || $clen eq "LEN: $args{len}\n"
    or die "client: $clen", "len $args{len} expected";
!defined($args{len}) || !$slen || $slen eq "LEN: $args{len}\n"
    or die "server: $slen", "len $args{len} expected";

my $cmd5 = $c->loggrep(qr/^MD5: /) unless $args{client}{nocheck};
my $smd5 = $s->loggrep(qr/^MD5: /) unless $args{server}{nocheck};
!$cmd5 || !$smd5 || ref($args{md5}) eq 'ARRAY' || $cmd5 eq $smd5
    or die "client: $cmd5", "server: $smd5", "md5 mismatch";
my $md5 = ref($args{md5}) eq 'ARRAY' ? join('|', @@{$args{md5}}) : $args{md5};
!$md5 || !$cmd5 || $cmd5 =~ /^MD5: ($md5)$/
    or die "client: $cmd5", "md5 $md5 expected";
!$md5 || !$smd5 || $smd5 =~ /^MD5: ($md5)$/
    or die "server: $smd5", "md5 $md5 expected";
@

