head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.4
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.22.0.6
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.18.0.4
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.8.0.8
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2;
locks; strict;
comment	@# @;


1.23
date	2017.07.14.14.41.03;	author bluhm;	state Exp;
branches;
next	1.22;
commitid	VrvXrAQYX3zpm11W;

1.22
date	2016.05.03.19.13.04;	author bluhm;	state Exp;
branches;
next	1.21;
commitid	QUorL89Z4jPT2RKR;

1.21
date	2015.07.20.05.37.49;	author bluhm;	state Exp;
branches;
next	1.20;
commitid	k8VK1TtQP5xAiPzp;

1.20
date	2015.07.18.22.11.34;	author benno;	state Exp;
branches;
next	1.19;
commitid	tCw6ZnA3ALMQ8qf7;

1.19
date	2015.05.17.22.49.03;	author bluhm;	state Exp;
branches;
next	1.18;
commitid	ZmEdEsG37OVW32LM;

1.18
date	2015.01.05.22.41.37;	author bluhm;	state Exp;
branches;
next	1.17;
commitid	E4uocvOGIK8ZPWbU;

1.17
date	2014.08.18.22.58.19;	author bluhm;	state Exp;
branches;
next	1.16;
commitid	Lrki66TGIJh8PoUM;

1.16
date	2014.07.20.19.18.32;	author bluhm;	state Exp;
branches;
next	1.15;
commitid	KBUibY42i7baeqrn;

1.15
date	2014.07.10.19.42.59;	author bluhm;	state Exp;
branches;
next	1.14;
commitid	nk40kclwQAcI5z4r;

1.14
date	2014.07.10.11.56.11;	author reyk;	state Exp;
branches;
next	1.13;
commitid	Zhns4mligOWElT1h;

1.13
date	2014.07.10.10.19.06;	author bluhm;	state Exp;
branches;
next	1.12;
commitid	loXzT9dsd77X1DLN;

1.12
date	2014.07.09.16.48.55;	author reyk;	state Exp;
branches;
next	1.11;
commitid	tyiEIIip8IP7h6pK;

1.11
date	2014.06.22.14.18.01;	author bluhm;	state Exp;
branches;
next	1.10;
commitid	9lcQYgJu0eGKsg3G;

1.10
date	2014.05.02.14.10.03;	author andre;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.24.09.05.10;	author bluhm;	state Exp;
branches;
next	1.8;

1.8
date	2013.02.07.22.56.27;	author bluhm;	state Exp;
branches;
next	1.7;

1.7
date	2013.01.04.14.01.49;	author bluhm;	state Exp;
branches;
next	1.6;

1.6
date	2012.11.02.17.40.46;	author bluhm;	state Exp;
branches;
next	1.5;

1.5
date	2011.09.06.23.25.27;	author bluhm;	state Exp;
branches;
next	1.4;

1.4
date	2011.09.02.21.05.41;	author bluhm;	state Exp;
branches;
next	1.3;

1.3
date	2011.09.02.17.02.10;	author bluhm;	state Exp;
branches;
next	1.2;

1.2
date	2011.09.02.10.45.36;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2011.09.01.17.33.17;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Do not mix Perl read() with sysread().  Data could get stuck in the
buffered IO and test run-regress-args-http-chunked.pl would fail
on slow hardware.  Limit debug output to one line per 1% of data.
Improve function write_syswrite().  Sync with httpd regress.  Fix
whitespace.
@
text
@#	$OpenBSD: funcs.pl,v 1.22 2016/05/03 19:13:04 bluhm Exp $

# Copyright (c) 2010-2017 Alexander Bluhm <bluhm@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
no warnings 'experimental::smartmatch';
use feature 'switch';
use Errno;
use Digest::MD5;
use Socket;
use Socket6;
use IO::Socket;
use IO::Socket::INET6;

sub find_ports {
	my %args = @@_;
	my $num    = delete $args{num}    // 1;
	my $domain = delete $args{domain} // AF_INET;
	my $addr   = delete $args{addr}   // "127.0.0.1";

	my @@sockets = (1..$num);
	foreach my $s (@@sockets) {
		$s = IO::Socket::INET6->new(
		    Proto  => "tcp",
		    Domain => $domain,
		    $addr ? (LocalAddr => $addr) : (),
		) or die "find_ports: create and bind socket failed: $!";
	}
	my @@ports = map { $_->sockport() } @@sockets;

	return @@ports;
}

########################################################################
# Client funcs
########################################################################

sub write_syswrite {
	my $self = shift;
	my $buf = shift;

	IO::Handle::flush(\*STDOUT);
	my $size = length($buf);
	my $len = 0;
	while ($len < $size) {
		my $n = syswrite(STDOUT, $buf, $size, $len);
		if (!defined($n)) {
			$!{EWOULDBLOCK}
			    or die ref($self), " syswrite failed: $!";
			print STDERR "blocked write at $len of $size: $!\n";
			next;
		}
		if ($len + $n != $size) {
			print STDERR "short write $n at $len of $size\n";
		}
		$len += $n;
	}
	return $len;
}

sub write_block {
	my $self = shift;
	my $len = shift;

	my $data;
	my $outb = 0;
	my $blocks = int($len / 1000);
	my $rest = $len % 1000;

	for (my $i = 1; $i <= 100 ; $i++) {
		$data .= "012345678\n";
	}

	my $opct = 0;
	for (my $i = 1; $i <= $blocks; $i++) {
		$outb += write_syswrite($self, $data);
		my $pct = ($outb / $len) * 100.0;
		if ($pct >= $opct + 1) {
			printf(STDERR "%.2f%% $outb/$len\n", $pct);
			$opct = $pct;
		}
	}

	if ($rest>0) {
		for (my $i = 1; $i < $rest-1 ; $i++) {
		    $outb += write_syswrite($self, 'r');
		    my $pct = ($outb / $len) * 100.0;
		    if ($pct >= $opct + 1) {
			    printf(STDERR "%.2f%% $outb/$len\n", $pct);
			    $opct = $pct;
		    }
		}
	}
	$outb += write_syswrite($self, "\n\n");
	IO::Handle::flush(\*STDOUT);
	print STDERR "LEN: ", $outb, "\n";
}

sub write_char {
	my $self = shift;
	my $len = shift // $self->{len} // 251;
	my $sleep = $self->{sleep};

	if ($self->{fast}) {
		write_block($self, $len);
		return;
	}

	my $ctx = Digest::MD5->new();
	my $char = '0';
	for (my $i = 1; $i < $len; $i++) {
		$ctx->add($char);
		print $char
		    or die ref($self), " print failed: $!";
		given ($char) {
			when(/9/)	{ $char = 'A' }
			when(/Z/)	{ $char = 'a' }
			when(/z/)	{ $char = "\n" }
			when(/\n/)	{ print STDERR "."; $char = '0' }
			default		{ $char++ }
		}
		if ($self->{sleep}) {
			IO::Handle::flush(\*STDOUT);
			sleep $self->{sleep};
		}
	}
	if ($len) {
		$char = "\n";
		$ctx->add($char);
		print $char
		    or die ref($self), " print failed: $!";
		print STDERR ".\n";
	}
	IO::Handle::flush(\*STDOUT);

	print STDERR "LEN: ", $len, "\n";
	print STDERR "MD5: ", $ctx->hexdigest, "\n";
}

sub http_client {
	my $self = shift;

	unless ($self->{lengths}) {
		# only a single http request
		my $len = shift // $self->{len} // 251;
		my $cookie = $self->{cookie};
		http_request($self, $len, "1.0", $cookie);
		http_response($self, $len);
		return;
	}

	$self->{http_vers} ||= ["1.1", "1.0"];
	my $vers = $self->{http_vers}[0];
	my @@lengths = @@{$self->{redo}{lengths} || $self->{lengths}};
	my @@cookies = @@{$self->{redo}{cookies} || $self->{cookies} || []};
	while (defined (my $len = shift @@lengths)) {
		my $cookie = shift @@cookies || $self->{cookie};
		eval {
			http_request($self, $len, $vers, $cookie);
			http_response($self, $len);
		};
		warn $@@ if $@@;
		if (@@lengths && ($@@ || $vers eq "1.0")) {
			# reconnect and redo the outstanding requests
			$self->{redo} = {
			    lengths => \@@lengths,
			    cookies => \@@cookies,
			};
			return;
		}
	}
	delete $self->{redo};
	shift @@{$self->{http_vers}};
	if (@@{$self->{http_vers}}) {
		# run the tests again with other persistence
		$self->{redo} = {
		    lengths => [@@{$self->{lengths}}],
		    cookies => [@@{$self->{cookies} || []}],
		};
	}
}

sub http_request {
	my ($self, $len, $vers, $cookie) = @@_;
	my $method = $self->{method} || "GET";
	my %header = %{$self->{header} || {}};

	# encode the requested length or chunks into the url
	my $path = ref($len) eq 'ARRAY' ? join("/", @@$len) : $len;
	# overwrite path with custom path
	if (defined($self->{path})) {
		$path = $self->{path};
	}
	my @@request = ("$method /$path HTTP/$vers");
	push @@request, "Host: foo.bar" unless defined $header{Host};
	if ($vers eq "1.1" && $method eq "PUT") {
		if (ref($len) eq 'ARRAY') {
			push @@request, "Transfer-Encoding: chunked"
			    if !defined $header{'Transfer-Encoding'};
		} else {
			push @@request, "Content-Length: $len"
			    if !defined $header{'Content-Length'};
		}
	}
	foreach my $key (sort keys %header) {
		my $val = $header{$key};
		if (ref($val) eq 'ARRAY') {
			push @@request, "$key: $_"
			    foreach @@{$val};
		} else {
			push @@request, "$key: $val";
		}
	}
	push @@request, "Cookie: $cookie" if $cookie;
	push @@request, "";
	print STDERR map { ">>> $_\n" } @@request;
	print map { "$_\r\n" } @@request;
	if ($method eq "PUT") {
		if (ref($len) eq 'ARRAY') {
			if ($vers eq "1.1") {
				write_chunked($self, @@$len);
			} else {
				write_char($self, $_) foreach (@@$len);
			}
		} else {
			write_char($self, $len);
		}
	}
	IO::Handle::flush(\*STDOUT);
	# XXX client shutdown seems to be broken in relayd
	#shutdown(\*STDOUT, SHUT_WR)
	#    or die ref($self), " shutdown write failed: $!"
	#    if $vers ne "1.1";
}

sub http_response {
	my ($self, $len) = @@_;
	my $method = $self->{method} || "GET";

	my $vers;
	my $chunked = 0;
	{
		local $/ = "\r\n";
		local $_ = <STDIN>;
		defined
		    or die ref($self), " missing http $len response";
		chomp;
		print STDERR "<<< $_\n";
		m{^HTTP/(\d\.\d) 200 OK$}
		    or die ref($self), " http response not ok"
		    unless $self->{httpnok};
		$vers = $1;
		while (<STDIN>) {
			chomp;
			print STDERR "<<< $_\n";
			last if /^$/;
			if (/^Content-Length: (.*)/) {
				if ($self->{httpnok}) {
					$len = $1;
				} else {
					$1 == $len or die ref($self),
					    " bad content length $1";
				}
			}
			if (/^Transfer-Encoding: chunked$/) {
				$chunked = 1;
			}
		}
	}
	if ($chunked) {
		read_chunked($self);
	} else {
		undef $len unless defined($vers) && $vers eq "1.1";
		read_char($self, $len)
		    if $method eq "GET";
	}
}

sub read_chunked {
	my $self = shift;

	for (;;) {
		my $len;
		{
			local $/ = "\r\n";
			local $_ = <STDIN>;
			defined or die ref($self), " missing chunk size";
			chomp;
			print STDERR "<<< $_\n";
			/^[[:xdigit:]]+$/
			    or die ref($self), " chunk size not hex: $_";
			$len = hex;
		}
		last unless $len > 0;
		read_char($self, $len);
		{
			local $/ = "\r\n";
			local $_ = <STDIN>;
			defined or die ref($self), " missing chunk data end";
			chomp;
			print STDERR "<<< $_\n";
			/^$/ or die ref($self), " no chunk data end: $_";
		}
	}
	{
		local $/ = "\r\n";
		while (<STDIN>) {
			chomp;
			print STDERR "<<< $_\n";
			last if /^$/;
		}
		defined or die ref($self), " missing chunk trailer";
	}
}

sub errignore {
	$SIG{PIPE} = 'IGNORE';
	$SIG{__DIE__} = sub {
		die @@_ if $^S;
		warn "Error ignored";
		warn @@_;
		IO::Handle::flush(\*STDERR);
		POSIX::_exit(0);
	};
}

########################################################################
# Common funcs
########################################################################

sub read_char {
	my $self = shift;
	my $max = shift // $self->{max};

	if ($self->{fast}) {
		read_block($self, $max);
		return;
	}

	my $ctx = Digest::MD5->new();
	my $len = 0;
	if (defined($max) && $max == 0) {
		print STDERR "Max\n";
	} else {
		while (<STDIN>) {
			$len += length($_);
			$ctx->add($_);
			print STDERR ".";
			if (defined($max) && $len >= $max) {
				print STDERR "\nMax";
				last;
			}
		}
		print STDERR "\n";
	}

	print STDERR "LEN: ", $len, "\n";
	print STDERR "MD5: ", $ctx->hexdigest, "\n";
}

sub read_block {
	my $self = shift;
	my $max = shift // $self->{max};

	my $opct = 0;
	my $ctx = Digest::MD5->new();
	my $len = 0;
	for (;;) {
		if (defined($max) && $len >= $max) {
			print STDERR "Max\n";
			last;
		}
		my $rlen = POSIX::BUFSIZ;
		if (defined($max) && $rlen > $max - $len) {
			$rlen = $max - $len;
		}
		defined(my $n = read(STDIN, my $buf, $rlen))
		    or die ref($self), " read failed: $!";
		$n or last;
		$len += $n;
		$ctx->add($buf);
		my $pct = ($len / $max) * 100.0;
		if ($pct >= $opct + 1) {
			printf(STDERR "%.2f%% $len/$max\n", $pct);
			$opct = $pct;
		}
	}

	print STDERR "LEN: ", $len, "\n";
	print STDERR "MD5: ", $ctx->hexdigest, "\n";
}

########################################################################
# Server funcs
########################################################################

sub http_server {
	my $self = shift;
	my %header = %{$self->{header} || { Server => "Perl/".$^V }};
	my $cookie = $self->{cookie} || "";

	my($method, $url, $vers);
	do {
		my $len;
		{
			local $/ = "\r\n";
			local $_ = <STDIN>;
			return unless defined $_;
			chomp;
			print STDERR "<<< $_\n";
			($method, $url, $vers) = m{^(\w+) (.*) HTTP/(1\.[01])$}
			    or die ref($self), " http request not ok";
			$method =~ /^(GET|PUT)$/
			    or die ref($self), " unknown method: $method";
			($len, my @@chunks) = $url =~ /(\d+)/g;
			$len = [ $len, @@chunks ] if @@chunks;
			while (<STDIN>) {
				chomp;
				print STDERR "<<< $_\n";
				last if /^$/;
				if ($method eq "PUT" &&
				    /^Content-Length: (.*)/) {
					$1 == $len or die ref($self),
					    " bad content length $1";
				}
				$cookie ||= $1 if /^Cookie: (.*)/;
			}
		}
		if ($method eq "PUT" ) {
			if (ref($len) eq 'ARRAY') {
				read_chunked($self);
			} else {
				read_char($self, $len);
			}
		}

		my @@response = ("HTTP/$vers 200 OK");
		$len = defined($len) ? $len : scalar(split /|/,$url);
		if ($vers eq "1.1" && $method eq "GET") {
			if (ref($len) eq 'ARRAY') {
				push @@response, "Transfer-Encoding: chunked";
			} else {
				push @@response, "Content-Length: $len";
			}
		}
		foreach my $key (sort keys %header) {
			my $val = $header{$key};
			if (ref($val) eq 'ARRAY') {
				push @@response, "$key: $_"
				    foreach @@{$val};
			} else {
				push @@response, "$key: $val";
			}
		}
		push @@response, "Set-Cookie: $cookie" if $cookie;
		push @@response, "";

		print STDERR map { ">>> $_\n" } @@response;
		print map { "$_\r\n" } @@response;

		if ($method eq "GET") {
			if (ref($len) eq 'ARRAY') {
				if ($vers eq "1.1") {
					write_chunked($self, @@$len);
				} else {
					write_char($self, $_) foreach (@@$len);
				}
			} else {
				write_char($self, $len);
			}
		}
		IO::Handle::flush(\*STDOUT);
	} while ($vers eq "1.1");
	$self->{redo}-- if $self->{redo};
}

sub write_chunked {
	my $self = shift;
	my @@chunks = @@_;

	foreach my $len (@@chunks) {
		printf STDERR ">>> %x\n", $len;
		printf "%x\r\n", $len;
		write_char($self, $len);
		printf STDERR ">>> \n";
		print "\r\n";
	}
	my @@trailer = ("0", "X-Chunk-Trailer: @@chunks", "");
	print STDERR map { ">>> $_\n" } @@trailer;
	print map { "$_\r\n" } @@trailer;
}

########################################################################
# Script funcs
########################################################################

sub check_logs {
	my ($c, $r, $s, %args) = @@_;

	return if $args{nocheck};

	check_len($c, $r, $s, %args);
	check_md5($c, $r, $s, %args);
	check_loggrep($c, $r, $s, %args);
	$r->loggrep("lost child")
	    and die "relayd lost child";
}

sub check_len {
	my ($c, $r, $s, %args) = @@_;

	$args{len} ||= 251 unless $args{lengths};

	my (@@clen, @@slen);
	@@clen = $c->loggrep(qr/^LEN: /) or die "no client len"
	    unless $args{client}{nocheck};
	@@slen = $s->loggrep(qr/^LEN: /) or die "no server len"
	    unless $args{server}{nocheck};
	!@@clen || !@@slen || @@clen ~~ @@slen
	    or die "client: @@clen", "server: @@slen", "len mismatch";
	!defined($args{len}) || !$clen[0] || $clen[0] eq "LEN: $args{len}\n"
	    or die "client: $clen[0]", "len $args{len} expected";
	!defined($args{len}) || !$slen[0] || $slen[0] eq "LEN: $args{len}\n"
	    or die "server: $slen[0]", "len $args{len} expected";
	my @@lengths = map { ref eq 'ARRAY' ? @@$_ : $_ }
	    @@{$args{lengths} || []};
	foreach my $len (@@lengths) {
		unless ($args{client}{nocheck}) {
			my $clen = shift @@clen;
			$clen eq "LEN: $len\n"
			    or die "client: $clen", "len $len expected";
		}
		unless ($args{server}{nocheck}) {
			my $slen = shift @@slen;
			$slen eq "LEN: $len\n"
			    or die "server: $slen", "len $len expected";
		}
	}
}

sub check_md5 {
	my ($c, $r, $s, %args) = @@_;

	my (@@cmd5, @@smd5);
	@@cmd5 = $c->loggrep(qr/^MD5: /) unless $args{client}{nocheck};
	@@smd5 = $s->loggrep(qr/^MD5: /) unless $args{server}{nocheck};
	!@@cmd5 || !@@smd5 || $cmd5[0] eq $smd5[0]
	    or die "client: $cmd5[0]", "server: $smd5[0]", "md5 mismatch";

	my @@md5 = ref($args{md5}) eq 'ARRAY' ? @@{$args{md5}} : $args{md5} || ()
	    or return;
	foreach my $md5 (@@md5) {
		unless ($args{client}{nocheck}) {
			my $cmd5 = shift @@cmd5
			    or die "too few md5 in client log";
			$cmd5 =~ /^MD5: ($md5)$/
			    or die "client: $cmd5", "md5 $md5 expected";
		}
		unless ($args{server}{nocheck}) {
			my $smd5 = shift @@smd5
			    or die "too few md5 in server log";
			$smd5 =~ /^MD5: ($md5)$/
			    or die "server: $smd5", "md5 $md5 expected";
		}
	}
	@@cmd5 && ref($args{md5}) eq 'ARRAY'
	    and die "too many md5 in client log";
	@@smd5 && ref($args{md5}) eq 'ARRAY'
	    and die "too many md5 in server log";
}

sub check_loggrep {
	my ($c, $r, $s, %args) = @@_;

	my %name2proc = (client => $c, relayd => $r, server => $s);
	foreach my $name (qw(client relayd server)) {
		my $p = $name2proc{$name} or next;
		my $pattern = $args{$name}{loggrep} or next;
		$pattern = [ $pattern ] unless ref($pattern) eq 'ARRAY';
		foreach my $pat (@@$pattern) {
			if (ref($pat) eq 'HASH') {
				while (my($re, $num) = each %$pat) {
					my @@matches = $p->loggrep($re);
					@@matches == $num
					    or die "$name matches '@@matches': ",
					    "'$re' => $num";
				}
			} else {
				$p->loggrep($pat)
				    or die "$name log missing pattern: '$pat'";
			}
		}
	}
}

1;
@


1.22
log
@Fix some Perl statements perlcritic was bitching about: Variable
declared in conditional statement.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.21 2015/07/20 05:37:49 bluhm Exp $
d3 1
a3 1
# Copyright (c) 2010-2015 Alexander Bluhm <bluhm@@openbsd.org>
d54 3
a57 3
	my $size = length($buf);
	my $r = 0;

d59 6
a64 5
		while (($r = syswrite(STDOUT, $buf, $size, $len))) {
		    $len += $r;
			if ($r != $size) {
			    print STDERR "short write (only $r bytes)\n";
			}
d66 2
a67 2
		if ($len != $size) {
		    print STDERR "short write ($!)\n";
d69 1
d74 1
a74 1
sub write_blocks {
d84 1
a84 1
		$data .= '012345678'."\n";
d87 1
d89 6
a94 2
		$outb += write_syswrite($self,$data);
		print STDERR ".";
d99 6
a104 2
		    $outb += write_syswrite($self,'r');
		    print STDERR ".";
d107 1
a107 2
	print STDERR "\n";
	$outb += write_syswrite($self,"\n\n");
d118 1
a118 1
		write_blocks($self,$len);
d286 2
a287 1
		read_char($self, $vers eq "1.1" ? $len : undef)
d341 1
a341 1
# Server funcs
d344 1
a344 1
sub read_char_fast {
d348 5
d358 2
a359 4
		while ((my $r = sysread(STDIN, my $buf, POSIX::BUFSIZ))) {
			my $pct;
			$_ = $buf;
			$len += $r;
d361 1
a361 2
			$pct = ($len / $max) * 100.0;
			printf(STDERR "%.2f%%\n", $pct);
d374 1
a374 1
sub read_char {
d378 1
a378 5
	if ($self->{fast}) {
		read_char_fast($self,$max);
		return;
	}

d381 18
a398 11
	if (defined($max) && $max == 0) {
		print STDERR "Max\n";
	} else {
		while (<STDIN>) {
			$len += length($_);
			$ctx->add($_);
			print STDERR ".";
			if (defined($max) && $len >= $max) {
				print STDERR "\nMax";
				last;
			}
a399 1
		print STDERR "\n";
d405 4
@


1.21
log
@Fix white spaces.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.20 2015/07/18 22:11:34 benno Exp $
d508 2
a509 1
	my @@clen = $c->loggrep(qr/^LEN: /) or die "no client len"
d511 1
a511 1
	my @@slen = $s->loggrep(qr/^LEN: /) or die "no server len"
d538 3
a540 2
	my @@cmd5 = $c->loggrep(qr/^MD5: /) unless $args{client}{nocheck};
	my @@smd5 = $s->loggrep(qr/^MD5: /) unless $args{server}{nocheck};
@


1.20
log
@add relayd regression test args-http-slow-consumer.pl
ok reyk@@, bluhm@@
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.19 2015/05/17 22:49:03 bluhm Exp $
d97 1
a97 1
	$outb += write_syswrite($self,"\n\n");	
@


1.19
log
@Add test cases for a crash reported by Bertrand PROVOST.  When a
HTTP client writes multiple requests or chunks in a single transfer,
relayd invokes the libevent callback manually for the next data.
If the callback closes the session, this results in an use after
free.
Test an invalid second request method, test an invalid header line
in the second PUT request, test an invalid second chunked length
for a PUT request.  Also test multiple valid HTTP 1.1 PUT requests
with chunked body.
To detect crashes of relayd, start it with "prefork 1" and grep for
"lost child" log messages.  Unfortunately only the first child is
monitored by the parent.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.18 2015/01/05 22:41:37 bluhm Exp $
d51 51
d107 5
d333 28
d364 5
@


1.18
log
@Fix relayd http regression tests.  If http response is not ok, the
response's content length may be an unexpected value as an error
page is shown.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.17 2014/08/18 22:58:19 bluhm Exp $
d3 1
a3 1
# Copyright (c) 2010-2014 Alexander Bluhm <bluhm@@openbsd.org>
d95 1
d105 4
a108 1
		eval { http_request($self, $len, $vers, $cookie) };
d143 9
a151 3
	push @@request, "Content-Length: $len"
	    if $vers eq "1.1" && $method eq "PUT" &&
	    !defined $header{'Content-Length'};
d165 11
a175 1
	write_char($self, $len) if $method eq "PUT";
d181 1
d183 5
d196 1
a196 1
		m{^HTTP/$vers 200 OK$}
d199 1
d334 7
a340 4
		# XXX reading to EOF does not work with relayd
		#read_char($self, $vers eq "1.1" ? $len : undef)
		read_char($self, $len)
		    if $method eq "PUT";
d344 6
a349 6
		if (ref($len) eq 'ARRAY') {
			push @@response, "Transfer-Encoding: chunked"
			    if $vers eq "1.1";
		} else {
			push @@response, "Content-Length: $len"
			    if $vers eq "1.1" && $method eq "GET";
d366 7
a372 3
		if (ref($len) eq 'ARRAY') {
			if ($vers eq "1.1") {
				write_chunked($self, @@$len);
d374 1
a374 1
				write_char($self, $_) foreach (@@$len);
a375 2
		} else {
			write_char($self, $len) if $method eq "GET";
d410 2
@


1.17
log
@Make the perl modules consistent for the multiple regression tests.
This includes coding style, better error messages and variable
naming.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.16 2014/07/20 19:18:32 bluhm Exp $
d178 6
a183 2
				$1 == $len or die ref($self),
				    " bad content length $1";
@


1.16
log
@A HTTP connection may have multiple requests with content.  Allow
to specify an array of md5 hashes in the test arguments and check
all of them in the client and server log files.  So test that relayd
does not modify the http body.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.15 2014/07/10 19:42:59 bluhm Exp $
d3 1
a3 1
# Copyright (c) 2010-2013 Alexander Bluhm <bluhm@@openbsd.org>
d442 1
a442 2
		my $p = $name2proc{$name}
		    or next;
d450 2
a451 2
					    or die "$name matches @@matches: ",
					    "$re => $num";
d455 1
a455 1
				    or die "$name log missing pattern: $pat";
@


1.15
log
@To make sure that at least anything is tested, add a length check
per default for the default length value in check_logs().  If a
test doesn't want this check, it has to disable it explicitly with
nocheck.  Also remove unneeded nocheck switches for deeper testing.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.14 2014/07/10 11:56:11 reyk Exp $
d410 25
a434 10
	my $cmd5 = $c->loggrep(qr/^MD5: /) unless $args{client}{nocheck};
	my $smd5 = $s->loggrep(qr/^MD5: /) unless $args{server}{nocheck};
	!$cmd5 || !$smd5 || ref($args{md5}) eq 'ARRAY' || $cmd5 eq $smd5
	    or die "client: $cmd5", "server: $smd5", "md5 mismatch";
	my $md5 = ref($args{md5}) eq 'ARRAY' ?
	    join('|', @@{$args{md5}}) : $args{md5};
	!$md5 || !$cmd5 || $cmd5 =~ /^MD5: ($md5)$/
	    or die "client: $cmd5", "md5 $md5 expected";
	!$md5 || !$smd5 || $smd5 =~ /^MD5: ($md5)$/
	    or die "server: $smd5", "md5 $md5 expected";
@


1.14
log
@Add support to test handling of repeated headers.

From RFC 7230, section 3.2.2:
"A sender MUST NOT generate multiple header fields with the same field
name in a message unless either the entire field value for that
header field is defined as a comma-separated list [i.e., #(values)]
or the header field is a well-known exception (as noted below)."
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.13 2014/07/10 10:19:06 bluhm Exp $
d378 2
@


1.13
log
@Implement non-persistent connections in a cleaner way.  Every test
that offers multiple requets per HTTP connection is run twice.
First all requests are run over a single TCP connection.  Then for
each requests a separate TCP connection is established.  If a
requests during a persistent connection fails, a reconnect is done
as relayd cancels the whole connection.  This allows stricter tests
for filters.
OK reyk@@
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.12 2014/07/09 16:48:55 reyk Exp $
d142 9
a150 1
	push @@request, "$_: $header{$_}" foreach sort keys %header;
d317 9
a325 1
		push @@response, "$_: $header{$_} " foreach sort keys %header;
@


1.12
log
@Update and extend the regress tests to use the new grammar of the
filtering rules.  Some of the filenames are based on the old grammar,
we keep them for now and just update the contents to have a
before/after comparison of the features.

Most of the work was done by Andre de Oliveira (andre@@)

OK bluhm@@ benno@@
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.11 2014/06/22 14:18:01 bluhm Exp $
a26 1
use IO::Socket::SSL;
a46 35
sub client_connect {
	my $self = shift;

	$SSL_ERROR = "";
	my $iosocket = $self->{ssl} ? "IO::Socket::SSL" : "IO::Socket::INET6";
	my $cs = $iosocket->new(
	    Proto		=> "tcp",
	    Domain		=> $self->{connectdomain},
	    PeerAddr		=> $self->{connectaddr},
	    PeerPort		=> $self->{connectport},
	    SSL_verify_mode	=> SSL_VERIFY_NONE,
	) or die ref($self), " $iosocket socket connect failed: $!,$SSL_ERROR";
	print STDERR "connect sock: ",$cs->sockhost()," ",$cs->sockport(),"\n";
	print STDERR "connect peer: ",$cs->peerhost()," ",$cs->peerport(),"\n";

	$self->{stdout} = *STDOUT;
	$self->{stdin} = *STDIN;
	*STDIN = *STDOUT = $self->{cs} = $cs;
}

sub client_disconnect {
	my $self = shift;
	my $cs = $self->{cs};

	*STDOUT = $self->{stdout};
	*STDIN = $self->{stdin};

	print STDERR "shutdown sock: ",$cs->sockhost()," ",$cs->sockport(),"\n";
	print STDERR "shutdown peer: ",$cs->peerhost()," ",$cs->peerport(),"\n";

	IO::Handle::flush(\*STDOUT);
	IO::Handle::flush($cs);
	$cs->shutdown(SHUT_RDWR);
}

d89 39
a127 2
	my @@lengths = @@{$self->{lengths} || [ shift // $self->{len} // 251 ]};
	my $vers = $self->{lengths} ? "1.1" : "1.0";
a129 31
	my @@cookies = $self->{cookies} ? @@{$self->{cookies}} :
		($self->{cookie} ? @@{$self->{cookie}} : ());
	my $c = 0;

	foreach my $len (@@lengths) {
		my $cookie = ($c < scalar(@@cookies) && length($cookies[$c])) ?
			$cookies[$c] : "";
		++$c;
		$self->{mreqs} && client_connect($self);
		# encode the requested length or chunks into the url
		my $path = ref($len) eq 'ARRAY' ? join("/", @@$len) : $len;
		# overwrite path with custom path
		if (defined($self->{path})) {
			$path = $self->{path};
		}
		my @@request = ("$method /$path HTTP/$vers");
		push @@request, "Host: foo.bar" unless defined $header{Host};
		push @@request, "Content-Length: $len"
		    if $vers eq "1.1" && $method eq "PUT" &&
		    !defined $header{'Content-Length'};
		push @@request, "$_: $header{$_}" foreach sort keys %header;
		push @@request, "Cookie: $cookie" if $cookie ne "";
		push @@request, "";
		print STDERR map { ">>> $_\n" } @@request;
		print map { "$_\r\n" } @@request;
		write_char($self, $len) if $method eq "PUT";
		IO::Handle::flush(\*STDOUT);
		# XXX client shutdown seems to be broken in relayd
		#shutdown(\*STDOUT, SHUT_WR)
		#    or die ref($self), " shutdown write failed: $!"
		#    if $vers ne "1.1";
d131 44
a174 24
		my $chunked = 0;
		{
			local $/ = "\r\n";
			local $_ = <STDIN>;
			defined
			    or print STDERR ref($self),
				" missing http $len response\n";
			chomp if defined;
			print STDERR "<<< $_\n" if defined;
			die ref($self), " http response not ok"
				if (!defined or !m{^HTTP/$vers 200 OK$}) &&
				    !$self->{httpnok};
			while (<STDIN>) {
				chomp;
				print STDERR "<<< $_\n";
				last if /^$/;
				last if /^X-Chunk-Trailer:.*/;
				if (/^Content-Length: (.*)/) {
					$1 == $len or die ref($self),
					    " bad content length $1";
				}
				if (/^Transfer-Encoding: chunked$/) {
					$chunked = 1;
				}
d177 6
a182 7
		if ($chunked) {
			read_chunked($self);
		} else {
			read_char($self, $vers eq "1.1" ? $len : undef)
			    if $method eq "GET";
		}
		$self->{mreqs} && client_disconnect($self);
a262 28
sub server_accept {
	my $self = shift;
	my $iosocket = $self->{ssl} ? "IO::Socket::SSL" : "IO::Socket::INET6";
	my $as = $self->{ls}->accept()
	    or die ref($self), " $iosocket socket accept failed: $!";
	print STDERR "accept sock: ",$as->sockhost()," ",$as->sockport(),"\n";
	print STDERR "accept peer: ",$as->peerhost()," ",$as->peerport(),"\n";

	$self->{stdout} = *STDOUT;
	$self->{stdin} = *STDIN;
	*STDIN = *STDOUT = $self->{as} = $as;
}

sub server_disconnect {
	my $self = shift;
	my $as = $self->{as};
	*STDOUT = $self->{stdout};
	*STDIN = $self->{stdin};

	print STDERR "shutdown sock: ",$as->sockhost()," ",$as->sockport(),"\n";
	print STDERR "shutdown peer: ",$as->peerhost()," ",$as->peerport(),"\n";

	IO::Handle::flush(\*STDOUT);
	IO::Handle::flush($as);
#	$as->shutdown(SHUT_RDWR);
	IO::Handle::close($as);
}

a266 1
	my $reqsc = $self->{mreqs} || 0;
a269 1
		$self->{mreqs} && server_accept($self);
d292 1
a292 4
				if ($cookie eq "" &&
				    /^Cookie: (.*)/) {
				    $cookie = $1;
				}
d310 1
a310 2
		push @@response, "Set-Cookie: $cookie"
		    if $cookie ne "";
d317 5
a321 1
			write_chunked($self, @@$len);
a325 4
		if ($self->{mreqs}) {
			server_disconnect($self);
			--$reqsc > 0 or return;
		}
d327 1
@


1.11
log
@Fix the relayd regression tests.  Now they pass with and without
an obj directory.  The relayd process can also run on a remote
machine for different timing.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.10 2014/05/02 14:10:03 andre Exp $
d27 1
d48 35
d129 3
a131 1
	my $cookie = $self->{cookie} || "";
d134 4
d150 1
a150 2
		push @@request, "Cookie: $cookie"
		    if $cookie ne "";
d166 7
a172 6
			    or die ref($self), " missing http $len response";
			chomp;
			print STDERR "<<< $_\n";
			m{^HTTP/$vers 200 OK$}
			    or die ref($self), " http response not ok"
			    unless $self->{httpnok};
d177 1
d193 1
d274 28
d304 1
a304 1
	my %header = %{$self->{header} || {}};
d306 1
d310 1
d367 4
@


1.10
log
@Extends relayd regress-tests framework to support tweaks from test-code: tables
definition on relayd.conf, customization of client/server cookies,
client/server headers and request path.

ok reyk
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.9 2014/04/24 09:05:10 bluhm Exp $
d19 1
a19 1
#no warnings 'experimental::smartmatch';
@


1.9
log
@The switch statement given/when was introduced in Perl 5.10 and got
experimental in Perl 5.18.  So we see warnings in the tests.
given is experimental at funcs.pl line 62.
when is experimental at funcs.pl line 63.
Just suppress this type of warnings for now.  If Perl will disable
smart match, the simple regression code still works.  If they will
choose to remove given/when, we can fix it later.
Discussed with and OK andre@@ afresh1@@
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.8 2013/02/07 22:56:27 bluhm Exp $
d19 1
a19 1
no warnings 'experimental::smartmatch';
d93 1
d98 4
d108 2
d129 2
a130 1
			    or die ref($self), " http response not ok";
d232 2
d259 4
d271 1
d279 3
d283 1
@


1.8
log
@Add relayd regression tests with http filter and late connect.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.7 2013/01/04 14:01:49 bluhm Exp $
d19 1
@


1.7
log
@Sync relayd tests with socket splicing tests.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.6 2012/11/02 17:40:46 bluhm Exp $
d91 1
d96 2
a97 1
		my @@request = ("$method /$path HTTP/$vers", "Host: foo.bar");
d99 3
a101 1
		    if $vers eq "1.1" && $method eq "PUT";
d107 4
d116 2
a117 1
			defined or die ref($self), " missing http response";
d243 2
a244 1
				if (/^Content-Length: (.*)/) {
d250 3
a252 1
		read_char($self, $vers eq "1.1" ? $len : undef)
d255 1
a255 1
		my @@request = ("HTTP/$vers 200 OK");
d257 1
a257 1
			push @@request, "Transfer-Encoding: chunked"
d260 1
a260 1
			push @@request, "Content-Length: $len"
d263 3
a265 3
		push @@request, "";
		print STDERR map { ">>> $_\n" } @@request;
		print map { "$_\r\n" } @@request;
d322 10
a331 6
		my $clen = shift @@clen;
		$clen eq "LEN: $len\n"
		    or die "client: $clen", "len $len expected";
		my $slen = shift @@slen;
		$slen eq "LEN: $len\n"
		    or die "server: $slen", "len $len expected";
@


1.6
log
@Make the relayd regression tests more verbose.  Write everything
received from or sent to relayd into the client and server log file.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.5 2011/09/06 23:25:27 bluhm Exp $
d3 1
a3 1
# Copyright (c) 2010-2012 Alexander Bluhm <bluhm@@openbsd.org>
d176 1
a177 5
		my $soerror;
		$soerror = getsockopt(STDIN, SOL_SOCKET, SO_ERROR);
		print STDERR "ERROR IN: ", unpack('i', $soerror), "\n";
		$soerror = getsockopt(STDOUT, SOL_SOCKET, SO_ERROR);
		print STDERR "ERROR OUT: ", unpack('i', $soerror), "\n";
d278 79
@


1.5
log
@Add test for http chunked encoding over relayd http protocol.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.4 2011/09/02 21:05:41 bluhm Exp $
d3 1
a3 1
# Copyright (c) 2010,2011 Alexander Bluhm <bluhm@@openbsd.org>
d93 1
d95 6
a100 8
		{
			local $\ = "\r\n";
			print "$method /$path HTTP/$vers";
			print "Host: foo.bar";
			print "Content-Length: $len"
			    if $vers eq "1.1" && $method eq "PUT";
			print "";
		}
a105 1
			local $\ = "\n";
d108 1
d110 1
a110 1
			print STDERR;
d115 1
a116 1
				print STDERR;
a140 1
			local $\ = "\n";
d145 1
a145 1
			print STDERR;
a152 1
			local $\ = "\n";
d157 1
a161 1
		local $\ = "\n";
d165 1
a166 1
			print STDERR;
a222 1
			local $\ = "\n";
d227 1
a227 1
			print STDERR;
d236 1
a237 1
				print STDERR;
d247 7
a253 11
		{
			local $\ = "\r\n";
			print "HTTP/$vers 200 OK";
			if (ref($len) eq 'ARRAY') {
				print "Transfer-Encoding: chunked"
				    if $vers eq "1.1";
			} else {
				print "Content-Length: $len"
				    if $vers eq "1.1" && $method eq "GET";
			}
			print "";
d255 4
d273 1
d276 1
d279 3
a281 3
	print "0\r\n";
	print "X-Chunk-Trailer: @@chunks\r\n";
	print "\r\n";
@


1.4
log
@Add tests for relayd session timeout.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.3 2011/09/02 17:02:10 bluhm Exp $
d93 1
d96 1
a96 1
			print "$method /$len HTTP/$vers";
d105 1
d122 3
d127 45
a171 2
		read_char($self, $vers eq "1.1" ? $len : undef)
		    if $method eq "GET";
d236 2
a237 1
			($len) = $url =~ /(\d+)$/;
d254 7
a260 2
			print "Content-Length: $len"
			    if $vers eq "1.1" && $method eq "GET";
d263 5
a267 1
		write_char($self, $len) if $method eq "GET";
d270 14
@


1.3
log
@Add tests for relayd http put and https.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.2 2011/09/02 10:45:36 bluhm Exp $
d125 15
@


1.2
log
@Add tests for relayd protocol http 1.0 and 1.1.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.1 2011/09/01 17:33:17 bluhm Exp $
d90 1
d95 1
a95 1
			print "GET /$len HTTP/$vers";
d97 2
d101 1
d122 2
a123 1
		read_char($self, $vers eq "1.1" ? $len : undef);
d159 1
a159 1
	my($url, $vers);
d161 1
d169 1
a169 1
			($url, $vers) = m{^GET (.*) HTTP/(1\.[01])$}
d171 3
d178 4
d184 2
a186 2
		$url =~ /(\d+)$/;
		my $len = $1;
d190 2
a191 1
			print "Content-Length: $len" if $vers eq "1.1";
d194 1
a194 1
		write_char($self, $len);
@


1.1
log
@Add regression tests for relaying connections through relayd.  This
is useful to ensure that socket splicing is working correctly.
Server, relayd, client with different config are started for each
subtest.  Data must pass unmodified.
@
text
@d1 1
a1 1
#	$OpenBSD$
d86 34
a119 13
sub errignore {
	$SIG{PIPE} = 'IGNORE';
	$SIG{__DIE__} = sub {
		die @@_ if $^S;
		warn @@_;
		my $soerror;
		$soerror = getsockopt(STDIN, SOL_SOCKET, SO_ERROR);
		print STDERR "ERROR IN: ", unpack('i', $soerror), "\n";
		$soerror = getsockopt(STDOUT, SOL_SOCKET, SO_ERROR);
		print STDERR "ERROR OUT: ", unpack('i', $soerror), "\n";
		IO::Handle::flush(\*STDERR);
		POSIX::_exit(0);
	};
d128 1
a128 1
	my $max = $self->{max};
d132 11
a142 7
	while (<STDIN>) {
		$len += length($_);
		$ctx->add($_);
		print STDERR ".";
		if ($max && $len >= $max) {
			print STDERR "\nMax";
			last;
d144 1
a145 1
	print STDERR "\n";
d149 34
@

