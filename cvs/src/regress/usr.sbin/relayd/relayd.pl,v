head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.4
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.8.0.8
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2;
locks; strict;
comment	@# @;


1.15
date	2016.08.25.22.56.13;	author bluhm;	state Exp;
branches;
next	1.14;
commitid	aCXnzxhgJDfwKCFJ;

1.14
date	2016.05.03.19.13.04;	author bluhm;	state Exp;
branches;
next	1.13;
commitid	QUorL89Z4jPT2RKR;

1.13
date	2014.08.18.22.58.19;	author bluhm;	state Exp;
branches;
next	1.12;
commitid	Lrki66TGIJh8PoUM;

1.12
date	2014.07.11.15.38.44;	author bluhm;	state Exp;
branches;
next	1.11;
commitid	4Fj6TMeFzFnCmKj8;

1.11
date	2014.07.10.10.19.06;	author bluhm;	state Exp;
branches;
next	1.10;
commitid	loXzT9dsd77X1DLN;

1.10
date	2014.05.12.21.30.42;	author andre;	state Exp;
branches;
next	1.9;

1.9
date	2014.05.09.11.49.26;	author andre;	state Exp;
branches;
next	1.8;

1.8
date	2013.02.07.22.56.27;	author bluhm;	state Exp;
branches;
next	1.7;

1.7
date	2013.01.04.14.01.49;	author bluhm;	state Exp;
branches;
next	1.6;

1.6
date	2012.12.28.20.36.25;	author bluhm;	state Exp;
branches;
next	1.5;

1.5
date	2012.11.02.17.47.04;	author bluhm;	state Exp;
branches;
next	1.4;

1.4
date	2011.09.04.12.19.44;	author bluhm;	state Exp;
branches;
next	1.3;

1.3
date	2011.09.02.21.05.41;	author bluhm;	state Exp;
branches;
next	1.2;

1.2
date	2011.09.02.10.45.36;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2011.09.01.17.33.17;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Make relayd test slow-consumer more reliable.  Set SO_SNDTIMEO
sockopt correctly with Perl pack on i386.  Make it possible to grep
in each others client and server logfile.  Client does not simply
sleep but waits for short write at server.
@
text
@#!/usr/bin/perl
#	$OpenBSD: relayd.pl,v 1.14 2016/05/03 19:13:04 bluhm Exp $

# Copyright (c) 2010-2014 Alexander Bluhm <bluhm@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use Socket;
use Socket6;

use Client;
use Relayd;
use Server;
require 'funcs.pl';

sub usage {
	die "usage: relay.pl copy|splice [test-args.pl]\n";
}

my $testfile;
our %args;
if (@@ARGV and -f $ARGV[-1]) {
	$testfile = pop;
	do $testfile
	    or die "Do test file $testfile failed: ", $@@ || $!;
}
@@ARGV == 1 or usage();

my $redo = $args{lengths} && @@{$args{lengths}};
$redo = 0 if $args{client}{http_vers};  # run only one persistent connection
my($sport, $rport) = find_ports(num => 2);
my($s, $r, $c);
$s = Server->new(
    forward             => $ARGV[0],
    func                => \&read_char,
    listendomain        => AF_INET,
    listenaddr          => "127.0.0.1",
    listenport          => $sport,
    redo                => $redo,
    %{$args{server}},
    testfile            => $testfile,
    client              => \$c,
) unless $args{server}{noserver};
$r = Relayd->new(
    forward             => $ARGV[0],
    listendomain        => AF_INET,
    listenaddr          => "127.0.0.1",
    listenport          => $rport,
    connectdomain       => AF_INET,
    connectaddr         => "127.0.0.1",
    connectport         => $sport,
    %{$args{relayd}},
    testfile            => $testfile,
);
$c = Client->new(
    forward             => $ARGV[0],
    func                => \&write_char,
    connectdomain       => AF_INET,
    connectaddr         => "127.0.0.1",
    connectport         => $rport,
    %{$args{client}},
    testfile            => $testfile,
    server              => \$s,
) unless $args{client}{noclient};

$s->run unless $args{server}{noserver};
$r->run;
$r->up;
$c->run->up unless $args{client}{noclient};
$s->up unless $args{server}{noserver};

$c->down unless $args{client}{noclient};
$s->down unless $args{server}{noserver};
$r->kill_child;
$r->down;

check_logs($c, $r, $s, %args);
@


1.14
log
@Fix some Perl statements perlcritic was bitching about: Variable
declared in conditional statement.
@
text
@d2 1
a2 1
#	$OpenBSD: relayd.pl,v 1.13 2014/08/18 22:58:19 bluhm Exp $
d54 1
d75 1
@


1.13
log
@Make the perl modules consistent for the multiple regression tests.
This includes coding style, better error messages and variable
naming.
@
text
@d2 1
a2 1
#	$OpenBSD: relayd.pl,v 1.12 2014/07/11 15:38:44 bluhm Exp $
d44 2
a45 1
my $s = Server->new(
d55 1
a55 1
my $r = Relayd->new(
d66 1
a66 1
my $c = Client->new(
@


1.12
log
@Add a time.log file that accumulates timing information about the
executed tests.  This allows to micro benchmark relayd.
based on a diff from andre@@; OK reyk@@
@
text
@d2 1
a2 1
#	$OpenBSD: relayd.pl,v 1.11 2014/07/10 10:19:06 bluhm Exp $
d4 1
a4 1
# Copyright (c) 2010-2013 Alexander Bluhm <bluhm@@openbsd.org>
d32 1
a32 1
my $test;
d35 3
a37 3
	$test = pop;
	do $test
	    or die "Do test file $test failed: ", $@@ || $!;
d52 1
a52 1
    testfile            => $test,
d63 1
a63 1
    testfile            => $test,
d72 1
a72 1
    testfile            => $test,
@


1.11
log
@Implement non-persistent connections in a cleaner way.  Every test
that offers multiple requets per HTTP connection is run twice.
First all requests are run over a single TCP connection.  Then for
each requests a separate TCP connection is established.  If a
requests during a persistent connection fails, a reconnect is done
as relayd cancels the whole connection.  This allows stricter tests
for filters.
OK reyk@@
@
text
@d2 1
a2 1
#	$OpenBSD: relayd.pl,v 1.10 2014/05/12 21:30:42 andre Exp $
d45 1
d52 1
d66 1
d72 1
@


1.10
log
@Refactors "dummyrun" flag as "dryrun" with an approach similar to the one used
for client/server processes checks through $self->{down} state control
variable, while here, do not instantiate a client when noclient is defined,
reflecting server object instantiation behaviour.

ok bluhm
@
text
@d2 1
a2 1
#	$OpenBSD: relayd.pl,v 1.9 2014/05/09 11:49:26 andre Exp $
d41 2
d49 1
@


1.9
log
@Adds $relayd->{dummyrun} and $client->{noclient} flags to relayd tests
framework. These flags can be set from test file which eases performing
dry-runs of relayd long enough to do relayd.conf parsing, thus enabling the
grammar/parser-only tests.  While here, fix and improves args-http-mark.pl to a
correct use-case.

ok reyk
@
text
@d2 1
a2 1
#	$OpenBSD: relayd.pl,v 1.8 2013/02/07 22:56:27 bluhm Exp $
d66 1
a66 1
);
d77 1
a77 1
$r->down unless $args{relayd}{dummyrun};
@


1.8
log
@Add relayd regression tests with http filter and late connect.
@
text
@d2 1
a2 1
#	$OpenBSD: relayd.pl,v 1.7 2013/01/04 14:01:49 bluhm Exp $
d71 1
a71 1
$c->run->up;
d74 1
a74 1
$c->down;
d77 1
a77 1
$r->down;
@


1.7
log
@Sync relayd tests with socket splicing tests.
@
text
@d2 1
a2 1
#	$OpenBSD: relayd.pl,v 1.6 2012/12/28 20:36:25 bluhm Exp $
d48 1
a48 1
);
d68 1
a68 1
$s->run;
d72 1
a72 1
$s->up;
d75 1
a75 1
$s->down;
@


1.6
log
@Allow the relayd regression tests to run the relayd on a different
host from client and server.  Real TCP connections not running on
localhost provide a different timing uncovering more bugs.
@
text
@d2 1
a2 1
#	$OpenBSD: relayd.pl,v 1.5 2012/11/02 17:47:04 bluhm Exp $
d4 1
a4 1
# Copyright (c) 2010-2012 Alexander Bluhm <bluhm@@openbsd.org>
d79 1
a79 48
foreach ([ client => $c ], [ relayd => $r ], [ server => $s ]) {
	my($name, $proc) = @@$_;
	my $pattern = $args{$name}{loggrep} or next;
	$pattern = [ $pattern ] unless ref($pattern) eq 'ARRAY';
	foreach my $pat (@@$pattern) {
		if (ref($pat) eq 'HASH') {
			while (my($re, $num) = each %$pat) {
				my @@matches = $proc->loggrep($re);
				@@matches == $num or
				    die "$name matches @@matches: $re => $num";
			}
		} else {
			$proc->loggrep($pat)
			    or die "$name log missing pattern: $pat";
		}
	}
}

exit if $args{nocheck};

my @@clen = $c->loggrep(qr/^LEN: /) or die "no client len"
    unless $args{client}{nocheck};
my @@slen = $s->loggrep(qr/^LEN: /) or die "no server len"
    unless $args{server}{nocheck};
!@@clen || !@@slen || @@clen ~~ @@slen
    or die "client: @@clen", "server: @@slen", "len mismatch";
!defined($args{len}) || !$clen[0] || $clen[0] eq "LEN: $args{len}\n"
    or die "client: $clen[0]", "len $args{len} expected";
!defined($args{len}) || !$slen[0] || $slen[0] eq "LEN: $args{len}\n"
    or die "server: $slen[0]", "len $args{len} expected";
foreach my $len (map { ref eq 'ARRAY' ? @@$_ : $_ } @@{$args{lengths} || []}) {
	my $clen = shift @@clen;
	$clen eq "LEN: $len\n"
	    or die "client: $clen", "len $len expected";
	my $slen = shift @@slen;
	$slen eq "LEN: $len\n"
	    or die "server: $slen", "len $len expected";
}

my $cmd5 = $c->loggrep(qr/^MD5: /) unless $args{client}{nocheck};
my $smd5 = $s->loggrep(qr/^MD5: /) unless $args{server}{nocheck};
!$cmd5 || !$smd5 || ref($args{md5}) eq 'ARRAY' || $cmd5 eq $smd5
    or die "client: $cmd5", "server: $smd5", "md5 mismatch";
my $md5 = ref($args{md5}) eq 'ARRAY' ? join('|', @@{$args{md5}}) : $args{md5};
!$md5 || !$cmd5 || $cmd5 =~ /^MD5: ($md5)$/
    or die "client: $cmd5", "md5 $md5 expected";
!$md5 || !$smd5 || $smd5 =~ /^MD5: ($md5)$/
    or die "server: $smd5", "md5 $md5 expected";
@


1.5
log
@Allow to specify how often a pattern has to show up in the relayd
log file during a test.
@
text
@d2 1
a2 1
#	$OpenBSD: relayd.pl,v 1.4 2011/09/04 12:19:44 bluhm Exp $
d58 1
a58 1
    test                => $test,
d76 1
@


1.4
log
@Add test wether relayd is logging the correct http content-length.
@
text
@d2 1
a2 1
#	$OpenBSD: relayd.pl,v 1.3 2011/09/02 21:05:41 bluhm Exp $
d4 1
a4 1
# Copyright (c) 2010,2011 Alexander Bluhm <bluhm@@openbsd.org>
d83 10
a92 2
		$proc->loggrep($pat)
		    or die "$name log missing pattern: $pat";
d108 1
a108 1
foreach my $len (@@{$args{lengths} || []}) {
@


1.3
log
@Add tests for relayd session timeout.
@
text
@d2 1
a2 1
#	$OpenBSD: relayd.pl,v 1.2 2011/09/02 10:45:36 bluhm Exp $
d77 10
@


1.2
log
@Add tests for relayd protocol http 1.0 and 1.1.
@
text
@d2 1
a2 1
#	$OpenBSD: relayd.pl,v 1.1 2011/09/01 17:33:17 bluhm Exp $
d57 1
a57 1
    %{$args{relay}},
@


1.1
log
@Add regression tests for relaying connections through relayd.  This
is useful to ensure that socket splicing is working correctly.
Server, relayd, client with different config are started for each
subtest.  Data must pass unmodified.
@
text
@d2 1
a2 1
#	$OpenBSD$
d80 1
a80 1
my $clen = $c->loggrep(qr/^LEN: /) // die "no client len"
d82 1
a82 1
my $slen = $s->loggrep(qr/^LEN: /) // die "no server len"
d84 14
a97 6
!$clen || !$slen || $clen eq $slen
    or die "client: $clen", "server: $slen", "len mismatch";
!defined($args{len}) || !$clen || $clen eq "LEN: $args{len}\n"
    or die "client: $clen", "len $args{len} expected";
!defined($args{len}) || !$slen || $slen eq "LEN: $args{len}\n"
    or die "server: $slen", "len $args{len} expected";
@

