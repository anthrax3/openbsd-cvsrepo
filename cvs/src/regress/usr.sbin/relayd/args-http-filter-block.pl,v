head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.16
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.14
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.10
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.6
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.1.0.8
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@# @;


1.4
date	2014.07.10.10.19.06;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	loXzT9dsd77X1DLN;

1.3
date	2014.07.09.16.48.55;	author reyk;	state Exp;
branches;
next	1.2;
commitid	tyiEIIip8IP7h6pK;

1.2
date	2014.05.02.14.13.41;	author andre;	state Exp;
branches;
next	1.1;

1.1
date	2013.02.07.22.56.27;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Implement non-persistent connections in a cleaner way.  Every test
that offers multiple requets per HTTP connection is run twice.
First all requests are run over a single TCP connection.  Then for
each requests a separate TCP connection is established.  If a
requests during a persistent connection fails, a reconnect is done
as relayd cancels the whole connection.  This allows stricter tests
for filters.
OK reyk@@
@
text
@# test http block

use strict;
use warnings;

my @@lengths = (1, 2, 0, 3);
our %args = (
    client => {
	func => \&http_client,
	loggrep => qr/Client missing http 3 response/,
	lengths => \@@lengths,
    },
    relayd => {
	protocol => [ "http",
	    'block request path "/3"',
	],
	loggrep => qr/Forbidden/,
    },
    server => {
	func => \&http_server,
    },
    lengths => [1, 2, 0],
);

1;
@


1.3
log
@Update and extend the regress tests to use the new grammar of the
filtering rules.  Some of the filenames are based on the old grammar,
we keep them for now and just update the contents to have a
before/after comparison of the features.

Most of the work was done by Andre de Oliveira (andre@@)

OK bluhm@@ benno@@
@
text
@d9 1
a9 1
	func => sub { eval { http_client(@@_) }; warn $@@ },
d11 1
a11 2
        lengths => \@@lengths,
	mreqs => 1,
a20 2
	lengths => (1, 2, 0),
	mreqs => 3,
d22 1
@


1.2
log
@Improves this test to be more strict on the filter action test. Now it
dispatches 4 requests from the client and checks if the server receives only 3.
Previous functionality kept.

ok reyk
@
text
@d1 1
a1 1
# test http connection with request block filter, tests lateconnect
d11 2
a12 1
	lengths => \@@lengths,
d16 1
a16 1
	    'request path filter "/3"',
d18 1
a18 1
	loggrep => qr/rejecting request/,
d23 1
@


1.1
log
@Add relayd regression tests with http filter and late connect.
@
text
@d6 1
d9 3
a11 8
	func => sub {
	    eval { http_client(@@_) };
	    warn $@@;
	    $@@ =~ /missing http 1 response/
		or die "http not filtered";
	},
	len => 1,
	nocheck => 1,
d15 1
a15 1
	    'request path filter "/1"',
d20 2
a21 2
	noserver => 1,
	nocheck => 1,
@

