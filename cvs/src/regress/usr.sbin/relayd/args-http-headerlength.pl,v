head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.14
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.12
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.8
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.6
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.4
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.1.0.4
	OPENBSD_5_6_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2014.08.17.21.01.24;	author doug;	state Exp;
branches;
next	1.1;
commitid	F4Z4Mn9jGm10RS7k;

1.1
date	2014.07.11.22.28.45;	author reyk;	state Exp;
branches;
next	;
commitid	etE3yRsFWECDBHuh;


desc
@@


1.2
log
@Sync regress/usr.sbin/relayd with recent http.h changes
@
text
@use strict;
use warnings;

my %header = ( "Host" => "www.example.com", "Set-Cookie" => "a="."X"x8192 );
our %args = (
    client => {
	func => \&http_client,
	header => \%header,
	httpnok => 1,
	nocheck => 1,
	loggrep => qr/HTTP\/1\.0 413 Payload Too Large/,
    },
    relayd => {
	protocol => [ "http",
	    'return error',
	    'pass',
	],
	loggrep => qr/413 Payload Too Large/,
    },
    server => {
	noserver => 1,
	nocheck => 1,
    },
);

1;
@


1.1
log
@Limit HTTP header length to about 8K (based on the default of 4-8K in
common web servers).  Add a related regress test.

OK benno@@
@
text
@d11 1
a11 1
	loggrep => qr/HTTP\/1\.0 413 Request Entity Too Large/,
d18 1
a18 1
	loggrep => qr/413 Request Entity Too Large/,
@

