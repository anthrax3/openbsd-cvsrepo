head	1.9;
access;
symbols
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.3.0.8
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3;
locks; strict;
comment	@# @;


1.9
date	2016.08.25.22.56.13;	author bluhm;	state Exp;
branches;
next	1.8;
commitid	aCXnzxhgJDfwKCFJ;

1.8
date	2016.05.03.19.13.04;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	QUorL89Z4jPT2RKR;

1.7
date	2014.08.18.22.58.19;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	Lrki66TGIJh8PoUM;

1.6
date	2014.07.11.15.38.44;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	4Fj6TMeFzFnCmKj8;

1.5
date	2014.07.10.10.19.06;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	loXzT9dsd77X1DLN;

1.4
date	2014.06.22.14.18.01;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	9lcQYgJu0eGKsg3G;

1.3
date	2013.02.07.22.56.27;	author bluhm;	state Exp;
branches;
next	1.2;

1.2
date	2013.01.04.14.01.49;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2012.12.28.20.36.25;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Make relayd test slow-consumer more reliable.  Set SO_SNDTIMEO
sockopt correctly with Perl pack on i386.  Make it possible to grep
in each others client and server logfile.  Client does not simply
sleep but waits for short write at server.
@
text
@#!/usr/bin/perl
#	$OpenBSD: remote.pl,v 1.8 2016/05/03 19:13:04 bluhm Exp $

# Copyright (c) 2010-2014 Alexander Bluhm <bluhm@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use File::Basename;
use File::Copy;
use Socket;
use Socket6;

use Client;
use Relayd;
use Server;
use Remote;
require 'funcs.pl';

sub usage {
	die <<"EOF";
usage:
    remote.pl localport remoteaddr remoteport [test-args.pl]
	Run test with local client and server.  Remote relayd
	forwarding from remoteaddr remoteport to server localport
	has to be started manually.
    remote.pl copy|splice listenaddr connectaddr connectport [test-args.pl]
	Only start remote relayd.
    remote.pl copy|splice localaddr remoteaddr remotessh [test-args.pl]
	Run test with local client and server.  Remote relayd is
	started automatically with ssh on remotessh.
EOF
}

my $testfile;
our %args;
if (@@ARGV and -f $ARGV[-1]) {
	$testfile = pop;
	do $testfile
	    or die "Do test file $testfile failed: ", $@@ || $!;
}
my $mode =
	@@ARGV == 3 && $ARGV[0] =~ /^\d+$/ && $ARGV[2] =~ /^\d+$/ ? "manual" :
	@@ARGV == 4 && $ARGV[1] !~ /^\d+$/ && $ARGV[3] =~ /^\d+$/ ? "relay"  :
	@@ARGV == 4 && $ARGV[1] !~ /^\d+$/ && $ARGV[3] !~ /^\d+$/ ? "auto"   :
	usage();

my($s, $r, $c);
if ($mode eq "relay") {
	my($rport) = find_ports(num => 1);
	$r = Relayd->new(
	    forward             => $ARGV[0],
	    %{$args{relayd}},
	    listendomain        => AF_INET,
	    listenaddr          => $ARGV[1],
	    listenport          => $rport,
	    connectdomain       => AF_INET,
	    connectaddr         => $ARGV[2],
	    connectport         => $ARGV[3],
	    logfile             => dirname($0)."/remote.log",
	    conffile            => dirname($0)."/relayd.conf",
	    testfile            => $testfile,
	);
	open(my $log, '<', $r->{logfile})
	    or die "Remote log file open failed: $!";
	$SIG{__DIE__} = sub {
		die @@_ if $^S;
		copy($log, \*STDERR);
		warn @@_;
		exit 255;
	};
	copy($log, \*STDERR);
	$r->run;
	copy($log, \*STDERR);
	$r->up;
	copy($log, \*STDERR);
	print STDERR "listen sock: $ARGV[1] $rport\n";
	<STDIN>;
	copy($log, \*STDERR);
	print STDERR "stdin closed\n";
	$r->kill_child;
	$r->down;
	copy($log, \*STDERR);

	exit;
}

my $redo = $args{lengths} && @@{$args{lengths}};
$redo = 0 if $args{client}{http_vers};  # run only one persistent connection
$s = Server->new(
    forward             => $ARGV[0],
    func                => \&read_char,
    redo                => $redo,
    %{$args{server}},
    listendomain        => AF_INET,
    listenaddr          => ($mode eq "auto" ? $ARGV[1] : undef),
    listenport          => ($mode eq "manual" ? $ARGV[0] : undef),
    testfile            => $testfile,
    client              => \$c,
) unless $args{server}{noserver};
if ($mode eq "auto") {
	$r = Remote->new(
	    forward             => $ARGV[0],
	    logfile             => "relayd.log",
	    %{$args{relayd}},
	    remotessh           => $ARGV[3],
	    listenaddr          => $ARGV[2],
	    connectaddr         => $ARGV[1],
	    connectport         => $s ? $s->{listenport} : 1,
	    testfile            => $testfile,
	);
	$r->run->up;
}
$c = Client->new(
    forward             => $ARGV[0],
    func                => \&write_char,
    %{$args{client}},
    connectdomain       => AF_INET,
    connectaddr         => ($mode eq "manual" ? $ARGV[1] : $r->{listenaddr}),
    connectport         => ($mode eq "manual" ? $ARGV[2] : $r->{listenport}),
    testfile            => $testfile,
    server              => \$s,
) unless $args{client}{noclient};

$s->run unless $args{server}{noserver};
$c->run->up unless $args{client}{noclient};
$s->up unless $args{server}{noserver};

$c->down unless $args{client}{noclient};
$s->down unless $args{server}{noserver};
$r->close_child;
$r->down;

check_logs($c, $r, $s, %args);
@


1.8
log
@Fix some Perl statements perlcritic was bitching about: Variable
declared in conditional statement.
@
text
@d2 1
a2 1
#	$OpenBSD: remote.pl,v 1.7 2014/08/18 22:58:19 bluhm Exp $
d110 1
d133 1
@


1.7
log
@Make the perl modules consistent for the multiple regression tests.
This includes coding style, better error messages and variable
naming.
@
text
@d2 1
a2 1
#	$OpenBSD: remote.pl,v 1.6 2014/07/11 15:38:44 bluhm Exp $
d59 1
a59 1
my $r;
d101 1
a101 1
my $s = Server->new(
d124 1
a124 1
my $c = Client->new(
@


1.6
log
@Add a time.log file that accumulates timing information about the
executed tests.  This allows to micro benchmark relayd.
based on a diff from andre@@; OK reyk@@
@
text
@d2 1
a2 1
#	$OpenBSD: remote.pl,v 1.5 2014/07/10 10:19:06 bluhm Exp $
d4 1
a4 1
# Copyright (c) 2010-2013 Alexander Bluhm <bluhm@@openbsd.org>
d46 1
a46 1
my $test;
d49 3
a51 3
	$test = pop;
	do $test
	    or die "Do test file $test failed: ", $@@ || $!;
d73 1
a73 1
	    testfile            => $test,
d109 1
a109 1
    testfile            => $test,
d120 1
a120 1
	    testfile            => $test,
d131 1
a131 1
    testfile            => $test,
@


1.5
log
@Implement non-persistent connections in a cleaner way.  Every test
that offers multiple requets per HTTP connection is run twice.
First all requests are run over a single TCP connection.  Then for
each requests a separate TCP connection is established.  If a
requests during a persistent connection fails, a reconnect is done
as relayd cancels the whole connection.  This allows stricter tests
for filters.
OK reyk@@
@
text
@d2 1
a2 1
#	$OpenBSD: remote.pl,v 1.4 2014/06/22 14:18:01 bluhm Exp $
d102 1
d104 1
d109 1
a109 1
    redo                => $redo,
a114 1
	    testfile            => $test,
d120 1
d125 1
d131 1
@


1.4
log
@Fix the relayd regression tests.  Now they pass with and without
an obj directory.  The relayd process can also run on a remote
machine for different timing.
@
text
@d2 1
a2 1
#	$OpenBSD: remote.pl,v 1.3 2013/02/07 22:56:27 bluhm Exp $
d99 2
d107 1
@


1.3
log
@Add relayd regression tests with http filter and late connect.
@
text
@d2 1
a2 1
#	$OpenBSD: remote.pl,v 1.2 2013/01/04 14:01:49 bluhm Exp $
d111 1
a111 1
	    %{$args{relay}},
d125 1
a125 1
);
d128 1
a128 1
$c->run->up;
d131 1
a131 1
$c->down;
@


1.2
log
@Sync relayd tests with socket splicing tests.
@
text
@d2 1
a2 1
#	$OpenBSD: remote.pl,v 1.1 2012/12/28 20:36:25 bluhm Exp $
d105 1
a105 1
);
d115 1
a115 1
	    connectport         => $s->{listenport},
d127 1
a127 1
$s->run;
d129 1
a129 1
$s->up;
d132 1
a132 1
$s->down;
@


1.1
log
@Allow the relayd regression tests to run the relayd on a different
host from client and server.  Real TCP connections not running on
localhost provide a different timing uncovering more bugs.
@
text
@d2 1
a2 1
#	$OpenBSD$
d4 1
a4 1
# Copyright (c) 2010-2012 Alexander Bluhm <bluhm@@openbsd.org>
d136 1
a136 48
foreach ([ client => $c ], [ relayd => $r ], [ server => $s ]) {
	my($name, $proc) = @@$_;
	my $pattern = $args{$name}{loggrep} or next;
	$pattern = [ $pattern ] unless ref($pattern) eq 'ARRAY';
	foreach my $pat (@@$pattern) {
		if (ref($pat) eq 'HASH') {
			while (my($re, $num) = each %$pat) {
				my @@matches = $proc->loggrep($re);
				@@matches == $num or
				    die "$name matches @@matches: $re => $num";
			}
		} else {
			$proc->loggrep($pat)
			    or die "$name log missing pattern: $pat";
		}
	}
}

exit if $args{nocheck};

my @@clen = $c->loggrep(qr/^LEN: /) or die "no client len"
    unless $args{client}{nocheck};
my @@slen = $s->loggrep(qr/^LEN: /) or die "no server len"
    unless $args{server}{nocheck};
!@@clen || !@@slen || @@clen ~~ @@slen
    or die "client: @@clen", "server: @@slen", "len mismatch";
!defined($args{len}) || !$clen[0] || $clen[0] eq "LEN: $args{len}\n"
    or die "client: $clen[0]", "len $args{len} expected";
!defined($args{len}) || !$slen[0] || $slen[0] eq "LEN: $args{len}\n"
    or die "server: $slen[0]", "len $args{len} expected";
foreach my $len (map { ref eq 'ARRAY' ? @@$_ : $_ } @@{$args{lengths} || []}) {
	my $clen = shift @@clen;
	$clen eq "LEN: $len\n"
	    or die "client: $clen", "len $len expected";
	my $slen = shift @@slen;
	$slen eq "LEN: $len\n"
	    or die "server: $slen", "len $len expected";
}

my $cmd5 = $c->loggrep(qr/^MD5: /) unless $args{client}{nocheck};
my $smd5 = $s->loggrep(qr/^MD5: /) unless $args{server}{nocheck};
!$cmd5 || !$smd5 || ref($args{md5}) eq 'ARRAY' || $cmd5 eq $smd5
    or die "client: $cmd5", "server: $smd5", "md5 mismatch";
my $md5 = ref($args{md5}) eq 'ARRAY' ? join('|', @@{$args{md5}}) : $args{md5};
!$md5 || !$cmd5 || $cmd5 =~ /^MD5: ($md5)$/
    or die "client: $cmd5", "md5 $md5 expected";
!$md5 || !$smd5 || $smd5 =~ /^MD5: ($md5)$/
    or die "server: $smd5", "md5 $md5 expected";
@

