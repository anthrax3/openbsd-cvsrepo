head	1.2;
access;
symbols
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.1.0.6
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.4
	OPENBSD_5_7_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2015.10.13.23.30.42;	author schwarze;	state Exp;
branches;
next	1.1;
commitid	A4ygCil1Mn9VDkml;

1.1
date	2014.12.19.04.57.11;	author schwarze;	state Exp;
branches;
next	;
commitid	bjUOzumNjzY2mijc;


desc
@@


1.2
log
@Reject the escape sequences \[uD800] to \[uDFFF] in the parser.
These surrogates are not valid Unicode codepoints,
so treat them just like any other undefined character escapes:
Warn about them and do not produce output.
Issue noticed while talking to stsp@@, semarie@@, and bentley@@.
@
text
@CHAR-UNICODE-INPUT(1)       General Commands Manual      CHAR-UNICODE-INPUT(1)



NNAAMMEE
       char-unicode-input - Unicode characters in the input file

DDEESSCCRRIIPPTTIIOONN
       lowest valid: <80>

   OOnnee--bbyyttee rraannggee

       U+0000   0x00   <NUL>?   lowest ASCII
       U+001f   0x1f   <US>?    highest ASCII control character
       U+007f   0x7f   <DEL>?   highest ASCII
                0x80   ?        leading lowest continuation
                0xbf   ?        leading highest continuation

   TTwwoo--bbyyttee rraannggee

       U+0000   0xc080     ??         lowest obfuscated ASCII
       U+007f   0xc1bf     ??         highest obfuscated ASCII
                0xc278     ?x         ASCII continuation
       U+0080   0xc280     <80><80>   lowest two-byte
                0xc2c380   ?`A       high continuation
       U+07FF   0xdfbf     <?><?>     highest two-byte

   TThhrreeee--bbyyttee rraannggee

       U+0000   0xe08080   ???      lowest obfuscated ASCII
       U+007f   0xe081bf   ???      highest obfuscated ASCII
       U+0080   0xe08280   ???      lowest obfuscated two-byte
       U+07FF   0xe09fbf   ???      highest obfuscated two-byte
       U+0800   0xe0a080   <?><?>   lowest three-byte
       U+0FFF   0xe0bfbf   <?><?>   end of first middle byte
       U+1000   0xe18080   <?><?>   begin of second middle byte
       U+CFFF   0xecbfbf   <?><?>   end of last normal middle byte
       U+D000   0xed8080   <?><?>   begin of strange middle byte
       U+D7FF   0xed9fbf   <?><?>   highest public three-byte
       U+D800   0xeda080   ???      lowest surrogate
       U+DFFF   0xedbfbf   ???      highest surrogate
       U+E000   0xee8080   <?><?>   lowest private use
       U+FFFF   0xefbfbf   <?><?>   highest three-byte

   FFoouurr--bbyyttee rraannggee

       U+0000     0xf0808080     ????     lowest obfuscated ASCII
       U+007f     0xf08081bf     ????     highest obfuscated ASCII
       U+0080     0xf0808280     ????     lowest obfuscated two-byte
       U+07FF     0xf0809fbf     ????     highest obfuscated two-byte
       U+0800     0xf080a080     ????     lowest obfuscated three-byte
       U+FFFF     0xf08fbfbf     ????     highest obfuscated three-byte
       U+10000    0xf0908080     <?><?>   lowest four-byte
       U+3FFFF    0xf0bfbfbf     <?><?>   end of first middle byte
       U+40000    0xf1808080     <?><?>   second middle byte
       U+FFFFF    0xf3bfbfbf     <?><?>   last normal middle byte
       U+100000   0xf4808080     <?><?>   strange middle byte
       U+10FFFF   0xf48fbfbf     <?><?>   last valid four-byte
       U+110000   0xf4908080     ????     lowest beyond Unicode
       U+13FFFF   0xf4bfbfbf     ????     end of strange middle byte
       U+140000   0xf5808080     ????     lowest invalid middle byte
       U+1FFFFF   0xf7bfbfbf     ????     highest four-byte
       U+200000   0xf888808080   ?????    lowest five-byte



OpenBSD                        December 19, 2014         CHAR-UNICODE-INPUT(1)
@


1.1
log
@Rewrite the low-level UTF-8 parser from scratch.
It accepted invalid byte sequences like 0xc080-c1bf, 0xe08080-e09fbf,
0xeda080-edbfbf, and 0xf0808080-f08fbfbf, produced valid roff Unicode
escape sequences from them, and the algorithm contained strong
defenses against any attempt to fix it.

This cures an assertion failure in the terminal formatter caused
by sneaking in ASCII 0x08 (backspace) by "encoding" it as an (invalid)
multibyte UTF-8 sequence, found by jsg@@ with afl.

As a bonus, the new algorithm also reduces the code in the function
by about 20%.
@
text
@d40 2
a41 2
       U+D800   0xeda080   <?>???   lowest surrogate
       U+DFFF   0xedbfbf   <?>???   highest surrogate
@

