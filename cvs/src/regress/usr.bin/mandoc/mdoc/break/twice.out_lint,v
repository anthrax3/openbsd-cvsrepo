head	1.5;
access;
symbols
	OPENBSD_6_0:1.4.0.8
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4;
locks; strict;
comment	@# @;


1.5
date	2017.02.16.09.47.10;	author schwarze;	state Exp;
branches;
next	1.4;
commitid	CGH7SijTvfRoSBIL;

1.4
date	2015.02.12.13.52.12;	author schwarze;	state Exp;
branches;
next	1.3;
commitid	YdleMpqIEn5SQL56;

1.3
date	2015.02.02.18.26.06;	author schwarze;	state Exp;
branches;
next	1.2;
commitid	JF1v3mbtU0RfAJKN;

1.2
date	2015.02.02.04.26.03;	author schwarze;	state Exp;
branches;
next	1.1;
commitid	aVQDMaIveEZUjjaV;

1.1
date	2014.12.22.23.26.20;	author schwarze;	state Exp;
branches;
next	;
commitid	7lnT7ht5X6HoJfAt;


desc
@@


1.5
log
@Fix block scoping error if an explicit block is broken by two
implicit blocks (.Aq Bq Po .Pc) that left the outer breaker open
and could in exceptional cases, like between .Bl and .It, cause
tree corruption leading to NULL dereference.
Found by tb@@ with afl(1).

While here, do not mark intermediate ENDBODY markers as broken.
@
text
@mandoc: twice.in:12:2: WARNING: blocks badly nested: Bro breaks Ao
mandoc: twice.in:13:2: WARNING: blocks badly nested: Bo breaks Ao
mandoc: twice.in:19:12: WARNING: blocks badly nested: Bro breaks Aq
mandoc: twice.in:19:19: WARNING: blocks badly nested: Bo breaks Aq
mandoc: twice.in:25:2: WARNING: blocks badly nested: Bo breaks Ao
mandoc: twice.in:26:2: WARNING: blocks badly nested: Bo breaks Ao
mandoc: twice.in:32:11: WARNING: blocks badly nested: Bo breaks Aq
mandoc: twice.in:32:17: WARNING: blocks badly nested: Bo breaks Aq
mandoc: twice.in:36:8: WARNING: blocks badly nested: Bq breaks Po
mandoc: twice.in:36:2: WARNING: blocks badly nested: Aq breaks Po
mandoc: twice.in:36:2: WARNING: moving content out of list: Aq
@


1.4
log
@After almost five years and 92 revisions, mdoc_macro.c rev. 1.139
finally fixed the four issues explained in the mdoc_macro.c rev. 1.47
commit message.
@
text
@d9 3
@


1.3
log
@Simplify: Do not call rew_dohalt() from make_pending(),
the calling macro handler already found the breaking block.
No functional change except tiny variations in error messages.
@
text
@d1 8
a8 3
mandoc: twice.in:10:2: WARNING: blocks badly nested: Po breaks Ao
mandoc: twice.in:12:2: ERROR: skipping end of block that is not open: Pc
mandoc: twice.in:13:2: WARNING: blocks badly nested: Ao breaks Bo
@


1.2
log
@Get rid of all calls to rew_sub() in blk_exp_close(); only ten calls
remain in other functions.  As a bonus, this fixes an assertion failure
jsg@@ found some time ago with afl (test case 982) and improves minor
details in error reporting.
@
text
@d1 1
a1 1
mandoc: twice.in:10:2: WARNING: blocks badly nested: Pc breaks Ao
d3 1
a3 1
mandoc: twice.in:13:2: WARNING: blocks badly nested: Ac breaks Bo
@


1.1
log
@The code already pays attention not to close the same block twice.
Similarly, avoid having the same block break two other blocks.
In some situations, this could lead to an endless loop in rew_sub()
found by jsg@@ with afl.
Minimal example:  .Po Ao Pc Bo Pc Ac Bc
@
text
@d2 1
@

