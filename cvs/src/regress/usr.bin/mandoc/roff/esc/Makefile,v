head	1.13;
access;
symbols
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.11.0.10
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.6
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.10.0.4
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.3.0.10
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3;
locks; strict;
comment	@# @;


1.13
date	2017.06.14.18.23.26;	author schwarze;	state Exp;
branches;
next	1.12;
commitid	U7H8okNRL1PyBwPc;

1.12
date	2017.06.14.01.31.19;	author schwarze;	state Exp;
branches;
next	1.11;
commitid	PPUZg39EU736tntb;

1.11
date	2015.04.29.18.32.57;	author schwarze;	state Exp;
branches;
next	1.10;
commitid	Jraw3F5Czk5tAif5;

1.10
date	2015.01.21.20.20.49;	author schwarze;	state Exp;
branches;
next	1.9;
commitid	oPCJQka1zVKJ04b2;

1.9
date	2015.01.01.18.10.09;	author schwarze;	state Exp;
branches;
next	1.8;
commitid	KrvHfL0MlExM8p3R;

1.8
date	2014.12.03.01.06.22;	author schwarze;	state Exp;
branches;
next	1.7;
commitid	3T5929dMFXDa6Arl;

1.7
date	2014.12.02.10.07.17;	author schwarze;	state Exp;
branches;
next	1.6;
commitid	G1dK13T4nePhhgx3;

1.6
date	2014.08.14.01.58.51;	author schwarze;	state Exp;
branches;
next	1.5;
commitid	I195DFC5p2b9CR9i;

1.5
date	2014.07.06.19.08.57;	author schwarze;	state Exp;
branches;
next	1.4;
commitid	rolX8OitNNoUBJoD;

1.4
date	2014.04.08.01.36.50;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2012.05.28.22.45.34;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2012.05.28.17.08.48;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2012.05.28.13.00.51;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.13
log
@let \l use the right fill character
@
text
@# $OpenBSD: Makefile,v 1.12 2017/06/14 01:31:19 schwarze Exp $

REGRESS_TARGETS = one two multi B c c_man e f h l o p w z ignore
LINT_TARGETS	= B h l w ignore

.include <bsd.regress.mk>
@


1.12
log
@implement the roff(7) \p (break output line) escape sequence
@
text
@d1 1
a1 1
# $OpenBSD: Makefile,v 1.11 2015/04/29 18:32:57 schwarze Exp $
d3 2
a4 2
REGRESS_TARGETS = one two multi B c c_man e f h o p w z ignore
LINT_TARGETS	= B h w ignore
@


1.11
log
@Replace the kludge for the \z escape sequence by an actual
implementation.  As a side effect, minus ten lines of code.

As another side effect, this also fixes the assertion failure that
used to be triggered by "\z\o'ab'c" at the beginning of an output
line, found by jsg@@ with afl (test case 022/Apr27).
@
text
@d1 1
a1 1
# $OpenBSD: Makefile,v 1.10 2015/01/21 20:20:49 schwarze Exp $
d3 1
a3 1
REGRESS_TARGETS = one two multi B c c_man e f h o w z ignore
@


1.10
log
@Rudimentary implementation of the roff(7) \o escape sequence (overstrike).
This is of some relevance because the pod2man(1) preamble abuses it
for the icelandic letter Thorn, instead of simply using \(TP and \(Tp.
Missing feature found by sthen@@ in DateTime::Locale::is_IS(3p).
@
text
@d1 1
a1 1
# $OpenBSD: Makefile,v 1.9 2015/01/01 18:10:09 schwarze Exp $
a4 10

# Postprocessing to remove "character backspace" sequences
# unless they are followed by the same character again.
# This removes underlining as well, so we mustn't use it.
# Cannot use /g because matches progress backwards.

z.out_ascii: z.in
	${NROFF} ${NOPTS} -Tascii ${.ALLSRC} | \
		perl -pe 'while (s/(.)\010(?!\1)//) {}' \
		> ${.TARGET}
@


1.9
log
@Fix a read buffer overrun triggered by trailing \s- or trailing \s+
without the required subsequent argument; found by jsg@@ with afl.
@
text
@d1 1
a1 1
# $OpenBSD: Makefile,v 1.8 2014/12/03 01:06:22 schwarze Exp $
d3 1
a3 1
REGRESS_TARGETS = one two multi B c c_man e f h w z ignore
@


1.8
log
@test backslash handling because it was on my todo list;
fortunately, it already seems to work
@
text
@d1 1
a1 1
# $OpenBSD: Makefile,v 1.7 2014/12/02 10:07:17 schwarze Exp $
d4 1
a4 1
LINT_TARGETS	= B h w
@


1.7
log
@Fix the implementation and documentation of \c (continue text input line).
In particular, make it work in no-fill mode, too.
Reminded by Carsten dot Kunze at arcor dot de (Heirloom roff).
@
text
@d1 1
a1 1
# $OpenBSD: Makefile,v 1.6 2014/08/14 01:58:51 schwarze Exp $
d3 1
a3 1
REGRESS_TARGETS = one two multi B c c_man f h w z ignore
@


1.6
log
@add missing NOPTS arguments
@
text
@d1 1
a1 1
# $OpenBSD: Makefile,v 1.5 2014/07/06 19:08:57 schwarze Exp $
d3 1
a3 1
REGRESS_TARGETS = one two multi B c f h w z ignore
d7 1
a7 1
# unless they are foolowed by the same character again.
@


1.5
log
@Clean up messages related to plain text and to escape sequences.
* Mention invalid escape sequences and string names, and fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
# $OpenBSD: Makefile,v 1.4 2014/04/08 01:36:50 schwarze Exp $
d12 1
a12 1
	${NROFF} ${.ALLSRC} | \
@


1.4
log
@Fully implement the \B (validate numerical expression) and
partially implement the \w (measure text width) escape sequence
in a way that makes them usable in numerical expressions and in
conditional requests, similar to how \n (interpolate number register)
and \* (expand user-defined string) are implemented.

This lets mandoc(1) handle the baroque low-level roff code
found at the beginning of the ggrep(1) manual.
Thanks to pascal@@ for the report.
@
text
@d1 1
a1 1
# $OpenBSD: Makefile,v 1.3 2012/05/28 22:45:34 schwarze Exp $
d4 1
@


1.3
log
@While i already got my fingers dirty on mandoc_escape(),
profit of the occasion to pull out some spaghetti, that is,
three confusing variables and fourteen pointless assignments
among them; instead, always operate on the official pointers
**start, **end, and *sz, each of which conveys an obvious meaning.

No functional change intended, and the new tests confirm that
everything still (err...) "works", as far as that word can be
applied to the kind of roff(7) mock-up code i'm polishing here.
@
text
@d1 1
a1 1
# $OpenBSD: Makefile,v 1.2 2012/05/28 17:08:48 schwarze Exp $
d3 1
a3 1
REGRESS_TARGETS=one two multi c f h z ignore
@


1.2
log
@Make recursive parsing of roff(7) escapes actually work in the general case,
in particular when the inner escapes are preceded or followed by other terms.
While doing so, remove lots of bogus code that was trying to make pointless
distinctions between numeric and non-numeric escape sequences, while both
actually share the same syntax and we ignore the semantics anyway.

This prevents some of the strings defined in the pod2man(1) preamble
from producing garbage output, in particular in scandinavian words.
Of course, proper rendering of scandinavian national characters
cannot be expected even with these fixes.
@
text
@d1 1
a1 1
# $OpenBSD: Makefile,v 1.1 2012/05/28 13:00:51 schwarze Exp $
d3 1
a3 1
REGRESS_TARGETS=h z
@


1.1
log
@Implement the roff \z escape sequence, intended to output the next
character without advancing the cursor position; implement it to
simply skip the next character, as it will usually be overwritten.

With this change, the pod2man(1) preamble user-defined string \*:,
intended to render as a diaeresis or umlaut diacritic above the
preceding character, is rendered in a slightly less ugly way,
though still not correctly.  It was rendered as "z.." and is now
rendered as ".".

Given that the definition of \*: uses elaborate manual \h positioning,
there is little chance for mandoc(1) to ever render it correctly,
but at least we can refrain from printing out a spurious "z", and
we can make the \z do something semi-reasonable for easier cases.
@
text
@d1 1
a1 1
# $OpenBSD: Makefile,v 1.2 2011/11/17 16:28:46 schwarze Exp $
d3 1
a3 1
REGRESS_TARGETS=z
@

