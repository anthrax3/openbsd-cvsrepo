head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.8
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.4
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.1.0.6
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.2
	OPENBSD_5_7_BASE:1.1;
locks; strict;
comment	@# @;


1.4
date	2015.10.29.08.05.17;	author djm;	state Exp;
branches;
next	1.3;
commitid	JyIaoNZRULKzYEW6;

1.3
date	2015.10.26.02.50.58;	author dtucker;	state Exp;
branches;
next	1.2;
commitid	YEyz64iVub4FKR0G;

1.2
date	2015.09.24.06.16.53;	author djm;	state Exp;
branches;
next	1.1;
commitid	5OZyjCM8FhoxLlNA;

1.1
date	2015.01.13.07.49.49;	author djm;	state Exp;
branches;
next	;
commitid	RDFGhPj5IZQMm90n;


desc
@@


1.4
log
@regress test for "PubkeyAcceptedKeyTypes +..." inside a Match block
@
text
@#	$OpenBSD: limit-keytype.sh,v 1.3 2015/10/26 02:50:58 dtucker Exp $
#	Placed in the Public Domain.

tid="restrict pubkey type"

rm -f $OBJ/authorized_keys_$USER $OBJ/user_ca_key* $OBJ/user_key*
rm -f $OBJ/authorized_principals_$USER $OBJ/cert_user_key*

mv $OBJ/sshd_proxy $OBJ/sshd_proxy.orig
mv $OBJ/ssh_proxy $OBJ/ssh_proxy.orig

# Create a CA key
${SSHKEYGEN} -q -N '' -t ed25519  -f $OBJ/user_ca_key ||\
	fatal "ssh-keygen failed"

# Make some keys and a certificate.
${SSHKEYGEN} -q -N '' -t ed25519 -f $OBJ/user_key1 || \
	fatal "ssh-keygen failed"
${SSHKEYGEN} -q -N '' -t rsa -f $OBJ/user_key2 || \
	fatal "ssh-keygen failed"
${SSHKEYGEN} -q -N '' -t rsa -f $OBJ/user_key3 || \
	fatal "ssh-keygen failed"
${SSHKEYGEN} -q -N '' -t dsa -f $OBJ/user_key4 || \
	fatal "ssh-keygen failed"
${SSHKEYGEN} -q -s $OBJ/user_ca_key -I "regress user key for $USER" \
	-z $$ -n ${USER},mekmitasdigoat $OBJ/user_key3 ||
		fatal "couldn't sign user_key1"
# Copy the private key alongside the cert to allow better control of when
# it is offered.
mv $OBJ/user_key3-cert.pub $OBJ/cert_user_key3.pub

grep -v IdentityFile $OBJ/ssh_proxy.orig > $OBJ/ssh_proxy

opts="-oProtocol=2 -F $OBJ/ssh_proxy -oIdentitiesOnly=yes"
certopts="$opts -i $OBJ/user_key3 -oCertificateFile=$OBJ/cert_user_key3.pub"

echo mekmitasdigoat > $OBJ/authorized_principals_$USER
cat $OBJ/user_key1.pub > $OBJ/authorized_keys_$USER
cat $OBJ/user_key2.pub >> $OBJ/authorized_keys_$USER

prepare_config() {
	(
		grep -v "Protocol"  $OBJ/sshd_proxy.orig
		echo "Protocol 2"
		echo "AuthenticationMethods publickey"
		echo "TrustedUserCAKeys $OBJ/user_ca_key.pub"
		echo "AuthorizedPrincipalsFile $OBJ/authorized_principals_%u"
		for x in "$@@" ; do
			echo "$x"
		done
 	) > $OBJ/sshd_proxy
}

prepare_config

# Check we can log in with all key types.
${SSH} $certopts proxy true || fatal "cert failed"
${SSH} $opts -i $OBJ/user_key1 proxy true || fatal "key1 failed"
${SSH} $opts -i $OBJ/user_key2 proxy true || fatal "key2 failed"

# Allow plain Ed25519 and RSA. The certificate should fail.
verbose "allow rsa,ed25519"
prepare_config "PubkeyAcceptedKeyTypes ssh-rsa,ssh-ed25519"
${SSH} $certopts proxy true && fatal "cert succeeded"
${SSH} $opts -i $OBJ/user_key1 proxy true || fatal "key1 failed"
${SSH} $opts -i $OBJ/user_key2 proxy true || fatal "key2 failed"

# Allow Ed25519 only.
verbose "allow ed25519"
prepare_config "PubkeyAcceptedKeyTypes ssh-ed25519"
${SSH} $certopts proxy true && fatal "cert succeeded"
${SSH} $opts -i $OBJ/user_key1 proxy true || fatal "key1 failed"
${SSH} $opts -i $OBJ/user_key2 proxy true && fatal "key2 succeeded"

# Allow all certs. Plain keys should fail.
verbose "allow cert only"
prepare_config "PubkeyAcceptedKeyTypes ssh-*-cert-v01@@openssh.com"
${SSH} $certopts proxy true || fatal "cert failed"
${SSH} $opts -i $OBJ/user_key1 proxy true && fatal "key1 succeeded"
${SSH} $opts -i $OBJ/user_key2 proxy true && fatal "key2 succeeded"

# Allow RSA in main config, Ed25519 for non-existent user.
verbose "match w/ no match"
prepare_config "PubkeyAcceptedKeyTypes ssh-rsa" \
	"Match user x$USER" "PubkeyAcceptedKeyTypes +ssh-ed25519"
${SSH} $certopts proxy true && fatal "cert succeeded"
${SSH} $opts -i $OBJ/user_key1 proxy true && fatal "key1 succeeded"
${SSH} $opts -i $OBJ/user_key2 proxy true || fatal "key2 failed"

# Allow only DSA in main config, Ed25519 for user.
verbose "match w/ matching"
prepare_config "PubkeyAcceptedKeyTypes ssh-dss" \
	"Match user $USER" "PubkeyAcceptedKeyTypes +ssh-ed25519"
${SSH} $certopts proxy true || fatal "cert failed"
${SSH} $opts -i $OBJ/user_key1 proxy true || fatal "key1 failed"
${SSH} $opts -i $OBJ/user_key4 proxy true && fatal "key4 succeeded"

@


1.3
log
@Fix typo certopt->certopts in shell variable.  This would cause the test to
hang at a host key prompt if you have an A or CNAME for "proxy" in your local
domain.
@
text
@d1 1
a1 1
#	$OpenBSD: limit-keytype.sh,v 1.2 2015/09/24 06:16:53 djm Exp $
d23 2
d81 16
@


1.2
log
@regress test for CertificateFile; patch from Meghana Bhat via bz#2436
@
text
@d1 1
a1 1
#	$OpenBSD: limit-keytype.sh,v 1.1 2015/01/13 07:49:49 djm Exp $
d62 1
a62 1
${SSH} $certopt proxy true && fatal "cert succeeded"
@


1.1
log
@regress test for PubkeyAcceptedKeyTypes; ok markus@@
@
text
@d1 1
a1 1
#	$OpenBSD$
a28 1
cp -p $OBJ/user_key3 $OBJ/cert_user_key3
d33 1
a33 1
fullopts="$opts -i $OBJ/cert_user_key3 -i $OBJ/user_key1 -i $OBJ/user_key2"
d55 1
a55 1
${SSH} $opts -i $OBJ/cert_user_key3 proxy true || fatal "cert failed"
d60 1
a60 1
verbose "privsep=$privsep allow rsa,ed25519"
d62 1
a62 1
${SSH} $opts -i $OBJ/cert_user_key3 proxy true && fatal "cert succeeded"
d67 1
a67 1
verbose "privsep=$privsep allow ed25519"
d69 1
a69 1
${SSH} $opts -i $OBJ/cert_user_key3 proxy true && fatal "cert succeeded"
d74 1
a74 1
verbose "privsep=$privsep allow cert only"
d76 1
a76 1
${SSH} $opts -i $OBJ/cert_user_key3 proxy true || fatal "cert failed"
@

