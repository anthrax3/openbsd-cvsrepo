head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.4
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.4.0.10
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.6
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.5
date	2017.04.30.23.33.48;	author djm;	state Exp;
branches;
next	1.4;
commitid	9mApJQ1q88FyYy7a;

1.4
date	2015.03.31.22.59.01;	author djm;	state Exp;
branches;
next	1.3;
commitid	H5t5ScULmIpJu6O0;

1.3
date	2015.03.07.04.41.48;	author djm;	state Exp;
branches;
next	1.2;
commitid	0Q3XmPYK0JM0q3jm;

1.2
date	2015.03.04.23.22.35;	author djm;	state Exp;
branches;
next	1.1;
commitid	A33yiKxZ9eQznM4u;

1.1
date	2015.02.16.22.18.34;	author djm;	state Exp;
branches;
next	;
commitid	RB7y1XtwYCQ2S0Zm;


desc
@@


1.5
log
@remove SSHv1 support from unit tests
@
text
@/* 	$OpenBSD: test_iterate.c,v 1.4 2015/03/31 22:59:01 djm Exp $ */
/*
 * Regress test for hostfile.h hostkeys_foreach()
 *
 * Placed in the public domain
 */

#include <sys/types.h>
#include <sys/param.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "test_helper.h"

#include "sshkey.h"
#include "authfile.h"
#include "hostfile.h"

struct expected {
	const char *key_file;		/* Path for key, NULL for none */
	int no_parse_status;		/* Expected status w/o key parsing */
	int no_parse_keytype;		/* Expected keytype w/o key parsing */
	int match_host_p;		/* Match 'prometheus.example.com' */
	int match_host_s;		/* Match 'sisyphus.example.com' */
	int match_ipv4;			/* Match '192.0.2.1' */
	int match_ipv6;			/* Match '2001:db8::1' */
	int match_flags;		/* Expected flags from match */
	struct hostkey_foreach_line l;	/* Expected line contents */
};

struct cbctx {
	const struct expected *expected;
	size_t nexpected;
	size_t i;
	int flags;
	int match_host_p;
	int match_host_s;
	int match_ipv4;
	int match_ipv6;
};

/*
 * hostkeys_foreach() iterator callback that verifies the line passed
 * against an array of expected entries.
 */
static int
check(struct hostkey_foreach_line *l, void *_ctx)
{
	struct cbctx *ctx = (struct cbctx *)_ctx;
	const struct expected *expected;
	int parse_key = (ctx->flags & HKF_WANT_PARSE_KEY) != 0;
	const int matching = (ctx->flags & HKF_WANT_MATCH) != 0;
	u_int expected_status, expected_match;
	int expected_keytype;

	test_subtest_info("entry %zu/%zu, file line %ld",
	    ctx->i + 1, ctx->nexpected, l->linenum);

	for (;;) {
		ASSERT_SIZE_T_LT(ctx->i, ctx->nexpected);
		expected = ctx->expected + ctx->i++;
		/* If we are matching host/IP then skip entries that don't */
		if (!matching)
			break;
		if (ctx->match_host_p && expected->match_host_p)
			break;
		if (ctx->match_host_s && expected->match_host_s)
			break;
		if (ctx->match_ipv4 && expected->match_ipv4)
			break;
		if (ctx->match_ipv6 && expected->match_ipv6)
			break;
	}
	expected_status = (parse_key || expected->no_parse_status < 0) ?
	    expected->l.status : (u_int)expected->no_parse_status;
	expected_match = expected->l.match;
#define UPDATE_MATCH_STATUS(x) do { \
		if (ctx->x && expected->x) { \
			expected_match |= expected->x; \
			if (expected_status == HKF_STATUS_OK) \
				expected_status = HKF_STATUS_MATCHED; \
		} \
	} while (0)
	expected_keytype = (parse_key || expected->no_parse_keytype < 0) ?
	    expected->l.keytype : expected->no_parse_keytype;

	UPDATE_MATCH_STATUS(match_host_p);
	UPDATE_MATCH_STATUS(match_host_s);
	UPDATE_MATCH_STATUS(match_ipv4);
	UPDATE_MATCH_STATUS(match_ipv6);

	ASSERT_PTR_NE(l->path, NULL); /* Don't care about path */
	ASSERT_LONG_LONG_EQ(l->linenum, expected->l.linenum);
	ASSERT_U_INT_EQ(l->status, expected_status);
	ASSERT_U_INT_EQ(l->match, expected_match);
	/* Not all test entries contain fulltext */
	if (expected->l.line != NULL)
		ASSERT_STRING_EQ(l->line, expected->l.line);
	ASSERT_INT_EQ(l->marker, expected->l.marker);
	/* XXX we skip hashed hostnames for now; implement checking */
	if (expected->l.hosts != NULL)
		ASSERT_STRING_EQ(l->hosts, expected->l.hosts);
	/* Not all test entries contain raw keys */
	if (expected->l.rawkey != NULL)
		ASSERT_STRING_EQ(l->rawkey, expected->l.rawkey);
	/* XXX synthesise raw key for cases lacking and compare */
	ASSERT_INT_EQ(l->keytype, expected_keytype);
	if (parse_key) {
		if (expected->l.key == NULL)
			ASSERT_PTR_EQ(l->key, NULL);
		if (expected->l.key != NULL) {
			ASSERT_PTR_NE(l->key, NULL);
			ASSERT_INT_EQ(sshkey_equal(l->key, expected->l.key), 1);
		}
	}
	if (parse_key && !(l->comment == NULL && expected->l.comment == NULL))
		ASSERT_STRING_EQ(l->comment, expected->l.comment);
	return 0;
}

/* Loads public keys for a set of expected results */
static void
prepare_expected(struct expected *expected, size_t n)
{
	size_t i;

	for (i = 0; i < n; i++) {
		if (expected[i].key_file == NULL)
			continue;
		ASSERT_INT_EQ(sshkey_load_public(
		    test_data_file(expected[i].key_file), &expected[i].l.key,
		    NULL), 0);
	}
}

struct expected expected_full[] = {
	{ NULL, -1, -1, 0, 0, 0, 0, -1, {
		NULL,				/* path, don't care */
		1,				/* line number */
		HKF_STATUS_COMMENT,		/* status */
		0,				/* match flags */
		"# Plain host keys, plain host names", /* full line, optional */
		MRK_NONE,			/* marker (CA / revoked) */
		NULL,				/* hosts text */
		NULL,				/* raw key, optional */
		KEY_UNSPEC,			/* key type */
		NULL,				/* deserialised key */
		NULL,				/* comment */
	} },
	{ "dsa_1.pub" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {
		NULL,
		2,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		"sisyphus.example.com",
		NULL,
		KEY_DSA,
		NULL,	/* filled at runtime */
		"DSA #1",
	} },
	{ "ecdsa_1.pub" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {
		NULL,
		3,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		"sisyphus.example.com",
		NULL,
		KEY_ECDSA,
		NULL,	/* filled at runtime */
		"ECDSA #1",
	} },
	{ "ed25519_1.pub" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {
		NULL,
		4,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		"sisyphus.example.com",
		NULL,
		KEY_ED25519,
		NULL,	/* filled at runtime */
		"ED25519 #1",
	} },
	{ "rsa_1.pub" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {
		NULL,
		5,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		"sisyphus.example.com",
		NULL,
		KEY_RSA,
		NULL,	/* filled at runtime */
		"RSA #1",
	} },
	{ NULL, -1, -1, 0, 0, 0, 0, -1, {
		NULL,
		6,
		HKF_STATUS_COMMENT,
		0,
		"",
		MRK_NONE,
		NULL,
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ NULL, -1, -1, 0, 0, 0, 0, -1, {
		NULL,
		7,
		HKF_STATUS_COMMENT,
		0,
		"# Plain host keys, hostnames + addresses",
		MRK_NONE,
		NULL,
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ "dsa_2.pub" , -1, -1, HKF_MATCH_HOST, 0, HKF_MATCH_IP, HKF_MATCH_IP, -1, {
		NULL,
		8,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		"prometheus.example.com,192.0.2.1,2001:db8::1",
		NULL,
		KEY_DSA,
		NULL,	/* filled at runtime */
		"DSA #2",
	} },
	{ "ecdsa_2.pub" , -1, -1, HKF_MATCH_HOST, 0, HKF_MATCH_IP, HKF_MATCH_IP, -1, {
		NULL,
		9,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		"prometheus.example.com,192.0.2.1,2001:db8::1",
		NULL,
		KEY_ECDSA,
		NULL,	/* filled at runtime */
		"ECDSA #2",
	} },
	{ "ed25519_2.pub" , -1, -1, HKF_MATCH_HOST, 0, HKF_MATCH_IP, HKF_MATCH_IP, -1, {
		NULL,
		10,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		"prometheus.example.com,192.0.2.1,2001:db8::1",
		NULL,
		KEY_ED25519,
		NULL,	/* filled at runtime */
		"ED25519 #2",
	} },
	{ "rsa_2.pub" , -1, -1, HKF_MATCH_HOST, 0, HKF_MATCH_IP, HKF_MATCH_IP, -1, {
		NULL,
		11,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		"prometheus.example.com,192.0.2.1,2001:db8::1",
		NULL,
		KEY_RSA,
		NULL,	/* filled at runtime */
		"RSA #2",
	} },
	{ NULL, -1, -1, 0, 0, 0, 0, -1, {
		NULL,
		12,
		HKF_STATUS_COMMENT,
		0,
		"",
		MRK_NONE,
		NULL,
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ NULL, -1, -1, 0, 0, 0, 0, -1, {
		NULL,
		13,
		HKF_STATUS_COMMENT,
		0,
		"# Some hosts with wildcard names / IPs",
		MRK_NONE,
		NULL,
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ "dsa_3.pub" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, HKF_MATCH_IP, HKF_MATCH_IP, -1, {
		NULL,
		14,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		"*.example.com,192.0.2.*,2001:*",
		NULL,
		KEY_DSA,
		NULL,	/* filled at runtime */
		"DSA #3",
	} },
	{ "ecdsa_3.pub" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, HKF_MATCH_IP, HKF_MATCH_IP, -1, {
		NULL,
		15,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		"*.example.com,192.0.2.*,2001:*",
		NULL,
		KEY_ECDSA,
		NULL,	/* filled at runtime */
		"ECDSA #3",
	} },
	{ "ed25519_3.pub" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, HKF_MATCH_IP, HKF_MATCH_IP, -1, {
		NULL,
		16,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		"*.example.com,192.0.2.*,2001:*",
		NULL,
		KEY_ED25519,
		NULL,	/* filled at runtime */
		"ED25519 #3",
	} },
	{ "rsa_3.pub" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, HKF_MATCH_IP, HKF_MATCH_IP, -1, {
		NULL,
		17,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		"*.example.com,192.0.2.*,2001:*",
		NULL,
		KEY_RSA,
		NULL,	/* filled at runtime */
		"RSA #3",
	} },
	{ NULL, -1, -1, 0, 0, 0, 0, -1, {
		NULL,
		18,
		HKF_STATUS_COMMENT,
		0,
		"",
		MRK_NONE,
		NULL,
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ NULL, -1, -1, 0, 0, 0, 0, -1, {
		NULL,
		19,
		HKF_STATUS_COMMENT,
		0,
		"# Hashed hostname and address entries",
		MRK_NONE,
		NULL,
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ "dsa_5.pub" , -1, -1, 0, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, -1, {
		NULL,
		20,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_DSA,
		NULL,	/* filled at runtime */
		"DSA #5",
	} },
	{ "ecdsa_5.pub" , -1, -1, 0, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, -1, {
		NULL,
		21,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_ECDSA,
		NULL,	/* filled at runtime */
		"ECDSA #5",
	} },
	{ "ed25519_5.pub" , -1, -1, 0, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, -1, {
		NULL,
		22,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_ED25519,
		NULL,	/* filled at runtime */
		"ED25519 #5",
	} },
	{ "rsa_5.pub" , -1, -1, 0, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, -1, {
		NULL,
		23,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_RSA,
		NULL,	/* filled at runtime */
		"RSA #5",
	} },
	{ NULL, -1, -1, 0, 0, 0, 0, -1, {
		NULL,
		24,
		HKF_STATUS_COMMENT,
		0,
		"",
		MRK_NONE,
		NULL,
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	/*
	 * The next series have each key listed multiple times, as the
	 * hostname and addresses in the pre-hashed known_hosts are split
	 * to separate lines.
	 */
	{ "dsa_6.pub" , -1, -1, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, 0, -1, {
		NULL,
		25,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_DSA,
		NULL,	/* filled at runtime */
		"DSA #6",
	} },
	{ "dsa_6.pub" , -1, -1, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, 0, -1, {
		NULL,
		26,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_DSA,
		NULL,	/* filled at runtime */
		"DSA #6",
	} },
	{ "dsa_6.pub" , -1, -1, 0, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, -1, {
		NULL,
		27,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_DSA,
		NULL,	/* filled at runtime */
		"DSA #6",
	} },
	{ "ecdsa_6.pub" , -1, -1, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, 0, -1, {
		NULL,
		28,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_ECDSA,
		NULL,	/* filled at runtime */
		"ECDSA #6",
	} },
	{ "ecdsa_6.pub" , -1, -1, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, 0, -1, {
		NULL,
		29,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_ECDSA,
		NULL,	/* filled at runtime */
		"ECDSA #6",
	} },
	{ "ecdsa_6.pub" , -1, -1, 0, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, -1, {
		NULL,
		30,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_ECDSA,
		NULL,	/* filled at runtime */
		"ECDSA #6",
	} },
	{ "ed25519_6.pub" , -1, -1, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, 0, -1, {
		NULL,
		31,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_ED25519,
		NULL,	/* filled at runtime */
		"ED25519 #6",
	} },
	{ "ed25519_6.pub" , -1, -1, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, 0, -1, {
		NULL,
		32,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_ED25519,
		NULL,	/* filled at runtime */
		"ED25519 #6",
	} },
	{ "ed25519_6.pub" , -1, -1, 0, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, -1, {
		NULL,
		33,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_ED25519,
		NULL,	/* filled at runtime */
		"ED25519 #6",
	} },
	{ "rsa_6.pub" , -1, -1, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, 0, -1, {
		NULL,
		34,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_RSA,
		NULL,	/* filled at runtime */
		"RSA #6",
	} },
	{ "rsa_6.pub" , -1, -1, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, 0, -1, {
		NULL,
		35,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_RSA,
		NULL,	/* filled at runtime */
		"RSA #6",
	} },
	{ "rsa_6.pub" , -1, -1, 0, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, -1, {
		NULL,
		36,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_RSA,
		NULL,	/* filled at runtime */
		"RSA #6",
	} },
	{ NULL, -1, -1, 0, 0, 0, 0, -1, {
		NULL,
		37,
		HKF_STATUS_COMMENT,
		0,
		"",
		MRK_NONE,
		NULL,
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ NULL, -1, -1, 0, 0, 0, 0, -1, {
		NULL,
		38,
		HKF_STATUS_COMMENT,
		0,
		"",
		MRK_NONE,
		NULL,
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ NULL, -1, -1, 0, 0, 0, 0, -1, {
		NULL,
		39,
		HKF_STATUS_COMMENT,
		0,
		"# Revoked and CA keys",
		MRK_NONE,
		NULL,
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ "ed25519_4.pub" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {
		NULL,
		40,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_REVOKE,
		"sisyphus.example.com",
		NULL,
		KEY_ED25519,
		NULL,	/* filled at runtime */
		"ED25519 #4",
	} },
	{ "ecdsa_4.pub" , -1, -1, HKF_MATCH_HOST, 0, 0, 0, -1, {
		NULL,
		41,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_CA,
		"prometheus.example.com",
		NULL,
		KEY_ECDSA,
		NULL,	/* filled at runtime */
		"ECDSA #4",
	} },
	{ "dsa_4.pub" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, 0, 0, -1, {
		NULL,
		42,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_CA,
		"*.example.com",
		NULL,
		KEY_DSA,
		NULL,	/* filled at runtime */
		"DSA #4",
	} },
	{ NULL, -1, -1, 0, 0, 0, 0, -1, {
		NULL,
		43,
		HKF_STATUS_COMMENT,
		0,
		"",
		MRK_NONE,
		NULL,
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ NULL, -1, -1, 0, 0, 0, 0, -1, {
		NULL,
		44,
		HKF_STATUS_COMMENT,
		0,
		"# Some invalid lines",
		MRK_NONE,
		NULL,
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ NULL, -1, -1, 0, 0, 0, 0, -1, {
		NULL,
		45,
		HKF_STATUS_INVALID,
		0,
		NULL,
		MRK_ERROR,
		NULL,
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ NULL, -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {
		NULL,
		46,
		HKF_STATUS_INVALID,
		0,
		NULL,
		MRK_NONE,
		"sisyphus.example.com",
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ NULL, -1, -1, HKF_MATCH_HOST, 0, 0, 0, -1, {
		NULL,
		47,
		HKF_STATUS_INVALID,
		0,
		NULL,
		MRK_NONE,
		"prometheus.example.com",
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ NULL, -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {
		NULL,
		48,
		HKF_STATUS_INVALID,	/* Would be ok if key not parsed */
		0,
		NULL,
		MRK_NONE,
		"sisyphus.example.com",
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ NULL, -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {
		NULL,
		49,
		HKF_STATUS_INVALID,
		0,
		NULL,
		MRK_NONE,
		"sisyphus.example.com",
		NULL,
		KEY_UNSPEC,
		NULL,	/* filled at runtime */
		NULL,
	} },
	{ NULL, HKF_STATUS_OK, KEY_RSA, HKF_MATCH_HOST, 0, 0, 0, -1, {
		NULL,
		50,
		HKF_STATUS_INVALID,	/* Would be ok if key not parsed */
		0,
		NULL,
		MRK_NONE,
		"prometheus.example.com",
		NULL,
		KEY_UNSPEC,
		NULL,	/* filled at runtime */
		NULL,
	} },
};

void test_iterate(void);

void
test_iterate(void)
{
	struct cbctx ctx;

	TEST_START("hostkeys_iterate all with key parse");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = HKF_WANT_PARSE_KEY;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, NULL, NULL, ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate all without key parse");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = 0;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, NULL, NULL, ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate specify host 1");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = 0;
	ctx.match_host_p = 1;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "prometheus.example.com", NULL, ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate specify host 2");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = 0;
	ctx.match_host_s = 1;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "sisyphus.example.com", NULL, ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate match host 1");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = HKF_WANT_MATCH;
	ctx.match_host_p = 1;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "prometheus.example.com", NULL, ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate match host 2");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = HKF_WANT_MATCH;
	ctx.match_host_s = 1;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "sisyphus.example.com", NULL, ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate specify host missing");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = 0;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "actaeon.example.org", NULL, ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate match host missing");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = HKF_WANT_MATCH;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "actaeon.example.org", NULL, ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate specify IPv4");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = 0;
	ctx.match_ipv4 = 1;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "tiresias.example.org", "192.0.2.1", ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate specify IPv6");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = 0;
	ctx.match_ipv6 = 1;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "tiresias.example.org", "2001:db8::1", ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate match IPv4");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = HKF_WANT_MATCH;
	ctx.match_ipv4 = 1;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "tiresias.example.org", "192.0.2.1", ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate match IPv6");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = HKF_WANT_MATCH;
	ctx.match_ipv6 = 1;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "tiresias.example.org", "2001:db8::1", ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate specify addr missing");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = 0;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "tiresias.example.org", "192.168.0.1", ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate match addr missing");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = HKF_WANT_MATCH;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "tiresias.example.org", "::1", ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate specify host 2 and IPv4");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = 0;
	ctx.match_host_s = 1;
	ctx.match_ipv4 = 1;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "sisyphus.example.com", "192.0.2.1", ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate match host 1 and IPv6");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = HKF_WANT_MATCH;
	ctx.match_host_p = 1;
	ctx.match_ipv6 = 1;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "prometheus.example.com", "2001:db8::1", ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate specify host 2 and IPv4 w/ key parse");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = HKF_WANT_PARSE_KEY;
	ctx.match_host_s = 1;
	ctx.match_ipv4 = 1;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "sisyphus.example.com", "192.0.2.1", ctx.flags), 0);
	TEST_DONE();

	TEST_START("hostkeys_iterate match host 1 and IPv6 w/ key parse");
	memset(&ctx, 0, sizeof(ctx));
	ctx.expected = expected_full;
	ctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);
	ctx.flags = HKF_WANT_MATCH|HKF_WANT_PARSE_KEY;
	ctx.match_host_p = 1;
	ctx.match_ipv6 = 1;
	prepare_expected(expected_full, ctx.nexpected);
	ASSERT_INT_EQ(hostkeys_foreach(test_data_file("known_hosts"),
	    check, &ctx, "prometheus.example.com", "2001:db8::1", ctx.flags), 0);
	TEST_DONE();
}

@


1.4
log
@adapt to recent hostfile.c change: when parsing known_hosts without
fully parsing the keys therein, hostkeys_foreach() will now correctly
identify KEY_RSA1 keys; ok markus@@ miod@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: test_iterate.c,v 1.3 2015/03/07 04:41:48 djm Exp $ */
a88 8
#ifndef WITH_SSH1
	if (parse_key && (expected->l.keytype == KEY_RSA1 ||
	    expected->no_parse_keytype == KEY_RSA1)) {
		expected_status = HKF_STATUS_INVALID;
		expected_keytype = KEY_UNSPEC;
		parse_key = 0;
	}
#endif
a131 4
#ifndef WITH_SSH1
		if (expected[i].l.keytype == KEY_RSA1)
			continue;
#endif
d191 1
a191 1
	{ "rsa1_1.pub" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {
a199 13
		KEY_RSA1,
		NULL,	/* filled at runtime */
		"RSA1 #1",
	} },
	{ "rsa_1.pub" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {
		NULL,
		6,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		"sisyphus.example.com",
		NULL,
d206 1
a206 1
		7,
d219 1
a219 1
		8,
d232 1
a232 1
		9,
d245 1
a245 1
		10,
d258 1
a258 1
		11,
a268 13
	{ "rsa1_2.pub" , -1, -1, HKF_MATCH_HOST, 0, HKF_MATCH_IP, HKF_MATCH_IP, -1, {
		NULL,
		12,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		"prometheus.example.com,192.0.2.1,2001:db8::1",
		NULL,
		KEY_RSA1,
		NULL,	/* filled at runtime */
		"RSA1 #2",
	} },
d271 1
a271 1
		13,
d284 1
a284 1
		14,
d297 1
a297 1
		15,
d310 1
a310 1
		16,
d323 1
a323 1
		17,
d336 1
a336 1
		18,
a346 13
	{ "rsa1_3.pub" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, HKF_MATCH_IP, HKF_MATCH_IP, -1, {
		NULL,
		19,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		"*.example.com,192.0.2.*,2001:*",
		NULL,
		KEY_RSA1,
		NULL,	/* filled at runtime */
		"RSA1 #3",
	} },
d349 1
a349 1
		20,
d362 1
a362 1
		21,
d375 1
a375 1
		22,
d388 1
a388 1
		23,
d401 1
a401 1
		24,
d414 1
a414 1
		25,
a424 13
	{ "rsa1_5.pub" , -1, -1, 0, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, -1, {
		NULL,
		26,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_RSA1,
		NULL,	/* filled at runtime */
		"RSA1 #5",
	} },
d427 1
a427 1
		27,
d440 1
a440 1
		28,
d458 1
a458 1
		29,
d471 1
a471 1
		30,
d484 1
a484 1
		31,
d497 1
a497 1
		32,
d510 1
a510 1
		33,
d523 1
a523 1
		34,
d536 1
a536 1
		35,
d549 1
a549 1
		36,
d562 1
a562 1
		37,
a572 39
	{ "rsa1_6.pub" , -1, -1, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, 0, -1, {
		NULL,
		38,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_RSA1,
		NULL,	/* filled at runtime */
		"RSA1 #6",
	} },
	{ "rsa1_6.pub" , -1, -1, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, 0, -1, {
		NULL,
		39,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_RSA1,
		NULL,	/* filled at runtime */
		"RSA1 #6",
	} },
	{ "rsa1_6.pub" , -1, -1, 0, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, -1, {
		NULL,
		40,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_NONE,
		NULL,
		NULL,
		KEY_RSA1,
		NULL,	/* filled at runtime */
		"RSA1 #6",
	} },
d575 1
a575 1
		41,
d588 1
a588 1
		42,
d601 1
a601 1
		43,
d614 1
a614 1
		44,
d627 1
a627 1
		45,
d640 1
a640 1
		46,
a650 13
	{ "rsa1_4.pub" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {
		NULL,
		47,
		HKF_STATUS_OK,
		0,
		NULL,
		MRK_REVOKE,
		"sisyphus.example.com",
		NULL,
		KEY_RSA1,
		NULL,	/* filled at runtime */
		"RSA1 #4",
	} },
d653 1
a653 1
		48,
d666 1
a666 1
		49,
d679 1
a679 1
		50,
d692 1
a692 1
		51,
d705 1
a705 1
		52,
d718 1
a718 1
		53,
d731 1
a731 1
		54,
d744 1
a744 1
		55,
d757 1
a757 27
		56,
		HKF_STATUS_INVALID,	/* Would be ok if key not parsed */
		0,
		NULL,
		MRK_NONE,
		"sisyphus.example.com",
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ NULL, -1, -1, HKF_MATCH_HOST, 0, 0, 0, -1, {
		NULL,
		57,
		HKF_STATUS_INVALID,	/* Would be ok if key not parsed */
		0,
		NULL,
		MRK_NONE,
		"prometheus.example.com",
		NULL,
		KEY_UNSPEC,
		NULL,
		NULL,
	} },
	{ NULL, HKF_STATUS_OK, KEY_RSA1, 0, HKF_MATCH_HOST, 0, 0, -1, {
		NULL,
		58,
a767 13
	{ NULL, HKF_STATUS_OK, KEY_RSA1, HKF_MATCH_HOST, 0, 0, 0, -1, {
		NULL,
		59,
		HKF_STATUS_INVALID,	/* Would be ok if key not parsed */
		0,
		NULL,
		MRK_NONE,
		"prometheus.example.com",
		NULL,
		KEY_UNSPEC,
		NULL,	/* filled at runtime */
		NULL,
	} },
d770 1
a770 1
		60,
d783 1
a783 1
		61,
@


1.3
log
@unbreak for w/SSH1 (default) case; ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: test_iterate.c,v 1.2 2015/03/04 23:22:35 djm Exp $ */
d90 2
a91 2
	if (expected->l.keytype == KEY_RSA1 ||
	    expected->no_parse_keytype == KEY_RSA1) {
@


1.2
log
@make these work with !SSH1; ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: test_iterate.c,v 1.1 2015/02/16 22:18:34 djm Exp $ */
d140 1
d143 1
@


1.1
log
@unit tests for hostfile.c code, just hostkeys_foreach so far
@
text
@d1 1
a1 1
/* 	$OpenBSD$ */
d53 1
a53 1
	const int parse_key = (ctx->flags & HKF_WANT_PARSE_KEY) != 0;
d86 11
a100 2
	expected_keytype = (parse_key || expected->no_parse_keytype < 0) ?
	    expected->l.keytype : expected->no_parse_keytype;
d139 2
@

