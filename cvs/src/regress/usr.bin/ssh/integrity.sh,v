head	1.20;
access;
symbols
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7;
locks; strict;
comment	@# @;


1.20
date	2017.01.06.02.26.10;	author dtucker;	state Exp;
branches;
next	1.19;
commitid	xDlsJobmrqtCwN2v;

1.19
date	2016.11.25.02.56.49;	author dtucker;	state Exp;
branches;
next	1.18;
commitid	GBjpW35Acgyi33yX;

1.18
date	2016.03.04.02.48.06;	author dtucker;	state Exp;
branches;
next	1.17;
commitid	8KR1e4wQit7klCy1;

1.17
date	2016.03.03.00.46.53;	author dtucker;	state Exp;
branches;
next	1.16;
commitid	kHTRg5RumeZfYfRN;

1.16
date	2015.03.24.20.22.17;	author markus;	state Exp;
branches;
next	1.15;
commitid	gbmXWxEI6RvKxhBC;

1.15
date	2015.01.19.20.42.31;	author markus;	state Exp;
branches;
next	1.14;
commitid	jP3x8ECxueEv2uQo;

1.14
date	2014.05.21.07.04.21;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.21.22.15.37;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2013.11.21.03.18.51;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2013.11.07.02.48.38;	author dtucker;	state Exp;
branches;
next	1.10;

1.10
date	2013.05.17.01.32.11;	author dtucker;	state Exp;
branches;
next	1.9;

1.9
date	2013.04.07.02.16.03;	author dtucker;	state Exp;
branches;
next	1.8;

1.8
date	2013.04.06.06.00.22;	author dtucker;	state Exp;
branches;
next	1.7;

1.7
date	2013.02.20.08.27.50;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2013.02.19.02.14.09;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2013.02.18.22.26.47;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2013.02.17.23.16.55;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2013.02.16.06.08.45;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2013.01.12.11.23.53;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2012.12.11.22.42.11;	author markus;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Account for timeouts in the integrity tests as failures.

If the first test in a series for a given MAC happens to modify the low
bytes of a packet length, then ssh will time out and this will be
interpreted as a test failure.  Patch from cjwatson at debian.org via
bz#2658.
@
text
@#	$OpenBSD: integrity.sh,v 1.19 2016/11/25 02:56:49 dtucker Exp $
#	Placed in the Public Domain.

tid="integrity"
cp $OBJ/sshd_proxy $OBJ/sshd_proxy_bak

# start at byte 2900 (i.e. after kex) and corrupt at different offsets
tries=10
startoffset=2900
macs=`${SSH} -Q mac`
# The following are not MACs, but ciphers with integrated integrity. They are
# handled specially below.
macs="$macs `${SSH} -Q cipher-auth`"

# sshd-command for proxy (see test-exec.sh)
cmd="$SUDO sh ${SRC}/sshd-log-wrapper.sh ${TEST_SSHD_LOGFILE} ${SSHD} -i -f $OBJ/sshd_proxy"

for m in $macs; do
	trace "test $tid: mac $m"
	elen=0
	epad=0
	emac=0
	etmo=0
	ecnt=0
	skip=0
	for off in $(jot $tries $startoffset); do
		if [ $((skip--)) -gt 0 ]; then
			# avoid modifying the high bytes of the length
			continue
		fi
		cp $OBJ/sshd_proxy_bak $OBJ/sshd_proxy
		# modify output from sshd at offset $off
		pxy="proxycommand=$cmd | $OBJ/modpipe -wm xor:$off:1"
		if ${SSH} -Q cipher-auth | grep "^${m}\$" >/dev/null 2>&1 ; then
			echo "Ciphers=$m" >> $OBJ/sshd_proxy
			macopt="-c $m"
		else
			echo "Ciphers=aes128-ctr" >> $OBJ/sshd_proxy
			echo "MACs=$m" >> $OBJ/sshd_proxy
			macopt="-m $m -c aes128-ctr"
		fi
		verbose "test $tid: $m @@$off"
		${SSH} $macopt -2F $OBJ/ssh_proxy -o "$pxy" \
		    -oServerAliveInterval=1 -oServerAliveCountMax=30 \
		    999.999.999.999 'printf "%4096s" " "' >/dev/null
		if [ $? -eq 0 ]; then
			fail "ssh -m $m succeeds with bit-flip at $off"
		fi
		ecnt=$((ecnt+1))
		out=$(egrep -v "^debug" $TEST_SSH_LOGFILE | tail -2 | \
		     tr -s '\r\n' '.')
		case "$out" in
		Bad?packet*)	elen=$((elen+1)); skip=2;;
		Corrupted?MAC* | *message?authentication?code?incorrect*)
				emac=$((emac+1)); skip=0;;
		padding*)	epad=$((epad+1)); skip=0;;
		*)		fail "unexpected error mac $m at $off: $out";;
		esac
	done
	verbose "test $tid: $ecnt errors: mac $emac padding $epad length $elen"
	if [ $emac -eq 0 ]; then
		fail "$m: no mac errors"
	fi
	expect=$((ecnt-epad-elen))
	if [ $emac -ne $expect ]; then
		fail "$m: expected $expect mac errors, got $emac"
	fi
done
@


1.19
log
@Reverse args to sshd-log-wrapper.  Matches change in portable, where it
allows sshd do be optionally run under Valgrind.
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.18 2016/03/04 02:48:06 dtucker Exp $
a7 2
# XXX the test hangs if we modify the low bytes of the packet length
# XXX and ssh tries to read...
d23 1
@


1.18
log
@Filter debug messages out of log before picking the last two lines.
Should prevent problems if any more debug output is added late in the
connection.
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.17 2016/03/03 00:46:53 dtucker Exp $
d18 1
a18 1
cmd="sh ${SRC}/sshd-log-wrapper.sh ${SSHD} ${TEST_SSHD_LOGFILE} -i -f $OBJ/sshd_proxy"
@


1.17
log
@Look back 3 lines for possible error messages.  Changes to the code mean
that "Bad packet length" errors are 3 lines back instead of the previous
two, which meant we didn't skip some offsets that we intended to.
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.16 2015/03/24 20:22:17 markus Exp $
d51 1
a51 1
		out=$(tail -3 $TEST_SSH_LOGFILE | egrep -v "^debug" | \
@


1.16
log
@use ${SSH} for -Q instead of installed ssh
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.15 2015/01/19 20:42:31 markus Exp $
d51 1
a51 1
		out=$(tail -2 $TEST_SSH_LOGFILE | egrep -v "^debug" | \
@


1.15
log
@adapt to new error message (SSH_ERR_MAC_INVALID)
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.14 2014/05/21 07:04:21 djm Exp $
d35 1
a35 1
		if ssh -Q cipher-auth | grep "^${m}\$" >/dev/null 2>&1 ; then
@


1.14
log
@when failing because of unexpected output, show the offending output
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.13 2014/04/21 22:15:37 djm Exp $
d55 1
a55 1
		Corrupted?MAC* | Decryption?integrity?check?failed*)
@


1.13
log
@repair regress tests broken by server-side default cipher/kex/mac changes
by ensuring that the option under test is included in the server's
algorithm list
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.12 2013/11/21 03:18:51 djm Exp $
d51 1
a51 1
		output=$(tail -2 $TEST_SSH_LOGFILE | egrep -v "^debug" | \
d53 1
a53 1
		case "$output" in
d58 1
a58 1
		*)		fail "unexpected error mac $m at $off";;
@


1.12
log
@use new "ssh -Q cipher-auth" query to obtain lists of authenticated
encryption ciphers instead of specifying them manually; ensures that
the new chacha20poly1305@@openssh.com mode is tested;

ok markus@@ and naddy@@ as part of the diff to add
chacha20poly1305@@openssh.com
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.11 2013/11/07 02:48:38 dtucker Exp $
d5 1
d32 1
d36 1
d39 2
@


1.11
log
@Use ssh -Q instead of hardcoding lists of ciphers or MACs.
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.10 2013/05/17 01:32:11 dtucker Exp $
d14 1
a14 1
macs="$macs `${SSH} -Q cipher | grep gcm@@openssh.com`"
d33 5
a37 4
		case $m in
			aes*gcm*)	macopt="-c $m";;
			*)		macopt="-m $m";;
		esac
d40 1
@


1.10
log
@don't print output from ssh before getting it (it's available in ssh.log)
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.9 2013/04/07 02:16:03 dtucker Exp $
d11 1
a11 6
macs="hmac-sha1 hmac-md5 umac-64@@openssh.com umac-128@@openssh.com
	hmac-sha1-96 hmac-md5-96 hmac-sha2-256 hmac-sha2-512
	hmac-sha1-etm@@openssh.com hmac-md5-etm@@openssh.com
	umac-64-etm@@openssh.com umac-128-etm@@openssh.com
	hmac-sha1-96-etm@@openssh.com hmac-md5-96-etm@@openssh.com
	hmac-sha2-256-etm@@openssh.com hmac-sha2-512-etm@@openssh.com"
d14 1
a14 1
macs="$macs aes128-gcm@@openssh.com aes256-gcm@@openssh.com"
@


1.9
log
@use -E option for ssh and sshd to write debuging logs to ssh{,d}.log and
save the output from any failing tests.  If a test fails the debug output
from ssh and sshd for the failing tests (and only the failing tests) should
be available in failed-ssh{,d}.log.
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.8 2013/04/06 06:00:22 dtucker Exp $
d42 1
a42 1
		verbose "test $tid: $m @@$off $output"
@


1.8
log
@Split the regress log into 3 parts: the debug output from ssh, the debug
log from sshd and the output from the client command (ssh, scp or sftp).
Somewhat functional now, will become more useful when ssh/sshd -E is added.
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.7 2013/02/20 08:27:50 djm Exp $
d42 3
a44 2
		output=$(${SSH} $macopt -2F $OBJ/ssh_proxy -o "$pxy" \
		    999.999.999.999 'printf "%4096s" " "' 2>&1)
d49 2
a50 2
		output=$(echo $output | tr -s '\r\n' '.')
		verbose "test $tid: $m @@$off $output"
@


1.7
log
@Add an option to modpipe that warns if the modification offset it not
reached in it's stream and turn it on for t-integrity. This should catch
cases where the session is not fuzzed for being too short (cf. my last
"oops" commit)
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.6 2013/02/19 02:14:09 djm Exp $
d22 1
a22 1
cmd="sh ${SRC}/sshd-log-wrapper.sh ${SSHD} ${TEST_SSH_LOGFILE} -i -f $OBJ/sshd_proxy"
@


1.6
log
@oops, forgot to increase the output of the ssh command to ensure that
we actually reach $offset
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.5 2013/02/18 22:26:47 djm Exp $
d37 1
a37 1
		pxy="proxycommand=$cmd | $OBJ/modpipe -m xor:$off:1"
@


1.5
log
@crank the offset yet again; it was still fuzzing KEX one of Darren's
portable test hosts at 2800
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.4 2013/02/17 23:16:55 djm Exp $
d43 1
a43 1
		    999.999.999.999 'printf "%2048s" " "' 2>&1)
@


1.4
log
@make the ssh command generates some output to ensure that there are at
least offset+tries bytes in the stream.
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.3 2013/02/16 06:08:45 djm Exp $
d6 1
a6 1
# start at byte 2800 (i.e. after kex) and corrupt at different offsets
d10 1
a10 1
startoffset=2800
@


1.3
log
@make sure the fuzz offset is actually past the end of KEX for all KEX
types. diffie-hellman-group-exchange-sha256 requires an offset around
2700. Noticed via test failures in portable OpenSSH on platforms that
lack ECC and this the more byte-frugal ECDH KEX algorithms.
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.2 2013/01/12 11:23:53 djm Exp $
d43 1
a43 1
		    999.999.999.999 true 2>&1)
@


1.2
log
@test AES-GCM modes; feedback markus@@
@
text
@d1 1
a1 1
#	$OpenBSD: integrity.sh,v 1.1 2012/12/11 22:42:11 markus Exp $
d6 1
a6 1
# start at byte 2300 (i.e. after kex) and corrupt at different offsets
d10 1
a10 1
startoffset=2300
@


1.1
log
@test the integrity of the packets; with djm@@
@
text
@d1 1
a1 1
#	$OpenBSD: $
d17 3
d38 5
a42 1
		output=$(${SSH} -m $m -2F $OBJ/ssh_proxy -o "$pxy" \
d52 2
a53 1
		Corrupted?MAC*) emac=$((emac+1)); skip=0;;
@

