head	1.27;
access;
symbols
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.8
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.4
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.21.0.6
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.2
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.12
	OPENBSD_5_0:1.12.0.10
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.8
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.6
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.11.0.16
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.14
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.12
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.10
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.8
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.6
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8;
locks; strict;
comment	@# @;


1.27
date	2014.12.22.06.14.29;	author djm;	state Exp;
branches;
next	1.26;
commitid	ed96aX8aRxyxXBwP;

1.26
date	2014.12.22.01.14.49;	author djm;	state Exp;
branches;
next	1.25;
commitid	IHDSatRz4OkAdGJ7;

1.25
date	2014.07.22.01.32.12;	author djm;	state Exp;
branches;
next	1.24;
commitid	RASkYvLnk2ZvzTe3;

1.24
date	2014.07.15.15.54.15;	author millert;	state Exp;
branches;
next	1.23;
commitid	z7plx8Gkj6l2sxem;

1.23
date	2014.07.07.08.15.26;	author djm;	state Exp;
branches;
next	1.22;
commitid	nbuQbc7OZlbQ8Rwl;

1.22
date	2014.07.06.07.42.03;	author djm;	state Exp;
branches;
next	1.21;
commitid	PRBp6lhSh5VPEYWp;

1.21
date	2013.05.17.04.29.14;	author dtucker;	state Exp;
branches;
next	1.20;

1.20
date	2013.04.22.07.28.53;	author dtucker;	state Exp;
branches;
next	1.19;

1.19
date	2013.04.22.07.23.08;	author dtucker;	state Exp;
branches;
next	1.18;

1.18
date	2013.04.06.06.00.22;	author dtucker;	state Exp;
branches;
next	1.17;

1.17
date	2012.10.05.02.05.30;	author dtucker;	state Exp;
branches;
next	1.16;

1.16
date	2012.09.10.01.51.19;	author dtucker;	state Exp;
branches;
next	1.15;

1.15
date	2012.09.10.00.49.21;	author dtucker;	state Exp;
branches;
next	1.14;

1.14
date	2012.09.09.11.51.25;	author dtucker;	state Exp;
branches;
next	1.13;

1.13
date	2012.06.01.00.47.36;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.05.07.51.36;	author dtucker;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.25.09.54.09;	author dtucker;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.27.11.33.30;	author dtucker;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.07.00.32.41;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.22.03.12.13;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.18.06.15.51;	author dtucker;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.17.14.53.27;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.17.06.19.06;	author dtucker;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.17.06.00.05;	author dtucker;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.17.05.51.59;	author dtucker;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.16.13.16.40;	author dtucker;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.13.15.04.08;	author djm;	state Exp;
branches;
next	;


desc
@@


1.27
log
@make this slightly easier to diff against portable
@
text
@#	$OpenBSD: multiplex.sh,v 1.26 2014/12/22 01:14:49 djm Exp $
#	Placed in the Public Domain.

CTL=$OBJ/ctl-sock

tid="connection multiplexing"

NC=nc
P=3301  # test port

wait_for_mux_master_ready()
{
	for i in 1 2 3 4 5; do
		${SSH} -F $OBJ/ssh_config -S $CTL -Ocheck otherhost \
		    >/dev/null 2>&1 && return 0
		sleep $i
	done
	fatal "mux master never becomes ready"
}

start_sshd

start_mux_master()
{
	trace "start master, fork to background"
	${SSH} -Nn2 -MS$CTL -F $OBJ/ssh_config -oSendEnv="_XXX_TEST" somehost \
	    -E $TEST_REGRESS_LOGFILE 2>&1 &
	# NB. $SSH_PID will be killed by test-exec.sh:cleanup on fatal errors.
	SSH_PID=$!
	wait_for_mux_master_ready
}

start_mux_master

verbose "test $tid: envpass"
trace "env passing over multiplexed connection"
_XXX_TEST=blah ${SSH} -F $OBJ/ssh_config -oSendEnv="_XXX_TEST" -S$CTL otherhost sh << 'EOF'
	test X"$_XXX_TEST" = X"blah"
EOF
if [ $? -ne 0 ]; then
	fail "environment not found"
fi

verbose "test $tid: transfer"
rm -f ${COPY}
trace "ssh transfer over multiplexed connection and check result"
${SSH} -F $OBJ/ssh_config -S$CTL otherhost cat ${DATA} > ${COPY}
test -f ${COPY}			|| fail "ssh -Sctl: failed copy ${DATA}" 
cmp ${DATA} ${COPY}		|| fail "ssh -Sctl: corrupted copy of ${DATA}"

rm -f ${COPY}
trace "ssh transfer over multiplexed connection and check result"
${SSH} -F $OBJ/ssh_config -S $CTL otherhost cat ${DATA} > ${COPY}
test -f ${COPY}			|| fail "ssh -S ctl: failed copy ${DATA}" 
cmp ${DATA} ${COPY}		|| fail "ssh -S ctl: corrupted copy of ${DATA}"

rm -f ${COPY}
trace "sftp transfer over multiplexed connection and check result"
echo "get ${DATA} ${COPY}" | \
	${SFTP} -S ${SSH} -F $OBJ/ssh_config -oControlPath=$CTL otherhost >>$TEST_REGRESS_LOGFILE 2>&1
test -f ${COPY}			|| fail "sftp: failed copy ${DATA}" 
cmp ${DATA} ${COPY}		|| fail "sftp: corrupted copy of ${DATA}"

rm -f ${COPY}
trace "scp transfer over multiplexed connection and check result"
${SCP} -S ${SSH} -F $OBJ/ssh_config -oControlPath=$CTL otherhost:${DATA} ${COPY} >>$TEST_REGRESS_LOGFILE 2>&1
test -f ${COPY}			|| fail "scp: failed copy ${DATA}" 
cmp ${DATA} ${COPY}		|| fail "scp: corrupted copy of ${DATA}"

rm -f ${COPY}
verbose "test $tid: forward"
trace "forward over TCP/IP and check result"
$NC -N -l 127.0.0.1 $((${PORT} + 1)) < ${DATA} > /dev/null &
netcat_pid=$!
${SSH} -F $OBJ/ssh_config -S $CTL -Oforward -L127.0.0.1:$((${PORT} + 2)):127.0.0.1:$((${PORT} + 1)) otherhost >>$TEST_SSH_LOGFILE 2>&1
$NC 127.0.0.1 $((${PORT} + 2)) < /dev/null > ${COPY}
cmp ${DATA} ${COPY}		|| fail "ssh: corrupted copy of ${DATA}"
kill $netcat_pid 2>/dev/null
rm -f ${COPY} $OBJ/unix-[123].fwd

trace "forward over UNIX and check result"
$NC -N -Ul $OBJ/unix-1.fwd < ${DATA} > /dev/null &
netcat_pid=$!
${SSH} -F $OBJ/ssh_config -S $CTL -Oforward -L$OBJ/unix-2.fwd:$OBJ/unix-1.fwd otherhost >>$TEST_SSH_LOGFILE 2>&1
${SSH} -F $OBJ/ssh_config -S $CTL -Oforward -R$OBJ/unix-3.fwd:$OBJ/unix-2.fwd otherhost >>$TEST_SSH_LOGFILE 2>&1
$NC -U $OBJ/unix-3.fwd < /dev/null > ${COPY}
cmp ${DATA} ${COPY}		|| fail "ssh: corrupted copy of ${DATA}"
kill $netcat_pid 2>/dev/null
rm -f ${COPY} $OBJ/unix-[123].fwd

for s in 0 1 4 5 44; do
	trace "exit status $s over multiplexed connection"
	verbose "test $tid: status $s"
	${SSH} -F $OBJ/ssh_config -S $CTL otherhost exit $s
	r=$?
	if [ $r -ne $s ]; then
		fail "exit code mismatch for protocol $p: $r != $s"
	fi

	# same with early close of stdout/err
	trace "exit status $s with early close over multiplexed connection"
	${SSH} -F $OBJ/ssh_config -S $CTL -n otherhost \
                exec sh -c \'"sleep 2; exec > /dev/null 2>&1; sleep 3; exit $s"\'
	r=$?
	if [ $r -ne $s ]; then
		fail "exit code (with sleep) mismatch for protocol $p: $r != $s"
	fi
done

verbose "test $tid: cmd check"
${SSH} -F $OBJ/ssh_config -S $CTL -Ocheck otherhost >>$TEST_REGRESS_LOGFILE 2>&1 \
    || fail "check command failed" 

verbose "test $tid: cmd forward local (TCP)"
${SSH} -F $OBJ/ssh_config -S $CTL -Oforward -L $P:localhost:$PORT otherhost \
     || fail "request local forward failed"
${SSH} -F $OBJ/ssh_config -p$P otherhost true \
     || fail "connect to local forward port failed"
${SSH} -F $OBJ/ssh_config -S $CTL -Ocancel -L $P:localhost:$PORT otherhost \
     || fail "cancel local forward failed"
${SSH} -F $OBJ/ssh_config -p$P otherhost true \
     && fail "local forward port still listening"

verbose "test $tid: cmd forward remote (TCP)"
${SSH} -F $OBJ/ssh_config -S $CTL -Oforward -R $P:localhost:$PORT otherhost \
     || fail "request remote forward failed"
${SSH} -F $OBJ/ssh_config -p$P otherhost true \
     || fail "connect to remote forwarded port failed"
${SSH} -F $OBJ/ssh_config -S $CTL -Ocancel -R $P:localhost:$PORT otherhost \
     || fail "cancel remote forward failed"
${SSH} -F $OBJ/ssh_config -p$P otherhost true \
     && fail "remote forward port still listening"

verbose "test $tid: cmd forward local (UNIX)"
${SSH} -F $OBJ/ssh_config -S $CTL -Oforward -L $OBJ/unix-1.fwd:localhost:$PORT otherhost \
     || fail "request local forward failed"
echo "" | $NC -U $OBJ/unix-1.fwd | grep "Protocol mismatch" >/dev/null 2>&1 \
     || fail "connect to local forward path failed"
${SSH} -F $OBJ/ssh_config -S $CTL -Ocancel -L $OBJ/unix-1.fwd:localhost:$PORT otherhost \
     || fail "cancel local forward failed"
N=$(echo "xyzzy" | $NC -U $OBJ/unix-1.fwd 2>&1 | grep "xyzzy" | wc -l)
test ${N} -eq 0 || fail "local forward path still listening"
rm -f $OBJ/unix-1.fwd

verbose "test $tid: cmd forward remote (UNIX)"
${SSH} -F $OBJ/ssh_config -S $CTL -Oforward -R $OBJ/unix-1.fwd:localhost:$PORT otherhost \
     || fail "request remote forward failed"
echo "" | $NC -U $OBJ/unix-1.fwd | grep "Protocol mismatch" >/dev/null 2>&1 \
     || fail "connect to remote forwarded path failed"
${SSH} -F $OBJ/ssh_config -S $CTL -Ocancel -R $OBJ/unix-1.fwd:localhost:$PORT otherhost \
     || fail "cancel remote forward failed"
N=$(echo "xyzzy" | $NC -U $OBJ/unix-1.fwd 2>&1 | grep "xyzzy" | wc -l)
test ${N} -eq 0 || fail "remote forward path still listening"
rm -f $OBJ/unix-1.fwd

verbose "test $tid: cmd exit"
${SSH} -F $OBJ/ssh_config -S $CTL -Oexit otherhost >>$TEST_REGRESS_LOGFILE 2>&1 \
    || fail "send exit command failed" 

# Wait for master to exit
wait $SSH_PID
kill -0 $SSH_PID >/dev/null 2>&1 && fail "exit command failed"

# Restart master and test -O stop command with master using -N
verbose "test $tid: cmd stop"
trace "restart master, fork to background"
start_mux_master

# start a long-running command then immediately request a stop
${SSH} -F $OBJ/ssh_config -S $CTL otherhost "sleep 10; exit 0" \
     >>$TEST_REGRESS_LOGFILE 2>&1 &
SLEEP_PID=$!
${SSH} -F $OBJ/ssh_config -S $CTL -Ostop otherhost >>$TEST_REGRESS_LOGFILE 2>&1 \
    || fail "send stop command failed"

# wait until both long-running command and master have exited.
wait $SLEEP_PID
[ $! != 0 ] || fail "waiting for concurrent command"
wait $SSH_PID
[ $! != 0 ] || fail "waiting for master stop"
kill -0 $SSH_PID >/dev/null 2>&1 && fatal "stop command failed"
SSH_PID="" # Already gone, so don't kill in cleanup

@


1.26
log
@poll changes to netcat (usr.bin/netcat.c r1.125) broke this test;
fix it by ensuring more stdio fds are sent to devnull
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.25 2014/07/22 01:32:12 djm Exp $
d8 1
d73 1
a73 1
nc -N -l 127.0.0.1 $((${PORT} + 1)) < ${DATA} > /dev/null &
d76 1
a76 1
nc 127.0.0.1 $((${PORT} + 2)) < /dev/null > ${COPY}
d82 1
a82 1
nc -N -Ul $OBJ/unix-1.fwd < ${DATA} > /dev/null &
d86 1
a86 1
nc -U $OBJ/unix-3.fwd < /dev/null > ${COPY}
d137 1
a137 1
echo "" | nc -U $OBJ/unix-1.fwd | grep "Protocol mismatch" >/dev/null 2>&1 \
d141 1
a141 1
N=$(echo "xyzzy" | nc -U $OBJ/unix-1.fwd 2>&1 | grep "xyzzy" | wc -l)
d148 1
a148 1
echo "" | nc -U $OBJ/unix-1.fwd | grep "Protocol mismatch" >/dev/null 2>&1 \
d152 1
a152 1
N=$(echo "xyzzy" | nc -U $OBJ/unix-1.fwd 2>&1 | grep "xyzzy" | wc -l)
@


1.25
log
@change the test for still-open Unix domain sockets to be robust against
nc implementations that produce error messages. from -portable
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.24 2014/07/15 15:54:15 millert Exp $
d72 1
a72 1
nc -N -l 127.0.0.1 $((${PORT} + 1)) < ${DATA} &
d75 1
a75 1
nc 127.0.0.1 $((${PORT} + 2)) > ${COPY}
d81 1
a81 1
nc -N -Ul $OBJ/unix-1.fwd < ${DATA} &
d85 1
a85 1
nc -U $OBJ/unix-3.fwd > ${COPY}
@


1.24
log
@Add support for Unix domain socket forwarding.  A remote TCP port
may be forwarded to a local Unix domain socket and vice versa or
both ends may be a Unix domain socket.  This is a reimplementation
of the streamlocal patches by William Ahern from:
    http://www.25thandclement.com/~william/projects/streamlocal.html
OK djm@@ markus@@
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.23 2014/07/07 08:15:26 djm Exp $
d140 1
a140 1
N=$(echo "" | nc -U $OBJ/unix-1.fwd 2>&1 | wc -l)
d151 1
a151 1
N=$(echo "" | nc -U $OBJ/unix-1.fwd 2>&1 | wc -l)
@


1.23
log
@remove forced-fatal that I stuck in there to test the new cleanup
logic and forgot to remove...
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.22 2014/07/06 07:42:03 djm Exp $
d70 19
d113 1
a113 1
verbose "test $tid: cmd forward local"
d123 1
a123 1
verbose "test $tid: cmd forward remote"
d132 22
@


1.22
log
@add a hook to the cleanup() function to kill $SSH_PID if it is set

use it to kill the mux master started in multiplex.sh (it was being left
around on fatal failures)
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.21 2013/05/17 04:29:14 dtucker Exp $
a41 2

fatal ok
@


1.21
log
@Move the setting of DATA and COPY into test-exec.sh
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.20 2013/04/22 07:28:53 dtucker Exp $
d27 2
a28 1
	MASTER_PID=$!
d43 2
d121 2
a122 2
wait $MASTER_PID
kill -0 $MASTER_PID >/dev/null 2>&1 && fail "exit command failed"
d139 1
a139 1
wait $MASTER_PID
d141 3
a143 1
kill -0 $MASTER_PID >/dev/null 2>&1 && fail "stop command failed"
@


1.20
log
@Add tests for -Oforward and -Ocancel for local and remote forwards
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.19 2013/04/22 07:23:08 dtucker Exp $
a7 2
DATA=/bin/ls
COPY=$OBJ/ls.copy
@


1.19
log
@Write mux master logs to regress.log instead of ssh.log to keep separate
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.18 2013/04/06 06:00:22 dtucker Exp $
d10 1
d94 20
@


1.18
log
@Split the regress log into 3 parts: the debug output from ssh, the debug
log from sshd and the output from the client command (ssh, scp or sftp).
Somewhat functional now, will become more useful when ssh/sshd -E is added.
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.17 2012/10/05 02:05:30 dtucker Exp $
d23 10
a32 4
trace "start master, fork to background"
${SSH} -Nn2 -MS$CTL -F $OBJ/ssh_config -oSendEnv="_XXX_TEST" somehost &
MASTER_PID=$!
wait_for_mux_master_ready
d105 1
a105 3
${SSH} -Nn2 -MS$CTL -F $OBJ/ssh_config -oSendEnv="_XXX_TEST" somehost &
MASTER_PID=$!
wait_for_mux_master_ready
@


1.17
log
@Use 'kill -0' to test for the presence of a pid since it's more portable
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.16 2012/09/10 01:51:19 dtucker Exp $
d53 1
a53 1
	${SFTP} -S ${SSH} -F $OBJ/ssh_config -oControlPath=$CTL otherhost >>$TEST_SSH_LOGFILE 2>&1
d59 1
a59 1
${SCP} -S ${SSH} -F $OBJ/ssh_config -oControlPath=$CTL otherhost:${DATA} ${COPY} >>$TEST_SSH_LOGFILE 2>&1
d85 1
a85 1
${SSH} -F $OBJ/ssh_config -S $CTL -Ocheck otherhost >>$TEST_SSH_LOGFILE 2>&1 \
d89 1
a89 1
${SSH} -F $OBJ/ssh_config -S $CTL -Oexit otherhost >>$TEST_SSH_LOGFILE 2>&1 \
d105 1
a105 1
     >>$TEST_SSH_LOGFILE 2>&1 &
d107 1
a107 1
${SSH} -F $OBJ/ssh_config -S $CTL -Ostop otherhost >>$TEST_SSH_LOGFILE 2>&1 \
@


1.16
log
@use -Ocheck and waiting for completions by PID to make multiplexing test
less racy and (hopefully) more reliable on slow hardware.
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.15 2012/09/10 00:49:21 dtucker Exp $
d94 1
a94 1
ps -p $MASTER_PID >/dev/null && fail "exit command failed"
d115 1
a115 1
ps -p $MASTER_PID >/dev/null && fail "stop command failed"
@


1.15
log
@Log -O cmd output to the log file and make logging consistent with the other
tests.  Test clean shutdown of an existing channel when testing "stop".
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.14 2012/09/09 11:51:25 dtucker Exp $
d11 10
d26 1
a26 3

# Wait for master to start and authenticate
sleep 5
d93 1
a93 2
sleep 2

d97 2
a98 1
trace "start master, fork to background"
d101 5
a105 3
sleep 5 # Wait for master to start and authenticate
verbose "test $tid: cmd stop"
${SSH} -F $OBJ/ssh_config -S $CTL otherhost "sleep 10; exit 0" &
d109 2
a110 1
sleep 12 # Wait for master to exit
d112 3
a114 1
[ $! != 0 ] || fail "stop with concurrent command"
@


1.14
log
@Add test for ssh -Ostop
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.13 2012/06/01 00:47:36 djm Exp $
d76 7
a82 5
trace "test check command"
${SSH} -F $OBJ/ssh_config -S $CTL -Ocheck otherhost || fail "check command failed" 

trace "test exit command"
${SSH} -F $OBJ/ssh_config -S $CTL -Oexit otherhost || fail "send exit command failed" 
d94 8
a101 3
trace "test stop command"
${SSH} -F $OBJ/ssh_config -S $CTL -Ostop otherhost || fail "send stop command failed"
sleep 2 # Wait for master to exit
@


1.13
log
@append to rather than truncate test log; bz#2013 from openssh AT
roumenpetrov.info
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.12 2009/05/05 07:51:36 dtucker Exp $
d85 11
a95 1
ps -p $MASTER_PID >/dev/null && fail "exit command failed" 
@


1.12
log
@Always specify ssh_config for multiplex tests: prevents breakage caused
by options in ~/.ssh/config.  From Dan Peterson.
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.11 2005/04/25 09:54:09 dtucker Exp $
a9 1
LOG=$TEST_SSH_LOGFILE
d45 1
a45 1
	${SFTP} -S ${SSH} -F $OBJ/ssh_config -oControlPath=$CTL otherhost >$LOG 2>&1
d51 1
a51 1
${SCP} -S ${SSH} -F $OBJ/ssh_config -oControlPath=$CTL otherhost:${DATA} ${COPY} >$LOG 2>&1
@


1.11
log
@Don't call cleanup in multiplex as test-exec will cleanup anyway
found by tim@@, ok djm@@
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.10 2005/02/27 11:33:30 dtucker Exp $
d23 1
a23 1
_XXX_TEST=blah ${SSH} -oSendEnv="_XXX_TEST" -S$CTL otherhost sh << 'EOF'
d33 1
a33 1
${SSH} -S$CTL otherhost cat ${DATA} > ${COPY}
d39 1
a39 1
${SSH} -S $CTL otherhost cat ${DATA} > ${COPY}
d46 1
a46 1
	${SFTP} -S ${SSH} -oControlPath=$CTL otherhost >$LOG 2>&1
d52 1
a52 1
${SCP} -S ${SSH} -oControlPath=$CTL otherhost:${DATA} ${COPY} >$LOG 2>&1
d61 1
a61 1
	${SSH} -S $CTL otherhost exit $s
d69 1
a69 1
	${SSH} -S $CTL -n otherhost \
d78 1
a78 1
${SSH} -S $CTL -Ocheck otherhost || fail "check command failed" 
d81 1
a81 1
${SSH} -S $CTL -Oexit otherhost || fail "send exit command failed" 
@


1.10
log
@Add optional capability to log output from regress commands; ok markus@@
Use with: make TEST_SSH_LOGFILE=/tmp/regress.log
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.9 2004/11/07 00:32:41 djm Exp $
a86 2

cleanup
@


1.9
log
@regression tests for new multiplex commands
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.8 2004/06/22 03:12:13 markus Exp $
d10 1
d46 1
a46 1
	${SFTP} -S ${SSH} -oControlPath=$CTL otherhost >/dev/null 2>&1
d52 1
a52 1
${SCP} -S ${SSH} -oControlPath=$CTL otherhost:${DATA} ${COPY} >/dev/null 2>&1
@


1.8
log
@more portable env passing tests
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.7 2004/06/18 06:15:51 dtucker Exp $
d14 5
a18 1
${SSH} -2 -MS$CTL -F $OBJ/ssh_config -oSendEnv="_XXX_TEST" -f somehost sleep 60
d76 12
a87 3
# kill master, remove control socket.  ssh -MS will exit when sleep exits
$SUDO kill `cat $PIDFILE`
rm -f $CTL
@


1.7
log
@Use -S for scp/sftp to force the use of the ssh being tested.  ok djm@@,markus@@
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.6 2004/06/17 14:53:27 djm Exp $
d14 1
a14 1
${SSH} -2 -MS$CTL -F $OBJ/ssh_config -oSendEnv="_XXX_TEST"  -f somehost sleep 60
d18 3
a20 1
_XXX_TEST=blah ${SSH} -S$CTL otherhost '[ "x$_XXX_TEST" = "xblah" ]'
@


1.6
log
@shared connection env passing regress test
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.5 2004/06/17 06:19:06 dtucker Exp $
d39 1
a39 1
	${SFTP} -oControlPath=$CTL otherhost >/dev/null 2>&1
d45 1
a45 1
${SCP} -oControlPath=$CTL otherhost:${DATA} ${COPY} >/dev/null 2>&1
@


1.5
log
@Add small description of failing test to failure message; ok djm@@
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.4 2004/06/17 06:00:05 dtucker Exp $
d14 1
a14 1
${SSH} -2 -MS$CTL -F $OBJ/ssh_config -f somehost sleep 60
d16 8
@


1.4
log
@Use  and  for test data rather than hard-coded paths; ok djm@@
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.3 2004/06/17 05:51:59 dtucker Exp $
d19 2
a20 2
test -f ${COPY}				|| fail "failed copy ${DATA}" 
cmp ${DATA} ${COPY}			|| fail "corrupted copy of ${DATA}"
d25 2
a26 2
test -f ${COPY}				|| fail "failed copy ${DATA}" 
cmp ${DATA} ${COPY}			|| fail "corrupted copy of ${DATA}"
d32 2
a33 2
test -f ${COPY}				|| fail "failed copy ${DATA}" 
cmp ${DATA} ${COPY}			|| fail "corrupted copy of ${DATA}"
d38 2
a39 2
test -f ${COPY}				|| fail "failed copy ${DATA}" 
cmp ${DATA} ${COPY}			|| fail "corrupted copy of ${DATA}"
@


1.3
log
@Remove datafile between and after tests, kill sshd rather than wait; ok djm@@
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.2 2004/06/16 13:16:40 dtucker Exp $
d8 3
d16 1
a16 1
rm -f $OBJ/ls.copy
d18 3
a20 3
${SSH} -S$CTL otherhost cat /bin/ls > $OBJ/ls.copy
test -f $OBJ/ls.copy			|| fail "failed copy /bin/ls"
cmp /bin/ls $OBJ/ls.copy		|| fail "corrupted copy of /bin/ls"
d22 1
a22 1
rm -f $OBJ/ls.copy
d24 3
a26 3
${SSH} -S $CTL otherhost cat /bin/ls > $OBJ/ls.copy
test -f $OBJ/ls.copy			|| fail "failed copy /bin/ls"
cmp /bin/ls $OBJ/ls.copy		|| fail "corrupted copy of /bin/ls"
d28 1
a28 1
rm -f $OBJ/ls.copy
d30 1
a30 1
echo "get /bin/ls $OBJ/ls.copy" | \
d32 2
a33 2
test -f $OBJ/ls.copy			|| fail "failed copy /bin/ls"
cmp /bin/ls $OBJ/ls.copy		|| fail "corrupted copy of /bin/ls"
d35 1
a35 1
rm -f $OBJ/ls.copy
d37 3
a39 3
${SCP} -oControlPath=$CTL otherhost:/bin/ls $OBJ/ls.copy >/dev/null 2>&1
test -f $OBJ/ls.copy			|| fail "failed copy /bin/ls"
cmp /bin/ls $OBJ/ls.copy		|| fail "corrupted copy of /bin/ls"
d41 1
a41 1
rm -f $OBJ/ls.copy
@


1.2
log
@Silence multiplex sftp and scp tests.  ok markus@@
@
text
@d1 1
a1 1
#	$OpenBSD: multiplex.sh,v 1.1 2004/06/13 15:04:08 djm Exp $
d13 1
d19 1
d38 2
d59 3
a61 1
sleep 30 # early close test sleeps 5 seconds per test
@


1.1
log
@regress test for client multiplexing; ok markus@@
@
text
@d1 1
a1 1
#	$OpenBSD$
d26 1
a26 1
	${SFTP} -oControlPath=$CTL otherhost
d32 1
a32 1
${SCP} -oControlPath=$CTL otherhost:/bin/ls $OBJ/ls.copy
@

