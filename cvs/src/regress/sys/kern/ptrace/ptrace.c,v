head	1.5;
access;
symbols
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.3.0.16
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.12
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.10
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.8
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.6
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.2.0.34
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.32
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.30
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.28
	OPENBSD_5_0:1.2.0.26
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.24
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.22
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.18
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.20
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.16
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.14
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.12
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.10
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.8
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.6
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2017.09.16.02.03.40;	author guenther;	state Exp;
branches;
next	1.4;
commitid	EtVx0z1Pdcy08AXO;

1.4
date	2017.09.06.04.20.12;	author guenther;	state Exp;
branches;
next	1.3;
commitid	ok8XyY4uYmSJKKbV;

1.3
date	2014.01.22.00.36.31;	author guenther;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.20.16.16.04;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.20.15.31.43;	author art;	state Exp;
branches;
next	;


desc
@@


1.5
log
@The copyin(9) family of functions should return EFAULT for all memory
protection issues.  So make amd64 do that instead of passing through
uvm_fault()'s return value, which lead to other possible errors
(particularly EACCES) being returned to userspace.  Clean up a vestige
on arm64 too.

ok bluhn@@ deraadt@@
@
text
@/*	$OpenBSD: ptrace.c,v 1.4 2017/09/06 04:20:12 guenther Exp $	*/
/*
 * Copyright (c) 2005 Artur Grabowski <art@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ptrace.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <err.h>

static void
usage(void)
{
	fprintf(stderr, "Usage: ptrace [-bdirwI]\n");
	exit(1);
}

#define MAGIC	"asdfblahblahspam1235432blah"
#define MAGIC_I	0x47114217

int
main(int argc, char **argv)
{
	int ch;
	int bad = 0, i, write, I;
	pid_t pid;
	char *m;
	int ps;
	int status;
	int ret;

	ps = getpagesize();

	I = 0;
	i = 0;
	write = 0;

	while ((ch = getopt(argc, argv, "bdirwI")) != -1) {
		switch (ch) {
		case 'b':
			bad = 1;
			break;
		case 'i':
			i = 1;
			break;
		case 'd':
			i = 0;
			break;
		case 'r':
			write = 0;
			break;
		case 'w':
			write = 1;
			break;
		case 'I':
			I = 1;
			break;
		default:
			usage();
		}
	}

	m = mmap(0, ps, PROT_READ|PROT_WRITE, MAP_ANON|MAP_SHARED, -1, 0);
	if (m == MAP_FAILED)
		err(1, "mmap");

	if (!write) {
		if (I)
			memcpy(m, MAGIC, sizeof(MAGIC));
		else
			*(int *)m = MAGIC_I;
	}
	if (bad)
		if (mprotect(m, ps, PROT_NONE))
			err(1, "mprotect");

	switch ((pid = fork())) {
	case 0:
		pause();
		_exit(0);
	case -1:
		err(1, "fork");
	}

	ret = 0;

	if (ptrace(PT_ATTACH, pid, 0, 0) == -1) {
		warn("ptrace(PT_ATTACH)");
		ret = -1;
		goto out;
	}

	if (wait(&status) != pid) {
		warn("wait");
		ret = -1;
		goto out;
	}

	if (!write) {
		int req;

		if (I) {
			char foo[1024];
			struct ptrace_io_desc piod;

			if (i)
				piod.piod_op = PIOD_READ_I;
			else
				piod.piod_op = PIOD_READ_D;
			piod.piod_offs = m;
			piod.piod_addr = &foo;
			piod.piod_len = sizeof(MAGIC);

			if (ptrace(PT_IO, pid, (caddr_t)&piod, 0) == -1) {
				warn("ptrace(PT_IO)");
				if (errno == EFAULT)
					ret = 1;
				else
					ret = -1;
				goto out;
			}

			if (memcmp(foo, MAGIC, sizeof(MAGIC))) {
				warnx("mismatch %s != %s", foo, MAGIC);
				ret = 1;
				goto out;
			}
		} else {
			if (i)
				req = PT_READ_I;
			else
				req = PT_READ_D;

			i = ptrace(req, pid, m, sizeof(i));
			if (i != MAGIC_I) {
				warn("ptrace(%d): %d != %d", req, i, MAGIC_I);
				ret = 1;
				goto out;
			}
		}
	} else {
		errx(1, "lazy bum");
	}

out:
	if (ret == -1) {
		/* other errors */
		ret = 1;
	} else if (bad) {
		if (ret == 0) {
			warnx("protected memory unprotected");
			ret = 1;
		} else {
			ret = 0;
		}
	}

	kill(pid, SIGKILL);

	return ret;
}
@


1.4
log
@Fix declarations
ptrace(PT_IO) memory protection faults return EACCES, not EFAULT
@
text
@d1 1
a1 1
/*	$OpenBSD: ptrace.c,v 1.3 2014/01/22 00:36:31 guenther Exp $	*/
d135 1
a135 1
				if (errno == EACCES)
@


1.3
log
@Missing #include
@
text
@d1 1
a1 1
/*	$OpenBSD: ptrace.c,v 1.2 2005/07/20 16:16:04 art Exp $	*/
d28 1
d48 1
a48 1
	int status, req;
d119 1
a119 1
		int i, req;
d135 1
a135 1
				if (errno == EFAULT)
@


1.2
log
@EFAULT from PT_IO is a good error value too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ptrace.c,v 1.1 2005/07/20 15:31:43 art Exp $	*/
d24 1
@


1.1
log
@Regress test for PT_READ_{D,I} and PT_IO. (write coming soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
d133 4
a136 1
				ret = -1;
@

