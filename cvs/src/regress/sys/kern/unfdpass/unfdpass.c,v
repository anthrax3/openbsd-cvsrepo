head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.2
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.18.0.8
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.4
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.16
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.14
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.10
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.12
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.10
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.6
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.8
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.12.0.16
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.14
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.12
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.10
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.8
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.1.0.10
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.8
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.6
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.4
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.19
date	2017.01.26.04.45.46;	author benno;	state Exp;
branches;
next	1.18;
commitid	g9ScwtXhYAGXvtEK;

1.18
date	2015.01.19.00.22.30;	author guenther;	state Exp;
branches;
next	1.17;
commitid	RqjZigDpMJeDnQTG;

1.17
date	2011.07.06.19.48.10;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.26.05.42.06;	author ray;	state Exp;
branches;
next	1.15;

1.15
date	2008.03.24.16.11.08;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2008.03.15.16.49.15;	author hshoexer;	state Exp;
branches;
next	1.13;

1.13
date	2008.03.13.01.49.53;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.08.30.18.13.14;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.28.19.35.39;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.27.18.51.17;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.28.03.29.16;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.31.21.48.10;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.32;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.11.05.31.25;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.11.04.57.55;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.09.13.56.29;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.11.23.26.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.02.05.57;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.06.28.00.11.39;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@enable compiler warnings and fix them.
@
text
@/*	$OpenBSD: unfdpass.c,v 1.18 2015/01/19 00:22:30 guenther Exp $	*/
/*	$NetBSD: unfdpass.c,v 1.3 1998/06/24 23:51:30 thorpej Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Test passing of file descriptors over Unix domain sockets and socketpairs.
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/un.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define	SOCK_NAME	"test-sock"

int	main(int, char *[]);
void	child(int, int);
void	catch_sigchld(int);

/* ARGSUSED */
int
main(int argc, char *argv[])
{
	struct msghdr msg;
	int sock, pfd[2], fd, i;
	int listensock = -1;
	char fname[16], buf[64];
	struct cmsghdr *cmp;
	int *files = NULL;
	struct sockaddr_un sun, csun;
	int csunlen;
	pid_t pid;
	union {
		struct cmsghdr hdr;
		char buf[CMSG_SPACE(sizeof(int) * 3)];
	} cmsgbuf;
	int pflag;
	int type = SOCK_STREAM;
	extern char *__progname;

	pflag = 0;
	while ((i = getopt(argc, argv, "pq")) != -1) {
		switch (i) {
		case 'p':
			pflag = 1;
			break;
		case 'q':
			type = SOCK_SEQPACKET;
			break;
		default:
			fprintf(stderr, "usage: %s [-p]\n", __progname);
			exit(1);
		}
	}

	/*
	 * Create the test files.
	 */
	for (i = 0; i < 3; i++) {
		(void) snprintf(fname, sizeof fname, "file%d", i + 1);
		if ((fd = open(fname, O_WRONLY|O_CREAT|O_TRUNC, 0666)) == -1)
			err(1, "open %s", fname);
		(void) snprintf(buf, sizeof buf, "This is file %d.\n", i + 1);
		if (write(fd, buf, strlen(buf)) != (ssize_t) strlen(buf))
			err(1, "write %s", fname);
		(void) close(fd);
	}

	if (pflag) {
		/*
		 * Create the socketpair
		 */
		if (socketpair(PF_LOCAL, type, 0, pfd) == -1)
			err(1, "socketpair");
	} else {
		/*
		 * Create the listen socket.
		 */
		if ((listensock = socket(PF_LOCAL, type, 0)) == -1)
			err(1, "socket");

		(void) unlink(SOCK_NAME);
		(void) memset(&sun, 0, sizeof(sun));
		sun.sun_family = AF_LOCAL;
		(void) strlcpy(sun.sun_path, SOCK_NAME, sizeof sun.sun_path);

		if (bind(listensock, (struct sockaddr *)&sun, sizeof(sun)) == -1)
			err(1, "bind");

		if (listen(listensock, 1) == -1)
			err(1, "listen");
		pfd[0] = pfd[1] = -1;
	}

	/*
	 * Create the sender.
	 */
	(void) signal(SIGCHLD, catch_sigchld);
	pid = fork();
	switch (pid) {
	case -1:
		err(1, "fork");
		/* NOTREACHED */

	case 0:
		if (pfd[0] != -1)
			close(pfd[0]);
		child(pfd[1], type);
		/* NOTREACHED */
	}

	if (pfd[0] != -1) {
		close(pfd[1]);
		sock = pfd[0];
	} else {
		/*
		 * Wait for the sender to connect.
		 */
		if ((sock = accept(listensock, (struct sockaddr *)&csun,
		    &csunlen)) == -1)
		err(1, "accept");
	}

	/*
	 * Give sender a chance to run.  We will get going again
	 * once the SIGCHLD arrives.
	 */
	(void) sleep(10);

	/*
	 * Grab the descriptors passed to us.
	 */
	(void) memset(&msg, 0, sizeof(msg));
	msg.msg_control = &cmsgbuf.buf;
	msg.msg_controllen = sizeof(cmsgbuf.buf);

	if (recvmsg(sock, &msg, 0) < 0)
		err(1, "recvmsg");

	(void) close(sock);

	if (msg.msg_controllen == 0)
		errx(1, "no control messages received");

	if (msg.msg_flags & MSG_CTRUNC)
		errx(1, "lost control message data");

	for (cmp = CMSG_FIRSTHDR(&msg); cmp != NULL;
	    cmp = CMSG_NXTHDR(&msg, cmp)) {
		if (cmp->cmsg_level != SOL_SOCKET)
			errx(1, "bad control message level %d",
			    cmp->cmsg_level);

		switch (cmp->cmsg_type) {
		case SCM_RIGHTS:
			if (cmp->cmsg_len != CMSG_LEN(sizeof(int) * 3))
				errx(1, "bad fd control message length %d",
				    cmp->cmsg_len);

			files = (int *)CMSG_DATA(cmp);
			break;

		default:
			errx(1, "unexpected control message");
			/* NOTREACHED */
		}
	}

	/*
	 * Read the files and print their contents.
	 */
	if (files == NULL)
		warnx("didn't get fd control message");
	else {
		for (i = 0; i < 3; i++) {
			(void) memset(buf, 0, sizeof(buf));
			if (read(files[i], buf, sizeof(buf)) <= 0)
				err(1, "read file %d (%d)", i + 1, files[i]);
			printf("%s", buf);
		}
	}

	/*
	 * All done!
	 */
	exit(0);
}

void
catch_sigchld(sig)
	int sig;
{
	int save_errno = errno;
	int status;

	(void) wait(&status);
	errno = save_errno;
}

void
child(int sock, int type)
{
	struct msghdr msg;
	char fname[16];
	struct cmsghdr *cmp;
	int i, fd;
	struct sockaddr_un sun;
	union {
		struct cmsghdr hdr;
		char buf[CMSG_SPACE(sizeof(int) * 3)];
	} cmsgbuf;
	int *files;

	/*
	 * Create socket if needed and connect to the receiver.
	 */
	if (sock == -1) {
		if ((sock = socket(PF_LOCAL, type, 0)) == -1)
			err(1, "child socket");

		(void) memset(&sun, 0, sizeof(sun));
		sun.sun_family = AF_LOCAL;
		(void) strlcpy(sun.sun_path, SOCK_NAME, sizeof sun.sun_path);

		if (connect(sock, (struct sockaddr *)&sun, sizeof(sun)) == -1)
			err(1, "child connect");
	}

	(void) memset(&msg, 0, sizeof(msg));
	msg.msg_control = &cmsgbuf.buf;
	msg.msg_controllen = sizeof(cmsgbuf.buf);

	cmp = CMSG_FIRSTHDR(&msg);
	cmp->cmsg_len = CMSG_LEN(sizeof(int) * 3);
	cmp->cmsg_level = SOL_SOCKET;
	cmp->cmsg_type = SCM_RIGHTS;

	/*
	 * Open the files again, and pass them to the parent over the socket.
	 */
	files = (int *)CMSG_DATA(cmp);
	for (i = 0; i < 3; i++) {
		(void) snprintf(fname, sizeof fname, "file%d", i + 1);
		if ((fd = open(fname, O_RDONLY, 0666)) == -1)
			err(1, "child open %s", fname);
		files[i] = fd;
	}

	if (sendmsg(sock, &msg, 0))
		err(1, "child sendmsg");

	/*
	 * All done!
	 */
	exit(0);
}
@


1.18
log
@The kernel doesn't actually care what a sockaddr's sa_len is on input,
so don't waste code setting it
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.17 2011/07/06 19:48:10 matthew Exp $	*/
d63 2
a64 1
	int listensock, sock, pfd[2], fd, i;
d102 1
a102 1
		if (write(fd, buf, strlen(buf)) != strlen(buf))
d277 1
a277 1
	 * Open the files again, and pass them to the child over the socket.
@


1.17
log
@Add a regression test for file descriptor passing with UNIX sockets.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.16 2008/06/26 05:42:06 ray Exp $	*/
a122 1
		sun.sun_len = SUN_LEN(&sun);
a260 1
		sun.sun_len = SUN_LEN(&sun);
@


1.16
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.15 2008/03/24 16:11:08 deraadt Exp $	*/
d55 1
a55 1
void	child(int);
d75 1
d79 1
a79 1
	while ((i = getopt(argc, argv, "p")) != -1) {
d84 3
d110 1
a110 1
		if (socketpair(PF_LOCAL, SOCK_STREAM, 0, pfd) == -1)
d116 1
a116 1
		if ((listensock = socket(PF_LOCAL, SOCK_STREAM, 0)) == -1)
d146 1
a146 1
		child(pfd[1]);
d239 1
a239 1
child(int sock)
d256 1
a256 1
		if ((sock = socket(PF_LOCAL, SOCK_STREAM, 0)) == -1)
@


1.15
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.14 2008/03/15 16:49:15 hshoexer Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.14
log
@Repair usage of CMSG_SPACE and CMSG_LEN.  While there, send three fds
instead of just two as this decreases the propability that things just
work although the sizes are wrong (ie. 8 aligns correctly on both 32 and 64 bit
platforms even with wrong usage of CMSG_{LEN,SPACE} whereas 12 doesn't).
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.13 2008/03/13 01:49:53 deraadt Exp $	*/
d176 1
a176 1
	msg.msg_controllen = CMSG_LEN(sizeof(int) * 3);
d273 1
a273 1
	msg.msg_controllen = CMSG_LEN(sizeof(int) * 3);
@


1.13
log
@Correct CMSG_SPACE and CMSG_LEN usage everywhere in the tree. Due to
an extensive discussion with otto, kettenis, millert, and hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.12 2004/08/30 18:13:14 millert Exp $	*/
d79 1
a79 1
		char buf[CMSG_SPACE(sizeof(int) * 2)];
d99 1
a99 1
	for (i = 0; i < 2; i++) {
d176 1
a176 1
	msg.msg_controllen = sizeof(cmsgbuf.buf);
d197 1
a197 1
			if (cmp->cmsg_len != CMSG_LEN(sizeof(int) * 2))
d216 1
a216 1
		for (i = 0; i < 2; i++) {
d251 1
a251 1
		char buf[CMSG_SPACE(sizeof(int) * 2)];
d273 1
a273 1
	msg.msg_controllen = sizeof(cmsgbuf.buf);
d276 1
a276 1
	cmp->cmsg_len = CMSG_LEN(sizeof(int) * 2);
d284 1
a284 1
	for (i = 0; i < 2; i++) {
@


1.12
log
@Use CMSG_SPACE when allocating space for the control message.
Fixes a bogus regression on sparc64.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.11 2004/07/28 19:35:39 millert Exp $	*/
d77 4
a80 1
	char message[CMSG_SPACE(sizeof(int) * 2)];
d175 2
a176 2
	msg.msg_control = message;
	msg.msg_controllen = CMSG_LEN(sizeof(int) * 2);
d249 4
a252 1
	char cmsgbuf[CMSG_SPACE(sizeof(int) * 2)];
d272 2
a273 2
	msg.msg_control = cmsgbuf;
	msg.msg_controllen = CMSG_LEN(sizeof(int) * 2);
@


1.11
log
@Remove statement with no effect.
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.10 2004/04/27 18:51:17 millert Exp $	*/
d77 2
a78 2
	void *message;
	int msglen, pflag;
a92 4
	msglen = CMSG_LEN(sizeof(int) * 2);
	if ((message = malloc(msglen)) == NULL)
		err(1, "malloc");

d172 2
a173 2
	msg.msg_control = (caddr_t) message;
	msg.msg_controllen = msglen;
d246 1
a246 1
	struct cmsghdr *cmpf;
a248 4
	if ((cmpf = malloc(CMSG_LEN(sizeof(int) * 2))) == NULL)
		err(1, "malloc");
	files = (int *)CMSG_DATA(cmpf);

d265 9
d277 1
a283 9

	(void) memset(&msg, 0, sizeof(msg));
	msg.msg_control = (caddr_t)cmpf;
	msg.msg_controllen = CMSG_LEN(sizeof(int) * 2);

	cmp = cmpf;
	cmp->cmsg_len = CMSG_LEN(sizeof(int) * 2);
	cmp->cmsg_level = SOL_SOCKET;
	cmp->cmsg_type = SCM_RIGHTS;
@


1.10
log
@fd passing works over a socketpair too of course so document this.
Also test it in regress to be pedantic (though the kernel path is
really the same).  While there, remove cred-passing code that we
don't support.  OK deraadt@@,
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.9 2004/02/28 03:29:16 deraadt Exp $	*/
a189 1
	cmp = CMSG_FIRSTHDR(&msg);
@


1.9
log
@avoid bad functions; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.8 2003/07/31 21:48:10 deraadt Exp $	*/
d42 1
a42 1
 * Test passing of file descriptors and credentials over Unix domain sockets.
d62 1
a62 1
void	child(void);
d67 1
a67 3
main(argc, argv)
	int argc;
	char *argv[];
d70 1
a70 1
	int listensock, sock, fd, i, status;
a73 1
	struct sockcred *sc = NULL;
a75 1
	fd_set oob;
d78 2
a79 1
	int msglen;
d81 13
a93 1
	msglen = CMSG_LEN(MAX(sizeof(int) * 2, SOCKCREDSIZE(NGROUPS)));
d110 26
a135 23
	/*
	 * Create the listen socket.
	 */
	if ((listensock = socket(PF_LOCAL, SOCK_STREAM, 0)) == -1)
		err(1, "socket");

	(void) unlink(SOCK_NAME);
	(void) memset(&sun, 0, sizeof(sun));
	sun.sun_family = AF_LOCAL;
	(void) strlcpy(sun.sun_path, SOCK_NAME, sizeof sun.sun_path);
	sun.sun_len = SUN_LEN(&sun);

	i = 1;
#if 0
	if (setsockopt(listensock, 0, LOCAL_CREDS, &i, sizeof(i)) == -1)
		err(1, "setsockopt");
#endif

	if (bind(listensock, (struct sockaddr *)&sun, sizeof(sun)) == -1)
		err(1, "bind");

	if (listen(listensock, 1) == -1)
		err(1, "listen");
d148 3
a150 1
		child();
d154 9
a162 5
	/*
	 * Wait for the sender to connect.
	 */
	if ((sock = accept(listensock, (struct sockaddr *)&csun,
	    &csunlen)) == -1)
d164 1
d173 1
a173 1
	 * Grab the descriptors and credentials passed to us.
a205 7
		case SCM_CREDS:
			if (cmp->cmsg_len < sizeof(struct sockcred))
				errx(1, "bad cred control message length");

			sc = (struct sockcred *)CMSG_DATA(cmp);
			break;

a225 19
#if 0	/* XXX - OpenBSD doesn't implement this yet. */
	/*
	 * Double-check credentials.
	 */
	if (sc == NULL)
		warnx("didn't get cred control message");
	else {
		if (sc->sc_uid == getuid() &&
		    sc->sc_euid == geteuid() &&
		    sc->sc_gid == getgid() &&
		    sc->sc_egid == getegid())
			printf("Credentials match.\n");
		else
			printf("Credentials do NOT match.\n");
	}
#else
	printf("Credentials match.\n");
#endif

d244 1
a244 1
child()
d247 1
a247 1
	char fname[16], buf[64];
d249 1
a249 1
	int i, fd, sock;
d259 1
a259 1
	 * Create socket and connect to the receiver.
d261 8
a268 2
	if ((sock = socket(PF_LOCAL, SOCK_STREAM, 0)) == -1)
		errx(1, "child socket");
d270 3
a272 7
	(void) memset(&sun, 0, sizeof(sun));
	sun.sun_family = AF_LOCAL;
	(void) strlcpy(sun.sun_path, SOCK_NAME, sizeof sun.sun_path);
	sun.sun_len = SUN_LEN(&sun);

	if (connect(sock, (struct sockaddr *)&sun, sizeof(sun)) == -1)
		err(1, "child connect");
@


1.8
log
@various cleanups; david says results are same
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.7 2002/02/16 21:27:32 millert Exp $	*/
d110 1
a110 1
	(void) strcpy(sun.sun_path, SOCK_NAME);
d273 1
a273 1
	(void) strcpy(sun.sun_path, SOCK_NAME);
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.6 2002/02/11 05:31:25 art Exp $	*/
d92 1
a92 1
		(void) sprintf(fname, "file%d", i + 1);
d95 1
a95 1
		(void) sprintf(buf, "This is file %d.\n", i + 1);
d283 1
a283 1
		(void) sprintf(fname, "file%d", i + 1);
@


1.6
log
@OpenBSD doesn't implement the cred part yet. comment out.
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.5 2002/02/11 04:57:55 art Exp $	*/
d61 3
a63 3
int	main __P((int, char *[]));
void	child __P((void));
void	catch_sigchld __P((int));
@


1.5
log
@Make this 64-bit safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.4 2002/02/09 13:56:29 art Exp $	*/
d214 1
d229 3
d293 1
a293 1
	cmp = CMSG_FIRSTHDR(&msg);
@


1.4
log
@Let this test build.
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.3 2001/11/11 23:26:35 deraadt Exp $	*/
d55 1
a64 10
struct fdcmessage {
	struct cmsghdr cm;
	int files[2];
};

struct crcmessage {
	struct cmsghdr cm;
	char creds[SOCKCREDSIZE(NGROUPS)];
};

a74 4
	struct {
		struct fdcmessage fdcm;
		struct crcmessage crcm;
	} message;
d81 6
d157 2
a158 2
	msg.msg_control = (caddr_t) &message;
	msg.msg_controllen = sizeof(message);
d180 1
a180 1
			if (cmp->cmsg_len != sizeof(message.fdcm))
a251 1
	struct fdcmessage fdcm;
d254 6
d282 1
a282 1
		fdcm.files[i] = fd;
d286 2
a287 2
	msg.msg_control = (caddr_t) &fdcm;
	msg.msg_controllen = sizeof(fdcm);
d290 1
a290 1
	cmp->cmsg_len = sizeof(fdcm);
@


1.3
log
@signal race fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.2 2001/01/29 02:05:57 niklas Exp $	*/
d121 1
d124 1
d188 2
a189 1
				errx(1, "bad fd control message length");
d216 1
a216 1
				err(1, "read file %d", i + 1);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: unfdpass.c,v 1.3 1998/06/24 23:51:30 thorpej Exp $	*/
d243 1
d247 1
@


1.1
log
@copy from netbsd...
@
text
@d1 1
@

