head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.6
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8;
locks; strict;
comment	@ * @;


1.9
date	2017.02.19.19.59.12;	author tb;	state Exp;
branches;
next	1.8;
commitid	h6uTilcx9rCoSBMB;

1.8
date	2015.10.30.07.24.20;	author semarie;	state Exp;
branches;
next	1.7;
commitid	3tjL8emT1xXXpIC5;

1.7
date	2015.10.29.10.23.55;	author semarie;	state Exp;
branches;
next	1.6;
commitid	Lkty49WIn8PfqvJa;

1.6
date	2015.10.26.18.52.19;	author semarie;	state Exp;
branches;
next	1.5;
commitid	GSr8DcEToMYp39H4;

1.5
date	2015.10.18.13.01.40;	author semarie;	state Exp;
branches;
next	1.4;
commitid	pTfuR0UA3oDzz3la;

1.4
date	2015.10.18.12.54.25;	author semarie;	state Exp;
branches;
next	1.3;
commitid	ihI5rtz1NsGSHgE6;

1.3
date	2015.10.18.12.53.32;	author semarie;	state Exp;
branches;
next	1.2;
commitid	oidNdWJXGRAScNUI;

1.2
date	2015.10.09.11.38.05;	author semarie;	state Exp;
branches;
next	1.1;
commitid	EccnxJocNG6QZ9Um;

1.1
date	2015.10.09.06.44.13;	author semarie;	state Exp;
branches;
next	;
commitid	OMHrQoEqoUBdOfmt;


desc
@@


1.9
log
@Clean up regress/sys/kern/pledge/generic tests: many tests failed because
wlpaths is disabled in GENERIC kernels: remove or disable failing test
cases. Also remove the test_mmap() function testing the prot_exec promise
since it would need to be run on a wxallowed partition.

from semarie
@
text
@/*	$OpenBSD: main.c,v 1.8 2015/10/30 07:24:20 semarie Exp $ */
/*
 * Copyright (c) 2015 Sebastien Marie <semarie@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <signal.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "manager.h"

void test_request_stdio(void);
void test_request_tty(void);

static void
test_nop()
{
	/* nop */
}

static void
test_inet()
{
	int fd = socket(AF_INET, SOCK_STREAM, 0);
	int saved_errno = errno;
	close(fd);
	errno = saved_errno ? saved_errno : errno;
}

static void
test_kill()
{
	kill(0, SIGINT);
}

#ifdef WLPATHS 
static void
open_close(const char *filename)
{
	int fd;
	int saved_errno;

	errno = 0;
	printf("\n open_close(\"%s\")", filename);
	fd = open(filename, O_RDONLY);
	saved_errno = errno;
	printf(" fd=%d errno=%d", fd, errno);
	if (fd != -1)
		close(fd);
	errno = saved_errno;
}

static void
test_wpaths()
{
	/* absolute file */
	open_close("/etc/passwd");

	/* relative */
	open_close("generic");

	/* relative */
	open_close("../../../../../../../../../../../../../../../etc/passwd");

	/* ENOENT */
	open_close("/nonexistent");

	/* calling exit to flush stdout */
	printf("\n");
	exit(EXIT_SUCCESS);
}
#endif

static void
test_pledge()
{
	if (pledge("stdio rpath", NULL) != 0)
		_exit(errno);
}

#ifdef WLPATHS
static void
do_stat(const char *path)
{
	char resolved[PATH_MAX];
	struct stat sb;

	printf("\n stat(\"%s\"):", path);

	/* call realpath(3) */
	errno = 0;
	if (realpath(path, resolved) != NULL)
		printf(" realpath=\"%s\"", resolved);
	else
		printf(" realpath=failed(%d)", errno);

	/* call stat(2) */
	errno = 0;
	if (stat(path, &sb) == 0)
		printf(" uid=%d gid=%d mode=%04o", sb.st_uid, sb.st_gid,
		    sb.st_mode);
	else
		printf(" errno=%d", errno);
}

static void
test_stat()
{
	/* in whitelisted path */
	do_stat("/usr/share/man/man8/afterboot.8");
	do_stat("/usr/share/man/man8/");
	do_stat("/usr/share/man");

	/* parent of whitelisted path */
	do_stat("/usr/share");
	do_stat("/usr");
	do_stat("/");

	/* outside whitelisted path */
	do_stat("/usr/bin/gzip");

	/* calling exit to flush stdout */
	printf("\n");
	exit(EXIT_SUCCESS);
}
#endif

static void
test_rpath()
{
	int fd;
	char data[512];

	if ((fd = open("/dev/zero", O_RDONLY, 0)) == -1)
		_exit(errno);

	if (read(fd, data, sizeof(data)) == -1)
		_exit(errno);

	close(fd);
}

static void
test_wpath()
{
	int fd;
	char data[] = { 0x01, 0x02, 0x03, 0x04, 0x05 };

	if ((fd = open("/dev/null", O_WRONLY, 0)) == -1)
		_exit(errno);

	if (write(fd, data, sizeof(data)) == -1)
		_exit(errno);

	close(fd);
}

static void
test_cpath()
{
	const char filename[] = "/tmp/generic-test-cpath";

	if (mkdir(filename, S_IRWXU) == -1)
		_exit(errno);

	if (rmdir(filename) == -1)
		_exit(errno);
}

int
main(int argc, char *argv[])
{
	int ret = EXIT_SUCCESS;

	if (argc != 1)
		errx(1, "usage: %s", argv[0]);

	/*
	 * testsuite
	 */

	/* _exit is always allowed, and nothing else under flags=0 */
	start_test(&ret, "", NULL, test_nop);
	start_test(&ret, "", NULL, test_inet);

	/* test coredump */
	start_test(&ret, "abort", NULL, test_inet);

	/* inet under inet is ok (stdio is needed of close(2)) */
	start_test(&ret, "stdio", NULL, test_inet);
	start_test(&ret, "inet", NULL, test_inet);
	start_test(&ret, "stdio inet", NULL, test_inet);

	/* kill under fattr is forbidden */
	start_test(&ret, "fattr", NULL, test_kill);

	/* kill under stdio is allowed */
	start_test(&ret, "stdio", NULL, test_kill);

	/* stdio for open(2) */
	start_test(&ret, "stdio rpath", NULL, test_rpath);
	start_test(&ret, "stdio wpath", NULL, test_wpath);
	start_test(&ret, "cpath", NULL, test_cpath);

#if WLPATHS
	/*
	 * test whitelist path
	 */
	start_test(&ret, "stdio rpath", NULL, test_wpaths);
	start_test1(&ret, "stdio rpath", NULL, test_wpaths);
	start_test1(&ret, "stdio rpath", "/", test_wpaths);
	start_test1(&ret, "stdio rpath", "/etc", test_wpaths);
	start_test1(&ret, "stdio rpath", "/etc/", test_wpaths);
	start_test1(&ret, "stdio rpath", "/etc/passwd", test_wpaths);
	// XXX start_test1(&ret, "stdio rpath", "/etc/passwd/", test_wpaths);
	start_test1(&ret, "stdio rpath", "/bin", test_wpaths);
	start_test1(&ret, "stdio rpath", "generic", test_wpaths);
	start_test1(&ret, "stdio rpath", "", test_wpaths);
	start_test1(&ret, "stdio rpath", ".", test_wpaths);
#endif

	/*
	 * test pledge(2) arguments
	 */
	/* same request */
	start_test(&ret, "stdio rpath", NULL, test_pledge);
	/* reduce request */
	start_test(&ret, "stdio rpath wpath", NULL, test_pledge);
	/* add request */
	start_test(&ret, "stdio", NULL, test_pledge);
	/* change request */
	start_test(&ret, "stdio unix", NULL, test_pledge);

	/* test stat(2) */
#if WLPATHS
	start_test1(&ret, "stdio rpath", "/usr/share/man", test_stat);
#endif

	/* stdio */
	start_test(&ret, NULL, NULL, test_request_stdio);

	/* tty */
	start_test(&ret, NULL, NULL, test_request_tty);

	return (ret);
}
@


1.8
log
@regress: pledge

- for calling ioctl(2), we need "stdio" now: change test_request_tty
- for calling kill(2), we need "stdio" now: change test_kill
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 2015/10/29 10:23:55 semarie Exp $ */
d64 1
d100 1
d105 1
a105 3
	const char *wpaths[] = { "/sbin", NULL };

	if (pledge("stdio rpath", wpaths) != 0)
d109 1
d154 1
a154 19

static void
test_mmap()
{
	int fd;
	void * data;

	if ((fd = open("/dev/zero", O_RDONLY, 0)) == -1)
		_exit(errno);

	data = mmap(NULL, 4096, PROT_READ|PROT_WRITE|PROT_EXEC,
	    MAP_FILE|MAP_SHARED, fd, 0);

	if (data == MAP_FAILED)
		_exit(errno);

	munmap(data, 4096);
	close(fd);
}
d233 1
d248 1
a256 3
	/* reduce request (with same/other wpaths) */
	start_test1(&ret, "stdio rpath wpath", "/sbin", test_pledge);
	start_test1(&ret, "stdio rpath wpath", "/", test_pledge);
d263 1
d265 1
a265 4

	/* mmap */
	start_test1(&ret, "stdio rpath prot_exec", "/dev/zero", test_mmap);
	start_test1(&ret, "stdio rpath", "/dev/zero", test_mmap);
@


1.7
log
@regress pledge: rpath isn't needed anymore for mkdir()

make the cpath test more strict.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 2015/10/26 18:52:19 semarie Exp $ */
d242 2
a243 2
	/* kill under proc is allowed */
	start_test(&ret, "proc", NULL, test_kill);
@


1.6
log
@update regress suite for pledge
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 2015/10/18 13:01:40 semarie Exp $ */
d248 1
a248 1
	start_test(&ret, "rpath cpath", NULL, test_cpath);
@


1.5
log
@regress pledge: test kill()

since "inet" has PLEDGE_SELF, and now calling kill() to self is permitted with PLEDGE_SELF, try this with "fattr"
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 2015/10/18 12:54:25 semarie Exp $ */
d40 1
a64 33
test_allowed_syscalls()
{
	clock_getres(CLOCK_MONOTONIC, NULL);
	clock_gettime(CLOCK_MONOTONIC, NULL);
	/* fchdir(); */
	getdtablecount();
	getegid();
	geteuid();
	getgid();
	getgroups(0, NULL);
	getitimer(ITIMER_REAL, NULL);
	getlogin();
	getpgid(0);
	getpgrp();
	getpid();
	getppid();
	/* getresgid(); */
	/* getresuid(); */
	{ struct rlimit rl; getrlimit(RLIMIT_CORE, &rl); }
	getsid(0);
	getthrid();
	{ struct timeval tp; gettimeofday(&tp, NULL); }
	getuid();
	geteuid();
	issetugid();
	/* nanosleep(); */
	/* sigreturn(); */
	umask(0000);
	/* wait4(); */
}


static void
d234 2
a235 1
	/* inet under inet is ok */
d237 1
d239 1
a239 1
	/* kill under fattr is forbidden (don't have PLEDGE_SELF) */
d245 3
a247 22
	/* tests PLEDGE_SELF for permitted syscalls */
	start_test(&ret, "malloc",  NULL, test_allowed_syscalls);
	start_test(&ret, "rw",      NULL, test_allowed_syscalls);
	start_test(&ret, "stdio",   NULL, test_allowed_syscalls);
	start_test(&ret, "rpath",   NULL, test_allowed_syscalls);
	start_test(&ret, "wpath",   NULL, test_allowed_syscalls);
	start_test(&ret, "tmppath", NULL, test_allowed_syscalls);
	start_test(&ret, "inet",    NULL, test_allowed_syscalls);
	start_test(&ret, "unix",    NULL, test_allowed_syscalls);
	start_test(&ret, "dns",     NULL, test_allowed_syscalls);
	start_test(&ret, "getpw",   NULL, test_allowed_syscalls);

	/* tests req without PLEDGE_SELF for "permitted syscalls" */
	// XXX it is a documentation bug
	start_test(&ret, "ioctl", NULL, test_allowed_syscalls);
	start_test(&ret, "proc",  NULL, test_allowed_syscalls);
	start_test(&ret, "cpath", NULL, test_allowed_syscalls);
	start_test(&ret, "abort", NULL, test_allowed_syscalls);
	start_test(&ret, "fattr", NULL, test_allowed_syscalls);

	start_test(&ret, "rpath", NULL, test_rpath);
	start_test(&ret, "wpath", NULL, test_wpath);
a269 2
	/* same request (stdio = malloc rw) */
	start_test(&ret, "malloc rw rpath", NULL, test_pledge);
d278 1
a278 1
	start_test(&ret, "unix", NULL, test_pledge);
d284 5
a288 2
	start_test1(&ret, "rpath malloc prot_exec", "/dev/zero", test_mmap);
	start_test1(&ret, "rpath malloc", "/dev/zero", test_mmap);
@


1.4
log
@regress pledge: remove cmsg

it has no sens to keep it.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 2015/10/18 12:53:32 semarie Exp $ */
d269 2
a270 2
	/* kill under inet is forbidden */
	start_test(&ret, "inet", NULL, test_kill);
@


1.3
log
@regress pledge: cpath test

you need to read the directory before creating something in. add rpath
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.2 2015/10/09 11:38:05 semarie Exp $ */
a288 1
	start_test(&ret, "cmsg",  NULL, test_allowed_syscalls);
@


1.2
log
@add "tty" regress for pledge
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.1 2015/10/09 06:44:13 semarie Exp $ */
d298 1
a298 1
	start_test(&ret, "cpath", NULL, test_cpath);
@


1.1
log
@follow tame->pledge in regress
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 2015/10/06 15:45:31 semarie Exp $ */
d40 2
d338 3
@

