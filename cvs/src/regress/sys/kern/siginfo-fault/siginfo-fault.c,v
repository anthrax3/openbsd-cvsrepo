head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.2
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.10
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.8
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.6
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2017.07.22.16.12.27;	author kettenis;	state Exp;
branches;
next	1.5;
commitid	A0AKTRq6Bue1w38S;

1.5
date	2017.07.20.18.22.25;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	eXLHJ8oEZQtPpKri;

1.4
date	2017.07.13.00.29.14;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	RqVnzTUaj3FcNMpi;

1.3
date	2016.09.28.08.55.11;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	QzwZbNKAsra3uTNN;

1.2
date	2014.06.24.19.05.42;	author matthew;	state Exp;
branches;
next	1.1;
commitid	gnwV5prRUxzhOJbb;

1.1
date	2014.06.23.21.10.03;	author matthew;	state Exp;
branches;
next	;
commitid	wkQaTzWNTKtHb7YT;


desc
@@


1.6
log
@Tolerate imprecise fault address on sparc64 where the hardware doesn't provide
tho low order bits.

ok deraadt@@, visa@@
@
text
@/*	$OpenBSD: siginfo-fault.c,v 1.5 2017/07/20 18:22:25 bluhm Exp $	*/
/*
 * Copyright (c) 2014 Google Inc.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/mman.h>

#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <setjmp.h>
#include <signal.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/*
 * Some architectures deliver an imprecise fault address.
 */
#ifdef __sparc64__
#define EXPADDR_MASK	~(3UL)
#else
#define EXPADDR_MASK	~(0UL)
#endif

#define CHECK_EQ(a, b) assert((a) == (b))
#define CHECK_NE(a, b) assert((a) != (b))
#define CHECK_LE(a, b) assert((a) <= (b))
#define FAIL() assert(0)

static jmp_buf env;
static volatile int gotsigno;
static volatile siginfo_t gotsi;

static void
sigsegv(int signo, siginfo_t *si, void *ctx)
{
	gotsigno = signo;
	gotsi = *si;
	siglongjmp(env, 1);
}

static const char *
strsigcode(int signum, int sigcode)
{
	switch (signum) {
	case SIGSEGV:
		switch (sigcode) {
		case SEGV_MAPERR:
			return "address not mapped to object";
		case SEGV_ACCERR:
			return "invalid permissions";
		}
		break;
	case SIGBUS:
		switch (sigcode) {
		case BUS_ADRALN:
			return "invalid address alignment";
		case BUS_ADRERR:
			return "non-existent physical address";
		case BUS_OBJERR:
			return "object specific hardware error";
		}
		break;
	}
	return "unknown";
}

static int
checksig(const char *name, int expsigno, int expcode, volatile char *expaddr)
{
	int fail = 0;
	char str1[NL_TEXTMAX], str2[NL_TEXTMAX];

	expaddr = (char *)((uintptr_t)expaddr & EXPADDR_MASK);

	if (expsigno != gotsigno) {
		strlcpy(str1, strsignal(expsigno), sizeof(str1));
		strlcpy(str2, strsignal(gotsigno), sizeof(str2));
		fprintf(stderr, "%s signo: expect %d (%s), actual %d (%s)\n",
		    name, expsigno, str1, gotsigno, str2);
		++fail;
	}
	if (expsigno != gotsi.si_signo) {
		strlcpy(str1, strsignal(expsigno), sizeof(str1));
		strlcpy(str2, strsignal(gotsi.si_signo), sizeof(str2));
		fprintf(stderr, "%s si_signo: expect %d (%s), actual %d (%s)\n",
		    name, expsigno, str1, gotsi.si_signo, str2);
		++fail;
	}
	if (expcode != gotsi.si_code) {
		fprintf(stderr, "%s si_code: expect %d (%s), actual %d (%s)\n",
		    name, expcode, strsigcode(expsigno, expcode),
		    gotsi.si_code, strsigcode(gotsigno, gotsi.si_code));
		++fail;
	}
	if (expaddr != gotsi.si_addr) {
		fprintf(stderr, "%s si_addr: expect %p, actual %p\n",
		    name, expaddr, gotsi.si_addr);
		++fail;
	}
	return (fail);
}

int
main()
{
	int fail = 0;
	long pagesize = sysconf(_SC_PAGESIZE);
	CHECK_NE(-1, pagesize);

	const struct sigaction sa = {
		.sa_sigaction = sigsegv,
		.sa_flags = SA_SIGINFO,
	};
	CHECK_EQ(0, sigaction(SIGSEGV, &sa, NULL));
	CHECK_EQ(0, sigaction(SIGBUS, &sa, NULL));

	volatile char *p;
	CHECK_NE(MAP_FAILED, (p = mmap(NULL, pagesize, PROT_NONE,
	    MAP_PRIVATE|MAP_ANON, -1, 0)));

	CHECK_EQ(0, mprotect((void *)p, pagesize, PROT_READ));
	if (sigsetjmp(env, 1) == 0) {
		p[0] = 1;
		FAIL();
	}
	fail += checksig("mprotect read", SIGSEGV, SEGV_ACCERR, p);

	CHECK_EQ(0, mprotect((void *)p, pagesize, PROT_NONE));
	if (sigsetjmp(env, 1) == 0) {
		(void)p[1];
		FAIL();
	}
	fail += checksig("mprotect none", SIGSEGV, SEGV_ACCERR, p + 1);

	CHECK_EQ(0, munmap((void *)p, pagesize));
	if (sigsetjmp(env, 1) == 0) {
		(void)p[2];
		FAIL();
	}
	fail += checksig("munmap", SIGSEGV, SEGV_MAPERR, p + 2);

	char filename[] = "/tmp/siginfo-fault.XXXXXXXX";
	int fd;
	CHECK_LE(0, (fd = mkstemp(filename)));
	CHECK_EQ(0, unlink(filename));
	CHECK_EQ(0, ftruncate(fd, 0));  /* just in case */
	CHECK_NE(MAP_FAILED, (p = mmap(NULL, pagesize, PROT_READ|PROT_WRITE,
	    MAP_SHARED, fd, 0)));
	CHECK_EQ(0, close(fd));

	if (sigsetjmp(env, 1) == 0) {
		p[3] = 1;
		FAIL();
	}
	fail += checksig("mmap file", SIGBUS, BUS_OBJERR, p + 3);

	return (fail);
}
@


1.5
log
@Accessing a mmap(2)ed file behind its end should result in a SIGBUS
according to POSIX.  Bring regression test and kernel in line for
amd64 and i386.  Other architectures have to follow.
OK deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: siginfo-fault.c,v 1.4 2017/07/13 00:29:14 bluhm Exp $	*/
d27 1
d32 9
d89 3
@


1.4
log
@Improve error messages of siginfo-fault regress to make clear which
tests fail.  First run all checks and report problmes, finally exit
with the total number of failures.  Unfortunately it still fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: siginfo-fault.c,v 1.3 2016/09/28 08:55:11 bluhm Exp $	*/
d159 1
a159 1
	fail += checksig("mmap file", SIGBUS, BUS_ADRERR, p + 3);
@


1.3
log
@If stdout is not line buffered, messages got lost when assert() was
called.  Print errors to stderr instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: siginfo-fault.c,v 1.2 2014/06/24 19:05:42 matthew Exp $	*/
d19 1
d23 1
d33 1
a33 1
#define CHECK_GE(a, b) assert((a) >= (b))
d45 27
a71 1
        siglongjmp(env, 1);
d74 2
a75 2
static void
checksig(int expsigno, int expcode, volatile char *expaddr)
d78 1
d80 4
a83 3
		fprintf(stderr, "signo: expect %d (%s), actual %d (%s)\n",
		    expsigno, strsignal(expsigno),
		    gotsigno, strsignal(gotsigno));
d87 4
a90 3
		fprintf(stderr, "signo: expect %d (%s), actual %d (%s)\n",
		    expsigno, strsignal(expsigno),
		    gotsi.si_signo, strsignal(gotsi.si_signo));
d94 3
a96 2
		fprintf(stderr, "si_code: expect %d, actual %d\n",
		    expcode, gotsi.si_code);
d100 2
a101 2
		fprintf(stderr, "si_addr: expect %p, actual %p\n",
		    expaddr, gotsi.si_addr);
d104 1
a104 1
	CHECK_EQ(0, fail);
d110 3
a112 2
        long pagesize = sysconf(_SC_PAGESIZE);
        CHECK_NE(-1, pagesize);
d114 10
a123 10
        const struct sigaction sa = {
                .sa_sigaction = sigsegv,
                .sa_flags = SA_SIGINFO,
        };
        CHECK_EQ(0, sigaction(SIGSEGV, &sa, NULL));
        CHECK_EQ(0, sigaction(SIGBUS, &sa, NULL));

        volatile char *p = mmap(NULL, pagesize, PROT_READ,
	    MAP_PRIVATE|MAP_ANON, -1, 0);
        CHECK_NE(MAP_FAILED, p);
d125 2
a126 1
        if (sigsetjmp(env, 1) == 0) {
d128 3
a130 3
                FAIL();
        }
	checksig(SIGSEGV, SEGV_ACCERR, p);
d133 1
a133 1
        if (sigsetjmp(env, 1) == 0) {
d135 3
a137 3
                FAIL();
        }
	checksig(SIGSEGV, SEGV_ACCERR, p + 1);
d140 1
a140 1
        if (sigsetjmp(env, 1) == 0) {
d142 3
a144 3
                FAIL();
        }
	checksig(SIGSEGV, SEGV_MAPERR, p + 2);
d147 2
a148 2
	int fd = mkstemp(filename);
	CHECK_GE(fd, 0);
d151 2
a152 2
	p = mmap(NULL, pagesize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
	CHECK_NE(MAP_FAILED, p);
d159 1
a159 1
	checksig(SIGBUS, BUS_ADRERR, p + 3);
d161 1
a161 1
        return (0);
@


1.2
log
@POSIX doesn't specify MAP_FILE and it's a noop anyway, so remove it to
make test portable to other OSes.
@
text
@d1 1
a1 1
/*	$OpenBSD: siginfo-fault.c,v 1.1 2014/06/23 21:10:03 matthew Exp $	*/
d51 3
a53 2
		printf("signo: expect %d (%s)", expsigno, strsignal(expsigno));
		printf(", actual %d (%s)\n", gotsigno, strsignal(gotsigno));
d57 3
a59 2
		printf("signo: expect %d (%s)", expsigno, strsignal(expsigno));
		printf(", actual %d (%s)\n", gotsi.si_signo, strsignal(gotsi.si_signo));
d63 2
a64 1
		printf("si_code: expect %d, actual %d\n", expcode, gotsi.si_code);
d68 2
a69 1
		printf("si_addr: expect %p, actual %p\n", expaddr, gotsi.si_addr);
@


1.1
log
@Add regress test for SIGSEGV and SIGBUS siginfo semantics.

According to POSIX, SIGSEGV should specify SEGV_ACCERR if the memory
pages are mapped, but the protections don't match the user's access
attempts, while SEGV_MAPERR should only be specified for pages that
are unmapped.  Some platforms currently handle this correctly, but not
all.

Additionally, SIGBUS/BUS_ADRERR should be generated instead of SIGSEGV
for access to file mapped pages that exceed the end of the file.
(Thanks to kettenis@@ for suggesting this test.)

Currently failing, so not linked into the regress tree yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 1
a113 1
	p = mmap(NULL, pagesize, PROT_READ|PROT_WRITE, MAP_FILE|MAP_SHARED, fd, 0);
@

