head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.4
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.5.0.52
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.50
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.48
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.46
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.42
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.40
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.38
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.36
	OPENBSD_5_0:1.5.0.34
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.32
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.30
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5;
locks; strict;
comment	@ * @;


1.8
date	2016.09.21.15.26.54;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	WCQhDKFR7lfSnNON;

1.7
date	2016.09.20.23.05.27;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	5GU2P4d8AX6RwJst;

1.6
date	2015.08.13.10.11.38;	author uebayasi;	state Exp;
branches;
next	1.5;
commitid	akmg9iXFpq1iX7Ge;

1.5
date	2003.07.31.21.48.08;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.31.03.23.41;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.12.18.36.47;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.12.05.08.51;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.12.05.06.47;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Use /dev/console as a template for the pseudo tty, stdin may be not
a terminal.  Check wether tcgetattr() can read the values.  Do not
only verify that kqueue does not report unwanted events but also
that expected events exist.
@
text
@/*	$OpenBSD: kqueue-pty.c,v 1.7 2016/09/20 23:05:27 bluhm Exp $	*/

/*	Written by Michael Shalayeff, 2003, Public Domain	*/

#include <sys/types.h>
#include <sys/time.h>
#include <sys/event.h>

#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include <util.h>

#include "main.h"

static int
pty_check(int kq, struct kevent *ev, int n, int rm, int rs, int wm, int ws)
{
	struct timespec ts;
	int i;

	ts.tv_sec = 0;
	ts.tv_nsec = 0;
	if ((n = kevent(kq, NULL, 0, ev, n, &ts)) < 0)
		err(1, "slave: kevent");

	ASSX(n != 0);

	for (i = 0; i < n; i++, ev++) {
		if (ev->filter == EVFILT_READ) {
			ASSX(ev->ident != -rm);
			ASSX(ev->ident != -rs);
			if (ev->ident == rm)
				rm = 0;
			if (ev->ident == rs)
				rs = 0;
		} else if (ev->filter == EVFILT_WRITE) {
			ASSX(ev->ident != -wm);
			ASSX(ev->ident != -ws);
			if (ev->ident == wm)
				wm = 0;
			if (ev->ident == ws)
				ws = 0;
		} else
			errx(1, "unknown event");
	}
	ASSX(rm <= 0);
	ASSX(rs <= 0);
	ASSX(wm <= 0);
	ASSX(ws <= 0);

	return (0);
}

int
do_pty(void)
{
	struct kevent ev[4];
	struct termios tt;
	int fd, kq, massa, slave;
	char buf[1024];

	ASS((fd = open("/dev/console", O_RDONLY, &tt)) > 0,
	    warn("open /dev/console"));
	ASS(tcgetattr(fd, &tt) == 0,
	    warn("tcgetattr"));
	cfmakeraw(&tt);
	tt.c_lflag &= ~ECHO;
	if (openpty(&massa, &slave, NULL, &tt, NULL) < 0)
		err(1, "openpty");
	if (fcntl(massa, F_SETFL, O_NONBLOCK) < 0)
		err(1, "massa: fcntl");
	if (fcntl(slave, F_SETFL, O_NONBLOCK) < 0)
		err(1, "massa: fcntl");
	if ((kq = kqueue()) == -1)
		err(1, "kqueue");

	/* test the read from the slave works */
	EV_SET(&ev[0], massa, EVFILT_READ,  EV_ADD|EV_ENABLE, 0, 0, NULL);
	EV_SET(&ev[1], massa, EVFILT_WRITE, EV_ADD|EV_ENABLE, 0, 0, NULL);
	EV_SET(&ev[2], slave, EVFILT_READ,  EV_ADD|EV_ENABLE, 0, 0, NULL);
	EV_SET(&ev[3], slave, EVFILT_WRITE, EV_ADD|EV_ENABLE, 0, 0, NULL);
	if (kevent(kq, ev, 4, NULL, 0, NULL) < 0)
		err(1, "slave: kevent add");

	memset(buf, 0, sizeof(buf));

	ASSX(pty_check(kq, ev, 4, -massa, -slave, massa, slave) == 0);

	if (write(massa, " ", 1) != 1)
		err(1, "massa: write");

	ASSX(pty_check(kq, ev, 4, -massa, slave, massa, slave) == 0);

	read(slave, buf, sizeof(buf));

	ASSX(pty_check(kq, ev, 4, -massa, -slave, massa, slave) == 0);

	while (write(massa, buf, sizeof(buf)) > 0)
		continue;

	ASSX(pty_check(kq, ev, 4, -massa, slave, -massa, slave) == 0);

	read(slave, buf, 1);

	ASSX(pty_check(kq, ev, 4, -massa, slave, massa, slave) == 0);

	while (read(slave, buf, sizeof(buf)) > 0)
		continue;

	ASSX(pty_check(kq, ev, 4, -massa, -slave, massa, slave) == 0);

	return (0);
}
@


1.7
log
@To make debugging the kqueue test easier, always print the assertion
failure before returning.
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue-pty.c,v 1.6 2015/08/13 10:11:38 uebayasi Exp $	*/
d34 6
a39 2
			ASSX(rm > 0 || ev->ident != -rm);
			ASSX(rs > 0 || ev->ident != -rs);
d41 6
a46 2
			ASSX(wm > 0 || ev->ident != -wm);
			ASSX(ws > 0 || ev->ident != -ws);
d50 4
d63 1
a63 1
	int kq, massa, slave;
d66 4
a69 1
	tcgetattr(STDIN_FILENO, &tt);
d89 3
a91 1
	memset(buf, 0, sizeof buf);
@


1.6
log
@Zero-clear test buffer.  KNF while here.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d8 3
d12 2
d16 2
a17 4
#include <termios.h>
#include <fcntl.h>
#include <err.h>
#include <string.h>
d30 1
a30 2
	if (n == 0)
		return (1);
d34 2
a35 4
			if (rm < 0 && ev->ident == -rm)
				return (1);
			if (rs < 0 && ev->ident == -rs)
				return (1);
d37 2
a38 4
			if (wm < 0 && ev->ident == -wm)
				return (1);
			if (ws < 0 && ev->ident == -ws)
				return (1);
a45 2
int do_pty(void);

d79 1
a79 2
	if (pty_check(kq, ev, 4, -massa, slave, massa, slave))
		return (1);
d83 1
a83 2
	if (pty_check(kq, ev, 4, -massa, -slave, massa, slave))
		return (1);
d88 1
a88 2
	if (pty_check(kq, ev, 4, -massa, slave, -massa, slave))
		return (1);
d92 1
a92 2
	if (pty_check(kq, ev, 4, -massa, slave, massa, slave))
		return (1);
d97 1
a97 2
	if (pty_check(kq, ev, 4, -massa, -slave, massa, slave))
		return (1);
@


1.5
log
@various cleanups; david says results are same
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue-pty.c,v 1.4 2003/07/31 03:23:41 mickey Exp $	*/
d14 1
d78 2
d91 2
a92 1
	while (write(massa, buf, sizeof(buf)) > 0);
d102 2
a103 1
	while (read(slave, buf, sizeof(buf)) > 0);
@


1.4
log
@fix the license
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue-pty.c,v 1.3 2003/06/12 18:36:47 mickey Exp $	*/
d15 1
a15 1
int
d46 2
@


1.3
log
@it has been brought to my attention that i have forgotten a license on this file
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue-pty.c,v 1.2 2003/06/12 05:08:51 mickey Exp $	*/
d3 1
a3 1
/*	Copyright (c) 2003 Michael Shalayeff, Public Domain	*/
@


1.2
log
@ugh. cleanup debugging
@
text
@d1 3
a3 1
/*	$OpenBSD: kqueue-pty.c,v 1.1 2003/06/12 05:06:47 mickey Exp $	*/
@


1.1
log
@test for kqueue on ptys (to verify pr3209)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a12 2
#define	EVDUMP(ev)	printf("%d %d %d %d %d", ev->ident, ev->filter, ev->flags, ev->fflags, ev->data)

a26 1
	printf("%d:\n", n);
a27 1
		EVDUMP(ev);
d29 4
a32 6
			if (rm < 0 && ev->ident == -rm) {
				printf(" bad");
			}
			if (rs < 0 && ev->ident == -rs) {
				printf(" bad");
			}
d34 4
a37 6
			if (wm < 0 && ev->ident == -wm) {
				printf(" bad");
			}
			if (ws < 0 && ev->ident == -ws) {
				printf(" bad");
			}
a39 1
		printf("\n");
a40 1
	printf("\n");
@

