head	1.6;
access;
symbols
	OPENBSD_6_0:1.5.0.8
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@# @;


1.6
date	2016.08.29.16.25.14;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	ZPJ1SkfRpR6j1V1X;

1.5
date	2014.10.30.20.41.02;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	kPjswYykjhh99Ou8;

1.4
date	2014.07.11.20.41.20;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	rghTlQRdYGi3EoZU;

1.3
date	2014.01.18.05.54.52;	author martynas;	state Exp;
branches;
next	1.2;

1.2
date	2014.01.08.23.32.17;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2013.01.08.21.42.19;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Make socket splicing performance test pass in multiple environments.
When running the setup over two machines, build required binaries
on remote machine.  Avoid localhost nameserver lookup, just use
127.0.0.1.  Use greater timeout.
@
text
@#	$OpenBSD: Makefile,v 1.5 2014/10/30 20:41:02 bluhm Exp $

PROG ?=		relay
CFLAGS +=	-Wall -Werror
CFLAGS +=	-Wstrict-prototypes -Wmissing-prototypes
CFLAGS +=	-Wmissing-declarations
CFLAGS +=	-Wshadow -Wpointer-arith -Wcast-qual
CFLAGS +=	-Wsign-compare
NOMAN =		yes

TARGETS =	tcp-copy tcp-splice udp-copy udp-splice
CLEANFILES +=	copy splice

.include <bsd.regress.mk>

copy splice: ${PROG}
	ln -s relay $@@

remote-setup:
.if ! empty (REMOTE_SSH)
	ssh ${REMOTE_SSH} 'cd ${.CURDIR} && make copy splice'
.endif

.for p in tcp udp
.for r in copy splice

run-regress-$p-$r: $r remote-setup
	@@echo '\n======== $@@ ========'
	-pkill -x tcpbench
.if empty (REMOTE_SSH)
	./$r ${p:S/tcp//:S/udp/-u/} -4 12345 127.0.0.1 12346 & \
	rpid=$$! ; \
	tcpbench ${p:S/tcp//:S/udp/-u/} -4 -t 7 -s -p 12346 & \
	sleep 1 ; \
	tcpbench ${p:S/tcp//:S/udp/-u/} -4 -t 5 127.0.0.1 ; \
	kill $$rpid ; \
	pkill -x tcpbench
.else
	ssh -f ${REMOTE_SSH} 'cd ${.CURDIR} && make PROG= LOCAL_ADDR=${LOCAL_ADDR} REMOTE_ADDR=${REMOTE_ADDR} remote-regress-$p-$r' ; \
	sleep 2 ; \
	tcpbench ${p:S/tcp//:S/udp/-u/} -t 7 -b ${LOCAL_ADDR} -s -p 12346 & \
	sleep 1 ; \
	tcpbench ${p:S/tcp//:S/udp/-u/} -t 5 ${REMOTE_ADDR} ; \
	pkill -x tcpbench
.endif
	sleep 1

remote-regress-$p-$r: $r
	-pkill -x $r
	./$r ${p:S/tcp//:S/udp/-u/} -b ${REMOTE_ADDR} 12345 ${LOCAL_ADDR} 12346 & \
	rpid=$$! ; \
	sleep 10 ; \
	kill $$rpid

.endfor
.endfor
@


1.5
log
@Add some pkill and sleep to make socket splicing performance tests
more reliable.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.4 2014/07/11 20:41:20 bluhm Exp $
d19 5
d27 1
a27 1
run-regress-$p-$r: $r
d31 1
a31 1
	./$r ${p:S/tcp//:S/udp/-u/} 12345 localhost 12346 & \
d33 1
a33 1
	tcpbench ${p:S/tcp//:S/udp/-u/} -t 7 -s -p 12346 & \
d35 1
a35 1
	tcpbench ${p:S/tcp//:S/udp/-u/} -t 5 localhost ; \
d52 1
a52 1
	sleep 7 ; \
@


1.4
log
@Make the test output easier to read by splitting the test cases
with an empty line and a header line.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.3 2014/01/18 05:54:52 martynas Exp $
d24 1
d35 1
d44 1
@


1.3
log
@Remove -Wbounded:  it is now the compiler default.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.2 2014/01/08 23:32:17 bluhm Exp $
d23 1
a23 2
	@@echo
	@@echo $@@
@


1.2
log
@Set socket buffer size to fixed value of 100000 octets.  This
prevents that the socket splicing performance test interferes with
the dynamic TCP buffer size adjusting.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.1 2013/01/08 21:42:19 bluhm Exp $
d8 1
a8 1
CFLAGS +=	-Wsign-compare -Wbounded
@


1.1
log
@Add performance test for socket splicing.  Two tcpbench processes
are used as server and client.  Between them is a relay process
that can either copy or splice the data.  Benchmarking is done for
TCP and UDP and for copy and splice.  All tests are executed on
localhost per default.  Alternatively the relay process can be
started on a remote machine.
Depending on hardware and environment socket splicing has increased
my throughput by 30% or up to 150% in this test.
@
text
@d1 1
a1 1
#	$OpenBSD$
d23 2
@

