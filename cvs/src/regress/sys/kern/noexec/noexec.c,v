head	1.16;
access;
symbols
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.8
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.6
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.11.0.14
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.12
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.10
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.8
	OPENBSD_5_0:1.11.0.6
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.8
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.10
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.6
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.16
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.14
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.12
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.10
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.16
date	2016.09.24.07.26.14;	author otto;	state Exp;
branches;
next	1.15;
commitid	ykokAP4SAlpyfJon;

1.15
date	2014.04.18.14.38.21;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2014.01.10.13.45.00;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2013.07.30.15.46.32;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2013.07.30.11.15.33;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.27.17.42.23;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2007.12.27.17.56.44;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.23.08.21.53;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.25.23.35.06;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.31.21.48.09;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.05.15.34.46;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.03.00.08.58;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.23.21.46.04;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.05.22.41.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.03.15.29.33;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.31.22.56.01;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.16
log
@recpect W^X, sparc64 still has a problem: non-exec mmap: execute
#1 is done, the others not. ok kettenis@@ millert@@
@
text
@/*	$OpenBSD: noexec.c,v 1.15 2014/04/18 14:38:21 guenther Exp $	*/

/*
 * Copyright (c) 2002,2003 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/mman.h>
#include <unistd.h>
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <err.h>

volatile sig_atomic_t fail;
int page_size;
char label[64] = "non-exec ";

#define PAD 64*1024
#define	MAXPAGESIZE 8192
#define TESTSZ 256	/* assuming the testfly() will fit */
u_int64_t data[(PAD + TESTSZ + PAD + MAXPAGESIZE) / 8] = { 0 };
u_int64_t bss[(PAD + TESTSZ + PAD + MAXPAGESIZE) / 8];

void testfly(void);

static void
fdcache(void *p, size_t size)
{
#ifdef __hppa__
	__asm volatile(	/* XXX this hardcodes the TESTSZ */
	    "fdc,m	%1(%0)\n\t"
	    "fdc,m	%1(%0)\n\t"
	    "fdc,m	%1(%0)\n\t"
	    "fdc,m	%1(%0)\n\t"
	    "fdc,m	%1(%0)\n\t"
	    "fdc,m	%1(%0)\n\t"
	    "fdc,m	%1(%0)\n\t"
	    "fdc,m	%1(%0)"
	    : "+r" (p) : "r" (32));
#endif
#ifdef __sparc64__
	char *s = p;
	int i;

	for (i = 0; i < TESTSZ; i += 8)
	  __asm volatile("flush %0" : : "r" (s + i) : "memory");
#endif
}

static void
sigsegv(int sig, siginfo_t *sip, void *scp)
{
	_exit(fail);
}

static int
noexec(void *p, size_t size)
{
	fail = 0;
	printf("%s: execute\n", label);
	fflush(stdout);
	((void (*)(void))p)();

	return (1);
}

static int
noexec_mprotect(void *p, size_t size)
{

	/* here we must fail on segv since we said it gets executable */
	fail = 1;
	if (mprotect(p, size, PROT_READ|PROT_EXEC) < 0)
		err(1, "mprotect 1");
	printf("%s: execute\n", label);
	fflush(stdout);
	((void (*)(void))p)();

	/* here we are successful on segv and fail if it still executes */
	fail = 0;
	if (mprotect(p, size, PROT_READ) < 0)
		err(1, "mprotect 2");
	printf("%s: catch a signal\n", label);
	fflush(stdout);
	((void (*)(void))p)();

	return (1);
}

static void *
getaddr(void *a)
{
	void *ret;

	if ((void *)&ret < a)
		ret = (void *)((u_long)&ret - 4 * page_size);
	else
		ret = (void *)((u_long)&ret + 4 * page_size);

	return (void *)((u_long)ret & ~(page_size - 1));
}

static int
noexec_mmap(void *p, size_t size)
{
	memcpy(p + page_size * 1, p, page_size);
	memcpy(p + page_size * 2, p, page_size);
	fdcache(p + page_size * 1, TESTSZ);
	fdcache(p + page_size * 2, TESTSZ);
	if (mprotect(p, size + 2 * page_size, PROT_READ|PROT_EXEC) != 0)
		err(1, "mprotect");

	/* here we must fail on segv since we said it gets executable */
	fail = 1;

	printf("%s: execute #1\n", label);
	fflush(stdout);
	((void (*)(void))p)();

	/* unmap the first page to see that the higher page is still exec */
	if (munmap(p, page_size) < 0)
		err(1, "munmap");

	p += page_size;
	printf("%s: execute #2\n", label);
	fflush(stdout);
	((void (*)(void))p)();

	/* unmap the last page to see that the lower page is still exec */
	if (munmap(p + page_size, page_size) < 0)
		err(1, "munmap");

	printf("%s: execute #3\n", label);
	fflush(stdout);
	((void (*)(void))p)();

	return (0);
}

static void
usage(void)
{
	extern char *__progname;
	fprintf(stderr, "Usage: %s [-s <size>] -[TDBHS] [-p] [-m]\n",
	    __progname);
	exit(2);
}

int
main(int argc, char *argv[])
{
	u_int64_t stack[TESTSZ/8];	/* assuming the testfly() will fit */
	struct sigaction sa;
	int (*func)(void *, size_t);
	size_t size;
	char *ep;
	void *p, *ptr;
	int ch;

	if ((page_size = sysconf(_SC_PAGESIZE)) < 0)
		err(1, "sysconf");

	setvbuf(stdout, NULL, _IONBF, 0);
	setvbuf(stderr, NULL, _IONBF, 0);

	p = NULL;
	func = &noexec;
	size = TESTSZ;
	while ((ch = getopt(argc, argv, "TDBHSmps:")) != -1) {
		if (p == NULL) {
			switch (ch) {
			case 'T':
				p = &testfly;
				(void) strlcat(label, "text", sizeof(label));
				continue;
			case 'D':
				p = &data[(PAD + page_size) / 8];
				p = (void *)((long)p & ~(page_size - 1));
				(void) strlcat(label, "data", sizeof(label));
				continue;
			case 'B':
				p = &bss[(PAD + page_size) / 8];
				p = (void *)((long)p & ~(page_size - 1));
				(void) strlcat(label, "bss", sizeof(label));
				continue;
			case 'H':
				p = malloc(size + 2 * page_size);
				if (p == NULL)
					err(2, "malloc");
				p += page_size;
				p = (void *)((long)p & ~(page_size - 1));
				(void) strlcat(label, "heap", sizeof(label));
				continue;
			case 'S':
				p = getaddr(&stack);
				(void) strlcat(label, "stack", sizeof(label));
				continue;
			case 's':	/* only valid for heap and size */
				size = strtoul(optarg, &ep, 0);
				if (size > ULONG_MAX)
					errno = ERANGE;
				if (errno)
					err(1, "invalid size: %s", optarg);
				if (*ep)
					errx(1, "invalid size: %s", optarg);
				continue;
			}
		}
		switch (ch) {
		case 'm':
			if (p) {
				if ((ptr = mmap(p, size + 2 * page_size,
				    PROT_READ|PROT_WRITE,
				    MAP_ANON|MAP_FIXED, -1, 0)) == MAP_FAILED)
					err(1, "mmap");
				(void) strlcat(label, "-mmap", sizeof(label));
			} else {
				if ((ptr = mmap(p, size + 2 * page_size,
				    PROT_READ|PROT_WRITE,
				    MAP_ANON, -1, 0)) == MAP_FAILED)
					err(1, "mmap");
				func = &noexec_mmap;
				(void) strlcat(label, "mmap", sizeof(label));
			}
			p = ptr;
			break;
		case 'p':
			func = &noexec_mprotect;
			(void) strlcat(label, "-mprotect", sizeof(label));
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc > 0)
		usage();

	if (p == NULL)
		exit(2);

	sa.sa_sigaction = &sigsegv;
	sa.sa_flags = SA_SIGINFO;
	sigemptyset(&sa.sa_mask);
	sigaction(SIGSEGV, &sa, NULL);

	if (p != &testfly) {
		memcpy(p, &testfly, TESTSZ);
		fdcache(p, size);
	}

	exit((*func)(p, size));
}
@


1.15
log
@It's been a quarter century: we can assume volatile is present with that name.
@
text
@d1 1
a1 1
/*	$OpenBSD: noexec.c,v 1.14 2014/01/10 13:45:00 jsing Exp $	*/
d138 2
d247 1
a247 1
				    PROT_READ|PROT_WRITE|PROT_EXEC,
@


1.14
log
@Do not include MD assembly code in a sys regress test. Untested on alpha,
however it has a much better chance of compiling than it did previously.
@
text
@d1 1
a1 1
/*	$OpenBSD: noexec.c,v 1.13 2013/07/30 15:46:32 kettenis Exp $	*/
d58 1
a58 1
	__asm __volatile(	/* XXX this hardcodes the TESTSZ */
d74 1
a74 1
	  __asm __volatile("flush %0" : : "r" (s + i) : "memory");
@


1.13
log
@better
@
text
@d1 1
a1 1
/*	$OpenBSD: noexec.c,v 1.12 2013/07/30 11:15:33 kettenis Exp $	*/
a281 2

__asm (".space 8192; .globl  testfly; .type   testfly, @@function; testfly: ret; nop; .space 8192");
@


1.12
log
@Make this test actually work on sparc64:
 - Fill delay slot of "ret" pseudo-instruction.
 - Properly synchronize instruction cache using the iflush instruction.
@
text
@d1 1
a1 1
/*	$OpenBSD: noexec.c,v 1.11 2010/06/27 17:42:23 art Exp $	*/
d70 5
a74 1
	__asm __volatile("iflush %0" : : "r" (p));
@


1.11
log
@GCC is being intelligent with our asm statements that were used to pad stuff
before and after a function. We made the assumption that the function would
not be rearranged but would stay between our paddings. Haha, trusting
gcc to not rearrange things, we've never had problems with that.
@
text
@d1 1
a1 1
/*	$OpenBSD: noexec.c,v 1.10 2007/12/27 17:56:44 deraadt Exp $	*/
d69 3
d279 1
a279 1
__asm (".space 8192; .globl  testfly; .type   testfly, @@function; testfly: ret ;.space 8192");
@


1.10
log
@-s uses optarg; Elad Efrat
@
text
@d1 1
a1 1
/*	$OpenBSD: noexec.c,v 1.9 2004/02/23 08:21:53 mickey Exp $	*/
d276 1
a276 8
__asm (".space 8192");

void
testfly(void)
{
}

__asm (".space 8192");
@


1.9
log
@disable buffering on stdout/stderr to avoid freaky sbrk() messages
@
text
@d1 1
a1 1
/*	$OpenBSD: noexec.c,v 1.8 2003/09/25 23:35:06 mickey Exp $	*/
d188 1
a188 1
	while ((ch = getopt(argc, argv, "TDBHSmps")) != -1) {
@


1.8
log
@make sure to not overflow the label; from Charles Blundell <cb@@netbsd.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: noexec.c,v 1.7 2003/07/31 21:48:09 deraadt Exp $	*/
d181 3
@


1.7
log
@various cleanups; david says results are same
@
text
@d1 1
a1 1
/*	$OpenBSD: noexec.c,v 1.6 2003/05/05 15:34:46 mickey Exp $	*/
d185 40
a224 1
	while ((ch = getopt(argc, argv, "TDBHSmps")) != -1)
a225 35
		case 'T':
			p = &testfly;
			strcat(label, "text");
			break;
		case 'D':
			p = &data[(PAD + page_size) / 8];
			p = (void *)((long)p & ~(page_size - 1));
			strcat(label, "data");
			break;
		case 'B':
			p = &bss[(PAD + page_size) / 8];
			p = (void *)((long)p & ~(page_size - 1));
			strcat(label, "bss");
			break;
		case 'H':
			p = malloc(size + 2 * page_size);
			if (p == NULL)
				err(2, "malloc");
			p += page_size;
			p = (void *)((long)p & ~(page_size - 1));
			strcat(label, "heap");
			break;
		case 'S':
			p = getaddr(&stack);
			strcat(label, "stack");
			break;
		case 's':	/* only valid for heap and size */
			size = strtoul(optarg, &ep, 0);
			if (size > ULONG_MAX)
				errno = ERANGE;
			if (errno)
				err(1, "invalid size: %s", optarg);
			if (*ep)
				errx(1, "invalid size: %s", optarg);
			break;
d232 1
a232 1
				strcat(label, "-mmap");
d239 1
a239 1
				strcat(label, "mmap");
d245 1
a245 1
			strcat(label, "-mprotect");
d250 1
@


1.6
log
@page-align for fixed mmap to work
@
text
@d1 1
a1 1
/*	$OpenBSD: noexec.c,v 1.5 2003/05/03 00:08:58 mickey Exp $	*/
d52 1
a52 1
void testfly();
d54 1
a54 1
void
d71 1
a71 1
void
d77 1
a77 1
int
d88 1
a88 1
int
d111 1
a111 1
void *
d124 1
a124 1
int
d159 1
a159 1
void
d271 1
a271 1
testfly()
@


1.5
log
@implement and enable a mmaping pages test (mmap over .data etc,
as it was suggested by art@@ some time ago).
implement noexec test for mmap()ed memory and enable it.
add more padding on the data allocated to prevent changing
protection on unrelated data and such.
implement cache flushing (for hppa now).
be careful w/ data allocations sizes and such.
some other cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: noexec.c,v 1.4 2003/04/23 21:46:04 mickey Exp $	*/
d47 1
d49 2
a50 2
u_int64_t data[(PAD + TESTSZ + PAD) / 8] = { 0 };
u_int64_t bss[(PAD + TESTSZ + PAD) / 8];
d192 2
a193 1
			p = &data[PAD/8];
d197 2
a198 1
			p = &bss[PAD/8];
d206 1
a206 1
			p = (void *)ALIGN((long)p);
d226 1
a226 1
				    MAP_ANON, -1, 0)) == MAP_FAILED)
@


1.4
log
@implement mmap tests and enable the .text test (with padding now)
@
text
@d1 1
a1 1
/*	$OpenBSD: noexec.c,v 1.3 2003/01/05 22:41:36 deraadt Exp $	*/
d31 1
a31 1
#include <sys/types.h>
d47 3
a49 3
#define TEST 256	/* assuming the testfly() will fit */
u_int64_t data[PAD+TEST] = { 0 };
u_int64_t bss[PAD+TEST];
d54 17
d81 1
d93 1
a93 1
	if (mprotect(p, size, PROT_READ|PROT_WRITE|PROT_EXEC) < 0)
d96 1
d101 1
a101 1
	if (mprotect(p, size, PROT_READ|PROT_WRITE) < 0)
d104 1
d128 2
a129 1
	/* XXX must flush cache */
d135 1
d144 1
d152 1
d170 1
a170 1
	u_int64_t stack[256];	/* assuming the testfly() will fit */
d175 1
a175 1
	void *p;
d183 1
a183 1
	size = TEST;
d191 1
a191 1
			p = &data[PAD];
d195 1
a195 1
			p = &bss[PAD];
d199 1
a199 1
			p = malloc(TEST);	/* XXX align? */
d202 2
d207 1
a207 1
			p = &stack;
d210 1
a210 1
		case 's':	/* only valid for stack */
d220 15
a234 6
			func = &noexec_mmap;
			strcat(label, "mmap");
			if ((p = mmap(NULL, 3 * page_size,
			    PROT_READ|PROT_WRITE|PROT_EXEC,
			    MAP_ANON, -1, 0)) == MAP_FAILED)
				err(1, "mmap");
d257 4
a260 2
	if (p != &testfly)
		memcpy(p, &testfly, TEST);
@


1.3
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: noexec.c,v 1.2 2002/09/03 15:29:33 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2002 Michael Shalayeff
d51 1
a51 4
void
testfly()
{
}
a61 1

d75 2
a76 1
	mprotect(p, size, PROT_READ|PROT_WRITE|PROT_EXEC);
d82 2
a83 1
	mprotect(p, size, PROT_READ|PROT_WRITE);
d106 3
a108 1
	void *addr;
a111 5
	if ((addr = mmap(p, size, PROT_READ|PROT_WRITE|PROT_EXEC,
	    MAP_ANON|MAP_FIXED, -1, 0)) == MAP_FAILED)
		err(1, "mmap");
	printf("%s: execute\n", label);
	((void (*)(void))addr)();
d113 19
a131 1
	exit(0);
d195 5
a199 1
			strcat(label, "-mmap");
d222 2
a223 1
	memcpy(p, &testfly, TEST);
d227 9
@


1.2
log
@suffix the tests to see what is happenning indeed
@
text
@d1 1
a1 1
/*	$OpenBSD: noexec.c,v 1.1 2002/08/31 22:56:01 mickey Exp $	*/
d83 1
a83 1
	/* here we are successfull on segv and fail if it still executes */
@


1.1
log
@a combined non-exec test set.
allows reusing same testing code for:
- text & mprotect (not finished, not enabled);
- data, data & mprotect;
- bss, bss & mprotect;
- heap, heap & mprotect;
- stack, stack & mprotect.
also a test for mmaping pages in those areas
and see how it allows execution (suggested by art@@),
not enabled yet.
all tested on i386 and hppa.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d182 1
d186 1
@

