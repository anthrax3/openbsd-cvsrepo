head	1.11;
access;
symbols;
locks; strict;
comment	@ * @;


1.11
date	2015.10.09.06.44.14;	author semarie;	state dead;
branches;
next	1.10;
commitid	OMHrQoEqoUBdOfmt;

1.10
date	2015.10.06.15.45.31;	author semarie;	state Exp;
branches;
next	1.9;
commitid	kygDv7OutdysOJJQ;

1.9
date	2015.10.06.15.24.54;	author semarie;	state Exp;
branches;
next	1.8;
commitid	HTnJdT3baTvUm83F;

1.8
date	2015.09.30.11.36.07;	author semarie;	state Exp;
branches;
next	1.7;
commitid	TMIPnGR2J26p7mlU;

1.7
date	2015.09.28.15.40.18;	author semarie;	state Exp;
branches;
next	1.6;
commitid	r1EbZLbyjDs5Df4X;

1.6
date	2015.09.27.17.55.39;	author semarie;	state Exp;
branches;
next	1.5;
commitid	4qvYBxoHcISbHhT5;

1.5
date	2015.09.24.06.52.22;	author semarie;	state Exp;
branches;
next	1.4;
commitid	TUvbBaBL9IIGZInz;

1.4
date	2015.09.24.06.25.54;	author semarie;	state Exp;
branches;
next	1.3;
commitid	zJVLAfTNVIOkVoSl;

1.3
date	2015.09.18.08.34.22;	author semarie;	state Exp;
branches;
next	1.2;
commitid	MibNAjkycKGJvmzU;

1.2
date	2015.09.10.11.18.10;	author semarie;	state Exp;
branches;
next	1.1;
commitid	wGhTUOQVKI9rH3bX;

1.1
date	2015.08.24.09.21.10;	author semarie;	state Exp;
branches;
next	;
commitid	PMLVZe5EVtqaJvpn;


desc
@@


1.11
log
@follow tame->pledge in regress
@
text
@/*	$OpenBSD: main.c,v 1.10 2015/10/06 15:45:31 semarie Exp $ */
/*
 * Copyright (c) 2015 Sebastien Marie <semarie@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <signal.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "manager.h"

static void
test_nop()
{
	/* nop */
}

static void
test_inet()
{
	int fd = socket(AF_INET, SOCK_STREAM, 0);
	int saved_errno = errno;
	close(fd);
	errno = saved_errno ? saved_errno : errno;
}

static void
test_kill()
{
	kill(0, SIGINT);
}

static void
test_allowed_syscalls()
{
	clock_getres(CLOCK_MONOTONIC, NULL);
	clock_gettime(CLOCK_MONOTONIC, NULL);
	/* fchdir(); */
	getdtablecount();
	getegid();
	geteuid();
	getgid();
	getgroups(0, NULL);
	getitimer(ITIMER_REAL, NULL);
	getlogin();
	getpgid(0);
	getpgrp();
	getpid();
	getppid();
	/* getresgid(); */
	/* getresuid(); */
	{ struct rlimit rl; getrlimit(RLIMIT_CORE, &rl); }
	getsid(0);
	getthrid();
	{ struct timeval tp; gettimeofday(&tp, NULL); }
	getuid();
	geteuid();
	issetugid();
	/* nanosleep(); */
	/* sigreturn(); */
	umask(0000);
	/* wait4(); */
}


static void
open_close(const char *filename)
{
	int fd;
	int saved_errno;

	errno = 0;
	printf("\n open_close(\"%s\")", filename);
	fd = open(filename, O_RDONLY);
	saved_errno = errno;
	printf(" fd=%d errno=%d", fd, errno);
	if (fd != -1)
		close(fd);
	errno = saved_errno;
}

static void
test_wpaths()
{
	/* absolute file */
	open_close("/etc/passwd");

	/* relative */
	open_close("generic");

	/* relative */
	open_close("../../../../../../../../../../../../../../../etc/passwd");

	/* ENOENT */
	open_close("/nonexistent");

	/* calling exit to flush stdout */
	printf("\n");
	exit(EXIT_SUCCESS);
}

static void
test_tame()
{
	const char *wpaths[] = { "/sbin", NULL };

	if (tame("stdio rpath", wpaths) != 0)
		_exit(errno);
}

static void
do_stat(const char *path)
{
	char resolved[PATH_MAX];
	struct stat sb;

	printf("\n stat(\"%s\"):", path);

	/* call realpath(3) */
	errno = 0;
	if (realpath(path, resolved) != NULL)
		printf(" realpath=\"%s\"", resolved);
	else
		printf(" realpath=failed(%d)", errno);

	/* call stat(2) */
	errno = 0;
	if (stat(path, &sb) == 0)
		printf(" uid=%d gid=%d mode=%04o", sb.st_uid, sb.st_gid,
		    sb.st_mode);
	else
		printf(" errno=%d", errno);
}

static void
test_stat()
{
	/* in whitelisted path */
	do_stat("/usr/share/man/man8/afterboot.8");
	do_stat("/usr/share/man/man8/");
	do_stat("/usr/share/man");

	/* parent of whitelisted path */
	do_stat("/usr/share");
	do_stat("/usr");
	do_stat("/");

	/* outside whitelisted path */
	do_stat("/usr/bin/gzip");

	/* calling exit to flush stdout */
	printf("\n");
	exit(EXIT_SUCCESS);
}

static void
test_mmap()
{
	int fd;
	void * data;

	if ((fd = open("/dev/zero", O_RDONLY, 0)) == -1)
		_exit(errno);

	data = mmap(NULL, 4096, PROT_READ|PROT_WRITE|PROT_EXEC,
	    MAP_FILE|MAP_SHARED, fd, 0);

	if (data == MAP_FAILED)
		_exit(errno);

	munmap(data, 4096);
	close(fd);
}

static void
test_rpath()
{
	int fd;
	char data[512];

	if ((fd = open("/dev/zero", O_RDONLY, 0)) == -1)
		_exit(errno);

	if (read(fd, data, sizeof(data)) == -1)
		_exit(errno);

	close(fd);
}

static void
test_wpath()
{
	int fd;
	char data[] = { 0x01, 0x02, 0x03, 0x04, 0x05 };

	if ((fd = open("/dev/null", O_WRONLY, 0)) == -1)
		_exit(errno);

	if (write(fd, data, sizeof(data)) == -1)
		_exit(errno);

	close(fd);
}

static void
test_cpath()
{
	const char filename[] = "/tmp/generic-test-cpath";

	if (mkdir(filename, S_IRWXU) == -1)
		_exit(errno);

	if (rmdir(filename) == -1)
		_exit(errno);
}

int
main(int argc, char *argv[])
{
	int ret = EXIT_SUCCESS;

	if (argc != 1)
		errx(1, "usage: %s", argv[0]);

	/*
	 * testsuite
	 */

	/* _exit is always allowed, and nothing else under flags=0 */
	start_test(&ret, "", NULL, test_nop);
	start_test(&ret, "", NULL, test_inet);

	/* test coredump */
	start_test(&ret, "abort", NULL, test_inet);

	/* inet under inet is ok */
	start_test(&ret, "inet", NULL, test_inet);

	/* kill under inet is forbidden */
	start_test(&ret, "inet", NULL, test_kill);

	/* kill under proc is allowed */
	start_test(&ret, "proc", NULL, test_kill);

	/* tests TAME_SELF for permitted syscalls */
	start_test(&ret, "malloc",  NULL, test_allowed_syscalls);
	start_test(&ret, "rw",      NULL, test_allowed_syscalls);
	start_test(&ret, "stdio",   NULL, test_allowed_syscalls);
	start_test(&ret, "rpath",   NULL, test_allowed_syscalls);
	start_test(&ret, "wpath",   NULL, test_allowed_syscalls);
	start_test(&ret, "tmppath", NULL, test_allowed_syscalls);
	start_test(&ret, "inet",    NULL, test_allowed_syscalls);
	start_test(&ret, "unix",    NULL, test_allowed_syscalls);
	start_test(&ret, "dns",     NULL, test_allowed_syscalls);
	start_test(&ret, "getpw",   NULL, test_allowed_syscalls);

	/* tests req without TAME_SELF for "permitted syscalls" */
	// XXX it is a documentation bug
	start_test(&ret, "cmsg",  NULL, test_allowed_syscalls);
	start_test(&ret, "ioctl", NULL, test_allowed_syscalls);
	start_test(&ret, "proc",  NULL, test_allowed_syscalls);
	start_test(&ret, "cpath", NULL, test_allowed_syscalls);
	start_test(&ret, "abort", NULL, test_allowed_syscalls);
	start_test(&ret, "fattr", NULL, test_allowed_syscalls);

	start_test(&ret, "rpath", NULL, test_rpath);
	start_test(&ret, "wpath", NULL, test_wpath);
	start_test(&ret, "cpath", NULL, test_cpath);

	/*
	 * test whitelist path
	 */
	start_test(&ret, "stdio rpath", NULL, test_wpaths);
	start_test1(&ret, "stdio rpath", NULL, test_wpaths);
	start_test1(&ret, "stdio rpath", "/", test_wpaths);
	start_test1(&ret, "stdio rpath", "/etc", test_wpaths);
	start_test1(&ret, "stdio rpath", "/etc/", test_wpaths);
	start_test1(&ret, "stdio rpath", "/etc/passwd", test_wpaths);
	// XXX start_test1(&ret, "stdio rpath", "/etc/passwd/", test_wpaths);
	start_test1(&ret, "stdio rpath", "/bin", test_wpaths);
	start_test1(&ret, "stdio rpath", "generic", test_wpaths);
	start_test1(&ret, "stdio rpath", "", test_wpaths);
	start_test1(&ret, "stdio rpath", ".", test_wpaths);

	/*
	 * test tame(2) arguments
	 */
	/* same request */
	start_test(&ret, "stdio rpath", NULL, test_tame);
	/* same request (stdio = malloc rw) */
	start_test(&ret, "malloc rw rpath", NULL, test_tame);
	/* reduce request */
	start_test(&ret, "stdio rpath wpath", NULL, test_tame);
	/* reduce request (with same/other wpaths) */
	start_test1(&ret, "stdio rpath wpath", "/sbin", test_tame);
	start_test1(&ret, "stdio rpath wpath", "/", test_tame);
	/* add request */
	start_test(&ret, "stdio", NULL, test_tame);
	/* change request */
	start_test(&ret, "unix", NULL, test_tame);

	/* test stat(2) */
	start_test1(&ret, "stdio rpath", "/usr/share/man", test_stat);

	/* mmap */
	start_test1(&ret, "rpath malloc prot_exec", "/dev/zero", test_mmap);
	start_test1(&ret, "rpath malloc", "/dev/zero", test_mmap);

	return (ret);
}
@


1.10
log
@update "cmsg" tests: it lost TAME_SELF flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 2015/10/06 15:24:54 semarie Exp $ */
@


1.9
log
@add some tests for rpath, wpath, cpath
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 2015/09/30 11:36:07 semarie Exp $ */
a281 1
	start_test(&ret, "cmsg",    NULL, test_allowed_syscalls);
d287 1
d328 1
a328 1
	start_test(&ret, "cmsg", NULL, test_tame);
@


1.8
log
@implement new "prot_exec" tame(2) request:
- by default, a tamed-program don't have the possibility to use PROT_EXEC for
  mmap(2) or mprotect(2)
- for that, use the request "prot_exec" (that could be dropped later)

initial idea from deraadt@@ and kettenis@@

"make complete sense" beck@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 2015/09/28 15:40:18 semarie Exp $ */
d203 42
d293 4
@


1.7
log
@make using tame path "/" work.
and add a regress test for that.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 2015/09/27 17:55:39 semarie Exp $ */
d18 1
d184 19
d286 4
@


1.6
log
@add a tame(2) regress for stat(2) and realpath(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 2015/09/24 06:52:22 semarie Exp $ */
d237 1
a237 1
	// XXX start_test1(&ret, "stdio rpath", "/", test_wpaths);
@


1.5
log
@tame("xxx", NULL) and tame("xxx", {NULL}) are not the same
- change output of regress to reflect that
- add test
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 2015/09/24 06:25:54 semarie Exp $ */
d28 1
d138 45
d263 3
@


1.4
log
@refactor a bit regress tame
- unit tests are functions in main.c
- use test name in output
- add grabbing stdout output of tests
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.2 2015/09/10 11:18:10 semarie Exp $ */
d190 1
@


1.3
log
@remove check for LD_BIND_NOW as kbind(2) is available on almost (all ?) arch
where LD_BIND_NOW was in use.
@
text
@d18 7
d26 4
d31 21
d53 5
a57 1
#include "actions.h"
d59 31
a89 1
void start_test(int *ret, int ntest, const char *req, const char *paths[], ...);
a90 5
#define start_test1(ret,ntest,req,path,...) \
    do { \
	    const char *_paths[] = {path, NULL}; \
	    start_test(ret,ntest,req,_paths,__VA_ARGS__); \
    } while (0)
d92 44
d150 2
a151 2
	start_test(&ret, 1, "", NULL, AC_EXIT);
	start_test(&ret, 2, "", NULL, AC_INET, AC_EXIT);
d154 1
a154 1
	start_test(&ret, 3, "abort", NULL, AC_INET, AC_EXIT);
d157 1
a157 1
	start_test(&ret, 4, "inet", NULL, AC_INET, AC_EXIT);
d160 1
a160 1
	start_test(&ret, 5, "inet", NULL, AC_KILL, AC_EXIT);
d163 1
a163 1
	start_test(&ret, 6, "proc", NULL, AC_KILL, AC_EXIT);
d165 12
a176 3
	/* tests several permitted syscalls */
	start_test(&ret, 7, "dns",  NULL, AC_ALLOWED_SYSCALLS, AC_EXIT);
	start_test(&ret, 8, "inet", NULL, AC_ALLOWED_SYSCALLS, AC_EXIT);
d178 1
a178 1
	/* these TAME_* don't have "permitted syscalls" */
d180 5
a184 1
	start_test(&ret, 9, "proc", NULL, AC_ALLOWED_SYSCALLS, AC_EXIT);
d187 1
a187 1
	 * test absolute whitelist path
d189 10
a198 20
	/* without wpaths */
	start_test(&ret, 10, "rpath", NULL,
	    AC_OPENFILE_RDONLY, "/etc/passwd",
	    AC_EXIT);
	/* exact match */
	start_test1(&ret, 11, "rpath", "/etc/passwd",
	    AC_OPENFILE_RDONLY, "/etc/passwd",
	    AC_EXIT);
	/* subdir match */
	start_test1(&ret, 12, "rpath", "/etc/",
	    AC_OPENFILE_RDONLY, "/etc/passwd",
	    AC_EXIT);
	/* same without trailing '/' */
	start_test1(&ret, 13, "rpath", "/etc",
	    AC_OPENFILE_RDONLY, "/etc/passwd",
	    AC_EXIT);
	/* failing one */
	start_test1(&ret, 14, "rpath", "/bin",
	    AC_OPENFILE_RDONLY, "/etc/passwd",
	    AC_EXIT);
d201 1
a201 1
	 * test relative whitelist path
d203 13
a215 35
	/* without wpaths */
	start_test(&ret, 15, "rpath", NULL,
	    AC_OPENFILE_RDONLY, "generic",
	    AC_EXIT);
	/* exact match */
	start_test1(&ret, 16, "rpath", "generic",
	    AC_OPENFILE_RDONLY, "generic",
	    AC_EXIT);
	/* subdir match */
	start_test1(&ret, 17, "rpath", "./",
	    AC_OPENFILE_RDONLY, "generic",
	    AC_EXIT);
	/* same without trailing '/' */
	start_test1(&ret, 18, "rpath", ".",
	    AC_OPENFILE_RDONLY, "generic",
	    AC_EXIT);
	/* failing one */
	start_test1(&ret, 19, "rpath", ".",
	    AC_OPENFILE_RDONLY, "../../../../../../../../../../../../../../../etc/passwd",
	    AC_EXIT);

	/* tame: test reducing flags */
	start_test1(&ret, 20, "rpath wpath", NULL,
	    AC_TAME, "rpath",
	    AC_EXIT);

	/* tame: test adding flags */
	start_test1(&ret, 21, "rpath", NULL,
	    AC_TAME, "rpath wpath",
	    AC_EXIT);

	/* tame: test replacing flags */
	start_test1(&ret, 22, "rpath", NULL,
	    AC_TAME, "wpath",
	    AC_EXIT);
@


1.2
log
@convert tame(2) regress to new API
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.1 2015/08/24 09:21:10 semarie Exp $ */
a38 4

	/* check for env */
	if (getenv("LD_BIND_NOW") == NULL)
		warnx("depending of your arch, LD_BIND_NOW=1 in env may be needed");
@


1.1
log
@add new (extensible) testsuite for tame(2)
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a17 2
#include <sys/tame.h>

d23 1
a23 1
void start_test(int *ret, int ntest, int flags, const char *paths[], ...);
d25 1
a25 1
#define start_test1(ret,ntest,flags,path,...) \
d28 1
a28 1
	    start_test(ret,ntest,flags,_paths,__VA_ARGS__); \
d42 1
a42 1
		errx(1, "should use LD_BIND_NOW=1 in env");
d49 2
a50 2
	start_test(&ret, 1, 0, NULL, AC_EXIT);
	start_test(&ret, 2, 0, NULL, AC_INET, AC_EXIT);
d53 1
a53 1
	start_test(&ret, 3, TAME_ABORT, NULL, AC_INET, AC_EXIT);
d56 1
a56 1
	start_test(&ret, 4, TAME_INET, NULL, AC_INET, AC_EXIT);
d59 1
a59 1
	start_test(&ret, 5, TAME_INET, NULL, AC_KILL, AC_EXIT);
d62 1
a62 1
	start_test(&ret, 6, TAME_PROC, NULL, AC_KILL, AC_EXIT);
d65 2
a66 2
	start_test(&ret, 7, TAME_DNS,  NULL, AC_ALLOWED_SYSCALLS, AC_EXIT);
	start_test(&ret, 8, TAME_INET, NULL, AC_ALLOWED_SYSCALLS, AC_EXIT);
d70 1
a70 1
	start_test(&ret, 9, TAME_PROC, NULL, AC_ALLOWED_SYSCALLS, AC_EXIT);
d76 1
a76 1
	start_test(&ret, 10, TAME_RPATH, NULL,
d80 1
a80 1
	start_test1(&ret, 11, TAME_RPATH, "/etc/passwd",
d84 1
a84 1
	start_test1(&ret, 12, TAME_RPATH, "/etc/",
d88 1
a88 1
	start_test1(&ret, 13, TAME_RPATH, "/etc",
d92 1
a92 1
	start_test1(&ret, 14, TAME_RPATH, "/bin",
d100 1
a100 1
	start_test(&ret, 15, TAME_RPATH, NULL,
d104 1
a104 1
	start_test1(&ret, 16, TAME_RPATH, "generic",
d108 1
a108 1
	start_test1(&ret, 17, TAME_RPATH, "./",
d112 1
a112 1
	start_test1(&ret, 18, TAME_RPATH, ".",
d116 1
a116 1
	start_test1(&ret, 19, TAME_RPATH, ".",
d121 2
a122 2
	start_test1(&ret, 20, TAME_RPATH | TAME_WPATH, NULL,
	    AC_TAME, TAME_RPATH,
d126 2
a127 2
	start_test1(&ret, 21, TAME_RPATH, NULL,
	    AC_TAME, TAME_RPATH | TAME_WPATH,
d131 2
a132 2
	start_test1(&ret, 22, TAME_RPATH, NULL,
	    AC_TAME, TAME_WPATH,
@

