head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.5.0.54
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.52
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.50
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.48
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.46
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.42
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.40
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.38
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.36
	OPENBSD_5_0:1.5.0.34
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.32
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.30
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4;
locks; strict;
comment	@ * @;


1.6
date	2017.03.08.19.28.47;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	m15f2dxc4qR2El8M;

1.5
date	2003.08.02.01.24.36;	author david;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.17.05.39.49;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.17.05.37.20;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.17.05.33.33;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.16.00.47.55;	author art;	state Exp;
branches;
next	;


desc
@@


1.6
log
@warning cleanups; ok guenther
@
text
@/*	$OpenBSD: nanosleep.c,v 1.5 2003/08/02 01:24:36 david Exp $	*/
/*
 *	Written by Artur Grabowski <art@@openbsd.org> 2002 Public Domain.
 */
#include <sys/types.h>
#include <sys/time.h>
#include <sys/wait.h>

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <time.h>
#include <err.h>
#include <signal.h>

int trivial(void);
int with_signal(void);
int time_elapsed(void);
int time_elapsed_with_signal(void);

int short_time(void);

void sighandler(int);

int
main(int argc, char **argv)
{
	int ch, ret;

	ret = 0;

	while ((ch = getopt(argc, argv, "tseES")) != -1) {
		switch (ch) {
		case 't':
			ret |= trivial();
			break;
		case 's':
			ret |= with_signal();
			break;
		case 'e':
			ret |= time_elapsed();
			break;
		case 'E':
			ret |= time_elapsed_with_signal();
			break;
		case 'S':
			ret |= short_time();
		default:
			fprintf(stderr, "Usage: nanosleep [-tse]\n");
			exit(1);
		}
	}

	return (ret);
}

void
sighandler(int signum)
{
}

int
trivial(void)
{
	struct timespec ts, rts;

	ts.tv_sec = 0;
	ts.tv_nsec = 30000000;
	rts.tv_sec = 4711;	/* Just add to the confusion */
	rts.tv_nsec = 4711;
	if (nanosleep(&ts, &rts) < 0) {
		warn("trivial: nanosleep");
		return 1;
	}

	/*
	 * Just check that we don't get any leftover time if we sleep the
	 * amount of time we want to sleep.
	 * If we receive any signal, something is wrong anyway.
	 */
	if (rts.tv_sec != 0 || rts.tv_nsec != 0) {
		warnx("trivial: non-zero time? %lld/%ld", (long long)rts.tv_sec,
		    rts.tv_nsec);
		return 1;
	}

	return 0;
}

int
with_signal(void)
{
	struct timespec ts, rts;
	pid_t pid;
	int status;

	signal(SIGUSR1, sighandler);

	pid = getpid();

	switch(fork()) {
	case -1:
		err(1, "fork");
	default:
		ts.tv_sec = 1;
		ts.tv_nsec = 0;
		nanosleep(&ts, NULL);
		kill(pid, SIGUSR1);
		exit(0);
	}

	ts.tv_sec = 10;
	ts.tv_nsec = 0;
	rts.tv_sec = 0;
	rts.tv_nsec = 0;
	if (nanosleep(&ts, &rts) == 0) {
		warnx("with-signal: nanosleep");
		return 1;
	}
	if (rts.tv_sec == 0 && rts.tv_nsec == 0) {
		warnx("with-signal: zero time");
		return 1;
	}

	if (wait(&status) < 0)
		err(1, "wait");

	return 0;
}

int
time_elapsed(void)
{
	struct timespec ts;
	struct timeval stv, etv;

	ts.tv_sec = 0;
	ts.tv_nsec = 500000000;

	if (gettimeofday(&stv, NULL) < 0) {
		warn("gettimeofday");
		return 1;
	}

	if (nanosleep(&ts, NULL) < 0) {
		warn("nanosleep");
		return 1;
	}

	if (gettimeofday(&etv, NULL) < 0) {
		warn("gettimeofday");
		return 1;
	}

	timersub(&etv, &stv, &stv);

	if (stv.tv_sec == 0 && stv.tv_usec < 500000) {
		warnx("slept less than 0.5 sec");
		return 1;
	}

	return 0;
}

int
time_elapsed_with_signal(void)
{
	struct timespec ts, rts;
	struct timeval stv, etv;
	pid_t pid;
	int status;

	signal(SIGUSR1, sighandler);

	pid = getpid();

	switch(fork()) {
	case -1:
		err(1, "fork");
	default:
		ts.tv_sec = 1;
		ts.tv_nsec = 0;
		nanosleep(&ts, NULL);
		kill(pid, SIGUSR1);
		exit(0);
	}

	ts.tv_sec = 10;
	ts.tv_nsec = 0;
	rts.tv_sec = 0;
	rts.tv_nsec = 0;

	if (gettimeofday(&stv, NULL) < 0) {
		warn("gettimeofday");
		return 1;
	}

	if (nanosleep(&ts, &rts) == 0) {
		warnx("nanosleep");
		return 1;
	}

	if (gettimeofday(&etv, NULL) < 0) {
		warn("gettimeofday");
		return 1;
	}

	timersub(&etv, &stv, &stv);

	etv.tv_sec = rts.tv_sec;
	etv.tv_usec = rts.tv_nsec / 1000 + 1; /* the '+ 1' is a "roundup" */

	timeradd(&etv, &stv, &stv);

	if (stv.tv_sec < 10) {
		warnx("slept time + leftover time < 10 sec");
		return 1;
	}


	if (wait(&status) < 0)
		err(1, "wait");

	return 0;
}

int
short_time(void)
{
	struct timespec ts, rts;
	pid_t pid;
	int status;

	signal(SIGUSR1, sighandler);

	pid = getpid();

	switch(fork()) {
	case -1:
		err(1, "fork");
	default:
		/* Sleep two seconds, then shoot parent. */
		ts.tv_sec = 2;
		ts.tv_nsec = 0;
		nanosleep(&ts, NULL);
		kill(pid, SIGUSR1);
		exit(0);
	}

	ts.tv_sec = 0;
	ts.tv_nsec = 1;
	if (nanosleep(&ts, NULL) <= 0) {
		warn("short_time: nanosleep");
		return 1;
	}

	if (wait(&status) < 0)
		err(1, "wait");

	return 0;
}
@


1.5
log
@add missing includes
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nanosleep.c,v 1.4 2002/02/17 05:39:49 art Exp $	*/
d82 1
a82 1
		warnx("trivial: non-zero time? %d/%d", rts.tv_sec,
@


1.4
log
@time_elapsed_with_signal was completly wrong, fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: nanosleep.c,v 1.3 2002/02/17 05:37:20 art Exp $	*/
d7 1
@


1.3
log
@Don't warn when we don't have an errno, warnx.
@
text
@d1 1
a1 1
/*	$OpenBSD: nanosleep.c,v 1.2 2002/02/17 05:33:33 art Exp $	*/
d214 2
a215 2
	if (stv.tv_sec == 0 && stv.tv_usec < 500000) {
		warnx("slept less than 0.5 sec");
@


1.2
log
@Add a test for nansleep with a very short time (less than a tick).
@
text
@d1 1
a1 1
/*	$OpenBSD: nanosleep.c,v 1.1 2002/02/16 00:47:55 art Exp $	*/
d116 1
a116 1
		warn("with-signal: nanosleep");
d198 1
a198 1
		warn("nanosleep");
@


1.1
log
@Test nanosleep(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: exit.c,v 1.1 2002/02/08 20:15:14 art Exp $	*/
d20 2
d31 1
a31 1
	while ((ch = getopt(argc, argv, "tseE")) != -1) {
d45 2
d219 36
@

