head	1.3;
access;
symbols
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.54
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.44
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.52
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.50
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.48
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.46
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.42
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.40
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.38
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.36
	OPENBSD_5_0:1.3.0.34
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.32
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.30
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.26
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.28
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.24
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.22
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.20
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.18
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.16
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.14
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.3
date	2003.07.31.21.48.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.18.13.32.08;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.08.18.47.46;	author art;	state Exp;
branches;
next	;


desc
@@


1.3
log
@various cleanups; david says results are same
@
text
@/*	$OpenBSD: dup2_self.c,v 1.2 2002/02/18 13:32:08 art Exp $	*/
/*
 *	Written by Artur Grabowski <art@@openbsd.org> 2002 Public Domain.
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <err.h>
#include <fcntl.h>

/*
 * We're testing a small tweak in dup2 semantics. Normally dup and dup2
 * will clear the close-on-exec flag on the new fd (which appears to be
 * an implementation mistake from start and not some planned behavior).
 * In todays implementations of dup and dup2 we have to make an effort
 * to really clear that flag. But all tested implementations of dup2 have
 * another tweak. If we dup2(old, new) when old == new, the syscall
 * short-circuits and returns early (because there is no need to do all
 * the work (and there is a risk for serious mistakes)). So although the
 * docs say that dup2 should "take 'old', close 'new' perform a dup(2) of
 * 'old' into 'new'" the docs are not really followed because close-on-exec
 * is not cleared on 'new'.
 *
 * Since everyone has this bug, we pretend that this is the way it is
 * supposed to be and test here that it really works that way.
 *
 * This is a fine example on where two separate implementation fuckups
 * take out each other and make the end-result the way it was meant to be.
 */

int
main(int argc, char *argv[])
{
	int orgfd, fd1, fd2;
	char temp[] = "/tmp/dup2XXXXXXXXX";

	if ((orgfd = mkstemp(temp)) < 0)
		err(1, "mkstemp");
	remove(temp);

	if (ftruncate(orgfd, 1024) != 0)
		err(1, "ftruncate");

	if ((fd1 = dup(orgfd)) < 0)
		err(1, "dup");

	/* Set close-on-exec */
	if (fcntl(fd1, F_SETFD, 1) != 0)
		err(1, "fcntl(F_SETFD)");

	if ((fd2 = dup2(fd1, fd1)) < 0)
		err(1, "dup2");

	/* Test 1: Do we get the right fd? */
	if (fd2 != fd1)
		errx(1, "dup2 didn't give us the right fd");

	/* Test 2: Was close-on-exec cleared? */
	if (fcntl(fd2, F_GETFD) == 0)
		errx(1, "dup2 cleared close-on-exec");

	return 0;
}
@


1.2
log
@Document in more detail what's going on here.
@
text
@d1 1
a1 1
/*	$OpenBSD: dup2_self.c,v 1.1 2002/02/08 18:47:46 art Exp $	*/
d32 1
a32 1
main()
@


1.1
log
@Test an obscure case of dup2 behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d10 20
@

