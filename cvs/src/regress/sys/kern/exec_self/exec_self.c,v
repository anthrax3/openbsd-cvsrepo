head	1.2;
access;
symbols
	OPENBSD_6_0:1.2.0.2
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.0.48
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.56
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.54
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.52
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.50
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.46
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.44
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.42
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.40
	OPENBSD_5_0:1.1.0.38
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.36
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.34
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.30
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.32
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.28
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.26
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.24
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.22
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.20
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.18
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.16
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.14
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.12
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.10
	OPENBSD_3_6_BASE:1.1
	OPENBSD_3_5:1.1.0.8
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.6
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.4
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.2
date	2016.03.17.19.40.43;	author krw;	state Exp;
branches;
next	1.1;
commitid	aCmYZrmRmWHLuztW;

1.1
date	2002.08.17.22.58.59;	author art;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Last parameter to execl[e]() functions *must* be cast to a pointer.
Just NULL is not good practise as NULL is theoretically allowed to
be an integer rather than a pointer.

Use (char *)NULL consistently instead of scattering a few (char *)0
and (void *)NULL into the mix.

Prompted by and probably ok deraadt@@ millert@@ kettenis@@

Definitely ok mestre@@ ratchov@@
@
text
@/*	$OpenBSD: exec_self.c,v 1.1 2002/08/17 22:58:59 art Exp $	*/
/*
 *	Written by Artur Grabowski <art@@openbsd.org> 2002 Public Domain.
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <err.h>
#include <sys/types.h>
#include <sys/mman.h>

struct {
	const char pad1[256*1024];	/* avoid read-ahead. */
	const char string[256*1024];	/* at least one page */
	const char pad2[256*1024];	/* avoid read-behind. */
} const blob = {
	"padding1",
	"the_test",
	"padding2"
};

int
main(int argc, char **argv)
{
	int pgsz = getpagesize();
	vaddr_t va, off;

	if (argc > 1) {
		return (0);
	}
	va = (vaddr_t)&blob;
	off = va & (pgsz - 1);

	/* Make sure that nothing in the "blob" is cached. */
	if (madvise((void *)(va - off), sizeof(blob) + (off > 0 ? pgsz : 0),
	    MADV_FREE))
		err(1, "madvise");

	if (execl(argv[0], argv[0], &blob.string, (char *)NULL))
		err(1, "execl");

	/* NOTREACHED */
	return (1);
}
@


1.1
log
@Test for a nasty complication in the exec code.

What happens is that if an executable tries to exec itself (happens all
the time on the ramdisk, among others) and needs to page in a page from
the data segment (or rodata) it will need to perform a pagein operation
on the vnode that's execing right now. exec keeps that vnode locked and
fails (no deadlock, that part was fixed a long time ago).
@
text
@d1 1
a1 1
/*	$OpenBSD: pread.c,v 1.1 2002/02/08 19:05:18 art Exp $	*/
d39 1
a39 1
	if (execl(argv[0], argv[0], &blob.string, NULL))
@

