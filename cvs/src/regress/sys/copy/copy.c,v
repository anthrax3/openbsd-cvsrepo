head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.4
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.4.0.22
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.12
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.20
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.18
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.16
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.14
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.10
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.8
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.10
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.8
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.14
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.12
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.10
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.8
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.6
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.0.2
	OPENBSD_3_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2016.08.19.01.37.50;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	VP1yeayEAQ5Is9TZ;

1.4
date	2011.04.10.03.20.59;	author guenther;	state Exp;
branches;
next	1.3;

1.3
date	2009.02.15.13.33.22;	author jsing;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.17.07.37.10;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.24.06.58.36;	author otto;	state Exp;
branches;
next	;


desc
@@


1.5
log
@string.h not strings.h
@
text
@/*	$OpenBSD: copy.c,v 1.4 2011/04/10 03:20:59 guenther Exp $	*/

/* Written by Ted Unangst 2004 Public Domain */

#include <sys/param.h>
#include <sys/mount.h>
#include <sys/sysctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/syslimits.h>
#include <net/if.h>
#include <string.h>
#include <errno.h>

#include <stdio.h>
#include <err.h>
#include <unistd.h>

int failure;

static void
fail(const char *str)
{
	fprintf(stderr, "%s\n", str);
	failure++;
}

int
main(int argc, char **argv)
{
 	char buf[4096];
	char path[PATH_MAX + 1];
 	void *goodbuf;
 	void *badbuf;
 	int mib[6];
 	struct kinfo_proc kinfo;
 	size_t kinfosize = sizeof(kinfo);
 	int s, i;
 	struct ifreq ifrdesc;


 	s = socket(AF_INET, SOCK_DGRAM, 0);
 	if (s == -1)
 		err(1, "socket");

 	mib[0] = CTL_KERN;
 	mib[1] = KERN_PROC;
 	mib[2] = KERN_PROC_PID;
 	mib[3] = getpid();
 	mib[4] = sizeof(struct kinfo_proc);
 	mib[5] = 1;

 	if (sysctl(mib, 6, &kinfo, &kinfosize, 0, 0))
 		err(1, "sysctl");

	for (i = 0; i < PATH_MAX; i++)
		path[i] = (i % NAME_MAX) ? 'a' : '/';
	path[PATH_MAX] = '\0';

 	goodbuf = buf;
 	badbuf = (void*)(long)kinfo.p_paddr;

 	/* printf("goodbuf %p badbuf %p\n", goodbuf, badbuf); */

 	/* copyin */
 	if (!syscall(202, 0, 6, &kinfo, &kinfosize, 0, 0))
 		fail("copyin did not fail on 0 buf\n");
 	if (!syscall(202, badbuf, 6, &kinfo, &kinfosize, 0, 0))
 		fail("copyin did not fail on bad buf\n");

 	/* copyout */
 	if (statfs("/", goodbuf))
 		fail("copyout failed on a good buf\n");
 	if (!statfs("/", 0) || errno != EFAULT)
 		fail("copyout didn't fail on 0 buf\n");
 	if (!statfs("/", badbuf) || errno != EFAULT)
 		fail("copyout didn't fail on bad buf\n");

 	/* copyoutstr */
 	memset(&ifrdesc, 0, sizeof(ifrdesc));
 	strlcpy(ifrdesc.ifr_name, "lo0", sizeof(ifrdesc.ifr_name));
 	ifrdesc.ifr_data = goodbuf;
 	if (ioctl(s, SIOCGIFDESCR, &ifrdesc))
 		fail("SIOCIFDESCR ioctl failed\n");
 	memset(&ifrdesc, 0, sizeof(ifrdesc));
 	strlcpy(ifrdesc.ifr_name, "lo0", sizeof(ifrdesc.ifr_name));
 	ifrdesc.ifr_data = 0;
 	if (!ioctl(s, SIOCGIFDESCR, &ifrdesc))
 		fail("copyoutstr didn't fail on 0 buf\n");
 	memset(&ifrdesc, 0, sizeof(ifrdesc));
 	strlcpy(ifrdesc.ifr_name, "lo0", sizeof(ifrdesc.ifr_name));
 	ifrdesc.ifr_data = badbuf;
 	if (!ioctl(s, SIOCGIFDESCR, &ifrdesc))
 		fail("copyoutstr didn't fail on badbuf\n");

 	/* copyinstr */
 	if (statfs("/", goodbuf))
 		fail("copyinstr failed on a good buf\n");
 	if (!statfs(0, goodbuf) || errno != EFAULT)
 		fail("copyinstr didn't fail on 0 buf\n");
 	if (!statfs(badbuf, goodbuf) || errno != EFAULT)
 		fail("copyinstr didn't fail on bad buf\n");
	if (!statfs(path, goodbuf) || errno != ENAMETOOLONG)
		fail("copyinstr didn't fail on long string\n");

	if (failure)
		errx(1, "%d failures", failure);
 	return 0;
}
@


1.4
log
@Switch back from KERN_PROC2/kinfo_proc2 to KERN_PROC/kinfo_proc now
that we've got name we want for the API we want

"ZAP!" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.c,v 1.3 2009/02/15 13:33:22 jsing Exp $	*/
d13 1
a13 1
#include <strings.h>
@


1.3
log
@Add an ENAMETOOLONG test case for copyinstr(), inspired by sthen@@'s code.

ok sthen@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.c,v 1.2 2005/04/17 07:37:10 tedu Exp $	*/
d37 1
a37 1
 	struct kinfo_proc2 kinfo;
d48 1
a48 1
 	mib[1] = KERN_PROC2;
d51 1
a51 1
 	mib[4] = sizeof(struct kinfo_proc2);
@


1.2
log
@duh, make sure we're testing what we thing we are.  still not exactly
the best test around.
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.c,v 1.1 2005/02/24 06:58:36 otto Exp $	*/
d11 1
d33 1
d39 1
a39 1
 	int s;
d57 3
d104 2
@


1.1
log
@Add tedu's copy* test, turned into a regress test by me.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d13 1
d70 1
a70 1
 	if (!statfs("/", 0))
d72 1
a72 1
 	if (!statfs("/", badbuf))
d95 1
a95 1
 	if (!statfs(0, goodbuf))
d97 1
a97 1
 	if (!statfs(badbuf, goodbuf))
@

