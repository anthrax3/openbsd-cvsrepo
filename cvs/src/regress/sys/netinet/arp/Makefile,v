head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3
	bluhm_20151105:1.1.1.1
	bluhm:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2016.10.19.14.31.19;	author tb;	state Exp;
branches;
next	1.8;
commitid	r0ZXVh0JShv1yn7K;

1.8
date	2016.09.02.21.30.34;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	sbZCO4zszQKrda5x;

1.7
date	2016.07.18.09.09.24;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	UV0OrP6fDdGqha9j;

1.6
date	2016.03.30.11.09.56;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	lgf5rI6pyyu49Ej6;

1.5
date	2016.03.30.09.06.27;	author mpi;	state Exp;
branches;
next	1.4;
commitid	oFZnKLaK3yltRbqf;

1.4
date	2016.03.24.07.11.45;	author mpi;	state Exp;
branches;
next	1.3;
commitid	D7bJ4Otsu0TbHpY7;

1.3
date	2015.12.04.23.43.04;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	A0RCnJnBH7HFrqRl;

1.2
date	2015.12.04.20.48.24;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	s6YTEeSLMnStAgE8;

1.1
date	2015.11.05.01.49.12;	author bluhm;	state Exp;
branches
	1.1.1.1;
next	;
commitid	wFKigL0B7MsvNV9p;

1.1.1.1
date	2015.11.05.01.49.12;	author bluhm;	state Exp;
branches;
next	;
commitid	wFKigL0B7MsvNV9p;


desc
@@


1.9
log
@The clean:, cleandir:, and obj: targets of src/Makefile descend into
regress/ and run python to set the IMPORT_PYTHON variable in several
test Makefiles. This results in W^X violations during 'make build'.
Avoid doing that.

ok bluhm
@
text
@#	$OpenBSD: Makefile,v 1.8 2016/09/02 21:30:34 bluhm Exp $

# The following ports must be installed:
#
# python-2.7          interpreted object-oriented programming language
# py-libdnet          python interface to libdnet
# scapy               powerful interactive packet manipulation in python

.if ! (make(clean) || make(cleandir) || make(obj))
# Check wether all required python packages are installed.  If some
# are missing print a warning and skip the tests, but do not fail.
PYTHON_IMPORT != python2.7 -c 'from scapy.all import *' 2>&1 || true
.endif
.if ! empty(PYTHON_IMPORT)
regress:
	@@echo '${PYTHON_IMPORT}'
	@@echo install python and the scapy module for additional tests
	@@echo SKIPPED
.endif

# This test needs a manual setup of two machines
# Set up machines: LOCAL REMOTE
# LOCAL is the machine where this makefile is running.
# REMOTE is running OpenBSD with ARP to test the Address Resolution Protocol.
# FAKE is an non existing machine, its IP is used in the tests.
# OTHER is an IP on REMOTE, but configured on another interface.
# OTHERFAKE is an non existing IP on another interface.
# REMOTE_SSH is the hostname to log in on the REMOTE machine.

# Configure Addresses on the machines.
# Adapt interface and addresse variables to your local setup.
#
LOCAL_IF ?=
LOCAL_MAC ?=
REMOTE_MAC ?=
FAKE_MAC ?= 12:34:56:78:9a:bc
PROXY_MAC ?= 00:90:27:bb:cc:dd
REMOTE_SSH ?=

LOCAL_ADDR ?= 10.188.70.17
REMOTE_ADDR ?= 10.188.70.70
FAKE_ADDR ?= 10.188.70.188
OTHER_ADDR ?= 10.188.211.70
OTHERFAKE_ADDR ?= 10.188.211.188

.if empty (LOCAL_IF) || empty (LOCAL_MAC) || empty (REMOTE_MAC) || \
    empty (FAKE_MAC) || empty (REMOTE_SSH) || empty (LOCAL_ADDR) || \
    empty (REMOTE_ADDR) || empty (FAKE_ADDR) || empty (OTHER_ADDR) || \
    empty (OTHERFAKE_ADDR)
regress:
	@@echo this tests needs a remote machine to operate on
	@@echo LOCAL_IF LOCAL_MAC REMOTE_MAC FAKE_MAC REMOTE_SSH LOCAL_ADDR
	@@echo REMOTE_ADDR FAKE_ADDR OTHER_ADDR OTHERFAKE_ADDR are empty
	@@echo fill out these variables for additional tests
	@@echo SKIPPED
.endif

.if ! empty (REMOTE_SSH)
.if make (regress) || make (all)
.BEGIN: pf.conf addr.py
	@@echo
	${SUDO} true
	ssh -t ${REMOTE_SSH} ${SUDO} true
.endif
.endif

depend: addr.py

# Create python include file containing the addresses.
addr.py: Makefile
	rm -f $@@ $@@.tmp
	echo 'LOCAL_IF = "${LOCAL_IF}"' >>$@@.tmp
.for var in LOCAL REMOTE FAKE
	echo '${var}_MAC = "${${var}_MAC}"' >>$@@.tmp
.endfor
.for var in LOCAL REMOTE FAKE OTHER OTHERFAKE
	echo '${var}_ADDR = "${${var}_ADDR}"' >>$@@.tmp
.endfor
	mv $@@.tmp $@@

# Set variables so that make runs with and without obj directory.
# Only do that if necessary to keep visible output short.
.if ${.CURDIR} == ${.OBJDIR}
PYTHON =	python2.7 ./
.else
PYTHON =	PYTHONPATH=${.OBJDIR} python2.7 ${.CURDIR}/
.endif

.PHONY: clean-arp

# Clear local and remote ARP cache.
clean-arp:
	@@echo '\n======== $@@ ========'
	${SUDO} arp -da
	ssh ${REMOTE_SSH} ${SUDO} arp -da

# Clear ARP cache and ping all addresses.  This ensures that
# the IP addresses are configured and all routing table are set up
# to allow bidirectional packet flow.
TARGETS +=	ping
run-regress-ping: clean-arp
	@@echo '\n======== $@@ ========'
.for ip in LOCAL_ADDR REMOTE_ADDR
	@@echo Check ping ${ip}
	ping -n -c 1 ${${ip}}
.endfor

# Send an ARP request from the local machine, asking for the remote
# machine's MAC.  Target MAC is broadcast, Target IP is remote address.
# Check that all fields of the answer are filled out correctly.
# Check that the remote machine has the local IP and MAC in its ARP table.
TARGETS +=	arp-request
run-regress-arp-request: addr.py clean-arp
	@@echo '\n======== $@@ ========'
	@@echo Send ARP Request for remote address and insert local address
	${SUDO} ${PYTHON}arp_request.py
	ssh ${REMOTE_SSH} ${SUDO} arp -an >arp.log
	grep '^${LOCAL_ADDR} .* ${LOCAL_MAC} ' arp.log

# Send an ARP request from the local machine, but use a multicast MAC
# as sender.  Although there is a special check in in_arpinput(),
# this must be answered.  The ARP entry on the remote machine for the
# local address is changed to the multicast MAC.
# Check that all fields of the answer are filled out correctly.
# Check that the remote machine overwrites the local address.
TARGETS +=	arp-multicast
run-regress-arp-multicast: addr.py clean-arp
	@@echo '\n======== $@@ ========'
	@@echo Send ARP Request and overwrite entry with multicast ethernet
	ssh ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
	ssh ${REMOTE_SSH} ${SUDO} arp -s ${LOCAL_ADDR} ${LOCAL_MAC} temp
	scp ${REMOTE_SSH}:/var/log/messages old.log
	${SUDO} ${PYTHON}arp_multicast.py
	scp ${REMOTE_SSH}:/var/log/messages new.log
	ssh ${REMOTE_SSH} ${SUDO} arp -an >arp.log
	ssh ${REMOTE_SSH} ${SUDO} arp -d ${LOCAL_ADDR}
	diff old.log new.log | grep '^> ' >diff.log
	grep 'bsd: arp info overwritten for ${LOCAL_ADDR} by 33:33:33:33:33:33' diff.log
	grep '^${LOCAL_ADDR} .* 33:33:33:33:33:33 ' arp.log

# Send an ARP probe from the local machine with the remote IP as
# target.  Sender MAC is local and IP is 0.  The remote machine must
# defend its IP address with an ARP reply.
# Check that all fields of the answer are filled out correctly.
TARGETS +=	arp-probe
run-regress-arp-probe: addr.py clean-arp
	@@echo '\n======== $@@ ========'
	@@echo Send ARP Probe for existing address and expect correct reply
	${SUDO} ${PYTHON}arp_probe.py

# Send ARP request with broadcast MAC as sender.
# Check that no answer is received.
# Check that the remote machine rejects the broadcast sender.
TARGETS +=	arp-broadcast
run-regress-arp-broadcast: addr.py clean-arp
	@@echo '\n======== $@@ ========'
	@@echo Send ARP Request with broadcast as sender hardware address
	ssh ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
	scp ${REMOTE_SSH}:/var/log/messages old.log
	${SUDO} ${PYTHON}arp_broadcast.py
	scp ${REMOTE_SSH}:/var/log/messages new.log
	diff old.log new.log | grep '^> ' >diff.log
	grep 'bsd: arp: ether address is broadcast for IP address ${LOCAL_ADDR}' diff.log

# The local machine announces that it has taken the remote machine's
# IP.  The sender is the local machines MAC and the remote IP.  The
# remote machine must defend its IP address with an ARP reply.
# Check that all fields of the answer are filled out correctly.
# Check that the remote machine reports an duplicate address.
# Check that the remote machine keeps its local ARP entry.
TARGETS +=	arp-announcement
run-regress-arp-announcement: addr.py clean-arp
	@@echo '\n======== $@@ ========'
	@@echo Send ARP Announcement for existing address
	ssh ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
	scp ${REMOTE_SSH}:/var/log/messages old.log
	${SUDO} ${PYTHON}arp_announcement.py
	scp ${REMOTE_SSH}:/var/log/messages new.log
	ssh ${REMOTE_SSH} ${SUDO} arp -an >arp.log
	diff old.log new.log | grep '^> ' >diff.log
	grep 'bsd: duplicate IP address ${REMOTE_ADDR} sent from ethernet address ${LOCAL_MAC}' diff.log
	grep '^${REMOTE_ADDR} .* ${REMOTE_MAC} .* permanent * l$$' arp.log

# The local machine sends an gratuitous ARP reply for the remote IP
# with its local MAC.
# Check that no answer is received.
# Check that the remote machine reports an duplicate address.
# Check that the remote machine keeps its local ARP entry.
TARGETS +=	arp-gratuitous
run-regress-arp-gratuitous: addr.py clean-arp
	@@echo '\n======== $@@ ========'
	@@echo Send Gratuitous ARP for existing address
	ssh ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
	scp ${REMOTE_SSH}:/var/log/messages old.log
	${SUDO} ${PYTHON}arp_gratuitous.py
	scp ${REMOTE_SSH}:/var/log/messages new.log
	ssh ${REMOTE_SSH} ${SUDO} arp -an >arp.log
	diff old.log new.log | grep '^> ' >diff.log
	grep 'bsd: duplicate IP address ${REMOTE_ADDR} sent from ethernet address ${LOCAL_MAC}' diff.log
	grep '^${REMOTE_ADDR} .* ${REMOTE_MAC} .* permanent * l$$' arp.log

# Add a permanent entry on the remote machine for a fake MAC and IP.
# Send a request form the local machine, indicating with the local
# MAC and the fake IP as sender that it claims the fake address.
# Check that no answer is received.
# Check that the attempt to overwrite the permanent entry is logged.
# Check that the remote machine keeps its permanent ARP entry.
TARGETS +=	arp-permanent
run-regress-arp-permanent: addr.py clean-arp
	@@echo '\n======== $@@ ========'
	@@echo Send ARP Request to change permanent fake address
	ssh ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
	ssh ${REMOTE_SSH} ${SUDO} arp -s ${FAKE_ADDR} ${FAKE_MAC} permanent
	scp ${REMOTE_SSH}:/var/log/messages old.log
	${SUDO} ${PYTHON}arp_fake.py
	scp ${REMOTE_SSH}:/var/log/messages new.log
	ssh ${REMOTE_SSH} ${SUDO} arp -an >arp.log
	ssh ${REMOTE_SSH} ${SUDO} arp -d ${FAKE_ADDR}
	diff old.log new.log | grep '^> ' >diff.log
	grep 'bsd: arp: attempt to overwrite permanent entry for ${FAKE_ADDR} by ${LOCAL_MAC}' diff.log
	grep '^${FAKE_ADDR} .* ${FAKE_MAC} .* permanent * $$' arp.log

# The remote machine has a second address on another interface.
# The local machine claims this address in its sender IP.
# Check that no answer is received.
# Check that the attempt to overwrite the permanent entry is logged.
# Check that the remote machine keeps its local ARP entry.
TARGETS +=	arp-address
run-regress-arp-address: addr.py clean-arp
	@@echo '\n======== $@@ ========'
	@@echo Send ARP Request to change address on other interface
	ssh ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
	scp ${REMOTE_SSH}:/var/log/messages old.log
	${SUDO} ${PYTHON}arp_other.py
	scp ${REMOTE_SSH}:/var/log/messages new.log
	ssh ${REMOTE_SSH} ${SUDO} arp -an >arp.log
	diff old.log new.log | grep '^> ' >diff.log
	grep 'bsd: arp: attempt to overwrite permanent entry for ${OTHER_ADDR} by ${LOCAL_MAC}' diff.log
	grep '^${OTHER_ADDR} .* permanent * l$$' arp.log

# The remote machine has a second address on another interface.  Add
# a temporary ARP entry for a fake address in this network on the
# remote machine.  The local machine tries to overwrite this address
# with its own MAC.
# Check that no answer is received.
# Check that the attempt to overwrite the permanent entry is logged.
# Check that the remote machine keeps its ARP entry.
TARGETS +=	arp-temporary
run-regress-arp-temporary: addr.py clean-arp
	@@echo '\n======== $@@ ========'
	@@echo Send ARP Request to change temporary entry on other interface
	ssh ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
	ssh ${REMOTE_SSH} ${SUDO} arp -s ${OTHERFAKE_ADDR} ${FAKE_MAC} temp
	scp ${REMOTE_SSH}:/var/log/messages old.log
	${SUDO} ${PYTHON}arp_otherfake.py
	scp ${REMOTE_SSH}:/var/log/messages new.log
	ssh ${REMOTE_SSH} ${SUDO} arp -an >arp.log
	ssh ${REMOTE_SSH} ${SUDO} arp -d ${OTHERFAKE_ADDR}
	diff old.log new.log | grep '^> ' >diff.log
	grep 'bsd: arp: attempt to overwrite entry for ${OTHERFAKE_ADDR} on .* by ${LOCAL_MAC} on .*' diff.log
	grep '^${OTHERFAKE_ADDR} .* ${FAKE_MAC} ' arp.log

# The remote machine has a second address on another interface.  Create
# an incomplete ARP entry for a fake address in this network on the
# remote machine with an unsuccessful ping.  The local machine tries
# to overwrite this address with its own MAC.
# Check that no answer is received.
# Check that the attempt to add an entry is logged.
# Check that the remote machine keeps its incomplete ARP entry.
TARGETS +=	arp-incomplete
run-regress-arp-incomplete: addr.py clean-arp
	@@echo '\n======== $@@ ========'
	@@echo Send ARP Request filling an incomplete entry on other interface
	ssh ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
	ssh ${REMOTE_SSH} ${SUDO} ping -n -w 1 -c 1 ${OTHERFAKE_ADDR} || true
	scp ${REMOTE_SSH}:/var/log/messages old.log
	${SUDO} ${PYTHON}arp_otherfake.py
	scp ${REMOTE_SSH}:/var/log/messages new.log
	ssh ${REMOTE_SSH} ${SUDO} arp -an >arp.log
	ssh ${REMOTE_SSH} ${SUDO} arp -d ${OTHERFAKE_ADDR}
	diff old.log new.log | grep '^> ' >diff.log
	grep 'bsd: arp: attempt to add entry for ${OTHERFAKE_ADDR} on .* by ${LOCAL_MAC} on .*' diff.log
	grep '^${OTHERFAKE_ADDR} .* (incomplete) ' arp.log

# Publish a proxy ARP entry on the remote machine for a fake address.
# The local machine requests this IP as a the target.
# Check that all fields of the answer are filled out correctly.
# Check that the remote machine has a public ARP entry.
TARGETS +=	arp-proxy
run-regress-arp-proxy: addr.py clean-arp
	@@echo '\n======== $@@ ========'
	@@echo Send ARP Request for fake address that is proxied
	ssh ${REMOTE_SSH} ${SUDO} arp -s ${FAKE_ADDR} ${PROXY_MAC}
	ssh ${REMOTE_SSH} ${SUDO} arp -s ${FAKE_ADDR} ${FAKE_MAC} pub
	${SUDO} ${PYTHON}arp_proxy.py
	ssh ${REMOTE_SSH} ${SUDO} arp -an >arp.log
	ssh ${REMOTE_SSH} ${SUDO} arp -d ${FAKE_ADDR}
	ssh ${REMOTE_SSH} ${SUDO} arp -d ${FAKE_ADDR}
	grep '^${FAKE_ADDR} .* ${FAKE_MAC} .* static * p$$' arp.log

# Enter a static ARP entry on the remote machine for a fake address,
# but do not publish it.  The local machine requests this IP as a the
# target.
# Check that no answer is received.
# Check that the remote machine has a static ARP entry.
TARGETS +=	arp-nonproxy
run-regress-arp-nonproxy: addr.py clean-arp
	@@echo '\n======== $@@ ========'
	@@echo Send ARP Request for fake address that is not published
	ssh ${REMOTE_SSH} ${SUDO} arp -s ${FAKE_ADDR} ${FAKE_MAC}
	${SUDO} ${PYTHON}arp_nonproxy.py
	ssh ${REMOTE_SSH} ${SUDO} arp -an >arp.log
	ssh ${REMOTE_SSH} ${SUDO} arp -d ${FAKE_ADDR}
	grep '^${FAKE_ADDR} .* ${FAKE_MAC} .* static * $$' arp.log

# Publish a proxy ARP entry on the remote machine for a fake address
# on another interface.  The local machine requests this IP.  As the
# proxy entry is for another interface, it must not be answered.
# Check that no answer is received.
# Check that the remote machine has a public ARP entry.
TARGETS +=	arp-otherproxy
run-regress-arp-otherproxy: addr.py clean-arp
	@@echo '\n======== $@@ ========'
	@@echo Send ARP Request for address proxied on another interface
	ssh ${REMOTE_SSH} ${SUDO} arp -s ${OTHERFAKE_ADDR} ${FAKE_MAC} pub
	${SUDO} ${PYTHON}arp_otherproxy.py
	ssh ${REMOTE_SSH} ${SUDO} arp -an >arp.log
	ssh ${REMOTE_SSH} ${SUDO} arp -d ${OTHERFAKE_ADDR}
	grep '^${OTHERFAKE_ADDR} .* ${FAKE_MAC} .* static * p$$' arp.log

REGRESS_TARGETS =	${TARGETS:S/^/run-regress-/}

CLEANFILES +=		addr.py *.pyc *.log

.include <bsd.regress.mk>
@


1.8
log
@Print SKIPPED if a regress test cannot be executed for some reason.
This allows to identify such tests by looking at their output.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.7 2016/07/18 09:09:24 bluhm Exp $
d9 1
d13 1
@


1.7
log
@Remote regression tests should not run ssh with -t all the time.
This will make it easier to automate them.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.6 2016/03/30 11:09:56 bluhm Exp $
d16 1
d53 1
@


1.6
log
@Clear local and remote ARP cache for every subtest.
OK mpi
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.5 2016/03/30 09:06:27 mpi Exp $
d54 9
d91 1
a91 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -da
d126 2
a127 2
	ssh -t ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
	ssh -t ${REMOTE_SSH} ${SUDO} arp -s ${LOCAL_ADDR} ${LOCAL_MAC} temp
d132 1
a132 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -d ${LOCAL_ADDR}
d154 1
a154 1
	ssh -t ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
d171 1
a171 1
	ssh -t ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
d189 1
a189 1
	ssh -t ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
d208 2
a209 2
	ssh -t ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
	ssh -t ${REMOTE_SSH} ${SUDO} arp -s ${FAKE_ADDR} ${FAKE_MAC} permanent
d214 1
a214 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -d ${FAKE_ADDR}
d228 1
a228 1
	ssh -t ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
d248 2
a249 2
	ssh -t ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
	ssh -t ${REMOTE_SSH} ${SUDO} arp -s ${OTHERFAKE_ADDR} ${FAKE_MAC} temp
d254 1
a254 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -d ${OTHERFAKE_ADDR}
d270 2
a271 2
	ssh -t ${REMOTE_SSH} logger -t "arp-regress[$$$$]" $@@
	ssh -t ${REMOTE_SSH} ${SUDO} ping -n -w 1 -c 1 ${OTHERFAKE_ADDR} || true
d276 1
a276 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -d ${OTHERFAKE_ADDR}
d289 2
a290 2
	ssh -t ${REMOTE_SSH} ${SUDO} arp -s ${FAKE_ADDR} ${PROXY_MAC}
	ssh -t ${REMOTE_SSH} ${SUDO} arp -s ${FAKE_ADDR} ${FAKE_MAC} pub
d293 2
a294 2
	ssh -t ${REMOTE_SSH} ${SUDO} arp -d ${FAKE_ADDR}
	ssh -t ${REMOTE_SSH} ${SUDO} arp -d ${FAKE_ADDR}
d306 1
a306 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -s ${FAKE_ADDR} ${FAKE_MAC}
d309 1
a309 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -d ${FAKE_ADDR}
d321 1
a321 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -s ${OTHERFAKE_ADDR} ${FAKE_MAC} pub
d324 1
a324 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -d ${OTHERFAKE_ADDR}
@


1.5
log
@Fix multicast test and a typo.

ok bluhm@@
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.4 2016/03/24 07:11:45 mpi Exp $
d76 8
d88 1
a88 1
run-regress-ping:
a89 2
	${SUDO} arp -da
	ssh -t ${REMOTE_SSH} ${SUDO} arp -da
d100 1
a100 1
run-regress-arp-request: addr.py
a102 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -d ${LOCAL_ADDR}
d114 1
a114 1
run-regress-arp-multicast: addr.py
d133 1
a133 1
run-regress-arp-probe: addr.py
d142 1
a142 1
run-regress-arp-broadcast: addr.py
d159 1
a159 1
run-regress-arp-announcement: addr.py
d177 1
a177 1
run-regress-arp-gratuitous: addr.py
d196 1
a196 1
run-regress-arp-permanent: addr.py
d216 1
a216 1
run-regress-arp-address: addr.py
d236 1
a236 1
run-regress-arp-temporary: addr.py
d258 1
a258 1
run-regress-arp-incomplete: addr.py
d277 1
a277 1
run-regress-arp-proxy: addr.py
d294 1
a294 1
run-regress-arp-nonproxy: addr.py
d309 1
a309 1
run-regress-arp-otherproxy: addr.py
@


1.4
log
@Make sure that two ARP entries can be created for the same IP when
doing proxy ARP.

ok millert@@, bluhm@@
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.3 2015/12/04 23:43:04 bluhm Exp $
d121 1
a121 1
	grep '^${LOCAL_ADDR} .* ${LOCAL_MAC} ' arp.log
d252 2
a253 2
TARGETS +=	arp-incomlete
run-regress-arp-incomlete: addr.py
@


1.3
log
@Comment all existing ARP test cases describing what is going on.
Add a new test that creates proxy ARP entries on a second interface.
Requests for that from the first interfaces must not be answered.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.2 2015/12/04 20:48:24 bluhm Exp $
d34 1
d275 1
d279 1
@


1.2
log
@Enter a static ARP entry for a fake address which is not published
by the ARP proxy.  The kernel must not answer ARP requests for such
addresss.  This test triggers a misbehavior in ART as it currently
answers in such situations.  Radix tree works fine as it uses 33
bit IPv4 entries for ARP proxy.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.1.1.1 2015/11/05 01:49:12 bluhm Exp $
d75 2
a76 2
# Clear arp cache and ping all addresses.  This ensures that
# the ip addresses are configured and all routing table are set up
d88 4
d101 6
d122 4
d132 3
d146 6
d165 5
d183 6
d204 5
d222 7
d244 7
d266 4
d280 5
d294 15
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#	$OpenBSD$
d94 1
a94 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -an >arp.log
d106 1
a106 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -an >arp.log
d137 1
a137 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -an >arp.log
d140 1
a140 1
	grep '^${REMOTE_ADDR} .* ${REMOTE_MAC} .* permanent ' arp.log
d150 1
a150 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -an >arp.log
d153 1
a153 1
	grep '^${REMOTE_ADDR} .* ${REMOTE_MAC} .* permanent ' arp.log
d164 1
a164 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -an >arp.log
d168 1
a168 1
	grep '^${FAKE_ADDR} .* ${FAKE_MAC} .* permanent ' arp.log
d178 1
a178 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -an >arp.log
d181 1
a181 1
	grep '^${OTHER_ADDR} .* permanent ' arp.log
d192 1
a192 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -an >arp.log
d207 1
a207 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -an >arp.log
d219 1
a219 1
	ssh -t ${REMOTE_SSH} ${SUDO} arp -an >arp.log
d221 11
a231 1
	grep '^${FAKE_ADDR} .* ${FAKE_MAC} .* static .* p' arp.log
@


1.1.1.1
log
@Add regression tests for the ARP implementation in the kernel.  Send
multiple ARP packets to a remote machine with Scapy.  Check ARP 
replies, table entries and log messages.  All log messages in 
in_arpinput() are generated.  Proxy ARP is also tested.
@
text
@@
