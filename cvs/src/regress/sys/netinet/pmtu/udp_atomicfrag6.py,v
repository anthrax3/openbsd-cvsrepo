head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.6
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3;
locks; strict;
comment	@# @;


1.3
date	2017.01.19.15.00.38;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	2HBNFHpffGEI4NUd;

1.2
date	2017.01.18.23.03.44;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	CeKCY3OcQDpvUbop;

1.1
date	2017.01.18.19.26.59;	author bluhm;	state Exp;
branches;
next	;
commitid	xgGC5bPElBQiKZYG;


desc
@@


1.3
log
@Our kernel does not generate IPv6 atomic fragments anymore.  Check
that the test does not receive any.
@
text
@#!/usr/local/bin/python2.7

import os
import string
import random
from addr import *
from scapy.all import *

e=Ether(src=LOCAL_MAC, dst=REMOTE_MAC)
ip6=IPv6(src=FAKE_NET_ADDR6, dst=REMOTE_ADDR6)
uport=os.getpid() & 0xffff
# inetd ignores UDP packets from privileged port or nfs
if uport < 1024 or uport == 2049:
	uport+=1024

print "Send UDP packet with 1200 octets payload, receive echo."
data=''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase +
    string.digits) for _ in range(1200))
udp=UDP(sport=uport, dport='echo')/data
echo=srp1(e/ip6/udp, iface=LOCAL_IF, timeout=5)

if echo is None:
	print "ERROR: no UDP answer from echo server received"
	exit(1)

print "Send ICMP6 packet too big packet with MTU 1272."
icmp6=ICMPv6PacketTooBig(mtu=1272)/echo.payload
sendp(e/IPv6(src=LOCAL_ADDR6, dst=REMOTE_ADDR6)/icmp6, iface=LOCAL_IF)

print "Clear route cache at echo socket by sending from different address."
sendp(e/IPv6(src=LOCAL_ADDR6, dst=REMOTE_ADDR6)/udp, iface=LOCAL_IF)

print "Path MTU discovery will not send UDP atomic fragment."
# srp1 cannot be used, fragment answer will not match on outgoing UDP packet
if os.fork() == 0:
	time.sleep(1)
	sendp(e/ip6/udp, iface=LOCAL_IF)
	os._exit(0)

ans=sniff(iface=LOCAL_IF, timeout=3, filter=
    "ip6 and src "+ip6.dst+" and dst "+ip6.src+" and proto ipv6-frag")

print "IPv6 atomic fragments must not be generated."
frag=None
for a in ans:
	fh=a.payload.payload
	if fh.offset != 0 or fh.nh != (ip6/udp).nh:
		continue
	uh=fh.payload
	if uh.sport != udp.dport or uh.dport != udp.sport:
		continue
	frag=a
	break

if frag is not None:
	print "ERROR: matching IPv6 fragment UDP answer found"
	exit(1)

print "Send echo again and expect reply without fragmentation."
reply=srp1(e/IPv6(src=LOCAL_ADDR6, dst=REMOTE_ADDR6)/udp, iface=LOCAL_IF)

print "UDP echo has IPv6 and UDP header, so expected payload len is 1248."
elen = reply.plen + len(IPv6())
print "rlen=%d" % elen
if elen != 1248:
	print "ERROR: UDP reply payload len is %d, expected 1248." % elen
	exit(1)

exit(0)
@


1.2
log
@Do not use privileged or NFS source ports for UDP packets as inetd
ignores such packets.  This should avoid some sporadic failures.
While there, use variable names consistently in all tests.
@
text
@d33 2
a34 2
print "Path MTU discovery will send UDP atomic fragment with length 1256."
# srp1 cannot be used, fragment answer will not match on outgoing udp packet
d43 2
a53 3
else:
	print "ERROR: no matching IPv6 fragment UDP answer found"
	exit(1)
d55 2
a56 2
if frag.offset != 0:
	print "ERROR: TCP fragment is not atomic, offset is %d." % frag.offset
d59 2
a60 3
if frag.m != 0:
	print "ERROR: TCP fragment is not atomic, more fragment bit is set."
	exit(1)
d62 3
a64 3
print "UDP echo has IPv6 and UDP header, so expected payload len is 1248"
elen = echo.plen + len(IPv6())
print "elen=%d" % elen
d66 1
a66 8
	print "ERROR: UDP echo payload len is %d, expected 1248." % elen
	exit(1)

print "Atomic fragment contains 8 octet header, so expected len is 1256"
flen = frag.plen + len(IPv6())
print "flen=%d" % flen
if flen != 1256:
	print "ERROR: UDP atomic fragment len is %d, expected 1256." % flen
@


1.1
log
@Add tests that generate IPv6 atomic fragments for UDP and TCP by
sending an ICMP6 too big packet with MTU 1272.
@
text
@d11 4
a14 4
port=os.getpid() & 0xffff
# inetd ignores packets from privileged port or nfs
if port < 1024 or port == 2049:
	port+=1024
d19 1
a19 1
udp=UDP(sport=port, dport='echo')/data
@

