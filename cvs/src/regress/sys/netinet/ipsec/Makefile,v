head	1.16;
access;
symbols
	OPENBSD_6_1:1.6.0.4
	OPENBSD_6_1_BASE:1.6
	bluhm_20170206:1.1.1.1
	bluhm:1.1.1;
locks; strict;
comment	@# @;


1.16
date	2017.05.28.21.23.47;	author bluhm;	state Exp;
branches;
next	1.15;
commitid	cBjakFsMsK3w2EbO;

1.15
date	2017.05.27.10.58.53;	author bluhm;	state Exp;
branches;
next	1.14;
commitid	htDA97kscxuqVnKR;

1.14
date	2017.05.15.20.09.11;	author bluhm;	state Exp;
branches;
next	1.13;
commitid	7E0CqgZrQWY550Dh;

1.13
date	2017.05.12.00.09.17;	author bluhm;	state Exp;
branches;
next	1.12;
commitid	t2xus2JciIjIwAKc;

1.12
date	2017.05.11.12.18.37;	author bluhm;	state Exp;
branches;
next	1.11;
commitid	XHY6N0TUQUM4YHPF;

1.11
date	2017.05.11.11.42.45;	author bluhm;	state Exp;
branches;
next	1.10;
commitid	ykXKh5gRN7LI9NT7;

1.10
date	2017.05.10.22.21.39;	author bluhm;	state Exp;
branches;
next	1.9;
commitid	QArzd4m4CXn2O5Qx;

1.9
date	2017.05.04.22.10.39;	author bluhm;	state Exp;
branches;
next	1.8;
commitid	B9GXpSlYYH57oEqj;

1.8
date	2017.04.16.16.59.53;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	hpGq1pT1hHI9Vx7Z;

1.7
date	2017.04.14.19.03.50;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	jXheFZtkXlZaAz76;

1.6
date	2017.02.27.16.53.59;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	1etDVlj4DY6lAghO;

1.5
date	2017.02.13.17.54.27;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	QdZDDgO8zyidhhiV;

1.4
date	2017.02.08.23.09.28;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	ijZ5G7yC0GxN00CG;

1.3
date	2017.02.08.17.58.59;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	EEeNxU6pA9OS6i77;

1.2
date	2017.02.06.22.58.51;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	95HOSuhexmuLTCxk;

1.1
date	2017.02.06.21.54.05;	author bluhm;	state Exp;
branches
	1.1.1.1;
next	;
commitid	ymImhD4qA3SEDVJy;

1.1.1.1
date	2017.02.06.21.54.05;	author bluhm;	state Exp;
branches;
next	;
commitid	ymImhD4qA3SEDVJy;


desc
@@


1.16
log
@Now that pf looks behind IPv4 authentication headers, disable the
transport mode tests that fail because of floating states.  At least
IPv4 and IPv6 are in sync now.
@
text
@#	$OpenBSD: Makefile,v 1.15 2017/05/27 10:58:53 bluhm Exp $

# This test needs a manual setup of four machines, the make
# target create-setup can be used distribute the configuration.
# The setup is the same as for regress/sys/net/pf_forward.
# Set up machines: SRC IPS RT ECO
# SRC is the machine where this makefile is running.
# IPS is running IPsec, it is reflecting or forwarding packets.
# RT is a router forwarding packets, maximum MTU is 1300.
# ECO is reflecting the ping and UDP and TCP echo packets.
#
# By choosing the net prefix of the outgoing packet the mode is selected
# 5 -> 5 : transport v4
# 4 -> 5 : transport v6
# 8 -> c : tunnel v4 stack v4
# 8 -> c : tunnel v4 stack v6
# 8 -> d : tunnel v6 stack v4
# 8 -> d : tunnel v6 stack v6
# 8 -> e : tunnel v4 forward v4
# 8 -> e : tunnel v4 forward v6
# 8 -> f : tunnel v6 forward v4
# 8 -> f : tunnel v6 forward v6
#
#               1400        1300
# +---+   06  +---+   1   +---+   2   +---+
# |SRC| ----> |IPS| ----> |RT | ----> |ECO|
# +---+ 458 5 +---+ cd    +---+    ef +---+
#     out    in   out    in   out    in
#
# The encapsulation is chosen by the digit before
# 0,1 ESP
# 2,3 AH
# 4,5 IPIP
# 6,7 IPCOMP
# 8,9 BUNDLE

PREFIX_IPV4 ?=	10.188.1
PREFIX_IPV6 ?=	fdd7:e83e:66bc:1

# IPv4 outgoing address is selected by route if address of cloning route,
# so SRC_TRANSP_IPV4 and IPS_TRANSP_IPV4 must be in same net
# IPv6 outgoing address is selected common prefix, 4 and 5 are close together
# SRC_TRANSP_IPV6 and IPS_TRANSP_IPV6 should be in different network
# to avoid encryption of neighbor discovery packets

SRC_OUT_IPV4 ?=	${PREFIX_IPV4}00.17
SRC_OUT_IPV6 ?=	${PREFIX_IPV6}00::17
SRC_BUNDLE_IPV4 ?=	${PREFIX_IPV4}06.17
SRC_BUNDLE_IPV6 ?=	${PREFIX_IPV6}06::17
SRC_ESP_TRANSP_IPV4 ?=	${PREFIX_IPV4}05.17
SRC_ESP_TRANSP_IPV6 ?=	${PREFIX_IPV6}04::17
SRC_ESP_TUNNEL_IPV4 ?=	${PREFIX_IPV4}08.17
SRC_ESP_TUNNEL_IPV6 ?=	${PREFIX_IPV6}08::17
SRC_AH_TRANSP_IPV4 ?=	${PREFIX_IPV4}25.17
SRC_AH_TRANSP_IPV6 ?=	${PREFIX_IPV6}24::17
SRC_AH_TUNNEL_IPV4 ?=	${PREFIX_IPV4}28.17
SRC_AH_TUNNEL_IPV6 ?=	${PREFIX_IPV6}28::17
SRC_IPIP_TRANSP_IPV4 ?=	${PREFIX_IPV4}45.17
SRC_IPIP_TRANSP_IPV6 ?=	${PREFIX_IPV6}44::17
SRC_IPIP_TUNNEL_IPV4 ?=	${PREFIX_IPV4}48.17
SRC_IPIP_TUNNEL_IPV6 ?=	${PREFIX_IPV6}48::17
SRC_IPCOMP_TRANSP_IPV4 ?=	${PREFIX_IPV4}65.17
SRC_IPCOMP_TRANSP_IPV6 ?=	${PREFIX_IPV6}64::17
SRC_IPCOMP_TUNNEL_IPV4 ?=	${PREFIX_IPV4}68.17
SRC_IPCOMP_TUNNEL_IPV6 ?=	${PREFIX_IPV6}68::17
SRC_BUNDLE_TRANSP_IPV4 ?=	${PREFIX_IPV4}85.17
SRC_BUNDLE_TRANSP_IPV6 ?=	${PREFIX_IPV6}84::17
SRC_BUNDLE_TUNNEL_IPV4 ?=	${PREFIX_IPV4}88.17
SRC_BUNDLE_TUNNEL_IPV6 ?=	${PREFIX_IPV6}88::17

IPS_IN_IPV4 ?=	${PREFIX_IPV4}00.70
IPS_IN_IPV6 ?=	${PREFIX_IPV6}00::70
IPS_OUT_IPV4 ?=	${PREFIX_IPV4}01.70
IPS_OUT_IPV6 ?=	${PREFIX_IPV6}01::70
IPS_BUNDLE_IPV4 ?=	${PREFIX_IPV4}06.70
IPS_BUNDLE_IPV6 ?=	${PREFIX_IPV6}06::70
IPS_ESP_TRANSP_IPV4 ?=	${PREFIX_IPV4}05.70
IPS_ESP_TRANSP_IPV6 ?=	${PREFIX_IPV6}05::70
IPS_ESP_TUNNEL4_IPV4 ?=	${PREFIX_IPV4}12.70
IPS_ESP_TUNNEL4_IPV6 ?=	${PREFIX_IPV6}0c::70
IPS_ESP_TUNNEL6_IPV4 ?=	${PREFIX_IPV4}13.70
IPS_ESP_TUNNEL6_IPV6 ?=	${PREFIX_IPV6}0d::70
IPS_AH_TRANSP_IPV4 ?=	${PREFIX_IPV4}25.70
IPS_AH_TRANSP_IPV6 ?=	${PREFIX_IPV6}25::70
IPS_AH_TUNNEL4_IPV4 ?=	${PREFIX_IPV4}32.70
IPS_AH_TUNNEL4_IPV6 ?=	${PREFIX_IPV6}2c::70
IPS_AH_TUNNEL6_IPV4 ?=	${PREFIX_IPV4}33.70
IPS_AH_TUNNEL6_IPV6 ?=	${PREFIX_IPV6}2d::70
IPS_IPIP_TRANSP_IPV4 ?=	${PREFIX_IPV4}45.70
IPS_IPIP_TRANSP_IPV6 ?=	${PREFIX_IPV6}45::70
IPS_IPIP_TUNNEL4_IPV4 ?=	${PREFIX_IPV4}52.70
IPS_IPIP_TUNNEL4_IPV6 ?=	${PREFIX_IPV6}4c::70
IPS_IPIP_TUNNEL6_IPV4 ?=	${PREFIX_IPV4}53.70
IPS_IPIP_TUNNEL6_IPV6 ?=	${PREFIX_IPV6}4d::70
IPS_IPCOMP_TRANSP_IPV4 ?=	${PREFIX_IPV4}65.70
IPS_IPCOMP_TRANSP_IPV6 ?=	${PREFIX_IPV6}65::70
IPS_IPCOMP_TUNNEL4_IPV4 ?=	${PREFIX_IPV4}72.70
IPS_IPCOMP_TUNNEL4_IPV6 ?=	${PREFIX_IPV6}6c::70
IPS_IPCOMP_TUNNEL6_IPV4 ?=	${PREFIX_IPV4}73.70
IPS_IPCOMP_TUNNEL6_IPV6 ?=	${PREFIX_IPV6}6d::70
IPS_BUNDLE_TRANSP_IPV4 ?=	${PREFIX_IPV4}85.70
IPS_BUNDLE_TRANSP_IPV6 ?=	${PREFIX_IPV6}85::70
IPS_BUNDLE_TUNNEL4_IPV4 ?=	${PREFIX_IPV4}92.70
IPS_BUNDLE_TUNNEL4_IPV6 ?=	${PREFIX_IPV6}8c::70
IPS_BUNDLE_TUNNEL6_IPV4 ?=	${PREFIX_IPV4}93.70
IPS_BUNDLE_TUNNEL6_IPV6 ?=	${PREFIX_IPV6}8d::70

RT_IN_IPV4 ?=	${PREFIX_IPV4}01.71
RT_IN_IPV6 ?=	${PREFIX_IPV6}01::71
RT_OUT_IPV4 ?=	${PREFIX_IPV4}02.71
RT_OUT_IPV6 ?=	${PREFIX_IPV6}02::71

ECO_IN_IPV4 ?=	${PREFIX_IPV4}02.72
ECO_IN_IPV6 ?=	${PREFIX_IPV6}02::72
ECO_ESP_TUNNEL4_IPV4 ?=	${PREFIX_IPV4}14.72
ECO_ESP_TUNNEL4_IPV6 ?=	${PREFIX_IPV6}0e::72
ECO_ESP_TUNNEL6_IPV4 ?=	${PREFIX_IPV4}15.72
ECO_ESP_TUNNEL6_IPV6 ?=	${PREFIX_IPV6}0f::72
ECO_AH_TUNNEL4_IPV4 ?=	${PREFIX_IPV4}34.72
ECO_AH_TUNNEL4_IPV6 ?=	${PREFIX_IPV6}2e::72
ECO_AH_TUNNEL6_IPV4 ?=	${PREFIX_IPV4}35.72
ECO_AH_TUNNEL6_IPV6 ?=	${PREFIX_IPV6}2f::72
ECO_IPIP_TUNNEL4_IPV4 ?=	${PREFIX_IPV4}54.72
ECO_IPIP_TUNNEL4_IPV6 ?=	${PREFIX_IPV6}4e::72
ECO_IPIP_TUNNEL6_IPV4 ?=	${PREFIX_IPV4}55.72
ECO_IPIP_TUNNEL6_IPV6 ?=	${PREFIX_IPV6}4f::72
ECO_IPCOMP_TUNNEL4_IPV4 ?=	${PREFIX_IPV4}74.72
ECO_IPCOMP_TUNNEL4_IPV6 ?=	${PREFIX_IPV6}6e::72
ECO_IPCOMP_TUNNEL6_IPV4 ?=	${PREFIX_IPV4}75.72
ECO_IPCOMP_TUNNEL6_IPV6 ?=	${PREFIX_IPV6}6f::72
ECO_BUNDLE_TUNNEL4_IPV4 ?=	${PREFIX_IPV4}94.72
ECO_BUNDLE_TUNNEL4_IPV6 ?=	${PREFIX_IPV6}8e::72
ECO_BUNDLE_TUNNEL6_IPV4 ?=	${PREFIX_IPV4}95.72
ECO_BUNDLE_TUNNEL6_IPV6 ?=	${PREFIX_IPV6}8f::72

# Configure Addresses on the machines, there must be routes for the
# networks.  Adapt interface and addresse variables to your local
# setup.  To control the remote machine you need a hostname for
# ssh to log in.
#
# IPS and ECO need inetd echo service on TRANSP and TUNNEL addresses.
# Run make create-setup to copy hostname.if files to the machines
# Run make check-setup to see if you got the setup correct.

SRC_OUT_IF ?=	tap4
IPS_IN_IF ?=	vio1
IPS_OUT_IF ?=	vio2
RT_IN_IF ?=	vio1
RT_OUT_IF ?=	vio2
ECO_IN_IF ?=	vio1

.MAIN: all

.if empty (IPS_SSH) || empty (RT_SSH) || empty (ECO_SSH)
regress:
	@@echo this tests needs three remote machines to operate on
	@@echo IPS_SSH RT_SSH ECO_SSH are empty
	@@echo fill out these variables for additional tests, then
	@@echo check whether your test machines are set up properly
	@@echo SKIPPED

.elif make (regress) || make (all)
.BEGIN: ipsec.conf addr.py
	@@echo
	${SUDO} true
	ssh -t ${IPS_SSH} ${SUDO} true
	rm -f stamp-*
.endif

depend: addr.py

# Create python include file containing the addresses.
addr.py: Makefile
	@@echo '\n======== $@@ ========'
	rm -f $@@ $@@.tmp
.for host in SRC IPS RT ECO
.for dir in IN OUT BUNDLE
.for ipv in IF IPV4 IPV6
	echo '${host}_${dir}_${ipv}="${${host}_${dir}_${ipv}}"' >>$@@.tmp
.endfor
.endfor
.endfor
.for sec in ESP AH IPIP IPCOMP BUNDLE
.for host mode in SRC TRANSP SRC TUNNEL \
    IPS TRANSP IPS TUNNEL4 IPS TUNNEL6 \
    ECO TUNNEL4 ECO TUNNEL6
.for ipv in IPV4 IPV6
	echo '${host}_${sec}_${mode}_${ipv}="${${host}_${sec}_${mode}_${ipv}}"'\
	    >>$@@.tmp
.endfor
.endfor
.endfor
	mv $@@.tmp $@@

# load the ipsec sa and flow into the kernel of the SRC and IPS machine
stamp-ipsec: addr.py ipsec.conf
	@@echo '\n======== $@@ ========'
	cat addr.py ${.CURDIR}/ipsec.conf | ipsecctl -n -f -
	${SUDO} ipsecctl -F
	cat addr.py ${.CURDIR}/ipsec.conf | ${SUDO} ipsecctl -f -
	ssh ${IPS_SSH} ${SUDO} ipsecctl -F
	cat addr.py ${.CURDIR}/ipsec.conf | ssh ${IPS_SSH} ${SUDO} ipsecctl\
	    -f - -D FROM=to -D TO=from -D LOCAL=peer -D PEER=local
	@@date >$@@

# load a pf log enc0 pass any rule into the kernel of the IPS machine
stamp-pfctl: addr.py pf.conf
	@@echo '\n======== $@@ ========'
	cat addr.py ${.CURDIR}/pf.conf | pfctl -n -f -
	cat addr.py ${.CURDIR}/pf.conf | \
	    ssh ${IPS_SSH} ${SUDO} pfctl -a regress -f -
	@@date >$@@

DUMPCMD=	tcpdump -l -e -vvv -s 2048 -ni

# run tcpdump on enc device of IPS machine
stamp-bpf: Makefile stamp-drop
	@@echo '\n======== $@@ ========'
	rm -f enc0.tcpdump
	-ssh ${IPS_SSH} ${SUDO} pkill -f "'${DUMPCMD} enc0'" || true
	ssh ${IPS_SSH} ${SUDO} ${DUMPCMD} enc0 >enc0.tcpdump &
	sleep 5  # XXX
	rm -f stamp-stop
	@@date >$@@

# run tcpdump on pflog device of IPS machine
stamp-pflog: stamp-pfctl stamp-drop
	@@echo '\n======== $@@ ========'
	rm -f pflog0.tcpdump
	-ssh ${IPS_SSH} ${SUDO} pkill -f "'${DUMPCMD} pflog0'" || true
	ssh ${IPS_SSH} ${SUDO} ${DUMPCMD} pflog0 >pflog0.tcpdump &
	sleep 5  # XXX
	rm -f stamp-stop
	@@date >$@@

stamp-stop:
	@@echo '\n======== $@@ ========'
	sleep 5  # XXX
	-ssh ${IPS_SSH} ${SUDO} pkill -f "'${DUMPCMD}'"
	@@date >$@@

# Old TCP connections send packets from time to time.  These confuse
# the checks that count the IPsec packets with netstat -ss.
stamp-drop:
	@@echo '\n======== $@@ ========'
	netstat -nv -p tcp |\
	    perl -ne '\
		/ ${PREFIX_IPV6}.* ${PREFIX_IPV6}/ ||\
		/ ${PREFIX_IPV4}.* ${PREFIX_IPV4}/ or next;\
		my ($$laddr,$$faddr) = (split)[3,4];\
		my ($$lip,$$lport) = $$laddr =~ /(.*)\.(\d+)/;\
		my ($$fip,$$fport) = $$faddr =~ /(.*)\.(\d+)/;\
		print join(" ",$$lip,$$lport,$$fip,$$fport),"\n"' |\
	    xargs -r -L1 ${SUDO} tcpdrop
	@@date >$@@

# Disable tests that do not pass.

run-regress-pflog-ping-IPS_AH_TRANSP_IPV4 \
    run-regress-pflog-udp-IPS_AH_TRANSP_IPV4 \
    run-regress-pflog-tcp-IPS_AH_TRANSP_IPV4 \
    run-regress-pflog-ping-IPS_AH_TRANSP_IPV6 \
    run-regress-pflog-udp-IPS_AH_TRANSP_IPV6 \
    run-regress-pflog-tcp-IPS_AH_TRANSP_IPV6:
	@@echo '\n======== $@@ ========'
	@@echo IPv6 AH packets are treated as their payload protocol by pf.
	@@echo So they match the floating state on the physical interface
	@@echo and are not logged by the enc0 pf rule.
	@@echo DISABLED

# Ping all addresses.  This ensures that the IP addresses are configured
# and all routing table are set up to allow bidirectional packet flow.

.for host dir in SRC OUT IPS IN IPS OUT RT IN RT OUT ECO IN
.for ping ipv in ping IPV4 ping6 IPV6
TARGETS +=      ping-${host}_${dir}_${ipv}
run-regress-send-ping-${host}_${dir}_${ipv}:
	@@echo '\n======== $@@ ========'
	${ping} -n -c 1 -w 2 ${${host}_${dir}_${ipv}}
.endfor
.endfor

# send IPsec packets from SRC to IPS and expect response

.for sec in ESP AH IPIP IPCOMP BUNDLE

.for host mode in SRC TRANSP SRC TUNNEL \
    IPS TRANSP IPS TUNNEL4 IPS TUNNEL6 \
    ECO TUNNEL4 ECO TUNNEL6
.for ping ipv in ping IPV4 ping6 IPV6
.for len size in small -s24 big -s1000

TARGETS +=      ping-${len}-${host}_${sec}_${mode}_${ipv}
ping ${host:L} ${sec:L} ${mode:L} ${ipv:L}:\
    run-regress-send-ping-${len}-${host}_${sec}_${mode}_${ipv}
run-regress-send-ping-${len}-${host}_${sec}_${mode}_${ipv}:
	@@echo '\n======== $@@ ========'
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/input ${sec:S/BUNDLE/ESP/} /{print $$1}' >pkt.in
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/output ${sec:S/BUNDLE/ESP/} /{print $$1}' >pkt.out
	${ping} ${size} -n -c 1 -w 2 ${${host}_${sec}_${mode}_${ipv}}
.if "${host}" == SRC || ( "${len}" == small && "${sec}" == IPCOMP )
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/input ${sec:S/BUNDLE/ESP/} /{print $$1}' |\
	    diff pkt.in -
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/output ${sec:S/BUNDLE/ESP/} /{print $$1}' |\
	    diff pkt.out -
.else
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/input ${sec:S/BUNDLE/ESP/} /{print $$1-1}' |\
	    diff pkt.in -
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/output ${sec:S/BUNDLE/ESP/} /{print $$1-1}' |\
	    diff pkt.out -
.endif

.endfor
.endfor
.endfor

.for host mode in IPS TRANSP IPS TUNNEL4 IPS TUNNEL6 \
    ECO TUNNEL4 ECO TUNNEL6
.for ipv in IPV4 IPV6
TARGETS +=      udp-${host}_${sec}_${mode}_${ipv}
udp ${host:L} ${sec:L} ${mode:L} ${ipv:L}:\
    run-regress-send-udp-${host}_${sec}_${mode}_${ipv}
run-regress-send-udp-${host}_${sec}_${mode}_${ipv}:
	@@echo '\n======== $@@ ========'
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/input ${sec:S/BUNDLE/ESP/} /{print $$1}' >pkt.in
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/output ${sec:S/BUNDLE/ESP/} /{print $$1}' >pkt.out
	echo $$$$ | nc -n -u -W 1 -w 3 ${${host}_${sec}_${mode}_${ipv}} 7 |\
	    fgrep $$$$
.if "${sec}" == IPCOMP
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/input ${sec:S/BUNDLE/ESP/} /{print $$1}' |\
	    diff pkt.in -
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/output ${sec:S/BUNDLE/ESP/} /{print $$1}' |\
	    diff pkt.out -
.else
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/input ${sec:S/BUNDLE/ESP/} /{print $$1-1}' |\
	    diff pkt.in -
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/output ${sec:S/BUNDLE/ESP/} /{print $$1-1}' |\
	    diff pkt.out -
.endif

TARGETS +=      tcp-${host}_${sec}_${mode}_${ipv}
tcp ${host:L} ${sec:L} ${mode:L} ${ipv:L}:\
    run-regress-send-tcp-${host}_${sec}_${mode}_${ipv}
run-regress-send-tcp-${host}_${sec}_${mode}_${ipv}:
	@@echo '\n======== $@@ ========'
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/input ${sec:S/BUNDLE/ESP/} /{print $$1}' >pkt.in
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/output ${sec:S/BUNDLE/ESP/} /{print $$1}' >pkt.out
	echo $$$$ | nc -n -N -w 3 ${${host}_${sec}_${mode}_${ipv}} 7 |\
	    fgrep $$$$
.if "${sec}" == IPCOMP
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/input ${sec:S/BUNDLE/ESP/} /{print $$1}' |\
	    diff pkt.in -
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/output ${sec:S/BUNDLE/ESP/} /{print $$1}' |\
	    diff pkt.out -
.else
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/input ${sec:S/BUNDLE/ESP/} /{print $$1-4}' |\
	    diff pkt.in -
	netstat -s -p ${sec:L:S/ipip/ipencap/:S/bundle/esp/} |\
	    awk '/output ${sec:S/BUNDLE/ESP/} /{print $$1-6}' |\
	    diff pkt.out -
.endif

.endfor
.endfor

.endfor

# Check bpf has dumped all IPsec packets to enc0 on IPS

REGEX_ESP=	(authentic,confidential): SPI 0x[0-9a-f]*:
REGEX_AH=	(authentic): SPI 0x[0-9a-f]*:
REGEX_IPCOMP=	(unprotected): SPI 0x[0-9a-f]*:

REGEX_REQ_TRANSP=	*
REGEX_REQ_TUNNEL4=	${SRC_OUT_IPV4} > ${IPS_IN_IPV4}:
REGEX_REQ_TUNNEL6=	${SRC_OUT_IPV6} > ${IPS_IN_IPV6}:

REGEX_RPL_TRANSP=	*
REGEX_RPL_TUNNEL4=	${IPS_IN_IPV4} > ${SRC_OUT_IPV4}:
REGEX_RPL_TUNNEL6=	${IPS_IN_IPV6} > ${SRC_OUT_IPV6}:

REGEX_REQ_PING=	icmp6*: echo request
REGEX_REQ_UDP=	.* udp
REGEX_REQ_TCP=	S

REGEX_RPL_PING=	icmp6*: echo reply
REGEX_RPL_UDP=	.* udp
REGEX_RPL_TCP=	S .* ack

.for host in IPS ECO
.for sec in ESP AH IPIP IPCOMP BUNDLE
.for mode in TRANSP TUNNEL4 TUNNEL6
.for ipv in IPV4 IPV6

REGEX_REQ_${host}_${sec}_${mode}_${ipv}_PING=\
    ${SRC_${sec}_${mode:C/[46]$//}_${ipv}} >\
    ${${host}_${sec}_${mode}_${ipv}}:
REGEX_REQ_${host}_${sec}_${mode}_${ipv}_UDP=\
    ${SRC_${sec}_${mode:C/[46]$//}_${ipv}}\.[0-9][0-9]* >\
    ${${host}_${sec}_${mode}_${ipv}}\.7:
REGEX_REQ_${host}_${sec}_${mode}_${ipv}_TCP=\
    ${REGEX_REQ_${host}_${sec}_${mode}_${ipv}_UDP}

REGEX_RPL_${host}_${sec}_${mode}_${ipv}_PING=\
    ${${host}_${sec}_${mode}_${ipv}} >\
    ${SRC_${sec}_${mode:C/[46]$//}_${ipv}}:
REGEX_RPL_${host}_${sec}_${mode}_${ipv}_UDP=\
    ${${host}_${sec}_${mode}_${ipv}}\.7 >\
    ${SRC_${sec}_${mode:C/[46]$//}_${ipv}}\.[0-9][0-9]*:
REGEX_RPL_${host}_${sec}_${mode}_${ipv}_TCP=\
    ${REGEX_RPL_${host}_${sec}_${mode}_${ipv}_UDP}

.for proto in PING UDP TCP

run-regress-bpf-${proto:L}-${host}_${sec}_${mode}_${ipv}: stamp-stop
	@@echo '\n======== $@@ ========'
	grep -q '\
	    ${REGEX_${sec}}\
	    ${REGEX_REQ_${mode}}\
	    ${REGEX_REQ_${host}_${sec}_${mode}_${ipv}_${proto}}\
	    ${REGEX_REQ_${proto}} ' enc0.tcpdump
	grep -q '\
	    ${REGEX_${sec}}\
	    ${REGEX_RPL_${mode}}\
	    ${REGEX_RPL_${host}_${sec}_${mode}_${ipv}_${proto}}\
	    ${REGEX_RPL_${proto}} ' enc0.tcpdump

run-regress-pflog-${proto:L}-${host}_${sec}_${mode}_${ipv}: stamp-stop
	@@echo '\n======== $@@ ========'
	grep -q '\
	    rule .*regress.0/(match) .*\
	    pass in on enc0:.*\
	    ${REGEX_REQ_${host}_${sec}_${mode}_${ipv}_${proto}}\
	    ${REGEX_REQ_${proto}} ' pflog0.tcpdump
	grep -q '\
	    rule .*/(match) .*\
	    pass out on enc0:.*\
	    ${REGEX_RPL_${host}_${sec}_${mode}_${ipv}_${proto}}\
	    ${REGEX_RPL_${proto}} ' pflog0.tcpdump

.endfor
.endfor
.endfor
.endfor
.endfor

REGRESS_TARGETS =	${TARGETS:S/^/run-regress-send-/} \
    ${TARGETS:N*_IPIP_*:N*_BUNDLE_*:N*_IN_*:N*_OUT_*:N*-SRC_*:Nudp-*_IPCOMP_*:Ntcp-*_IPCOMP_*:N*-small-*:S/-big-/-/:S/^/run-regress-bpf-/} \
    ${TARGETS:N*_IPIP_*:N*_IPCOMP_*:N*_IN_*:N*_OUT_*:N*-SRC_*:N*-small-*:S/-big-/-/:S/^/run-regress-pflog-/}
${REGRESS_TARGETS:Mrun-regress-send-*}: \
    stamp-ipsec stamp-bpf stamp-pflog stamp-drop

CLEANFILES +=	addr.py *.pyc *.log stamp-* */hostname.* *.{in,out} *.tcpdump

# create hostname.if files, copy them to the machines and install addresses

.PHONY: create-setup

create-setup: stamp-hostname

etc/hostname.${SRC_OUT_IF}: Makefile
	@@echo '\n======== $@@ ========'
	mkdir -p ${@@:H}
	rm -f $@@ $@@.tmp
	echo '### regress ipsec $@@' >$@@.tmp
.for dir in OUT BUNDLE
	echo '# SRC_${dir}' >>$@@.tmp
.for inet ipv masklen in inet IPV4 255.255.255.0 inet6 IPV6 64
	echo '${inet} alias ${SRC_${dir}_${ipv}} ${masklen}' >>$@@.tmp
.endfor
.endfor
.for sec in ESP AH IPIP IPCOMP BUNDLE
	echo '## SRC_${sec}' >>$@@.tmp
.for mode in TRANSP TUNNEL
	echo '# SRC_${sec}_${mode}' >>$@@.tmp
.for inet ipv masklen in inet IPV4 255.255.255.0 inet6 IPV6 64
	echo '${inet} alias ${SRC_${sec}_${mode}_${ipv}} ${masklen}' >>$@@.tmp
.endfor
.endfor
	echo '# IPS_${sec}_TRANSP_IPV6/64 IPS_IN_IPV6' >>$@@.tmp
	echo '!route -q delete -inet6 ${IPS_${sec}_TRANSP_IPV6}/64' >>$@@.tmp
	echo '!route add -inet6 ${IPS_${sec}_TRANSP_IPV6}/64 ${IPS_IN_IPV6}'\
	    >>$@@.tmp
.for host dir in RT IN ECO IN
	echo '# ${host}_${dir}/pfxlen IPS_IN' >>$@@.tmp
.for inet ipv pfxlen in inet IPV4 24 inet6 IPV6 64
	echo '!route -q delete -${inet} ${${host}_${dir}_${ipv}}/${pfxlen}'\
	    >>$@@.tmp
	echo '!route add -${inet} ${${host}_${dir}_${ipv}}/${pfxlen}\
	    ${IPS_IN_${ipv}}' >>$@@.tmp
.endfor
.endfor
.for host in IPS ECO
.for mode in TUNNEL4 TUNNEL6
	echo '# ${host}_${sec}_${mode}/pfxlen\
	    ${SRC_${sec}_TUNNEL_${ipv}}' >>$@@.tmp
.for inet ipv pfxlen in inet IPV4 24 inet6 IPV6 64
	echo '!route -q delete -${inet}\
	    ${${host}_${sec}_${mode}_${ipv}}/${pfxlen}' >>$@@.tmp
	echo '!route add -${inet} ${${host}_${sec}_${mode}_${ipv}}/${pfxlen}\
	    ${SRC_${sec}_TUNNEL_${ipv}}' >>$@@.tmp
.endfor
.endfor
.endfor
.endfor
	mv $@@.tmp $@@

${IPS_SSH}/hostname.${IPS_IN_IF}: Makefile
	mkdir -p ${@@:H}
	rm -f $@@ $@@.tmp
	echo '### regress ipsec $@@' >$@@.tmp
.for dir in IN BUNDLE
	echo '# IPS_${dir}' >>$@@.tmp
.for inet ipv masklen in inet IPV4 255.255.255.0 inet6 IPV6 64
	echo '${inet} alias ${IPS_${dir}_${ipv}} ${masklen}' >>$@@.tmp
.endfor
.endfor
.for sec in ESP AH IPIP IPCOMP BUNDLE
	echo '## IPS_${sec}' >>$@@.tmp
	echo '# IPS_${sec}_TRANSP' >>$@@.tmp
.for inet ipv masklen in inet IPV4 255.255.255.0 inet6 IPV6 64
	echo '${inet} alias ${IPS_${sec}_TRANSP_${ipv}} ${masklen}' >>$@@.tmp
.endfor
	echo '# SRC_${sec}_TRANSP_IPV6/64 SRC_OUT_IPV6' >>$@@.tmp
	echo '!route -q delete -inet6 ${SRC_${sec}_TRANSP_IPV6}/64' >>$@@.tmp
	echo '!route add -inet6 ${SRC_${sec}_TRANSP_IPV6}/64 ${SRC_OUT_IPV6}'\
	    >>$@@.tmp
.for mode in TUNNEL
	echo '# SRC_${sec}_${mode}/pfxlen ${IPS_IN_${ipv}}' >>$@@.tmp
.for inet ipv pfxlen in inet IPV4 24 inet6 IPV6 64
	echo '!route -q delete -${inet}\
	    ${SRC_${sec}_${mode}_${ipv}}/${pfxlen}' >>$@@.tmp
	echo '!route add -${inet} ${SRC_${sec}_${mode}_${ipv}}/${pfxlen}\
	    ${IPS_IN_${ipv}}' >>$@@.tmp
.endfor
.endfor
.endfor
	mv $@@.tmp $@@

${IPS_SSH}/hostname.${IPS_OUT_IF}: Makefile
	@@echo '\n======== $@@ ========'
	mkdir -p ${@@:H}
	rm -f $@@ $@@.tmp
	echo '### regress ipsec $@@' >$@@.tmp
	echo '# IPS_OUT' >>$@@.tmp
.for inet ipv masklen in inet IPV4 255.255.255.0 inet6 IPV6 64
	echo '${inet} alias ${IPS_OUT_${ipv}} ${masklen}' >>$@@.tmp
.endfor
	echo '# ECO_IN/pfxlen RT_IN' >>$@@.tmp
.for inet ipv pfxlen in inet IPV4 24 inet6 IPV6 64
	echo '!route -q delete -${inet} ${ECO_IN_${ipv}}/${pfxlen}'\
	    >>$@@.tmp
	echo '!route add -${inet} ${ECO_IN_${ipv}}/${pfxlen} ${RT_IN_${ipv}}'\
	    >>$@@.tmp
.endfor
.for sec in ESP AH IPIP IPCOMP BUNDLE
	echo '## IPS_${sec}' >>$@@.tmp
.for mode in TUNNEL4 TUNNEL6
	echo '# IPS_${sec}_${mode}' >>$@@.tmp
.for inet ipv masklen in inet IPV4 255.255.255.0 inet6 IPV6 64
	echo '${inet} alias ${IPS_${sec}_${mode}_${ipv}} ${masklen}' >>$@@.tmp
.endfor
.endfor
.for mode in TUNNEL4 TUNNEL6
	echo '# ECO_${sec}_${mode}/pfxlen RT_IN' >>$@@.tmp
.for inet ipv pfxlen in inet IPV4 24 inet6 IPV6 64
	echo '!route -q delete -${inet}\
	    ${ECO_${sec}_${mode}_${ipv}}/${pfxlen}' >>$@@.tmp
	echo '!route add -${inet} ${ECO_${sec}_${mode}_${ipv}}/${pfxlen}\
	    ${RT_IN_${ipv}}' >>$@@.tmp
.endfor
.endfor
.endfor
	mv $@@.tmp $@@

${RT_SSH}/hostname.${RT_IN_IF}: Makefile
	@@echo '\n======== $@@ ========'
	mkdir -p ${@@:H}
	rm -f $@@ $@@.tmp
	echo '### regress ipsec $@@' >$@@.tmp
	echo '# RT_IN' >>$@@.tmp
.for inet ipv masklen in inet IPV4 255.255.255.0 inet6 IPV6 64
	echo '${inet} alias ${RT_IN_${ipv}} ${masklen}' >>$@@.tmp
.endfor
	echo '# SRC_OUT/pfxlen IPS_OUT' >>$@@.tmp
.for inet ipv pfxlen in inet IPV4 24 inet6 IPV6 64
	echo '!route -q delete -${inet} ${SRC_OUT_${ipv}}/${pfxlen}'\
	    >>$@@.tmp
	echo '!route add -${inet} ${SRC_OUT_${ipv}}/${pfxlen}'\
	    ${IPS_OUT_${ipv}} >>$@@.tmp
.endfor
.for sec in ESP AH IPIP IPCOMP BUNDLE
	echo '## IPS_${sec}' >>$@@.tmp
.for mode in TUNNEL
	echo '# SRC_${mode}/pfxlen IPS_OUT' >>$@@.tmp
.for inet ipv pfxlen in inet IPV4 24 inet6 IPV6 64
	echo '!route -q delete -${inet} ${SRC_${sec}_${mode}_${ipv}}/${pfxlen}'\
	    >>$@@.tmp
	echo '!route add -${inet} ${SRC_${sec}_${mode}_${ipv}}/${pfxlen}\
	    ${IPS_OUT_${ipv}}' >>$@@.tmp
.endfor
.endfor
.endfor
	mv $@@.tmp $@@

${RT_SSH}/hostname.${RT_OUT_IF}: Makefile
	@@echo '\n======== $@@ ========'
	mkdir -p ${@@:H}
	rm -f $@@ $@@.tmp
	echo '### regress ipsec $@@' >$@@.tmp
	echo '# RT_OUT' >>$@@.tmp
.for inet ipv masklen in inet IPV4 255.255.255.0 inet6 IPV6 64
	echo '${inet} alias ${RT_OUT_${ipv}} ${masklen}' >>$@@.tmp
.endfor
.for sec in ESP AH IPIP IPCOMP BUNDLE
	echo '## IPS_${sec}' >>$@@.tmp
.for mode in TUNNEL4 TUNNEL6
	echo '# ECO_${sec}_${mode}/pfxlen ECO_IN' >>$@@.tmp
.for inet ipv pfxlen in inet IPV4 24 inet6 IPV6 64
	echo '!route -q delete -${inet}\
	    ${ECO_${sec}_${mode}_${ipv}}/${pfxlen}' >>$@@.tmp
	echo '!route add -${inet} ${ECO_${sec}_${mode}_${ipv}}/${pfxlen}\
	    ${ECO_IN_${ipv}}' >>$@@.tmp
.endfor
.endfor
.endfor
	mv $@@.tmp $@@

${ECO_SSH}/hostname.${ECO_IN_IF}: Makefile
	@@echo '\n======== $@@ ========'
	mkdir -p ${@@:H}
	rm -f $@@ $@@.tmp
	echo '### regress ipsec $@@' >$@@.tmp
	echo '# ECO_IN' >>$@@.tmp
.for inet ipv masklen in inet IPV4 255.255.255.0 inet6 IPV6 64
	echo '${inet} alias ${ECO_IN_${ipv}} ${masklen}' >>$@@.tmp
.endfor
.for host in IPS SRC
	echo '# ${host}_OUT/pfxlen RT_OUT' >>$@@.tmp
.for inet ipv pfxlen in inet IPV4 24 inet6 IPV6 64
	echo '!route -q delete -${inet} ${${host}_OUT_${ipv}}/${pfxlen}'\
	    >>$@@.tmp
	echo '!route add -${inet} ${${host}_OUT_${ipv}}/${pfxlen}\
	    ${RT_OUT_${ipv}}' >>$@@.tmp
.endfor
.endfor
.for sec in ESP AH IPIP IPCOMP BUNDLE
	echo '## IPS_${sec}' >>$@@.tmp
.for mode in TUNNEL4 TUNNEL6
	echo '# ECO_${sec}_${mode}' >>$@@.tmp
.for inet ipv masklen in inet IPV4 255.255.255.0 inet6 IPV6 64
	echo '${inet} alias ${ECO_${sec}_${mode}_${ipv}} ${masklen}' >>$@@.tmp
.endfor
.endfor
.for mode in TUNNEL
	echo '# SRC_${sec}_${mode}/pfxlen RT_OUT' >>$@@.tmp
.for inet ipv pfxlen in inet IPV4 24 inet6 IPV6 64
	echo '!route -q delete -${inet}\
	    ${SRC_${sec}_${mode}_${ipv}}/${pfxlen}' >>$@@.tmp
	echo '!route add -${inet} ${SRC_${sec}_${mode}_${ipv}}/${pfxlen}\
	    ${RT_OUT_${ipv}}' >>$@@.tmp
.endfor
.endfor
.endfor
	mv $@@.tmp $@@

stamp-hostname: etc/hostname.${SRC_OUT_IF} \
    ${IPS_SSH}/hostname.${IPS_IN_IF} ${IPS_SSH}/hostname.${IPS_OUT_IF} \
    ${RT_SSH}/hostname.${RT_IN_IF} ${RT_SSH}/hostname.${RT_OUT_IF} \
    ${ECO_SSH}/hostname.${ECO_IN_IF}
	@@echo '\n======== $@@ ========'
	${SUDO} sh -c "umask 027;\
	    { sed '/^### regress/,\$$d' /etc/hostname.${SRC_OUT_IF} &&\
	    cat; } >/etc/hostname.${SRC_OUT_IF}.tmp"\
	    <etc/hostname.${SRC_OUT_IF}
	${SUDO} sh -c "mv /etc/hostname.${SRC_OUT_IF}.tmp\
	    /etc/hostname.${SRC_OUT_IF} &&\
	    sh /etc/netstart ${SRC_OUT_IF}"
.for host dir in IPS IN IPS OUT RT IN RT OUT ECO IN
	ssh root@@${${host}_SSH} "umask 027;\
	    { sed '/^### regress/,\$$d' /etc/hostname.${${host}_${dir}_IF} &&\
	    cat; } >/etc/hostname.${${host}_${dir}_IF}.tmp"\
	    <${${host}_SSH}/hostname.${${host}_${dir}_IF}
	ssh root@@${${host}_SSH} "mv /etc/hostname.${${host}_${dir}_IF}.tmp\
	    /etc/hostname.${${host}_${dir}_IF} &&\
	    sh /etc/netstart ${${host}_${dir}_IF}"
.endfor
	date >$@@

.PHONY: check-setup

# Check whether the address, route and remote setup is correct

check-setup: check-setup-src check-setup-ips check-setup-rt check-setup-eco

check-setup-src:
	@@echo '\n======== $@@ ========'
.for ping inet ipv in ping inet IPV4 ping6 inet6 IPV6
.for host dir in SRC OUT SRC BUNDLE
	${ping} -n -c 1 ${${host}_${dir}_${ipv}}  # ${host}_${dir}_${ipv}
	route -n get -${inet} ${${host}_${dir}_${ipv}} |\
	    grep -q 'flags: .*LOCAL'  # ${host}_${dir}_${ipv}
.endfor
	${ping} -n -c 1 ${IPS_IN_${ipv}}  # IPS_IN_${ipv}
	${ping} -n -c 1 ${IPS_BUNDLE_${ipv}}  # IPS_BUNDLE_${ipv}
.for host dir in IPS OUT RT IN RT OUT ECO IN
	route -n get -${inet} ${${host}_${dir}_${ipv}} |\
	    fgrep -q 'gateway: ${IPS_IN_${ipv}}' \
	    # ${host}_${dir}_${ipv} IPS_IN_${ipv}
.endfor
.for sec in ESP AH IPIP IPCOMP BUNDLE
.for host mode in SRC TRANSP SRC TUNNEL
	${ping} -n -c 1 ${${host}_${sec}_${mode}_${ipv}} \
	    # ${host}_${sec}_${mode}_${ipv}
	route -n get -${inet} ${${host}_${sec}_${mode}_${ipv}} |\
	    grep -q 'flags: .*LOCAL'  # ${host}_${sec}_${mode}_${ipv}
.endfor
.for host mode in IPS TUNNEL4 IPS TUNNEL6 ECO TUNNEL4 ECO TUNNEL6
	route -n get -${inet} ${${host}_${sec}_${mode}_${ipv}} |\
	    grep -q 'flags: .*STATIC'  # ${host}_${sec}_${mode}_${ipv}
.endfor
.endfor
.endfor
.for sec in ESP AH IPIP IPCOMP BUNDLE
	route -n get -inet ${IPS_${sec}_TRANSP_IPV4} |\
	    egrep -q 'flags: .*(CLONING|CLONED)'  # IPS_${sec}_TRANSP_IPV4
	route -n get -inet6 ${IPS_${sec}_TRANSP_IPV6} |\
	    fgrep -q 'gateway: ${IPS_IN_IPV6}' \
	    # IPS_${sec}_TRANSP_IPV6 IPS_IN_IPV6
.endfor
	sysctl net.inet.esp.enable | fgrep =1
	sysctl net.inet.ah.enable | fgrep =1
	sysctl net.inet.ipip.allow | fgrep =1
	sysctl net.inet.ipcomp.enable | fgrep =1

check-setup-ips:
	@@echo '\n======== $@@ ========'
.for ping inet ipv in ping inet IPV4 ping6 inet6 IPV6
.for host dir in IPS IN IPS OUT IPS BUNDLE
	ssh ${IPS_SSH} ${ping} -n -c 1 ${${host}_${dir}_${ipv}} \
	    # ${host}_${dir}_${ipv}
	ssh ${IPS_SSH} route -n get -${inet} ${${host}_${dir}_${ipv}} |\
	    grep -q 'flags: .*LOCAL'  # ${host}_${dir}_${ipv}
.endfor
	ssh ${IPS_SSH} ${ping} -n -c 1 ${SRC_OUT_${ipv}}  # SRC_OUT_${ipv}
	ssh ${IPS_SSH} ${ping} -n -c 1 ${SRC_BUNDLE_${ipv}}  # SRC_BUNDLE_${ipv}
	ssh ${IPS_SSH} ${ping} -n -c 1 ${RT_IN_${ipv}}  # RT_IN_${ipv}
.for host dir in RT OUT ECO IN
	ssh ${IPS_SSH} route -n get -${inet} ${${host}_${dir}_${ipv}} |\
	    fgrep -q 'gateway: ${RT_IN_${ipv}}' \
	    # ${host}_${dir}_${ipv} RT_IN_${ipv}
.endfor
.for sec in ESP AH IPIP IPCOMP BUNDLE
.for host mode in IPS TRANSP IPS TUNNEL4 IPS TUNNEL6
	ssh ${IPS_SSH} ${ping} -n -c 1 ${${host}_${sec}_${mode}_${ipv}} \
	    # ${host}_${sec}_${mode}_${ipv}
	ssh ${IPS_SSH} route -n get -${inet} ${${host}_${sec}_${mode}_${ipv}} |\
	    grep -q 'flags: .*LOCAL'  # ${host}_${sec}_${mode}_${ipv}
.endfor
.for host mode in ECO TUNNEL4 ECO TUNNEL6
	ssh ${IPS_SSH} route -n get -${inet} ${${host}_${sec}_${mode}_${ipv}} |\
	    fgrep -q 'gateway: ${RT_IN_${ipv}}' \
	    # ${host}_${sec}_${mode}_${ipv} RT_IN_${ipv}
.endfor
.for host mode in SRC TUNNEL
	ssh ${IPS_SSH} route -n get -${inet} ${${host}_${sec}_${mode}_${ipv}} |\
	    grep -q 'flags: .*STATIC'  # ${host}_${sec}_${mode}_${ipv}
.endfor
.for host mode in IPS TRANSP IPS TUNNEL4 IPS TUNNEL6
	ssh ${IPS_SSH} netstat -nav -f ${inet} -p udp |\
	    fgrep ' ${${host}_${sec}_${mode}_${ipv}}.7 ' \
	    # ${host}_${sec}_${mode}_${ipv}
.endfor
.endfor
	ssh ${ECO_SSH} netstat -na -f ${inet} -p tcp | fgrep ' *.7 '
.endfor
.for sec in ESP AH IPIP IPCOMP BUNDLE
	ssh ${IPS_SSH} route -n get -inet ${SRC_${sec}_TRANSP_IPV4} |\
	    egrep -q 'flags: .*(CLONING|CLONED)'  # SRC_${sec}_TRANSP_IPV4
	ssh ${IPS_SSH} route -n get -inet6 ${SRC_${sec}_TRANSP_IPV6} |\
	    fgrep -q 'gateway: ${SRC_OUT_IPV6}' \
	    # SRC_${sec}_TRANSP_IPV6 SRC_OUT_IPV6
.endfor
	ssh ${IPS_SSH} sysctl net.inet.esp.enable | fgrep =1
	ssh ${IPS_SSH} sysctl net.inet.ah.enable | fgrep =1
	ssh ${IPS_SSH} sysctl net.inet.ipip.allow | fgrep =1
	ssh ${IPS_SSH} sysctl net.inet.ipcomp.enable | fgrep =1
	ssh ${PF_SSH} ${SUDO} pfctl -sr | grep '^anchor "regress" all$$'
	ssh ${PF_SSH} ${SUDO} pfctl -si | grep '^Status: Enabled '

check-setup-rt:
	@@echo '\n======== $@@ ========'
.for ping inet ipv in ping inet IPV4 ping6 inet6 IPV6
.for host dir in RT IN RT OUT
	ssh ${RT_SSH} ${ping} -n -c 1 ${${host}_${dir}_${ipv}} \
	    # ${host}_${dir}_${ipv}
	ssh ${RT_SSH} route -n get -${inet} ${${host}_${dir}_${ipv}} |\
	    grep -q 'flags: .*LOCAL'  # ${host}_${dir}_${ipv}
.endfor
	ssh ${RT_SSH} ${ping} -n -c 1 ${IPS_OUT_${ipv}}  # IPS_OUT_${ipv}
.for host dir in IPS IN SRC OUT
	ssh ${RT_SSH} route -n get -${inet} ${${host}_${dir}_${ipv}} |\
	    fgrep -q 'gateway: ${IPS_OUT_${ipv}}' \
	    # ${host}_${dir}_${ipv} IPS_OUT_${ipv}
.endfor
	ssh ${RT_SSH} ${ping} -n -c 1 ${ECO_IN_${ipv}}  # ECO_IN_${ipv}
.for sec in ESP AH IPIP IPCOMP BUNDLE
.for host mode in SRC TUNNEL
	ssh ${RT_SSH} route -n get -${inet} ${${host}_${sec}_${mode}_${ipv}} |\
	    fgrep -q 'gateway: ${IPS_OUT_${ipv}}' \
	    # ${host}_${sec}_${mode}_${ipv} IPS_OUT_${ipv}
.endfor
.for host mode in ECO TUNNEL4 ECO TUNNEL6
	ssh ${RT_SSH} route -n get -${inet} ${${host}_${sec}_${mode}_${ipv}} |\
	    fgrep -q 'gateway: ${ECO_IN_${ipv}}' \
	    # ${host}_${sec}_${mode}_${ipv} ECO_IN_${ipv}
.endfor
.endfor
.endfor

check-setup-eco:
	@@echo '\n======== $@@ ========'
.for ping inet ipv in ping inet IPV4 ping6 inet6 IPV6
.for host dir in ECO IN
	ssh ${ECO_SSH} ${ping} -n -c 1 ${${host}_${dir}_${ipv}} \
	    # ${host}_${dir}_${ipv}
	ssh ${ECO_SSH} route -n get -${inet} ${${host}_${dir}_${ipv}} |\
	    grep -q 'flags: .*LOCAL'  # ${host}_${dir}_${ipv}
.endfor
	ssh ${ECO_SSH} ${ping} -n -c 1 ${RT_OUT_${ipv}}  # RT_OUT_${ipv}
.for host dir in RT IN IPS OUT IPS IN SRC OUT
	ssh ${ECO_SSH} route -n get -${inet} ${${host}_${dir}_${ipv}} |\
	    fgrep -q 'gateway: ${RT_OUT_${ipv}}' \
	    # ${host}_${dir}_${ipv} RT_OUT_${ipv}
.endfor
.for sec in ESP AH IPIP IPCOMP BUNDLE
.for host mode in ECO TUNNEL4 ECO TUNNEL6
	ssh ${ECO_SSH} ${ping} -n -c 1 ${${host}_${sec}_${mode}_${ipv}} \
	    # ${host}_${sec}_${mode}_${ipv}
	ssh ${ECO_SSH} route -n get -${inet} ${${host}_${sec}_${mode}_${ipv}} |\
	    grep -q 'flags: .*LOCAL'  # ${host}_${sec}_${mode}_${ipv}
.endfor
.for host mode in SRC TUNNEL
	ssh ${ECO_SSH} route -n get -${inet} ${${host}_${sec}_${mode}_${ipv}} |\
	    fgrep -q 'gateway: ${RT_OUT_${ipv}}' \
	    # ${host}_${sec}_${mode}_${ipv} RT_OUT_${ipv}
.endfor
.for host mode in ECO TUNNEL4 ECO TUNNEL6
	ssh ${ECO_SSH} netstat -nav -f ${inet} -p udp |\
	    fgrep ' ${${host}_${sec}_${mode}_${ipv}}.7 ' \
	    # ${host}_${sec}_${mode}_${ipv}
.endfor
.endfor
	ssh ${ECO_SSH} netstat -na -f ${inet} -p tcp | fgrep ' *.7 '
.endfor

.include <bsd.regress.mk>
@


1.15
log
@Do not use reject routes as they prevent path MTU discovery.
Drop possible old TCP connections from previous test runs.
Adapt regex that checks tcpdump pflog0, output has been fixed.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.14 2017/05/15 20:09:11 bluhm Exp $
d259 4
a262 1
run-regress-pflog-ping-IPS_AH_TRANSP_IPV6 \
@


1.14
log
@Try to work around a race in the daily test run.  Before killing
tcpdump, sleep a while to collect all data.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.13 2017/05/12 00:09:17 bluhm Exp $
d167 1
a167 1
	rm -f stamp-ipsec stamp-pfctl stamp-bpf stamp-pflog stamp-stop
d217 1
a217 1
stamp-bpf: Makefile
d227 1
a227 1
stamp-pflog: stamp-pfctl
d242 15
d446 1
a446 1
	    pass in on enc0: .*\
d451 1
a451 1
	    pass out on enc0: .*\
d464 2
a465 1
${REGRESS_TARGETS:Mrun-regress-send-*}: stamp-ipsec stamp-bpf stamp-pflog
d467 1
a467 1
CLEANFILES +=	addr.py *.pyc *.log stamp-* */hostname.* *.{in,out} *.tcdump
d509 1
a509 1
	echo '# ${host}_${sec}_${mode}/pfxlen reject\
d515 1
a515 1
	    -reject ${SRC_${sec}_TUNNEL_${ipv}}' >>$@@.tmp
d543 1
a543 1
	echo '# SRC_${sec}_${mode}/pfxlen reject ${IPS_IN_${ipv}}' >>$@@.tmp
d548 1
a548 1
	    -reject ${IPS_IN_${ipv}}' >>$@@.tmp
d734 1
a734 1
	    grep -q 'flags: .*REJECT'  # ${host}_${sec}_${mode}_${ipv}
d781 1
a781 1
	    grep -q 'flags: .*REJECT'  # ${host}_${sec}_${mode}_${ipv}
@


1.13
log
@Run all IPsec tests with a pf rule that logs everything on the enc0
interface.  Use tcpdump to write the pflog0 output into a file.
Then grep can verify that all encrypted packets have been processed
by pf.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.12 2017/05/11 12:18:37 bluhm Exp $
d238 1
@


1.12
log
@Enable IPv6 IPsec transport mode tests for ping and TCP over ESP
and IPComp.  The kernel has been fixed.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.11 2017/05/11 11:42:45 bluhm Exp $
d167 1
a167 1
	rm -f stamp-ipsec stamp-bpf stamp-stop
d174 1
d206 8
d220 1
a220 1
	-ssh ${IPS_SSH} ${SUDO} pkill -f "'${DUMPCMD}' enc0" || true
d226 10
d241 11
d389 1
a389 1
.for sec in ESP AH IPCOMP BUNDLE
d412 1
a414 3
.if "${sec}" == IPCOMP && "${sec}" != PING
	@@echo packet too small to be compressed
.else
d425 14
a438 1
.endif
a439 1

d446 3
a448 2
    ${TARGETS:N*_IPIP_*:N*_BUNDLE_*:N*_IN_*:N*_OUT_*:N*-SRC_*:N*-small-*:S/^/run-regress-bpf-/:S/-big-/-/}
${REGRESS_TARGETS:Mrun-regress-send-*}: stamp-ipsec stamp-bpf
d785 2
@


1.11
log
@Use the new netcat -W recvlimit feature to speed up the test.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.10 2017/05/10 22:21:39 bluhm Exp $
a232 33

# disable some tests, they do not pass yet due to kernel bugs

run-regress-bpf-ping-IPS_ESP_TRANSP_IPV6 \
    run-regress-send-ping-small-IPS_ESP_TRANSP_IPV6 \
    run-regress-send-ping-big-IPS_ESP_TRANSP_IPV6:
	@@echo '\n======== $@@ ========'
	@@echo 'IPv6 IPsec input does not filter enc0 interface with pf.  Echo'
	@@echo 'request does not create state and echo reply does not pass pf.'
	@@echo DISABLED

run-regress-bpf-tcp-IPS_ESP_TRANSP_IPV6 \
    run-regress-send-tcp-IPS_ESP_TRANSP_IPV6:
	@@echo '\n======== $@@ ========'
	@@echo 'IPv6 IPsec input does not filter enc0 interface with pf.  TCP'
	@@echo 'SYN does not create state and SYN+ACK does not pass pf.'
	@@echo DISABLED

run-regress-send-ping-IPS_IPCOMP_TRANSP_IPV6 \
    run-regress-send-ping-small-IPS_IPCOMP_TRANSP_IPV6 \
    run-regress-send-ping-big-IPS_IPCOMP_TRANSP_IPV6:
	@@echo '\n======== $@@ ========'
	@@echo 'IPv6 IPsec input does not filter enc0 interface with pf.  Echo'
	@@echo 'request does not create state and echo reply does not pass pf.'
	@@echo DISABLED

run-regress-send-ping-small-IPS_BUNDLE_TRANSP_IPV6 \
    run-regress-send-ping-big-IPS_BUNDLE_TRANSP_IPV6 \
    run-regress-send-tcp-IPS_BUNDLE_TRANSP_IPV6:
	@@echo '\n======== $@@ ========'
	@@echo 'IPv6 IPsec input does not filter enc0 interface with pf.  Echo'
	@@echo 'request does not create state and echo reply does not pass pf.'
	@@echo DISABLED
@


1.10
log
@Run tcpdump(8) on the enc0 device while the test is sending IPsec
packets.  Then check whether decrypted packets have been processed
by bpf(4) as expected.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.9 2017/05/04 22:10:39 bluhm Exp $
d319 1
a319 1
	echo $$$$ | nc -n -u -w 1 ${${host}_${sec}_${mode}_${ipv}} 7 |\
@


1.9
log
@Add IPsec test for manually configured SA bundles.  That does ipcomp,
and esp, and ah with one flow and three SAs in one step.  Test
transport mode, locally terminated tunnel and forwarding packets
from and to tunnel.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.8 2017/04/16 16:59:53 kettenis Exp $
d159 1
a159 1
	@@echo check wether your test machines are set up properly
d167 1
a167 1
	rm -f stamp-ipsec
d205 17
d228 1
a228 1
run-regress-ping-${host}_${dir}_${ipv}:
d234 5
a238 3
run-regress-ping-IPS_ESP_TRANSP_IPV6 \
    run-regress-ping-small-IPS_ESP_TRANSP_IPV6 \
    run-regress-ping-big-IPS_ESP_TRANSP_IPV6:
d244 2
a245 1
run-regress-tcp-IPS_ESP_TRANSP_IPV6:
d251 3
a253 3
run-regress-ping-IPS_IPCOMP_TRANSP_IPV6 \
    run-regress-ping-small-IPS_IPCOMP_TRANSP_IPV6 \
    run-regress-ping-big-IPS_IPCOMP_TRANSP_IPV6:
d259 3
a261 3
run-regress-ping-small-IPS_BUNDLE_TRANSP_IPV6 \
    run-regress-ping-big-IPS_BUNDLE_TRANSP_IPV6 \
    run-regress-tcp-IPS_BUNDLE_TRANSP_IPV6:
d267 2
d279 2
a280 2
    run-regress-ping-${len}-${host}_${sec}_${mode}_${ipv}
run-regress-ping-${len}-${host}_${sec}_${mode}_${ipv}:
d312 2
a313 2
    run-regress-udp-${host}_${sec}_${mode}_${ipv}
run-regress-udp-${host}_${sec}_${mode}_${ipv}:
d339 2
a340 2
    run-regress-tcp-${host}_${sec}_${mode}_${ipv}
run-regress-tcp-${host}_${sec}_${mode}_${ipv}:
d369 72
a440 1
REGRESS_TARGETS =	${TARGETS:S/^/run-regress-/}
d442 1
a442 1
${REGRESS_TARGETS}: stamp-ipsec
d444 1
a444 1
CLEANFILES +=		addr.py *.pyc *.log stamp-* */hostname.* *.{in,out}
d681 2
a682 1
# Check wether the address, route and remote setup is correct
@


1.8
log
@Make sure these tests print "SKIPPED" if the necessary variables aren't set.
The current code doesn't work since the magic .BEGIN target runs before
the regress target that prints "SKIPPED" and the .BEGIN target fails when
the variables aren't set.

ok bluhm@@
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.7 2017/04/14 19:03:50 bluhm Exp $
d25 1
a25 1
# +---+   0   +---+   1   +---+   2   +---+
d35 1
d48 2
d66 4
d75 2
d101 6
d131 4
d176 1
a176 1
.for dir in IN OUT
d182 1
a182 1
.for sec in ESP AH IPIP IPCOMP
d239 9
a247 1
.for sec in ESP AH IPIP IPCOMP
d260 4
a263 4
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/input ${sec} /{print $$1}' >pkt.in
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/output ${sec} /{print $$1}' >pkt.out
d266 2
a267 2
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/input ${sec} /{print $$1}' |\
d269 2
a270 2
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/output ${sec} /{print $$1}' |\
d273 2
a274 2
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/input ${sec} /{print $$1-1}' |\
d276 2
a277 2
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/output ${sec} /{print $$1-1}' |\
d293 4
a296 4
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/input ${sec} /{print $$1}' >pkt.in
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/output ${sec} /{print $$1}' >pkt.out
d300 2
a301 2
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/input ${sec} /{print $$1}' |\
d303 2
a304 2
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/output ${sec} /{print $$1}' |\
d307 2
a308 2
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/input ${sec} /{print $$1-1}' |\
d310 2
a311 2
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/output ${sec} /{print $$1-1}' |\
d320 4
a323 4
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/input ${sec} /{print $$1}' >pkt.in
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/output ${sec} /{print $$1}' >pkt.out
d327 2
a328 2
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/input ${sec} /{print $$1}' |\
d330 2
a331 2
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/output ${sec} /{print $$1}' |\
d334 2
a335 2
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/input ${sec} /{print $$1-4}' |\
d337 2
a338 2
	netstat -s -p ${sec:L:S/ipip/ipencap/} |\
	    awk '/output ${sec} /{print $$1-6}' |\
d341 1
d362 2
a363 1
	echo '# SRC_OUT' >>$@@.tmp
d365 1
a365 1
	echo '${inet} alias ${SRC_OUT_${ipv}} ${masklen}' >>$@@.tmp
d367 2
a368 1
.for sec in ESP AH IPIP IPCOMP
d408 2
a409 1
	echo '# IPS_IN' >>$@@.tmp
d411 2
a412 1
	echo '${inet} alias ${IPS_IN_${ipv}} ${masklen}' >>$@@.tmp
d414 1
a414 1
.for sec in ESP AH IPIP IPCOMP
d452 1
a452 1
.for sec in ESP AH IPIP IPCOMP
d488 1
a488 1
.for sec in ESP AH IPIP IPCOMP
d511 1
a511 1
.for sec in ESP AH IPIP IPCOMP
d543 1
a543 1
.for sec in ESP AH IPIP IPCOMP
d594 1
a594 1
.for host dir in SRC OUT
d600 1
d606 1
a606 1
.for sec in ESP AH IPIP IPCOMP
d619 1
a619 1
.for sec in ESP AH IPIP IPCOMP
d634 1
a634 1
.for host dir in IPS IN IPS OUT
d641 1
d648 1
a648 1
.for sec in ESP AH IPIP IPCOMP
d672 1
a672 1
.for sec in ESP AH IPIP IPCOMP
d700 1
a700 1
.for sec in ESP AH IPIP IPCOMP
d729 1
a729 1
.for sec in ESP AH IPIP IPCOMP
@


1.7
log
@Add test for IP payload compression.  It is sending small and big
ping packets as only the latter get actually compressed.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.6 2017/02/27 16:53:59 bluhm Exp $
d133 2
a141 3
.endif

.MAIN: all
d143 1
a143 1
.if make (regress) || make (all)
@


1.6
log
@Add IPsec tests for ipip encapsulation.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.5 2017/02/13 17:54:27 bluhm Exp $
d34 1
d59 4
d86 6
d112 4
d164 1
a164 1
.for sec in ESP AH IPIP
d199 3
a201 1
run-regress-ping-IPS_ESP_TRANSP_IPV6:
d213 9
a221 1
.for sec in ESP AH IPIP
d227 3
a229 1
TARGETS +=      ping-${host}_${sec}_${mode}_${ipv}
d231 2
a232 2
    run-regress-ping-${host}_${sec}_${mode}_${ipv}
run-regress-ping-${host}_${sec}_${mode}_${ipv}:
d238 9
a246 2
	${ping} -n -c 1 -w 2 ${${host}_${sec}_${mode}_${ipv}}
.if "${host}" != SRC
d254 2
d267 4
a270 2
	netstat -s -p ${sec:L:S/ipip/ipencap/} | awk '/input ${sec} /{print $$1}' >pkt.in
	netstat -s -p ${sec:L:S/ipip/ipencap/} | awk '/output ${sec} /{print $$1}' >pkt.out
d273 10
a282 1
	netstat -s -p ${sec:L:S/ipip/ipencap/} | awk '/input ${sec} /{print $$1-1}' |\
d284 2
a285 1
	netstat -s -p ${sec:L:S/ipip/ipencap/} | awk '/output ${sec} /{print $$1-1}' |\
d287 1
d294 4
a297 2
	netstat -s -p ${sec:L:S/ipip/ipencap/} | awk '/input ${sec} /{print $$1}' >pkt.in
	netstat -s -p ${sec:L:S/ipip/ipencap/} | awk '/output ${sec} /{print $$1}' >pkt.out
d300 3
a302 1
	netstat -s -p ${sec:L:S/ipip/ipencap/} | awk '/input ${sec} /{print $$1-4}' |\
d304 2
a305 1
	netstat -s -p ${sec:L:S/ipip/ipencap/} | awk '/output ${sec} /{print $$1-6}' |\
d307 8
d339 1
a339 1
.for sec in ESP AH IPIP
d383 1
a383 1
.for sec in ESP AH IPIP
d421 1
a421 1
.for sec in ESP AH IPIP
d457 1
a457 1
.for sec in ESP AH IPIP
d480 1
a480 1
.for sec in ESP AH IPIP
d512 1
a512 1
.for sec in ESP AH IPIP
d574 1
a574 1
.for sec in ESP AH IPIP
d587 1
a587 1
.for sec in ESP AH IPIP
d597 1
d615 1
a615 1
.for sec in ESP AH IPIP
d639 1
a639 1
.for sec in ESP AH IPIP
d649 1
d667 1
a667 1
.for sec in ESP AH IPIP
d696 1
a696 1
.for sec in ESP AH IPIP
@


1.5
log
@Test IPsec with AH the same way it is already done for ESP.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.4 2017/02/08 23:09:28 bluhm Exp $
d33 1
d54 4
d75 6
d97 4
d149 1
a149 1
.for sec in ESP AH
d164 1
d166 1
a166 3
	cat addr.py ${.CURDIR}/ipsec.conf | ipsecctl -n -f -
	cat addr.py ${.CURDIR}/ipsec.conf | \
	    ${SUDO} ipsecctl -f -
d168 2
a169 3
	cat addr.py ${.CURDIR}/ipsec.conf | \
	    ssh ${IPS_SSH} ${SUDO} ipsecctl -f - \
	    -D FROM=to -D TO=from -D LOCAL=peer -D PEER=local
d184 1
a184 3
.for sec in ESP AH

run-regress-ping-IPS_${sec}_TRANSP_IPV6:
d190 1
a190 1
run-regress-tcp-IPS_${sec}_TRANSP_IPV6:
d196 2
d203 2
d207 4
a210 2
	netstat -s -p ${sec:L} | awk '/input ${sec} /{print $$1}' >pkt.in
	netstat -s -p ${sec:L} | awk '/output ${sec} /{print $$1}' >pkt.out
d213 2
a214 1
	netstat -s -p ${sec:L} | awk '/input ${sec} /{print $$1-1}' |\
d216 2
a217 1
	netstat -s -p ${sec:L} | awk '/output ${sec} /{print $$1-1}' |\
d227 2
d231 2
a232 2
	netstat -s -p ${sec:L} | awk '/input ${sec} /{print $$1}' >pkt.in
	netstat -s -p ${sec:L} | awk '/output ${sec} /{print $$1}' >pkt.out
d235 1
a235 1
	netstat -s -p ${sec:L} | awk '/input ${sec} /{print $$1-1}' |\
d237 1
a237 1
	netstat -s -p ${sec:L} | awk '/output ${sec} /{print $$1-1}' |\
d241 2
d245 2
a246 2
	netstat -s -p ${sec:L} | awk '/input ${sec} /{print $$1}' >pkt.in
	netstat -s -p ${sec:L} | awk '/output ${sec} /{print $$1}' >pkt.out
d249 1
a249 1
	netstat -s -p ${sec:L} | awk '/input ${sec} /{print $$1-4}' |\
d251 1
a251 1
	netstat -s -p ${sec:L} | awk '/output ${sec} /{print $$1-6}' |\
d277 1
a277 1
.for sec in ESP AH
d321 1
a321 1
.for sec in ESP AH
d359 1
a359 1
.for sec in ESP AH
d395 1
a395 1
.for sec in ESP AH
d418 1
a418 1
.for sec in ESP AH
d450 1
a450 1
.for sec in ESP AH
d512 1
a512 1
.for sec in ESP AH
d525 1
a525 1
.for sec in ESP AH
d532 3
d552 1
a552 1
.for sec in ESP AH
d576 1
a576 1
.for sec in ESP AH
d583 3
d603 1
a603 1
.for sec in ESP AH
d632 1
a632 1
.for sec in ESP AH
@


1.4
log
@Fix IP address schema to make space for AH tests.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.3 2017/02/08 17:58:59 bluhm Exp $
d30 3
d45 8
a52 4
SRC_TRANSP_IPV4 ?=	${PREFIX_IPV4}05.17
SRC_TRANSP_IPV6 ?=	${PREFIX_IPV6}04::17
SRC_TUNNEL_IPV4 ?=	${PREFIX_IPV4}08.17
SRC_TUNNEL_IPV6 ?=	${PREFIX_IPV6}08::17
d58 12
a69 6
IPS_TRANSP_IPV4 ?=	${PREFIX_IPV4}05.70
IPS_TRANSP_IPV6 ?=	${PREFIX_IPV6}05::70
IPS_TUNNEL4_IPV4 ?=	${PREFIX_IPV4}12.70
IPS_TUNNEL4_IPV6 ?=	${PREFIX_IPV6}0c::70
IPS_TUNNEL6_IPV4 ?=	${PREFIX_IPV4}13.70
IPS_TUNNEL6_IPV6 ?=	${PREFIX_IPV6}0d::70
d78 8
a85 4
ECO_TUNNEL4_IPV4 ?=	${PREFIX_IPV4}14.72
ECO_TUNNEL4_IPV6 ?=	${PREFIX_IPV6}0e::72
ECO_TUNNEL6_IPV4 ?=	${PREFIX_IPV4}15.72
ECO_TUNNEL6_IPV6 ?=	${PREFIX_IPV6}0f::72
d134 2
a135 1
.for host dir in SRC TRANSP SRC TUNNEL \
d139 3
a141 1
	echo '${host}_${dir}_${ipv}="${${host}_${dir}_${ipv}}"' >>$@@.tmp
d162 12
a173 1
run-regress-ping-IPS_TRANSP_IPV6:
d179 1
a179 1
run-regress-tcp-IPS_TRANSP_IPV6:
d185 3
a187 4
.for host dir in SRC OUT SRC TRANSP SRC TUNNEL \
    IPS IN IPS OUT IPS TRANSP IPS TUNNEL4 IPS TUNNEL6 \
    RT IN RT OUT \
    ECO IN ECO TUNNEL4 ECO TUNNEL6
d189 2
a190 2
TARGETS +=      ping-${host}_${dir}_${ipv}
run-regress-ping-${host}_${dir}_${ipv}:
d192 8
a199 6
	netstat -s -p esp | awk '/input ESP /{print $$1}' >esp.in
	netstat -s -p esp | awk '/output ESP /{print $$1}' >esp.out
	${ping} -n -c 1 -w 2 ${${host}_${dir}_${ipv}}
.if "${host}" != SRC && "${dir}" != IN && "${dir}" != OUT
	netstat -s -p esp | awk '/input ESP /{print $$1-1}' | diff esp.in -
	netstat -s -p esp | awk '/output ESP /{print $$1-1}' | diff esp.out -
d204 1
a204 1
.for host dir in IPS TRANSP IPS TUNNEL4 IPS TUNNEL6 \
d207 2
a208 2
TARGETS +=      udp-${host}_${dir}_${ipv}
run-regress-udp-${host}_${dir}_${ipv}:
d210 20
a229 14
	netstat -s -p esp | awk '/input ESP /{print $$1}' >esp.in
	netstat -s -p esp | awk '/output ESP /{print $$1}' >esp.out
	echo $$$$ | nc -n -u -w 1 ${${host}_${dir}_${ipv}} 7 | fgrep $$$$
	netstat -s -p esp | awk '/input ESP /{print $$1-1}' | diff esp.in -
	netstat -s -p esp | awk '/output ESP /{print $$1-1}' | diff esp.out -

TARGETS +=      tcp-${host}_${dir}_${ipv}
run-regress-tcp-${host}_${dir}_${ipv}:
	@@echo '\n======== $@@ ========'
	netstat -s -p esp | awk '/input ESP /{print $$1}' >esp.in
	netstat -s -p esp | awk '/output ESP /{print $$1}' >esp.out
	echo $$$$ | nc -n -N -w 3 ${${host}_${dir}_${ipv}} 7 | fgrep $$$$
	netstat -s -p esp | awk '/input ESP /{print $$1-4}' | diff esp.in -
	netstat -s -p esp | awk '/output ESP /{print $$1-6}' | diff esp.out -
d233 2
d250 1
a250 2
.for dir in OUT TRANSP TUNNEL
	echo '# SRC_${dir}' >>$@@.tmp
d252 1
a252 1
	echo '${inet} alias ${SRC_${dir}_${ipv}} ${masklen}' >>$@@.tmp
d254 6
d261 5
a265 3
	echo '# IPS_TRANSP_IPV6/64 IPS_IN_IPV6' >>$@@.tmp
	echo '!route -q delete -inet6 ${IPS_TRANSP_IPV6}/64' >>$@@.tmp
	echo '!route add -inet6 ${IPS_TRANSP_IPV6}/64 ${IPS_IN_IPV6}' >>$@@.tmp
d271 2
a272 2
	echo '!route add -${inet} ${${host}_${dir}_${ipv}}/${pfxlen}'\
	    ${IPS_IN_${ipv}} >>$@@.tmp
d276 3
a278 2
.for dir in TUNNEL4 TUNNEL6
	echo '# ${host}_${dir}/pfxlen reject ${SRC_TUNNEL_${ipv}}' >>$@@.tmp
d280 5
a284 4
	echo '!route -q delete -${inet} ${${host}_${dir}_${ipv}}/${pfxlen}'\
	    >>$@@.tmp
	echo '!route add -${inet} ${${host}_${dir}_${ipv}}/${pfxlen}'\
	    -reject ${SRC_TUNNEL_${ipv}} >>$@@.tmp
d294 1
a294 2
.for dir in IN TRANSP
	echo '# IPS_${dir}' >>$@@.tmp
d296 1
a296 1
	echo '${inet} alias ${IPS_${dir}_${ipv}} ${masklen}' >>$@@.tmp
d298 5
d304 6
a309 5
	echo '# SRC_TRANSP_IPV6/64 SRC_OUT_IPV6' >>$@@.tmp
	echo '!route -q delete -inet6 ${SRC_TRANSP_IPV6}/64' >>$@@.tmp
	echo '!route add -inet6 ${SRC_TRANSP_IPV6}/64 ${SRC_OUT_IPV6}' >>$@@.tmp
.for host dir in SRC TUNNEL
	echo '# ${host}_${dir}/pfxlen reject ${IPS_IN_${ipv}}' >>$@@.tmp
d311 5
a315 4
	echo '!route -q delete -${inet} ${${host}_${dir}_${ipv}}/${pfxlen}'\
	    >>$@@.tmp
	echo '!route add -${inet} ${${host}_${dir}_${ipv}}/${pfxlen}'\
	    -reject ${IPS_IN_${ipv}} >>$@@.tmp
d325 15
a339 2
.for dir in OUT TUNNEL4 TUNNEL6
	echo '# IPS_${dir}' >>$@@.tmp
d341 1
a341 1
	echo '${inet} alias ${IPS_${dir}_${ipv}} ${masklen}' >>$@@.tmp
d344 2
a345 2
.for dir in IN TUNNEL4 TUNNEL6
	echo '# ECO_${dir}/pfxlen RT_IN' >>$@@.tmp
d347 5
a351 4
	echo '!route -q delete -${inet} ${ECO_${dir}_${ipv}}/${pfxlen}'\
	    >>$@@.tmp
	echo '!route add -${inet} ${ECO_${dir}_${ipv}}/${pfxlen}'\
	    ${RT_IN_${ipv}} >>$@@.tmp
d365 1
a365 2
.for dir in OUT TUNNEL
	echo '# SRC_${dir}/pfxlen IPS_OUT' >>$@@.tmp
d367 1
a367 1
	echo '!route -q delete -${inet} ${SRC_${dir}_${ipv}}/${pfxlen}'\
d369 1
a369 1
	echo '!route add -${inet} ${SRC_${dir}_${ipv}}/${pfxlen}'\
d372 11
d395 4
a398 2
.for dir in TUNNEL4 TUNNEL6
	echo '# ECO_${dir}/pfxlen ECO_IN' >>$@@.tmp
d400 5
a404 4
	echo '!route -q delete -${inet} ${ECO_${dir}_${ipv}}/${pfxlen}'\
	    >>$@@.tmp
	echo '!route add -${inet} ${ECO_${dir}_${ipv}}/${pfxlen}'\
	    ${ECO_IN_${ipv}} >>$@@.tmp
d414 1
a414 2
.for dir in IN TUNNEL4 TUNNEL6
	echo '# ECO_${dir}' >>$@@.tmp
d416 1
a416 2
	echo '${inet} alias ${ECO_${dir}_${ipv}} ${masklen}' >>$@@.tmp
.endfor
d418 2
a419 1
	echo '# IPS_OUT/pfxlen RT_OUT' >>$@@.tmp
d421 1
a421 1
	echo '!route -q delete -${inet} ${IPS_OUT_${ipv}}/${pfxlen}'\
d423 11
a433 2
	echo '!route add -${inet} ${IPS_OUT_${ipv}}/${pfxlen}'\
	    ${RT_OUT_${ipv}} >>$@@.tmp
d435 2
a436 2
.for dir in OUT TUNNEL
	echo '# SRC_${dir}/pfxlen RT_OUT' >>$@@.tmp
d438 5
a442 4
	echo '!route -q delete -${inet} ${SRC_${dir}_${ipv}}/${pfxlen}'\
	    >>$@@.tmp
	echo '!route add -${inet} ${SRC_${dir}_${ipv}}/${pfxlen}'\
	    ${RT_OUT_${ipv}} >>$@@.tmp
d478 1
a478 1
.for host dir in SRC OUT SRC TRANSP SRC TUNNEL
d489 11
a499 3
.for host dir in IPS TUNNEL4 IPS TUNNEL6 ECO TUNNEL4 ECO TUNNEL6
	route -n get -${inet} ${${host}_${dir}_${ipv}} |\
	    grep -q 'flags: .*REJECT'  # ${host}_${dir}_${ipv}
d502 4
a505 3
	route -n get -inet ${IPS_TRANSP_IPV4} |\
	    egrep -q 'flags: .*(CLONING|CLONED)' # IPS_TRANSP_IPV4
	route -n get -inet6 ${IPS_TRANSP_IPV6} |\
d507 2
a508 1
	    # IPS_TRANSP_IPV6 IPS_IN_IPV6
d513 1
a513 1
.for host dir in IPS IN IPS OUT IPS TRANSP IPS TUNNEL4 IPS TUNNEL6
d521 1
a521 1
.for host dir in RT OUT ECO IN ECO TUNNEL4 ECO TUNNEL6
d526 15
a540 3
.for host dir in SRC TUNNEL
	ssh ${IPS_SSH} route -n get -${inet} ${${host}_${dir}_${ipv}} |\
	    grep -q 'flags: .*REJECT'  # ${host}_${dir}_${ipv}
d542 1
a542 1
.for host dir in IPS TRANSP IPS TUNNEL4 IPS TUNNEL6
d544 3
a546 1
	    fgrep ' ${${host}_${dir}_${ipv}}.7 '  # ${host}_${dir}_${ipv}
d550 4
a553 3
	ssh ${IPS_SSH} route -n get -inet ${SRC_TRANSP_IPV4} |\
	    egrep -q 'flags: .*(CLONING|CLONED)' # SRC_TRANSP_IPV4
	ssh ${IPS_SSH} route -n get -inet6 ${SRC_TRANSP_IPV6} |\
d555 2
a556 1
	    # SRC_TRANSP_IPV6 SRC_OUT_IPV6
d568 1
a568 1
.for host dir in IPS IN SRC OUT SRC TUNNEL
d574 8
a581 2
.for host dir in ECO TUNNEL4 ECO TUNNEL6
	ssh ${RT_SSH} route -n get -${inet} ${${host}_${dir}_${ipv}} |\
d583 2
a584 1
	    # ${host}_${dir}_${ipv} ECO_IN_${ipv}
d591 1
a591 1
.for host dir in ECO IN ECO TUNNEL4 ECO TUNNEL6
d598 1
a598 1
.for host dir in RT IN IPS OUT IPS IN SRC OUT SRC TUNNEL
d603 13
a615 1
.for host dir in ECO TUNNEL4 ECO TUNNEL6
d617 3
a619 1
	    fgrep ' ${${host}_${dir}_${ipv}}.7 '  # ${host}_${dir}_${ipv}
@


1.3
log
@Encrypt UDP and TCP packets in test.  Use a sane transport config.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.2 2017/02/06 22:58:51 bluhm Exp $
d41 1
a41 1
SRC_OUT_IPV6 ?=	${PREFIX_IPV6}0::17
d43 1
a43 1
SRC_TRANSP_IPV6 ?=	${PREFIX_IPV6}4::17
d45 1
a45 1
SRC_TUNNEL_IPV6 ?=	${PREFIX_IPV6}8::17
d48 1
a48 1
IPS_IN_IPV6 ?=	${PREFIX_IPV6}0::70
d50 1
a50 1
IPS_OUT_IPV6 ?=	${PREFIX_IPV6}1::70
d52 1
a52 1
IPS_TRANSP_IPV6 ?=	${PREFIX_IPV6}5::70
d54 1
a54 1
IPS_TUNNEL4_IPV6 ?=	${PREFIX_IPV6}c::70
d56 1
a56 1
IPS_TUNNEL6_IPV6 ?=	${PREFIX_IPV6}d::70
d59 1
a59 1
RT_IN_IPV6 ?=	${PREFIX_IPV6}1::71
d61 1
a61 1
RT_OUT_IPV6 ?=	${PREFIX_IPV6}2::71
d64 1
a64 1
ECO_IN_IPV6 ?=	${PREFIX_IPV6}2::72
d66 1
a66 1
ECO_TUNNEL4_IPV6 ?=	${PREFIX_IPV6}e::72
d68 1
a68 1
ECO_TUNNEL6_IPV6 ?=	${PREFIX_IPV6}f::72
d369 1
a369 1
	ssh ${${host}_SSH} ${SUDO} "umask 027;\
d373 1
a373 1
	ssh ${${host}_SSH} ${SUDO} "mv /etc/hostname.${${host}_${dir}_IF}.tmp\
@


1.2
log
@Ping via IPsec must increment ESP input and output counter by one.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.1.1.1 2017/02/06 21:54:05 bluhm Exp $
d75 1
d148 5
d172 23
d429 5
d479 5
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#	$OpenBSD$
d156 2
d159 4
d170 1
a170 1
CLEANFILES +=		addr.py *.pyc *.log stamp-* */hostname.*
@


1.1.1.1
log
@Test combinations of IPsec tunnel and transport mode on several
machines.  For now only ESP encrypted IPv4 and IPv6 ICMP ping packets
are generated.
@
text
@@
