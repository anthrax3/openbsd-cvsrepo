head	1.2;
access;
symbols
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.8
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2;
locks; strict;
comment	@ * @;


1.2
date	2015.12.02.20.45.00;	author mpi;	state Exp;
branches;
next	1.1;
commitid	4kCnMWdG3OHwNaOY;

1.1
date	2015.10.27.16.05.54;	author vgross;	state Exp;
branches;
next	;
commitid	H4e4TJIG3keEGchR;


desc
@@


1.2
log
@KNF and use ${SUDO} when needed.

ok vgross@@
@
text
@/* $OpenBSD: broadcast_bind.c,v 1.1 2015/10/27 16:05:54 vgross Exp $ */

/*
 * Copyright (c) 2015 Vincent Gross <vgross@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

#include <arpa/inet.h>

#include <sys/socket.h>

#include <netinet/in.h>


int
test_bind(char *paddr, struct in_addr *addr, u_int16_t port, int type,
    int expected_errno)
{
	int s, rc;
	struct sockaddr_in sin;

	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_len = sizeof(sin);
	sin.sin_port = htons(port);
	memcpy(&sin.sin_addr, addr, sizeof(*addr));

	s = socket(PF_INET, type, 0);
	if (s < 0) {
		warn("socket(PF_INET, %d, 0)", type);
		return (1);
	}

	rc = bind(s, (struct sockaddr *)&sin, sin.sin_len);
	if ((rc == 0 && expected_errno == 0) ||
	    (rc != 0 && expected_errno == errno)) {
		close(s);
		return (0);
	}

	warn("bind(%s,%d) (type %d) expected %d, got %d", paddr, port, type,
	    expected_errno, errno);
	close(s);

	return (1);
}

int
main(int argc, char *argv[])
{
	int rc;
	struct in_addr uc_addr, err_addr, bc_addr;
	int port = 30000;

	if (argc != 4)
		errx(1, "needs 2 arguments: <unicast> <error> <broadcast>");

	rc = inet_pton(AF_INET, argv[1], &uc_addr);
	if (rc != 1) {
		if (rc)
			err(1, "inet_pton(unicast)");
		else
			errx(1, "inet_pton(unicast): error parsing %s",
			    argv[1]);
	}
	rc = inet_pton(AF_INET, argv[2], &err_addr);
	if (rc != 1) {
		if (rc)
			err(1, "inet_pton(error)");
		else
			errx(1, "inet_pton(error): error parsing %s", argv[2]);
	}
	rc = inet_pton(AF_INET, argv[3], &bc_addr);
	if (rc != 1) {
		if (rc)
			err(1, "inet_pton(broadcast)");
		else
			errx(1, "inet_pton(broadcast): error parsing %s",
			    argv[3]);
	}

	rc = 0;
	rc |= test_bind(argv[1], &uc_addr, port, SOCK_STREAM, 0);
	rc |= test_bind(argv[2], &err_addr, port, SOCK_STREAM, EADDRNOTAVAIL);
	rc |= test_bind(argv[3], &bc_addr, port, SOCK_STREAM, EADDRNOTAVAIL);

	rc |= test_bind(argv[2], &err_addr, port, SOCK_STREAM, EADDRNOTAVAIL);
	rc |= test_bind(argv[3], &bc_addr, port, SOCK_DGRAM, 0);

	return (rc);
}
@


1.1
log
@add regress test on bind(2)ing with broadcast and inexistant addresses
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d33 3
a35 4
int test_result = EXIT_SUCCESS;

void
test_bind(char *paddr, struct in_addr *addr, u_int16_t port, int type, int expected_errno)
d40 1
a40 1
	bzero(&sin, sizeof(sin));
d49 1
a49 2
		test_result = EXIT_FAILURE;
		return;
d56 1
a56 1
		return;
d58 3
a60 3
		
	warn("bind(%s,%d) (type %d) expected %d, got %d", paddr, port, type, expected_errno, errno);
	test_result = EXIT_FAILURE;
d62 2
a63 1
	return;
d74 1
a74 1
		errx(EXIT_FAILURE, "needs 2 arguments: <unicast> <error> <broadcast>");
d79 1
a79 1
			err(EXIT_FAILURE, "inet_pton(unicast)");
d81 1
a81 1
			errx(EXIT_FAILURE, "inet_pton(unicast): error parsing %s",
d87 1
a87 1
			err(EXIT_FAILURE, "inet_pton(error)");
d89 1
a89 2
			errx(EXIT_FAILURE, "inet_pton(error): error parsing %s",
			    argv[2]);
d94 1
a94 1
			err(EXIT_FAILURE, "inet_pton(broadcast)");
d96 1
a96 1
			errx(EXIT_FAILURE, "inet_pton(broadcast): error parsing %s",
d100 4
a103 5
	test_result = EXIT_SUCCESS;

	test_bind(argv[1], &uc_addr, port, SOCK_STREAM, 0);
	test_bind(argv[2], &err_addr, port, SOCK_STREAM, EADDRNOTAVAIL);
	test_bind(argv[3], &bc_addr, port, SOCK_STREAM, EADDRNOTAVAIL);
d105 2
a106 3
	test_bind(argv[1], &uc_addr, port, SOCK_DGRAM, 0);
	test_bind(argv[2], &err_addr, port, SOCK_STREAM, EADDRNOTAVAIL);
	test_bind(argv[3], &bc_addr, port, SOCK_DGRAM, 0);
d108 1
a108 1
	return test_result;
@

