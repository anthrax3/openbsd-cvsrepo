head	1.10;
access;
symbols
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.6
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.46
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.42
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.40
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.38
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.36
	OPENBSD_5_0:1.8.0.34
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.32
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.30
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.26
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.28
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.24
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.22
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.20
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.18
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.16
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.14
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.03.03.12.41.29;	author naddy;	state dead;
branches;
next	1.9;
commitid	Ykztt9UU7jxBEqeD;

1.9
date	2014.04.18.14.38.21;	author guenther;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.02.23.52.17;	author david;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.02.01.24.36;	author david;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.31.21.48.07;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.11.23.26.35;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.11.15.51.59;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.02.05.51;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.01.15.23.41.08;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.35;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Remove option USER_LDT and everything depending on it.
Remove machdep.userldt sysctl.
Remove i386_[gs]et_ldt syscall stub from libi386.
Remove i386_[gs]et_ldt regression test.

ok mlarkin@@ millert@@ guenther@@
@
text
@/*	$OpenBSD: testldt.c,v 1.9 2014/04/18 14:38:21 guenther Exp $	*/
/*	$NetBSD: testldt.c,v 1.4 1995/04/20 22:42:38 cgd Exp $	*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <machine/segments.h>

extern int i386_get_ldt(int, union descriptor *, int);
extern int i386_set_ldt(int, union descriptor *, int);

int verbose = 0;
struct sigaction segv_act;

static inline void
set_fs(unsigned long val)
{
	__asm__ volatile("mov %0,%%fs"::"r" ((unsigned short) val));
}

static inline unsigned char
get_fs_byte(const char * addr)
{
	unsigned register char _v;

	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
	return _v;
}

static inline unsigned short
get_cs(void)
{
	unsigned register short _v;

	__asm__ ("movw %%cs,%0"::"r" ((unsigned short) _v));
	return _v;
}

static int
check_desc(unsigned int desc)
{
	desc = LSEL(desc, SEL_UPL);
	set_fs(desc);
	return(get_fs_byte((char *) 0));
}

static void
gated_call(void)
{
	printf("Called from call gate...");
	__asm__ volatile("popl %ebp");
	__asm__ volatile(".byte 0xcb");
}

static struct segment_descriptor *
make_sd(unsigned base, unsigned limit, int type, int dpl, int seg32, int inpgs)
{
	static struct segment_descriptor d;

	d.sd_lolimit = limit & 0x0000ffff;
	d.sd_lobase  = base & 0x00ffffff;
	d.sd_type    = type & 0x01f;
	d.sd_dpl     = dpl & 0x3;
	d.sd_p	     = 1;
	d.sd_hilimit = (limit & 0x00ff0000) >> 16;
	d.sd_xx	     = 0;
	d.sd_def32   = seg32?1:0;
	d.sd_gran    = inpgs?1:0;
	d.sd_hibase  = (base & 0xff000000) >> 24;

	return (&d);
}

static struct gate_descriptor *
make_gd(unsigned offset, unsigned int sel, unsigned stkcpy, int type, int dpl)
{
	static struct gate_descriptor d;

	d.gd_looffset = offset & 0x0000ffff;
	d.gd_selector = sel & 0xffff;
	d.gd_stkcpy   = stkcpy & 0x1ff;
	d.gd_type     = type & 0x1ff;
	d.gd_dpl      = dpl & 0x3;
	d.gd_p	      = 1;
	d.gd_hioffset = (offset & 0xffff0000) >> 16;

	return(&d);
}

static void
print_ldt(union descriptor *dp)
{
	unsigned long base_addr, limit, offset, selector, stack_copy;
	int type, dpl, i;
	unsigned long *lp = (unsigned long *)dp;
    
	/* First 32 bits of descriptor */
	selector = base_addr = (*lp >> 16) & 0x0000FFFF;
	offset = limit = *lp & 0x0000FFFF;
	lp++;
	
	/* First 32 bits of descriptor */
	base_addr |= (*lp & 0xFF000000) | ((*lp << 16) & 0x00FF0000);
	limit |= (*lp & 0x000F0000);
	type = dp->sd.sd_type;
	dpl = dp->sd.sd_dpl;
	stack_copy = dp->gd.gd_stkcpy;
	offset |= (*lp >> 16) & 0x0000FFFF;
    
	if (type == SDT_SYS386CGT || type == SDT_SYS286CGT)
		printf("LDT: Gate Off %08.8x, Sel   %05.5x, Stkcpy %d DPL %d, Type %d\n",
			offset, selector, stack_copy, dpl, type);
	else
		printf("LDT: Seg Base %08.8x, Limit %05.5x, DPL %d, Type %d\n",
			base_addr, limit, dpl, type);
	printf("	  ");
	if (*lp & 0x100)
		printf("Accessed, ");
	if (*lp & 8000)
		printf("Present, ");
	if (type != SDT_SYS386CGT && type != SDT_SYS286CGT) {
		if (*lp & 0x100000)
			printf("User, ");
		if (*lp & 0x200000)
			printf("X, ");
		if (*lp & 0x400000)
			printf("32, ");
		else
			printf("16, ");
		if (*lp & 0x800000)
			printf("page limit, ");
		else
			printf("byte limit, ");
	}
	printf("\n");
	printf("	  %08.8x %08.8x\n", *(lp), *(lp-1));
}

static void busfault(int signal, int code, struct sigcontext *sc)
{
	fprintf(stderr, "\nbus fault - investigate.\n");
	_exit(1);
}

static void usage(int status)
{
	fprintf(stderr, "Usage: testldt [-v]\n");
        exit(status);
}

#define MAX_USER_LDT 1024
main(int argc, char *argv[])
{
	union descriptor ldt[MAX_USER_LDT];
	int num, n, ch;
	unsigned int cs = get_cs();
	char *data;
	struct segment_descriptor *sd;
	struct gate_descriptor *gd;
	
	segv_act.sa_handler = (sig_t) busfault;
	if (sigaction(SIGBUS, &segv_act, NULL) < 0) {
		perror("sigaction");
		exit(1);
	}

	while ((ch = getopt(argc, argv, "v")) != -1) {
		switch (ch) {
		case 'v':
		    verbose++;
		    break;
		default:
		    usage(1);
		    break;
		}
	}

	printf("Testing i386_get_ldt...\n");
	if ((num = i386_get_ldt(0, ldt, MAX_USER_LDT)) < 0) {
		perror("get_ldt");
		exit(2);
	}
	if (num == 0) {
	    fprintf(stderr, "ERROR: i386_get_ldt() return 0 default LDT entries.\n");
	    exit(1);
	}

	if (verbose) {
	    printf("Got %d (default) LDTs\n", num);
	    for (n=0; n < num; n++) {
		printf("Entry %d: ", n);
		print_ldt(&ldt[n]);
	    }
	}
	
	/*
	 * mmap a data area and assign an LDT to it
	 */
	printf("Testing i386_set_ldt...\n");
	data = (void *) mmap( (char *)0x005f0000, 0x0fff,
			     PROT_EXEC | PROT_READ | PROT_WRITE,
			     MAP_FIXED | MAP_PRIVATE | MAP_ANON, -1, 0);
	if (data == MAP_FAILED) {
		perror("mmap");
		exit(1);
	}
	if (verbose) printf("data address: %8.8x\n", data);

	*data = 0x97;

	/* Get the next free LDT and set it to the allocated data. */
	sd = make_sd((unsigned)data, 4096, SDT_MEMRW, SEL_UPL, 0, 0);
	if ((num = i386_set_ldt(6, (union descriptor *)sd, 1)) < 0) {
		perror("set_ldt");
		exit(1);
	}
	if (verbose) printf("setldt returned: %d\n", num);
	if ((n = i386_get_ldt(num, ldt, 1)) < 0) {
		perror("get_ldt");
		exit(1);
	}
	if (verbose) {
		printf("Entry %d: ", num);
		print_ldt(&ldt[0]);
	}

	if (verbose) printf("Checking desc (should be 0x97): 0x%x\n", check_desc(num));
	if (check_desc(num) != 0x97) {
		fprintf(stderr, "ERROR: descriptor check failed: (should be 0x97): 0x%x\n", check_desc(num));
		exit(1);
	}
	
	/*
	 * Test a Call Gate
	 */
	printf("Testing Call Gate...");
	gd = make_gd((unsigned)gated_call, cs, 0, SDT_SYS386CGT, SEL_UPL);
	if ((num = i386_set_ldt(5, (union descriptor *)gd, 1)) < 0) {
		perror("set_ldt: call gate");
		exit(1);
	}
	if (verbose) printf("setldt returned: %d\n", num);
	if (verbose) printf("Call gate sel = 0x%x\n", LSEL(num, SEL_UPL));
	if ((n = i386_get_ldt(num, ldt, 1)) < 0) {
		perror("get_ldt");
		exit(1);
	}
	if (verbose) printf("Entry %d: ", num);
	if (verbose) print_ldt(&ldt[0]);

#if 0
	err = setldt(5,
		     gated_call,	/* Offset */
		     0x0001,		/* This selector is for the executable segment descriptor.  It
					   is the standard linux text descriptor. */
		     0x00008c00);	/* Descriptor flags (you can't set all, the OS protects some) */
	printf("setldt returned: %d\n", err);
#endif

	__asm__ volatile(".byte 0x9a"); /* This is a call to a call gate. */
	__asm__ volatile(".byte 0x00"); /* Value is ignored in a call gate but can be used. */
	__asm__ volatile(".byte 0x00"); /* by the called procedure. */
	__asm__ volatile(".byte 0x00");
	__asm__ volatile(".byte 0x00");
	__asm__ volatile(".byte 0x2f"); /* Selector 0x002f.	 This is index = 5 (the call gate), */
	__asm__ volatile(".byte 0x00"); /* and a requestor priveledge level of 3. */

	printf("Gated call returned\n");
	exit (0);
}
@


1.9
log
@It's been a quarter century: we can assume volatile is present with that name.
@
text
@d1 1
a1 1
/*	$OpenBSD: testldt.c,v 1.8 2003/09/02 23:52:17 david Exp $	*/
@


1.8
log
@add missing includes
ok deraadt@@ tedu@@ dhartmei@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: testldt.c,v 1.7 2003/08/02 01:24:36 david Exp $	*/
d21 1
a21 1
	__asm__ __volatile__("mov %0,%%fs"::"r" ((unsigned short) val));
d54 2
a55 2
	__asm__ __volatile__("popl %ebp");
	__asm__ __volatile__(".byte 0xcb");
d263 7
a269 7
	__asm__ __volatile__(".byte 0x9a"); /* This is a call to a call gate. */
	__asm__ __volatile__(".byte 0x00"); /* Value is ignored in a call gate but can be used. */
	__asm__ __volatile__(".byte 0x00"); /* by the called procedure. */
	__asm__ __volatile__(".byte 0x00");
	__asm__ __volatile__(".byte 0x00");
	__asm__ __volatile__(".byte 0x2f"); /* Selector 0x002f.	 This is index = 5 (the call gate), */
	__asm__ __volatile__(".byte 0x00"); /* and a requestor priveledge level of 3. */
@


1.7
log
@add missing includes
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: testldt.c,v 1.6 2003/07/31 21:48:07 deraadt Exp $	*/
d5 1
@


1.6
log
@various cleanups; david says results are same
@
text
@d1 1
a1 1
/*	$OpenBSD: testldt.c,v 1.5 2001/11/11 23:26:35 deraadt Exp $	*/
d6 1
@


1.5
log
@signal race fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: testldt.c,v 1.4 2001/05/11 15:51:59 art Exp $	*/
d16 2
a17 1
inline void set_fs(unsigned long val)
d22 2
a23 1
inline unsigned char get_fs_byte(const char * addr)
d31 2
a32 1
inline unsigned short get_cs(void)
d40 1
a40 1
int
d48 2
a49 2
void
gated_call()
d56 1
a56 1
struct segment_descriptor *
d75 1
a75 1
struct gate_descriptor *
d91 1
a91 1
void
@


1.4
log
@MAP_FAILED, not NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: testldt.c,v 1.3 2001/01/29 02:05:51 niklas Exp $	*/
d140 1
a140 1
	exit(1);
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: testldt.c,v 1.4 1995/04/20 22:42:38 cgd Exp $	*/
d201 1
a201 1
	if (data == NULL) {
@


1.2
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d164 1
a164 1
	while ((ch = getopt(argc, argv, "v")) != EOF) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
