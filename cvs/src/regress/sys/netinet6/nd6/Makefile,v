head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.4
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.6.0.4
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.3.0.4
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.2.0.10
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.8
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.6
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.1.0.8
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.6
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.4
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.2;
locks; strict;
comment	@# @;


1.7
date	2017.07.07.23.15.27;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	o44bwTTe61BAwrkn;

1.6
date	2017.03.01.00.05.21;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	5O6VrHQNBYYOu82K;

1.5
date	2016.10.19.14.31.19;	author tb;	state Exp;
branches;
next	1.4;
commitid	r0ZXVh0JShv1yn7K;

1.4
date	2016.09.02.21.30.34;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	sbZCO4zszQKrda5x;

1.3
date	2015.11.05.12.56.12;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	KcjOzzXe713jREej;

1.2
date	2013.10.31.01.24.06;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2012.01.31.00.14.02;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Remove useless make depend targets.
@
text
@#	$OpenBSD: Makefile,v 1.6 2017/03/01 00:05:21 bluhm Exp $

# The following ports must be installed:
#
# python-2.7          interpreted object-oriented programming language
# py-libdnet          python interface to libdnet
# scapy               powerful interactive packet manipulation in python

.if ! (make(clean) || make(cleandir) || make(obj))
# Check wether all required python packages are installed.  If some
# are missing print a warning and skip the tests, but do not fail.
PYTHON_IMPORT !!= python2.7 -c 'from scapy.all import *' 2>&1 || true
.endif

.if ! empty(PYTHON_IMPORT)
regress:
	@@echo '${PYTHON_IMPORT}'
	@@echo Install python and the scapy module for additional tests.
	@@echo SKIPPED
.endif

# This test needs a manual setup of two machines
# Set up machines: LOCAL REMOTE
# LOCAL is the machine where this makefile is running.
# REMOTE is running OpenBSD with pf to test the neighbor discovery states.

# Configure addresses on the machines.
# Adapt interface and addresse variables to your local setup.

LOCAL_IF ?=	em1
LOCAL_MAC ?=	00:1b:21:0e:6e:8e
REMOTE_MAC ?=	00:04:23:b0:68:8e

LOCAL_ADDR6 ?=	fdd7:e83e:66bc:81::21
REMOTE_ADDR6 ?=	fdd7:e83e:66bc:81::22

REMOTE_SSH ?=

# pf rules on REMOTE should look like this:
#
# block log
# pass inet6 proto icmp6 icmp6-type echoreq keep state
# pass inet6 proto icmp6 icmp6-type neighbrsol keep state
# pass inet6 proto icmp6 icmp6-type neighbradv keep state

# RFC 4861 7. describes the following test cases for ND:
#
# Duplicate Address Detection
# - request  NS from unspecified address to target solicitated-node multicast
# - response NA from interface address   to all-nodes multicast
#
# Address Resolution
# - request  NS from interface address   to target solicitated-node multicast
# - response NA from interface address   to source of NS
#
# Unsolicited Neighbor Advertisements
# - request  NA from interface address   to all-nodes multicast
#
# Neighbor Unreachability Detection
# - request  NS from interface address   to target unicast
# - response NA from interface address   to source of NS

.if empty (LOCAL_IF) || empty (LOCAL_MAC) || empty (REMOTE_MAC) || \
    empty (LOCAL_ADDR6) || empty (REMOTE_ADDR6)
regress:
	@@echo This tests needs a remote machine to operate on.
	@@echo LOCAL_IF LOCAL_MAC REMOTE_MAC LOCAL_ADDR6 REMOTE_ADDR6
	@@echo Fill out these variables for additional tests.
	@@echo SKIPPED
.endif

# Create python include file containing the addresses.
addr.py: Makefile
	rm -f $@@ $@@.tmp
	echo 'LOCAL_IF = "${LOCAL_IF}"' >>$@@.tmp
	echo 'LOCAL_MAC = "${LOCAL_MAC}"' >>$@@.tmp
	echo 'REMOTE_MAC = "${REMOTE_MAC}"' >>$@@.tmp
.for var in LOCAL_ADDR REMOTE_ADDR
	echo '${var} = "${${var}}"' >>$@@.tmp
	echo '${var}6 = "${${var}6}"' >>$@@.tmp
.endfor
	mv $@@.tmp $@@

# Set variables so that make runs with and without obj directory.
# Only do that if necessary to keep visible output short.
.if ${.CURDIR} == ${.OBJDIR}
PYTHON =	python2.7 ./
.else
PYTHON =	PYTHONPATH=${.OBJDIR} python2.7 ${.CURDIR}/
.endif

# Clear neighbor cache and ping all addresses.  This ensures that
# the ip addresses are configured and all routing table are set up
# to allow bidirectional packet flow.
run-regress-ping6:
	@@echo '\n======== $@@ ========'
	${SUDO} ndp -c
.for ip in LOCAL_ADDR REMOTE_ADDR
	@@echo Check ping6 ${ip}6:
	ping6 -n -c 1 ${${ip}6}
.endfor

ND6_SCRIPTS !!=		cd ${.CURDIR} && ls -1 nd6*.py

.for s in ${ND6_SCRIPTS}
run-regress-${s}: addr.py
	@@echo '\n======== $@@ ========'
	${SUDO} ${PYTHON}${s}
.endfor

REGRESS_TARGETS =	run-regress-ping6 ${ND6_SCRIPTS:S/^/run-regress-/}

CLEANFILES +=		addr.py *.pyc *.log

.PHONY: check-setup check-setup-local check-setup-remote

# Check wether the address, route and remote setup is correct
check-setup: check-setup-local check-setup-remote

check-setup-local:
	@@echo '\n======== $@@ ========'
	ping6 -n -c 1 ${LOCAL_ADDR6}  # LOCAL_ADDR6
	route -n get -inet6 ${LOCAL_ADDR6} |\
	    grep -q 'flags: .*LOCAL'  # LOCAL_ADDR6
	ping6 -n -c 1 ${REMOTE_ADDR6}  # REMOTE_ADDR6
	route -n get -inet6 ${REMOTE_ADDR6} |\
	    grep -q 'interface: ${LOCAL_IF}$$'  # REMOTE_ADDR6 LOCAL_IF
	ndp -n ${REMOTE_ADDR6} |\
	    grep -q ' ${REMOTE_MAC} '  # REMOTE_ADDR6 REMOTE_MAC

check-setup-remote:
	@@echo '\n======== $@@ ========'
	ssh ${REMOTE_SSH} ping6 -n -c 1 ${REMOTE_ADDR6}  # REMOTE_ADDR6
	ssh ${REMOTE_SSH} route -n get -inet6 ${REMOTE_ADDR6} |\
	    grep -q 'flags: .*LOCAL'  # REMOTE_ADDR6
	ssh ${REMOTE_SSH} ping6 -n -c 1 ${LOCAL_ADDR6}  # LOCAL_ADDR6
	ssh ${REMOTE_SSH} ndp -n ${LOCAL_ADDR6} |\
	    grep -q ' ${LOCAL_MAC} '  # LOCAL_ADDR6 LOCAL_MAC

.include <bsd.regress.mk>
@


1.6
log
@Use consistent address schema with local and remote machine.  Fill
variables with example IPs from my daily test run.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.5 2016/10/19 14:31:19 tb Exp $
a70 2

depend: addr.py
@


1.5
log
@The clean:, cleandir:, and obj: targets of src/Makefile descend into
regress/ and run python to set the IMPORT_PYTHON variable in several
test Makefiles. This results in W^X violations during 'make build'.
Avoid doing that.

ok bluhm
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.4 2016/09/02 21:30:34 bluhm Exp $
d12 1
a12 1
PYTHON_IMPORT != python2.7 -c 'from scapy.all import *' 2>&1 || true
d14 1
d18 1
a18 1
	@@echo install python and the scapy module for additional tests
d23 3
a25 8
# Set up machines: SRC DST
# SRC is the machine where this makefile is running.
# DST is running OpenBSD with pf to test the neighbor discovery states.
#
# +---+   1   +---+
# |SRC| ----> |DST|
# +---+       +---+
#     out    in
d27 1
a27 1
# Configure Addresses on the machines.
a28 4
#
SRC_IF ?=
SRC_MAC ?=
DST_MAC ?=
d30 8
a37 2
SRC_OUT6 ?=
DST_IN6 ?=
d39 1
a39 1
# pf rules on DST should look like this:
d63 2
a64 2
.if empty (SRC_IF) || empty (SRC_MAC) || empty (DST_MAC) || \
    empty (SRC_OUT6) || empty (DST_IN6)
d66 3
a68 3
	@@echo this tests needs a remote machine to operate on
	@@echo SRC_IF SRC_MAC DST_MAC SRC_OUT6 DST_IN6 are empty
	@@echo fill out these variables for additional tests
d77 4
a80 4
	echo 'SRC_IF = "${SRC_IF}"' >>$@@.tmp
	echo 'SRC_MAC = "${SRC_MAC}"' >>$@@.tmp
	echo 'DST_MAC = "${DST_MAC}"' >>$@@.tmp
.for var in SRC_OUT DST_IN
a96 1
TARGETS +=	ping6
d100 1
a100 1
.for ip in SRC_OUT DST_IN
d105 4
a108 3
# Send hand-crafted duplicate address detection neighbor solicitation packet
TARGETS +=	nd6_dad
run-regress-nd6_dad: addr.py
d110 4
a113 2
	@@echo Check duplicate address detection
	${SUDO} ${PYTHON}nd6_dad.py
d115 6
a120 6
# Send hand-crafted address resolution neighbor solicitation packet
TARGETS +=	nd6_ar
run-regress-nd6_ar: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check address resolution
	${SUDO} ${PYTHON}nd6_ar.py
d122 1
a122 3
# Send hand-crafted unsolicited neighbor advertisement packet
TARGETS +=	nd6_una
run-regress-nd6_una: addr.py
d124 8
a131 2
	@@echo Check unsolicited neighbor advertisement
	${SUDO} ${PYTHON}nd6_una.py
d133 1
a133 3
# Send hand-crafted neighbor unreachability detection solicitation packet
TARGETS +=	nd6_nud
run-regress-nd6_nud: addr.py
d135 6
a140 6
	@@echo Check neighbor unreachability detection
	${SUDO} ${PYTHON}nd6_nud.py

REGRESS_TARGETS =	${TARGETS:S/^/run-regress-/}

CLEANFILES +=		addr.py *.pyc *.log
@


1.4
log
@Print SKIPPED if a regress test cannot be executed for some reason.
This allows to identify such tests by looking at their output.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.3 2015/11/05 12:56:12 bluhm Exp $
d9 1
d13 1
@


1.3
log
@Replace a sudo with ${SUDO}.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.2 2013/10/31 01:24:06 bluhm Exp $
d16 1
d69 1
@


1.2
log
@Do not fail the regression tests if python or the scapy package is
not installed.  Print a warning, explain the problem and skip the
test in this case.  Also skip the test if the environment has not
been configured for the remote test target machine.  Fix the Makefile
to run the tests with or without an obj directory.  Finally link
the netinet6 regression tests into the build.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.1 2012/01/31 00:14:02 bluhm Exp $
d98 1
a98 1
	sudo ndp -c
@


1.1
log
@Add test suite for IPv6 neighbor discovery protocol.  Send all kind
of solicitations to remote host and check responses.  This can be
used to test both pf neighbor discovery states and the IPv6 stack.
@
text
@d1 1
a1 1
#	$OpenBSD$
d9 9
d31 3
a33 3
SRC_IF =	tun0
SRC_MAC =	fe:e1:ba:d1:56:1f
DST_MAC =	52:54:00:12:34:50
d35 2
a36 2
SRC_OUT6 =	fdd7:e83e:66bc:211:fce1:baff:fed1:561f
DST_IN6 =	fdd7:e83e:66bc:211:5054:ff:fe12:3450
d62 8
d84 8
d109 1
a109 1
	${SUDO} python2.7 nd6_dad.py
d116 1
a116 1
	${SUDO} python2.7 nd6_ar.py
d123 1
a123 1
	${SUDO} python2.7 nd6_una.py
d130 1
a130 1
	${SUDO} python2.7 nd6_nud.py
@

