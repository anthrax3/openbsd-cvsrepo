head	1.20;
access;
symbols
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.11.0.6
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.10.0.6
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2;
locks; strict;
comment	@# @;


1.20
date	2017.07.07.23.15.27;	author bluhm;	state Exp;
branches;
next	1.19;
commitid	o44bwTTe61BAwrkn;

1.19
date	2017.05.31.09.25.17;	author bluhm;	state Exp;
branches;
next	1.18;
commitid	qFwDSzubZQp6VYxy;

1.18
date	2017.03.01.00.58.22;	author bluhm;	state Exp;
branches;
next	1.17;
commitid	79BTddPZSnsqarDG;

1.17
date	2017.03.01.00.05.21;	author bluhm;	state Exp;
branches;
next	1.16;
commitid	5O6VrHQNBYYOu82K;

1.16
date	2017.02.28.16.08.10;	author bluhm;	state Exp;
branches;
next	1.15;
commitid	VVZrSL7BVRU9evf8;

1.15
date	2016.11.17.17.27.05;	author bluhm;	state Exp;
branches;
next	1.14;
commitid	edSHo2pc3VKAdOlz;

1.14
date	2016.11.17.13.24.32;	author bluhm;	state Exp;
branches;
next	1.13;
commitid	aycNH5Srpcd1UJgx;

1.13
date	2016.10.19.14.31.19;	author tb;	state Exp;
branches;
next	1.12;
commitid	r0ZXVh0JShv1yn7K;

1.12
date	2016.09.02.21.30.34;	author bluhm;	state Exp;
branches;
next	1.11;
commitid	sbZCO4zszQKrda5x;

1.11
date	2015.04.15.21.29.15;	author bluhm;	state Exp;
branches;
next	1.10;
commitid	NtrzJZn7KuD1llpY;

1.10
date	2014.07.11.18.25.50;	author bluhm;	state Exp;
branches;
next	1.9;
commitid	k6I89Y30DnVfNl4F;

1.9
date	2013.10.31.01.24.06;	author bluhm;	state Exp;
branches;
next	1.8;

1.8
date	2013.07.23.22.38.45;	author bluhm;	state Exp;
branches;
next	1.7;

1.7
date	2013.07.23.22.15.04;	author bluhm;	state Exp;
branches;
next	1.6;

1.6
date	2012.02.08.00.35.31;	author bluhm;	state Exp;
branches;
next	1.5;

1.5
date	2012.01.27.17.28.00;	author bluhm;	state Exp;
branches;
next	1.4;

1.4
date	2012.01.24.19.12.34;	author bluhm;	state Exp;
branches;
next	1.3;

1.3
date	2012.01.11.21.37.44;	author bluhm;	state Exp;
branches;
next	1.2;

1.2
date	2012.01.10.17.21.52;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2012.01.06.21.52.15;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Remove useless make depend targets.
@
text
@#	$OpenBSD: Makefile,v 1.19 2017/05/31 09:25:17 bluhm Exp $

# The following ports must be installed:
#
# python-2.7          interpreted object-oriented programming language
# py-libdnet          python interface to libdnet
# scapy               powerful interactive packet manipulation in python

.if ! (make(clean) || make(cleandir) || make(obj))
# Check wether all required python packages are installed.  If some
# are missing print a warning and skip the tests, but do not fail.
PYTHON_IMPORT !!= python2.7 -c 'from scapy.all import *' 2>&1 || true
.endif

.if ! empty(PYTHON_IMPORT)
.BEGIN:
	@@true
regress:
	@@echo '${PYTHON_IMPORT}'
	@@echo Install python and the scapy module for additional tests.
	@@echo SKIPPED
.endif

# This test needs a manual setup of two machines
# Set up machines: LOCAL REMOTE
# LOCAL is the machine where this makefile is running.
# REMOTE is running OpenBSD with or without pf to test fragment reassemly
# Enable echo udp6 in inetd.conf on REMOTE to test UDP fragments.
# REMOTE_SSH is used to login and enable or disable pf automatically.

# Configure addresses on the machines.
# Adapt interface and addresse variables to your local setup.

LOCAL_IF ?=	em1
LOCAL_MAC ?=	00:1b:21:0e:6e:8e
REMOTE_MAC ?=	00:04:23:b0:68:8e

LOCAL_ADDR ?=	fdd7:e83e:66bc:81::21
REMOTE_ADDR ?=	fdd7:e83e:66bc:81::22

REMOTE_SSH ?=

.if empty (LOCAL_IF) || empty (LOCAL_MAC) || empty (REMOTE_MAC) || \
    empty (LOCAL_ADDR6) || empty (REMOTE_ADDR6) || empty (REMOTE_SSH)
.BEGIN:
	@@true
regress:
	@@echo This tests needs a remote machine to operate on.
	@@echo LOCAL_IF LOCAL_MAC REMOTE_MAC LOCAL_ADDR6 REMOTE_ADDR6 REMOTE_SSH
	@@echo Fill out these variables for additional tests.
	@@echo SKIPPED
.endif

.MAIN: all

.if make (regress) || make (all)
.BEGIN: addr.py
	@@echo
	${SUDO} true
	ssh -t ${REMOTE_SSH} ${SUDO} true
	rm -f stamp-stack stamp-pf
.endif

# Create python include file containing the addresses.
addr.py: Makefile
	rm -f $@@ $@@.tmp
	echo 'LOCAL_IF = "${LOCAL_IF}"' >>$@@.tmp
	echo 'LOCAL_MAC = "${LOCAL_MAC}"' >>$@@.tmp
	echo 'REMOTE_MAC = "${REMOTE_MAC}"' >>$@@.tmp
.for var in LOCAL_ADDR REMOTE_ADDR
	echo '${var}6 = "${${var}6}"' >>$@@.tmp
.endfor
	mv $@@.tmp $@@

# Set variables so that make runs with and without obj directory.
# Only do that if necessary to keep visible output short.
.if ${.CURDIR} == ${.OBJDIR}
PYTHON =	python2.7 ./
.else
PYTHON =	PYTHONPATH=${.OBJDIR} python2.7 ${.CURDIR}/
.endif

stamp-stack:
	rm -f stamp-stack stamp-pf
	-ssh ${REMOTE_SSH} ${SUDO} pfctl -d
	ssh ${REMOTE_SSH} ${SUDO} pfctl -a regress -Fr
	date >$@@

stamp-pf: addr.py pf.conf
	rm -f stamp-stack stamp-pf
	cat addr.py ${.CURDIR}/pf.conf | pfctl -n -f -
	cat addr.py ${.CURDIR}/pf.conf | \
	    ssh ${IPS_SSH} ${SUDO} pfctl -a regress -f -
	-ssh ${REMOTE_SSH} ${SUDO} pfctl -e
	date >$@@

REGRESS_TARGETS =
FRAG6_SCRIPTS !!=	cd ${.CURDIR} && ls -1 frag6*.py

.for sp in stack pf

# Ping all addresses.  This ensures that the ip addresses are configured
# and all routing table are set up to allow bidirectional packet flow.
${sp}: run-regress-${sp}-ping6
run-regress-${sp}-ping6: stamp-${sp}
	@@echo '\n======== $@@ ========'
.for ip in LOCAL_ADDR REMOTE_ADDR
	@@echo Check ping6 ${ip}6:
	ping6 -n -c 1 ${${ip}6}
.endfor

# Ping all addresses again but with 5000 bytes payload.  These large
# packets get fragmented by LOCAL and must be handled by REMOTE.
${sp}: run-regress-${sp}-fragping6
run-regress-${sp}-fragping6: stamp-${sp}
	@@echo '\n======== $@@ ========'
.for ip in LOCAL_ADDR REMOTE_ADDR
	@@echo Check ping6 ${ip}6:
	ping6 -n -c 1 -s 5000 -m ${${ip}6}
.endfor

.for s in ${FRAG6_SCRIPTS}
${sp}: run-regress-${sp}-${s}
run-regress-${sp}-${s}: addr.py stamp-${sp}
	@@echo '\n======== $@@ ========'
	${SUDO} ${PYTHON}${s}
.endfor

REGRESS_TARGETS +=	run-regress-${sp}-ping6 run-regress-${sp}-fragping6 \
			${FRAG6_SCRIPTS:S/^/run-regress-${sp}-/}

.endfor

# After running the tests, turn on pf on remote machine.
# This is the expected default configuration.
REGRESS_TARGETS +=	stamp-pf

CLEANFILES +=		addr.py *.pyc *.log stamp-*

.PHONY: check-setup check-setup-local check-setup-remote

# Check wether the address, route and remote setup is correct
check-setup: check-setup-local check-setup-remote

check-setup-local:
	@@echo '\n======== $@@ ========'
	ping6 -n -c 1 ${LOCAL_ADDR6}  # LOCAL_ADDR6
	route -n get -inet6 ${LOCAL_ADDR6} |\
	    grep -q 'flags: .*LOCAL'  # LOCAL_ADDR6
	ping6 -n -c 1 ${REMOTE_ADDR6}  # REMOTE_ADDR6
	route -n get -inet6 ${REMOTE_ADDR6} |\
	    grep -q 'interface: ${LOCAL_IF}$$'  # REMOTE_ADDR6 LOCAL_IF
	ndp -n ${REMOTE_ADDR6} |\
	    grep -q ' ${REMOTE_MAC} '  # REMOTE_ADDR6 REMOTE_MAC

check-setup-remote:
	@@echo '\n======== $@@ ========'
	ssh ${REMOTE_SSH} ping6 -n -c 1 ${REMOTE_ADDR6}  # REMOTE_ADDR6
	ssh ${REMOTE_SSH} route -n get -inet6 ${REMOTE_ADDR6} |\
	    grep -q 'flags: .*LOCAL'  # REMOTE_ADDR6
	ssh ${REMOTE_SSH} ping6 -n -c 1 ${LOCAL_ADDR6}  # LOCAL_ADDR6
	ssh ${REMOTE_SSH} ndp -n ${LOCAL_ADDR6} |\
	    grep -q ' ${LOCAL_MAC} '  # LOCAL_ADDR6 LOCAL_MAC

.include <bsd.regress.mk>
@


1.19
log
@As pf blocks packets with IPv6 options header, the tests needs an
allow-opts rule.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.18 2017/03/01 00:58:22 bluhm Exp $
a62 2

depend: addr.py
@


1.18
log
@Avoid warnings from ssh -t, check remote SUDO at beginning.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.17 2017/03/01 00:05:21 bluhm Exp $
d91 1
a91 1
stamp-pf:
d93 3
a95 3
	echo 'pass proto tcp from port ssh no state\n'\
	    'pass proto tcp to port ssh no state'|\
	    ssh ${REMOTE_SSH} ${SUDO} pfctl -a regress -f -
@


1.17
log
@Use consistent address schema with local and remote machine.  Fill
variables with example IPs from my daily test run.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.16 2017/02/28 16:08:10 bluhm Exp $
d60 1
d87 2
a88 2
	-ssh -t ${REMOTE_SSH} ${SUDO} pfctl -d
	ssh -t ${REMOTE_SSH} ${SUDO} pfctl -a regress -Fr
d95 2
a96 2
	    ssh -t ${REMOTE_SSH} ${SUDO} pfctl -a regress -f -
	-ssh -t ${REMOTE_SSH} ${SUDO} pfctl -e
@


1.16
log
@Fragment reassembly code exists in pf and network stack.  To test
both, run the tests in a loop.  Disable and enable pf on the remote
machine automatically.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.15 2016/11/17 17:27:05 bluhm Exp $
d16 2
d25 5
a29 9
# Set up machines: SRC DST
# SRC is the machine where this makefile is running.
# DST is running OpenBSD with pf disabled to test the IPv6 stack.
# Enable echo udp6 in inetd.conf of DST to test UDP fragments.
#
# +---+   1   +---+
# |SRC| ----> |DST|
# +---+       +---+
#     out    in
d31 1
a31 1
# Configure Addresses on the machines.
a32 7
#
SRC_IF ?=
SRC_MAC ?=
DST_MAC ?=

SRC_OUT6 ?=
DST_IN6 ?=
d34 13
a46 2
.if empty (SRC_IF) || empty (SRC_MAC) || empty (DST_MAC) || \
    empty (SRC_OUT6) || empty (DST_IN6) || empty (REMOTE_SSH)
d49 1
a49 1
	@@echo SRC_IF SRC_MAC DST_MAC SRC_OUT6 DST_IN6 REMOTE_SSH are empty.
d68 4
a71 4
	echo 'SRC_IF = "${SRC_IF}"' >>$@@.tmp
	echo 'SRC_MAC = "${SRC_MAC}"' >>$@@.tmp
	echo 'DST_MAC = "${DST_MAC}"' >>$@@.tmp
.for var in SRC_OUT DST_IN
d108 1
a108 1
.for ip in SRC_OUT DST_IN
d114 1
a114 1
# packets get fragmented by SRC and must be handled by DST.
d118 1
a118 1
.for ip in SRC_OUT DST_IN
d140 25
@


1.15
log
@Put all make targets in a loop and print a little more what each
IPv6 fragment header test is doing.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.14 2016/11/17 13:24:32 bluhm Exp $
d12 1
a12 1
PYTHON_IMPORT != python2.7 -c 'from scapy.all import *' 2>&1 || true
d14 1
d18 1
a18 1
	@@echo install python and the scapy module for additional tests
d44 1
a44 1
    empty (SRC_OUT6) || empty (DST_IN6)
d46 3
a48 3
	@@echo this tests needs a remote machine to operate on
	@@echo SRC_IF SRC_MAC DST_MAC SRC_OUT6 DST_IN6 are empty
	@@echo fill out these variables for additional tests
d52 9
d82 19
d103 2
a104 1
run-regress-ping6:
d113 2
a114 1
run-regress-fragping6:
a120 2
FRAG6_SCRIPTS !=	cd ${.CURDIR} && ls -1 frag6*.py

d122 2
a123 1
run-regress-${s}: addr.py
d128 8
a135 2
REGRESS_TARGETS =	run-regress-ping6 run-regress-fragping6 \
			${FRAG6_SCRIPTS:S/^/run-regress-/}
d137 1
a137 1
CLEANFILES +=		addr.py *.pyc *.log
@


1.14
log
@Send fragment with Hop-by-Hop extension header after the fragment
header.  I must not be processed.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.13 2016/10/19 14:31:19 tb Exp $
a73 1
TARGETS +=	ping6
a82 1
TARGETS +=	fragping6
d90 1
a90 6
# Send hand-crafted fragmented packet
TARGETS +=	frag6
run-regress-frag6: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 reassembly
	${SUDO} ${PYTHON}frag6.py
d92 2
a93 3
# An hop by hop options extension header before the fragment header
TARGETS +=	frag6-ext
run-regress-frag6-ext: addr.py
d95 2
a96 121
	@@echo Check ping6 extension header reassembly
	${SUDO} ${PYTHON}frag6_ext.py

# An hop by hop options extension header after the fragment header
TARGETS +=	frag6-hop
run-regress-frag6-hop: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 not initial hop by hop extension header
	${SUDO} ${PYTHON}frag6_hop.py

# An destination options extension header after the fragment header
TARGETS +=	frag6-opt
run-regress-frag6-opt: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 destination option reassembly
	${SUDO} ${PYTHON}frag6_opt.py

# The ethernet frame has some padding that must be ignored by reassembly
TARGETS +=	frag6-padding
run-regress-frag6-padding: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 ethernet padding
	${SUDO} ${PYTHON}frag6_padding.py

# fragmented packet with head overlapping first fragment
TARGETS +=	frag6-overhead0
run-regress-frag6-overhead0: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 head overlapping first fragment
	${SUDO} ${PYTHON}frag6_overhead0.py

# fragmented packet with head overlapping second fragment
TARGETS +=	frag6-overhead
run-regress-frag6-overhead: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 head overlapping second fragment
	${SUDO} ${PYTHON}frag6_overhead.py

# fragmented packet with tail overlapping last fragment
TARGETS +=	frag6-overtail
run-regress-frag6-overtail: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 tail overlapping last fragment
	${SUDO} ${PYTHON}frag6_overtail.py

# fragmented packet with overlap, drop future fragments
TARGETS +=	frag6-overdrop
run-regress-frag6-overdrop: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 overlap drop future fragments
	${SUDO} ${PYTHON}frag6_overdrop.py

# fragmented packet with overlap, atomic fragment must be processed
TARGETS +=	frag6-overatomic
run-regress-frag6-overatomic: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 overlapping and atomic fragments
	${SUDO} ${PYTHON}frag6_overatomic.py

# atomic fragment with short fragmented payload
TARGETS +=	frag6-shortatomic
run-regress-frag6-shortatomic: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 short atomic fragments
	${SUDO} ${PYTHON}frag6_shortatomic.py

# fragmented packet permuted fragments
TARGETS +=	frag6-permute
run-regress-frag6-permute: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 permuted fragments
	${SUDO} ${PYTHON}frag6_permute.py

# fragmented packet with zero length first fragment
TARGETS +=	frag6-zerofirst
run-regress-frag6-zerofirst: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 zero length first fragment
	${SUDO} ${PYTHON}frag6_zerofirst.py

# fragmented packet with zero length second fragment
TARGETS +=	frag6-zerosecond
run-regress-frag6-zerosecond: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 zero length second fragment
	${SUDO} ${PYTHON}frag6_zerosecond.py

# fragmented large ping packet that has to be refragmented by reflector
TARGETS +=	frag6-refrag
run-regress-frag6-refrag: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 with fragmented reply
	${SUDO} ${PYTHON}frag6_refrag.py

# atomic fragmented udp packet
TARGETS +=	frag6-udpatomic
run-regress-frag6-udpatomic: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 atomic udp fragment
	${SUDO} ${PYTHON}frag6_udpatomic.py

# fragmented udp packet after header
TARGETS +=	frag6-udpheader
run-regress-frag6-udpheader: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 udp header fragment
	${SUDO} ${PYTHON}frag6_udpheader.py

# fragmented udp packet within payload
TARGETS +=	frag6-udppayload
run-regress-frag6-udppayload: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 udp payload fragment
	${SUDO} ${PYTHON}frag6_udppayload.py

# fragmented icmp packet not within 60 second timeout, test takes 90 seconds
TARGETS +=	frag6-timeout
run-regress-frag6-timeout: addr.py
	@@echo '\n======== $@@ ========'
	@@echo Check ping6 fragment timeout
	${SUDO} ${PYTHON}frag6_timeout.py
d98 2
a99 1
REGRESS_TARGETS =	${TARGETS:S/^/run-regress-/}
@


1.13
log
@The clean:, cleandir:, and obj: targets of src/Makefile descend into
regress/ and run python to set the IMPORT_PYTHON variable in several
test Makefiles. This results in W^X violations during 'make build'.
Avoid doing that.

ok bluhm
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.12 2016/09/02 21:30:34 bluhm Exp $
d105 7
@


1.12
log
@Print SKIPPED if a regress test cannot be executed for some reason.
This allows to identify such tests by looking at their output.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.11 2015/04/15 21:29:15 bluhm Exp $
d9 1
d13 1
@


1.11
log
@Test that ping6 fragments with ethernet padding get reassembled
correctly.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.10 2014/07/11 18:25:50 bluhm Exp $
d16 1
d46 1
@


1.10
log
@Add a test that sends a large ICMP6 packet in many small fragments.
The echo reply has to be fragmented.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.9 2013/10/31 01:24:06 bluhm Exp $
d108 7
@


1.9
log
@Do not fail the regression tests if python or the scapy package is
not installed.  Print a warning, explain the problem and skip the
test in this case.  Also skip the test if the environment has not
been configured for the remote test target machine.  Fix the Makefile
to run the tests with or without an obj directory.  Finally link
the netinet6 regression tests into the build.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.8 2013/07/23 22:38:45 bluhm Exp $
d171 7
@


1.8
log
@I need one more fragment to make the timeout test reliable.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.7 2013/07/23 22:15:04 bluhm Exp $
d9 9
d32 14
a45 6
SRC_IF =	tun0
SRC_MAC =	fe:e1:ba:d1:56:1f
DST_MAC =	52:54:00:12:34:50

SRC_OUT6 =	fdd7:e83e:66bc:211:fce1:baff:fed1:561f
DST_IN6 =	fdd7:e83e:66bc:211:5054:ff:fe12:3450
a55 1
	echo '${var} = "${${var}}"' >>$@@.tmp
d60 8
d93 1
a93 1
	${SUDO} python2.7 frag6.py
d100 1
a100 1
	${SUDO} python2.7 frag6_ext.py
d107 1
a107 1
	${SUDO} python2.7 frag6_opt.py
d114 1
a114 1
	${SUDO} python2.7 frag6_overhead0.py
d121 1
a121 1
	${SUDO} python2.7 frag6_overhead.py
d128 1
a128 1
	${SUDO} python2.7 frag6_overtail.py
d135 1
a135 1
	${SUDO} python2.7 frag6_overdrop.py
d142 1
a142 1
	${SUDO} python2.7 frag6_overatomic.py
d149 1
a149 1
	${SUDO} python2.7 frag6_shortatomic.py
d156 1
a156 1
	${SUDO} python2.7 frag6_permute.py
d163 1
a163 1
	${SUDO} python2.7 frag6_zerofirst.py
d170 1
a170 1
	${SUDO} python2.7 frag6_zerosecond.py
d177 1
a177 1
	${SUDO} python2.7 frag6_udpatomic.py
d184 1
a184 1
	${SUDO} python2.7 frag6_udpheader.py
d191 1
a191 1
	${SUDO} python2.7 frag6_udppayload.py
d198 1
a198 1
	${SUDO} python2.7 frag6_timeout.py
@


1.7
log
@IPv6 fragments, that cannot be reassembled within 60 seconds after
the frist fragment has arrived, must be dropped.  Add a regression
test that sends 5 echo request fragments within 75 seconds and check
that there is no echo reply.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.6 2012/02/08 00:35:31 bluhm Exp $
d169 1
a169 1
# fragmented icmp packet not within 60 second timeout
a176 1
REGRESS_SLOW_TARGETS =	run-regress-frag6-timeout
@


1.6
log
@Add IPv6 tests for fragmented destination options, fragments without
payload, fragmented UDP packets.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.5 2012/01/27 17:28:00 bluhm Exp $
d169 7
d177 1
@


1.5
log
@Test sending a short atomic IPv6 fragment.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.4 2012/01/24 19:12:34 bluhm Exp $
d13 1
d78 7
d134 35
d171 1
a171 1
CLEANFILES +=		*.pyc *.log
@


1.4
log
@Add a test for atomic IPv6 fragment reassembly.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.3 2012/01/11 21:37:44 bluhm Exp $
d111 7
@


1.3
log
@Do not read dstaddr from command line, get it from addr.py.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.2 2012/01/10 17:21:52 bluhm Exp $
d104 7
@


1.2
log
@According to RFC 5722 we drop all IPv6 fragments that belong to a
packet with overlaps.  Adapt existing tests and add one more.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.1 2012/01/06 21:52:15 bluhm Exp $
d68 1
a68 1
	${SUDO} python2.7 frag6.py ${DST_IN6}
d75 1
a75 1
	${SUDO} python2.7 frag6_ext.py ${DST_IN6}
d82 1
a82 1
	${SUDO} python2.7 frag6_overhead0.py ${DST_IN6}
d89 1
a89 1
	${SUDO} python2.7 frag6_overhead.py ${DST_IN6}
d96 1
a96 1
	${SUDO} python2.7 frag6_overtail.py ${DST_IN6}
d103 1
a103 1
	${SUDO} python2.7 frag6_overdrop.py ${DST_IN6}
d110 1
a110 1
	${SUDO} python2.7 frag6_permute.py ${DST_IN6}
@


1.1
log
@Add tests for IPv6 fragment reassembly.  Hand-crafted ping6
echo-request fragments are sent by scapy to the target machine.
There they get reassembled and a echo-reply comes back.  The ping6
payload is checked.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.2 2011/09/21 23:48:23 bluhm Exp $
d97 7
@

