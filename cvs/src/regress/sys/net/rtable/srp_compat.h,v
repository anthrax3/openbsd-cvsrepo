head	1.4;
access;
symbols
	OPENBSD_6_0:1.3.0.2
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.1.0.2
	OPENBSD_5_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2016.11.20.11.48.52;	author mpi;	state Exp;
branches;
next	1.3;
commitid	llGmvV3QkoVOWWXG;

1.3
date	2016.07.19.10.52.56;	author mpi;	state Exp;
branches;
next	1.2;
commitid	zEXTxgD8kqjgybKP;

1.2
date	2016.06.07.07.57.59;	author mpi;	state Exp;
branches;
next	1.1;
commitid	pbrgUisI2WcZJYWo;

1.1
date	2015.12.03.15.15.04;	author mpi;	state Exp;
branches;
next	;
commitid	EzPopRwGLnsCCvRH;


desc
@@


1.4
log
@SRPL_FIRST() and SRPL_FOLLOW().
@
text
@
#ifndef _SRP_COMPAT_H_
#define _SRP_COMPAT_H_

#include <sys/srp.h>
#include <sys/queue.h>

/*
 * SRP glue.
 */

#define srp_enter(_sr, _s)		((_s)->ref)
#define srp_follow(_sr, _s)		((_s)->ref)
#define srp_leave(_sr)			do { } while (0)
#define srp_swap(_srp, _v)		srp_swap_locked((_srp), (_v))
#define srp_update(_gc, _srp, _v)	srp_update_locked((_gc), (_srp), (_v))
#define srp_finalize(_v, _wchan)	((void)0)

#define srp_get_locked(_s)		((_s)->ref)

static inline void *
srp_swap_locked(struct srp *srp, void *nv)
{
	void *ov;

	ov = srp->ref;
	srp->ref = nv;

	return (ov);
}

#define srp_update_locked(_gc, _s, _v) do {				\
	void *ov;							\
									\
	ov = srp_swap_locked(_s, _v);					\
									\
	if (ov != NULL)							\
		((_gc)->srp_gc_dtor)((_gc)->srp_gc_cookie, ov);		\
} while (0)

/*
 * SRPL glue.
 */

#define SRPL_INIT(_sl)			SLIST_INIT(_sl)
#define SRPL_HEAD(name, entry)		SLIST_HEAD(name, entry)
#define SRPL_ENTRY(type)		SLIST_ENTRY(type)

#define SRPL_FIRST(_sr, _sl)		SLIST_FIRST(_sl);
#define SRPL_NEXT(_sr, _e, _ENTRY)	SLIST_NEXT(_e, _ENTRY)
#define SRPL_FOLLOW(_sr, _e, _ENTRY)	SLIST_NEXT(_e, _ENTRY)
#define SRPL_LEAVE(_sr)			((void)_sr)

#define SRPL_FOREACH(_c, _srp, _sl, _ENTRY)				\
		SLIST_FOREACH(_c, _sl, _ENTRY)

#define SRPL_EMPTY_LOCKED(_sl)	SLIST_EMPTY(_sl)
#define SRPL_FOREACH_SAFE_LOCKED(_c, _sl, _ENTRY, _tc)			\
		SLIST_FOREACH_SAFE(_c, _sl, _ENTRY, _tc)

#define SRPL_INSERT_HEAD_LOCKED(_rc, _sl, _e, _ENTRY)			\
	do {								\
		(_rc)->srpl_ref((_rc)->srpl_cookie, _e);		\
		SLIST_INSERT_HEAD(_sl, _e, _ENTRY);			\
	} while (0)

#define SRPL_REMOVE_LOCKED(_rc, _sl, _e, _type, _ENTRY)			\
	do {								\
		SLIST_REMOVE(_sl, _e, _type, _ENTRY);			\
		((_rc)->srpl_gc.srp_gc_dtor)((_rc)->srpl_gc.srp_gc_cookie, _e);\
	} while (0)

#endif /* _SRP_COMPAT_H_ */
@


1.3
log
@Adapt test to the srp_swap() area.
@
text
@d49 1
a49 1
#define SRPL_ENTER(_sr, _sl)		SLIST_FIRST(_sl);
d51 1
@


1.2
log
@Adapt compat layers after recent changes: srp_swap() and the GC task
for ART.
@
text
@d9 1
a9 1
 * SRPL glue.
d12 19
a30 3
#define srp_get_locked(_s)	((_s)->ref)
#define srp_enter(_sr, _s)	srp_get_locked(_s)
#define srp_leave(_sr)		((void)_sr)
d35 1
a35 2
	ov = (_s)->ref;							\
	(_s)->ref = _v;							\
d41 4
d52 3
@


1.1
log
@Sync to recent changes including SRP protection of rtable_get(), use
of a SRPL for the multipath list and rtable_delete() API change.
@
text
@a10 3
#define REFCNT_INITIALIZER()	{ .refs = 1 }
#define SRP_GC_INITIALIZER(_d, _c) { (_d), (_c), REFCNT_INITIALIZER() }
#define SRPL_RC_INITIALIZER(_r, _u, _c) { _r, SRP_GC_INITIALIZER(_u, _c) }
d13 2
a14 2
#define srp_enter(_s)		srp_get_locked(_s)
#define srp_leave(_s, _v)	/* nothing */
d20 2
a21 1
	(_s)->ref = (_v);						\
d23 1
a23 1
		(*(_gc)->srp_gc_dtor)((_gc)->srp_gc_cookie, ov);	\
d30 3
a32 3
#define SRPL_ENTER(_sl, _si)		SLIST_FIRST(_sl);(void)_si
#define SRPL_NEXT(_si, _e, _ENTRY)	SLIST_NEXT(_e, _ENTRY)
#define SRPL_LEAVE(_si, _c)		/* nothing */
d34 1
d37 7
d45 4
a48 3
		SLIST_REMOVE(_sl, _e, _type, _ENTRY)
#define SRPL_INSERT_HEAD_LOCKED(_rc, _sl, _e, _ENTRY)			\
		SLIST_INSERT_HEAD(_sl, _e, _ENTRY)
@

