head	1.22;
access;
symbols
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.11.0.6
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2;
locks; strict;
comment	@# @;


1.22
date	2016.10.19.14.31.19;	author tb;	state Exp;
branches;
next	1.21;
commitid	r0ZXVh0JShv1yn7K;

1.21
date	2016.09.02.21.30.34;	author bluhm;	state Exp;
branches;
next	1.20;
commitid	sbZCO4zszQKrda5x;

1.20
date	2016.08.31.22.44.29;	author bluhm;	state Exp;
branches;
next	1.19;
commitid	wQLTIpNOdX9pBNCe;

1.19
date	2016.05.28.19.54.26;	author sthen;	state Exp;
branches;
next	1.18;
commitid	ENVizNO58FuDAOdi;

1.18
date	2015.11.01.21.30.00;	author bluhm;	state Exp;
branches;
next	1.17;
commitid	YhekLUbUv3XdjNpb;

1.17
date	2015.08.24.23.12.53;	author bluhm;	state Exp;
branches;
next	1.16;
commitid	io7tL4yJ4LeVqmMX;

1.16
date	2015.08.24.22.14.01;	author bluhm;	state Exp;
branches;
next	1.15;
commitid	maFgnCEHZJBbFTvd;

1.15
date	2015.08.17.22.06.50;	author bluhm;	state Exp;
branches;
next	1.14;
commitid	dA9USfvUvCKUBfV4;

1.14
date	2015.08.13.15.46.01;	author bluhm;	state Exp;
branches;
next	1.13;
commitid	uJhwczfXJPtkffM7;

1.13
date	2015.07.21.17.51.50;	author bluhm;	state Exp;
branches;
next	1.12;
commitid	rrWHLPuCICxdemKP;

1.12
date	2015.07.20.20.53.44;	author bluhm;	state Exp;
branches;
next	1.11;
commitid	HuFAc4EkWhEVIDnk;

1.11
date	2014.07.18.23.54.55;	author bluhm;	state Exp;
branches;
next	1.10;
commitid	q1ZGA4d2w2OgeX39;

1.10
date	2014.07.13.02.01.23;	author bluhm;	state Exp;
branches;
next	1.9;
commitid	ZyB3xN7jW17OOsD3;

1.9
date	2014.07.12.22.43.31;	author bluhm;	state Exp;
branches;
next	1.8;
commitid	8kciCoVC9NsnDpq4;

1.8
date	2014.07.12.21.41.49;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	ZzV1CGylzBHJz2cs;

1.7
date	2014.07.12.21.00.46;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	kRAUZYkP8QlyLbU8;

1.6
date	2013.10.17.02.20.15;	author lteo;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.10.16.58.29;	author bluhm;	state Exp;
branches;
next	1.4;

1.4
date	2012.07.10.12.45.58;	author bluhm;	state Exp;
branches;
next	1.3;

1.3
date	2012.07.08.21.47.49;	author bluhm;	state Exp;
branches;
next	1.2;

1.2
date	2011.09.21.23.48.23;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2011.09.19.22.45.32;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.22
log
@The clean:, cleandir:, and obj: targets of src/Makefile descend into
regress/ and run python to set the IMPORT_PYTHON variable in several
test Makefiles. This results in W^X violations during 'make build'.
Avoid doing that.

ok bluhm
@
text
@#	$OpenBSD: Makefile,v 1.21 2016/09/02 21:30:34 bluhm Exp $

# The following ports must be installed:
#
# python-2.7          interpreted object-oriented programming language
# py-libdnet          python interface to libdnet
# scapy               powerful interactive packet manipulation in python

.if ! (make(clean) || make(cleandir) || make(obj))
# Check whether all required python packages are installed.  If some
# are missing print a warning and skip the tests, but do not fail.
PYTHON_IMPORT != python2.7 -c 'from scapy.all import *' 2>&1 || true
.endif
.if ! empty(PYTHON_IMPORT)
regress:
	@@echo '${PYTHON_IMPORT}'
	@@echo install python and the scapy module for additional tests
	@@echo SKIPPED
.endif

# This test needs a manual setup of four machines
# The setup is the same as for regress/sys/net/pf_forward
# Set up machines: SRC PF RT ECO
# SRC is the machine where this makefile is running.
# PF is running OpenBSD forwarding through pf, it is the test target.
# RT is a router forwarding packets, maximum MTU is 1300.
# ECO is reflecting the ping and UDP echo packets.
# RDR does not exist, PF redirects the traffic to ECO.
# RTT addresses exist on ECO, PF has no route and must use route-to RT
#
# +---+   0   +--+   1   +--+   2   +---+ 7   4 +---+   7 +---+
# |SRC| ----> |PF| ----> |RT| ----> |ECO|       |RDR|     |RTT|
# +---+       +--+       +--+       +---+       +---+     +---+
#     out    in  out    in  out    in   rtt    in        in

# Configure Addresses on the machines, there must be routes for the
# networks.  Adapt interface and address variables to your local
# setup.  To control the remote machine you need a hostname for
# ssh to log in.
# You must have an anchor "regress" for the divert rules in the pf.conf
# of the PF machine.  The kernel of the PF machine gets tested.
#
# Run make check-setup to see if you got the setup correct.

SRC_IF ?=	tap0
SRC_MAC ?=	fe:e1:ba:d1:0a:dc
PF_IFIN ?=	vio0
PF_IFOUT ?=	vio1
PF_MAC ?=	52:54:00:12:34:50
PF_SSH ?=
RT_SSH ?=
ECO_SSH ?=

SRC_OUT ?=	10.188.210.10
PF_IN ?=	10.188.210.50
PF_OUT ?=	10.188.211.50
RT_IN ?=	10.188.211.51
RT_OUT ?=	10.188.212.51
ECO_IN ?=	10.188.212.52
RDR_IN ?=	10.188.214.188
RTT_IN ?=	10.188.217.52

SRC_OUT6 ?=	fdd7:e83e:66bc:210:fce1:baff:fed1:561f
PF_IN6 ?=	fdd7:e83e:66bc:210:5054:ff:fe12:3450
PF_OUT6 ?=	fdd7:e83e:66bc:211:5054:ff:fe12:3450
RT_IN6 ?=	fdd7:e83e:66bc:211:5054:ff:fe12:3451
RT_OUT6 ?=	fdd7:e83e:66bc:212:5054:ff:fe12:3451
ECO_IN6 ?=	fdd7:e83e:66bc:212:5054:ff:fe12:3452
RDR_IN6 ?=	fdd7:e83e:66bc:214::188
RTT_IN6 ?=	fdd7:e83e:66bc:217:5054:ff:fe12:3452

.if empty (PF_SSH) || empty (RT_SSH) || empty (ECO_SSH)
regress:
	@@echo this test needs three remote machines to operate on
	@@echo PF_SSH RT_SSH ECO_SSH are empty
	@@echo fill out these variables for additional tests, then
	@@echo check whether your test machines are set up properly
	@@echo SKIPPED
.endif

.MAIN: all

.if ! empty (PF_SSH)
.if make (regress) || make (all)
.BEGIN: pf.conf addr.py
	@@echo
	${SUDO} true
	ssh -t ${PF_SSH} ${SUDO} true
	rm -f stamp-pfctl
.endif
.endif

depend: addr.py

# Create python include file containing the addresses.
addr.py: Makefile
	rm -f $@@ $@@.tmp
	echo 'SRC_IF="${SRC_IF}"' >>$@@.tmp
	echo 'SRC_MAC="${SRC_MAC}"' >>$@@.tmp
	echo 'PF_IFIN="${PF_IFIN}"' >>$@@.tmp
	echo 'PF_IFOUT="${PF_IFOUT}"' >>$@@.tmp
	echo 'PF_MAC="${PF_MAC}"' >>$@@.tmp
.for var in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN RDR_IN RTT_IN
	echo '${var}="${${var}}"' >>$@@.tmp
	echo '${var}6="${${var}6}"' >>$@@.tmp
.endfor
	mv $@@.tmp $@@

# load the pf rules into the kernel of the PF machine
# XXX pfctl does not replace variables after @@
stamp-pfctl: addr.py pf.conf
	cat addr.py ${.CURDIR}/pf.conf | pfctl -n -f -
	cat addr.py ${.CURDIR}/pf.conf | \
	    sed 's/@@$$PF_IFIN /@@${PF_IFIN} /;s/@@$$PF_IFOUT /@@${PF_IFOUT} /' | \
	    ssh ${PF_SSH} ${SUDO} pfctl -a regress -f -
	@@date >$@@

# Set variables so that make runs with and without obj directory.
# Only do that if necessary to keep visible output short.
.if ${.CURDIR} == ${.OBJDIR}
PYTHON =	python2.7 ./
.else
PYTHON =	PYTHONPATH=${.OBJDIR} python2.7 ${.CURDIR}/
.endif

# Ping all addresses.  This ensures that the IP addresses are configured
# and all routing table are set up to allow bidirectional packet flow.
# Note that RDR does not exist physically.  So this traffic is rewritten
# by PF and handled by ECO.
TARGETS +=	ping  ping6

run-regress-ping: stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN RDR_IN RTT_IN
	@@echo Check ping ${ip}:
	ping -n -c 1 ${${ip}}
.endfor

run-regress-ping6: stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN RDR_IN RTT_IN
	@@echo Check ping ${ip}6:
	ping6 -n -c 1 ${${ip}6}
.endfor

# Ping all addresses again but with 5000 bytes payload.  These large
# packets get fragmented by SRC and must be handled by PF.
# Send 1 packet in advance for Path-MTU discovery.
TARGETS +=	fragping  fragping6

run-regress-fragping: stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in PF_IN PF_OUT RT_IN RT_OUT ECO_IN RDR_IN RTT_IN
	@@echo Check ping ${ip}:
	ping -n -c 1 -s 5000 ${${ip}}
.endfor

run-regress-fragping6: stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in PF_IN PF_OUT RT_IN RT_OUT
	@@echo Check ping ${ip}6:
	${SUDO} route -n delete -host -inet6 ${${ip}6} || true
	ping6 -n -c 1 -s 1452 -m ${${ip}6} & sleep 1; kill $$! || true
	ping6 -n -c 1 -s 5000 -m ${${ip}6}
.endfor
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check ping ${ip}6:
	${SUDO} route -n delete -host -inet6 ${${ip}6} || true
	ping6 -n -c 1 -s 1352 -m ${${ip}6} & sleep 1; kill $$! || true
	ping6 -n -c 1 -s 5000 -m ${${ip}6}
.endfor

# Send a large IPv4/ICMP-Echo-Request packet with enabled DF bit and
# parse response packet to determine MTU of the router.  The MTU has
# to be 1300 octets.  The MTU has to be defined at out interface of
# the router RT before.
TARGETS +=	ping-mtu ping6-mtu

run-regress-ping-mtu: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check path MTU to ${ip}
	${SUDO} ${PYTHON}ping_mtu_1300.py ${${ip}}
.endfor

run-regress-ping6-mtu: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check path MTU to ${ip}6
	${SUDO} ${PYTHON}ping6_mtu_1300.py ${${ip}6}
.endfor

# Send packet too big to get to destination.
# Check that checksum of the quoted original packet in ICMP is correct.

# Currently these test fail as pf does not fix the checksum of
# NATed packets inside of ICMP packets.
# XXX TARGETS +=	ping-cksum ping6-cksum udp-cksum udp6-cksum

run-regress-ping-cksum: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check ICMP chksum in fragmentation needed to ${ip}
	${SUDO} ${PYTHON}ping_cksum.py ${${ip}}
.endfor

run-regress-ping6-cksum: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check ICMP6 chksum in packet too big to ${ip}6
	${SUDO} ${PYTHON}ping6_cksum.py ${${ip}6}
.endfor

run-regress-udp-cksum: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check UDP chksum in packet too big to ${ip}
	${SUDO} ${PYTHON}udp_cksum.py ${${ip}}
.endfor

run-regress-udp6-cksum: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check UDP6 chksum in packet too big to ${ip}6
	${SUDO} ${PYTHON}udp6_cksum.py ${${ip}6}
.endfor

# Send handcrafted fragmented packets with overlaps
TARGETS +=	frag frag6

run-regress-frag: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check ping reassembly ${ip}
	${SUDO} ${PYTHON}frag.py ${${ip}}
.endfor

run-regress-frag6: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check ping6 reassembly ${ip}6
	${SUDO} ${PYTHON}frag6.py ${${ip}6}
.endfor

TARGETS +=	frag6-ext

run-regress-frag6-ext: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check ping6 extension header reassembly ${ip}6
	${SUDO} ${PYTHON}frag6_ext.py ${${ip}6}
.endfor

TARGETS +=	frag-cutnew frag6-cutnew

run-regress-frag-cutnew: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check ping head overlap reassembly ${ip}
	${SUDO} ${PYTHON}frag_cutnew.py ${${ip}}
.endfor

run-regress-frag6-cutnew: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check ping6 head overlap reassembly ${ip}6
	${SUDO} ${PYTHON}frag6_cutnew.py ${${ip}6}
.endfor

TARGETS +=	frag-cutold frag6-cutold

run-regress-frag-cutold: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check ping tail overlap reassembly ${ip}
	${SUDO} ${PYTHON}frag_cutold.py ${${ip}}
.endfor

run-regress-frag6-cutold: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check ping6 tail overlap reassembly ${ip}6
	${SUDO} ${PYTHON}frag6_cutold.py ${${ip}6}
.endfor

TARGETS +=	frag-dropold frag6-dropold

run-regress-frag-dropold: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check ping total overlapping reassembly ${ip}
	${SUDO} ${PYTHON}frag_dropold.py ${${ip}}
.endfor

run-regress-frag6-dropold: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check ping6 total overlapping reassembly ${ip}6
	${SUDO} ${PYTHON}frag6_dropold.py ${${ip}6}
.endfor

TARGETS +=	frag-dropnew frag6-dropnew

run-regress-frag-dropnew: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check ping total overlaped reassembly ${ip}
	${SUDO} ${PYTHON}frag_dropnew.py ${${ip}}
.endfor

run-regress-frag6-dropnew: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RDR_IN RTT_IN
	@@echo Check ping6 total overlaped reassembly ${ip}6
	${SUDO} ${PYTHON}frag6_dropnew.py ${${ip}6}
.endfor

REGRESS_TARGETS =	${TARGETS:S/^/run-regress-/}

CLEANFILES +=		addr.py *.pyc *.log stamp-*

.PHONY: check-setup

# Check whether the address, route and remote setup are correct
check-setup: check-setup-src check-setup-pf check-setup-rt check-setup-eco

check-setup-src:
	@@echo '\n======== $@@ ========'
.for ip in SRC_OUT
	ping -n -c 1 ${${ip}}  # ${ip}
	route -n get -inet ${${ip}} | grep -q 'flags: .*LOCAL'  # ${ip}
.endfor
	ping -n -c 1 ${PF_IN}  # PF_IN
	route -n get -inet ${PF_IN} | fgrep -q 'interface: ${SRC_IF}'  # PF_IN SRC_IF
.for ip in PF_OUT RT_IN RT_OUT ECO_IN RDR_IN RTT_IN
	route -n get -inet ${${ip}} | fgrep -q 'gateway: ${PF_IN}'  # ${ip} PF_IN
.endfor
.for ip in SRC_OUT
	ping6 -n -c 1 ${${ip}6}  # ${ip}6
	route -n get -inet6 ${${ip}6} | grep -q 'flags: .*LOCAL'  # ${ip}6
.endfor
	ping6 -n -c 1 ${PF_IN6}  # PF_IN6
	route -n get -inet6 ${PF_IN6} | fgrep -q 'interface: ${SRC_IF}'  # PF_IN6 SRC_IF
.for ip in PF_OUT RT_IN RT_OUT ECO_IN RDR_IN RTT_IN
	route -n get -inet6 ${${ip}6} | fgrep -q 'gateway: ${PF_IN6}'  # ${ip}6 PF_IN6
.endfor

check-setup-pf:
	@@echo '\n======== $@@ ========'
	ssh ${PF_SSH} ping -n -c 1 ${PF_IN}  # PF_IN
	ssh ${PF_SSH} route -n get -inet ${PF_IN} | grep -q 'flags: .*LOCAL'  # PF_IN
	ssh ${PF_SSH} ping -n -c 1 ${SRC_OUT}  # SRC_OUT
	ssh ${PF_SSH} ping -n -c 1 ${PF_OUT}  # PF_OUT
	ssh ${PF_SSH} route -n get -inet ${PF_OUT} | grep -q 'flags: .*LOCAL'  # PF_OUT
	ssh ${PF_SSH} ping -n -c 1 ${RT_IN}  # RT_IN
.for ip in RT_OUT ECO_IN
	ssh ${PF_SSH} route -n get -inet ${${ip}} | fgrep -q 'gateway: ${RT_IN}'  # ${ip} RT_IN
.endfor
.for ip in RTT_IN
	ssh ${PF_SSH} route -n get -inet ${${ip}} | grep -q 'flags: .*REJECT'  # ${ip} reject
.endfor
	ssh ${PF_SSH} ping6 -n -c 1 ${PF_IN6}  # PF_IN6
	ssh ${PF_SSH} route -n get -inet6 ${PF_IN6} | grep -q 'flags: .*LOCAL'  # PF_IN6
	ssh ${PF_SSH} ping6 -n -c 1 ${SRC_OUT6}  # SRC_OUT6
	ssh ${PF_SSH} ping6 -n -c 1 ${PF_OUT6}  # PF_OUT6
	ssh ${PF_SSH} route -n get -inet6 ${PF_OUT6} | grep -q 'flags: .*LOCAL'  # PF_OUT6
	ssh ${PF_SSH} ping6 -n -c 1 ${RT_IN6}  # RT_IN6
.for ip in RT_OUT ECO_IN
	ssh ${PF_SSH} route -n get -inet6 ${${ip}6} | fgrep -q 'gateway: ${RT_IN6}'  # ${ip}6 RT_IN6
.endfor
.for ip in RTT_IN
	ssh ${PF_SSH} route -n get -inet6 ${${ip}6} | grep -q 'flags: .*REJECT'  # ${ip}6 reject
.endfor
	ssh ${PF_SSH} ${SUDO} pfctl -sr | grep '^anchor "regress" all$$'
	ssh ${PF_SSH} ${SUDO} pfctl -si | grep '^Status: Enabled '
	ssh ${PF_SSH} sysctl net.inet.ip.forwarding | fgrep =1
	ssh ${PF_SSH} sysctl net.inet6.ip6.forwarding | fgrep =1

check-setup-rt:
	@@echo '\n======== $@@ ========'
	ssh ${RT_SSH} ping -n -c 1 ${RT_IN}  # RT_IN
	ssh ${RT_SSH} route -n get -inet ${RT_IN} | grep -q 'flags: .*LOCAL'  # RT_IN
	ssh ${RT_SSH} ping -n -c 1 ${PF_OUT}  # PF_OUT
.for ip in PF_IN SRC_OUT
	ssh ${RT_SSH} route -n get -inet ${${ip}} | fgrep -q 'gateway: ${PF_OUT}'  # ${ip} PF_OUT
.endfor
	ssh ${RT_SSH} ping -n -c 1 ${RT_OUT}  # RT_OUT
	ssh ${RT_SSH} route -n get -inet ${RT_OUT} | grep -q 'flags: .*LOCAL'  # RT_OUT
	ssh ${RT_SSH} ping -n -c 1 ${ECO_IN}  # ECO_IN
.for ip in RTT_IN
	ssh ${RT_SSH} route -n get -inet ${${ip}} | fgrep -q 'gateway: ${ECO_IN}'  # ${ip} ECO_IN
.endfor
	ssh ${RT_SSH} ping6 -n -c 1 ${RT_IN6}  # RT_IN6
	ssh ${RT_SSH} route -n get -inet6 ${RT_IN6} | grep -q 'flags: .*LOCAL'  # RT_IN6
	ssh ${RT_SSH} ping6 -n -c 1 ${PF_OUT6}  # PF_OUT6
.for ip in PF_IN SRC_OUT
	ssh ${RT_SSH} route -n get -inet6 ${${ip}6} | fgrep -q 'gateway: ${PF_OUT6}'  # ${ip}6 PF_OUT6
.endfor
	ssh ${RT_SSH} ping6 -n -c 1 ${RT_OUT6}  # RT_OUT6
	ssh ${RT_SSH} route -n get -inet6 ${RT_OUT6} | grep -q 'flags: .*LOCAL'  # RT_OUT6
	ssh ${RT_SSH} ping6 -n -c 1 ${ECO_IN6}  # ECO_IN6
.for ip in RTT_IN
	ssh ${RT_SSH} route -n get -inet6 ${${ip}6} | fgrep -q 'gateway: ${ECO_IN6}'  # ${ip}6 ECO_IN6
.endfor
	ssh ${RT_SSH} sysctl net.inet.ip.forwarding | fgrep =1
	ssh ${RT_SSH} sysctl net.inet6.ip6.forwarding | fgrep =1
	ssh ${RT_SSH} ifconfig | fgrep 'mtu 1300'

check-setup-eco:
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN RTT_IN
	ssh ${ECO_SSH} ping -n -c 1 ${${ip}}  # ${ip}
	ssh ${ECO_SSH} route -n get -inet ${${ip}} | grep -q 'flags: .*LOCAL'  # ${ip}
.endfor
	ssh ${ECO_SSH} ping -n -c 1 ${RT_OUT}  # RT_OUT
.for ip in RT_IN PF_OUT PF_IN SRC_OUT
	ssh ${ECO_SSH} route -n get -inet ${${ip}} | fgrep -q 'gateway: ${RT_OUT}'  # ${ip} RT_OUT
.endfor
.for ip in ECO_IN RTT_IN
	ssh ${ECO_SSH} ping6 -n -c 1 ${${ip}6}  # ${ip}6
	ssh ${ECO_SSH} route -n get -inet6 ${${ip}6} | grep -q 'flags: .*LOCAL'  # ${ip}6
.endfor
	ssh ${ECO_SSH} ping6 -n -c 1 ${RT_OUT6}  # RT_OUT6
.for ip in RT_IN PF_OUT PF_IN SRC_OUT
	ssh ${ECO_SSH} route -n get -inet6 ${${ip}6} | fgrep -q 'gateway: ${RT_OUT6}'  # ${ip}6 RT_OUT6
.endfor

.include <bsd.regress.mk>
@


1.21
log
@Print SKIPPED if a regress test cannot be executed for some reason.
This allows to identify such tests by looking at their output.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.20 2016/08/31 22:44:29 bluhm Exp $
d9 1
d13 1
@


1.20
log
@Split the check-setup target into smaller parts to make it easier
to configure the regression test machines.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.19 2016/05/28 19:54:26 sthen Exp $
d16 1
d76 1
@


1.19
log
@comment typos
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.18 2015/11/01 21:30:00 bluhm Exp $
d321 4
a324 2
check-setup:
	@@echo '\n======== $@@ SRC ========'
d343 3
a345 1
	@@echo '\n======== $@@ PF ========'
d374 3
a376 1
	@@echo '\n======== $@@ RT ========'
d404 3
a406 1
	@@echo '\n======== $@@ ECO ========'
@


1.18
log
@Route output to local addresses has changed, ping6 command line
options have changed, tun has been renamed to tap.  Adapt tests.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.17 2015/08/24 23:12:53 bluhm Exp $
d9 1
a9 1
# Check wether all required python packages are installed.  If some
d34 1
a34 1
# networks.  Adapt interface and addresse variables to your local
d38 1
a38 1
# of the PF machine.  The kernel of the PF machine gets testet.
d71 1
a71 1
	@@echo this tests needs three remote machines to operate on
d74 1
a74 1
	@@echo check wether your test machines are set up properly
d189 1
a189 1
# Send packet to big to get to destination.
d320 1
a320 1
# Check wether the address, route and remote setup is correct
@


1.17
log
@Extend the pf forward and fragment tests with a second challenge
for path MTU discovery.  The router behind the pf machine has MTU
1300.  The ICMP packet generated by the router matches the pf state
and is NATed correctly.  Additionally the pf machine itself has an
interface MTU 1400.  So when pf is sending a packet is has to
generate a correct "fragmentation needed" or "packet too big" ICMP
response.  This is done with pf route-to and reply-to.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.16 2015/08/24 22:14:01 bluhm Exp $
d42 1
a42 1
SRC_IF ?=	tun0
d325 1
a325 1
	route -n get -inet ${${ip}} | fgrep -q 'interface: lo0'  # ${ip}
d334 1
a334 1
	route -n get -inet6 ${${ip}6} | fgrep -q 'interface: lo0'  # ${ip}6
d343 1
a343 1
	ssh ${PF_SSH} route -n get -inet ${PF_IN} | fgrep -q 'interface: lo0'  # PF_IN
d346 1
a346 1
	ssh ${PF_SSH} route -n get -inet ${PF_OUT} | fgrep -q 'interface: lo0'  # PF_OUT
d355 1
a355 1
	ssh ${PF_SSH} route -n get -inet6 ${PF_IN6} | fgrep -q 'interface: lo0'  # PF_IN6
d358 1
a358 1
	ssh ${PF_SSH} route -n get -inet6 ${PF_OUT6} | fgrep -q 'interface: lo0'  # PF_OUT6
d372 1
a372 1
	ssh ${RT_SSH} route -n get -inet ${RT_IN} | fgrep -q 'interface: lo0'  # RT_IN
d378 1
a378 1
	ssh ${RT_SSH} route -n get -inet ${RT_OUT} | fgrep -q 'interface: lo0'  # RT_OUT
d384 1
a384 1
	ssh ${RT_SSH} route -n get -inet6 ${RT_IN6} | fgrep -q 'interface: lo0'  # RT_IN6
d390 1
a390 1
	ssh ${RT_SSH} route -n get -inet6 ${RT_OUT6} | fgrep -q 'interface: lo0'  # RT_OUT6
d401 1
a401 1
	ssh ${ECO_SSH} route -n get -inet ${${ip}} | fgrep -q 'interface: lo0'  # ${ip}
d409 1
a409 1
	ssh ${ECO_SSH} route -n get -inet6 ${${ip}6} | fgrep -q 'interface: lo0'  # ${ip}6
@


1.16
log
@Enable path MTU test with ping for IPv6.  Scapy srp1() does not
accept inner IPv6 packets in ICMP6 with bad checksum created by pf.
Use same workaround as in pf_forward tests and fork a process for
sniffing.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.15 2015/08/17 22:06:50 bluhm Exp $
d44 2
a45 1
PF_IF ?=	vio0
d96 2
a97 1
	echo 'PF_IF="${PF_IF}"' >>$@@.tmp
d110 1
a110 1
	    sed 's/@@$$PF_IF /@@${PF_IF} /g' | \
a150 1
	-ping -n -c 1 -s 1400 -D ${${ip}}
d156 7
a162 1
.for ip in PF_IN PF_OUT RT_IN RT_OUT ECO_IN RDR_IN RTT_IN
d164 2
a165 1
	-ping6 -n -c 1 -s 1400 -m ${${ip}6}
@


1.15
log
@Add forwarding tests for pf route-to and reply-to.  Keep pf forward
and pf fragment tests in sync.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.14 2015/08/13 15:46:01 bluhm Exp $
d165 1
a165 5
TARGETS +=	ping-mtu

# Currently this test fails as pf does not fix the checksum of
# NATed packets inside of ICMP packets.
# XXX TARGETS +=	ping6-mtu
@


1.14
log
@Add IPv6 fragment tests for pf route-to.  A big ping packet is sent
in fragments to a machine running pf.  From there it is forwarded
with route-to to a router with a smaller MTU.  Path MTU discovery
has to make successive fragments shorter and pf route-to has to
preserve the fragment size.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.13 2015/07/21 17:51:50 bluhm Exp $
d26 1
a26 1
# RTT addresses exist on ECO, PF has not route and must use route-to
d120 1
a120 1
# Ping all addresses.  This ensures that the ip addresses are configured
d168 1
a168 1
# NATed packets inside of icmp packets.
d186 1
a186 1
# Check that checksum of the quoted original packet in icmp is correct.
d189 1
a189 1
# NATed packets inside of icmp packets.
d195 1
a195 1
	@@echo Check icmp chksum in fragmentation needed to ${ip}
d202 1
a202 1
	@@echo Check icmp6 chksum in packet too big to ${ip}6
d209 1
a209 1
	@@echo Check udp chksum in packet too big to ${ip}
d216 1
a216 1
	@@echo Check udp6 chksum in packet too big to ${ip}6
d319 4
a322 2
	ping -n -c 1 ${SRC_OUT}  # SRC_OUT
	route -n get -inet ${SRC_OUT} | fgrep -q 'interface: lo0'  # SRC_OUT
d328 4
a331 2
	ping6 -n -c 1 ${SRC_OUT6}  # SRC_OUT6
	route -n get -inet6 ${SRC_OUT6} | fgrep -q 'interface: lo0'  # SRC_OUT6
d347 3
a349 2
	ssh ${PF_SSH} route -n get -inet ${RTT_IN} | grep -q 'flags: .*REJECT'  # RTT_IN reject
	! ssh ${PF_SSH} route -n get -inet ${RTT_IN} | fgrep -q 'gateway: ${RT_IN}'  # RTT_IN RT_IN
d359 3
a361 2
	ssh ${PF_SSH} route -n get -inet6 ${RTT_IN6} | grep -q 'flags: .*REJECT'  # RTT_IN6 reject
	! ssh ${PF_SSH} route -n get -inet6 ${RTT_IN6} | fgrep -q 'gateway: ${RT_IN6}'  # RTT_IN6 RT_IN6
d376 3
a378 1
	ssh ${RT_SSH} route -n get -inet ${RTT_IN} | fgrep -q 'gateway: ${ECO_IN}'  # RTT_IN ECO_IN
d388 3
a390 1
	ssh ${RT_SSH} route -n get -inet6 ${RTT_IN6} | fgrep -q 'gateway: ${ECO_IN6}'  # RTT_IN6 ECO_IN6
@


1.13
log
@Extend the setup with another address for testing pf route-to.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.12 2015/07/20 20:53:44 bluhm Exp $
d44 1
d95 1
d104 1
d108 1
d128 1
a128 1
.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN RDR_IN
d135 1
a135 1
.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN RDR_IN
d147 1
a147 1
.for ip in PF_IN PF_OUT RT_IN RT_OUT ECO_IN RDR_IN
d155 1
a155 1
.for ip in PF_IN PF_OUT RT_IN RT_OUT ECO_IN RDR_IN
d173 1
a173 1
.for ip in ECO_IN RDR_IN
d180 1
a180 1
.for ip in ECO_IN RDR_IN
d194 1
a194 1
.for ip in ECO_IN RDR_IN
d201 1
a201 1
.for ip in ECO_IN RDR_IN
d208 1
a208 1
.for ip in ECO_IN RDR_IN
d215 1
a215 1
.for ip in ECO_IN RDR_IN
d225 1
a225 1
.for ip in ECO_IN RDR_IN
d232 1
a232 1
.for ip in ECO_IN RDR_IN
d241 1
a241 1
.for ip in ECO_IN RDR_IN
d250 1
a250 1
.for ip in ECO_IN RDR_IN
d257 1
a257 1
.for ip in ECO_IN RDR_IN
d266 1
a266 1
.for ip in ECO_IN RDR_IN
d273 1
a273 1
.for ip in ECO_IN RDR_IN
d282 1
a282 1
.for ip in ECO_IN RDR_IN
d289 1
a289 1
.for ip in ECO_IN RDR_IN
d298 1
a298 1
.for ip in ECO_IN RDR_IN
d305 1
a305 1
.for ip in ECO_IN RDR_IN
d343 1
d354 1
@


1.12
log
@When test pf.conf changes, check its syntax and use the new one.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.11 2014/07/18 23:54:55 bluhm Exp $
d19 1
d26 1
d28 4
a31 4
# +---+   0   +--+   1   +--+   2   +---+ 3   4 +---+
# |SRC| ----> |PF| ----> |RT| ----> |ECO|       |RDR|
# +---+       +--+       +--+       +---+       +---+
#     out    in  out    in  out    in          in
d56 1
d65 1
d95 1
a95 1
.for var in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN RDR_IN
d319 1
a319 1
.for ip in PF_OUT RT_IN RT_OUT ECO_IN RDR_IN
d326 1
a326 1
.for ip in PF_OUT RT_IN RT_OUT ECO_IN RDR_IN
d339 1
d349 1
d364 1
d374 1
d379 4
a382 2
	ssh ${ECO_SSH} ping -n -c 1 ${ECO_IN}  # ECO_IN
	ssh ${ECO_SSH} route -n get -inet ${ECO_IN} | fgrep -q 'interface: lo0'  # ECO_IN
d387 4
a390 2
	ssh ${ECO_SSH} ping6 -n -c 1 ${ECO_IN6}  # ECO_IN6
	ssh ${ECO_SSH} route -n get -inet6 ${ECO_IN6} | fgrep -q 'interface: lo0'  # ECO_IN6
@


1.11
log
@The pf forward tests were running rdr-to and nat-to simultaneously
only.  Change address layout and add individual tests for each
feature rdr-to and nat-to and rdr-to together with nat-to.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.10 2014/07/13 02:01:23 bluhm Exp $
d98 2
a99 1
stamp-pfctl: addr.py
@


1.10
log
@Make the pf_fragment test pass again.  pf does not adjust the
checksum of a NATed UDP or TCP packet in the payload of an ICMP
packet anymore.  Disable all test that rely on this feature.
Check that the router's interface mtu has been set to 1300.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.9 2014/07/12 22:43:31 bluhm Exp $
d26 1
a26 1
# +---+   0   +--+   1   +--+   2   +---+   3   +---+
d53 1
a53 1
RDR_IN ?=	10.188.213.188
d61 1
a61 1
RDR_IN6 ?=	fdd7:e83e:66bc:213::188
@


1.9
log
@Automatically load the required pf rules into the kernel of the
remote test machine.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.8 2014/07/12 21:41:49 bluhm Exp $
a82 8
# Currently these test fail as pf does not fix the checksum of
# NATed packets inside of icmp packets.
# ping6-mtu
# ping-cksum
# ping6-cksum
# udp-cksum
# udp6-cksum

d156 5
a160 1
TARGETS +=	ping-mtu ping6-mtu
d178 4
a181 1
TARGETS +=	ping-cksum ping6-cksum udp-cksum udp6-cksum
d345 2
a346 2
	ssh ${PF_SSH} sysctl net.inet.ip.forwarding | fgrep 1
	ssh ${PF_SSH} sysctl net.inet6.ip6.forwarding | fgrep 1
d366 3
a368 2
	ssh ${RT_SSH} sysctl net.inet.ip.forwarding | fgrep 1
	ssh ${RT_SSH} sysctl net.inet6.ip6.forwarding | fgrep 1
@


1.8
log
@Teach these pf regress tests to run with obj directory and to fail
softly if the setup is incomplete.  Link them to the build.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.7 2014/07/12 21:00:46 bluhm Exp $
d71 11
a81 11
# pf rules on PF must look like this:
#
# pass to { $PF_IN/24 $PF_IN6/64 }
# pass to { $RT_IN/24 $RT_IN6/64 }
# pass to { $ECO_IN/24 $DST_IN6/64 }
# pass to { $RDR_IN/24 $RDR_IN6/64 }
#
# pass in  to $RDR_IN/24  rdr-to $ECO_IN  allow-opts tag rdr
# pass out                nat-to $PF_OUT  allow-opts tagged rdr
# pass in  to $RDR_IN6/64 rdr-to $ECO_IN6 allow-opts tag rdr
# pass out                nat-to $PF_OUT6 allow-opts tagged rdr
d105 6
d125 1
a125 1
run-regress-ping:
d132 1
a132 1
run-regress-ping6:
d144 1
a144 1
run-regress-fragping:
d152 1
a152 1
run-regress-fragping6:
d166 1
a166 1
run-regress-ping-mtu: addr.py
d173 1
a173 1
run-regress-ping6-mtu: addr.py
d184 1
a184 1
run-regress-ping-cksum: addr.py
d191 1
a191 1
run-regress-ping6-cksum: addr.py
d198 1
a198 1
run-regress-udp-cksum: addr.py
d205 1
a205 1
run-regress-udp6-cksum: addr.py
d215 1
a215 1
run-regress-frag: addr.py
d222 1
a222 1
run-regress-frag6: addr.py
d231 1
a231 1
run-regress-frag6-ext: addr.py
d240 1
a240 1
run-regress-frag-cutnew: addr.py
d247 1
a247 1
run-regress-frag6-cutnew: addr.py
d256 1
a256 1
run-regress-frag-cutold: addr.py
d263 1
a263 1
run-regress-frag6-cutold: addr.py
d272 1
a272 1
run-regress-frag-dropold: addr.py
d279 1
a279 1
run-regress-frag6-dropold: addr.py
d288 1
a288 1
run-regress-frag-dropnew: addr.py
d295 1
a295 1
run-regress-frag6-dropnew: addr.py
d304 1
a304 1
CLEANFILES +=		addr.py *.pyc *.log
@


1.7
log
@Use a saner and consistent address layout for my network tests that
run over 4 machines.  Add a check-setup target to verify that
interface addresses and routes are properly set up.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.6 2013/10/17 02:20:15 lteo Exp $
d9 9
d43 3
a45 3
PF_SSH ?=	q50
RT_SSH ?=	q51
ECO_SSH ?=	q52
d63 8
d105 8
d164 1
a164 1
	${SUDO} python2.7 ping_mtu_1300.py ${${ip}}
d171 1
a171 1
	${SUDO} python2.7 ping6_mtu_1300.py ${${ip}6}
d182 1
a182 1
	${SUDO} python2.7 ping_cksum.py ${${ip}}
d189 1
a189 1
	${SUDO} python2.7 ping6_cksum.py ${${ip}6}
d196 1
a196 1
	${SUDO} python2.7 udp_cksum.py ${${ip}}
d203 1
a203 1
	${SUDO} python2.7 udp6_cksum.py ${${ip}6}
d213 1
a213 1
	${SUDO} python2.7 frag.py ${${ip}}
d220 1
a220 1
	${SUDO} python2.7 frag6.py ${${ip}6}
d229 1
a229 1
	${SUDO} python2.7 frag6_ext.py ${${ip}6}
d238 1
a238 1
	${SUDO} python2.7 frag_cutnew.py ${${ip}}
d245 1
a245 1
	${SUDO} python2.7 frag6_cutnew.py ${${ip}6}
d254 1
a254 1
	${SUDO} python2.7 frag_cutold.py ${${ip}}
d261 1
a261 1
	${SUDO} python2.7 frag6_cutold.py ${${ip}6}
d270 1
a270 1
	${SUDO} python2.7 frag_dropold.py ${${ip}}
d277 1
a277 1
	${SUDO} python2.7 frag6_dropold.py ${${ip}6}
d286 1
a286 1
	${SUDO} python2.7 frag_dropnew.py ${${ip}}
d293 1
a293 1
	${SUDO} python2.7 frag6_dropnew.py ${${ip}6}
d330 1
a330 1
	ssh ${PF_SSH} route -n get -inet6 ${PF_IN6} | fgrep -q 'interface: lo0'  # PF_IN6 
d333 1
a333 1
	ssh ${PF_SSH} route -n get -inet6 ${PF_OUT6} | fgrep -q 'interface: lo0'  # PF_OUT6 
d353 1
a353 1
	ssh ${RT_SSH} route -n get -inet6 ${RT_IN6} | fgrep -q 'interface: lo0'  # RT_IN6 
d359 1
a359 1
	ssh ${RT_SSH} route -n get -inet6 ${RT_OUT6} | fgrep -q 'interface: lo0'  # RT_OUT6 
d371 1
a371 1
	ssh ${ECO_SSH} route -n get -inet6 ${ECO_IN6} | fgrep -q 'interface: lo0'  # ECO_IN6 
@


1.6
log
@Fix run-regress-fragping to use ping(8) instead of ping6(8) to send the
initial Path-MTU discovery packet.

OK bluhm@@
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.5 2012/07/10 16:58:29 bluhm Exp $
d10 1
a10 1
# Set up machines: SRC PF RT DST
d14 2
a15 2
# DST is reflecting the ping and UDP echo packets.
# RDR does not exist, PF redirects the traffic to DST.
d17 2
a18 2
# +---+   1   +--+   2   +--+   3   +---+   4   +---+
# |SRC| ----> |PF| ----> |RT| ----> |DST|       |RDR|
d22 6
a27 2
# Configure Addresses on the machines, there must be routes for the networks.
# Adapt interface and addresse variables to your local setup.
d29 24
a52 19
SRC_IF =	tun0
SRC_MAC =	fe:e1:ba:d1:0a:dc
PF_MAC =	52:54:00:12:34:50

SRC_OUT =	10.188.211.10
PF_IN =		10.188.211.50
PF_OUT =	10.188.212.50
RT_IN =		10.188.212.51
RT_OUT =	10.188.213.51
DST_IN =	10.188.213.52
RDR_IN =	10.188.214.1

SRC_OUT6 =	fdd7:e83e:66bc:211:fce1:baff:fed1:561f
PF_IN6 =	fdd7:e83e:66bc:211:5054:ff:fe12:3450
PF_OUT6 =	fdd7:e83e:66bc:212:5054:ff:fe12:3450
RT_IN6 =	fdd7:e83e:66bc:212:5054:ff:fe12:3451
RT_OUT6 =	fdd7:e83e:66bc:213:5054:ff:fe12:3451
DST_IN6 =	fdd7:e83e:66bc:213:5054:ff:fe12:3452
RDR_IN6 =	fdd7:e83e:66bc:214::1
d58 1
a58 1
# pass to { $DST_IN/24 $DST_IN6/64 }
d61 1
a61 1
# pass in  to $RDR_IN/24  rdr-to $DST_IN  allow-opts tag rdr
d63 1
a63 1
# pass in  to $RDR_IN6/64 rdr-to $DST_IN6 allow-opts tag rdr
d82 1
a82 1
.for var in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT DST_IN RDR_IN
a87 24
# Make sure that the routing table on the SRC machine is correct.
# All packets must be forwarded to PF target machine.
TARGETS +=	route route6

run-regress-route:
	@@echo '\n======== $@@ ========'
	@@echo Check route SRC_OUT:
	route -n get -inet ${SRC_OUT} | fgrep -q 'interface: lo0'
	@@echo Check route PF_IN:
	route -n get -inet ${PF_IN} | fgrep -q 'if address: ${SRC_OUT}'
.for ip in PF_OUT RT_IN RT_OUT DST_IN RDR_IN
	@@echo Check route ${ip}:
	route -n get -inet ${${ip}} | fgrep -q 'gateway: ${PF_IN}'
.endfor

run-regress-route6:
	@@echo '\n======== $@@ ========'
	@@echo Check route SRC_OUT6:
	route -n get -inet6 ${SRC_OUT6} | fgrep -q 'interface: lo0'
.for ip in PF_OUT RT_IN RT_OUT DST_IN RDR_IN
	@@echo Check route ${ip}6:
	route -n get -inet6 ${${ip}6} | fgrep -q 'gateway: ${PF_IN6}'
.endfor

d91 1
a91 1
# by PF and handled by DST.
d96 1
a96 1
.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT DST_IN RDR_IN
d103 1
a103 1
.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT DST_IN RDR_IN
d115 1
a115 1
.for ip in PF_IN PF_OUT RT_IN RT_OUT DST_IN RDR_IN
d123 1
a123 1
.for ip in PF_IN PF_OUT RT_IN RT_OUT DST_IN RDR_IN
d137 1
a137 1
.for ip in DST_IN RDR_IN
d144 1
a144 1
.for ip in DST_IN RDR_IN
d155 1
a155 1
.for ip in DST_IN RDR_IN
d162 1
a162 1
.for ip in DST_IN RDR_IN
d169 1
a169 1
.for ip in DST_IN RDR_IN
d176 1
a176 1
.for ip in DST_IN RDR_IN
d186 1
a186 1
.for ip in DST_IN RDR_IN
d193 1
a193 1
.for ip in DST_IN RDR_IN
d202 1
a202 1
.for ip in DST_IN RDR_IN
d211 1
a211 1
.for ip in DST_IN RDR_IN
d218 1
a218 1
.for ip in DST_IN RDR_IN
d227 1
a227 1
.for ip in DST_IN RDR_IN
d234 1
a234 1
.for ip in DST_IN RDR_IN
d243 1
a243 1
.for ip in DST_IN RDR_IN
d250 1
a250 1
.for ip in DST_IN RDR_IN
d259 1
a259 1
.for ip in DST_IN RDR_IN
d266 1
a266 1
.for ip in DST_IN RDR_IN
d274 77
@


1.5
log
@Do not write spaces around = in addr.py so it can also be read by
the shell.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.4 2012/07/10 12:45:58 bluhm Exp $
d132 1
a132 1
	-ping6 -n -c 1 -s 1400 -m ${${ip}}
@


1.4
log
@Kill trailing whitespaces.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.3 2012/07/08 21:47:49 bluhm Exp $
d70 3
a72 3
	echo 'SRC_IF = "${SRC_IF}"' >>$@@.tmp
	echo 'SRC_MAC = "${SRC_MAC}"' >>$@@.tmp
	echo 'PF_MAC = "${PF_MAC}"' >>$@@.tmp
d74 2
a75 2
	echo '${var} = "${${var}}"' >>$@@.tmp
	echo '${var}6 = "${${var}6}"' >>$@@.tmp
@


1.3
log
@Add addr.py to CLEANFILES.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.2 2011/09/21 23:48:23 bluhm Exp $
d14 1
a14 1
# DST is reflecting the ping and UDP packets.
@


1.2
log
@Add tests for pf fragment reassembly with all kinds of overlapping.
Some fragments contain invalid data, this must be replaced to
reassemble a valid packet.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.1 2011/09/19 22:45:32 bluhm Exp $
d288 1
a288 1
CLEANFILES +=		*.pyc *.log
@


1.1
log
@Add a test suite to route ip fragments through a box running pf.
You have to setup four machines manually as described in the makefile.
The test uses scapy and python to send ping echo request or udp
echo packets along the routers.  It analyzes the returned ping echo
reply or udp packets or the icmp error packets.
@
text
@d1 1
a1 1
#	$OpenBSD$
d165 1
a165 1
# Chek that checksum of the quoted original packet in icmp is correct.
d194 90
@

