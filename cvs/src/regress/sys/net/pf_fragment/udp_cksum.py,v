head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.2
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.5.0.2
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.2.0.12
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.10
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.2;
locks; strict;
comment	@# @;


1.7
date	2017.01.24.00.32.05;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	4QKh0TWCqHBOD6I0;

1.6
date	2017.01.18.23.03.44;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	CeKCY3OcQDpvUbop;

1.5
date	2016.05.22.22.13.33;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	1AiC2RYVGPeCEPmz;

1.4
date	2015.08.24.23.12.53;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	io7tL4yJ4LeVqmMX;

1.3
date	2014.12.19.21.41.20;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	SeHiTyo2F64te6y4;

1.2
date	2012.07.10.12.45.58;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2011.09.19.22.45.32;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Fix typo in variable name.
@
text
@#!/usr/local/bin/python2.7
# check ip and udp checksum in returned icmp packet

import os
from addr import *
from scapy.all import *

dstaddr=sys.argv[1]
uport=os.getpid() & 0xffff
# inetd ignores UDP packets from privileged port or nfs
if uport < 1024 or uport == 2049:
	uport+=1024
payload="a" * 1472
p=(Ether(src=SRC_MAC, dst=PF_MAC)/IP(flags="DF", src=SRC_OUT, dst=dstaddr)/
    UDP(sport=uport, dport=9)/payload)
ipcksum=IP(str(p.payload)).chksum
print "ipcksum=%#04x" % (ipcksum)
udpcksum=IP(str(p.payload)).payload.chksum
print "udpcksum=%#04x" % (udpcksum)
a=srp1(p, iface=SRC_IF, timeout=2)
if a and a.type == ETH_P_IP and \
    a.payload.proto == 1 and \
    icmptypes[a.payload.payload.type] == 'dest-unreach' and \
    icmpcodes[a.payload.payload.type][a.payload.payload.code] == \
    'fragmentation-needed':
	outeripcksum=a.payload.chksum
	print "outeripcksum=%#04x" % (outeripcksum)
	outercksum=a.payload.payload.chksum
	print "outercksum=%#04x" % (outercksum)
	q=a.payload.payload.payload
	inneripcksum=q.chksum
	print "inneripcksum=%#04x" % (inneripcksum)
	if q.proto == 17:
		innercksum=q.payload.chksum
		print "innercksum=%#04x" % (innercksum)
		if innercksum == udpcksum:
			exit(0)
		print "INNERCKSUM!=UDPCKSUM"
		exit(1)
	print "NO INNER UDP REQUEST"
	exit(2)
print "NO FRAGMENTATION NEEDED"
exit(2)
@


1.6
log
@Do not use privileged or NFS source ports for UDP packets as inetd
ignores such packets.  This should avoid some sporadic failures.
While there, use variable names consistently in all tests.
@
text
@d12 1
a12 1
	port+=1024
@


1.5
log
@Fix tests:  Restrict getpid() to lower 16 bit so that it can still
be used as packet id.  Now scapy calls nexthopmtu with this name
explicitly in icmp structure.
@
text
@d9 4
a12 1
pid=os.getpid() & 0xffff
d15 1
a15 1
    UDP(sport=pid,dport=9)/payload)
@


1.4
log
@Extend the pf forward and fragment tests with a second challenge
for path MTU discovery.  The router behind the pf machine has MTU
1300.  The ICMP packet generated by the router matches the pf state
and is NATed correctly.  Additionally the pf machine itself has an
interface MTU 1400.  So when pf is sending a packet is has to
generate a correct "fragmentation needed" or "packet too big" ICMP
response.  This is done with pf route-to and reply-to.
@
text
@d9 1
a9 1
pid=os.getpid()
@


1.3
log
@Use a simpler expression to check the ether type in scapy.  This
makes the fragment tests work on FreeBSD.  From Ilya Bakulin.
@
text
@d10 1
a10 1
payload="a" * 1452
@


1.2
log
@Kill trailing whitespaces.
@
text
@d18 1
a18 1
if a and a.type == scapy.layers.dot11.ETHER_TYPES.IPv4 and \
@


1.1
log
@Add a test suite to route ip fragments through a box running pf.
You have to setup four machines manually as described in the makefile.
The test uses scapy and python to send ping echo request or udp
echo packets along the routers.  It analyzes the returned ping echo
reply or udp packets or the icmp error packets.
@
text
@d5 1
a5 1
from addr import * 
@

