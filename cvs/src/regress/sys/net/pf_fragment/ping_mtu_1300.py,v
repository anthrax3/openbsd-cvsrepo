head	1.6;
access;
symbols
	OPENBSD_6_0:1.4.0.2
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.2.0.16
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.14
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.12
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.10
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.2;
locks; strict;
comment	@# @;


1.6
date	2017.01.18.23.03.44;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	CeKCY3OcQDpvUbop;

1.5
date	2016.10.20.21.05.59;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	V0KwVY2KraO9zTRW;

1.4
date	2016.05.22.22.13.33;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	1AiC2RYVGPeCEPmz;

1.3
date	2015.08.24.23.12.53;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	io7tL4yJ4LeVqmMX;

1.2
date	2012.07.10.12.45.58;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2011.09.19.22.45.32;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Do not use privileged or NFS source ports for UDP packets as inetd
ignores such packets.  This should avoid some sporadic failures.
While there, use variable names consistently in all tests.
@
text
@#!/usr/local/bin/python2.7
# check wether path mtu to dst is 1300

import os
from addr import *
from scapy.all import *

dstaddr=sys.argv[1]
eid=os.getpid() & 0xffff
hdr=IP(flags="DF", src=SRC_OUT, dst=dstaddr)/ICMP(type='echo-request', id=eid)
payload="a" * (1400 - len(str(hdr)))
ip=hdr/payload
eth=Ether(src=SRC_MAC, dst=PF_MAC)/ip
a=srp1(eth, iface=SRC_IF, timeout=2)

if a is None:
	print "no packet sniffed"
	exit(2)
if a and a.payload.payload.type==3 and a.payload.payload.code==4:
	mtu=a.payload.payload.nexthopmtu
	print "mtu=%d" % (mtu)
	if mtu == 1300:
		exit(0)
	print "MTU!=1300"
	exit(1)
print "MTU=UNKNOWN"
exit(2)
@


1.5
log
@During sniffing filter strictly on icmp6 "packet too big" to avoid
that "neighbor discovery" confuses the test.
@
text
@d9 2
a10 2
pid=os.getpid() & 0xffff
hdr=IP(flags="DF", src=SRC_OUT, dst=dstaddr)/ICMP(id=pid)
@


1.4
log
@Fix tests:  Restrict getpid() to lower 16 bit so that it can still
be used as packet id.  Now scapy calls nexthopmtu with this name
explicitly in icmp structure.
@
text
@d16 3
@


1.3
log
@Extend the pf forward and fragment tests with a second challenge
for path MTU discovery.  The router behind the pf machine has MTU
1300.  The ICMP packet generated by the router matches the pf state
and is NATed correctly.  Additionally the pf machine itself has an
interface MTU 1400.  So when pf is sending a packet is has to
generate a correct "fragmentation needed" or "packet too big" ICMP
response.  This is done with pf route-to and reply-to.
@
text
@d9 1
a9 1
pid=os.getpid()
d17 1
a17 1
	mtu=a.payload.payload.unused
@


1.2
log
@Kill trailing whitespaces.
@
text
@d10 6
a15 3
payload="a" * 1452
a=srp1(Ether(src=SRC_MAC, dst=PF_MAC)/IP(flags="DF", src=SRC_OUT, dst=dstaddr)/
    ICMP(id=pid)/payload, iface=SRC_IF, timeout=2)
@


1.1
log
@Add a test suite to route ip fragments through a box running pf.
You have to setup four machines manually as described in the makefile.
The test uses scapy and python to send ping echo request or udp
echo packets along the routers.  It analyzes the returned ping echo
reply or udp packets or the icmp error packets.
@
text
@d5 1
a5 1
from addr import * 
@

