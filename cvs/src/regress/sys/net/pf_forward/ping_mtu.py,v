head	1.7;
access;
symbols
	OPENBSD_6_0:1.5.0.2
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.2.0.16
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.14
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.12
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.10
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2;
locks; strict;
comment	@# @;


1.7
date	2017.01.18.23.03.44;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	CeKCY3OcQDpvUbop;

1.6
date	2016.10.20.21.05.59;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	V0KwVY2KraO9zTRW;

1.5
date	2016.05.22.22.13.33;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	1AiC2RYVGPeCEPmz;

1.4
date	2015.09.11.15.57.37;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	7dkMbqm14825sRDk;

1.3
date	2015.08.24.23.12.53;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	io7tL4yJ4LeVqmMX;

1.2
date	2012.07.10.16.52.45;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2012.07.10.12.43.54;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Do not use privileged or NFS source ports for UDP packets as inetd
ignores such packets.  This should avoid some sporadic failures.
While there, use variable names consistently in all tests.
@
text
@#!/usr/local/bin/python2.7
# check wether path mtu to dst is as expected

import os
from addr import *
from scapy.all import *

# usage: ping_mtu src dst size icmp-size

srcaddr=sys.argv[1]
dstaddr=sys.argv[2]
size=int(sys.argv[3])
expect=int(sys.argv[4])
eid=os.getpid() & 0xffff
hdr=IP(flags="DF", src=srcaddr, dst=dstaddr)/ICMP(type='echo-request', id=eid)
payload="a" * (size - len(str(hdr)))
ip=hdr/payload
iplen=IP(str(ip)).len
eth=Ether(src=SRC_MAC, dst=PF_MAC)/ip
a=srp1(eth, iface=SRC_IF, timeout=2)

if a is None:
	print "no packet sniffed"
	exit(2)
if a and a.payload.payload.type==3 and a.payload.payload.code==4:
	mtu=a.payload.payload.nexthopmtu
	print "mtu=%d" % (mtu)
	if mtu != expect:
		print "MTU!=%d" % (expect)
		exit(1)
	iip=a.payload.payload.payload
	iiplen=iip.len
	if iiplen != iplen:
		print "inner IP len %d!=%d" % (iiplen, iplen)
		exit(1)
	isrc=iip.src
	if isrc != srcaddr:
		print "inner IP src %d!=%d" % (isrc, srcaddr)
		exit(1)
	idst=iip.dst
	if idst != dstaddr:
		print "inner IP dst %d!=%d" % (idst, dstaddr)
		exit(1)
	exit(0)
print "MTU=UNKNOWN"
exit(2)
@


1.6
log
@During sniffing filter strictly on icmp6 "packet too big" to avoid
that "neighbor discovery" confuses the test.
@
text
@d14 2
a15 2
pid=os.getpid() & 0xffff
hdr=IP(flags="DF", src=srcaddr, dst=dstaddr)/ICMP(id=pid)
@


1.5
log
@Fix tests:  Restrict getpid() to lower 16 bit so that it can still
be used as packet id.  Now scapy calls nexthopmtu with this name
explicitly in icmp structure.
@
text
@d22 3
@


1.4
log
@fter fixing poll(2) semantics in dynamic TCP buffer size update,
making netcat non-blocking and fixing ip6_forward() ICMP6 checksum,
this test can be made more aggressive.  Delete the path MTU route
before sending TCP streams through the pf firewall.  This checks
that PMTU discovery works with outgoing interface MTU and router
MTU.
Test IPv4 and IPv6 protocols ICMP echo, UDP, TCP with pf nat-to,
rdr-to, af-to, route-to, reply-to.  Some af-to cases seem to be
broken.
@
text
@d14 1
a14 1
pid=os.getpid()
d23 1
a23 1
	mtu=a.payload.payload.unused
@


1.3
log
@Extend the pf forward and fragment tests with a second challenge
for path MTU discovery.  The router behind the pf machine has MTU
1300.  The ICMP packet generated by the router matches the pf state
and is NATed correctly.  Additionally the pf machine itself has an
interface MTU 1400.  So when pf is sending a packet is has to
generate a correct "fragmentation needed" or "packet too big" ICMP
response.  This is done with pf route-to and reply-to.
@
text
@d28 12
a39 3
	len=a.payload.payload.payload.len
	if len != iplen:
		print "IP len %d!=%d" % (len, iplen)
@


1.2
log
@Add a subtest to the MTU ping that checks wether the ip length of
the original packet and the icmp quoted packet are the same.
@
text
@d8 6
a13 2
dstaddr=sys.argv[1]
expect=int(sys.argv[2])
d15 3
a17 2
payload="a" * 1452
ip=IP(flags="DF", src=SRC_OUT, dst=dstaddr)/ICMP(id=pid)/payload
d21 1
@


1.1
log
@Add a test suite to route ip packets through a box running pf.  You
have to setup four machines manually as described in the makefile.
The test uses netcat and scapy to send ping or udp echo packets or
tcp streams along the routers.  It analyzes the returned reply or
icmp error packets.  It tests the forward and net/rdr and net64
paths.
@
text
@d12 4
a15 2
a=srp1(Ether(src=SRC_MAC, dst=PF_MAC)/IP(flags="DF", src=SRC_OUT, dst=dstaddr)/
    ICMP(id=pid)/payload, iface=SRC_IF, timeout=2)
d19 8
a26 4
	if mtu == expect:
		exit(0)
	print "MTU!=%d" % (expect)
	exit(1)
@

