head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.4
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.8.0.6
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.3.0.10
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3;
locks; strict;
comment	@# @;


1.24
date	2017.07.07.23.15.27;	author bluhm;	state Exp;
branches;
next	1.23;
commitid	o44bwTTe61BAwrkn;

1.23
date	2017.05.15.13.10.33;	author bluhm;	state Exp;
branches;
next	1.22;
commitid	F53gPwiBWPSvmh75;

1.22
date	2016.11.28.23.19.18;	author bluhm;	state Exp;
branches;
next	1.21;
commitid	F3lHRlMhAFI3pe5t;

1.21
date	2016.11.09.14.43.35;	author bluhm;	state Exp;
branches;
next	1.20;
commitid	oZ2u0ear6lrRNG7u;

1.20
date	2016.11.09.13.08.51;	author bluhm;	state Exp;
branches;
next	1.19;
commitid	d3jbgDQBiEQfUGjR;

1.19
date	2016.11.09.12.43.36;	author bluhm;	state Exp;
branches;
next	1.18;
commitid	KmAoTmuhuGgcwJup;

1.18
date	2016.10.26.19.14.28;	author bluhm;	state Exp;
branches;
next	1.17;
commitid	JjcJUhd1TMoEJmHn;

1.17
date	2016.10.19.14.31.19;	author tb;	state Exp;
branches;
next	1.16;
commitid	r0ZXVh0JShv1yn7K;

1.16
date	2016.09.02.21.30.34;	author bluhm;	state Exp;
branches;
next	1.15;
commitid	sbZCO4zszQKrda5x;

1.15
date	2016.08.31.22.44.29;	author bluhm;	state Exp;
branches;
next	1.14;
commitid	wQLTIpNOdX9pBNCe;

1.14
date	2015.11.01.21.30.00;	author bluhm;	state Exp;
branches;
next	1.13;
commitid	YhekLUbUv3XdjNpb;

1.13
date	2015.09.11.15.57.37;	author bluhm;	state Exp;
branches;
next	1.12;
commitid	7dkMbqm14825sRDk;

1.12
date	2015.08.24.23.12.53;	author bluhm;	state Exp;
branches;
next	1.11;
commitid	io7tL4yJ4LeVqmMX;

1.11
date	2015.08.17.22.06.50;	author bluhm;	state Exp;
branches;
next	1.10;
commitid	dA9USfvUvCKUBfV4;

1.10
date	2015.07.21.17.51.50;	author bluhm;	state Exp;
branches;
next	1.9;
commitid	rrWHLPuCICxdemKP;

1.9
date	2015.07.20.20.53.43;	author bluhm;	state Exp;
branches;
next	1.8;
commitid	HuFAc4EkWhEVIDnk;

1.8
date	2014.07.18.23.54.55;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	q1ZGA4d2w2OgeX39;

1.7
date	2014.07.13.01.47.20;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	aUlBJO64qj5WG56U;

1.6
date	2014.07.12.22.43.31;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	8kciCoVC9NsnDpq4;

1.5
date	2014.07.12.21.41.49;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	ZzV1CGylzBHJz2cs;

1.4
date	2014.07.12.21.00.46;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	kRAUZYkP8QlyLbU8;

1.3
date	2012.07.10.16.58.29;	author bluhm;	state Exp;
branches;
next	1.2;

1.2
date	2012.07.10.16.52.45;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2012.07.10.12.43.54;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Remove useless make depend targets.
@
text
@#	$OpenBSD: Makefile,v 1.23 2017/05/15 13:10:33 bluhm Exp $

# The following ports must be installed:
#
# python-2.7          interpreted object-oriented programming language
# py-libdnet          python interface to libdnet
# scapy               powerful interactive packet manipulation in python

.if ! (make(clean) || make(cleandir) || make(obj))
# Check wether all required python packages are installed.  If some
# are missing print a warning and skip the tests, but do not fail.
PYTHON_IMPORT != python2.7 -c 'from scapy.all import *' 2>&1 || true
.endif
.if ! empty(PYTHON_IMPORT)
regress:
	@@echo '${PYTHON_IMPORT}'
	@@echo install python and the scapy module for additional tests
	@@echo SKIPPED
.endif

# This test needs a manual setup of four machines
# The setup is the same as for regress/sys/net/pf_fragment
# Set up machines: SRC PF RT ECO
# SRC is the machine where this makefile is running.
# PF is running OpenBSD forwarding through pf, it is the test target.
# RT is a router forwarding packets, maximum MTU is 1300.
# ECO is reflecting the ping and UDP and TCP echo packets.
# RDR does not exist, PF redirects the traffic to ECO.
# AF does not exist, PF translates address family and sends to ECO.
# RTT addresses exist on ECO, PF has no route and must use route-to RT
# RPT addresses exist on SRC, PF has no route and must use reply-to SRC
#
# +---+   0   +--+   1   +--+   2   +---+ 3
# |SRC| ----> |PF| ----> |RT| ----> |ECO| 7
# +---+ 8     +--+       +--+       +---+ 9
#     out    in  out    in  out    in   out
#
# 4 +---+ 5   6 +--+   7 +---+   +---+ 8
#   |RDR|       |AF|     |RTT|   |RPT|
#   +---+       +--+     +---+   +---+
#  in   out    in       in           out

# Configure Addresses on the machines, there must be routes for the
# networks.  Adapt interface and addresse variables to your local
# setup.  To control the remote machine you need a hostname for
# ssh to log in.
# You must have an anchor "regress" for the divert rules in the pf.conf
# of the PF machine.  The kernel of the PF machine gets testet.
#
# Run make check-setup to see if you got the setup correct.

SRC_IF ?=	tap0
SRC_MAC ?=	fe:e1:ba:d1:0a:dc
PF_IFIN ?=	vio0
PF_IFOUT ?=	vio1
PF_MAC ?=	52:54:00:12:34:50
PF_SSH ?=
RT_SSH ?=
ECO_SSH ?=

SRC_OUT ?=	10.188.210.10
PF_IN ?=	10.188.210.50
PF_OUT ?=	10.188.211.50
RT_IN ?=	10.188.211.51
RT_OUT ?=	10.188.212.51
ECO_IN ?=	10.188.212.52
ECO_OUT ?=	10.188.213.52
RDR_IN ?=	10.188.214.188
RDR_OUT ?=	10.188.215.188
AF_IN ?=	10.188.216.82		# /24 must be dec(ECO_IN6/120)
RTT_IN ?=	10.188.217.52
RPT_OUT ?=	10.188.218.10

SRC_OUT6 ?=	fdd7:e83e:66bc:210:fce1:baff:fed1:561f
PF_IN6 ?=	fdd7:e83e:66bc:210:5054:ff:fe12:3450
PF_OUT6 ?=	fdd7:e83e:66bc:211:5054:ff:fe12:3450
RT_IN6 ?=	fdd7:e83e:66bc:211:5054:ff:fe12:3451
RT_OUT6 ?=	fdd7:e83e:66bc:212:5054:ff:fe12:3451
ECO_IN6 ?=	fdd7:e83e:66bc:212:5054:ff:fe12:3452
ECO_OUT6 ?=	fdd7:e83e:66bc:213:5054:ff:fe12:3452
RDR_IN6 ?=	fdd7:e83e:66bc:214::188
RDR_OUT6 ?=	fdd7:e83e:66bc:215::188
AF_IN6 ?=	fdd7:e83e:66bc:216::34	# /120 must be hex(ECO_IN/24)
RTT_IN6 ?=	fdd7:e83e:66bc:217:5054:ff:fe12:3452
RPT_OUT6 ?=	fdd7:e83e:66bc:1218:fce1:baff:fed1:561f

.if empty (PF_SSH) || empty (RT_SSH) || empty (ECO_SSH)
regress:
	@@echo this tests needs three remote machines to operate on
	@@echo PF_SSH RT_SSH ECO_SSH are empty
	@@echo fill out these variables for additional tests, then
	@@echo check wether your test machines are set up properly
	@@echo SKIPPED
.endif

.MAIN: all

.if ! empty (PF_SSH)
.if make (regress) || make (all)
.BEGIN: pf.conf addr.py
	@@echo
	${SUDO} true
	ssh -t ${PF_SSH} ${SUDO} true
	rm -f stamp-pfctl
.endif
.endif

# Create python include file containing the addresses.
addr.py: Makefile
	rm -f $@@ $@@.tmp
	echo 'SRC_IF="${SRC_IF}"' >>$@@.tmp
	echo 'SRC_MAC="${SRC_MAC}"' >>$@@.tmp
	echo 'PF_IFIN="${PF_IFIN}"' >>$@@.tmp
	echo 'PF_IFOUT="${PF_IFOUT}"' >>$@@.tmp
	echo 'PF_MAC="${PF_MAC}"' >>$@@.tmp
.for var in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN ECO_OUT RDR_IN RDR_OUT\
    AF_IN RTT_IN RPT_OUT
	echo '${var}="${${var}}"' >>$@@.tmp
	echo '${var}6="${${var}6}"' >>$@@.tmp
.endfor
	mv $@@.tmp $@@

# Load the pf rules into the kernel of the PF machine.
# XXX pfctl does not replace variables after @@.
stamp-pfctl: addr.py pf.conf
	cat addr.py ${.CURDIR}/pf.conf | pfctl -n -f -
	cat addr.py ${.CURDIR}/pf.conf | \
	    sed 's/@@$$PF_IFIN /@@${PF_IFIN} /;s/@@$$PF_IFOUT /@@${PF_IFOUT} /' | \
	    ssh ${PF_SSH} ${SUDO} pfctl -a regress -f -
	@@date >$@@

# Set variables so that make runs with and without obj directory.
# Only do that if necessary to keep visible output short.
.if ${.CURDIR} == ${.OBJDIR}
PYTHON =	python2.7 ./
.else
PYTHON =	PYTHONPATH=${.OBJDIR} python2.7 ${.CURDIR}/
.endif

.for inet in inet inet6

# Ping all addresses.  This ensures that the IP addresses are configured
# and all routing table are set up to allow bidirectional packet flow.
# Note that RDR does not exist physically.  So this traffic is rewritten
# by PF and handled by ECO.

.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN ECO_OUT RDR_IN RDR_OUT\
    AF_IN RTT_IN RPT_OUT
TARGETS +=	ping-${inet}-${ip}
run-regress-ping-${inet}-${ip}: stamp-pfctl
	@@echo '\n======== $@@ ========'
	@@echo Check ping ${ip}${inet:S/inet//}:
.if "RPT_OUT" == ${ip}
	ping${inet:S/inet//} -n -c 1 -I ${${ip}${inet:S/inet//}}\
	    ${ECO_IN${inet:S/inet//}}
.else
	ping${inet:S/inet//} -n -c 1 ${${ip}${inet:S/inet//}}
.endif
.endfor # ip

.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN RTT_IN RPT_OUT

# Send a large IPv4/ICMP-Echo-Request packet with enabled DF bit and
# parse response packet to determine MTU of the packet filter.  The
# outgoing MTU of PF has to be 1400 octets.  Packet size is 1500.
# Check that the IP length of the original packet and the ICMP
# quoted packet are the same.

TARGETS +=	ping-mtu-1400-${inet}-${ip}
run-regress-ping-mtu-1400-${inet}-${ip}: stamp-pfctl
	@@echo '\n======== $@@ ========'
	@@echo Check path MTU to ${ip}${inet:S/inet//} is 1400
.if "RPT_OUT" == ${ip}
	${SUDO} ${PYTHON}ping${inet:S/inet//}_mtu.py ${${ip}${inet:S/inet//}}\
	    ${ECO_IN${inet:S/inet//}} 1500 1400
.elif "AF_IN" == ${ip}
.if "inet" == ${inet}
	${SUDO} ${PYTHON}ping_mtu.py ${SRC_OUT} ${${ip}} 1500 1380
.else
	${SUDO} ${PYTHON}ping6_mtu.py ${SRC_OUT6} ${${ip}6} 1500 1420
.endif
.else
	${SUDO} ${PYTHON}ping${inet:S/inet//}_mtu.py ${SRC_OUT${inet:S/inet//}}\
	    ${${ip}${inet:S/inet//}} 1500 1400
.endif

# Send a large IPv4/ICMP-Echo-Request packet with enabled DF bit and
# parse response packet to determine MTU of the router.  The MTU has
# to be 1300 octets.  The MTU has to be defined at out interface of
# the router RT before.  Packet size is 1400 to pass PF MTU.
# Check that the IP length of the original packet and the ICMP
# quoted packet are the same.

TARGETS +=	ping-mtu-1300-${inet}-${ip}
run-regress-ping-mtu-1300-${inet}-${ip}: stamp-pfctl
	@@echo '\n======== $@@ ========'
	@@echo Check path MTU from ${ip}${inet:S/inet//} is 1300
.if "RPT_OUT" == ${ip}
	${SUDO} ${PYTHON}ping${inet:S/inet//}_mtu.py ${${ip}${inet:S/inet//}}\
	    ${ECO_IN${inet:S/inet//}} 1400 1300
.elif "AF_IN" == ${ip}
.if "inet" == ${inet}
	${SUDO} ${PYTHON}ping_mtu.py ${SRC_OUT} ${${ip}} 1380 1280
.else
	${SUDO} ${PYTHON}ping6_mtu.py ${SRC_OUT6} ${${ip}6} 1420 1320
.endif
.else
	${SUDO} ${PYTHON}ping${inet:S/inet//}_mtu.py ${SRC_OUT${inet:S/inet//}}\
	    ${${ip}${inet:S/inet//}} 1400 1300
.endif

# Send one UDP echo port 7 packet to all destination addresses with netcat.
# The response must arrive in 1 second.

TARGETS +=	udp-${inet}-${ip}
run-regress-udp-${inet}-${ip}: stamp-pfctl
	@@echo '\n======== $@@ ========'
	@@echo Check UDP ${ip${inet:S/inet//}}:
.if "RPT_OUT" == ${ip}
	echo $$$$ | nc -n -u -W 1 -w 3 -s ${${ip}${inet:S/inet//}}\
	    ${ECO_IN${inet:S/inet//}} 7 | grep $$$$
.else
	echo $$$$ | nc -n -u -W 1 -w 3 ${${ip}${inet:S/inet//}} 7 | grep $$$$
.endif

# Send a data stream to TCP echo port 7 to all destination addresses
# with netcat.  Use enough data to make sure PMTU discovery works.
# Count the reflected bytes and compare with the transmitted ones.
# Delete host route before test to trigger PMTU discovery.

TARGETS +=	tcp-${inet}-${ip}
run-regress-tcp-${inet}-${ip}: stamp-pfctl
	@@echo '\n======== $@@ ========'
	@@echo Check tcp ${ip}${inet:S/inet//}:
	${SUDO} route -n delete -host -inet ${${ip}${inet:S/inet//}} || true
.if "RPT_OUT" == ${ip}
	openssl rand 200000 | nc -n -N -w 10 -s ${${ip}${inet:S/inet//}}\
	    ${ECO_IN${inet:S/inet//}} 7 | wc -c | grep '200000$$'
.else
	openssl rand 200000 | nc -n -N -w 10 ${${ip}${inet:S/inet//}} 7 |\
	    wc -c | grep '200000$$'
.endif

.endfor # ip

# Run traceroute with ICMP and UDP to all destination addresses.
# Expect three hops in output and that every probe has a response.

TRACEROUTE_CHECK =	awk \
    'BEGIN{ x=0 } \
    { print $$0 } \
    { n=$$1 } \
    /\*/{ x++ } \
    END{ if (n!=3) { print "hopcount is not 3: "n; exit 1 } } \
    END{ if (x!=0) { print "unanswered probes: "x; exit 1 } }'

.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN RTT_IN RPT_OUT
.for proto in icmp udp
run-regress-traceroute-${proto}-${inet}-RPT_OUT:
	@@echo '\n======== $@@ ========'
	@@echo 'RPT_OUT is broken with PF ttl.'
	@@echo DISABLED

TARGETS +=	traceroute-${proto}-${inet}-${ip}
run-regress-traceroute-${proto}-${inet}-${ip}: stamp-pfctl
	@@echo '\n======== $@@ ========'
	@@echo Check traceroute ${proto} ${ip${inet:S/inet//}}:
.if "RPT_OUT" == ${ip}
	traceroute${inet:S/inet//} ${proto:S/icmp/-I/:S/udp//}
	    -s ${${ip}${inet:S/inet//}} ${ECO_IN${inet:S/inet//}} |\
	    ${TRACEROUTE_CHECK}
.else
	traceroute${inet:S/inet//} ${proto:S/icmp/-I/:S/udp//}\
	    ${${ip}${inet:S/inet//}} | ${TRACEROUTE_CHECK}
.endif
.endfor # proto
.endfor # ip

.endfor # inet

REGRESS_TARGETS =	${TARGETS:S/^/run-regress-/}

CLEANFILES +=		addr.py *.pyc *.log stamp-*

.PHONY: check-setup

# Check wether the address, route and remote setup is correct
check-setup: check-setup-src check-setup-pf check-setup-rt check-setup-eco

check-setup-src:
	@@echo '\n======== $@@ ========'
.for ip in SRC_OUT RPT_OUT
	ping -n -c 1 ${${ip}}  # ${ip}
	route -n get -inet ${${ip}} | grep -q 'flags: .*LOCAL'  # ${ip}
.endfor
	ping -n -c 1 ${PF_IN}  # PF_IN
	route -n get -inet ${PF_IN} | fgrep -q 'interface: ${SRC_IF}' \
	    # PF_IN SRC_IF
.for ip in PF_OUT RT_IN RT_OUT ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN RTT_IN
	route -n get -inet ${${ip}} | fgrep -q 'gateway: ${PF_IN}' \
	    # ${ip} PF_IN
.endfor
.for ip in SRC_OUT RPT_OUT
	ping6 -n -c 1 ${${ip}6}  # ${ip}6
	route -n get -inet6 ${${ip}6} | grep -q 'flags: .*LOCAL'  # ${ip}6
.endfor
	ping6 -n -c 1 ${PF_IN6}  # PF_IN6
	route -n get -inet6 ${PF_IN6} | fgrep -q 'interface: ${SRC_IF}' \
	    # PF_IN6 SRC_IF
.for ip in PF_OUT RT_IN RT_OUT ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN RTT_IN
	route -n get -inet6 ${${ip}6} | fgrep -q 'gateway: ${PF_IN6}' \
	    # ${ip}6 PF_IN6
.endfor

check-setup-pf:
	@@echo '\n======== $@@ ========'
	ssh ${PF_SSH} ping -n -c 1 ${PF_IN}  # PF_IN
	ssh ${PF_SSH} route -n get -inet ${PF_IN} | grep -q 'flags: .*LOCAL' \
	    # PF_IN
	ssh ${PF_SSH} ping -n -c 1 ${SRC_OUT}  # SRC_OUT
	ssh ${PF_SSH} ping -n -c 1 ${PF_OUT}  # PF_OUT
	ssh ${PF_SSH} route -n get -inet ${PF_OUT} | grep -q 'flags: .*LOCAL' \
	    # PF_OUT
	ssh ${PF_SSH} ping -n -c 1 ${RT_IN}  # RT_IN
.for ip in RT_OUT ECO_IN ECO_OUT
	ssh ${PF_SSH} route -n get -inet ${${ip}} |\
	    fgrep -q 'gateway: ${RT_IN}'  # ${ip} RT_IN
.endfor
.for ip in RTT_IN RPT_OUT
	ssh ${PF_SSH} route -n get -inet ${${ip}} | grep -q 'flags: .*REJECT' \
	    # ${ip} reject
.endfor
	ssh ${PF_SSH} ping6 -n -c 1 ${PF_IN6}  # PF_IN6
	ssh ${PF_SSH} route -n get -inet6 ${PF_IN6} | grep -q 'flags: .*LOCAL' \
	    # PF_IN6
	ssh ${PF_SSH} ping6 -n -c 1 ${SRC_OUT6}  # SRC_OUT6
	ssh ${PF_SSH} ping6 -n -c 1 ${PF_OUT6}  # PF_OUT6
	ssh ${PF_SSH} route -n get -inet6 ${PF_OUT6} |\
	    grep -q 'flags: .*LOCAL'  # PF_OUT6
	ssh ${PF_SSH} ping6 -n -c 1 ${RT_IN6}  # RT_IN6
.for ip in RT_OUT ECO_IN ECO_OUT
	ssh ${PF_SSH} route -n get -inet6 ${${ip}6} |\
	    fgrep -q 'gateway: ${RT_IN6}'  # ${ip}6 RT_IN6
.endfor
.for ip in RTT_IN RPT_OUT
	ssh ${PF_SSH} route -n get -inet6 ${${ip}6} |\
	    grep -q 'flags: .*REJECT'  # ${ip}6 reject
.endfor
	ssh ${PF_SSH} ${SUDO} pfctl -sr | grep '^anchor "regress" all$$'
	ssh ${PF_SSH} ${SUDO} pfctl -si | grep '^Status: Enabled '
	ssh ${PF_SSH} sysctl net.inet.ip.forwarding | fgrep =1
	ssh ${PF_SSH} sysctl net.inet6.ip6.forwarding | fgrep =1
	ssh ${PF_SSH} ifconfig ${PF_IFOUT} | fgrep 'mtu 1400'

check-setup-rt:
	@@echo '\n======== $@@ ========'
	ssh ${RT_SSH} ping -n -c 1 ${RT_IN}  # RT_IN
	ssh ${RT_SSH} route -n get -inet ${RT_IN} | grep -q 'flags: .*LOCAL' \
	    # RT_IN
	ssh ${RT_SSH} ping -n -c 1 ${PF_OUT}  # PF_OUT
.for ip in PF_IN SRC_OUT RPT_OUT
	ssh ${RT_SSH} route -n get -inet ${${ip}} |\
	    fgrep -q 'gateway: ${PF_OUT}'  # ${ip} PF_OUT
.endfor
	ssh ${RT_SSH} ping -n -c 1 ${RT_OUT}  # RT_OUT
	ssh ${RT_SSH} route -n get -inet ${RT_OUT} | grep -q 'flags: .*LOCAL' \
	    # RT_OUT
	ssh ${RT_SSH} ping -n -c 1 ${ECO_IN}  # ECO_IN
.for ip in ECO_OUT RTT_IN
	ssh ${RT_SSH} route -n get -inet ${${ip}} |\
	    fgrep -q 'gateway: ${ECO_IN}'  # ${ip} ECO_IN
.endfor
	ssh ${RT_SSH} ping6 -n -c 1 ${RT_IN6}  # RT_IN6
	ssh ${RT_SSH} route -n get -inet6 ${RT_IN6} | grep -q 'flags: .*LOCAL' \
	    # RT_IN6
	ssh ${RT_SSH} ping6 -n -c 1 ${PF_OUT6}  # PF_OUT6
.for ip in PF_IN SRC_OUT RPT_OUT
	ssh ${RT_SSH} route -n get -inet6 ${${ip}6} |\
	    fgrep -q 'gateway: ${PF_OUT6}'  # ${ip}6 PF_OUT6
.endfor
	ssh ${RT_SSH} ping6 -n -c 1 ${RT_OUT6}  # RT_OUT6
	ssh ${RT_SSH} route -n get -inet6 ${RT_OUT6} |\
	    grep -q 'flags: .*LOCAL'  # RT_OUT6
	ssh ${RT_SSH} ping6 -n -c 1 ${ECO_IN6}  # ECO_IN6
.for ip in ECO_OUT RTT_IN
	ssh ${RT_SSH} route -n get -inet6 ${${ip}6} |\
	    fgrep -q 'gateway: ${ECO_IN6}'  # ${ip}6 ECO_IN6
.endfor
	ssh ${RT_SSH} sysctl net.inet.ip.forwarding | fgrep =1
	ssh ${RT_SSH} sysctl net.inet6.ip6.forwarding | fgrep =1
	ssh ${RT_SSH} ifconfig | fgrep 'mtu 1300'

check-setup-eco:
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN ECO_OUT RTT_IN
	ssh ${ECO_SSH} ping -n -c 1 ${${ip}}  # ${ip}
	ssh ${ECO_SSH} route -n get -inet ${${ip}} | grep -q 'flags: .*LOCAL' \
	    # ${ip}
.endfor
	ssh ${ECO_SSH} ping -n -c 1 ${RT_OUT}  # RT_OUT
.for ip in RT_IN PF_OUT PF_IN SRC_OUT RPT_OUT
	ssh ${ECO_SSH} route -n get -inet ${${ip}} |\
	    fgrep -q 'gateway: ${RT_OUT}'  # ${ip} RT_OUT
.endfor
.for ip in ECO_IN ECO_OUT RTT_IN
	ssh ${ECO_SSH} ping6 -n -c 1 ${${ip}6}  # ${ip}6
	ssh ${ECO_SSH} route -n get -inet6 ${${ip}6} |\
	    grep -q 'flags: .*LOCAL'  # ${ip}6
.endfor
	ssh ${ECO_SSH} ping6 -n -c 1 ${RT_OUT6}  # RT_OUT6
.for ip in RT_IN PF_OUT PF_IN SRC_OUT RPT_OUT
	ssh ${ECO_SSH} route -n get -inet6 ${${ip}6} |\
	    fgrep -q 'gateway: ${RT_OUT6}'  # ${ip}6 RT_OUT6
.endfor
.for inet in inet inet6
.for proto in udp tcp
	ssh ${ECO_SSH} netstat -na -f ${inet} -p ${proto} | fgrep ' *.7 '
.endfor
.endfor
.for ip in ECO_IN ECO_OUT RTT_IN
	ssh ${ECO_SSH} netstat -nav -f inet -p udp | fgrep ' ${${ip}}.7 '
	ssh ${ECO_SSH} netstat -nav -f inet6 -p udp | fgrep ' ${${ip}6}.7 '
.endfor

.include <bsd.regress.mk>
@


1.23
log
@Use netcat options -n, -W, -w to simplify test.  Wrap long lines.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.22 2016/11/28 23:19:18 bluhm Exp $
a106 2

depend: addr.py
@


1.22
log
@Enable the pmtu and traceroute subtests with af-to.  pf has been
fixed now.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.21 2016/11/09 14:43:35 bluhm Exp $
d118 2
a119 1
.for var in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN RTT_IN RPT_OUT
d149 2
a150 1
.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN RTT_IN RPT_OUT
d156 2
a157 1
	ping${inet:S/inet//} -n -c 1 -I ${${ip}${inet:S/inet//}} ${ECO_IN${inet:S/inet//}}
d176 2
a177 1
	${SUDO} ${PYTHON}ping${inet:S/inet//}_mtu.py ${${ip}${inet:S/inet//}} ${ECO_IN${inet:S/inet//}} 1500 1400
d185 2
a186 1
	${SUDO} ${PYTHON}ping${inet:S/inet//}_mtu.py ${SRC_OUT${inet:S/inet//}} ${${ip}${inet:S/inet//}} 1500 1400
d201 2
a202 1
	${SUDO} ${PYTHON}ping${inet:S/inet//}_mtu.py ${${ip}${inet:S/inet//}} ${ECO_IN${inet:S/inet//}} 1400 1300
d210 2
a211 1
	${SUDO} ${PYTHON}ping${inet:S/inet//}_mtu.py ${SRC_OUT${inet:S/inet//}} ${${ip}${inet:S/inet//}} 1400 1300
d222 2
a223 1
	( echo $$$$ | nc -u -s ${${ip}${inet:S/inet//}} ${ECO_IN${inet:S/inet//}} 7 & sleep 1; kill $$! ) | grep $$$$
d225 1
a225 1
	( echo $$$$ | nc -u ${${ip}${inet:S/inet//}} 7 & sleep 1; kill $$! ) | grep $$$$
d239 2
a240 1
	openssl rand 200000 | nc -N -s ${${ip}${inet:S/inet//}} ${ECO_IN${inet:S/inet//}} 7 | wc -c | grep '200000$$'
d242 2
a243 1
	openssl rand 200000 | nc -N ${${ip}${inet:S/inet//}} 7 | wc -c | grep '200000$$'
d271 3
a273 1
	traceroute${inet:S/inet//} ${proto:S/icmp/-I/:S/udp//} -s ${${ip}${inet:S/inet//}} ${ECO_IN${inet:S/inet//}} | ${TRACEROUTE_CHECK}
d275 2
a276 1
	traceroute${inet:S/inet//} ${proto:S/icmp/-I/:S/udp//} ${${ip}${inet:S/inet//}} | ${TRACEROUTE_CHECK}
d299 2
a300 1
	route -n get -inet ${PF_IN} | fgrep -q 'interface: ${SRC_IF}'  # PF_IN SRC_IF
d302 2
a303 1
	route -n get -inet ${${ip}} | fgrep -q 'gateway: ${PF_IN}'  # ${ip} PF_IN
d310 2
a311 1
	route -n get -inet6 ${PF_IN6} | fgrep -q 'interface: ${SRC_IF}'  # PF_IN6 SRC_IF
d313 2
a314 1
	route -n get -inet6 ${${ip}6} | fgrep -q 'gateway: ${PF_IN6}'  # ${ip}6 PF_IN6
d320 2
a321 1
	ssh ${PF_SSH} route -n get -inet ${PF_IN} | grep -q 'flags: .*LOCAL'  # PF_IN
d324 2
a325 1
	ssh ${PF_SSH} route -n get -inet ${PF_OUT} | grep -q 'flags: .*LOCAL'  # PF_OUT
d328 2
a329 1
	ssh ${PF_SSH} route -n get -inet ${${ip}} | fgrep -q 'gateway: ${RT_IN}'  # ${ip} RT_IN
d332 2
a333 1
	ssh ${PF_SSH} route -n get -inet ${${ip}} | grep -q 'flags: .*REJECT'  # ${ip} reject
d336 2
a337 1
	ssh ${PF_SSH} route -n get -inet6 ${PF_IN6} | grep -q 'flags: .*LOCAL'  # PF_IN6
d340 2
a341 1
	ssh ${PF_SSH} route -n get -inet6 ${PF_OUT6} | grep -q 'flags: .*LOCAL'  # PF_OUT6
d344 2
a345 1
	ssh ${PF_SSH} route -n get -inet6 ${${ip}6} | fgrep -q 'gateway: ${RT_IN6}'  # ${ip}6 RT_IN6
d348 2
a349 1
	ssh ${PF_SSH} route -n get -inet6 ${${ip}6} | grep -q 'flags: .*REJECT'  # ${ip}6 reject
d360 2
a361 1
	ssh ${RT_SSH} route -n get -inet ${RT_IN} | grep -q 'flags: .*LOCAL'  # RT_IN
d364 2
a365 1
	ssh ${RT_SSH} route -n get -inet ${${ip}} | fgrep -q 'gateway: ${PF_OUT}'  # ${ip} PF_OUT
d368 2
a369 1
	ssh ${RT_SSH} route -n get -inet ${RT_OUT} | grep -q 'flags: .*LOCAL'  # RT_OUT
d372 2
a373 1
	ssh ${RT_SSH} route -n get -inet ${${ip}} | fgrep -q 'gateway: ${ECO_IN}'  # ${ip} ECO_IN
d376 2
a377 1
	ssh ${RT_SSH} route -n get -inet6 ${RT_IN6} | grep -q 'flags: .*LOCAL'  # RT_IN6
d380 2
a381 1
	ssh ${RT_SSH} route -n get -inet6 ${${ip}6} | fgrep -q 'gateway: ${PF_OUT6}'  # ${ip}6 PF_OUT6
d384 2
a385 1
	ssh ${RT_SSH} route -n get -inet6 ${RT_OUT6} | grep -q 'flags: .*LOCAL'  # RT_OUT6
d388 2
a389 1
	ssh ${RT_SSH} route -n get -inet6 ${${ip}6} | fgrep -q 'gateway: ${ECO_IN6}'  # ${ip}6 ECO_IN6
d399 2
a400 1
	ssh ${ECO_SSH} route -n get -inet ${${ip}} | grep -q 'flags: .*LOCAL'  # ${ip}
d404 2
a405 1
	ssh ${ECO_SSH} route -n get -inet ${${ip}} | fgrep -q 'gateway: ${RT_OUT}'  # ${ip} RT_OUT
d409 2
a410 1
	ssh ${ECO_SSH} route -n get -inet6 ${${ip}6} | grep -q 'flags: .*LOCAL'  # ${ip}6
d414 2
a415 1
	ssh ${ECO_SSH} route -n get -inet6 ${${ip}6} | fgrep -q 'gateway: ${RT_OUT6}'  # ${ip}6 RT_OUT6
@


1.21
log
@Remove the path MTU workaround in the af-to tcp test.  This subtest
passes without it.  For ping with af-to the expected mtu is special.
Adapt although pf is still broken here and this subtest is disabled.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.20 2016/11/09 13:08:51 bluhm Exp $
a167 5
run-regress-ping-mtu-1400-${inet}-AF_IN:
	@@echo '\n======== $@@ ========'
	@@echo 'AF_IN is broken with PF MTU.'
	@@echo DISABLED

a239 1
# XXX AF_IN and RPT_OUT have issues, do not test them now.
d251 1
a251 1
run-regress-traceroute-${proto}-${inet}-AF_IN run-regress-traceroute-${proto}-${inet}-RPT_OUT:
d253 1
a253 1
	@@echo 'AF_IN is broken with PF MTU.'
@


1.20
log
@Split the pf forwarding test into more subtests to make debugging
specific failures easier.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.19 2016/11/09 12:43:36 bluhm Exp $
d179 6
a228 1
# XXX AF_IN is broken with PF MTU, make sure that it hits RT MTU 1300.
a237 7
.if "AF_IN" == ${ip}
.if "inet" == ${inet}
	${SUDO} ${PYTHON}ping_mtu.py ${SRC_OUT} ${${ip}} 1380 1280
.else
	${SUDO} ${PYTHON}ping6_mtu.py ${SRC_OUT6} ${${ip}6} 1420 1320
.endif
.endif
@


1.19
log
@Use netstat -n in target check-setup to avoid DNS timeout.
Requested by mpi@@
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.18 2016/10/26 19:14:28 bluhm Exp $
d141 2
a146 1
TARGETS +=	ping ping6
d148 11
a158 8
run-regress-ping: stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN RTT_IN
	@@echo Check ping ${ip}:
	ping -n -c 1 ${${ip}}
.endfor
	@@echo Check ping RPT_OUT:
	ping -n -c 1 -I ${RPT_OUT} ${ECO_IN}
d160 1
a160 8
run-regress-ping6: stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN RTT_IN
	@@echo Check ping ${ip}6:
	ping6 -n -c 1 ${${ip}6}
.endfor
	@@echo Check ping RPT_OUT6:
	ping6 -n -c 1 -I ${RPT_OUT6} ${ECO_IN6}
a166 2
# XXX AF_IN is broken with PF MTU.
TARGETS +=	ping-mtu-1400 ping6-mtu-1400
d168 1
a168 1
run-regress-ping-mtu-1400: addr.py stamp-pfctl
d170 2
a171 6
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT RTT_IN
	@@echo Check path MTU to ${ip} is 1400
	${SUDO} ${PYTHON}ping_mtu.py ${SRC_OUT} ${${ip}} 1500 1400
.endfor
	@@echo Check path MTU from RPT_OUT is 1400
	${SUDO} ${PYTHON}ping_mtu.py ${RPT_OUT} ${ECO_IN} 1500 1400
d173 2
a174 1
run-regress-ping6-mtu-1400: addr.py stamp-pfctl
d176 6
a181 6
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT RTT_IN
	@@echo Check path MTU to ${ip}6 is 1400
	${SUDO} ${PYTHON}ping6_mtu.py ${SRC_OUT6} ${${ip}6} 1500 1400
.endfor
	@@echo Check path MTU from RPT_OUT6 is 1400
	${SUDO} ${PYTHON}ping6_mtu.py ${RPT_OUT6} ${ECO_IN6} 1500 1400
a188 1
TARGETS +=	ping-mtu-1300 ping6-mtu-1300
d190 2
a191 1
run-regress-ping-mtu-1300: addr.py stamp-pfctl
d193 12
a204 19
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT RTT_IN
	@@echo Check path MTU to ${ip} is 1300
	${SUDO} ${PYTHON}ping_mtu.py ${SRC_OUT} ${${ip}} 1400 1300
.endfor
	@@echo Check path MTU to AF_IN is 1280
	${SUDO} ${PYTHON}ping_mtu.py ${SRC_OUT} ${AF_IN} 1380 1280
	@@echo Check path MTU from RPT_OUT is 1300
	${SUDO} ${PYTHON}ping_mtu.py ${RPT_OUT} ${ECO_IN} 1400 1300

run-regress-ping6-mtu-1300: addr.py stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT RTT_IN
	@@echo Check path MTU to ${ip}6 is 1300
	${SUDO} ${PYTHON}ping6_mtu.py ${SRC_OUT6} ${${ip}6} 1400 1300
.endfor
	@@echo Check path MTU to AF_IN6 is 1320
	${SUDO} ${PYTHON}ping6_mtu.py ${SRC_OUT6} ${AF_IN6} 1420 1320
	@@echo Check path MTU from RPT_OUT6 is 1300
	${SUDO} ${PYTHON}ping6_mtu.py ${RPT_OUT6} ${ECO_IN6} 1400 1300
a207 1
TARGETS +=	udp udp6
d209 2
a210 1
run-regress-udp: stamp-pfctl
d212 6
a217 15
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN RTT_IN
	@@echo Check UDP ${ip}:
	( echo $$$$ | nc -u ${${ip}} 7 & sleep 1; kill $$! ) | grep $$$$
.endfor
	@@echo Check UDP RPT_OUT:
	( echo $$$$ | nc -u -s ${RPT_OUT} ${ECO_IN} 7 & sleep 1; kill $$! ) | grep $$$$

run-regress-udp6: stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN RTT_IN
	@@echo Check UDP ${ip}6:
	( echo $$$$ | nc -u ${${ip}6} 7 & sleep 1; kill $$! ) | grep $$$$
.endfor
	@@echo Check UDP RPT_OUT6:
	( echo $$$$ | nc -u -s ${RPT_OUT6} ${ECO_IN6} 7 & sleep 1; kill $$! ) | grep $$$$
a223 1
TARGETS +=	tcp tcp6
d225 2
a226 1
run-regress-tcp: stamp-pfctl
d228 16
a243 27
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT RTT_IN
	@@echo Check tcp ${ip}:
	${SUDO} route -n delete -host -inet ${${ip}} || true
	openssl rand 200000 | nc -N ${${ip}} 7 | wc -c | grep '200000$$'
.endfor
	@@echo Check tcp AF_IN:
	${SUDO} route -n delete -host -inet ${AF_IN} || true
	${SUDO} ${PYTHON}ping_mtu.py ${SRC_OUT} ${AF_IN} 1380 1280 || true
	openssl rand 200000 | nc -N ${AF_IN} 7 | wc -c | grep '200000$$'
	@@echo Check tcp RPT_OUT:
	${SUDO} route -n delete -host -inet ${RPT_OUT} || true
	openssl rand 200000 | nc -N -s ${RPT_OUT} ${ECO_IN} 7 | wc -c | grep '200000$$'

run-regress-tcp6: stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT RTT_IN
	@@echo Check tcp ${ip}6:
	${SUDO} route -n delete -host -inet6 ${${ip}6} || true
	openssl rand 200000 | nc -N ${${ip}6} 7 | wc -c | grep '200000$$'
.endfor
	@@echo Check tcp AF_IN6:
	${SUDO} route -n delete -host -inet6 ${AF_IN6} || true
	${SUDO} ${PYTHON}ping6_mtu.py ${SRC_OUT6} ${AF_IN6} 1420 1320 || true
	openssl rand 200000 | nc -N ${AF_IN6} 7 | wc -c | grep '200000$$'
	@@echo Check tcp RPT_OUT6:
	${SUDO} route -n delete -host -inet6 ${RPT_OUT6} || true
	openssl rand 200000 | nc -N -s ${RPT_OUT6} ${ECO_IN6} 7 | wc -c | grep '200000$$'
d257 1
d259 4
a262 1
TARGETS +=	traceroute-${proto} traceroute-${proto}6
d264 2
a265 1
run-regress-traceroute-${proto}: stamp-pfctl
d267 8
a274 4
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT RTT_IN
	@@echo Check traceroute ${proto} ${ip}:
	traceroute ${proto:S/icmp/-I/:S/udp//} ${${ip}} | ${TRACEROUTE_CHECK}
.endfor
d276 1
a276 7
run-regress-traceroute-${proto}6: stamp-pfctl
	@@echo '\n======== $@@ ========'
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT RTT_IN
	@@echo Check traceroute ${proto}6 ${ip}6:
	traceroute6 ${proto:S/icmp/-I/:S/udp//} ${${ip}6} | ${TRACEROUTE_CHECK}
.endfor
.endfor
d388 1
a388 1
.for af in inet inet6
d390 1
a390 1
	ssh ${ECO_SSH} netstat -na -f ${af} -p ${proto} | fgrep ' *.7 '
@


1.18
log
@In addition to forwarding and path MTU discovery with pf, check
that ICMP Time Exceeded packets are generated.  Traceroute output
from packets forwarded through pf and a router must contain 3 hops
and every hop must respond.
Do not test with af-to and reply-to rules as this does not work
right now.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.17 2016/10/19 14:31:19 tb Exp $
d422 1
a422 1
	ssh ${ECO_SSH} netstat -a -f ${af} -p ${proto} | fgrep ' *.echo '
d426 2
a427 2
	ssh ${ECO_SSH} netstat -av -f inet -p udp | fgrep ' ${${ip}}.echo '
	ssh ${ECO_SSH} netstat -av -f inet6 -p udp | fgrep ' ${${ip}6}.echo '
@


1.17
log
@The clean:, cleandir:, and obj: targets of src/Makefile descend into
regress/ and run python to set the IMPORT_PYTHON variable in several
test Makefiles. This results in W^X violations during 'make build'.
Avoid doing that.

ok bluhm
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.16 2016/09/02 21:30:34 bluhm Exp $
d124 2
a125 2
# load the pf rules into the kernel of the PF machine
# XXX pfctl does not replace variables after @@
d145 1
a145 1
TARGETS +=	ping  ping6
d170 1
a170 1
# XXX AF_IN is broken with PF MTU
d223 1
a223 1
TARGETS +=	udp  udp6
d248 1
a248 1
TARGETS +=	tcp  tcp6
d279 30
@


1.16
log
@Print SKIPPED if a regress test cannot be executed for some reason.
This allows to identify such tests by looking at their output.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.15 2016/08/31 22:44:29 bluhm Exp $
d9 1
d13 1
@


1.15
log
@Split the check-setup target into smaller parts to make it easier
to configure the regression test machines.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.14 2015/11/01 21:30:00 bluhm Exp $
d16 1
d91 1
@


1.14
log
@Route output to local addresses has changed, ping6 command line
options have changed, tun has been renamed to tap.  Adapt tests.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.13 2015/09/11 15:57:37 bluhm Exp $
d283 4
a286 2
check-setup:
	@@echo '\n======== $@@ SRC ========'
d305 3
a307 1
	@@echo '\n======== $@@ PF ========'
d337 3
a339 1
	@@echo '\n======== $@@ RT ========'
d367 3
a369 1
	@@echo '\n======== $@@ ECO ========'
@


1.13
log
@fter fixing poll(2) semantics in dynamic TCP buffer size update,
making netcat non-blocking and fixing ip6_forward() ICMP6 checksum,
this test can be made more aggressive.  Delete the path MTU route
before sending TCP streams through the pf firewall.  This checks
that PMTU discovery works with outgoing interface MTU and router
MTU.
Test IPv4 and IPv6 protocols ICMP echo, UDP, TCP with pf nat-to,
rdr-to, af-to, route-to, reply-to.  Some af-to cases seem to be
broken.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.12 2015/08/24 23:12:53 bluhm Exp $
d49 1
a49 1
SRC_IF ?=	tun0
d159 1
a159 1
	ping6 -n -c 1 -S ${RPT_OUT6} ${ECO_IN6}
d287 1
a287 1
	route -n get -inet ${${ip}} | fgrep -q 'interface: lo0'  # ${ip}
d296 1
a296 1
	route -n get -inet6 ${${ip}6} | fgrep -q 'interface: lo0'  # ${ip}6
d305 1
a305 1
	ssh ${PF_SSH} route -n get -inet ${PF_IN} | fgrep -q 'interface: lo0'  # PF_IN
d308 1
a308 1
	ssh ${PF_SSH} route -n get -inet ${PF_OUT} | fgrep -q 'interface: lo0'  # PF_OUT
d317 1
a317 1
	ssh ${PF_SSH} route -n get -inet6 ${PF_IN6} | fgrep -q 'interface: lo0'  # PF_IN6
d320 1
a320 1
	ssh ${PF_SSH} route -n get -inet6 ${PF_OUT6} | fgrep -q 'interface: lo0'  # PF_OUT6
d335 1
a335 1
	ssh ${RT_SSH} route -n get -inet ${RT_IN} | fgrep -q 'interface: lo0'  # RT_IN
d341 1
a341 1
	ssh ${RT_SSH} route -n get -inet ${RT_OUT} | fgrep -q 'interface: lo0'  # RT_OUT
d347 1
a347 1
	ssh ${RT_SSH} route -n get -inet6 ${RT_IN6} | fgrep -q 'interface: lo0'  # RT_IN6
d353 1
a353 1
	ssh ${RT_SSH} route -n get -inet6 ${RT_OUT6} | fgrep -q 'interface: lo0'  # RT_OUT6
d364 1
a364 1
	ssh ${ECO_SSH} route -n get -inet ${${ip}} | fgrep -q 'interface: lo0'  # ${ip}
d372 1
a372 1
	ssh ${ECO_SSH} route -n get -inet6 ${${ip}6} | fgrep -q 'interface: lo0'  # ${ip}6
@


1.12
log
@Extend the pf forward and fragment tests with a second challenge
for path MTU discovery.  The router behind the pf machine has MTU
1300.  The ICMP packet generated by the router matches the pf state
and is NATed correctly.  Additionally the pf machine itself has an
interface MTU 1400.  So when pf is sending a packet is has to
generate a correct "fragmentation needed" or "packet too big" ICMP
response.  This is done with pf route-to and reply-to.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.11 2015/08/17 22:06:50 bluhm Exp $
d166 1
d242 2
d248 1
a248 1
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN RTT_IN
d250 1
d253 4
d258 1
d263 1
a263 1
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN RTT_IN
d265 1
d268 4
d273 1
@


1.11
log
@Add forwarding tests for pf route-to and reply-to.  Keep pf forward
and pf fragment tests in sync.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.10 2015/07/21 17:51:50 bluhm Exp $
d30 4
a33 4
# +---+   0   +--+   1   +--+   2   +---+ 3   4 +---+ 5   6 +--+
# |SRC| ----> |PF| ----> |RT| ----> |ECO| 7     |RDR|       |AF|
# +---+ 8     +--+       +--+       +---+ 9     +---+       +--+
#     out    in  out    in  out    in   out    in   out    in
d35 4
a38 4
# 7 +---+   +---+ 8
#   |RTT|   |RPT|
#   +---+   +---+
#  in           out
d51 2
a52 1
PF_IF ?=	vio0
d111 2
a112 1
	echo 'PF_IF="${PF_IF}"' >>$@@.tmp
d125 1
a125 1
	    sed 's/@@$$PF_IF /@@${PF_IF} /g' | \
d162 25
d189 1
a189 1
# the router RT before.
d192 1
a192 1
TARGETS +=	ping-mtu ping6-mtu
d194 1
a194 1
run-regress-ping-mtu: addr.py stamp-pfctl
d198 1
a198 1
	${SUDO} ${PYTHON}ping_mtu.py ${${ip}} 1300
d201 3
a203 1
	${SUDO} ${PYTHON}ping_mtu.py ${AF_IN} 1280
d205 1
a205 1
run-regress-ping6-mtu: addr.py stamp-pfctl
d209 1
a209 1
	${SUDO} ${PYTHON}ping6_mtu.py ${${ip}6} 1300
d212 3
a214 1
	${SUDO} ${PYTHON}ping6_mtu.py ${AF_IN6} 1320
d317 1
@


1.10
log
@Extend the setup with another address for testing pf route-to.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.9 2015/07/20 20:53:43 bluhm Exp $
d27 2
d31 2
a32 2
# |SRC| ----> |PF| ----> |RT| ----> |ECO|       |RDR|       |AF|
# +---+       +--+       +--+       +---+       +---+       +--+
d34 5
d51 1
d67 2
d80 2
d110 1
d112 1
a112 1
.for var in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN
d119 1
d123 1
d135 1
a135 1
# Ping all addresses.  This ensures that the ip addresses are configured
d143 1
a143 1
.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN
d147 2
d152 1
a152 1
.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN
d156 2
d163 1
a163 1
# Check that the ip length of the original packet and the icmp
d169 1
a169 1
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT
d178 1
a178 1
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT
d185 1
a185 1
# Send one udp echo port 7 packet to all destination addresses with netcat.
d191 2
a192 2
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN
	@@echo Check udp ${ip}:
d195 2
d200 2
a201 2
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN
	@@echo Check udp ${ip}6:
d204 2
d207 1
a207 1
# Send a data stream to tcp echo port 7 to all destination addresses
d214 1
a214 1
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN
d218 2
d223 1
a223 1
.for ip in ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN
d227 2
d239 4
a242 2
	ping -n -c 1 ${SRC_OUT}  # SRC_OUT
	route -n get -inet ${SRC_OUT} | fgrep -q 'interface: lo0'  # SRC_OUT
d245 1
a245 1
.for ip in PF_OUT RT_IN RT_OUT ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN
d248 4
a251 2
	ping6 -n -c 1 ${SRC_OUT6}  # SRC_OUT6
	route -n get -inet6 ${SRC_OUT6} | fgrep -q 'interface: lo0'  # SRC_OUT6
d254 1
a254 1
.for ip in PF_OUT RT_IN RT_OUT ECO_IN ECO_OUT RDR_IN RDR_OUT AF_IN
d267 3
d279 3
d290 1
a290 1
.for ip in PF_IN SRC_OUT
d296 3
a298 1
	ssh ${RT_SSH} route -n get -inet ${ECO_OUT} | fgrep -q 'gateway: ${ECO_IN}'  # ECO_OUT ECO_IN
d302 1
a302 1
.for ip in PF_IN SRC_OUT
d308 3
a310 1
	ssh ${RT_SSH} route -n get -inet6 ${ECO_OUT6} | fgrep -q 'gateway: ${ECO_IN6}'  # ECO_OUT6 ECO_IN6
d315 1
a315 1
.for ip in ECO_IN ECO_OUT
d320 1
a320 1
.for ip in RT_IN PF_OUT PF_IN SRC_OUT
d323 1
a323 1
.for ip in ECO_IN ECO_OUT
d328 1
a328 1
.for ip in RT_IN PF_OUT PF_IN SRC_OUT
d336 4
a339 4
	ssh ${ECO_SSH} netstat -av -f inet -p udp | fgrep ' ${ECO_IN}.echo '
	ssh ${ECO_SSH} netstat -av -f inet -p udp | fgrep ' ${ECO_OUT}.echo '
	ssh ${ECO_SSH} netstat -av -f inet6 -p udp | fgrep ' ${ECO_IN6}.echo '
	ssh ${ECO_SSH} netstat -av -f inet6 -p udp | fgrep ' ${ECO_OUT6}.echo '
@


1.9
log
@When test pf.conf changes, check its syntax and use the new one.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.8 2014/07/18 23:54:55 bluhm Exp $
d274 4
a277 2
	ssh ${ECO_SSH} ping -n -c 1 ${ECO_IN}  # ECO_IN
	ssh ${ECO_SSH} route -n get -inet ${ECO_IN} | fgrep -q 'interface: lo0'  # ECO_IN
d282 4
a285 4
	ssh ${ECO_SSH} ping -n -c 1 ${ECO_OUT}  # ECO_OUT
	ssh ${ECO_SSH} route -n get -inet ${ECO_OUT} | fgrep -q 'interface: lo0'  # ECO_OUT
	ssh ${ECO_SSH} ping6 -n -c 1 ${ECO_IN6}  # ECO_IN6
	ssh ${ECO_SSH} route -n get -inet6 ${ECO_IN6} | fgrep -q 'interface: lo0'  # ECO_IN6
a288 2
	ssh ${ECO_SSH} ping6 -n -c 1 ${ECO_OUT6}  # ECO_OUT6
	ssh ${ECO_SSH} route -n get -inet6 ${ECO_OUT6} | fgrep -q 'interface: lo0'  # ECO_OUT6
@


1.8
log
@The pf forward tests were running rdr-to and nat-to simultaneously
only.  Change address layout and add individual tests for each
feature rdr-to and nat-to and rdr-to together with nat-to.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.7 2014/07/13 01:47:20 bluhm Exp $
d106 2
a107 1
stamp-pfctl: addr.py
@


1.7
log
@Make the pf_forward test pass again.  Check that the router's
interface mtu has been set to 1300.  New netcat needs -N for shutdown.
The IPv4 and IPv6 addresses for the af-to tests must have corresponding
host numbers.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.6 2014/07/12 22:43:31 bluhm Exp $
d28 4
a31 4
# +---+   0   +--+   1   +--+   2   +---+   3   +---+  4  +--+
# |SRC| ----> |PF| ----> |RT| ----> |ECO|       |RDR|     |AF|
# +---+       +--+       +--+       +---+       +---+     +--+
#     out    in  out    in  out    in          in        in
d55 4
a58 2
RDR_IN ?=	10.188.213.188
AF_IN ?=	10.188.214.82		# /24 must be dec(ECO_IN6/120)
d66 4
a69 2
RDR_IN6 ?=	fdd7:e83e:66bc:213::188
AF_IN6 ?=	fdd7:e83e:66bc:214::34	# /120 must be hex(ECO_IN/24)
d99 1
a99 1
.for var in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN RDR_IN AF_IN
d127 1
a127 1
.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN RDR_IN AF_IN
d134 1
a134 1
.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT ECO_IN RDR_IN AF_IN
d149 1
a149 1
.for ip in ECO_IN RDR_IN
d158 1
a158 1
.for ip in ECO_IN RDR_IN
d171 1
a171 1
.for ip in ECO_IN RDR_IN AF_IN
d178 1
a178 1
.for ip in ECO_IN RDR_IN AF_IN
d190 1
a190 1
.for ip in ECO_IN RDR_IN AF_IN
d197 1
a197 1
.for ip in ECO_IN RDR_IN AF_IN
d215 1
a215 1
.for ip in PF_OUT RT_IN RT_OUT ECO_IN RDR_IN AF_IN
d222 1
a222 1
.for ip in PF_OUT RT_IN RT_OUT ECO_IN RDR_IN AF_IN
d232 1
a232 1
.for ip in RT_OUT ECO_IN
d241 1
a241 1
.for ip in RT_OUT ECO_IN
d258 1
d268 1
d279 2
d286 2
d294 4
@


1.6
log
@Automatically load the required pf rules into the kernel of the
remote test machine.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.5 2014/07/12 21:41:49 bluhm Exp $
d56 1
a56 1
AF_IN ?=	10.188.214.188
d65 1
a65 1
AF_IN6 ?=	fdd7:e83e:66bc:214::188
a86 4
# Currently these test fail as pf does not fix the checksum of
# NATed packets inside of icmp packets.
# ping6-mtu

d188 1
a188 1
	openssl rand 200000 | nc ${${ip}} 7 | wc -c | grep '200000$$'
d195 1
a195 1
	openssl rand 200000 | nc ${${ip}6} 7 | wc -c | grep '200000$$'
d242 2
a243 2
	ssh ${PF_SSH} sysctl net.inet.ip.forwarding | fgrep 1
	ssh ${PF_SSH} sysctl net.inet6.ip6.forwarding | fgrep 1
d263 3
a265 2
	ssh ${RT_SSH} sysctl net.inet.ip.forwarding | fgrep 1
	ssh ${RT_SSH} sysctl net.inet6.ip6.forwarding | fgrep 1
@


1.5
log
@Teach these pf regress tests to run with obj directory and to fail
softly if the setup is incomplete.  Link them to the build.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.4 2014/07/12 21:00:46 bluhm Exp $
d75 11
a85 16
# pf rules on PF must look like this:
#
# pass to { $PF_IN/24 $PF_IN6/64 }
# pass to { $RT_IN/24 $RT_IN6/64 }
# pass to { $ECO_IN/24 $DST_IN6/64 }
# pass to { $RDR_IN/24 $RDR_IN6/64 }
#
# pass in  to $RDR_IN/24  rdr-to $ECO_IN  tag rdr
# pass out                nat-to $PF_OUT  tagged rdr
# pass in  to $RDR_IN6/64 rdr-to $ECO_IN6 tag rdr
# pass out                nat-to $PF_OUT6 tagged rdr

# pass in  to $AF_IN/24  af-to inet6 from $PF_OUT6 to $ECO_IN6/120 tag af
# pass out                     inet6                               tagged af
# pass in  to $AF_IN6/64 af-to inet  from $PF_OUT  to $ECO_IN/24   tag af
# pass out                     inet                                tagged af
d105 6
d125 1
a125 1
run-regress-ping:
d132 1
a132 1
run-regress-ping6:
d147 1
a147 1
run-regress-ping-mtu: addr.py
d156 1
a156 1
run-regress-ping6-mtu: addr.py
d169 1
a169 1
run-regress-udp:
d176 1
a176 1
run-regress-udp6:
d188 1
a188 1
run-regress-tcp:
d195 1
a195 1
run-regress-tcp6:
d204 1
a204 1
CLEANFILES +=		addr.py *.pyc *.log
@


1.4
log
@Use a saner and consistent address layout for my network tests that
run over 4 machines.  Add a check-setup target to verify that
interface addresses and routes are properly set up.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.3 2012/07/10 16:58:29 bluhm Exp $
d9 9
d45 3
a47 3
PF_SSH ?=	q50
RT_SSH ?=	q51
ECO_SSH ?=	q52
d67 8
d110 8
d150 1
a150 1
	${SUDO} python2.7 ping_mtu.py ${${ip}} 1300
d153 1
a153 1
	${SUDO} python2.7 ping_mtu.py ${AF_IN} 1280
d159 1
a159 1
	${SUDO} python2.7 ping6_mtu.py ${${ip}6} 1300
d162 1
a162 1
	${SUDO} python2.7 ping6_mtu.py ${AF_IN6} 1320
d235 1
a235 1
	ssh ${PF_SSH} route -n get -inet6 ${PF_IN6} | fgrep -q 'interface: lo0'  # PF_IN6 
d238 1
a238 1
	ssh ${PF_SSH} route -n get -inet6 ${PF_OUT6} | fgrep -q 'interface: lo0'  # PF_OUT6 
d258 1
a258 1
	ssh ${RT_SSH} route -n get -inet6 ${RT_IN6} | fgrep -q 'interface: lo0'  # RT_IN6 
d264 1
a264 1
	ssh ${RT_SSH} route -n get -inet6 ${RT_OUT6} | fgrep -q 'interface: lo0'  # RT_OUT6 
d276 1
a276 1
	ssh ${ECO_SSH} route -n get -inet6 ${ECO_IN6} | fgrep -q 'interface: lo0'  # ECO_IN6 
@


1.3
log
@Do not write spaces around = in addr.py so it can also be read by
the shell.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.2 2012/07/10 16:52:45 bluhm Exp $
d11 1
a11 1
# Set up machines: SRC PF RT DST
d15 3
a17 3
# DST is reflecting the ping and UDP and TCP echo packets.
# RDR does not exist, PF redirects the traffic to DST.
# AF does not exist, PF translates address family and sends to DST.
d19 2
a20 2
# +---+   1   +--+   2   +--+   3   +---+   4   +---+  5  +--+
# |SRC| ----> |PF| ----> |RT| ----> |DST|       |RDR|     |AF|
d24 6
a29 2
# Configure Addresses on the machines, there must be routes for the networks.
# Adapt interface and addresse variables to your local setup.
d31 26
a56 21
SRC_IF =	tun0
SRC_MAC =	fe:e1:ba:d1:0a:dc
PF_MAC =	52:54:00:12:34:50

SRC_OUT =	10.188.211.10
PF_IN =		10.188.211.50
PF_OUT =	10.188.212.50
RT_IN =		10.188.212.51
RT_OUT =	10.188.213.51
DST_IN =	10.188.213.52
RDR_IN =	10.188.214.1
AF_IN =		10.188.215.82

SRC_OUT6 =	fdd7:e83e:66bc:211:fce1:baff:fed1:561f
PF_IN6 =	fdd7:e83e:66bc:211:5054:ff:fe12:3450
PF_OUT6 =	fdd7:e83e:66bc:212:5054:ff:fe12:3450
RT_IN6 =	fdd7:e83e:66bc:212:5054:ff:fe12:3451
RT_OUT6 =	fdd7:e83e:66bc:213:5054:ff:fe12:3451
DST_IN6 =	fdd7:e83e:66bc:213:5054:ff:fe12:3452
RDR_IN6 =	fdd7:e83e:66bc:214::1
AF_IN6 =	fdd7:e83e:66bc:215:5054:ff:fe12:3434
d62 1
a62 1
# pass to { $DST_IN/24 $DST_IN6/64 }
d65 1
a65 1
# pass in  to $RDR_IN/24  rdr-to $DST_IN  tag rdr
d67 1
a67 1
# pass in  to $RDR_IN6/64 rdr-to $DST_IN6 tag rdr
d70 1
a70 1
# pass in  to $AF_IN/24  af-to inet6 from $PF_OUT6 to $DST_IN6/120 tag af
d72 1
a72 1
# pass in  to $AF_IN6/64 af-to inet  from $PF_OUT  to $DST_IN/24   tag af
d87 1
a87 1
.for var in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT DST_IN RDR_IN AF_IN
a92 24
# Make sure that the routing table on the SRC machine is correct.
# All packets must be forwarded to PF target machine.
TARGETS +=	route route6

run-regress-route:
	@@echo '\n======== $@@ ========'
	@@echo Check route SRC_OUT:
	route -n get -inet ${SRC_OUT} | fgrep -q 'interface: lo0'
	@@echo Check route PF_IN:
	route -n get -inet ${PF_IN} | fgrep -q 'if address: ${SRC_OUT}'
.for ip in PF_OUT RT_IN RT_OUT DST_IN RDR_IN AF_IN
	@@echo Check route ${ip}:
	route -n get -inet ${${ip}} | fgrep -q 'gateway: ${PF_IN}'
.endfor

run-regress-route6:
	@@echo '\n======== $@@ ========'
	@@echo Check route SRC_OUT6:
	route -n get -inet6 ${SRC_OUT6} | fgrep -q 'interface: lo0'
.for ip in PF_OUT RT_IN RT_OUT DST_IN RDR_IN AF_IN
	@@echo Check route ${ip}6:
	route -n get -inet6 ${${ip}6} | fgrep -q 'gateway: ${PF_IN6}'
.endfor

d96 1
a96 1
# by PF and handled by DST.
d101 1
a101 1
.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT DST_IN RDR_IN AF_IN
d108 1
a108 1
.for ip in SRC_OUT PF_IN PF_OUT RT_IN RT_OUT DST_IN RDR_IN AF_IN
d123 1
a123 1
.for ip in DST_IN RDR_IN
d132 1
a132 1
.for ip in DST_IN RDR_IN
d145 1
a145 1
.for ip in DST_IN RDR_IN AF_IN
d152 1
a152 1
.for ip in DST_IN RDR_IN AF_IN
d164 1
a164 1
.for ip in DST_IN RDR_IN AF_IN
d171 1
a171 1
.for ip in DST_IN RDR_IN AF_IN
d179 82
@


1.2
log
@Add a subtest to the MTU ping that checks wether the ip length of
the original packet and the icmp quoted packet are the same.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.1 2012/07/10 12:43:54 bluhm Exp $
d75 3
a77 3
	echo 'SRC_IF = "${SRC_IF}"' >>$@@.tmp
	echo 'SRC_MAC = "${SRC_MAC}"' >>$@@.tmp
	echo 'PF_MAC = "${PF_MAC}"' >>$@@.tmp
d79 2
a80 2
	echo '${var} = "${${var}}"' >>$@@.tmp
	echo '${var}6 = "${${var}6}"' >>$@@.tmp
@


1.1
log
@Add a test suite to route ip packets through a box running pf.  You
have to setup four machines manually as described in the makefile.
The test uses netcat and scapy to send ping or udp echo packets or
tcp streams along the routers.  It analyzes the returned reply or
icmp error packets.  It tests the forward and net/rdr and net64
paths.
@
text
@d1 1
a1 1
#	$OpenBSD$
d132 2
@

