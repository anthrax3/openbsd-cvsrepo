head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	bluhm_20161019:1.1.1.1
	bluhm:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2017.01.18.23.03.44;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	CeKCY3OcQDpvUbop;

1.4
date	2016.11.21.22.56.35;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	RPwHsfGbEmb36hR3;

1.3
date	2016.10.20.19.16.05;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	uBbyZx0hTaqwReOG;

1.2
date	2016.10.20.16.31.37;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	M6nQiwYW6Kzr65WL;

1.1
date	2016.10.19.16.39.50;	author bluhm;	state Exp;
branches
	1.1.1.1;
next	;
commitid	DXnLPNyXQsmQXUte;

1.1.1.1
date	2016.10.19.16.39.50;	author bluhm;	state Exp;
branches;
next	;
commitid	DXnLPNyXQsmQXUte;


desc
@@


1.5
log
@Do not use privileged or NFS source ports for UDP packets as inetd
ignores such packets.  This should avoid some sporadic failures.
While there, use variable names consistently in all tests.
@
text
@#!/usr/local/bin/python2.7
# check wether path mtu to dst is as expected

import os
import threading
from addr import *
from scapy.all import *

#
# we can not use scapy's sr() function as receive side
# ignores the packet we expect to see. Packet is ignored
# due to mismatching sequence numbers. 'bogus_syn' is using
# seq = 1000000, while response sent back by PF has ack,
# which fits regular session opened by 'syn'.
#
class Sniff1(threading.Thread):
	filter = None
	captured = None
	packet = None
	def run(self):
		self.captured = sniff(iface=LOCAL_IF, filter=self.filter,
		    count=1, timeout=5)
		if self.captured:
			self.packet = self.captured[0]

tport=os.getpid() & 0xffff

ip=IP(src=FAKE_NET_ADDR, dst=REMOTE_ADDR)

print "Send SYN packet, receive SYN+ACK"
syn=TCP(sport=tport, dport='echo', seq=1, flags='S', window=(2**16)-1)
synack=sr1(ip/syn, iface=LOCAL_IF, timeout=5)

if synack is None:
	print "ERROR: no matching SYN+ACK packet received"
	exit(1)

print "Send ACK packet to finish handshake."
ack=TCP(sport=synack.dport, dport=synack.sport, seq=2, flags='A',
    ack=synack.seq+1)
send(ip/ack, iface=LOCAL_IF)

print "Connection is established, send bogus SYN, expect challenge ACK"
bogus_syn=TCP(sport=syn.sport, dport=syn.dport, seq=1000000, flags='S',
    window=(2**16)-1)
sniffer = Sniff1();
sniffer.filter = "src %s and tcp port %u and dst %s and tcp port %u " \
    "and tcp[tcpflags] = tcp-ack" % (ip.dst, syn.dport, ip.src, syn.sport)
sniffer.start()
time.sleep(1)
send(ip/bogus_syn, iface=LOCAL_IF)
sniffer.join(timeout=7)
challenge_ack = sniffer.packet

if challenge_ack is None:
	print "ERROR: no matching ACK packet received"
	exit(1)

if challenge_ack.getlayer(TCP).seq != (synack.seq + 1):
	print "ERROR: expecting seq %d got %d in challange ack" % \
	    (challenge_ack.getlayer(TCP).seq, (synack.seq + 1))
	exit(1)

exit(0)
@


1.4
log
@Print better error message if test fails.
@
text
@d26 1
a26 1
fake_port=os.getpid() & 0xffff
d31 2
a32 2
syn=TCP(sport=fake_port, dport='echo', seq=1, flags='S', window=(2**16)-1)
syn_ack=sr1(ip/syn, iface=LOCAL_IF, timeout=5)
d34 1
a34 1
if syn_ack is None:
d39 2
a40 2
ack=TCP(sport=syn_ack.dport, dport=syn_ack.sport, seq=2, flags='A',
    ack=syn_ack.seq+1)
d44 1
a44 1
bogus_syn=TCP(sport=fake_port, dport='echo', seq=1000000, flags='S',
d47 2
a48 2
sniffer.filter = "src %s and tcp port echo and dst %s and tcp port %u " \
    "and tcp[tcpflags] = tcp-ack" % (REMOTE_ADDR, FAKE_NET_ADDR, fake_port)
d59 1
a59 1
if challenge_ack.getlayer(TCP).seq != (syn_ack.seq + 1):
d61 1
a61 1
	    (challenge_ack.getlayer(TCP).seq, (syn_ack.seq + 1))
@


1.3
log
@By removing all the sleeps I created a race in the pf tests.  The
packet was sent and its reply received before the sniffer was up
and running.  So sleep a second after starting the sniffer thread
but before sending the packet.  With pf_forward 0m51.54s, pf_fragment
1m33.59s, pf_state 0m03.64s the test are still faster than with
forking.
@
text
@d32 5
a36 1
synack=sr1(ip/syn, iface=LOCAL_IF, timeout=5)
d39 2
a40 2
ack=TCP(sport=synack.dport, dport=synack.sport, seq=2, flags='A',
    ack=synack.seq+1)
d59 1
a59 1
if challenge_ack.getlayer(TCP).seq != (synack.seq + 1):
d61 1
a61 1
	    (challenge_ack.getlayer(TCP).seq, (synack.seq + 1))
@


1.2
log
@Make the test faster.  Move all the packet matching code into the
pcap filter.  That means the first packet sniffed is the correct
one.  In the success case, we can stop without waiting for a timeout.
OK sashan@@
@
text
@d43 1
a43 1
sniffer.filter= "src %s and tcp port echo and dst %s and tcp port %u " \
d46 1
a48 1

@


1.1
log
@Initial revision
@
text
@a8 2
# usage: challenge_ack.py src dst

d16 2
a17 1
class Sniff(threading.Thread):
d19 1
d21 4
a24 2
		self.captured = sniff(iface=LOCAL_IF,
		    filter='tcp src port 7', timeout=3)
d26 1
a26 3
srcaddr=sys.argv[1]
dstaddr=sys.argv[2]
port=os.getpid() & 0xffff
d28 1
a28 1
ip=IP(src=srcaddr, dst=dstaddr)
d31 1
a31 1
syn=TCP(sport=port, dport='echo', seq=1, flags='S', window=(2**16)-1)
d40 1
a40 1
bogus_syn=TCP(sport=port, dport='echo', seq=1000000, flags='S',
d42 3
a44 1
sniffer = Sniff();
d46 2
a47 2
challenge_ack=send(ip/bogus_syn, iface=LOCAL_IF)
sniffer.join(timeout=5)
d49 1
a49 11
if sniffer.captured == None:
	print "ERROR: no packet received"
	exit(1)

challenge_ack = None

for p in sniffer.captured:
	if p.haslayer(TCP) and p.getlayer(TCP).sport == 7 and \
	    p.getlayer(TCP).flags == 16:
		challenge_ack = p
		break
d51 2
a52 2
if challenge_ack == None:
	print "No ACK has been seen"
@


1.1.1.1
log
@Add a test suite for pf state handling.  It needs a remote machine
to exchange packets, the remote kernel is tested.  For now it only
contains a challenge ack test written by sashan@@.
OK sashan@@
@
text
@@
