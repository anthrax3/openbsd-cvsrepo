head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.6
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.4.0.10
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.8
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.6
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	bluhm_20130603:1.1.1.1
	bluhm:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2015.07.28.12.31.29;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	o6wdSs3EDVW9tmqt;

1.4
date	2013.06.05.04.34.27;	author bluhm;	state Exp;
branches;
next	1.3;

1.3
date	2013.06.04.04.17.42;	author bluhm;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.03.21.07.45;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2013.06.03.05.06.38;	author bluhm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.06.03.05.06.38;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Add more and deeper tests for pf divert-reply rules.  Especially
the combination of sending and receiving multiple packets over one
socket is tested for UDP, raw IP and ICMP.
@
text
@#	$OpenBSD: funcs.pl,v 1.4 2013/06/05 04:34:27 bluhm Exp $

# Copyright (c) 2010-2015 Alexander Bluhm <bluhm@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use Socket;
use Socket6;

########################################################################
# Client and Server funcs
########################################################################

sub write_read_stream {
	my $self = shift;

	my $out = ref($self). "\n";
	print $out;
	IO::Handle::flush(\*STDOUT);
	print STDERR ">>> $out";

	my $in = <STDIN>;
	print STDERR "<<< $in";
}

sub write_datagram {
	my $self = shift;
	my $dgram = shift;

	my $out = $dgram || ref($self). "\n";
	my $addr = $self->{toaddr};
	my $port = $self->{toport};
	if ($addr) {
		my ($to, $netaddr);
		if ($self->{af} eq "inet") {
			$netaddr = inet_pton(AF_INET, $addr);
			$to = pack_sockaddr_in($port, $netaddr);
		} else {
			$netaddr = inet_pton(AF_INET6, $addr);
			$to = pack_sockaddr_in6($port, $netaddr);
		}
		$self->{toaddr} = $addr;
		$self->{toport} = $port;
		print STDERR "send to: $addr $port\n";

		send(STDIN, $out, 0, $to)
		    or die ref($self), " send to failed: $!";
	} else {
		send(STDIN, $out, 0)
		    or die ref($self), " send failed: $!";
	}

	unless ($dgram) {
		print STDERR ">>> $out";
	}
}

sub read_datagram {
	my $self = shift;
	my $dgram = shift;

	my $from = recv(STDIN, my $in, 70000, 0)
	    or die ref($self), " recv from failed: $!";
	# Raw sockets include the IPv4 header.
	if ($self->{socktype} && $self->{socktype} == Socket::SOCK_RAW &&
	    $self->{af} eq "inet") {
		substr($in, 0, 20, "");
	}

	my ($port, $netaddr, $addr);
	if ($self->{af} eq "inet") {
		($port, $netaddr) = unpack_sockaddr_in($from);
		$addr = inet_ntop(AF_INET, $netaddr);
	} else {
		($port, $netaddr) = unpack_sockaddr_in6($from);
		$addr = inet_ntop(AF_INET6, $netaddr);
	}
	$self->{fromaddr} = $addr;
	$self->{fromport} = $port;
	print STDERR "recv from: $addr $port\n";

	if ($dgram) {
		$$dgram = $in;
	} else {
		print STDERR "<<< $in";
	}
}

sub in_cksum {
	my $data = shift;
	my $sum = 0;

	$data .= pack("x") if (length($data) & 1);
	while (length($data)) {
		$sum += unpack("n", substr($data, 0, 2, ""));
		$sum = ($sum >> 16) + ($sum & 0xffff) if ($sum > 0xffff);
	}
	return (~$sum & 0xffff);
}

use constant IPPROTO_ICMPV6	=> 58;
use constant ICMP_ECHO		=> 8;
use constant ICMP_ECHOREPLY	=> 0;
use constant ICMP6_ECHO_REQUEST	=> 128;
use constant ICMP6_ECHO_REPLY	=> 129;

my $seq = 0;
sub write_icmp_echo {
	my $self = shift;
	my $pid = shift || $$;
	my $af = $self->{af};

	my $type = $af eq "inet" ? ICMP_ECHO : ICMP6_ECHO_REQUEST;
	# type, code, cksum, id, seq
	my $icmp = pack("CCnnn", $type, 0, 0, $pid, ++$seq);
	if ($af eq "inet") {
		substr($icmp, 2, 2, pack("n", in_cksum($icmp)));
	} else {
		# src, dst, plen, pad, next
		my $phdr = "";
		$phdr .= inet_pton(AF_INET6, $self->{srcaddr});
		$phdr .= inet_pton(AF_INET6, $self->{dstaddr});
		$phdr .= pack("NxxxC", length($icmp), IPPROTO_ICMPV6);
		print STDERR "pseudo header: ", unpack("H*", $phdr), "\n";
		substr($icmp, 2, 2, pack("n", in_cksum($phdr. $icmp)));
	}

	write_datagram($self, $icmp);
	my $text = $af eq "inet" ? "ICMP" : "ICMP6";
	print STDERR ">>> $text ", unpack("H*", $icmp), "\n";
}

sub read_icmp_echo {
	my $self = shift;
	my $reply = shift;
	my $af = $self->{af};

	my $icmp;
	read_datagram($self, \$icmp);

	my $text = $af eq "inet" ? "ICMP" : "ICMP6";
	$text .= " reply" if $reply;
	my $phdr = "";
	if ($af eq "inet6") {
		# src, dst, plen, pad, next
		$phdr .= inet_pton(AF_INET6, $self->{srcaddr});
		$phdr .= inet_pton(AF_INET6, $self->{dstaddr});
		$phdr .= pack("NxxxC", length($icmp), IPPROTO_ICMPV6);
		print STDERR "pseudo header: ", unpack("H*", $phdr), "\n";
	}
	if (length($icmp) < 8) {
		$text = "BAD $text LENGTH";
	} elsif (in_cksum($phdr. $icmp) != 0) {
		$text = "BAD $text CHECKSUM";
	} else {
		my($type, $code, $cksum, $id, $seq) = unpack("CCnnn", $icmp);
		my $t = $reply ?
		    ($af eq "inet" ? ICMP_ECHOREPLY : ICMP6_ECHO_REPLY) :
		    ($af eq "inet" ? ICMP_ECHO : ICMP6_ECHO_REQUEST);
		if ($type != $t) {
			$text = "BAD $text TYPE";
		} elsif ($code != 0) {
			$text = "BAD $text CODE";
		}
	}

	print STDERR "<<< $text ", unpack("H*", $icmp), "\n";
}

########################################################################
# Script funcs
########################################################################

sub check_logs {
	my ($c, $s, %args) = @@_;

	return if $args{nocheck};

	check_inout($c, $s, %args);
}

sub check_inout {
	my ($c, $s, %args) = @@_;

	if ($args{client} && !$args{client}{nocheck}) {
		my $out = $args{client}{out} || "Client";
		$c->loggrep(qr/^>>> $out/) or die "no client output"
		    unless $args{client}{noout};
		my $in = $args{client}{in} || "Server";
		$c->loggrep(qr/^<<< $in/) or die "no client input"
		    unless $args{client}{noin};
	}
	if ($args{server} && !$args{server}{nocheck}) {
		my $out = $args{server}{out} || "Server";
		$s->loggrep(qr/^>>> $out/) or die "no server output"
		    unless $args{server}{noout};
		my $in = $args{server}{in} || "Client";
		$s->loggrep(qr/^<<< $in/) or die "no server input"
		    unless $args{server}{noin};
	}
}

1;
@


1.4
log
@Add tests for ICMP and ICMP6 divert-to.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.3 2013/06/04 04:17:42 bluhm Exp $
d3 1
a3 1
# Copyright (c) 2010-2013 Alexander Bluhm <bluhm@@openbsd.org>
d19 2
d40 1
d42 26
a67 4
	my $out = ref($self). "\n";
	print $out;
	IO::Handle::flush(\*STDOUT);
	print STDERR ">>> $out";
d72 1
a72 2
	my $skip = $self->{skip};
	$skip = $skip->($self) if ref $skip eq 'CODE';
d74 22
a95 6
	my $in;
	if ($skip) {
		# Raw sockets include the IPv4 header.
		sysread(STDIN, $in, 70000);
		# Cut the header off.
		substr($in, 0, $skip, "");
d97 1
a97 1
		$in = <STDIN>;
a98 1
	print STDERR "<<< $in";
d115 1
d117 1
d122 1
d127 1
a127 1
	my $icmp = pack("CCnnn", $type, 0, 0, $$, ++$seq);
d140 1
a140 2
	print $icmp;
	IO::Handle::flush(\*STDOUT);
d147 1
d150 2
a151 6
	# Raw sockets include the IPv4 header.
	sysread(STDIN, my $icmp, 70000);
	# Cut the header off.
	if ($af eq "inet") {
		substr($icmp, 0, 20, "");
	}
d154 1
d169 4
a172 1
		if ($type != ($af eq "inet" ? ICMP_ECHO : ICMP6_ECHO_REQUEST)) {
d197 1
a197 1
	if ($c && !$args{client}{nocheck}) {
d205 1
a205 1
	if ($s && !$args{server}{nocheck}) {
@


1.3
log
@Add tests for raw IP divert.  Set effective user ID to 0 only during
privileged operations for raw sockets and bind any.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.2 2013/06/03 21:07:45 bluhm Exp $
d62 78
d156 2
a157 1
		$c->loggrep(qr/^>>> Client$/) or die "no client output"
d159 2
a160 1
		$c->loggrep(qr/^<<< Server$/) or die "no client input"
d164 2
a165 1
		$s->loggrep(qr/^>>> Server$/) or die "no server output"
d167 2
a168 1
		$s->loggrep(qr/^<<< Client$/) or die "no server input"
@


1.2
log
@Add tests for UDP divert.
@
text
@d1 1
a1 1
#	$OpenBSD: funcs.pl,v 1.1.1.1 2013/06/03 05:06:38 bluhm Exp $
d47 2
d50 9
a58 1
	my $in = <STDIN>;
d78 1
a78 1
		$c->loggrep(qr/^>>> Client$/) or die "no client out"
d80 1
a80 1
		$c->loggrep(qr/^<<< Server$/) or die "no client in"
d84 1
a84 1
		$s->loggrep(qr/^>>> Server$/) or die "no server out"
d86 1
a86 1
		$s->loggrep(qr/^<<< Client$/) or die "no server in"
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#	$OpenBSD$
d36 16
d68 4
a71 2
		$c->loggrep(qr/^>>> Client$/) or die "no client out";
		$c->loggrep(qr/^<<< Server$/) or die "no client in";
d74 4
a77 2
		$s->loggrep(qr/^>>> Server$/) or die "no server out";
		$s->loggrep(qr/^<<< Client$/) or die "no server in";
@


1.1.1.1
log
@Add a regression test suite for the pf divert-to and divert-reply
feature.  It requires two machines, the local host is running the
regression test, the remote host gets pf divert rules installed.
The diverted TCP connections are running between these hosts in
both directions.  The remote host is controlled via ssh.
@
text
@@
