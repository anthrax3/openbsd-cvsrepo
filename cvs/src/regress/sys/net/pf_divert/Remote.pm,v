head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.4
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.6.0.2
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.3.0.6
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	bluhm_20130603:1.1.1.1
	bluhm:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2017.09.01.17.44.00;	author bluhm;	state Exp;
branches;
next	1.8;
commitid	x7OfHSqgu79gS9ee;

1.8
date	2017.08.15.04.11.20;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	LHIvCN212Bjl0MLN;

1.7
date	2016.11.15.16.00.50;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	GFMbw7tGYp1GtemC;

1.6
date	2016.05.03.19.13.04;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	QUorL89Z4jPT2RKR;

1.5
date	2015.06.25.19.29.57;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	7rKQ3g1MlOMYaffv;

1.4
date	2014.08.18.22.58.19;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	Lrki66TGIJh8PoUM;

1.3
date	2013.11.03.00.32.36;	author bluhm;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.04.04.17.42;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2013.06.03.05.06.38;	author bluhm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.06.03.05.06.38;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Increase timeout, otherwise test may fail on slow machines.
@
text
@#	$OpenBSD: Remote.pm,v 1.8 2017/08/15 04:11:20 bluhm Exp $

# Copyright (c) 2010-2014 Alexander Bluhm <bluhm@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package Remote;
use parent 'Proc';
use Carp;
use Cwd;
use File::Basename;

sub new {
	my $class = shift;
	my %args = @@_;
	$args{logfile} ||= "remote.log";
	$args{up} ||= "Started";
	$args{down} ||= "Shutdown";
	$args{func} = sub { Carp::confess "$class func may not be called" };
	$args{remotessh}
	    or croak "$class remote ssh host not given";
	my $self = Proc::new($class, %args);
	$self->{af}
	    or croak "$class address family not given";
	$self->{bindaddr}
	    or croak "$class bind addr not given";
	$self->{connectaddr}
	    or croak "$class connect addr not given";
	defined $self->{connectport}
	    or croak "$class connect port not given";
	return $self;
}

sub up {
	my $self = Proc::up(shift, @@_);
	my $timeout = shift || 20;
	if ($self->{connect}) {
		$self->loggrep(qr/^Connected$/, $timeout)
		    or croak ref($self), " no Connected in $self->{logfile} ".
			"after $timeout seconds";
		return $self;
	}
	my $lsock = $self->loggrep(qr/^listen sock: /, $timeout)
	    or croak ref($self), " no listen sock in $self->{logfile} ".
		"after $timeout seconds";
	my($addr, $port) = $lsock =~ /: (\S+) (\S+)$/
	    or croak ref($self), " no listen addr and port in $self->{logfile}";
	$self->{listenaddr} = $addr;
	$self->{listenport} = $port;
	return $self;
}

sub child {
	my $self = shift;
	my @@remoteopts;

	if ($self->{opts}) {
		my %opts = %{$self->{opts}};
		foreach my $k (sort keys %opts) {
			push @@remoteopts, "-$k";
			my $v = $opts{$k};
			push @@remoteopts, $v if $k =~ /[A-Z]/ or $v ne 1;
		}
	}

	print STDERR $self->{up}, "\n";
	my @@sshopts = $ENV{SSH_OPTIONS} ? split(' ', $ENV{SSH_OPTIONS}) : ();
	my @@sudo = $ENV{SUDO} ? ($ENV{SUDO}, "SUDO=$ENV{SUDO}") : ();
	my $dir = dirname($0);
	$dir = getcwd() if ! $dir || $dir eq ".";
	my @@cmd = ("ssh", "-n", @@sshopts, $self->{remotessh}, @@sudo, "perl",
	    "-I", $dir, "$dir/".basename($0), @@remoteopts, $self->{af},
	    $self->{bindaddr}, $self->{connectaddr}, $self->{connectport},
	    ($self->{bindport} ? $self->{bindport} : ()),
	    ($self->{testfile} ? "$dir/".basename($self->{testfile}) : ()));
	print STDERR "execute: @@cmd\n";
	$< = $>;
	exec @@cmd;
	die ref($self), " exec '@@cmd' failed: $!";
}

1;
@


1.8
log
@Add tests for pf divert-packet.  Currently UDP packets are tested
with in and out rules.  A single packet, the initial packet or the
response packet are diverted and reinjected.
@
text
@d1 1
a1 1
#	$OpenBSD: Remote.pm,v 1.7 2016/11/15 16:00:50 bluhm Exp $
d49 1
a49 1
	my $timeout = shift || 10;
@


1.7
log
@Mark pf states created by this regress test with a label.  Remove
all such states before basic testing to make sure that these subtests
are independent.
@
text
@d1 1
a1 1
#	$OpenBSD: Remote.pm,v 1.6 2016/05/03 19:13:04 bluhm Exp $
d31 1
@


1.6
log
@Fix some Perl statements perlcritic was bitching about: Variable
declared in conditional statement.
@
text
@d1 1
a1 1
#	$OpenBSD: Remote.pm,v 1.5 2015/06/25 19:29:57 bluhm Exp $
d67 10
d79 1
a79 1
	my @@opts = $ENV{SSH_OPTIONS} ? split(' ', $ENV{SSH_OPTIONS}) : ();
d83 2
a84 2
	my @@cmd = ("ssh", "-n", @@opts, $self->{remotessh}, @@sudo, "perl",
	    "-I", $dir, "$dir/".basename($0), $self->{af},
@


1.5
log
@Align the three variants of Remote.pm.
@
text
@d1 1
a1 1
#	$OpenBSD: Remote.pm,v 1.4 2014/08/18 22:58:19 bluhm Exp $
d69 1
a69 1
	my @@opts = split(' ', $ENV{SSH_OPTIONS}) if $ENV{SSH_OPTIONS};
@


1.4
log
@Make the perl modules consistent for the multiple regression tests.
This includes coding style, better error messages and variable
naming.
@
text
@d1 1
a1 1
#	$OpenBSD: Remote.pm,v 1.3 2013/11/03 00:32:36 bluhm Exp $
d77 1
a77 2
	    ($self->{testfile} ? "$dir/".basename($self->{testfile}) :
	    ()));
@


1.3
log
@Add divert tests that reuse protocol and port.  They show what
happens when we close the socket but the divert state remains.  If
a new socket uses the same protocol and port, it will use the old
dangling state.  Without searching for the correct rule, the divert-to
will fail.  There are real life corner cases where this occurred.
@
text
@d1 1
a1 1
#	$OpenBSD: Remote.pm,v 1.2 2013/06/04 04:17:42 bluhm Exp $
d3 1
a3 1
# Copyright (c) 2010-2013 Alexander Bluhm <bluhm@@openbsd.org>
d72 3
a74 3
	$dir = getcwd() if ! $dir || $dir eq '.';
	my @@cmd = ('ssh', '-n', @@opts, $self->{remotessh}, @@sudo, 'perl',
	    '-I', $dir, "$dir/".basename($0), $self->{af},
d79 1
a79 1
	print STDERR "remote command: @@cmd\n";
d82 1
a82 1
	die "Exec @@cmd failed: $!";
@


1.2
log
@Add tests for raw IP divert.  Set effective user ID to 0 only during
privileged operations for raw sockets and bind any.
@
text
@d1 1
a1 1
#	$OpenBSD: Remote.pm,v 1.1.1.1 2013/06/03 05:06:38 bluhm Exp $
d76 1
d79 1
a79 1
	print STDERR "execute: @@cmd\n";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#	$OpenBSD$
d49 1
a49 1
	if ($self->{connectport}) {
d70 1
a70 3
	# if sudo is set, run the remote perl as root, otherwise pass SUDO
	my @@sudo = !$ENV{SUDO} ? () :
	    $self->{sudo} ? $ENV{SUDO} : "SUDO=$ENV{SUDO}";
d79 1
@


1.1.1.1
log
@Add a regression test suite for the pf divert-to and divert-reply
feature.  It requires two machines, the local host is running the
regression test, the remote host gets pf divert rules installed.
The diverted TCP connections are running between these hosts in
both directions.  The remote host is controlled via ssh.
@
text
@@
