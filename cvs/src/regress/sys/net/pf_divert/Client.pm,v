head	1.4;
access;
symbols
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.3.0.18
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.14
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.4
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.12
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.10
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.8
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	bluhm_20130603:1.1.1.1
	bluhm:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2017.08.15.04.11.20;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	LHIvCN212Bjl0MLN;

1.3
date	2013.06.05.04.34.27;	author bluhm;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.04.04.17.42;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2013.06.03.05.06.38;	author bluhm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.06.03.05.06.38;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Add tests for pf divert-packet.  Currently UDP packets are tested
with in and out rules.  A single packet, the initial packet or the
response packet are diverted and reinjected.
@
text
@#	$OpenBSD: Client.pm,v 1.3 2013/06/05 04:34:27 bluhm Exp $

# Copyright (c) 2010-2013 Alexander Bluhm <bluhm@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package Client;
use parent 'Proc';
use Carp;
use Socket qw(IPPROTO_TCP TCP_NODELAY);
use Socket6;
use IO::Socket;
use IO::Socket::INET6;
use constant SO_BINDANY => 0x1000;

sub new {
	my $class = shift;
	my %args = @@_;
	$args{logfile} ||= "client.log";
	$args{up} ||= "Connected";
	$args{down} ||= $args{alarm} ? "Alarm $class" :
	    "Shutdown $class|Broken pipe|Connection reset by peer";
	my $self = Proc::new($class, %args);
	$self->{domain}
	    or croak "$class domain not given";
	$self->{protocol}
	    or croak "$class protocol not given";
	$self->{connectaddr}
	    or croak "$class connect addr not given";
	$self->{connectport} || $self->{protocol} !~ /^(tcp|udp)$/
	    or croak "$class connect port not given";

	my $cs;
	if ($self->{bindany}) {
		do { local $> = 0; $cs = IO::Socket::INET6->new(
		    Type	=> $self->{socktype},
		    Proto	=> $self->{protocol},
		    Domain	=> $self->{domain},
		    Blocking	=> ($self->{nonblocking} ? 0 : 1),
		) } or die ref($self), " socket connect failed: $!";
		do { local $> = 0; $cs->setsockopt(SOL_SOCKET, SO_BINDANY, 1) }
		    or die ref($self), " setsockopt SO_BINDANY failed: $!";
		my @@rres = getaddrinfo($self->{bindaddr}, $self->{bindport}||0,
		    $self->{domain}, SOCK_STREAM, 0, AI_PASSIVE);
		$cs->bind($rres[3])
		    or die ref($self), " bind failed: $!";
	} elsif ($self->{bindaddr} || $self->{bindport}) {
		do { local $> = 0; $cs = IO::Socket::INET6->new(
		    Type	=> $self->{socktype},
		    Proto	=> $self->{protocol},
		    Domain	=> $self->{domain},
		    Blocking	=> ($self->{nonblocking} ? 0 : 1),
		    LocalAddr	=> $self->{bindaddr},
		    LocalPort	=> $self->{bindport},
		) } or die ref($self), " socket connect failed: $!";
	}
	if ($cs) {
		$self->{bindaddr} = $cs->sockhost();
		$self->{bindport} = $cs->sockport();
		$self->{cs} = $cs;
	}

	return $self;
}

sub child {
	my $self = shift;

	my $cs = $self->{cs} || do { local $> = 0; IO::Socket::INET6->new(
	    Type	=> $self->{socktype},
	    Proto	=> $self->{protocol},
	    Domain	=> $self->{domain},
	    Blocking	=> ($self->{nonblocking} ? 0 : 1),
	) } or die ref($self), " socket connect failed: $!";
	if ($self->{oobinline}) {
		setsockopt($cs, SOL_SOCKET, SO_OOBINLINE, pack('i', 1))
		    or die ref($self), " set oobinline connect failed: $!";
	}
	if ($self->{sndbuf}) {
		setsockopt($cs, SOL_SOCKET, SO_SNDBUF,
		    pack('i', $self->{sndbuf}))
		    or die ref($self), " set sndbuf connect failed: $!";
	}
	if ($self->{rcvbuf}) {
		setsockopt($cs, SOL_SOCKET, SO_RCVBUF,
		    pack('i', $self->{rcvbuf}))
		    or die ref($self), " set rcvbuf connect failed: $!";
	}
	if ($self->{protocol} eq "tcp") {
		setsockopt($cs, IPPROTO_TCP, TCP_NODELAY, pack('i', 1))
		    or die ref($self), " set nodelay connect failed: $!";
	}
	my @@rres = getaddrinfo($self->{connectaddr}, $self->{connectport},
	    $self->{domain}, SOCK_STREAM);
	$cs->connect($rres[3])
	    or die ref($self), " connect failed: $!";
	print STDERR "connect sock: ",$cs->sockhost()," ",$cs->sockport(),"\n";
	print STDERR "connect peer: ",$cs->peerhost()," ",$cs->peerport(),"\n";
	$self->{bindaddr} = $cs->sockhost();
	$self->{bindport} = $cs->sockport();

	open(STDOUT, '>&', $cs)
	    or die ref($self), " dup STDOUT failed: $!";
	open(STDIN, '<&', $cs)
	    or die ref($self), " dup STDIN failed: $!";
}

1;
@


1.3
log
@Add tests for ICMP and ICMP6 divert-to.
@
text
@d1 1
a1 1
#	$OpenBSD: Client.pm,v 1.2 2013/06/04 04:17:42 bluhm Exp $
d34 2
a35 2
	$args{down} ||= $args{alarm} ? "Alarm" :
	    "Shutdown|Broken pipe|Connection reset by peer";
@


1.2
log
@Add tests for raw IP divert.  Set effective user ID to 0 only during
privileged operations for raw sockets and bind any.
@
text
@d1 1
a1 1
#	$OpenBSD: Client.pm,v 1.1.1.1 2013/06/03 05:06:38 bluhm Exp $
d37 4
a40 3
	$self->{protocol} ||= "tcp";
	$self->{connectdomain}
	    or croak "$class connect domain not given";
d51 1
a51 1
		    Domain	=> $self->{connectdomain},
d57 1
a57 1
		    $self->{connectdomain}, SOCK_STREAM, 0, AI_PASSIVE);
d64 1
a64 1
		    Domain	=> $self->{connectdomain},
d85 1
a85 1
	    Domain	=> $self->{connectdomain},
d107 1
a107 1
	    $self->{connectdomain}, SOCK_STREAM);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#	$OpenBSD$
d42 1
a42 1
	$self->{connectport}
d47 2
a48 1
		$cs = IO::Socket::INET6->new(
d52 2
a53 2
		) or die ref($self), " socket connect failed: $!";
		$cs->setsockopt(SOL_SOCKET, SO_BINDANY, 1)
d60 2
a61 1
		$cs = IO::Socket::INET6->new(
d67 1
a67 1
		) or die ref($self), " socket connect failed: $!";
d81 2
a82 1
	my $cs = $self->{cs} || IO::Socket::INET6->new(
d86 1
a86 1
	) or die ref($self), " socket connect failed: $!";
@


1.1.1.1
log
@Add a regression test suite for the pf divert-to and divert-reply
feature.  It requires two machines, the local host is running the
regression test, the remote host gets pf divert rules installed.
The diverted TCP connections are running between these hosts in
both directions.  The remote host is controlled via ssh.
@
text
@@
