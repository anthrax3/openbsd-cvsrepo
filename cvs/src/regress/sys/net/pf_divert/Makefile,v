head	1.15;
access;
symbols
	OPENBSD_6_0:1.12.0.6
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.11.0.4
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	bluhm_20130603:1.1.1.1
	bluhm:1.1.1;
locks; strict;
comment	@# @;


1.15
date	2016.11.16.16.00.41;	author bluhm;	state Exp;
branches;
next	1.14;
commitid	HcYreLkAjRomKg9e;

1.14
date	2016.11.15.16.00.50;	author bluhm;	state Exp;
branches;
next	1.13;
commitid	GFMbw7tGYp1GtemC;

1.13
date	2016.09.02.21.30.34;	author bluhm;	state Exp;
branches;
next	1.12;
commitid	sbZCO4zszQKrda5x;

1.12
date	2015.07.28.12.31.29;	author bluhm;	state Exp;
branches;
next	1.11;
commitid	o6wdSs3EDVW9tmqt;

1.11
date	2014.08.18.22.58.19;	author bluhm;	state Exp;
branches;
next	1.10;
commitid	Lrki66TGIJh8PoUM;

1.10
date	2014.07.12.21.00.46;	author bluhm;	state Exp;
branches;
next	1.9;
commitid	kRAUZYkP8QlyLbU8;

1.9
date	2014.07.11.20.41.20;	author bluhm;	state Exp;
branches;
next	1.8;
commitid	rghTlQRdYGi3EoZU;

1.8
date	2014.01.08.23.42.23;	author bluhm;	state Exp;
branches;
next	1.7;

1.7
date	2013.11.03.14.03.35;	author bluhm;	state Exp;
branches;
next	1.6;

1.6
date	2013.11.03.00.32.36;	author bluhm;	state Exp;
branches;
next	1.5;

1.5
date	2013.11.01.18.07.45;	author bluhm;	state Exp;
branches;
next	1.4;

1.4
date	2013.08.11.21.49.04;	author bluhm;	state Exp;
branches;
next	1.3;

1.3
date	2013.06.17.19.42.27;	author bluhm;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.04.04.17.42;	author bluhm;	state Exp;
branches;
next	1.1;

1.1
date	2013.06.03.05.06.38;	author bluhm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.06.03.05.06.38;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Test multiple combinations of divert connections.  The socket cleanup
of the first connection must remove the pf state so that the second
connection can succeed.  Disable two raw IP tests that do not work
with the current implementation in the kernel.
@
text
@#	$OpenBSD: Makefile,v 1.14 2016/11/15 16:00:50 bluhm Exp $

# The following ports must be installed for the regression tests:
# p5-IO-Socket-INET6	object interface for AF_INET and AF_INET6 domain sockets
# p5-Socket6		Perl defines relating to AF_INET6 sockets
#
# Check wether all required perl packages are installed.  If some
# are missing print a warning and skip the tests, but do not fail.

PERL_REQUIRE !=	perl -Mstrict -Mwarnings -e ' \
    eval { require IO::Socket::INET6 } or print $@@; \
    eval { require Socket6 } or print $@@; \
'
.if ! empty(PERL_REQUIRE)
regress:
	@@echo "${PERL_REQUIRE}"
	@@echo install these perl packages for additional tests
	@@echo SKIPPED
.endif

# Fill out these variables as you have to test divert with the pf
# kernel running on a remote machine.  You have to specify a local
# and remote ip address for the test connections.  The fake ip address
# will be routed via the remote address to test divert with non-existing
# addresses.  To control the remote machine you need a hostname for
# ssh to log in.  All the test files must be in the same directory
# local and remote.
# You must have an anchor "regress" for the divert rules in the pf.conf
# of the remote machine.  The kernel of the remote machine gets testet.
#
# Run make check-setup to see if you got the setup correct.

LOCAL_ADDR ?=
REMOTE_ADDR ?=
FAKE_ADDR ?=
LOCAL_ADDR6 ?=
REMOTE_ADDR6 ?=
FAKE_ADDR6 ?=
REMOTE_SSH ?=

.if empty (LOCAL_ADDR) || empty (REMOTE_ADDR) || empty (FAKE_ADDR) || \
    empty (LOCAL_ADDR6) || empty (REMOTE_ADDR6) || empty (FAKE_ADDR6) || \
    empty (REMOTE_SSH)
regress:
	@@echo This tests needs a remote machine to operate on.
	@@echo LOCAL_ADDR REMOTE_ADDR FAKE_ADDR LOCAL_ADDR6
	@@echo REMOTE_ADDR6 FAKE_ADDR6 REMOTE_SSH are empty.
	@@echo Fill out these variables for additional tests.
	@@echo SKIPPED
.endif

# Automatically generate regress targets from test cases in directory.

ARGS !=			cd ${.CURDIR} && ls args-*.pl
TARGETS ?=		inet-args-tcp-to inet6-args-tcp-to \
			inet-args-tcp-reply inet6-args-tcp-reply \
			inet-args-udp-to inet6-args-udp-to \
			inet-args-udp-reply inet6-args-udp-reply \
			inet-args-udp-reply-to inet6-args-udp-reply-to \
			inet-args-rip-to inet6-args-rip-to \
			inet-args-rip-reply inet6-args-rip-reply \
			inet-args-rip-reply-to inet6-args-rip-reply-to \
			inet-args-icmp-to inet6-args-icmp-to \
			inet-args-icmp-reply-to inet6-args-icmp-reply-to \
			inet-args-icmp-reply-reuse inet6-args-icmp-reply-reuse \
			inet-reuse-tcp-to-to inet6-reuse-tcp-to-to \
			inet-reuse-tcp-to-reply inet6-reuse-tcp-to-reply \
			inet-reuse-tcp-reply-to inet6-reuse-tcp-reply-to \
			inet-reuse-tcp-reply-reply inet6-reuse-tcp-reply-reply \
			inet-reuse-udp-to-to inet6-reuse-udp-to-to \
			inet-reuse-udp-to-reply inet6-reuse-udp-to-reply \
			inet-reuse-udp-to-reply-to inet6-reuse-udp-to-reply-to \
			inet-reuse-udp-reply-to inet6-reuse-udp-reply-to \
			inet-reuse-udp-reply-reply inet6-reuse-udp-reply-reply \
			inet-reuse-udp-reply-reply-to inet6-reuse-udp-reply-reply-to \
			inet-reuse-udp-reply-to-to inet6-reuse-udp-reply-to-to \
			inet-reuse-udp-reply-to-reply inet6-reuse-udp-reply-to-reply \
			inet-reuse-udp-reply-to-reply-to inet6-reuse-udp-reply-to-reply-to \
			inet-reuse-rip-to-to inet6-reuse-rip-to-to \
			inet-reuse-rip-to-reply inet6-reuse-rip-to-reply \
			inet-reuse-rip-to-reply-to inet6-reuse-rip-to-reply-to \
			inet-reuse-rip-reply-to inet6-reuse-rip-reply-to \
			inet-reuse-rip-reply-reply inet6-reuse-rip-reply-reply \
			inet-reuse-rip-reply-reply-to inet6-reuse-rip-reply-reply-to \
			inet-reuse-rip-reply-to-to inet6-reuse-rip-reply-to-to \
			inet-reuse-rip-reply-to-reply inet6-reuse-rip-reply-to-reply \
			inet-reuse-rip-reply-to-reply-to inet6-reuse-rip-reply-to-reply-to
REGRESS_TARGETS =	${TARGETS:S/^/run-regress-/}
CLEANFILES +=		*.log *.port ktrace.out stamp-*

.MAIN: all

.if ! empty (REMOTE_SSH)
.if make (regress) || make (all)
.BEGIN:
	@@echo
	${SUDO} true
	ssh -t ${REMOTE_SSH} ${SUDO} true
.if ! empty (FAKE_ADDR) && ! empty (REMOTE_ADDR)
	-${SUDO} route -n delete -inet -host ${FAKE_ADDR} 2>/dev/null
	${SUDO} route -n add -inet -host ${FAKE_ADDR} ${REMOTE_ADDR}
.endif
.if ! empty (FAKE_ADDR6) && ! empty (REMOTE_ADDR6)
	-${SUDO} route -n delete -inet6 -host ${FAKE_ADDR6} 2>/dev/null
	${SUDO} route -n add -inet6 -host ${FAKE_ADDR6} ${REMOTE_ADDR6}
.endif
.endif
.endif

# Set variables so that make runs with and without obj directory.
# Only do that if necessary to keep visible output short.

.if ${.CURDIR} == ${.OBJDIR}
PERLINC =	-I.
PERLPATH =
.else
PERLINC =	-I${.CURDIR}
PERLPATH =	${.CURDIR}/
.endif

# The arg tests take a perl hash with arguments controlling the test
# parameters.  The remote.pl test has local client or server and the
# diverted process is running on the remote machine reachable with
# ssh.

.for  inet addr  in  inet ADDR  inet6 ADDR6

run-regress-${inet}-reuse-rip-to-reply-to:
	@@echo '\n======== $@@ ========'
	@@echo 'rip to before reply is broken, it does not remove the state.'
	@@echo DISABLED

.for a in ${ARGS}
run-regress-${inet}-${a:R}: ${a}
	@@echo '\n======== $@@ ========'
	time ${SUDO} SUDO=${SUDO} perl ${PERLINC} ${PERLPATH}remote.pl -f ${inet} ${LOCAL_${addr}} ${FAKE_${addr}} ${REMOTE_SSH} ${PERLPATH}${a}
.endfor

.for proto in tcp udp rip

.for  first second  in  to to  to reply  to reply-to  reply to  reply reply  reply reply-to  reply-to to  reply-to reply  reply-to reply-to

run-regress-${inet}-reuse-${proto}-${first}-${second}:
	@@echo '\n======== $@@ ========'
	time ${SUDO} SUDO=${SUDO} perl ${PERLINC} ${PERLPATH}remote.pl -f ${inet} ${LOCAL_${addr}} ${FAKE_${addr}} ${REMOTE_SSH} ${PERLPATH}args-${proto}-${first}.pl
	sed -n '/^connect peer:/s/.* //p' client.log >client.port
	sed -n '/^connect sock:/s/.* //p' client.log >server.port
.if "tcp" == ${proto}
.if "reply" == ${first}
	${SUDO} tcpdrop ${LOCAL_${addr}} `cat client.port` ${FAKE_${addr}} `cat server.port`
.endif
.if "to" == ${first}
	ssh ${REMOTE_SSH} ${SUDO} tcpdrop ${FAKE_${addr}} `cat client.port` ${LOCAL_${addr}} `cat server.port`
.endif
.endif
	time ${SUDO} SUDO=${SUDO} perl ${PERLINC} ${PERLPATH}remote.pl ${inet} ${LOCAL_${addr}} ${FAKE_${addr}} ${REMOTE_SSH} `cat client.port` `cat server.port` ${PERLPATH}args-${proto}-${second}.pl
.if "tcp" == ${proto}
.if "reply" == ${second}
	${SUDO} tcpdrop ${LOCAL_${addr}} `cat server.port` ${FAKE_${addr}} `cat client.port`
.endif
.if "to" == ${second}
	ssh ${REMOTE_SSH} ${SUDO} pfctl -ss | \
	    egrep 'all ${proto} ${FAKE_${addr}}:?\[?'`cat server.port`\]?' .. ${LOCAL_${addr}}:?\[?'`cat client.port`'\]? '
	ssh ${REMOTE_SSH} ${SUDO} tcpdrop ${FAKE_${addr}} `cat server.port` ${LOCAL_${addr}} `cat client.port`
	ssh ${REMOTE_SSH} ${SUDO} pfctl -ss | \
	    ! egrep 'all ${proto} ${FAKE_${addr}}:?\[?'`cat server.port`\]?' .. ${LOCAL_${addr}}:?\[?'`cat client.port`'\]? '
.endif
.endif

.endfor
.endfor
.endfor

.PHONY: syntax check-setup

# make perl syntax check for all args files
syntax: stamp-syntax

stamp-syntax: ${ARGS}
.for a in ${ARGS}
	@@perl -c ${PERLPATH}$a
.endfor
	@@date >$@@

# Check wether the address, route and remote setup is correct
check-setup:
	@@echo '\n======== $@@ ========'
	ping -n -c 1 ${LOCAL_ADDR}
	ping -n -c 1 ${REMOTE_ADDR}
	ping6 -n -c 1 ${LOCAL_ADDR6}
	ping6 -n -c 1 ${REMOTE_ADDR6}
	route -n get -inet ${FAKE_ADDR} | grep 'if address: ${LOCAL_ADDR}$$'
	route -n get -inet ${FAKE_ADDR} | grep 'gateway: ${REMOTE_ADDR}$$'
	route -n get -inet6 ${FAKE_ADDR6} | grep 'if address: ${LOCAL_ADDR6}$$'
	route -n get -inet6 ${FAKE_ADDR6} | grep 'gateway: ${REMOTE_ADDR6}$$'
	ssh ${REMOTE_SSH} ${SUDO} pfctl -sr | grep '^anchor "regress" all$$'
	ssh ${REMOTE_SSH} ${SUDO} pfctl -si | grep '^Status: Enabled '
	ssh ${REMOTE_SSH} perl -MIO::Socket::INET6 -MSocket6 -e 1

.include <bsd.regress.mk>
@


1.14
log
@Mark pf states created by this regress test with a label.  Remove
all such states before basic testing to make sure that these subtests
are independent.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.13 2016/09/02 21:30:34 bluhm Exp $
d66 22
a87 3
			inet-reuse-tcp inet6-reuse-tcp \
			inet-reuse-udp inet6-reuse-udp \
			inet-reuse-rip inet6-reuse-rip
d126 6
a131 1
.for inet addr in inet ADDR inet6 ADDR6
d140 4
a143 1
run-regress-${inet}-reuse-${proto}:
d145 1
a145 1
	time ${SUDO} SUDO=${SUDO} perl ${PERLINC} ${PERLPATH}remote.pl ${inet} ${LOCAL_${addr}} ${FAKE_${addr}} ${REMOTE_SSH} ${PERLPATH}args-${proto}-reply.pl
d149 1
d152 5
a156 1
	time ${SUDO} SUDO=${SUDO} perl ${PERLINC} ${PERLPATH}remote.pl ${inet} ${LOCAL_${addr}} ${FAKE_${addr}} ${REMOTE_SSH} `cat client.port` `cat server.port` ${PERLPATH}args-${proto}-to.pl
d158 6
d165 2
a166 10
.if "inet" == ${inet}
	if ssh ${REMOTE_SSH} ${SUDO} pfctl -ss | \
	    grep 'all ${proto} ${FAKE_${addr}}:'`cat server.port`' .. ${LOCAL_${addr}}:'`cat client.port`' '; \
		then false; \
	fi
.else
	if ssh ${REMOTE_SSH} ${SUDO} pfctl -ss | \
	    grep 'all ${proto} ${FAKE_${addr}}\['`cat server.port`\]' .. ${LOCAL_${addr}}\['`cat client.port`'\] '; \
		then false; \
	fi
d169 2
a171 1

@


1.13
log
@Print SKIPPED if a regress test cannot be executed for some reason.
This allows to identify such tests by looking at their output.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.12 2015/07/28 12:31:29 bluhm Exp $
d112 1
a112 1
	time ${SUDO} SUDO=${SUDO} perl ${PERLINC} ${PERLPATH}remote.pl ${inet} ${LOCAL_${addr}} ${FAKE_${addr}} ${REMOTE_SSH} ${PERLPATH}${a}
@


1.12
log
@Add more and deeper tests for pf divert-reply rules.  Especially
the combination of sending and receiving multiple packets over one
socket is tested for UDP, raw IP and ICMP.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.11 2014/08/18 22:58:19 bluhm Exp $
d18 1
d49 1
@


1.11
log
@Make the perl modules consistent for the multiple regression tests.
This includes coding style, better error messages and variable
naming.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.10 2014/07/12 21:00:46 bluhm Exp $
d57 1
d60 1
d62 2
@


1.10
log
@Use a saner and consistent address layout for my network tests that
run over 4 machines.  Add a check-setup target to verify that
interface addresses and routes are properly set up.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.9 2014/07/11 20:41:20 bluhm Exp $
d44 1
a44 1
	@@echo this tests needs a remote machine to operate on
d46 2
a47 2
	@@echo REMOTE_ADDR6 FAKE_ADDR6 REMOTE_SSH are empty
	@@echo fill out these variables for additional tests
d161 1
a161 1
	ssh ${REMOTE_SSH} perl -MIO::Socket::INET6 -MIO::Socket::INET6 -e 1
@


1.9
log
@Make the test output easier to read by splitting the test cases
with an empty line and a header line.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.8 2014/01/08 23:42:23 bluhm Exp $
d29 2
d150 1
@


1.8
log
@Fix the tests for the pf divert state and socket reuse.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.7 2013/11/03 14:03:35 bluhm Exp $
d103 1
a103 2
	@@echo
	@@echo $@@
d109 1
a109 2
	@@echo
	@@echo $@@
@


1.7
log
@Grep pf state table on remote machine to find state reuse problems.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.6 2013/11/03 00:32:36 bluhm Exp $
d119 2
a120 6
.if "rip" == ${proto}
	if ssh ${REMOTE_SSH} ${SUDO} pfctl -ss | \
	    grep 'all 254 ${FAKE_${addr}} .. ${LOCAL_${addr}} '; \
		then false; \
	fi
.else
a136 2
# make perl syntax check for all args files

d139 1
d154 4
a157 4
	route get -inet ${FAKE_ADDR} | grep 'if address: ${LOCAL_ADDR}$$'
	route get -inet ${FAKE_ADDR} | grep 'gateway: ${REMOTE_ADDR}$$'
	route get -inet6 ${FAKE_ADDR6} | grep 'if address: ${LOCAL_ADDR6}$$'
	route get -inet6 ${FAKE_ADDR6} | grep 'gateway: ${REMOTE_ADDR6}$$'
@


1.6
log
@Add divert tests that reuse protocol and port.  They show what
happens when we close the socket but the divert state remains.  If
a new socket uses the same protocol and port, it will use the old
dangling state.  Without searching for the correct rule, the divert-to
will fail.  There are real life corner cases where this occurred.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.5 2013/11/01 18:07:45 bluhm Exp $
d112 1
a112 1
	time ${SUDO} SUDO=${SUDO} ktrace -i perl ${PERLINC} ${PERLPATH}remote.pl ${inet} ${LOCAL_${addr}} ${FAKE_${addr}} ${REMOTE_SSH} ${PERLPATH}args-${proto}-reply.pl
d119 18
@


1.5
log
@Add a check-setup target.  This allows to find setup errors more
easily.  A remote machine with correct addresses, routes and pf
rules is needed for the test.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.4 2013/08/11 21:49:04 bluhm Exp $
d51 10
a60 1
TARGETS ?=		${ARGS}
d62 1
a62 1
CLEANFILES +=		*.log ktrace.out stamp-*
d99 2
d102 1
a102 2
run-regress-$a: $a
.if !empty (LOCAL_ADDR)
d104 6
a109 3
	time ${SUDO} SUDO=${SUDO} perl ${PERLINC} ${PERLPATH}remote.pl inet ${LOCAL_ADDR} ${FAKE_ADDR} ${REMOTE_SSH} ${PERLPATH}$a
.endif
.if !empty (LOCAL_ADDR6)
d111 6
a116 1
	time ${SUDO} SUDO=${SUDO} perl ${PERLINC} ${PERLPATH}remote.pl inet6 ${LOCAL_ADDR6} ${FAKE_ADDR6} ${REMOTE_SSH} ${PERLPATH}$a
d118 3
@


1.4
log
@Check wether the required perl packages are installed and that the
environment for the remote testing machine is set up.  If not, print
a message and skip the regression tests.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.3 2013/06/17 19:42:27 bluhm Exp $
d104 1
a104 1
.PHONY: syntax
d113 14
@


1.3
log
@Do not write my IP addresses into the pf_divert Makefile, the tester
has to fill in his own addresses.  Link the pf_divert regression
tests to the build.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.2 2013/06/04 04:17:42 bluhm Exp $
d6 12
a17 5


TARGETS ?=		${ARGS}
.if empty (TARGETS)
ARGS !=			cd ${.CURDIR} && ls args-*.pl
a18 2
REGRESS_TARGETS =	${TARGETS:S/^/run-regress-/}
CLEANFILES +=		*.log ktrace.out stamp-*
d38 17
d57 2
a58 1
.if make(regress) || make(all)
a59 3
.if empty (REMOTE_SSH)
	@@echo "remote test target host not set"; false
.endif
d62 2
a63 1
	ssh -t q0 ${SUDO} true
d66 2
d70 2
@


1.2
log
@Add tests for raw IP divert.  Set effective user ID to 0 only during
privileged operations for raw sockets and bind any.
@
text
@d1 1
a1 1
#	$OpenBSD: Makefile,v 1.1.1.1 2013/06/03 05:06:38 bluhm Exp $
d25 7
a31 7
LOCAL_ADDR ?= 10.188.50.10
REMOTE_ADDR ?= 10.188.50.50
FAKE_ADDR ?= 10.188.50.51
LOCAL_ADDR6 ?= fdd7:e83e:66bc:211:fce1:baff:fed1:561f
REMOTE_ADDR6 ?= fdd7:e83e:66bc:211:5054:ff:fe12:3450
FAKE_ADDR6 ?= fdd7:e83e:66bc:211:5054:ff:fe12:3451
REMOTE_SSH ?= q0
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#	$OpenBSD$
d69 1
a69 1
	time SUDO=${SUDO} perl ${PERLINC} ${PERLPATH}remote.pl inet ${LOCAL_ADDR} ${FAKE_ADDR} ${REMOTE_SSH} ${PERLPATH}$a
d73 1
a73 1
	time SUDO=${SUDO} perl ${PERLINC} ${PERLPATH}remote.pl inet6 ${LOCAL_ADDR6} ${FAKE_ADDR6} ${REMOTE_SSH} ${PERLPATH}$a
@


1.1.1.1
log
@Add a regression test suite for the pf divert-to and divert-reply
feature.  It requires two machines, the local host is running the
regression test, the remote host gets pf divert rules installed.
The diverted TCP connections are running between these hosts in
both directions.  The remote host is controlled via ssh.
@
text
@@
