head	1.5;
access;
symbols
	OPENBSD_6_2_BASE:1.5;
locks; strict;
comment	@# @;


1.5
date	2017.07.22.13.50.54;	author anton;	state Exp;
branches;
next	1.4;
commitid	6r4QszwV0bHrjk08;

1.4
date	2017.07.19.20.09.35;	author anton;	state Exp;
branches;
next	1.3;
commitid	9MGMBJiyBYpL0tDy;

1.3
date	2017.07.06.06.33.42;	author anton;	state Exp;
branches;
next	1.2;
commitid	9BDvKIUz7dcnwtfw;

1.2
date	2017.06.22.18.05.31;	author anton;	state Exp;
branches;
next	1.1;
commitid	IkWPHARPwrMZdYV5;

1.1
date	2017.06.21.19.03.30;	author anton;	state Exp;
branches;
next	;
commitid	b1L3Z0TpwBKzS2Gb;


desc
@@


1.5
log
@Add missing RCS IDs and zap redundant SRCS from Makefile.
@
text
@#!/bin/sh
#
# $OpenBSD$
#
# Copyright (c) 2017 Anton Lindqvist <anton@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

testseq() {
	stdin=$1
	exp=$(echo "$2")
	act=$(echo -n "$stdin" | ./edit -p "$PS1" csh)
	[ $? = 0 ] && [ "$exp" = "$act" ] && return 0

	echo input:
	echo ">>>${stdin}<<<"
	echo -n "$stdin" | hexdump -Cv
	echo expected:
	echo ">>>${exp}<<<"
	echo -n "$exp" | hexdump -Cv
	echo actual:
	echo ">>>${act}<<<"
	echo -n "$act" | hexdump -Cv

	exit 1
}

PS1='? '

# Create a fake HOME with a minimal .cshrc and a few files used for completion.
tmp=$(mktemp -d)
trap 'rm -r $tmp' 0
touch $tmp/ambiguous.{1,2} $tmp/complete $tmp/ignore.{c,o} $tmp/only.o
cat >$tmp/.cshrc <<!
set filec
set fignore = (.o)
set prompt = "$PS1"
cd ~
!

HOME=$tmp
MALLOC_OPTIONS=S
export HOME MALLOC_OPTIONS

# NL: Execute command.
testseq "echo a\n" "? echo a\r\na\r\n? "
testseq "echo \0001\n" "? echo ^A\r\n\0001\r\n? "

# VEOF: List all completions or exit.
testseq "a\0004" "? a^D\r\nambiguous.1  ambiguous.2  \r\r\n? a"
testseq "ignore\0004" "? ignore^D\r\nignore.c  ignore.o  \r\r\n? ignore"
testseq "set ignoreeof\n\0004" \
	"? set ignoreeof\r\n? ^D\r\nUse \"exit\" to leave csh.\r\n? "
testseq "set ignoreeof\na\0004" \
	"? set ignoreeof\r\n? a^D\r\nambiguous.1  ambiguous.2  \r\r\n? a"

# VEOL: File name completion.
testseq "\0033" "? \0007"
testseq "c\0033" "? complete"
testseq "a\0033" "? a\0007mbiguous."
testseq "~${USER}\0033" "? ~${USER}"
testseq "ignore\0033" "? ignore.c"
testseq "only\0033" "? only.o"

# VERASE: Delete character.
testseq "\0177" "? "
testseq "ab\0177\0177\0177" "? ab\b \b\b \b"
testseq "a\0002\0177" "? a^B\b\b  \b\b"
testseq "\0001\0002\0177" "? ^A^B\b\b  \b\b"
testseq "\t\0177" "?         \b\b\b\b\b\b\b\b        \b\b\b\b\b\b\b\b"

# VINTR: Abort line.
testseq "\0003" "? ^C\r\n? "
testseq "ab\0003" "? ab^C\r\n? "
testseq "foreach i ()\n\0003" "? foreach i ()\r\n? ^C\r\r\n? "

# VKILL: Kill line.
testseq "\0025" "? "
testseq "ab\0025" "? ab\b\b  \b\b"

# VLNEXT: Insert literal.
testseq "\0026\0007" "? ^G"
testseq "\0026\0033" "? ^["
testseq "echo \0026\0001a\n" "? echo ^Aa\r\n\0001a\r\n? "

# VREPRINT: Reprint line.
testseq "ab\0022" "? ab^R\r\nab"

# XXX VSTATUS: Send TIOCSTAT.

# VWERASE: Delete word.
testseq "\0027" "? "
testseq "ab\0027" "? ab\b\b  \b\b"
testseq "ab cd\0027\0027" "? ab cd\b\b  \b\b\b\b\b   \b\b\b"

# VWERASE: Delete word using altwerase.
testseq "stty altwerase\n\0027" "? stty altwerase\r\n? "
testseq "stty altwerase\nab\0027" "? stty altwerase\r\n? ab\b\b  \b\b"
testseq "stty altwerase\nab/cd\0027\0027" \
	"? stty altwerase\r\n? ab/cd\b\b  \b\b\b\b\b   \b\b\b"
@


1.4
log
@The first version of the edit program used to test csh, ksh and mail was based
on the following reasoning: once the program to test has written some data it
has entered the main-loop and is by now ready to receive user input. At this
point it should be safe to start writing input and once the program once again
enters a blocking reading state, its done processing the input. This approach
was sensitive to timing and determining when a shell is done processing its
input (if ever) is tricky.

This iteration of the edit program takes a new approach and uses presence of a
prompt for synchronisation of I/O. It doesn't solve all problems but is a step
in the right direction.

Joint work with bluhm@@
@
text
@d3 2
@


1.3
log
@Add tests for all features of file completion in csh.
@
text
@a16 2
set -e

d20 2
a21 2
	act=$(echo -n "$stdin" | ./edit csh)
	[ "$exp" = "$act" ] && return 0
d33 1
a33 1
	return 1
d36 2
d45 1
a45 1
set prompt = " % "
d54 2
a55 2
testseq "echo a\nb" " % echo a\r\na\r\n % b"
testseq "echo \0001\nb" " % echo ^A\r\n\0001\r\n % b"
d58 2
a59 3
testseq "\0004" " % exit\r"
testseq "a\0004" " % a^D\r\nambiguous.1  ambiguous.2  \r\r\n % a"
testseq "ignore\0004" " % ignore^D\r\nignore.c  ignore.o  \r\r\n % ignore"
d61 1
a61 1
	" % set ignoreeof\r\n % ^D\r\nUse \"exit\" to leave csh.\r\n % "
d63 1
a63 1
	" % set ignoreeof\r\n % a^D\r\nambiguous.1  ambiguous.2  \r\r\n % a"
d66 6
a71 6
testseq "\0033" " % \0007"
testseq "c\0033" " % complete"
testseq "a\0033" " % a\0007mbiguous."
testseq "~${USER}\0033" " % ~${USER}"
testseq "ignore\0033" " % ignore.c"
testseq "only\0033" " % only.o"
d74 5
a78 5
testseq "\0177" " % "
testseq "ab\0177\0177\0177" " % ab\b \b\b \b"
testseq "a\0002\0177" " % a^B\b\b  \b\b"
testseq "\0001\0002\0177" " % ^A^B\b\b  \b\b"
testseq "\t\0177" " %         \b\b\b\b\b\b\b\b        \b\b\b\b\b\b\b\b"
d81 3
a83 3
testseq "\0003" " % ^C\r\n % "
testseq "ab\0003" " % ab^C\r\n % "
testseq "foreach i ()\n\0003a" " % foreach i ()\r\n? ^C\r\r\n % a"
d86 2
a87 2
testseq "\0025" " % "
testseq "ab\0025" " % ab\b\b  \b\b"
d90 3
a92 3
testseq "\0026\0007" " % ^G"
testseq "\0026\0033" " % ^["
testseq "echo \0026\na\nb" " % echo ^Ma\r\n\ra\r\n % b"
d95 1
a95 1
testseq "ab\0022" " % ab^R\r\nab"
d100 3
a102 3
testseq "\0027" " % "
testseq "ab\0027" " % ab\b\b  \b\b"
testseq "ab cd\0027\0027" " % ab cd\b\b  \b\b\b\b\b   \b\b\b"
d105 2
a106 2
testseq "stty altwerase\n\0027" " % stty altwerase\r\n % "
testseq "stty altwerase\nab\0027" " % stty altwerase\r\n % ab\b\b  \b\b"
d108 1
a108 1
	" % stty altwerase\r\n % ab/cd\b\b  \b\b\b\b\b   \b\b\b"
@


1.2
log
@
Make sure to abort loops when pressing ^C in csh.

Regression found by deraadt@@
@
text
@d27 1
a27 1
	echo -n "$stdin" | hexdump -C
d30 1
a30 1
	echo -n "$exp" | hexdump -C
d33 1
a33 1
	echo -n "$act" | hexdump -C
d41 2
a42 2
touch "${tmp}/complete" "${tmp}/incomplete.1" "${tmp}/incomplete.2"
cat >"${tmp}/.cshrc" <<!
d44 1
d59 2
a60 1
testseq "i\0004" " % i^D\r\nincomplete.1  incomplete.2  \r\r\n % i"
d63 2
a64 2
testseq "set ignoreeof\ni\0004" \
	" % set ignoreeof\r\n % i^D\r\nincomplete.1  incomplete.2  \r\r\n % i"
d69 4
a72 1
testseq "i\0033" " % i\0007ncomplete."
@


1.1
log
@Add regression tests for the filec feature in csh.
@
text
@d79 1
@

