head	1.6;
access;
symbols
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@# @;


1.6
date	2002.06.11.02.16.30;	author kjell;	state dead;
branches;
next	1.5;

1.5
date	2002.04.24.18.10.25;	author dhartmei;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.09.11.52.30;	author dhartmei;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.13.07.01.03;	author dhartmei;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.15.21.53.09;	author dhartmei;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.06.18.45.13;	author jasoni;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Use merged config file format. The separate NAT loop can go away,
since all files are now loaded the same way. Add regress tests for
invalid ordering of scrub, nat, filter rules
@
text
@no binat on lo0 inet from 192.168.1.1 to 10.1.2.3 
binat on lo0 inet from 192.168.1.1 to any -> 10.0.0.1
binat on lo0 inet proto tcp from 192.168.1.2 to any -> 10.0.0.2
binat on lo0 inet proto udp from 192.168.1.3 to any -> 10.0.0.3
binat on lo0 inet proto icmp from 192.168.1.4 to any -> 10.0.0.4
binat on lo0 inet from 192.168.1.5 to 172.16.1.1 -> 10.0.0.5
binat on lo0 inet from 192.168.1.6 to 172.16.1.2 -> 10.0.0.6
binat on lo0 inet from 192.168.1.7 to 172.16.2.0/24 -> 10.0.0.7
binat on lo0 inet from 192.168.1.8 to ! 172.17.0.0/16 -> 10.0.0.8
@


1.5
log
@Add dynamic (in-kernel) interface name -> address translation. Instead of
using just the interface name instead of an address and reloading the rule
set whenever the interface changes its address, the interface name can be
put in parentheses, and the kernel will keep track of changes and update
rules. There is no additional cost for evaluating rules (per packet),
the cost occurs when an interface changes address (and the rules are
traversed and updated where necessary).
@
text
@@


1.4
log
@Add tests for 'no' translation rules and 'label' in filter rules.
@
text
@d1 9
a9 9
no binat on lo0 from 192.168.1.1 to 10.1.2.3/32 
binat on lo0 from 192.168.1.1 to any -> 10.0.0.1
binat on lo0 proto tcp from 192.168.1.2 to any -> 10.0.0.2
binat on lo0 proto udp from 192.168.1.3 to any -> 10.0.0.3
binat on lo0 proto icmp from 192.168.1.4 to any -> 10.0.0.4
binat on lo0 from 192.168.1.5 to 172.16.1.1/32 -> 10.0.0.5
binat on lo0 from 192.168.1.6 to 172.16.1.2/32 -> 10.0.0.6
binat on lo0 from 192.168.1.7 to 172.16.2.0/24 -> 10.0.0.7
binat on lo0 from 192.168.1.8 to ! 172.17.0.0/16 -> 10.0.0.8
@


1.3
log
@Use more common interface names like lo0, tun0, enc0 for regress tests,
so they run anywhere. From jason@@.
@
text
@d1 9
a9 8
@@binat on lo0 from 192.168.1.1 to any -> 10.0.0.1
@@binat on lo0 proto tcp from 192.168.1.2 to any -> 10.0.0.2
@@binat on lo0 proto udp from 192.168.1.3 to any -> 10.0.0.3
@@binat on lo0 proto icmp from 192.168.1.4 to any -> 10.0.0.4
@@binat on lo0 from 192.168.1.5 to 172.16.1.1/32 -> 10.0.0.5
@@binat on lo0 from 192.168.1.6 to 172.16.1.2/32 -> 10.0.0.6
@@binat on lo0 from 192.168.1.7 to 172.16.2.0/24 -> 10.0.0.7
@@binat on lo0 from 192.168.1.8 to ! 172.17.0.0/16 -> 10.0.0.8
@


1.2
log
@Update regress tests. Some input syntax has changed (inet/inet6) as well
as some output format (netmasks, inet/inet6, return-icmp).
@
text
@d1 8
a8 8
@@binat on fxp0 from 192.168.1.1 to any -> 10.0.0.1
@@binat on fxp0 proto tcp from 192.168.1.2 to any -> 10.0.0.2
@@binat on fxp0 proto udp from 192.168.1.3 to any -> 10.0.0.3
@@binat on fxp0 proto icmp from 192.168.1.4 to any -> 10.0.0.4
@@binat on fxp0 from 192.168.1.5 to 172.16.1.1/32 -> 10.0.0.5
@@binat on fxp0 from 192.168.1.6 to 172.16.1.2/32 -> 10.0.0.6
@@binat on fxp0 from 192.168.1.7 to 172.16.2.0/24 -> 10.0.0.7
@@binat on fxp0 from 192.168.1.8 to ! 172.17.0.0/16 -> 10.0.0.8
@


1.1
log
@add test for binat
@
text
@d5 4
a8 4
@@binat on fxp0 from 192.168.1.5 to 172.16.1.1 -> 10.0.0.5
@@binat on fxp0 from 192.168.1.6 to 172.16.1.2 -> 10.0.0.6
@@binat on fxp0 from 192.168.1.7 to 172.16.2.0/255.255.255.0 -> 10.0.0.7
@@binat on fxp0 from 192.168.1.8 to ! 172.17.0.0/255.255.0.0 -> 10.0.0.8
@

