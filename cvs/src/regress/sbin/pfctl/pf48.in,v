head	1.8;
access;
symbols
	OPENBSD_6_0:1.8.0.10
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.6
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.3.0.18
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.16
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.14
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2;
locks; strict;
comment	@# @;


1.8
date	2014.06.25.15.14.20;	author mikeb;	state Exp;
branches;
next	1.7;
commitid	vdQ0f9G49C4trITR;

1.7
date	2011.07.08.06.17.58;	author mcbride;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.02.17.25.46;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.06.12.41.48;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.19.12.51.05;	author mpf;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.11.09.12.25;	author cedric;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.22.23.38.36;	author mcbride;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.25.20.46.45;	author cedric;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Explicitely specify address family when translation pool may contain
addresses of different address families.
@
text
@table < regress > { 1.2.3.4 !5.6.7.8 10/8 lo0 }
table <regress.1> const { ::1 fe80::/64 }
table <regress.a> { 1.2.3.4 !5.6.7.8 } { ::1 ::2 ::3 } file "/dev/null" const { 4.3.2.1 }
match out on lo0 inet from < regress.1> to <regress.2> nat-to lo0:0
match out on !lo0 inet from !<regress.1 > to <regress.2> nat-to lo0:0
match in on lo0 inet6 from <regress.1> to <regress.2> rdr-to lo0:0
match in on !lo0 inet6 from !< regress.1 > to <regress.2> rdr-to lo0:0
match in from { <regress.1> !<regress.2> } to any
match out from any to { !<regress.1>, <regress.2> }
pass in from <regress> to any
pass out from any to <regress >
pass in from { <regress.1> <regress.2> } to any
pass out from any to { !<regress.1>, !<regress.2> }
@


1.7
log
@Update regress tests for the following changes:
- if_addr RB_TREE (Address sort differently on an interface)
- skip steps changes
	- RDOMAIN
	- reordering of address/port tests
- fastroute is gone
- keep state is no longer printed by default
- lo0 now has link-local scope address in addition to ::1
@
text
@d4 1
a4 1
match out on lo0 from < regress.1> to <regress.2> nat-to lo0:0
d7 1
a7 1
match in on !lo0 from !< regress.1 > to <regress.2> rdr-to lo0:0
@


1.6
log
@convert a bunch of rdr/nat rules to the new syntax
Things still need to be changed for route-to/binat/command line
options among other things.

ok henning
@
text
@d4 4
a7 4
match out on lo0 from < regress.1> to <regress.2> nat-to lo0
match out on !lo0 from !<regress.1 > to <regress.2> nat-to lo0
match in on lo0 from <regress.1> to <regress.2> rdr-to lo0
match in on !lo0 from !< regress.1 > to <regress.2> rdr-to lo0
@


1.5
log
@scrub gone
@
text
@d4 4
a7 4
nat on lo0 from < regress.1> to <regress.2> -> lo0
nat on !lo0 from !<regress.1 > to <regress.2> -> lo0
rdr on lo0 from <regress.1> to <regress.2> -> lo0
rdr on !lo0 from !< regress.1 > to <regress.2> -> lo0
@


1.4
log
@Remove "localhost" from the table test, since the result is dependent
on the resolver.  In some enviroments you'll get an AAAA for it,
in others you won't. Testing the resolver isn't really the intention
of this test anyway.
OK henning
@
text
@a3 2
scrub in from { <regress.1> !<regress.2> } to any
scrub out from any to { !<regress.1>, <regress.2> }
d8 2
@


1.3
log
@More complete table definition.
@
text
@d2 1
a2 1
table <regress.1> const { ::1 fe80::/64 localhost }
@


1.2
log
@pfctl allows a space between the < >'s and the table name.
@
text
@d3 1
@


1.1
log
@Regression tests for table statements and rules containing tables.
ok henning@@
@
text
@d1 1
a1 1
table <regress> { 1.2.3.4 !5.6.7.8 10/8 lo0 }
d5 2
a6 2
nat on lo0 from <regress.1> to <regress.2> -> lo0
nat on !lo0 from !<regress.1> to <regress.2> -> lo0
d8 1
a8 1
rdr on !lo0 from !<regress.1> to <regress.2> -> lo0
d10 1
a10 1
pass out from any to <regress>
@

