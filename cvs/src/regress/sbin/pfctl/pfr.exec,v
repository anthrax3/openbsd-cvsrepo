head	1.17;
access;
symbols
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.17.0.26
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.22
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.12
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.20
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.18
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.16
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.14
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.10
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.15.0.10
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.8
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.4
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.10
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9;
locks; strict;
comment	@# @;


1.17
date	2011.07.24.02.22.52;	author mcbride;	state Exp;
branches;
next	1.16;

1.16
date	2011.07.24.01.22.11;	author mcbride;	state Exp;
branches;
next	1.15;

1.15
date	2008.10.19.16.16.03;	author mpf;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.19.12.51.49;	author mpf;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.28.19.09.27;	author mpf;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.27.21.34.03;	author mpf;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.21.23.10.49;	author dhartmei;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.08.10.39.02;	author cedric;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.07.15.32.07;	author cedric;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.25.09.06.32;	author cedric;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.19.13.54.33;	author cedric;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.14.17.33.54;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.24.23.44.41;	author cedric;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.17.17.59.23;	author cedric;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.15.17.08.16;	author cedric;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.15.10.11.54;	author cedric;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.14.14.43.31;	author cedric;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Handle 'show' specially to prepare for regress tests on pfrke_route
and pfrke_cost entries. Output becomes sorted in table order.
@
text
@#!/bin/ksh
D=`dirname $1`
A='regress'
pfctl -a $A -FT 2>/dev/null
pfctl -a $A -Fr 2>/dev/null
KT_R=`vmstat -mv | awk '/pfrktable/{print $3}'`
KT_I=`vmstat -mv | awk '/pfrktable/{print $5}'`
KEP_R=`vmstat -mv | awk '/pfrke_plain /{print $3}'`
KEP_I=`vmstat -mv | awk '/pfrke_plain /{print $5}'`
KER_R=`vmstat -mv | awk '/pfrke_route /{print $3}'`
KER_I=`vmstat -mv | awk '/pfrke_route /{print $5}'`
KEC_R=`vmstat -mv | awk '/pfrke_cost /{print $3}'`
KEC_I=`vmstat -mv | awk '/pfrke_cost /{print $5}'`
echo "# create"
echo "table <regress> persist" | pfctl -a $A -f - 2>&1 || exit 1
for LINE in `sed -e "s/ /_/g" $1`; do 
	RESULT=`echo $LINE | awk '{split($1,a,"_");print a[1]}'`
	case $RESULT in
		pass|fail) ;;
		*) continue ;;
	esac
	CMD=`echo $LINE | awk '{split($1,a,"_");print a[2]}'` 
	ARGSX=`echo $LINE | awk '{split($1,a,"_");for(i=3;a[i];i++)print a[i]}'`
	ARGS=""
	for ARG in $ARGSX; do
		if [ "X$ARGS" = "X" ]; then
			ARGS="$ARG"
		else
			ARGS="$ARGS $ARG"
		fi
	done
	if [ "$RESULT" = "pass" ]; then case $CMD in
	add|delete|replace)
		echo "# pass $CMD -n $ARGS"
		pfctl -a $A -t regress -nT $CMD $ARGS 2>&1 | sort || exit 1
		echo "# pass $CMD -nf-"
		echo "# test\n" $ARGSX | pfctl -a $A -t regress -nT $CMD -f- \
			2>&1 | sort || exit 1
		echo "# pass $CMD -nqv $ARGS"
		pfctl -a $A -t regress -nqvT $CMD $ARGS 2>&1 | sort || exit 1
		echo "# pass $CMD -nqvv $ARGS"
		pfctl -a $A -t regress -nqvvT $CMD $ARGS 2>&1 | sort || exit 1
		;;
	esac fi
	echo "# $RESULT $CMD $ARGS"
	if [ "$RESULT" = "pass" ]; then
		case $CMD in
		list)
			pfctl -a $A -sT 2>&1
			echo "# pass $CMD -v"
			pfctl -a $A -gvsT 2>&1
			;;
		load)
			echo $ARGS | sed "s,DIR,$D,g" | pfctl -a $A -f- \
			    || exit 1
			;;
		rule)
			echo $ARGS | pfctl -a $A -f- 2>&1 || exit 1
			;;
		show)
			pfctl -qvv -a $A -t regress -T $CMD $ARGS 2>&1 | \
			    grep -v "Cleared:"
			;;
		*)
			pfctl -a $A -t regress -T $CMD $ARGS 2>&1 | sort \
			    || exit 1
			;;
		esac
	else
		case $CMD in
		load)
			echo ARGS | sed "s,DIR,$D,g" | pfctl -a $A -Tl -f- \
			    && exit 1
			;;
		rule)
			echo $ARGS | pfctl -a $A -f- 2>&1 && exit 1
			;;
		*)
			pfctl -a $A -t regress -T $CMD $ARGS 2>&1 && exit 1
			;;
		esac
	fi
done
echo "# kill"
pfctl -a $A -FT 2>&1
pfctl -a $A -Fr 2>&1
let KT_R=`vmstat -mv | awk '/pfrktable/{print $3}'`-$KT_R
let KT_I=`vmstat -mv | awk '/pfrktable/{print $5}'`-$KT_I
let KT_RL=$KT_R-$KT_I
let KEP_R=`vmstat -mv | awk '/pfrke_plain /{print $3}'`-$KEP_R
let KEP_I=`vmstat -mv | awk '/pfrke_plain /{print $5}'`-$KEP_I
let KEP_RL=$KEP_R-$KEP_I
let KER_R=`vmstat -mv | awk '/pfrke_route /{print $3}'`-$KER_R
let KER_I=`vmstat -mv | awk '/pfrke_route /{print $5}'`-$KER_I
let KER_RL=$KER_R-$KER_I
let KEC_R=`vmstat -mv | awk '/pfrke_cost /{print $3}'`-$KEC_R
let KEC_I=`vmstat -mv | awk '/pfrke_cost /{print $5}'`-$KEC_I
let KEC_RL=$KEC_R-$KEC_I
echo "ktable: $KT_R allocated, $KT_RL released, $KT_I leaked."
echo "pfrke_plain: $KEP_R allocated, $KEP_RL released, $KEP_I leaked."
echo "pfrke_route: $KER_R allocated, $KER_RL released, $KER_I leaked."
echo "pfrke_cost: $KEC_R allocated, $KEC_RL released, $KEC_I leaked."
[ "$KT_I" = "0" -a "$KEP_I" = "0"  -a "$KER_I" = "0" -a "$KEC_I" = "0" ] || exit 1
@


1.16
log
@Update PF table regress tests to work with -current.
@
text
@d60 4
@


1.15
log
@vmstat(8) now reports "InUse" instead of "Releases".
Adopt for ktable/kentry usage/leakage tests.
Also run vmstat verbose, to avoid matching failures
if the pools haven't been used yet.
@
text
@a5 1
pfctl -a $A -Fn 2>/dev/null
d8 6
a13 2
KE_R=`vmstat -mv | awk '/pfrkentry /{print $3}'`
KE_I=`vmstat -mv | awk '/pfrkentry /{print $5}'`
d15 1
a15 1
echo "table <regress> persist" | pfctl -a $A -Tl -f - 2>&1 || exit 1
d54 1
a54 1
			echo $ARGS | sed "s,DIR,$D,g" | pfctl -a $A -Tl -f- \
a82 1
pfctl -a $A -Fn 2>&1
d86 9
a94 3
let KE_R=`vmstat -mv | awk '/pfrkentry /{print $3}'`-$KE_R
let KE_I=`vmstat -mv | awk '/pfrkentry /{print $5}'`-$KE_I
let KE_RL=$KE_R-$KE_I
d96 4
a99 2
echo "kentry: $KE_R allocated, $KE_RL released, $KE_I leaked."
[ "$KT_I" = "0" -a "$KE_I" = "0" ] || exit 1
@


1.14
log
@This got broken when a second pool (pfrkentry2) was added
for source-tracking support about 3 years ago.
OK henning
@
text
@d7 4
a10 4
KT_A=`vmstat -m | awk '/pfrktable/{print $3}'`
KT_R=`vmstat -m | awk '/pfrktable/{print $5}'`
KE_A=`vmstat -m | awk '/pfrkentry /{print $3}'`
KE_R=`vmstat -m | awk '/pfrkentry /{print $5}'`
d81 9
a89 9
let KT_A=`vmstat -m | awk '/pfrktable/{print $3}'`-$KT_A
let KT_R=`vmstat -m | awk '/pfrktable/{print $5}'`-$KT_R
let KT_L=$KT_A-$KT_R
let KE_A=`vmstat -m | awk '/pfrkentry /{print $3}'`-$KE_A
let KE_R=`vmstat -m | awk '/pfrkentry /{print $5}'`-$KE_R
let KE_L=$KE_A-$KE_R
echo "ktable: $KT_A allocated, $KT_R released, $KT_L leaked."
echo "kentry: $KE_A allocated, $KE_R released, $KE_L leaked."
[ "$KT_L" = "0" -a "$KE_L" = "0" ] || exit 1
@


1.13
log
@fix pf table tests with a less confusing anchor name.
pointed out by cedric.
ok dhartmei@@
@
text
@d9 2
a10 2
KE_A=`vmstat -m | awk '/pfrkentry/{print $3}'`
KE_R=`vmstat -m | awk '/pfrkentry/{print $5}'`
d84 2
a85 2
let KE_A=`vmstat -m | awk '/pfrkentry/{print $3}'`-$KE_A
let KE_R=`vmstat -m | awk '/pfrkentry/{print $5}'`-$KE_R
@


1.12
log
@sync pf table test with new ksh behaviour.
ok henning@@
@
text
@d3 1
a3 1
A='regress:regress'
@


1.11
log
@Use '/' instead of ':' as separator for anchor path components. Note that
the parser now needs quotes around paths containing separators.
ok mcbride@@
@
text
@d3 1
a3 1
A='regress'
d7 4
a10 4
KT_A=0`vmstat -m | awk '/pfrktable/{print $3}'`
KT_R=0`vmstat -m | awk '/pfrktable/{print $5}'`
KE_A=0`vmstat -m | awk '/pfrkentry/{print $3}'`
KE_R=0`vmstat -m | awk '/pfrkentry/{print $5}'`
@


1.10
log
@Sync with recent anchor changes.
Execute all table regress tests inside 'regress:regress' ruleset.
@
text
@d3 1
a3 1
A='regress:regress'
@


1.9
log
@Needs -g flag now.
@
text
@d3 4
a6 5
for TABLE in `pfctl -sT | grep regress`; do 
	pfctl -t $TABLE -qTk 2>&1 || exit 1
done
pfctl -Fr -a regress:regress 2>/dev/null
pfctl -Fn -a regress:regress 2>/dev/null
d12 1
a12 1
echo "table <regress> persist" | pfctl -Tl -f - 2>&1 || exit 1
d32 1
a32 1
		pfctl -t regress -nT $CMD $ARGS 2>&1 | sort || exit 1
d34 1
a34 1
		echo "# test\n" $ARGSX | pfctl -t regress -nT $CMD -f- \
d37 1
a37 1
		pfctl -t regress -nqvT $CMD $ARGS 2>&1 | sort || exit 1
d39 1
a39 1
		pfctl -t regress -nqvvT $CMD $ARGS 2>&1 | sort || exit 1
d46 1
a46 1
			(pfctl -sT | grep regress) 2>&1
d48 1
a48 1
			(pfctl -gvsT | grep regress) 2>&1
d51 2
a52 1
			echo $ARGS | sed "s,DIR,$D,g" | pfctl -Tl -f- || exit 1
d55 1
a55 1
			echo $ARGS | pfctl -a regress:regress -f- 2>&1 || exit 1
d58 2
a59 1
			pfctl -t regress -T $CMD $ARGS 2>&1 | sort || exit 1
d65 2
a66 1
			echo ARGS | sed "s,DIR,$D,g" | pfctl -Tl -f- && exit 1
d69 2
a70 1
			echo $ARGS | pfctl -a regress:regress -f- 2>&1 && exit 1			;;
d72 1
a72 1
			pfctl -t regress -T $CMD $ARGS 2>&1 && exit 1
d78 3
a80 5
for TABLE in `pfctl -sT | grep regress`; do
        pfctl -t $TABLE -Tk 2>&1 || exit 1
done
pfctl -Fr -a regress:regress 2>/dev/null
pfctl -Fn -a regress:regress 2>/dev/null
@


1.8
log
@Add regress tests for the 'table <foo> file "filename"' syntax.
Syntax checks only in pfsimple2, real tests in pfr13.
@
text
@d49 1
a49 1
			(pfctl -vsT | grep regress) 2>&1
@


1.7
log
@Regression tests are not supposed to flush the user's PF ruleset...
@
text
@d2 1
d52 1
a52 1
			echo $ARGS | pfctl -Tl -f- || exit 1
d64 1
a64 1
			echo $ARGS | pfctl -Tl -f- && exit 1
@


1.6
log
@adjust after pfctl changes
@
text
@d12 1
a12 1
echo "table <regress> persist" | pfctl -f - 2>&1 || exit 1
@


1.5
log
@Make table tests less sensitive to environmental conditions.
Work started with revision 1.4
ok dhartmei@@
@
text
@d12 1
a12 1
pfctl -t regress -Tc 2>&1 || exit 1
@


1.4
log
@Make table tests less sensitive to environmental conditions.
ok dhartmei@@
@
text
@d32 1
a32 1
		pfctl -t regress -nT $CMD $ARGS 2>&1 || exit 1
d35 1
a35 1
			2>&1 || exit 1
d37 1
a37 1
		pfctl -t regress -nqvT $CMD $ARGS 2>&1 || exit 1
d39 1
a39 1
		pfctl -t regress -nqvvT $CMD $ARGS 2>&1 || exit 1
@


1.3
log
@Bunch of new regression tests. The only missing thing now is tests
for the <table> syntax in rules.
@
text
@d57 1
a57 1
			pfctl -t regress -T $CMD $ARGS 2>&1 || exit 1
@


1.2
log
@Add memory allocation checks + leak detection in regress tests.
@
text
@d2 5
a10 1
pfctl -t regress -qTk 2>&1 || exit 1
d22 7
a28 1
	for ARG in $ARGSX; do ARGS="$ARGS $ARG"; done
d30 2
a31 2
	a*|d*|r*)
		echo "# $CMD -n $ARGS"
d33 1
a33 1
		echo "# $CMD -nf-"
d36 1
a36 1
		echo "# $CMD -nqv"
d38 1
a38 1
		echo "# $CMD -nqvv"
d42 1
d44 16
a59 2
		echo "# $CMD"
		pfctl -t regress -T $CMD $ARGS 2>&1 || exit 1
d61 10
a70 2
		echo "# $CMD"
		pfctl -t regress -T $CMD $ARGS 2>&1 && exit 1
a72 4
echo "# table"
pfctl -sT | grep regress 2>&1 || exit 1
echo "# table -v"
pfctl -vsT | grep regress 2>&1 || exit 1
d74 5
a78 1
pfctl -t regress -Tk 2>&1 || exit 1
a87 1

@


1.1
log
@Add regression tests for radix table address manipulations.
ok dhartmei@@
@
text
@d2 4
d46 10
@

