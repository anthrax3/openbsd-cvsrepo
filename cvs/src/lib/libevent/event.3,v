head	1.53;
access;
symbols
	OPENBSD_6_2_BASE:1.53
	OPENBSD_6_1:1.52.0.6
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.52.0.2
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.43.0.4
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.41.0.18
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.14
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.12
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.10
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.8
	OPENBSD_5_0:1.41.0.6
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.4
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.2
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.39.0.6
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.39.0.8
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.4
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.39.0.2
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.36.0.4
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	EVENT00:1.1.1.1
	PROVOS00:1.1.1;
locks; strict;
comment	@.\" @;


1.53
date	2017.06.29.01.25.59;	author dlg;	state Exp;
branches;
next	1.52;
commitid	2u8SfYihKYscImpj;

1.52
date	2016.07.17.11.21.07;	author stefan;	state Exp;
branches;
next	1.51;
commitid	WGbisUjnleuYvAOs;

1.51
date	2015.11.10.23.48.18;	author jmc;	state Exp;
branches;
next	1.50;
commitid	QU70QaxjyBAtj4Rv;

1.50
date	2015.04.14.22.16.03;	author nicm;	state Exp;
branches;
next	1.49;
commitid	S5epGQ6j3xpRgW4I;

1.49
date	2015.04.14.21.34.45;	author nicm;	state Exp;
branches;
next	1.48;
commitid	ZsR7zGwiaPRyim4T;

1.48
date	2015.04.14.21.25.54;	author nicm;	state Exp;
branches;
next	1.47;
commitid	CSPGE92mh1acRzHj;

1.47
date	2014.11.20.00.02.44;	author dlg;	state Exp;
branches;
next	1.46;
commitid	HO2c4fPu9QV4lvLU;

1.46
date	2014.11.19.23.55.54;	author dlg;	state Exp;
branches;
next	1.45;
commitid	6rHEwHxhbF8PBCcE;

1.45
date	2014.11.19.23.50.22;	author dlg;	state Exp;
branches;
next	1.44;
commitid	mjJTYMAWSPLUM2xZ;

1.44
date	2014.11.19.20.29.03;	author jmc;	state Exp;
branches;
next	1.43;
commitid	Ck3pCtzdPn9h4s9m;

1.43
date	2014.04.03.13.30.05;	author jmc;	state Exp;
branches;
next	1.42;

1.42
date	2014.04.03.11.27.02;	author eric;	state Exp;
branches;
next	1.41;

1.41
date	2010.04.22.16.35.45;	author jmc;	state Exp;
branches;
next	1.40;

1.40
date	2010.04.21.20.02.40;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2008.05.02.18.26.42;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2008.05.02.09.18.26;	author jmc;	state Exp;
branches;
next	1.37;

1.37
date	2008.05.02.06.09.11;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.31.19.19.35;	author jmc;	state Exp;
branches;
next	1.35;

1.35
date	2007.03.26.18.43.32;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.03.21.13.52.01;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2007.03.21.13.41.21;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.21.12.22.30;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2007.03.19.20.32.41;	author jmc;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.19.19.31.13;	author jmc;	state Exp;
branches;
next	1.29;

1.29
date	2007.03.19.15.12.49;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2006.11.26.15.22.58;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2006.10.21.12.04.18;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.23.10.51.27;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.18.20.23.42;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2006.01.25.05.25.34;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.23.20.18.20;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.21.19.15.09;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2005.06.18.01.52.22;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.04.03.17.48;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.22.08.32.17;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.22.01.10.34;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.22.01.01.17;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.19.08.07.45;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.19.02.03.12;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.13.16.15.09;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.02.09.59.17;	author jolan;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.28.07.35.07;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.28.06.53.12;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.23.08.52.04;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.09.10.54.38;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.03.01.27.31;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.23.12.41.13;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.10.03.21.48;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.30.18.38.05;	author jsyn;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.12.18.50.48;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.05.20.04.39;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.25.15.39.38;	author mpech;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.15.18.01.37;	author provos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.15.18.01.37;	author provos;	state Exp;
branches;
next	;


desc
@@


1.53
log
@take const off the timeval argument in the pending functions.

event_pending, evtimer_pending, and signal_pending all write to the
timeval because that's how they tell the caller when the event is
meant to fire.

ok deraadt@@ millert@@ jmc@@ schwarze@@
@
text
@.\"	$OpenBSD: event.3,v 1.52 2016/07/17 11:21:07 stefan Exp $
.\"
.\" Copyright (c) 2000 Artur Grabowski <art@@openbsd.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. The name of the author may not be used to endorse or promote products
.\"    derived from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
.\" INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
.\" AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
.\" THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
.\" EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
.\" PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
.\" OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
.\" WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
.\" OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
.\" ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd $Mdocdate: July 17 2016 $
.Dt EVENT_INIT 3
.Os
.Sh NAME
.Nm event_init ,
.Nm event_dispatch ,
.Nm event_set ,
.Nm event_add ,
.Nm event_del ,
.Nm event_pending ,
.Nm event_initialized ,
.Nm evtimer_set ,
.Nm evtimer_add ,
.Nm evtimer_del ,
.Nm evtimer_pending ,
.Nm evtimer_initialized ,
.Nm signal_set ,
.Nm signal_add ,
.Nm signal_del ,
.Nm signal_pending ,
.Nm signal_initialized ,
.Nm event_once ,
.Nm event_loop ,
.Nm event_loopexit ,
.Nm event_loopbreak ,
.Nm event_asr_run ,
.Nm event_asr_abort ,
.Nm event_priority_init ,
.Nm event_priority_set ,
.Nm event_base_dispatch ,
.Nm event_base_loop ,
.Nm event_base_loopexit ,
.Nm event_base_loopbreak ,
.Nm event_base_set ,
.Nm event_base_once ,
.Nm event_base_free ,
.Nm bufferevent_base_set ,
.Nm bufferevent_new ,
.Nm bufferevent_free ,
.Nm bufferevent_write ,
.Nm bufferevent_write_buffer ,
.Nm bufferevent_read ,
.Nm bufferevent_enable ,
.Nm bufferevent_disable ,
.Nm bufferevent_settimeout
.Nd execute a function when a specific event occurs
.Sh SYNOPSIS
.In sys/time.h
.In event.h
.Ft "struct event_base *"
.Fn "event_init" "void"
.Ft int
.Fn "event_dispatch" "void"
.Ft void
.Fn "event_set" "struct event *ev" "int fd" "short event" "void (*fn)(int, short, void *)" "void *arg"
.Ft int
.Fn "event_add" "struct event *ev" "const struct timeval *tv"
.Ft int
.Fn "event_del" "struct event *ev"
.Ft int
.Fn "event_pending" "struct event *ev" "short event" "struct timeval *tv"
.Ft int
.Fn "event_initialized" "struct event *ev"
.Ft void
.Fn "evtimer_set" "struct event *ev" "void (*fn)(int, short, void *)" "void *arg"
.Ft void
.Fn "evtimer_add" "struct event *ev" "const struct timeval *tv"
.Ft void
.Fn "evtimer_del" "struct event *ev"
.Ft int
.Fn "evtimer_pending" "struct event *ev" "struct timeval *tv"
.Ft int
.Fn "evtimer_initialized" "struct event *ev"
.Ft void
.Fn "signal_set" "struct event *ev" "int signal" "void (*fn)(int, short, void *)" "void *arg"
.Ft void
.Fn "signal_add" "struct event *ev" "const struct timeval *tv"
.Ft void
.Fn "signal_del" "struct event *ev"
.Ft int
.Fn "signal_pending" "struct event *ev" "struct timeval *tv"
.Ft int
.Fn "signal_initialized" "struct event *ev"
.Ft int
.Fn "event_once" "int fd" "short event" "void (*fn)(int, short, void *)" "void *arg" "const struct timeval *tv"
.Ft int
.Fn "event_loop" "int flags"
.Ft int
.Fn "event_loopexit" "const struct timeval *tv"
.Ft int
.Fn "event_loopbreak" "void"
.Ft "struct event_asr *"
.Fn event_asr_run "struct asr_query *aq" "void (*fn)(struct asr_result *, void *)" "void *arg"
.Ft "void"
.Fn event_asr_abort "struct event_asr *eva"
.Ft int
.Fn "event_priority_init" "int npriorities"
.Ft int
.Fn "event_priority_set" "struct event *ev" "int priority"
.Ft int
.Fn "event_base_dispatch" "struct event_base *base"
.Ft int
.Fn "event_base_loop" "struct event_base *base" "int flags"
.Ft int
.Fn "event_base_loopexit" "struct event_base *base" "const struct timeval *tv"
.Ft int
.Fn "event_base_loopbreak" "struct event_base *base"
.Ft int
.Fn "event_base_set" "struct event_base *base" "struct event *ev"
.Ft int
.Fn "event_base_once" "struct event_base *base" "int fd" "short event" "void (*fn)(int, short, void *)" "void *arg" "const struct timeval *tv"
.Ft void
.Fn "event_base_free" "struct event_base *base"
.Ft int
.Fn "bufferevent_base_set" "struct event_base *base" "struct bufferevent *bufev"
.Ft "struct bufferevent *"
.Fn "bufferevent_new" "int fd" "evbuffercb readcb" "evbuffercb writecb" "everrorcb errorcb" "void *cbarg"
.Ft void
.Fn "bufferevent_free" "struct bufferevent *bufev"
.Ft int
.Fn "bufferevent_write" "struct bufferevent *bufev" "const void *data" "size_t size"
.Ft int
.Fn "bufferevent_write_buffer" "struct bufferevent *bufev" "struct evbuffer *buf"
.Ft size_t
.Fn "bufferevent_read" "struct bufferevent *bufev" "void *data" "size_t size"
.Ft int
.Fn "bufferevent_enable" "struct bufferevent *bufev" "short event"
.Ft int
.Fn "bufferevent_disable" "struct bufferevent *bufev" "short event"
.Ft void
.Fn "bufferevent_settimeout" "struct bufferevent *bufev" "int timeout_read" "int timeout_write"
.Sh DESCRIPTION
The
.Nm event
API provides a mechanism to execute a function when a specific event
on a file descriptor occurs or after a given time has passed.
.Pp
The
.Nm event
API needs to be initialized with
.Fn event_init
before it can be used.
.Pp
In order to process events, an application needs to call
.Fn event_dispatch .
This function only returns on error, and should replace the event core
of the application program.
.Pp
The function
.Fn event_set
prepares the event structure
.Fa ev
to be used in future calls to
.Fn event_add
and
.Fn event_del .
The event will be prepared to call the function specified by the
.Fa fn
argument with an
.Fa int
argument indicating the file descriptor, a
.Fa short
argument indicating the type of event, and a
.Fa void *
argument given in the
.Fa arg
argument.
The
.Fa fd
indicates the file descriptor that should be monitored for events.
The events can be either
.Va EV_READ ,
.Va EV_WRITE ,
or both,
indicating that an application can read or write from the file descriptor
respectively without blocking.
.Pp
The function
.Fa fn
will be called with the file descriptor that triggered the event and
the type of event which will be either
.Va EV_TIMEOUT ,
.Va EV_SIGNAL ,
.Va EV_READ ,
or
.Va EV_WRITE .
Additionally, an event which has registered interest in more than one of the
preceding events, via bitwise-OR to
.Fn event_set ,
can provide its callback function with a bitwise-OR of more than one triggered
event.
The additional flag
.Va EV_PERSIST
makes an
.Fn event_add
persistent until
.Fn event_del
has been called.
.Pp
Once initialized, the
.Fa ev
structure can be used repeatedly with
.Fn event_add
and
.Fn event_del
and does not need to be reinitialized unless the function called and/or
the argument to it are to be changed.
However, when an
.Fa ev
structure has been added to libevent using
.Fn event_add
the structure must persist until the event occurs (assuming
.Fa EV_PERSIST
is not set) or is removed
using
.Fn event_del .
You may not reuse the same
.Fa ev
structure for multiple monitored descriptors; each descriptor
needs its own
.Fa ev .
.Pp
The function
.Fn event_add
schedules the execution of the
.Fa ev
event when the event specified in
.Fn event_set
occurs or in at least the time specified in the
.Fa tv .
If
.Fa tv
is
.Dv NULL ,
no timeout occurs and the function will only be called
if a matching event occurs on the file descriptor.
The event in the
.Fa ev
argument must be already initialized by
.Fn event_set
and may not be used in calls to
.Fn event_set
until it has timed out or been removed with
.Fn event_del .
If the event in the
.Fa ev
argument already has a scheduled timeout, the old timeout will be
replaced by the new one.
.Pp
The function
.Fn event_del
will cancel the event in the argument
.Fa ev .
If the event has already executed or has never been added
the call will have no effect.
.Pp
The functions
.Fn evtimer_set ,
.Fn evtimer_add ,
.Fn evtimer_del ,
.Fn evtimer_initialized ,
and
.Fn evtimer_pending
are abbreviations for common situations where only a timeout is required.
The file descriptor passed will be \-1, and the event type will be
.Va EV_TIMEOUT .
.Pp
The functions
.Fn signal_set ,
.Fn signal_add ,
.Fn signal_del ,
.Fn signal_initialized ,
and
.Fn signal_pending
are abbreviations.
The event type will be a persistent
.Va EV_SIGNAL .
That means
.Fn signal_set
adds
.Va EV_PERSIST .
.Pp
The function
.Fn event_once
is similar to
.Fn event_set .
However, it schedules a callback to be called exactly once and does not
require the caller to prepare an
.Fa event
structure.
This function supports
.Fa EV_TIMEOUT ,
.Fa EV_READ ,
and
.Fa EV_WRITE .
.Pp
The
.Fn event_pending
function can be used to check if the event specified by
.Fa event
is pending to run.
If
.Va EV_TIMEOUT
was specified and
.Fa tv
is not
.Dv NULL ,
the expiration time of the event will be returned in
.Fa tv .
.Pp
The
.Fn event_initialized
macro can be used to check if an event has been initialized.
.Pp
The
.Nm event_loop
function provides an interface for single pass execution of pending
events.
The flags
.Va EVLOOP_ONCE
and
.Va EVLOOP_NONBLOCK
are recognized.
The
.Nm event_loopexit
function exits from the event loop.
The next
.Fn event_loop
iteration after the
given timer expires will complete normally (handling all queued events) then
exit without blocking for events again.
Subsequent invocations of
.Fn event_loop
will proceed normally.
The
.Nm event_loopbreak
function exits from the event loop immediately.
.Fn event_loop
will abort after the next event is completed;
.Fn event_loopbreak
is typically invoked from this event's callback.
This behavior is analogous to the "break;" statement.
Subsequent invocations of
.Fn event_loop
will proceed normally.
.Pp
It is the responsibility of the caller to provide these functions with
pre-allocated event structures.
.Pp
The
.Fn event_asr_run
function is used to schedule the asynchronous resolver query
.Ar aq
to run within a libevent event loop, and call the
.Ar fn
callback when the result is available.
The extra
.Ar arg
parameter is passed to the callback.
The user does not need to set up an event structure for using this function.
It returns an opaque handle representing the running query.
This handle becomes invalid before the callback is run.
It can be cancelled by calling the
.Fn event_asr_abort
function.
See
.Xr asr_run 3
for details on constructing asynchronous resolver queries.
.Sh EVENT PRIORITIES
By default
.Nm libevent
schedules all active events with the same priority.
However, sometimes it is desirable to process some events with a higher
priority than others.
For that reason,
.Nm libevent
supports strict priority queues.
Active events with a lower priority are always processed before events
with a higher priority.
.Pp
The number of different priorities can be set initially with the
.Fn event_priority_init
function.
This function should be called before the first call to
.Fn event_dispatch .
The
.Fn event_priority_set
function can be used to assign a priority to an event.
By default,
.Nm libevent
assigns the middle priority to all events unless their priority
is explicitly set.
.Sh THREAD SAFE EVENTS
The
.Nm event
API has experimental support for thread-safe events.
When initializing the library via
.Fn event_init ,
an event base is returned.
This event base can be used in conjunction with calls to
.Fn event_base_set ,
.Fn event_base_dispatch ,
.Fn event_base_loop ,
.Fn event_base_loopexit ,
.Fn bufferevent_base_set
and
.Fn event_base_free .
.Fn event_base_set
should be called after preparing an event with
.Fn event_set ,
as
.Fn event_set
assigns the provided event to the most recently created event base.
.Fn bufferevent_base_set
should be called after preparing a bufferevent with
.Fn bufferevent_new .
.Fn event_base_free
should be used to free memory associated with the event base
when it is no longer needed.
.Sh BUFFERED EVENTS
The
.Nm event
API provides an abstraction on top of the regular event callbacks.
This abstraction is called a
.Va "buffered event" .
A buffered event provides input and output buffers that get filled
and drained automatically.
The user of a buffered event no longer deals directly with the IO,
but instead is reading from input and writing to output buffers.
.Pp
A new bufferevent is created by
.Fn bufferevent_new .
The parameter
.Fa fd
specifies the file descriptor from which data is read and written to.
This file descriptor is not allowed to be a
.Xr pipe 2 .
The next three parameters are callbacks.
The read and write callback have the following form:
.Ft void
.Fn "(*cb)" "struct bufferevent *bufev" "void *arg" .
The error callback has the following form:
.Ft void
.Fn "(*cb)" "struct bufferevent *bufev" "short what" "void *arg" .
The argument is specified by the fourth parameter
.Fa "cbarg" .
A
.Fa bufferevent struct
pointer is returned on success, NULL on error.
Both the read and the write callback may be NULL.
The error callback has to be always provided.
.Pp
Once initialized, the bufferevent structure can be used repeatedly with
.Fn bufferevent_enable
and
.Fn bufferevent_disable .
The flags parameter can be a combination of
.Va EV_READ
and
.Va EV_WRITE .
When read enabled the bufferevent will try to read from the file
descriptor and call the read callback.
The write callback is executed
whenever the output buffer is drained below the write low watermark,
which is
.Va 0
by default.
.Pp
The
.Fn bufferevent_write
function can be used to write data to the file descriptor.
The data is appended to the output buffer and written to the descriptor
automatically as it becomes available for writing.
.Fn bufferevent_write
returns 0 on success or \-1 on failure.
The
.Fn bufferevent_read
function is used to read data from the input buffer,
returning the amount of data read.
.Pp
If multiple bases are in use,
.Fn bufferevent_base_set
must be called before
enabling the bufferevent for the first time.
.Sh ADDITIONAL NOTES
It is possible to disable support for
.Va kqueue , poll
or
.Va select
by setting the environment variable
.Va EVENT_NOKQUEUE , EVENT_NOPOLL
or
.Va EVENT_NOSELECT ,
respectively.
By setting the environment variable
.Va EVENT_SHOW_METHOD ,
.Nm libevent
displays the kernel notification method that it uses.
.Sh RETURN VALUES
Upon successful completion
.Fn event_add
and
.Fn event_del
return 0.
Otherwise, \-1 is returned and the global variable errno is
set to indicate the error.
.Sh SEE ALSO
.Xr kqueue 2 ,
.Xr poll 2 ,
.Xr select 2 ,
.Xr asr_run 3 ,
.Xr evbuffer_new 3 ,
.Xr timeout 9
.Sh HISTORY
The
.Nm event
API manpage is based on the
.Xr timeout 9
manpage by Artur Grabowski.
Support for real-time signals was added by Taral.
.Sh AUTHORS
The
.Nm event
library was written by
.An Niels Provos .
@


1.52
log
@Talk about event API instead of libevent

Avoids inconsistent capitalization of libevent at start of sentence
suggested by and ok jmc@@, ok bluhm@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.51 2015/11/10 23:48:18 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: November 10 2015 $
d86 1
a86 1
.Fn "event_pending" "struct event *ev" "short event" "const struct timeval *tv"
d96 1
a96 1
.Fn "evtimer_pending" "struct event *ev" "const struct timeval *tv"
d106 1
a106 1
.Fn "signal_pending" "struct event *ev" "const struct timeval *tv"
@


1.51
log
@update NAME section to include all documented functions,
or otherwise change Dt to reflect the name of an existing function;

feedback/ok schwarze
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.50 2015/04/14 22:16:03 nicm Exp $
d26 1
a26 1
.Dd $Mdocdate: April 14 2015 $
d419 3
a421 2
.Nm Libevent
has experimental support for thread-safe events.
d446 3
a448 2
.Nm libevent
provides an abstraction on top of the regular event callbacks.
@


1.50
log
@Another couple of commas in the wrong place, ok jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.49 2015/04/14 21:34:45 nicm Exp $
d27 1
a27 1
.Dt EVENT 3
@


1.49
log
@Remove an extra comma pointed out by jmc@@.
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.48 2015/04/14 21:25:54 nicm Exp $
d52 1
a52 1
.Nm event_asr_abort,
@


1.48
log
@Reorder prototypes to better match manpage layout and add some missing
argument names, from Fabian Raetz. ok deraadt
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.47 2014/11/20 00:02:44 dlg Exp $
d26 1
a26 1
.Dd $Mdocdate: November 20 2014 $
d70 1
a70 1
.Nm bufferevent_settimeout ,
@


1.47
log
@might help to Xr evbuffer_new 3
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.46 2014/11/19 23:55:54 dlg Exp $
d26 1
a26 1
.Dd $Mdocdate: November 19 2014 $
a31 3
.Nm event_loop ,
.Nm event_loopexit ,
.Nm event_loopbreak ,
a32 6
.Nm event_base_dispatch ,
.Nm event_base_loop ,
.Nm event_base_loopexit ,
.Nm event_base_loopbreak ,
.Nm event_base_set ,
.Nm event_base_free ,
a34 2
.Nm event_once ,
.Nm event_base_once ,
a36 2
.Nm event_priority_init ,
.Nm event_priority_set ,
d47 16
a70 3
.Nm bufferevent_base_set ,
.Nm event_asr_run ,
.Nm event_asr_abort
a78 6
.Ft int
.Fn "event_loop" "int flags"
.Ft int
.Fn "event_loopexit" "struct timeval *tv"
.Ft int
.Fn "event_loopbreak" "void"
d82 1
a82 13
.Fn "event_base_dispatch" "struct event_base *base"
.Ft int
.Fn "event_base_loop" "struct event_base *base" "int flags"
.Ft int
.Fn "event_base_loopexit" "struct event_base *base" "struct timeval *tv"
.Ft int
.Fn "event_base_loopbreak" "struct event_base *base"
.Ft int
.Fn "event_base_set" "struct event_base *base" "struct event *"
.Ft void
.Fn "event_base_free" "struct event_base *base"
.Ft int
.Fn "event_add" "struct event *ev" "struct timeval *tv"
d86 1
a86 5
.Fn "event_once" "int fd" "short event" "void (*fn)(int, short, void *)" "void *arg" "struct timeval *tv"
.Ft int
.Fn "event_base_once" "struct event_base *base" "int fd" "short event" "void (*fn)(int, short, void *)" "void *arg" "struct timeval *tv"
.Ft int
.Fn "event_pending" "struct event *ev" "short event" "struct timeval *tv"
a88 4
.Ft int
.Fn "event_priority_init" "int npriorities"
.Ft int
.Fn "event_priority_set" "struct event *ev" "int priority"
d92 1
a92 1
.Fn "evtimer_add" "struct event *ev" "struct timeval *"
d96 1
a96 1
.Fn "evtimer_pending" "struct event *ev" "struct timeval *tv"
d102 1
a102 1
.Fn "signal_add" "struct event *ev" "struct timeval *"
d106 1
a106 1
.Fn "signal_pending" "struct event *ev" "struct timeval *tv"
d109 32
d142 1
a142 1
.Fn "bufferevent_new" "int fd" "evbuffercb readcb" "evbuffercb writecb" "everrorcb" "void *cbarg"
a156 6
.Ft int
.Fn "bufferevent_base_set" "struct event_base *base" "struct bufferevent *bufev"
.Ft "struct event_asr *"
.Fn event_asr_run "struct asr_query *aq" "void (*fn)(struct asr_result *, void *)" "void *"
.Ft "void"
.Fn event_asr_abort "struct event_asr *eva"
@


1.46
log
@use .In to specify includes.
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.45 2014/11/19 23:50:22 dlg Exp $
d535 1
@


1.45
log
@i got sick of having to read the source code to know what the
evbuffer_foo functions do. reyk, nicm, jmc, and schwarze seem to
support a manpage as a reasonable solution to this problem.

im putting this in a separate manpage because i find they get too
cumbersome when they get too big. ingo agrees (and suggests even
this might be too big).

the file is evbuffer_new.3 rather than evbuffer.3 because we document
functions.

ok reyk@@ nicm@@ jmc@@ schwarze@@
this is rough, everyone has tweaks coming.
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.44 2014/11/19 20:29:03 jmc Exp $
d73 2
a74 2
.Fd #include <sys/time.h>
.Fd #include <event.h>
@


1.44
log
@BUGS is no longer relevant, according to nicm;
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.43 2014/04/03 13:30:05 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: April 3 2014 $
a68 11
.Nm evbuffer_new ,
.Nm evbuffer_free ,
.Nm evbuffer_add ,
.Nm evbuffer_add_buffer ,
.Nm evbuffer_add_printf ,
.Nm evbuffer_add_vprintf ,
.Nm evbuffer_drain ,
.Nm evbuffer_write ,
.Nm evbuffer_read ,
.Nm evbuffer_find ,
.Nm evbuffer_readline ,
a152 22
.Ft "struct evbuffer *"
.Fn "evbuffer_new" "void"
.Ft void
.Fn "evbuffer_free" "struct evbuffer *buf"
.Ft int
.Fn "evbuffer_add" "struct evbuffer *buf" "const void *data" "size_t size"
.Ft int
.Fn "evbuffer_add_buffer" "struct evbuffer *dst" "struct evbuffer *src"
.Ft int
.Fn "evbuffer_add_printf" "struct evbuffer *buf" "const char *fmt" "..."
.Ft int
.Fn "evbuffer_add_vprintf" "struct evbuffer *buf" "const char *fmt" "va_list ap"
.Ft void
.Fn "evbuffer_drain" "struct evbuffer *buf" "size_t size"
.Ft int
.Fn "evbuffer_write" "struct evbuffer *buf" "int fd"
.Ft int
.Fn "evbuffer_read" "struct evbuffer *buf" "int fd" "int size"
.Ft "u_char *"
.Fn "evbuffer_find" "struct evbuffer *buf" "const u_char *data" "size_t size"
.Ft "char *"
.Fn "evbuffer_readline" "struct evbuffer *buf"
@


1.43
log
@sort SEE ALSO;
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.42 2014/04/03 11:27:02 eric Exp $
a580 6
.Sh BUGS
This documentation is neither complete nor authoritative.
If you are in doubt about the usage of this API then
check the source code to find out how it works, write
up the missing piece of documentation and send it to
me for inclusion in this man page.
@


1.42
log
@add helper functions to use asr with libevent.

ok deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.41 2010/04/22 16:35:45 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: April 22 2010 $
a563 1
.Xr asr_run 3 ,
d567 1
@


1.41
log
@tweak previous; ok nicm
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.40 2010/04/21 20:02:40 nicm Exp $
d26 1
a26 1
.Dd $Mdocdate: April 21 2010 $
d79 3
a81 1
.Nm evbuffer_readline
d186 4
d407 20
d564 1
@


1.40
log
@Update libevent to 1.4.13.

This is the core library only, the DNS parts are removed and it does not
include the other extra bits (HTTP, DNS, and RPC), a separate port for
these will appear in due course.

Thanks to jsg, sthen, alek, gilles, jacekm, bernd and any others I've
forgotten for testing/comments.

Note that /usr/include/evdns.h should be removed after updating.

ok deraadt
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.39 2008/05/02 18:26:42 brad Exp $
d26 1
a26 1
.Dd $Mdocdate: May 2 2008 $
a400 1
.Pp
d484 3
a486 1
bufferevent_enable() and bufferevent_disable().
d511 3
a513 1
If multiple bases are in use, bufferevent_base_set() must be called before
d548 1
a548 4
The port of
.Nm libevent
to Windows is due to Michael A. Davis.
Support for real-time signals is due to Taral.
d552 2
a553 1
library was written by Niels Provos.
@


1.39
log
@- Use a const pointer for bufferevent_write.
- Make event_init return struct event_base *.

From the libevent SVN repo.

ok millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.38 2008/05/02 09:18:26 jmc Exp $
d34 1
a35 1
.\".Nm event_set_log_callback ,
d39 1
a45 1
.\".Nm event_active ,
a49 3
.\".Nm event_base_priority_init ,
.\".Nm event_get_version ,
.\".Nm event_get_method ,
a68 1
.\".Nm bufferevent_priority_set ,
a74 3
.\".Nm evbuffer_expand ,
.\".Nm evbuffer_remove ,
.\".Nm evbuffer_setcb ,
a79 45
.\".Nm evhttp_start ,
.\".Nm evhttp_free
.\".Nm evtag_init ,
.\".Nm evtag_marshal ,
.\".Nm encode_int ,
.\".Nm evtag_marshal_int ,
.\".Nm evtag_marshal_string ,
.\".Nm evtag_marshal_timeval ,
.\".Nm evtag_test ,
.\".Nm evtag_unmarshal ,
.\".Nm evtag_peek ,
.\".Nm evtag_peek_length ,
.\".Nm evtag_payload_length ,
.\".Nm evtag_consume ,
.\".Nm evtag_unmarshal_int ,
.\".Nm evtag_unmarshal_fixed ,
.\".Nm evtag_unmarshal_string ,
.\".Nm evtag_unmarshal_timeval ,
.\".Nm evhttp_start ,
.\".Nm evhttp_free ,
.\".Nm evhttp_set_cb ,
.\".Nm evhttp_set_gencb ,
.\".Nm evhttp_set_timeout ,
.\".Nm evhttp_send_error ,
.\".Nm evhttp_send_reply ,
.\".Nm evhttp_send_reply_start ,
.\".Nm evhttp_send_reply_chunk ,
.\".Nm evhttp_send_reply_end ,
.\".Nm evhttp_request_new ,
.\".Nm evhttp_request_set_chunked_cb ,
.\".Nm evhttp_connection_new ,
.\".Nm evhttp_connection_free ,
.\".Nm evhttp_connection_set_timeout ,
.\".Nm evhttp_connection_set_retries ,
.\".Nm evhttp_connection_set_closecb ,
.\".Nm evhttp_connection_get_peer ,
.\".Nm evhttp_make_request ,
.\".Nm evhttp_request_uri ,
.\".Nm evhttp_remove_header ,
.\".Nm evhttp_add_header ,
.\".Nm evhttp_clear_headers ,
.\".Nm evhttp_encode_uri ,
.\".Nm evhttp_decode_uri ,
.\".Nm evhttp_parse_query ,
.\".Nm evhttp_htmlescape ,
d92 2
d103 2
a183 8
.\".Ft "struct evhttp *"
.\".Fn "evhttp_start" "const char *address" "u_short port"
.\".Ft "void"
.\".Fn "evhttp_free" "struct evhttp* http"
.Ft int
.Fa (*event_sigcb)(void) ;
.Ft volatile sig_atomic_t
.Fa event_gotsig ;
a200 45
In order to avoid races in signal handlers, the
.Nm event
API provides two variables:
.Va event_sigcb
and
.Va event_gotsig .
A signal handler
sets
.Va event_gotsig
to indicate that a signal has been received.
The application sets
.Va event_sigcb
to a callback function.
After the signal handler sets
.Va event_gotsig ,
.Nm event_dispatch
will execute the callback function to process received signals.
The callback returns 1 when no events are registered any more.
It can return \-1 to indicate an error to the
.Nm event
library, causing
.Fn event_dispatch
to terminate with
.Va errno
set to
.Er EINTR .
.Pp
The
.Nm event_loop
function provides an interface for single pass execution of pending
events.
The flags
.Va EVLOOP_ONCE
and
.Va EVLOOP_NONBLOCK
are recognized.
The
.Nm event_loopexit
function allows the loop to be terminated after some amount of time
has passed.
The parameter indicates the time after which the loop should terminate.
.Pp
It is the responsibility of the caller to provide these functions with
pre-allocated event structures.
.Pp
d239 5
d309 26
d367 6
a372 5
The functions
.Fn evtimer_set ,
.Fn evtimer_add ,
.Fn evtimer_del ,
.Fn evtimer_initialized ,
d374 24
a397 4
.Fn evtimer_pending
are abbreviations for common situations where only a timeout is required.
The file descriptor passed will be \-1, and the event type will be
.Va EV_TIMEOUT .
d399 2
a400 14
The functions
.Fn signal_set ,
.Fn signal_add ,
.Fn signal_del ,
.Fn signal_initialized ,
and
.Fn signal_pending
are abbreviations.
The event type will be a persistent
.Va EV_SIGNAL .
That means
.Fn signal_set
adds
.Va EV_PERSIST .
a401 13
It is possible to disable support for
.Va kqueue , poll ,
or
.Va select
by setting the environment variables
.Va EVENT_NOKQUEUE , EVENT_NOPOLL ,
or
.Va EVENT_NOSELECT ,
respectively.
By setting the environment variable
.Va EVENT_SHOW_METHOD ,
.Nm libevent
displays the kernel notification method that it uses.
d512 14
a525 22
.\".Sh NON-BLOCKING HTTP SUPPORT
.\".Nm libevent
.\"provides a very thin HTTP layer that can be used both to host an HTTP
.\"server and also to make HTTP requests.
.\"An HTTP server can be created by calling
.\".Fn evhttp_start .
.\"When the HTTP server is no longer used, it can be freed via
.\".Fn evhttp_free .
.\".Pp
.\"To be notified of HTTP requests, a user needs to register callbacks with the
.\"HTTP server.
.\"This can be done by calling
.\".Fn evhttp_set_cb .
.\"The second argument is the URI for which a callback is being registered.
.\"The corresponding callback will receive an
.\".Va struct evhttp_request
.\"object that contains all information about the request.
.Pp
This section does not document all the possible function calls; please
check
.Va event.h
for the public interfaces.
a537 1
.Xr evdns 3 ,
d545 3
@


1.38
log
@Makefile: sort MLINKS and add event_base_once.3
event.3: fix NAME and remove spurious blank line
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.37 2008/05/02 06:09:11 brad Exp $
d197 1
a197 1
.Fn "bufferevent_write" "struct bufferevent *bufev" "void *data" "size_t size"
@


1.37
log
@Update to libevent 1.3e while retaining our local changes.

"No objection" millert@@
"the diff looks and works fine" reyk@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.36 2007/05/31 19:19:35 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: May 31 2007 $
d86 1
a86 1
.Nm evbuffer_readline ,
a163 1

@


1.36
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.35 2007/03/26 18:43:32 deraadt Exp $
d26 1
a26 1
.Dd $Mdocdate$
d44 1
d162 3
@


1.35
log
@do not doc the http parts
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.34 2007/03/21 13:52:01 millert Exp $
d26 1
a26 1
.Dd August 8, 2000
@


1.34
log
@Add missing const
List evhttp stuff commented out, should probably get its own man page
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.33 2007/03/21 13:41:21 millert Exp $
d86 2
a87 2
.Nm evhttp_start ,
.Nm evhttp_free
d229 4
a232 4
.Ft "struct evhttp *"
.Fn "evhttp_start" "const char *address" "u_short port"
.Ft "void"
.Fn "evhttp_free" "struct evhttp* http"
d583 17
a599 17
.Sh NON-BLOCKING HTTP SUPPORT
.Nm libevent
provides a very thin HTTP layer that can be used both to host an HTTP
server and also to make HTTP requests.
An HTTP server can be created by calling
.Fn evhttp_start .
When the HTTP server is no longer used, it can be freed via
.Fn evhttp_free .
.Pp
To be notified of HTTP requests, a user needs to register callbacks with the
HTTP server.
This can be done by calling
.Fn evhttp_set_cb .
The second argument is the URI for which a callback is being registered.
The corresponding callback will receive an
.Va struct evhttp_request
object that contains all information about the request.
@


1.33
log
@event_init() and event_dispatch() take void.  Add commented out
entries for undocumented functions to be filled in later, preferably
by someone who uses libevent.
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.31 2007/03/19 20:32:41 jmc Exp $
d104 27
d216 1
a216 1
.Fn "evbuffer_add_printf" "struct evbuffer *buf" "char *fmt" "..."
@


1.32
log
@Document event_base_free().  OK jmc@@
@
text
@d35 1
d44 1
d49 3
d71 1
d78 3
d88 16
d109 1
a109 1
.Fn "event_init"
d111 1
a111 1
.Fn "event_dispatch"
@


1.31
log
@+.Xr evdns 3 ,
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.30 2007/03/19 19:31:13 jmc Exp $
d39 1
d101 2
d456 1
d458 1
a458 1
.Fn bufferevent_base_set .
d468 3
@


1.30
log
@tweaks;
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.29 2007/03/19 15:12:49 millert Exp $
d558 1
@


1.29
log
@Update to libevent-1.3b while retaining our local changes.  beck@@ OK
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.28 2006/11/26 15:22:58 brad Exp $
d498 1
a498 1
The flags parameter can be a combination of 
d540 1
a540 1
object that contains all information about the request. 
d542 1
a542 1
This section does not document all the possible function calls, please
@


1.28
log
@allow both read and write callbacks for bufferevents to be NULL.

From Niels Provos via the libevent SVN

ok deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.27 2006/10/21 12:04:18 deraadt Exp $
d75 3
a77 1
.Nm evbuffer_readline
d157 1
a157 1
.Fn "evbuffer_add" "struct evbuffer *buf" "u_char *data" "size_t size"
d174 4
d498 1
a498 1
The flags parameter can be a combination of
d524 22
@


1.27
log
@bufferevent_write() return code misdocumented; ok jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.26 2006/03/23 10:51:27 jmc Exp $
d487 2
@


1.26
log
@new sentence, new line;
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.25 2006/03/18 20:23:42 brad Exp $
d507 2
d511 2
a512 2
function is used to read data from the input buffer.
Both functions return the amount of data written or read.
@


1.25
log
@- limit the amount of data bufferevents are going to consume to something
  reasonable; in some circumstances it could happen that libevent happily
  allocated 100MB in read buffers without telling the user; found by
  christopher maxwell - parts of these changes are from his patch.

- allow setting an event base for bufferevents; from phil oleson

- improved manpage from Phil Oleson

From libevent CVS
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.24 2006/01/25 05:25:34 brad Exp $
d489 2
a490 2
bufferevent_enable() and bufferevent_disable().  The flags parameter can
be a combination of 
d494 4
a497 3
When read enabled the bufferevent will try to read from the file 
descriptor and call the read callback. The write callback is executed
whenever the output buffer is drained below the write low watermark, 
@


1.24
log
@another fix from art.

From libevent CVS
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.23 2006/01/23 20:18:20 brad Exp $
d64 1
d148 2
d446 1
d448 1
a448 1
.Fn event_base_loopexit .
d455 3
d479 3
d484 14
a497 5
.Pp
By default the buffered event is read enabled and will try to read
from the file descriptor.
The write callback is executed whenever the output buffer is drained
below the write low watermark, which is
d510 3
@


1.23
log
@add evbuffer_add_vprintf interface from artur grabowski

From libevent CVS

ok markus@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.22 2006/01/21 19:15:09 brad Exp $
d166 1
a166 1
.Fn "evbuffer_find" "struct evbuffer *buf" "u_char *data" "size_t size"
@


1.22
log
@add a few missing functions.

From libevent CVS
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.21 2005/06/18 01:52:22 brad Exp $
d69 1
d157 2
@


1.21
log
@update to libevent 1.1a; keep local changes

ok grunk@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.20 2005/05/04 03:17:48 brad Exp $
d34 2
d38 1
a38 1
.Nm event_set ,
d86 2
d89 1
a89 1
.Fn "event_base_loop" "struct event_base *" "int flags"
d91 5
a95 3
.Fn "event_base_loopexit" "struct event_base *" "struct timeval *tv"
.Ft void
.Fn "event_set" "struct event *ev" "int fd" "short event" "void (*fn)(int, short, void *)" "void *arg"
@


1.20
log
@update to libevent 1.0d; keep local changes

thanks to Alexander von Gernler for testing
and some bug fixes

ok mpf@@ norby@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.19 2005/04/22 08:32:17 jmc Exp $
d199 1
a199 1
It can return -1 to indicate an error to the
d369 1
a369 1
The file descriptor passed will be 0, and the event type will be
@


1.19
log
@- no need for .Pp before .Sh
- sometime -> sometimes
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.18 2005/04/22 01:10:34 brad Exp $
d70 2
a71 1
.Nm evbuffer_find
d158 2
d331 1
a331 1
is similiar to
d391 1
a391 1
by setting the environment variable
d394 2
a395 1
.Va EVENT_NOSELECT .
@


1.18
log
@remove whitespace
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.17 2005/04/22 01:01:17 brad Exp $
a395 1
.Pp
d400 1
a400 1
However, sometime it is desirable to process some events with a higher
a419 1
.Pp
a437 1
.Pp
@


1.17
log
@update to libevent 1.0c; keep local changes

no shared lib so no ABI/API check is necessary

thanks to Alexander von Gernler for submitting
another diff in an attempt to update libevent
and for a use-after-free fix.

ok henning@@ deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.15 2005/04/19 02:03:12 brad Exp $
d277 1
a277 1
However, when an 
d279 1
a279 1
structure has been added to libevent using 
d281 5
a285 5
the structure must persist until the event occurs (assuming 
.Fa EV_PERSIST 
is not set) or is removed 
using 
.Fn event_del .  
d287 2
a288 2
.Fa ev 
structure for multiple monitored descriptors; each descriptor 
d434 1
a434 1
.Fn event_base_set 
d436 1
a436 1
.Fn event_set , 
d438 1
a438 1
.Fn event_set 
@


1.16
log
@backout.  not discussed, and very wrong.  bad brad
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.14 2005/04/13 16:15:09 reyk Exp $
d34 2
d42 2
d75 1
a75 1
.Ft void
d83 4
d99 4
d277 14
d385 1
a385 1
.Va epoll , kqueue , poll ,
d389 1
a389 1
.Va EVENT_NOEPOLL , EVENT_NOKQUEUE , EVENT_NOPOLL ,
d396 45
@


1.15
log
@update to libevent 1.0c; keep local changes
@
text
@a33 2
.Nm event_base_loop ,
.Nm event_base_loopexit ,
a39 2
.Nm event_priority_init ,
.Nm event_priority_set ,
d71 1
a71 1
.Ft "struct event_base *"
a78 4
.Ft int
.Fn "event_base_loop" "struct event_base *" "int flags"
.Ft int
.Fn "event_base_loopexit" "struct event_base *" "struct timeval *tv"
a90 4
.Ft int
.Fn "event_priority_init" "int npriorities"
.Ft int
.Fn "event_priority_set" "struct event *ev" "int priority"
a264 14
However, when an 
.Fa ev
structure has been added to libevent using 
.Fn event_add
the structure must persist until the event occurs (assuming 
.Fa EV_PERSIST 
is not set) or is removed 
using 
.Fn event_del .  
You may not reuse the same
.Fa ev 
structure for multiple monitored descriptors; each descriptor 
needs its own
.Fa ev .
d359 1
a359 1
.Va kqueue , poll ,
d363 1
a363 1
.Va EVENT_NOKQUEUE , EVENT_NOPOLL ,
a369 45
.Pp
.Sh EVENT PRIORITIES
By default
.Nm libevent
schedules all active events with the same priority.
However, sometime it is desirable to process some events with a higher
priority than others.
For that reason,
.Nm libevent
supports strict priority queues.
Active events with a lower priority are always processed before events
with a higher priority.
.Pp
The number of different priorities can be set initially with the
.Fn event_priority_init
function.
This function should be called before the first call to
.Fn event_dispatch .
The
.Fn event_priority_set
function can be used to assign a priority to an event.
By default,
.Nm libevent
assigns the middle priority to all events unless their priority
is explicitly set.
.Pp
.Sh THREAD SAFE EVENTS
.Nm Libevent
has experimental support for thread-safe events.
When initializing the library via
.Fn event_init ,
an event base is returned.
This event base can be used in conjunction with calls to
.Fn event_base_set ,
.Fn event_base_dispatch ,
.Fn event_base_loop ,
and
.Fn event_base_loopexit .
.Fn event_base_set 
should be called after preparing an event with
.Fn event_set , 
as
.Fn event_set 
assigns the provided event to the most recently created event base.
.Pp
@


1.14
log
@use "volatile sig_atomic_t" types instead of "int" for signal flags.

ok deraadt@@ henning@@ provos
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.13 2005/02/02 09:59:17 jolan Exp $
d34 2
d42 2
d75 1
a75 1
.Ft void
d83 4
d99 4
d277 14
d385 1
a385 1
.Va epoll , kqueue , poll ,
d389 1
a389 1
.Va EVENT_NOEPOLL , EVENT_NOKQUEUE , EVENT_NOPOLL ,
d396 45
@


1.13
log
@authorative->authoritative
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.12 2004/04/28 07:35:07 jmc Exp $
d147 1
a147 1
.Ft int
@


1.12
log
@various tweaks;
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.11 2004/04/28 06:53:12 brad Exp $
d435 1
a435 1
This documentation is neither complete nor authorative.
@


1.11
log
@update to libevent 0.8; keep local changes

ok markus@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.10 2003/09/23 08:52:04 markus Exp $
d276 3
a278 1
is NULL, no timeout occurs and the function will only be called
d310 1
a310 1
.Fa EV_READ
d324 1
a324 1
.Va NULL ,
d359 1
a359 1
.Va epoll , kqueue , poll
d363 1
a363 1
.Va EVENT_NOEPOLL , EVENT_NOKQUEUE , EVENT_NOPOLL
a369 1
.Pp
d375 1
a375 1
A buffered event provides input and output buffer that get filled
d383 1
a383 1
.Fa "fd"
d385 1
a385 1
This file descriptor is not allowed to be a 
d388 1
a388 1
The read and write callback have the following form
d390 1
a390 1
.Fn "(*cb)" "struct bufferevent *bufev" "void *arg"
d397 1
a397 1
below the write low watermark which is
a409 1
.Pp
d416 1
a416 1
Otherwise, -1 is returned and the global variable errno is
a428 3
The port of
.Nm libevent
to Windows is due to Michael A. Davis.
a433 1
.Pp
@


1.10
log
@add support for poll(2); ok deraadt
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.9 2003/07/09 10:54:38 markus Exp $
d33 1
d37 1
d49 18
a66 1
.Nm signal_initialized
d77 2
d86 2
d111 34
d202 5
d298 14
d357 1
a357 2
.Xr kqueue 2 ,
.Xr poll 2 ,
d359 1
a359 1
.Xr select 2
d361 1
a361 2
.Va EVENT_NOKQUEUE ,
.Va EVENT_NOPOLL ,
d369 41
d429 4
d437 7
@


1.9
log
@update to libevent-0.7a.tar.gz; keep local changes
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.8 2003/06/03 01:27:31 art Exp $
d281 2
a282 1
.Va kqueue
d284 1
a284 1
.Va select
d286 2
a287 1
.Va EVENT_NOKQUEUE
d305 1
@


1.8
log
@license cleaning.
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.7 2003/05/23 12:41:13 jmc Exp $
d282 2
d285 8
a292 1
.Va EVENT_NOKQUEUE .
@


1.7
log
@- typos
- whitespace at EOL
- new sentence, new line
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.6 2002/11/10 03:21:48 fgsch Exp $
d12 1
a12 4
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. The name of the author may not be used to endorse or promote products
@


1.6
log
@SEE ALSO corrections. millert ok.
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.4 2002/07/12 18:50:48 provos Exp $
d43 1
a43 1
.Nm evtimer_del
d48 1
a48 1
.Nm signal_del
d124 2
a125 1
to a callback function.  After the signal handler sets
d128 3
a130 3
will execute the callback function to process received signals.  The
callback returns 1 when no events are registered any more.  It can
return -1 to indicate an error to the
d137 1
a137 1
.Er EINTR.
d142 2
a143 1
events.  The flags
d171 1
a171 1
The 
d177 2
a178 2
or both.
Indicating that an application can read or write from the file descriptor
d211 1
a211 1
event when the event specified in 
d246 1
a246 1
was specified and 
a267 1
.Pp
a286 1
.Pp
@


1.5
log
@grammar; ok deraadt@@
@
text
@d296 1
a296 1
.Xr timeout 9 ,
d298 1
a298 1
.Xr kqueue 2
@


1.4
log
@change timeout_ API to evtimer_ API; avoiding clashes with kernel include
files.  okay mickey@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.3 2002/07/05 20:04:39 provos Exp $
d99 1
a99 1
on a file descriptor occurs or after at a given time has passed.
d109 1
a109 1
This functions only returns on error, and should replace the event core
d227 1
a227 1
argument has already a scheduled timeout, the old timeout will be
@


1.3
log
@add sys/time.h to SYNOPSIS; from bk@@rt.fm
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.2 2002/06/25 15:39:38 mpech Exp $
d41 5
a45 5
.Nm timeout_set ,
.Nm timeout_add ,
.Nm timeout_del
.Nm timeout_pending ,
.Nm timeout_initialized ,
d72 1
a72 1
.Fn "timeout_set" "struct event *ev" "void (*fn)(int, short, void *)" "void *arg"
d74 1
a74 1
.Fn "timeout_add" "struct event *ev" "struct timeval *"
d76 1
a76 1
.Fn "timeout_del" "struct event *ev"
d78 1
a78 1
.Fn "timeout_pending" "struct event *ev" "struct timeval *tv"
d80 1
a80 1
.Fn "timeout_initialized" "struct event *ev"
d256 4
a259 4
.Fn timeout_set ,
.Fn timeout_add ,
.Fn timeout_del ,
.Fn timeout_initialized ,
d261 1
a261 1
.Fn timeout_pending
@


1.2
log
@typos. Patch from bk@@rt.fr

millert@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: event.3,v 1.1.1.1 2002/06/15 18:01:37 provos Exp $
d53 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
.\"	$OpenBSD: timeout.9,v 1.11 2000/10/12 18:06:03 aaron Exp $
d40 1
a40 1
.Nm event_initalized ,
d45 1
a45 1
.Nm timeout_initalized ,
d50 1
a50 1
.Nm signal_initalized ,
d102 1
a102 1
API needs to be initalized with
d161 1
a161 1
argument indicating the file descriptor, with a
d172 2
a173 2
.Va EV_READ,
.Va EV_WRITE,
d201 2
a202 2
and does not need to be reinitialized unless you wish to
change the function called and/or the argument to it.
@


1.1.1.1
log
@import libevent an event notification abstraction on top of select or kqueue
supporting timeout and signal callsbacks, too.  okay deraadt@@ millert@@
@
text
@@
