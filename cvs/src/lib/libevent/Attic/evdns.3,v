head	1.6;
access;
symbols
	OPENBSD_4_7:1.5.0.10
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.12
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.8
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.6
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.4
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.2
	OPENBSD_4_2_BASE:1.5;
locks; strict;
comment	@.\" @;


1.6
date	2010.04.21.20.02.40;	author nicm;	state dead;
branches;
next	1.5;

1.5
date	2007.05.31.19.19.35;	author jmc;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.21.12.52.04;	author jmc;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.19.20.30.22;	author jmc;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.19.20.12.45;	author jmc;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.19.15.12.49;	author millert;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update libevent to 1.4.13.

This is the core library only, the DNS parts are removed and it does not
include the other extra bits (HTTP, DNS, and RPC), a separate port for
these will appear in due course.

Thanks to jsg, sthen, alek, gilles, jacekm, bernd and any others I've
forgotten for testing/comments.

Note that /usr/include/evdns.h should be removed after updating.

ok deraadt
@
text
@.\"	$OpenBSD: evdns.3,v 1.5 2007/05/31 19:19:35 jmc Exp $
.\"
.\" Copyright (c) 2006 Niels Provos <provos@@citi.umich.edu>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. The name of the author may not be used to endorse or promote products
.\"    derived from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
.\" INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
.\" AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
.\" THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
.\" EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
.\" PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
.\" OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
.\" WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
.\" OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
.\" ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd $Mdocdate: May 31 2007 $
.Dt EVDNS 3
.Os
.Sh NAME
.Nm evdns_init ,
.Nm evdns_shutdown ,
.Nm evdns_err_to_string ,
.Nm evdns_nameserver_add ,
.Nm evdns_count_nameservers ,
.Nm evdns_clear_nameservers_and_suspend ,
.Nm evdns_resume ,
.Nm evdns_nameserver_ip_add ,
.Nm evdns_resolve_ipv4 ,
.Nm evdns_resolve_reverse ,
.Nm evdns_resolv_conf_parse ,
.Nm evdns_search_clear ,
.Nm evdns_search_add ,
.Nm evdns_search_ndots_set ,
.Nm evdns_set_log_fn
.Nd asynchronous functions for DNS resolution
.Sh SYNOPSIS
.Fd #include <sys/time.h>
.Fd #include <event.h>
.Fd #include <evdns.h>
.Ft int
.Fn evdns_init
.Ft void
.Fn evdns_shutdown "int fail_requests"
.Ft "const char *"
.Fn evdns_err_to_string "int err"
.Ft int
.Fn evdns_nameserver_add "unsigned long int address"
.Ft int
.Fn evdns_count_nameservers
.Ft int
.Fn evdns_clear_nameservers_and_suspend
.Ft int
.Fn evdns_resume
.Ft int
.Fn evdns_nameserver_ip_add "const char *ip_as_string"
.Ft int
.Fn evdns_resolve_ipv4 "const char *name" "int flags" "evdns_callback_type callback" "void *ptr"
.Ft int
.Fn evdns_resolve_reverse "struct in_addr *in" "int flags" "evdns_callback_type callback" "void *ptr"
.Ft int
.Fn evdns_resolv_conf_parse "int flags" "const char *"
.Ft void
.Fn evdns_search_clear
.Ft void
.Fn evdns_search_add "const char *domain"
.Ft void
.Fn evdns_search_ndots_set "const int ndots"
.Ft void
.Fn evdns_set_log_fn "evdns_debug_log_fn_type fn"
.Sh DESCRIPTION
Welcome, gentle reader.
.Pp
Asynchronous DNS lookups are really a whole lot harder
than they should be,
mostly stemming from the fact that the libc resolver has never been
very good at them.
Before you use this library you should see if libc
can do the job for you with the modern async call
.Fn getaddrinfo_a
(see http://www.imperialviolet.org/page25.html#e498).
Otherwise, please continue.
.Pp
This code is based on libevent and
.Fn event_init
must be called before
any of the APIs in this file.
.Pp
The library keeps track of the state of nameservers and will avoid
them when they go down.
Otherwise it will round robin between them.
.Pp
Quick start guide:
.Bd -literal -offset indent
#include "evdns.h"
void callback(int result, char type, int count, int ttl,
    void *addresses, void *arg);
evdns_resolv_conf_parse(DNS_OPTIONS_ALL, "/etc/resolv.conf");
evdns_resolve("www.hostname.com", 0, callback, NULL);
.Ed
.Pp
When the lookup is complete, the callback function is called.
The first argument will be one of the DNS_ERR_* defines in
.Aq Pa evdns.h .
Hopefully it will be
.Dv DNS_ERR_NONE ,
in which case type will be
.Dv DNS_IPv4_A ,
.Fa count
will be the number of IP addresses,
.Fa ttl
is the time which the data can be cached for (in seconds),
.Fa addresses
will point to an array of uint32_t's and
.Fa arg
will be whatever was passed to
.Fn evdns_resolve .
.Pp
Searching:
.Pp
In order for this library to be a good replacement for the libc resolver,
it supports searching.
This involves setting a list of default domains, in
which names will be queried for.
The number of dots in the query name
determines the order in which this list is used.
.Pp
Searching appears to be a single lookup from the point of view of the API,
although many DNS queries may be generated from a single call to
.Fn evdns_resolve .
Searching can also drastically slow down the resolution of names.
.Pp
To disable searching:
.Pp
.Bl -enum -compact -offset indent
.It
Never set it up.
If
.Fn evdns_resolv_conf_parse ,
.Fn evdns_init ,
and
.Fn evdns_search_add
are never called
then no searching will occur.
.It
If you do call
.Fn evdns_resolv_conf_parse
then don't pass
.Dv DNS_OPTION_SEARCH
(or
.Dv DNS_OPTIONS_ALL ,
which implies it).
.It
When calling
.Fn evdns_resolve ,
pass the
.Dv DNS_QUERY_NO_SEARCH
flag.
.El
.Pp
The order of searches depends on the number of dots in the name.
If the number is greater than the ndots setting then the names is first tried
globally.
Otherwise each search domain is appended in turn.
.Pp
The ndots setting can either be set from a
.Xr resolv.conf 5 ,
or by calling
.Fn evdns_search_ndots_set .
.Pp
For example, with ndots set to 1 (the default) and a search domain list of
["myhome.net"]:
.Bd -literal -offset indent
Query: www
Order: www.myhome.net, www.

Query: www.abc
Order: www.abc., www.abc.myhome.net
.Ed
.Sh API REFERENCE
.Bl -tag -width 0123456
.It Fn "int evdns_init"
Initializes support for non-blocking name resolution by calling
.Fn evdns_resolv_conf_parse .
.It Fn "int evdns_nameserver_add" "unsigned long int address"
Add a nameserver.
The address should be an IP address in network byte order.
The type of address is chosen so that
it matches in_addr.s_addr.
Returns non-zero on error.
.It Fn "int evdns_nameserver_ip_add" "const char *ip_as_string"
This wraps the above function by parsing a string as an IP
address and adds it as a nameserver.
Returns non-zero on error
.It Fn "int evdns_resolve" "const char *name" "int flags" "evdns_callback_type callback" "void *ptr"
Resolve a name.
The name parameter should be a DNS name.
The flags parameter should be 0, or
.Dv DNS_QUERY_NO_SEARCH
which disables searching for this query
(see the definition of searching, above).
.Pp
The
.Fa callback
argument is a function which is called when
this query completes and
.Fa ptr
is an argument which is passed
to that callback function.
.Pp
Returns non-zero on error.
.It Fn "void evdns_search_clear"
Clears the list of search domains
.It Fn "void evdns_search_add" "const char *domain"
Add a domain to the list of search domains
.It Fn "void evdns_search_ndots_set" "int ndots"
Set the number of dots which, when found in a name, causes
the first query to be without any search domain.
.It Fn "int evdns_count_nameservers" "void"
Return the number of configured nameservers (not necessarily the
number of running nameservers).
This is useful for double checking whether calls to the various
nameserver configuration functions have been successful.
.It Fn "int evdns_clear_nameservers_and_suspend" "void"
Remove all currently configured nameservers, and suspend all pending
resolves.
Resolves will not necessarily be re-attempted until
.Fn evdns_resume
is called.
.It Fn "int evdns_resume" "void"
Re-attempt resolves left in limbo after an earlier call to
.Fn evdns_clear_nameservers_and_suspend .
.It Fn "int evdns_resolv_conf_parse" "int flags" "const char *filename"
Parse a resolv.conf-like file from the given filename.
.Pp
See the man page for
.Xr resolv.conf 5
for the format of this file.
The flags argument determines what information is parsed from
this file:
.Pp
.Bl -tag -width "DNS_OPTION_NAMESERVERS" -offset indent -compact
.It Dv DNS_OPTION_SEARCH
Domain, search, and ndots options.
.It Dv DNS_OPTION_NAMESERVERS
Nameserver lines.
.It Dv DNS_OPTION_MISC
Timeout and attempts options.
.It Dv DNS_OPTIONS_ALL
All of the above.
.El
.Pp
The following directives are not parsed from the file:
lookup and sortlist.
Additionally, the following
.Dq options
are ignored: debug, edns0, inet6, insecure1, and insecure2.
.Pp
Returns non-zero on error:
.Pp
.Bl -tag -width "0XXX" -offset indent -compact
.It 0
no errors
.It 1
failed to open file
.It 2
failed to stat file
.It 3
file too large
.It 4
out of memory
.It 5
short read from file
.El
.El
.Sh INTERNALS
Requests are kept in two queues.
The first is the inflight queue.
In this queue requests have an allocated transaction ID and nameserver.
They will soon be transmitted if they haven't already.
.Pp
The second is the waiting queue.
The size of the inflight ring is
limited and all other requests wait in waiting queue for space.
This limits the number of concurrent requests
so that the nameserver does not get flooded.
Several algorithms require a full walk of the inflight
queue so limiting its size keeps thing going nicely under huge
(many thousands of requests) loads.
.Pp
If a nameserver loses too many requests it is considered down and we
try not to use it.
After a while a probe is sent to that nameserver
(a lookup for google.com) and, if it replies, we consider it working
again.
If the nameserver fails a probe,
we wait longer to try again with the next probe.
.Sh SEE ALSO
.Xr event 3 ,
.Xr gethostbyname 3 ,
.Xr resolv.conf 5
.Sh HISTORY
The
.Nm evdns
API was developed by Adam Langley on top of the
.Nm libevent
API.
The code was integrated into
.Nm Tor
by Nick Mathewson and finally put into
.Nm libevent
itself by Niels Provos.
.Sh AUTHORS
The
.Nm evdns
API and code was written by Adam Langley with significant
contributions by Nick Mathewson.
.Sh BUGS
This documentation is neither complete nor authoritative.
If you are in doubt about the usage of this API then
check the source code to find out how it works, write
up the missing piece of documentation and send it to
me for inclusion in this man page.
@


1.5
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: evdns.3,v 1.4 2007/03/21 12:52:04 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate$
@


1.4
log
@fix a formatting issue found by reyk;
@
text
@d1 1
a1 1
.\"	$OpenBSD: evdns.3,v 1.3 2007/03/19 20:30:22 jmc Exp $
d29 1
a29 1
.Dd October 7, 2006
@


1.3
log
@further cleanup;
@
text
@d1 1
a1 1
.\"	$OpenBSD: evdns.3,v 1.2 2007/03/19 20:12:45 jmc Exp $
d194 1
a194 1
.It Fn int evdns_init
d197 1
a197 1
.It Fn int evdns_nameserver_add "unsigned long int address"
d203 1
a203 1
.It Fn int evdns_nameserver_ip_add "const char *ip_as_string"
d207 1
a207 1
.It Fn int evdns_resolve "const char *name" "int flags" "evdns_callback_type callback" "void *ptr"
d224 1
a224 1
.It Fn void evdns_search_clear
d226 1
a226 1
.It Fn void evdns_search_add "const char *domain"
d228 1
a228 1
.It Fn void evdns_search_ndots_set "int ndots"
d231 1
a231 1
.It Fn int evdns_count_nameservers "void"
d236 1
a236 1
.It Fn int evdns_clear_nameservers_and_suspend "void"
d242 1
a242 1
.It Fn int evdns_resume "void"
d245 1
a245 1
.It Fn int evdns_resolv_conf_parse "int flags" "const char *filename"
@


1.2
log
@clean up this page;
@
text
@d1 1
a1 1
.\"	$OpenBSD: evdns.3,v 1.1 2007/03/19 15:12:49 millert Exp $
d33 14
a46 14
.Nm evdns_init
.Nm evdns_shutdown
.Nm evdns_err_to_string
.Nm evdns_nameserver_add
.Nm evdns_count_nameservers
.Nm evdns_clear_nameservers_and_suspend
.Nm evdns_resume
.Nm evdns_nameserver_ip_add
.Nm evdns_resolve_ipv4
.Nm evdns_resolve_reverse
.Nm evdns_resolv_conf_parse
.Nm evdns_search_clear
.Nm evdns_search_add
.Nm evdns_search_ndots_set
d68 1
a68 1
.Fn evdns_nameserver_ip_add(const char *ip_as_string);
a184 1
.Pp
@


1.1
log
@Update to libevent-1.3b while retaining our local changes.  beck@@ OK
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d48 1
a48 1
.Nd asynchronous functions for DNS resolution.
d84 1
a84 1
Welcome, gentle reader
d86 2
a87 1
Async DNS lookups are really a whole lot harder than they should be,
d91 2
a92 1
can do the job for you with the modern async call getaddrinfo_a
d96 3
a98 1
This code is based on libevent and you must call event_init before
d115 15
a129 6
The first argument will be one of the DNS_ERR_* defines in evdns.h.
Hopefully it will be DNS_ERR_NONE, in which case type will be
DNS_IPv4_A, count will be the number of IP addresses, ttl is the time
which the data can be cached for (in seconds), addresses will point
to an array of uint32_t's and arg will be whatever you passed to
evdns_resolve.
d133 2
a134 2
In order for this library to be a good replacement for the libc resolver it
supports searching.
d142 1
a142 1
evdns_resolve.
d146 1
d150 4
a153 4
If you never call
.Fn evdns_resolv_conf_parse,
.Fn evdns_init,
or
d155 1
d161 1
a161 1
.Va DNS_OPTION_SEARCH
d163 1
a163 1
.Va DNS_OPTIONS_ALL,
d167 1
a167 1
.Fn evdns_resolve,
d169 1
a169 1
.Va DNS_QUERY_NO_SEARCH
d178 4
a181 2
The ndots setting can either be set from a resolv.conf, or by calling
evdns_search_ndots_set.
a184 7
 Query: www
 Order: www.myhome.net, www.
.Pp
 Query: www.abc
 Order: www.abc., www.abc.myhome.net
.Pp
.Sh API reference
d186 8
d195 1
a195 1
.It Ft int Fn evdns_init
d198 1
a198 1
.It Ft int Fn evdns_nameserver_add "unsigned long int address"
d204 1
a204 1
.It Ft int Fn evdns_nameserver_ip_add "const char *ip_as_string"
d208 1
a208 1
.It Ft int Fn evdns_resolve "const char *name" "int flags" "evdns_callback_type callback" "void *ptr"
d211 4
a214 3
The flags parameter should be 0, or DNS_QUERY_NO_SEARCH
which disables searching for this query.
(see defn of searching above).
d216 6
a221 2
The callback argument is a function which is called when
this query completes and ptr is an argument which is passed
d224 2
a225 2
Returns non-zero on error
.It Ft void Fn evdns_search_clear
d227 1
a227 1
.It Ft void Fn evdns_search_add "const char *domain"
d229 1
a229 1
.It Ft void Fn evdns_search_ndots_set "int ndots"
d232 1
a232 1
.It Ft int Fn evdns_count_nameservers "void"
d235 1
a235 1
This is useful for double-checking whether our calls to the various
d237 1
a237 1
.It Ft int Fn evdns_clear_nameservers_and_suspend "void"
d241 3
a243 2
evdns_resume() is called.
.It Ft int Fn evdns_resume "void"
d245 3
a247 3
evdns_clear_nameservers_and_suspend().
.It Ft int Fn evdns_resolv_conf_parse "int flags" "const char *filename"
Parse a resolv.conf like file from the given filename.
d249 3
a251 1
See the man page for resolv.conf for the format of this file.
d254 10
a263 9
.Bl -tag -width "DNS_OPTION_NAMESERVERS" -offset indent -compact -nested
.It DNS_OPTION_SEARCH
domain, search and ndots options
.It DNS_OPTION_NAMESERVERS
nameserver lines
.It DNS_OPTION_MISC
timeout and attempts options
.It DNS_OPTIONS_ALL
all of the above
d266 2
a267 1
The following directives are not parsed from the file: lookup, sortlist.
d270 1
a270 1
are ignored: debug, edns0, inet6, insecure1, insecure2.
d273 2
a274 1
.Bl -tag -width "0" -offset indent -compact -nested
d289 13
a301 10
.Sh Internals:
Requests are kept in two queues. The first is the inflight queue. In
this queue requests have an allocated transaction id and nameserver.
They will soon be transmitted if they haven't already been.
.Pp
The second is the waiting queue. The size of the inflight ring is
limited and all other requests wait in waiting queue for space. This
bounds the number of concurrent requests so that we don't flood the
nameserver. Several algorithms require a full walk of the inflight
queue and so bounding its size keeps thing going nicely under huge
d305 2
a306 1
try not to use it. After a while we send a probe to that nameserver
d308 3
a310 2
again. If the nameserver fails a probe we wait longer to try again
with the next probe.
d321 1
a321 1
The code was integrate into
@

