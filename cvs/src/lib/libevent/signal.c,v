head	1.25;
access;
symbols
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.8
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.4
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.16.0.8
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.12
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.10
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.8
	OPENBSD_5_0:1.15.0.6
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.8
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.6
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.25
date	2015.01.06.11.42.37;	author bluhm;	state Exp;
branches;
next	1.24;
commitid	M27YXZ9VjQWTQYT3;

1.24
date	2014.10.30.16.45.37;	author bluhm;	state Exp;
branches;
next	1.23;
commitid	tunEM8ZR8ESfpNht;

1.23
date	2014.10.29.22.47.29;	author bluhm;	state Exp;
branches;
next	1.22;
commitid	FfV5qz960uDg9hP4;

1.22
date	2014.10.18.16.48.28;	author bluhm;	state Exp;
branches;
next	1.21;
commitid	hi1FlfmD0UHtTfmr;

1.21
date	2014.10.17.19.16.01;	author bluhm;	state Exp;
branches;
next	1.20;
commitid	wDYYYW1I3umfP7v5;

1.20
date	2014.10.16.07.38.06;	author bluhm;	state Exp;
branches;
next	1.19;
commitid	Lmt85cKJJzyEtWLn;

1.19
date	2014.10.08.20.14.19;	author bluhm;	state Exp;
branches;
next	1.18;
commitid	WQfvaeUx8qLyAKa3;

1.18
date	2014.10.08.05.41.42;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	bIKEHDDuWEhznXtg;

1.17
date	2014.10.06.21.16.03;	author bluhm;	state Exp;
branches;
next	1.16;
commitid	g4pIM3aXIE3MYzpg;

1.16
date	2013.04.29.00.28.23;	author okan;	state Exp;
branches;
next	1.15;

1.15
date	2010.07.12.18.03.38;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.21.20.02.40;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2010.01.10.00.36.35;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.02.06.09.11;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.19.15.12.49;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.02.16.54.25;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.02.04.14.03;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.01.21.08.56;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.02.07.15.13;	author grunk;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.22.00.56.25;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.19.08.07.45;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.19.02.03.12;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.28.06.53.12;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.10.07.48.42;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.09.10.54.38;	author markus;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Apply commit e0e6958aa074a7714cd7c4aa779a1dfede3a03b1 from upstream.
- Avoid deadlock when activating signals.  Fixes bug 3048812.
  Based on patch by Nicholas Marriott.
The deadlock was ultimately fixed in a different way (by disabling
reinit - see event.c r1.25).  Add it now for consistency but without
the Windows compatibility code.  Convert the fnctl() calls to
SOCK_CLOEXEC | SOCK_NONBLOCK to simplify the code.
OK nicm@@
@
text
@/*	$OpenBSD: signal.c,v 1.24 2014/10/30 16:45:37 bluhm Exp $	*/

/*
 * Copyright 2000-2002 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/queue.h>
#include <sys/socket.h>

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <assert.h>

#include "event.h"
#include "event-internal.h"
#include "evsignal.h"
#include "log.h"

struct event_base *evsignal_base = NULL;

static void evsignal_handler(int sig);

/* Callback for when the signal handler write a byte to our signaling socket */
static void
evsignal_cb(int fd, short what, void *arg)
{
	static char signals[1];
	ssize_t n;

	n = recv(fd, signals, sizeof(signals), 0);
	if (n == -1) {
		if (errno != EAGAIN)
			event_err(1, "%s: read", __func__);
	}
}

int
evsignal_init(struct event_base *base)
{
	int i;

	/*
	 * Our signal handler is going to write to one end of the socket
	 * pair to wake up our event loop.  The event loop then scans for
	 * signals that got delivered.
	 */
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    0, base->sig.ev_signal_pair) == -1) {
		event_err(1, "%s: socketpair", __func__);
		return -1;
	}

	base->sig.sh_old = NULL;
	base->sig.sh_old_max = 0;
	base->sig.evsignal_caught = 0;
	memset(&base->sig.evsigcaught, 0, sizeof(sig_atomic_t)*NSIG);
	/* initialize the queues for all events */
	for (i = 0; i < NSIG; ++i)
		TAILQ_INIT(&base->sig.evsigevents[i]);

	event_set(&base->sig.ev_signal, base->sig.ev_signal_pair[1],
		EV_READ | EV_PERSIST, evsignal_cb, &base->sig.ev_signal);
	base->sig.ev_signal.ev_base = base;
	base->sig.ev_signal.ev_flags |= EVLIST_INTERNAL;

	return 0;
}

/* Helper: set the signal handler for evsignal to handler in base, so that
 * we can restore the original handler when we clear the current one. */
int
_evsignal_set_handler(struct event_base *base,
		      int evsignal, void (*handler)(int))
{
	struct sigaction sa;
	struct evsignal_info *sig = &base->sig;
	void *p;

	/*
	 * resize saved signal handler array up to the highest signal number.
	 * a dynamic array is used to keep footprint on the low side.
	 */
	if (evsignal >= sig->sh_old_max) {
		int new_max = evsignal + 1;
		event_debug(("%s: evsignal (%d) >= sh_old_max (%d), resizing",
			    __func__, evsignal, sig->sh_old_max));
		p = reallocarray(sig->sh_old, new_max, sizeof(*sig->sh_old));
		if (p == NULL) {
			event_warn("realloc");
			return (-1);
		}

		memset((char *)p + sig->sh_old_max * sizeof(*sig->sh_old),
		    0, (new_max - sig->sh_old_max) * sizeof(*sig->sh_old));

		sig->sh_old_max = new_max;
		sig->sh_old = p;
	}

	/* allocate space for previous handler out of dynamic array */
	sig->sh_old[evsignal] = malloc(sizeof *sig->sh_old[evsignal]);
	if (sig->sh_old[evsignal] == NULL) {
		event_warn("malloc");
		return (-1);
	}

	/* save previous handler and setup new handler */
	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = handler;
	sa.sa_flags |= SA_RESTART;
	sigfillset(&sa.sa_mask);

	if (sigaction(evsignal, &sa, sig->sh_old[evsignal]) == -1) {
		event_warn("sigaction");
		free(sig->sh_old[evsignal]);
		sig->sh_old[evsignal] = NULL;
		return (-1);
	}

	return (0);
}

int
evsignal_add(struct event *ev)
{
	int evsignal;
	struct event_base *base = ev->ev_base;
	struct evsignal_info *sig = &ev->ev_base->sig;

	if (ev->ev_events & (EV_READ|EV_WRITE))
		event_errx(1, "%s: EV_SIGNAL incompatible use", __func__);
	evsignal = EVENT_SIGNAL(ev);
	assert(evsignal >= 0 && evsignal < NSIG);
	if (TAILQ_EMPTY(&sig->evsigevents[evsignal])) {
		event_debug(("%s: %p: changing signal handler", __func__, ev));
		if (_evsignal_set_handler(
			    base, evsignal, evsignal_handler) == -1)
			return (-1);

		/* catch signals if they happen quickly */
		evsignal_base = base;

		if (!sig->ev_signal_added) {
			if (event_add(&sig->ev_signal, NULL))
				return (-1);
			sig->ev_signal_added = 1;
		}
	}

	/* multiple events may listen to the same signal */
	TAILQ_INSERT_TAIL(&sig->evsigevents[evsignal], ev, ev_signal_next);

	return (0);
}

int
_evsignal_restore_handler(struct event_base *base, int evsignal)
{
	int ret = 0;
	struct evsignal_info *sig = &base->sig;
	struct sigaction *sh;

	/* restore previous handler */
	sh = sig->sh_old[evsignal];
	sig->sh_old[evsignal] = NULL;
	if (sigaction(evsignal, sh, NULL) == -1) {
		event_warn("sigaction");
		ret = -1;
	}
	free(sh);

	return ret;
}

int
evsignal_del(struct event *ev)
{
	struct event_base *base = ev->ev_base;
	struct evsignal_info *sig = &base->sig;
	int evsignal = EVENT_SIGNAL(ev);

	assert(evsignal >= 0 && evsignal < NSIG);

	/* multiple events may listen to the same signal */
	TAILQ_REMOVE(&sig->evsigevents[evsignal], ev, ev_signal_next);

	if (!TAILQ_EMPTY(&sig->evsigevents[evsignal]))
		return (0);

	event_debug(("%s: %p: restoring signal handler", __func__, ev));

	return (_evsignal_restore_handler(ev->ev_base, EVENT_SIGNAL(ev)));
}

static void
evsignal_handler(int sig)
{
	int save_errno = errno;

	if (evsignal_base == NULL) {
		event_warn(
			"%s: received signal %d, but have no base configured",
			__func__, sig);
		return;
	}

	evsignal_base->sig.evsigcaught[sig]++;
	evsignal_base->sig.evsignal_caught = 1;

	/* Wake up our notification mechanism */
	send(evsignal_base->sig.ev_signal_pair[0], "a", 1, 0);
	errno = save_errno;
}

void
evsignal_process(struct event_base *base)
{
	struct evsignal_info *sig = &base->sig;
	struct event *ev, *next_ev;
	sig_atomic_t ncalls;
	int i;

	base->sig.evsignal_caught = 0;
	for (i = 1; i < NSIG; ++i) {
		ncalls = sig->evsigcaught[i];
		if (ncalls == 0)
			continue;
		sig->evsigcaught[i] -= ncalls;

		for (ev = TAILQ_FIRST(&sig->evsigevents[i]);
		    ev != NULL; ev = next_ev) {
			next_ev = TAILQ_NEXT(ev, ev_signal_next);
			if (!(ev->ev_events & EV_PERSIST))
				event_del(ev);
			event_active(ev, EV_SIGNAL, ncalls);
		}

	}
}

void
evsignal_dealloc(struct event_base *base)
{
	int i = 0;
	if (base->sig.ev_signal_added) {
		event_del(&base->sig.ev_signal);
		base->sig.ev_signal_added = 0;
	}
	for (i = 0; i < NSIG; ++i) {
		if (i < base->sig.sh_old_max && base->sig.sh_old[i] != NULL)
			_evsignal_restore_handler(base, i);
	}

	if (base->sig.ev_signal_pair[0] != -1) {
		close(base->sig.ev_signal_pair[0]);
		base->sig.ev_signal_pair[0] = -1;
	}
	if (base->sig.ev_signal_pair[1] != -1) {
		close(base->sig.ev_signal_pair[1]);
		base->sig.ev_signal_pair[1] = -1;
	}
	base->sig.sh_old_max = 0;

	/* per index frees are handled in evsignal_del() */
	if (base->sig.sh_old) {
		free(base->sig.sh_old);
		base->sig.sh_old = NULL;
	}
}
@


1.24
log
@Fix whitespace errors in libevent.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.23 2014/10/29 22:47:29 bluhm Exp $	*/
d61 4
a64 2
	if (n == -1)
		event_err(1, "%s: read", __func__);
d70 1
a70 1
	int i, flags;
d77 2
a78 2
	if (socketpair(
		    AF_UNIX, SOCK_STREAM, 0, base->sig.ev_signal_pair) == -1) {
a82 4
	if (fcntl(base->sig.ev_signal_pair[0], F_SETFD, FD_CLOEXEC) == -1)
		event_warn("fcntl(signal_pair[0], FD_CLOEXEC)");
	if (fcntl(base->sig.ev_signal_pair[1], F_SETFD, FD_CLOEXEC) == -1)
		event_warn("fcntl(signal_pair[1], FD_CLOEXEC)");
a89 4

	if ((flags = fcntl(base->sig.ev_signal_pair[0], F_GETFL, NULL)) == -1 ||
	    fcntl(base->sig.ev_signal_pair[0], F_SETFL, flags|O_NONBLOCK) == -1)
		event_warn("fcntl(signal_pair[0], O_NONBLOCK)");
@


1.23
log
@After removing all the #ifdef, the wrappers in evutil are rather
useless.  Let libevent call the libc functions directly.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.22 2014/10/18 16:48:28 bluhm Exp $	*/
d70 1
a70 1
	/* 
d258 1
a258 1
	
@


1.22
log
@Remove the remaining #ifdef HAVE_ and the #define _GNU_SOURCE.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.21 2014/10/17 19:16:01 bluhm Exp $	*/
a46 1
#include "evutil.h"
a64 5
#define FD_CLOSEONEXEC(x) do { \
        if (fcntl(x, F_SETFD, FD_CLOEXEC) == -1) \
                event_warn("fcntl(%d, F_SETFD)", x); \
} while (0)

d68 1
a68 1
	int i;
d75 1
a75 1
	if (evutil_socketpair(
d81 4
a84 2
	FD_CLOSEONEXEC(base->sig.ev_signal_pair[0]);
	FD_CLOSEONEXEC(base->sig.ev_signal_pair[1]);
d93 3
a95 1
        evutil_make_socket_nonblocking(base->sig.ev_signal_pair[0]);
d291 1
a291 1
		EVUTIL_CLOSESOCKET(base->sig.ev_signal_pair[0]);
d295 1
a295 1
		EVUTIL_CLOSESOCKET(base->sig.ev_signal_pair[1]);
@


1.21
log
@Remove #ifdef HAVE_.*_H, just include the header files.
Do not include sys/param.h.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.20 2014/10/16 07:38:06 bluhm Exp $	*/
a65 1
#ifdef HAVE_SETFD
a69 3
#else
#define FD_CLOSEONEXEC(x)
#endif
@


1.20
log
@Remove #ifdef HAVE_CONFIG_H, there is no config.h file.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.19 2014/10/08 20:14:19 bluhm Exp $	*/
a30 1
#ifdef HAVE_SYS_TIME_H
a31 1
#endif
a32 1
#ifdef HAVE_SYS_SOCKET_H
d34 1
a34 1
#endif
a38 1
#ifdef HAVE_UNISTD_H
a39 1
#endif
a40 1
#ifdef HAVE_FCNTL_H
a41 1
#endif
@


1.19
log
@iRemove the #ifdef WIN32 implementation from libevent.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.18 2014/10/08 05:41:42 deraadt Exp $	*/
a28 3
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
@


1.18
log
@use reallocarray() to detect multiplicative integer overflow; obvious
pattern.
This commit does not fix the non-obvious bloody horror of select.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.17 2014/10/06 21:16:03 bluhm Exp $	*/
a32 6
#ifdef WIN32
#define WIN32_LEAN_AND_MEAN
#include <winsock2.h>
#include <windows.h>
#undef WIN32_LEAN_AND_MEAN
#endif
a68 3
#ifdef WIN32
	SSIZE_T n;
#else
a69 1
#endif
a96 5
#ifdef WIN32
		/* Make this nonfatal on win32, where sometimes people
		   have localhost firewalled. */
		event_warn("%s: socketpair", __func__);
#else
a97 1
#endif
@


1.17
log
@Remove the #ifdef HAVE_SIGACTION from libevent.  The struct
evsignal_info does not change, so no library crank.
OK nicm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.16 2013/04/29 00:28:23 okan Exp $	*/
d155 1
a155 1
		p = realloc(sig->sh_old, new_max * sizeof(*sig->sh_old));
@


1.16
log
@use FD_CLOEXEC instead of 1; from David Hill

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.15 2010/07/12 18:03:38 nicm Exp $	*/
a142 1
#ifdef HAVE_SIGACTION
a143 3
#else
	ev_sighandler_t sh;
#endif
a175 1
#ifdef HAVE_SIGACTION
a186 9
#else
	if ((sh = signal(evsignal, handler)) == SIG_ERR) {
		event_warn("signal");
		free(sig->sh_old[evsignal]);
		sig->sh_old[evsignal] = NULL;
		return (-1);
	}
	*sig->sh_old[evsignal] = sh;
#endif
a228 1
#ifdef HAVE_SIGACTION
a229 3
#else
	ev_sighandler_t *sh;
#endif
a233 1
#ifdef HAVE_SIGACTION
a237 6
#else
	if (signal(evsignal, *sh) == SIG_ERR) {
		event_warn("signal");
		ret = -1;
	}
#endif
a276 4

#ifndef HAVE_SIGACTION
	signal(sig, evsignal_handler);
#endif
@


1.15
log
@Update to 1.4.14b.

From their change log:
 o Fix memory-leak of signal handler array with kqueue. [backport]
 o Make evutil_make_socket_nonblocking() leave any other flags alone.
 o Adjusted fcntl() retval comparison on evutil_make_socket_nonblocking().
 o Re-add event_siglcb; some old code _was_ still using it. :(
 o Fix a free(NULL) in min_heap.h
 o Clean up properly when adding a signal handler fails.

Also a local change to use an int rather than a long for fcntl().

ok guenther deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.14 2010/04/21 20:02:40 nicm Exp $	*/
d88 1
a88 1
        if (fcntl(x, F_SETFD, 1) == -1) \
@


1.14
log
@Update libevent to 1.4.13.

This is the core library only, the DNS parts are removed and it does not
include the other extra bits (HTTP, DNS, and RPC), a separate port for
these will appear in due course.

Thanks to jsg, sthen, alek, gilles, jacekm, bernd and any others I've
forgotten for testing/comments.

Note that /usr/include/evdns.h should be removed after updating.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.13 2010/01/10 00:36:35 guenther Exp $	*/
d189 1
d196 1
d351 8
a358 4
	EVUTIL_CLOSESOCKET(base->sig.ev_signal_pair[0]);
	base->sig.ev_signal_pair[0] = -1;
	EVUTIL_CLOSESOCKET(base->sig.ev_signal_pair[1]);
	base->sig.ev_signal_pair[1] = -1;
d362 4
a365 1
	free(base->sig.sh_old);
@


1.13
log
@Fix evsignal_del()'s use of sigaction(): fill in a sigaction struct
and pass a pointer to that instead of passing SIG_DFL directly.
(Probably the result of a bad signal()-->sigaction() translation...)

ok deraadt@@, nicm@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.12 2008/05/02 06:09:11 brad Exp $	*/
d33 6
a39 1
#include <sys/tree.h>
a41 2
#else
#include <sys/_time.h>
d44 1
d46 1
d51 1
d53 1
d63 1
d74 4
a77 2
	static char signals[100];
	struct event *ev = arg;
d79 1
d81 1
a81 1
	n = read(fd, signals, sizeof(signals));
a83 1
	event_add(ev, NULL);
d95 1
a95 1
void
d98 3
a100 1
	/*
d105 7
a111 1
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, base->sig.ev_signal_pair) == -1)
d113 3
d119 2
d123 3
d127 1
a127 1
	fcntl(base->sig.ev_signal_pair[0], F_SETFL, O_NONBLOCK);
d129 2
a130 2
	event_set(&base->sig.ev_signal, base->sig.ev_signal_pair[1], EV_READ,
	    evsignal_cb, &base->sig.ev_signal);
d133 68
a206 1
	struct sigaction sa;
d208 1
d213 19
d233 2
a234 6
	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = evsignal_handler;
	sigfillset(&sa.sa_mask);
	sa.sa_flags |= SA_RESTART;
	/* catch signals if they happen quickly */
	evsignal_base = base;
d236 10
a245 2
	if (sigaction(evsignal, &sa, NULL) == -1)
		return (-1);
d247 12
a258 3
	if (!base->sig.ev_signal_added) {
		base->sig.ev_signal_added = 1;
		event_add(&base->sig.ev_signal, NULL);
d260 2
d263 1
a263 1
	return (0);
d269 13
a281 1
	struct sigaction sa;
d283 1
a283 4
	memset(&sa, 0, sizeof(sa));
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = SIG_DFL;
	return (sigaction(EVENT_SIGNAL(ev), &sa, NULL));
d291 1
a291 1
	if(evsignal_base == NULL) {
d293 1
a293 1
			"%s: received signal %s, but have no base configured",
d301 4
d306 1
a306 1
	write(evsignal_base->sig.ev_signal_pair[0], "a", 1);
d313 2
a314 1
	struct event *ev;
d316 2
a317 1

d319 9
a327 3
	TAILQ_FOREACH(ev, &base->sig.signalqueue, ev_signal_next) {
		ncalls = base->sig.evsigcaught[EVENT_SIGNAL(ev)];
		if (ncalls) {
a330 1
			base->sig.evsigcaught[EVENT_SIGNAL(ev)] = 0;
d332 1
d339 2
a340 1
	if(base->sig.ev_signal_added) {
d344 4
a347 1
	assert(TAILQ_EMPTY(&base->sig.signalqueue));
d349 1
a349 1
	close(base->sig.ev_signal_pair[0]);
d351 1
a351 1
	close(base->sig.ev_signal_pair[1]);
d353 4
@


1.12
log
@Update to libevent 1.3e while retaining our local changes.

"No objection" millert@@
"the diff looks and works fine" reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.11 2007/03/19 15:12:49 millert Exp $	*/
d141 6
a146 1
	return (sigaction(EVENT_SIGNAL(ev),(struct sigaction *)SIG_DFL, NULL));
@


1.11
log
@Update to libevent-1.3b while retaining our local changes.  beck@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.10 2005/12/02 16:54:25 deraadt Exp $	*/
d34 1
d51 1
d54 1
d58 1
a58 1
extern struct event_list signalqueue;
d60 1
a60 7
static sig_atomic_t evsigcaught[NSIG];
static int needrecalc;
volatile sig_atomic_t evsignal_caught = 0;

static struct event ev_signal;
static int ev_signal_pair[2];
static int ev_signal_added;
d86 1
a86 1
evsignal_init(sigset_t *evsigmask)
a87 2
	sigemptyset(evsigmask);

d93 1
a93 1
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, ev_signal_pair) == -1)
d96 11
a106 8
	FD_CLOSEONEXEC(ev_signal_pair[0]);
	FD_CLOSEONEXEC(ev_signal_pair[1]);

	fcntl(ev_signal_pair[0], F_SETFL, O_NONBLOCK);

	event_set(&ev_signal, ev_signal_pair[1], EV_READ,
	    evsignal_cb, &ev_signal);
	ev_signal.ev_flags |= EVLIST_INTERNAL;
d110 1
a110 1
evsignal_add(sigset_t *evsigmask, struct event *ev)
d113 2
d119 15
a133 1
	sigaddset(evsigmask, evsignal);
a137 4
/*
 * Nothing to be done here.
 */

d139 1
a139 1
evsignal_del(sigset_t *evsigmask, struct event *ev)
a140 6
	int evsignal;

	evsignal = EVENT_SIGNAL(ev);
	sigdelset(evsigmask, evsignal);
	needrecalc = 1;

d149 9
a157 2
	evsigcaught[sig]++;
	evsignal_caught = 1;
d160 1
a160 1
	write(ev_signal_pair[0], "a", 1);
a163 41
int
evsignal_recalc(sigset_t *evsigmask)
{
	struct sigaction sa;
	struct event *ev;

	if (!ev_signal_added) {
		ev_signal_added = 1;
		event_add(&ev_signal, NULL);
	}

	if (TAILQ_FIRST(&signalqueue) == NULL && !needrecalc)
		return (0);
	needrecalc = 0;

	if (sigprocmask(SIG_BLOCK, evsigmask, NULL) == -1)
		return (-1);

	/* Reinstall our signal handler. */
	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = evsignal_handler;
	sa.sa_mask = *evsigmask;
	sa.sa_flags |= SA_RESTART;

	TAILQ_FOREACH(ev, &signalqueue, ev_signal_next) {
		if (sigaction(EVENT_SIGNAL(ev), &sa, NULL) == -1)
			return (-1);
	}
	return (0);
}

int
evsignal_deliver(sigset_t *evsigmask)
{
	if (TAILQ_FIRST(&signalqueue) == NULL)
		return (0);

	return (sigprocmask(SIG_UNBLOCK, evsigmask, NULL));
	/* XXX - pending signals handled here */
}

d165 1
a165 1
evsignal_process(void)
d170 3
a172 3
	evsignal_caught = 0;
	TAILQ_FOREACH(ev, &signalqueue, ev_signal_next) {
		ncalls = evsigcaught[EVENT_SIGNAL(ev)];
d177 1
a177 1
			evsigcaught[EVENT_SIGNAL(ev)] = 0;
d180 15
@


1.10
log
@make write-end of signal socketpair non-blocking.
every signal received writes 1 byte to the socketpair.  if you are outside
the libevent main loop too long, the socketpair might fill up.  that write
would then block, in a signal handler.  related to this, yesterdy we changed
the signal handler to not trash errno.
as for the read end, there will be multiple libevent reads off the socketpair
(100 bytes at a time) until the socketpair is empty again
ok provos
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.9 2005/12/02 04:14:03 deraadt Exp $	*/
d200 1
d207 1
a209 3

	memset(evsigcaught, 0, sizeof(evsigcaught));
	evsignal_caught = 0;
a210 1

@


1.9
log
@lookup out of evsigcaught[] must be sig_atomic_t too
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.8 2005/12/01 21:08:56 deraadt Exp $	*/
d103 2
@


1.8
log
@save errno in signal handler since it does a system call
only access sig_atomic_t variables, to make it further save
ok aaron
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.7 2005/07/02 07:15:13 grunk Exp $	*/
d196 1
a196 1
	short ncalls;
@


1.7
log
@zap trailing whitespaces, no binary change

ok brad@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.6 2005/04/22 00:56:25 brad Exp $	*/
d57 1
a57 1
static short evsigcaught[NSIG];
d66 2
a67 1
static void evsignal_cb(int fd, short what, void *arg)
d71 1
a71 1
	int n;
d141 2
d148 1
@


1.6
log
@update to libevent 1.0c; keep local changes

no shared lib so no ABI/API check is necessary

thanks to Alexander von Gernler for submitting
another diff in an attempt to update libevent
and for a use-after-free fix.

ok henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.4 2005/04/19 02:03:12 brad Exp $	*/
d92 1
a92 1
	/* 
@


1.5
log
@backout.  not discussed, and very wrong.  bad brad
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.3 2004/04/28 06:53:12 brad Exp $	*/
d40 1
d47 2
a48 7
#include <err.h>

#ifdef USE_LOG
#include "log.h"
#else
#define LOG_DBG(x)
#define log_error(x)	perror(x)
d53 1
d61 25
a85 3
void evsignal_process(void);
int evsignal_recalc(sigset_t *);
int evsignal_deliver(sigset_t *);
d91 15
d112 1
a112 1
	
d114 1
a114 1
		errx(1, "%s: EV_SIGNAL incompatible use", __func__);
d117 1
a117 1
	
d142 3
d153 5
d164 1
a164 1
	
d170 1
a170 1
	
@


1.4
log
@update to libevent 1.0c; keep local changes
@
text
@a39 1
#include <sys/socket.h>
d46 7
a52 2
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
a56 1
#include "log.h"
d64 3
a66 25
static struct event ev_signal;
static int ev_signal_pair[2];
static int ev_signal_added;

/* Callback for when the signal handler write a byte to our signaling socket */
static void evsignal_cb(int fd, short what, void *arg)
{
	static char signals[100];
	struct event *ev = arg;
	int n;

	n = read(fd, signals, sizeof(signals));
	if (n == -1)
		event_err(1, "%s: read", __func__);
	event_add(ev, NULL);
}

#ifdef HAVE_SETFD
#define FD_CLOSEONEXEC(x) do { \
        if (fcntl(x, F_SETFD, 1) == -1) \
                event_warn("fcntl(%d, F_SETFD)", x); \
} while (0)
#else
#define FD_CLOSEONEXEC(x)
#endif
a71 15

	/* 
	 * Our signal handler is going to write to one end of the socket
	 * pair to wake up our event loop.  The event loop then scans for
	 * signals that got delivered.
	 */
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, ev_signal_pair) == -1)
		event_err(1, "%s: socketpair", __func__);

	FD_CLOSEONEXEC(ev_signal_pair[0]);
	FD_CLOSEONEXEC(ev_signal_pair[1]);

	event_set(&ev_signal, ev_signal_pair[1], EV_READ,
	    evsignal_cb, &ev_signal);
	ev_signal.ev_flags |= EVLIST_INTERNAL;
d78 1
a78 1

d80 1
a80 1
		event_errx(1, "%s: EV_SIGNAL incompatible use", __func__);
d83 1
a83 1

a107 3

	/* Wake up our notification mechanism */
	write(ev_signal_pair[0], "a", 1);
a115 5
	if (!ev_signal_added) {
		ev_signal_added = 1;
		event_add(&ev_signal, NULL);
	}

d122 1
a122 1

d128 1
a128 1

@


1.3
log
@update to libevent 0.8; keep local changes

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: select.c,v 1.2 2002/06/25 15:50:15 mickey Exp $	*/
d40 1
d47 2
a48 7
#include <err.h>

#ifdef USE_LOG
#include "log.h"
#else
#define LOG_DBG(x)
#define log_error(x)	perror(x)
d53 1
d61 25
a85 3
void evsignal_process(void);
int evsignal_recalc(sigset_t *);
int evsignal_deliver(sigset_t *);
d91 15
d112 1
a112 1
	
d114 1
a114 1
		errx(1, "%s: EV_SIGNAL incompatible use", __func__);
d117 1
a117 1
	
d142 3
d153 5
d164 1
a164 1
	
d170 1
a170 1
	
@


1.2
log
@get rid of config.h; ok miod@@, millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signal.c,v 1.1 2003/07/09 10:54:38 markus Exp $	*/
d15 1
a15 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
d56 1
d77 1
a77 1
	int signal;
d81 2
a82 2
	signal = EVENT_SIGNAL(ev);
	sigaddset(evsigmask, signal);
d94 1
a94 1
	int signal;
d96 2
a97 2
	signal = EVENT_SIGNAL(ev);
	sigdelset(evsigmask, signal);
@


1.1
log
@update to libevent-0.7a.tar.gz; keep local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: select.c,v 1.2 2002/06/25 15:50:15 mickey Exp $	*/
d32 1
d34 1
@

