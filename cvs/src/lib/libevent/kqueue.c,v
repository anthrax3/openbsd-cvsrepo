head	1.39;
access;
symbols
	OPENBSD_6_1:1.39.0.4
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.28.0.14
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.12
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.8
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.6
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.4
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.2
	OPENBSD_5_0:1.26.0.6
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.24.0.6
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.8
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	EVENT00:1.1.1.1
	PROVOS00:1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2016.09.03.11.31.17;	author nayden;	state Exp;
branches;
next	1.38;
commitid	tdu5Eu69k0NPLcIY;

1.38
date	2015.12.25.17.10.05;	author tedu;	state Exp;
branches;
next	1.37;
commitid	NpxadQ0nP6czPlnI;

1.37
date	2015.12.16.20.12.31;	author tedu;	state Exp;
branches;
next	1.36;
commitid	X3MQUmGwJEIpURzB;

1.36
date	2014.10.30.16.45.37;	author bluhm;	state Exp;
branches;
next	1.35;
commitid	tunEM8ZR8ESfpNht;

1.35
date	2014.10.29.22.47.29;	author bluhm;	state Exp;
branches;
next	1.34;
commitid	FfV5qz960uDg9hP4;

1.34
date	2014.10.29.22.38.42;	author bluhm;	state Exp;
branches;
next	1.33;
commitid	rvapI8rPPqIjH5Pw;

1.33
date	2014.10.18.21.56.44;	author bluhm;	state Exp;
branches;
next	1.32;
commitid	XRrKg8ZEpC2CbWF4;

1.32
date	2014.10.18.16.48.28;	author bluhm;	state Exp;
branches;
next	1.31;
commitid	hi1FlfmD0UHtTfmr;

1.31
date	2014.10.17.19.16.01;	author bluhm;	state Exp;
branches;
next	1.30;
commitid	wDYYYW1I3umfP7v5;

1.30
date	2014.10.16.07.38.06;	author bluhm;	state Exp;
branches;
next	1.29;
commitid	Lmt85cKJJzyEtWLn;

1.29
date	2014.10.08.05.41.42;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	bIKEHDDuWEhznXtg;

1.28
date	2012.02.08.09.01.00;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2012.01.30.09.45.34;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.12.18.03.38;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2010.04.21.20.02.40;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2008.05.02.06.09.11;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.02.15.19.18;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.03.19.15.12.49;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.05.17.07.07;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.30.06.32.36;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.20.02.15.28;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.02.07.15.13;	author grunk;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.18.01.52.22;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.04.03.17.48;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.22.00.56.25;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.19.08.07.45;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.19.02.03.12;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.28.06.53.12;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.05.19.20.18;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.09.10.54.38;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.19.18.52.12;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.03.20.26.44;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.10.04.02.50;	author david;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.08.07.52.33;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.10.14.41.31;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.25.15.50.15;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.19.05.26.53;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.18.22.05.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.15.18.01.38;	author provos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.15.18.01.38;	author provos;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Remove NULL pointer checks before calls to free().
OK bluhm@@ nicm@@
@
text
@/*	$OpenBSD: kqueue.c,v 1.38 2015/12/25 17:10:05 tedu Exp $	*/

/*
 * Copyright 2000-2002 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/queue.h>
#include <sys/event.h>

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <assert.h>
#include <inttypes.h>

#include "event.h"
#include "event-internal.h"
#include "log.h"
#include "evsignal.h"

#define EVLIST_X_KQINKERNEL	0x1000

#define NEVENT		64

struct kqop {
	struct kevent *changes;
	int nchanges;
	struct kevent *events;
	struct event_list evsigevents[NSIG];
	int nevents;
	int kq;
	pid_t pid;
};

static void *kq_init	(struct event_base *);
static int kq_add	(void *, struct event *);
static int kq_del	(void *, struct event *);
static int kq_dispatch	(struct event_base *, void *, struct timeval *);
static int kq_insert	(struct kqop *, struct kevent *);
static void kq_dealloc (struct event_base *, void *);

const struct eventop kqops = {
	"kqueue",
	kq_init,
	kq_add,
	kq_del,
	kq_dispatch,
	kq_dealloc,
	1 /* need reinit */
};

static void *
kq_init(struct event_base *base)
{
	int i, kq;
	struct kqop *kqueueop;

	/* Disable kqueue when this environment variable is set */
	if (!issetugid() && getenv("EVENT_NOKQUEUE"))
		return (NULL);

	if (!(kqueueop = calloc(1, sizeof(struct kqop))))
		return (NULL);

	/* Initalize the kernel queue */

	if ((kq = kqueue()) == -1) {
		event_warn("kqueue");
		free (kqueueop);
		return (NULL);
	}

	kqueueop->kq = kq;

	kqueueop->pid = getpid();

	/* Initalize fields */
	kqueueop->changes = calloc(NEVENT, sizeof(struct kevent));
	if (kqueueop->changes == NULL) {
		free (kqueueop);
		return (NULL);
	}
	kqueueop->events = calloc(NEVENT, sizeof(struct kevent));
	if (kqueueop->events == NULL) {
		free (kqueueop->changes);
		free (kqueueop);
		return (NULL);
	}
	kqueueop->nevents = NEVENT;

	/* we need to keep track of multiple events per signal */
	for (i = 0; i < NSIG; ++i) {
		TAILQ_INIT(&kqueueop->evsigevents[i]);
	}

	return (kqueueop);
}

static int
kq_insert(struct kqop *kqop, struct kevent *kev)
{
	int nevents = kqop->nevents;

	if (kqop->nchanges == nevents) {
		struct kevent *newchange;
		struct kevent *newresult;

		nevents *= 2;

		newchange = reallocarray(kqop->changes,
		    nevents, sizeof(struct kevent));
		if (newchange == NULL) {
			event_warn("%s: malloc", __func__);
			return (-1);
		}
		kqop->changes = newchange;

		newresult = reallocarray(kqop->events,
		    nevents, sizeof(struct kevent));

		/*
		 * If we fail, we don't have to worry about freeing,
		 * the next realloc will pick it up.
		 */
		if (newresult == NULL) {
			event_warn("%s: malloc", __func__);
			return (-1);
		}
		kqop->events = newresult;

		kqop->nevents = nevents;
	}

	memcpy(&kqop->changes[kqop->nchanges++], kev, sizeof(struct kevent));

	event_debug(("%s: fd %d %s%s",
		__func__, (int)kev->ident,
		kev->filter == EVFILT_READ ? "EVFILT_READ" : "EVFILT_WRITE",
		kev->flags == EV_DELETE ? " (del)" : ""));

	return (0);
}

static void
kq_sighandler(int sig)
{
	/* Do nothing here */
}

static int
kq_dispatch(struct event_base *base, void *arg, struct timeval *tv)
{
	struct kqop *kqop = arg;
	struct kevent *changes = kqop->changes;
	struct kevent *events = kqop->events;
	struct event *ev;
	struct timespec ts, *ts_p = NULL;
	int i, res;

	if (tv != NULL) {
		TIMEVAL_TO_TIMESPEC(tv, &ts);
		ts_p = &ts;
	}

	res = kevent(kqop->kq, changes, kqop->nchanges,
	    events, kqop->nevents, ts_p);
	kqop->nchanges = 0;
	if (res == -1) {
		if (errno != EINTR) {
			event_warn("kevent");
			return (-1);
		}

		return (0);
	}

	event_debug(("%s: kevent reports %d", __func__, res));

	for (i = 0; i < res; i++) {
		int which = 0;

		if (events[i].flags & EV_ERROR) {
			switch (events[i].data) {

			/* Can occur on delete if we are not currently
			 * watching any events on this fd.  That can
			 * happen when the fd was closed and another
			 * file was opened with that fd. */
			case ENOENT:
			/* Can occur for reasons not fully understood
			 * on FreeBSD. */
			case EINVAL:
				continue;
			/* Can occur on a delete if the fd is closed.  Can
			 * occur on an add if the fd was one side of a pipe,
			 * and the other side was closed. */
			case EBADF:
				continue;
			/* These two can occur on an add if the fd was one side
			 * of a pipe, and the other side was closed. */
			case EPERM:
			case EPIPE:
				/* Report read events, if we're listening for
				 * them, so that the user can learn about any
				 * add errors.  (If the operation was a
				 * delete, then udata should be cleared.) */
				if (events[i].udata) {
					/* The operation was an add:
					 * report the error as a read. */
					which |= EV_READ;
					break;
				} else {
					/* The operation was a del:
					 * report nothing. */
					continue;
				}

			/* Other errors shouldn't occur. */
			default:
				errno = events[i].data;
				return (-1);
			}
		} else if (events[i].filter == EVFILT_READ) {
			which |= EV_READ;
		} else if (events[i].filter == EVFILT_WRITE) {
			which |= EV_WRITE;
		} else if (events[i].filter == EVFILT_SIGNAL) {
			which |= EV_SIGNAL;
		}

		if (!which)
			continue;

		if (events[i].filter == EVFILT_SIGNAL) {
			struct event_list *head =
			    (struct event_list *)events[i].udata;
			TAILQ_FOREACH(ev, head, ev_signal_next) {
				event_active(ev, which, events[i].data);
			}
		} else {
			ev = (struct event *)events[i].udata;

			if (!(ev->ev_events & EV_PERSIST))
				ev->ev_flags &= ~EVLIST_X_KQINKERNEL;

			event_active(ev, which, 1);
		}
	}

	return (0);
}


static int
kq_add(void *arg, struct event *ev)
{
	struct kqop *kqop = arg;
	struct kevent kev;

	if (ev->ev_events & EV_SIGNAL) {
		int nsignal = EVENT_SIGNAL(ev);

		assert(nsignal >= 0 && nsignal < NSIG);
		if (TAILQ_EMPTY(&kqop->evsigevents[nsignal])) {
			struct timespec timeout = { 0, 0 };

			memset(&kev, 0, sizeof(kev));
			kev.ident = nsignal;
			kev.filter = EVFILT_SIGNAL;
			kev.flags = EV_ADD;
			kev.udata = &kqop->evsigevents[nsignal];

			/* Be ready for the signal if it is sent any
			 * time between now and the next call to
			 * kq_dispatch. */
			if (kevent(kqop->kq, &kev, 1, NULL, 0, &timeout) == -1)
				return (-1);

			if (_evsignal_set_handler(ev->ev_base, nsignal,
				kq_sighandler) == -1)
				return (-1);
		}

		TAILQ_INSERT_TAIL(&kqop->evsigevents[nsignal], ev,
		    ev_signal_next);
		ev->ev_flags |= EVLIST_X_KQINKERNEL;
		return (0);
	}

	if (ev->ev_events & EV_READ) {
		memset(&kev, 0, sizeof(kev));
		kev.ident = ev->ev_fd;
		kev.filter = EVFILT_READ;
		/* Make it behave like select() and poll() */
		kev.fflags = NOTE_EOF;
		kev.flags = EV_ADD;
		if (!(ev->ev_events & EV_PERSIST))
			kev.flags |= EV_ONESHOT;
		kev.udata = ev;

		if (kq_insert(kqop, &kev) == -1)
			return (-1);

		ev->ev_flags |= EVLIST_X_KQINKERNEL;
	}

	if (ev->ev_events & EV_WRITE) {
		memset(&kev, 0, sizeof(kev));
		kev.ident = ev->ev_fd;
		kev.filter = EVFILT_WRITE;
		kev.flags = EV_ADD;
		if (!(ev->ev_events & EV_PERSIST))
			kev.flags |= EV_ONESHOT;
		kev.udata = ev;

		if (kq_insert(kqop, &kev) == -1)
			return (-1);

		ev->ev_flags |= EVLIST_X_KQINKERNEL;
	}

	return (0);
}

static int
kq_del(void *arg, struct event *ev)
{
	struct kqop *kqop = arg;
	struct kevent kev;

	if (!(ev->ev_flags & EVLIST_X_KQINKERNEL))
		return (0);

	if (ev->ev_events & EV_SIGNAL) {
		int nsignal = EVENT_SIGNAL(ev);
		struct timespec timeout = { 0, 0 };

		assert(nsignal >= 0 && nsignal < NSIG);
		TAILQ_REMOVE(&kqop->evsigevents[nsignal], ev, ev_signal_next);
		if (TAILQ_EMPTY(&kqop->evsigevents[nsignal])) {
			memset(&kev, 0, sizeof(kev));
			kev.ident = nsignal;
			kev.filter = EVFILT_SIGNAL;
			kev.flags = EV_DELETE;

			/* Because we insert signal events
			 * immediately, we need to delete them
			 * immediately, too */
			if (kevent(kqop->kq, &kev, 1, NULL, 0, &timeout) == -1)
				return (-1);

			if (_evsignal_restore_handler(ev->ev_base,
				nsignal) == -1)
				return (-1);
		}

		ev->ev_flags &= ~EVLIST_X_KQINKERNEL;
		return (0);
	}

	if (ev->ev_events & EV_READ) {
		memset(&kev, 0, sizeof(kev));
		kev.ident = ev->ev_fd;
		kev.filter = EVFILT_READ;
		kev.flags = EV_DELETE;

		if (kq_insert(kqop, &kev) == -1)
			return (-1);

		ev->ev_flags &= ~EVLIST_X_KQINKERNEL;
	}

	if (ev->ev_events & EV_WRITE) {
		memset(&kev, 0, sizeof(kev));
		kev.ident = ev->ev_fd;
		kev.filter = EVFILT_WRITE;
		kev.flags = EV_DELETE;

		if (kq_insert(kqop, &kev) == -1)
			return (-1);

		ev->ev_flags &= ~EVLIST_X_KQINKERNEL;
	}

	return (0);
}

static void
kq_dealloc(struct event_base *base, void *arg)
{
	struct kqop *kqop = arg;

	evsignal_dealloc(base);

	free(kqop->changes);
	free(kqop->events);
	if (kqop->kq >= 0 && kqop->pid == getpid())
		close(kqop->kq);

	memset(kqop, 0, sizeof(struct kqop));
	free(kqop);
}
@


1.38
log
@revert change to call kevent immediately.
tcpbench (at a minimum) relies on the old behavior of changes all happening
after all event handlers run. in particular, it resets the event for the
listening socket *before* calling accept(), when it is still readable.
kevent then (correctly) says it is readable on the next go through the loop.
silly, subtle, and stupid.
problem reported by kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.36 2014/10/30 16:45:37 bluhm Exp $	*/
d423 2
a424 4
	if (kqop->changes)
		free(kqop->changes);
	if (kqop->events)
		free(kqop->events);
@


1.37
log
@change the kqueue backend to call kevent() as events are added instead
of deferring until the dispatch loop. kqueue support for various types
of files and filesystems has been historically incomplete, and kevent
handles this condition by returning an error. the libevent dispatch
loop has no way to recover from this error and fails catastrophically,
bringing down the entire process because one file went bad.
now, instead of all that happending, event_add will return an error. the
application can choose to handle or ignore this error, but at least the
band will play on.
ok nicm
@
text
@d54 2
d67 1
d106 5
d113 1
d127 45
d182 1
d193 3
a195 1
	res = kevent(kqop->kq, NULL, 0, events, kqop->nevents, ts_p);
d329 1
a329 1
		if (kevent(kqop->kq, &kev, 1, NULL, 0, NULL) == -1)
d344 1
a344 1
		if (kevent(kqop->kq, &kev, 1, NULL, 0, NULL) == -1)
d395 1
a395 1
		if (kevent(kqop->kq, &kev, 1, NULL, 0, NULL) == -1)
d407 1
a407 1
		if (kevent(kqop->kq, &kev, 1, NULL, 0, NULL) == -1)
d423 2
@


1.36
log
@Fix whitespace errors in libevent.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.35 2014/10/29 22:47:29 bluhm Exp $	*/
a53 2
	struct kevent *changes;
	int nchanges;
a64 1
static int kq_insert	(struct kqop *, struct kevent *);
a102 5
	kqueueop->changes = calloc(NEVENT, sizeof(struct kevent));
	if (kqueueop->changes == NULL) {
		free (kqueueop);
		return (NULL);
	}
a104 1
		free (kqueueop->changes);
a117 45
static int
kq_insert(struct kqop *kqop, struct kevent *kev)
{
	int nevents = kqop->nevents;

	if (kqop->nchanges == nevents) {
		struct kevent *newchange;
		struct kevent *newresult;

		nevents *= 2;

		newchange = reallocarray(kqop->changes,
		    nevents, sizeof(struct kevent));
		if (newchange == NULL) {
			event_warn("%s: malloc", __func__);
			return (-1);
		}
		kqop->changes = newchange;

		newresult = reallocarray(kqop->events,
		    nevents, sizeof(struct kevent));

		/*
		 * If we fail, we don't have to worry about freeing,
		 * the next realloc will pick it up.
		 */
		if (newresult == NULL) {
			event_warn("%s: malloc", __func__);
			return (-1);
		}
		kqop->events = newresult;

		kqop->nevents = nevents;
	}

	memcpy(&kqop->changes[kqop->nchanges++], kev, sizeof(struct kevent));

	event_debug(("%s: fd %d %s%s",
		__func__, (int)kev->ident,
		kev->filter == EVFILT_READ ? "EVFILT_READ" : "EVFILT_WRITE",
		kev->flags == EV_DELETE ? " (del)" : ""));

	return (0);
}

a127 1
	struct kevent *changes = kqop->changes;
d138 1
a138 3
	res = kevent(kqop->kq, changes, kqop->nchanges,
	    events, kqop->nevents, ts_p);
	kqop->nchanges = 0;
d272 1
a272 1
		if (kq_insert(kqop, &kev) == -1)
d287 1
a287 1
		if (kq_insert(kqop, &kev) == -1)
d338 1
a338 1
		if (kq_insert(kqop, &kev) == -1)
d350 1
a350 1
		if (kq_insert(kqop, &kev) == -1)
a365 2
	if (kqop->changes)
		free(kqop->changes);
@


1.35
log
@After removing all the #ifdef, the wrappers in evutil are rather
useless.  Let libevent call the libc functions directly.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.34 2014/10/29 22:38:42 bluhm Exp $	*/
d94 1
a94 1
	
d165 1
a165 1
		__func__, (int)kev->ident, 
d198 1
a198 1
                        event_warn("kevent");
d294 1
a294 1
			
d300 1
a300 1
			
d319 1
a319 1
 		memset(&kev, 0, sizeof(kev));
d328 1
a328 1
		
d336 1
a336 1
 		memset(&kev, 0, sizeof(kev));
d343 1
a343 1
		
d373 1
a373 1
		
d390 1
a390 1
 		memset(&kev, 0, sizeof(kev));
d394 1
a394 1
		
d402 1
a402 1
 		memset(&kev, 0, sizeof(kev));
d406 1
a406 1
		
@


1.34
log
@Remove workaround for Mac OS X kqueue bug.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.33 2014/10/18 21:56:44 bluhm Exp $	*/
d87 1
a87 1
	if (evutil_getenv("EVENT_NOKQUEUE"))
@


1.33
log
@Remove some #ifdef from libevent.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.32 2014/10/18 16:48:28 bluhm Exp $	*/
a121 21
	}

	/* Check for Mac OS X kqueue bug. */
	kqueueop->changes[0].ident = -1;
	kqueueop->changes[0].filter = EVFILT_READ;
	kqueueop->changes[0].flags = EV_ADD;
	/* 
	 * If kqueue works, then kevent will succeed, and it will
	 * stick an error in events[0].  If kqueue is broken, then
	 * kevent will fail.
	 */
	if (kevent(kq,
		kqueueop->changes, 1, kqueueop->events, NEVENT, NULL) != 1 ||
	    kqueueop->events[0].ident != -1 ||
	    kqueueop->events[0].flags != EV_ERROR) {
		event_warn("%s: detected broken kqueue; not using.", __func__);
		free(kqueueop->changes);
		free(kqueueop->events);
		free(kqueueop);
		close(kq);
		return (NULL);
@


1.32
log
@Remove the remaining #ifdef HAVE_ and the #define _GNU_SOURCE.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.31 2014/10/17 19:16:01 bluhm Exp $	*/
a43 9
/* Some platforms apparently define the udata field of struct kevent as
 * intptr_t, whereas others define it as void*.  There doesn't seem to be an
 * easy way to tell them apart via autoconf, so we need to use OS macros. */
#if !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__darwin__) && !defined(__APPLE__)
#define PTR_TO_UDATA(x)	((intptr_t)(x))
#else
#define PTR_TO_UDATA(x)	(x)
#endif

d320 1
a320 1
			kev.udata = PTR_TO_UDATA(&kqop->evsigevents[nsignal]);
a342 1
#ifdef NOTE_EOF
a344 1
#endif
d348 1
a348 1
		kev.udata = PTR_TO_UDATA(ev);
d363 1
a363 1
		kev.udata = PTR_TO_UDATA(ev);
@


1.31
log
@Remove #ifdef HAVE_.*_H, just include the header files.
Do not include sys/param.h.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.30 2014/10/16 07:38:06 bluhm Exp $	*/
a28 2

#define _GNU_SOURCE 1
@


1.30
log
@Remove #ifdef HAVE_CONFIG_H, there is no config.h file.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.29 2014/10/08 05:41:42 deraadt Exp $	*/
a32 1
#ifdef HAVE_SYS_TIME_H
a33 3
#else
#include <sys/_libevent_time.h>
#endif
d36 1
a43 1
#ifdef HAVE_INTTYPES_H
a44 1
#endif
d49 1
a49 1
#if defined(HAVE_INTTYPES_H) && !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__darwin__) && !defined(__APPLE__)
@


1.29
log
@use reallocarray() to detect multiplicative integer overflow; obvious
pattern.
This commit does not fix the non-obvious bloody horror of select.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.28 2012/02/08 09:01:00 nicm Exp $	*/
a28 3
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
@


1.28
log
@r1.27 changed libevent to fire a read event when kqueue returned EBADF
(and several other things, particularly EPIPE) on a file
descriptor. This causes Google Chrome to die (probably due to a bug in
Chrome but finding that is next to impossible at the moment).

It's not really clear what libevent should when an invalid fd is added -
the poll backend doesn't fire an event and select exits the event
loop. Until this is settled, change kqueue to match poll and ignore
EBADF, keeping the behaviour r1.27 fixed on EPIPE.

Fix from robert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.27 2012/01/30 09:45:34 nicm Exp $	*/
d178 2
a179 2
		newchange = realloc(kqop->changes,
				    nevents * sizeof(struct kevent));
d186 2
a187 2
		newresult = realloc(kqop->events,
				    nevents * sizeof(struct kevent));
@


1.27
log
@Handle a wider range of kqueue error return values for an event,
prevents libevent exiting the event loop when getting EPIPE. Problem
first seen by drahn@@ and more recently hit by gilles@@, fix based on one
by Nick Mathewson.

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.26 2010/07/12 18:03:38 nicm Exp $	*/
d266 1
@


1.26
log
@Update to 1.4.14b.

From their change log:
 o Fix memory-leak of signal handler array with kqueue. [backport]
 o Make evutil_make_socket_nonblocking() leave any other flags alone.
 o Adjusted fcntl() retval comparison on evutil_make_socket_nonblocking().
 o Re-add event_siglcb; some old code _was_ still using it. :(
 o Fix a free(NULL) in min_heap.h
 o Clean up properly when adding a signal handler fails.

Also a local change to use an int rather than a long for fcntl().

ok guenther deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.25 2010/04/21 20:02:40 nicm Exp $	*/
d251 10
a260 15
			/* 
			 * Error messages that can happen, when a delete fails.
			 *   EBADF happens when the file discriptor has been
			 *   closed,
			 *   ENOENT when the file discriptor was closed and
			 *   then reopened.
			 *   EINVAL for some reasons not understood; EINVAL
			 *   should not be returned ever; but FreeBSD does :-\
			 * An error is also indicated when a callback deletes
			 * an event we are still processing.  In that case
			 * the data field is set to ENOENT.
			 */
			if (events[i].data == EBADF ||
			    events[i].data == EINVAL ||
			    events[i].data == ENOENT)
d262 29
a290 5
			errno = events[i].data;
			return (-1);
		}

		if (events[i].filter == EVFILT_READ) {
@


1.25
log
@Update libevent to 1.4.13.

This is the core library only, the DNS parts are removed and it does not
include the other extra bits (HTTP, DNS, and RPC), a separate port for
these will appear in due course.

Thanks to jsg, sthen, alek, gilles, jacekm, bernd and any others I've
forgotten for testing/comments.

Note that /usr/include/evdns.h should be removed after updating.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.24 2008/05/02 06:09:11 brad Exp $	*/
d66 1
d291 2
a292 2
		if (!(ev->ev_events & EV_PERSIST))
			ev->ev_flags &= ~EVLIST_X_KQINKERNEL;
d443 2
d451 1
@


1.24
log
@Update to libevent 1.3e while retaining our local changes.

"No objection" millert@@
"the diff looks and works fine" reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.23 2007/09/02 15:19:18 deraadt Exp $	*/
d33 2
d39 1
a39 1
#include <sys/_time.h>
d49 1
d55 1
a55 1
 * ntptr_t, whereas others define it as void*.  There doesn't seem to be an
d58 1
a58 1
#define PTR_TO_UDATA(x) ((intptr_t)(x))
d60 1
a60 1
#define PTR_TO_UDATA(x) (x)
d64 1
d75 1
d78 1
d81 6
a86 7
void *kq_init	(struct event_base *);
int kq_add	(void *, struct event *);
int kq_del	(void *, struct event *);
int kq_recalc	(struct event_base *, void *, int);
int kq_dispatch	(struct event_base *, void *, struct timeval *);
int kq_insert	(struct kqop *, struct kevent *);
void kq_dealloc (struct event_base *, void *);
a92 1
	kq_recalc,
d94 2
a95 1
	kq_dealloc
d98 1
a98 1
void *
d101 1
a101 1
	int kq;
d105 1
a105 1
	if (!issetugid() && getenv("EVENT_NOKQUEUE"))
d112 1
a112 1

d121 2
d137 5
d146 1
a146 1
	/*
d166 1
a166 7
int
kq_recalc(struct event_base *base, void *arg, int max)
{
	return (0);
}

int
d204 3
a206 3
		 __func__, kev->ident,
		 kev->filter == EVFILT_READ ? "EVFILT_READ" : "EVFILT_WRITE",
		 kev->flags == EV_DELETE ? " (del)" : ""));
d217 1
a217 1
int
d250 1
a250 1
			/*
a269 2
		ev = (struct event *)events[i].udata;

d281 9
d291 1
a291 1
			event_del(ev);
d293 2
a294 2
		event_active(ev, which,
		    ev->ev_events & EV_SIGNAL ? events[i].data : 1);
d301 1
a301 1
int
d310 20
a329 13
 		memset(&kev, 0, sizeof(kev));
		kev.ident = nsignal;
		kev.filter = EVFILT_SIGNAL;
		kev.flags = EV_ADD;
		if (!(ev->ev_events & EV_PERSIST))
			kev.flags |= EV_ONESHOT;
		kev.udata = PTR_TO_UDATA(ev);

		if (kq_insert(kqop, &kev) == -1)
			return (-1);

		if (signal(nsignal, kq_sighandler) == SIG_ERR)
			return (-1);
d331 2
d349 1
a349 1

d364 1
a364 1

d374 1
a374 1
int
d385 1
d387 18
a404 10
 		memset(&kev, 0, sizeof(kev));
		kev.ident = nsignal;
		kev.filter = EVFILT_SIGNAL;
		kev.flags = EV_DELETE;

		if (kq_insert(kqop, &kev) == -1)
			return (-1);

		if (signal(nsignal, SIG_DFL) == SIG_ERR)
			return (-1);
d415 1
a415 1

d427 1
a427 1

d437 1
a437 1
void
d446 1
a446 1
	if (kqop->kq)
@


1.23
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.22 2007/03/19 15:12:49 millert Exp $	*/
d51 5
a55 2
#if defined(HAVE_INTTYPES_H) && !defined(__OpenBSD__) && !defined(__FreeBSD__)
#define INTPTR(x)	(intptr_t)x
d57 1
a57 1
#define INTPTR(x)	x
d75 1
a75 1
void *kq_init	(void);
d81 1
a81 1
void kq_dealloc (void *);
d94 1
a94 1
kq_init(void)
d218 1
a218 1
	struct timespec ts;
d221 4
a224 1
	TIMEVAL_TO_TIMESPEC(tv, &ts);
d227 1
a227 1
	    events, kqop->nevents, &ts);
d303 1
a303 1
		kev.udata = INTPTR(ev);
d326 1
a326 1
		kev.udata = INTPTR(ev);
d341 1
a341 1
		kev.udata = INTPTR(ev);
d407 1
a407 1
kq_dealloc(void *arg)
@


1.22
log
@Update to libevent-1.3b while retaining our local changes.  beck@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.21 2006/11/05 17:07:07 brad Exp $	*/
d114 1
a114 1
	kqueueop->changes = malloc(NEVENT * sizeof(struct kevent));
d119 1
a119 1
	kqueueop->events = malloc(NEVENT * sizeof(struct kevent));
@


1.21
log
@typo in kqueue delete.

From Niels Provos via the libevent SVN repo, by Bert JW. Regeer

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.20 2006/03/30 06:32:36 brad Exp $	*/
d104 1
a104 1
	
d298 1
a298 1
		
d321 1
a321 1
		
d336 1
a336 1
		
d362 1
a362 1
		
d378 1
a378 1
		
d390 1
a390 1
		
@


1.20
log
@introduce a way to free the base.

From libevent CVS
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.19 2005/12/20 02:15:28 brad Exp $	*/
d359 1
a359 1
		kev.ident = (int)signal;
@


1.19
log
@do not remove kq inkernel flag before event_del gets to it;

From libevent CVS

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.18 2005/07/02 07:15:13 grunk Exp $	*/
d78 1
d86 2
a87 1
	kq_dispatch
d398 15
@


1.18
log
@zap trailing whitespaces, no binary change

ok brad@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.17 2005/06/18 01:52:22 brad Exp $	*/
d269 1
a269 2
		if (!(ev->ev_events & EV_PERSIST)) {
			ev->ev_flags &= ~EVLIST_X_KQINKERNEL;
a270 1
		}
@


1.17
log
@update to libevent 1.1a; keep local changes

ok grunk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.16 2005/05/04 03:17:48 brad Exp $	*/
d129 1
a129 1
	/* 
d193 1
a193 1
		 __func__, kev->ident, 
d236 1
a236 1
			/* 
@


1.16
log
@update to libevent 1.0d; keep local changes

thanks to Alexander von Gernler for testing
and some bug fixes

ok mpf@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.15 2005/04/22 00:56:25 brad Exp $	*/
d125 21
d242 2
d249 1
@


1.15
log
@update to libevent 1.0c; keep local changes

no shared lib so no ABI/API check is necessary

thanks to Alexander von Gernler for submitting
another diff in an attempt to update libevent
and for a use-after-free fix.

ok henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.13 2005/04/19 02:03:12 brad Exp $	*/
d228 1
@


1.14
log
@backout.  not discussed, and very wrong.  bad brad
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.12 2004/04/28 06:53:12 brad Exp $	*/
a46 1
#include <err.h>
d51 1
a51 8
#ifdef USE_LOG
#include "log.h"
#else
#define LOG_DBG(x)
#define log_error	warn
#endif

#if defined(HAVE_INTTYPES_H) && !defined(__OpenBSD__)
d58 1
a58 4

extern struct event_list timequeue;
extern struct event_list eventqueue;
extern struct event_list addqueue;
d70 1
a70 1
} kqueueop;
d75 2
a76 2
int kq_recalc	(void *, int);
int kq_dispatch	(void *, struct timeval *);
d92 1
d98 2
a99 1
	memset(&kqueueop, 0, sizeof(kqueueop));
d104 2
a105 1
		log_error("kqueue");
d109 1
a109 1
	kqueueop.kq = kq;
d112 3
a114 2
	kqueueop.changes = malloc(NEVENT * sizeof(struct kevent));
	if (kqueueop.changes == NULL)
d116 5
a120 3
	kqueueop.events = malloc(NEVENT * sizeof(struct kevent));
	if (kqueueop.events == NULL) {
		free (kqueueop.changes);
d123 1
a123 1
	kqueueop.nevents = NEVENT;
d125 1
a125 1
	return (&kqueueop);
d129 1
a129 1
kq_recalc(void *arg, int max)
d148 1
a148 1
			log_error("%s: malloc", __func__);
d161 1
a161 1
			log_error("%s: malloc", __func__);
d171 1
a171 1
	LOG_DBG((LOG_MISC, 70, "%s: fd %d %s%s",
d186 1
a186 1
kq_dispatch(void *arg, struct timeval *tv)
d202 1
a202 1
			log_error("kevent");
d209 1
a209 1
	LOG_DBG((LOG_MISC, 80, "%s: kevent reports %d", __func__, res));
@


1.13
log
@update to libevent 1.0c; keep local changes
@
text
@d47 1
d52 8
a59 1
#if defined(HAVE_INTTYPES_H) && !defined(__OpenBSD__) && !defined(__FreeBSD__)
d66 4
a69 1
#include "log.h"
d81 1
a81 1
};
d86 2
a87 2
int kq_recalc	(struct event_base *, void *, int);
int kq_dispatch	(struct event_base *, void *, struct timeval *);
a102 1
	struct kqop *kqueueop;
d108 1
a108 2
	if (!(kqueueop = calloc(1, sizeof(struct kqop))))
		return (NULL);
d113 1
a113 2
		event_warn("kqueue");
		free (kqueueop);
d117 1
a117 1
	kqueueop->kq = kq;
d120 2
a121 3
	kqueueop->changes = malloc(NEVENT * sizeof(struct kevent));
	if (kqueueop->changes == NULL) {
		free (kqueueop);
d123 3
a125 5
	}
	kqueueop->events = malloc(NEVENT * sizeof(struct kevent));
	if (kqueueop->events == NULL) {
		free (kqueueop->changes);
		free (kqueueop);
d128 1
a128 1
	kqueueop->nevents = NEVENT;
d130 1
a130 1
	return (kqueueop);
d134 1
a134 1
kq_recalc(struct event_base *base, void *arg, int max)
d153 1
a153 1
			event_warn("%s: malloc", __func__);
d166 1
a166 1
			event_warn("%s: malloc", __func__);
d176 1
a176 1
	event_debug(("%s: fd %d %s%s",
d191 1
a191 1
kq_dispatch(struct event_base *base, void *arg, struct timeval *tv)
d207 1
a207 1
                        event_warn("kevent");
d214 1
a214 1
	event_debug(("%s: kevent reports %d", __func__, res));
@


1.12
log
@update to libevent 0.8; keep local changes

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.5 2002/07/10 14:41:31 art Exp $	*/
a46 1
#include <err.h>
d51 1
a51 8
#ifdef USE_LOG
#include "log.h"
#else
#define LOG_DBG(x)
#define log_error	warn
#endif

#if defined(HAVE_INTTYPES_H) && !defined(__OpenBSD__)
d58 1
a58 4

extern struct event_list timequeue;
extern struct event_list eventqueue;
extern struct event_list addqueue;
d70 1
a70 1
} kqueueop;
d75 2
a76 2
int kq_recalc	(void *, int);
int kq_dispatch	(void *, struct timeval *);
d92 1
d98 2
a99 1
	memset(&kqueueop, 0, sizeof(kqueueop));
d104 2
a105 1
		log_error("kqueue");
d109 1
a109 1
	kqueueop.kq = kq;
d112 3
a114 2
	kqueueop.changes = malloc(NEVENT * sizeof(struct kevent));
	if (kqueueop.changes == NULL)
d116 5
a120 3
	kqueueop.events = malloc(NEVENT * sizeof(struct kevent));
	if (kqueueop.events == NULL) {
		free (kqueueop.changes);
d123 1
a123 1
	kqueueop.nevents = NEVENT;
d125 1
a125 1
	return (&kqueueop);
d129 1
a129 1
kq_recalc(void *arg, int max)
d148 1
a148 1
			log_error("%s: malloc", __func__);
d161 1
a161 1
			log_error("%s: malloc", __func__);
d171 1
a171 1
	LOG_DBG((LOG_MISC, 70, "%s: fd %d %s%s",
d186 1
a186 1
kq_dispatch(void *arg, struct timeval *tv)
d202 1
a202 1
			log_error("kevent");
d209 1
a209 1
	LOG_DBG((LOG_MISC, 80, "%s: kevent reports %d", __func__, res));
@


1.11
log
@support NOTE_EOF; from marius aamodt eriksen; ok tedu, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.10 2003/07/09 10:54:38 markus Exp $	*/
d15 1
a15 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
d59 1
a59 1
#ifdef HAVE_INTTYPES_H
d81 1
a81 1
} kqop;
d88 1
d108 1
a108 1
	memset(&kqop, 0, sizeof(kqop));
d110 1
a110 1
	/* Initialize the kernel queue */
d117 1
a117 1
	kqop.kq = kq;
d119 3
a121 3
	/* Initialize fields */
	kqop.changes = malloc(NEVENT * sizeof(struct kevent));
	if (kqop.changes == NULL)
d123 3
a125 3
	kqop.events = malloc(NEVENT * sizeof(struct kevent));
	if (kqop.events == NULL) {
		free (kqop.changes);
d128 1
a128 1
	kqop.nevents = NEVENT;
d130 1
a130 1
	return (&kqop);
d158 1
a158 1
		newresult = realloc(kqop->changes,
d169 1
a169 1
		kqop->events = newchange;
d293 1
a293 1
		kev.flags = EV_ADD;
d296 2
@


1.10
log
@update to libevent-0.7a.tar.gz; keep local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.9 2003/06/19 18:52:12 mickey Exp $	*/
d296 2
@


1.9
log
@constify constant structures; niels ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.8 2003/06/03 20:26:44 deraadt Exp $	*/
d32 1
d34 1
d37 1
d39 3
d50 4
d59 7
a65 1
#define log_error(x)	perror(x)
d107 1
a107 1
	if (issetugid() == 0 && getenv("EVENT_NOKQUEUE"))
d155 1
a155 1
			log_error(__FUNCTION__": malloc");
d168 1
a168 1
			log_error(__FUNCTION__": malloc");
d178 2
a179 2
	LOG_DBG((LOG_MISC, 70, __FUNCTION__": fd %d %s%s",
		 kev->ident, 
d205 1
a205 1
		     events, kqop->nevents, &ts);
d216 1
a216 1
	LOG_DBG((LOG_MISC, 80, __FUNCTION__": kevent reports %d", res));
d238 1
a238 1
		ev = events[i].udata;
d246 1
a246 2
		} else
			events[i].filter = 0;
d251 5
a259 23
	for (i = 0; i < res; i++) {
		/* XXX */
		int ncalls, evres;

		if (events[i].flags & EV_ERROR || events[i].filter == NULL)
			continue;

		ev = events[i].udata;
		if (ev->ev_events & EV_PERSIST)
			continue;

		ncalls = 0;
		if (ev->ev_flags & EVLIST_ACTIVE) {
			ncalls = ev->ev_ncalls;
			evres = ev->ev_res;
		}
		ev->ev_flags &= ~EVLIST_X_KQINKERNEL;
		event_del(ev);

		if (ncalls)
			event_active(ev, evres, ncalls);
	}

d279 1
a279 1
		kev.udata = ev;
d298 1
a298 1
		kev.udata = ev;
d313 1
a313 1
		kev.udata = ev;
@


1.8
log
@do not honour getenv of EVENT_NOKQUEUE is issetugid; millert henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.7 2003/03/10 04:02:50 david Exp $	*/
d76 1
a76 1
struct eventop kqops = {
@


1.7
log
@duplicate words and spelling fixes in comments
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.6 2002/09/08 07:52:33 itojun Exp $	*/
d91 1
a91 1
	if (getenv("EVENT_NOKQUEUE"))
@


1.6
log
@typo.  from marius@@umich.edu via provos
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.5 2002/07/10 14:41:31 art Exp $	*/
d96 1
a96 1
	/* Initalize the kernel queue */
d105 1
a105 1
	/* Initalize fields */
@


1.5
log
@Make EV_PERSIST work on EV_READ and EV_WRITE events.
provos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.4 2002/06/25 15:50:15 mickey Exp $	*/
d281 1
a281 1
			kev.filter |= EV_ONESHOT;
d300 1
a300 1
			kev.filter |= EV_ONESHOT;
d315 1
a315 1
			kev.filter |= EV_ONESHOT;
@


1.4
log
@rcsids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d298 3
a300 1
		kev.flags = EV_ADD | EV_ONESHOT;
d313 3
a315 1
		kev.flags = EV_ADD | EV_ONESHOT;
@


1.3
log
@rename variable so that scoping is more obvious
@
text
@d1 2
@


1.2
log
@need string.h
@
text
@d240 1
a240 1
		int ncalls, res;
d252 1
a252 1
			res = ev->ev_res;
d258 1
a258 1
			event_active(ev, res, ncalls);
@


1.1
log
@Initial revision
@
text
@d39 1
@


1.1.1.1
log
@import libevent an event notification abstraction on top of select or kqueue
supporting timeout and signal callsbacks, too.  okay deraadt@@ millert@@
@
text
@@
