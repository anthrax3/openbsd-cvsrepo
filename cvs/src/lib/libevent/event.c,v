head	1.38;
access;
symbols
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.8
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.4
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.38.0.6
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.27.0.6
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.2
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.25.0.8
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.6
	OPENBSD_5_0:1.25.0.4
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.17.0.4
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	EVENT00:1.1.1.1
	PROVOS00:1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2015.01.06.23.11.23;	author bluhm;	state Exp;
branches;
next	1.37;
commitid	0Btin9vZDFlKKN70;

1.37
date	2015.01.06.11.27.35;	author bluhm;	state Exp;
branches;
next	1.36;
commitid	mPPx6uc6nkLYhSRx;

1.36
date	2014.10.30.16.45.37;	author bluhm;	state Exp;
branches;
next	1.35;
commitid	tunEM8ZR8ESfpNht;

1.35
date	2014.10.29.22.47.29;	author bluhm;	state Exp;
branches;
next	1.34;
commitid	FfV5qz960uDg9hP4;

1.34
date	2014.10.17.22.59.46;	author bluhm;	state Exp;
branches;
next	1.33;
commitid	p1PA5gc7DJH1iIRh;

1.33
date	2014.10.17.20.52.59;	author bluhm;	state Exp;
branches;
next	1.32;
commitid	kP2i1Fuvolo0c88A;

1.32
date	2014.10.17.19.16.01;	author bluhm;	state Exp;
branches;
next	1.31;
commitid	wDYYYW1I3umfP7v5;

1.31
date	2014.10.16.07.38.06;	author bluhm;	state Exp;
branches;
next	1.30;
commitid	Lmt85cKJJzyEtWLn;

1.30
date	2014.10.08.20.14.19;	author bluhm;	state Exp;
branches;
next	1.29;
commitid	WQfvaeUx8qLyAKa3;

1.29
date	2014.09.01.13.26.29;	author bluhm;	state Exp;
branches;
next	1.28;
commitid	gETnB1VwzzWRopgQ;

1.28
date	2014.04.03.11.27.02;	author eric;	state Exp;
branches;
next	1.27;

1.27
date	2013.04.17.15.31.49;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2012.08.28.09.09.56;	author pascal;	state Exp;
branches;
next	1.25;

1.25
date	2010.08.30.07.54.29;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.12.18.03.38;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2010.04.21.21.02.46;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2010.04.21.20.02.40;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.12.05.44.29;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.30.13.51.29;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.02.18.26.42;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.02.06.09.11;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.19.15.12.49;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.13.20.10.57;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.04.18.59.12;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.05.03.39.40;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.30.06.32.36;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.28.15.32.13;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.02.07.15.13;	author grunk;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.04.03.17.48;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.22.00.56.25;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.19.08.07.45;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.19.02.03.12;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.13.16.15.09;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.28.06.53.12;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.09.10.54.38;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.19.18.52.12;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.25.15.50.15;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.15.18.01.37;	author provos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.15.18.01.37;	author provos;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Backout revision 1.37.  Setting ev->ev_pncalls to NULL results in
a use after free if the callback has freed the ev.  With F in
malloc.conf both tmux and the regression tests triggered a segmentation
fault.
OK nicm@@
@
text
@/*	$OpenBSD: event.c,v 1.37 2015/01/06 11:27:35 bluhm Exp $	*/

/*
 * Copyright (c) 2000-2004 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/queue.h>

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <netdb.h>
#include <asr.h>

#include "event.h"
#include "event-internal.h"
#include "log.h"

extern const struct eventop selectops;
extern const struct eventop pollops;
extern const struct eventop kqops;

/* In order of preference */
static const struct eventop *eventops[] = {
	&kqops,
	&pollops,
	&selectops,
	NULL
};

/* Global state */
struct event_base *current_base = NULL;
extern struct event_base *evsignal_base;
static int use_monotonic;

/* Handle signals - This is a deprecated interface */
int (*event_sigcb)(void);		/* Signal callback when gotsig is set */
volatile sig_atomic_t event_gotsig;	/* Set in signal handler */

/* Prototypes */
static void	event_queue_insert(struct event_base *, struct event *, int);
static void	event_queue_remove(struct event_base *, struct event *, int);
static int	event_haveevents(struct event_base *);

static void	event_process_active(struct event_base *);

static int	timeout_next(struct event_base *, struct timeval **);
static void	timeout_process(struct event_base *);
static void	timeout_correct(struct event_base *, struct timeval *);

static void
detect_monotonic(void)
{
	struct timespec	ts;

	if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0)
		use_monotonic = 1;
}

static int
gettime(struct event_base *base, struct timeval *tp)
{
	if (base->tv_cache.tv_sec) {
		*tp = base->tv_cache;
		return (0);
	}

	if (use_monotonic) {
		struct timespec	ts;

		if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
			return (-1);

		tp->tv_sec = ts.tv_sec;
		tp->tv_usec = ts.tv_nsec / 1000;
		return (0);
	}

	return (gettimeofday(tp, NULL));
}

struct event_base *
event_init(void)
{
	struct event_base *base = event_base_new();

	if (base != NULL)
		current_base = base;

	return (base);
}

struct event_base *
event_base_new(void)
{
	int i;
	struct event_base *base;

	if ((base = calloc(1, sizeof(struct event_base))) == NULL)
		event_err(1, "%s: calloc", __func__);

	event_sigcb = NULL;
	event_gotsig = 0;

	detect_monotonic();
	gettime(base, &base->event_tv);

	min_heap_ctor(&base->timeheap);
	TAILQ_INIT(&base->eventqueue);
	base->sig.ev_signal_pair[0] = -1;
	base->sig.ev_signal_pair[1] = -1;

	base->evbase = NULL;
	for (i = 0; eventops[i] && !base->evbase; i++) {
		base->evsel = eventops[i];

		base->evbase = base->evsel->init(base);
	}

	if (base->evbase == NULL)
		event_errx(1, "%s: no event mechanism available", __func__);

	if (!issetugid() && getenv("EVENT_SHOW_METHOD"))
		event_msgx("libevent using: %s", base->evsel->name);

	/* allocate a single active event queue */
	event_base_priority_init(base, 1);

	return (base);
}

void
event_base_free(struct event_base *base)
{
	int i, n_deleted=0;
	struct event *ev;

	if (base == NULL && current_base)
		base = current_base;
	if (base == current_base)
		current_base = NULL;

	/* XXX(niels) - check for internal events first */
	assert(base);
	/* Delete all non-internal events. */
	for (ev = TAILQ_FIRST(&base->eventqueue); ev; ) {
		struct event *next = TAILQ_NEXT(ev, ev_next);
		if (!(ev->ev_flags & EVLIST_INTERNAL)) {
			event_del(ev);
			++n_deleted;
		}
		ev = next;
	}
	while ((ev = min_heap_top(&base->timeheap)) != NULL) {
		event_del(ev);
		++n_deleted;
	}

	for (i = 0; i < base->nactivequeues; ++i) {
		for (ev = TAILQ_FIRST(base->activequeues[i]); ev; ) {
			struct event *next = TAILQ_NEXT(ev, ev_active_next);
			if (!(ev->ev_flags & EVLIST_INTERNAL)) {
				event_del(ev);
				++n_deleted;
			}
			ev = next;
		}
	}

	if (n_deleted)
		event_debug(("%s: %d events were still set in base",
			__func__, n_deleted));

	if (base->evsel->dealloc != NULL)
		base->evsel->dealloc(base, base->evbase);

	for (i = 0; i < base->nactivequeues; ++i)
		assert(TAILQ_EMPTY(base->activequeues[i]));

	assert(min_heap_empty(&base->timeheap));
	min_heap_dtor(&base->timeheap);

	for (i = 0; i < base->nactivequeues; ++i)
		free(base->activequeues[i]);
	free(base->activequeues);

	assert(TAILQ_EMPTY(&base->eventqueue));

	free(base);
}

/* reinitialized the event base after a fork */
int
event_reinit(struct event_base *base)
{
	const struct eventop *evsel = base->evsel;
	void *evbase = base->evbase;
	int res = 0;
	struct event *ev;

#if 0
	/* Right now, reinit always takes effect, since even if the
	   backend doesn't require it, the signal socketpair code does.
	*/
	/* check if this event mechanism requires reinit */
	if (!evsel->need_reinit)
		return (0);
#endif

	/* prevent internal delete */
	if (base->sig.ev_signal_added) {
		/* we cannot call event_del here because the base has
		 * not been reinitialized yet. */
		event_queue_remove(base, &base->sig.ev_signal,
		    EVLIST_INSERTED);
		if (base->sig.ev_signal.ev_flags & EVLIST_ACTIVE)
			event_queue_remove(base, &base->sig.ev_signal,
			    EVLIST_ACTIVE);
		base->sig.ev_signal_added = 0;
	}

	if (base->evsel->dealloc != NULL)
		base->evsel->dealloc(base, base->evbase);
	evbase = base->evbase = evsel->init(base);
	if (base->evbase == NULL)
		event_errx(1, "%s: could not reinitialize event mechanism",
		    __func__);

	TAILQ_FOREACH(ev, &base->eventqueue, ev_next) {
		if (evsel->add(evbase, ev) == -1)
			res = -1;
	}

	return (res);
}

int
event_priority_init(int npriorities)
{
  return event_base_priority_init(current_base, npriorities);
}

int
event_base_priority_init(struct event_base *base, int npriorities)
{
	int i;

	if (base->event_count_active)
		return (-1);

	if (npriorities == base->nactivequeues)
		return (0);

	if (base->nactivequeues) {
		for (i = 0; i < base->nactivequeues; ++i) {
			free(base->activequeues[i]);
		}
		free(base->activequeues);
	}

	/* Allocate our priority queues */
	base->nactivequeues = npriorities;
	base->activequeues = (struct event_list **)
	    calloc(base->nactivequeues, sizeof(struct event_list *));
	if (base->activequeues == NULL)
		event_err(1, "%s: calloc", __func__);

	for (i = 0; i < base->nactivequeues; ++i) {
		base->activequeues[i] = malloc(sizeof(struct event_list));
		if (base->activequeues[i] == NULL)
			event_err(1, "%s: malloc", __func__);
		TAILQ_INIT(base->activequeues[i]);
	}

	return (0);
}

int
event_haveevents(struct event_base *base)
{
	return (base->event_count > 0);
}

/*
 * Active events are stored in priority queues.  Lower priorities are always
 * process before higher priorities.  Low priority events can starve high
 * priority ones.
 */

static void
event_process_active(struct event_base *base)
{
	struct event *ev;
	struct event_list *activeq = NULL;
	int i;
	short ncalls;

	for (i = 0; i < base->nactivequeues; ++i) {
		if (TAILQ_FIRST(base->activequeues[i]) != NULL) {
			activeq = base->activequeues[i];
			break;
		}
	}

	assert(activeq != NULL);

	for (ev = TAILQ_FIRST(activeq); ev; ev = TAILQ_FIRST(activeq)) {
		if (ev->ev_events & EV_PERSIST)
			event_queue_remove(base, ev, EVLIST_ACTIVE);
		else
			event_del(ev);

		/* Allows deletes to work */
		ncalls = ev->ev_ncalls;
		ev->ev_pncalls = &ncalls;
		while (ncalls) {
			ncalls--;
			ev->ev_ncalls = ncalls;
			(*ev->ev_callback)((int)ev->ev_fd, ev->ev_res, ev->ev_arg);
			if (event_gotsig || base->event_break)
				return;
		}
	}
}

/*
 * Wait continously for events.  We exit only if no events are left.
 */

int
event_dispatch(void)
{
	return (event_loop(0));
}

int
event_base_dispatch(struct event_base *event_base)
{
  return (event_base_loop(event_base, 0));
}

const char *
event_base_get_method(struct event_base *base)
{
	assert(base);
	return (base->evsel->name);
}

static void
event_loopexit_cb(int fd, short what, void *arg)
{
	struct event_base *base = arg;
	base->event_gotterm = 1;
}

/* not thread safe */
int
event_loopexit(const struct timeval *tv)
{
	return (event_once(-1, EV_TIMEOUT, event_loopexit_cb,
		    current_base, tv));
}

int
event_base_loopexit(struct event_base *event_base, const struct timeval *tv)
{
	return (event_base_once(event_base, -1, EV_TIMEOUT, event_loopexit_cb,
		    event_base, tv));
}

/* not thread safe */
int
event_loopbreak(void)
{
	return (event_base_loopbreak(current_base));
}

int
event_base_loopbreak(struct event_base *event_base)
{
	if (event_base == NULL)
		return (-1);

	event_base->event_break = 1;
	return (0);
}



/* not thread safe */

int
event_loop(int flags)
{
	return event_base_loop(current_base, flags);
}

int
event_base_loop(struct event_base *base, int flags)
{
	const struct eventop *evsel = base->evsel;
	void *evbase = base->evbase;
	struct timeval tv;
	struct timeval *tv_p;
	int res, done;

	/* clear time cache */
	base->tv_cache.tv_sec = 0;

	if (base->sig.ev_signal_added)
		evsignal_base = base;
	done = 0;
	while (!done) {
		/* Terminate the loop if we have been asked to */
		if (base->event_gotterm) {
			base->event_gotterm = 0;
			break;
		}

		if (base->event_break) {
			base->event_break = 0;
			break;
		}

		/* You cannot use this interface for multi-threaded apps */
		while (event_gotsig) {
			event_gotsig = 0;
			if (event_sigcb) {
				res = (*event_sigcb)();
				if (res == -1) {
					errno = EINTR;
					return (-1);
				}
			}
		}

		timeout_correct(base, &tv);

		tv_p = &tv;
		if (!base->event_count_active && !(flags & EVLOOP_NONBLOCK)) {
			timeout_next(base, &tv_p);
		} else {
			/*
			 * if we have active events, we just poll new events
			 * without waiting.
			 */
			timerclear(&tv);
		}

		/* If we have no events, we just exit */
		if (!event_haveevents(base)) {
			event_debug(("%s: no events registered.", __func__));
			return (1);
		}

		/* update last old time */
		gettime(base, &base->event_tv);

		/* clear time cache */
		base->tv_cache.tv_sec = 0;

		res = evsel->dispatch(base, evbase, tv_p);

		if (res == -1)
			return (-1);
		gettime(base, &base->tv_cache);

		timeout_process(base);

		if (base->event_count_active) {
			event_process_active(base);
			if (!base->event_count_active && (flags & EVLOOP_ONCE))
				done = 1;
		} else if (flags & EVLOOP_NONBLOCK)
			done = 1;
	}

	/* clear time cache */
	base->tv_cache.tv_sec = 0;

	event_debug(("%s: asked to terminate loop.", __func__));
	return (0);
}

/* Sets up an event for processing once */

struct event_once {
	struct event ev;

	void (*cb)(int, short, void *);
	void *arg;
};

/* One-time callback, it deletes itself */

static void
event_once_cb(int fd, short events, void *arg)
{
	struct event_once *eonce = arg;

	(*eonce->cb)(fd, events, eonce->arg);
	free(eonce);
}

/* not threadsafe, event scheduled once. */
int
event_once(int fd, short events,
    void (*callback)(int, short, void *), void *arg, const struct timeval *tv)
{
	return event_base_once(current_base, fd, events, callback, arg, tv);
}

/* Schedules an event once */
int
event_base_once(struct event_base *base, int fd, short events,
    void (*callback)(int, short, void *), void *arg, const struct timeval *tv)
{
	struct event_once *eonce;
	struct timeval etv;
	int res;

	/* We cannot support signals that just fire once */
	if (events & EV_SIGNAL)
		return (-1);

	if ((eonce = calloc(1, sizeof(struct event_once))) == NULL)
		return (-1);

	eonce->cb = callback;
	eonce->arg = arg;

	if (events == EV_TIMEOUT) {
		if (tv == NULL) {
			timerclear(&etv);
			tv = &etv;
		}

		evtimer_set(&eonce->ev, event_once_cb, eonce);
	} else if (events & (EV_READ|EV_WRITE)) {
		events &= EV_READ|EV_WRITE;

		event_set(&eonce->ev, fd, events, event_once_cb, eonce);
	} else {
		/* Bad event combination */
		free(eonce);
		return (-1);
	}

	res = event_base_set(base, &eonce->ev);
	if (res == 0)
		res = event_add(&eonce->ev, tv);
	if (res != 0) {
		free(eonce);
		return (res);
	}

	return (0);
}

void
event_set(struct event *ev, int fd, short events,
	  void (*callback)(int, short, void *), void *arg)
{
	/* Take the current base - caller needs to set the real base later */
	ev->ev_base = current_base;

	ev->ev_callback = callback;
	ev->ev_arg = arg;
	ev->ev_fd = fd;
	ev->ev_events = events;
	ev->ev_res = 0;
	ev->ev_flags = EVLIST_INIT;
	ev->ev_ncalls = 0;
	ev->ev_pncalls = NULL;

	min_heap_elem_init(ev);

	/* by default, we put new events into the middle priority */
	if(current_base)
		ev->ev_pri = current_base->nactivequeues/2;
}

int
event_base_set(struct event_base *base, struct event *ev)
{
	/* Only innocent events may be assigned to a different base */
	if (ev->ev_flags != EVLIST_INIT)
		return (-1);

	ev->ev_base = base;
	ev->ev_pri = base->nactivequeues/2;

	return (0);
}

/*
 * Set's the priority of an event - if an event is already scheduled
 * changing the priority is going to fail.
 */

int
event_priority_set(struct event *ev, int pri)
{
	if (ev->ev_flags & EVLIST_ACTIVE)
		return (-1);
	if (pri < 0 || pri >= ev->ev_base->nactivequeues)
		return (-1);

	ev->ev_pri = pri;

	return (0);
}

/*
 * Checks if a specific event is pending or scheduled.
 */

int
event_pending(struct event *ev, short event, struct timeval *tv)
{
	struct timeval	now, res;
	int flags = 0;

	if (ev->ev_flags & EVLIST_INSERTED)
		flags |= (ev->ev_events & (EV_READ|EV_WRITE|EV_SIGNAL));
	if (ev->ev_flags & EVLIST_ACTIVE)
		flags |= ev->ev_res;
	if (ev->ev_flags & EVLIST_TIMEOUT)
		flags |= EV_TIMEOUT;

	event &= (EV_TIMEOUT|EV_READ|EV_WRITE|EV_SIGNAL);

	/* See if there is a timeout that we should report */
	if (tv != NULL && (flags & event & EV_TIMEOUT)) {
		gettime(ev->ev_base, &now);
		timersub(&ev->ev_timeout, &now, &res);
		/* correctly remap to real time */
		gettimeofday(&now, NULL);
		timeradd(&now, &res, tv);
	}

	return (flags & event);
}

int
event_add(struct event *ev, const struct timeval *tv)
{
	struct event_base *base = ev->ev_base;
	const struct eventop *evsel = base->evsel;
	void *evbase = base->evbase;
	int res = 0;

	event_debug((
		 "event_add: event: %p, %s%s%scall %p",
		 ev,
		 ev->ev_events & EV_READ ? "EV_READ " : " ",
		 ev->ev_events & EV_WRITE ? "EV_WRITE " : " ",
		 tv ? "EV_TIMEOUT " : " ",
		 ev->ev_callback));

	assert(!(ev->ev_flags & ~EVLIST_ALL));

	/*
	 * prepare for timeout insertion further below, if we get a
	 * failure on any step, we should not change any state.
	 */
	if (tv != NULL && !(ev->ev_flags & EVLIST_TIMEOUT)) {
		if (min_heap_reserve(&base->timeheap,
			1 + min_heap_size(&base->timeheap)) == -1)
			return (-1);  /* ENOMEM == errno */
	}

	if ((ev->ev_events & (EV_READ|EV_WRITE|EV_SIGNAL)) &&
	    !(ev->ev_flags & (EVLIST_INSERTED|EVLIST_ACTIVE))) {
		res = evsel->add(evbase, ev);
		if (res != -1)
			event_queue_insert(base, ev, EVLIST_INSERTED);
	}

	/*
	 * we should change the timout state only if the previous event
	 * addition succeeded.
	 */
	if (res != -1 && tv != NULL) {
		struct timeval now;

		/*
		 * we already reserved memory above for the case where we
		 * are not replacing an exisiting timeout.
		 */
		if (ev->ev_flags & EVLIST_TIMEOUT)
			event_queue_remove(base, ev, EVLIST_TIMEOUT);

		/* Check if it is active due to a timeout.  Rescheduling
		 * this timeout before the callback can be executed
		 * removes it from the active list. */
		if ((ev->ev_flags & EVLIST_ACTIVE) &&
		    (ev->ev_res & EV_TIMEOUT)) {
			/* See if we are just active executing this
			 * event in a loop
			 */
			if (ev->ev_ncalls && ev->ev_pncalls) {
				/* Abort loop */
				*ev->ev_pncalls = 0;
			}

			event_queue_remove(base, ev, EVLIST_ACTIVE);
		}

		gettime(base, &now);
		timeradd(&now, tv, &ev->ev_timeout);

		event_debug((
			 "event_add: timeout in %lld seconds, call %p",
			 (long long)tv->tv_sec, ev->ev_callback));

		event_queue_insert(base, ev, EVLIST_TIMEOUT);
	}

	return (res);
}

int
event_del(struct event *ev)
{
	struct event_base *base;
	const struct eventop *evsel;
	void *evbase;

	event_debug(("event_del: %p, callback %p",
		 ev, ev->ev_callback));

	/* An event without a base has not been added */
	if (ev->ev_base == NULL)
		return (-1);

	base = ev->ev_base;
	evsel = base->evsel;
	evbase = base->evbase;

	assert(!(ev->ev_flags & ~EVLIST_ALL));

	/* See if we are just active executing this event in a loop */
	if (ev->ev_ncalls && ev->ev_pncalls) {
		/* Abort loop */
		*ev->ev_pncalls = 0;
	}

	if (ev->ev_flags & EVLIST_TIMEOUT)
		event_queue_remove(base, ev, EVLIST_TIMEOUT);

	if (ev->ev_flags & EVLIST_ACTIVE)
		event_queue_remove(base, ev, EVLIST_ACTIVE);

	if (ev->ev_flags & EVLIST_INSERTED) {
		event_queue_remove(base, ev, EVLIST_INSERTED);
		return (evsel->del(evbase, ev));
	}

	return (0);
}

void
event_active(struct event *ev, int res, short ncalls)
{
	/* We get different kinds of events, add them together */
	if (ev->ev_flags & EVLIST_ACTIVE) {
		ev->ev_res |= res;
		return;
	}

	ev->ev_res = res;
	ev->ev_ncalls = ncalls;
	ev->ev_pncalls = NULL;
	event_queue_insert(ev->ev_base, ev, EVLIST_ACTIVE);
}

static int
timeout_next(struct event_base *base, struct timeval **tv_p)
{
	struct timeval now;
	struct event *ev;
	struct timeval *tv = *tv_p;

	if ((ev = min_heap_top(&base->timeheap)) == NULL) {
		/* if no time-based events are active wait for I/O */
		*tv_p = NULL;
		return (0);
	}

	if (gettime(base, &now) == -1)
		return (-1);

	if (timercmp(&ev->ev_timeout, &now, <=)) {
		timerclear(tv);
		return (0);
	}

	timersub(&ev->ev_timeout, &now, tv);

	assert(tv->tv_sec >= 0);
	assert(tv->tv_usec >= 0);

	event_debug(("timeout_next: in %lld seconds", (long long)tv->tv_sec));
	return (0);
}

/*
 * Determines if the time is running backwards by comparing the current
 * time against the last time we checked.  Not needed when using clock
 * monotonic.
 */

static void
timeout_correct(struct event_base *base, struct timeval *tv)
{
	struct event **pev;
	unsigned int size;
	struct timeval off;

	if (use_monotonic)
		return;

	/* Check if time is running backwards */
	gettime(base, tv);
	if (timercmp(tv, &base->event_tv, >=)) {
		base->event_tv = *tv;
		return;
	}

	event_debug(("%s: time is running backwards, corrected",
		    __func__));
	timersub(&base->event_tv, tv, &off);

	/*
	 * We can modify the key element of the node without destroying
	 * the key, beause we apply it to all in the right order.
	 */
	pev = base->timeheap.p;
	size = base->timeheap.n;
	for (; size-- > 0; ++pev) {
		struct timeval *ev_tv = &(**pev).ev_timeout;
		timersub(ev_tv, &off, ev_tv);
	}
	/* Now remember what the new time turned out to be. */
	base->event_tv = *tv;
}

void
timeout_process(struct event_base *base)
{
	struct timeval now;
	struct event *ev;

	if (min_heap_empty(&base->timeheap))
		return;

	gettime(base, &now);

	while ((ev = min_heap_top(&base->timeheap))) {
		if (timercmp(&ev->ev_timeout, &now, >))
			break;

		/* delete this event from the I/O queues */
		event_del(ev);

		event_debug(("timeout_process: call %p",
			 ev->ev_callback));
		event_active(ev, EV_TIMEOUT, 1);
	}
}

void
event_queue_remove(struct event_base *base, struct event *ev, int queue)
{
	if (!(ev->ev_flags & queue))
		event_errx(1, "%s: %p(fd %d) not on queue %x", __func__,
			   ev, ev->ev_fd, queue);

	if (~ev->ev_flags & EVLIST_INTERNAL)
		base->event_count--;

	ev->ev_flags &= ~queue;
	switch (queue) {
	case EVLIST_INSERTED:
		TAILQ_REMOVE(&base->eventqueue, ev, ev_next);
		break;
	case EVLIST_ACTIVE:
		base->event_count_active--;
		TAILQ_REMOVE(base->activequeues[ev->ev_pri],
		    ev, ev_active_next);
		break;
	case EVLIST_TIMEOUT:
		min_heap_erase(&base->timeheap, ev);
		break;
	default:
		event_errx(1, "%s: unknown queue %x", __func__, queue);
	}
}

void
event_queue_insert(struct event_base *base, struct event *ev, int queue)
{
	if (ev->ev_flags & queue) {
		/* Double insertion is possible for active events */
		if (queue & EVLIST_ACTIVE)
			return;

		event_errx(1, "%s: %p(fd %d) already on queue %x", __func__,
			   ev, ev->ev_fd, queue);
	}

	if (~ev->ev_flags & EVLIST_INTERNAL)
		base->event_count++;

	ev->ev_flags |= queue;
	switch (queue) {
	case EVLIST_INSERTED:
		TAILQ_INSERT_TAIL(&base->eventqueue, ev, ev_next);
		break;
	case EVLIST_ACTIVE:
		base->event_count_active++;
		TAILQ_INSERT_TAIL(base->activequeues[ev->ev_pri],
		    ev,ev_active_next);
		break;
	case EVLIST_TIMEOUT: {
		min_heap_push(&base->timeheap, ev);
		break;
	}
	default:
		event_errx(1, "%s: unknown queue %x", __func__, queue);
	}
}

/* Functions for debugging */

const char *
event_get_version(void)
{
	return (_EVENT_VERSION);
}

/*
 * No thread-safe interface needed - the information should be the same
 * for all threads.
 */

const char *
event_get_method(void)
{
	return (current_base->evsel->name);
}


/*
 * Libevent glue for ASR.
 */
struct event_asr {
	struct event	 ev;
	struct asr_query *async;
	void		(*cb)(struct asr_result *, void *);
	void		*arg;
};

static void
event_asr_dispatch(int fd __attribute__((__unused__)),
    short ev __attribute__((__unused__)), void *arg)
{
	struct event_asr	*eva = arg;
	struct asr_result	 ar;
	struct timeval		 tv;

	event_del(&eva->ev);

	if (asr_run(eva->async, &ar)) {
		eva->cb(&ar, eva->arg);
		free(eva);
	} else {
		event_set(&eva->ev, ar.ar_fd,
		    ar.ar_cond == ASR_WANT_READ ? EV_READ : EV_WRITE,
		    event_asr_dispatch, eva);
		tv.tv_sec = ar.ar_timeout / 1000;
		tv.tv_usec = (ar.ar_timeout % 1000) * 1000;
		event_add(&eva->ev, &tv);
	}
}

struct event_asr *
event_asr_run(struct asr_query *async, void (*cb)(struct asr_result *, void *),
    void *arg)
{
	struct event_asr *eva;
	struct timeval tv;

	eva = calloc(1, sizeof *eva);
	if (eva == NULL)
		return (NULL);
	eva->async = async;
	eva->cb = cb;
	eva->arg = arg;
	tv.tv_sec = 0;
	tv.tv_usec = 0;
	evtimer_set(&eva->ev, event_asr_dispatch, eva);
	evtimer_add(&eva->ev, &tv);
	return (eva);
}

void
event_asr_abort(struct event_asr *eva)
{
	asr_abort(eva->async);
	event_del(&eva->ev);
	free(eva);
}
@


1.37
log
@Apply commit 2d8cf0b720cdd5f9f292f174a10ff74e62a380ec from upstream.
- Defensive programming to prevent (hopefully impossible) stack-stomping
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.36 2014/10/30 16:45:37 bluhm Exp $	*/
d351 1
a351 2
			if (event_gotsig || base->event_break) {
				ev->ev_pncalls = NULL;
a352 1
			}
a353 1
		ev->ev_pncalls = NULL;
@


1.36
log
@Fix whitespace errors in libevent.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.35 2014/10/29 22:47:29 bluhm Exp $	*/
d351 2
a352 1
			if (event_gotsig || base->event_break)
d354 1
d356 1
@


1.35
log
@After removing all the #ifdef, the wrappers in evutil are rather
useless.  Let libevent call the libc functions directly.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.34 2014/10/17 22:59:46 bluhm Exp $	*/
d138 1
a138 1
	
d143 1
a143 1
	
d154 1
a154 1
	if (!issetugid() && getenv("EVENT_SHOW_METHOD")) 
d343 1
a343 1
		
d474 1
a474 1
			/* 
d480 1
a480 1
		
d711 1
a711 1
	/* 
d718 1
a718 1
		/* 
d737 1
a737 1
			
d974 1
a974 1
/* 
@


1.34
log
@Remove #ifdef HAVE_backend and remove references to unimplemented
backends.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.33 2014/10/17 20:52:59 bluhm Exp $	*/
a47 1
#include "evutil.h"
d110 1
a110 1
	return (evutil_gettimeofday(tp, NULL));
d154 1
a154 1
	if (evutil_getenv("EVENT_SHOW_METHOD")) 
d478 1
a478 1
			evutil_timerclear(&tv);
d565 1
a565 1
			evutil_timerclear(&etv);
d667 1
a667 1
		evutil_timersub(&ev->ev_timeout, &now, &res);
d669 2
a670 2
		evutil_gettimeofday(&now, NULL);
		evutil_timeradd(&now, &res, tv);
d742 1
a742 1
		evutil_timeradd(&now, tv, &ev->ev_timeout);
d825 2
a826 2
	if (evutil_timercmp(&ev->ev_timeout, &now, <=)) {
		evutil_timerclear(tv);
d830 1
a830 1
	evutil_timersub(&ev->ev_timeout, &now, tv);
d857 1
a857 1
	if (evutil_timercmp(tv, &base->event_tv, >=)) {
d864 1
a864 1
	evutil_timersub(&base->event_tv, tv, &off);
d874 1
a874 1
		evutil_timersub(ev_tv, &off, ev_tv);
d892 1
a892 1
		if (evutil_timercmp(&ev->ev_timeout, &now, >))
@


1.33
log
@Remove some #ifdef HAVE_syscall.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.32 2014/10/17 19:16:01 bluhm Exp $	*/
a50 4
#ifdef HAVE_EVENT_PORTS
extern const struct eventop evportops;
#endif
#ifdef HAVE_SELECT
a51 2
#endif
#ifdef HAVE_POLL
a52 5
#endif
#ifdef HAVE_EPOLL
extern const struct eventop epollops;
#endif
#ifdef HAVE_WORKING_KQUEUE
a53 4
#endif
#ifdef HAVE_DEVPOLL
extern const struct eventop devpollops;
#endif
a56 4
#ifdef HAVE_EVENT_PORTS
	&evportops,
#endif
#ifdef HAVE_WORKING_KQUEUE
a57 8
#endif
#ifdef HAVE_EPOLL
	&epollops,
#endif
#ifdef HAVE_DEVPOLL
	&devpollops,
#endif
#ifdef HAVE_POLL
a58 2
#endif
#ifdef HAVE_SELECT
a59 1
#endif
@


1.32
log
@Remove #ifdef HAVE_.*_H, just include the header files.
Do not include sys/param.h.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.31 2014/10/16 07:38:06 bluhm Exp $	*/
a115 1
#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
a119 1
#endif
a129 1
#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
a139 1
#endif
@


1.31
log
@Remove #ifdef HAVE_CONFIG_H, there is no config.h file.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.30 2014/10/08 20:14:19 bluhm Exp $	*/
a31 1
#ifdef HAVE_SYS_TIME_H
a32 3
#else 
#include <sys/_libevent_time.h>
#endif
d34 1
@


1.30
log
@iRemove the #ifdef WIN32 implementation from libevent.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.29 2014/09/01 13:26:29 bluhm Exp $	*/
a28 3
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
@


1.29
log
@The libevent event_log() function called by event_msgx() adds a new
line itself.  Do not print a double new line when EVENT_SHOW_METHOD
is set.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.28 2014/04/03 11:27:02 eric Exp $	*/
a32 5
#ifdef WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#undef WIN32_LEAN_AND_MEAN
#endif
a42 1
#ifndef WIN32
a43 1
#endif
a74 3
#ifdef WIN32
extern const struct eventop win32ops;
#endif
a94 3
#endif
#ifdef WIN32
	&win32ops,
@


1.28
log
@add helper functions to use asr with libevent.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.27 2013/04/17 15:31:49 deraadt Exp $	*/
d209 1
a209 2
		event_msgx("libevent using: %s\n",
			   base->evsel->name);
@


1.27
log
@(long long) and %lld for big time_t
ok nicm, who will pass it upstream
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.26 2012/08/28 09:09:56 pascal Exp $	*/
d39 1
d56 2
d1038 62
@


1.26
log
@Expose _EVENT_VERSION in event.h.  This is expected by net/tor, which will spew
out scary warnings if it's not there.  Bump minor accordingly.

Requested by and ok dcoppa@@, ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.25 2010/08/30 07:54:29 nicm Exp $	*/
d797 2
a798 2
			 "event_add: timeout in %ld seconds, call %p",
			 tv->tv_sec, ev->ev_callback));
d887 1
a887 1
	event_debug(("timeout_next: in %ld seconds", tv->tv_sec));
@


1.25
log
@Fix from upstream to make all backends reinit on event_reinit(). This
was not being done for poll and select, so after fork they would remain
using the same socketpair for signal notification, leading to a race
between the two processes to read from it and hangs.

Problem originally reported by kili@@.

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.24 2010/07/12 18:03:38 nicm Exp $	*/
d1023 1
a1023 1
	return ("1.4.14b-stable");
@


1.24
log
@Update to 1.4.14b.

From their change log:
 o Fix memory-leak of signal handler array with kqueue. [backport]
 o Make evutil_make_socket_nonblocking() leave any other flags alone.
 o Adjusted fcntl() retval comparison on evutil_make_socket_nonblocking().
 o Re-add event_siglcb; some old code _was_ still using it. :(
 o Fix a free(NULL) in min_heap.h
 o Clean up properly when adding a signal handler fails.

Also a local change to use an int rather than a long for fcntl().

ok guenther deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.23 2010/04/21 21:02:46 nicm Exp $	*/
d284 4
d291 1
d304 1
a304 1
	
@


1.23
log
@Clean up the awful _EVENT_* poo in the libevent headers, and don't
install event-config.h.

Pointed out by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.22 2010/04/21 20:02:40 nicm Exp $	*/
d114 4
d184 3
d329 4
a332 1
	if (base->nactivequeues && npriorities != base->nactivequeues) {
d398 1
a398 1
			if (base->event_break)
d503 12
d1018 1
a1018 1
	return ("1.4.13-stable");
@


1.22
log
@Update libevent to 1.4.13.

This is the core library only, the DNS parts are removed and it does not
include the other extra bits (HTTP, DNS, and RPC), a separate port for
these will appear in due course.

Thanks to jsg, sthen, alek, gilles, jacekm, bernd and any others I've
forgotten for testing/comments.

Note that /usr/include/evdns.h should be removed after updating.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.21 2009/11/12 05:44:29 deraadt Exp $	*/
d996 1
a996 1
	return (_EVENT_VERSION);
@


1.21
log
@change back to preferring kqueue, now that nicm, tedu and i have
fixed it (or, all the issues we are aware of so far).
discussed with nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.19 2008/05/02 18:26:42 brad Exp $	*/
a36 1
#include "misc.h"
a38 1
#include <sys/tree.h>
d41 2
a42 2
#else
#include <sys/_time.h>
d58 1
a69 3
#ifdef HAVE_RTSIG
extern const struct eventop rtsigops;
#endif
d84 1
a84 1
const struct eventop *eventops[] = {
a96 3
#ifdef HAVE_RTSIG
	&rtsigops,
#endif
a113 4
/* Handle signals - This is a deprecated interface */
int (*event_sigcb)(void);		/* Signal callback when gotsig is set */
volatile sig_atomic_t event_gotsig;	/* Set in signal handler */

a124 14
static int
compare(struct event *a, struct event *b)
{
	if (timercmp(&a->ev_timeout, &b->ev_timeout, <))
		return (-1);
	else if (timercmp(&a->ev_timeout, &b->ev_timeout, >))
		return (1);
	if (a < b)
		return (-1);
	else if (a > b)
		return (1);
	return (0);
}

d137 1
a137 1
gettime(struct timeval *tp)
d139 5
d145 2
a146 1
	struct timespec	ts;
a147 1
	if (use_monotonic) {
d157 1
a157 1
	return (gettimeofday(tp, NULL));
d160 4
a163 1
RB_PROTOTYPE(event_tree, event, ev_timeout_node, compare);
d165 2
a166 1
RB_GENERATE(event_tree, event, ev_timeout_node, compare);
d168 2
d172 1
a172 1
event_init(void)
d178 1
a178 4
		event_err(1, "%s: calloc");

	event_sigcb = NULL;
	event_gotsig = 0;
d181 3
a183 3
	gettime(&base->event_tv);

	RB_INIT(&base->timetree);
a184 1
	TAILQ_INIT(&base->sig.signalqueue);
d187 1
a187 1

d198 1
a198 1
	if (getenv("EVENT_SHOW_METHOD")) 
a204 1
	current_base = base;
d211 2
a212 1
	int i;
d216 1
a216 1
        if (base == current_base)
d219 1
d221 29
d252 2
a253 1
	for (i=0; i < base->nactivequeues; ++i)
d256 2
a257 1
	assert(RB_EMPTY(&base->timetree));
d268 40
d331 2
a332 2
	base->activequeues = (struct event_list **)calloc(base->nactivequeues,
	    npriorities * sizeof(struct event_list *));
a365 3
	if (!base->event_count_active)
		return;

d376 5
a380 2
		event_queue_remove(base, ev, EVLIST_ACTIVE);

d388 1
a388 1
			if (event_gotsig)
d410 7
d426 1
a426 1
event_loopexit(struct timeval *tv)
d433 1
a433 1
event_base_loopexit(struct event_base *event_base, struct timeval *tv)
d440 19
d475 4
a478 2
#ifndef WIN32
	if(!TAILQ_EMPTY(&base->sig.signalqueue))
a479 1
#endif
a481 4
		/* Calculate the initial events that we are waiting for */
		if (evsel->recalc(base, evbase, 0) == -1)
			return (-1);

d488 3
a490 10
		/* You cannot use this interface for multi-threaded apps */
		while (event_gotsig) {
			event_gotsig = 0;
			if (event_sigcb) {
				res = (*event_sigcb)();
				if (res == -1) {
					errno = EINTR;
					return (-1);
				}
			}
d503 1
a503 1
			timerclear(&tv);
d505 1
a505 1

d512 6
d522 1
d534 3
d564 1
a564 1
    void (*callback)(int, short, void *), void *arg, struct timeval *tv)
d572 1
a572 1
    void (*callback)(int, short, void *), void *arg, struct timeval *tv)
d590 1
a590 1
			timerclear(&etv);
d632 2
d681 1
a681 1
		flags |= (ev->ev_events & (EV_READ|EV_WRITE));
a685 2
	if (ev->ev_flags & EVLIST_SIGNAL)
		flags |= EV_SIGNAL;
d691 2
a692 2
		gettime(&now);
		timersub(&ev->ev_timeout, &now, &res);
d694 2
a695 2
		gettimeofday(&now, NULL);
		timeradd(&now, &res, tv);
d702 1
a702 1
event_add(struct event *ev, struct timeval *tv)
d707 1
d719 22
a740 1
	if (tv != NULL) {
d743 4
d762 1
a762 1

d766 2
a767 2
		gettime(&now);
		timeradd(&now, tv, &ev->ev_timeout);
d770 1
a770 1
			 "event_add: timeout in %d seconds, call %p",
d776 1
a776 13
	if ((ev->ev_events & (EV_READ|EV_WRITE)) &&
	    !(ev->ev_flags & (EVLIST_INSERTED|EVLIST_ACTIVE))) {
		event_queue_insert(base, ev, EVLIST_INSERTED);

		return (evsel->add(evbase, ev));
	} else if ((ev->ev_events & EV_SIGNAL) &&
	    !(ev->ev_flags & EVLIST_SIGNAL)) {
		event_queue_insert(base, ev, EVLIST_SIGNAL);

		return (evsel->add(evbase, ev));
	}

	return (0);
a813 3
	} else if (ev->ev_flags & EVLIST_SIGNAL) {
		event_queue_remove(base, ev, EVLIST_SIGNAL);
		return (evsel->del(evbase, ev));
d841 1
a841 1
	if ((ev = RB_MIN(event_tree, &base->timetree)) == NULL) {
d847 1
a847 1
	if (gettime(&now) == -1)
d850 2
a851 2
	if (timercmp(&ev->ev_timeout, &now, <=)) {
		timerclear(tv);
d855 1
a855 1
	timersub(&ev->ev_timeout, &now, tv);
d860 1
a860 1
	event_debug(("timeout_next: in %d seconds", tv->tv_sec));
d873 2
a874 1
	struct event *ev;
d881 2
a882 2
	gettime(tv);
	if (timercmp(tv, &base->event_tv, >=)) {
d889 1
a889 1
	timersub(&base->event_tv, tv, &off);
d895 8
a902 2
	RB_FOREACH(ev, event_tree, &base->timetree)
		timersub(&ev->ev_timeout, &off, &ev->ev_timeout);
d909 4
a912 1
	struct event *ev, *next;
d914 1
a914 1
	gettime(&now);
d916 2
a917 2
	for (ev = RB_MIN(event_tree, &base->timetree); ev; ev = next) {
		if (timercmp(&ev->ev_timeout, &now, >))
a918 3
		next = RB_NEXT(event_tree, &base->timetree, ev);

		event_queue_remove(base, ev, EVLIST_TIMEOUT);
a931 2
	int docount = 1;

d936 1
a936 4
	if (ev->ev_flags & EVLIST_INTERNAL)
		docount = 0;

	if (docount)
d941 3
d945 1
a945 2
		if (docount)
			base->event_count_active--;
a948 3
	case EVLIST_SIGNAL:
		TAILQ_REMOVE(&base->sig.signalqueue, ev, ev_signal_next);
		break;
d950 1
a950 4
		RB_REMOVE(event_tree, &base->timetree, ev);
		break;
	case EVLIST_INSERTED:
		TAILQ_REMOVE(&base->eventqueue, ev, ev_next);
a959 2
	int docount = 1;

d969 1
a969 4
	if (ev->ev_flags & EVLIST_INTERNAL)
		docount = 0;

	if (docount)
d974 3
d978 1
a978 2
		if (docount)
			base->event_count_active++;
a981 3
	case EVLIST_SIGNAL:
		TAILQ_INSERT_TAIL(&base->sig.signalqueue, ev, ev_signal_next);
		break;
d983 1
a983 2
		struct event *tmp = RB_INSERT(event_tree, &base->timetree, ev);
		assert(tmp == NULL);
a985 3
	case EVLIST_INSERTED:
		TAILQ_INSERT_TAIL(&base->eventqueue, ev, ev_next);
		break;
d996 1
a996 1
	return (LIBEVENT_VERSION);
d999 1
a999 1
/*
@


1.20
log
@stop using kqueue.
@
text
@d92 3
a108 3
#endif
#ifdef HAVE_WORKING_KQUEUE
	&kqops,
@


1.19
log
@- Use a const pointer for bufferevent_write.
- Make event_init return struct event_base *.

From the libevent SVN repo.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.18 2008/05/02 06:09:11 brad Exp $	*/
a91 3
#ifdef HAVE_WORKING_KQUEUE
	&kqops,
#endif
d106 3
@


1.18
log
@Update to libevent 1.3e while retaining our local changes.

"No objection" millert@@
"the diff looks and works fine" reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.17 2007/03/19 15:12:49 millert Exp $	*/
d185 1
a185 1
void *
@


1.17
log
@Update to libevent-1.3b while retaining our local changes.  beck@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.16 2007/02/13 20:10:57 millert Exp $	*/
d56 1
a116 2
struct event_list signalqueue;

d118 2
d132 1
a132 1
static int	timeout_next(struct event_base *, struct timeval *);
d150 11
d164 1
a164 1
#ifdef HAVE_CLOCK_GETTIME
d167 8
a174 10
#ifdef HAVE_CLOCK_MONOTONIC
	if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
#else
	if (clock_gettime(CLOCK_REALTIME, &ts) == -1)
#endif
		return (-1);
	tp->tv_sec = ts.tv_sec;
	tp->tv_usec = ts.tv_nsec / 1000;
#else
	gettimeofday(tp, NULL);
d177 1
a177 1
	return (0);
d189 1
d191 1
a191 1
	if ((current_base = calloc(1, sizeof(struct event_base))) == NULL)
a195 1
	gettime(&current_base->event_tv);
d197 8
a204 3
	RB_INIT(&current_base->timetree);
	TAILQ_INIT(&current_base->eventqueue);
	TAILQ_INIT(&signalqueue);
d206 3
a208 3
	current_base->evbase = NULL;
	for (i = 0; eventops[i] && !current_base->evbase; i++) {
		current_base->evsel = eventops[i];
d210 1
a210 1
		current_base->evbase = current_base->evsel->init();
d213 1
a213 1
	if (current_base->evbase == NULL)
d216 1
a216 1
	if (!issetugid() && getenv("EVENT_SHOW_METHOD"))
d218 1
a218 1
			   current_base->evsel->name);
d221 1
a221 1
	event_base_priority_init(current_base, 1);
d223 2
a224 1
	return (current_base);
d238 2
a239 1
	assert(TAILQ_EMPTY(&base->eventqueue));
d249 1
a249 2
	if (base->evsel->dealloc != NULL)
		base->evsel->dealloc(base->evbase);
a363 1

d374 1
a374 1
	return (event_once(-1, EV_TIMEOUT, event_loopexit_cb,
d392 1
d395 4
d423 1
a423 10
		/* Check if time is running backwards */
		gettime(&tv);
		if (timercmp(&tv, &base->event_tv, <)) {
			struct timeval off;
			event_debug(("%s: time is running backwards, corrected",
				    __func__));
			timersub(&base->event_tv, &tv, &off);
			timeout_correct(base, &off);
		}
		base->event_tv = tv;
d425 8
a432 3
		if (!base->event_count_active && !(flags & EVLOOP_NONBLOCK))
			timeout_next(base, &tv);
		else
d434 1
d442 1
a442 1
		res = evsel->dispatch(base, evbase, &tv);
d481 8
a489 1

d491 1
a491 1
event_once(int fd, short events,
d525 3
a527 1
	res = event_add(&eonce->ev, tv);
d547 1
d553 2
a554 1
	ev->ev_pri = current_base->nactivequeues/2;
d743 2
a744 2
int
timeout_next(struct event_base *base, struct timeval *tv)
a745 2
	struct timeval dflt = TIMEOUT_DEFAULT;

d748 1
d751 2
a752 1
		*tv = dflt;
d773 6
d780 1
a780 1
timeout_correct(struct event_base *base, struct timeval *off)
d783 15
d804 1
a804 1
		timersub(&ev->ev_timeout, off, &ev->ev_timeout);
d855 1
a855 1
		TAILQ_REMOVE(&signalqueue, ev, ev_signal_next);
d897 1
a897 1
		TAILQ_INSERT_TAIL(&signalqueue, ev, ev_signal_next);
@


1.16
log
@Avoid double recacl when loop_once is used.
From libevent SVN via brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.15 2007/02/04 18:59:12 millert Exp $	*/
d61 3
d88 3
d154 2
a155 1
	
d157 3
d186 1
a186 1
	
d190 1
a190 1
	
d218 1
a218 1
	if (base == current_base)
d306 2
d310 1
a310 1
		
d418 1
a418 1
		
d628 1
a628 1
			
@


1.15
log
@Two libevent fixes from the SVN repo:
allow gotsig to terminate active event loop and evbuffer_find fix.
OK brad@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.14 2006/11/05 03:39:40 brad Exp $	*/
a366 4
	/* Calculate the initial events that we are waiting for */
	if (evsel->recalc(base, evbase, 0) == -1)
		return (-1);

d369 4
a425 3

		if (evsel->recalc(base, evbase, 0) == -1)
			return (-1);
@


1.14
log
@fix a potential memory leak in event_once().

From Niels Provos via the libevent SVN repo, by Scott Lamb

tested by niallo@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.13 2006/03/30 06:32:36 brad Exp $	*/
d306 2
@


1.13
log
@introduce a way to free the base.

From libevent CVS
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.12 2006/03/28 15:32:13 brad Exp $	*/
d461 1
d490 5
a494 1
	event_add(&eonce->ev, tv);
@


1.12
log
@use clock_gettime if available.

From claudio@@ via libevent CVS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.11 2005/07/02 07:15:13 grunk Exp $	*/
d201 27
d569 1
@


1.11
log
@zap trailing whitespaces, no binary change

ok brad@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.10 2005/05/04 03:17:48 brad Exp $	*/
d143 17
d175 1
a175 1
	gettimeofday(&current_base->event_tv, NULL);
d363 1
a363 1
		gettimeofday(&tv, NULL);
d524 1
d539 6
a544 2
	if (tv != NULL && (flags & event & EV_TIMEOUT))
		*tv = ev->ev_timeout;
d588 1
a588 1
		gettimeofday(&now, NULL);
d684 1
a684 1
	if (gettimeofday(&now, NULL) == -1)
d720 1
a720 1
	gettimeofday(&now, NULL);
@


1.10
log
@update to libevent 1.0d; keep local changes

thanks to Alexander von Gernler for testing
and some bug fixes

ok mpf@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.9 2005/04/22 00:56:25 brad Exp $	*/
d43 1
a43 1
#else 
d174 1
a174 1
	if (!issetugid() && getenv("EVENT_SHOW_METHOD")) 
d805 1
a805 1
/* 
@


1.9
log
@update to libevent 1.0c; keep local changes

no shared lib so no ABI/API check is necessary

thanks to Alexander von Gernler for submitting
another diff in an attempt to update libevent
and for a use-after-free fix.

ok henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.7 2005/04/19 02:03:12 brad Exp $	*/
d441 1
d477 1
a477 1
	ev->ev_pri = current_base->nactivequeues/2;
@


1.8
log
@backout.  not discussed, and very wrong.  bad brad
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.6 2005/04/13 16:15:09 reyk Exp $	*/
a54 1
#include <err.h>
d57 2
a58 1
#ifdef USE_LOG
a59 6
#else
#define LOG_DBG(x)
#define log_error(x)	perror(x)
#endif

#include "event.h"
d76 3
d91 3
d109 4
a112 2
const struct eventop *evsel;
void *evbase;
a116 1
volatile sig_atomic_t event_gotterm;	/* Set to terminate loop */
d119 9
a127 11
void		event_queue_insert(struct event *, int);
void		event_queue_remove(struct event *, int);
int		event_haveevents(void);

static void	event_process_active(void);

static RB_HEAD(event_tree, event) timetree;
static struct event_list activequeue;
struct event_list signalqueue;
struct event_list eventqueue;
static struct timeval event_tv;
d138 1
a138 1
	if (a > b)
d148 1
a148 1
void
d153 3
d158 1
a158 1
	gettimeofday(&event_tv, NULL);
d160 2
a161 3
	RB_INIT(&timetree);
	TAILQ_INIT(&eventqueue);
	TAILQ_INIT(&activequeue);
d164 3
a166 3
	evbase = NULL;
	for (i = 0; eventops[i] && !evbase; i++) {
		evsel = eventops[i];
d168 1
a168 1
		evbase = evsel->init();
d171 2
a172 2
	if (evbase == NULL)
		errx(1, "%s: no event mechanism available", __func__);
d175 5
a179 1
		fprintf(stderr, "libevent using: %s\n", evsel->name); 
d181 39
a219 4
#if defined(USE_LOG) && defined(USE_DEBUG)
	log_to(stderr);
	log_debug_cmd(LOG_MISC, 80);
#endif
d223 1
a223 1
event_haveevents(void)
d225 1
a225 2
	return (RB_ROOT(&timetree) || TAILQ_FIRST(&eventqueue) ||
	    TAILQ_FIRST(&signalqueue) || TAILQ_FIRST(&activequeue));
d228 6
d235 1
a235 1
event_process_active(void)
d238 2
d242 12
a253 3
	for (ev = TAILQ_FIRST(&activequeue); ev;
	    ev = TAILQ_FIRST(&activequeue)) {
		event_queue_remove(ev, EVLIST_ACTIVE);
d276 6
d285 2
a286 1
	event_gotterm = 1;
d289 2
d294 2
a295 1
	return (event_once(-1, EV_TIMEOUT, event_loopexit_cb, NULL, tv));
d299 9
d310 8
d322 1
a322 1
	if (evsel->recalc(evbase, 0) == -1)
d328 2
a329 2
		if (event_gotterm) {
			event_gotterm = 0;
d333 1
d347 1
a347 1
		if (timercmp(&tv, &event_tv, <)) {
d349 1
a349 2
			LOG_DBG((LOG_MISC, 10,
				    "%s: time is running backwards, corrected",
d351 2
a352 3

			timersub(&event_tv, &tv, &off);
			timeout_correct(&off);
d354 1
a354 1
		event_tv = tv;
d356 2
a357 2
		if (!(flags & EVLOOP_NONBLOCK))
			timeout_next(&tv);
d362 2
a363 1
		if (!event_haveevents())
d365 1
d367 1
a367 1
		res = evsel->dispatch(evbase, &tv);
d372 1
a372 1
		timeout_process();
d374 3
a376 3
		if (TAILQ_FIRST(&activequeue)) {
			event_process_active();
			if (flags & EVLOOP_ONCE)
d381 1
a381 1
		if (evsel->recalc(evbase, 0) == -1)
d385 1
d425 3
a433 3
		eonce->cb = callback;
		eonce->arg = arg;

d453 3
a457 4
#ifdef WIN32
	ev->ev_fd = (HANDLE)fd;
	ev->overlap.hEvent = ev;
#else
a458 1
#endif
d463 34
d529 5
a533 1
	LOG_DBG((LOG_MISC, 55,
d547 1
a547 1
			event_queue_remove(ev, EVLIST_TIMEOUT);
d562 1
a562 1
			event_queue_remove(ev, EVLIST_ACTIVE);
d568 1
a568 1
		LOG_DBG((LOG_MISC, 55,
d572 1
a572 1
		event_queue_insert(ev, EVLIST_TIMEOUT);
d577 1
a577 1
		event_queue_insert(ev, EVLIST_INSERTED);
d582 1
a582 1
		event_queue_insert(ev, EVLIST_SIGNAL);
d593 5
a597 1
	LOG_DBG((LOG_MISC, 80, "event_del: %p, callback %p",
d600 8
d617 1
a617 1
		event_queue_remove(ev, EVLIST_TIMEOUT);
d620 1
a620 1
		event_queue_remove(ev, EVLIST_ACTIVE);
d623 1
a623 1
		event_queue_remove(ev, EVLIST_INSERTED);
d626 1
a626 1
		event_queue_remove(ev, EVLIST_SIGNAL);
d645 1
a645 1
	event_queue_insert(ev, EVLIST_ACTIVE);
d649 1
a649 1
timeout_next(struct timeval *tv)
d656 1
a656 1
	if ((ev = RB_MIN(event_tree, &timetree)) == NULL) {
d674 1
a674 1
	LOG_DBG((LOG_MISC, 60, "timeout_next: in %d seconds", tv->tv_sec));
d678 2
a679 2
void
timeout_correct(struct timeval *off)
d683 2
a684 1
	/* We can modify the key element of the node without destroying
d687 1
a687 1
	RB_FOREACH(ev, event_tree, &timetree)
d692 1
a692 1
timeout_process(void)
d699 1
a699 1
	for (ev = RB_MIN(event_tree, &timetree); ev; ev = next) {
d702 1
a702 1
		next = RB_NEXT(event_tree, &timetree, ev);
d704 1
a704 1
		event_queue_remove(ev, EVLIST_TIMEOUT);
d709 1
a709 1
		LOG_DBG((LOG_MISC, 60, "timeout_process: call %p",
d716 1
a716 1
event_queue_remove(struct event *ev, int queue)
d718 2
d721 8
a728 2
		errx(1, "%s: %p(fd %d) not on queue %x", __func__,
		    ev, ev->ev_fd, queue);
d733 4
a736 1
		TAILQ_REMOVE(&activequeue, ev, ev_active_next);
d742 1
a742 1
		RB_REMOVE(event_tree, &timetree, ev);
d745 1
a745 1
		TAILQ_REMOVE(&eventqueue, ev, ev_next);
d748 1
a748 1
		errx(1, "%s: unknown queue %x", __func__, queue);
d753 1
a753 1
event_queue_insert(struct event *ev, int queue)
d755 16
a770 3
	if (ev->ev_flags & queue)
		errx(1, "%s: %p(fd %d) already on queue %x", __func__,
		    ev, ev->ev_fd, queue);
d775 4
a778 1
		TAILQ_INSERT_TAIL(&activequeue, ev, ev_active_next);
d784 1
a784 1
		struct event *tmp = RB_INSERT(event_tree, &timetree, ev);
d789 1
a789 1
		TAILQ_INSERT_TAIL(&eventqueue, ev, ev_next);
d792 1
a792 1
		errx(1, "%s: unknown queue %x", __func__, queue);
d794 19
@


1.7
log
@update to libevent 1.0c; keep local changes
@
text
@d55 1
d58 7
a65 2
#include "event-internal.h"
#include "log.h"
a81 3
#ifdef HAVE_DEVPOLL
extern const struct eventop devpollops;
#endif
a93 3
#ifdef HAVE_DEVPOLL
	&devpollops,
#endif
d109 2
a110 4
/* Global state */
struct event_list signalqueue;

struct event_base *current_base = NULL;
d115 1
d118 11
a128 9
static void	event_queue_insert(struct event_base *, struct event *, int);
static void	event_queue_remove(struct event_base *, struct event *, int);
static int	event_haveevents(struct event_base *);

static void	event_process_active(struct event_base *);

static int	timeout_next(struct event_base *, struct timeval *);
static void	timeout_process(struct event_base *);
static void	timeout_correct(struct event_base *, struct timeval *);
d139 1
a139 1
	else if (a > b)
d149 1
a149 1
void *
a153 3
	if ((current_base = calloc(1, sizeof(struct event_base))) == NULL)
		event_err(1, "%s: calloc");

d156 1
a156 1
	gettimeofday(&current_base->event_tv, NULL);
d158 3
a160 2
	RB_INIT(&current_base->timetree);
	TAILQ_INIT(&current_base->eventqueue);
d163 3
a165 3
	current_base->evbase = NULL;
	for (i = 0; eventops[i] && !current_base->evbase; i++) {
		current_base->evsel = eventops[i];
d167 1
a167 1
		current_base->evbase = current_base->evsel->init();
d170 2
a171 2
	if (current_base->evbase == NULL)
		event_errx(1, "%s: no event mechanism available", __func__);
d174 1
a174 2
		event_msgx("libevent using: %s\n",
			   current_base->evsel->name);
d176 4
a179 4
	/* allocate a single active event queue */
	event_base_priority_init(current_base, 1);

	return (current_base);
d183 1
a183 1
event_priority_init(int npriorities)
d185 2
a186 1
  return event_base_priority_init(current_base, npriorities);
a188 44
int
event_base_priority_init(struct event_base *base, int npriorities)
{
	int i;

	if (base->event_count_active)
		return (-1);

	if (base->nactivequeues && npriorities != base->nactivequeues) {
		for (i = 0; i < base->nactivequeues; ++i) {
			free(base->activequeues[i]);
		}
		free(base->activequeues);
	}

	/* Allocate our priority queues */
	base->nactivequeues = npriorities;
	base->activequeues = (struct event_list **)calloc(base->nactivequeues,
	    npriorities * sizeof(struct event_list *));
	if (base->activequeues == NULL)
		event_err(1, "%s: calloc", __func__);

	for (i = 0; i < base->nactivequeues; ++i) {
		base->activequeues[i] = malloc(sizeof(struct event_list));
		if (base->activequeues[i] == NULL)
			event_err(1, "%s: malloc", __func__);
		TAILQ_INIT(base->activequeues[i]);
	}

	return (0);
}

int
event_haveevents(struct event_base *base)
{
	return (base->event_count > 0);
}

/*
 * Active events are stored in priority queues.  Lower priorities are always
 * process before higher priorities.  Low priority events can starve high
 * priority ones.
 */

d190 1
a190 1
event_process_active(struct event_base *base)
a192 2
	struct event_list *activeq = NULL;
	int i;
d195 3
a197 12
	if (!base->event_count_active)
		return;

	for (i = 0; i < base->nactivequeues; ++i) {
		if (TAILQ_FIRST(base->activequeues[i]) != NULL) {
			activeq = base->activequeues[i];
			break;
		}
	}

	for (ev = TAILQ_FIRST(activeq); ev; ev = TAILQ_FIRST(activeq)) {
		event_queue_remove(base, ev, EVLIST_ACTIVE);
a219 6
int
event_base_dispatch(struct event_base *event_base)
{
  return (event_base_loop(event_base, 0));
}

d223 1
a223 2
	struct event_base *base = arg;
	base->event_gotterm = 1;
a225 2
/* not thread safe */

d229 1
a229 2
	return (event_once(-1, EV_TIMEOUT, event_loopexit_cb,
		    current_base, tv));
a232 9
event_base_loopexit(struct event_base *event_base, struct timeval *tv)
{
	return (event_once(-1, EV_TIMEOUT, event_loopexit_cb,
		    event_base, tv));
}

/* not thread safe */

int
a234 8
	return event_base_loop(current_base, flags);
}

int
event_base_loop(struct event_base *base, int flags)
{
	const struct eventop *evsel = base->evsel;
	void *evbase = base->evbase;
d239 1
a239 1
	if (evsel->recalc(base, evbase, 0) == -1)
d245 2
a246 2
		if (base->event_gotterm) {
			base->event_gotterm = 0;
a249 1
		/* You cannot use this interface for multi-threaded apps */
d263 1
a263 1
		if (timercmp(&tv, &base->event_tv, <)) {
d265 2
a266 1
			event_debug(("%s: time is running backwards, corrected",
d268 3
a270 2
			timersub(&base->event_tv, &tv, &off);
			timeout_correct(base, &off);
d272 1
a272 1
		base->event_tv = tv;
d274 2
a275 2
		if (!base->event_count_active && !(flags & EVLOOP_NONBLOCK))
			timeout_next(base, &tv);
d280 1
a280 2
		if (!event_haveevents(base)) {
			event_debug(("%s: no events registered.", __func__));
a281 1
		}
d283 1
a283 1
		res = evsel->dispatch(base, evbase, &tv);
d288 1
a288 1
		timeout_process(base);
d290 3
a292 3
		if (base->event_count_active) {
			event_process_active(base);
			if (!base->event_count_active && (flags & EVLOOP_ONCE))
d297 1
a297 1
		if (evsel->recalc(base, evbase, 0) == -1)
a300 1
	event_debug(("%s: asked to terminate loop.", __func__));
a339 3
	eonce->cb = callback;
	eonce->arg = arg;

d346 3
a367 3
	/* Take the current base - caller needs to set the real base later */
	ev->ev_base = current_base;

d370 4
d375 1
a379 34

	/* by default, we put new events into the middle priority */
	ev->ev_pri = current_base->nactivequeues/2;
}

int
event_base_set(struct event_base *base, struct event *ev)
{
	/* Only innocent events may be assigned to a different base */
	if (ev->ev_flags != EVLIST_INIT)
		return (-1);

	ev->ev_base = base;
	ev->ev_pri = current_base->nactivequeues/2;

	return (0);
}

/*
 * Set's the priority of an event - if an event is already scheduled
 * changing the priority is going to fail.
 */

int
event_priority_set(struct event *ev, int pri)
{
	if (ev->ev_flags & EVLIST_ACTIVE)
		return (-1);
	if (pri < 0 || pri >= ev->ev_base->nactivequeues)
		return (-1);

	ev->ev_pri = pri;

	return (0);
d412 1
a412 5
	struct event_base *base = ev->ev_base;
	const struct eventop *evsel = base->evsel;
	void *evbase = base->evbase;

	event_debug((
d426 1
a426 1
			event_queue_remove(base, ev, EVLIST_TIMEOUT);
d441 1
a441 1
			event_queue_remove(base, ev, EVLIST_ACTIVE);
d447 1
a447 1
		event_debug((
d451 1
a451 1
		event_queue_insert(base, ev, EVLIST_TIMEOUT);
d456 1
a456 1
		event_queue_insert(base, ev, EVLIST_INSERTED);
d461 1
a461 1
		event_queue_insert(base, ev, EVLIST_SIGNAL);
d472 1
a472 5
	struct event_base *base;
	const struct eventop *evsel;
	void *evbase;

	event_debug(("event_del: %p, callback %p",
a474 8
	/* An event without a base has not been added */
	if (ev->ev_base == NULL)
		return (-1);

	base = ev->ev_base;
	evsel = base->evsel;
	evbase = base->evbase;

d484 1
a484 1
		event_queue_remove(base, ev, EVLIST_TIMEOUT);
d487 1
a487 1
		event_queue_remove(base, ev, EVLIST_ACTIVE);
d490 1
a490 1
		event_queue_remove(base, ev, EVLIST_INSERTED);
d493 1
a493 1
		event_queue_remove(base, ev, EVLIST_SIGNAL);
d512 1
a512 1
	event_queue_insert(ev->ev_base, ev, EVLIST_ACTIVE);
d516 1
a516 1
timeout_next(struct event_base *base, struct timeval *tv)
d523 1
a523 1
	if ((ev = RB_MIN(event_tree, &base->timetree)) == NULL) {
d541 1
a541 1
	event_debug(("timeout_next: in %d seconds", tv->tv_sec));
d545 2
a546 2
static void
timeout_correct(struct event_base *base, struct timeval *off)
d550 1
a550 2
	/*
	 * We can modify the key element of the node without destroying
d553 1
a553 1
	RB_FOREACH(ev, event_tree, &base->timetree)
d558 1
a558 1
timeout_process(struct event_base *base)
d565 1
a565 1
	for (ev = RB_MIN(event_tree, &base->timetree); ev; ev = next) {
d568 1
a568 1
		next = RB_NEXT(event_tree, &base->timetree, ev);
d570 1
a570 1
		event_queue_remove(base, ev, EVLIST_TIMEOUT);
d575 1
a575 1
		event_debug(("timeout_process: call %p",
d582 1
a582 1
event_queue_remove(struct event_base *base, struct event *ev, int queue)
a583 2
	int docount = 1;

d585 2
a586 8
		event_errx(1, "%s: %p(fd %d) not on queue %x", __func__,
			   ev, ev->ev_fd, queue);

	if (ev->ev_flags & EVLIST_INTERNAL)
		docount = 0;

	if (docount)
		base->event_count--;
d591 1
a591 4
		if (docount)
			base->event_count_active--;
		TAILQ_REMOVE(base->activequeues[ev->ev_pri],
		    ev, ev_active_next);
d597 1
a597 1
		RB_REMOVE(event_tree, &base->timetree, ev);
d600 1
a600 1
		TAILQ_REMOVE(&base->eventqueue, ev, ev_next);
d603 1
a603 1
		event_errx(1, "%s: unknown queue %x", __func__, queue);
d608 1
a608 1
event_queue_insert(struct event_base *base, struct event *ev, int queue)
d610 3
a612 16
	int docount = 1;

	if (ev->ev_flags & queue) {
		/* Double insertion is possible for active events */
		if (queue & EVLIST_ACTIVE)
			return;

		event_errx(1, "%s: %p(fd %d) already on queue %x", __func__,
			   ev, ev->ev_fd, queue);
	}

	if (ev->ev_flags & EVLIST_INTERNAL)
		docount = 0;

	if (docount)
		base->event_count++;
d617 1
a617 4
		if (docount)
			base->event_count_active++;
		TAILQ_INSERT_TAIL(base->activequeues[ev->ev_pri],
		    ev,ev_active_next);
d623 1
a623 1
		struct event *tmp = RB_INSERT(event_tree, &base->timetree, ev);
d628 1
a628 1
		TAILQ_INSERT_TAIL(&base->eventqueue, ev, ev_next);
d631 1
a631 1
		event_errx(1, "%s: unknown queue %x", __func__, queue);
a632 19
}

/* Functions for debugging */

const char *
event_get_version(void)
{
	return (LIBEVENT_VERSION);
}

/* 
 * No thread-safe interface needed - the information should be the same
 * for all threads.
 */

const char *
event_get_method(void)
{
	return (current_base->evsel->name);
@


1.6
log
@use "volatile sig_atomic_t" types instead of "int" for signal flags.

ok deraadt@@ henning@@ provos
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.5 2004/04/28 06:53:12 brad Exp $	*/
a54 1
#include <err.h>
d57 2
a58 1
#ifdef USE_LOG
a59 6
#else
#define LOG_DBG(x)
#define log_error(x)	perror(x)
#endif

#include "event.h"
d76 3
d91 3
d109 4
a112 2
const struct eventop *evsel;
void *evbase;
a116 1
volatile sig_atomic_t event_gotterm;	/* Set to terminate loop */
d119 9
a127 11
void		event_queue_insert(struct event *, int);
void		event_queue_remove(struct event *, int);
int		event_haveevents(void);

static void	event_process_active(void);

static RB_HEAD(event_tree, event) timetree;
static struct event_list activequeue;
struct event_list signalqueue;
struct event_list eventqueue;
static struct timeval event_tv;
d138 1
a138 1
	if (a > b)
d148 1
a148 1
void
d153 3
d158 1
a158 1
	gettimeofday(&event_tv, NULL);
d160 2
a161 3
	RB_INIT(&timetree);
	TAILQ_INIT(&eventqueue);
	TAILQ_INIT(&activequeue);
d164 3
a166 3
	evbase = NULL;
	for (i = 0; eventops[i] && !evbase; i++) {
		evsel = eventops[i];
d168 1
a168 1
		evbase = evsel->init();
d171 2
a172 2
	if (evbase == NULL)
		errx(1, "%s: no event mechanism available", __func__);
d175 5
a179 1
		fprintf(stderr, "libevent using: %s\n", evsel->name); 
d181 39
a219 4
#if defined(USE_LOG) && defined(USE_DEBUG)
	log_to(stderr);
	log_debug_cmd(LOG_MISC, 80);
#endif
d223 1
a223 1
event_haveevents(void)
d225 1
a225 2
	return (RB_ROOT(&timetree) || TAILQ_FIRST(&eventqueue) ||
	    TAILQ_FIRST(&signalqueue) || TAILQ_FIRST(&activequeue));
d228 6
d235 1
a235 1
event_process_active(void)
d238 2
d242 12
a253 3
	for (ev = TAILQ_FIRST(&activequeue); ev;
	    ev = TAILQ_FIRST(&activequeue)) {
		event_queue_remove(ev, EVLIST_ACTIVE);
d276 6
d285 2
a286 1
	event_gotterm = 1;
d289 2
d294 2
a295 1
	return (event_once(-1, EV_TIMEOUT, event_loopexit_cb, NULL, tv));
d299 9
d310 8
d322 1
a322 1
	if (evsel->recalc(evbase, 0) == -1)
d328 2
a329 2
		if (event_gotterm) {
			event_gotterm = 0;
d333 1
d347 1
a347 1
		if (timercmp(&tv, &event_tv, <)) {
d349 1
a349 2
			LOG_DBG((LOG_MISC, 10,
				    "%s: time is running backwards, corrected",
d351 2
a352 3

			timersub(&event_tv, &tv, &off);
			timeout_correct(&off);
d354 1
a354 1
		event_tv = tv;
d356 2
a357 2
		if (!(flags & EVLOOP_NONBLOCK))
			timeout_next(&tv);
d362 2
a363 1
		if (!event_haveevents())
d365 1
d367 1
a367 1
		res = evsel->dispatch(evbase, &tv);
d372 1
a372 1
		timeout_process();
d374 3
a376 3
		if (TAILQ_FIRST(&activequeue)) {
			event_process_active();
			if (flags & EVLOOP_ONCE)
d381 1
a381 1
		if (evsel->recalc(evbase, 0) == -1)
d385 1
d425 3
a433 3
		eonce->cb = callback;
		eonce->arg = arg;

d453 3
a457 4
#ifdef WIN32
	ev->ev_fd = (HANDLE)fd;
	ev->overlap.hEvent = ev;
#else
a458 1
#endif
d463 34
d529 5
a533 1
	LOG_DBG((LOG_MISC, 55,
d547 1
a547 1
			event_queue_remove(ev, EVLIST_TIMEOUT);
d562 1
a562 1
			event_queue_remove(ev, EVLIST_ACTIVE);
d568 1
a568 1
		LOG_DBG((LOG_MISC, 55,
d572 1
a572 1
		event_queue_insert(ev, EVLIST_TIMEOUT);
d577 1
a577 1
		event_queue_insert(ev, EVLIST_INSERTED);
d582 1
a582 1
		event_queue_insert(ev, EVLIST_SIGNAL);
d593 5
a597 1
	LOG_DBG((LOG_MISC, 80, "event_del: %p, callback %p",
d600 8
d617 1
a617 1
		event_queue_remove(ev, EVLIST_TIMEOUT);
d620 1
a620 1
		event_queue_remove(ev, EVLIST_ACTIVE);
d623 1
a623 1
		event_queue_remove(ev, EVLIST_INSERTED);
d626 1
a626 1
		event_queue_remove(ev, EVLIST_SIGNAL);
d645 1
a645 1
	event_queue_insert(ev, EVLIST_ACTIVE);
d649 1
a649 1
timeout_next(struct timeval *tv)
d656 1
a656 1
	if ((ev = RB_MIN(event_tree, &timetree)) == NULL) {
d674 1
a674 1
	LOG_DBG((LOG_MISC, 60, "timeout_next: in %d seconds", tv->tv_sec));
d678 2
a679 2
void
timeout_correct(struct timeval *off)
d683 2
a684 1
	/* We can modify the key element of the node without destroying
d687 1
a687 1
	RB_FOREACH(ev, event_tree, &timetree)
d692 1
a692 1
timeout_process(void)
d699 1
a699 1
	for (ev = RB_MIN(event_tree, &timetree); ev; ev = next) {
d702 1
a702 1
		next = RB_NEXT(event_tree, &timetree, ev);
d704 1
a704 1
		event_queue_remove(ev, EVLIST_TIMEOUT);
d709 1
a709 1
		LOG_DBG((LOG_MISC, 60, "timeout_process: call %p",
d716 1
a716 1
event_queue_remove(struct event *ev, int queue)
d718 2
d721 8
a728 2
		errx(1, "%s: %p(fd %d) not on queue %x", __func__,
		    ev, ev->ev_fd, queue);
d733 4
a736 1
		TAILQ_REMOVE(&activequeue, ev, ev_active_next);
d742 1
a742 1
		RB_REMOVE(event_tree, &timetree, ev);
d745 1
a745 1
		TAILQ_REMOVE(&eventqueue, ev, ev_next);
d748 1
a748 1
		errx(1, "%s: unknown queue %x", __func__, queue);
d753 1
a753 1
event_queue_insert(struct event *ev, int queue)
d755 16
a770 3
	if (ev->ev_flags & queue)
		errx(1, "%s: %p(fd %d) already on queue %x", __func__,
		    ev, ev->ev_fd, queue);
d775 4
a778 1
		TAILQ_INSERT_TAIL(&activequeue, ev, ev_active_next);
d784 1
a784 1
		struct event *tmp = RB_INSERT(event_tree, &timetree, ev);
d789 1
a789 1
		TAILQ_INSERT_TAIL(&eventqueue, ev, ev_next);
d792 1
a792 1
		errx(1, "%s: unknown queue %x", __func__, queue);
d794 19
@


1.5
log
@update to libevent 0.8; keep local changes

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.4 2003/07/09 10:54:38 markus Exp $	*/
d53 1
d113 3
a115 3
int (*event_sigcb)(void);	/* Signal callback when gotsig is set */
int event_gotsig;		/* Set in signal handler */
int event_gotterm;		/* Set to terminate loop */
@


1.4
log
@update to libevent-0.7a.tar.gz; keep local changes
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.3 2003/06/19 18:52:12 mickey Exp $	*/
d4 1
a4 1
 * Copyright 2000-2002 Niels Provos <provos@@citi.umich.edu>
d15 1
a15 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
d33 6
d49 1
d51 1
d70 4
a73 1
extern struct eventop pollops;
d76 1
a76 1
extern struct eventop epollops;
d81 3
d93 3
d102 3
d111 1
a111 1
/* Handle signals */
d114 1
d117 5
a121 2
void	event_queue_insert(struct event *, int);
void	event_queue_remove(struct event *, int);
d136 4
d188 1
a188 1
void
d204 1
a204 1
			(*ev->ev_callback)(ev->ev_fd, ev->ev_res, ev->ev_arg);
d209 4
d219 12
d243 6
d264 1
a264 1
			LOG_DBG((LOG_MIST, 10,
d303 60
d369 4
d374 1
d396 2
d399 1
a399 1
	event &= (EV_TIMEOUT|EV_READ|EV_WRITE);
d537 3
a580 25
timeout_insert(struct event *ev)
{
	struct event *tmp;

	tmp = RB_FIND(event_tree, &timetree, ev);

	if (tmp != NULL) {
		struct timeval tv;
		struct timeval add = {0,1};

		/* Find unique time */
		tv = ev->ev_timeout;
		do {
			timeradd(&tv, &add, &tv);
			tmp = RB_NEXT(event_tree, &timetree, tmp);
		} while (tmp != NULL && timercmp(&tmp->ev_timeout, &tv, ==));

		ev->ev_timeout = tv;
	}

	tmp = RB_INSERT(event_tree, &timetree, ev);
	assert(tmp == NULL);
}

void
d621 3
a623 2
	case EVLIST_TIMEOUT:
		timeout_insert(ev);
d625 1
@


1.3
log
@constify constant structures; niels ok
@
text
@d1 1
a1 1
/*	$OpenBSD: event.c,v 1.2 2002/06/25 15:50:15 mickey Exp $	*/
d32 1
d34 1
d38 1
d40 3
d64 6
d79 6
d144 6
d219 1
a219 1
				    __FUNCTION__));
d313 16
d340 1
a340 1
	    !(ev->ev_flags & EVLIST_INSERTED)) {
d492 1
a492 1
		errx(1, "%s: %p(fd %d) not on queue %x", __FUNCTION__,
d510 1
a510 1
		errx(1, "%s: unknown queue %x", __FUNCTION__, queue);
d518 1
a518 1
		errx(1, "%s: %p(fd %d) already on queue %x", __FUNCTION__,
d536 1
a536 1
		errx(1, "%s: unknown queue %x", __FUNCTION__, queue);
@


1.2
log
@rcsids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a56 1
extern struct eventop selectops;
d59 1
a59 1
extern struct eventop kqops;
d63 1
a63 1
struct eventop *eventops[] = {
d73 1
a73 1
struct eventop *evsel;
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@import libevent an event notification abstraction on top of select or kqueue
supporting timeout and signal callsbacks, too.  okay deraadt@@ millert@@
@
text
@@
