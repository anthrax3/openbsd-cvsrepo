head	1.28;
access;
symbols
	OPENBSD_6_1:1.28.0.2
	OPENBSD_6_1_BASE:1.28;
locks; strict;
comment	@ * @;


1.28
date	2017.02.07.02.08.38;	author beck;	state Exp;
branches;
next	1.27;
commitid	xH3OeartUDKSlAnB;

1.27
date	2017.01.26.12.16.13;	author beck;	state Exp;
branches;
next	1.26;
commitid	lb4UTPLS9Casn2PL;

1.26
date	2017.01.26.10.40.21;	author beck;	state Exp;
branches;
next	1.25;
commitid	Bi1VygMenL4YtCp7;

1.25
date	2017.01.24.14.57.31;	author jsing;	state Exp;
branches;
next	1.24;
commitid	nQzaI20w3vrSZN0L;

1.24
date	2017.01.23.22.34.38;	author beck;	state Exp;
branches;
next	1.23;
commitid	LjSyQ9gcPyeZpDNB;

1.23
date	2017.01.23.05.13.02;	author jsing;	state Exp;
branches;
next	1.22;
commitid	XWcFqNClp2MoKERU;

1.22
date	2017.01.23.04.15.28;	author jsing;	state Exp;
branches;
next	1.21;
commitid	j20UnjrPw7WvzMvm;

1.21
date	2016.03.11.07.08.45;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	MTdM7aVFdRMAzAYE;

1.20
date	2015.02.06.01.37.11;	author reyk;	state Exp;
branches;
next	1.19;
commitid	Lv0p59uUkApDv6rT;

1.19
date	2014.12.14.15.30.50;	author jsing;	state Exp;
branches;
next	1.18;
commitid	XNZawfRSWvnVv1VS;

1.18
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.17;
commitid	M3pvHgIFoWUHNqJn;

1.17
date	2014.09.28.14.45.48;	author reyk;	state Exp;
branches;
next	1.16;
commitid	3rzcEvcae6gEJLgr;

1.16
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches;
next	1.15;
commitid	G74O1dmRukKsW7IJ;

1.15
date	2014.06.22.19.09.37;	author guenther;	state Exp;
branches;
next	1.14;
commitid	oOnzFvY6h42SBmEm;

1.14
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	mJUVYpkFBZ0Zv2bG;

1.13
date	2014.06.07.14.35.31;	author jsing;	state Exp;
branches;
next	1.12;
commitid	moce2ayovF9fb7cV;

1.12
date	2014.05.29.18.27.52;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.17.21.37.37;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.14.13.10.35;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.54;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.29.05.39.31;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.11.22.15.20;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.30;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.11;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.11;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.42;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.44.35;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.11.11.21.21.29;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.28;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Change SSLerror() back to taking two args, with the first one being an SSL *.
Make a table of "function codes" which maps the internal state of the SSL *
to something like a useful name so in a typical error in the connection you
know in what sort of place in the handshake things happened. (instead of
by arcane function name).
Add SSLerrorx() for when we don't have an SSL *
ok jsing@@ after us both being prodded by bluhm@@ to make it not terrible
@
text
@/* $OpenBSD: ssl_rsa.c,v 1.27 2017/01/26 12:16:13 beck Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <stdio.h>

#include "ssl_locl.h"

#include <openssl/bio.h>
#include <openssl/evp.h>
#include <openssl/objects.h>
#include <openssl/pem.h>
#include <openssl/x509.h>

static int ssl_set_cert(CERT *c, X509 *x509);
static int ssl_set_pkey(CERT *c, EVP_PKEY *pkey);
static int ssl_ctx_use_certificate_chain_bio(SSL_CTX *, BIO *);

int
SSL_use_certificate(SSL *ssl, X509 *x)
{
	if (x == NULL) {
		SSLerror(ssl, ERR_R_PASSED_NULL_PARAMETER);
		return (0);
	}
	if (!ssl_cert_inst(&ssl->cert)) {
		SSLerror(ssl, ERR_R_MALLOC_FAILURE);
		return (0);
	}
	return (ssl_set_cert(ssl->cert, x));
}

int
SSL_use_certificate_file(SSL *ssl, const char *file, int type)
{
	int j;
	BIO *in;
	int ret = 0;
	X509 *x = NULL;

	in = BIO_new(BIO_s_file_internal());
	if (in == NULL) {
		SSLerror(ssl, ERR_R_BUF_LIB);
		goto end;
	}

	if (BIO_read_filename(in, file) <= 0) {
		SSLerror(ssl, ERR_R_SYS_LIB);
		goto end;
	}
	if (type == SSL_FILETYPE_ASN1) {
		j = ERR_R_ASN1_LIB;
		x = d2i_X509_bio(in, NULL);
	} else if (type == SSL_FILETYPE_PEM) {
		j = ERR_R_PEM_LIB;
		x = PEM_read_bio_X509(in, NULL,
		    ssl->ctx->default_passwd_callback,
		    ssl->ctx->default_passwd_callback_userdata);
	} else {
		SSLerror(ssl, SSL_R_BAD_SSL_FILETYPE);
		goto end;
	}

	if (x == NULL) {
		SSLerror(ssl, j);
		goto end;
	}

	ret = SSL_use_certificate(ssl, x);
end:
	X509_free(x);
	BIO_free(in);
	return (ret);
}

int
SSL_use_certificate_ASN1(SSL *ssl, const unsigned char *d, int len)
{
	X509 *x;
	int ret;

	x = d2i_X509(NULL, &d,(long)len);
	if (x == NULL) {
		SSLerror(ssl, ERR_R_ASN1_LIB);
		return (0);
	}

	ret = SSL_use_certificate(ssl, x);
	X509_free(x);
	return (ret);
}

int
SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa)
{
	EVP_PKEY *pkey;
	int ret;

	if (rsa == NULL) {
		SSLerror(ssl, ERR_R_PASSED_NULL_PARAMETER);
		return (0);
	}
	if (!ssl_cert_inst(&ssl->cert)) {
		SSLerror(ssl, ERR_R_MALLOC_FAILURE);
		return (0);
	}
	if ((pkey = EVP_PKEY_new()) == NULL) {
		SSLerror(ssl, ERR_R_EVP_LIB);
		return (0);
	}

	RSA_up_ref(rsa);
	EVP_PKEY_assign_RSA(pkey, rsa);

	ret = ssl_set_pkey(ssl->cert, pkey);
	EVP_PKEY_free(pkey);
	return (ret);
}

static int
ssl_set_pkey(CERT *c, EVP_PKEY *pkey)
{
	int i;

	i = ssl_cert_type(NULL, pkey);
	if (i < 0) {
		SSLerrorx(SSL_R_UNKNOWN_CERTIFICATE_TYPE);
		return (0);
	}

	if (c->pkeys[i].x509 != NULL) {
		EVP_PKEY *pktmp;
		pktmp = X509_get_pubkey(c->pkeys[i].x509);
		EVP_PKEY_copy_parameters(pktmp, pkey);
		EVP_PKEY_free(pktmp);
		ERR_clear_error();

		/*
		 * Don't check the public/private key, this is mostly
		 * for smart cards.
		 */
		if ((pkey->type == EVP_PKEY_RSA) &&
			(RSA_flags(pkey->pkey.rsa) & RSA_METHOD_FLAG_NO_CHECK))
;
		else
		if (!X509_check_private_key(c->pkeys[i].x509, pkey)) {
			X509_free(c->pkeys[i].x509);
			c->pkeys[i].x509 = NULL;
			return 0;
		}
	}

	EVP_PKEY_free(c->pkeys[i].privatekey);
	CRYPTO_add(&pkey->references, 1, CRYPTO_LOCK_EVP_PKEY);
	c->pkeys[i].privatekey = pkey;
	c->key = &(c->pkeys[i]);

	c->valid = 0;
	return (1);
}

int
SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type)
{
	int j, ret = 0;
	BIO *in;
	RSA *rsa = NULL;

	in = BIO_new(BIO_s_file_internal());
	if (in == NULL) {
		SSLerror(ssl, ERR_R_BUF_LIB);
		goto end;
	}

	if (BIO_read_filename(in, file) <= 0) {
		SSLerror(ssl, ERR_R_SYS_LIB);
		goto end;
	}
	if (type == SSL_FILETYPE_ASN1) {
		j = ERR_R_ASN1_LIB;
		rsa = d2i_RSAPrivateKey_bio(in, NULL);
	} else if (type == SSL_FILETYPE_PEM) {
		j = ERR_R_PEM_LIB;
		rsa = PEM_read_bio_RSAPrivateKey(in, NULL,
		    ssl->ctx->default_passwd_callback,
		    ssl->ctx->default_passwd_callback_userdata);
	} else {
		SSLerror(ssl, SSL_R_BAD_SSL_FILETYPE);
		goto end;
	}
	if (rsa == NULL) {
		SSLerror(ssl, j);
		goto end;
	}
	ret = SSL_use_RSAPrivateKey(ssl, rsa);
	RSA_free(rsa);
end:
	BIO_free(in);
	return (ret);
}

int
SSL_use_RSAPrivateKey_ASN1(SSL *ssl, unsigned char *d, long len)
{
	int ret;
	const unsigned char *p;
	RSA *rsa;

	p = d;
	if ((rsa = d2i_RSAPrivateKey(NULL, &p,(long)len)) == NULL) {
		SSLerror(ssl, ERR_R_ASN1_LIB);
		return (0);
	}

	ret = SSL_use_RSAPrivateKey(ssl, rsa);
	RSA_free(rsa);
	return (ret);
}

int
SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey)
{
	int ret;

	if (pkey == NULL) {
		SSLerror(ssl, ERR_R_PASSED_NULL_PARAMETER);
		return (0);
	}
	if (!ssl_cert_inst(&ssl->cert)) {
		SSLerror(ssl, ERR_R_MALLOC_FAILURE);
		return (0);
	}
	ret = ssl_set_pkey(ssl->cert, pkey);
	return (ret);
}

int
SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type)
{
	int j, ret = 0;
	BIO *in;
	EVP_PKEY *pkey = NULL;

	in = BIO_new(BIO_s_file_internal());
	if (in == NULL) {
		SSLerror(ssl, ERR_R_BUF_LIB);
		goto end;
	}

	if (BIO_read_filename(in, file) <= 0) {
		SSLerror(ssl, ERR_R_SYS_LIB);
		goto end;
	}
	if (type == SSL_FILETYPE_PEM) {
		j = ERR_R_PEM_LIB;
		pkey = PEM_read_bio_PrivateKey(in, NULL,
		    ssl->ctx->default_passwd_callback,
		    ssl->ctx->default_passwd_callback_userdata);
	} else if (type == SSL_FILETYPE_ASN1) {
		j = ERR_R_ASN1_LIB;
		pkey = d2i_PrivateKey_bio(in, NULL);
	} else {
		SSLerror(ssl, SSL_R_BAD_SSL_FILETYPE);
		goto end;
	}
	if (pkey == NULL) {
		SSLerror(ssl, j);
		goto end;
	}
	ret = SSL_use_PrivateKey(ssl, pkey);
	EVP_PKEY_free(pkey);
end:
	BIO_free(in);
	return (ret);
}

int
SSL_use_PrivateKey_ASN1(int type, SSL *ssl, const unsigned char *d, long len)
{
	int ret;
	const unsigned char *p;
	EVP_PKEY *pkey;

	p = d;
	if ((pkey = d2i_PrivateKey(type, NULL, &p,(long)len)) == NULL) {
		SSLerror(ssl, ERR_R_ASN1_LIB);
		return (0);
	}

	ret = SSL_use_PrivateKey(ssl, pkey);
	EVP_PKEY_free(pkey);
	return (ret);
}

int
SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x)
{
	if (x == NULL) {
		SSLerrorx(ERR_R_PASSED_NULL_PARAMETER);
		return (0);
	}
	if (!ssl_cert_inst(&ctx->internal->cert)) {
		SSLerrorx(ERR_R_MALLOC_FAILURE);
		return (0);
	}
	return (ssl_set_cert(ctx->internal->cert, x));
}

static int
ssl_set_cert(CERT *c, X509 *x)
{
	EVP_PKEY *pkey;
	int i;

	pkey = X509_get_pubkey(x);
	if (pkey == NULL) {
		SSLerrorx(SSL_R_X509_LIB);
		return (0);
	}

	i = ssl_cert_type(x, pkey);
	if (i < 0) {
		SSLerrorx(SSL_R_UNKNOWN_CERTIFICATE_TYPE);
		EVP_PKEY_free(pkey);
		return (0);
	}

	if (c->pkeys[i].privatekey != NULL) {
		EVP_PKEY_copy_parameters(pkey, c->pkeys[i].privatekey);
		ERR_clear_error();

		/*
		 * Don't check the public/private key, this is mostly
		 * for smart cards.
		 */
		if ((c->pkeys[i].privatekey->type == EVP_PKEY_RSA) &&
			(RSA_flags(c->pkeys[i].privatekey->pkey.rsa) &
		RSA_METHOD_FLAG_NO_CHECK))
;
		else
		if (!X509_check_private_key(x, c->pkeys[i].privatekey)) {
			/*
			 * don't fail for a cert/key mismatch, just free
			 * current private key (when switching to a different
			 * cert & key, first this function should be used,
			 * then ssl_set_pkey
			 */
			EVP_PKEY_free(c->pkeys[i].privatekey);
			c->pkeys[i].privatekey = NULL;
			/* clear error queue */
			ERR_clear_error();
		}
	}

	EVP_PKEY_free(pkey);

	X509_free(c->pkeys[i].x509);
	CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
	c->pkeys[i].x509 = x;
	c->key = &(c->pkeys[i]);

	c->valid = 0;
	return (1);
}

int
SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type)
{
	int j;
	BIO *in;
	int ret = 0;
	X509 *x = NULL;

	in = BIO_new(BIO_s_file_internal());
	if (in == NULL) {
		SSLerrorx(ERR_R_BUF_LIB);
		goto end;
	}

	if (BIO_read_filename(in, file) <= 0) {
		SSLerrorx(ERR_R_SYS_LIB);
		goto end;
	}
	if (type == SSL_FILETYPE_ASN1) {
		j = ERR_R_ASN1_LIB;
		x = d2i_X509_bio(in, NULL);
	} else if (type == SSL_FILETYPE_PEM) {
		j = ERR_R_PEM_LIB;
		x = PEM_read_bio_X509(in, NULL, ctx->default_passwd_callback,
		    ctx->default_passwd_callback_userdata);
	} else {
		SSLerrorx(SSL_R_BAD_SSL_FILETYPE);
		goto end;
	}

	if (x == NULL) {
		SSLerrorx(j);
		goto end;
	}

	ret = SSL_CTX_use_certificate(ctx, x);
end:
	X509_free(x);
	BIO_free(in);
	return (ret);
}

int
SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, const unsigned char *d)
{
	X509 *x;
	int ret;

	x = d2i_X509(NULL, &d,(long)len);
	if (x == NULL) {
		SSLerrorx(ERR_R_ASN1_LIB);
		return (0);
	}

	ret = SSL_CTX_use_certificate(ctx, x);
	X509_free(x);
	return (ret);
}

int
SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa)
{
	int ret;
	EVP_PKEY *pkey;

	if (rsa == NULL) {
		SSLerrorx(ERR_R_PASSED_NULL_PARAMETER);
		return (0);
	}
	if (!ssl_cert_inst(&ctx->internal->cert)) {
		SSLerrorx(ERR_R_MALLOC_FAILURE);
		return (0);
	}
	if ((pkey = EVP_PKEY_new()) == NULL) {
		SSLerrorx(ERR_R_EVP_LIB);
		return (0);
	}

	RSA_up_ref(rsa);
	EVP_PKEY_assign_RSA(pkey, rsa);

	ret = ssl_set_pkey(ctx->internal->cert, pkey);
	EVP_PKEY_free(pkey);
	return (ret);
}

int
SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type)
{
	int j, ret = 0;
	BIO *in;
	RSA *rsa = NULL;

	in = BIO_new(BIO_s_file_internal());
	if (in == NULL) {
		SSLerrorx(ERR_R_BUF_LIB);
		goto end;
	}

	if (BIO_read_filename(in, file) <= 0) {
		SSLerrorx(ERR_R_SYS_LIB);
		goto end;
	}
	if (type == SSL_FILETYPE_ASN1) {
		j = ERR_R_ASN1_LIB;
		rsa = d2i_RSAPrivateKey_bio(in, NULL);
	} else if (type == SSL_FILETYPE_PEM) {
		j = ERR_R_PEM_LIB;
		rsa = PEM_read_bio_RSAPrivateKey(in, NULL,
		    ctx->default_passwd_callback,
		    ctx->default_passwd_callback_userdata);
	} else {
		SSLerrorx(SSL_R_BAD_SSL_FILETYPE);
		goto end;
	}
	if (rsa == NULL) {
		SSLerrorx(j);
		goto end;
	}
	ret = SSL_CTX_use_RSAPrivateKey(ctx, rsa);
	RSA_free(rsa);
end:
	BIO_free(in);
	return (ret);
}

int
SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, const unsigned char *d, long len)
{
	int ret;
	const unsigned char *p;
	RSA *rsa;

	p = d;
	if ((rsa = d2i_RSAPrivateKey(NULL, &p,(long)len)) == NULL) {
		SSLerrorx(ERR_R_ASN1_LIB);
		return (0);
	}

	ret = SSL_CTX_use_RSAPrivateKey(ctx, rsa);
	RSA_free(rsa);
	return (ret);
}

int
SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey)
{
	if (pkey == NULL) {
		SSLerrorx(ERR_R_PASSED_NULL_PARAMETER);
		return (0);
	}
	if (!ssl_cert_inst(&ctx->internal->cert)) {
		SSLerrorx(ERR_R_MALLOC_FAILURE);
		return (0);
	}
	return (ssl_set_pkey(ctx->internal->cert, pkey));
}

int
SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type)
{
	int j, ret = 0;
	BIO *in;
	EVP_PKEY *pkey = NULL;

	in = BIO_new(BIO_s_file_internal());
	if (in == NULL) {
		SSLerrorx(ERR_R_BUF_LIB);
		goto end;
	}

	if (BIO_read_filename(in, file) <= 0) {
		SSLerrorx(ERR_R_SYS_LIB);
		goto end;
	}
	if (type == SSL_FILETYPE_PEM) {
		j = ERR_R_PEM_LIB;
		pkey = PEM_read_bio_PrivateKey(in, NULL,
		    ctx->default_passwd_callback,
		    ctx->default_passwd_callback_userdata);
	} else if (type == SSL_FILETYPE_ASN1) {
		j = ERR_R_ASN1_LIB;
		pkey = d2i_PrivateKey_bio(in, NULL);
	} else {
		SSLerrorx(SSL_R_BAD_SSL_FILETYPE);
		goto end;
	}
	if (pkey == NULL) {
		SSLerrorx(j);
		goto end;
	}
	ret = SSL_CTX_use_PrivateKey(ctx, pkey);
	EVP_PKEY_free(pkey);
end:
	BIO_free(in);
	return (ret);
}

int
SSL_CTX_use_PrivateKey_ASN1(int type, SSL_CTX *ctx, const unsigned char *d,
    long len)
{
	int ret;
	const unsigned char *p;
	EVP_PKEY *pkey;

	p = d;
	if ((pkey = d2i_PrivateKey(type, NULL, &p,(long)len)) == NULL) {
		SSLerrorx(ERR_R_ASN1_LIB);
		return (0);
	}

	ret = SSL_CTX_use_PrivateKey(ctx, pkey);
	EVP_PKEY_free(pkey);
	return (ret);
}


/*
 * Read a bio that contains our certificate in "PEM" format,
 * possibly followed by a sequence of CA certificates that should be
 * sent to the peer in the Certificate message.
 */
static int
ssl_ctx_use_certificate_chain_bio(SSL_CTX *ctx, BIO *in)
{
	int ret = 0;
	X509 *x = NULL;

	ERR_clear_error(); /* clear error stack for SSL_CTX_use_certificate() */

	x = PEM_read_bio_X509_AUX(in, NULL, ctx->default_passwd_callback,
	    ctx->default_passwd_callback_userdata);
	if (x == NULL) {
		SSLerrorx(ERR_R_PEM_LIB);
		goto end;
	}

	ret = SSL_CTX_use_certificate(ctx, x);

	if (ERR_peek_error() != 0)
		ret = 0;
	/* Key/certificate mismatch doesn't imply ret==0 ... */
	if (ret) {
		/*
		 * If we could set up our certificate, now proceed to
		 * the CA certificates.
		 */
		X509 *ca;
		int r;
		unsigned long err;

		sk_X509_pop_free(ctx->extra_certs, X509_free);
		ctx->extra_certs = NULL;

		while ((ca = PEM_read_bio_X509(in, NULL,
		    ctx->default_passwd_callback,
		    ctx->default_passwd_callback_userdata)) != NULL) {
			r = SSL_CTX_add_extra_chain_cert(ctx, ca);
			if (!r) {
				X509_free(ca);
				ret = 0;
				goto end;
			}
			/*
			 * Note that we must not free r if it was successfully
			 * added to the chain (while we must free the main
			 * certificate, since its reference count is increased
			 * by SSL_CTX_use_certificate).
			 */
		}

		/* When the while loop ends, it's usually just EOF. */
		err = ERR_peek_last_error();
		if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
		    ERR_GET_REASON(err) == PEM_R_NO_START_LINE)
			ERR_clear_error();
		else
			ret = 0; /* some real error */
	}

end:
	X509_free(x);
	return (ret);
}

int
SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file)
{
	BIO *in;
	int ret = 0;

	in = BIO_new(BIO_s_file_internal());
	if (in == NULL) {
		SSLerrorx(ERR_R_BUF_LIB);
		goto end;
	}

	if (BIO_read_filename(in, file) <= 0) {
		SSLerrorx(ERR_R_SYS_LIB);
		goto end;
	}

	ret = ssl_ctx_use_certificate_chain_bio(ctx, in);

end:
	BIO_free(in);
	return (ret);
}

int
SSL_CTX_use_certificate_chain_mem(SSL_CTX *ctx, void *buf, int len)
{
	BIO *in;
	int ret = 0;

	in = BIO_new_mem_buf(buf, len);
	if (in == NULL) {
		SSLerrorx(ERR_R_BUF_LIB);
		goto end;
	}

	ret = ssl_ctx_use_certificate_chain_bio(ctx, in);

end:
	BIO_free(in);
	return (ret);
}
@


1.27
log
@Finish the fallout of the SSLerr->SSLerror cleanup to get rid of the ugly
line wraps that resulted
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_rsa.c,v 1.26 2017/01/26 10:40:21 beck Exp $ */
d77 1
a77 1
		SSLerror(ERR_R_PASSED_NULL_PARAMETER);
d81 1
a81 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d97 1
a97 1
		SSLerror(ERR_R_BUF_LIB);
d102 1
a102 1
		SSLerror(ERR_R_SYS_LIB);
d114 1
a114 1
		SSLerror(SSL_R_BAD_SSL_FILETYPE);
d119 1
a119 1
		SSLerror(j);
d138 1
a138 1
		SSLerror(ERR_R_ASN1_LIB);
d154 1
a154 1
		SSLerror(ERR_R_PASSED_NULL_PARAMETER);
d158 1
a158 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d162 1
a162 1
		SSLerror(ERR_R_EVP_LIB);
d181 1
a181 1
		SSLerror(SSL_R_UNKNOWN_CERTIFICATE_TYPE);
d225 1
a225 1
		SSLerror(ERR_R_BUF_LIB);
d230 1
a230 1
		SSLerror(ERR_R_SYS_LIB);
d242 1
a242 1
		SSLerror(SSL_R_BAD_SSL_FILETYPE);
d246 1
a246 1
		SSLerror(j);
d265 1
a265 1
		SSLerror(ERR_R_ASN1_LIB);
d280 1
a280 1
		SSLerror(ERR_R_PASSED_NULL_PARAMETER);
d284 1
a284 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d300 1
a300 1
		SSLerror(ERR_R_BUF_LIB);
d305 1
a305 1
		SSLerror(ERR_R_SYS_LIB);
d317 1
a317 1
		SSLerror(SSL_R_BAD_SSL_FILETYPE);
d321 1
a321 1
		SSLerror(j);
d340 1
a340 1
		SSLerror(ERR_R_ASN1_LIB);
d353 1
a353 1
		SSLerror(ERR_R_PASSED_NULL_PARAMETER);
d357 1
a357 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d371 1
a371 1
		SSLerror(SSL_R_X509_LIB);
d377 1
a377 1
		SSLerror(SSL_R_UNKNOWN_CERTIFICATE_TYPE);
d430 1
a430 1
		SSLerror(ERR_R_BUF_LIB);
d435 1
a435 1
		SSLerror(ERR_R_SYS_LIB);
d446 1
a446 1
		SSLerror(SSL_R_BAD_SSL_FILETYPE);
d451 1
a451 1
		SSLerror(j);
d470 1
a470 1
		SSLerror(ERR_R_ASN1_LIB);
d486 1
a486 1
		SSLerror(ERR_R_PASSED_NULL_PARAMETER);
d490 1
a490 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d494 1
a494 1
		SSLerror(ERR_R_EVP_LIB);
d515 1
a515 1
		SSLerror(ERR_R_BUF_LIB);
d520 1
a520 1
		SSLerror(ERR_R_SYS_LIB);
d532 1
a532 1
		SSLerror(SSL_R_BAD_SSL_FILETYPE);
d536 1
a536 1
		SSLerror(j);
d555 1
a555 1
		SSLerror(ERR_R_ASN1_LIB);
d568 1
a568 1
		SSLerror(ERR_R_PASSED_NULL_PARAMETER);
d572 1
a572 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d587 1
a587 1
		SSLerror(ERR_R_BUF_LIB);
d592 1
a592 1
		SSLerror(ERR_R_SYS_LIB);
d604 1
a604 1
		SSLerror(SSL_R_BAD_SSL_FILETYPE);
d608 1
a608 1
		SSLerror(j);
d628 1
a628 1
		SSLerror(ERR_R_ASN1_LIB);
d654 1
a654 1
		SSLerror(ERR_R_PEM_LIB);
d714 1
a714 1
		SSLerror(ERR_R_BUF_LIB);
d719 1
a719 1
		SSLerror(ERR_R_SYS_LIB);
d738 1
a738 1
		SSLerror(ERR_R_BUF_LIB);
@


1.26
log
@Send the error function codes to rot in the depths of hell where they belong
We leave a single funciton code (0xFFF) to say "SSL_internal" so the public
API will not break, and we replace all internal use of the two argument
SSL_err() with the internal only SSL_error() that only takes a reason code.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_rsa.c,v 1.25 2017/01/24 14:57:31 jsing Exp $ */
d568 1
a568 2
		SSLerror(
		    ERR_R_PASSED_NULL_PARAMETER);
d604 1
a604 2
		SSLerror(
		    SSL_R_BAD_SSL_FILETYPE);
@


1.25
log
@sk_pop_free() checks for NULL so do not bother doing it from the callers.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_rsa.c,v 1.24 2017/01/23 22:34:38 beck Exp $ */
d77 1
a77 1
		SSLerr(SSL_F_SSL_USE_CERTIFICATE, ERR_R_PASSED_NULL_PARAMETER);
d81 1
a81 1
		SSLerr(SSL_F_SSL_USE_CERTIFICATE, ERR_R_MALLOC_FAILURE);
d97 1
a97 1
		SSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE, ERR_R_BUF_LIB);
d102 1
a102 1
		SSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE, ERR_R_SYS_LIB);
d114 1
a114 1
		SSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE, SSL_R_BAD_SSL_FILETYPE);
d119 1
a119 1
		SSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE, j);
d138 1
a138 1
		SSLerr(SSL_F_SSL_USE_CERTIFICATE_ASN1, ERR_R_ASN1_LIB);
d154 1
a154 1
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY, ERR_R_PASSED_NULL_PARAMETER);
d158 1
a158 1
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY, ERR_R_MALLOC_FAILURE);
d162 1
a162 1
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY, ERR_R_EVP_LIB);
d181 1
a181 1
		SSLerr(SSL_F_SSL_SET_PKEY, SSL_R_UNKNOWN_CERTIFICATE_TYPE);
d225 1
a225 1
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE, ERR_R_BUF_LIB);
d230 1
a230 1
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE, ERR_R_SYS_LIB);
d242 1
a242 1
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE, SSL_R_BAD_SSL_FILETYPE);
d246 1
a246 1
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE, j);
d265 1
a265 1
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_ASN1, ERR_R_ASN1_LIB);
d280 1
a280 1
		SSLerr(SSL_F_SSL_USE_PRIVATEKEY, ERR_R_PASSED_NULL_PARAMETER);
d284 1
a284 1
		SSLerr(SSL_F_SSL_USE_PRIVATEKEY, ERR_R_MALLOC_FAILURE);
d300 1
a300 1
		SSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE, ERR_R_BUF_LIB);
d305 1
a305 1
		SSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE, ERR_R_SYS_LIB);
d317 1
a317 1
		SSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE, SSL_R_BAD_SSL_FILETYPE);
d321 1
a321 1
		SSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE, j);
d340 1
a340 1
		SSLerr(SSL_F_SSL_USE_PRIVATEKEY_ASN1, ERR_R_ASN1_LIB);
d353 1
a353 1
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE, ERR_R_PASSED_NULL_PARAMETER);
d357 1
a357 1
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE, ERR_R_MALLOC_FAILURE);
d371 1
a371 1
		SSLerr(SSL_F_SSL_SET_CERT, SSL_R_X509_LIB);
d377 1
a377 1
		SSLerr(SSL_F_SSL_SET_CERT, SSL_R_UNKNOWN_CERTIFICATE_TYPE);
d430 1
a430 1
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE, ERR_R_BUF_LIB);
d435 1
a435 1
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE, ERR_R_SYS_LIB);
d446 1
a446 1
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE, SSL_R_BAD_SSL_FILETYPE);
d451 1
a451 1
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE, j);
d470 1
a470 1
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1, ERR_R_ASN1_LIB);
d486 1
a486 1
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY, ERR_R_PASSED_NULL_PARAMETER);
d490 1
a490 1
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY, ERR_R_MALLOC_FAILURE);
d494 1
a494 1
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY, ERR_R_EVP_LIB);
d515 1
a515 1
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE, ERR_R_BUF_LIB);
d520 1
a520 1
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE, ERR_R_SYS_LIB);
d532 1
a532 1
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE, SSL_R_BAD_SSL_FILETYPE);
d536 1
a536 1
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE, j);
d555 1
a555 1
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_ASN1, ERR_R_ASN1_LIB);
d568 1
a568 1
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY,
d573 1
a573 1
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_MALLOC_FAILURE);
d588 1
a588 1
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE, ERR_R_BUF_LIB);
d593 1
a593 1
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE, ERR_R_SYS_LIB);
d605 1
a605 1
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE,
d610 1
a610 1
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE, j);
d630 1
a630 1
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_ASN1, ERR_R_ASN1_LIB);
d656 1
a656 1
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE, ERR_R_PEM_LIB);
d716 1
a716 1
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE, ERR_R_BUF_LIB);
d721 1
a721 1
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE, ERR_R_SYS_LIB);
d740 1
a740 1
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE, ERR_R_BUF_LIB);
@


1.24
log
@move default_passwd_cb and default_passwd_cb_userdata back into
the ssl_ctx from internal - these are used directly by python
and openvpn and a few other things - we have the set accessors
but the get accessors were added in 1.1 and these roll their
own caveat OPENSSL_VERSION chickenpluckery
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_rsa.c,v 1.23 2017/01/23 05:13:02 jsing Exp $ */
d674 2
a675 4
		if (ctx->extra_certs != NULL) {
			sk_X509_pop_free(ctx->extra_certs, X509_free);
			ctx->extra_certs = NULL;
		}
@


1.23
log
@Move most of the fields in SSL_CTX to internal - the ones that remain are
known to be in use.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_rsa.c,v 1.22 2017/01/23 04:15:28 jsing Exp $ */
d111 2
a112 2
		    ssl->ctx->internal->default_passwd_callback,
		    ssl->ctx->internal->default_passwd_callback_userdata);
d239 2
a240 2
		    ssl->ctx->internal->default_passwd_callback,
		    ssl->ctx->internal->default_passwd_callback_userdata);
d311 2
a312 2
		    ssl->ctx->internal->default_passwd_callback,
		    ssl->ctx->internal->default_passwd_callback_userdata);
d443 2
a444 2
		x = PEM_read_bio_X509(in, NULL, ctx->internal->default_passwd_callback,
		    ctx->internal->default_passwd_callback_userdata);
d529 2
a530 2
		    ctx->internal->default_passwd_callback,
		    ctx->internal->default_passwd_callback_userdata);
d599 2
a600 2
		    ctx->internal->default_passwd_callback,
		    ctx->internal->default_passwd_callback_userdata);
d653 2
a654 2
	x = PEM_read_bio_X509_AUX(in, NULL, ctx->internal->default_passwd_callback,
	    ctx->internal->default_passwd_callback_userdata);
d680 2
a681 2
		    ctx->internal->default_passwd_callback,
		    ctx->internal->default_passwd_callback_userdata)) != NULL) {
@


1.22
log
@Move callback function pointers and argument pointers from SSL_CTX to
internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_rsa.c,v 1.21 2016/03/11 07:08:45 mmcc Exp $ */
d356 1
a356 1
	if (!ssl_cert_inst(&ctx->cert)) {
d360 1
a360 1
	return (ssl_set_cert(ctx->cert, x));
d489 1
a489 1
	if (!ssl_cert_inst(&ctx->cert)) {
d501 1
a501 1
	ret = ssl_set_pkey(ctx->cert, pkey);
d572 1
a572 1
	if (!ssl_cert_inst(&ctx->cert)) {
d576 1
a576 1
	return (ssl_set_pkey(ctx->cert, pkey));
@


1.21
log
@X509_free(3) is NULL-safe, so remove NULL checks before its calls.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_rsa.c,v 1.20 2015/02/06 01:37:11 reyk Exp $ */
d111 2
a112 2
		    ssl->ctx->default_passwd_callback,
		    ssl->ctx->default_passwd_callback_userdata);
d239 2
a240 2
		    ssl->ctx->default_passwd_callback,
		    ssl->ctx->default_passwd_callback_userdata);
d311 2
a312 2
		    ssl->ctx->default_passwd_callback,
		    ssl->ctx->default_passwd_callback_userdata);
d443 2
a444 2
		x = PEM_read_bio_X509(in, NULL, ctx->default_passwd_callback,
		    ctx->default_passwd_callback_userdata);
d529 2
a530 2
		    ctx->default_passwd_callback,
		    ctx->default_passwd_callback_userdata);
d599 2
a600 2
		    ctx->default_passwd_callback,
		    ctx->default_passwd_callback_userdata);
d653 2
a654 2
	x = PEM_read_bio_X509_AUX(in, NULL, ctx->default_passwd_callback,
	    ctx->default_passwd_callback_userdata);
d680 2
a681 2
		    ctx->default_passwd_callback,
		    ctx->default_passwd_callback_userdata)) != NULL) {
@


1.20
log
@Rename SSL_CTX_use_certificate_chain() to SSL_CTX_use_certificate_chain_mem().

As discussed with beck@@ jsing@@ and others
OK beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_rsa.c,v 1.19 2014/12/14 15:30:50 jsing Exp $ */
d125 1
a125 2
	if (x != NULL)
		X509_free(x);
d411 1
a411 2
	if (c->pkeys[i].x509 != NULL)
		X509_free(c->pkeys[i].x509);
d457 1
a457 2
	if (x != NULL)
		X509_free(x);
d706 1
a706 2
	if (x != NULL)
		X509_free(x);
@


1.19
log
@Remove trailing whitespace.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_rsa.c,v 1.18 2014/11/16 14:12:47 jsing Exp $ */
d739 1
a739 1
SSL_CTX_use_certificate_chain(SSL_CTX *ctx, void *buf, int len)
@


1.18
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_rsa.c,v 1.17 2014/09/28 14:45:48 reyk Exp $ */
d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
@


1.17
log
@Add a new API function SSL_CTX_use_certificate_chain() that allows to
read the PEM-encoded certificate chain from memory instead of a file.
This idea is derived from an older implementation in relayd that was
needed to use the function with a privep'ed process in a chroot.  Now
it is time to get it into LibreSSL to make the API more privsep-
friendly and to make it available for other programs and the ressl
library.

ok jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_rsa.c,v 1.16 2014/07/12 16:03:37 miod Exp $ */
d60 1
d62 1
d64 1
d66 1
a66 1
#include <openssl/evp.h>
a67 1
#include <openssl/pem.h>
@


1.16
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_rsa.c,v 1.15 2014/06/22 19:09:37 guenther Exp $ */
d69 2
d642 1
a642 1
 * Read a file that contains our certificate in "PEM" format,
d646 2
a647 2
int
SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file)
a648 1
	BIO *in;
a653 11
	in = BIO_new(BIO_s_file_internal());
	if (in == NULL) {
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE, ERR_R_BUF_LIB);
		goto end;
	}

	if (BIO_read_filename(in, file) <= 0) {
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE, ERR_R_SYS_LIB);
		goto end;
	}

d709 42
@


1.15
log
@KNF, particularly wrapped lines of calls to PEM_read_bio_FOO() and
multiline comments

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_rsa.c,v 1.14 2014/06/12 15:49:31 deraadt Exp $ */
d204 1
a204 2
	if (c->pkeys[i].privatekey != NULL)
		EVP_PKEY_free(c->pkeys[i].privatekey);
@


1.14
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d106 3
a108 1
		x = PEM_read_bio_X509(in, NULL, ssl->ctx->default_passwd_callback, ssl->ctx->default_passwd_callback_userdata);
d189 4
a192 2
		/* Don't check the public/private key, this is mostly
		 * for smart cards. */
d237 2
a238 1
		ssl->ctx->default_passwd_callback, ssl->ctx->default_passwd_callback_userdata);
d309 2
a310 1
		ssl->ctx->default_passwd_callback, ssl->ctx->default_passwd_callback_userdata);
d384 4
a387 2
		/* Don't check the public/private key, this is mostly
		 * for smart cards. */
d394 2
a395 1
			/* don't fail for a cert/key mismatch, just free
d398 2
a399 1
			 * then ssl_set_pkey */
d442 2
a443 1
		x = PEM_read_bio_X509(in, NULL, ctx->default_passwd_callback, ctx->default_passwd_callback_userdata);
d529 2
a530 1
		ctx->default_passwd_callback, ctx->default_passwd_callback_userdata);
d568 2
a569 1
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_PASSED_NULL_PARAMETER);
d599 2
a600 1
		ctx->default_passwd_callback, ctx->default_passwd_callback_userdata);
d605 2
a606 1
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE, SSL_R_BAD_SSL_FILETYPE);
d640 2
a641 1
/* Read a file that contains our certificate in "PEM" format,
d666 1
a666 1
	ctx->default_passwd_callback_userdata);
d678 2
a679 1
		/* If we could set up our certificate, now proceed to
d692 2
a693 3
		ctx->default_passwd_callback,
		ctx->default_passwd_callback_userdata))
		!= NULL) {
d700 2
a701 1
			/* Note that we must not free r if it was successfully
d704 2
a705 1
			 * by SSL_CTX_use_certificate). */
d707 1
d710 2
a711 1
		if (ERR_GET_LIB(err) == ERR_LIB_PEM && ERR_GET_REASON(err) == PEM_R_NO_START_LINE)
@


1.13
log
@BIO_free has an implicit NULL check, so do not bother checking for NULL
before calling it.
@
text
@d1 1
a1 1
/* ssl/ssl_rsa.c */
@


1.12
log
@Any sane platform has stdio. Stop pretending we will ever use a platform
that does not.
"fire bomb" tedu@@
@
text
@d121 1
a121 2
	if (in != NULL)
		BIO_free(in);
d245 1
a245 2
	if (in != NULL)
		BIO_free(in);
d319 1
a319 2
	if (in != NULL)
		BIO_free(in);
d447 1
a447 2
	if (in != NULL)
		BIO_free(in);
d530 1
a530 2
	if (in != NULL)
		BIO_free(in);
d601 1
a601 2
	if (in != NULL)
		BIO_free(in);
d700 1
a700 2
	if (in != NULL)
		BIO_free(in);
@


1.11
log
@always build in RSA and DSA. ok deraadt miod
@
text
@a82 1
#ifndef OPENSSL_NO_STDIO
a124 1
#endif
a210 1
#ifndef OPENSSL_NO_STDIO
a249 1
#endif
a285 1
#ifndef OPENSSL_NO_STDIO
a324 1
#endif
a411 1
#ifndef OPENSSL_NO_STDIO
a453 1
#endif
a498 1
#ifndef OPENSSL_NO_STDIO
a537 1
#endif
a570 1
#ifndef OPENSSL_NO_STDIO
a609 1
#endif
a630 1
#ifndef OPENSSL_NO_STDIO
a709 1
#endif
@


1.10
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a144 1
#ifndef OPENSSL_NO_RSA
a170 1
#endif
a189 1
#ifndef OPENSSL_NO_RSA
a195 1
#endif
a212 1
#ifndef OPENSSL_NO_RSA
a271 1
#endif /* !OPENSSL_NO_RSA */
a386 1
#ifndef OPENSSL_NO_RSA
a393 1
#endif /* OPENSSL_NO_RSA */
a479 1
#ifndef OPENSSL_NO_RSA
a565 1
#endif /* !OPENSSL_NO_RSA */
@


1.9
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d69 10
a78 13
int SSL_use_certificate(SSL *ssl, X509 *x)
	{
	if (x == NULL)
		{
		SSLerr(SSL_F_SSL_USE_CERTIFICATE,ERR_R_PASSED_NULL_PARAMETER);
		return(0);
		}
	if (!ssl_cert_inst(&ssl->cert))
		{
		SSLerr(SSL_F_SSL_USE_CERTIFICATE,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	return(ssl_set_cert(ssl->cert,x));
d80 2
d84 3
a86 2
int SSL_use_certificate_file(SSL *ssl, const char *file, int type)
	{
d89 2
a90 2
	int ret=0;
	X509 *x=NULL;
d92 3
a94 4
	in=BIO_new(BIO_s_file_internal());
	if (in == NULL)
		{
		SSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE,ERR_R_BUF_LIB);
d96 1
a96 1
		}
d98 2
a99 3
	if (BIO_read_filename(in,file) <= 0)
		{
		SSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE,ERR_R_SYS_LIB);
d101 9
a109 14
		}
	if (type == SSL_FILETYPE_ASN1)
		{
		j=ERR_R_ASN1_LIB;
		x=d2i_X509_bio(in,NULL);
		}
	else if (type == SSL_FILETYPE_PEM)
		{
		j=ERR_R_PEM_LIB;
		x=PEM_read_bio_X509(in,NULL,ssl->ctx->default_passwd_callback,ssl->ctx->default_passwd_callback_userdata);
		}
	else
		{
		SSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE,SSL_R_BAD_SSL_FILETYPE);
d111 1
a111 1
		}
d113 2
a114 3
	if (x == NULL)
		{
		SSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE,j);
d116 1
a116 1
		}
d118 1
a118 1
	ret=SSL_use_certificate(ssl,x);
d120 6
a125 4
	if (x != NULL) X509_free(x);
	if (in != NULL) BIO_free(in);
	return(ret);
	}
d128 3
a130 2
int SSL_use_certificate_ASN1(SSL *ssl, const unsigned char *d, int len)
	{
d134 5
a138 6
	x=d2i_X509(NULL,&d,(long)len);
	if (x == NULL)
		{
		SSLerr(SSL_F_SSL_USE_CERTIFICATE_ASN1,ERR_R_ASN1_LIB);
		return(0);
		}
d140 1
a140 1
	ret=SSL_use_certificate(ssl,x);
d142 2
a143 2
	return(ret);
	}
d146 3
a148 2
int SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa)
	{
d152 12
a163 15
	if (rsa == NULL)
		{
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY,ERR_R_PASSED_NULL_PARAMETER);
		return(0);
		}
	if (!ssl_cert_inst(&ssl->cert))
		{
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	if ((pkey=EVP_PKEY_new()) == NULL)
		{
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY,ERR_R_EVP_LIB);
		return(0);
		}
d166 1
a166 1
	EVP_PKEY_assign_RSA(pkey,rsa);
d168 1
a168 1
	ret=ssl_set_pkey(ssl->cert,pkey);
d170 2
a171 2
	return(ret);
	}
d174 3
a176 2
static int ssl_set_pkey(CERT *c, EVP_PKEY *pkey)
	{
d179 5
a183 6
	i=ssl_cert_type(NULL,pkey);
	if (i < 0)
		{
		SSLerr(SSL_F_SSL_SET_PKEY,SSL_R_UNKNOWN_CERTIFICATE_TYPE);
		return(0);
		}
d185 1
a185 2
	if (c->pkeys[i].x509 != NULL)
		{
d187 2
a188 2
		pktmp =	X509_get_pubkey(c->pkeys[i].x509);
		EVP_PKEY_copy_parameters(pktmp,pkey);
d197 1
a197 1
			;
d200 1
a200 2
		if (!X509_check_private_key(c->pkeys[i].x509,pkey))
			{
a203 1
			}
d205 1
d209 7
a215 7
	CRYPTO_add(&pkey->references,1,CRYPTO_LOCK_EVP_PKEY);
	c->pkeys[i].privatekey=pkey;
	c->key= &(c->pkeys[i]);

	c->valid=0;
	return(1);
	}
d219 4
a222 3
int SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type)
	{
	int j,ret=0;
d224 1
a224 1
	RSA *rsa=NULL;
d226 3
a228 4
	in=BIO_new(BIO_s_file_internal());
	if (in == NULL)
		{
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE,ERR_R_BUF_LIB);
d230 1
a230 1
		}
d232 2
a233 3
	if (BIO_read_filename(in,file) <= 0)
		{
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE,ERR_R_SYS_LIB);
d235 10
a244 15
		}
	if	(type == SSL_FILETYPE_ASN1)
		{
		j=ERR_R_ASN1_LIB;
		rsa=d2i_RSAPrivateKey_bio(in,NULL);
		}
	else if (type == SSL_FILETYPE_PEM)
		{
		j=ERR_R_PEM_LIB;
		rsa=PEM_read_bio_RSAPrivateKey(in,NULL,
			ssl->ctx->default_passwd_callback,ssl->ctx->default_passwd_callback_userdata);
		}
	else
		{
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE,SSL_R_BAD_SSL_FILETYPE);
d246 3
a248 4
		}
	if (rsa == NULL)
		{
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE,j);
d250 2
a251 2
		}
	ret=SSL_use_RSAPrivateKey(ssl,rsa);
d254 4
a257 3
	if (in != NULL) BIO_free(in);
	return(ret);
	}
d260 3
a262 2
int SSL_use_RSAPrivateKey_ASN1(SSL *ssl, unsigned char *d, long len)
	{
d267 5
a271 6
	p=d;
	if ((rsa=d2i_RSAPrivateKey(NULL,&p,(long)len)) == NULL)
		{
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_ASN1,ERR_R_ASN1_LIB);
		return(0);
		}
d273 1
a273 1
	ret=SSL_use_RSAPrivateKey(ssl,rsa);
d275 2
a276 2
	return(ret);
	}
d279 3
a281 2
int SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey)
	{
d284 11
a294 13
	if (pkey == NULL)
		{
		SSLerr(SSL_F_SSL_USE_PRIVATEKEY,ERR_R_PASSED_NULL_PARAMETER);
		return(0);
		}
	if (!ssl_cert_inst(&ssl->cert))
		{
		SSLerr(SSL_F_SSL_USE_PRIVATEKEY,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	ret=ssl_set_pkey(ssl->cert,pkey);
	return(ret);
	}
d297 4
a300 3
int SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type)
	{
	int j,ret=0;
d302 1
a302 1
	EVP_PKEY *pkey=NULL;
d304 3
a306 4
	in=BIO_new(BIO_s_file_internal());
	if (in == NULL)
		{
		SSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE,ERR_R_BUF_LIB);
d308 1
a308 1
		}
d310 2
a311 3
	if (BIO_read_filename(in,file) <= 0)
		{
		SSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE,ERR_R_SYS_LIB);
d313 6
a318 9
		}
	if (type == SSL_FILETYPE_PEM)
		{
		j=ERR_R_PEM_LIB;
		pkey=PEM_read_bio_PrivateKey(in,NULL,
			ssl->ctx->default_passwd_callback,ssl->ctx->default_passwd_callback_userdata);
		}
	else if (type == SSL_FILETYPE_ASN1)
		{
d320 3
a322 5
		pkey = d2i_PrivateKey_bio(in,NULL);
		}
	else
		{
		SSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE,SSL_R_BAD_SSL_FILETYPE);
d324 3
a326 4
		}
	if (pkey == NULL)
		{
		SSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE,j);
d328 2
a329 2
		}
	ret=SSL_use_PrivateKey(ssl,pkey);
d332 4
a335 3
	if (in != NULL) BIO_free(in);
	return(ret);
	}
d338 3
a340 2
int SSL_use_PrivateKey_ASN1(int type, SSL *ssl, const unsigned char *d, long len)
	{
d345 5
a349 6
	p=d;
	if ((pkey=d2i_PrivateKey(type,NULL,&p,(long)len)) == NULL)
		{
		SSLerr(SSL_F_SSL_USE_PRIVATEKEY_ASN1,ERR_R_ASN1_LIB);
		return(0);
		}
d351 1
a351 1
	ret=SSL_use_PrivateKey(ssl,pkey);
d353 2
a354 17
	return(ret);
	}

int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x)
	{
	if (x == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE,ERR_R_PASSED_NULL_PARAMETER);
		return(0);
		}
	if (!ssl_cert_inst(&ctx->cert))
		{
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	return(ssl_set_cert(ctx->cert, x));
	}
d356 17
a372 2
static int ssl_set_cert(CERT *c, X509 *x)
	{
d376 5
a380 6
	pkey=X509_get_pubkey(x);
	if (pkey == NULL)
		{
		SSLerr(SSL_F_SSL_SET_CERT,SSL_R_X509_LIB);
		return(0);
		}
d382 3
a384 4
	i=ssl_cert_type(x,pkey);
	if (i < 0)
		{
		SSLerr(SSL_F_SSL_SET_CERT,SSL_R_UNKNOWN_CERTIFICATE_TYPE);
d386 2
a387 2
		return(0);
		}
d389 2
a390 3
	if (c->pkeys[i].privatekey != NULL)
		{
		EVP_PKEY_copy_parameters(pkey,c->pkeys[i].privatekey);
d398 2
a399 2
			 RSA_METHOD_FLAG_NO_CHECK))
			 ;
d402 1
a402 2
		if (!X509_check_private_key(x,c->pkeys[i].privatekey))
			{
d408 1
a408 1
			c->pkeys[i].privatekey=NULL;
a410 1
			}
d412 1
d418 7
a424 7
	CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
	c->pkeys[i].x509=x;
	c->key= &(c->pkeys[i]);

	c->valid=0;
	return(1);
	}
d427 3
a429 2
int SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type)
	{
d432 2
a433 2
	int ret=0;
	X509 *x=NULL;
d435 3
a437 4
	in=BIO_new(BIO_s_file_internal());
	if (in == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE,ERR_R_BUF_LIB);
d439 1
a439 1
		}
d441 2
a442 3
	if (BIO_read_filename(in,file) <= 0)
		{
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE,ERR_R_SYS_LIB);
d444 9
a452 14
		}
	if (type == SSL_FILETYPE_ASN1)
		{
		j=ERR_R_ASN1_LIB;
		x=d2i_X509_bio(in,NULL);
		}
	else if (type == SSL_FILETYPE_PEM)
		{
		j=ERR_R_PEM_LIB;
		x=PEM_read_bio_X509(in,NULL,ctx->default_passwd_callback,ctx->default_passwd_callback_userdata);
		}
	else
		{
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE,SSL_R_BAD_SSL_FILETYPE);
d454 1
a454 1
		}
d456 2
a457 3
	if (x == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE,j);
d459 1
a459 1
		}
d461 1
a461 1
	ret=SSL_CTX_use_certificate(ctx,x);
d463 6
a468 4
	if (x != NULL) X509_free(x);
	if (in != NULL) BIO_free(in);
	return(ret);
	}
d471 3
a473 2
int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, const unsigned char *d)
	{
d477 5
a481 6
	x=d2i_X509(NULL,&d,(long)len);
	if (x == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1,ERR_R_ASN1_LIB);
		return(0);
		}
d483 1
a483 1
	ret=SSL_CTX_use_certificate(ctx,x);
d485 2
a486 2
	return(ret);
	}
d489 3
a491 2
int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa)
	{
d495 12
a506 15
	if (rsa == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY,ERR_R_PASSED_NULL_PARAMETER);
		return(0);
		}
	if (!ssl_cert_inst(&ctx->cert))
		{
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	if ((pkey=EVP_PKEY_new()) == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY,ERR_R_EVP_LIB);
		return(0);
		}
d509 1
a509 1
	EVP_PKEY_assign_RSA(pkey,rsa);
d511 1
a511 1
	ret=ssl_set_pkey(ctx->cert, pkey);
d513 2
a514 2
	return(ret);
	}
d517 4
a520 3
int SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type)
	{
	int j,ret=0;
d522 1
a522 1
	RSA *rsa=NULL;
d524 3
a526 4
	in=BIO_new(BIO_s_file_internal());
	if (in == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE,ERR_R_BUF_LIB);
d528 1
a528 1
		}
d530 2
a531 3
	if (BIO_read_filename(in,file) <= 0)
		{
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE,ERR_R_SYS_LIB);
d533 10
a542 15
		}
	if	(type == SSL_FILETYPE_ASN1)
		{
		j=ERR_R_ASN1_LIB;
		rsa=d2i_RSAPrivateKey_bio(in,NULL);
		}
	else if (type == SSL_FILETYPE_PEM)
		{
		j=ERR_R_PEM_LIB;
		rsa=PEM_read_bio_RSAPrivateKey(in,NULL,
			ctx->default_passwd_callback,ctx->default_passwd_callback_userdata);
		}
	else
		{
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE,SSL_R_BAD_SSL_FILETYPE);
d544 3
a546 4
		}
	if (rsa == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE,j);
d548 2
a549 2
		}
	ret=SSL_CTX_use_RSAPrivateKey(ctx,rsa);
d552 4
a555 3
	if (in != NULL) BIO_free(in);
	return(ret);
	}
d558 3
a560 2
int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, const unsigned char *d, long len)
	{
d565 5
a569 6
	p=d;
	if ((rsa=d2i_RSAPrivateKey(NULL,&p,(long)len)) == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_ASN1,ERR_R_ASN1_LIB);
		return(0);
		}
d571 1
a571 1
	ret=SSL_CTX_use_RSAPrivateKey(ctx,rsa);
d573 2
a574 2
	return(ret);
	}
d577 10
a586 13
int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey)
	{
	if (pkey == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY,ERR_R_PASSED_NULL_PARAMETER);
		return(0);
		}
	if (!ssl_cert_inst(&ctx->cert))
		{
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	return(ssl_set_pkey(ctx->cert,pkey));
d588 2
d592 4
a595 3
int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type)
	{
	int j,ret=0;
d597 1
a597 1
	EVP_PKEY *pkey=NULL;
d599 3
a601 4
	in=BIO_new(BIO_s_file_internal());
	if (in == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE,ERR_R_BUF_LIB);
d603 1
a603 1
		}
d605 2
a606 3
	if (BIO_read_filename(in,file) <= 0)
		{
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE,ERR_R_SYS_LIB);
d608 6
a613 9
		}
	if (type == SSL_FILETYPE_PEM)
		{
		j=ERR_R_PEM_LIB;
		pkey=PEM_read_bio_PrivateKey(in,NULL,
			ctx->default_passwd_callback,ctx->default_passwd_callback_userdata);
		}
	else if (type == SSL_FILETYPE_ASN1)
		{
d615 3
a617 5
		pkey = d2i_PrivateKey_bio(in,NULL);
		}
	else
		{
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE,SSL_R_BAD_SSL_FILETYPE);
d619 3
a621 4
		}
	if (pkey == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE,j);
d623 2
a624 2
		}
	ret=SSL_CTX_use_PrivateKey(ctx,pkey);
d627 4
a630 3
	if (in != NULL) BIO_free(in);
	return(ret);
	}
d633 4
a636 3
int SSL_CTX_use_PrivateKey_ASN1(int type, SSL_CTX *ctx, const unsigned char *d,
	     long len)
	{
d641 5
a645 6
	p=d;
	if ((pkey=d2i_PrivateKey(type,NULL,&p,(long)len)) == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_ASN1,ERR_R_ASN1_LIB);
		return(0);
		}
d647 1
a647 1
	ret=SSL_CTX_use_PrivateKey(ctx,pkey);
d649 2
a650 2
	return(ret);
	}
d658 3
a660 2
int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file)
	{
d662 2
a663 2
	int ret=0;
	X509 *x=NULL;
d668 2
a669 3
	if (in == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE,ERR_R_BUF_LIB);
d671 1
a671 1
		}
d673 2
a674 3
	if (BIO_read_filename(in,file) <= 0)
		{
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE,ERR_R_SYS_LIB);
d676 1
a676 1
		}
d678 4
a681 5
	x=PEM_read_bio_X509_AUX(in,NULL,ctx->default_passwd_callback,
				ctx->default_passwd_callback_userdata);
	if (x == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE,ERR_R_PEM_LIB);
d683 1
a683 1
		}
d688 3
a690 3
		ret = 0;  /* Key/certificate mismatch doesn't imply ret==0 ... */
	if (ret)
		{
d697 2
a698 3
		
		if (ctx->extra_certs != NULL)
			{
d701 1
a701 1
			}
d704 3
a706 4
					ctx->default_passwd_callback,
					ctx->default_passwd_callback_userdata))
			!= NULL)
			{
d708 1
a708 2
			if (!r) 
				{
d712 1
a712 1
				}
d717 1
a717 1
			}
d722 1
a722 1
		else 
d724 1
a724 1
		}
d727 6
a732 4
	if (x != NULL) X509_free(x);
	if (in != NULL) BIO_free(in);
	return(ret);
	}
@


1.8
log
@resolve conflicts, fix local changes
@
text
@d713 1
a713 1
	in=BIO_new(BIO_s_file_internal());
d726 2
a727 1
	x=PEM_read_bio_X509_AUX(in,NULL,ctx->default_passwd_callback,ctx->default_passwd_callback_userdata);
d734 2
a735 1
	ret=SSL_CTX_use_certificate(ctx,x);
d747 1
a747 1
		if (ctx->extra_certs != NULL) 
d753 3
a755 1
		while ((ca = PEM_read_bio_X509(in,NULL,ctx->default_passwd_callback,ctx->default_passwd_callback_userdata))
@


1.7
log
@resolve conflicts
@
text
@d726 1
a726 1
	x=PEM_read_bio_X509(in,NULL,ctx->default_passwd_callback,ctx->default_passwd_callback_userdata);
@


1.6
log
@resolve conflicts
@
text
@d134 1
a134 1
int SSL_use_certificate_ASN1(SSL *ssl, unsigned char *d, int len)
d184 1
a184 1
	int i,ok=0,bad=0;
d205 2
a206 3
			(RSA_flags(pkey->pkey.rsa) &
			 RSA_METHOD_FLAG_NO_CHECK))
			 ok=1;
d209 1
a209 1
		     if (!X509_check_private_key(c->pkeys[i].x509,pkey))
d211 3
a213 18
			if ((i == SSL_PKEY_DH_RSA) || (i == SSL_PKEY_DH_DSA))
				{
				i=(i == SSL_PKEY_DH_RSA)?
					SSL_PKEY_DH_DSA:SSL_PKEY_DH_RSA;

				if (c->pkeys[i].x509 == NULL)
					ok=1;
				else
					{
					if (!X509_check_private_key(
						c->pkeys[i].x509,pkey))
						bad=1;
					else
						ok=1;
					}
				}
			else
				bad=1;
a214 2
		else
			ok=1;
a215 2
	else
		ok=1;
a216 9
	if (bad)
		{
		X509_free(c->pkeys[i].x509);
		c->pkeys[i].x509=NULL;
		return(0);
		}

	ERR_clear_error(); /* make sure no error from X509_check_private_key()
	                    * is left if we have chosen to ignore it */
d338 5
d361 1
a361 1
int SSL_use_PrivateKey_ASN1(int type, SSL *ssl, unsigned char *d, long len)
d364 1
a364 1
	unsigned char *p;
d397 1
a397 1
	int i,ok=0,bad=0;
d425 1
a425 1
			 ok=1;
d427 1
a427 2
#endif
		{
d430 8
a437 18
			if ((i == SSL_PKEY_DH_RSA) || (i == SSL_PKEY_DH_DSA))
				{
				i=(i == SSL_PKEY_DH_RSA)?
					SSL_PKEY_DH_DSA:SSL_PKEY_DH_RSA;

				if (c->pkeys[i].privatekey == NULL)
					ok=1;
				else
					{
					if (!X509_check_private_key(x,
						c->pkeys[i].privatekey))
						bad=1;
					else
						ok=1;
					}
				}
			else
				bad=1;
a438 3
		else
			ok=1;
		} /* OPENSSL_NO_RSA */
a439 2
	else
		ok=1;
a441 5
	if (bad)
		{
		EVP_PKEY_free(c->pkeys[i].privatekey);
		c->pkeys[i].privatekey=NULL;
		}
d503 1
a503 1
int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, unsigned char *d)
d598 1
a598 1
int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, unsigned char *d, long len)
d657 5
d680 1
a680 1
int SSL_CTX_use_PrivateKey_ASN1(int type, SSL_CTX *ctx, unsigned char *d,
d684 1
a684 1
	unsigned char *p;
d710 2
@


1.5
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d807 1
a807 1
			(void)ERR_get_error();
@


1.4
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d210 1
a210 1
			if (!X509_check_private_key(c->pkeys[i].x509,pkey))
d244 2
@


1.3
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d60 1
a65 1
#include "ssl_locl.h"
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d84 1
a84 1
#ifndef NO_STDIO
d151 1
a151 1
#ifndef NO_RSA
d173 1
a173 1
	CRYPTO_add(&rsa->references,1,CRYPTO_LOCK_RSA);
d201 1
a201 1
#ifndef NO_RSA
d254 2
a255 2
#ifndef NO_RSA
#ifndef NO_STDIO
d306 1
a306 1
	unsigned char *p;
d320 1
a320 1
#endif /* !NO_RSA */
d340 1
a340 1
#ifndef NO_STDIO
d441 1
a441 1
#ifndef NO_RSA
d474 1
a474 1
		} /* NO_RSA */
d496 1
a496 1
#ifndef NO_STDIO
d563 1
a563 1
#ifndef NO_RSA
d585 1
a585 1
	CRYPTO_add(&rsa->references,1,CRYPTO_LOCK_RSA);
d593 1
a593 1
#ifndef NO_STDIO
d644 1
a644 1
	unsigned char *p;
d658 1
a658 1
#endif /* !NO_RSA */
d675 1
a675 1
#ifndef NO_STDIO
d738 1
a738 1
#ifndef NO_STDIO
d803 1
a803 1
		err = ERR_peek_error();
d805 1
a805 1
			(void) ERR_get_error();
@


1.1
log
@Initial revision
@
text
@d60 5
a64 5
#include "bio.h"
#include "objects.h"
#include "evp.h"
#include "x509.h"
#include "pem.h"
a66 1
#ifndef NOPROTO
d69 1
a69 8
#else
static int ssl_set_cert();
static int ssl_set_pkey();
#endif

int SSL_use_certificate(ssl, x)
SSL *ssl;
X509 *x;
a70 2
	CERT *c;

d76 1
a76 1
	if ((ssl->cert == NULL) || (ssl->cert == ssl->ctx->default_cert))
d78 2
a79 8
		c=ssl_cert_new();
		if (c == NULL)
			{
			SSLerr(SSL_F_SSL_USE_CERTIFICATE,ERR_R_MALLOC_FAILURE);
			return(0);
			}
		if (ssl->cert != NULL) ssl_cert_free(ssl->cert);
		ssl->cert=c;
d81 1
a81 3
	c=ssl->cert;

	return(ssl_set_cert(c,x));
d85 1
a85 4
int SSL_use_certificate_file(ssl, file, type)
SSL *ssl;
char *file;
int type;
d112 1
a112 1
		x=PEM_read_bio_X509(in,NULL,ssl->ctx->default_passwd_callback);
d134 1
a134 4
int SSL_use_certificate_ASN1(ssl, len, d)
SSL *ssl;
int len;
unsigned char *d;
d152 1
a152 3
int SSL_use_RSAPrivateKey(ssl, rsa)
SSL *ssl;
RSA *rsa;
a153 1
	CERT *c;
d162 4
a165 11

        if ((ssl->cert == NULL) || (ssl->cert == ssl->ctx->default_cert))
                {
                c=ssl_cert_new();
		if (c == NULL)
			{
			SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY,ERR_R_MALLOC_FAILURE);
			return(0);
			}
                if (ssl->cert != NULL) ssl_cert_free(ssl->cert);
		ssl->cert=c;
a166 1
	c=ssl->cert;
d176 1
a176 1
	ret=ssl_set_pkey(c,pkey);
d182 1
a182 3
static int ssl_set_pkey(c,pkey)
CERT *c;
EVP_PKEY *pkey;
d195 6
d256 1
a256 4
int SSL_use_RSAPrivateKey_file(ssl, file, type)
SSL *ssl;
char *file;
int type;
d283 1
a283 1
			ssl->ctx->default_passwd_callback);
d303 1
a303 4
int SSL_use_RSAPrivateKey_ASN1(ssl,d,len)
SSL *ssl;
unsigned char *d;
long len;
d322 1
a322 3
int SSL_use_PrivateKey(ssl, pkey)
SSL *ssl;
EVP_PKEY *pkey;
a323 1
	CERT *c;
d331 4
a334 11

        if ((ssl->cert == NULL) || (ssl->cert == ssl->ctx->default_cert))
                {
                c=ssl_cert_new();
		if (c == NULL)
			{
			SSLerr(SSL_F_SSL_USE_PRIVATEKEY,ERR_R_MALLOC_FAILURE);
			return(0);
			}
                if (ssl->cert != NULL) ssl_cert_free(ssl->cert);
		ssl->cert=c;
d336 1
a336 3
	c=ssl->cert;

	ret=ssl_set_pkey(c,pkey);
d341 1
a341 4
int SSL_use_PrivateKey_file(ssl, file, type)
SSL *ssl;
char *file;
int type;
d363 1
a363 1
			ssl->ctx->default_passwd_callback);
d383 1
a383 5
int SSL_use_PrivateKey_ASN1(type,ssl,d,len)
int type;
SSL *ssl;
unsigned char *d;
long len;
d401 1
a401 3
int SSL_CTX_use_certificate(ctx, x)
SSL_CTX *ctx;
X509 *x;
a402 2
	CERT *c;

d408 1
a408 2

	if (ctx->default_cert == NULL)
d410 2
a411 7
		c=ssl_cert_new();
		if (c == NULL)
			{
			SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE,ERR_R_MALLOC_FAILURE);
			return(0);
			}
		ctx->default_cert=c;
d413 1
a413 3
	c=ctx->default_cert;

	return(ssl_set_cert(c,x));
d416 1
a416 3
static int ssl_set_cert(c,x)
CERT *c;
X509 *x;
d432 1
d438 13
d474 1
d479 1
d497 1
a497 4
int SSL_CTX_use_certificate_file(ctx, file, type)
SSL_CTX *ctx;
char *file;
int type;
d524 1
a524 1
		x=PEM_read_bio_X509(in,NULL,ctx->default_passwd_callback);
d546 1
a546 4
int SSL_CTX_use_certificate_ASN1(ctx, len, d)
SSL_CTX *ctx;
int len;
unsigned char *d;
d564 1
a564 3
int SSL_CTX_use_RSAPrivateKey(ctx, rsa)
SSL_CTX *ctx;
RSA *rsa;
a566 1
	CERT *c;
d574 1
a574 1
	if (ctx->default_cert == NULL)
d576 2
a577 7
		c=ssl_cert_new();
		if (c == NULL)
			{
			SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY,ERR_R_MALLOC_FAILURE);
			return(0);
			}
		ctx->default_cert=c;
a578 2
	c=ctx->default_cert;

d588 1
a588 1
	ret=ssl_set_pkey(c,pkey);
d594 1
a594 4
int SSL_CTX_use_RSAPrivateKey_file(ctx, file, type)
SSL_CTX *ctx;
char *file;
int type;
d621 1
a621 1
			ctx->default_passwd_callback);
d641 1
a641 4
int SSL_CTX_use_RSAPrivateKey_ASN1(ctx,d,len)
SSL_CTX *ctx;
unsigned char *d;
long len;
d660 1
a660 3
int SSL_CTX_use_PrivateKey(ctx, pkey)
SSL_CTX *ctx;
EVP_PKEY *pkey;
a661 2
	CERT *c;

d667 1
a667 2
		
	if (ctx->default_cert == NULL)
d669 2
a670 7
		c=ssl_cert_new();
		if (c == NULL)
			{
			SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY,ERR_R_MALLOC_FAILURE);
			return(0);
			}
		ctx->default_cert=c;
d672 1
a672 3
	c=ctx->default_cert;

	return(ssl_set_pkey(c,pkey));
d676 1
a676 4
int SSL_CTX_use_PrivateKey_file(ctx, file, type)
SSL_CTX *ctx;
char *file;
int type;
d698 1
a698 1
			ctx->default_passwd_callback);
d718 2
a719 5
int SSL_CTX_use_PrivateKey_ASN1(type,ctx,d,len)
int type;
SSL_CTX *ctx;
unsigned char *d;
long len;
d738 78
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d60 5
a64 5
#include <openssl/bio.h>
#include <openssl/objects.h>
#include <openssl/evp.h>
#include <openssl/x509.h>
#include <openssl/pem.h>
d67 1
d70 8
a77 1
int SSL_use_certificate(SSL *ssl, X509 *x)
d79 2
d86 1
a86 1
	if (!ssl_cert_inst(&ssl->cert))
d88 8
a95 2
		SSLerr(SSL_F_SSL_USE_CERTIFICATE,ERR_R_MALLOC_FAILURE);
		return(0);
d97 3
a99 1
	return(ssl_set_cert(ssl->cert,x));
d102 5
a106 2
#ifndef OPENSSL_NO_STDIO
int SSL_use_certificate_file(SSL *ssl, const char *file, int type)
d133 1
a133 1
		x=PEM_read_bio_X509(in,NULL,ssl->ctx->default_passwd_callback,ssl->ctx->default_passwd_callback_userdata);
d155 4
a158 1
int SSL_use_certificate_ASN1(SSL *ssl, unsigned char *d, int len)
d175 4
a178 2
#ifndef OPENSSL_NO_RSA
int SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa)
d180 1
d189 11
a199 4
	if (!ssl_cert_inst(&ssl->cert))
		{
		SSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY,ERR_R_MALLOC_FAILURE);
		return(0);
d201 1
d208 1
a208 1
	RSA_up_ref(rsa);
d211 1
a211 1
	ret=ssl_set_pkey(ssl->cert,pkey);
d217 3
a219 1
static int ssl_set_pkey(CERT *c, EVP_PKEY *pkey)
d232 1
a232 7
		EVP_PKEY *pktmp;
		pktmp =	X509_get_pubkey(c->pkeys[i].x509);
		EVP_PKEY_copy_parameters(pktmp,pkey);
		EVP_PKEY_free(pktmp);
		ERR_clear_error();

#ifndef OPENSSL_NO_RSA
d285 6
a290 3
#ifndef OPENSSL_NO_RSA
#ifndef OPENSSL_NO_STDIO
int SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type)
d317 1
a317 1
			ssl->ctx->default_passwd_callback,ssl->ctx->default_passwd_callback_userdata);
d337 4
a340 1
int SSL_use_RSAPrivateKey_ASN1(SSL *ssl, unsigned char *d, long len)
d343 1
a343 1
	const unsigned char *p;
d357 1
a357 1
#endif /* !OPENSSL_NO_RSA */
d359 3
a361 1
int SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey)
d363 1
d371 11
a381 4
	if (!ssl_cert_inst(&ssl->cert))
		{
		SSLerr(SSL_F_SSL_USE_PRIVATEKEY,ERR_R_MALLOC_FAILURE);
		return(0);
d383 3
a385 1
	ret=ssl_set_pkey(ssl->cert,pkey);
d389 5
a393 2
#ifndef OPENSSL_NO_STDIO
int SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type)
d415 1
a415 1
			ssl->ctx->default_passwd_callback,ssl->ctx->default_passwd_callback_userdata);
d435 5
a439 1
int SSL_use_PrivateKey_ASN1(int type, SSL *ssl, unsigned char *d, long len)
d457 3
a459 1
int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x)
d461 2
d468 2
a469 1
	if (!ssl_cert_inst(&ctx->cert))
d471 7
a477 2
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE,ERR_R_MALLOC_FAILURE);
		return(0);
d479 3
a481 1
	return(ssl_set_cert(ctx->cert, x));
d484 3
a486 1
static int ssl_set_cert(CERT *c, X509 *x)
a501 1
		EVP_PKEY_free(pkey);
a506 13
		EVP_PKEY_copy_parameters(pkey,c->pkeys[i].privatekey);
		ERR_clear_error();

#ifndef OPENSSL_NO_RSA
		/* Don't check the public/private key, this is mostly
		 * for smart cards. */
		if ((c->pkeys[i].privatekey->type == EVP_PKEY_RSA) &&
			(RSA_flags(c->pkeys[i].privatekey->pkey.rsa) &
			 RSA_METHOD_FLAG_NO_CHECK))
			 ok=1;
		else
#endif
		{
a529 1
		} /* OPENSSL_NO_RSA */
a533 1
	EVP_PKEY_free(pkey);
d550 5
a554 2
#ifndef OPENSSL_NO_STDIO
int SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type)
d581 1
a581 1
		x=PEM_read_bio_X509(in,NULL,ctx->default_passwd_callback,ctx->default_passwd_callback_userdata);
d603 4
a606 1
int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, unsigned char *d)
d623 4
a626 2
#ifndef OPENSSL_NO_RSA
int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa)
d629 1
d637 1
a637 1
	if (!ssl_cert_inst(&ctx->cert))
d639 7
a645 2
		SSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY,ERR_R_MALLOC_FAILURE);
		return(0);
d647 2
d655 1
a655 1
	RSA_up_ref(rsa);
d658 1
a658 1
	ret=ssl_set_pkey(ctx->cert, pkey);
d663 5
a667 2
#ifndef OPENSSL_NO_STDIO
int SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type)
d694 1
a694 1
			ctx->default_passwd_callback,ctx->default_passwd_callback_userdata);
d714 4
a717 1
int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, unsigned char *d, long len)
d720 1
a720 1
	const unsigned char *p;
d734 1
a734 1
#endif /* !OPENSSL_NO_RSA */
d736 3
a738 1
int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey)
d740 2
d747 2
a748 1
	if (!ssl_cert_inst(&ctx->cert))
d750 7
a756 2
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY,ERR_R_MALLOC_FAILURE);
		return(0);
d758 3
a760 1
	return(ssl_set_pkey(ctx->cert,pkey));
d763 5
a767 2
#ifndef OPENSSL_NO_STDIO
int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type)
d789 1
a789 1
			ctx->default_passwd_callback,ctx->default_passwd_callback_userdata);
d809 5
a813 2
int SSL_CTX_use_PrivateKey_ASN1(int type, SSL_CTX *ctx, unsigned char *d,
	     long len)
a831 78
#ifndef OPENSSL_NO_STDIO
/* Read a file that contains our certificate in "PEM" format,
 * possibly followed by a sequence of CA certificates that should be
 * sent to the peer in the Certificate message.
 */
int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file)
	{
	BIO *in;
	int ret=0;
	X509 *x=NULL;

	in=BIO_new(BIO_s_file_internal());
	if (in == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE,ERR_R_BUF_LIB);
		goto end;
		}

	if (BIO_read_filename(in,file) <= 0)
		{
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE,ERR_R_SYS_LIB);
		goto end;
		}

	x=PEM_read_bio_X509(in,NULL,ctx->default_passwd_callback,ctx->default_passwd_callback_userdata);
	if (x == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE,ERR_R_PEM_LIB);
		goto end;
		}

	ret=SSL_CTX_use_certificate(ctx,x);
	if (ERR_peek_error() != 0)
		ret = 0;  /* Key/certificate mismatch doesn't imply ret==0 ... */
	if (ret)
		{
		/* If we could set up our certificate, now proceed to
		 * the CA certificates.
		 */
		X509 *ca;
		int r;
		unsigned long err;
		
		if (ctx->extra_certs != NULL) 
			{
			sk_X509_pop_free(ctx->extra_certs, X509_free);
			ctx->extra_certs = NULL;
			}

		while ((ca = PEM_read_bio_X509(in,NULL,ctx->default_passwd_callback,ctx->default_passwd_callback_userdata))
			!= NULL)
			{
			r = SSL_CTX_add_extra_chain_cert(ctx, ca);
			if (!r) 
				{
				X509_free(ca);
				ret = 0;
				goto end;
				}
			/* Note that we must not free r if it was successfully
			 * added to the chain (while we must free the main
			 * certificate, since its reference count is increased
			 * by SSL_CTX_use_certificate). */
			}
		/* When the while loop ends, it's usually just EOF. */
		err = ERR_peek_last_error();
		if (ERR_GET_LIB(err) == ERR_LIB_PEM && ERR_GET_REASON(err) == PEM_R_NO_START_LINE)
			(void)ERR_get_error();
		else 
			ret = 0; /* some real error */
		}

end:
	if (x != NULL) X509_free(x);
	if (in != NULL) BIO_free(in);
	return(ret);
	}
#endif
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a59 1
#include "ssl_locl.h"
d65 1
@


1.1.1.4
log
@import 0.9.7c
@
text
@d210 1
a210 1
		     if (!X509_check_private_key(c->pkeys[i].x509,pkey))
a243 2
	ERR_clear_error(); /* make sure no error from X509_check_private_key()
	                    * is left if we have chosen to ignore it */
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d807 1
a807 1
			ERR_clear_error();
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@d134 1
a134 1
int SSL_use_certificate_ASN1(SSL *ssl, const unsigned char *d, int len)
d184 1
a184 1
	int i;
d205 3
a207 2
			(RSA_flags(pkey->pkey.rsa) & RSA_METHOD_FLAG_NO_CHECK))
			;
d210 1
a210 1
		if (!X509_check_private_key(c->pkeys[i].x509,pkey))
d212 18
a229 3
			X509_free(c->pkeys[i].x509);
			c->pkeys[i].x509 = NULL;
			return 0;
d231 2
d234 2
d237 9
a366 5
	else if (type == SSL_FILETYPE_ASN1)
		{
		j = ERR_R_ASN1_LIB;
		pkey = d2i_PrivateKey_bio(in,NULL);
		}
d385 1
a385 1
int SSL_use_PrivateKey_ASN1(int type, SSL *ssl, const unsigned char *d, long len)
d388 1
a388 1
	const unsigned char *p;
d421 1
a421 1
	int i;
d449 1
a449 1
			 ;
d451 2
a452 1
#endif /* OPENSSL_NO_RSA */
d455 18
a472 8
			/* don't fail for a cert/key mismatch, just free
			 * current private key (when switching to a different
			 * cert & key, first this function should be used,
			 * then ssl_set_pkey */
			EVP_PKEY_free(c->pkeys[i].privatekey);
			c->pkeys[i].privatekey=NULL;
			/* clear error queue */
			ERR_clear_error();
d474 3
d478 2
d482 5
d548 1
a548 1
int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, const unsigned char *d)
d643 1
a643 1
int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, const unsigned char *d, long len)
a701 5
	else if (type == SSL_FILETYPE_ASN1)
		{
		j = ERR_R_ASN1_LIB;
		pkey = d2i_PrivateKey_bio(in,NULL);
		}
d720 1
a720 1
int SSL_CTX_use_PrivateKey_ASN1(int type, SSL_CTX *ctx, const unsigned char *d,
d724 1
a724 1
	const unsigned char *p;
a749 2

	ERR_clear_error(); /* clear error stack for SSL_CTX_use_certificate() */
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@d726 1
a726 1
	x=PEM_read_bio_X509_AUX(in,NULL,ctx->default_passwd_callback,ctx->default_passwd_callback_userdata);
@


1.1.1.8
log
@Import OpenSSL 1.0.1g
@
text
@d713 1
a713 1
	in = BIO_new(BIO_s_file_internal());
d726 1
a726 2
	x=PEM_read_bio_X509_AUX(in,NULL,ctx->default_passwd_callback,
				ctx->default_passwd_callback_userdata);
d733 1
a733 2
	ret = SSL_CTX_use_certificate(ctx, x);

d745 1
a745 1
		if (ctx->extra_certs != NULL)
d751 1
a751 3
		while ((ca = PEM_read_bio_X509(in, NULL,
					ctx->default_passwd_callback,
					ctx->default_passwd_callback_userdata))
@


