head	1.76;
access;
symbols
	OPENBSD_6_2:1.76.0.4
	OPENBSD_6_2_BASE:1.76
	OPENBSD_6_1:1.74.0.4
	OPENBSD_6_1_BASE:1.74;
locks; strict;
comment	@ * @;


1.76
date	2017.05.07.04.22.24;	author beck;	state Exp;
branches;
next	1.75;
commitid	lvbt7GJEb5w5u0NS;

1.75
date	2017.05.06.22.24.57;	author beck;	state Exp;
branches;
next	1.74;
commitid	caPZfWYl80TRorLe;

1.74
date	2017.02.07.02.08.38;	author beck;	state Exp;
branches;
next	1.73;
commitid	xH3OeartUDKSlAnB;

1.73
date	2017.01.26.12.16.13;	author beck;	state Exp;
branches;
next	1.72;
commitid	lb4UTPLS9Casn2PL;

1.72
date	2017.01.26.10.40.21;	author beck;	state Exp;
branches;
next	1.71;
commitid	Bi1VygMenL4YtCp7;

1.71
date	2017.01.26.06.32.58;	author jsing;	state Exp;
branches;
next	1.70;
commitid	TbFBd2VdEVckCCsd;

1.70
date	2017.01.26.05.31.25;	author jsing;	state Exp;
branches;
next	1.69;
commitid	GRopTNgx07uByytM;

1.69
date	2017.01.23.13.36.13;	author jsing;	state Exp;
branches;
next	1.68;
commitid	xYJ523Ay020rUB5W;

1.68
date	2017.01.23.10.22.06;	author jsing;	state Exp;
branches;
next	1.67;
commitid	sfluQzS4C53eT1pq;

1.67
date	2017.01.23.08.48.44;	author beck;	state Exp;
branches;
next	1.66;
commitid	vAKES6VByBpegTl4;

1.66
date	2017.01.23.06.45.30;	author beck;	state Exp;
branches;
next	1.65;
commitid	grTXB43OAHDwwKOU;

1.65
date	2017.01.23.04.55.26;	author beck;	state Exp;
branches;
next	1.64;
commitid	AhwkqHI5lKK3NR31;

1.64
date	2017.01.23.04.15.28;	author jsing;	state Exp;
branches;
next	1.63;
commitid	j20UnjrPw7WvzMvm;

1.63
date	2017.01.23.00.12.54;	author jsing;	state Exp;
branches;
next	1.62;
commitid	Ry6OEk67lc2U2xi9;

1.62
date	2017.01.22.09.02.07;	author jsing;	state Exp;
branches;
next	1.61;
commitid	570ElYZpaAvthwZh;

1.61
date	2017.01.22.07.16.38;	author beck;	state Exp;
branches;
next	1.60;
commitid	qajmn1SU3Rm3vz6g;

1.60
date	2017.01.21.06.50.02;	author jsing;	state Exp;
branches;
next	1.59;
commitid	SLShWZcEQp4rguvl;

1.59
date	2016.12.06.13.38.11;	author jsing;	state Exp;
branches;
next	1.58;
commitid	NUWXcEP3cB3L0fHl;

1.58
date	2016.11.04.19.11.43;	author jsing;	state Exp;
branches;
next	1.57;
commitid	flfhf3ewosqcrbcc;

1.57
date	2016.11.04.18.30.21;	author guenther;	state Exp;
branches;
next	1.56;
commitid	SNICeApXI9gSqHEv;

1.56
date	2016.03.11.07.08.45;	author mmcc;	state Exp;
branches;
next	1.55;
commitid	MTdM7aVFdRMAzAYE;

1.55
date	2015.09.12.16.10.07;	author doug;	state Exp;
branches;
next	1.54;
commitid	VR022UcxWVmcgSOF;

1.54
date	2015.09.12.12.58.15;	author jsing;	state Exp;
branches;
next	1.53;
commitid	1jVyIriiuraS5IRJ;

1.53
date	2015.09.12.12.26.56;	author jsing;	state Exp;
branches;
next	1.52;
commitid	U95DqojbIagvkkKK;

1.52
date	2015.09.11.18.08.21;	author jsing;	state Exp;
branches;
next	1.51;
commitid	pa8oXRlJthT375Ws;

1.51
date	2015.09.11.16.28.37;	author jsing;	state Exp;
branches;
next	1.50;
commitid	D3HqE5ZRseh1ZZFx;

1.50
date	2015.09.10.17.57.50;	author jsing;	state Exp;
branches;
next	1.49;
commitid	T35skZJCouRaXVVY;

1.49
date	2015.09.10.15.56.26;	author jsing;	state Exp;
branches;
next	1.48;
commitid	vHznCDK3idwNEFz4;

1.48
date	2015.09.02.17.59.15;	author jsing;	state Exp;
branches;
next	1.47;
commitid	6qqbZhzSEFZnYRiq;

1.47
date	2015.07.15.18.35.34;	author beck;	state Exp;
branches;
next	1.46;
commitid	JY6O4DRAnDaT0LYP;

1.46
date	2015.07.14.05.26.32;	author doug;	state Exp;
branches;
next	1.45;
commitid	VOFzkj8Uv0Q5MLhu;

1.45
date	2015.06.13.08.38.10;	author doug;	state Exp;
branches;
next	1.44;
commitid	A7PrDVdy9HjfQlSR;

1.44
date	2015.03.27.12.29.54;	author jsing;	state Exp;
branches;
next	1.43;
commitid	GlMku1cNd3nfgnVW;

1.43
date	2015.02.09.10.53.28;	author jsing;	state Exp;
branches;
next	1.42;
commitid	91DZ31h3Xbk1xWbU;

1.42
date	2015.02.06.08.30.23;	author jsing;	state Exp;
branches;
next	1.41;
commitid	K5MXFl39zEkHakNY;

1.41
date	2014.12.14.16.19.38;	author jsing;	state Exp;
branches;
next	1.40;
commitid	LQ4CRrGioEdszPsH;

1.40
date	2014.12.10.15.43.31;	author jsing;	state Exp;
branches;
next	1.39;
commitid	9GGF3DCNTm9Bs8E3;

1.39
date	2014.12.06.14.24.26;	author jsing;	state Exp;
branches;
next	1.38;
commitid	R8J9s9ZDvNB7vidN;

1.38
date	2014.11.27.16.03.03;	author jsing;	state Exp;
branches;
next	1.37;
commitid	O7qAKZyO2otZLhDu;

1.37
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.36;
commitid	M3pvHgIFoWUHNqJn;

1.36
date	2014.10.18.16.13.16;	author jsing;	state Exp;
branches;
next	1.35;
commitid	cGE1JG2i0h4NcVDi;

1.35
date	2014.09.07.12.16.23;	author jsing;	state Exp;
branches;
next	1.34;
commitid	oAt7EW2Y0Fwu0XNB;

1.34
date	2014.08.10.14.42.55;	author jsing;	state Exp;
branches;
next	1.33;
commitid	wihJupNvfkdpKL9O;

1.33
date	2014.08.07.20.02.23;	author miod;	state Exp;
branches
	1.33.2.1;
next	1.32;
commitid	DMh9IXTC6aDWVuh5;

1.32
date	2014.08.07.19.46.31;	author miod;	state Exp;
branches;
next	1.31;
commitid	vayOLqnrIMw5dnz8;

1.31
date	2014.07.12.22.33.39;	author jsing;	state Exp;
branches;
next	1.30;
commitid	JT7oO4AHgBkjVLfZ;

1.30
date	2014.07.12.13.11.53;	author jsing;	state Exp;
branches;
next	1.29;
commitid	tJhRneQ4w1l9LuV2;

1.29
date	2014.07.11.22.57.25;	author miod;	state Exp;
branches;
next	1.28;
commitid	n7W5lBeOlkdDXzQO;

1.28
date	2014.07.11.09.24.44;	author beck;	state Exp;
branches;
next	1.27;
commitid	cCGiAdDteN08GytD;

1.27
date	2014.07.10.08.51.14;	author tedu;	state Exp;
branches;
next	1.26;
commitid	lsH7iukeZYSZBx6F;

1.26
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	mJUVYpkFBZ0Zv2bG;

1.25
date	2014.06.07.22.23.12;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	4IX3BI6FoxwuHgdS;

1.24
date	2014.06.07.14.10.35;	author jsing;	state Exp;
branches;
next	1.23;
commitid	AgFmutmGDUehZZeH;

1.23
date	2014.05.31.14.15.21;	author jsing;	state Exp;
branches;
next	1.22;

1.22
date	2014.05.31.10.49.28;	author jsing;	state Exp;
branches;
next	1.21;

1.21
date	2014.05.30.14.30.50;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2014.05.29.18.11.13;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2014.05.28.13.03.24;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2014.05.24.12.44.48;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2014.05.05.15.03.22;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.23.22.26.26;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.21.16.34.43;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.17.21.41.12;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.17.21.37.37;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.14.18.45.55;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.14.17.45.38;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.14.14.51.11;	author jsing;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.13.21.11.19;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches
	1.5.4.1
	1.5.8.1;
next	1.4;

1.4
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.01.09.12.14.06;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.11.03.02.32.19;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.10.13.21.23.49;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;

1.5.4.1
date	2014.08.09.16.55.55;	author tedu;	state Exp;
branches;
next	;
commitid	M9vFauFXshUDHG4j;

1.5.8.1
date	2014.08.09.16.54.57;	author tedu;	state Exp;
branches;
next	;
commitid	iDBdpZ9JdHGZqIAL;

1.33.2.1
date	2015.03.11.19.52.37;	author tedu;	state Exp;
branches;
next	;
commitid	hkSvLV4ooBbkYqsi;


desc
@@


1.76
log
@Move state from ssl->internal to the handshake structure.
while we are at it, convert SSLerror to use a function
internally, so that we may later allocate the handshake
structure and check for it
ok jsing@@
@
text
@/* $OpenBSD: d1_clnt.c,v 1.75 2017/05/06 22:24:57 beck Exp $ */
/*
 * DTLS implementation written by Nagendra Modadugu
 * (nagendra@@cs.stanford.edu) for the OpenSSL project 2005.
 */
/* ====================================================================
 * Copyright (c) 1999-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <limits.h>
#include <stdio.h>

#include "ssl_locl.h"

#include <openssl/bn.h>
#include <openssl/buffer.h>
#include <openssl/dh.h>
#include <openssl/evp.h>
#include <openssl/md5.h>
#include <openssl/objects.h>

#include "bytestring.h"

static int dtls1_get_hello_verify(SSL *s);

static const SSL_METHOD_INTERNAL DTLSv1_client_method_internal_data = {
	.version = DTLS1_VERSION,
	.min_version = DTLS1_VERSION,
	.max_version = DTLS1_VERSION,
	.ssl_new = dtls1_new,
	.ssl_clear = dtls1_clear,
	.ssl_free = dtls1_free,
	.ssl_accept = ssl_undefined_function,
	.ssl_connect = dtls1_connect,
	.ssl_read = ssl3_read,
	.ssl_peek = ssl3_peek,
	.ssl_write = ssl3_write,
	.ssl_shutdown = dtls1_shutdown,
	.ssl_pending = ssl3_pending,
	.get_ssl_method = dtls1_get_client_method,
	.get_timeout = dtls1_default_timeout,
	.ssl_version = ssl_undefined_void_function,
	.ssl_renegotiate = ssl3_renegotiate,
	.ssl_renegotiate_check = ssl3_renegotiate_check,
	.ssl_get_message = dtls1_get_message,
	.ssl_read_bytes = dtls1_read_bytes,
	.ssl_write_bytes = dtls1_write_app_data_bytes,
	.ssl3_enc = &DTLSv1_enc_data,
};

static const SSL_METHOD DTLSv1_client_method_data = {
	.ssl_dispatch_alert = dtls1_dispatch_alert,
	.num_ciphers = ssl3_num_ciphers,
	.get_cipher = dtls1_get_cipher,
	.get_cipher_by_char = ssl3_get_cipher_by_char,
	.put_cipher_by_char = ssl3_put_cipher_by_char,
	.internal = &DTLSv1_client_method_internal_data,
};

const SSL_METHOD *
DTLSv1_client_method(void)
{
	return &DTLSv1_client_method_data;
}

const SSL_METHOD *
dtls1_get_client_method(int ver)
{
	if (ver == DTLS1_VERSION)
		return (DTLSv1_client_method());
	return (NULL);
}

int
dtls1_connect(SSL *s)
{
	void (*cb)(const SSL *ssl, int type, int val) = NULL;
	int ret = -1;
	int new_state, state, skip = 0;

	ERR_clear_error();
	errno = 0;

	if (s->internal->info_callback != NULL)
		cb = s->internal->info_callback;
	else if (s->ctx->internal->info_callback != NULL)
		cb = s->ctx->internal->info_callback;

	s->internal->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s))
		SSL_clear(s);


	for (;;) {
		state = S3I(s)->hs.state;

		switch (S3I(s)->hs.state) {
		case SSL_ST_RENEGOTIATE:
			s->internal->renegotiate = 1;
			S3I(s)->hs.state = SSL_ST_CONNECT;
			s->ctx->internal->stats.sess_connect_renegotiate++;
			/* break */
		case SSL_ST_BEFORE:
		case SSL_ST_CONNECT:
		case SSL_ST_BEFORE|SSL_ST_CONNECT:
		case SSL_ST_OK|SSL_ST_CONNECT:

			s->server = 0;
			if (cb != NULL)
				cb(s, SSL_CB_HANDSHAKE_START, 1);

			if ((s->version & 0xff00 ) != (DTLS1_VERSION & 0xff00)) {
				SSLerror(s, ERR_R_INTERNAL_ERROR);
				ret = -1;
				goto end;
			}

			/* s->version=SSL3_VERSION; */
			s->internal->type = SSL_ST_CONNECT;

			if (!ssl3_setup_init_buffer(s)) {
				ret = -1;
				goto end;
			}
			if (!ssl3_setup_buffers(s)) {
				ret = -1;
				goto end;
			}
			if (!ssl_init_wbio_buffer(s, 0)) {
				ret = -1;
				goto end;
			}

			/* don't push the buffering BIO quite yet */

			S3I(s)->hs.state = SSL3_ST_CW_CLNT_HELLO_A;
			s->ctx->internal->stats.sess_connect++;
			s->internal->init_num = 0;
			/* mark client_random uninitialized */
			memset(s->s3->client_random, 0,
			    sizeof(s->s3->client_random));
			D1I(s)->send_cookie = 0;
			s->internal->hit = 0;
			break;


		case SSL3_ST_CW_CLNT_HELLO_A:
		case SSL3_ST_CW_CLNT_HELLO_B:

			s->internal->shutdown = 0;

			/* every DTLS ClientHello resets Finished MAC */
			if (!tls1_init_finished_mac(s)) {
				ret = -1;
				goto end;
			}

			dtls1_start_timer(s);
			ret = ssl3_client_hello(s);
			if (ret <= 0)
				goto end;

			if (D1I(s)->send_cookie) {
				S3I(s)->hs.state = SSL3_ST_CW_FLUSH;
				S3I(s)->hs.next_state = SSL3_ST_CR_SRVR_HELLO_A;
			} else
				S3I(s)->hs.state = SSL3_ST_CR_SRVR_HELLO_A;

			s->internal->init_num = 0;

			/* turn on buffering for the next lot of output */
			if (s->bbio != s->wbio)
				s->wbio = BIO_push(s->bbio, s->wbio);

			break;

		case SSL3_ST_CR_SRVR_HELLO_A:
		case SSL3_ST_CR_SRVR_HELLO_B:
			ret = ssl3_get_server_hello(s);
			if (ret <= 0)
				goto end;
			else {
				if (s->internal->hit) {

					S3I(s)->hs.state = SSL3_ST_CR_FINISHED_A;
				} else
					S3I(s)->hs.state = DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A;
			}
			s->internal->init_num = 0;
			break;

		case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A:
		case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B:

			ret = dtls1_get_hello_verify(s);
			if (ret <= 0)
				goto end;
			dtls1_stop_timer(s);
			if ( D1I(s)->send_cookie) /* start again, with a cookie */
				S3I(s)->hs.state = SSL3_ST_CW_CLNT_HELLO_A;
			else
				S3I(s)->hs.state = SSL3_ST_CR_CERT_A;
			s->internal->init_num = 0;
			break;

		case SSL3_ST_CR_CERT_A:
		case SSL3_ST_CR_CERT_B:
			ret = ssl3_check_finished(s);
			if (ret <= 0)
				goto end;
			if (ret == 2) {
				s->internal->hit = 1;
				if (s->internal->tlsext_ticket_expected)
					S3I(s)->hs.state = SSL3_ST_CR_SESSION_TICKET_A;
				else
					S3I(s)->hs.state = SSL3_ST_CR_FINISHED_A;
				s->internal->init_num = 0;
				break;
			}
			/* Check if it is anon DH. */
			if (!(S3I(s)->hs.new_cipher->algorithm_auth &
			    SSL_aNULL)) {
				ret = ssl3_get_server_certificate(s);
				if (ret <= 0)
					goto end;
				if (s->internal->tlsext_status_expected)
					S3I(s)->hs.state = SSL3_ST_CR_CERT_STATUS_A;
				else
					S3I(s)->hs.state = SSL3_ST_CR_KEY_EXCH_A;
			} else {
				skip = 1;
				S3I(s)->hs.state = SSL3_ST_CR_KEY_EXCH_A;
			}
			s->internal->init_num = 0;
			break;

		case SSL3_ST_CR_KEY_EXCH_A:
		case SSL3_ST_CR_KEY_EXCH_B:
			ret = ssl3_get_server_key_exchange(s);
			if (ret <= 0)
				goto end;
			S3I(s)->hs.state = SSL3_ST_CR_CERT_REQ_A;
			s->internal->init_num = 0;

			/* at this point we check that we have the
			 * required stuff from the server */
			if (!ssl3_check_cert_and_algorithm(s)) {
				ret = -1;
				goto end;
			}
			break;

		case SSL3_ST_CR_CERT_REQ_A:
		case SSL3_ST_CR_CERT_REQ_B:
			ret = ssl3_get_certificate_request(s);
			if (ret <= 0)
				goto end;
			S3I(s)->hs.state = SSL3_ST_CR_SRVR_DONE_A;
			s->internal->init_num = 0;
			break;

		case SSL3_ST_CR_SRVR_DONE_A:
		case SSL3_ST_CR_SRVR_DONE_B:
			ret = ssl3_get_server_done(s);
			if (ret <= 0)
				goto end;
			dtls1_stop_timer(s);
			if (S3I(s)->tmp.cert_req)
				S3I(s)->hs.next_state = SSL3_ST_CW_CERT_A;
			else
				S3I(s)->hs.next_state = SSL3_ST_CW_KEY_EXCH_A;
			s->internal->init_num = 0;
			S3I(s)->hs.state = S3I(s)->hs.next_state;
			break;

		case SSL3_ST_CW_CERT_A:
		case SSL3_ST_CW_CERT_B:
		case SSL3_ST_CW_CERT_C:
		case SSL3_ST_CW_CERT_D:
			dtls1_start_timer(s);
			ret = ssl3_send_client_certificate(s);
			if (ret <= 0)
				goto end;
			S3I(s)->hs.state = SSL3_ST_CW_KEY_EXCH_A;
			s->internal->init_num = 0;
			break;

		case SSL3_ST_CW_KEY_EXCH_A:
		case SSL3_ST_CW_KEY_EXCH_B:
			dtls1_start_timer(s);
			ret = ssl3_send_client_key_exchange(s);
			if (ret <= 0)
				goto end;

			/* EAY EAY EAY need to check for DH fix cert
			 * sent back */
			/* For TLS, cert_req is set to 2, so a cert chain
			 * of nothing is sent, but no verify packet is sent */
			if (S3I(s)->tmp.cert_req == 1) {
				S3I(s)->hs.state = SSL3_ST_CW_CERT_VRFY_A;
			} else {
				S3I(s)->hs.state = SSL3_ST_CW_CHANGE_A;
				S3I(s)->change_cipher_spec = 0;
			}

			s->internal->init_num = 0;
			break;

		case SSL3_ST_CW_CERT_VRFY_A:
		case SSL3_ST_CW_CERT_VRFY_B:
			dtls1_start_timer(s);
			ret = ssl3_send_client_verify(s);
			if (ret <= 0)
				goto end;
			S3I(s)->hs.state = SSL3_ST_CW_CHANGE_A;
			s->internal->init_num = 0;
			S3I(s)->change_cipher_spec = 0;
			break;

		case SSL3_ST_CW_CHANGE_A:
		case SSL3_ST_CW_CHANGE_B:
			if (!s->internal->hit)
				dtls1_start_timer(s);
			ret = dtls1_send_change_cipher_spec(s,
			    SSL3_ST_CW_CHANGE_A, SSL3_ST_CW_CHANGE_B);
			if (ret <= 0)
				goto end;

			S3I(s)->hs.state = SSL3_ST_CW_FINISHED_A;
			s->internal->init_num = 0;

			s->session->cipher = S3I(s)->hs.new_cipher;
			if (!tls1_setup_key_block(s)) {
				ret = -1;
				goto end;
			}

			if (!tls1_change_cipher_state(s,
			    SSL3_CHANGE_CIPHER_CLIENT_WRITE)) {
				ret = -1;
				goto end;
			}


			dtls1_reset_seq_numbers(s, SSL3_CC_WRITE);
			break;

		case SSL3_ST_CW_FINISHED_A:
		case SSL3_ST_CW_FINISHED_B:
			if (!s->internal->hit)
				dtls1_start_timer(s);
			ret = ssl3_send_finished(s,
			    SSL3_ST_CW_FINISHED_A, SSL3_ST_CW_FINISHED_B,
			    TLS_MD_CLIENT_FINISH_CONST,
			    TLS_MD_CLIENT_FINISH_CONST_SIZE);
			if (ret <= 0)
				goto end;
			S3I(s)->hs.state = SSL3_ST_CW_FLUSH;

			/* clear flags */
			s->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;
			if (s->internal->hit) {
				S3I(s)->hs.next_state = SSL_ST_OK;
				if (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED) {
					S3I(s)->hs.state = SSL_ST_OK;
					s->s3->flags |= SSL3_FLAGS_POP_BUFFER;
					S3I(s)->delay_buf_pop_ret = 0;
				}
			} else {

				/* Allow NewSessionTicket if ticket expected */
				if (s->internal->tlsext_ticket_expected)
					S3I(s)->hs.next_state =
					    SSL3_ST_CR_SESSION_TICKET_A;
				else
					S3I(s)->hs.next_state =
					    SSL3_ST_CR_FINISHED_A;
			}
			s->internal->init_num = 0;
			break;

		case SSL3_ST_CR_SESSION_TICKET_A:
		case SSL3_ST_CR_SESSION_TICKET_B:
			ret = ssl3_get_new_session_ticket(s);
			if (ret <= 0)
				goto end;
			S3I(s)->hs.state = SSL3_ST_CR_FINISHED_A;
			s->internal->init_num = 0;
			break;

		case SSL3_ST_CR_CERT_STATUS_A:
		case SSL3_ST_CR_CERT_STATUS_B:
			ret = ssl3_get_cert_status(s);
			if (ret <= 0)
				goto end;
			S3I(s)->hs.state = SSL3_ST_CR_KEY_EXCH_A;
			s->internal->init_num = 0;
			break;

		case SSL3_ST_CR_FINISHED_A:
		case SSL3_ST_CR_FINISHED_B:
			D1I(s)->change_cipher_spec_ok = 1;
			ret = ssl3_get_finished(s, SSL3_ST_CR_FINISHED_A,
			    SSL3_ST_CR_FINISHED_B);
			if (ret <= 0)
				goto end;
			dtls1_stop_timer(s);

			if (s->internal->hit)
				S3I(s)->hs.state = SSL3_ST_CW_CHANGE_A;
			else
				S3I(s)->hs.state = SSL_ST_OK;


			s->internal->init_num = 0;
			break;

		case SSL3_ST_CW_FLUSH:
			s->internal->rwstate = SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0) {
				/* If the write error was fatal, stop trying */
				if (!BIO_should_retry(s->wbio)) {
					s->internal->rwstate = SSL_NOTHING;
					S3I(s)->hs.state = S3I(s)->hs.next_state;
				}

				ret = -1;
				goto end;
			}
			s->internal->rwstate = SSL_NOTHING;
			S3I(s)->hs.state = S3I(s)->hs.next_state;
			break;

		case SSL_ST_OK:
			/* clean a few things up */
			tls1_cleanup_key_block(s);

			/* If we are not 'joining' the last two packets,
			 * remove the buffering now */
			if (!(s->s3->flags & SSL3_FLAGS_POP_BUFFER))
				ssl_free_wbio_buffer(s);
			/* else do it later in ssl3_write */

			s->internal->init_num = 0;
			s->internal->renegotiate = 0;
			s->internal->new_session = 0;

			ssl_update_cache(s, SSL_SESS_CACHE_CLIENT);
			if (s->internal->hit)
				s->ctx->internal->stats.sess_hit++;

			ret = 1;
			/* s->server=0; */
			s->internal->handshake_func = dtls1_connect;
			s->ctx->internal->stats.sess_connect_good++;

			if (cb != NULL)
				cb(s, SSL_CB_HANDSHAKE_DONE, 1);

			/* done with handshaking */
			D1I(s)->handshake_read_seq = 0;
			D1I(s)->next_handshake_write_seq = 0;
			goto end;
			/* break; */

		default:
			SSLerror(s, SSL_R_UNKNOWN_STATE);
			ret = -1;
			goto end;
			/* break; */
		}

		/* did we do anything */
		if (!S3I(s)->tmp.reuse_message && !skip) {
			if (s->internal->debug) {
				if ((ret = BIO_flush(s->wbio)) <= 0)
					goto end;
			}

			if ((cb != NULL) && (S3I(s)->hs.state != state)) {
				new_state = S3I(s)->hs.state;
				S3I(s)->hs.state = state;
				cb(s, SSL_CB_CONNECT_LOOP, 1);
				S3I(s)->hs.state = new_state;
			}
		}
		skip = 0;
	}

end:
	s->internal->in_handshake--;
	if (cb != NULL)
		cb(s, SSL_CB_CONNECT_EXIT, ret);

	return (ret);
}

static int
dtls1_get_hello_verify(SSL *s)
{
	long n;
	int al, ok = 0;
	size_t cookie_len;
	uint16_t ssl_version;
	CBS hello_verify_request, cookie;

	n = s->method->internal->ssl_get_message(s, DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A,
	    DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B, -1, s->internal->max_cert_list, &ok);

	if (!ok)
		return ((int)n);

	if (S3I(s)->tmp.message_type != DTLS1_MT_HELLO_VERIFY_REQUEST) {
		D1I(s)->send_cookie = 0;
		S3I(s)->tmp.reuse_message = 1;
		return (1);
	}

	if (n < 0)
		goto truncated;

	CBS_init(&hello_verify_request, s->internal->init_msg, n);

	if (!CBS_get_u16(&hello_verify_request, &ssl_version))
		goto truncated;

	if (ssl_version != s->version) {
		SSLerror(s, SSL_R_WRONG_SSL_VERSION);
		s->version = (s->version & 0xff00) | (ssl_version & 0xff);
		al = SSL_AD_PROTOCOL_VERSION;
		goto f_err;
	}

	if (!CBS_get_u8_length_prefixed(&hello_verify_request, &cookie))
		goto truncated;

	if (!CBS_write_bytes(&cookie, D1I(s)->cookie,
	    sizeof(D1I(s)->cookie), &cookie_len)) {
		D1I(s)->cookie_len = 0;
		al = SSL_AD_ILLEGAL_PARAMETER;
		goto f_err;
	}
	D1I(s)->cookie_len = cookie_len;
	D1I(s)->send_cookie = 1;

	return 1;

truncated:
	al = SSL_AD_DECODE_ERROR;
f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
	return -1;
}
@


1.75
log
@Bring in an SSL_HANDSHAKE structure and commence the great shovelling
ok jsing@@, gcc@@, regress@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.74 2017/02/07 02:08:38 beck Exp $ */
d201 1
a201 1
		state = s->internal->state;
d203 1
a203 1
		switch (s->internal->state) {
d206 1
a206 1
			s->internal->state = SSL_ST_CONNECT;
d242 1
a242 1
			s->internal->state = SSL3_ST_CW_CLNT_HELLO_A;
d270 1
a270 1
				s->internal->state = SSL3_ST_CW_FLUSH;
d273 1
a273 1
				s->internal->state = SSL3_ST_CR_SRVR_HELLO_A;
d291 1
a291 1
					s->internal->state = SSL3_ST_CR_FINISHED_A;
d293 1
a293 1
					s->internal->state = DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A;
d306 1
a306 1
				s->internal->state = SSL3_ST_CW_CLNT_HELLO_A;
d308 1
a308 1
				s->internal->state = SSL3_ST_CR_CERT_A;
d320 1
a320 1
					s->internal->state = SSL3_ST_CR_SESSION_TICKET_A;
d322 1
a322 1
					s->internal->state = SSL3_ST_CR_FINISHED_A;
d333 1
a333 1
					s->internal->state = SSL3_ST_CR_CERT_STATUS_A;
d335 1
a335 1
					s->internal->state = SSL3_ST_CR_KEY_EXCH_A;
d338 1
a338 1
				s->internal->state = SSL3_ST_CR_KEY_EXCH_A;
d348 1
a348 1
			s->internal->state = SSL3_ST_CR_CERT_REQ_A;
d364 1
a364 1
			s->internal->state = SSL3_ST_CR_SRVR_DONE_A;
d379 1
a379 1
			s->internal->state = S3I(s)->hs.next_state;
d390 1
a390 1
			s->internal->state = SSL3_ST_CW_KEY_EXCH_A;
d406 1
a406 1
				s->internal->state = SSL3_ST_CW_CERT_VRFY_A;
d408 1
a408 1
				s->internal->state = SSL3_ST_CW_CHANGE_A;
d421 1
a421 1
			s->internal->state = SSL3_ST_CW_CHANGE_A;
d435 1
a435 1
			s->internal->state = SSL3_ST_CW_FINISHED_A;
d464 1
a464 1
			s->internal->state = SSL3_ST_CW_FLUSH;
d471 1
a471 1
					s->internal->state = SSL_ST_OK;
d493 1
a493 1
			s->internal->state = SSL3_ST_CR_FINISHED_A;
d502 1
a502 1
			s->internal->state = SSL3_ST_CR_KEY_EXCH_A;
d516 1
a516 1
				s->internal->state = SSL3_ST_CW_CHANGE_A;
d518 1
a518 1
				s->internal->state = SSL_ST_OK;
d530 1
a530 1
					s->internal->state = S3I(s)->hs.next_state;
d537 1
a537 1
			s->internal->state = S3I(s)->hs.next_state;
d586 3
a588 3
			if ((cb != NULL) && (s->internal->state != state)) {
				new_state = s->internal->state;
				s->internal->state = state;
d590 1
a590 1
				s->internal->state = new_state;
@


1.74
log
@Change SSLerror() back to taking two args, with the first one being an SSL *.
Make a table of "function codes" which maps the internal state of the SSL *
to something like a useful name so in a typical error in the connection you
know in what sort of place in the handshake things happened. (instead of
by arcane function name).
Add SSLerrorx() for when we don't have an SSL *
ok jsing@@ after us both being prodded by bluhm@@ to make it not terrible
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.73 2017/01/26 12:16:13 beck Exp $ */
d271 1
a271 1
				S3I(s)->tmp.next_state = SSL3_ST_CR_SRVR_HELLO_A;
d327 1
a327 1
			if (!(S3I(s)->tmp.new_cipher->algorithm_auth &
d375 1
a375 1
				S3I(s)->tmp.next_state = SSL3_ST_CW_CERT_A;
d377 1
a377 1
				S3I(s)->tmp.next_state = SSL3_ST_CW_KEY_EXCH_A;
d379 1
a379 1
			s->internal->state = S3I(s)->tmp.next_state;
d438 1
a438 1
			s->session->cipher = S3I(s)->tmp.new_cipher;
d469 1
a469 1
				S3I(s)->tmp.next_state = SSL_ST_OK;
d479 1
a479 1
					S3I(s)->tmp.next_state =
d482 1
a482 1
					S3I(s)->tmp.next_state =
d530 1
a530 1
					s->internal->state = S3I(s)->tmp.next_state;
d537 1
a537 1
			s->internal->state = S3I(s)->tmp.next_state;
@


1.73
log
@Finish the fallout of the SSLerr->SSLerror cleanup to get rid of the ugly
line wraps that resulted
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.72 2017/01/26 10:40:21 beck Exp $ */
d219 1
a219 1
				SSLerror(ERR_R_INTERNAL_ERROR);
d573 1
a573 1
			SSLerror(SSL_R_UNKNOWN_STATE);
d634 1
a634 1
		SSLerror(SSL_R_WRONG_SSL_VERSION);
@


1.72
log
@Send the error function codes to rot in the depths of hell where they belong
We leave a single funciton code (0xFFF) to say "SSL_internal" so the public
API will not break, and we replace all internal use of the two argument
SSL_err() with the internal only SSL_error() that only takes a reason code.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.71 2017/01/26 06:32:58 jsing Exp $ */
d219 1
a219 2
				SSLerror(
				    ERR_R_INTERNAL_ERROR);
@


1.71
log
@Remove most of SSL3_ENC_METHOD - we can just inline the function calls
and defines since they are the same everywhere.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.70 2017/01/26 05:31:25 jsing Exp $ */
d219 1
a219 1
				SSLerr(SSL_F_DTLS1_CONNECT,
d574 1
a574 1
			SSLerr(SSL_F_DTLS1_CONNECT, SSL_R_UNKNOWN_STATE);
d635 1
a635 1
		SSLerr(SSL_F_DTLS1_GET_HELLO_VERIFY, SSL_R_WRONG_SSL_VERSION);
@


1.70
log
@Merge the client/server version negotiation into the existing (currently
fixed version) client/server code.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.69 2017/01/23 13:36:13 jsing Exp $ */
d440 1
a440 1
			if (!s->method->internal->ssl3_enc->setup_key_block(s)) {
d445 1
a445 1
			if (!s->method->internal->ssl3_enc->change_cipher_state(s,
d461 2
a462 2
			    s->method->internal->ssl3_enc->client_finished_label,
			    s->method->internal->ssl3_enc->client_finished_label_len);
@


1.69
log
@Split most of SSL_METHOD out into an internal variant, which is opaque.

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.68 2017/01/23 10:22:06 jsing Exp $ */
a129 1
static const SSL_METHOD *dtls1_get_client_method(int ver);
d172 1
a172 1
static const SSL_METHOD *
@


1.68
log
@Remove ssl_ctrl, ssl_ctx_ctrl, ssl_callback_ctrl and ssl_ctx_callback_ctrl
from SSL_METHOD, replacing usage with direct calls to the appropriate
functions.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.67 2017/01/23 08:48:44 beck Exp $ */
d133 1
a133 1
static const SSL_METHOD DTLSv1_client_method_data = {
d146 4
d155 4
d160 2
d164 1
a164 7
	.ssl_pending = ssl3_pending,
	.num_ciphers = ssl3_num_ciphers,
	.get_cipher = dtls1_get_cipher,
	.get_ssl_method = dtls1_get_client_method,
	.get_timeout = dtls1_default_timeout,
	.ssl3_enc = &DTLSv1_enc_data,
	.ssl_version = ssl_undefined_void_function,
d441 1
a441 1
			if (!s->method->ssl3_enc->setup_key_block(s)) {
d446 1
a446 1
			if (!s->method->ssl3_enc->change_cipher_state(s,
d462 2
a463 2
			    s->method->ssl3_enc->client_finished_label,
			    s->method->ssl3_enc->client_finished_label_len);
d615 1
a615 1
	n = s->method->ssl_get_message(s, DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A,
@


1.67
log
@send state and rstate from ssl_st into internal. There are accessors
so these should not be diddled with directly
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.66 2017/01/23 06:45:30 beck Exp $ */
a151 2
	.ssl_ctrl = dtls1_ctrl,
	.ssl_ctx_ctrl = ssl3_ctx_ctrl,
a160 2
	.ssl_callback_ctrl = ssl3_callback_ctrl,
	.ssl_ctx_callback_ctrl = ssl3_ctx_callback_ctrl,
@


1.66
log
@Move a large part of ssl_st into internal, so we can see what squeals.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.65 2017/01/23 04:55:26 beck Exp $ */
d202 1
a202 1
		state = s->state;
d204 1
a204 1
		switch (s->state) {
d207 1
a207 1
			s->state = SSL_ST_CONNECT;
d244 1
a244 1
			s->state = SSL3_ST_CW_CLNT_HELLO_A;
d272 1
a272 1
				s->state = SSL3_ST_CW_FLUSH;
d275 1
a275 1
				s->state = SSL3_ST_CR_SRVR_HELLO_A;
d293 1
a293 1
					s->state = SSL3_ST_CR_FINISHED_A;
d295 1
a295 1
					s->state = DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A;
d308 1
a308 1
				s->state = SSL3_ST_CW_CLNT_HELLO_A;
d310 1
a310 1
				s->state = SSL3_ST_CR_CERT_A;
d322 1
a322 1
					s->state = SSL3_ST_CR_SESSION_TICKET_A;
d324 1
a324 1
					s->state = SSL3_ST_CR_FINISHED_A;
d335 1
a335 1
					s->state = SSL3_ST_CR_CERT_STATUS_A;
d337 1
a337 1
					s->state = SSL3_ST_CR_KEY_EXCH_A;
d340 1
a340 1
				s->state = SSL3_ST_CR_KEY_EXCH_A;
d350 1
a350 1
			s->state = SSL3_ST_CR_CERT_REQ_A;
d366 1
a366 1
			s->state = SSL3_ST_CR_SRVR_DONE_A;
d381 1
a381 1
			s->state = S3I(s)->tmp.next_state;
d392 1
a392 1
			s->state = SSL3_ST_CW_KEY_EXCH_A;
d408 1
a408 1
				s->state = SSL3_ST_CW_CERT_VRFY_A;
d410 1
a410 1
				s->state = SSL3_ST_CW_CHANGE_A;
d423 1
a423 1
			s->state = SSL3_ST_CW_CHANGE_A;
d437 1
a437 1
			s->state = SSL3_ST_CW_FINISHED_A;
d466 1
a466 1
			s->state = SSL3_ST_CW_FLUSH;
d473 1
a473 1
					s->state = SSL_ST_OK;
d495 1
a495 1
			s->state = SSL3_ST_CR_FINISHED_A;
d504 1
a504 1
			s->state = SSL3_ST_CR_KEY_EXCH_A;
d518 1
a518 1
				s->state = SSL3_ST_CW_CHANGE_A;
d520 1
a520 1
				s->state = SSL_ST_OK;
d532 1
a532 1
					s->state = S3I(s)->tmp.next_state;
d539 1
a539 1
			s->state = S3I(s)->tmp.next_state;
d588 3
a590 3
			if ((cb != NULL) && (s->state != state)) {
				new_state = s->state;
				s->state = state;
d592 1
a592 1
				s->state = new_state;
@


1.65
log
@move the callbacks from ssl_st to internal
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.64 2017/01/23 04:15:28 jsing Exp $ */
d206 1
a206 1
			s->renegotiate = 1;
d227 1
a227 1
			s->type = SSL_ST_CONNECT;
d246 1
a246 1
			s->init_num = 0;
d251 1
a251 1
			s->hit = 0;
d258 1
a258 1
			s->shutdown = 0;
d277 1
a277 1
			s->init_num = 0;
d291 1
a291 1
				if (s->hit) {
d297 1
a297 1
			s->init_num = 0;
d311 1
a311 1
			s->init_num = 0;
d320 2
a321 2
				s->hit = 1;
				if (s->tlsext_ticket_expected)
d325 1
a325 1
				s->init_num = 0;
d334 1
a334 1
				if (s->tlsext_status_expected)
d342 1
a342 1
			s->init_num = 0;
d351 1
a351 1
			s->init_num = 0;
d367 1
a367 1
			s->init_num = 0;
d380 1
a380 1
			s->init_num = 0;
d393 1
a393 1
			s->init_num = 0;
d414 1
a414 1
			s->init_num = 0;
d424 1
a424 1
			s->init_num = 0;
d430 1
a430 1
			if (!s->hit)
d438 1
a438 1
			s->init_num = 0;
d458 1
a458 1
			if (!s->hit)
d470 1
a470 1
			if (s->hit) {
d480 1
a480 1
				if (s->tlsext_ticket_expected)
d487 1
a487 1
			s->init_num = 0;
d496 1
a496 1
			s->init_num = 0;
d505 1
a505 1
			s->init_num = 0;
d517 1
a517 1
			if (s->hit)
d523 1
a523 1
			s->init_num = 0;
d527 1
a527 1
			s->rwstate = SSL_WRITING;
d531 1
a531 1
					s->rwstate = SSL_NOTHING;
d538 1
a538 1
			s->rwstate = SSL_NOTHING;
d552 3
a554 3
			s->init_num = 0;
			s->renegotiate = 0;
			s->new_session = 0;
d557 1
a557 1
			if (s->hit)
d583 1
a583 1
			if (s->debug) {
d616 1
a616 1
	    DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B, -1, s->max_cert_list, &ok);
d630 1
a630 1
	CBS_init(&hello_verify_request, s->init_msg, n);
@


1.64
log
@Move callback function pointers and argument pointers from SSL_CTX to
internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.63 2017/01/23 00:12:54 jsing Exp $ */
d191 2
a192 2
	if (s->info_callback != NULL)
		cb = s->info_callback;
d196 1
a196 1
	s->in_handshake++;
d562 1
a562 1
			s->handshake_func = dtls1_connect;
d599 1
a599 1
	s->in_handshake--;
@


1.63
log
@Move the stats struct from SSL_CTX to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.62 2017/01/22 09:02:07 jsing Exp $ */
d193 2
a194 2
	else if (s->ctx->info_callback != NULL)
		cb = s->ctx->info_callback;
@


1.62
log
@Move most of the SSL3_STATE fields to internal - the ones that remain are
known to be used by ports.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.61 2017/01/22 07:16:38 beck Exp $ */
d208 1
a208 1
			s->ctx->stats.sess_connect_renegotiate++;
d245 1
a245 1
			s->ctx->stats.sess_connect++;
d558 1
a558 1
				s->ctx->stats.sess_hit++;
d563 1
a563 1
			s->ctx->stats.sess_connect_good++;
@


1.61
log
@Move most of DTLS1_STATE to internal.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.60 2017/01/21 06:50:02 jsing Exp $ */
d273 1
a273 1
				s->s3->tmp.next_state = SSL3_ST_CR_SRVR_HELLO_A;
d329 1
a329 1
			if (!(s->s3->tmp.new_cipher->algorithm_auth &
d376 2
a377 2
			if (s->s3->tmp.cert_req)
				s->s3->tmp.next_state = SSL3_ST_CW_CERT_A;
d379 1
a379 1
				s->s3->tmp.next_state = SSL3_ST_CW_KEY_EXCH_A;
d381 1
a381 1
			s->state = s->s3->tmp.next_state;
d407 1
a407 1
			if (s->s3->tmp.cert_req == 1) {
d411 1
a411 1
				s->s3->change_cipher_spec = 0;
d425 1
a425 1
			s->s3->change_cipher_spec = 0;
d440 1
a440 1
			s->session->cipher = s->s3->tmp.new_cipher;
d471 1
a471 1
				s->s3->tmp.next_state = SSL_ST_OK;
d475 1
a475 1
					s->s3->delay_buf_pop_ret = 0;
d481 1
a481 1
					s->s3->tmp.next_state =
d484 1
a484 1
					s->s3->tmp.next_state =
d532 1
a532 1
					s->state = s->s3->tmp.next_state;
d539 1
a539 1
			s->state = s->s3->tmp.next_state;
d582 1
a582 1
		if (!s->s3->tmp.reuse_message && !skip) {
d621 1
a621 1
	if (s->s3->tmp.message_type != DTLS1_MT_HELLO_VERIFY_REQUEST) {
d623 1
a623 1
		s->s3->tmp.reuse_message = 1;
@


1.60
log
@Specify minimum and maximum protocol version for each method. This is
currently unused, but will be in the near future.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.59 2016/12/06 13:38:11 jsing Exp $ */
d250 1
a250 1
			s->d1->send_cookie = 0;
d271 1
a271 1
			if (s->d1->send_cookie) {
d307 1
a307 1
			if ( s->d1->send_cookie) /* start again, with a cookie */
d510 1
a510 1
			s->d1->change_cipher_spec_ok = 1;
d569 2
a570 2
			s->d1->handshake_read_seq = 0;
			s->d1->next_handshake_write_seq = 0;
d622 1
a622 1
		s->d1->send_cookie = 0;
d645 3
a647 3
	if (!CBS_write_bytes(&cookie, s->d1->cookie,
	    sizeof(s->d1->cookie), &cookie_len)) {
		s->d1->cookie_len = 0;
d651 2
a652 2
	s->d1->cookie_len = cookie_len;
	s->d1->send_cookie = 1;
@


1.59
log
@Now that ssl3_send_{client,server}_certificate() are using the common
handshake functions, we can remove more copied code from DTLS.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.58 2016/11/04 19:11:43 jsing Exp $ */
d135 2
@


1.58
log
@Rename ssl3_get_key_exchange() to ssl3_get_server_key_exchange(), since
that's what it really is.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.57 2016/11/04 18:30:21 guenther Exp $ */
d387 1
a387 1
			ret = dtls1_send_client_certificate(s);
a658 65
}

int
dtls1_send_client_certificate(SSL *s)
{
	X509 *x509 = NULL;
	EVP_PKEY *pkey = NULL;
	int i;
	unsigned long l;

	if (s->state ==	SSL3_ST_CW_CERT_A) {
		if ((s->cert == NULL) || (s->cert->key->x509 == NULL) ||
		    (s->cert->key->privatekey == NULL))
			s->state = SSL3_ST_CW_CERT_B;
		else
			s->state = SSL3_ST_CW_CERT_C;
	}

	/* We need to get a client cert */
	if (s->state == SSL3_ST_CW_CERT_B) {
		/* If we get an error, we need to
		 * ssl->rwstate=SSL_X509_LOOKUP; return(-1);
		 * We then get retied later */
		i = 0;
		i = ssl_do_client_cert_cb(s, &x509, &pkey);
		if (i < 0) {
			s->rwstate = SSL_X509_LOOKUP;
			return (-1);
		}
		s->rwstate = SSL_NOTHING;
		if ((i == 1) && (pkey != NULL) && (x509 != NULL)) {
			s->state = SSL3_ST_CW_CERT_B;
			if (!SSL_use_certificate(s, x509) ||
			    !SSL_use_PrivateKey(s, pkey))
				i = 0;
		} else if (i == 1) {
			i = 0;
			SSLerr(SSL_F_DTLS1_SEND_CLIENT_CERTIFICATE,
			    SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);
		}

		X509_free(x509);
		EVP_PKEY_free(pkey);
		if (i == 0)
			s->s3->tmp.cert_req = 2;

		/* Ok, we have a cert */
		s->state = SSL3_ST_CW_CERT_C;
	}

	if (s->state == SSL3_ST_CW_CERT_C) {
		s->state = SSL3_ST_CW_CERT_D;
		l = dtls1_output_cert_chain(s,
		    (s->s3->tmp.cert_req == 2) ? NULL : s->cert->key->x509);
		s->init_num = (int)l;
		s->init_off = 0;

		/* set header called by dtls1_output_cert_chain() */

		/* buffer the message to handle re-xmits */
		dtls1_buffer_message(s, 0);
	}

	/* SSL3_ST_CW_CERT_D */
	return (dtls1_do_write(s, SSL3_RT_HANDSHAKE));
@


1.57
log
@The *_method_data structures can be static

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.56 2016/03/11 07:08:45 mmcc Exp $ */
d345 1
a345 1
			ret = ssl3_get_key_exchange(s);
@


1.56
log
@X509_free(3) is NULL-safe, so remove NULL checks before its calls.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.55 2015/09/12 16:10:07 doug Exp $ */
d133 1
a133 1
const SSL_METHOD DTLSv1_client_method_data = {
@


1.55
log
@Remove most of the SSLv3 version checks and a few TLS v1.0.

We can now assume >= TLS v1.0 since SSL2_VERSION, SSL3_VERSION and
DTLS1_BAD_VER support was removed.

"reads ok" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.54 2015/09/12 12:58:15 jsing Exp $ */
d700 1
a700 2
		if (x509 != NULL)
			X509_free(x509);
@


1.54
log
@Uncopy and unpaste dtls1_send_client_verify() - the
ssl3_send_client_verify() is different, but it correctly supports things
like SIGALGS. Another 74 lines of code bites the dust.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.53 2015/09/12 12:26:56 jsing Exp $ */
d703 2
a704 10
		if (i == 0) {
			if (s->version == SSL3_VERSION) {
				s->s3->tmp.cert_req = 0;
				ssl3_send_alert(s, SSL3_AL_WARNING,
				    SSL_AD_NO_CERTIFICATE);
				return (1);
			} else {
				s->s3->tmp.cert_req = 2;
			}
		}
@


1.53
log
@Uncopy and unpaste dtls1_send_client_key_exchange() - the
ssl3_send_client_key_exchange() is effectively identical, in fact it has
a number of bug fixes and improvements that never got merged into the
DTLS copy of the code. Flenses another 264 lines of code.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.52 2015/09/11 18:08:21 jsing Exp $ */
d418 1
a418 1
			ret = dtls1_send_client_verify(s);
a658 70
}

int
dtls1_send_client_verify(SSL *s)
{
	unsigned char *p;
	unsigned char data[MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH];
	EVP_PKEY *pkey;
	unsigned u = 0;
	unsigned long n;
	int j;

	if (s->state == SSL3_ST_CW_CERT_VRFY_A) {
		p = ssl3_handshake_msg_start(s, SSL3_MT_CERTIFICATE_VERIFY);

		pkey = s->cert->key->privatekey;

		s->method->ssl3_enc->cert_verify_mac(s, NID_sha1,
		    &(data[MD5_DIGEST_LENGTH]));

		if (pkey->type == EVP_PKEY_RSA) {
			s->method->ssl3_enc->cert_verify_mac(s,
			    NID_md5, &(data[0]));
			if (RSA_sign(NID_md5_sha1, data,
			    MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH,
			    &(p[2]), &u, pkey->pkey.rsa) <= 0 ) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_VERIFY,
				    ERR_R_RSA_LIB);
				goto err;
			}
			s2n(u, p);
			n = u + 2;
		} else if (pkey->type == EVP_PKEY_DSA) {
			if (!DSA_sign(pkey->save_type,
			    &(data[MD5_DIGEST_LENGTH]),
			    SHA_DIGEST_LENGTH, &(p[2]),
			    (unsigned int *)&j, pkey->pkey.dsa)) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_VERIFY,
				    ERR_R_DSA_LIB);
				goto err;
			}
			s2n(j, p);
			n = j + 2;
		} else if (pkey->type == EVP_PKEY_EC) {
			if (!ECDSA_sign(pkey->save_type,
			    &(data[MD5_DIGEST_LENGTH]),
			    SHA_DIGEST_LENGTH, &(p[2]),
			    (unsigned int *)&j, pkey->pkey.ec)) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_VERIFY,
				    ERR_R_ECDSA_LIB);
				goto err;
			}
			s2n(j, p);
			n = j + 2;
		} else {
			SSLerr(SSL_F_DTLS1_SEND_CLIENT_VERIFY,
			    ERR_R_INTERNAL_ERROR);
			goto err;
		}

		ssl3_handshake_msg_finish(s, n);

		s->state = SSL3_ST_CW_CERT_VRFY_B;
	}

	/* s->state = SSL3_ST_CW_CERT_VRFY_B */
	return (ssl3_handshake_write(s));

err:
	return (-1);
@


1.52
log
@Rename functions that moved to t1_enc.c, with a tls1_ prefix instead of a
ssl3_ prefix.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.51 2015/09/11 16:28:37 jsing Exp $ */
d379 1
a379 2

				s->state = s->s3->tmp.next_state;
d397 1
a397 1
			ret = dtls1_send_client_key_exchange(s);
a400 1

d408 1
a408 1
					s->state = SSL3_ST_CW_CHANGE_A;
a658 261
}

int
dtls1_send_client_key_exchange(SSL *s)
{
	unsigned char *p, *q;
	int n;
	unsigned long alg_k;
	EVP_PKEY *pkey = NULL;
	EC_KEY *clnt_ecdh = NULL;
	const EC_POINT *srvr_ecpoint = NULL;
	EVP_PKEY *srvr_pub_pkey = NULL;
	unsigned char *encodedPoint = NULL;
	int encoded_pt_len = 0;
	BN_CTX * bn_ctx = NULL;

	if (s->state == SSL3_ST_CW_KEY_EXCH_A) {
		p = ssl3_handshake_msg_start(s, SSL3_MT_CLIENT_KEY_EXCHANGE);

		alg_k = s->s3->tmp.new_cipher->algorithm_mkey;

		if (s->session->sess_cert == NULL) {
			ssl3_send_alert(s, SSL3_AL_FATAL,
			    SSL_AD_HANDSHAKE_FAILURE);
			SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
			    ERR_R_INTERNAL_ERROR);
			goto err;
		}

		if (alg_k & SSL_kRSA) {
			RSA *rsa;
			unsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];

			pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
			if ((pkey == NULL) ||
			    (pkey->type != EVP_PKEY_RSA) ||
			    (pkey->pkey.rsa == NULL)) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}
			rsa = pkey->pkey.rsa;
			EVP_PKEY_free(pkey);

			tmp_buf[0] = s->client_version >> 8;
			tmp_buf[1] = s->client_version&0xff;
			arc4random_buf(&tmp_buf[2], sizeof(tmp_buf) - 2);

			s->session->master_key_length = sizeof tmp_buf;

			q = p;
			/* Fix buf for TLS and [incidentally] DTLS */
			if (s->version > SSL3_VERSION)
				p += 2;
			n = RSA_public_encrypt(sizeof tmp_buf,
			    tmp_buf, p, rsa, RSA_PKCS1_PADDING);
			if (n <= 0) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    SSL_R_BAD_RSA_ENCRYPT);
				goto err;
			}

			/* Fix buf for TLS and [incidentally] DTLS */
			if (s->version > SSL3_VERSION) {
				s2n(n, q);
				n += 2;
			}

			s->session->master_key_length =
			    s->method->ssl3_enc->generate_master_secret(s,
			    s->session->master_key,
			    tmp_buf, sizeof tmp_buf);
			explicit_bzero(tmp_buf, sizeof tmp_buf);
		} else if (alg_k & SSL_kDHE) {
			DH *dh_srvr, *dh_clnt;

			if (s->session->sess_cert->peer_dh_tmp != NULL)
				dh_srvr = s->session->sess_cert->peer_dh_tmp;
			else {
				/* we get them from the cert */
				ssl3_send_alert(s, SSL3_AL_FATAL,
				    SSL_AD_HANDSHAKE_FAILURE);
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    SSL_R_UNABLE_TO_FIND_DH_PARAMETERS);
				goto err;
			}

			/* generate a new random key */
			if ((dh_clnt = DHparams_dup(dh_srvr)) == NULL) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_DH_LIB);
				goto err;
			}
			if (!DH_generate_key(dh_clnt)) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_DH_LIB);
				goto err;
			}

			/* use the 'p' output buffer for the DH key, but
			 * make sure to clear it out afterwards */

			n = DH_compute_key(p, dh_srvr->pub_key, dh_clnt);

			if (n <= 0) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_DH_LIB);
				goto err;
			}

			/* generate master key from the result */
			s->session->master_key_length =
			    s->method->ssl3_enc->generate_master_secret(
				s, s->session->master_key, p, n);
			/* clean up */
			memset(p, 0, n);

			/* send off the data */
			n = BN_num_bytes(dh_clnt->pub_key);
			s2n(n, p);
			BN_bn2bin(dh_clnt->pub_key, p);
			n += 2;

			DH_free(dh_clnt);

			/* perhaps clean things up a bit EAY EAY EAY EAY*/
		} else if (alg_k & (SSL_kECDHE|SSL_kECDHr|SSL_kECDHe)) {
			const EC_GROUP *srvr_group = NULL;
			EC_KEY *tkey;
			int field_size = 0;

			if (s->session->sess_cert->peer_ecdh_tmp != NULL) {
				tkey = s->session->sess_cert->peer_ecdh_tmp;
			} else {
				/* Get the Server Public Key from Cert */
				srvr_pub_pkey = X509_get_pubkey(s->session-> \
				    sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
				if ((srvr_pub_pkey == NULL) ||
				    (srvr_pub_pkey->type != EVP_PKEY_EC) ||
				    (srvr_pub_pkey->pkey.ec == NULL)) {
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
					    ERR_R_INTERNAL_ERROR);
					goto err;
				}

				tkey = srvr_pub_pkey->pkey.ec;
			}

			srvr_group = EC_KEY_get0_group(tkey);
			srvr_ecpoint = EC_KEY_get0_public_key(tkey);

			if ((srvr_group == NULL) || (srvr_ecpoint == NULL)) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}

			if ((clnt_ecdh = EC_KEY_new()) == NULL) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				goto err;
			}

			if (!EC_KEY_set_group(clnt_ecdh, srvr_group)) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_EC_LIB);
				goto err;
			}

			/* Generate a new ECDH key pair */
			if (!(EC_KEY_generate_key(clnt_ecdh))) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_ECDH_LIB);
				goto err;
			}

			/* use the 'p' output buffer for the ECDH key, but
			 * make sure to clear it out afterwards
			 */

			field_size = EC_GROUP_get_degree(srvr_group);
			if (field_size <= 0) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_ECDH_LIB);
				goto err;
			}
			n = ECDH_compute_key(p, (field_size + 7)/8, srvr_ecpoint, clnt_ecdh, NULL);
			if (n <= 0) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_ECDH_LIB);
				goto err;
			}

			/* generate master key from the result */
			s->session->master_key_length =
			    s->method->ssl3_enc->generate_master_secret(
				s, s->session->master_key, p, n);
			memset(p, 0, n); /* clean up */

			/* First check the size of encoding and
			 * allocate memory accordingly.
			 */
			encoded_pt_len = EC_POINT_point2oct(srvr_group,
			    EC_KEY_get0_public_key(clnt_ecdh),
			    POINT_CONVERSION_UNCOMPRESSED,
			    NULL, 0, NULL);

			encodedPoint = malloc(encoded_pt_len);

			bn_ctx = BN_CTX_new();
			if ((encodedPoint == NULL) ||
			    (bn_ctx == NULL)) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				goto err;
			}

			/* Encode the public key */
			n = EC_POINT_point2oct(srvr_group,
			    EC_KEY_get0_public_key(clnt_ecdh),
			    POINT_CONVERSION_UNCOMPRESSED,
			    encodedPoint, encoded_pt_len, bn_ctx);

			*p = n; /* length of encoded point */
			/* Encoded point will be copied here */
			p += 1;

			/* copy the point */
			memcpy((unsigned char *)p, encodedPoint, n);
			/* increment n to account for length field */
			n += 1;

			/* Free allocated memory */
			BN_CTX_free(bn_ctx);
			free(encodedPoint);
			EC_KEY_free(clnt_ecdh);
			EVP_PKEY_free(srvr_pub_pkey);
		}

		else {
			ssl3_send_alert(s, SSL3_AL_FATAL,
			    SSL_AD_HANDSHAKE_FAILURE);
			SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
			    ERR_R_INTERNAL_ERROR);
			goto err;
		}

		ssl3_handshake_msg_finish(s, n);

		s->state = SSL3_ST_CW_KEY_EXCH_B;
	}

	/* SSL3_ST_CW_KEY_EXCH_B */
	return (ssl3_handshake_write(s));

err:
	BN_CTX_free(bn_ctx);
	free(encodedPoint);
	EC_KEY_free(clnt_ecdh);
	EVP_PKEY_free(srvr_pub_pkey);
	return (-1);
@


1.51
log
@Replace dtls1_send_finished() with ssl3_send_finished() - they're now
both essentially the same (in fact DTLS benefits from improvements
previously made to the ssl3_send_finished() function).

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.50 2015/09/10 17:57:50 jsing Exp $ */
d259 1
a259 1
			if (!ssl3_init_finished_mac(s)) {
d544 1
a544 1
			ssl3_cleanup_key_block(s);
@


1.50
log
@Remove support for DTLS_BAD_VER. We do not support non-standard and
incomplete implementations just so that we can interoperate with products
from vendors who have not bothered to fix things in the last ~10 years.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.49 2015/09/10 15:56:26 jsing Exp $ */
d460 1
a460 1
			ret = dtls1_send_finished(s,
@


1.49
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.48 2015/09/02 17:59:15 jsing Exp $ */
d174 1
a174 1
	if (ver == DTLS1_VERSION || ver == DTLS1_BAD_VER)
d217 1
a217 2
			if ((s->version & 0xff00 ) != (DTLS1_VERSION & 0xff00) &&
			    (s->version & 0xff00 ) != (DTLS1_BAD_VER & 0xff00)) {
@


1.48
log
@Replace dtls1_client_hello() with ssl3_client_hello() - both are basically
the same code, with two slight differences for DTLS handling.

Also, make use of send_cookie to determine if the client random needs to
be preserved, rather than testing if it is zeroed (hopefully your random
number generator never returned all zeros, since the existing code would
break). Inspired by BoringSSL.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.47 2015/07/15 18:35:34 beck Exp $ */
d734 1
a734 1
			OPENSSL_cleanse(tmp_buf, sizeof tmp_buf);
@


1.47
log
@Flense out dead code, we don't do ecdhe_clnt_cert.
coverity ID's 21691 21698
ok miod@@, "Fry it" jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.46 2015/07/14 05:26:32 doug Exp $ */
d266 1
a266 1
			ret = dtls1_client_hello(s);
d278 4
a281 3
				/* turn on buffering for the next lot of output */
				if (s->bbio != s->wbio)
					s->wbio = BIO_push(s->bbio, s->wbio);
a604 94
}

int
dtls1_client_hello(SSL *s)
{
	unsigned char *bufend, *d, *p;
	unsigned int i;

	if (s->state == SSL3_ST_CW_CLNT_HELLO_A) {
		SSL_SESSION *sess = s->session;

		if ((s->session == NULL) ||
		    (s->session->ssl_version != s->version) ||
		    (!sess->session_id_length && !sess->tlsext_tick) ||
		    (s->session->not_resumable)) {
			if (!ssl_get_new_session(s, 0))
				goto err;
		}
		/* else use the pre-loaded session */

		p = s->s3->client_random;

		/* if client_random is initialized, reuse it, we are
		 * required to use same upon reply to HelloVerify */
		for (i = 0; p[i]=='\0' && i < sizeof(s->s3->client_random); i++)
			;
		if (i == sizeof(s->s3->client_random))
			arc4random_buf(p, sizeof(s->s3->client_random));

		d = p = ssl3_handshake_msg_start(s, SSL3_MT_CLIENT_HELLO);

		*(p++) = s->version >> 8;
		*(p++) = s->version&0xff;
		s->client_version = s->version;

		/* Random stuff */
		memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);
		p += SSL3_RANDOM_SIZE;

		/* Session ID */
		if (s->new_session)
			i = 0;
		else
			i = s->session->session_id_length;
		*(p++) = i;
		if (i != 0) {
			if (i > sizeof s->session->session_id) {
				SSLerr(SSL_F_DTLS1_CLIENT_HELLO,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}
			memcpy(p, s->session->session_id, i);
			p += i;
		}

		/* cookie stuff */
		if (s->d1->cookie_len > sizeof(s->d1->cookie)) {
			SSLerr(SSL_F_DTLS1_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
			goto err;
		}
		*(p++) = s->d1->cookie_len;
		memcpy(p, s->d1->cookie, s->d1->cookie_len);
		p += s->d1->cookie_len;

		/* Ciphers supported */
		i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &p[2]);
		if (i == 0) {
			SSLerr(SSL_F_DTLS1_CLIENT_HELLO,
			    SSL_R_NO_CIPHERS_AVAILABLE);
			goto err;
		}
		s2n(i, p);
		p += i;

		/* add in (no) COMPRESSION */
		*(p++) = 1;
		*(p++) = 0; /* Add the NULL method */

		bufend = (unsigned char *)s->init_buf->data +
		    SSL3_RT_MAX_PLAIN_LENGTH;
		if ((p = ssl_add_clienthello_tlsext(s, p, bufend)) == NULL) {
			SSLerr(SSL_F_DTLS1_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
			goto err;
		}

		ssl3_handshake_msg_finish(s, p - d);

		s->state = SSL3_ST_CW_CLNT_HELLO_B;
	}

	/* SSL3_ST_CW_CLNT_HELLO_B */
	return (ssl3_handshake_write(s));
err:
	return (-1);
@


1.46
log
@Convert dtls1_get_hello_verify to CBS.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.45 2015/06/13 08:38:10 doug Exp $ */
a883 1
			int ecdh_clnt_cert = 0;
a885 28
			/* Did we send out the client's
			 * ECDH share for use in premaster
			 * computation as part of client certificate?
			 * If so, set ecdh_clnt_cert to 1.
			 */
			if ((alg_k & (SSL_kECDHr|SSL_kECDHe)) &&
			    (s->cert != NULL)) {
				/* XXX: For now, we do not support client
				 * authentication using ECDH certificates.
				 * To add such support, one needs to add
				 * code that checks for appropriate
				 * conditions and sets ecdh_clnt_cert to 1.
				 * For example, the cert have an ECC
				 * key on the same curve as the server's
				 * and the key should be authorized for
				 * key agreement.
				 *
				 * One also needs to add code in ssl3_connect
				 * to skip sending the certificate verify
				 * message.
				 *
				 * if ((s->cert->key->privatekey != NULL) &&
				 *     (s->cert->key->privatekey->type ==
				 *      EVP_PKEY_EC) && ...)
				 * ecdh_clnt_cert = 1;
				 */
			}

d923 6
a928 25
			if (ecdh_clnt_cert) {
				/* Reuse key info from our certificate
				 * We only need our private key to perform
				 * the ECDH computation.
				 */
				const BIGNUM *priv_key;
				tkey = s->cert->key->privatekey->pkey.ec;
				priv_key = EC_KEY_get0_private_key(tkey);
				if (priv_key == NULL) {
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
					    ERR_R_MALLOC_FAILURE);
					goto err;
				}
				if (!EC_KEY_set_private_key(clnt_ecdh, priv_key)) {
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
					    ERR_R_EC_LIB);
					goto err;
				}
			} else {
				/* Generate a new ECDH key pair */
				if (!(EC_KEY_generate_key(clnt_ecdh))) {
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
					    ERR_R_ECDH_LIB);
					goto err;
				}
d954 17
a970 36
			if (ecdh_clnt_cert) {
				/* Send empty client key exch message */
				n = 0;
			} else {
				/* First check the size of encoding and
				 * allocate memory accordingly.
				 */
				encoded_pt_len = EC_POINT_point2oct(srvr_group,
				    EC_KEY_get0_public_key(clnt_ecdh),
				    POINT_CONVERSION_UNCOMPRESSED,
				    NULL, 0, NULL);

				encodedPoint = malloc(encoded_pt_len);

				bn_ctx = BN_CTX_new();
				if ((encodedPoint == NULL) ||
				    (bn_ctx == NULL)) {
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
					    ERR_R_MALLOC_FAILURE);
					goto err;
				}

				/* Encode the public key */
				n = EC_POINT_point2oct(srvr_group,
				    EC_KEY_get0_public_key(clnt_ecdh),
				    POINT_CONVERSION_UNCOMPRESSED,
				    encodedPoint, encoded_pt_len, bn_ctx);

				*p = n; /* length of encoded point */
				/* Encoded point will be copied here */
				p += 1;

				/* copy the point */
				memcpy((unsigned char *)p, encodedPoint, n);
				/* increment n to account for length field */
				n += 1;
d972 14
a985 1
			}
@


1.45
log
@Fix bad indenting in LibreSSL.

jsg@@ noticed that some of the lines in libssl and libcrypto are not
indented properly.  At a quick glance, it looks like it has a different
control flow than it really does.  I checked the history in our tree and
in OpenSSL to make sure these were simple mistakes.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.44 2015/03/27 12:29:54 jsing Exp $ */
d116 1
d128 2
d703 5
a707 3
	int n, al, ok = 0;
	unsigned char *data;
	unsigned int cookie_len;
d721 1
a721 1
	if (2 > n)
a722 1
	data = (unsigned char *)s->init_msg;
d724 6
a729 1
	if ((data[0] != (s->version >> 8)) || (data[1] != (s->version&0xff))) {
d731 1
a731 1
		s->version = (s->version & 0xff00) | data[1];
a734 1
	data += 2;
d736 1
a736 1
	if (2 + 1 > n)
d738 4
a741 4
	cookie_len = *(data++);
	if (2 + 1 + cookie_len > n)
		goto truncated;
	if (cookie_len > sizeof(s->d1->cookie)) {
a744 2

	memcpy(s->d1->cookie, data, cookie_len);
d746 1
a747 1
	s->d1->send_cookie = 1;
@


1.44
log
@Factor out the init_buf initialisation code, rather than duplicating it
in four different places.

ok doug@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.43 2015/02/09 10:53:28 jsing Exp $ */
d420 1
a420 1
				s->state = SSL3_ST_CW_CHANGE_A;
@


1.43
log
@Jettison DTLS over SCTP.

OpenBSD does not have SCTP support and it sees little use in the wild.
OPENSSL_NO_SCTP is already specified via opensslfeatures.h, hence this
is a code removal only and symbols should remain unchanged.

ok beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.42 2015/02/06 08:30:23 jsing Exp $ */
a178 1
	BUF_MEM *buf = NULL;
d225 3
a227 11
			if (s->init_buf == NULL) {
				if ((buf = BUF_MEM_new()) == NULL) {
					ret = -1;
					goto end;
				}
				if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {
					ret = -1;
					goto end;
				}
				s->init_buf = buf;
				buf = NULL;
a228 1

a232 2

			/* setup buffing BIO */
d594 1
a596 4


	if (buf != NULL)
		BUF_MEM_free(buf);
d599 1
@


1.42
log
@Bring back the horrible API that is get_cipher_by_char/put_cipher_by_char.

This API was intended to be an internal only, however like many things in
OpenSSL, it is exposed externally and parts of the software ecosystem are
now using it since there is no real alternative within the public API.

ok doug@@, tedu@@ and reluctantly miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.41 2014/12/14 16:19:38 jsing Exp $ */
a182 4
#ifndef OPENSSL_NO_SCTP
	unsigned char sctpauthkey[64];
	char labelbuffer[sizeof(DTLS1_SCTP_AUTH_LABEL)];
#endif
a195 8
#ifndef OPENSSL_NO_SCTP
	/* Notify SCTP BIO socket to enter handshake
	 * mode and prevent stream identifier other
	 * than 0. Will be ignored if no SCTP is used.
	 */
	BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE,
	    s->in_handshake, NULL);
#endif
a261 34
#ifndef OPENSSL_NO_SCTP
		case DTLS1_SCTP_ST_CR_READ_SOCK:

			if (BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s))) {
				s->s3->in_read_app_data = 2;
				s->rwstate = SSL_READING;
				BIO_clear_retry_flags(SSL_get_rbio(s));
				BIO_set_retry_read(SSL_get_rbio(s));
				ret = -1;
				goto end;
			}

			s->state = s->s3->tmp.next_state;
			break;

		case DTLS1_SCTP_ST_CW_WRITE_SOCK:
			/* read app data until dry event */

			ret = BIO_dgram_sctp_wait_for_dry(SSL_get_wbio(s));
			if (ret < 0)
				goto end;

			if (ret == 0) {
				s->s3->in_read_app_data = 2;
				s->rwstate = SSL_READING;
				BIO_clear_retry_flags(SSL_get_rbio(s));
				BIO_set_retry_read(SSL_get_rbio(s));
				ret = -1;
				goto end;
			}

			s->state = s->d1->next_state;
			break;
#endif
a286 4
#ifndef OPENSSL_NO_SCTP
			/* Disable buffering for SCTP */
			if (!BIO_dgram_is_sctp(SSL_get_wbio(s))) {
#endif
a289 3
#ifndef OPENSSL_NO_SCTP
			}
#endif
a298 14
#ifndef OPENSSL_NO_SCTP
					/* Add new shared key for SCTP-Auth,
					 * will be ignored if no SCTP used.
					 */
					snprintf((char*) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),
					    DTLS1_SCTP_AUTH_LABEL);

					SSL_export_keying_material(s, sctpauthkey,
					    sizeof(sctpauthkey), labelbuffer,
					    sizeof(labelbuffer), NULL, 0, 0);

					BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
					    sizeof(sctpauthkey), sctpauthkey);
#endif
a388 6
#ifndef OPENSSL_NO_SCTP
			if (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&
			    state == SSL_ST_RENEGOTIATE)
				s->state = DTLS1_SCTP_ST_CR_READ_SOCK;
			else
#endif
a410 16
#ifndef OPENSSL_NO_SCTP
			/* Add new shared key for SCTP-Auth,
			 * will be ignored if no SCTP used.
			 */
			snprintf((char*)labelbuffer,
			    sizeof(DTLS1_SCTP_AUTH_LABEL),
			    DTLS1_SCTP_AUTH_LABEL);

			SSL_export_keying_material(s, sctpauthkey,
			    sizeof(sctpauthkey), labelbuffer,
			    sizeof(labelbuffer), NULL, 0, 0);

			BIO_ctrl(SSL_get_wbio(s),
			    BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
			    sizeof(sctpauthkey), sctpauthkey);
#endif
a418 6
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s))) {
					s->d1->next_state = SSL3_ST_CW_CHANGE_A;
					s->state = DTLS1_SCTP_ST_CW_WRITE_SOCK;
				} else
#endif
a431 6
#ifndef OPENSSL_NO_SCTP
			if (BIO_dgram_is_sctp(SSL_get_wbio(s))) {
				s->d1->next_state = SSL3_ST_CW_CHANGE_A;
				s->state = DTLS1_SCTP_ST_CW_WRITE_SOCK;
			} else
#endif
a460 9
#ifndef OPENSSL_NO_SCTP
			if (s->hit) {
				/* Change to new shared key of SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				BIO_ctrl(SSL_get_wbio(s),
				    BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
			}
#endif
a480 6
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s))) {
					s->d1->next_state = s->s3->tmp.next_state;
					s->s3->tmp.next_state = DTLS1_SCTP_ST_CW_WRITE_SOCK;
				}
#endif
a482 6
#ifndef OPENSSL_NO_SCTP
					if (BIO_dgram_is_sctp(SSL_get_wbio(s))) {
						s->d1->next_state = SSL_ST_OK;
						s->state = DTLS1_SCTP_ST_CW_WRITE_SOCK;
					}
#endif
a486 7
#ifndef OPENSSL_NO_SCTP
				/* Change to new shared key of SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				BIO_ctrl(SSL_get_wbio(s),
				    BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
#endif
a530 7
#ifndef OPENSSL_NO_SCTP
			if (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&
			    state == SSL_ST_RENEGOTIATE) {
				s->d1->next_state = s->state;
				s->state = DTLS1_SCTP_ST_CW_WRITE_SOCK;
			}
#endif
a608 8
#ifndef OPENSSL_NO_SCTP
	/* Notify SCTP BIO socket to leave handshake
	 * mode and allow stream identifier other
	 * than 0. Will be ignored if no SCTP is used.
	 */
	BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE,
	    s->in_handshake, NULL);
#endif
@


1.41
log
@Convert all of the straight forward client handshake handling code to use
the new handshake functions.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.40 2014/12/10 15:43:31 jsing Exp $ */
d149 2
@


1.40
log
@ssl3_init_finished_mac() calls BIO_new() which can fail since it in turn
calls malloc(). Instead of silently continuing on failure, check the return
value of BIO_new() and propagate failure back to the caller for appropriate
handling.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.39 2014/12/06 14:24:26 jsing Exp $ */
d762 1
a762 2
	unsigned char *buf;
	unsigned char *p, *d;
a763 1
	unsigned long l;
a764 1
	buf = (unsigned char *)s->init_buf->data;
d767 1
d786 1
a786 2
		/* Do the message type and length last */
		d = p = &(buf[DTLS1_HM_HEADER_LENGTH]);
d835 3
a837 2
		if ((p = ssl_add_clienthello_tlsext(s, p,
		    buf + SSL3_RT_MAX_PLAIN_LENGTH)) == NULL) {
d842 1
a842 5
		l = (p - d);
		d = buf;

		d = dtls1_set_message_header(s, d, SSL3_MT_CLIENT_HELLO,
		    l, 0, l);
a844 6
		/* number of bytes to write */
		s->init_num = p - buf;
		s->init_off = 0;

		/* buffer the message to handle re-xmits */
		dtls1_buffer_message(s, 0);
d848 1
a848 1
	return (dtls1_do_write(s, SSL3_RT_HANDSHAKE));
d910 1
a910 1
	unsigned char *p, *d;
a912 1
	unsigned char *q;
d922 1
a922 2
		d = (unsigned char *)s->init_buf->data;
		p = &(d[DTLS1_HM_HEADER_LENGTH]);
d1206 1
a1206 8
		d = dtls1_set_message_header(s, d,
		    SSL3_MT_CLIENT_KEY_EXCHANGE, n, 0, n);
		/*
		 *(d++)=SSL3_MT_CLIENT_KEY_EXCHANGE;
		 l2n3(n,d);
		 l2n(s->d1->handshake_write_seq,d);
		 s->d1->handshake_write_seq++;
		*/
a1208 6
		/* number of bytes to write */
		s->init_num = n + DTLS1_HM_HEADER_LENGTH;
		s->init_off = 0;

		/* buffer the message to handle re-xmits */
		dtls1_buffer_message(s, 0);
d1212 1
a1212 1
	return (dtls1_do_write(s, SSL3_RT_HANDSHAKE));
d1225 1
a1225 1
	unsigned char *p, *d;
d1233 2
a1234 2
		d = (unsigned char *)s->init_buf->data;
		p = &(d[DTLS1_HM_HEADER_LENGTH]);
d1280 1
a1280 8
		d = dtls1_set_message_header(s, d,
		    SSL3_MT_CERTIFICATE_VERIFY, n, 0, n);

		s->init_num = (int)n + DTLS1_HM_HEADER_LENGTH;
		s->init_off = 0;

		/* buffer the message to handle re-xmits */
		dtls1_buffer_message(s, 0);
d1286 2
a1287 1
	return (dtls1_do_write(s, SSL3_RT_HANDSHAKE));
@


1.39
log
@Remove client handling of RSA in ServerKeyExchange messages, along with
the associated peer_rsa_tmp goop.

This was only needed for export cipher handling and intentional RFC
violations. The export cipher suites have already been removed and
previous cleanup means that we will never send ServerKeyExchange messages
from the server side for RSA.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.38 2014/11/27 16:03:03 jsing Exp $ */
d313 4
a316 1
			ssl3_init_finished_mac(s);
@


1.38
log
@Avoid a NULL dereference in the DTLS client that can be triggered by a
crafted server response used in conjunction with an anonymous DH or
anonymous ECDH ciphersuite.

Fixes CVE-2014-3510, which is effectively a repeat of CVE-2014-3470 in
copied code.

Reported by Felix Groebert of the Google Security Team.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.37 2014/11/16 14:12:47 jsing Exp $ */
d949 7
a955 13
			if (s->session->sess_cert->peer_rsa_tmp != NULL)
				rsa = s->session->sess_cert->peer_rsa_tmp;
			else {
				pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
				if ((pkey == NULL) ||
				    (pkey->type != EVP_PKEY_RSA) ||
				    (pkey->pkey.rsa == NULL)) {
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
					    ERR_R_INTERNAL_ERROR);
					goto err;
				}
				rsa = pkey->pkey.rsa;
				EVP_PKEY_free(pkey);
d957 2
@


1.37
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.36 2014/10/18 16:13:16 jsing Exp $ */
d936 8
@


1.36
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random provides high quality pseudo-random numbers, hence there is no
need to differentiate between "strong" and "pseudo". Furthermore, the
arc4random_buf() function is guaranteed to succeed, which avoids the need
to check for and handle failure, simplifying the code.

It is worth noting that a number of the replaced RAND_bytes() and
RAND_pseudo_bytes() calls were missing return value checks and these
functions can fail for a number of reasons (at least in OpenSSL -
thankfully they were converted to wrappers around arc4random_buf() some
time ago in LibreSSL).

ok beck@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.35 2014/09/07 12:16:23 jsing Exp $ */
d117 1
d119 2
d122 1
a122 1
#include <openssl/objects.h>
d125 1
a125 2
#include <openssl/bn.h>
#include <openssl/dh.h>
@


1.35
log
@Remove SSL_kDHr, SSL_kDHd and SSL_aDH. No supported ciphersuites use them,
nor do we plan on supporting them.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.34 2014/08/10 14:42:55 jsing Exp $ */
a118 1
#include <openssl/rand.h>
d781 1
a781 1
			RAND_pseudo_bytes(p, sizeof(s->s3->client_random));
d956 1
a956 2
			if (RAND_bytes(&(tmp_buf[2]), sizeof tmp_buf - 2) <= 0)
				goto err;
@


1.34
log
@Since we no longer need to support SSLv2-style cipher lists, start
unravelling the maze of function pointers and callbacks by directly
calling ssl3_{get,put}_cipher_by_char() and removing the
ssl_{get,put}_cipher_by_char macros.

Prompted by similar changes in boringssl.

ok guenther.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.33 2014/08/07 20:02:23 miod Exp $ */
d985 1
a985 1
		} else if (alg_k & (SSL_kDHE|SSL_kDHr|SSL_kDHd)) {
@


1.33
log
@Oops, revert changes commited by mistake. The previous commit was supposed
to only apply to s23_srvr.c.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.31 2014/07/12 22:33:39 jsing Exp $ */
a147 2
	.get_cipher_by_char = ssl3_get_cipher_by_char,
	.put_cipher_by_char = ssl3_put_cipher_by_char,
d821 1
a821 1
		i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]), 0);
@


1.33.2.1
log
@backport fixes to prevent connections from being downgraded to weak keys.
ok bluhm miod
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.33 2014/08/07 20:02:23 miod Exp $ */
d942 13
a954 7
			pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
			if ((pkey == NULL) ||
			    (pkey->type != EVP_PKEY_RSA) ||
			    (pkey->pkey.rsa == NULL)) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
a955 2
			rsa = pkey->pkey.rsa;
			EVP_PKEY_free(pkey);
@


1.32
log
@When you expect a function to return a particular value, don't put a comment
saying that you expect it to return that value and compare it against zero
because it is supposedly faster, for this leads to bugs (especially given the
high rate of sloppy cut'n'paste within ssl3 and dtls1 routines in this
library).

Instead, compare for the exact value it ought to return upon success.

ok deraadt@@
@
text
@d781 2
a782 3
		for (i = 0; i < sizeof(s->s3->client_random); i++)
			if (p[i] != '\0')
				break;
d1341 1
@


1.31
log
@The correct name for EDH is DHE, likewise EECDH should be ECDHE.

Based on changes to OpenSSL trunk.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.30 2014/07/12 13:11:53 jsing Exp $ */
d781 3
a783 2
		for (i = 0; p[i]=='\0' && i < sizeof(s->s3->client_random); i++)
			;
a1341 1
		i = 0;
@


1.30
log
@Remove remnants from PSK, KRB5 and SRP.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.29 2014/07/11 22:57:25 miod Exp $ */
d987 1
a987 1
		} else if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd)) {
d1040 1
a1040 1
		} else if (alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe)) {
@


1.29
log
@As reported by David Ramos, most consumer of ssl_get_message() perform late
bounds check, after reading the 2-, 3- or 4-byte size of the next chunk to
process. But the size fields themselves are not checked for being entirely
contained in the buffer.

Since reading past your bounds is bad practice, and may not possible if you
are using a secure memory allocator, we need to add the necessary bounds check,
at the expense of some readability.

As a bonus, a wrong size GOST session key will now trigger an error instead of
a printf to stderr and it being handled as if it had the correct size.

Creating this diff made my eyes bleed (in the real sense); reviewing it
made guenther@@'s and beck@@'s eyes bleed too (in the literal sense).

ok guenther@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.28 2014/07/11 09:24:44 beck Exp $ */
d398 3
a400 3
			/* Check if it is anon DH or PSK */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
			    !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)) {
@


1.28
log
@Remove the PSK code. We don't need to drag around this
baggage.
ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.27 2014/07/10 08:51:14 tedu Exp $ */
d882 2
d894 2
d897 2
d910 2
@


1.27
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: d1_clnt.c,v 1.26 2014/06/12 15:49:31 deraadt Exp $ */
a1198 77
#ifndef OPENSSL_NO_PSK
		else if (alg_k & SSL_kPSK) {
			char identity[PSK_MAX_IDENTITY_LEN];
			unsigned char *t = NULL;
			unsigned char psk_or_pre_ms[PSK_MAX_PSK_LEN*2 + 4];
			unsigned int pre_ms_len = 0, psk_len = 0;
			int psk_err = 1;

			n = 0;
			if (s->psk_client_callback == NULL) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    SSL_R_PSK_NO_CLIENT_CB);
				goto err;
			}

			psk_len = s->psk_client_callback(s,
			    s->ctx->psk_identity_hint, identity,
			    PSK_MAX_IDENTITY_LEN, psk_or_pre_ms,
			    sizeof(psk_or_pre_ms));
			if (psk_len > PSK_MAX_PSK_LEN) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto psk_err;
			} else if (psk_len == 0) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    SSL_R_PSK_IDENTITY_NOT_FOUND);
				goto psk_err;
			}

			/* create PSK pre_master_secret */
			pre_ms_len = 2 + psk_len + 2 + psk_len;
			t = psk_or_pre_ms;
			memmove(psk_or_pre_ms + psk_len + 4,
			    psk_or_pre_ms, psk_len);
			s2n(psk_len, t);
			memset(t, 0, psk_len);
			t += psk_len;
			s2n(psk_len, t);

			free(s->session->psk_identity_hint);
			s->session->psk_identity_hint =
			    BUF_strdup(s->ctx->psk_identity_hint);
			if (s->ctx->psk_identity_hint != NULL &&
			    s->session->psk_identity_hint == NULL) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				goto psk_err;
			}

			free(s->session->psk_identity);
			s->session->psk_identity = BUF_strdup(identity);
			if (s->session->psk_identity == NULL) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				goto psk_err;
			}

			s->session->master_key_length =
			    s->method->ssl3_enc->generate_master_secret(s,
			    s->session->master_key,
			    psk_or_pre_ms, pre_ms_len);

			n = strlen(identity);
			s2n(n, p);
			memcpy(p, identity, n);
			n += 2;
			psk_err = 0;
psk_err:
			OPENSSL_cleanse(identity, PSK_MAX_IDENTITY_LEN);
			OPENSSL_cleanse(psk_or_pre_ms, sizeof(psk_or_pre_ms));
			if (psk_err != 0) {
				ssl3_send_alert(s, SSL3_AL_FATAL,
				    SSL_AD_HANDSHAKE_FAILURE);
				goto err;
			}
		}
#endif
@


1.26
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a546 9
#ifdef OPENSSL_NO_COMP
			s->session->compress_meth = 0;
#else
			if (s->s3->tmp.new_compression == NULL)
				s->session->compress_meth = 0;
			else
				s->session->compress_meth =
				    s->s3->tmp.new_compression->id;
#endif
d762 1
a762 1
	unsigned int i, j;
a763 1
	SSL_COMP *comp;
d832 2
a833 10
		/* COMPRESSION */
		if (s->ctx->comp_methods == NULL)
			j = 0;
		else
			j = sk_SSL_COMP_num(s->ctx->comp_methods);
		*(p++) = 1 + j;
		for (i = 0; i < j; i++) {
			comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);
			*(p++) = comp->id;
		}
@


1.25
log
@http://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=2016265dfbab162ec30718b5e7480add42598158
Don't know the full story, but it looks like a "can't do random
perfectly, so do it god awful" problem was found in 2013, and
replaced with "only do it badly if a flag is set".  New flags
(SSL_MODE_SEND_SERVERHELLO_TIME and SSL_MODE_SEND_SERVERHELLO_TIME)
were added [Ben Laurie?] to support the old scheme of "use time_t
for first 4 bytes of the random buffer".

Nothing uses these flags [ecosystem scan by sthen]

Fully discourage use of these flags in the future by removing
support & definition of them.  The buflen < 4 check is also interesting,
because no entropy would be returned.  No callers passed such small
buffers.
ok miod sthen
@
text
@d1 1
a1 1
/* ssl/d1_clnt.c */
@


1.24
log
@The DH_free, EC_KEY_free, EVP_PKEY_free and RSA_free functions all have
implicit NULL checks, so there is no point ensuring that the pointer is
non-NULL before calling them.
@
text
@d794 1
a794 2
			ssl_fill_hello_random(s, 0, p,
			    sizeof(s->s3->client_random));
@


1.23
log
@More KNF.
@
text
@d1214 1
a1214 2
			if (clnt_ecdh != NULL)
				EC_KEY_free(clnt_ecdh);
d1323 1
d1327 1
a1327 2
	if (clnt_ecdh != NULL)
		EC_KEY_free(clnt_ecdh);
d1449 1
a1449 2
		if (pkey != NULL)
			EVP_PKEY_free(pkey);
@


1.22
log
@TLS would not be entirely functional without extensions, so unifdef
OPENSSL_NO_TLSEXT.

ok tedu@@
@
text
@d2 1
a2 1
/* 
d4 1
a4 1
 * (nagendra@@cs.stanford.edu) for the OpenSSL project 2005.  
d14 1
a14 1
 *    notice, this list of conditions and the following disclaimer. 
d65 1
a65 1
 * 
d72 1
a72 1
 * 
d79 1
a79 1
 * 
d94 1
a94 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d97 1
a97 1
 * 
d109 1
a109 1
 * 
d228 2
a229 1
				SSLerr(SSL_F_DTLS1_CONNECT, ERR_R_INTERNAL_ERROR);
d267 2
a268 1
			memset(s->s3->client_random, 0, sizeof(s->s3->client_random));
a338 1

d353 1
a353 1
					DTLS1_SCTP_AUTH_LABEL);
d356 2
a357 2
					sizeof(sctpauthkey), labelbuffer,
					sizeof(labelbuffer), NULL, 0, 0);
d360 1
a360 1
					sizeof(sctpauthkey), sctpauthkey);
d452 1
a452 1
#ifndef OPENSSL_NO_SCTP			
d457 1
a457 1
#endif			
d539 1
a539 1
			SSL3_ST_CW_CHANGE_A, SSL3_ST_CW_CHANGE_B);
d585 3
a587 3
			SSL3_ST_CW_FINISHED_A, SSL3_ST_CW_FINISHED_B,
			s->method->ssl3_enc->client_finished_label,
			s->method->ssl3_enc->client_finished_label_len);
d610 1
a610 1
					s->s3->flags|=SSL3_FLAGS_POP_BUFFER;
d618 2
a619 1
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
d624 2
a625 1
					s->s3->tmp.next_state = SSL3_ST_CR_SESSION_TICKET_A;
d627 2
a628 2

					s->s3->tmp.next_state = SSL3_ST_CR_FINISHED_A;
d667 1
a667 1
				state == SSL_ST_RENEGOTIATE) {
d792 1
a792 1
;
d816 2
a817 1
				SSLerr(SSL_F_DTLS1_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
d836 2
a837 1
			SSLerr(SSL_F_DTLS1_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);
d855 2
a856 1
		if ((p = ssl_add_clienthello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH)) == NULL) {
d864 2
a865 1
		d = dtls1_set_message_header(s, d, SSL3_MT_CLIENT_HELLO, l, 0, l);
d889 2
a890 6
	n = s->method->ssl_get_message(s,
	DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A,
	DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B,
	-1,
	s->max_cert_list,
	&ok);
d960 2
a961 1
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
d980 1
a980 1
			tmp_buf, p, rsa, RSA_PKCS1_PADDING);
d982 2
a983 1
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, SSL_R_BAD_RSA_ENCRYPT);
d994 3
a996 3
			s->method->ssl3_enc->generate_master_secret(s,
			s->session->master_key,
			tmp_buf, sizeof tmp_buf);
d998 1
a998 2
		}
		else if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd)) {
d1005 4
a1008 2
				ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, SSL_R_UNABLE_TO_FIND_DH_PARAMETERS);
d1014 2
a1015 1
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);
d1019 2
a1020 1
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);
d1030 2
a1031 1
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);
d1037 2
a1038 2
			    s->method->ssl3_enc->generate_master_secret(s,
			        s->session->master_key, p, n);
d1051 1
a1051 2
		}
		else if (alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe)) {
d1062 2
a1063 1
			if ((alg_k & (SSL_kECDHr|SSL_kECDHe)) && (s->cert != NULL)) {
d1067 1
a1067 1
				 * code that checks for appropriate 
d1095 1
a1095 1
					ERR_R_INTERNAL_ERROR);
d1107 1
a1107 1
				ERR_R_INTERNAL_ERROR);
d1112 2
a1113 1
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
d1118 2
a1119 1
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB);
d1131 2
a1132 1
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
d1136 2
a1137 1
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB);
d1143 2
a1144 1
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ECDH_LIB);
d1156 1
a1156 1
				ERR_R_ECDH_LIB);
d1162 1
a1162 1
				ERR_R_ECDH_LIB);
d1167 3
a1169 5
			s->session->master_key_length = s->method->ssl3_enc \
			    -> generate_master_secret(s, 
			s->session->master_key,
			p, n);

d1179 4
a1182 5
				encoded_pt_len =
				    EC_POINT_point2oct(srvr_group,
				        EC_KEY_get0_public_key(clnt_ecdh),
				        POINT_CONVERSION_UNCOMPRESSED,
				        NULL, 0, NULL);
d1189 2
a1190 1
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
d1197 2
a1198 2
				        POINT_CONVERSION_UNCOMPRESSED,
				        encodedPoint, encoded_pt_len, bn_ctx);
d1230 1
a1230 1
				SSL_R_PSK_NO_CLIENT_CB);
d1251 2
a1252 1
			memmove(psk_or_pre_ms + psk_len + 4, psk_or_pre_ms, psk_len);
d1262 1
a1262 1
				s->session->psk_identity_hint == NULL) {
d1264 1
a1264 1
				ERR_R_MALLOC_FAILURE);
d1272 1
a1272 1
				ERR_R_MALLOC_FAILURE);
d1278 2
a1279 2
			        s->session->master_key,
			        psk_or_pre_ms, pre_ms_len);
d1290 2
a1291 1
				ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);
d1297 4
a1300 2
			ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);
			SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
d1357 2
a1358 1
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_VERIFY, ERR_R_RSA_LIB);
d1363 1
a1363 2
		} else
		if (pkey->type == EVP_PKEY_DSA) {
d1368 2
a1369 1
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_VERIFY, ERR_R_DSA_LIB);
d1374 1
a1374 2
		} else
		if (pkey->type == EVP_PKEY_EC) {
d1380 1
a1380 1
				ERR_R_ECDSA_LIB);
d1385 3
a1387 3
		} else
		{
			SSLerr(SSL_F_DTLS1_SEND_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);
d1392 1
a1392 1
		SSL3_MT_CERTIFICATE_VERIFY, n, 0, n);
d1444 2
a1445 1
			SSLerr(SSL_F_DTLS1_SEND_CLIENT_CERTIFICATE, SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);
d1455 2
a1456 1
				ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_CERTIFICATE);
d1479 1
@


1.21
log
@remove some #if 0 code. we don't need any more reminders that we're using
a not quite appropriate data structure. ok jsing
@
text
@a384 1
#ifndef OPENSSL_NO_TLSEXT
a396 1
#endif
a402 1
#ifndef OPENSSL_NO_TLSEXT
a410 6
#else
			} else
				skip = 1;

			s->state = SSL3_ST_CR_KEY_EXCH_A;
#endif
a619 1
#ifndef OPENSSL_NO_TLSEXT
a623 1
#endif
a629 1
#ifndef OPENSSL_NO_TLSEXT
a646 1
#endif
a776 3
#ifdef OPENSSL_NO_TLSEXT
		    !sess->session_id_length ||
#else
a777 1
#endif
a849 1
#ifndef OPENSSL_NO_TLSEXT
a853 1
#endif		
@


1.20
log
@unidef DH, ECDH, and ECDSA. there's no purpose to a libssl without them.
ok deraadt jsing
@
text
@a705 7
#if 0
			if (s->init_buf != NULL) {
				BUF_MEM_free(s->init_buf);
				s->init_buf = NULL;
			}
#endif

@


1.19
log
@There is no point in checking if a pointer is non-NULL before calling free,
since free already does this for us. Also remove some pointless NULL
assignments, where the result from malloc(3) is immediately assigned to the
same variable.

ok miod@@
@
text
@a123 1
#ifndef OPENSSL_NO_DH
a124 1
#endif
a958 1
#ifndef OPENSSL_NO_ECDH
a964 1
#endif
a1019 1
#ifndef OPENSSL_NO_DH
a1068 2
#endif
#ifndef OPENSSL_NO_ECDH 
a1231 1
#endif /* !OPENSSL_NO_ECDH */
a1334 1
#ifndef OPENSSL_NO_ECDH
a1339 1
#endif
a1383 1
#ifndef OPENSSL_NO_ECDSA
a1395 1
#endif
@


1.18
log
@DeIMPLEMENT libssl. Expand the IMPLEMENT_* macros since it is far more
readable and one less layer of abstraction. Use C99 initialisers for
clarity, grepability and to protect from future field reordering/removal.

ok miod@@ (tedu@@ also thought it was a wonderful idea, beck@@ also agreed,
but ran away squealing since it reminded him of the VOP layer...)
@
text
@d1234 1
a1234 2
			if (encodedPoint != NULL)
				free(encodedPoint);
d1279 3
a1281 3
			if (s->session->psk_identity_hint != NULL)
				free(s->session->psk_identity_hint);
			s->session->psk_identity_hint = BUF_strdup(s->ctx->psk_identity_hint);
d1289 1
a1289 2
			if (s->session->psk_identity != NULL)
				free(s->session->psk_identity);
d1345 1
a1345 2
	if (encodedPoint != NULL)
		free(encodedPoint);
@


1.17
log
@Remove SRP and Kerberos support from libssl. These are complex protocols
all on their own and we can't effectively maintain them without using them,
which we don't. If the need arises, the code can be resurrected.
@
text
@d131 38
a175 3

IMPLEMENT_dtls1_meth_func(DTLSv1_client_method,
    ssl_undefined_function, dtls1_connect, dtls1_get_client_method)
@


1.16
log
@Unifdef -UPKCS1_CHECK and remove SSL_OP_PKCS1_CHECK_[12], this is leftover
``debug'' code from a 15+ years old bugfix and the SSL_OP_PKCS1_CHECK_*
constants have had a value of zero since ages. No production code should use
them.

ok beck@@
@
text
@a117 3
#ifndef OPENSSL_NO_KRB5
#include "kssl_lcl.h"
#endif
a925 3
#ifndef OPENSSL_NO_KRB5
	KSSL_ERR kssl_err;
#endif /* OPENSSL_NO_KRB5 */
a988 128
#ifndef OPENSSL_NO_KRB5
		else if (alg_k & SSL_kKRB5) {
			krb5_error_code	krb5rc;
			KSSL_CTX	*kssl_ctx = s->kssl_ctx;
			/*  krb5_data	krb5_ap_req;  */
			krb5_data	*enc_ticket;
			krb5_data	authenticator, *authp = NULL;
			EVP_CIPHER_CTX	ciph_ctx;
			const EVP_CIPHER *enc = NULL;
			unsigned char	iv[EVP_MAX_IV_LENGTH];
			unsigned char	tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];
			unsigned char	epms[SSL_MAX_MASTER_KEY_LENGTH
			+ EVP_MAX_IV_LENGTH];
			int 		padl, outl = sizeof(epms);

			EVP_CIPHER_CTX_init(&ciph_ctx);

#ifdef KSSL_DEBUG
			printf("ssl3_send_client_key_exchange(%lx & %lx)\n",
			alg_k, SSL_kKRB5);
#endif	/* KSSL_DEBUG */

			authp = NULL;
#ifdef KRB5SENDAUTH
			if (KRB5SENDAUTH)
				authp = &authenticator;
#endif	/* KRB5SENDAUTH */

			krb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket, authp,
			&kssl_err);
			enc = kssl_map_enc(kssl_ctx->enctype);
			if (enc == NULL)
				goto err;
#ifdef KSSL_DEBUG
			{
				printf("kssl_cget_tkt rtn %d\n", krb5rc);
				if (krb5rc && kssl_err.text)
					printf("kssl_cget_tkt kssl_err=%s\n", kssl_err.text);
			}
#endif	/* KSSL_DEBUG */

			if (krb5rc) {
				ssl3_send_alert(s, SSL3_AL_FATAL,
				SSL_AD_HANDSHAKE_FAILURE);
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				kssl_err.reason);
				goto err;
			}

			/*  20010406 VRS - Earlier versions used KRB5 AP_REQ
			**  in place of RFC 2712 KerberosWrapper, as in:
			**
                        **  Send ticket (copy to *p, set n = length)
                        **  n = krb5_ap_req.length;
                        **  memcpy(p, krb5_ap_req.data, krb5_ap_req.length);
                        **  if (krb5_ap_req.data)  
                        **    kssl_krb5_free_data_contents(NULL,&krb5_ap_req);
                        **
			**  Now using real RFC 2712 KerberosWrapper
			**  (Thanks to Simon Wilkinson <sxw@@sxw.org.uk>)
			**  Note: 2712 "opaque" types are here replaced
			**  with a 2-byte length followed by the value.
			**  Example:
			**  KerberosWrapper= xx xx asn1ticket 0 0 xx xx encpms
			**  Where "xx xx" = length bytes.  Shown here with
			**  optional authenticator omitted.
			*/

			/*  KerberosWrapper.Ticket		*/
			s2n(enc_ticket->length, p);
			memcpy(p, enc_ticket->data, enc_ticket->length);
			p += enc_ticket->length;
			n = enc_ticket->length + 2;

			/*  KerberosWrapper.Authenticator	*/
			if (authp && authp->length) {
				s2n(authp->length, p);
				memcpy(p, authp->data, authp->length);
				p += authp->length;
				n += authp->length + 2;

				free(authp->data);
				authp->data = NULL;
				authp->length = 0;
			} else {
				s2n(0, p);/*  null authenticator length	*/
				n += 2;
			}

			if (RAND_bytes(tmp_buf, sizeof tmp_buf) <= 0)
				goto err;

			/*  20010420 VRS.  Tried it this way; failed.
			**	EVP_EncryptInit_ex(&ciph_ctx,enc, NULL,NULL);
			**	EVP_CIPHER_CTX_set_key_length(&ciph_ctx,
			**				kssl_ctx->length);
			**	EVP_EncryptInit_ex(&ciph_ctx,NULL, key,iv);
			*/

			memset(iv, 0, sizeof iv);
			/* per RFC 1510 */
			EVP_EncryptInit_ex(&ciph_ctx, enc, NULL,
			    kssl_ctx->key, iv);
			EVP_EncryptUpdate(&ciph_ctx, epms, &outl, tmp_buf,
			    sizeof tmp_buf);
			EVP_EncryptFinal_ex(&ciph_ctx, &(epms[outl]), &padl);
			outl += padl;
			if (outl > (int)sizeof epms) {
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
				goto err;
			}
			EVP_CIPHER_CTX_cleanup(&ciph_ctx);

			/*  KerberosWrapper.EncryptedPreMasterSecret	*/
			s2n(outl, p);
			memcpy(p, epms, outl);
			p += outl;
			n += outl + 2;

			s->session->master_key_length =
			    s->method->ssl3_enc->generate_master_secret(s,
			        s->session->master_key,
			        tmp_buf, sizeof tmp_buf);

			OPENSSL_cleanse(tmp_buf, sizeof tmp_buf);
			OPENSSL_cleanse(epms, outl);
		}
#endif
@


1.15
log
@more malloc/realloc/calloc cleanups; ok beck kettenis
@
text
@a977 6
#ifdef PKCS1_CHECK
			if (s->options & SSL_OP_PKCS1_CHECK_1)
				p[1]++;
			if (s->options & SSL_OP_PKCS1_CHECK_2)
				tmp_buf[0] = 0x70;
#endif
@


1.14
log
@More KNF and style consistency tweaks
@
text
@d1311 1
a1311 3
				encodedPoint = (unsigned char *)
				    malloc(encoded_pt_len *
				        sizeof(unsigned char));
@


1.13
log
@no longer need to fool emacs indentation and other if (0) oddities.
@
text
@d134 2
a135 2
static const SSL_METHOD
*dtls1_get_client_method(int ver)
d139 1
a139 2
	else
		return (NULL);
@


1.12
log
@always build in RSA and DSA. ok deraadt miod
@
text
@d948 1
a948 4
		/* Fool emacs indentation */
		if (0) {
		}
		else if (alg_k & SSL_kRSA) {
@


1.11
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a927 1
#ifndef OPENSSL_NO_RSA
a929 1
#endif
a950 1
#ifndef OPENSSL_NO_RSA
a1004 1
#endif
a1472 1
#ifndef OPENSSL_NO_RSA
a1473 1
#endif
a1474 1
#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_ECDSA)
a1475 1
#endif
a1484 1
#ifndef OPENSSL_NO_RSA
a1496 2
#endif
#ifndef OPENSSL_NO_DSA
a1507 1
#endif
@


1.10
log
@make OPENSSL_NO_HEARTBLEED the default and only option. ok deraadt miod
@
text
@d1320 1
a1320 1
				    OPENSSL_malloc(encoded_pt_len *
d1350 1
a1350 1
				OPENSSL_free(encodedPoint);
d1396 1
a1396 1
				OPENSSL_free(s->session->psk_identity_hint);
d1406 1
a1406 1
				OPENSSL_free(s->session->psk_identity);
d1463 1
a1463 1
		OPENSSL_free(encodedPoint);
@


1.9
log
@So the OpenSSL codebase does "get the time, add it as a random seed"
in a bunch of places inside the TLS engine, to try to keep entropy high.
I wonder if their moto is "If you can't solve a problem, at least try
to do it badly".
ok miod
@
text
@a178 12
#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending) {
		dtls1_stop_timer(s);
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
	}
#endif

@


1.8
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a149 1
	unsigned long Time = (unsigned long)time(NULL);
a157 1
	RAND_add(&Time, sizeof(Time), 0);
@


1.7
log
@Do not include "e_os.h" anymore.  Simply pull in the necessary headers.

ok miod@@, deraadt@@
@
text
@d134 3
a136 2
static const SSL_METHOD *dtls1_get_client_method(int ver)
	{
d138 1
a138 1
		return(DTLSv1_client_method());
d140 2
a141 2
		return(NULL);
	}
d144 10
a153 11
			ssl_undefined_function,
			dtls1_connect,
			dtls1_get_client_method)

int dtls1_connect(SSL *s)
	{
	BUF_MEM *buf=NULL;
	unsigned long Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	int ret= -1;
	int new_state,state,skip=0;
d159 1
a159 1
	RAND_add(&Time,sizeof(Time),0);
d164 1
a164 1
		cb=s->info_callback;
d166 2
a167 2
		cb=s->ctx->info_callback;
	
d169 2
a170 1
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); 
d177 2
a178 1
	BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE, s->in_handshake, NULL);
d186 1
a186 2
	if (s->tlsext_hb_pending)
		{
d190 1
a190 1
		}
d193 2
a194 3
	for (;;)
		{
		state=s->state;
d196 1
a196 2
		switch(s->state)
			{
d198 2
a199 2
			s->renegotiate=1;
			s->state=SSL_ST_CONNECT;
d207 3
a209 2
			s->server=0;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);
d212 1
a212 2
			    (s->version & 0xff00 ) != (DTLS1_BAD_VER & 0xff00))
				{
d216 2
a217 2
				}
				
d219 1
a219 1
			s->type=SSL_ST_CONNECT;
d221 3
a223 5
			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
d225 3
a227 4
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					ret= -1;
a228 3
					}
				s->init_buf=buf;
				buf=NULL;
d230 3
d234 4
a237 1
			if (!ssl3_setup_buffers(s)) { ret= -1; goto end; }
d240 4
a243 1
			if (!ssl_init_wbio_buffer(s,0)) { ret= -1; goto end; }
d247 1
a247 1
			s->state=SSL3_ST_CW_CLNT_HELLO_A;
d249 1
a249 1
			s->init_num=0;
d251 1
a251 1
			memset(s->s3->client_random,0,sizeof(s->s3->client_random));
d259 3
a261 4
			if (BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))
			{
				s->s3->in_read_app_data=2;
				s->rwstate=SSL_READING;
d268 1
a268 1
			s->state=s->s3->tmp.next_state;
d275 2
a276 1
			if (ret < 0) goto end;
d278 3
a280 4
			if (ret == 0)
			{
				s->s3->in_read_app_data=2;
				s->rwstate=SSL_READING;
d287 1
a287 1
			s->state=s->d1->next_state;
d294 1
a294 1
			s->shutdown=0;
d300 3
a302 2
			ret=dtls1_client_hello(s);
			if (ret <= 0) goto end;
d304 5
a308 7
			if ( s->d1->send_cookie)
				{
				s->state=SSL3_ST_CW_FLUSH;
				s->s3->tmp.next_state=SSL3_ST_CR_SRVR_HELLO_A;
				}
			else
				s->state=SSL3_ST_CR_SRVR_HELLO_A;
d310 1
a310 1
			s->init_num=0;
d314 1
a314 2
			if (!BIO_dgram_is_sctp(SSL_get_wbio(s)))
				{
d318 1
a318 1
					s->wbio=BIO_push(s->bbio,s->wbio);
d320 1
a320 1
				}
d327 5
a331 6
			ret=ssl3_get_server_hello(s);
			if (ret <= 0) goto end;
			else
				{
				if (s->hit)
					{
d337 1
a337 1
					         DTLS1_SCTP_AUTH_LABEL);
d340 2
a341 2
					                           sizeof(sctpauthkey), labelbuffer,
					                           sizeof(labelbuffer), NULL, 0, 0);
d344 1
a344 1
							 sizeof(sctpauthkey), sctpauthkey);
d347 5
a351 6
					s->state=SSL3_ST_CR_FINISHED_A;
					}
				else
					s->state=DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A;
				}
			s->init_num=0;
d358 1
a358 1
			if ( ret <= 0)
d362 1
a362 1
				s->state=SSL3_ST_CW_CLNT_HELLO_A;
d371 4
a374 4
			ret=ssl3_check_finished(s);
			if (ret <= 0) goto end;
			if (ret == 2)
				{
d377 1
a377 1
					s->state=SSL3_ST_CR_SESSION_TICKET_A;
d379 2
a380 2
					s->state=SSL3_ST_CR_FINISHED_A;
				s->init_num=0;
d382 1
a382 1
				}
d386 4
a389 4
			    !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				ret=ssl3_get_server_certificate(s);
				if (ret <= 0) goto end;
d392 1
a392 1
					s->state=SSL3_ST_CR_CERT_STATUS_A;
d394 2
a395 4
					s->state=SSL3_ST_CR_KEY_EXCH_A;
				}
			else
				{
d397 2
a398 2
				s->state=SSL3_ST_CR_KEY_EXCH_A;
				}
d400 2
a401 3
				}
			else
				skip=1;
d403 1
a403 1
			s->state=SSL3_ST_CR_KEY_EXCH_A;
d405 1
a405 1
			s->init_num=0;
d410 5
a414 4
			ret=ssl3_get_key_exchange(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_CERT_REQ_A;
			s->init_num=0;
d418 2
a419 3
			if (!ssl3_check_cert_and_algorithm(s))
				{
				ret= -1;
d421 1
a421 1
				}
d426 5
a430 4
			ret=ssl3_get_certificate_request(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_SRVR_DONE_A;
			s->init_num=0;
d435 3
a437 2
			ret=ssl3_get_server_done(s);
			if (ret <= 0) goto end;
d440 1
a440 1
				s->s3->tmp.next_state=SSL3_ST_CW_CERT_A;
d442 2
a443 2
				s->s3->tmp.next_state=SSL3_ST_CW_KEY_EXCH_A;
			s->init_num=0;
d448 1
a448 1
				s->state=DTLS1_SCTP_ST_CR_READ_SOCK;
d451 1
a451 1
			s->state=s->s3->tmp.next_state;
d459 5
a463 4
			ret=dtls1_send_client_certificate(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_KEY_EXCH_A;
			s->init_num=0;
d469 3
a471 2
			ret=dtls1_send_client_key_exchange(s);
			if (ret <= 0) goto end;
d477 3
a479 2
			snprintf((char*) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),
			         DTLS1_SCTP_AUTH_LABEL);
d482 2
a483 2
			                           sizeof(sctpauthkey), labelbuffer,
			                           sizeof(labelbuffer), NULL, 0, 0);
d485 3
a487 2
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
					 sizeof(sctpauthkey), sctpauthkey);
d494 3
a496 6
			if (s->s3->tmp.cert_req == 1)
				{
				s->state=SSL3_ST_CW_CERT_VRFY_A;
				}
			else
				{
d498 4
a501 6
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state=SSL3_ST_CW_CHANGE_A;
					s->state=DTLS1_SCTP_ST_CW_WRITE_SOCK;
					}
				else
d503 3
a505 3
					s->state=SSL3_ST_CW_CHANGE_A;
				s->s3->change_cipher_spec=0;
				}
d507 1
a507 1
			s->init_num=0;
d513 3
a515 2
			ret=dtls1_send_client_verify(s);
			if (ret <= 0) goto end;
d517 4
a520 6
			if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
			{
				s->d1->next_state=SSL3_ST_CW_CHANGE_A;
				s->state=DTLS1_SCTP_ST_CW_WRITE_SOCK;
			}
			else
d522 3
a524 3
				s->state=SSL3_ST_CW_CHANGE_A;
			s->init_num=0;
			s->s3->change_cipher_spec=0;
d531 4
a534 3
			ret=dtls1_send_change_cipher_spec(s,
				SSL3_ST_CW_CHANGE_A,SSL3_ST_CW_CHANGE_B);
			if (ret <= 0) goto end;
d536 2
a537 2
			s->state=SSL3_ST_CW_FINISHED_A;
			s->init_num=0;
d539 1
a539 1
			s->session->cipher=s->s3->tmp.new_cipher;
d541 1
a541 1
			s->session->compress_meth=0;
d544 1
a544 1
				s->session->compress_meth=0;
d546 2
a547 2
				s->session->compress_meth=
					s->s3->tmp.new_compression->id;
d549 2
a550 3
			if (!s->method->ssl3_enc->setup_key_block(s))
				{
				ret= -1;
d552 1
a552 1
				}
d555 2
a556 3
				SSL3_CHANGE_CIPHER_CLIENT_WRITE))
				{
				ret= -1;
d558 2
a559 2
				}
			
d561 7
a567 7
				if (s->hit)
					{
					/* Change to new shared key of SCTP-Auth,
					 * will be ignored if no SCTP used.
					 */
					BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
					}
d577 7
a583 6
			ret=dtls1_send_finished(s,
				SSL3_ST_CW_FINISHED_A,SSL3_ST_CW_FINISHED_B,
				s->method->ssl3_enc->client_finished_label,
				s->method->ssl3_enc->client_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_FLUSH;
d587 2
a588 3
			if (s->hit)
				{
				s->s3->tmp.next_state=SSL_ST_OK;
d590 4
a593 5
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
						s->d1->next_state = s->s3->tmp.next_state;
						s->s3->tmp.next_state=DTLS1_SCTP_ST_CW_WRITE_SOCK;
					}
d595 2
a596 3
				if (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED)
					{
					s->state=SSL_ST_OK;
d598 4
a601 5
					if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
						{
							s->d1->next_state = SSL_ST_OK;
							s->state=DTLS1_SCTP_ST_CW_WRITE_SOCK;
						}
d604 1
a604 2
					s->s3->delay_buf_pop_ret=0;
					}
d606 1
a606 2
			else
				{
d617 1
a617 1
					s->s3->tmp.next_state=SSL3_ST_CR_SESSION_TICKET_A;
d620 4
a623 4
				
				s->s3->tmp.next_state=SSL3_ST_CR_FINISHED_A;
				}
			s->init_num=0;
d629 6
a634 5
			ret=ssl3_get_new_session_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_FINISHED_A;
			s->init_num=0;
		break;
d638 6
a643 5
			ret=ssl3_get_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_KEY_EXCH_A;
			s->init_num=0;
		break;
d649 4
a652 3
			ret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,
				SSL3_ST_CR_FINISHED_B);
			if (ret <= 0) goto end;
d656 1
a656 1
				s->state=SSL3_ST_CW_CHANGE_A;
d658 1
a658 1
				s->state=SSL_ST_OK;
d662 4
a665 5
				state == SSL_ST_RENEGOTIATE)
				{
				s->d1->next_state=s->state;
				s->state=DTLS1_SCTP_ST_CW_WRITE_SOCK;
				}
d668 1
a668 1
			s->init_num=0;
d672 2
a673 3
			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
d675 6
a680 7
				if (!BIO_should_retry(s->wbio))
					{
					s->rwstate=SSL_NOTHING;
					s->state=s->s3->tmp.next_state;
					}
				
				ret= -1;
d682 3
a684 3
				}
			s->rwstate=SSL_NOTHING;
			s->state=s->s3->tmp.next_state;
d692 1
a692 2
			if (s->init_buf != NULL)
				{
d694 2
a695 2
				s->init_buf=NULL;
				}
d704 3
a706 3
			s->init_num=0;
			s->renegotiate=0;
			s->new_session=0;
d708 3
a710 2
			ssl_update_cache(s,SSL_SESS_CACHE_CLIENT);
			if (s->hit) s->ctx->stats.sess_hit++;
d712 1
a712 1
			ret=1;
d714 1
a714 1
			s->handshake_func=dtls1_connect;
d717 2
a718 1
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
d721 1
a721 1
			s->d1->handshake_read_seq  = 0;
d725 1
a725 1
			
d727 2
a728 2
			SSLerr(SSL_F_DTLS1_CONNECT,SSL_R_UNKNOWN_STATE);
			ret= -1;
d731 1
a731 1
			}
d734 3
a736 5
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
d738 1
a738 1
				}
d740 5
a744 7
			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_CONNECT_LOOP,1);
				s->state=new_state;
				}
a745 1
		skip=0;
d747 2
d751 1
a751 1
	
d757 2
a758 1
	BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE, s->in_handshake, NULL);
d764 7
a770 6
		cb(s,SSL_CB_CONNECT_EXIT,ret);
	return(ret);
	}

int dtls1_client_hello(SSL *s)
	{
d772 2
a773 2
	unsigned char *p,*d;
	unsigned int i,j;
d777 2
a778 3
	buf=(unsigned char *)s->init_buf->data;
	if (s->state == SSL3_ST_CW_CLNT_HELLO_A)
		{
d781 1
a781 1
			(s->session->ssl_version != s->version) ||
d783 1
a783 1
			!sess->session_id_length ||
d785 1
a785 1
			(!sess->session_id_length && !sess->tlsext_tick) ||
d787 2
a788 3
			(s->session->not_resumable))
			{
			if (!ssl_get_new_session(s,0))
d790 1
a790 1
			}
d793 1
a793 1
		p=s->s3->client_random;
d797 3
a799 3
		for (i=0;p[i]=='\0' && i<sizeof(s->s3->client_random);i++)
			;
		if (i==sizeof(s->s3->client_random))
d801 1
a801 1
					      sizeof(s->s3->client_random));
d804 1
a804 1
		d=p= &(buf[DTLS1_HM_HEADER_LENGTH]);
d806 3
a808 3
		*(p++)=s->version>>8;
		*(p++)=s->version&0xff;
		s->client_version=s->version;
d811 2
a812 2
		memcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);
		p+=SSL3_RANDOM_SIZE;
d816 1
a816 1
			i=0;
d818 4
a821 6
			i=s->session->session_id_length;
		*(p++)=i;
		if (i != 0)
			{
			if (i > sizeof s->session->session_id)
				{
a823 3
				}
			memcpy(p,s->session->session_id,i);
			p+=i;
d825 4
a828 1
		
d830 1
a830 2
		if ( s->d1->cookie_len > sizeof(s->d1->cookie))
			{
d833 1
a833 1
			}
d839 3
a841 4
		i=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),&(p[2]),0);
		if (i == 0)
			{
			SSLerr(SSL_F_DTLS1_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);
d843 3
a845 3
			}
		s2n(i,p);
		p+=i;
d849 1
a849 1
			j=0;
d851 7
a857 8
			j=sk_SSL_COMP_num(s->ctx->comp_methods);
		*(p++)=1+j;
		for (i=0; i<j; i++)
			{
			comp=sk_SSL_COMP_value(s->ctx->comp_methods,i);
			*(p++)=comp->id;
			}
		*(p++)=0; /* Add the NULL method */
d860 2
a861 3
		if ((p = ssl_add_clienthello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH)) == NULL)
			{
			SSLerr(SSL_F_DTLS1_CLIENT_HELLO,ERR_R_INTERNAL_ERROR);
d863 1
a863 1
			}
d866 2
a867 2
		l=(p-d);
		d=buf;
d871 1
a871 1
		s->state=SSL3_ST_CW_CLNT_HELLO_B;
d873 2
a874 2
		s->init_num=p-buf;
		s->init_off=0;
d878 1
a878 1
		}
d881 1
a881 1
	return(dtls1_do_write(s,SSL3_RT_HANDSHAKE));
d883 2
a884 2
	return(-1);
	}
d886 3
a888 2
static int dtls1_get_hello_verify(SSL *s)
	{
d893 6
a898 6
	n=s->method->ssl_get_message(s,
		DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A,
		DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B,
		-1,
		s->max_cert_list,
		&ok);
d900 2
a901 1
	if (!ok) return((int)n);
d903 1
a903 2
	if (s->s3->tmp.message_type != DTLS1_MT_HELLO_VERIFY_REQUEST)
		{
d905 3
a907 3
		s->s3->tmp.reuse_message=1;
		return(1);
		}
d911 3
a913 4
	if ((data[0] != (s->version>>8)) || (data[1] != (s->version&0xff)))
		{
		SSLerr(SSL_F_DTLS1_GET_HELLO_VERIFY,SSL_R_WRONG_SSL_VERSION);
		s->version=(s->version&0xff00)|data[1];
d916 2
a917 2
		}
	data+=2;
d920 2
a921 3
	if ( cookie_len > sizeof(s->d1->cookie))
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
d923 1
a923 1
		}
d934 1
a934 1
	}
d936 4
a939 3
int dtls1_send_client_key_exchange(SSL *s)
	{
	unsigned char *p,*d;
d944 1
a944 1
	EVP_PKEY *pkey=NULL;
d947 1
a947 1
        KSSL_ERR kssl_err;
d958 5
a962 6
	if (s->state == SSL3_ST_CW_KEY_EXCH_A)
		{
		d=(unsigned char *)s->init_buf->data;
		p= &(d[DTLS1_HM_HEADER_LENGTH]);
		
		alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
d964 3
a966 2
                /* Fool emacs indentation */
                if (0) {}
d968 1
a968 2
		else if (alg_k & SSL_kRSA)
			{
d973 3
a975 4
				rsa=s->session->sess_cert->peer_rsa_tmp;
			else
				{
				pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
d977 3
a979 4
					(pkey->type != EVP_PKEY_RSA) ||
					(pkey->pkey.rsa == NULL))
					{
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
d981 2
a982 2
					}
				rsa=pkey->pkey.rsa;
d984 6
a989 6
				}
				
			tmp_buf[0]=s->client_version>>8;
			tmp_buf[1]=s->client_version&0xff;
			if (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)
					goto err;
d991 1
a991 1
			s->session->master_key_length=sizeof tmp_buf;
d993 1
a993 1
			q=p;
d996 3
a998 3
				p+=2;
			n=RSA_public_encrypt(sizeof tmp_buf,
				tmp_buf,p,rsa,RSA_PKCS1_PADDING);
d1000 4
a1003 2
			if (s->options & SSL_OP_PKCS1_CHECK_1) p[1]++;
			if (s->options & SSL_OP_PKCS1_CHECK_2) tmp_buf[0]=0x70;
d1005 2
a1006 3
			if (n <= 0)
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_ENCRYPT);
d1008 1
a1008 1
				}
d1011 4
a1014 5
			if (s->version > SSL3_VERSION)
				{
				s2n(n,q);
				n+=2;
				}
d1016 6
a1021 6
			s->session->master_key_length=
				s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key,
					tmp_buf,sizeof tmp_buf);
			OPENSSL_cleanse(tmp_buf,sizeof tmp_buf);
			}
d1024 6
a1029 7
		else if (alg_k & SSL_kKRB5)
                        {
                        krb5_error_code	krb5rc;
                        KSSL_CTX	*kssl_ctx = s->kssl_ctx;
                        /*  krb5_data	krb5_ap_req;  */
                        krb5_data	*enc_ticket;
                        krb5_data	authenticator, *authp = NULL;
d1034 2
a1035 2
			unsigned char	epms[SSL_MAX_MASTER_KEY_LENGTH 
						+ EVP_MAX_IV_LENGTH];
d1041 2
a1042 2
                        printf("ssl3_send_client_key_exchange(%lx & %lx)\n",
                                alg_k, SSL_kKRB5);
d1047 2
a1048 1
			if (KRB5SENDAUTH)  authp = &authenticator;
d1051 2
a1052 2
                        krb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket, authp,
				&kssl_err);
d1054 2
a1055 2
                        if (enc == NULL)
                            goto err;
d1057 5
a1061 5
                        {
                        printf("kssl_cget_tkt rtn %d\n", krb5rc);
                        if (krb5rc && kssl_err.text)
			  printf("kssl_cget_tkt kssl_err=%s\n", kssl_err.text);
                        }
d1064 7
a1070 8
                        if (krb5rc)
                                {
                                ssl3_send_alert(s,SSL3_AL_FATAL,
						SSL_AD_HANDSHAKE_FAILURE);
                                SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
						kssl_err.reason);
                                goto err;
                                }
d1092 1
a1092 1
			s2n(enc_ticket->length,p);
d1094 1
a1094 1
			p+= enc_ticket->length;
d1098 2
a1099 3
			if (authp  &&  authp->length)  
				{
				s2n(authp->length,p);
d1101 3
a1103 3
				p+= authp->length;
				n+= authp->length + 2;
				
d1107 7
a1113 9
				}
			else
				{
				s2n(0,p);/*  null authenticator length	*/
				n+=2;
				}
 
			if (RAND_bytes(tmp_buf,sizeof tmp_buf) <= 0)
			    goto err;
d1122 7
a1128 6
			memset(iv, 0, sizeof iv);  /* per RFC 1510 */
			EVP_EncryptInit_ex(&ciph_ctx,enc, NULL,
				kssl_ctx->key,iv);
			EVP_EncryptUpdate(&ciph_ctx,epms,&outl,tmp_buf,
				sizeof tmp_buf);
			EVP_EncryptFinal_ex(&ciph_ctx,&(epms[outl]),&padl);
d1130 1
a1130 2
			if (outl > (int)sizeof epms)
				{
d1133 1
a1133 1
				}
d1137 1
a1137 1
			s2n(outl,p);
d1139 2
a1140 2
			p+=outl;
			n+=outl + 2;
d1142 4
a1145 4
                        s->session->master_key_length=
                                s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key,
					tmp_buf, sizeof tmp_buf);
d1149 1
a1149 1
                        }
d1152 2
a1153 3
		else if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
			{
			DH *dh_srvr,*dh_clnt;
d1156 2
a1157 3
				dh_srvr=s->session->sess_cert->peer_dh_tmp;
			else
				{
d1159 2
a1160 2
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_DH_PARAMETERS);
d1162 2
a1163 2
				}
			
d1165 2
a1166 3
			if ((dh_clnt=DHparams_dup(dh_srvr)) == NULL)
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);
d1168 3
a1170 4
				}
			if (!DH_generate_key(dh_clnt))
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);
d1172 1
a1172 1
				}
d1177 1
a1177 1
			n=DH_compute_key(p,dh_srvr->pub_key,dh_clnt);
d1179 2
a1180 3
			if (n <= 0)
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);
d1182 1
a1182 1
				}
d1185 3
a1187 3
			s->session->master_key_length=
				s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key,p,n);
d1189 1
a1189 1
			memset(p,0,n);
d1192 4
a1195 4
			n=BN_num_bytes(dh_clnt->pub_key);
			s2n(n,p);
			BN_bn2bin(dh_clnt->pub_key,p);
			n+=2;
d1200 1
a1200 1
			}
d1203 1
a1203 2
		else if (alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe))
			{
d1214 1
a1214 2
			if ((alg_k & (SSL_kECDHr|SSL_kECDHe)) && (s->cert != NULL)) 
				{
d1234 1
a1234 1
				}
d1236 1
a1236 2
			if (s->session->sess_cert->peer_ecdh_tmp != NULL)
				{
d1238 1
a1238 3
				}
			else
				{
d1244 1
a1244 2
				    (srvr_pub_pkey->pkey.ec == NULL))
					{
d1246 1
a1246 1
					    ERR_R_INTERNAL_ERROR);
d1248 1
a1248 1
					}
d1251 1
a1251 1
				}
d1253 1
a1253 1
			srvr_group   = EC_KEY_get0_group(tkey);
d1256 1
a1256 2
			if ((srvr_group == NULL) || (srvr_ecpoint == NULL))
				{
d1258 1
a1258 1
				    ERR_R_INTERNAL_ERROR);
d1260 1
a1260 1
				}
d1262 2
a1263 3
			if ((clnt_ecdh=EC_KEY_new()) == NULL) 
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
d1265 1
a1265 1
				}
d1267 2
a1268 3
			if (!EC_KEY_set_group(clnt_ecdh, srvr_group))
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);
d1270 2
a1271 3
				}
			if (ecdh_clnt_cert) 
				{ 
d1279 2
a1280 3
				if (priv_key == NULL)
					{
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
d1282 3
a1284 4
					}
				if (!EC_KEY_set_private_key(clnt_ecdh, priv_key))
					{
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);
a1285 1
					}
d1287 1
a1287 2
			else 
				{
d1289 1
a1289 2
				if (!(EC_KEY_generate_key(clnt_ecdh)))
					{
a1291 1
					}
d1293 1
d1300 3
a1302 4
			if (field_size <= 0)
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, 
				       ERR_R_ECDH_LIB);
d1304 5
a1308 6
				}
			n=ECDH_compute_key(p, (field_size+7)/8, srvr_ecpoint, clnt_ecdh, NULL);
			if (n <= 0)
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, 
				       ERR_R_ECDH_LIB);
d1310 1
a1310 1
				}
d1315 2
a1316 2
				s->session->master_key,
				p, n);
d1320 1
a1320 2
			if (ecdh_clnt_cert) 
				{
d1323 1
a1323 3
				}
			else 
				{
d1327 10
a1336 9
				encoded_pt_len = 
				    EC_POINT_point2oct(srvr_group, 
					EC_KEY_get0_public_key(clnt_ecdh), 
					POINT_CONVERSION_UNCOMPRESSED, 
					NULL, 0, NULL);

				encodedPoint = (unsigned char *) 
				    OPENSSL_malloc(encoded_pt_len * 
					sizeof(unsigned char)); 
d1338 3
a1340 4
				if ((encodedPoint == NULL) || 
				    (bn_ctx == NULL)) 
					{
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
d1342 1
a1342 1
					}
d1345 4
a1348 4
				n = EC_POINT_point2oct(srvr_group, 
				    EC_KEY_get0_public_key(clnt_ecdh), 
				    POINT_CONVERSION_UNCOMPRESSED, 
				    encodedPoint, encoded_pt_len, bn_ctx);
d1352 2
a1353 1
				p += 1; 
d1357 3
a1359 2
				n += 1; 
				}
d1363 4
a1366 3
			if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
			if (clnt_ecdh != NULL) 
				 EC_KEY_free(clnt_ecdh);
d1368 1
a1368 1
			}
d1372 1
a1372 2
		else if (alg_k & SSL_kPSK)
			{
d1375 1
a1375 1
			unsigned char psk_or_pre_ms[PSK_MAX_PSK_LEN*2+4];
d1380 1
a1380 2
			if (s->psk_client_callback == NULL)
				{
d1382 1
a1382 1
					SSL_R_PSK_NO_CLIENT_CB);
d1384 1
a1384 1
				}
d1386 5
a1390 5
			psk_len = s->psk_client_callback(s, s->ctx->psk_identity_hint,
				identity, PSK_MAX_IDENTITY_LEN,
				psk_or_pre_ms, sizeof(psk_or_pre_ms));
			if (psk_len > PSK_MAX_PSK_LEN)
				{
d1392 1
a1392 1
					ERR_R_INTERNAL_ERROR);
d1394 1
a1394 3
				}
			else if (psk_len == 0)
				{
d1396 1
a1396 1
					SSL_R_PSK_IDENTITY_NOT_FOUND);
d1398 1
a1398 1
				}
d1401 1
a1401 1
			pre_ms_len = 2+psk_len+2+psk_len;
d1403 1
a1403 1
			memmove(psk_or_pre_ms+psk_len+4, psk_or_pre_ms, psk_len);
d1406 1
a1406 1
			t+=psk_len;
d1413 1
a1413 2
				s->session->psk_identity_hint == NULL)
				{
d1415 1
a1415 1
					ERR_R_MALLOC_FAILURE);
d1417 1
a1417 1
				}
d1422 1
a1422 2
			if (s->session->psk_identity == NULL)
				{
d1424 1
a1424 1
					ERR_R_MALLOC_FAILURE);
d1426 1
a1426 1
				}
d1429 4
a1432 3
				s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key,
					psk_or_pre_ms, pre_ms_len); 
d1436 1
a1436 1
			n+=2;
d1438 1
a1438 1
		psk_err:
d1441 1
a1441 2
			if (psk_err != 0)
				{
a1443 1
				}
d1445 1
d1447 3
a1449 4
		else
			{
			ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
			SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
d1451 2
a1452 2
			}
		
d1454 1
a1454 1
		SSL3_MT_CLIENT_KEY_EXCHANGE, n, 0, n);
d1461 2
a1462 2
		
		s->state=SSL3_ST_CW_KEY_EXCH_B;
d1464 2
a1465 2
		s->init_num=n+DTLS1_HM_HEADER_LENGTH;
		s->init_off=0;
d1469 2
a1470 2
		}
	
d1472 1
a1472 1
	return(dtls1_do_write(s,SSL3_RT_HANDSHAKE));
d1476 3
a1478 2
	if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
	if (clnt_ecdh != NULL) 
d1482 2
a1483 2
	return(-1);
	}
d1485 5
a1489 4
int dtls1_send_client_verify(SSL *s)
	{
	unsigned char *p,*d;
	unsigned char data[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];
d1492 1
a1492 1
	unsigned u=0;
d1499 7
a1505 9
	if (s->state == SSL3_ST_CW_CERT_VRFY_A)
		{
		d=(unsigned char *)s->init_buf->data;
		p= &(d[DTLS1_HM_HEADER_LENGTH]);
		pkey=s->cert->key->privatekey;

		s->method->ssl3_enc->cert_verify_mac(s,
		NID_sha1,
			&(data[MD5_DIGEST_LENGTH]));
d1508 1
a1508 2
		if (pkey->type == EVP_PKEY_RSA)
			{
d1510 1
a1510 2
				NID_md5,
				&(data[0]));
d1512 3
a1514 4
					 MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH,
					&(p[2]), &u, pkey->pkey.rsa) <= 0 )
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_VERIFY,ERR_R_RSA_LIB);
a1515 3
				}
			s2n(u,p);
			n=u+2;
d1517 3
a1519 1
		else
d1522 1
a1522 2
			if (pkey->type == EVP_PKEY_DSA)
			{
d1524 4
a1527 5
				&(data[MD5_DIGEST_LENGTH]),
				SHA_DIGEST_LENGTH,&(p[2]),
				(unsigned int *)&j,pkey->pkey.dsa))
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_VERIFY,ERR_R_DSA_LIB);
a1528 3
				}
			s2n(j,p);
			n=j+2;
d1530 3
a1532 1
		else
d1535 1
a1535 2
			if (pkey->type == EVP_PKEY_EC)
			{
d1537 3
a1539 4
				&(data[MD5_DIGEST_LENGTH]),
				SHA_DIGEST_LENGTH,&(p[2]),
				(unsigned int *)&j,pkey->pkey.ec))
				{
d1541 1
a1541 1
				    ERR_R_ECDSA_LIB);
a1542 3
				}
			s2n(j,p);
			n=j+2;
d1544 3
a1546 1
		else
d1548 2
a1549 2
			{
			SSLerr(SSL_F_DTLS1_SEND_CLIENT_VERIFY,ERR_R_INTERNAL_ERROR);
d1551 1
a1551 1
			}
d1554 1
a1554 1
			SSL3_MT_CERTIFICATE_VERIFY, n, 0, n) ;
d1556 2
a1557 2
		s->init_num=(int)n+DTLS1_HM_HEADER_LENGTH;
		s->init_off=0;
d1563 1
a1563 1
		}
d1566 1
a1566 1
	return(dtls1_do_write(s,SSL3_RT_HANDSHAKE));
d1568 2
a1569 2
	return(-1);
	}
d1571 5
a1575 4
int dtls1_send_client_certificate(SSL *s)
	{
	X509 *x509=NULL;
	EVP_PKEY *pkey=NULL;
d1579 4
a1582 6
	if (s->state ==	SSL3_ST_CW_CERT_A)
		{
		if ((s->cert == NULL) ||
			(s->cert->key->x509 == NULL) ||
			(s->cert->key->privatekey == NULL))
			s->state=SSL3_ST_CW_CERT_B;
d1584 2
a1585 2
			s->state=SSL3_ST_CW_CERT_C;
		}
d1588 1
a1588 2
	if (s->state == SSL3_ST_CW_CERT_B)
		{
d1592 1
a1592 1
		i=0;
d1594 14
a1607 18
		if (i < 0)
			{
			s->rwstate=SSL_X509_LOOKUP;
			return(-1);
			}
		s->rwstate=SSL_NOTHING;
		if ((i == 1) && (pkey != NULL) && (x509 != NULL))
			{
			s->state=SSL3_ST_CW_CERT_B;
			if (	!SSL_use_certificate(s,x509) ||
				!SSL_use_PrivateKey(s,pkey))
				i=0;
			}
		else if (i == 1)
			{
			i=0;
			SSLerr(SSL_F_DTLS1_SEND_CLIENT_CERTIFICATE,SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);
			}
d1609 11
a1619 14
		if (x509 != NULL) X509_free(x509);
		if (pkey != NULL) EVP_PKEY_free(pkey);
		if (i == 0)
			{
			if (s->version == SSL3_VERSION)
				{
				s->s3->tmp.cert_req=0;
				ssl3_send_alert(s,SSL3_AL_WARNING,SSL_AD_NO_CERTIFICATE);
				return(1);
				}
			else
				{
				s->s3->tmp.cert_req=2;
				}
d1621 1
d1624 2
a1625 2
		s->state=SSL3_ST_CW_CERT_C;
		}
d1627 6
a1632 7
	if (s->state == SSL3_ST_CW_CERT_C)
		{
		s->state=SSL3_ST_CW_CERT_D;
		l=dtls1_output_cert_chain(s,
			(s->s3->tmp.cert_req == 2)?NULL:s->cert->key->x509);
		s->init_num=(int)l;
		s->init_off=0;
d1638 1
a1638 1
		}
d1640 2
a1641 4
	return(dtls1_do_write(s,SSL3_RT_HANDSHAKE));
	}


@


1.6
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d161 1
a161 1
	clear_sys_error();
@


1.5
log
@resolve conflicts
@
text
@a540 7
#ifndef OPENSSL_NO_SCTP
			/* Change to new shared key of SCTP-Auth,
			 * will be ignored if no SCTP used.
			 */
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
#endif

d567 10
d619 7
d786 1
a786 1
	unsigned long Time,l;
d811 2
a812 1
		for (i=0;p[i]=='\0' && i<sizeof(s->s3->client_random);i++) ;
d814 2
a815 5
			{
			Time=(unsigned long)time(NULL);	/* Time */
			l2n(Time,p);
			RAND_pseudo_bytes(p,sizeof(s->s3->client_random)-4);
			}
@


1.5.4.1
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@a870 6
		/* TLS extensions*/
		if (ssl_prepare_clienthello_tlsext(s) <= 0)
			{
			SSLerr(SSL_F_DTLS1_CLIENT_HELLO,SSL_R_CLIENTHELLO_TLSEXT);
			goto err;
			}
d876 1
a876 1
#endif
a984 7
			if (s->session->sess_cert == NULL)
				{
				/* We should always have a server certificate with SSL_kRSA. */
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
				goto err;
				}

a1174 7
			if (s->session->sess_cert == NULL)
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
				goto err;
				}

a1233 7
			if (s->session->sess_cert == NULL)
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
				goto err;
				}

d1709 2
@


1.5.8.1
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@a870 6
		/* TLS extensions*/
		if (ssl_prepare_clienthello_tlsext(s) <= 0)
			{
			SSLerr(SSL_F_DTLS1_CLIENT_HELLO,SSL_R_CLIENTHELLO_TLSEXT);
			goto err;
			}
d876 1
a876 1
#endif
a984 7
			if (s->session->sess_cert == NULL)
				{
				/* We should always have a server certificate with SSL_kRSA. */
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
				goto err;
				}

a1174 7
			if (s->session->sess_cert == NULL)
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
				goto err;
				}

a1233 7
			if (s->session->sess_cert == NULL)
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
				goto err;
				}

d1709 2
@


1.4
log
@openssl-1.0.0e: resolve conflicts
@
text
@d153 5
a157 1
	int new_state,state,skip=0;;
d171 21
d199 1
a199 1
			s->new_session=1;
d254 36
d312 11
a322 3
			/* turn on buffering for the next lot of output */
			if (s->bbio != s->wbio)
				s->wbio=BIO_push(s->bbio,s->wbio);
a331 1
				dtls1_stop_timer(s);
d333 16
d350 1
d442 1
d444 1
a444 1
				s->state=SSL3_ST_CW_CERT_A;
d446 1
a446 1
				s->state=SSL3_ST_CW_KEY_EXCH_A;
d449 7
d474 16
d500 9
a508 1
				s->state=SSL3_ST_CW_CHANGE_A;
d520 9
a528 1
			s->state=SSL3_ST_CW_CHANGE_A;
d540 8
d593 7
d603 7
d658 10
d675 7
d708 1
d755 9
@


1.3
log
@resolve conflicts, fix local changes
@
text
@d410 2
a411 1
			dtls1_start_timer(s);
d446 2
a447 1
			dtls1_start_timer(s);
@


1.2
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d7 1
a7 1
 * Copyright (c) 1999-2005 The OpenSSL Project.  All rights reserved.
d118 1
d120 1
d126 1
d131 1
a131 1
static SSL_METHOD *dtls1_get_client_method(int ver);
d134 1
a134 1
static SSL_METHOD *dtls1_get_client_method(int ver)
d136 1
a136 1
	if (ver == DTLS1_VERSION)
d150 1
a150 2
	unsigned long Time=(unsigned long)time(NULL),l;
	long num1;
d186 2
a187 1
			if ((s->version & 0xff00 ) != (DTLS1_VERSION & 0xff00))
d225 2
d237 1
d263 1
d278 1
d288 17
a304 2
			/* Check if it is anon DH */
			if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))
d308 12
d323 1
d325 1
d369 1
d378 1
a380 1
			l=s->s3->tmp.new_cipher->algorithms;
d400 1
d410 1
d445 1
d467 7
d477 10
a486 2
			/* mark client_random uninitialized */
			memset (s->s3->client_random,0,sizeof(s->s3->client_random));
d488 8
a495 1
			break;
d499 1
a499 1

d503 1
d513 5
a517 8
			/* number of bytes to be flushed */
			num1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);
			if (num1 > 0)
				{
				s->rwstate=SSL_WRITING;
				num1=BIO_flush(s->wbio);
				if (num1 <= 0) { ret= -1; goto end; }
				s->rwstate=SSL_NOTHING;
d519 1
a519 1

d556 1
d606 1
d609 5
d622 1
d630 1
a630 1
			RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4);
d693 9
a701 1
		
d777 1
a777 1
	unsigned long l;
d785 8
d798 2
a799 2

		l=s->s3->tmp.new_cipher->algorithms;
d804 1
a804 1
		else if (l & SSL_kRSA)
d863 1
a863 1
		else if (l & SSL_kKRB5)
d871 1
a871 1
			EVP_CIPHER	*enc = NULL;
d882 1
a882 1
                                l, SSL_kKRB5);
d972 1
a972 1
			if (outl > sizeof epms)
d995 1
a995 1
		else if (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
d1050 268
d1346 7
d1365 1
a1365 1
#ifndef OPENSSL_NO_DSA
d1375 2
a1376 1
		s->method->ssl3_enc->cert_verify_mac(s,&(s->s3->finish_dgst2),
d1383 2
a1384 1
				&(s->s3->finish_dgst1),&(data[0]));
d1406 17
@


1.1
log
@Initial revision
@
text
@d1098 1
a1098 2
		if (s->ctx->client_cert_cb != NULL)
			i=s->ctx->client_cert_cb(s,&(x509),&(pkey));
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import openssl-0.9.8j
@
text
@d1098 2
a1099 1
		i = ssl_do_client_cert_cb(s, &x509, &pkey);
@


1.1.1.3
log
@import OpenSSL-1.0.0a
@
text
@d7 1
a7 1
 * Copyright (c) 1999-2007 The OpenSSL Project.  All rights reserved.
a117 1
#ifndef OPENSSL_NO_KRB5
a118 1
#endif
a123 1
#include <openssl/bn.h>
d128 1
a128 1
static const SSL_METHOD *dtls1_get_client_method(int ver);
d131 1
a131 1
static const SSL_METHOD *dtls1_get_client_method(int ver)
d133 1
a133 1
	if (ver == DTLS1_VERSION || ver == DTLS1_BAD_VER)
d147 2
a148 1
	unsigned long Time=(unsigned long)time(NULL);
d184 1
a184 2
			if ((s->version & 0xff00 ) != (DTLS1_VERSION & 0xff00) &&
			    (s->version & 0xff00 ) != (DTLS1_BAD_VER & 0xff00))
a221 2
			s->d1->send_cookie = 0;
			s->hit = 0;
a231 1
			dtls1_start_timer(s);
a256 1
				dtls1_stop_timer(s);
a270 1
			dtls1_stop_timer(s);
d280 2
a281 17
#ifndef OPENSSL_NO_TLSEXT
			ret=ssl3_check_finished(s);
			if (ret <= 0) goto end;
			if (ret == 2)
				{
				s->hit = 1;
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_CR_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_CR_FINISHED_A;
				s->init_num=0;
				break;
				}
#endif
			/* Check if it is anon DH or PSK */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
			    !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
a284 12
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_CR_CERT_STATUS_A;
				else
					s->state=SSL3_ST_CR_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_CR_KEY_EXCH_A;
				}
#else
a287 1

a288 1
#endif
a331 1
			dtls1_start_timer(s);
a339 1
			dtls1_start_timer(s);
d342 1
a361 1
			dtls1_start_timer(s);
a370 1
			dtls1_start_timer(s);
a404 1
			dtls1_start_timer(s);
a425 7
#ifndef OPENSSL_NO_TLSEXT
				/* Allow NewSessionTicket if ticket expected */
				if (s->tlsext_ticket_expected)
					s->s3->tmp.next_state=SSL3_ST_CR_SESSION_TICKET_A;
				else
#endif
				
d429 3
a433 18
#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_CR_SESSION_TICKET_A:
		case SSL3_ST_CR_SESSION_TICKET_B:
			ret=ssl3_get_new_session_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_FINISHED_A;
			s->init_num=0;
		break;

		case SSL3_ST_CR_CERT_STATUS_A:
		case SSL3_ST_CR_CERT_STATUS_B:
			ret=ssl3_get_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_KEY_EXCH_A;
			s->init_num=0;
		break;
#endif

d436 1
a436 1
			s->d1->change_cipher_spec_ok = 1;
a439 1
			dtls1_stop_timer(s);
d449 8
a456 5
			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				ret= -1;
				goto end;
d458 1
a458 1
			s->rwstate=SSL_NOTHING;
a494 1
			s->d1->next_handshake_write_seq = 0;
a543 1
		SSL_SESSION *sess = s->session;
a545 5
#ifdef OPENSSL_NO_TLSEXT
			!sess->session_id_length ||
#else
			(!sess->session_id_length && !sess->tlsext_tick) ||
#endif
a553 1

d561 1
a561 1
			RAND_pseudo_bytes(p,sizeof(s->s3->client_random)-4);
d624 1
a624 9

#ifndef OPENSSL_NO_TLSEXT
		if ((p = ssl_add_clienthello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH)) == NULL)
			{
			SSLerr(SSL_F_DTLS1_CLIENT_HELLO,ERR_R_INTERNAL_ERROR);
			goto err;
			}
#endif		

d700 1
a700 1
	unsigned long alg_k;
a707 8
#ifndef OPENSSL_NO_ECDH
	EC_KEY *clnt_ecdh = NULL;
	const EC_POINT *srvr_ecpoint = NULL;
	EVP_PKEY *srvr_pub_pkey = NULL;
	unsigned char *encodedPoint = NULL;
	int encoded_pt_len = 0;
	BN_CTX * bn_ctx = NULL;
#endif
d713 2
a714 2
		
		alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
d719 1
a719 1
		else if (alg_k & SSL_kRSA)
d778 1
a778 1
		else if (alg_k & SSL_kKRB5)
d786 1
a786 1
			const EVP_CIPHER *enc = NULL;
d797 1
a797 1
                                alg_k, SSL_kKRB5);
d887 1
a887 1
			if (outl > (int)sizeof epms)
d910 1
a910 1
		else if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
a964 268
#ifndef OPENSSL_NO_ECDH 
		else if (alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe))
			{
			const EC_GROUP *srvr_group = NULL;
			EC_KEY *tkey;
			int ecdh_clnt_cert = 0;
			int field_size = 0;

			/* Did we send out the client's
			 * ECDH share for use in premaster
			 * computation as part of client certificate?
			 * If so, set ecdh_clnt_cert to 1.
			 */
			if ((alg_k & (SSL_kECDHr|SSL_kECDHe)) && (s->cert != NULL)) 
				{
				/* XXX: For now, we do not support client
				 * authentication using ECDH certificates.
				 * To add such support, one needs to add
				 * code that checks for appropriate 
				 * conditions and sets ecdh_clnt_cert to 1.
				 * For example, the cert have an ECC
				 * key on the same curve as the server's
				 * and the key should be authorized for
				 * key agreement.
				 *
				 * One also needs to add code in ssl3_connect
				 * to skip sending the certificate verify
				 * message.
				 *
				 * if ((s->cert->key->privatekey != NULL) &&
				 *     (s->cert->key->privatekey->type ==
				 *      EVP_PKEY_EC) && ...)
				 * ecdh_clnt_cert = 1;
				 */
				}

			if (s->session->sess_cert->peer_ecdh_tmp != NULL)
				{
				tkey = s->session->sess_cert->peer_ecdh_tmp;
				}
			else
				{
				/* Get the Server Public Key from Cert */
				srvr_pub_pkey = X509_get_pubkey(s->session-> \
				    sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
				if ((srvr_pub_pkey == NULL) ||
				    (srvr_pub_pkey->type != EVP_PKEY_EC) ||
				    (srvr_pub_pkey->pkey.ec == NULL))
					{
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
					    ERR_R_INTERNAL_ERROR);
					goto err;
					}

				tkey = srvr_pub_pkey->pkey.ec;
				}

			srvr_group   = EC_KEY_get0_group(tkey);
			srvr_ecpoint = EC_KEY_get0_public_key(tkey);

			if ((srvr_group == NULL) || (srvr_ecpoint == NULL))
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
				}

			if ((clnt_ecdh=EC_KEY_new()) == NULL) 
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
				goto err;
				}

			if (!EC_KEY_set_group(clnt_ecdh, srvr_group))
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);
				goto err;
				}
			if (ecdh_clnt_cert) 
				{ 
				/* Reuse key info from our certificate
				 * We only need our private key to perform
				 * the ECDH computation.
				 */
				const BIGNUM *priv_key;
				tkey = s->cert->key->privatekey->pkey.ec;
				priv_key = EC_KEY_get0_private_key(tkey);
				if (priv_key == NULL)
					{
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
					goto err;
					}
				if (!EC_KEY_set_private_key(clnt_ecdh, priv_key))
					{
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);
					goto err;
					}
				}
			else 
				{
				/* Generate a new ECDH key pair */
				if (!(EC_KEY_generate_key(clnt_ecdh)))
					{
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ECDH_LIB);
					goto err;
					}
				}

			/* use the 'p' output buffer for the ECDH key, but
			 * make sure to clear it out afterwards
			 */

			field_size = EC_GROUP_get_degree(srvr_group);
			if (field_size <= 0)
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, 
				       ERR_R_ECDH_LIB);
				goto err;
				}
			n=ECDH_compute_key(p, (field_size+7)/8, srvr_ecpoint, clnt_ecdh, NULL);
			if (n <= 0)
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, 
				       ERR_R_ECDH_LIB);
				goto err;
				}

			/* generate master key from the result */
			s->session->master_key_length = s->method->ssl3_enc \
			    -> generate_master_secret(s, 
				s->session->master_key,
				p, n);

			memset(p, 0, n); /* clean up */

			if (ecdh_clnt_cert) 
				{
				/* Send empty client key exch message */
				n = 0;
				}
			else 
				{
				/* First check the size of encoding and
				 * allocate memory accordingly.
				 */
				encoded_pt_len = 
				    EC_POINT_point2oct(srvr_group, 
					EC_KEY_get0_public_key(clnt_ecdh), 
					POINT_CONVERSION_UNCOMPRESSED, 
					NULL, 0, NULL);

				encodedPoint = (unsigned char *) 
				    OPENSSL_malloc(encoded_pt_len * 
					sizeof(unsigned char)); 
				bn_ctx = BN_CTX_new();
				if ((encodedPoint == NULL) || 
				    (bn_ctx == NULL)) 
					{
					SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
					goto err;
					}

				/* Encode the public key */
				n = EC_POINT_point2oct(srvr_group, 
				    EC_KEY_get0_public_key(clnt_ecdh), 
				    POINT_CONVERSION_UNCOMPRESSED, 
				    encodedPoint, encoded_pt_len, bn_ctx);

				*p = n; /* length of encoded point */
				/* Encoded point will be copied here */
				p += 1; 
				/* copy the point */
				memcpy((unsigned char *)p, encodedPoint, n);
				/* increment n to account for length field */
				n += 1; 
				}

			/* Free allocated memory */
			BN_CTX_free(bn_ctx);
			if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
			if (clnt_ecdh != NULL) 
				 EC_KEY_free(clnt_ecdh);
			EVP_PKEY_free(srvr_pub_pkey);
			}
#endif /* !OPENSSL_NO_ECDH */

#ifndef OPENSSL_NO_PSK
		else if (alg_k & SSL_kPSK)
			{
			char identity[PSK_MAX_IDENTITY_LEN];
			unsigned char *t = NULL;
			unsigned char psk_or_pre_ms[PSK_MAX_PSK_LEN*2+4];
			unsigned int pre_ms_len = 0, psk_len = 0;
			int psk_err = 1;

			n = 0;
			if (s->psk_client_callback == NULL)
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
					SSL_R_PSK_NO_CLIENT_CB);
				goto err;
				}

			psk_len = s->psk_client_callback(s, s->ctx->psk_identity_hint,
				identity, PSK_MAX_IDENTITY_LEN,
				psk_or_pre_ms, sizeof(psk_or_pre_ms));
			if (psk_len > PSK_MAX_PSK_LEN)
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
					ERR_R_INTERNAL_ERROR);
				goto psk_err;
				}
			else if (psk_len == 0)
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
					SSL_R_PSK_IDENTITY_NOT_FOUND);
				goto psk_err;
				}

			/* create PSK pre_master_secret */
			pre_ms_len = 2+psk_len+2+psk_len;
			t = psk_or_pre_ms;
			memmove(psk_or_pre_ms+psk_len+4, psk_or_pre_ms, psk_len);
			s2n(psk_len, t);
			memset(t, 0, psk_len);
			t+=psk_len;
			s2n(psk_len, t);

			if (s->session->psk_identity_hint != NULL)
				OPENSSL_free(s->session->psk_identity_hint);
			s->session->psk_identity_hint = BUF_strdup(s->ctx->psk_identity_hint);
			if (s->ctx->psk_identity_hint != NULL &&
				s->session->psk_identity_hint == NULL)
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
					ERR_R_MALLOC_FAILURE);
				goto psk_err;
				}

			if (s->session->psk_identity != NULL)
				OPENSSL_free(s->session->psk_identity);
			s->session->psk_identity = BUF_strdup(identity);
			if (s->session->psk_identity == NULL)
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,
					ERR_R_MALLOC_FAILURE);
				goto psk_err;
				}

			s->session->master_key_length =
				s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key,
					psk_or_pre_ms, pre_ms_len); 
			n = strlen(identity);
			s2n(n, p);
			memcpy(p, identity, n);
			n+=2;
			psk_err = 0;
		psk_err:
			OPENSSL_cleanse(identity, PSK_MAX_IDENTITY_LEN);
			OPENSSL_cleanse(psk_or_pre_ms, sizeof(psk_or_pre_ms));
			if (psk_err != 0)
				{
				ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);
				goto err;
				}
			}
#endif
a992 7
#ifndef OPENSSL_NO_ECDH
	BN_CTX_free(bn_ctx);
	if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
	if (clnt_ecdh != NULL) 
		EC_KEY_free(clnt_ecdh);
	EVP_PKEY_free(srvr_pub_pkey);
#endif
d1005 1
a1005 1
#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_ECDSA)
d1015 1
a1015 2
		s->method->ssl3_enc->cert_verify_mac(s,
		NID_sha1,
d1022 1
a1022 2
				NID_md5,
				&(data[0]));
a1043 17
				goto err;
				}
			s2n(j,p);
			n=j+2;
			}
		else
#endif
#ifndef OPENSSL_NO_ECDSA
			if (pkey->type == EVP_PKEY_EC)
			{
			if (!ECDSA_sign(pkey->save_type,
				&(data[MD5_DIGEST_LENGTH]),
				SHA_DIGEST_LENGTH,&(p[2]),
				(unsigned int *)&j,pkey->pkey.ec))
				{
				SSLerr(SSL_F_DTLS1_SEND_CLIENT_VERIFY,
				    ERR_R_ECDSA_LIB);
@


1.1.1.4
log
@import OpenSSL 1.0.0e
@
text
@d410 1
a410 2
			if (!s->hit)
				dtls1_start_timer(s);
d445 1
a445 2
			if (!s->hit)
				dtls1_start_timer(s);
@


1.1.1.5
log
@import OpenSSL-1.0.1c
@
text
@d153 1
a153 5
	int new_state,state,skip=0;
#ifndef OPENSSL_NO_SCTP
	unsigned char sctpauthkey[64];
	char labelbuffer[sizeof(DTLS1_SCTP_AUTH_LABEL)];
#endif
a166 21
#ifndef OPENSSL_NO_SCTP
	/* Notify SCTP BIO socket to enter handshake
	 * mode and prevent stream identifier other
	 * than 0. Will be ignored if no SCTP is used.
	 */
	BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE, s->in_handshake, NULL);
#endif

#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		dtls1_stop_timer(s);
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

d174 1
a174 1
			s->renegotiate=1;
a228 36
#ifndef OPENSSL_NO_SCTP
		case DTLS1_SCTP_ST_CR_READ_SOCK:

			if (BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))
			{
				s->s3->in_read_app_data=2;
				s->rwstate=SSL_READING;
				BIO_clear_retry_flags(SSL_get_rbio(s));
				BIO_set_retry_read(SSL_get_rbio(s));
				ret = -1;
				goto end;
			}

			s->state=s->s3->tmp.next_state;
			break;

		case DTLS1_SCTP_ST_CW_WRITE_SOCK:
			/* read app data until dry event */

			ret = BIO_dgram_sctp_wait_for_dry(SSL_get_wbio(s));
			if (ret < 0) goto end;

			if (ret == 0)
			{
				s->s3->in_read_app_data=2;
				s->rwstate=SSL_READING;
				BIO_clear_retry_flags(SSL_get_rbio(s));
				BIO_set_retry_read(SSL_get_rbio(s));
				ret = -1;
				goto end;
			}

			s->state=s->d1->next_state;
			break;
#endif

d251 3
a253 11
#ifndef OPENSSL_NO_SCTP
			/* Disable buffering for SCTP */
			if (!BIO_dgram_is_sctp(SSL_get_wbio(s)))
				{
#endif
				/* turn on buffering for the next lot of output */
				if (s->bbio != s->wbio)
					s->wbio=BIO_push(s->bbio,s->wbio);
#ifndef OPENSSL_NO_SCTP
				}
#endif
d263 1
a264 16
					{
#ifndef OPENSSL_NO_SCTP
					/* Add new shared key for SCTP-Auth,
					 * will be ignored if no SCTP used.
					 */
					snprintf((char*) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),
					         DTLS1_SCTP_AUTH_LABEL);

					SSL_export_keying_material(s, sctpauthkey,
					                           sizeof(sctpauthkey), labelbuffer,
					                           sizeof(labelbuffer), NULL, 0, 0);

					BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
							 sizeof(sctpauthkey), sctpauthkey);
#endif

a265 1
					}
a356 1
			dtls1_stop_timer(s);
d358 1
a358 1
				s->s3->tmp.next_state=SSL3_ST_CW_CERT_A;
d360 1
a360 1
				s->s3->tmp.next_state=SSL3_ST_CW_KEY_EXCH_A;
a362 7
#ifndef OPENSSL_NO_SCTP			
			if (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&
			    state == SSL_ST_RENEGOTIATE)
				s->state=DTLS1_SCTP_ST_CR_READ_SOCK;
			else
#endif			
			s->state=s->s3->tmp.next_state;
a380 16

#ifndef OPENSSL_NO_SCTP
			/* Add new shared key for SCTP-Auth,
			 * will be ignored if no SCTP used.
			 */
			snprintf((char*) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),
			         DTLS1_SCTP_AUTH_LABEL);

			SSL_export_keying_material(s, sctpauthkey,
			                           sizeof(sctpauthkey), labelbuffer,
			                           sizeof(labelbuffer), NULL, 0, 0);

			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
					 sizeof(sctpauthkey), sctpauthkey);
#endif

d391 1
a391 9
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state=SSL3_ST_CW_CHANGE_A;
					s->state=DTLS1_SCTP_ST_CW_WRITE_SOCK;
					}
				else
#endif
					s->state=SSL3_ST_CW_CHANGE_A;
d403 1
a403 9
#ifndef OPENSSL_NO_SCTP
			if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
			{
				s->d1->next_state=SSL3_ST_CW_CHANGE_A;
				s->state=DTLS1_SCTP_ST_CW_WRITE_SOCK;
			}
			else
#endif
				s->state=SSL3_ST_CW_CHANGE_A;
a414 8

#ifndef OPENSSL_NO_SCTP
			/* Change to new shared key of SCTP-Auth,
			 * will be ignored if no SCTP used.
			 */
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
#endif

a459 7
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
						s->d1->next_state = s->s3->tmp.next_state;
						s->s3->tmp.next_state=DTLS1_SCTP_ST_CW_WRITE_SOCK;
					}
#endif
a462 7
#ifndef OPENSSL_NO_SCTP
					if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
						{
							s->d1->next_state = SSL_ST_OK;
							s->state=DTLS1_SCTP_ST_CW_WRITE_SOCK;
						}
#endif
a510 10

#ifndef OPENSSL_NO_SCTP
			if (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&
				state == SSL_ST_RENEGOTIATE)
				{
				s->d1->next_state=s->state;
				s->state=DTLS1_SCTP_ST_CW_WRITE_SOCK;
				}
#endif

a517 7
				/* If the write error was fatal, stop trying */
				if (!BIO_should_retry(s->wbio))
					{
					s->rwstate=SSL_NOTHING;
					s->state=s->s3->tmp.next_state;
					}
				
a543 1
			s->renegotiate=0;
a589 9
	
#ifndef OPENSSL_NO_SCTP
	/* Notify SCTP BIO socket to leave handshake
	 * mode and allow stream identifier other
	 * than 0. Will be ignored if no SCTP is used.
	 */
	BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE, s->in_handshake, NULL);
#endif

@


1.1.1.6
log
@Import OpenSSL 1.0.1g
@
text
@d541 7
a573 10
#ifndef OPENSSL_NO_SCTP
				if (s->hit)
					{
					/* Change to new shared key of SCTP-Auth,
					 * will be ignored if no SCTP used.
					 */
					BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
					}
#endif

a615 7
#ifndef OPENSSL_NO_SCTP
				/* Change to new shared key of SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
#endif

d776 1
a776 1
	unsigned long l;
d801 1
a801 2
		for (i=0;p[i]=='\0' && i<sizeof(s->s3->client_random);i++)
			;
d803 5
a807 2
			ssl_fill_hello_random(s, 0, p,
					      sizeof(s->s3->client_random));
@


