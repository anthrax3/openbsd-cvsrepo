head	1.134;
access;
symbols
	OPENBSD_6_1:1.127.0.4
	OPENBSD_6_1_BASE:1.127;
locks; strict;
comment	@ * @;


1.134
date	2017.08.30.16.24.21;	author jsing;	state Exp;
branches;
next	1.133;
commitid	bb5uAl96fNTkBlaY;

1.133
date	2017.08.28.17.36.58;	author jsing;	state Exp;
branches;
next	1.132;
commitid	8Sp0KD8xWCnY2mOk;

1.132
date	2017.08.13.16.28.45;	author jsing;	state Exp;
branches;
next	1.131;
commitid	cVr2s33jy79EDzok;

1.131
date	2017.08.13.16.25.19;	author jsing;	state Exp;
branches;
next	1.130;
commitid	y9k3U2MDf2ZBXv7V;

1.130
date	2017.08.10.17.18.38;	author jsing;	state Exp;
branches;
next	1.129;
commitid	dKulPy2Ty6efAQYX;

1.129
date	2017.05.07.04.22.24;	author beck;	state Exp;
branches;
next	1.128;
commitid	lvbt7GJEb5w5u0NS;

1.128
date	2017.05.06.20.37.25;	author jsing;	state Exp;
branches;
next	1.127;
commitid	TYalkspbBA5xUOBz;

1.127
date	2017.02.05.15.06.05;	author jsing;	state Exp;
branches;
next	1.126;
commitid	cQmoHP6ZRA5LjFSi;

1.126
date	2017.01.31.15.35.46;	author jsing;	state Exp;
branches;
next	1.125;
commitid	a7kVbIEh0Aj50LTz;

1.125
date	2017.01.26.07.20.57;	author beck;	state Exp;
branches;
next	1.124;
commitid	t6df4Y0447eXpzHd;

1.124
date	2017.01.26.00.29.04;	author jsing;	state Exp;
branches;
next	1.123;
commitid	tKHEg8Aiud7kuc5q;

1.123
date	2017.01.25.03.20.27;	author jsing;	state Exp;
branches;
next	1.122;
commitid	20gJtvQDKJ57I1fQ;

1.122
date	2017.01.24.09.03.21;	author jsing;	state Exp;
branches;
next	1.121;
commitid	NTZJ3rEptTLCIZDB;

1.121
date	2017.01.24.02.56.17;	author jsing;	state Exp;
branches;
next	1.120;
commitid	RfBpe8ry9y8Vp3dy;

1.120
date	2017.01.23.22.34.38;	author beck;	state Exp;
branches;
next	1.119;
commitid	LjSyQ9gcPyeZpDNB;

1.119
date	2017.01.23.14.35.42;	author jsing;	state Exp;
branches;
next	1.118;
commitid	fvePj4ki9zOwq3SB;

1.118
date	2017.01.23.13.36.13;	author jsing;	state Exp;
branches;
next	1.117;
commitid	xYJ523Ay020rUB5W;

1.117
date	2017.01.23.10.22.06;	author jsing;	state Exp;
branches;
next	1.116;
commitid	sfluQzS4C53eT1pq;

1.116
date	2017.01.23.08.48.44;	author beck;	state Exp;
branches;
next	1.115;
commitid	vAKES6VByBpegTl4;

1.115
date	2017.01.23.08.08.06;	author beck;	state Exp;
branches;
next	1.114;
commitid	INyvrQFO5zrO2vlL;

1.114
date	2017.01.23.06.45.30;	author beck;	state Exp;
branches;
next	1.113;
commitid	grTXB43OAHDwwKOU;

1.113
date	2017.01.23.05.27.22;	author jsing;	state Exp;
branches;
next	1.112;
commitid	Fb8XE84a6xE5r8Gy;

1.112
date	2017.01.23.05.13.02;	author jsing;	state Exp;
branches;
next	1.111;
commitid	XWcFqNClp2MoKERU;

1.111
date	2017.01.23.04.55.27;	author beck;	state Exp;
branches;
next	1.110;
commitid	AhwkqHI5lKK3NR31;

1.110
date	2017.01.23.04.15.28;	author jsing;	state Exp;
branches;
next	1.109;
commitid	j20UnjrPw7WvzMvm;

1.109
date	2017.01.23.01.22.08;	author jsing;	state Exp;
branches;
next	1.108;
commitid	YymiVWgtX4KkSfL3;

1.108
date	2017.01.23.01.04.23;	author jsing;	state Exp;
branches;
next	1.107;
commitid	UFLWZxST2Sb2brUP;

1.107
date	2017.01.23.00.12.54;	author jsing;	state Exp;
branches;
next	1.106;
commitid	Ry6OEk67lc2U2xi9;

1.106
date	2017.01.22.06.36.49;	author jsing;	state Exp;
branches;
next	1.105;
commitid	jkexAOoo4I6xT9SH;

1.105
date	2017.01.22.05.14.42;	author beck;	state Exp;
branches;
next	1.104;
commitid	cQZFlJKgRV0smF3Q;

1.104
date	2017.01.22.04.07.44;	author jsing;	state Exp;
branches;
next	1.103;
commitid	BEcuQdhH5OOziMLl;

1.103
date	2017.01.22.03.50.45;	author jsing;	state Exp;
branches;
next	1.102;
commitid	Q5mGTZ7ZJXh4fPDx;

1.102
date	2016.12.30.17.20.51;	author jsing;	state Exp;
branches;
next	1.101;
commitid	xp97QNZbrpDxRQqC;

1.101
date	2016.12.21.16.51.10;	author jsing;	state Exp;
branches;
next	1.100;
commitid	EsIu9q317enQYECc;

1.100
date	2016.11.04.17.58.19;	author guenther;	state Exp;
branches;
next	1.99;
commitid	tFcVtRkGNBKQzafm;

1.99
date	2016.11.02.10.59.25;	author jsing;	state Exp;
branches;
next	1.98;
commitid	FegBNioz2tK2aoYL;

1.98
date	2016.11.02.10.55.48;	author jsing;	state Exp;
branches;
next	1.97;
commitid	OxaOSFJJ3GW7A3Zm;

1.97
date	2016.11.02.10.52.30;	author jsing;	state Exp;
branches;
next	1.96;
commitid	vl3PCXSFTjIPF3QW;

1.96
date	2015.10.25.16.07.04;	author doug;	state Exp;
branches;
next	1.95;
commitid	SDFMn6fagEQNh0jn;

1.95
date	2015.10.25.15.58.57;	author doug;	state Exp;
branches;
next	1.94;
commitid	QhMKKt6LbulK0h66;

1.94
date	2015.09.10.17.57.50;	author jsing;	state Exp;
branches;
next	1.93;
commitid	T35skZJCouRaXVVY;

1.93
date	2015.08.27.06.21.15;	author doug;	state Exp;
branches;
next	1.92;
commitid	81GzeBdk0eOTcvRE;

1.92
date	2015.07.19.06.31.32;	author doug;	state Exp;
branches;
next	1.91;
commitid	as8DOqEY9XBrHJyu;

1.91
date	2015.07.18.19.41.54;	author doug;	state Exp;
branches;
next	1.90;
commitid	iFy6hDttnmi2K987;

1.90
date	2015.07.18.01.42.26;	author doug;	state Exp;
branches;
next	1.89;
commitid	LjIP0S5CJ9sr9Mac;

1.89
date	2015.07.17.15.50.37;	author doug;	state Exp;
branches;
next	1.88;
commitid	74rjqXo4BbFp9EDU;

1.88
date	2015.07.17.07.04.41;	author doug;	state Exp;
branches;
next	1.87;
commitid	UNQoAwJYBULH7Shk;

1.87
date	2015.06.20.12.29.39;	author jsing;	state Exp;
branches;
next	1.86;
commitid	uLq0p8g0ISsbXIE0;

1.86
date	2015.06.17.14.27.56;	author jsing;	state Exp;
branches;
next	1.85;
commitid	bj1SO1XyllNsvf5a;

1.85
date	2015.06.17.14.14.20;	author jsing;	state Exp;
branches;
next	1.84;
commitid	LW6xV0zXzGFOMV2z;

1.84
date	2015.06.17.06.49.27;	author doug;	state Exp;
branches;
next	1.83;
commitid	PiCDbQK0hy7esDs2;

1.83
date	2015.02.22.15.54.27;	author jsing;	state Exp;
branches;
next	1.82;
commitid	9t8bOP5HFWMq1Big;

1.82
date	2015.02.12.03.45.25;	author jsing;	state Exp;
branches;
next	1.81;
commitid	ZdeeylZ91TlYBz1I;

1.81
date	2015.02.07.04.17.11;	author jsing;	state Exp;
branches;
next	1.80;
commitid	kTcp4bxIaEX3QOn0;

1.80
date	2015.02.06.08.30.23;	author jsing;	state Exp;
branches;
next	1.79;
commitid	K5MXFl39zEkHakNY;

1.79
date	2015.02.06.01.37.11;	author reyk;	state Exp;
branches;
next	1.78;
commitid	Lv0p59uUkApDv6rT;

1.78
date	2015.01.26.13.06.39;	author jsing;	state Exp;
branches;
next	1.77;
commitid	giaBqbLY6IrY5S0l;

1.77
date	2015.01.22.09.12.57;	author reyk;	state Exp;
branches;
next	1.76;
commitid	aaSKbEKrSo5DOatY;

1.76
date	2014.12.14.15.30.50;	author jsing;	state Exp;
branches;
next	1.75;
commitid	XNZawfRSWvnVv1VS;

1.75
date	2014.12.10.14.58.56;	author jsing;	state Exp;
branches;
next	1.74;
commitid	GHVxpbbDPbCM2xPo;

1.74
date	2014.12.10.14.51.00;	author bcook;	state Exp;
branches;
next	1.73;
commitid	Goe2e4h3arLN9iNl;

1.73
date	2014.12.06.13.51.06;	author jsing;	state Exp;
branches;
next	1.72;
commitid	hIBGoSRrWndOvCaU;

1.72
date	2014.11.18.05.33.43;	author miod;	state Exp;
branches;
next	1.71;
commitid	81uwsCsokEuKDUjo;

1.71
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.70;
commitid	M3pvHgIFoWUHNqJn;

1.70
date	2014.10.31.15.34.06;	author jsing;	state Exp;
branches;
next	1.69;
commitid	V5OG7sbRChqLPbIP;

1.69
date	2014.10.31.15.25.55;	author jsing;	state Exp;
branches;
next	1.68;
commitid	NOaAgwTtK29a9Ncs;

1.68
date	2014.10.15.13.57.21;	author jsing;	state Exp;
branches;
next	1.67;
commitid	mrYYmKqkXNPjzDuB;

1.67
date	2014.10.03.13.58.18;	author jsing;	state Exp;
branches;
next	1.66;
commitid	TTuHOVoRSWSvd6HI;

1.66
date	2014.09.28.14.45.48;	author reyk;	state Exp;
branches;
next	1.65;
commitid	3rzcEvcae6gEJLgr;

1.65
date	2014.09.27.11.01.06;	author jsing;	state Exp;
branches;
next	1.64;
commitid	pg2itwAdFVptNvwc;

1.64
date	2014.09.21.17.11.04;	author jsing;	state Exp;
branches;
next	1.63;
commitid	MNvcHFf1nsj9LKgm;

1.63
date	2014.08.10.14.42.56;	author jsing;	state Exp;
branches;
next	1.62;
commitid	wihJupNvfkdpKL9O;

1.62
date	2014.07.12.19.45.53;	author jsing;	state Exp;
branches;
next	1.61;
commitid	foFDfYAdqxlf9LD4;

1.61
date	2014.07.11.09.24.44;	author beck;	state Exp;
branches;
next	1.60;
commitid	cCGiAdDteN08GytD;

1.60
date	2014.07.10.11.58.08;	author jsing;	state Exp;
branches;
next	1.59;
commitid	qLodpwcyFbEuMoav;

1.59
date	2014.07.10.09.26.08;	author jsing;	state Exp;
branches;
next	1.58;
commitid	YQZ6XBoOk46lT2M2;

1.58
date	2014.07.10.08.51.15;	author tedu;	state Exp;
branches;
next	1.57;
commitid	lsH7iukeZYSZBx6F;

1.57
date	2014.07.09.11.25.42;	author jsing;	state Exp;
branches;
next	1.56;
commitid	N5P2FUkVkAd7ODs9;

1.56
date	2014.06.13.13.28.53;	author jsing;	state Exp;
branches;
next	1.55;
commitid	Ujg3vMZHX0kgoEuK;

1.55
date	2014.06.13.11.52.03;	author jsing;	state Exp;
branches;
next	1.54;
commitid	yMCwYdOgQN7IP0A0;

1.54
date	2014.06.13.10.52.24;	author jsing;	state Exp;
branches;
next	1.53;
commitid	NX4qoGRCqaBXEm1B;

1.53
date	2014.06.13.04.29.13;	author miod;	state Exp;
branches;
next	1.52;
commitid	8Qu6YceLSxhOi4yG;

1.52
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	mJUVYpkFBZ0Zv2bG;

1.51
date	2014.06.08.14.13.43;	author jsing;	state Exp;
branches;
next	1.50;
commitid	yTVStANHMXFUNa12;

1.50
date	2014.06.07.22.23.12;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	4IX3BI6FoxwuHgdS;

1.49
date	2014.05.31.10.53.39;	author jsing;	state Exp;
branches;
next	1.48;

1.48
date	2014.05.31.10.49.28;	author jsing;	state Exp;
branches;
next	1.47;

1.47
date	2014.05.30.14.30.50;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2014.05.29.20.21.23;	author beck;	state Exp;
branches;
next	1.45;

1.45
date	2014.05.29.20.04.08;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2014.05.29.18.27.52;	author beck;	state Exp;
branches;
next	1.43;

1.43
date	2014.05.29.18.11.13;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2014.05.25.13.27.38;	author jsing;	state Exp;
branches;
next	1.41;

1.41
date	2014.05.24.13.02.32;	author jsing;	state Exp;
branches;
next	1.40;

1.40
date	2014.05.22.17.43.52;	author jsing;	state Exp;
branches;
next	1.39;

1.39
date	2014.05.05.15.03.22;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2014.05.02.17.05.41;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.30.01.05.50;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.28.20.05.21;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.28.19.06.19;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.24.19.54.04;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.23.22.26.26;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.20.12.48.19;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.17.21.37.37;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.16.21.16.33;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.16.20.39.09;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.16.17.59.16;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.15.21.47.56;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.15.12.00.25;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.14.18.45.55;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.13.23.50.02;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.13.23.05.18;	author beck;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.13.22.11.45;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2012.01.05.23.01.39;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.06.12.17.53;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.27.05.07.03;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.29.05.39.31;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.08.08.03.15;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.14.11.18.03;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.30.11.08.06;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.22.00.03.40;	author beck;	state Exp;
branches
	1.6.2.1
	1.6.4.1;
next	1.5;

1.5
date	2000.12.15.02.58.38;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.50;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.31;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.28;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.14;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.14;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.41;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.44.21;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.12.20.52.50;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.11.21.36.45;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.20.42.07;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.04.29.05.37.28;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.06.27.05.05.39;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.01.09.12.14.07;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2012.01.05.22.59.10;	author djm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2012.10.13.21.23.50;	author djm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;

1.6.2.1
date	2002.07.30.11.07.33;	author miod;	state Exp;
branches;
next	;

1.6.4.1
date	2002.07.30.15.47.52;	author jason;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2003.02.22.17.46.48;	author miod;	state Exp;
branches;
next	;


desc
@@


1.134
log
@Bring back the NPN related symbols.

Several pieces of software make use of these based on a conditional around
OPENSSL_NPN_NEGOTIATED, rather than using the presence of the symbols, the
non-existence of a OPENSSL_NO_NEXTPROTONEG define or even the existence of
the TLS extension type.

Unfortunately we cannot remove OPENSSL_NPN_NEGOTIATED since the API for
ALPN was effectively botched and reuses two parts from the NPN
implementation, rather than providing ALPN specific or generic versions.
@
text
@/* $OpenBSD: ssl.h,v 1.132 2017/08/13 16:28:45 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */

#ifndef HEADER_SSL_H
#define HEADER_SSL_H

#include <stdint.h>

#include <openssl/opensslconf.h>
#include <openssl/hmac.h>
#include <openssl/pem.h>
#include <openssl/safestack.h>

#include <openssl/bio.h>

#ifndef OPENSSL_NO_DEPRECATED
#include <openssl/buffer.h>
#include <openssl/crypto.h>
#include <openssl/lhash.h>

#ifndef OPENSSL_NO_X509
#include <openssl/x509.h>
#endif
#endif

#ifdef  __cplusplus
extern "C" {
#endif

/* SSLeay version number for ASN.1 encoding of the session information */
/* Version 0 - initial version
 * Version 1 - added the optional peer certificate
 */
#define SSL_SESSION_ASN1_VERSION 0x0001

/* text strings for the ciphers */
#define SSL_TXT_NULL_WITH_MD5		SSL2_TXT_NULL_WITH_MD5
#define SSL_TXT_RC4_128_WITH_MD5	SSL2_TXT_RC4_128_WITH_MD5
#define SSL_TXT_RC4_128_EXPORT40_WITH_MD5 SSL2_TXT_RC4_128_EXPORT40_WITH_MD5
#define SSL_TXT_RC2_128_CBC_WITH_MD5	SSL2_TXT_RC2_128_CBC_WITH_MD5
#define SSL_TXT_RC2_128_CBC_EXPORT40_WITH_MD5 SSL2_TXT_RC2_128_CBC_EXPORT40_WITH_MD5
#define SSL_TXT_IDEA_128_CBC_WITH_MD5	SSL2_TXT_IDEA_128_CBC_WITH_MD5
#define SSL_TXT_DES_64_CBC_WITH_MD5	SSL2_TXT_DES_64_CBC_WITH_MD5
#define SSL_TXT_DES_64_CBC_WITH_SHA	SSL2_TXT_DES_64_CBC_WITH_SHA
#define SSL_TXT_DES_192_EDE3_CBC_WITH_MD5 SSL2_TXT_DES_192_EDE3_CBC_WITH_MD5
#define SSL_TXT_DES_192_EDE3_CBC_WITH_SHA SSL2_TXT_DES_192_EDE3_CBC_WITH_SHA

/*    VRS Additional Kerberos5 entries
 */
#define SSL_TXT_KRB5_DES_64_CBC_SHA   SSL3_TXT_KRB5_DES_64_CBC_SHA
#define SSL_TXT_KRB5_DES_192_CBC3_SHA SSL3_TXT_KRB5_DES_192_CBC3_SHA
#define SSL_TXT_KRB5_RC4_128_SHA      SSL3_TXT_KRB5_RC4_128_SHA
#define SSL_TXT_KRB5_IDEA_128_CBC_SHA SSL3_TXT_KRB5_IDEA_128_CBC_SHA
#define SSL_TXT_KRB5_DES_64_CBC_MD5   SSL3_TXT_KRB5_DES_64_CBC_MD5
#define SSL_TXT_KRB5_DES_192_CBC3_MD5 SSL3_TXT_KRB5_DES_192_CBC3_MD5
#define SSL_TXT_KRB5_RC4_128_MD5      SSL3_TXT_KRB5_RC4_128_MD5
#define SSL_TXT_KRB5_IDEA_128_CBC_MD5 SSL3_TXT_KRB5_IDEA_128_CBC_MD5

#define SSL_TXT_KRB5_DES_40_CBC_SHA   SSL3_TXT_KRB5_DES_40_CBC_SHA
#define SSL_TXT_KRB5_RC2_40_CBC_SHA   SSL3_TXT_KRB5_RC2_40_CBC_SHA
#define SSL_TXT_KRB5_RC4_40_SHA	      SSL3_TXT_KRB5_RC4_40_SHA
#define SSL_TXT_KRB5_DES_40_CBC_MD5   SSL3_TXT_KRB5_DES_40_CBC_MD5
#define SSL_TXT_KRB5_RC2_40_CBC_MD5   SSL3_TXT_KRB5_RC2_40_CBC_MD5
#define SSL_TXT_KRB5_RC4_40_MD5	      SSL3_TXT_KRB5_RC4_40_MD5

#define SSL_TXT_KRB5_DES_40_CBC_SHA   SSL3_TXT_KRB5_DES_40_CBC_SHA
#define SSL_TXT_KRB5_DES_40_CBC_MD5   SSL3_TXT_KRB5_DES_40_CBC_MD5
#define SSL_TXT_KRB5_DES_64_CBC_SHA   SSL3_TXT_KRB5_DES_64_CBC_SHA
#define SSL_TXT_KRB5_DES_64_CBC_MD5   SSL3_TXT_KRB5_DES_64_CBC_MD5
#define SSL_TXT_KRB5_DES_192_CBC3_SHA SSL3_TXT_KRB5_DES_192_CBC3_SHA
#define SSL_TXT_KRB5_DES_192_CBC3_MD5 SSL3_TXT_KRB5_DES_192_CBC3_MD5
#define SSL_MAX_KRB5_PRINCIPAL_LENGTH  256

#define SSL_MAX_SSL_SESSION_ID_LENGTH		32
#define SSL_MAX_SID_CTX_LENGTH			32

#define SSL_MIN_RSA_MODULUS_LENGTH_IN_BYTES	(512/8)
#define SSL_MAX_KEY_ARG_LENGTH			8
#define SSL_MAX_MASTER_KEY_LENGTH		48


/* These are used to specify which ciphers to use and not to use */

#define SSL_TXT_LOW		"LOW"
#define SSL_TXT_MEDIUM		"MEDIUM"
#define SSL_TXT_HIGH		"HIGH"

#define SSL_TXT_kFZA		"kFZA" /* unused! */
#define	SSL_TXT_aFZA		"aFZA" /* unused! */
#define SSL_TXT_eFZA		"eFZA" /* unused! */
#define SSL_TXT_FZA		"FZA"  /* unused! */

#define	SSL_TXT_aNULL		"aNULL"
#define	SSL_TXT_eNULL		"eNULL"
#define	SSL_TXT_NULL		"NULL"

#define SSL_TXT_kRSA		"kRSA"
#define SSL_TXT_kDHr		"kDHr" /* no such ciphersuites supported! */
#define SSL_TXT_kDHd		"kDHd" /* no such ciphersuites supported! */
#define SSL_TXT_kDH 		"kDH"  /* no such ciphersuites supported! */
#define SSL_TXT_kEDH		"kEDH"
#define SSL_TXT_kKRB5     	"kKRB5"
#define SSL_TXT_kECDHr		"kECDHr"
#define SSL_TXT_kECDHe		"kECDHe"
#define SSL_TXT_kECDH		"kECDH"
#define SSL_TXT_kEECDH		"kEECDH"
#define SSL_TXT_kPSK            "kPSK"
#define SSL_TXT_kGOST		"kGOST"
#define SSL_TXT_kSRP		"kSRP"

#define	SSL_TXT_aRSA		"aRSA"
#define	SSL_TXT_aDSS		"aDSS"
#define	SSL_TXT_aDH		"aDH" /* no such ciphersuites supported! */
#define	SSL_TXT_aECDH		"aECDH"
#define SSL_TXT_aKRB5     	"aKRB5"
#define SSL_TXT_aECDSA		"aECDSA"
#define SSL_TXT_aPSK            "aPSK"
#define SSL_TXT_aGOST94		"aGOST94"
#define SSL_TXT_aGOST01		"aGOST01"
#define SSL_TXT_aGOST		"aGOST"

#define	SSL_TXT_DSS		"DSS"
#define SSL_TXT_DH		"DH"
#define SSL_TXT_DHE		"DHE" /* same as "kDHE:-ADH" */
#define SSL_TXT_EDH		"EDH" /* previous name for DHE */
#define SSL_TXT_ADH		"ADH"
#define SSL_TXT_RSA		"RSA"
#define SSL_TXT_ECDH		"ECDH"
#define SSL_TXT_ECDHE		"ECDHE" /* same as "kECDHE:-AECDH" */
#define SSL_TXT_EECDH		"EECDH" /* previous name for ECDHE */
#define SSL_TXT_AECDH		"AECDH"
#define SSL_TXT_ECDSA		"ECDSA"
#define SSL_TXT_KRB5      	"KRB5"
#define SSL_TXT_PSK             "PSK"
#define SSL_TXT_SRP		"SRP"

#define SSL_TXT_DES		"DES"
#define SSL_TXT_3DES		"3DES"
#define SSL_TXT_RC4		"RC4"
#define SSL_TXT_RC2		"RC2"
#define SSL_TXT_IDEA		"IDEA"
#define SSL_TXT_SEED		"SEED"
#define SSL_TXT_AES128		"AES128"
#define SSL_TXT_AES256		"AES256"
#define SSL_TXT_AES		"AES"
#define SSL_TXT_AES_GCM		"AESGCM"
#define SSL_TXT_CAMELLIA128	"CAMELLIA128"
#define SSL_TXT_CAMELLIA256	"CAMELLIA256"
#define SSL_TXT_CAMELLIA	"CAMELLIA"
#define SSL_TXT_CHACHA20	"CHACHA20"

#define SSL_TXT_AEAD		"AEAD"
#define SSL_TXT_MD5		"MD5"
#define SSL_TXT_SHA1		"SHA1"
#define SSL_TXT_SHA		"SHA" /* same as "SHA1" */
#define SSL_TXT_GOST94		"GOST94"
#define SSL_TXT_GOST89MAC		"GOST89MAC"
#define SSL_TXT_SHA256		"SHA256"
#define SSL_TXT_SHA384		"SHA384"
#define SSL_TXT_STREEBOG256		"STREEBOG256"
#define SSL_TXT_STREEBOG512		"STREEBOG512"

#define SSL_TXT_DTLS1		"DTLSv1"
#define SSL_TXT_SSLV2		"SSLv2"
#define SSL_TXT_SSLV3		"SSLv3"
#define SSL_TXT_TLSV1		"TLSv1"
#define SSL_TXT_TLSV1_1		"TLSv1.1"
#define SSL_TXT_TLSV1_2		"TLSv1.2"

#define SSL_TXT_EXP		"EXP"
#define SSL_TXT_EXPORT		"EXPORT"

#define SSL_TXT_ALL		"ALL"

/*
 * COMPLEMENTOF* definitions. These identifiers are used to (de-select)
 * ciphers normally not being used.
 * Example: "RC4" will activate all ciphers using RC4 including ciphers
 * without authentication, which would normally disabled by DEFAULT (due
 * the "!ADH" being part of default). Therefore "RC4:!COMPLEMENTOFDEFAULT"
 * will make sure that it is also disabled in the specific selection.
 * COMPLEMENTOF* identifiers are portable between version, as adjustments
 * to the default cipher setup will also be included here.
 *
 * COMPLEMENTOFDEFAULT does not experience the same special treatment that
 * DEFAULT gets, as only selection is being done and no sorting as needed
 * for DEFAULT.
 */
#define SSL_TXT_CMPALL		"COMPLEMENTOFALL"
#define SSL_TXT_CMPDEF		"COMPLEMENTOFDEFAULT"

/* The following cipher list is used by default.
 * It also is substituted when an application-defined cipher list string
 * starts with 'DEFAULT'. */
#define SSL_DEFAULT_CIPHER_LIST	"ALL:!aNULL:!eNULL:!SSLv2"
/* As of OpenSSL 1.0.0, ssl_create_cipher_list() in ssl/ssl_ciph.c always
 * starts with a reasonable order, and all we have to do for DEFAULT is
 * throwing out anonymous and unencrypted ciphersuites!
 * (The latter are not actually enabled by ALL, but "ALL:RSA" would enable
 * some of them.)
 */

/* Used in SSL_set_shutdown()/SSL_get_shutdown(); */
#define SSL_SENT_SHUTDOWN	1
#define SSL_RECEIVED_SHUTDOWN	2


#define SSL_FILETYPE_ASN1	X509_FILETYPE_ASN1
#define SSL_FILETYPE_PEM	X509_FILETYPE_PEM

/* This is needed to stop compilers complaining about the
 * 'struct ssl_st *' function parameters used to prototype callbacks
 * in SSL_CTX. */
typedef struct ssl_st *ssl_crock_st;

typedef struct tls_session_ticket_ext_st TLS_SESSION_TICKET_EXT;
typedef struct ssl_method_st SSL_METHOD;
typedef struct ssl_cipher_st SSL_CIPHER;
typedef struct ssl_session_st SSL_SESSION;

DECLARE_STACK_OF(SSL_CIPHER)

/* SRTP protection profiles for use with the use_srtp extension (RFC 5764)*/
typedef struct srtp_protection_profile_st {
	const char *name;
	unsigned long id;
} SRTP_PROTECTION_PROFILE;

DECLARE_STACK_OF(SRTP_PROTECTION_PROFILE)

typedef int (*tls_session_ticket_ext_cb_fn)(SSL *s, const unsigned char *data,
    int len, void *arg);
typedef int (*tls_session_secret_cb_fn)(SSL *s, void *secret, int *secret_len,
    STACK_OF(SSL_CIPHER) *peer_ciphers, SSL_CIPHER **cipher, void *arg);

#ifndef OPENSSL_NO_SSL_INTERN

/* used to hold info on the particular ciphers used */
struct ssl_cipher_st {
	int valid;
	const char *name;		/* text name */
	unsigned long id;		/* id, 4 bytes, first is version */

	unsigned long algorithm_mkey;	/* key exchange algorithm */
	unsigned long algorithm_auth;	/* server authentication */
	unsigned long algorithm_enc;	/* symmetric encryption */
	unsigned long algorithm_mac;	/* symmetric authentication */
	unsigned long algorithm_ssl;	/* (major) protocol version */

	unsigned long algo_strength;	/* strength and export flags */
	unsigned long algorithm2;	/* Extra flags */
	int strength_bits;		/* Number of bits really used */
	int alg_bits;			/* Number of bits for algorithm */
};


/* Used to hold functions for SSLv3/TLSv1 functions */
struct ssl_method_internal_st;

struct ssl_method_st {
	int (*ssl_dispatch_alert)(SSL *s);
	int (*num_ciphers)(void);
	const SSL_CIPHER *(*get_cipher)(unsigned ncipher);
	const SSL_CIPHER *(*get_cipher_by_char)(const unsigned char *ptr);
	int (*put_cipher_by_char)(const SSL_CIPHER *cipher, unsigned char *ptr);

	const struct ssl_method_internal_st *internal;
};

/* Lets make this into an ASN.1 type structure as follows
 * SSL_SESSION_ID ::= SEQUENCE {
 *	version 		INTEGER,	-- structure version number
 *	SSLversion 		INTEGER,	-- SSL version number
 *	Cipher 			OCTET STRING,	-- the 3 byte cipher ID
 *	Session_ID 		OCTET STRING,	-- the Session ID
 *	Master_key 		OCTET STRING,	-- the master key
 *	KRB5_principal		OCTET STRING	-- optional Kerberos principal
 *	Time [ 1 ] EXPLICIT	INTEGER,	-- optional Start Time
 *	Timeout [ 2 ] EXPLICIT	INTEGER,	-- optional Timeout ins seconds
 *	Peer [ 3 ] EXPLICIT	X509,		-- optional Peer Certificate
 *	Session_ID_context [ 4 ] EXPLICIT OCTET STRING,   -- the Session ID context
 *	Verify_result [ 5 ] EXPLICIT INTEGER,   -- X509_V_... code for `Peer'
 *	HostName [ 6 ] EXPLICIT OCTET STRING,   -- optional HostName from servername TLS extension
 *	PSK_identity_hint [ 7 ] EXPLICIT OCTET STRING, -- optional PSK identity hint
 *	PSK_identity [ 8 ] EXPLICIT OCTET STRING,  -- optional PSK identity
 *	Ticket_lifetime_hint [9] EXPLICIT INTEGER, -- server's lifetime hint for session ticket
 *	Ticket [10]             EXPLICIT OCTET STRING, -- session ticket (clients only)
 *	Compression_meth [11]   EXPLICIT OCTET STRING, -- optional compression method
 *	SRP_username [ 12 ] EXPLICIT OCTET STRING -- optional SRP username
 *	}
 * Look in ssl/ssl_asn1.c for more details
 * I'm using EXPLICIT tags so I can read the damn things using asn1parse :-).
 */
struct ssl_session_internal_st;

struct ssl_session_st {
	int ssl_version;	/* what ssl version session info is
				 * being kept in here? */

	int master_key_length;
	unsigned char master_key[SSL_MAX_MASTER_KEY_LENGTH];

	/* session_id - valid? */
	unsigned int session_id_length;
	unsigned char session_id[SSL_MAX_SSL_SESSION_ID_LENGTH];

	/* this is used to determine whether the session is being reused in
	 * the appropriate context. It is up to the application to set this,
	 * via SSL_new */
	unsigned int sid_ctx_length;
	unsigned char sid_ctx[SSL_MAX_SID_CTX_LENGTH];

	/* This is the cert for the other end. */
	X509 *peer;

	/* when app_verify_callback accepts a session where the peer's certificate
	 * is not ok, we must remember the error for session reuse: */
	long verify_result; /* only for servers */

	long timeout;
	time_t time;
	int references;

	const SSL_CIPHER *cipher;
	unsigned long cipher_id;	/* when ASN.1 loaded, this
					 * needs to be used to load
					 * the 'cipher' structure */

	STACK_OF(SSL_CIPHER) *ciphers; /* shared ciphers? */

	char *tlsext_hostname;

	/* RFC4507 info */
	unsigned char *tlsext_tick;	/* Session ticket */
	size_t tlsext_ticklen;		/* Session ticket length */
	long tlsext_tick_lifetime_hint;	/* Session lifetime hint in seconds */

	struct ssl_session_internal_st *internal;
};

#endif

/* Allow initial connection to servers that don't support RI */
#define SSL_OP_LEGACY_SERVER_CONNECT			0x00000004L

/* Disable SSL 3.0/TLS 1.0 CBC vulnerability workaround that was added
 * in OpenSSL 0.9.6d.  Usually (depending on the application protocol)
 * the workaround is not needed.
 * Unfortunately some broken SSL/TLS implementations cannot handle it
 * at all, which is why it was previously included in SSL_OP_ALL.
 * Now it's not.
 */
#define SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS		0x00000800L

/* DTLS options */
#define SSL_OP_NO_QUERY_MTU				0x00001000L
/* Turn on Cookie Exchange (on relevant for servers) */
#define SSL_OP_COOKIE_EXCHANGE				0x00002000L
/* Don't use RFC4507 ticket extension */
#define SSL_OP_NO_TICKET				0x00004000L

/* As server, disallow session resumption on renegotiation */
#define SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION	0x00010000L
/* Disallow client initiated renegotiation. */
#define SSL_OP_NO_CLIENT_RENEGOTIATION			0x00020000L
/* If set, always create a new key when using tmp_dh parameters */
#define SSL_OP_SINGLE_DH_USE				0x00100000L
/* Set on servers to choose the cipher according to the server's
 * preferences */
#define SSL_OP_CIPHER_SERVER_PREFERENCE			0x00400000L
/* If set, a server will allow a client to issue a SSLv3.0 version number
 * as latest version supported in the premaster secret, even when TLSv1.0
 * (version 3.1) was announced in the client hello. Normally this is
 * forbidden to prevent version rollback attacks. */
#define SSL_OP_TLS_ROLLBACK_BUG				0x00800000L

#define SSL_OP_NO_TLSv1					0x04000000L
#define SSL_OP_NO_TLSv1_2				0x08000000L
#define SSL_OP_NO_TLSv1_1				0x10000000L

/* SSL_OP_ALL: various bug workarounds that should be rather harmless. */
#define SSL_OP_ALL \
    (SSL_OP_LEGACY_SERVER_CONNECT)

/* Obsolete flags kept for compatibility. No sane code should use them. */
#define SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION	0x0
#define SSL_OP_CISCO_ANYCONNECT				0x0
#define SSL_OP_CRYPTOPRO_TLSEXT_BUG			0x0
#define SSL_OP_EPHEMERAL_RSA				0x0
#define SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER		0x0
#define SSL_OP_MICROSOFT_SESS_ID_BUG			0x0
#define SSL_OP_MSIE_SSLV2_RSA_PADDING			0x0
#define SSL_OP_NETSCAPE_CA_DN_BUG			0x0
#define SSL_OP_NETSCAPE_CHALLENGE_BUG			0x0
#define SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG		0x0
#define SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG		0x0
#define SSL_OP_NO_COMPRESSION				0x0
#define SSL_OP_NO_SSLv2					0x0
#define SSL_OP_NO_SSLv3					0x0
#define SSL_OP_PKCS1_CHECK_1				0x0
#define SSL_OP_PKCS1_CHECK_2				0x0
#define SSL_OP_SAFARI_ECDHE_ECDSA_BUG			0x0
#define SSL_OP_SINGLE_ECDH_USE				0x0
#define SSL_OP_SSLEAY_080_CLIENT_DH_BUG			0x0
#define SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG		0x0
#define SSL_OP_TLSEXT_PADDING				0x0
#define SSL_OP_TLS_BLOCK_PADDING_BUG			0x0
#define SSL_OP_TLS_D5_BUG				0x0

/* Allow SSL_write(..., n) to return r with 0 < r < n (i.e. report success
 * when just a single record has been written): */
#define SSL_MODE_ENABLE_PARTIAL_WRITE       0x00000001L
/* Make it possible to retry SSL_write() with changed buffer location
 * (buffer contents must stay the same!); this is not the default to avoid
 * the misconception that non-blocking SSL_write() behaves like
 * non-blocking write(): */
#define SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER 0x00000002L
/* Never bother the application with retries if the transport
 * is blocking: */
#define SSL_MODE_AUTO_RETRY 0x00000004L
/* Don't attempt to automatically build certificate chain */
#define SSL_MODE_NO_AUTO_CHAIN 0x00000008L
/* Save RAM by releasing read and write buffers when they're empty. (SSL3 and
 * TLS only.)  "Released" buffers are put onto a free-list in the context
 * or just freed (depending on the context's setting for freelist_max_len). */
#define SSL_MODE_RELEASE_BUFFERS 0x00000010L

/* Note: SSL[_CTX]_set_{options,mode} use |= op on the previous value,
 * they cannot be used to clear bits. */

#define SSL_CTX_set_options(ctx,op) \
	SSL_CTX_ctrl((ctx),SSL_CTRL_OPTIONS,(op),NULL)
#define SSL_CTX_clear_options(ctx,op) \
	SSL_CTX_ctrl((ctx),SSL_CTRL_CLEAR_OPTIONS,(op),NULL)
#define SSL_CTX_get_options(ctx) \
	SSL_CTX_ctrl((ctx),SSL_CTRL_OPTIONS,0,NULL)
#define SSL_set_options(ssl,op) \
	SSL_ctrl((ssl),SSL_CTRL_OPTIONS,(op),NULL)
#define SSL_clear_options(ssl,op) \
	SSL_ctrl((ssl),SSL_CTRL_CLEAR_OPTIONS,(op),NULL)
#define SSL_get_options(ssl) \
        SSL_ctrl((ssl),SSL_CTRL_OPTIONS,0,NULL)

#define SSL_CTX_set_mode(ctx,op) \
	SSL_CTX_ctrl((ctx),SSL_CTRL_MODE,(op),NULL)
#define SSL_CTX_clear_mode(ctx,op) \
	SSL_CTX_ctrl((ctx),SSL_CTRL_CLEAR_MODE,(op),NULL)
#define SSL_CTX_get_mode(ctx) \
	SSL_CTX_ctrl((ctx),SSL_CTRL_MODE,0,NULL)
#define SSL_clear_mode(ssl,op) \
	SSL_ctrl((ssl),SSL_CTRL_CLEAR_MODE,(op),NULL)
#define SSL_set_mode(ssl,op) \
	SSL_ctrl((ssl),SSL_CTRL_MODE,(op),NULL)
#define SSL_get_mode(ssl) \
        SSL_ctrl((ssl),SSL_CTRL_MODE,0,NULL)
#define SSL_set_mtu(ssl, mtu) \
        SSL_ctrl((ssl),SSL_CTRL_SET_MTU,(mtu),NULL)

#define SSL_get_secure_renegotiation_support(ssl) \
	SSL_ctrl((ssl), SSL_CTRL_GET_RI_SUPPORT, 0, NULL)

void SSL_CTX_set_msg_callback(SSL_CTX *ctx, void (*cb)(int write_p,
    int version, int content_type, const void *buf, size_t len, SSL *ssl,
    void *arg));
void SSL_set_msg_callback(SSL *ssl, void (*cb)(int write_p, int version,
    int content_type, const void *buf, size_t len, SSL *ssl, void *arg));
#define SSL_CTX_set_msg_callback_arg(ctx, arg) SSL_CTX_ctrl((ctx), SSL_CTRL_SET_MSG_CALLBACK_ARG, 0, (arg))
#define SSL_set_msg_callback_arg(ssl, arg) SSL_ctrl((ssl), SSL_CTRL_SET_MSG_CALLBACK_ARG, 0, (arg))

struct ssl_aead_ctx_st;
typedef struct ssl_aead_ctx_st SSL_AEAD_CTX;

#define SSL_MAX_CERT_LIST_DEFAULT 1024*100 /* 100k max cert list :-) */

#define SSL_SESSION_CACHE_MAX_SIZE_DEFAULT	(1024*20)

/* This callback type is used inside SSL_CTX, SSL, and in the functions that set
 * them. It is used to override the generation of SSL/TLS session IDs in a
 * server. Return value should be zero on an error, non-zero to proceed. Also,
 * callbacks should themselves check if the id they generate is unique otherwise
 * the SSL handshake will fail with an error - callbacks can do this using the
 * 'ssl' value they're passed by;
 *      SSL_has_matching_session_id(ssl, id, *id_len)
 * The length value passed in is set at the maximum size the session ID can be.
 * In SSLv2 this is 16 bytes, whereas SSLv3/TLSv1 it is 32 bytes. The callback
 * can alter this length to be less if desired, but under SSLv2 session IDs are
 * supposed to be fixed at 16 bytes so the id will be padded after the callback
 * returns in this case. It is also an error for the callback to set the size to
 * zero. */
typedef int (*GEN_SESSION_CB)(const SSL *ssl, unsigned char *id,
    unsigned int *id_len);

typedef struct ssl_comp_st SSL_COMP;

#ifndef OPENSSL_NO_SSL_INTERN

struct ssl_comp_st {
	int id;
	const char *name;
};

DECLARE_STACK_OF(SSL_COMP)
struct lhash_st_SSL_SESSION {
	int dummy;
};

struct ssl_ctx_internal_st;

struct ssl_ctx_st {
	const SSL_METHOD *method;

	STACK_OF(SSL_CIPHER) *cipher_list;

	struct x509_store_st /* X509_STORE */ *cert_store;

	/* If timeout is not 0, it is the default timeout value set
	 * when SSL_new() is called.  This has been put in to make
	 * life easier to set things up */
	long session_timeout;

	int references;

	/* Default values to use in SSL structures follow (these are copied by SSL_new) */

	STACK_OF(X509) *extra_certs;

	int verify_mode;
	unsigned int sid_ctx_length;
	unsigned char sid_ctx[SSL_MAX_SID_CTX_LENGTH];

	X509_VERIFY_PARAM *param;

	/*
	 * XXX
	 * default_passwd_cb used by python and openvpn, need to keep it until we
	 * add an accessor
	 */
	/* Default password callback. */
	pem_password_cb *default_passwd_callback;

	/* Default password callback user data. */
	void *default_passwd_callback_userdata;

	struct ssl_ctx_internal_st *internal;
};

#endif

#define SSL_SESS_CACHE_OFF			0x0000
#define SSL_SESS_CACHE_CLIENT			0x0001
#define SSL_SESS_CACHE_SERVER			0x0002
#define SSL_SESS_CACHE_BOTH	(SSL_SESS_CACHE_CLIENT|SSL_SESS_CACHE_SERVER)
#define SSL_SESS_CACHE_NO_AUTO_CLEAR		0x0080
/* enough comments already ... see SSL_CTX_set_session_cache_mode(3) */
#define SSL_SESS_CACHE_NO_INTERNAL_LOOKUP	0x0100
#define SSL_SESS_CACHE_NO_INTERNAL_STORE	0x0200
#define SSL_SESS_CACHE_NO_INTERNAL \
	(SSL_SESS_CACHE_NO_INTERNAL_LOOKUP|SSL_SESS_CACHE_NO_INTERNAL_STORE)

struct lhash_st_SSL_SESSION *SSL_CTX_sessions(SSL_CTX *ctx);
#define SSL_CTX_sess_number(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_NUMBER,0,NULL)
#define SSL_CTX_sess_connect(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_CONNECT,0,NULL)
#define SSL_CTX_sess_connect_good(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_CONNECT_GOOD,0,NULL)
#define SSL_CTX_sess_connect_renegotiate(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_CONNECT_RENEGOTIATE,0,NULL)
#define SSL_CTX_sess_accept(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_ACCEPT,0,NULL)
#define SSL_CTX_sess_accept_renegotiate(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_ACCEPT_RENEGOTIATE,0,NULL)
#define SSL_CTX_sess_accept_good(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_ACCEPT_GOOD,0,NULL)
#define SSL_CTX_sess_hits(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_HIT,0,NULL)
#define SSL_CTX_sess_cb_hits(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_CB_HIT,0,NULL)
#define SSL_CTX_sess_misses(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_MISSES,0,NULL)
#define SSL_CTX_sess_timeouts(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_TIMEOUTS,0,NULL)
#define SSL_CTX_sess_cache_full(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_CACHE_FULL,0,NULL)

void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,
    int (*new_session_cb)(struct ssl_st *ssl, SSL_SESSION *sess));
int (*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx))(struct ssl_st *ssl,
    SSL_SESSION *sess);
void SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx,
    void (*remove_session_cb)(struct ssl_ctx_st *ctx, SSL_SESSION *sess));
void (*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx))(struct ssl_ctx_st *ctx,
    SSL_SESSION *sess);
void SSL_CTX_sess_set_get_cb(SSL_CTX *ctx,
    SSL_SESSION *(*get_session_cb)(struct ssl_st *ssl, unsigned char *data,
    int len, int *copy));
SSL_SESSION *(*SSL_CTX_sess_get_get_cb(SSL_CTX *ctx))(struct ssl_st *ssl,
    unsigned char *Data, int len, int *copy);
void SSL_CTX_set_info_callback(SSL_CTX *ctx, void (*cb)(const SSL *ssl,
    int type, int val));
void (*SSL_CTX_get_info_callback(SSL_CTX *ctx))(const SSL *ssl, int type,
    int val);
void SSL_CTX_set_client_cert_cb(SSL_CTX *ctx,
    int (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey));
int (*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx))(SSL *ssl, X509 **x509,
    EVP_PKEY **pkey);
#ifndef OPENSSL_NO_ENGINE
int SSL_CTX_set_client_cert_engine(SSL_CTX *ctx, ENGINE *e);
#endif
void SSL_CTX_set_cookie_generate_cb(SSL_CTX *ctx,
    int (*app_gen_cookie_cb)(SSL *ssl, unsigned char *cookie,
    unsigned int *cookie_len));
void SSL_CTX_set_cookie_verify_cb(SSL_CTX *ctx,
    int (*app_verify_cookie_cb)(SSL *ssl, unsigned char *cookie,
    unsigned int cookie_len));
void SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *s, int (*cb)(SSL *ssl,
    const unsigned char **out, unsigned int *outlen, void *arg), void *arg);
void SSL_CTX_set_next_proto_select_cb(SSL_CTX *s, int (*cb)(SSL *ssl,
    unsigned char **out, unsigned char *outlen, const unsigned char *in,
    unsigned int inlen, void *arg), void *arg);

int SSL_select_next_proto(unsigned char **out, unsigned char *outlen,
    const unsigned char *in, unsigned int inlen, const unsigned char *client,
    unsigned int client_len);
void SSL_get0_next_proto_negotiated(const SSL *s, const unsigned char **data,
    unsigned *len);

#define OPENSSL_NPN_UNSUPPORTED	0
#define OPENSSL_NPN_NEGOTIATED	1
#define OPENSSL_NPN_NO_OVERLAP	2

int SSL_CTX_set_alpn_protos(SSL_CTX *ctx, const unsigned char *protos,
    unsigned int protos_len);
int SSL_set_alpn_protos(SSL *ssl, const unsigned char *protos,
    unsigned int protos_len);
void SSL_CTX_set_alpn_select_cb(SSL_CTX *ctx,
    int (*cb)(SSL *ssl, const unsigned char **out, unsigned char *outlen,
    const unsigned char *in, unsigned int inlen, void *arg), void *arg);
void SSL_get0_alpn_selected(const SSL *ssl, const unsigned char **data,
    unsigned int *len);

#define SSL_NOTHING	1
#define SSL_WRITING	2
#define SSL_READING	3
#define SSL_X509_LOOKUP	4

/* These will only be used when doing non-blocking IO */
#define SSL_want_nothing(s)	(SSL_want(s) == SSL_NOTHING)
#define SSL_want_read(s)	(SSL_want(s) == SSL_READING)
#define SSL_want_write(s)	(SSL_want(s) == SSL_WRITING)
#define SSL_want_x509_lookup(s)	(SSL_want(s) == SSL_X509_LOOKUP)

#define SSL_MAC_FLAG_READ_MAC_STREAM 1
#define SSL_MAC_FLAG_WRITE_MAC_STREAM 2

#ifndef OPENSSL_NO_SSL_INTERN
struct ssl_internal_st;

struct ssl_st {
	/* protocol version
	 * (one of SSL2_VERSION, SSL3_VERSION, TLS1_VERSION, DTLS1_VERSION)
	 */
	int version;

	const SSL_METHOD *method; /* SSLv3 */

	/* There are 2 BIO's even though they are normally both the
	 * same.  This is so data can be read and written to different
	 * handlers */

	BIO *rbio; /* used by SSL_read */
	BIO *wbio; /* used by SSL_write */
	BIO *bbio; /* used during session-id reuse to concatenate
		    * messages */
	int server;	/* are we the server side? - mostly used by SSL_clear*/

	struct ssl3_state_st *s3; /* SSLv3 variables */
	struct dtls1_state_st *d1; /* DTLSv1 variables */

	X509_VERIFY_PARAM *param;

	/* crypto */
	STACK_OF(SSL_CIPHER) *cipher_list;

	/* This is used to hold the server certificate used */
	struct cert_st /* CERT */ *cert;

	/* the session_id_context is used to ensure sessions are only reused
	 * in the appropriate context */
	unsigned int sid_ctx_length;
	unsigned char sid_ctx[SSL_MAX_SID_CTX_LENGTH];

	/* This can also be in the session once a session is established */
	SSL_SESSION *session;

	/* Used in SSL2 and SSL3 */
	int verify_mode;	/* 0 don't care about verify failure.
				 * 1 fail if verify fails */
	int error;		/* error bytes to be written */
	int error_code;		/* actual code */

	SSL_CTX *ctx;

	long verify_result;

	int references;

	int client_version;	/* what was passed, used for
				 * SSLv3/TLS rollback check */

	unsigned int max_send_fragment;

	char *tlsext_hostname;

	/* certificate status request info */
	/* Status type or -1 if no status type */
	int tlsext_status_type;

	SSL_CTX * initial_ctx; /* initial ctx, used to store sessions */
#define session_ctx initial_ctx

	/*
	 * XXX really should be internal, but is
	 * touched unnaturally by wpa-supplicant
	 * and freeradius and other perversions
	 */
	EVP_CIPHER_CTX *enc_read_ctx;		/* cryptographic state */
	EVP_MD_CTX *read_hash;			/* used for mac generation */

	struct ssl_internal_st *internal;
};

#endif

#ifdef __cplusplus
}
#endif

#include <openssl/ssl2.h>
#include <openssl/ssl3.h>
#include <openssl/tls1.h>	/* This is mostly sslv3 with a few tweaks */
#include <openssl/dtls1.h>	/* Datagram TLS */
#include <openssl/ssl23.h>
#include <openssl/srtp.h>	/* Support for the use_srtp extension */

#ifdef  __cplusplus
extern "C" {
#endif

/* compatibility */
#define SSL_set_app_data(s,arg)		(SSL_set_ex_data(s,0,(char *)arg))
#define SSL_get_app_data(s)		(SSL_get_ex_data(s,0))
#define SSL_SESSION_set_app_data(s,a)	(SSL_SESSION_set_ex_data(s,0,(char *)a))
#define SSL_SESSION_get_app_data(s)	(SSL_SESSION_get_ex_data(s,0))
#define SSL_CTX_get_app_data(ctx)	(SSL_CTX_get_ex_data(ctx,0))
#define SSL_CTX_set_app_data(ctx,arg)	(SSL_CTX_set_ex_data(ctx,0,(char *)arg))

/* The following are the possible values for ssl->state are are
 * used to indicate where we are up to in the SSL connection establishment.
 * The macros that follow are about the only things you should need to use
 * and even then, only when using non-blocking IO.
 * It can also be useful to work out where you were when the connection
 * failed */

#define SSL_ST_CONNECT			0x1000
#define SSL_ST_ACCEPT			0x2000
#define SSL_ST_MASK			0x0FFF
#define SSL_ST_INIT			(SSL_ST_CONNECT|SSL_ST_ACCEPT)
#define SSL_ST_BEFORE			0x4000
#define SSL_ST_OK			0x03
#define SSL_ST_RENEGOTIATE		(0x04|SSL_ST_INIT)

#define SSL_CB_LOOP			0x01
#define SSL_CB_EXIT			0x02
#define SSL_CB_READ			0x04
#define SSL_CB_WRITE			0x08
#define SSL_CB_ALERT			0x4000 /* used in callback */
#define SSL_CB_READ_ALERT		(SSL_CB_ALERT|SSL_CB_READ)
#define SSL_CB_WRITE_ALERT		(SSL_CB_ALERT|SSL_CB_WRITE)
#define SSL_CB_ACCEPT_LOOP		(SSL_ST_ACCEPT|SSL_CB_LOOP)
#define SSL_CB_ACCEPT_EXIT		(SSL_ST_ACCEPT|SSL_CB_EXIT)
#define SSL_CB_CONNECT_LOOP		(SSL_ST_CONNECT|SSL_CB_LOOP)
#define SSL_CB_CONNECT_EXIT		(SSL_ST_CONNECT|SSL_CB_EXIT)
#define SSL_CB_HANDSHAKE_START		0x10
#define SSL_CB_HANDSHAKE_DONE		0x20

/* Is the SSL_connection established? */
#define SSL_get_state(a)		(SSL_state((a)))
#define SSL_is_init_finished(a)		(SSL_state((a)) == SSL_ST_OK)
#define SSL_in_init(a)			(SSL_state((a))&SSL_ST_INIT)
#define SSL_in_before(a)		(SSL_state((a))&SSL_ST_BEFORE)
#define SSL_in_connect_init(a)		(SSL_state((a))&SSL_ST_CONNECT)
#define SSL_in_accept_init(a)		(SSL_state((a))&SSL_ST_ACCEPT)

/* The following 2 states are kept in ssl->rstate when reads fail,
 * you should not need these */
#define SSL_ST_READ_HEADER		0xF0
#define SSL_ST_READ_BODY		0xF1
#define SSL_ST_READ_DONE		0xF2

/* Obtain latest Finished message
 *   -- that we sent (SSL_get_finished)
 *   -- that we expected from peer (SSL_get_peer_finished).
 * Returns length (0 == no Finished so far), copies up to 'count' bytes. */
size_t SSL_get_finished(const SSL *s, void *buf, size_t count);
size_t SSL_get_peer_finished(const SSL *s, void *buf, size_t count);

/* use either SSL_VERIFY_NONE or SSL_VERIFY_PEER, the last 2 options
 * are 'ored' with SSL_VERIFY_PEER if they are desired */
#define SSL_VERIFY_NONE			0x00
#define SSL_VERIFY_PEER			0x01
#define SSL_VERIFY_FAIL_IF_NO_PEER_CERT	0x02
#define SSL_VERIFY_CLIENT_ONCE		0x04

#define OpenSSL_add_ssl_algorithms()	SSL_library_init()
#define SSLeay_add_ssl_algorithms()	SSL_library_init()

/* More backward compatibility */
#define SSL_get_cipher(s) \
		SSL_CIPHER_get_name(SSL_get_current_cipher(s))
#define SSL_get_cipher_bits(s,np) \
		SSL_CIPHER_get_bits(SSL_get_current_cipher(s),np)
#define SSL_get_cipher_version(s) \
		SSL_CIPHER_get_version(SSL_get_current_cipher(s))
#define SSL_get_cipher_name(s) \
		SSL_CIPHER_get_name(SSL_get_current_cipher(s))
#define SSL_get_time(a)		SSL_SESSION_get_time(a)
#define SSL_set_time(a,b)	SSL_SESSION_set_time((a),(b))
#define SSL_get_timeout(a)	SSL_SESSION_get_timeout(a)
#define SSL_set_timeout(a,b)	SSL_SESSION_set_timeout((a),(b))

#define d2i_SSL_SESSION_bio(bp,s_id) ASN1_d2i_bio_of(SSL_SESSION,SSL_SESSION_new,d2i_SSL_SESSION,bp,s_id)
#define i2d_SSL_SESSION_bio(bp,s_id) ASN1_i2d_bio_of(SSL_SESSION,i2d_SSL_SESSION,bp,s_id)

SSL_SESSION *PEM_read_bio_SSL_SESSION(BIO *bp, SSL_SESSION **x,
    pem_password_cb *cb, void *u);
SSL_SESSION *PEM_read_SSL_SESSION(FILE *fp, SSL_SESSION **x,
    pem_password_cb *cb, void *u);
int PEM_write_bio_SSL_SESSION(BIO *bp, SSL_SESSION *x);
int PEM_write_SSL_SESSION(FILE *fp, SSL_SESSION *x);

#define SSL_AD_REASON_OFFSET		1000 /* offset to get SSL_R_... value from SSL_AD_... */

/* These alert types are for SSLv3 and TLSv1 */
#define SSL_AD_CLOSE_NOTIFY		SSL3_AD_CLOSE_NOTIFY
#define SSL_AD_UNEXPECTED_MESSAGE	SSL3_AD_UNEXPECTED_MESSAGE /* fatal */
#define SSL_AD_BAD_RECORD_MAC		SSL3_AD_BAD_RECORD_MAC     /* fatal */
#define SSL_AD_DECRYPTION_FAILED	TLS1_AD_DECRYPTION_FAILED
#define SSL_AD_RECORD_OVERFLOW		TLS1_AD_RECORD_OVERFLOW
#define SSL_AD_DECOMPRESSION_FAILURE	SSL3_AD_DECOMPRESSION_FAILURE/* fatal */
#define SSL_AD_HANDSHAKE_FAILURE	SSL3_AD_HANDSHAKE_FAILURE/* fatal */
#define SSL_AD_NO_CERTIFICATE		SSL3_AD_NO_CERTIFICATE /* Not for TLS */
#define SSL_AD_BAD_CERTIFICATE		SSL3_AD_BAD_CERTIFICATE
#define SSL_AD_UNSUPPORTED_CERTIFICATE	SSL3_AD_UNSUPPORTED_CERTIFICATE
#define SSL_AD_CERTIFICATE_REVOKED	SSL3_AD_CERTIFICATE_REVOKED
#define SSL_AD_CERTIFICATE_EXPIRED	SSL3_AD_CERTIFICATE_EXPIRED
#define SSL_AD_CERTIFICATE_UNKNOWN	SSL3_AD_CERTIFICATE_UNKNOWN
#define SSL_AD_ILLEGAL_PARAMETER	SSL3_AD_ILLEGAL_PARAMETER   /* fatal */
#define SSL_AD_UNKNOWN_CA		TLS1_AD_UNKNOWN_CA	/* fatal */
#define SSL_AD_ACCESS_DENIED		TLS1_AD_ACCESS_DENIED	/* fatal */
#define SSL_AD_DECODE_ERROR		TLS1_AD_DECODE_ERROR	/* fatal */
#define SSL_AD_DECRYPT_ERROR		TLS1_AD_DECRYPT_ERROR
#define SSL_AD_EXPORT_RESTRICTION	TLS1_AD_EXPORT_RESTRICTION/* fatal */
#define SSL_AD_PROTOCOL_VERSION		TLS1_AD_PROTOCOL_VERSION /* fatal */
#define SSL_AD_INSUFFICIENT_SECURITY	TLS1_AD_INSUFFICIENT_SECURITY/* fatal */
#define SSL_AD_INTERNAL_ERROR		TLS1_AD_INTERNAL_ERROR	/* fatal */
#define SSL_AD_INAPPROPRIATE_FALLBACK	TLS1_AD_INAPPROPRIATE_FALLBACK /* fatal */
#define SSL_AD_USER_CANCELLED		TLS1_AD_USER_CANCELLED
#define SSL_AD_NO_RENEGOTIATION		TLS1_AD_NO_RENEGOTIATION
#define SSL_AD_UNSUPPORTED_EXTENSION	TLS1_AD_UNSUPPORTED_EXTENSION
#define SSL_AD_CERTIFICATE_UNOBTAINABLE TLS1_AD_CERTIFICATE_UNOBTAINABLE
#define SSL_AD_UNRECOGNIZED_NAME	TLS1_AD_UNRECOGNIZED_NAME
#define SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE
#define SSL_AD_BAD_CERTIFICATE_HASH_VALUE TLS1_AD_BAD_CERTIFICATE_HASH_VALUE
#define SSL_AD_UNKNOWN_PSK_IDENTITY	TLS1_AD_UNKNOWN_PSK_IDENTITY /* fatal */

#define SSL_ERROR_NONE			0
#define SSL_ERROR_SSL			1
#define SSL_ERROR_WANT_READ		2
#define SSL_ERROR_WANT_WRITE		3
#define SSL_ERROR_WANT_X509_LOOKUP	4
#define SSL_ERROR_SYSCALL		5 /* look at error stack/return value/errno */
#define SSL_ERROR_ZERO_RETURN		6
#define SSL_ERROR_WANT_CONNECT		7
#define SSL_ERROR_WANT_ACCEPT		8

#define SSL_CTRL_NEED_TMP_RSA			1
#define SSL_CTRL_SET_TMP_RSA			2
#define SSL_CTRL_SET_TMP_DH			3
#define SSL_CTRL_SET_TMP_ECDH			4
#define SSL_CTRL_SET_TMP_RSA_CB			5
#define SSL_CTRL_SET_TMP_DH_CB			6
#define SSL_CTRL_SET_TMP_ECDH_CB		7

#define SSL_CTRL_GET_SESSION_REUSED		8
#define SSL_CTRL_GET_CLIENT_CERT_REQUEST	9
#define SSL_CTRL_GET_NUM_RENEGOTIATIONS		10
#define SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS	11
#define SSL_CTRL_GET_TOTAL_RENEGOTIATIONS	12
#define SSL_CTRL_GET_FLAGS			13
#define SSL_CTRL_EXTRA_CHAIN_CERT		14

#define SSL_CTRL_SET_MSG_CALLBACK               15
#define SSL_CTRL_SET_MSG_CALLBACK_ARG           16

/* only applies to datagram connections */
#define SSL_CTRL_SET_MTU                17
/* Stats */
#define SSL_CTRL_SESS_NUMBER			20
#define SSL_CTRL_SESS_CONNECT			21
#define SSL_CTRL_SESS_CONNECT_GOOD		22
#define SSL_CTRL_SESS_CONNECT_RENEGOTIATE	23
#define SSL_CTRL_SESS_ACCEPT			24
#define SSL_CTRL_SESS_ACCEPT_GOOD		25
#define SSL_CTRL_SESS_ACCEPT_RENEGOTIATE	26
#define SSL_CTRL_SESS_HIT			27
#define SSL_CTRL_SESS_CB_HIT			28
#define SSL_CTRL_SESS_MISSES			29
#define SSL_CTRL_SESS_TIMEOUTS			30
#define SSL_CTRL_SESS_CACHE_FULL		31
#define SSL_CTRL_OPTIONS			32
#define SSL_CTRL_MODE				33

#define SSL_CTRL_GET_READ_AHEAD			40
#define SSL_CTRL_SET_READ_AHEAD			41
#define SSL_CTRL_SET_SESS_CACHE_SIZE		42
#define SSL_CTRL_GET_SESS_CACHE_SIZE		43
#define SSL_CTRL_SET_SESS_CACHE_MODE		44
#define SSL_CTRL_GET_SESS_CACHE_MODE		45

#define SSL_CTRL_GET_MAX_CERT_LIST		50
#define SSL_CTRL_SET_MAX_CERT_LIST		51

#define SSL_CTRL_SET_MAX_SEND_FRAGMENT		52

/* see tls1.h for macros based on these */
#define SSL_CTRL_SET_TLSEXT_SERVERNAME_CB	53
#define SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG	54
#define SSL_CTRL_SET_TLSEXT_HOSTNAME		55
#define SSL_CTRL_SET_TLSEXT_DEBUG_CB		56
#define SSL_CTRL_SET_TLSEXT_DEBUG_ARG		57
#define SSL_CTRL_GET_TLSEXT_TICKET_KEYS		58
#define SSL_CTRL_SET_TLSEXT_TICKET_KEYS		59
#define SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB	63
#define SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG	64
#define SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE	65
#define SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS	66
#define SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS	67
#define SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS	68
#define SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS	69
#define SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP	70
#define SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP	71

#define SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB	72

#define SSL_CTRL_SET_TLS_EXT_SRP_USERNAME_CB	75
#define SSL_CTRL_SET_SRP_VERIFY_PARAM_CB		76
#define SSL_CTRL_SET_SRP_GIVE_CLIENT_PWD_CB		77

#define SSL_CTRL_SET_SRP_ARG		78
#define SSL_CTRL_SET_TLS_EXT_SRP_USERNAME		79
#define SSL_CTRL_SET_TLS_EXT_SRP_STRENGTH		80
#define SSL_CTRL_SET_TLS_EXT_SRP_PASSWORD		81

#define DTLS_CTRL_GET_TIMEOUT		73
#define DTLS_CTRL_HANDLE_TIMEOUT	74
#define DTLS_CTRL_LISTEN			75

#define SSL_CTRL_GET_RI_SUPPORT			76
#define SSL_CTRL_CLEAR_OPTIONS			77
#define SSL_CTRL_CLEAR_MODE			78

#define SSL_CTRL_GET_EXTRA_CHAIN_CERTS		82
#define SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS	83

#define SSL_CTRL_SET_GROUPS				91
#define SSL_CTRL_SET_GROUPS_LIST			92

#define SSL_CTRL_SET_ECDH_AUTO			94

#define SSL_CTRL_GET_SERVER_TMP_KEY		109

#define SSL_CTRL_SET_DH_AUTO			118

#define SSL_CTRL_SET_MIN_PROTO_VERSION			123
#define SSL_CTRL_SET_MAX_PROTO_VERSION			124

#define DTLSv1_get_timeout(ssl, arg) \
	SSL_ctrl(ssl,DTLS_CTRL_GET_TIMEOUT,0, (void *)arg)
#define DTLSv1_handle_timeout(ssl) \
	SSL_ctrl(ssl,DTLS_CTRL_HANDLE_TIMEOUT,0, NULL)
#define DTLSv1_listen(ssl, peer) \
	SSL_ctrl(ssl,DTLS_CTRL_LISTEN,0, (void *)peer)

#define SSL_session_reused(ssl) \
	SSL_ctrl((ssl),SSL_CTRL_GET_SESSION_REUSED,0,NULL)
#define SSL_num_renegotiations(ssl) \
	SSL_ctrl((ssl),SSL_CTRL_GET_NUM_RENEGOTIATIONS,0,NULL)
#define SSL_clear_num_renegotiations(ssl) \
	SSL_ctrl((ssl),SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS,0,NULL)
#define SSL_total_renegotiations(ssl) \
	SSL_ctrl((ssl),SSL_CTRL_GET_TOTAL_RENEGOTIATIONS,0,NULL)

#define SSL_CTX_need_tmp_RSA(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_NEED_TMP_RSA,0,NULL)
#define SSL_CTX_set_tmp_rsa(ctx,rsa) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_TMP_RSA,0,(char *)rsa)
#define SSL_CTX_set_tmp_dh(ctx,dh) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_TMP_DH,0,(char *)dh)
#define SSL_CTX_set_tmp_ecdh(ctx,ecdh) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_TMP_ECDH,0,(char *)ecdh)
#define SSL_CTX_set_dh_auto(ctx, onoff) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_DH_AUTO,onoff,NULL)
#define SSL_CTX_set_ecdh_auto(ctx, onoff) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_ECDH_AUTO,onoff,NULL)

#define SSL_need_tmp_RSA(ssl) \
	SSL_ctrl(ssl,SSL_CTRL_NEED_TMP_RSA,0,NULL)
#define SSL_set_tmp_rsa(ssl,rsa) \
	SSL_ctrl(ssl,SSL_CTRL_SET_TMP_RSA,0,(char *)rsa)
#define SSL_set_tmp_dh(ssl,dh) \
	SSL_ctrl(ssl,SSL_CTRL_SET_TMP_DH,0,(char *)dh)
#define SSL_set_tmp_ecdh(ssl,ecdh) \
	SSL_ctrl(ssl,SSL_CTRL_SET_TMP_ECDH,0,(char *)ecdh)
#define SSL_set_dh_auto(s, onoff) \
	SSL_ctrl(s,SSL_CTRL_SET_DH_AUTO,onoff,NULL)
#define SSL_set_ecdh_auto(s, onoff) \
	SSL_ctrl(s,SSL_CTRL_SET_ECDH_AUTO,onoff,NULL)

int SSL_CTX_set1_groups(SSL_CTX *ctx, const int *groups, size_t groups_len);
int SSL_CTX_set1_groups_list(SSL_CTX *ctx, const char *groups);

int SSL_set1_groups(SSL *ssl, const int *groups, size_t groups_len);
int SSL_set1_groups_list(SSL *ssl, const char *groups);

int SSL_CTX_set_min_proto_version(SSL_CTX *ctx, uint16_t version);
int SSL_CTX_set_max_proto_version(SSL_CTX *ctx, uint16_t version);

int SSL_set_min_proto_version(SSL *ssl, uint16_t version);
int SSL_set_max_proto_version(SSL *ssl, uint16_t version);

#ifndef LIBRESSL_INTERNAL
#define SSL_CTRL_SET_CURVES			SSL_CTRL_SET_GROUPS
#define SSL_CTRL_SET_CURVES_LIST		SSL_CTRL_SET_GROUPS_LIST

#define SSL_CTX_set1_curves SSL_CTX_set1_groups
#define SSL_CTX_set1_curves_list SSL_CTX_set1_groups_list
#define SSL_set1_curves SSL_set1_groups
#define SSL_set1_curves_list SSL_set1_groups_list
#endif

#define SSL_CTX_add_extra_chain_cert(ctx,x509) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_EXTRA_CHAIN_CERT,0,(char *)x509)
#define SSL_CTX_get_extra_chain_certs(ctx,px509) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_GET_EXTRA_CHAIN_CERTS,0,px509)
#define SSL_CTX_clear_extra_chain_certs(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS,0,NULL)

#define SSL_get_server_tmp_key(s, pk) \
	SSL_ctrl(s,SSL_CTRL_GET_SERVER_TMP_KEY,0,pk)

BIO_METHOD *BIO_f_ssl(void);
BIO *BIO_new_ssl(SSL_CTX *ctx, int client);
BIO *BIO_new_ssl_connect(SSL_CTX *ctx);
BIO *BIO_new_buffer_ssl_connect(SSL_CTX *ctx);
int BIO_ssl_copy_session_id(BIO *to, BIO *from);
void BIO_ssl_shutdown(BIO *ssl_bio);

int	SSL_CTX_set_cipher_list(SSL_CTX *, const char *str);
SSL_CTX *SSL_CTX_new(const SSL_METHOD *meth);
void	SSL_CTX_free(SSL_CTX *);
long SSL_CTX_set_timeout(SSL_CTX *ctx, long t);
long SSL_CTX_get_timeout(const SSL_CTX *ctx);
X509_STORE *SSL_CTX_get_cert_store(const SSL_CTX *);
void SSL_CTX_set_cert_store(SSL_CTX *, X509_STORE *);
int SSL_want(const SSL *s);
int	SSL_clear(SSL *s);

void	SSL_CTX_flush_sessions(SSL_CTX *ctx, long tm);

const SSL_CIPHER *SSL_get_current_cipher(const SSL *s);
const SSL_CIPHER *SSL_CIPHER_get_by_id(unsigned int id);
const SSL_CIPHER *SSL_CIPHER_get_by_value(uint16_t value);
int	SSL_CIPHER_get_bits(const SSL_CIPHER *c, int *alg_bits);
char *	SSL_CIPHER_get_version(const SSL_CIPHER *c);
const char *	SSL_CIPHER_get_name(const SSL_CIPHER *c);
unsigned long 	SSL_CIPHER_get_id(const SSL_CIPHER *c);
uint16_t SSL_CIPHER_get_value(const SSL_CIPHER *c);

int	SSL_get_fd(const SSL *s);
int	SSL_get_rfd(const SSL *s);
int	SSL_get_wfd(const SSL *s);
const char  * SSL_get_cipher_list(const SSL *s, int n);
char *	SSL_get_shared_ciphers(const SSL *s, char *buf, int len);
int	SSL_get_read_ahead(const SSL * s);
int	SSL_pending(const SSL *s);
int	SSL_set_fd(SSL *s, int fd);
int	SSL_set_rfd(SSL *s, int fd);
int	SSL_set_wfd(SSL *s, int fd);
void	SSL_set_bio(SSL *s, BIO *rbio, BIO *wbio);
BIO *	SSL_get_rbio(const SSL *s);
BIO *	SSL_get_wbio(const SSL *s);
int	SSL_set_cipher_list(SSL *s, const char *str);
void	SSL_set_read_ahead(SSL *s, int yes);
int	SSL_get_verify_mode(const SSL *s);
int	SSL_get_verify_depth(const SSL *s);
int	(*SSL_get_verify_callback(const SSL *s))(int, X509_STORE_CTX *);
void	SSL_set_verify(SSL *s, int mode,
	    int (*callback)(int ok, X509_STORE_CTX *ctx));
void	SSL_set_verify_depth(SSL *s, int depth);
int	SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa);
int	SSL_use_RSAPrivateKey_ASN1(SSL *ssl, unsigned char *d, long len);
int	SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey);
int	SSL_use_PrivateKey_ASN1(int pk, SSL *ssl, const unsigned char *d, long len);
int	SSL_use_certificate(SSL *ssl, X509 *x);
int	SSL_use_certificate_ASN1(SSL *ssl, const unsigned char *d, int len);

int	SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type);
int	SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type);
int	SSL_use_certificate_file(SSL *ssl, const char *file, int type);
int	SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type);
int	SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type);
int	SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type);
int	SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file); /* PEM type */
int	SSL_CTX_use_certificate_chain_mem(SSL_CTX *ctx, void *buf, int len);
STACK_OF(X509_NAME) *SSL_load_client_CA_file(const char *file);
int	SSL_add_file_cert_subjects_to_stack(STACK_OF(X509_NAME) *stackCAs,
	    const char *file);
int	SSL_add_dir_cert_subjects_to_stack(STACK_OF(X509_NAME) *stackCAs,
	    const char *dir);

void	SSL_load_error_strings(void );
const char *SSL_state_string(const SSL *s);
const char *SSL_rstate_string(const SSL *s);
const char *SSL_state_string_long(const SSL *s);
const char *SSL_rstate_string_long(const SSL *s);
long	SSL_SESSION_get_time(const SSL_SESSION *s);
long	SSL_SESSION_set_time(SSL_SESSION *s, long t);
long	SSL_SESSION_get_timeout(const SSL_SESSION *s);
long	SSL_SESSION_set_timeout(SSL_SESSION *s, long t);
void	SSL_copy_session_id(SSL *to, const SSL *from);
X509	*SSL_SESSION_get0_peer(SSL_SESSION *s);
int	SSL_SESSION_set1_id_context(SSL_SESSION *s,
	    const unsigned char *sid_ctx, unsigned int sid_ctx_len);

SSL_SESSION *SSL_SESSION_new(void);
const unsigned char *SSL_SESSION_get_id(const SSL_SESSION *s,
	    unsigned int *len);
unsigned int SSL_SESSION_get_compress_id(const SSL_SESSION *s);
int	SSL_SESSION_print_fp(FILE *fp, const SSL_SESSION *ses);
int	SSL_SESSION_print(BIO *fp, const SSL_SESSION *ses);
void	SSL_SESSION_free(SSL_SESSION *ses);
int	i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp);
int	SSL_set_session(SSL *to, SSL_SESSION *session);
int	SSL_CTX_add_session(SSL_CTX *s, SSL_SESSION *c);
int	SSL_CTX_remove_session(SSL_CTX *, SSL_SESSION *c);
int	SSL_CTX_set_generate_session_id(SSL_CTX *, GEN_SESSION_CB);
int	SSL_set_generate_session_id(SSL *, GEN_SESSION_CB);
int	SSL_has_matching_session_id(const SSL *ssl, const unsigned char *id,
	    unsigned int id_len);
SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp,
	    long length);

#ifdef HEADER_X509_H
X509 *	SSL_get_peer_certificate(const SSL *s);
#endif

STACK_OF(X509) *SSL_get_peer_cert_chain(const SSL *s);

int SSL_CTX_get_verify_mode(const SSL_CTX *ctx);
int SSL_CTX_get_verify_depth(const SSL_CTX *ctx);
int (*SSL_CTX_get_verify_callback(const SSL_CTX *ctx))(int, X509_STORE_CTX *);
void SSL_CTX_set_verify(SSL_CTX *ctx, int mode,
    int (*callback)(int, X509_STORE_CTX *));
void SSL_CTX_set_verify_depth(SSL_CTX *ctx, int depth);
void SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx, int (*cb)(X509_STORE_CTX *, void *), void *arg);
int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa);
int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, const unsigned char *d, long len);
int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
int SSL_CTX_use_PrivateKey_ASN1(int pk, SSL_CTX *ctx, const unsigned char *d, long len);
int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x);
int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, const unsigned char *d);

void SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, pem_password_cb *cb);
void SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx, void *u);

int SSL_CTX_check_private_key(const SSL_CTX *ctx);
int SSL_check_private_key(const SSL *ctx);

int SSL_CTX_set_session_id_context(SSL_CTX *ctx, const unsigned char *sid_ctx, unsigned int sid_ctx_len);

SSL *SSL_new(SSL_CTX *ctx);
int SSL_set_session_id_context(SSL *ssl, const unsigned char *sid_ctx, unsigned int sid_ctx_len);

int SSL_CTX_set_purpose(SSL_CTX *s, int purpose);
int SSL_set_purpose(SSL *s, int purpose);
int SSL_CTX_set_trust(SSL_CTX *s, int trust);
int SSL_set_trust(SSL *s, int trust);

int SSL_CTX_set1_param(SSL_CTX *ctx, X509_VERIFY_PARAM *vpm);
int SSL_set1_param(SSL *ssl, X509_VERIFY_PARAM *vpm);


void	SSL_free(SSL *ssl);
int 	SSL_accept(SSL *ssl);
int 	SSL_connect(SSL *ssl);
int 	SSL_read(SSL *ssl, void *buf, int num);
int 	SSL_peek(SSL *ssl, void *buf, int num);
int 	SSL_write(SSL *ssl, const void *buf, int num);
long	SSL_ctrl(SSL *ssl, int cmd, long larg, void *parg);
long	SSL_callback_ctrl(SSL *, int, void (*)(void));
long	SSL_CTX_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg);
long	SSL_CTX_callback_ctrl(SSL_CTX *, int, void (*)(void));

int	SSL_get_error(const SSL *s, int ret_code);
const char *SSL_get_version(const SSL *s);

/* This sets the 'default' SSL version that SSL_new() will create */
int SSL_CTX_set_ssl_version(SSL_CTX *ctx, const SSL_METHOD *meth);

const SSL_METHOD *SSLv23_method(void);		/* SSLv3 or TLSv1.* */
const SSL_METHOD *SSLv23_server_method(void);	/* SSLv3 or TLSv1.* */
const SSL_METHOD *SSLv23_client_method(void);	/* SSLv3 or TLSv1.* */

const SSL_METHOD *TLSv1_method(void);		/* TLSv1.0 */
const SSL_METHOD *TLSv1_server_method(void);	/* TLSv1.0 */
const SSL_METHOD *TLSv1_client_method(void);	/* TLSv1.0 */

const SSL_METHOD *TLSv1_1_method(void);		/* TLSv1.1 */
const SSL_METHOD *TLSv1_1_server_method(void);	/* TLSv1.1 */
const SSL_METHOD *TLSv1_1_client_method(void);	/* TLSv1.1 */

const SSL_METHOD *TLSv1_2_method(void);		/* TLSv1.2 */
const SSL_METHOD *TLSv1_2_server_method(void);	/* TLSv1.2 */
const SSL_METHOD *TLSv1_2_client_method(void);	/* TLSv1.2 */

const SSL_METHOD *TLS_method(void);		/* TLS v1.0 or later */
const SSL_METHOD *TLS_server_method(void);	/* TLS v1.0 or later */
const SSL_METHOD *TLS_client_method(void);	/* TLS v1.0 or later */

const SSL_METHOD *DTLSv1_method(void);		/* DTLSv1.0 */
const SSL_METHOD *DTLSv1_server_method(void);	/* DTLSv1.0 */
const SSL_METHOD *DTLSv1_client_method(void);	/* DTLSv1.0 */

STACK_OF(SSL_CIPHER) *SSL_get_ciphers(const SSL *s);

int SSL_do_handshake(SSL *s);
int SSL_renegotiate(SSL *s);
int SSL_renegotiate_abbreviated(SSL *s);
int SSL_renegotiate_pending(SSL *s);
int SSL_shutdown(SSL *s);

const SSL_METHOD *SSL_get_ssl_method(SSL *s);
int SSL_set_ssl_method(SSL *s, const SSL_METHOD *method);
const char *SSL_alert_type_string_long(int value);
const char *SSL_alert_type_string(int value);
const char *SSL_alert_desc_string_long(int value);
const char *SSL_alert_desc_string(int value);

void SSL_set_client_CA_list(SSL *s, STACK_OF(X509_NAME) *name_list);
void SSL_CTX_set_client_CA_list(SSL_CTX *ctx, STACK_OF(X509_NAME) *name_list);
STACK_OF(X509_NAME) *SSL_get_client_CA_list(const SSL *s);
STACK_OF(X509_NAME) *SSL_CTX_get_client_CA_list(const SSL_CTX *s);
int SSL_add_client_CA(SSL *ssl, X509 *x);
int SSL_CTX_add_client_CA(SSL_CTX *ctx, X509 *x);

void SSL_set_connect_state(SSL *s);
void SSL_set_accept_state(SSL *s);

long SSL_get_default_timeout(const SSL *s);

int SSL_library_init(void );

char *SSL_CIPHER_description(const SSL_CIPHER *, char *buf, int size);
STACK_OF(X509_NAME) *SSL_dup_CA_list(STACK_OF(X509_NAME) *sk);

SSL *SSL_dup(SSL *ssl);

X509 *SSL_get_certificate(const SSL *ssl);
/* EVP_PKEY */ struct evp_pkey_st *SSL_get_privatekey(SSL *ssl);

void SSL_CTX_set_quiet_shutdown(SSL_CTX *ctx,int mode);
int SSL_CTX_get_quiet_shutdown(const SSL_CTX *ctx);
void SSL_set_quiet_shutdown(SSL *ssl,int mode);
int SSL_get_quiet_shutdown(const SSL *ssl);
void SSL_set_shutdown(SSL *ssl,int mode);
int SSL_get_shutdown(const SSL *ssl);
int SSL_version(const SSL *ssl);
int SSL_CTX_set_default_verify_paths(SSL_CTX *ctx);
int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,
    const char *CApath);
int SSL_CTX_load_verify_mem(SSL_CTX *ctx, void *buf, int len);
#define SSL_get0_session SSL_get_session /* just peek at pointer */
SSL_SESSION *SSL_get_session(const SSL *ssl);
SSL_SESSION *SSL_get1_session(SSL *ssl); /* obtain a reference count */
SSL_CTX *SSL_get_SSL_CTX(const SSL *ssl);
SSL_CTX *SSL_set_SSL_CTX(SSL *ssl, SSL_CTX* ctx);
void SSL_set_info_callback(SSL *ssl,
    void (*cb)(const SSL *ssl, int type, int val));
void (*SSL_get_info_callback(const SSL *ssl))(const SSL *ssl, int type, int val);
int SSL_state(const SSL *ssl);
void SSL_set_state(SSL *ssl, int state);

void SSL_set_verify_result(SSL *ssl, long v);
long SSL_get_verify_result(const SSL *ssl);

int SSL_set_ex_data(SSL *ssl, int idx, void *data);
void *SSL_get_ex_data(const SSL *ssl, int idx);
int SSL_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
    CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);

int SSL_SESSION_set_ex_data(SSL_SESSION *ss, int idx, void *data);
void *SSL_SESSION_get_ex_data(const SSL_SESSION *ss, int idx);
int SSL_SESSION_get_ex_new_index(long argl, void *argp,
    CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
    CRYPTO_EX_free *free_func);

int SSL_CTX_set_ex_data(SSL_CTX *ssl, int idx, void *data);
void *SSL_CTX_get_ex_data(const SSL_CTX *ssl, int idx);
int SSL_CTX_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
    CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);

int SSL_get_ex_data_X509_STORE_CTX_idx(void );

#define SSL_CTX_sess_set_cache_size(ctx,t) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SESS_CACHE_SIZE,t,NULL)
#define SSL_CTX_sess_get_cache_size(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_GET_SESS_CACHE_SIZE,0,NULL)
#define SSL_CTX_set_session_cache_mode(ctx,m) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SESS_CACHE_MODE,m,NULL)
#define SSL_CTX_get_session_cache_mode(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_GET_SESS_CACHE_MODE,0,NULL)

#define SSL_CTX_get_default_read_ahead(ctx) SSL_CTX_get_read_ahead(ctx)
#define SSL_CTX_set_default_read_ahead(ctx,m) SSL_CTX_set_read_ahead(ctx,m)
#define SSL_CTX_get_read_ahead(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_GET_READ_AHEAD,0,NULL)
#define SSL_CTX_set_read_ahead(ctx,m) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_READ_AHEAD,m,NULL)
#define SSL_CTX_get_max_cert_list(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_GET_MAX_CERT_LIST,0,NULL)
#define SSL_CTX_set_max_cert_list(ctx,m) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_MAX_CERT_LIST,m,NULL)
#define SSL_get_max_cert_list(ssl) \
	SSL_ctrl(ssl,SSL_CTRL_GET_MAX_CERT_LIST,0,NULL)
#define SSL_set_max_cert_list(ssl,m) \
	SSL_ctrl(ssl,SSL_CTRL_SET_MAX_CERT_LIST,m,NULL)

#define SSL_CTX_set_max_send_fragment(ctx,m) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_MAX_SEND_FRAGMENT,m,NULL)
#define SSL_set_max_send_fragment(ssl,m) \
	SSL_ctrl(ssl,SSL_CTRL_SET_MAX_SEND_FRAGMENT,m,NULL)

/* NB: the keylength is only applicable when is_export is true */
void SSL_CTX_set_tmp_rsa_callback(SSL_CTX *ctx,
    RSA *(*cb)(SSL *ssl, int is_export, int keylength));

void SSL_set_tmp_rsa_callback(SSL *ssl,
    RSA *(*cb)(SSL *ssl, int is_export, int keylength));
void SSL_CTX_set_tmp_dh_callback(SSL_CTX *ctx,
    DH *(*dh)(SSL *ssl, int is_export, int keylength));
void SSL_set_tmp_dh_callback(SSL *ssl,
    DH *(*dh)(SSL *ssl, int is_export, int keylength));
void SSL_CTX_set_tmp_ecdh_callback(SSL_CTX *ctx,
    EC_KEY *(*ecdh)(SSL *ssl, int is_export, int keylength));
void SSL_set_tmp_ecdh_callback(SSL *ssl,
    EC_KEY *(*ecdh)(SSL *ssl, int is_export, int keylength));

const void *SSL_get_current_compression(SSL *s);
const void *SSL_get_current_expansion(SSL *s);

const char *SSL_COMP_get_name(const void *comp);
void *SSL_COMP_get_compression_methods(void);
int SSL_COMP_add_compression_method(int id, void *cm);

/* TLS extensions functions */
int SSL_set_session_ticket_ext(SSL *s, void *ext_data, int ext_len);

int SSL_set_session_ticket_ext_cb(SSL *s,
    tls_session_ticket_ext_cb_fn cb, void *arg);

/* Pre-shared secret session resumption functions */
int SSL_set_session_secret_cb(SSL *s,
    tls_session_secret_cb_fn tls_session_secret_cb, void *arg);

void SSL_set_debug(SSL *s, int debug);
int SSL_cache_hit(SSL *s);

/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_SSL_strings(void);

/* Error codes for the SSL functions. */

/* Function codes. */
#define SSL_F_CLIENT_CERTIFICATE			 100
#define SSL_F_CLIENT_FINISHED				 167
#define SSL_F_CLIENT_HELLO				 101
#define SSL_F_CLIENT_MASTER_KEY				 102
#define SSL_F_D2I_SSL_SESSION				 103
#define SSL_F_DO_DTLS1_WRITE				 245
#define SSL_F_DO_SSL3_WRITE				 104
#define SSL_F_DTLS1_ACCEPT				 246
#define SSL_F_DTLS1_ADD_CERT_TO_BUF			 295
#define SSL_F_DTLS1_BUFFER_RECORD			 247
#define SSL_F_DTLS1_CHECK_TIMEOUT_NUM			 316
#define SSL_F_DTLS1_CLIENT_HELLO			 248
#define SSL_F_DTLS1_CONNECT				 249
#define SSL_F_DTLS1_ENC					 250
#define SSL_F_DTLS1_GET_HELLO_VERIFY			 251
#define SSL_F_DTLS1_GET_MESSAGE				 252
#define SSL_F_DTLS1_GET_MESSAGE_FRAGMENT		 253
#define SSL_F_DTLS1_GET_RECORD				 254
#define SSL_F_DTLS1_HANDLE_TIMEOUT			 297
#define SSL_F_DTLS1_HEARTBEAT				 305
#define SSL_F_DTLS1_OUTPUT_CERT_CHAIN			 255
#define SSL_F_DTLS1_PREPROCESS_FRAGMENT			 288
#define SSL_F_DTLS1_PROCESS_OUT_OF_SEQ_MESSAGE		 256
#define SSL_F_DTLS1_PROCESS_RECORD			 257
#define SSL_F_DTLS1_READ_BYTES				 258
#define SSL_F_DTLS1_READ_FAILED				 259
#define SSL_F_DTLS1_SEND_CERTIFICATE_REQUEST		 260
#define SSL_F_DTLS1_SEND_CLIENT_CERTIFICATE		 261
#define SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE		 262
#define SSL_F_DTLS1_SEND_CLIENT_VERIFY			 263
#define SSL_F_DTLS1_SEND_HELLO_VERIFY_REQUEST		 264
#define SSL_F_DTLS1_SEND_SERVER_CERTIFICATE		 265
#define SSL_F_DTLS1_SEND_SERVER_HELLO			 266
#define SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE		 267
#define SSL_F_DTLS1_WRITE_APP_DATA_BYTES		 268
#define SSL_F_GET_CLIENT_FINISHED			 105
#define SSL_F_GET_CLIENT_HELLO				 106
#define SSL_F_GET_CLIENT_MASTER_KEY			 107
#define SSL_F_GET_SERVER_FINISHED			 108
#define SSL_F_GET_SERVER_HELLO				 109
#define SSL_F_GET_SERVER_VERIFY				 110
#define SSL_F_I2D_SSL_SESSION				 111
#define SSL_F_READ_N					 112
#define SSL_F_REQUEST_CERTIFICATE			 113
#define SSL_F_SERVER_FINISH				 239
#define SSL_F_SERVER_HELLO				 114
#define SSL_F_SERVER_VERIFY				 240
#define SSL_F_SSL23_ACCEPT				 115
#define SSL_F_SSL23_CLIENT_HELLO			 116
#define SSL_F_SSL23_CONNECT				 117
#define SSL_F_SSL23_GET_CLIENT_HELLO			 118
#define SSL_F_SSL23_GET_SERVER_HELLO			 119
#define SSL_F_SSL23_PEEK				 237
#define SSL_F_SSL23_READ				 120
#define SSL_F_SSL23_WRITE				 121
#define SSL_F_SSL2_ACCEPT				 122
#define SSL_F_SSL2_CONNECT				 123
#define SSL_F_SSL2_ENC_INIT				 124
#define SSL_F_SSL2_GENERATE_KEY_MATERIAL		 241
#define SSL_F_SSL2_PEEK					 234
#define SSL_F_SSL2_READ					 125
#define SSL_F_SSL2_READ_INTERNAL			 236
#define SSL_F_SSL2_SET_CERTIFICATE			 126
#define SSL_F_SSL2_WRITE				 127
#define SSL_F_SSL3_ACCEPT				 128
#define SSL_F_SSL3_ADD_CERT_TO_BUF			 296
#define SSL_F_SSL3_CALLBACK_CTRL			 233
#define SSL_F_SSL3_CHANGE_CIPHER_STATE			 129
#define SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM		 130
#define SSL_F_SSL3_CHECK_CLIENT_HELLO			 304
#define SSL_F_SSL3_CLIENT_HELLO				 131
#define SSL_F_SSL3_CONNECT				 132
#define SSL_F_SSL3_CTRL					 213
#define SSL_F_SSL3_CTX_CTRL				 133
#define SSL_F_SSL3_DIGEST_CACHED_RECORDS		 293
#define SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC		 292
#define SSL_F_SSL3_ENC					 134
#define SSL_F_SSL3_GENERATE_KEY_BLOCK			 238
#define SSL_F_SSL3_GET_CERTIFICATE_REQUEST		 135
#define SSL_F_SSL3_GET_CERT_STATUS			 289
#define SSL_F_SSL3_GET_CERT_VERIFY			 136
#define SSL_F_SSL3_GET_CLIENT_CERTIFICATE		 137
#define SSL_F_SSL3_GET_CLIENT_HELLO			 138
#define SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE		 139
#define SSL_F_SSL3_GET_FINISHED				 140
#define SSL_F_SSL3_GET_KEY_EXCHANGE			 141
#define SSL_F_SSL3_GET_MESSAGE				 142
#define SSL_F_SSL3_GET_NEW_SESSION_TICKET		 283
#define SSL_F_SSL3_GET_NEXT_PROTO			 306
#define SSL_F_SSL3_GET_RECORD				 143
#define SSL_F_SSL3_GET_SERVER_CERTIFICATE		 144
#define SSL_F_SSL3_GET_SERVER_DONE			 145
#define SSL_F_SSL3_GET_SERVER_HELLO			 146
#define SSL_F_SSL3_HANDSHAKE_MAC			 285
#define SSL_F_SSL3_NEW_SESSION_TICKET			 287
#define SSL_F_SSL3_OUTPUT_CERT_CHAIN			 147
#define SSL_F_SSL3_PEEK					 235
#define SSL_F_SSL3_READ_BYTES				 148
#define SSL_F_SSL3_READ_N				 149
#define SSL_F_SSL3_SEND_CERTIFICATE_REQUEST		 150
#define SSL_F_SSL3_SEND_CLIENT_CERTIFICATE		 151
#define SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE		 152
#define SSL_F_SSL3_SEND_CLIENT_VERIFY			 153
#define SSL_F_SSL3_SEND_SERVER_CERTIFICATE		 154
#define SSL_F_SSL3_SEND_SERVER_HELLO			 242
#define SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE		 155
#define SSL_F_SSL3_SETUP_KEY_BLOCK			 157
#define SSL_F_SSL3_SETUP_READ_BUFFER			 156
#define SSL_F_SSL3_SETUP_WRITE_BUFFER			 291
#define SSL_F_SSL3_WRITE_BYTES				 158
#define SSL_F_SSL3_WRITE_PENDING			 159
#define SSL_F_SSL_ADD_CLIENTHELLO_RENEGOTIATE_EXT	 298
#define SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT		 277
#define SSL_F_SSL_ADD_CLIENTHELLO_USE_SRTP_EXT		 307
#define SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK	 215
#define SSL_F_SSL_ADD_FILE_CERT_SUBJECTS_TO_STACK	 216
#define SSL_F_SSL_ADD_SERVERHELLO_RENEGOTIATE_EXT	 299
#define SSL_F_SSL_ADD_SERVERHELLO_TLSEXT		 278
#define SSL_F_SSL_ADD_SERVERHELLO_USE_SRTP_EXT		 308
#define SSL_F_SSL_BAD_METHOD				 160
#define SSL_F_SSL_BYTES_TO_CIPHER_LIST			 161
#define SSL_F_SSL_CERT_DUP				 221
#define SSL_F_SSL_CERT_INST				 222
#define SSL_F_SSL_CERT_INSTANTIATE			 214
#define SSL_F_SSL_CERT_NEW				 162
#define SSL_F_SSL_CHECK_PRIVATE_KEY			 163
#define SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT		 280
#define SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG		 279
#define SSL_F_SSL_CIPHER_PROCESS_RULESTR		 230
#define SSL_F_SSL_CIPHER_STRENGTH_SORT			 231
#define SSL_F_SSL_CLEAR					 164
#define SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD		 165
#define SSL_F_SSL_CREATE_CIPHER_LIST			 166
#define SSL_F_SSL_CTRL					 232
#define SSL_F_SSL_CTX_CHECK_PRIVATE_KEY			 168
#define SSL_F_SSL_CTX_MAKE_PROFILES			 309
#define SSL_F_SSL_CTX_NEW				 169
#define SSL_F_SSL_CTX_SET_CIPHER_LIST			 269
#define SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE		 290
#define SSL_F_SSL_CTX_SET_PURPOSE			 226
#define SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT		 219
#define SSL_F_SSL_CTX_SET_SSL_VERSION			 170
#define SSL_F_SSL_CTX_SET_TRUST				 229
#define SSL_F_SSL_CTX_USE_CERTIFICATE			 171
#define SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1		 172
#define SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE	 220
#define SSL_F_SSL_CTX_USE_CERTIFICATE_FILE		 173
#define SSL_F_SSL_CTX_USE_PRIVATEKEY			 174
#define SSL_F_SSL_CTX_USE_PRIVATEKEY_ASN1		 175
#define SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE		 176
#define SSL_F_SSL_CTX_USE_PSK_IDENTITY_HINT		 272
#define SSL_F_SSL_CTX_USE_RSAPRIVATEKEY			 177
#define SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_ASN1		 178
#define SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE		 179
#define SSL_F_SSL_DO_HANDSHAKE				 180
#define SSL_F_SSL_GET_NEW_SESSION			 181
#define SSL_F_SSL_GET_PREV_SESSION			 217
#define SSL_F_SSL_GET_SERVER_SEND_CERT			 182
#define SSL_F_SSL_GET_SERVER_SEND_PKEY			 317
#define SSL_F_SSL_GET_SIGN_PKEY				 183
#define SSL_F_SSL_INIT_WBIO_BUFFER			 184
#define SSL_F_SSL_LOAD_CLIENT_CA_FILE			 185
#define SSL_F_SSL_NEW					 186
#define SSL_F_SSL_PARSE_CLIENTHELLO_RENEGOTIATE_EXT	 300
#define SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT		 302
#define SSL_F_SSL_PARSE_CLIENTHELLO_USE_SRTP_EXT	 310
#define SSL_F_SSL_PARSE_SERVERHELLO_RENEGOTIATE_EXT	 301
#define SSL_F_SSL_PARSE_SERVERHELLO_TLSEXT		 303
#define SSL_F_SSL_PARSE_SERVERHELLO_USE_SRTP_EXT	 311
#define SSL_F_SSL_PEEK					 270
#define SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT		 281
#define SSL_F_SSL_PREPARE_SERVERHELLO_TLSEXT		 282
#define SSL_F_SSL_READ					 223
#define SSL_F_SSL_RSA_PRIVATE_DECRYPT			 187
#define SSL_F_SSL_RSA_PUBLIC_ENCRYPT			 188
#define SSL_F_SSL_SESSION_NEW				 189
#define SSL_F_SSL_SESSION_PRINT_FP			 190
#define SSL_F_SSL_SESSION_SET1_ID_CONTEXT		 312
#define SSL_F_SSL_SESS_CERT_NEW				 225
#define SSL_F_SSL_SET_CERT				 191
#define SSL_F_SSL_SET_CIPHER_LIST			 271
#define SSL_F_SSL_SET_FD				 192
#define SSL_F_SSL_SET_PKEY				 193
#define SSL_F_SSL_SET_PURPOSE				 227
#define SSL_F_SSL_SET_RFD				 194
#define SSL_F_SSL_SET_SESSION				 195
#define SSL_F_SSL_SET_SESSION_ID_CONTEXT		 218
#define SSL_F_SSL_SET_SESSION_TICKET_EXT		 294
#define SSL_F_SSL_SET_TRUST				 228
#define SSL_F_SSL_SET_WFD				 196
#define SSL_F_SSL_SHUTDOWN				 224
#define SSL_F_SSL_SRP_CTX_INIT				 313
#define SSL_F_SSL_UNDEFINED_CONST_FUNCTION		 243
#define SSL_F_SSL_UNDEFINED_FUNCTION			 197
#define SSL_F_SSL_UNDEFINED_VOID_FUNCTION		 244
#define SSL_F_SSL_USE_CERTIFICATE			 198
#define SSL_F_SSL_USE_CERTIFICATE_ASN1			 199
#define SSL_F_SSL_USE_CERTIFICATE_FILE			 200
#define SSL_F_SSL_USE_PRIVATEKEY			 201
#define SSL_F_SSL_USE_PRIVATEKEY_ASN1			 202
#define SSL_F_SSL_USE_PRIVATEKEY_FILE			 203
#define SSL_F_SSL_USE_PSK_IDENTITY_HINT			 273
#define SSL_F_SSL_USE_RSAPRIVATEKEY			 204
#define SSL_F_SSL_USE_RSAPRIVATEKEY_ASN1		 205
#define SSL_F_SSL_USE_RSAPRIVATEKEY_FILE		 206
#define SSL_F_SSL_VERIFY_CERT_CHAIN			 207
#define SSL_F_SSL_WRITE					 208
#define SSL_F_TLS1_AEAD_CTX_INIT			 339
#define SSL_F_TLS1_CERT_VERIFY_MAC			 286
#define SSL_F_TLS1_CHANGE_CIPHER_STATE			 209
#define SSL_F_TLS1_CHANGE_CIPHER_STATE_AEAD		 340
#define SSL_F_TLS1_CHANGE_CIPHER_STATE_CIPHER		 338
#define SSL_F_TLS1_CHECK_SERVERHELLO_TLSEXT		 274
#define SSL_F_TLS1_ENC					 210
#define SSL_F_TLS1_EXPORT_KEYING_MATERIAL		 314
#define SSL_F_TLS1_HEARTBEAT				 315
#define SSL_F_TLS1_PREPARE_CLIENTHELLO_TLSEXT		 275
#define SSL_F_TLS1_PREPARE_SERVERHELLO_TLSEXT		 276
#define SSL_F_TLS1_PRF					 284
#define SSL_F_TLS1_SETUP_KEY_BLOCK			 211
#define SSL_F_WRITE_PENDING				 212

/* Reason codes. */
#define SSL_R_APP_DATA_IN_HANDSHAKE			 100
#define SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT 272
#define SSL_R_BAD_ALERT_RECORD				 101
#define SSL_R_BAD_AUTHENTICATION_TYPE			 102
#define SSL_R_BAD_CHANGE_CIPHER_SPEC			 103
#define SSL_R_BAD_CHECKSUM				 104
#define SSL_R_BAD_DATA_RETURNED_BY_CALLBACK		 106
#define SSL_R_BAD_DECOMPRESSION				 107
#define SSL_R_BAD_DH_G_LENGTH				 108
#define SSL_R_BAD_DH_PUB_KEY_LENGTH			 109
#define SSL_R_BAD_DH_P_LENGTH				 110
#define SSL_R_BAD_DIGEST_LENGTH				 111
#define SSL_R_BAD_DSA_SIGNATURE				 112
#define SSL_R_BAD_ECC_CERT				 304
#define SSL_R_BAD_ECDSA_SIGNATURE			 305
#define SSL_R_BAD_ECPOINT				 306
#define SSL_R_BAD_HANDSHAKE_LENGTH			 332
#define SSL_R_BAD_HELLO_REQUEST				 105
#define SSL_R_BAD_LENGTH				 271
#define SSL_R_BAD_MAC_DECODE				 113
#define SSL_R_BAD_MAC_LENGTH				 333
#define SSL_R_BAD_MESSAGE_TYPE				 114
#define SSL_R_BAD_PACKET_LENGTH				 115
#define SSL_R_BAD_PROTOCOL_VERSION_NUMBER		 116
#define SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH		 316
#define SSL_R_BAD_RESPONSE_ARGUMENT			 117
#define SSL_R_BAD_RSA_DECRYPT				 118
#define SSL_R_BAD_RSA_ENCRYPT				 119
#define SSL_R_BAD_RSA_E_LENGTH				 120
#define SSL_R_BAD_RSA_MODULUS_LENGTH			 121
#define SSL_R_BAD_RSA_SIGNATURE				 122
#define SSL_R_BAD_SIGNATURE				 123
#define SSL_R_BAD_SRP_A_LENGTH				 347
#define SSL_R_BAD_SRP_B_LENGTH				 348
#define SSL_R_BAD_SRP_G_LENGTH				 349
#define SSL_R_BAD_SRP_N_LENGTH				 350
#define SSL_R_BAD_SRP_S_LENGTH				 351
#define SSL_R_BAD_SRTP_MKI_VALUE			 352
#define SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST		 353
#define SSL_R_BAD_SSL_FILETYPE				 124
#define SSL_R_BAD_SSL_SESSION_ID_LENGTH			 125
#define SSL_R_BAD_STATE					 126
#define SSL_R_BAD_WRITE_RETRY				 127
#define SSL_R_BIO_NOT_SET				 128
#define SSL_R_BLOCK_CIPHER_PAD_IS_WRONG			 129
#define SSL_R_BN_LIB					 130
#define SSL_R_CA_DN_LENGTH_MISMATCH			 131
#define SSL_R_CA_DN_TOO_LONG				 132
#define SSL_R_CCS_RECEIVED_EARLY			 133
#define SSL_R_CERTIFICATE_VERIFY_FAILED			 134
#define SSL_R_CERT_LENGTH_MISMATCH			 135
#define SSL_R_CHALLENGE_IS_DIFFERENT			 136
#define SSL_R_CIPHER_CODE_WRONG_LENGTH			 137
#define SSL_R_CIPHER_COMPRESSION_UNAVAILABLE		 371
#define SSL_R_CIPHER_OR_HASH_UNAVAILABLE		 138
#define SSL_R_CIPHER_TABLE_SRC_ERROR			 139
#define SSL_R_CLIENTHELLO_TLSEXT			 226
#define SSL_R_COMPRESSED_LENGTH_TOO_LONG		 140
#define SSL_R_COMPRESSION_DISABLED			 343
#define SSL_R_COMPRESSION_FAILURE			 141
#define SSL_R_COMPRESSION_ID_NOT_WITHIN_PRIVATE_RANGE	 307
#define SSL_R_COMPRESSION_LIBRARY_ERROR			 142
#define SSL_R_CONNECTION_ID_IS_DIFFERENT		 143
#define SSL_R_CONNECTION_TYPE_NOT_SET			 144
#define SSL_R_COOKIE_MISMATCH				 308
#define SSL_R_DATA_BETWEEN_CCS_AND_FINISHED		 145
#define SSL_R_DATA_LENGTH_TOO_LONG			 146
#define SSL_R_DECRYPTION_FAILED				 147
#define SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC	 281
#define SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG		 148
#define SSL_R_DIGEST_CHECK_FAILED			 149
#define SSL_R_DTLS_MESSAGE_TOO_BIG			 334
#define SSL_R_DUPLICATE_COMPRESSION_ID			 309
#define SSL_R_ECC_CERT_NOT_FOR_KEY_AGREEMENT		 317
#define SSL_R_ECC_CERT_NOT_FOR_SIGNING			 318
#define SSL_R_ECC_CERT_SHOULD_HAVE_RSA_SIGNATURE	 322
#define SSL_R_ECC_CERT_SHOULD_HAVE_SHA1_SIGNATURE	 323
#define SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER		 310
#define SSL_R_EMPTY_SRTP_PROTECTION_PROFILE_LIST	 354
#define SSL_R_ENCRYPTED_LENGTH_TOO_LONG			 150
#define SSL_R_ERROR_GENERATING_TMP_RSA_KEY		 282
#define SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST		 151
#define SSL_R_EXCESSIVE_MESSAGE_SIZE			 152
#define SSL_R_EXTRA_DATA_IN_MESSAGE			 153
#define SSL_R_GOT_A_FIN_BEFORE_A_CCS			 154
#define SSL_R_GOT_NEXT_PROTO_BEFORE_A_CCS		 355
#define SSL_R_GOT_NEXT_PROTO_WITHOUT_EXTENSION		 356
#define SSL_R_HTTPS_PROXY_REQUEST			 155
#define SSL_R_HTTP_REQUEST				 156
#define SSL_R_ILLEGAL_PADDING				 283
#define SSL_R_INAPPROPRIATE_FALLBACK			 373
#define SSL_R_INCONSISTENT_COMPRESSION			 340
#define SSL_R_INVALID_CHALLENGE_LENGTH			 158
#define SSL_R_INVALID_COMMAND				 280
#define SSL_R_INVALID_COMPRESSION_ALGORITHM		 341
#define SSL_R_INVALID_PURPOSE				 278
#define SSL_R_INVALID_SRP_USERNAME			 357
#define SSL_R_INVALID_STATUS_RESPONSE			 328
#define SSL_R_INVALID_TICKET_KEYS_LENGTH		 325
#define SSL_R_INVALID_TRUST				 279
#define SSL_R_KEY_ARG_TOO_LONG				 284
#define SSL_R_KRB5					 285
#define SSL_R_KRB5_C_CC_PRINC				 286
#define SSL_R_KRB5_C_GET_CRED				 287
#define SSL_R_KRB5_C_INIT				 288
#define SSL_R_KRB5_C_MK_REQ				 289
#define SSL_R_KRB5_S_BAD_TICKET				 290
#define SSL_R_KRB5_S_INIT				 291
#define SSL_R_KRB5_S_RD_REQ				 292
#define SSL_R_KRB5_S_TKT_EXPIRED			 293
#define SSL_R_KRB5_S_TKT_NYV				 294
#define SSL_R_KRB5_S_TKT_SKEW				 295
#define SSL_R_LENGTH_MISMATCH				 159
#define SSL_R_LENGTH_TOO_SHORT				 160
#define SSL_R_LIBRARY_BUG				 274
#define SSL_R_LIBRARY_HAS_NO_CIPHERS			 161
#define SSL_R_MESSAGE_TOO_LONG				 296
#define SSL_R_MISSING_DH_DSA_CERT			 162
#define SSL_R_MISSING_DH_KEY				 163
#define SSL_R_MISSING_DH_RSA_CERT			 164
#define SSL_R_MISSING_DSA_SIGNING_CERT			 165
#define SSL_R_MISSING_EXPORT_TMP_DH_KEY			 166
#define SSL_R_MISSING_EXPORT_TMP_RSA_KEY		 167
#define SSL_R_MISSING_RSA_CERTIFICATE			 168
#define SSL_R_MISSING_RSA_ENCRYPTING_CERT		 169
#define SSL_R_MISSING_RSA_SIGNING_CERT			 170
#define SSL_R_MISSING_SRP_PARAM				 358
#define SSL_R_MISSING_TMP_DH_KEY			 171
#define SSL_R_MISSING_TMP_ECDH_KEY			 311
#define SSL_R_MISSING_TMP_RSA_KEY			 172
#define SSL_R_MISSING_TMP_RSA_PKEY			 173
#define SSL_R_MISSING_VERIFY_MESSAGE			 174
#define SSL_R_MULTIPLE_SGC_RESTARTS			 346
#define SSL_R_NON_SSLV2_INITIAL_PACKET			 175
#define SSL_R_NO_CERTIFICATES_RETURNED			 176
#define SSL_R_NO_CERTIFICATE_ASSIGNED			 177
#define SSL_R_NO_CERTIFICATE_RETURNED			 178
#define SSL_R_NO_CERTIFICATE_SET			 179
#define SSL_R_NO_CERTIFICATE_SPECIFIED			 180
#define SSL_R_NO_CIPHERS_AVAILABLE			 181
#define SSL_R_NO_CIPHERS_PASSED				 182
#define SSL_R_NO_CIPHERS_SPECIFIED			 183
#define SSL_R_NO_CIPHER_LIST				 184
#define SSL_R_NO_CIPHER_MATCH				 185
#define SSL_R_NO_CLIENT_CERT_METHOD			 331
#define SSL_R_NO_CLIENT_CERT_RECEIVED			 186
#define SSL_R_NO_COMPRESSION_SPECIFIED			 187
#define SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER		 330
#define SSL_R_NO_METHOD_SPECIFIED			 188
#define SSL_R_NO_PRIVATEKEY				 189
#define SSL_R_NO_PRIVATE_KEY_ASSIGNED			 190
#define SSL_R_NO_PROTOCOLS_AVAILABLE			 191
#define SSL_R_NO_PUBLICKEY				 192
#define SSL_R_NO_RENEGOTIATION				 339
#define SSL_R_NO_REQUIRED_DIGEST			 324
#define SSL_R_NO_SHARED_CIPHER				 193
#define SSL_R_NO_SRTP_PROFILES				 359
#define SSL_R_NO_VERIFY_CALLBACK			 194
#define SSL_R_NULL_SSL_CTX				 195
#define SSL_R_NULL_SSL_METHOD_PASSED			 196
#define SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED		 197
#define SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED 344
#define SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE		 297
#define SSL_R_PACKET_LENGTH_TOO_LONG			 198
#define SSL_R_PARSE_TLSEXT				 227
#define SSL_R_PATH_TOO_LONG				 270
#define SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE		 199
#define SSL_R_PEER_ERROR				 200
#define SSL_R_PEER_ERROR_CERTIFICATE			 201
#define SSL_R_PEER_ERROR_NO_CERTIFICATE			 202
#define SSL_R_PEER_ERROR_NO_CIPHER			 203
#define SSL_R_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE	 204
#define SSL_R_PRE_MAC_LENGTH_TOO_LONG			 205
#define SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS		 206
#define SSL_R_PROTOCOL_IS_SHUTDOWN			 207
#define SSL_R_PSK_IDENTITY_NOT_FOUND			 223
#define SSL_R_PSK_NO_CLIENT_CB				 224
#define SSL_R_PSK_NO_SERVER_CB				 225
#define SSL_R_PUBLIC_KEY_ENCRYPT_ERROR			 208
#define SSL_R_PUBLIC_KEY_IS_NOT_RSA			 209
#define SSL_R_PUBLIC_KEY_NOT_RSA			 210
#define SSL_R_READ_BIO_NOT_SET				 211
#define SSL_R_READ_TIMEOUT_EXPIRED			 312
#define SSL_R_READ_WRONG_PACKET_TYPE			 212
#define SSL_R_RECORD_LENGTH_MISMATCH			 213
#define SSL_R_RECORD_TOO_LARGE				 214
#define SSL_R_RECORD_TOO_SMALL				 298
#define SSL_R_RENEGOTIATE_EXT_TOO_LONG			 335
#define SSL_R_RENEGOTIATION_ENCODING_ERR		 336
#define SSL_R_RENEGOTIATION_MISMATCH			 337
#define SSL_R_REQUIRED_CIPHER_MISSING			 215
#define SSL_R_REQUIRED_COMPRESSSION_ALGORITHM_MISSING	 342
#define SSL_R_REUSE_CERT_LENGTH_NOT_ZERO		 216
#define SSL_R_REUSE_CERT_TYPE_NOT_ZERO			 217
#define SSL_R_REUSE_CIPHER_LIST_NOT_ZERO		 218
#define SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING		 345
#define SSL_R_SERVERHELLO_TLSEXT			 275
#define SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED		 277
#define SSL_R_SHORT_READ				 219
#define SSL_R_SIGNATURE_ALGORITHMS_ERROR		 360
#define SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE	 220
#define SSL_R_SRP_A_CALC				 361
#define SSL_R_SRTP_COULD_NOT_ALLOCATE_PROFILES		 362
#define SSL_R_SRTP_PROTECTION_PROFILE_LIST_TOO_LONG	 363
#define SSL_R_SRTP_UNKNOWN_PROTECTION_PROFILE		 364
#define SSL_R_SSL23_DOING_SESSION_ID_REUSE		 221
#define SSL_R_SSL2_CONNECTION_ID_TOO_LONG		 299
#define SSL_R_SSL3_EXT_INVALID_ECPOINTFORMAT		 321
#define SSL_R_SSL3_EXT_INVALID_SERVERNAME		 319
#define SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE		 320
#define SSL_R_SSL3_SESSION_ID_TOO_LONG			 300
#define SSL_R_SSL3_SESSION_ID_TOO_SHORT			 222
#define SSL_R_SSLV3_ALERT_BAD_CERTIFICATE		 1042
#define SSL_R_SSLV3_ALERT_BAD_RECORD_MAC		 1020
#define SSL_R_SSLV3_ALERT_CERTIFICATE_EXPIRED		 1045
#define SSL_R_SSLV3_ALERT_CERTIFICATE_REVOKED		 1044
#define SSL_R_SSLV3_ALERT_CERTIFICATE_UNKNOWN		 1046
#define SSL_R_SSLV3_ALERT_DECOMPRESSION_FAILURE		 1030
#define SSL_R_SSLV3_ALERT_HANDSHAKE_FAILURE		 1040
#define SSL_R_SSLV3_ALERT_ILLEGAL_PARAMETER		 1047
#define SSL_R_SSLV3_ALERT_NO_CERTIFICATE		 1041
#define SSL_R_SSLV3_ALERT_UNEXPECTED_MESSAGE		 1010
#define SSL_R_SSLV3_ALERT_UNSUPPORTED_CERTIFICATE	 1043
#define SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION	 228
#define SSL_R_SSL_HANDSHAKE_FAILURE			 229
#define SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS		 230
#define SSL_R_SSL_SESSION_ID_CALLBACK_FAILED		 301
#define SSL_R_SSL_SESSION_ID_CONFLICT			 302
#define SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG		 273
#define SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH		 303
#define SSL_R_SSL_SESSION_ID_IS_DIFFERENT		 231
#define SSL_R_TLSV1_ALERT_ACCESS_DENIED			 1049
#define SSL_R_TLSV1_ALERT_DECODE_ERROR			 1050
#define SSL_R_TLSV1_ALERT_DECRYPTION_FAILED		 1021
#define SSL_R_TLSV1_ALERT_DECRYPT_ERROR			 1051
#define SSL_R_TLSV1_ALERT_EXPORT_RESTRICTION		 1060
#define SSL_R_TLSV1_ALERT_INAPPROPRIATE_FALLBACK	 1086
#define SSL_R_TLSV1_ALERT_INSUFFICIENT_SECURITY		 1071
#define SSL_R_TLSV1_ALERT_INTERNAL_ERROR		 1080
#define SSL_R_TLSV1_ALERT_NO_RENEGOTIATION		 1100
#define SSL_R_TLSV1_ALERT_PROTOCOL_VERSION		 1070
#define SSL_R_TLSV1_ALERT_RECORD_OVERFLOW		 1022
#define SSL_R_TLSV1_ALERT_UNKNOWN_CA			 1048
#define SSL_R_TLSV1_ALERT_USER_CANCELLED		 1090
#define SSL_R_TLSV1_BAD_CERTIFICATE_HASH_VALUE		 1114
#define SSL_R_TLSV1_BAD_CERTIFICATE_STATUS_RESPONSE	 1113
#define SSL_R_TLSV1_CERTIFICATE_UNOBTAINABLE		 1111
#define SSL_R_TLSV1_UNRECOGNIZED_NAME			 1112
#define SSL_R_TLSV1_UNSUPPORTED_EXTENSION		 1110
#define SSL_R_TLS_CLIENT_CERT_REQ_WITH_ANON_CIPHER	 232
#define SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT		 365
#define SSL_R_TLS_HEARTBEAT_PENDING			 366
#define SSL_R_TLS_ILLEGAL_EXPORTER_LABEL		 367
#define SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST		 157
#define SSL_R_TLS_PEER_DID_NOT_RESPOND_WITH_CERTIFICATE_LIST 233
#define SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG	 234
#define SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER		 235
#define SSL_R_UNABLE_TO_DECODE_DH_CERTS			 236
#define SSL_R_UNABLE_TO_DECODE_ECDH_CERTS		 313
#define SSL_R_UNABLE_TO_EXTRACT_PUBLIC_KEY		 237
#define SSL_R_UNABLE_TO_FIND_DH_PARAMETERS		 238
#define SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS		 314
#define SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS	 239
#define SSL_R_UNABLE_TO_FIND_SSL_METHOD			 240
#define SSL_R_UNABLE_TO_LOAD_SSL2_MD5_ROUTINES		 241
#define SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES		 242
#define SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES		 243
#define SSL_R_UNEXPECTED_MESSAGE			 244
#define SSL_R_UNEXPECTED_RECORD				 245
#define SSL_R_UNINITIALIZED				 276
#define SSL_R_UNKNOWN_ALERT_TYPE			 246
#define SSL_R_UNKNOWN_CERTIFICATE_TYPE			 247
#define SSL_R_UNKNOWN_CIPHER_RETURNED			 248
#define SSL_R_UNKNOWN_CIPHER_TYPE			 249
#define SSL_R_UNKNOWN_DIGEST				 368
#define SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE			 250
#define SSL_R_UNKNOWN_PKEY_TYPE				 251
#define SSL_R_UNKNOWN_PROTOCOL				 252
#define SSL_R_UNKNOWN_REMOTE_ERROR_TYPE			 253
#define SSL_R_UNKNOWN_SSL_VERSION			 254
#define SSL_R_UNKNOWN_STATE				 255
#define SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED	 338
#define SSL_R_UNSUPPORTED_CIPHER			 256
#define SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM		 257
#define SSL_R_UNSUPPORTED_DIGEST_TYPE			 326
#define SSL_R_UNSUPPORTED_ELLIPTIC_CURVE		 315
#define SSL_R_UNSUPPORTED_PROTOCOL			 258
#define SSL_R_UNSUPPORTED_SSL_VERSION			 259
#define SSL_R_UNSUPPORTED_STATUS_TYPE			 329
#define SSL_R_USE_SRTP_NOT_NEGOTIATED			 369
#define SSL_R_WRITE_BIO_NOT_SET				 260
#define SSL_R_WRONG_CIPHER_RETURNED			 261
#define SSL_R_WRONG_CURVE				 378
#define SSL_R_WRONG_MESSAGE_TYPE			 262
#define SSL_R_WRONG_NUMBER_OF_KEY_BITS			 263
#define SSL_R_WRONG_SIGNATURE_LENGTH			 264
#define SSL_R_WRONG_SIGNATURE_SIZE			 265
#define SSL_R_WRONG_SIGNATURE_TYPE			 370
#define SSL_R_WRONG_SSL_VERSION				 266
#define SSL_R_WRONG_VERSION_NUMBER			 267
#define SSL_R_X509_LIB					 268
#define SSL_R_X509_VERIFICATION_SETUP_PROBLEMS		 269
#define SSL_R_PEER_BEHAVING_BADLY			 666

#ifdef  __cplusplus
}
#endif
#endif
@


1.133
log
@Completely remove NPN remnants.

Based on a diff from doug@@, similar diff from inoguchi@@
@
text
@d755 5
a760 1
/* NPN support function used by ALPN */
d764 2
@


1.132
log
@Remove support for the TLS padding extension.

This was added as a workaround for broken F5 TLS termination, which then
created issues talking to broken IronPorts. The size of the padding is
hardcoded so it cannot be used in any generic sense.

ok bcook@@ beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.131 2017/08/13 16:25:19 jsing Exp $ */
a754 5
void SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *s, int (*cb)(SSL *ssl,
    const unsigned char **out, unsigned int *outlen, void *arg), void *arg);
void SSL_CTX_set_next_proto_select_cb(SSL_CTX *s, int (*cb)(SSL *ssl,
    unsigned char **out, unsigned char *outlen, const unsigned char *in,
    unsigned int inlen, void *arg), void *arg);
d756 1
a759 2
void SSL_get0_next_proto_negotiated(const SSL *s, const unsigned char **data,
    unsigned *len);
@


1.131
log
@Nuke SSL_OP_CRYPTOPRO_TLSEXT_BUG.

This was a workaround for a server that needed to talk GOST to old/broken
CryptoPro clients. This has no impact on TLS clients that are using GOST.

ok bcook@@ beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.130 2017/08/10 17:18:38 jsing Exp $ */
a483 1
#define SSL_OP_TLSEXT_PADDING				0x00000010L
d522 1
a522 2
    (SSL_OP_LEGACY_SERVER_CONNECT | \
     SSL_OP_TLSEXT_PADDING)
d545 1
@


1.130
log
@Clean up the EC key/curve configuration handling.

Over the years OpenSSL grew multiple ways of being able to specify EC keys
(and/or curves) for use with ECDH and ECDHE key exchange. You could specify
a static EC key (SSL{_CTX,}_set_tmp_ecdh()), use that as a curve and
generate ephemeral keys (SSL_OP_SINGLE_ECDH_USE), provide the EC key via
a callback that was provided with insufficient information
(SSL{_CTX,}_set_tmp_ecdh_cb()) or enable automatic selection and generation
of EC keys via SSL{_CTX,}_set_ecdh_auto(). This complexity leads to
problems (like ECDHE not being enabled) and potential weird configuration
(like being able to do ECDHE without the ephemeral part...).

We no longer support ECDH and ECDHE can be disabled by removing ECDHE
ciphers from the cipher list. As such, permanently enable automatic EC
curve selection and generation, effectively disabling all of the
configuration knobs. The only exception is the
SSL{_CTX,}_set_tmp_ecdh() functions, which retain part of their previous
behaviour by configuring the curve of the given EC key as the only curve
being enabled. Everything else becomes a no-op.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.129 2017/05/07 04:22:24 beck Exp $ */
a520 6
/* Make server add server-hello extension from early version of
 * cryptopro draft, when GOST ciphersuite is negotiated.
 * Required for interoperability with CryptoPro CSP 3.x
 */
#define SSL_OP_CRYPTOPRO_TLSEXT_BUG			0x80000000L

d524 1
a524 2
     SSL_OP_TLSEXT_PADDING | \
     SSL_OP_CRYPTOPRO_TLSEXT_BUG)
d529 1
@


1.129
log
@Move state from ssl->internal to the handshake structure.
while we are at it, convert SSLerror to use a function
internally, so that we may later allocate the handshake
structure and check for it
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.128 2017/05/06 20:37:25 jsing Exp $ */
a505 2
/* If set, always create a new key when using tmp_ecdh parameters */
#define SSL_OP_SINGLE_ECDH_USE				0x00080000L
d550 1
@


1.128
log
@Provide SSL{,_CTX}_set_{min,max}_proto_version() functions.

Rides minor bump.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.127 2017/02/05 15:06:05 jsing Exp $ */
d935 6
a940 6
#define SSL_get_state(a)		SSL_state(a)
#define SSL_is_init_finished(a)		(SSL_state(a) == SSL_ST_OK)
#define SSL_in_init(a)			(SSL_state(a)&SSL_ST_INIT)
#define SSL_in_before(a)		(SSL_state(a)&SSL_ST_BEFORE)
#define SSL_in_connect_init(a)		(SSL_state(a)&SSL_ST_CONNECT)
#define SSL_in_accept_init(a)		(SSL_state(a)&SSL_ST_ACCEPT)
@


1.127
log
@Define values for SSL_CTRL_SET_GROUPS{,_LIST} and wire them up to the
SSL_{,CTX_}ctrl() functions. As crazy as it is, some software appears to
call the control functions directly rather than using the macros (or
functions) provided by the library.

Discussed with beck@@ and sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.126 2017/01/31 15:35:46 jsing Exp $ */
d1132 3
d1182 6
@


1.126
log
@Provide an SSL_OP_NO_CLIENT_RENEGOTIATION option that disallows
client-initiated renegotiation. The current default behaviour remains
unchanged.

ok beck@@ reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.125 2017/01/26 07:20:57 beck Exp $ */
d1123 3
d1181 2
a1182 13
/*
 * Preprocessor compatibility section.
 *
 * Historically, a number of APIs were implemented in OpenSSL as macros and
 * constants to 'ctrl' functions. To avoid breaking #ifdefs in consumers, this
 * section defines a number of legacy macros.
 *
 * Although using either the CTRL values or their wrapper macros in #ifdefs is
 * still supported, the CTRL values may not be passed to SSL_ctrl and
 * SSL_CTX_ctrl. Call the functions (previously wrapper macros) instead.
 */
#define SSL_CTRL_SET_CURVES doesnt_exist
#define SSL_CTRL_SET_CURVES_LIST doesnt_exist
@


1.125
log
@Limit the number of sequential empty records that we will process
before yielding, and fail if we exceed a maximum. loosely based
on what boring and openssl are doing
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.124 2017/01/26 00:29:04 jsing Exp $ */
d504 2
@


1.124
log
@Remove a sess_cert reference from a comment in the public header.

Noted by zhuk@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.123 2017/01/25 03:20:27 jsing Exp $ */
d2067 1
@


1.123
log
@Provide defines for SSL_CTRL_SET_CURVES/SSL_CTRL_SET_CURVES_LIST for things
that are conditioning on these.

From BoringSSL.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.122 2017/01/24 09:03:21 jsing Exp $ */
d452 1
a452 4
	/* This is the cert for the other end.
	 * On clients, it will be the same as sess_cert->peer_key->x509
	 * (the latter is not enough as sess_cert is not retained
	 * in the external representation of sessions, see ssl_asn1.c). */
@


1.122
log
@Add support for setting the supported EC curves via
SSL{_CTX}_set1_groups{_list}() - also provide defines for the previous
SSL{_CTX}_set1_curves{_list} names.

This also changes the default list of EC curves to be X25519, P-256 and
P-384. If you want others (such a brainpool) you need to configure this
yourself.

Inspired by parts of BoringSSL and OpenSSL.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.121 2017/01/24 02:56:17 jsing Exp $ */
d1179 14
@


1.121
log
@unifdef OPENSSL_NO_BIO - we do not support this in any form.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.120 2017/01/23 22:34:38 beck Exp $ */
d1171 13
@


1.120
log
@move default_passwd_cb and default_passwd_cb_userdata back into
the ssl_ctx from internal - these are used directly by python
and openvpn and a few other things - we have the set accessors
but the get accessors were added in 1.1 and these roll their
own caveat OPENSSL_VERSION chickenpluckery
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.119 2017/01/23 14:35:42 jsing Exp $ */
a152 1
#ifndef OPENSSL_NO_BIO
a153 1
#endif
a818 1
#ifndef OPENSSL_NO_BIO
a822 5
#else
	char *rbio; /* used by SSL_read */
	char *wbio; /* used by SSL_write */
	char *bbio;
#endif
a1181 1
#ifndef OPENSSL_NO_BIO
a1187 1
#endif
a1219 1
#ifndef OPENSSL_NO_BIO
a1222 1
#endif
a1270 1
#ifndef OPENSSL_NO_BIO
a1271 1
#endif
@


1.119
log
@Move options and mode from SSL_CTX and SSL to internal, since these can be
set and cleared via existing functions.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.118 2017/01/23 13:36:13 jsing Exp $ */
d682 11
@


1.118
log
@Split most of SSL_METHOD out into an internal variant, which is opaque.

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.117 2017/01/23 10:22:06 jsing Exp $ */
a674 3
	unsigned long options;
	unsigned long mode;

d852 1
a852 2
	unsigned long options; /* protocol behaviour */
	unsigned long mode; /* API behaviour */
d855 1
@


1.117
log
@Remove ssl_ctrl, ssl_ctx_ctrl, ssl_callback_ctrl and ssl_ctx_callback_ctrl
from SSL_METHOD, replacing usage with direct calls to the appropriate
functions.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.116 2017/01/23 08:48:44 beck Exp $ */
d399 2
a401 19
	int version;
	uint16_t min_version;
	uint16_t max_version;
	int (*ssl_new)(SSL *s);
	void (*ssl_clear)(SSL *s);
	void (*ssl_free)(SSL *s);
	int (*ssl_accept)(SSL *s);
	int (*ssl_connect)(SSL *s);
	int (*ssl_read)(SSL *s, void *buf, int len);
	int (*ssl_peek)(SSL *s, void *buf, int len);
	int (*ssl_write)(SSL *s, const void *buf, int len);
	int (*ssl_shutdown)(SSL *s);
	int (*ssl_renegotiate)(SSL *s);
	int (*ssl_renegotiate_check)(SSL *s);
	long (*ssl_get_message)(SSL *s, int st1, int stn, int mt,
	    long max, int *ok);
	int (*ssl_read_bytes)(SSL *s, int type, unsigned char *buf,
	    int len, int peek);
	int (*ssl_write_bytes)(SSL *s, int type, const void *buf_, int len);
d403 2
d407 2
a408 7
	int (*ssl_pending)(const SSL *s);
	int (*num_ciphers)(void);
	const SSL_CIPHER *(*get_cipher)(unsigned ncipher);
	const struct ssl_method_st *(*get_ssl_method)(int version);
	long (*get_timeout)(void);
	struct ssl3_enc_method *ssl3_enc; /* Extra SSLv3/TLS stuff */
	int (*ssl_version)(void);
@


1.116
log
@send state and rstate from ssl_st into internal. There are accessors
so these should not be diddled with directly
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.115 2017/01/23 08:08:06 beck Exp $ */
a419 2
	long (*ssl_ctrl)(SSL *s, int cmd, long larg, void *parg);
	long (*ssl_ctx_ctrl)(SSL_CTX *ctx, int cmd, long larg, void *parg);
a428 2
	long (*ssl_callback_ctrl)(SSL *s, int cb_id, void (*fp)(void));
	long (*ssl_ctx_callback_ctrl)(SSL_CTX *s, int cb_id, void (*fp)(void));
@


1.115
log
@move back read_hash and enc_read_ctx into ssl_st. wpa_supplicant and
other perversions touches them sickly and unnaturally.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.114 2017/01/23 06:45:30 beck Exp $ */
a847 3

	int state;	/* where we are */
	int rstate;	/* where we are when reading */
@


1.114
log
@Move a large part of ssl_st into internal, so we can see what squeals.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.113 2017/01/23 05:27:22 jsing Exp $ */
d896 8
@


1.113
log
@Move ex_data, next and prev from SSL_SESSION to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.112 2017/01/23 05:13:02 jsing Exp $ */
a830 2
	int type; /* SSL_ST_CONNECT or SSL_ST_ACCEPT */

a846 14
	/* This holds a variable that indicates what we were doing
	 * when a 0 or -1 is returned.  This is needed for
	 * non-blocking IO so we know what request needs re-doing when
	 * in SSL_accept or SSL_connect */
	int rwstate;

	/* Imagine that here's a boolean member "init" that is
	 * switched as soon as SSL_set_{accept/connect}_state
	 * is called for the first time, so that "state" and
	 * "handshake_func" are properly initialized.  But as
	 * handshake_func is == 0 until then, we use this
	 * test instead of an "init" member.
	 */

a848 7
	int new_session;/* Generate a new session or reuse an old one.
			 * NB: For servers, the 'new' session may actually be a previously
			 * cached session or even the previous session unless
			 * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is set */
	int quiet_shutdown;/* don't send shutdown packets */
	int shutdown;	/* we have shut things down, 0x01 sent, 0x02
			 * for received */
a851 9
	BUF_MEM *init_buf;	/* buffer used during init */
	void *init_msg;		/* pointer to handshake message body, set by ssl3_get_message() */
	int init_num;		/* amount read/written */
	int init_off;		/* amount read/written */

	/* used internally to point at a raw packet */
	unsigned char *packet;
	unsigned int packet_length;

a854 5
	int read_ahead;		/* Read as many input bytes as possible
				 * (for non-blocking reads) */

	int hit;		/* reusing a previous session */

a858 16
	STACK_OF(SSL_CIPHER) *cipher_list_by_id;

	/* These are the ones being used, the ones in SSL_SESSION are
	 * the ones to be 'copied' into these ones */
	int mac_flags;

	SSL_AEAD_CTX *aead_read_ctx;	/* AEAD context. If non-NULL, then
					   enc_read_ctx and read_hash are
					   ignored. */

	EVP_CIPHER_CTX *enc_read_ctx;		/* cryptographic state */
	EVP_MD_CTX *read_hash;			/* used for mac generation */

	SSL_AEAD_CTX *aead_write_ctx;	/* AEAD context. If non-NULL, then
					   enc_write_ctx and write_hash are
					   ignored. */
a859 6
	EVP_CIPHER_CTX *enc_write_ctx;		/* cryptographic state */
	EVP_MD_CTX *write_hash;			/* used for mac generation */

	/* session info */

	/* client cert? */
a876 2


a877 4
	/* set this flag to 1 and a sleep(1) is put into all SSL_read()
	 * and SSL_write() calls, good for nbio debuging :-) */
	int debug;

a878 1
	/* extra application data */
a879 4
	CRYPTO_EX_DATA ex_data;

	/* for server side, keep the list of CA_dn we can use */
	STACK_OF(X509_NAME) *client_CA;
a883 2
	long max_cert_list;
	int first_packet;
a889 5
	int servername_done;	/* no further mod of servername
				   0 : call the servername extension callback.
				   1 : prepare 2, allow last ack just after in server callback.
				   2 : don't call servername callback, no ack in server hello
				   */
a892 18
	/* Expect OCSP CertificateStatus message */
	int tlsext_status_expected;
	/* OCSP status request only */
	STACK_OF(OCSP_RESPID) *tlsext_ocsp_ids;
	X509_EXTENSIONS *tlsext_ocsp_exts;
	/* OCSP response received or to be sent */
	unsigned char *tlsext_ocsp_resp;
	int tlsext_ocsp_resplen;

	/* RFC4507 session ticket expected to be received or sent */
	int tlsext_ticket_expected;
	size_t tlsext_ecpointformatlist_length;
	uint8_t *tlsext_ecpointformatlist; /* our list */
	size_t tlsext_ellipticcurvelist_length;
	uint16_t *tlsext_ellipticcurvelist; /* our list */

	/* TLS Session Ticket extension override */
	TLS_SESSION_TICKET_EXT *tlsext_session_ticket;
a895 7

	STACK_OF(SRTP_PROTECTION_PROFILE) *srtp_profiles;	/* What we'll do */
	SRTP_PROTECTION_PROFILE *srtp_profile;			/* What's been chosen */

	int renegotiate;/* 1 if we are renegotiating.
		 	 * 2 if we are a server and are inside a handshake
	                 * (i.e. not just sending a HelloRequest) */
@


1.112
log
@Move most of the fields in SSL_CTX to internal - the ones that remain are
known to be in use.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.111 2017/01/23 04:55:27 beck Exp $ */
a498 5
	CRYPTO_EX_DATA ex_data; /* application specific data */

	/* These are used to make removal of session-ids more
	 * efficient and to implement a maximum cache size. */
	struct ssl_session_st *prev, *next;
@


1.111
log
@move the callbacks from ssl_st to internal
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.110 2017/01/23 04:15:28 jsing Exp $ */
a691 2
	/* same as above but sorted for lookup */
	STACK_OF(SSL_CIPHER) *cipher_list_by_id;
a693 13
	struct lhash_st_SSL_SESSION *sessions;
	/* Most session-ids that will be cached, default is
	 * SSL_SESSION_CACHE_MAX_SIZE_DEFAULT. 0 is unlimited. */
	unsigned long session_cache_size;
	struct ssl_session_st *session_cache_head;
	struct ssl_session_st *session_cache_tail;

	/* This can have one of 2 values, ored together,
	 * SSL_SESS_CACHE_CLIENT,
	 * SSL_SESS_CACHE_SERVER,
	 * Default is SSL_SESSION_CACHE_SERVER, which means only
	 * SSL_accept which cache SSL_SESSIONS. */
	int session_cache_mode;
a701 12
	CRYPTO_EX_DATA ex_data;

	const EVP_MD *md5;	/* For SSLv3/TLSv1 'ssl3-md5' */
	const EVP_MD *sha1;	/* For SSLv3/TLSv1 'ssl3-sha1' */

	STACK_OF(X509) *extra_certs;

	/* Default values used when no per-SSL value is defined follow */

	/* what we put in client cert requests */
	STACK_OF(X509_NAME) *client_CA;

a705 1
	long max_cert_list;
d707 1
a707 2
	struct cert_st /* CERT */ *cert;
	int read_ahead;
a713 22

	int quiet_shutdown;

	/* Maximum amount of data to send in one fragment.
	 * actual record size can be more than this due to
	 * padding and MAC overheads.
	 */
	unsigned int max_send_fragment;

#ifndef OPENSSL_NO_ENGINE
	/* Engine to pass requests for client certs to
	 */
	ENGINE *client_cert_engine;
#endif

	/* RFC 4507 session ticket keys */
	unsigned char tlsext_tick_key_name[16];
	unsigned char tlsext_tick_hmac_key[16];
	unsigned char tlsext_tick_aes_key[16];

	/* SRTP profiles we are willing to do from RFC 5764 */
	STACK_OF(SRTP_PROTECTION_PROFILE) *srtp_profiles;
@


1.110
log
@Move callback function pointers and argument pointers from SSL_CTX to
internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.109 2017/01/23 01:22:08 jsing Exp $ */
a910 4
	/* true when we are actually in SSL_accept() or SSL_connect() */
	int in_handshake;
	int (*handshake_func)(SSL *);

a945 5
	/* callback that allows applications to peek at protocol messages */
	void (*msg_callback)(int write_p, int version, int content_type,
	    const void *buf, size_t len, SSL *ssl, void *arg);
	void *msg_callback_arg;

a985 3
	/* Default generate session ID callback. */
	GEN_SESSION_CB generate_session_id;

a988 4
	int (*verify_callback)(int ok,X509_STORE_CTX *ctx); /* fail if callback returns 0 */

	void (*info_callback)(const SSL *ssl,int type,int val); /* optional informational callback */

d1015 1
a1015 4
	/* TLS extension debug callback */
	void (*tlsext_debug_cb)(SSL *s, int client_server, int type,
	    unsigned char *data, int len, void *arg);
	void *tlsext_debug_arg;
d1017 1
a1043 8

	/* TLS Session Ticket extension callback */
	tls_session_ticket_ext_cb_fn tls_session_ticket_ext_cb;
	void *tls_session_ticket_ext_cb_arg;

	/* TLS pre-shared secret session resumption */
	tls_session_secret_cb_fn tls_session_secret_cb;
	void *tls_session_secret_cb_arg;
@


1.109
log
@Move not_resumable and sess_cert from SSL_SESSION to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.108 2017/01/23 01:04:23 jsing Exp $ */
a714 13
	/* If this callback is not null, it will be called each
	 * time a session id is added to the cache.  If this function
	 * returns 1, it means that the callback will do a
	 * SSL_SESSION_free() when it has finished using it.  Otherwise,
	 * on 0, it means the callback has finished with it.
	 * If remove_session_cb is not null, it will be called when
	 * a session-id is removed from the cache.  After the call,
	 * OpenSSL will SSL_SESSION_free() it. */
	int (*new_session_cb)(struct ssl_st *ssl, SSL_SESSION *sess);
	void (*remove_session_cb)(struct ssl_ctx_st *ctx, SSL_SESSION *sess);
	SSL_SESSION *(*get_session_cb)(struct ssl_st *ssl,
	unsigned char *data, int len, int *copy);

a716 21
	/* if defined, these override the X509_verify_cert() calls */
	int (*app_verify_callback)(X509_STORE_CTX *, void *);
	void *app_verify_arg;

	/* Default password callback. */
	pem_password_cb *default_passwd_callback;

	/* Default password callback user data. */
	void *default_passwd_callback_userdata;

	/* get client cert callback */
	int (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey);

	/* cookie generate callback */
	int (*app_gen_cookie_cb)(SSL *ssl, unsigned char *cookie,
	unsigned int *cookie_len);

	/* verify cookie callback */
	int (*app_verify_cookie_cb)(SSL *ssl, unsigned char *cookie,
	unsigned int cookie_len);

a725 2
	void (*info_callback)(const SSL *ssl,int type,int val); /* used if SSL's info_callback is NULL */

a728 1

a737 5
	/* callback that allows applications to peek at protocol messages */
	void (*msg_callback)(int write_p, int version, int content_type,
	    const void *buf, size_t len, SSL *ssl, void *arg);
	void *msg_callback_arg;

a740 4
	int (*default_verify_callback)(int ok,X509_STORE_CTX *ctx); /* called 'verify_callback' in the SSL */

	/* Default generate session ID callback. */
	GEN_SESSION_CB generate_session_id;
a757 3
	/* TLS extensions servername callback */
	int (*tlsext_servername_callback)(SSL*, int *, void *);
	void *tlsext_servername_arg;
a761 8
	/* Callback to support customisation of ticket key setting */
	int (*tlsext_ticket_key_cb)(SSL *ssl, unsigned char *name,
	    unsigned char *iv, EVP_CIPHER_CTX *ectx, HMAC_CTX *hctx, int enc);

	/* certificate status request info */
	/* Callback for status request */
	int (*tlsext_status_cb)(SSL *ssl, void *arg);
	void *tlsext_status_arg;
@


1.108
log
@Remove heartbeat related fields from the SSL_CTX, which are unused
(thankfully).
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.107 2017/01/23 00:12:54 jsing Exp $ */
d467 1
d471 1
a477 8
	/* Used to indicate that session resumption is not allowed.
	 * Applications can also set this bit for a new session via
	 * not_resumable_session_cb to disable session caching and tickets. */
	int not_resumable;

	/* The cert is the certificate used to establish this connection */
	struct sess_cert_st /* SESS_CERT */ *sess_cert;

d483 1
@


1.107
log
@Move the stats struct from SSL_CTX to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.106 2017/01/22 06:36:49 jsing Exp $ */
a1137 8

	unsigned int tlsext_heartbeat;	/* Is use of the Heartbeat extension negotiated?
					   0: disabled
					   1: enabled
					   2: enabled, but not allowed to send Requests
					   */
	unsigned int tlsext_hb_pending; /* Indicates if a HeartbeatRequest is in flight */
	unsigned int tlsext_hb_seq;	/* HeartbeatRequest sequence number */
@


1.106
log
@Move ALPN and NPN fields from SSL/SSL_CTX to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.105 2017/01/22 05:14:42 beck Exp $ */
a731 19

	struct {
		int sess_connect;	/* SSL new conn - started */
		int sess_connect_renegotiate;/* SSL reneg - requested */
		int sess_connect_good;	/* SSL new conne/reneg - finished */
		int sess_accept;	/* SSL new accept - started */
		int sess_accept_renegotiate;/* SSL reneg - requested */
		int sess_accept_good;	/* SSL accept/reneg - finished */
		int sess_miss;		/* session lookup misses  */
		int sess_timeout;	/* reuse attempt on timeouted session */
		int sess_cache_full;	/* session removed due to full cache */
		int sess_hit;		/* session reuse actually done */
		int sess_cb_hit;	/* session-id that was not
					 * in the cache was
					 * passed back via the callback.  This
					 * indicates that the application is
					 * supplying session-id's from other
					 * processes - spooky :-) */
	} stats;
@


1.105
log
@Move internal parts of ssl_session_st to internal
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.104 2017/01/22 04:07:44 jsing Exp $ */
a843 42



	/* Next protocol negotiation information */
	/* (for experimental NPN extension). */

	/* For a server, this contains a callback function by which the set of
	 * advertised protocols can be provided. */
	int (*next_protos_advertised_cb)(SSL *s, const unsigned char **buf,
	    unsigned int *len, void *arg);
	void *next_protos_advertised_cb_arg;
	/* For a client, this contains a callback function that selects the
	 * next protocol from the list provided by the server. */
	int (*next_proto_select_cb)(SSL *s, unsigned char **out,
	    unsigned char *outlen, const unsigned char *in,
	    unsigned int inlen, void *arg);
	void *next_proto_select_cb_arg;

	/*
	 * ALPN information
	 * (we are in the process of transitioning from NPN to ALPN).
	 */

	/*
	 * Server callback function that allows the server to select the
	 * protocol for the connection.
	 *   out: on successful return, this must point to the raw protocol
	 *       name (without the length prefix).
	 *   outlen: on successful return, this contains the length of out.
	 *   in: points to the client's list of supported protocols in
	 *       wire-format.
	 *   inlen: the length of in.
	 */
	int (*alpn_select_cb)(SSL *s, const unsigned char **out,
	    unsigned char *outlen, const unsigned char *in, unsigned int inlen,
	    void *arg);
	void *alpn_select_cb_arg;

	/* Client list of supported protocols in wire format. */
	unsigned char *alpn_client_proto_list;
	unsigned int alpn_client_proto_list_len;

a1154 10
	/* Next protocol negotiation. For the client, this is the protocol that
	 * we sent in NextProtocol and is set when handling ServerHello
	 * extensions.
	 *
	 * For a server, this is the client's selected_protocol from
	 * NextProtocol and is set when handling the NextProtocol message,
	 * before the Finished message. */
	unsigned char *next_proto_negotiated;
	unsigned char next_proto_negotiated_len;

a1164 4

	/* Client list of supported protocols in wire format. */
	unsigned char *alpn_client_proto_list;
	unsigned int alpn_client_proto_list_len;
@


1.104
log
@Move recently added min_version/max_version from SSL and SSL_CTX to their
opaque structs.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.103 2017/01/22 03:50:45 jsing Exp $ */
a509 4
	size_t tlsext_ecpointformatlist_length;
	uint8_t *tlsext_ecpointformatlist; /* peer's list */
	size_t tlsext_ellipticcurvelist_length;
	uint16_t *tlsext_ellipticcurvelist; /* peer's list */
@


1.103
log
@Convert publically visible structs to translucent structs.

This change adds an internal opaque struct for each of the significant
publically visible structs. The opaque struct is then allocated and
attached to the publically visible struct when the appropriate *_new()
function is called, then cleared and freed as necessary.

This will allow for changes to be made to the internals of libssl, without
requiring a major bump each time the publically visible structs are
modified.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.102 2016/12/30 17:20:51 jsing Exp $ */
a699 3
	uint16_t min_version;
	uint16_t max_version;

a1012 3

	uint16_t min_version;
	uint16_t max_version;
@


1.102
log
@Add support for SSL_get_server_tmp_key().

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.101 2016/12/21 16:51:10 jsing Exp $ */
d356 1
d459 2
d519 2
d695 2
d895 2
d1009 1
d1205 1
a1216 2
#define session_ctx initial_ctx

d1236 1
@


1.101
log
@Add minimum and maximum version fields to SSL, SSL_CTX and SSL_METHOD
for future work.

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.100 2016/11/04 17:58:19 guenther Exp $ */
d1472 3
a1474 1
#define SSL_CTRL_SET_ECDH_AUTO				94
d1526 3
@


1.100
log
@Fix some linewrapping glitches

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.99 2016/11/02 10:59:25 jsing Exp $ */
d400 2
d693 3
d1006 4
@


1.99
log
@Expand another LHASH_OF macro.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.98 2016/11/02 10:55:48 jsing Exp $ */
d954 1
a954 2
void
SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *s, int (*cb)(SSL *ssl,
d1600 3
a1602 4
X509 *SSL_SESSION_get0_peer(SSL_SESSION *s);
int
SSL_SESSION_set1_id_context(SSL_SESSION *s, const unsigned char *sid_ctx,
unsigned int sid_ctx_len);
@


1.98
log
@Expand DECLARE_LHASH_OF and LHASH_OF macros.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.97 2016/11/02 10:52:30 jsing Exp $ */
d898 1
a898 1
LHASH_OF(SSL_SESSION) *SSL_CTX_sessions(SSL_CTX *ctx);
@


1.97
log
@Expand DECLARE_PEM_rw macro.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.96 2015/10/25 16:07:04 doug Exp $ */
d684 3
a686 1
DECLARE_LHASH_OF(SSL_SESSION);
d696 1
a696 1
	LHASH_OF(SSL_SESSION) *sessions;
@


1.96
log
@Sort the obsolete flags.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.95 2015/10/25 15:58:57 doug Exp $ */
d1321 6
a1326 1
DECLARE_PEM_rw(SSL_SESSION, SSL_SESSION)
@


1.95
log
@Mark SSL_OP_NO_{COMPRESSION,SSLv2,SSLv3} as obsolete.

For backward compatibility, the flags are redefined as 0.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.94 2015/09/10 17:57:50 jsing Exp $ */
d571 1
d573 1
d580 3
a589 5
#define SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER		0x0
#define SSL_OP_CISCO_ANYCONNECT				0x0
#define SSL_OP_NO_COMPRESSION				0x0
#define SSL_OP_NO_SSLv2					0x0
#define SSL_OP_NO_SSLv3					0x0
@


1.94
log
@Remove support for DTLS_BAD_VER. We do not support non-standard and
incomplete implementations just so that we can interoperate with products
from vendors who have not bothered to fix things in the last ~10 years.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.93 2015/08/27 06:21:15 doug Exp $ */
a539 2
/* Don't use compression even if supported */
#define SSL_OP_NO_COMPRESSION				0x00020000L
a552 2
#define SSL_OP_NO_SSLv2					0x01000000L
#define SSL_OP_NO_SSLv3					0x02000000L
d587 3
@


1.93
log
@Remove SSLv3 support from LibreSSL.

This is the first wave of SSLv3 removal which removes the main SSLv3
functions.  Future commits will remove the rest of the SSLv3 support.

Discussed the plan at c2k15.  Input from jsing@@, beck@@, miod@@, bcook@@,
sthen@@, naddy@@, and deraadt@@.

ok jsing@@, beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.92 2015/07/19 06:31:32 doug Exp $ */
a304 1
#define SSL_TXT_DTLS1_BAD	"DTLSv1-bad"
a536 2
/* Use Cisco's "speshul" version of DTLS_BAD_VER (as client)  */
#define SSL_OP_CISCO_ANYCONNECT				0x00008000L
d590 1
@


1.92
log
@Add TLS_method, TLS_client_method and TLS_server_method.

Use these instead of SSLv23_*method when you want to make sure TLS is
used.

By default, we disable SSLv3 but it's still possible for the user to
re-enable it.  TLS_*method does not allow SSLv3.

Both BoringSSL and (next version of) OpenSSL have these methods.
However, they have changed the implementation significantly.  We will
as well, but not right now.

Riding the libssl major bump.

ok miod@@ bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.91 2015/07/18 19:41:54 doug Exp $ */
a1677 4

const SSL_METHOD *SSLv3_method(void);		/* SSLv3 */
const SSL_METHOD *SSLv3_server_method(void);	/* SSLv3 */
const SSL_METHOD *SSLv3_client_method(void);	/* SSLv3 */
@


1.91
log
@Remove SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER workaround.

This was a hack to work around problems on IE 6 with SSLv3.

ok miod@@ bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.90 2015/07/18 01:42:26 doug Exp $ */
d1699 3
@


1.90
log
@Remove support for the SSL_OP_TLS_D5_BUG compat hack from SSLeay.

This is a 17 year old workaround from SSLeay 0.9.0b.  It was for
clients that send RSA client key exchange in TLS using SSLv3 format
(no length prefix).

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.89 2015/07/17 15:50:37 doug Exp $ */
a521 1
#define SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER		0x00000020L
a573 1
     SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER | \
d592 1
@


1.89
log
@Remove compat hack that disabled ECDHE-ECDSA on OS X.

For a few old releases, ECDHE-ECDSA was broken on OS X.  This option
cannot differentiate between working and broken OS X so it disabled
ECDHE-ECDSA support on all OS X >= 10.6.  10.8-10.8.3 were the faulty
releases but these are no longer relevant.  Tested on OS X 10.10 by jsing.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.88 2015/07/17 07:04:41 doug Exp $ */
a522 1
#define SSL_OP_TLS_D5_BUG				0x00000100L
a575 1
     SSL_OP_TLS_D5_BUG | \
d593 1
@


1.88
log
@Remove workaround for TLS padding bug from SSLeay days.

OpenSSL doesn't remember which clients were impacted and the
functionality has been broken in their stable releases for 2 years.

Based on OpenSSL commit a8e4ac6a2fe67c19672ecf0c6aeafa15801ce3a5.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.87 2015/06/20 12:29:39 jsing Exp $ */
a522 1
#define SSL_OP_SAFARI_ECDHE_ECDSA_BUG			0x00000040L
a576 1
     SSL_OP_SAFARI_ECDHE_ECDSA_BUG | \
d591 1
@


1.87
log
@Make SSL_OP_ALL readable.

ok deraadt@@ doug@@ millert@@ miod@@ sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.84 2015/06/17 06:49:27 doug Exp $ */
a524 1
#define SSL_OP_TLS_BLOCK_PADDING_BUG			0x00000200L
a579 1
     SSL_OP_TLS_BLOCK_PADDING_BUG | \
d595 1
@


1.86
log
@Keep alerts sorted by alert code.
@
text
@d575 8
a582 1
#define SSL_OP_ALL					0x80000374L
@


1.85
log
@Remove pointless comments.
@
text
@d1348 1
a1356 1
#define SSL_AD_INAPPROPRIATE_FALLBACK	TLS1_AD_INAPPROPRIATE_FALLBACK /* fatal */
@


1.84
log
@Cleanup SSL_OP_* compat flags in ssl.h.

These were recently removed and are now set to 0:

SSL_OP_NETSCAPE_CA_DN_BUG
SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG
SSL_OP_SSLEAY_080_CLIENT_DH_BUG

The code associated with these was deleted in the past at some point
and these are also now 0:

SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
SSL_OP_EPHEMERAL_RSA
SSL_OP_MICROSOFT_SESS_ID_BUG
SSL_OP_NETSCAPE_CHALLENGE_BUG
SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG

The SSL_OP_ALL macro has been updated to reflect the removals.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.83 2015/02/22 15:54:27 jsing Exp $ */
a384 1
	/* changed in 0.9.9: these four used to be portions of a single value 'algorithms' */
d534 1
a534 1
#define SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS		0x00000800L /* added in 0.9.6e */
d574 1
a574 2
/* SSL_OP_ALL: various bug workarounds that should be rather harmless.
 *             This used to be 0x000FFFFFL before 0.9.7. */
a749 2
	/* before OpenSSL 0.9.7, 'app_verify_arg' was ignored
	 * ('app_verify_callback' was called with just one argument) */
@


1.83
log
@Reluctantly add server-side support for TLS_FALLBACK_SCSV.

This allows for clients that willingly choose to perform a downgrade and
attempt to establish a second connection at a lower protocol after the
previous attempt unexpectedly failed, to be notified and have the second
connection aborted, if the server does in fact support a higher protocol.

TLS has perfectly good version negotiation and client-side fallback is
dangerous. Despite this, in order to maintain maximum compatability with
broken web servers, most mainstream browsers implement this. Furthermore,
TLS_FALLBACK_SCSV only works if both the client and server support it and
there is effectively no way to tell if this is the case, unless you control
both ends.

Unfortunately, various auditors and vulnerability scanners (including
certain online assessment websites) consider the presence of a not yet
standardised feature to be important for security, even if the clients do
not perform client-side downgrade or the server only supports current TLS
protocols.

Diff is loosely based on OpenSSL with some inspiration from BoringSSL.

Discussed with beck@@ and miod@@.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.82 2015/02/12 03:45:25 jsing Exp $ */
a519 2
#define SSL_OP_MICROSOFT_SESS_ID_BUG			0x00000001L
#define SSL_OP_NETSCAPE_CHALLENGE_BUG			0x00000002L
a521 1
#define SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG		0x00000008L
a524 1
#define SSL_OP_SSLEAY_080_CLIENT_DH_BUG			0x00000080L
a527 6
/* Hasn't done anything since OpenSSL 0.9.7h, retained for compatibility */
#define SSL_OP_MSIE_SSLV2_RSA_PADDING			0x0

/* Refers to ancient SSLREF and SSLv2, retained for compatibility */
#define SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG		0x0

d535 1
a535 5
#define SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS              0x00000800L /* added in 0.9.6e */

/* SSL_OP_ALL: various bug workarounds that should be rather harmless.
 *             This used to be 0x000FFFFFL before 0.9.7. */
#define SSL_OP_ALL					0x800003FFL
d538 1
a538 1
#define SSL_OP_NO_QUERY_MTU                 0x00001000L
d540 1
a540 1
#define SSL_OP_COOKIE_EXCHANGE              0x00002000L
d542 1
a542 1
#define SSL_OP_NO_TICKET	            0x00004000L
d544 1
a544 1
#define SSL_OP_CISCO_ANYCONNECT		    0x00008000L
a549 2
/* Permit unsafe legacy renegotiation */
#define SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION	0x00040000L
a553 3
/* Set to always use the tmp_rsa key when doing RSA operations,
 * even when this violates protocol specs */
#define SSL_OP_EPHEMERAL_RSA				0x00200000L
a568 6
/* Obsolete flags kept for compatibility. No sane code should use them. */
#define SSL_OP_PKCS1_CHECK_1				0x0
#define SSL_OP_PKCS1_CHECK_2				0x0

#define SSL_OP_NETSCAPE_CA_DN_BUG			0x20000000L
#define SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG		0x40000000L
d574 18
@


1.82
log
@unifdef -m -UOPENSSL_NO_NEXTPROTONEG - NPN is being replaced with ALPN,
however it is not likely to be removed any time soon.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.81 2015/02/07 04:17:11 jsing Exp $ */
d1366 2
a1367 1
#define SSL_AD_UNKNOWN_PSK_IDENTITY     TLS1_AD_UNKNOWN_PSK_IDENTITY /* fatal */
d2178 1
d2324 1
@


1.81
log
@Provide a SSL_CIPHER_get_by_value() function that allows a cipher to be
retrieved via its cipher suite value. A corresponding SSL_CIPHER_by_value()
function returns the cipher suite value for a given SSL_CIPHER. These
functions should mean that software does not need to resort to
put_cipher_by_char()/get_cipher_by_char() in order to locate a cipher.

Begrudgingly also provide a SSL_CIPHER_get_by_id() function that locates a
cipher via the internal cipher identifier. Unfortunately these have already
been leaked outside the library via SSL_CIPHER_by_id() and the various
SSL3_CK_* and TLS1_CK_* defines in the ssl3.h/tls1.h headers.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.80 2015/02/06 08:30:23 jsing Exp $ */
a850 1
# ifndef OPENSSL_NO_NEXTPROTONEG
a864 1
# endif
a962 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a978 1
#endif
a1196 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a1205 1
#endif
@


1.80
log
@Bring back the horrible API that is get_cipher_by_char/put_cipher_by_char.

This API was intended to be an internal only, however like many things in
OpenSSL, it is exposed externally and parts of the software ecosystem are
now using it since there is no real alternative within the public API.

ok doug@@, tedu@@ and reluctantly miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.79 2015/02/06 01:37:11 reyk Exp $ */
d1548 2
d1554 1
@


1.79
log
@Rename SSL_CTX_use_certificate_chain() to SSL_CTX_use_certificate_chain_mem().

As discussed with beck@@ jsing@@ and others
OK beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.78 2015/01/26 13:06:39 jsing Exp $ */
d421 2
@


1.78
log
@Add AEAD as a "MAC alias" so that it is possible to identify/select ciphers
that use AEAD instead of a MAC. This allows for TLSv1.2 AEAD ciphers
(effectively the only ciphers that are still considered to be secure) to be
selected using TLSv1.2+AEAD as a cipher string.

ok bcook@@ doug@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.77 2015/01/22 09:12:57 reyk Exp $ */
d1588 1
a1588 1
int	SSL_CTX_use_certificate_chain(SSL_CTX *ctx, void *buf, int len);
@


1.77
log
@Support CA verification in chroot'ed processes without direct file
access to the certificates.  SSL_CTX_load_verify_mem() is a frontend
to the new X509_STORE_load_mem() function that allows to load the CA
chain from a memory buffer that is holding the PEM-encoded files.
This function allows to handle the verification in privsep'ed code.

Adopted for LibreSSL based on older code from relayd (by pyr@@ and myself)
With feedback and OK bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.76 2014/12/14 15:30:50 jsing Exp $ */
d293 1
@


1.76
log
@Remove trailing whitespace.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.75 2014/12/10 14:58:56 jsing Exp $ */
d1758 1
@


1.75
log
@Add support for ALPN.

Based on OpenSSL and BoringSSL.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.74 2014/12/10 14:51:00 bcook Exp $ */
d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d113 1
a113 1
 * ECC cipher suite support in OpenSSL originally developed by 
d143 2
a144 2
#ifndef HEADER_SSL_H 
#define HEADER_SSL_H 
d178 10
a187 10
#define SSL_TXT_NULL_WITH_MD5		SSL2_TXT_NULL_WITH_MD5			
#define SSL_TXT_RC4_128_WITH_MD5	SSL2_TXT_RC4_128_WITH_MD5		
#define SSL_TXT_RC4_128_EXPORT40_WITH_MD5 SSL2_TXT_RC4_128_EXPORT40_WITH_MD5	
#define SSL_TXT_RC2_128_CBC_WITH_MD5	SSL2_TXT_RC2_128_CBC_WITH_MD5		
#define SSL_TXT_RC2_128_CBC_EXPORT40_WITH_MD5 SSL2_TXT_RC2_128_CBC_EXPORT40_WITH_MD5	
#define SSL_TXT_IDEA_128_CBC_WITH_MD5	SSL2_TXT_IDEA_128_CBC_WITH_MD5		
#define SSL_TXT_DES_64_CBC_WITH_MD5	SSL2_TXT_DES_64_CBC_WITH_MD5		
#define SSL_TXT_DES_64_CBC_WITH_SHA	SSL2_TXT_DES_64_CBC_WITH_SHA		
#define SSL_TXT_DES_192_EDE3_CBC_WITH_MD5 SSL2_TXT_DES_192_EDE3_CBC_WITH_MD5	
#define SSL_TXT_DES_192_EDE3_CBC_WITH_SHA SSL2_TXT_DES_192_EDE3_CBC_WITH_SHA	
d195 2
a196 2
#define SSL_TXT_KRB5_DES_64_CBC_MD5   SSL3_TXT_KRB5_DES_64_CBC_MD5       
#define SSL_TXT_KRB5_DES_192_CBC3_MD5 SSL3_TXT_KRB5_DES_192_CBC3_MD5       
d198 1
a198 1
#define SSL_TXT_KRB5_IDEA_128_CBC_MD5 SSL3_TXT_KRB5_IDEA_128_CBC_MD5 
d200 2
a201 2
#define SSL_TXT_KRB5_DES_40_CBC_SHA   SSL3_TXT_KRB5_DES_40_CBC_SHA 
#define SSL_TXT_KRB5_RC2_40_CBC_SHA   SSL3_TXT_KRB5_RC2_40_CBC_SHA 
d203 2
a204 2
#define SSL_TXT_KRB5_DES_40_CBC_MD5   SSL3_TXT_KRB5_DES_40_CBC_MD5 
#define SSL_TXT_KRB5_RC2_40_CBC_MD5   SSL3_TXT_KRB5_RC2_40_CBC_MD5 
d296 2
a297 2
#define SSL_TXT_GOST94		"GOST94" 
#define SSL_TXT_GOST89MAC		"GOST89MAC" 
d444 1
a444 1
 *	HostName [ 6 ] EXPLICIT OCTET STRING,   -- optional HostName from servername TLS extension 
d592 2
a593 2
 * cryptopro draft, when GOST ciphersuite is negotiated. 
 * Required for interoperability with CryptoPro CSP 3.x 
d1161 1
a1161 1
	int servername_done;	/* no further mod of servername 
@


1.74
log
@add stdint.h to ssl.h.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.73 2014/12/06 13:51:06 jsing Exp $ */
d864 25
a890 1

d981 9
d1222 4
@


1.73
log
@Use appropriate internal types for EC curves and formats, rather than
storing and processing in wire encoded form.

Inspired by boringssl.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.72 2014/11/18 05:33:43 miod Exp $ */
d145 2
@


1.72
log
@Update the GOST code in libssl, as contributed by Dmitry Eremin-Solenikov.

This causes a libssl major version bump as this affects the layout of some
internal-but-unfortunately-made-visible structs.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.71 2014/11/16 14:12:47 jsing Exp $ */
d503 1
a503 1
	unsigned char *tlsext_ecpointformatlist; /* peer's list */
d505 2
a506 1
	unsigned char *tlsext_ellipticcurvelist; /* peer's list */
d1146 1
a1146 1
	unsigned char *tlsext_ecpointformatlist; /* our list */
d1148 1
a1148 1
	unsigned char *tlsext_ellipticcurvelist; /* our list */
@


1.71
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.70 2014/10/31 15:34:06 jsing Exp $ */
d298 2
@


1.70
log
@Remove now unused remnants from public structs.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.69 2014/10/31 15:25:55 jsing Exp $ */
d147 3
d154 1
d156 4
a162 3
#include <openssl/crypto.h>
#include <openssl/lhash.h>
#include <openssl/buffer.h>
a163 4
#include <openssl/pem.h>
#include <openssl/hmac.h>

#include <openssl/safestack.h>
@


1.69
log
@Add support for automatic DH ephemeral keys.

This allows an SSL server to enable DHE ciphers with a single setting,
which results in an DH key being generated based on the server key length.

Partly based on OpenSSL.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.68 2014/10/15 13:57:21 jsing Exp $ */
a414 3
	/* XXX - remove get_cipher_by_char and put_cipher_by_char. */
	const SSL_CIPHER *(*get_cipher_by_char)(const unsigned char *ptr);
	int (*put_cipher_by_char)(const SSL_CIPHER *cipher, unsigned char *ptr);
@


1.68
log
@Add cipher aliases for DHE (the correct name for EDH) and ECDHE (the
correct name for EECDH). The EDH and EECDH aliases remain for backwards
compatibility.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.67 2014/10/03 13:58:18 jsing Exp $ */
d1432 2
d1458 2
d1471 2
@


1.67
log
@Add support for automatic ephemeral EC keys.

This allows an SSL server to enable ECDHE ciphers with a single setting,
which results in an EC key being generated using the first preference
shared curve.

Based on OpenSSL with inspiration from boringssl.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.66 2014/09/28 14:45:48 reyk Exp $ */
d262 2
a263 1
#define SSL_TXT_EDH		"EDH" /* same as "kEDH:-ADH" */
d267 2
a268 1
#define SSL_TXT_EECDH		"EECDH" /* same as "kEECDH:-AECDH" */
@


1.66
log
@Add a new API function SSL_CTX_use_certificate_chain() that allows to
read the PEM-encoded certificate chain from memory instead of a file.
This idea is derived from an older implementation in relayd that was
needed to use the function with a privep'ed process in a chroot.  Now
it is time to get it into LibreSSL to make the API more privsep-
friendly and to make it available for other programs and the ressl
library.

ok jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.65 2014/09/27 11:01:06 jsing Exp $ */
d1428 2
d1454 2
d1465 2
@


1.65
log
@Check that the specified curve is one of the client preferences.

Based on OpenSSL.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.64 2014/09/21 17:11:04 jsing Exp $ */
d1533 1
@


1.64
log
@Move the TLS padding extension under an SSL_OP_TLSEXT_PADDING option, which
is off by default (instead of being enabled unconditionally).

The TLS padding extension was added as a workaround for a bug in F5 SSL
terminators, however appears to trigger bugs in IronPort SMTP appliances.
Now the SSL client gets to choose which of these devices it wants to
trigger bugs in...

Ported from OpenSSL.

Discussed with many.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.63 2014/08/10 14:42:56 jsing Exp $ */
d2321 1
@


1.63
log
@Since we no longer need to support SSLv2-style cipher lists, start
unravelling the maze of function pointers and callbacks by directly
calling ssl3_{get,put}_cipher_by_char() and removing the
ssl_{get,put}_cipher_by_char macros.

Prompted by similar changes in boringssl.

ok guenther.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.62 2014/07/12 19:45:53 jsing Exp $ */
d517 1
a517 1
#define SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG		0x00000010L
d526 3
@


1.62
log
@Provide ssl_version_string() function, which uses one of those modern C
constructs (a switch statement) and returns the appropriate string defined
by SSL_TXT_* for the given version, including support for DTLSv1 and
DTLSv1-bad. Use this function in SSL_get_version() and SSL_SESSION_print().

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.61 2014/07/11 09:24:44 beck Exp $ */
d413 1
@


1.61
log
@Remove the PSK code. We don't need to drag around this
baggage.
ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.60 2014/07/10 11:58:08 jsing Exp $ */
d296 2
@


1.60
log
@Remove more compression tendrils.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.59 2014/07/10 09:26:08 jsing Exp $ */
a462 4
#ifndef OPENSSL_NO_PSK
	char *psk_identity_hint;
	char *psk_identity;
#endif
a833 8
#ifndef OPENSSL_NO_PSK
	char *psk_identity_hint;
	unsigned int (*psk_client_callback)(SSL *ssl, const char *hint,
	    char *identity, unsigned int max_identity_len, unsigned char *psk,
	    unsigned int max_psk_len);
	unsigned int (*psk_server_callback)(SSL *ssl, const char *identity,
	    unsigned char *psk, unsigned int max_psk_len);
#endif
a945 24
#ifndef OPENSSL_NO_PSK
/* the maximum length of the buffer given to callbacks containing the
 * resulting identity/psk */
#define PSK_MAX_IDENTITY_LEN 128
#define PSK_MAX_PSK_LEN 256
void SSL_CTX_set_psk_client_callback(SSL_CTX *ctx,
    unsigned int (*psk_client_callback)(SSL *ssl, const char *hint,
    char *identity, unsigned int max_identity_len, unsigned char *psk,
    unsigned int max_psk_len));
void SSL_set_psk_client_callback(SSL *ssl,
    unsigned int (*psk_client_callback)(SSL *ssl, const char *hint,
    char *identity, unsigned int max_identity_len, unsigned char *psk,
    unsigned int max_psk_len));
void SSL_CTX_set_psk_server_callback(SSL_CTX *ctx,
    unsigned int (*psk_server_callback)(SSL *ssl, const char *identity,
    unsigned char *psk, unsigned int max_psk_len));
void SSL_set_psk_server_callback(SSL *ssl,
    unsigned int (*psk_server_callback)(SSL *ssl, const char *identity,
    unsigned char *psk, unsigned int max_psk_len));
int SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *identity_hint);
int SSL_use_psk_identity_hint(SSL *s, const char *identity_hint);
const char *SSL_get_psk_identity_hint(const SSL *s);
const char *SSL_get_psk_identity(const SSL *s);
#endif
a1089 7
#ifndef OPENSSL_NO_PSK
	unsigned int (*psk_client_callback)(SSL *ssl, const char *hint,
	    char *identity, unsigned int max_identity_len, unsigned char *psk,
	    unsigned int max_psk_len);
	unsigned int (*psk_server_callback)(SSL *ssl, const char *identity,
	    unsigned char *psk, unsigned int max_psk_len);
#endif
@


1.59
log
@Put back some parts of the public SSL API that should not have been
completely decompressed.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.58 2014/07/10 08:51:15 tedu Exp $ */
a774 2
	STACK_OF(SSL_COMP) *comp_methods; /* stack of SSL_COMP, SSLv3/TLSv1 */

@


1.58
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.57 2014/07/09 11:25:42 jsing Exp $ */
d1817 7
@


1.57
log
@tedu the SSL export cipher handling - since we do not have enabled export
ciphers we no longer need the flags or code to support it.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.56 2014/06/13 13:28:53 jsing Exp $ */
a147 3
#ifndef OPENSSL_NO_COMP
#include <openssl/comp.h>
#endif
a487 2
	unsigned int compress_meth;	/* Need to lookup the method */

a679 5
#ifndef OPENSSL_NO_COMP
	COMP_METHOD *method;
#else
	char *method;
#endif
a1091 5
#ifndef OPENSSL_NO_COMP
	COMP_CTX *expand;			/* uncompress */
#else
	char *expand;
#endif
a1098 6
#ifndef OPENSSL_NO_COMP
	COMP_CTX *compress;			/* compression */
#else
	char *compress;

#endif
a1816 14

#ifndef OPENSSL_NO_COMP
const COMP_METHOD *SSL_get_current_compression(SSL *s);
const COMP_METHOD *SSL_get_current_expansion(SSL *s);
const char *SSL_COMP_get_name(const COMP_METHOD *comp);
STACK_OF(SSL_COMP) *SSL_COMP_get_compression_methods(void);
int SSL_COMP_add_compression_method(int id, COMP_METHOD *cm);
#else
const void *SSL_get_current_compression(SSL *s);
const void *SSL_get_current_expansion(SSL *s);
const char *SSL_COMP_get_name(const void *comp);
void *SSL_COMP_get_compression_methods(void);
int SSL_COMP_add_compression_method(int id, void *cm);
#endif
@


1.56
log
@Add ChaCha20-Poly1305 based ciphersuites.

Based on Adam Langley's chromium patches.

Tested by and ok sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.55 2014/06/13 11:52:03 jsing Exp $ */
a224 2
#define SSL_TXT_EXP40		"EXPORT40"
#define SSL_TXT_EXP56		"EXPORT56"
a227 1
#define SSL_TXT_FIPS		"FIPS"
@


1.55
log
@Add support for handling SSL_CIPHER_ALGORITHM2_AEAD ciphers, which are
those that use EVP_AEAD instead ov EVP_CIPHER. This means being able to
change cipher state with an EVP_AEAD and being able to encrypt/decrypt
TLS using the EVP_AEAD. This has no change on existing
non-SSL_CIPHER_ALGORITHM2_AEAD ciphers.

Based on Adam Langley's chromium patches.

Rides the recent libssl bump.

Tested by sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.54 2014/06/13 10:52:24 jsing Exp $ */
d292 1
@


1.54
log
@Add an SSL_AEAD_CTX to enable the use of EVP_AEAD with an SSL cipher.
Read and write contexts are also added to the SSL_CTX, along with
supporting code.

Based on Adam Langley's chromium diffs.

Rides the recent SSL library bump.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.53 2014/06/13 04:29:13 miod Exp $ */
d2084 1
d2086 2
a2088 1
#define SSL_F_TLS1_CHANGE_CIPHER_STATE			 209
@


1.53
log
@Remove support for the `opaque PRF input' extension, which draft has expired
7 years ago and never made it into an RFC. That code wasn't compiled in
anyway unless one would define the actual on-the-wire extension id bytes;
crank libssl major.

With help and enlightenment from Brendan MacDonell.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl.h,v 1.52 2014/06/12 15:49:31 deraadt Exp $ */
d657 2
d1098 4
d1109 4
@


1.52
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a849 5
	/* draft-rescorla-tls-opaque-prf-input-00.txt information */
	int (*tlsext_opaque_prf_input_callback)(SSL *, void *peerinput,
	    size_t len, void *arg);
	void *tlsext_opaque_prf_input_callback_arg;

a1198 4
	/* draft-rescorla-tls-opaque-prf-input-00.txt information to be used for handshakes */
	void *tlsext_opaque_prf_input;
	size_t tlsext_opaque_prf_input_len;

a1447 3
#define SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT	60
#define SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB	61
#define SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB_ARG 62
a2249 1
#define SSL_R_OPAQUE_PRF_INPUT_TOO_LONG			 327
@


1.51
log
@Factor out the part of tls1_change_cipher_state() that is specific to
switching cipher states using an EVP_CIPHER. This will facilitate the
addition of cipher state changes for EVP_AEAD. No functional change.

Based on Adam Langley's chromium patches.
@
text
@d1 1
a1 1
/* ssl/ssl.h */
@


1.50
log
@http://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=2016265dfbab162ec30718b5e7480add42598158
Don't know the full story, but it looks like a "can't do random
perfectly, so do it god awful" problem was found in 2013, and
replaced with "only do it badly if a flag is set".  New flags
(SSL_MODE_SEND_SERVERHELLO_TIME and SSL_MODE_SEND_SERVERHELLO_TIME)
were added [Ben Laurie?] to support the old scheme of "use time_t
for first 4 bytes of the random buffer".

Nothing uses these flags [ecosystem scan by sthen]

Fully discourage use of these flags in the future by removing
support & definition of them.  The buflen < 4 check is also interesting,
because no entropy would be returned.  No callers passed such small
buffers.
ok miod sthen
@
text
@d2087 1
@


1.49
log
@ECDH and ECDSA will not work overly well if there is no EC, so unifdef
OPENSSL_NO_EC.

ok tedu@@
@
text
@a613 6
/* Send the current time in the Random fields of the ClientHello and
 * ServerHello records for compatibility with hypothetical implementations
 * that require it.
 */
#define SSL_MODE_SEND_CLIENTHELLO_TIME 0x00000020L
#define SSL_MODE_SEND_SERVERHELLO_TIME 0x00000040L
@


1.48
log
@TLS would not be entirely functional without extensions, so unifdef
OPENSSL_NO_TLSEXT.

ok tedu@@
@
text
@a507 1
#ifndef OPENSSL_NO_EC
a511 1
#endif /* OPENSSL_NO_EC */
a1204 1
#ifndef OPENSSL_NO_EC
a1208 1
#endif /* OPENSSL_NO_EC */
@


1.47
log
@remove some #if 0 code. we don't need any more reminders that we're using
a not quite appropriate data structure. ok jsing
@
text
@a506 1
#ifndef OPENSSL_NO_TLSEXT
a517 1
#endif
a841 1
#ifndef OPENSSL_NO_TLSEXT
a861 1
#endif
a872 1
#ifndef OPENSSL_NO_TLSEXT
a892 1
#endif
a1182 1
#ifndef OPENSSL_NO_TLSEXT
a1254 3
#else
#define session_ctx ctx
#endif /* OPENSSL_NO_TLSEXT */
a1459 1
#ifndef OPENSSL_NO_TLSEXT
a1489 1
#endif
@


1.46
log
@Everything sane has stdio, and FILE *. we don't need ifdefs for this.
ok to firebomb from tedu@@
@
text
@a829 5
#if 0
	int purpose;		/* Purpose setting */
	int trust;		/* Trust setting */
#endif

a1105 5

#if 0
	int purpose;		/* Purpose setting */
	int trust;		/* Trust setting */
#endif
@


1.45
log
@remove back compat that was already disabled back in 1998.
from Alexander Schrijver
@
text
@a1653 1
#ifndef OPENSSL_NO_FP_API
a1654 1
#endif
@


1.44
log
@Any sane platform has stdio. Stop pretending we will ever use a platform
that does not.
"fire bomb" tedu@@
@
text
@a1366 8
/* this is for backward compatibility */
#if 0 /* NEW_SSLEAY */
#define SSL_CTX_set_default_verify(a,b,c) SSL_CTX_set_verify(a,b,c)
#define SSL_set_pref_cipher(c,n)	SSL_set_cipher_list(c,n)
#define SSL_add_session(a,b)            SSL_CTX_add_session((a),(b))
#define SSL_remove_session(a,b)		SSL_CTX_remove_session((a),(b))
#define SSL_flush_sessions(a,b)		SSL_CTX_flush_sessions((a),(b))
#endif
@


1.43
log
@unidef DH, ECDH, and ECDSA. there's no purpose to a libssl without them.
ok deraadt jsing
@
text
@a1629 1
#ifndef OPENSSL_NO_STDIO
a1641 1
#endif
@


1.42
log
@The ssl_ciper_get_evp() function is currently overloaded to also return the
compression associated with the SSL session. Based on one of Adam Langley's
chromium diffs, factor out the compression handling code into a separate
ssl_cipher_get_comp() function.

Rewrite the compression handling code to avoid pointless duplication and so
that failures are actually returned to and detectable by the caller.

ok miod@@
@
text
@a1877 1
#ifndef OPENSSL_NO_DH
a1881 2
#endif
#ifndef OPENSSL_NO_ECDH
a1885 1
#endif
@


1.41
log
@Include <openssl/opensslconf.h> - currently ssl.h is relying on it being
pulled in elsewhere, even though it is makes use of the OPENSSL_NO_*
defines. While here, remove kssl.h since it is a no-op.

ok beck@@ miod@@
@
text
@d2200 1
@


1.40
log
@There are two actual uses of e_os2.h in libssl - an OPENSSL_GLOBAL (an
empty define) and an OPENSSL_EXTERN (which is defined as, well... extern).
The use of OPENSSL_EXTERN is already inconsistent since the lines above
and below just use plain old "extern". Expand the two uses of these macros
and stop including e_os2.h in libssl.

ok miod@@
@
text
@d146 2
a164 1
#include <openssl/kssl.h>
@


1.39
log
@Remove SRP and Kerberos support from libssl. These are complex protocols
all on their own and we can't effectively maintain them without using them,
which we don't. If the need arises, the code can be resurrected.
@
text
@a145 2
#include <openssl/e_os2.h>

@


1.38
log
@Nuke OPENSSL_NO_SOCK since any half sane operating system has sockets.

ok beck@@
@
text
@a468 4
#ifndef OPENSSL_NO_KRB5
	unsigned int krb5_client_princ_len;
	unsigned char krb5_client_princ[SSL_MAX_KRB5_PRINCIPAL_LENGTH];
#endif /* OPENSSL_NO_KRB5 */
a520 3
#ifndef OPENSSL_NO_SRP
	char *srp_username;
#endif
a667 36
#ifndef OPENSSL_NO_SRP

#ifndef OPENSSL_NO_SSL_INTERN

typedef struct srp_ctx_st {
	/* param for all the callbacks */
	void *SRP_cb_arg;
	/* set client Hello login callback */
	int (*TLS_ext_srp_username_callback)(SSL *, int *, void *);
	/* set SRP N/g param callback for verification */
	int (*SRP_verify_param_callback)(SSL *, void *);
	/* set SRP client passwd callback */
	char *(*SRP_give_srp_client_pwd_callback)(SSL *, void *);

	char *login;
	BIGNUM *N, *g, *s, *B, *A;
	BIGNUM *a, *b, *v;
	char *info;
	int strength;

	unsigned long srp_Mask;
} SRP_CTX;

#endif

/* see tls_srp.c */
int SSL_SRP_CTX_init(SSL *s);
int SSL_CTX_SRP_CTX_init(SSL_CTX *ctx);
int SSL_SRP_CTX_free(SSL *ctx);
int SSL_CTX_SRP_CTX_free(SSL_CTX *ctx);
int SSL_srp_server_param_with_username(SSL *s, int *ad);
int SRP_generate_server_master_secret(SSL *s, unsigned char *master_key);
int SRP_Calc_A_param(SSL *s);
int SRP_generate_client_master_secret(SSL *s, unsigned char *master_key);

#endif
a881 3
#ifndef OPENSSL_NO_SRP
	SRP_CTX srp_ctx; /* ctx for SRP authentication */
#endif
a1169 3
#ifndef OPENSSL_NO_KRB5
	KSSL_CTX *kssl_ctx;	/* Kerberos 5 context */
#endif	/* OPENSSL_NO_KRB5 */
a1280 3
#ifndef OPENSSL_NO_SRP
	SRP_CTX srp_ctx; /* ctx for SRP authentication */
#endif
a1721 18
#ifndef OPENSSL_NO_SRP
int SSL_CTX_set_srp_username(SSL_CTX *ctx, char *name);
int SSL_CTX_set_srp_password(SSL_CTX *ctx, char *password);
int SSL_CTX_set_srp_strength(SSL_CTX *ctx, int strength);
int SSL_CTX_set_srp_client_pwd_callback(SSL_CTX *ctx, char *(*cb)(SSL *, void *));
int SSL_CTX_set_srp_verify_param_callback(SSL_CTX *ctx, int (*cb)(SSL *, void *));
int SSL_CTX_set_srp_username_callback(SSL_CTX *ctx, int (*cb)(SSL *, int *, void *));
int SSL_CTX_set_srp_cb_arg(SSL_CTX *ctx, void *arg);

int SSL_set_srp_server_param(SSL *s, const BIGNUM *N, const BIGNUM *g, BIGNUM *sa, BIGNUM *v, char *info);
int SSL_set_srp_server_param_pw(SSL *s, const char *user, const char *pass, const char *grp);

BIGNUM *SSL_get_srp_g(SSL *s);
BIGNUM *SSL_get_srp_N(SSL *s);

char *SSL_get_srp_username(SSL *s);
char *SSL_get_srp_userinfo(SSL *s);
#endif
@


1.37
log
@i suck at math. b - 8 = 3, not 4. detected by Antoine Pitrou. thanks.
@
text
@a1659 1
#ifndef OPENSSL_NO_SOCK
a1662 1
#endif
@


1.36
log
@SSL_OP_ALL is supposed to be all options and workarounds that are safe,
but disabling attack mitigations is not safe. 0.9.6d contained a
workaround for an attack against CBC modes. 0.9.6e disabled it by default
because "some" implementations couldn't handle empty fragments. 12 years
have passed. Does anybody still care? Let's find out.
ok miod
@
text
@d558 1
a558 1
#define SSL_OP_ALL					0x800004FFL
@


1.35
log
@Remove ending cplusplus guard followed by starting cplusplus guard; from
Gebruiker Schoot.
@
text
@d549 5
a553 3
 * the workaround is not needed.  Unfortunately some broken SSL/TLS
 * implementations cannot handle it at all, which is why we include
 * it in SSL_OP_ALL. */
d558 1
a558 1
#define SSL_OP_ALL					0x80000BFFL
@


1.34
log
@Bring back the SSL_OP_PKCS1_CHECK_* defines (defined to zero, as they already
were), after stumbling upon code (mis)using them in the wild.
@
text
@a344 7
#ifdef __cplusplus
}
#endif

#ifdef  __cplusplus
extern "C" {
#endif
@


1.33
log
@Unifdef -UPKCS1_CHECK and remove SSL_OP_PKCS1_CHECK_[12], this is leftover
``debug'' code from a 15+ years old bugfix and the SSL_OP_PKCS1_CHECK_*
constants have had a value of zero since ages. No production code should use
them.

ok beck@@
@
text
@d602 4
@


1.32
log
@Chop off more SSLv2 tentacles and start fixing and noting y2038 issues.
APIs that pass times as longs will have to change at some point...
Bump major on both libcrypto and libssl.

ok tedu@@
@
text
@a601 8
/* These next two were never actually used for anything since SSLeay
 * zap so we have some more flags.
 */
/* The next flag deliberately changes the ciphertest, this is a check
 * for the PKCS#1 attack */
#define SSL_OP_PKCS1_CHECK_1				0x0
#define SSL_OP_PKCS1_CHECK_2				0x0

@


1.31
log
@More KNF and style consistency tweaks
@
text
@d402 1
a402 1
/* Used to hold functions for SSLv2 or SSLv3/TLSv1 functions */
a444 1
 *	Key_Arg [ 0 ] IMPLICIT	OCTET STRING,	-- the optional Key argument
a464 3
	/* only really used in SSLv2 */
	unsigned int key_arg_length;
	unsigned char key_arg[SSL_MAX_KEY_ARG_LENGTH];
d501 2
a503 2
	long timeout;
	long time;
a843 1
	const EVP_MD *rsa_md5;	/* For SSLv2 - name is 'ssl2-md5' */
d845 1
a845 1
	const EVP_MD *sha1;	/* For SSLv3/TLSv1 'ssl3->sha1' */
a1152 1
	struct ssl2_state_st *s2; /* SSLv2 variables */
d1825 3
a1827 3
const SSL_METHOD *SSLv23_method(void);		/* SSLv3 but can rollback to v2 */
const SSL_METHOD *SSLv23_server_method(void);	/* SSLv3 but can rollback to v2 */
const SSL_METHOD *SSLv23_client_method(void);	/* SSLv3 but can rollback to v2 */
@


1.30
log
@always build in RSA and DSA. ok deraadt miod
@
text
@d1731 2
a1732 3
const unsigned char
*SSL_SESSION_get_id(const SSL_SESSION *s,
unsigned int *len);
@


1.29
log
@TANSTAAFL - delete the buf freelist code. if you need a better malloc, get
a better malloc. ok beck deraadt
@
text
@a1692 1
#ifndef OPENSSL_NO_RSA
a1693 1
#endif
a1765 1
#ifndef OPENSSL_NO_RSA
a1766 1
#endif
a1961 1
#ifndef OPENSSL_NO_RSA
a1966 1
#endif
@


1.28
log
@add back SRP. i was being too greedy.
@
text
@a938 6
#ifndef OPENSSL_NO_BUF_FREELISTS
#define SSL_MAX_BUF_FREELIST_LEN_DEFAULT 32
	unsigned int freelist_max_len;
	struct ssl3_buf_freelist_st *wbuf_freelist;
	struct ssl3_buf_freelist_st *rbuf_freelist;
#endif
@


1.27
log
@disentangle SRP code from TLS
@
text
@d536 3
d688 36
d945 3
d1351 3
d1802 18
@


1.26
log
@remove ssl2 support even more completely.
in the process, always include ssl3 and tls1, we don't need config options
for them. when the time comes to expire ssl3, it will be with an ax.
checked by miod
@
text
@a535 3
#ifndef OPENSSL_NO_SRP
	char *srp_username;
#endif
a684 36
#ifndef OPENSSL_NO_SRP

#ifndef OPENSSL_NO_SSL_INTERN

typedef struct srp_ctx_st {
	/* param for all the callbacks */
	void *SRP_cb_arg;
	/* set client Hello login callback */
	int (*TLS_ext_srp_username_callback)(SSL *, int *, void *);
	/* set SRP N/g param callback for verification */
	int (*SRP_verify_param_callback)(SSL *, void *);
	/* set SRP client passwd callback */
	char *(*SRP_give_srp_client_pwd_callback)(SSL *, void *);

	char *login;
	BIGNUM *N, *g, *s, *B, *A;
	BIGNUM *a, *b, *v;
	char *info;
	int strength;

	unsigned long srp_Mask;
} SRP_CTX;

#endif

/* see tls_srp.c */
int SSL_SRP_CTX_init(SSL *s);
int SSL_CTX_SRP_CTX_init(SSL_CTX *ctx);
int SSL_SRP_CTX_free(SSL *ctx);
int SSL_CTX_SRP_CTX_free(SSL_CTX *ctx);
int SSL_srp_server_param_with_username(SSL *s, int *ad);
int SRP_generate_server_master_secret(SSL *s, unsigned char *master_key);
int SRP_Calc_A_param(SSL *s);
int SRP_generate_client_master_secret(SSL *s, unsigned char *master_key);

#endif
a905 3
#ifndef OPENSSL_NO_SRP
	SRP_CTX srp_ctx; /* ctx for SRP authentication */
#endif
a1308 3
#ifndef OPENSSL_NO_SRP
	SRP_CTX srp_ctx; /* ctx for SRP authentication */
#endif
a1756 18
#ifndef OPENSSL_NO_SRP
int SSL_CTX_set_srp_username(SSL_CTX *ctx, char *name);
int SSL_CTX_set_srp_password(SSL_CTX *ctx, char *password);
int SSL_CTX_set_srp_strength(SSL_CTX *ctx, int strength);
int SSL_CTX_set_srp_client_pwd_callback(SSL_CTX *ctx, char *(*cb)(SSL *, void *));
int SSL_CTX_set_srp_verify_param_callback(SSL_CTX *ctx, int (*cb)(SSL *, void *));
int SSL_CTX_set_srp_username_callback(SSL_CTX *ctx, int (*cb)(SSL *, int *, void *));
int SSL_CTX_set_srp_cb_arg(SSL_CTX *ctx, void *arg);

int SSL_set_srp_server_param(SSL *s, const BIGNUM *N, const BIGNUM *g, BIGNUM *sa, BIGNUM *v, char *info);
int SSL_set_srp_server_param_pw(SSL *s, const char *user, const char *pass, const char *grp);

BIGNUM *SSL_get_srp_g(SSL *s);
BIGNUM *SSL_get_srp_N(SSL *s);

char *SSL_get_srp_username(SSL *s);
char *SSL_get_srp_userinfo(SSL *s);
#endif
@


1.25
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.

There is still a huge amount of inconsistency within these headers.
@
text
@a352 4
#if (defined(OPENSSL_NO_RSA) || defined(OPENSSL_NO_MD5)) && !defined(OPENSSL_NO_SSL2)
#define OPENSSL_NO_SSL2
#endif

a1836 6

#ifndef OPENSSL_NO_SSL2
const SSL_METHOD *SSLv2_method(void);		/* SSLv2 */
const SSL_METHOD *SSLv2_server_method(void);	/* SSLv2 */
const SSL_METHOD *SSLv2_client_method(void);	/* SSLv2 */
#endif
@


1.24
log
@make OPENSSL_NO_HEARTBLEED the default and only option. ok deraadt miod
@
text
@d263 3
a265 3
#define SSL_TXT_aGOST94	"aGOST94"
#define SSL_TXT_aGOST01 "aGOST01"
#define SSL_TXT_aGOST  "aGOST"
d372 4
a375 5
typedef struct srtp_protection_profile_st
       {
       const char *name;
       unsigned long id;
       } SRTP_PROTECTION_PROFILE;
d379 4
a382 3
typedef int (*tls_session_ticket_ext_cb_fn)(SSL *s, const unsigned char *data, int len, void *arg);
typedef int (*tls_session_secret_cb_fn)(SSL *s, void *secret, int *secret_len, STACK_OF(SSL_CIPHER) *peer_ciphers, SSL_CIPHER **cipher, void *arg);

d387 1
a387 2
struct ssl_cipher_st
	{
d403 1
a403 1
	};
d407 1
a407 2
struct ssl_method_st
	{
d414 3
a416 3
	int (*ssl_read)(SSL *s,void *buf,int len);
	int (*ssl_peek)(SSL *s,void *buf,int len);
	int (*ssl_write)(SSL *s,const void *buf,int len);
d420 4
a423 4
	long (*ssl_get_message)(SSL *s, int st1, int stn, int mt, long
		max, int *ok);
	int (*ssl_read_bytes)(SSL *s, int type, unsigned char *buf, int len, 
		int peek);
d426 2
a427 2
	long (*ssl_ctrl)(SSL *s,int cmd,long larg,void *parg);
	long (*ssl_ctx_ctrl)(SSL_CTX *ctx,int cmd,long larg,void *parg);
d429 1
a429 1
	int (*put_cipher_by_char)(const SSL_CIPHER *cipher,unsigned char *ptr);
d439 1
a439 1
	};
d466 1
a466 2
struct ssl_session_st
	{
d485 2
a486 2
        unsigned int krb5_client_princ_len;
        unsigned char krb5_client_princ[SSL_MAX_KRB5_PRINCIPAL_LENGTH];
d526 1
a526 1
	struct ssl_session_st *prev,*next;
d543 1
a543 1
	};
d684 5
a688 2
void SSL_CTX_set_msg_callback(SSL_CTX *ctx, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg));
void SSL_set_msg_callback(SSL *ssl, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg));
d696 1
a696 2
typedef struct srp_ctx_st
	{
d707 2
a708 2
	BIGNUM *N,*g,*s,*B,*A;
	BIGNUM *a,*b,*v;
d713 1
a713 1
	} SRP_CTX;
d723 1
a723 1
int SRP_generate_server_master_secret(SSL *s,unsigned char *master_key);
d725 1
a725 1
int SRP_generate_client_master_secret(SSL *s,unsigned char *master_key);
d747 1
a747 1
				unsigned int *id_len);
d753 1
a753 2
struct ssl_comp_st
	{
d761 1
a761 1
	};
d766 1
a766 2
struct ssl_ctx_st
	{
d801 2
a802 2
	int (*new_session_cb)(struct ssl_st *ssl,SSL_SESSION *sess);
	void (*remove_session_cb)(struct ssl_ctx_st *ctx,SSL_SESSION *sess);
d804 1
a804 1
		unsigned char *data,int len,int *copy);
d806 1
a806 2
	struct
		{
d823 1
a823 1
		} stats;
d842 7
a848 7
    /* cookie generate callback */
    int (*app_gen_cookie_cb)(SSL *ssl, unsigned char *cookie, 
        unsigned int *cookie_len);

    /* verify cookie callback */
    int (*app_verify_cookie_cb)(SSL *ssl, unsigned char *cookie, 
        unsigned int cookie_len);
d852 1
a852 1
	const EVP_MD *rsa_md5;/* For SSLv2 - name is 'ssl2-md5' */
d854 1
a854 1
	const EVP_MD *sha1;   /* For SSLv3/TLSv1 'ssl3->sha1' */
d878 2
a879 1
	void (*msg_callback)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg);
d920 2
a921 4
	int (*tlsext_ticket_key_cb)(SSL *ssl,
					unsigned char *name, unsigned char *iv,
					EVP_CIPHER_CTX *ectx,
 					HMAC_CTX *hctx, int enc);
d929 2
a930 1
	int (*tlsext_opaque_prf_input_callback)(SSL *, void *peerinput, size_t len, void *arg);
d936 3
a938 3
	unsigned int (*psk_client_callback)(SSL *ssl, const char *hint, char *identity,
		unsigned int max_identity_len, unsigned char *psk,
		unsigned int max_psk_len);
d940 1
a940 1
		unsigned char *psk, unsigned int max_psk_len);
d962 1
a962 1
			                 unsigned int *len, void *arg);
d967 2
a968 4
				    unsigned char *outlen,
				    const unsigned char *in,
				    unsigned int inlen,
				    void *arg);
d971 3
a973 2
        /* SRTP profiles we are willing to do from RFC 5764 */
        STACK_OF(SRTP_PROTECTION_PROFILE) *srtp_profiles;  
d975 1
a975 1
	};
d1016 21
a1036 10
void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx, int (*new_session_cb)(struct ssl_st *ssl,SSL_SESSION *sess));
int (*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx))(struct ssl_st *ssl, SSL_SESSION *sess);
void SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx, void (*remove_session_cb)(struct ssl_ctx_st *ctx,SSL_SESSION *sess));
void (*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx))(struct ssl_ctx_st *ctx, SSL_SESSION *sess);
void SSL_CTX_sess_set_get_cb(SSL_CTX *ctx, SSL_SESSION *(*get_session_cb)(struct ssl_st *ssl, unsigned char *data,int len,int *copy));
SSL_SESSION *(*SSL_CTX_sess_get_get_cb(SSL_CTX *ctx))(struct ssl_st *ssl, unsigned char *Data, int len, int *copy);
void SSL_CTX_set_info_callback(SSL_CTX *ctx, void (*cb)(const SSL *ssl,int type,int val));
void (*SSL_CTX_get_info_callback(SSL_CTX *ctx))(const SSL *ssl,int type,int val);
void SSL_CTX_set_client_cert_cb(SSL_CTX *ctx, int (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey));
int (*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx))(SSL *ssl, X509 **x509, EVP_PKEY **pkey);
d1040 6
a1045 2
void SSL_CTX_set_cookie_generate_cb(SSL_CTX *ctx, int (*app_gen_cookie_cb)(SSL *ssl, unsigned char *cookie, unsigned int *cookie_len));
void SSL_CTX_set_cookie_verify_cb(SSL_CTX *ctx, int (*app_verify_cookie_cb)(SSL *ssl, unsigned char *cookie, unsigned int cookie_len));
d1047 6
a1052 14
void SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *s,
					   int (*cb) (SSL *ssl,
						      const unsigned char **out,
						      unsigned int *outlen,
						      void *arg),
					   void *arg);
void SSL_CTX_set_next_proto_select_cb(SSL_CTX *s,
				      int (*cb) (SSL *ssl,
						 unsigned char **out,
						 unsigned char *outlen,
						 const unsigned char *in,
						 unsigned int inlen,
						 void *arg),
				      void *arg);
d1055 4
a1058 4
			  const unsigned char *in, unsigned int inlen,
			  const unsigned char *client, unsigned int client_len);
void SSL_get0_next_proto_negotiated(const SSL *s,
				    const unsigned char **data, unsigned *len);
d1070 11
a1080 11
void SSL_CTX_set_psk_client_callback(SSL_CTX *ctx, 
	unsigned int (*psk_client_callback)(SSL *ssl, const char *hint, 
		char *identity, unsigned int max_identity_len, unsigned char *psk,
		unsigned int max_psk_len));
void SSL_set_psk_client_callback(SSL *ssl, 
	unsigned int (*psk_client_callback)(SSL *ssl, const char *hint, 
		char *identity, unsigned int max_identity_len, unsigned char *psk,
		unsigned int max_psk_len));
void SSL_CTX_set_psk_server_callback(SSL_CTX *ctx, 
	unsigned int (*psk_server_callback)(SSL *ssl, const char *identity,
		unsigned char *psk, unsigned int max_psk_len));
d1082 2
a1083 2
	unsigned int (*psk_server_callback)(SSL *ssl, const char *identity,
		unsigned char *psk, unsigned int max_psk_len));
d1106 1
a1106 2
struct ssl_st
	{
d1150 3
a1152 3
	                 * NB: For servers, the 'new' session may actually be a previously
	                 * cached session or even the previous session unless
	                 * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is set */
d1160 1
a1160 1
	void *init_msg;   	/* pointer to handshake message body, set by ssl3_get_message() */
d1173 1
a1173 1
	               	 	 * (for non-blocking reads) */
d1176 2
a1177 1
	void (*msg_callback)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg);
d1195 2
a1196 1
	int mac_flags; 
d1198 1
a1198 1
	EVP_MD_CTX *read_hash;		/* used for mac generation */
d1206 1
a1206 1
	EVP_MD_CTX *write_hash;		/* used for mac generation */
d1210 2
a1211 1
	char *compress;	
d1242 1
a1242 1
	KSSL_CTX *kssl_ctx;     /* Kerberos 5 context */
d1246 3
a1248 3
	unsigned int (*psk_client_callback)(SSL *ssl, const char *hint, char *identity,
		unsigned int max_identity_len, unsigned char *psk,
		unsigned int max_psk_len);
d1250 1
a1250 1
		unsigned char *psk, unsigned int max_psk_len);
d1256 2
a1257 1
	int debug;	
d1277 1
a1277 2
					unsigned char *data, int len,
					void *arg);
d1280 5
a1284 5
	int servername_done;   /* no further mod of servername 
	                          0 : call the servername extension callback.
	                          1 : prepare 2, allow last ack just after in server callback.
	                          2 : don't call servername callback, no ack in server hello
	                       */
d1337 2
a1338 2
	STACK_OF(SRTP_PROTECTION_PROFILE) *srtp_profiles;  /* What we'll do */
	SRTP_PROTECTION_PROFILE *srtp_profile;            /* What's been chosen */
d1340 5
a1344 5
	unsigned int tlsext_heartbeat;  /* Is use of the Heartbeat extension negotiated?
	                                   0: disabled
	                                   1: enabled
	                                   2: enabled, but not allowed to send Requests
	                                 */
d1346 1
a1346 1
	unsigned int tlsext_hb_seq;     /* HeartbeatRequest sequence number */
d1352 1
a1352 1
	                 * 2 if we are a server and are inside a handshake
d1358 1
a1358 1
	};
d1368 2
a1369 2
#include <openssl/tls1.h> /* This is mostly sslv3 with a few tweaks */
#include <openssl/dtls1.h> /* Datagram TLS */
d1371 1
a1371 1
#include <openssl/srtp.h>  /* Support for the use_srtp extension */
d1424 3
a1426 3
#define SSL_ST_READ_HEADER			0xF0
#define SSL_ST_READ_BODY			0xF1
#define SSL_ST_READ_DONE			0xF2
d1653 1
a1653 1
BIO *BIO_new_ssl(SSL_CTX *ctx,int client);
d1656 1
a1656 1
int BIO_ssl_copy_session_id(BIO *to,BIO *from);
a1657 1

d1660 1
a1660 1
int	SSL_CTX_set_cipher_list(SSL_CTX *,const char *str);
d1663 1
a1663 1
long SSL_CTX_set_timeout(SSL_CTX *ctx,long t);
d1666 1
a1666 1
void SSL_CTX_set_cert_store(SSL_CTX *,X509_STORE *);
d1670 1
a1670 1
void	SSL_CTX_flush_sessions(SSL_CTX *ctx,long tm);
d1673 1
a1673 1
int	SSL_CIPHER_get_bits(const SSL_CIPHER *c,int *alg_bits);
d1681 1
a1681 1
const char  * SSL_get_cipher_list(const SSL *s,int n);
d1691 1
a1691 1
void	SSL_set_bio(SSL *s, BIO *rbio,BIO *wbio);
d1699 1
a1699 1
int	(*SSL_get_verify_callback(const SSL *s))(int,X509_STORE_CTX *);
d1701 1
a1701 1
		       int (*callback)(int ok,X509_STORE_CTX *ctx));
d1708 1
a1708 1
int	SSL_use_PrivateKey_ASN1(int pk,SSL *ssl, const unsigned char *d, long len);
d1722 1
a1722 1
					    const char *file);
d1724 1
a1724 1
					    const char *dir);
d1736 1
a1736 1
void	SSL_copy_session_id(SSL *to,const SSL *from);
d1738 3
a1740 2
int SSL_SESSION_set1_id_context(SSL_SESSION *s,const unsigned char *sid_ctx,
			       unsigned int sid_ctx_len);
d1743 3
a1745 2
const unsigned char *SSL_SESSION_get_id(const SSL_SESSION *s,
					unsigned int *len);
d1748 1
a1748 1
int	SSL_SESSION_print_fp(FILE *fp,const SSL_SESSION *ses);
d1751 1
a1751 1
int	SSL_SESSION_print(BIO *fp,const SSL_SESSION *ses);
d1754 1
a1754 1
int	i2d_SSL_SESSION(SSL_SESSION *in,unsigned char **pp);
d1757 1
a1757 1
int	SSL_CTX_remove_session(SSL_CTX *,SSL_SESSION *c);
d1761 3
a1763 3
					unsigned int id_len);
SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a,const unsigned char **pp,
			     long length);
d1773 5
a1777 5
int (*SSL_CTX_get_verify_callback(const SSL_CTX *ctx))(int,X509_STORE_CTX *);
void SSL_CTX_set_verify(SSL_CTX *ctx,int mode,
			int (*callback)(int, X509_STORE_CTX *));
void SSL_CTX_set_verify_depth(SSL_CTX *ctx,int depth);
void SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx, int (*cb)(X509_STORE_CTX *,void *), void *arg);
d1783 1
a1783 2
int SSL_CTX_use_PrivateKey_ASN1(int pk,SSL_CTX *ctx,
	const unsigned char *d, long len);
d1793 1
a1793 2
int	SSL_CTX_set_session_id_context(SSL_CTX *ctx,const unsigned char *sid_ctx,
				       unsigned int sid_ctx_len);
d1795 2
a1796 3
SSL *	SSL_new(SSL_CTX *ctx);
int	SSL_set_session_id_context(SSL *ssl,const unsigned char *sid_ctx,
				   unsigned int sid_ctx_len);
d1807 2
a1808 2
int SSL_CTX_set_srp_username(SSL_CTX *ctx,char *name);
int SSL_CTX_set_srp_password(SSL_CTX *ctx,char *password);
d1810 3
a1812 6
int SSL_CTX_set_srp_client_pwd_callback(SSL_CTX *ctx,
					char *(*cb)(SSL *,void *));
int SSL_CTX_set_srp_verify_param_callback(SSL_CTX *ctx,
					  int (*cb)(SSL *,void *));
int SSL_CTX_set_srp_username_callback(SSL_CTX *ctx,
				      int (*cb)(SSL *,int *,void *));
d1815 2
a1816 4
int SSL_set_srp_server_param(SSL *s, const BIGNUM *N, const BIGNUM *g,
			     BIGNUM *sa, BIGNUM *v, char *info);
int SSL_set_srp_server_param_pw(SSL *s, const char *user, const char *pass,
				const char *grp);
d1828 4
a1831 4
int 	SSL_read(SSL *ssl,void *buf,int num);
int 	SSL_peek(SSL *ssl,void *buf,int num);
int 	SSL_write(SSL *ssl,const void *buf,int num);
long	SSL_ctrl(SSL *ssl,int cmd, long larg, void *parg);
d1833 1
a1833 1
long	SSL_CTX_ctrl(SSL_CTX *ctx,int cmd, long larg, void *parg);
d1836 1
a1836 1
int	SSL_get_error(const SSL *s,int ret_code);
d1852 1
a1852 1
const SSL_METHOD *SSLv23_method(void);	/* SSLv3 but can rollback to v2 */
d1892 2
a1893 2
int SSL_add_client_CA(SSL *ssl,X509 *x);
int SSL_CTX_add_client_CA(SSL_CTX *ctx,X509 *x);
d1902 1
a1902 1
char *SSL_CIPHER_description(const SSL_CIPHER *,char *buf,int size);
d1919 1
a1919 1
	const char *CApath);
d1926 2
a1927 2
			   void (*cb)(const SSL *ssl,int type,int val));
void (*SSL_get_info_callback(const SSL *ssl))(const SSL *ssl,int type,int val);
d1931 1
a1931 1
void SSL_set_verify_result(SSL *ssl,long v);
d1934 2
a1935 2
int SSL_set_ex_data(SSL *ssl,int idx,void *data);
void *SSL_get_ex_data(const SSL *ssl,int idx);
d1937 1
a1937 1
	CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
d1939 5
a1943 4
int SSL_SESSION_set_ex_data(SSL_SESSION *ss,int idx,void *data);
void *SSL_SESSION_get_ex_data(const SSL_SESSION *ss,int idx);
int SSL_SESSION_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
	CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
d1945 2
a1946 2
int SSL_CTX_set_ex_data(SSL_CTX *ssl,int idx,void *data);
void *SSL_CTX_get_ex_data(const SSL_CTX *ssl,int idx);
d1948 1
a1948 1
	CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
d1981 1
a1981 1
     /* NB: the keylength is only applicable when is_export is true */
d1984 1
a1984 2
				  RSA *(*cb)(SSL *ssl,int is_export,
					     int keylength));
d1987 1
a1987 2
				  RSA *(*cb)(SSL *ssl,int is_export,
					     int keylength));
d1991 1
a1991 2
				 DH *(*dh)(SSL *ssl,int is_export,
					   int keylength));
d1993 1
a1993 2
				 DH *(*dh)(SSL *ssl,int is_export,
					   int keylength));
d1997 1
a1997 2
				 EC_KEY *(*ecdh)(SSL *ssl,int is_export,
					   int keylength));
d1999 1
a1999 2
				 EC_KEY *(*ecdh)(SSL *ssl,int is_export,
					   int keylength));
d2007 1
a2007 1
int SSL_COMP_add_compression_method(int id,COMP_METHOD *cm);
d2013 1
a2013 1
int SSL_COMP_add_compression_method(int id,void *cm);
d2019 2
a2020 2
int SSL_set_session_ticket_ext_cb(SSL *s, tls_session_ticket_ext_cb_fn cb,
				  void *arg);
d2023 2
a2024 1
int SSL_set_session_secret_cb(SSL *s, tls_session_secret_cb_fn tls_session_secret_cb, void *arg);
@


1.23
log
@Cope with the removal of openssl/symhacks.h
@
text
@a686 5
#ifndef OPENSSL_NO_HEARTBEATS
#define SSL_heartbeat(ssl) \
        SSL_ctrl((ssl),SSL_CTRL_TLS_EXT_SEND_HEARTBEAT,0,NULL)
#endif

a1592 5
#ifndef OPENSSL_NO_HEARTBEATS
#define SSL_CTRL_TLS_EXT_SEND_HEARTBEAT				85
#define SSL_CTRL_GET_TLS_EXT_HEARTBEAT_PENDING		86
#define SSL_CTRL_SET_TLS_EXT_HEARTBEAT_NO_REQUESTS	87
#endif
@


1.22
log
@Flense a variety of windows support stuff, and a strange gettimeofday function.
ok deraadt@@
@
text
@a166 1
#include <openssl/symhacks.h>
@


1.21
log
@Remove vms support stuff.
ok deraadt@@
@
text
@a735 3
#if defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_WIN32)
#define SSL_MAX_CERT_LIST_DEFAULT 1024*30 /* 30k max cert list :-) */
#else
a736 1
#endif
@


1.20
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a1734 2
#ifndef OPENSSL_SYS_VMS
#ifndef OPENSSL_SYS_MACINTOSH_CLASSIC /* XXXXX: Better scheme needed! [was: #ifndef MAC_OS_pre_X] */
d1736 1
a1736 4
					   const char *dir);
#endif
#endif

@


1.19
log
@resolve conflicts
@
text
@d496 3
d541 1
a541 1
	size_t	tlsext_ticklen;		/* Session ticket length */	
d558 1
a558 1
#define SSL_OP_MSIE_SSLV2_RSA_PADDING			0x00000040L /* no effect since 0.9.7h and 0.9.8b */
d563 3
d647 6
d918 1
a918 1
#ifndef OPENSSL_ENGINE
d942 1
d968 1
d2223 1
@


1.18
log
@OpenSSL 1.0.0f: merge
@
text
@d255 1
d279 1
d290 1
d300 2
d306 2
d366 20
d388 1
a388 1
typedef struct ssl_cipher_st
d405 1
a405 3
	} SSL_CIPHER;

DECLARE_STACK_OF(SSL_CIPHER)
a406 2
typedef int (*tls_session_ticket_ext_cb_fn)(SSL *s, const unsigned char *data, int len, void *arg);
typedef int (*tls_session_secret_cb_fn)(SSL *s, void *secret, int *secret_len, STACK_OF(SSL_CIPHER) *peer_ciphers, SSL_CIPHER **cipher, void *arg);
d409 1
a409 1
typedef struct ssl_method_st
d442 1
a442 1
	} SSL_METHOD;
d459 6
a464 3
 *	ECPointFormatList [ 7 ] OCTET STRING,     -- optional EC point format list from TLS extension
 *	PSK_identity_hint [ 8 ] EXPLICIT OCTET STRING, -- optional PSK identity hint
 *	PSK_identity [ 9 ] EXPLICIT OCTET STRING -- optional PSK identity
d469 1
a469 1
typedef struct ssl_session_st
d541 4
a544 1
	} SSL_SESSION;
d546 1
d569 1
a569 1
#define SSL_OP_ALL					0x80000FFFL
d605 2
d608 3
d613 3
a615 2
#define SSL_OP_PKCS1_CHECK_1				0x08000000L
#define SSL_OP_PKCS1_CHECK_2				0x10000000L
d676 5
d686 35
d722 1
d748 5
a752 1
typedef struct ssl_comp_st
d761 1
a761 1
	} SSL_COMP;
a929 1

d950 26
d978 2
d1032 26
d1098 2
d1144 1
a1144 3
	int new_session;/* 1 if we are to use a new session.
	                 * 2 if we are a server and are inside a handshake
	                 *   (i.e. not just sending a HelloRequest)
d1314 13
d1328 11
d1342 8
d1352 2
d1363 1
d1580 14
d1604 3
d1643 4
d1674 1
d1740 3
d1747 1
d1810 24
d1869 9
d1886 1
d1938 1
d2039 3
d2061 1
d2070 1
d2139 1
d2164 1
d2169 1
d2186 1
d2215 1
d2218 1
d2227 1
d2241 1
d2261 2
d2302 7
d2347 1
d2354 2
d2364 1
d2394 1
d2424 1
d2468 1
d2470 4
d2518 3
d2542 1
d2557 1
d2564 1
@


1.17
log
@resolve conflicts, fix local changes
@
text
@d1885 1
d2143 1
@


1.16
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d59 1
a59 54
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
d116 26
d224 1
d226 3
d233 5
a237 4
#define SSL_TXT_kFZA		"kFZA"
#define	SSL_TXT_aFZA		"aFZA"
#define SSL_TXT_eFZA		"eFZA"
#define SSL_TXT_FZA		"FZA"
d243 5
d249 6
a254 2
#define SSL_TXT_aKRB5     	"aKRB5"
#define SSL_TXT_KRB5      	"KRB5"
a255 4
#define SSL_TXT_kRSA		"kRSA"
#define SSL_TXT_kDHr		"kDHr"
#define SSL_TXT_kDHd		"kDHd"
#define SSL_TXT_kEDH		"kEDH"
d258 9
a266 1
#define	SSL_TXT_aDH		"aDH"
d269 1
a269 1
#define SSL_TXT_EDH		"EDH"
d272 7
d285 2
d288 2
d291 1
d294 4
a297 5
#define SSL_TXT_SHA		"SHA"
#define SSL_TXT_EXP		"EXP"
#define SSL_TXT_EXPORT		"EXPORT"
#define SSL_TXT_EXP40		"EXPORT40"
#define SSL_TXT_EXP56		"EXPORT56"
d301 4
a305 1
#define SSL_TXT_ECC		"ECCdraft" /* ECC ciphersuites are not yet official */
d327 7
a333 1
#define SSL_DEFAULT_CIPHER_LIST	"AES:ALL:!aNULL:!eNULL:+RC4:@@STRENGTH" /* low priority for RC4 */
d358 1
d366 8
a373 1
	unsigned long algorithms;	/* what ciphers are used */
a377 2
	unsigned long mask;		/* used for matching */
	unsigned long mask_strength;	/* also used for matching */
d382 3
d408 1
a408 1
	SSL_CIPHER *(*get_cipher_by_char)(const unsigned char *ptr);
d412 2
a413 2
	SSL_CIPHER *(*get_cipher)(unsigned ncipher);
	struct ssl_method_st *(*get_ssl_method)(int version);
d425 5
a429 5
 *	Cipher 			OCTET_STRING,	-- the 3 byte cipher ID
 *	Session_ID 		OCTET_STRING,	-- the Session ID
 *	Master_key 		OCTET_STRING,	-- the master key
 *	KRB5_principal		OCTET_STRING	-- optional Kerberos principal
 *	Key_Arg [ 0 ] IMPLICIT	OCTET_STRING,	-- the optional Key argument
d433 6
a438 3
 *	Session_ID_context [ 4 ] EXPLICIT OCTET_STRING,   -- the Session ID context
 *	Verify_result [ 5 ] EXPLICIT INTEGER    -- X509_V_... code for `Peer'
 *	Compression [6] IMPLICIT ASN1_OBJECT	-- compression OID XXXXX
d466 4
a469 1

d488 1
a488 1
	int compress_meth;		/* Need to lookup the method */
d490 1
a490 1
	SSL_CIPHER *cipher;
d504 6
d520 2
d539 1
a539 1
#define SSL_OP_ALL					0x00000FFFL
d547 2
d552 4
d582 5
a586 1

d601 4
a604 1

d611 2
d617 2
d624 2
d628 2
d637 2
d683 1
d687 1
a687 1
	SSL_METHOD *method;
d694 1
a694 1
	struct lhash_st /* LHASH */ *sessions;	/* a set of SSL_SESSIONs */
d819 6
d843 1
a843 1
					HMAC_CTX *hctx, int enc);
d849 20
a869 1

d883 1
a883 1
  struct lhash_st *SSL_CTX_sessions(SSL_CTX *ctx);
d925 25
d961 3
d972 1
a972 1
	SSL_METHOD *method; /* SSLv3 */
d1055 1
a1055 1

d1057 1
a1057 1
	const EVP_MD *read_hash;		/* used for mac generation */
d1065 1
a1065 1
	const EVP_MD *write_hash;		/* used for mac generation */
d1103 8
d1130 1
d1157 22
d1183 1
a1183 1
#endif
a1289 1
#if 1 /*SSLEAY_MACROS*/
a1291 9
#define PEM_read_SSL_SESSION(fp,x,cb,u) (SSL_SESSION *)PEM_ASN1_read( \
	(char *(*)())d2i_SSL_SESSION,PEM_STRING_SSL_SESSION,fp,(char **)x,cb,u)
#define PEM_read_bio_SSL_SESSION(bp,x,cb,u) PEM_ASN1_read_bio_of(SSL_SESSION,d2i_SSL_SESSION,PEM_STRING_SSL_SESSION,bp,x,cb,u)
#define PEM_write_SSL_SESSION(fp,x) \
	PEM_ASN1_write((int (*)())i2d_SSL_SESSION, \
		PEM_STRING_SSL_SESSION,fp, (char *)x, NULL,NULL,0,NULL,NULL)
#define PEM_write_bio_SSL_SESSION(bp,x) \
	PEM_ASN1_write_bio_of(SSL_SESSION,i2d_SSL_SESSION,PEM_STRING_SSL_SESSION,bp,x,NULL,NULL,0,NULL,NULL)
#endif
d1293 4
a1296 1
#define SSL_AD_REASON_OFFSET		1000
d1326 2
d1386 2
d1397 3
a1399 1

d1413 15
d1469 1
a1469 1
SSL_CTX *SSL_CTX_new(SSL_METHOD *meth);
d1480 1
a1480 1
SSL_CIPHER *SSL_get_current_cipher(const SSL *s);
d1551 2
a1552 3
unsigned long SSL_SESSION_hash(const SSL_SESSION *a);
int	SSL_SESSION_cmp(const SSL_SESSION *a,const SSL_SESSION *b);
const unsigned char *SSL_SESSION_get_id(const SSL_SESSION *s, unsigned int *len);
d1612 3
d1630 7
a1636 1
int SSL_CTX_set_ssl_version(SSL_CTX *ctx,SSL_METHOD *meth);
d1638 15
a1652 19
SSL_METHOD *SSLv2_method(void);		/* SSLv2 */
SSL_METHOD *SSLv2_server_method(void);	/* SSLv2 */
SSL_METHOD *SSLv2_client_method(void);	/* SSLv2 */

SSL_METHOD *SSLv3_method(void);		/* SSLv3 */
SSL_METHOD *SSLv3_server_method(void);	/* SSLv3 */
SSL_METHOD *SSLv3_client_method(void);	/* SSLv3 */

SSL_METHOD *SSLv23_method(void);	/* SSLv3 but can rollback to v2 */
SSL_METHOD *SSLv23_server_method(void);	/* SSLv3 but can rollback to v2 */
SSL_METHOD *SSLv23_client_method(void);	/* SSLv3 but can rollback to v2 */

SSL_METHOD *TLSv1_method(void);		/* TLSv1.0 */
SSL_METHOD *TLSv1_server_method(void);	/* TLSv1.0 */
SSL_METHOD *TLSv1_client_method(void);	/* TLSv1.0 */

SSL_METHOD *DTLSv1_method(void);		/* DTLSv1.0 */
SSL_METHOD *DTLSv1_server_method(void);	/* DTLSv1.0 */
SSL_METHOD *DTLSv1_client_method(void);	/* DTLSv1.0 */
d1661 2
a1662 2
SSL_METHOD *SSL_get_ssl_method(SSL *s);
int SSL_set_ssl_method(SSL *s,SSL_METHOD *method);
d1682 1
a1682 1
char *SSL_CIPHER_description(SSL_CIPHER *,char *buf,int size);
d1754 5
d1800 9
d1826 1
d1835 1
d1837 1
a1837 1
#define SSL_F_DTLS1_PREPROCESS_FRAGMENT			 277
d1881 1
d1889 2
a1890 1
#define SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC		 279
d1894 1
a1894 1
#define SSL_F_SSL3_GET_CERT_STATUS			 288
d1907 2
a1908 1
#define SSL_F_SSL3_NEW_SESSION_TICKET			 284
a1919 1
#define SSL_F_SSL3_SETUP_BUFFERS			 156
d1921 2
d1925 2
a1926 1
#define SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT		 272
d1929 2
a1930 1
#define SSL_F_SSL_ADD_SERVERHELLO_TLSEXT		 273
d1938 2
a1939 1
#define SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT		 274
d1949 1
a1949 1
#define SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE		 278
d1961 1
d1973 4
d1978 2
a1979 2
#define SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT		 275
#define SSL_F_SSL_PREPARE_SERVERHELLO_TLSEXT		 276
d1994 1
d2007 1
d2013 1
d2015 1
d2017 3
d2040 1
d2044 1
d2048 1
d2072 1
a2072 1
#define SSL_R_CLIENTHELLO_TLSEXT			 157
d2074 1
d2087 1
d2089 4
d2103 1
d2106 1
d2108 2
a2109 2
#define SSL_R_INVALID_STATUS_RESPONSE			 316
#define SSL_R_INVALID_TICKET_KEYS_LENGTH		 275
d2153 1
a2153 1
#define SSL_R_NO_CLIENT_CERT_METHOD			 317
d2156 1
d2162 2
d2169 1
d2171 1
d2173 1
a2173 1
#define SSL_R_PARSE_TLSEXT				 223
d2184 3
d2196 3
d2200 1
d2204 2
a2205 1
#define SSL_R_SERVERHELLO_TLSEXT			 224
d2211 3
a2213 2
#define SSL_R_SSL3_EXT_INVALID_SERVERNAME		 225
#define SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE		 226
d2247 5
d2253 1
a2253 1
#define SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST		 227
d2280 1
d2283 1
@


1.15
log
@resolve conflicts
@
text
@d255 1
a364 3
typedef struct ssl_st SSL;
typedef struct ssl_ctx_st SSL_CTX;

d761 6
d836 3
d1712 1
d1766 1
d1947 1
@


1.14
log
@resolve conflicts
@
text
@d112 1
a112 1
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
d164 5
d181 1
d185 7
a254 1
#define SSL_TXT_FIPS		"FIPS"
d285 1
d287 1
d299 1
d321 1
a321 1
#define SSL_DEFAULT_CIPHER_LIST	"ALL:!ADH:+RC4:@@STRENGTH" /* low priority for RC4 */
a330 5
#include <openssl/crypto.h>
#include <openssl/lhash.h>
#include <openssl/buffer.h>
#include <openssl/pem.h>

d382 6
d398 3
a400 3
	int (*ssl_version)();
	long (*ssl_callback_ctrl)(SSL *s, int cb_id, void (*fp)());
	long (*ssl_ctx_callback_ctrl)(SSL_CTX *s, int cb_id, void (*fp)());
d478 7
d509 7
d518 2
d581 2
d619 1
a619 1
	char *name;
d707 8
a746 1
	int verify_depth;
d754 3
d759 1
d762 21
d822 12
a833 10
#define SSL_CTX_sess_set_new_cb(ctx,cb)	((ctx)->new_session_cb=(cb))
#define SSL_CTX_sess_get_new_cb(ctx)	((ctx)->new_session_cb)
#define SSL_CTX_sess_set_remove_cb(ctx,cb)	((ctx)->remove_session_cb=(cb))
#define SSL_CTX_sess_get_remove_cb(ctx)	((ctx)->remove_session_cb)
#define SSL_CTX_sess_set_get_cb(ctx,cb)	((ctx)->get_session_cb=(cb))
#define SSL_CTX_sess_get_get_cb(ctx)	((ctx)->get_session_cb)
#define SSL_CTX_set_info_callback(ctx,cb)	((ctx)->info_callback=(cb))
#define SSL_CTX_get_info_callback(ctx)		((ctx)->info_callback)
#define SSL_CTX_set_client_cert_cb(ctx,cb)	((ctx)->client_cert_cb=(cb))
#define SSL_CTX_get_client_cert_cb(ctx)		((ctx)->client_cert_cb)
d849 1
a849 1
	 * (one of SSL2_VERSION, SSL3_VERSION, TLS1_VERSION)
d878 1
a878 1
	int (*handshake_func)();
d913 1
d924 3
d929 1
a973 1
	int verify_depth;
d1004 31
d1044 1
d1142 2
a1143 5
#define d2i_SSL_SESSION_bio(bp,s_id) (SSL_SESSION *)ASN1_d2i_bio( \
	(char *(*)())SSL_SESSION_new,(char *(*)())d2i_SSL_SESSION, \
	(bp),(unsigned char **)(s_id))
#define i2d_SSL_SESSION_bio(bp,s_id) ASN1_i2d_bio(i2d_SSL_SESSION, \
	bp,(unsigned char *)s_id)
d1146 1
a1146 2
#define PEM_read_bio_SSL_SESSION(bp,x,cb,u) (SSL_SESSION *)PEM_ASN1_read_bio( \
	(char *(*)())d2i_SSL_SESSION,PEM_STRING_SSL_SESSION,bp,(char **)x,cb,u)
d1151 1
a1151 2
	PEM_ASN1_write_bio((int (*)())i2d_SSL_SESSION, \
		PEM_STRING_SSL_SESSION,bp, (char *)x, NULL,NULL,0,NULL,NULL)
d1180 4
d1198 12
a1209 2
#define SSL_CTRL_SET_TMP_RSA_CB			4
#define SSL_CTRL_SET_TMP_DH_CB			5
d1211 2
a1212 10
#define SSL_CTRL_GET_SESSION_REUSED		6
#define SSL_CTRL_GET_CLIENT_CERT_REQUEST	7
#define SSL_CTRL_GET_NUM_RENEGOTIATIONS		8
#define SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS	9
#define SSL_CTRL_GET_TOTAL_RENEGOTIATIONS	10
#define SSL_CTRL_GET_FLAGS			11
#define SSL_CTRL_EXTRA_CHAIN_CERT		12

#define SSL_CTRL_SET_MSG_CALLBACK               13
#define SSL_CTRL_SET_MSG_CALLBACK_ARG           14
d1214 2
d1242 23
d1280 2
d1289 2
d1352 1
a1352 1
int	SSL_use_PrivateKey_ASN1(int pk,SSL *ssl, unsigned char *d, long len);
d1354 1
a1354 1
int	SSL_use_certificate_ASN1(SSL *ssl, unsigned char *d, int len);
d1390 1
d1406 1
a1406 1
SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a,const unsigned char * const *pp,
d1425 1
a1425 1
int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, unsigned char *d, long len);
d1428 1
a1428 1
	unsigned char *d, long len);
d1430 1
a1430 1
int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, unsigned char *d);
d1457 1
a1457 1
long	SSL_callback_ctrl(SSL *, int, void (*)());
d1459 1
a1459 1
long	SSL_CTX_callback_ctrl(SSL_CTX *, int, void (*)());
d1483 4
d1537 1
d1605 8
d1615 4
d1621 5
a1625 1
int SSL_COMP_add_compression_method(int id,char *cm);
d1638 1
a1638 1
#define SSL_F_CLIENT_FINISHED				 238
d1642 1
d1644 24
d1708 1
d1716 1
d1721 1
d1737 1
d1740 1
d1748 1
d1780 3
d1802 1
d1833 3
d1865 1
d1868 1
d1872 1
d1879 2
d1893 2
d1923 1
d1952 1
d1967 1
d1976 1
d1982 2
d2018 1
d2023 1
d2026 1
d2047 1
d2050 1
@


1.13
log
@resolve conflicts
@
text
@d470 1
a470 1
#define SSL_OP_MSIE_SSLV2_RSA_PADDING			0x00000040L
d1570 1
d1600 1
d1679 1
a1679 1
#define SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC	 1109
d1683 1
a1683 1
#define SSL_R_ERROR_GENERATING_TMP_RSA_KEY		 1092
d1690 1
a1690 1
#define SSL_R_ILLEGAL_PADDING				 1110
d1695 12
a1706 12
#define SSL_R_KEY_ARG_TOO_LONG				 1112
#define SSL_R_KRB5					 1104
#define SSL_R_KRB5_C_CC_PRINC				 1094
#define SSL_R_KRB5_C_GET_CRED				 1095
#define SSL_R_KRB5_C_INIT				 1096
#define SSL_R_KRB5_C_MK_REQ				 1097
#define SSL_R_KRB5_S_BAD_TICKET				 1098
#define SSL_R_KRB5_S_INIT				 1099
#define SSL_R_KRB5_S_RD_REQ				 1108
#define SSL_R_KRB5_S_TKT_EXPIRED			 1105
#define SSL_R_KRB5_S_TKT_NYV				 1106
#define SSL_R_KRB5_S_TKT_SKEW				 1107
d1711 1
a1711 2
#define SSL_R_MASTER_KEY_TOO_LONG			 1112
#define SSL_R_MESSAGE_TOO_LONG				 1111
d1748 1
a1748 1
#define SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE		 1115
d1767 1
a1767 1
#define SSL_R_RECORD_TOO_SMALL				 1093
d1776 2
a1777 2
#define SSL_R_SSL2_CONNECTION_ID_TOO_LONG		 1114
#define SSL_R_SSL3_SESSION_ID_TOO_LONG			 1113
a1787 4
#define SSL_R_SSLV3_ALERT_PEER_ERROR_CERTIFICATE	 223
#define SSL_R_SSLV3_ALERT_PEER_ERROR_NO_CERTIFICATE	 224
#define SSL_R_SSLV3_ALERT_PEER_ERROR_NO_CIPHER		 225
#define SSL_R_SSLV3_ALERT_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE 226
a1788 1
#define SSL_R_SSLV3_ALERT_UNKNOWN_REMOTE_ERROR_TYPE	 227
d1793 2
a1794 2
#define SSL_R_SSL_SESSION_ID_CALLBACK_FAILED		 1102
#define SSL_R_SSL_SESSION_ID_CONFLICT			 1103
d1796 1
a1796 1
#define SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH		 1101
a1836 1
#define SSL_R_UNSUPPORTED_OPTION			 1091
@


1.12
log
@merge 0.9.7d
@
text
@d242 1
d376 1
a376 1
	int (*ssl_pending)(SSL *s);
d1002 2
a1003 2
size_t SSL_get_finished(SSL *s, void *buf, size_t count);
size_t SSL_get_peer_finished(SSL *s, void *buf, size_t count);
d1175 2
a1176 2
long SSL_CTX_get_timeout(SSL_CTX *ctx);
X509_STORE *SSL_CTX_get_cert_store(SSL_CTX *);
d1178 1
a1178 1
int SSL_want(SSL *s);
d1183 12
a1194 12
SSL_CIPHER *SSL_get_current_cipher(SSL *s);
int	SSL_CIPHER_get_bits(SSL_CIPHER *c,int *alg_bits);
char *	SSL_CIPHER_get_version(SSL_CIPHER *c);
const char *	SSL_CIPHER_get_name(SSL_CIPHER *c);

int	SSL_get_fd(SSL *s);
int	SSL_get_rfd(SSL *s);
int	SSL_get_wfd(SSL *s);
const char  * SSL_get_cipher_list(SSL *s,int n);
char *	SSL_get_shared_ciphers(SSL *s, char *buf, int len);
int	SSL_get_read_ahead(SSL * s);
int	SSL_pending(SSL *s);
d1202 2
a1203 2
BIO *	SSL_get_rbio(SSL *s);
BIO *	SSL_get_wbio(SSL *s);
d1207 3
a1209 3
int	SSL_get_verify_mode(SSL *s);
int	SSL_get_verify_depth(SSL *s);
int	(*SSL_get_verify_callback(SSL *s))(int,X509_STORE_CTX *);
d1247 1
a1247 1
long	SSL_SESSION_get_time(SSL_SESSION *s);
d1249 1
a1249 1
long	SSL_SESSION_get_timeout(SSL_SESSION *s);
d1251 1
a1251 1
void	SSL_copy_session_id(SSL *to,SSL *from);
d1254 2
a1255 2
unsigned long SSL_SESSION_hash(SSL_SESSION *a);
int	SSL_SESSION_cmp(SSL_SESSION *a,SSL_SESSION *b);
d1257 1
a1257 1
int	SSL_SESSION_print_fp(FILE *fp,SSL_SESSION *ses);
d1260 1
a1260 1
int	SSL_SESSION_print(BIO *fp,SSL_SESSION *ses);
d1271 2
a1272 1
SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a,unsigned char **pp,long length);
d1275 1
a1275 1
X509 *	SSL_get_peer_certificate(SSL *s);
d1278 1
a1278 1
STACK_OF(X509) *SSL_get_peer_cert_chain(SSL *s);
d1280 3
a1282 3
int SSL_CTX_get_verify_mode(SSL_CTX *ctx);
int SSL_CTX_get_verify_depth(SSL_CTX *ctx);
int (*SSL_CTX_get_verify_callback(SSL_CTX *ctx))(int,X509_STORE_CTX *);
d1300 2
a1301 2
int SSL_CTX_check_private_key(SSL_CTX *ctx);
int SSL_check_private_key(SSL *ctx);
d1326 2
a1327 2
int	SSL_get_error(SSL *s,int ret_code);
const char *SSL_get_version(SSL *s);
d1348 1
a1348 1
STACK_OF(SSL_CIPHER) *SSL_get_ciphers(SSL *s);
d1364 2
a1365 2
STACK_OF(X509_NAME) *SSL_get_client_CA_list(SSL *s);
STACK_OF(X509_NAME) *SSL_CTX_get_client_CA_list(SSL_CTX *s);
d1372 1
a1372 1
long SSL_get_default_timeout(SSL *s);
d1381 1
a1381 1
X509 *SSL_get_certificate(SSL *ssl);
d1385 1
a1385 1
int SSL_CTX_get_quiet_shutdown(SSL_CTX *ctx);
d1387 1
a1387 1
int SSL_get_quiet_shutdown(SSL *ssl);
d1389 2
a1390 2
int SSL_get_shutdown(SSL *ssl);
int SSL_version(SSL *ssl);
d1395 1
a1395 1
SSL_SESSION *SSL_get_session(SSL *ssl);
d1397 1
a1397 1
SSL_CTX *SSL_get_SSL_CTX(SSL *ssl);
d1400 2
a1401 2
void (*SSL_get_info_callback(SSL *ssl))(const SSL *ssl,int type,int val);
int SSL_state(SSL *ssl);
d1404 1
a1404 1
long SSL_get_verify_result(SSL *ssl);
d1407 1
a1407 1
void *SSL_get_ex_data(SSL *ssl,int idx);
d1412 1
a1412 1
void *SSL_SESSION_get_ex_data(SSL_SESSION *ss,int idx);
d1417 1
a1417 1
void *SSL_CTX_get_ex_data(SSL_CTX *ssl,int idx);
d1608 1
d1747 1
@


1.11
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d1360 2
a1361 2
void SSL_set_client_CA_list(SSL *s, STACK_OF(X509_NAME) *list);
void SSL_CTX_set_client_CA_list(SSL_CTX *ctx, STACK_OF(X509_NAME) *list);
@


1.10
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d207 16
a317 1
#include <openssl/bio.h>
a318 1
#include <openssl/x509.h>
d524 2
d723 1
a723 3
/* This one, when set, makes the server session-id lookup not look
 * in the cache.  If there is an application get_session callback
 * defined, this will still get called. */
d725 3
a1231 1
#ifndef OPENSSL_SYS_WIN32
a1237 1
#endif
d1706 1
@


1.9
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d1465 1
d1479 1
d1481 1
d1493 1
d1530 1
d1755 1
@


1.8
log
@apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@d256 1
a256 1
#define SSL_TXT_AES		"AESdraft" /* AES ciphersuites are not yet official (thus excluded from 'ALL') */
d269 17
d449 1
d460 13
d486 4
a489 2
/* As server, disallow session resumption on renegotiation */
#define SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION	0x01000000L
a496 1
#define SSL_OP_ALL					0x000FFFFFL
a497 3
#define SSL_OP_NO_SSLv2					0x01000000L
#define SSL_OP_NO_SSLv3					0x02000000L
#define SSL_OP_NO_TLSv1					0x04000000L
d510 1
@


1.7
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d1640 1
d1720 1
@


1.6
log
@openssl-engine-0.9.6a merge
@
text
@d58 106
d168 3
a170 1
#ifndef NO_COMP
d173 1
a173 1
#ifndef NO_BIO
d176 1
a176 1
#ifndef NO_X509
d179 1
d181 1
d205 10
d235 4
d256 1
d269 4
a272 3
/* 'DEFAULT' at the start of the cipher list insert the following string
 * in addition to this being the default cipher string */
#define SSL_DEFAULT_CIPHER_LIST	"ALL:!ADH:RC4+RSA:+SSLv2:@@STRENGTH"
d293 2
a294 2
#if (defined(NO_RSA) || defined(NO_MD5)) && !defined(NO_SSL2)
#define NO_SSL2
d340 2
a341 2
	long (*ssl_ctrl)(SSL *s,int cmd,long larg,char *parg);
	long (*ssl_ctx_ctrl)(SSL_CTX *ctx,int cmd,long larg,char *parg);
d362 1
d393 5
a440 1
#define SSL_OP_TLS_ROLLBACK_BUG				0x00000400L
d444 2
a445 1
/* Set to also use the tmp_rsa key when doing RSA operations. */
d447 10
d463 1
a463 3
/* SSL_OP_NON_EXPORT_FIRST looks utterly broken .. */
#define SSL_OP_NON_EXPORT_FIRST 			0x40000000L
#define SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG		0x80000000L
d486 1
a486 1
	SSL_CTX_ctrl(ctx,SSL_CTRL_OPTIONS,op,NULL)
d488 1
a488 1
	SSL_CTX_ctrl(ctx,SSL_CTRL_OPTIONS,0,NULL)
d490 1
a490 1
	SSL_ctrl(ssl,SSL_CTRL_OPTIONS,op,NULL)
d492 1
a492 1
        SSL_ctrl(ssl,SSL_CTRL_OPTIONS,0,NULL)
d495 1
a495 1
	SSL_CTX_ctrl(ctx,SSL_CTRL_MODE,op,NULL)
d497 1
a497 1
	SSL_CTX_ctrl(ctx,SSL_CTRL_MODE,0,NULL)
d499 1
a499 1
	SSL_ctrl(ssl,SSL_CTRL_MODE,op,NULL)
d501 15
a515 1
        SSL_ctrl(ssl,SSL_CTRL_MODE,0,NULL)
d519 16
d539 1
a539 1
#ifndef NO_COMP
a550 2
	unsigned long options;
	unsigned long mode;
d588 1
a610 2
/**/	void (*info_callback)();

d612 4
a615 14
/**/	int (*app_verify_callback)();
/**/	char *app_verify_arg; /* never used; should be void * */

	/* default values to use in SSL structures */
/**/	struct cert_st /* CERT */ *cert;
/**/	int read_ahead;
/**/	int verify_mode;
/**/	int verify_depth;
/**/	unsigned int sid_ctx_length;
/**/	unsigned char sid_ctx[SSL_MAX_SID_CTX_LENGTH];
/**/	int (*default_verify_callback)(int ok,X509_STORE_CTX *ctx);

	int purpose;		/* Purpose setting */
	int trust;		/* Trust setting */
d618 1
a618 1
/**/	pem_password_cb *default_passwd_callback;
d621 1
a621 1
/**/	void *default_passwd_callback_userdata;
d624 1
a624 6
/**/	int (*client_cert_cb)(/* SSL *ssl, X509 **x509, EVP_PKEY **pkey */);

	/* what we put in client cert requests */
	STACK_OF(X509_NAME) *client_CA;

/**/	int quiet_shutdown;
d633 37
a669 1
        STACK_OF(SSL_COMP) *comp_methods; /* stack of SSL_COMP, SSLv3/TLSv1 */
d744 1
a744 1
#ifndef NO_BIO
d774 6
a779 1
	int new_session;/* 1 if we are to use a new session */
d787 1
d800 5
d819 1
a819 1
#ifndef NO_COMP
d827 1
a827 1
#ifndef NO_COMP
d847 3
d855 2
a856 1
	void (*info_callback)(); /* optional informational callback */
d861 4
d880 1
d1042 1
d1049 1
a1049 1
/* Add these ones */
d1058 3
d1075 1
a1075 1
#define SSL_CTRL_MODE			33
d1084 3
d1113 1
a1113 17
/* VMS uses only 31 characters for symbols. */
#ifdef VMS
#undef SSL_CTX_set_cert_verify_callback
#define SSL_CTX_set_cert_verify_callback SSL_CTX_set_cert_verify_cb
#undef SSL_CTX_use_certificate_chain_file
#define SSL_CTX_use_certificate_chain_file SSL_CTX_use_cert_chain_file
#undef SSL_CTX_set_default_verify_paths
#define SSL_CTX_set_default_verify_paths SSL_CTX_set_def_verify_paths
#undef SSL_get_ex_data_X509_STORE_CTX_idx
#define SSL_get_ex_data_X509_STORE_CTX_idx SSL_get_ex_data_X509_STOR_CTX_i
#undef SSL_add_file_cert_subjects_to_stack
#define SSL_add_file_cert_subjects_to_stack SSL_add_file_cert_sub_to_stack
#undef SSL_add_dir_cert_subjects_to_stack
#define SSL_add_dir_cert_subjects_to_stack SSL_add_dir_cert_sub_to_stack
#endif

#ifndef NO_BIO
d1141 2
d1147 1
a1147 1
#ifndef NO_SOCK
d1152 1
a1152 1
#ifndef NO_BIO
d1165 1
a1165 1
#ifndef NO_RSA
d1174 1
a1174 1
#ifndef NO_STDIO
d1185 3
d1191 4
a1195 1
void	ERR_load_SSL_strings(void );
d1197 4
a1200 4
char * 	SSL_state_string(SSL *s);
char * 	SSL_rstate_string(SSL *s);
char * 	SSL_state_string_long(SSL *s);
char * 	SSL_rstate_string_long(SSL *s);
d1210 1
a1210 1
#ifndef NO_FP_API
d1213 1
a1213 1
#ifndef NO_BIO
d1221 4
a1232 4
#ifdef VMS
#define SSL_CTX_set_default_passwd_cb_userdata SSL_CTX_set_def_passwd_cb_ud
#endif

d1239 2
a1240 2
void SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx, int (*cb)(),char *arg);
#ifndef NO_RSA
d1274 1
a1274 1
long	SSL_ctrl(SSL *ssl,int cmd, long larg, char *parg);
d1276 1
a1276 1
long	SSL_CTX_ctrl(SSL_CTX *ctx,int cmd, long larg, char *parg);
d1305 1
d1310 4
a1313 4
char *SSL_alert_type_string_long(int value);
char *SSL_alert_type_string(int value);
char *SSL_alert_desc_string_long(int value);
char *SSL_alert_desc_string(int value);
d1351 3
a1353 2
void SSL_set_info_callback(SSL *ssl,void (*cb)());
void (*SSL_get_info_callback(SSL *ssl))();
d1391 8
d1401 1
a1401 1
#ifndef NO_RSA
d1410 1
a1410 1
#ifndef NO_DH
d1419 1
a1419 1
#ifndef NO_COMP
d1474 1
d1624 1
d1635 1
a1635 1
#define SSL_R_INTERNAL_ERROR				 157
d1640 11
d1655 1
d1739 2
d1742 1
@


1.6.4.1
log
@Pull in patch from current:
Fix (markus), errata 013:
apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@a1420 1
#define SSL_R_KEY_ARG_TOO_LONG				 1112
a1487 1
#define SSL_R_SSL3_SESSION_ID_TOO_LONG			 1113
@


1.6.4.2
log
@Errata 021:
security fix from openssl 0.9.7a:

In ssl3_get_record (ssl/s3_pkt.c), minimize information leaked
via timing by performing a MAC computation even if incorrrect
block cipher padding has been found.  This is a countermeasure
against active attacks where the attacker has to distinguish
between bad padding and a MAC verification error. (CAN-2003-0078)

adapted from a patch from Ryan W. Maple, via markus@@
@
text
@a1405 1
#define SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC	 1109
@


1.6.2.1
log
@Errata #030 (markus):
Fixes for the "OpenSSL Security Advisory [30 July 2002]"
@
text
@a1420 1
#define SSL_R_KEY_ARG_TOO_LONG				 1112
a1487 1
#define SSL_R_SSL3_SESSION_ID_TOO_LONG			 1113
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d209 1
a209 1
	int (*ssl_peek)(SSL *s,char *buf,int len);
d1064 3
a1066 3
int 	SSL_read(SSL *ssl,char *buf,int num);
int 	SSL_peek(SSL *ssl,char *buf,int num);
int 	SSL_write(SSL *ssl,const char *buf,int num);
d1181 1
a1181 1
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_READ_AHEAD,0,NULL)
d1212 1
d1237 1
d1243 1
d1245 1
d1270 1
a1566 1

@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d62 11
a76 2
#include <openssl/safestack.h>

d152 4
d163 4
d338 3
d366 5
a370 5
{
    int id;
    char *name;
#ifdef HEADER_COMP_H
    COMP_METHOD *method;
d372 1
a372 1
    char *method;
d374 1
a374 1
} SSL_COMP;
d556 1
a556 1
#ifdef HEADER_BIO_H
d559 1
a559 1
	BIO *bbio; /* used during session-id reuse to concatinate
d620 1
a620 1
#ifdef HEADER_COMP_H
d628 1
a628 1
#ifdef HEADER_COMP_H
d678 4
d687 4
d914 1
a914 1
#ifdef HEADER_BIO_H
d951 1
a951 1
#ifdef HEADER_BIO_H
d1006 1
a1006 1
#ifdef HEADER_BIO_H
d1202 1
a1202 1
#ifdef HEADER_COMP_H
d1474 1
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d394 2
a395 3
	 * a session-id is removed from the cache.  Again, a return
	 * of 0 mens that SSLeay should not SSL_SESSION_free() since
	 * the application is doing something with it. */
d1217 1
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d126 1
a126 1
#define SSL_TXT_EXP40		"EXP"
d128 1
d137 1
a137 6
#ifndef NO_RSA
#define SSL_DEFAULT_CIPHER_LIST	"ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP"
#else
#define SSL_ALLOW_ADH
#define SSL_DEFAULT_CIPHER_LIST	"HIGH:MEDIUM:LOW:ADH+3DES:ADH+RC4:ADH+DES:+EXP"
#endif
d150 4
d169 1
d171 2
d174 1
d208 2
d224 2
a225 1
 *	Compression [5] IMPLICIT ASN1_OBJECT	-- compression OID XXXXX
d259 3
d304 1
d369 1
a369 1
	struct lhash_st /* LHASH */ *sessions;	/* a set of SSL_SESSION's */
d371 1
a371 1
	 * SSL_SESSION_CACHE_SIZE_DEFAULT. 0 is unlimited. */
d438 3
d450 1
a450 1
	/* what we put in client requests */
d475 1
d582 2
a583 2
	struct ssl2_ctx_st *s2;	/* SSLv2 variables */
	struct ssl3_ctx_st *s3;	/* SSLv3 variables */
d585 2
a586 1
	int read_ahead;		/* Read as many input bytes as possible */
d589 3
d596 1
a596 1
	/* These are the ones being used, the ones is SSL_SESSION are
d656 1
a656 1
				 * SSLv3/TLS rolback check */
d664 1
a664 1
/* compatablity */
d673 1
a673 1
 * used to indicate where we are upto in the SSL connection establishment.
d715 7
d729 1
d732 1
a732 1
/* this is for backward compatablility */
d740 1
a740 1
/* More backward compatablity */
d792 1
a792 1
#define SSL_AD_EXPORT_RESTRICION	TLS1_AD_EXPORT_RESTRICION/* fatal */
d796 1
a796 1
#define SSL_AD_USER_CANCLED		TLS1_AD_USER_CANCLED
d897 1
a897 1
int	SSL_CTX_set_cipher_list(SSL_CTX *,char *str);
d929 1
a929 1
int	SSL_set_cipher_list(SSL *s, char *str);
d1028 6
d1041 1
d1043 1
d1046 1
a1046 1
char *	SSL_get_version(SSL *s);
d1112 1
d1114 1
d1125 2
a1126 2
int SSL_get_ex_new_index(long argl, char *argp, int (*new_func)(),
	int (*dup_func)(), void (*free_func)());
d1130 2
a1131 2
int SSL_SESSION_get_ex_new_index(long argl, char *argp, int (*new_func)(),
	int (*dup_func)(), void (*free_func)());
d1135 2
a1136 2
int SSL_CTX_get_ex_new_index(long argl, char *argp, int (*new_func)(),
	int (*dup_func)(), void (*free_func)());
d1259 2
d1264 1
d1267 1
d1270 1
d1298 1
d1302 1
a1328 1
#define SSL_R_BAD_CLIENT_REQUEST			 105
d1336 1
d1376 1
d1385 3
d1480 1
a1480 1
#define SSL_R_TLSV1_ALERT_EXPORT_RESTRICION		 1060
d1487 1
a1487 1
#define SSL_R_TLSV1_ALERT_USER_CANCLED			 1090
d1515 1
@


1.1
log
@Initial revision
@
text
@d66 2
d87 1
d126 1
a126 1
#define SSL_TXT_EXP		"EXP"
d128 1
d131 1
d147 6
a152 5
#include "crypto.h"
#include "lhash.h"
#include "buffer.h"
#include "bio.h"
#include "x509.h"
d166 1
a166 1
	char *name;			/* text name */
d173 5
d182 20
a201 19
	int (*ssl_new)();
	void (*ssl_clear)();
	void (*ssl_free)();
	int (*ssl_accept)();
	int (*ssl_connect)();
	int (*ssl_read)();
	int (*ssl_peek)();
	int (*ssl_write)();
	int (*ssl_shutdown)();
	int (*ssl_renegotiate)();
	long (*ssl_ctrl)();
	long (*ssl_ctx_ctrl)();
	SSL_CIPHER *(*get_cipher_by_char)();
	int (*put_cipher_by_char)();
	int (*ssl_pending)();
	int (*num_ciphers)();
	SSL_CIPHER *(*get_cipher)();
	struct ssl_method_st *(*get_ssl_method)();
	long (*get_timeout)();
d203 1
a205 5
typedef struct ssl_compression_st
	{
	char *stuff;
	} SSL_COMPRESSION;

d217 2
d236 5
d245 1
a245 1
	struct cert_st /* CERT */ *cert;
d247 4
a250 2
	/* This is the cert for the other end.  On servers, it will be
	 * the same as cert->x509 */
d257 1
a257 2
	SSL_COMPRESSION *read_compression;
	SSL_COMPRESSION *write_compression;
d264 1
a264 1
	STACK /* SSL_CIPHER */ *ciphers; /* shared ciphers? */
d281 2
a282 1
#define	SSL_OP_TLS_BLOCK_PADDING_BUG			0x00000200L
d284 1
a284 1
/* If set, only use tmp_dh parameters once */
d289 4
a297 3
#define SSL_CTX_set_options(ctx,op)	((ctx)->options|=(op))
#define SSL_set_options(ssl,op)		((ssl)->options|=(op))

d302 29
a330 5
/* Normally you will only use these if your application wants to use
 * the certificate store in other places, perhaps PKCS7 */
#define SSL_CTX_get_cert_store(ctx)     ((ctx)->cert_store)
#define SSL_CTX_set_cert_store(ctx,cs) \
                (X509_STORE_free((ctx)->cert_store),(ctx)->cert_store=(cs))
d332 1
d334 12
a345 1
#define SSL_SESSION_CACHE_MAX_SIZE_DEFAULT	(1024*20)
d347 1
a347 1
typedef struct ssl_ctx_st
d351 1
d353 1
a353 1
	STACK /* SSL_CIPHER */ *cipher_list;
d355 1
a355 1
	STACK /* SSL_CIPHER */ *cipher_list_by_id;
a385 1
#ifndef NOPROTO
d390 19
a408 21
#else
	int (*new_session_cb)();
	void (*remove_session_cb)();
	SSL_SESSION *(*get_session_cb)();
#endif

	int sess_connect;	/* SSL new connection - started */
	int sess_connect_renegotiate;/* SSL renegotiatene  - requested */
	int sess_connect_good;	/* SSL new connection/renegotiate - finished */
	int sess_accept;	/* SSL new accept - started */
	int sess_accept_renegotiate;/* SSL renegotiatene - requested */
	int sess_accept_good;	/* SSL accept/renegotiate - finished */
	int sess_miss;		/* session lookup misses  */
	int sess_timeout;	/* session reuse attempt on timeouted session */
	int sess_cache_full;	/* session removed due to full cache */
	int sess_hit;		/* session reuse actually done */
	int sess_cb_hit;	/* session-id that was not in the cache was
				 * passed back via the callback.  This
				 * indicates that the application is supplying
				 * session-id's from other processes -
				 * spooky :-) */
d412 1
a412 1
	void (*info_callback)();
d415 2
a416 2
	int (*app_verify_callback)();
	char *app_verify_arg;
d419 7
a425 4
	struct cert_st /* CERT */ *default_cert;
	int default_read_ahead;
	int default_verify_mode;
	int (*default_verify_callback)();
d428 4
a431 1
	int (*default_passwd_callback)();
d434 1
a434 1
	int (*client_cert_cb)(/* SSL *ssl, X509 **x509, EVP_PKEY **pkey */);
d437 1
a437 1
	STACK *client_CA;
d439 1
a439 1
	int quiet_shutdown;
d443 7
a449 4
	EVP_MD *rsa_md5;/* For SSLv2 - name is 'ssl2-md5' */
	EVP_MD *md5;	/* For SSLv3/TLSv1 'ssl3-md5' */
	EVP_MD *sha1;   /* For SSLv3/TLSv1 'ssl3->sha1' */
	} SSL_CTX;
d461 24
a484 17
#define SSL_CTX_sessions(ctx)		((ctx)->sessions)
/* You will need to include lhash.h to access the following #define */
#define SSL_CTX_sess_number(ctx)	((ctx)->sessions->num_items)
#define SSL_CTX_sess_connect(ctx)	((ctx)->sess_connect)
#define SSL_CTX_sess_connect_good(ctx)	((ctx)->sess_connect_good)
#define SSL_CTX_sess_accept(ctx)	((ctx)->sess_accept)
#define SSL_CTX_sess_accept_renegotiate(ctx)	((ctx)->sess_accept_renegotiate)
#define SSL_CTX_sess_connect_renegotiate(ctx)	((ctx)->sess_connect_renegotiate)
#define SSL_CTX_sess_accept_good(ctx)	((ctx)->sess_accept_good)
#define SSL_CTX_sess_hits(ctx)		((ctx)->sess_hit)
#define SSL_CTX_sess_cb_hits(ctx)	((ctx)->sess_cb_hit)
#define SSL_CTX_sess_misses(ctx)	((ctx)->sess_miss)
#define SSL_CTX_sess_timeouts(ctx)	((ctx)->sess_timeout)
#define SSL_CTX_sess_cache_full(ctx)	((ctx)->sess_cache_full)

#define SSL_CTX_sess_set_cache_size(ctx,t) ((ctx)->session_cache_size=(t))
#define SSL_CTX_sess_get_cache_size(ctx)   ((ctx)->session_cache_size)
a491 5
#define SSL_CTX_set_session_cache_mode(ctx,m)	((ctx)->session_cache_mode=(m))
#define SSL_CTX_get_session_cache_mode(ctx)	((ctx)->session_cache_mode)
#define SSL_CTX_set_timeout(ctx,t)	((ctx)->session_timeout=(t))
#define SSL_CTX_get_timeout(ctx)	((ctx)->session_timeout)

a493 2
#define SSL_CTX_set_default_read_ahead(ctx,m) (((ctx)->default_read_ahead)=(m))

d503 4
a506 5
#define SSL_want(s)		((s)->rwstate)
#define SSL_want_nothing(s)	((s)->rwstate == SSL_NOTHING)
#define SSL_want_read(s)	((s)->rwstate == SSL_READING)
#define SSL_want_write(s)	((s)->rwstate == SSL_WRITING)
#define SSL_want_x509_lookup(s)	((s)->rwstate == SSL_X509_LOOKUP)
d508 1
a508 1
typedef struct ssl_st
d510 3
a512 4
	/* procol version
	 * 2 for SSLv2
	 * 3 for SSLv3
	 * -3 for SSLv3 but accept SSLv2 */
d542 9
a550 1
/*	int server;*/	/* are we the server side? */
d574 2
a575 2
	STACK /* SSL_CIPHER */ *cipher_list;
	STACK /* SSL_CIPHER */ *cipher_list_by_id;
d581 6
a586 2
	EVP_MD *read_hash;			/* used for mac generation */
	SSL_COMPRESSION *read_compression;	/* compression */
d589 6
a594 2
	EVP_MD *write_hash;			/* used for mac generation */
	SSL_COMPRESSION *write_compression;	/* compression */
d602 5
d613 2
a614 1
	int (*verify_callback)(); /* fail if callback returns 0 */
d630 1
a630 1
	STACK /* X509_NAME */ *client_CA;
d633 2
a634 1
	unsigned long options;
d636 8
a643 6
	} SSL;

#include "ssl2.h"
#include "ssl3.h"
#include "tls1.h" /* This is mostly sslv3 with a few tweaks */
#include "ssl23.h"
d703 2
a726 4
/* VMS linker has a 31 char name limit */
#define SSL_CTX_set_cert_verify_callback(a,b,c) \
		SSL_CTX_set_cert_verify_cb((a),(b),(c))

d733 4
a736 4
#define PEM_read_SSL_SESSION(fp,x,cb) (SSL_SESSION *)PEM_ASN1_read( \
	(char *(*)())d2i_SSL_SESSION,PEM_STRING_SSL_SESSION,fp,(char **)x,cb)
#define PEM_read_bio_SSL_SESSION(bp,x,cb) (SSL_SESSION *)PEM_ASN1_read_bio( \
	(char *(*)())d2i_SSL_SESSION,PEM_STRING_SSL_SESSION,bp,(char **)x,cb)
d739 1
a739 1
		PEM_STRING_SSL_SESSION,fp, (char *)x, NULL,NULL,0,NULL)
d742 1
a742 1
		PEM_STRING_SSL_SESSION,bp, (char *)x, NULL,NULL,0,NULL)
d745 1
d777 1
a777 1
#define SSL_ERROR_SYSCALL		5 /* look at errno */
d792 25
d834 25
a858 10
/* For the next 2, the callbacks are 
 * RSA *tmp_rsa_cb(int export)
 * DH *tmp_dh_cb(int export)
 */
#define SSL_CTX_set_tmp_rsa_callback(ctx,cb) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_TMP_RSA_CB,0,(char *)cb)
#define SSL_CTX_set_tmp_dh_callback(ctx,dh) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_TMP_DH_CB,0,(char *)dh)

#ifndef NOPROTO
d873 7
a879 1
void	SSL_clear(SSL *s);
d885 1
a885 1
char *	SSL_CIPHER_get_name(SSL_CIPHER *c);
d888 1
a888 1
char  * SSL_get_cipher_list(SSL *s,int n);
d905 6
a910 2
int	(*SSL_get_verify_callback(SSL *s))();
void	SSL_set_verify(SSL *s, int mode, int (*callback) ());
d912 1
d917 1
a917 1
int	SSL_use_certificate_ASN1(SSL *ssl, int len, unsigned char *d);
d920 12
a931 7
int	SSL_use_RSAPrivateKey_file(SSL *ssl, char *file, int type);
int	SSL_use_PrivateKey_file(SSL *ssl, char *file, int type);
int	SSL_use_certificate_file(SSL *ssl, char *file, int type);
int	SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, char *file, int type);
int	SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, char *file, int type);
int	SSL_CTX_use_certificate_file(SSL_CTX *ctx, char *file, int type);
STACK * SSL_load_client_CA_file(char *file);
d966 5
a970 1
STACK *	SSL_get_peer_cert_chain(SSL *s);
d973 7
a979 3
int (*SSL_CTX_get_verify_callback(SSL_CTX *ctx))();
void SSL_CTX_set_verify(SSL_CTX *ctx,int mode,int (*callback)());
void SSL_CTX_set_cert_verify_cb(SSL_CTX *ctx, int (*cb)(),char *arg);
d981 1
d989 2
a990 1
void SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx,int (*cb)());
d995 3
d999 2
a1000 1
void    SSL_clear(SSL *s);
d1006 1
a1006 1
int 	SSL_write(SSL *ssl,char *buf,int num);
d1032 1
a1032 1
STACK *SSL_get_ciphers(SSL *s);
d1045 4
a1048 4
void SSL_set_client_CA_list(SSL *s, STACK *list);
void SSL_CTX_set_client_CA_list(SSL_CTX *ctx, STACK *list);
STACK *SSL_get_client_CA_list(SSL *s);
STACK *SSL_CTX_get_client_CA_list(SSL_CTX *s);
d1057 1
a1057 1
void SSLeay_add_ssl_algorithms(void );
d1060 1
a1060 1
STACK *SSL_dup_CA_list(STACK *sk);
d1075 2
a1076 1
int SSL_CTX_load_verify_locations(SSL_CTX *ctx,char *CAfile,char *CApath);
d1086 2
a1087 2
int SSL_set_ex_data(SSL *ssl,int idx,char *data);
char *SSL_get_ex_data(SSL *ssl,int idx);
d1091 2
a1092 2
int SSL_SESSION_set_ex_data(SSL_SESSION *ss,int idx,char *data);
char *SSL_SESSION_get_ex_data(SSL_SESSION *ss,int idx);
d1096 2
a1097 2
int SSL_CTX_set_ex_data(SSL_CTX *ssl,int idx,char *data);
char *SSL_CTX_get_ex_data(SSL_CTX *ssl,int idx);
d1101 1
a1101 1
#else
d1103 15
a1117 44
BIO_METHOD *BIO_f_ssl();
BIO *BIO_new_ssl();
BIO *BIO_new_ssl_connect();
BIO *BIO_new_buffer_ssl_connect();
int BIO_ssl_copy_session_id();
void BIO_ssl_shutdown();

int	SSL_CTX_set_cipher_list();
SSL_CTX *SSL_CTX_new();
void	SSL_CTX_free();
void	SSL_clear();
void	SSL_CTX_flush_sessions();

SSL_CIPHER *SSL_get_current_cipher();
int	SSL_CIPHER_get_bits();
char *	SSL_CIPHER_get_version();
char *	SSL_CIPHER_get_name();

int	SSL_get_fd();
char  * SSL_get_cipher_list();
char *	SSL_get_shared_ciphers();
int	SSL_get_read_ahead();
int	SSL_pending();
#ifndef NO_SOCK
int	SSL_set_fd();
int	SSL_set_rfd();
int	SSL_set_wfd();
#endif
#ifdef HEADER_BIO_H
void	SSL_set_bio();
BIO *	SSL_get_rbio();
BIO *	SSL_get_wbio();
#endif
int	SSL_set_cipher_list();
void	SSL_set_read_ahead();
int	SSL_get_verify_mode();

void	SSL_set_verify();
int	SSL_use_RSAPrivateKey();
int	SSL_use_RSAPrivateKey_ASN1();
int	SSL_use_PrivateKey();
int	SSL_use_PrivateKey_ASN1();
int	SSL_use_certificate();
int	SSL_use_certificate_ASN1();
d1119 9
a1127 27
#ifndef NO_STDIO
int	SSL_use_RSAPrivateKey_file();
int	SSL_use_PrivateKey_file();
int	SSL_use_certificate_file();
int	SSL_CTX_use_RSAPrivateKey_file();
int	SSL_CTX_use_PrivateKey_file();
int	SSL_CTX_use_certificate_file();
STACK * SSL_load_client_CA_file();
#endif

void	ERR_load_SSL_strings();
void	SSL_load_error_strings();
char * 	SSL_state_string();
char * 	SSL_rstate_string();
char * 	SSL_state_string_long();
char * 	SSL_rstate_string_long();
long	SSL_SESSION_get_time();
long	SSL_SESSION_set_time();
long	SSL_SESSION_get_timeout();
long	SSL_SESSION_set_timeout();
void	SSL_copy_session_id();

SSL_SESSION *SSL_SESSION_new();
unsigned long SSL_SESSION_hash();
int	SSL_SESSION_cmp();
#ifndef NO_FP_API
int	SSL_SESSION_print_fp();
d1129 7
a1135 2
#ifdef HEADER_BIO_H
int	SSL_SESSION_print();
a1136 6
void	SSL_SESSION_free();
int	i2d_SSL_SESSION();
int	SSL_set_session();
int	SSL_CTX_add_session();
int	SSL_CTX_remove_session();
SSL_SESSION *d2i_SSL_SESSION();
d1138 4
a1141 2
#ifdef HEADER_X509_H
X509 *	SSL_get_peer_certificate();
d1144 4
a1147 1
STACK *	SSL_get_peer_cert_chain();
a1148 120
int SSL_CTX_get_verify_mode();
int (*SSL_CTX_get_verify_callback())();
void SSL_CTX_set_verify();
void SSL_CTX_set_cert_verify_cb();
int SSL_CTX_use_RSAPrivateKey();
int SSL_CTX_use_RSAPrivateKey_ASN1();
int SSL_CTX_use_PrivateKey();
int SSL_CTX_use_PrivateKey_ASN1();
int SSL_CTX_use_certificate();
int SSL_CTX_use_certificate_ASN1();

void SSL_CTX_set_default_passwd_cb();

int SSL_CTX_check_private_key();
int SSL_check_private_key();

SSL *	SSL_new();
void    SSL_clear();
void	SSL_free();
int 	SSL_accept();
int 	SSL_connect();
int 	SSL_read();
int 	SSL_peek();
int 	SSL_write();
long	SSL_ctrl();
long	SSL_CTX_ctrl();

int	SSL_get_error();
char *	SSL_get_version();

int SSL_CTX_set_ssl_version();

SSL_METHOD *SSLv2_method();
SSL_METHOD *SSLv2_server_method();
SSL_METHOD *SSLv2_client_method();

SSL_METHOD *SSLv3_method();
SSL_METHOD *SSLv3_server_method();
SSL_METHOD *SSLv3_client_method();

SSL_METHOD *SSLv23_method();
SSL_METHOD *SSLv23_server_method();
SSL_METHOD *SSLv23_client_method();

SSL_METHOD *TLSv1_method();
SSL_METHOD *TLSv1_server_method();
SSL_METHOD *TLSv1_client_method();

STACK *SSL_get_ciphers();

int SSL_do_handshake();
int SSL_renegotiate();
int SSL_shutdown();

SSL_METHOD *SSL_get_ssl_method();
int SSL_set_ssl_method();
char *SSL_alert_type_string_long();
char *SSL_alert_type_string();
char *SSL_alert_desc_string_long();
char *SSL_alert_desc_string();

void SSL_set_client_CA_list();
void SSL_CTX_set_client_CA_list();
STACK *SSL_get_client_CA_list();
STACK *SSL_CTX_get_client_CA_list();
int SSL_add_client_CA();
int SSL_CTX_add_client_CA();

void SSL_set_connect_state();
void SSL_set_accept_state();

long SSL_get_default_timeout();

void SSLeay_add_ssl_algorithms();

char *SSL_CIPHER_description();
STACK *SSL_dup_CA_list();

SSL *SSL_dup();

X509 *SSL_get_certificate();
/* EVP * */ struct evp_pkey_st *SSL_get_privatekey();

#ifdef this_is_for_mk1mf_pl
EVP *SSL_get_privatekey();

void SSL_CTX_set_quiet_shutdown();
int SSL_CTX_get_quiet_shutdown();
void SSL_set_quiet_shutdown();
int SSL_get_quiet_shutdown();
void SSL_set_shutdown();
int SSL_get_shutdown();
int SSL_version();
int SSL_CTX_set_default_verify_paths();
int SSL_CTX_load_verify_locations();
SSL_SESSION *SSL_get_session();
SSL_CTX *SSL_get_SSL_CTX();
void SSL_set_info_callback();
int (*SSL_get_info_callback())();
int SSL_state();
void SSL_set_verify_result();
long SSL_get_verify_result();

int SSL_set_ex_data();
char *SSL_get_ex_data();
int SSL_get_ex_new_index();

int SSL_SESSION_set_ex_data();
char *SSL_SESSION_get_ex_data();
int SSL_SESSION_get_ex_new_index();

int SSL_CTX_set_ex_data();
char *SSL_CTX_get_ex_data();
int SSL_CTX_get_ex_new_index();

#endif

#endif

/* BEGIN ERROR CODES */
d1185 1
d1213 2
d1217 3
d1222 55
a1276 45
#define SSL_F_SSL_CREATE_CIPHER_LIST			 164
#define SSL_F_SSL_CTX_CHECK_PRIVATE_KEY			 165
#define SSL_F_SSL_CTX_NEW				 166
#define SSL_F_SSL_CTX_SET_SSL_VERSION			 167
#define SSL_F_SSL_CTX_USE_CERTIFICATE			 168
#define SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1		 169
#define SSL_F_SSL_CTX_USE_CERTIFICATE_FILE		 170
#define SSL_F_SSL_CTX_USE_PRIVATEKEY			 171
#define SSL_F_SSL_CTX_USE_PRIVATEKEY_ASN1		 172
#define SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE		 173
#define SSL_F_SSL_CTX_USE_RSAPRIVATEKEY			 174
#define SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_ASN1		 175
#define SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE		 176
#define SSL_F_SSL_DO_HANDSHAKE				 177
#define SSL_F_SSL_GET_NEW_SESSION			 178
#define SSL_F_SSL_GET_SERVER_SEND_CERT			 179
#define SSL_F_SSL_GET_SIGN_PKEY				 180
#define SSL_F_SSL_INIT_WBIO_BUFFER			 181
#define SSL_F_SSL_LOAD_CLIENT_CA_FILE			 182
#define SSL_F_SSL_NEW					 183
#define SSL_F_SSL_RSA_PRIVATE_DECRYPT			 184
#define SSL_F_SSL_RSA_PUBLIC_ENCRYPT			 185
#define SSL_F_SSL_SESSION_NEW				 186
#define SSL_F_SSL_SESSION_PRINT_FP			 187
#define SSL_F_SSL_SET_CERT				 188
#define SSL_F_SSL_SET_FD				 189
#define SSL_F_SSL_SET_PKEY				 190
#define SSL_F_SSL_SET_RFD				 191
#define SSL_F_SSL_SET_SESSION				 192
#define SSL_F_SSL_SET_WFD				 193
#define SSL_F_SSL_UNDEFINED_FUNCTION			 194
#define SSL_F_SSL_USE_CERTIFICATE			 195
#define SSL_F_SSL_USE_CERTIFICATE_ASN1			 196
#define SSL_F_SSL_USE_CERTIFICATE_FILE			 197
#define SSL_F_SSL_USE_PRIVATEKEY			 198
#define SSL_F_SSL_USE_PRIVATEKEY_ASN1			 199
#define SSL_F_SSL_USE_PRIVATEKEY_FILE			 200
#define SSL_F_SSL_USE_RSAPRIVATEKEY			 201
#define SSL_F_SSL_USE_RSAPRIVATEKEY_ASN1		 202
#define SSL_F_SSL_USE_RSAPRIVATEKEY_FILE		 203
#define SSL_F_SSL_WRITE					 204
#define SSL_F_TLS1_CHANGE_CIPHER_STATE			 205
#define SSL_F_TLS1_ENC					 206
#define SSL_F_TLS1_SETUP_KEY_BLOCK			 207
#define SSL_F_WRITE_PENDING				 208
d1280 1
d1293 1
d1323 84
a1406 77
#define SSL_R_CONNECTION_ID_IS_DIFFERENT		 142
#define SSL_R_CONNECTION_TYPE_NOT_SET			 143
#define SSL_R_DATA_BETWEEN_CCS_AND_FINISHED		 144
#define SSL_R_DATA_LENGTH_TOO_LONG			 145
#define SSL_R_DECRYPTION_FAILED				 146
#define SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG		 147
#define SSL_R_DIGEST_CHECK_FAILED			 148
#define SSL_R_ENCRYPTED_LENGTH_TOO_LONG			 149
#define SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST		 150
#define SSL_R_EXCESSIVE_MESSAGE_SIZE			 151
#define SSL_R_EXTRA_DATA_IN_MESSAGE			 152
#define SSL_R_GOT_A_FIN_BEFORE_A_CCS			 153
#define SSL_R_HTTPS_PROXY_REQUEST			 154
#define SSL_R_HTTP_REQUEST				 155
#define SSL_R_INTERNAL_ERROR				 156
#define SSL_R_INVALID_CHALLENGE_LENGTH			 157
#define SSL_R_LENGTH_MISMATCH				 158
#define SSL_R_LENGTH_TOO_SHORT				 159
#define SSL_R_LIBRARY_HAS_NO_CIPHERS			 160
#define SSL_R_MISSING_DH_DSA_CERT			 161
#define SSL_R_MISSING_DH_KEY				 162
#define SSL_R_MISSING_DH_RSA_CERT			 163
#define SSL_R_MISSING_DSA_SIGNING_CERT			 164
#define SSL_R_MISSING_EXPORT_TMP_DH_KEY			 165
#define SSL_R_MISSING_EXPORT_TMP_RSA_KEY		 166
#define SSL_R_MISSING_RSA_CERTIFICATE			 167
#define SSL_R_MISSING_RSA_ENCRYPTING_CERT		 168
#define SSL_R_MISSING_RSA_SIGNING_CERT			 169
#define SSL_R_MISSING_TMP_DH_KEY			 170
#define SSL_R_MISSING_TMP_RSA_KEY			 171
#define SSL_R_MISSING_TMP_RSA_PKEY			 172
#define SSL_R_MISSING_VERIFY_MESSAGE			 173
#define SSL_R_NON_SSLV2_INITIAL_PACKET			 174
#define SSL_R_NO_CERTIFICATES_RETURNED			 175
#define SSL_R_NO_CERTIFICATE_ASSIGNED			 176
#define SSL_R_NO_CERTIFICATE_RETURNED			 177
#define SSL_R_NO_CERTIFICATE_SET			 178
#define SSL_R_NO_CERTIFICATE_SPECIFIED			 179
#define SSL_R_NO_CIPHERS_AVAILABLE			 180
#define SSL_R_NO_CIPHERS_PASSED				 181
#define SSL_R_NO_CIPHERS_SPECIFIED			 182
#define SSL_R_NO_CIPHER_LIST				 183
#define SSL_R_NO_CIPHER_MATCH				 184
#define SSL_R_NO_CLIENT_CERT_RECEIVED			 185
#define SSL_R_NO_COMPRESSION_SPECIFIED			 186
#define SSL_R_NO_PRIVATEKEY				 187
#define SSL_R_NO_PRIVATE_KEY_ASSIGNED			 188
#define SSL_R_NO_PROTOCOLS_AVAILABLE			 189
#define SSL_R_NO_PUBLICKEY				 190
#define SSL_R_NO_SHARED_CIPHER				 191
#define SSL_R_NULL_SSL_CTX				 192
#define SSL_R_NULL_SSL_METHOD_PASSED			 193
#define SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED		 194
#define SSL_R_PACKET_LENGTH_TOO_LONG			 195
#define SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE		 196
#define SSL_R_PEER_ERROR				 197
#define SSL_R_PEER_ERROR_CERTIFICATE			 198
#define SSL_R_PEER_ERROR_NO_CERTIFICATE			 199
#define SSL_R_PEER_ERROR_NO_CIPHER			 200
#define SSL_R_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE	 201
#define SSL_R_PRE_MAC_LENGTH_TOO_LONG			 202
#define SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS		 203
#define SSL_R_PROTOCOL_IS_SHUTDOWN			 204
#define SSL_R_PUBLIC_KEY_ENCRYPT_ERROR			 205
#define SSL_R_PUBLIC_KEY_IS_NOT_RSA			 206
#define SSL_R_PUBLIC_KEY_NOT_RSA			 207
#define SSL_R_READ_BIO_NOT_SET				 208
#define SSL_R_READ_WRONG_PACKET_TYPE			 209
#define SSL_R_RECORD_LENGTH_MISMATCH			 210
#define SSL_R_RECORD_TOO_LARGE				 211
#define SSL_R_REQUIRED_CIPHER_MISSING			 212
#define SSL_R_REUSE_CERT_LENGTH_NOT_ZERO		 213
#define SSL_R_REUSE_CERT_TYPE_NOT_ZERO			 214
#define SSL_R_REUSE_CIPHER_LIST_NOT_ZERO		 215
#define SSL_R_SHORT_READ				 216
#define SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE	 217
#define SSL_R_SSL3_SESSION_ID_TOO_SHORT			 218
d1416 4
a1419 4
#define SSL_R_SSLV3_ALERT_PEER_ERROR_CERTIFICATE	 219
#define SSL_R_SSLV3_ALERT_PEER_ERROR_NO_CERTIFICATE	 220
#define SSL_R_SSLV3_ALERT_PEER_ERROR_NO_CIPHER		 221
#define SSL_R_SSLV3_ALERT_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE 222
d1421 1
a1421 1
#define SSL_R_SSLV3_ALERT_UNKNOWN_REMOTE_ERROR_TYPE	 223
d1423 57
a1479 42
#define SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION	 224
#define SSL_R_SSL_HANDSHAKE_FAILURE			 225
#define SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS		 226
#define SSL_R_SSL_SESSION_ID_IS_DIFFERENT		 227
#define SSL_R_TLS_CLIENT_CERT_REQ_WITH_ANON_CIPHER	 228
#define SSL_R_TLS_PEER_DID_NOT_RESPOND_WITH_CERTIFICATE_LIST 229
#define SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG	 230
#define SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER		 231
#define SSL_R_UNABLE_TO_DECODE_DH_CERTS			 232
#define SSL_R_UNABLE_TO_EXTRACT_PUBLIC_KEY		 233
#define SSL_R_UNABLE_TO_FIND_DH_PARAMETERS		 234
#define SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS	 235
#define SSL_R_UNABLE_TO_FIND_SSL_METHOD			 236
#define SSL_R_UNABLE_TO_LOAD_SSL2_MD5_ROUTINES		 237
#define SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES		 238
#define SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES		 239
#define SSL_R_UNEXPECTED_MESSAGE			 240
#define SSL_R_UNEXPECTED_RECORD				 241
#define SSL_R_UNKNOWN_ALERT_TYPE			 242
#define SSL_R_UNKNOWN_CERTIFICATE_TYPE			 243
#define SSL_R_UNKNOWN_CIPHER_RETURNED			 244
#define SSL_R_UNKNOWN_CIPHER_TYPE			 245
#define SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE			 246
#define SSL_R_UNKNOWN_PKEY_TYPE				 247
#define SSL_R_UNKNOWN_PROTOCOL				 248
#define SSL_R_UNKNOWN_REMOTE_ERROR_TYPE			 249
#define SSL_R_UNKNOWN_SSL_VERSION			 250
#define SSL_R_UNKNOWN_STATE				 251
#define SSL_R_UNSUPPORTED_CIPHER			 252
#define SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM		 253
#define SSL_R_UNSUPPORTED_PROTOCOL			 254
#define SSL_R_UNSUPPORTED_SSL_VERSION			 255
#define SSL_R_WRITE_BIO_NOT_SET				 256
#define SSL_R_WRONG_CIPHER_RETURNED			 257
#define SSL_R_WRONG_MESSAGE_TYPE			 258
#define SSL_R_WRONG_NUMBER_OF_KEY_BITS			 259
#define SSL_R_WRONG_SIGNATURE_LENGTH			 260
#define SSL_R_WRONG_SIGNATURE_SIZE			 261
#define SSL_R_WRONG_SSL_VERSION				 262
#define SSL_R_WRONG_VERSION_NUMBER			 263
#define SSL_R_X509_LIB					 264
 
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 106
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
a61 15
#include <openssl/e_os2.h>

#ifndef OPENSSL_NO_COMP
#include <openssl/comp.h>
#endif
#ifndef OPENSSL_NO_BIO
#include <openssl/bio.h>
#endif
#ifndef OPENSSL_NO_X509
#include <openssl/x509.h>
#endif
#include <openssl/kssl.h>
#include <openssl/safestack.h>
#include <openssl/symhacks.h>

a83 10
/*    VRS Additional Kerberos5 entries
 */
#define SSL_TXT_KRB5_DES_40_CBC_SHA   SSL3_TXT_KRB5_DES_40_CBC_SHA
#define SSL_TXT_KRB5_DES_40_CBC_MD5   SSL3_TXT_KRB5_DES_40_CBC_MD5
#define SSL_TXT_KRB5_DES_64_CBC_SHA   SSL3_TXT_KRB5_DES_64_CBC_SHA
#define SSL_TXT_KRB5_DES_64_CBC_MD5   SSL3_TXT_KRB5_DES_64_CBC_MD5
#define SSL_TXT_KRB5_DES_192_CBC3_SHA SSL3_TXT_KRB5_DES_192_CBC3_SHA
#define SSL_TXT_KRB5_DES_192_CBC3_MD5 SSL3_TXT_KRB5_DES_192_CBC3_MD5
#define SSL_MAX_KRB5_PRINCIPAL_LENGTH  256

a84 1
#define SSL_MAX_SID_CTX_LENGTH			32
a102 4
#define SSL_TXT_kKRB5     	"kKRB5"
#define SSL_TXT_aKRB5     	"aKRB5"
#define SSL_TXT_KRB5      	"KRB5"

a119 1
#define SSL_TXT_AES		"AESdraft" /* AES ciphersuites are not yet official (thus excluded from 'ALL') */
a124 2
#define SSL_TXT_EXP40		"EXPORT40"
#define SSL_TXT_EXP56		"EXPORT56"
a126 1
#define SSL_TXT_TLSV1		"TLSv1"
d129 8
a136 4
/* The following cipher list is used by default.
 * It also is substituted when an application-defined cipher list string
 * starts with 'DEFAULT'. */
#define SSL_DEFAULT_CIPHER_LIST	"ALL:!ADH:+RC4:@@STRENGTH" /* low priority for RC4 */
d142 5
a146 18
#ifdef __cplusplus
}
#endif

#include <openssl/crypto.h>
#include <openssl/lhash.h>
#include <openssl/buffer.h>
#include <openssl/bio.h>
#include <openssl/pem.h>
#include <openssl/x509.h>

#ifdef  __cplusplus
extern "C" {
#endif

#if (defined(OPENSSL_NO_RSA) || defined(OPENSSL_NO_MD5)) && !defined(OPENSSL_NO_SSL2)
#define OPENSSL_NO_SSL2
#endif
d160 1
a160 1
	const char *name;		/* text name */
a162 1
	unsigned long algo_strength;	/* strength and export flags */
a163 2
	int strength_bits;		/* Number of bits really used */
	int alg_bits;			/* Number of bits for algorithm */
a164 1
	unsigned long mask_strength;	/* also used for matching */
a166 5
DECLARE_STACK_OF(SSL_CIPHER)

typedef struct ssl_st SSL;
typedef struct ssl_ctx_st SSL_CTX;

d171 19
a189 20
	int (*ssl_new)(SSL *s);
	void (*ssl_clear)(SSL *s);
	void (*ssl_free)(SSL *s);
	int (*ssl_accept)(SSL *s);
	int (*ssl_connect)(SSL *s);
	int (*ssl_read)(SSL *s,void *buf,int len);
	int (*ssl_peek)(SSL *s,void *buf,int len);
	int (*ssl_write)(SSL *s,const void *buf,int len);
	int (*ssl_shutdown)(SSL *s);
	int (*ssl_renegotiate)(SSL *s);
	int (*ssl_renegotiate_check)(SSL *s);
	long (*ssl_ctrl)(SSL *s,int cmd,long larg,void *parg);
	long (*ssl_ctx_ctrl)(SSL_CTX *ctx,int cmd,long larg,void *parg);
	SSL_CIPHER *(*get_cipher_by_char)(const unsigned char *ptr);
	int (*put_cipher_by_char)(const SSL_CIPHER *cipher,unsigned char *ptr);
	int (*ssl_pending)(SSL *s);
	int (*num_ciphers)(void);
	SSL_CIPHER *(*get_cipher)(unsigned ncipher);
	struct ssl_method_st *(*get_ssl_method)(int version);
	long (*get_timeout)(void);
a190 3
	int (*ssl_version)();
	long (*ssl_callback_ctrl)(SSL *s, int cb_id, void (*fp)());
	long (*ssl_ctx_callback_ctrl)(SSL_CTX *s, int cb_id, void (*fp)());
d193 5
a204 1
 *	KRB5_principal		OCTET_STRING	-- optional Kerberos principal
a208 3
 *	Session_ID_context [ 4 ] EXPLICIT OCTET_STRING,   -- the Session ID context
 *	Verify_result [ 5 ] EXPLICIT INTEGER    -- X509_V_... code for `Peer'
 *	Compression [6] IMPLICIT ASN1_OBJECT	-- compression OID XXXXX
a225 10
	/* this is used to determine whether the session is being reused in
	 * the appropriate context. It is up to the application to set this,
	 * via SSL_new */
	unsigned int sid_ctx_length;
	unsigned char sid_ctx[SSL_MAX_SID_CTX_LENGTH];

#ifndef OPENSSL_NO_KRB5
        unsigned int krb5_client_princ_len;
        unsigned char krb5_client_princ[SSL_MAX_KRB5_PRINCIPAL_LENGTH];
#endif /* OPENSSL_NO_KRB5 */
d230 1
a230 1
	struct sess_cert_st /* SESS_CERT */ *sess_cert;
d232 2
a233 4
	/* This is the cert for the other end.
	 * On clients, it will be the same as sess_cert->peer_key->x509
	 * (the latter is not enough as sess_cert is not retained
	 * in the external representation of sessions, see ssl_asn1.c). */
a234 3
	/* when app_verify_callback accepts a session where the peer's certificate
	 * is not ok, we must remember the error for session reuse: */
	long verify_result; /* only for servers */
d240 2
a241 1
	int compress_meth;		/* Need to lookup the method */
d248 1
a248 1
	STACK_OF(SSL_CIPHER) *ciphers; /* shared ciphers? */
d265 1
a265 1
#define SSL_OP_TLS_BLOCK_PADDING_BUG			0x00000200L
d267 1
a267 1
/* If set, always create a new key when using tmp_dh parameters */
d269 1
a269 2
/* Set to always use the tmp_rsa key when doing RSA operations,
 * even when this violates protocol specs */
d271 1
a271 15
/* Set on servers to choose the cipher according to the server's
 * preferences */
#define SSL_OP_CIPHER_SERVER_PREFERENCE			0x00400000L
/* If set, a server will allow a client to issue a SSLv3.0 version number
 * as latest version supported in the premaster secret, even when TLSv1.0
 * (version 3.1) was announced in the client hello. Normally this is
 * forbidden to prevent version rollback attacks. */
#define SSL_OP_TLS_ROLLBACK_BUG				0x00800000L
/* As server, disallow session resumption on renegotiation */
#define SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION	0x01000000L

/* The next flag deliberately changes the ciphertest, this is a check
 * for the PKCS#1 attack */
#define SSL_OP_PKCS1_CHECK_1				0x08000000L
#define SSL_OP_PKCS1_CHECK_2				0x10000000L
d273 2
a274 1
#define SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG		0x40000000L
d277 3
d284 5
a288 39
/* Allow SSL_write(..., n) to return r with 0 < r < n (i.e. report success
 * when just a single record has been written): */
#define SSL_MODE_ENABLE_PARTIAL_WRITE       0x00000001L
/* Make it possible to retry SSL_write() with changed buffer location
 * (buffer contents must stay the same!); this is not the default to avoid
 * the misconception that non-blocking SSL_write() behaves like
 * non-blocking write(): */
#define SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER 0x00000002L
/* Never bother the application with retries if the transport
 * is blocking: */
#define SSL_MODE_AUTO_RETRY 0x00000004L

/* Note: SSL[_CTX]_set_{options,mode} use |= op on the previous value,
 * they cannot be used to clear bits. */

#define SSL_CTX_set_options(ctx,op) \
	SSL_CTX_ctrl((ctx),SSL_CTRL_OPTIONS,(op),NULL)
#define SSL_CTX_get_options(ctx) \
	SSL_CTX_ctrl((ctx),SSL_CTRL_OPTIONS,0,NULL)
#define SSL_set_options(ssl,op) \
	SSL_ctrl((ssl),SSL_CTRL_OPTIONS,(op),NULL)
#define SSL_get_options(ssl) \
        SSL_ctrl((ssl),SSL_CTRL_OPTIONS,0,NULL)

#define SSL_CTX_set_mode(ctx,op) \
	SSL_CTX_ctrl((ctx),SSL_CTRL_MODE,(op),NULL)
#define SSL_CTX_get_mode(ctx) \
	SSL_CTX_ctrl((ctx),SSL_CTRL_MODE,0,NULL)
#define SSL_set_mode(ssl,op) \
	SSL_ctrl((ssl),SSL_CTRL_MODE,(op),NULL)
#define SSL_get_mode(ssl) \
        SSL_ctrl((ssl),SSL_CTRL_MODE,0,NULL)


void SSL_CTX_set_msg_callback(SSL_CTX *ctx, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg));
void SSL_set_msg_callback(SSL *ssl, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg));
#define SSL_CTX_set_msg_callback_arg(ctx, arg) SSL_CTX_ctrl((ctx), SSL_CTRL_SET_MSG_CALLBACK_ARG, 0, (arg))
#define SSL_set_msg_callback_arg(ssl, arg) SSL_ctrl((ssl), SSL_CTRL_SET_MSG_CALLBACK_ARG, 0, (arg))

a290 6
#if defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_WIN32)
#define SSL_MAX_CERT_LIST_DEFAULT 1024*30 /* 30k max cert list :-) */
#else
#define SSL_MAX_CERT_LIST_DEFAULT 1024*100 /* 100k max cert list :-) */
#endif

d293 1
a293 30
/* This callback type is used inside SSL_CTX, SSL, and in the functions that set
 * them. It is used to override the generation of SSL/TLS session IDs in a
 * server. Return value should be zero on an error, non-zero to proceed. Also,
 * callbacks should themselves check if the id they generate is unique otherwise
 * the SSL handshake will fail with an error - callbacks can do this using the
 * 'ssl' value they're passed by;
 *      SSL_has_matching_session_id(ssl, id, *id_len)
 * The length value passed in is set at the maximum size the session ID can be.
 * In SSLv2 this is 16 bytes, whereas SSLv3/TLSv1 it is 32 bytes. The callback
 * can alter this length to be less if desired, but under SSLv2 session IDs are
 * supposed to be fixed at 16 bytes so the id will be padded after the callback
 * returns in this case. It is also an error for the callback to set the size to
 * zero. */
typedef int (*GEN_SESSION_CB)(const SSL *ssl, unsigned char *id,
				unsigned int *id_len);

typedef struct ssl_comp_st
	{
	int id;
	char *name;
#ifndef OPENSSL_NO_COMP
	COMP_METHOD *method;
#else
	char *method;
#endif
	} SSL_COMP;

DECLARE_STACK_OF(SSL_COMP)

struct ssl_ctx_st
d296 1
d298 1
a298 1
	STACK_OF(SSL_CIPHER) *cipher_list;
d300 1
a300 1
	STACK_OF(SSL_CIPHER) *cipher_list_by_id;
d303 1
a303 1
	struct lhash_st /* LHASH */ *sessions;	/* a set of SSL_SESSIONs */
d305 1
a305 1
	 * SSL_SESSION_CACHE_MAX_SIZE_DEFAULT. 0 is unlimited. */
d328 4
a331 2
	 * a session-id is removed from the cache.  After the call,
	 * OpenSSL will SSL_SESSION_free() it. */
d336 21
d358 1
a358 19
	struct
		{
		int sess_connect;	/* SSL new conn - started */
		int sess_connect_renegotiate;/* SSL reneg - requested */
		int sess_connect_good;	/* SSL new conne/reneg - finished */
		int sess_accept;	/* SSL new accept - started */
		int sess_accept_renegotiate;/* SSL reneg - requested */
		int sess_accept_good;	/* SSL accept/reneg - finished */
		int sess_miss;		/* session lookup misses  */
		int sess_timeout;	/* reuse attempt on timeouted session */
		int sess_cache_full;	/* session removed due to full cache */
		int sess_hit;		/* session reuse actually done */
		int sess_cb_hit;	/* session-id that was not
					 * in the cache was
					 * passed back via the callback.  This
					 * indicates that the application is
					 * supplying session-id's from other
					 * processes - spooky :-) */
		} stats;
d360 1
a360 1
	int references;
d363 8
a370 4
	int (*app_verify_callback)(X509_STORE_CTX *, void *);
	void *app_verify_arg;
	/* before OpenSSL 0.9.7, 'app_verify_arg' was ignored
	 * ('app_verify_callback' was called with just one argument) */
d373 1
a373 4
	pem_password_cb *default_passwd_callback;

	/* Default password callback user data. */
	void *default_passwd_callback_userdata;
d376 1
a376 1
	int (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey);
d378 2
a379 1
	CRYPTO_EX_DATA ex_data;
d381 1
a381 3
	const EVP_MD *rsa_md5;/* For SSLv2 - name is 'ssl2-md5' */
	const EVP_MD *md5;	/* For SSLv3/TLSv1 'ssl3-md5' */
	const EVP_MD *sha1;   /* For SSLv3/TLSv1 'ssl3->sha1' */
d383 1
a383 30
	STACK_OF(X509) *extra_certs;
	STACK_OF(SSL_COMP) *comp_methods; /* stack of SSL_COMP, SSLv3/TLSv1 */


	/* Default values used when no per-SSL value is defined follow */

	void (*info_callback)(const SSL *ssl,int type,int val); /* used if SSL's info_callback is NULL */

	/* what we put in client cert requests */
	STACK_OF(X509_NAME) *client_CA;


	/* Default values to use in SSL structures follow (these are copied by SSL_new) */

	unsigned long options;
	unsigned long mode;
	long max_cert_list;

	struct cert_st /* CERT */ *cert;
	int read_ahead;

	/* callback that allows applications to peek at protocol messages */
	void (*msg_callback)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg);
	void *msg_callback_arg;

	int verify_mode;
	int verify_depth;
	unsigned int sid_ctx_length;
	unsigned char sid_ctx[SSL_MAX_SID_CTX_LENGTH];
	int (*default_verify_callback)(int ok,X509_STORE_CTX *ctx); /* called 'verify_callback' in the SSL */
d385 4
a388 8
	/* Default generate session ID callback. */
	GEN_SESSION_CB generate_session_id;

	int purpose;		/* Purpose setting */
	int trust;		/* Trust setting */

	int quiet_shutdown;
	};
d400 17
a416 25
  struct lhash_st *SSL_CTX_sessions(SSL_CTX *ctx);
#define SSL_CTX_sess_number(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_NUMBER,0,NULL)
#define SSL_CTX_sess_connect(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_CONNECT,0,NULL)
#define SSL_CTX_sess_connect_good(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_CONNECT_GOOD,0,NULL)
#define SSL_CTX_sess_connect_renegotiate(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_CONNECT_RENEGOTIATE,0,NULL)
#define SSL_CTX_sess_accept(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_ACCEPT,0,NULL)
#define SSL_CTX_sess_accept_renegotiate(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_ACCEPT_RENEGOTIATE,0,NULL)
#define SSL_CTX_sess_accept_good(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_ACCEPT_GOOD,0,NULL)
#define SSL_CTX_sess_hits(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_HIT,0,NULL)
#define SSL_CTX_sess_cb_hits(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_CB_HIT,0,NULL)
#define SSL_CTX_sess_misses(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_MISSES,0,NULL)
#define SSL_CTX_sess_timeouts(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_TIMEOUTS,0,NULL)
#define SSL_CTX_sess_cache_full(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SESS_CACHE_FULL,0,NULL)
d424 5
d431 2
d442 5
a446 4
#define SSL_want_nothing(s)	(SSL_want(s) == SSL_NOTHING)
#define SSL_want_read(s)	(SSL_want(s) == SSL_READING)
#define SSL_want_write(s)	(SSL_want(s) == SSL_WRITING)
#define SSL_want_x509_lookup(s)	(SSL_want(s) == SSL_X509_LOOKUP)
d448 1
a448 1
struct ssl_st
d450 4
a453 3
	/* protocol version
	 * (one of SSL2_VERSION, SSL3_VERSION, TLS1_VERSION)
	 */
d463 1
a463 1
#ifndef OPENSSL_NO_BIO
d466 1
a466 1
	BIO *bbio; /* used during session-id reuse to concatenate
d483 3
a485 16
	/* Imagine that here's a boolean member "init" that is
	 * switched as soon as SSL_set_{accept/connect}_state
	 * is called for the first time, so that "state" and
	 * "handshake_func" are properly initialized.  But as
	 * handshake_func is == 0 until then, we use this
	 * test instead of an "init" member.
	 */

	int server;	/* are we the server side? - mostly used by SSL_clear*/

	int new_session;/* 1 if we are to use a new session.
	                 * 2 if we are a server and are inside a handshake
	                 *   (i.e. not just sending a HelloRequest)
	                 * NB: For servers, the 'new' session may actually be a previously
	                 * cached session or even the previous session unless
	                 * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is set */
a492 1
	void *init_msg;   	/* pointer to handshake message body, set by ssl3_get_message() */
d500 2
a501 9
	struct ssl2_state_st *s2; /* SSLv2 variables */
	struct ssl3_state_st *s3; /* SSLv3 variables */

	int read_ahead;		/* Read as many input bytes as possible
	               	 	 * (for non-blocking reads) */

	/* callback that allows applications to peek at protocol messages */
	void (*msg_callback)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg);
	void *msg_callback_arg;
d503 1
a505 3
	int purpose;		/* Purpose setting */
	int trust;		/* Trust setting */

d507 2
a508 2
	STACK_OF(SSL_CIPHER) *cipher_list;
	STACK_OF(SSL_CIPHER) *cipher_list_by_id;
d510 1
a510 1
	/* These are the ones being used, the ones in SSL_SESSION are
d514 2
a515 6
	const EVP_MD *read_hash;		/* used for mac generation */
#ifndef OPENSSL_NO_COMP
	COMP_CTX *expand;			/* uncompress */
#else
	char *expand;
#endif
d518 2
a519 6
	const EVP_MD *write_hash;		/* used for mac generation */
#ifndef OPENSSL_NO_COMP
	COMP_CTX *compress;			/* compression */
#else
	char *compress;	
#endif
a526 5
	/* the session_id_context is used to ensure sessions are only reused
	 * in the appropriate context */
	unsigned int sid_ctx_length;
	unsigned char sid_ctx[SSL_MAX_SID_CTX_LENGTH];

a529 3
	/* Default generate session ID callback. */
	GEN_SESSION_CB generate_session_id;

d533 2
a534 4
	int verify_depth;
	int (*verify_callback)(int ok,X509_STORE_CTX *ctx); /* fail if callback returns 0 */

	void (*info_callback)(const SSL *ssl,int type,int val); /* optional informational callback */
a538 4
#ifndef OPENSSL_NO_KRB5
	KSSL_CTX *kssl_ctx;     /* Kerberos 5 context */
#endif	/* OPENSSL_NO_KRB5 */

d549 1
a549 1
	STACK_OF(X509_NAME) *client_CA;
d552 1
a552 3
	unsigned long options; /* protocol behaviour */
	unsigned long mode; /* API behaviour */
	long max_cert_list;
d554 1
a554 7
	int client_version;	/* what was passed, used for
				 * SSLv3/TLS rollback check */
	};

#ifdef __cplusplus
}
#endif
d556 4
a559 4
#include <openssl/ssl2.h>
#include <openssl/ssl3.h>
#include <openssl/tls1.h> /* This is mostly sslv3 with a few tweaks */
#include <openssl/ssl23.h>
d561 1
a561 5
#ifdef  __cplusplus
extern "C" {
#endif

/* compatibility */
d570 1
a570 1
 * used to indicate where we are up to in the SSL connection establishment.
a611 7
/* Obtain latest Finished message
 *   -- that we sent (SSL_get_finished)
 *   -- that we expected from peer (SSL_get_peer_finished).
 * Returns length (0 == no Finished so far), copies up to 'count' bytes. */
size_t SSL_get_finished(SSL *s, void *buf, size_t count);
size_t SSL_get_peer_finished(SSL *s, void *buf, size_t count);

d619 1
a619 4
#define OpenSSL_add_ssl_algorithms()	SSL_library_init()
#define SSLeay_add_ssl_algorithms()	SSL_library_init()

/* this is for backward compatibility */
d627 1
a627 1
/* More backward compatibility */
d641 4
d651 4
a654 4
#define PEM_read_SSL_SESSION(fp,x,cb,u) (SSL_SESSION *)PEM_ASN1_read( \
	(char *(*)())d2i_SSL_SESSION,PEM_STRING_SSL_SESSION,fp,(char **)x,cb,u)
#define PEM_read_bio_SSL_SESSION(bp,x,cb,u) (SSL_SESSION *)PEM_ASN1_read_bio( \
	(char *(*)())d2i_SSL_SESSION,PEM_STRING_SSL_SESSION,bp,(char **)x,cb,u)
d657 1
a657 1
		PEM_STRING_SSL_SESSION,fp, (char *)x, NULL,NULL,0,NULL,NULL)
d660 1
a660 1
		PEM_STRING_SSL_SESSION,bp, (char *)x, NULL,NULL,0,NULL,NULL)
a662 1
#define SSL_AD_REASON_OFFSET		1000
d682 1
a682 1
#define SSL_AD_EXPORT_RESTRICTION	TLS1_AD_EXPORT_RESTRICTION/* fatal */
d686 1
a686 1
#define SSL_AD_USER_CANCELLED		TLS1_AD_USER_CANCELLED
d694 1
a694 1
#define SSL_ERROR_SYSCALL		5 /* look at error stack/return value/errno */
a696 1
#define SSL_ERROR_WANT_ACCEPT		8
d703 1
a703 1

a708 31
#define SSL_CTRL_GET_FLAGS			11
#define SSL_CTRL_EXTRA_CHAIN_CERT		12

#define SSL_CTRL_SET_MSG_CALLBACK               13
#define SSL_CTRL_SET_MSG_CALLBACK_ARG           14

/* Stats */
#define SSL_CTRL_SESS_NUMBER			20
#define SSL_CTRL_SESS_CONNECT			21
#define SSL_CTRL_SESS_CONNECT_GOOD		22
#define SSL_CTRL_SESS_CONNECT_RENEGOTIATE	23
#define SSL_CTRL_SESS_ACCEPT			24
#define SSL_CTRL_SESS_ACCEPT_GOOD		25
#define SSL_CTRL_SESS_ACCEPT_RENEGOTIATE	26
#define SSL_CTRL_SESS_HIT			27
#define SSL_CTRL_SESS_CB_HIT			28
#define SSL_CTRL_SESS_MISSES			29
#define SSL_CTRL_SESS_TIMEOUTS			30
#define SSL_CTRL_SESS_CACHE_FULL		31
#define SSL_CTRL_OPTIONS			32
#define SSL_CTRL_MODE				33

#define SSL_CTRL_GET_READ_AHEAD			40
#define SSL_CTRL_SET_READ_AHEAD			41
#define SSL_CTRL_SET_SESS_CACHE_SIZE		42
#define SSL_CTRL_GET_SESS_CACHE_SIZE		43
#define SSL_CTRL_SET_SESS_CACHE_MODE		44
#define SSL_CTRL_GET_SESS_CACHE_MODE		45

#define SSL_CTRL_GET_MAX_CERT_LIST		50
#define SSL_CTRL_SET_MAX_CERT_LIST		51
d726 8
a733 6
#define SSL_need_tmp_RSA(ssl) \
	SSL_ctrl(ssl,SSL_CTRL_NEED_TMP_RSA,0,NULL)
#define SSL_set_tmp_rsa(ssl,rsa) \
	SSL_ctrl(ssl,SSL_CTRL_SET_TMP_RSA,0,(char *)rsa)
#define SSL_set_tmp_dh(ssl,dh) \
	SSL_ctrl(ssl,SSL_CTRL_SET_TMP_DH,0,(char *)dh)
d735 1
a735 2
#define SSL_CTX_add_extra_chain_cert(ctx,x509) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_EXTRA_CHAIN_CERT,0,(char *)x509)
d737 1
a737 1
#ifndef OPENSSL_NO_BIO
d747 1
a747 1
int	SSL_CTX_set_cipher_list(SSL_CTX *,const char *str);
d750 1
a750 7
long SSL_CTX_set_timeout(SSL_CTX *ctx,long t);
long SSL_CTX_get_timeout(SSL_CTX *ctx);
X509_STORE *SSL_CTX_get_cert_store(SSL_CTX *);
void SSL_CTX_set_cert_store(SSL_CTX *,X509_STORE *);
int SSL_want(SSL *s);
int	SSL_clear(SSL *s);

d756 1
a756 1
const char *	SSL_CIPHER_get_name(SSL_CIPHER *c);
d759 1
a759 3
int	SSL_get_rfd(SSL *s);
int	SSL_get_wfd(SSL *s);
const char  * SSL_get_cipher_list(SSL *s,int n);
d763 1
a763 1
#ifndef OPENSSL_NO_SOCK
d768 1
a768 1
#ifndef OPENSSL_NO_BIO
d773 1
a773 1
int	SSL_set_cipher_list(SSL *s, const char *str);
d776 2
a777 6
int	SSL_get_verify_depth(SSL *s);
int	(*SSL_get_verify_callback(SSL *s))(int,X509_STORE_CTX *);
void	SSL_set_verify(SSL *s, int mode,
		       int (*callback)(int ok,X509_STORE_CTX *ctx));
void	SSL_set_verify_depth(SSL *s, int depth);
#ifndef OPENSSL_NO_RSA
a778 1
#endif
d783 1
a783 21
int	SSL_use_certificate_ASN1(SSL *ssl, unsigned char *d, int len);

#ifndef OPENSSL_NO_STDIO
int	SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type);
int	SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type);
int	SSL_use_certificate_file(SSL *ssl, const char *file, int type);
int	SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type);
int	SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type);
int	SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type);
int	SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file); /* PEM type */
STACK_OF(X509_NAME) *SSL_load_client_CA_file(const char *file);
int	SSL_add_file_cert_subjects_to_stack(STACK_OF(X509_NAME) *stackCAs,
					    const char *file);
#ifndef OPENSSL_SYS_WIN32
#ifndef OPENSSL_SYS_VMS
#ifndef OPENSSL_SYS_MACINTOSH_CLASSIC /* XXXXX: Better scheme needed! [was: #ifndef MAC_OS_pre_X] */
int	SSL_add_dir_cert_subjects_to_stack(STACK_OF(X509_NAME) *stackCAs,
					   const char *dir);
#endif
#endif
#endif
d785 8
d795 1
d797 4
a800 4
const char *SSL_state_string(const SSL *s);
const char *SSL_rstate_string(const SSL *s);
const char *SSL_state_string_long(const SSL *s);
const char *SSL_rstate_string_long(const SSL *s);
d810 1
a810 1
#ifndef OPENSSL_NO_FP_API
d813 1
a813 1
#ifndef OPENSSL_NO_BIO
a820 4
int	SSL_CTX_set_generate_session_id(SSL_CTX *, GEN_SESSION_CB);
int	SSL_set_generate_session_id(SSL *, GEN_SESSION_CB);
int	SSL_has_matching_session_id(const SSL *ssl, const unsigned char *id,
					unsigned int id_len);
d827 1
a827 1
STACK_OF(X509) *SSL_get_peer_cert_chain(SSL *s);
d830 3
a832 7
int SSL_CTX_get_verify_depth(SSL_CTX *ctx);
int (*SSL_CTX_get_verify_callback(SSL_CTX *ctx))(int,X509_STORE_CTX *);
void SSL_CTX_set_verify(SSL_CTX *ctx,int mode,
			int (*callback)(int, X509_STORE_CTX *));
void SSL_CTX_set_verify_depth(SSL_CTX *ctx,int depth);
void SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx, int (*cb)(X509_STORE_CTX *,void *), void *arg);
#ifndef OPENSSL_NO_RSA
a833 1
#endif
d841 1
a841 2
void SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, pem_password_cb *cb);
void SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx, void *u);
a845 3
int	SSL_CTX_set_session_id_context(SSL_CTX *ctx,const unsigned char *sid_ctx,
				       unsigned int sid_ctx_len);

d847 1
a847 8
int	SSL_set_session_id_context(SSL *ssl,const unsigned char *sid_ctx,
				   unsigned int sid_ctx_len);

int SSL_CTX_set_purpose(SSL_CTX *s, int purpose);
int SSL_set_purpose(SSL *s, int purpose);
int SSL_CTX_set_trust(SSL_CTX *s, int trust);
int SSL_set_trust(SSL *s, int trust);

d851 5
a855 7
int 	SSL_read(SSL *ssl,void *buf,int num);
int 	SSL_peek(SSL *ssl,void *buf,int num);
int 	SSL_write(SSL *ssl,const void *buf,int num);
long	SSL_ctrl(SSL *ssl,int cmd, long larg, void *parg);
long	SSL_callback_ctrl(SSL *, int, void (*)());
long	SSL_CTX_ctrl(SSL_CTX *ctx,int cmd, long larg, void *parg);
long	SSL_CTX_callback_ctrl(SSL_CTX *, int, void (*)());
d858 1
a858 1
const char *SSL_get_version(SSL *s);
d879 1
a879 1
STACK_OF(SSL_CIPHER) *SSL_get_ciphers(SSL *s);
a882 1
int SSL_renegotiate_pending(SSL *s);
d887 9
a895 9
const char *SSL_alert_type_string_long(int value);
const char *SSL_alert_type_string(int value);
const char *SSL_alert_desc_string_long(int value);
const char *SSL_alert_desc_string(int value);

void SSL_set_client_CA_list(SSL *s, STACK_OF(X509_NAME) *list);
void SSL_CTX_set_client_CA_list(SSL_CTX *ctx, STACK_OF(X509_NAME) *list);
STACK_OF(X509_NAME) *SSL_get_client_CA_list(SSL *s);
STACK_OF(X509_NAME) *SSL_CTX_get_client_CA_list(SSL_CTX *s);
d904 1
a904 1
int SSL_library_init(void );
d907 1
a907 1
STACK_OF(X509_NAME) *SSL_dup_CA_list(STACK_OF(X509_NAME) *sk);
d922 1
a922 3
int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,
	const char *CApath);
#define SSL_get0_session SSL_get_session /* just peek at pointer */
a923 1
SSL_SESSION *SSL_get1_session(SSL *ssl); /* obtain a reference count */
d925 2
a926 3
void SSL_set_info_callback(SSL *ssl,
			   void (*cb)(const SSL *ssl,int type,int val));
void (*SSL_get_info_callback(SSL *ssl))(const SSL *ssl,int type,int val);
d932 221
a1152 58
int SSL_set_ex_data(SSL *ssl,int idx,void *data);
void *SSL_get_ex_data(SSL *ssl,int idx);
int SSL_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
	CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);

int SSL_SESSION_set_ex_data(SSL_SESSION *ss,int idx,void *data);
void *SSL_SESSION_get_ex_data(SSL_SESSION *ss,int idx);
int SSL_SESSION_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
	CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);

int SSL_CTX_set_ex_data(SSL_CTX *ssl,int idx,void *data);
void *SSL_CTX_get_ex_data(SSL_CTX *ssl,int idx);
int SSL_CTX_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
	CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);

int SSL_get_ex_data_X509_STORE_CTX_idx(void );

#define SSL_CTX_sess_set_cache_size(ctx,t) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SESS_CACHE_SIZE,t,NULL)
#define SSL_CTX_sess_get_cache_size(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_GET_SESS_CACHE_SIZE,0,NULL)
#define SSL_CTX_set_session_cache_mode(ctx,m) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_SESS_CACHE_MODE,m,NULL)
#define SSL_CTX_get_session_cache_mode(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_GET_SESS_CACHE_MODE,0,NULL)

#define SSL_CTX_get_default_read_ahead(ctx) SSL_CTX_get_read_ahead(ctx)
#define SSL_CTX_set_default_read_ahead(ctx,m) SSL_CTX_set_read_ahead(ctx,m)
#define SSL_CTX_get_read_ahead(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_GET_READ_AHEAD,0,NULL)
#define SSL_CTX_set_read_ahead(ctx,m) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_READ_AHEAD,m,NULL)
#define SSL_CTX_get_max_cert_list(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_GET_MAX_CERT_LIST,0,NULL)
#define SSL_CTX_set_max_cert_list(ctx,m) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_MAX_CERT_LIST,m,NULL)
#define SSL_get_max_cert_list(ssl) \
	SSL_ctrl(ssl,SSL_CTRL_GET_MAX_CERT_LIST,0,NULL)
#define SSL_set_max_cert_list(ssl,m) \
	SSL_ctrl(ssl,SSL_CTRL_SET_MAX_CERT_LIST,m,NULL)

     /* NB: the keylength is only applicable when is_export is true */
#ifndef OPENSSL_NO_RSA
void SSL_CTX_set_tmp_rsa_callback(SSL_CTX *ctx,
				  RSA *(*cb)(SSL *ssl,int is_export,
					     int keylength));

void SSL_set_tmp_rsa_callback(SSL *ssl,
				  RSA *(*cb)(SSL *ssl,int is_export,
					     int keylength));
#endif
#ifndef OPENSSL_NO_DH
void SSL_CTX_set_tmp_dh_callback(SSL_CTX *ctx,
				 DH *(*dh)(SSL *ssl,int is_export,
					   int keylength));
void SSL_set_tmp_dh_callback(SSL *ssl,
				 DH *(*dh)(SSL *ssl,int is_export,
					   int keylength));
a1154 4
#ifndef OPENSSL_NO_COMP
int SSL_COMP_add_compression_method(int id,COMP_METHOD *cm);
#else
int SSL_COMP_add_compression_method(int id,char *cm);
a1157 5
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_SSL_strings(void);

a1180 1
#define SSL_F_SSL23_PEEK				 237
a1185 1
#define SSL_F_SSL2_PEEK					 234
a1186 1
#define SSL_F_SSL2_READ_INTERNAL			 236
a1189 1
#define SSL_F_SSL3_CALLBACK_CTRL			 233
a1193 1
#define SSL_F_SSL3_CTRL					 213
a1195 1
#define SSL_F_SSL3_GENERATE_KEY_BLOCK			 238
a1208 1
#define SSL_F_SSL3_PEEK					 235
a1220 2
#define SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK	 215
#define SSL_F_SSL_ADD_FILE_CERT_SUBJECTS_TO_STACK	 216
a1222 3
#define SSL_F_SSL_CERT_DUP				 221
#define SSL_F_SSL_CERT_INST				 222
#define SSL_F_SSL_CERT_INSTANTIATE			 214
d1225 45
a1269 62
#define SSL_F_SSL_CIPHER_PROCESS_RULESTR		 230
#define SSL_F_SSL_CIPHER_STRENGTH_SORT			 231
#define SSL_F_SSL_CLEAR					 164
#define SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD		 165
#define SSL_F_SSL_CREATE_CIPHER_LIST			 166
#define SSL_F_SSL_CTRL					 232
#define SSL_F_SSL_CTX_CHECK_PRIVATE_KEY			 168
#define SSL_F_SSL_CTX_NEW				 169
#define SSL_F_SSL_CTX_SET_PURPOSE			 226
#define SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT		 219
#define SSL_F_SSL_CTX_SET_SSL_VERSION			 170
#define SSL_F_SSL_CTX_SET_TRUST				 229
#define SSL_F_SSL_CTX_USE_CERTIFICATE			 171
#define SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1		 172
#define SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE	 220
#define SSL_F_SSL_CTX_USE_CERTIFICATE_FILE		 173
#define SSL_F_SSL_CTX_USE_PRIVATEKEY			 174
#define SSL_F_SSL_CTX_USE_PRIVATEKEY_ASN1		 175
#define SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE		 176
#define SSL_F_SSL_CTX_USE_RSAPRIVATEKEY			 177
#define SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_ASN1		 178
#define SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE		 179
#define SSL_F_SSL_DO_HANDSHAKE				 180
#define SSL_F_SSL_GET_NEW_SESSION			 181
#define SSL_F_SSL_GET_PREV_SESSION			 217
#define SSL_F_SSL_GET_SERVER_SEND_CERT			 182
#define SSL_F_SSL_GET_SIGN_PKEY				 183
#define SSL_F_SSL_INIT_WBIO_BUFFER			 184
#define SSL_F_SSL_LOAD_CLIENT_CA_FILE			 185
#define SSL_F_SSL_NEW					 186
#define SSL_F_SSL_READ					 223
#define SSL_F_SSL_RSA_PRIVATE_DECRYPT			 187
#define SSL_F_SSL_RSA_PUBLIC_ENCRYPT			 188
#define SSL_F_SSL_SESSION_NEW				 189
#define SSL_F_SSL_SESSION_PRINT_FP			 190
#define SSL_F_SSL_SESS_CERT_NEW				 225
#define SSL_F_SSL_SET_CERT				 191
#define SSL_F_SSL_SET_FD				 192
#define SSL_F_SSL_SET_PKEY				 193
#define SSL_F_SSL_SET_PURPOSE				 227
#define SSL_F_SSL_SET_RFD				 194
#define SSL_F_SSL_SET_SESSION				 195
#define SSL_F_SSL_SET_SESSION_ID_CONTEXT		 218
#define SSL_F_SSL_SET_TRUST				 228
#define SSL_F_SSL_SET_WFD				 196
#define SSL_F_SSL_SHUTDOWN				 224
#define SSL_F_SSL_UNDEFINED_FUNCTION			 197
#define SSL_F_SSL_USE_CERTIFICATE			 198
#define SSL_F_SSL_USE_CERTIFICATE_ASN1			 199
#define SSL_F_SSL_USE_CERTIFICATE_FILE			 200
#define SSL_F_SSL_USE_PRIVATEKEY			 201
#define SSL_F_SSL_USE_PRIVATEKEY_ASN1			 202
#define SSL_F_SSL_USE_PRIVATEKEY_FILE			 203
#define SSL_F_SSL_USE_RSAPRIVATEKEY			 204
#define SSL_F_SSL_USE_RSAPRIVATEKEY_ASN1		 205
#define SSL_F_SSL_USE_RSAPRIVATEKEY_FILE		 206
#define SSL_F_SSL_VERIFY_CERT_CHAIN			 207
#define SSL_F_SSL_WRITE					 208
#define SSL_F_TLS1_CHANGE_CIPHER_STATE			 209
#define SSL_F_TLS1_ENC					 210
#define SSL_F_TLS1_SETUP_KEY_BLOCK			 211
#define SSL_F_WRITE_PENDING				 212
a1272 1
#define SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT 272
d1277 1
a1284 2
#define SSL_R_BAD_HELLO_REQUEST				 105
#define SSL_R_BAD_LENGTH				 271
d1314 77
a1390 102
#define SSL_R_COMPRESSION_LIBRARY_ERROR			 142
#define SSL_R_CONNECTION_ID_IS_DIFFERENT		 143
#define SSL_R_CONNECTION_TYPE_NOT_SET			 144
#define SSL_R_DATA_BETWEEN_CCS_AND_FINISHED		 145
#define SSL_R_DATA_LENGTH_TOO_LONG			 146
#define SSL_R_DECRYPTION_FAILED				 147
#define SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC	 1109
#define SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG		 148
#define SSL_R_DIGEST_CHECK_FAILED			 149
#define SSL_R_ENCRYPTED_LENGTH_TOO_LONG			 150
#define SSL_R_ERROR_GENERATING_TMP_RSA_KEY		 1092
#define SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST		 151
#define SSL_R_EXCESSIVE_MESSAGE_SIZE			 152
#define SSL_R_EXTRA_DATA_IN_MESSAGE			 153
#define SSL_R_GOT_A_FIN_BEFORE_A_CCS			 154
#define SSL_R_HTTPS_PROXY_REQUEST			 155
#define SSL_R_HTTP_REQUEST				 156
#define SSL_R_ILLEGAL_PADDING				 1110
#define SSL_R_INVALID_CHALLENGE_LENGTH			 158
#define SSL_R_INVALID_COMMAND				 280
#define SSL_R_INVALID_PURPOSE				 278
#define SSL_R_INVALID_TRUST				 279
#define SSL_R_KRB5					 1104
#define SSL_R_KRB5_C_CC_PRINC				 1094
#define SSL_R_KRB5_C_GET_CRED				 1095
#define SSL_R_KRB5_C_INIT				 1096
#define SSL_R_KRB5_C_MK_REQ				 1097
#define SSL_R_KRB5_S_BAD_TICKET				 1098
#define SSL_R_KRB5_S_INIT				 1099
#define SSL_R_KRB5_S_RD_REQ				 1108
#define SSL_R_KRB5_S_TKT_EXPIRED			 1105
#define SSL_R_KRB5_S_TKT_NYV				 1106
#define SSL_R_KRB5_S_TKT_SKEW				 1107
#define SSL_R_LENGTH_MISMATCH				 159
#define SSL_R_LENGTH_TOO_SHORT				 160
#define SSL_R_LIBRARY_BUG				 274
#define SSL_R_LIBRARY_HAS_NO_CIPHERS			 161
#define SSL_R_MESSAGE_TOO_LONG				 1111
#define SSL_R_MISSING_DH_DSA_CERT			 162
#define SSL_R_MISSING_DH_KEY				 163
#define SSL_R_MISSING_DH_RSA_CERT			 164
#define SSL_R_MISSING_DSA_SIGNING_CERT			 165
#define SSL_R_MISSING_EXPORT_TMP_DH_KEY			 166
#define SSL_R_MISSING_EXPORT_TMP_RSA_KEY		 167
#define SSL_R_MISSING_RSA_CERTIFICATE			 168
#define SSL_R_MISSING_RSA_ENCRYPTING_CERT		 169
#define SSL_R_MISSING_RSA_SIGNING_CERT			 170
#define SSL_R_MISSING_TMP_DH_KEY			 171
#define SSL_R_MISSING_TMP_RSA_KEY			 172
#define SSL_R_MISSING_TMP_RSA_PKEY			 173
#define SSL_R_MISSING_VERIFY_MESSAGE			 174
#define SSL_R_NON_SSLV2_INITIAL_PACKET			 175
#define SSL_R_NO_CERTIFICATES_RETURNED			 176
#define SSL_R_NO_CERTIFICATE_ASSIGNED			 177
#define SSL_R_NO_CERTIFICATE_RETURNED			 178
#define SSL_R_NO_CERTIFICATE_SET			 179
#define SSL_R_NO_CERTIFICATE_SPECIFIED			 180
#define SSL_R_NO_CIPHERS_AVAILABLE			 181
#define SSL_R_NO_CIPHERS_PASSED				 182
#define SSL_R_NO_CIPHERS_SPECIFIED			 183
#define SSL_R_NO_CIPHER_LIST				 184
#define SSL_R_NO_CIPHER_MATCH				 185
#define SSL_R_NO_CLIENT_CERT_RECEIVED			 186
#define SSL_R_NO_COMPRESSION_SPECIFIED			 187
#define SSL_R_NO_METHOD_SPECIFIED			 188
#define SSL_R_NO_PRIVATEKEY				 189
#define SSL_R_NO_PRIVATE_KEY_ASSIGNED			 190
#define SSL_R_NO_PROTOCOLS_AVAILABLE			 191
#define SSL_R_NO_PUBLICKEY				 192
#define SSL_R_NO_SHARED_CIPHER				 193
#define SSL_R_NO_VERIFY_CALLBACK			 194
#define SSL_R_NULL_SSL_CTX				 195
#define SSL_R_NULL_SSL_METHOD_PASSED			 196
#define SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED		 197
#define SSL_R_PACKET_LENGTH_TOO_LONG			 198
#define SSL_R_PATH_TOO_LONG				 270
#define SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE		 199
#define SSL_R_PEER_ERROR				 200
#define SSL_R_PEER_ERROR_CERTIFICATE			 201
#define SSL_R_PEER_ERROR_NO_CERTIFICATE			 202
#define SSL_R_PEER_ERROR_NO_CIPHER			 203
#define SSL_R_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE	 204
#define SSL_R_PRE_MAC_LENGTH_TOO_LONG			 205
#define SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS		 206
#define SSL_R_PROTOCOL_IS_SHUTDOWN			 207
#define SSL_R_PUBLIC_KEY_ENCRYPT_ERROR			 208
#define SSL_R_PUBLIC_KEY_IS_NOT_RSA			 209
#define SSL_R_PUBLIC_KEY_NOT_RSA			 210
#define SSL_R_READ_BIO_NOT_SET				 211
#define SSL_R_READ_WRONG_PACKET_TYPE			 212
#define SSL_R_RECORD_LENGTH_MISMATCH			 213
#define SSL_R_RECORD_TOO_LARGE				 214
#define SSL_R_RECORD_TOO_SMALL				 1093
#define SSL_R_REQUIRED_CIPHER_MISSING			 215
#define SSL_R_REUSE_CERT_LENGTH_NOT_ZERO		 216
#define SSL_R_REUSE_CERT_TYPE_NOT_ZERO			 217
#define SSL_R_REUSE_CIPHER_LIST_NOT_ZERO		 218
#define SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED		 277
#define SSL_R_SHORT_READ				 219
#define SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE	 220
#define SSL_R_SSL23_DOING_SESSION_ID_REUSE		 221
#define SSL_R_SSL3_SESSION_ID_TOO_SHORT			 222
d1400 4
a1403 4
#define SSL_R_SSLV3_ALERT_PEER_ERROR_CERTIFICATE	 223
#define SSL_R_SSLV3_ALERT_PEER_ERROR_NO_CERTIFICATE	 224
#define SSL_R_SSLV3_ALERT_PEER_ERROR_NO_CIPHER		 225
#define SSL_R_SSLV3_ALERT_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE 226
d1405 1
a1405 1
#define SSL_R_SSLV3_ALERT_UNKNOWN_REMOTE_ERROR_TYPE	 227
d1407 42
a1448 61
#define SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION	 228
#define SSL_R_SSL_HANDSHAKE_FAILURE			 229
#define SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS		 230
#define SSL_R_SSL_SESSION_ID_CALLBACK_FAILED		 1102
#define SSL_R_SSL_SESSION_ID_CONFLICT			 1103
#define SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG		 273
#define SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH		 1101
#define SSL_R_SSL_SESSION_ID_IS_DIFFERENT		 231
#define SSL_R_TLSV1_ALERT_ACCESS_DENIED			 1049
#define SSL_R_TLSV1_ALERT_DECODE_ERROR			 1050
#define SSL_R_TLSV1_ALERT_DECRYPTION_FAILED		 1021
#define SSL_R_TLSV1_ALERT_DECRYPT_ERROR			 1051
#define SSL_R_TLSV1_ALERT_EXPORT_RESTRICTION		 1060
#define SSL_R_TLSV1_ALERT_INSUFFICIENT_SECURITY		 1071
#define SSL_R_TLSV1_ALERT_INTERNAL_ERROR		 1080
#define SSL_R_TLSV1_ALERT_NO_RENEGOTIATION		 1100
#define SSL_R_TLSV1_ALERT_PROTOCOL_VERSION		 1070
#define SSL_R_TLSV1_ALERT_RECORD_OVERFLOW		 1022
#define SSL_R_TLSV1_ALERT_UNKNOWN_CA			 1048
#define SSL_R_TLSV1_ALERT_USER_CANCELLED		 1090
#define SSL_R_TLS_CLIENT_CERT_REQ_WITH_ANON_CIPHER	 232
#define SSL_R_TLS_PEER_DID_NOT_RESPOND_WITH_CERTIFICATE_LIST 233
#define SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG	 234
#define SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER		 235
#define SSL_R_UNABLE_TO_DECODE_DH_CERTS			 236
#define SSL_R_UNABLE_TO_EXTRACT_PUBLIC_KEY		 237
#define SSL_R_UNABLE_TO_FIND_DH_PARAMETERS		 238
#define SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS	 239
#define SSL_R_UNABLE_TO_FIND_SSL_METHOD			 240
#define SSL_R_UNABLE_TO_LOAD_SSL2_MD5_ROUTINES		 241
#define SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES		 242
#define SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES		 243
#define SSL_R_UNEXPECTED_MESSAGE			 244
#define SSL_R_UNEXPECTED_RECORD				 245
#define SSL_R_UNINITIALIZED				 276
#define SSL_R_UNKNOWN_ALERT_TYPE			 246
#define SSL_R_UNKNOWN_CERTIFICATE_TYPE			 247
#define SSL_R_UNKNOWN_CIPHER_RETURNED			 248
#define SSL_R_UNKNOWN_CIPHER_TYPE			 249
#define SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE			 250
#define SSL_R_UNKNOWN_PKEY_TYPE				 251
#define SSL_R_UNKNOWN_PROTOCOL				 252
#define SSL_R_UNKNOWN_REMOTE_ERROR_TYPE			 253
#define SSL_R_UNKNOWN_SSL_VERSION			 254
#define SSL_R_UNKNOWN_STATE				 255
#define SSL_R_UNSUPPORTED_CIPHER			 256
#define SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM		 257
#define SSL_R_UNSUPPORTED_OPTION			 1091
#define SSL_R_UNSUPPORTED_PROTOCOL			 258
#define SSL_R_UNSUPPORTED_SSL_VERSION			 259
#define SSL_R_WRITE_BIO_NOT_SET				 260
#define SSL_R_WRONG_CIPHER_RETURNED			 261
#define SSL_R_WRONG_MESSAGE_TYPE			 262
#define SSL_R_WRONG_NUMBER_OF_KEY_BITS			 263
#define SSL_R_WRONG_SIGNATURE_LENGTH			 264
#define SSL_R_WRONG_SIGNATURE_SIZE			 265
#define SSL_R_WRONG_SSL_VERSION				 266
#define SSL_R_WRONG_VERSION_NUMBER			 267
#define SSL_R_X509_LIB					 268
#define SSL_R_X509_VERIFICATION_SETUP_PROBLEMS		 269

d1453 1
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d256 1
a256 1
#define SSL_TXT_AES		"AES"
a268 17
/*
 * COMPLEMENTOF* definitions. These identifiers are used to (de-select)
 * ciphers normally not being used.
 * Example: "RC4" will activate all ciphers using RC4 including ciphers
 * without authentication, which would normally disabled by DEFAULT (due
 * the "!ADH" being part of default). Therefore "RC4:!COMPLEMENTOFDEFAULT"
 * will make sure that it is also disabled in the specific selection.
 * COMPLEMENTOF* identifiers are portable between version, as adjustments
 * to the default cipher setup will also be included here.
 *
 * COMPLEMENTOFDEFAULT does not experience the same special treatment that
 * DEFAULT gets, as only selection is being done and no sorting as needed
 * for DEFAULT.
 */
#define SSL_TXT_CMPALL		"COMPLEMENTOFALL"
#define SSL_TXT_CMPDEF		"COMPLEMENTOFDEFAULT"

a431 1

a441 13
/* Disable SSL 3.0/TLS 1.0 CBC vulnerability workaround that was added
 * in OpenSSL 0.9.6d.  Usually (depending on the application protocol)
 * the workaround is not needed.  Unfortunately some broken SSL/TLS
 * implementations cannot handle it at all, which is why we include
 * it in SSL_OP_ALL. */
#define SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS              0x00000800L /* added in 0.9.6e */

/* SSL_OP_ALL: various bug workarounds that should be rather harmless.
 *             This used to be 0x000FFFFFL before 0.9.7. */
#define SSL_OP_ALL					0x00000FFFL

/* As server, disallow session resumption on renegotiation */
#define SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION	0x00010000L
d455 2
a456 4

#define SSL_OP_NO_SSLv2					0x01000000L
#define SSL_OP_NO_SSLv3					0x02000000L
#define SSL_OP_NO_TLSv1					0x04000000L
d464 1
d466 3
a481 1

a1639 1
#define SSL_R_KEY_ARG_TOO_LONG				 1112
a1718 1
#define SSL_R_SSL3_SESSION_ID_TOO_LONG			 1113
@


1.1.1.4
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@a1464 1
#define SSL_F_CLIENT_FINISHED				 238
a1477 1
#define SSL_F_SERVER_FINISH				 239
a1478 1
#define SSL_F_SERVER_VERIFY				 240
a1489 1
#define SSL_F_SSL2_GENERATE_KEY_MATERIAL		 241
a1525 1
#define SSL_F_SSL3_SEND_SERVER_HELLO			 242
a1749 1
#define SSL_R_SSL2_CONNECTION_ID_TOO_LONG		 1114
@


1.1.1.5
log
@import 0.9.7b (without idea and rc5)
@
text
@a206 16
#define SSL_TXT_KRB5_DES_64_CBC_SHA   SSL3_TXT_KRB5_DES_64_CBC_SHA
#define SSL_TXT_KRB5_DES_192_CBC3_SHA SSL3_TXT_KRB5_DES_192_CBC3_SHA
#define SSL_TXT_KRB5_RC4_128_SHA      SSL3_TXT_KRB5_RC4_128_SHA
#define SSL_TXT_KRB5_IDEA_128_CBC_SHA SSL3_TXT_KRB5_IDEA_128_CBC_SHA
#define SSL_TXT_KRB5_DES_64_CBC_MD5   SSL3_TXT_KRB5_DES_64_CBC_MD5       
#define SSL_TXT_KRB5_DES_192_CBC3_MD5 SSL3_TXT_KRB5_DES_192_CBC3_MD5       
#define SSL_TXT_KRB5_RC4_128_MD5      SSL3_TXT_KRB5_RC4_128_MD5
#define SSL_TXT_KRB5_IDEA_128_CBC_MD5 SSL3_TXT_KRB5_IDEA_128_CBC_MD5 

#define SSL_TXT_KRB5_DES_40_CBC_SHA   SSL3_TXT_KRB5_DES_40_CBC_SHA 
#define SSL_TXT_KRB5_RC2_40_CBC_SHA   SSL3_TXT_KRB5_RC2_40_CBC_SHA 
#define SSL_TXT_KRB5_RC4_40_SHA	      SSL3_TXT_KRB5_RC4_40_SHA
#define SSL_TXT_KRB5_DES_40_CBC_MD5   SSL3_TXT_KRB5_DES_40_CBC_MD5 
#define SSL_TXT_KRB5_RC2_40_CBC_MD5   SSL3_TXT_KRB5_RC2_40_CBC_MD5 
#define SSL_TXT_KRB5_RC4_40_MD5	      SSL3_TXT_KRB5_RC4_40_MD5

d302 1
d304 1
a509 2
/* Don't attempt to automatically build certificate chain */
#define SSL_MODE_NO_AUTO_CHAIN 0x00000008L
d707 3
a709 1
/* enough comments already ... see SSL_CTX_set_session_cache_mode(3) */
a710 3
#define SSL_SESS_CACHE_NO_INTERNAL_STORE	0x0200
#define SSL_SESS_CACHE_NO_INTERNAL \
	(SSL_SESS_CACHE_NO_INTERNAL_LOOKUP|SSL_SESS_CACHE_NO_INTERNAL_STORE)
d1215 1
d1222 1
a1690 1
#define SSL_R_MASTER_KEY_TOO_LONG			 1112
@


1.1.1.6
log
@import openssl-0.9.7d
@
text
@d1360 2
a1361 2
void SSL_set_client_CA_list(SSL *s, STACK_OF(X509_NAME) *name_list);
void SSL_CTX_set_client_CA_list(SSL_CTX *ctx, STACK_OF(X509_NAME) *name_list);
@


1.1.1.7
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a241 1
#define SSL_TXT_FIPS		"FIPS"
d375 1
a375 1
	int (*ssl_pending)(const SSL *s);
d1001 2
a1002 2
size_t SSL_get_finished(const SSL *s, void *buf, size_t count);
size_t SSL_get_peer_finished(const SSL *s, void *buf, size_t count);
d1174 2
a1175 2
long SSL_CTX_get_timeout(const SSL_CTX *ctx);
X509_STORE *SSL_CTX_get_cert_store(const SSL_CTX *);
d1177 1
a1177 1
int SSL_want(const SSL *s);
d1182 12
a1193 12
SSL_CIPHER *SSL_get_current_cipher(const SSL *s);
int	SSL_CIPHER_get_bits(const SSL_CIPHER *c,int *alg_bits);
char *	SSL_CIPHER_get_version(const SSL_CIPHER *c);
const char *	SSL_CIPHER_get_name(const SSL_CIPHER *c);

int	SSL_get_fd(const SSL *s);
int	SSL_get_rfd(const SSL *s);
int	SSL_get_wfd(const SSL *s);
const char  * SSL_get_cipher_list(const SSL *s,int n);
char *	SSL_get_shared_ciphers(const SSL *s, char *buf, int len);
int	SSL_get_read_ahead(const SSL * s);
int	SSL_pending(const SSL *s);
d1201 2
a1202 2
BIO *	SSL_get_rbio(const SSL *s);
BIO *	SSL_get_wbio(const SSL *s);
d1206 3
a1208 3
int	SSL_get_verify_mode(const SSL *s);
int	SSL_get_verify_depth(const SSL *s);
int	(*SSL_get_verify_callback(const SSL *s))(int,X509_STORE_CTX *);
d1246 1
a1246 1
long	SSL_SESSION_get_time(const SSL_SESSION *s);
d1248 1
a1248 1
long	SSL_SESSION_get_timeout(const SSL_SESSION *s);
d1250 1
a1250 1
void	SSL_copy_session_id(SSL *to,const SSL *from);
d1253 2
a1254 2
unsigned long SSL_SESSION_hash(const SSL_SESSION *a);
int	SSL_SESSION_cmp(const SSL_SESSION *a,const SSL_SESSION *b);
d1256 1
a1256 1
int	SSL_SESSION_print_fp(FILE *fp,const SSL_SESSION *ses);
d1259 1
a1259 1
int	SSL_SESSION_print(BIO *fp,const SSL_SESSION *ses);
d1270 1
a1270 2
SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a,const unsigned char * const *pp,
			     long length);
d1273 1
a1273 1
X509 *	SSL_get_peer_certificate(const SSL *s);
d1276 1
a1276 1
STACK_OF(X509) *SSL_get_peer_cert_chain(const SSL *s);
d1278 3
a1280 3
int SSL_CTX_get_verify_mode(const SSL_CTX *ctx);
int SSL_CTX_get_verify_depth(const SSL_CTX *ctx);
int (*SSL_CTX_get_verify_callback(const SSL_CTX *ctx))(int,X509_STORE_CTX *);
d1298 2
a1299 2
int SSL_CTX_check_private_key(const SSL_CTX *ctx);
int SSL_check_private_key(const SSL *ctx);
d1324 2
a1325 2
int	SSL_get_error(const SSL *s,int ret_code);
const char *SSL_get_version(const SSL *s);
d1346 1
a1346 1
STACK_OF(SSL_CIPHER) *SSL_get_ciphers(const SSL *s);
d1362 2
a1363 2
STACK_OF(X509_NAME) *SSL_get_client_CA_list(const SSL *s);
STACK_OF(X509_NAME) *SSL_CTX_get_client_CA_list(const SSL_CTX *s);
d1370 1
a1370 1
long SSL_get_default_timeout(const SSL *s);
d1379 1
a1379 1
X509 *SSL_get_certificate(const SSL *ssl);
d1383 1
a1383 1
int SSL_CTX_get_quiet_shutdown(const SSL_CTX *ctx);
d1385 1
a1385 1
int SSL_get_quiet_shutdown(const SSL *ssl);
d1387 2
a1388 2
int SSL_get_shutdown(const SSL *ssl);
int SSL_version(const SSL *ssl);
d1393 1
a1393 1
SSL_SESSION *SSL_get_session(const SSL *ssl);
d1395 1
a1395 1
SSL_CTX *SSL_get_SSL_CTX(const SSL *ssl);
d1398 2
a1399 2
void (*SSL_get_info_callback(const SSL *ssl))(const SSL *ssl,int type,int val);
int SSL_state(const SSL *ssl);
d1402 1
a1402 1
long SSL_get_verify_result(const SSL *ssl);
d1405 1
a1405 1
void *SSL_get_ex_data(const SSL *ssl,int idx);
d1410 1
a1410 1
void *SSL_SESSION_get_ex_data(const SSL_SESSION *ss,int idx);
d1415 1
a1415 1
void *SSL_CTX_get_ex_data(const SSL_CTX *ssl,int idx);
a1605 1
#define SSL_F_SSL_UNDEFINED_CONST_FUNCTION		 243
a1743 1
#define SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE		 1115
@


1.1.1.8
log
@import of openssl-0.9.7j
@
text
@d470 1
a470 1
#define SSL_OP_MSIE_SSLV2_RSA_PADDING			0x00000040L /* no effect since 0.9.7h and 0.9.8b */
a1569 1
#define SSL_F_SSL_CTX_SET_CIPHER_LIST			 269
a1598 1
#define SSL_F_SSL_SET_CIPHER_LIST			 271
d1677 1
a1677 1
#define SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC	 281
d1681 1
a1681 1
#define SSL_R_ERROR_GENERATING_TMP_RSA_KEY		 282
d1688 1
a1688 1
#define SSL_R_ILLEGAL_PADDING				 283
d1693 12
a1704 12
#define SSL_R_KEY_ARG_TOO_LONG				 284
#define SSL_R_KRB5					 285
#define SSL_R_KRB5_C_CC_PRINC				 286
#define SSL_R_KRB5_C_GET_CRED				 287
#define SSL_R_KRB5_C_INIT				 288
#define SSL_R_KRB5_C_MK_REQ				 289
#define SSL_R_KRB5_S_BAD_TICKET				 290
#define SSL_R_KRB5_S_INIT				 291
#define SSL_R_KRB5_S_RD_REQ				 292
#define SSL_R_KRB5_S_TKT_EXPIRED			 293
#define SSL_R_KRB5_S_TKT_NYV				 294
#define SSL_R_KRB5_S_TKT_SKEW				 295
d1709 2
a1710 1
#define SSL_R_MESSAGE_TOO_LONG				 296
d1747 1
a1747 1
#define SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE		 297
d1766 1
a1766 1
#define SSL_R_RECORD_TOO_SMALL				 298
d1775 2
a1776 2
#define SSL_R_SSL2_CONNECTION_ID_TOO_LONG		 299
#define SSL_R_SSL3_SESSION_ID_TOO_LONG			 300
d1787 4
d1792 1
d1797 2
a1798 2
#define SSL_R_SSL_SESSION_ID_CALLBACK_FAILED		 301
#define SSL_R_SSL_SESSION_ID_CONFLICT			 302
d1800 1
a1800 1
#define SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH		 303
d1841 1
@


1.1.1.9
log
@import of OpenSSL 0.9.8h
@
text
@d112 1
a112 1
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
a163 5
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
a175 1
#ifndef OPENSSL_NO_DEPRECATED
a178 7
#include <openssl/crypto.h>
#include <openssl/lhash.h>
#include <openssl/buffer.h>
#endif
#include <openssl/pem.h>
#include <openssl/hmac.h>

d242 1
a272 1
#define SSL_TXT_SEED		"SEED"
a273 1
#define SSL_TXT_CAMELLIA	"CAMELLIA"
a284 1
#define SSL_TXT_ECC		"ECCdraft" /* ECC ciphersuites are not yet official */
d306 1
a306 1
#define SSL_DEFAULT_CIPHER_LIST	"AES:ALL:!aNULL:!eNULL:+RC4:@@STRENGTH" /* low priority for RC4 */
d316 5
a371 6
	long (*ssl_get_message)(SSL *s, int st1, int stn, int mt, long
		max, int *ok);
	int (*ssl_read_bytes)(SSL *s, int type, unsigned char *buf, int len, 
		int peek);
	int (*ssl_write_bytes)(SSL *s, int type, const void *buf_, int len);
	int (*ssl_dispatch_alert)(SSL *s);
d382 3
a384 3
	int (*ssl_version)(void);
	long (*ssl_callback_ctrl)(SSL *s, int cb_id, void (*fp)(void));
	long (*ssl_ctx_callback_ctrl)(SSL_CTX *s, int cb_id, void (*fp)(void));
a461 7
#ifndef OPENSSL_NO_TLSEXT
	char *tlsext_hostname;
	/* RFC4507 info */
	unsigned char *tlsext_tick;	/* Session ticket */
	size_t	tlsext_ticklen;		/* Session ticket length */	
	long tlsext_tick_lifetime_hint;	/* Session lifetime hint in seconds */
#endif
a485 7
/* DTLS options */
#define SSL_OP_NO_QUERY_MTU                 0x00001000L
/* Turn on Cookie Exchange (on relevant for servers) */
#define SSL_OP_COOKIE_EXCHANGE              0x00002000L
/* Don't use RFC4507 ticket extension */
#define SSL_OP_NO_TICKET	            0x00004000L

a487 2
/* If set, always create a new key when using tmp_ecdh parameters */
#define SSL_OP_SINGLE_ECDH_USE				0x00080000L
a548 2
#define SSL_set_mtu(ssl, mtu) \
        SSL_ctrl((ssl),SSL_CTRL_SET_MTU,(mtu),NULL)
d585 1
a585 1
	const char *name;
a672 8
    /* cookie generate callback */
    int (*app_gen_cookie_cb)(SSL *ssl, unsigned char *cookie, 
        unsigned int *cookie_len);

    /* verify cookie callback */
    int (*app_verify_cookie_cb)(SSL *ssl, unsigned char *cookie, 
        unsigned int cookie_len);

d705 1
a712 3
	X509_VERIFY_PARAM *param;

#if 0
a714 1
#endif
a716 21

#ifndef OPENSSL_NO_TLSEXT
	/* TLS extensions servername callback */
	int (*tlsext_servername_callback)(SSL*, int *, void *);
	void *tlsext_servername_arg;
	/* RFC 4507 session ticket keys */
	unsigned char tlsext_tick_key_name[16];
	unsigned char tlsext_tick_hmac_key[16];
	unsigned char tlsext_tick_aes_key[16];
	/* Callback to support customisation of ticket key setting */
	int (*tlsext_ticket_key_cb)(SSL *ssl,
					unsigned char *name, unsigned char *iv,
					EVP_CIPHER_CTX *ectx,
					HMAC_CTX *hctx, int enc);

	/* certificate status request info */
	/* Callback for status request */
	int (*tlsext_status_cb)(SSL *ssl, void *arg);
	void *tlsext_status_arg;
#endif

d756 10
a765 12
void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx, int (*new_session_cb)(struct ssl_st *ssl,SSL_SESSION *sess));
int (*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx))(struct ssl_st *ssl, SSL_SESSION *sess);
void SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx, void (*remove_session_cb)(struct ssl_ctx_st *ctx,SSL_SESSION *sess));
void (*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx))(struct ssl_ctx_st *ctx, SSL_SESSION *sess);
void SSL_CTX_sess_set_get_cb(SSL_CTX *ctx, SSL_SESSION *(*get_session_cb)(struct ssl_st *ssl, unsigned char *data,int len,int *copy));
SSL_SESSION *(*SSL_CTX_sess_get_get_cb(SSL_CTX *ctx))(struct ssl_st *ssl, unsigned char *Data, int len, int *copy);
void SSL_CTX_set_info_callback(SSL_CTX *ctx, void (*cb)(const SSL *ssl,int type,int val));
void (*SSL_CTX_get_info_callback(SSL_CTX *ctx))(const SSL *ssl,int type,int val);
void SSL_CTX_set_client_cert_cb(SSL_CTX *ctx, int (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey));
int (*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx))(SSL *ssl, X509 **x509, EVP_PKEY **pkey);
void SSL_CTX_set_cookie_generate_cb(SSL_CTX *ctx, int (*app_gen_cookie_cb)(SSL *ssl, unsigned char *cookie, unsigned int *cookie_len));
void SSL_CTX_set_cookie_verify_cb(SSL_CTX *ctx, int (*app_verify_cookie_cb)(SSL *ssl, unsigned char *cookie, unsigned int cookie_len));
d781 1
a781 1
	 * (one of SSL2_VERSION, SSL3_VERSION, TLS1_VERSION, DTLS1_VERSION)
d810 1
a810 1
	int (*handshake_func)(SSL *);
a844 1
	struct dtls1_state_st *d1; /* DTLSv1 variables */
a854 3
	X509_VERIFY_PARAM *param;

#if 0
a856 1
#endif
d901 1
a931 31
#ifndef OPENSSL_NO_TLSEXT
	/* TLS extension debug callback */
	void (*tlsext_debug_cb)(SSL *s, int client_server, int type,
					unsigned char *data, int len,
					void *arg);
	void *tlsext_debug_arg;
	char *tlsext_hostname;
	int servername_done;   /* no further mod of servername 
	                          0 : call the servername extension callback.
	                          1 : prepare 2, allow last ack just after in server callback.
	                          2 : don't call servername callback, no ack in server hello
	                       */
	/* certificate status request info */
	/* Status type or -1 if no status type */
	int tlsext_status_type;
	/* Expect OCSP CertificateStatus message */
	int tlsext_status_expected;
	/* OCSP status request only */
	STACK_OF(OCSP_RESPID) *tlsext_ocsp_ids;
	X509_EXTENSIONS *tlsext_ocsp_exts;
	/* OCSP response received or to be sent */
	unsigned char *tlsext_ocsp_resp;
	int tlsext_ocsp_resplen;

	/* RFC4507 session ticket expected to be received or sent */
	int tlsext_ticket_expected;
	SSL_CTX * initial_ctx; /* initial ctx, used to store sessions */
#define session_ctx initial_ctx
#else
#define session_ctx ctx
#endif
a940 1
#include <openssl/dtls1.h> /* Datagram TLS */
d1038 5
a1042 2
#define d2i_SSL_SESSION_bio(bp,s_id) ASN1_d2i_bio_of(SSL_SESSION,SSL_SESSION_new,d2i_SSL_SESSION,bp,s_id)
#define i2d_SSL_SESSION_bio(bp,s_id) ASN1_i2d_bio_of(SSL_SESSION,i2d_SSL_SESSION,bp,s_id)
d1045 2
a1046 1
#define PEM_read_bio_SSL_SESSION(bp,x,cb,u) PEM_ASN1_read_bio_of(SSL_SESSION,d2i_SSL_SESSION,PEM_STRING_SSL_SESSION,bp,x,cb,u)
d1051 2
a1052 1
	PEM_ASN1_write_bio_of(SSL_SESSION,i2d_SSL_SESSION,PEM_STRING_SSL_SESSION,bp,x,NULL,NULL,0,NULL,NULL)
a1080 4
#define SSL_AD_UNSUPPORTED_EXTENSION	TLS1_AD_UNSUPPORTED_EXTENSION
#define SSL_AD_CERTIFICATE_UNOBTAINABLE TLS1_AD_CERTIFICATE_UNOBTAINABLE
#define SSL_AD_UNRECOGNIZED_NAME	TLS1_AD_UNRECOGNIZED_NAME
#define SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE
d1095 2
a1096 12
#define SSL_CTRL_SET_TMP_ECDH			4
#define SSL_CTRL_SET_TMP_RSA_CB			5
#define SSL_CTRL_SET_TMP_DH_CB			6
#define SSL_CTRL_SET_TMP_ECDH_CB		7

#define SSL_CTRL_GET_SESSION_REUSED		8
#define SSL_CTRL_GET_CLIENT_CERT_REQUEST	9
#define SSL_CTRL_GET_NUM_RENEGOTIATIONS		10
#define SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS	11
#define SSL_CTRL_GET_TOTAL_RENEGOTIATIONS	12
#define SSL_CTRL_GET_FLAGS			13
#define SSL_CTRL_EXTRA_CHAIN_CERT		14
d1098 10
a1107 2
#define SSL_CTRL_SET_MSG_CALLBACK               15
#define SSL_CTRL_SET_MSG_CALLBACK_ARG           16
a1108 2
/* only applies to datagram connections */
#define SSL_CTRL_SET_MTU                17
a1134 23
/* see tls1.h for macros based on these */
#ifndef OPENSSL_NO_TLSEXT
#define SSL_CTRL_SET_TLSEXT_SERVERNAME_CB	53
#define SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG	54
#define SSL_CTRL_SET_TLSEXT_HOSTNAME		55
#define SSL_CTRL_SET_TLSEXT_DEBUG_CB		56
#define SSL_CTRL_SET_TLSEXT_DEBUG_ARG		57
#define SSL_CTRL_GET_TLSEXT_TICKET_KEYS		58
#define SSL_CTRL_SET_TLSEXT_TICKET_KEYS		59

#define SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB	63
#define SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG	64
#define SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE	65
#define SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS	66
#define SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS	67
#define SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS	68
#define SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS	69
#define SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP	70
#define SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP	71

#define SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB	72
#endif

a1149 2
#define SSL_CTX_set_tmp_ecdh(ctx,ecdh) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_TMP_ECDH,0,(char *)ecdh)
a1156 2
#define SSL_set_tmp_ecdh(ssl,ecdh) \
	SSL_ctrl(ssl,SSL_CTRL_SET_TMP_ECDH,0,(char *)ecdh)
d1218 1
a1218 1
int	SSL_use_PrivateKey_ASN1(int pk,SSL *ssl, const unsigned char *d, long len);
d1220 1
a1220 1
int	SSL_use_certificate_ASN1(SSL *ssl, const unsigned char *d, int len);
a1255 1
const unsigned char *SSL_SESSION_get_id(const SSL_SESSION *s, unsigned int *len);
d1271 1
a1271 1
SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a,const unsigned char **pp,
d1290 1
a1290 1
int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, const unsigned char *d, long len);
d1293 1
a1293 1
	const unsigned char *d, long len);
d1295 1
a1295 1
int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, const unsigned char *d);
d1322 1
a1322 1
long	SSL_callback_ctrl(SSL *, int, void (*)(void));
d1324 1
a1324 1
long	SSL_CTX_callback_ctrl(SSL_CTX *, int, void (*)(void));
a1347 4
SSL_METHOD *DTLSv1_method(void);		/* DTLSv1.0 */
SSL_METHOD *DTLSv1_server_method(void);	/* DTLSv1.0 */
SSL_METHOD *DTLSv1_client_method(void);	/* DTLSv1.0 */

a1397 1
SSL_CTX *SSL_set_SSL_CTX(SSL *ssl, SSL_CTX* ctx);
a1464 8
#ifndef OPENSSL_NO_ECDH
void SSL_CTX_set_tmp_ecdh_callback(SSL_CTX *ctx,
				 EC_KEY *(*ecdh)(SSL *ssl,int is_export,
					   int keylength));
void SSL_set_tmp_ecdh_callback(SSL *ssl,
				 EC_KEY *(*ecdh)(SSL *ssl,int is_export,
					   int keylength));
#endif
a1466 4
const COMP_METHOD *SSL_get_current_compression(SSL *s);
const COMP_METHOD *SSL_get_current_expansion(SSL *s);
const char *SSL_COMP_get_name(const COMP_METHOD *comp);
STACK_OF(SSL_COMP) *SSL_COMP_get_compression_methods(void);
d1469 1
a1469 5
const void *SSL_get_current_compression(SSL *s);
const void *SSL_get_current_expansion(SSL *s);
const char *SSL_COMP_get_name(const void *comp);
void *SSL_COMP_get_compression_methods(void);
int SSL_COMP_add_compression_method(int id,void *cm);
d1482 1
a1482 1
#define SSL_F_CLIENT_FINISHED				 167
a1485 1
#define SSL_F_DO_DTLS1_WRITE				 245
a1486 24
#define SSL_F_DTLS1_ACCEPT				 246
#define SSL_F_DTLS1_BUFFER_RECORD			 247
#define SSL_F_DTLS1_CLIENT_HELLO			 248
#define SSL_F_DTLS1_CONNECT				 249
#define SSL_F_DTLS1_ENC					 250
#define SSL_F_DTLS1_GET_HELLO_VERIFY			 251
#define SSL_F_DTLS1_GET_MESSAGE				 252
#define SSL_F_DTLS1_GET_MESSAGE_FRAGMENT		 253
#define SSL_F_DTLS1_GET_RECORD				 254
#define SSL_F_DTLS1_OUTPUT_CERT_CHAIN			 255
#define SSL_F_DTLS1_PREPROCESS_FRAGMENT			 277
#define SSL_F_DTLS1_PROCESS_OUT_OF_SEQ_MESSAGE		 256
#define SSL_F_DTLS1_PROCESS_RECORD			 257
#define SSL_F_DTLS1_READ_BYTES				 258
#define SSL_F_DTLS1_READ_FAILED				 259
#define SSL_F_DTLS1_SEND_CERTIFICATE_REQUEST		 260
#define SSL_F_DTLS1_SEND_CLIENT_CERTIFICATE		 261
#define SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE		 262
#define SSL_F_DTLS1_SEND_CLIENT_VERIFY			 263
#define SSL_F_DTLS1_SEND_HELLO_VERIFY_REQUEST		 264
#define SSL_F_DTLS1_SEND_SERVER_CERTIFICATE		 265
#define SSL_F_DTLS1_SEND_SERVER_HELLO			 266
#define SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE		 267
#define SSL_F_DTLS1_WRITE_APP_DATA_BYTES		 268
a1526 1
#define SSL_F_SSL3_GET_CERT_STATUS			 288
a1533 1
#define SSL_F_SSL3_GET_NEW_SESSION_TICKET		 283
a1537 1
#define SSL_F_SSL3_NEW_SESSION_TICKET			 284
a1552 1
#define SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT		 272
a1554 1
#define SSL_F_SSL_ADD_SERVERHELLO_TLSEXT		 273
a1561 1
#define SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT		 274
a1592 3
#define SSL_F_SSL_PEEK					 270
#define SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT		 275
#define SSL_F_SSL_PREPARE_SERVERHELLO_TLSEXT		 276
a1611 1
#define SSL_F_SSL_UNDEFINED_VOID_FUNCTION		 244
a1641 3
#define SSL_R_BAD_ECC_CERT				 304
#define SSL_R_BAD_ECDSA_SIGNATURE			 305
#define SSL_R_BAD_ECPOINT				 306
a1670 1
#define SSL_R_CLIENTHELLO_TLSEXT			 157
a1672 1
#define SSL_R_COMPRESSION_ID_NOT_WITHIN_PRIVATE_RANGE	 307
a1675 1
#define SSL_R_COOKIE_MISMATCH				 308
a1681 2
#define SSL_R_DUPLICATE_COMPRESSION_ID			 309
#define SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER		 310
a1693 2
#define SSL_R_INVALID_STATUS_RESPONSE			 316
#define SSL_R_INVALID_TICKET_KEYS_LENGTH		 275
a1721 1
#define SSL_R_MISSING_TMP_ECDH_KEY			 311
a1749 1
#define SSL_R_PARSE_TLSEXT				 223
a1763 1
#define SSL_R_READ_TIMEOUT_EXPIRED			 312
a1771 1
#define SSL_R_SERVERHELLO_TLSEXT			 224
a1776 2
#define SSL_R_SSL3_EXT_INVALID_SERVERNAME		 225
#define SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE		 226
a1810 1
#define SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST		 227
a1814 1
#define SSL_R_UNABLE_TO_DECODE_ECDH_CERTS		 313
a1816 1
#define SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS		 314
a1836 1
#define SSL_R_UNSUPPORTED_ELLIPTIC_CURVE		 315
a1838 1
#define SSL_R_UNSUPPORTED_STATUS_TYPE			 329
@


1.1.1.10
log
@import openssl-0.9.8j
@
text
@a254 1
#define SSL_TXT_FIPS		"FIPS"
d364 3
a762 6
#ifndef OPENSSL_ENGINE
	/* Engine to pass requests for client certs to
	 */
	ENGINE *client_cert_engine;
#endif

a831 3
#ifndef OPENSSL_NO_ENGINE
int SSL_CTX_set_client_cert_engine(SSL_CTX *ctx, ENGINE *e);
#endif
a1704 1
#define SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC		 279
a1757 1
#define SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE		 278
a1937 1
#define SSL_R_NO_CLIENT_CERT_METHOD			 317
@


1.1.1.11
log
@import OpenSSL-1.0.0a
@
text
@d59 54
a112 1
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
a168 26
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */
a250 1

a251 3

#define SSL_TXT_EXP40		"EXPORT40"
#define SSL_TXT_EXP56		"EXPORT56"
d256 4
a259 5

#define SSL_TXT_kFZA		"kFZA" /* unused! */
#define	SSL_TXT_aFZA		"aFZA" /* unused! */
#define SSL_TXT_eFZA		"eFZA" /* unused! */
#define SSL_TXT_FZA		"FZA"  /* unused! */
d265 4
d270 2
a271 3
#define SSL_TXT_kDHr		"kDHr" /* no such ciphersuites supported! */
#define SSL_TXT_kDHd		"kDHd" /* no such ciphersuites supported! */
#define SSL_TXT_kDH 		"kDH"  /* no such ciphersuites supported! */
a272 8
#define SSL_TXT_kKRB5     	"kKRB5"
#define SSL_TXT_kECDHr		"kECDHr"
#define SSL_TXT_kECDHe		"kECDHe"
#define SSL_TXT_kECDH		"kECDH"
#define SSL_TXT_kEECDH		"kEECDH"
#define SSL_TXT_kPSK            "kPSK"
#define SSL_TXT_kGOST		"kGOST"

d275 1
a275 9
#define	SSL_TXT_aDH		"aDH" /* no such ciphersuites supported! */
#define	SSL_TXT_aECDH		"aECDH"
#define SSL_TXT_aKRB5     	"aKRB5"
#define SSL_TXT_aECDSA		"aECDSA"
#define SSL_TXT_aPSK            "aPSK"
#define SSL_TXT_aGOST94	"aGOST94"
#define SSL_TXT_aGOST01 "aGOST01"
#define SSL_TXT_aGOST  "aGOST"

d278 1
a278 1
#define SSL_TXT_EDH		"EDH" /* same as "kEDH:-ADH" */
a280 7
#define SSL_TXT_ECDH		"ECDH"
#define SSL_TXT_EECDH		"EECDH" /* same as "kEECDH:-AECDH" */
#define SSL_TXT_AECDH		"AECDH"
#define SSL_TXT_ECDSA		"ECDSA"
#define SSL_TXT_KRB5      	"KRB5"
#define SSL_TXT_PSK             "PSK"

a286 2
#define SSL_TXT_AES128		"AES128"
#define SSL_TXT_AES256		"AES256"
a287 2
#define SSL_TXT_CAMELLIA128	"CAMELLIA128"
#define SSL_TXT_CAMELLIA256	"CAMELLIA256"
a288 1

d291 5
a295 4
#define SSL_TXT_SHA		"SHA" /* same as "SHA1" */
#define SSL_TXT_GOST94		"GOST94" 
#define SSL_TXT_GOST89MAC		"GOST89MAC" 

a298 4

#define SSL_TXT_EXP		"EXP"
#define SSL_TXT_EXPORT		"EXPORT"

d300 1
d322 1
a322 7
#define SSL_DEFAULT_CIPHER_LIST	"ALL:!aNULL:!eNULL:!SSLv2"
/* As of OpenSSL 1.0.0, ssl_create_cipher_list() in ssl/ssl_ciph.c always
 * starts with a reasonable order, and all we have to do for DEFAULT is
 * throwing out anonymous and unencrypted ciphersuites!
 * (The latter are not actually enabled by ALL, but "ALL:RSA" would enable
 * some of them.)
 */
a346 1
typedef struct tls_session_ticket_ext_st TLS_SESSION_TICKET_EXT;
d354 1
a354 8

	/* changed in 0.9.9: these four used to be portions of a single value 'algorithms' */
	unsigned long algorithm_mkey;	/* key exchange algorithm */
	unsigned long algorithm_auth;	/* server authentication */
	unsigned long algorithm_enc;	/* symmetric encryption */
	unsigned long algorithm_mac;	/* symmetric authentication */
	unsigned long algorithm_ssl;	/* (major) protocol version */

d359 2
a364 3
typedef int (*tls_session_ticket_ext_cb_fn)(SSL *s, const unsigned char *data, int len, void *arg);
typedef int (*tls_session_secret_cb_fn)(SSL *s, void *secret, int *secret_len, STACK_OF(SSL_CIPHER) *peer_ciphers, SSL_CIPHER **cipher, void *arg);

d388 1
a388 1
	const SSL_CIPHER *(*get_cipher_by_char)(const unsigned char *ptr);
d392 2
a393 2
	const SSL_CIPHER *(*get_cipher)(unsigned ncipher);
	const struct ssl_method_st *(*get_ssl_method)(int version);
d405 5
a409 5
 *	Cipher 			OCTET STRING,	-- the 3 byte cipher ID
 *	Session_ID 		OCTET STRING,	-- the Session ID
 *	Master_key 		OCTET STRING,	-- the master key
 *	KRB5_principal		OCTET STRING	-- optional Kerberos principal
 *	Key_Arg [ 0 ] IMPLICIT	OCTET STRING,	-- the optional Key argument
d413 3
a415 6
 *	Session_ID_context [ 4 ] EXPLICIT OCTET STRING,   -- the Session ID context
 *	Verify_result [ 5 ] EXPLICIT INTEGER,   -- X509_V_... code for `Peer'
 *	HostName [ 6 ] EXPLICIT OCTET STRING,   -- optional HostName from servername TLS extension 
 *	ECPointFormatList [ 7 ] OCTET STRING,     -- optional EC point format list from TLS extension
 *	PSK_identity_hint [ 8 ] EXPLICIT OCTET STRING, -- optional PSK identity hint
 *	PSK_identity [ 9 ] EXPLICIT OCTET STRING -- optional PSK identity
d443 1
a443 4
#ifndef OPENSSL_NO_PSK
	char *psk_identity_hint;
	char *psk_identity;
#endif
d462 1
a462 1
	unsigned int compress_meth;	/* Need to lookup the method */
d464 1
a464 1
	const SSL_CIPHER *cipher;
a477 6
#ifndef OPENSSL_NO_EC
	size_t tlsext_ecpointformatlist_length;
	unsigned char *tlsext_ecpointformatlist; /* peer's list */
	size_t tlsext_ellipticcurvelist_length;
	unsigned char *tlsext_ellipticcurvelist; /* peer's list */
#endif /* OPENSSL_NO_EC */
a487 2
/* Allow initial connection to servers that don't support RI */
#define SSL_OP_LEGACY_SERVER_CONNECT			0x00000004L
d505 1
a505 1
#define SSL_OP_ALL					0x80000FFFL
a512 2
/* Use Cisco's "speshul" version of DTLS_BAD_VER (as client)  */
#define SSL_OP_CISCO_ANYCONNECT		    0x00008000L
a515 4
/* Don't use compression even if supported */
#define SSL_OP_NO_COMPRESSION				0x00020000L
/* Permit unsafe legacy renegotiation */
#define SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION	0x00040000L
d542 1
a542 5
/* Make server add server-hello extension from early version of
 * cryptopro draft, when GOST ciphersuite is negotiated. 
 * Required for interoperability with CryptoPro CSP 3.x 
 */
#define SSL_OP_CRYPTOPRO_TLSEXT_BUG			0x80000000L
d557 1
a557 4
/* Save RAM by releasing read and write buffers when they're empty. (SSL3 and
 * TLS only.)  "Released" buffers are put onto a free-list in the context
 * or just freed (depending on the context's setting for freelist_max_len). */
#define SSL_MODE_RELEASE_BUFFERS 0x00000010L
a563 2
#define SSL_CTX_clear_options(ctx,op) \
	SSL_CTX_ctrl((ctx),SSL_CTRL_CLEAR_OPTIONS,(op),NULL)
a567 2
#define SSL_clear_options(ssl,op) \
	SSL_ctrl((ssl),SSL_CTRL_CLEAR_OPTIONS,(op),NULL)
a572 2
#define SSL_CTX_clear_mode(ctx,op) \
	SSL_CTX_ctrl((ctx),SSL_CTRL_CLEAR_MODE,(op),NULL)
a574 2
#define SSL_clear_mode(ssl,op) \
	SSL_ctrl((ssl),SSL_CTRL_CLEAR_MODE,(op),NULL)
a581 2
#define SSL_get_secure_renegotiation_support(ssl) \
	SSL_ctrl((ssl), SSL_CTRL_GET_RI_SUPPORT, 0, NULL)
a625 1
DECLARE_LHASH_OF(SSL_SESSION);
d629 1
a629 1
	const SSL_METHOD *method;
d636 1
a636 1
	LHASH_OF(SSL_SESSION) *sessions;
a760 6
	/* Maximum amount of data to send in one fragment.
	 * actual record size can be more than this due to
	 * padding and MAC overheads.
	 */
	unsigned int max_send_fragment;

d779 1
a779 1
 					HMAC_CTX *hctx, int enc);
d785 1
a786 20
	/* draft-rescorla-tls-opaque-prf-input-00.txt information */
	int (*tlsext_opaque_prf_input_callback)(SSL *, void *peerinput, size_t len, void *arg);
	void *tlsext_opaque_prf_input_callback_arg;
#endif

#ifndef OPENSSL_NO_PSK
	char *psk_identity_hint;
	unsigned int (*psk_client_callback)(SSL *ssl, const char *hint, char *identity,
		unsigned int max_identity_len, unsigned char *psk,
		unsigned int max_psk_len);
	unsigned int (*psk_server_callback)(SSL *ssl, const char *identity,
		unsigned char *psk, unsigned int max_psk_len);
#endif

#ifndef OPENSSL_NO_BUF_FREELISTS
#define SSL_MAX_BUF_FREELIST_LEN_DEFAULT 32
	unsigned int freelist_max_len;
	struct ssl3_buf_freelist_st *wbuf_freelist;
	struct ssl3_buf_freelist_st *rbuf_freelist;
#endif
d800 1
a800 1
LHASH_OF(SSL_SESSION) *SSL_CTX_sessions(SSL_CTX *ctx);
a841 25
#ifndef OPENSSL_NO_PSK
/* the maximum length of the buffer given to callbacks containing the
 * resulting identity/psk */
#define PSK_MAX_IDENTITY_LEN 128
#define PSK_MAX_PSK_LEN 256
void SSL_CTX_set_psk_client_callback(SSL_CTX *ctx, 
	unsigned int (*psk_client_callback)(SSL *ssl, const char *hint, 
		char *identity, unsigned int max_identity_len, unsigned char *psk,
		unsigned int max_psk_len));
void SSL_set_psk_client_callback(SSL *ssl, 
	unsigned int (*psk_client_callback)(SSL *ssl, const char *hint, 
		char *identity, unsigned int max_identity_len, unsigned char *psk,
		unsigned int max_psk_len));
void SSL_CTX_set_psk_server_callback(SSL_CTX *ctx, 
	unsigned int (*psk_server_callback)(SSL *ssl, const char *identity,
		unsigned char *psk, unsigned int max_psk_len));
void SSL_set_psk_server_callback(SSL *ssl,
	unsigned int (*psk_server_callback)(SSL *ssl, const char *identity,
		unsigned char *psk, unsigned int max_psk_len));
int SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *identity_hint);
int SSL_use_psk_identity_hint(SSL *s, const char *identity_hint);
const char *SSL_get_psk_identity_hint(const SSL *s);
const char *SSL_get_psk_identity(const SSL *s);
#endif

a852 3
#define SSL_MAC_FLAG_READ_MAC_STREAM 1
#define SSL_MAC_FLAG_WRITE_MAC_STREAM 2

d861 1
a861 1
	const SSL_METHOD *method; /* SSLv3 */
d944 1
a944 1
	int mac_flags; 
d946 1
a946 1
	EVP_MD_CTX *read_hash;		/* used for mac generation */
d954 1
a954 1
	EVP_MD_CTX *write_hash;		/* used for mac generation */
a991 8
#ifndef OPENSSL_NO_PSK
	unsigned int (*psk_client_callback)(SSL *ssl, const char *hint, char *identity,
		unsigned int max_identity_len, unsigned char *psk,
		unsigned int max_psk_len);
	unsigned int (*psk_server_callback)(SSL *ssl, const char *identity,
		unsigned char *psk, unsigned int max_psk_len);
#endif

a1010 1
	unsigned int max_send_fragment;
a1036 22
#ifndef OPENSSL_NO_EC
	size_t tlsext_ecpointformatlist_length;
	unsigned char *tlsext_ecpointformatlist; /* our list */
	size_t tlsext_ellipticcurvelist_length;
	unsigned char *tlsext_ellipticcurvelist; /* our list */
#endif /* OPENSSL_NO_EC */

	/* draft-rescorla-tls-opaque-prf-input-00.txt information to be used for handshakes */
	void *tlsext_opaque_prf_input;
	size_t tlsext_opaque_prf_input_len;

	/* TLS Session Ticket extension override */
	TLS_SESSION_TICKET_EXT *tlsext_session_ticket;

	/* TLS Session Ticket extension callback */
	tls_session_ticket_ext_cb_fn tls_session_ticket_ext_cb;
	void *tls_session_ticket_ext_cb_arg;

	/* TLS pre-shared secret session resumption */
	tls_session_secret_cb_fn tls_session_secret_cb;
	void *tls_session_secret_cb_arg;

d1041 1
a1041 1
#endif /* OPENSSL_NO_TLSEXT */
d1148 1
d1151 9
d1161 1
a1161 4
DECLARE_PEM_rw(SSL_SESSION, SSL_SESSION)

#define SSL_AD_REASON_OFFSET		1000 /* offset to get SSL_R_... value from SSL_AD_... */

a1190 2
#define SSL_AD_BAD_CERTIFICATE_HASH_VALUE TLS1_AD_BAD_CERTIFICATE_HASH_VALUE
#define SSL_AD_UNKNOWN_PSK_IDENTITY     TLS1_AD_UNKNOWN_PSK_IDENTITY /* fatal */
a1248 2
#define SSL_CTRL_SET_MAX_SEND_FRAGMENT		52

d1258 1
a1258 3
#define SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT	60
#define SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB	61
#define SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB_ARG 62
a1271 15
#define DTLS_CTRL_GET_TIMEOUT		73
#define DTLS_CTRL_HANDLE_TIMEOUT	74
#define DTLS_CTRL_LISTEN			75

#define SSL_CTRL_GET_RI_SUPPORT			76
#define SSL_CTRL_CLEAR_OPTIONS			77
#define SSL_CTRL_CLEAR_MODE			78

#define DTLSv1_get_timeout(ssl, arg) \
	SSL_ctrl(ssl,DTLS_CTRL_GET_TIMEOUT,0, (void *)arg)
#define DTLSv1_handle_timeout(ssl) \
	SSL_ctrl(ssl,DTLS_CTRL_HANDLE_TIMEOUT,0, NULL)
#define DTLSv1_listen(ssl, peer) \
	SSL_ctrl(ssl,DTLS_CTRL_LISTEN,0, (void *)peer)

d1313 1
a1313 1
SSL_CTX *SSL_CTX_new(const SSL_METHOD *meth);
d1324 1
a1324 1
const SSL_CIPHER *SSL_get_current_cipher(const SSL *s);
d1395 3
a1397 2
const unsigned char *SSL_SESSION_get_id(const SSL_SESSION *s,
					unsigned int *len);
a1456 3
int SSL_CTX_set1_param(SSL_CTX *ctx, X509_VERIFY_PARAM *vpm);
int SSL_set1_param(SSL *ssl, X509_VERIFY_PARAM *vpm);

d1472 1
a1472 7
int SSL_CTX_set_ssl_version(SSL_CTX *ctx, const SSL_METHOD *meth);

#ifndef OPENSSL_NO_SSL2
const SSL_METHOD *SSLv2_method(void);		/* SSLv2 */
const SSL_METHOD *SSLv2_server_method(void);	/* SSLv2 */
const SSL_METHOD *SSLv2_client_method(void);	/* SSLv2 */
#endif
d1474 19
a1492 15
const SSL_METHOD *SSLv3_method(void);		/* SSLv3 */
const SSL_METHOD *SSLv3_server_method(void);	/* SSLv3 */
const SSL_METHOD *SSLv3_client_method(void);	/* SSLv3 */

const SSL_METHOD *SSLv23_method(void);	/* SSLv3 but can rollback to v2 */
const SSL_METHOD *SSLv23_server_method(void);	/* SSLv3 but can rollback to v2 */
const SSL_METHOD *SSLv23_client_method(void);	/* SSLv3 but can rollback to v2 */

const SSL_METHOD *TLSv1_method(void);		/* TLSv1.0 */
const SSL_METHOD *TLSv1_server_method(void);	/* TLSv1.0 */
const SSL_METHOD *TLSv1_client_method(void);	/* TLSv1.0 */

const SSL_METHOD *DTLSv1_method(void);		/* DTLSv1.0 */
const SSL_METHOD *DTLSv1_server_method(void);	/* DTLSv1.0 */
const SSL_METHOD *DTLSv1_client_method(void);	/* DTLSv1.0 */
d1501 2
a1502 2
const SSL_METHOD *SSL_get_ssl_method(SSL *s);
int SSL_set_ssl_method(SSL *s, const SSL_METHOD *method);
d1522 1
a1522 1
char *SSL_CIPHER_description(const SSL_CIPHER *,char *buf,int size);
a1593 5
#define SSL_CTX_set_max_send_fragment(ctx,m) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_SET_MAX_SEND_FRAGMENT,m,NULL)
#define SSL_set_max_send_fragment(ssl,m) \
	SSL_ctrl(ssl,SSL_CTRL_SET_MAX_SEND_FRAGMENT,m,NULL)

a1634 9
/* TLS extensions functions */
int SSL_set_session_ticket_ext(SSL *s, void *ext_data, int ext_len);

int SSL_set_session_ticket_ext_cb(SSL *s, tls_session_ticket_ext_cb_fn cb,
				  void *arg);

/* Pre-shared secret session resumption functions */
int SSL_set_session_secret_cb(SSL *s, tls_session_secret_cb_fn tls_session_secret_cb, void *arg);

a1651 1
#define SSL_F_DTLS1_ADD_CERT_TO_BUF			 295
a1659 1
#define SSL_F_DTLS1_HANDLE_TIMEOUT			 297
d1661 1
a1661 1
#define SSL_F_DTLS1_PREPROCESS_FRAGMENT			 288
a1704 1
#define SSL_F_SSL3_ADD_CERT_TO_BUF			 296
d1712 1
a1712 2
#define SSL_F_SSL3_DIGEST_CACHED_RECORDS		 293
#define SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC		 292
d1716 1
a1716 1
#define SSL_F_SSL3_GET_CERT_STATUS			 289
d1729 1
a1729 2
#define SSL_F_SSL3_HANDSHAKE_MAC			 285
#define SSL_F_SSL3_NEW_SESSION_TICKET			 287
d1741 1
a1742 2
#define SSL_F_SSL3_SETUP_READ_BUFFER			 156
#define SSL_F_SSL3_SETUP_WRITE_BUFFER			 291
d1745 1
a1745 2
#define SSL_F_SSL_ADD_CLIENTHELLO_RENEGOTIATE_EXT	 298
#define SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT		 277
d1748 1
a1748 2
#define SSL_F_SSL_ADD_SERVERHELLO_RENEGOTIATE_EXT	 299
#define SSL_F_SSL_ADD_SERVERHELLO_TLSEXT		 278
d1756 1
a1756 2
#define SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT		 280
#define SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG		 279
d1766 1
a1766 1
#define SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE		 290
a1777 1
#define SSL_F_SSL_CTX_USE_PSK_IDENTITY_HINT		 272
a1788 4
#define SSL_F_SSL_PARSE_CLIENTHELLO_RENEGOTIATE_EXT	 300
#define SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT		 302
#define SSL_F_SSL_PARSE_SERVERHELLO_RENEGOTIATE_EXT	 301
#define SSL_F_SSL_PARSE_SERVERHELLO_TLSEXT		 303
d1790 2
a1791 2
#define SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT		 281
#define SSL_F_SSL_PREPARE_SERVERHELLO_TLSEXT		 282
a1805 1
#define SSL_F_SSL_SET_SESSION_TICKET_EXT		 294
a1817 1
#define SSL_F_SSL_USE_PSK_IDENTITY_HINT			 273
a1822 1
#define SSL_F_TLS1_CERT_VERIFY_MAC			 286
a1823 1
#define SSL_F_TLS1_CHECK_SERVERHELLO_TLSEXT		 274
a1824 3
#define SSL_F_TLS1_PREPARE_CLIENTHELLO_TLSEXT		 275
#define SSL_F_TLS1_PREPARE_SERVERHELLO_TLSEXT		 276
#define SSL_F_TLS1_PRF					 284
a1844 1
#define SSL_R_BAD_HANDSHAKE_LENGTH			 332
a1847 1
#define SSL_R_BAD_MAC_LENGTH				 333
a1850 1
#define SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH		 316
d1874 1
a1874 1
#define SSL_R_CLIENTHELLO_TLSEXT			 226
a1875 1
#define SSL_R_COMPRESSION_DISABLED			 343
a1887 1
#define SSL_R_DTLS_MESSAGE_TOO_BIG			 334
a1888 4
#define SSL_R_ECC_CERT_NOT_FOR_KEY_AGREEMENT		 317
#define SSL_R_ECC_CERT_NOT_FOR_SIGNING			 318
#define SSL_R_ECC_CERT_SHOULD_HAVE_RSA_SIGNATURE	 322
#define SSL_R_ECC_CERT_SHOULD_HAVE_SHA1_SIGNATURE	 323
a1898 1
#define SSL_R_INCONSISTENT_COMPRESSION			 340
a1900 1
#define SSL_R_INVALID_COMPRESSION_ALGORITHM		 341
d1902 2
a1903 2
#define SSL_R_INVALID_STATUS_RESPONSE			 328
#define SSL_R_INVALID_TICKET_KEYS_LENGTH		 325
d1947 1
a1947 1
#define SSL_R_NO_CLIENT_CERT_METHOD			 331
a1949 1
#define SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER		 330
a1954 2
#define SSL_R_NO_RENEGOTIATION				 339
#define SSL_R_NO_REQUIRED_DIGEST			 324
a1959 1
#define SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED 344
a1960 1
#define SSL_R_OPAQUE_PRF_INPUT_TOO_LONG			 327
d1962 1
a1962 1
#define SSL_R_PARSE_TLSEXT				 227
a1972 3
#define SSL_R_PSK_IDENTITY_NOT_FOUND			 223
#define SSL_R_PSK_NO_CLIENT_CB				 224
#define SSL_R_PSK_NO_SERVER_CB				 225
a1981 3
#define SSL_R_RENEGOTIATE_EXT_TOO_LONG			 335
#define SSL_R_RENEGOTIATION_ENCODING_ERR		 336
#define SSL_R_RENEGOTIATION_MISMATCH			 337
a1982 1
#define SSL_R_REQUIRED_COMPRESSSION_ALGORITHM_MISSING	 342
d1986 1
a1986 2
#define SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING		 345
#define SSL_R_SERVERHELLO_TLSEXT			 275
d1992 2
a1993 3
#define SSL_R_SSL3_EXT_INVALID_ECPOINTFORMAT		 321
#define SSL_R_SSL3_EXT_INVALID_SERVERNAME		 319
#define SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE		 320
a2026 5
#define SSL_R_TLSV1_BAD_CERTIFICATE_HASH_VALUE		 1114
#define SSL_R_TLSV1_BAD_CERTIFICATE_STATUS_RESPONSE	 1113
#define SSL_R_TLSV1_CERTIFICATE_UNOBTAINABLE		 1111
#define SSL_R_TLSV1_UNRECOGNIZED_NAME			 1112
#define SSL_R_TLSV1_UNSUPPORTED_EXTENSION		 1110
d2028 1
a2028 1
#define SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST		 157
a2054 1
#define SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED	 338
a2056 1
#define SSL_R_UNSUPPORTED_DIGEST_TYPE			 326
@


1.1.1.12
log
@OpenSSL 1.0.0f: import upstream source
@
text
@a1884 1
#define SSL_F_SSL3_CHECK_CLIENT_HELLO			 304
a2141 1
#define SSL_R_MULTIPLE_SGC_RESTARTS			 346
@


1.1.1.13
log
@import OpenSSL-1.0.1c
@
text
@a254 1
#define SSL_TXT_kSRP		"kSRP"
a277 1
#define SSL_TXT_SRP		"SRP"
a287 1
#define SSL_TXT_AES_GCM		"AESGCM"
a296 2
#define SSL_TXT_SHA256		"SHA256"
#define SSL_TXT_SHA384		"SHA384"
a300 2
#define SSL_TXT_TLSV1_1		"TLSv1.1"
#define SSL_TXT_TLSV1_2		"TLSv1.2"
a358 20
typedef struct ssl_method_st SSL_METHOD;
typedef struct ssl_cipher_st SSL_CIPHER;
typedef struct ssl_session_st SSL_SESSION;

DECLARE_STACK_OF(SSL_CIPHER)

/* SRTP protection profiles for use with the use_srtp extension (RFC 5764)*/
typedef struct srtp_protection_profile_st
       {
       const char *name;
       unsigned long id;
       } SRTP_PROTECTION_PROFILE;

DECLARE_STACK_OF(SRTP_PROTECTION_PROFILE)

typedef int (*tls_session_ticket_ext_cb_fn)(SSL *s, const unsigned char *data, int len, void *arg);
typedef int (*tls_session_secret_cb_fn)(SSL *s, void *secret, int *secret_len, STACK_OF(SSL_CIPHER) *peer_ciphers, SSL_CIPHER **cipher, void *arg);


#ifndef OPENSSL_NO_SSL_INTERN
d361 1
a361 1
struct ssl_cipher_st
d378 3
a380 1
	};
d382 2
d386 1
a386 1
struct ssl_method_st
d419 1
a419 1
	};
d436 3
a438 6
 *	PSK_identity_hint [ 7 ] EXPLICIT OCTET STRING, -- optional PSK identity hint
 *	PSK_identity [ 8 ] EXPLICIT OCTET STRING,  -- optional PSK identity
 *	Ticket_lifetime_hint [9] EXPLICIT INTEGER, -- server's lifetime hint for session ticket
 *	Ticket [10]             EXPLICIT OCTET STRING, -- session ticket (clients only)
 *	Compression_meth [11]   EXPLICIT OCTET STRING, -- optional compression method
 *	SRP_username [ 12 ] EXPLICIT OCTET STRING -- optional SRP username
d443 1
a443 1
struct ssl_session_st
d515 1
a515 4
#ifndef OPENSSL_NO_SRP
	char *srp_username;
#endif
	};
a516 1
#endif
d539 1
a539 1
#define SSL_OP_ALL					0x80000BFFL
a574 2
#define SSL_OP_NO_TLSv1_2				0x08000000L
#define SSL_OP_NO_TLSv1_1				0x10000000L
a575 3
/* These next two were never actually used for anything since SSLeay
 * zap so we have some more flags.
 */
d578 2
a579 3
#define SSL_OP_PKCS1_CHECK_1				0x0
#define SSL_OP_PKCS1_CHECK_2				0x0

a639 5
#ifndef OPENSSL_NO_HEARTBEATS
#define SSL_heartbeat(ssl) \
        SSL_ctrl((ssl),SSL_CTRL_TLS_EXT_SEND_HEARTBEAT,0,NULL)
#endif

a644 35
#ifndef OPENSSL_NO_SRP

#ifndef OPENSSL_NO_SSL_INTERN

typedef struct srp_ctx_st
	{
	/* param for all the callbacks */
	void *SRP_cb_arg;
	/* set client Hello login callback */
	int (*TLS_ext_srp_username_callback)(SSL *, int *, void *);
	/* set SRP N/g param callback for verification */
	int (*SRP_verify_param_callback)(SSL *, void *);
	/* set SRP client passwd callback */
	char *(*SRP_give_srp_client_pwd_callback)(SSL *, void *);

	char *login;
	BIGNUM *N,*g,*s,*B,*A;
	BIGNUM *a,*b,*v;
	char *info;
	int strength;

	unsigned long srp_Mask;
	} SRP_CTX;

#endif

/* see tls_srp.c */
int SSL_SRP_CTX_init(SSL *s);
int SSL_CTX_SRP_CTX_init(SSL_CTX *ctx);
int SSL_SRP_CTX_free(SSL *ctx);
int SSL_CTX_SRP_CTX_free(SSL_CTX *ctx);
int SSL_srp_server_param_with_username(SSL *s, int *ad);
int SRP_generate_server_master_secret(SSL *s,unsigned char *master_key);
int SRP_Calc_A_param(SSL *s);
int SRP_generate_client_master_secret(SSL *s,unsigned char *master_key);
a645 1
#endif
d671 1
a671 5
typedef struct ssl_comp_st SSL_COMP;

#ifndef OPENSSL_NO_SSL_INTERN

struct ssl_comp_st
d680 1
a680 1
	};
d849 1
a869 26
#ifndef OPENSSL_NO_SRP
	SRP_CTX srp_ctx; /* ctx for SRP authentication */
#endif

#ifndef OPENSSL_NO_TLSEXT
# ifndef OPENSSL_NO_NEXTPROTONEG
	/* Next protocol negotiation information */
	/* (for experimental NPN extension). */

	/* For a server, this contains a callback function by which the set of
	 * advertised protocols can be provided. */
	int (*next_protos_advertised_cb)(SSL *s, const unsigned char **buf,
			                 unsigned int *len, void *arg);
	void *next_protos_advertised_cb_arg;
	/* For a client, this contains a callback function that selects the
	 * next protocol from the list provided by the server. */
	int (*next_proto_select_cb)(SSL *s, unsigned char **out,
				    unsigned char *outlen,
				    const unsigned char *in,
				    unsigned int inlen,
				    void *arg);
	void *next_proto_select_cb_arg;
# endif
        /* SRTP profiles we are willing to do from RFC 5764 */
        STACK_OF(SRTP_PROTECTION_PROFILE) *srtp_profiles;  
#endif
a871 2
#endif

a923 26
#ifndef OPENSSL_NO_NEXTPROTONEG
void SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *s,
					   int (*cb) (SSL *ssl,
						      const unsigned char **out,
						      unsigned int *outlen,
						      void *arg),
					   void *arg);
void SSL_CTX_set_next_proto_select_cb(SSL_CTX *s,
				      int (*cb) (SSL *ssl,
						 unsigned char **out,
						 unsigned char *outlen,
						 const unsigned char *in,
						 unsigned int inlen,
						 void *arg),
				      void *arg);

int SSL_select_next_proto(unsigned char **out, unsigned char *outlen,
			  const unsigned char *in, unsigned int inlen,
			  const unsigned char *client, unsigned int client_len);
void SSL_get0_next_proto_negotiated(const SSL *s,
				    const unsigned char **data, unsigned *len);

#define OPENSSL_NPN_UNSUPPORTED	0
#define OPENSSL_NPN_NEGOTIATED	1
#define OPENSSL_NPN_NO_OVERLAP	2
#endif
a963 2
#ifndef OPENSSL_NO_SSL_INTERN

d1008 3
a1010 1
	int new_session;/* Generate a new session or reuse an old one.
a1179 13

#ifndef OPENSSL_NO_NEXTPROTONEG
	/* Next protocol negotiation. For the client, this is the protocol that
	 * we sent in NextProtocol and is set when handling ServerHello
	 * extensions.
	 *
	 * For a server, this is the client's selected_protocol from
	 * NextProtocol and is set when handling the NextProtocol message,
	 * before the Finished message. */
	unsigned char *next_proto_negotiated;
	unsigned char next_proto_negotiated_len;
#endif

a1180 11

	STACK_OF(SRTP_PROTECTION_PROFILE) *srtp_profiles;  /* What we'll do */
	SRTP_PROTECTION_PROFILE *srtp_profile;            /* What's been chosen */

	unsigned int tlsext_heartbeat;  /* Is use of the Heartbeat extension negotiated?
	                                   0: disabled
	                                   1: enabled
	                                   2: enabled, but not allowed to send Requests
	                                 */
	unsigned int tlsext_hb_pending; /* Indicates if a HeartbeatRequest is in flight */
	unsigned int tlsext_hb_seq;     /* HeartbeatRequest sequence number */
a1183 8

	int renegotiate;/* 1 if we are renegotiating.
	                 * 2 if we are a server and are inside a handshake
	                 * (i.e. not just sending a HelloRequest) */

#ifndef OPENSSL_NO_SRP
	SRP_CTX srp_ctx; /* ctx for SRP authentication */
#endif
a1185 2
#endif

a1194 1
#include <openssl/srtp.h>  /* Support for the use_srtp extension */
a1410 14

#define SSL_CTRL_SET_TLS_EXT_SRP_USERNAME_CB	75
#define SSL_CTRL_SET_SRP_VERIFY_PARAM_CB		76
#define SSL_CTRL_SET_SRP_GIVE_CLIENT_PWD_CB		77

#define SSL_CTRL_SET_SRP_ARG		78
#define SSL_CTRL_SET_TLS_EXT_SRP_USERNAME		79
#define SSL_CTRL_SET_TLS_EXT_SRP_STRENGTH		80
#define SSL_CTRL_SET_TLS_EXT_SRP_PASSWORD		81
#ifndef OPENSSL_NO_HEARTBEATS
#define SSL_CTRL_TLS_EXT_SEND_HEARTBEAT				85
#define SSL_CTRL_GET_TLS_EXT_HEARTBEAT_PENDING		86
#define SSL_CTRL_SET_TLS_EXT_HEARTBEAT_NO_REQUESTS	87
#endif
a1420 3
#define SSL_CTRL_GET_EXTRA_CHAIN_CERTS		82
#define SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS	83

a1456 4
#define SSL_CTX_get_extra_chain_certs(ctx,px509) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_GET_EXTRA_CHAIN_CERTS,0,px509)
#define SSL_CTX_clear_extra_chain_certs(ctx) \
	SSL_CTX_ctrl(ctx,SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS,0,NULL)
a1483 1
unsigned long 	SSL_CIPHER_get_id(const SSL_CIPHER *c);
a1548 3
X509 *SSL_SESSION_get0_peer(SSL_SESSION *s);
int SSL_SESSION_set1_id_context(SSL_SESSION *s,const unsigned char *sid_ctx,
			       unsigned int sid_ctx_len);
a1552 1
unsigned int SSL_SESSION_get_compress_id(const SSL_SESSION *s);
a1614 24
#ifndef OPENSSL_NO_SRP
int SSL_CTX_set_srp_username(SSL_CTX *ctx,char *name);
int SSL_CTX_set_srp_password(SSL_CTX *ctx,char *password);
int SSL_CTX_set_srp_strength(SSL_CTX *ctx, int strength);
int SSL_CTX_set_srp_client_pwd_callback(SSL_CTX *ctx,
					char *(*cb)(SSL *,void *));
int SSL_CTX_set_srp_verify_param_callback(SSL_CTX *ctx,
					  int (*cb)(SSL *,void *));
int SSL_CTX_set_srp_username_callback(SSL_CTX *ctx,
				      int (*cb)(SSL *,int *,void *));
int SSL_CTX_set_srp_cb_arg(SSL_CTX *ctx, void *arg);

int SSL_set_srp_server_param(SSL *s, const BIGNUM *N, const BIGNUM *g,
			     BIGNUM *sa, BIGNUM *v, char *info);
int SSL_set_srp_server_param_pw(SSL *s, const char *user, const char *pass,
				const char *grp);

BIGNUM *SSL_get_srp_g(SSL *s);
BIGNUM *SSL_get_srp_N(SSL *s);

char *SSL_get_srp_username(SSL *s);
char *SSL_get_srp_userinfo(SSL *s);
#endif

a1649 9
const SSL_METHOD *TLSv1_1_method(void);		/* TLSv1.1 */
const SSL_METHOD *TLSv1_1_server_method(void);	/* TLSv1.1 */
const SSL_METHOD *TLSv1_1_client_method(void);	/* TLSv1.1 */

const SSL_METHOD *TLSv1_2_method(void);		/* TLSv1.2 */
const SSL_METHOD *TLSv1_2_server_method(void);	/* TLSv1.2 */
const SSL_METHOD *TLSv1_2_client_method(void);	/* TLSv1.2 */


a1657 1
int SSL_renegotiate_abbreviated(SSL *s);
a1708 1
void SSL_set_state(SSL *ssl, int state);
a1808 3
void SSL_set_debug(SSL *s, int debug);
int SSL_cache_hit(SSL *s);

a1827 1
#define SSL_F_DTLS1_CHECK_TIMEOUT_NUM			 316
a1835 1
#define SSL_F_DTLS1_HEARTBEAT				 305
a1903 1
#define SSL_F_SSL3_GET_NEXT_PROTO			 306
a1927 1
#define SSL_F_SSL_ADD_CLIENTHELLO_USE_SRTP_EXT		 307
a1931 1
#define SSL_F_SSL_ADD_SERVERHELLO_USE_SRTP_EXT		 308
a1947 1
#define SSL_F_SSL_CTX_MAKE_PROFILES			 309
a1975 1
#define SSL_F_SSL_PARSE_CLIENTHELLO_USE_SRTP_EXT	 310
a1977 1
#define SSL_F_SSL_PARSE_SERVERHELLO_USE_SRTP_EXT	 311
a1985 1
#define SSL_F_SSL_SESSION_SET1_ID_CONTEXT		 312
a1998 1
#define SSL_F_SSL_SRP_CTX_INIT				 313
a2017 2
#define SSL_F_TLS1_EXPORT_KEYING_MATERIAL		 314
#define SSL_F_TLS1_HEARTBEAT				 315
a2056 7
#define SSL_R_BAD_SRP_A_LENGTH				 347
#define SSL_R_BAD_SRP_B_LENGTH				 348
#define SSL_R_BAD_SRP_G_LENGTH				 349
#define SSL_R_BAD_SRP_N_LENGTH				 350
#define SSL_R_BAD_SRP_S_LENGTH				 351
#define SSL_R_BAD_SRTP_MKI_VALUE			 352
#define SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST		 353
a2094 1
#define SSL_R_EMPTY_SRTP_PROTECTION_PROFILE_LIST	 354
a2100 2
#define SSL_R_GOT_NEXT_PROTO_BEFORE_A_CCS		 355
#define SSL_R_GOT_NEXT_PROTO_WITHOUT_EXTENSION		 356
a2108 1
#define SSL_R_INVALID_SRP_USERNAME			 357
a2137 1
#define SSL_R_MISSING_SRP_PARAM				 358
a2166 1
#define SSL_R_NO_SRTP_PROFILES				 359
a2209 1
#define SSL_R_SIGNATURE_ALGORITHMS_ERROR		 360
a2210 4
#define SSL_R_SRP_A_CALC				 361
#define SSL_R_SRTP_COULD_NOT_ALLOCATE_PROFILES		 362
#define SSL_R_SRTP_PROTECTION_PROFILE_LIST_TOO_LONG	 363
#define SSL_R_SRTP_UNKNOWN_PROTECTION_PROFILE		 364
a2254 3
#define SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT		 365
#define SSL_R_TLS_HEARTBEAT_PENDING			 366
#define SSL_R_TLS_ILLEGAL_EXPORTER_LABEL		 367
a2275 1
#define SSL_R_UNKNOWN_DIGEST				 368
a2289 1
#define SSL_R_USE_SRTP_NOT_NEGOTIATED			 369
a2295 1
#define SSL_R_WRONG_SIGNATURE_TYPE			 370
@


1.1.1.14
log
@Import OpenSSL 1.0.1g
@
text
@a495 3
	/* Used to indicate that session resumption is not allowed.
	 * Applications can also set this bit for a new session via
	 * not_resumable_session_cb to disable session caching and tickets. */
d538 1
a538 1
	size_t tlsext_ticklen;		/* Session ticket length */
d555 1
a555 1
#define SSL_OP_SAFARI_ECDHE_ECDSA_BUG			0x00000040L
a559 3
/* Hasn't done anything since OpenSSL 0.9.7h, retained for compatibility */
#define SSL_OP_MSIE_SSLV2_RSA_PADDING			0x0

a640 6
/* Send the current time in the Random fields of the ClientHello and
 * ServerHello records for compatibility with hypothetical implementations
 * that require it.
 */
#define SSL_MODE_SEND_CLIENTHELLO_TIME 0x00000020L
#define SSL_MODE_SEND_SERVERHELLO_TIME 0x00000040L
d906 1
a906 1
#ifndef OPENSSL_NO_ENGINE
a929 1

a954 1

a2208 1
#define SSL_F_SSL_GET_SERVER_SEND_PKEY			 317
@


