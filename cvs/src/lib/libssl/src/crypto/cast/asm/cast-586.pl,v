head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.24
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.14
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.22
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.20
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.18
	OPENBSD_5_6_BASE:1.4
	butholakala:1.4
	openssl_1_0_1_g:1.1.1.3
	OPENBSD_5_5:1.4.0.16
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.12
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.10
	OPENBSD_5_3_BASE:1.4
	openssl_1_0_1_c:1.1.1.3
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.8
	openssl_1_0_0_f:1.1.1.3
	openssl_1_0_0_e:1.1.1.3
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	openssh_1_0_0_a:1.1.1.3
	OPENBSD_4_8:1.3.0.28
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.24
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.26
	OPENBSD_4_6_BASE:1.3
	openssl_0_9_8_k:1.1.1.2
	OPENBSD_4_5:1.3.0.22
	OPENBSD_4_5_BASE:1.3
	openssl_0_9_8_j:1.1.1.2
	openssl_0_9_8_h:1.1.1.2
	pre_openssl_0_9_8h:1.3
	OPENBSD_4_4:1.3.0.20
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.18
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.16
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.14
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.12
	OPENBSD_4_0_BASE:1.3
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.3.0.10
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.8
	OPENBSD_3_8_BASE:1.3
	OPENSSL_0_9_7G:1.1.1.2
	OPENBSD_3_7:1.3.0.6
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.2.0.18
	OPENBSD_3_4_BASE:1.2
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.2.0.16
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.14
	OPENBSD_3_2_BASE:1.2
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.2.0.12
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.10
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.8
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.6
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2010.10.01.22.58.54;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.18.12.39.05;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.53;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.39;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.39;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.08;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.10.01.22.54.05;	author djm;	state Exp;
branches;
next	;


desc
@@


1.4
log
@resolve conflicts, fix local changes
@
text
@#!/usr/local/bin/perl

# define for pentium pro friendly version
$ppro=1;

$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
push(@@INC,"${dir}","${dir}../../perlasm");
require "x86asm.pl";
require "cbc.pl";

&asm_init($ARGV[0],"cast-586.pl",$ARGV[$#ARGV] eq "386");

$CAST_ROUNDS=16;
$L="edi";
$R="esi";
$K="ebp";
$tmp1="ecx";
$tmp2="ebx";
$tmp3="eax";
$tmp4="edx";
$S1="CAST_S_table0";
$S2="CAST_S_table1";
$S3="CAST_S_table2";
$S4="CAST_S_table3";

@@F1=("add","xor","sub");
@@F2=("xor","sub","add");
@@F3=("sub","add","xor");

&CAST_encrypt("CAST_encrypt",1);
&CAST_encrypt("CAST_decrypt",0);
&cbc("CAST_cbc_encrypt","CAST_encrypt","CAST_decrypt",1,4,5,3,-1,-1) unless $main'openbsd;

&asm_finish();

sub CAST_encrypt {
    local($name,$enc)=@@_;

    local($win_ex)=<<"EOF";
EXTERN	_CAST_S_table0:DWORD
EXTERN	_CAST_S_table1:DWORD
EXTERN	_CAST_S_table2:DWORD
EXTERN	_CAST_S_table3:DWORD
EOF
    &main::external_label(
			  "CAST_S_table0",
			  "CAST_S_table1",
			  "CAST_S_table2",
			  "CAST_S_table3",
			  );

    &function_begin_B($name,$win_ex);

    &comment("");

    &push("ebp");
    &push("ebx");
    &mov($tmp2,&wparam(0));
    &mov($K,&wparam(1));
    &push("esi");
    &push("edi");

    &comment("Load the 2 words");
    &mov($L,&DWP(0,$tmp2,"",0));
    &mov($R,&DWP(4,$tmp2,"",0));

    &comment('Get short key flag');
    &mov($tmp3,&DWP(128,$K,"",0));
    if($enc) {
	&push($tmp3);
    } else {
	&or($tmp3,$tmp3);
	&jnz(&label('cast_dec_skip'));
    }

    &xor($tmp3,	$tmp3);

    # encrypting part

    if ($enc) {
	&E_CAST( 0,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 1,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 2,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 3,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 4,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 5,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 6,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 7,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 8,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 9,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(10,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(11,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&comment('test short key flag');
	&pop($tmp4);
	&or($tmp4,$tmp4);
	&jnz(&label('cast_enc_done'));
	&E_CAST(12,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(13,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(14,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(15,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
    } else {
	&E_CAST(15,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(14,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(13,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(12,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&set_label('cast_dec_skip');
	&E_CAST(11,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(10,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 9,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 8,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 7,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 6,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 5,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 4,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 3,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 2,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 1,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 0,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
    }

    &set_label('cast_enc_done') if $enc;
# Why the nop? - Ben 17/1/99
    &nop();
    &mov($tmp3,&wparam(0));
    &mov(&DWP(4,$tmp3,"",0),$L);
    &mov(&DWP(0,$tmp3,"",0),$R);
    &function_end($name);
}

sub E_CAST {
    local($i,$S,$L,$R,$K,$OP1,$OP2,$OP3,$tmp1,$tmp2,$tmp3,$tmp4)=@@_;
    # Ri needs to have 16 pre added.

    &comment("round $i");
    &mov(	$tmp4,		&DWP($i*8,$K,"",1));

    &mov(	$tmp1,		&DWP($i*8+4,$K,"",1));
    &$OP1(	$tmp4,		$R);

    &rotl(	$tmp4,		&LB($tmp1));

    if ($ppro) {
	&mov(	$tmp2,		$tmp4);		# B
	&xor(	$tmp1,		$tmp1);
	
	&movb(	&LB($tmp1),	&HB($tmp4));	# A
	&and(	$tmp2,		0xff);

	&shr(	$tmp4,		16); 		#
	&xor(	$tmp3,		$tmp3);
    } else {
	&mov(	$tmp2,		$tmp4);		# B
	&movb(	&LB($tmp1),	&HB($tmp4));	# A	# BAD BAD BAD
	
	&shr(	$tmp4,		16); 		#
	&and(	$tmp2,		0xff);
    }

    &movb(	&LB($tmp3),	&HB($tmp4));	# C	# BAD BAD BAD
    &and(	$tmp4,		0xff);		# D

    &mov(	$tmp1,		&DWP($S1,"",$tmp1,4));
    &mov(	$tmp2,		&DWP($S2,"",$tmp2,4));

    &$OP2(	$tmp1,		$tmp2);
    &mov(	$tmp2,		&DWP($S3,"",$tmp3,4));

    &$OP3(	$tmp1,		$tmp2);
    &mov(	$tmp2,		&DWP($S4,"",$tmp4,4));

    &$OP1(	$tmp1,		$tmp2);
    # XXX

    &xor(	$L,		$tmp1);
    # XXX
}

@


1.3
log
@use bn_asm_vax.S (from netbsd); test + ok by miod
use asm code for i386, except for the CBC code, because
it is not clean PIC code.
add <machime/asm.h> support to x86unix.pl
tested by: nick (on 30386), henning, djm, tedu, jmc and more;
no shlib minor crank necessary, only internal symbols changed.
@
text
@d6 2
a7 1
push(@@INC,"perlasm","../../perlasm");
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d31 1
a31 1
&cbc("CAST_cbc_encrypt","CAST_encrypt","CAST_decrypt",1,4,5,3,-1,-1);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#!/usr/bin/perl
d10 1
a10 1
&asm_init($ARGV[0],"cast-586.pl");
d35 2
a36 3
sub CAST_encrypt
	{
	local($name,$enc)=@@_;
d38 1
a38 1
	local($win_ex)=<<"EOF";
d44 133
a176 123
	&main'external_label(
		"CAST_S_table0",
		"CAST_S_table1",
		"CAST_S_table2",
		"CAST_S_table3",
		);

	&function_begin_B($name,$win_ex);

	&comment("");

	&push("ebp");
	&push("ebx");
	&mov($tmp2,&wparam(0));
	&mov($K,&wparam(1));
	&push("esi");
	&push("edi");

	&comment("Load the 2 words");
	&mov($L,&DWP(0,$tmp2,"",0));
	&mov($R,&DWP(4,$tmp2,"",0));

	&xor(	$tmp3,	$tmp3);

	# encrypting part

	if ($enc)
		{
		&E_CAST( 0,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 1,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 2,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 3,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 4,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 5,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 6,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 7,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 8,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 9,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(10,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(11,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(12,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(13,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(14,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(15,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4,1);
		}
	else
		{
		&E_CAST(15,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(14,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(13,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(12,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(11,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(10,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 9,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 8,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 7,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 6,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 5,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 4,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 3,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 2,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 1,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 0,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4,1);
		}

	&nop();
	&mov(&DWP(4,$tmp3,"",0),$L);
	&mov(&DWP(0,$tmp3,"",0),$R);
	&function_end($name);
	}

sub E_CAST
	{
	local($i,$S,$L,$R,$K,$OP1,$OP2,$OP3,$tmp1,$tmp2,$tmp3,$tmp4,$lst)=@@_;
	# Ri needs to have 16 pre added.

	&comment("round $i");
	&mov(	$tmp4,		&DWP($i*8,$K,"",1));

	&mov(	$tmp1,		&DWP($i*8+4,$K,"",1));# must be word
	&$OP1(	$tmp4,		$R);

	&rotl(	$tmp4,		&LB($tmp1));

	if ($ppro)
		{
		&mov(	$tmp2,		$tmp4);		# B
		&xor(	$tmp1,		$tmp1);

		&movb(	&LB($tmp1),	&HB($tmp4));	# A
		&and(	$tmp2,		0xff);

		&shr(	$tmp4,		16); 		#
		&xor(	$tmp3,		$tmp3);
		}
	else
		{
		&mov(	$tmp2,		$tmp4);		# B
		&movb(	&LB($tmp1),	&HB($tmp4));	# A	# BAD BAD BAD

		&shr(	$tmp4,		16); 		#
		&and(	$tmp2,		0xff);
		}

	&movb(	&LB($tmp3),	&HB($tmp4));	# C	# BAD BAD BAD
	&and(	$tmp4,		0xff);		# D

	&mov(	$tmp1,		&DWP($S1,"",$tmp1,4));
	&mov(	$tmp2,		&DWP($S2,"",$tmp2,4));

	&$OP2(	$tmp1,		$tmp2);
	&mov(	$tmp2,		&DWP($S3,"",$tmp3,4));

	&$OP3(	$tmp1,		$tmp2);
	&mov(	$tmp2,		&DWP($S4,"",$tmp4,4));

	&$OP1(	$tmp1,		$tmp2);
	 &mov($tmp3,&wparam(0)) if $lst;
	 # XXX

	&xor(	$L,		$tmp1);
	 # XXX
	}
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d1 1
a1 1
#!/usr/local/bin/perl
d10 1
a10 1
&asm_init($ARGV[0],"cast-586.pl",$ARGV[$#ARGV] eq "386");
d35 3
a37 2
sub CAST_encrypt {
    local($name,$enc)=@@_;
d39 1
a39 1
    local($win_ex)=<<"EOF";
d45 123
a167 133
    &main::external_label(
			  "CAST_S_table0",
			  "CAST_S_table1",
			  "CAST_S_table2",
			  "CAST_S_table3",
			  );

    &function_begin_B($name,$win_ex);

    &comment("");

    &push("ebp");
    &push("ebx");
    &mov($tmp2,&wparam(0));
    &mov($K,&wparam(1));
    &push("esi");
    &push("edi");

    &comment("Load the 2 words");
    &mov($L,&DWP(0,$tmp2,"",0));
    &mov($R,&DWP(4,$tmp2,"",0));

    &comment('Get short key flag');
    &mov($tmp3,&DWP(128,$K,"",0));
    if($enc) {
	&push($tmp3);
    } else {
	&or($tmp3,$tmp3);
	&jnz(&label('cast_dec_skip'));
    }

    &xor($tmp3,	$tmp3);

    # encrypting part

    if ($enc) {
	&E_CAST( 0,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 1,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 2,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 3,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 4,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 5,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 6,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 7,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 8,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 9,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(10,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(11,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&comment('test short key flag');
	&pop($tmp4);
	&or($tmp4,$tmp4);
	&jnz(&label('cast_enc_done'));
	&E_CAST(12,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(13,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(14,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(15,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
    } else {
	&E_CAST(15,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(14,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(13,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(12,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&set_label('cast_dec_skip');
	&E_CAST(11,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(10,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 9,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 8,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 7,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 6,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 5,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 4,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 3,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 2,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 1,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 0,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
    }

    &set_label('cast_enc_done') if $enc;
# Why the nop? - Ben 17/1/99
    &nop();
    &mov($tmp3,&wparam(0));
    &mov(&DWP(4,$tmp3,"",0),$L);
    &mov(&DWP(0,$tmp3,"",0),$R);
    &function_end($name);
}

sub E_CAST {
    local($i,$S,$L,$R,$K,$OP1,$OP2,$OP3,$tmp1,$tmp2,$tmp3,$tmp4)=@@_;
    # Ri needs to have 16 pre added.

    &comment("round $i");
    &mov(	$tmp4,		&DWP($i*8,$K,"",1));

    &mov(	$tmp1,		&DWP($i*8+4,$K,"",1));
    &$OP1(	$tmp4,		$R);

    &rotl(	$tmp4,		&LB($tmp1));

    if ($ppro) {
	&mov(	$tmp2,		$tmp4);		# B
	&xor(	$tmp1,		$tmp1);
	
	&movb(	&LB($tmp1),	&HB($tmp4));	# A
	&and(	$tmp2,		0xff);

	&shr(	$tmp4,		16); 		#
	&xor(	$tmp3,		$tmp3);
    } else {
	&mov(	$tmp2,		$tmp4);		# B
	&movb(	&LB($tmp1),	&HB($tmp4));	# A	# BAD BAD BAD
	
	&shr(	$tmp4,		16); 		#
	&and(	$tmp2,		0xff);
    }

    &movb(	&LB($tmp3),	&HB($tmp4));	# C	# BAD BAD BAD
    &and(	$tmp4,		0xff);		# D

    &mov(	$tmp1,		&DWP($S1,"",$tmp1,4));
    &mov(	$tmp2,		&DWP($S2,"",$tmp2,4));

    &$OP2(	$tmp1,		$tmp2);
    &mov(	$tmp2,		&DWP($S3,"",$tmp3,4));

    &$OP3(	$tmp1,		$tmp2);
    &mov(	$tmp2,		&DWP($S4,"",$tmp4,4));

    &$OP1(	$tmp1,		$tmp2);
    # XXX

    &xor(	$L,		$tmp1);
    # XXX
}

@


1.1.1.3
log
@import OpenSSL-1.0.0a
@
text
@d6 1
a6 2
$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
push(@@INC,"${dir}","${dir}../../perlasm");
@


