head	1.15;
access;
symbols
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.4
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	butholakala:1.7
	openssl_1_0_1_g:1.1.1.4
	OPENBSD_5_5:1.7.0.24
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.20
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.18
	OPENBSD_5_3_BASE:1.7
	openssl_1_0_1_c:1.1.1.4
	OPENBSD_5_2:1.7.0.14
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.16
	openssl_1_0_0_f:1.1.1.4
	openssl_1_0_0_e:1.1.1.4
	OPENBSD_5_0:1.7.0.12
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.10
	OPENBSD_4_9_BASE:1.7
	openssh_1_0_0_a:1.1.1.4
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	openssl_0_9_8_k:1.1.1.4
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	openssl_0_9_8_j:1.1.1.4
	openssl_0_9_8_h:1.1.1.4
	pre_openssl_0_9_8h:1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	openssl_0_9_7j:1.1.1.3
	openssl:1.1.1
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENSSL_0_9_7G:1.1.1.3
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENSSL_0_9_7D:1.1.1.3
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENSSL_0_9_7C:1.1.1.3
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2016.07.05.02.54.35;	author bcook;	state Exp;
branches;
next	1.14;
commitid	NHesUMO050EuY7RN;

1.14
date	2015.10.21.19.02.22;	author miod;	state Exp;
branches;
next	1.13;
commitid	NwfjRNMG7NEIjq8F;

1.13
date	2015.02.09.15.49.22;	author jsing;	state Exp;
branches;
next	1.12;
commitid	69Tc75PIK8JcRRsC;

1.12
date	2014.10.18.17.20.40;	author jsing;	state Exp;
branches;
next	1.11;
commitid	8tb4v3IC8S2vzfHj;

1.11
date	2014.07.12.16.03.36;	author miod;	state Exp;
branches;
next	1.10;
commitid	G74O1dmRukKsW7IJ;

1.10
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.9;
commitid	yQEL1wOWIearrW15;

1.9
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	mJUVYpkFBZ0Zv2bG;

1.8
date	2014.05.08.13.20.49;	author jsing;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.49;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.14.20.34.33;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.12.02.18.36;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.09.19;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.45;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.59;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.34.43;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	;


desc
@@


1.15
log
@On systems where we do not have BN_ULLONG defined (most 64-bit systems),
BN_mod_word() can return incorrect results if the supplied modulus is
too big, so we need to fall back to BN_div_word.

Now that BN_mod_word may fail, handle errors properly update the man page.

Thanks to Brian Smith for pointing out these fixes from BoringSSL:

https://boringssl.googlesource.com/boringssl/+/67cb49d045f04973ddba0f92fe8a8ad483c7da89
https://boringssl.googlesource.com/boringssl/+/44bedc348d9491e63c7ed1438db100a4b8a830be

ok beck@@
@
text
@/* $OpenBSD: bn_prime.c,v 1.14 2015/10/21 19:02:22 miod Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <time.h>

#include <openssl/err.h>

#include "bn_lcl.h"

/* NB: these functions have been "upgraded", the deprecated versions (which are
 * compatibility wrappers using these functions) are in bn_depr.c.
 * - Geoff
 */

/* The quick sieve algorithm approach to weeding out primes is
 * Philip Zimmermann's, as implemented in PGP.  I have had a read of
 * his comments and implemented my own version.
 */
#include "bn_prime.h"

static int witness(BIGNUM *w, const BIGNUM *a, const BIGNUM *a1,
    const BIGNUM *a1_odd, int k, BN_CTX *ctx, BN_MONT_CTX *mont);
static int probable_prime(BIGNUM *rnd, int bits);
static int probable_prime_dh(BIGNUM *rnd, int bits,
    const BIGNUM *add, const BIGNUM *rem, BN_CTX *ctx);
static int probable_prime_dh_safe(BIGNUM *rnd, int bits,
    const BIGNUM *add, const BIGNUM *rem, BN_CTX *ctx);

int
BN_GENCB_call(BN_GENCB *cb, int a, int b)
{
	/* No callback means continue */
	if (!cb)
		return 1;
	switch (cb->ver) {
	case 1:
		/* Deprecated-style callbacks */
		if (!cb->cb.cb_1)
			return 1;
		cb->cb.cb_1(a, b, cb->arg);
		return 1;
	case 2:
		/* New-style callbacks */
		return cb->cb.cb_2(a, b, cb);
	default:
		break;
	}
	/* Unrecognised callback type */
	return 0;
}

int
BN_generate_prime_ex(BIGNUM *ret, int bits, int safe, const BIGNUM *add,
    const BIGNUM *rem, BN_GENCB *cb)
{
	BIGNUM *t;
	int found = 0;
	int i, j, c1 = 0;
	BN_CTX *ctx;
	int checks;

	if (bits < 2 || (bits == 2 && safe)) {
		/*
		 * There are no prime numbers smaller than 2, and the smallest
		 * safe prime (7) spans three bits.
		 */
		BNerr(BN_F_BN_GENERATE_PRIME_EX, BN_R_BITS_TOO_SMALL);
		return 0;
	}

	ctx = BN_CTX_new();
	if (ctx == NULL)
		goto err;
	BN_CTX_start(ctx);
	if ((t = BN_CTX_get(ctx)) == NULL)
		goto err;

	checks = BN_prime_checks_for_size(bits);

loop:
	/* make a random number and set the top and bottom bits */
	if (add == NULL) {
		if (!probable_prime(ret, bits))
			goto err;
	} else {
		if (safe) {
			if (!probable_prime_dh_safe(ret, bits, add, rem, ctx))
				goto err;
		} else {
			if (!probable_prime_dh(ret, bits, add, rem, ctx))
				goto err;
		}
	}
	/* if (BN_mod_word(ret,(BN_ULONG)3) == 1) goto loop; */
	if (!BN_GENCB_call(cb, 0, c1++))
		/* aborted */
		goto err;

	if (!safe) {
		i = BN_is_prime_fasttest_ex(ret, checks, ctx, 0, cb);
		if (i == -1)
			goto err;
		if (i == 0)
			goto loop;
	} else {
		/* for "safe prime" generation,
		 * check that (p-1)/2 is prime.
		 * Since a prime is odd, We just
		 * need to divide by 2 */
		if (!BN_rshift1(t, ret))
			goto err;

		for (i = 0; i < checks; i++) {
			j = BN_is_prime_fasttest_ex(ret, 1, ctx, 0, cb);
			if (j == -1)
				goto err;
			if (j == 0)
				goto loop;

			j = BN_is_prime_fasttest_ex(t, 1, ctx, 0, cb);
			if (j == -1)
				goto err;
			if (j == 0)
				goto loop;

			if (!BN_GENCB_call(cb, 2, c1 - 1))
				goto err;
			/* We have a safe prime test pass */
		}
	}
	/* we have a prime :-) */
	found = 1;

err:
	if (ctx != NULL) {
		BN_CTX_end(ctx);
		BN_CTX_free(ctx);
	}
	bn_check_top(ret);
	return found;
}

int
BN_is_prime_ex(const BIGNUM *a, int checks, BN_CTX *ctx_passed, BN_GENCB *cb)
{
	return BN_is_prime_fasttest_ex(a, checks, ctx_passed, 0, cb);
}

int
BN_is_prime_fasttest_ex(const BIGNUM *a, int checks, BN_CTX *ctx_passed,
    int do_trial_division, BN_GENCB *cb)
{
	int i, j, ret = -1;
	int k;
	BN_CTX *ctx = NULL;
	BIGNUM *A1, *A1_odd, *check; /* taken from ctx */
	BN_MONT_CTX *mont = NULL;
	const BIGNUM *A = NULL;

	if (BN_cmp(a, BN_value_one()) <= 0)
		return 0;

	if (checks == BN_prime_checks)
		checks = BN_prime_checks_for_size(BN_num_bits(a));

	/* first look for small factors */
	if (!BN_is_odd(a))
		/* a is even => a is prime if and only if a == 2 */
		return BN_is_word(a, 2);
	if (do_trial_division) {
		for (i = 1; i < NUMPRIMES; i++) {
			BN_ULONG mod = BN_mod_word(a, primes[i]);
			if (mod == (BN_ULONG)-1)
				goto err;
			if (mod == 0)
				return 0;
		}
		if (!BN_GENCB_call(cb, 1, -1))
			goto err;
	}

	if (ctx_passed != NULL)
		ctx = ctx_passed;
	else if ((ctx = BN_CTX_new()) == NULL)
		goto err;
	BN_CTX_start(ctx);

	/* A := abs(a) */
	if (a->neg) {
		BIGNUM *t;
		if ((t = BN_CTX_get(ctx)) == NULL)
			goto err;
		BN_copy(t, a);
		t->neg = 0;
		A = t;
	} else
		A = a;
	if ((A1 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((A1_odd = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((check = BN_CTX_get(ctx)) == NULL)
		goto err;

	/* compute A1 := A - 1 */
	if (!BN_copy(A1, A))
		goto err;
	if (!BN_sub_word(A1, 1))
		goto err;
	if (BN_is_zero(A1)) {
		ret = 0;
		goto err;
	}

	/* write  A1  as  A1_odd * 2^k */
	k = 1;
	while (!BN_is_bit_set(A1, k))
		k++;
	if (!BN_rshift(A1_odd, A1, k))
		goto err;

	/* Montgomery setup for computations mod A */
	mont = BN_MONT_CTX_new();
	if (mont == NULL)
		goto err;
	if (!BN_MONT_CTX_set(mont, A, ctx))
		goto err;

	for (i = 0; i < checks; i++) {
		if (!BN_pseudo_rand_range(check, A1))
			goto err;
		if (!BN_add_word(check, 1))
			goto err;
		/* now 1 <= check < A */

		j = witness(check, A, A1, A1_odd, k, ctx, mont);
		if (j == -1)
			goto err;
		if (j) {
			ret = 0;
			goto err;
		}
		if (!BN_GENCB_call(cb, 1, i))
			goto err;
	}
	ret = 1;

err:
	if (ctx != NULL) {
		BN_CTX_end(ctx);
		if (ctx_passed == NULL)
			BN_CTX_free(ctx);
	}
	BN_MONT_CTX_free(mont);

	return (ret);
}

static int
witness(BIGNUM *w, const BIGNUM *a, const BIGNUM *a1, const BIGNUM *a1_odd,
    int k, BN_CTX *ctx, BN_MONT_CTX *mont)
{
	if (!BN_mod_exp_mont(w, w, a1_odd, a, ctx, mont))
		/* w := w^a1_odd mod a */
		return -1;
	if (BN_is_one(w))
		return 0; /* probably prime */
	if (BN_cmp(w, a1) == 0)
		return 0; /* w == -1 (mod a),  'a' is probably prime */
	while (--k) {
		if (!BN_mod_mul(w, w, w, a, ctx)) /* w := w^2 mod a */
			return -1;
		if (BN_is_one(w))
			return 1; /* 'a' is composite, otherwise a previous 'w' would
			           * have been == -1 (mod 'a') */
		if (BN_cmp(w, a1) == 0)
			return 0; /* w == -1 (mod a), 'a' is probably prime */
	}
	/* If we get here, 'w' is the (a-1)/2-th power of the original 'w',
	 * and it is neither -1 nor +1 -- so 'a' cannot be prime */
	bn_check_top(w);
	return 1;
}

static int
probable_prime(BIGNUM *rnd, int bits)
{
	int i;
	prime_t mods[NUMPRIMES];
	BN_ULONG delta, maxdelta;

again:
	if (!BN_rand(rnd, bits, 1, 1))
		return (0);
	/* we now have a random number 'rand' to test. */
	for (i = 1; i < NUMPRIMES; i++) {
		BN_ULONG mod = BN_mod_word(rnd, (BN_ULONG)primes[i]);
		if (mod == (BN_ULONG)-1)
			return (0);
		mods[i] = (prime_t)mod;
	}
	maxdelta = BN_MASK2 - primes[NUMPRIMES - 1];
	delta = 0;
loop:
	for (i = 1; i < NUMPRIMES; i++) {
		/* check that rnd is not a prime and also
		 * that gcd(rnd-1,primes) == 1 (except for 2) */
		if (((mods[i] + delta) % primes[i]) <= 1) {
			delta += 2;
			if (delta > maxdelta)
				goto again;
			goto loop;
		}
	}
	if (!BN_add_word(rnd, delta))
		return (0);
	bn_check_top(rnd);
	return (1);
}

static int
probable_prime_dh(BIGNUM *rnd, int bits, const BIGNUM *add, const BIGNUM *rem,
    BN_CTX *ctx)
{
	int i, ret = 0;
	BIGNUM *t1;

	BN_CTX_start(ctx);
	if ((t1 = BN_CTX_get(ctx)) == NULL)
		goto err;

	if (!BN_rand(rnd, bits, 0, 1))
		goto err;

	/* we need ((rnd-rem) % add) == 0 */

	if (!BN_mod(t1, rnd, add, ctx))
		goto err;
	if (!BN_sub(rnd, rnd, t1))
		goto err;
	if (rem == NULL) {
		if (!BN_add_word(rnd, 1))
			goto err;
	} else {
		if (!BN_add(rnd, rnd, rem))
			goto err;
	}

	/* we now have a random number 'rand' to test. */

loop:
	for (i = 1; i < NUMPRIMES; i++) {
		/* check that rnd is a prime */
		BN_LONG mod = BN_mod_word(rnd, (BN_ULONG)primes[i]);
		if (mod == (BN_ULONG)-1)
			goto err;
		if (mod <= 1) {
			if (!BN_add(rnd, rnd, add))
				goto err;
			goto loop;
		}
	}
	ret = 1;

err:
	BN_CTX_end(ctx);
	bn_check_top(rnd);
	return (ret);
}

static int
probable_prime_dh_safe(BIGNUM *p, int bits, const BIGNUM *padd,
    const BIGNUM *rem, BN_CTX *ctx)
{
	int i, ret = 0;
	BIGNUM *t1, *qadd, *q;

	bits--;
	BN_CTX_start(ctx);
	if ((t1 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((q = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((qadd = BN_CTX_get(ctx)) == NULL)
		goto err;

	if (!BN_rshift1(qadd, padd))
		goto err;

	if (!BN_rand(q, bits, 0, 1))
		goto err;

	/* we need ((rnd-rem) % add) == 0 */
	if (!BN_mod(t1, q,qadd, ctx))
		goto err;
	if (!BN_sub(q, q, t1))
		goto err;
	if (rem == NULL) {
		if (!BN_add_word(q, 1))
			goto err;
	} else {
		if (!BN_rshift1(t1, rem))
			goto err;
		if (!BN_add(q, q, t1))
			goto err;
	}

	/* we now have a random number 'rand' to test. */
	if (!BN_lshift1(p, q))
		goto err;
	if (!BN_add_word(p, 1))
		goto err;

loop:
	for (i = 1; i < NUMPRIMES; i++) {
		/* check that p and q are prime */
		/* check that for p and q
		 * gcd(p-1,primes) == 1 (except for 2) */
		BN_ULONG pmod = BN_mod_word(p, (BN_ULONG)primes[i]);
		BN_ULONG qmod = BN_mod_word(q, (BN_ULONG)primes[i]);
		if (pmod == (BN_ULONG)-1 || qmod == (BN_ULONG)-1)
			goto err;
		if (pmod == 0 || qmod == 0) {
			if (!BN_add(p, p, padd))
				goto err;
			if (!BN_add(q, q, qadd))
				goto err;
			goto loop;
		}
	}
	ret = 1;

err:
	BN_CTX_end(ctx);
	bn_check_top(p);
	return (ret);
}
@


1.14
log
@Reject too small bits value in BN_generate_prime_ex(), so that it does not risk
becoming negative in probable_prime_dh_safe(). Reported by Franck Denis who
noticed `openssl gendh 0' would segfault.
Fix adapted from OpenSSL RT#2701.

ok beck@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_prime.c,v 1.13 2015/02/09 15:49:22 jsing Exp $ */
d280 5
a284 2
		for (i = 1; i < NUMPRIMES; i++)
			if (BN_mod_word(a, primes[i]) == 0)
d286 1
d405 6
a410 2
	for (i = 1; i < NUMPRIMES; i++)
		mods[i] = (prime_t)BN_mod_word(rnd, (BN_ULONG)primes[i]);
d463 4
a466 1
		if (BN_mod_word(rnd, (BN_ULONG)primes[i]) <= 1) {
d528 5
a532 2
		if ((BN_mod_word(p, (BN_ULONG)primes[i]) == 0) ||
		    (BN_mod_word(q, (BN_ULONG)primes[i]) == 0)) {
@


1.13
log
@BN_CTX_get() can fail - consistently check its return value.

There are currently cases where the return from each call is checked,
the return from only the last call is checked and cases where it is not
checked at all (including code in bn, ec and engine).

Checking the last return value is valid as once the function fails it will
continue to return NULL. However, in order to be consistent check each
call with the same idiom. This makes it easy to verify.

Note there are still a handful of cases that do not follow the idiom -
these will be handled separately.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_prime.c,v 1.12 2014/10/18 17:20:40 jsing Exp $ */
d115 2
d169 10
a178 1
	int checks = BN_prime_checks_for_size(bits);
d186 3
@


1.12
log
@None of these need to include <openssl/rand.h>
@
text
@d1 1
a1 1
/* $OpenBSD: bn_prime.c,v 1.11 2014/07/12 16:03:36 miod Exp $ */
d173 1
a173 2
	t = BN_CTX_get(ctx);
	if (!t)
d289 5
a293 4
	A1 = BN_CTX_get(ctx);
	A1_odd = BN_CTX_get(ctx);
	check = BN_CTX_get(ctx);
	if (check == NULL)
d464 5
a468 4
	t1 = BN_CTX_get(ctx);
	q = BN_CTX_get(ctx);
	qadd = BN_CTX_get(ctx);
	if (qadd == NULL)
@


1.11
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_prime.c,v 1.10 2014/07/11 08:44:48 jsing Exp $ */
a113 2

#include <openssl/rand.h>
@


1.10
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_prime.c,v 1.9 2014/06/12 15:49:28 deraadt Exp $ */
d347 1
a347 2
	if (mont != NULL)
		BN_MONT_CTX_free(mont);
@


1.9
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d114 3
a116 1
#include "cryptlib.h"
a117 1
#include <openssl/rand.h>
@


1.8
log
@Emergency knfectomie requested by tedu@@.
@
text
@d1 1
a1 1
/* crypto/bn/bn_prime.c */
@


1.7
log
@resolve conflicts
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d130 1
a130 1
	const BIGNUM *a1_odd, int k, BN_CTX *ctx, BN_MONT_CTX *mont);
d133 1
a133 1
	const BIGNUM *add, const BIGNUM *rem, BN_CTX *ctx);
d135 1
a135 1
	const BIGNUM *add, const BIGNUM *rem, BN_CTX *ctx);
d137 3
a139 2
int BN_GENCB_call(BN_GENCB *cb, int a, int b)
	{
d141 3
a143 3
	if(!cb) return 1;
	switch(cb->ver)
		{
d146 1
a146 1
		if(!cb->cb.cb_1)
d155 1
a155 1
		}
d158 1
a158 1
	}
d160 4
a163 3
int BN_generate_prime_ex(BIGNUM *ret, int bits, int safe,
	const BIGNUM *add, const BIGNUM *rem, BN_GENCB *cb)
	{
d165 2
a166 2
	int found=0;
	int i,j,c1=0;
d170 3
a172 2
	ctx=BN_CTX_new();
	if (ctx == NULL) goto err;
d175 3
a177 2
	if(!t) goto err;
loop: 
d179 9
a187 14
	if (add == NULL)
		{
		if (!probable_prime(ret,bits)) goto err;
		}
	else
		{
		if (safe)
			{
			if (!probable_prime_dh_safe(ret,bits,add,rem,ctx))
				 goto err;
			}
		else
			{
			if (!probable_prime_dh(ret,bits,add,rem,ctx))
a188 1
			}
d190 1
d192 1
a192 1
	if(!BN_GENCB_call(cb, 0, c1++))
d196 7
a202 8
	if (!safe)
		{
		i=BN_is_prime_fasttest_ex(ret,checks,ctx,0,cb);
		if (i == -1) goto err;
		if (i == 0) goto loop;
		}
	else
		{
d207 2
a208 1
		if (!BN_rshift1(t,ret)) goto err;
d210 6
a215 9
		for (i=0; i<checks; i++)
			{
			j=BN_is_prime_fasttest_ex(ret,1,ctx,0,cb);
			if (j == -1) goto err;
			if (j == 0) goto loop;

			j=BN_is_prime_fasttest_ex(t,1,ctx,0,cb);
			if (j == -1) goto err;
			if (j == 0) goto loop;
d217 7
a223 1
			if(!BN_GENCB_call(cb, 2, c1-1))
a225 1
			}
d227 1
d230 1
d232 1
a232 2
	if (ctx != NULL)
		{
d235 1
a235 1
		}
d238 1
a238 1
	}
d240 3
a242 2
int BN_is_prime_ex(const BIGNUM *a, int checks, BN_CTX *ctx_passed, BN_GENCB *cb)
	{
d244 1
a244 1
	}
d246 4
a249 3
int BN_is_prime_fasttest_ex(const BIGNUM *a, int checks, BN_CTX *ctx_passed,
		int do_trial_division, BN_GENCB *cb)
	{
d259 1
a259 1
	
d267 1
a267 2
	if (do_trial_division)
		{
d269 1
a269 1
			if (BN_mod_word(a, primes[i]) == 0) 
d271 1
a271 1
		if(!BN_GENCB_call(cb, 1, -1))
d273 1
a273 1
		}
d277 2
a278 3
	else
		if ((ctx=BN_CTX_new()) == NULL)
			goto err;
d282 1
a282 2
	if (a->neg)
		{
d284 2
a285 1
		if ((t = BN_CTX_get(ctx)) == NULL) goto err;
d289 1
a289 2
		}
	else
d294 2
a295 1
	if (check == NULL) goto err;
d302 1
a302 2
	if (BN_is_zero(A1))
		{
d305 1
a305 1
		}
d320 2
a321 3
	
	for (i = 0; i < checks; i++)
		{
d329 1
a329 4
		if (j == -1) goto err;
		if (j)
			{
			ret=0;
d331 2
a332 2
			}
		if(!BN_GENCB_call(cb, 1, i))
d335 5
a339 1
	ret=1;
d341 1
a341 2
	if (ctx != NULL)
		{
d345 1
a345 1
		}
d349 2
a350 2
	return(ret);
	}
d352 6
a357 4
static int witness(BIGNUM *w, const BIGNUM *a, const BIGNUM *a1,
	const BIGNUM *a1_odd, int k, BN_CTX *ctx, BN_MONT_CTX *mont)
	{
	if (!BN_mod_exp_mont(w, w, a1_odd, a, ctx, mont)) /* w := w^a1_odd mod a */
d363 1
a363 2
	while (--k)
		{
d371 1
a371 1
		}
d376 1
a376 1
	}
d378 3
a380 2
static int probable_prime(BIGNUM *rnd, int bits)
	{
d383 1
a383 1
	BN_ULONG delta,maxdelta;
d386 2
a387 1
	if (!BN_rand(rnd,bits,1,1)) return(0);
d389 6
a394 6
	for (i=1; i<NUMPRIMES; i++)
		mods[i]=(prime_t)BN_mod_word(rnd,(BN_ULONG)primes[i]);
	maxdelta=BN_MASK2 - primes[NUMPRIMES-1];
	delta=0;
	loop: for (i=1; i<NUMPRIMES; i++)
		{
d397 4
a400 4
		if (((mods[i]+delta)%primes[i]) <= 1)
			{
			delta+=2;
			if (delta > maxdelta) goto again;
a401 1
			}
d403 3
a405 1
	if (!BN_add_word(rnd,delta)) return(0);
d407 2
a408 2
	return(1);
	}
d410 5
a414 4
static int probable_prime_dh(BIGNUM *rnd, int bits,
	const BIGNUM *add, const BIGNUM *rem, BN_CTX *ctx)
	{
	int i,ret=0;
d418 2
a419 1
	if ((t1 = BN_CTX_get(ctx)) == NULL) goto err;
d421 2
a422 1
	if (!BN_rand(rnd,bits,0,1)) goto err;
d426 11
a436 6
	if (!BN_mod(t1,rnd,add,ctx)) goto err;
	if (!BN_sub(rnd,rnd,t1)) goto err;
	if (rem == NULL)
		{ if (!BN_add_word(rnd,1)) goto err; }
	else
		{ if (!BN_add(rnd,rnd,rem)) goto err; }
d440 2
a441 2
	loop: for (i=1; i<NUMPRIMES; i++)
		{
d443 3
a445 3
		if (BN_mod_word(rnd,(BN_ULONG)primes[i]) <= 1)
			{
			if (!BN_add(rnd,rnd,add)) goto err;
a446 1
			}
d448 3
a450 1
	ret=1;
d454 2
a455 2
	return(ret);
	}
d457 6
a462 5
static int probable_prime_dh_safe(BIGNUM *p, int bits, const BIGNUM *padd,
	const BIGNUM *rem, BN_CTX *ctx)
	{
	int i,ret=0;
	BIGNUM *t1,*qadd,*q;
d469 5
a473 1
	if (qadd == NULL) goto err;
d475 2
a476 3
	if (!BN_rshift1(qadd,padd)) goto err;
		
	if (!BN_rand(q,bits,0,1)) goto err;
d479 13
a491 9
	if (!BN_mod(t1,q,qadd,ctx)) goto err;
	if (!BN_sub(q,q,t1)) goto err;
	if (rem == NULL)
		{ if (!BN_add_word(q,1)) goto err; }
	else
		{
		if (!BN_rshift1(t1,rem)) goto err;
		if (!BN_add(q,q,t1)) goto err;
		}
d494 4
a497 2
	if (!BN_lshift1(p,q)) goto err;
	if (!BN_add_word(p,1)) goto err;
d499 2
a500 2
	loop: for (i=1; i<NUMPRIMES; i++)
		{
d504 6
a509 5
		if (	(BN_mod_word(p,(BN_ULONG)primes[i]) == 0) ||
			(BN_mod_word(q,(BN_ULONG)primes[i]) == 0))
			{
			if (!BN_add(p,p,padd)) goto err;
			if (!BN_add(q,q,qadd)) goto err;
a510 1
			}
d512 3
a514 1
	ret=1;
d518 2
a519 2
	return(ret);
	}
@


1.6
log
@make BN_is_prime() realise that 2 is, in fact, a prime number.
from OpenSSL CVS; ok otto@@ deraadt@@
@
text
@d118 5
d137 24
a160 3
BIGNUM *BN_generate_prime(BIGNUM *ret, int bits, int safe,
	const BIGNUM *add, const BIGNUM *rem,
	void (*callback)(int,int,void *), void *cb_arg)
d162 1
a162 2
	BIGNUM *rnd=NULL;
	BIGNUM t;
a167 1
	BN_init(&t);
d170 3
a172 6
	if (ret == NULL)
		{
		if ((rnd=BN_new()) == NULL) goto err;
		}
	else
		rnd=ret;
d177 1
a177 1
		if (!probable_prime(rnd,bits)) goto err;
d183 1
a183 1
			if (!probable_prime_dh_safe(rnd,bits,add,rem,ctx))
d188 1
a188 1
			if (!probable_prime_dh(rnd,bits,add,rem,ctx))
d192 4
a195 2
	/* if (BN_mod_word(rnd,(BN_ULONG)3) == 1) goto loop; */
	if (callback != NULL) callback(0,c1++,cb_arg);
d199 1
a199 1
		i=BN_is_prime_fasttest(rnd,checks,callback,ctx,cb_arg,0);
d209 1
a209 1
		if (!BN_rshift1(&t,rnd)) goto err;
d213 1
a213 1
			j=BN_is_prime_fasttest(rnd,1,callback,ctx,cb_arg,0);
d217 1
a217 1
			j=BN_is_prime_fasttest(&t,1,callback,ctx,cb_arg,0);
d221 2
a222 1
			if (callback != NULL) callback(2,c1-1,cb_arg);
d229 7
a235 4
	if (!found && (ret == NULL) && (rnd != NULL)) BN_free(rnd);
	BN_free(&t);
	if (ctx != NULL) BN_CTX_free(ctx);
	return(found ? rnd : NULL);
d238 1
a238 2
int BN_is_prime(const BIGNUM *a, int checks, void (*callback)(int,int,void *),
	BN_CTX *ctx_passed, void *cb_arg)
d240 1
a240 1
	return BN_is_prime_fasttest(a, checks, callback, ctx_passed, cb_arg, 0);
d243 2
a244 4
int BN_is_prime_fasttest(const BIGNUM *a, int checks,
		void (*callback)(int,int,void *),
		BN_CTX *ctx_passed, void *cb_arg,
		int do_trial_division)
a262 1

d268 2
a269 1
		if (callback != NULL) callback(1, -1, cb_arg);
d335 2
a336 1
		if (callback != NULL) callback(1,i,cb_arg);
d373 1
d380 2
a381 2
	BN_ULONG mods[NUMPRIMES];
	BN_ULONG delta,d;
d387 2
a388 1
		mods[i]=BN_mod_word(rnd,(BN_ULONG)primes[i]);
a395 1
			d=delta;
d397 1
a397 4
			/* perhaps need to check for overflow of
			 * delta (but delta can be up to 2^32)
			 * 21-May-98 eay - added overflow check */
			if (delta < d) goto again;
d402 1
d440 1
d492 1
@


1.5
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d237 3
a239 1
		return 0;
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d143 1
a151 1
	BN_init(&t);
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
d128 1
a128 1
	BIGNUM *add, BIGNUM *rem, BN_CTX *ctx);
d130 1
a130 1
	BIGNUM *add, BIGNUM *rem, BN_CTX *ctx);
d132 3
a134 2
BIGNUM *BN_generate_prime(BIGNUM *ret, int bits, int safe, BIGNUM *add,
	     BIGNUM *rem, void (*callback)(int,int,void *), void *cb_arg)
d229 3
d237 1
a237 1
		return(0);
d296 1
a296 1
		if (!BN_pseudo_rand(check, BN_num_bits(A1), 0, 0))
a297 3
		if (BN_cmp(check, A1) >= 0)
			if (!BN_sub(check, check, A1))
				goto err;
d380 2
a381 2
static int probable_prime_dh(BIGNUM *rnd, int bits, BIGNUM *add, BIGNUM *rem,
	     BN_CTX *ctx)
d417 2
a418 2
static int probable_prime_dh_safe(BIGNUM *p, int bits, BIGNUM *padd,
	     BIGNUM *rem, BN_CTX *ctx)
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d58 53
d118 1
a118 1
/* The quick seive algorithm approach to weeding out primes is
d124 2
a125 2
static int witness(BIGNUM *a, BIGNUM *n, BN_CTX *ctx,BN_CTX *ctx2,
	BN_MONT_CTX *mont);
d129 1
a129 1
static int probable_prime_dh_strong(BIGNUM *rnd, int bits,
d131 2
a132 1
BIGNUM *BN_generate_prime(BIGNUM *ret, int bits, int strong, BIGNUM *add,
d137 1
d140 1
d159 1
a159 1
		if (strong)
d161 1
a161 1
			if (!probable_prime_dh_strong(rnd,bits,add,rem,ctx))
d173 1
a173 1
	if (!strong)
d175 1
a175 1
		i=BN_is_prime(rnd,BN_prime_checks,callback,ctx,cb_arg);
d181 1
a181 1
		/* for a strong prime generation,
d187 1
a187 1
		for (i=0; i<BN_prime_checks; i++)
d189 1
a189 1
			j=BN_is_prime(rnd,1,callback,ctx,cb_arg);
d193 1
a193 1
			j=BN_is_prime(&t,1,callback,ctx,cb_arg);
d198 1
a198 1
			/* We have a strong prime test pass */
d202 1
a202 1
	ret=rnd;
d204 1
a204 1
	if ((ret == NULL) && (rnd != NULL)) BN_free(rnd);
d207 7
a213 1
	return(ret);
d216 4
a219 2
int BN_is_prime(BIGNUM *a, int checks, void (*callback)(int,int,void *),
	     BN_CTX *ctx_passed, void *cb_arg)
d221 9
a229 4
	int i,j,c2=0,ret= -1;
	BIGNUM *check;
	BN_CTX *ctx=NULL,*ctx2=NULL;
	BN_MONT_CTX *mont=NULL;
d231 1
d234 8
d243 1
a243 1
		ctx=ctx_passed;
d245 3
a247 1
		if ((ctx=BN_CTX_new()) == NULL) goto err;
d249 51
a299 2
	if ((ctx2=BN_CTX_new()) == NULL) goto err;
	if ((mont=BN_MONT_CTX_new()) == NULL) goto err;
d301 1
a301 9
	check= &(ctx->bn[ctx->tos++]);

	/* Setup the montgomery structure */
	if (!BN_MONT_CTX_set(mont,a,ctx2)) goto err;

	for (i=0; i<checks; i++)
		{
		if (!BN_rand(check,BN_num_bits(a)-1,0,0)) goto err;
		j=witness(check,a,ctx,ctx2,mont);
d308 1
a308 1
		if (callback != NULL) callback(1,c2++,cb_arg);
d312 9
a320 7
	ctx->tos--;
	if ((ctx_passed == NULL) && (ctx != NULL))
		BN_CTX_free(ctx);
	if (ctx2 != NULL)
		BN_CTX_free(ctx2);
	if (mont != NULL) BN_MONT_CTX_free(mont);
		
d324 2
a325 4
#define RECP_MUL_MOD

static int witness(BIGNUM *a, BIGNUM *n, BN_CTX *ctx, BN_CTX *ctx2,
	     BN_MONT_CTX *mont)
d327 19
a345 59
	int k,i,ret= -1,good;
	BIGNUM *d,*dd,*tmp,*d1,*d2,*n1;
	BIGNUM *mont_one,*mont_n1,*mont_a;

	d1= &(ctx->bn[ctx->tos]);
	d2= &(ctx->bn[ctx->tos+1]);
	n1= &(ctx->bn[ctx->tos+2]);
	ctx->tos+=3;

	mont_one= &(ctx2->bn[ctx2->tos]);
	mont_n1= &(ctx2->bn[ctx2->tos+1]);
	mont_a= &(ctx2->bn[ctx2->tos+2]);
	ctx2->tos+=3;

	d=d1;
	dd=d2;
	if (!BN_one(d)) goto err;
	if (!BN_sub(n1,n,d)) goto err; /* n1=n-1; */
	k=BN_num_bits(n1);

	if (!BN_to_montgomery(mont_one,BN_value_one(),mont,ctx2)) goto err;
	if (!BN_to_montgomery(mont_n1,n1,mont,ctx2)) goto err;
	if (!BN_to_montgomery(mont_a,a,mont,ctx2)) goto err;

	BN_copy(d,mont_one);
	for (i=k-1; i>=0; i--)
		{
		if (	(BN_cmp(d,mont_one) != 0) &&
			(BN_cmp(d,mont_n1) != 0))
			good=1;
		else
			good=0;

		BN_mod_mul_montgomery(dd,d,d,mont,ctx2);

		if (good && (BN_cmp(dd,mont_one) == 0))
			{
			ret=1;
			goto err;
			}
		if (BN_is_bit_set(n1,i))
			{
			BN_mod_mul_montgomery(d,dd,mont_a,mont,ctx2);
			}
		else
			{
			tmp=d;
			d=dd;
			dd=tmp;
			}
		}
	if (BN_cmp(d,mont_one) == 0)
		i=0;
	else	i=1;
	ret=i;
err:
	ctx->tos-=3;
	ctx2->tos-=3;
	return(ret);
d351 1
a351 1
	MS_STATIC BN_ULONG mods[NUMPRIMES];
d369 1
a369 1
			 * delta (but delta can be upto 2^32)
d385 2
a386 1
	t1= &(ctx->bn[ctx->tos++]);
d412 1
a412 1
	ctx->tos--;
d416 1
a416 1
static int probable_prime_dh_strong(BIGNUM *p, int bits, BIGNUM *padd,
d420 1
a420 1
	BIGNUM *t1,*qadd=NULL,*q=NULL;
d423 5
a427 3
	t1= &(ctx->bn[ctx->tos++]);
	q= &(ctx->bn[ctx->tos++]);
	qadd= &(ctx->bn[ctx->tos++]);
d463 1
a463 66
	ctx->tos-=3;
	return(ret);
	}

#if 0
static int witness(BIGNUM *a, BIGNUM *n, BN_CTX *ctx)
	{
	int k,i,nb,ret= -1;
	BIGNUM *d,*dd,*tmp;
	BIGNUM *d1,*d2,*x,*n1,*inv;

	d1= &(ctx->bn[ctx->tos]);
	d2= &(ctx->bn[ctx->tos+1]);
	x=  &(ctx->bn[ctx->tos+2]);
	n1= &(ctx->bn[ctx->tos+3]);
	inv=&(ctx->bn[ctx->tos+4]);
	ctx->tos+=5;

	d=d1;
	dd=d2;
	if (!BN_one(d)) goto err;
	if (!BN_sub(n1,n,d)) goto err; /* n1=n-1; */
	k=BN_num_bits(n1);

	/* i=BN_num_bits(n); */
#ifdef RECP_MUL_MOD
	nb=BN_reciprocal(inv,n,ctx); /**/
	if (nb == -1) goto err;
#endif

	for (i=k-1; i>=0; i--)
		{
		if (BN_copy(x,d) == NULL) goto err;
#ifndef RECP_MUL_MOD
		if (!BN_mod_mul(dd,d,d,n,ctx)) goto err;
#else
		if (!BN_mod_mul_reciprocal(dd,d,d,n,inv,nb,ctx)) goto err;
#endif
		if (	BN_is_one(dd) &&
			!BN_is_one(x) &&
			(BN_cmp(x,n1) != 0))
			{
			ret=1;
			goto err;
			}
		if (BN_is_bit_set(n1,i))
			{
#ifndef RECP_MUL_MOD
			if (!BN_mod_mul(d,dd,a,n,ctx)) goto err;
#else
			if (!BN_mod_mul_reciprocal(d,dd,a,n,inv,nb,ctx)) goto err; 
#endif
			}
		else
			{
			tmp=d;
			d=dd;
			dd=tmp;
			}
		}
	if (BN_is_one(d))
		i=0;
	else	i=1;
	ret=i;
err:
	ctx->tos-=5;
a465 1
#endif
@


1.1
log
@Initial revision
@
text
@d63 1
a63 1
#include "rand.h"
a70 1
#ifndef NOPROTO
d78 2
a79 14
#else
static int witness();
static int probable_prime();
static int probable_prime_dh();
static int probable_prime_dh_strong();
#endif

BIGNUM *BN_generate_prime(bits,strong,add,rem,callback,cb_arg)
int bits;
int strong;
BIGNUM *add;
BIGNUM *rem;
void (*callback)(P_I_I_P); 
char *cb_arg;
d82 1
a82 2
	BIGNUM *ret=NULL;
	BIGNUM *t=NULL;
d88 7
a94 3
	if ((rnd=BN_new()) == NULL) goto err;
	if (strong)
		if ((t=BN_new()) == NULL) goto err;
d129 1
a129 1
		if (!BN_rshift1(t,rnd)) goto err;
d137 1
a137 1
			j=BN_is_prime(t,1,callback,ctx,cb_arg);
d149 1
a149 1
	if (t != NULL) BN_free(t);
d154 2
a155 6
int BN_is_prime(a,checks,callback,ctx_passed,cb_arg)
BIGNUM *a;
int checks;
void (*callback)(P_I_I_P);
BN_CTX *ctx_passed;
char *cb_arg;
d172 1
a172 1
	check=ctx->bn[ctx->tos++];
d203 2
a204 5
static int witness(a,n,ctx,ctx2,mont)
BIGNUM *a;
BIGNUM *n;
BN_CTX *ctx,*ctx2;
BN_MONT_CTX *mont;
d210 3
a212 3
	d1=ctx->bn[ctx->tos];
	d2=ctx->bn[ctx->tos+1];
	n1=ctx->bn[ctx->tos+2];
d215 3
a217 3
	mont_one=ctx2->bn[ctx2->tos];
	mont_n1=ctx2->bn[ctx2->tos+1];
	mont_a=ctx2->bn[ctx2->tos+2];
d240 1
a240 1
		
d267 1
a267 3
static int probable_prime(rnd, bits)
BIGNUM *rnd;
int bits;
d271 1
a271 1
	BN_ULONG delta;
d273 1
d285 1
d288 3
a290 1
			 * delta (but delta can be upto 2^32) */
d298 2
a299 6
static int probable_prime_dh(rnd, bits, add, rem,ctx)
BIGNUM *rnd;
int bits;
BIGNUM *add;
BIGNUM *rem;
BN_CTX *ctx;
d304 1
a304 1
	t1=ctx->bn[ctx->tos++];
d322 1
a322 1
		if (BN_mod_word(rnd,(BN_LONG)primes[i]) <= 1)
d334 2
a335 6
static int probable_prime_dh_strong(p, bits, padd, rem,ctx)
BIGNUM *p;
int bits;
BIGNUM *padd;
BIGNUM *rem;
BN_CTX *ctx;
d341 3
a343 3
	t1=ctx->bn[ctx->tos++];
	q=ctx->bn[ctx->tos++];
	qadd=ctx->bn[ctx->tos++];
d369 2
a370 2
		if (	(BN_mod_word(p,(BN_LONG)primes[i]) == 0) ||
			(BN_mod_word(q,(BN_LONG)primes[i]) == 0))
d384 1
a384 4
static int witness(a, n,ctx)
BIGNUM *a;
BIGNUM *n;
BN_CTX *ctx;
d390 5
a394 5
	d1=ctx->bn[ctx->tos];
	d2=ctx->bn[ctx->tos+1];
	x=ctx->bn[ctx->tos+2];
	n1=ctx->bn[ctx->tos+3];
	inv=ctx->bn[ctx->tos+4];
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d63 1
a63 1
#include <openssl/rand.h>
d65 1
a65 1
/* The quick sieve algorithm approach to weeding out primes is
d71 3
a73 2
static int witness(BIGNUM *w, const BIGNUM *a, const BIGNUM *a1,
	const BIGNUM *a1_odd, int k, BN_CTX *ctx, BN_MONT_CTX *mont);
d76 17
a92 7
	const BIGNUM *add, const BIGNUM *rem, BN_CTX *ctx);
static int probable_prime_dh_safe(BIGNUM *rnd, int bits,
	const BIGNUM *add, const BIGNUM *rem, BN_CTX *ctx);

BIGNUM *BN_generate_prime(BIGNUM *ret, int bits, int safe,
	const BIGNUM *add, const BIGNUM *rem,
	void (*callback)(int,int,void *), void *cb_arg)
d95 2
a96 2
	BIGNUM t;
	int found=0;
a98 1
	int checks = BN_prime_checks_for_size(bits);
d102 3
a104 7
	if (ret == NULL)
		{
		if ((rnd=BN_new()) == NULL) goto err;
		}
	else
		rnd=ret;
	BN_init(&t);
d113 1
a113 1
		if (safe)
d115 1
a115 1
			if (!probable_prime_dh_safe(rnd,bits,add,rem,ctx))
d127 1
a127 1
	if (!safe)
d129 1
a129 1
		i=BN_is_prime_fasttest(rnd,checks,callback,ctx,cb_arg,0);
d135 1
a135 1
		/* for "safe prime" generation,
d139 1
a139 1
		if (!BN_rshift1(&t,rnd)) goto err;
d141 1
a141 1
		for (i=0; i<checks; i++)
d143 1
a143 1
			j=BN_is_prime_fasttest(rnd,1,callback,ctx,cb_arg,0);
d147 1
a147 1
			j=BN_is_prime_fasttest(&t,1,callback,ctx,cb_arg,0);
d152 1
a152 1
			/* We have a safe prime test pass */
d156 1
a156 1
	found = 1;
d158 2
a159 2
	if (!found && (ret == NULL) && (rnd != NULL)) BN_free(rnd);
	BN_free(&t);
d161 1
a161 7
	return(found ? rnd : NULL);
	}

int BN_is_prime(const BIGNUM *a, int checks, void (*callback)(int,int,void *),
	BN_CTX *ctx_passed, void *cb_arg)
	{
	return BN_is_prime_fasttest(a, checks, callback, ctx_passed, cb_arg, 0);
d164 6
a169 4
int BN_is_prime_fasttest(const BIGNUM *a, int checks,
		void (*callback)(int,int,void *),
		BN_CTX *ctx_passed, void *cb_arg,
		int do_trial_division)
d171 4
a174 12
	int i, j, ret = -1;
	int k;
	BN_CTX *ctx = NULL;
	BIGNUM *A1, *A1_odd, *check; /* taken from ctx */
	BN_MONT_CTX *mont = NULL;
	const BIGNUM *A = NULL;

	if (BN_cmp(a, BN_value_one()) <= 0)
		return 0;
	
	if (checks == BN_prime_checks)
		checks = BN_prime_checks_for_size(BN_num_bits(a));
a175 1
	/* first look for small factors */
d177 1
a177 9
		return 0;
	if (do_trial_division)
		{
		for (i = 1; i < NUMPRIMES; i++)
			if (BN_mod_word(a, primes[i]) == 0) 
				return 0;
		if (callback != NULL) callback(1, -1, cb_arg);
		}

d179 1
a179 1
		ctx = ctx_passed;
d181 9
a189 3
		if ((ctx=BN_CTX_new()) == NULL)
			goto err;
	BN_CTX_start(ctx);
d191 1
a191 42
	/* A := abs(a) */
	if (a->neg)
		{
		BIGNUM *t;
		if ((t = BN_CTX_get(ctx)) == NULL) goto err;
		BN_copy(t, a);
		t->neg = 0;
		A = t;
		}
	else
		A = a;
	A1 = BN_CTX_get(ctx);
	A1_odd = BN_CTX_get(ctx);
	check = BN_CTX_get(ctx);
	if (check == NULL) goto err;

	/* compute A1 := A - 1 */
	if (!BN_copy(A1, A))
		goto err;
	if (!BN_sub_word(A1, 1))
		goto err;
	if (BN_is_zero(A1))
		{
		ret = 0;
		goto err;
		}

	/* write  A1  as  A1_odd * 2^k */
	k = 1;
	while (!BN_is_bit_set(A1, k))
		k++;
	if (!BN_rshift(A1_odd, A1, k))
		goto err;

	/* Montgomery setup for computations mod A */
	mont = BN_MONT_CTX_new();
	if (mont == NULL)
		goto err;
	if (!BN_MONT_CTX_set(mont, A, ctx))
		goto err;
	
	for (i = 0; i < checks; i++)
d193 2
a194 7
		if (!BN_pseudo_rand_range(check, A1))
			goto err;
		if (!BN_add_word(check, 1))
			goto err;
		/* now 1 <= check < A */

		j = witness(check, A, A1, A1_odd, k, ctx, mont);
d201 1
a201 1
		if (callback != NULL) callback(1,i,cb_arg);
d205 7
a211 9
	if (ctx != NULL)
		{
		BN_CTX_end(ctx);
		if (ctx_passed == NULL)
			BN_CTX_free(ctx);
		}
	if (mont != NULL)
		BN_MONT_CTX_free(mont);

d215 7
a221 2
static int witness(BIGNUM *w, const BIGNUM *a, const BIGNUM *a1,
	const BIGNUM *a1_odd, int k, BN_CTX *ctx, BN_MONT_CTX *mont)
d223 59
a281 19
	if (!BN_mod_exp_mont(w, w, a1_odd, a, ctx, mont)) /* w := w^a1_odd mod a */
		return -1;
	if (BN_is_one(w))
		return 0; /* probably prime */
	if (BN_cmp(w, a1) == 0)
		return 0; /* w == -1 (mod a),  'a' is probably prime */
	while (--k)
		{
		if (!BN_mod_mul(w, w, w, a, ctx)) /* w := w^2 mod a */
			return -1;
		if (BN_is_one(w))
			return 1; /* 'a' is composite, otherwise a previous 'w' would
			           * have been == -1 (mod 'a') */
		if (BN_cmp(w, a1) == 0)
			return 0; /* w == -1 (mod a), 'a' is probably prime */
		}
	/* If we get here, 'w' is the (a-1)/2-th power of the original 'w',
	 * and it is neither -1 nor +1 -- so 'a' cannot be prime */
	return 1;
d284 3
a286 1
static int probable_prime(BIGNUM *rnd, int bits)
d289 2
a290 2
	BN_ULONG mods[NUMPRIMES];
	BN_ULONG delta,d;
a291 1
again:
a302 1
			d=delta;
d305 1
a305 3
			 * delta (but delta can be up to 2^32)
			 * 21-May-98 eay - added overflow check */
			if (delta < d) goto again;
d313 6
a318 2
static int probable_prime_dh(BIGNUM *rnd, int bits,
	const BIGNUM *add, const BIGNUM *rem, BN_CTX *ctx)
d323 1
a323 2
	BN_CTX_start(ctx);
	if ((t1 = BN_CTX_get(ctx)) == NULL) goto err;
d341 1
a341 1
		if (BN_mod_word(rnd,(BN_ULONG)primes[i]) <= 1)
d349 1
a349 1
	BN_CTX_end(ctx);
d353 6
a358 2
static int probable_prime_dh_safe(BIGNUM *p, int bits, const BIGNUM *padd,
	const BIGNUM *rem, BN_CTX *ctx)
d361 1
a361 1
	BIGNUM *t1,*qadd,*q;
d364 3
a366 5
	BN_CTX_start(ctx);
	t1 = BN_CTX_get(ctx);
	q = BN_CTX_get(ctx);
	qadd = BN_CTX_get(ctx);
	if (qadd == NULL) goto err;
d392 2
a393 2
		if (	(BN_mod_word(p,(BN_ULONG)primes[i]) == 0) ||
			(BN_mod_word(q,(BN_ULONG)primes[i]) == 0))
d402 69
a470 1
	BN_CTX_end(ctx);
d473 1
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@a142 1
	BN_init(&t);
d151 1
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@a117 5
/* NB: these functions have been "upgraded", the deprecated versions (which are
 * compatibility wrappers using these functions) are in bn_depr.c.
 * - Geoff
 */

d132 3
a134 24
int BN_GENCB_call(BN_GENCB *cb, int a, int b)
	{
	/* No callback means continue */
	if(!cb) return 1;
	switch(cb->ver)
		{
	case 1:
		/* Deprecated-style callbacks */
		if(!cb->cb.cb_1)
			return 1;
		cb->cb.cb_1(a, b, cb->arg);
		return 1;
	case 2:
		/* New-style callbacks */
		return cb->cb.cb_2(a, b, cb);
	default:
		break;
		}
	/* Unrecognised callback type */
	return 0;
	}

int BN_generate_prime_ex(BIGNUM *ret, int bits, int safe,
	const BIGNUM *add, const BIGNUM *rem, BN_GENCB *cb)
d136 2
a137 1
	BIGNUM *t;
d143 1
d146 6
a151 3
	BN_CTX_start(ctx);
	t = BN_CTX_get(ctx);
	if(!t) goto err;
d156 1
a156 1
		if (!probable_prime(ret,bits)) goto err;
d162 1
a162 1
			if (!probable_prime_dh_safe(ret,bits,add,rem,ctx))
d167 1
a167 1
			if (!probable_prime_dh(ret,bits,add,rem,ctx))
d171 2
a172 4
	/* if (BN_mod_word(ret,(BN_ULONG)3) == 1) goto loop; */
	if(!BN_GENCB_call(cb, 0, c1++))
		/* aborted */
		goto err;
d176 1
a176 1
		i=BN_is_prime_fasttest_ex(ret,checks,ctx,0,cb);
d186 1
a186 1
		if (!BN_rshift1(t,ret)) goto err;
d190 1
a190 1
			j=BN_is_prime_fasttest_ex(ret,1,ctx,0,cb);
d194 1
a194 1
			j=BN_is_prime_fasttest_ex(t,1,ctx,0,cb);
d198 1
a198 2
			if(!BN_GENCB_call(cb, 2, c1-1))
				goto err;
d205 4
a208 7
	if (ctx != NULL)
		{
		BN_CTX_end(ctx);
		BN_CTX_free(ctx);
		}
	bn_check_top(ret);
	return found;
d211 2
a212 1
int BN_is_prime_ex(const BIGNUM *a, int checks, BN_CTX *ctx_passed, BN_GENCB *cb)
d214 1
a214 1
	return BN_is_prime_fasttest_ex(a, checks, ctx_passed, 0, cb);
d217 4
a220 2
int BN_is_prime_fasttest_ex(const BIGNUM *a, int checks, BN_CTX *ctx_passed,
		int do_trial_division, BN_GENCB *cb)
d237 1
a237 2
		/* a is even => a is prime if and only if a == 2 */
		return BN_is_word(a, 2);
d243 1
a243 2
		if(!BN_GENCB_call(cb, 1, -1))
			goto err;
d309 1
a309 2
		if(!BN_GENCB_call(cb, 1, i))
			goto err;
a345 1
	bn_check_top(w);
d352 2
a353 2
	prime_t mods[NUMPRIMES];
	BN_ULONG delta,maxdelta;
d359 1
a359 2
		mods[i]=(prime_t)BN_mod_word(rnd,(BN_ULONG)primes[i]);
	maxdelta=BN_MASK2 - primes[NUMPRIMES-1];
d367 1
d369 4
a372 1
			if (delta > maxdelta) goto again;
a376 1
	bn_check_top(rnd);
a413 1
	bn_check_top(rnd);
a464 1
	bn_check_top(p);
@


