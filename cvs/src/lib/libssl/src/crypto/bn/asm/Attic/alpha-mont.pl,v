head	1.3;
access;
symbols
	OPENBSD_6_0:1.2.0.10
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.8
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.6
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2
	butholakala:1.1.1.3
	openssl_1_0_1_g:1.1.1.3
	OPENSSL:1.1.1
	OPENBSD_5_5:1.1.1.3.0.12
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.8
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.6
	OPENBSD_5_3_BASE:1.1.1.3
	openssl_1_0_1_c:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.2
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.4
	openssl_1_0_0_f:1.1.1.3
	openssl_1_0_0_e:1.1.1.3
	OPENBSD_5_0:1.1.1.2.0.4
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	openssh_1_0_0_a:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.6
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.4
	OPENBSD_4_6_BASE:1.1.1.1
	openssl_0_9_8_k:1.1.1.1
	openssl:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2016.09.03.11.33.35;	author beck;	state dead;
branches;
next	1.2;
commitid	HnbXxsegngek41U2;

1.2
date	2014.05.01.20.41.56;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.06.06.30.01;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.04.06.06.30.01;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.10.01.22.54.04;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.11.03.02.32.09;	author djm;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Remove the libssl/src directory
@
text
@#!/usr/bin/env perl
#
# ====================================================================
# Written by Andy Polyakov <appro@@fy.chalmers.se> for the OpenSSL
# project. The module is, however, dual licensed under OpenSSL and
# CRYPTOGAMS licenses depending on where you obtain it. For further
# details see http://www.openssl.org/~appro/cryptogams/.
# ====================================================================
#
# On 21264 RSA sign performance improves by 70/35/20/15 percent for
# 512/1024/2048/4096 bit key lengths. This is against vendor compiler
# instructed to '-tune host' code with in-line assembler. Other
# benchmarks improve by 15-20%. To anchor it to something else, the
# code provides approximately the same performance per GHz as AMD64.
# I.e. if you compare 1GHz 21264 and 2GHz Opteron, you'll observe ~2x
# difference.

# int bn_mul_mont(
$rp="a0";	# BN_ULONG *rp,
$ap="a1";	# const BN_ULONG *ap,
$bp="a2";	# const BN_ULONG *bp,
$np="a3";	# const BN_ULONG *np,
$n0="a4";	# const BN_ULONG *n0,
$num="a5";	# int num);

$lo0="t0";
$hi0="t1";
$lo1="t2";
$hi1="t3";
$aj="t4";
$bi="t5";
$nj="t6";
$tp="t7";
$alo="t8";
$ahi="t9";
$nlo="t10";
$nhi="t11";
$tj="t12";
$i="s3";
$j="s4";
$m1="s5";

$code=<<___;
#include <machine/asm.h>

.text

.set	noat
.set	noreorder

.globl	bn_mul_mont
.align	5
.ent	bn_mul_mont
bn_mul_mont:
	lda	sp,-48(sp)
	stq	ra,0(sp)
	stq	s3,8(sp)
	stq	s4,16(sp)
	stq	s5,24(sp)
	stq	fp,32(sp)
	mov	sp,fp
	.mask	0x0400f000,-48
	.frame	fp,48,ra
	.prologue 0

	.align	4
	.set	reorder
	sextl	$num,$num
	mov	0,v0
	cmplt	$num,4,AT
	bne	AT,.Lexit

	ldq	$hi0,0($ap)	# ap[0]
	s8addq	$num,16,AT
	ldq	$aj,8($ap)
	subq	sp,AT,sp
	ldq	$bi,0($bp)	# bp[0]
	lda	AT,-4096(zero)	# mov	-4096,AT
	ldq	$n0,0($n0)
	and	sp,AT,sp

	mulq	$hi0,$bi,$lo0
	ldq	$hi1,0($np)	# np[0]
	umulh	$hi0,$bi,$hi0
	ldq	$nj,8($np)

	mulq	$lo0,$n0,$m1

	mulq	$hi1,$m1,$lo1
	umulh	$hi1,$m1,$hi1

	addq	$lo1,$lo0,$lo1
	cmpult	$lo1,$lo0,AT
	addq	$hi1,AT,$hi1

	mulq	$aj,$bi,$alo
	mov	2,$j
	umulh	$aj,$bi,$ahi
	mov	sp,$tp

	mulq	$nj,$m1,$nlo
	s8addq	$j,$ap,$aj
	umulh	$nj,$m1,$nhi
	s8addq	$j,$np,$nj
.align	4
.L1st:
	.set	noreorder
	ldq	$aj,0($aj)
	addl	$j,1,$j
	ldq	$nj,0($nj)
	lda	$tp,8($tp)

	addq	$alo,$hi0,$lo0
	mulq	$aj,$bi,$alo
	cmpult	$lo0,$hi0,AT
	addq	$nlo,$hi1,$lo1

	mulq	$nj,$m1,$nlo
	addq	$ahi,AT,$hi0
	cmpult	$lo1,$hi1,v0
	cmplt	$j,$num,$tj

	umulh	$aj,$bi,$ahi
	addq	$nhi,v0,$hi1
	addq	$lo1,$lo0,$lo1
	s8addq	$j,$ap,$aj

	umulh	$nj,$m1,$nhi
	cmpult	$lo1,$lo0,v0
	addq	$hi1,v0,$hi1
	s8addq	$j,$np,$nj

	stq	$lo1,-8($tp)
	nop
	unop
	bne	$tj,.L1st
	.set	reorder

	addq	$alo,$hi0,$lo0
	addq	$nlo,$hi1,$lo1
	cmpult	$lo0,$hi0,AT
	cmpult	$lo1,$hi1,v0
	addq	$ahi,AT,$hi0
	addq	$nhi,v0,$hi1

	addq	$lo1,$lo0,$lo1
	cmpult	$lo1,$lo0,v0
	addq	$hi1,v0,$hi1

	stq	$lo1,0($tp)

	addq	$hi1,$hi0,$hi1
	cmpult	$hi1,$hi0,AT
	stq	$hi1,8($tp)
	stq	AT,16($tp)

	mov	1,$i
.align	4
.Louter:
	s8addq	$i,$bp,$bi
	ldq	$hi0,0($ap)
	ldq	$aj,8($ap)
	ldq	$bi,0($bi)
	ldq	$hi1,0($np)
	ldq	$nj,8($np)
	ldq	$tj,0(sp)

	mulq	$hi0,$bi,$lo0
	umulh	$hi0,$bi,$hi0

	addq	$lo0,$tj,$lo0
	cmpult	$lo0,$tj,AT
	addq	$hi0,AT,$hi0

	mulq	$lo0,$n0,$m1

	mulq	$hi1,$m1,$lo1
	umulh	$hi1,$m1,$hi1

	addq	$lo1,$lo0,$lo1
	cmpult	$lo1,$lo0,AT
	mov	2,$j
	addq	$hi1,AT,$hi1

	mulq	$aj,$bi,$alo
	mov	sp,$tp
	umulh	$aj,$bi,$ahi

	mulq	$nj,$m1,$nlo
	s8addq	$j,$ap,$aj
	umulh	$nj,$m1,$nhi
.align	4
.Linner:
	.set	noreorder
	ldq	$tj,8($tp)	#L0
	nop			#U1
	ldq	$aj,0($aj)	#L1
	s8addq	$j,$np,$nj	#U0

	ldq	$nj,0($nj)	#L0
	nop			#U1
	addq	$alo,$hi0,$lo0	#L1
	lda	$tp,8($tp)

	mulq	$aj,$bi,$alo	#U1
	cmpult	$lo0,$hi0,AT	#L0
	addq	$nlo,$hi1,$lo1	#L1
	addl	$j,1,$j

	mulq	$nj,$m1,$nlo	#U1
	addq	$ahi,AT,$hi0	#L0
	addq	$lo0,$tj,$lo0	#L1
	cmpult	$lo1,$hi1,v0	#U0

	umulh	$aj,$bi,$ahi	#U1
	cmpult	$lo0,$tj,AT	#L0
	addq	$lo1,$lo0,$lo1	#L1
	addq	$nhi,v0,$hi1	#U0

	umulh	$nj,$m1,$nhi	#U1
	s8addq	$j,$ap,$aj	#L0
	cmpult	$lo1,$lo0,v0	#L1
	cmplt	$j,$num,$tj	#U0	# borrow $tj

	addq	$hi0,AT,$hi0	#L0
	addq	$hi1,v0,$hi1	#U1
	stq	$lo1,-8($tp)	#L1
	bne	$tj,.Linner	#U0
	.set	reorder

	ldq	$tj,8($tp)
	addq	$alo,$hi0,$lo0
	addq	$nlo,$hi1,$lo1
	cmpult	$lo0,$hi0,AT
	cmpult	$lo1,$hi1,v0
	addq	$ahi,AT,$hi0
	addq	$nhi,v0,$hi1

	addq	$lo0,$tj,$lo0
	cmpult	$lo0,$tj,AT
	addq	$hi0,AT,$hi0

	ldq	$tj,16($tp)
	addq	$lo1,$lo0,$j
	cmpult	$j,$lo0,v0
	addq	$hi1,v0,$hi1

	addq	$hi1,$hi0,$lo1
	stq	$j,0($tp)
	cmpult	$lo1,$hi0,$hi1
	addq	$lo1,$tj,$lo1
	cmpult	$lo1,$tj,AT
	addl	$i,1,$i
	addq	$hi1,AT,$hi1
	stq	$lo1,8($tp)
	cmplt	$i,$num,$tj	# borrow $tj
	stq	$hi1,16($tp)
	bne	$tj,.Louter

	s8addq	$num,sp,$tj	# &tp[num]
	mov	$rp,$bp		# put rp aside
	mov	sp,$tp
	mov	sp,$ap
	mov	0,$hi0		# clear borrow bit

.align	4
.Lsub:	ldq	$lo0,0($tp)
	ldq	$lo1,0($np)
	lda	$tp,8($tp)
	lda	$np,8($np)
	subq	$lo0,$lo1,$lo1	# tp[i]-np[i]
	cmpult	$lo0,$lo1,AT
	subq	$lo1,$hi0,$lo0
	cmpult	$lo1,$lo0,$hi0
	or	$hi0,AT,$hi0
	stq	$lo0,0($rp)
	cmpult	$tp,$tj,v0
	lda	$rp,8($rp)
	bne	v0,.Lsub

	subq	$hi1,$hi0,$hi0	# handle upmost overflow bit
	mov	sp,$tp
	mov	$bp,$rp		# restore rp

	and	sp,$hi0,$ap
	bic	$bp,$hi0,$bp
	bis	$bp,$ap,$ap	# ap=borrow?tp:rp

.align	4
.Lcopy:	ldq	$aj,0($ap)	# copy or in-place refresh
	lda	$tp,8($tp)
	lda	$rp,8($rp)
	lda	$ap,8($ap)
	stq	zero,-8($tp)	# zap tp
	cmpult	$tp,$tj,AT
	stq	$aj,-8($rp)
	bne	AT,.Lcopy
	mov	1,v0

.Lexit:
	.set	noreorder
	mov	fp,sp
	/*ldq	ra,0(sp)*/
	ldq	s3,8(sp)
	ldq	s4,16(sp)
	ldq	s5,24(sp)
	ldq	fp,32(sp)
	lda	sp,48(sp)
	ret	(ra)
.end	bn_mul_mont
.ascii	"Montgomery Multiplication for Alpha, CRYPTOGAMS by <appro\@@openssl.org>"
.align	2
___

print $code;
close STDOUT;
@


1.2
log
@Fix include filename to get register name aliases under BSD
@
text
@@


1.1
log
@Initial revision
@
text
@d44 1
a44 2
#include <asm.h>
#include <regdef.h>
d55 1
a55 1
	lda	sp,-40(sp)
d62 2
a63 2
	.mask	0x0400f000,-40
	.frame	fp,40,ra
d78 1
a78 1
	mov	-4096,AT
d108 1
a108 1
	ldq	$aj,($aj)
d110 1
a110 1
	ldq	$nj,($nj)
d161 1
a161 1
	ldq	$hi0,($ap)
d163 2
a164 2
	ldq	$bi,($bi)
	ldq	$hi1,($np)
d166 1
a166 1
	ldq	$tj,(sp)
d197 1
a197 1
	ldq	$aj,($aj)	#L1
d200 1
a200 1
	ldq	$nj,($nj)	#L0
d249 1
a249 1
	stq	$j,($tp)
d267 2
a268 2
.Lsub:	ldq	$lo0,($tp)
	ldq	$lo1,($np)
d276 1
a276 1
	stq	$lo0,($rp)
d290 1
a290 1
.Lcopy:	ldq	$aj,($ap)	# copy or in-place refresh
d308 1
a308 1
	lda	sp,40(sp)
d311 2
a312 2
.rdata
.asciiz	"Montgomery Multiplication for Alpha, CRYPTOGAMS by <appro\@@openssl.org>"
@


1.1.1.1
log
@import of OpenSSL 0.9.8k
@
text
@@


1.1.1.2
log
@import OpenSSL-1.0.0a
@
text
@d56 1
a56 1
	lda	sp,-48(sp)
d63 2
a64 2
	.mask	0x0400f000,-48
	.frame	fp,48,ra
d309 1
a309 1
	lda	sp,48(sp)
@


1.1.1.3
log
@import OpenSSL 1.0.0e
@
text
@a43 3
#ifdef __linux__
#include <asm/regdef.h>
#else
a45 1
#endif
d79 1
a79 1
	lda	AT,-4096(zero)	# mov	-4096,AT
d109 1
a109 1
	ldq	$aj,0($aj)
d111 1
a111 1
	ldq	$nj,0($nj)
d162 1
a162 1
	ldq	$hi0,0($ap)
d164 2
a165 2
	ldq	$bi,0($bi)
	ldq	$hi1,0($np)
d167 1
a167 1
	ldq	$tj,0(sp)
d198 1
a198 1
	ldq	$aj,0($aj)	#L1
d201 1
a201 1
	ldq	$nj,0($nj)	#L0
d250 1
a250 1
	stq	$j,0($tp)
d268 2
a269 2
.Lsub:	ldq	$lo0,0($tp)
	ldq	$lo1,0($np)
d277 1
a277 1
	stq	$lo0,0($rp)
d291 1
a291 1
.Lcopy:	ldq	$aj,0($ap)	# copy or in-place refresh
d312 2
a313 2
.ascii	"Montgomery Multiplication for Alpha, CRYPTOGAMS by <appro\@@openssl.org>"
.align	2
@


