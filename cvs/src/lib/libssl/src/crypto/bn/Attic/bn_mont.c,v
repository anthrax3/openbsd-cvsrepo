head	1.25;
access;
symbols
	OPENBSD_6_0:1.24.0.8
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.4
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	butholakala:1.14
	openssl_1_0_1_g:1.1.1.8
	OPENBSD_5_5:1.14.0.8
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	openssl_1_0_1_c:1.1.1.8
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	openssl_1_0_0_f:1.1.1.7
	openssl_1_0_0_e:1.1.1.7
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	openssh_1_0_0_a:1.1.1.6
	OPENBSD_4_8:1.11.0.8
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.4
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	openssl_0_9_8_k:1.1.1.5
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	openssl_0_9_8_j:1.1.1.5
	openssl_0_9_8_h:1.1.1.5
	pre_openssl_0_9_8h:1.10
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	openssl_0_9_7j:1.1.1.4
	openssl:1.1.1
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENSSL_0_9_7G:1.1.1.3
	OPENBSD_3_7:1.7.0.12
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.10
	OPENBSD_3_6_BASE:1.7
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.5.0.6
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2016.09.03.11.33.35;	author beck;	state dead;
branches;
next	1.24;
commitid	HnbXxsegngek41U2;

1.24
date	2015.02.09.15.49.22;	author jsing;	state Exp;
branches;
next	1.23;
commitid	69Tc75PIK8JcRRsC;

1.23
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.22;
commitid	yQEL1wOWIearrW15;

1.22
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.21;
commitid	id8dTrTMtnTn4fqt;

1.21
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	mJUVYpkFBZ0Zv2bG;

1.20
date	2014.06.07.14.41.56;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	2nvnQBrv22dLtvTt;

1.19
date	2014.05.08.13.20.49;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.23.19.17.48;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.19.13.31.24;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.14.14.50.09;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.06.12.17.49;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2007.08.21.21.03.46;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.27.05.07.01;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.29.05.39.19;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.07.03.45.33;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.57.21;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.33;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.09.18;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.44;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.58;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.05.37.05;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.06.27.05.05.31;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.04;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2011.11.03.02.32.09;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2012.10.13.21.23.37;	author djm;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Remove the libssl/src directory
@
text
@/* $OpenBSD: bn_mont.c,v 1.24 2015/02/09 15:49:22 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

/*
 * Details about Montgomery multiplication algorithms can be found at
 * http://security.ece.orst.edu/publications.html, e.g.
 * http://security.ece.orst.edu/koc/papers/j37acmon.pdf and
 * sections 3.8 and 4.2 in http://security.ece.orst.edu/koc/papers/r01rsasw.pdf
 */

#include <stdio.h>
#include <stdint.h>

#include "bn_lcl.h"

#define MONT_WORD /* use the faster word-based algorithm */

#ifdef MONT_WORD
static int BN_from_montgomery_word(BIGNUM *ret, BIGNUM *r, BN_MONT_CTX *mont);
#endif

int
BN_mod_mul_montgomery(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
    BN_MONT_CTX *mont, BN_CTX *ctx)
{
	BIGNUM *tmp;
	int ret = 0;
#if defined(OPENSSL_BN_ASM_MONT) && defined(MONT_WORD)
	int num = mont->N.top;

	if (num > 1 && a->top == num && b->top == num) {
		if (bn_wexpand(r, num) == NULL)
			return (0);
		if (bn_mul_mont(r->d, a->d, b->d, mont->N.d, mont->n0, num)) {
			r->neg = a->neg^b->neg;
			r->top = num;
			bn_correct_top(r);
			return (1);
		}
	}
#endif

	BN_CTX_start(ctx);
	if ((tmp = BN_CTX_get(ctx)) == NULL)
		goto err;

	bn_check_top(tmp);
	if (a == b) {
		if (!BN_sqr(tmp, a, ctx))
			goto err;
	} else {
		if (!BN_mul(tmp, a,b, ctx))
			goto err;
	}
	/* reduce from aRR to aR */
#ifdef MONT_WORD
	if (!BN_from_montgomery_word(r, tmp, mont))
		goto err;
#else
	if (!BN_from_montgomery(r, tmp, mont, ctx))
		goto err;
#endif
	bn_check_top(r);
	ret = 1;
err:
	BN_CTX_end(ctx);
	return (ret);
}

#ifdef MONT_WORD
static int
BN_from_montgomery_word(BIGNUM *ret, BIGNUM *r, BN_MONT_CTX *mont)
{
	BIGNUM *n;
	BN_ULONG *ap, *np, *rp, n0, v, carry;
	int nl, max, i;

	n = &(mont->N);
	nl = n->top;
	if (nl == 0) {
		ret->top = 0;
		return (1);
	}

	max = (2 * nl); /* carry is stored separately */
	if (bn_wexpand(r, max) == NULL)
		return (0);

	r->neg ^= n->neg;
	np = n->d;
	rp = r->d;

	/* clear the top words of T */
#if 1
	for (i=r->top; i<max; i++) /* memset? XXX */
		rp[i] = 0;
#else
	memset(&(rp[r->top]), 0, (max - r->top) * sizeof(BN_ULONG));
#endif

	r->top = max;
	n0 = mont->n0[0];

#ifdef BN_COUNT
	fprintf(stderr, "word BN_from_montgomery_word %d * %d\n", nl, nl);
#endif
	for (carry = 0, i = 0; i < nl; i++, rp++) {
		v = bn_mul_add_words(rp, np, nl, (rp[0] * n0) & BN_MASK2);
		v = (v + carry + rp[nl]) & BN_MASK2;
		carry |= (v != rp[nl]);
		carry &= (v <= rp[nl]);
		rp[nl] = v;
	}

	if (bn_wexpand(ret, nl) == NULL)
		return (0);
	ret->top = nl;
	ret->neg = r->neg;

	rp = ret->d;
	ap = &(r->d[nl]);

#define BRANCH_FREE 1
#if BRANCH_FREE
	{
		BN_ULONG *nrp;
		size_t m;

		v = bn_sub_words(rp, ap, np, nl) - carry;
		/* if subtraction result is real, then
		 * trick unconditional memcpy below to perform in-place
		 * "refresh" instead of actual copy. */
		m = (0 - (size_t)v);
		nrp = (BN_ULONG *)(((uintptr_t)rp & ~m)|((uintptr_t)ap & m));

		for (i = 0, nl -= 4; i < nl; i += 4) {
			BN_ULONG t1, t2, t3, t4;

			t1 = nrp[i + 0];
			t2 = nrp[i + 1];
			t3 = nrp[i + 2];
			ap[i + 0] = 0;
			t4 = nrp[i + 3];
			ap[i + 1] = 0;
			rp[i + 0] = t1;
			ap[i + 2] = 0;
			rp[i + 1] = t2;
			ap[i + 3] = 0;
			rp[i + 2] = t3;
			rp[i + 3] = t4;
		}
		for (nl += 4; i < nl; i++)
			rp[i] = nrp[i], ap[i] = 0;
	}
#else
	if (bn_sub_words (rp, ap, np, nl) - carry)
		memcpy(rp, ap, nl*sizeof(BN_ULONG));
#endif
	bn_correct_top(r);
	bn_correct_top(ret);
	bn_check_top(ret);

	return (1);
}
#endif	/* MONT_WORD */

int
BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont, BN_CTX *ctx)
{
	int retn = 0;
#ifdef MONT_WORD
	BIGNUM *t;

	BN_CTX_start(ctx);
	if ((t = BN_CTX_get(ctx)) && BN_copy(t, a))
		retn = BN_from_montgomery_word(ret, t, mont);
	BN_CTX_end(ctx);
#else /* !MONT_WORD */
	BIGNUM *t1, *t2;

	BN_CTX_start(ctx);
	if ((t1 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((t2 = BN_CTX_get(ctx)) == NULL)
		goto err;

	if (!BN_copy(t1, a))
		goto err;
	BN_mask_bits(t1, mont->ri);

	if (!BN_mul(t2, t1, &mont->Ni, ctx))
		goto err;
	BN_mask_bits(t2, mont->ri);

	if (!BN_mul(t1, t2, &mont->N, ctx))
		goto err;
	if (!BN_add(t2, a, t1))
		goto err;
	if (!BN_rshift(ret, t2, mont->ri))
		goto err;

	if (BN_ucmp(ret, &(mont->N)) >= 0) {
		if (!BN_usub(ret, ret, &(mont->N)))
			goto err;
	}
	retn = 1;
	bn_check_top(ret);

err:
	BN_CTX_end(ctx);
#endif /* MONT_WORD */
	return (retn);
}

BN_MONT_CTX *
BN_MONT_CTX_new(void)
{
	BN_MONT_CTX *ret;

	if ((ret = malloc(sizeof(BN_MONT_CTX))) == NULL)
		return (NULL);

	BN_MONT_CTX_init(ret);
	ret->flags = BN_FLG_MALLOCED;
	return (ret);
}

void
BN_MONT_CTX_init(BN_MONT_CTX *ctx)
{
	ctx->ri = 0;
	BN_init(&(ctx->RR));
	BN_init(&(ctx->N));
	BN_init(&(ctx->Ni));
	ctx->n0[0] = ctx->n0[1] = 0;
	ctx->flags = 0;
}

void
BN_MONT_CTX_free(BN_MONT_CTX *mont)
{
	if (mont == NULL)
		return;

	BN_clear_free(&(mont->RR));
	BN_clear_free(&(mont->N));
	BN_clear_free(&(mont->Ni));
	if (mont->flags & BN_FLG_MALLOCED)
		free(mont);
}

int
BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx)
{
	int ret = 0;
	BIGNUM *Ri, *R;

	BN_CTX_start(ctx);
	if ((Ri = BN_CTX_get(ctx)) == NULL)
		goto err;
	R = &(mont->RR);				/* grab RR as a temp */
	if (!BN_copy(&(mont->N), mod))
		 goto err;				/* Set N */
	mont->N.neg = 0;

#ifdef MONT_WORD
	{
		BIGNUM tmod;
		BN_ULONG buf[2];

		BN_init(&tmod);
		tmod.d = buf;
		tmod.dmax = 2;
		tmod.neg = 0;

		mont->ri = (BN_num_bits(mod) +
		    (BN_BITS2 - 1)) / BN_BITS2 * BN_BITS2;

#if defined(OPENSSL_BN_ASM_MONT) && (BN_BITS2<=32)
		/* Only certain BN_BITS2<=32 platforms actually make use of
		 * n0[1], and we could use the #else case (with a shorter R
		 * value) for the others.  However, currently only the assembler
		 * files do know which is which. */

		BN_zero(R);
		if (!(BN_set_bit(R, 2 * BN_BITS2)))
			goto err;

		tmod.top = 0;
		if ((buf[0] = mod->d[0]))
			tmod.top = 1;
		if ((buf[1] = mod->top > 1 ? mod->d[1] : 0))
			tmod.top = 2;

		if ((BN_mod_inverse(Ri, R, &tmod, ctx)) == NULL)
			goto err;
		if (!BN_lshift(Ri, Ri, 2 * BN_BITS2))
			goto err; /* R*Ri */
		if (!BN_is_zero(Ri)) {
			if (!BN_sub_word(Ri, 1))
				goto err;
		}
		else /* if N mod word size == 1 */
		{
			if (bn_expand(Ri, (int)sizeof(BN_ULONG) * 2) == NULL)
				goto err;
			/* Ri-- (mod double word size) */
			Ri->neg = 0;
			Ri->d[0] = BN_MASK2;
			Ri->d[1] = BN_MASK2;
			Ri->top = 2;
		}
		if (!BN_div(Ri, NULL, Ri, &tmod, ctx))
			goto err;
		/* Ni = (R*Ri-1)/N,
		 * keep only couple of least significant words: */
		mont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0;
		mont->n0[1] = (Ri->top > 1) ? Ri->d[1] : 0;
#else
		BN_zero(R);
		if (!(BN_set_bit(R, BN_BITS2)))
			goto err;	/* R */

		buf[0] = mod->d[0]; /* tmod = N mod word size */
		buf[1] = 0;
		tmod.top = buf[0] != 0 ? 1 : 0;
		/* Ri = R^-1 mod N*/
		if ((BN_mod_inverse(Ri, R, &tmod, ctx)) == NULL)
			goto err;
		if (!BN_lshift(Ri, Ri, BN_BITS2))
			goto err; /* R*Ri */
		if (!BN_is_zero(Ri)) {
			if (!BN_sub_word(Ri, 1))
				goto err;
		}
		else /* if N mod word size == 1 */
		{
			if (!BN_set_word(Ri, BN_MASK2))
				goto err;  /* Ri-- (mod word size) */
		}
		if (!BN_div(Ri, NULL, Ri, &tmod, ctx))
			goto err;
		/* Ni = (R*Ri-1)/N,
		 * keep only least significant word: */
		mont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0;
		mont->n0[1] = 0;
#endif
	}
#else /* !MONT_WORD */
	{ /* bignum version */
		mont->ri = BN_num_bits(&mont->N);
		BN_zero(R);
		if (!BN_set_bit(R, mont->ri))
			goto err;  /* R = 2^ri */
		/* Ri = R^-1 mod N*/
		if ((BN_mod_inverse(Ri, R, &mont->N, ctx)) == NULL)
			goto err;
		if (!BN_lshift(Ri, Ri, mont->ri))
			goto err; /* R*Ri */
		if (!BN_sub_word(Ri, 1))
			goto err;
		/* Ni = (R*Ri-1) / N */
		if (!BN_div(&(mont->Ni), NULL, Ri, &mont->N, ctx))
			goto err;
	}
#endif

	/* setup RR for conversions */
	BN_zero(&(mont->RR));
	if (!BN_set_bit(&(mont->RR), mont->ri*2))
		goto err;
	if (!BN_mod(&(mont->RR), &(mont->RR), &(mont->N), ctx))
		goto err;

	ret = 1;

err:
	BN_CTX_end(ctx);
	return ret;
}

BN_MONT_CTX *
BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from)
{
	if (to == from)
		return (to);

	if (!BN_copy(&(to->RR), &(from->RR)))
		return NULL;
	if (!BN_copy(&(to->N), &(from->N)))
		return NULL;
	if (!BN_copy(&(to->Ni), &(from->Ni)))
		return NULL;
	to->ri = from->ri;
	to->n0[0] = from->n0[0];
	to->n0[1] = from->n0[1];
	return (to);
}

BN_MONT_CTX *
BN_MONT_CTX_set_locked(BN_MONT_CTX **pmont, int lock, const BIGNUM *mod,
    BN_CTX *ctx)
{
	int got_write_lock = 0;
	BN_MONT_CTX *ret;

	CRYPTO_r_lock(lock);
	if (!*pmont) {
		CRYPTO_r_unlock(lock);
		CRYPTO_w_lock(lock);
		got_write_lock = 1;

		if (!*pmont) {
			ret = BN_MONT_CTX_new();
			if (ret && !BN_MONT_CTX_set(ret, mod, ctx))
				BN_MONT_CTX_free(ret);
			else
				*pmont = ret;
		}
	}

	ret = *pmont;

	if (got_write_lock)
		CRYPTO_w_unlock(lock);
	else
		CRYPTO_r_unlock(lock);

	return ret;
}
@


1.24
log
@BN_CTX_get() can fail - consistently check its return value.

There are currently cases where the return from each call is checked,
the return from only the last call is checked and cases where it is not
checked at all (including code in bn, ec and engine).

Checking the last return value is valid as once the function fails it will
continue to return NULL. However, in order to be consistent check each
call with the same idiom. This makes it easy to verify.

Note there are still a handful of cases that do not follow the idiom -
these will be handled separately.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_mont.c,v 1.23 2014/07/11 08:44:48 jsing Exp $ */
@


1.23
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_mont.c,v 1.22 2014/07/10 13:58:22 jsing Exp $ */
d152 1
a152 2
	tmp = BN_CTX_get(ctx);
	if (tmp == NULL)
d290 3
a292 3
	t1 = BN_CTX_get(ctx);
	t2 = BN_CTX_get(ctx);
	if (t1 == NULL || t2 == NULL)
@


1.22
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_mont.c,v 1.21 2014/06/12 15:49:28 deraadt Exp $ */
a121 1
#include "cryptlib.h"
@


1.21
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d120 2
@


1.20
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* crypto/bn/bn_mont.c */
@


1.19
log
@Emergency knfectomie requested by tedu@@.
@
text
@d328 1
a328 1
	if ((ret = (BN_MONT_CTX *)malloc(sizeof(BN_MONT_CTX))) == NULL)
@


1.18
log
@When I grow up, I want to write workaround for long long multiplications
under __TANDEM systems and compilers, using hardcoded octal numbers. NOT.
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d129 4
a132 3
int BN_mod_mul_montgomery(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
			  BN_MONT_CTX *mont, BN_CTX *ctx)
	{
d134 1
a134 1
	int ret=0;
d138 4
a141 5
	if (num>1 && a->top==num && b->top==num)
		{
		if (bn_wexpand(r,num) == NULL) return(0);
		if (bn_mul_mont(r->d,a->d,b->d,mont->N.d,mont->n0,num))
			{
d145 1
a145 2
			return(1);
			}
d147 1
d152 2
a153 1
	if (tmp == NULL) goto err;
d156 7
a162 8
	if (a == b)
		{
		if (!BN_sqr(tmp,a,ctx)) goto err;
		}
	else
		{
		if (!BN_mul(tmp,a,b,ctx)) goto err;
		}
d165 2
a166 1
	if (!BN_from_montgomery_word(r,tmp,mont)) goto err;
d168 2
a169 1
	if (!BN_from_montgomery(r,tmp,mont,ctx)) goto err;
d172 1
a172 1
	ret=1;
d175 2
a176 2
	return(ret);
	}
d179 3
a181 2
static int BN_from_montgomery_word(BIGNUM *ret, BIGNUM *r, BN_MONT_CTX *mont)
	{
d183 2
a184 2
	BN_ULONG *ap,*np,*rp,n0,v,carry;
	int nl,max,i;
d186 14
a199 10
	n= &(mont->N);
	nl=n->top;
	if (nl == 0) { ret->top=0; return(1); }

	max=(2*nl); /* carry is stored separately */
	if (bn_wexpand(r,max) == NULL) return(0);

	r->neg^=n->neg;
	np=n->d;
	rp=r->d;
d204 1
a204 1
		rp[i]=0;
d206 1
a206 1
	memset(&(rp[r->top]),0,(max-r->top)*sizeof(BN_ULONG)); 
d209 2
a210 2
	r->top=max;
	n0=mont->n0[0];
d213 1
a213 1
	fprintf(stderr,"word BN_from_montgomery_word %d * %d\n",nl,nl);
d215 3
a217 4
	for (carry=0, i=0; i<nl; i++, rp++)
		{
		v=bn_mul_add_words(rp,np,nl,(rp[0]*n0)&BN_MASK2);
		v = (v+carry+rp[nl])&BN_MASK2;
d220 2
a221 2
		rp[nl]=v;
		}
d223 4
a226 3
	if (bn_wexpand(ret,nl) == NULL) return(0);
	ret->top=nl;
	ret->neg=r->neg;
d228 2
a229 2
	rp=ret->d;
	ap=&(r->d[nl]);
d234 2
a235 2
	BN_ULONG *nrp;
	size_t m;
d237 22
a258 19
	v=bn_sub_words(rp,ap,np,nl)-carry;
	/* if subtraction result is real, then
	 * trick unconditional memcpy below to perform in-place
	 * "refresh" instead of actual copy. */
	m=(0-(size_t)v);
	nrp=(BN_ULONG *)(((uintptr_t)rp&~m)|((uintptr_t)ap&m));

	for (i=0,nl-=4; i<nl; i+=4)
		{
		BN_ULONG t1,t2,t3,t4;
		
		t1=nrp[i+0];
		t2=nrp[i+1];
		t3=nrp[i+2];	ap[i+0]=0;
		t4=nrp[i+3];	ap[i+1]=0;
		rp[i+0]=t1;	ap[i+2]=0;
		rp[i+1]=t2;	ap[i+3]=0;
		rp[i+2]=t3;
		rp[i+3]=t4;
d260 2
a261 2
	for (nl+=4; i<nl; i++)
		rp[i]=nrp[i], ap[i]=0;
d264 2
a265 2
	if (bn_sub_words (rp,ap,np,nl)-carry)
		memcpy(rp,ap,nl*sizeof(BN_ULONG));
d271 2
a272 2
	return(1);
	}
d275 4
a278 4
int BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,
	     BN_CTX *ctx)
	{
	int retn=0;
d283 2
a284 2
	if ((t = BN_CTX_get(ctx)) && BN_copy(t,a))
		retn = BN_from_montgomery_word(ret,t,mont);
d287 1
a287 1
	BIGNUM *t1,*t2;
d292 17
a308 11
	if (t1 == NULL || t2 == NULL) goto err;
	
	if (!BN_copy(t1,a)) goto err;
	BN_mask_bits(t1,mont->ri);

	if (!BN_mul(t2,t1,&mont->Ni,ctx)) goto err;
	BN_mask_bits(t2,mont->ri);

	if (!BN_mul(t1,t2,&mont->N,ctx)) goto err;
	if (!BN_add(t2,a,t1)) goto err;
	if (!BN_rshift(ret,t2,mont->ri)) goto err;
d310 5
a314 5
	if (BN_ucmp(ret, &(mont->N)) >= 0)
		{
		if (!BN_usub(ret,ret,&(mont->N))) goto err;
		}
	retn=1;
d316 2
a317 1
 err:
d320 2
a321 2
	return(retn);
	}
d323 3
a325 2
BN_MONT_CTX *BN_MONT_CTX_new(void)
	{
d328 2
a329 2
	if ((ret=(BN_MONT_CTX *)malloc(sizeof(BN_MONT_CTX))) == NULL)
		return(NULL);
d332 8
a339 7
	ret->flags=BN_FLG_MALLOCED;
	return(ret);
	}

void BN_MONT_CTX_init(BN_MONT_CTX *ctx)
	{
	ctx->ri=0;
d344 2
a345 2
	ctx->flags=0;
	}
d347 5
a351 4
void BN_MONT_CTX_free(BN_MONT_CTX *mont)
	{
	if(mont == NULL)
	    return;
d358 1
a358 1
	}
d360 3
a362 2
int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx)
	{
d364 1
a364 1
	BIGNUM *Ri,*R;
d367 5
a371 3
	if((Ri = BN_CTX_get(ctx)) == NULL) goto err;
	R= &(mont->RR);					/* grab RR as a temp */
	if (!BN_copy(&(mont->N),mod)) goto err;		/* Set N */
d375 1
a375 1
		{
d380 3
a382 3
		tmod.d=buf;
		tmod.dmax=2;
		tmod.neg=0;
d384 2
a385 1
		mont->ri=(BN_num_bits(mod)+(BN_BITS2-1))/BN_BITS2*BN_BITS2;
d394 2
a395 1
		if (!(BN_set_bit(R,2*BN_BITS2))) goto err;
d397 14
a410 11
								tmod.top=0;
		if ((buf[0] = mod->d[0]))			tmod.top=1;
		if ((buf[1] = mod->top>1 ? mod->d[1] : 0))	tmod.top=2;

		if ((BN_mod_inverse(Ri,R,&tmod,ctx)) == NULL)
			goto err;
		if (!BN_lshift(Ri,Ri,2*BN_BITS2)) goto err; /* R*Ri */
		if (!BN_is_zero(Ri))
			{
			if (!BN_sub_word(Ri,1)) goto err;
			}
d412 2
a413 2
			{
			if (bn_expand(Ri,(int)sizeof(BN_ULONG)*2) == NULL)
d416 7
a422 6
			Ri->neg=0;
			Ri->d[0]=BN_MASK2;
			Ri->d[1]=BN_MASK2;
			Ri->top=2;
			}
		if (!BN_div(Ri,NULL,Ri,&tmod,ctx)) goto err;
d429 2
a430 1
		if (!(BN_set_bit(R,BN_BITS2))) goto err;	/* R */
d432 2
a433 2
		buf[0]=mod->d[0]; /* tmod = N mod word size */
		buf[1]=0;
d435 2
a436 2
							/* Ri = R^-1 mod N*/
		if ((BN_mod_inverse(Ri,R,&tmod,ctx)) == NULL)
d438 6
a443 5
		if (!BN_lshift(Ri,Ri,BN_BITS2)) goto err; /* R*Ri */
		if (!BN_is_zero(Ri))
			{
			if (!BN_sub_word(Ri,1)) goto err;
			}
d445 6
a450 4
			{
			if (!BN_set_word(Ri,BN_MASK2)) goto err;  /* Ri-- (mod word size) */
			}
		if (!BN_div(Ri,NULL,Ri,&tmod,ctx)) goto err;
d456 1
a456 1
		}
d458 2
a459 2
		{ /* bignum version */
		mont->ri=BN_num_bits(&mont->N);
d461 13
a473 9
		if (!BN_set_bit(R,mont->ri)) goto err;  /* R = 2^ri */
		                                        /* Ri = R^-1 mod N*/
		if ((BN_mod_inverse(Ri,R,&mont->N,ctx)) == NULL)
			goto err;
		if (!BN_lshift(Ri,Ri,mont->ri)) goto err; /* R*Ri */
		if (!BN_sub_word(Ri,1)) goto err;
							/* Ni = (R*Ri-1) / N */
		if (!BN_div(&(mont->Ni),NULL,Ri,&mont->N,ctx)) goto err;
		}
d478 4
a481 2
	if (!BN_set_bit(&(mont->RR),mont->ri*2)) goto err;
	if (!BN_mod(&(mont->RR),&(mont->RR),&(mont->N),ctx)) goto err;
d484 1
d488 1
a488 14
	}

BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from)
	{
	if (to == from) return(to);

	if (!BN_copy(&(to->RR),&(from->RR))) return NULL;
	if (!BN_copy(&(to->N),&(from->N))) return NULL;
	if (!BN_copy(&(to->Ni),&(from->Ni))) return NULL;
	to->ri=from->ri;
	to->n0[0]=from->n0[0];
	to->n0[1]=from->n0[1];
	return(to);
	}
d490 22
a511 3
BN_MONT_CTX *BN_MONT_CTX_set_locked(BN_MONT_CTX **pmont, int lock,
					const BIGNUM *mod, BN_CTX *ctx)
	{
d516 1
a516 2
	if (!*pmont)
		{
d521 1
a521 2
		if (!*pmont)
			{
a526 1
			}
d528 2
a529 1
	
d531 1
a531 1
	
d536 1
a536 1
		
d538 1
a538 1
	}
@


1.17
log
@Lacking a proof that--for this implementation--exposure of Montgomery
multiplication or RSA blinding parameters doesn't permit retroactive
timing analysis of the secrets, we'll do the stupidly cheap thing and
cleanse them before freeing them.

ok deraadt@@
@
text
@a209 14
#ifdef __TANDEM
                {
                   long long t1;
                   long long t2;
                   long long t3;
                   t1 = rp[0] * (n0 & 0177777);
                   t2 = 037777600000l;
                   t2 = n0 & t2;
                   t3 = rp[0] & 0177777;
                   t2 = (t3 * t2) & BN_MASK2;
                   t1 = t1 + t2;
                   v=bn_mul_add_words(rp,np,nl,(BN_ULONG) t1);
                }
#else
a210 1
#endif
@


1.16
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d348 3
a350 3
	BN_free(&(mont->RR));
	BN_free(&(mont->N));
	BN_free(&(mont->Ni));
@


1.15
log
@replace PTR_SIZE_INT (only used for VMS) with uintptr_t, tweaks from jca@@,
makes sense to beck@@
@
text
@d325 1
a325 1
	if ((ret=(BN_MONT_CTX *)OPENSSL_malloc(sizeof(BN_MONT_CTX))) == NULL)
d352 1
a352 1
		OPENSSL_free(mont);
@


1.14
log
@resolve conflicts
@
text
@d250 1
a250 1
	nrp=(BN_ULONG *)(((PTR_SIZE_INT)rp&~m)|((PTR_SIZE_INT)ap&m));
@


1.13
log
@openssl-1.0.0e: resolve conflicts
@
text
@d180 2
a181 2
	BN_ULONG *ap,*np,*rp,n0,v,*nrp;
	int al,nl,max,i,x,ri;
a183 4
	/* mont->ri is the size of mont->N in bits (rounded up
	   to the word size) */
	al=ri=mont->ri/BN_BITS2;

d185 1
a185 1
	if ((al == 0) || (nl == 0)) { ret->top=0; return(1); }
d187 1
a187 1
	max=(nl+al+1); /* allow for overflow (no?) XXX */
a192 1
	nrp= &(r->d[nl]);
d197 1
a197 1
		r->d[i]=0;
d199 1
a199 1
	memset(&(r->d[r->top]),0,(max-r->top)*sizeof(BN_ULONG)); 
d208 1
a208 1
	for (i=0; i<nl; i++)
d226 4
a229 10
		nrp++;
		rp++;
		if (((nrp[-1]+=v)&BN_MASK2) >= v)
			continue;
		else
			{
			if (((++nrp[0])&BN_MASK2) != 0) continue;
			if (((++nrp[1])&BN_MASK2) != 0) continue;
			for (x=2; (((++nrp[x])&BN_MASK2) == 0); x++) ;
			}
a230 1
	bn_correct_top(r);
d232 2
a233 14
	/* mont->ri will be a multiple of the word size and below code
	 * is kind of BN_rshift(ret,r,mont->ri) equivalent */
	if (r->top <= ri)
		{
		ret->top=0;
		return(1);
		}
	al=r->top-ri;

#define BRANCH_FREE 1
#if BRANCH_FREE
	if (bn_wexpand(ret,ri) == NULL) return(0);
	x=0-(((al-ri)>>(sizeof(al)*8-1))&1);
	ret->top=x=(ri&~x)|(al&x);	/* min(ri,al) */
d237 1
a237 1
	ap=&(r->d[ri]);
d239 2
d242 2
a243 1
	size_t m1,m2;
d245 2
a246 7
	v=bn_sub_words(rp,ap,np,ri);
	/* this ----------------^^ works even in al<ri case
	 * thanks to zealous zeroing of top of the vector in the
	 * beginning. */

	/* if (al==ri && !v) || al>ri) nrp=rp; else nrp=ap; */
	/* in other words if subtraction result is real, then
d249 2
a250 7
	m1=0-(size_t)(((al-ri)>>(sizeof(al)*8-1))&1);	/* al<ri */
	m2=0-(size_t)(((ri-al)>>(sizeof(al)*8-1))&1);	/* al>ri */
	m1|=m2;			/* (al!=ri) */
	m1|=(0-(size_t)v);	/* (al!=ri || v) */
	m1&=~m2;		/* (al!=ri || v) && !al>ri */
	nrp=(BN_ULONG *)(((PTR_SIZE_INT)rp&~m1)|((PTR_SIZE_INT)ap&m1));
	}
d252 1
a252 3
	/* 'i<ri' is chosen to eliminate dependency on input data, even
	 * though it results in redundant copy in al<ri case. */
	for (i=0,ri-=4; i<ri; i+=4)
d265 1
a265 1
	for (ri+=4; i<ri; i++)
d267 5
a273 30
#else
	if (bn_wexpand(ret,al) == NULL) return(0);
	ret->top=al;
	ret->neg=r->neg;

	rp=ret->d;
	ap=&(r->d[ri]);
	al-=4;
	for (i=0; i<al; i+=4)
		{
		BN_ULONG t1,t2,t3,t4;
		
		t1=ap[i+0];
		t2=ap[i+1];
		t3=ap[i+2];
		t4=ap[i+3];
		rp[i+0]=t1;
		rp[i+1]=t2;
		rp[i+2]=t3;
		rp[i+3]=t4;
		}
	al+=4;
	for (; i<al; i++)
		rp[i]=ap[i];

	if (BN_ucmp(ret, &(mont->N)) >= 0)
		{
		if (!BN_usub(ret,ret,&(mont->N))) return(0);
		}
#endif
@


1.12
log
@resolve conflicts, fix local changes
@
text
@d280 1
a280 1
	nrp=(BN_ULONG *)(((size_t)rp&~m1)|((size_t)ap&m1));
@


1.11
log
@resolve conflicts
@
text
@d125 1
a125 15
#if defined(MONT_WORD) && defined(OPENSSL_BN_ASM_MONT) && (BN_BITS2<=32)
/* This condition means we have a specific non-default build:
 * In the 0.9.8 branch, OPENSSL_BN_ASM_MONT is normally not set for any
 * BN_BITS2<=32 platform; an explicit "enable-montasm" is required.
 * I.e., if we are here, the user intentionally deviates from the
 * normal stable build to get better Montgomery performance from
 * the 0.9.9-dev backport.
 *
 * In this case only, we also enable BN_from_montgomery_word()
 * (another non-stable feature from 0.9.9-dev).
 */
#define MONT_FROM_WORD___NON_DEFAULT_0_9_8_BUILD
#endif

#ifdef MONT_FROM_WORD___NON_DEFAULT_0_9_8_BUILD
a128 2


a139 1
#if 0 /* for OpenSSL 0.9.9 mont->n0 */
a140 3
#else
		if (bn_mul_mont(r->d,a->d,b->d,mont->N.d,&mont->n0,num))
#endif
d164 1
a164 1
#ifdef MONT_FROM_WORD___NON_DEFAULT_0_9_8_BUILD
d176 1
a176 1
#ifdef MONT_FROM_WORD___NON_DEFAULT_0_9_8_BUILD
d200 1
d203 3
a207 1
#if 0 /* for OpenSSL 0.9.9 mont->n0 */
a208 3
#else
	n0=mont->n0;
#endif
d253 2
a301 56
	bn_check_top(ret);

	return(1);
	}

int BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,
	     BN_CTX *ctx)
	{
	int retn=0;
	BIGNUM *t;

	BN_CTX_start(ctx);
	if ((t = BN_CTX_get(ctx)) && BN_copy(t,a))
		retn = BN_from_montgomery_word(ret,t,mont);
	BN_CTX_end(ctx);
	return retn;
	}

#else /* !MONT_FROM_WORD___NON_DEFAULT_0_9_8_BUILD */

int BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,
	     BN_CTX *ctx)
	{
	int retn=0;

#ifdef MONT_WORD
	BIGNUM *n,*r;
	BN_ULONG *ap,*np,*rp,n0,v,*nrp;
	int al,nl,max,i,x,ri;

	BN_CTX_start(ctx);
	if ((r = BN_CTX_get(ctx)) == NULL) goto err;

	if (!BN_copy(r,a)) goto err;
	n= &(mont->N);

	ap=a->d;
	/* mont->ri is the size of mont->N in bits (rounded up
	   to the word size) */
	al=ri=mont->ri/BN_BITS2;
	
	nl=n->top;
	if ((al == 0) || (nl == 0)) { r->top=0; return(1); }

	max=(nl+al+1); /* allow for overflow (no?) XXX */
	if (bn_wexpand(r,max) == NULL) goto err;

	r->neg=a->neg^n->neg;
	np=n->d;
	rp=r->d;
	nrp= &(r->d[nl]);

	/* clear the top words of T */
#if 1
	for (i=r->top; i<max; i++) /* memset? XXX */
		r->d[i]=0;
d303 1
a303 101
	memset(&(r->d[r->top]),0,(max-r->top)*sizeof(BN_ULONG)); 
#endif

	r->top=max;
	n0=mont->n0;

#ifdef BN_COUNT
	fprintf(stderr,"word BN_from_montgomery %d * %d\n",nl,nl);
#endif
	for (i=0; i<nl; i++)
		{
#ifdef __TANDEM
                {
                   long long t1;
                   long long t2;
                   long long t3;
                   t1 = rp[0] * (n0 & 0177777);
                   t2 = 037777600000l;
                   t2 = n0 & t2;
                   t3 = rp[0] & 0177777;
                   t2 = (t3 * t2) & BN_MASK2;
                   t1 = t1 + t2;
                   v=bn_mul_add_words(rp,np,nl,(BN_ULONG) t1);
                }
#else
		v=bn_mul_add_words(rp,np,nl,(rp[0]*n0)&BN_MASK2);
#endif
		nrp++;
		rp++;
		if (((nrp[-1]+=v)&BN_MASK2) >= v)
			continue;
		else
			{
			if (((++nrp[0])&BN_MASK2) != 0) continue;
			if (((++nrp[1])&BN_MASK2) != 0) continue;
			for (x=2; (((++nrp[x])&BN_MASK2) == 0); x++) ;
			}
		}
	bn_correct_top(r);
	
	/* mont->ri will be a multiple of the word size and below code
	 * is kind of BN_rshift(ret,r,mont->ri) equivalent */
	if (r->top <= ri)
		{
		ret->top=0;
		retn=1;
		goto err;
		}
	al=r->top-ri;

# define BRANCH_FREE 1
# if BRANCH_FREE
	if (bn_wexpand(ret,ri) == NULL) goto err;
	x=0-(((al-ri)>>(sizeof(al)*8-1))&1);
	ret->top=x=(ri&~x)|(al&x);	/* min(ri,al) */
	ret->neg=r->neg;

	rp=ret->d;
	ap=&(r->d[ri]);

	{
	size_t m1,m2;

	v=bn_sub_words(rp,ap,np,ri);
	/* this ----------------^^ works even in al<ri case
	 * thanks to zealous zeroing of top of the vector in the
	 * beginning. */

	/* if (al==ri && !v) || al>ri) nrp=rp; else nrp=ap; */
	/* in other words if subtraction result is real, then
	 * trick unconditional memcpy below to perform in-place
	 * "refresh" instead of actual copy. */
	m1=0-(size_t)(((al-ri)>>(sizeof(al)*8-1))&1);	/* al<ri */
	m2=0-(size_t)(((ri-al)>>(sizeof(al)*8-1))&1);	/* al>ri */
	m1|=m2;			/* (al!=ri) */
	m1|=(0-(size_t)v);	/* (al!=ri || v) */
	m1&=~m2;		/* (al!=ri || v) && !al>ri */
	nrp=(BN_ULONG *)(((size_t)rp&~m1)|((size_t)ap&m1));
	}

	/* 'i<ri' is chosen to eliminate dependency on input data, even
	 * though it results in redundant copy in al<ri case. */
	for (i=0,ri-=4; i<ri; i+=4)
		{
		BN_ULONG t1,t2,t3,t4;
		
		t1=nrp[i+0];
		t2=nrp[i+1];
		t3=nrp[i+2];	ap[i+0]=0;
		t4=nrp[i+3];	ap[i+1]=0;
		rp[i+0]=t1;	ap[i+2]=0;
		rp[i+1]=t2;	ap[i+3]=0;
		rp[i+2]=t3;
		rp[i+3]=t4;
		}
	for (ri+=4; i<ri; i++)
		rp[i]=nrp[i], ap[i]=0;
	bn_correct_top(r);
	bn_correct_top(ret);
# else
	if (bn_wexpand(ret,al) == NULL) goto err;
d326 24
a349 2
# endif
#else /* !MONT_WORD */ 
a365 1
#endif /* MONT_WORD */
a366 1
#if !defined(BRANCH_FREE) || BRANCH_FREE==0
a370 1
#endif
d375 1
a377 1
#endif /* MONT_FROM_WORD___NON_DEFAULT_0_9_8_BUILD */
a396 1
#if 0 /* for OpenSSL 0.9.9 mont->n0 */
a397 3
#else
	ctx->n0 = 0;
#endif
a428 12
		mont->ri=(BN_num_bits(mod)+(BN_BITS2-1))/BN_BITS2*BN_BITS2;
		BN_zero(R);
#if 0 /* for OpenSSL 0.9.9 mont->n0, would be "#if defined(OPENSSL_BN_ASM_MONT) && (BN_BITS2<=32)",
         only certain BN_BITS2<=32 platforms actually need this */
		if (!(BN_set_bit(R,2*BN_BITS2))) goto err;	/* R */
#else
		if (!(BN_set_bit(R,BN_BITS2))) goto err;	/* R */
#endif

		buf[0]=mod->d[0]; /* tmod = N mod word size */
		buf[1]=0;

a430 1
		tmod.top = buf[0] != 0 ? 1 : 0;
d434 11
a444 2
#if 0 /* for OpenSSL 0.9.9 mont->n0, would be "#if defined(OPENSSL_BN_ASM_MONT) && (BN_BITS2<=32)";
         only certain BN_BITS2<=32 platforms actually need this */
d472 6
a492 1
# if 0 /* for OpenSSL 0.9.9 mont->n0 */
a494 3
# else
		mont->n0 = (Ri->top > 0) ? Ri->d[0] : 0;
# endif
a530 1
#if 0 /* for OpenSSL 0.9.9 mont->n0 */
a532 3
#else
	to->n0=from->n0;
#endif
@


1.10
log
@http://openssl.org/news/patch-CVE-2007-3108.txt; ok pval, deraadt
@
text
@d58 53
d125 20
d150 19
d184 3
d188 2
d196 144
d415 1
a415 1
	bn_fix_top(r);
d474 2
d527 1
d532 1
d552 5
d574 2
a575 1
	BIGNUM Ri,*R;
d577 2
a578 1
	BN_init(&Ri);
d589 5
a593 1
		if (!(BN_zero(R))) goto err;
d595 1
d599 2
d602 1
a602 1
		tmod.top=1;
d605 30
d636 1
a636 1
		if ((BN_mod_inverse(&Ri,R,&tmod,ctx)) == NULL)
d638 2
a639 2
		if (!BN_lshift(&Ri,&Ri,BN_BITS2)) goto err; /* R*Ri */
		if (!BN_is_zero(&Ri))
d641 1
a641 1
			if (!BN_sub_word(&Ri,1)) goto err;
d645 1
a645 1
			if (!BN_set_word(&Ri,BN_MASK2)) goto err;  /* Ri-- (mod word size) */
d647 1
a647 1
		if (!BN_div(&Ri,NULL,&Ri,&tmod,ctx)) goto err;
d650 7
a656 2
		mont->n0 = (Ri.top > 0) ? Ri.d[0] : 0;
		BN_free(&Ri);
d661 1
a661 1
		if (!BN_zero(R)) goto err;
d664 1
a664 1
		if ((BN_mod_inverse(&Ri,R,&mont->N,ctx)) == NULL)
d666 2
a667 2
		if (!BN_lshift(&Ri,&Ri,mont->ri)) goto err; /* R*Ri */
		if (!BN_sub_word(&Ri,1)) goto err;
d669 1
a669 2
		if (!BN_div(&(mont->Ni),NULL,&Ri,&mont->N,ctx)) goto err;
		BN_free(&Ri);
d674 1
a674 1
	if (!BN_zero(&(mont->RR))) goto err;
d678 1
a678 1
	return(1);
d680 2
a681 1
	return(0);
d692 4
d697 1
d704 4
a707 3
	if (*pmont)
		return *pmont;
	CRYPTO_w_lock(lock);
d710 5
a714 2
		*pmont = BN_MONT_CTX_new();
		if (*pmont && !BN_MONT_CTX_set(*pmont, mod, ctx))
d716 5
a720 2
			BN_MONT_CTX_free(*pmont);
			*pmont = NULL;
d723 9
a731 2
	CRYPTO_w_unlock(lock);
	return *pmont;
a732 2
		

@


1.9
log
@resolve conflicts
@
text
@a124 1
	if (bn_wexpand(ret,max) == NULL) goto err;
d176 17
a192 6
	/* mont->ri will be a multiple of the word size */
#if 0
	BN_rshift(ret,r,mont->ri);
#else
	ret->neg = r->neg;
	x=ri;
d194 41
a234 5
	ap= &(r->d[x]);
	if (r->top < x)
		al=0;
	else
		al=r->top-x;
d236 4
d257 1
a257 1
#endif
d277 1
d282 1
@


1.8
log
@resolve conflicts
@
text
@d350 20
@


1.7
log
@Merge OpenSSL 0.9.7-stable-20020605,
correctly autogenerate obj_mac.h
@
text
@d276 1
a276 1
	BN_copy(&(mont->N),mod);			/* Set N */
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d224 1
a224 1
	BN_rshift(ret,t2,mont->ri);
d285 2
a286 2
		BN_zero(R);
		BN_set_bit(R,BN_BITS2);			/* R */
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d72 1
a72 1
int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b,
d75 1
a75 1
	BIGNUM *tmp,*tmp2;
d80 1
a80 2
	tmp2 = BN_CTX_get(ctx);
	if (tmp == NULL || tmp2 == NULL) goto err;
a82 2
	bn_check_top(tmp2);

d99 1
a99 1
int BN_from_montgomery(BIGNUM *ret, BIGNUM *a, BN_MONT_CTX *mont,
d144 1
a144 1
	printf("word BN_from_montgomery %d * %d\n",nl,nl);
d229 1
a229 1
		BN_usub(ret,ret,&(mont->N));
d277 1
d293 1
a293 1
		tmod.neg=mod->neg;
d297 1
a297 1
		BN_lshift(&Ri,&Ri,BN_BITS2);		/* R*Ri */
d299 3
a301 1
			BN_sub_word(&Ri,1);
d303 7
a309 4
			BN_set_word(&Ri,BN_MASK2);  /* Ri-- (mod word size) */
		BN_div(&Ri,NULL,&Ri,&tmod,ctx);	/* Ni = (R*Ri-1)/N,
		                                 * keep only least significant word: */
		mont->n0=Ri.d[0];
d314 5
a318 5
		mont->ri=BN_num_bits(mod);
		BN_zero(R);
		BN_set_bit(R,mont->ri);			/* R = 2^ri */
							/* Ri = R^-1 mod N*/
		if ((BN_mod_inverse(&Ri,R,mod,ctx)) == NULL)
d320 2
a321 2
		BN_lshift(&Ri,&Ri,mont->ri);		/* R*Ri */
		BN_sub_word(&Ri,1);
d323 1
a323 1
		BN_div(&(mont->Ni),NULL,&Ri,mod,ctx);
d329 3
a331 3
	BN_zero(&(mont->RR));
	BN_set_bit(&(mont->RR),mont->ri*2);
	BN_mod(&(mont->RR),&(mont->RR),&(mont->N),ctx);
d342 3
a344 3
	BN_copy(&(to->RR),&(from->RR));
	BN_copy(&(to->N),&(from->N));
	BN_copy(&(to->Ni),&(from->Ni));
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@a87 8
#if 0
		bn_wexpand(tmp,a->top*2);
		bn_wexpand(tmp2,a->top*4);
		bn_sqr_recursive(tmp->d,a->d,a->top,tmp2->d);
		tmp->top=a->top*2;
		if (tmp->d[tmp->top-1] == 0)
			tmp->top--;
#else
a88 1
#endif
d151 14
d166 1
d184 1
d244 1
a244 1
	if ((ret=(BN_MONT_CTX *)Malloc(sizeof(BN_MONT_CTX))) == NULL)
d270 1
a270 1
		Free(mont);
d294 1
a294 1
		tmod.max=2;
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d76 1
d105 2
d108 1
a108 3
	return(1);
err:
	return(0);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d60 4
a63 3
 * Details about Montgomery multiplication algorithms can be found at:
 * http://www.ece.orst.edu/ISL/Publications.html
 * http://www.ece.orst.edu/ISL/Koc/papers/j37acmon.pdf
d70 1
a70 1
#define MONT_WORD
d77 4
a80 3
        tmp= &(ctx->bn[ctx->tos]);
        tmp2= &(ctx->bn[ctx->tos]);
	ctx->tos+=2;
d104 1
a104 1
	ctx->tos-=2;
d113 1
a113 13
#ifdef BN_RECURSION_MONT
	if (mont->use_word)
#endif
		{
		BIGNUM *n,*r;
		BN_ULONG *ap,*np,*rp,n0,v,*nrp;
		int al,nl,max,i,x,ri;
		int retn=0;

		r= &(ctx->bn[ctx->tos]);

		if (!BN_copy(r,a)) goto err1;
		n= &(mont->N);
d115 27
a141 3
		ap=a->d;
		/* mont->ri is the size of mont->N in bits/words */
		al=ri=mont->ri/BN_BITS2;
d143 1
a143 13
		nl=n->top;
		if ((al == 0) || (nl == 0)) { r->top=0; return(1); }

		max=(nl+al+1); /* allow for overflow (no?) XXX */
		if (bn_wexpand(r,max) == NULL) goto err1;
		if (bn_wexpand(ret,max) == NULL) goto err1;

		r->neg=a->neg^n->neg;
		np=n->d;
		rp=r->d;
		nrp= &(r->d[nl]);

		/* clear the top words of T */
d145 2
a146 2
		for (i=r->top; i<max; i++) /* memset? XXX */
			r->d[i]=0;
d148 1
a148 1
		memset(&(r->d[r->top]),0,(max-r->top)*sizeof(BN_ULONG)); 
d151 2
a152 2
		r->top=max;
		n0=mont->n0;
d155 1
a155 1
printf("word BN_from_montgomery %d * %d\n",nl,nl);
d157 8
a164 1
		for (i=0; i<nl; i++)
d166 3
a168 11
			v=bn_mul_add_words(rp,np,nl,(rp[0]*n0)&BN_MASK2);
			nrp++;
			rp++;
			if (((nrp[-1]+=v)&BN_MASK2) >= v)
				continue;
			else
				{
				if (((++nrp[0])&BN_MASK2) != 0) continue;
				if (((++nrp[1])&BN_MASK2) != 0) continue;
				for (x=2; (((++nrp[x])&BN_MASK2) == 0); x++) ;
				}
d170 4
a173 3
		bn_fix_top(r);

		/* mont->ri will be a multiple of the word size */
d175 1
a175 1
		BN_rshift(ret,r,mont->ri);
d177 44
a220 26
		x=ri;
		rp=ret->d;
		ap= &(r->d[x]);
		if (r->top < x)
			al=0;
		else
			al=r->top-x;
		ret->top=al;
		al-=4;
		for (i=0; i<al; i+=4)
			{
			BN_ULONG t1,t2,t3,t4;

			t1=ap[i+0];
			t2=ap[i+1];
			t3=ap[i+2];
			t4=ap[i+3];
			rp[i+0]=t1;
			rp[i+1]=t2;
			rp[i+2]=t3;
			rp[i+3]=t4;
			}
		al+=4;
		for (; i<al; i++)
			rp[i]=ap[i];
#endif
d222 1
a222 10
		if (BN_ucmp(ret, &(mont->N)) >= 0)
			{
			BN_usub(ret,ret,&(mont->N)); /* XXX */
			}
		retn=1;
err1:
		return(retn);
		}
#ifdef BN_RECURSION_MONT
	else /* bignum version */ 
d224 1
a224 50
		BIGNUM *t1,*t2,*t3;
		int j,i;

#ifdef BN_COUNT
printf("number BN_from_montgomery\n");
#endif

		t1= &(ctx->bn[ctx->tos]);
		t2= &(ctx->bn[ctx->tos+1]);
		t3= &(ctx->bn[ctx->tos+2]);

		i=mont->Ni.top;
		bn_wexpand(ret,i); /* perhaps only i*2 */
		bn_wexpand(t1,i*4); /* perhaps only i*2 */
		bn_wexpand(t2,i*2); /* perhaps only i   */

		bn_mul_low_recursive(t2->d,a->d,mont->Ni.d,i,t1->d);

		BN_zero(t3);
		BN_set_bit(t3,mont->N.top*BN_BITS2);
		bn_sub_words(t3->d,t3->d,a->d,i);
		bn_mul_high(ret->d,t2->d,mont->N.d,t3->d,i,t1->d);

		/* hmm... if a is between i and 2*i, things are bad */
		if (a->top > i)
			{
			j=(int)(bn_add_words(ret->d,ret->d,&(a->d[i]),i));
			if (j) /* overflow */
				bn_sub_words(ret->d,ret->d,mont->N.d,i);
			}
		ret->top=i;
		bn_fix_top(ret);
		if (a->d[0])
			BN_add_word(ret,1); /* Always? */
		else	/* Very very rare */
			{
			for (i=1; i<mont->N.top-1; i++)
				{
				if (a->d[i])
					{
					BN_add_word(ret,1); /* Always? */
					break;
					}
				}
			}

		if (BN_ucmp(ret,&(mont->N)) >= 0)
			BN_usub(ret,ret,&(mont->N));

		return(1);
d226 4
a229 1
#endif
a245 1
	ctx->use_word=0;
d273 1
a273 3
#ifdef BN_RECURSION_MONT
	if (mont->N.top < BN_MONT_CTX_SET_SIZE_WORD)
#endif
a277 2
		mont->use_word=1;

d280 1
a280 5
		BN_set_bit(R,BN_BITS2);
		/* I was bad, this modification of a passed variable was
		 * breaking the multithreaded stuff :-(
		 * z=mod->top;
		 * mod->top=1; */
d282 1
a282 1
		buf[0]=mod->d[0];
d286 1
a286 1
		tmod.max=mod->max;
d288 1
a288 1

d291 1
a291 1
		BN_lshift(&Ri,&Ri,BN_BITS2);			/* R*Ri */
a292 2
			{
#if 1
d294 4
a297 13
#else
			BN_usub(&Ri,&Ri,BN_value_one());	/* R*Ri - 1 */
#endif
			}
		else
			{
			/* This is not common..., 1 in BN_MASK2,
			 * It happens when buf[0] was == 1.  So for 8 bit,
			 * this is 1/256, 16bit, 1 in 2^16 etc.
			 */
			BN_set_word(&Ri,BN_MASK2);
			}
		BN_div(&Ri,NULL,&Ri,&tmod,ctx);
a299 1
		/* mod->top=z; */
d301 3
a303 6
#ifdef BN_RECURSION_MONT
	else
		{
		mont->use_word=0;
		mont->ri=(BN_num_bits(mod)+(BN_BITS2-1))/BN_BITS2*BN_BITS2;
#if 1
d305 2
a306 4
		BN_set_bit(R,mont->ri);
#else
		BN_lshift(R,BN_value_one(),mont->ri);	/* R */
#endif
a309 1
#if 1
d311 1
a311 3
#else
		BN_usub(&Ri,&Ri,BN_value_one());	/* R*Ri - 1 */
#endif
a317 1
#if 1
a319 3
#else
	BN_lshift(mont->RR,BN_value_one(),mont->ri*2);
#endif
a333 1
	to->use_word=from->use_word;
@


1.1
log
@Initial revision
@
text
@d59 6
d69 4
a72 4
int BN_mod_mul_montgomery(r,a,b,mont,ctx)
BIGNUM *r,*a,*b;
BN_MONT_CTX *mont;
BN_CTX *ctx;
d74 1
a74 1
	BIGNUM *tmp;
d76 6
a81 1
        tmp=ctx->bn[ctx->tos++];
d85 8
d94 1
d98 1
a98 1
		if (!BN_mul(tmp,a,b)) goto err;
d102 1
a102 1
	ctx->tos--;
d108 27
a134 1
#define MONT_WORD
d136 4
a139 32
#ifdef MONT_WORD
int BN_from_montgomery(ret,a,mont,ctx)
BIGNUM *ret;
BIGNUM *a;
BN_MONT_CTX *mont;
BN_CTX *ctx;
	{
	BIGNUM *n,*t1,*r;
	BN_ULONG *ap,*np,*rp,n0,v;
	int al,nl,max,i,x,ri;
	int retn=0;

	t1=ctx->bn[ctx->tos];
	r=ctx->bn[ctx->tos+1];

	if (!BN_copy(r,a)) goto err;
	n=mont->N;

	ap=a->d;
	/* mont->ri is the size of mont->N in bits/words */
	al=ri=mont->ri/BN_BITS2;

	nl=n->top;
	if ((al == 0) || (nl == 0)) { r->top=0; return(1); }

	max=(nl+al+1); /* allow for overflow (no?) XXX */
	if (bn_wexpand(r,max) == NULL) goto err;
	if (bn_wexpand(ret,max) == NULL) goto err;

	r->neg=a->neg^n->neg;
	np=n->d;
	rp=r->d;
d141 1
a141 1
	/* clear the top words of T */
d143 2
a144 2
	for (i=r->top; i<max; i++) /* memset? XXX */
		r->d[i]=0;
d146 1
a146 1
	memset(&(r->d[r->top]),0,(max-r->top)*sizeof(BN_ULONG)); 
d149 2
a150 2
	r->top=max;
	n0=mont->n0;
d152 4
a155 6
	for (i=0; i<nl; i++)
		{
#if 0
		int x1,x2;

		if (i+4 > nl)
d157 11
a167 2
			x2=nl;
			x1=0;
d169 11
d181 4
d186 10
a195 2
			x2=i+4;
			x1=nl-x2;
d197 3
a199 3
		v=bn_mul_add_words(&(rp[x1]),&(np[x1]),x2,(rp[x1]*n0)&BN_MASK2);
#else
		v=bn_mul_add_words(rp,np,nl,(rp[0]*n0)&BN_MASK2);
d202 1
a202 1
		if (((rp[nl]+=v)&BN_MASK2) < v)
d204 1
a204 2
			for (x=(nl+1); (((++rp[x])&BN_MASK2) == 0); x++)
				;
d206 3
a208 1
		rp++;
d210 5
a214 2
	while (r->d[r->top-1] == 0)
		r->top--;
d216 2
a217 13
	/* mont->ri will be a multiple of the word size */
#if 0
	BN_rshift(ret,r,mont->ri);
#else
	ap=r->d;
	rp=ret->d;
	x=ri;
	al=r->top-x;
	for (i=0; i<al; i++)
		{
		rp[i]=ap[i+x];
		}
	ret->top=al;
d220 43
a262 3
	if (BN_ucmp(ret,mont->N) >= 0)
		{
		bn_qsub(ret,ret,mont->N); /* XXX */
d264 1
a264 3
	retn=1;
err:
	return(retn);
d266 2
a267 6
#else
int BN_from_montgomery(r,a,mont,ctx)
BIGNUM *r;
BIGNUM *a;
BN_MONT_CTX *mont;
BN_CTX *ctx;
d269 1
a269 1
	BIGNUM *t1,*t2;
d271 2
a272 2
	t1=ctx->bn[ctx->tos];
	t2=ctx->bn[ctx->tos+1];
d274 19
a292 3
	if (!BN_copy(t1,a)) goto err;
	/* can cheat */
	BN_mask_bits(t1,mont->ri);
d294 6
a299 2
	if (!BN_mul(t2,t1,mont->Ni)) goto err;
	BN_mask_bits(t2,mont->ri);
d301 3
a303 3
	if (!BN_mul(t1,t2,mont->N)) goto err;
	if (!BN_add(t2,a,t1)) goto err;
	BN_rshift(r,t2,mont->ri);
d305 3
a307 2
	if (BN_ucmp(r,mont->N) >= 0)
		bn_qsub(r,r,mont->N);
d309 2
a310 4
	return(1);
err:
	return(0);
	}
d312 3
d316 1
a316 3
BN_MONT_CTX *BN_MONT_CTX_new()
	{
	BN_MONT_CTX *ret;
d318 41
a358 7
	if ((ret=(BN_MONT_CTX *)Malloc(sizeof(BN_MONT_CTX))) == NULL)
		return(NULL);
	ret->ri=0;
	ret->RR=BN_new();
	ret->N=BN_new();
	ret->Ni=NULL;
	if ((ret->RR == NULL) || (ret->N == NULL))
d360 18
a377 2
		BN_MONT_CTX_free(ret);
		return(NULL);
a378 62
	return(ret);
	}

void BN_MONT_CTX_free(mont)
BN_MONT_CTX *mont;
	{
	if (mont->RR != NULL) BN_free(mont->RR);
	if (mont->N != NULL) BN_free(mont->N);
	if (mont->Ni != NULL) BN_free(mont->Ni);
	Free(mont);
	}

int BN_MONT_CTX_set(mont,mod,ctx)
BN_MONT_CTX *mont;
BIGNUM *mod;
BN_CTX *ctx;
	{
	BIGNUM *Ri=NULL,*R=NULL;

	if (mont->RR == NULL) mont->RR=BN_new();
	if (mont->N == NULL)  mont->N=BN_new();

	R=mont->RR;					/* grab RR as a temp */
	BN_copy(mont->N,mod);				/* Set N */

#ifdef MONT_WORD
{
	BIGNUM tmod;
	BN_ULONG buf[2];
	/* int z; */

	mont->ri=(BN_num_bits(mod)+(BN_BITS2-1))/BN_BITS2*BN_BITS2;
	BN_lshift(R,BN_value_one(),BN_BITS2);		/* R */
	/* I was bad, this modification of a passed variable was
	 * breaking the multithreaded stuff :-(
	 * z=mod->top;
	 * mod->top=1; */

	buf[0]=mod->d[0];
	buf[1]=0;
	tmod.d=buf;
	tmod.top=1;
	tmod.max=mod->max;
	tmod.neg=mod->neg;

	if ((Ri=BN_mod_inverse(R,&tmod,ctx)) == NULL) goto err; /* Ri */
	BN_lshift(Ri,Ri,BN_BITS2);			/* R*Ri */
	bn_qsub(Ri,Ri,BN_value_one());			/* R*Ri - 1 */
	BN_div(Ri,NULL,Ri,&tmod,ctx);
	mont->n0=Ri->d[0];
	BN_free(Ri);
	/* mod->top=z; */
}
#else
	mont->ri=BN_num_bits(mod);
	BN_lshift(R,BN_value_one(),mont->ri);			/* R */
	if ((Ri=BN_mod_inverse(R,mod,ctx)) == NULL) goto err;	/* Ri */
	BN_lshift(Ri,Ri,mont->ri);				/* R*Ri */
	bn_qsub(Ri,Ri,BN_value_one());				/* R*Ri - 1 */
	BN_div(Ri,NULL,Ri,mod,ctx);
	if (mont->Ni != NULL) BN_free(mont->Ni);
	mont->Ni=Ri;					/* Ni=(R*Ri-1)/N */
d382 4
d387 2
a388 1
	BN_mod(mont->RR,mont->RR,mont->N,ctx);
d393 13
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a58 7
/*
 * Details about Montgomery multiplication algorithms can be found at
 * http://security.ece.orst.edu/publications.html, e.g.
 * http://security.ece.orst.edu/koc/papers/j37acmon.pdf and
 * sections 3.8 and 4.2 in http://security.ece.orst.edu/koc/papers/r01rsasw.pdf
 */

d63 4
a66 4
#define MONT_WORD /* use the faster word-based algorithm */

int BN_mod_mul_montgomery(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
			  BN_MONT_CTX *mont, BN_CTX *ctx)
a68 1
	int ret=0;
d70 1
a70 3
	BN_CTX_start(ctx);
	tmp = BN_CTX_get(ctx);
	if (tmp == NULL) goto err;
a71 1
	bn_check_top(tmp);
d78 1
a78 1
		if (!BN_mul(tmp,a,b,ctx)) goto err;
d82 2
a83 1
	ret=1;
d85 1
a85 2
	BN_CTX_end(ctx);
	return(ret);
d88 1
a88 4
int BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,
	     BN_CTX *ctx)
	{
	int retn=0;
d91 8
a98 2
	BIGNUM *n,*r;
	BN_ULONG *ap,*np,*rp,n0,v,*nrp;
d100 1
d102 2
a103 2
	BN_CTX_start(ctx);
	if ((r = BN_CTX_get(ctx)) == NULL) goto err;
d106 1
a106 1
	n= &(mont->N);
d109 1
a109 2
	/* mont->ri is the size of mont->N in bits (rounded up
	   to the word size) */
d111 1
a111 1
	
a121 1
	nrp= &(r->d[nl]);
a133 3
#ifdef BN_COUNT
	fprintf(stderr,"word BN_from_montgomery %d * %d\n",nl,nl);
#endif
d136 14
a149 13
#ifdef __TANDEM
                {
                   long long t1;
                   long long t2;
                   long long t3;
                   t1 = rp[0] * (n0 & 0177777);
                   t2 = 037777600000l;
                   t2 = n0 & t2;
                   t3 = rp[0] & 0177777;
                   t2 = (t3 * t2) & BN_MASK2;
                   t1 = t1 + t2;
                   v=bn_mul_add_words(rp,np,nl,(BN_ULONG) t1);
                }
d153 2
a154 5
		nrp++;
		rp++;
		if (((nrp[-1]+=v)&BN_MASK2) >= v)
			continue;
		else
d156 2
a157 3
			if (((++nrp[0])&BN_MASK2) != 0) continue;
			if (((++nrp[1])&BN_MASK2) != 0) continue;
			for (x=2; (((++nrp[x])&BN_MASK2) == 0); x++) ;
d159 1
d161 3
a163 2
	bn_fix_top(r);
	
d168 2
a169 1
	ret->neg = r->neg;
d171 5
a175 6
	rp=ret->d;
	ap= &(r->d[x]);
	if (r->top < x)
		al=0;
	else
		al=r->top-x;
d177 3
a179 2
	al-=4;
	for (i=0; i<al; i+=4)
d181 1
a181 10
		BN_ULONG t1,t2,t3,t4;
		
		t1=ap[i+0];
		t2=ap[i+1];
		t3=ap[i+2];
		t4=ap[i+3];
		rp[i+0]=t1;
		rp[i+1]=t2;
		rp[i+2]=t3;
		rp[i+3]=t4;
d183 11
a193 5
	al+=4;
	for (; i<al; i++)
		rp[i]=ap[i];
#endif
#else /* !MONT_WORD */ 
d196 3
a198 5
	BN_CTX_start(ctx);
	t1 = BN_CTX_get(ctx);
	t2 = BN_CTX_get(ctx);
	if (t1 == NULL || t2 == NULL) goto err;
	
d200 1
d203 1
a203 1
	if (!BN_mul(t2,t1,&mont->Ni,ctx)) goto err;
d206 1
a206 1
	if (!BN_mul(t1,t2,&mont->N,ctx)) goto err;
d208 4
a211 2
	if (!BN_rshift(ret,t2,mont->ri)) goto err;
#endif /* MONT_WORD */
d213 3
a215 8
	if (BN_ucmp(ret, &(mont->N)) >= 0)
		{
		if (!BN_usub(ret,ret,&(mont->N))) goto err;
		}
	retn=1;
 err:
	BN_CTX_end(ctx);
	return(retn);
d217 1
d219 1
a219 1
BN_MONT_CTX *BN_MONT_CTX_new(void)
d223 1
a223 1
	if ((ret=(BN_MONT_CTX *)OPENSSL_malloc(sizeof(BN_MONT_CTX))) == NULL)
d225 9
a233 3

	BN_MONT_CTX_init(ret);
	ret->flags=BN_FLG_MALLOCED;
d237 2
a238 1
void BN_MONT_CTX_init(BN_MONT_CTX *ctx)
d240 4
a243 5
	ctx->ri=0;
	BN_init(&(ctx->RR));
	BN_init(&(ctx->N));
	BN_init(&(ctx->Ni));
	ctx->flags=0;
d246 4
a249 1
void BN_MONT_CTX_free(BN_MONT_CTX *mont)
d251 1
a251 2
	if(mont == NULL)
	    return;
d253 2
a254 10
	BN_free(&(mont->RR));
	BN_free(&(mont->N));
	BN_free(&(mont->Ni));
	if (mont->flags & BN_FLG_MALLOCED)
		OPENSSL_free(mont);
	}

int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx)
	{
	BIGNUM Ri,*R;
d256 2
a257 4
	BN_init(&Ri);
	R= &(mont->RR);					/* grab RR as a temp */
	BN_copy(&(mont->N),mod);			/* Set N */
	mont->N.neg = 0;
d260 36
a295 46
		{
		BIGNUM tmod;
		BN_ULONG buf[2];

		mont->ri=(BN_num_bits(mod)+(BN_BITS2-1))/BN_BITS2*BN_BITS2;
		if (!(BN_zero(R))) goto err;
		if (!(BN_set_bit(R,BN_BITS2))) goto err;	/* R */

		buf[0]=mod->d[0]; /* tmod = N mod word size */
		buf[1]=0;
		tmod.d=buf;
		tmod.top=1;
		tmod.dmax=2;
		tmod.neg=0;
							/* Ri = R^-1 mod N*/
		if ((BN_mod_inverse(&Ri,R,&tmod,ctx)) == NULL)
			goto err;
		if (!BN_lshift(&Ri,&Ri,BN_BITS2)) goto err; /* R*Ri */
		if (!BN_is_zero(&Ri))
			{
			if (!BN_sub_word(&Ri,1)) goto err;
			}
		else /* if N mod word size == 1 */
			{
			if (!BN_set_word(&Ri,BN_MASK2)) goto err;  /* Ri-- (mod word size) */
			}
		if (!BN_div(&Ri,NULL,&Ri,&tmod,ctx)) goto err;
		/* Ni = (R*Ri-1)/N,
		 * keep only least significant word: */
		mont->n0 = (Ri.top > 0) ? Ri.d[0] : 0;
		BN_free(&Ri);
		}
#else /* !MONT_WORD */
		{ /* bignum version */
		mont->ri=BN_num_bits(&mont->N);
		if (!BN_zero(R)) goto err;
		if (!BN_set_bit(R,mont->ri)) goto err;  /* R = 2^ri */
		                                        /* Ri = R^-1 mod N*/
		if ((BN_mod_inverse(&Ri,R,&mont->N,ctx)) == NULL)
			goto err;
		if (!BN_lshift(&Ri,&Ri,mont->ri)) goto err; /* R*Ri */
		if (!BN_sub_word(&Ri,1)) goto err;
							/* Ni = (R*Ri-1) / N */
		if (!BN_div(&(mont->Ni),NULL,&Ri,&mont->N,ctx)) goto err;
		BN_free(&Ri);
		}
d299 2
a300 3
	if (!BN_zero(&(mont->RR))) goto err;
	if (!BN_set_bit(&(mont->RR),mont->ri*2)) goto err;
	if (!BN_mod(&(mont->RR),&(mont->RR),&(mont->N),ctx)) goto err;
a304 12
	}

BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from)
	{
	if (to == from) return(to);

	if (!BN_copy(&(to->RR),&(from->RR))) return NULL;
	if (!BN_copy(&(to->N),&(from->N))) return NULL;
	if (!BN_copy(&(to->Ni),&(from->Ni))) return NULL;
	to->ri=from->ri;
	to->n0=from->n0;
	return(to);
@


1.1.1.3
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d276 1
a276 1
	if (!BN_copy(&(mont->N),mod)) goto err;		/* Set N */
@


1.1.1.4
log
@import of openssl-0.9.7j
@
text
@a349 20
BN_MONT_CTX *BN_MONT_CTX_set_locked(BN_MONT_CTX **pmont, int lock,
					const BIGNUM *mod, BN_CTX *ctx)
	{
	if (*pmont)
		return *pmont;
	CRYPTO_w_lock(lock);
	if (!*pmont)
		{
		*pmont = BN_MONT_CTX_new();
		if (*pmont && !BN_MONT_CTX_set(*pmont, mod, ctx))
			{
			BN_MONT_CTX_free(*pmont);
			*pmont = NULL;
			}
		}
	CRYPTO_w_unlock(lock);
	return *pmont;
	}
		

@


1.1.1.5
log
@import of OpenSSL 0.9.8h
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
a71 20
#if defined(MONT_WORD) && defined(OPENSSL_BN_ASM_MONT) && (BN_BITS2<=32)
/* This condition means we have a specific non-default build:
 * In the 0.9.8 branch, OPENSSL_BN_ASM_MONT is normally not set for any
 * BN_BITS2<=32 platform; an explicit "enable-montasm" is required.
 * I.e., if we are here, the user intentionally deviates from the
 * normal stable build to get better Montgomery performance from
 * the 0.9.9-dev backport.
 *
 * In this case only, we also enable BN_from_montgomery_word()
 * (another non-stable feature from 0.9.9-dev).
 */
#define MONT_FROM_WORD___NON_DEFAULT_0_9_8_BUILD
#endif

#ifdef MONT_FROM_WORD___NON_DEFAULT_0_9_8_BUILD
static int BN_from_montgomery_word(BIGNUM *ret, BIGNUM *r, BN_MONT_CTX *mont);
#endif



a76 19
#if defined(OPENSSL_BN_ASM_MONT) && defined(MONT_WORD)
	int num = mont->N.top;

	if (num>1 && a->top==num && b->top==num)
		{
		if (bn_wexpand(r,num) == NULL) return(0);
#if 0 /* for OpenSSL 0.9.9 mont->n0 */
		if (bn_mul_mont(r->d,a->d,b->d,mont->N.d,mont->n0,num))
#else
		if (bn_mul_mont(r->d,a->d,b->d,mont->N.d,&mont->n0,num))
#endif
			{
			r->neg = a->neg^b->neg;
			r->top = num;
			bn_correct_top(r);
			return(1);
			}
		}
#endif
a91 3
#ifdef MONT_FROM_WORD___NON_DEFAULT_0_9_8_BUILD
	if (!BN_from_montgomery_word(r,tmp,mont)) goto err;
#else
a92 2
#endif
	bn_check_top(r);
a98 144
#ifdef MONT_FROM_WORD___NON_DEFAULT_0_9_8_BUILD
static int BN_from_montgomery_word(BIGNUM *ret, BIGNUM *r, BN_MONT_CTX *mont)
	{
	BIGNUM *n;
	BN_ULONG *ap,*np,*rp,n0,v,*nrp;
	int al,nl,max,i,x,ri;

	n= &(mont->N);
	/* mont->ri is the size of mont->N in bits (rounded up
	   to the word size) */
	al=ri=mont->ri/BN_BITS2;

	nl=n->top;
	if ((al == 0) || (nl == 0)) { ret->top=0; return(1); }

	max=(nl+al+1); /* allow for overflow (no?) XXX */
	if (bn_wexpand(r,max) == NULL) return(0);

	r->neg^=n->neg;
	np=n->d;
	rp=r->d;
	nrp= &(r->d[nl]);

	/* clear the top words of T */
	for (i=r->top; i<max; i++) /* memset? XXX */
		r->d[i]=0;

	r->top=max;
#if 0 /* for OpenSSL 0.9.9 mont->n0 */
	n0=mont->n0[0];
#else
	n0=mont->n0;
#endif

#ifdef BN_COUNT
	fprintf(stderr,"word BN_from_montgomery_word %d * %d\n",nl,nl);
#endif
	for (i=0; i<nl; i++)
		{
#ifdef __TANDEM
                {
                   long long t1;
                   long long t2;
                   long long t3;
                   t1 = rp[0] * (n0 & 0177777);
                   t2 = 037777600000l;
                   t2 = n0 & t2;
                   t3 = rp[0] & 0177777;
                   t2 = (t3 * t2) & BN_MASK2;
                   t1 = t1 + t2;
                   v=bn_mul_add_words(rp,np,nl,(BN_ULONG) t1);
                }
#else
		v=bn_mul_add_words(rp,np,nl,(rp[0]*n0)&BN_MASK2);
#endif
		nrp++;
		rp++;
		if (((nrp[-1]+=v)&BN_MASK2) >= v)
			continue;
		else
			{
			if (((++nrp[0])&BN_MASK2) != 0) continue;
			if (((++nrp[1])&BN_MASK2) != 0) continue;
			for (x=2; (((++nrp[x])&BN_MASK2) == 0); x++) ;
			}
		}
	bn_correct_top(r);

	/* mont->ri will be a multiple of the word size and below code
	 * is kind of BN_rshift(ret,r,mont->ri) equivalent */
	if (r->top <= ri)
		{
		ret->top=0;
		return(1);
		}
	al=r->top-ri;

	if (bn_wexpand(ret,ri) == NULL) return(0);
	x=0-(((al-ri)>>(sizeof(al)*8-1))&1);
	ret->top=x=(ri&~x)|(al&x);	/* min(ri,al) */
	ret->neg=r->neg;

	rp=ret->d;
	ap=&(r->d[ri]);

	{
	size_t m1,m2;

	v=bn_sub_words(rp,ap,np,ri);
	/* this ----------------^^ works even in al<ri case
	 * thanks to zealous zeroing of top of the vector in the
	 * beginning. */

	/* if (al==ri && !v) || al>ri) nrp=rp; else nrp=ap; */
	/* in other words if subtraction result is real, then
	 * trick unconditional memcpy below to perform in-place
	 * "refresh" instead of actual copy. */
	m1=0-(size_t)(((al-ri)>>(sizeof(al)*8-1))&1);	/* al<ri */
	m2=0-(size_t)(((ri-al)>>(sizeof(al)*8-1))&1);	/* al>ri */
	m1|=m2;			/* (al!=ri) */
	m1|=(0-(size_t)v);	/* (al!=ri || v) */
	m1&=~m2;		/* (al!=ri || v) && !al>ri */
	nrp=(BN_ULONG *)(((size_t)rp&~m1)|((size_t)ap&m1));
	}

	/* 'i<ri' is chosen to eliminate dependency on input data, even
	 * though it results in redundant copy in al<ri case. */
	for (i=0,ri-=4; i<ri; i+=4)
		{
		BN_ULONG t1,t2,t3,t4;
		
		t1=nrp[i+0];
		t2=nrp[i+1];
		t3=nrp[i+2];	ap[i+0]=0;
		t4=nrp[i+3];	ap[i+1]=0;
		rp[i+0]=t1;	ap[i+2]=0;
		rp[i+1]=t2;	ap[i+3]=0;
		rp[i+2]=t3;
		rp[i+3]=t4;
		}
	for (ri+=4; i<ri; i++)
		rp[i]=nrp[i], ap[i]=0;
	bn_correct_top(r);
	bn_correct_top(ret);
	bn_check_top(ret);

	return(1);
	}

int BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,
	     BN_CTX *ctx)
	{
	int retn=0;
	BIGNUM *t;

	BN_CTX_start(ctx);
	if ((t = BN_CTX_get(ctx)) && BN_copy(t,a))
		retn = BN_from_montgomery_word(ret,t,mont);
	BN_CTX_end(ctx);
	return retn;
	}

#else /* !MONT_FROM_WORD___NON_DEFAULT_0_9_8_BUILD */

d125 1
d175 1
a175 1
	bn_correct_top(r);
d177 6
a182 17
	/* mont->ri will be a multiple of the word size and below code
	 * is kind of BN_rshift(ret,r,mont->ri) equivalent */
	if (r->top <= ri)
		{
		ret->top=0;
		retn=1;
		goto err;
		}
	al=r->top-ri;

# define BRANCH_FREE 1
# if BRANCH_FREE
	if (bn_wexpand(ret,ri) == NULL) goto err;
	x=0-(((al-ri)>>(sizeof(al)*8-1))&1);
	ret->top=x=(ri&~x)|(al&x);	/* min(ri,al) */
	ret->neg=r->neg;

d184 5
a188 43
	ap=&(r->d[ri]);

	{
	size_t m1,m2;

	v=bn_sub_words(rp,ap,np,ri);
	/* this ----------------^^ works even in al<ri case
	 * thanks to zealous zeroing of top of the vector in the
	 * beginning. */

	/* if (al==ri && !v) || al>ri) nrp=rp; else nrp=ap; */
	/* in other words if subtraction result is real, then
	 * trick unconditional memcpy below to perform in-place
	 * "refresh" instead of actual copy. */
	m1=0-(size_t)(((al-ri)>>(sizeof(al)*8-1))&1);	/* al<ri */
	m2=0-(size_t)(((ri-al)>>(sizeof(al)*8-1))&1);	/* al>ri */
	m1|=m2;			/* (al!=ri) */
	m1|=(0-(size_t)v);	/* (al!=ri || v) */
	m1&=~m2;		/* (al!=ri || v) && !al>ri */
	nrp=(BN_ULONG *)(((size_t)rp&~m1)|((size_t)ap&m1));
	}

	/* 'i<ri' is chosen to eliminate dependency on input data, even
	 * though it results in redundant copy in al<ri case. */
	for (i=0,ri-=4; i<ri; i+=4)
		{
		BN_ULONG t1,t2,t3,t4;
		
		t1=nrp[i+0];
		t2=nrp[i+1];
		t3=nrp[i+2];	ap[i+0]=0;
		t4=nrp[i+3];	ap[i+1]=0;
		rp[i+0]=t1;	ap[i+2]=0;
		rp[i+1]=t2;	ap[i+3]=0;
		rp[i+2]=t3;
		rp[i+3]=t4;
		}
	for (ri+=4; i<ri; i++)
		rp[i]=nrp[i], ap[i]=0;
	bn_correct_top(r);
	bn_correct_top(ret);
# else
	if (bn_wexpand(ret,al) == NULL) goto err;
a189 4
	ret->neg=r->neg;

	rp=ret->d;
	ap=&(r->d[ri]);
d207 1
a207 1
# endif
a226 1
#if !defined(BRANCH_FREE) || BRANCH_FREE==0
a230 1
#endif
a231 1
	bn_check_top(ret);
a235 1
#endif /* MONT_FROM_WORD___NON_DEFAULT_0_9_8_BUILD */
a254 5
#if 0 /* for OpenSSL 0.9.9 mont->n0 */
	ctx->n0[0] = ctx->n0[1] = 0;
#else
	ctx->n0 = 0;
#endif
d272 1
a272 2
	int ret = 0;
	BIGNUM *Ri,*R;
d274 1
a274 2
	BN_CTX_start(ctx);
	if((Ri = BN_CTX_get(ctx)) == NULL) goto err;
d285 1
a285 5
		BN_zero(R);
#if 0 /* for OpenSSL 0.9.9 mont->n0, would be "#if defined(OPENSSL_BN_ASM_MONT) && (BN_BITS2<=32)",
         only certain BN_BITS2<=32 platforms actually need this */
		if (!(BN_set_bit(R,2*BN_BITS2))) goto err;	/* R */
#else
a286 1
#endif
a289 2

		BN_init(&tmod);
d291 1
a291 1
		tmod.top = buf[0] != 0 ? 1 : 0;
a293 30

#if 0 /* for OpenSSL 0.9.9 mont->n0, would be "#if defined(OPENSSL_BN_ASM_MONT) && (BN_BITS2<=32)";
         only certain BN_BITS2<=32 platforms actually need this */
								tmod.top=0;
		if ((buf[0] = mod->d[0]))			tmod.top=1;
		if ((buf[1] = mod->top>1 ? mod->d[1] : 0))	tmod.top=2;

		if ((BN_mod_inverse(Ri,R,&tmod,ctx)) == NULL)
			goto err;
		if (!BN_lshift(Ri,Ri,2*BN_BITS2)) goto err; /* R*Ri */
		if (!BN_is_zero(Ri))
			{
			if (!BN_sub_word(Ri,1)) goto err;
			}
		else /* if N mod word size == 1 */
			{
			if (bn_expand(Ri,(int)sizeof(BN_ULONG)*2) == NULL)
				goto err;
			/* Ri-- (mod double word size) */
			Ri->neg=0;
			Ri->d[0]=BN_MASK2;
			Ri->d[1]=BN_MASK2;
			Ri->top=2;
			}
		if (!BN_div(Ri,NULL,Ri,&tmod,ctx)) goto err;
		/* Ni = (R*Ri-1)/N,
		 * keep only couple of least significant words: */
		mont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0;
		mont->n0[1] = (Ri->top > 1) ? Ri->d[1] : 0;
#else
d295 1
a295 1
		if ((BN_mod_inverse(Ri,R,&tmod,ctx)) == NULL)
d297 2
a298 2
		if (!BN_lshift(Ri,Ri,BN_BITS2)) goto err; /* R*Ri */
		if (!BN_is_zero(Ri))
d300 1
a300 1
			if (!BN_sub_word(Ri,1)) goto err;
d304 1
a304 1
			if (!BN_set_word(Ri,BN_MASK2)) goto err;  /* Ri-- (mod word size) */
d306 1
a306 1
		if (!BN_div(Ri,NULL,Ri,&tmod,ctx)) goto err;
d309 2
a310 7
# if 0 /* for OpenSSL 0.9.9 mont->n0 */
		mont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0;
		mont->n0[1] = 0;
# else
		mont->n0 = (Ri->top > 0) ? Ri->d[0] : 0;
# endif
#endif
d315 1
a315 1
		BN_zero(R);
d318 1
a318 1
		if ((BN_mod_inverse(Ri,R,&mont->N,ctx)) == NULL)
d320 2
a321 2
		if (!BN_lshift(Ri,Ri,mont->ri)) goto err; /* R*Ri */
		if (!BN_sub_word(Ri,1)) goto err;
d323 2
a324 1
		if (!BN_div(&(mont->Ni),NULL,Ri,&mont->N,ctx)) goto err;
d329 1
a329 1
	BN_zero(&(mont->RR));
d333 1
a333 1
	ret = 1;
d335 1
a335 2
	BN_CTX_end(ctx);
	return ret;
a345 4
#if 0 /* for OpenSSL 0.9.9 mont->n0 */
	to->n0[0]=from->n0[0];
	to->n0[1]=from->n0[1];
#else
a346 1
#endif
d353 3
a355 4
	int got_write_lock = 0;
	BN_MONT_CTX *ret;

	CRYPTO_r_lock(lock);
d358 2
a359 5
		CRYPTO_r_unlock(lock);
		CRYPTO_w_lock(lock);
		got_write_lock = 1;

		if (!*pmont)
d361 2
a362 5
			ret = BN_MONT_CTX_new();
			if (ret && !BN_MONT_CTX_set(ret, mod, ctx))
				BN_MONT_CTX_free(ret);
			else
				*pmont = ret;
d365 3
a367 7
	
	ret = *pmont;
	
	if (got_write_lock)
		CRYPTO_w_unlock(lock);
	else
		CRYPTO_r_unlock(lock);
d369 1
a369 2
	return ret;
	}
@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@d125 15
a139 1
#ifdef MONT_WORD
d143 2
d156 1
d158 3
d184 1
a184 1
#ifdef MONT_WORD
d196 1
a196 1
#ifdef MONT_WORD
a219 1
#if 1
a221 3
#else
	memset(&(r->d[r->top]),0,(max-r->top)*sizeof(BN_ULONG)); 
#endif
d224 1
d226 3
a272 2
#define BRANCH_FREE 1
#if BRANCH_FREE
d320 56
d377 101
a477 1
	if (bn_wexpand(ret,al) == NULL) return(0);
d500 2
a501 24

	if (BN_ucmp(ret, &(mont->N)) >= 0)
		{
		if (!BN_usub(ret,ret,&(mont->N))) return(0);
		}
#endif
	bn_check_top(ret);

	return(1);
	}
#endif	/* MONT_WORD */

int BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,
	     BN_CTX *ctx)
	{
	int retn=0;
#ifdef MONT_WORD
	BIGNUM *t;

	BN_CTX_start(ctx);
	if ((t = BN_CTX_get(ctx)) && BN_copy(t,a))
		retn = BN_from_montgomery_word(ret,t,mont);
	BN_CTX_end(ctx);
#else /* !MONT_WORD */
d518 1
d520 1
d525 1
a529 1
#endif /* MONT_WORD */
d532 1
d552 1
d554 3
d588 12
d602 1
d606 2
a607 11
		mont->ri=(BN_num_bits(mod)+(BN_BITS2-1))/BN_BITS2*BN_BITS2;

#if defined(OPENSSL_BN_ASM_MONT) && (BN_BITS2<=32)
		/* Only certain BN_BITS2<=32 platforms actually make use of
		 * n0[1], and we could use the #else case (with a shorter R
		 * value) for the others.  However, currently only the assembler
		 * files do know which is which. */

		BN_zero(R);
		if (!(BN_set_bit(R,2*BN_BITS2))) goto err;

a634 6
		BN_zero(R);
		if (!(BN_set_bit(R,BN_BITS2))) goto err;	/* R */

		buf[0]=mod->d[0]; /* tmod = N mod word size */
		buf[1]=0;
		tmod.top = buf[0] != 0 ? 1 : 0;
d650 1
d653 3
d692 1
d695 3
@


1.1.1.7
log
@import OpenSSL 1.0.0e
@
text
@d280 1
a280 1
	nrp=(BN_ULONG *)(((PTR_SIZE_INT)rp&~m1)|((PTR_SIZE_INT)ap&m1));
@


1.1.1.8
log
@import OpenSSL-1.0.1c
@
text
@d180 2
a181 2
	BN_ULONG *ap,*np,*rp,n0,v,carry;
	int nl,max,i;
d184 4
d189 1
a189 1
	if (nl == 0) { ret->top=0; return(1); }
d191 1
a191 1
	max=(2*nl); /* carry is stored separately */
d197 1
d202 1
a202 1
		rp[i]=0;
d204 1
a204 1
	memset(&(rp[r->top]),0,(max-r->top)*sizeof(BN_ULONG)); 
d213 1
a213 1
	for (carry=0, i=0; i<nl; i++, rp++)
d231 10
a240 4
		v = (v+carry+rp[nl])&BN_MASK2;
		carry |= (v != rp[nl]);
		carry &= (v <= rp[nl]);
		rp[nl]=v;
d242 1
d244 14
a257 2
	if (bn_wexpand(ret,nl) == NULL) return(0);
	ret->top=nl;
d261 1
a261 1
	ap=&(r->d[nl]);
a262 2
#define BRANCH_FREE 1
#if BRANCH_FREE
d264 1
a264 2
	BN_ULONG *nrp;
	size_t m;
d266 7
a272 2
	v=bn_sub_words(rp,ap,np,nl)-carry;
	/* if subtraction result is real, then
d275 7
a281 2
	m=(0-(size_t)v);
	nrp=(BN_ULONG *)(((PTR_SIZE_INT)rp&~m)|((PTR_SIZE_INT)ap&m));
d283 3
a285 1
	for (i=0,nl-=4; i<nl; i+=4)
d298 1
a298 1
	for (nl+=4; i<nl; i++)
d300 2
a301 1
	}
d303 28
a330 2
	if (bn_sub_words (rp,ap,np,nl)-carry)
		memcpy(rp,ap,nl*sizeof(BN_ULONG));
a331 2
	bn_correct_top(r);
	bn_correct_top(ret);
@


