head	1.24;
access;
symbols
	OPENBSD_6_0:1.23.0.8
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.4
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	butholakala:1.14
	openssl_1_0_1_g:1.1.1.8
	OPENBSD_5_5:1.13.0.8
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.4
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.2
	OPENBSD_5_3_BASE:1.13
	openssl_1_0_1_c:1.1.1.7
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.8
	openssl_1_0_0_f:1.1.1.6
	openssl_1_0_0_e:1.1.1.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	openssh_1_0_0_a:1.1.1.6
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	openssl_0_9_8_k:1.1.1.5
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	openssl_0_9_8_j:1.1.1.5
	openssl_0_9_8_h:1.1.1.4
	pre_openssl_0_9_8h:1.8
	OPENBSD_4_4:1.8.0.22
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.20
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.18
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	openssl_0_9_7j:1.1.1.3
	openssl:1.1.1
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENSSL_0_9_7G:1.1.1.3
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENSSL_0_9_7D:1.1.1.3
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENSSL_0_9_7C:1.1.1.3
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2016.09.03.11.33.35;	author beck;	state dead;
branches;
next	1.23;
commitid	HnbXxsegngek41U2;

1.23
date	2015.02.09.15.49.22;	author jsing;	state Exp;
branches;
next	1.22;
commitid	69Tc75PIK8JcRRsC;

1.22
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.21;
commitid	yQEL1wOWIearrW15;

1.21
date	2014.07.10.22.45.56;	author jsing;	state Exp;
branches;
next	1.20;
commitid	nzndm3zqPmFurSaK;

1.20
date	2014.06.27.22.02.07;	author miod;	state Exp;
branches;
next	1.19;
commitid	BVbYQJGqRX0Co41p;

1.19
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	mJUVYpkFBZ0Zv2bG;

1.18
date	2014.05.08.13.20.49;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.24.21.31.02;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.23.19.09.49;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.17.20.29.19;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.04.11.02.42;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches
	1.10.2.1
	1.10.6.1;
next	1.9;

1.9
date	2008.09.06.12.17.49;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.12.02.18.36;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.07.03.45.33;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.02.58;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.20;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.09.17;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.43;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.57;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.34.41;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.01.09.12.13.52;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.04;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2012.10.13.21.23.35;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.04.13.15.16.33;	author miod;	state Exp;
branches;
next	;

1.10.2.1
date	2010.03.12.13.26.38;	author jasper;	state Exp;
branches;
next	;

1.10.6.1
date	2010.03.12.13.26.05;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Remove the libssl/src directory
@
text
@/* $OpenBSD: bn_div.c,v 1.23 2015/02/09 15:49:22 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <stdio.h>

#include <openssl/opensslconf.h>

#include <openssl/bn.h>
#include <openssl/err.h>

#include "bn_lcl.h"

#if !defined(OPENSSL_NO_ASM) && !defined(OPENSSL_NO_INLINE_ASM) \
    && !defined(BN_DIV3W)
# if defined(__GNUC__) && __GNUC__>=2
#  if defined(__i386) || defined (__i386__)
   /*
    * There were two reasons for implementing this template:
    * - GNU C generates a call to a function (__udivdi3 to be exact)
    *   in reply to ((((BN_ULLONG)n0)<<BN_BITS2)|n1)/d0 (I fail to
    *   understand why...);
    * - divl doesn't only calculate quotient, but also leaves
    *   remainder in %edx which we can definitely use here:-)
    *
    *					<appro@@fy.chalmers.se>
    */
#undef bn_div_words
#  define bn_div_words(n0,n1,d0)		\
	({  asm volatile (			\
		"divl	%4"			\
		: "=a"(q), "=d"(rem)		\
		: "a"(n1), "d"(n0), "g"(d0)	\
		: "cc");			\
	    q;					\
	})
#  define REMAINDER_IS_ALREADY_CALCULATED
#  elif defined(__x86_64)
   /*
    * Same story here, but it's 128-bit by 64-bit division. Wow!
    *					<appro@@fy.chalmers.se>
    */
#  undef bn_div_words
#  define bn_div_words(n0,n1,d0)		\
	({  asm volatile (			\
		"divq	%4"			\
		: "=a"(q), "=d"(rem)		\
		: "a"(n1), "d"(n0), "g"(d0)	\
		: "cc");			\
	    q;					\
	})
#  define REMAINDER_IS_ALREADY_CALCULATED
#  endif /* __<cpu> */
# endif /* __GNUC__ */
#endif /* OPENSSL_NO_ASM */


/* BN_div computes  dv := num / divisor,  rounding towards
 * zero, and sets up rm  such that  dv*divisor + rm = num  holds.
 * Thus:
 *     dv->neg == num->neg ^ divisor->neg  (unless the result is zero)
 *     rm->neg == num->neg                 (unless the remainder is zero)
 * If 'dv' or 'rm' is NULL, the respective value is not returned.
 */
int
BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,
    BN_CTX *ctx)
{
	int norm_shift, i, loop;
	BIGNUM *tmp, wnum, *snum, *sdiv, *res;
	BN_ULONG *resp, *wnump;
	BN_ULONG d0, d1;
	int num_n, div_n;
	int no_branch = 0;

	/* Invalid zero-padding would have particularly bad consequences
	 * in the case of 'num', so don't just rely on bn_check_top() for this one
	 * (bn_check_top() works only for BN_DEBUG builds) */
	if (num->top > 0 && num->d[num->top - 1] == 0) {
		BNerr(BN_F_BN_DIV, BN_R_NOT_INITIALIZED);
		return 0;
	}

	bn_check_top(num);

	if ((BN_get_flags(num, BN_FLG_CONSTTIME) != 0) ||
	    (BN_get_flags(divisor, BN_FLG_CONSTTIME) != 0)) {
		no_branch = 1;
	}

	bn_check_top(dv);
	bn_check_top(rm);
	/* bn_check_top(num); */ /* 'num' has been checked already */
	bn_check_top(divisor);

	if (BN_is_zero(divisor)) {
		BNerr(BN_F_BN_DIV, BN_R_DIV_BY_ZERO);
		return (0);
	}

	if (!no_branch && BN_ucmp(num, divisor) < 0) {
		if (rm != NULL) {
			if (BN_copy(rm, num) == NULL)
				return (0);
		}
		if (dv != NULL)
			BN_zero(dv);
		return (1);
	}

	BN_CTX_start(ctx);
	tmp = BN_CTX_get(ctx);
	snum = BN_CTX_get(ctx);
	sdiv = BN_CTX_get(ctx);
	if (dv == NULL)
		res = BN_CTX_get(ctx);
	else
		res = dv;
	if (tmp == NULL || snum == NULL || sdiv == NULL || res == NULL)
		goto err;

	/* First we normalise the numbers */
	norm_shift = BN_BITS2 - ((BN_num_bits(divisor)) % BN_BITS2);
	if (!(BN_lshift(sdiv, divisor, norm_shift)))
		goto err;
	sdiv->neg = 0;
	norm_shift += BN_BITS2;
	if (!(BN_lshift(snum, num, norm_shift)))
		goto err;
	snum->neg = 0;

	if (no_branch) {
		/* Since we don't know whether snum is larger than sdiv,
		 * we pad snum with enough zeroes without changing its
		 * value.
		 */
		if (snum->top <= sdiv->top + 1) {
			if (bn_wexpand(snum, sdiv->top + 2) == NULL)
				goto err;
			for (i = snum->top; i < sdiv->top + 2; i++)
				snum->d[i] = 0;
			snum->top = sdiv->top + 2;
		} else {
			if (bn_wexpand(snum, snum->top + 1) == NULL)
				goto err;
			snum->d[snum->top] = 0;
			snum->top ++;
		}
	}

	div_n = sdiv->top;
	num_n = snum->top;
	loop = num_n - div_n;
	/* Lets setup a 'window' into snum
	 * This is the part that corresponds to the current
	 * 'area' being divided */
	wnum.neg = 0;
	wnum.d = &(snum->d[loop]);
	wnum.top = div_n;
	/* only needed when BN_ucmp messes up the values between top and max */
	wnum.dmax  = snum->dmax - loop; /* so we don't step out of bounds */
	wnum.flags = snum->flags | BN_FLG_STATIC_DATA;

	/* Get the top 2 words of sdiv */
	/* div_n=sdiv->top; */
	d0 = sdiv->d[div_n - 1];
	d1 = (div_n == 1) ? 0 : sdiv->d[div_n - 2];

	/* pointer to the 'top' of snum */
	wnump = &(snum->d[num_n - 1]);

	/* Setup to 'res' */
	res->neg = (num->neg ^ divisor->neg);
	if (!bn_wexpand(res, (loop + 1)))
		goto err;
	res->top = loop - no_branch;
	resp = &(res->d[loop - 1]);

	/* space for temp */
	if (!bn_wexpand(tmp, (div_n + 1)))
		goto err;

	if (!no_branch) {
		if (BN_ucmp(&wnum, sdiv) >= 0) {
			/* If BN_DEBUG_RAND is defined BN_ucmp changes (via
			 * bn_pollute) the const bignum arguments =>
			 * clean the values between top and max again */
			bn_clear_top2max(&wnum);
			bn_sub_words(wnum.d, wnum.d, sdiv->d, div_n);
			*resp = 1;
		} else
			res->top--;
	}

	/* if res->top == 0 then clear the neg value otherwise decrease
	 * the resp pointer */
	if (res->top == 0)
		res->neg = 0;
	else
		resp--;

	for (i = 0; i < loop - 1; i++, wnump--, resp--) {
		BN_ULONG q, l0;
		/* the first part of the loop uses the top two words of
		 * snum and sdiv to calculate a BN_ULONG q such that
		 * | wnum - sdiv * q | < sdiv */
#if defined(BN_DIV3W) && !defined(OPENSSL_NO_ASM)
		BN_ULONG bn_div_3_words(BN_ULONG*, BN_ULONG, BN_ULONG);
		q = bn_div_3_words(wnump, d1, d0);
#else
		BN_ULONG n0, n1, rem = 0;

		n0 = wnump[0];
		n1 = wnump[-1];
		if (n0 == d0)
			q = BN_MASK2;
		else 			/* n0 < d0 */
		{
#ifdef BN_LLONG
			BN_ULLONG t2;

#if defined(BN_DIV2W) && !defined(bn_div_words)
			q = (BN_ULONG)(((((BN_ULLONG)n0) << BN_BITS2)|n1)/d0);
#else
			q = bn_div_words(n0, n1, d0);
#endif

#ifndef REMAINDER_IS_ALREADY_CALCULATED
			/*
			 * rem doesn't have to be BN_ULLONG. The least we
			 * know it's less that d0, isn't it?
			 */
			rem = (n1 - q * d0) & BN_MASK2;
#endif
			t2 = (BN_ULLONG)d1*q;

			for (;;) {
				if (t2 <= ((((BN_ULLONG)rem) << BN_BITS2) |
				    wnump[-2]))
					break;
				q--;
				rem += d0;
				if (rem < d0) break; /* don't let rem overflow */
					t2 -= d1;
			}
#else /* !BN_LLONG */
			BN_ULONG t2l, t2h;

			q = bn_div_words(n0, n1, d0);
#ifndef REMAINDER_IS_ALREADY_CALCULATED
			rem = (n1 - q*d0)&BN_MASK2;
#endif

#if defined(BN_UMULT_LOHI)
			BN_UMULT_LOHI(t2l, t2h, d1, q);
#elif defined(BN_UMULT_HIGH)
			t2l = d1 * q;
			t2h = BN_UMULT_HIGH(d1, q);
#else
			{
				BN_ULONG ql, qh;
				t2l = LBITS(d1);
				t2h = HBITS(d1);
				ql = LBITS(q);
				qh = HBITS(q);
				mul64(t2l, t2h, ql, qh); /* t2=(BN_ULLONG)d1*q; */
			}
#endif

			for (;;) {
				if ((t2h < rem) ||
				    ((t2h == rem) && (t2l <= wnump[-2])))
					break;
				q--;
				rem += d0;
				if (rem < d0)
					break; /* don't let rem overflow */
				if (t2l < d1)
					t2h--;
				t2l -= d1;
			}
#endif /* !BN_LLONG */
		}
#endif /* !BN_DIV3W */

		l0 = bn_mul_words(tmp->d, sdiv->d, div_n, q);
		tmp->d[div_n] = l0;
		wnum.d--;
		/* ingore top values of the bignums just sub the two
		 * BN_ULONG arrays with bn_sub_words */
		if (bn_sub_words(wnum.d, wnum.d, tmp->d, div_n + 1)) {
			/* Note: As we have considered only the leading
			 * two BN_ULONGs in the calculation of q, sdiv * q
			 * might be greater than wnum (but then (q-1) * sdiv
			 * is less or equal than wnum)
			 */
			q--;
			if (bn_add_words(wnum.d, wnum.d, sdiv->d, div_n))
				/* we can't have an overflow here (assuming
				 * that q != 0, but if q == 0 then tmp is
				 * zero anyway) */
				(*wnump)++;
		}
		/* store part of the result */
		*resp = q;
	}
	bn_correct_top(snum);
	if (rm != NULL) {
		/* Keep a copy of the neg flag in num because if rm==num
		 * BN_rshift() will overwrite it.
		 */
		int neg = num->neg;
		BN_rshift(rm, snum, norm_shift);
		if (!BN_is_zero(rm))
			rm->neg = neg;
		bn_check_top(rm);
	}
	if (no_branch)
		bn_correct_top(res);
	BN_CTX_end(ctx);
	return (1);

err:
	bn_check_top(rm);
	BN_CTX_end(ctx);
	return (0);
}
@


1.23
log
@BN_CTX_get() can fail - consistently check its return value.

There are currently cases where the return from each call is checked,
the return from only the last call is checked and cases where it is not
checked at all (including code in bn, ec and engine).

Checking the last return value is valid as once the function fails it will
continue to return NULL. However, in order to be consistent check each
call with the same idiom. This makes it easy to verify.

Note there are still a handful of cases that do not follow the idiom -
these will be handled separately.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_div.c,v 1.22 2014/07/11 08:44:47 jsing Exp $ */
@


1.22
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_div.c,v 1.21 2014/07/10 22:45:56 jsing Exp $ */
d173 1
a173 1
	if (sdiv == NULL || res == NULL || tmp == NULL || snum == NULL)
@


1.21
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: bn_div.c,v 1.20 2014/06/27 22:02:07 miod Exp $ */
a59 1
#include <openssl/bn.h>
d63 3
a65 1
#include "cryptlib.h"
@


1.20
log
@When building a BN on the stack in BN_div(), make sure to initialize all its
fields (i.e. the flags field) before using it. This is currently harmless,
but might not be if we end up invoking other BN functions checking for
constant-time processing requirement in the future.
@
text
@d1 1
a1 1
/* $OpenBSD: bn_div.c,v 1.19 2014/06/12 15:49:28 deraadt Exp $ */
d61 3
@


1.19
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d212 1
@


1.18
log
@Emergency knfectomie requested by tedu@@.
@
text
@d1 1
a1 1
/* crypto/bn/bn_div.c */
@


1.17
log
@Try to clean the maze of <openssl/bn.h> defines regarding the BN internals.

The intent of this change is to only keep support for two kind of architectures:
- those with 32-bit int and long, and 64-bit long long, where
  ``long * long -> long long'' multiplication routines are available.
- those with 64-bit int and long, and no 128-bit long long type.

This gets rid of the SIXTY_FOUR_BIT_LONG, SIXTY_FOUR_BIT (not the same!),
THIRTY_TWO_BIT, SIXTEEN_BIT and EIGHT_BIT defines.

After this change, the types and defines are as follows:

arch:           64bit           32bit           rationale
BN_LLONG        undefined       defined         defined if l * l -> ll
BN_ULLONG       undefined       u long long     result of BN_LONG * BN_LONG
BN_ULONG        u long          u int           native register size
BN_LONG         long            int             the same, signed
BN_BITS         128             64              size of 2*BN_ULONG in bits
BN_BYTES        8               4               size of 2*BN_ULONG in bytes
BN_BITS2        64              32              BN_BITS / 2

Tested on various 32-bit and 64-bit OpenBSD systems of various endianness.
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d115 10
a124 9
int BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,
	   BN_CTX *ctx)
	{
	int norm_shift,i,loop;
	BIGNUM *tmp,wnum,*snum,*sdiv,*res;
	BN_ULONG *resp,*wnump;
	BN_ULONG d0,d1;
	int num_n,div_n;
	int no_branch=0;
d129 2
a130 3
	if (num->top > 0 && num->d[num->top - 1] == 0)
		{
		BNerr(BN_F_BN_DIV,BN_R_NOT_INITIALIZED);
d132 1
a132 1
		}
d136 4
a139 4
	if ((BN_get_flags(num, BN_FLG_CONSTTIME) != 0) || (BN_get_flags(divisor, BN_FLG_CONSTTIME) != 0))
		{
		no_branch=1;
		}
d146 4
a149 5
	if (BN_is_zero(divisor))
		{
		BNerr(BN_F_BN_DIV,BN_R_DIV_BY_ZERO);
		return(0);
		}
d151 4
a154 6
	if (!no_branch && BN_ucmp(num,divisor) < 0)
		{
		if (rm != NULL)
			{ if (BN_copy(rm,num) == NULL) return(0); }
		if (dv != NULL) BN_zero(dv);
		return(1);
d156 4
d162 3
a164 3
	tmp=BN_CTX_get(ctx);
	snum=BN_CTX_get(ctx);
	sdiv=BN_CTX_get(ctx);
d166 3
a168 2
		res=BN_CTX_get(ctx);
	else	res=dv;
d173 8
a180 6
	norm_shift=BN_BITS2-((BN_num_bits(divisor))%BN_BITS2);
	if (!(BN_lshift(sdiv,divisor,norm_shift))) goto err;
	sdiv->neg=0;
	norm_shift+=BN_BITS2;
	if (!(BN_lshift(snum,num,norm_shift))) goto err;
	snum->neg=0;
d182 1
a182 2
	if (no_branch)
		{
d185 1
a185 1
		 * value. 
d187 5
a191 4
		if (snum->top <= sdiv->top+1) 
			{
			if (bn_wexpand(snum, sdiv->top + 2) == NULL) goto err;
			for (i = snum->top; i < sdiv->top + 2; i++) snum->d[i] = 0;
d193 3
a195 4
			}
		else
			{
			if (bn_wexpand(snum, snum->top + 1) == NULL) goto err;
a197 1
			}
d199 1
d201 3
a203 3
	div_n=sdiv->top;
	num_n=snum->top;
	loop=num_n-div_n;
d207 3
a209 3
	wnum.neg   = 0;
	wnum.d     = &(snum->d[loop]);
	wnum.top   = div_n;
d215 2
a216 2
	d0=sdiv->d[div_n-1];
	d1=(div_n == 1)?0:sdiv->d[div_n-2];
d219 1
a219 1
	wnump= &(snum->d[num_n-1]);
d222 5
a226 4
	res->neg= (num->neg^divisor->neg);
	if (!bn_wexpand(res,(loop+1))) goto err;
	res->top=loop-no_branch;
	resp= &(res->d[loop-1]);
d229 2
a230 1
	if (!bn_wexpand(tmp,(div_n+1))) goto err;
d232 2
a233 4
	if (!no_branch)
		{
		if (BN_ucmp(&wnum,sdiv) >= 0)
			{
d239 2
a240 3
			*resp=1;
			}
		else
d242 1
a242 1
		}
d251 2
a252 3
	for (i=0; i<loop-1; i++, wnump--, resp--)
		{
		BN_ULONG q,l0;
d257 2
a258 2
		BN_ULONG bn_div_3_words(BN_ULONG*,BN_ULONG,BN_ULONG);
		q=bn_div_3_words(wnump,d1,d0);
d260 1
a260 1
		BN_ULONG n0,n1,rem=0;
d262 2
a263 2
		n0=wnump[0];
		n1=wnump[-1];
d265 1
a265 1
			q=BN_MASK2;
d267 1
a267 1
			{
d272 1
a272 1
			q=(BN_ULONG)(((((BN_ULLONG)n0)<<BN_BITS2)|n1)/d0);
d274 1
a274 1
			q=bn_div_words(n0,n1,d0);
d282 1
a282 1
			rem=(n1-q*d0)&BN_MASK2;
d284 1
a284 1
			t2=(BN_ULLONG)d1*q;
d286 3
a288 3
			for (;;)
				{
				if (t2 <= ((((BN_ULLONG)rem)<<BN_BITS2)|wnump[-2]))
d293 2
a294 2
				t2 -= d1;
				}
d296 1
a296 1
			BN_ULONG t2l,t2h;
d298 1
a298 1
			q=bn_div_words(n0,n1,d0);
d300 1
a300 1
			rem=(n1-q*d0)&BN_MASK2;
d304 1
a304 1
			BN_UMULT_LOHI(t2l,t2h,d1,q);
d307 1
a307 1
			t2h = BN_UMULT_HIGH(d1,q);
d310 6
a315 4
			BN_ULONG ql, qh;
			t2l=LBITS(d1); t2h=HBITS(d1);
			ql =LBITS(q);  qh =HBITS(q);
			mul64(t2l,t2h,ql,qh); /* t2=(BN_ULLONG)d1*q; */
d319 1
a319 2
			for (;;)
				{
d321 1
a321 1
					((t2h == rem) && (t2l <= wnump[-2])))
d325 6
a330 3
				if (rem < d0) break; /* don't let rem overflow */
				if (t2l < d1) t2h--; t2l -= d1;
				}
d332 1
a332 1
			}
d335 2
a336 2
		l0=bn_mul_words(tmp->d,sdiv->d,div_n,q);
		tmp->d[div_n]=l0;
d338 1
a338 1
		/* ingore top values of the bignums just sub the two 
d340 1
a340 2
		if (bn_sub_words(wnum.d, wnum.d, tmp->d, div_n+1))
			{
d352 1
a352 1
			}
d355 1
a355 1
		}
d357 1
a357 2
	if (rm != NULL)
		{
d362 1
a362 1
		BN_rshift(rm,snum,norm_shift);
d366 3
a368 2
		}
	if (no_branch)	bn_correct_top(res);
d370 2
a371 1
	return(1);
d375 2
a376 2
	return(0);
	}
@


1.16
log
@Unifdef -UPEDANTIC. ok beck@@ tedu@@
@
text
@a63 66

/* The old slow way */
#if 0
int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, const BIGNUM *d,
	   BN_CTX *ctx)
	{
	int i,nm,nd;
	int ret = 0;
	BIGNUM *D;

	bn_check_top(m);
	bn_check_top(d);
	if (BN_is_zero(d))
		{
		BNerr(BN_F_BN_DIV,BN_R_DIV_BY_ZERO);
		return(0);
		}

	if (BN_ucmp(m,d) < 0)
		{
		if (rem != NULL)
			{ if (BN_copy(rem,m) == NULL) return(0); }
		if (dv != NULL) BN_zero(dv);
		return(1);
		}

	BN_CTX_start(ctx);
	D = BN_CTX_get(ctx);
	if (dv == NULL) dv = BN_CTX_get(ctx);
	if (rem == NULL) rem = BN_CTX_get(ctx);
	if (D == NULL || dv == NULL || rem == NULL)
		goto end;

	nd=BN_num_bits(d);
	nm=BN_num_bits(m);
	if (BN_copy(D,d) == NULL) goto end;
	if (BN_copy(rem,m) == NULL) goto end;

	/* The next 2 are needed so we can do a dv->d[0]|=1 later
	 * since BN_lshift1 will only work once there is a value :-) */
	BN_zero(dv);
	if(bn_wexpand(dv,1) == NULL) goto end;
	dv->top=1;

	if (!BN_lshift(D,D,nm-nd)) goto end;
	for (i=nm-nd; i>=0; i--)
		{
		if (!BN_lshift1(dv,dv)) goto end;
		if (BN_ucmp(rem,D) >= 0)
			{
			dv->d[0]|=1;
			if (!BN_usub(rem,rem,D)) goto end;
			}
/* CAN IMPROVE (and have now :=) */
		if (!BN_rshift1(D,D)) goto end;
		}
	rem->neg=BN_is_zero(rem)?0:m->neg;
	dv->neg=m->neg^d->neg;
	ret = 1;
 end:
	BN_CTX_end(ctx);
	return(ret);
	}

#else

d88 1
a88 1
#  elif defined(__x86_64) && defined(SIXTY_FOUR_BIT_LONG)
d270 1
a270 1
#if defined(BN_LLONG) && defined(BN_DIV2W) && !defined(bn_div_words)
a371 1
#endif
@


1.15
log
@Nuke BN_DEBUG_LEVITTE
@
text
@d131 1
a131 1
    && !defined(PEDANTIC) && !defined(BN_DIV3W)
@


1.14
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a339 5
#ifdef BN_DEBUG_LEVITTE
			fprintf(stderr,"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\
X) -> 0x%08X\n",
				n0, n1, d0, q);
#endif
a363 5
#ifdef BN_DEBUG_LEVITTE
			fprintf(stderr,"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\
X) -> 0x%08X\n",
				n0, n1, d0, q);
#endif
@


1.13
log
@resolve conflicts
@
text
@d144 1
d159 1
@


1.12
log
@resolve conflicts, fix local changes
@
text
@d172 1
a172 1
/* BN_div[_no_branch] computes  dv := num / divisor,  rounding towards
a178 2
static int BN_div_no_branch(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num,
        const BIGNUM *divisor, BN_CTX *ctx);
d187 1
d202 1
a202 1
		return BN_div_no_branch(dv, rm, num, divisor, ctx);
d216 1
a216 1
	if (BN_ucmp(num,divisor) < 0)
a240 28
	div_n=sdiv->top;
	num_n=snum->top;
	loop=num_n-div_n;
	/* Lets setup a 'window' into snum
	 * This is the part that corresponds to the current
	 * 'area' being divided */
	wnum.neg   = 0;
	wnum.d     = &(snum->d[loop]);
	wnum.top   = div_n;
	/* only needed when BN_ucmp messes up the values between top and max */
	wnum.dmax  = snum->dmax - loop; /* so we don't step out of bounds */

	/* Get the top 2 words of sdiv */
	/* div_n=sdiv->top; */
	d0=sdiv->d[div_n-1];
	d1=(div_n == 1)?0:sdiv->d[div_n-2];

	/* pointer to the 'top' of snum */
	wnump= &(snum->d[num_n-1]);

	/* Setup to 'res' */
	res->neg= (num->neg^divisor->neg);
	if (!bn_wexpand(res,(loop+1))) goto err;
	res->top=loop;
	resp= &(res->d[loop-1]);

	/* space for temp */
	if (!bn_wexpand(tmp,(div_n+1))) goto err;
d242 1
a242 1
	if (BN_ucmp(&wnum,sdiv) >= 0)
d244 5
a248 85
		/* If BN_DEBUG_RAND is defined BN_ucmp changes (via
		 * bn_pollute) the const bignum arguments =>
		 * clean the values between top and max again */
		bn_clear_top2max(&wnum);
		bn_sub_words(wnum.d, wnum.d, sdiv->d, div_n);
		*resp=1;
		}
	else
		res->top--;
	/* if res->top == 0 then clear the neg value otherwise decrease
	 * the resp pointer */
	if (res->top == 0)
		res->neg = 0;
	else
		resp--;

	for (i=0; i<loop-1; i++, wnump--, resp--)
		{
		BN_ULONG q,l0;
		/* the first part of the loop uses the top two words of
		 * snum and sdiv to calculate a BN_ULONG q such that
		 * | wnum - sdiv * q | < sdiv */
#if defined(BN_DIV3W) && !defined(OPENSSL_NO_ASM)
		BN_ULONG bn_div_3_words(BN_ULONG*,BN_ULONG,BN_ULONG);
		q=bn_div_3_words(wnump,d1,d0);
#else
		BN_ULONG n0,n1,rem=0;

		n0=wnump[0];
		n1=wnump[-1];
		if (n0 == d0)
			q=BN_MASK2;
		else 			/* n0 < d0 */
			{
#ifdef BN_LLONG
			BN_ULLONG t2;

#if defined(BN_LLONG) && defined(BN_DIV2W) && !defined(bn_div_words)
			q=(BN_ULONG)(((((BN_ULLONG)n0)<<BN_BITS2)|n1)/d0);
#else
			q=bn_div_words(n0,n1,d0);
#ifdef BN_DEBUG_LEVITTE
			fprintf(stderr,"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\
X) -> 0x%08X\n",
				n0, n1, d0, q);
#endif
#endif

#ifndef REMAINDER_IS_ALREADY_CALCULATED
			/*
			 * rem doesn't have to be BN_ULLONG. The least we
			 * know it's less that d0, isn't it?
			 */
			rem=(n1-q*d0)&BN_MASK2;
#endif
			t2=(BN_ULLONG)d1*q;

			for (;;)
				{
				if (t2 <= ((((BN_ULLONG)rem)<<BN_BITS2)|wnump[-2]))
					break;
				q--;
				rem += d0;
				if (rem < d0) break; /* don't let rem overflow */
				t2 -= d1;
				}
#else /* !BN_LLONG */
			BN_ULONG t2l,t2h;

			q=bn_div_words(n0,n1,d0);
#ifdef BN_DEBUG_LEVITTE
			fprintf(stderr,"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\
X) -> 0x%08X\n",
				n0, n1, d0, q);
#endif
#ifndef REMAINDER_IS_ALREADY_CALCULATED
			rem=(n1-q*d0)&BN_MASK2;
#endif

#if defined(BN_UMULT_LOHI)
			BN_UMULT_LOHI(t2l,t2h,d1,q);
#elif defined(BN_UMULT_HIGH)
			t2l = d1 * q;
			t2h = BN_UMULT_HIGH(d1,q);
#else
d250 3
a252 4
			BN_ULONG ql, qh;
			t2l=LBITS(d1); t2h=HBITS(d1);
			ql =LBITS(q);  qh =HBITS(q);
			mul64(t2l,t2h,ql,qh); /* t2=(BN_ULLONG)d1*q; */
d254 1
a254 22
#endif

			for (;;)
				{
				if ((t2h < rem) ||
					((t2h == rem) && (t2l <= wnump[-2])))
					break;
				q--;
				rem += d0;
				if (rem < d0) break; /* don't let rem overflow */
				if (t2l < d1) t2h--; t2l -= d1;
				}
#endif /* !BN_LLONG */
			}
#endif /* !BN_DIV3W */

		l0=bn_mul_words(tmp->d,sdiv->d,div_n,q);
		tmp->d[div_n]=l0;
		wnum.d--;
		/* ingore top values of the bignums just sub the two 
		 * BN_ULONG arrays with bn_sub_words */
		if (bn_sub_words(wnum.d, wnum.d, tmp->d, div_n+1))
d256 3
a258 11
			/* Note: As we have considered only the leading
			 * two BN_ULONGs in the calculation of q, sdiv * q
			 * might be greater than wnum (but then (q-1) * sdiv
			 * is less or equal than wnum)
			 */
			q--;
			if (bn_add_words(wnum.d, wnum.d, sdiv->d, div_n))
				/* we can't have an overflow here (assuming
				 * that q != 0, but if q == 0 then tmp is
				 * zero anyway) */
				(*wnump)++;
a259 79
		/* store part of the result */
		*resp = q;
		}
	bn_correct_top(snum);
	if (rm != NULL)
		{
		/* Keep a copy of the neg flag in num because if rm==num
		 * BN_rshift() will overwrite it.
		 */
		int neg = num->neg;
		BN_rshift(rm,snum,norm_shift);
		if (!BN_is_zero(rm))
			rm->neg = neg;
		bn_check_top(rm);
		}
	BN_CTX_end(ctx);
	return(1);
err:
	bn_check_top(rm);
	BN_CTX_end(ctx);
	return(0);
	}


/* BN_div_no_branch is a special version of BN_div. It does not contain
 * branches that may leak sensitive information.
 */
static int BN_div_no_branch(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, 
	const BIGNUM *divisor, BN_CTX *ctx)
	{
	int norm_shift,i,loop;
	BIGNUM *tmp,wnum,*snum,*sdiv,*res;
	BN_ULONG *resp,*wnump;
	BN_ULONG d0,d1;
	int num_n,div_n;

	bn_check_top(dv);
	bn_check_top(rm);
	/* bn_check_top(num); */ /* 'num' has been checked in BN_div() */
	bn_check_top(divisor);

	if (BN_is_zero(divisor))
		{
		BNerr(BN_F_BN_DIV_NO_BRANCH,BN_R_DIV_BY_ZERO);
		return(0);
		}

	BN_CTX_start(ctx);
	tmp=BN_CTX_get(ctx);
	snum=BN_CTX_get(ctx);
	sdiv=BN_CTX_get(ctx);
	if (dv == NULL)
		res=BN_CTX_get(ctx);
	else	res=dv;
	if (sdiv == NULL || res == NULL) goto err;

	/* First we normalise the numbers */
	norm_shift=BN_BITS2-((BN_num_bits(divisor))%BN_BITS2);
	if (!(BN_lshift(sdiv,divisor,norm_shift))) goto err;
	sdiv->neg=0;
	norm_shift+=BN_BITS2;
	if (!(BN_lshift(snum,num,norm_shift))) goto err;
	snum->neg=0;

	/* Since we don't know whether snum is larger than sdiv,
	 * we pad snum with enough zeroes without changing its
	 * value. 
	 */
	if (snum->top <= sdiv->top+1) 
		{
		if (bn_wexpand(snum, sdiv->top + 2) == NULL) goto err;
		for (i = snum->top; i < sdiv->top + 2; i++) snum->d[i] = 0;
		snum->top = sdiv->top + 2;
		}
	else
		{
		if (bn_wexpand(snum, snum->top + 1) == NULL) goto err;
		snum->d[snum->top] = 0;
		snum->top ++;
d285 1
a285 1
	res->top=loop-1;
d291 15
d438 1
a438 1
	bn_correct_top(res);
a445 1

@


1.11
log
@cherrypick patch from OpenSSL 0.9.8m:

  *) Always check bn_wexpend() return values for failure.  (CVE-2009-3245)
     [Martin Olsson, Neel Mehta]
@
text
@d232 2
a233 1
	if (sdiv == NULL || res == NULL) goto err;
d340 1
a340 1
			BN_ULONG t2l,t2h,ql,qh;
d358 2
d363 1
d567 1
a567 1
			BN_ULONG t2l,t2h,ql,qh;
d585 2
d590 1
@


1.10
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d105 1
a105 1
	bn_wexpand(dv,1);
@


1.10.2.1
log
@MFC, original commit by djm@@:
---------------------------
cherrypick patch from OpenSSL 0.9.8m:

  *) Always check bn_wexpend() return values for failure.  (CVE-2009-3245)
     [Martin Olsson, Neel Mehta]

---------------------------

ok sthen@@
@
text
@d105 1
a105 1
	if(bn_wexpand(dv,1) == NULL) goto end;
@


1.10.6.1
log
@MFC, original commit by djm@@:
---------------------------
cherrypick patch from OpenSSL 0.9.8m:

  *) Always check bn_wexpend() return values for failure.  (CVE-2009-3245)
     [Martin Olsson, Neel Mehta]

---------------------------

ok sthen@@
@
text
@d105 1
a105 1
	if(bn_wexpand(dv,1) == NULL) goto end;
@


1.9
log
@resolve conflicts
@
text
@d190 11
d208 1
a208 1
	bn_check_top(num);
d433 1
a433 1
	bn_check_top(num);
@


1.8
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d172 2
a173 2
/* BN_div computes  dv := num / divisor,  rounding towards zero, and sets up
 * rm  such that  dv*divisor + rm = num  holds.
d179 2
d184 1
a184 1
	int norm_shift,i,j,loop;
d190 7
a221 1
	tmp->neg=0;
a232 1

d236 5
a240 4
	BN_init(&wnum);
	wnum.d=	 &(snum->d[loop]);
	wnum.top= div_n;
	wnum.dmax= snum->dmax+1; /* a bit of a lie */
d243 1
a243 1
	/* i=sdiv->top; */
d261 5
a265 1
		if (!BN_usub(&wnum,&wnum,sdiv)) goto err;
a266 1
		res->d[res->top-1]=1;
d270 2
d274 2
a275 1
	resp--;
d277 1
a277 1
	for (i=0; i<loop-1; i++)
d280 3
a365 1
		wnum.d--; wnum.top++;
d367 154
a520 3
		for (j=div_n+1; j>0; j--)
			if (tmp->d[j-1]) break;
		tmp->top=j;
d522 10
a531 2
		j=wnum.top;
		if (!BN_sub(&wnum,&wnum,tmp)) goto err;
d533 8
a540 1
		snum->top=snum->top+wnum.top-j;
d542 53
a594 1
		if (wnum.neg)
d596 5
d602 5
a606 3
			j=wnum.top;
			if (!BN_add(&wnum,&wnum,sdiv)) goto err;
			snum->top+=wnum.top-j;
d608 2
a609 2
		*(resp--)=q;
		wnump--;
d611 1
d621 1
d623 1
d627 1
@


1.7
log
@Merge OpenSSL 0.9.7-stable-20020605,
correctly autogenerate obj_mac.h
@
text
@d153 14
d285 5
d314 5
d323 3
a325 1
#ifdef BN_UMULT_HIGH
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d203 1
a203 1
	BN_lshift(sdiv,divisor,norm_shift);
d206 1
a206 1
	BN_lshift(snum,num,norm_shift);
d330 1
a330 1
		BN_sub(&wnum,&wnum,tmp);
d338 1
a338 1
			BN_add(&wnum,&wnum,sdiv);
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@d64 1
d130 2
a131 1
#if !defined(NO_ASM) && !defined(NO_INLINE_ASM) && !defined(PEDANTIC) && !defined(BN_DIV3W)
d133 1
a133 1
#  if defined(__i386)
d155 2
a156 1
#endif /* NO_ASM */
d158 7
d198 1
a198 1
	if (sdiv==NULL || res == NULL) goto err;
d245 2
d252 1
a252 1
#if defined(BN_DIV3W) && !defined(NO_ASM)
d346 4
d351 2
a352 1
		rm->neg=num->neg;
a361 37

/* rem != m */
int BN_mod(BIGNUM *rem, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)
	{
#if 0 /* The old slow way */
	int i,nm,nd;
	BIGNUM *dv;

	if (BN_ucmp(m,d) < 0)
		return((BN_copy(rem,m) == NULL)?0:1);

	BN_CTX_start(ctx);
	dv=BN_CTX_get(ctx);

	if (!BN_copy(rem,m)) goto err;

	nm=BN_num_bits(rem);
	nd=BN_num_bits(d);
	if (!BN_lshift(dv,d,nm-nd)) goto err;
	for (i=nm-nd; i>=0; i--)
		{
		if (BN_cmp(rem,dv) >= 0)
			{
			if (!BN_sub(rem,rem,dv)) goto err;
			}
		if (!BN_rshift1(dv,dv)) goto err;
		}
	BN_CTX_end(ctx);
	return(1);
 err:
	BN_CTX_end(ctx);
	return(0);
#else
	return(BN_div(NULL,rem,m,d,ctx));
#endif
	}

@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@a182 1
	tmp->neg=0;
d188 2
a189 1
	if (res == NULL) goto err;
d240 2
a241 1
#ifdef BN_DIV3W
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d208 1
a208 1
	wnum.max= snum->max+1; /* a bit of a lie */
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d66 2
a67 1
int BN_div(BIGNUM *dv, BIGNUM *rem, BIGNUM *m, BIGNUM *d, BN_CTX *ctx)
d70 1
d89 6
a94 3
	D= &(ctx->bn[ctx->tos]);
	if (dv == NULL) dv= &(ctx->bn[ctx->tos+1]);
	if (rem == NULL) rem= &(ctx->bn[ctx->tos+2]);
d98 2
a99 2
	if (BN_copy(D,d) == NULL) return(0);
	if (BN_copy(rem,m) == NULL) return(0);
d107 1
a107 1
	if (!BN_lshift(D,D,nm-nd)) return(0);
d110 1
a110 1
		if (!BN_lshift1(dv,dv)) return(0);
d114 1
a114 1
			if (!BN_usub(rem,rem,D)) return(0);
d117 1
a117 1
		if (!BN_rshift1(D,D)) return(0);
d121 4
a124 1
	return(1);
d129 26
d181 2
a182 1
	tmp= &(ctx->bn[ctx->tos]);
d184 2
a185 2
	snum= &(ctx->bn[ctx->tos+1]);
	sdiv= &(ctx->bn[ctx->tos+2]);
d187 1
a187 1
		res= &(ctx->bn[ctx->tos+3]);
d189 1
d241 1
a241 1
		q=bn_div_3_words(wnump,d0,d1);
a242 26

#if !defined(NO_ASM) && !defined(PEDANTIC)
# if defined(__GNUC__) && __GNUC__>=2
#  if defined(__i386)
   /*
    * There were two reasons for implementing this template:
    * - GNU C generates a call to a function (__udivdi3 to be exact)
    *   in reply to ((((BN_ULLONG)n0)<<BN_BITS2)|n1)/d0 (I fail to
    *   understand why...);
    * - divl doesn't only calculate quotient, but also leaves
    *   remainder in %edx which we can definitely use here:-)
    *
    *					<appro@@fy.chalmers.se>
    */
#  define bn_div_words(n0,n1,d0)		\
	({  asm volatile (			\
		"divl	%4"			\
		: "=a"(q), "=d"(rem)		\
		: "a"(n1), "d"(n0), "g"(d0)	\
		: "cc");			\
	    q;					\
	})
#  define REMINDER_IS_ALREADY_CALCULATED
#  endif /* __<cpu> */
# endif /* __GNUC__ */
#endif /* NO_ASM */
d249 5
a253 1
		else
d255 1
a255 1
			q=((((BN_ULLONG)n0)<<BN_BITS2)|n1)/d0;
a258 3
		{
#ifdef BN_LLONG
		BN_ULLONG t2;
d260 24
a283 6
#ifndef REMINDER_IS_ALREADY_CALCULATED
		/*
		 * rem doesn't have to be BN_ULLONG. The least we
		 * know it's less that d0, isn't it?
		 */
		rem=(n1-q*d0)&BN_MASK2;
a284 1
		t2=(BN_ULLONG)d1*q;
d286 3
a288 9
		for (;;)
			{
                        if (t2 <= ((((BN_ULLONG)rem)<<BN_BITS2)|wnump[-2]))
				break;
			q--;
			rem += d0;
			if (rem < d0) break; /* don't let rem overflow */
			t2 -= d1;
			}
d290 3
a292 8
		BN_ULONG t2l,t2h,ql,qh;

#ifndef REMINDER_IS_ALREADY_CALCULATED
		/*
		 * It's more than enough with the only multiplication.
		 * See the comment above in BN_LLONG section...
		 */
		rem=(n1-q*d0)&BN_MASK2;
a293 3
		t2l=LBITS(d1); t2h=HBITS(d1);
		ql =LBITS(q);  qh =HBITS(q);
		mul64(t2l,t2h,ql,qh); /* t2=(BN_ULLONG)d1*q; */
d295 11
a305 9
		for (;;)
			{
			if ((t2h < rem) ||
				((t2h == rem) && (t2l <= wnump[-2])))
				break;
			q--;
			rem += d0;
			if (rem < d0) break; /* don't let rem overflow */
			if (t2l < d1) t2h--; t2l -= d1;
a306 2
#endif
		}
d308 2
a310 1
		l0=bn_mul_words(tmp->d,sdiv->d,div_n,q);
d336 1
d339 1
d355 2
a356 1
	dv= &(ctx->bn[ctx->tos]);
d358 1
a358 1
	if (!BN_copy(rem,m)) return(0);
d362 1
a362 1
	if (!BN_lshift(dv,d,nm-nd)) return(0);
d367 1
a367 1
			if (!BN_sub(rem,rem,dv)) return(0);
d369 1
a369 1
		if (!BN_rshift1(dv,dv)) return(0);
d371 1
d373 3
@


1.1
log
@Initial revision
@
text
@d60 1
d66 1
a66 6
int BN_div(dv, rem, m, d,ctx)
BIGNUM *dv;
BIGNUM *rem;
BIGNUM *m;
BIGNUM *d;
BN_CTX *ctx;
d71 2
d87 3
a89 3
	D=ctx->bn[ctx->tos];
	if (dv == NULL) dv=ctx->bn[ctx->tos+1];
	if (rem == NULL) rem=ctx->bn[ctx->tos+2];
d99 1
d109 1
a109 1
			bn_qsub(rem,rem,D);
d121 2
a122 6
int BN_div(dv, rm, num, divisor,ctx)
BIGNUM *dv;
BIGNUM *rm;
BIGNUM *num;
BIGNUM *divisor;
BN_CTX *ctx;
d130 3
d147 1
a147 1
	tmp=ctx->bn[ctx->tos]; 
d149 2
a150 2
	snum=ctx->bn[ctx->tos+1];
	sdiv=ctx->bn[ctx->tos+2];
d152 1
a152 1
		res=ctx->bn[ctx->tos+3];
d169 1
d172 1
a172 2
	wnum.max= snum->max; /* a bit of a lie */
	wnum.neg= 0;
d184 1
a185 1
	if (!bn_wexpand(res,(loop+1))) goto err;
d193 1
a193 1
		bn_qsub(&wnum,&wnum,sdiv);
d203 31
a233 2
		BN_ULONG q,n0,n1;
		BN_ULONG l0;
a234 1
		wnum.d--; wnum.top++;
d240 5
a244 1
			q=bn_div64(n0,n1,d0);
d247 11
a257 2
		BN_ULLONG t1,t2,rem;
		t1=((BN_ULLONG)n0<<BN_BITS2)|n1;
d260 1
a260 4
			t2=(BN_ULLONG)d1*q;
			rem=t1-(BN_ULLONG)q*d0;
			if ((rem>>BN_BITS2) ||
				(t2 <= ((BN_ULLONG)(rem<<BN_BITS2)+wnump[-2])))
d263 3
d268 13
a280 3
		BN_ULONG t1l,t1h,t2l,t2h,t3l,t3h,ql,qh,t3t;
		t1h=n0;
		t1l=n1;
d283 3
a285 17
			t2l=LBITS(d1); t2h=HBITS(d1);
			ql =LBITS(q);  qh =HBITS(q);
			mul64(t2l,t2h,ql,qh); /* t2=(BN_ULLONG)d1*q; */

			t3t=LBITS(d0); t3h=HBITS(d0);
			mul64(t3t,t3h,ql,qh); /* t3=t1-(BN_ULLONG)q*d0; */
			t3l=(t1l-t3t)&BN_MASK2;
			if (t3l > t1l) t3h++;
			t3h=(t1h-t3h)&BN_MASK2;

			/*if ((t3>>BN_BITS2) ||
				(t2 <= ((t3<<BN_BITS2)+wnump[-2])))
				break; */
			if (t3h) break;
			if (t2h < t3l) break;
			if ((t2h == t3l) && (t2l <= wnump[-2])) break;

d287 3
d293 2
d327 32
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a59 1
#include <openssl/bn.h>
a62 1

d65 6
a70 2
int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, const BIGNUM *d,
	   BN_CTX *ctx)
a72 1
	int ret = 0;
a74 2
	bn_check_top(m);
	bn_check_top(d);
d89 3
a91 6
	BN_CTX_start(ctx);
	D = BN_CTX_get(ctx);
	if (dv == NULL) dv = BN_CTX_get(ctx);
	if (rem == NULL) rem = BN_CTX_get(ctx);
	if (D == NULL || dv == NULL || rem == NULL)
		goto end;
d95 2
a96 2
	if (BN_copy(D,d) == NULL) goto end;
	if (BN_copy(rem,m) == NULL) goto end;
a100 1
	bn_wexpand(dv,1);
d103 1
a103 1
	if (!BN_lshift(D,D,nm-nd)) goto end;
d106 1
a106 1
		if (!BN_lshift1(dv,dv)) goto end;
d110 1
a110 1
			if (!BN_usub(rem,rem,D)) goto end;
d113 1
a113 1
		if (!BN_rshift1(D,D)) goto end;
d117 1
a117 4
	ret = 1;
 end:
	BN_CTX_end(ctx);
	return(ret);
d122 6
a127 37
#if !defined(OPENSSL_NO_ASM) && !defined(OPENSSL_NO_INLINE_ASM) \
    && !defined(PEDANTIC) && !defined(BN_DIV3W)
# if defined(__GNUC__) && __GNUC__>=2
#  if defined(__i386) || defined (__i386__)
   /*
    * There were two reasons for implementing this template:
    * - GNU C generates a call to a function (__udivdi3 to be exact)
    *   in reply to ((((BN_ULLONG)n0)<<BN_BITS2)|n1)/d0 (I fail to
    *   understand why...);
    * - divl doesn't only calculate quotient, but also leaves
    *   remainder in %edx which we can definitely use here:-)
    *
    *					<appro@@fy.chalmers.se>
    */
#  define bn_div_words(n0,n1,d0)		\
	({  asm volatile (			\
		"divl	%4"			\
		: "=a"(q), "=d"(rem)		\
		: "a"(n1), "d"(n0), "g"(d0)	\
		: "cc");			\
	    q;					\
	})
#  define REMAINDER_IS_ALREADY_CALCULATED
#  endif /* __<cpu> */
# endif /* __GNUC__ */
#endif /* OPENSSL_NO_ASM */


/* BN_div computes  dv := num / divisor,  rounding towards zero, and sets up
 * rm  such that  dv*divisor + rm = num  holds.
 * Thus:
 *     dv->neg == num->neg ^ divisor->neg  (unless the result is zero)
 *     rm->neg == num->neg                 (unless the remainder is zero)
 * If 'dv' or 'rm' is NULL, the respective value is not returned.
 */
int BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,
	   BN_CTX *ctx)
a134 3
	bn_check_top(num);
	bn_check_top(divisor);

d149 4
a152 4
	BN_CTX_start(ctx);
	tmp=BN_CTX_get(ctx);
	snum=BN_CTX_get(ctx);
	sdiv=BN_CTX_get(ctx);
d154 1
a154 1
		res=BN_CTX_get(ctx);
a155 2
	if (sdiv == NULL || res == NULL) goto err;
	tmp->neg=0;
d159 1
a159 1
	if (!(BN_lshift(sdiv,divisor,norm_shift))) goto err;
d162 1
a162 1
	if (!(BN_lshift(snum,num,norm_shift))) goto err;
a170 1
	BN_init(&wnum);
d173 2
a174 1
	wnum.dmax= snum->dmax+1; /* a bit of a lie */
d186 1
a187 1
	res->top=loop;
d195 1
a195 1
		if (!BN_usub(&wnum,&wnum,sdiv)) goto err;
a200 2
	if (res->top == 0)
		res->neg = 0;
d205 2
a206 6
		BN_ULONG q,l0;
#if defined(BN_DIV3W) && !defined(OPENSSL_NO_ASM)
		BN_ULONG bn_div_3_words(BN_ULONG*,BN_ULONG,BN_ULONG);
		q=bn_div_3_words(wnump,d1,d0);
#else
		BN_ULONG n0,n1,rem=0;
d208 1
d213 7
a219 1
		else 			/* n0 < d0 */
a220 16
#ifdef BN_LLONG
			BN_ULLONG t2;

#if defined(BN_LLONG) && defined(BN_DIV2W) && !defined(bn_div_words)
			q=(BN_ULONG)(((((BN_ULLONG)n0)<<BN_BITS2)|n1)/d0);
#else
			q=bn_div_words(n0,n1,d0);
#endif

#ifndef REMAINDER_IS_ALREADY_CALCULATED
			/*
			 * rem doesn't have to be BN_ULLONG. The least we
			 * know it's less that d0, isn't it?
			 */
			rem=(n1-q*d0)&BN_MASK2;
#endif
d222 6
a227 21

			for (;;)
				{
				if (t2 <= ((((BN_ULLONG)rem)<<BN_BITS2)|wnump[-2]))
					break;
				q--;
				rem += d0;
				if (rem < d0) break; /* don't let rem overflow */
				t2 -= d1;
				}
#else /* !BN_LLONG */
			BN_ULONG t2l,t2h,ql,qh;

			q=bn_div_words(n0,n1,d0);
#ifndef REMAINDER_IS_ALREADY_CALCULATED
			rem=(n1-q*d0)&BN_MASK2;
#endif

#ifdef BN_UMULT_HIGH
			t2l = d1 * q;
			t2h = BN_UMULT_HIGH(d1,q);
d229 5
a236 1
#endif
d238 14
a251 11
			for (;;)
				{
				if ((t2h < rem) ||
					((t2h == rem) && (t2l <= wnump[-2])))
					break;
				q--;
				rem += d0;
				if (rem < d0) break; /* don't let rem overflow */
				if (t2l < d1) t2h--; t2l -= d1;
				}
#endif /* !BN_LLONG */
d253 2
a254 2
#endif /* !BN_DIV3W */

a255 1
		wnum.d--; wnum.top++;
d262 1
a262 1
		if (!BN_sub(&wnum,&wnum,tmp)) goto err;
d270 1
a270 1
			if (!BN_add(&wnum,&wnum,sdiv)) goto err;
a277 4
		/* Keep a copy of the neg flag in num because if rm==num
		 * BN_rshift() will overwrite it.
		 */
		int neg = num->neg;
d279 1
a279 2
		if (!BN_is_zero(rm))
			rm->neg = neg;
a280 1
	BN_CTX_end(ctx);
a282 1
	BN_CTX_end(ctx);
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@a152 14
#  elif defined(__x86_64) && defined(SIXTY_FOUR_BIT_LONG)
   /*
    * Same story here, but it's 128-bit by 64-bit division. Wow!
    *					<appro@@fy.chalmers.se>
    */
#  define bn_div_words(n0,n1,d0)		\
	({  asm volatile (			\
		"divq	%4"			\
		: "=a"(q), "=d"(rem)		\
		: "a"(n1), "d"(n0), "g"(d0)	\
		: "cc");			\
	    q;					\
	})
#  define REMAINDER_IS_ALREADY_CALCULATED
a270 5
#ifdef BN_DEBUG_LEVITTE
			fprintf(stderr,"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\
X) -> 0x%08X\n",
				n0, n1, d0, q);
#endif
a294 5
#ifdef BN_DEBUG_LEVITTE
			fprintf(stderr,"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\
X) -> 0x%08X\n",
				n0, n1, d0, q);
#endif
d299 1
a299 3
#if defined(BN_UMULT_LOHI)
			BN_UMULT_LOHI(t2l,t2h,d1,q);
#elif defined(BN_UMULT_HIGH)
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@d172 2
a173 2
/* BN_div[_no_branch] computes  dv := num / divisor,  rounding towards
 * zero, and sets up rm  such that  dv*divisor + rm = num  holds.
a178 2
static int BN_div_no_branch(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num,
        const BIGNUM *divisor, BN_CTX *ctx);
d182 1
a182 1
	int norm_shift,i,loop;
a187 7
	if ((BN_get_flags(num, BN_FLG_CONSTTIME) != 0) || (BN_get_flags(divisor, BN_FLG_CONSTTIME) != 0))
		{
		return BN_div_no_branch(dv, rm, num, divisor, ctx);
		}

	bn_check_top(dv);
	bn_check_top(rm);
d213 1
d225 1
d229 4
a232 5
	wnum.neg   = 0;
	wnum.d     = &(snum->d[loop]);
	wnum.top   = div_n;
	/* only needed when BN_ucmp messes up the values between top and max */
	wnum.dmax  = snum->dmax - loop; /* so we don't step out of bounds */
d235 1
a235 1
	/* div_n=sdiv->top; */
d253 1
a253 5
		/* If BN_DEBUG_RAND is defined BN_ucmp changes (via
		 * bn_pollute) the const bignum arguments =>
		 * clean the values between top and max again */
		bn_clear_top2max(&wnum);
		bn_sub_words(wnum.d, wnum.d, sdiv->d, div_n);
d255 1
a258 2
	/* if res->top == 0 then clear the neg value otherwise decrease
	 * the resp pointer */
d261 1
a261 2
	else
		resp--;
d263 1
a263 1
	for (i=0; i<loop-1; i++, wnump--, resp--)
a265 3
		/* the first part of the loop uses the top two words of
		 * snum and sdiv to calculate a BN_ULONG q such that
		 * | wnum - sdiv * q | < sdiv */
d349 1
d351 3
a353 154
		wnum.d--;
		/* ingore top values of the bignums just sub the two 
		 * BN_ULONG arrays with bn_sub_words */
		if (bn_sub_words(wnum.d, wnum.d, tmp->d, div_n+1))
			{
			/* Note: As we have considered only the leading
			 * two BN_ULONGs in the calculation of q, sdiv * q
			 * might be greater than wnum (but then (q-1) * sdiv
			 * is less or equal than wnum)
			 */
			q--;
			if (bn_add_words(wnum.d, wnum.d, sdiv->d, div_n))
				/* we can't have an overflow here (assuming
				 * that q != 0, but if q == 0 then tmp is
				 * zero anyway) */
				(*wnump)++;
			}
		/* store part of the result */
		*resp = q;
		}
	bn_correct_top(snum);
	if (rm != NULL)
		{
		/* Keep a copy of the neg flag in num because if rm==num
		 * BN_rshift() will overwrite it.
		 */
		int neg = num->neg;
		BN_rshift(rm,snum,norm_shift);
		if (!BN_is_zero(rm))
			rm->neg = neg;
		bn_check_top(rm);
		}
	BN_CTX_end(ctx);
	return(1);
err:
	bn_check_top(rm);
	BN_CTX_end(ctx);
	return(0);
	}


/* BN_div_no_branch is a special version of BN_div. It does not contain
 * branches that may leak sensitive information.
 */
static int BN_div_no_branch(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, 
	const BIGNUM *divisor, BN_CTX *ctx)
	{
	int norm_shift,i,loop;
	BIGNUM *tmp,wnum,*snum,*sdiv,*res;
	BN_ULONG *resp,*wnump;
	BN_ULONG d0,d1;
	int num_n,div_n;

	bn_check_top(dv);
	bn_check_top(rm);
	bn_check_top(num);
	bn_check_top(divisor);

	if (BN_is_zero(divisor))
		{
		BNerr(BN_F_BN_DIV_NO_BRANCH,BN_R_DIV_BY_ZERO);
		return(0);
		}

	BN_CTX_start(ctx);
	tmp=BN_CTX_get(ctx);
	snum=BN_CTX_get(ctx);
	sdiv=BN_CTX_get(ctx);
	if (dv == NULL)
		res=BN_CTX_get(ctx);
	else	res=dv;
	if (sdiv == NULL || res == NULL) goto err;

	/* First we normalise the numbers */
	norm_shift=BN_BITS2-((BN_num_bits(divisor))%BN_BITS2);
	if (!(BN_lshift(sdiv,divisor,norm_shift))) goto err;
	sdiv->neg=0;
	norm_shift+=BN_BITS2;
	if (!(BN_lshift(snum,num,norm_shift))) goto err;
	snum->neg=0;

	/* Since we don't know whether snum is larger than sdiv,
	 * we pad snum with enough zeroes without changing its
	 * value. 
	 */
	if (snum->top <= sdiv->top+1) 
		{
		if (bn_wexpand(snum, sdiv->top + 2) == NULL) goto err;
		for (i = snum->top; i < sdiv->top + 2; i++) snum->d[i] = 0;
		snum->top = sdiv->top + 2;
		}
	else
		{
		if (bn_wexpand(snum, snum->top + 1) == NULL) goto err;
		snum->d[snum->top] = 0;
		snum->top ++;
		}

	div_n=sdiv->top;
	num_n=snum->top;
	loop=num_n-div_n;
	/* Lets setup a 'window' into snum
	 * This is the part that corresponds to the current
	 * 'area' being divided */
	wnum.neg   = 0;
	wnum.d     = &(snum->d[loop]);
	wnum.top   = div_n;
	/* only needed when BN_ucmp messes up the values between top and max */
	wnum.dmax  = snum->dmax - loop; /* so we don't step out of bounds */

	/* Get the top 2 words of sdiv */
	/* div_n=sdiv->top; */
	d0=sdiv->d[div_n-1];
	d1=(div_n == 1)?0:sdiv->d[div_n-2];

	/* pointer to the 'top' of snum */
	wnump= &(snum->d[num_n-1]);

	/* Setup to 'res' */
	res->neg= (num->neg^divisor->neg);
	if (!bn_wexpand(res,(loop+1))) goto err;
	res->top=loop-1;
	resp= &(res->d[loop-1]);

	/* space for temp */
	if (!bn_wexpand(tmp,(div_n+1))) goto err;

	/* if res->top == 0 then clear the neg value otherwise decrease
	 * the resp pointer */
	if (res->top == 0)
		res->neg = 0;
	else
		resp--;

	for (i=0; i<loop-1; i++, wnump--, resp--)
		{
		BN_ULONG q,l0;
		/* the first part of the loop uses the top two words of
		 * snum and sdiv to calculate a BN_ULONG q such that
		 * | wnum - sdiv * q | < sdiv */
#if defined(BN_DIV3W) && !defined(OPENSSL_NO_ASM)
		BN_ULONG bn_div_3_words(BN_ULONG*,BN_ULONG,BN_ULONG);
		q=bn_div_3_words(wnump,d1,d0);
#else
		BN_ULONG n0,n1,rem=0;

		n0=wnump[0];
		n1=wnump[-1];
		if (n0 == d0)
			q=BN_MASK2;
		else 			/* n0 < d0 */
			{
#ifdef BN_LLONG
			BN_ULLONG t2;
d355 2
a356 10
#if defined(BN_LLONG) && defined(BN_DIV2W) && !defined(bn_div_words)
			q=(BN_ULONG)(((((BN_ULLONG)n0)<<BN_BITS2)|n1)/d0);
#else
			q=bn_div_words(n0,n1,d0);
#ifdef BN_DEBUG_LEVITTE
			fprintf(stderr,"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\
X) -> 0x%08X\n",
				n0, n1, d0, q);
#endif
#endif
d358 1
a358 8
#ifndef REMAINDER_IS_ALREADY_CALCULATED
			/*
			 * rem doesn't have to be BN_ULLONG. The least we
			 * know it's less that d0, isn't it?
			 */
			rem=(n1-q*d0)&BN_MASK2;
#endif
			t2=(BN_ULLONG)d1*q;
d360 1
a360 53
			for (;;)
				{
				if (t2 <= ((((BN_ULLONG)rem)<<BN_BITS2)|wnump[-2]))
					break;
				q--;
				rem += d0;
				if (rem < d0) break; /* don't let rem overflow */
				t2 -= d1;
				}
#else /* !BN_LLONG */
			BN_ULONG t2l,t2h,ql,qh;

			q=bn_div_words(n0,n1,d0);
#ifdef BN_DEBUG_LEVITTE
			fprintf(stderr,"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\
X) -> 0x%08X\n",
				n0, n1, d0, q);
#endif
#ifndef REMAINDER_IS_ALREADY_CALCULATED
			rem=(n1-q*d0)&BN_MASK2;
#endif

#if defined(BN_UMULT_LOHI)
			BN_UMULT_LOHI(t2l,t2h,d1,q);
#elif defined(BN_UMULT_HIGH)
			t2l = d1 * q;
			t2h = BN_UMULT_HIGH(d1,q);
#else
			t2l=LBITS(d1); t2h=HBITS(d1);
			ql =LBITS(q);  qh =HBITS(q);
			mul64(t2l,t2h,ql,qh); /* t2=(BN_ULLONG)d1*q; */
#endif

			for (;;)
				{
				if ((t2h < rem) ||
					((t2h == rem) && (t2l <= wnump[-2])))
					break;
				q--;
				rem += d0;
				if (rem < d0) break; /* don't let rem overflow */
				if (t2l < d1) t2h--; t2l -= d1;
				}
#endif /* !BN_LLONG */
			}
#endif /* !BN_DIV3W */

		l0=bn_mul_words(tmp->d,sdiv->d,div_n,q);
		tmp->d[div_n]=l0;
		wnum.d--;
		/* ingore top values of the bignums just sub the two 
		 * BN_ULONG arrays with bn_sub_words */
		if (bn_sub_words(wnum.d, wnum.d, tmp->d, div_n+1))
a361 5
			/* Note: As we have considered only the leading
			 * two BN_ULONGs in the calculation of q, sdiv * q
			 * might be greater than wnum (but then (q-1) * sdiv
			 * is less or equal than wnum)
			 */
d363 3
a365 5
			if (bn_add_words(wnum.d, wnum.d, sdiv->d, div_n))
				/* we can't have an overflow here (assuming
				 * that q != 0, but if q == 0 then tmp is
				 * zero anyway) */
				(*wnump)++;
d367 2
a368 2
		/* store part of the result */
		*resp = q;
a369 1
	bn_correct_top(snum);
a378 1
		bn_check_top(rm);
a379 1
	bn_correct_top(res);
a382 1
	bn_check_top(rm);
@


1.1.1.5
log
@import openssl-0.9.8j
@
text
@a189 11
	/* Invalid zero-padding would have particularly bad consequences
	 * in the case of 'num', so don't just rely on bn_check_top() for this one
	 * (bn_check_top() works only for BN_DEBUG builds) */
	if (num->top > 0 && num->d[num->top - 1] == 0)
		{
		BNerr(BN_F_BN_DIV,BN_R_NOT_INITIALIZED);
		return 0;
		}

	bn_check_top(num);

d197 1
a197 1
	/* bn_check_top(num); */ /* 'num' has been checked already */
d422 1
a422 1
	/* bn_check_top(num); */ /* 'num' has been checked in BN_div() */
@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@d105 1
a105 1
	if(bn_wexpand(dv,1) == NULL) goto end;
d232 1
a232 2
	if (sdiv == NULL || res == NULL || tmp == NULL || snum == NULL)
		goto err;
d339 1
a339 1
			BN_ULONG t2l,t2h;
a356 2
			{
			BN_ULONG ql, qh;
a359 1
			}
d563 1
a563 1
			BN_ULONG t2l,t2h;
a580 2
			{
			BN_ULONG ql, qh;
a583 1
			}
@


1.1.1.7
log
@import OpenSSL-1.0.1c
@
text
@d172 1
a172 1
/* BN_div computes  dv := num / divisor,  rounding towards
d179 2
a188 1
	int no_branch=0;
d203 1
a203 1
		no_branch=1;
d217 1
a217 1
	if (!no_branch && BN_ucmp(num,divisor) < 0)
d242 28
d271 1
a271 1
	if (no_branch)
d273 85
a357 5
		/* Since we don't know whether snum is larger than sdiv,
		 * we pad snum with enough zeroes without changing its
		 * value. 
		 */
		if (snum->top <= sdiv->top+1) 
d359 4
a362 3
			if (bn_wexpand(snum, sdiv->top + 2) == NULL) goto err;
			for (i = snum->top; i < sdiv->top + 2; i++) snum->d[i] = 0;
			snum->top = sdiv->top + 2;
d364 22
a385 1
		else
d387 11
a397 3
			if (bn_wexpand(snum, snum->top + 1) == NULL) goto err;
			snum->d[snum->top] = 0;
			snum->top ++;
d399 79
d503 1
a503 1
	res->top=loop-no_branch;
a508 15
	if (!no_branch)
		{
		if (BN_ucmp(&wnum,sdiv) >= 0)
			{
			/* If BN_DEBUG_RAND is defined BN_ucmp changes (via
			 * bn_pollute) the const bignum arguments =>
			 * clean the values between top and max again */
			bn_clear_top2max(&wnum);
			bn_sub_words(wnum.d, wnum.d, sdiv->d, div_n);
			*resp=1;
			}
		else
			res->top--;
		}

d641 1
a641 1
	if (no_branch)	bn_correct_top(res);
d649 1
@


1.1.1.8
log
@Import OpenSSL 1.0.1g
@
text
@a143 1
#undef bn_div_words
a157 1
#  undef bn_div_words
@


