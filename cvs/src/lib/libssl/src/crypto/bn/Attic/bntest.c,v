head	1.15;
access;
symbols
	butholakala:1.14
	openssl_1_0_1_g:1.1.1.10
	OPENBSD_5_5:1.14.0.8
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	openssl_1_0_1_c:1.1.1.10
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	openssl_1_0_0_f:1.1.1.9
	openssl_1_0_0_e:1.1.1.9
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	openssh_1_0_0_a:1.1.1.9
	OPENBSD_4_8:1.12.0.8
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.4
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	openssl_0_9_8_k:1.1.1.8
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	openssl_0_9_8_j:1.1.1.7
	openssl_0_9_8_h:1.1.1.7
	pre_openssl_0_9_8h:1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	openssl_0_9_7j:1.1.1.6
	openssl:1.1.1
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2014.04.15.18.08.41;	author miod;	state dead;
branches;
next	1.14;

1.14
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.06.12.17.49;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.27.05.07.01;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.29.05.39.19;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.17.21.31.34;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.12.02.18.36;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.10.16.31.54;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.02.59;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.33;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.09.21;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.46;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.00;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.36.45;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.34.45;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.05;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.06.27.05.05.31;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.04.06.06.30.01;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.04;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2012.10.13.21.23.37;	author djm;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Moved to regress/lib/libcrypto.
@
text
@/* crypto/bn/bntest.c */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 *
 * Portions of the attached software ("Contribution") are developed by 
 * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.
 *
 * The Contribution is licensed pursuant to the Eric Young open source
 * license provided above.
 *
 * The binary polynomial arithmetic software is originally written by 
 * Sheueling Chang Shantz and Douglas Stebila of Sun Microsystems Laboratories.
 *
 */

/* Until the key-gen callbacks are modified to use newer prototypes, we allow
 * deprecated functions for openssl-internal code */
#ifdef OPENSSL_NO_DEPRECATED
#undef OPENSSL_NO_DEPRECATED
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "e_os.h"

#include <openssl/bio.h>
#include <openssl/bn.h>
#include <openssl/rand.h>
#include <openssl/x509.h>
#include <openssl/err.h>

const int num0 = 100; /* number of tests */
const int num1 = 50;  /* additional tests for some functions */
const int num2 = 5;   /* number of tests for slow functions */

int test_add(BIO *bp);
int test_sub(BIO *bp);
int test_lshift1(BIO *bp);
int test_lshift(BIO *bp,BN_CTX *ctx,BIGNUM *a_);
int test_rshift1(BIO *bp);
int test_rshift(BIO *bp,BN_CTX *ctx);
int test_div(BIO *bp,BN_CTX *ctx);
int test_div_word(BIO *bp);
int test_div_recp(BIO *bp,BN_CTX *ctx);
int test_mul(BIO *bp);
int test_sqr(BIO *bp,BN_CTX *ctx);
int test_mont(BIO *bp,BN_CTX *ctx);
int test_mod(BIO *bp,BN_CTX *ctx);
int test_mod_mul(BIO *bp,BN_CTX *ctx);
int test_mod_exp(BIO *bp,BN_CTX *ctx);
int test_mod_exp_mont_consttime(BIO *bp,BN_CTX *ctx);
int test_exp(BIO *bp,BN_CTX *ctx);
int test_gf2m_add(BIO *bp);
int test_gf2m_mod(BIO *bp);
int test_gf2m_mod_mul(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_sqr(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_inv(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_div(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_exp(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_sqrt(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_solve_quad(BIO *bp,BN_CTX *ctx);
int test_kron(BIO *bp,BN_CTX *ctx);
int test_sqrt(BIO *bp,BN_CTX *ctx);
int rand_neg(void);
static int results=0;

static unsigned char lst[]="\xC6\x4F\x43\x04\x2A\xEA\xCA\x6E\x58\x36\x80\x5B\xE8\xC9"
"\x9B\x04\x5D\x48\x36\xC2\xFD\x16\xC9\x64\xF0";

static const char rnd_seed[] = "string to make the random number generator think it has entropy";

static void message(BIO *out, char *m)
	{
	fprintf(stderr, "test %s\n", m);
	BIO_puts(out, "print \"test ");
	BIO_puts(out, m);
	BIO_puts(out, "\\n\"\n");
	}

int main(int argc, char *argv[])
	{
	BN_CTX *ctx;
	BIO *out;
	char *outfile=NULL;

	results = 0;

	RAND_seed(rnd_seed, sizeof rnd_seed); /* or BN_generate_prime may fail */

	argc--;
	argv++;
	while (argc >= 1)
		{
		if (strcmp(*argv,"-results") == 0)
			results=1;
		else if (strcmp(*argv,"-out") == 0)
			{
			if (--argc < 1) break;
			outfile= *(++argv);
			}
		argc--;
		argv++;
		}


	ctx=BN_CTX_new();
	if (ctx == NULL) EXIT(1);

	out=BIO_new(BIO_s_file());
	if (out == NULL) EXIT(1);
	if (outfile == NULL)
		{
		BIO_set_fp(out,stdout,BIO_NOCLOSE);
		}
	else
		{
		if (!BIO_write_filename(out,outfile))
			{
			perror(outfile);
			EXIT(1);
			}
		}

	if (!results)
		BIO_puts(out,"obase=16\nibase=16\n");

	message(out,"BN_add");
	if (!test_add(out)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_sub");
	if (!test_sub(out)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_lshift1");
	if (!test_lshift1(out)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_lshift (fixed)");
	if (!test_lshift(out,ctx,BN_bin2bn(lst,sizeof(lst)-1,NULL)))
	    goto err;
	(void)BIO_flush(out);

	message(out,"BN_lshift");
	if (!test_lshift(out,ctx,NULL)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_rshift1");
	if (!test_rshift1(out)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_rshift");
	if (!test_rshift(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_sqr");
	if (!test_sqr(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_mul");
	if (!test_mul(out)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_div");
	if (!test_div(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_div_word");
	if (!test_div_word(out)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_div_recp");
	if (!test_div_recp(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_mod");
	if (!test_mod(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_mod_mul");
	if (!test_mod_mul(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_mont");
	if (!test_mont(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_mod_exp");
	if (!test_mod_exp(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_mod_exp_mont_consttime");
	if (!test_mod_exp_mont_consttime(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_exp");
	if (!test_exp(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_kronecker");
	if (!test_kron(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_mod_sqrt");
	if (!test_sqrt(out,ctx)) goto err;
	(void)BIO_flush(out);
#ifndef OPENSSL_NO_EC2M
	message(out,"BN_GF2m_add");
	if (!test_gf2m_add(out)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod");
	if (!test_gf2m_mod(out)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod_mul");
	if (!test_gf2m_mod_mul(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod_sqr");
	if (!test_gf2m_mod_sqr(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod_inv");
	if (!test_gf2m_mod_inv(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod_div");
	if (!test_gf2m_mod_div(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod_exp");
	if (!test_gf2m_mod_exp(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod_sqrt");
	if (!test_gf2m_mod_sqrt(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod_solve_quad");
	if (!test_gf2m_mod_solve_quad(out,ctx)) goto err;
	(void)BIO_flush(out);
#endif
	BN_CTX_free(ctx);
	BIO_free(out);

/**/
	EXIT(0);
err:
	BIO_puts(out,"1\n"); /* make sure the Perl script fed by bc notices
	                      * the failure, see test_bn in test/Makefile.ssl*/
	(void)BIO_flush(out);
	ERR_load_crypto_strings();
	ERR_print_errors_fp(stderr);
	EXIT(1);
	return(1);
	}

int test_add(BIO *bp)
	{
	BIGNUM a,b,c;
	int i;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);

	BN_bntest_rand(&a,512,0,0);
	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(&b,450+i,0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_add(&c,&a,&b);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," + ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
			}
		a.neg=!a.neg;
		b.neg=!b.neg;
		BN_add(&c,&c,&b);
		BN_add(&c,&c,&a);
		if(!BN_is_zero(&c))
		    {
		    fprintf(stderr,"Add test failed!\n");
		    return 0;
		    }
		}
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	return(1);
	}

int test_sub(BIO *bp)
	{
	BIGNUM a,b,c;
	int i;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);

	for (i=0; i<num0+num1; i++)
		{
		if (i < num1)
			{
			BN_bntest_rand(&a,512,0,0);
			BN_copy(&b,&a);
			if (BN_set_bit(&a,i)==0) return(0);
			BN_add_word(&b,i);
			}
		else
			{
			BN_bntest_rand(&b,400+i-num1,0,0);
			a.neg=rand_neg();
			b.neg=rand_neg();
			}
		BN_sub(&c,&a,&b);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," - ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
			}
		BN_add(&c,&c,&b);
		BN_sub(&c,&c,&a);
		if(!BN_is_zero(&c))
		    {
		    fprintf(stderr,"Subtract test failed!\n");
		    return 0;
		    }
		}
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	return(1);
	}

int test_div(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM a,b,c,d,e;
	int i;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);

	for (i=0; i<num0+num1; i++)
		{
		if (i < num1)
			{
			BN_bntest_rand(&a,400,0,0);
			BN_copy(&b,&a);
			BN_lshift(&a,&a,i);
			BN_add_word(&a,i);
			}
		else
			BN_bntest_rand(&b,50+3*(i-num1),0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_div(&d,&c,&a,&b,ctx);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," / ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&d);
			BIO_puts(bp,"\n");

			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," % ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
			}
		BN_mul(&e,&d,&b,ctx);
		BN_add(&d,&e,&c);
		BN_sub(&d,&d,&a);
		if(!BN_is_zero(&d))
		    {
		    fprintf(stderr,"Division test failed!\n");
		    return 0;
		    }
		}
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	return(1);
	}

static void print_word(BIO *bp,BN_ULONG w)
	{
#ifdef SIXTY_FOUR_BIT
	if (sizeof(w) > sizeof(unsigned long))
		{
		unsigned long	h=(unsigned long)(w>>32),
				l=(unsigned long)(w);

		if (h)	BIO_printf(bp,"%lX%08lX",h,l);
		else	BIO_printf(bp,"%lX",l);
		return;
		}
#endif
	BIO_printf(bp,BN_HEX_FMT1,w);
	}

int test_div_word(BIO *bp)
	{
	BIGNUM   a,b;
	BN_ULONG r,s;
	int i;

	BN_init(&a);
	BN_init(&b);

	for (i=0; i<num0; i++)
		{
		do {
			BN_bntest_rand(&a,512,-1,0);
			BN_bntest_rand(&b,BN_BITS2,-1,0);
			s = b.d[0];
		} while (!s);

		BN_copy(&b, &a);
		r = BN_div_word(&b, s);

		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," / ");
				print_word(bp,s);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&b);
			BIO_puts(bp,"\n");

			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," % ");
				print_word(bp,s);
				BIO_puts(bp," - ");
				}
			print_word(bp,r);
			BIO_puts(bp,"\n");
			}
		BN_mul_word(&b,s);
		BN_add_word(&b,r);
		BN_sub(&b,&a,&b);
		if(!BN_is_zero(&b))
		    {
		    fprintf(stderr,"Division (word) test failed!\n");
		    return 0;
		    }
		}
	BN_free(&a);
	BN_free(&b);
	return(1);
	}

int test_div_recp(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM a,b,c,d,e;
	BN_RECP_CTX recp;
	int i;

	BN_RECP_CTX_init(&recp);
	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);

	for (i=0; i<num0+num1; i++)
		{
		if (i < num1)
			{
			BN_bntest_rand(&a,400,0,0);
			BN_copy(&b,&a);
			BN_lshift(&a,&a,i);
			BN_add_word(&a,i);
			}
		else
			BN_bntest_rand(&b,50+3*(i-num1),0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_RECP_CTX_set(&recp,&b,ctx);
		BN_div_recp(&d,&c,&a,&recp,ctx);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," / ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&d);
			BIO_puts(bp,"\n");

			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," % ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
			}
		BN_mul(&e,&d,&b,ctx);
		BN_add(&d,&e,&c);
		BN_sub(&d,&d,&a);
		if(!BN_is_zero(&d))
		    {
		    fprintf(stderr,"Reciprocal division test failed!\n");
		    fprintf(stderr,"a=");
		    BN_print_fp(stderr,&a);
		    fprintf(stderr,"\nb=");
		    BN_print_fp(stderr,&b);
		    fprintf(stderr,"\n");
		    return 0;
		    }
		}
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	BN_RECP_CTX_free(&recp);
	return(1);
	}

int test_mul(BIO *bp)
	{
	BIGNUM a,b,c,d,e;
	int i;
	BN_CTX *ctx;

	ctx = BN_CTX_new();
	if (ctx == NULL) EXIT(1);
	
	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);

	for (i=0; i<num0+num1; i++)
		{
		if (i <= num1)
			{
			BN_bntest_rand(&a,100,0,0);
			BN_bntest_rand(&b,100,0,0);
			}
		else
			BN_bntest_rand(&b,i-num1,0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_mul(&c,&a,&b,ctx);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," * ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
			}
		BN_div(&d,&e,&c,&a,ctx);
		BN_sub(&d,&d,&b);
		if(!BN_is_zero(&d) || !BN_is_zero(&e))
		    {
		    fprintf(stderr,"Multiplication test failed!\n");
		    return 0;
		    }
		}
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	BN_CTX_free(ctx);
	return(1);
	}

int test_sqr(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM a,c,d,e;
	int i;

	BN_init(&a);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(&a,40+i*10,0,0);
		a.neg=rand_neg();
		BN_sqr(&c,&a,ctx);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," * ");
				BN_print(bp,&a);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
			}
		BN_div(&d,&e,&c,&a,ctx);
		BN_sub(&d,&d,&a);
		if(!BN_is_zero(&d) || !BN_is_zero(&e))
		    {
		    fprintf(stderr,"Square test failed!\n");
		    return 0;
		    }
		}
	BN_free(&a);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	return(1);
	}

int test_mont(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM a,b,c,d,A,B;
	BIGNUM n;
	int i;
	BN_MONT_CTX *mont;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&A);
	BN_init(&B);
	BN_init(&n);

	mont=BN_MONT_CTX_new();
	if (mont == NULL)
		return 0;

	BN_bntest_rand(&a,100,0,0); /**/
	BN_bntest_rand(&b,100,0,0); /**/
	for (i=0; i<num2; i++)
		{
		int bits = (200*(i+1))/num2;

		if (bits == 0)
			continue;
		BN_bntest_rand(&n,bits,0,1);
		BN_MONT_CTX_set(mont,&n,ctx);

		BN_nnmod(&a,&a,&n,ctx);
		BN_nnmod(&b,&b,&n,ctx);

		BN_to_montgomery(&A,&a,mont,ctx);
		BN_to_montgomery(&B,&b,mont,ctx);

		BN_mod_mul_montgomery(&c,&A,&B,mont,ctx);/**/
		BN_from_montgomery(&A,&c,mont,ctx);/**/
		if (bp != NULL)
			{
			if (!results)
				{
#ifdef undef
fprintf(stderr,"%d * %d %% %d\n",
BN_num_bits(&a),
BN_num_bits(&b),
BN_num_bits(mont->N));
#endif
				BN_print(bp,&a);
				BIO_puts(bp," * ");
				BN_print(bp,&b);
				BIO_puts(bp," % ");
				BN_print(bp,&(mont->N));
				BIO_puts(bp," - ");
				}
			BN_print(bp,&A);
			BIO_puts(bp,"\n");
			}
		BN_mod_mul(&d,&a,&b,&n,ctx);
		BN_sub(&d,&d,&A);
		if(!BN_is_zero(&d))
		    {
		    fprintf(stderr,"Montgomery multiplication test failed!\n");
		    return 0;
		    }
		}
	BN_MONT_CTX_free(mont);
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&A);
	BN_free(&B);
	BN_free(&n);
	return(1);
	}

int test_mod(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM *a,*b,*c,*d,*e;
	int i;

	a=BN_new();
	b=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();

	BN_bntest_rand(a,1024,0,0); /**/
	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(b,450+i*10,0,0); /**/
		a->neg=rand_neg();
		b->neg=rand_neg();
		BN_mod(c,a,b,ctx);/**/
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," % ");
				BN_print(bp,b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,c);
			BIO_puts(bp,"\n");
			}
		BN_div(d,e,a,b,ctx);
		BN_sub(e,e,c);
		if(!BN_is_zero(e))
		    {
		    fprintf(stderr,"Modulo test failed!\n");
		    return 0;
		    }
		}
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return(1);
	}

int test_mod_mul(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM *a,*b,*c,*d,*e;
	int i,j;

	a=BN_new();
	b=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();

	for (j=0; j<3; j++) {
	BN_bntest_rand(c,1024,0,0); /**/
	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a,475+i*10,0,0); /**/
		BN_bntest_rand(b,425+i*11,0,0); /**/
		a->neg=rand_neg();
		b->neg=rand_neg();
		if (!BN_mod_mul(e,a,b,c,ctx))
			{
			unsigned long l;

			while ((l=ERR_get_error()))
				fprintf(stderr,"ERROR:%s\n",
					ERR_error_string(l,NULL));
			EXIT(1);
			}
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," * ");
				BN_print(bp,b);
				BIO_puts(bp," % ");
				BN_print(bp,c);
				if ((a->neg ^ b->neg) && !BN_is_zero(e))
					{
					/* If  (a*b) % c  is negative,  c  must be added
					 * in order to obtain the normalized remainder
					 * (new with OpenSSL 0.9.7, previous versions of
					 * BN_mod_mul could generate negative results)
					 */
					BIO_puts(bp," + ");
					BN_print(bp,c);
					}
				BIO_puts(bp," - ");
				}
			BN_print(bp,e);
			BIO_puts(bp,"\n");
			}
		BN_mul(d,a,b,ctx);
		BN_sub(d,d,e);
		BN_div(a,b,d,c,ctx);
		if(!BN_is_zero(b))
		    {
		    fprintf(stderr,"Modulo multiply test failed!\n");
		    ERR_print_errors_fp(stderr);
		    return 0;
		    }
		}
	}
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return(1);
	}

int test_mod_exp(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM *a,*b,*c,*d,*e;
	int i;

	a=BN_new();
	b=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();

	BN_bntest_rand(c,30,0,1); /* must be odd for montgomery */
	for (i=0; i<num2; i++)
		{
		BN_bntest_rand(a,20+i*5,0,0); /**/
		BN_bntest_rand(b,2+i,0,0); /**/

		if (!BN_mod_exp(d,a,b,c,ctx))
			return(0);

		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," ^ ");
				BN_print(bp,b);
				BIO_puts(bp," % ");
				BN_print(bp,c);
				BIO_puts(bp," - ");
				}
			BN_print(bp,d);
			BIO_puts(bp,"\n");
			}
		BN_exp(e,a,b,ctx);
		BN_sub(e,e,d);
		BN_div(a,b,e,c,ctx);
		if(!BN_is_zero(b))
		    {
		    fprintf(stderr,"Modulo exponentiation test failed!\n");
		    return 0;
		    }
		}
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return(1);
	}

int test_mod_exp_mont_consttime(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM *a,*b,*c,*d,*e;
	int i;

	a=BN_new();
	b=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();

	BN_bntest_rand(c,30,0,1); /* must be odd for montgomery */
	for (i=0; i<num2; i++)
		{
		BN_bntest_rand(a,20+i*5,0,0); /**/
		BN_bntest_rand(b,2+i,0,0); /**/

		if (!BN_mod_exp_mont_consttime(d,a,b,c,ctx,NULL))
			return(00);

		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," ^ ");
				BN_print(bp,b);
				BIO_puts(bp," % ");
				BN_print(bp,c);
				BIO_puts(bp," - ");
				}
			BN_print(bp,d);
			BIO_puts(bp,"\n");
			}
		BN_exp(e,a,b,ctx);
		BN_sub(e,e,d);
		BN_div(a,b,e,c,ctx);
		if(!BN_is_zero(b))
		    {
		    fprintf(stderr,"Modulo exponentiation test failed!\n");
		    return 0;
		    }
		}
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return(1);
	}

int test_exp(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM *a,*b,*d,*e,*one;
	int i;

	a=BN_new();
	b=BN_new();
	d=BN_new();
	e=BN_new();
	one=BN_new();
	BN_one(one);

	for (i=0; i<num2; i++)
		{
		BN_bntest_rand(a,20+i*5,0,0); /**/
		BN_bntest_rand(b,2+i,0,0); /**/

		if (BN_exp(d,a,b,ctx) <= 0)
			return(0);

		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," ^ ");
				BN_print(bp,b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,d);
			BIO_puts(bp,"\n");
			}
		BN_one(e);
		for( ; !BN_is_zero(b) ; BN_sub(b,b,one))
		    BN_mul(e,e,a,ctx);
		BN_sub(e,e,d);
		if(!BN_is_zero(e))
		    {
		    fprintf(stderr,"Exponentiation test failed!\n");
		    return 0;
		    }
		}
	BN_free(a);
	BN_free(b);
	BN_free(d);
	BN_free(e);
	BN_free(one);
	return(1);
	}
#ifndef OPENSSL_NO_EC2M
int test_gf2m_add(BIO *bp)
	{
	BIGNUM a,b,c;
	int i, ret = 0;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);

	for (i=0; i<num0; i++)
		{
		BN_rand(&a,512,0,0);
		BN_copy(&b, BN_value_one());
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_GF2m_add(&c,&a,&b);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," ^ ");
				BN_print(bp,&b);
				BIO_puts(bp," = ");
				}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
			}
#endif
		/* Test that two added values have the correct parity. */
		if((BN_is_odd(&a) && BN_is_odd(&c)) || (!BN_is_odd(&a) && !BN_is_odd(&c)))
			{
		    fprintf(stderr,"GF(2^m) addition test (a) failed!\n");
			goto err;
			}
		BN_GF2m_add(&c,&c,&c);
		/* Test that c + c = 0. */
		if(!BN_is_zero(&c))
		    {
		    fprintf(stderr,"GF(2^m) addition test (b) failed!\n");
			goto err;
		    }
		}
	ret = 1;
  err:
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	return ret;
	}

int test_gf2m_mod(BIO *bp)
	{
	BIGNUM *a,*b[2],*c,*d,*e;
	int i, j, ret = 0;
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 1024, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod(c, a, b[j]);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp," % ");
					BN_print(bp,b[j]);
					BIO_puts(bp," - ");
					BN_print(bp,c);
					BIO_puts(bp,"\n");
					}
				}
#endif
			BN_GF2m_add(d, a, c);
			BN_GF2m_mod(e, d, b[j]);
			/* Test that a + (a mod p) mod p == 0. */
			if(!BN_is_zero(e))
				{
				fprintf(stderr,"GF(2^m) modulo test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return ret;
	}

int test_gf2m_mod_mul(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d,*e,*f,*g,*h;
	int i, j, ret = 0;
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	f=BN_new();
	g=BN_new();
	h=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 1024, 0, 0);
		BN_bntest_rand(c, 1024, 0, 0);
		BN_bntest_rand(d, 1024, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod_mul(e, a, c, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp," * ");
					BN_print(bp,c);
					BIO_puts(bp," % ");
					BN_print(bp,b[j]);
					BIO_puts(bp," - ");
					BN_print(bp,e);
					BIO_puts(bp,"\n");
					}
				}
#endif
			BN_GF2m_add(f, a, d);
			BN_GF2m_mod_mul(g, f, c, b[j], ctx);
			BN_GF2m_mod_mul(h, d, c, b[j], ctx);
			BN_GF2m_add(f, e, g);
			BN_GF2m_add(f, f, h);
			/* Test that (a+d)*c = a*c + d*c. */
			if(!BN_is_zero(f))
				{
				fprintf(stderr,"GF(2^m) modular multiplication test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	BN_free(f);
	BN_free(g);
	BN_free(h);
	return ret;
	}

int test_gf2m_mod_sqr(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d;
	int i, j, ret = 0;
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 1024, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod_sqr(c, a, b[j], ctx);
			BN_copy(d, a);
			BN_GF2m_mod_mul(d, a, d, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp," ^ 2 % ");
					BN_print(bp,b[j]);
					BIO_puts(bp, " = ");
					BN_print(bp,c);
					BIO_puts(bp,"; a * a = ");
					BN_print(bp,d);
					BIO_puts(bp,"\n");
					}
				}
#endif
			BN_GF2m_add(d, c, d);
			/* Test that a*a = a^2. */
			if(!BN_is_zero(d))
				{
				fprintf(stderr,"GF(2^m) modular squaring test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	return ret;
	}

int test_gf2m_mod_inv(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d;
	int i, j, ret = 0;
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 512, 0, 0); 
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod_inv(c, a, b[j], ctx);
			BN_GF2m_mod_mul(d, a, c, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp, " * ");
					BN_print(bp,c);
					BIO_puts(bp," - 1 % ");
					BN_print(bp,b[j]);
					BIO_puts(bp,"\n");
					}
				}
#endif
			/* Test that ((1/a)*a) = 1. */
			if(!BN_is_one(d))
				{
				fprintf(stderr,"GF(2^m) modular inversion test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	return ret;
	}

int test_gf2m_mod_div(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d,*e,*f;
	int i, j, ret = 0;
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	f=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 512, 0, 0); 
		BN_bntest_rand(c, 512, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod_div(d, a, c, b[j], ctx);
			BN_GF2m_mod_mul(e, d, c, b[j], ctx);
			BN_GF2m_mod_div(f, a, e, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp, " = ");
					BN_print(bp,c);
					BIO_puts(bp," * ");
					BN_print(bp,d);
					BIO_puts(bp, " % ");
					BN_print(bp,b[j]);
					BIO_puts(bp,"\n");
					}
				}
#endif
			/* Test that ((a/c)*c)/a = 1. */
			if(!BN_is_one(f))
				{
				fprintf(stderr,"GF(2^m) modular division test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	BN_free(f);
	return ret;
	}

int test_gf2m_mod_exp(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d,*e,*f;
	int i, j, ret = 0;
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	f=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 512, 0, 0);
		BN_bntest_rand(c, 512, 0, 0);
		BN_bntest_rand(d, 512, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod_exp(e, a, c, b[j], ctx);
			BN_GF2m_mod_exp(f, a, d, b[j], ctx);
			BN_GF2m_mod_mul(e, e, f, b[j], ctx);
			BN_add(f, c, d);
			BN_GF2m_mod_exp(f, a, f, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp, " ^ (");
					BN_print(bp,c);
					BIO_puts(bp," + ");
					BN_print(bp,d);
					BIO_puts(bp, ") = ");
					BN_print(bp,e);
					BIO_puts(bp, "; - ");
					BN_print(bp,f);
					BIO_puts(bp, " % ");
					BN_print(bp,b[j]);
					BIO_puts(bp,"\n");
					}
				}
#endif
			BN_GF2m_add(f, e, f);
			/* Test that a^(c+d)=a^c*a^d. */
			if(!BN_is_zero(f))
				{
				fprintf(stderr,"GF(2^m) modular exponentiation test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	BN_free(f);
	return ret;
	}

int test_gf2m_mod_sqrt(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d,*e,*f;
	int i, j, ret = 0;
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	f=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 512, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod(c, a, b[j]);
			BN_GF2m_mod_sqrt(d, a, b[j], ctx);
			BN_GF2m_mod_sqr(e, d, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,d);
					BIO_puts(bp, " ^ 2 - ");
					BN_print(bp,a);
					BIO_puts(bp,"\n");
					}
				}
#endif
			BN_GF2m_add(f, c, e);
			/* Test that d^2 = a, where d = sqrt(a). */
			if(!BN_is_zero(f))
				{
				fprintf(stderr,"GF(2^m) modular square root test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	BN_free(f);
	return ret;
	}

int test_gf2m_mod_solve_quad(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d,*e;
	int i, j, s = 0, t, ret = 0;
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 512, 0, 0);
		for (j=0; j < 2; j++)
			{
			t = BN_GF2m_mod_solve_quad(c, a, b[j], ctx);
			if (t)
				{
				s++;
				BN_GF2m_mod_sqr(d, c, b[j], ctx);
				BN_GF2m_add(d, c, d);
				BN_GF2m_mod(e, a, b[j]);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
				if (bp != NULL)
					{
					if (!results)
						{
						BN_print(bp,c);
						BIO_puts(bp, " is root of z^2 + z = ");
						BN_print(bp,a);
						BIO_puts(bp, " % ");
						BN_print(bp,b[j]);
						BIO_puts(bp, "\n");
						}
					}
#endif
				BN_GF2m_add(e, e, d);
				/* Test that solution of quadratic c satisfies c^2 + c = a. */
				if(!BN_is_zero(e))
					{
					fprintf(stderr,"GF(2^m) modular solve quadratic test failed!\n");
					goto err;
					}

				}
			else 
				{
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
				if (bp != NULL)
					{
					if (!results)
						{
						BIO_puts(bp, "There are no roots of z^2 + z = ");
						BN_print(bp,a);
						BIO_puts(bp, " % ");
						BN_print(bp,b[j]);
						BIO_puts(bp, "\n");
						}
					}
#endif
				}
			}
		}
	if (s == 0)
		{	
		fprintf(stderr,"All %i tests of GF(2^m) modular solve quadratic resulted in no roots;\n", num0);
		fprintf(stderr,"this is very unlikely and probably indicates an error.\n");
		goto err;
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return ret;
	}
#endif
static int genprime_cb(int p, int n, BN_GENCB *arg)
	{
	char c='*';

	if (p == 0) c='.';
	if (p == 1) c='+';
	if (p == 2) c='*';
	if (p == 3) c='\n';
	putc(c, stderr);
	fflush(stderr);
	return 1;
	}

int test_kron(BIO *bp, BN_CTX *ctx)
	{
	BN_GENCB cb;
	BIGNUM *a,*b,*r,*t;
	int i;
	int legendre, kronecker;
	int ret = 0;

	a = BN_new();
	b = BN_new();
	r = BN_new();
	t = BN_new();
	if (a == NULL || b == NULL || r == NULL || t == NULL) goto err;

	BN_GENCB_set(&cb, genprime_cb, NULL);
	
	/* We test BN_kronecker(a, b, ctx) just for  b  odd (Jacobi symbol).
	 * In this case we know that if  b  is prime, then BN_kronecker(a, b, ctx)
	 * is congruent to $a^{(b-1)/2}$, modulo $b$ (Legendre symbol).
	 * So we generate a random prime  b  and compare these values
	 * for a number of random  a's.  (That is, we run the Solovay-Strassen
	 * primality test to confirm that  b  is prime, except that we
	 * don't want to test whether  b  is prime but whether BN_kronecker
	 * works.) */

	if (!BN_generate_prime_ex(b, 512, 0, NULL, NULL, &cb)) goto err;
	b->neg = rand_neg();
	putc('\n', stderr);

	for (i = 0; i < num0; i++)
		{
		if (!BN_bntest_rand(a, 512, 0, 0)) goto err;
		a->neg = rand_neg();

		/* t := (|b|-1)/2  (note that b is odd) */
		if (!BN_copy(t, b)) goto err;
		t->neg = 0;
		if (!BN_sub_word(t, 1)) goto err;
		if (!BN_rshift1(t, t)) goto err;
		/* r := a^t mod b */
		b->neg=0;
		
		if (!BN_mod_exp_recp(r, a, t, b, ctx)) goto err;
		b->neg=1;

		if (BN_is_word(r, 1))
			legendre = 1;
		else if (BN_is_zero(r))
			legendre = 0;
		else
			{
			if (!BN_add_word(r, 1)) goto err;
			if (0 != BN_ucmp(r, b))
				{
				fprintf(stderr, "Legendre symbol computation failed\n");
				goto err;
				}
			legendre = -1;
			}
		
		kronecker = BN_kronecker(a, b, ctx);
		if (kronecker < -1) goto err;
		/* we actually need BN_kronecker(a, |b|) */
		if (a->neg && b->neg)
			kronecker = -kronecker;
		
		if (legendre != kronecker)
			{
			fprintf(stderr, "legendre != kronecker; a = ");
			BN_print_fp(stderr, a);
			fprintf(stderr, ", b = ");
			BN_print_fp(stderr, b);
			fprintf(stderr, "\n");
			goto err;
			}

		putc('.', stderr);
		fflush(stderr);
		}

	putc('\n', stderr);
	fflush(stderr);
	ret = 1;
 err:
	if (a != NULL) BN_free(a);
	if (b != NULL) BN_free(b);
	if (r != NULL) BN_free(r);
	if (t != NULL) BN_free(t);
	return ret;
	}

int test_sqrt(BIO *bp, BN_CTX *ctx)
	{
	BN_GENCB cb;
	BIGNUM *a,*p,*r;
	int i, j;
	int ret = 0;

	a = BN_new();
	p = BN_new();
	r = BN_new();
	if (a == NULL || p == NULL || r == NULL) goto err;

	BN_GENCB_set(&cb, genprime_cb, NULL);

	for (i = 0; i < 16; i++)
		{
		if (i < 8)
			{
			unsigned primes[8] = { 2, 3, 5, 7, 11, 13, 17, 19 };
			
			if (!BN_set_word(p, primes[i])) goto err;
			}
		else
			{
			if (!BN_set_word(a, 32)) goto err;
			if (!BN_set_word(r, 2*i + 1)) goto err;
		
			if (!BN_generate_prime_ex(p, 256, 0, a, r, &cb)) goto err;
			putc('\n', stderr);
			}
		p->neg = rand_neg();

		for (j = 0; j < num2; j++)
			{
			/* construct 'a' such that it is a square modulo p,
			 * but in general not a proper square and not reduced modulo p */
			if (!BN_bntest_rand(r, 256, 0, 3)) goto err;
			if (!BN_nnmod(r, r, p, ctx)) goto err;
			if (!BN_mod_sqr(r, r, p, ctx)) goto err;
			if (!BN_bntest_rand(a, 256, 0, 3)) goto err;
			if (!BN_nnmod(a, a, p, ctx)) goto err;
			if (!BN_mod_sqr(a, a, p, ctx)) goto err;
			if (!BN_mul(a, a, r, ctx)) goto err;
			if (rand_neg())
				if (!BN_sub(a, a, p)) goto err;

			if (!BN_mod_sqrt(r, a, p, ctx)) goto err;
			if (!BN_mod_sqr(r, r, p, ctx)) goto err;

			if (!BN_nnmod(a, a, p, ctx)) goto err;

			if (BN_cmp(a, r) != 0)
				{
				fprintf(stderr, "BN_mod_sqrt failed: a = ");
				BN_print_fp(stderr, a);
				fprintf(stderr, ", r = ");
				BN_print_fp(stderr, r);
				fprintf(stderr, ", p = ");
				BN_print_fp(stderr, p);
				fprintf(stderr, "\n");
				goto err;
				}

			putc('.', stderr);
			fflush(stderr);
			}
		
		putc('\n', stderr);
		fflush(stderr);
		}
	ret = 1;
 err:
	if (a != NULL) BN_free(a);
	if (p != NULL) BN_free(p);
	if (r != NULL) BN_free(r);
	return ret;
	}

int test_lshift(BIO *bp,BN_CTX *ctx,BIGNUM *a_)
	{
	BIGNUM *a,*b,*c,*d;
	int i;

	b=BN_new();
	c=BN_new();
	d=BN_new();
	BN_one(c);

	if(a_)
	    a=a_;
	else
	    {
	    a=BN_new();
	    BN_bntest_rand(a,200,0,0); /**/
	    a->neg=rand_neg();
	    }
	for (i=0; i<num0; i++)
		{
		BN_lshift(b,a,i+1);
		BN_add(c,c,c);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," * ");
				BN_print(bp,c);
				BIO_puts(bp," - ");
				}
			BN_print(bp,b);
			BIO_puts(bp,"\n");
			}
		BN_mul(d,a,c,ctx);
		BN_sub(d,d,b);
		if(!BN_is_zero(d))
		    {
		    fprintf(stderr,"Left shift test failed!\n");
		    fprintf(stderr,"a=");
		    BN_print_fp(stderr,a);
		    fprintf(stderr,"\nb=");
		    BN_print_fp(stderr,b);
		    fprintf(stderr,"\nc=");
		    BN_print_fp(stderr,c);
		    fprintf(stderr,"\nd=");
		    BN_print_fp(stderr,d);
		    fprintf(stderr,"\n");
		    return 0;
		    }
		}
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	return(1);
	}

int test_lshift1(BIO *bp)
	{
	BIGNUM *a,*b,*c;
	int i;

	a=BN_new();
	b=BN_new();
	c=BN_new();

	BN_bntest_rand(a,200,0,0); /**/
	a->neg=rand_neg();
	for (i=0; i<num0; i++)
		{
		BN_lshift1(b,a);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," * 2");
				BIO_puts(bp," - ");
				}
			BN_print(bp,b);
			BIO_puts(bp,"\n");
			}
		BN_add(c,a,a);
		BN_sub(a,b,c);
		if(!BN_is_zero(a))
		    {
		    fprintf(stderr,"Left shift one test failed!\n");
		    return 0;
		    }
		
		BN_copy(a,b);
		}
	BN_free(a);
	BN_free(b);
	BN_free(c);
	return(1);
	}

int test_rshift(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b,*c,*d,*e;
	int i;

	a=BN_new();
	b=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	BN_one(c);

	BN_bntest_rand(a,200,0,0); /**/
	a->neg=rand_neg();
	for (i=0; i<num0; i++)
		{
		BN_rshift(b,a,i+1);
		BN_add(c,c,c);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," / ");
				BN_print(bp,c);
				BIO_puts(bp," - ");
				}
			BN_print(bp,b);
			BIO_puts(bp,"\n");
			}
		BN_div(d,e,a,c,ctx);
		BN_sub(d,d,b);
		if(!BN_is_zero(d))
		    {
		    fprintf(stderr,"Right shift test failed!\n");
		    return 0;
		    }
		}
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return(1);
	}

int test_rshift1(BIO *bp)
	{
	BIGNUM *a,*b,*c;
	int i;

	a=BN_new();
	b=BN_new();
	c=BN_new();

	BN_bntest_rand(a,200,0,0); /**/
	a->neg=rand_neg();
	for (i=0; i<num0; i++)
		{
		BN_rshift1(b,a);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," / 2");
				BIO_puts(bp," - ");
				}
			BN_print(bp,b);
			BIO_puts(bp,"\n");
			}
		BN_sub(c,a,b);
		BN_sub(c,c,b);
		if(!BN_is_zero(c) && !BN_abs_is_word(c, 1))
		    {
		    fprintf(stderr,"Right shift one test failed!\n");
		    return 0;
		    }
		BN_copy(a,b);
		}
	BN_free(a);
	BN_free(b);
	BN_free(c);
	return(1);
	}

int rand_neg(void)
	{
	static unsigned int neg=0;
	static int sign[8]={0,0,0,1,1,0,1,1};

	return(sign[(neg++)%8]);
	}
@


1.14
log
@resolve conflicts
@
text
@@


1.13
log
@resolve conflicts, fix local changes
@
text
@d265 1
a265 1

d301 1
a301 1

d1064 1
a1064 1

d1639 1
a1639 1

@


1.12
log
@resolve conflicts
@
text
@d489 1
a489 1
	BIO_printf(bp,"%lX",w);
d735 2
d1032 1
a1032 1
		if (!BN_exp(d,a,b,ctx))
d1121 2
a1122 2
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};
d1179 2
a1180 2
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};
d1250 2
a1251 2
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};
d1309 2
a1310 2
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};
d1364 2
a1365 2
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};
d1427 2
a1428 2
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};
d1498 2
a1499 2
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};
d1557 2
a1558 2
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};
@


1.11
log
@resolve conflicts
@
text
@d58 19
d101 1
d111 9
d187 1
a187 1
	BIO_flush(out);
d191 1
a191 1
	BIO_flush(out);
d195 1
a195 1
	BIO_flush(out);
d200 1
a200 1
	BIO_flush(out);
d204 1
a204 1
	BIO_flush(out);
d208 1
a208 1
	BIO_flush(out);
d212 1
a212 1
	BIO_flush(out);
d216 1
a216 1
	BIO_flush(out);
d220 1
a220 1
	BIO_flush(out);
d224 5
a228 1
	BIO_flush(out);
d232 1
a232 1
	BIO_flush(out);
d236 1
a236 1
	BIO_flush(out);
d240 1
a240 1
	BIO_flush(out);
d244 1
a244 1
	BIO_flush(out);
d248 1
a248 1
	BIO_flush(out);
d252 1
a252 1
	BIO_flush(out);
d256 1
a256 1
	BIO_flush(out);
d260 1
a260 1
	BIO_flush(out);
d264 37
a300 1
	BIO_flush(out);
d309 2
a310 2
	                      * the failure, see test_bn in test/Makefile */
	BIO_flush(out);
d476 72
d1063 576
a1638 1
static void genprime_cb(int p, int n, void *arg)
d1648 1
a1648 2
	(void)n;
	(void)arg;
d1653 1
d1664 2
d1676 1
a1676 1
	if (!BN_generate_prime(b, 512, 0, NULL, NULL, genprime_cb, NULL)) goto err;
d1744 1
d1753 3
a1755 1
	
d1769 1
a1769 1
			if (!BN_generate_prime(p, 256, 0, a, r, genprime_cb, NULL)) goto err;
@


1.10
log
@resolve conflicts
@
text
@d89 1
d217 4
d789 51
@


1.9
log
@return(00); -> return(0); markus@@ ok
@
text
@d235 1
a235 1
	                      * the failure, see test_bn in test/Makefile.ssl*/
@


1.8
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d783 1
a783 1
			return(00);
d834 1
a834 1
			return(00);
@


1.7
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@a70 4
#ifdef OPENSSL_SYS_WINDOWS
#include "../bio/bss_file.c"
#endif

a94 5
#ifdef OPENSSL_NO_STDIO
#define APPS_WIN16
#include "bss_file.c"
#endif

d135 1
a135 1
	if (ctx == NULL) exit(1);
d138 1
a138 1
	if (out == NULL) exit(1);
d148 1
a148 1
			exit(1);
d232 1
a232 1
	exit(0);
d239 1
a239 1
	exit(1);
d482 1
a482 1
	if (ctx == NULL) exit(1);
d720 1
a720 1
			exit(1);
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d928 1
a928 1
		if (!BN_mod_exp_recp(r, a, t, b, ctx)) goto err; /* XXX should be BN_mod_exp_recp, but ..._recp triggers a bug that must be fixed */
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@d63 1
a63 1
#include "openssl/e_os.h"
d71 1
a71 1
#ifdef WINDOWS
d94 2
d99 1
a99 1
#ifdef NO_STDIO
d229 8
a255 1
	int j;
a266 3
		if (bp == NULL)
			for (j=0; j<10000; j++)
				BN_add(&c,&a,&b);
a299 1
	int j;
a319 3
		if (bp == NULL)
			for (j=0; j<10000; j++)
				BN_sub(&c,&a,&b);
a350 1
	int j;
a370 3
		if (bp == NULL)
			for (j=0; j<100; j++)
				BN_div(&d,&c,&a,&b,ctx);
a415 1
	int j;
a437 3
		if (bp == NULL)
			for (j=0; j<100; j++)
				BN_div_recp(&d,&c,&a,&recp,ctx);
d488 1
a488 2
	int j;
	BN_CTX ctx;
d490 3
a492 1
	BN_CTX_init(&ctx);
d510 1
a510 4
		if (bp == NULL)
			for (j=0; j<100; j++)
				BN_mul(&c,&a,&b,&ctx);
		BN_mul(&c,&a,&b,&ctx);
d523 1
a523 1
		BN_div(&d,&e,&c,&a,&ctx);
d536 1
a536 1
	BN_CTX_free(&ctx);
a543 1
	int j;
a553 3
		if (bp == NULL)
			for (j=0; j<100; j++)
				BN_sqr(&c,&a,ctx);
a586 1
	int j;
d610 3
a615 3
		if (bp == NULL)
			for (j=0; j<100; j++)
				BN_mod_mul_montgomery(&c,&A,&B,mont,ctx);/**/
a660 1
	int j;
a673 3
		if (bp == NULL)
			for (j=0; j<100; j++)
				BN_mod(c,a,b,ctx);/**/
d706 1
a706 1
	int i;
d714 1
a721 4
	/*	if (bp == NULL)
			for (j=0; j<100; j++)
				BN_mod_mul(d,a,b,c,ctx);*/ /**/

d740 10
d761 1
d765 1
d875 177
d1224 1
a1224 1
		if(!BN_is_zero(c) && !BN_is_one(c))
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@a109 1
#if defined(linux) || defined(__FreeBSD__) /* can we use GNU bc features? */
a112 1
#endif
d123 1
a123 3
	RAND_seed(rnd_seed, sizeof rnd_seed); /* or BN_rand may fail, and we don't
	                                       * even check its return value
	                                       * (which we should) */
d252 1
a252 1
	BN_rand(&a,512,0,0);
d255 1
a255 1
		BN_rand(&b,450+i,0,0);
d304 1
a304 1
			BN_rand(&a,512,0,0);
d311 1
a311 1
			BN_rand(&b,400+i-num1,0,0);
d361 1
a361 1
			BN_rand(&a,400,0,0);
d367 1
a367 1
			BN_rand(&b,50+3*(i-num1),0,0);
d431 1
a431 1
			BN_rand(&a,400,0,0);
d437 1
a437 1
			BN_rand(&b,50+3*(i-num1),0,0);
d508 2
a509 2
			BN_rand(&a,100,0,0);
			BN_rand(&b,100,0,0);
d512 1
a512 1
			BN_rand(&b,i-num1,0,0);
d561 1
a561 1
		BN_rand(&a,40+i*10,0,0);
d612 2
a613 2
	BN_rand(&a,100,0,0); /**/
	BN_rand(&b,100,0,0); /**/
d620 1
a620 1
		BN_rand(&n,bits,0,1);
d682 1
a682 1
	BN_rand(a,1024,0,0); /**/
d685 1
a685 1
		BN_rand(b,450+i*10,0,0); /**/
d731 1
a731 1
	BN_rand(c,1024,0,0); /**/
d734 2
a735 2
		BN_rand(a,475+i*10,0,0); /**/
		BN_rand(b,425+i*11,0,0); /**/
d793 1
a793 1
	BN_rand(c,30,0,1); /* must be odd for montgomery */
d796 2
a797 2
		BN_rand(a,20+i*5,0,0); /**/
		BN_rand(b,2+i,0,0); /**/
d847 2
a848 2
		BN_rand(a,20+i*5,0,0); /**/
		BN_rand(b,2+i,0,0); /**/
d898 1
a898 1
	    BN_rand(a,200,0,0); /**/
d950 1
a950 1
	BN_rand(a,200,0,0); /**/
d994 1
a994 1
	BN_rand(a,200,0,0); /**/
d1037 1
a1037 1
	BN_rand(a,200,0,0); /**/
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d237 2
a238 1
	BIO_puts(out,"1\n"); /* make sure bc fails if we are piping to it */
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d75 4
d102 1
a102 1
static unsigned char lst1[]="\xC6\x4F\x43\x04\x2A\xEA\xCA\x6E\x58\x36\x80\x5B\xE8\xC9"
d105 12
d123 6
d166 1
a166 1
	fprintf(stderr,"test BN_add\n");
d168 1
a168 1
	fflush(stdout);
d170 1
a170 1
	fprintf(stderr,"test BN_sub\n");
d172 1
a172 1
	fflush(stdout);
d174 1
a174 1
	fprintf(stderr,"test BN_lshift1\n");
d176 1
a176 1
	fflush(stdout);
d178 2
a179 2
	fprintf(stderr,"test BN_lshift (fixed)\n");
	if (!test_lshift(out,ctx,BN_bin2bn(lst1,sizeof(lst1)-1,NULL)))
d181 1
a181 1
	fflush(stdout);
d183 1
a183 1
	fprintf(stderr,"test BN_lshift\n");
d185 1
a185 1
	fflush(stdout);
d187 1
a187 1
	fprintf(stderr,"test BN_rshift1\n");
d189 1
a189 1
	fflush(stdout);
d191 1
a191 1
	fprintf(stderr,"test BN_rshift\n");
d193 1
a193 1
	fflush(stdout);
d195 1
a195 1
	fprintf(stderr,"test BN_sqr\n");
d197 1
a197 1
	fflush(stdout);
d199 1
a199 1
	fprintf(stderr,"test BN_mul\n");
d201 1
a201 1
	fflush(stdout);
d203 1
a203 1
	fprintf(stderr,"test BN_div\n");
d205 1
a205 1
	fflush(stdout);
d207 1
a207 1
	fprintf(stderr,"test BN_div_recp\n");
d209 1
a209 1
	fflush(stdout);
d211 1
a211 1
	fprintf(stderr,"test BN_mod\n");
d213 1
a213 1
	fflush(stdout);
d215 1
a215 1
	fprintf(stderr,"test BN_mod_mul\n");
d217 1
a217 1
	fflush(stdout);
d219 1
a219 2
/*
	fprintf(stderr,"test BN_mont\n");
d221 3
a223 3
	fflush(stdout);
*/
	fprintf(stderr,"test BN_mod_exp\n");
d225 1
a225 1
	fflush(stdout);
d227 1
a227 1
	fprintf(stderr,"test BN_exp\n");
d229 4
a232 1
	fflush(stdout);
d238 1
d240 1
a240 1
	ERR_print_errors(out);
d256 1
a256 1
	for (i=0; i<100; i++)
d283 1
a283 1
		    BIO_puts(bp,"Add test failed!\n");
d303 1
a303 2
	BN_rand(&a,512,0,0);
	for (i=0; i<100; i++)
d305 13
a317 3
		BN_rand(&b,400+i,0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
d338 1
a338 1
		    BIO_puts(bp,"Subtract test failed!\n");
d360 1
a360 2
	BN_rand(&a,400,0,0);
	for (i=0; i<100; i++)
d362 9
a370 1
		BN_rand(&b,50+i,0,0);
d404 1
a404 1
		    BIO_puts(bp,"Division test failed!\n");
d430 1
a430 2
	BN_rand(&a,400,0,0);
	for (i=0; i<100; i++)
d432 9
a440 1
		BN_rand(&b,50+i,0,0);
d475 6
a480 1
		    BIO_puts(bp,"Reciprocal division test failed!\n");
d507 1
a507 2
	BN_rand(&a,200,0,0);
	for (i=0; i<100; i++)
d509 7
a515 2
		BN_rand(&b,250+i,0,0);
		BN_rand(&b,200,0,0);
d538 1
a538 1
		    BIO_puts(bp,"Multiplication test failed!\n");
d562 1
a562 1
	for (i=0; i<40; i++)
d586 1
a586 1
		    BIO_puts(bp,"Square test failed!\n");
d617 1
a617 1
	for (i=0; i<10; i++)
d619 5
a623 1
		BN_rand(&n,(100%BN_BITS2+1)*BN_BITS2*i*BN_BITS2,0,1); /**/
d658 1
a658 1
		    BIO_puts(bp,"Montgomery multiplication test failed!\n");
d686 1
a686 1
	for (i=0; i<20; i++)
d711 1
a711 1
		    BIO_puts(bp,"Modulo test failed!\n");
d735 1
a735 1
	for (i=0; i<10; i++)
d738 1
a738 1
		BN_rand(b,425+i*10,0,0); /**/
d773 1
a773 1
		    BIO_puts(bp,"Modulo multiply test failed!\n");
d797 1
a797 1
	for (i=0; i<6; i++)
d824 1
a824 1
		    BIO_puts(bp,"Modulo exponentiation test failed!\n");
d848 1
a848 1
	for (i=0; i<6; i++)
d874 1
a874 1
		    BIO_puts(bp,"Exponentiation test failed!\n");
d904 1
a904 1
	for (i=0; i<70; i++)
d924 10
a933 10
		    BIO_puts(bp,"Left shift test failed!\n");
		    BIO_puts(bp,"a=");
		    BN_print(bp,a);
		    BIO_puts(bp,"\nb=");
		    BN_print(bp,b);
		    BIO_puts(bp,"\nc=");
		    BN_print(bp,c);
		    BIO_puts(bp,"\nd=");
		    BN_print(bp,d);
		    BIO_puts(bp,"\n");
d955 1
a955 1
	for (i=0; i<70; i++)
d973 1
a973 1
		    BIO_puts(bp,"Left shift one test failed!\n");
d999 1
a999 1
	for (i=0; i<70; i++)
d1019 1
a1019 1
		    BIO_puts(bp,"Right shift test failed!\n");
d1042 1
a1042 1
	for (i=0; i<70; i++)
d1060 1
a1060 1
		    BIO_puts(bp,"Right shift one test failed!\n");
@


1.1
log
@Initial revision
@
text
@d62 8
a69 6
#include "e_os.h"
#include "bio.h"
#include "bn.h"
#include "rand.h"
#include "x509.h"
#include "err.h"
d75 15
a89 14
#ifndef NOPROTO
int test_add (BIO *bp);
int test_sub (BIO *bp);
int test_lshift1 (BIO *bp);
int test_lshift (BIO *bp);
int test_rshift1 (BIO *bp);
int test_rshift (BIO *bp);
int test_div (BIO *bp,BN_CTX *ctx);
int test_mul (BIO *bp);
int test_sqr (BIO *bp,BN_CTX *ctx);
int test_mont (BIO *bp,BN_CTX *ctx);
int test_mod (BIO *bp,BN_CTX *ctx);
int test_mod_mul (BIO *bp,BN_CTX *ctx);
int test_mod_exp (BIO *bp,BN_CTX *ctx);
a90 17
#else
int test_add ();
int test_sub ();
int test_lshift1 ();
int test_lshift ();
int test_rshift1 ();
int test_rshift ();
int test_div ();
int test_mul ();
int test_sqr ();
int test_mont ();
int test_mod ();
int test_mod_mul ();
int test_mod_exp ();
int rand_neg();
#endif

d98 4
a101 3
int main(argc,argv)
int argc;
char *argv[];
a106 2
	srand((unsigned int)time(NULL));

d156 5
d162 1
a162 1
	if (!test_lshift(out)) goto err;
d170 1
a170 1
	if (!test_rshift(out)) goto err;
d185 4
d206 4
d213 1
d220 1
a220 2
int test_add(bp)
BIO *bp;
d222 1
a222 1
	BIGNUM *a,*b,*c;
d226 3
a228 3
	a=BN_new();
	b=BN_new();
	c=BN_new();
d230 1
a230 1
	BN_rand(a,512,0,0);
d233 3
a235 3
		BN_rand(b,450+i,0,0);
		a->neg=rand_neg();
		b->neg=rand_neg();
d238 2
a239 2
				BN_add(c,a,b);
		BN_add(c,a,b);
d244 1
a244 1
				BN_print(bp,a);
d246 1
a246 1
				BN_print(bp,b);
d249 1
a249 1
			BN_print(bp,c);
d252 9
d262 3
a264 3
	BN_free(a);
	BN_free(b);
	BN_free(c);
d268 1
a268 2
int test_sub(bp)
BIO *bp;
d270 1
a270 1
	BIGNUM *a,*b,*c;
d274 3
a276 3
	a=BN_new();
	b=BN_new();
	c=BN_new();
d278 1
a278 1
	BN_rand(a,512,0,0);
d281 3
a283 3
		BN_rand(b,400+i,0,0);
		a->neg=rand_neg();
		b->neg=rand_neg();
d286 50
a335 2
				BN_sub(c,a,b);
		BN_sub(c,a,b);
d340 3
a342 1
				BN_print(bp,a);
d344 9
a352 1
				BN_print(bp,b);
d355 1
a355 1
			BN_print(bp,c);
d358 8
d367 5
a371 3
	BN_free(a);
	BN_free(b);
	BN_free(c);
d375 1
a375 3
int test_div(bp,ctx)
BIO *bp;
BN_CTX *ctx;
d377 2
a378 1
	BIGNUM *a,*b,*c,*d;
d382 6
a387 4
	a=BN_new();
	b=BN_new();
	c=BN_new();
	d=BN_new();
d389 1
a389 1
	BN_rand(a,400,0,0);
d392 4
a395 3
		BN_rand(b,50+i,0,0);
		a->neg=rand_neg();
		b->neg=rand_neg();
d398 2
a399 2
				BN_div(d,c,a,b,ctx);
		BN_div(d,c,a,b,ctx);
d404 1
a404 1
				BN_print(bp,a);
d406 1
a406 1
				BN_print(bp,b);
d409 1
a409 1
			BN_print(bp,d);
d414 1
a414 1
				BN_print(bp,a);
d416 1
a416 1
				BN_print(bp,b);
d419 1
a419 1
			BN_print(bp,c);
d422 8
d431 6
a436 4
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
d440 1
a440 2
int test_mul(bp)
BIO *bp;
d442 1
a442 1
	BIGNUM *a,*b,*c;
d445 1
d447 6
a452 3
	a=BN_new();
	b=BN_new();
	c=BN_new();
d454 1
a454 1
	BN_rand(a,200,0,0);
d457 4
a460 3
		BN_rand(b,250+i,0,0);
		a->neg=rand_neg();
		b->neg=rand_neg();
d463 2
a464 2
				BN_mul(c,a,b);
		BN_mul(c,a,b);
d469 1
a469 1
				BN_print(bp,a);
d471 1
a471 1
				BN_print(bp,b);
d474 1
a474 1
			BN_print(bp,c);
d477 7
d485 6
a490 3
	BN_free(a);
	BN_free(b);
	BN_free(c);
d494 1
a494 3
int test_sqr(bp,ctx)
BIO *bp;
BN_CTX *ctx;
d496 1
a496 1
	BIGNUM *a,*c;
d500 4
a503 2
	a=BN_new();
	c=BN_new();
d507 2
a508 2
		BN_rand(a,40+i*10,0,0);
		a->neg=rand_neg();
d511 2
a512 2
				BN_sqr(c,a,ctx);
		BN_sqr(c,a,ctx);
d517 1
a517 1
				BN_print(bp,a);
d519 1
a519 1
				BN_print(bp,a);
d522 1
a522 1
			BN_print(bp,c);
d525 7
d533 4
a536 2
	BN_free(a);
	BN_free(c);
d540 1
a540 3
int test_mont(bp,ctx)
BIO *bp;
BN_CTX *ctx;
d542 2
a543 2
	BIGNUM *a,*b,*c,*A,*B;
	BIGNUM *n;
d548 7
a554 6
	a=BN_new();
	b=BN_new();
	c=BN_new();
	A=BN_new();
	B=BN_new();
	n=BN_new();
d558 2
a559 2
	BN_rand(a,100,0,0); /**/
	BN_rand(b,100,0,0); /**/
d562 2
a563 2
		BN_rand(n,(100%BN_BITS2+1)*BN_BITS2*i*BN_BITS2,0,1); /**/
		BN_MONT_CTX_set(mont,n,ctx);
d565 2
a566 2
		BN_to_montgomery(A,a,mont,ctx);
		BN_to_montgomery(B,b,mont,ctx);
d570 3
a572 3
				BN_mod_mul_montgomery(c,A,B,mont,ctx);/**/
		BN_mod_mul_montgomery(c,A,B,mont,ctx);/**/
		BN_from_montgomery(A,c,mont,ctx);/**/
d579 2
a580 2
BN_num_bits(a),
BN_num_bits(b),
d583 1
a583 1
				BN_print(bp,a);
d585 1
a585 1
				BN_print(bp,b);
d587 1
a587 1
				BN_print(bp,mont->N);
d590 1
a590 1
			BN_print(bp,A);
d593 7
d602 7
a608 3
	BN_free(a);
	BN_free(b);
	BN_free(c);
d612 1
a612 3
int test_mod(bp,ctx)
BIO *bp;
BN_CTX *ctx;
d614 1
a614 1
	BIGNUM *a,*b,*c;
d621 2
d646 7
d657 2
d662 1
a662 3
int test_mod_mul(bp,ctx)
BIO *bp;
BN_CTX *ctx;
d707 8
d724 1
a724 3
int test_mod_exp(bp,ctx)
BIO *bp;
BN_CTX *ctx;
d758 8
d775 1
a775 2
int test_lshift(bp)
BIO *bp;
d777 1
a777 1
	BIGNUM *a,*b,*c;
d782 49
d832 1
d835 8
a842 2
	BN_rand(a,200,0,0); /**/
	a->neg=rand_neg();
d859 16
d879 1
d883 1
a883 2
int test_lshift1(bp)
BIO *bp;
d885 1
a885 1
	BIGNUM *a,*b;
d890 1
d908 8
d920 1
d924 1
a924 2
int test_rshift(bp)
BIO *bp;
d926 1
a926 1
	BIGNUM *a,*b,*c;
d932 2
d954 7
d965 2
d970 1
a970 2
int test_rshift1(bp)
BIO *bp;
d972 1
a972 1
	BIGNUM *a,*b;
d977 1
d995 7
d1006 1
d1010 1
a1010 1
int rand_neg()
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a61 1

d63 5
d69 1
a69 7
#include <openssl/bio.h>
#include <openssl/bn.h>
#include <openssl/rand.h>
#include <openssl/x509.h>
#include <openssl/err.h>

#ifdef OPENSSL_SYS_WINDOWS
d73 14
a86 21
const int num0 = 100; /* number of tests */
const int num1 = 50;  /* additional tests for some functions */
const int num2 = 5;   /* number of tests for slow functions */

int test_add(BIO *bp);
int test_sub(BIO *bp);
int test_lshift1(BIO *bp);
int test_lshift(BIO *bp,BN_CTX *ctx,BIGNUM *a_);
int test_rshift1(BIO *bp);
int test_rshift(BIO *bp,BN_CTX *ctx);
int test_div(BIO *bp,BN_CTX *ctx);
int test_div_recp(BIO *bp,BN_CTX *ctx);
int test_mul(BIO *bp);
int test_sqr(BIO *bp,BN_CTX *ctx);
int test_mont(BIO *bp,BN_CTX *ctx);
int test_mod(BIO *bp,BN_CTX *ctx);
int test_mod_mul(BIO *bp,BN_CTX *ctx);
int test_mod_exp(BIO *bp,BN_CTX *ctx);
int test_exp(BIO *bp,BN_CTX *ctx);
int test_kron(BIO *bp,BN_CTX *ctx);
int test_sqrt(BIO *bp,BN_CTX *ctx);
d88 17
d107 1
a107 1
#ifdef OPENSSL_NO_STDIO
d112 3
a114 14
static unsigned char lst[]="\xC6\x4F\x43\x04\x2A\xEA\xCA\x6E\x58\x36\x80\x5B\xE8\xC9"
"\x9B\x04\x5D\x48\x36\xC2\xFD\x16\xC9\x64\xF0";

static const char rnd_seed[] = "string to make the random number generator think it has entropy";

static void message(BIO *out, char *m)
	{
	fprintf(stderr, "test %s\n", m);
	BIO_puts(out, "print \"test ");
	BIO_puts(out, m);
	BIO_puts(out, "\\n\"\n");
	}

int main(int argc, char *argv[])
d120 1
a120 3
	results = 0;

	RAND_seed(rnd_seed, sizeof rnd_seed); /* or BN_generate_prime may fail */
d159 1
a159 1
	message(out,"BN_add");
d161 1
a161 1
	BIO_flush(out);
d163 1
a163 1
	message(out,"BN_sub");
d165 1
a165 1
	BIO_flush(out);
d167 1
a167 1
	message(out,"BN_lshift1");
d169 1
a169 1
	BIO_flush(out);
d171 3
a173 8
	message(out,"BN_lshift (fixed)");
	if (!test_lshift(out,ctx,BN_bin2bn(lst,sizeof(lst)-1,NULL)))
	    goto err;
	BIO_flush(out);

	message(out,"BN_lshift");
	if (!test_lshift(out,ctx,NULL)) goto err;
	BIO_flush(out);
d175 1
a175 1
	message(out,"BN_rshift1");
d177 1
a177 1
	BIO_flush(out);
d179 3
a181 3
	message(out,"BN_rshift");
	if (!test_rshift(out,ctx)) goto err;
	BIO_flush(out);
d183 1
a183 1
	message(out,"BN_sqr");
d185 1
a185 1
	BIO_flush(out);
d187 1
a187 1
	message(out,"BN_mul");
d189 1
a189 1
	BIO_flush(out);
d191 1
a191 1
	message(out,"BN_div");
d193 1
a193 5
	BIO_flush(out);

	message(out,"BN_div_recp");
	if (!test_div_recp(out,ctx)) goto err;
	BIO_flush(out);
d195 1
a195 1
	message(out,"BN_mod");
d197 1
a197 1
	BIO_flush(out);
d199 1
a199 1
	message(out,"BN_mod_mul");
d201 1
a201 1
	BIO_flush(out);
d203 2
a204 1
	message(out,"BN_mont");
d206 3
a208 3
	BIO_flush(out);

	message(out,"BN_mod_exp");
d210 1
a210 16
	BIO_flush(out);

	message(out,"BN_exp");
	if (!test_exp(out,ctx)) goto err;
	BIO_flush(out);

	message(out,"BN_kronecker");
	if (!test_kron(out,ctx)) goto err;
	BIO_flush(out);

	message(out,"BN_mod_sqrt");
	if (!test_sqrt(out,ctx)) goto err;
	BIO_flush(out);

	BN_CTX_free(ctx);
	BIO_free(out);
a214 3
	BIO_puts(out,"1\n"); /* make sure the Perl script fed by bc notices
	                      * the failure, see test_bn in test/Makefile.ssl*/
	BIO_flush(out);
d216 1
a216 1
	ERR_print_errors_fp(stderr);
d221 2
a222 1
int test_add(BIO *bp)
d224 1
a224 1
	BIGNUM a,b,c;
d226 1
d228 3
a230 3
	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
d232 2
a233 2
	BN_bntest_rand(&a,512,0,0);
	for (i=0; i<num0; i++)
d235 7
a241 4
		BN_bntest_rand(&b,450+i,0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_add(&c,&a,&b);
d246 1
a246 1
				BN_print(bp,&a);
d248 1
a248 1
				BN_print(bp,&b);
d251 1
a251 1
			BN_print(bp,&c);
a253 9
		a.neg=!a.neg;
		b.neg=!b.neg;
		BN_add(&c,&c,&b);
		BN_add(&c,&c,&a);
		if(!BN_is_zero(&c))
		    {
		    fprintf(stderr,"Add test failed!\n");
		    return 0;
		    }
d255 3
a257 3
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
d261 2
a262 1
int test_sub(BIO *bp)
d264 1
a264 1
	BIGNUM a,b,c;
d266 1
d268 3
a270 3
	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
d272 2
a273 1
	for (i=0; i<num0+num1; i++)
d275 7
a281 14
		if (i < num1)
			{
			BN_bntest_rand(&a,512,0,0);
			BN_copy(&b,&a);
			if (BN_set_bit(&a,i)==0) return(0);
			BN_add_word(&b,i);
			}
		else
			{
			BN_bntest_rand(&b,400+i-num1,0,0);
			a.neg=rand_neg();
			b.neg=rand_neg();
			}
		BN_sub(&c,&a,&b);
d286 1
a286 1
				BN_print(bp,&a);
d288 1
a288 1
				BN_print(bp,&b);
d291 1
a291 1
			BN_print(bp,&c);
a293 7
		BN_add(&c,&c,&b);
		BN_sub(&c,&c,&a);
		if(!BN_is_zero(&c))
		    {
		    fprintf(stderr,"Subtract test failed!\n");
		    return 0;
		    }
d295 3
a297 3
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
d301 3
a303 1
int test_div(BIO *bp, BN_CTX *ctx)
d305 1
a305 1
	BIGNUM a,b,c,d,e;
d307 1
d309 4
a312 5
	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);
d314 2
a315 1
	for (i=0; i<num0+num1; i++)
d317 7
a323 12
		if (i < num1)
			{
			BN_bntest_rand(&a,400,0,0);
			BN_copy(&b,&a);
			BN_lshift(&a,&a,i);
			BN_add_word(&a,i);
			}
		else
			BN_bntest_rand(&b,50+3*(i-num1),0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_div(&d,&c,&a,&b,ctx);
d328 1
a328 1
				BN_print(bp,&a);
d330 1
a330 1
				BN_print(bp,&b);
d333 1
a333 1
			BN_print(bp,&d);
d338 1
a338 1
				BN_print(bp,&a);
d340 1
a340 1
				BN_print(bp,&b);
d343 1
a343 1
			BN_print(bp,&c);
a345 8
		BN_mul(&e,&d,&b,ctx);
		BN_add(&d,&e,&c);
		BN_sub(&d,&d,&a);
		if(!BN_is_zero(&d))
		    {
		    fprintf(stderr,"Division test failed!\n");
		    return 0;
		    }
d347 4
a350 5
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
d354 2
a355 1
int test_div_recp(BIO *bp, BN_CTX *ctx)
d357 1
a357 2
	BIGNUM a,b,c,d,e;
	BN_RECP_CTX recp;
d359 1
d361 3
a363 6
	BN_RECP_CTX_init(&recp);
	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);
d365 2
a366 1
	for (i=0; i<num0+num1; i++)
d368 7
a374 13
		if (i < num1)
			{
			BN_bntest_rand(&a,400,0,0);
			BN_copy(&b,&a);
			BN_lshift(&a,&a,i);
			BN_add_word(&a,i);
			}
		else
			BN_bntest_rand(&b,50+3*(i-num1),0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_RECP_CTX_set(&recp,&b,ctx);
		BN_div_recp(&d,&c,&a,&recp,ctx);
d379 1
a379 73
				BN_print(bp,&a);
				BIO_puts(bp," / ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&d);
			BIO_puts(bp,"\n");

			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," % ");
				BN_print(bp,&b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
			}
		BN_mul(&e,&d,&b,ctx);
		BN_add(&d,&e,&c);
		BN_sub(&d,&d,&a);
		if(!BN_is_zero(&d))
		    {
		    fprintf(stderr,"Reciprocal division test failed!\n");
		    fprintf(stderr,"a=");
		    BN_print_fp(stderr,&a);
		    fprintf(stderr,"\nb=");
		    BN_print_fp(stderr,&b);
		    fprintf(stderr,"\n");
		    return 0;
		    }
		}
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	BN_RECP_CTX_free(&recp);
	return(1);
	}

int test_mul(BIO *bp)
	{
	BIGNUM a,b,c,d,e;
	int i;
	BN_CTX *ctx;

	ctx = BN_CTX_new();
	if (ctx == NULL) exit(1);
	
	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);

	for (i=0; i<num0+num1; i++)
		{
		if (i <= num1)
			{
			BN_bntest_rand(&a,100,0,0);
			BN_bntest_rand(&b,100,0,0);
			}
		else
			BN_bntest_rand(&b,i-num1,0,0);
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_mul(&c,&a,&b,ctx);
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
d381 1
a381 1
				BN_print(bp,&b);
d384 1
a384 1
			BN_print(bp,&c);
a386 7
		BN_div(&d,&e,&c,&a,ctx);
		BN_sub(&d,&d,&b);
		if(!BN_is_zero(&d) || !BN_is_zero(&e))
		    {
		    fprintf(stderr,"Multiplication test failed!\n");
		    return 0;
		    }
d388 3
a390 6
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	BN_CTX_free(ctx);
d394 3
a396 1
int test_sqr(BIO *bp, BN_CTX *ctx)
d398 1
a398 1
	BIGNUM a,c,d,e;
d400 1
d402 2
a403 4
	BN_init(&a);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);
d405 1
a405 1
	for (i=0; i<num0; i++)
d407 6
a412 3
		BN_bntest_rand(&a,40+i*10,0,0);
		a.neg=rand_neg();
		BN_sqr(&c,&a,ctx);
d417 1
a417 1
				BN_print(bp,&a);
d419 1
a419 1
				BN_print(bp,&a);
d422 1
a422 1
			BN_print(bp,&c);
a424 7
		BN_div(&d,&e,&c,&a,ctx);
		BN_sub(&d,&d,&a);
		if(!BN_is_zero(&d) || !BN_is_zero(&e))
		    {
		    fprintf(stderr,"Square test failed!\n");
		    return 0;
		    }
d426 2
a427 4
	BN_free(&a);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
d431 3
a433 1
int test_mont(BIO *bp, BN_CTX *ctx)
d435 2
a436 2
	BIGNUM a,b,c,d,A,B;
	BIGNUM n;
d438 1
d441 6
a446 7
	BN_init(&a);
	BN_init(&b);
	BN_init(&c);
	BN_init(&d);
	BN_init(&A);
	BN_init(&B);
	BN_init(&n);
d450 15
a464 19
	BN_bntest_rand(&a,100,0,0); /**/
	BN_bntest_rand(&b,100,0,0); /**/
	for (i=0; i<num2; i++)
		{
		int bits = (200*(i+1))/num2;

		if (bits == 0)
			continue;
		BN_bntest_rand(&n,bits,0,1);
		BN_MONT_CTX_set(mont,&n,ctx);

		BN_nnmod(&a,&a,&n,ctx);
		BN_nnmod(&b,&b,&n,ctx);

		BN_to_montgomery(&A,&a,mont,ctx);
		BN_to_montgomery(&B,&b,mont,ctx);

		BN_mod_mul_montgomery(&c,&A,&B,mont,ctx);/**/
		BN_from_montgomery(&A,&c,mont,ctx);/**/
d471 2
a472 2
BN_num_bits(&a),
BN_num_bits(&b),
d475 1
a475 1
				BN_print(bp,&a);
d477 1
a477 1
				BN_print(bp,&b);
d479 1
a479 1
				BN_print(bp,&(mont->N));
d482 1
a482 1
			BN_print(bp,&A);
a484 7
		BN_mod_mul(&d,&a,&b,&n,ctx);
		BN_sub(&d,&d,&A);
		if(!BN_is_zero(&d))
		    {
		    fprintf(stderr,"Montgomery multiplication test failed!\n");
		    return 0;
		    }
d487 3
a489 7
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	BN_free(&d);
	BN_free(&A);
	BN_free(&B);
	BN_free(&n);
d493 3
a495 1
int test_mod(BIO *bp, BN_CTX *ctx)
d497 1
a497 1
	BIGNUM *a,*b,*c,*d,*e;
d499 1
a503 2
	d=BN_new();
	e=BN_new();
d505 2
a506 2
	BN_bntest_rand(a,1024,0,0); /**/
	for (i=0; i<num0; i++)
d508 1
a508 1
		BN_bntest_rand(b,450+i*10,0,0); /**/
d511 3
a526 7
		BN_div(d,e,a,b,ctx);
		BN_sub(e,e,c);
		if(!BN_is_zero(e))
		    {
		    fprintf(stderr,"Modulo test failed!\n");
		    return 0;
		    }
a530 2
	BN_free(d);
	BN_free(e);
d534 3
a536 1
int test_mod_mul(BIO *bp, BN_CTX *ctx)
d539 1
a539 1
	int i,j;
d547 2
a548 3
	for (j=0; j<3; j++) {
	BN_bntest_rand(c,1024,0,0); /**/
	for (i=0; i<num0; i++)
d550 2
a551 2
		BN_bntest_rand(a,475+i*10,0,0); /**/
		BN_bntest_rand(b,425+i*11,0,0); /**/
d554 4
a575 10
				if ((a->neg ^ b->neg) && !BN_is_zero(e))
					{
					/* If  (a*b) % c  is negative,  c  must be added
					 * in order to obtain the normalized remainder
					 * (new with OpenSSL 0.9.7, previous versions of
					 * BN_mod_mul could generate negative results)
					 */
					BIO_puts(bp," + ");
					BN_print(bp,c);
					}
a580 9
		BN_mul(d,a,b,ctx);
		BN_sub(d,d,e);
		BN_div(a,b,d,c,ctx);
		if(!BN_is_zero(b))
		    {
		    fprintf(stderr,"Modulo multiply test failed!\n");
		    ERR_print_errors_fp(stderr);
		    return 0;
		    }
a581 1
	}
d590 3
a592 1
int test_mod_exp(BIO *bp, BN_CTX *ctx)
d603 2
a604 2
	BN_bntest_rand(c,30,0,1); /* must be odd for montgomery */
	for (i=0; i<num2; i++)
d606 2
a607 2
		BN_bntest_rand(a,20+i*5,0,0); /**/
		BN_bntest_rand(b,2+i,0,0); /**/
a625 8
		BN_exp(e,a,b,ctx);
		BN_sub(e,e,d);
		BN_div(a,b,e,c,ctx);
		if(!BN_is_zero(b))
		    {
		    fprintf(stderr,"Modulo exponentiation test failed!\n");
		    return 0;
		    }
d635 2
a636 1
int test_exp(BIO *bp, BN_CTX *ctx)
d638 1
a638 1
	BIGNUM *a,*b,*d,*e,*one;
a642 226
	d=BN_new();
	e=BN_new();
	one=BN_new();
	BN_one(one);

	for (i=0; i<num2; i++)
		{
		BN_bntest_rand(a,20+i*5,0,0); /**/
		BN_bntest_rand(b,2+i,0,0); /**/

		if (!BN_exp(d,a,b,ctx))
			return(00);

		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," ^ ");
				BN_print(bp,b);
				BIO_puts(bp," - ");
				}
			BN_print(bp,d);
			BIO_puts(bp,"\n");
			}
		BN_one(e);
		for( ; !BN_is_zero(b) ; BN_sub(b,b,one))
		    BN_mul(e,e,a,ctx);
		BN_sub(e,e,d);
		if(!BN_is_zero(e))
		    {
		    fprintf(stderr,"Exponentiation test failed!\n");
		    return 0;
		    }
		}
	BN_free(a);
	BN_free(b);
	BN_free(d);
	BN_free(e);
	BN_free(one);
	return(1);
	}

static void genprime_cb(int p, int n, void *arg)
	{
	char c='*';

	if (p == 0) c='.';
	if (p == 1) c='+';
	if (p == 2) c='*';
	if (p == 3) c='\n';
	putc(c, stderr);
	fflush(stderr);
	(void)n;
	(void)arg;
	}

int test_kron(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM *a,*b,*r,*t;
	int i;
	int legendre, kronecker;
	int ret = 0;

	a = BN_new();
	b = BN_new();
	r = BN_new();
	t = BN_new();
	if (a == NULL || b == NULL || r == NULL || t == NULL) goto err;
	
	/* We test BN_kronecker(a, b, ctx) just for  b  odd (Jacobi symbol).
	 * In this case we know that if  b  is prime, then BN_kronecker(a, b, ctx)
	 * is congruent to $a^{(b-1)/2}$, modulo $b$ (Legendre symbol).
	 * So we generate a random prime  b  and compare these values
	 * for a number of random  a's.  (That is, we run the Solovay-Strassen
	 * primality test to confirm that  b  is prime, except that we
	 * don't want to test whether  b  is prime but whether BN_kronecker
	 * works.) */

	if (!BN_generate_prime(b, 512, 0, NULL, NULL, genprime_cb, NULL)) goto err;
	b->neg = rand_neg();
	putc('\n', stderr);

	for (i = 0; i < num0; i++)
		{
		if (!BN_bntest_rand(a, 512, 0, 0)) goto err;
		a->neg = rand_neg();

		/* t := (|b|-1)/2  (note that b is odd) */
		if (!BN_copy(t, b)) goto err;
		t->neg = 0;
		if (!BN_sub_word(t, 1)) goto err;
		if (!BN_rshift1(t, t)) goto err;
		/* r := a^t mod b */
		b->neg=0;
		
		if (!BN_mod_exp_recp(r, a, t, b, ctx)) goto err; /* XXX should be BN_mod_exp_recp, but ..._recp triggers a bug that must be fixed */
		b->neg=1;

		if (BN_is_word(r, 1))
			legendre = 1;
		else if (BN_is_zero(r))
			legendre = 0;
		else
			{
			if (!BN_add_word(r, 1)) goto err;
			if (0 != BN_ucmp(r, b))
				{
				fprintf(stderr, "Legendre symbol computation failed\n");
				goto err;
				}
			legendre = -1;
			}
		
		kronecker = BN_kronecker(a, b, ctx);
		if (kronecker < -1) goto err;
		/* we actually need BN_kronecker(a, |b|) */
		if (a->neg && b->neg)
			kronecker = -kronecker;
		
		if (legendre != kronecker)
			{
			fprintf(stderr, "legendre != kronecker; a = ");
			BN_print_fp(stderr, a);
			fprintf(stderr, ", b = ");
			BN_print_fp(stderr, b);
			fprintf(stderr, "\n");
			goto err;
			}

		putc('.', stderr);
		fflush(stderr);
		}

	putc('\n', stderr);
	fflush(stderr);
	ret = 1;
 err:
	if (a != NULL) BN_free(a);
	if (b != NULL) BN_free(b);
	if (r != NULL) BN_free(r);
	if (t != NULL) BN_free(t);
	return ret;
	}

int test_sqrt(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM *a,*p,*r;
	int i, j;
	int ret = 0;

	a = BN_new();
	p = BN_new();
	r = BN_new();
	if (a == NULL || p == NULL || r == NULL) goto err;
	
	for (i = 0; i < 16; i++)
		{
		if (i < 8)
			{
			unsigned primes[8] = { 2, 3, 5, 7, 11, 13, 17, 19 };
			
			if (!BN_set_word(p, primes[i])) goto err;
			}
		else
			{
			if (!BN_set_word(a, 32)) goto err;
			if (!BN_set_word(r, 2*i + 1)) goto err;
		
			if (!BN_generate_prime(p, 256, 0, a, r, genprime_cb, NULL)) goto err;
			putc('\n', stderr);
			}
		p->neg = rand_neg();

		for (j = 0; j < num2; j++)
			{
			/* construct 'a' such that it is a square modulo p,
			 * but in general not a proper square and not reduced modulo p */
			if (!BN_bntest_rand(r, 256, 0, 3)) goto err;
			if (!BN_nnmod(r, r, p, ctx)) goto err;
			if (!BN_mod_sqr(r, r, p, ctx)) goto err;
			if (!BN_bntest_rand(a, 256, 0, 3)) goto err;
			if (!BN_nnmod(a, a, p, ctx)) goto err;
			if (!BN_mod_sqr(a, a, p, ctx)) goto err;
			if (!BN_mul(a, a, r, ctx)) goto err;
			if (rand_neg())
				if (!BN_sub(a, a, p)) goto err;

			if (!BN_mod_sqrt(r, a, p, ctx)) goto err;
			if (!BN_mod_sqr(r, r, p, ctx)) goto err;

			if (!BN_nnmod(a, a, p, ctx)) goto err;

			if (BN_cmp(a, r) != 0)
				{
				fprintf(stderr, "BN_mod_sqrt failed: a = ");
				BN_print_fp(stderr, a);
				fprintf(stderr, ", r = ");
				BN_print_fp(stderr, r);
				fprintf(stderr, ", p = ");
				BN_print_fp(stderr, p);
				fprintf(stderr, "\n");
				goto err;
				}

			putc('.', stderr);
			fflush(stderr);
			}
		
		putc('\n', stderr);
		fflush(stderr);
		}
	ret = 1;
 err:
	if (a != NULL) BN_free(a);
	if (p != NULL) BN_free(p);
	if (r != NULL) BN_free(r);
	return ret;
	}

int test_lshift(BIO *bp,BN_CTX *ctx,BIGNUM *a_)
	{
	BIGNUM *a,*b,*c,*d;
	int i;

	b=BN_new();
a643 1
	d=BN_new();
d646 3
a648 9
	if(a_)
	    a=a_;
	else
	    {
	    a=BN_new();
	    BN_bntest_rand(a,200,0,0); /**/
	    a->neg=rand_neg();
	    }
	for (i=0; i<num0; i++)
a663 16
		BN_mul(d,a,c,ctx);
		BN_sub(d,d,b);
		if(!BN_is_zero(d))
		    {
		    fprintf(stderr,"Left shift test failed!\n");
		    fprintf(stderr,"a=");
		    BN_print_fp(stderr,a);
		    fprintf(stderr,"\nb=");
		    BN_print_fp(stderr,b);
		    fprintf(stderr,"\nc=");
		    BN_print_fp(stderr,c);
		    fprintf(stderr,"\nd=");
		    BN_print_fp(stderr,d);
		    fprintf(stderr,"\n");
		    return 0;
		    }
a667 1
	BN_free(d);
d671 2
a672 1
int test_lshift1(BIO *bp)
d674 1
a674 1
	BIGNUM *a,*b,*c;
a678 1
	c=BN_new();
d680 1
a680 1
	BN_bntest_rand(a,200,0,0); /**/
d682 1
a682 1
	for (i=0; i<num0; i++)
a695 8
		BN_add(c,a,a);
		BN_sub(a,b,c);
		if(!BN_is_zero(a))
		    {
		    fprintf(stderr,"Left shift one test failed!\n");
		    return 0;
		    }
		
a699 1
	BN_free(c);
d703 2
a704 1
int test_rshift(BIO *bp,BN_CTX *ctx)
d706 1
a706 1
	BIGNUM *a,*b,*c,*d,*e;
a711 2
	d=BN_new();
	e=BN_new();
d714 1
a714 1
	BN_bntest_rand(a,200,0,0); /**/
d716 1
a716 1
	for (i=0; i<num0; i++)
a731 7
		BN_div(d,e,a,c,ctx);
		BN_sub(d,d,b);
		if(!BN_is_zero(d))
		    {
		    fprintf(stderr,"Right shift test failed!\n");
		    return 0;
		    }
a735 2
	BN_free(d);
	BN_free(e);
d739 2
a740 1
int test_rshift1(BIO *bp)
d742 1
a742 1
	BIGNUM *a,*b,*c;
a746 1
	c=BN_new();
d748 1
a748 1
	BN_bntest_rand(a,200,0,0); /**/
d750 1
a750 1
	for (i=0; i<num0; i++)
a763 7
		BN_sub(c,a,b);
		BN_sub(c,c,b);
		if(!BN_is_zero(c) && !BN_abs_is_word(c, 1))
		    {
		    fprintf(stderr,"Right shift one test failed!\n");
		    return 0;
		    }
a767 1
	BN_free(c);
d771 1
a771 1
int rand_neg(void)
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d928 1
a928 1
		if (!BN_mod_exp_recp(r, a, t, b, ctx)) goto err;
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d71 4
d99 5
d144 1
a144 1
	if (ctx == NULL) EXIT(1);
d147 1
a147 1
	if (out == NULL) EXIT(1);
d157 1
a157 1
			EXIT(1);
d241 1
a241 1
	EXIT(0);
d248 1
a248 1
	EXIT(1);
d491 1
a491 1
	if (ctx == NULL) EXIT(1);
d729 1
a729 1
			EXIT(1);
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d235 1
a235 1
	                      * the failure, see test_bn in test/Makefile */
@


1.1.1.6
log
@import of openssl-0.9.7j
@
text
@a88 1
int test_mod_exp_mont_consttime(BIO *bp,BN_CTX *ctx);
a215 4
	message(out,"BN_mod_exp_mont_consttime");
	if (!test_mod_exp_mont_consttime(out,ctx)) goto err;
	BIO_flush(out);

a782 51
			return(00);

		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,a);
				BIO_puts(bp," ^ ");
				BN_print(bp,b);
				BIO_puts(bp," % ");
				BN_print(bp,c);
				BIO_puts(bp," - ");
				}
			BN_print(bp,d);
			BIO_puts(bp,"\n");
			}
		BN_exp(e,a,b,ctx);
		BN_sub(e,e,d);
		BN_div(a,b,e,c,ctx);
		if(!BN_is_zero(b))
		    {
		    fprintf(stderr,"Modulo exponentiation test failed!\n");
		    return 0;
		    }
		}
	BN_free(a);
	BN_free(b);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return(1);
	}

int test_mod_exp_mont_consttime(BIO *bp, BN_CTX *ctx)
	{
	BIGNUM *a,*b,*c,*d,*e;
	int i;

	a=BN_new();
	b=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();

	BN_bntest_rand(c,30,0,1); /* must be odd for montgomery */
	for (i=0; i<num2; i++)
		{
		BN_bntest_rand(a,20+i*5,0,0); /**/
		BN_bntest_rand(b,2+i,0,0); /**/

		if (!BN_mod_exp_mont_consttime(d,a,b,c,ctx,NULL))
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@a57 19
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 *
 * Portions of the attached software ("Contribution") are developed by 
 * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.
 *
 * The Contribution is licensed pursuant to the Eric Young open source
 * license provided above.
 *
 * The binary polynomial arithmetic software is originally written by 
 * Sheueling Chang Shantz and Douglas Stebila of Sun Microsystems Laboratories.
 *
 */

/* Until the key-gen callbacks are modified to use newer prototypes, we allow
 * deprecated functions for openssl-internal code */
#ifdef OPENSSL_NO_DEPRECATED
#undef OPENSSL_NO_DEPRECATED
#endif
a81 1
int test_div_word(BIO *bp);
a90 9
int test_gf2m_add(BIO *bp);
int test_gf2m_mod(BIO *bp);
int test_gf2m_mod_mul(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_sqr(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_inv(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_div(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_exp(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_sqrt(BIO *bp,BN_CTX *ctx);
int test_gf2m_mod_solve_quad(BIO *bp,BN_CTX *ctx);
d158 1
a158 1
	(void)BIO_flush(out);
d162 1
a162 1
	(void)BIO_flush(out);
d166 1
a166 1
	(void)BIO_flush(out);
d171 1
a171 1
	(void)BIO_flush(out);
d175 1
a175 1
	(void)BIO_flush(out);
d179 1
a179 1
	(void)BIO_flush(out);
d183 1
a183 1
	(void)BIO_flush(out);
d187 1
a187 1
	(void)BIO_flush(out);
d191 1
a191 1
	(void)BIO_flush(out);
d195 1
a195 5
	(void)BIO_flush(out);

	message(out,"BN_div_word");
	if (!test_div_word(out)) goto err;
	(void)BIO_flush(out);
d199 1
a199 1
	(void)BIO_flush(out);
d203 1
a203 1
	(void)BIO_flush(out);
d207 1
a207 1
	(void)BIO_flush(out);
d211 1
a211 1
	(void)BIO_flush(out);
d215 1
a215 1
	(void)BIO_flush(out);
d219 1
a219 1
	(void)BIO_flush(out);
d223 1
a223 1
	(void)BIO_flush(out);
d227 1
a227 1
	(void)BIO_flush(out);
d231 1
a231 37
	(void)BIO_flush(out);

	message(out,"BN_GF2m_add");
	if (!test_gf2m_add(out)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod");
	if (!test_gf2m_mod(out)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod_mul");
	if (!test_gf2m_mod_mul(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod_sqr");
	if (!test_gf2m_mod_sqr(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod_inv");
	if (!test_gf2m_mod_inv(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod_div");
	if (!test_gf2m_mod_div(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod_exp");
	if (!test_gf2m_mod_exp(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod_sqrt");
	if (!test_gf2m_mod_sqrt(out,ctx)) goto err;
	(void)BIO_flush(out);

	message(out,"BN_GF2m_mod_solve_quad");
	if (!test_gf2m_mod_solve_quad(out,ctx)) goto err;
	(void)BIO_flush(out);
d240 2
a241 2
	                      * the failure, see test_bn in test/Makefile.ssl*/
	(void)BIO_flush(out);
a406 72
static void print_word(BIO *bp,BN_ULONG w)
	{
#ifdef SIXTY_FOUR_BIT
	if (sizeof(w) > sizeof(unsigned long))
		{
		unsigned long	h=(unsigned long)(w>>32),
				l=(unsigned long)(w);

		if (h)	BIO_printf(bp,"%lX%08lX",h,l);
		else	BIO_printf(bp,"%lX",l);
		return;
		}
#endif
	BIO_printf(bp,"%lX",w);
	}

int test_div_word(BIO *bp)
	{
	BIGNUM   a,b;
	BN_ULONG r,s;
	int i;

	BN_init(&a);
	BN_init(&b);

	for (i=0; i<num0; i++)
		{
		do {
			BN_bntest_rand(&a,512,-1,0);
			BN_bntest_rand(&b,BN_BITS2,-1,0);
			s = b.d[0];
		} while (!s);

		BN_copy(&b, &a);
		r = BN_div_word(&b, s);

		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," / ");
				print_word(bp,s);
				BIO_puts(bp," - ");
				}
			BN_print(bp,&b);
			BIO_puts(bp,"\n");

			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," % ");
				print_word(bp,s);
				BIO_puts(bp," - ");
				}
			print_word(bp,r);
			BIO_puts(bp,"\n");
			}
		BN_mul_word(&b,s);
		BN_add_word(&b,r);
		BN_sub(&b,&a,&b);
		if(!BN_is_zero(&b))
		    {
		    fprintf(stderr,"Division (word) test failed!\n");
		    return 0;
		    }
		}
	BN_free(&a);
	BN_free(&b);
	return(1);
	}

d922 1
a922 576
int test_gf2m_add(BIO *bp)
	{
	BIGNUM a,b,c;
	int i, ret = 0;

	BN_init(&a);
	BN_init(&b);
	BN_init(&c);

	for (i=0; i<num0; i++)
		{
		BN_rand(&a,512,0,0);
		BN_copy(&b, BN_value_one());
		a.neg=rand_neg();
		b.neg=rand_neg();
		BN_GF2m_add(&c,&a,&b);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
		if (bp != NULL)
			{
			if (!results)
				{
				BN_print(bp,&a);
				BIO_puts(bp," ^ ");
				BN_print(bp,&b);
				BIO_puts(bp," = ");
				}
			BN_print(bp,&c);
			BIO_puts(bp,"\n");
			}
#endif
		/* Test that two added values have the correct parity. */
		if((BN_is_odd(&a) && BN_is_odd(&c)) || (!BN_is_odd(&a) && !BN_is_odd(&c)))
			{
		    fprintf(stderr,"GF(2^m) addition test (a) failed!\n");
			goto err;
			}
		BN_GF2m_add(&c,&c,&c);
		/* Test that c + c = 0. */
		if(!BN_is_zero(&c))
		    {
		    fprintf(stderr,"GF(2^m) addition test (b) failed!\n");
			goto err;
		    }
		}
	ret = 1;
  err:
	BN_free(&a);
	BN_free(&b);
	BN_free(&c);
	return ret;
	}

int test_gf2m_mod(BIO *bp)
	{
	BIGNUM *a,*b[2],*c,*d,*e;
	int i, j, ret = 0;
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 1024, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod(c, a, b[j]);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp," % ");
					BN_print(bp,b[j]);
					BIO_puts(bp," - ");
					BN_print(bp,c);
					BIO_puts(bp,"\n");
					}
				}
#endif
			BN_GF2m_add(d, a, c);
			BN_GF2m_mod(e, d, b[j]);
			/* Test that a + (a mod p) mod p == 0. */
			if(!BN_is_zero(e))
				{
				fprintf(stderr,"GF(2^m) modulo test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return ret;
	}

int test_gf2m_mod_mul(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d,*e,*f,*g,*h;
	int i, j, ret = 0;
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	f=BN_new();
	g=BN_new();
	h=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 1024, 0, 0);
		BN_bntest_rand(c, 1024, 0, 0);
		BN_bntest_rand(d, 1024, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod_mul(e, a, c, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp," * ");
					BN_print(bp,c);
					BIO_puts(bp," % ");
					BN_print(bp,b[j]);
					BIO_puts(bp," - ");
					BN_print(bp,e);
					BIO_puts(bp,"\n");
					}
				}
#endif
			BN_GF2m_add(f, a, d);
			BN_GF2m_mod_mul(g, f, c, b[j], ctx);
			BN_GF2m_mod_mul(h, d, c, b[j], ctx);
			BN_GF2m_add(f, e, g);
			BN_GF2m_add(f, f, h);
			/* Test that (a+d)*c = a*c + d*c. */
			if(!BN_is_zero(f))
				{
				fprintf(stderr,"GF(2^m) modular multiplication test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	BN_free(f);
	BN_free(g);
	BN_free(h);
	return ret;
	}

int test_gf2m_mod_sqr(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d;
	int i, j, ret = 0;
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 1024, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod_sqr(c, a, b[j], ctx);
			BN_copy(d, a);
			BN_GF2m_mod_mul(d, a, d, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp," ^ 2 % ");
					BN_print(bp,b[j]);
					BIO_puts(bp, " = ");
					BN_print(bp,c);
					BIO_puts(bp,"; a * a = ");
					BN_print(bp,d);
					BIO_puts(bp,"\n");
					}
				}
#endif
			BN_GF2m_add(d, c, d);
			/* Test that a*a = a^2. */
			if(!BN_is_zero(d))
				{
				fprintf(stderr,"GF(2^m) modular squaring test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	return ret;
	}

int test_gf2m_mod_inv(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d;
	int i, j, ret = 0;
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 512, 0, 0); 
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod_inv(c, a, b[j], ctx);
			BN_GF2m_mod_mul(d, a, c, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp, " * ");
					BN_print(bp,c);
					BIO_puts(bp," - 1 % ");
					BN_print(bp,b[j]);
					BIO_puts(bp,"\n");
					}
				}
#endif
			/* Test that ((1/a)*a) = 1. */
			if(!BN_is_one(d))
				{
				fprintf(stderr,"GF(2^m) modular inversion test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	return ret;
	}

int test_gf2m_mod_div(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d,*e,*f;
	int i, j, ret = 0;
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	f=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 512, 0, 0); 
		BN_bntest_rand(c, 512, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod_div(d, a, c, b[j], ctx);
			BN_GF2m_mod_mul(e, d, c, b[j], ctx);
			BN_GF2m_mod_div(f, a, e, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp, " = ");
					BN_print(bp,c);
					BIO_puts(bp," * ");
					BN_print(bp,d);
					BIO_puts(bp, " % ");
					BN_print(bp,b[j]);
					BIO_puts(bp,"\n");
					}
				}
#endif
			/* Test that ((a/c)*c)/a = 1. */
			if(!BN_is_one(f))
				{
				fprintf(stderr,"GF(2^m) modular division test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	BN_free(f);
	return ret;
	}

int test_gf2m_mod_exp(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d,*e,*f;
	int i, j, ret = 0;
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	f=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 512, 0, 0);
		BN_bntest_rand(c, 512, 0, 0);
		BN_bntest_rand(d, 512, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod_exp(e, a, c, b[j], ctx);
			BN_GF2m_mod_exp(f, a, d, b[j], ctx);
			BN_GF2m_mod_mul(e, e, f, b[j], ctx);
			BN_add(f, c, d);
			BN_GF2m_mod_exp(f, a, f, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,a);
					BIO_puts(bp, " ^ (");
					BN_print(bp,c);
					BIO_puts(bp," + ");
					BN_print(bp,d);
					BIO_puts(bp, ") = ");
					BN_print(bp,e);
					BIO_puts(bp, "; - ");
					BN_print(bp,f);
					BIO_puts(bp, " % ");
					BN_print(bp,b[j]);
					BIO_puts(bp,"\n");
					}
				}
#endif
			BN_GF2m_add(f, e, f);
			/* Test that a^(c+d)=a^c*a^d. */
			if(!BN_is_zero(f))
				{
				fprintf(stderr,"GF(2^m) modular exponentiation test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	BN_free(f);
	return ret;
	}

int test_gf2m_mod_sqrt(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d,*e,*f;
	int i, j, ret = 0;
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();
	f=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 512, 0, 0);
		for (j=0; j < 2; j++)
			{
			BN_GF2m_mod(c, a, b[j]);
			BN_GF2m_mod_sqrt(d, a, b[j], ctx);
			BN_GF2m_mod_sqr(e, d, b[j], ctx);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
			if (bp != NULL)
				{
				if (!results)
					{
					BN_print(bp,d);
					BIO_puts(bp, " ^ 2 - ");
					BN_print(bp,a);
					BIO_puts(bp,"\n");
					}
				}
#endif
			BN_GF2m_add(f, c, e);
			/* Test that d^2 = a, where d = sqrt(a). */
			if(!BN_is_zero(f))
				{
				fprintf(stderr,"GF(2^m) modular square root test failed!\n");
				goto err;
				}
			}
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	BN_free(f);
	return ret;
	}

int test_gf2m_mod_solve_quad(BIO *bp,BN_CTX *ctx)
	{
	BIGNUM *a,*b[2],*c,*d,*e;
	int i, j, s = 0, t, ret = 0;
	unsigned int p0[] = {163,7,6,3,0};
	unsigned int p1[] = {193,15,0};

	a=BN_new();
	b[0]=BN_new();
	b[1]=BN_new();
	c=BN_new();
	d=BN_new();
	e=BN_new();

	BN_GF2m_arr2poly(p0, b[0]);
	BN_GF2m_arr2poly(p1, b[1]);

	for (i=0; i<num0; i++)
		{
		BN_bntest_rand(a, 512, 0, 0);
		for (j=0; j < 2; j++)
			{
			t = BN_GF2m_mod_solve_quad(c, a, b[j], ctx);
			if (t)
				{
				s++;
				BN_GF2m_mod_sqr(d, c, b[j], ctx);
				BN_GF2m_add(d, c, d);
				BN_GF2m_mod(e, a, b[j]);
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
				if (bp != NULL)
					{
					if (!results)
						{
						BN_print(bp,c);
						BIO_puts(bp, " is root of z^2 + z = ");
						BN_print(bp,a);
						BIO_puts(bp, " % ");
						BN_print(bp,b[j]);
						BIO_puts(bp, "\n");
						}
					}
#endif
				BN_GF2m_add(e, e, d);
				/* Test that solution of quadratic c satisfies c^2 + c = a. */
				if(!BN_is_zero(e))
					{
					fprintf(stderr,"GF(2^m) modular solve quadratic test failed!\n");
					goto err;
					}

				}
			else 
				{
#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */
				if (bp != NULL)
					{
					if (!results)
						{
						BIO_puts(bp, "There are no roots of z^2 + z = ");
						BN_print(bp,a);
						BIO_puts(bp, " % ");
						BN_print(bp,b[j]);
						BIO_puts(bp, "\n");
						}
					}
#endif
				}
			}
		}
	if (s == 0)
		{	
		fprintf(stderr,"All %i tests of GF(2^m) modular solve quadratic resulted in no roots;\n", num0);
		fprintf(stderr,"this is very unlikely and probably indicates an error.\n");
		goto err;
		}
	ret = 1;
  err:
	BN_free(a);
	BN_free(b[0]);
	BN_free(b[1]);
	BN_free(c);
	BN_free(d);
	BN_free(e);
	return ret;
	}

static int genprime_cb(int p, int n, BN_GENCB *arg)
d932 2
a933 1
	return 1;
a937 1
	BN_GENCB cb;
a947 2

	BN_GENCB_set(&cb, genprime_cb, NULL);
d958 1
a958 1
	if (!BN_generate_prime_ex(b, 512, 0, NULL, NULL, &cb)) goto err;
a1025 1
	BN_GENCB cb;
d1034 1
a1034 3

	BN_GENCB_set(&cb, genprime_cb, NULL);

d1048 1
a1048 1
			if (!BN_generate_prime_ex(p, 256, 0, a, r, &cb)) goto err;
@


1.1.1.8
log
@import of OpenSSL 0.9.8k
@
text
@d929 1
a929 1
			return(0);
d1031 1
a1031 1
			return(0);
@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@d489 1
a489 1
	BIO_printf(bp,BN_HEX_FMT1,w);
a734 2
	if (mont == NULL)
		return 0;
d1030 1
a1030 1
		if (BN_exp(d,a,b,ctx) <= 0)
d1119 2
a1120 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
d1177 2
a1178 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
d1248 2
a1249 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
d1307 2
a1308 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
d1362 2
a1363 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
d1425 2
a1426 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
d1496 2
a1497 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
d1555 2
a1556 2
	int p0[] = {163,7,6,3,0,-1};
	int p1[] = {193,15,0,-1};
@


1.1.1.10
log
@import OpenSSL-1.0.1c
@
text
@d265 1
a265 1
#ifndef OPENSSL_NO_EC2M
d301 1
a301 1
#endif
d1064 1
a1064 1
#ifndef OPENSSL_NO_EC2M
d1639 1
a1639 1
#endif
@


