head	1.19;
access;
symbols
	butholakala:1.16
	openssl_1_0_1_g:1.1.1.10
	OPENBSD_5_5:1.15.0.8
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.4
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	openssl_1_0_1_c:1.1.1.9
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	openssl_1_0_0_f:1.1.1.8
	openssl_1_0_0_e:1.1.1.8
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	openssh_1_0_0_a:1.1.1.8
	OPENBSD_4_8:1.12.0.8
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.4
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	openssl_0_9_8_k:1.1.1.7
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	openssl_0_9_8_j:1.1.1.7
	openssl_0_9_8_h:1.1.1.6
	pre_openssl_0_9_8h:1.10
	OPENBSD_4_4:1.10.0.18
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.16
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.14
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.12
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.10
	OPENBSD_4_0_BASE:1.10
	openssl_0_9_7j:1.1.1.5
	openssl:1.1.1
	OPENBSD_3_9:1.10.0.8
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.6
	OPENBSD_3_8_BASE:1.10
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENSSL_0_9_7D:1.1.1.5
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.04.16.03.24.53;	author beck;	state dead;
branches;
next	1.18;

1.18
date	2014.04.16.01.35.37;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.15.13.41.53;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.13.15.25.29;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2012.04.19.22.57.38;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches
	1.13.4.1
	1.13.8.1;
next	1.12;

1.12
date	2009.01.09.12.15.22;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.25.12.41.02;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.21.12.39.17;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.14.11.18.02;	author markus;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2002.05.15.02.29.10;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.02;	author beck;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	2000.03.19.11.08.29;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.24;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.33;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.33;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.42;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.12.20.43.35;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.34.27;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.20.41.32;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.39;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.01.09.12.13.50;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.10.01.22.54.02;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2012.10.13.21.23.33;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;

1.4.6.1
date	2003.02.23.16.16.02;	author miod;	state Exp;
branches;
next	;

1.6.2.1
date	2003.02.22.22.14.48;	author margarida;	state Exp;
branches;
next	;

1.13.4.1
date	2012.04.22.01.38.23;	author djm;	state Exp;
branches;
next	;

1.13.8.1
date	2012.04.22.01.39.22;	author djm;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Your operating system memory allocation functions are your friend. If they
are not please fix your operating system. Replace mem.c with an API-compatible
wrapper that just calls the system functions and does not allow a one word
modification of a variable in a running shared library to turn on memory
debug functions that expose things that should not be seen.
ok tedu@@
@
text
@/* crypto/mem.c */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <stdio.h>
#include <stdlib.h>
#include <openssl/crypto.h>
#include "cryptlib.h"


static int allow_customize = 1;
/* we provide flexible functions for */
static int allow_customize_debug = 1;/* exchanging memory - related functions at
					* run - time, but this must be done
					* before any blocks are actually
					* allocated; or we'll run into huge
					* problems when malloc/free pairs
					* don't match etc. */

/* the following pointers may be changed as long as 'allow_customize' is set */

static void *(*malloc_func)(size_t) = malloc;
static void
*default_malloc_ex(size_t num, const char *file, int line)
{
	return malloc_func(num);
}
static void *(*malloc_ex_func)(size_t, const char *file, int line) =
    default_malloc_ex;

static void *(*realloc_func)(void *, size_t) = realloc;
static void
*default_realloc_ex(void *str, size_t num, const char *file, int line)
{
	return realloc_func(str, num);
}
static void *(*realloc_ex_func)(void *, size_t, const char *file, int line) =
    default_realloc_ex;

static void (*free_func)(void *) = free;

static void *(*malloc_locked_func)(size_t) = malloc;
static void
*default_malloc_locked_ex(size_t num, const char *file, int line)
{
	return malloc_locked_func(num);
}
static void *(*malloc_locked_ex_func)(size_t, const char *file, int line) =
    default_malloc_locked_ex;

static void (*free_locked_func)(void *) = free;


/* may be changed as long as 'allow_customize_debug' is set */
/* XXX use correct function pointer types */
#ifdef CRYPTO_MDEBUG
/* use default functions from mem_dbg.c */
static void (*malloc_debug_func)(void *, int, const char *, int, int) =
    CRYPTO_dbg_malloc;
static void (*realloc_debug_func)(void *, void *, int, const char *, int, int) =
    CRYPTO_dbg_realloc;
static void (*free_debug_func)(void *, int) = CRYPTO_dbg_free;
static void (*set_debug_options_func)(long) = CRYPTO_dbg_set_options;
static long (*get_debug_options_func)(void) = CRYPTO_dbg_get_options;
#else
/* applications can use CRYPTO_malloc_debug_init() to select above case
 * at run-time */
static void (*malloc_debug_func)(void *, int, const char *, int, int) = NULL;
static void (*realloc_debug_func)(void *, void *, int, const char *, int, int) =
    NULL;
static void (*free_debug_func)(void *, int) = NULL;
static void (*set_debug_options_func)(long) = NULL;
static long (*get_debug_options_func)(void) = NULL;
#endif

int
CRYPTO_set_mem_functions(void *(*m)(size_t), void *(*r)(void *, size_t),
    void (*f)(void *))
{
	/* Dummy call just to ensure OPENSSL_init() gets linked in */
	OPENSSL_init();
	if (!allow_customize)
		return 0;
	if ((m == 0) || (r == 0) || (f == 0))
		return 0;
	malloc_func = m;
	malloc_ex_func = default_malloc_ex;
	realloc_func = r;
	realloc_ex_func = default_realloc_ex;
	free_func = f;
	malloc_locked_func = m;
	malloc_locked_ex_func = default_malloc_locked_ex;
	free_locked_func = f;
	return 1;
}

int
CRYPTO_set_mem_ex_functions(void *(*m)(size_t, const char *, int),
    void *(*r)(void *, size_t, const char *, int), void (*f)(void *))
{
	if (!allow_customize)
		return 0;
	if ((m == 0) || (r == 0) || (f == 0))
		return 0;
	malloc_func = 0;
	malloc_ex_func = m;
	realloc_func = 0;
	realloc_ex_func = r;
	free_func = f;
	malloc_locked_func = 0;
	malloc_locked_ex_func = m;
	free_locked_func = f;
	return 1;
}

int
CRYPTO_set_locked_mem_functions(void *(*m)(size_t), void (*f)(void *))
{
	if (!allow_customize)
		return 0;
	if ((m == NULL) || (f == NULL))
		return 0;
	malloc_locked_func = m;
	malloc_locked_ex_func = default_malloc_locked_ex;
	free_locked_func = f;
	return 1;
}

int
CRYPTO_set_locked_mem_ex_functions(void *(*m)(size_t, const char *, int),
    void (*f)(void *))
{
	if (!allow_customize)
		return 0;
	if ((m == NULL) || (f == NULL))
		return 0;
	malloc_locked_func = 0;
	malloc_locked_ex_func = m;
	free_func = f;
	return 1;
}

int
CRYPTO_set_mem_debug_functions(void (*m)(void *, int, const char *, int, int),
    void (*r)(void *, void *, int, const char *, int, int),
    void (*f)(void *, int), void (*so)(long), long (*go)(void))
{
	if (!allow_customize_debug)
		return 0;
	OPENSSL_init();
	malloc_debug_func = m;
	realloc_debug_func = r;
	free_debug_func = f;
	set_debug_options_func = so;
	get_debug_options_func = go;
	return 1;
}


void
CRYPTO_get_mem_functions(void *(**m)(size_t), void *(**r)(void *, size_t),
    void (**f)(void *))
{
	if (m != NULL)
		*m = (malloc_ex_func == default_malloc_ex) ? malloc_func : 0;
	if (r != NULL)
		*r = (realloc_ex_func == default_realloc_ex) ? realloc_func : 0;
	if (f != NULL)
		*f = free_func;
}

void
CRYPTO_get_mem_ex_functions(void *(**m)(size_t, const char *, int),
    void *(**r)(void *, size_t, const char *, int), void (**f)(void *))
{
	if (m != NULL)
		*m = (malloc_ex_func != default_malloc_ex) ? malloc_ex_func : 0;
	if (r != NULL)
		*r = (realloc_ex_func != default_realloc_ex) ?
		    realloc_ex_func : 0;
	if (f != NULL)
		*f = free_func;
}

void
CRYPTO_get_locked_mem_functions(void *(**m)(size_t), void (**f)(void *))
{
	if (m != NULL)
		*m = (malloc_locked_ex_func == default_malloc_locked_ex) ?
		    malloc_locked_func : 0;
	if (f != NULL)
		*f = free_locked_func;
}

void
CRYPTO_get_locked_mem_ex_functions(void *(**m)(size_t, const char *, int),
    void (**f)(void *))
{
	if (m != NULL)
		*m = (malloc_locked_ex_func != default_malloc_locked_ex) ?
		    malloc_locked_ex_func : 0;
	if (f != NULL)
		*f = free_locked_func;
}

void
CRYPTO_get_mem_debug_functions(void (**m)(void *, int, const char *, int, int),
    void (**r)(void *, void *, int, const char *, int, int),
    void (**f)(void *, int), void (**so)(long), long (**go)(void))
{
	if (m != NULL)
		*m = malloc_debug_func;
	if (r != NULL)
		*r = realloc_debug_func;
	if (f != NULL)
		*f = free_debug_func;
	if (so != NULL)
		*so = set_debug_options_func;
	if (go != NULL)
		*go = get_debug_options_func;
}


void *
CRYPTO_malloc_locked(int num, const char *file, int line)
{
	void *ret = NULL;

	if (num <= 0)
		return NULL;

	allow_customize = 0;
	if (malloc_debug_func != NULL) {
		allow_customize_debug = 0;
		malloc_debug_func(NULL, num, file, line, 0);
	}
	ret = malloc_locked_ex_func(num, file, line);
#ifdef LEVITTE_DEBUG_MEM
	fprintf(stderr, "LEVITTE_DEBUG_MEM:         > 0x%p (%d)\n", ret, num);
#endif
	if (malloc_debug_func != NULL)
		malloc_debug_func(ret, num, file, line, 1);

	return ret;
}

void
CRYPTO_free_locked(void *str)
{
	if (free_debug_func != NULL)
		free_debug_func(str, 0);
#ifdef LEVITTE_DEBUG_MEM
	fprintf(stderr, "LEVITTE_DEBUG_MEM:         < 0x%p\n", str);
#endif
	free_locked_func(str);
	if (free_debug_func != NULL)
		free_debug_func(NULL, 1);
}

void *
CRYPTO_malloc(int num, const char *file, int line)
{
	void *ret = NULL;

	if (num <= 0)
		return NULL;

	allow_customize = 0;
	if (malloc_debug_func != NULL) {
		allow_customize_debug = 0;
		malloc_debug_func(NULL, num, file, line, 0);
	}
	ret = malloc_ex_func(num, file, line);
#ifdef LEVITTE_DEBUG_MEM
	fprintf(stderr, "LEVITTE_DEBUG_MEM:         > 0x%p (%d)\n", ret, num);
#endif
	if (malloc_debug_func != NULL)
		malloc_debug_func(ret, num, file, line, 1);

	return ret;
}

char *
CRYPTO_strdup(const char *str, const char *file, int line)
{
	size_t len = strlen(str) + 1;
	char *ret = CRYPTO_malloc(len, file, line);

	memcpy(ret, str, len);
	return ret;
}

void *
CRYPTO_realloc(void *str, int num, const char *file, int line)
{
	void *ret = NULL;

	if (str == NULL)
		return CRYPTO_malloc(num, file, line);

	if (num <= 0)
		return NULL;

	if (realloc_debug_func != NULL)
		realloc_debug_func(str, NULL, num, file, line, 0);
	ret = realloc_ex_func(str, num, file, line);
#ifdef LEVITTE_DEBUG_MEM
	fprintf(stderr, "LEVITTE_DEBUG_MEM:         | 0x%p -> 0x%p (%d)\n", str, ret, num);
#endif
	if (realloc_debug_func != NULL)
		realloc_debug_func(str, ret, num, file, line, 1);

	return ret;
}

void *
CRYPTO_realloc_clean(void *str, int old_len, int num, const char *file,
int line)
{
	void *ret = NULL;

	if (str == NULL)
		return CRYPTO_malloc(num, file, line);

	if (num <= 0)
		return NULL;

	/* We don't support shrinking the buffer. Note the memcpy that copies
	 * |old_len| bytes to the new buffer, below. */
	if (num < old_len)
		return NULL;

	if (realloc_debug_func != NULL)
		realloc_debug_func(str, NULL, num, file, line, 0);
	ret = malloc_ex_func(num, file, line);
	if (ret) {
		memcpy(ret, str, old_len);
		OPENSSL_cleanse(str, old_len);
		free_func(str);
	}
#ifdef LEVITTE_DEBUG_MEM
	fprintf(stderr,
	    "LEVITTE_DEBUG_MEM:         | 0x%p -> 0x%p (%d)\n",
	    str, ret, num);
#endif
	if (realloc_debug_func != NULL)
		realloc_debug_func(str, ret, num, file, line, 1);

	return ret;
}

void
CRYPTO_free(void *str)
{
	if (free_debug_func != NULL)
		free_debug_func(str, 0);
#ifdef LEVITTE_DEBUG_MEM
	fprintf(stderr, "LEVITTE_DEBUG_MEM:         < 0x%p\n", str);
#endif
	free_func(str);
	if (free_debug_func != NULL)
		free_debug_func(NULL, 1);
}

void *
CRYPTO_remalloc(void *a, int num, const char *file, int line)
{
	if (a != NULL)
		OPENSSL_free(a);
	a = (char *)OPENSSL_malloc(num);
	return (a);
}

void
CRYPTO_set_mem_debug_options(long bits)
{
	if (set_debug_options_func != NULL)
		set_debug_options_func(bits);
}

long
CRYPTO_get_mem_debug_options(void)
{
	if (get_debug_options_func != NULL)
		return get_debug_options_func();
	return 0;
}
@


1.18
log
@Remove disabled code that wouldn't work now that cleanse_ptr was
removed.

Also, fix some nearby KNF nits that were bothering me.

ok beck
@
text
@@


1.17
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@d183 2
a184 1
int CRYPTO_set_locked_mem_ex_functions(void *(*m)(size_t, const char *, int),
d226 2
a227 1
void CRYPTO_get_mem_ex_functions(void *(**m)(size_t, const char *, int),
d249 2
a250 1
void CRYPTO_get_locked_mem_ex_functions(void *(**m)(size_t, const char *, int),
d278 2
a279 2
void
*CRYPTO_malloc_locked(int num, const char *file, int line)
a297 10
#ifndef OPENSSL_CPUID_OBJ
        /* Create a dependency on the value of 'cleanse_ctr' so our memory
         * sanitisation function can't be optimised out. NB: We only do
         * this for >2Kb so the overhead doesn't bother us. */
	if (ret && (num > 2048)) {
		extern unsigned char cleanse_ctr;
		((unsigned char *)ret)[0] = cleanse_ctr;
	}
#endif

d314 2
a315 2
void
*CRYPTO_malloc(int num, const char *file, int line)
a333 10
#ifndef OPENSSL_CPUID_OBJ
        /* Create a dependency on the value of 'cleanse_ctr' so our memory
         * sanitisation function can't be optimised out. NB: We only do
         * this for >2Kb so the overhead doesn't bother us. */
	if (ret && (num > 2048)) {
		extern unsigned char cleanse_ctr;
		((unsigned char *)ret)[0] = cleanse_ctr;
	}
#endif

d337 2
a338 2
char
*CRYPTO_strdup(const char *str, const char *file, int line)
d347 2
a348 2
void
*CRYPTO_realloc(void *str, int num, const char *file, int line)
d370 2
a371 2
void
*CRYPTO_realloc_clean(void *str, int old_len, int num, const char *file,
d419 2
a420 2
void
*CRYPTO_remalloc(void *a, int num, const char *file, int line)
@


1.16
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d65 8
a72 9
static int allow_customize = 1;      /* we provide flexible functions for */
static int allow_customize_debug = 1;/* exchanging memory-related functions at
                                      * run-time, but this must be done
                                      * before any blocks are actually
                                      * allocated; or we'll run into huge
                                      * problems when malloc/free pairs
                                      * don't match etc. */


d76 28
a103 22
static void *(*malloc_func)(size_t)         = malloc;
static void *default_malloc_ex(size_t num, const char *file, int line)
	{ return malloc_func(num); }
static void *(*malloc_ex_func)(size_t, const char *file, int line)
        = default_malloc_ex;

static void *(*realloc_func)(void *, size_t)= realloc;
static void *default_realloc_ex(void *str, size_t num,
        const char *file, int line)
	{ return realloc_func(str,num); }
static void *(*realloc_ex_func)(void *, size_t, const char *file, int line)
        = default_realloc_ex;

static void (*free_func)(void *)            = free;

static void *(*malloc_locked_func)(size_t)  = malloc;
static void *default_malloc_locked_ex(size_t num, const char *file, int line)
	{ return malloc_locked_func(num); }
static void *(*malloc_locked_ex_func)(size_t, const char *file, int line)
        = default_malloc_locked_ex;

static void (*free_locked_func)(void *)     = free;
d105 1
d112 5
a116 5
static void (*malloc_debug_func)(void *,int,const char *,int,int)
	= CRYPTO_dbg_malloc;
static void (*realloc_debug_func)(void *,void *,int,const char *,int,int)
	= CRYPTO_dbg_realloc;
static void (*free_debug_func)(void *,int) = CRYPTO_dbg_free;
d122 4
a125 4
static void (*malloc_debug_func)(void *,int,const char *,int,int) = NULL;
static void (*realloc_debug_func)(void *,void *,int,const char *,int,int)
	= NULL;
static void (*free_debug_func)(void *,int) = NULL;
d130 4
a133 3
int CRYPTO_set_mem_functions(void *(*m)(size_t), void *(*r)(void *, size_t),
	void (*f)(void *))
	{
d140 8
a147 5
	malloc_func=m; malloc_ex_func=default_malloc_ex;
	realloc_func=r; realloc_ex_func=default_realloc_ex;
	free_func=f;
	malloc_locked_func=m; malloc_locked_ex_func=default_malloc_locked_ex;
	free_locked_func=f;
d149 1
a149 1
	}
d151 4
a154 5
int CRYPTO_set_mem_ex_functions(
        void *(*m)(size_t,const char *,int),
        void *(*r)(void *, size_t,const char *,int),
	void (*f)(void *))
	{
d159 8
a166 5
	malloc_func=0; malloc_ex_func=m;
	realloc_func=0; realloc_ex_func=r;
	free_func=f;
	malloc_locked_func=0; malloc_locked_ex_func=m;
	free_locked_func=f;
d168 1
a168 1
	}
d170 3
a172 2
int CRYPTO_set_locked_mem_functions(void *(*m)(size_t), void (*f)(void *))
	{
d177 3
a179 2
	malloc_locked_func=m; malloc_locked_ex_func=default_malloc_locked_ex;
	free_locked_func=f;
d181 1
a181 1
	}
d183 3
a185 4
int CRYPTO_set_locked_mem_ex_functions(
        void *(*m)(size_t,const char *,int),
        void (*f)(void *))
	{
d190 3
a192 2
	malloc_locked_func=0; malloc_locked_ex_func=m;
	free_func=f;
d194 1
a194 1
	}
d196 5
a200 6
int CRYPTO_set_mem_debug_functions(void (*m)(void *,int,const char *,int,int),
				   void (*r)(void *,void *,int,const char *,int,int),
				   void (*f)(void *,int),
				   void (*so)(long),
				   long (*go)(void))
	{
d204 5
a208 5
	malloc_debug_func=m;
	realloc_debug_func=r;
	free_debug_func=f;
	set_debug_options_func=so;
	get_debug_options_func=go;
d210 1
a210 53
	}


void CRYPTO_get_mem_functions(void *(**m)(size_t), void *(**r)(void *, size_t),
	void (**f)(void *))
	{
	if (m != NULL) *m = (malloc_ex_func == default_malloc_ex) ? 
	                     malloc_func : 0;
	if (r != NULL) *r = (realloc_ex_func == default_realloc_ex) ? 
	                     realloc_func : 0;
	if (f != NULL) *f=free_func;
	}

void CRYPTO_get_mem_ex_functions(
        void *(**m)(size_t,const char *,int),
        void *(**r)(void *, size_t,const char *,int),
	void (**f)(void *))
	{
	if (m != NULL) *m = (malloc_ex_func != default_malloc_ex) ?
	                    malloc_ex_func : 0;
	if (r != NULL) *r = (realloc_ex_func != default_realloc_ex) ?
	                    realloc_ex_func : 0;
	if (f != NULL) *f=free_func;
	}

void CRYPTO_get_locked_mem_functions(void *(**m)(size_t), void (**f)(void *))
	{
	if (m != NULL) *m = (malloc_locked_ex_func == default_malloc_locked_ex) ? 
	                     malloc_locked_func : 0;
	if (f != NULL) *f=free_locked_func;
	}

void CRYPTO_get_locked_mem_ex_functions(
        void *(**m)(size_t,const char *,int),
        void (**f)(void *))
	{
	if (m != NULL) *m = (malloc_locked_ex_func != default_malloc_locked_ex) ?
	                    malloc_locked_ex_func : 0;
	if (f != NULL) *f=free_locked_func;
	}

void CRYPTO_get_mem_debug_functions(void (**m)(void *,int,const char *,int,int),
				    void (**r)(void *,void *,int,const char *,int,int),
				    void (**f)(void *,int),
				    void (**so)(long),
				    long (**go)(void))
	{
	if (m != NULL) *m=malloc_debug_func;
	if (r != NULL) *r=realloc_debug_func;
	if (f != NULL) *f=free_debug_func;
	if (so != NULL) *so=set_debug_options_func;
	if (go != NULL) *go=get_debug_options_func;
	}
d213 65
a277 2
void *CRYPTO_malloc_locked(int num, const char *file, int line)
	{
d280 2
a281 1
	if (num <= 0) return NULL;
d284 1
a284 2
	if (malloc_debug_func != NULL)
		{
d287 2
a288 2
		}
	ret = malloc_locked_ex_func(num,file,line);
d299 2
a300 2
        if(ret && (num > 2048))
	{	extern unsigned char cleanse_ctr;
d306 1
a306 1
	}
d308 3
a310 2
void CRYPTO_free_locked(void *str)
	{
d319 1
a319 1
	}
d321 3
a323 2
void *CRYPTO_malloc(int num, const char *file, int line)
	{
d326 2
a327 1
	if (num <= 0) return NULL;
d330 1
a330 2
	if (malloc_debug_func != NULL)
		{
d333 2
a334 2
		}
	ret = malloc_ex_func(num,file,line);
d345 3
a347 3
        if(ret && (num > 2048))
	{	extern unsigned char cleanse_ctr;
                ((unsigned char *)ret)[0] = cleanse_ctr;
d352 6
a357 4
	}
char *CRYPTO_strdup(const char *str, const char *file, int line)
	{
	size_t len = strlen(str)+1;
d362 1
a362 1
	}
d364 3
a366 2
void *CRYPTO_realloc(void *str, int num, const char *file, int line)
	{
d372 2
a373 1
	if (num <= 0) return NULL;
d377 1
a377 1
	ret = realloc_ex_func(str,num,file,line);
d385 1
a385 1
	}
d387 4
a390 3
void *CRYPTO_realloc_clean(void *str, int old_len, int num, const char *file,
			   int line)
	{
d396 2
a397 1
	if (num <= 0) return NULL;
d401 2
a402 1
	if (num < old_len) return NULL;
d406 4
a409 5
	ret=malloc_ex_func(num,file,line);
	if(ret)
		{
		memcpy(ret,str,old_len);
		OPENSSL_cleanse(str,old_len);
d411 1
a411 1
		}
d414 2
a415 2
		"LEVITTE_DEBUG_MEM:         | 0x%p -> 0x%p (%d)\n",
		str, ret, num);
d421 1
a421 1
	}
d423 3
a425 2
void CRYPTO_free(void *str)
	{
d434 1
a434 1
	}
d436 12
a447 9
void *CRYPTO_remalloc(void *a, int num, const char *file, int line)
	{
	if (a != NULL) OPENSSL_free(a);
	a=(char *)OPENSSL_malloc(num);
	return(a);
	}

void CRYPTO_set_mem_debug_options(long bits)
	{
d450 1
a450 1
	}
d452 3
a454 2
long CRYPTO_get_mem_debug_options(void)
	{
d458 1
a458 1
	}
@


1.15
log
@resolve conflicts
@
text
@a123 1

d127 1
@


1.14
log
@cherrypick fix for CVE-2012-2110: libcrypto ASN.1 parsing heap overflow
ok miod@@ deraadt@@
@
text
@d128 1
d190 1
@


1.13
log
@resolve conflicts, fix local changes
@
text
@d365 4
@


1.13.8.1
log
@MFC

mem.c
revision 1.14
date: 2012/04/19 22:57:38;  author: djm;  state: Exp;  lines: +4 -0
cherrypick fix for CVE-2012-2110: libcrypto ASN.1 parsing heap overflow
ok miod@@ deraadt@@

asn1/a_d2i_fp.c
revision 1.6
date: 2012/04/19 22:57:38;  author: djm;  state: Exp;  lines: +40 -14
cherrypick fix for CVE-2012-2110: libcrypto ASN.1 parsing heap overflow
ok miod@@ deraadt@@

buffer/buffer.c
revision 1.9
date: 2012/04/19 22:57:38;  author: djm;  state: Exp;  lines: +17 -0
cherrypick fix for CVE-2012-2110: libcrypto ASN.1 parsing heap overflow
ok miod@@ deraadt@@
@
text
@a364 4
	/* We don't support shrinking the buffer. Note the memcpy that copies
	 * |old_len| bytes to the new buffer, below. */
	if (num < old_len) return NULL;

@


1.13.4.1
log
@MFC

mem.c
revision 1.14
date: 2012/04/19 22:57:38;  author: djm;  state: Exp;  lines: +4 -0
cherrypick fix for CVE-2012-2110: libcrypto ASN.1 parsing heap overflow
ok miod@@ deraadt@@

asn1/a_d2i_fp.c
revision 1.6
date: 2012/04/19 22:57:38;  author: djm;  state: Exp;  lines: +40 -14
cherrypick fix for CVE-2012-2110: libcrypto ASN.1 parsing heap overflow
ok miod@@ deraadt@@

buffer/buffer.c
revision 1.9
date: 2012/04/19 22:57:38;  author: djm;  state: Exp;  lines: +17 -0
cherrypick fix for CVE-2012-2110: libcrypto ASN.1 parsing heap overflow
ok miod@@ deraadt@@
@
text
@a364 4
	/* We don't support shrinking the buffer. Note the memcpy that copies
	 * |old_len| bytes to the new buffer, below. */
	if (num < old_len) return NULL;

@


1.12
log
@resolve conflicts
@
text
@d104 1
a104 1
#if defined(CRYPTO_MDEBUG) && !defined(OPENSSL_FIPS)
a112 8

static int  (*push_info_func)(const char *info, const char *file, int line)
	= CRYPTO_dbg_push_info;
static int  (*pop_info_func)(void)
	= CRYPTO_dbg_pop_info;
static int (*remove_all_info_func)(void)
	= CRYPTO_dbg_remove_all_info;

a121 7


static int  (*push_info_func)(const char *info, const char *file, int line)
	= NULL;
static int  (*pop_info_func)(void) = NULL;
static int (*remove_all_info_func)(void) = NULL;

a196 9
void CRYPTO_set_mem_info_functions(
	int  (*push_info_fn)(const char *info, const char *file, int line),
	int  (*pop_info_fn)(void),
	int (*remove_all_info_fn)(void))
	{
	push_info_func = push_info_fn;
	pop_info_func = pop_info_fn;
	remove_all_info_func = remove_all_info_fn;
	}
a252 1
	extern unsigned char cleanse_ctr;
d269 1
d274 1
d276 2
a296 1
	extern unsigned char cleanse_ctr;
d313 1
d318 1
d320 2
d325 8
a414 21
	}

int CRYPTO_push_info_(const char *info, const char *file, int line)
	{
	if (push_info_func)
		return push_info_func(info, file, line);
	return 1;
	}

int CRYPTO_pop_info(void)
	{
	if (pop_info_func)
		return pop_info_func();
	return 1;
	}

int CRYPTO_remove_all_info(void)
	{
	if (remove_all_info_func)
		return remove_all_info_func();
	return 1;
@


1.11
log
@resolve conflicts
@
text
@d104 1
a104 1
#ifdef CRYPTO_MDEBUG
d113 8
d130 7
d212 9
d425 21
@


1.10
log
@merge 0.9.7d
@
text
@d327 2
a328 2
 	if (num <= 0) return NULL;
 
d348 3
a350 3
 
 	if (num <= 0) return NULL;
 
@


1.9
log
@don't destroy old pointer if realloc fails; from Daniel Lucq; ok deraadt@@
@
text
@d255 1
a255 1
	if (num < 0) return NULL;
d296 1
a296 1
	if (num < 0) return NULL;
d327 1
a327 1
 	if (num < 0) return NULL;
d349 1
a349 1
 	if (num < 0) return NULL;
@


1.8
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d355 1
d357 3
a359 2
	OPENSSL_cleanse(str,old_len);
	free_func(str);
d361 3
a363 1
	fprintf(stderr, "LEVITTE_DEBUG_MEM:         | 0x%p -> 0x%p (%d)\n", str, ret, num);
@


1.7
log
@check for size < 0 when allocating memory, from openssl (-r1.34)
@
text
@d253 1
d270 6
d294 1
d311 6
d327 18
a344 1
	if (num < 0) return NULL;
d346 5
d353 5
a357 1
	ret = realloc_ex_func(str,num,file,line);
a384 1

@


1.6
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d254 2
d288 2
d312 2
@


1.6.2.1
log
@Pull patch from current:
Fix by markus@@

check for size < 0 when allocating memory, from openssl (-r1.34)

markus@@ deraadt@@ ok
@
text
@a253 2
	if (num < 0) return NULL;

a285 2
	if (num < 0) return NULL;

a307 2

	if (num < 0) return NULL;
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d306 3
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d73 4
a76 3
/* may be changed as long as `allow_customize' is set */
static void *(*malloc_locked_func)(size_t)  = malloc;
static void (*free_locked_func)(void *)     = free;
d78 5
d84 6
d92 11
a102 1
/* may be changed as long as `allow_customize_debug' is set */
d130 18
a147 1
	if ((m == NULL) || (r == NULL) || (f == NULL))
d149 2
a150 2
	malloc_func=m;
	realloc_func=r;
d152 1
a152 1
	malloc_locked_func=m;
d163 1
a163 1
	malloc_locked_func=m;
d168 13
d197 1
d201 16
a216 2
	if (m != NULL) *m=malloc_func;
	if (r != NULL) *r=realloc_func;
d222 11
a232 1
	if (m != NULL) *m=malloc_locked_func;
d260 3
a262 3
	ret = malloc_locked_func(num);
#ifdef LEVITTE_DEBUG
	fprintf(stderr, "LEVITTE_DEBUG:         > 0x%p (%d)\n", ret, num);
d274 2
a275 2
#ifdef LEVITTE_DEBUG
	fprintf(stderr, "LEVITTE_DEBUG:         < 0x%p\n", str);
d292 3
a294 3
	ret = malloc_func(num);
#ifdef LEVITTE_DEBUG
	fprintf(stderr, "LEVITTE_DEBUG:         > 0x%p (%d)\n", ret, num);
d308 3
a310 3
	ret = realloc_func(str,num);
#ifdef LEVITTE_DEBUG
	fprintf(stderr, "LEVITTE_DEBUG:         | 0x%p -> 0x%p (%d)\n", str, ret, num);
d322 2
a323 2
#ifdef LEVITTE_DEBUG
	fprintf(stderr, "LEVITTE_DEBUG:         < 0x%p\n", str);
@


1.4.6.1
log
@MFC (markus@@):
check for size < 0 when allocating memory, from openssl (-r1.34)
@
text
@a176 2
	if (num < 0) return NULL;

a208 2
	if (num < 0) return NULL;

a227 2

	if (num < 0) return NULL;
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d83 8
a90 6
  /* use default functions from mem_dbg.c */
  static void (*malloc_debug_func)()= (void (*)())CRYPTO_dbg_malloc;
  static void (*realloc_debug_func)()= (void (*)())CRYPTO_dbg_realloc;
  static void (*free_debug_func)()= (void (*)())CRYPTO_dbg_free;
  static void (*set_debug_options_func)()= (void (*)())CRYPTO_dbg_set_options;
  static long (*get_debug_options_func)()= (long (*)())CRYPTO_dbg_get_options;
d92 8
a99 7
  /* applications can use CRYPTO_malloc_debug_init() to select above case
   * at run-time */
  static void (*malloc_debug_func)()= NULL;
  static void (*realloc_debug_func)()= NULL;
  static void (*free_debug_func)()= NULL;
  static void (*set_debug_options_func)()= NULL;
  static long (*get_debug_options_func)()= NULL;
d129 5
a133 1
int CRYPTO_set_mem_debug_functions(void (*m)(), void (*r)(), void (*f)(),void (*so)(),long (*go)())
d159 5
a163 1
void CRYPTO_get_mem_debug_functions(void (**m)(), void (**r)(), void (**f)(),void (**so)(),long (**go)())
d175 1
a175 1
	char *ret = NULL;
d207 1
a207 1
	char *ret = NULL;
d227 1
a227 1
	char *ret = NULL;
d255 2
a256 2
	if (a != NULL) Free(a);
	a=(char *)Malloc(num);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@a61 6
#ifdef CRYPTO_MDEBUG_TIME
# include <time.h>	
#endif
#include <openssl/buffer.h>
#include <openssl/bio.h>
#include <openssl/lhash.h>
d64 33
a96 31
/* #ifdef CRYPTO_MDEBUG */
/* static int mh_mode=CRYPTO_MEM_CHECK_ON; */
/* #else */
static int mh_mode=CRYPTO_MEM_CHECK_OFF;
/* #endif */
/* State CRYPTO_MEM_CHECK_ON exists only temporarily when the library
 * thinks that certain allocations should not be checked (e.g. the data
 * structures used for memory checking).  It is not suitable as an initial
 * state: the library will unexpectedly enable memory checking when it
 * executes one of those sections that want to disable checking
 * temporarily.
 *
 * State CRYPTO_MEM_CHECK_ENABLE without ..._ON makes no sense whatsoever.
 */

static unsigned long order=0;

static LHASH *mh=NULL;

typedef struct mem_st
	{
	char *addr;
	int num;
	const char *file;
	int line;
#ifdef CRYPTO_MDEBUG_THREAD
	unsigned long thread;
#endif
	unsigned long order;
#ifdef CRYPTO_MDEBUG_TIME
	time_t time;
a97 32
	} MEM;

int CRYPTO_mem_ctrl(int mode)
	{
	int ret=mh_mode;

	CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
	switch (mode)
		{
	/* for applications: */
	case CRYPTO_MEM_CHECK_ON: /* aka MemCheck_start() */
		mh_mode = CRYPTO_MEM_CHECK_ON|CRYPTO_MEM_CHECK_ENABLE;
		break;
	case CRYPTO_MEM_CHECK_OFF: /* aka MemCheck_stop() */
		mh_mode = 0;
		break;

	/* switch off temporarily (for library-internal use): */
	case CRYPTO_MEM_CHECK_DISABLE: /* aka MemCheck_off() */
		mh_mode&= ~CRYPTO_MEM_CHECK_ENABLE;
		break;
	case CRYPTO_MEM_CHECK_ENABLE: /* aka MemCheck_on() */
		if (mh_mode&CRYPTO_MEM_CHECK_ON)
			mh_mode|=CRYPTO_MEM_CHECK_ENABLE;
		break;

	default:
		break;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
	return(ret);
	}
a98 10
static int mem_cmp(MEM *a, MEM *b)
	{
	return(a->addr - b->addr);
	}

static unsigned long mem_hash(MEM *a)
	{
	unsigned long ret;

	ret=(unsigned long)a->addr;
d100 7
a106 13
	ret=ret*17851+(ret>>14)*7+(ret>>4)*251;
	return(ret);
	}

static char *(*malloc_locked_func)()=(char *(*)())malloc;
static void (*free_locked_func)()=(void (*)())free;
static char *(*malloc_func)()=	(char *(*)())malloc;
static char *(*realloc_func)()=	(char *(*)())realloc;
static void (*free_func)()=	(void (*)())free;

void CRYPTO_set_mem_functions(char *(*m)(), char *(*r)(), void (*f)())
	{
	if ((m == NULL) || (r == NULL) || (f == NULL)) return;
d112 1
d115 1
a115 1
void CRYPTO_set_locked_mem_functions(char *(*m)(), void (*f)())
d117 4
a120 1
	if ((m == NULL) || (f == NULL)) return;
d123 1
d126 14
a139 1
void CRYPTO_get_mem_functions(char *(**m)(), char *(**r)(), void (**f)())
d146 1
a146 1
void CRYPTO_get_locked_mem_functions(char *(**m)(), void (**f)())
d152 1
a152 1
void *CRYPTO_malloc_locked(int num)
d154 5
a158 1
	return(malloc_locked_func(num));
a160 4
void CRYPTO_free_locked(void *str)
	{
	free_locked_func(str);
	}
d162 1
a162 1
void *CRYPTO_malloc(int num)
d164 1
a164 2
	return(malloc_func(num));
	}
d166 12
a177 4
void *CRYPTO_realloc(void *str, int num)
	{
	return(realloc_func(str,num));
	}
d179 1
a179 3
void CRYPTO_free(void *str)
	{
	free_func(str);
d182 1
a182 2
static unsigned long break_order_num=0;
void *CRYPTO_dbg_malloc(int num, const char *file, int line)
d184 4
a187 33
	char *ret;
	MEM *m,*mm;

	if ((ret=malloc_func(num)) == NULL)
		return(NULL);

	if (mh_mode & CRYPTO_MEM_CHECK_ENABLE)
		{
		MemCheck_off();
		if ((m=(MEM *)Malloc(sizeof(MEM))) == NULL)
			{
			Free(ret);
			MemCheck_on();
			return(NULL);
			}
		CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
		if (mh == NULL)
			{
			if ((mh=lh_new(mem_hash,mem_cmp)) == NULL)
				{
				Free(ret);
				Free(m);
				ret=NULL;
				goto err;
				}
			}

		m->addr=ret;
		m->file=file;
		m->line=line;
		m->num=num;
#ifdef CRYPTO_MDEBUG_THREAD
		m->thread=CRYPTO_thread_id();
d189 3
a191 19
		if (order == break_order_num)
			{
			/* BREAK HERE */
			m->order=order;
			}
		m->order=order++;
#ifdef CRYPTO_MDEBUG_TIME
		m->time=time(NULL);
#endif
		if ((mm=(MEM *)lh_insert(mh,(char *)m)) != NULL)
			{
			/* Not good, but don't sweat it */
			Free(mm);
			}
err:
		CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
		MemCheck_on();
		}
	return(ret);
d194 1
a194 1
void CRYPTO_dbg_free(void *addr)
d196 1
a196 1
	MEM m,*mp;
d198 2
a199 1
	if ((mh_mode & CRYPTO_MEM_CHECK_ENABLE) && (mh != NULL))
d201 2
a202 8
		MemCheck_off();
		CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
		m.addr=addr;
		mp=(MEM *)lh_delete(mh,(char *)&m);
		if (mp != NULL)
			Free(mp);
		CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
		MemCheck_on();
d204 8
a211 1
	free_func(addr);
d214 1
a214 1
void *CRYPTO_dbg_realloc(void *addr, int num, const char *file, int line)
d216 1
a216 2
	char *ret;
	MEM m,*mp;
d218 8
a225 2
	ret=realloc_func(addr,num);
	if (ret == addr) return(ret);
d227 1
a227 16
	if (mh_mode & CRYPTO_MEM_CHECK_ENABLE)
		{
		MemCheck_off();
		if (ret == NULL) return(NULL);
		m.addr=addr;
		CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
		mp=(MEM *)lh_delete(mh,(char *)&m);
		if (mp != NULL)
			{
			mp->addr=ret;
			lh_insert(mh,(char *)mp);
			}
		CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
		MemCheck_on();
		}
	return(ret);
d230 1
a230 1
void *CRYPTO_remalloc(void *a, int n)
d232 8
a239 3
	if (a != NULL) Free(a);
	a=(char *)Malloc(n);
	return(a);
d242 1
a242 1
void *CRYPTO_dbg_remalloc(void *a, int n, const char *file, int line)
d244 2
a245 2
	if (a != NULL) CRYPTO_dbg_free(a);
	a=(char *)CRYPTO_dbg_malloc(n,file,line);
d250 1
a250 73
typedef struct mem_leak_st
	{
	BIO *bio;
	int chunks;
	long bytes;
	} MEM_LEAK;

static void print_leak(MEM *m, MEM_LEAK *l)
	{
	char buf[128];
#ifdef CRYPTO_MDEBUG_TIME
	struct tm *lcl;
#endif

	if(m->addr == (char *)l->bio)
	    return;

#ifdef CRYPTO_MDEBUG_TIME
	lcl = localtime(&m->time);
#endif

	sprintf(buf,
#ifdef CRYPTO_MDEBUG_TIME
		"[%02d:%02d:%02d] "
#endif
		"%5lu file=%s, line=%d, "
#ifdef CRYPTO_MDEBUG_THREAD
		"thread=%lu, "
#endif
		"number=%d, address=%08lX\n",
#ifdef CRYPTO_MDEBUG_TIME
		lcl->tm_hour,lcl->tm_min,lcl->tm_sec,
#endif
		m->order,m->file,m->line,
#ifdef CRYPTO_MDEBUG_THREAD
		m->thread,
#endif
		m->num,(unsigned long)m->addr);

	BIO_puts(l->bio,buf);
	l->chunks++;
	l->bytes+=m->num;
	}

void CRYPTO_mem_leaks(BIO *b)
	{
	MEM_LEAK ml;
	char buf[80];

	if (mh == NULL) return;
	ml.bio=b;
	ml.bytes=0;
	ml.chunks=0;
	CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
	lh_doall_arg(mh,(void (*)())print_leak,(char *)&ml);
	CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
	if (ml.chunks != 0)
		{
		sprintf(buf,"%ld bytes leaked in %d chunks\n",
			ml.bytes,ml.chunks);
		BIO_puts(b,buf);
		}

#if 0
	lh_stats_bio(mh,b);
	lh_node_stats_bio(mh,b);
	lh_node_usage_stats_bio(mh,b);
#endif
	}

static void (*mem_cb)()=NULL;

static void cb_leak(MEM *m, char *cb)
d252 2
a253 2
	void (*mem_callback)()=(void (*)())cb;
	mem_callback(m->order,m->file,m->line,m->num,m->addr);
d256 1
a256 1
void CRYPTO_mem_leaks_cb(void (*cb)())
d258 3
a260 6
	if (mh == NULL) return;
	CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
	mem_cb=cb;
	lh_doall_arg(mh,(void (*)())cb_leak,(char *)mem_cb);
	mem_cb=NULL;
	CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
a261 15

#ifndef NO_FP_API
void CRYPTO_mem_leaks_fp(FILE *fp)
	{
	BIO *b;

	if (mh == NULL) return;
	if ((b=BIO_new(BIO_s_file())) == NULL)
		return;
	BIO_set_fp(b,fp,BIO_NOCLOSE);
	CRYPTO_mem_leaks(b);
	BIO_free(b);
	}
#endif

@


1.1
log
@Initial revision
@
text
@d61 7
a67 3
#include "buffer.h"
#include "bio.h"
#include "lhash.h"
d70 3
d74 11
d93 1
a93 1
	char *file;
d95 3
d99 3
d104 1
a104 2
int CRYPTO_mem_ctrl(mode)
int mode;
d111 6
a116 2
	case CRYPTO_MEM_CHECK_ON:
		mh_mode|=CRYPTO_MEM_CHECK_ON;
d118 4
a121 2
	case CRYPTO_MEM_CHECK_OFF:
		mh_mode&= ~CRYPTO_MEM_CHECK_ON;
d123 5
d135 1
a135 2
static int mem_cmp(a,b)
MEM *a,*b;
d140 1
a140 2
static unsigned long mem_hash(a)
MEM *a;
d150 2
d156 1
a156 4
void CRYPTO_set_mem_functions(m,r,f)
char *(*m)();
char *(*r)();
void (*f)();
d162 2
d166 8
a173 4
void CRYPTO_get_mem_functions(m,r,f)
char *(**m)();
char *(**r)();
void (**f)();
d180 17
a196 2
char *CRYPTO_malloc(num)
int num;
d201 1
a201 3
char *CRYPTO_realloc(str,num)
char *str;
int num;
d206 1
a206 2
void CRYPTO_free(str)
char *str;
d211 2
a212 4
char *CRYPTO_dbg_malloc(num,file,line)
int num;
char *file;
int line;
d220 1
a220 1
	if (mh_mode & CRYPTO_MEM_CHECK_ON)
d222 2
a223 1
		if ((m=(MEM *)malloc(sizeof(MEM))) == NULL)
d225 2
a226 1
			free(ret);
d234 4
a237 3
				free(ret);
				free(m);
				return(NULL);
d245 8
d254 3
d260 1
a260 1
			free(mm);
d262 1
d264 1
d269 1
a269 2
void CRYPTO_dbg_free(addr)
char *addr;
d273 1
a273 1
	if ((mh_mode & CRYPTO_MEM_CHECK_ON) && (mh != NULL))
d275 1
d280 1
a280 1
			free(mp);
d282 1
d287 1
a287 5
char *CRYPTO_dbg_realloc(addr,num,file,line)
char *addr;
int num;
char *file;
int line;
d295 1
a295 1
	if (mh_mode & CRYPTO_MEM_CHECK_ON)
d297 1
d308 1
d313 1
a313 3
char *CRYPTO_remalloc(a,n)
char *a;
int n;
d320 1
a320 5
char *CRYPTO_dbg_remalloc(a,n,file,line)
char *a;
int n;
char *file;
int line;
d335 1
a335 3
static void print_leak(m,l)
MEM *m;
MEM_LEAK *l;
d338 28
a366 2
	sprintf(buf,"%5ld file=%s, line=%d, number=%d, address=%08lX\n",
		m->order,m->file,m->line,m->num,(long)m->addr);
d372 1
a372 2
void CRYPTO_mem_leaks(b)
BIO *b;
d390 2
a391 1
	/*
d393 3
a395 3
        lh_node_stats_bio(mh,b);
        lh_node_usage_stats_bio(mh,b);
	*/
d400 1
a400 3
static void cb_leak(m,cb)
MEM *m;
char *cb;
d406 1
a406 2
void CRYPTO_mem_leaks_cb(cb)
void (*cb)();
d417 1
a417 2
void CRYPTO_mem_leaks_fp(fp)
FILE *fp;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d61 3
a63 1
#include <openssl/crypto.h>
d66 2
d69 1
a69 7
static int allow_customize = 1;      /* we provide flexible functions for */
static int allow_customize_debug = 1;/* exchanging memory-related functions at
                                      * run-time, but this must be done
                                      * before any blocks are actually
                                      * allocated; or we'll run into huge
                                      * problems when malloc/free pairs
                                      * don't match etc. */
d71 8
d80 4
d85 15
a99 25
/* the following pointers may be changed as long as 'allow_customize' is set */

static void *(*malloc_func)(size_t)         = malloc;
static void *default_malloc_ex(size_t num, const char *file, int line)
	{ return malloc_func(num); }
static void *(*malloc_ex_func)(size_t, const char *file, int line)
        = default_malloc_ex;

static void *(*realloc_func)(void *, size_t)= realloc;
static void *default_realloc_ex(void *str, size_t num,
        const char *file, int line)
	{ return realloc_func(str,num); }
static void *(*realloc_ex_func)(void *, size_t, const char *file, int line)
        = default_realloc_ex;

static void (*free_func)(void *)            = free;

static void *(*malloc_locked_func)(size_t)  = malloc;
static void *default_malloc_locked_ex(size_t num, const char *file, int line)
	{ return malloc_locked_func(num); }
static void *(*malloc_locked_ex_func)(size_t, const char *file, int line)
        = default_malloc_locked_ex;

static void (*free_locked_func)(void *)     = free;

d101 2
a102 26

/* may be changed as long as 'allow_customize_debug' is set */
/* XXX use correct function pointer types */
#ifdef CRYPTO_MDEBUG
/* use default functions from mem_dbg.c */
static void (*malloc_debug_func)(void *,int,const char *,int,int)
	= CRYPTO_dbg_malloc;
static void (*realloc_debug_func)(void *,void *,int,const char *,int,int)
	= CRYPTO_dbg_realloc;
static void (*free_debug_func)(void *,int) = CRYPTO_dbg_free;
static void (*set_debug_options_func)(long) = CRYPTO_dbg_set_options;
static long (*get_debug_options_func)(void) = CRYPTO_dbg_get_options;
#else
/* applications can use CRYPTO_malloc_debug_init() to select above case
 * at run-time */
static void (*malloc_debug_func)(void *,int,const char *,int,int) = NULL;
static void (*realloc_debug_func)(void *,void *,int,const char *,int,int)
	= NULL;
static void (*free_debug_func)(void *,int) = NULL;
static void (*set_debug_options_func)(long) = NULL;
static long (*get_debug_options_func)(void) = NULL;
#endif


int CRYPTO_set_mem_functions(void *(*m)(size_t), void *(*r)(void *, size_t),
	void (*f)(void *))
d104 1
a104 51
	if (!allow_customize)
		return 0;
	if ((m == 0) || (r == 0) || (f == 0))
		return 0;
	malloc_func=m; malloc_ex_func=default_malloc_ex;
	realloc_func=r; realloc_ex_func=default_realloc_ex;
	free_func=f;
	malloc_locked_func=m; malloc_locked_ex_func=default_malloc_locked_ex;
	free_locked_func=f;
	return 1;
	}

int CRYPTO_set_mem_ex_functions(
        void *(*m)(size_t,const char *,int),
        void *(*r)(void *, size_t,const char *,int),
	void (*f)(void *))
	{
	if (!allow_customize)
		return 0;
	if ((m == 0) || (r == 0) || (f == 0))
		return 0;
	malloc_func=0; malloc_ex_func=m;
	realloc_func=0; realloc_ex_func=r;
	free_func=f;
	malloc_locked_func=0; malloc_locked_ex_func=m;
	free_locked_func=f;
	return 1;
	}

int CRYPTO_set_locked_mem_functions(void *(*m)(size_t), void (*f)(void *))
	{
	if (!allow_customize)
		return 0;
	if ((m == NULL) || (f == NULL))
		return 0;
	malloc_locked_func=m; malloc_locked_ex_func=default_malloc_locked_ex;
	free_locked_func=f;
	return 1;
	}

int CRYPTO_set_locked_mem_ex_functions(
        void *(*m)(size_t,const char *,int),
        void (*f)(void *))
	{
	if (!allow_customize)
		return 0;
	if ((m == NULL) || (f == NULL))
		return 0;
	malloc_locked_func=0; malloc_locked_ex_func=m;
	free_func=f;
	return 1;
d107 2
a108 5
int CRYPTO_set_mem_debug_functions(void (*m)(void *,int,const char *,int,int),
				   void (*r)(void *,void *,int,const char *,int,int),
				   void (*f)(void *,int),
				   void (*so)(long),
				   long (*go)(void))
d110 6
a115 8
	if (!allow_customize_debug)
		return 0;
	malloc_debug_func=m;
	realloc_debug_func=r;
	free_debug_func=f;
	set_debug_options_func=so;
	get_debug_options_func=go;
	return 1;
d118 3
d122 4
a125 2
void CRYPTO_get_mem_functions(void *(**m)(size_t), void *(**r)(void *, size_t),
	void (**f)(void *))
d127 4
a130 5
	if (m != NULL) *m = (malloc_ex_func == default_malloc_ex) ? 
	                     malloc_func : 0;
	if (r != NULL) *r = (realloc_ex_func == default_realloc_ex) ? 
	                     realloc_func : 0;
	if (f != NULL) *f=free_func;
d133 7
a139 9
void CRYPTO_get_mem_ex_functions(
        void *(**m)(size_t,const char *,int),
        void *(**r)(void *, size_t,const char *,int),
	void (**f)(void *))
	{
	if (m != NULL) *m = (malloc_ex_func != default_malloc_ex) ?
	                    malloc_ex_func : 0;
	if (r != NULL) *r = (realloc_ex_func != default_realloc_ex) ?
	                    realloc_ex_func : 0;
d143 2
a144 1
void CRYPTO_get_locked_mem_functions(void *(**m)(size_t), void (**f)(void *))
d146 1
a146 3
	if (m != NULL) *m = (malloc_locked_ex_func == default_malloc_locked_ex) ? 
	                     malloc_locked_func : 0;
	if (f != NULL) *f=free_locked_func;
d149 3
a151 3
void CRYPTO_get_locked_mem_ex_functions(
        void *(**m)(size_t,const char *,int),
        void (**f)(void *))
d153 1
a153 3
	if (m != NULL) *m = (malloc_locked_ex_func != default_malloc_locked_ex) ?
	                    malloc_locked_ex_func : 0;
	if (f != NULL) *f=free_locked_func;
d156 2
a157 5
void CRYPTO_get_mem_debug_functions(void (**m)(void *,int,const char *,int,int),
				    void (**r)(void *,void *,int,const char *,int,int),
				    void (**f)(void *,int),
				    void (**so)(long),
				    long (**go)(void))
d159 1
a159 5
	if (m != NULL) *m=malloc_debug_func;
	if (r != NULL) *r=realloc_debug_func;
	if (f != NULL) *f=free_debug_func;
	if (so != NULL) *so=set_debug_options_func;
	if (go != NULL) *go=get_debug_options_func;
d162 7
d170 2
a171 3
void *CRYPTO_malloc_locked(int num, const char *file, int line)
	{
	void *ret = NULL;
d173 1
a173 2
	allow_customize = 0;
	if (malloc_debug_func != NULL)
d175 27
a201 2
		allow_customize_debug = 0;
		malloc_debug_func(NULL, num, file, line, 0);
d203 1
a203 8
	ret = malloc_locked_ex_func(num,file,line);
#ifdef LEVITTE_DEBUG_MEM
	fprintf(stderr, "LEVITTE_DEBUG_MEM:         > 0x%p (%d)\n", ret, num);
#endif
	if (malloc_debug_func != NULL)
		malloc_debug_func(ret, num, file, line, 1);

	return ret;
d206 2
a207 1
void CRYPTO_free_locked(void *str)
d209 12
a220 8
	if (free_debug_func != NULL)
		free_debug_func(str, 0);
#ifdef LEVITTE_DEBUG_MEM
	fprintf(stderr, "LEVITTE_DEBUG_MEM:         < 0x%p\n", str);
#endif
	free_locked_func(str);
	if (free_debug_func != NULL)
		free_debug_func(NULL, 1);
d223 5
a227 1
void *CRYPTO_malloc(int num, const char *file, int line)
d229 2
a230 1
	void *ret = NULL;
d232 4
a235 2
	allow_customize = 0;
	if (malloc_debug_func != NULL)
d237 10
a246 2
		allow_customize_debug = 0;
		malloc_debug_func(NULL, num, file, line, 0);
d248 2
a249 6
	ret = malloc_ex_func(num,file,line);
#ifdef LEVITTE_DEBUG_MEM
	fprintf(stderr, "LEVITTE_DEBUG_MEM:         > 0x%p (%d)\n", ret, num);
#endif
	if (malloc_debug_func != NULL)
		malloc_debug_func(ret, num, file, line, 1);
d251 7
a257 1
	return ret;
d260 5
a264 1
void *CRYPTO_realloc(void *str, int num, const char *file, int line)
d266 4
a269 1
	void *ret = NULL;
a270 8
	if (realloc_debug_func != NULL)
		realloc_debug_func(str, NULL, num, file, line, 0);
	ret = realloc_ex_func(str,num,file,line);
#ifdef LEVITTE_DEBUG_MEM
	fprintf(stderr, "LEVITTE_DEBUG_MEM:         | 0x%p -> 0x%p (%d)\n", str, ret, num);
#endif
	if (realloc_debug_func != NULL)
		realloc_debug_func(str, ret, num, file, line, 1);
d272 44
a315 1
	return ret;
d318 5
a322 1
void CRYPTO_free(void *str)
d324 2
a325 8
	if (free_debug_func != NULL)
		free_debug_func(str, 0);
#ifdef LEVITTE_DEBUG_MEM
	fprintf(stderr, "LEVITTE_DEBUG_MEM:         < 0x%p\n", str);
#endif
	free_func(str);
	if (free_debug_func != NULL)
		free_debug_func(NULL, 1);
d328 2
a329 1
void *CRYPTO_remalloc(void *a, int num, const char *file, int line)
d331 6
a336 3
	if (a != NULL) OPENSSL_free(a);
	a=(char *)OPENSSL_malloc(num);
	return(a);
d339 5
d345 6
a350 4
void CRYPTO_set_mem_debug_options(long bits)
	{
	if (set_debug_options_func != NULL)
		set_debug_options_func(bits);
d352 1
a353 6
long CRYPTO_get_mem_debug_options(void)
	{
	if (get_debug_options_func != NULL)
		return get_debug_options_func();
	return 0;
	}
@


1.1.1.3
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@a305 3
	if (str == NULL)
		return CRYPTO_malloc(num, file, line);

@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@a252 3
	extern unsigned char cleanse_ctr;

	if (num < 0) return NULL;
a266 6
        /* Create a dependency on the value of 'cleanse_ctr' so our memory
         * sanitisation function can't be optimised out. NB: We only do
         * this for >2Kb so the overhead doesn't bother us. */
        if(ret && (num > 2048))
		((unsigned char *)ret)[0] = cleanse_ctr;

a284 3
	extern unsigned char cleanse_ctr;

	if (num < 0) return NULL;
a298 6
        /* Create a dependency on the value of 'cleanse_ctr' so our memory
         * sanitisation function can't be optimised out. NB: We only do
         * this for >2Kb so the overhead doesn't bother us. */
        if(ret && (num > 2048))
                ((unsigned char *)ret)[0] = cleanse_ctr;

a308 2
 	if (num < 0) return NULL;
 
a320 26
void *CRYPTO_realloc_clean(void *str, int old_len, int num, const char *file,
			   int line)
	{
	void *ret = NULL;

	if (str == NULL)
		return CRYPTO_malloc(num, file, line);
 
 	if (num < 0) return NULL;
 
	if (realloc_debug_func != NULL)
		realloc_debug_func(str, NULL, num, file, line, 0);
	ret=malloc_ex_func(num,file,line);
	if(ret)
		memcpy(ret,str,old_len);
	OPENSSL_cleanse(str,old_len);
	free_func(str);
#ifdef LEVITTE_DEBUG_MEM
	fprintf(stderr, "LEVITTE_DEBUG_MEM:         | 0x%p -> 0x%p (%d)\n", str, ret, num);
#endif
	if (realloc_debug_func != NULL)
		realloc_debug_func(str, ret, num, file, line, 1);

	return ret;
	}

d339 1
@


1.1.1.5
log
@import openssl-0.9.7d
@
text
@d255 1
a255 1
	if (num <= 0) return NULL;
d296 1
a296 1
	if (num <= 0) return NULL;
d327 1
a327 1
 	if (num <= 0) return NULL;
d349 1
a349 1
 	if (num <= 0) return NULL;
a354 1
		{
d356 2
a357 3
		OPENSSL_cleanse(str,old_len);
		free_func(str);
		}
d359 1
a359 3
	fprintf(stderr,
		"LEVITTE_DEBUG_MEM:         | 0x%p -> 0x%p (%d)\n",
		str, ret, num);
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@d327 2
a328 2
	if (num <= 0) return NULL;

d348 3
a350 3

	if (num <= 0) return NULL;

@


1.1.1.7
log
@import openssl-0.9.8j
@
text
@d104 1
a104 1
#if defined(CRYPTO_MDEBUG) && !defined(OPENSSL_FIPS)
a112 8

static int  (*push_info_func)(const char *info, const char *file, int line)
	= CRYPTO_dbg_push_info;
static int  (*pop_info_func)(void)
	= CRYPTO_dbg_pop_info;
static int (*remove_all_info_func)(void)
	= CRYPTO_dbg_remove_all_info;

a121 7


static int  (*push_info_func)(const char *info, const char *file, int line)
	= NULL;
static int  (*pop_info_func)(void) = NULL;
static int (*remove_all_info_func)(void) = NULL;

a196 9
void CRYPTO_set_mem_info_functions(
	int  (*push_info_fn)(const char *info, const char *file, int line),
	int  (*pop_info_fn)(void),
	int (*remove_all_info_fn)(void))
	{
	push_info_func = push_info_fn;
	pop_info_func = pop_info_fn;
	remove_all_info_func = remove_all_info_fn;
	}
a400 21
	}

int CRYPTO_push_info_(const char *info, const char *file, int line)
	{
	if (push_info_func)
		return push_info_func(info, file, line);
	return 1;
	}

int CRYPTO_pop_info(void)
	{
	if (pop_info_func)
		return pop_info_func();
	return 1;
	}

int CRYPTO_remove_all_info(void)
	{
	if (remove_all_info_func)
		return remove_all_info_func();
	return 1;
@


1.1.1.8
log
@import OpenSSL-1.0.0a
@
text
@d104 1
a104 1
#ifdef CRYPTO_MDEBUG
d113 8
d130 7
d212 9
d277 1
a293 1
#ifndef OPENSSL_CPUID_OBJ
a297 1
	{	extern unsigned char cleanse_ctr;
a298 2
	}
#endif
d318 1
a334 1
#ifndef OPENSSL_CPUID_OBJ
a338 1
	{	extern unsigned char cleanse_ctr;
a339 2
	}
#endif
a342 7
char *CRYPTO_strdup(const char *str, const char *file, int line)
	{
	char *ret = CRYPTO_malloc(strlen(str)+1, file, line);

	strcpy(ret, str);
	return ret;
	}
d425 21
@


1.1.1.9
log
@import OpenSSL-1.0.1c
@
text
@a127 1
	OPENSSL_init();
a188 1
	OPENSSL_init();
a362 4

	/* We don't support shrinking the buffer. Note the memcpy that copies
	 * |old_len| bytes to the new buffer, below. */
	if (num < old_len) return NULL;
@


1.1.1.10
log
@Import OpenSSL 1.0.1g
@
text
@d124 1
a127 1
	/* Dummy call just to ensure OPENSSL_init() gets linked in */
@


