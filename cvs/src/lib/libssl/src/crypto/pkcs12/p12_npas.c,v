head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.8
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.4
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	butholakala:1.7
	openssl_1_0_1_g:1.1.1.5
	OPENBSD_5_5:1.7.0.16
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.12
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.10
	OPENBSD_5_3_BASE:1.7
	openssl_1_0_1_c:1.1.1.5
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.8
	openssl_1_0_0_f:1.1.1.5
	openssl_1_0_0_e:1.1.1.5
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	openssh_1_0_0_a:1.1.1.5
	OPENBSD_4_8:1.6.0.8
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.4
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	openssl_0_9_8_k:1.1.1.4
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	openssl_0_9_8_j:1.1.1.4
	openssl_0_9_8_h:1.1.1.3
	pre_openssl_0_9_8h:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENSSL_0_9_7G:1.1.1.2
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.2.0.6
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.02.14.14.18.58;	author miod;	state Exp;
branches;
next	1.9;
commitid	4GODJqfhVhSA70cs;

1.9
date	2014.07.08.09.24.53;	author jsing;	state Exp;
branches;
next	1.8;
commitid	XxMwLiDq7L4rxrmk;

1.8
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	mJUVYpkFBZ0Zv2bG;

1.7
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.12.02.18.38;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.15.02.29.15;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.15.02.58.00;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.11.04;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.44;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.35.39;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.45;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.01.09.12.13.58;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Attempt to correctly free temporary storage upon error. With help from
doug@@ and jsing@@, ok doug@@ three months ago (sigh... I sometimes suck bigtime
at commiting bugfixes)
@
text
@/* $OpenBSD: p12_npas.c,v 1.9 2014/07/08 09:24:53 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 1999.
 */
/* ====================================================================
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <openssl/pkcs12.h>

/* PKCS#12 password change routine */

static int newpass_p12(PKCS12 *p12, char *oldpass, char *newpass);
static int newpass_bags(STACK_OF(PKCS12_SAFEBAG) *bags, char *oldpass,
    char *newpass);
static int newpass_bag(PKCS12_SAFEBAG *bag, char *oldpass, char *newpass);
static int alg_get(X509_ALGOR *alg, int *pnid, int *piter, int *psaltlen);

/*
 * Change the password on a PKCS#12 structure.
 */

int
PKCS12_newpass(PKCS12 *p12, char *oldpass, char *newpass)
{
	/* Check for NULL PKCS12 structure */

	if (!p12) {
		PKCS12err(PKCS12_F_PKCS12_NEWPASS,
		    PKCS12_R_INVALID_NULL_PKCS12_POINTER);
		return 0;
	}

	/* Check the mac */

	if (!PKCS12_verify_mac(p12, oldpass, -1)) {
		PKCS12err(PKCS12_F_PKCS12_NEWPASS, PKCS12_R_MAC_VERIFY_FAILURE);
		return 0;
	}

	if (!newpass_p12(p12, oldpass, newpass)) {
		PKCS12err(PKCS12_F_PKCS12_NEWPASS, PKCS12_R_PARSE_ERROR);
		return 0;
	}

	return 1;
}

/* Parse the outer PKCS#12 structure */

static int
newpass_p12(PKCS12 *p12, char *oldpass, char *newpass)
{
	STACK_OF(PKCS7) *asafes, *newsafes;
	STACK_OF(PKCS12_SAFEBAG) *bags;
	int i, bagnid, pbe_nid = 0, pbe_iter = 0, pbe_saltlen = 0;
	PKCS7 *p7, *p7new;
	ASN1_OCTET_STRING *p12_data_tmp = NULL, *macnew = NULL;
	unsigned char mac[EVP_MAX_MD_SIZE];
	unsigned int maclen;

	if (!(asafes = PKCS12_unpack_authsafes(p12)))
		return 0;
	if (!(newsafes = sk_PKCS7_new_null()))
		return 0;
	for (i = 0; i < sk_PKCS7_num(asafes); i++) {
		p7 = sk_PKCS7_value(asafes, i);
		bagnid = OBJ_obj2nid(p7->type);
		if (bagnid == NID_pkcs7_data) {
			bags = PKCS12_unpack_p7data(p7);
		} else if (bagnid == NID_pkcs7_encrypted) {
			bags = PKCS12_unpack_p7encdata(p7, oldpass, -1);
			if (!alg_get(p7->d.encrypted->enc_data->algorithm,
			    &pbe_nid, &pbe_iter, &pbe_saltlen)) {
				sk_PKCS12_SAFEBAG_pop_free(bags,
				    PKCS12_SAFEBAG_free);
				bags = NULL;
			}
		} else
			continue;
		if (bags == NULL)
			goto err;
		if (!newpass_bags(bags, oldpass, newpass)) {
			sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
			goto err;
		}
		/* Repack bag in same form with new password */
		if (bagnid == NID_pkcs7_data)
			p7new = PKCS12_pack_p7data(bags);
		else
			p7new = PKCS12_pack_p7encdata(pbe_nid, newpass, -1,
			    NULL, pbe_saltlen, pbe_iter, bags);
		sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
		if (p7new == NULL)
			goto err;
		if (sk_PKCS7_push(newsafes, p7new) == 0)
			goto err;
	}
	sk_PKCS7_pop_free(asafes, PKCS7_free);

	/* Repack safe: save old safe in case of error */

	p12_data_tmp = p12->authsafes->d.data;
	if (!(p12->authsafes->d.data = ASN1_OCTET_STRING_new())) {
		p12->authsafes->d.data = p12_data_tmp;
		goto err;
	}
	if (!PKCS12_pack_authsafes(p12, newsafes))
		goto saferr;

	if (!PKCS12_gen_mac(p12, newpass, -1, mac, &maclen))
		goto saferr;
	if (!(macnew = ASN1_OCTET_STRING_new()))
		goto saferr;
	if (!ASN1_OCTET_STRING_set(macnew, mac, maclen))
		goto saferr;
	ASN1_OCTET_STRING_free(p12->mac->dinfo->digest);
	p12->mac->dinfo->digest = macnew;
	ASN1_OCTET_STRING_free(p12_data_tmp);

	return 1;

saferr:
	/* Restore old safe */
	ASN1_OCTET_STRING_free(p12->authsafes->d.data);
	ASN1_OCTET_STRING_free(macnew);
	p12->authsafes->d.data = p12_data_tmp;
	return 0;

err:
	sk_PKCS7_pop_free(asafes, PKCS7_free);
	sk_PKCS7_pop_free(newsafes, PKCS7_free);
	return 0;
}


static int
newpass_bags(STACK_OF(PKCS12_SAFEBAG) *bags, char *oldpass, char *newpass)
{
	int i;

	for (i = 0; i < sk_PKCS12_SAFEBAG_num(bags); i++) {
		if (!newpass_bag(sk_PKCS12_SAFEBAG_value(bags, i),
		    oldpass, newpass))
			return 0;
	}
	return 1;
}

/* Change password of safebag: only needs handle shrouded keybags */

static int
newpass_bag(PKCS12_SAFEBAG *bag, char *oldpass, char *newpass)
{
	PKCS8_PRIV_KEY_INFO *p8;
	X509_SIG *p8new;
	int p8_nid, p8_saltlen, p8_iter;

	if (M_PKCS12_bag_type(bag) != NID_pkcs8ShroudedKeyBag)
		return 1;

	if (!(p8 = PKCS8_decrypt(bag->value.shkeybag, oldpass, -1)))
		return 0;
	if (!alg_get(bag->value.shkeybag->algor, &p8_nid, &p8_iter,
	    &p8_saltlen))
		return 0;
	if (!(p8new = PKCS8_encrypt(p8_nid, NULL, newpass, -1, NULL, p8_saltlen,
	    p8_iter, p8))) return 0;
	X509_SIG_free(bag->value.shkeybag);
	bag->value.shkeybag = p8new;
	return 1;
}

static int
alg_get(X509_ALGOR *alg, int *pnid, int *piter, int *psaltlen)
{
	PBEPARAM *pbe;
	const unsigned char *p;

	p = alg->parameter->value.sequence->data;
	pbe = d2i_PBEPARAM(NULL, &p, alg->parameter->value.sequence->length);
	if (!pbe)
		return 0;
	*pnid = OBJ_obj2nid(alg->algorithm);
	*piter = ASN1_INTEGER_get(pbe->iter);
	*psaltlen = pbe->salt->length;
	PBEPARAM_free(pbe);
	return 1;
}
@


1.9
log
@KNF.
@
text
@d1 1
a1 1
/* $OpenBSD: p12_npas.c,v 1.8 2014/06/12 15:49:30 deraadt Exp $ */
d121 1
a121 1
	for (i = 0; i < sk_PKCS7_num (asafes); i++) {
d136 2
a137 4
		if (!bags) {
			sk_PKCS7_pop_free(asafes, PKCS7_free);
			return 0;
		}
d140 1
a140 2
			sk_PKCS7_pop_free(asafes, PKCS7_free);
			return 0;
d149 4
a152 5
		if (!p7new) {
			sk_PKCS7_pop_free(asafes, PKCS7_free);
			return 0;
		}
		sk_PKCS7_push(newsafes, p7new);
d159 4
a162 2
	if (!(p12->authsafes->d.data = ASN1_OCTET_STRING_new()))
		goto saferr;
d183 5
@


1.8
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d70 1
a70 1
			char *newpass);
d74 1
a74 1
/* 
d78 2
a79 1
int PKCS12_newpass(PKCS12 *p12, char *oldpass, char *newpass)
d83 3
a85 2
	if(!p12) {
		PKCS12err(PKCS12_F_PKCS12_NEWPASS,PKCS12_R_INVALID_NULL_PKCS12_POINTER);
d90 1
a90 1
	
d92 1
a92 1
		PKCS12err(PKCS12_F_PKCS12_NEWPASS,PKCS12_R_MAC_VERIFY_FAILURE);
d97 1
a97 1
		PKCS12err(PKCS12_F_PKCS12_NEWPASS,PKCS12_R_PARSE_ERROR);
d106 2
a107 1
static int newpass_p12(PKCS12 *p12, char *oldpass, char *newpass)
d117 4
a120 2
	if (!(asafes = PKCS12_unpack_authsafes(p12))) return 0;
	if(!(newsafes = sk_PKCS7_new_null())) return 0;
d129 1
a129 2
				&pbe_nid, &pbe_iter, &pbe_saltlen))
				{
d131 1
a131 1
						PKCS12_SAFEBAG_free);
d133 3
a135 2
				}
		} else continue;
d140 1
a140 1
	    	if (!newpass_bags(bags, oldpass, newpass)) {
d146 5
a150 3
		if (bagnid == NID_pkcs7_data) p7new = PKCS12_pack_p7data(bags);
		else p7new = PKCS12_pack_p7encdata(pbe_nid, newpass, -1, NULL,
						 pbe_saltlen, pbe_iter, bags);
d152 1
a152 1
		if(!p7new) {
d163 11
a173 6
	if(!(p12->authsafes->d.data = ASN1_OCTET_STRING_new())) goto saferr;
	if(!PKCS12_pack_authsafes(p12, newsafes)) goto saferr;

	if(!PKCS12_gen_mac(p12, newpass, -1, mac, &maclen)) goto saferr;
	if(!(macnew = ASN1_OCTET_STRING_new())) goto saferr;
	if(!ASN1_OCTET_STRING_set(macnew, mac, maclen)) goto saferr;
d180 1
a180 1
	saferr:
a185 1

d189 2
a190 2
static int newpass_bags(STACK_OF(PKCS12_SAFEBAG) *bags, char *oldpass,
			char *newpass)
d193 1
d196 2
a197 2
				 oldpass, newpass))
		    return 0;
d204 2
a205 1
static int newpass_bag(PKCS12_SAFEBAG *bag, char *oldpass, char *newpass)
d211 2
a212 1
	if(M_PKCS12_bag_type(bag) != NID_pkcs8ShroudedKeyBag) return 1;
d214 2
a215 1
	if (!(p8 = PKCS8_decrypt(bag->value.shkeybag, oldpass, -1))) return 0;
d217 1
a217 1
							&p8_saltlen))
d219 2
a220 2
	if(!(p8new = PKCS8_encrypt(p8_nid, NULL, newpass, -1, NULL, p8_saltlen,
						     p8_iter, p8))) return 0;
d226 2
a227 1
static int alg_get(X509_ALGOR *alg, int *pnid, int *piter, int *psaltlen)
d229 2
a230 2
        PBEPARAM *pbe;
        const unsigned char *p;
d232 2
a233 2
        p = alg->parameter->value.sequence->data;
        pbe = d2i_PBEPARAM(NULL, &p, alg->parameter->value.sequence->length);
d236 1
a236 1
        *pnid = OBJ_obj2nid(alg->algorithm);
d239 2
a240 2
        PBEPARAM_free(pbe);
        return 1;
@


1.7
log
@resolve conflicts, fix local changes
@
text
@d1 1
a1 1
/* p12_npas.c */
@


1.6
log
@resolve conflicts
@
text
@d123 7
a129 2
			alg_get(p7->d.encrypted->enc_data->algorithm,
				&pbe_nid, &pbe_iter, &pbe_saltlen);
d201 3
a203 1
	alg_get(bag->value.shkeybag->algor, &p8_nid, &p8_iter, &p8_saltlen);
d218 2
d224 1
a224 1
        return 0;
@


1.5
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.4
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d80 1
d82 4
a85 1
/* Check for NULL PKCS12 structure */
d87 6
a92 4
if(!p12) {
	PKCS12err(PKCS12_F_PKCS12_NEWPASS,PKCS12_R_INVALID_NULL_PKCS12_POINTER);
	return 0;
}
d94 4
a97 13
/* Check the mac */

if (!PKCS12_verify_mac(p12, oldpass, -1)) {
	PKCS12err(PKCS12_F_PKCS12_NEWPASS,PKCS12_R_MAC_VERIFY_FAILURE);
	return 0;
}

if (!newpass_p12(p12, oldpass, newpass)) {
	PKCS12err(PKCS12_F_PKCS12_NEWPASS,PKCS12_R_PARSE_ERROR);
	return 0;
}

return 1;
d99 1
d207 2
a208 1
        unsigned char *p;
@


1.3
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d110 1
a110 1
	int i, bagnid, pbe_nid, pbe_iter, pbe_saltlen;
@


1.2
log
@openssl-engine-0.9.6 merge
@
text
@d116 1
a116 1
	if (!(asafes = M_PKCS12_unpack_authsafes(p12))) return 0;
d122 1
a122 1
			bags = M_PKCS12_unpack_p7data(p7);
d124 1
a124 1
			bags = M_PKCS12_unpack_p7encdata(p7, oldpass, -1);
d154 1
a154 1
	if(!M_PKCS12_pack_authsafes(p12, newsafes)) goto saferr;
d197 1
a197 1
	if (!(p8 = M_PKCS12_decrypt_skey(bag, oldpass, -1))) return 0;
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d69 2
a70 1
static int newpass_bags(STACK *bags, char *oldpass,  char *newpass);
d108 2
a109 1
	STACK *asafes, *newsafes, *bags;
d115 1
d117 3
a119 3
	if(!(newsafes = sk_new(NULL))) return 0;
	for (i = 0; i < sk_num (asafes); i++) {
		p7 = (PKCS7 *) sk_value(asafes, i);
d129 1
a129 1
			sk_pop_free(asafes, PKCS7_free);
d133 2
a134 2
			sk_pop_free(bags, PKCS12_SAFEBAG_free);
			sk_pop_free(asafes, PKCS7_free);
d141 1
a141 1
		sk_pop_free(bags, PKCS12_SAFEBAG_free);
d143 1
a143 1
			sk_pop_free(asafes, PKCS7_free);
d146 1
a146 1
		sk_push(newsafes, (char *)p7new);
d148 1
a148 1
	sk_pop_free(asafes, PKCS7_free);
d175 2
a176 1
static int newpass_bags(STACK *bags, char *oldpass,  char *newpass)
d179 4
a182 3
	for (i = 0; i < sk_num(bags); i++) {
		if (!newpass_bag((PKCS12_SAFEBAG *)sk_value(bags, i),
						 oldpass, newpass)) return 0;
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d69 1
a69 2
static int newpass_bags(STACK_OF(PKCS12_SAFEBAG) *bags, char *oldpass,
			char *newpass);
d107 1
a107 2
	STACK_OF(PKCS7) *asafes, *newsafes;
	STACK_OF(PKCS12_SAFEBAG) *bags;
d113 4
a116 5

	if (!(asafes = PKCS12_unpack_authsafes(p12))) return 0;
	if(!(newsafes = sk_PKCS7_new_null())) return 0;
	for (i = 0; i < sk_PKCS7_num (asafes); i++) {
		p7 = sk_PKCS7_value(asafes, i);
d119 1
a119 1
			bags = PKCS12_unpack_p7data(p7);
d121 1
a121 1
			bags = PKCS12_unpack_p7encdata(p7, oldpass, -1);
d126 1
a126 1
			sk_PKCS7_pop_free(asafes, PKCS7_free);
d130 2
a131 2
			sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
			sk_PKCS7_pop_free(asafes, PKCS7_free);
d138 1
a138 1
		sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
d140 1
a140 1
			sk_PKCS7_pop_free(asafes, PKCS7_free);
d143 1
a143 1
		sk_PKCS7_push(newsafes, p7new);
d145 1
a145 1
	sk_PKCS7_pop_free(asafes, PKCS7_free);
d151 1
a151 1
	if(!PKCS12_pack_authsafes(p12, newsafes)) goto saferr;
d172 1
a172 2
static int newpass_bags(STACK_OF(PKCS12_SAFEBAG) *bags, char *oldpass,
			char *newpass)
d175 3
a177 4
	for (i = 0; i < sk_PKCS12_SAFEBAG_num(bags); i++) {
		if (!newpass_bag(sk_PKCS12_SAFEBAG_value(bags, i),
				 oldpass, newpass))
		    return 0;
d192 1
a192 1
	if (!(p8 = PKCS8_decrypt(bag->value.shkeybag, oldpass, -1))) return 0;
@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@d110 1
a110 1
	int i, bagnid, pbe_nid = 0, pbe_iter = 0, pbe_saltlen = 0;
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@a79 1
	/* Check for NULL PKCS12 structure */
d81 13
a93 4
	if(!p12) {
		PKCS12err(PKCS12_F_PKCS12_NEWPASS,PKCS12_R_INVALID_NULL_PKCS12_POINTER);
		return 0;
	}
d95 4
a98 6
	/* Check the mac */
	
	if (!PKCS12_verify_mac(p12, oldpass, -1)) {
		PKCS12err(PKCS12_F_PKCS12_NEWPASS,PKCS12_R_MAC_VERIFY_FAILURE);
		return 0;
	}
d100 1
a100 4
	if (!newpass_p12(p12, oldpass, newpass)) {
		PKCS12err(PKCS12_F_PKCS12_NEWPASS,PKCS12_R_PARSE_ERROR);
		return 0;
	}
a101 1
	return 1;
d209 1
a209 2
        const unsigned char *p;

@


1.1.1.4
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@d123 2
a124 7
			if (!alg_get(p7->d.encrypted->enc_data->algorithm,
				&pbe_nid, &pbe_iter, &pbe_saltlen))
				{
				sk_PKCS12_SAFEBAG_pop_free(bags,
						PKCS12_SAFEBAG_free);
				bags = NULL;
				}
d196 1
a196 3
	if (!alg_get(bag->value.shkeybag->algor, &p8_nid, &p8_iter,
							&p8_saltlen))
		return 0;
a210 2
	if (!pbe)
		return 0;
d215 1
a215 1
        return 1;
@


