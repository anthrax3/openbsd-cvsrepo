head	1.15;
access;
symbols
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.4
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	butholakala:1.5
	openssl_1_0_1_g:1.1.1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	openssl_1_0_1_c:1.1.1.5
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.8
	openssl_1_0_0_f:1.1.1.4
	openssl_1_0_0_e:1.1.1.4
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	openssh_1_0_0_a:1.1.1.4
	OPENBSD_4_8:1.3.0.8
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	openssl_0_9_8_k:1.1.1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	openssl_0_9_8_j:1.1.1.3
	openssl_0_9_8_h:1.1.1.2
	pre_openssl_0_9_8h:1.2
	OPENBSD_4_4:1.2.0.22
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.20
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.18
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.16
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.14
	OPENBSD_4_0_BASE:1.2
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.2.0.12
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.10
	OPENBSD_3_8_BASE:1.2
	OPENSSL_0_9_7G:1.1.1.2
	OPENBSD_3_7:1.2.0.8
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.6
	OPENBSD_3_6_BASE:1.2
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.1.0.4
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2016.09.03.11.33.35;	author beck;	state dead;
branches;
next	1.14;
commitid	HnbXxsegngek41U2;

1.14
date	2015.12.23.01.50.26;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	h26uCaSliqo3t5oa;

1.13
date	2015.02.14.15.15.27;	author miod;	state Exp;
branches;
next	1.12;
commitid	2zugqyZpZdb2LOgt;

1.12
date	2015.02.07.13.19.15;	author doug;	state Exp;
branches;
next	1.11;
commitid	gtwLkRyWx0K1HbzX;

1.11
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.10;
commitid	yQEL1wOWIearrW15;

1.10
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	mJUVYpkFBZ0Zv2bG;

1.9
date	2014.04.18.12.15.48;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.18.00.58.49;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.18.00.10.08;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.09.12.15.27;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.50;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.34.36;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2009.01.09.12.13.51;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.03;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.10.13.21.23.34;	author djm;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Remove the libssl/src directory
@
text
@/* $OpenBSD: tasn_prn.c,v 1.14 2015/12/23 01:50:26 mmcc Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 2000,2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stddef.h>

#include <openssl/asn1.h>
#include <openssl/asn1t.h>
#include <openssl/buffer.h>
#include <openssl/err.h>
#include <openssl/objects.h>
#include <openssl/x509v3.h>

#include "asn1_locl.h"

/* Print routines.
 */

/* ASN1_PCTX routines */

ASN1_PCTX default_pctx = {
	ASN1_PCTX_FLAGS_SHOW_ABSENT,	/* flags */
	0,				/* nm_flags */
	0,				/* cert_flags */
	0,				/* oid_flags */
	0				/* str_flags */
};


ASN1_PCTX *
ASN1_PCTX_new(void)
{
	ASN1_PCTX *ret;
	ret = malloc(sizeof(ASN1_PCTX));
	if (ret == NULL) {
		ASN1err(ASN1_F_ASN1_PCTX_NEW, ERR_R_MALLOC_FAILURE);
		return NULL;
	}
	ret->flags = 0;
	ret->nm_flags = 0;
	ret->cert_flags = 0;
	ret->oid_flags = 0;
	ret->str_flags = 0;
	return ret;
}

void
ASN1_PCTX_free(ASN1_PCTX *p)
{
	free(p);
}

unsigned long
ASN1_PCTX_get_flags(ASN1_PCTX *p)
{
	return p->flags;
}

void
ASN1_PCTX_set_flags(ASN1_PCTX *p, unsigned long flags)
{
	p->flags = flags;
}

unsigned long
ASN1_PCTX_get_nm_flags(ASN1_PCTX *p)
{
	return p->nm_flags;
}

void
ASN1_PCTX_set_nm_flags(ASN1_PCTX *p, unsigned long flags)
{
	p->nm_flags = flags;
}

unsigned long
ASN1_PCTX_get_cert_flags(ASN1_PCTX *p)
{
	return p->cert_flags;
}

void
ASN1_PCTX_set_cert_flags(ASN1_PCTX *p, unsigned long flags)
{
	p->cert_flags = flags;
}

unsigned long
ASN1_PCTX_get_oid_flags(ASN1_PCTX *p)
{
	return p->oid_flags;
}

void
ASN1_PCTX_set_oid_flags(ASN1_PCTX *p, unsigned long flags)
{
	p->oid_flags = flags;
}

unsigned long
ASN1_PCTX_get_str_flags(ASN1_PCTX *p)
{
	return p->str_flags;
}

void
ASN1_PCTX_set_str_flags(ASN1_PCTX *p, unsigned long flags)
{
	p->str_flags = flags;
}

/* Main print routines */

static int asn1_item_print_ctx(BIO *out, ASN1_VALUE **fld, int indent,
    const ASN1_ITEM *it, const char *fname, const char *sname, int nohdr,
    const ASN1_PCTX *pctx);

int asn1_template_print_ctx(BIO *out, ASN1_VALUE **fld, int indent,
    const ASN1_TEMPLATE *tt, const ASN1_PCTX *pctx);

static int asn1_primitive_print(BIO *out, ASN1_VALUE **fld,
    const ASN1_ITEM *it, int indent, const char *fname, const char *sname,
    const ASN1_PCTX *pctx);

static int asn1_print_fsname(BIO *out, int indent, const char *fname,
    const char *sname, const ASN1_PCTX *pctx);

int
ASN1_item_print(BIO *out, ASN1_VALUE *ifld, int indent, const ASN1_ITEM *it,
    const ASN1_PCTX *pctx)
{
	const char *sname;

	if (pctx == NULL)
		pctx = &default_pctx;
	if (pctx->flags & ASN1_PCTX_FLAGS_NO_STRUCT_NAME)
		sname = NULL;
	else
		sname = it->sname;
	return asn1_item_print_ctx(out, &ifld, indent, it, NULL, sname,
	    0, pctx);
}

static int
asn1_item_print_ctx(BIO *out, ASN1_VALUE **fld, int indent, const ASN1_ITEM *it,
    const char *fname, const char *sname, int nohdr, const ASN1_PCTX *pctx)
{
	const ASN1_TEMPLATE *tt;
	const ASN1_EXTERN_FUNCS *ef;
	ASN1_VALUE **tmpfld;
	const ASN1_AUX *aux = it->funcs;
	ASN1_aux_cb *asn1_cb;
	ASN1_PRINT_ARG parg;
	int i;

	if (aux && aux->asn1_cb) {
		parg.out = out;
		parg.indent = indent;
		parg.pctx = pctx;
		asn1_cb = aux->asn1_cb;
	} else
		asn1_cb = NULL;

	if (*fld == NULL) {
		if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_ABSENT) {
			if (!nohdr &&
			    !asn1_print_fsname(out, indent, fname, sname, pctx))
				return 0;
			if (BIO_puts(out, "<ABSENT>\n") <= 0)
				return 0;
		}
		return 1;
	}

	switch (it->itype) {
	case ASN1_ITYPE_PRIMITIVE:
		if (it->templates) {
			if (!asn1_template_print_ctx(out, fld, indent,
			    it->templates, pctx))
				return 0;
		}
		/* fall thru */
	case ASN1_ITYPE_MSTRING:
		if (!asn1_primitive_print(out, fld, it,
		    indent, fname, sname, pctx))
			return 0;
		break;

	case ASN1_ITYPE_EXTERN:
		if (!nohdr &&
		    !asn1_print_fsname(out, indent, fname, sname, pctx))
			return 0;
		/* Use new style print routine if possible */
		ef = it->funcs;
		if (ef && ef->asn1_ex_print) {
			i = ef->asn1_ex_print(out, fld, indent, "", pctx);
			if (!i)
				return 0;
			if ((i == 2) && (BIO_puts(out, "\n") <= 0))
				return 0;
			return 1;
		} else if (sname &&
		    BIO_printf(out, ":EXTERNAL TYPE %s\n", sname) <= 0)
			return 0;
		break;

	case ASN1_ITYPE_CHOICE:
		/* CHOICE type, get selector */
		i = asn1_get_choice_selector(fld, it);
		/* This should never happen... */
		if ((i < 0) || (i >= it->tcount)) {
			if (BIO_printf(out,
			    "ERROR: selector [%d] invalid\n", i) <= 0)
				return 0;
			return 1;
		}
		tt = it->templates + i;
		tmpfld = asn1_get_field_ptr(fld, tt);
		if (!asn1_template_print_ctx(out, tmpfld, indent, tt, pctx))
			return 0;
		break;

	case ASN1_ITYPE_SEQUENCE:
	case ASN1_ITYPE_NDEF_SEQUENCE:
		if (!nohdr &&
		    !asn1_print_fsname(out, indent, fname, sname, pctx))
			return 0;
		if (fname || sname) {
			if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE) {
				if (BIO_puts(out, " {\n") <= 0)
					return 0;
			} else {
				if (BIO_puts(out, "\n") <= 0)
					return 0;
			}
		}

		if (asn1_cb) {
			i = asn1_cb(ASN1_OP_PRINT_PRE, fld, it, &parg);
			if (i == 0)
				return 0;
			if (i == 2)
				return 1;
		}

		/* Print each field entry */
		for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
			const ASN1_TEMPLATE *seqtt;

			seqtt = asn1_do_adb(fld, tt, 1);
			if (seqtt == NULL)
				return 0;
			tmpfld = asn1_get_field_ptr(fld, seqtt);
			if (!asn1_template_print_ctx(out, tmpfld, indent + 2,
			    seqtt, pctx))
				return 0;
		}
		if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE) {
			if (BIO_printf(out, "%*s}\n", indent, "") < 0)
				return 0;
		}

		if (asn1_cb) {
			i = asn1_cb(ASN1_OP_PRINT_POST, fld, it, &parg);
			if (i == 0)
				return 0;
		}
		break;

	default:
		BIO_printf(out, "Unprocessed type %d\n", it->itype);
		return 0;
	}

	return 1;
}

int
asn1_template_print_ctx(BIO *out, ASN1_VALUE **fld, int indent,
    const ASN1_TEMPLATE *tt, const ASN1_PCTX *pctx)
{
	int i, flags;
	const char *sname, *fname;

	flags = tt->flags;
	if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME)
		sname = ASN1_ITEM_ptr(tt->item)->sname;
	else
		sname = NULL;
	if (pctx->flags & ASN1_PCTX_FLAGS_NO_FIELD_NAME)
		fname = NULL;
	else
		fname = tt->field_name;
	if (flags & ASN1_TFLG_SK_MASK) {
		char *tname;
		ASN1_VALUE *skitem;
		STACK_OF(ASN1_VALUE) *stack;

		/* SET OF, SEQUENCE OF */
		if (fname) {
			if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_SSOF) {
				if (flags & ASN1_TFLG_SET_OF)
					tname = "SET";
				else
					tname = "SEQUENCE";
				if (BIO_printf(out, "%*s%s OF %s {\n",
				    indent, "", tname, tt->field_name) <= 0)
					return 0;
			} else if (BIO_printf(out, "%*s%s:\n", indent, "",
			    fname) <= 0)
				return 0;
		}
		stack = (STACK_OF(ASN1_VALUE) *)*fld;
		for (i = 0; i < sk_ASN1_VALUE_num(stack); i++) {
			if ((i > 0) && (BIO_puts(out, "\n") <= 0))
				return 0;
			skitem = sk_ASN1_VALUE_value(stack, i);
			if (!asn1_item_print_ctx(out, &skitem, indent + 2,
			    ASN1_ITEM_ptr(tt->item), NULL, NULL, 1, pctx))
				return 0;
		}
		if (!i && BIO_printf(out, "%*s<EMPTY>\n", indent + 2, "") <= 0)
			return 0;
		if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE) {
			if (BIO_printf(out, "%*s}\n", indent, "") <= 0)
				return 0;
		}
		return 1;
	}
	return asn1_item_print_ctx(out, fld, indent, ASN1_ITEM_ptr(tt->item),
	    fname, sname, 0, pctx);
}

static int
asn1_print_fsname(BIO *out, int indent, const char *fname, const char *sname,
    const ASN1_PCTX *pctx)
{
	static char spaces[] = "                    ";
	const int nspaces = sizeof(spaces) - 1;

	while (indent > nspaces) {
		if (BIO_write(out, spaces, nspaces) != nspaces)
			return 0;
		indent -= nspaces;
	}
	if (BIO_write(out, spaces, indent) != indent)
		return 0;
	if (pctx->flags & ASN1_PCTX_FLAGS_NO_STRUCT_NAME)
		sname = NULL;
	if (pctx->flags & ASN1_PCTX_FLAGS_NO_FIELD_NAME)
		fname = NULL;
	if (!sname && !fname)
		return 1;
	if (fname) {
		if (BIO_puts(out, fname) <= 0)
			return 0;
	}
	if (sname) {
		if (fname) {
			if (BIO_printf(out, " (%s)", sname) <= 0)
				return 0;
		} else {
			if (BIO_puts(out, sname) <= 0)
				return 0;
		}
	}
	if (BIO_write(out, ": ", 2) != 2)
		return 0;
	return 1;
}

static int
asn1_print_boolean_ctx(BIO *out, int boolval, const ASN1_PCTX *pctx)
{
	const char *str;
	switch (boolval) {
	case -1:
		str = "BOOL ABSENT";
		break;

	case 0:
		str = "FALSE";
		break;

	default:
		str = "TRUE";
		break;

	}

	if (BIO_puts(out, str) <= 0)
		return 0;
	return 1;

}

static int
asn1_print_integer_ctx(BIO *out, ASN1_INTEGER *str, const ASN1_PCTX *pctx)
{
	char *s;
	int ret = 1;
	s = i2s_ASN1_INTEGER(NULL, str);
	if (BIO_puts(out, s) <= 0)
		ret = 0;
	free(s);
	return ret;
}

static int
asn1_print_oid_ctx(BIO *out, const ASN1_OBJECT *oid, const ASN1_PCTX *pctx)
{
	char objbuf[80];
	const char *ln;
	ln = OBJ_nid2ln(OBJ_obj2nid(oid));
	if (!ln)
		ln = "";
	OBJ_obj2txt(objbuf, sizeof objbuf, oid, 1);
	if (BIO_printf(out, "%s (%s)", ln, objbuf) <= 0)
		return 0;
	return 1;
}

static int
asn1_print_obstring_ctx(BIO *out, ASN1_STRING *str, int indent,
    const ASN1_PCTX *pctx)
{
	if (str->type == V_ASN1_BIT_STRING) {
		if (BIO_printf(out, " (%ld unused bits)\n",
		    str->flags & 0x7) <= 0)
			return 0;
	} else if (BIO_puts(out, "\n") <= 0)
		return 0;
	if ((str->length > 0) &&
	    BIO_dump_indent(out, (char *)str->data, str->length,
	    indent + 2) <= 0)
		return 0;
	return 1;
}

static int
asn1_primitive_print(BIO *out, ASN1_VALUE **fld, const ASN1_ITEM *it,
    int indent, const char *fname, const char *sname, const ASN1_PCTX *pctx)
{
	long utype;
	ASN1_STRING *str;
	int ret = 1, needlf = 1;
	const char *pname;
	const ASN1_PRIMITIVE_FUNCS *pf;

	pf = it->funcs;
	if (!asn1_print_fsname(out, indent, fname, sname, pctx))
		return 0;
	if (pf && pf->prim_print)
		return pf->prim_print(out, fld, it, indent, pctx);
	str = (ASN1_STRING *)*fld;
	if (it->itype == ASN1_ITYPE_MSTRING)
		utype = str->type & ~V_ASN1_NEG;
	else
		utype = it->utype;
	if (utype == V_ASN1_ANY) {
		ASN1_TYPE *atype = (ASN1_TYPE *)*fld;
		utype = atype->type;
		fld = &atype->value.asn1_value;
		str = (ASN1_STRING *)*fld;
		if (pctx->flags & ASN1_PCTX_FLAGS_NO_ANY_TYPE)
			pname = NULL;
		else
			pname = ASN1_tag2str(utype);
	} else {
		if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_TYPE)
			pname = ASN1_tag2str(utype);
		else
			pname = NULL;
	}

	if (utype == V_ASN1_NULL) {
		if (BIO_puts(out, "NULL\n") <= 0)
			return 0;
		return 1;
	}

	if (pname) {
		if (BIO_puts(out, pname) <= 0)
			return 0;
		if (BIO_puts(out, ":") <= 0)
			return 0;
	}

	switch (utype) {
	case V_ASN1_BOOLEAN:
		{
			int boolval = *(int *)fld;
			if (boolval == -1)
				boolval = it->size;
			ret = asn1_print_boolean_ctx(out, boolval, pctx);
		}
		break;

	case V_ASN1_INTEGER:
	case V_ASN1_ENUMERATED:
		ret = asn1_print_integer_ctx(out, str, pctx);
		break;

	case V_ASN1_UTCTIME:
		ret = ASN1_UTCTIME_print(out, str);
		break;

	case V_ASN1_GENERALIZEDTIME:
		ret = ASN1_GENERALIZEDTIME_print(out, str);
		break;

	case V_ASN1_OBJECT:
		ret = asn1_print_oid_ctx(out, (const ASN1_OBJECT *)*fld, pctx);
		break;

	case V_ASN1_OCTET_STRING:
	case V_ASN1_BIT_STRING:
		ret = asn1_print_obstring_ctx(out, str, indent, pctx);
		needlf = 0;
		break;

	case V_ASN1_SEQUENCE:
	case V_ASN1_SET:
	case V_ASN1_OTHER:
		if (BIO_puts(out, "\n") <= 0)
			return 0;
		if (ASN1_parse_dump(out, str->data, str->length,
		    indent, 0) <= 0)
			ret = 0;
		needlf = 0;
		break;

	default:
		ret = ASN1_STRING_print_ex(out, str, pctx->str_flags);
	}
	if (!ret)
		return 0;
	if (needlf && BIO_puts(out, "\n") <= 0)
		return 0;
	return 1;
}
@


1.14
log
@assign pointer NULL rather than 0
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_prn.c,v 1.13 2015/02/14 15:15:27 miod Exp $ */
@


1.13
log
@Possible NULL pointer dereferences. Coverity CID 21719, 21732.
ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_prn.c,v 1.12 2015/02/07 13:19:15 doug Exp $ */
d217 1
a217 1
		asn1_cb = 0;
@


1.12
log
@Delete a lot of #if 0 code in libressl.

There are a few instances where #if 1 is removed but the code remains.

Based on the following OpenSSL commits.  Some of the commits weren't
strictly deletions so they are going to be split up into separate commits.

6f91b017bbb7140f816721141ac156d1b828a6b3
3d47c1d331fdc7574d2275cda1a630ccdb624b08
dfb56425b68314b2b57e17c82c1df42e7a015132
c8fa2356a00cbaada8963f739e5570298311a060
f16a64d11f55c01f56baa62ebf1dec7f8fe718cb
9ccc00ef6ea65567622e40c49aca43f2c6d79cdb
02a938c953b3e1ced71d9a832de1618f907eb96d
75d0ebef2aef7a2c77b27575b8da898e22f3ccd5
d6fbb194095312f4722c81c9362dbd0de66cb656
6f1a93ad111c7dfe36a09a976c4c009079b19ea1
1a5adcfb5edfe23908b350f8757df405b0f5f71f
8de24b792743d11e1d5a0dcd336a49368750c577
a2b18e657ea1a932d125154f4e13ab2258796d90
8e964419603d2478dfb391c66e7ccb2dcc9776b4
32dfde107636ac9bc62a5b3233fe2a54dbc27008

input + ok jsing@@, miod@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_prn.c,v 1.11 2014/07/11 08:44:47 jsing Exp $ */
d304 1
d306 2
@


1.11
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_prn.c,v 1.10 2014/06/12 15:49:27 deraadt Exp $ */
a262 5
#if 0
		if (!nohdr &&
		    !asn1_print_fsname(out, indent, fname, sname, pctx))
			return 0;
#endif
a391 5

#if 0
	if (!sname && !fname)
		return 1;
#endif
@


1.10
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 1
a60 1
#include "cryptlib.h"
a62 1
#include <openssl/objects.h>
d65 1
d67 1
@


1.9
log
@More KNF.
@
text
@d1 1
a1 1
/* tasn_prn.c */
@


1.8
log
@lob a few more knf grenades in here to soften things up.
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
a58 1

d74 1
a74 2
ASN1_PCTX default_pctx = 
{
d76 4
a79 4
	0,	/* nm_flags */
	0,	/* cert_flags */
	0,	/* oid_flags */
	0	/* str_flags */
a80 1
	
d82 3
a84 1
ASN1_PCTX *ASN1_PCTX_new(void)
d100 2
a101 1
void ASN1_PCTX_free(ASN1_PCTX *p)
d106 2
a107 1
unsigned long ASN1_PCTX_get_flags(ASN1_PCTX *p)
d112 2
a113 1
void ASN1_PCTX_set_flags(ASN1_PCTX *p, unsigned long flags)
d118 2
a119 1
unsigned long ASN1_PCTX_get_nm_flags(ASN1_PCTX *p)
d124 2
a125 1
void ASN1_PCTX_set_nm_flags(ASN1_PCTX *p, unsigned long flags)
d130 2
a131 1
unsigned long ASN1_PCTX_get_cert_flags(ASN1_PCTX *p)
d136 2
a137 1
void ASN1_PCTX_set_cert_flags(ASN1_PCTX *p, unsigned long flags)
d142 2
a143 1
unsigned long ASN1_PCTX_get_oid_flags(ASN1_PCTX *p)
d148 2
a149 1
void ASN1_PCTX_set_oid_flags(ASN1_PCTX *p, unsigned long flags)
d154 2
a155 1
unsigned long ASN1_PCTX_get_str_flags(ASN1_PCTX *p)
d160 2
a161 1
void ASN1_PCTX_set_str_flags(ASN1_PCTX *p, unsigned long flags)
d169 2
a170 3
				const ASN1_ITEM *it,
				const char *fname, const char *sname,
				int nohdr, const ASN1_PCTX *pctx);
d173 1
a173 1
				const ASN1_TEMPLATE *tt, const ASN1_PCTX *pctx);
d176 5
a180 7
				const ASN1_ITEM *it, int indent,
				const char *fname, const char *sname,
				const ASN1_PCTX *pctx);

static int asn1_print_fsname(BIO *out, int indent,
			const char *fname, const char *sname,
			const ASN1_PCTX *pctx);
d182 3
a184 2
int ASN1_item_print(BIO *out, ASN1_VALUE *ifld, int indent,
				const ASN1_ITEM *it, const ASN1_PCTX *pctx)
d187 1
d194 2
a195 2
	return asn1_item_print_ctx(out, &ifld, indent, it,
							NULL, sname, 0, pctx);
d198 3
a200 4
static int asn1_item_print_ctx(BIO *out, ASN1_VALUE **fld, int indent,
				const ASN1_ITEM *it,
				const char *fname, const char *sname,
				int nohdr, const ASN1_PCTX *pctx)
d209 1
d215 2
a216 2
	}
	else asn1_cb = 0;
d218 1
a218 1
	if(*fld == NULL) {
d220 2
a221 2
			if (!nohdr && !asn1_print_fsname(out, indent,
							fname, sname, pctx))
d229 1
a229 1
	switch(it->itype) {
d231 1
a231 1
		if(it->templates) {
d233 1
a233 1
							it->templates, pctx))
d239 1
a239 1
				indent, fname, sname,pctx))
d244 2
a245 1
		if (!nohdr && !asn1_print_fsname(out, indent, fname, sname, pctx))
d256 2
a257 3
		}
		else if (sname && 
			BIO_printf(out, ":EXTERNAL TYPE %s\n", sname) <= 0)
d263 2
a264 1
		if (!nohdr && !asn1_print_fsname(out, indent, fname, sname, pctx))
d270 1
a270 1
		if((i < 0) || (i >= it->tcount)) {
d272 1
a272 1
				"ERROR: selector [%d] invalid\n", i) <= 0)
d284 2
a285 1
		if (!nohdr && !asn1_print_fsname(out, indent, fname, sname, pctx))
d306 1
a306 1
		for(i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
d310 2
a311 2
			if (!asn1_template_print_ctx(out, tmpfld,
						indent + 2, seqtt, pctx))
d326 1
a326 1
		default:
d334 3
a336 2
int asn1_template_print_ctx(BIO *out, ASN1_VALUE **fld, int indent,
				const ASN1_TEMPLATE *tt, const ASN1_PCTX *pctx)
d340 1
d342 1
a342 1
	if(pctx->flags & ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME)
d346 1
a346 1
	if(pctx->flags & ASN1_PCTX_FLAGS_NO_FIELD_NAME)
d350 1
a350 1
	if(flags & ASN1_TFLG_SK_MASK) {
d357 2
a358 2
			if(pctx->flags & ASN1_PCTX_FLAGS_SHOW_SSOF) {
				if(flags & ASN1_TFLG_SET_OF)
d363 1
a363 1
					indent, "", tname, tt->field_name) <= 0)
d365 2
a366 3
			}
			else if (BIO_printf(out, "%*s%s:\n", indent, "",
					fname) <= 0)
d370 1
a370 1
		for(i = 0; i < sk_ASN1_VALUE_num(stack); i++) {
a372 1

d375 1
a375 1
				ASN1_ITEM_ptr(tt->item), NULL, NULL, 1, pctx))
d379 2
a380 2
				return 0;
		if(pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE) {
d387 1
a387 1
							fname, sname, 0, pctx);
d390 3
a392 3
static int asn1_print_fsname(BIO *out, int indent,
			const char *fname, const char *sname,
			const ASN1_PCTX *pctx)
d433 2
a434 2
static int asn1_print_boolean_ctx(BIO *out, int boolval,
							const ASN1_PCTX *pctx)
d446 1
a446 1
		default:
d458 2
a459 2
static int asn1_print_integer_ctx(BIO *out, ASN1_INTEGER *str,
						const ASN1_PCTX *pctx)
d470 2
a471 2
static int asn1_print_oid_ctx(BIO *out, const ASN1_OBJECT *oid,
						const ASN1_PCTX *pctx)
d476 1
a476 1
	if(!ln)
d484 3
a486 2
static int asn1_print_obstring_ctx(BIO *out, ASN1_STRING *str, int indent,
						const ASN1_PCTX *pctx)
d490 3
a492 4
					str->flags & 0x7) <= 0)
				return 0;
	}
	else if (BIO_puts(out, "\n") <= 0)
d494 3
a496 3
	if ((str->length > 0)
		&& BIO_dump_indent(out, (char *)str->data, str->length,
				indent + 2) <= 0)
d501 3
a503 4
static int asn1_primitive_print(BIO *out, ASN1_VALUE **fld,
				const ASN1_ITEM *it, int indent,
				const char *fname, const char *sname,
				const ASN1_PCTX *pctx)
d510 1
d513 1
a513 1
			return 0;
d528 1
a528 1
		else 
d533 1
a533 1
		else 
d589 1
a589 1
						indent, 0) <= 0)
a595 1

@


1.7
log
@putting most of the braces in the right column is the very least we can do.
@
text
@d89 1
a89 2
	if (ret == NULL)
	{
d201 1
a201 2
	if (aux && aux->asn1_cb)
	{
d209 2
a210 4
	if(*fld == NULL)
	{
		if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_ABSENT)
		{
d220 3
a222 5
	switch(it->itype)
	{
		case ASN1_ITYPE_PRIMITIVE:
		if(it->templates)
		{
d228 1
a228 1
		case ASN1_ITYPE_MSTRING:
d234 1
a234 1
		case ASN1_ITYPE_EXTERN:
d239 1
a239 2
		if (ef && ef->asn1_ex_print)
		{
d252 1
a252 1
		case ASN1_ITYPE_CHOICE:
d260 1
a260 2
		if((i < 0) || (i >= it->tcount))
		{
d272 2
a273 2
		case ASN1_ITYPE_SEQUENCE:
		case ASN1_ITYPE_NDEF_SEQUENCE:
d276 2
a277 4
		if (fname || sname)
		{
			if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE)
			{
d280 1
a280 3
			}
			else
			{
d286 1
a286 2
		if (asn1_cb)
		{
d295 1
a295 2
		for(i = 0, tt = it->templates; i < it->tcount; i++, tt++)
		{
d303 1
a303 2
		if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE)
		{
d308 1
a308 2
		if (asn1_cb)
		{
d337 1
a337 2
	if(flags & ASN1_TFLG_SK_MASK)
	{
d343 2
a344 4
		if (fname)
		{
			if(pctx->flags & ASN1_PCTX_FLAGS_SHOW_SSOF)
			{
d358 1
a358 2
		for(i = 0; i < sk_ASN1_VALUE_num(stack); i++)
		{
d369 1
a369 2
		if(pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE)
		{
d391 1
a391 2
	while (indent > nspaces)
	{
d404 1
a404 2
	if (fname)
	{
d408 2
a409 4
	if (sname)
	{
		if (fname)
		{
d412 1
a412 3
		}
		else
		{
d426 2
a427 3
	switch (boolval)
	{
		case -1:
d431 1
a431 1
		case 0:
d476 1
a476 2
	if (str->type == V_ASN1_BIT_STRING)
	{
d510 1
a510 2
	if (utype == V_ASN1_ANY)
	{
d519 1
a519 3
	}
	else
	{
d526 1
a526 2
	if (utype == V_ASN1_NULL)
	{
d532 1
a532 2
	if (pname)
	{
d539 2
a540 3
	switch (utype)
	{
		case V_ASN1_BOOLEAN:
d549 2
a550 2
		case V_ASN1_INTEGER:
		case V_ASN1_ENUMERATED:
d554 1
a554 1
		case V_ASN1_UTCTIME:
d558 1
a558 1
		case V_ASN1_GENERALIZEDTIME:
d562 1
a562 1
		case V_ASN1_OBJECT:
d566 2
a567 2
		case V_ASN1_OCTET_STRING:
		case V_ASN1_BIT_STRING:
d572 3
a574 3
		case V_ASN1_SEQUENCE:
		case V_ASN1_SET:
		case V_ASN1_OTHER:
d583 1
a583 1
		default:
@


1.6
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d76 1
a76 1
	{
d82 1
a82 1
	};
d86 1
a86 1
	{
d90 1
a90 1
		{
d93 1
a93 1
		}
d100 1
a100 1
	}
d103 1
a103 1
	{
d105 1
a105 1
	}
d108 1
a108 1
	{
d110 1
a110 1
	}
d113 1
a113 1
	{
d115 1
a115 1
	}
d118 1
a118 1
	{
d120 1
a120 1
	}
d123 1
a123 1
	{
d125 1
a125 1
	}
d128 1
a128 1
	{
d130 1
a130 1
	}
d133 1
a133 1
	{
d135 1
a135 1
	}
d138 1
a138 1
	{
d140 1
a140 1
	}
d143 1
a143 1
	{
d145 1
a145 1
	}
d148 1
a148 1
	{
d150 1
a150 1
	}
d153 1
a153 1
	{
d155 1
a155 1
	}
d178 1
a178 1
	{
d188 1
a188 1
	}
d194 1
a194 1
	{
d203 1
a203 1
		{
d208 1
a208 1
		}
d212 2
a214 2
		if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_ABSENT)
			{
d220 1
a220 1
			}
d222 1
a222 1
		}
d225 1
a225 1
		{
d228 1
a228 1
			{
d232 1
a232 1
			}
d246 1
a246 1
			{
d253 1
a253 1
			}
d268 1
a268 1
			{
d273 1
a273 1
			}
d285 2
a287 2
			if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE)
				{
d290 1
a290 1
				}
d292 1
a292 1
				{
a294 1
				}
d296 1
d299 1
a299 1
			{
d305 1
a305 1
			}
d309 1
a309 1
			{
d316 1
a316 1
			}
d318 1
a318 1
			{
d321 1
a321 1
			}
d324 1
a324 1
			{
d328 1
a328 1
			}
d334 1
a334 1
		}
d337 1
a337 1
	}
d341 1
a341 1
	{
d354 1
a354 1
		{
d361 2
a363 2
			if(pctx->flags & ASN1_PCTX_FLAGS_SHOW_SSOF)
				{
d371 1
a371 1
				}
d375 1
a375 1
			}
d378 1
a378 1
			{
d386 1
a386 1
			}
d390 1
a390 1
			{
d393 1
a393 1
			}
d395 1
a395 1
		}
d398 1
a398 1
	}
d403 1
a403 1
	{
d413 1
a413 1
		{
d417 1
a417 1
		}
d427 1
a427 1
		{
d430 1
a430 1
		}
d432 2
a434 2
		if (fname)
			{
d437 1
a437 1
			}
d439 1
a439 1
			{
a441 1
			}
d443 1
d447 1
a447 1
	}
d451 1
a451 1
	{
d454 1
a454 1
		{
d467 1
a467 1
		}
d473 1
a473 1
	}
d477 1
a477 1
	{
d485 1
a485 1
	}
d489 1
a489 1
	{
d499 1
a499 1
	}
d503 2
a505 2
	if (str->type == V_ASN1_BIT_STRING)
		{
d509 1
a509 1
		}
d517 1
a517 1
	}
d523 1
a523 1
	{
d540 1
a540 1
		{
d549 1
a549 1
		}
d551 1
a551 1
		{
d556 1
a556 1
		}
d559 1
a559 1
		{
d563 1
a563 1
		}
d566 1
a566 1
		{
d571 1
a571 1
		}
d574 2
a576 2
		case V_ASN1_BOOLEAN:
			{
d581 1
a581 1
			}
d621 1
a621 1
		}
d627 1
a627 1
	}
@


1.5
log
@resolve conflicts
@
text
@d88 1
a88 1
	ret = OPENSSL_malloc(sizeof(ASN1_PCTX));
d104 1
a104 1
	OPENSSL_free(p);
d483 1
a483 1
	OPENSSL_free(s);
@


1.4
log
@resolve conflicts, fix local changes
@
text
@d449 1
a449 1
static int asn1_print_boolean_ctx(BIO *out, const int bool,
d453 1
a453 1
	switch (bool)
d577 4
a580 4
			int bool = *(int *)fld;
			if (bool == -1)
				bool = it->size;
			ret = asn1_print_boolean_ctx(out, bool, pctx);
@


1.3
log
@resolve conflicts
@
text
@d6 1
a6 1
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
d61 1
d63 1
d67 2
a68 1
#include <openssl/nasn.h>
d70 1
a70 1
/* Print routines. Print out a whole structure from a template.
d73 1
a73 1
static int asn1_item_print_nm(BIO *out, void *fld, int indent, const ASN1_ITEM *it, const char *name);
d75 66
a140 4
int ASN1_item_print(BIO *out, void *fld, int indent, const ASN1_ITEM *it)
{
	return asn1_item_print_nm(out, fld, indent, it, it->sname);
}
d142 53
a194 3
static int asn1_item_print_nm(BIO *out, void *fld, int indent, const ASN1_ITEM *it, const char *name)
{
	ASN1_STRING *str;
d196 5
a200 1
	void *tmpfld;
d202 19
a220 2
	if(!fld) {
		BIO_printf(out, "%*s%s ABSENT\n", indent, "", name);
d222 1
a222 2
	}
	switch(it->itype) {
d224 2
d228 10
a237 2
			return ASN1_template_print(out, fld, indent, it->templates);
		return asn1_primitive_print(out, fld, it->utype, indent, name);
a239 4
		case ASN1_ITYPE_MSTRING:
		str = fld;
		return asn1_primitive_print(out, fld, str->type, indent, name);

d241 17
a257 6
		BIO_printf(out, "%*s%s:EXTERNAL TYPE %s %s\n", indent, "", name, it->sname, fld ? "" : "ABSENT");
		return 1;
		case ASN1_ITYPE_COMPAT:
		BIO_printf(out, "%*s%s:COMPATIBLE TYPE %s %s\n", indent, "", name, it->sname, fld ? "" : "ABSENT");
		return 1;

d260 4
d267 5
a271 2
		if((i < 0) || (i >= it->tcount)) {
			BIO_printf(out, "%s selector [%d] out of range\n", it->sname, i);
d273 1
a273 1
		}
d275 4
a278 2
		tmpfld = asn1_get_field(fld, tt);
		return ASN1_template_print(out, tmpfld, indent, tt);
d281 49
a329 8
		BIO_printf(out, "%*s%s {\n", indent, "", name);
		/* Get each field entry */
		for(i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
			tmpfld = asn1_get_field(fld, tt);
			ASN1_template_print(out, tmpfld, indent + 2, tt);
		}
		BIO_printf(out, "%*s}\n", indent, "");
		return 1;
d332 1
d334 3
a337 1
}
d339 3
a341 2
int ASN1_template_print(BIO *out, void *fld, int indent, const ASN1_TEMPLATE *tt)
{
d343 1
a343 3
#if 0
	if(!fld) return 0; 
#endif
d345 10
a354 1
	if(flags & ASN1_TFLG_SK_MASK) {
d356 3
a358 1
		void *skitem;
d360 65
a424 11
		if(flags & ASN1_TFLG_SET_OF) tname = "SET";
		else tname = "SEQUENCE";
		if(fld) {
			BIO_printf(out, "%*s%s OF %s {\n", indent, "", tname, tt->field_name);
			for(i = 0; i < sk_num(fld); i++) {
				skitem = sk_value(fld, i);
				asn1_item_print_nm(out, skitem, indent + 2, tt->item, "");
			}
			BIO_printf(out, "%*s}\n", indent, "");
		} else 
			BIO_printf(out, "%*s%s OF %s ABSENT\n", indent, "", tname, tt->field_name);
d426 73
a499 2
	return asn1_item_print_nm(out, fld, indent, tt->item, tt->field_name);
}
d501 8
a508 33
static int asn1_primitive_print(BIO *out, void *fld, long utype, int indent, const char *name)
{
	ASN1_STRING *str = fld;
	if(fld) {
		if(utype == V_ASN1_BOOLEAN) {
			int *bool = fld;
if(*bool == -1) printf("BOOL MISSING\n");
			BIO_printf(out, "%*s%s:%s", indent, "", "BOOLEAN", *bool ? "TRUE" : "FALSE");
		} else if((utype == V_ASN1_INTEGER) 
			  || (utype == V_ASN1_ENUMERATED)) {
			char *s, *nm;
			s = i2s_ASN1_INTEGER(NULL, fld);
			if(utype == V_ASN1_INTEGER) nm = "INTEGER";
			else nm = "ENUMERATED";
			BIO_printf(out, "%*s%s:%s", indent, "", nm, s);
			OPENSSL_free(s);
		} else if(utype == V_ASN1_NULL) {
			BIO_printf(out, "%*s%s", indent, "", "NULL");
		} else if(utype == V_ASN1_UTCTIME) {
			BIO_printf(out, "%*s%s:%s:", indent, "", name, "UTCTIME");
			ASN1_UTCTIME_print(out, str);
		} else if(utype == V_ASN1_GENERALIZEDTIME) {
			BIO_printf(out, "%*s%s:%s:", indent, "", name, "GENERALIZEDTIME");
			ASN1_GENERALIZEDTIME_print(out, str);
		} else if(utype == V_ASN1_OBJECT) {
			char objbuf[80], *ln;
			ln = OBJ_nid2ln(OBJ_obj2nid(fld));
			if(!ln) ln = "";
			OBJ_obj2txt(objbuf, sizeof objbuf, fld, 1);
			BIO_printf(out, "%*s%s:%s (%s)", indent, "", "OBJECT", ln, objbuf);
		} else {
			BIO_printf(out, "%*s%s:", indent, "", name);
			ASN1_STRING_print_ex(out, str, ASN1_STRFLGS_DUMP_UNKNOWN|ASN1_STRFLGS_SHOW_TYPE);
d510 6
a515 2
		BIO_printf(out, "\n");
	} else BIO_printf(out, "%*s%s [ABSENT]\n", indent, "", name);
d517 111
a627 1
}
@


1.2
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d189 1
a189 1
			OBJ_obj2txt(objbuf, 80, fld, 1);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@d189 1
a189 1
			OBJ_obj2txt(objbuf, sizeof objbuf, fld, 1);
@


1.1.1.3
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@d6 1
a6 1
 * Copyright (c) 2000,2005 The OpenSSL Project.  All rights reserved.
a60 1
#include "cryptlib.h"
a61 1
#include <openssl/asn1t.h>
d65 1
a65 2
#include <openssl/x509v3.h>
#include "asn1_locl.h"
d67 1
a67 1
/* Print routines.
d70 1
a70 1
/* ASN1_PCTX routines */
d72 4
a75 26
ASN1_PCTX default_pctx = 
	{
	ASN1_PCTX_FLAGS_SHOW_ABSENT,	/* flags */
	0,	/* nm_flags */
	0,	/* cert_flags */
	0,	/* oid_flags */
	0	/* str_flags */
	};
	

ASN1_PCTX *ASN1_PCTX_new(void)
	{
	ASN1_PCTX *ret;
	ret = OPENSSL_malloc(sizeof(ASN1_PCTX));
	if (ret == NULL)
		{
		ASN1err(ASN1_F_ASN1_PCTX_NEW, ERR_R_MALLOC_FAILURE);
		return NULL;
		}
	ret->flags = 0;
	ret->nm_flags = 0;
	ret->cert_flags = 0;
	ret->oid_flags = 0;
	ret->str_flags = 0;
	return ret;
	}
d77 3
a79 93
void ASN1_PCTX_free(ASN1_PCTX *p)
	{
	OPENSSL_free(p);
	}

unsigned long ASN1_PCTX_get_flags(ASN1_PCTX *p)
	{
	return p->flags;
	}

void ASN1_PCTX_set_flags(ASN1_PCTX *p, unsigned long flags)
	{
	p->flags = flags;
	}

unsigned long ASN1_PCTX_get_nm_flags(ASN1_PCTX *p)
	{
	return p->nm_flags;
	}

void ASN1_PCTX_set_nm_flags(ASN1_PCTX *p, unsigned long flags)
	{
	p->nm_flags = flags;
	}

unsigned long ASN1_PCTX_get_cert_flags(ASN1_PCTX *p)
	{
	return p->cert_flags;
	}

void ASN1_PCTX_set_cert_flags(ASN1_PCTX *p, unsigned long flags)
	{
	p->cert_flags = flags;
	}

unsigned long ASN1_PCTX_get_oid_flags(ASN1_PCTX *p)
	{
	return p->oid_flags;
	}

void ASN1_PCTX_set_oid_flags(ASN1_PCTX *p, unsigned long flags)
	{
	p->oid_flags = flags;
	}

unsigned long ASN1_PCTX_get_str_flags(ASN1_PCTX *p)
	{
	return p->str_flags;
	}

void ASN1_PCTX_set_str_flags(ASN1_PCTX *p, unsigned long flags)
	{
	p->str_flags = flags;
	}

/* Main print routines */

static int asn1_item_print_ctx(BIO *out, ASN1_VALUE **fld, int indent,
				const ASN1_ITEM *it,
				const char *fname, const char *sname,
				int nohdr, const ASN1_PCTX *pctx);

int asn1_template_print_ctx(BIO *out, ASN1_VALUE **fld, int indent,
				const ASN1_TEMPLATE *tt, const ASN1_PCTX *pctx);

static int asn1_primitive_print(BIO *out, ASN1_VALUE **fld,
				const ASN1_ITEM *it, int indent,
				const char *fname, const char *sname,
				const ASN1_PCTX *pctx);

static int asn1_print_fsname(BIO *out, int indent,
			const char *fname, const char *sname,
			const ASN1_PCTX *pctx);

int ASN1_item_print(BIO *out, ASN1_VALUE *ifld, int indent,
				const ASN1_ITEM *it, const ASN1_PCTX *pctx)
	{
	const char *sname;
	if (pctx == NULL)
		pctx = &default_pctx;
	if (pctx->flags & ASN1_PCTX_FLAGS_NO_STRUCT_NAME)
		sname = NULL;
	else
		sname = it->sname;
	return asn1_item_print_ctx(out, &ifld, indent, it,
							NULL, sname, 0, pctx);
	}

static int asn1_item_print_ctx(BIO *out, ASN1_VALUE **fld, int indent,
				const ASN1_ITEM *it,
				const char *fname, const char *sname,
				int nohdr, const ASN1_PCTX *pctx)
	{
d81 1
a81 5
	const ASN1_EXTERN_FUNCS *ef;
	ASN1_VALUE **tmpfld;
	const ASN1_AUX *aux = it->funcs;
	ASN1_aux_cb *asn1_cb;
	ASN1_PRINT_ARG parg;
d83 2
a84 19
	if (aux && aux->asn1_cb)
		{
		parg.out = out;
		parg.indent = indent;
		parg.pctx = pctx;
		asn1_cb = aux->asn1_cb;
		}
	else asn1_cb = 0;

	if(*fld == NULL)
		{
		if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_ABSENT)
			{
			if (!nohdr && !asn1_print_fsname(out, indent,
							fname, sname, pctx))
				return 0;
			if (BIO_puts(out, "<ABSENT>\n") <= 0)
				return 0;
			}
d86 2
a87 1
		}
a88 2
	switch(it->itype)
		{
d91 4
a94 6
			{
			if (!asn1_template_print_ctx(out, fld, indent,
							it->templates, pctx))
				return 0;
			}
		/* fall thru */
d96 2
a97 4
		if (!asn1_primitive_print(out, fld, it,
				indent, fname, sname,pctx))
			return 0;
		break;
d100 6
a105 17
		if (!nohdr && !asn1_print_fsname(out, indent, fname, sname, pctx))
			return 0;
		/* Use new style print routine if possible */
		ef = it->funcs;
		if (ef && ef->asn1_ex_print)
			{
			i = ef->asn1_ex_print(out, fld, indent, "", pctx);
			if (!i)
				return 0;
			if ((i == 2) && (BIO_puts(out, "\n") <= 0))
				return 0;
			return 1;
			}
		else if (sname && 
			BIO_printf(out, ":EXTERNAL TYPE %s\n", sname) <= 0)
			return 0;
		break;
a107 4
#if 0
		if (!nohdr && !asn1_print_fsname(out, indent, fname, sname, pctx))
			return 0;
#endif
d111 2
a112 5
		if((i < 0) || (i >= it->tcount))
			{
			if (BIO_printf(out,
				"ERROR: selector [%d] invalid\n", i) <= 0)
				return 0;
d114 1
a114 1
			}
d116 2
a117 4
		tmpfld = asn1_get_field_ptr(fld, tt);
		if (!asn1_template_print_ctx(out, tmpfld, indent, tt, pctx))
			return 0;
		break;
d120 8
a127 49
		case ASN1_ITYPE_NDEF_SEQUENCE:
		if (!nohdr && !asn1_print_fsname(out, indent, fname, sname, pctx))
			return 0;
		if (fname || sname)
			{
			if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE)
				{
				if (BIO_puts(out, " {\n") <= 0)
					return 0;
				}
			else
				{
				if (BIO_puts(out, "\n") <= 0)
					return 0;
				}
			}

		if (asn1_cb)
			{
			i = asn1_cb(ASN1_OP_PRINT_PRE, fld, it, &parg);
			if (i == 0)
				return 0;
			if (i == 2)
				return 1;
			}

		/* Print each field entry */
		for(i = 0, tt = it->templates; i < it->tcount; i++, tt++)
			{
			const ASN1_TEMPLATE *seqtt;
			seqtt = asn1_do_adb(fld, tt, 1);
			tmpfld = asn1_get_field_ptr(fld, seqtt);
			if (!asn1_template_print_ctx(out, tmpfld,
						indent + 2, seqtt, pctx))
				return 0;
			}
		if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE)
			{
			if (BIO_printf(out, "%*s}\n", indent, "") < 0)
				return 0;
			}

		if (asn1_cb)
			{
			i = asn1_cb(ASN1_OP_PRINT_POST, fld, it, &parg);
			if (i == 0)
				return 0;
			}
		break;
a129 1
		BIO_printf(out, "Unprocessed type %d\n", it->itype);
a130 3
		}

	return 1;
d132 1
d134 2
a135 3
int asn1_template_print_ctx(BIO *out, ASN1_VALUE **fld, int indent,
				const ASN1_TEMPLATE *tt, const ASN1_PCTX *pctx)
	{
d137 3
a139 1
	const char *sname, *fname;
d141 1
a141 10
	if(pctx->flags & ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME)
		sname = ASN1_ITEM_ptr(tt->item)->sname;
	else
		sname = NULL;
	if(pctx->flags & ASN1_PCTX_FLAGS_NO_FIELD_NAME)
		fname = NULL;
	else
		fname = tt->field_name;
	if(flags & ASN1_TFLG_SK_MASK)
		{
d143 1
a143 3
		ASN1_VALUE *skitem;
		STACK_OF(ASN1_VALUE) *stack;

d145 11
a155 65
		if (fname)
			{
			if(pctx->flags & ASN1_PCTX_FLAGS_SHOW_SSOF)
				{
				if(flags & ASN1_TFLG_SET_OF)
					tname = "SET";
				else
					tname = "SEQUENCE";
				if (BIO_printf(out, "%*s%s OF %s {\n",
					indent, "", tname, tt->field_name) <= 0)
					return 0;
				}
			else if (BIO_printf(out, "%*s%s:\n", indent, "",
					fname) <= 0)
				return 0;
			}
		stack = (STACK_OF(ASN1_VALUE) *)*fld;
		for(i = 0; i < sk_ASN1_VALUE_num(stack); i++)
			{
			if ((i > 0) && (BIO_puts(out, "\n") <= 0))
				return 0;

			skitem = sk_ASN1_VALUE_value(stack, i);
			if (!asn1_item_print_ctx(out, &skitem, indent + 2,
				ASN1_ITEM_ptr(tt->item), NULL, NULL, 1, pctx))
				return 0;
			}
		if (!i && BIO_printf(out, "%*s<EMPTY>\n", indent + 2, "") <= 0)
				return 0;
		if(pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE)
			{
			if (BIO_printf(out, "%*s}\n", indent, "") <= 0)
				return 0;
			}
		return 1;
		}
	return asn1_item_print_ctx(out, fld, indent, ASN1_ITEM_ptr(tt->item),
							fname, sname, 0, pctx);
	}

static int asn1_print_fsname(BIO *out, int indent,
			const char *fname, const char *sname,
			const ASN1_PCTX *pctx)
	{
	static char spaces[] = "                    ";
	const int nspaces = sizeof(spaces) - 1;

#if 0
	if (!sname && !fname)
		return 1;
#endif

	while (indent > nspaces)
		{
		if (BIO_write(out, spaces, nspaces) != nspaces)
			return 0;
		indent -= nspaces;
		}
	if (BIO_write(out, spaces, indent) != indent)
		return 0;
	if (pctx->flags & ASN1_PCTX_FLAGS_NO_STRUCT_NAME)
		sname = NULL;
	if (pctx->flags & ASN1_PCTX_FLAGS_NO_FIELD_NAME)
		fname = NULL;
	if (!sname && !fname)
a156 73
	if (fname)
		{
		if (BIO_puts(out, fname) <= 0)
			return 0;
		}
	if (sname)
		{
		if (fname)
			{
			if (BIO_printf(out, " (%s)", sname) <= 0)
				return 0;
			}
		else
			{
			if (BIO_puts(out, sname) <= 0)
				return 0;
			}
		}
	if (BIO_write(out, ": ", 2) != 2)
		return 0;
	return 1;
	}

static int asn1_print_boolean_ctx(BIO *out, const int bool,
							const ASN1_PCTX *pctx)
	{
	const char *str;
	switch (bool)
		{
		case -1:
		str = "BOOL ABSENT";
		break;

		case 0:
		str = "FALSE";
		break;

		default:
		str = "TRUE";
		break;

		}

	if (BIO_puts(out, str) <= 0)
		return 0;
	return 1;

	}

static int asn1_print_integer_ctx(BIO *out, ASN1_INTEGER *str,
						const ASN1_PCTX *pctx)
	{
	char *s;
	int ret = 1;
	s = i2s_ASN1_INTEGER(NULL, str);
	if (BIO_puts(out, s) <= 0)
		ret = 0;
	OPENSSL_free(s);
	return ret;
	}

static int asn1_print_oid_ctx(BIO *out, const ASN1_OBJECT *oid,
						const ASN1_PCTX *pctx)
	{
	char objbuf[80];
	const char *ln;
	ln = OBJ_nid2ln(OBJ_obj2nid(oid));
	if(!ln)
		ln = "";
	OBJ_obj2txt(objbuf, sizeof objbuf, oid, 1);
	if (BIO_printf(out, "%s (%s)", ln, objbuf) <= 0)
		return 0;
	return 1;
d158 2
d161 33
a193 8
static int asn1_print_obstring_ctx(BIO *out, ASN1_STRING *str, int indent,
						const ASN1_PCTX *pctx)
	{
	if (str->type == V_ASN1_BIT_STRING)
		{
		if (BIO_printf(out, " (%ld unused bits)\n",
					str->flags & 0x7) <= 0)
				return 0;
d195 2
a196 6
	else if (BIO_puts(out, "\n") <= 0)
		return 0;
	if ((str->length > 0)
		&& BIO_dump_indent(out, (char *)str->data, str->length,
				indent + 2) <= 0)
		return 0;
d198 1
a198 111
	}

static int asn1_primitive_print(BIO *out, ASN1_VALUE **fld,
				const ASN1_ITEM *it, int indent,
				const char *fname, const char *sname,
				const ASN1_PCTX *pctx)
	{
	long utype;
	ASN1_STRING *str;
	int ret = 1, needlf = 1;
	const char *pname;
	const ASN1_PRIMITIVE_FUNCS *pf;
	pf = it->funcs;
	if (!asn1_print_fsname(out, indent, fname, sname, pctx))
			return 0;
	if (pf && pf->prim_print)
		return pf->prim_print(out, fld, it, indent, pctx);
	str = (ASN1_STRING *)*fld;
	if (it->itype == ASN1_ITYPE_MSTRING)
		utype = str->type & ~V_ASN1_NEG;
	else
		utype = it->utype;
	if (utype == V_ASN1_ANY)
		{
		ASN1_TYPE *atype = (ASN1_TYPE *)*fld;
		utype = atype->type;
		fld = &atype->value.asn1_value;
		str = (ASN1_STRING *)*fld;
		if (pctx->flags & ASN1_PCTX_FLAGS_NO_ANY_TYPE)
			pname = NULL;
		else 
			pname = ASN1_tag2str(utype);
		}
	else
		{
		if (pctx->flags & ASN1_PCTX_FLAGS_SHOW_TYPE)
			pname = ASN1_tag2str(utype);
		else 
			pname = NULL;
		}

	if (utype == V_ASN1_NULL)
		{
		if (BIO_puts(out, "NULL\n") <= 0)
			return 0;
		return 1;
		}

	if (pname)
		{
		if (BIO_puts(out, pname) <= 0)
			return 0;
		if (BIO_puts(out, ":") <= 0)
			return 0;
		}

	switch (utype)
		{
		case V_ASN1_BOOLEAN:
			{
			int bool = *(int *)fld;
			if (bool == -1)
				bool = it->size;
			ret = asn1_print_boolean_ctx(out, bool, pctx);
			}
		break;

		case V_ASN1_INTEGER:
		case V_ASN1_ENUMERATED:
		ret = asn1_print_integer_ctx(out, str, pctx);
		break;

		case V_ASN1_UTCTIME:
		ret = ASN1_UTCTIME_print(out, str);
		break;

		case V_ASN1_GENERALIZEDTIME:
		ret = ASN1_GENERALIZEDTIME_print(out, str);
		break;

		case V_ASN1_OBJECT:
		ret = asn1_print_oid_ctx(out, (const ASN1_OBJECT *)*fld, pctx);
		break;

		case V_ASN1_OCTET_STRING:
		case V_ASN1_BIT_STRING:
		ret = asn1_print_obstring_ctx(out, str, indent, pctx);
		needlf = 0;
		break;

		case V_ASN1_SEQUENCE:
		case V_ASN1_SET:
		case V_ASN1_OTHER:
		if (BIO_puts(out, "\n") <= 0)
			return 0;
		if (ASN1_parse_dump(out, str->data, str->length,
						indent, 0) <= 0)
			ret = 0;
		needlf = 0;
		break;

		default:
		ret = ASN1_STRING_print_ex(out, str, pctx->str_flags);

		}
	if (!ret)
		return 0;
	if (needlf && BIO_puts(out, "\n") <= 0)
		return 0;
	return 1;
	}
@


1.1.1.5
log
@import OpenSSL-1.0.1c
@
text
@d449 1
a449 1
static int asn1_print_boolean_ctx(BIO *out, int boolval,
d453 1
a453 1
	switch (boolval)
d577 4
a580 4
			int boolval = *(int *)fld;
			if (boolval == -1)
				boolval = it->size;
			ret = asn1_print_boolean_ctx(out, boolval, pctx);
@


