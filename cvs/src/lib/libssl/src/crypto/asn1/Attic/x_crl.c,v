head	1.26;
access;
symbols
	OPENBSD_6_0:1.25.0.6
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.4
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	butholakala:1.9
	openssl_1_0_1_g:1.1.1.5
	OPENBSD_5_5:1.9.0.16
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.12
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	openssl_1_0_1_c:1.1.1.5
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	openssl_1_0_0_f:1.1.1.5
	openssl_1_0_0_e:1.1.1.5
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	openssh_1_0_0_a:1.1.1.5
	OPENBSD_4_8:1.8.0.8
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	openssl_0_9_8_k:1.1.1.4
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	openssl_0_9_8_j:1.1.1.4
	openssl_0_9_8_h:1.1.1.4
	pre_openssl_0_9_8h:1.7
	OPENBSD_4_4:1.7.0.14
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.12
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.10
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.8
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.6
	OPENBSD_4_0_BASE:1.7
	openssl_0_9_7j:1.1.1.3
	openssl:1.1.1
	OPENBSD_3_9:1.7.0.4
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENSSL_0_9_7G:1.1.1.3
	OPENBSD_3_7:1.6.0.12
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.10
	OPENBSD_3_6_BASE:1.6
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2016.09.03.11.33.35;	author beck;	state dead;
branches;
next	1.25;
commitid	HnbXxsegngek41U2;

1.25
date	2015.07.20.15.29.13;	author miod;	state Exp;
branches;
next	1.24;
commitid	73iSboxCVX9GdDlG;

1.24
date	2015.02.11.04.00.39;	author jsing;	state Exp;
branches;
next	1.23;
commitid	QCjRtjn2xv9owjIW;

1.23
date	2015.02.11.03.39.51;	author jsing;	state Exp;
branches;
next	1.22;
commitid	PWeA1V6nbEryguKH;

1.22
date	2015.02.10.08.33.10;	author jsing;	state Exp;
branches;
next	1.21;
commitid	v5VD2cgZRaYX8ah1;

1.21
date	2015.02.10.05.25.45;	author jsing;	state Exp;
branches;
next	1.20;
commitid	HQSAPkY0rIzvWYsC;

1.20
date	2015.02.10.04.21.50;	author jsing;	state Exp;
branches;
next	1.19;
commitid	lmzaeFtqKbLCKhxJ;

1.19
date	2015.02.09.15.05.59;	author jsing;	state Exp;
branches;
next	1.18;
commitid	X3hE8E9VwC2nOKbW;

1.18
date	2014.07.11.13.54.41;	author miod;	state Exp;
branches;
next	1.17;
commitid	yeDsKDTGMFGrXMye;

1.17
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.16;
commitid	yQEL1wOWIearrW15;

1.16
date	2014.07.10.22.45.56;	author jsing;	state Exp;
branches;
next	1.15;
commitid	nzndm3zqPmFurSaK;

1.15
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	mJUVYpkFBZ0Zv2bG;

1.14
date	2014.04.27.20.26.46;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.18.11.20.32;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.18.00.58.49;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.18.00.10.08;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.29.05.39.18;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.02.56;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.13;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.08.51;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.34;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.51;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.51;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.51;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.05.37.03;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.40;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.03;	author djm;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Remove the libssl/src directory
@
text
@/* $OpenBSD: x_crl.c,v 1.25 2015/07/20 15:29:13 miod Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <stdio.h>

#include <openssl/opensslconf.h>

#include <openssl/asn1t.h>
#include <openssl/err.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>

#include "asn1_locl.h"

static int X509_REVOKED_cmp(const X509_REVOKED * const *a,
    const X509_REVOKED * const *b);
static void setup_idp(X509_CRL *crl, ISSUING_DIST_POINT *idp);

static const ASN1_TEMPLATE X509_REVOKED_seq_tt[] = {
	{
		.offset = offsetof(X509_REVOKED, serialNumber),
		.field_name = "serialNumber",
		.item = &ASN1_INTEGER_it,
	},
	{
		.offset = offsetof(X509_REVOKED, revocationDate),
		.field_name = "revocationDate",
		.item = &ASN1_TIME_it,
	},
	{
		.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
		.offset = offsetof(X509_REVOKED, extensions),
		.field_name = "extensions",
		.item = &X509_EXTENSION_it,
	},
};

const ASN1_ITEM X509_REVOKED_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = X509_REVOKED_seq_tt,
	.tcount = sizeof(X509_REVOKED_seq_tt) / sizeof(ASN1_TEMPLATE),
	.size = sizeof(X509_REVOKED),
	.sname = "X509_REVOKED",
};

static int def_crl_verify(X509_CRL *crl, EVP_PKEY *r);
static int def_crl_lookup(X509_CRL *crl, X509_REVOKED **ret,
    ASN1_INTEGER *serial, X509_NAME *issuer);

static X509_CRL_METHOD int_crl_meth = {
	.crl_lookup = def_crl_lookup,
	.crl_verify = def_crl_verify
};

static const X509_CRL_METHOD *default_crl_method = &int_crl_meth;

/* The X509_CRL_INFO structure needs a bit of customisation.
 * Since we cache the original encoding the signature wont be affected by
 * reordering of the revoked field.
 */
static int
crl_inf_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg)
{
	X509_CRL_INFO *a = (X509_CRL_INFO *)*pval;

	if (!a || !a->revoked)
		return 1;
	switch (operation) {
		/* Just set cmp function here. We don't sort because that
		 * would affect the output of X509_CRL_print().
		 */
	case ASN1_OP_D2I_POST:
		(void)sk_X509_REVOKED_set_cmp_func(a->revoked, X509_REVOKED_cmp);
		break;
	}
	return 1;
}


static const ASN1_AUX X509_CRL_INFO_aux = {
	.flags = ASN1_AFLG_ENCODING,
	.asn1_cb = crl_inf_cb,
	.enc_offset = offsetof(X509_CRL_INFO, enc),
};
static const ASN1_TEMPLATE X509_CRL_INFO_seq_tt[] = {
	{
		.flags = ASN1_TFLG_OPTIONAL,
		.offset = offsetof(X509_CRL_INFO, version),
		.field_name = "version",
		.item = &ASN1_INTEGER_it,
	},
	{
		.offset = offsetof(X509_CRL_INFO, sig_alg),
		.field_name = "sig_alg",
		.item = &X509_ALGOR_it,
	},
	{
		.offset = offsetof(X509_CRL_INFO, issuer),
		.field_name = "issuer",
		.item = &X509_NAME_it,
	},
	{
		.offset = offsetof(X509_CRL_INFO, lastUpdate),
		.field_name = "lastUpdate",
		.item = &ASN1_TIME_it,
	},
	{
		.flags = ASN1_TFLG_OPTIONAL,
		.offset = offsetof(X509_CRL_INFO, nextUpdate),
		.field_name = "nextUpdate",
		.item = &ASN1_TIME_it,
	},
	{
		.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
		.offset = offsetof(X509_CRL_INFO, revoked),
		.field_name = "revoked",
		.item = &X509_REVOKED_it,
	},
	{
		.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
		.offset = offsetof(X509_CRL_INFO, extensions),
		.field_name = "extensions",
		.item = &X509_EXTENSION_it,
	},
};

const ASN1_ITEM X509_CRL_INFO_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = X509_CRL_INFO_seq_tt,
	.tcount = sizeof(X509_CRL_INFO_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = &X509_CRL_INFO_aux,
	.size = sizeof(X509_CRL_INFO),
	.sname = "X509_CRL_INFO",
};

/* Set CRL entry issuer according to CRL certificate issuer extension.
 * Check for unhandled critical CRL entry extensions.
 */

static int
crl_set_issuers(X509_CRL *crl)
{
	int i, j;
	GENERAL_NAMES *gens, *gtmp;
	STACK_OF(X509_REVOKED) *revoked;

	revoked = X509_CRL_get_REVOKED(crl);

	gens = NULL;
	for (i = 0; i < sk_X509_REVOKED_num(revoked); i++) {
		X509_REVOKED *rev = sk_X509_REVOKED_value(revoked, i);
		STACK_OF(X509_EXTENSION) *exts;
		ASN1_ENUMERATED *reason;
		X509_EXTENSION *ext;
		gtmp = X509_REVOKED_get_ext_d2i(rev, NID_certificate_issuer,
		    &j, NULL);
		if (!gtmp && (j != -1)) {
			crl->flags |= EXFLAG_INVALID;
			return 1;
		}

		if (gtmp) {
			gens = gtmp;
			if (!crl->issuers) {
				crl->issuers = sk_GENERAL_NAMES_new_null();
				if (!crl->issuers)
					return 0;
			}
			if (!sk_GENERAL_NAMES_push(crl->issuers, gtmp))
				return 0;
		}
		rev->issuer = gens;

		reason = X509_REVOKED_get_ext_d2i(rev, NID_crl_reason,
		    &j, NULL);
		if (!reason && (j != -1)) {
			crl->flags |= EXFLAG_INVALID;
			return 1;
		}

		if (reason) {
			rev->reason = ASN1_ENUMERATED_get(reason);
			ASN1_ENUMERATED_free(reason);
		} else
			rev->reason = CRL_REASON_NONE;

		/* Check for critical CRL entry extensions */

		exts = rev->extensions;

		for (j = 0; j < sk_X509_EXTENSION_num(exts); j++) {
			ext = sk_X509_EXTENSION_value(exts, j);
			if (ext->critical > 0) {
				if (OBJ_obj2nid(ext->object) ==
				    NID_certificate_issuer)
					continue;
				crl->flags |= EXFLAG_CRITICAL;
				break;
			}
		}
	}

	return 1;
}

/* The X509_CRL structure needs a bit of customisation. Cache some extensions
 * and hash of the whole CRL.
 */
static int
crl_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg)
{
	X509_CRL *crl = (X509_CRL *)*pval;
	STACK_OF(X509_EXTENSION) *exts;
	X509_EXTENSION *ext;
	int idx;
	int rc = 1;

	switch (operation) {
	case ASN1_OP_NEW_POST:
		crl->idp = NULL;
		crl->akid = NULL;
		crl->flags = 0;
		crl->idp_flags = 0;
		crl->idp_reasons = CRLDP_ALL_REASONS;
		crl->meth = default_crl_method;
		crl->meth_data = NULL;
		crl->issuers = NULL;
		crl->crl_number = NULL;
		crl->base_crl_number = NULL;
		break;

	case ASN1_OP_D2I_POST:
#ifndef OPENSSL_NO_SHA
		X509_CRL_digest(crl, EVP_sha1(), crl->sha1_hash, NULL);
#endif
		crl->idp = X509_CRL_get_ext_d2i(crl,
		    NID_issuing_distribution_point, NULL, NULL);
		if (crl->idp)
			setup_idp(crl, crl->idp);

		crl->akid = X509_CRL_get_ext_d2i(crl,
		    NID_authority_key_identifier, NULL, NULL);

		crl->crl_number = X509_CRL_get_ext_d2i(crl,
		    NID_crl_number, NULL, NULL);

		crl->base_crl_number = X509_CRL_get_ext_d2i(crl,
		    NID_delta_crl, NULL, NULL);
		/* Delta CRLs must have CRL number */
		if (crl->base_crl_number && !crl->crl_number)
			crl->flags |= EXFLAG_INVALID;

		/* See if we have any unhandled critical CRL extensions and
		 * indicate this in a flag. We only currently handle IDP,
		 * AKID and deltas, so anything else critical sets the flag.
		 *
		 * This code accesses the X509_CRL structure directly:
		 * applications shouldn't do this.
		 */

		exts = crl->crl->extensions;

		for (idx = 0; idx < sk_X509_EXTENSION_num(exts); idx++) {
			int nid;
			ext = sk_X509_EXTENSION_value(exts, idx);
			nid = OBJ_obj2nid(ext->object);
			if (nid == NID_freshest_crl)
				crl->flags |= EXFLAG_FRESHEST;
			if (ext->critical > 0) {
				/* We handle IDP, AKID and deltas */
				if (nid == NID_issuing_distribution_point ||
				    nid == NID_authority_key_identifier ||
				    nid == NID_delta_crl)
					break;
				crl->flags |= EXFLAG_CRITICAL;
				break;
			}
		}

		if (!crl_set_issuers(crl))
			return 0;

		if (crl->meth->crl_init) {
			if (crl->meth->crl_init(crl) == 0)
				return 0;
		}
		break;

	case ASN1_OP_FREE_POST:
		if (crl->meth->crl_free) {
			if (!crl->meth->crl_free(crl))
				rc = 0;
		}
		if (crl->akid)
			AUTHORITY_KEYID_free(crl->akid);
		if (crl->idp)
			ISSUING_DIST_POINT_free(crl->idp);
		ASN1_INTEGER_free(crl->crl_number);
		ASN1_INTEGER_free(crl->base_crl_number);
		sk_GENERAL_NAMES_pop_free(crl->issuers, GENERAL_NAMES_free);
		break;
	}
	return rc;
}

/* Convert IDP into a more convenient form */

static void
setup_idp(X509_CRL *crl, ISSUING_DIST_POINT *idp)
{
	int idp_only = 0;

	/* Set various flags according to IDP */
	crl->idp_flags |= IDP_PRESENT;
	if (idp->onlyuser > 0) {
		idp_only++;
		crl->idp_flags |= IDP_ONLYUSER;
	}
	if (idp->onlyCA > 0) {
		idp_only++;
		crl->idp_flags |= IDP_ONLYCA;
	}
	if (idp->onlyattr > 0) {
		idp_only++;
		crl->idp_flags |= IDP_ONLYATTR;
	}

	if (idp_only > 1)
		crl->idp_flags |= IDP_INVALID;

	if (idp->indirectCRL > 0)
		crl->idp_flags |= IDP_INDIRECT;

	if (idp->onlysomereasons) {
		crl->idp_flags |= IDP_REASONS;
		if (idp->onlysomereasons->length > 0)
			crl->idp_reasons = idp->onlysomereasons->data[0];
		if (idp->onlysomereasons->length > 1)
			crl->idp_reasons |=
			    (idp->onlysomereasons->data[1] << 8);
		crl->idp_reasons &= CRLDP_ALL_REASONS;
	}

	DIST_POINT_set_dpname(idp->distpoint, X509_CRL_get_issuer(crl));
}

static const ASN1_AUX X509_CRL_aux = {
	.app_data = NULL,
	.flags = ASN1_AFLG_REFCOUNT,
	.ref_offset = offsetof(X509_CRL, references),
	.ref_lock = CRYPTO_LOCK_X509_CRL,
	.asn1_cb = crl_cb,
};
static const ASN1_TEMPLATE X509_CRL_seq_tt[] = {
	{
		.offset = offsetof(X509_CRL, crl),
		.field_name = "crl",
		.item = &X509_CRL_INFO_it,
	},
	{
		.offset = offsetof(X509_CRL, sig_alg),
		.field_name = "sig_alg",
		.item = &X509_ALGOR_it,
	},
	{
		.offset = offsetof(X509_CRL, signature),
		.field_name = "signature",
		.item = &ASN1_BIT_STRING_it,
	},
};

const ASN1_ITEM X509_CRL_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = X509_CRL_seq_tt,
	.tcount = sizeof(X509_CRL_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = &X509_CRL_aux,
	.size = sizeof(X509_CRL),
	.sname = "X509_CRL",
};


X509_REVOKED *
d2i_X509_REVOKED(X509_REVOKED **a, const unsigned char **in, long len)
{
	return (X509_REVOKED *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &X509_REVOKED_it);
}

int
i2d_X509_REVOKED(X509_REVOKED *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_REVOKED_it);
}

X509_REVOKED *
X509_REVOKED_new(void)
{
	return (X509_REVOKED *)ASN1_item_new(&X509_REVOKED_it);
}

void
X509_REVOKED_free(X509_REVOKED *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &X509_REVOKED_it);
}

X509_CRL_INFO *
d2i_X509_CRL_INFO(X509_CRL_INFO **a, const unsigned char **in, long len)
{
	return (X509_CRL_INFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &X509_CRL_INFO_it);
}

int
i2d_X509_CRL_INFO(X509_CRL_INFO *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_CRL_INFO_it);
}

X509_CRL_INFO *
X509_CRL_INFO_new(void)
{
	return (X509_CRL_INFO *)ASN1_item_new(&X509_CRL_INFO_it);
}

void
X509_CRL_INFO_free(X509_CRL_INFO *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &X509_CRL_INFO_it);
}

X509_CRL *
d2i_X509_CRL(X509_CRL **a, const unsigned char **in, long len)
{
	return (X509_CRL *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &X509_CRL_it);
}

int
i2d_X509_CRL(X509_CRL *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_CRL_it);
}

X509_CRL *
X509_CRL_new(void)
{
	return (X509_CRL *)ASN1_item_new(&X509_CRL_it);
}

void
X509_CRL_free(X509_CRL *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &X509_CRL_it);
}

X509_CRL *
X509_CRL_dup(X509_CRL *x)
{
	return ASN1_item_dup(&X509_CRL_it, x);
}

static int
X509_REVOKED_cmp(const X509_REVOKED * const *a, const X509_REVOKED * const *b)
{
	return(ASN1_STRING_cmp(
	    (ASN1_STRING *)(*a)->serialNumber,
	    (ASN1_STRING *)(*b)->serialNumber));
}

int
X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev)
{
	X509_CRL_INFO *inf;

	inf = crl->crl;
	if (!inf->revoked)
		inf->revoked = sk_X509_REVOKED_new(X509_REVOKED_cmp);
	if (!inf->revoked || !sk_X509_REVOKED_push(inf->revoked, rev)) {
		ASN1err(ASN1_F_X509_CRL_ADD0_REVOKED, ERR_R_MALLOC_FAILURE);
		return 0;
	}
	inf->enc.modified = 1;
	return 1;
}

int
X509_CRL_verify(X509_CRL *crl, EVP_PKEY *r)
{
	if (crl->meth->crl_verify)
		return crl->meth->crl_verify(crl, r);
	return 0;
}

int
X509_CRL_get0_by_serial(X509_CRL *crl, X509_REVOKED **ret,
    ASN1_INTEGER *serial)
{
	if (crl->meth->crl_lookup)
		return crl->meth->crl_lookup(crl, ret, serial, NULL);
	return 0;
}

int
X509_CRL_get0_by_cert(X509_CRL *crl, X509_REVOKED **ret, X509 *x)
{
	if (crl->meth->crl_lookup)
		return crl->meth->crl_lookup(crl, ret,
		    X509_get_serialNumber(x), X509_get_issuer_name(x));
	return 0;
}

static int
def_crl_verify(X509_CRL *crl, EVP_PKEY *r)
{
	return(ASN1_item_verify(ASN1_ITEM_rptr(X509_CRL_INFO),
	    crl->sig_alg, crl->signature, crl->crl, r));
}

static int
crl_revoked_issuer_match(X509_CRL *crl, X509_NAME *nm, X509_REVOKED *rev)
{
	int i;

	if (!rev->issuer) {
		if (!nm)
			return 1;
		if (!X509_NAME_cmp(nm, X509_CRL_get_issuer(crl)))
			return 1;
		return 0;
	}

	if (!nm)
		nm = X509_CRL_get_issuer(crl);

	for (i = 0; i < sk_GENERAL_NAME_num(rev->issuer); i++) {
		GENERAL_NAME *gen = sk_GENERAL_NAME_value(rev->issuer, i);
		if (gen->type != GEN_DIRNAME)
			continue;
		if (!X509_NAME_cmp(nm, gen->d.directoryName))
			return 1;
	}
	return 0;

}

static int
def_crl_lookup(X509_CRL *crl, X509_REVOKED **ret, ASN1_INTEGER *serial,
    X509_NAME *issuer)
{
	X509_REVOKED rtmp, *rev;
	int idx;

	rtmp.serialNumber = serial;
	/* Sort revoked into serial number order if not already sorted.
	 * Do this under a lock to avoid race condition.
 	 */
	if (!sk_X509_REVOKED_is_sorted(crl->crl->revoked)) {
		CRYPTO_w_lock(CRYPTO_LOCK_X509_CRL);
		sk_X509_REVOKED_sort(crl->crl->revoked);
		CRYPTO_w_unlock(CRYPTO_LOCK_X509_CRL);
	}
	idx = sk_X509_REVOKED_find(crl->crl->revoked, &rtmp);
	if (idx < 0)
		return 0;
	/* Need to look for matching name */
	for (; idx < sk_X509_REVOKED_num(crl->crl->revoked); idx++) {
		rev = sk_X509_REVOKED_value(crl->crl->revoked, idx);
		if (ASN1_INTEGER_cmp(rev->serialNumber, serial))
			return 0;
		if (crl_revoked_issuer_match(crl, issuer, rev)) {
			if (ret)
				*ret = rev;
			if (rev->reason == CRL_REASON_REMOVE_FROM_CRL)
				return 2;
			return 1;
		}
	}
	return 0;
}

void
X509_CRL_set_default_method(const X509_CRL_METHOD *meth)
{
	if (meth == NULL)
		default_crl_method = &int_crl_meth;
	else
		default_crl_method = meth;
}

X509_CRL_METHOD *
X509_CRL_METHOD_new(int (*crl_init)(X509_CRL *crl),
    int (*crl_free)(X509_CRL *crl),
    int (*crl_lookup)(X509_CRL *crl, X509_REVOKED **ret,
    ASN1_INTEGER *ser, X509_NAME *issuer),
    int (*crl_verify)(X509_CRL *crl, EVP_PKEY *pk))
{
	X509_CRL_METHOD *m;

	m = malloc(sizeof(X509_CRL_METHOD));
	if (!m)
		return NULL;
	m->crl_init = crl_init;
	m->crl_free = crl_free;
	m->crl_lookup = crl_lookup;
	m->crl_verify = crl_verify;
	m->flags = X509_CRL_METHOD_DYNAMIC;
	return m;
}

void
X509_CRL_METHOD_free(X509_CRL_METHOD *m)
{
	if (!(m->flags & X509_CRL_METHOD_DYNAMIC))
		return;
	free(m);
}

void
X509_CRL_set_meth_data(X509_CRL *crl, void *dat)
{
	crl->meth_data = dat;
}

void *
X509_CRL_get_meth_data(X509_CRL *crl)
{
	return crl->meth_data;
}
@


1.25
log
@When freeing an X509_CRL, if freeing the user-maintained meth_data fails,
do not forgot to nevertheless keep freeing the other fields.
ok doug@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: x_crl.c,v 1.24 2015/02/11 04:00:39 jsing Exp $ */
@


1.24
log
@Remove initialisers with default values from the ASN1 data structures.

Minor changes in generated assembly due to the compiler swapping from
.quad 0/.long 0 to .zero, along with changes due to line numbering.
@
text
@d1 1
a1 1
/* $OpenBSD: x_crl.c,v 1.23 2015/02/11 03:39:51 jsing Exp $ */
d273 1
d349 1
a349 1
				return 0;
d360 1
a360 1
	return 1;
@


1.23
log
@Expand most of the ASN1_SEQUENCE* and associated macros, making the data
structures visible and easier to review, without having to wade through
layers and layers of asn1t.h macros.

Change has been scripted and the generated assembly only differs by changes
to line numbers.

Discussed with beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: x_crl.c,v 1.22 2015/02/10 08:33:10 jsing Exp $ */
a75 2
		.flags = 0,
		.tag = 0,
a80 2
		.flags = 0,
		.tag = 0,
a86 1
		.tag = 0,
a97 1
	.funcs = NULL,
a136 1
	.app_data = NULL,
a137 2
	.ref_offset = 0,
	.ref_lock = 0,
a143 1
		.tag = 0,
a148 2
		.flags = 0,
		.tag = 0,
a153 2
		.flags = 0,
		.tag = 0,
a158 2
		.flags = 0,
		.tag = 0,
a164 1
		.tag = 0,
a170 1
		.tag = 0,
a176 1
		.tag = 0,
a408 1
	.enc_offset = 0,
a411 2
		.flags = 0,
		.tag = 0,
a416 2
		.flags = 0,
		.tag = 0,
a421 2
		.flags = 0,
		.tag = 0,
@


1.22
log
@The IMPLEMENT_STACK_OF and IMPLEMENT_ASN1_SET_OF macros were turned into
noops around 15 years ago. Remove multiple occurances of both that still
exist in the code today.
@
text
@d1 1
a1 1
/* $OpenBSD: x_crl.c,v 1.21 2015/02/10 05:25:45 jsing Exp $ */
d74 33
a106 5
ASN1_SEQUENCE(X509_REVOKED) = {
	ASN1_SIMPLE(X509_REVOKED, serialNumber, ASN1_INTEGER),
	ASN1_SIMPLE(X509_REVOKED, revocationDate, ASN1_TIME),
	ASN1_SEQUENCE_OF_OPT(X509_REVOKED, extensions, X509_EXTENSION)
} ASN1_SEQUENCE_END(X509_REVOKED)
d142 69
a210 9
ASN1_SEQUENCE_enc(X509_CRL_INFO, enc, crl_inf_cb) = {
	ASN1_OPT(X509_CRL_INFO, version, ASN1_INTEGER),
	ASN1_SIMPLE(X509_CRL_INFO, sig_alg, X509_ALGOR),
	ASN1_SIMPLE(X509_CRL_INFO, issuer, X509_NAME),
	ASN1_SIMPLE(X509_CRL_INFO, lastUpdate, ASN1_TIME),
	ASN1_OPT(X509_CRL_INFO, nextUpdate, ASN1_TIME),
	ASN1_SEQUENCE_OF_OPT(X509_CRL_INFO, revoked, X509_REVOKED),
	ASN1_EXP_SEQUENCE_OF_OPT(X509_CRL_INFO, extensions, X509_EXTENSION, 0)
} ASN1_SEQUENCE_END_enc(X509_CRL_INFO, X509_CRL_INFO)
d422 41
a462 5
ASN1_SEQUENCE_ref(X509_CRL, crl_cb, CRYPTO_LOCK_X509_CRL) = {
	ASN1_SIMPLE(X509_CRL, crl, X509_CRL_INFO),
	ASN1_SIMPLE(X509_CRL, sig_alg, X509_ALGOR),
	ASN1_SIMPLE(X509_CRL, signature, ASN1_BIT_STRING)
} ASN1_SEQUENCE_END_ref(X509_CRL, X509_CRL)
@


1.21
log
@Manually expand ASN1_ITEM_rptr macros that should have been expanded with
the IMPLEMENT_ASN1_DUP_FUNCTION macro.
@
text
@d1 1
a1 1
/* $OpenBSD: x_crl.c,v 1.20 2015/02/10 04:21:50 jsing Exp $ */
a588 5

IMPLEMENT_STACK_OF(X509_REVOKED)
IMPLEMENT_ASN1_SET_OF(X509_REVOKED)
IMPLEMENT_STACK_OF(X509_CRL)
IMPLEMENT_ASN1_SET_OF(X509_CRL)
@


1.20
log
@Expand the IMPLEMENT_ASN1_DUP_FUNCTION macro so that the code is visible
and functions can be readily located.

Change has been scripted and the generated assembly only differs by changes
to line numbers.

Discussed with beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: x_crl.c,v 1.19 2015/02/09 15:05:59 jsing Exp $ */
d419 1
a419 1
	return ASN1_item_dup(ASN1_ITEM_rptr(X509_CRL), x);
@


1.19
log
@Expand the IMPLEMENT_ASN1_FUNCTIONS macro so that the code is visible and
functions can be readily located.

Change has been scripted and the generated assembly only differs by changes
to line numbers.

Discussed with beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: x_crl.c,v 1.18 2014/07/11 13:54:41 miod Exp $ */
d415 6
a420 1
IMPLEMENT_ASN1_DUP_FUNCTION(X509_CRL)
@


1.18
log
@Tolerate critical AKID in CRLs; OpenSSL PR #3014 via OpenSSL trunk, and
also update the comments to reflect what the code now does.
@
text
@d1 1
a1 1
/* $OpenBSD: x_crl.c,v 1.17 2014/07/11 08:44:47 jsing Exp $ */
d340 75
a414 3
IMPLEMENT_ASN1_FUNCTIONS(X509_REVOKED)
IMPLEMENT_ASN1_FUNCTIONS(X509_CRL_INFO)
IMPLEMENT_ASN1_FUNCTIONS(X509_CRL)
@


1.17
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: x_crl.c,v 1.16 2014/07/10 22:45:56 jsing Exp $ */
d241 2
a242 2
		 * indicate this in a flag. We only currently handle IDP so
		 * anything else critical sets the flag.
d257 5
a261 4
				/* We handle IDP and deltas */
				if ((nid == NID_issuing_distribution_point) ||
				    (nid == NID_delta_crl))
					break;;
@


1.16
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: x_crl.c,v 1.15 2014/06/12 15:49:27 deraadt Exp $ */
a62 2
#include "cryptlib.h"
#include "asn1_locl.h"
d64 1
d67 2
@


1.15
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 3
@


1.14
log
@Use C99 initializers for the various FOO_METHOD structs. More readable, and
avoid unreadable/unmaintainable constructs like that:

const EVP_PKEY_ASN1_METHOD cmac_asn1_meth =
        {
        EVP_PKEY_CMAC,
        EVP_PKEY_CMAC,
        0,

        "CMAC",
        "OpenSSL CMAC method",

        0,0,0,0,

        0,0,0,

        cmac_size,
        0,
        0,0,0,0,0,0,0,

        cmac_key_free,
        0,
        0,0
        };

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/* crypto/asn1/x_crl.c */
@


1.13
log
@More KNF.
@
text
@d81 2
a82 5
	0,
	0,
	0,
	def_crl_lookup,
	def_crl_verify
@


1.12
log
@lob a few more knf grenades in here to soften things up.
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d67 1
a67 1
				const X509_REVOKED * const *b);
d71 3
a73 3
	ASN1_SIMPLE(X509_REVOKED,serialNumber, ASN1_INTEGER),
	ASN1_SIMPLE(X509_REVOKED,revocationDate, ASN1_TIME),
	ASN1_SEQUENCE_OF_OPT(X509_REVOKED,extensions, X509_EXTENSION)
d77 2
a78 2
static int def_crl_lookup(X509_CRL *crl,
		X509_REVOKED **ret, ASN1_INTEGER *serial, X509_NAME *issuer);
d80 3
a82 2
static X509_CRL_METHOD int_crl_meth =
{
a83 1
	0,0,
d94 2
a95 2
static int crl_inf_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
								void *exarg)
d99 3
a101 2
	if(!a || !a->revoked) return 1;
	switch(operation) {
d106 1
a106 1
		(void)sk_X509_REVOKED_set_cmp_func(a->revoked,X509_REVOKED_cmp);
d127 2
a128 1
static int crl_set_issuers(X509_CRL *crl)
a129 1

d142 2
a143 3
		gtmp = X509_REVOKED_get_ext_d2i(rev, 
						NID_certificate_issuer,
						&j, NULL);
d162 1
a162 1
								&j, NULL);
d172 1
a172 1
			rev->reason = CRL_REASON_NONE;	
d182 1
a182 1
					NID_certificate_issuer)
a187 2


a190 1

d196 2
a197 2
static int crl_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
								void *exarg)
d204 1
a204 1
	switch(operation) {
d223 1
a223 1
				NID_issuing_distribution_point, NULL, NULL);
d228 1
a228 1
				NID_authority_key_identifier, NULL, NULL);	
d231 1
a231 1
				NID_crl_number, NULL, NULL);	
d234 1
a234 1
				NID_delta_crl, NULL, NULL);	
d239 1
a239 1
		/* See if we have any unhandled critical CRL extensions and 
d257 2
a258 2
				if ((nid == NID_issuing_distribution_point)
					|| (nid == NID_delta_crl))
a264 1

d293 2
a294 1
static void setup_idp(X509_CRL *crl, ISSUING_DIST_POINT *idp)
d297 1
d325 1
a325 1
				(idp->onlysomereasons->data[1] << 8);
d343 2
a344 2
static int X509_REVOKED_cmp(const X509_REVOKED * const *a,
			const X509_REVOKED * const *b)
d347 2
a348 2
		(ASN1_STRING *)(*a)->serialNumber,
		(ASN1_STRING *)(*b)->serialNumber));
d351 2
a352 1
int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev)
d355 1
d357 1
a357 1
	if(!inf->revoked)
d359 1
a359 1
	if(!inf->revoked || !sk_X509_REVOKED_push(inf->revoked, rev)) {
d362 1
a362 1
}
d367 2
a368 1
int X509_CRL_verify(X509_CRL *crl, EVP_PKEY *r)
d375 3
a377 2
int X509_CRL_get0_by_serial(X509_CRL *crl,
		X509_REVOKED **ret, ASN1_INTEGER *serial)
d384 2
a385 1
int X509_CRL_get0_by_cert(X509_CRL *crl, X509_REVOKED **ret, X509 *x)
d389 1
a389 2
						X509_get_serialNumber(x),
						X509_get_issuer_name(x));
d393 2
a394 1
static int def_crl_verify(X509_CRL *crl, EVP_PKEY *r)
d397 1
a397 1
		crl->sig_alg, crl->signature,crl->crl,r));
d400 2
a401 2
static int crl_revoked_issuer_match(X509_CRL *crl, X509_NAME *nm,
						X509_REVOKED *rev)
d427 3
a429 2
static int def_crl_lookup(X509_CRL *crl,
		X509_REVOKED **ret, ASN1_INTEGER *serial, X509_NAME *issuer)
d433 1
d444 1
a444 1
	if(idx < 0)
d447 1
a447 1
	for(;idx < sk_X509_REVOKED_num(crl->crl->revoked); idx++) {
d462 2
a463 1
void X509_CRL_set_default_method(const X509_CRL_METHOD *meth)
d467 1
a467 1
	else 
d471 6
a476 6
X509_CRL_METHOD *X509_CRL_METHOD_new(
	int (*crl_init)(X509_CRL *crl),
	int (*crl_free)(X509_CRL *crl),
	int (*crl_lookup)(X509_CRL *crl, X509_REVOKED **ret,
				ASN1_INTEGER *ser, X509_NAME *issuer),
	int (*crl_verify)(X509_CRL *crl, EVP_PKEY *pk))
d479 1
d491 2
a492 1
void X509_CRL_METHOD_free(X509_CRL_METHOD *m)
d499 2
a500 1
void X509_CRL_set_meth_data(X509_CRL *crl, void *dat)
d505 2
a506 1
void *X509_CRL_get_meth_data(X509_CRL *crl)
@


1.11
log
@putting most of the braces in the right column is the very least we can do.
@
text
@d104 1
a104 1
		case ASN1_OP_D2I_POST:
d107 1
a107 1
}
d136 1
a136 2
	for (i = 0; i < sk_X509_REVOKED_num(revoked); i++)
	{
d144 1
a144 2
		if (!gtmp && (j != -1))
		{
d149 1
a149 2
		if (gtmp)
		{
d151 1
a151 2
			if (!crl->issuers)
			{
d163 1
a163 2
		if (!reason && (j != -1))
		{
d168 1
a168 2
		if (reason)
		{
d171 1
a171 2
		}
		else
d178 1
a178 2
		for (j = 0; j < sk_X509_EXTENSION_num(exts); j++)
		{
d180 1
a180 2
			if (ext->critical > 0)
			{
d207 2
a208 3
	switch(operation)
	{
		case ASN1_OP_NEW_POST:
d221 1
a221 1
		case ASN1_OP_D2I_POST:
d252 1
a252 2
		for (idx = 0; idx < sk_X509_EXTENSION_num(exts); idx++)
		{
d258 1
a258 2
			if (ext->critical > 0)
			{
d272 1
a272 2
		if (crl->meth->crl_init)
		{
d278 2
a279 3
		case ASN1_OP_FREE_POST:
		if (crl->meth->crl_free)
		{
d302 1
a302 2
	if (idp->onlyuser > 0)
	{
d306 1
a306 2
	if (idp->onlyCA > 0)
	{
d310 1
a310 2
	if (idp->onlyattr > 0)
	{
d321 1
a321 2
	if (idp->onlysomereasons)
	{
d402 1
a402 2
	if (!rev->issuer)
	{
d413 1
a413 2
	for (i = 0; i < sk_GENERAL_NAME_num(rev->issuer); i++)
	{
d433 1
a433 2
	if (!sk_X509_REVOKED_is_sorted(crl->crl->revoked))
	{
d442 1
a442 2
	for(;idx < sk_X509_REVOKED_num(crl->crl->revoked); idx++)
	{
d446 1
a446 2
		if (crl_revoked_issuer_match(crl, issuer, rev))
		{
@


1.10
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d81 1
a81 1
	{
d86 1
a86 1
	};
d107 1
a107 1
	}
d127 1
a127 1
	{
d137 1
a137 1
		{
d146 1
a146 1
			{
d149 1
a149 1
			}
d152 1
a152 1
			{
d155 1
a155 1
				{
d159 1
a159 1
				}
d162 1
a162 1
			}
d168 1
a168 1
			{
d171 1
a171 1
			}
d174 1
a174 1
			{
d177 1
a177 1
			}
d186 1
a186 1
			{
d189 1
a189 1
				{
a194 1
				}
d196 1
d199 1
a199 1
		}
d203 1
a203 1
	}
d210 1
a210 1
	{
d217 1
a217 1
		{
d263 1
a263 1
			{
d270 1
a270 1
				{
a276 1
				}
d278 1
d285 1
a285 1
			{
d288 1
a288 1
			}
d293 1
a293 1
			{
d296 1
a296 1
			}
d305 1
a305 1
		}
d307 1
a307 1
	}
d312 1
a312 1
	{
d317 1
a317 1
		{
d320 1
a320 1
		}
d322 1
a322 1
		{
d325 1
a325 1
		}
d327 1
a327 1
		{
d330 1
a330 1
		}
d339 1
a339 1
		{
d347 1
a347 1
		}
d350 1
a350 1
	}
d365 1
a365 1
	{
d369 1
a369 1
	}
d380 1
a380 1
	}
d386 1
a386 1
	{
d390 1
a390 1
	}
d394 1
a394 1
	{
d398 1
a398 1
	}
d401 1
a401 1
	{
d407 1
a407 1
	}
d410 1
a410 1
	{
d413 1
a413 1
	}
d417 1
a417 1
	{
d421 1
a421 1
		{
d427 1
a427 1
		}
d433 1
a433 1
		{
d439 1
a439 1
		}
d442 1
a442 1
	}
d446 1
a446 1
	{
d454 1
a454 1
		{
d458 1
a458 1
		}
d464 1
a464 1
		{
d469 1
a469 1
			{
a474 1
			}
d476 1
d478 1
a478 1
	}
d481 1
a481 1
	{
d486 1
a486 1
	}
d494 1
a494 1
	{
d505 1
a505 1
	}
d508 1
a508 1
	{
d512 1
a512 1
	}
d515 1
a515 1
	{
d517 1
a517 1
	}
d520 1
a520 1
	{
d522 1
a522 1
	}
@


1.9
log
@resolve conflicts, fix local changes
@
text
@d496 1
a496 1
	m = OPENSSL_malloc(sizeof(X509_CRL_METHOD));
d511 1
a511 1
	OPENSSL_free(m);
@


1.8
log
@resolve conflicts
@
text
@d61 1
d64 1
d68 1
d76 14
d94 2
a95 1
static int crl_inf_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)
d122 231
a352 1
ASN1_SEQUENCE_ref(X509_CRL, 0, CRYPTO_LOCK_X509_CRL) = {
d384 139
@


1.7
log
@resolve conflicts
@
text
@d87 1
a87 1
		sk_X509_REVOKED_set_cmp_func(a->revoked,X509_REVOKED_cmp);
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@a65 2
static int X509_REVOKED_seq_cmp(const X509_REVOKED * const *a,
				const X509_REVOKED * const *b);
d73 3
a75 7
/* The X509_CRL_INFO structure needs a bit of customisation. This is actually
 * mirroring the old behaviour: its purpose is to allow the use of
 * sk_X509_REVOKED_find to lookup revoked certificates. Unfortunately
 * this will zap the original order and the signature so we keep a copy
 * of the original positions and reorder appropriately before encoding.
 *
 * Might want to see if there's a better way of doing this later...
a79 3
	int i;
	int (*old_cmp)(const X509_REVOKED * const *,
			const X509_REVOKED * const *);
d83 3
a85 2

		/* Save original order */
a86 2
		for (i=0; i<sk_X509_REVOKED_num(a->revoked); i++)
			sk_X509_REVOKED_value(a->revoked,i)->sequence=i;
a88 7

		/* Restore original order */
		case ASN1_OP_I2D_PRE:
		old_cmp=sk_X509_REVOKED_set_cmp_func(a->revoked,X509_REVOKED_seq_cmp);
		sk_X509_REVOKED_sort(a->revoked);
		sk_X509_REVOKED_set_cmp_func(a->revoked,old_cmp);
		break;
d94 1
a94 1
ASN1_SEQUENCE_cb(X509_CRL_INFO, crl_inf_cb) = {
d102 1
a102 1
} ASN1_SEQUENCE_END_cb(X509_CRL_INFO, X509_CRL_INFO)
a122 6
static int X509_REVOKED_seq_cmp(const X509_REVOKED * const *a,
				const X509_REVOKED * const *b)
	{
	return((*a)->sequence-(*b)->sequence);
	}

d133 1
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@d61 1
a61 1
#include <openssl/asn1_mac.h>
a67 3
int i2d_X509_REVOKED(X509_REVOKED *a, unsigned char **pp)
	{
	M_ASN1_I2D_vars(a);
d69 18
a86 33
	M_ASN1_I2D_len(a->serialNumber,i2d_ASN1_INTEGER);
	M_ASN1_I2D_len(a->revocationDate,i2d_ASN1_TIME);
	M_ASN1_I2D_len_SEQUENCE_opt_ex_type(X509_EXTENSION,a->extensions,
					 i2d_X509_EXTENSION);

	M_ASN1_I2D_seq_total();

	M_ASN1_I2D_put(a->serialNumber,i2d_ASN1_INTEGER);
	M_ASN1_I2D_put(a->revocationDate,i2d_ASN1_TIME);
	M_ASN1_I2D_put_SEQUENCE_opt_ex_type(X509_EXTENSION,a->extensions,
					 i2d_X509_EXTENSION);

	M_ASN1_I2D_finish();
	}

X509_REVOKED *d2i_X509_REVOKED(X509_REVOKED **a, unsigned char **pp,
	     long length)
	{
	M_ASN1_D2I_vars(a,X509_REVOKED *,X509_REVOKED_new);

	M_ASN1_D2I_Init();
	M_ASN1_D2I_start_sequence();
	M_ASN1_D2I_get(ret->serialNumber,d2i_ASN1_INTEGER);
	M_ASN1_D2I_get(ret->revocationDate,d2i_ASN1_TIME);
	M_ASN1_D2I_get_seq_opt_type(X509_EXTENSION,ret->extensions,
				    d2i_X509_EXTENSION,X509_EXTENSION_free);
	M_ASN1_D2I_Finish(a,X509_REVOKED_free,ASN1_F_D2I_X509_REVOKED);
	}

int i2d_X509_CRL_INFO(X509_CRL_INFO *a, unsigned char **pp)
	{
	int v1=0;
	long l=0;
a88 37
	M_ASN1_I2D_vars(a);
	
	old_cmp=sk_X509_REVOKED_set_cmp_func(a->revoked,X509_REVOKED_seq_cmp);
	sk_X509_REVOKED_sort(a->revoked);
	sk_X509_REVOKED_set_cmp_func(a->revoked,old_cmp);

	if ((a->version != NULL) && ((l=ASN1_INTEGER_get(a->version)) != 0))
		{
		M_ASN1_I2D_len(a->version,i2d_ASN1_INTEGER);
		}
	M_ASN1_I2D_len(a->sig_alg,i2d_X509_ALGOR);
	M_ASN1_I2D_len(a->issuer,i2d_X509_NAME);
	M_ASN1_I2D_len(a->lastUpdate,i2d_ASN1_TIME);
	if (a->nextUpdate != NULL)
		{ M_ASN1_I2D_len(a->nextUpdate,i2d_ASN1_TIME); }
	M_ASN1_I2D_len_SEQUENCE_opt_type(X509_REVOKED,a->revoked,
					 i2d_X509_REVOKED);
	M_ASN1_I2D_len_EXP_SEQUENCE_opt_ex_type(X509_EXTENSION,a->extensions,
					     i2d_X509_EXTENSION,0,
					     V_ASN1_SEQUENCE,v1);

	M_ASN1_I2D_seq_total();

	if ((a->version != NULL) && (l != 0))
		{
		M_ASN1_I2D_put(a->version,i2d_ASN1_INTEGER);
		}
	M_ASN1_I2D_put(a->sig_alg,i2d_X509_ALGOR);
	M_ASN1_I2D_put(a->issuer,i2d_X509_NAME);
	M_ASN1_I2D_put(a->lastUpdate,i2d_ASN1_TIME);
	if (a->nextUpdate != NULL)
		{ M_ASN1_I2D_put(a->nextUpdate,i2d_ASN1_TIME); }
	M_ASN1_I2D_put_SEQUENCE_opt_type(X509_REVOKED,a->revoked,
					 i2d_X509_REVOKED);
	M_ASN1_I2D_put_EXP_SEQUENCE_opt_ex_type(X509_EXTENSION,a->extensions,
					     i2d_X509_EXTENSION,0,
					     V_ASN1_SEQUENCE,v1);
d90 2
a91 8
	M_ASN1_I2D_finish();
	}

X509_CRL_INFO *d2i_X509_CRL_INFO(X509_CRL_INFO **a, unsigned char **pp,
	     long length)
	{
	int i,ver=0;
	M_ASN1_D2I_vars(a,X509_CRL_INFO *,X509_CRL_INFO_new);
d93 38
a130 176

	M_ASN1_D2I_Init();
	M_ASN1_D2I_start_sequence();
	M_ASN1_D2I_get_opt(ret->version,d2i_ASN1_INTEGER,V_ASN1_INTEGER);
	if (ret->version != NULL)
		ver=ret->version->data[0];
	
	if ((ver == 0) && (ret->version != NULL))
		{
		M_ASN1_INTEGER_free(ret->version);
		ret->version=NULL;
		}
	M_ASN1_D2I_get(ret->sig_alg,d2i_X509_ALGOR);
	M_ASN1_D2I_get(ret->issuer,d2i_X509_NAME);
	M_ASN1_D2I_get(ret->lastUpdate,d2i_ASN1_TIME);
	/* Manually handle the OPTIONAL ASN1_TIME stuff */
	/* First try UTCTime */
	M_ASN1_D2I_get_opt(ret->nextUpdate,d2i_ASN1_UTCTIME, V_ASN1_UTCTIME);
	/* If that doesn't work try GeneralizedTime */
	if(!ret->nextUpdate) 
		M_ASN1_D2I_get_opt(ret->nextUpdate,d2i_ASN1_GENERALIZEDTIME,
							V_ASN1_GENERALIZEDTIME);
	if (ret->revoked != NULL)
		{
		while (sk_X509_REVOKED_num(ret->revoked))
			X509_REVOKED_free(sk_X509_REVOKED_pop(ret->revoked));
		}
	M_ASN1_D2I_get_seq_opt_type(X509_REVOKED,ret->revoked,d2i_X509_REVOKED,
				    X509_REVOKED_free);

	if (ret->revoked != NULL)
		{
		for (i=0; i<sk_X509_REVOKED_num(ret->revoked); i++)
			{
			sk_X509_REVOKED_value(ret->revoked,i)->sequence=i;
			}
		}

	if (ret->extensions != NULL)
		{
		while (sk_X509_EXTENSION_num(ret->extensions))
			X509_EXTENSION_free(
			sk_X509_EXTENSION_pop(ret->extensions));
		}
		
	M_ASN1_D2I_get_EXP_set_opt_type(X509_EXTENSION,ret->extensions,
					d2i_X509_EXTENSION,
					X509_EXTENSION_free,0,
					V_ASN1_SEQUENCE);

	M_ASN1_D2I_Finish(a,X509_CRL_INFO_free,ASN1_F_D2I_X509_CRL_INFO);
	}

int i2d_X509_CRL(X509_CRL *a, unsigned char **pp)
	{
	M_ASN1_I2D_vars(a);

	M_ASN1_I2D_len(a->crl,i2d_X509_CRL_INFO);
	M_ASN1_I2D_len(a->sig_alg,i2d_X509_ALGOR);
	M_ASN1_I2D_len(a->signature,i2d_ASN1_BIT_STRING);

	M_ASN1_I2D_seq_total();

	M_ASN1_I2D_put(a->crl,i2d_X509_CRL_INFO);
	M_ASN1_I2D_put(a->sig_alg,i2d_X509_ALGOR);
	M_ASN1_I2D_put(a->signature,i2d_ASN1_BIT_STRING);

	M_ASN1_I2D_finish();
	}

X509_CRL *d2i_X509_CRL(X509_CRL **a, unsigned char **pp, long length)
	{
	M_ASN1_D2I_vars(a,X509_CRL *,X509_CRL_new);

	M_ASN1_D2I_Init();
	M_ASN1_D2I_start_sequence();
	M_ASN1_D2I_get(ret->crl,d2i_X509_CRL_INFO);
	M_ASN1_D2I_get(ret->sig_alg,d2i_X509_ALGOR);
	M_ASN1_D2I_get(ret->signature,d2i_ASN1_BIT_STRING);

	M_ASN1_D2I_Finish(a,X509_CRL_free,ASN1_F_D2I_X509_CRL);
	}


X509_REVOKED *X509_REVOKED_new(void)
	{
	X509_REVOKED *ret=NULL;
	ASN1_CTX c;

	M_ASN1_New_Malloc(ret,X509_REVOKED);
	M_ASN1_New(ret->serialNumber,M_ASN1_INTEGER_new);
	M_ASN1_New(ret->revocationDate,M_ASN1_UTCTIME_new);
	ret->extensions=NULL;
	return(ret);
	M_ASN1_New_Error(ASN1_F_X509_REVOKED_NEW);
	}

X509_CRL_INFO *X509_CRL_INFO_new(void)
	{
	X509_CRL_INFO *ret=NULL;
	ASN1_CTX c;

	M_ASN1_New_Malloc(ret,X509_CRL_INFO);
	ret->version=NULL;
	M_ASN1_New(ret->sig_alg,X509_ALGOR_new);
	M_ASN1_New(ret->issuer,X509_NAME_new);
	M_ASN1_New(ret->lastUpdate,M_ASN1_UTCTIME_new);
	ret->nextUpdate=NULL;
	M_ASN1_New(ret->revoked,sk_X509_REVOKED_new_null);
	ret->extensions = NULL;
	sk_X509_REVOKED_set_cmp_func(ret->revoked,X509_REVOKED_cmp);
	return(ret);
	M_ASN1_New_Error(ASN1_F_X509_CRL_INFO_NEW);
	}

X509_CRL *X509_CRL_new(void)
	{
	X509_CRL *ret=NULL;
	ASN1_CTX c;

	M_ASN1_New_Malloc(ret,X509_CRL);
	ret->references=1;
	M_ASN1_New(ret->crl,X509_CRL_INFO_new);
	M_ASN1_New(ret->sig_alg,X509_ALGOR_new);
	M_ASN1_New(ret->signature,M_ASN1_BIT_STRING_new);
	return(ret);
	M_ASN1_New_Error(ASN1_F_X509_CRL_NEW);
	}

void X509_REVOKED_free(X509_REVOKED *a)
	{
	if (a == NULL) return;
	M_ASN1_INTEGER_free(a->serialNumber);
	M_ASN1_UTCTIME_free(a->revocationDate);
	sk_X509_EXTENSION_pop_free(a->extensions,X509_EXTENSION_free);
	OPENSSL_free(a);
	}

void X509_CRL_INFO_free(X509_CRL_INFO *a)
	{
	if (a == NULL) return;
	M_ASN1_INTEGER_free(a->version);
	X509_ALGOR_free(a->sig_alg);
	X509_NAME_free(a->issuer);
	M_ASN1_UTCTIME_free(a->lastUpdate);
	if (a->nextUpdate)
		M_ASN1_UTCTIME_free(a->nextUpdate);
	sk_X509_REVOKED_pop_free(a->revoked,X509_REVOKED_free);
	sk_X509_EXTENSION_pop_free(a->extensions,X509_EXTENSION_free);
	OPENSSL_free(a);
	}

void X509_CRL_free(X509_CRL *a)
	{
	int i;

	if (a == NULL) return;

	i=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_X509_CRL);
#ifdef REF_PRINT
	REF_PRINT("X509_CRL",a);
#endif
	if (i > 0) return;
#ifdef REF_CHECK
	if (i < 0)
		{
		fprintf(stderr,"X509_CRL_free, bad reference count\n");
		abort();
		}
#endif

	X509_CRL_INFO_free(a->crl);
	X509_ALGOR_free(a->sig_alg);
	M_ASN1_BIT_STRING_free(a->signature);
	OPENSSL_free(a);
	}
d145 13
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d74 1
a74 1
	M_ASN1_I2D_len_SEQUENCE_opt_type(X509_EXTENSION,a->extensions,
d81 1
a81 1
	M_ASN1_I2D_put_SEQUENCE_opt_type(X509_EXTENSION,a->extensions,
d124 1
a124 1
	M_ASN1_I2D_len_EXP_SEQUENCE_opt_type(X509_EXTENSION,a->extensions,
d141 1
a141 1
	M_ASN1_I2D_put_EXP_SEQUENCE_opt_type(X509_EXTENSION,a->extensions,
d263 1
a263 1
	M_ASN1_New(ret->extensions,sk_X509_EXTENSION_new_null);
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d64 4
a67 2
static int X509_REVOKED_cmp(X509_REVOKED **a,X509_REVOKED **b);
static int X509_REVOKED_seq_cmp(X509_REVOKED **a,X509_REVOKED **b);
d105 2
a106 1
	int (*old_cmp)(X509_REVOKED **,X509_REVOKED **);
d289 1
a289 1
	Free(a);
d303 1
a303 1
	Free(a);
d328 1
a328 1
	Free(a);
d331 2
a332 1
static int X509_REVOKED_cmp(X509_REVOKED **a, X509_REVOKED **b)
d339 2
a340 1
static int X509_REVOKED_seq_cmp(X509_REVOKED **a, X509_REVOKED **b)
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d133 1
a133 1
	M_ASN1_I2D_put(a->lastUpdate,i2d_ASN1_UTCTIME);
d135 1
a135 1
		{ M_ASN1_I2D_put(a->nextUpdate,i2d_ASN1_UTCTIME); }
d160 1
a160 1
		ASN1_INTEGER_free(ret->version);
d167 3
a169 7
	if(c.slen != 0
	   && ( (M_ASN1_next & ~V_ASN1_CONSTRUCTED) ==
		    (V_ASN1_UNIVERSAL|V_ASN1_UTCTIME)
		|| (M_ASN1_next & ~V_ASN1_CONSTRUCTED) ==
		    (V_ASN1_UNIVERSAL|V_ASN1_GENERALIZEDTIME) ) ) {
		M_ASN1_D2I_get(ret->nextUpdate,d2i_ASN1_TIME);
	}
d189 1
a189 1
	if (ver >= 1)
d191 3
a193 11
		if (ret->extensions != NULL)
			{
			while (sk_X509_EXTENSION_num(ret->extensions))
				X509_EXTENSION_free(
				sk_X509_EXTENSION_pop(ret->extensions));
			}
			
		M_ASN1_D2I_get_EXP_set_opt_type(X509_EXTENSION,ret->extensions,
						d2i_X509_EXTENSION,
						X509_EXTENSION_free,0,
						V_ASN1_SEQUENCE);
d195 5
d241 2
a242 2
	M_ASN1_New(ret->serialNumber,ASN1_INTEGER_new);
	M_ASN1_New(ret->revocationDate,ASN1_UTCTIME_new);
d257 1
a257 1
	M_ASN1_New(ret->lastUpdate,ASN1_UTCTIME_new);
d275 1
a275 1
	M_ASN1_New(ret->signature,ASN1_BIT_STRING_new);
d283 2
a284 2
	ASN1_INTEGER_free(a->serialNumber);
	ASN1_UTCTIME_free(a->revocationDate);
d292 1
a292 1
	ASN1_INTEGER_free(a->version);
d295 1
a295 1
	ASN1_UTCTIME_free(a->lastUpdate);
d297 1
a297 1
		ASN1_UTCTIME_free(a->nextUpdate);
d324 1
a324 1
	ASN1_BIT_STRING_free(a->signature);
@


1.1
log
@Initial revision
@
text
@d61 2
a62 2
#include "asn1_mac.h"
#include "x509.h"
a63 10
/*
 * ASN1err(ASN1_F_D2I_X509_CRL,ASN1_R_LENGTH_MISMATCH);
 * ASN1err(ASN1_F_D2I_X509_CRL_INFO,ASN1_R_EXPECTING_A_SEQUENCE);
 * ASN1err(ASN1_F_D2I_X509_REVOKED,ASN1_R_LENGTH_MISMATCH);
 * ASN1err(ASN1_F_X509_CRL_NEW,ASN1_R_LENGTH_MISMATCH);
 * ASN1err(ASN1_F_X509_CRL_INFO_NEW,ASN1_R_EXPECTING_A_SEQUENCE);
 * ASN1err(ASN1_F_X509_REVOKED_NEW,ASN1_R_LENGTH_MISMATCH);
 */

#ifndef NOPROTO
d66 1
a66 8
#else
static int X509_REVOKED_cmp();
static int X509_REVOKED_seq_cmp();
#endif

int i2d_X509_REVOKED(a,pp)
X509_REVOKED *a;
unsigned char **pp;
d71 3
a73 2
	M_ASN1_I2D_len(a->revocationDate,i2d_ASN1_UTCTIME);
	M_ASN1_I2D_len_SEQ_opt(a->extensions,i2d_X509_EXTENSION);
d78 3
a80 2
	M_ASN1_I2D_put(a->revocationDate,i2d_ASN1_UTCTIME);
	M_ASN1_I2D_put_SEQ_opt(a->extensions,i2d_X509_EXTENSION);
d85 2
a86 4
X509_REVOKED *d2i_X509_REVOKED(a,pp,length)
X509_REVOKED **a;
unsigned char **pp;
long length;
d93 3
a95 2
	M_ASN1_D2I_get(ret->revocationDate,d2i_ASN1_UTCTIME);
	M_ASN1_D2I_get_seq_opt(ret->extensions,d2i_X509_EXTENSION);
d99 1
a99 3
int i2d_X509_CRL_INFO(a,pp)
X509_CRL_INFO *a;
unsigned char **pp;
d103 1
d105 4
a109 3
	if (sk_num(a->revoked) != 0)
		qsort((char *)a->revoked->data,sk_num(a->revoked),
			sizeof(X509_REVOKED *),(int (*)(P_CC_CC))X509_REVOKED_seq_cmp);
d116 1
a116 1
	M_ASN1_I2D_len(a->lastUpdate,i2d_ASN1_UTCTIME);
d118 6
a123 4
		{ M_ASN1_I2D_len(a->nextUpdate,i2d_ASN1_UTCTIME); }
	M_ASN1_I2D_len_SEQ_opt(a->revoked,i2d_X509_REVOKED);
	M_ASN1_I2D_len_EXP_set_opt(a->extensions,i2d_X509_EXTENSION,0,
		V_ASN1_SEQUENCE,v1);
d136 5
a140 3
	M_ASN1_I2D_put_SEQ_opt(a->revoked,i2d_X509_REVOKED);
	M_ASN1_I2D_put_EXP_set_opt(a->extensions,i2d_X509_EXTENSION,0,
		V_ASN1_SEQUENCE,v1);
d145 2
a146 4
X509_CRL_INFO *d2i_X509_CRL_INFO(a,pp,length)
X509_CRL_INFO **a;
unsigned char **pp;
long length;
d165 12
a176 2
	M_ASN1_D2I_get(ret->lastUpdate,d2i_ASN1_UTCTIME);
	M_ASN1_D2I_get_opt(ret->nextUpdate,d2i_ASN1_UTCTIME,V_ASN1_UTCTIME);
d179 2
a180 2
		while (sk_num(ret->revoked))
			X509_REVOKED_free((X509_REVOKED *)sk_pop(ret->revoked));
d182 2
a183 1
	M_ASN1_D2I_get_seq_opt(ret->revoked,d2i_X509_REVOKED);
d187 1
a187 1
		for (i=0; i<sk_num(ret->revoked); i++)
d189 1
a189 1
			((X509_REVOKED *)sk_value(ret->revoked,i))->sequence=i;
d197 3
a199 3
			while (sk_num(ret->extensions))
				X509_EXTENSION_free((X509_EXTENSION *)
				sk_pop(ret->extensions));
d202 4
a205 2
		M_ASN1_D2I_get_EXP_set_opt(ret->extensions,d2i_X509_EXTENSION,
			0,V_ASN1_SEQUENCE);
d211 1
a211 3
int i2d_X509_CRL(a,pp)
X509_CRL *a;
unsigned char **pp;
d228 1
a228 4
X509_CRL *d2i_X509_CRL(a,pp,length)
X509_CRL **a;
unsigned char **pp;
long length;
d242 1
a242 1
X509_REVOKED *X509_REVOKED_new()
d245 1
d255 1
a255 1
X509_CRL_INFO *X509_CRL_INFO_new()
d258 1
d266 3
a268 3
	M_ASN1_New(ret->revoked,sk_new_null);
	M_ASN1_New(ret->extensions,sk_new_null);
	ret->revoked->comp=(int (*)())X509_REVOKED_cmp;
d273 1
a273 1
X509_CRL *X509_CRL_new()
d276 1
d287 1
a287 2
void X509_REVOKED_free(a)
X509_REVOKED *a;
d292 2
a293 2
	sk_pop_free(a->extensions,X509_EXTENSION_free);
	Free((char *)a);
d296 1
a296 2
void X509_CRL_INFO_free(a)
X509_CRL_INFO *a;
d305 3
a307 3
	sk_pop_free(a->revoked,X509_REVOKED_free);
	sk_pop_free(a->extensions,X509_EXTENSION_free);
	Free((char *)a);
d310 1
a310 2
void X509_CRL_free(a)
X509_CRL *a;
d332 1
a332 1
	Free((char *)a);
d335 1
a335 2
static int X509_REVOKED_cmp(a,b)
X509_REVOKED **a,**b;
d342 1
a342 2
static int X509_REVOKED_seq_cmp(a,b)
X509_REVOKED **a,**b;
d346 5
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d61 2
a62 2
#include <openssl/asn1t.h>
#include <openssl/x509.h>
d64 7
a70 18
static int X509_REVOKED_cmp(const X509_REVOKED * const *a,
				const X509_REVOKED * const *b);
static int X509_REVOKED_seq_cmp(const X509_REVOKED * const *a,
				const X509_REVOKED * const *b);

ASN1_SEQUENCE(X509_REVOKED) = {
	ASN1_SIMPLE(X509_REVOKED,serialNumber, ASN1_INTEGER),
	ASN1_SIMPLE(X509_REVOKED,revocationDate, ASN1_TIME),
	ASN1_SEQUENCE_OF_OPT(X509_REVOKED,extensions, X509_EXTENSION)
} ASN1_SEQUENCE_END(X509_REVOKED)

/* The X509_CRL_INFO structure needs a bit of customisation. This is actually
 * mirroring the old behaviour: its purpose is to allow the use of
 * sk_X509_REVOKED_find to lookup revoked certificates. Unfortunately
 * this will zap the original order and the signature so we keep a copy
 * of the original positions and reorder appropriately before encoding.
 *
 * Might want to see if there's a better way of doing this later...
d72 246
a317 3
static int crl_inf_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)
{
	X509_CRL_INFO *a = (X509_CRL_INFO *)*pval;
a318 2
	int (*old_cmp)(const X509_REVOKED * const *,
			const X509_REVOKED * const *);
d320 1
a320 2
	if(!a || !a->revoked) return 1;
	switch(operation) {
d322 18
a339 38
		/* Save original order */
		case ASN1_OP_D2I_POST:
		for (i=0; i<sk_X509_REVOKED_num(a->revoked); i++)
			sk_X509_REVOKED_value(a->revoked,i)->sequence=i;
		sk_X509_REVOKED_set_cmp_func(a->revoked,X509_REVOKED_cmp);
		break;

		/* Restore original order */
		case ASN1_OP_I2D_PRE:
		old_cmp=sk_X509_REVOKED_set_cmp_func(a->revoked,X509_REVOKED_seq_cmp);
		sk_X509_REVOKED_sort(a->revoked);
		sk_X509_REVOKED_set_cmp_func(a->revoked,old_cmp);
		break;
	}
	return 1;
}


ASN1_SEQUENCE_cb(X509_CRL_INFO, crl_inf_cb) = {
	ASN1_OPT(X509_CRL_INFO, version, ASN1_INTEGER),
	ASN1_SIMPLE(X509_CRL_INFO, sig_alg, X509_ALGOR),
	ASN1_SIMPLE(X509_CRL_INFO, issuer, X509_NAME),
	ASN1_SIMPLE(X509_CRL_INFO, lastUpdate, ASN1_TIME),
	ASN1_OPT(X509_CRL_INFO, nextUpdate, ASN1_TIME),
	ASN1_SEQUENCE_OF_OPT(X509_CRL_INFO, revoked, X509_REVOKED),
	ASN1_EXP_SEQUENCE_OF_OPT(X509_CRL_INFO, extensions, X509_EXTENSION, 0)
} ASN1_SEQUENCE_END_cb(X509_CRL_INFO, X509_CRL_INFO)

ASN1_SEQUENCE_ref(X509_CRL, 0, CRYPTO_LOCK_X509_CRL) = {
	ASN1_SIMPLE(X509_CRL, crl, X509_CRL_INFO),
	ASN1_SIMPLE(X509_CRL, sig_alg, X509_ALGOR),
	ASN1_SIMPLE(X509_CRL, signature, ASN1_BIT_STRING)
} ASN1_SEQUENCE_END_ref(X509_CRL, X509_CRL)

IMPLEMENT_ASN1_FUNCTIONS(X509_REVOKED)
IMPLEMENT_ASN1_FUNCTIONS(X509_CRL_INFO)
IMPLEMENT_ASN1_FUNCTIONS(X509_CRL)
IMPLEMENT_ASN1_DUP_FUNCTION(X509_CRL)
d341 2
a342 2
static int X509_REVOKED_cmp(const X509_REVOKED * const *a,
			const X509_REVOKED * const *b)
d349 2
a350 2
static int X509_REVOKED_seq_cmp(const X509_REVOKED * const *a,
				const X509_REVOKED * const *b)
a353 18

int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev)
{
	X509_CRL_INFO *inf;
	inf = crl->crl;
	if(!inf->revoked)
		inf->revoked = sk_X509_REVOKED_new(X509_REVOKED_cmp);
	if(!inf->revoked || !sk_X509_REVOKED_push(inf->revoked, rev)) {
		ASN1err(ASN1_F_X509_CRL_ADD0_REVOKED, ERR_R_MALLOC_FAILURE);
		return 0;
	}
	return 1;
}

IMPLEMENT_STACK_OF(X509_REVOKED)
IMPLEMENT_ASN1_SET_OF(X509_REVOKED)
IMPLEMENT_STACK_OF(X509_CRL)
IMPLEMENT_ASN1_SET_OF(X509_CRL)
@


1.1.1.3
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d66 2
d75 7
a81 3
/* The X509_CRL_INFO structure needs a bit of customisation.
 * Since we cache the original encoding the signature wont be affected by
 * reordering of the revoked field.
d86 3
d92 2
a93 3
		/* Just set cmp function here. We don't sort because that
		 * would affect the output of X509_CRL_print().
		 */
d95 2
d99 7
d111 1
a111 1
ASN1_SEQUENCE_enc(X509_CRL_INFO, enc, crl_inf_cb) = {
d119 1
a119 1
} ASN1_SEQUENCE_END_enc(X509_CRL_INFO, X509_CRL_INFO)
d140 6
a155 1
	inf->enc.modified = 1;
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@d87 1
a87 1
		(void)sk_X509_REVOKED_set_cmp_func(a->revoked,X509_REVOKED_cmp);
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@a60 1
#include "asn1_locl.h"
a62 1
#include <openssl/x509v3.h>
a65 1
static void setup_idp(X509_CRL *crl, ISSUING_DIST_POINT *idp);
a72 14
static int def_crl_verify(X509_CRL *crl, EVP_PKEY *r);
static int def_crl_lookup(X509_CRL *crl,
		X509_REVOKED **ret, ASN1_INTEGER *serial, X509_NAME *issuer);

static X509_CRL_METHOD int_crl_meth =
	{
	0,
	0,0,
	def_crl_lookup,
	def_crl_verify
	};

static const X509_CRL_METHOD *default_crl_method = &int_crl_meth;

d77 1
a77 2
static int crl_inf_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
								void *exarg)
d104 1
a104 231
/* Set CRL entry issuer according to CRL certificate issuer extension.
 * Check for unhandled critical CRL entry extensions.
 */

static int crl_set_issuers(X509_CRL *crl)
	{

	int i, j;
	GENERAL_NAMES *gens, *gtmp;
	STACK_OF(X509_REVOKED) *revoked;

	revoked = X509_CRL_get_REVOKED(crl);

	gens = NULL;
	for (i = 0; i < sk_X509_REVOKED_num(revoked); i++)
		{
		X509_REVOKED *rev = sk_X509_REVOKED_value(revoked, i);
		STACK_OF(X509_EXTENSION) *exts;
		ASN1_ENUMERATED *reason;
		X509_EXTENSION *ext;
		gtmp = X509_REVOKED_get_ext_d2i(rev, 
						NID_certificate_issuer,
						&j, NULL);
		if (!gtmp && (j != -1))
			{
			crl->flags |= EXFLAG_INVALID;
			return 1;
			}

		if (gtmp)
			{
			gens = gtmp;
			if (!crl->issuers)
				{
				crl->issuers = sk_GENERAL_NAMES_new_null();
				if (!crl->issuers)
					return 0;
				}
			if (!sk_GENERAL_NAMES_push(crl->issuers, gtmp))
				return 0;
			}
		rev->issuer = gens;

		reason = X509_REVOKED_get_ext_d2i(rev, NID_crl_reason,
								&j, NULL);
		if (!reason && (j != -1))
			{
			crl->flags |= EXFLAG_INVALID;
			return 1;
			}

		if (reason)
			{
			rev->reason = ASN1_ENUMERATED_get(reason);
			ASN1_ENUMERATED_free(reason);
			}
		else
			rev->reason = CRL_REASON_NONE;	

		/* Check for critical CRL entry extensions */

		exts = rev->extensions;

		for (j = 0; j < sk_X509_EXTENSION_num(exts); j++)
			{
			ext = sk_X509_EXTENSION_value(exts, j);
			if (ext->critical > 0)
				{
				if (OBJ_obj2nid(ext->object) ==
					NID_certificate_issuer)
					continue;
				crl->flags |= EXFLAG_CRITICAL;
				break;
				}
			}


		}

	return 1;

	}

/* The X509_CRL structure needs a bit of customisation. Cache some extensions
 * and hash of the whole CRL.
 */
static int crl_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
								void *exarg)
	{
	X509_CRL *crl = (X509_CRL *)*pval;
	STACK_OF(X509_EXTENSION) *exts;
	X509_EXTENSION *ext;
	int idx;

	switch(operation)
		{
		case ASN1_OP_NEW_POST:
		crl->idp = NULL;
		crl->akid = NULL;
		crl->flags = 0;
		crl->idp_flags = 0;
		crl->idp_reasons = CRLDP_ALL_REASONS;
		crl->meth = default_crl_method;
		crl->meth_data = NULL;
		crl->issuers = NULL;
		crl->crl_number = NULL;
		crl->base_crl_number = NULL;
		break;

		case ASN1_OP_D2I_POST:
#ifndef OPENSSL_NO_SHA
		X509_CRL_digest(crl, EVP_sha1(), crl->sha1_hash, NULL);
#endif
		crl->idp = X509_CRL_get_ext_d2i(crl,
				NID_issuing_distribution_point, NULL, NULL);
		if (crl->idp)
			setup_idp(crl, crl->idp);

		crl->akid = X509_CRL_get_ext_d2i(crl,
				NID_authority_key_identifier, NULL, NULL);	

		crl->crl_number = X509_CRL_get_ext_d2i(crl,
				NID_crl_number, NULL, NULL);	

		crl->base_crl_number = X509_CRL_get_ext_d2i(crl,
				NID_delta_crl, NULL, NULL);	
		/* Delta CRLs must have CRL number */
		if (crl->base_crl_number && !crl->crl_number)
			crl->flags |= EXFLAG_INVALID;

		/* See if we have any unhandled critical CRL extensions and 
		 * indicate this in a flag. We only currently handle IDP so
		 * anything else critical sets the flag.
		 *
		 * This code accesses the X509_CRL structure directly:
		 * applications shouldn't do this.
		 */

		exts = crl->crl->extensions;

		for (idx = 0; idx < sk_X509_EXTENSION_num(exts); idx++)
			{
			int nid;
			ext = sk_X509_EXTENSION_value(exts, idx);
			nid = OBJ_obj2nid(ext->object);
			if (nid == NID_freshest_crl)
				crl->flags |= EXFLAG_FRESHEST;
			if (ext->critical > 0)
				{
				/* We handle IDP and deltas */
				if ((nid == NID_issuing_distribution_point)
					|| (nid == NID_delta_crl))
					break;;
				crl->flags |= EXFLAG_CRITICAL;
				break;
				}
			}


		if (!crl_set_issuers(crl))
			return 0;

		if (crl->meth->crl_init)
			{
			if (crl->meth->crl_init(crl) == 0)
				return 0;
			}
		break;

		case ASN1_OP_FREE_POST:
		if (crl->meth->crl_free)
			{
			if (!crl->meth->crl_free(crl))
				return 0;
			}
		if (crl->akid)
			AUTHORITY_KEYID_free(crl->akid);
		if (crl->idp)
			ISSUING_DIST_POINT_free(crl->idp);
		ASN1_INTEGER_free(crl->crl_number);
		ASN1_INTEGER_free(crl->base_crl_number);
		sk_GENERAL_NAMES_pop_free(crl->issuers, GENERAL_NAMES_free);
		break;
		}
	return 1;
	}

/* Convert IDP into a more convenient form */

static void setup_idp(X509_CRL *crl, ISSUING_DIST_POINT *idp)
	{
	int idp_only = 0;
	/* Set various flags according to IDP */
	crl->idp_flags |= IDP_PRESENT;
	if (idp->onlyuser > 0)
		{
		idp_only++;
		crl->idp_flags |= IDP_ONLYUSER;
		}
	if (idp->onlyCA > 0)
		{
		idp_only++;
		crl->idp_flags |= IDP_ONLYCA;
		}
	if (idp->onlyattr > 0)
		{
		idp_only++;
		crl->idp_flags |= IDP_ONLYATTR;
		}

	if (idp_only > 1)
		crl->idp_flags |= IDP_INVALID;

	if (idp->indirectCRL > 0)
		crl->idp_flags |= IDP_INDIRECT;

	if (idp->onlysomereasons)
		{
		crl->idp_flags |= IDP_REASONS;
		if (idp->onlysomereasons->length > 0)
			crl->idp_reasons = idp->onlysomereasons->data[0];
		if (idp->onlysomereasons->length > 1)
			crl->idp_reasons |=
				(idp->onlysomereasons->data[1] << 8);
		crl->idp_reasons &= CRLDP_ALL_REASONS;
		}

	DIST_POINT_set_dpname(idp->distpoint, X509_CRL_get_issuer(crl));
	}

ASN1_SEQUENCE_ref(X509_CRL, crl_cb, CRYPTO_LOCK_X509_CRL) = {
a135 139

int X509_CRL_verify(X509_CRL *crl, EVP_PKEY *r)
	{
	if (crl->meth->crl_verify)
		return crl->meth->crl_verify(crl, r);
	return 0;
	}

int X509_CRL_get0_by_serial(X509_CRL *crl,
		X509_REVOKED **ret, ASN1_INTEGER *serial)
	{
	if (crl->meth->crl_lookup)
		return crl->meth->crl_lookup(crl, ret, serial, NULL);
	return 0;
	}

int X509_CRL_get0_by_cert(X509_CRL *crl, X509_REVOKED **ret, X509 *x)
	{
	if (crl->meth->crl_lookup)
		return crl->meth->crl_lookup(crl, ret,
						X509_get_serialNumber(x),
						X509_get_issuer_name(x));
	return 0;
	}

static int def_crl_verify(X509_CRL *crl, EVP_PKEY *r)
	{
	return(ASN1_item_verify(ASN1_ITEM_rptr(X509_CRL_INFO),
		crl->sig_alg, crl->signature,crl->crl,r));
	}

static int crl_revoked_issuer_match(X509_CRL *crl, X509_NAME *nm,
						X509_REVOKED *rev)
	{
	int i;

	if (!rev->issuer)
		{
		if (!nm)
			return 1;
		if (!X509_NAME_cmp(nm, X509_CRL_get_issuer(crl)))
			return 1;
		return 0;
		}

	if (!nm)
		nm = X509_CRL_get_issuer(crl);

	for (i = 0; i < sk_GENERAL_NAME_num(rev->issuer); i++)
		{
		GENERAL_NAME *gen = sk_GENERAL_NAME_value(rev->issuer, i);
		if (gen->type != GEN_DIRNAME)
			continue;
		if (!X509_NAME_cmp(nm, gen->d.directoryName))
			return 1;
		}
	return 0;

	}

static int def_crl_lookup(X509_CRL *crl,
		X509_REVOKED **ret, ASN1_INTEGER *serial, X509_NAME *issuer)
	{
	X509_REVOKED rtmp, *rev;
	int idx;
	rtmp.serialNumber = serial;
	/* Sort revoked into serial number order if not already sorted.
	 * Do this under a lock to avoid race condition.
 	 */
	if (!sk_X509_REVOKED_is_sorted(crl->crl->revoked))
		{
		CRYPTO_w_lock(CRYPTO_LOCK_X509_CRL);
		sk_X509_REVOKED_sort(crl->crl->revoked);
		CRYPTO_w_unlock(CRYPTO_LOCK_X509_CRL);
		}
	idx = sk_X509_REVOKED_find(crl->crl->revoked, &rtmp);
	if(idx < 0)
		return 0;
	/* Need to look for matching name */
	for(;idx < sk_X509_REVOKED_num(crl->crl->revoked); idx++)
		{
		rev = sk_X509_REVOKED_value(crl->crl->revoked, idx);
		if (ASN1_INTEGER_cmp(rev->serialNumber, serial))
			return 0;
		if (crl_revoked_issuer_match(crl, issuer, rev))
			{
			if (ret)
				*ret = rev;
			if (rev->reason == CRL_REASON_REMOVE_FROM_CRL)
				return 2;
			return 1;
			}
		}
	return 0;
	}

void X509_CRL_set_default_method(const X509_CRL_METHOD *meth)
	{
	if (meth == NULL)
		default_crl_method = &int_crl_meth;
	else 
		default_crl_method = meth;
	}

X509_CRL_METHOD *X509_CRL_METHOD_new(
	int (*crl_init)(X509_CRL *crl),
	int (*crl_free)(X509_CRL *crl),
	int (*crl_lookup)(X509_CRL *crl, X509_REVOKED **ret,
				ASN1_INTEGER *ser, X509_NAME *issuer),
	int (*crl_verify)(X509_CRL *crl, EVP_PKEY *pk))
	{
	X509_CRL_METHOD *m;
	m = OPENSSL_malloc(sizeof(X509_CRL_METHOD));
	if (!m)
		return NULL;
	m->crl_init = crl_init;
	m->crl_free = crl_free;
	m->crl_lookup = crl_lookup;
	m->crl_verify = crl_verify;
	m->flags = X509_CRL_METHOD_DYNAMIC;
	return m;
	}

void X509_CRL_METHOD_free(X509_CRL_METHOD *m)
	{
	if (!(m->flags & X509_CRL_METHOD_DYNAMIC))
		return;
	OPENSSL_free(m);
	}

void X509_CRL_set_meth_data(X509_CRL *crl, void *dat)
	{
	crl->meth_data = dat;
	}

void *X509_CRL_get_meth_data(X509_CRL *crl)
	{
	return crl->meth_data;
	}
@


