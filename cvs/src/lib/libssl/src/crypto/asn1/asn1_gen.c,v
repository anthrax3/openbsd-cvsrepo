head	1.15;
access;
symbols
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.4
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	butholakala:1.1.1.3
	openssl_1_0_1_g:1.1.1.3
	OPENSSL:1.1.1
	OPENBSD_5_5:1.1.1.3.0.16
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.12
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.10
	OPENBSD_5_3_BASE:1.1.1.3
	openssl_1_0_1_c:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.6
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.8
	openssl_1_0_0_f:1.1.1.3
	openssl_1_0_0_e:1.1.1.3
	OPENBSD_5_0:1.1.1.3.0.4
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.2
	OPENBSD_4_9_BASE:1.1.1.3
	openssh_1_0_0_a:1.1.1.3
	OPENBSD_4_8:1.1.1.2.0.8
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.4
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.6
	OPENBSD_4_6_BASE:1.1.1.2
	openssl_0_9_8_k:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.2
	OPENBSD_4_5_BASE:1.1.1.2
	openssl_0_9_8_j:1.1.1.2
	openssl_0_9_8_h:1.1.1.1
	openssl:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.12.12.21.03.52;	author beck;	state Exp;
branches;
next	1.14;
commitid	a4eU0kx6v3Ly2FeR;

1.14
date	2015.07.18.14.40.59;	author miod;	state Exp;
branches;
next	1.13;
commitid	NrpNH5PdtStO4m1P;

1.13
date	2015.02.12.06.04.24;	author jsg;	state Exp;
branches;
next	1.12;
commitid	OHlRGpzQiaggKrnH;

1.12
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.11;
commitid	yQEL1wOWIearrW15;

1.11
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.10;
commitid	id8dTrTMtnTn4fqt;

1.10
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	mJUVYpkFBZ0Zv2bG;

1.9
date	2014.05.30.06.22.57;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2014.05.22.21.12.15;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.26.18.56.37;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.19.10.54.26;	author jsing;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.18.00.58.49;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2014.04.18.00.10.08;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.16.18.23.52;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.39;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.39;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.01.09.12.13.51;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.10.01.22.54.03;	author djm;	state Exp;
branches;
next	;


desc
@@


1.15
log
@prevent possibly use of uninitialized variable
ok bcook@@
@
text
@/* $OpenBSD: asn1_gen.c,v 1.14 2015/07/18 14:40:59 miod Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2002.
 */
/* ====================================================================
 * Copyright (c) 2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <string.h>

#include <openssl/asn1.h>
#include <openssl/err.h>
#include <openssl/x509v3.h>

#define ASN1_GEN_FLAG		0x10000
#define ASN1_GEN_FLAG_IMP	(ASN1_GEN_FLAG|1)
#define ASN1_GEN_FLAG_EXP	(ASN1_GEN_FLAG|2)
#define ASN1_GEN_FLAG_TAG	(ASN1_GEN_FLAG|3)
#define ASN1_GEN_FLAG_BITWRAP	(ASN1_GEN_FLAG|4)
#define ASN1_GEN_FLAG_OCTWRAP	(ASN1_GEN_FLAG|5)
#define ASN1_GEN_FLAG_SEQWRAP	(ASN1_GEN_FLAG|6)
#define ASN1_GEN_FLAG_SETWRAP	(ASN1_GEN_FLAG|7)
#define ASN1_GEN_FLAG_FORMAT	(ASN1_GEN_FLAG|8)

#define ASN1_GEN_STR(str,val){str, sizeof(str) - 1, val}

#define ASN1_FLAG_EXP_MAX	20

/* Input formats */

/* ASCII: default */
#define ASN1_GEN_FORMAT_ASCII	1
/* UTF8 */
#define ASN1_GEN_FORMAT_UTF8	2
/* Hex */
#define ASN1_GEN_FORMAT_HEX	3
/* List of bits */
#define ASN1_GEN_FORMAT_BITLIST	4

struct tag_name_st {
	const char *strnam;
	int len;
	int tag;
};

typedef struct {
	int exp_tag;
	int exp_class;
	int exp_constructed;
	int exp_pad;
	long exp_len;
} tag_exp_type;

typedef struct {
	int imp_tag;
	int imp_class;
	int utype;
	int format;
	const char *str;
	tag_exp_type exp_list[ASN1_FLAG_EXP_MAX];
	int exp_count;
} tag_exp_arg;

static int bitstr_cb(const char *elem, int len, void *bitstr);
static int asn1_cb(const char *elem, int len, void *bitstr);
static int append_exp(tag_exp_arg *arg, int exp_tag, int exp_class,
    int exp_constructed, int exp_pad, int imp_ok);
static int parse_tagging(const char *vstart, int vlen, int *ptag, int *pclass);
static ASN1_TYPE *asn1_multi(int utype, const char *section, X509V3_CTX *cnf);
static ASN1_TYPE *asn1_str2type(const char *str, int format, int utype);
static int asn1_str2tag(const char *tagstr, int len);

ASN1_TYPE *
ASN1_generate_nconf(char *str, CONF *nconf)
{
	X509V3_CTX cnf;

	if (!nconf)
		return ASN1_generate_v3(str, NULL);

	X509V3_set_nconf(&cnf, nconf);
	return ASN1_generate_v3(str, &cnf);
}

ASN1_TYPE *
ASN1_generate_v3(char *str, X509V3_CTX *cnf)
{
	ASN1_TYPE *ret;
	tag_exp_arg asn1_tags;
	tag_exp_type *etmp;

	int i, len;

	unsigned char *orig_der = NULL, *new_der = NULL;
	const unsigned char *cpy_start;
	unsigned char *p;
	const unsigned char *cp;
	int cpy_len;
	long hdr_len = 0;
	int hdr_constructed = 0, hdr_tag, hdr_class;
	int r;

	asn1_tags.imp_tag = -1;
	asn1_tags.imp_class = -1;
	asn1_tags.format = ASN1_GEN_FORMAT_ASCII;
	asn1_tags.exp_count = 0;
	if (CONF_parse_list(str, ',', 1, asn1_cb, &asn1_tags) != 0)
		return NULL;

	if ((asn1_tags.utype == V_ASN1_SEQUENCE) ||
	    (asn1_tags.utype == V_ASN1_SET)) {
		if (!cnf) {
			ASN1err(ASN1_F_ASN1_GENERATE_V3,
			    ASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG);
			return NULL;
		}
		ret = asn1_multi(asn1_tags.utype, asn1_tags.str, cnf);
	} else
		ret = asn1_str2type(asn1_tags.str, asn1_tags.format,
		    asn1_tags.utype);

	if (!ret)
		return NULL;

	/* If no tagging return base type */
	if ((asn1_tags.imp_tag == -1) && (asn1_tags.exp_count == 0))
		return ret;

	/* Generate the encoding */
	cpy_len = i2d_ASN1_TYPE(ret, &orig_der);
	ASN1_TYPE_free(ret);
	ret = NULL;
	/* Set point to start copying for modified encoding */
	cpy_start = orig_der;

	/* Do we need IMPLICIT tagging? */
	if (asn1_tags.imp_tag != -1) {
		/* If IMPLICIT we will replace the underlying tag */
		/* Skip existing tag+len */
		r = ASN1_get_object(&cpy_start, &hdr_len, &hdr_tag,
		    &hdr_class, cpy_len);
		if (r & 0x80)
			goto err;
		/* Update copy length */
		cpy_len -= cpy_start - orig_der;
		/* For IMPLICIT tagging the length should match the
		 * original length and constructed flag should be
		 * consistent.
		 */
		if (r & 0x1) {
			/* Indefinite length constructed */
			hdr_constructed = 2;
			hdr_len = 0;
		} else
			/* Just retain constructed flag */
			hdr_constructed = r & V_ASN1_CONSTRUCTED;
		/* Work out new length with IMPLICIT tag: ignore constructed
		 * because it will mess up if indefinite length
		 */
		len = ASN1_object_size(0, hdr_len, asn1_tags.imp_tag);
	} else
		len = cpy_len;

	/* Work out length in any EXPLICIT, starting from end */

	for (i = 0, etmp = asn1_tags.exp_list + asn1_tags.exp_count - 1;
	    i < asn1_tags.exp_count; i++, etmp--) {
		/* Content length: number of content octets + any padding */
		len += etmp->exp_pad;
		etmp->exp_len = len;
		/* Total object length: length including new header */
		len = ASN1_object_size(0, len, etmp->exp_tag);
	}

	/* Allocate buffer for new encoding */

	new_der = malloc(len);
	if (!new_der)
		goto err;

	/* Generate tagged encoding */
	p = new_der;

	/* Output explicit tags first */
	for (i = 0, etmp = asn1_tags.exp_list; i < asn1_tags.exp_count;
	    i++, etmp++) {
		ASN1_put_object(&p, etmp->exp_constructed, etmp->exp_len,
		    etmp->exp_tag, etmp->exp_class);
		if (etmp->exp_pad)
			*p++ = 0;
	}

	/* If IMPLICIT, output tag */

	if (asn1_tags.imp_tag != -1) {
		if (asn1_tags.imp_class == V_ASN1_UNIVERSAL &&
		    (asn1_tags.imp_tag == V_ASN1_SEQUENCE ||
		    asn1_tags.imp_tag == V_ASN1_SET))
			hdr_constructed = V_ASN1_CONSTRUCTED;
		ASN1_put_object(&p, hdr_constructed, hdr_len,
		    asn1_tags.imp_tag, asn1_tags.imp_class);
	}

	/* Copy across original encoding */
	memcpy(p, cpy_start, cpy_len);

	cp = new_der;

	/* Obtain new ASN1_TYPE structure */
	ret = d2i_ASN1_TYPE(NULL, &cp, len);

err:
	free(orig_der);
	free(new_der);

	return ret;
}

static int
asn1_cb(const char *elem, int len, void *bitstr)
{
	tag_exp_arg *arg = bitstr;
	int i;
	int utype;
	int vlen = 0;
	const char *p, *vstart = NULL;

	int tmp_tag, tmp_class;

	for (i = 0, p = elem; i < len; p++, i++) {
		/* Look for the ':' in name value pairs */
		if (*p == ':') {
			vstart = p + 1;
			vlen = len - (vstart - elem);
			len = p - elem;
			break;
		}
	}

	utype = asn1_str2tag(elem, len);

	if (utype == -1) {
		ASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKNOWN_TAG);
		ERR_asprintf_error_data("tag=%s", elem);
		return -1;
	}

	/* If this is not a modifier mark end of string and exit */
	if (!(utype & ASN1_GEN_FLAG)) {
		arg->utype = utype;
		arg->str = vstart;
		/* If no value and not end of string, error */
		if (!vstart && elem[len]) {
			ASN1err(ASN1_F_ASN1_CB, ASN1_R_MISSING_VALUE);
			return -1;
		}
		return 0;
	}

	switch (utype) {

	case ASN1_GEN_FLAG_IMP:
		/* Check for illegal multiple IMPLICIT tagging */
		if (arg->imp_tag != -1) {
			ASN1err(ASN1_F_ASN1_CB, ASN1_R_ILLEGAL_NESTED_TAGGING);
			return -1;
		}
		if (!parse_tagging(vstart, vlen, &arg->imp_tag,
		    &arg->imp_class))
			return -1;
		break;

	case ASN1_GEN_FLAG_EXP:
		if (!parse_tagging(vstart, vlen, &tmp_tag, &tmp_class))
			return -1;
		if (!append_exp(arg, tmp_tag, tmp_class, 1, 0, 0))
			return -1;
		break;

	case ASN1_GEN_FLAG_SEQWRAP:
		if (!append_exp(arg, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL, 1, 0, 1))
			return -1;
		break;

	case ASN1_GEN_FLAG_SETWRAP:
		if (!append_exp(arg, V_ASN1_SET, V_ASN1_UNIVERSAL, 1, 0, 1))
			return -1;
		break;

	case ASN1_GEN_FLAG_BITWRAP:
		if (!append_exp(arg, V_ASN1_BIT_STRING, V_ASN1_UNIVERSAL, 0, 1, 1))
			return -1;
		break;

	case ASN1_GEN_FLAG_OCTWRAP:
		if (!append_exp(arg, V_ASN1_OCTET_STRING, V_ASN1_UNIVERSAL, 0, 0, 1))
			return -1;
		break;

	case ASN1_GEN_FLAG_FORMAT:
		if (vstart == NULL) {
			ASN1err(ASN1_F_ASN1_CB, ASN1_R_ILLEGAL_FORMAT);
			return -1;
		}
		if (!strncmp(vstart, "ASCII", 5))
			arg->format = ASN1_GEN_FORMAT_ASCII;
		else if (!strncmp(vstart, "UTF8", 4))
			arg->format = ASN1_GEN_FORMAT_UTF8;
		else if (!strncmp(vstart, "HEX", 3))
			arg->format = ASN1_GEN_FORMAT_HEX;
		else if (!strncmp(vstart, "BITLIST", 7))
			arg->format = ASN1_GEN_FORMAT_BITLIST;
		else {
			ASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKOWN_FORMAT);
			return -1;
		}
		break;

	}

	return 1;
}

static int
parse_tagging(const char *vstart, int vlen, int *ptag, int *pclass)
{
	long tag_num;
	char *eptr;

	if (!vstart)
		return 0;
	tag_num = strtoul(vstart, &eptr, 10);
	/* Check we haven't gone past max length: should be impossible */
	if (eptr && *eptr && (eptr > vstart + vlen))
		return 0;
	if (tag_num < 0) {
		ASN1err(ASN1_F_PARSE_TAGGING, ASN1_R_INVALID_NUMBER);
		return 0;
	}
	*ptag = tag_num;
	/* If we have non numeric characters, parse them */
	if (eptr)
		vlen -= eptr - vstart;
	else
		vlen = 0;
	if (vlen) {
		switch (*eptr) {

		case 'U':
			*pclass = V_ASN1_UNIVERSAL;
			break;

		case 'A':
			*pclass = V_ASN1_APPLICATION;
			break;

		case 'P':
			*pclass = V_ASN1_PRIVATE;
			break;

		case 'C':
			*pclass = V_ASN1_CONTEXT_SPECIFIC;
			break;

		default:
			ASN1err(ASN1_F_PARSE_TAGGING, ASN1_R_INVALID_MODIFIER);
			ERR_asprintf_error_data("Char=%c", *eptr);
			return 0;
			break;

		}
	} else
		*pclass = V_ASN1_CONTEXT_SPECIFIC;

	return 1;

}

/* Handle multiple types: SET and SEQUENCE */

static ASN1_TYPE *
asn1_multi(int utype, const char *section, X509V3_CTX *cnf)
{
	ASN1_TYPE *ret = NULL;
	STACK_OF(ASN1_TYPE) *sk = NULL;
	STACK_OF(CONF_VALUE) *sect = NULL;
	unsigned char *der = NULL;
	int derlen;
	int i;
	sk = sk_ASN1_TYPE_new_null();
	if (!sk)
		goto bad;
	if (section) {
		if (!cnf)
			goto bad;
		sect = X509V3_get_section(cnf, (char *)section);
		if (!sect)
			goto bad;
		for (i = 0; i < sk_CONF_VALUE_num(sect); i++) {
			ASN1_TYPE *typ = ASN1_generate_v3(
			    sk_CONF_VALUE_value(sect, i)->value, cnf);
			if (!typ)
				goto bad;
			if (!sk_ASN1_TYPE_push(sk, typ))
				goto bad;
		}
	}

	/* Now we has a STACK of the components, convert to the correct form */

	if (utype == V_ASN1_SET)
		derlen = i2d_ASN1_SET_ANY(sk, &der);
	else
		derlen = i2d_ASN1_SEQUENCE_ANY(sk, &der);

	if (derlen < 0)
		goto bad;

	if (!(ret = ASN1_TYPE_new()))
		goto bad;

	if (!(ret->value.asn1_string = ASN1_STRING_type_new(utype)))
		goto bad;

	ret->type = utype;

	ret->value.asn1_string->data = der;
	ret->value.asn1_string->length = derlen;

	der = NULL;

bad:
	free(der);
	if (sk)
		sk_ASN1_TYPE_pop_free(sk, ASN1_TYPE_free);
	if (sect)
		X509V3_section_free(cnf, sect);

	return ret;
}

static int
append_exp(tag_exp_arg *arg, int exp_tag, int exp_class, int exp_constructed,
    int exp_pad, int imp_ok)
{
	tag_exp_type *exp_tmp;

	/* Can only have IMPLICIT if permitted */
	if ((arg->imp_tag != -1) && !imp_ok) {
		ASN1err(ASN1_F_APPEND_EXP, ASN1_R_ILLEGAL_IMPLICIT_TAG);
		return 0;
	}

	if (arg->exp_count == ASN1_FLAG_EXP_MAX) {
		ASN1err(ASN1_F_APPEND_EXP, ASN1_R_DEPTH_EXCEEDED);
		return 0;
	}

	exp_tmp = &arg->exp_list[arg->exp_count++];

	/* If IMPLICIT set tag to implicit value then
	 * reset implicit tag since it has been used.
	 */
	if (arg->imp_tag != -1) {
		exp_tmp->exp_tag = arg->imp_tag;
		exp_tmp->exp_class = arg->imp_class;
		arg->imp_tag = -1;
		arg->imp_class = -1;
	} else {
		exp_tmp->exp_tag = exp_tag;
		exp_tmp->exp_class = exp_class;
	}
	exp_tmp->exp_constructed = exp_constructed;
	exp_tmp->exp_pad = exp_pad;

	return 1;
}

static int
asn1_str2tag(const char *tagstr, int len)
{
	unsigned int i;
	static const struct tag_name_st *tntmp, tnst [] = {
		ASN1_GEN_STR("BOOL", V_ASN1_BOOLEAN),
		ASN1_GEN_STR("BOOLEAN", V_ASN1_BOOLEAN),
		ASN1_GEN_STR("NULL", V_ASN1_NULL),
		ASN1_GEN_STR("INT", V_ASN1_INTEGER),
		ASN1_GEN_STR("INTEGER", V_ASN1_INTEGER),
		ASN1_GEN_STR("ENUM", V_ASN1_ENUMERATED),
		ASN1_GEN_STR("ENUMERATED", V_ASN1_ENUMERATED),
		ASN1_GEN_STR("OID", V_ASN1_OBJECT),
		ASN1_GEN_STR("OBJECT", V_ASN1_OBJECT),
		ASN1_GEN_STR("UTCTIME", V_ASN1_UTCTIME),
		ASN1_GEN_STR("UTC", V_ASN1_UTCTIME),
		ASN1_GEN_STR("GENERALIZEDTIME", V_ASN1_GENERALIZEDTIME),
		ASN1_GEN_STR("GENTIME", V_ASN1_GENERALIZEDTIME),
		ASN1_GEN_STR("OCT", V_ASN1_OCTET_STRING),
		ASN1_GEN_STR("OCTETSTRING", V_ASN1_OCTET_STRING),
		ASN1_GEN_STR("BITSTR", V_ASN1_BIT_STRING),
		ASN1_GEN_STR("BITSTRING", V_ASN1_BIT_STRING),
		ASN1_GEN_STR("UNIVERSALSTRING", V_ASN1_UNIVERSALSTRING),
		ASN1_GEN_STR("UNIV", V_ASN1_UNIVERSALSTRING),
		ASN1_GEN_STR("IA5", V_ASN1_IA5STRING),
		ASN1_GEN_STR("IA5STRING", V_ASN1_IA5STRING),
		ASN1_GEN_STR("UTF8", V_ASN1_UTF8STRING),
		ASN1_GEN_STR("UTF8String", V_ASN1_UTF8STRING),
		ASN1_GEN_STR("BMP", V_ASN1_BMPSTRING),
		ASN1_GEN_STR("BMPSTRING", V_ASN1_BMPSTRING),
		ASN1_GEN_STR("VISIBLESTRING", V_ASN1_VISIBLESTRING),
		ASN1_GEN_STR("VISIBLE", V_ASN1_VISIBLESTRING),
		ASN1_GEN_STR("PRINTABLESTRING", V_ASN1_PRINTABLESTRING),
		ASN1_GEN_STR("PRINTABLE", V_ASN1_PRINTABLESTRING),
		ASN1_GEN_STR("T61", V_ASN1_T61STRING),
		ASN1_GEN_STR("T61STRING", V_ASN1_T61STRING),
		ASN1_GEN_STR("TELETEXSTRING", V_ASN1_T61STRING),
		ASN1_GEN_STR("GeneralString", V_ASN1_GENERALSTRING),
		ASN1_GEN_STR("GENSTR", V_ASN1_GENERALSTRING),
		ASN1_GEN_STR("NUMERIC", V_ASN1_NUMERICSTRING),
		ASN1_GEN_STR("NUMERICSTRING", V_ASN1_NUMERICSTRING),

		/* Special cases */
		ASN1_GEN_STR("SEQUENCE", V_ASN1_SEQUENCE),
		ASN1_GEN_STR("SEQ", V_ASN1_SEQUENCE),
		ASN1_GEN_STR("SET", V_ASN1_SET),
		/* type modifiers */
		/* Explicit tag */
		ASN1_GEN_STR("EXP", ASN1_GEN_FLAG_EXP),
		ASN1_GEN_STR("EXPLICIT", ASN1_GEN_FLAG_EXP),
		/* Implicit tag */
		ASN1_GEN_STR("IMP", ASN1_GEN_FLAG_IMP),
		ASN1_GEN_STR("IMPLICIT", ASN1_GEN_FLAG_IMP),
		/* OCTET STRING wrapper */
		ASN1_GEN_STR("OCTWRAP", ASN1_GEN_FLAG_OCTWRAP),
		/* SEQUENCE wrapper */
		ASN1_GEN_STR("SEQWRAP", ASN1_GEN_FLAG_SEQWRAP),
		/* SET wrapper */
		ASN1_GEN_STR("SETWRAP", ASN1_GEN_FLAG_SETWRAP),
		/* BIT STRING wrapper */
		ASN1_GEN_STR("BITWRAP", ASN1_GEN_FLAG_BITWRAP),
		ASN1_GEN_STR("FORM", ASN1_GEN_FLAG_FORMAT),
		ASN1_GEN_STR("FORMAT", ASN1_GEN_FLAG_FORMAT),
	};

	if (len == -1)
		len = strlen(tagstr);

	tntmp = tnst;
	for (i = 0; i < sizeof(tnst) / sizeof(struct tag_name_st);
	    i++, tntmp++) {
		if ((len == tntmp->len) && !strncmp(tntmp->strnam, tagstr, len))
			return tntmp->tag;
	}

	return -1;
}

static ASN1_TYPE *
asn1_str2type(const char *str, int format, int utype)
{
	ASN1_TYPE *atmp = NULL;
	CONF_VALUE vtmp;
	unsigned char *rdata;
	long rdlen;
	int no_unused = 1;

	if (!(atmp = ASN1_TYPE_new())) {
		ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);
		return NULL;
	}

	if (!str)
		str = "";

	switch (utype) {

	case V_ASN1_NULL:
		if (str && *str) {
			ASN1err(ASN1_F_ASN1_STR2TYPE,
			    ASN1_R_ILLEGAL_NULL_VALUE);
			goto bad_form;
		}
		break;

	case V_ASN1_BOOLEAN:
		if (format != ASN1_GEN_FORMAT_ASCII) {
			ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_NOT_ASCII_FORMAT);
			goto bad_form;
		}
		vtmp.name = NULL;
		vtmp.section = NULL;
		vtmp.value = (char *)str;
		if (!X509V3_get_value_bool(&vtmp, &atmp->value.boolean)) {
			ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_BOOLEAN);
			goto bad_str;
		}
		break;

	case V_ASN1_INTEGER:
	case V_ASN1_ENUMERATED:
		if (format != ASN1_GEN_FORMAT_ASCII) {
			ASN1err(ASN1_F_ASN1_STR2TYPE,
			    ASN1_R_INTEGER_NOT_ASCII_FORMAT);
			goto bad_form;
		}
		if (!(atmp->value.integer =
		    s2i_ASN1_INTEGER(NULL, (char *)str))) {
			ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_INTEGER);
			goto bad_str;
		}
		break;

	case V_ASN1_OBJECT:
		if (format != ASN1_GEN_FORMAT_ASCII) {
			ASN1err(ASN1_F_ASN1_STR2TYPE,
			    ASN1_R_OBJECT_NOT_ASCII_FORMAT);
			goto bad_form;
		}
		if (!(atmp->value.object = OBJ_txt2obj(str, 0))) {
			ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_OBJECT);
			goto bad_str;
		}
		break;

	case V_ASN1_UTCTIME:
	case V_ASN1_GENERALIZEDTIME:
		if (format != ASN1_GEN_FORMAT_ASCII) {
			ASN1err(ASN1_F_ASN1_STR2TYPE,
			    ASN1_R_TIME_NOT_ASCII_FORMAT);
			goto bad_form;
		}
		if (!(atmp->value.asn1_string = ASN1_STRING_new())) {
			ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);
			goto bad_str;
		}
		if (!ASN1_STRING_set(atmp->value.asn1_string, str, -1)) {
			ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);
			goto bad_str;
		}
		atmp->value.asn1_string->type = utype;
		if (!ASN1_TIME_check(atmp->value.asn1_string)) {
			ASN1err(ASN1_F_ASN1_STR2TYPE,
			    ASN1_R_ILLEGAL_TIME_VALUE);
			goto bad_str;
		}
		break;

	case V_ASN1_BMPSTRING:
	case V_ASN1_PRINTABLESTRING:
	case V_ASN1_IA5STRING:
	case V_ASN1_T61STRING:
	case V_ASN1_UTF8STRING:
	case V_ASN1_VISIBLESTRING:
	case V_ASN1_UNIVERSALSTRING:
	case V_ASN1_GENERALSTRING:
	case V_ASN1_NUMERICSTRING:

		if (format == ASN1_GEN_FORMAT_ASCII)
			format = MBSTRING_ASC;
		else if (format == ASN1_GEN_FORMAT_UTF8)
			format = MBSTRING_UTF8;
		else {
			ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_FORMAT);
			goto bad_form;
		}

		if (ASN1_mbstring_copy(&atmp->value.asn1_string,
		    (unsigned char *)str, -1, format,
		    ASN1_tag2bit(utype)) <= 0) {
			ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);
			goto bad_str;
		}
		break;

	case V_ASN1_BIT_STRING:
	case V_ASN1_OCTET_STRING:
		if (!(atmp->value.asn1_string = ASN1_STRING_new())) {
			ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);
			goto bad_form;
		}

		if (format == ASN1_GEN_FORMAT_HEX) {

			if (!(rdata = string_to_hex((char *)str, &rdlen))) {
				ASN1err(ASN1_F_ASN1_STR2TYPE,
				    ASN1_R_ILLEGAL_HEX);
				goto bad_str;
			}

			atmp->value.asn1_string->data = rdata;
			atmp->value.asn1_string->length = rdlen;
			atmp->value.asn1_string->type = utype;

		} else if (format == ASN1_GEN_FORMAT_ASCII) {
			if (ASN1_STRING_set(atmp->value.asn1_string, str,
			    -1) == 0) {
				ASN1err(ASN1_F_ASN1_STR2TYPE,
				    ERR_R_MALLOC_FAILURE);
				goto bad_str;
			}
		} else if ((format == ASN1_GEN_FORMAT_BITLIST) &&
		    (utype == V_ASN1_BIT_STRING)) {
			if (!CONF_parse_list(str, ',', 1, bitstr_cb,
			    atmp->value.bit_string)) {
				ASN1err(ASN1_F_ASN1_STR2TYPE,
				    ASN1_R_LIST_ERROR);
				goto bad_str;
			}
			no_unused = 0;

		} else {
			ASN1err(ASN1_F_ASN1_STR2TYPE,
			    ASN1_R_ILLEGAL_BITSTRING_FORMAT);
			goto bad_form;
		}

		if ((utype == V_ASN1_BIT_STRING) && no_unused) {
			atmp->value.asn1_string->flags &=
			    ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
			atmp->value.asn1_string->flags |=
			    ASN1_STRING_FLAG_BITS_LEFT;
		}

		break;

	default:
		ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_UNSUPPORTED_TYPE);
		goto bad_str;
		break;
	}

	atmp->type = utype;
	return atmp;

bad_str:
	ERR_asprintf_error_data("string=%s", str);
bad_form:
	ASN1_TYPE_free(atmp);
	return NULL;
}

static int
bitstr_cb(const char *elem, int len, void *bitstr)
{
	long bitnum;
	char *eptr;

	if (!elem)
		return 0;
	bitnum = strtoul(elem, &eptr, 10);
	if (eptr && *eptr && (eptr != elem + len))
		return 0;
	if (bitnum < 0) {
		ASN1err(ASN1_F_BITSTR_CB, ASN1_R_INVALID_NUMBER);
		return 0;
	}
	if (!ASN1_BIT_STRING_set_bit(bitstr, bitnum, 1)) {
		ASN1err(ASN1_F_BITSTR_CB, ERR_R_MALLOC_FAILURE);
		return 0;
	}
	return 1;
}
@


1.14
log
@Check the return value of ASN1_STRING_set(), for it may fail to allocate
memory. Coverity CID 24810, 24846.
ok bcook@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: asn1_gen.c,v 1.13 2015/02/12 06:04:24 jsg Exp $ */
d149 1
a149 1
	long hdr_len;
@


1.13
log
@prevent a crash with openssl asn1parse -genstr FORMAT
aka ASN1_generate_nconf("FORMAT", NULL)

ok krw@@ beck@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: asn1_gen.c,v 1.12 2014/07/11 08:44:47 jsing Exp $ */
d743 8
a750 3
		} else if (format == ASN1_GEN_FORMAT_ASCII)
			ASN1_STRING_set(atmp->value.asn1_string, str, -1);
		else if ((format == ASN1_GEN_FORMAT_BITLIST) &&
@


1.12
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: asn1_gen.c,v 1.11 2014/07/10 13:58:22 jsing Exp $ */
d351 4
@


1.11
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: asn1_gen.c,v 1.10 2014/06/12 15:49:27 deraadt Exp $ */
a60 1
#include "cryptlib.h"
d62 1
@


1.10
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d58 2
@


1.9
log
@more: no need for null check before free
ok tedu guenther
@
text
@d1 1
a1 1
/* asn1_gen.c */
@


1.8
log
@if (x) free(x) -> free(x); semantic patch generated with coccinelle, carefully
eyeballed before applying. Contributed by Cyril Roelandt on tech@@
@
text
@d477 1
a477 2
	if (der)
		free(der);
@


1.7
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d261 2
a262 4
	if (orig_der)
		free(orig_der);
	if (new_der)
		free(new_der);
@


1.6
log
@More KNF.
@
text
@d294 1
a294 1
		ERR_add_error_data(2, "tag=", elem);
a372 1
	char erch[2];
a411 2
			erch[0] = *eptr;
			erch[1] = 0;
d413 1
a413 1
			ERR_add_error_data(2, "Char=", erch);
d777 1
a777 1
	ERR_add_error_data(2, "string=", str);
@


1.5
log
@lob a few more knf grenades in here to soften things up.
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d88 1
a88 3

struct tag_name_st
{
d94 1
a94 2
typedef struct
{
d102 1
a102 2
typedef struct
{
d114 2
a115 1
static int append_exp(tag_exp_arg *arg, int exp_tag, int exp_class, int exp_constructed, int exp_pad, int imp_ok);
d121 2
a122 1
ASN1_TYPE *ASN1_generate_nconf(char *str, CONF *nconf)
d133 2
a134 1
ASN1_TYPE *ASN1_generate_v3(char *str, X509V3_CTX *cnf)
d158 2
a159 1
	if ((asn1_tags.utype == V_ASN1_SEQUENCE) || (asn1_tags.utype == V_ASN1_SET)) {
d161 2
a162 1
			ASN1err(ASN1_F_ASN1_GENERATE_V3, ASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG);
d166 3
a168 3
	}
	else
		ret = asn1_str2type(asn1_tags.str, asn1_tags.format, asn1_tags.utype);
d188 2
a189 1
		r = ASN1_get_object(&cpy_start, &hdr_len, &hdr_tag, &hdr_class, cpy_len);
d202 1
a202 2
		}
		else
d209 1
a209 2
	}
	else
d214 2
a215 1
	for(i = 0, etmp = asn1_tags.exp_list + asn1_tags.exp_count - 1; i < asn1_tags.exp_count; i++, etmp--) {
a229 1

d233 2
a234 2

	for (i = 0, etmp = asn1_tags.exp_list; i < asn1_tags.exp_count; i++, etmp++) {
d236 1
a236 1
					etmp->exp_tag, etmp->exp_class);
d244 3
a246 3
		if (asn1_tags.imp_class == V_ASN1_UNIVERSAL 
		    && (asn1_tags.imp_tag == V_ASN1_SEQUENCE
		     || asn1_tags.imp_tag == V_ASN1_SET) )
d249 1
a249 1
					asn1_tags.imp_tag, asn1_tags.imp_class);
d260 1
a260 1
	err:
a266 1

d269 2
a270 1
static int asn1_cb(const char *elem, int len, void *bitstr)
d280 1
a280 1
	for(i = 0, p = elem; i < len; p++, i++) {
d310 1
a310 1
	switch(utype) {
d318 2
a319 1
		if (!parse_tagging(vstart, vlen, &arg->imp_tag, &arg->imp_class))
a323 1

a367 1

d370 2
a371 1
static int parse_tagging(const char *vstart, int vlen, int *ptag, int *pclass)
d376 1
d391 1
a391 1
	else 
d412 1
a412 1
			default:
d421 1
a421 2
	}
	else
d430 2
a431 1
static ASN1_TYPE *asn1_multi(int utype, const char *section, X509V3_CTX *cnf)
d449 2
a450 1
			ASN1_TYPE *typ = ASN1_generate_v3(sk_CONF_VALUE_value(sect, i)->value, cnf);
d481 1
a481 2
	bad:

a483 1

d492 3
a494 1
static int append_exp(tag_exp_arg *arg, int exp_tag, int exp_class, int exp_constructed, int exp_pad, int imp_ok)
d497 1
d529 2
a530 2

static int asn1_str2tag(const char *tagstr, int len)
d592 1
a592 1
};
d596 4
a599 3
	
	tntmp = tnst;	
	for (i = 0; i < sizeof(tnst) / sizeof(struct tag_name_st); i++, tntmp++) {
d603 1
a603 1
	
d607 2
a608 1
static ASN1_TYPE *asn1_str2type(const char *str, int format, int utype)
a610 1

a611 1

a613 1

d624 1
a624 1
	switch(utype) {
d628 2
a629 1
			ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_NULL_VALUE);
d633 1
a633 1
		
d651 2
a652 1
			ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_INTEGER_NOT_ASCII_FORMAT);
d655 2
a656 1
		if (!(atmp->value.integer = s2i_ASN1_INTEGER(NULL, (char *)str))) {
d664 2
a665 1
			ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_OBJECT_NOT_ASCII_FORMAT);
d677 2
a678 1
			ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_TIME_NOT_ASCII_FORMAT);
d691 2
a692 1
			ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_TIME_VALUE);
a694 1

d716 3
a718 3

		if (ASN1_mbstring_copy(&atmp->value.asn1_string, (unsigned char *)str,
						-1, format, ASN1_tag2bit(utype)) <= 0) {
a721 2
		

a724 1

a725 1

d734 2
a735 1
				ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_HEX);
d743 1
a743 2
		}
		else if (format == ASN1_GEN_FORMAT_ASCII)
d745 6
a750 3
		else if ((format == ASN1_GEN_FORMAT_BITLIST) && (utype == V_ASN1_BIT_STRING)) {
			if (!CONF_parse_list(str, ',', 1, bitstr_cb, atmp->value.bit_string)) {
				ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_LIST_ERROR);
d754 1
a754 1
			
d756 2
a757 1
			ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_BITSTRING_FORMAT);
d762 4
a765 4
			atmp->value.asn1_string->flags
				&= ~(ASN1_STRING_FLAG_BITS_LEFT|0x07);
        		atmp->value.asn1_string->flags
				|= ASN1_STRING_FLAG_BITS_LEFT;
a767 1

a775 1

a778 1

a781 1

a783 1

d786 2
a787 1
static int bitstr_cb(const char *elem, int len, void *bitstr)
d791 1
a806 1

@


1.4
log
@putting most of the braces in the right column is the very least we can do.
@
text
@d159 2
a160 4
	if ((asn1_tags.utype == V_ASN1_SEQUENCE) || (asn1_tags.utype == V_ASN1_SET))
	{
		if (!cnf)
		{
d184 1
a184 2
	if (asn1_tags.imp_tag != -1)
	{
d196 1
a196 2
		if (r & 0x1)
		{
d214 1
a214 2
	for(i = 0, etmp = asn1_tags.exp_list + asn1_tags.exp_count - 1; i < asn1_tags.exp_count; i++, etmp--)
	{
d234 1
a234 2
	for (i = 0, etmp = asn1_tags.exp_list; i < asn1_tags.exp_count; i++, etmp++)
	{
d243 1
a243 2
	if (asn1_tags.imp_tag != -1)
	{
d280 1
a280 2
	for(i = 0, p = elem; i < len; p++, i++)
	{
d282 1
a282 2
		if (*p == ':')
		{
d292 1
a292 2
	if (utype == -1)
	{
d299 1
a299 2
	if (!(utype & ASN1_GEN_FLAG))
	{
d303 1
a303 2
		if (!vstart && elem[len])
		{
d310 1
a310 2
	switch(utype)
	{
d312 1
a312 1
		case ASN1_GEN_FLAG_IMP:
d314 1
a314 2
		if (arg->imp_tag != -1)
		{
d322 1
a322 1
		case ASN1_GEN_FLAG_EXP:
d330 1
a330 1
		case ASN1_GEN_FLAG_SEQWRAP:
d335 1
a335 1
		case ASN1_GEN_FLAG_SETWRAP:
d340 1
a340 1
		case ASN1_GEN_FLAG_BITWRAP:
d345 1
a345 1
		case ASN1_GEN_FLAG_OCTWRAP:
d350 1
a350 1
		case ASN1_GEN_FLAG_FORMAT:
d359 1
a359 2
		else
		{
d382 1
a382 2
	if (tag_num < 0)
	{
d392 2
a393 4
	if (vlen)
	{
		switch (*eptr)
		{
d395 1
a395 1
			case 'U':
d399 1
a399 1
			case 'A':
d403 1
a403 1
			case 'P':
d407 1
a407 1
			case 'C':
d441 1
a441 2
	if (section)
	{
d447 1
a447 2
		for (i = 0; i < sk_CONF_VALUE_num(sect); i++)
		{
d496 1
a496 2
	if ((arg->imp_tag != -1) && !imp_ok)
	{
d501 1
a501 2
	if (arg->exp_count == ASN1_FLAG_EXP_MAX)
	{
d511 1
a511 2
	if (arg->imp_tag != -1)
	{
d516 1
a516 3
	}
	else
	{
d595 1
a595 2
	for (i = 0; i < sizeof(tnst) / sizeof(struct tag_name_st); i++, tntmp++)
	{
d614 1
a614 2
	if (!(atmp = ASN1_TYPE_new()))
	{
d622 1
a622 2
	switch(utype)
	{
d624 2
a625 3
		case V_ASN1_NULL:
		if (str && *str)
		{
d631 2
a632 3
		case V_ASN1_BOOLEAN:
		if (format != ASN1_GEN_FORMAT_ASCII)
		{
d639 1
a639 2
		if (!X509V3_get_value_bool(&vtmp, &atmp->value.boolean))
		{
d645 3
a647 4
		case V_ASN1_INTEGER:
		case V_ASN1_ENUMERATED:
		if (format != ASN1_GEN_FORMAT_ASCII)
		{
d651 1
a651 2
		if (!(atmp->value.integer = s2i_ASN1_INTEGER(NULL, (char *)str)))
		{
d657 2
a658 3
		case V_ASN1_OBJECT:
		if (format != ASN1_GEN_FORMAT_ASCII)
		{
d662 1
a662 2
		if (!(atmp->value.object = OBJ_txt2obj(str, 0)))
		{
d668 3
a670 4
		case V_ASN1_UTCTIME:
		case V_ASN1_GENERALIZEDTIME:
		if (format != ASN1_GEN_FORMAT_ASCII)
		{
d674 1
a674 2
		if (!(atmp->value.asn1_string = ASN1_STRING_new()))
		{
d678 1
a678 2
		if (!ASN1_STRING_set(atmp->value.asn1_string, str, -1))
		{
d683 1
a683 2
		if (!ASN1_TIME_check(atmp->value.asn1_string))
		{
d690 9
a698 9
		case V_ASN1_BMPSTRING:
		case V_ASN1_PRINTABLESTRING:
		case V_ASN1_IA5STRING:
		case V_ASN1_T61STRING:
		case V_ASN1_UTF8STRING:
		case V_ASN1_VISIBLESTRING:
		case V_ASN1_UNIVERSALSTRING:
		case V_ASN1_GENERALSTRING:
		case V_ASN1_NUMERICSTRING:
d704 1
a704 2
		else
		{
d711 1
a711 2
						-1, format, ASN1_tag2bit(utype)) <= 0)
		{
d719 1
a719 1
		case V_ASN1_BIT_STRING:
d721 1
a721 1
		case V_ASN1_OCTET_STRING:
d723 1
a723 2
		if (!(atmp->value.asn1_string = ASN1_STRING_new()))
		{
d728 1
a728 2
		if (format == ASN1_GEN_FORMAT_HEX)
		{
d730 1
a730 2
			if (!(rdata = string_to_hex((char *)str, &rdlen)))
			{
d742 2
a743 4
		else if ((format == ASN1_GEN_FORMAT_BITLIST) && (utype == V_ASN1_BIT_STRING))
		{
			if (!CONF_parse_list(str, ',', 1, bitstr_cb, atmp->value.bit_string))
			{
d749 1
a749 3
		}
		else 
		{
d754 1
a754 2
		if ((utype == V_ASN1_BIT_STRING) && no_unused)
		{
d764 1
a764 1
		default:
d775 1
a775 1
	bad_str:
d777 1
a777 1
	bad_form:
d793 1
a793 2
	if (bitnum < 0)
	{
d797 1
a797 2
	if (!ASN1_BIT_STRING_set_bit(bitstr, bitnum, 1))
	{
@


1.3
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d73 1
a73 1
#define ASN1_GEN_STR(str,val)	{str, sizeof(str) - 1, val}
d90 1
a90 1
	{
d94 1
a94 1
	};
d97 1
a97 1
	{
d103 1
a103 1
	} tag_exp_type;
d106 1
a106 1
	{
d114 1
a114 1
	} tag_exp_arg;
d125 1
a125 1
	{
d133 1
a133 1
	}
d136 1
a136 1
	{
d160 2
a162 2
		if (!cnf)
			{
d165 1
a165 1
			}
d167 1
a167 1
		}
d187 1
a187 1
		{
d200 1
a200 1
			{
d204 1
a204 1
			}
d212 1
a212 1
		}
d219 1
a219 1
		{
d225 1
a225 1
		}
d240 1
a240 1
		{
d245 1
a245 1
		}
d250 1
a250 1
		{
d257 1
a257 1
		}
d275 1
a275 1
	}
d278 1
a278 1
	{
d288 1
a288 1
		{
d291 1
a291 1
			{
a295 1
			}
d297 1
d302 1
a302 1
		{
d306 1
a306 1
		}
d310 1
a310 1
		{
d315 1
a315 1
			{
d318 1
a318 1
			}
d320 1
a320 1
		}
d323 1
a323 1
		{
d328 1
a328 1
			{
d331 1
a331 1
			}
d374 1
a374 1
			{
d377 1
a377 1
			}
d380 1
a380 1
		}
d384 1
a384 1
	}
d387 1
a387 1
	{
d398 1
a398 1
		{
d401 1
a401 1
		}
d409 2
a411 2
		switch (*eptr)
			{
a436 1
			}
d438 1
d444 1
a444 1
	}
d449 1
a449 1
	{
d460 1
a460 1
		{
d467 1
a467 1
			{
a472 1
			}
d474 1
d510 1
a510 1
	}
d513 1
a513 1
	{
d517 1
a517 1
		{
d520 1
a520 1
		}
d523 1
a523 1
		{
d526 1
a526 1
		}
d534 1
a534 1
		{
d539 1
a539 1
		}
d541 1
a541 1
		{
d544 1
a544 1
		}
d549 1
a549 1
	}
d553 1
a553 1
	{
d614 1
a614 1
	};
d621 1
a621 1
		{
d624 1
a624 1
		}
d627 1
a627 1
	}
d630 1
a630 1
	{
d641 1
a641 1
		{
d644 1
a644 1
		}
d650 1
a650 1
		{
d654 1
a654 1
			{
d657 1
a657 1
			}
d662 1
a662 1
			{
d665 1
a665 1
			}
d670 1
a670 1
			{
d673 1
a673 1
			}
d679 1
a679 1
			{
d682 1
a682 1
			}
d684 1
a684 1
			{
d687 1
a687 1
			}
d692 1
a692 1
			{
d695 1
a695 1
			}
d697 1
a697 1
			{
d700 1
a700 1
			}
d706 1
a706 1
			{
d709 1
a709 1
			}
d711 1
a711 1
			{
d714 1
a714 1
			}
d716 1
a716 1
			{
d719 1
a719 1
			}
d722 1
a722 1
			{
d725 1
a725 1
			}
d744 1
a744 1
			{
d747 1
a747 1
			}
d752 1
a752 1
			{
d755 1
a755 1
			}
d765 1
a765 1
			{
d768 1
a768 1
			}
d771 1
a771 1
			{
d774 1
a774 1
				{
d777 1
a777 1
				}
d783 1
a783 1
			}
d787 2
a789 2
			if (!CONF_parse_list(str, ',', 1, bitstr_cb, atmp->value.bit_string))
				{
d792 1
a792 1
				}
d795 1
a795 1
			}
d797 1
a797 1
			{
d800 1
a800 1
			}
d803 1
a803 1
			{
d808 1
a808 1
			}
d817 1
a817 1
		}
d831 1
a831 1
	}
d834 1
a834 1
	{
d843 1
a843 1
		{
d846 1
a846 1
		}
d848 1
a848 1
		{
d851 1
a851 1
		}
d853 1
a853 1
	}
@


1.2
log
@fix a few bugs observed on http://www.viva64.com/en/b/0250/
ok krw miod
@
text
@d229 1
a229 1
	new_der = OPENSSL_malloc(len);
d269 1
a269 1
		OPENSSL_free(orig_der);
d271 1
a271 1
		OPENSSL_free(new_der);
d502 1
a502 1
		OPENSSL_free(der);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
d230 2
d250 5
d257 1
d371 1
a371 1
		else if (!strncmp(vstart, "BITLIST", 3))
d450 1
a450 1
	ASN1_TYPE *ret = NULL, *typ = NULL;
d453 1
a453 1
	unsigned char *der = NULL, *p;
d455 1
a455 1
	int i, is_set;
d457 2
d468 1
a468 1
			typ = ASN1_generate_v3(sk_CONF_VALUE_value(sect, i)->value, cnf);
d471 2
a472 2
			sk_ASN1_TYPE_push(sk, typ);
			typ = NULL;
d479 1
a479 1
		is_set = 1;
d481 1
a481 1
		is_set = 0;
d483 2
a484 7

	derlen = i2d_ASN1_SET_OF_ASN1_TYPE(sk, NULL, i2d_ASN1_TYPE, utype,
					   V_ASN1_UNIVERSAL, is_set);
	der = OPENSSL_malloc(derlen);
	p = der;
	i2d_ASN1_SET_OF_ASN1_TYPE(sk, &p, i2d_ASN1_TYPE, utype,
				  V_ASN1_UNIVERSAL, is_set);
a505 2
	if (typ)
		ASN1_TYPE_free(typ);
d555 1
a555 1
	static struct tag_name_st *tntmp, tnst [] = {
d590 2
d737 1
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.3
log
@import OpenSSL-1.0.0a
@
text
@a229 2
	if (!new_der)
		goto err;
a247 5
		{
		if (asn1_tags.imp_class == V_ASN1_UNIVERSAL 
		    && (asn1_tags.imp_tag == V_ASN1_SEQUENCE
		     || asn1_tags.imp_tag == V_ASN1_SET) )
			hdr_constructed = V_ASN1_CONSTRUCTED;
a249 1
		}
d442 1
a442 1
	ASN1_TYPE *ret = NULL;
d445 1
a445 1
	unsigned char *der = NULL;
d447 1
a447 1
	int i;
a448 2
	if (!sk)
		goto bad;
d458 1
a458 1
			ASN1_TYPE *typ = ASN1_generate_v3(sk_CONF_VALUE_value(sect, i)->value, cnf);
d461 2
a462 2
			if (!sk_ASN1_TYPE_push(sk, typ))
				goto bad;
d469 1
a469 1
		derlen = i2d_ASN1_SET_ANY(sk, &der);
d471 2
a472 1
		derlen = i2d_ASN1_SEQUENCE_ANY(sk, &der);
d474 6
a479 2
	if (derlen < 0)
		goto bad;
d501 2
d552 1
a552 1
	static const struct tag_name_st *tntmp, tnst [] = {
a586 2
		ASN1_GEN_STR("NUMERIC", V_ASN1_NUMERICSTRING),
		ASN1_GEN_STR("NUMERICSTRING", V_ASN1_NUMERICSTRING),
a731 1
		case V_ASN1_NUMERICSTRING:
@


