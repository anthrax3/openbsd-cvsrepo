head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.6
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.12.0.4
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	butholakala:1.4
	openssl_1_0_1_g:1.1.1.4
	OPENBSD_5_5:1.4.0.16
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.12
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.10
	OPENBSD_5_3_BASE:1.4
	openssl_1_0_1_c:1.1.1.4
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.8
	openssl_1_0_0_f:1.1.1.4
	openssl_1_0_0_e:1.1.1.4
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	openssh_1_0_0_a:1.1.1.4
	OPENBSD_4_8:1.3.0.8
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	openssl_0_9_8_k:1.1.1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	openssl_0_9_8_j:1.1.1.3
	openssl_0_9_8_h:1.1.1.2
	pre_openssl_0_9_8h:1.1
	OPENBSD_4_4:1.1.0.26
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.24
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.22
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.20
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.18
	OPENBSD_4_0_BASE:1.1
	openssl_0_9_7j:1.1.1.1
	openssl:1.1.1
	OPENBSD_3_9:1.1.0.16
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.14
	OPENBSD_3_8_BASE:1.1
	OPENSSL_0_9_7G:1.1.1.1
	OPENBSD_3_7:1.1.0.12
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.10
	OPENBSD_3_6_BASE:1.1
	OPENSSL_0_9_7D:1.1.1.1
	OPENBSD_3_5:1.1.0.8
	OPENBSD_3_5_BASE:1.1
	OPENSSL_0_9_7C:1.1.1.1
	OPENBSD_3_4:1.1.0.6
	OPENBSD_3_4_BASE:1.1
	OPENSSL_0_9_7B:1.1.1.1
	OPENBSD_3_3:1.1.0.4
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.07.25.17.20.02;	author jsing;	state Exp;
branches;
next	1.12;
commitid	GRnrk7Zlgqg46Nh0;

1.12
date	2015.02.14.19.41.39;	author miod;	state Exp;
branches;
next	1.11;
commitid	KVko553P08ieJpft;

1.11
date	2015.02.14.15.23.57;	author miod;	state Exp;
branches;
next	1.10;
commitid	peVibfevZfgr8DNB;

1.10
date	2015.02.10.08.05.16;	author jsing;	state Exp;
branches;
next	1.9;
commitid	kAuyq8DyOW7AKXoO;

1.9
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	mJUVYpkFBZ0Zv2bG;

1.8
date	2014.05.24.15.03.39;	author jsing;	state Exp;
branches;
next	1.7;

1.7
date	2014.05.24.09.16.07;	author jsing;	state Exp;
branches;
next	1.6;

1.6
date	2014.05.24.07.26.05;	author jsing;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.27.20.22.30;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.09.12.15.27;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.46;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.06.12.15.40;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2009.01.09.12.13.51;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.03;	author djm;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Place the ASN.1 template macros (and remaining implement macros) under
#ifndef LIBRESSL_INTERNAL - we're not using these anymore!
@
text
@/* $OpenBSD: asn1t.h,v 1.12 2015/02/14 19:41:39 miod Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
#ifndef HEADER_ASN1T_H
#define HEADER_ASN1T_H

#include <stddef.h>

#include <openssl/opensslconf.h>

#include <openssl/asn1.h>

/* ASN1 template defines, structures and functions */

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef LIBRESSL_INTERNAL

/* Macro to obtain ASN1_ADB pointer from a type (only used internally) */
#define ASN1_ADB_ptr(iptr) ((const ASN1_ADB *)(iptr))


/* Macros for start and end of ASN1_ITEM definition */

#define ASN1_ITEM_start(itname) \
	const ASN1_ITEM itname##_it = {

#define ASN1_ITEM_end(itname) \
		};



/* Macros to aid ASN1 template writing */

#define ASN1_ITEM_TEMPLATE(tname) \
	static const ASN1_TEMPLATE tname##_item_tt 

#define ASN1_ITEM_TEMPLATE_END(tname) \
	;\
	ASN1_ITEM_start(tname) \
		ASN1_ITYPE_PRIMITIVE,\
		-1,\
		&tname##_item_tt,\
		0,\
		NULL,\
		0,\
		#tname \
	ASN1_ITEM_end(tname)


/* This is a ASN1 type which just embeds a template */
 
/* This pair helps declare a SEQUENCE. We can do:
 *
 * 	ASN1_SEQUENCE(stname) = {
 * 		... SEQUENCE components ...
 * 	} ASN1_SEQUENCE_END(stname)
 *
 * 	This will produce an ASN1_ITEM called stname_it
 *	for a structure called stname.
 *
 * 	If you want the same structure but a different
 *	name then use:
 *
 * 	ASN1_SEQUENCE(itname) = {
 * 		... SEQUENCE components ...
 * 	} ASN1_SEQUENCE_END_name(stname, itname)
 *
 *	This will create an item called itname_it using
 *	a structure called stname.
 */

#define ASN1_SEQUENCE(tname) \
	static const ASN1_TEMPLATE tname##_seq_tt[] 

#define ASN1_SEQUENCE_END(stname) ASN1_SEQUENCE_END_name(stname, stname)

#define ASN1_SEQUENCE_END_name(stname, tname) \
	;\
	ASN1_ITEM_start(tname) \
		ASN1_ITYPE_SEQUENCE,\
		V_ASN1_SEQUENCE,\
		tname##_seq_tt,\
		sizeof(tname##_seq_tt) / sizeof(ASN1_TEMPLATE),\
		NULL,\
		sizeof(stname),\
		#stname \
	ASN1_ITEM_end(tname)

#define ASN1_NDEF_SEQUENCE(tname) \
	ASN1_SEQUENCE(tname)

#define ASN1_NDEF_SEQUENCE_cb(tname, cb) \
	ASN1_SEQUENCE_cb(tname, cb)

#define ASN1_SEQUENCE_cb(tname, cb) \
	static const ASN1_AUX tname##_aux = {NULL, 0, 0, 0, cb, 0}; \
	ASN1_SEQUENCE(tname)

#define ASN1_BROKEN_SEQUENCE(tname) \
	static const ASN1_AUX tname##_aux = {NULL, ASN1_AFLG_BROKEN, 0, 0, 0, 0}; \
	ASN1_SEQUENCE(tname)

#define ASN1_SEQUENCE_ref(tname, cb, lck) \
	static const ASN1_AUX tname##_aux = {NULL, ASN1_AFLG_REFCOUNT, offsetof(tname, references), lck, cb, 0}; \
	ASN1_SEQUENCE(tname)

#define ASN1_SEQUENCE_enc(tname, enc, cb) \
	static const ASN1_AUX tname##_aux = {NULL, ASN1_AFLG_ENCODING, 0, 0, cb, offsetof(tname, enc)}; \
	ASN1_SEQUENCE(tname)

#define ASN1_NDEF_SEQUENCE_END(tname) \
	;\
	ASN1_ITEM_start(tname) \
		ASN1_ITYPE_NDEF_SEQUENCE,\
		V_ASN1_SEQUENCE,\
		tname##_seq_tt,\
		sizeof(tname##_seq_tt) / sizeof(ASN1_TEMPLATE),\
		NULL,\
		sizeof(tname),\
		#tname \
	ASN1_ITEM_end(tname)

#define ASN1_BROKEN_SEQUENCE_END(stname) ASN1_SEQUENCE_END_ref(stname, stname)

#define ASN1_SEQUENCE_END_enc(stname, tname) ASN1_SEQUENCE_END_ref(stname, tname)

#define ASN1_SEQUENCE_END_cb(stname, tname) ASN1_SEQUENCE_END_ref(stname, tname)

#define ASN1_SEQUENCE_END_ref(stname, tname) \
	;\
	ASN1_ITEM_start(tname) \
		ASN1_ITYPE_SEQUENCE,\
		V_ASN1_SEQUENCE,\
		tname##_seq_tt,\
		sizeof(tname##_seq_tt) / sizeof(ASN1_TEMPLATE),\
		&tname##_aux,\
		sizeof(stname),\
		#stname \
	ASN1_ITEM_end(tname)

#define ASN1_NDEF_SEQUENCE_END_cb(stname, tname) \
	;\
	ASN1_ITEM_start(tname) \
		ASN1_ITYPE_NDEF_SEQUENCE,\
		V_ASN1_SEQUENCE,\
		tname##_seq_tt,\
		sizeof(tname##_seq_tt) / sizeof(ASN1_TEMPLATE),\
		&tname##_aux,\
		sizeof(stname),\
		#stname \
	ASN1_ITEM_end(tname)


/* This pair helps declare a CHOICE type. We can do:
 *
 * 	ASN1_CHOICE(chname) = {
 * 		... CHOICE options ...
 * 	ASN1_CHOICE_END(chname)
 *
 * 	This will produce an ASN1_ITEM called chname_it
 *	for a structure called chname. The structure
 *	definition must look like this:
 *	typedef struct {
 *		int type;
 *		union {
 *			ASN1_SOMETHING *opt1;
 *			ASN1_SOMEOTHER *opt2;
 *		} value;
 *	} chname;
 *	
 *	the name of the selector must be 'type'.
 * 	to use an alternative selector name use the
 *      ASN1_CHOICE_END_selector() version.
 */

#define ASN1_CHOICE(tname) \
	static const ASN1_TEMPLATE tname##_ch_tt[] 

#define ASN1_CHOICE_cb(tname, cb) \
	static const ASN1_AUX tname##_aux = {NULL, 0, 0, 0, cb, 0}; \
	ASN1_CHOICE(tname)

#define ASN1_CHOICE_END(stname) ASN1_CHOICE_END_name(stname, stname)

#define ASN1_CHOICE_END_name(stname, tname) ASN1_CHOICE_END_selector(stname, tname, type)

#define ASN1_CHOICE_END_selector(stname, tname, selname) \
	;\
	ASN1_ITEM_start(tname) \
		ASN1_ITYPE_CHOICE,\
		offsetof(stname,selname) ,\
		tname##_ch_tt,\
		sizeof(tname##_ch_tt) / sizeof(ASN1_TEMPLATE),\
		NULL,\
		sizeof(stname),\
		#stname \
	ASN1_ITEM_end(tname)

#define ASN1_CHOICE_END_cb(stname, tname, selname) \
	;\
	ASN1_ITEM_start(tname) \
		ASN1_ITYPE_CHOICE,\
		offsetof(stname,selname) ,\
		tname##_ch_tt,\
		sizeof(tname##_ch_tt) / sizeof(ASN1_TEMPLATE),\
		&tname##_aux,\
		sizeof(stname),\
		#stname \
	ASN1_ITEM_end(tname)

/* This helps with the template wrapper form of ASN1_ITEM */

#define ASN1_EX_TEMPLATE_TYPE(flags, tag, name, type) { \
	(flags), (tag), 0,\
	#name, ASN1_ITEM_ref(type) }

/* These help with SEQUENCE or CHOICE components */

/* used to declare other types */

#define ASN1_EX_TYPE(flags, tag, stname, field, type) { \
	(flags), (tag), offsetof(stname, field),\
	#field, ASN1_ITEM_ref(type) }

/* used when the structure is combined with the parent */

#define ASN1_EX_COMBINE(flags, tag, type) { \
	(flags)|ASN1_TFLG_COMBINE, (tag), 0, NULL, ASN1_ITEM_ref(type) }

/* implicit and explicit helper macros */

#define ASN1_IMP_EX(stname, field, type, tag, ex) \
		ASN1_EX_TYPE(ASN1_TFLG_IMPLICIT | ex, tag, stname, field, type)

#define ASN1_EXP_EX(stname, field, type, tag, ex) \
		ASN1_EX_TYPE(ASN1_TFLG_EXPLICIT | ex, tag, stname, field, type)

/* Any defined by macros: the field used is in the table itself */

#define ASN1_ADB_OBJECT(tblname) { ASN1_TFLG_ADB_OID, -1, 0, #tblname, (const ASN1_ITEM *)&(tblname##_adb) }
#define ASN1_ADB_INTEGER(tblname) { ASN1_TFLG_ADB_INT, -1, 0, #tblname, (const ASN1_ITEM *)&(tblname##_adb) }
/* Plain simple type */
#define ASN1_SIMPLE(stname, field, type) ASN1_EX_TYPE(0,0, stname, field, type)

/* OPTIONAL simple type */
#define ASN1_OPT(stname, field, type) ASN1_EX_TYPE(ASN1_TFLG_OPTIONAL, 0, stname, field, type)

/* IMPLICIT tagged simple type */
#define ASN1_IMP(stname, field, type, tag) ASN1_IMP_EX(stname, field, type, tag, 0)

/* IMPLICIT tagged OPTIONAL simple type */
#define ASN1_IMP_OPT(stname, field, type, tag) ASN1_IMP_EX(stname, field, type, tag, ASN1_TFLG_OPTIONAL)

/* Same as above but EXPLICIT */

#define ASN1_EXP(stname, field, type, tag) ASN1_EXP_EX(stname, field, type, tag, 0)
#define ASN1_EXP_OPT(stname, field, type, tag) ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_OPTIONAL)

/* SEQUENCE OF type */
#define ASN1_SEQUENCE_OF(stname, field, type) \
		ASN1_EX_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, stname, field, type)

/* OPTIONAL SEQUENCE OF */
#define ASN1_SEQUENCE_OF_OPT(stname, field, type) \
		ASN1_EX_TYPE(ASN1_TFLG_SEQUENCE_OF|ASN1_TFLG_OPTIONAL, 0, stname, field, type)

/* Same as above but for SET OF */

#define ASN1_SET_OF(stname, field, type) \
		ASN1_EX_TYPE(ASN1_TFLG_SET_OF, 0, stname, field, type)

#define ASN1_SET_OF_OPT(stname, field, type) \
		ASN1_EX_TYPE(ASN1_TFLG_SET_OF|ASN1_TFLG_OPTIONAL, 0, stname, field, type)

/* Finally compound types of SEQUENCE, SET, IMPLICIT, EXPLICIT and OPTIONAL */

#define ASN1_IMP_SET_OF(stname, field, type, tag) \
			ASN1_IMP_EX(stname, field, type, tag, ASN1_TFLG_SET_OF)

#define ASN1_EXP_SET_OF(stname, field, type, tag) \
			ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_SET_OF)

#define ASN1_IMP_SET_OF_OPT(stname, field, type, tag) \
			ASN1_IMP_EX(stname, field, type, tag, ASN1_TFLG_SET_OF|ASN1_TFLG_OPTIONAL)

#define ASN1_EXP_SET_OF_OPT(stname, field, type, tag) \
			ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_SET_OF|ASN1_TFLG_OPTIONAL)

#define ASN1_IMP_SEQUENCE_OF(stname, field, type, tag) \
			ASN1_IMP_EX(stname, field, type, tag, ASN1_TFLG_SEQUENCE_OF)

#define ASN1_IMP_SEQUENCE_OF_OPT(stname, field, type, tag) \
			ASN1_IMP_EX(stname, field, type, tag, ASN1_TFLG_SEQUENCE_OF|ASN1_TFLG_OPTIONAL)

#define ASN1_EXP_SEQUENCE_OF(stname, field, type, tag) \
			ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_SEQUENCE_OF)

#define ASN1_EXP_SEQUENCE_OF_OPT(stname, field, type, tag) \
			ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_SEQUENCE_OF|ASN1_TFLG_OPTIONAL)

/* EXPLICIT using indefinite length constructed form */
#define ASN1_NDEF_EXP(stname, field, type, tag) \
			ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_NDEF)

/* EXPLICIT OPTIONAL using indefinite length constructed form */
#define ASN1_NDEF_EXP_OPT(stname, field, type, tag) \
			ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_OPTIONAL|ASN1_TFLG_NDEF)

/* Macros for the ASN1_ADB structure */

#define ASN1_ADB(name) \
	static const ASN1_ADB_TABLE name##_adbtbl[] 


#define ASN1_ADB_END(name, flags, field, app_table, def, none) \
	;\
	static const ASN1_ADB name##_adb = {\
		flags,\
		offsetof(name, field),\
		app_table,\
		name##_adbtbl,\
		sizeof(name##_adbtbl) / sizeof(ASN1_ADB_TABLE),\
		def,\
		none\
	}


#define ADB_ENTRY(val, template) {val, template}

#define ASN1_ADB_TEMPLATE(name) \
	static const ASN1_TEMPLATE name##_tt 

#endif /* !LIBRESSL_INTERNAL */

/* This is the ASN1 template structure that defines
 * a wrapper round the actual type. It determines the
 * actual position of the field in the value structure,
 * various flags such as OPTIONAL and the field name.
 */

struct ASN1_TEMPLATE_st {
unsigned long flags;		/* Various flags */
long tag;			/* tag, not used if no tagging */
unsigned long offset;		/* Offset of this field in structure */
#ifndef NO_ASN1_FIELD_NAMES
const char *field_name;		/* Field name */
#endif
ASN1_ITEM_EXP *item;		/* Relevant ASN1_ITEM or ASN1_ADB */
};

/* Macro to extract ASN1_ITEM and ASN1_ADB pointer from ASN1_TEMPLATE */

#define ASN1_TEMPLATE_item(t) (t->item_ptr)
#define ASN1_TEMPLATE_adb(t) (t->item_ptr)

typedef struct ASN1_ADB_TABLE_st ASN1_ADB_TABLE;
typedef struct ASN1_ADB_st ASN1_ADB;

struct ASN1_ADB_st {
	unsigned long flags;	/* Various flags */
	unsigned long offset;	/* Offset of selector field */
	STACK_OF(ASN1_ADB_TABLE) **app_items; /* Application defined items */
	const ASN1_ADB_TABLE *tbl;	/* Table of possible types */
	long tblcount;		/* Number of entries in tbl */
	const ASN1_TEMPLATE *default_tt;  /* Type to use if no match */
	const ASN1_TEMPLATE *null_tt;  /* Type to use if selector is NULL */
};

struct ASN1_ADB_TABLE_st {
	long value;		/* NID for an object or value for an int */
	const ASN1_TEMPLATE tt;		/* item for this value */
};

/* template flags */

/* Field is optional */
#define ASN1_TFLG_OPTIONAL	(0x1)

/* Field is a SET OF */
#define ASN1_TFLG_SET_OF	(0x1 << 1)

/* Field is a SEQUENCE OF */
#define ASN1_TFLG_SEQUENCE_OF	(0x2 << 1)

/* Special case: this refers to a SET OF that
 * will be sorted into DER order when encoded *and*
 * the corresponding STACK will be modified to match
 * the new order.
 */
#define ASN1_TFLG_SET_ORDER	(0x3 << 1)

/* Mask for SET OF or SEQUENCE OF */
#define ASN1_TFLG_SK_MASK	(0x3 << 1)

/* These flags mean the tag should be taken from the
 * tag field. If EXPLICIT then the underlying type
 * is used for the inner tag.
 */

/* IMPLICIT tagging */
#define ASN1_TFLG_IMPTAG	(0x1 << 3)


/* EXPLICIT tagging, inner tag from underlying type */
#define ASN1_TFLG_EXPTAG	(0x2 << 3)

#define ASN1_TFLG_TAG_MASK	(0x3 << 3)

/* context specific IMPLICIT */
#define ASN1_TFLG_IMPLICIT	ASN1_TFLG_IMPTAG|ASN1_TFLG_CONTEXT

/* context specific EXPLICIT */
#define ASN1_TFLG_EXPLICIT	ASN1_TFLG_EXPTAG|ASN1_TFLG_CONTEXT

/* If tagging is in force these determine the
 * type of tag to use. Otherwise the tag is
 * determined by the underlying type. These 
 * values reflect the actual octet format.
 */

/* Universal tag */ 
#define ASN1_TFLG_UNIVERSAL	(0x0<<6)
/* Application tag */ 
#define ASN1_TFLG_APPLICATION	(0x1<<6)
/* Context specific tag */ 
#define ASN1_TFLG_CONTEXT	(0x2<<6)
/* Private tag */ 
#define ASN1_TFLG_PRIVATE	(0x3<<6)

#define ASN1_TFLG_TAG_CLASS	(0x3<<6)

/* These are for ANY DEFINED BY type. In this case
 * the 'item' field points to an ASN1_ADB structure
 * which contains a table of values to decode the
 * relevant type
 */

#define ASN1_TFLG_ADB_MASK	(0x3<<8)

#define ASN1_TFLG_ADB_OID	(0x1<<8)

#define ASN1_TFLG_ADB_INT	(0x1<<9)

/* This flag means a parent structure is passed
 * instead of the field: this is useful is a
 * SEQUENCE is being combined with a CHOICE for
 * example. Since this means the structure and
 * item name will differ we need to use the
 * ASN1_CHOICE_END_name() macro for example.
 */

#define ASN1_TFLG_COMBINE	(0x1<<10)

/* This flag when present in a SEQUENCE OF, SET OF
 * or EXPLICIT causes indefinite length constructed
 * encoding to be used if required.
 */

#define ASN1_TFLG_NDEF		(0x1<<11)

/* This is the actual ASN1 item itself */

struct ASN1_ITEM_st {
char itype;			/* The item type, primitive, SEQUENCE, CHOICE or extern */
long utype;			/* underlying type */
const ASN1_TEMPLATE *templates;	/* If SEQUENCE or CHOICE this contains the contents */
long tcount;			/* Number of templates if SEQUENCE or CHOICE */
const void *funcs;		/* functions that handle this type */
long size;			/* Structure size (usually)*/
#ifndef NO_ASN1_FIELD_NAMES
const char *sname;		/* Structure name */
#endif
};

/* These are values for the itype field and
 * determine how the type is interpreted.
 *
 * For PRIMITIVE types the underlying type
 * determines the behaviour if items is NULL.
 *
 * Otherwise templates must contain a single 
 * template and the type is treated in the
 * same way as the type specified in the template.
 *
 * For SEQUENCE types the templates field points
 * to the members, the size field is the
 * structure size.
 *
 * For CHOICE types the templates field points
 * to each possible member (typically a union)
 * and the 'size' field is the offset of the
 * selector.
 *
 * The 'funcs' field is used for application
 * specific functions. 
 *
 * The EXTERN type uses a new style d2i/i2d.
 * The new style should be used where possible
 * because it avoids things like the d2i IMPLICIT
 * hack.
 *
 * MSTRING is a multiple string type, it is used
 * for a CHOICE of character strings where the
 * actual strings all occupy an ASN1_STRING
 * structure. In this case the 'utype' field
 * has a special meaning, it is used as a mask
 * of acceptable types using the B_ASN1 constants.
 *
 * NDEF_SEQUENCE is the same as SEQUENCE except
 * that it will use indefinite length constructed
 * encoding if requested.
 *
 */

#define ASN1_ITYPE_PRIMITIVE		0x0

#define ASN1_ITYPE_SEQUENCE		0x1

#define ASN1_ITYPE_CHOICE		0x2

#define ASN1_ITYPE_EXTERN		0x4

#define ASN1_ITYPE_MSTRING		0x5

#define ASN1_ITYPE_NDEF_SEQUENCE	0x6

/* Cache for ASN1 tag and length, so we
 * don't keep re-reading it for things
 * like CHOICE
 */

struct ASN1_TLC_st{
	char valid;	/* Values below are valid */
	int ret;	/* return value */
	long plen;	/* length */
	int ptag;	/* class value */
	int pclass;	/* class value */
	int hdrlen;	/* header length */
};

/* Typedefs for ASN1 function pointers */

typedef ASN1_VALUE * ASN1_new_func(void);
typedef void ASN1_free_func(ASN1_VALUE *a);
typedef ASN1_VALUE * ASN1_d2i_func(ASN1_VALUE **a, const unsigned char ** in, long length);
typedef int ASN1_i2d_func(ASN1_VALUE * a, unsigned char **in);

typedef int ASN1_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len, const ASN1_ITEM *it,
					int tag, int aclass, char opt, ASN1_TLC *ctx);

typedef int ASN1_ex_i2d(ASN1_VALUE **pval, unsigned char **out, const ASN1_ITEM *it, int tag, int aclass);
typedef int ASN1_ex_new_func(ASN1_VALUE **pval, const ASN1_ITEM *it);
typedef void ASN1_ex_free_func(ASN1_VALUE **pval, const ASN1_ITEM *it);

typedef int ASN1_ex_print_func(BIO *out, ASN1_VALUE **pval, 
						int indent, const char *fname, 
						const ASN1_PCTX *pctx);

typedef int ASN1_primitive_i2c(ASN1_VALUE **pval, unsigned char *cont, int *putype, const ASN1_ITEM *it);
typedef int ASN1_primitive_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len, int utype, char *free_cont, const ASN1_ITEM *it);
typedef int ASN1_primitive_print(BIO *out, ASN1_VALUE **pval, const ASN1_ITEM *it, int indent, const ASN1_PCTX *pctx);

typedef struct ASN1_EXTERN_FUNCS_st {
	void *app_data;
	ASN1_ex_new_func *asn1_ex_new;
	ASN1_ex_free_func *asn1_ex_free;
	ASN1_ex_free_func *asn1_ex_clear;
	ASN1_ex_d2i *asn1_ex_d2i;
	ASN1_ex_i2d *asn1_ex_i2d;
	ASN1_ex_print_func *asn1_ex_print;
} ASN1_EXTERN_FUNCS;

typedef struct ASN1_PRIMITIVE_FUNCS_st {
	void *app_data;
	unsigned long flags;
	ASN1_ex_new_func *prim_new;
	ASN1_ex_free_func *prim_free;
	ASN1_ex_free_func *prim_clear;
	ASN1_primitive_c2i *prim_c2i;
	ASN1_primitive_i2c *prim_i2c;
	ASN1_primitive_print *prim_print;
} ASN1_PRIMITIVE_FUNCS;

/* This is the ASN1_AUX structure: it handles various
 * miscellaneous requirements. For example the use of
 * reference counts and an informational callback.
 *
 * The "informational callback" is called at various
 * points during the ASN1 encoding and decoding. It can
 * be used to provide minor customisation of the structures
 * used. This is most useful where the supplied routines
 * *almost* do the right thing but need some extra help
 * at a few points. If the callback returns zero then
 * it is assumed a fatal error has occurred and the 
 * main operation should be abandoned.
 *
 * If major changes in the default behaviour are required
 * then an external type is more appropriate.
 */

typedef int ASN1_aux_cb(int operation, ASN1_VALUE **in, const ASN1_ITEM *it,
				void *exarg);

typedef struct ASN1_AUX_st {
	void *app_data;
	int flags;
	int ref_offset;		/* Offset of reference value */
	int ref_lock;		/* Lock type to use */
	ASN1_aux_cb *asn1_cb;
	int enc_offset;		/* Offset of ASN1_ENCODING structure */
} ASN1_AUX;

/* For print related callbacks exarg points to this structure */
typedef struct ASN1_PRINT_ARG_st {
	BIO *out;
	int indent;
	const ASN1_PCTX *pctx;
} ASN1_PRINT_ARG;

/* For streaming related callbacks exarg points to this structure */
typedef struct ASN1_STREAM_ARG_st {
	/* BIO to stream through */
	BIO *out;
	/* BIO with filters appended */
	BIO *ndef_bio;
	/* Streaming I/O boundary */
	unsigned char **boundary;
} ASN1_STREAM_ARG;

/* Flags in ASN1_AUX */

/* Use a reference count */
#define ASN1_AFLG_REFCOUNT	1
/* Save the encoding of structure (useful for signatures) */
#define ASN1_AFLG_ENCODING	2
/* The Sequence length is invalid */
#define ASN1_AFLG_BROKEN	4

/* operation values for asn1_cb */

#define ASN1_OP_NEW_PRE		0
#define ASN1_OP_NEW_POST	1
#define ASN1_OP_FREE_PRE	2
#define ASN1_OP_FREE_POST	3
#define ASN1_OP_D2I_PRE		4
#define ASN1_OP_D2I_POST	5
#define ASN1_OP_I2D_PRE		6
#define ASN1_OP_I2D_POST	7
#define ASN1_OP_PRINT_PRE	8
#define ASN1_OP_PRINT_POST	9
#define ASN1_OP_STREAM_PRE	10
#define ASN1_OP_STREAM_POST	11
#define ASN1_OP_DETACHED_PRE	12
#define ASN1_OP_DETACHED_POST	13

#ifndef LIBRESSL_INTERNAL

/* Macro to implement a primitive type */
#define IMPLEMENT_ASN1_TYPE(stname) IMPLEMENT_ASN1_TYPE_ex(stname, stname, 0)
#define IMPLEMENT_ASN1_TYPE_ex(itname, vname, ex) \
				ASN1_ITEM_start(itname) \
					ASN1_ITYPE_PRIMITIVE, V_##vname, NULL, 0, NULL, ex, #itname \
				ASN1_ITEM_end(itname)

/* Macro to implement a multi string type */
#define IMPLEMENT_ASN1_MSTRING(itname, mask) \
				ASN1_ITEM_start(itname) \
					ASN1_ITYPE_MSTRING, mask, NULL, 0, NULL, sizeof(ASN1_STRING), #itname \
				ASN1_ITEM_end(itname)
#define IMPLEMENT_EXTERN_ASN1(sname, tag, fptrs) \
	ASN1_ITEM_start(sname) \
		ASN1_ITYPE_EXTERN, \
		tag, \
		NULL, \
		0, \
		&fptrs, \
		0, \
		#sname \
	ASN1_ITEM_end(sname)

/* Macro to implement standard functions in terms of ASN1_ITEM structures */

#define IMPLEMENT_ASN1_FUNCTIONS(stname) IMPLEMENT_ASN1_FUNCTIONS_fname(stname, stname, stname)

#define IMPLEMENT_ASN1_FUNCTIONS_name(stname, itname) IMPLEMENT_ASN1_FUNCTIONS_fname(stname, itname, itname)

#define IMPLEMENT_ASN1_FUNCTIONS_ENCODE_name(stname, itname) \
			IMPLEMENT_ASN1_FUNCTIONS_ENCODE_fname(stname, itname, itname)

#define IMPLEMENT_STATIC_ASN1_ALLOC_FUNCTIONS(stname) \
		IMPLEMENT_ASN1_ALLOC_FUNCTIONS_pfname(static, stname, stname, stname)

#define IMPLEMENT_ASN1_ALLOC_FUNCTIONS(stname) \
		IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, stname, stname)

#define IMPLEMENT_ASN1_ALLOC_FUNCTIONS_pfname(pre, stname, itname, fname) \
	pre stname *fname##_new(void) \
	{ \
		return (stname *)ASN1_item_new(ASN1_ITEM_rptr(itname)); \
	} \
	pre void fname##_free(stname *a) \
	{ \
		ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \
	}

#define IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, itname, fname) \
	stname *fname##_new(void) \
	{ \
		return (stname *)ASN1_item_new(ASN1_ITEM_rptr(itname)); \
	} \
	void fname##_free(stname *a) \
	{ \
		ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \
	}

#define IMPLEMENT_ASN1_FUNCTIONS_fname(stname, itname, fname) \
	IMPLEMENT_ASN1_ENCODE_FUNCTIONS_fname(stname, itname, fname) \
	IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, itname, fname)

#define IMPLEMENT_ASN1_ENCODE_FUNCTIONS_fname(stname, itname, fname) \
	stname *d2i_##fname(stname **a, const unsigned char **in, long len) \
	{ \
		return (stname *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, ASN1_ITEM_rptr(itname));\
	} \
	int i2d_##fname(stname *a, unsigned char **out) \
	{ \
		return ASN1_item_i2d((ASN1_VALUE *)a, out, ASN1_ITEM_rptr(itname));\
	} 

#define IMPLEMENT_ASN1_NDEF_FUNCTION(stname) \
	int i2d_##stname##_NDEF(stname *a, unsigned char **out) \
	{ \
		return ASN1_item_ndef_i2d((ASN1_VALUE *)a, out, ASN1_ITEM_rptr(stname));\
	} 

/* This includes evil casts to remove const: they will go away when full
 * ASN1 constification is done.
 */
#define IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(stname, itname, fname) \
	stname *d2i_##fname(stname **a, const unsigned char **in, long len) \
	{ \
		return (stname *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, ASN1_ITEM_rptr(itname));\
	} \
	int i2d_##fname(const stname *a, unsigned char **out) \
	{ \
		return ASN1_item_i2d((ASN1_VALUE *)a, out, ASN1_ITEM_rptr(itname));\
	} 

#define IMPLEMENT_ASN1_DUP_FUNCTION(stname) \
	stname * stname##_dup(stname *x) \
        { \
        return ASN1_item_dup(ASN1_ITEM_rptr(stname), x); \
        }

#define IMPLEMENT_ASN1_PRINT_FUNCTION(stname) \
	IMPLEMENT_ASN1_PRINT_FUNCTION_fname(stname, stname, stname)

#define IMPLEMENT_ASN1_PRINT_FUNCTION_fname(stname, itname, fname) \
	int fname##_print_ctx(BIO *out, stname *x, int indent, \
						const ASN1_PCTX *pctx) \
	{ \
		return ASN1_item_print(out, (ASN1_VALUE *)x, indent, \
			ASN1_ITEM_rptr(itname), pctx); \
	} 

#define IMPLEMENT_ASN1_FUNCTIONS_const(name) \
		IMPLEMENT_ASN1_FUNCTIONS_const_fname(name, name, name)

#define IMPLEMENT_ASN1_FUNCTIONS_const_fname(stname, itname, fname) \
	IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(stname, itname, fname) \
	IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, itname, fname)

#endif /* !LIBRESSL_INTERNAL */

/* external definitions for primitive types */

DECLARE_ASN1_ITEM(ASN1_BOOLEAN)
DECLARE_ASN1_ITEM(ASN1_TBOOLEAN)
DECLARE_ASN1_ITEM(ASN1_FBOOLEAN)
DECLARE_ASN1_ITEM(ASN1_SEQUENCE)
DECLARE_ASN1_ITEM(CBIGNUM)
DECLARE_ASN1_ITEM(BIGNUM)
DECLARE_ASN1_ITEM(LONG)
DECLARE_ASN1_ITEM(ZLONG)

DECLARE_STACK_OF(ASN1_VALUE)

/* Functions used internally by the ASN1 code */

int ASN1_item_ex_new(ASN1_VALUE **pval, const ASN1_ITEM *it);
void ASN1_item_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it);
int ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);
int ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it);

void ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);
int ASN1_template_d2i(ASN1_VALUE **pval, const unsigned char **in, long len, const ASN1_TEMPLATE *tt);
int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len, const ASN1_ITEM *it,
				int tag, int aclass, char opt, ASN1_TLC *ctx);

int ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned char **out, const ASN1_ITEM *it, int tag, int aclass);
int ASN1_template_i2d(ASN1_VALUE **pval, unsigned char **out, const ASN1_TEMPLATE *tt);
void ASN1_primitive_free(ASN1_VALUE **pval, const ASN1_ITEM *it);

int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len, int utype, char *free_cont, const ASN1_ITEM *it);

int asn1_get_choice_selector(ASN1_VALUE **pval, const ASN1_ITEM *it);
int asn1_set_choice_selector(ASN1_VALUE **pval, int value, const ASN1_ITEM *it);

ASN1_VALUE ** asn1_get_field_ptr(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);

const ASN1_TEMPLATE *asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt, int nullerr);

int asn1_do_lock(ASN1_VALUE **pval, int op, const ASN1_ITEM *it);

void asn1_enc_init(ASN1_VALUE **pval, const ASN1_ITEM *it);
void asn1_enc_free(ASN1_VALUE **pval, const ASN1_ITEM *it);
int asn1_enc_restore(int *len, unsigned char **out, ASN1_VALUE **pval, const ASN1_ITEM *it);
int asn1_enc_save(ASN1_VALUE **pval, const unsigned char *in, int inlen, const ASN1_ITEM *it);

#ifdef  __cplusplus
}
#endif
#endif
@


1.12
log
@Remove asn1_ex_i2c() prototype, now that this function has been made static;
reminded by bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: asn1t.h,v 1.11 2015/02/14 15:23:57 miod Exp $ */
d73 1
a73 1

d390 2
d713 2
a737 1
#ifndef LIBRESSL_INTERNAL
@


1.11
log
@Remove IMPLEMENT_COMPAT_ASN1() and related support code. Nothing uses it in
libcrypto/libssl, and nothing seems to use it in the wild, apart from embedded
copies of OpenSSL.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: asn1t.h,v 1.10 2015/02/10 08:05:16 jsing Exp $ */
a857 1
int asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cont, int *putype, const ASN1_ITEM *it);
@


1.10
log
@Place the IMPLEMENT_ASN1_.*FUNCTION.* macros under an #ifndef
LIBRESSL_INTERNAL - we do not need them any more.
@
text
@d1 1
a1 1
/* $OpenBSD: asn1t.h,v 1.9 2014/06/12 15:49:27 deraadt Exp $ */
a551 4
 * For COMPAT types the funcs field gives a
 * set of functions that handle this type, this
 * supports the old d2i, i2d convention.
 *
a575 2
#define ASN1_ITYPE_COMPAT		0x3

a617 7
typedef struct ASN1_COMPAT_FUNCS_st {
	ASN1_new_func *asn1_new;
	ASN1_free_func *asn1_free;
	ASN1_d2i_func *asn1_d2i;
	ASN1_i2d_func *asn1_i2d;
} ASN1_COMPAT_FUNCS;

a722 22

/* Macro to implement an ASN1_ITEM in terms of old style funcs */

#define IMPLEMENT_COMPAT_ASN1(sname) IMPLEMENT_COMPAT_ASN1_type(sname, V_ASN1_SEQUENCE)

#define IMPLEMENT_COMPAT_ASN1_type(sname, tag) \
	static const ASN1_COMPAT_FUNCS sname##_ff = { \
		(ASN1_new_func *)sname##_new, \
		(ASN1_free_func *)sname##_free, \
		(ASN1_d2i_func *)d2i_##sname, \
		(ASN1_i2d_func *)i2d_##sname, \
	}; \
	ASN1_ITEM_start(sname) \
		ASN1_ITYPE_COMPAT, \
		tag, \
		NULL, \
		0, \
		&sname##_ff, \
		0, \
		#sname \
	ASN1_ITEM_end(sname)

@


1.9
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d769 1
d861 2
@


1.8
log
@We have shared global variables - unifdef OPENSSL_EXPORT_VAR_AS_FUNCTION.

ok miod@@ beck@@
@
text
@d1 1
a1 1
/* asn1t.h */
@


1.7
log
@Almost nothing actually needs to include <openssl/e_os2.h>, however by
including it they get <openssl/opensslconf.h>. So instead of pulling in
<openssl/e_os2.h>, just pull in <openssl/opensslconf.h>.

"go ahead" miod@@
@
text
@a73 1
#ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION
a86 19
#else

/* Macro to obtain ASN1_ADB pointer from a type (only used internally) */
#define ASN1_ADB_ptr(iptr) ((const ASN1_ADB *)(iptr()))


/* Macros for start and end of ASN1_ITEM definition */

#define ASN1_ITEM_start(itname) \
	const ASN1_ITEM * itname##_it(void) \
	{ \
		static const ASN1_ITEM local_it = { 

#define ASN1_ITEM_end(itname) \
		}; \
	return &local_it; \
	}

#endif
a296 1
#ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION
a298 4
#else
#define ASN1_ADB_OBJECT(tblname) { ASN1_TFLG_ADB_OID, -1, 0, #tblname, tblname##_adb }
#define ASN1_ADB_INTEGER(tblname) { ASN1_TFLG_ADB_INT, -1, 0, #tblname, tblname##_adb }
#endif
a370 1
#ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION
a383 21
#else

#define ASN1_ADB_END(name, flags, field, app_table, def, none) \
	;\
	static const ASN1_ITEM *name##_adb(void) \
	{ \
	static const ASN1_ADB internal_adb = \
		{\
		flags,\
		offsetof(name, field),\
		app_table,\
		name##_adbtbl,\
		sizeof(name##_adbtbl) / sizeof(ASN1_ADB_TABLE),\
		def,\
		none\
		}; \
		return (const ASN1_ITEM *) &internal_adb; \
	} \
	void dummy_function(void)

#endif
@


1.6
log
@Expand OPENSSL_{GLOBAL,EXTERN} macros that I missed last time around,
since they are hiding in the #define forest.

ok miod@@
@
text
@d62 3
a64 1
#include <openssl/e_os2.h>
@


1.5
log
@Unifdef -U OPENSSL_BUILD_SHLIBCRYPTO, since all it causes under Unix is to
redefine OPENSSL_EXTERN from `extern' to `extern'.
@
text
@d81 1
a81 1
	OPENSSL_GLOBAL const ASN1_ITEM itname##_it = {
@


1.4
log
@resolve conflicts, fix local changes
@
text
@a64 5
#ifdef OPENSSL_BUILD_SHLIBCRYPTO
# undef OPENSSL_EXTERN
# define OPENSSL_EXTERN OPENSSL_EXPORT
#endif

@


1.3
log
@resolve conflicts
@
text
@d6 1
a6 1
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
d221 12
d666 4
d672 1
d688 1
d699 1
d719 2
a720 1
typedef int ASN1_aux_cb(int operation, ASN1_VALUE **in, const ASN1_ITEM *it);
d731 17
d767 6
d828 3
d834 10
d892 11
@


1.2
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d102 1
a102 1
		static const ASN1_ITEM local_it = { \
d115 1
a115 1
	const static ASN1_TEMPLATE tname##_item_tt 
d153 1
a153 1
	const static ASN1_TEMPLATE tname##_seq_tt[] 
d169 6
d176 1
a176 1
	const static ASN1_AUX tname##_aux = {NULL, 0, 0, 0, cb, 0}; \
d180 1
a180 1
	const static ASN1_AUX tname##_aux = {NULL, ASN1_AFLG_BROKEN, 0, 0, 0, 0}; \
d184 1
a184 1
	const static ASN1_AUX tname##_aux = {NULL, ASN1_AFLG_REFCOUNT, offsetof(tname, references), lck, cb, 0}; \
d188 1
a188 1
	const static ASN1_AUX tname##_aux = {NULL, ASN1_AFLG_ENCODING, 0, 0, cb, offsetof(tname, enc)}; \
d191 12
d245 1
a245 1
	const static ASN1_TEMPLATE tname##_ch_tt[] 
d248 1
a248 1
	const static ASN1_AUX tname##_aux = {NULL, 0, 0, 0, cb, 0}; \
d374 8
d385 1
a385 1
	const static ASN1_ADB_TABLE name##_adbtbl[] 
d391 1
a391 1
	const static ASN1_ADB name##_adb = {\
d405 1
a405 1
	const static ASN1_ITEM *name##_adb(void) \
d407 1
a407 1
	const static ASN1_ADB internal_adb = \
d426 1
a426 1
	const static ASN1_TEMPLATE name##_tt 
d439 1
a439 1
char *field_name;		/* Field name */
d547 7
d606 4
d612 3
a614 1
#define ASN1_ITYPE_PRIMITIVE	0x0
d616 1
a616 1
#define ASN1_ITYPE_SEQUENCE	0x1
d618 1
a618 1
#define ASN1_ITYPE_CHOICE	0x2
d620 1
a620 1
#define ASN1_ITYPE_COMPAT	0x3
d622 1
a622 1
#define ASN1_ITYPE_EXTERN	0x4
d624 1
a624 1
#define ASN1_ITYPE_MSTRING	0x5
d644 1
a644 1
typedef ASN1_VALUE * ASN1_d2i_func(ASN1_VALUE **a, unsigned char ** in, long length);
d647 1
a647 1
typedef int ASN1_ex_d2i(ASN1_VALUE **pval, unsigned char **in, long len, const ASN1_ITEM *it,
d655 1
a655 1
typedef int ASN1_primitive_c2i(ASN1_VALUE **pval, unsigned char *cont, int len, int utype, char *free_cont, const ASN1_ITEM *it);
d785 3
d803 1
a803 1
	stname *d2i_##fname(stname **a, unsigned char **in, long len) \
d812 6
d824 1
a824 1
		return (stname *)ASN1_item_d2i((ASN1_VALUE **)a, (unsigned char **)in, len, ASN1_ITEM_rptr(itname));\
a848 1
DECLARE_ASN1_ITEM(ASN1_ANY)
d865 2
a866 2
int ASN1_template_d2i(ASN1_VALUE **pval, unsigned char **in, long len, const ASN1_TEMPLATE *tt);
int ASN1_item_ex_d2i(ASN1_VALUE **pval, unsigned char **in, long len, const ASN1_ITEM *it,
d874 1
a874 1
int asn1_ex_c2i(ASN1_VALUE **pval, unsigned char *cont, int len, int utype, char *free_cont, const ASN1_ITEM *it);
d888 1
a888 1
int asn1_enc_save(ASN1_VALUE **pval, unsigned char *in, int inlen, const ASN1_ITEM *it);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import of OpenSSL 0.9.8h
@
text
@d102 1
a102 1
		static const ASN1_ITEM local_it = { 
d115 1
a115 1
	static const ASN1_TEMPLATE tname##_item_tt 
d153 1
a153 1
	static const ASN1_TEMPLATE tname##_seq_tt[] 
a168 6
#define ASN1_NDEF_SEQUENCE(tname) \
	ASN1_SEQUENCE(tname)

#define ASN1_NDEF_SEQUENCE_cb(tname, cb) \
	ASN1_SEQUENCE_cb(tname, cb)

d170 1
a170 1
	static const ASN1_AUX tname##_aux = {NULL, 0, 0, 0, cb, 0}; \
d174 1
a174 1
	static const ASN1_AUX tname##_aux = {NULL, ASN1_AFLG_BROKEN, 0, 0, 0, 0}; \
d178 1
a178 1
	static const ASN1_AUX tname##_aux = {NULL, ASN1_AFLG_REFCOUNT, offsetof(tname, references), lck, cb, 0}; \
d182 1
a182 1
	static const ASN1_AUX tname##_aux = {NULL, ASN1_AFLG_ENCODING, 0, 0, cb, offsetof(tname, enc)}; \
a184 12
#define ASN1_NDEF_SEQUENCE_END(tname) \
	;\
	ASN1_ITEM_start(tname) \
		ASN1_ITYPE_NDEF_SEQUENCE,\
		V_ASN1_SEQUENCE,\
		tname##_seq_tt,\
		sizeof(tname##_seq_tt) / sizeof(ASN1_TEMPLATE),\
		NULL,\
		sizeof(tname),\
		#tname \
	ASN1_ITEM_end(tname)

d227 1
a227 1
	static const ASN1_TEMPLATE tname##_ch_tt[] 
d230 1
a230 1
	static const ASN1_AUX tname##_aux = {NULL, 0, 0, 0, cb, 0}; \
a355 8
/* EXPLICIT using indefinite length constructed form */
#define ASN1_NDEF_EXP(stname, field, type, tag) \
			ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_NDEF)

/* EXPLICIT OPTIONAL using indefinite length constructed form */
#define ASN1_NDEF_EXP_OPT(stname, field, type, tag) \
			ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_OPTIONAL|ASN1_TFLG_NDEF)

d359 1
a359 1
	static const ASN1_ADB_TABLE name##_adbtbl[] 
d365 1
a365 1
	static const ASN1_ADB name##_adb = {\
d379 1
a379 1
	static const ASN1_ITEM *name##_adb(void) \
d381 1
a381 1
	static const ASN1_ADB internal_adb = \
d400 1
a400 1
	static const ASN1_TEMPLATE name##_tt 
d413 1
a413 1
const char *field_name;		/* Field name */
a520 7
/* This flag when present in a SEQUENCE OF, SET OF
 * or EXPLICIT causes indefinite length constructed
 * encoding to be used if required.
 */

#define ASN1_TFLG_NDEF		(0x1<<11)

a572 4
 * NDEF_SEQUENCE is the same as SEQUENCE except
 * that it will use indefinite length constructed
 * encoding if requested.
 *
d575 1
a575 3
#define ASN1_ITYPE_PRIMITIVE		0x0

#define ASN1_ITYPE_SEQUENCE		0x1
d577 1
a577 1
#define ASN1_ITYPE_CHOICE		0x2
d579 1
a579 1
#define ASN1_ITYPE_COMPAT		0x3
d581 1
a581 1
#define ASN1_ITYPE_EXTERN		0x4
d583 1
a583 1
#define ASN1_ITYPE_MSTRING		0x5
d585 1
a585 1
#define ASN1_ITYPE_NDEF_SEQUENCE	0x6
d605 1
a605 1
typedef ASN1_VALUE * ASN1_d2i_func(ASN1_VALUE **a, const unsigned char ** in, long length);
d608 1
a608 1
typedef int ASN1_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len, const ASN1_ITEM *it,
d616 1
a616 1
typedef int ASN1_primitive_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len, int utype, char *free_cont, const ASN1_ITEM *it);
a745 3
#define IMPLEMENT_ASN1_ALLOC_FUNCTIONS(stname) \
		IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, stname, stname)

d761 1
a761 1
	stname *d2i_##fname(stname **a, const unsigned char **in, long len) \
a769 6
#define IMPLEMENT_ASN1_NDEF_FUNCTION(stname) \
	int i2d_##stname##_NDEF(stname *a, unsigned char **out) \
	{ \
		return ASN1_item_ndef_i2d((ASN1_VALUE *)a, out, ASN1_ITEM_rptr(stname));\
	} 

d776 1
a776 1
		return (stname *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, ASN1_ITEM_rptr(itname));\
d801 1
d818 2
a819 2
int ASN1_template_d2i(ASN1_VALUE **pval, const unsigned char **in, long len, const ASN1_TEMPLATE *tt);
int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len, const ASN1_ITEM *it,
d827 1
a827 1
int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len, int utype, char *free_cont, const ASN1_ITEM *it);
d841 1
a841 1
int asn1_enc_save(ASN1_VALUE **pval, const unsigned char *in, int inlen, const ASN1_ITEM *it);
@


1.1.1.3
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@d6 1
a6 1
 * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
a220 12
#define ASN1_NDEF_SEQUENCE_END_cb(stname, tname) \
	;\
	ASN1_ITEM_start(tname) \
		ASN1_ITYPE_NDEF_SEQUENCE,\
		V_ASN1_SEQUENCE,\
		tname##_seq_tt,\
		sizeof(tname##_seq_tt) / sizeof(ASN1_TEMPLATE),\
		&tname##_aux,\
		sizeof(stname),\
		#stname \
	ASN1_ITEM_end(tname)

a653 4
typedef int ASN1_ex_print_func(BIO *out, ASN1_VALUE **pval, 
						int indent, const char *fname, 
						const ASN1_PCTX *pctx);

a655 1
typedef int ASN1_primitive_print(BIO *out, ASN1_VALUE **pval, const ASN1_ITEM *it, int indent, const ASN1_PCTX *pctx);
a670 1
	ASN1_ex_print_func *asn1_ex_print;
a680 1
	ASN1_primitive_print *prim_print;
d700 1
a700 2
typedef int ASN1_aux_cb(int operation, ASN1_VALUE **in, const ASN1_ITEM *it,
				void *exarg);
a710 17
/* For print related callbacks exarg points to this structure */
typedef struct ASN1_PRINT_ARG_st {
	BIO *out;
	int indent;
	const ASN1_PCTX *pctx;
} ASN1_PRINT_ARG;

/* For streaming related callbacks exarg points to this structure */
typedef struct ASN1_STREAM_ARG_st {
	/* BIO to stream through */
	BIO *out;
	/* BIO with filters appended */
	BIO *ndef_bio;
	/* Streaming I/O boundary */
	unsigned char **boundary;
} ASN1_STREAM_ARG;

a729 6
#define ASN1_OP_PRINT_PRE	8
#define ASN1_OP_PRINT_POST	9
#define ASN1_OP_STREAM_PRE	10
#define ASN1_OP_STREAM_POST	11
#define ASN1_OP_DETACHED_PRE	12
#define ASN1_OP_DETACHED_POST	13
a784 3
#define IMPLEMENT_STATIC_ASN1_ALLOC_FUNCTIONS(stname) \
		IMPLEMENT_ASN1_ALLOC_FUNCTIONS_pfname(static, stname, stname, stname)

a787 10
#define IMPLEMENT_ASN1_ALLOC_FUNCTIONS_pfname(pre, stname, itname, fname) \
	pre stname *fname##_new(void) \
	{ \
		return (stname *)ASN1_item_new(ASN1_ITEM_rptr(itname)); \
	} \
	pre void fname##_free(stname *a) \
	{ \
		ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \
	}

a835 11

#define IMPLEMENT_ASN1_PRINT_FUNCTION(stname) \
	IMPLEMENT_ASN1_PRINT_FUNCTION_fname(stname, stname, stname)

#define IMPLEMENT_ASN1_PRINT_FUNCTION_fname(stname, itname, fname) \
	int fname##_print_ctx(BIO *out, stname *x, int indent, \
						const ASN1_PCTX *pctx) \
	{ \
		return ASN1_item_print(out, (ASN1_VALUE *)x, indent, \
			ASN1_ITEM_rptr(itname), pctx); \
	} 
@


