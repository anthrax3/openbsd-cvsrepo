head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.4
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	butholakala:1.5
	openssl_1_0_1_g:1.1.1.5
	OPENBSD_5_5:1.5.0.16
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.12
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.10
	OPENBSD_5_3_BASE:1.5
	openssl_1_0_1_c:1.1.1.5
	OPENBSD_5_2:1.5.0.6
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.8
	openssl_1_0_0_f:1.1.1.5
	openssl_1_0_0_e:1.1.1.5
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	openssh_1_0_0_a:1.1.1.5
	OPENBSD_4_8:1.4.0.8
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.6
	OPENBSD_4_6_BASE:1.4
	openssl_0_9_8_k:1.1.1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	openssl_0_9_8_j:1.1.1.4
	openssl_0_9_8_h:1.1.1.3
	pre_openssl_0_9_8h:1.2
	OPENBSD_4_4:1.2.0.10
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.8
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.6
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.4
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.1.0.16
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.14
	OPENBSD_3_8_BASE:1.1
	OPENSSL_0_9_7G:1.1.1.1
	OPENBSD_3_7:1.1.0.12
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.10
	OPENBSD_3_6_BASE:1.1
	OPENSSL_0_9_7D:1.1.1.1
	OPENBSD_3_5:1.1.0.8
	OPENBSD_3_5_BASE:1.1
	OPENSSL_0_9_7C:1.1.1.1
	OPENBSD_3_4:1.1.0.6
	OPENBSD_3_4_BASE:1.1
	OPENSSL_0_9_7B:1.1.1.1
	OPENBSD_3_3:1.1.0.4
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2016.05.04.15.00.24;	author tedu;	state Exp;
branches;
next	1.19;
commitid	s4NE9FX4wus4Piaj;

1.19
date	2016.05.04.14.53.29;	author tedu;	state Exp;
branches;
next	1.18;
commitid	dp2wUlmUxyODyIfQ;

1.18
date	2016.05.03.12.38.53;	author tedu;	state Exp;
branches;
next	1.17;
commitid	0ClIPo2LiLW7bSvG;

1.17
date	2015.12.22.08.44.44;	author mmcc;	state Exp;
branches
	1.17.2.1;
next	1.16;
commitid	Rxmvz3iHd5BduplG;

1.16
date	2015.02.14.15.23.57;	author miod;	state Exp;
branches
	1.16.6.1;
next	1.15;
commitid	peVibfevZfgr8DNB;

1.15
date	2015.02.14.15.21.49;	author miod;	state Exp;
branches;
next	1.14;
commitid	ByDUHBYJNzv3POwe;

1.14
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.13;
commitid	yQEL1wOWIearrW15;

1.13
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	mJUVYpkFBZ0Zv2bG;

1.12
date	2014.05.29.21.07.42;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.18.12.15.48;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.18.11.14.35;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.18.00.58.49;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.18.00.10.08;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.17.18.38.53;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.09.12.15.27;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.27.05.07.00;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.50;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.27.05.05.30;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.40;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.01.09.12.13.51;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.03;	author djm;	state Exp;
branches;
next	;

1.16.6.1
date	2016.05.03.12.39.23;	author tedu;	state Exp;
branches;
next	;
commitid	5iHrqqr5iZFurKzX;

1.17.2.1
date	2016.05.03.12.39.48;	author tedu;	state Exp;
branches;
next	;
commitid	Ekna9eOpYJ6UbVcF;


desc
@@


1.20
log
@internal only negative types should not be handled here.
CVE-2016-2108 from openssl.
@
text
@/* $OpenBSD: tasn_enc.c,v 1.19 2016/05/04 14:53:29 tedu Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 2000-2004 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stddef.h>
#include <string.h>

#include <openssl/asn1.h>
#include <openssl/asn1t.h>
#include <openssl/objects.h>

static int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out,
    const ASN1_ITEM *it, int tag, int aclass);
static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
    int skcontlen, const ASN1_ITEM *item, int do_sort, int iclass);
static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
    const ASN1_TEMPLATE *tt, int tag, int aclass);
static int asn1_item_flags_i2d(ASN1_VALUE *val, unsigned char **out,
    const ASN1_ITEM *it, int flags);
static int asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cout, int *putype,
    const ASN1_ITEM *it);

/* Top level i2d equivalents: the 'ndef' variant instructs the encoder
 * to use indefinite length constructed encoding, where appropriate
 */

int
ASN1_item_ndef_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it)
{
	return asn1_item_flags_i2d(val, out, it, ASN1_TFLG_NDEF);
}

int
ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it)
{
	return asn1_item_flags_i2d(val, out, it, 0);
}

/* Encode an ASN1 item, this is use by the
 * standard 'i2d' function. 'out' points to
 * a buffer to output the data to.
 *
 * The new i2d has one additional feature. If the output
 * buffer is NULL (i.e. *out == NULL) then a buffer is
 * allocated and populated with the encoding.
 */

static int
asn1_item_flags_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it,
    int flags)
{
	if (out && !*out) {
		unsigned char *p, *buf;
		int len;
		len = ASN1_item_ex_i2d(&val, NULL, it, -1, flags);
		if (len <= 0)
			return len;
		buf = malloc(len);
		if (!buf)
			return -1;
		p = buf;
		ASN1_item_ex_i2d(&val, &p, it, -1, flags);
		*out = buf;
		return len;
	}

	return ASN1_item_ex_i2d(&val, out, it, -1, flags);
}

/* Encode an item, taking care of IMPLICIT tagging (if any).
 * This function performs the normal item handling: it can be
 * used in external types.
 */

int
ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned char **out, const ASN1_ITEM *it,
    int tag, int aclass)
{
	const ASN1_TEMPLATE *tt = NULL;
	int i, seqcontlen, seqlen, ndef = 1;
	const ASN1_EXTERN_FUNCS *ef;
	const ASN1_AUX *aux = it->funcs;
	ASN1_aux_cb *asn1_cb = NULL;

	if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval)
		return 0;

	if (aux && aux->asn1_cb)
		asn1_cb = aux->asn1_cb;

	switch (it->itype) {

	case ASN1_ITYPE_PRIMITIVE:
		if (it->templates)
			return asn1_template_ex_i2d(pval, out, it->templates,
			    tag, aclass);
		return asn1_i2d_ex_primitive(pval, out, it, tag, aclass);
		break;

	case ASN1_ITYPE_MSTRING:
		return asn1_i2d_ex_primitive(pval, out, it, -1, aclass);

	case ASN1_ITYPE_CHOICE:
		if (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))
			return 0;
		i = asn1_get_choice_selector(pval, it);
		if ((i >= 0) && (i < it->tcount)) {
			ASN1_VALUE **pchval;
			const ASN1_TEMPLATE *chtt;
			chtt = it->templates + i;
			pchval = asn1_get_field_ptr(pval, chtt);
			return asn1_template_ex_i2d(pchval, out, chtt,
			    -1, aclass);
		}
		/* Fixme: error condition if selector out of range */
		if (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))
			return 0;
		break;

	case ASN1_ITYPE_EXTERN:
		/* If new style i2d it does all the work */
		ef = it->funcs;
		return ef->asn1_ex_i2d(pval, out, it, tag, aclass);

	case ASN1_ITYPE_NDEF_SEQUENCE:
		/* Use indefinite length constructed if requested */
		if (aclass & ASN1_TFLG_NDEF)
			ndef = 2;
		/* fall through */

	case ASN1_ITYPE_SEQUENCE:
		i = asn1_enc_restore(&seqcontlen, out, pval, it);
		/* An error occurred */
		if (i < 0)
			return 0;
		/* We have a valid cached encoding... */
		if (i > 0)
			return seqcontlen;
		/* Otherwise carry on */
		seqcontlen = 0;
		/* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */
		if (tag == -1) {
			tag = V_ASN1_SEQUENCE;
			/* Retain any other flags in aclass */
			aclass = (aclass & ~ASN1_TFLG_TAG_CLASS) |
			    V_ASN1_UNIVERSAL;
		}
		if (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))
			return 0;
		/* First work out sequence content length */
		for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
			const ASN1_TEMPLATE *seqtt;
			ASN1_VALUE **pseqval;
			seqtt = asn1_do_adb(pval, tt, 1);
			if (!seqtt)
				return 0;
			pseqval = asn1_get_field_ptr(pval, seqtt);
			/* FIXME: check for errors in enhanced version */
			seqcontlen += asn1_template_ex_i2d(pseqval, NULL, seqtt,
			    -1, aclass);
		}

		seqlen = ASN1_object_size(ndef, seqcontlen, tag);
		if (!out)
			return seqlen;
		/* Output SEQUENCE header */
		ASN1_put_object(out, ndef, seqcontlen, tag, aclass);
		for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
			const ASN1_TEMPLATE *seqtt;
			ASN1_VALUE **pseqval;
			seqtt = asn1_do_adb(pval, tt, 1);
			if (!seqtt)
				return 0;
			pseqval = asn1_get_field_ptr(pval, seqtt);
			/* FIXME: check for errors in enhanced version */
			asn1_template_ex_i2d(pseqval, out, seqtt, -1, aclass);
		}
		if (ndef == 2)
			ASN1_put_eoc(out);
		if (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))
			return 0;
		return seqlen;

	default:
		return 0;

	}
	return 0;
}

int
ASN1_template_i2d(ASN1_VALUE **pval, unsigned char **out,
    const ASN1_TEMPLATE *tt)
{
	return asn1_template_ex_i2d(pval, out, tt, -1, 0);
}

static int
asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
    const ASN1_TEMPLATE *tt, int tag, int iclass)
{
	int i, ret, flags, ttag, tclass, ndef;
	flags = tt->flags;
	/* Work out tag and class to use: tagging may come
	 * either from the template or the arguments, not both
	 * because this would create ambiguity. Additionally
	 * the iclass argument may contain some additional flags
	 * which should be noted and passed down to other levels.
	 */
	if (flags & ASN1_TFLG_TAG_MASK) {
		/* Error if argument and template tagging */
		if (tag != -1)
			/* FIXME: error code here */
			return -1;
		/* Get tagging from template */
		ttag = tt->tag;
		tclass = flags & ASN1_TFLG_TAG_CLASS;
	} else if (tag != -1) {
		/* No template tagging, get from arguments */
		ttag = tag;
		tclass = iclass & ASN1_TFLG_TAG_CLASS;
	} else {
		ttag = -1;
		tclass = 0;
	}
	/*
	 * Remove any class mask from iflag.
	 */
	iclass &= ~ASN1_TFLG_TAG_CLASS;

	/* At this point 'ttag' contains the outer tag to use,
	 * 'tclass' is the class and iclass is any flags passed
	 * to this function.
	 */

	/* if template and arguments require ndef, use it */
	if ((flags & ASN1_TFLG_NDEF) && (iclass & ASN1_TFLG_NDEF))
		ndef = 2;
	else
		ndef = 1;

	if (flags & ASN1_TFLG_SK_MASK) {
		/* SET OF, SEQUENCE OF */
		STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;
		int isset, sktag, skaclass;
		int skcontlen, sklen;
		ASN1_VALUE *skitem;

		if (!*pval)
			return 0;

		if (flags & ASN1_TFLG_SET_OF) {
			isset = 1;
			/* 2 means we reorder */
			if (flags & ASN1_TFLG_SEQUENCE_OF)
				isset = 2;
		} else
			isset = 0;

		/* Work out inner tag value: if EXPLICIT
		 * or no tagging use underlying type.
		 */
		if ((ttag != -1) && !(flags & ASN1_TFLG_EXPTAG)) {
			sktag = ttag;
			skaclass = tclass;
		} else {
			skaclass = V_ASN1_UNIVERSAL;
			if (isset)
				sktag = V_ASN1_SET;
			else
				sktag = V_ASN1_SEQUENCE;
		}

		/* Determine total length of items */
		skcontlen = 0;
		for (i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
			skitem = sk_ASN1_VALUE_value(sk, i);
			skcontlen += ASN1_item_ex_i2d(&skitem, NULL,
			    ASN1_ITEM_ptr(tt->item), -1, iclass);
		}
		sklen = ASN1_object_size(ndef, skcontlen, sktag);
		/* If EXPLICIT need length of surrounding tag */
		if (flags & ASN1_TFLG_EXPTAG)
			ret = ASN1_object_size(ndef, sklen, ttag);
		else
			ret = sklen;

		if (!out)
			return ret;

		/* Now encode this lot... */
		/* EXPLICIT tag */
		if (flags & ASN1_TFLG_EXPTAG)
			ASN1_put_object(out, ndef, sklen, ttag, tclass);
		/* SET or SEQUENCE and IMPLICIT tag */
		ASN1_put_object(out, ndef, skcontlen, sktag, skaclass);
		/* And the stuff itself */
		asn1_set_seq_out(sk, out, skcontlen, ASN1_ITEM_ptr(tt->item),
		    isset, iclass);
		if (ndef == 2) {
			ASN1_put_eoc(out);
			if (flags & ASN1_TFLG_EXPTAG)
				ASN1_put_eoc(out);
		}

		return ret;
	}

	if (flags & ASN1_TFLG_EXPTAG) {
		/* EXPLICIT tagging */
		/* Find length of tagged item */
		i = ASN1_item_ex_i2d(pval, NULL, ASN1_ITEM_ptr(tt->item),
		    -1, iclass);
		if (!i)
			return 0;
		/* Find length of EXPLICIT tag */
		ret = ASN1_object_size(ndef, i, ttag);
		if (out) {
			/* Output tag and item */
			ASN1_put_object(out, ndef, i, ttag, tclass);
			ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item),
			    -1, iclass);
			if (ndef == 2)
				ASN1_put_eoc(out);
		}
		return ret;
	}

	/* Either normal or IMPLICIT tagging: combine class and flags */
	return ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item),
	    ttag, tclass | iclass);
}

/* Temporary structure used to hold DER encoding of items for SET OF */

typedef	struct {
	unsigned char *data;
	int length;
	ASN1_VALUE *field;
} DER_ENC;

static int
der_cmp(const void *a, const void *b)
{
	const DER_ENC *d1 = a, *d2 = b;
	int cmplen, i;

	cmplen = (d1->length < d2->length) ? d1->length : d2->length;
	i = memcmp(d1->data, d2->data, cmplen);
	if (i)
		return i;
	return d1->length - d2->length;
}

/* Output the content octets of SET OF or SEQUENCE OF */

static int
asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out, int skcontlen,
    const ASN1_ITEM *item, int do_sort, int iclass)
{
	int i;
	ASN1_VALUE *skitem;
	unsigned char *tmpdat = NULL, *p = NULL;
	DER_ENC *derlst = NULL, *tder;

	if (do_sort) {
		/* Don't need to sort less than 2 items */
		if (sk_ASN1_VALUE_num(sk) < 2)
			do_sort = 0;
		else {
			derlst = reallocarray(NULL, sk_ASN1_VALUE_num(sk),
			    sizeof(*derlst));
			tmpdat = malloc(skcontlen);
			if (!derlst || !tmpdat) {
				free(derlst);
				free(tmpdat);
				return 0;
			}
		}
	}
	/* If not sorting just output each item */
	if (!do_sort) {
		for (i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
			skitem = sk_ASN1_VALUE_value(sk, i);
			ASN1_item_ex_i2d(&skitem, out, item, -1, iclass);
		}
		return 1;
	}
	p = tmpdat;

	/* Doing sort: build up a list of each member's DER encoding */
	for (i = 0, tder = derlst; i < sk_ASN1_VALUE_num(sk); i++, tder++) {
		skitem = sk_ASN1_VALUE_value(sk, i);
		tder->data = p;
		tder->length = ASN1_item_ex_i2d(&skitem, &p, item, -1, iclass);
		tder->field = skitem;
	}

	/* Now sort them */
	qsort(derlst, sk_ASN1_VALUE_num(sk), sizeof(*derlst), der_cmp);
	/* Output sorted DER encoding */
	p = *out;
	for (i = 0, tder = derlst; i < sk_ASN1_VALUE_num(sk); i++, tder++) {
		memcpy(p, tder->data, tder->length);
		p += tder->length;
	}
	*out = p;
	/* If do_sort is 2 then reorder the STACK */
	if (do_sort == 2) {
		for (i = 0, tder = derlst; i < sk_ASN1_VALUE_num(sk); i++, tder++)
			(void)sk_ASN1_VALUE_set(sk, i, tder->field);
	}
	free(derlst);
	free(tmpdat);
	return 1;
}

static int
asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out,
    const ASN1_ITEM *it, int tag, int aclass)
{
	int len;
	int utype;
	int usetag;
	int ndef = 0;

	utype = it->utype;

	/* Get length of content octets and maybe find
	 * out the underlying type.
	 */

	len = asn1_ex_i2c(pval, NULL, &utype, it);

	/* If SEQUENCE, SET or OTHER then header is
	 * included in pseudo content octets so don't
	 * include tag+length. We need to check here
	 * because the call to asn1_ex_i2c() could change
	 * utype.
	 */
	if ((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||
	    (utype == V_ASN1_OTHER))
		usetag = 0;
	else
		usetag = 1;

	/* -1 means omit type */
	if (len == -1)
		return 0;

	/* -2 return is special meaning use ndef */
	if (len == -2) {
		ndef = 2;
		len = 0;
	}

	/* If not implicitly tagged get tag from underlying type */
	if (tag == -1)
		tag = utype;

	/* Output tag+length followed by content octets */
	if (out) {
		if (usetag)
			ASN1_put_object(out, ndef, len, tag, aclass);
		asn1_ex_i2c(pval, *out, &utype, it);
		if (ndef)
			ASN1_put_eoc(out);
		else
			*out += len;
	}

	if (usetag)
		return ASN1_object_size(ndef, len, tag);
	return len;
}

/* Produce content octets from a structure */

static int
asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cout, int *putype,
    const ASN1_ITEM *it)
{
	ASN1_BOOLEAN *tbool = NULL;
	ASN1_STRING *strtmp;
	ASN1_OBJECT *otmp;
	int utype;
	const unsigned char *cont;
	unsigned char c;
	int len;
	const ASN1_PRIMITIVE_FUNCS *pf;

	pf = it->funcs;
	if (pf && pf->prim_i2c)
		return pf->prim_i2c(pval, cout, putype, it);

	/* Should type be omitted? */
	if ((it->itype != ASN1_ITYPE_PRIMITIVE) ||
	    (it->utype != V_ASN1_BOOLEAN)) {
		if (!*pval)
			return -1;
	}

	if (it->itype == ASN1_ITYPE_MSTRING) {
		/* If MSTRING type set the underlying type */
		strtmp = (ASN1_STRING *)*pval;
		utype = strtmp->type;
		*putype = utype;
	} else if (it->utype == V_ASN1_ANY) {
		/* If ANY set type and pointer to value */
		ASN1_TYPE *typ;
		typ = (ASN1_TYPE *)*pval;
		utype = typ->type;
		*putype = utype;
		pval = &typ->value.asn1_value;
	} else
		utype = *putype;

	switch (utype) {
	case V_ASN1_OBJECT:
		otmp = (ASN1_OBJECT *)*pval;
		cont = otmp->data;
		len = otmp->length;
		break;

	case V_ASN1_NULL:
		cont = NULL;
		len = 0;
		break;

	case V_ASN1_BOOLEAN:
		tbool = (ASN1_BOOLEAN *)pval;
		if (*tbool == -1)
			return -1;
		if (it->utype != V_ASN1_ANY) {
			/* Default handling if value == size field then omit */
			if (*tbool && (it->size > 0))
				return -1;
			if (!*tbool && !it->size)
				return -1;
		}
		c = (unsigned char)*tbool;
		cont = &c;
		len = 1;
		break;

	case V_ASN1_BIT_STRING:
		return i2c_ASN1_BIT_STRING((ASN1_BIT_STRING *)*pval,
		    cout ? &cout : NULL);
		break;

	case V_ASN1_INTEGER:
	case V_ASN1_ENUMERATED:
		/* These are all have the same content format
		 * as ASN1_INTEGER
		 */
		return i2c_ASN1_INTEGER((ASN1_INTEGER *)*pval,
		    cout ? &cout : NULL);
		break;

	case V_ASN1_OCTET_STRING:
	case V_ASN1_NUMERICSTRING:
	case V_ASN1_PRINTABLESTRING:
	case V_ASN1_T61STRING:
	case V_ASN1_VIDEOTEXSTRING:
	case V_ASN1_IA5STRING:
	case V_ASN1_UTCTIME:
	case V_ASN1_GENERALIZEDTIME:
	case V_ASN1_GRAPHICSTRING:
	case V_ASN1_VISIBLESTRING:
	case V_ASN1_GENERALSTRING:
	case V_ASN1_UNIVERSALSTRING:
	case V_ASN1_BMPSTRING:
	case V_ASN1_UTF8STRING:
	case V_ASN1_SEQUENCE:
	case V_ASN1_SET:
	default:
		/* All based on ASN1_STRING and handled the same */
		strtmp = (ASN1_STRING *)*pval;
		/* Special handling for NDEF */
		if ((it->size == ASN1_TFLG_NDEF) &&
		    (strtmp->flags & ASN1_STRING_FLAG_NDEF)) {
			if (cout) {
				strtmp->data = cout;
				strtmp->length = 0;
			}
			/* Special return code */
			return -2;
		}
		cont = strtmp->data;
		len = strtmp->length;

		break;

	}
	if (cout && len)
		memcpy(cout, cont, len);
	return len;
}
@


1.19
log
@revert the big change from yesterday to prepare for smaller commits.
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_enc.c,v 1.18 2016/05/03 12:38:53 tedu Exp $ */
a605 1
	case V_ASN1_NEG_INTEGER:
a606 1
	case V_ASN1_NEG_ENUMERATED:
@


1.18
log
@patch from openssl for multiple issues:
missing padding check in aesni functions
overflow in evp encode functions
use of invalid negative asn.1 types
ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_enc.c,v 1.17 2015/12/22 08:44:44 mmcc Exp $ */
d606 1
d608 1
@


1.17
log
@initialize a pointer to NULL rather than 0
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_enc.c,v 1.16 2015/02/14 15:23:57 miod Exp $ */
a605 1
	case V_ASN1_NEG_INTEGER:
a606 1
	case V_ASN1_NEG_ENUMERATED:
@


1.17.2.1
log
@backport patch from openssl for multiple issues:
missing padding check in aesni functions
overflow in evp encode functions
use of invalid negative asn.1 types
ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_enc.c,v 1.17 2015/12/22 08:44:44 mmcc Exp $ */
d606 1
d608 1
@


1.16
log
@Remove IMPLEMENT_COMPAT_ASN1() and related support code. Nothing uses it in
libcrypto/libssl, and nothing seems to use it in the wild, apart from embedded
copies of OpenSSL.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_enc.c,v 1.15 2015/02/14 15:21:49 miod Exp $ */
d137 1
a137 1
	ASN1_aux_cb *asn1_cb = 0;
@


1.16.6.1
log
@backport patch from openssl for multiple issues:
missing padding check in aesni functions
overflow in evp encode functions
use of invalid negative asn.1 types
ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_enc.c,v 1.16 2015/02/14 15:23:57 miod Exp $ */
d606 1
d608 1
@


1.15
log
@Make asn1_ex_i2c() static. ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_enc.c,v 1.14 2014/07/11 08:44:47 jsing Exp $ */
a133 1
	unsigned char *p = NULL;
a134 1
	const ASN1_COMPAT_FUNCS *cf;
a177 13

	case ASN1_ITYPE_COMPAT:
		/* old style hackery... */
		cf = it->funcs;
		if (out)
			p = *out;
		i = cf->asn1_i2d(*pval, out);
		/* Fixup for IMPLICIT tag: note this messes up for tags > 30,
		 * but so did the old code. Tags > 30 are very rare anyway.
		 */
		if (out && (tag != -1))
			*p = aclass | tag | (*p & V_ASN1_CONSTRUCTED);
		return i;
@


1.14
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_enc.c,v 1.13 2014/06/12 15:49:27 deraadt Exp $ */
d74 2
d548 1
a548 1
int
@


1.13
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d61 1
a61 1
#include "cryptlib.h"
@


1.12
log
@convert 53 malloc(a*b) to reallocarray(NULL, a, b).  that is 53
potential integer overflows easily changed into an allocation return
of NULL, with errno nicely set if need be.  checks for an allocations
returning NULL are commonplace, or if the object is dereferenced
(quite normal) will result in a nice fault which can be detected &
repaired properly.
ok tedu
@
text
@d1 1
a1 1
/* tasn_enc.c */
@


1.11
log
@More KNF.
@
text
@d438 1
a438 1
			derlst = malloc(sk_ASN1_VALUE_num(sk) *
@


1.10
log
@add braces missed when fixing leaks
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
a58 1

d67 1
a67 2
					const ASN1_ITEM *it,
					int tag, int aclass);
d69 1
a69 2
					int skcontlen, const ASN1_ITEM *item,
					int do_sort, int iclass);
d71 1
a71 2
					const ASN1_TEMPLATE *tt,
					int tag, int aclass);
d73 1
a73 1
					const ASN1_ITEM *it, int flags);
d79 2
a80 2
int ASN1_item_ndef_i2d(ASN1_VALUE *val, unsigned char **out,
						const ASN1_ITEM *it)
d85 2
a86 1
int ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it)
d92 1
a92 1
 * standard 'i2d' function. 'out' points to 
d100 3
a102 2
static int asn1_item_flags_i2d(ASN1_VALUE *val, unsigned char **out,
					const ASN1_ITEM *it, int flags)
d127 3
a129 2
int ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
			const ASN1_ITEM *it, int tag, int aclass)
d143 1
a143 1
		 asn1_cb = aux->asn1_cb;
d145 1
a145 1
	switch(it->itype) {
d150 1
a150 1
								tag, aclass);
d159 1
a159 1
				return 0;
d167 1
a167 1
								-1, aclass);
d171 1
a171 1
				return 0;
d191 1
a191 1
		
d194 2
a195 1
		if (aclass & ASN1_TFLG_NDEF) ndef = 2;
d212 2
a213 2
			aclass = (aclass & ~ASN1_TFLG_TAG_CLASS)
					| V_ASN1_UNIVERSAL;
d216 1
a216 1
				return 0;
d227 1
a227 1
								-1, aclass);
d248 1
a248 1
				return 0;
d251 1
a251 1
		default:
d258 3
a260 2
int ASN1_template_i2d(ASN1_VALUE **pval, unsigned char **out,
							const ASN1_TEMPLATE *tt)
d265 3
a267 2
static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
				const ASN1_TEMPLATE *tt, int tag, int iclass)
d293 1
a293 1
	/* 
d306 2
a307 1
	else ndef = 1;
d324 2
a325 2
		}
		else isset = 0;
d337 2
a338 1
			else sktag = V_ASN1_SEQUENCE;
d346 1
a346 2
						ASN1_ITEM_ptr(tt->item),
							-1, iclass);
d352 2
a353 1
		else ret = sklen;
d366 1
a366 1
								isset, iclass);
d380 1
a380 1
								-1, iclass);
d389 1
a389 1
								-1, iclass);
d398 1
a398 2
						ttag, tclass | iclass);

d409 2
a410 1
static int der_cmp(const void *a, const void *b)
d414 1
d424 3
a426 3
static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
					int skcontlen, const ASN1_ITEM *item,
					int do_sort, int iclass)
d432 2
a433 2
	if (do_sort)
		 {
d438 2
a439 2
			derlst = malloc(sk_ASN1_VALUE_num(sk)
						* sizeof(*derlst));
d468 1
a468 1
	/* Output sorted DER encoding */	
d485 3
a487 2
static int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out,
				const ASN1_ITEM *it, int tag, int aclass)
d509 1
a509 1
	   (utype == V_ASN1_OTHER))
d511 2
a512 1
	else usetag = 1;
a514 1

d525 2
a526 1
	if (tag == -1) tag = utype;
d546 3
a548 2
int asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cout, int *putype,
				const ASN1_ITEM *it)
d558 1
d564 4
a567 2
	if ((it->itype != ASN1_ITYPE_PRIMITIVE) || (it->utype != V_ASN1_BOOLEAN)) {
		if (!*pval) return -1;
d582 2
a583 2
	}
	else utype = *putype;
d585 1
a585 1
	switch(utype) {
d615 1
a615 1
							cout ? &cout : NULL);
d626 1
a626 1
							cout ? &cout : NULL);
d649 2
a650 2
		if ((it->size == ASN1_TFLG_NDEF)
			&& (strtmp->flags & ASN1_STRING_FLAG_NDEF)) {
@


1.9
log
@lob a few more knf grenades in here to soften things up.
@
text
@d436 1
a436 1
			if (!derlst || !tmpdat)
d440 1
@


1.8
log
@putting most of the braces in the right column is the very least we can do.
@
text
@d106 1
a106 2
	if (out && !*out)
	{
d146 1
a146 2
	switch(it->itype)
	{
d148 1
a148 1
		case ASN1_ITYPE_PRIMITIVE:
d155 1
a155 1
		case ASN1_ITYPE_MSTRING:
d158 1
a158 1
		case ASN1_ITYPE_CHOICE:
d162 1
a162 2
		if ((i >= 0) && (i < it->tcount))
		{
d175 1
a175 1
		case ASN1_ITYPE_EXTERN:
d180 1
a180 1
		case ASN1_ITYPE_COMPAT:
d193 1
a193 1
		case ASN1_ITYPE_NDEF_SEQUENCE:
d198 1
a198 1
		case ASN1_ITYPE_SEQUENCE:
d209 1
a209 2
		if (tag == -1)
		{
d218 1
a218 2
		for (i = 0, tt = it->templates; i < it->tcount; tt++, i++)
		{
d235 1
a235 2
		for (i = 0, tt = it->templates; i < it->tcount; tt++, i++)
		{
d275 1
a275 2
	if (flags & ASN1_TFLG_TAG_MASK)
	{
d283 1
a283 3
	}
	else if (tag != -1)
	{
d287 1
a287 3
	}
	else
	{
d306 1
a306 2
	if (flags & ASN1_TFLG_SK_MASK)
	{
d316 1
a316 2
		if (flags & ASN1_TFLG_SET_OF)
		{
d327 1
a327 2
		if ((ttag != -1) && !(flags & ASN1_TFLG_EXPTAG))
		{
d330 1
a330 3
		}
		else
		{
d339 1
a339 2
		for (i = 0; i < sk_ASN1_VALUE_num(sk); i++)
		{
d363 1
a363 2
		if (ndef == 2)
		{
d372 1
a372 2
	if (flags & ASN1_TFLG_EXPTAG)
	{
d381 1
a381 2
		if (out)
		{
d432 1
a432 2
		else
		{
d443 2
a444 4
	if (!do_sort)
	{
		for (i = 0; i < sk_ASN1_VALUE_num(sk); i++)
		{
d453 1
a453 2
	for (i = 0, tder = derlst; i < sk_ASN1_VALUE_num(sk); i++, tder++)
	{
d464 1
a464 2
	for (i = 0, tder = derlst; i < sk_ASN1_VALUE_num(sk); i++, tder++)
	{
d470 2
a471 4
	if (do_sort == 2)
	{
		for (i = 0, tder = derlst; i < sk_ASN1_VALUE_num(sk);
							i++, tder++)
d512 1
a512 2
	if (len == -2)
	{
d521 1
a521 2
	if (out)
	{
d554 1
a554 3
	if ((it->itype != ASN1_ITYPE_PRIMITIVE)
		|| (it->utype != V_ASN1_BOOLEAN))
	{
d558 1
a558 2
	if (it->itype == ASN1_ITYPE_MSTRING)
	{
d563 1
a563 3
	}
	else if (it->utype == V_ASN1_ANY)
	{
d573 2
a574 3
	switch(utype)
	{
		case V_ASN1_OBJECT:
d580 1
a580 1
		case V_ASN1_NULL:
d585 1
a585 1
		case V_ASN1_BOOLEAN:
d589 1
a589 2
		if (it->utype != V_ASN1_ANY)
		{
d601 1
a601 1
		case V_ASN1_BIT_STRING:
d606 4
a609 4
		case V_ASN1_INTEGER:
		case V_ASN1_NEG_INTEGER:
		case V_ASN1_ENUMERATED:
		case V_ASN1_NEG_ENUMERATED:
d617 17
a633 17
		case V_ASN1_OCTET_STRING:
		case V_ASN1_NUMERICSTRING:
		case V_ASN1_PRINTABLESTRING:
		case V_ASN1_T61STRING:
		case V_ASN1_VIDEOTEXSTRING:
		case V_ASN1_IA5STRING:
		case V_ASN1_UTCTIME:
		case V_ASN1_GENERALIZEDTIME:
		case V_ASN1_GRAPHICSTRING:
		case V_ASN1_VISIBLESTRING:
		case V_ASN1_GENERALSTRING:
		case V_ASN1_UNIVERSALSTRING:
		case V_ASN1_BMPSTRING:
		case V_ASN1_UTF8STRING:
		case V_ASN1_SEQUENCE:
		case V_ASN1_SET:
		default:
d638 2
a639 4
			&& (strtmp->flags & ASN1_STRING_FLAG_NDEF))
		{
			if (cout)
			{
@


1.7
log
@fix some more leaks, mostly suggestions from miod
ok miod@@
@
text
@d85 1
a85 1
	{
d87 1
a87 1
	}
d90 1
a90 1
	{
d92 1
a92 1
	}
d105 2
a107 2
	if (out && !*out)
		{
d120 1
a120 1
		}
d123 1
a123 1
	}
d132 1
a132 1
	{
d148 1
a148 1
		{
d165 1
a165 1
			{
d172 1
a172 1
			}
d213 1
a213 1
			{
d218 1
a218 1
			}
d223 1
a223 1
			{
d233 1
a233 1
			}
d241 1
a241 1
			{
d250 1
a250 1
			}
d260 1
a260 1
		}
d262 1
a262 1
	}
d266 1
a266 1
	{
d268 1
a268 1
	}
d272 1
a272 1
	{
d282 1
a282 1
		{
d290 1
a290 1
		}
d292 1
a292 1
		{
d296 1
a296 1
		}
d298 1
a298 1
		{
d301 1
a301 1
		}
d318 1
a318 1
		{
d329 1
a329 1
			{
d334 1
a334 1
			}
d341 1
a341 1
			{
d344 1
a344 1
			}
d346 1
a346 1
			{
d351 1
a351 1
			}
d356 1
a356 1
			{
d361 1
a361 1
			}
d381 1
a381 1
			{
d385 1
a385 1
			}
d388 1
a388 1
		}
d391 1
a391 1
		{
d401 1
a401 1
			{
d408 1
a408 1
			}
d410 1
a410 1
		}
d427 1
a427 1
	{
d435 1
a435 1
	}
d442 1
a442 1
	{
d453 1
a453 1
			{
a460 1
			}
d462 1
d465 2
a467 2
		for (i = 0; i < sk_ASN1_VALUE_num(sk); i++)
			{
d470 1
a470 1
			}
d472 1
a472 1
		}
d477 1
a477 1
		{
d482 1
a482 1
		}
d489 1
a489 1
		{
d492 1
a492 1
		}
d496 1
a496 1
		{
d500 1
a500 1
		}
d504 1
a504 1
	}
d508 1
a508 1
	{
d540 1
a540 1
		{
d543 1
a543 1
		}
d550 1
a550 1
		{
d558 1
a558 1
		}
d563 1
a563 1
	}
d569 1
a569 1
	{
d585 1
a585 1
		{
d587 1
a587 1
		}
d590 1
a590 1
		{
d595 1
a595 1
		}
d597 1
a597 1
		{
d604 1
a604 1
		}
d608 1
a608 1
		{
d625 1
a625 1
			{
d631 1
a631 1
			}
d675 2
a677 2
			if (cout)
				{
d680 1
a680 1
				}
d683 1
a683 1
			}
d689 1
a689 1
		}
d693 1
a693 1
	}
@


1.6
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d458 2
@


1.5
log
@resolve conflicts, fix local changes
@
text
@d113 1
a113 1
		buf = OPENSSL_malloc(len);
d454 1
a454 1
			derlst = OPENSSL_malloc(sk_ASN1_VALUE_num(sk)
d456 1
a456 1
			tmpdat = OPENSSL_malloc(skcontlen);
d499 2
a500 2
	OPENSSL_free(derlst);
	OPENSSL_free(tmpdat);
@


1.4
log
@resolve conflicts
@
text
@d161 1
a161 1
		if (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it))
d174 1
a174 1
		if (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it))
d219 1
a219 1
		if (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it))
d253 1
a253 1
		if (asn1_cb  && !asn1_cb(ASN1_OP_I2D_POST, pval, it))
d572 2
a573 1
	unsigned char *cont, c;
@


1.3
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.2
log
@resolve conflicts
@
text
@d6 1
a6 1
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
d62 1
d67 11
a77 2
static int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out, const ASN1_ITEM *it, int tag, int aclass);
static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *seq, unsigned char **out, int skcontlen, const ASN1_ITEM *item, int isset);
d79 16
a94 1
/* Encode an ASN1 item, this is compatible with the
d96 1
a96 4
 * a buffer to output the data to, in future we will
 * have more advanced versions that can output data
 * a piece at a time and this will simply be a special
 * case.
d103 5
a107 4

int ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it)
{
	if(out && !*out) {
d110 3
a112 2
		len = ASN1_item_ex_i2d(&val, NULL, it, -1, 0);
		if(len <= 0) return len;
d114 2
a115 1
		if(!buf) return -1;
d117 1
a117 1
		ASN1_item_ex_i2d(&val, &p, it, -1, 0);
d120 3
a123 3
		
	return ASN1_item_ex_i2d(&val, out, it, -1, 0);
}
d130 3
a132 2
int ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned char **out, const ASN1_ITEM *it, int tag, int aclass)
{
d135 1
a135 2
	int i, seqcontlen, seqlen;
	ASN1_STRING *strtmp;
d139 7
a145 4
	ASN1_aux_cb *asn1_cb;
	if((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) return 0;
	if(aux && aux->asn1_cb) asn1_cb = aux->asn1_cb;
	else asn1_cb = 0;
d147 2
a148 1
	switch(it->itype) {
d151 3
a153 2
		if(it->templates)
			return ASN1_template_i2d(pval, out, it->templates);
d158 1
a158 2
		strtmp = (ASN1_STRING *)*pval;
		return asn1_i2d_ex_primitive(pval, out, it, -1, 0);
d161 1
a161 1
		if(asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it))
d164 2
a165 1
		if((i >= 0) && (i < it->tcount)) {
d170 3
a172 2
			return ASN1_template_i2d(pchval, out, chtt);
		} 
d174 1
a174 1
		if(asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it))
d186 2
a187 1
		if(out) p = *out;
d192 1
a192 1
		if(out && (tag != -1))
d196 5
d204 2
a205 1
		if(i < 0) return 0;
d207 2
a208 1
		if(i > 0) return seqcontlen;
d212 2
a213 1
		if(tag == -1) {
d215 5
a219 3
			aclass = V_ASN1_UNIVERSAL;
		}
		if(asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it))
d222 2
a223 1
		for(i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
d227 2
a228 1
			if(!seqtt) return 0;
d231 7
a237 5
			/* FIXME: special handling of indefinite length encoding */
			seqcontlen += ASN1_template_i2d(pseqval, NULL, seqtt);
		}
		seqlen = ASN1_object_size(1, seqcontlen, tag);
		if(!out) return seqlen;
d239 3
a241 2
		ASN1_put_object(out, 1, seqcontlen, tag, aclass);
		for(i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
d245 2
a246 1
			if(!seqtt) return 0;
d249 5
a253 3
			ASN1_template_i2d(pseqval, out, seqtt);
		}
		if(asn1_cb  && !asn1_cb(ASN1_OP_I2D_POST, pval, it))
d259 9
a268 2
	return 0;
}
d270 4
a273 3
int ASN1_template_i2d(ASN1_VALUE **pval, unsigned char **out, const ASN1_TEMPLATE *tt)
{
	int i, ret, flags, aclass;
d275 44
a318 2
	aclass = flags & ASN1_TFLG_TAG_CLASS;
	if(flags & ASN1_TFLG_SK_MASK) {
d324 6
a329 2
		if(!*pval) return 0;
		if(flags & ASN1_TFLG_SET_OF) {
d332 15
a346 7
			if(flags & ASN1_TFLG_SEQUENCE_OF) isset = 2;
		} else isset = 0;
		/* First work out inner tag value */
		if(flags & ASN1_TFLG_IMPTAG) {
			sktag = tt->tag;
			skaclass = aclass;
		} else {
d348 2
a349 1
			if(isset) sktag = V_ASN1_SET;
d351 3
a353 2
		}
		/* Now work out length of items */
d355 2
a356 1
		for(i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
d358 5
a362 3
			skcontlen += ASN1_item_ex_i2d(&skitem, NULL, ASN1_ITEM_ptr(tt->item), -1, 0);
		}
		sklen = ASN1_object_size(1, skcontlen, sktag);
d364 2
a365 2
		if(flags & ASN1_TFLG_EXPTAG)
			ret = ASN1_object_size(1, sklen, tt->tag);
d368 2
a369 1
		if(!out) return ret;
d373 2
a374 2
		if(flags & ASN1_TFLG_EXPTAG)
			ASN1_put_object(out, 1, sklen, tt->tag, aclass);
d376 10
a385 3
		ASN1_put_object(out, 1, skcontlen, sktag, skaclass);
		/* And finally the stuff itself */
		asn1_set_seq_out(sk, out, skcontlen, ASN1_ITEM_ptr(tt->item), isset);
d388 4
a391 3
	}
			
	if(flags & ASN1_TFLG_EXPTAG) {
d394 4
a397 2
		i = ASN1_item_ex_i2d(pval, NULL, ASN1_ITEM_ptr(tt->item), -1, 0);
		if(!i) return 0;
d399 3
a401 2
		ret = ASN1_object_size(1, i, tt->tag);
		if(out) {
d403 7
a409 2
			ASN1_put_object(out, 1, i, tt->tag, aclass);
			ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item), -1, 0);
d411 5
a415 8
		return ret;
	}
	if(flags & ASN1_TFLG_IMPTAG) {
		/* IMPLICIT tagging */
		return ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item), tt->tag, aclass);
	}
	/* Nothing special: treat as normal */
	return ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item), -1, 0);
d427 1
a427 1
{
d432 2
a433 1
	if(i) return i;
d435 1
a435 1
}
d439 4
a442 2
static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out, int skcontlen, const ASN1_ITEM *item, int do_sort)
{
d447 2
a448 1
	if(do_sort) {
d450 6
a455 3
		if(sk_ASN1_VALUE_num(sk) < 2) do_sort = 0;
		else {
			derlst = OPENSSL_malloc(sk_ASN1_VALUE_num(sk) * sizeof(*derlst));
d457 3
a459 1
			if(!derlst || !tmpdat) return 0;
a460 1
	}
d462 4
a465 2
	if(!do_sort) {
		for(i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
d467 3
a469 1
			ASN1_item_i2d(skitem, out, item);
a470 2
		return 1;
	}
d472 1
d474 2
a475 1
	for(i = 0, tder = derlst; i < sk_ASN1_VALUE_num(sk); i++, tder++) {
d478 1
a478 1
		tder->length = ASN1_item_i2d(skitem, &p, item);
d480 2
a481 1
	}
d486 2
a487 1
	for(i = 0, tder = derlst; i < sk_ASN1_VALUE_num(sk); i++, tder++) {
d490 1
a490 1
	}
d493 6
a498 4
	if(do_sort == 2) {
		for(i = 0, tder = derlst; i < sk_ASN1_VALUE_num(sk); i++, tder++)
			sk_ASN1_VALUE_set(sk, i, tder->field);
	}
d502 1
a502 1
}
d504 3
a506 2
static int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out, const ASN1_ITEM *it, int tag, int aclass)
{
d510 1
d526 1
a526 1
	if((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||
d533 9
a541 1
	if(len == -1) return 0;
d544 1
a544 1
	if(tag == -1) tag = utype;
d547 4
a550 2
	if(out) {
		if(usetag) ASN1_put_object(out, 0, len, tag, aclass);
d552 5
a556 2
		*out += len;
	}
d558 2
a559 1
	if(usetag) return ASN1_object_size(0, len, tag);
d561 1
a561 1
}
d565 3
a567 2
int asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cout, int *putype, const ASN1_ITEM *it)
{
d576 2
a577 1
	if(pf && pf->prim_i2c) return pf->prim_i2c(pval, cout, putype, it);
d580 5
a584 3
	if((it->itype != ASN1_ITYPE_PRIMITIVE) || (it->utype != V_ASN1_BOOLEAN)) {
		if(!*pval) return -1;
	}
d586 2
a587 1
	if(it->itype == ASN1_ITYPE_MSTRING) {
d592 3
a594 1
	} else if(it->utype == V_ASN1_ANY) {
d600 3
a602 2
		pval = (ASN1_VALUE **)&typ->value.ptr;
	} else utype = *putype;
d604 2
a605 1
	switch(utype) {
d619 2
a620 1
		if(*tbool == -1) return -1;
d624 4
a627 2
			if(*tbool && (it->size > 0)) return -1;
			if(!*tbool && !it->size) return -1;
d635 2
a636 1
		return i2c_ASN1_BIT_STRING((ASN1_BIT_STRING *)*pval, cout ? &cout : NULL);
d646 2
a647 1
		return i2c_ASN1_INTEGER((ASN1_INTEGER *)*pval, cout ? &cout : NULL);
d669 12
d686 4
a690 3
	if(cout && len) memcpy(cout, cont, len);
	return len;
}
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d448 6
a453 3
		/* Default handling if value == size field then omit */
		if(*tbool && (it->size > 0)) return -1;
		if(!*tbool && !it->size) return -1;
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import of openssl-0.9.7j
@
text
@d448 3
a450 6
		if (it->utype != V_ASN1_ANY)
			{
			/* Default handling if value == size field then omit */
			if(*tbool && (it->size > 0)) return -1;
			if(!*tbool && !it->size) return -1;
			}
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d6 1
a6 1
 * Copyright (c) 2000-2004 The OpenSSL Project.  All rights reserved.
a61 1
#include "cryptlib.h"
d66 2
a67 11
static int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out,
					const ASN1_ITEM *it,
					int tag, int aclass);
static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
					int skcontlen, const ASN1_ITEM *item,
					int do_sort, int iclass);
static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
					const ASN1_TEMPLATE *tt,
					int tag, int aclass);
static int asn1_item_flags_i2d(ASN1_VALUE *val, unsigned char **out,
					const ASN1_ITEM *it, int flags);
d69 1
a69 16
/* Top level i2d equivalents: the 'ndef' variant instructs the encoder
 * to use indefinite length constructed encoding, where appropriate
 */

int ASN1_item_ndef_i2d(ASN1_VALUE *val, unsigned char **out,
						const ASN1_ITEM *it)
	{
	return asn1_item_flags_i2d(val, out, it, ASN1_TFLG_NDEF);
	}

int ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it)
	{
	return asn1_item_flags_i2d(val, out, it, 0);
	}

/* Encode an ASN1 item, this is use by the
d71 4
a74 1
 * a buffer to output the data to.
d81 4
a84 5
static int asn1_item_flags_i2d(ASN1_VALUE *val, unsigned char **out,
					const ASN1_ITEM *it, int flags)
	{
	if (out && !*out)
		{
d87 2
a88 3
		len = ASN1_item_ex_i2d(&val, NULL, it, -1, flags);
		if (len <= 0)
			return len;
d90 1
a90 2
		if (!buf)
			return -1;
d92 1
a92 1
		ASN1_item_ex_i2d(&val, &p, it, -1, flags);
a94 3
		}

	return ASN1_item_ex_i2d(&val, out, it, -1, flags);
d96 3
d105 2
a106 3
int ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
			const ASN1_ITEM *it, int tag, int aclass)
	{
d109 2
a110 1
	int i, seqcontlen, seqlen, ndef = 1;
d114 4
a117 7
	ASN1_aux_cb *asn1_cb = 0;

	if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval)
		return 0;

	if (aux && aux->asn1_cb)
		 asn1_cb = aux->asn1_cb;
d119 1
a119 2
	switch(it->itype)
		{
d122 2
a123 3
		if (it->templates)
			return asn1_template_ex_i2d(pval, out, it->templates,
								tag, aclass);
d128 2
a129 1
		return asn1_i2d_ex_primitive(pval, out, it, -1, aclass);
d132 1
a132 1
		if (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it))
d135 1
a135 2
		if ((i >= 0) && (i < it->tcount))
			{
d140 2
a141 3
			return asn1_template_ex_i2d(pchval, out, chtt,
								-1, aclass);
			}
d143 1
a143 1
		if (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it))
d155 1
a155 2
		if (out)
			p = *out;
d160 1
a160 1
		if (out && (tag != -1))
a163 5
		case ASN1_ITYPE_NDEF_SEQUENCE:
		/* Use indefinite length constructed if requested */
		if (aclass & ASN1_TFLG_NDEF) ndef = 2;
		/* fall through */

d167 1
a167 2
		if (i < 0)
			return 0;
d169 1
a169 2
		if (i > 0)
			return seqcontlen;
d173 1
a173 2
		if (tag == -1)
			{
d175 3
a177 5
			/* Retain any other flags in aclass */
			aclass = (aclass & ~ASN1_TFLG_TAG_CLASS)
					| V_ASN1_UNIVERSAL;
			}
		if (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it))
d180 1
a180 2
		for (i = 0, tt = it->templates; i < it->tcount; tt++, i++)
			{
d184 1
a184 2
			if (!seqtt)
				return 0;
d187 5
a191 7
			seqcontlen += asn1_template_ex_i2d(pseqval, NULL, seqtt,
								-1, aclass);
			}

		seqlen = ASN1_object_size(ndef, seqcontlen, tag);
		if (!out)
			return seqlen;
d193 2
a194 3
		ASN1_put_object(out, ndef, seqcontlen, tag, aclass);
		for (i = 0, tt = it->templates; i < it->tcount; tt++, i++)
			{
d198 1
a198 2
			if (!seqtt)
				return 0;
d201 3
a203 5
			asn1_template_ex_i2d(pseqval, out, seqtt, -1, aclass);
			}
		if (ndef == 2)
			ASN1_put_eoc(out);
		if (asn1_cb  && !asn1_cb(ASN1_OP_I2D_POST, pval, it))
d209 1
a209 2

		}
d211 1
a211 1
	}
d213 3
a215 10
int ASN1_template_i2d(ASN1_VALUE **pval, unsigned char **out,
							const ASN1_TEMPLATE *tt)
	{
	return asn1_template_ex_i2d(pval, out, tt, -1, 0);
	}

static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
				const ASN1_TEMPLATE *tt, int tag, int iclass)
	{
	int i, ret, flags, ttag, tclass, ndef;
d217 2
a218 44
	/* Work out tag and class to use: tagging may come
	 * either from the template or the arguments, not both
	 * because this would create ambiguity. Additionally
	 * the iclass argument may contain some additional flags
	 * which should be noted and passed down to other levels.
	 */
	if (flags & ASN1_TFLG_TAG_MASK)
		{
		/* Error if argument and template tagging */
		if (tag != -1)
			/* FIXME: error code here */
			return -1;
		/* Get tagging from template */
		ttag = tt->tag;
		tclass = flags & ASN1_TFLG_TAG_CLASS;
		}
	else if (tag != -1)
		{
		/* No template tagging, get from arguments */
		ttag = tag;
		tclass = iclass & ASN1_TFLG_TAG_CLASS;
		}
	else
		{
		ttag = -1;
		tclass = 0;
		}
	/* 
	 * Remove any class mask from iflag.
	 */
	iclass &= ~ASN1_TFLG_TAG_CLASS;

	/* At this point 'ttag' contains the outer tag to use,
	 * 'tclass' is the class and iclass is any flags passed
	 * to this function.
	 */

	/* if template and arguments require ndef, use it */
	if ((flags & ASN1_TFLG_NDEF) && (iclass & ASN1_TFLG_NDEF))
		ndef = 2;
	else ndef = 1;

	if (flags & ASN1_TFLG_SK_MASK)
		{
d224 2
a225 6

		if (!*pval)
			return 0;

		if (flags & ASN1_TFLG_SET_OF)
			{
d228 7
a234 15
			if (flags & ASN1_TFLG_SEQUENCE_OF)
				isset = 2;
			}
		else isset = 0;

		/* Work out inner tag value: if EXPLICIT
		 * or no tagging use underlying type.
		 */
		if ((ttag != -1) && !(flags & ASN1_TFLG_EXPTAG))
			{
			sktag = ttag;
			skaclass = tclass;
			}
		else
			{
d236 1
a236 2
			if (isset)
				sktag = V_ASN1_SET;
d238 2
a239 3
			}

		/* Determine total length of items */
d241 1
a241 2
		for (i = 0; i < sk_ASN1_VALUE_num(sk); i++)
			{
d243 3
a245 5
			skcontlen += ASN1_item_ex_i2d(&skitem, NULL,
						ASN1_ITEM_ptr(tt->item),
							-1, iclass);
			}
		sklen = ASN1_object_size(ndef, skcontlen, sktag);
d247 2
a248 2
		if (flags & ASN1_TFLG_EXPTAG)
			ret = ASN1_object_size(ndef, sklen, ttag);
d251 1
a251 2
		if (!out)
			return ret;
d255 2
a256 2
		if (flags & ASN1_TFLG_EXPTAG)
			ASN1_put_object(out, ndef, sklen, ttag, tclass);
d258 3
a260 10
		ASN1_put_object(out, ndef, skcontlen, sktag, skaclass);
		/* And the stuff itself */
		asn1_set_seq_out(sk, out, skcontlen, ASN1_ITEM_ptr(tt->item),
								isset, iclass);
		if (ndef == 2)
			{
			ASN1_put_eoc(out);
			if (flags & ASN1_TFLG_EXPTAG)
				ASN1_put_eoc(out);
			}
d263 3
a265 4
		}

	if (flags & ASN1_TFLG_EXPTAG)
		{
d268 2
a269 4
		i = ASN1_item_ex_i2d(pval, NULL, ASN1_ITEM_ptr(tt->item),
								-1, iclass);
		if (!i)
			return 0;
d271 2
a272 3
		ret = ASN1_object_size(ndef, i, ttag);
		if (out)
			{
d274 3
a276 6
			ASN1_put_object(out, ndef, i, ttag, tclass);
			ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item),
								-1, iclass);
			if (ndef == 2)
				ASN1_put_eoc(out);
			}
d278 7
a284 6
		}

	/* Either normal or IMPLICIT tagging: combine class and flags */
	return ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item),
						ttag, tclass | iclass);

d296 1
a296 1
	{
d301 1
a301 2
	if (i)
		return i;
d303 1
a303 1
	}
d307 2
a308 4
static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
					int skcontlen, const ASN1_ITEM *item,
					int do_sort, int iclass)
	{
d313 1
a313 2
	if (do_sort)
		 {
d315 3
a317 6
		if (sk_ASN1_VALUE_num(sk) < 2)
			do_sort = 0;
		else
			{
			derlst = OPENSSL_malloc(sk_ASN1_VALUE_num(sk)
						* sizeof(*derlst));
d319 1
a319 3
			if (!derlst || !tmpdat)
				return 0;
			}
d321 1
d323 2
a324 4
	if (!do_sort)
		{
		for (i = 0; i < sk_ASN1_VALUE_num(sk); i++)
			{
d326 2
a327 2
			ASN1_item_ex_i2d(&skitem, out, item, -1, iclass);
			}
d329 1
a329 1
		}
a330 1

d332 1
a332 2
	for (i = 0, tder = derlst; i < sk_ASN1_VALUE_num(sk); i++, tder++)
		{
d335 1
a335 1
		tder->length = ASN1_item_ex_i2d(&skitem, &p, item, -1, iclass);
d337 1
a337 2
		}

d342 1
a342 2
	for (i = 0, tder = derlst; i < sk_ASN1_VALUE_num(sk); i++, tder++)
		{
d345 1
a345 1
		}
d348 4
a351 6
	if (do_sort == 2)
		{
		for (i = 0, tder = derlst; i < sk_ASN1_VALUE_num(sk);
							i++, tder++)
			(void)sk_ASN1_VALUE_set(sk, i, tder->field);
		}
d355 1
a355 1
	}
d357 2
a358 3
static int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out,
				const ASN1_ITEM *it, int tag, int aclass)
	{
a361 1
	int ndef = 0;
d377 1
a377 1
	if ((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||
d384 1
a384 9
	if (len == -1)
		return 0;

	/* -2 return is special meaning use ndef */
	if (len == -2)
		{
		ndef = 2;
		len = 0;
		}
d387 1
a387 1
	if (tag == -1) tag = utype;
d390 2
a391 4
	if (out)
		{
		if (usetag)
			ASN1_put_object(out, ndef, len, tag, aclass);
d393 2
a394 5
		if (ndef)
			ASN1_put_eoc(out);
		else
			*out += len;
		}
d396 1
a396 2
	if (usetag)
		return ASN1_object_size(ndef, len, tag);
d398 1
a398 1
	}
d402 2
a403 3
int asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cout, int *putype,
				const ASN1_ITEM *it)
	{
d412 1
a412 2
	if (pf && pf->prim_i2c)
		return pf->prim_i2c(pval, cout, putype, it);
d415 3
a417 5
	if ((it->itype != ASN1_ITYPE_PRIMITIVE)
		|| (it->utype != V_ASN1_BOOLEAN))
		{
		if (!*pval) return -1;
		}
d419 1
a419 2
	if (it->itype == ASN1_ITYPE_MSTRING)
		{
d424 1
a424 3
		}
	else if (it->utype == V_ASN1_ANY)
		{
d430 2
a431 3
		pval = &typ->value.asn1_value;
		}
	else utype = *putype;
d433 1
a433 2
	switch(utype)
		{
d447 1
a447 2
		if (*tbool == -1)
			return -1;
d451 2
a452 4
			if (*tbool && (it->size > 0))
				return -1;
			if (!*tbool && !it->size)
				return -1;
d460 1
a460 2
		return i2c_ASN1_BIT_STRING((ASN1_BIT_STRING *)*pval,
							cout ? &cout : NULL);
d470 1
a470 2
		return i2c_ASN1_INTEGER((ASN1_INTEGER *)*pval,
							cout ? &cout : NULL);
a491 12
		/* Special handling for NDEF */
		if ((it->size == ASN1_TFLG_NDEF)
			&& (strtmp->flags & ASN1_STRING_FLAG_NDEF))
			{
			if (cout)
				{
				strtmp->data = cout;
				strtmp->length = 0;
				}
			/* Special return code */
			return -2;
			}
d497 2
a498 3
		}
	if (cout && len)
		memcpy(cout, cont, len);
d500 1
a500 1
	}
@


1.1.1.4
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@d161 1
a161 1
		if (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))
d174 1
a174 1
		if (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))
d219 1
a219 1
		if (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))
d253 1
a253 1
		if (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))
d572 1
a572 2
	const unsigned char *cont;
	unsigned char c;
@


