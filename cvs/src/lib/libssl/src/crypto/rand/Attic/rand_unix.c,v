head	1.12;
access;
symbols
	butholakala:1.10
	openssl_1_0_1_g:1.1.1.9
	OPENBSD_5_5:1.10.0.12
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.8
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.6
	OPENBSD_5_3_BASE:1.10
	openssl_1_0_1_c:1.1.1.9
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	openssl_1_0_0_f:1.1.1.9
	openssl_1_0_0_e:1.1.1.8
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	openssh_1_0_0_a:1.1.1.8
	OPENBSD_4_8:1.8.0.6
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	openssl_0_9_8_k:1.1.1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	openssl_0_9_8_j:1.1.1.6
	openssl_0_9_8_h:1.1.1.6
	pre_openssl_0_9_8h:1.5
	OPENBSD_4_4:1.5.0.14
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.12
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.10
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.8
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.6
	OPENBSD_4_0_BASE:1.5
	openssl_0_9_7j:1.1.1.5
	openssl:1.1.1
	OPENBSD_3_9:1.5.0.4
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENSSL_0_9_7C:1.1.1.3
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.04.18.13.19.03;	author tedu;	state dead;
branches;
next	1.11;

1.11
date	2014.04.15.16.52.50;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2012.01.05.23.01.39;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.06.06.33.20;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.10.05.38.04;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.29.05.39.25;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.12.02.18.38;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.17.20.15.03;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.10.16.31.55;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.16;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.48;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.22.40.53;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.35.43;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.04.07.20.41.49;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.15;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.46;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.04.06.06.30.04;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2012.01.05.22.59.01;	author djm;	state Exp;
branches;
next	;


desc
@@


1.12
log
@another round of chemo for the RAND code to provide clarity.
ok deraadt
@
text
@/* crypto/rand/rand_unix.c */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
#include "e_os.h"
#include "cryptlib.h"
#include <openssl/rand.h>

#include <stdlib.h>
#include <string.h>

int RAND_poll(void)
{
	return 1;
}
@


1.11
log
@Replace the old OpenSSL PRNG by direct use of arc4random_buf(), keeping the
existing RAND interfaces unchanged.

All interfaces allowing external feed or seed of the RNG (either from a file
or a local entropy gathering daemon) are kept for ABI compatibility, but are
no longer do anything.

While the OpenSSL PRNG was required 15+ years ago when many systems lacked
proper entropy collection, things have evolved and one can reasonably assume
it is better to use the kernel (system global) entropy pool rather than trying
to build one's own and having to compensate for thread scheduling...

<RANT>
Whoever thought that RAND_screen(), feeding the PRNG with the contents of the
local workstation's display, under Win32, was a smart idea, ought to be banned
from security programming.
</RANT>

ok beck@@ deraadt@@ tedu@@
@
text
@@


1.10
log
@OpenSSL 1.0.0f: merge
@
text
@a110 3
#include <stdio.h>

#define USE_SOCKETS
a113 60
#include "rand_lcl.h"

#if !(defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_VXWORKS) || defined(OPENSSL_SYS_NETWARE))

#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>
#if defined(OPENSSL_SYS_LINUX) /* should actually be available virtually everywhere */
# include <poll.h>
#endif
#include <limits.h>
#ifndef FD_SETSIZE
# define FD_SETSIZE (8*sizeof(fd_set))
#endif

#if defined(OPENSSL_SYS_VOS)

/* The following algorithm repeatedly samples the real-time clock
   (RTC) to generate a sequence of unpredictable data.  The algorithm
   relies upon the uneven execution speed of the code (due to factors
   such as cache misses, interrupts, bus activity, and scheduling) and
   upon the rather large relative difference between the speed of the
   clock and the rate at which it can be read.

   If this code is ported to an environment where execution speed is
   more constant or where the RTC ticks at a much slower rate, or the
   clock can be read with fewer instructions, it is likely that the
   results would be far more predictable.

   As a precaution, we generate 4 times the minimum required amount of
   seed data.  */

int RAND_poll(void)
{
	short int code;
	gid_t curr_gid;
	pid_t curr_pid;
	uid_t curr_uid;
	int i, k;
	struct timespec ts;
	unsigned char v;

#ifdef OPENSSL_SYS_VOS_HPPA
	long duration;
	extern void s$sleep (long *_duration, short int *_code);
#else
#ifdef OPENSSL_SYS_VOS_IA32
	long long duration;
	extern void s$sleep2 (long long *_duration, short int *_code);
#else
#error "Unsupported Platform."
#endif /* OPENSSL_SYS_VOS_IA32 */
#endif /* OPENSSL_SYS_VOS_HPPA */

	/* Seed with the gid, pid, and uid, to ensure *some*
	   variation between different processes.  */
d115 2
a116 3
	curr_gid = getgid();
	RAND_add (&curr_gid, sizeof curr_gid, 1);
	curr_gid = 0;
a117 38
	curr_pid = getpid();
	RAND_add (&curr_pid, sizeof curr_pid, 1);
	curr_pid = 0;

	curr_uid = getuid();
	RAND_add (&curr_uid, sizeof curr_uid, 1);
	curr_uid = 0;

	for (i=0; i<(ENTROPY_NEEDED*4); i++)
	{
		/* burn some cpu; hope for interrupts, cache
		   collisions, bus interference, etc.  */
		for (k=0; k<99; k++)
			ts.tv_nsec = random ();

#ifdef OPENSSL_SYS_VOS_HPPA
		/* sleep for 1/1024 of a second (976 us).  */
		duration = 1;
		s$sleep (&duration, &code);
#else
#ifdef OPENSSL_SYS_VOS_IA32
		/* sleep for 1/65536 of a second (15 us).  */
		duration = 1;
		s$sleep2 (&duration, &code);
#endif /* OPENSSL_SYS_VOS_IA32 */
#endif /* OPENSSL_SYS_VOS_HPPA */

		/* get wall clock time.  */
		clock_gettime (CLOCK_REALTIME, &ts);

		/* take 8 bits */
		v = (unsigned char) (ts.tv_nsec % 256);
		RAND_add (&v, sizeof v, 1);
		v = 0;
	}
	return 1;
}
#elif defined __OpenBSD__
a119 6
	unsigned char buf[ENTROPY_NEEDED];

	arc4random_buf(buf, sizeof(buf));
	RAND_add(buf, sizeof(buf), sizeof(buf));
	memset(buf, 0, sizeof(buf));

a121 196
#else /* !defined(__OpenBSD__) */
int RAND_poll(void)
{
	unsigned long l;
	pid_t curr_pid = getpid();
#if defined(DEVRANDOM) || defined(DEVRANDOM_EGD)
	unsigned char tmpbuf[ENTROPY_NEEDED];
	int n = 0;
#endif
#ifdef DEVRANDOM
	static const char *randomfiles[] = { DEVRANDOM };
	struct stat randomstats[sizeof(randomfiles)/sizeof(randomfiles[0])];
	int fd;
	unsigned int i;
#endif
#ifdef DEVRANDOM_EGD
	static const char *egdsockets[] = { DEVRANDOM_EGD, NULL };
	const char **egdsocket = NULL;
#endif

#ifdef DEVRANDOM
	memset(randomstats,0,sizeof(randomstats));
	/* Use a random entropy pool device. Linux, FreeBSD and OpenBSD
	 * have this. Use /dev/urandom if you can as /dev/random may block
	 * if it runs out of random entries.  */

	for (i = 0; (i < sizeof(randomfiles)/sizeof(randomfiles[0])) &&
			(n < ENTROPY_NEEDED); i++)
		{
		if ((fd = open(randomfiles[i], O_RDONLY
#ifdef O_NONBLOCK
			|O_NONBLOCK
#endif
#ifdef O_BINARY
			|O_BINARY
#endif
#ifdef O_NOCTTY /* If it happens to be a TTY (god forbid), do not make it
		   our controlling tty */
			|O_NOCTTY
#endif
			)) >= 0)
			{
			int usec = 10*1000; /* spend 10ms on each file */
			int r;
			unsigned int j;
			struct stat *st=&randomstats[i];

			/* Avoid using same input... Used to be O_NOFOLLOW
			 * above, but it's not universally appropriate... */
			if (fstat(fd,st) != 0)	{ close(fd); continue; }
			for (j=0;j<i;j++)
				{
				if (randomstats[j].st_ino==st->st_ino &&
				    randomstats[j].st_dev==st->st_dev)
					break;
				}
			if (j<i)		{ close(fd); continue; }

			do
				{
				int try_read = 0;

#if defined(OPENSSL_SYS_BEOS_R5)
				/* select() is broken in BeOS R5, so we simply
				 *  try to read something and snooze if we couldn't */
				try_read = 1;

#elif defined(OPENSSL_SYS_LINUX)
				/* use poll() */
				struct pollfd pset;
				
				pset.fd = fd;
				pset.events = POLLIN;
				pset.revents = 0;

				if (poll(&pset, 1, usec / 1000) < 0)
					usec = 0;
				else
					try_read = (pset.revents & POLLIN) != 0;

#else
				/* use select() */
				fd_set fset;
				struct timeval t;
				
				t.tv_sec = 0;
				t.tv_usec = usec;

				if (FD_SETSIZE > 0 && (unsigned)fd >= FD_SETSIZE)
					{
					/* can't use select, so just try to read once anyway */
					try_read = 1;
					}
				else
					{
					FD_ZERO(&fset);
					FD_SET(fd, &fset);
					
					if (select(fd+1,&fset,NULL,NULL,&t) >= 0)
						{
						usec = t.tv_usec;
						if (FD_ISSET(fd, &fset))
							try_read = 1;
						}
					else
						usec = 0;
					}
#endif
				
				if (try_read)
					{
					r = read(fd,(unsigned char *)tmpbuf+n, ENTROPY_NEEDED-n);
					if (r > 0)
						n += r;
#if defined(OPENSSL_SYS_BEOS_R5)
					if (r == 0)
						snooze(t.tv_usec);
#endif
					}
				else
					r = -1;
				
				/* Some Unixen will update t in select(), some
				   won't.  For those who won't, or if we
				   didn't use select() in the first place,
				   give up here, otherwise, we will do
				   this once again for the remaining
				   time. */
				if (usec == 10*1000)
					usec = 0;
				}
			while ((r > 0 ||
			       (errno == EINTR || errno == EAGAIN)) && usec != 0 && n < ENTROPY_NEEDED);

			close(fd);
			}
		}
#endif /* defined(DEVRANDOM) */

#ifdef DEVRANDOM_EGD
	/* Use an EGD socket to read entropy from an EGD or PRNGD entropy
	 * collecting daemon. */

	for (egdsocket = egdsockets; *egdsocket && n < ENTROPY_NEEDED; egdsocket++)
		{
		int r;

		r = RAND_query_egd_bytes(*egdsocket, (unsigned char *)tmpbuf+n,
					 ENTROPY_NEEDED-n);
		if (r > 0)
			n += r;
		}
#endif /* defined(DEVRANDOM_EGD) */

#if defined(DEVRANDOM) || defined(DEVRANDOM_EGD)
	if (n > 0)
		{
		RAND_add(tmpbuf,sizeof tmpbuf,(double)n);
		OPENSSL_cleanse(tmpbuf,n);
		}
#endif

	/* put in some default random data, we need more than just this */
	l=curr_pid;
	RAND_add(&l,sizeof(l),0.0);
	l=getuid();
	RAND_add(&l,sizeof(l),0.0);

	l=time(NULL);
	RAND_add(&l,sizeof(l),0.0);

#if defined(OPENSSL_SYS_BEOS)
	{
	system_info sysInfo;
	get_system_info(&sysInfo);
	RAND_add(&sysInfo,sizeof(sysInfo),0);
	}
#endif

#if defined(DEVRANDOM) || defined(DEVRANDOM_EGD)
	return 1;
#else
	return 0;
#endif
}

#endif /* defined(__OpenBSD__) */
#endif /* !(defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_VXWORKS) || defined(OPENSSL_SYS_NETWARE)) */


#if defined(OPENSSL_SYS_VXWORKS)
int RAND_poll(void)
	{
	return 0;
	}
#endif
@


1.9
log
@resolve conflicts, fix local changes
@
text
@d136 17
a152 1
#ifdef __VOS__
d155 2
a156 1
	unsigned char buf[ENTROPY_NEEDED];
d159 1
a159 3
	static int first=1;
	int i;
	long rnd = 0;
d161 20
a180 1
	unsigned seed;
d182 29
a210 19
/* The VOS random() function starts from a static seed so its
   initial value is predictable.  If random() returns the
   initial value, reseed it with dynamic data.  The VOS
   real-time clock has a granularity of 1 nsec so it should be
   reasonably difficult to predict its exact value.  Do not
   gratuitously reseed the PRNG because other code in this
   process or thread may be using it.  */

	if (first) {
		first = 0;
		rnd = random ();
		if (rnd == 1804289383) {
			clock_gettime (CLOCK_REALTIME, &ts);
			curr_pid = getpid();
			curr_uid = getuid();
			seed = ts.tv_sec ^ ts.tv_nsec ^ curr_pid ^ curr_uid;
			srandom (seed);
		}
	}
d212 4
a215 5
	for (i = 0; i < sizeof(buf); i++) {
		if (i % 4 == 0)
			rnd = random();
		buf[i] = rnd;
		rnd >>= 8;
a216 3
	RAND_add(buf, sizeof(buf), ENTROPY_NEEDED);
	memset(buf, 0, sizeof(buf));

@


1.8
log
@resolve conflicts
@
text
@d136 44
a179 1
#ifdef __OpenBSD__
d203 1
a203 1
	size_t i;
d216 2
a217 1
	for (i=0; i<sizeof(randomfiles)/sizeof(randomfiles[0]) && n < ENTROPY_NEEDED; i++)
d234 1
a234 1
			size_t j;
d252 6
a257 1
#if defined(OPENSSL_SYS_LINUX)
d304 4
d360 8
@


1.7
log
@use one call to arc4random_buf() instead of lots of arc4random()
@
text
@d229 1
a229 1
				if (FD_SETSIZE > 0 && fd >= FD_SETSIZE)
@


1.6
log
@resolve conflicts
@
text
@a138 1
	u_int32_t rnd = 0, i;
d141 2
a142 7
	for (i = 0; i < sizeof(buf); i++) {
		if (i % 4 == 0)
			rnd = arc4random();
		buf[i] = rnd;
		rnd >>= 8;
	}
	RAND_add(buf, sizeof(buf), ENTROPY_NEEDED);
@


1.5
log
@resolve conflicts
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
d111 1
d119 1
a119 1
#if !(defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_VXWORKS))
d128 7
d153 1
a153 1
#else
d165 2
a166 1
	int fd,i;
d194 3
a196 4
			struct timeval t = { 0, 10*1000 }; /* Spend 10ms on
							      each file. */
			int r,j;
			fd_set fset;
d212 45
a256 7
				FD_ZERO(&fset);
				FD_SET(fd, &fset);
				r = -1;

				if (select(fd+1,&fset,NULL,NULL,&t) < 0)
					t.tv_usec=0;
				else if (FD_ISSET(fd, &fset))
d258 1
a258 2
					r=read(fd,(unsigned char *)tmpbuf+n,
					       ENTROPY_NEEDED-n);
d262 7
a268 4

				/* Some Unixen will update t, some
				   won't.  For those who won't, give
				   up here, otherwise, we will do
d271 2
a272 2
				if (t.tv_usec == 10*1000)
					t.tv_usec=0;
d274 2
a275 2
			while ((r > 0 || (errno == EINTR || errno == EAGAIN))
				&& t.tv_usec != 0 && n < ENTROPY_NEEDED);
d280 1
a280 1
#endif
d295 1
a295 1
#endif
d300 1
a300 1
		RAND_add(tmpbuf,sizeof tmpbuf,n);
d307 1
a307 1
	RAND_add(&l,sizeof(l),0);
d309 1
a309 1
	RAND_add(&l,sizeof(l),0);
d312 1
a312 1
	RAND_add(&l,sizeof(l),0);
d321 3
a323 2
#endif
#endif
d327 3
a329 3
{
    return 0;
}
@


1.4
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d123 1
d155 3
a157 3
	static const char *randomfiles[] = { DEVRANDOM, NULL };
	const char **randomfile = NULL;
	int fd;
d165 1
d170 1
a170 1
	for (randomfile = randomfiles; *randomfile && n < ENTROPY_NEEDED; randomfile++)
d172 7
a178 1
		if ((fd = open(*randomfile, O_RDONLY|O_NONBLOCK
a182 3
#ifdef O_NOFOLLOW /* Fail if the file is a symbolic link */
			|O_NOFOLLOW
#endif
d187 1
a187 1
			int r;
d189 12
@


1.3
log
@use arc4random instead of /dev/arandom,
allows RAND_poll after chroot, ok deraadt, fgsch
@
text
@d118 1
a118 1
#if !(defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_OS2))
d236 1
a236 1
		memset(tmpbuf,0,n);
d257 7
@


1.2
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@a127 2
#undef DEVRANDOM
#define DEVRANDOM "/dev/arandom"
d130 2
a131 3
        unsigned long l;
        pid_t curr_pid = getpid();
        FILE *fh;
d133 8
a140 3
        /* Use a random entropy pool device. Linux, FreeBSD and OpenBSD
         * have this. Use /dev/urandom if you can as /dev/random may block
         * if it runs out of random entries.  */
d142 1
a142 22
        if ((fh = fopen(DEVRANDOM, "r")) != NULL)
                {
                unsigned char tmpbuf[ENTROPY_NEEDED];
                int n;

                setvbuf(fh, NULL, _IONBF, 0);
                n=fread((unsigned char *)tmpbuf,1,ENTROPY_NEEDED,fh);
                fclose(fh);
                RAND_add(tmpbuf,sizeof tmpbuf,n);
                memset(tmpbuf,0,n);
                }

        /* put in some default random data, we need more than just this */
        l=curr_pid;
        RAND_add(&l,sizeof(l),0);
        l=getuid();
        RAND_add(&l,sizeof(l),0);

        l=time(NULL);
        RAND_add(&l,sizeof(l),0);

        return 1;
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d112 2
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d125 37
d273 1
@


1.1.1.2
log
@import openssl-0.9.7-beta3
@
text
@a111 2
#define USE_SOCKETS
#include "e_os.h"
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d118 1
a118 1
#if !(defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_VXWORKS))
d218 1
a218 1
		OPENSSL_cleanse(tmpbuf,n);
a237 7
#endif

#if defined(OPENSSL_SYS_VXWORKS)
int RAND_poll(void)
{
    return 0;
}
@


1.1.1.4
log
@import openssl-0.9.7d
@
text
@a126 18
#ifdef __OpenBSD__
int RAND_poll(void)
{
	u_int32_t rnd = 0, i;
	unsigned char buf[ENTROPY_NEEDED];

	for (i = 0; i < sizeof(buf); i++) {
		if (i % 4 == 0)
			rnd = arc4random();
		buf[i] = rnd;
		rnd >>= 8;
	}
	RAND_add(buf, sizeof(buf), ENTROPY_NEEDED);
	memset(buf, 0, sizeof(buf));

	return 1;
}
#else
a237 1
#endif
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a122 1
#include <sys/stat.h>
d154 3
a156 3
	static const char *randomfiles[] = { DEVRANDOM };
	struct stat randomstats[sizeof(randomfiles)/sizeof(randomfiles[0])];
	int fd,i;
a163 1
	memset(randomstats,0,sizeof(randomstats));
d168 1
a168 1
	for (i=0; i<sizeof(randomfiles)/sizeof(randomfiles[0]) && n < ENTROPY_NEEDED; i++)
d170 1
a170 7
		if ((fd = open(randomfiles[i], O_RDONLY
#ifdef O_NONBLOCK
			|O_NONBLOCK
#endif
#ifdef O_BINARY
			|O_BINARY
#endif
d175 3
d182 1
a182 1
			int r,j;
a183 12
			struct stat *st=&randomstats[i];

			/* Avoid using same input... Used to be O_NOFOLLOW
			 * above, but it's not universally appropriate... */
			if (fstat(fd,st) != 0)	{ close(fd); continue; }
			for (j=0;j<i;j++)
				{
				if (randomstats[j].st_ino==st->st_ino &&
				    randomstats[j].st_dev==st->st_dev)
					break;
				}
			if (j<i)		{ close(fd); continue; }
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
a110 1
#include <stdio.h>
d118 1
a118 1
#if !(defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_VXWORKS) || defined(OPENSSL_SYS_NETWARE))
a126 7
#if defined(OPENSSL_SYS_LINUX) /* should actually be available virtually everywhere */
# include <poll.h>
#endif
#include <limits.h>
#ifndef FD_SETSIZE
# define FD_SETSIZE (8*sizeof(fd_set))
#endif
d145 1
a145 1
#else /* !defined(__OpenBSD__) */
d157 1
a157 2
	int fd;
	size_t i;
d185 4
a188 3
			int usec = 10*1000; /* spend 10ms on each file */
			int r;
			size_t j;
d204 7
a210 45
				int try_read = 0;

#if defined(OPENSSL_SYS_LINUX)
				/* use poll() */
				struct pollfd pset;
				
				pset.fd = fd;
				pset.events = POLLIN;
				pset.revents = 0;

				if (poll(&pset, 1, usec / 1000) < 0)
					usec = 0;
				else
					try_read = (pset.revents & POLLIN) != 0;

#else
				/* use select() */
				fd_set fset;
				struct timeval t;
				
				t.tv_sec = 0;
				t.tv_usec = usec;

				if (FD_SETSIZE > 0 && fd >= FD_SETSIZE)
					{
					/* can't use select, so just try to read once anyway */
					try_read = 1;
					}
				else
					{
					FD_ZERO(&fset);
					FD_SET(fd, &fset);
					
					if (select(fd+1,&fset,NULL,NULL,&t) >= 0)
						{
						usec = t.tv_usec;
						if (FD_ISSET(fd, &fset))
							try_read = 1;
						}
					else
						usec = 0;
					}
#endif
				
				if (try_read)
d212 2
a213 1
					r = read(fd,(unsigned char *)tmpbuf+n, ENTROPY_NEEDED-n);
d217 4
a220 7
				else
					r = -1;
				
				/* Some Unixen will update t in select(), some
				   won't.  For those who won't, or if we
				   didn't use select() in the first place,
				   give up here, otherwise, we will do
d223 2
a224 2
				if (usec == 10*1000)
					usec = 0;
d226 2
a227 2
			while ((r > 0 ||
			       (errno == EINTR || errno == EAGAIN)) && usec != 0 && n < ENTROPY_NEEDED);
d232 1
a232 1
#endif /* defined(DEVRANDOM) */
d247 1
a247 1
#endif /* defined(DEVRANDOM_EGD) */
d252 1
a252 1
		RAND_add(tmpbuf,sizeof tmpbuf,(double)n);
d259 1
a259 1
	RAND_add(&l,sizeof(l),0.0);
d261 1
a261 1
	RAND_add(&l,sizeof(l),0.0);
d264 1
a264 1
	RAND_add(&l,sizeof(l),0.0);
d273 2
a274 3
#endif /* defined(__OpenBSD__) */
#endif /* !(defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_VXWORKS) || defined(OPENSSL_SYS_NETWARE)) */

d278 3
a280 3
	{
	return 0;
	}
@


1.1.1.7
log
@import of OpenSSL 0.9.8k
@
text
@d235 1
a235 1
				if (FD_SETSIZE > 0 && (unsigned)fd >= FD_SETSIZE)
@


1.1.1.8
log
@import OpenSSL-1.0.0a
@
text
@d136 1
a136 44
#ifdef __VOS__
int RAND_poll(void)
{
	unsigned char buf[ENTROPY_NEEDED];
	pid_t curr_pid;
	uid_t curr_uid;
	static int first=1;
	int i;
	long rnd = 0;
	struct timespec ts;
	unsigned seed;

/* The VOS random() function starts from a static seed so its
   initial value is predictable.  If random() returns the
   initial value, reseed it with dynamic data.  The VOS
   real-time clock has a granularity of 1 nsec so it should be
   reasonably difficult to predict its exact value.  Do not
   gratuitously reseed the PRNG because other code in this
   process or thread may be using it.  */

	if (first) {
		first = 0;
		rnd = random ();
		if (rnd == 1804289383) {
			clock_gettime (CLOCK_REALTIME, &ts);
			curr_pid = getpid();
			curr_uid = getuid();
			seed = ts.tv_sec ^ ts.tv_nsec ^ curr_pid ^ curr_uid;
			srandom (seed);
		}
	}

	for (i = 0; i < sizeof(buf); i++) {
		if (i % 4 == 0)
			rnd = random();
		buf[i] = rnd;
		rnd >>= 8;
	}
	RAND_add(buf, sizeof(buf), ENTROPY_NEEDED);
	memset(buf, 0, sizeof(buf));

	return 1;
}
#elif defined __OpenBSD__
d166 1
a166 1
	unsigned int i;
d179 1
a179 2
	for (i = 0; (i < sizeof(randomfiles)/sizeof(randomfiles[0])) &&
			(n < ENTROPY_NEEDED); i++)
d196 1
a196 1
			unsigned int j;
d214 1
a214 6
#if defined(OPENSSL_SYS_BEOS_R5)
				/* select() is broken in BeOS R5, so we simply
				 *  try to read something and snooze if we couldn't */
				try_read = 1;

#elif defined(OPENSSL_SYS_LINUX)
a260 4
#if defined(OPENSSL_SYS_BEOS_R5)
					if (r == 0)
						snooze(t.tv_usec);
#endif
a312 8

#if defined(OPENSSL_SYS_BEOS)
	{
	system_info sysInfo;
	get_system_info(&sysInfo);
	RAND_add(&sysInfo,sizeof(sysInfo),0);
	}
#endif
@


1.1.1.9
log
@OpenSSL 1.0.0f: import upstream source
@
text
@d136 1
a136 17
#if defined(OPENSSL_SYS_VOS)

/* The following algorithm repeatedly samples the real-time clock
   (RTC) to generate a sequence of unpredictable data.  The algorithm
   relies upon the uneven execution speed of the code (due to factors
   such as cache misses, interrupts, bus activity, and scheduling) and
   upon the rather large relative difference between the speed of the
   clock and the rate at which it can be read.

   If this code is ported to an environment where execution speed is
   more constant or where the RTC ticks at a much slower rate, or the
   clock can be read with fewer instructions, it is likely that the
   results would be far more predictable.

   As a precaution, we generate 4 times the minimum required amount of
   seed data.  */

d139 1
a139 2
	short int code;
	gid_t curr_gid;
d142 3
a144 1
	int i, k;
d146 1
a146 1
	unsigned char v;
d148 19
a166 11
#ifdef OPENSSL_SYS_VOS_HPPA
	long duration;
	extern void s$sleep (long *_duration, short int *_code);
#else
#ifdef OPENSSL_SYS_VOS_IA32
	long long duration;
	extern void s$sleep2 (long long *_duration, short int *_code);
#else
#error "Unsupported Platform."
#endif /* OPENSSL_SYS_VOS_IA32 */
#endif /* OPENSSL_SYS_VOS_HPPA */
d168 8
a175 6
	/* Seed with the gid, pid, and uid, to ensure *some*
	   variation between different processes.  */

	curr_gid = getgid();
	RAND_add (&curr_gid, sizeof curr_gid, 1);
	curr_gid = 0;
a176 35
	curr_pid = getpid();
	RAND_add (&curr_pid, sizeof curr_pid, 1);
	curr_pid = 0;

	curr_uid = getuid();
	RAND_add (&curr_uid, sizeof curr_uid, 1);
	curr_uid = 0;

	for (i=0; i<(ENTROPY_NEEDED*4); i++)
	{
		/* burn some cpu; hope for interrupts, cache
		   collisions, bus interference, etc.  */
		for (k=0; k<99; k++)
			ts.tv_nsec = random ();

#ifdef OPENSSL_SYS_VOS_HPPA
		/* sleep for 1/1024 of a second (976 us).  */
		duration = 1;
		s$sleep (&duration, &code);
#else
#ifdef OPENSSL_SYS_VOS_IA32
		/* sleep for 1/65536 of a second (15 us).  */
		duration = 1;
		s$sleep2 (&duration, &code);
#endif /* OPENSSL_SYS_VOS_IA32 */
#endif /* OPENSSL_SYS_VOS_HPPA */

		/* get wall clock time.  */
		clock_gettime (CLOCK_REALTIME, &ts);

		/* take 8 bits */
		v = (unsigned char) (ts.tv_nsec % 256);
		RAND_add (&v, sizeof v, 1);
		v = 0;
	}
@


