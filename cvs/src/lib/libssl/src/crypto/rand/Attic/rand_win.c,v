head	1.11;
access;
symbols
	butholakala:1.10
	openssl_1_0_1_g:1.1.1.8
	OPENBSD_5_5:1.9.0.16
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.12
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	openssl_1_0_1_c:1.1.1.7
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	openssl_1_0_0_f:1.1.1.7
	openssl_1_0_0_e:1.1.1.7
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	openssh_1_0_0_a:1.1.1.7
	OPENBSD_4_8:1.8.0.8
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	openssl_0_9_8_k:1.1.1.6
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	openssl_0_9_8_j:1.1.1.6
	openssl_0_9_8_h:1.1.1.6
	pre_openssl_0_9_8h:1.7
	OPENBSD_4_4:1.7.0.14
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.12
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.10
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.8
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.6
	OPENBSD_4_0_BASE:1.7
	openssl_0_9_7j:1.1.1.5
	openssl:1.1.1
	OPENBSD_3_9:1.7.0.4
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENSSL_0_9_7C:1.1.1.3
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.1.0.2
	OPENBSD_2_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.04.14.04.27.50;	author miod;	state dead;
branches;
next	1.10;

1.10
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.29.05.39.25;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.08.08.03.14;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.12.02.18.38;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.15.02.29.16;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.22.00.03.17;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.15.02.58.03;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.49;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.35.43;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.11.21.17.05;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.04.07.20.41.49;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.15;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.46;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.10;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Don't bother compiling files which end up containing
  #if OPENSSL_SYS_NOTYOURS
  <whole file>
  #endif
@
text
@/* crypto/rand/rand_win.c */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include "cryptlib.h"
#include <openssl/rand.h>
#include "rand_lcl.h"

#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32)
#include <windows.h>
#ifndef _WIN32_WINNT
# define _WIN32_WINNT 0x0400
#endif
#include <wincrypt.h>
#include <tlhelp32.h>

/* Limit the time spent walking through the heap, processes, threads and modules to
   a maximum of 1000 miliseconds each, unless CryptoGenRandom failed */
#define MAXDELAY 1000

/* Intel hardware RNG CSP -- available from
 * http://developer.intel.com/design/security/rng/redist_license.htm
 */
#define PROV_INTEL_SEC 22
#define INTEL_DEF_PROV L"Intel Hardware Cryptographic Service Provider"

static void readtimer(void);
static void readscreen(void);

/* It appears like CURSORINFO, PCURSORINFO and LPCURSORINFO are only defined
   when WINVER is 0x0500 and up, which currently only happens on Win2000.
   Unfortunately, those are typedefs, so they're a little bit difficult to
   detect properly.  On the other hand, the macro CURSOR_SHOWING is defined
   within the same conditional, so it can be use to detect the absence of said
   typedefs. */

#ifndef CURSOR_SHOWING
/*
 * Information about the global cursor.
 */
typedef struct tagCURSORINFO
{
    DWORD   cbSize;
    DWORD   flags;
    HCURSOR hCursor;
    POINT   ptScreenPos;
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;

#define CURSOR_SHOWING     0x00000001
#endif /* CURSOR_SHOWING */

#if !defined(OPENSSL_SYS_WINCE)
typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTW)(HCRYPTPROV *, LPCWSTR, LPCWSTR,
				    DWORD, DWORD);
typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV, DWORD, BYTE *);
typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV, DWORD);

typedef HWND (WINAPI *GETFOREGROUNDWINDOW)(VOID);
typedef BOOL (WINAPI *GETCURSORINFO)(PCURSORINFO);
typedef DWORD (WINAPI *GETQUEUESTATUS)(UINT);

typedef HANDLE (WINAPI *CREATETOOLHELP32SNAPSHOT)(DWORD, DWORD);
typedef BOOL (WINAPI *CLOSETOOLHELP32SNAPSHOT)(HANDLE);
typedef BOOL (WINAPI *HEAP32FIRST)(LPHEAPENTRY32, DWORD, size_t);
typedef BOOL (WINAPI *HEAP32NEXT)(LPHEAPENTRY32);
typedef BOOL (WINAPI *HEAP32LIST)(HANDLE, LPHEAPLIST32);
typedef BOOL (WINAPI *PROCESS32)(HANDLE, LPPROCESSENTRY32);
typedef BOOL (WINAPI *THREAD32)(HANDLE, LPTHREADENTRY32);
typedef BOOL (WINAPI *MODULE32)(HANDLE, LPMODULEENTRY32);

#include <lmcons.h>
#include <lmstats.h>
#if 1 /* The NET API is Unicode only.  It requires the use of the UNICODE
       * macro.  When UNICODE is defined LPTSTR becomes LPWSTR.  LMSTR was
       * was added to the Platform SDK to allow the NET API to be used in
       * non-Unicode applications provided that Unicode strings were still
       * used for input.  LMSTR is defined as LPWSTR.
       */
typedef NET_API_STATUS (NET_API_FUNCTION * NETSTATGET)
        (LPWSTR, LPWSTR, DWORD, DWORD, LPBYTE*);
typedef NET_API_STATUS (NET_API_FUNCTION * NETFREE)(LPBYTE);
#endif /* 1 */
#endif /* !OPENSSL_SYS_WINCE */

int RAND_poll(void)
{
	MEMORYSTATUS m;
	HCRYPTPROV hProvider = 0;
	DWORD w;
	int good = 0;

	/* Determine the OS version we are on so we can turn off things 
	 * that do not work properly.
	 */
        OSVERSIONINFO osverinfo ;
        osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO) ;
        GetVersionEx( &osverinfo ) ;

#if defined(OPENSSL_SYS_WINCE)
# if defined(_WIN32_WCE) && _WIN32_WCE>=300
/* Even though MSDN says _WIN32_WCE>=210, it doesn't seem to be available
 * in commonly available implementations prior 300... */
	{
	BYTE buf[64];
	/* poll the CryptoAPI PRNG */
	/* The CryptoAPI returns sizeof(buf) bytes of randomness */
	if (CryptAcquireContextW(&hProvider, NULL, NULL, PROV_RSA_FULL,
				CRYPT_VERIFYCONTEXT))
		{
		if (CryptGenRandom(hProvider, sizeof(buf), buf))
			RAND_add(buf, sizeof(buf), sizeof(buf));
		CryptReleaseContext(hProvider, 0); 
		}
	}
# endif
#else	/* OPENSSL_SYS_WINCE */
	/*
	 * None of below libraries are present on Windows CE, which is
	 * why we #ifndef the whole section. This also excuses us from
	 * handling the GetProcAddress issue. The trouble is that in
	 * real Win32 API GetProcAddress is available in ANSI flavor
	 * only. In WinCE on the other hand GetProcAddress is a macro
	 * most commonly defined as GetProcAddressW, which accepts
	 * Unicode argument. If we were to call GetProcAddress under
	 * WinCE, I'd recommend to either redefine GetProcAddress as
	 * GetProcAddressA (there seem to be one in common CE spec) or
	 * implement own shim routine, which would accept ANSI argument
	 * and expand it to Unicode.
	 */
	{
	/* load functions dynamically - not available on all systems */
	HMODULE advapi = LoadLibrary(TEXT("ADVAPI32.DLL"));
	HMODULE kernel = LoadLibrary(TEXT("KERNEL32.DLL"));
	HMODULE user = NULL;
	HMODULE netapi = LoadLibrary(TEXT("NETAPI32.DLL"));
	CRYPTACQUIRECONTEXTW acquire = NULL;
	CRYPTGENRANDOM gen = NULL;
	CRYPTRELEASECONTEXT release = NULL;
	NETSTATGET netstatget = NULL;
	NETFREE netfree = NULL;
	BYTE buf[64];

	if (netapi)
		{
		netstatget = (NETSTATGET) GetProcAddress(netapi,"NetStatisticsGet");
		netfree = (NETFREE) GetProcAddress(netapi,"NetApiBufferFree");
		}

	if (netstatget && netfree)
		{
		LPBYTE outbuf;
		/* NetStatisticsGet() is a Unicode only function
 		 * STAT_WORKSTATION_0 contains 45 fields and STAT_SERVER_0
		 * contains 17 fields.  We treat each field as a source of
		 * one byte of entropy.
                 */

		if (netstatget(NULL, L"LanmanWorkstation", 0, 0, &outbuf) == 0)
			{
			RAND_add(outbuf, sizeof(STAT_WORKSTATION_0), 45);
			netfree(outbuf);
			}
		if (netstatget(NULL, L"LanmanServer", 0, 0, &outbuf) == 0)
			{
			RAND_add(outbuf, sizeof(STAT_SERVER_0), 17);
			netfree(outbuf);
			}
		}

	if (netapi)
		FreeLibrary(netapi);

        /* It appears like this can cause an exception deep within ADVAPI32.DLL
         * at random times on Windows 2000.  Reported by Jeffrey Altman.  
         * Only use it on NT.
	 */
	/* Wolfgang Marczy <WMarczy@@topcall.co.at> reports that
	 * the RegQueryValueEx call below can hang on NT4.0 (SP6).
	 * So we don't use this at all for now. */
#if 0
        if ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&
		osverinfo.dwMajorVersion < 5)
		{
		/* Read Performance Statistics from NT/2000 registry
		 * The size of the performance data can vary from call
		 * to call so we must guess the size of the buffer to use
		 * and increase its size if we get an ERROR_MORE_DATA
		 * return instead of ERROR_SUCCESS.
		 */
		LONG   rc=ERROR_MORE_DATA;
		char * buf=NULL;
		DWORD bufsz=0;
		DWORD length;

		while (rc == ERROR_MORE_DATA)
			{
			buf = realloc(buf,bufsz+8192);
			if (!buf)
				break;
			bufsz += 8192;

			length = bufsz;
			rc = RegQueryValueEx(HKEY_PERFORMANCE_DATA, TEXT("Global"),
				NULL, NULL, buf, &length);
			}
		if (rc == ERROR_SUCCESS)
			{
                        /* For entropy count assume only least significant
			 * byte of each DWORD is random.
			 */
			RAND_add(&length, sizeof(length), 0);
			RAND_add(buf, length, length / 4.0);

			/* Close the Registry Key to allow Windows to cleanup/close
			 * the open handle
			 * Note: The 'HKEY_PERFORMANCE_DATA' key is implicitly opened
			 *       when the RegQueryValueEx above is done.  However, if
			 *       it is not explicitly closed, it can cause disk
			 *       partition manipulation problems.
			 */
			RegCloseKey(HKEY_PERFORMANCE_DATA);
			}
		if (buf)
			free(buf);
		}
#endif

	if (advapi)
		{
		/*
		 * If it's available, then it's available in both ANSI
		 * and UNICODE flavors even in Win9x, documentation says.
		 * We favor Unicode...
		 */
		acquire = (CRYPTACQUIRECONTEXTW) GetProcAddress(advapi,
			"CryptAcquireContextW");
		gen = (CRYPTGENRANDOM) GetProcAddress(advapi,
			"CryptGenRandom");
		release = (CRYPTRELEASECONTEXT) GetProcAddress(advapi,
			"CryptReleaseContext");
		}

	if (acquire && gen && release)
		{
		/* poll the CryptoAPI PRNG */
                /* The CryptoAPI returns sizeof(buf) bytes of randomness */
		if (acquire(&hProvider, NULL, NULL, PROV_RSA_FULL,
			CRYPT_VERIFYCONTEXT))
			{
			if (gen(hProvider, sizeof(buf), buf) != 0)
				{
				RAND_add(buf, sizeof(buf), 0);
				good = 1;
#if 0
				printf("randomness from PROV_RSA_FULL\n");
#endif
				}
			release(hProvider, 0); 
			}
		
		/* poll the Pentium PRG with CryptoAPI */
		if (acquire(&hProvider, 0, INTEL_DEF_PROV, PROV_INTEL_SEC, 0))
			{
			if (gen(hProvider, sizeof(buf), buf) != 0)
				{
				RAND_add(buf, sizeof(buf), sizeof(buf));
				good = 1;
#if 0
				printf("randomness from PROV_INTEL_SEC\n");
#endif
				}
			release(hProvider, 0);
			}
		}

        if (advapi)
		FreeLibrary(advapi);

	if ((osverinfo.dwPlatformId != VER_PLATFORM_WIN32_NT ||
	     !OPENSSL_isservice()) &&
	    (user = LoadLibrary(TEXT("USER32.DLL"))))
		{
		GETCURSORINFO cursor;
		GETFOREGROUNDWINDOW win;
		GETQUEUESTATUS queue;

		win = (GETFOREGROUNDWINDOW) GetProcAddress(user, "GetForegroundWindow");
		cursor = (GETCURSORINFO) GetProcAddress(user, "GetCursorInfo");
		queue = (GETQUEUESTATUS) GetProcAddress(user, "GetQueueStatus");

		if (win)
			{
			/* window handle */
			HWND h = win();
			RAND_add(&h, sizeof(h), 0);
			}
		if (cursor)
			{
			/* unfortunately, its not safe to call GetCursorInfo()
			 * on NT4 even though it exists in SP3 (or SP6) and
			 * higher.
			 */
			if ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&
				osverinfo.dwMajorVersion < 5)
				cursor = 0;
			}
		if (cursor)
			{
			/* cursor position */
                        /* assume 2 bytes of entropy */
			CURSORINFO ci;
			ci.cbSize = sizeof(CURSORINFO);
			if (cursor(&ci))
				RAND_add(&ci, ci.cbSize, 2);
			}

		if (queue)
			{
			/* message queue status */
                        /* assume 1 byte of entropy */
			w = queue(QS_ALLEVENTS);
			RAND_add(&w, sizeof(w), 1);
			}

		FreeLibrary(user);
		}

	/* Toolhelp32 snapshot: enumerate processes, threads, modules and heap
	 * http://msdn.microsoft.com/library/psdk/winbase/toolhelp_5pfd.htm
	 * (Win 9x and 2000 only, not available on NT)
	 *
	 * This seeding method was proposed in Peter Gutmann, Software
	 * Generation of Practically Strong Random Numbers,
	 * http://www.usenix.org/publications/library/proceedings/sec98/gutmann.html
	 * revised version at http://www.cryptoengines.com/~peter/06_random.pdf
	 * (The assignment of entropy estimates below is arbitrary, but based
	 * on Peter's analysis the full poll appears to be safe. Additional
	 * interactive seeding is encouraged.)
	 */

	if (kernel)
		{
		CREATETOOLHELP32SNAPSHOT snap;
		CLOSETOOLHELP32SNAPSHOT close_snap;
		HANDLE handle;

		HEAP32FIRST heap_first;
		HEAP32NEXT heap_next;
		HEAP32LIST heaplist_first, heaplist_next;
		PROCESS32 process_first, process_next;
		THREAD32 thread_first, thread_next;
		MODULE32 module_first, module_next;

		HEAPLIST32 hlist;
		HEAPENTRY32 hentry;
		PROCESSENTRY32 p;
		THREADENTRY32 t;
		MODULEENTRY32 m;
		DWORD starttime = 0;

		snap = (CREATETOOLHELP32SNAPSHOT)
			GetProcAddress(kernel, "CreateToolhelp32Snapshot");
		close_snap = (CLOSETOOLHELP32SNAPSHOT)
			GetProcAddress(kernel, "CloseToolhelp32Snapshot");
		heap_first = (HEAP32FIRST) GetProcAddress(kernel, "Heap32First");
		heap_next = (HEAP32NEXT) GetProcAddress(kernel, "Heap32Next");
		heaplist_first = (HEAP32LIST) GetProcAddress(kernel, "Heap32ListFirst");
		heaplist_next = (HEAP32LIST) GetProcAddress(kernel, "Heap32ListNext");
		process_first = (PROCESS32) GetProcAddress(kernel, "Process32First");
		process_next = (PROCESS32) GetProcAddress(kernel, "Process32Next");
		thread_first = (THREAD32) GetProcAddress(kernel, "Thread32First");
		thread_next = (THREAD32) GetProcAddress(kernel, "Thread32Next");
		module_first = (MODULE32) GetProcAddress(kernel, "Module32First");
		module_next = (MODULE32) GetProcAddress(kernel, "Module32Next");

		if (snap && heap_first && heap_next && heaplist_first &&
			heaplist_next && process_first && process_next &&
			thread_first && thread_next && module_first &&
			module_next && (handle = snap(TH32CS_SNAPALL,0))
			!= INVALID_HANDLE_VALUE)
			{
			/* heap list and heap walking */
                        /* HEAPLIST32 contains 3 fields that will change with
                         * each entry.  Consider each field a source of 1 byte
                         * of entropy.
                         * HEAPENTRY32 contains 5 fields that will change with 
                         * each entry.  Consider each field a source of 1 byte
                         * of entropy.
                         */
			ZeroMemory(&hlist, sizeof(HEAPLIST32));
			hlist.dwSize = sizeof(HEAPLIST32);		
			if (good) starttime = GetTickCount();
#ifdef _MSC_VER
			if (heaplist_first(handle, &hlist))
				{
				/*
				   following discussion on dev ML, exception on WinCE (or other Win
				   platform) is theoretically of unknown origin; prevent infinite
				   loop here when this theoretical case occurs; otherwise cope with
				   the expected (MSDN documented) exception-throwing behaviour of
				   Heap32Next() on WinCE.

				   based on patch in original message by Tanguy Fautré (2009/03/02)
			           Subject: RAND_poll() and CreateToolhelp32Snapshot() stability
			     */
				int ex_cnt_limit = 42; 
				do
					{
					RAND_add(&hlist, hlist.dwSize, 3);
					__try
						{
						ZeroMemory(&hentry, sizeof(HEAPENTRY32));
					hentry.dwSize = sizeof(HEAPENTRY32);
					if (heap_first(&hentry,
						hlist.th32ProcessID,
						hlist.th32HeapID))
						{
						int entrycnt = 80;
						do
							RAND_add(&hentry,
								hentry.dwSize, 5);
						while (heap_next(&hentry)
						&& (!good || (GetTickCount()-starttime)<MAXDELAY)
							&& --entrycnt > 0);
						}
						}
					__except (EXCEPTION_EXECUTE_HANDLER)
						{
							/* ignore access violations when walking the heap list */
							ex_cnt_limit--;
						}
					} while (heaplist_next(handle, &hlist) 
						&& (!good || (GetTickCount()-starttime)<MAXDELAY)
						&& ex_cnt_limit > 0);
				}

#else
			if (heaplist_first(handle, &hlist))
				{
				do
					{
					RAND_add(&hlist, hlist.dwSize, 3);
					hentry.dwSize = sizeof(HEAPENTRY32);
					if (heap_first(&hentry,
						hlist.th32ProcessID,
						hlist.th32HeapID))
						{
						int entrycnt = 80;
						do
							RAND_add(&hentry,
								hentry.dwSize, 5);
						while (heap_next(&hentry)
							&& --entrycnt > 0);
						}
					} while (heaplist_next(handle, &hlist) 
						&& (!good || (GetTickCount()-starttime)<MAXDELAY));
				}
#endif

			/* process walking */
                        /* PROCESSENTRY32 contains 9 fields that will change
                         * with each entry.  Consider each field a source of
                         * 1 byte of entropy.
                         */
			p.dwSize = sizeof(PROCESSENTRY32);
		
			if (good) starttime = GetTickCount();
			if (process_first(handle, &p))
				do
					RAND_add(&p, p.dwSize, 9);
				while (process_next(handle, &p) && (!good || (GetTickCount()-starttime)<MAXDELAY));

			/* thread walking */
                        /* THREADENTRY32 contains 6 fields that will change
                         * with each entry.  Consider each field a source of
                         * 1 byte of entropy.
                         */
			t.dwSize = sizeof(THREADENTRY32);
			if (good) starttime = GetTickCount();
			if (thread_first(handle, &t))
				do
					RAND_add(&t, t.dwSize, 6);
				while (thread_next(handle, &t) && (!good || (GetTickCount()-starttime)<MAXDELAY));

			/* module walking */
                        /* MODULEENTRY32 contains 9 fields that will change
                         * with each entry.  Consider each field a source of
                         * 1 byte of entropy.
                         */
			m.dwSize = sizeof(MODULEENTRY32);
			if (good) starttime = GetTickCount();
			if (module_first(handle, &m))
				do
					RAND_add(&m, m.dwSize, 9);
				while (module_next(handle, &m)
					       	&& (!good || (GetTickCount()-starttime)<MAXDELAY));
			if (close_snap)
				close_snap(handle);
			else
				CloseHandle(handle);

			}

		FreeLibrary(kernel);
		}
	}
#endif /* !OPENSSL_SYS_WINCE */

	/* timer data */
	readtimer();
	
	/* memory usage statistics */
	GlobalMemoryStatus(&m);
	RAND_add(&m, sizeof(m), 1);

	/* process ID */
	w = GetCurrentProcessId();
	RAND_add(&w, sizeof(w), 1);

#if 0
	printf("Exiting RAND_poll\n");
#endif

	return(1);
}

int RAND_event(UINT iMsg, WPARAM wParam, LPARAM lParam)
        {
        double add_entropy=0;

        switch (iMsg)
                {
        case WM_KEYDOWN:
                        {
                        static WPARAM key;
                        if (key != wParam)
                                add_entropy = 0.05;
                        key = wParam;
                        }
                        break;
	case WM_MOUSEMOVE:
                        {
                        static int lastx,lasty,lastdx,lastdy;
                        int x,y,dx,dy;

                        x=LOWORD(lParam);
                        y=HIWORD(lParam);
                        dx=lastx-x;
                        dy=lasty-y;
                        if (dx != 0 && dy != 0 && dx-lastdx != 0 && dy-lastdy != 0)
                                add_entropy=.2;
                        lastx=x, lasty=y;
                        lastdx=dx, lastdy=dy;
                        }
		break;
		}

	readtimer();
        RAND_add(&iMsg, sizeof(iMsg), add_entropy);
	RAND_add(&wParam, sizeof(wParam), 0);
	RAND_add(&lParam, sizeof(lParam), 0);
 
	return (RAND_status());
	}


void RAND_screen(void) /* function available for backward compatibility */
{
	RAND_poll();
	readscreen();
}


/* feed timing information to the PRNG */
static void readtimer(void)
{
	DWORD w;
	LARGE_INTEGER l;
	static int have_perfc = 1;
#if defined(_MSC_VER) && defined(_M_X86)
	static int have_tsc = 1;
	DWORD cyclecount;

	if (have_tsc) {
	  __try {
	    __asm {
	      _emit 0x0f
	      _emit 0x31
	      mov cyclecount, eax
	      }
	    RAND_add(&cyclecount, sizeof(cyclecount), 1);
	  } __except(EXCEPTION_EXECUTE_HANDLER) {
	    have_tsc = 0;
	  }
	}
#else
# define have_tsc 0
#endif

	if (have_perfc) {
	  if (QueryPerformanceCounter(&l) == 0)
	    have_perfc = 0;
	  else
	    RAND_add(&l, sizeof(l), 0);
	}

	if (!have_tsc && !have_perfc) {
	  w = GetTickCount();
	  RAND_add(&w, sizeof(w), 0);
	}
}

/* feed screen contents to PRNG */
/*****************************************************************************
 *
 * Created 960901 by Gertjan van Oosten, gertjan@@West.NL, West Consulting B.V.
 *
 * Code adapted from
 * <URL:http://support.microsoft.com/default.aspx?scid=kb;[LN];97193>;
 * the original copyright message is:
 *
 *   (C) Copyright Microsoft Corp. 1993.  All rights reserved.
 *
 *   You have a royalty-free right to use, modify, reproduce and
 *   distribute the Sample Files (and/or any modified version) in
 *   any way you find useful, provided that you agree that
 *   Microsoft has no warranty obligations or liability for any
 *   Sample Application Files which are modified.
 */

static void readscreen(void)
{
#if !defined(OPENSSL_SYS_WINCE) && !defined(OPENSSL_SYS_WIN32_CYGWIN)
  HDC		hScrDC;		/* screen DC */
  HDC		hMemDC;		/* memory DC */
  HBITMAP	hBitmap;	/* handle for our bitmap */
  HBITMAP	hOldBitmap;	/* handle for previous bitmap */
  BITMAP	bm;		/* bitmap properties */
  unsigned int	size;		/* size of bitmap */
  char		*bmbits;	/* contents of bitmap */
  int		w;		/* screen width */
  int		h;		/* screen height */
  int		y;		/* y-coordinate of screen lines to grab */
  int		n = 16;		/* number of screen lines to grab at a time */

  if (check_winnt() && OPENSSL_isservice()>0)
    return;

  /* Create a screen DC and a memory DC compatible to screen DC */
  hScrDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
  hMemDC = CreateCompatibleDC(hScrDC);

  /* Get screen resolution */
  w = GetDeviceCaps(hScrDC, HORZRES);
  h = GetDeviceCaps(hScrDC, VERTRES);

  /* Create a bitmap compatible with the screen DC */
  hBitmap = CreateCompatibleBitmap(hScrDC, w, n);

  /* Select new bitmap into memory DC */
  hOldBitmap = SelectObject(hMemDC, hBitmap);

  /* Get bitmap properties */
  GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
  size = (unsigned int)bm.bmWidthBytes * bm.bmHeight * bm.bmPlanes;

  bmbits = OPENSSL_malloc(size);
  if (bmbits) {
    /* Now go through the whole screen, repeatedly grabbing n lines */
    for (y = 0; y < h-n; y += n)
    	{
	unsigned char md[MD_DIGEST_LENGTH];

	/* Bitblt screen DC to memory DC */
	BitBlt(hMemDC, 0, 0, w, n, hScrDC, 0, y, SRCCOPY);

	/* Copy bitmap bits from memory DC to bmbits */
	GetBitmapBits(hBitmap, size, bmbits);

	/* Get the hash of the bitmap */
	MD(bmbits,size,md);

	/* Seed the random generator with the hash value */
	RAND_add(md, MD_DIGEST_LENGTH, 0);
	}

    OPENSSL_free(bmbits);
  }

  /* Select old bitmap back into memory DC */
  hBitmap = SelectObject(hMemDC, hOldBitmap);

  /* Clean up */
  DeleteObject(hBitmap);
  DeleteDC(hMemDC);
  DeleteDC(hScrDC);
#endif /* !OPENSSL_SYS_WINCE */
}

#endif
@


1.10
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@@


1.9
log
@resolve conflicts, fix local changes
@
text
@d753 1
a753 1
  if (GetVersion() < 0x80000000 && OPENSSL_isservice()>0)
@


1.8
log
@resolve conflicts
@
text
@d466 1
a466 1
		DWORD stoptime = 0;
d497 1
d499 2
a500 1
			if (good) stoptime = GetTickCount() + MAXDELAY;
d502 12
d517 3
d530 1
d533 33
a565 2
					} while (heaplist_next(handle,
						&hlist) && GetTickCount() < stoptime);
d574 1
a574 1
			if (good) stoptime = GetTickCount() + MAXDELAY;
d578 1
a578 1
				while (process_next(handle, &p) && GetTickCount() < stoptime);
d586 1
a586 1
			if (good) stoptime = GetTickCount() + MAXDELAY;
d590 1
a590 1
				while (thread_next(handle, &t) && GetTickCount() < stoptime);
d598 1
a598 1
			if (good) stoptime = GetTickCount() + MAXDELAY;
d603 1
a603 1
					       	&& (GetTickCount() < stoptime));
d753 1
a753 1
  if (GetVersion() >= 0x80000000 || !OPENSSL_isservice())
@


1.7
log
@resolve conflicts
@
text
@d124 4
d159 1
d171 1
a171 1
typedef BOOL (WINAPI *HEAP32FIRST)(LPHEAPENTRY32, DWORD, DWORD);
a178 1
#ifndef OPENSSL_SYS_WINCE
a179 1
#endif
d190 1
a195 1
	BYTE buf[64];
d197 1
a197 13
	HWND h;

	HMODULE advapi, kernel, user, netapi;
	CRYPTACQUIRECONTEXTW acquire = 0;
	CRYPTGENRANDOM gen = 0;
	CRYPTRELEASECONTEXT release = 0;
#if 1 /* There was previously a problem with NETSTATGET.  Currently, this
       * section is still experimental, but if all goes well, this conditional
       * will be removed
       */
	NETSTATGET netstatget = 0;
	NETFREE netfree = 0;
#endif /* 1 */
d206 6
a211 4
#if defined(OPENSSL_SYS_WINCE) && WCEPLATFORM!=MS_HPC_PRO
#ifndef CryptAcquireContext
#define CryptAcquireContext CryptAcquireContextW
#endif
d214 2
a215 1
	if (CryptAcquireContext(&hProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
d221 3
a223 3
#endif

#ifndef OPENSSL_SYS_WINCE
d237 12
a249 10
	/* load functions dynamically - not available on all systems */
	advapi = LoadLibrary(TEXT("ADVAPI32.DLL"));
	kernel = LoadLibrary(TEXT("KERNEL32.DLL"));
	user = LoadLibrary(TEXT("USER32.DLL"));
	netapi = LoadLibrary(TEXT("NETAPI32.DLL"));

#if 1 /* There was previously a problem with NETSTATGET.  Currently, this
       * section is still experimental, but if all goes well, this conditional
       * will be removed
       */
a278 1
#endif /* 1 */
d354 1
a354 1
		if (acquire(&hProvider, 0, 0, PROV_RSA_FULL,
d360 1
d374 1
d386 3
a388 1
	if (user)
d401 1
a401 1
			h = win();
d466 1
d498 1
d516 2
a517 2
						&hlist));
			
d524 2
d529 1
a529 1
				while (process_next(handle, &p));
d537 1
d541 1
a541 1
				while (thread_next(handle, &t));
d549 1
d553 2
a554 1
				while (module_next(handle, &m));
d559 1
d564 1
d703 3
@


1.6
log
@merge 0.9.7d
@
text
@d128 1
a128 1
#define INTEL_DEF_PROV TEXT("Intel Hardware Cryptographic Service Provider")
d155 1
a155 1
typedef BOOL (WINAPI *CRYPTACQUIRECONTEXT)(HCRYPTPROV *, LPCTSTR, LPCTSTR,
d197 1
a197 1
	CRYPTACQUIRECONTEXT acquire = 0;
d216 3
d229 15
a249 1
#ifndef OPENSSL_SYS_WINCE
d256 2
a257 2
		netstatget = (NETSTATGET) GetProcAddress(netapi,TEXT("NetStatisticsGet"));
		netfree = (NETFREE) GetProcAddress(netapi,TEXT("NetApiBufferFree"));
d284 1
a284 3
#endif /* !OPENSSL_SYS_WINCE */
 
#ifndef OPENSSL_SYS_WINCE
a338 1
#endif /* !OPENSSL_SYS_WINCE */
d342 7
a348 2
		acquire = (CRYPTACQUIRECONTEXT) GetProcAddress(advapi,
			TEXT("CryptAcquireContextA"));
d350 1
a350 1
			TEXT("CryptGenRandom"));
d352 1
a352 1
			TEXT("CryptReleaseContext"));
a388 11
	/* timer data */
	readtimer();
	
	/* memory usage statistics */
	GlobalMemoryStatus(&m);
	RAND_add(&m, sizeof(m), 1);

	/* process ID */
	w = GetCurrentProcessId();
	RAND_add(&w, sizeof(w), 1);

d395 3
a397 3
		win = (GETFOREGROUNDWINDOW) GetProcAddress(user, TEXT("GetForegroundWindow"));
		cursor = (GETCURSORINFO) GetProcAddress(user, TEXT("GetCursorInfo"));
		queue = (GETQUEUESTATUS) GetProcAddress(user, TEXT("GetQueueStatus"));
d469 1
a469 1
			GetProcAddress(kernel, TEXT("CreateToolhelp32Snapshot"));
d471 11
a481 11
			GetProcAddress(kernel, TEXT("CloseToolhelp32Snapshot"));
		heap_first = (HEAP32FIRST) GetProcAddress(kernel, TEXT("Heap32First"));
		heap_next = (HEAP32NEXT) GetProcAddress(kernel, TEXT("Heap32Next"));
		heaplist_first = (HEAP32LIST) GetProcAddress(kernel, TEXT("Heap32ListFirst"));
		heaplist_next = (HEAP32LIST) GetProcAddress(kernel, TEXT("Heap32ListNext"));
		process_first = (PROCESS32) GetProcAddress(kernel, TEXT("Process32First"));
		process_next = (PROCESS32) GetProcAddress(kernel, TEXT("Process32Next"));
		thread_first = (THREAD32) GetProcAddress(kernel, TEXT("Thread32First"));
		thread_next = (THREAD32) GetProcAddress(kernel, TEXT("Thread32Next"));
		module_first = (MODULE32) GetProcAddress(kernel, TEXT("Module32First"));
		module_next = (MODULE32) GetProcAddress(kernel, TEXT("Module32Next"));
d557 12
d630 1
a630 1
#if defined(_MSC_VER) && !defined(OPENSSL_SYS_WINCE)
d683 1
a683 1
#ifndef OPENSSL_SYS_WINCE
@


1.5
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d649 1
a649 1
 * <URL:http://www.microsoft.com/kb/developr/win_dk/q97193.htm>;
@


1.4
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d165 1
d435 1
a435 1
     * revised version at http://www.cryptoengines.com/~peter/06_random.pdf
d444 1
d462 2
d479 1
a479 1
			!= NULL)
d541 4
a544 2

			CloseHandle(handle);
@


1.3
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d128 1
a128 1
#define INTEL_DEF_PROV "Intel Hardware Cryptographic Service Provider"
d173 1
d175 1
d214 11
d226 4
a229 4
	advapi = LoadLibrary("ADVAPI32.DLL");
	kernel = LoadLibrary("KERNEL32.DLL");
	user = LoadLibrary("USER32.DLL");
	netapi = LoadLibrary("NETAPI32.DLL");
d231 1
d238 2
a239 2
		netstatget = (NETSTATGET) GetProcAddress(netapi,"NetStatisticsGet");
		netfree = (NETFREE) GetProcAddress(netapi,"NetApiBufferFree");
d266 1
d268 1
d299 1
a299 1
			rc = RegQueryValueEx(HKEY_PERFORMANCE_DATA, "Global",
d306 1
a306 1
                         */
d309 9
d323 1
d328 1
a328 1
			"CryptAcquireContextA");
d330 1
a330 1
			"CryptGenRandom");
d332 1
a332 1
			"CryptReleaseContext");
d386 3
a388 3
		win = (GETFOREGROUNDWINDOW) GetProcAddress(user, "GetForegroundWindow");
		cursor = (GETCURSORINFO) GetProcAddress(user, "GetCursorInfo");
		queue = (GETQUEUESTATUS) GetProcAddress(user, "GetQueueStatus");
d459 11
a469 11
			GetProcAddress(kernel, "CreateToolhelp32Snapshot");
		heap_first = (HEAP32FIRST) GetProcAddress(kernel, "Heap32First");
		heap_next = (HEAP32NEXT) GetProcAddress(kernel, "Heap32Next");
		heaplist_first = (HEAP32LIST) GetProcAddress(kernel, "Heap32ListFirst");
		heaplist_next = (HEAP32LIST) GetProcAddress(kernel, "Heap32ListNext");
		process_first = (PROCESS32) GetProcAddress(kernel, "Process32First");
		process_next = (PROCESS32) GetProcAddress(kernel, "Process32Next");
		thread_first = (THREAD32) GetProcAddress(kernel, "Thread32First");
		thread_next = (THREAD32) GetProcAddress(kernel, "Thread32Next");
		module_first = (MODULE32) GetProcAddress(kernel, "Module32First");
		module_next = (MODULE32) GetProcAddress(kernel, "Module32Next");
d604 1
a604 1
#ifdef _MSC_VER
d657 1
d671 1
a671 1
  hScrDC = CreateDC("DISPLAY", NULL, NULL, NULL);
d718 1
@


1.2
log
@openssl-engine-0.9.6a merge
@
text
@d116 1
a116 1
#if defined(WINDOWS) || defined(WIN32)
d257 4
d297 1
d318 2
a319 2
				RAND_add(buf, sizeof(buf), sizeof(buf));
#ifdef DEBUG
d332 1
a332 1
#ifdef DEBUG
d469 1
a469 1
						int entrycnt = 50;
d518 1
a518 1
#ifdef DEBUG
a690 46
}

#else /* Unix version */

#include <time.h>

int RAND_poll(void)
{
	unsigned long l;
	pid_t curr_pid = getpid();
#ifdef DEVRANDOM
	FILE *fh;
#endif

#ifdef DEVRANDOM
	/* Use a random entropy pool device. Linux, FreeBSD and OpenBSD
	 * have this. Use /dev/urandom if you can as /dev/random may block
	 * if it runs out of random entries.  */

	if ((fh = fopen(DEVRANDOM, "r")) != NULL)
		{
		unsigned char tmpbuf[ENTROPY_NEEDED];
		int n;
		
		setvbuf(fh, NULL, _IONBF, 0);
		n=fread((unsigned char *)tmpbuf,1,ENTROPY_NEEDED,fh);
		fclose(fh);
		RAND_add(tmpbuf,sizeof tmpbuf,n);
		memset(tmpbuf,0,n);
		}
#endif

	/* put in some default random data, we need more than just this */
	l=curr_pid;
	RAND_add(&l,sizeof(l),0);
	l=getuid();
	RAND_add(&l,sizeof(l),0);

	l=time(NULL);
	RAND_add(&l,sizeof(l),0);

#ifdef DEVRANDOM
	return 1;
#else
	return 0;
#endif
@


1.1
log
@openssl-engine-0.9.6 merge
@
text
@d573 1
a573 1
#ifndef __GNUC__
d580 2
a581 1
	      rdtsc
d729 2
a731 1
	return 0;
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d116 1
a116 1
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32)
a256 4
	/* Wolfgang Marczy <WMarczy@@topcall.co.at> reports that
	 * the RegQueryValueEx call below can hang on NT4.0 (SP6).
	 * So we don't use this at all for now. */
#if 0
a292 1
#endif
d313 2
a314 2
				RAND_add(buf, sizeof(buf), 0);
#if 0
d327 1
a327 1
#if 0
d464 1
a464 1
						int entrycnt = 80;
d513 1
a513 1
#if 0
d573 1
a573 1
#ifdef _MSC_VER
d580 1
a580 2
	      _emit 0x0f
	      _emit 0x31
d685 45
@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@d128 1
a128 1
#define INTEL_DEF_PROV TEXT("Intel Hardware Cryptographic Service Provider")
a172 1
#ifndef OPENSSL_SYS_WINCE
a173 1
#endif
a211 11
#if defined(OPENSSL_SYS_WINCE) && WCEPLATFORM!=MS_HPC_PRO
	/* poll the CryptoAPI PRNG */
	/* The CryptoAPI returns sizeof(buf) bytes of randomness */
	if (CryptAcquireContext(&hProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
		{
		if (CryptGenRandom(hProvider, sizeof(buf), buf))
			RAND_add(buf, sizeof(buf), sizeof(buf));
		CryptReleaseContext(hProvider, 0); 
		}
#endif

d213 4
a216 4
	advapi = LoadLibrary(TEXT("ADVAPI32.DLL"));
	kernel = LoadLibrary(TEXT("KERNEL32.DLL"));
	user = LoadLibrary(TEXT("USER32.DLL"));
	netapi = LoadLibrary(TEXT("NETAPI32.DLL"));
a217 1
#ifndef OPENSSL_SYS_WINCE
d224 2
a225 2
		netstatget = (NETSTATGET) GetProcAddress(netapi,TEXT("NetStatisticsGet"));
		netfree = (NETFREE) GetProcAddress(netapi,TEXT("NetApiBufferFree"));
a251 1
#endif /* !OPENSSL_SYS_WINCE */
a252 1
#ifndef OPENSSL_SYS_WINCE
d283 1
a283 1
			rc = RegQueryValueEx(HKEY_PERFORMANCE_DATA, TEXT("Global"),
d290 1
a290 1
			 */
a292 9

			/* Close the Registry Key to allow Windows to cleanup/close
			 * the open handle
			 * Note: The 'HKEY_PERFORMANCE_DATA' key is implicitly opened
			 *       when the RegQueryValueEx above is done.  However, if
			 *       it is not explicitly closed, it can cause disk
			 *       partition manipulation problems.
			 */
			RegCloseKey(HKEY_PERFORMANCE_DATA);
a297 1
#endif /* !OPENSSL_SYS_WINCE */
d302 1
a302 1
			TEXT("CryptAcquireContextA"));
d304 1
a304 1
			TEXT("CryptGenRandom"));
d306 1
a306 1
			TEXT("CryptReleaseContext"));
d360 3
a362 3
		win = (GETFOREGROUNDWINDOW) GetProcAddress(user, TEXT("GetForegroundWindow"));
		cursor = (GETCURSORINFO) GetProcAddress(user, TEXT("GetCursorInfo"));
		queue = (GETQUEUESTATUS) GetProcAddress(user, TEXT("GetQueueStatus"));
d433 11
a443 11
			GetProcAddress(kernel, TEXT("CreateToolhelp32Snapshot"));
		heap_first = (HEAP32FIRST) GetProcAddress(kernel, TEXT("Heap32First"));
		heap_next = (HEAP32NEXT) GetProcAddress(kernel, TEXT("Heap32Next"));
		heaplist_first = (HEAP32LIST) GetProcAddress(kernel, TEXT("Heap32ListFirst"));
		heaplist_next = (HEAP32LIST) GetProcAddress(kernel, TEXT("Heap32ListNext"));
		process_first = (PROCESS32) GetProcAddress(kernel, TEXT("Process32First"));
		process_next = (PROCESS32) GetProcAddress(kernel, TEXT("Process32Next"));
		thread_first = (THREAD32) GetProcAddress(kernel, TEXT("Thread32First"));
		thread_next = (THREAD32) GetProcAddress(kernel, TEXT("Thread32Next"));
		module_first = (MODULE32) GetProcAddress(kernel, TEXT("Module32First"));
		module_next = (MODULE32) GetProcAddress(kernel, TEXT("Module32Next"));
d578 1
a578 1
#if defined(_MSC_VER) && !defined(OPENSSL_SYS_WINCE)
a630 1
#ifndef OPENSSL_SYS_WINCE
d644 1
a644 1
  hScrDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
a690 1
#endif /* !OPENSSL_SYS_WINCE */
@


1.1.1.3
log
@import 0.9.7c
@
text
@a164 1
typedef BOOL (WINAPI *CLOSETOOLHELP32SNAPSHOT)(HANDLE);
d434 1
a434 1
	 * revised version at http://www.cryptoengines.com/~peter/06_random.pdf
a442 1
		CLOSETOOLHELP32SNAPSHOT close_snap;
a459 2
		close_snap = (CLOSETOOLHELP32SNAPSHOT)
			GetProcAddress(kernel, TEXT("CloseToolhelp32Snapshot"));
d475 1
a475 1
			!= INVALID_HANDLE_VALUE)
d537 2
a538 4
			if (close_snap)
				close_snap(handle);
			else
				CloseHandle(handle);
@


1.1.1.4
log
@import openssl-0.9.7d
@
text
@d649 1
a649 1
 * <URL:http://support.microsoft.com/default.aspx?scid=kb;[LN];97193>;
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d128 1
a128 1
#define INTEL_DEF_PROV L"Intel Hardware Cryptographic Service Provider"
d155 1
a155 1
typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTW)(HCRYPTPROV *, LPCWSTR, LPCWSTR,
d197 1
a197 1
	CRYPTACQUIRECONTEXTW acquire = 0;
a215 3
#ifndef CryptAcquireContext
#define CryptAcquireContext CryptAcquireContextW
#endif
a225 15
#ifndef OPENSSL_SYS_WINCE
	/*
	 * None of below libraries are present on Windows CE, which is
	 * why we #ifndef the whole section. This also excuses us from
	 * handling the GetProcAddress issue. The trouble is that in
	 * real Win32 API GetProcAddress is available in ANSI flavor
	 * only. In WinCE on the other hand GetProcAddress is a macro
	 * most commonly defined as GetProcAddressW, which accepts
	 * Unicode argument. If we were to call GetProcAddress under
	 * WinCE, I'd recommend to either redefine GetProcAddress as
	 * GetProcAddressA (there seem to be one in common CE spec) or
	 * implement own shim routine, which would accept ANSI argument
	 * and expand it to Unicode.
	 */

d232 1
d239 2
a240 2
		netstatget = (NETSTATGET) GetProcAddress(netapi,"NetStatisticsGet");
		netfree = (NETFREE) GetProcAddress(netapi,"NetApiBufferFree");
d267 3
a269 1

d324 1
d328 2
a329 7
		/*
		 * If it's available, then it's available in both ANSI
		 * and UNICODE flavors even in Win9x, documentation says.
		 * We favor Unicode...
		 */
		acquire = (CRYPTACQUIRECONTEXTW) GetProcAddress(advapi,
			"CryptAcquireContextW");
d331 1
a331 1
			"CryptGenRandom");
d333 1
a333 1
			"CryptReleaseContext");
d370 11
d387 3
a389 3
		win = (GETFOREGROUNDWINDOW) GetProcAddress(user, "GetForegroundWindow");
		cursor = (GETCURSORINFO) GetProcAddress(user, "GetCursorInfo");
		queue = (GETQUEUESTATUS) GetProcAddress(user, "GetQueueStatus");
d461 1
a461 1
			GetProcAddress(kernel, "CreateToolhelp32Snapshot");
d463 11
a473 11
			GetProcAddress(kernel, "CloseToolhelp32Snapshot");
		heap_first = (HEAP32FIRST) GetProcAddress(kernel, "Heap32First");
		heap_next = (HEAP32NEXT) GetProcAddress(kernel, "Heap32Next");
		heaplist_first = (HEAP32LIST) GetProcAddress(kernel, "Heap32ListFirst");
		heaplist_next = (HEAP32LIST) GetProcAddress(kernel, "Heap32ListNext");
		process_first = (PROCESS32) GetProcAddress(kernel, "Process32First");
		process_next = (PROCESS32) GetProcAddress(kernel, "Process32Next");
		thread_first = (THREAD32) GetProcAddress(kernel, "Thread32First");
		thread_next = (THREAD32) GetProcAddress(kernel, "Thread32Next");
		module_first = (MODULE32) GetProcAddress(kernel, "Module32First");
		module_next = (MODULE32) GetProcAddress(kernel, "Module32Next");
a548 12
#endif /* !OPENSSL_SYS_WINCE */

	/* timer data */
	readtimer();
	
	/* memory usage statistics */
	GlobalMemoryStatus(&m);
	RAND_add(&m, sizeof(m), 1);

	/* process ID */
	w = GetCurrentProcessId();
	RAND_add(&w, sizeof(w), 1);
d610 1
a610 1
#if defined(_MSC_VER) && defined(_M_X86)
d663 1
a663 1
#if !defined(OPENSSL_SYS_WINCE) && !defined(OPENSSL_SYS_WIN32_CYGWIN)
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@a123 4
/* Limit the time spent walking through the heap, processes, threads and modules to
   a maximum of 1000 miliseconds each, unless CryptoGenRandom failed */
#define MAXDELAY 1000

a154 1
#if !defined(OPENSSL_SYS_WINCE)
d166 1
a166 1
typedef BOOL (WINAPI *HEAP32FIRST)(LPHEAPENTRY32, DWORD, size_t);
d174 1
d176 1
a186 1
#endif /* !OPENSSL_SYS_WINCE */
d192 1
d194 13
a206 1
	int good = 0;
d215 4
a218 6
#if defined(OPENSSL_SYS_WINCE)
# if defined(_WIN32_WCE) && _WIN32_WCE>=300
/* Even though MSDN says _WIN32_WCE>=210, it doesn't seem to be available
 * in commonly available implementations prior 300... */
	{
	BYTE buf[64];
d221 1
a221 2
	if (CryptAcquireContextW(&hProvider, NULL, NULL, PROV_RSA_FULL,
				CRYPT_VERIFYCONTEXT))
d227 3
a229 3
	}
# endif
#else	/* OPENSSL_SYS_WINCE */
d243 1
a243 1
	{
d245 9
a253 11
	HMODULE advapi = LoadLibrary(TEXT("ADVAPI32.DLL"));
	HMODULE kernel = LoadLibrary(TEXT("KERNEL32.DLL"));
	HMODULE user = NULL;
	HMODULE netapi = LoadLibrary(TEXT("NETAPI32.DLL"));
	CRYPTACQUIRECONTEXTW acquire = NULL;
	CRYPTGENRANDOM gen = NULL;
	CRYPTRELEASECONTEXT release = NULL;
	NETSTATGET netstatget = NULL;
	NETFREE netfree = NULL;
	BYTE buf[64];

d283 1
d359 1
a359 1
		if (acquire(&hProvider, NULL, NULL, PROV_RSA_FULL,
a364 1
				good = 1;
a377 1
				good = 1;
d389 1
a389 3
	if ((osverinfo.dwPlatformId != VER_PLATFORM_WIN32_NT ||
	     !OPENSSL_isservice()) &&
	    (user = LoadLibrary(TEXT("USER32.DLL"))))
d402 1
a402 1
			HWND h = win();
a466 1
		DWORD stoptime = 0;
a497 1
			if (good) stoptime = GetTickCount() + MAXDELAY;
d515 2
a516 2
						&hlist) && GetTickCount() < stoptime);

a522 2
		
			if (good) stoptime = GetTickCount() + MAXDELAY;
d526 1
a526 1
				while (process_next(handle, &p) && GetTickCount() < stoptime);
a533 1
			if (good) stoptime = GetTickCount() + MAXDELAY;
d537 1
a537 1
				while (thread_next(handle, &t) && GetTickCount() < stoptime);
a544 1
			if (good) stoptime = GetTickCount() + MAXDELAY;
d548 1
a548 2
				while (module_next(handle, &m)
					       	&& (GetTickCount() < stoptime));
a552 1

a556 1
	}
a694 3

  if (GetVersion() >= 0x80000000 || !OPENSSL_isservice())
    return;
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@d466 1
a466 1
		DWORD starttime = 0;
a496 1
			ZeroMemory(&hlist, sizeof(HEAPLIST32));
d498 1
a498 2
			if (good) starttime = GetTickCount();
#ifdef _MSC_VER
a499 12
				{
				/*
				   following discussion on dev ML, exception on WinCE (or other Win
				   platform) is theoretically of unknown origin; prevent infinite
				   loop here when this theoretical case occurs; otherwise cope with
				   the expected (MSDN documented) exception-throwing behaviour of
				   Heap32Next() on WinCE.

				   based on patch in original message by Tanguy Fautré (2009/03/02)
			           Subject: RAND_poll() and CreateToolhelp32Snapshot() stability
			     */
				int ex_cnt_limit = 42; 
a502 3
					__try
						{
						ZeroMemory(&hentry, sizeof(HEAPENTRY32));
a512 1
						&& (!good || (GetTickCount()-starttime)<MAXDELAY)
d515 2
a516 33
						}
					__except (EXCEPTION_EXECUTE_HANDLER)
						{
							/* ignore access violations when walking the heap list */
							ex_cnt_limit--;
						}
					} while (heaplist_next(handle, &hlist) 
						&& (!good || (GetTickCount()-starttime)<MAXDELAY)
						&& ex_cnt_limit > 0);
				}

#else
			if (heaplist_first(handle, &hlist))
				{
				do
					{
					RAND_add(&hlist, hlist.dwSize, 3);
					hentry.dwSize = sizeof(HEAPENTRY32);
					if (heap_first(&hentry,
						hlist.th32ProcessID,
						hlist.th32HeapID))
						{
						int entrycnt = 80;
						do
							RAND_add(&hentry,
								hentry.dwSize, 5);
						while (heap_next(&hentry)
							&& --entrycnt > 0);
						}
					} while (heaplist_next(handle, &hlist) 
						&& (!good || (GetTickCount()-starttime)<MAXDELAY));
				}
#endif
d525 1
a525 1
			if (good) starttime = GetTickCount();
d529 1
a529 1
				while (process_next(handle, &p) && (!good || (GetTickCount()-starttime)<MAXDELAY));
d537 1
a537 1
			if (good) starttime = GetTickCount();
d541 1
a541 1
				while (thread_next(handle, &t) && (!good || (GetTickCount()-starttime)<MAXDELAY));
d549 1
a549 1
			if (good) starttime = GetTickCount();
d554 1
a554 1
					       	&& (!good || (GetTickCount()-starttime)<MAXDELAY));
d704 1
a704 1
  if (GetVersion() < 0x80000000 && OPENSSL_isservice()>0)
@


1.1.1.8
log
@Import OpenSSL 1.0.1g
@
text
@d753 1
a753 1
  if (check_winnt() && OPENSSL_isservice()>0)
@


