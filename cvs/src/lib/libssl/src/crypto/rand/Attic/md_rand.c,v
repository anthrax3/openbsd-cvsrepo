head	1.19;
access;
symbols
	butholakala:1.18
	openssl_1_0_1_g:1.1.1.10
	OPENBSD_5_5:1.17.0.8
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.4
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	openssl_1_0_1_c:1.1.1.9
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	openssl_1_0_0_f:1.1.1.8
	openssl_1_0_0_e:1.1.1.8
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	openssh_1_0_0_a:1.1.1.7
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	openssl_0_9_8_k:1.1.1.6
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	openssl_0_9_8_j:1.1.1.6
	openssl_0_9_8_h:1.1.1.5
	pre_openssl_0_9_8h:1.12
	OPENBSD_4_4:1.12.0.14
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.12
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.10
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.8
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.6
	OPENBSD_4_0_BASE:1.12
	openssl_0_9_7j:1.1.1.4
	openssl:1.1.1
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENSSL_0_9_7G:1.1.1.4
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENSSL_0_9_7D:1.1.1.3
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENSSL_0_9_7C:1.1.1.3
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.9.0.4
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.04.15.16.52.50;	author miod;	state dead;
branches;
next	1.18;

1.18
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.29.05.39.25;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.12.02.18.38;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.15.02.29.16;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.01.19.51.17;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.01.15.31.16;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.22.00.03.17;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.15.02.58.02;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.15.06.18.42;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.19.11.11.13;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.24.20.09.59;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.33;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.56;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.56;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.48;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.35.43;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.04.29.05.37.14;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.06.12.15.46;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.01.09.12.13.59;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2011.11.03.02.32.13;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2012.10.13.21.23.42;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Replace the old OpenSSL PRNG by direct use of arc4random_buf(), keeping the
existing RAND interfaces unchanged.

All interfaces allowing external feed or seed of the RNG (either from a file
or a local entropy gathering daemon) are kept for ABI compatibility, but are
no longer do anything.

While the OpenSSL PRNG was required 15+ years ago when many systems lacked
proper entropy collection, things have evolved and one can reasonably assume
it is better to use the kernel (system global) entropy pool rather than trying
to build one's own and having to compensate for thread scheduling...

<RANT>
Whoever thought that RAND_screen(), feeding the PRNG with the contents of the
local workstation's display, under Win32, was a smart idea, ought to be banned
from security programming.
</RANT>

ok beck@@ deraadt@@ tedu@@
@
text
@/* crypto/rand/md_rand.c */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#define OPENSSL_FIPSEVP

#ifdef MD_RAND_DEBUG
# ifndef NDEBUG
#   define NDEBUG
# endif
#endif

#include <assert.h>
#include <stdio.h>
#include <string.h>

#include "e_os.h"

#include <openssl/crypto.h>
#include <openssl/rand.h>
#include "rand_lcl.h"

#include <openssl/err.h>

#ifdef BN_DEBUG
# define PREDICT
#endif

/* #define PREDICT	1 */

#define STATE_SIZE	1023
static int state_num=0,state_index=0;
static unsigned char state[STATE_SIZE+MD_DIGEST_LENGTH];
static unsigned char md[MD_DIGEST_LENGTH];
static long md_count[2]={0,0};
static double entropy=0;
static int initialized=0;

static unsigned int crypto_lock_rand = 0; /* may be set only when a thread
                                           * holds CRYPTO_LOCK_RAND
                                           * (to prevent double locking) */
/* access to lockin_thread is synchronized by CRYPTO_LOCK_RAND2 */
static CRYPTO_THREADID locking_threadid; /* valid iff crypto_lock_rand is set */


#ifdef PREDICT
int rand_predictable=0;
#endif

const char RAND_version[]="RAND" OPENSSL_VERSION_PTEXT;

static void ssleay_rand_cleanup(void);
static void ssleay_rand_seed(const void *buf, int num);
static void ssleay_rand_add(const void *buf, int num, double add_entropy);
static int ssleay_rand_bytes(unsigned char *buf, int num, int pseudo);
static int ssleay_rand_nopseudo_bytes(unsigned char *buf, int num);
static int ssleay_rand_pseudo_bytes(unsigned char *buf, int num);
static int ssleay_rand_status(void);

RAND_METHOD rand_ssleay_meth={
	ssleay_rand_seed,
	ssleay_rand_nopseudo_bytes,
	ssleay_rand_cleanup,
	ssleay_rand_add,
	ssleay_rand_pseudo_bytes,
	ssleay_rand_status
	}; 

RAND_METHOD *RAND_SSLeay(void)
	{
	return(&rand_ssleay_meth);
	}

static void ssleay_rand_cleanup(void)
	{
	OPENSSL_cleanse(state,sizeof(state));
	state_num=0;
	state_index=0;
	OPENSSL_cleanse(md,MD_DIGEST_LENGTH);
	md_count[0]=0;
	md_count[1]=0;
	entropy=0;
	initialized=0;
	}

static void ssleay_rand_add(const void *buf, int num, double add)
	{
	int i,j,k,st_idx;
	long md_c[2];
	unsigned char local_md[MD_DIGEST_LENGTH];
	EVP_MD_CTX m;
	int do_not_lock;

	if (!num)
		return;

	/*
	 * (Based on the rand(3) manpage)
	 *
	 * The input is chopped up into units of 20 bytes (or less for
	 * the last block).  Each of these blocks is run through the hash
	 * function as follows:  The data passed to the hash function
	 * is the current 'md', the same number of bytes from the 'state'
	 * (the location determined by in incremented looping index) as
	 * the current 'block', the new key data 'block', and 'count'
	 * (which is incremented after each use).
	 * The result of this is kept in 'md' and also xored into the
	 * 'state' at the same locations that were used as input into the
         * hash function.
	 */

	/* check if we already have the lock */
	if (crypto_lock_rand)
		{
		CRYPTO_THREADID cur;
		CRYPTO_THREADID_current(&cur);
		CRYPTO_r_lock(CRYPTO_LOCK_RAND2);
		do_not_lock = !CRYPTO_THREADID_cmp(&locking_threadid, &cur);
		CRYPTO_r_unlock(CRYPTO_LOCK_RAND2);
		}
	else
		do_not_lock = 0;

	if (!do_not_lock) CRYPTO_w_lock(CRYPTO_LOCK_RAND);
	st_idx=state_index;

	/* use our own copies of the counters so that even
	 * if a concurrent thread seeds with exactly the
	 * same data and uses the same subarray there's _some_
	 * difference */
	md_c[0] = md_count[0];
	md_c[1] = md_count[1];

	memcpy(local_md, md, sizeof md);

	/* state_index <= state_num <= STATE_SIZE */
	state_index += num;
	if (state_index >= STATE_SIZE)
		{
		state_index%=STATE_SIZE;
		state_num=STATE_SIZE;
		}
	else if (state_num < STATE_SIZE)	
		{
		if (state_index > state_num)
			state_num=state_index;
		}
	/* state_index <= state_num <= STATE_SIZE */

	/* state[st_idx], ..., state[(st_idx + num - 1) % STATE_SIZE]
	 * are what we will use now, but other threads may use them
	 * as well */

	md_count[1] += (num / MD_DIGEST_LENGTH) + (num % MD_DIGEST_LENGTH > 0);

	if (!do_not_lock) CRYPTO_w_unlock(CRYPTO_LOCK_RAND);

	EVP_MD_CTX_init(&m);
	for (i=0; i<num; i+=MD_DIGEST_LENGTH)
		{
		j=(num-i);
		j=(j > MD_DIGEST_LENGTH)?MD_DIGEST_LENGTH:j;

		MD_Init(&m);
		MD_Update(&m,local_md,MD_DIGEST_LENGTH);
		k=(st_idx+j)-STATE_SIZE;
		if (k > 0)
			{
			MD_Update(&m,&(state[st_idx]),j-k);
			MD_Update(&m,&(state[0]),k);
			}
		else
			MD_Update(&m,&(state[st_idx]),j);

		/* DO NOT REMOVE THE FOLLOWING CALL TO MD_Update()! */
		MD_Update(&m,buf,j);
		/* We know that line may cause programs such as
		   purify and valgrind to complain about use of
		   uninitialized data.  The problem is not, it's
		   with the caller.  Removing that line will make
		   sure you get really bad randomness and thereby
		   other problems such as very insecure keys. */

		MD_Update(&m,(unsigned char *)&(md_c[0]),sizeof(md_c));
		MD_Final(&m,local_md);
		md_c[1]++;

		buf=(const char *)buf + j;

		for (k=0; k<j; k++)
			{
			/* Parallel threads may interfere with this,
			 * but always each byte of the new state is
			 * the XOR of some previous value of its
			 * and local_md (itermediate values may be lost).
			 * Alway using locking could hurt performance more
			 * than necessary given that conflicts occur only
			 * when the total seeding is longer than the random
			 * state. */
			state[st_idx++]^=local_md[k];
			if (st_idx >= STATE_SIZE)
				st_idx=0;
			}
		}
	EVP_MD_CTX_cleanup(&m);

	if (!do_not_lock) CRYPTO_w_lock(CRYPTO_LOCK_RAND);
	/* Don't just copy back local_md into md -- this could mean that
	 * other thread's seeding remains without effect (except for
	 * the incremented counter).  By XORing it we keep at least as
	 * much entropy as fits into md. */
	for (k = 0; k < (int)sizeof(md); k++)
		{
		md[k] ^= local_md[k];
		}
	if (entropy < ENTROPY_NEEDED) /* stop counting when we have enough */
	    entropy += add;
	if (!do_not_lock) CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
	
#if !defined(OPENSSL_THREADS) && !defined(OPENSSL_SYS_WIN32)
	assert(md_c[1] == md_count[1]);
#endif
	}

static void ssleay_rand_seed(const void *buf, int num)
	{
	ssleay_rand_add(buf, num, (double)num);
	}

static int ssleay_rand_bytes(unsigned char *buf, int num, int pseudo)
	{
	static volatile int stirred_pool = 0;
	int i,j,k,st_num,st_idx;
	int num_ceil;
	int ok;
	long md_c[2];
	unsigned char local_md[MD_DIGEST_LENGTH];
	EVP_MD_CTX m;
#ifndef GETPID_IS_MEANINGLESS
	pid_t curr_pid = getpid();
#endif
	int do_stir_pool = 0;

#ifdef PREDICT
	if (rand_predictable)
		{
		static unsigned char val=0;

		for (i=0; i<num; i++)
			buf[i]=val++;
		return(1);
		}
#endif

	if (num <= 0)
		return 1;

	EVP_MD_CTX_init(&m);
	/* round upwards to multiple of MD_DIGEST_LENGTH/2 */
	num_ceil = (1 + (num-1)/(MD_DIGEST_LENGTH/2)) * (MD_DIGEST_LENGTH/2);

	/*
	 * (Based on the rand(3) manpage:)
	 *
	 * For each group of 10 bytes (or less), we do the following:
	 *
	 * Input into the hash function the local 'md' (which is initialized from
	 * the global 'md' before any bytes are generated), the bytes that are to
	 * be overwritten by the random bytes, and bytes from the 'state'
	 * (incrementing looping index). From this digest output (which is kept
	 * in 'md'), the top (up to) 10 bytes are returned to the caller and the
	 * bottom 10 bytes are xored into the 'state'.
	 * 
	 * Finally, after we have finished 'num' random bytes for the
	 * caller, 'count' (which is incremented) and the local and global 'md'
	 * are fed into the hash function and the results are kept in the
	 * global 'md'.
	 */
#ifdef OPENSSL_FIPS
	/* NB: in FIPS mode we are already under a lock */
	if (!FIPS_mode())
#endif
		CRYPTO_w_lock(CRYPTO_LOCK_RAND);

	/* prevent ssleay_rand_bytes() from trying to obtain the lock again */
	CRYPTO_w_lock(CRYPTO_LOCK_RAND2);
	CRYPTO_THREADID_current(&locking_threadid);
	CRYPTO_w_unlock(CRYPTO_LOCK_RAND2);
	crypto_lock_rand = 1;

	if (!initialized)
		{
		RAND_poll();
		initialized = 1;
		}
	
	if (!stirred_pool)
		do_stir_pool = 1;
	
	ok = (entropy >= ENTROPY_NEEDED);
	if (!ok)
		{
		/* If the PRNG state is not yet unpredictable, then seeing
		 * the PRNG output may help attackers to determine the new
		 * state; thus we have to decrease the entropy estimate.
		 * Once we've had enough initial seeding we don't bother to
		 * adjust the entropy count, though, because we're not ambitious
		 * to provide *information-theoretic* randomness.
		 *
		 * NOTE: This approach fails if the program forks before
		 * we have enough entropy. Entropy should be collected
		 * in a separate input pool and be transferred to the
		 * output pool only when the entropy limit has been reached.
		 */
		entropy -= num;
		if (entropy < 0)
			entropy = 0;
		}

	if (do_stir_pool)
		{
		/* In the output function only half of 'md' remains secret,
		 * so we better make sure that the required entropy gets
		 * 'evenly distributed' through 'state', our randomness pool.
		 * The input function (ssleay_rand_add) chains all of 'md',
		 * which makes it more suitable for this purpose.
		 */

		int n = STATE_SIZE; /* so that the complete pool gets accessed */
		while (n > 0)
			{
#if MD_DIGEST_LENGTH > 20
# error "Please adjust DUMMY_SEED."
#endif
#define DUMMY_SEED "...................." /* at least MD_DIGEST_LENGTH */
			/* Note that the seed does not matter, it's just that
			 * ssleay_rand_add expects to have something to hash. */
			ssleay_rand_add(DUMMY_SEED, MD_DIGEST_LENGTH, 0.0);
			n -= MD_DIGEST_LENGTH;
			}
		if (ok)
			stirred_pool = 1;
		}

	st_idx=state_index;
	st_num=state_num;
	md_c[0] = md_count[0];
	md_c[1] = md_count[1];
	memcpy(local_md, md, sizeof md);

	state_index+=num_ceil;
	if (state_index > state_num)
		state_index %= state_num;

	/* state[st_idx], ..., state[(st_idx + num_ceil - 1) % st_num]
	 * are now ours (but other threads may use them too) */

	md_count[0] += 1;

	/* before unlocking, we must clear 'crypto_lock_rand' */
	crypto_lock_rand = 0;
#ifdef OPENSSL_FIPS
	if (!FIPS_mode())
#endif
		CRYPTO_w_unlock(CRYPTO_LOCK_RAND);

	while (num > 0)
		{
		/* num_ceil -= MD_DIGEST_LENGTH/2 */
		j=(num >= MD_DIGEST_LENGTH/2)?MD_DIGEST_LENGTH/2:num;
		num-=j;
		MD_Init(&m);
#ifndef GETPID_IS_MEANINGLESS
		if (curr_pid) /* just in the first iteration to save time */
			{
			MD_Update(&m,(unsigned char*)&curr_pid,sizeof curr_pid);
			curr_pid = 0;
			}
#endif
		MD_Update(&m,local_md,MD_DIGEST_LENGTH);
		MD_Update(&m,(unsigned char *)&(md_c[0]),sizeof(md_c));

#ifndef PURIFY /* purify complains */
		/* The following line uses the supplied buffer as a small
		 * source of entropy: since this buffer is often uninitialised
		 * it may cause programs such as purify or valgrind to
		 * complain. So for those builds it is not used: the removal
		 * of such a small source of entropy has negligible impact on
		 * security.
		 */
		MD_Update(&m,buf,j);
#endif

		k=(st_idx+MD_DIGEST_LENGTH/2)-st_num;
		if (k > 0)
			{
			MD_Update(&m,&(state[st_idx]),MD_DIGEST_LENGTH/2-k);
			MD_Update(&m,&(state[0]),k);
			}
		else
			MD_Update(&m,&(state[st_idx]),MD_DIGEST_LENGTH/2);
		MD_Final(&m,local_md);

		for (i=0; i<MD_DIGEST_LENGTH/2; i++)
			{
			state[st_idx++]^=local_md[i]; /* may compete with other threads */
			if (st_idx >= st_num)
				st_idx=0;
			if (i < j)
				*(buf++)=local_md[i+MD_DIGEST_LENGTH/2];
			}
		}

	MD_Init(&m);
	MD_Update(&m,(unsigned char *)&(md_c[0]),sizeof(md_c));
	MD_Update(&m,local_md,MD_DIGEST_LENGTH);
#ifdef OPENSSL_FIPS
	if (!FIPS_mode())
#endif
		CRYPTO_w_lock(CRYPTO_LOCK_RAND);
	MD_Update(&m,md,MD_DIGEST_LENGTH);
	MD_Final(&m,md);
#ifdef OPENSSL_FIPS
	if (!FIPS_mode())
#endif
		CRYPTO_w_unlock(CRYPTO_LOCK_RAND);

	EVP_MD_CTX_cleanup(&m);
	if (ok)
		return(1);
	else if (pseudo)
		return 0;
	else 
		{
		RANDerr(RAND_F_SSLEAY_RAND_BYTES,RAND_R_PRNG_NOT_SEEDED);
		ERR_add_error_data(1, "You need to read the OpenSSL FAQ, "
			"http://www.openssl.org/support/faq.html");
		return(0);
		}
	}

static int ssleay_rand_nopseudo_bytes(unsigned char *buf, int num)
	{
	return ssleay_rand_bytes(buf, num, 0);
	}

/* pseudo-random bytes that are guaranteed to be unique but not
   unpredictable */
static int ssleay_rand_pseudo_bytes(unsigned char *buf, int num) 
	{
	return ssleay_rand_bytes(buf, num, 1);
	}

static int ssleay_rand_status(void)
	{
	CRYPTO_THREADID cur;
	int ret;
	int do_not_lock;

	CRYPTO_THREADID_current(&cur);
	/* check if we already have the lock
	 * (could happen if a RAND_poll() implementation calls RAND_status()) */
	if (crypto_lock_rand)
		{
		CRYPTO_r_lock(CRYPTO_LOCK_RAND2);
		do_not_lock = !CRYPTO_THREADID_cmp(&locking_threadid, &cur);
		CRYPTO_r_unlock(CRYPTO_LOCK_RAND2);
		}
	else
		do_not_lock = 0;
	
	if (!do_not_lock)
		{
		CRYPTO_w_lock(CRYPTO_LOCK_RAND);
		
		/* prevent ssleay_rand_bytes() from trying to obtain the lock again */
		CRYPTO_w_lock(CRYPTO_LOCK_RAND2);
		CRYPTO_THREADID_cpy(&locking_threadid, &cur);
		CRYPTO_w_unlock(CRYPTO_LOCK_RAND2);
		crypto_lock_rand = 1;
		}
	
	if (!initialized)
		{
		RAND_poll();
		initialized = 1;
		}

	ret = entropy >= ENTROPY_NEEDED;

	if (!do_not_lock)
		{
		/* before unlocking, we must clear 'crypto_lock_rand' */
		crypto_lock_rand = 0;
		
		CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
		}
	
	return ret;
	}
@


1.18
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@@


1.17
log
@resolve conflicts
@
text
@d126 1
a129 1
#include <openssl/crypto.h>
d201 3
d386 5
a390 2

	CRYPTO_w_lock(CRYPTO_LOCK_RAND);
d469 4
a472 1
	CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
d524 4
a527 1
	CRYPTO_w_lock(CRYPTO_LOCK_RAND);
d530 4
a533 1
	CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
@


1.16
log
@openssl-1.0.0e: resolve conflicts
@
text
@d112 2
d162 2
a163 1
static int ssleay_rand_bytes(unsigned char *buf, int num);
d169 1
a169 1
	ssleay_rand_bytes,
d334 1
a334 1
static int ssleay_rand_bytes(unsigned char *buf, int num)
d523 3
a525 1
	else
d534 5
d543 1
a543 12
	int ret;
	unsigned long err;

	ret = RAND_bytes(buf, num);
	if (ret == 0)
		{
		err = ERR_peek_error();
		if (ERR_GET_LIB(err) == ERR_LIB_RAND &&
		    ERR_GET_REASON(err) == RAND_R_PRNG_NOT_SEEDED)
			ERR_clear_error();
		}
	return (ret);
@


1.15
log
@resolve conflicts, fix local changes
@
text
@d479 7
a485 1
		/* DO NOT REMOVE THE FOLLOWING CALL TO MD_Update()! */
a486 3
		/* We know that line may cause programs such as
		   purify and valgrind to complain about use of
		   uninitialized data.  */
@


1.14
log
@resolve conflicts
@
text
@a128 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

d148 1
a148 1
static unsigned long locking_thread = 0; /* valid iff crypto_lock_rand is set */
d216 2
d219 1
a219 1
		do_not_lock = (locking_thread == CRYPTO_thread_id());
d275 2
a276 1
			
d278 7
a344 8
#ifdef OPENSSL_FIPS
	if(FIPS_mode())
	    {
	    FIPSerr(FIPS_F_SSLEAY_RAND_BYTES,FIPS_R_NON_FIPS_METHOD);
	    return 0;
	    }
#endif

d385 1
a385 1
	locking_thread = CRYPTO_thread_id();
d477 7
a483 2
#ifndef PURIFY
		MD_Update(&m,buf,j); /* purify complains */
d485 1
d546 1
d550 1
d556 1
a556 1
		do_not_lock = (locking_thread == CRYPTO_thread_id());
d568 1
a568 1
		locking_thread = CRYPTO_thread_id();
@


1.13
log
@resolve conflicts
@
text
@d129 4
d338 8
@


1.12
log
@resolve conflicts
@
text
@a128 1
#include <openssl/fips.h>
d155 1
a155 1
const char *RAND_version="RAND" OPENSSL_VERSION_PTEXT;
d303 1
a303 1
	for (k = 0; k < sizeof md; k++)
d318 1
a318 1
	ssleay_rand_add(buf, num, num);
a334 8
#ifdef OPENSSL_FIPS
	if(FIPS_mode())
	    {
	    FIPSerr(FIPS_F_SSLEAY_RAND_BYTES,FIPS_R_NON_FIPS_METHOD);
	    return 0;
	    }
#endif

d523 1
a523 1
			(void)ERR_get_error();
@


1.11
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d129 1
d335 8
@


1.10
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d180 1
a180 1
	memset(state,0,sizeof(state));
d183 1
a183 1
	memset(md,0,MD_DIGEST_LENGTH);
@


1.9
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
d122 1
a122 1
#include "openssl/e_os.h"
d147 1
d195 1
a195 1
	MD_CTX m;
d214 8
a221 1
	do_not_lock = crypto_lock_rand && (locking_thread == CRYPTO_thread_id());
d257 1
d276 1
a276 1
		MD_Final(local_md,&m);
d296 1
a296 1
	memset((char *)&m,0,sizeof(m));
d311 1
a311 1
#if !defined(THREADS) && !defined(WIN32)
d329 1
a329 1
	MD_CTX m;
d348 2
a349 1
	
d374 3
a377 1
	locking_thread = CRYPTO_thread_id();
a449 1
	locking_thread = 0;
d478 1
a478 1
		MD_Final(local_md,&m);
d495 1
a495 1
	MD_Final(md,&m);
d498 1
a498 1
	memset(&m,0,sizeof(m));
d535 8
a542 1
	do_not_lock = crypto_lock_rand && (locking_thread == CRYPTO_thread_id());
d549 3
a552 1
		locking_thread = CRYPTO_thread_id();
a566 1
		locking_thread = 0;
@


1.8
log
@http://www.openssl.org/news/secadv_prng.txt; ok beck@@
@
text
@d144 5
a148 4
/* This should be set to 1 only when ssleay_rand_add() is called inside
   an already locked state, so it doesn't try to lock and thereby cause
   a hang.  And it should always be reset back to 0 before unlocking. */
static int add_do_not_lock=0;
d195 1
d212 4
a215 1
	if (!add_do_not_lock) CRYPTO_w_lock(CRYPTO_LOCK_RAND);
d247 1
a247 1
	if (!add_do_not_lock) CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
d289 1
a289 1
	if (!add_do_not_lock) CRYPTO_w_lock(CRYPTO_LOCK_RAND);
d300 1
a300 1
	if (!add_do_not_lock) CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
d348 7
a354 8
	 * Input into the hash function the top 10 bytes from the
	 * local 'md' (which is initialized from the global 'md'
	 * before any bytes are generated), the bytes that are
	 * to be overwritten by the random bytes, and bytes from the
	 * 'state' (incrementing looping index).  From this digest output
	 * (which is kept in 'md'), the top (up to) 10 bytes are
	 * returned to the caller and the bottom (up to) 10 bytes are xored
	 * into the 'state'.
d361 6
d368 1
d370 3
a372 6

	CRYPTO_w_lock(CRYPTO_LOCK_RAND);
	add_do_not_lock = 1;	/* Since we call ssleay_rand_add while in
				   this locked state. */

	initialized = 1;
d398 5
a402 5
		/* Our output function chains only half of 'md', so we better
		 * make sure that the required entropy gets 'evenly distributed'
		 * through 'state', our randomness pool.  The input function
		 * (ssleay_rand_add) chains all of 'md', which makes it more
		 * suitable for this purpose.
d436 3
a438 2
	add_do_not_lock = 0;	/* If this would ever be forgotten, we can
				   expect any evil god to eat our souls. */
d504 1
d509 1
a509 1
		long err = ERR_peek_error();
d520 1
d522 13
d536 1
d538 2
a540 2
	CRYPTO_w_lock(CRYPTO_LOCK_RAND);
	initialized = 1;
a541 1
	CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
d543 9
@


1.7
log
@openssl-engine-0.9.6a merge
@
text
@d311 1
d332 6
d419 1
a419 1
	state_index+=num;
d423 1
a423 1
	/* state[st_idx], ..., state[(st_idx + num - 1) % st_num]
d434 1
d445 1
a445 1
		MD_Update(&m,&(local_md[MD_DIGEST_LENGTH/2]),MD_DIGEST_LENGTH/2);
d450 1
a450 1
		k=(st_idx+j)-st_num;
d453 1
a453 1
			MD_Update(&m,&(state[st_idx]),j-k);
d457 1
a457 1
			MD_Update(&m,&(state[st_idx]),j);
d460 1
a460 1
		for (i=0; i<j; i++)
a462 1
			*(buf++)=local_md[i+MD_DIGEST_LENGTH/2];
d465 2
@


1.6
log
@openssl-engine-0.9.6 merge
@
text
@d485 1
a485 1
	int ret, err;
d490 1
a490 1
		err = ERR_peek_error();
@


1.5
log
@OpenSSL 0.9.5a merge
@
text
@d112 1
a112 3
#define ENTROPY_NEEDED 16  /* require 128 bits = 16 bytes of randomness */

#ifndef MD_RAND_DEBUG
a119 1
#include <time.h>
d124 3
a129 56
#if !defined(USE_MD5_RAND) && !defined(USE_SHA1_RAND) && !defined(USE_MDC2_RAND) && !defined(USE_MD2_RAND)
#if !defined(NO_SHA) && !defined(NO_SHA1)
#define USE_SHA1_RAND
#elif !defined(NO_MD5)
#define USE_MD5_RAND
#elif !defined(NO_MDC2) && !defined(NO_DES)
#define USE_MDC2_RAND
#elif !defined(NO_MD2)
#define USE_MD2_RAND
#else
#error No message digest algorithm available
#endif
#endif

/* Changed how the state buffer used.  I now attempt to 'wrap' such
 * that I don't run over the same locations the next time  go through
 * the 1023 bytes - many thanks to
 * Robert J. LeBlanc <rjl@@renaissoft.com> for his comments
 */

#if defined(USE_MD5_RAND)
#include <openssl/md5.h>
#define MD_DIGEST_LENGTH	MD5_DIGEST_LENGTH
#define MD_CTX			MD5_CTX
#define MD_Init(a)		MD5_Init(a)
#define MD_Update(a,b,c)	MD5_Update(a,b,c)
#define	MD_Final(a,b)		MD5_Final(a,b)
#define	MD(a,b,c)		MD5(a,b,c)
#elif defined(USE_SHA1_RAND)
#include <openssl/sha.h>
#define MD_DIGEST_LENGTH	SHA_DIGEST_LENGTH
#define MD_CTX			SHA_CTX
#define MD_Init(a)		SHA1_Init(a)
#define MD_Update(a,b,c)	SHA1_Update(a,b,c)
#define	MD_Final(a,b)		SHA1_Final(a,b)
#define	MD(a,b,c)		SHA1(a,b,c)
#elif defined(USE_MDC2_RAND)
#include <openssl/mdc2.h>
#define MD_DIGEST_LENGTH	MDC2_DIGEST_LENGTH
#define MD_CTX			MDC2_CTX
#define MD_Init(a)		MDC2_Init(a)
#define MD_Update(a,b,c)	MDC2_Update(a,b,c)
#define	MD_Final(a,b)		MDC2_Final(a,b)
#define	MD(a,b,c)		MDC2(a,b,c)
#elif defined(USE_MD2_RAND)
#include <openssl/md2.h>
#define MD_DIGEST_LENGTH	MD2_DIGEST_LENGTH
#define MD_CTX			MD2_CTX
#define MD_Init(a)		MD2_Init(a)
#define MD_Update(a,b,c)	MD2_Update(a,b,c)
#define	MD_Final(a,b)		MD2_Final(a,b)
#define	MD(a,b,c)		MD2(a,b,c)
#endif

#include <openssl/rand.h>

a133 1
/* #define NORAND	1 */
d144 5
d185 1
a194 4
#ifdef NORAND
	return;
#endif

d210 1
a210 1
	CRYPTO_w_lock(CRYPTO_LOCK_RAND);
d242 1
a242 1
	CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
d284 1
a284 1
	CRYPTO_w_lock(CRYPTO_LOCK_RAND);
d295 1
a295 1
	CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
d297 1
a297 1
#ifndef THREADS	
a306 50
static void ssleay_rand_initialize(void)
	{
	unsigned long l;
#ifndef GETPID_IS_MEANINGLESS
	pid_t curr_pid = getpid();
#endif
#ifdef DEVRANDOM
	FILE *fh;
#endif

#ifdef NORAND
	return;
#endif

	CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
	/* put in some default random data, we need more than just this */
#ifndef GETPID_IS_MEANINGLESS
	l=curr_pid;
	RAND_add(&l,sizeof(l),0);
	l=getuid();
	RAND_add(&l,sizeof(l),0);
#endif
	l=time(NULL);
	RAND_add(&l,sizeof(l),0);

#ifdef DEVRANDOM
	/* Use a random entropy pool device. Linux, FreeBSD and OpenBSD
	 * have this. Use /dev/urandom if you can as /dev/random may block
	 * if it runs out of random entries.  */

	if ((fh = fopen(DEVRANDOM, "r")) != NULL)
		{
		unsigned char tmpbuf[ENTROPY_NEEDED];
		int n;
		
		setvbuf(fh, NULL, _IONBF, 0);
		n=fread((unsigned char *)tmpbuf,1,ENTROPY_NEEDED,fh);
		fclose(fh);
		RAND_add(tmpbuf,sizeof tmpbuf,n);
		memset(tmpbuf,0,n);
		}
#endif
#ifdef PURIFY
	memset(state,0,STATE_SIZE);
	memset(md,0,MD_DIGEST_LENGTH);
#endif
	CRYPTO_w_lock(CRYPTO_LOCK_RAND);
	initialized=1;
	}

d309 1
d318 1
d350 3
d354 2
d357 4
a360 3
	if (!initialized)
		ssleay_rand_initialize();

d370 5
d381 25
d420 3
d475 2
d502 3
d506 1
a506 3

	if (!initialized)
		ssleay_rand_initialize();
a507 1

a511 139

#ifdef WINDOWS
#include <windows.h>
#include <openssl/rand.h>

int RAND_event(UINT iMsg, WPARAM wParam, LPARAM lParam)
        {
        double add_entropy=0;
        SYSTEMTIME t;

        switch (iMsg)
                {
        case WM_KEYDOWN:
                        {
                        static WPARAM key;
                        if (key != wParam)
                                add_entropy = 0.05;
                        key = wParam;
                        }
                        break;
	case WM_MOUSEMOVE:
                        {
                        static int lastx,lasty,lastdx,lastdy;
                        int x,y,dx,dy;

                        x=LOWORD(lParam);
                        y=HIWORD(lParam);
                        dx=lastx-x;
                        dy=lasty-y;
                        if (dx != 0 && dy != 0 && dx-lastdx != 0 && dy-lastdy != 0)
                                add_entropy=.2;
                        lastx=x, lasty=y;
                        lastdx=dx, lastdy=dy;
                        }
		break;
		}

        GetSystemTime(&t);
        RAND_add(&iMsg, sizeof(iMsg), add_entropy);
	RAND_add(&wParam, sizeof(wParam), 0);
	RAND_add(&lParam, sizeof(lParam), 0);
        RAND_add(&t, sizeof(t), 0);

	return (RAND_status());
	}

/*****************************************************************************
 * Initialisation function for the SSL random generator.  Takes the contents
 * of the screen as random seed.
 *
 * Created 960901 by Gertjan van Oosten, gertjan@@West.NL, West Consulting B.V.
 *
 * Code adapted from
 * <URL:http://www.microsoft.com/kb/developr/win_dk/q97193.htm>;
 * the original copyright message is:
 *
 *   (C) Copyright Microsoft Corp. 1993.  All rights reserved.
 *
 *   You have a royalty-free right to use, modify, reproduce and
 *   distribute the Sample Files (and/or any modified version) in
 *   any way you find useful, provided that you agree that
 *   Microsoft has no warranty obligations or liability for any
 *   Sample Application Files which are modified.
 */
/*
 * I have modified the loading of bytes via RAND_seed() mechanism since
 * the original would have been very very CPU intensive since RAND_seed()
 * does an MD5 per 16 bytes of input.  The cost to digest 16 bytes is the same
 * as that to digest 56 bytes.  So under the old system, a screen of
 * 1024*768*256 would have been CPU cost of approximately 49,000 56 byte MD5
 * digests or digesting 2.7 mbytes.  What I have put in place would
 * be 48 16k MD5 digests, or effectively 48*16+48 MD5 bytes or 816 kbytes
 * or about 3.5 times as much.
 * - eric 
 */
void RAND_screen(void)
{
  HDC		hScrDC;		/* screen DC */
  HDC		hMemDC;		/* memory DC */
  HBITMAP	hBitmap;	/* handle for our bitmap */
  HBITMAP	hOldBitmap;	/* handle for previous bitmap */
  BITMAP	bm;		/* bitmap properties */
  unsigned int	size;		/* size of bitmap */
  char		*bmbits;	/* contents of bitmap */
  int		w;		/* screen width */
  int		h;		/* screen height */
  int		y;		/* y-coordinate of screen lines to grab */
  int		n = 16;		/* number of screen lines to grab at a time */

  /* Create a screen DC and a memory DC compatible to screen DC */
  hScrDC = CreateDC("DISPLAY", NULL, NULL, NULL);
  hMemDC = CreateCompatibleDC(hScrDC);

  /* Get screen resolution */
  w = GetDeviceCaps(hScrDC, HORZRES);
  h = GetDeviceCaps(hScrDC, VERTRES);

  /* Create a bitmap compatible with the screen DC */
  hBitmap = CreateCompatibleBitmap(hScrDC, w, n);

  /* Select new bitmap into memory DC */
  hOldBitmap = SelectObject(hMemDC, hBitmap);

  /* Get bitmap properties */
  GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
  size = (unsigned int)bm.bmWidthBytes * bm.bmHeight * bm.bmPlanes;

  bmbits = Malloc(size);
  if (bmbits) {
    /* Now go through the whole screen, repeatedly grabbing n lines */
    for (y = 0; y < h-n; y += n)
    	{
	unsigned char md[MD_DIGEST_LENGTH];

	/* Bitblt screen DC to memory DC */
	BitBlt(hMemDC, 0, 0, w, n, hScrDC, 0, y, SRCCOPY);

	/* Copy bitmap bits from memory DC to bmbits */
	GetBitmapBits(hBitmap, size, bmbits);

	/* Get the MD5 of the bitmap */
	MD(bmbits,size,md);

	/* Seed the random generator with the MD5 digest */
	RAND_seed(md, MD_DIGEST_LENGTH);
	}

    Free(bmbits);
  }

  /* Select old bitmap back into memory DC */
  hBitmap = SelectObject(hMemDC, hOldBitmap);

  /* Clean up */
  DeleteObject(hBitmap);
  DeleteDC(hMemDC);
  DeleteDC(hScrDC);
}
#endif
@


1.4
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d58 53
d186 4
d201 4
d212 1
d220 1
d372 4
d424 3
a426 2
	{
	static unsigned char val=0;
d428 4
a431 4
	for (i=0; i<num; i++)
		buf[i]=val++;
	return(1);
	}
d560 1
a560 1
int RAND_status(void)
d562 4
d568 5
a572 1
	return (entropy >= ENTROPY_NEEDED);
d578 41
@


1.3
log
@fread() of /dev/random reads an entire huge stdio buffer, instead of the 32
bytes that we actually need, thus wasting a lot of system entropy. found by
alecm@@coyote.uk.sun.com, passed on by Pete.Zaytsev@@EBay.Sun.COM
@
text
@d59 9
a68 2
#include <sys/types.h>
#include <fcntl.h>
d75 1
d141 2
d148 3
a150 1
static void ssleay_rand_bytes(unsigned char *buf, int num);
d156 2
d173 1
d176 1
a176 1
static void ssleay_rand_seed(const void *buf, int num)
d178 3
a180 1
	int i,j,k,st_idx,st_num;
d187 15
a203 1
	st_num=state_num;
d205 11
a215 1
	state_index=(state_index+num);
d226 8
d242 1
a242 1
		MD_Update(&m,md,MD_DIGEST_LENGTH);
d253 3
a255 3
		MD_Update(&m,(unsigned char *)&(md_count[0]),sizeof(md_count));
		MD_Final(md,&m);
		md_count[1]++;
d261 9
a269 1
			state[st_idx++]^=md[k];
a270 1
				{
a271 2
				st_num=STATE_SIZE;
				}
d275 68
d345 1
a345 1
static void ssleay_rand_bytes(unsigned char *buf, int num)
d348 3
d352 2
a353 4
	static int init=1;
	unsigned long l;
#ifdef DEVRANDOM
	int fd;
d362 1
a362 1
	return;
d366 19
d387 5
a391 1
	if (init)
d393 6
a398 20
		CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
		/* put in some default random data, we need more than
		 * just this */
		RAND_seed(&m,sizeof(m));
#ifndef MSDOS
		l=getpid();
		RAND_seed(&l,sizeof(l));
		l=getuid();
		RAND_seed(&l,sizeof(l));
#endif
		l=time(NULL);
		RAND_seed(&l,sizeof(l));

/* #ifdef DEVRANDOM */
		/* 
		 * Use a random entropy pool device.
		 * Linux 1.3.x, OpenBSD, and FreeBSD have
		 * this. Use /dev/urandom if you can
		 * as /dev/random will block if it runs out
		 * of random entries.
d400 3
a402 22
		if ((fd = open(DEVRANDOM, O_RDONLY)) != NULL)
			{
			unsigned char tmpbuf[32];

			read(fd, tmpbuf, sizeof(tmpbuf));
			/* we don't care how many bytes we read,
			 * we will just copy the 'stack' if there is
			 * nothing else :-) */
			/* the above comment is EVIL.  Security software
			 * RELIES ON THESE PRIMITIVES HAVING MORE SECURE
			 * BEHAVIOUR! Secure entropy is required in
			 * many cases! */
			RAND_seed(tmpbuf,32);
			memset(tmpbuf,0,32);
			}
/* #endif */
#ifdef PURIFY
		memset(state,0,STATE_SIZE);
		memset(md,0,MD_DIGEST_LENGTH);
#endif
		CRYPTO_w_lock(CRYPTO_LOCK_RAND);
		init=0;
d407 4
d413 4
a416 1
		state_index=(state_index%state_num);
d418 1
d426 9
a434 2
		MD_Update(&m,&(md[MD_DIGEST_LENGTH/2]),MD_DIGEST_LENGTH/2);
		MD_Update(&m,(unsigned char *)&(md_count[0]),sizeof(md_count));
d446 1
a446 1
		MD_Final(md,&m);
d450 2
a453 2
			state[st_idx++]^=md[i];
			*(buf++)=md[i+MD_DIGEST_LENGTH/2];
d458 3
a460 2
	MD_Update(&m,(unsigned char *)&(md_count[0]),sizeof(md_count));
	md_count[0]++;
d463 2
d466 31
d523 1
a523 1
 * the origional would have been very very CPU intensive since RAND_seed()
d526 1
a526 1
 * 1024*768*256 would have been CPU cost of approximatly 49,000 56 byte MD5
d528 1
a528 1
 * be 48 16k MD5 digests, or efectivly 48*16+48 MD5 bytes or 816 kbytes
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d61 1
d230 1
a230 1
	FILE *fh;
d263 1
a263 1
		 * Linux 1.3.x and FreeBSD-Current has 
d268 1
a268 1
		if ((fh = fopen(DEVRANDOM, "r")) != NULL)
d272 1
a272 1
			fread((unsigned char *)tmpbuf,1,32,fh);
d276 4
a279 1
			fclose(fh);
@


1.1
log
@Initial revision
@
text
@a59 1
#include "cryptlib.h"
d62 5
d69 3
a71 1
#ifndef NO_MD5
d73 1
a73 3
#elif !defined(NO_SHA1)
#define USE_SHA1_RAND
#elif !defined(NO_MDC2)
d78 1
a78 1
We need a message digest of some type 
d89 1
a89 1
#include "md5.h"
d95 1
d97 1
a97 1
#include "sha.h"
d103 1
d105 1
a105 1
#include "mdc2.h"
d111 1
d113 1
a113 1
#include "md2.h"
d119 1
d122 1
a122 1
#include "rand.h"
d124 2
a125 2
/*#define NORAND	1 */
/*#define PREDICT	1 */
d131 7
a137 1
static int md_count=0;
d139 5
a143 1
char *RAND_version="RAND part of SSLeay 0.9.0b 29-Jun-1998";
d145 6
a150 1
void RAND_cleanup()
d156 2
a157 1
	md_count=0;
d160 1
a160 3
void RAND_seed(buf,num)
unsigned char *buf;
int num;
d203 1
d205 1
d207 1
a207 1
		buf+=j;
d222 1
a222 3
void RAND_bytes(buf,num)
unsigned char *buf;
int num;
a245 1
		init=0;
d249 1
a249 1
		RAND_seed((unsigned char *)&m,sizeof(m));
d252 1
a252 1
		RAND_seed((unsigned char *)&l,sizeof(l));
d254 1
a254 1
		RAND_seed((unsigned char *)&l,sizeof(l));
d257 1
a257 1
		RAND_seed((unsigned char *)&l,sizeof(l));
d285 1
d302 1
d326 2
a327 1
	MD_Update(&m,(unsigned char *)&md_count,sizeof(md_count)); md_count++;
d335 1
a335 1
#include <rand.h>
d347 7
a353 7
//   (C) Copyright Microsoft Corp. 1993.  All rights reserved.
//
//   You have a royalty-free right to use, modify, reproduce and
//   distribute the Sample Files (and/or any modified version) in
//   any way you find useful, provided that you agree that
//   Microsoft has no warranty obligations or liability for any
//   Sample Application Files which are modified.
d412 1
a412 1
	MD5(bmbits,size,md);
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d59 17
a75 4
#ifdef MD_RAND_DEBUG
# ifndef NDEBUG
#   define NDEBUG
# endif
d78 5
a82 3
#include <assert.h>
#include <stdio.h>
#include <string.h>
d84 29
a112 1
#include "e_os.h"
d114 1
a114 2
#include <openssl/rand.h>
#include "rand_lcl.h"
d116 2
a117 8
#include <openssl/crypto.h>
#include <openssl/err.h>

#ifdef BN_DEBUG
# define PREDICT
#endif

/* #define PREDICT	1 */
d123 1
a123 9
static long md_count[2]={0,0};
static double entropy=0;
static int initialized=0;

static unsigned int crypto_lock_rand = 0; /* may be set only when a thread
                                           * holds CRYPTO_LOCK_RAND
                                           * (to prevent double locking) */
/* access to lockin_thread is synchronized by CRYPTO_LOCK_RAND2 */
static unsigned long locking_thread = 0; /* valid iff crypto_lock_rand is set */
d125 1
d127 1
a127 28
#ifdef PREDICT
int rand_predictable=0;
#endif

const char *RAND_version="RAND" OPENSSL_VERSION_PTEXT;

static void ssleay_rand_cleanup(void);
static void ssleay_rand_seed(const void *buf, int num);
static void ssleay_rand_add(const void *buf, int num, double add_entropy);
static int ssleay_rand_bytes(unsigned char *buf, int num);
static int ssleay_rand_pseudo_bytes(unsigned char *buf, int num);
static int ssleay_rand_status(void);

RAND_METHOD rand_ssleay_meth={
	ssleay_rand_seed,
	ssleay_rand_bytes,
	ssleay_rand_cleanup,
	ssleay_rand_add,
	ssleay_rand_pseudo_bytes,
	ssleay_rand_status
	}; 

RAND_METHOD *RAND_SSLeay(void)
	{
	return(&rand_ssleay_meth);
	}

static void ssleay_rand_cleanup(void)
d133 1
a133 4
	md_count[0]=0;
	md_count[1]=0;
	entropy=0;
	initialized=0;
d136 3
a138 1
static void ssleay_rand_add(const void *buf, int num, double add)
d140 2
a141 20
	int i,j,k,st_idx;
	long md_c[2];
	unsigned char local_md[MD_DIGEST_LENGTH];
	EVP_MD_CTX m;
	int do_not_lock;

	/*
	 * (Based on the rand(3) manpage)
	 *
	 * The input is chopped up into units of 20 bytes (or less for
	 * the last block).  Each of these blocks is run through the hash
	 * function as follows:  The data passed to the hash function
	 * is the current 'md', the same number of bytes from the 'state'
	 * (the location determined by in incremented looping index) as
	 * the current 'block', the new key data 'block', and 'count'
	 * (which is incremented after each use).
	 * The result of this is kept in 'md' and also xored into the
	 * 'state' at the same locations that were used as input into the
         * hash function.
	 */
d143 3
a145 9
	/* check if we already have the lock */
	if (crypto_lock_rand)
		{
		CRYPTO_r_lock(CRYPTO_LOCK_RAND2);
		do_not_lock = (locking_thread == CRYPTO_thread_id());
		CRYPTO_r_unlock(CRYPTO_LOCK_RAND2);
		}
	else
		do_not_lock = 0;
d147 1
a147 1
	if (!do_not_lock) CRYPTO_w_lock(CRYPTO_LOCK_RAND);
d149 1
d151 1
a151 11
	/* use our own copies of the counters so that even
	 * if a concurrent thread seeds with exactly the
	 * same data and uses the same subarray there's _some_
	 * difference */
	md_c[0] = md_count[0];
	md_c[1] = md_count[1];

	memcpy(local_md, md, sizeof md);

	/* state_index <= state_num <= STATE_SIZE */
	state_index += num;
d162 1
a162 5
	/* state_index <= state_num <= STATE_SIZE */

	/* state[st_idx], ..., state[(st_idx + num - 1) % STATE_SIZE]
	 * are what we will use now, but other threads may use them
	 * as well */
a163 5
	md_count[1] += (num / MD_DIGEST_LENGTH) + (num % MD_DIGEST_LENGTH > 0);

	if (!do_not_lock) CRYPTO_w_unlock(CRYPTO_LOCK_RAND);

	EVP_MD_CTX_init(&m);
d170 1
a170 1
		MD_Update(&m,local_md,MD_DIGEST_LENGTH);
d181 1
a181 3
		MD_Update(&m,(unsigned char *)&(md_c[0]),sizeof(md_c));
		MD_Final(&m,local_md);
		md_c[1]++;
d183 1
a183 1
		buf=(const char *)buf + j;
d187 1
a187 9
			/* Parallel threads may interfere with this,
			 * but always each byte of the new state is
			 * the XOR of some previous value of its
			 * and local_md (itermediate values may be lost).
			 * Alway using locking could hurt performance more
			 * than necessary given that conflicts occur only
			 * when the total seeding is longer than the random
			 * state. */
			state[st_idx++]^=local_md[k];
d189 1
d191 2
d195 1
a195 23
	EVP_MD_CTX_cleanup(&m);

	if (!do_not_lock) CRYPTO_w_lock(CRYPTO_LOCK_RAND);
	/* Don't just copy back local_md into md -- this could mean that
	 * other thread's seeding remains without effect (except for
	 * the incremented counter).  By XORing it we keep at least as
	 * much entropy as fits into md. */
	for (k = 0; k < sizeof md; k++)
		{
		md[k] ^= local_md[k];
		}
	if (entropy < ENTROPY_NEEDED) /* stop counting when we have enough */
	    entropy += add;
	if (!do_not_lock) CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
	
#if !defined(OPENSSL_THREADS) && !defined(OPENSSL_SYS_WIN32)
	assert(md_c[1] == md_count[1]);
#endif
	}

static void ssleay_rand_seed(const void *buf, int num)
	{
	ssleay_rand_add(buf, num, num);
d198 3
a200 1
static int ssleay_rand_bytes(unsigned char *buf, int num)
a201 1
	static volatile int stirred_pool = 0;
d203 5
a207 7
	int num_ceil;
	int ok;
	long md_c[2];
	unsigned char local_md[MD_DIGEST_LENGTH];
	EVP_MD_CTX m;
#ifndef GETPID_IS_MEANINGLESS
	pid_t curr_pid = getpid();
a208 1
	int do_stir_pool = 0;
d211 2
a212 3
	if (rand_predictable)
		{
		static unsigned char val=0;
d214 4
a217 4
		for (i=0; i<num; i++)
			buf[i]=val++;
		return(1);
		}
a219 25
	if (num <= 0)
		return 1;

	EVP_MD_CTX_init(&m);
	/* round upwards to multiple of MD_DIGEST_LENGTH/2 */
	num_ceil = (1 + (num-1)/(MD_DIGEST_LENGTH/2)) * (MD_DIGEST_LENGTH/2);

	/*
	 * (Based on the rand(3) manpage:)
	 *
	 * For each group of 10 bytes (or less), we do the following:
	 *
	 * Input into the hash function the local 'md' (which is initialized from
	 * the global 'md' before any bytes are generated), the bytes that are to
	 * be overwritten by the random bytes, and bytes from the 'state'
	 * (incrementing looping index). From this digest output (which is kept
	 * in 'md'), the top (up to) 10 bytes are returned to the caller and the
	 * bottom 10 bytes are xored into the 'state'.
	 * 
	 * Finally, after we have finished 'num' random bytes for the
	 * caller, 'count' (which is incremented) and the local and global 'md'
	 * are fed into the hash function and the results are kept in the
	 * global 'md'.
	 */

d222 1
a222 7
	/* prevent ssleay_rand_bytes() from trying to obtain the lock again */
	CRYPTO_w_lock(CRYPTO_LOCK_RAND2);
	locking_thread = CRYPTO_thread_id();
	CRYPTO_w_unlock(CRYPTO_LOCK_RAND2);
	crypto_lock_rand = 1;

	if (!initialized)
d224 13
a236 26
		RAND_poll();
		initialized = 1;
		}
	
	if (!stirred_pool)
		do_stir_pool = 1;
	
	ok = (entropy >= ENTROPY_NEEDED);
	if (!ok)
		{
		/* If the PRNG state is not yet unpredictable, then seeing
		 * the PRNG output may help attackers to determine the new
		 * state; thus we have to decrease the entropy estimate.
		 * Once we've had enough initial seeding we don't bother to
		 * adjust the entropy count, though, because we're not ambitious
		 * to provide *information-theoretic* randomness.
		 *
		 * NOTE: This approach fails if the program forks before
		 * we have enough entropy. Entropy should be collected
		 * in a separate input pool and be transferred to the
		 * output pool only when the entropy limit has been reached.
		 */
		entropy -= num;
		if (entropy < 0)
			entropy = 0;
		}
d238 7
a244 7
	if (do_stir_pool)
		{
		/* In the output function only half of 'md' remains secret,
		 * so we better make sure that the required entropy gets
		 * 'evenly distributed' through 'state', our randomness pool.
		 * The input function (ssleay_rand_add) chains all of 'md',
		 * which makes it more suitable for this purpose.
d246 3
d250 12
a261 5
		int n = STATE_SIZE; /* so that the complete pool gets accessed */
		while (n > 0)
			{
#if MD_DIGEST_LENGTH > 20
# error "Please adjust DUMMY_SEED."
d263 1
a263 8
#define DUMMY_SEED "...................." /* at least MD_DIGEST_LENGTH */
			/* Note that the seed does not matter, it's just that
			 * ssleay_rand_add expects to have something to hash. */
			ssleay_rand_add(DUMMY_SEED, MD_DIGEST_LENGTH, 0.0);
			n -= MD_DIGEST_LENGTH;
			}
		if (ok)
			stirred_pool = 1;
d268 1
a268 5
	md_c[0] = md_count[0];
	md_c[1] = md_count[1];
	memcpy(local_md, md, sizeof md);

	state_index+=num_ceil;
d270 1
a270 6
		state_index %= state_num;

	/* state[st_idx], ..., state[(st_idx + num_ceil - 1) % st_num]
	 * are now ours (but other threads may use them too) */

	md_count[0] += 1;
a271 2
	/* before unlocking, we must clear 'crypto_lock_rand' */
	crypto_lock_rand = 0;
a275 1
		/* num_ceil -= MD_DIGEST_LENGTH/2 */
d279 1
a279 9
#ifndef GETPID_IS_MEANINGLESS
		if (curr_pid) /* just in the first iteration to save time */
			{
			MD_Update(&m,(unsigned char*)&curr_pid,sizeof curr_pid);
			curr_pid = 0;
			}
#endif
		MD_Update(&m,local_md,MD_DIGEST_LENGTH);
		MD_Update(&m,(unsigned char *)&(md_c[0]),sizeof(md_c));
d283 1
a283 1
		k=(st_idx+MD_DIGEST_LENGTH/2)-st_num;
d286 1
a286 1
			MD_Update(&m,&(state[st_idx]),MD_DIGEST_LENGTH/2-k);
d290 2
a291 2
			MD_Update(&m,&(state[st_idx]),MD_DIGEST_LENGTH/2);
		MD_Final(&m,local_md);
d293 1
a293 1
		for (i=0; i<MD_DIGEST_LENGTH/2; i++)
a294 1
			state[st_idx++]^=local_md[i]; /* may compete with other threads */
d297 2
a298 2
			if (i < j)
				*(buf++)=local_md[i+MD_DIGEST_LENGTH/2];
d303 1
a303 3
	MD_Update(&m,(unsigned char *)&(md_c[0]),sizeof(md_c));
	MD_Update(&m,local_md,MD_DIGEST_LENGTH);
	CRYPTO_w_lock(CRYPTO_LOCK_RAND);
d305 78
a382 2
	MD_Final(&m,md);
	CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
d384 2
a385 11
	EVP_MD_CTX_cleanup(&m);
	if (ok)
		return(1);
	else
		{
		RANDerr(RAND_F_SSLEAY_RAND_BYTES,RAND_R_PRNG_NOT_SEEDED);
		ERR_add_error_data(1, "You need to read the OpenSSL FAQ, "
			"http://www.openssl.org/support/faq.html");
		return(0);
		}
	}
d387 2
a388 6
/* pseudo-random bytes that are guaranteed to be unique but not
   unpredictable */
static int ssleay_rand_pseudo_bytes(unsigned char *buf, int num) 
	{
	int ret;
	unsigned long err;
d390 2
a391 9
	ret = RAND_bytes(buf, num);
	if (ret == 0)
		{
		err = ERR_peek_error();
		if (ERR_GET_LIB(err) == ERR_LIB_RAND &&
		    ERR_GET_REASON(err) == RAND_R_PRNG_NOT_SEEDED)
			(void)ERR_get_error();
		}
	return (ret);
d394 2
a395 4
static int ssleay_rand_status(void)
	{
	int ret;
	int do_not_lock;
d397 2
a398 27
	/* check if we already have the lock
	 * (could happen if a RAND_poll() implementation calls RAND_status()) */
	if (crypto_lock_rand)
		{
		CRYPTO_r_lock(CRYPTO_LOCK_RAND2);
		do_not_lock = (locking_thread == CRYPTO_thread_id());
		CRYPTO_r_unlock(CRYPTO_LOCK_RAND2);
		}
	else
		do_not_lock = 0;
	
	if (!do_not_lock)
		{
		CRYPTO_w_lock(CRYPTO_LOCK_RAND);
		
		/* prevent ssleay_rand_bytes() from trying to obtain the lock again */
		CRYPTO_w_lock(CRYPTO_LOCK_RAND2);
		locking_thread = CRYPTO_thread_id();
		CRYPTO_w_unlock(CRYPTO_LOCK_RAND2);
		crypto_lock_rand = 1;
		}
	
	if (!initialized)
		{
		RAND_poll();
		initialized = 1;
		}
d400 6
a405 12
	ret = entropy >= ENTROPY_NEEDED;

	if (!do_not_lock)
		{
		/* before unlocking, we must clear 'crypto_lock_rand' */
		crypto_lock_rand = 0;
		
		CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
		}
	
	return ret;
	}
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d180 1
a180 1
	OPENSSL_cleanse(state,sizeof(state));
d183 1
a183 1
	OPENSSL_cleanse(md,MD_DIGEST_LENGTH);
@


1.1.1.4
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a128 1
#include <openssl/fips.h>
a333 8

#ifdef OPENSSL_FIPS
	if(FIPS_mode())
	    {
	    FIPSerr(FIPS_F_SSLEAY_RAND_BYTES,FIPS_R_NON_FIPS_METHOD);
	    return 0;
	    }
#endif
@


1.1.1.5
log
@import of OpenSSL 0.9.8h
@
text
@d129 1
d156 1
a156 1
const char RAND_version[]="RAND" OPENSSL_VERSION_PTEXT;
d304 1
a304 1
	for (k = 0; k < (int)sizeof(md); k++)
d319 1
a319 1
	ssleay_rand_add(buf, num, (double)num);
d336 8
d532 1
a532 1
			ERR_clear_error();
@


1.1.1.6
log
@import openssl-0.9.8j
@
text
@a128 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

a333 8

#ifdef OPENSSL_FIPS
	if(FIPS_mode())
	    {
	    FIPSerr(FIPS_F_SSLEAY_RAND_BYTES,FIPS_R_NON_FIPS_METHOD);
	    return 0;
	    }
#endif
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@d129 4
d152 1
a152 1
static CRYPTO_THREADID locking_threadid; /* valid iff crypto_lock_rand is set */
a219 2
		CRYPTO_THREADID cur;
		CRYPTO_THREADID_current(&cur);
d221 1
a221 1
		do_not_lock = !CRYPTO_THREADID_cmp(&locking_threadid, &cur);
d277 1
a277 2

		/* DO NOT REMOVE THE FOLLOWING CALL TO MD_Update()! */
a278 7
		/* We know that line may cause programs such as
		   purify and valgrind to complain about use of
		   uninitialized data.  The problem is not, it's
		   with the caller.  Removing that line will make
		   sure you get really bad randomness and thereby
		   other problems such as very insecure keys. */

d339 8
d387 1
a387 1
	CRYPTO_THREADID_current(&locking_threadid);
d479 2
a480 7

#ifndef PURIFY /* purify complains */
		/* DO NOT REMOVE THE FOLLOWING CALL TO MD_Update()! */
		MD_Update(&m,buf,j);
		/* We know that line may cause programs such as
		   purify and valgrind to complain about use of
		   uninitialized data.  */
a481 1

a541 1
	CRYPTO_THREADID cur;
a544 1
	CRYPTO_THREADID_current(&cur);
d550 1
a550 1
		do_not_lock = !CRYPTO_THREADID_cmp(&locking_threadid, &cur);
d562 1
a562 1
		CRYPTO_THREADID_cpy(&locking_threadid, &cur);
@


1.1.1.8
log
@import OpenSSL 1.0.0e
@
text
@d479 1
a479 7
		/* The following line uses the supplied buffer as a small
		 * source of entropy: since this buffer is often uninitialised
		 * it may cause programs such as purify or valgrind to
		 * complain. So for those builds it is not used: the removal
		 * of such a small source of entropy has negligible impact on
		 * security.
		 */
d481 3
@


1.1.1.9
log
@import OpenSSL-1.0.1c
@
text
@a111 2
#define OPENSSL_FIPSEVP

d160 1
a160 2
static int ssleay_rand_bytes(unsigned char *buf, int num, int pseudo);
static int ssleay_rand_nopseudo_bytes(unsigned char *buf, int num);
d166 1
a166 1
	ssleay_rand_nopseudo_bytes,
d331 1
a331 1
static int ssleay_rand_bytes(unsigned char *buf, int num, int pseudo)
d520 1
a520 3
	else if (pseudo)
		return 0;
	else 
a528 5
static int ssleay_rand_nopseudo_bytes(unsigned char *buf, int num)
	{
	return ssleay_rand_bytes(buf, num, 0);
	}

d533 12
a544 1
	return ssleay_rand_bytes(buf, num, 1);
@


1.1.1.10
log
@Import OpenSSL 1.0.1g
@
text
@a125 1
#include <openssl/crypto.h>
d129 1
a200 3
	if (!num)
		return;

d383 2
a384 5
#ifdef OPENSSL_FIPS
	/* NB: in FIPS mode we are already under a lock */
	if (!FIPS_mode())
#endif
		CRYPTO_w_lock(CRYPTO_LOCK_RAND);
d463 1
a463 4
#ifdef OPENSSL_FIPS
	if (!FIPS_mode())
#endif
		CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
d515 1
a515 4
#ifdef OPENSSL_FIPS
	if (!FIPS_mode())
#endif
		CRYPTO_w_lock(CRYPTO_LOCK_RAND);
d518 1
a518 4
#ifdef OPENSSL_FIPS
	if (!FIPS_mode())
#endif
		CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
@


