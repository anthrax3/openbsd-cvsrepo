head	1.21;
access;
symbols
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.4
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	butholakala:1.11
	openssl_1_0_1_g:1.1.1.9
	OPENBSD_5_5:1.10.0.8
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	openssl_1_0_1_c:1.1.1.8
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	openssl_1_0_0_f:1.1.1.7
	openssl_1_0_0_e:1.1.1.7
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	openssh_1_0_0_a:1.1.1.7
	OPENBSD_4_8:1.8.0.8
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	openssl_0_9_8_k:1.1.1.6
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	openssl_0_9_8_j:1.1.1.6
	openssl_0_9_8_h:1.1.1.5
	pre_openssl_0_9_8h:1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	openssl_0_9_7j:1.1.1.4
	openssl:1.1.1
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENSSL_0_9_7G:1.1.1.3
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENSSL_0_9_7D:1.1.1.3
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENSSL_0_9_7C:1.1.1.3
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.2.0.6
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.1.0.6
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.21
date	2015.09.10.15.56.25;	author jsing;	state Exp;
branches;
next	1.20;
commitid	vHznCDK3idwNEFz4;

1.20
date	2015.02.14.15.49.51;	author miod;	state Exp;
branches;
next	1.19;
commitid	rzTv2OT8donUXvX1;

1.19
date	2015.02.14.15.45.21;	author miod;	state Exp;
branches;
next	1.18;
commitid	krWMfcnwXZeytonW;

1.18
date	2015.02.10.09.52.35;	author miod;	state Exp;
branches;
next	1.17;
commitid	elQcISUWkrkujoI4;

1.17
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.16;
commitid	yQEL1wOWIearrW15;

1.16
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.15;
commitid	nzndm3zqPmFurSaK;

1.15
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.14;
commitid	id8dTrTMtnTn4fqt;

1.14
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	mJUVYpkFBZ0Zv2bG;

1.13
date	2014.06.07.15.06.24;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	8XcpJqUicyz2wPAR;

1.12
date	2014.05.07.17.42.51;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.01.22.58.55;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.27.05.07.01;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.12.02.18.37;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.10.16.31.55;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.15.02.29.14;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.15.02.57.46;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.36.16;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.30;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.22.39.25;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.35.23;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.06.27.05.05.33;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.06.12.15.44;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.01.09.12.13.56;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.08;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2012.10.13.21.23.40;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@/* $OpenBSD: p5_crpt2.c,v 1.20 2015/02/14 15:49:51 miod Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 1999.
 */
/* ====================================================================
 * Copyright (c) 1999-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/opensslconf.h>

#if !defined(OPENSSL_NO_HMAC) && !defined(OPENSSL_NO_SHA)

#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/hmac.h>
#include <openssl/x509.h>

#include "evp_locl.h"

/* This is an implementation of PKCS#5 v2.0 password based encryption key
 * derivation function PBKDF2.
 * SHA1 version verified against test vectors posted by Peter Gutmann
 * <pgut001@@cs.auckland.ac.nz> to the PKCS-TNG <pkcs-tng@@rsa.com> mailing list.
 */

int
PKCS5_PBKDF2_HMAC(const char *pass, int passlen, const unsigned char *salt,
    int saltlen, int iter, const EVP_MD *digest, int keylen, unsigned char *out)
{
	unsigned char digtmp[EVP_MAX_MD_SIZE], *p, itmp[4];
	int cplen, j, k, tkeylen, mdlen;
	unsigned long i = 1;
	HMAC_CTX hctx_tpl, hctx;

	mdlen = EVP_MD_size(digest);
	if (mdlen < 0)
		return 0;

	HMAC_CTX_init(&hctx_tpl);
	p = out;
	tkeylen = keylen;
	if (!pass)
		passlen = 0;
	else if (passlen == -1)
		passlen = strlen(pass);
	if (!HMAC_Init_ex(&hctx_tpl, pass, passlen, digest, NULL)) {
		HMAC_CTX_cleanup(&hctx_tpl);
		return 0;
	}
	while (tkeylen) {
		if (tkeylen > mdlen)
			cplen = mdlen;
		else
			cplen = tkeylen;
		/* We are unlikely to ever use more than 256 blocks (5120 bits!)
		 * but just in case...
		 */
		itmp[0] = (unsigned char)((i >> 24) & 0xff);
		itmp[1] = (unsigned char)((i >> 16) & 0xff);
		itmp[2] = (unsigned char)((i >> 8) & 0xff);
		itmp[3] = (unsigned char)(i & 0xff);
		if (!HMAC_CTX_copy(&hctx, &hctx_tpl)) {
			HMAC_CTX_cleanup(&hctx_tpl);
			return 0;
		}
		if (!HMAC_Update(&hctx, salt, saltlen) ||
		    !HMAC_Update(&hctx, itmp, 4) ||
		    !HMAC_Final(&hctx, digtmp, NULL)) {
			HMAC_CTX_cleanup(&hctx_tpl);
			HMAC_CTX_cleanup(&hctx);
			return 0;
		}
		HMAC_CTX_cleanup(&hctx);
		memcpy(p, digtmp, cplen);
		for (j = 1; j < iter; j++) {
			if (!HMAC_CTX_copy(&hctx, &hctx_tpl)) {
				HMAC_CTX_cleanup(&hctx_tpl);
				return 0;
			}
			if (!HMAC_Update(&hctx, digtmp, mdlen) ||
			    !HMAC_Final(&hctx, digtmp, NULL)) {
				HMAC_CTX_cleanup(&hctx_tpl);
				HMAC_CTX_cleanup(&hctx);
				return 0;
			}
			HMAC_CTX_cleanup(&hctx);
			for (k = 0; k < cplen; k++)
				p[k] ^= digtmp[k];
		}
		tkeylen -= cplen;
		i++;
		p += cplen;
	}
	HMAC_CTX_cleanup(&hctx_tpl);
	return 1;
}

int
PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen, const unsigned char *salt,
    int saltlen, int iter, int keylen, unsigned char *out)
{
	return PKCS5_PBKDF2_HMAC(pass, passlen, salt, saltlen, iter,
	    EVP_sha1(), keylen, out);
}

/* Now the key derivation function itself. This is a bit evil because
 * it has to check the ASN1 parameters are valid: and there are quite a
 * few of them...
 */

int
PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
    ASN1_TYPE *param, const EVP_CIPHER *c, const EVP_MD *md, int en_de)
{
	const unsigned char *pbuf;
	int plen;
	PBE2PARAM *pbe2 = NULL;
	const EVP_CIPHER *cipher;

	int rv = 0;

	if (param == NULL || param->type != V_ASN1_SEQUENCE ||
	    param->value.sequence == NULL) {
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN, EVP_R_DECODE_ERROR);
		goto err;
	}

	pbuf = param->value.sequence->data;
	plen = param->value.sequence->length;
	if (!(pbe2 = d2i_PBE2PARAM(NULL, &pbuf, plen))) {
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN, EVP_R_DECODE_ERROR);
		goto err;
	}

	/* See if we recognise the key derivation function */

	if (OBJ_obj2nid(pbe2->keyfunc->algorithm) != NID_id_pbkdf2) {
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,
		    EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION);
		goto err;
	}

	/* lets see if we recognise the encryption algorithm.
	 */

	cipher = EVP_get_cipherbyobj(pbe2->encryption->algorithm);

	if (!cipher) {
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,
		    EVP_R_UNSUPPORTED_CIPHER);
		goto err;
	}

	/* Fixup cipher based on AlgorithmIdentifier */
	if (!EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, en_de))
		goto err;
	if (EVP_CIPHER_asn1_to_param(ctx, pbe2->encryption->parameter) < 0) {
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,
		    EVP_R_CIPHER_PARAMETER_ERROR);
		goto err;
	}
	rv = PKCS5_v2_PBKDF2_keyivgen(ctx, pass, passlen,
	    pbe2->keyfunc->parameter, c, md, en_de);

err:
	PBE2PARAM_free(pbe2);
	return rv;
}

int
PKCS5_v2_PBKDF2_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
    ASN1_TYPE *param, const EVP_CIPHER *c, const EVP_MD *md, int en_de)
{
	unsigned char *salt, key[EVP_MAX_KEY_LENGTH];
	const unsigned char *pbuf;
	int saltlen, iter, plen;
	int rv = 0;
	unsigned int keylen = 0;
	int prf_nid, hmac_md_nid;
	PBKDF2PARAM *kdf = NULL;
	const EVP_MD *prfmd;

	if (EVP_CIPHER_CTX_cipher(ctx) == NULL) {
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_NO_CIPHER_SET);
		return 0;
	}
	keylen = EVP_CIPHER_CTX_key_length(ctx);
	if (keylen > sizeof key) {
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_BAD_KEY_LENGTH);
		return 0;
	}

	/* Decode parameter */

	if (!param || (param->type != V_ASN1_SEQUENCE)) {
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_DECODE_ERROR);
		return 0;
	}

	pbuf = param->value.sequence->data;
	plen = param->value.sequence->length;

	if (!(kdf = d2i_PBKDF2PARAM(NULL, &pbuf, plen)) ) {
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_DECODE_ERROR);
		return 0;
	}

	/* Now check the parameters of the kdf */

	if (kdf->keylength &&
	    (ASN1_INTEGER_get(kdf->keylength) != (int)keylen)){
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN,
		    EVP_R_UNSUPPORTED_KEYLENGTH);
		goto err;
	}

	if (kdf->prf)
		prf_nid = OBJ_obj2nid(kdf->prf->algorithm);
	else
		prf_nid = NID_hmacWithSHA1;

	if (!EVP_PBE_find(EVP_PBE_TYPE_PRF, prf_nid, NULL, &hmac_md_nid, 0)) {
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_UNSUPPORTED_PRF);
		goto err;
	}

	prfmd = EVP_get_digestbynid(hmac_md_nid);
	if (prfmd == NULL) {
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_UNSUPPORTED_PRF);
		goto err;
	}

	if (kdf->salt->type != V_ASN1_OCTET_STRING) {
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN,
		    EVP_R_UNSUPPORTED_SALT_TYPE);
		goto err;
	}

	/* it seems that its all OK */
	salt = kdf->salt->value.octet_string->data;
	saltlen = kdf->salt->value.octet_string->length;
	iter = ASN1_INTEGER_get(kdf->iter);
	if (!PKCS5_PBKDF2_HMAC(pass, passlen, salt, saltlen, iter, prfmd,
	    keylen, key))
		goto err;
	rv = EVP_CipherInit_ex(ctx, NULL, NULL, key, NULL, en_de);

err:
	explicit_bzero(key, keylen);
	PBKDF2PARAM_free(kdf);
	return rv;
}

#endif
@


1.20
log
@1.18 would introduce a possible out-of-bounds access in the error path;
Coverity CID 105346
ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: p5_crpt2.c,v 1.19 2015/02/14 15:45:21 miod Exp $ */
d303 1
a303 1
	OPENSSL_cleanse(key, keylen);
@


1.19
log
@Remove DEBUG_PKCS5V2 code.
@
text
@d1 1
a1 1
/* $OpenBSD: p5_crpt2.c,v 1.18 2015/02/10 09:52:35 miod Exp $ */
d239 1
a239 1
		goto err;
d244 1
a244 1
		goto err;
d251 1
a251 1
		goto err;
d259 1
a259 1
		goto err;
a260 2

	keylen = EVP_CIPHER_CTX_key_length(ctx);
@


1.18
log
@Replace assert() and OPENSSL_assert() calls with proper error return paths.
Careful review, feedback & ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: p5_crpt2.c,v 1.17 2014/07/11 08:44:48 jsing Exp $ */
a73 7
/* set this to print out info about the keygen algorithm */
/* #define DEBUG_PKCS5V2 */

#ifdef DEBUG_PKCS5V2
static void h__dump (const unsigned char *p, int len);
#endif

a148 9
#ifdef DEBUG_PKCS5V2
	fprintf(stderr, "Password:\n");
	h__dump (pass, passlen);
	fprintf(stderr, "Salt:\n");
	h__dump (salt, saltlen);
	fprintf(stderr, "Iteration count %d\n", iter);
	fprintf(stderr, "Key:\n");
	h__dump (out, keylen);
#endif
a309 8
#ifdef DEBUG_PKCS5V2
static void h__dump (const unsigned char *p, int len)
{
	for (; len --; p++)
		fprintf(stderr, "%02X ", *p);
	fprintf(stderr, "\n");
}
#endif
@


1.17
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: p5_crpt2.c,v 1.16 2014/07/10 22:45:57 jsing Exp $ */
d258 4
a261 1
	OPENSSL_assert(keylen <= sizeof key);
@


1.16
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: p5_crpt2.c,v 1.15 2014/07/10 13:58:22 jsing Exp $ */
a64 1
#include "cryptlib.h"
d66 2
a67 1
#include <openssl/x509.h>
d70 2
@


1.15
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: p5_crpt2.c,v 1.14 2014/06/12 15:49:29 deraadt Exp $ */
d62 2
@


1.14
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d58 1
d61 2
@


1.13
log
@Remove various test stubs.  The good ones have been moved by jsing
and others to the regress framework.  These remaining ones just
muddle us up when re-reading code repeatedly.
ok jsing
@
text
@d1 1
a1 1
/* p5_crpt2.c */
@


1.12
log
@KNF.
@
text
@a168 11
#ifdef DO_TEST
main()
{
	unsigned char out[4];
	unsigned char salt[] = {0x12, 0x34, 0x56, 0x78};
	PKCS5_PBKDF2_HMAC_SHA1("password", -1, salt, 4, 5, 4, out);
	fprintf(stderr, "Out %02X %02X %02X %02X\n",
	    out[0], out[1], out[2], out[3]);
}
#endif

@


1.11
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d71 1
a71 1
	static void h__dump (const unsigned char *p, int len);
d80 4
a83 5
int PKCS5_PBKDF2_HMAC(const char *pass, int passlen,
			   const unsigned char *salt, int saltlen, int iter,
			   const EVP_MD *digest,
			   int keylen, unsigned char *out)
	{
d96 1
a96 1
	if(!pass)
d98 1
a98 1
	else if(passlen == -1)
d100 1
a100 2
	if (!HMAC_Init_ex(&hctx_tpl, pass, passlen, digest, NULL))
		{
d103 3
a105 4
		}
	while(tkeylen)
		{
		if(tkeylen > mdlen)
d116 1
a116 2
		if (!HMAC_CTX_copy(&hctx, &hctx_tpl))
			{
d119 4
a122 5
			}
		if (!HMAC_Update(&hctx, salt, saltlen)
		    || !HMAC_Update(&hctx, itmp, 4)
		    || !HMAC_Final(&hctx, digtmp, NULL))
			{
d126 1
a126 1
			}
d129 2
a130 4
		for(j = 1; j < iter; j++)
			{
			if (!HMAC_CTX_copy(&hctx, &hctx_tpl))
				{
d133 3
a135 4
				}
			if (!HMAC_Update(&hctx, digtmp, mdlen)
			    || !HMAC_Final(&hctx, digtmp, NULL))
				{
d139 1
a139 1
				}
d141 1
a141 1
			for(k = 0; k < cplen; k++)
d143 2
a144 2
			}
		tkeylen-= cplen;
d146 2
a147 2
		p+= cplen;
		}
d159 1
a159 1
	}
d161 7
a167 7
int PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen,
			   const unsigned char *salt, int saltlen, int iter,
			   int keylen, unsigned char *out)
	{
	return PKCS5_PBKDF2_HMAC(pass, passlen, salt, saltlen, iter, EVP_sha1(),
					keylen, out);
	}
d176 1
a176 1
					 out[0], out[1], out[2], out[3]);
a177 1

d185 3
a187 3
int PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
                         ASN1_TYPE *param, const EVP_CIPHER *c, const EVP_MD *md,
                         int en_de)
d198 1
a198 1
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,EVP_R_DECODE_ERROR);
d204 2
a205 2
	if(!(pbe2 = d2i_PBE2PARAM(NULL, &pbuf, plen))) {
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,EVP_R_DECODE_ERROR);
d211 1
a211 1
	if(OBJ_obj2nid(pbe2->keyfunc->algorithm) != NID_id_pbkdf2) {
d213 1
a213 1
				EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION);
d222 1
a222 1
	if(!cipher) {
d224 1
a224 1
						EVP_R_UNSUPPORTED_CIPHER);
d231 1
a231 1
	if(EVP_CIPHER_asn1_to_param(ctx, pbe2->encryption->parameter) < 0) {
d233 1
a233 1
					EVP_R_CIPHER_PARAMETER_ERROR);
d237 3
a239 2
					pbe2->keyfunc->parameter, c, md, en_de);
	err:
d244 3
a246 3
int PKCS5_v2_PBKDF2_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
                         ASN1_TYPE *param,
			 const EVP_CIPHER *c, const EVP_MD *md, int en_de)
d257 2
a258 3
	if (EVP_CIPHER_CTX_cipher(ctx) == NULL)
		{
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN,EVP_R_NO_CIPHER_SET);
d260 1
a260 1
		}
d266 2
a267 3
	if(!param || (param->type != V_ASN1_SEQUENCE))
		{
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN,EVP_R_DECODE_ERROR);
d269 1
a269 1
		}
d274 2
a275 2
	if(!(kdf = d2i_PBKDF2PARAM(NULL, &pbuf, plen)) ) {
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN,EVP_R_DECODE_ERROR);
d283 2
a284 1
	if(kdf->keylength && (ASN1_INTEGER_get(kdf->keylength) != (int)keylen)){
d286 1
a286 1
						EVP_R_UNSUPPORTED_KEYLENGTH);
d295 1
a295 2
	if (!EVP_PBE_find(EVP_PBE_TYPE_PRF, prf_nid, NULL, &hmac_md_nid, 0))
		{
d298 1
a298 1
		}
d301 1
a301 2
	if (prfmd == NULL)
		{
d304 1
a304 1
		}
d306 1
a306 1
	if(kdf->salt->type != V_ASN1_OCTET_STRING) {
d308 1
a308 1
						EVP_R_UNSUPPORTED_SALT_TYPE);
d316 2
a317 2
	if(!PKCS5_PBKDF2_HMAC(pass, passlen, salt, saltlen, iter, prfmd,
						   keylen, key))
d320 2
a321 1
	err:
d330 3
a332 2
        for (; len --; p++) fprintf(stderr, "%02X ", *p);
        fprintf(stderr, "\n");
@


1.10
log
@resolve conflicts
@
text
@d88 1
a88 1
	HMAC_CTX hctx;
d94 1
a94 1
	HMAC_CTX_init(&hctx);
d101 5
d119 1
a119 4
		if (!HMAC_Init_ex(&hctx, pass, passlen, digest, NULL)
			|| !HMAC_Update(&hctx, salt, saltlen)
			|| !HMAC_Update(&hctx, itmp, 4)
			|| !HMAC_Final(&hctx, digtmp, NULL))
d121 8
d132 1
d136 13
a148 2
			HMAC(digest, pass, passlen,
				 digtmp, mdlen, digtmp, NULL);
d156 1
a156 1
	HMAC_CTX_cleanup(&hctx);
@


1.9
log
@resolve conflicts, fix local changes
@
text
@d65 1
d114 8
a121 4
		HMAC_Init_ex(&hctx, pass, passlen, digest, NULL);
		HMAC_Update(&hctx, salt, saltlen);
		HMAC_Update(&hctx, itmp, 4);
		HMAC_Final(&hctx, digtmp, NULL);
a175 1
	unsigned char *salt, key[EVP_MAX_KEY_LENGTH];
d177 1
a177 2
	int saltlen, iter, plen;
	unsigned int keylen;
d180 2
a181 3
	PBKDF2PARAM *kdf = NULL;
	const EVP_MD *prfmd;
	int prf_nid, hmac_md_nid;
d186 1
a186 1
		return 0;
d193 1
a193 1
		return 0;
d216 2
a217 1
	EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, en_de);
d223 25
d251 1
a251 1
	/* Now decode key derivation function */
d253 1
a253 2
	if(!pbe2->keyfunc->parameter ||
		 (pbe2->keyfunc->parameter->type != V_ASN1_SEQUENCE))
d255 1
a255 1
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,EVP_R_DECODE_ERROR);
d259 3
a261 2
	pbuf = pbe2->keyfunc->parameter->value.sequence->data;
	plen = pbe2->keyfunc->parameter->value.sequence->length;
d263 1
a263 1
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,EVP_R_DECODE_ERROR);
d267 1
a267 2
	PBE2PARAM_free(pbe2);
	pbe2 = NULL;
d272 1
a272 1
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,
d284 1
a284 1
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN, EVP_R_UNSUPPORTED_PRF);
d291 1
a291 1
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN, EVP_R_UNSUPPORTED_PRF);
d296 1
a296 1
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,
d308 2
a309 1
	EVP_CipherInit_ex(ctx, NULL, NULL, key, NULL, en_de);
d312 1
a312 6
	return 1;

	err:
	PBE2PARAM_free(pbe2);
	PBKDF2PARAM_free(kdf);
	return 0;
@


1.8
log
@resolve conflicts
@
text
@d6 1
a6 1
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
d74 2
a75 2
 * derivation function PBKDF2 using the only currently defined function HMAC
 * with SHA1. Verified against test vectors posted by Peter Gutmann
d79 1
a79 1
int PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen,
d81 1
d83 3
a85 3
{
	unsigned char digtmp[SHA_DIGEST_LENGTH], *p, itmp[4];
	int cplen, j, k, tkeylen;
d89 4
d96 10
a105 5
	if(!pass) passlen = 0;
	else if(passlen == -1) passlen = strlen(pass);
	while(tkeylen) {
		if(tkeylen > SHA_DIGEST_LENGTH) cplen = SHA_DIGEST_LENGTH;
		else cplen = tkeylen;
d113 1
a113 1
		HMAC_Init_ex(&hctx, pass, passlen, EVP_sha1(), NULL);
d118 7
a124 5
		for(j = 1; j < iter; j++) {
			HMAC(EVP_sha1(), pass, passlen,
				 digtmp, SHA_DIGEST_LENGTH, digtmp, NULL);
			for(k = 0; k < cplen; k++) p[k] ^= digtmp[k];
		}
d128 1
a128 1
	}
d140 9
a148 1
}
d178 2
d205 1
a205 2
	cipher = EVP_get_cipherbyname(
			OBJ_nid2sn(OBJ_obj2nid(pbe2->encryption->algorithm)));
d250 14
a263 1
	if(kdf->prf && (OBJ_obj2nid(kdf->prf->algorithm) != NID_hmacWithSHA1)) {
d266 1
a266 1
	}
d278 3
a280 1
	PKCS5_PBKDF2_HMAC_SHA1(pass, passlen, salt, saltlen, iter, keylen, key);
@


1.7
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.6
log
@resolve conflicts
@
text
@a57 1
#if !defined(OPENSSL_NO_HMAC) && !defined(OPENSSL_NO_SHA)
d61 1
d80 1
a80 1
			   unsigned char *salt, int saltlen, int iter,
d151 4
a154 2
	unsigned char *pbuf, *salt, key[EVP_MAX_KEY_LENGTH];
	int saltlen, keylen, iter, plen;
d159 6
d167 1
a167 2
	if(!param || (param->type != V_ASN1_SEQUENCE) ||
				   !(pbe2 = d2i_PBE2PARAM(NULL, &pbuf, plen))) {
d223 1
a223 1
	if(kdf->keylength && (ASN1_INTEGER_get(kdf->keylength) != keylen)){
@


1.5
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d197 7
d206 1
a206 3
	if(!pbe2->keyfunc->parameter ||
		 (pbe2->keyfunc->parameter->type != V_ASN1_SEQUENCE) ||
				!(kdf = d2i_PBKDF2PARAM(NULL, &pbuf, plen)) ) {
@


1.4
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d193 1
d234 1
a234 1
	memset(key, 0, keylen);
@


1.3
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d61 1
a64 1
#include "cryptlib.h"
@


1.2
log
@openssl-engine-0.9.6 merge
@
text
@d58 1
a58 1
#if !defined(NO_HMAC) && !defined(NO_SHA)
d87 2
d103 1
a103 1
		HMAC_Init(&hctx, pass, passlen, EVP_sha1());
d117 1
a117 1
	HMAC_cleanup(&hctx);
d148 1
a148 1
                         ASN1_TYPE *param, EVP_CIPHER *c, EVP_MD *md,
d186 1
a186 1
	EVP_CipherInit(ctx, cipher, NULL, NULL, en_de);
d232 1
a232 1
	EVP_CipherInit(ctx, NULL, key, NULL, en_de);
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d89 2
a90 1
	if(passlen == -1) passlen = strlen(pass);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d58 1
a58 1
#if !defined(OPENSSL_NO_HMAC) && !defined(OPENSSL_NO_SHA)
a86 2

	HMAC_CTX_init(&hctx);
d89 1
a89 2
	if(!pass) passlen = 0;
	else if(passlen == -1) passlen = strlen(pass);
d100 1
a100 1
		HMAC_Init_ex(&hctx, pass, passlen, EVP_sha1(), NULL);
d114 1
a114 1
	HMAC_CTX_cleanup(&hctx);
d145 1
a145 1
                         ASN1_TYPE *param, const EVP_CIPHER *c, const EVP_MD *md,
d183 1
a183 1
	EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, en_de);
d229 1
a229 1
	EVP_CipherInit_ex(ctx, NULL, NULL, key, NULL, en_de);
@


1.1.1.2
log
@import openssl-0.9.7-beta3
@
text
@a60 1
#include "cryptlib.h"
d64 1
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@a192 1
	OPENSSL_assert(keylen <= sizeof key);
d233 1
a233 1
	OPENSSL_cleanse(key, keylen);
@


1.1.1.4
log
@import of openssl-0.9.7j
@
text
@a196 7
	if(!pbe2->keyfunc->parameter ||
		 (pbe2->keyfunc->parameter->type != V_ASN1_SEQUENCE))
		{
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,EVP_R_DECODE_ERROR);
		goto err;
		}

d199 3
a201 1
	if(!(kdf = d2i_PBKDF2PARAM(NULL, &pbuf, plen)) ) {
@


1.1.1.5
log
@import of OpenSSL 0.9.8h
@
text
@d58 1
a61 1
#if !defined(OPENSSL_NO_HMAC) && !defined(OPENSSL_NO_SHA)
d80 1
a80 1
			   const unsigned char *salt, int saltlen, int iter,
d151 2
a152 4
	unsigned char *salt, key[EVP_MAX_KEY_LENGTH];
	const unsigned char *pbuf;
	int saltlen, iter, plen;
	unsigned int keylen;
a156 6
	if (param == NULL || param->type != V_ASN1_SEQUENCE ||
	    param->value.sequence == NULL) {
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,EVP_R_DECODE_ERROR);
		return 0;
	}

d159 2
a160 1
	if(!(pbe2 = d2i_PBE2PARAM(NULL, &pbuf, plen))) {
d216 1
a216 1
	if(kdf->keylength && (ASN1_INTEGER_get(kdf->keylength) != (int)keylen)){
@


1.1.1.6
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@d6 1
a6 1
 * Copyright (c) 1999-2006 The OpenSSL Project.  All rights reserved.
d74 2
a75 2
 * derivation function PBKDF2.
 * SHA1 version verified against test vectors posted by Peter Gutmann
d79 1
a79 1
int PKCS5_PBKDF2_HMAC(const char *pass, int passlen,
a80 1
			   const EVP_MD *digest,
d82 3
a84 3
	{
	unsigned char digtmp[EVP_MAX_MD_SIZE], *p, itmp[4];
	int cplen, j, k, tkeylen, mdlen;
a87 4
	mdlen = EVP_MD_size(digest);
	if (mdlen < 0)
		return 0;

d91 5
a95 10
	if(!pass)
		passlen = 0;
	else if(passlen == -1)
		passlen = strlen(pass);
	while(tkeylen)
		{
		if(tkeylen > mdlen)
			cplen = mdlen;
		else
			cplen = tkeylen;
d103 1
a103 1
		HMAC_Init_ex(&hctx, pass, passlen, digest, NULL);
d108 5
a112 7
		for(j = 1; j < iter; j++)
			{
			HMAC(digest, pass, passlen,
				 digtmp, mdlen, digtmp, NULL);
			for(k = 0; k < cplen; k++)
				p[k] ^= digtmp[k];
			}
d116 1
a116 1
		}
d128 1
a128 9
	}

int PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen,
			   const unsigned char *salt, int saltlen, int iter,
			   int keylen, unsigned char *out)
	{
	return PKCS5_PBKDF2_HMAC(pass, passlen, salt, saltlen, iter, EVP_sha1(),
					keylen, out);
	}
a157 2
	const EVP_MD *prfmd;
	int prf_nid, hmac_md_nid;
d183 2
a184 1
	cipher = EVP_get_cipherbyobj(pbe2->encryption->algorithm);
d229 1
a229 7
	if (kdf->prf)
		prf_nid = OBJ_obj2nid(kdf->prf->algorithm);
	else
		prf_nid = NID_hmacWithSHA1;

	if (!EVP_PBE_find(EVP_PBE_TYPE_PRF, prf_nid, NULL, &hmac_md_nid, 0))
		{
d232 1
a232 8
		}

	prfmd = EVP_get_digestbynid(hmac_md_nid);
	if (prfmd == NULL)
		{
		EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN, EVP_R_UNSUPPORTED_PRF);
		goto err;
		}
d244 1
a244 3
	if(!PKCS5_PBKDF2_HMAC(pass, passlen, salt, saltlen, iter, prfmd,
						   keylen, key))
		goto err;
@


1.1.1.8
log
@import OpenSSL-1.0.1c
@
text
@a64 1
#include "evp_locl.h"
d113 4
a116 8
		if (!HMAC_Init_ex(&hctx, pass, passlen, digest, NULL)
			|| !HMAC_Update(&hctx, salt, saltlen)
			|| !HMAC_Update(&hctx, itmp, 4)
			|| !HMAC_Final(&hctx, digtmp, NULL))
			{
			HMAC_CTX_cleanup(&hctx);
			return 0;
			}
d171 1
d173 2
a174 1
	int plen;
d177 3
a179 2

	int rv = 0;
d184 1
a184 1
		goto err;
d191 1
a191 1
		goto err;
d214 1
a214 2
	if (!EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, en_de))
		goto err;
a219 25
	rv = PKCS5_v2_PBKDF2_keyivgen(ctx, pass, passlen,
					pbe2->keyfunc->parameter, c, md, en_de);
	err:
	PBE2PARAM_free(pbe2);
	return rv;
}

int PKCS5_v2_PBKDF2_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
                         ASN1_TYPE *param,
			 const EVP_CIPHER *c, const EVP_MD *md, int en_de)
{
	unsigned char *salt, key[EVP_MAX_KEY_LENGTH];
	const unsigned char *pbuf;
	int saltlen, iter, plen;
	int rv = 0;
	unsigned int keylen = 0;
	int prf_nid, hmac_md_nid;
	PBKDF2PARAM *kdf = NULL;
	const EVP_MD *prfmd;

	if (EVP_CIPHER_CTX_cipher(ctx) == NULL)
		{
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN,EVP_R_NO_CIPHER_SET);
		goto err;
		}
d223 1
a223 1
	/* Decode parameter */
d225 2
a226 1
	if(!param || (param->type != V_ASN1_SEQUENCE))
d228 1
a228 1
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN,EVP_R_DECODE_ERROR);
d232 2
a233 3
	pbuf = param->value.sequence->data;
	plen = param->value.sequence->length;

d235 1
a235 1
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN,EVP_R_DECODE_ERROR);
d239 2
a240 1
	keylen = EVP_CIPHER_CTX_key_length(ctx);
d245 1
a245 1
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN,
d257 1
a257 1
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_UNSUPPORTED_PRF);
d264 1
a264 1
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_UNSUPPORTED_PRF);
d269 1
a269 1
		EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN,
d281 5
a285 1
	rv = EVP_CipherInit_ex(ctx, NULL, NULL, key, NULL, en_de);
d287 1
a287 1
	OPENSSL_cleanse(key, keylen);
d289 1
a289 1
	return rv;
@


1.1.1.9
log
@Import OpenSSL 1.0.1g
@
text
@d88 1
a88 1
	HMAC_CTX hctx_tpl, hctx;
d94 1
a94 1
	HMAC_CTX_init(&hctx_tpl);
a100 5
	if (!HMAC_Init_ex(&hctx_tpl, pass, passlen, digest, NULL))
		{
		HMAC_CTX_cleanup(&hctx_tpl);
		return 0;
		}
d114 4
a117 1
		if (!HMAC_CTX_copy(&hctx, &hctx_tpl))
a118 8
			HMAC_CTX_cleanup(&hctx_tpl);
			return 0;
			}
		if (!HMAC_Update(&hctx, salt, saltlen)
		    || !HMAC_Update(&hctx, itmp, 4)
		    || !HMAC_Final(&hctx, digtmp, NULL))
			{
			HMAC_CTX_cleanup(&hctx_tpl);
a121 1
		HMAC_CTX_cleanup(&hctx);
d125 2
a126 13
			if (!HMAC_CTX_copy(&hctx, &hctx_tpl))
				{
				HMAC_CTX_cleanup(&hctx_tpl);
				return 0;
				}
			if (!HMAC_Update(&hctx, digtmp, mdlen)
			    || !HMAC_Final(&hctx, digtmp, NULL))
				{
				HMAC_CTX_cleanup(&hctx_tpl);
				HMAC_CTX_cleanup(&hctx);
				return 0;
				}
			HMAC_CTX_cleanup(&hctx);
d134 1
a134 1
	HMAC_CTX_cleanup(&hctx_tpl);
@


