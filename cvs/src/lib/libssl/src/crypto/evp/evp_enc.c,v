head	1.31;
access;
symbols
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.4
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	butholakala:1.14
	openssl_1_0_1_g:1.1.1.10
	OPENBSD_5_5:1.14.0.8
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	openssl_1_0_1_c:1.1.1.10
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	openssl_1_0_0_f:1.1.1.9
	openssl_1_0_0_e:1.1.1.9
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	openssh_1_0_0_a:1.1.1.8
	OPENBSD_4_8:1.11.0.8
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.4
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	openssl_0_9_8_k:1.1.1.7
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	openssl_0_9_8_j:1.1.1.7
	openssl_0_9_8_h:1.1.1.6
	pre_openssl_0_9_8h:1.8
	OPENBSD_4_4:1.8.0.14
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.12
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.10
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.8
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.6
	OPENBSD_4_0_BASE:1.8
	openssl_0_9_7j:1.1.1.5
	openssl:1.1.1
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENSSL_0_9_7C:1.1.1.3
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.3.0.6
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.6
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.05.30.13.42.54;	author beck;	state Exp;
branches;
next	1.30;
commitid	P66xC6CnwAnLazTN;

1.30
date	2016.05.04.15.05.13;	author tedu;	state Exp;
branches;
next	1.29;
commitid	tjGQtkBjFU7TMpJf;

1.29
date	2016.05.04.14.53.29;	author tedu;	state Exp;
branches;
next	1.28;
commitid	dp2wUlmUxyODyIfQ;

1.28
date	2016.05.03.12.38.53;	author tedu;	state Exp;
branches;
next	1.27;
commitid	0ClIPo2LiLW7bSvG;

1.27
date	2015.09.10.15.56.25;	author jsing;	state Exp;
branches
	1.27.2.1;
next	1.26;
commitid	vHznCDK3idwNEFz4;

1.26
date	2015.02.10.09.52.35;	author miod;	state Exp;
branches
	1.26.6.1;
next	1.25;
commitid	elQcISUWkrkujoI4;

1.25
date	2014.10.22.13.02.04;	author jsing;	state Exp;
branches;
next	1.24;
commitid	PjnBgKe6Buhbf937;

1.24
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.23;
commitid	yQEL1wOWIearrW15;

1.23
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.22;
commitid	nzndm3zqPmFurSaK;

1.22
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.21;
commitid	id8dTrTMtnTn4fqt;

1.21
date	2014.07.09.11.10.50;	author bcook;	state Exp;
branches;
next	1.20;
commitid	lHJTcoC4c5BhEOGj;

1.20
date	2014.06.15.15.44.39;	author jsing;	state Exp;
branches;
next	1.19;
commitid	XYwjEp2desmg6NQN;

1.19
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	mJUVYpkFBZ0Zv2bG;

1.18
date	2014.05.30.02.52.11;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2014.05.08.15.42.26;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.15.20.06.09;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.01.22.58.55;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.29.05.39.22;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.08.08.03.13;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.12.02.18.37;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.21.01.49.11;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.14;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.57.45;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.14;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.34;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.34;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.27;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.35.21;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.04.07.20.41.43;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.10;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.01.09.12.13.56;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.10.01.22.54.07;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2011.11.03.02.32.11;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2012.10.13.21.23.40;	author djm;	state Exp;
branches;
next	;

1.26.6.1
date	2016.05.03.12.39.23;	author tedu;	state Exp;
branches;
next	;
commitid	5iHrqqr5iZFurKzX;

1.27.2.1
date	2016.05.03.12.39.48;	author tedu;	state Exp;
branches;
next	;
commitid	Ekna9eOpYJ6UbVcF;


desc
@@


1.31
log
@deprecate internal use of EVP_[Cipher|Encrypt|Decrypt]_Final.
14 years ago these were changed in OpenSSL to be the same
as the _ex functions. We use the _ex functions only internally
to ensure it is obvious the ctx must be cleared.
ok bcook@@
@
text
@/* $OpenBSD: evp_enc.c,v 1.30 2016/05/04 15:05:13 tedu Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/opensslconf.h>

#include <openssl/err.h>
#include <openssl/evp.h>

#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif

#include "evp_locl.h"

#define M_do_cipher(ctx, out, in, inl) ctx->cipher->do_cipher(ctx, out, in, inl)

void
EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *ctx)
{
	memset(ctx, 0, sizeof(EVP_CIPHER_CTX));
}

EVP_CIPHER_CTX *
EVP_CIPHER_CTX_new(void)
{
	return calloc(1, sizeof(EVP_CIPHER_CTX));
}

int
EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
    const unsigned char *key, const unsigned char *iv, int enc)
{
	if (cipher)
		EVP_CIPHER_CTX_init(ctx);
	return EVP_CipherInit_ex(ctx, cipher, NULL, key, iv, enc);
}

int
EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl,
    const unsigned char *key, const unsigned char *iv, int enc)
{
	if (enc == -1)
		enc = ctx->encrypt;
	else {
		if (enc)
			enc = 1;
		ctx->encrypt = enc;
	}
#ifndef OPENSSL_NO_ENGINE
	/* Whether it's nice or not, "Inits" can be used on "Final"'d contexts
	 * so this context may already have an ENGINE! Try to avoid releasing
	 * the previous handle, re-querying for an ENGINE, and having a
	 * reinitialisation, when it may all be unecessary. */
	if (ctx->engine && ctx->cipher &&
	    (!cipher || (cipher && (cipher->nid == ctx->cipher->nid))))
		goto skip_to_init;
#endif
	if (cipher) {
		/* Ensure a context left lying around from last time is cleared
		 * (the previous check attempted to avoid this if the same
		 * ENGINE and EVP_CIPHER could be used). */
		if (ctx->cipher) {
			unsigned long flags = ctx->flags;
			EVP_CIPHER_CTX_cleanup(ctx);
			/* Restore encrypt and flags */
			ctx->encrypt = enc;
			ctx->flags = flags;
		}
#ifndef OPENSSL_NO_ENGINE
		if (impl) {
			if (!ENGINE_init(impl)) {
				EVPerr(EVP_F_EVP_CIPHERINIT_EX,
				    EVP_R_INITIALIZATION_ERROR);
				return 0;
			}
		} else
			/* Ask if an ENGINE is reserved for this job */
			impl = ENGINE_get_cipher_engine(cipher->nid);
		if (impl) {
			/* There's an ENGINE for this job ... (apparently) */
			const EVP_CIPHER *c =
			    ENGINE_get_cipher(impl, cipher->nid);
			if (!c) {
				EVPerr(EVP_F_EVP_CIPHERINIT_EX,
				    EVP_R_INITIALIZATION_ERROR);
				return 0;
			}
			/* We'll use the ENGINE's private cipher definition */
			cipher = c;
			/* Store the ENGINE functional reference so we know
			 * 'cipher' came from an ENGINE and we need to release
			 * it when done. */
			ctx->engine = impl;
		} else
			ctx->engine = NULL;
#endif

		ctx->cipher = cipher;
		if (ctx->cipher->ctx_size) {
			ctx->cipher_data = malloc(ctx->cipher->ctx_size);
			if (!ctx->cipher_data) {
				EVPerr(EVP_F_EVP_CIPHERINIT_EX,
				    ERR_R_MALLOC_FAILURE);
				return 0;
			}
		} else {
			ctx->cipher_data = NULL;
		}
		ctx->key_len = cipher->key_len;
		ctx->flags = 0;
		if (ctx->cipher->flags & EVP_CIPH_CTRL_INIT) {
			if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_INIT, 0, NULL)) {
				EVPerr(EVP_F_EVP_CIPHERINIT_EX,
				    EVP_R_INITIALIZATION_ERROR);
				return 0;
			}
		}
	} else if (!ctx->cipher) {
		EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_NO_CIPHER_SET);
		return 0;
	}
#ifndef OPENSSL_NO_ENGINE
skip_to_init:
#endif
	/* we assume block size is a power of 2 in *cryptUpdate */
	if (ctx->cipher->block_size != 1 &&
	    ctx->cipher->block_size != 8 &&
	    ctx->cipher->block_size != 16) {
		EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_BAD_BLOCK_LENGTH);
		return 0;
	}

	if (!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_CUSTOM_IV)) {
		switch (EVP_CIPHER_CTX_mode(ctx)) {

		case EVP_CIPH_STREAM_CIPHER:
		case EVP_CIPH_ECB_MODE:
			break;

		case EVP_CIPH_CFB_MODE:
		case EVP_CIPH_OFB_MODE:

			ctx->num = 0;
			/* fall-through */

		case EVP_CIPH_CBC_MODE:

			if ((size_t)EVP_CIPHER_CTX_iv_length(ctx) >
			    sizeof(ctx->iv)) {
				EVPerr(EVP_F_EVP_CIPHERINIT_EX,
				    EVP_R_IV_TOO_LARGE);
				return 0;
			}
			if (iv)
				memcpy(ctx->oiv, iv,
				    EVP_CIPHER_CTX_iv_length(ctx));
			memcpy(ctx->iv, ctx->oiv,
			    EVP_CIPHER_CTX_iv_length(ctx));
			break;

		case EVP_CIPH_CTR_MODE:
			ctx->num = 0;
			/* Don't reuse IV for CTR mode */
			if (iv)
				memcpy(ctx->iv, iv,
				    EVP_CIPHER_CTX_iv_length(ctx));
			break;

		default:
			return 0;
			break;
		}
	}

	if (key || (ctx->cipher->flags & EVP_CIPH_ALWAYS_CALL_INIT)) {
		if (!ctx->cipher->init(ctx, key, iv, enc))
			return 0;
	}
	ctx->buf_len = 0;
	ctx->final_used = 0;
	ctx->block_mask = ctx->cipher->block_size - 1;
	return 1;
}

int
EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
    const unsigned char *in, int inl)
{
	if (ctx->encrypt)
		return EVP_EncryptUpdate(ctx, out, outl, in, inl);
	else
		return EVP_DecryptUpdate(ctx, out, outl, in, inl);
}

int
EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
{
	if (ctx->encrypt)
		return EVP_EncryptFinal_ex(ctx, out, outl);
	else
		return EVP_DecryptFinal_ex(ctx, out, outl);
}

int
EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
{
	if (ctx->encrypt)
		return EVP_EncryptFinal_ex(ctx, out, outl);
	else
		return EVP_DecryptFinal_ex(ctx, out, outl);
}

int
EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
    const unsigned char *key, const unsigned char *iv)
{
	return EVP_CipherInit(ctx, cipher, key, iv, 1);
}

int
EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl,
    const unsigned char *key, const unsigned char *iv)
{
	return EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 1);
}

int
EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
    const unsigned char *key, const unsigned char *iv)
{
	return EVP_CipherInit(ctx, cipher, key, iv, 0);
}

int
EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl,
    const unsigned char *key, const unsigned char *iv)
{
	return EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 0);
}

int
EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
    const unsigned char *in, int inl)
{
	int i, j, bl;

	if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {
		i = M_do_cipher(ctx, out, in, inl);
		if (i < 0)
			return 0;
		else
			*outl = i;
		return 1;
	}

	if (inl <= 0) {
		*outl = 0;
		return inl == 0;
	}

	if (ctx->buf_len == 0 && (inl&(ctx->block_mask)) == 0) {
		if (M_do_cipher(ctx, out, in, inl)) {
			*outl = inl;
			return 1;
		} else {
			*outl = 0;
			return 0;
		}
	}
	i = ctx->buf_len;
	bl = ctx->cipher->block_size;
	if ((size_t)bl > sizeof(ctx->buf)) {
		EVPerr(EVP_F_EVP_ENCRYPTUPDATE, EVP_R_BAD_BLOCK_LENGTH);
		*outl = 0;
		return 0;
	}
	if (i != 0) {
		if (bl - i > inl) {
			memcpy(&(ctx->buf[i]), in, inl);
			ctx->buf_len += inl;
			*outl = 0;
			return 1;
		} else {
			j = bl - i;
			memcpy(&(ctx->buf[i]), in, j);
			if (!M_do_cipher(ctx, out, ctx->buf, bl))
				return 0;
			inl -= j;
			in += j;
			out += bl;
			*outl = bl;
		}
	} else
		*outl = 0;
	i = inl&(bl - 1);
	inl -= i;
	if (inl > 0) {
		if (!M_do_cipher(ctx, out, in, inl))
			return 0;
		*outl += inl;
	}

	if (i != 0)
		memcpy(ctx->buf, &(in[inl]), i);
	ctx->buf_len = i;
	return 1;
}

int
EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
{
	int ret;

	ret = EVP_EncryptFinal_ex(ctx, out, outl);
	(void) EVP_CIPHER_CTX_cleanup(ctx);
	return ret;
}

int
EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
{
	int n, ret;
	unsigned int i, b, bl;

	if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {
		ret = M_do_cipher(ctx, out, NULL, 0);
		if (ret < 0)
			return 0;
		else
			*outl = ret;
		return 1;
	}

	b = ctx->cipher->block_size;
	if (b > sizeof ctx->buf) {
		EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX, EVP_R_BAD_BLOCK_LENGTH);
		return 0;
	}
	if (b == 1) {
		*outl = 0;
		return 1;
	}
	bl = ctx->buf_len;
	if (ctx->flags & EVP_CIPH_NO_PADDING) {
		if (bl) {
			EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX,
			    EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
			return 0;
		}
		*outl = 0;
		return 1;
	}

	n = b - bl;
	for (i = bl; i < b; i++)
		ctx->buf[i] = n;
	ret = M_do_cipher(ctx, out, ctx->buf, b);


	if (ret)
		*outl = b;

	return ret;
}

int
EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
    const unsigned char *in, int inl)
{
	int fix_len;
	unsigned int b;

	if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {
		fix_len = M_do_cipher(ctx, out, in, inl);
		if (fix_len < 0) {
			*outl = 0;
			return 0;
		} else
			*outl = fix_len;
		return 1;
	}

	if (inl <= 0) {
		*outl = 0;
		return inl == 0;
	}

	if (ctx->flags & EVP_CIPH_NO_PADDING)
		return EVP_EncryptUpdate(ctx, out, outl, in, inl);

	b = ctx->cipher->block_size;
	if (b > sizeof ctx->final) {
		EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_BAD_BLOCK_LENGTH);
		return 0;
	}

	if (ctx->final_used) {
		memcpy(out, ctx->final, b);
		out += b;
		fix_len = 1;
	} else
		fix_len = 0;


	if (!EVP_EncryptUpdate(ctx, out, outl, in, inl))
		return 0;

	/* if we have 'decrypted' a multiple of block size, make sure
	 * we have a copy of this last block */
	if (b > 1 && !ctx->buf_len) {
		*outl -= b;
		ctx->final_used = 1;
		memcpy(ctx->final, &out[*outl], b);
	} else
		ctx->final_used = 0;

	if (fix_len)
		*outl += b;

	return 1;
}

int
EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
{
	int ret;

	ret = EVP_DecryptFinal_ex(ctx, out, outl);
	(void) EVP_CIPHER_CTX_cleanup(ctx);
	return ret;
}

int
EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
{
	int i, n;
	unsigned int b;
	*outl = 0;

	if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {
		i = M_do_cipher(ctx, out, NULL, 0);
		if (i < 0)
			return 0;
		else
			*outl = i;
		return 1;
	}

	b = ctx->cipher->block_size;
	if (ctx->flags & EVP_CIPH_NO_PADDING) {
		if (ctx->buf_len) {
			EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,
			    EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
			return 0;
		}
		*outl = 0;
		return 1;
	}
	if (b > 1) {
		if (ctx->buf_len || !ctx->final_used) {
			EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,
			    EVP_R_WRONG_FINAL_BLOCK_LENGTH);
			return (0);
		}
		if (b > sizeof ctx->final) {
			EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,
			    EVP_R_BAD_BLOCK_LENGTH);
			return 0;
		}
		n = ctx->final[b - 1];
		if (n == 0 || n > (int)b) {
			EVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_BAD_DECRYPT);
			return (0);
		}
		for (i = 0; i < n; i++) {
			if (ctx->final[--b] != n) {
				EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,
				    EVP_R_BAD_DECRYPT);
				return (0);
			}
		}
		n = ctx->cipher->block_size - n;
		for (i = 0; i < n; i++)
			out[i] = ctx->final[i];
		*outl = n;
	} else
		*outl = 0;
	return (1);
}

void
EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx)
{
	if (ctx) {
		EVP_CIPHER_CTX_cleanup(ctx);
		free(ctx);
	}
}

int
EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *c)
{
	if (c->cipher != NULL) {
		if (c->cipher->cleanup && !c->cipher->cleanup(c))
			return 0;
		/* Cleanse cipher context data */
		if (c->cipher_data)
			explicit_bzero(c->cipher_data, c->cipher->ctx_size);
	}
	free(c->cipher_data);
#ifndef OPENSSL_NO_ENGINE
	if (c->engine)
		/* The EVP_CIPHER we used belongs to an ENGINE, release the
		 * functional reference we held for this reason. */
		ENGINE_finish(c->engine);
#endif
	explicit_bzero(c, sizeof(EVP_CIPHER_CTX));
	return 1;
}

int
EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *c, int keylen)
{
	if (c->cipher->flags & EVP_CIPH_CUSTOM_KEY_LENGTH)
		return EVP_CIPHER_CTX_ctrl(c, EVP_CTRL_SET_KEY_LENGTH,
		    keylen, NULL);
	if (c->key_len == keylen)
		return 1;
	if ((keylen > 0) && (c->cipher->flags & EVP_CIPH_VARIABLE_LENGTH)) {
		c->key_len = keylen;
		return 1;
	}
	EVPerr(EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH, EVP_R_INVALID_KEY_LENGTH);
	return 0;
}

int
EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *ctx, int pad)
{
	if (pad)
		ctx->flags &= ~EVP_CIPH_NO_PADDING;
	else
		ctx->flags |= EVP_CIPH_NO_PADDING;
	return 1;
}

int
EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
{
	int ret;

	if (!ctx->cipher) {
		EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_NO_CIPHER_SET);
		return 0;
	}

	if (!ctx->cipher->ctrl) {
		EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_CTRL_NOT_IMPLEMENTED);
		return 0;
	}

	ret = ctx->cipher->ctrl(ctx, type, arg, ptr);
	if (ret == -1) {
		EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL,
		    EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED);
		return 0;
	}
	return ret;
}

int
EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key)
{
	if (ctx->cipher->flags & EVP_CIPH_RAND_KEY)
		return EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_RAND_KEY, 0, key);
	arc4random_buf(key, ctx->key_len);
	return 1;
}

int
EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in)
{
	if ((in == NULL) || (in->cipher == NULL)) {
		EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, EVP_R_INPUT_NOT_INITIALIZED);
		return 0;
	}
#ifndef OPENSSL_NO_ENGINE
	/* Make sure it's safe to copy a cipher context using an ENGINE */
	if (in->engine && !ENGINE_init(in->engine)) {
		EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, ERR_R_ENGINE_LIB);
		return 0;
	}
#endif

	EVP_CIPHER_CTX_cleanup(out);
	memcpy(out, in, sizeof *out);

	if (in->cipher_data && in->cipher->ctx_size) {
		out->cipher_data = malloc(in->cipher->ctx_size);
		if (!out->cipher_data) {
			EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, ERR_R_MALLOC_FAILURE);
			return 0;
		}
		memcpy(out->cipher_data, in->cipher_data, in->cipher->ctx_size);
	}

	if (in->cipher->flags & EVP_CIPH_CUSTOM_COPY)
		return in->cipher->ctrl((EVP_CIPHER_CTX *)in,
		    EVP_CTRL_COPY, 0, out);
	return 1;
}
@


1.30
log
@fix for integer overflow in encode and encrypt update functions.
additionally, in EncodeUpdate, if the amount written would overflow,
return 0 instead to prevent bugs in the caller.
CVE-2016-2105 and CVE-2016-2106 from openssl.
@
text
@d1 1
a1 1
/* $OpenBSD: evp_enc.c,v 1.29 2016/05/04 14:53:29 tedu Exp $ */
d267 1
a267 1
		return EVP_EncryptFinal(ctx, out, outl);
d269 1
a269 1
		return EVP_DecryptFinal(ctx, out, outl);
d374 1
d488 1
d576 1
a576 1
	memset(c, 0, sizeof(EVP_CIPHER_CTX));
@


1.29
log
@revert the big change from yesterday to prepare for smaller commits.
@
text
@d1 1
a1 1
/* $OpenBSD: evp_enc.c,v 1.28 2016/05/03 12:38:53 tedu Exp $ */
d337 1
a337 1
		if (i + inl < bl) {
@


1.28
log
@patch from openssl for multiple issues:
missing padding check in aesni functions
overflow in evp encode functions
use of invalid negative asn.1 types
ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: evp_enc.c,v 1.27 2015/09/10 15:56:25 jsing Exp $ */
d337 1
a337 1
		if (bl - i > inl) {
@


1.27
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp_enc.c,v 1.26 2015/02/10 09:52:35 miod Exp $ */
d337 1
a337 1
		if (i + inl < bl) {
@


1.27.2.1
log
@backport patch from openssl for multiple issues:
missing padding check in aesni functions
overflow in evp encode functions
use of invalid negative asn.1 types
ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: evp_enc.c,v 1.27 2015/09/10 15:56:25 jsing Exp $ */
d337 1
a337 1
		if (bl - i > inl) {
@


1.26
log
@Replace assert() and OPENSSL_assert() calls with proper error return paths.
Careful review, feedback & ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp_enc.c,v 1.25 2014/10/22 13:02:04 jsing Exp $ */
d565 1
a565 1
			OPENSSL_cleanse(c->cipher_data, c->cipher->ctx_size);
@


1.26.6.1
log
@backport patch from openssl for multiple issues:
missing padding check in aesni functions
overflow in evp encode functions
use of invalid negative asn.1 types
ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: evp_enc.c,v 1.26 2015/02/10 09:52:35 miod Exp $ */
d337 1
a337 1
		if (bl - i > inl) {
@


1.25
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random_buf() is guaranteed to always succeed - it is worth noting
that a number of the replaced function calls were already missing return
value checks.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp_enc.c,v 1.24 2014/07/11 08:44:48 jsing Exp $ */
a142 4
				/* One positive side-effect of US's export
				 * control history, is that we should at least
				 * be able to avoid using US mispellings of
				 * "initialisation"? */
d185 6
a190 3
	OPENSSL_assert(ctx->cipher->block_size == 1 ||
	    ctx->cipher->block_size == 8 ||
	    ctx->cipher->block_size == 16);
d207 6
a212 2
			OPENSSL_assert(EVP_CIPHER_CTX_iv_length(ctx) <=
			    (int)sizeof(ctx->iv));
d331 5
a335 1
	OPENSSL_assert(bl <= (int)sizeof(ctx->buf));
d393 4
a396 1
	OPENSSL_assert(b <= sizeof ctx->buf);
d450 4
a453 1
	OPENSSL_assert(b <= sizeof ctx->final);
d522 5
a526 1
		OPENSSL_assert(b <= sizeof ctx->final);
@


1.24
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp_enc.c,v 1.23 2014/07/10 22:45:57 jsing Exp $ */
d60 1
a66 1
#include <openssl/rand.h>
d616 1
a616 2
	if (RAND_bytes(key, ctx->key_len) <= 0)
		return 0;
@


1.23
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: evp_enc.c,v 1.22 2014/07/10 13:58:22 jsing Exp $ */
d64 1
a64 1
#include "cryptlib.h"
a65 1
#include <openssl/err.h>
d67 1
d71 1
@


1.22
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp_enc.c,v 1.21 2014/07/09 11:10:50 bcook Exp $ */
d61 2
@


1.21
log
@remove unused, private version strings except SSL_version_str

Also remove unused des_ver.h, which exports some of these strings, but is not installed.

ok miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp_enc.c,v 1.20 2014/06/15 15:44:39 jsing Exp $ */
d60 2
@


1.20
log
@Simplify EVP_CIPHER_CTX_new() - stop pretending that EVP_CIPHER_CTX_init()
does something special... just use calloc() instead.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp_enc.c,v 1.19 2014/06/12 15:49:29 deraadt Exp $ */
a69 2

const char EVP_version[] = "EVP" OPENSSL_VERSION_PTEXT;
@


1.19
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a76 1
	/* ctx->cipher=NULL; */
d82 1
a82 4
	EVP_CIPHER_CTX *ctx = malloc(sizeof *ctx);
	if (ctx)
		EVP_CIPHER_CTX_init(ctx);
	return ctx;
@


1.18
log
@no need for null check before free. from Brendan MacDonell
@
text
@d1 1
a1 1
/* crypto/evp/evp_enc.c */
@


1.17
log
@KNF.
@
text
@d551 1
a551 2
	if (c->cipher_data)
		free(c->cipher_data);
@


1.16
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d71 1
a71 1
const char EVP_version[]="EVP" OPENSSL_VERSION_PTEXT;
d73 4
a76 3
void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *ctx)
	{
	memset(ctx,0,sizeof(EVP_CIPHER_CTX));
d78 1
a78 1
	}
d80 4
a83 3
EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void)
	{
	EVP_CIPHER_CTX *ctx=malloc(sizeof *ctx);
d87 1
a87 1
	}
d89 4
a92 3
int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
	     const unsigned char *key, const unsigned char *iv, int enc)
	{
d95 2
a96 2
	return EVP_CipherInit_ex(ctx,cipher,NULL,key,iv,enc);
	}
d98 4
a101 3
int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl,
	     const unsigned char *key, const unsigned char *iv, int enc)
	{
d104 1
a104 2
	else
		{
d108 1
a108 1
		}
d114 2
a115 2
	if (ctx->engine && ctx->cipher && (!cipher ||
			(cipher && (cipher->nid == ctx->cipher->nid))))
d118 1
a118 2
	if (cipher)
		{
d122 1
a122 2
		if (ctx->cipher)
			{
d128 1
a128 1
			}
d130 4
a133 5
		if(impl)
			{
			if (!ENGINE_init(impl))
				{
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
a134 1
				}
d136 1
a136 1
		else
d139 1
a139 2
		if(impl)
			{
d141 3
a143 3
			const EVP_CIPHER *c = ENGINE_get_cipher(impl, cipher->nid);
			if(!c)
				{
d148 2
a149 1
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
d151 1
a151 1
				}
d158 1
a158 2
			}
		else
d162 6
a167 7
		ctx->cipher=cipher;
		if (ctx->cipher->ctx_size)
			{
			ctx->cipher_data=malloc(ctx->cipher->ctx_size);
			if (!ctx->cipher_data)
				{
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, ERR_R_MALLOC_FAILURE);
a168 1
				}
d170 1
a170 2
		else
			{
d172 1
a172 1
			}
d175 4
a178 5
		if(ctx->cipher->flags & EVP_CIPH_CTRL_INIT)
			{
			if(!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_INIT, 0, NULL))
				{
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
a179 1
				}
d182 1
a182 2
	else if(!ctx->cipher)
		{
d185 1
a185 1
		}
d190 3
a192 3
	OPENSSL_assert(ctx->cipher->block_size == 1
	    || ctx->cipher->block_size == 8
	    || ctx->cipher->block_size == 16);
d194 2
a195 2
	if(!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_CUSTOM_IV)) {
		switch(EVP_CIPHER_CTX_mode(ctx)) {
d197 2
a198 2
			case EVP_CIPH_STREAM_CIPHER:
			case EVP_CIPH_ECB_MODE:
d201 2
a202 2
			case EVP_CIPH_CFB_MODE:
			case EVP_CIPH_OFB_MODE:
d207 1
a207 1
			case EVP_CIPH_CBC_MODE:
d210 6
a215 3
					(int)sizeof(ctx->iv));
			if(iv) memcpy(ctx->oiv, iv, EVP_CIPHER_CTX_iv_length(ctx));
			memcpy(ctx->iv, ctx->oiv, EVP_CIPHER_CTX_iv_length(ctx));
d218 1
a218 1
			case EVP_CIPH_CTR_MODE:
d221 3
a223 2
			if(iv)
				memcpy(ctx->iv, iv, EVP_CIPHER_CTX_iv_length(ctx));
d226 1
a226 1
			default:
d232 3
a234 2
	if(key || (ctx->cipher->flags & EVP_CIPH_ALWAYS_CALL_INIT)) {
		if(!ctx->cipher->init(ctx,key,iv,enc)) return 0;
d236 3
a238 3
	ctx->buf_len=0;
	ctx->final_used=0;
	ctx->block_mask=ctx->cipher->block_size-1;
d240 1
a240 1
	}
d242 4
a245 3
int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
	     const unsigned char *in, int inl)
	{
d247 4
a250 3
		return EVP_EncryptUpdate(ctx,out,outl,in,inl);
	else	return EVP_DecryptUpdate(ctx,out,outl,in,inl);
	}
d252 3
a254 2
int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
	{
d256 4
a259 3
		return EVP_EncryptFinal_ex(ctx,out,outl);
	else	return EVP_DecryptFinal_ex(ctx,out,outl);
	}
d261 3
a263 2
int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
	{
d265 4
a268 3
		return EVP_EncryptFinal(ctx,out,outl);
	else	return EVP_DecryptFinal(ctx,out,outl);
	}
d270 4
a273 3
int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
	     const unsigned char *key, const unsigned char *iv)
	{
d275 1
a275 1
	}
d277 4
a280 3
int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher, ENGINE *impl,
		const unsigned char *key, const unsigned char *iv)
	{
d282 1
a282 1
	}
d284 4
a287 3
int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
	     const unsigned char *key, const unsigned char *iv)
	{
d289 1
a289 1
	}
d291 4
a294 3
int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl,
	     const unsigned char *key, const unsigned char *iv)
	{
d296 1
a296 1
	}
d298 5
a302 4
int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
	     const unsigned char *in, int inl)
	{
	int i,j,bl;
d304 1
a304 2
	if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER)
		{
d311 1
a311 1
		}
d313 1
a313 2
	if (inl <= 0)
		{
d316 1
a316 1
		}
d318 3
a320 5
	if(ctx->buf_len == 0 && (inl&(ctx->block_mask)) == 0)
		{
		if(M_do_cipher(ctx,out,in,inl))
			{
			*outl=inl;
d322 2
a323 4
			}
		else
			{
			*outl=0;
a324 1
			}
d326 3
a328 2
	i=ctx->buf_len;
	bl=ctx->cipher->block_size;
d330 5
a334 7
	if (i != 0)
		{
		if (i+inl < bl)
			{
			memcpy(&(ctx->buf[i]),in,inl);
			ctx->buf_len+=inl;
			*outl=0;
d336 9
a344 11
			}
		else
			{
			j=bl-i;
			memcpy(&(ctx->buf[i]),in,j);
			if(!M_do_cipher(ctx,out,ctx->buf,bl)) return 0;
			inl-=j;
			in+=j;
			out+=bl;
			*outl=bl;
			}
d346 1
a346 1
	else
d348 7
a354 7
	i=inl&(bl-1);
	inl-=i;
	if (inl > 0)
		{
		if(!M_do_cipher(ctx,out,in,inl)) return 0;
		*outl+=inl;
		}
d357 2
a358 2
		memcpy(ctx->buf,&(in[inl]),i);
	ctx->buf_len=i;
d360 1
a360 1
	}
d362 3
a364 2
int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
	{
d366 1
d369 1
a369 1
	}
d371 4
a374 3
int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
	{
	int n,ret;
d377 1
a377 2
	if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER)
		{
d381 1
a381 1
		else 
d384 1
a384 1
		}
d386 1
a386 1
	b=ctx->cipher->block_size;
d388 2
a389 3
	if (b == 1)
		{
		*outl=0;
d391 7
a398 8
	bl=ctx->buf_len;
	if (ctx->flags & EVP_CIPH_NO_PADDING)
		{
		if(bl)
			{
			EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
			return 0;
			}
d401 1
a401 1
		}
d403 4
a406 4
	n=b-bl;
	for (i=bl; i<b; i++)
		ctx->buf[i]=n;
	ret=M_do_cipher(ctx,out,ctx->buf,b);
d409 2
a410 2
	if(ret)
		*outl=b;
d413 1
a413 1
	}
d415 4
a418 3
int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
	     const unsigned char *in, int inl)
	{
d422 1
a422 2
	if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER)
		{
d424 1
a424 2
		if (fix_len < 0)
			{
d427 1
a427 2
			}
		else
d430 1
a430 1
		}
d432 1
a432 2
	if (inl <= 0)
		{
d435 1
a435 1
		}
d440 1
a440 1
	b=ctx->cipher->block_size;
d443 3
a445 4
	if(ctx->final_used)
		{
		memcpy(out,ctx->final,b);
		out+=b;
d447 1
a447 2
		}
	else
d451 1
a451 1
	if(!EVP_EncryptUpdate(ctx,out,outl,in,inl))
d456 5
a460 7
	if (b > 1 && !ctx->buf_len)
		{
		*outl-=b;
		ctx->final_used=1;
		memcpy(ctx->final,&out[*outl],b);
		}
	else
d465 1
a465 1
		
d467 1
a467 1
	}
d469 3
a471 2
int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
	{
d473 1
d476 1
a476 1
	}
d478 4
a481 3
int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
	{
	int i,n;
d483 1
a483 1
	*outl=0;
d485 1
a485 2
	if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER)
		{
d492 1
a492 1
		}
d494 5
a498 6
	b=ctx->cipher->block_size;
	if (ctx->flags & EVP_CIPH_NO_PADDING)
		{
		if(ctx->buf_len)
			{
			EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
d500 1
a500 1
			}
d503 6
a509 7
	if (b > 1)
		{
		if (ctx->buf_len || !ctx->final_used)
			{
			EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_WRONG_FINAL_BLOCK_LENGTH);
			return(0);
			}
d511 20
a530 23
		n=ctx->final[b-1];
		if (n == 0 || n > (int)b)
			{
			EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT);
			return(0);
			}
		for (i=0; i<n; i++)
			{
			if (ctx->final[--b] != n)
				{
				EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT);
				return(0);
				}
			}
		n=ctx->cipher->block_size-n;
		for (i=0; i<n; i++)
			out[i]=ctx->final[i];
		*outl=n;
		}
	else
		*outl=0;
	return(1);
	}
d532 4
a535 4
void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx)
	{
	if (ctx)
		{
a537 1
		}
d539 1
d541 5
a545 5
int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *c)
	{
	if (c->cipher != NULL)
		{
		if(c->cipher->cleanup && !c->cipher->cleanup(c))
d550 1
a550 1
		}
d559 1
a559 1
	memset(c,0,sizeof(EVP_CIPHER_CTX));
d561 1
a561 1
	}
d563 9
a571 7
int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *c, int keylen)
	{
	if(c->cipher->flags & EVP_CIPH_CUSTOM_KEY_LENGTH) 
		return EVP_CIPHER_CTX_ctrl(c, EVP_CTRL_SET_KEY_LENGTH, keylen, NULL);
	if(c->key_len == keylen) return 1;
	if((keylen > 0) && (c->cipher->flags & EVP_CIPH_VARIABLE_LENGTH))
		{
d574 2
a575 2
		}
	EVPerr(EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH,EVP_R_INVALID_KEY_LENGTH);
d577 1
a577 1
	}
d579 7
a585 4
int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *ctx, int pad)
	{
	if (pad) ctx->flags &= ~EVP_CIPH_NO_PADDING;
	else ctx->flags |= EVP_CIPH_NO_PADDING;
d587 1
a587 1
	}
d589 2
a590 1
int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
d593 2
a594 1
	if(!ctx->cipher) {
d599 1
a599 1
	if(!ctx->cipher->ctrl) {
d605 3
a607 2
	if(ret == -1) {
		EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED);
d613 3
a615 2
int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key)
	{
d621 1
a621 1
	}
d623 5
a627 5
int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in)
	{
	if ((in == NULL) || (in->cipher == NULL))
		{
		EVPerr(EVP_F_EVP_CIPHER_CTX_COPY,EVP_R_INPUT_NOT_INITIALIZED);
d629 1
a629 1
		}
d632 2
a633 3
	if (in->engine && !ENGINE_init(in->engine))
		{
		EVPerr(EVP_F_EVP_CIPHER_CTX_COPY,ERR_R_ENGINE_LIB);
d635 1
a635 1
		}
d639 1
a639 1
	memcpy(out,in,sizeof *out);
d641 4
a644 6
	if (in->cipher_data && in->cipher->ctx_size)
		{
		out->cipher_data=malloc(in->cipher->ctx_size);
		if (!out->cipher_data)
			{
			EVPerr(EVP_F_EVP_CIPHER_CTX_COPY,ERR_R_MALLOC_FAILURE);
a645 2
			}
		memcpy(out->cipher_data,in->cipher_data,in->cipher->ctx_size);
d647 2
d651 2
a652 1
		return in->cipher->ctrl((EVP_CIPHER_CTX *)in, EVP_CTRL_COPY, 0, out);
d654 1
a654 2
	}

@


1.15
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok beck deraadt
@
text
@d81 1
a81 1
	EVP_CIPHER_CTX *ctx=OPENSSL_malloc(sizeof *ctx);
d167 1
a167 1
			ctx->cipher_data=OPENSSL_malloc(ctx->cipher->ctx_size);
d549 1
a549 1
		OPENSSL_free(ctx);
d564 1
a564 1
		OPENSSL_free(c->cipher_data);
d647 1
a647 1
		out->cipher_data=OPENSSL_malloc(in->cipher->ctx_size);
@


1.14
log
@resolve conflicts
@
text
@a66 3
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif
a68 3
#ifdef OPENSSL_FIPS
#define M_do_cipher(ctx, out, in, inl) FIPS_cipher(ctx, out, in, inl)
#else
a69 2
#endif

a163 4
#ifdef OPENSSL_FIPS
		if (FIPS_mode())
			return FIPS_cipherinit(ctx, cipher, key, iv, enc);
#endif
a196 4
#ifdef OPENSSL_FIPS
	if (FIPS_mode())
		return FIPS_cipherinit(ctx, cipher, key, iv, enc);
#endif
a554 1
#ifndef OPENSSL_FIPS
a564 1
#endif
a569 3
#endif
#ifdef OPENSSL_FIPS
	FIPS_cipher_ctx_cleanup(c);
@


1.13
log
@openssl-1.0.0e: resolve conflicts
@
text
@d67 3
d72 7
d128 8
a135 4
		EVP_CIPHER_CTX_cleanup(ctx);

		/* Restore encrypt field: it is zeroed by cleanup */
		ctx->encrypt = enc;
d172 4
d209 4
d239 7
d312 10
d330 1
a330 1
		if(ctx->cipher->do_cipher(ctx,out,in,inl))
d357 1
a357 1
			if(!ctx->cipher->do_cipher(ctx,out,ctx->buf,bl)) return 0;
d370 1
a370 1
		if(!ctx->cipher->do_cipher(ctx,out,in,inl)) return 0;
d392 10
d424 1
a424 1
	ret=ctx->cipher->do_cipher(ctx,out,ctx->buf,b);
d439 13
d505 11
a516 1
	*outl=0;
d571 1
d582 1
d588 3
@


1.12
log
@resolve conflicts, fix local changes
@
text
@d207 1
@


1.11
log
@resolve conflicts
@
text
@d69 1
a69 7
#ifdef OPENSSL_FIPS
	#define M_do_cipher(ctx, out, in, inl) \
		EVP_Cipher(ctx,out,in,inl)
#else
	#define M_do_cipher(ctx, out, in, inl) \
		ctx->cipher->do_cipher(ctx,out,in,inl)
#endif
d71 5
a75 1
const char EVP_version[]="EVP" OPENSSL_VERSION_PTEXT;
d93 138
d290 1
a290 1
		if(M_do_cipher(ctx,out,in,inl))
d317 1
a317 1
			if(!M_do_cipher(ctx,out,ctx->buf,bl)) return 0;
d330 1
a330 1
		if(!M_do_cipher(ctx,out,in,inl)) return 0;
d374 1
a374 1
	ret=M_do_cipher(ctx,out,ctx->buf,b);
d496 22
d539 21
d569 7
d577 7
d585 2
a586 1
#ifdef OPENSSL_FIPS
d588 1
a588 3
static int do_evp_enc_engine_full(EVP_CIPHER_CTX *ctx, const EVP_CIPHER **pcipher, ENGINE *impl)
	{
	if(impl)
d590 2
a591 1
		if (!ENGINE_init(impl))
d593 1
a593 1
			EVPerr(EVP_F_DO_EVP_ENC_ENGINE_FULL, EVP_R_INITIALIZATION_ERROR);
d596 1
d598 3
a600 25
	else
		/* Ask if an ENGINE is reserved for this job */
		impl = ENGINE_get_cipher_engine((*pcipher)->nid);
	if(impl)
		{
		/* There's an ENGINE for this job ... (apparently) */
		const EVP_CIPHER *c = ENGINE_get_cipher(impl, (*pcipher)->nid);
		if(!c)
			{
			/* One positive side-effect of US's export
			 * control history, is that we should at least
			 * be able to avoid using US mispellings of
			 * "initialisation"? */
			EVPerr(EVP_F_DO_EVP_ENC_ENGINE_FULL, EVP_R_INITIALIZATION_ERROR);
			return 0;
			}
		/* We'll use the ENGINE's private cipher definition */
		*pcipher = c;
		/* Store the ENGINE functional reference so we know
		 * 'cipher' came from an ENGINE and we need to release
		 * it when done. */
		ctx->engine = impl;
		}
	else
		ctx->engine = NULL;
a603 9
void int_EVP_CIPHER_init_engine_callbacks(void)
	{
	int_EVP_CIPHER_set_engine_callbacks(
		ENGINE_finish, do_evp_enc_engine_full);
	}

#endif

#endif
@


1.10
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d69 8
a78 6
void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *ctx)
	{
	memset(ctx,0,sizeof(EVP_CIPHER_CTX));
	/* ctx->cipher=NULL; */
	}

a94 138
int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl,
	     const unsigned char *key, const unsigned char *iv, int enc)
	{
	if (enc == -1)
		enc = ctx->encrypt;
	else
		{
		if (enc)
			enc = 1;
		ctx->encrypt = enc;
		}
#ifndef OPENSSL_NO_ENGINE
	/* Whether it's nice or not, "Inits" can be used on "Final"'d contexts
	 * so this context may already have an ENGINE! Try to avoid releasing
	 * the previous handle, re-querying for an ENGINE, and having a
	 * reinitialisation, when it may all be unecessary. */
	if (ctx->engine && ctx->cipher && (!cipher ||
			(cipher && (cipher->nid == ctx->cipher->nid))))
		goto skip_to_init;
#endif
	if (cipher)
		{
		/* Ensure a context left lying around from last time is cleared
		 * (the previous check attempted to avoid this if the same
		 * ENGINE and EVP_CIPHER could be used). */
		EVP_CIPHER_CTX_cleanup(ctx);

		/* Restore encrypt field: it is zeroed by cleanup */
		ctx->encrypt = enc;
#ifndef OPENSSL_NO_ENGINE
		if(impl)
			{
			if (!ENGINE_init(impl))
				{
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
				return 0;
				}
			}
		else
			/* Ask if an ENGINE is reserved for this job */
			impl = ENGINE_get_cipher_engine(cipher->nid);
		if(impl)
			{
			/* There's an ENGINE for this job ... (apparently) */
			const EVP_CIPHER *c = ENGINE_get_cipher(impl, cipher->nid);
			if(!c)
				{
				/* One positive side-effect of US's export
				 * control history, is that we should at least
				 * be able to avoid using US mispellings of
				 * "initialisation"? */
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
				return 0;
				}
			/* We'll use the ENGINE's private cipher definition */
			cipher = c;
			/* Store the ENGINE functional reference so we know
			 * 'cipher' came from an ENGINE and we need to release
			 * it when done. */
			ctx->engine = impl;
			}
		else
			ctx->engine = NULL;
#endif

		ctx->cipher=cipher;
		if (ctx->cipher->ctx_size)
			{
			ctx->cipher_data=OPENSSL_malloc(ctx->cipher->ctx_size);
			if (!ctx->cipher_data)
				{
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, ERR_R_MALLOC_FAILURE);
				return 0;
				}
			}
		else
			{
			ctx->cipher_data = NULL;
			}
		ctx->key_len = cipher->key_len;
		ctx->flags = 0;
		if(ctx->cipher->flags & EVP_CIPH_CTRL_INIT)
			{
			if(!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_INIT, 0, NULL))
				{
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
				return 0;
				}
			}
		}
	else if(!ctx->cipher)
		{
		EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_NO_CIPHER_SET);
		return 0;
		}
#ifndef OPENSSL_NO_ENGINE
skip_to_init:
#endif
	/* we assume block size is a power of 2 in *cryptUpdate */
	OPENSSL_assert(ctx->cipher->block_size == 1
	    || ctx->cipher->block_size == 8
	    || ctx->cipher->block_size == 16);

	if(!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_CUSTOM_IV)) {
		switch(EVP_CIPHER_CTX_mode(ctx)) {

			case EVP_CIPH_STREAM_CIPHER:
			case EVP_CIPH_ECB_MODE:
			break;

			case EVP_CIPH_CFB_MODE:
			case EVP_CIPH_OFB_MODE:

			ctx->num = 0;

			case EVP_CIPH_CBC_MODE:

			OPENSSL_assert(EVP_CIPHER_CTX_iv_length(ctx) <=
					(int)sizeof(ctx->iv));
			if(iv) memcpy(ctx->oiv, iv, EVP_CIPHER_CTX_iv_length(ctx));
			memcpy(ctx->iv, ctx->oiv, EVP_CIPHER_CTX_iv_length(ctx));
			break;

			default:
			return 0;
			break;
		}
	}

	if(key || (ctx->cipher->flags & EVP_CIPH_ALWAYS_CALL_INIT)) {
		if(!ctx->cipher->init(ctx,key,iv,enc)) return 0;
	}
	ctx->buf_len=0;
	ctx->final_used=0;
	ctx->block_mask=ctx->cipher->block_size-1;
	return 1;
	}

d154 1
a154 1
		if(ctx->cipher->do_cipher(ctx,out,in,inl))
d181 1
a181 1
			if(!ctx->cipher->do_cipher(ctx,out,ctx->buf,bl)) return 0;
d194 1
a194 1
		if(!ctx->cipher->do_cipher(ctx,out,in,inl)) return 0;
d238 1
a238 1
	ret=ctx->cipher->do_cipher(ctx,out,ctx->buf,b);
a359 22
int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *c)
	{
	if (c->cipher != NULL)
		{
		if(c->cipher->cleanup && !c->cipher->cleanup(c))
			return 0;
		/* Cleanse cipher context data */
		if (c->cipher_data)
			OPENSSL_cleanse(c->cipher_data, c->cipher->ctx_size);
		}
	if (c->cipher_data)
		OPENSSL_free(c->cipher_data);
#ifndef OPENSSL_NO_ENGINE
	if (c->engine)
		/* The EVP_CIPHER we used belongs to an ENGINE, release the
		 * functional reference we held for this reason. */
		ENGINE_finish(c->engine);
#endif
	memset(c,0,sizeof(EVP_CIPHER_CTX));
	return 1;
	}

d381 5
a385 5
int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
{
	int ret;
	if(!ctx->cipher) {
		EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_NO_CIPHER_SET);
d387 1
d390 3
a392 4
	if(!ctx->cipher->ctrl) {
		EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_CTRL_NOT_IMPLEMENTED);
		return 0;
	}
d394 36
a429 4
	ret = ctx->cipher->ctrl(ctx, type, arg, ptr);
	if(ret == -1) {
		EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED);
		return 0;
a430 2
	return ret;
}
d432 1
a432 1
int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key)
d434 2
a435 5
	if (ctx->cipher->flags & EVP_CIPH_RAND_KEY)
		return EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_RAND_KEY, 0, key);
	if (RAND_bytes(key, ctx->key_len) <= 0)
		return 0;
	return 1;
d438 3
@


1.9
log
@resolve conflicts
@
text
@d282 6
a287 1
	OPENSSL_assert(inl > 0);
d389 1
a389 1
	if (inl == 0)
d391 2
a392 2
		*outl=0;
		return 1;
@


1.8
log
@resolve conflicts
@
text
@d63 1
d69 1
a69 1
const char *EVP_version="EVP" OPENSSL_VERSION_PTEXT;
d77 7
a92 42
#ifdef OPENSSL_FIPS

/* The purpose of these is to trap programs that attempt to use non FIPS
 * algorithms in FIPS mode and ignore the errors.
 */

int bad_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
	    const unsigned char *iv, int enc)
	{ FIPS_ERROR_IGNORED("Cipher init"); return 0;}

int bad_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
		 const unsigned char *in, unsigned int inl)
	{ FIPS_ERROR_IGNORED("Cipher update"); return 0;}

/* NB: no cleanup because it is allowed after failed init */

int bad_set_asn1(EVP_CIPHER_CTX *ctx, ASN1_TYPE *typ)
	{ FIPS_ERROR_IGNORED("Cipher set_asn1"); return 0;}
int bad_get_asn1(EVP_CIPHER_CTX *ctx, ASN1_TYPE *typ)
	{ FIPS_ERROR_IGNORED("Cipher get_asn1"); return 0;}
int bad_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
	{ FIPS_ERROR_IGNORED("Cipher ctrl"); return 0;}

static const EVP_CIPHER bad_cipher =
	{
	0,
	0,
	0,
	0,
	0,
	bad_init,
	bad_do_cipher,
	NULL,
	0,
	bad_set_asn1,
	bad_get_asn1,
	bad_ctrl,
	NULL
	};

#endif

d127 1
a127 1
				EVPerr(EVP_F_EVP_CIPHERINIT, EVP_R_INITIALIZATION_ERROR);
d144 1
a144 1
				EVPerr(EVP_F_EVP_CIPHERINIT, EVP_R_INITIALIZATION_ERROR);
d157 1
d164 1
a164 1
				EVPerr(EVP_F_EVP_CIPHERINIT, ERR_R_MALLOC_FAILURE);
d178 1
a178 1
				EVPerr(EVP_F_EVP_CIPHERINIT, EVP_R_INITIALIZATION_ERROR);
d185 1
a185 1
		EVPerr(EVP_F_EVP_CIPHERINIT, EVP_R_NO_CIPHER_SET);
d210 2
a211 1
			OPENSSL_assert(EVP_CIPHER_CTX_iv_length(ctx) <= sizeof ctx->iv);
a221 18
#ifdef OPENSSL_FIPS
	/* After 'key' is set no further parameters changes are permissible.
	 * So only check for non FIPS enabling at this point.
	 */
	if (key && FIPS_mode())
		{
		if (!(ctx->cipher->flags & EVP_CIPH_FLAG_FIPS)
			& !(ctx->flags & EVP_CIPH_FLAG_NON_FIPS_ALLOW))
			{
			EVPerr(EVP_F_EVP_CIPHERINIT, EVP_R_DISABLED_FOR_FIPS);
			ERR_add_error_data(2, "cipher=",
						EVP_CIPHER_name(ctx->cipher));
			ctx->cipher = &bad_cipher;
			return 0;
			}
		}
#endif

d298 1
a298 1
	OPENSSL_assert(bl <= sizeof ctx->buf);
d344 2
a345 1
	int i,n,b,bl,ret;
d359 1
a359 1
			EVPerr(EVP_F_EVP_ENCRYPTFINAL,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
d381 2
a382 1
	int b, fix_len;
d435 2
a436 2
	int i,b;
	int n;
d444 1
a444 1
			EVPerr(EVP_F_EVP_DECRYPTFINAL,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
d454 1
a454 1
			EVPerr(EVP_F_EVP_DECRYPTFINAL,EVP_R_WRONG_FINAL_BLOCK_LENGTH);
d459 1
a459 1
		if (n > b)
d461 1
a461 1
			EVPerr(EVP_F_EVP_DECRYPTFINAL,EVP_R_BAD_DECRYPT);
d468 1
a468 1
				EVPerr(EVP_F_EVP_DECRYPTFINAL,EVP_R_BAD_DECRYPT);
d482 9
d554 10
@


1.7
log
@merge 0.9.7d
@
text
@d85 42
a190 1

d253 18
@


1.6
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d151 13
a163 1
		ctx->cipher_data=OPENSSL_malloc(ctx->cipher->ctx_size);
@


1.5
log
@Merge openssl-0.9.7-stable-SNAP-20020519
@
text
@d63 1
d65 1
a67 2
#include <assert.h>

d96 1
d104 1
d114 1
d148 1
d168 1
d170 1
d172 3
a174 3
	assert(ctx->cipher->block_size == 1
	       || ctx->cipher->block_size == 8
	       || ctx->cipher->block_size == 16);
d190 1
d247 1
a247 1
	return EVP_CipherInit_ex(ctx, cipher, NULL, key, iv, 0);
d261 1
d277 1
d326 1
d371 1
d434 1
d465 1
a465 1
		/* Zero cipher context data */
d467 1
a467 1
			memset(c->cipher_data, 0, c->cipher->ctx_size);
d471 1
d476 1
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d105 1
a105 1
		/* Ensure an ENGINE left lying around from last time is cleared
d108 4
a111 2
		if(ctx->engine)
			ENGINE_finish(ctx->engine);
d145 1
a308 1
	EVP_CIPHER_CTX_cleanup(ctx);
a318 1
		EVP_CIPHER_CTX_cleanup(ctx);
a324 1
		EVP_CIPHER_CTX_cleanup(ctx);
a338 1
	EVP_CIPHER_CTX_cleanup(ctx);
a395 1
	EVP_CIPHER_CTX_cleanup(ctx);
a407 1
		EVP_CIPHER_CTX_cleanup(ctx);
a419 1
			EVP_CIPHER_CTX_cleanup(ctx);
a425 1
			EVP_CIPHER_CTX_cleanup(ctx);
a432 1
				EVP_CIPHER_CTX_cleanup(ctx);
a443 1
	EVP_CIPHER_CTX_cleanup(ctx);
d449 1
a449 1
	if ((c->cipher != NULL) && (c->cipher->cleanup != NULL))
d451 5
a455 1
		if(!c->cipher->cleanup(c)) return 0;
d457 2
a458 1
	OPENSSL_free(c->cipher_data);
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d63 1
d66 2
d76 1
d78 1
a78 1
	     unsigned char *key, unsigned char *iv, int enc)
d80 63
a142 2
	if(enc && (enc != -1)) enc = 1;
	if (cipher) {
d144 1
d146 5
a150 2
		if(ctx->cipher->flags & EVP_CIPH_CTRL_INIT) {
			if(!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_INIT, 0, NULL)) {
d153 1
d156 2
a157 1
	} else if(!ctx->cipher) {
d160 7
a166 1
	}
a193 1
	if(enc != -1) ctx->encrypt=enc;
d195 2
d201 1
a201 1
	     unsigned char *in, int inl)
d208 7
d219 1
a219 1
	else	return(EVP_DecryptFinal(ctx,out,outl));
d223 1
a223 1
	     unsigned char *key, unsigned char *iv)
d228 6
d235 1
a235 1
	     unsigned char *key, unsigned char *iv)
d237 1
a237 1
	return EVP_CipherInit(ctx, cipher, key, iv, 0);
d240 5
d247 1
a247 1
	     unsigned char *in, int inl)
d251 13
a265 2
	*outl=0;
	if ((inl == 0) && (i != bl)) return 1;
d272 1
d278 1
a278 1
			if (j != 0) memcpy(&(ctx->buf[i]),in,j);
d283 1
a283 1
			*outl+=bl;
d286 3
a288 1
	i=inl%bl; /* how much is left */
d304 9
a312 1
	int i,n,b,bl;
d317 1
d322 12
d337 8
a344 3
	if(!ctx->cipher->do_cipher(ctx,out,ctx->buf,b)) return 0;
	*outl=b;
	return 1;
d348 1
a348 1
	     unsigned char *in, int inl)
d350 7
a356 2
	int b,bl,n;
	int keep_last=0;
d358 2
a359 2
	*outl=0;
	if (inl == 0) return 1;
d362 2
a363 1
	if (b > 1)
d365 3
a367 15
		/* Is the input a multiple of the block size? */
		bl=ctx->buf_len;
		n=inl+bl;
		if (n%b == 0)
			{
			if (inl < b) /* must be 'just one' buff */
				{
				memcpy(&(ctx->buf[bl]),in,inl);
				ctx->buf_len=b;
				*outl=0;
				return 1;
				}
			keep_last=1;
			inl-=b; /* don't do the last block */
			}
d369 6
a374 1
	if(!EVP_EncryptUpdate(ctx,out,outl,in,inl)) return 0;
d378 1
a378 1
	if (keep_last)
d380 3
a382 8
		memcpy(&(ctx->buf[0]),&(in[inl]),b);
#ifdef DEBUG
		if (ctx->buf_len != 0)
			{
			abort();
			}
#endif
		ctx->buf_len=b;
d384 6
d395 8
d408 11
d421 1
a421 1
		if (ctx->buf_len != b)
d423 1
d427 1
a427 4
		if(!EVP_EncryptUpdate(ctx,ctx->buf,&n,ctx->buf,0)) return 0;
		if (n != b)
			return(0);
		n=ctx->buf[b-1];
d430 1
d436 1
a436 1
			if (ctx->buf[--b] != n)
d438 1
d445 1
a445 1
			out[i]=ctx->buf[i];
d450 1
d460 5
d481 7
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d62 2
d73 1
a73 1
void EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *data,
d76 13
a88 4
	if (enc)
		EVP_EncryptInit(ctx,data,key,iv);
	else	
		EVP_DecryptInit(ctx,data,key,iv);
d90 9
d100 23
a122 1
void EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
d126 2
a127 2
		EVP_EncryptUpdate(ctx,out,outl,in,inl);
	else	EVP_DecryptUpdate(ctx,out,outl,in,inl);
d133 1
a133 4
		{
		EVP_EncryptFinal(ctx,out,outl);
		return(1);
		}
d137 1
a137 1
void EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
d140 1
a140 5
	if (cipher != NULL)
		ctx->cipher=cipher;
	ctx->cipher->init(ctx,key,iv,1);
	ctx->encrypt=1;
	ctx->buf_len=0;
d143 1
a143 1
void EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
d146 1
a146 5
	if (cipher != NULL)
		ctx->cipher=cipher;
	ctx->cipher->init(ctx,key,iv,0);
	ctx->encrypt=0;
	ctx->buf_len=0;
d150 1
a150 1
void EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
d158 1
a158 1
	if ((inl == 0) && (i != bl)) return;
d165 1
a165 1
			return;
d171 1
a171 1
			ctx->cipher->do_cipher(ctx,out,ctx->buf,bl);
d182 1
a182 1
		ctx->cipher->do_cipher(ctx,out,in,inl);
d189 1
d192 1
a192 1
void EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
d200 1
a200 1
		return;
d206 1
a206 1
	ctx->cipher->do_cipher(ctx,out,ctx->buf,b);
d208 1
d211 1
a211 1
void EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
d218 1
a218 1
	if (inl == 0) return;
d233 1
a233 1
				return;
d239 1
a239 1
	EVP_EncryptUpdate(ctx,out,outl,in,inl);
d254 1
d271 1
a271 1
		EVP_EncryptUpdate(ctx,ctx->buf,&n,ctx->buf,0);
d298 1
a298 1
void EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *c)
d301 3
a303 1
		c->cipher->cleanup(c);
d305 28
d335 7
@


1.1
log
@Initial revision
@
text
@d61 1
a61 1
#include "evp.h"
d63 1
a63 1
char *EVP_version="EVP part of SSLeay 0.9.0b 29-Jun-1998";
d65 1
a65 2
void EVP_CIPHER_CTX_init(ctx)
EVP_CIPHER_CTX *ctx;
d71 2
a72 6
void EVP_CipherInit(ctx,data,key,iv,enc)
EVP_CIPHER_CTX *ctx;
EVP_CIPHER *data;
unsigned char *key;
unsigned char *iv;
int enc;
d80 2
a81 6
void EVP_CipherUpdate(ctx,out,outl,in,inl)
EVP_CIPHER_CTX *ctx;
unsigned char *out;
int *outl;
unsigned char *in;
int inl;
d88 1
a88 4
int EVP_CipherFinal(ctx,out,outl)
EVP_CIPHER_CTX *ctx;
unsigned char *out;
int *outl;
d98 2
a99 5
void EVP_EncryptInit(ctx,cipher,key,iv)
EVP_CIPHER_CTX *ctx;
EVP_CIPHER *cipher;
unsigned char *key;
unsigned char *iv;
d108 2
a109 5
void EVP_DecryptInit(ctx,cipher,key,iv)
EVP_CIPHER_CTX *ctx;
EVP_CIPHER *cipher;
unsigned char *key;
unsigned char *iv;
d119 2
a120 6
void EVP_EncryptUpdate(ctx,out,outl,in,inl)
EVP_CIPHER_CTX *ctx;
unsigned char *out;
int *outl;
unsigned char *in;
int inl;
d160 1
a160 4
void EVP_EncryptFinal(ctx,out,outl)
EVP_CIPHER_CTX *ctx;
unsigned char *out;
int *outl;
d178 2
a179 6
void EVP_DecryptUpdate(ctx,out,outl,in,inl)
EVP_CIPHER_CTX *ctx;
unsigned char *out;
int *outl;
unsigned char *in;
int inl;
d223 1
a223 4
int EVP_DecryptFinal(ctx,out,outl)
EVP_CIPHER_CTX *ctx;
unsigned char *out;
int *outl;
d264 1
a264 2
void EVP_CIPHER_CTX_cleanup(c)
EVP_CIPHER_CTX *c;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d61 1
a61 4
#include <openssl/evp.h>
#include <openssl/err.h>
#include <openssl/engine.h>
#include "evp_locl.h"
d63 1
a63 1
#include <assert.h>
d65 2
a66 3
const char *EVP_version="EVP" OPENSSL_VERSION_PTEXT;

void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *ctx)
d72 19
a90 3

int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
	     const unsigned char *key, const unsigned char *iv, int enc)
d92 3
a94 3
	if (cipher)
		EVP_CIPHER_CTX_init(ctx);
	return EVP_CipherInit_ex(ctx,cipher,NULL,key,iv,enc);
d97 4
a100 2
int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl,
	     const unsigned char *key, const unsigned char *iv, int enc)
d102 1
a102 3
	if (enc == -1)
		enc = ctx->encrypt;
	else
d104 2
a105 3
		if (enc)
			enc = 1;
		ctx->encrypt = enc;
d107 2
a108 49
	/* Whether it's nice or not, "Inits" can be used on "Final"'d contexts
	 * so this context may already have an ENGINE! Try to avoid releasing
	 * the previous handle, re-querying for an ENGINE, and having a
	 * reinitialisation, when it may all be unecessary. */
	if (ctx->engine && ctx->cipher && (!cipher ||
			(cipher && (cipher->nid == ctx->cipher->nid))))
		goto skip_to_init;
	if (cipher)
		{
		/* Ensure a context left lying around from last time is cleared
		 * (the previous check attempted to avoid this if the same
		 * ENGINE and EVP_CIPHER could be used). */
		EVP_CIPHER_CTX_cleanup(ctx);

		/* Restore encrypt field: it is zeroed by cleanup */
		ctx->encrypt = enc;
		if(impl)
			{
			if (!ENGINE_init(impl))
				{
				EVPerr(EVP_F_EVP_CIPHERINIT, EVP_R_INITIALIZATION_ERROR);
				return 0;
				}
			}
		else
			/* Ask if an ENGINE is reserved for this job */
			impl = ENGINE_get_cipher_engine(cipher->nid);
		if(impl)
			{
			/* There's an ENGINE for this job ... (apparently) */
			const EVP_CIPHER *c = ENGINE_get_cipher(impl, cipher->nid);
			if(!c)
				{
				/* One positive side-effect of US's export
				 * control history, is that we should at least
				 * be able to avoid using US mispellings of
				 * "initialisation"? */
				EVPerr(EVP_F_EVP_CIPHERINIT, EVP_R_INITIALIZATION_ERROR);
				return 0;
				}
			/* We'll use the ENGINE's private cipher definition */
			cipher = c;
			/* Store the ENGINE functional reference so we know
			 * 'cipher' came from an ENGINE and we need to release
			 * it when done. */
			ctx->engine = impl;
			}
		else
			ctx->engine = NULL;
d110 7
d118 2
a119 50
		ctx->cipher_data=OPENSSL_malloc(ctx->cipher->ctx_size);
		ctx->key_len = cipher->key_len;
		ctx->flags = 0;
		if(ctx->cipher->flags & EVP_CIPH_CTRL_INIT)
			{
			if(!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_INIT, 0, NULL))
				{
				EVPerr(EVP_F_EVP_CIPHERINIT, EVP_R_INITIALIZATION_ERROR);
				return 0;
				}
			}
		}
	else if(!ctx->cipher)
		{
		EVPerr(EVP_F_EVP_CIPHERINIT, EVP_R_NO_CIPHER_SET);
		return 0;
		}
skip_to_init:
	/* we assume block size is a power of 2 in *cryptUpdate */
	assert(ctx->cipher->block_size == 1
	       || ctx->cipher->block_size == 8
	       || ctx->cipher->block_size == 16);

	if(!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_CUSTOM_IV)) {
		switch(EVP_CIPHER_CTX_mode(ctx)) {

			case EVP_CIPH_STREAM_CIPHER:
			case EVP_CIPH_ECB_MODE:
			break;

			case EVP_CIPH_CFB_MODE:
			case EVP_CIPH_OFB_MODE:

			ctx->num = 0;

			case EVP_CIPH_CBC_MODE:

			if(iv) memcpy(ctx->oiv, iv, EVP_CIPHER_CTX_iv_length(ctx));
			memcpy(ctx->iv, ctx->oiv, EVP_CIPHER_CTX_iv_length(ctx));
			break;

			default:
			return 0;
			break;
		}
	}

	if(key || (ctx->cipher->flags & EVP_CIPH_ALWAYS_CALL_INIT)) {
		if(!ctx->cipher->init(ctx,key,iv,enc)) return 0;
	}
a120 3
	ctx->final_used=0;
	ctx->block_mask=ctx->cipher->block_size-1;
	return 1;
d123 5
a127 2
int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
	     const unsigned char *in, int inl)
d129 5
a133 23
	if (ctx->encrypt)
		return EVP_EncryptUpdate(ctx,out,outl,in,inl);
	else	return EVP_DecryptUpdate(ctx,out,outl,in,inl);
	}

int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
	{
	if (ctx->encrypt)
		return EVP_EncryptFinal_ex(ctx,out,outl);
	else	return EVP_DecryptFinal_ex(ctx,out,outl);
	}

int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
	{
	if (ctx->encrypt)
		return EVP_EncryptFinal(ctx,out,outl);
	else	return EVP_DecryptFinal(ctx,out,outl);
	}

int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
	     const unsigned char *key, const unsigned char *iv)
	{
	return EVP_CipherInit(ctx, cipher, key, iv, 1);
a135 5
int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher, ENGINE *impl,
		const unsigned char *key, const unsigned char *iv)
	{
	return EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 1);
	}
d137 6
a142 14
int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
	     const unsigned char *key, const unsigned char *iv)
	{
	return EVP_CipherInit_ex(ctx, cipher, NULL, key, iv, 0);
	}

int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl,
	     const unsigned char *key, const unsigned char *iv)
	{
	return EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 0);
	}

int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
	     const unsigned char *in, int inl)
a145 13
	if(ctx->buf_len == 0 && (inl&(ctx->block_mask)) == 0)
		{
		if(ctx->cipher->do_cipher(ctx,out,in,inl))
			{
			*outl=inl;
			return 1;
			}
		else
			{
			*outl=0;
			return 0;
			}
		}
d148 2
d156 1
a156 2
			*outl=0;
			return 1;
d161 2
a162 2
			memcpy(&(ctx->buf[i]),in,j);
			if(!ctx->cipher->do_cipher(ctx,out,ctx->buf,bl)) return 0;
d166 1
a166 1
			*outl=bl;
d169 1
a169 3
	else
		*outl = 0;
	i=inl&(bl-1);
d173 1
a173 1
		if(!ctx->cipher->do_cipher(ctx,out,in,inl)) return 0;
a179 1
	return 1;
d182 4
a185 1
int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
d187 1
a187 8
	int ret;
	ret = EVP_EncryptFinal_ex(ctx, out, outl);
	return ret;
	}

int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
	{
	int i,n,b,bl,ret;
d193 1
a193 1
		return 1;
a195 11
	if (ctx->flags & EVP_CIPH_NO_PADDING)
		{
		if(bl)
			{
			EVPerr(EVP_F_EVP_ENCRYPTFINAL,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
			return 0;
			}
		*outl = 0;
		return 1;
		}

d199 2
a200 7
	ret=ctx->cipher->do_cipher(ctx,out,ctx->buf,b);


	if(ret)
		*outl=b;

	return ret;
d203 6
a208 2
int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
	     const unsigned char *in, int inl)
d210 2
a211 1
	int b, fix_len;
d213 2
a214 8
	if (inl == 0)
		{
		*outl=0;
		return 1;
		}

	if (ctx->flags & EVP_CIPH_NO_PADDING)
		return EVP_EncryptUpdate(ctx, out, outl, in, inl);
d217 1
a217 2

	if(ctx->final_used)
d219 15
a233 3
		memcpy(out,ctx->final,b);
		out+=b;
		fix_len = 1;
d235 1
a235 6
	else
		fix_len = 0;


	if(!EVP_EncryptUpdate(ctx,out,outl,in,inl))
		return 0;
d239 1
a239 1
	if (b > 1 && !ctx->buf_len)
d241 8
a248 3
		*outl-=b;
		ctx->final_used=1;
		memcpy(ctx->final,&out[*outl],b);
a249 7
	else
		ctx->final_used = 0;

	if (fix_len)
		*outl += b;
		
	return 1;
d252 4
a255 8
int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
	{
	int ret;
	ret = EVP_DecryptFinal_ex(ctx, out, outl);
	return ret;
	}

int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
a261 10
	if (ctx->flags & EVP_CIPH_NO_PADDING)
		{
		if(ctx->buf_len)
			{
			EVPerr(EVP_F_EVP_DECRYPTFINAL,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
			return 0;
			}
		*outl = 0;
		return 1;
		}
d264 1
a264 1
		if (ctx->buf_len || !ctx->final_used)
d269 4
a272 1
		n=ctx->final[b-1];
d280 1
a280 1
			if (ctx->final[--b] != n)
d288 1
a288 1
			out[i]=ctx->final[i];
d296 2
a297 1
int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *c)
d299 2
a300 14
	if (c->cipher != NULL)
		{
		if(c->cipher->cleanup && !c->cipher->cleanup(c))
			return 0;
		/* Zero cipher context data */
		if (c->cipher_data)
			memset(c->cipher_data, 0, c->cipher->ctx_size);
		}
	if (c->cipher_data)
		OPENSSL_free(c->cipher_data);
	if (c->engine)
		/* The EVP_CIPHER we used belongs to an ENGINE, release the
		 * functional reference we held for this reason. */
		ENGINE_finish(c->engine);
a301 30
	return 1;
	}

int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *c, int keylen)
	{
	if(c->cipher->flags & EVP_CIPH_CUSTOM_KEY_LENGTH) 
		return EVP_CIPHER_CTX_ctrl(c, EVP_CTRL_SET_KEY_LENGTH, keylen, NULL);
	if(c->key_len == keylen) return 1;
	if((keylen > 0) && (c->cipher->flags & EVP_CIPH_VARIABLE_LENGTH))
		{
		c->key_len = keylen;
		return 1;
		}
	EVPerr(EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH,EVP_R_INVALID_KEY_LENGTH);
	return 0;
	}

int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *ctx, int pad)
	{
	if (pad) ctx->flags &= ~EVP_CIPH_NO_PADDING;
	else ctx->flags |= EVP_CIPH_NO_PADDING;
	return 1;
	}

int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
{
	int ret;
	if(!ctx->cipher) {
		EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_NO_CIPHER_SET);
		return 0;
a303 12
	if(!ctx->cipher->ctrl) {
		EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_CTRL_NOT_IMPLEMENTED);
		return 0;
	}

	ret = ctx->cipher->ctrl(ctx, type, arg, ptr);
	if(ret == -1) {
		EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED);
		return 0;
	}
	return ret;
}
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@a62 1
#ifndef OPENSSL_NO_ENGINE
a63 1
#endif
d66 2
a95 1
#ifndef OPENSSL_NO_ENGINE
a102 1
#endif
a111 1
#ifndef OPENSSL_NO_ENGINE
a144 1
#endif
a163 1
#ifndef OPENSSL_NO_ENGINE
a164 1
#endif
d166 3
a168 3
	OPENSSL_assert(ctx->cipher->block_size == 1
	    || ctx->cipher->block_size == 8
	    || ctx->cipher->block_size == 16);
a183 1
			OPENSSL_assert(EVP_CIPHER_CTX_iv_length(ctx) <= sizeof ctx->iv);
d240 1
a240 1
	return EVP_CipherInit(ctx, cipher, key, iv, 0);
a253 1
	OPENSSL_assert(inl > 0);
a268 1
	OPENSSL_assert(bl <= sizeof ctx->buf);
a316 1
	OPENSSL_assert(b <= sizeof ctx->buf);
a360 1
	OPENSSL_assert(b <= sizeof ctx->final);
a422 1
		OPENSSL_assert(b <= sizeof ctx->final);
d453 1
a453 1
		/* Cleanse cipher context data */
d455 1
a455 1
			OPENSSL_cleanse(c->cipher_data, c->cipher->ctx_size);
a458 1
#ifndef OPENSSL_NO_ENGINE
a462 1
#endif
@


1.1.1.4
log
@import openssl-0.9.7d
@
text
@d151 1
a151 13
		if (ctx->cipher->ctx_size)
			{
			ctx->cipher_data=OPENSSL_malloc(ctx->cipher->ctx_size);
			if (!ctx->cipher_data)
				{
				EVPerr(EVP_F_EVP_CIPHERINIT, ERR_R_MALLOC_FAILURE);
				return 0;
				}
			}
		else
			{
			ctx->cipher_data = NULL;
			}
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a84 42
#ifdef OPENSSL_FIPS

/* The purpose of these is to trap programs that attempt to use non FIPS
 * algorithms in FIPS mode and ignore the errors.
 */

int bad_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
	    const unsigned char *iv, int enc)
	{ FIPS_ERROR_IGNORED("Cipher init"); return 0;}

int bad_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
		 const unsigned char *in, unsigned int inl)
	{ FIPS_ERROR_IGNORED("Cipher update"); return 0;}

/* NB: no cleanup because it is allowed after failed init */

int bad_set_asn1(EVP_CIPHER_CTX *ctx, ASN1_TYPE *typ)
	{ FIPS_ERROR_IGNORED("Cipher set_asn1"); return 0;}
int bad_get_asn1(EVP_CIPHER_CTX *ctx, ASN1_TYPE *typ)
	{ FIPS_ERROR_IGNORED("Cipher get_asn1"); return 0;}
int bad_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
	{ FIPS_ERROR_IGNORED("Cipher ctrl"); return 0;}

static const EVP_CIPHER bad_cipher =
	{
	0,
	0,
	0,
	0,
	0,
	bad_init,
	bad_do_cipher,
	NULL,
	0,
	bad_set_asn1,
	bad_get_asn1,
	bad_ctrl,
	NULL
	};

#endif

d149 1
a211 18

#ifdef OPENSSL_FIPS
	/* After 'key' is set no further parameters changes are permissible.
	 * So only check for non FIPS enabling at this point.
	 */
	if (key && FIPS_mode())
		{
		if (!(ctx->cipher->flags & EVP_CIPH_FLAG_FIPS)
			& !(ctx->flags & EVP_CIPH_FLAG_NON_FIPS_ALLOW))
			{
			EVPerr(EVP_F_EVP_CIPHERINIT, EVP_R_DISABLED_FOR_FIPS);
			ERR_add_error_data(2, "cipher=",
						EVP_CIPHER_name(ctx->cipher));
			ctx->cipher = &bad_cipher;
			return 0;
			}
		}
#endif
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@a62 1
#include <openssl/rand.h>
d68 1
a68 1
const char EVP_version[]="EVP" OPENSSL_VERSION_PTEXT;
a75 7
EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void)
	{
	EVP_CIPHER_CTX *ctx=OPENSSL_malloc(sizeof *ctx);
	if (ctx)
		EVP_CIPHER_CTX_init(ctx);
	return ctx;
	}
d85 42
d161 1
a161 1
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
d178 1
a178 1
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
a190 1

d197 1
a197 1
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, ERR_R_MALLOC_FAILURE);
d211 1
a211 1
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
d218 1
a218 1
		EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_NO_CIPHER_SET);
d243 1
a243 2
			OPENSSL_assert(EVP_CIPHER_CTX_iv_length(ctx) <=
					(int)sizeof(ctx->iv));
d254 18
d348 1
a348 1
	OPENSSL_assert(bl <= (int)sizeof(ctx->buf));
d394 1
a394 2
	int n,ret;
	unsigned int i, b, bl;
d408 1
a408 1
			EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
d430 1
a430 2
	int fix_len;
	unsigned int b;
d483 2
a484 2
	int i,n;
	unsigned int b;
d492 1
a492 1
			EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
d502 1
a502 1
			EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_WRONG_FINAL_BLOCK_LENGTH);
d507 1
a507 1
		if (n == 0 || n > (int)b)
d509 1
a509 1
			EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT);
d516 1
a516 1
				EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT);
a529 9
void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx)
	{
	if (ctx)
		{
		EVP_CIPHER_CTX_cleanup(ctx);
		OPENSSL_free(ctx);
		}
	}

a592 10

int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key)
	{
	if (ctx->cipher->flags & EVP_CIPH_RAND_KEY)
		return EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_RAND_KEY, 0, key);
	if (RAND_bytes(key, ctx->key_len) <= 0)
		return 0;
	return 1;
	}

@


1.1.1.7
log
@import openssl-0.9.8j
@
text
@d69 1
a69 7
#ifdef OPENSSL_FIPS
	#define M_do_cipher(ctx, out, in, inl) \
		EVP_Cipher(ctx,out,in,inl)
#else
	#define M_do_cipher(ctx, out, in, inl) \
		ctx->cipher->do_cipher(ctx,out,in,inl)
#endif
d71 5
a75 1
const char EVP_version[]="EVP" OPENSSL_VERSION_PTEXT;
d93 138
d282 1
a282 6
	if (inl <= 0)
		{
		*outl = 0;
		return inl == 0;
		}

d285 1
a285 1
		if(M_do_cipher(ctx,out,in,inl))
d312 1
a312 1
			if(!M_do_cipher(ctx,out,ctx->buf,bl)) return 0;
d325 1
a325 1
		if(!M_do_cipher(ctx,out,in,inl)) return 0;
d369 1
a369 1
	ret=M_do_cipher(ctx,out,ctx->buf,b);
d384 1
a384 1
	if (inl <= 0)
d386 2
a387 2
		*outl = 0;
		return inl == 0;
d491 22
d534 21
a563 51
#ifndef OPENSSL_NO_ENGINE

#ifdef OPENSSL_FIPS

static int do_evp_enc_engine_full(EVP_CIPHER_CTX *ctx, const EVP_CIPHER **pcipher, ENGINE *impl)
	{
	if(impl)
		{
		if (!ENGINE_init(impl))
			{
			EVPerr(EVP_F_DO_EVP_ENC_ENGINE_FULL, EVP_R_INITIALIZATION_ERROR);
			return 0;
			}
		}
	else
		/* Ask if an ENGINE is reserved for this job */
		impl = ENGINE_get_cipher_engine((*pcipher)->nid);
	if(impl)
		{
		/* There's an ENGINE for this job ... (apparently) */
		const EVP_CIPHER *c = ENGINE_get_cipher(impl, (*pcipher)->nid);
		if(!c)
			{
			/* One positive side-effect of US's export
			 * control history, is that we should at least
			 * be able to avoid using US mispellings of
			 * "initialisation"? */
			EVPerr(EVP_F_DO_EVP_ENC_ENGINE_FULL, EVP_R_INITIALIZATION_ERROR);
			return 0;
			}
		/* We'll use the ENGINE's private cipher definition */
		*pcipher = c;
		/* Store the ENGINE functional reference so we know
		 * 'cipher' came from an ENGINE and we need to release
		 * it when done. */
		ctx->engine = impl;
		}
	else
		ctx->engine = NULL;
	return 1;
	}

void int_EVP_CIPHER_init_engine_callbacks(void)
	{
	int_EVP_CIPHER_set_engine_callbacks(
		ENGINE_finish, do_evp_enc_engine_full);
	}

#endif

#endif
@


1.1.1.8
log
@import OpenSSL-1.0.0a
@
text
@d69 8
a78 6
void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *ctx)
	{
	memset(ctx,0,sizeof(EVP_CIPHER_CTX));
	/* ctx->cipher=NULL; */
	}

a94 138
int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl,
	     const unsigned char *key, const unsigned char *iv, int enc)
	{
	if (enc == -1)
		enc = ctx->encrypt;
	else
		{
		if (enc)
			enc = 1;
		ctx->encrypt = enc;
		}
#ifndef OPENSSL_NO_ENGINE
	/* Whether it's nice or not, "Inits" can be used on "Final"'d contexts
	 * so this context may already have an ENGINE! Try to avoid releasing
	 * the previous handle, re-querying for an ENGINE, and having a
	 * reinitialisation, when it may all be unecessary. */
	if (ctx->engine && ctx->cipher && (!cipher ||
			(cipher && (cipher->nid == ctx->cipher->nid))))
		goto skip_to_init;
#endif
	if (cipher)
		{
		/* Ensure a context left lying around from last time is cleared
		 * (the previous check attempted to avoid this if the same
		 * ENGINE and EVP_CIPHER could be used). */
		EVP_CIPHER_CTX_cleanup(ctx);

		/* Restore encrypt field: it is zeroed by cleanup */
		ctx->encrypt = enc;
#ifndef OPENSSL_NO_ENGINE
		if(impl)
			{
			if (!ENGINE_init(impl))
				{
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
				return 0;
				}
			}
		else
			/* Ask if an ENGINE is reserved for this job */
			impl = ENGINE_get_cipher_engine(cipher->nid);
		if(impl)
			{
			/* There's an ENGINE for this job ... (apparently) */
			const EVP_CIPHER *c = ENGINE_get_cipher(impl, cipher->nid);
			if(!c)
				{
				/* One positive side-effect of US's export
				 * control history, is that we should at least
				 * be able to avoid using US mispellings of
				 * "initialisation"? */
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
				return 0;
				}
			/* We'll use the ENGINE's private cipher definition */
			cipher = c;
			/* Store the ENGINE functional reference so we know
			 * 'cipher' came from an ENGINE and we need to release
			 * it when done. */
			ctx->engine = impl;
			}
		else
			ctx->engine = NULL;
#endif

		ctx->cipher=cipher;
		if (ctx->cipher->ctx_size)
			{
			ctx->cipher_data=OPENSSL_malloc(ctx->cipher->ctx_size);
			if (!ctx->cipher_data)
				{
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, ERR_R_MALLOC_FAILURE);
				return 0;
				}
			}
		else
			{
			ctx->cipher_data = NULL;
			}
		ctx->key_len = cipher->key_len;
		ctx->flags = 0;
		if(ctx->cipher->flags & EVP_CIPH_CTRL_INIT)
			{
			if(!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_INIT, 0, NULL))
				{
				EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
				return 0;
				}
			}
		}
	else if(!ctx->cipher)
		{
		EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_NO_CIPHER_SET);
		return 0;
		}
#ifndef OPENSSL_NO_ENGINE
skip_to_init:
#endif
	/* we assume block size is a power of 2 in *cryptUpdate */
	OPENSSL_assert(ctx->cipher->block_size == 1
	    || ctx->cipher->block_size == 8
	    || ctx->cipher->block_size == 16);

	if(!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_CUSTOM_IV)) {
		switch(EVP_CIPHER_CTX_mode(ctx)) {

			case EVP_CIPH_STREAM_CIPHER:
			case EVP_CIPH_ECB_MODE:
			break;

			case EVP_CIPH_CFB_MODE:
			case EVP_CIPH_OFB_MODE:

			ctx->num = 0;

			case EVP_CIPH_CBC_MODE:

			OPENSSL_assert(EVP_CIPHER_CTX_iv_length(ctx) <=
					(int)sizeof(ctx->iv));
			if(iv) memcpy(ctx->oiv, iv, EVP_CIPHER_CTX_iv_length(ctx));
			memcpy(ctx->iv, ctx->oiv, EVP_CIPHER_CTX_iv_length(ctx));
			break;

			default:
			return 0;
			break;
		}
	}

	if(key || (ctx->cipher->flags & EVP_CIPH_ALWAYS_CALL_INIT)) {
		if(!ctx->cipher->init(ctx,key,iv,enc)) return 0;
	}
	ctx->buf_len=0;
	ctx->final_used=0;
	ctx->block_mask=ctx->cipher->block_size-1;
	return 1;
	}

d154 1
a154 1
		if(ctx->cipher->do_cipher(ctx,out,in,inl))
d181 1
a181 1
			if(!ctx->cipher->do_cipher(ctx,out,ctx->buf,bl)) return 0;
d194 1
a194 1
		if(!ctx->cipher->do_cipher(ctx,out,in,inl)) return 0;
d238 1
a238 1
	ret=ctx->cipher->do_cipher(ctx,out,ctx->buf,b);
a359 22
int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *c)
	{
	if (c->cipher != NULL)
		{
		if(c->cipher->cleanup && !c->cipher->cleanup(c))
			return 0;
		/* Cleanse cipher context data */
		if (c->cipher_data)
			OPENSSL_cleanse(c->cipher_data, c->cipher->ctx_size);
		}
	if (c->cipher_data)
		OPENSSL_free(c->cipher_data);
#ifndef OPENSSL_NO_ENGINE
	if (c->engine)
		/* The EVP_CIPHER we used belongs to an ENGINE, release the
		 * functional reference we held for this reason. */
		ENGINE_finish(c->engine);
#endif
	memset(c,0,sizeof(EVP_CIPHER_CTX));
	return 1;
	}

a380 21
int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
{
	int ret;
	if(!ctx->cipher) {
		EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_NO_CIPHER_SET);
		return 0;
	}

	if(!ctx->cipher->ctrl) {
		EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_CTRL_NOT_IMPLEMENTED);
		return 0;
	}

	ret = ctx->cipher->ctrl(ctx, type, arg, ptr);
	if(ret == -1) {
		EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED);
		return 0;
	}
	return ret;
}

a389 7
int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in)
	{
	if ((in == NULL) || (in->cipher == NULL))
		{
		EVPerr(EVP_F_EVP_CIPHER_CTX_COPY,EVP_R_INPUT_NOT_INITIALIZED);
		return 0;
		}
a390 7
	/* Make sure it's safe to copy a cipher context using an ENGINE */
	if (in->engine && !ENGINE_init(in->engine))
		{
		EVPerr(EVP_F_EVP_CIPHER_CTX_COPY,ERR_R_ENGINE_LIB);
		return 0;
		}
#endif
d392 1
a392 2
	EVP_CIPHER_CTX_cleanup(out);
	memcpy(out,in,sizeof *out);
d394 3
a396 1
	if (in->cipher_data && in->cipher->ctx_size)
d398 1
a398 2
		out->cipher_data=OPENSSL_malloc(in->cipher->ctx_size);
		if (!out->cipher_data)
d400 1
a400 1
			EVPerr(EVP_F_EVP_CIPHER_CTX_COPY,ERR_R_MALLOC_FAILURE);
a402 1
		memcpy(out->cipher_data,in->cipher_data,in->cipher->ctx_size);
d404 27
d432 4
a435 3
	if (in->cipher->flags & EVP_CIPH_CUSTOM_COPY)
		return in->cipher->ctrl((EVP_CIPHER_CTX *)in, EVP_CTRL_COPY, 0, out);
	return 1;
d438 3
@


1.1.1.9
log
@import OpenSSL 1.0.0e
@
text
@a206 1
			/* fall-through */
@


1.1.1.10
log
@import OpenSSL-1.0.1c
@
text
@a66 3
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif
a68 7
#ifdef OPENSSL_FIPS
#define M_do_cipher(ctx, out, in, inl) FIPS_cipher(ctx, out, in, inl)
#else
#define M_do_cipher(ctx, out, in, inl) ctx->cipher->do_cipher(ctx, out, in, inl)
#endif


d118 4
a121 8
		if (ctx->cipher)
			{
			unsigned long flags = ctx->flags;
			EVP_CIPHER_CTX_cleanup(ctx);
			/* Restore encrypt and flags */
			ctx->encrypt = enc;
			ctx->flags = flags;
			}
a157 4
#ifdef OPENSSL_FIPS
		if (FIPS_mode())
			return FIPS_cipherinit(ctx, cipher, key, iv, enc);
#endif
a190 4
#ifdef OPENSSL_FIPS
	if (FIPS_mode())
		return FIPS_cipherinit(ctx, cipher, key, iv, enc);
#endif
a216 7
			case EVP_CIPH_CTR_MODE:
			ctx->num = 0;
			/* Don't reuse IV for CTR mode */
			if(iv)
				memcpy(ctx->iv, iv, EVP_CIPHER_CTX_iv_length(ctx));
			break;

a282 10
	if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER)
		{
		i = M_do_cipher(ctx, out, in, inl);
		if (i < 0)
			return 0;
		else
			*outl = i;
		return 1;
		}

d291 1
a291 1
		if(M_do_cipher(ctx,out,in,inl))
d318 1
a318 1
			if(!M_do_cipher(ctx,out,ctx->buf,bl)) return 0;
d331 1
a331 1
		if(!M_do_cipher(ctx,out,in,inl)) return 0;
a352 10
	if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER)
		{
		ret = M_do_cipher(ctx, out, NULL, 0);
		if (ret < 0)
			return 0;
		else 
			*outl = ret;
		return 1;
		}

d375 1
a375 1
	ret=M_do_cipher(ctx,out,ctx->buf,b);
a389 13
	if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER)
		{
		fix_len = M_do_cipher(ctx, out, in, inl);
		if (fix_len < 0)
			{
			*outl = 0;
			return 0;
			}
		else
			*outl = fix_len;
		return 1;
		}

d443 1
a444 11

	if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER)
		{
		i = M_do_cipher(ctx, out, NULL, 0);
		if (i < 0)
			return 0;
		else
			*outl = i;
		return 1;
		}

a498 1
#ifndef OPENSSL_FIPS
a508 1
#endif
a513 3
#endif
#ifdef OPENSSL_FIPS
	FIPS_cipher_ctx_cleanup(c);
@


