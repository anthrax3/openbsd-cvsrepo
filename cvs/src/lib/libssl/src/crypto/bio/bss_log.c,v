head	1.21;
access;
symbols
	OPENBSD_6_0:1.21.0.10
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.8
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.6
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	butholakala:1.10
	openssl_1_0_1_g:1.1.1.6
	OPENBSD_5_5:1.9.0.12
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.8
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.6
	OPENBSD_5_3_BASE:1.9
	openssl_1_0_1_c:1.1.1.5
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	openssl_1_0_0_f:1.1.1.5
	openssl_1_0_0_e:1.1.1.5
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	openssh_1_0_0_a:1.1.1.4
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	openssl_0_9_8_k:1.1.1.3
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	openssl_0_9_8_j:1.1.1.3
	openssl_0_9_8_h:1.1.1.3
	pre_openssl_0_9_8h:1.6
	OPENBSD_4_4:1.6.0.22
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.20
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.18
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENSSL_0_9_7G:1.1.1.2
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.20;
commitid	yQEL1wOWIearrW15;

1.20
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.19;
commitid	id8dTrTMtnTn4fqt;

1.19
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	mJUVYpkFBZ0Zv2bG;

1.18
date	2014.04.27.20.26.48;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.21.11.12.49;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.17.17.50.45;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.16.20.36.35;	author beck;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.16.19.42.24;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.15.16.37.22;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.13.19.50.56;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.49;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.12.02.18.36;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.18;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.15.06.18.33;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.09.09;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.35.41;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.56;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.34.40;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.04;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2011.11.03.02.32.08;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.04.13.15.16.33;	author miod;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@/* $OpenBSD: bss_log.c,v 1.20 2014/07/10 13:58:22 jsing Exp $ */
/* ====================================================================
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

/*
	Why BIO_s_log?

	BIO_s_log is useful for system daemons (or services under NT).
	It is one-way BIO, it sends all stuff to syslogd (on system that
	commonly use that), or event log (on NT), or OPCOM (on OpenVMS).

*/

#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>

#include <openssl/buffer.h>
#include <openssl/err.h>

#ifndef NO_SYSLOG

static int slg_write(BIO *h, const char *buf, int num);
static int slg_puts(BIO *h, const char *str);
static long slg_ctrl(BIO *h, int cmd, long arg1, void *arg2);
static int slg_new(BIO *h);
static int slg_free(BIO *data);
static void xopenlog(BIO* bp, char* name, int level);
static void xsyslog(BIO* bp, int priority, const char* string);
static void xcloselog(BIO* bp);

static BIO_METHOD methods_slg = {
	.type = BIO_TYPE_MEM,
	.name = "syslog",
	.bwrite = slg_write,
	.bputs = slg_puts,
	.ctrl = slg_ctrl,
	.create = slg_new,
	.destroy = slg_free
};

BIO_METHOD *
BIO_s_log(void)
{
	return (&methods_slg);
}

static int
slg_new(BIO *bi)
{
	bi->init = 1;
	bi->num = 0;
	bi->ptr = NULL;
	xopenlog(bi, "application", LOG_DAEMON);
	return (1);
}

static int
slg_free(BIO *a)
{
	if (a == NULL)
		return (0);
	xcloselog(a);
	return (1);
}

static int
slg_write(BIO *b, const char *in, int inl)
{
	int ret = inl;
	char* buf;
	char* pp;
	int priority, i;
	static const struct {
		int strl;
		char str[10];
		int log_level;
	}
	mapping[] = {
		{ 6, "PANIC ", LOG_EMERG },
		{ 6, "EMERG ", LOG_EMERG },
		{ 4, "EMR ", LOG_EMERG },
		{ 6, "ALERT ", LOG_ALERT },
		{ 4, "ALR ", LOG_ALERT },
		{ 5, "CRIT ", LOG_CRIT },
		{ 4, "CRI ", LOG_CRIT },
		{ 6, "ERROR ", LOG_ERR },
		{ 4, "ERR ", LOG_ERR },
		{ 8, "WARNING ", LOG_WARNING },
		{ 5, "WARN ", LOG_WARNING },
		{ 4, "WAR ", LOG_WARNING },
		{ 7, "NOTICE ", LOG_NOTICE },
		{ 5, "NOTE ", LOG_NOTICE },
		{ 4, "NOT ", LOG_NOTICE },
		{ 5, "INFO ", LOG_INFO },
		{ 4, "INF ", LOG_INFO },
		{ 6, "DEBUG ", LOG_DEBUG },
		{ 4, "DBG ", LOG_DEBUG },
		{ 0, "", LOG_ERR } /* The default */
	};

	if ((buf = malloc(inl + 1)) == NULL) {
		return (0);
	}
	strlcpy(buf, in, inl + 1);
	i = 0;
	while (strncmp(buf, mapping[i].str, mapping[i].strl) != 0)
		i++;
	priority = mapping[i].log_level;
	pp = buf + mapping[i].strl;

	xsyslog(b, priority, pp);

	free(buf);
	return (ret);
}

static long
slg_ctrl(BIO *b, int cmd, long num, void *ptr)
{
	switch (cmd) {
	case BIO_CTRL_SET:
		xcloselog(b);
		xopenlog(b, ptr, num);
		break;
	default:
		break;
	}
	return (0);
}

static int
slg_puts(BIO *bp, const char *str)
{
	int n, ret;

	n = strlen(str);
	ret = slg_write(bp, str, n);
	return (ret);
}


static void
xopenlog(BIO* bp, char* name, int level)
{
	openlog(name, LOG_PID|LOG_CONS, level);
}

static void
xsyslog(BIO *bp, int priority, const char *string)
{
	syslog(priority, "%s", string);
}

static void
xcloselog(BIO* bp)
{
	closelog();
}

#endif /* NO_SYSLOG */
@


1.20
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bss_log.c,v 1.19 2014/06/12 15:49:28 deraadt Exp $ */
a68 2

#include "cryptlib.h"
@


1.19
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d65 1
a65 1

d67 2
a68 1
#include <errno.h>
a71 2
#include <syslog.h>

a76 1

a213 1

@


1.18
log
@Use C99 initializers for the various FOO_METHOD structs. More readable, and
avoid unreadable/unmaintainable constructs like that:

const EVP_PKEY_ASN1_METHOD cmac_asn1_meth =
        {
        EVP_PKEY_CMAC,
        EVP_PKEY_CMAC,
        0,

        "CMAC",
        "OpenSSL CMAC method",

        0,0,0,0,

        0,0,0,

        cmac_size,
        0,
        0,0,0,0,0,0,0,

        cmac_key_free,
        0,
        0,0
        };

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/* crypto/bio/bss_log.c */
@


1.17
log
@Bring malloc/calloc/realloc sequences to modern standard
ok guenther
@
text
@d89 7
a95 9
	BIO_TYPE_MEM, "syslog",
	slg_write,
	NULL,
	slg_puts,
	NULL,
	slg_ctrl,
	slg_new,
	slg_free,
	NULL,
@


1.16
log
@some KNF cleanup following the script
@
text
@d160 1
a160 1
	if ((buf = (char *)malloc(inl + 1)) == NULL) {
@


1.15
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d100 2
a101 2
BIO_METHOD
*BIO_s_log(void)
@


1.14
log
@Clean up dangerous strncpy use. This included a use where the resulting
string was potentially not nul terminated and a place where malloc return
was unchecked.
while we're at it remove dummytest.c
ok miod@@
@
text
@d160 1
a160 1
	if ((buf = (char *)OPENSSL_malloc(inl + 1)) == NULL) {
d172 1
a172 1
	OPENSSL_free(buf);
@


1.13
log
@> As I walk through the valley of the shadow of death
> I take a look at my life and realize there's nothin' left
> Cause I've been blasting and laughing so long,
> That even my mama thinks that my mind is gone
Remove even more unspeakable evil being perpetuated in the name of VMS.
(and lesser evils done in the name of others.)
ok miod
@
text
@d163 1
a163 3
	strncpy(buf, in, inl);
	buf[inl] = '\0';

@


1.12
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@d71 1
a71 23
#if defined(OPENSSL_SYS_WINCE)
#elif defined(OPENSSL_SYS_WIN32)
#elif defined(OPENSSL_SYS_VMS)
#  include <opcdef.h>
#  include <descrip.h>
#  include <lib$routines.h>
#  include <starlet.h>
/* Some compiler options may mask the declaration of "_malloc32". */
#  if __INITIAL_POINTER_SIZE && defined _ANSI_C_SOURCE
#    if __INITIAL_POINTER_SIZE == 64
#      pragma pointer_size save
#      pragma pointer_size 32
void * _malloc32  (__size_t);
#      pragma pointer_size restore
#    endif /* __INITIAL_POINTER_SIZE == 64 */
#  endif /* __INITIAL_POINTER_SIZE && defined _ANSI_C_SOURCE */
#elif defined(__ultrix)
#  include <sys/syslog.h>
#elif defined(OPENSSL_SYS_NETWARE)
#  define NO_SYSLOG
#elif (!defined(MSDOS) || defined(WATT32)) && !defined(OPENSSL_SYS_VXWORKS) && !defined(NO_SYSLOG)
#  include <syslog.h>
#endif
a77 24
#if defined(OPENSSL_SYS_WIN32)
#define LOG_EMERG	0
#define LOG_ALERT	1
#define LOG_CRIT	2
#define LOG_ERR		3
#define LOG_WARNING	4
#define LOG_NOTICE	5
#define LOG_INFO	6
#define LOG_DEBUG	7

#define LOG_DAEMON	(3<<3)
#elif defined(OPENSSL_SYS_VMS)
/* On VMS, we don't really care about these, but we need them to compile */
#define LOG_EMERG	0
#define LOG_ALERT	1
#define LOG_CRIT	2
#define LOG_ERR		3
#define LOG_WARNING	4
#define LOG_NOTICE	5
#define LOG_INFO	6
#define LOG_DEBUG	7

#define LOG_DAEMON	OPC$M_NM_NTWORK
#endif
a201 146
#if defined(OPENSSL_SYS_WIN32)

static void
xopenlog(BIO* bp, char* name, int level)
{
	if (check_winnt())
		bp->ptr = RegisterEventSourceA(NULL, name);
	else
		bp->ptr = NULL;
}

static void
xsyslog(BIO *bp, int priority, const char *string)
{
	LPCSTR lpszStrings[2];
	WORD evtype = EVENTLOG_ERROR_TYPE;
	char pidbuf[DECIMAL_SIZE(DWORD) + 4];

	if (bp->ptr == NULL)
		return;

	switch (priority) {
	case LOG_EMERG:
	case LOG_ALERT:
	case LOG_CRIT:
	case LOG_ERR:
		evtype = EVENTLOG_ERROR_TYPE;
		break;
	case LOG_WARNING:
		evtype = EVENTLOG_WARNING_TYPE;
		break;
	case LOG_NOTICE:
	case LOG_INFO:
	case LOG_DEBUG:
		evtype = EVENTLOG_INFORMATION_TYPE;
		break;
	default:		/* Should never happen, but set it
				   as error anyway. */
		evtype = EVENTLOG_ERROR_TYPE;
		break;
	}

	sprintf(pidbuf, "[%u] ", GetCurrentProcessId());
	lpszStrings[0] = pidbuf;
	lpszStrings[1] = string;

	ReportEventA(bp->ptr, evtype, 0, 1024, NULL, 2, 0,
	lpszStrings, NULL);
}

static void
xcloselog(BIO* bp)
{
	if (bp->ptr)
		DeregisterEventSource((HANDLE)(bp->ptr));
	bp->ptr = NULL;
}

#elif defined(OPENSSL_SYS_VMS)

static int VMS_OPC_target = LOG_DAEMON;

static void
xopenlog(BIO* bp, char* name, int level)
{
	VMS_OPC_target = level;

}

static void
xsyslog(BIO *bp, int priority, const char *string)
{
	struct dsc$descriptor_s opc_dsc;

/* Arrange 32-bit pointer to opcdef buffer and malloc(), if needed. */
#if __INITIAL_POINTER_SIZE == 64
# pragma pointer_size save
# pragma pointer_size 32
# define OPCDEF_TYPE __char_ptr32
# define OPCDEF_MALLOC _malloc32
#else /* __INITIAL_POINTER_SIZE == 64 */
# define OPCDEF_TYPE char *
# define OPCDEF_MALLOC OPENSSL_malloc
#endif /* __INITIAL_POINTER_SIZE == 64 [else] */

	struct opcdef *opcdef_p;

#if __INITIAL_POINTER_SIZE == 64
# pragma pointer_size restore
#endif /* __INITIAL_POINTER_SIZE == 64 */

	char buf[10240];
	unsigned int len;
	struct dsc$descriptor_s buf_dsc;
	$DESCRIPTOR(fao_cmd, "!AZ: !AZ");
	char *priority_tag;

	switch (priority) {
	case LOG_EMERG:
		priority_tag = "Emergency"; break;
	case LOG_ALERT:
		priority_tag = "Alert"; break;
	case LOG_CRIT:
		priority_tag = "Critical"; break;
	case LOG_ERR:
		priority_tag = "Error"; break;
	case LOG_WARNING:
		priority_tag = "Warning"; break;
	case LOG_NOTICE:
		priority_tag = "Notice"; break;
	case LOG_INFO:
		priority_tag = "Info"; break;
	case LOG_DEBUG:
		priority_tag = "DEBUG"; break;
	}

	buf_dsc.dsc$b_dtype = DSC$K_DTYPE_T;
	buf_dsc.dsc$b_class = DSC$K_CLASS_S;
	buf_dsc.dsc$a_pointer = buf;
	buf_dsc.dsc$w_length = sizeof(buf) - 1;

	lib$sys_fao(&fao_cmd, &len, &buf_dsc, priority_tag, string);

	/* We know there's an 8-byte header.  That's documented. */
	opcdef_p = OPCDEF_MALLOC( 8 + len);
	opcdef_p->opc$b_ms_type = OPC$_RQ_RQST;
	memcpy(opcdef_p->opc$z_ms_target_classes, &VMS_OPC_target, 3);
	opcdef_p->opc$l_ms_rqstid = 0;
	memcpy(&opcdef_p->opc$l_ms_text, buf, len);

	opc_dsc.dsc$b_dtype = DSC$K_DTYPE_T;
	opc_dsc.dsc$b_class = DSC$K_CLASS_S;
	opc_dsc.dsc$a_pointer = (OPCDEF_TYPE) opcdef_p;
	opc_dsc.dsc$w_length = len + 8;

	sys$sndopr(opc_dsc, 0);

	OPENSSL_free(opcdef_p);
}

static void
xcloselog(BIO* bp)
{
}

#else /* Unix/Watt32 */
a205 3
#ifdef WATT32   /* djgpp/DOS */
	openlog(name, LOG_PID|LOG_CONS|LOG_NDELAY, level);
#else
a206 1
#endif
a220 1
#endif /* Unix */
@


1.11
log
@Remove some stuff that isn't needed.
ok miod@@ deraadt@@
@
text
@d83 1
a83 1
    void * _malloc32  (__size_t);
d134 2
a135 3
static BIO_METHOD methods_slg=
	{
	BIO_TYPE_MEM,"syslog",
d144 1
a144 1
	};
d146 5
a150 4
BIO_METHOD *BIO_s_log(void)
	{
	return(&methods_slg);
	}
d152 6
a157 5
static int slg_new(BIO *bi)
	{
	bi->init=1;
	bi->num=0;
	bi->ptr=NULL;
d159 2
a160 2
	return(1);
	}
d162 5
a166 3
static int slg_free(BIO *a)
	{
	if (a == NULL) return(0);
d168 7
a174 6
	return(1);
	}
	
static int slg_write(BIO *b, const char *in, int inl)
	{
	int ret= inl;
d178 1
a178 2
	static const struct
		{
d182 2
a183 3
		}
	mapping[] =
		{
d204 1
a204 1
		};
d206 2
a207 2
	if((buf= (char *)OPENSSL_malloc(inl+ 1)) == NULL){
		return(0);
d210 1
a210 1
	buf[inl]= '\0';
d213 2
a214 1
	while(strncmp(buf, mapping[i].str, mapping[i].strl) != 0) i++;
d221 2
a222 2
	return(ret);
	}
d224 4
a227 4
static long slg_ctrl(BIO *b, int cmd, long num, void *ptr)
	{
	switch (cmd)
		{
a233 2
		}
	return(0);
d235 7
d243 4
a246 8
static int slg_puts(BIO *bp, const char *str)
	{
	int n,ret;

	n=strlen(str);
	ret=slg_write(bp,str,n);
	return(ret);
	}
d250 2
a251 1
static void xopenlog(BIO* bp, char* name, int level)
d254 1
a254 1
		bp->ptr = RegisterEventSourceA(NULL,name);
d259 2
a260 1
static void xsyslog(BIO *bp, int priority, const char *string)
d263 2
a264 2
	WORD evtype= EVENTLOG_ERROR_TYPE;
	char pidbuf[DECIMAL_SIZE(DWORD)+4];
d269 1
a269 2
	switch (priority)
		{
d288 1
a288 1
		}
d295 1
a295 1
				lpszStrings, NULL);
d297 3
a299 2
	
static void xcloselog(BIO* bp)
d301 1
a301 1
	if(bp->ptr)
d303 1
a303 1
	bp->ptr= NULL;
d310 2
a311 1
static void xopenlog(BIO* bp, char* name, int level)
d313 2
a314 1
	VMS_OPC_target = level; 
d317 2
a318 1
static void xsyslog(BIO *bp, int priority, const char *string)
d341 1
a341 1
        struct dsc$descriptor_s buf_dsc;
d345 18
a362 11
	switch (priority)
	  {
	  case LOG_EMERG: priority_tag = "Emergency"; break;
	  case LOG_ALERT: priority_tag = "Alert"; break;
	  case LOG_CRIT: priority_tag = "Critical"; break;
	  case LOG_ERR: priority_tag = "Error"; break;
	  case LOG_WARNING: priority_tag = "Warning"; break;
	  case LOG_NOTICE: priority_tag = "Notice"; break;
	  case LOG_INFO: priority_tag = "Info"; break;
	  case LOG_DEBUG: priority_tag = "DEBUG"; break;
	  }
d372 1
a372 1
	opcdef_p = OPCDEF_MALLOC( 8+ len);
d388 2
a389 1
static void xcloselog(BIO* bp)
d395 2
a396 1
static void xopenlog(BIO* bp, char* name, int level)
d405 2
a406 1
static void xsyslog(BIO *bp, int priority, const char *string)
d411 2
a412 1
static void xcloselog(BIO* bp)
@


1.10
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d125 5
a129 5
static int MS_CALLBACK slg_write(BIO *h, const char *buf, int num);
static int MS_CALLBACK slg_puts(BIO *h, const char *str);
static long MS_CALLBACK slg_ctrl(BIO *h, int cmd, long arg1, void *arg2);
static int MS_CALLBACK slg_new(BIO *h);
static int MS_CALLBACK slg_free(BIO *data);
d152 1
a152 1
static int MS_CALLBACK slg_new(BIO *bi)
d161 1
a161 1
static int MS_CALLBACK slg_free(BIO *a)
d168 1
a168 1
static int MS_CALLBACK slg_write(BIO *b, const char *in, int inl)
d221 1
a221 1
static long MS_CALLBACK slg_ctrl(BIO *b, int cmd, long num, void *ptr)
d235 1
a235 1
static int MS_CALLBACK slg_puts(BIO *bp, const char *str)
@


1.9
log
@openssl-1.0.0e: resolve conflicts
@
text
@d248 1
a248 1
	if (GetVersion() < 0x80000000)
@


1.8
log
@resolve conflicts, fix local changes
@
text
@d78 9
d312 12
d325 5
d355 2
a356 2
	/* we know there's an 8 byte header.  That's documented */
	opcdef_p = (struct opcdef *) OPENSSL_malloc(8 + len);
d364 1
a364 1
	opc_dsc.dsc$a_pointer = (char *)opcdef_p;
@


1.7
log
@resolve conflicts
@
text
@a72 1
#  include <process.h>
a123 12
#ifdef OPENSSL_SYS_WIN32
LONG	(WINAPI *go_for_advapi)()	= RegOpenKeyEx;
HANDLE	(WINAPI *register_event_source)()	= NULL;
BOOL	(WINAPI *deregister_event_source)()	= NULL;
BOOL	(WINAPI *report_event)()	= NULL;
#define DL_PROC(m,f)	(GetProcAddress( m, f ))
#ifdef UNICODE
#define DL_PROC_X(m,f) DL_PROC( m, f "W" )
#else
#define DL_PROC_X(m,f) DL_PROC( m, f "A" )
#endif
#endif
d165 1
a165 1
	static struct
d239 4
a242 21
	if ( !register_event_source )
		{
		HANDLE	advapi;
		if ( !(advapi = GetModuleHandle("advapi32")) )
			return;
		register_event_source = (HANDLE (WINAPI *)())DL_PROC_X(advapi,
			"RegisterEventSource" );
		deregister_event_source = (BOOL (WINAPI *)())DL_PROC(advapi,
			"DeregisterEventSource");
		report_event = (BOOL (WINAPI *)())DL_PROC_X(advapi,
			"ReportEvent" );
		if ( !(register_event_source && deregister_event_source &&
				report_event) )
			{
			register_event_source = NULL;
			deregister_event_source = NULL;
			report_event = NULL;
			return;
			}
		}
	bp->ptr= (char *)register_event_source(NULL, name);
d249 4
a252 2
	int pid = _getpid();
	char pidbuf[DECIMAL_SIZE(pid)+4];
d276 1
a276 1
	sprintf(pidbuf, "[%d] ", pid);
d280 1
a280 2
	if(report_event && bp->ptr)
		report_event(bp->ptr, evtype, 0, 1024, NULL, 2, 0,
d286 2
a287 2
	if(deregister_event_source && bp->ptr)
		deregister_event_source((HANDLE)(bp->ptr));
@


1.6
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d81 2
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d71 2
a72 1
#if defined(OPENSSL_SYS_WIN32)
d81 1
a81 1
#elif !defined(MSDOS) && !defined(OPENSSL_SYS_VXWORKS) && !defined(NO_SYSLOG) /* Unix */
d278 1
a278 1
	char pidbuf[20];
d377 1
a377 1
#else /* Unix */
d381 3
d385 1
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d69 3
a71 1
#if defined(WIN32)
d73 1
a73 1
#elif defined(VMS) || defined(__VMS)
d80 1
a80 1
#elif !defined(MSDOS) /* Unix */
a83 1
#include "cryptlib.h"
d89 1
a89 1
#if defined(WIN32)
d100 1
a100 1
#elif defined(VMS)
d122 1
a122 1
#ifdef WIN32
d245 1
a245 1
#if defined(WIN32)
d317 1
a317 1
#elif defined(VMS)
@


1.3
log
@OpenSSL 0.9.5a merge
@
text
@d113 3
a115 3
static int MS_CALLBACK slg_write(BIO *h,char *buf,int num);
static int MS_CALLBACK slg_puts(BIO *h,char *str);
static long MS_CALLBACK slg_ctrl(BIO *h,int cmd,long arg1,char *arg2);
d118 1
a118 1
static void xopenlog(BIO* bp, const char* name, int level);
d121 12
d168 1
a168 1
static int MS_CALLBACK slg_write(BIO *b, char *in, int inl)
d171 1
a171 1
	char* buf= in;
d173 30
a202 1
	int priority;
d204 1
a204 1
	if((buf= (char *)Malloc(inl+ 1)) == NULL){
d210 4
a213 13
	if(strncmp(buf, "ERR ", 4) == 0){
		priority= LOG_ERR;
		pp= buf+ 4;
	}else if(strncmp(buf, "WAR ", 4) == 0){
		priority= LOG_WARNING;
		pp= buf+ 4;
	}else if(strncmp(buf, "INF ", 4) == 0){
		priority= LOG_INFO;
		pp= buf+ 4;
	}else{
		priority= LOG_ERR;
		pp= buf;
	}
d217 1
a217 1
	Free(buf);
d221 1
a221 1
static long MS_CALLBACK slg_ctrl(BIO *b, int cmd, long num, char *ptr)
d235 1
a235 1
static int MS_CALLBACK slg_puts(BIO *bp, char *str)
d246 1
a246 1
static void xopenlog(BIO* bp, const char* name, int level)
d248 21
a268 1
	bp->ptr= (char *)RegisterEventSource(NULL, name);
d280 3
d289 1
d291 1
d294 2
a295 1
	default:
d304 2
a305 2
	if(bp->ptr)
		ReportEvent(bp->ptr, evtype, 0, 1024, NULL, 2, 0,
d311 2
a312 2
	if(bp->ptr)
		DeregisterEventSource((HANDLE)(bp->ptr));
d320 1
a320 1
static void xopenlog(BIO* bp, const char* name, int level)
d355 1
a355 1
	opcdef_p = (struct opcdef *) Malloc(8 + len);
d368 1
a368 1
	Free(opcdef_p);
d377 1
a377 1
static void xopenlog(BIO* bp, const char* name, int level)
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d60 2
a61 2
	It is one-way BIO, it sends all stuff to syslogd (or event log
	under NT).
d69 11
a79 8
#ifndef WIN32
#ifdef __ultrix
#include <sys/syslog.h>
#else
#include <syslog.h>
#endif
#else
#include <process.h>
d85 1
d88 24
d118 3
a120 2
static int xopenlog(BIO* bp, const char* name, int level);
static int xcloselog(BIO* bp);
a144 1
#ifndef WIN32
a145 3
#else
	xopenlog(bi, "application", 0);
#endif
a160 6
#if defined(WIN32)
	LPCSTR lpszStrings[2];
	WORD evtype= EVENTLOG_ERROR_TYPE;
	int pid = _getpid();
	char pidbuf[20];
#else
a161 1
#endif
a167 18
#if defined(WIN32)
	if(strncmp(buf, "ERR ", 4) == 0){
		evtype= EVENTLOG_ERROR_TYPE;
		pp= buf+ 4;
	}else if(strncmp(buf, "WAR ", 4) == 0){
		evtype= EVENTLOG_WARNING_TYPE;
		pp= buf+ 4;
	}else if(strncmp(buf, "INF ", 4) == 0){
		evtype= EVENTLOG_INFORMATION_TYPE;
		pp= buf+ 4;
	}else{
		evtype= EVENTLOG_ERROR_TYPE;
		pp= buf;
	}

	sprintf(pidbuf, "[%d] ", pid);
	lpszStrings[0] = pidbuf;
	lpszStrings[1] = pp;
a168 4
	if(b->ptr)
		ReportEvent(b->ptr, evtype, 0, 1024, NULL, 2, 0,
				lpszStrings, NULL);
#else
d183 2
a184 2
	syslog(priority, "%s", pp);
#endif
d212 3
a214 1
static int xopenlog(BIO* bp, const char* name, int level)
d216 1
a216 8
#if defined(WIN32)
	if((bp->ptr= (char *)RegisterEventSource(NULL, name)) == NULL){
		return(0);
	}
#else
	openlog(name, LOG_PID|LOG_CONS, level);
#endif
	return(1);
d219 33
a251 1
static int xcloselog(BIO* bp)
a252 1
#if defined(WIN32)
d256 75
a330 1
#else
a331 2
#endif
	return(1);
d334 3
a336 1
#endif
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d75 2
d103 1
d137 1
a137 1
	LPTSTR lpszStrings[1];
d139 2
d164 4
a167 1
	lpszStrings[0]= pp;
d170 1
a170 1
		ReportEvent(b->ptr, evtype, 0, 1024, NULL, 1, 0,
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d60 2
a61 2
	It is one-way BIO, it sends all stuff to syslogd (on system that
	commonly use that), or event log (on NT), or OPCOM (on OpenVMS).
d69 6
a74 13
#include "cryptlib.h"

#if defined(OPENSSL_SYS_WIN32)
#  include <process.h>
#elif defined(OPENSSL_SYS_VMS)
#  include <opcdef.h>
#  include <descrip.h>
#  include <lib$routines.h>
#  include <starlet.h>
#elif defined(__ultrix)
#  include <sys/syslog.h>
#elif !defined(MSDOS) && !defined(OPENSSL_SYS_VXWORKS) && !defined(NO_SYSLOG) /* Unix */
#  include <syslog.h>
d77 1
a79 1

a81 24
#if defined(OPENSSL_SYS_WIN32)
#define LOG_EMERG	0
#define LOG_ALERT	1
#define LOG_CRIT	2
#define LOG_ERR		3
#define LOG_WARNING	4
#define LOG_NOTICE	5
#define LOG_INFO	6
#define LOG_DEBUG	7

#define LOG_DAEMON	(3<<3)
#elif defined(OPENSSL_SYS_VMS)
/* On VMS, we don't really care about these, but we need them to compile */
#define LOG_EMERG	0
#define LOG_ALERT	1
#define LOG_CRIT	2
#define LOG_ERR		3
#define LOG_WARNING	4
#define LOG_NOTICE	5
#define LOG_INFO	6
#define LOG_DEBUG	7

#define LOG_DAEMON	OPC$M_NM_NTWORK
#endif
d83 3
a85 3
static int MS_CALLBACK slg_write(BIO *h, const char *buf, int num);
static int MS_CALLBACK slg_puts(BIO *h, const char *str);
static long MS_CALLBACK slg_ctrl(BIO *h, int cmd, long arg1, void *arg2);
d88 2
a89 15
static void xopenlog(BIO* bp, char* name, int level);
static void xsyslog(BIO* bp, int priority, const char* string);
static void xcloselog(BIO* bp);
#ifdef OPENSSL_SYS_WIN32
LONG	(WINAPI *go_for_advapi)()	= RegOpenKeyEx;
HANDLE	(WINAPI *register_event_source)()	= NULL;
BOOL	(WINAPI *deregister_event_source)()	= NULL;
BOOL	(WINAPI *report_event)()	= NULL;
#define DL_PROC(m,f)	(GetProcAddress( m, f ))
#ifdef UNICODE
#define DL_PROC_X(m,f) DL_PROC( m, f "W" )
#else
#define DL_PROC_X(m,f) DL_PROC( m, f "A" )
#endif
#endif
a100 1
	NULL,
d113 1
d115 3
d128 1
a128 1
static int MS_CALLBACK slg_write(BIO *b, const char *in, int inl)
d131 1
a131 1
	char* buf;
d133 6
a138 30
	int priority, i;
	static struct
		{
		int strl;
		char str[10];
		int log_level;
		}
	mapping[] =
		{
		{ 6, "PANIC ", LOG_EMERG },
		{ 6, "EMERG ", LOG_EMERG },
		{ 4, "EMR ", LOG_EMERG },
		{ 6, "ALERT ", LOG_ALERT },
		{ 4, "ALR ", LOG_ALERT },
		{ 5, "CRIT ", LOG_CRIT },
		{ 4, "CRI ", LOG_CRIT },
		{ 6, "ERROR ", LOG_ERR },
		{ 4, "ERR ", LOG_ERR },
		{ 8, "WARNING ", LOG_WARNING },
		{ 5, "WARN ", LOG_WARNING },
		{ 4, "WAR ", LOG_WARNING },
		{ 7, "NOTICE ", LOG_NOTICE },
		{ 5, "NOTE ", LOG_NOTICE },
		{ 4, "NOT ", LOG_NOTICE },
		{ 5, "INFO ", LOG_INFO },
		{ 4, "INF ", LOG_INFO },
		{ 6, "DEBUG ", LOG_DEBUG },
		{ 4, "DBG ", LOG_DEBUG },
		{ 0, "", LOG_ERR } /* The default */
		};
d140 1
a140 1
	if((buf= (char *)OPENSSL_malloc(inl+ 1)) == NULL){
d145 15
d161 17
a177 4
	i = 0;
	while(strncmp(buf, mapping[i].str, mapping[i].strl) != 0) i++;
	priority = mapping[i].log_level;
	pp = buf + mapping[i].strl;
d179 3
a181 3
	xsyslog(b, priority, pp);

	OPENSSL_free(buf);
d185 1
a185 1
static long MS_CALLBACK slg_ctrl(BIO *b, int cmd, long num, void *ptr)
d199 1
a199 1
static int MS_CALLBACK slg_puts(BIO *bp, const char *str)
d208 1
a208 3
#if defined(OPENSSL_SYS_WIN32)

static void xopenlog(BIO* bp, char* name, int level)
d210 8
a217 21
	if ( !register_event_source )
		{
		HANDLE	advapi;
		if ( !(advapi = GetModuleHandle("advapi32")) )
			return;
		register_event_source = (HANDLE (WINAPI *)())DL_PROC_X(advapi,
			"RegisterEventSource" );
		deregister_event_source = (BOOL (WINAPI *)())DL_PROC(advapi,
			"DeregisterEventSource");
		report_event = (BOOL (WINAPI *)())DL_PROC_X(advapi,
			"ReportEvent" );
		if ( !(register_event_source && deregister_event_source &&
				report_event) )
			{
			register_event_source = NULL;
			deregister_event_source = NULL;
			report_event = NULL;
			return;
			}
		}
	bp->ptr= (char *)register_event_source(NULL, name);
d220 1
a220 39
static void xsyslog(BIO *bp, int priority, const char *string)
{
	LPCSTR lpszStrings[2];
	WORD evtype= EVENTLOG_ERROR_TYPE;
	int pid = _getpid();
	char pidbuf[20];

	switch (priority)
		{
	case LOG_EMERG:
	case LOG_ALERT:
	case LOG_CRIT:
	case LOG_ERR:
		evtype = EVENTLOG_ERROR_TYPE;
		break;
	case LOG_WARNING:
		evtype = EVENTLOG_WARNING_TYPE;
		break;
	case LOG_NOTICE:
	case LOG_INFO:
	case LOG_DEBUG:
		evtype = EVENTLOG_INFORMATION_TYPE;
		break;
	default:		/* Should never happen, but set it
				   as error anyway. */
		evtype = EVENTLOG_ERROR_TYPE;
		break;
		}

	sprintf(pidbuf, "[%d] ", pid);
	lpszStrings[0] = pidbuf;
	lpszStrings[1] = string;

	if(report_event && bp->ptr)
		report_event(bp->ptr, evtype, 0, 1024, NULL, 2, 0,
				lpszStrings, NULL);
}
	
static void xcloselog(BIO* bp)
d222 3
a224 2
	if(deregister_event_source && bp->ptr)
		deregister_event_source((HANDLE)(bp->ptr));
d226 1
a226 75
}

#elif defined(OPENSSL_SYS_VMS)

static int VMS_OPC_target = LOG_DAEMON;

static void xopenlog(BIO* bp, char* name, int level)
{
	VMS_OPC_target = level; 
}

static void xsyslog(BIO *bp, int priority, const char *string)
{
	struct dsc$descriptor_s opc_dsc;
	struct opcdef *opcdef_p;
	char buf[10240];
	unsigned int len;
        struct dsc$descriptor_s buf_dsc;
	$DESCRIPTOR(fao_cmd, "!AZ: !AZ");
	char *priority_tag;

	switch (priority)
	  {
	  case LOG_EMERG: priority_tag = "Emergency"; break;
	  case LOG_ALERT: priority_tag = "Alert"; break;
	  case LOG_CRIT: priority_tag = "Critical"; break;
	  case LOG_ERR: priority_tag = "Error"; break;
	  case LOG_WARNING: priority_tag = "Warning"; break;
	  case LOG_NOTICE: priority_tag = "Notice"; break;
	  case LOG_INFO: priority_tag = "Info"; break;
	  case LOG_DEBUG: priority_tag = "DEBUG"; break;
	  }

	buf_dsc.dsc$b_dtype = DSC$K_DTYPE_T;
	buf_dsc.dsc$b_class = DSC$K_CLASS_S;
	buf_dsc.dsc$a_pointer = buf;
	buf_dsc.dsc$w_length = sizeof(buf) - 1;

	lib$sys_fao(&fao_cmd, &len, &buf_dsc, priority_tag, string);

	/* we know there's an 8 byte header.  That's documented */
	opcdef_p = (struct opcdef *) OPENSSL_malloc(8 + len);
	opcdef_p->opc$b_ms_type = OPC$_RQ_RQST;
	memcpy(opcdef_p->opc$z_ms_target_classes, &VMS_OPC_target, 3);
	opcdef_p->opc$l_ms_rqstid = 0;
	memcpy(&opcdef_p->opc$l_ms_text, buf, len);

	opc_dsc.dsc$b_dtype = DSC$K_DTYPE_T;
	opc_dsc.dsc$b_class = DSC$K_CLASS_S;
	opc_dsc.dsc$a_pointer = (char *)opcdef_p;
	opc_dsc.dsc$w_length = len + 8;

	sys$sndopr(opc_dsc, 0);

	OPENSSL_free(opcdef_p);
}

static void xcloselog(BIO* bp)
{
}

#else /* Unix */

static void xopenlog(BIO* bp, char* name, int level)
{
	openlog(name, LOG_PID|LOG_CONS, level);
}

static void xsyslog(BIO *bp, int priority, const char *string)
{
	syslog(priority, "%s", string);
}

static void xcloselog(BIO* bp)
{
d228 2
d232 1
a232 3
#endif /* Unix */

#endif /* NO_SYSLOG */
@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@d71 1
a71 2
#if defined(OPENSSL_SYS_WINCE)
#elif defined(OPENSSL_SYS_WIN32)
d80 1
a80 1
#elif (!defined(MSDOS) || defined(WATT32)) && !defined(OPENSSL_SYS_VXWORKS) && !defined(NO_SYSLOG)
d277 1
a277 1
	char pidbuf[DECIMAL_SIZE(pid)+4];
d376 1
a376 1
#else /* Unix/Watt32 */
a379 3
#ifdef WATT32   /* djgpp/DOS */
	openlog(name, LOG_PID|LOG_CONS|LOG_NDELAY, level);
#else
a380 1
#endif
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@a80 2
#elif defined(OPENSSL_SYS_NETWARE)
#  define NO_SYSLOG
@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@d73 1
d125 12
d178 1
a178 1
	static const struct
d252 21
a272 4
	if (GetVersion() < 0x80000000)
		bp->ptr = RegisterEventSourceA(NULL,name);
	else
		bp->ptr = NULL;
d279 2
a280 4
	char pidbuf[DECIMAL_SIZE(DWORD)+4];

	if (bp->ptr == NULL)
		return;
d304 1
a304 1
	sprintf(pidbuf, "[%u] ", GetCurrentProcessId());
d308 2
a309 1
	ReportEventA(bp->ptr, evtype, 0, 1024, NULL, 2, 0,
d315 2
a316 2
	if(bp->ptr)
		DeregisterEventSource((HANDLE)(bp->ptr));
@


1.1.1.5
log
@import OpenSSL 1.0.0e
@
text
@a77 9
/* Some compiler options may mask the declaration of "_malloc32". */
#  if __INITIAL_POINTER_SIZE && defined _ANSI_C_SOURCE
#    if __INITIAL_POINTER_SIZE == 64
#      pragma pointer_size save
#      pragma pointer_size 32
    void * _malloc32  (__size_t);
#      pragma pointer_size restore
#    endif /* __INITIAL_POINTER_SIZE == 64 */
#  endif /* __INITIAL_POINTER_SIZE && defined _ANSI_C_SOURCE */
a302 12

/* Arrange 32-bit pointer to opcdef buffer and malloc(), if needed. */
#if __INITIAL_POINTER_SIZE == 64
# pragma pointer_size save
# pragma pointer_size 32
# define OPCDEF_TYPE __char_ptr32
# define OPCDEF_MALLOC _malloc32
#else /* __INITIAL_POINTER_SIZE == 64 */
# define OPCDEF_TYPE char *
# define OPCDEF_MALLOC OPENSSL_malloc
#endif /* __INITIAL_POINTER_SIZE == 64 [else] */

a303 5

#if __INITIAL_POINTER_SIZE == 64
# pragma pointer_size restore
#endif /* __INITIAL_POINTER_SIZE == 64 */

d329 2
a330 2
	/* We know there's an 8-byte header.  That's documented. */
	opcdef_p = OPCDEF_MALLOC( 8+ len);
d338 1
a338 1
	opc_dsc.dsc$a_pointer = (OPCDEF_TYPE) opcdef_p;
@


1.1.1.6
log
@Import OpenSSL 1.0.1g
@
text
@d248 1
a248 1
	if (check_winnt())
@


