head	1.14;
access;
symbols
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	openssl_0_9_8_k:1.1.1.6
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	openssl_0_9_8_j:1.1.1.6
	openssl_0_9_8_h:1.1.1.6
	pre_openssl_0_9_8h:1.11
	OPENBSD_4_4:1.11.0.14
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.12
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.10
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.8
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.6
	OPENBSD_4_0_BASE:1.11
	openssl_0_9_7j:1.1.1.5
	openssl:1.1.1
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@# @;


1.14
date	2010.10.01.22.58.56;	author djm;	state dead;
branches;
next	1.13;

1.13
date	2008.09.19.06.09.01;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.10.14.03.22;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.29.05.39.24;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.18.12.39.05;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.12.02.18.38;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.15;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.01.19.51.17;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.41;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.10.57;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.29;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.54;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.54;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.43;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.35.38;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.11.11.21.16.36;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.13;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.45;	author djm;	state Exp;
branches;
next	;


desc
@@


1.14
log
@resolve conflicts, fix local changes
@
text
@#!/usr/local/bin/perl

package x86unix;	# GAS actually...

$label="L000";
$const="";
$constl=0;

$align=($main'aout)?"4":"16";
$under=($main'aout or $main'coff)?"_":"";
$dot=($main'aout)?"":".";
$com_start="#" if ($main'aout or $main'coff);

sub main'asm_init_output { @@out=(); }
sub main'asm_get_output { return(@@out); }
sub main'get_labels { return(@@labels); }
sub main'external_label { push(@@labels,@@_); }

if ($main'openbsd)
	{
	$com_start='/*';
	$com_end='*/';
	}

if ($main'cpp)
	{
	$align="ALIGN";
	$under="";
	$com_start='/*';
	$com_end='*/';
	}

%lb=(	'eax',	'%al',
	'ebx',	'%bl',
	'ecx',	'%cl',
	'edx',	'%dl',
	'ax',	'%al',
	'bx',	'%bl',
	'cx',	'%cl',
	'dx',	'%dl',
	);

%hb=(	'eax',	'%ah',
	'ebx',	'%bh',
	'ecx',	'%ch',
	'edx',	'%dh',
	'ax',	'%ah',
	'bx',	'%bh',
	'cx',	'%ch',
	'dx',	'%dh',
	);

%regs=(	'eax',	'%eax',
	'ebx',	'%ebx',
	'ecx',	'%ecx',
	'edx',	'%edx',
	'esi',	'%esi',
	'edi',	'%edi',
	'ebp',	'%ebp',
	'esp',	'%esp',

	'mm0',	'%mm0',
	'mm1',	'%mm1',
	'mm2',	'%mm2',
	'mm3',	'%mm3',
	'mm4',	'%mm4',
	'mm5',	'%mm5',
	'mm6',	'%mm6',
	'mm7',	'%mm7',

	'xmm0',	'%xmm0',
	'xmm1',	'%xmm1',
	'xmm2',	'%xmm2',
	'xmm3',	'%xmm3',
	'xmm4',	'%xmm4',
	'xmm5',	'%xmm5',
	'xmm6',	'%xmm6',
	'xmm7',	'%xmm7',
	);

%reg_val=(
	'eax',	0x00,
	'ebx',	0x03,
	'ecx',	0x01,
	'edx',	0x02,
	'esi',	0x06,
	'edi',	0x07,
	'ebp',	0x05,
	'esp',	0x04,
	);

sub main'LB
	{
	(defined($lb{$_[0]})) || die "$_[0] does not have a 'low byte'\n";
	return($lb{$_[0]});
	}

sub main'HB
	{
	(defined($hb{$_[0]})) || die "$_[0] does not have a 'high byte'\n";
	return($hb{$_[0]});
	}

sub main'DWP
	{
	local($addr,$reg1,$reg2,$idx)=@@_;

	$ret="";
	$addr =~ s/(^|[+ \t])([A-Za-z_]+[A-Za-z0-9_]+)($|[+ \t])/$1$under$2$3/;
	$reg1="$regs{$reg1}" if defined($regs{$reg1});
	$reg2="$regs{$reg2}" if defined($regs{$reg2});
	$ret.=$addr if ($addr ne "") && ($addr ne 0);
	if ($reg2 ne "")
		{
		if($idx ne "" && $idx != 0)
		    { $ret.="($reg1,$reg2,$idx)"; }
		else
		    { $ret.="($reg1,$reg2)"; }
	        }
	elsif ($reg1 ne "")
		{ $ret.="($reg1)" }
	return($ret);
	}

sub main'QWP
	{
	return(&main'DWP(@@_));
	}

sub main'BP
	{
	return(&main'DWP(@@_));
	}

sub main'BC
	{
	return @@_;
	}

sub main'DWC
	{
	return @@_;
	}

#sub main'BP
#	{
#	local($addr,$reg1,$reg2,$idx)=@@_;
#
#	$ret="";
#
#	$addr =~ s/(^|[+ \t])([A-Za-z_]+)($|[+ \t])/$1$under$2$3/;
#	$reg1="$regs{$reg1}" if defined($regs{$reg1});
#	$reg2="$regs{$reg2}" if defined($regs{$reg2});
#	$ret.=$addr if ($addr ne "") && ($addr ne 0);
#	if ($reg2 ne "")
#		{ $ret.="($reg1,$reg2,$idx)"; }
#	else
#		{ $ret.="($reg1)" }
#	return($ret);
#	}

sub main'mov	{ &out2("movl",@@_); }
sub main'movb	{ &out2("movb",@@_); }
sub main'and	{ &out2("andl",@@_); }
sub main'or	{ &out2("orl",@@_); }
sub main'shl	{ &out2("sall",@@_); }
sub main'shr	{ &out2("shrl",@@_); }
sub main'xor	{ &out2("xorl",@@_); }
sub main'xorb	{ &out2("xorb",@@_); }
sub main'add	{ &out2($_[0]=~/%[a-d][lh]/?"addb":"addl",@@_); }
sub main'adc	{ &out2("adcl",@@_); }
sub main'sub	{ &out2("subl",@@_); }
sub main'sbb	{ &out2("sbbl",@@_); }
sub main'rotl	{ &out2("roll",@@_); }
sub main'rotr	{ &out2("rorl",@@_); }
sub main'exch	{ &out2($_[0]=~/%[a-d][lh]/?"xchgb":"xchgl",@@_); }
sub main'cmp	{ &out2("cmpl",@@_); }
sub main'lea	{ &out2("leal",@@_); }
sub main'mul	{ &out1("mull",@@_); }
sub main'imul	{ &out2("imull",@@_); }
sub main'div	{ &out1("divl",@@_); }
sub main'jmp	{ &out1("jmp",@@_); }
sub main'jmp_ptr { &out1p("jmp",@@_); }
sub main'je	{ &out1("je",@@_); }
sub main'jle	{ &out1("jle",@@_); }
sub main'jne	{ &out1("jne",@@_); }
sub main'jnz	{ &out1("jnz",@@_); }
sub main'jz	{ &out1("jz",@@_); }
sub main'jge	{ &out1("jge",@@_); }
sub main'jl	{ &out1("jl",@@_); }
sub main'ja	{ &out1("ja",@@_); }
sub main'jae	{ &out1("jae",@@_); }
sub main'jb	{ &out1("jb",@@_); }
sub main'jbe	{ &out1("jbe",@@_); }
sub main'jc	{ &out1("jc",@@_); }
sub main'jnc	{ &out1("jnc",@@_); }
sub main'jno	{ &out1("jno",@@_); }
sub main'dec	{ &out1("decl",@@_); }
sub main'inc	{ &out1($_[0]=~/%[a-d][hl]/?"incb":"incl",@@_); }
sub main'push	{ &out1("pushl",@@_); $stack+=4; }
sub main'pop	{ &out1("popl",@@_); $stack-=4; }
sub main'pushf	{ &out0("pushfl"); $stack+=4; }
sub main'popf	{ &out0("popfl"); $stack-=4; }
sub main'not	{ &out1("notl",@@_); }
sub main'call	{	my $pre=$under;
			foreach $i (%label)
			{ if ($label{$i} eq $_[0]) { $pre=''; last; } }
			&out1("call",$pre.$_[0]);
		}
sub main'call_ptr { &out1p("call",@@_); }
sub main'ret	{ &out0("ret"); }
sub main'nop	{ &out0("nop"); }
sub main'test	{ &out2("testl",@@_); }
sub main'bt	{ &out2("btl",@@_); }
sub main'leave	{ &out0("leave"); }
sub main'cpuid	{ &out0(".byte\t0x0f,0xa2"); }
sub main'rdtsc	{ &out0(".byte\t0x0f,0x31"); }
sub main'halt	{ &out0("hlt"); }
sub main'movz	{ &out2("movzbl",@@_); }
sub main'neg	{ &out1("negl",@@_); }
sub main'cld	{ &out0("cld"); }

# SSE2
sub main'emms	{ &out0("emms"); }
sub main'movd	{ &out2("movd",@@_); }
sub main'movdqu	{ &out2("movdqu",@@_); }
sub main'movdqa	{ &out2("movdqa",@@_); }
sub main'movdq2q{ &out2("movdq2q",@@_); }
sub main'movq2dq{ &out2("movq2dq",@@_); }
sub main'paddq	{ &out2("paddq",@@_); }
sub main'pmuludq{ &out2("pmuludq",@@_); }
sub main'psrlq	{ &out2("psrlq",@@_); }
sub main'psllq	{ &out2("psllq",@@_); }
sub main'pxor	{ &out2("pxor",@@_); }
sub main'por	{ &out2("por",@@_); }
sub main'pand	{ &out2("pand",@@_); }
sub main'movq	{
	local($p1,$p2,$optimize)=@@_;
	if ($optimize && $p1=~/^mm[0-7]$/ && $p2=~/^mm[0-7]$/)
		# movq between mmx registers can sink Intel CPUs
		{	push(@@out,"\tpshufw\t\$0xe4,%$p2,%$p1\n");	}
	else	{	&out2("movq",@@_);				}
	}

# The bswapl instruction is new for the 486. Emulate if i386.
sub main'bswap
	{
	if ($main'i386)
		{
		&main'comment("bswapl @@_");
		&main'exch(main'HB(@@_),main'LB(@@_));
		&main'rotr(@@_,16);
		&main'exch(main'HB(@@_),main'LB(@@_));
		}
	else
		{
		&out1("bswapl",@@_);
		}
	}

sub out2
	{
	local($name,$p1,$p2)=@@_;
	local($l,$ll,$t);
	local(%special)=(	"roll",0xD1C0,"rorl",0xD1C8,
				"rcll",0xD1D0,"rcrl",0xD1D8,
				"shll",0xD1E0,"shrl",0xD1E8,
				"sarl",0xD1F8);
	
	if ((defined($special{$name})) && defined($regs{$p1}) && ($p2 == 1))
		{
		$op=$special{$name}|$reg_val{$p1};
		$tmp1=sprintf(".byte %d\n",($op>>8)&0xff);
		$tmp2=sprintf(".byte %d\t",$op     &0xff);
		push(@@out,$tmp1);
		push(@@out,$tmp2);

		$p2=&conv($p2);
		$p1=&conv($p1);
		&main'comment("$name $p2 $p1");
		return;
		}

	push(@@out,"\t$name\t");
	$t=&conv($p2).",";
	$l=length($t);
	push(@@out,$t);
	$ll=4-($l+9)/8;
	$tmp1=sprintf("\t" x $ll);
	push(@@out,$tmp1);
	push(@@out,&conv($p1)."\n");
	}

sub out1
	{
	local($name,$p1)=@@_;
	local($l,$t);
	local(%special)=("bswapl",0x0FC8);

	if ((defined($special{$name})) && defined($regs{$p1}))
		{
		$op=$special{$name}|$reg_val{$p1};
		$tmp1=sprintf(".byte %d\n",($op>>8)&0xff);
		$tmp2=sprintf(".byte %d\t",$op     &0xff);
		push(@@out,$tmp1);
		push(@@out,$tmp2);

		$p2=&conv($p2);
		$p1=&conv($p1);
		&main'comment("$name $p2 $p1");
		return;
		}

	push(@@out,"\t$name\t".&conv($p1)."\n");
	}

sub out1p
	{
	local($name,$p1)=@@_;
	local($l,$t);

	push(@@out,"\t$name\t*".&conv($p1)."\n");
	}

sub out0
	{
	push(@@out,"\t$_[0]\n");
	}

sub conv
	{
	local($p)=@@_;

#	$p =~ s/0x([0-9A-Fa-f]+)/0$1h/;

	$p=$regs{$p} if (defined($regs{$p}));

	$p =~ s/^(-{0,1}[0-9A-Fa-f]+)$/\$$1/;
	$p =~ s/^(0x[0-9A-Fa-f]+)$/\$$1/;
	return $p;
	}

sub main'file
	{
	local($file)=@@_;

	if ($main'openbsd)
		{ push(@@out,"#include <machine/asm.h>\n"); }

	local($tmp)=<<"EOF";
	.file	"$file.s"
EOF
	push(@@out,$tmp);
	}

sub main'function_begin
	{
	local($func,$junk,$llabel)=@@_;

	&main'external_label($func);
	$func=$under.$func;

	if ($main'openbsd)
		{
		push (@@out, "\nENTRY($func)\n");
		push (@@out, "$llabel:\n") if $llabel;
		goto skip;
		}

	local($tmp)=<<"EOF";
.text
.globl	$func
EOF
	push(@@out,$tmp);
	if ($main'cpp)
		{ $tmp=push(@@out,"TYPE($func,\@@function)\n"); }
	elsif ($main'coff)
		{ $tmp=push(@@out,".def\t$func;\t.scl\t2;\t.type\t32;\t.endef\n"); }
	elsif ($main'aout and !$main'pic)
		{ }
	else	{ $tmp=push(@@out,".type\t$func,\@@function\n"); }
	push(@@out,".align\t$align\n");
	push(@@out,"$func:\n");
skip:
	$tmp=<<"EOF";
	pushl	%ebp
	pushl	%ebx
	pushl	%esi
	pushl	%edi

EOF
	push(@@out,$tmp);
	$stack=20;
	}

sub main'function_begin_B
	{
	local($func,$extra)=@@_;

	&main'external_label($func);
	$func=$under.$func;

	if ($main'openbsd)
		{ push(@@out, "\nENTRY($func)\n"); goto skip; }

	local($tmp)=<<"EOF";
.text
.globl	$func
EOF
	push(@@out,$tmp);
	if ($main'cpp)
		{ push(@@out,"TYPE($func,\@@function)\n"); }
	elsif ($main'coff)
		{ $tmp=push(@@out,".def\t$func;\t.scl\t2;\t.type\t32;\t.endef\n"); }
	elsif ($main'aout and !$main'pic)
		{ }
	else	{ push(@@out,".type	$func,\@@function\n"); }
	push(@@out,".align\t$align\n");
	push(@@out,"$func:\n");
skip:
	$stack=4;
	}

# Like function_begin_B but with static linkage
sub main'function_begin_C
	{
	local($func,$extra)=@@_;

	&main'external_label($func);
	$func=$under.$func;

	if ($main'openbsd)
		{
			local($tmp)=<<"EOF";
.text
_ALIGN_TEXT
.type $func,\@@function
$func:
EOF
			push(@@out, $tmp);
			goto skip;
		}

	local($tmp)=<<"EOF";
.text
.globl	$func
EOF
	push(@@out,$tmp);
	if ($main'cpp)
		{ push(@@out,"TYPE($func,\@@function)\n"); }
	elsif ($main'coff)
		{ $tmp=push(@@out,".def\t$func;\t.scl\t2;\t.type\t32;\t.endef\n"); }
	elsif ($main'aout and !$main'pic)
		{ }
	else	{ push(@@out,".type	$func,\@@function\n"); }
	push(@@out,".align\t$align\n");
	push(@@out,"$func:\n");
skip:
	$stack=4;
	}

sub main'function_end
	{
	local($func)=@@_;

	$func=$under.$func;

	local($tmp)=<<"EOF";
	popl	%edi
	popl	%esi
	popl	%ebx
	popl	%ebp
	ret
${dot}L_${func}_end:
EOF
	push(@@out,$tmp);

	if ($main'cpp)
		{ push(@@out,"SIZE($func,${dot}L_${func}_end-$func)\n"); }
	elsif ($main'coff or $main'aout)
                { }
	else	{ push(@@out,".size\t$func,${dot}L_${func}_end-$func\n"); }
	push(@@out,".ident	\"$func\"\n");
	$stack=0;
	%label=();
	}

sub main'function_end_A
	{
	local($func)=@@_;

	local($tmp)=<<"EOF";
	popl	%edi
	popl	%esi
	popl	%ebx
	popl	%ebp
	ret
EOF
	push(@@out,$tmp);
	}

sub main'function_end_B
	{
	local($func)=@@_;

	$func=$under.$func;

	push(@@out,"${dot}L_${func}_end:\n");
	if ($main'cpp)
		{ push(@@out,"SIZE($func,${dot}L_${func}_end-$func)\n"); }
        elsif ($main'coff or $main'aout)
                { }
	else	{ push(@@out,".size\t$func,${dot}L_${func}_end-$func\n"); }
	push(@@out,".ident	\"$func\"\n");
	$stack=0;
	%label=();
	}

sub main'function_end_C { function_end_B(@@_); }

sub main'wparam
	{
	local($num)=@@_;

	return(&main'DWP($stack+$num*4,"esp","",0));
	}

sub main'stack_push
	{
	local($num)=@@_;
	$stack+=$num*4;
	&main'sub("esp",$num*4);
	}

sub main'stack_pop
	{
	local($num)=@@_;
	$stack-=$num*4;
	&main'add("esp",$num*4);
	}

sub main'swtmp
	{
	return(&main'DWP($_[0]*4,"esp","",0));
	}

# Should use swtmp, which is above esp.  Linix can trash the stack above esp
#sub main'wtmp
#	{
#	local($num)=@@_;
#
#	return(&main'DWP(-($num+1)*4,"esp","",0));
#	}

sub main'comment
	{
	if (!defined($com_start) or (!$main'openbsd && $main'elf))
		{	# Regarding $main'elf above...
			# GNU and SVR4 as'es use different comment delimiters,
		push(@@out,"\n");	# so we just skip ELF comments...
		return;
		}
	foreach (@@_)
		{
		if (/^\s*$/)
			{ push(@@out,"\n"); }
		else
			{ push(@@out,"\t$com_start $_ $com_end\n"); }
		}
	}

sub main'public_label
	{
	$label{$_[0]}="${under}${_[0]}"	if (!defined($label{$_[0]}));
	push(@@out,".globl\t$label{$_[0]}\n");
	}

sub main'label
	{
	if (!defined($label{$_[0]}))
		{
		$label{$_[0]}="${dot}${label}${_[0]}";
		$label++;
		}
	return($label{$_[0]});
	}

sub main'set_label
	{
	if (!defined($label{$_[0]}))
		{
		$label{$_[0]}="${dot}${label}${_[0]}";
		$label++;
		}
	if ($_[1]!=0)
		{
		if ($_[1]>1)	{ main'align($_[1]);		}
		else
			{
			if ($main'openbsd)
				{ push(@@out,"_ALIGN_TEXT\n"); }
			else
				{ push(@@out,".align $align\n"); }
			}
		}
	push(@@out,"$label{$_[0]}:\n");
	}

sub main'file_end
	{
	# try to detect if SSE2 or MMX extensions were used on ELF platform...
	if ($main'elf && grep {/\b%[x]*mm[0-7]\b|OPENSSL_ia32cap_P\b/i} @@out) {
		local($tmp);

		push (@@out,"\n.section\t.bss\n");
		push (@@out,".comm\t${under}OPENSSL_ia32cap_P,4,4\n");

		return;
	}

	if ($const ne "")
		{
		push(@@out,".section .rodata\n");
		push(@@out,$const);
		$const="";
		}
	}

sub main'data_byte
	{
	push(@@out,"\t.byte\t".join(',',@@_)."\n");
	}

sub main'data_word
	{
	push(@@out,"\t.long\t".join(',',@@_)."\n");
	}

sub main'align
	{
	my $val=$_[0],$p2,$i;
	if ($main'aout) {
		for ($p2=0;$val!=0;$val>>=1) { $p2++; }
		$val=$p2-1;
		$val.=",0x90";
	}
	push(@@out,".align\t$val\n");
	if ($main'openbsd)
		{ push(@@out,"_ALIGN_TEXT\n"); }
	else
		{ push(@@out,".align $tval\n"); }
	}

# debug output functions: puts, putx, printf

sub main'puts
	{
	&pushvars();
	&main'push('$Lstring' . ++$constl);
	&main'call('puts');
	$stack-=4;
	&main'add("esp",4);
	&popvars();

	$const .= "Lstring$constl:\n\t.string \"@@_[0]\"\n";
	}

sub main'putx
	{
	&pushvars();
	&main'push($_[0]);
	&main'push('$Lstring' . ++$constl);
	&main'call('printf');
	&main'add("esp",8);
	$stack-=8;
	&popvars();

	$const .= "Lstring$constl:\n\t.string \"\%X\"\n";
	}

sub main'printf
	{
	$ostack = $stack;
	&pushvars();
	for ($i = @@_ - 1; $i >= 0; $i--)
		{
		if ($i == 0) # change this to support %s format strings
			{
			&main'push('$Lstring' . ++$constl);
			$const .= "Lstring$constl:\n\t.string \"@@_[$i]\"\n";
			}
		else
			{
			if ($_[$i] =~ /([0-9]*)\(%esp\)/)
				{
				&main'push(($1 + $stack - $ostack) . '(%esp)');
				}
			else
				{
				&main'push($_[$i]);
				}
			}
		}
	&main'call('printf');
	$stack-=4*@@_;
	&main'add("esp",4*@@_);
	&popvars();
	}

sub pushvars
	{
	&main'pushf();
	&main'push("edx");
	&main'push("ecx");
	&main'push("eax");
	}

sub popvars
	{
	&main'pop("eax");
	&main'pop("ecx");
	&main'pop("edx");
	&main'popf();
	}

sub main'picmeup
	{
	local($dst,$sym)=@@_;
	if ($main'cpp)
		{
		local($tmp)=<<___;
#if (defined(ELF) || defined(SOL)) && defined(PIC)
	call	1f
1:	popl	$regs{$dst}
	addl	\$_GLOBAL_OFFSET_TABLE_+[.-1b],$regs{$dst}
	movl	$sym\@@GOT($regs{$dst}),$regs{$dst}
#else
	leal	$sym,$regs{$dst}
#endif
___
		push(@@out,$tmp);
		}
	elsif ($main'openbsd)
		{
		push(@@out, "#ifdef PIC\n");
		push(@@out, "\tPIC_PROLOGUE\n");
		&main'mov($dst,"PIC_GOT($sym)");
		push(@@out, "\tPIC_EPILOGUE\n");
		push(@@out, "#else\n");
		&main'lea($dst,&main'DWP($sym));
		push(@@out, "#endif\n");
		}
	elsif ($main'pic && ($main'elf || $main'aout))
		{
		&main'call(&main'label("PIC_me_up"));
		&main'set_label("PIC_me_up");
		&main'blindpop($dst);
		&main'add($dst,"\$${under}_GLOBAL_OFFSET_TABLE_+[.-".
				&main'label("PIC_me_up") . "]");
		&main'mov($dst,&main'DWP($under.$sym."\@@GOT",$dst));
		}
	else
		{
		&main'lea($dst,&main'DWP($sym));
		}
	}

sub main'blindpop { &out1("popl",@@_); }

sub main'initseg
	{
	local($f)=@@_;
	local($tmp);
	if ($main'elf)
		{
		$tmp=<<___;
.section	.init
		PIC_PROLOGUE
		call	PIC_PLT($under$f)
		PIC_EPILOGUE
	jmp	.Linitalign
.align	$align
.Linitalign:
___
		}
	elsif ($main'coff)
		{
		$tmp=<<___;	# applies to both Cygwin and Mingw
.section	.ctors
.long	$under$f
___
		}
	elsif ($main'aout)
		{
		local($ctor)="${under}_GLOBAL_\$I\$$f";
		$tmp=".text\n";
		$tmp.=".type	$ctor,\@@function\n" if ($main'pic);
		$tmp.=<<___;	# OpenBSD way...
.globl	$ctor
.align	2
$ctor:
	jmp	$under$f
___
		}
	push(@@out,$tmp) if ($tmp);
	}

1;
@


1.13
log
@fix some cause of bad TEXTREL on i386 and amd64
- global function calls in .init sections (diff makes them via PLT)
- calls to global functions in aes-586.S (made static or local)
- global variable accesses in rc4-x86_64.S (now made via GOT)
from djm@@large; ok miod@@
@
text
@@


1.12
log
@resolve conflicts
@
text
@d348 1
a348 1
		{ push(@@out,"#include <machine/asm.h>\n"); return; }
d358 1
a358 1
	local($func)=@@_;
d364 5
a368 1
		{ push (@@out, "\nENTRY($func)\n"); goto skip; }
d424 38
d519 2
d557 1
a557 1
	if (!defined($com_start) or $main'elf)
d778 3
a780 1
	call	$under$f
@


1.11
log
@import i386 AES asm code from openssl.org; ok and help with testing djm@@
@
text
@d3 1
a3 1
package x86unix;
d10 3
a12 2
$under=($main'aout)?"_":"";
$com_start=($main'sol)?"/":"#";
d61 18
d125 5
d173 1
d180 1
d202 2
a203 2
sub main'pushf	{ &out0("pushf"); $stack+=4; }
sub main'popf	{ &out0("popf"); $stack-=4; }
d205 6
a210 1
sub main'call	{ &out1("call",($_[0]=~/^\.L/?'':$under).$_[0]); }
d213 6
a218 1
sub main'test   { &out2("testl",@@_); }
d220 24
a243 1
sub main'neg    { &out1("negl",@@_); }
a351 2
	.version	"01.01"
gcc2_compiled.:
d368 1
a368 2
	.align $align
.globl $func
d372 7
a378 4
		{ $tmp=push(@@out,"\tTYPE($func,\@@function)\n"); }
	elsif ($main'gaswin)
		{ $tmp=push(@@out,"\t.def\t$func;\t.scl\t2;\t.type\t32;\t.endef\n"); }
	else	{ $tmp=push(@@out,"\t.type\t$func,\@@function\n"); }
d404 1
a404 2
	.align $align
.globl $func
d408 7
a414 4
		{ push(@@out,"\tTYPE($func,\@@function)\n"); }
	elsif ($main'gaswin)
		{ $tmp=push(@@out,"\t.def\t$func;\t.scl\t2;\t.type\t32;\t.endef\n"); }
	else	{ push(@@out,"\t.type	$func,\@@function\n"); }
d432 1
a432 1
.L_${func}_end:
d437 4
a440 4
		{ push(@@out,"\tSIZE($func,.L_${func}_end-$func)\n"); }
	elsif ($main'gaswin)
                { $tmp=push(@@out,"\t.align 4\n"); }
	else	{ push(@@out,"\t.size\t$func,.L_${func}_end-$func\n"); }
d466 1
a466 1
	push(@@out,".L_${func}_end:\n");
d468 5
a472 5
		{ push(@@out,"\tSIZE($func,.L_${func}_end-$func)\n"); }
        elsif ($main'gaswin)
                { push(@@out,"\t.align 4\n"); }
	else	{ push(@@out,"\t.size\t$func,.L_${func}_end-$func\n"); }
	push(@@out,".ident	\"desasm.pl\"\n");
d513 2
a514 1
	if (!$main'openbsd && $main'elf)
d516 1
a516 2
		{	# so we just skip comments...
		push(@@out,"\n");
d529 4
a532 4
        {
        $label{$_[0]}="${under}${_[0]}" if (!defined($label{$_[0]}));
        push(@@out,".globl\t$label{$_[0]}\n");
        }
d538 1
a538 1
		$label{$_[0]}=".${label}${_[0]}";
d548 1
a548 1
		$label{$_[0]}=".${label}${_[0]}";
d551 11
a561 4
	if ($main'openbsd)
		{ push(@@out,"_ALIGN_TEXT\n") if ($_[1] != 0); }
	else
		{ push(@@out,".align $align\n") if ($_[1] != 0); }
d567 10
d585 5
d595 15
a688 1
	.align	8
a710 1
		push(@@out,"\t.align\t8\n");
d714 1
a714 1
		&main'add($dst,"\$$under"."_GLOBAL_OFFSET_TABLE_+[.-".
d716 1
a716 1
		&main'mov($dst,&main'DWP($sym."\@@GOT",$dst));
d725 38
@


1.10
log
@resolve conflicts
@
text
@d182 1
d184 1
d467 6
d509 1
a509 1
	push(@@out,"\t.long $_[0]\n");
@


1.9
log
@use bn_asm_vax.S (from netbsd); test + ok by miod
use asm code for i386, except for the CBC code, because
it is not clean PIC code.
add <machime/asm.h> support to x86unix.pl
tested by: nick (on 30386), henning, djm, tedu, jmc and more;
no shlib minor crank necessary, only internal symbols changed.
@
text
@d146 1
a146 1
sub main'add	{ &out2("addl",@@_); }
d151 1
a151 1
sub main'exch	{ &out2("xchg",@@_); }
d173 1
a173 1
sub main'inc	{ &out1("incl",@@_); }
d182 1
@


1.8
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d18 6
d285 3
d303 3
d318 1
d337 3
d352 1
d449 2
a450 1
	if ($main'elf)	# GNU and SVR4 as'es use different comment delimiters,
d481 4
a484 1
	push(@@out,".align $align\n") if ($_[1] != 0);
d592 10
@


1.7
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d159 2
d162 1
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d90 1
a90 1
		if($idx ne "")
d95 1
a95 1
	else
d170 1
a170 1
sub main'call	{ &out1("call",$under.$_[0]); }
d348 1
a348 1
.${func}_end:
d353 1
a353 1
		{ push(@@out,"\tSIZE($func,.${func}_end-$func)\n"); }
d356 1
a356 1
	else	{ push(@@out,"\t.size\t$func,.${func}_end-$func\n"); }
d429 5
d550 36
@


1.5
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@d6 2
d167 2
d351 1
d461 6
d472 72
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d82 1
a82 1
	$addr =~ s/(^|[+ \t])([A-Za-z_]+)($|[+ \t])/$1$under$2$3/;
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d295 2
d325 2
d349 2
d380 2
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d371 1
a371 1
	push(@@out,".${func}_end:\n");
d373 2
a374 2
		{ push(@@out,"\tSIZE($func,.${func}_end-$func)\n"); }
	else	{ push(@@out,"\t.size\t$func,.${func}_end-$func\n"); }
@


1.1
log
@Initial revision
@
text
@d1 1
a1 7
#!/usr/bin/perl

# Because the bswapl instruction is not supported for old assembers
# (it was a new instruction for the 486), I've added .byte xxxx code
# to put it in.
# eric 24-Apr-1998
#
d87 6
a92 1
		{ $ret.="($reg1,$reg2,$idx)"; }
d103 10
a164 1
sub main'bswap	{ &out1("bswapl",@@_); }
d169 16
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d1 7
a7 1
#!/usr/local/bin/perl
a11 2
$const="";
$constl=0;
d88 1
a88 1
	$addr =~ s/(^|[+ \t])([A-Za-z_]+[A-Za-z0-9_]+)($|[+ \t])/$1$under$2$3/;
d93 1
a93 6
		{
		if($idx ne "")
		    { $ret.="($reg1,$reg2,$idx)"; }
		else
		    { $ret.="($reg1,$reg2)"; }
	        }
a103 10
sub main'BC
	{
	return @@_;
	}

sub main'DWC
	{
	return @@_;
	}

d156 1
a156 2
sub main'pushf	{ &out0("pushf"); $stack+=4; }
sub main'popf	{ &out0("popf"); $stack-=4; }
a161 16
# The bswapl instruction is new for the 486. Emulate if i386.
sub main'bswap
	{
	if ($main'i386)
		{
		&main'comment("bswapl @@_");
		&main'exch(main'HB(@@_),main'LB(@@_));
		&main'rotr(@@_,16);
		&main'exch(main'HB(@@_),main'LB(@@_));
		}
	else
		{
		&out1("bswapl",@@_);
		}
	}

a270 2
	elsif ($main'gaswin)
		{ $tmp=push(@@out,"\t.def\t$func;\t.scl\t2;\t.type\t32;\t.endef\n"); }
a298 2
	elsif ($main'gaswin)
		{ $tmp=push(@@out,"\t.def\t$func;\t.scl\t2;\t.type\t32;\t.endef\n"); }
a318 1

a320 2
	elsif ($main'gaswin)
                { $tmp=push(@@out,"\t.align 4\n"); }
d347 1
a347 1
	push(@@out,".L_${func}_end:\n");
d349 2
a350 4
		{ push(@@out,"\tSIZE($func,.L_${func}_end-$func)\n"); }
        elsif ($main'gaswin)
                { push(@@out,"\t.align 4\n"); }
	else	{ push(@@out,"\t.size\t$func,.L_${func}_end-$func\n"); }
a423 6
	if ($const ne "")
		{
		push(@@out,".section .rodata\n");
		push(@@out,$const);
		$const="";
		}
a428 72
	}

# debug output functions: puts, putx, printf

sub main'puts
	{
	&pushvars();
	&main'push('$Lstring' . ++$constl);
	&main'call('puts');
	$stack-=4;
	&main'add("esp",4);
	&popvars();

	$const .= "Lstring$constl:\n\t.string \"@@_[0]\"\n";
	}

sub main'putx
	{
	&pushvars();
	&main'push($_[0]);
	&main'push('$Lstring' . ++$constl);
	&main'call('printf');
	&main'add("esp",8);
	$stack-=8;
	&popvars();

	$const .= "Lstring$constl:\n\t.string \"\%X\"\n";
	}

sub main'printf
	{
	$ostack = $stack;
	&pushvars();
	for ($i = @@_ - 1; $i >= 0; $i--)
		{
		if ($i == 0) # change this to support %s format strings
			{
			&main'push('$Lstring' . ++$constl);
			$const .= "Lstring$constl:\n\t.string \"@@_[$i]\"\n";
			}
		else
			{
			if ($_[$i] =~ /([0-9]*)\(%esp\)/)
				{
				&main'push(($1 + $stack - $ostack) . '(%esp)');
				}
			else
				{
				&main'push($_[$i]);
				}
			}
		}
	&main'call('printf');
	$stack-=4*@@_;
	&main'add("esp",4*@@_);
	&popvars();
	}

sub pushvars
	{
	&main'pushf();
	&main'push("edx");
	&main'push("ecx");
	&main'push("eax");
	}

sub popvars
	{
	&main'pop("eax");
	&main'pop("ecx");
	&main'pop("edx");
	&main'popf();
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d90 1
a90 1
		if($idx ne "" && $idx != 0)
d95 1
a95 1
	elsif ($reg1 ne "")
d170 1
a170 1
sub main'call	{ &out1("call",($_[0]=~/^\.L/?'':$under).$_[0]); }
d348 1
a348 1
.L_${func}_end:
d353 1
a353 1
		{ push(@@out,"\tSIZE($func,.L_${func}_end-$func)\n"); }
d356 1
a356 1
	else	{ push(@@out,"\t.size\t$func,.L_${func}_end-$func\n"); }
a428 5
	if ($main'elf)	# GNU and SVR4 as'es use different comment delimiters,
		{	# so we just skip comments...
		push(@@out,"\n");
		return;
		}
a544 36

sub main'picmeup
	{
	local($dst,$sym)=@@_;
	if ($main'cpp)
		{
		local($tmp)=<<___;
#if (defined(ELF) || defined(SOL)) && defined(PIC)
	.align	8
	call	1f
1:	popl	$regs{$dst}
	addl	\$_GLOBAL_OFFSET_TABLE_+[.-1b],$regs{$dst}
	movl	$sym\@@GOT($regs{$dst}),$regs{$dst}
#else
	leal	$sym,$regs{$dst}
#endif
___
		push(@@out,$tmp);
		}
	elsif ($main'pic && ($main'elf || $main'aout))
		{
		push(@@out,"\t.align\t8\n");
		&main'call(&main'label("PIC_me_up"));
		&main'set_label("PIC_me_up");
		&main'blindpop($dst);
		&main'add($dst,"\$$under"."_GLOBAL_OFFSET_TABLE_+[.-".
				&main'label("PIC_me_up") . "]");
		&main'mov($dst,&main'DWP($sym."\@@GOT",$dst));
		}
	else
		{
		&main'lea($dst,&main'DWP($sym));
		}
	}

sub main'blindpop { &out1("popl",@@_); }
@


1.1.1.4
log
@import 0.9.7c
@
text
@a158 2
sub main'ja	{ &out1("ja",@@_); }
sub main'jae	{ &out1("jae",@@_); }
a159 1
sub main'jbe	{ &out1("jbe",@@_); }
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d140 1
a140 1
sub main'add	{ &out2($_[0]=~/%[a-d][lh]/?"addb":"addl",@@_); }
d145 1
a145 1
sub main'exch	{ &out2($_[0]=~/%[a-d][lh]/?"xchgb":"xchgl",@@_); }
d167 1
a167 1
sub main'inc	{ &out1($_[0]=~/%[a-d][hl]/?"incb":"incl",@@_); }
a175 1
sub main'movz	{ &out2("movzbl",@@_); }
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@d3 1
a3 1
package x86unix;	# GAS actually...
d10 2
a11 3
$under=($main'aout or $main'coff)?"_":"";
$dot=($main'aout)?"":".";
$com_start="#" if ($main'aout or $main'coff);
a53 18

	'mm0',	'%mm0',
	'mm1',	'%mm1',
	'mm2',	'%mm2',
	'mm3',	'%mm3',
	'mm4',	'%mm4',
	'mm5',	'%mm5',
	'mm6',	'%mm6',
	'mm7',	'%mm7',

	'xmm0',	'%xmm0',
	'xmm1',	'%xmm1',
	'xmm2',	'%xmm2',
	'xmm3',	'%xmm3',
	'xmm4',	'%xmm4',
	'xmm5',	'%xmm5',
	'xmm6',	'%xmm6',
	'xmm7',	'%xmm7',
a99 5
sub main'QWP
	{
	return(&main'DWP(@@_));
	}

a142 1
sub main'sbb	{ &out2("sbbl",@@_); }
a148 1
sub main'imul	{ &out2("imull",@@_); }
d170 2
a171 2
sub main'pushf	{ &out0("pushfl"); $stack+=4; }
sub main'popf	{ &out0("popfl"); $stack-=4; }
d173 1
a173 6
sub main'call	{	my $pre=$under;
			foreach $i (%label)
			{ if ($label{$i} eq $_[0]) { $pre=''; last; } }
			&out1("call",$pre.$_[0]);
		}
sub main'call_ptr { &out1p("call",@@_); }
a175 6
sub main'test	{ &out2("testl",@@_); }
sub main'bt	{ &out2("btl",@@_); }
sub main'leave	{ &out0("leave"); }
sub main'cpuid	{ &out0(".byte\t0x0f,0xa2"); }
sub main'rdtsc	{ &out0(".byte\t0x0f,0x31"); }
sub main'halt	{ &out0("hlt"); }
a176 24
sub main'neg	{ &out1("negl",@@_); }
sub main'cld	{ &out0("cld"); }

# SSE2
sub main'emms	{ &out0("emms"); }
sub main'movd	{ &out2("movd",@@_); }
sub main'movdqu	{ &out2("movdqu",@@_); }
sub main'movdqa	{ &out2("movdqa",@@_); }
sub main'movdq2q{ &out2("movdq2q",@@_); }
sub main'movq2dq{ &out2("movq2dq",@@_); }
sub main'paddq	{ &out2("paddq",@@_); }
sub main'pmuludq{ &out2("pmuludq",@@_); }
sub main'psrlq	{ &out2("psrlq",@@_); }
sub main'psllq	{ &out2("psllq",@@_); }
sub main'pxor	{ &out2("pxor",@@_); }
sub main'por	{ &out2("por",@@_); }
sub main'pand	{ &out2("pand",@@_); }
sub main'movq	{
	local($p1,$p2,$optimize)=@@_;
	if ($optimize && $p1=~/^mm[0-7]$/ && $p2=~/^mm[0-7]$/)
		# movq between mmx registers can sink Intel CPUs
		{	push(@@out,"\tpshufw\t\$0xe4,%$p2,%$p1\n");	}
	else	{	&out2("movq",@@_);				}
	}
d282 2
d297 2
a298 1
.globl	$func
d302 4
a305 7
		{ $tmp=push(@@out,"TYPE($func,\@@function)\n"); }
	elsif ($main'coff)
		{ $tmp=push(@@out,".def\t$func;\t.scl\t2;\t.type\t32;\t.endef\n"); }
	elsif ($main'aout and !$main'pic)
		{ }
	else	{ $tmp=push(@@out,".type\t$func,\@@function\n"); }
	push(@@out,".align\t$align\n");
d327 2
a328 1
.globl	$func
d332 4
a335 7
		{ push(@@out,"TYPE($func,\@@function)\n"); }
	elsif ($main'coff)
		{ $tmp=push(@@out,".def\t$func;\t.scl\t2;\t.type\t32;\t.endef\n"); }
	elsif ($main'aout and !$main'pic)
		{ }
	else	{ push(@@out,".type	$func,\@@function\n"); }
	push(@@out,".align\t$align\n");
d352 1
a352 1
${dot}L_${func}_end:
d357 4
a360 4
		{ push(@@out,"SIZE($func,${dot}L_${func}_end-$func)\n"); }
	elsif ($main'coff or $main'aout)
                { }
	else	{ push(@@out,".size\t$func,${dot}L_${func}_end-$func\n"); }
d386 1
a386 1
	push(@@out,"${dot}L_${func}_end:\n");
d388 5
a392 5
		{ push(@@out,"SIZE($func,${dot}L_${func}_end-$func)\n"); }
        elsif ($main'coff or $main'aout)
                { }
	else	{ push(@@out,".size\t$func,${dot}L_${func}_end-$func\n"); }
	push(@@out,".ident	\"$func\"\n");
d433 3
a435 4
	if (!defined($com_start) or $main'elf)
		{	# Regarding $main'elf above...
			# GNU and SVR4 as'es use different comment delimiters,
		push(@@out,"\n");	# so we just skip ELF comments...
a446 6
sub main'public_label
	{
	$label{$_[0]}="${under}${_[0]}"	if (!defined($label{$_[0]}));
	push(@@out,".globl\t$label{$_[0]}\n");
	}

d451 1
a451 1
		$label{$_[0]}="${dot}${label}${_[0]}";
d461 1
a461 1
		$label{$_[0]}="${dot}${label}${_[0]}";
d464 1
a464 5
	if ($_[1]!=0)
		{
		if ($_[1]>1)	{ main'align($_[1]);		}
		else		{ push(@@out,".align $align\n");	}
		}
a469 10
	# try to detect if SSE2 or MMX extensions were used on ELF platform...
	if ($main'elf && grep {/\b%[x]*mm[0-7]\b|OPENSSL_ia32cap_P\b/i} @@out) {
		local($tmp);

		push (@@out,"\n.section\t.bss\n");
		push (@@out,".comm\t${under}OPENSSL_ia32cap_P,4,4\n");

		return;
	}

a477 5
sub main'data_byte
	{
	push(@@out,"\t.byte\t".join(',',@@_)."\n");
	}

d480 1
a480 12
	push(@@out,"\t.long\t".join(',',@@_)."\n");
	}

sub main'align
	{
	my $val=$_[0],$p2,$i;
	if ($main'aout) {
		for ($p2=0;$val!=0;$val>>=1) { $p2++; }
		$val=$p2-1;
		$val.=",0x90";
	}
	push(@@out,".align\t$val\n");
d562 1
d575 1
d579 1
a579 1
		&main'add($dst,"\$${under}_GLOBAL_OFFSET_TABLE_+[.-".
d581 1
a581 1
		&main'mov($dst,&main'DWP($under.$sym."\@@GOT",$dst));
a589 38

sub main'initseg
	{
	local($f)=@@_;
	local($tmp);
	if ($main'elf)
		{
		$tmp=<<___;
.section	.init
	call	$under$f
	jmp	.Linitalign
.align	$align
.Linitalign:
___
		}
	elsif ($main'coff)
		{
		$tmp=<<___;	# applies to both Cygwin and Mingw
.section	.ctors
.long	$under$f
___
		}
	elsif ($main'aout)
		{
		local($ctor)="${under}_GLOBAL_\$I\$$f";
		$tmp=".text\n";
		$tmp.=".type	$ctor,\@@function\n" if ($main'pic);
		$tmp.=<<___;	# OpenBSD way...
.globl	$ctor
.align	2
$ctor:
	jmp	$under$f
___
		}
	push(@@out,$tmp) if ($tmp);
	}

1;
@


