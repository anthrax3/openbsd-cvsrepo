head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.8
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.4
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	butholakala:1.9
	openssl_1_0_1_g:1.1.1.5
	OPENBSD_5_5:1.9.0.16
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.12
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	openssl_1_0_1_c:1.1.1.5
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	openssl_1_0_0_f:1.1.1.5
	openssl_1_0_0_e:1.1.1.5
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	openssh_1_0_0_a:1.1.1.5
	OPENBSD_4_8:1.8.0.8
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	openssl_0_9_8_k:1.1.1.4
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	openssl_0_9_8_j:1.1.1.4
	openssl_0_9_8_h:1.1.1.3
	pre_openssl_0_9_8h:1.6
	OPENBSD_4_4:1.6.0.20
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.18
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.16
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.14
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.12
	OPENBSD_4_0_BASE:1.6
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENSSL_0_9_7G:1.1.1.2
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENSSL_0_9_7B:1.1.1.1
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.20
date	2015.02.10.11.22.21;	author jsing;	state Exp;
branches;
next	1.19;
commitid	LaAI4ax0sm4T2bQg;

1.19
date	2014.12.06.19.26.37;	author doug;	state Exp;
branches;
next	1.18;
commitid	9GO7rmvzRwFf0a5J;

1.18
date	2014.11.18.03.28.05;	author tedu;	state Exp;
branches;
next	1.17;
commitid	UtItdNUXNaRhKkyD;

1.17
date	2014.10.16.03.19.02;	author beck;	state Exp;
branches;
next	1.16;
commitid	id4pE5GZpJTmZzW6;

1.16
date	2014.09.28.10.52.59;	author miod;	state Exp;
branches;
next	1.15;
commitid	p4GF1jbqlnBaG4FP;

1.15
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.14;
commitid	yQEL1wOWIearrW15;

1.14
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	mJUVYpkFBZ0Zv2bG;

1.13
date	2014.04.20.16.15.01;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.20.16.10.10;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.18.01.59.00;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.52;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.17;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.01.19.51.17;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.58.14;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.15.06.18.46;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.12.11;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.00;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.11.11.21.17.58;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.47;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.01.09.12.14.00;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.11;	author djm;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Remove more IMPLEMENT_STACK_OF noops that have been hiding for the last
15 years.
@
text
@/* $OpenBSD: x509_trs.c,v 1.19 2014/12/06 19:26:37 doug Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 1999.
 */
/* ====================================================================
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <string.h>

#include <openssl/err.h>
#include <openssl/x509v3.h>

static int tr_cmp(const X509_TRUST * const *a, const X509_TRUST * const *b);
static void trtable_free(X509_TRUST *p);

static int trust_1oidany(X509_TRUST *trust, X509 *x, int flags);
static int trust_1oid(X509_TRUST *trust, X509 *x, int flags);
static int trust_compat(X509_TRUST *trust, X509 *x, int flags);

static int obj_trust(int id, X509 *x, int flags);
static int (*default_trust)(int id, X509 *x, int flags) = obj_trust;

/* WARNING: the following table should be kept in order of trust
 * and without any gaps so we can just subtract the minimum trust
 * value to get an index into the table
 */

static X509_TRUST trstandard[] = {
	{X509_TRUST_COMPAT, 0, trust_compat, "compatible", 0, NULL},
	{X509_TRUST_SSL_CLIENT, 0, trust_1oidany, "SSL Client", NID_client_auth, NULL},
	{X509_TRUST_SSL_SERVER, 0, trust_1oidany, "SSL Server", NID_server_auth, NULL},
	{X509_TRUST_EMAIL, 0, trust_1oidany, "S/MIME email", NID_email_protect, NULL},
	{X509_TRUST_OBJECT_SIGN, 0, trust_1oidany, "Object Signer", NID_code_sign, NULL},
	{X509_TRUST_OCSP_SIGN, 0, trust_1oid, "OCSP responder", NID_OCSP_sign, NULL},
	{X509_TRUST_OCSP_REQUEST, 0, trust_1oid, "OCSP request", NID_ad_OCSP, NULL},
	{X509_TRUST_TSA, 0, trust_1oidany, "TSA server", NID_time_stamp, NULL}
};

#define X509_TRUST_COUNT	(sizeof(trstandard)/sizeof(X509_TRUST))

static STACK_OF(X509_TRUST) *trtable = NULL;

static int
tr_cmp(const X509_TRUST * const *a, const X509_TRUST * const *b)
{
	return (*a)->trust - (*b)->trust;
}

int
(*X509_TRUST_set_default(int (*trust)(int , X509 *, int)))(int, X509 *, int)
{
	int (*oldtrust)(int , X509 *, int);

	oldtrust = default_trust;
	default_trust = trust;
	return oldtrust;
}

int
X509_check_trust(X509 *x, int id, int flags)
{
	X509_TRUST *pt;
	int idx;

	if (id == -1)
		return 1;
	idx = X509_TRUST_get_by_id(id);
	if (idx == -1)
		return default_trust(id, x, flags);
	pt = X509_TRUST_get0(idx);
	return pt->check_trust(pt, x, flags);
}

int
X509_TRUST_get_count(void)
{
	if (!trtable)
		return X509_TRUST_COUNT;
	return sk_X509_TRUST_num(trtable) + X509_TRUST_COUNT;
}

X509_TRUST *
X509_TRUST_get0(int idx)
{
	if (idx < 0)
		return NULL;
	if (idx < (int)X509_TRUST_COUNT)
		return trstandard + idx;
	return sk_X509_TRUST_value(trtable, idx - X509_TRUST_COUNT);
}

int
X509_TRUST_get_by_id(int id)
{
	X509_TRUST tmp;
	int idx;

	if ((id >= X509_TRUST_MIN) && (id <= X509_TRUST_MAX))
		return id - X509_TRUST_MIN;
	tmp.trust = id;
	if (!trtable)
		return -1;
	idx = sk_X509_TRUST_find(trtable, &tmp);
	if (idx == -1)
		return -1;
	return idx + X509_TRUST_COUNT;
}

int
X509_TRUST_set(int *t, int trust)
{
	if (X509_TRUST_get_by_id(trust) == -1) {
		X509err(X509_F_X509_TRUST_SET, X509_R_INVALID_TRUST);
		return 0;
	}
	*t = trust;
	return 1;
}

int
X509_TRUST_add(int id, int flags, int (*ck)(X509_TRUST *, X509 *, int),
    char *name, int arg1, void *arg2)
{
	int idx;
	X509_TRUST *trtmp;
	char *name_dup;

	/* This is set according to what we change: application can't set it */
	flags &= ~X509_TRUST_DYNAMIC;
	/* This will always be set for application modified trust entries */
	flags |= X509_TRUST_DYNAMIC_NAME;
	/* Get existing entry if any */
	idx = X509_TRUST_get_by_id(id);
	/* Need a new entry */
	if (idx == -1) {
		if (!(trtmp = malloc(sizeof(X509_TRUST)))) {
			X509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);
			return 0;
		}
		trtmp->flags = X509_TRUST_DYNAMIC;
	} else {
		trtmp = X509_TRUST_get0(idx);
		if (trtmp == NULL) {
			X509err(X509_F_X509_TRUST_ADD, X509_R_INVALID_TRUST);
			return 0;
		}
	}

	if ((name_dup = strdup(name)) == NULL)
		goto err;

	/* free existing name if dynamic */
	if (trtmp->flags & X509_TRUST_DYNAMIC_NAME)
		free(trtmp->name);
	/* dup supplied name */
	trtmp->name = name_dup;
	/* Keep the dynamic flag of existing entry */
	trtmp->flags &= X509_TRUST_DYNAMIC;
	/* Set all other flags */
	trtmp->flags |= flags;

	trtmp->trust = id;
	trtmp->check_trust = ck;
	trtmp->arg1 = arg1;
	trtmp->arg2 = arg2;

	/* If it's a new entry, manage the dynamic table */
	if (idx == -1) {
		if (trtable == NULL &&
		    (trtable = sk_X509_TRUST_new(tr_cmp)) == NULL)
			goto err;
		if (sk_X509_TRUST_push(trtable, trtmp) == 0)
			goto err;
	}
	return 1;

err:
	free(name_dup);
	if (idx == -1)
		free(trtmp);
	X509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);
	return 0;
}

static void
trtable_free(X509_TRUST *p)
{
	if (!p)
		return;
	if (p->flags & X509_TRUST_DYNAMIC) {
		if (p->flags & X509_TRUST_DYNAMIC_NAME)
			free(p->name);
		free(p);
	}
}

void
X509_TRUST_cleanup(void)
{
	unsigned int i;

	for (i = 0; i < X509_TRUST_COUNT; i++)
		trtable_free(trstandard + i);
	sk_X509_TRUST_pop_free(trtable, trtable_free);
	trtable = NULL;
}

int
X509_TRUST_get_flags(X509_TRUST *xp)
{
	return xp->flags;
}

char *
X509_TRUST_get0_name(X509_TRUST *xp)
{
	return xp->name;
}

int
X509_TRUST_get_trust(X509_TRUST *xp)
{
	return xp->trust;
}

static int
trust_1oidany(X509_TRUST *trust, X509 *x, int flags)
{
	if (x->aux && (x->aux->trust || x->aux->reject))
		return obj_trust(trust->arg1, x, flags);
	/* we don't have any trust settings: for compatibility
	 * we return trusted if it is self signed
	 */
	return trust_compat(trust, x, flags);
}

static int
trust_1oid(X509_TRUST *trust, X509 *x, int flags)
{
	if (x->aux)
		return obj_trust(trust->arg1, x, flags);
	return X509_TRUST_UNTRUSTED;
}

static int
trust_compat(X509_TRUST *trust, X509 *x, int flags)
{
	X509_check_purpose(x, -1, 0);
	if (x->ex_flags & EXFLAG_SS)
		return X509_TRUST_TRUSTED;
	else
		return X509_TRUST_UNTRUSTED;
}

static int
obj_trust(int id, X509 *x, int flags)
{
	ASN1_OBJECT *obj;
	int i;
	X509_CERT_AUX *ax;

	ax = x->aux;
	if (!ax)
		return X509_TRUST_UNTRUSTED;
	if (ax->reject) {
		for (i = 0; i < sk_ASN1_OBJECT_num(ax->reject); i++) {
			obj = sk_ASN1_OBJECT_value(ax->reject, i);
			if (OBJ_obj2nid(obj) == id)
				return X509_TRUST_REJECTED;
		}
	}
	if (ax->trust) {
		for (i = 0; i < sk_ASN1_OBJECT_num(ax->trust); i++) {
			obj = sk_ASN1_OBJECT_value(ax->trust, i);
			if (OBJ_obj2nid(obj) == id)
				return X509_TRUST_TRUSTED;
		}
	}
	return X509_TRUST_UNTRUSTED;
}
@


1.19
log
@Avoid modifying input on failure in X509_(TRUST|PURPOSE)_add.

If X509_TRUST_add() or X509_PURPOSE_add() fail, they will leave the
object in an inconsistent state since the name is already freed.
This commit avoids changing the original name unless the *_add() call
will succeed.

Based on BoringSSL's commit: ab2815eaff6219ef57aedca2f7b1b72333c27fd0

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_trs.c,v 1.18 2014/11/18 03:28:05 tedu Exp $ */
a91 2

IMPLEMENT_STACK_OF(X509_TRUST)
@


1.18
log
@further BUF_strdup conversion: these places should be safe to rely on
the function argument not being NULL
@
text
@d1 1
a1 1
/* $OpenBSD: x509_trs.c,v 1.17 2014/10/16 03:19:02 beck Exp $ */
d180 1
d203 3
d210 1
a210 2
	if ((trtmp->name = strdup(name)) == NULL)
		goto err;
d232 2
a233 2
	if (idx == -1) {
		free(trtmp->name);
a234 1
	}
@


1.17
log
@Get rid of the last remaining BUF_strdup and BUF_strlcpy and friends, use
intrinsic functions everywhere, and wrap these functions in an
#ifndef LIBRESSL_INTERNAL to make sure we don't bring their use back.
@
text
@d1 1
a1 1
/* $OpenBSD: x509_trs.c,v 1.16 2014/09/28 10:52:59 miod Exp $ */
d206 1
a206 1
	if (name == NULL || (trtmp->name = strdup(name)) == NULL)
@


1.16
log
@X509_TRUST_add(): check X509_TRUST_get0() return value before dereferencing it,
for it may be NULL. Do not leak memory upon error.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_trs.c,v 1.15 2014/07/11 08:44:49 jsing Exp $ */
d60 1
d206 1
a206 1
	if ((trtmp->name = BUF_strdup(name)) == NULL)
@


1.15
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_trs.c,v 1.14 2014/06/12 15:49:31 deraadt Exp $ */
d193 1
a193 1
	} else
d195 5
d205 2
a206 4
	if (!(trtmp->name = BUF_strdup(name))) {
		X509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);
		return 0;
	}
d217 1
a217 1
	/* If its a new entry manage the dynamic table */
d219 5
a223 8
		if (!trtable && !(trtable = sk_X509_TRUST_new(tr_cmp))) {
			X509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);
			return 0;
		}
		if (!sk_X509_TRUST_push(trtable, trtmp)) {
			X509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);
			return 0;
		}
d226 8
@


1.14
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 2
a61 1
#include "cryptlib.h"
a62 1

@


1.13
log
@More KNF.
@
text
@d1 1
a1 1
/* x509_trs.c */
@


1.12
log
@KNF.
@
text
@d245 2
a246 2
	for(i = 0; i < X509_TRUST_COUNT; i++)
	    trtable_free(trstandard + i);
@


1.11
log
@blunt force knf
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d64 1
a64 2
static int tr_cmp(const X509_TRUST * const *a,
		const X509_TRUST * const *b);
d80 8
a87 8
{X509_TRUST_COMPAT, 0, trust_compat, "compatible", 0, NULL},
{X509_TRUST_SSL_CLIENT, 0, trust_1oidany, "SSL Client", NID_client_auth, NULL},
{X509_TRUST_SSL_SERVER, 0, trust_1oidany, "SSL Server", NID_server_auth, NULL},
{X509_TRUST_EMAIL, 0, trust_1oidany, "S/MIME email", NID_email_protect, NULL},
{X509_TRUST_OBJECT_SIGN, 0, trust_1oidany, "Object Signer", NID_code_sign, NULL},
{X509_TRUST_OCSP_SIGN, 0, trust_1oid, "OCSP responder", NID_OCSP_sign, NULL},
{X509_TRUST_OCSP_REQUEST, 0, trust_1oid, "OCSP request", NID_ad_OCSP, NULL},
{X509_TRUST_TSA, 0, trust_1oidany, "TSA server", NID_time_stamp, NULL}
d96 2
a97 2
static int tr_cmp(const X509_TRUST * const *a,
		const X509_TRUST * const *b)
d102 2
a103 1
int (*X509_TRUST_set_default(int (*trust)(int , X509 *, int)))(int, X509 *, int)
d106 1
d112 2
a113 2

int X509_check_trust(X509 *x, int id, int flags)
d117 3
a119 1
	if(id == -1) return 1;
d121 2
a122 1
	if(idx == -1) return default_trust(id, x, flags);
d127 2
a128 1
int X509_TRUST_get_count(void)
d130 2
a131 1
	if(!trtable) return X509_TRUST_COUNT;
d135 2
a136 1
X509_TRUST * X509_TRUST_get0(int idx)
d138 4
a141 2
	if(idx < 0) return NULL;
	if(idx < (int)X509_TRUST_COUNT) return trstandard + idx;
d145 2
a146 1
int X509_TRUST_get_by_id(int id)
d150 3
a152 2
	if((id >= X509_TRUST_MIN) && (id <= X509_TRUST_MAX))
				 return id - X509_TRUST_MIN;
d154 2
a155 1
	if(!trtable) return -1;
d157 2
a158 1
	if(idx == -1) return -1;
d162 2
a163 1
int X509_TRUST_set(int *t, int trust)
d165 1
a165 1
	if(X509_TRUST_get_by_id(trust) == -1) {
d173 3
a175 2
int X509_TRUST_add(int id, int flags, int (*ck)(X509_TRUST *, X509 *, int),
					char *name, int arg1, void *arg2)
d179 1
d187 3
a189 3
	if(idx == -1) {
		if(!(trtmp = malloc(sizeof(X509_TRUST)))) {
			X509err(X509_F_X509_TRUST_ADD,ERR_R_MALLOC_FAILURE);
d197 2
a198 1
	if(trtmp->flags & X509_TRUST_DYNAMIC_NAME) free(trtmp->name);
d200 2
a201 2
	if(!(trtmp->name = BUF_strdup(name))) {
		X509err(X509_F_X509_TRUST_ADD,ERR_R_MALLOC_FAILURE);
d215 3
a217 3
	if(idx == -1) {
		if(!trtable && !(trtable = sk_X509_TRUST_new(tr_cmp))) {
			X509err(X509_F_X509_TRUST_ADD,ERR_R_MALLOC_FAILURE);
d221 1
a221 1
			X509err(X509_F_X509_TRUST_ADD,ERR_R_MALLOC_FAILURE);
d228 2
a229 1
static void trtable_free(X509_TRUST *p)
d231 2
a232 1
	if(!p) return;
d240 2
a241 1
void X509_TRUST_cleanup(void)
d244 3
a246 1
	for(i = 0; i < X509_TRUST_COUNT; i++) trtable_free(trstandard + i);
d251 2
a252 1
int X509_TRUST_get_flags(X509_TRUST *xp)
d257 2
a258 1
char *X509_TRUST_get0_name(X509_TRUST *xp)
d263 2
a264 1
int X509_TRUST_get_trust(X509_TRUST *xp)
d269 2
a270 1
static int trust_1oidany(X509_TRUST *trust, X509 *x, int flags)
d272 1
a272 1
	if(x->aux && (x->aux->trust || x->aux->reject))
d280 2
a281 1
static int trust_1oid(X509_TRUST *trust, X509 *x, int flags)
d283 2
a284 1
	if(x->aux) return obj_trust(trust->arg1, x, flags);
d288 2
a289 1
static int trust_compat(X509_TRUST *trust, X509 *x, int flags)
d292 4
a295 2
	if(x->ex_flags & EXFLAG_SS) return X509_TRUST_TRUSTED;
	else return X509_TRUST_UNTRUSTED;
d298 2
a299 1
static int obj_trust(int id, X509 *x, int flags)
d304 1
d306 4
a309 3
	if(!ax) return X509_TRUST_UNTRUSTED;
	if(ax->reject) {
		for(i = 0; i < sk_ASN1_OBJECT_num(ax->reject); i++) {
d311 2
a312 1
			if(OBJ_obj2nid(obj) == id) return X509_TRUST_REJECTED;
d314 3
a316 3
	}	
	if(ax->trust) {
		for(i = 0; i < sk_ASN1_OBJECT_num(ax->trust); i++) {
d318 2
a319 1
			if(OBJ_obj2nid(obj) == id) return X509_TRUST_TRUSTED;
a323 1

@


1.10
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d177 2
a178 1
	} else trtmp = X509_TRUST_get0(idx);
d212 1
a212 1
	{
d214 1
a214 2
	if (p->flags & X509_TRUST_DYNAMIC) 
		{
a217 1
		}
d219 1
@


1.9
log
@resolve conflicts, fix local changes
@
text
@d172 1
a172 1
		if(!(trtmp = OPENSSL_malloc(sizeof(X509_TRUST)))) {
d179 2
a180 2
	/* OPENSSL_free existing name if dynamic */
	if(trtmp->flags & X509_TRUST_DYNAMIC_NAME) OPENSSL_free(trtmp->name);
d216 2
a217 2
			OPENSSL_free(p->name);
		OPENSSL_free(p);
@


1.8
log
@resolve conflicts
@
text
@d87 2
a88 1
{X509_TRUST_OCSP_REQUEST, 0, trust_1oid, "OCSP request", NID_ad_OCSP, NULL}
@


1.7
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.6
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d131 1
a131 1
	if(idx < X509_TRUST_COUNT) return trstandard + idx;
d222 1
a222 1
	int i;
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d85 1
@


1.4
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@d69 1
d83 1
a83 1
{X509_TRUST_SSL_SERVER, 0, trust_1oidany, "SSL Client", NID_server_auth, NULL},
d85 2
d103 4
a106 4
int (*oldtrust)(int , X509 *, int);
oldtrust = default_trust;
default_trust = trust;
return oldtrust;
d147 10
d250 6
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d231 2
a232 1
	if(x->aux) return obj_trust(trust->arg1, x, flags);
@


1.2
log
@OpenSSL 0.9.5a merge
@
text
@d64 2
a65 1
static int tr_cmp(X509_TRUST **a, X509_TRUST **b);
d92 2
a93 1
static int tr_cmp(X509_TRUST **a, X509_TRUST **b)
d157 1
a157 1
		if(!(trtmp = Malloc(sizeof(X509_TRUST)))) {
d164 2
a165 2
	/* Free existing name if dynamic */
	if(trtmp->flags & X509_TRUST_DYNAMIC_NAME) Free(trtmp->name);
d201 2
a202 2
			Free(p->name);
		Free(p);
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d68 1
a68 1
static int trust_any(X509_TRUST *trust, X509 *x, int flags);
d79 1
a79 1
{X509_TRUST_ANY, 0, trust_any, "Any", 0, NULL},
d110 2
a111 2
	if(!(idx = X509_TRUST_get_by_id(id)))
			return default_trust(id, x, flags);
d233 5
a264 4
static int trust_any(X509_TRUST *trust, X509 *x, int flags)
{
	return X509_TRUST_TRUSTED;
}
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d64 1
a64 2
static int tr_cmp(const X509_TRUST * const *a,
		const X509_TRUST * const *b);
d68 1
a68 2
static int trust_1oid(X509_TRUST *trust, X509 *x, int flags);
static int trust_compat(X509_TRUST *trust, X509 *x, int flags);
d79 1
a79 1
{X509_TRUST_COMPAT, 0, trust_compat, "compatible", 0, NULL},
d81 1
a81 1
{X509_TRUST_SSL_SERVER, 0, trust_1oidany, "SSL Server", NID_server_auth, NULL},
a82 2
{X509_TRUST_OCSP_SIGN, 0, trust_1oid, "OCSP responder", NID_OCSP_sign, NULL},
{X509_TRUST_OCSP_REQUEST, 0, trust_1oid, "OCSP request", NID_ad_OCSP, NULL}
d91 1
a91 2
static int tr_cmp(const X509_TRUST * const *a,
		const X509_TRUST * const *b)
d98 4
a101 4
	int (*oldtrust)(int , X509 *, int);
	oldtrust = default_trust;
	default_trust = trust;
	return oldtrust;
d110 2
a111 2
	idx = X509_TRUST_get_by_id(id);
	if(idx == -1) return default_trust(id, x, flags);
a141 10
int X509_TRUST_set(int *t, int trust)
{
	if(X509_TRUST_get_by_id(trust) == -1) {
		X509err(X509_F_X509_TRUST_SET, X509_R_INVALID_TRUST);
		return 0;
	}
	*t = trust;
	return 1;
}

d155 1
a155 1
		if(!(trtmp = OPENSSL_malloc(sizeof(X509_TRUST)))) {
d162 2
a163 2
	/* OPENSSL_free existing name if dynamic */
	if(trtmp->flags & X509_TRUST_DYNAMIC_NAME) OPENSSL_free(trtmp->name);
d199 2
a200 2
			OPENSSL_free(p->name);
		OPENSSL_free(p);
d229 1
a229 2
	if(x->aux && (x->aux->trust || x->aux->reject))
		return obj_trust(trust->arg1, x, flags);
a232 11
	return trust_compat(trust, x, flags);
}

static int trust_1oid(X509_TRUST *trust, X509 *x, int flags)
{
	if(x->aux) return obj_trust(trust->arg1, x, flags);
	return X509_TRUST_UNTRUSTED;
}

static int trust_compat(X509_TRUST *trust, X509 *x, int flags)
{
d260 4
@


1.1.1.2
log
@import 0.9.7c
@
text
@a84 1
{X509_TRUST_OBJECT_SIGN, 0, trust_1oidany, "Object Signer", NID_code_sign, NULL},
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d131 1
a131 1
	if(idx < (int)X509_TRUST_COUNT) return trstandard + idx;
d222 1
a222 1
	unsigned int i;
@


1.1.1.4
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@d87 1
a87 2
{X509_TRUST_OCSP_REQUEST, 0, trust_1oid, "OCSP request", NID_ad_OCSP, NULL},
{X509_TRUST_TSA, 0, trust_1oidany, "TSA server", NID_time_stamp, NULL}
@


