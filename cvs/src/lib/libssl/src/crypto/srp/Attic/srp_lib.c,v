head	1.10;
access;
symbols
	butholakala:1.1.1.2
	openssl_1_0_1_g:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.8
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.4
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.2
	OPENBSD_5_3_BASE:1.1.1.1
	openssl_1_0_1_c:1.1.1.1
	openssl:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.07.28.17.57.18;	author tedu;	state dead;
branches;
next	1.9;
commitid	99MpI3E4JwwZj7Kn;

1.9
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.8;
commitid	yQEL1wOWIearrW15;

1.8
date	2014.07.10.22.45.58;	author jsing;	state Exp;
branches;
next	1.7;
commitid	nzndm3zqPmFurSaK;

1.7
date	2014.07.10.20.22.00;	author miod;	state Exp;
branches;
next	1.6;
commitid	eyLesJR24Yl7st0U;

1.6
date	2014.07.10.20.18.51;	author miod;	state Exp;
branches;
next	1.5;
commitid	XoQXmq1KvjP3sD0I;

1.5
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	mJUVYpkFBZ0Zv2bG;

1.4
date	2014.05.29.21.07.43;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.28.21.14.50;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2012.10.13.21.23.43;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.10.13.21.23.43;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.04.13.15.16.35;	author miod;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Remove SRP code. It contains a bug (this should not surprise anyone), but
the details are under embargo. The original plan was to wait for the
embargo to lift, but we've been waiting for quite some time, and there's no
indication of when or even if it will end. No sense in dragging this out
any longer.

The SRP code has never been enabled in OpenBSD, though I understand it is
in use by some other people. However, in light of this and other issues,
we're officially saying SRP is outside the scope of libressl. (For now.)
@
text
@/* $OpenBSD: srp_lib.c,v 1.9 2014/07/11 08:44:49 jsing Exp $ */
/* Written by Christophe Renou (christophe.renou@@edelweb.fr) with 
 * the precious help of Peter Sylvester (peter.sylvester@@edelweb.fr) 
 * for the EdelKey project and contributed to the OpenSSL project 2004.
 */
/* ====================================================================
 * Copyright (c) 2004 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <openssl/opensslconf.h>

#ifndef OPENSSL_NO_SRP

#include <openssl/evp.h>
#include <openssl/srp.h>

#include "srp_lcl.h"

#if (BN_BYTES == 8)
# if defined(_LP64)
#  define bn_pack4(a1,a2,a3,a4) ((a1##UL<<48)|(a2##UL<<32)|(a3##UL<<16)|a4##UL)
# else
#  define bn_pack4(a1,a2,a3,a4) ((a1##ULL<<48)|(a2##ULL<<32)|(a3##ULL<<16)|a4##ULL)
# endif
#elif (BN_BYTES == 4)
# define bn_pack4(a1,a2,a3,a4)  ((a3##UL<<16)|a4##UL), ((a1##UL<<16)|a2##UL)
#else
# error "unsupported BN_BYTES"
#endif


#include "srp_grps.h"

static BIGNUM *srp_Calc_k(BIGNUM *N, BIGNUM *g)
	{
	/* k = SHA1(N | PAD(g)) -- tls-srp draft 8 */

	unsigned char digest[SHA_DIGEST_LENGTH];
	unsigned char *tmp;
	EVP_MD_CTX ctxt;
	BIGNUM *ret = NULL;
	int longg;
	int longN = BN_num_bytes(N);

	if ((tmp = malloc(longN)) == NULL)
		return NULL;
	BN_bn2bin(N,tmp);

	EVP_MD_CTX_init(&ctxt);
	if (!EVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL))
		goto err;
	if (!EVP_DigestUpdate(&ctxt, tmp, longN))
		goto err;

	memset(tmp, 0, longN);
	longg = BN_bn2bin(g,tmp);
        /* use the zeros behind to pad on left */
	if (!EVP_DigestUpdate(&ctxt, tmp + longg, longN-longg))
		goto err;
	if (!EVP_DigestUpdate(&ctxt, tmp, longg))
		goto err;

	if (!EVP_DigestFinal_ex(&ctxt, digest, NULL))
		goto err;
	ret = BN_bin2bn(digest, sizeof(digest), NULL);	
err:
	EVP_MD_CTX_cleanup(&ctxt);
	free(tmp);
	return ret;
	}

BIGNUM *SRP_Calc_u(BIGNUM *A, BIGNUM *B, BIGNUM *N)
	{
	/* k = SHA1(PAD(A) || PAD(B) ) -- tls-srp draft 8 */

	BIGNUM *u;	
	unsigned char cu[SHA_DIGEST_LENGTH];
	unsigned char *cAB;
	EVP_MD_CTX ctxt;
	int longN;  
	if ((A == NULL) ||(B == NULL) || (N == NULL))
		return NULL;

	longN= BN_num_bytes(N);

	if ((cAB = reallocarray(NULL, 2, longN)) == NULL) 
		return NULL;

	memset(cAB, 0, longN);

	EVP_MD_CTX_init(&ctxt);
	EVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);
	EVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(A,cAB+longN), longN);
	EVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(B,cAB+longN), longN);
	free(cAB);
	EVP_DigestFinal_ex(&ctxt, cu, NULL);
	EVP_MD_CTX_cleanup(&ctxt);

	if (!(u = BN_bin2bn(cu, sizeof(cu), NULL)))
		return NULL;
	if (!BN_is_zero(u))
		return u;
	BN_free(u);
	return NULL;
}

BIGNUM *SRP_Calc_server_key(BIGNUM *A, BIGNUM *v, BIGNUM *u, BIGNUM *b, BIGNUM *N)
	{
	BIGNUM *tmp = NULL, *S = NULL;
	BN_CTX *bn_ctx; 
	
	if (u == NULL || A == NULL || v == NULL || b == NULL || N == NULL)
		return NULL; 

	if ((bn_ctx = BN_CTX_new()) == NULL ||
		(tmp = BN_new()) == NULL ||
		(S = BN_new()) == NULL )
		goto err;

	/* S = (A*v**u) ** b */ 

	if (!BN_mod_exp(tmp,v,u,N,bn_ctx))
		goto err;
	if (!BN_mod_mul(tmp,A,tmp,N,bn_ctx))
		goto err;
	if (!BN_mod_exp(S,tmp,b,N,bn_ctx))
		goto err;
err:
	BN_CTX_free(bn_ctx);
	BN_clear_free(tmp);
	return S;
	}

BIGNUM *SRP_Calc_B(BIGNUM *b, BIGNUM *N, BIGNUM *g, BIGNUM *v)
	{
	BIGNUM  *kv = NULL, *gb = NULL;
	BIGNUM *B = NULL, *k = NULL;
	BN_CTX *bn_ctx;

	if (b == NULL || N == NULL || g == NULL || v == NULL ||
		(bn_ctx = BN_CTX_new()) == NULL)
		return NULL; 

	if ( (kv = BN_new()) == NULL ||
		(gb = BN_new()) == NULL ||
		(B = BN_new())== NULL)
		goto err;

	/* B = g**b + k*v */

	if (!BN_mod_exp(gb,g,b,N,bn_ctx) ||
	   !(k = srp_Calc_k(N,g)) ||
	   !BN_mod_mul(kv,v,k,N,bn_ctx) || 
	   !BN_mod_add(B,gb,kv,N,bn_ctx))
		{
		BN_free(B);
		B = NULL;
		}
err:
	BN_CTX_free(bn_ctx);
	BN_clear_free(kv);
	BN_clear_free(gb);
	BN_free(k); 
	return B;
	}

BIGNUM *SRP_Calc_x(BIGNUM *s, const char *user, const char *pass)
	{
	unsigned char dig[SHA_DIGEST_LENGTH];
	EVP_MD_CTX ctxt;
	unsigned char *cs;

	if ((s == NULL) ||
		(user == NULL) ||
		(pass == NULL))
		return NULL;

	if ((cs = malloc(BN_num_bytes(s))) == NULL)
		return NULL;

	EVP_MD_CTX_init(&ctxt);
	EVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);
	EVP_DigestUpdate(&ctxt, user, strlen(user));
	EVP_DigestUpdate(&ctxt, ":", 1);
	EVP_DigestUpdate(&ctxt, pass, strlen(pass));
	EVP_DigestFinal_ex(&ctxt, dig, NULL);

	EVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);
	BN_bn2bin(s,cs);
	EVP_DigestUpdate(&ctxt, cs, BN_num_bytes(s));
	free(cs);
	EVP_DigestUpdate(&ctxt, dig, sizeof(dig));
	EVP_DigestFinal_ex(&ctxt, dig, NULL);
	EVP_MD_CTX_cleanup(&ctxt);

	return BN_bin2bn(dig, sizeof(dig), NULL);
	}

BIGNUM *SRP_Calc_A(BIGNUM *a, BIGNUM *N, BIGNUM *g)
	{
	BN_CTX *bn_ctx; 
	BIGNUM * A = NULL;

	if (a == NULL || N == NULL || g == NULL ||
		(bn_ctx = BN_CTX_new()) == NULL) 
		return NULL;

	if ((A = BN_new()) != NULL &&
	   !BN_mod_exp(A,g,a,N,bn_ctx))
		{
		BN_free(A);
		A = NULL;
		}
	BN_CTX_free(bn_ctx);
	return A;
	}


BIGNUM *SRP_Calc_client_key(BIGNUM *N, BIGNUM *B, BIGNUM *g, BIGNUM *x, BIGNUM *a, BIGNUM *u)
	{
	BIGNUM *tmp = NULL, *tmp2 = NULL, *tmp3 = NULL , *k = NULL, *K = NULL;
	BIGNUM *ret = NULL;
	BN_CTX *bn_ctx;

	if (u == NULL || B == NULL || N == NULL || g == NULL || x == NULL || a == NULL ||
		(bn_ctx = BN_CTX_new()) == NULL)
		return NULL; 

	if ((tmp = BN_new()) == NULL ||
		(tmp2 = BN_new())== NULL ||
		(tmp3 = BN_new())== NULL ||
		(K = BN_new()) == NULL)
		goto err;
	
	if (!BN_mod_exp(tmp,g,x,N,bn_ctx))
		goto err;
	if (!(k = srp_Calc_k(N,g)))
		goto err;
	if (!BN_mod_mul(tmp2,tmp,k,N,bn_ctx))
		goto err;
	if (!BN_mod_sub(tmp,B,tmp2,N,bn_ctx))
		goto err;

	if (!BN_mod_mul(tmp3,u,x,N,bn_ctx))
		goto err;
	if (!BN_mod_add(tmp2,a,tmp3,N,bn_ctx))
		goto err;
	if (!BN_mod_exp(K,tmp,tmp2,N,bn_ctx))
		goto err;

	ret = K;
	K = NULL;

err :
	BN_CTX_free(bn_ctx);
	BN_clear_free(tmp);
	BN_clear_free(tmp2);
	BN_clear_free(tmp3);
	BN_free(k);
	BN_clear_free(K);
	return ret;	
	}

int SRP_Verify_B_mod_N(BIGNUM *B, BIGNUM *N)
	{
	BIGNUM *r;
	BN_CTX *bn_ctx; 
	int ret = 0;

	if (B == NULL || N == NULL ||
		(bn_ctx = BN_CTX_new()) == NULL)
		return 0;

	if ((r = BN_new()) == NULL)
		goto err;
	/* Checks if B % N == 0 */
	if (!BN_nnmod(r,B,N,bn_ctx))
		goto err;
	ret = !BN_is_zero(r);
err:
	BN_CTX_free(bn_ctx);
	BN_free(r);
	return ret;
	}

int SRP_Verify_A_mod_N(BIGNUM *A, BIGNUM *N)
	{
	/* Checks if A % N == 0 */
	return SRP_Verify_B_mod_N(A,N) ;
	}


/* Check if G and N are kwown parameters. 
   The values have been generated from the ietf-tls-srp draft version 8
*/
char *SRP_check_known_gN_param(BIGNUM *g, BIGNUM *N)
	{
	size_t i;
	if ((g == NULL) || (N == NULL))
		return 0;

	srp_bn_print(g);
	srp_bn_print(N);

	for(i = 0; i < KNOWN_GN_NUMBER; i++)
		{
		if (BN_cmp(knowngN[i].g, g) == 0 && BN_cmp(knowngN[i].N, N) == 0) 
			return knowngN[i].id;
		}
	return NULL;
	}

SRP_gN *SRP_get_default_gN(const char *id)
	{
	size_t i;

	if (id == NULL) 
		return knowngN;
	for(i = 0; i < KNOWN_GN_NUMBER; i++)
		{
		if (strcmp(knowngN[i].id, id)==0)
			return knowngN + i;
		}
	return NULL;
	}
#endif
@


1.9
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: srp_lib.c,v 1.8 2014/07/10 22:45:58 jsing Exp $ */
@


1.8
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: srp_lib.c,v 1.7 2014/07/10 20:22:00 miod Exp $ */
d63 4
a66 1
#include "cryptlib.h"
a67 2
#include <openssl/srp.h>
#include <openssl/evp.h>
@


1.7
log
@Make sure srp_Calc_k() digest operations are checked for error; from
Florian Zumbiehl (florz , florz . de) on tech@@
@
text
@d1 1
a1 1
/* $OpenBSD: srp_lib.c,v 1.6 2014/07/10 20:18:51 miod Exp $ */
d59 3
@


1.6
log
@Make sure SRP_Calc_client_key() returns NULL instead of a pristine BN_new()
upon error; from Florian Zumbiehl (florz , florz . de) on tech@@
@
text
@d1 1
a1 1
/* $OpenBSD: srp_lib.c,v 1.5 2014/06/12 15:49:30 deraadt Exp $ */
d87 2
a88 1
	int longg ;
d96 4
a99 2
	EVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);
	EVP_DigestUpdate(&ctxt, tmp, longN);
d104 10
a113 2
	EVP_DigestUpdate(&ctxt, tmp + longg, longN-longg);
	EVP_DigestUpdate(&ctxt, tmp, longg);
d115 1
a115 4

	EVP_DigestFinal_ex(&ctxt, digest, NULL);
	EVP_MD_CTX_cleanup(&ctxt);
	return BN_bin2bn(digest, sizeof(digest), NULL);	
@


1.5
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d92 1
a92 1
	BN_bn2bin(N,tmp) ;
d99 1
a99 1
	longg = BN_bn2bin(g,tmp) ;
d260 1
d289 3
d298 2
a299 1
	return K;	
@


1.4
log
@convert 53 malloc(a*b) to reallocarray(NULL, a, b).  that is 53
potential integer overflows easily changed into an allocation return
of NULL, with errno nicely set if need be.  checks for an allocations
returning NULL are commonplace, or if the object is dereferenced
(quite normal) will result in a nice fault which can be detected &
repaired properly.
ok tedu
@
text
@d1 1
a1 1
/* crypto/srp/srp_lib.c */
@


1.3
log
@Remove WIN32, WIN64 and MINGW32 tentacles.
Also check for _LP64 rather than __arch64__ (the former being more reliable
than __LP64__ or __arch64__) to tell 64-bit int platforms apart from 32-bit
int platforms.

Loosely based upon a diff from Martijn van Duren on tech@@
@
text
@d124 1
a124 1
	if ((cAB = malloc(2*longN)) == NULL) 
@


1.2
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d66 1
a66 3
# if (defined(_WIN32) || defined(_WIN64)) && !defined(__MINGW32__)
#  define bn_pack4(a1,a2,a3,a4) ((a1##UI64<<48)|(a2##UI64<<32)|(a3##UI64<<16)|a4##UI64)
# elif defined(__arch64__)
@


1.1
log
@Initial revision
@
text
@d66 11
a76 7
#define bn_pack4(a1,a2,a3,a4) 0x##a1##a2##a3##a4##ul
#endif
#if (BN_BYTES == 4)
#define bn_pack4(a1,a2,a3,a4)  0x##a3##a4##ul, 0x##a1##a2##ul
#endif
#if (BN_BYTES == 2)
#define bn_pack4(a1,a2,a3,a4) 0x##a4##u,0x##a3##u,0x##a2##u,0x##a1##u
d92 1
a92 1
	if ((tmp = OPENSSL_malloc(longN)) == NULL)
d105 1
a105 1
	OPENSSL_free(tmp);
d126 1
a126 1
	if ((cAB = OPENSSL_malloc(2*longN)) == NULL) 
d135 1
a135 1
	OPENSSL_free(cAB);
d218 1
a218 1
	if ((cs = OPENSSL_malloc(BN_num_bytes(s))) == NULL)
d231 1
a231 1
	OPENSSL_free(cs);
@


1.1.1.1
log
@import OpenSSL-1.0.1c
@
text
@@


1.1.1.2
log
@Import OpenSSL 1.0.1g
@
text
@d66 7
a72 11
# if (defined(_WIN32) || defined(_WIN64)) && !defined(__MINGW32__)
#  define bn_pack4(a1,a2,a3,a4) ((a1##UI64<<48)|(a2##UI64<<32)|(a3##UI64<<16)|a4##UI64)
# elif defined(__arch64__)
#  define bn_pack4(a1,a2,a3,a4) ((a1##UL<<48)|(a2##UL<<32)|(a3##UL<<16)|a4##UL)
# else
#  define bn_pack4(a1,a2,a3,a4) ((a1##ULL<<48)|(a2##ULL<<32)|(a3##ULL<<16)|a4##ULL)
# endif
#elif (BN_BYTES == 4)
# define bn_pack4(a1,a2,a3,a4)  ((a3##UL<<16)|a4##UL), ((a1##UL<<16)|a2##UL)
#else
# error "unsupported BN_BYTES"
@

