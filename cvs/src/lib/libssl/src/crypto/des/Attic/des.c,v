head	1.8;
access;
symbols
	butholakala:1.7
	openssl_1_0_1_g:1.1.1.3
	OPENBSD_5_5:1.7.0.46
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.42
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.40
	OPENBSD_5_3_BASE:1.7
	openssl_1_0_1_c:1.1.1.3
	OPENBSD_5_2:1.7.0.36
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.38
	openssl_1_0_0_f:1.1.1.3
	openssl_1_0_0_e:1.1.1.3
	OPENBSD_5_0:1.7.0.34
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.32
	OPENBSD_4_9_BASE:1.7
	openssh_1_0_0_a:1.1.1.3
	OPENBSD_4_8:1.7.0.30
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.26
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.28
	OPENBSD_4_6_BASE:1.7
	openssl_0_9_8_k:1.1.1.3
	OPENBSD_4_5:1.7.0.24
	OPENBSD_4_5_BASE:1.7
	openssl_0_9_8_j:1.1.1.3
	openssl_0_9_8_h:1.1.1.3
	pre_openssl_0_9_8h:1.7
	OPENBSD_4_4:1.7.0.22
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.20
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.18
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.16
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.14
	OPENBSD_4_0_BASE:1.7
	openssl_0_9_7j:1.1.1.3
	openssl:1.1.1
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENSSL_0_9_7G:1.1.1.3
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENSSL_0_9_7D:1.1.1.3
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENSSL_0_9_7C:1.1.1.3
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.5.0.6
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.04.16.00.03.52;	author tedu;	state dead;
branches;
next	1.7;

1.7
date	2003.05.12.02.18.36;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.12;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.57.28;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.35;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.09.53;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.56;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.42;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.42;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.10;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.34.58;	author markus;	state Exp;
branches;
next	;


desc
@@


1.8
log
@you do not want to do the things this program does
@
text
@/* crypto/des/des.c */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/opensslconf.h>
#ifndef OPENSSL_SYS_MSDOS
#ifndef OPENSSL_SYS_VMS
#include OPENSSL_UNISTD
#else /* OPENSSL_SYS_VMS */
#ifdef __DECC
#include <unistd.h>
#else /* not __DECC */
#include <math.h>
#endif /* __DECC */
#endif /* OPENSSL_SYS_VMS */
#else /* OPENSSL_SYS_MSDOS */
#include <io.h>
#endif

#include <time.h>
#include "des_ver.h"

#ifdef OPENSSL_SYS_VMS
#include <types.h>
#include <stat.h>
#else
#ifndef _IRIX
#include <sys/types.h>
#endif
#include <sys/stat.h>
#endif
#include <openssl/des.h>
#include <openssl/rand.h>
#include <openssl/ui_compat.h>

void usage(void);
void doencryption(void);
int uufwrite(unsigned char *data, int size, unsigned int num, FILE *fp);
void uufwriteEnd(FILE *fp);
int uufread(unsigned char *out,int size,unsigned int num,FILE *fp);
int uuencode(unsigned char *in,int num,unsigned char *out);
int uudecode(unsigned char *in,int num,unsigned char *out);
void DES_3cbc_encrypt(DES_cblock *input,DES_cblock *output,long length,
	DES_key_schedule sk1,DES_key_schedule sk2,
	DES_cblock *ivec1,DES_cblock *ivec2,int enc);
#ifdef OPENSSL_SYS_VMS
#define EXIT(a) exit(a&0x10000000L)
#else
#define EXIT(a) exit(a)
#endif

#define BUFSIZE (8*1024)
#define VERIFY  1
#define KEYSIZ	8
#define KEYSIZB 1024 /* should hit tty line limit first :-) */
char key[KEYSIZB+1];
int do_encrypt,longk=0;
FILE *DES_IN,*DES_OUT,*CKSUM_OUT;
char uuname[200];
unsigned char uubuf[50];
int uubufnum=0;
#define INUUBUFN	(45*100)
#define OUTUUBUF	(65*100)
unsigned char b[OUTUUBUF];
unsigned char bb[300];
DES_cblock cksum={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
char cksumname[200]="";

int vflag,cflag,eflag,dflag,kflag,bflag,fflag,sflag,uflag,flag3,hflag,error;

int main(int argc, char **argv)
	{
	int i;
	struct stat ins,outs;
	char *p;
	char *in=NULL,*out=NULL;

	vflag=cflag=eflag=dflag=kflag=hflag=bflag=fflag=sflag=uflag=flag3=0;
	error=0;
	memset(key,0,sizeof(key));

	for (i=1; i<argc; i++)
		{
		p=argv[i];
		if ((p[0] == '-') && (p[1] != '\0'))
			{
			p++;
			while (*p)
				{
				switch (*(p++))
					{
				case '3':
					flag3=1;
					longk=1;
					break;
				case 'c':
					cflag=1;
					strncpy(cksumname,p,200);
					cksumname[sizeof(cksumname)-1]='\0';
					p+=strlen(cksumname);
					break;
				case 'C':
					cflag=1;
					longk=1;
					strncpy(cksumname,p,200);
					cksumname[sizeof(cksumname)-1]='\0';
					p+=strlen(cksumname);
					break;
				case 'e':
					eflag=1;
					break;
				case 'v':
					vflag=1;
					break;
				case 'E':
					eflag=1;
					longk=1;
					break;
				case 'd':
					dflag=1;
					break;
				case 'D':
					dflag=1;
					longk=1;
					break;
				case 'b':
					bflag=1;
					break;
				case 'f':
					fflag=1;
					break;
				case 's':
					sflag=1;
					break;
				case 'u':
					uflag=1;
					strncpy(uuname,p,200);
					uuname[sizeof(uuname)-1]='\0';
					p+=strlen(uuname);
					break;
				case 'h':
					hflag=1;
					break;
				case 'k':
					kflag=1;
					if ((i+1) == argc)
						{
						fputs("must have a key with the -k option\n",stderr);
						error=1;
						}
					else
						{
						int j;

						i++;
						strncpy(key,argv[i],KEYSIZB);
						for (j=strlen(argv[i])-1; j>=0; j--)
							argv[i][j]='\0';
						}
					break;
				default:
					fprintf(stderr,"'%c' unknown flag\n",p[-1]);
					error=1;
					break;
					}
				}
			}
		else
			{
			if (in == NULL)
				in=argv[i];
			else if (out == NULL)
				out=argv[i];
			else
				error=1;
			}
		}
	if (error) usage();
	/* We either
	 * do checksum or
	 * do encrypt or
	 * do decrypt or
	 * do decrypt then ckecksum or
	 * do checksum then encrypt
	 */
	if (((eflag+dflag) == 1) || cflag)
		{
		if (eflag) do_encrypt=DES_ENCRYPT;
		if (dflag) do_encrypt=DES_DECRYPT;
		}
	else
		{
		if (vflag) 
			{
#ifndef _Windows			
			fprintf(stderr,"des(1) built with %s\n",libdes_version);
#endif			
			EXIT(1);
			}
		else usage();
		}

#ifndef _Windows			
	if (vflag) fprintf(stderr,"des(1) built with %s\n",libdes_version);
#endif			
	if (	(in != NULL) &&
		(out != NULL) &&
#ifndef OPENSSL_SYS_MSDOS
		(stat(in,&ins) != -1) &&
		(stat(out,&outs) != -1) &&
		(ins.st_dev == outs.st_dev) &&
		(ins.st_ino == outs.st_ino))
#else /* OPENSSL_SYS_MSDOS */
		(strcmp(in,out) == 0))
#endif
			{
			fputs("input and output file are the same\n",stderr);
			EXIT(3);
			}

	if (!kflag)
		if (des_read_pw_string(key,KEYSIZB+1,"Enter key:",eflag?VERIFY:0))
			{
			fputs("password error\n",stderr);
			EXIT(2);
			}

	if (in == NULL)
		DES_IN=stdin;
	else if ((DES_IN=fopen(in,"r")) == NULL)
		{
		perror("opening input file");
		EXIT(4);
		}

	CKSUM_OUT=stdout;
	if (out == NULL)
		{
		DES_OUT=stdout;
		CKSUM_OUT=stderr;
		}
	else if ((DES_OUT=fopen(out,"w")) == NULL)
		{
		perror("opening output file");
		EXIT(5);
		}

#ifdef OPENSSL_SYS_MSDOS
	/* This should set the file to binary mode. */
	{
#include <fcntl.h>
	if (!(uflag && dflag))
		setmode(fileno(DES_IN),O_BINARY);
	if (!(uflag && eflag))
		setmode(fileno(DES_OUT),O_BINARY);
	}
#endif

	doencryption();
	fclose(DES_IN);
	fclose(DES_OUT);
	EXIT(0);
	}

void usage(void)
	{
	char **u;
	static const char *Usage[]={
"des <options> [input-file [output-file]]",
"options:",
"-v         : des(1) version number",
"-e         : encrypt using SunOS compatible user key to DES key conversion.",
"-E         : encrypt ",
"-d         : decrypt using SunOS compatible user key to DES key conversion.",
"-D         : decrypt ",
"-c[ckname] : generate a cbc_cksum using SunOS compatible user key to",
"             DES key conversion and output to ckname (stdout default,",
"             stderr if data being output on stdout).  The checksum is",
"             generated before encryption and after decryption if used",
"             in conjunction with -[eEdD].",
"-C[ckname] : generate a cbc_cksum as for -c but compatible with -[ED].",
"-k key     : use key 'key'",
"-h         : the key that is entered will be a hexadecimal number",
"             that is used directly as the des key",
"-u[uuname] : input file is uudecoded if -[dD] or output uuencoded data if -[eE]",
"             (uuname is the filename to put in the uuencode header).",
"-b         : encrypt using DES in ecb encryption mode, the default is cbc mode.",
"-3         : encrypt using triple DES encryption.  This uses 2 keys",
"             generated from the input key.  If the input key is less",
"             than 8 characters long, this is equivalent to normal",
"             encryption.  Default is triple cbc, -b makes it triple ecb.",
NULL
};
	for (u=(char **)Usage; *u; u++)
		{
		fputs(*u,stderr);
		fputc('\n',stderr);
		}

	EXIT(1);
	}

void doencryption(void)
	{
#ifdef _LIBC
	extern unsigned long time();
#endif

	register int i;
	DES_key_schedule ks,ks2;
	DES_cblock iv,iv2;
	char *p;
	int num=0,j,k,l,rem,ll,len,last,ex=0;
	DES_cblock kk,k2;
	FILE *O;
	int Exit=0;
#ifndef OPENSSL_SYS_MSDOS
	static unsigned char buf[BUFSIZE+8],obuf[BUFSIZE+8];
#else
	static unsigned char *buf=NULL,*obuf=NULL;

	if (buf == NULL)
		{
		if (    (( buf=OPENSSL_malloc(BUFSIZE+8)) == NULL) ||
			((obuf=OPENSSL_malloc(BUFSIZE+8)) == NULL))
			{
			fputs("Not enough memory\n",stderr);
			Exit=10;
			goto problems;
			}
		}
#endif

	if (hflag)
		{
		j=(flag3?16:8);
		p=key;
		for (i=0; i<j; i++)
			{
			k=0;
			if ((*p <= '9') && (*p >= '0'))
				k=(*p-'0')<<4;
			else if ((*p <= 'f') && (*p >= 'a'))
				k=(*p-'a'+10)<<4;
			else if ((*p <= 'F') && (*p >= 'A'))
				k=(*p-'A'+10)<<4;
			else
				{
				fputs("Bad hex key\n",stderr);
				Exit=9;
				goto problems;
				}
			p++;
			if ((*p <= '9') && (*p >= '0'))
				k|=(*p-'0');
			else if ((*p <= 'f') && (*p >= 'a'))
				k|=(*p-'a'+10);
			else if ((*p <= 'F') && (*p >= 'A'))
				k|=(*p-'A'+10);
			else
				{
				fputs("Bad hex key\n",stderr);
				Exit=9;
				goto problems;
				}
			p++;
			if (i < 8)
				kk[i]=k;
			else
				k2[i-8]=k;
			}
		DES_set_key_unchecked(&k2,&ks2);
		OPENSSL_cleanse(k2,sizeof(k2));
		}
	else if (longk || flag3)
		{
		if (flag3)
			{
			DES_string_to_2keys(key,&kk,&k2);
			DES_set_key_unchecked(&k2,&ks2);
			OPENSSL_cleanse(k2,sizeof(k2));
			}
		else
			DES_string_to_key(key,&kk);
		}
	else
		for (i=0; i<KEYSIZ; i++)
			{
			l=0;
			k=key[i];
			for (j=0; j<8; j++)
				{
				if (k&1) l++;
				k>>=1;
				}
			if (l & 1)
				kk[i]=key[i]&0x7f;
			else
				kk[i]=key[i]|0x80;
			}

	DES_set_key_unchecked(&kk,&ks);
	OPENSSL_cleanse(key,sizeof(key));
	OPENSSL_cleanse(kk,sizeof(kk));
	/* woops - A bug that does not showup under unix :-( */
	memset(iv,0,sizeof(iv));
	memset(iv2,0,sizeof(iv2));

	l=1;
	rem=0;
	/* first read */
	if (eflag || (!dflag && cflag))
		{
		for (;;)
			{
			num=l=fread(&(buf[rem]),1,BUFSIZE,DES_IN);
			l+=rem;
			num+=rem;
			if (l < 0)
				{
				perror("read error");
				Exit=6;
				goto problems;
				}

			rem=l%8;
			len=l-rem;
			if (feof(DES_IN))
				{
				for (i=7-rem; i>0; i--)
					RAND_pseudo_bytes(buf + l++, 1);
				buf[l++]=rem;
				ex=1;
				len+=rem;
				}
			else
				l-=rem;

			if (cflag)
				{
				DES_cbc_cksum(buf,&cksum,
					(long)len,&ks,&cksum);
				if (!eflag)
					{
					if (feof(DES_IN)) break;
					else continue;
					}
				}

			if (bflag && !flag3)
				for (i=0; i<l; i+=8)
					DES_ecb_encrypt(
						(DES_cblock *)&(buf[i]),
						(DES_cblock *)&(obuf[i]),
						&ks,do_encrypt);
			else if (flag3 && bflag)
				for (i=0; i<l; i+=8)
					DES_ecb2_encrypt(
						(DES_cblock *)&(buf[i]),
						(DES_cblock *)&(obuf[i]),
						&ks,&ks2,do_encrypt);
			else if (flag3 && !bflag)
				{
				char tmpbuf[8];

				if (rem) memcpy(tmpbuf,&(buf[l]),
					(unsigned int)rem);
				DES_3cbc_encrypt(
					(DES_cblock *)buf,(DES_cblock *)obuf,
					(long)l,ks,ks2,&iv,
					&iv2,do_encrypt);
				if (rem) memcpy(&(buf[l]),tmpbuf,
					(unsigned int)rem);
				}
			else
				{
				DES_cbc_encrypt(
					buf,obuf,
					(long)l,&ks,&iv,do_encrypt);
				if (l >= 8) memcpy(iv,&(obuf[l-8]),8);
				}
			if (rem) memcpy(buf,&(buf[l]),(unsigned int)rem);

			i=0;
			while (i < l)
				{
				if (uflag)
					j=uufwrite(obuf,1,(unsigned int)l-i,
						DES_OUT);
				else
					j=fwrite(obuf,1,(unsigned int)l-i,
						DES_OUT);
				if (j == -1)
					{
					perror("Write error");
					Exit=7;
					goto problems;
					}
				i+=j;
				}
			if (feof(DES_IN))
				{
				if (uflag) uufwriteEnd(DES_OUT);
				break;
				}
			}
		}
	else /* decrypt */
		{
		ex=1;
		for (;;)
			{
			if (ex) {
				if (uflag)
					l=uufread(buf,1,BUFSIZE,DES_IN);
				else
					l=fread(buf,1,BUFSIZE,DES_IN);
				ex=0;
				rem=l%8;
				l-=rem;
				}
			if (l < 0)
				{
				perror("read error");
				Exit=6;
				goto problems;
				}

			if (bflag && !flag3)
				for (i=0; i<l; i+=8)
					DES_ecb_encrypt(
						(DES_cblock *)&(buf[i]),
						(DES_cblock *)&(obuf[i]),
						&ks,do_encrypt);
			else if (flag3 && bflag)
				for (i=0; i<l; i+=8)
					DES_ecb2_encrypt(
						(DES_cblock *)&(buf[i]),
						(DES_cblock *)&(obuf[i]),
						&ks,&ks2,do_encrypt);
			else if (flag3 && !bflag)
				{
				DES_3cbc_encrypt(
					(DES_cblock *)buf,(DES_cblock *)obuf,
					(long)l,ks,ks2,&iv,
					&iv2,do_encrypt);
				}
			else
				{
				DES_cbc_encrypt(
					buf,obuf,
				 	(long)l,&ks,&iv,do_encrypt);
				if (l >= 8) memcpy(iv,&(buf[l-8]),8);
				}

			if (uflag)
				ll=uufread(&(buf[rem]),1,BUFSIZE,DES_IN);
			else
				ll=fread(&(buf[rem]),1,BUFSIZE,DES_IN);
			ll+=rem;
			rem=ll%8;
			ll-=rem;
			if (feof(DES_IN) && (ll == 0))
				{
				last=obuf[l-1];

				if ((last > 7) || (last < 0))
					{
					fputs("The file was not decrypted correctly.\n",
						stderr);
					Exit=8;
					last=0;
					}
				l=l-8+last;
				}
			i=0;
			if (cflag) DES_cbc_cksum(obuf,
				(DES_cblock *)cksum,(long)l/8*8,&ks,
				(DES_cblock *)cksum);
			while (i != l)
				{
				j=fwrite(obuf,1,(unsigned int)l-i,DES_OUT);
				if (j == -1)
					{
					perror("Write error");
					Exit=7;
					goto problems;
					}
				i+=j;
				}
			l=ll;
			if ((l == 0) && feof(DES_IN)) break;
			}
		}
	if (cflag)
		{
		l=0;
		if (cksumname[0] != '\0')
			{
			if ((O=fopen(cksumname,"w")) != NULL)
				{
				CKSUM_OUT=O;
				l=1;
				}
			}
		for (i=0; i<8; i++)
			fprintf(CKSUM_OUT,"%02X",cksum[i]);
		fprintf(CKSUM_OUT,"\n");
		if (l) fclose(CKSUM_OUT);
		}
problems:
	OPENSSL_cleanse(buf,sizeof(buf));
	OPENSSL_cleanse(obuf,sizeof(obuf));
	OPENSSL_cleanse(&ks,sizeof(ks));
	OPENSSL_cleanse(&ks2,sizeof(ks2));
	OPENSSL_cleanse(iv,sizeof(iv));
	OPENSSL_cleanse(iv2,sizeof(iv2));
	OPENSSL_cleanse(kk,sizeof(kk));
	OPENSSL_cleanse(k2,sizeof(k2));
	OPENSSL_cleanse(uubuf,sizeof(uubuf));
	OPENSSL_cleanse(b,sizeof(b));
	OPENSSL_cleanse(bb,sizeof(bb));
	OPENSSL_cleanse(cksum,sizeof(cksum));
	if (Exit) EXIT(Exit);
	}

/*    We ignore this parameter but it should be > ~50 I believe    */
int uufwrite(unsigned char *data, int size, unsigned int num, FILE *fp)
	{
	int i,j,left,rem,ret=num;
	static int start=1;

	if (start)
		{
		fprintf(fp,"begin 600 %s\n",
			(uuname[0] == '\0')?"text.d":uuname);
		start=0;
		}

	if (uubufnum)
		{
		if (uubufnum+num < 45)
			{
			memcpy(&(uubuf[uubufnum]),data,(unsigned int)num);
			uubufnum+=num;
			return(num);
			}
		else
			{
			i=45-uubufnum;
			memcpy(&(uubuf[uubufnum]),data,(unsigned int)i);
			j=uuencode((unsigned char *)uubuf,45,b);
			fwrite(b,1,(unsigned int)j,fp);
			uubufnum=0;
			data+=i;
			num-=i;
			}
		}

	for (i=0; i<(((int)num)-INUUBUFN); i+=INUUBUFN)
		{
		j=uuencode(&(data[i]),INUUBUFN,b);
		fwrite(b,1,(unsigned int)j,fp);
		}
	rem=(num-i)%45;
	left=(num-i-rem);
	if (left)
		{
		j=uuencode(&(data[i]),left,b);
		fwrite(b,1,(unsigned int)j,fp);
		i+=left;
		}
	if (i != num)
		{
		memcpy(uubuf,&(data[i]),(unsigned int)rem);
		uubufnum=rem;
		}
	return(ret);
	}

void uufwriteEnd(FILE *fp)
	{
	int j;
	static const char *end=" \nend\n";

	if (uubufnum != 0)
		{
		uubuf[uubufnum]='\0';
		uubuf[uubufnum+1]='\0';
		uubuf[uubufnum+2]='\0';
		j=uuencode(uubuf,uubufnum,b);
		fwrite(b,1,(unsigned int)j,fp);
		}
	fwrite(end,1,strlen(end),fp);
	}

/* int size:  should always be > ~ 60; I actually ignore this parameter :-)    */
int uufread(unsigned char *out, int size, unsigned int num, FILE *fp)
	{
	int i,j,tot;
	static int done=0;
	static int valid=0;
	static int start=1;

	if (start)
		{
		for (;;)
			{
			b[0]='\0';
			fgets((char *)b,300,fp);
			if (b[0] == '\0')
				{
				fprintf(stderr,"no 'begin' found in uuencoded input\n");
				return(-1);
				}
			if (strncmp((char *)b,"begin ",6) == 0) break;
			}
		start=0;
		}
	if (done) return(0);
	tot=0;
	if (valid)
		{
		memcpy(out,bb,(unsigned int)valid);
		tot=valid;
		valid=0;
		}
	for (;;)
		{
		b[0]='\0';
		fgets((char *)b,300,fp);
		if (b[0] == '\0') break;
		i=strlen((char *)b);
		if ((b[0] == 'e') && (b[1] == 'n') && (b[2] == 'd'))
			{
			done=1;
			while (!feof(fp))
				{
				fgets((char *)b,300,fp);
				}
			break;
			}
		i=uudecode(b,i,bb);
		if (i < 0) break;
		if ((i+tot+8) > num)
			{
			/* num to copy to make it a multiple of 8 */
			j=(num/8*8)-tot-8;
			memcpy(&(out[tot]),bb,(unsigned int)j);
			tot+=j;
			memcpy(bb,&(bb[j]),(unsigned int)i-j);
			valid=i-j;
			break;
			}
		memcpy(&(out[tot]),bb,(unsigned int)i);
		tot+=i;
		}
	return(tot);
	}

#define ccc2l(c,l)      (l =((DES_LONG)(*((c)++)))<<16, \
			 l|=((DES_LONG)(*((c)++)))<< 8, \
		 	 l|=((DES_LONG)(*((c)++))))

#define l2ccc(l,c)      (*((c)++)=(unsigned char)(((l)>>16)&0xff), \
                    *((c)++)=(unsigned char)(((l)>> 8)&0xff), \
                    *((c)++)=(unsigned char)(((l)    )&0xff))


int uuencode(unsigned char *in, int num, unsigned char *out)
	{
	int j,i,n,tot=0;
	DES_LONG l;
	register unsigned char *p;
	p=out;

	for (j=0; j<num; j+=45)
		{
		if (j+45 > num)
			i=(num-j);
		else	i=45;
		*(p++)=i+' ';
		for (n=0; n<i; n+=3)
			{
			ccc2l(in,l);
			*(p++)=((l>>18)&0x3f)+' ';
			*(p++)=((l>>12)&0x3f)+' ';
			*(p++)=((l>> 6)&0x3f)+' ';
			*(p++)=((l    )&0x3f)+' ';
			tot+=4;
			}
		*(p++)='\n';
		tot+=2;
		}
	*p='\0';
	l=0;
	return(tot);
	}

int uudecode(unsigned char *in, int num, unsigned char *out)
	{
	int j,i,k;
	unsigned int n=0,space=0;
	DES_LONG l;
	DES_LONG w,x,y,z;
	unsigned int blank=(unsigned int)'\n'-' ';

	for (j=0; j<num; )
		{
		n= *(in++)-' ';
		if (n == blank)
			{
			n=0;
			in--;
			}
		if (n > 60)
			{
			fprintf(stderr,"uuencoded line length too long\n");
			return(-1);
			}
		j++;

		for (i=0; i<n; j+=4,i+=3)
			{
			/* the following is for cases where spaces are
			 * removed from lines.
			 */
			if (space)
				{
				w=x=y=z=0;
				}
			else
				{
				w= *(in++)-' ';
				x= *(in++)-' ';
				y= *(in++)-' ';
				z= *(in++)-' ';
				}
			if ((w > 63) || (x > 63) || (y > 63) || (z > 63))
				{
				k=0;
				if (w == blank) k=1;
				if (x == blank) k=2;
				if (y == blank) k=3;
				if (z == blank) k=4;
				space=1;
				switch (k) {
				case 1:	w=0; in--;
				case 2: x=0; in--;
				case 3: y=0; in--;
				case 4: z=0; in--;
					break;
				case 0:
					space=0;
					fprintf(stderr,"bad uuencoded data values\n");
					w=x=y=z=0;
					return(-1);
					break;
					}
				}
			l=(w<<18)|(x<<12)|(y<< 6)|(z    );
			l2ccc(l,out);
			}
		if (*(in++) != '\n')
			{
			fprintf(stderr,"missing nl in uuencoded line\n");
			w=x=y=z=0;
			return(-1);
			}
		j++;
		}
	*out='\0';
	w=x=y=z=0;
	return(n);
	}
@


1.7
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d430 1
a430 1
		memset(k2,0,sizeof(k2));
d438 1
a438 1
			memset(k2,0,sizeof(k2));
d460 2
a461 2
	memset(key,0,sizeof(key));
	memset(kk,0,sizeof(kk));
d669 12
a680 12
	memset(buf,0,sizeof(buf));
	memset(obuf,0,sizeof(obuf));
	memset(&ks,0,sizeof(ks));
	memset(&ks2,0,sizeof(ks2));
	memset(iv,0,sizeof(iv));
	memset(iv2,0,sizeof(iv2));
	memset(kk,0,sizeof(kk));
	memset(k2,0,sizeof(k2));
	memset(uubuf,0,sizeof(uubuf));
	memset(b,0,sizeof(b));
	memset(bb,0,sizeof(bb));
	memset(cksum,0,sizeof(cksum));
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@a61 2
#ifndef MSDOS
#ifndef VMS
d63 2
d66 1
a66 1
#else /* VMS */
d72 2
a73 2
#endif /* VMS */
#else /* MSDOS */
d80 1
a80 1
#ifdef VMS
d91 1
d100 4
a103 4
void des_3cbc_encrypt(des_cblock *input,des_cblock *output,long length,
	des_key_schedule sk1,des_key_schedule sk2,
	des_cblock *ivec1,des_cblock *ivec2,int enc);
#ifdef VMS
d123 1
a123 1
des_cblock cksum={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
d156 1
d163 1
d195 1
d265 1
a265 1
#ifndef MSDOS
d270 1
a270 1
#else /* MSDOS */
d305 1
a305 1
#ifdef MSDOS
d367 2
a368 2
	des_key_schedule ks,ks2;
	des_cblock iv,iv2;
d371 1
a371 1
	des_cblock kk,k2;
d374 1
a374 1
#ifndef MSDOS
d429 1
a429 1
		des_set_key_unchecked(&k2,ks2);
d436 2
a437 2
			des_string_to_2keys(key,&kk,&k2);
			des_set_key_unchecked(&k2,ks2);
d441 1
a441 1
			des_string_to_key(key,&kk);
d459 1
a459 1
	des_set_key_unchecked(&kk,ks);
d498 2
a499 2
				des_cbc_cksum(buf,&cksum,
					(long)len,ks,&cksum);
d509 4
a512 4
					des_ecb_encrypt(
						(des_cblock *)&(buf[i]),
						(des_cblock *)&(obuf[i]),
						ks,do_encrypt);
d515 4
a518 4
					des_ecb2_encrypt(
						(des_cblock *)&(buf[i]),
						(des_cblock *)&(obuf[i]),
						ks,ks2,do_encrypt);
d525 2
a526 2
				des_3cbc_encrypt(
					(des_cblock *)buf,(des_cblock *)obuf,
d534 1
a534 1
				des_cbc_encrypt(
d536 1
a536 1
					(long)l,ks,&iv,do_encrypt);
d588 4
a591 4
					des_ecb_encrypt(
						(des_cblock *)&(buf[i]),
						(des_cblock *)&(obuf[i]),
						ks,do_encrypt);
d594 4
a597 4
					des_ecb2_encrypt(
						(des_cblock *)&(buf[i]),
						(des_cblock *)&(obuf[i]),
						ks,ks2,do_encrypt);
d600 2
a601 2
				des_3cbc_encrypt(
					(des_cblock *)buf,(des_cblock *)obuf,
d607 1
a607 1
				des_cbc_encrypt(
d609 1
a609 1
				 	(long)l,ks,&iv,do_encrypt);
d634 3
a636 3
			if (cflag) des_cbc_cksum(obuf,
				(des_cblock *)cksum,(long)l/8*8,ks,
				(des_cblock *)cksum);
d671 2
a672 2
	memset(ks,0,sizeof(ks));
	memset(ks2,0,sizeof(ks2));
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d377 2
a378 2
		if (    (( buf=Malloc(BUFSIZE+8)) == NULL) ||
			((obuf=Malloc(BUFSIZE+8)) == NULL))
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d61 1
d73 1
a73 1
#else
a90 4

#if defined(__STDC__) || defined(VMS) || defined(M_XENIX) || defined(MSDOS)
#include <string.h>
#endif
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d328 1
a328 1
"-e         : encrypt using sunOS compatible user key to DES key conversion.",
d330 1
a330 1
"-d         : decrypt using sunOS compatible user key to DES key conversion.",
d332 1
a332 1
"-c[ckname] : generate a cbc_cksum using sunOS compatible user key to",
d339 1
a339 1
"-h         : the key that is entered will be a hexidecimal number",
d343 2
a344 2
"-b         : encrypt using DES in ecb encryption mode, the defaut is cbc mode.",
"-3         : encrypt using tripple DES encryption.  This uses 2 keys",
d346 1
a346 1
"             than 8 characters long, this is equivelent to normal",
d428 1
a428 1
		des_set_key(&k2,ks2);
d436 1
a436 1
			des_set_key(&k2,ks2);
d458 1
a458 1
	des_set_key(&kk,ks);
d487 1
a487 1
					RAND_bytes(buf + l++, 1);
@


1.1
log
@Initial revision
@
text
@d62 5
d68 4
a73 1
#define RAND
d88 2
a89 4
#if defined(NOCONST)
#define const
#endif
#include "des.h"
a94 6
#ifdef RAND
#define random rand
#define srandom(s) srand(s)
#endif

#ifndef NOPROTO
a104 11
#else
void usage();
void doencryption();
int uufwrite();
void uufwriteEnd();
int uufread();
int uuencode();
int uudecode();
void des_3cbc_encrypt();
#endif

d130 1
a130 3
int main(argc, argv)
int argc;
char **argv;
d321 1
a321 1
void usage()
d347 1
a347 1
"             encryption.  Default is tripple cbc, -b makes it tripple ecb.",
d359 1
a359 1
void doencryption()
a361 2
	extern int srandom();
	extern int random();
d367 1
a367 1
	unsigned char iv[8],iv2[8];
d380 2
a381 2
		if (    (( buf=(unsigned char *)Malloc(BUFSIZE+8)) == NULL) ||
			((obuf=(unsigned char *)Malloc(BUFSIZE+8)) == NULL))
d428 1
a428 1
		des_set_key((C_Block *)k2,ks2);
d435 2
a436 2
			des_string_to_2keys(key,(C_Block *)kk,(C_Block *)k2);
			des_set_key((C_Block *)k2,ks2);
d440 1
a440 1
			des_string_to_key(key,(C_Block *)kk);
d458 1
a458 1
	des_set_key((C_Block *)kk,ks);
a485 1
				srandom((unsigned int)time(NULL));
d487 1
a487 1
					buf[l++]=random()&0xff;
d497 2
a498 2
				des_cbc_cksum((C_Block *)buf,(C_Block *)cksum,
					(long)len,ks,(C_Block *)cksum);
d526 2
a527 2
					(long)l,ks,ks2,(des_cblock *)iv,
					(des_cblock *)iv2,do_encrypt);
d534 2
a535 2
					(des_cblock *)buf,(des_cblock *)obuf,
					(long)l,ks,(des_cblock *)iv,do_encrypt);
d601 2
a602 2
					(long)l,ks,ks2,(des_cblock *)iv,
					(des_cblock *)iv2,do_encrypt);
d607 2
a608 2
					(des_cblock *)buf,(des_cblock *)obuf,
				 	(long)l,ks,(des_cblock *)iv,do_encrypt);
d633 3
a635 3
			if (cflag) des_cbc_cksum((C_Block *)obuf,
				(C_Block *)cksum,(long)l/8*8,ks,
				(C_Block *)cksum);
d683 2
a684 9
int uufwrite(data, size, num, fp)
unsigned char *data;
int size;
unsigned int num;
FILE *fp;
      
     /* We ignore this parameter but it should be > ~50 I believe */
   
    
d737 1
a737 2
void uufwriteEnd(fp)
FILE *fp;
d753 2
a754 5
int uufread(out, size, num, fp)
unsigned char *out;
int size; /* should always be > ~ 60; I actually ignore this parameter :-) */
unsigned int num;
FILE *fp;
d826 1
a826 4
int uuencode(in, num, out)
unsigned char *in;
int num;
unsigned char *out;
d856 1
a856 4
int uudecode(in, num, out)
unsigned char *in;
int num;
unsigned char *out;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d61 1
a61 7
#include <string.h>
#include <openssl/opensslconf.h>
#ifndef OPENSSL_SYS_MSDOS
#ifndef OPENSSL_SYS_VMS
#include OPENSSL_UNISTD
#else /* OPENSSL_SYS_VMS */
#ifdef __DECC
d63 1
a63 5
#else /* not __DECC */
#include <math.h>
#endif /* __DECC */
#endif /* OPENSSL_SYS_VMS */
#else /* OPENSSL_SYS_MSDOS */
d65 1
d71 1
a71 1
#ifdef OPENSSL_SYS_VMS
d80 8
a87 3
#include <openssl/des.h>
#include <openssl/rand.h>
#include <openssl/ui_compat.h>
d89 6
d102 15
a116 4
void DES_3cbc_encrypt(DES_cblock *input,DES_cblock *output,long length,
	DES_key_schedule sk1,DES_key_schedule sk2,
	DES_cblock *ivec1,DES_cblock *ivec2,int enc);
#ifdef OPENSSL_SYS_VMS
d136 1
a136 1
DES_cblock cksum={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
d141 3
a143 1
int main(int argc, char **argv)
a170 1
					cksumname[sizeof(cksumname)-1]='\0';
a176 1
					cksumname[sizeof(cksumname)-1]='\0';
a207 1
					uuname[sizeof(uuname)-1]='\0';
d277 1
a277 1
#ifndef OPENSSL_SYS_MSDOS
d282 1
a282 1
#else /* OPENSSL_SYS_MSDOS */
d317 1
a317 1
#ifdef OPENSSL_SYS_MSDOS
d334 1
a334 1
void usage(void)
d341 1
a341 1
"-e         : encrypt using SunOS compatible user key to DES key conversion.",
d343 1
a343 1
"-d         : decrypt using SunOS compatible user key to DES key conversion.",
d345 1
a345 1
"-c[ckname] : generate a cbc_cksum using SunOS compatible user key to",
d352 1
a352 1
"-h         : the key that is entered will be a hexadecimal number",
d356 2
a357 2
"-b         : encrypt using DES in ecb encryption mode, the default is cbc mode.",
"-3         : encrypt using triple DES encryption.  This uses 2 keys",
d359 2
a360 2
"             than 8 characters long, this is equivalent to normal",
"             encryption.  Default is triple cbc, -b makes it triple ecb.",
d372 1
a372 1
void doencryption(void)
d375 2
d381 2
a382 2
	DES_key_schedule ks,ks2;
	DES_cblock iv,iv2;
d385 1
a385 1
	DES_cblock kk,k2;
d388 1
a388 1
#ifndef OPENSSL_SYS_MSDOS
d395 2
a396 2
		if (    (( buf=OPENSSL_malloc(BUFSIZE+8)) == NULL) ||
			((obuf=OPENSSL_malloc(BUFSIZE+8)) == NULL))
d443 1
a443 1
		DES_set_key_unchecked(&k2,&ks2);
d450 2
a451 2
			DES_string_to_2keys(key,&kk,&k2);
			DES_set_key_unchecked(&k2,&ks2);
d455 1
a455 1
			DES_string_to_key(key,&kk);
d473 1
a473 1
	DES_set_key_unchecked(&kk,&ks);
d501 1
d503 1
a503 1
					RAND_pseudo_bytes(buf + l++, 1);
d513 2
a514 2
				DES_cbc_cksum(buf,&cksum,
					(long)len,&ks,&cksum);
d524 4
a527 4
					DES_ecb_encrypt(
						(DES_cblock *)&(buf[i]),
						(DES_cblock *)&(obuf[i]),
						&ks,do_encrypt);
d530 4
a533 4
					DES_ecb2_encrypt(
						(DES_cblock *)&(buf[i]),
						(DES_cblock *)&(obuf[i]),
						&ks,&ks2,do_encrypt);
d540 4
a543 4
				DES_3cbc_encrypt(
					(DES_cblock *)buf,(DES_cblock *)obuf,
					(long)l,ks,ks2,&iv,
					&iv2,do_encrypt);
d549 3
a551 3
				DES_cbc_encrypt(
					buf,obuf,
					(long)l,&ks,&iv,do_encrypt);
d603 4
a606 4
					DES_ecb_encrypt(
						(DES_cblock *)&(buf[i]),
						(DES_cblock *)&(obuf[i]),
						&ks,do_encrypt);
d609 4
a612 4
					DES_ecb2_encrypt(
						(DES_cblock *)&(buf[i]),
						(DES_cblock *)&(obuf[i]),
						&ks,&ks2,do_encrypt);
d615 4
a618 4
				DES_3cbc_encrypt(
					(DES_cblock *)buf,(DES_cblock *)obuf,
					(long)l,ks,ks2,&iv,
					&iv2,do_encrypt);
d622 3
a624 3
				DES_cbc_encrypt(
					buf,obuf,
				 	(long)l,&ks,&iv,do_encrypt);
d649 3
a651 3
			if (cflag) DES_cbc_cksum(obuf,
				(DES_cblock *)cksum,(long)l/8*8,&ks,
				(DES_cblock *)cksum);
d686 2
a687 2
	memset(&ks,0,sizeof(ks));
	memset(&ks2,0,sizeof(ks2));
d699 9
a707 2
/*    We ignore this parameter but it should be > ~50 I believe    */
int uufwrite(unsigned char *data, int size, unsigned int num, FILE *fp)
d760 2
a761 1
void uufwriteEnd(FILE *fp)
d777 5
a781 2
/* int size:  should always be > ~ 60; I actually ignore this parameter :-)    */
int uufread(unsigned char *out, int size, unsigned int num, FILE *fp)
d853 4
a856 1
int uuencode(unsigned char *in, int num, unsigned char *out)
d886 4
a889 1
int uudecode(unsigned char *in, int num, unsigned char *out)
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d430 1
a430 1
		OPENSSL_cleanse(k2,sizeof(k2));
d438 1
a438 1
			OPENSSL_cleanse(k2,sizeof(k2));
d460 2
a461 2
	OPENSSL_cleanse(key,sizeof(key));
	OPENSSL_cleanse(kk,sizeof(kk));
d669 12
a680 12
	OPENSSL_cleanse(buf,sizeof(buf));
	OPENSSL_cleanse(obuf,sizeof(obuf));
	OPENSSL_cleanse(&ks,sizeof(ks));
	OPENSSL_cleanse(&ks2,sizeof(ks2));
	OPENSSL_cleanse(iv,sizeof(iv));
	OPENSSL_cleanse(iv2,sizeof(iv2));
	OPENSSL_cleanse(kk,sizeof(kk));
	OPENSSL_cleanse(k2,sizeof(k2));
	OPENSSL_cleanse(uubuf,sizeof(uubuf));
	OPENSSL_cleanse(b,sizeof(b));
	OPENSSL_cleanse(bb,sizeof(bb));
	OPENSSL_cleanse(cksum,sizeof(cksum));
@


