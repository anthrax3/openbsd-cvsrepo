head	1.10;
access;
symbols
	butholakala:1.9
	openssl_1_0_1_g:1.1.1.4
	OPENBSD_5_5:1.9.0.46
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.42
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.40
	OPENBSD_5_3_BASE:1.9
	openssl_1_0_1_c:1.1.1.4
	OPENBSD_5_2:1.9.0.36
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.38
	openssl_1_0_0_f:1.1.1.4
	openssl_1_0_0_e:1.1.1.4
	OPENBSD_5_0:1.9.0.34
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.32
	OPENBSD_4_9_BASE:1.9
	openssh_1_0_0_a:1.1.1.4
	OPENBSD_4_8:1.9.0.30
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.26
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.28
	OPENBSD_4_6_BASE:1.9
	openssl_0_9_8_k:1.1.1.4
	OPENBSD_4_5:1.9.0.24
	OPENBSD_4_5_BASE:1.9
	openssl_0_9_8_j:1.1.1.4
	openssl_0_9_8_h:1.1.1.4
	pre_openssl_0_9_8h:1.9
	OPENBSD_4_4:1.9.0.22
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	openssl_0_9_7j:1.1.1.4
	openssl:1.1.1
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENSSL_0_9_7G:1.1.1.4
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.04.16.03.24.47;	author tedu;	state dead;
branches;
next	1.9;

1.9
date	2003.05.12.02.18.36;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.10.16.31.54;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.05.22.12.11;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.03.21.53.39;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.12;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.29;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.09.56;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.00;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.43;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.43;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.13;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.37.55;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.35.02;	author markus;	state Exp;
branches;
next	;


desc
@@


1.10
log
@dead file
@
text
@/* crypto/des/read_pwd.c */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <openssl/e_os2.h>
#if !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_VMS) && !defined(OPENSSL_SYS_WIN32)
#ifdef OPENSSL_UNISTD
# include OPENSSL_UNISTD
#else
# include <unistd.h>
#endif
/* If unistd.h defines _POSIX_VERSION, we conclude that we
 * are on a POSIX system and have sigaction and termios. */
#if defined(_POSIX_VERSION)

# define SIGACTION
# if !defined(TERMIOS) && !defined(TERMIO) && !defined(SGTTY)
# define TERMIOS
# endif

#endif
#endif

/* #define SIGACTION */ /* Define this if you have sigaction() */

#ifdef WIN16TTY
#undef OPENSSL_SYS_WIN16
#undef _WINDOWS
#include <graph.h>
#endif

/* 06-Apr-92 Luke Brennan    Support for VMS */
#include "des_locl.h"
#include "cryptlib.h"
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <setjmp.h>
#include <errno.h>

#ifdef OPENSSL_SYS_VMS			/* prototypes for sys$whatever */
#include <starlet.h>
#ifdef __DECC
#pragma message disable DOLLARID
#endif
#endif

#ifdef WIN_CONSOLE_BUG
#include <windows.h>
#ifndef OPENSSL_SYS_WINCE
#include <wincon.h>
#endif
#endif


/* There are 5 types of terminal interface supported,
 * TERMIO, TERMIOS, VMS, MSDOS and SGTTY
 */

#if defined(__sgi) && !defined(TERMIOS)
#define TERMIOS
#undef  TERMIO
#undef  SGTTY
#endif

#if defined(linux) && !defined(TERMIO)
#undef  TERMIOS
#define TERMIO
#undef  SGTTY
#endif

#ifdef _LIBC
#undef  TERMIOS
#define TERMIO
#undef  SGTTY
#endif

#if !defined(TERMIO) && !defined(TERMIOS) && !defined(OPENSSL_SYS_VMS) && !defined(OPENSSL_SYS_MSDOS) && !defined(MAC_OS_pre_X) && !defined(MAC_OS_GUSI_SOURCE)
#undef  TERMIOS
#undef  TERMIO
#define SGTTY
#endif

#if defined(OPENSSL_SYS_VXWORKS)
#undef TERMIOS
#undef TERMIO
#undef SGTTY
#endif

#ifdef TERMIOS
#include <termios.h>
#define TTY_STRUCT		struct termios
#define TTY_FLAGS		c_lflag
#define	TTY_get(tty,data)	tcgetattr(tty,data)
#define TTY_set(tty,data)	tcsetattr(tty,TCSANOW,data)
#endif

#ifdef TERMIO
#include <termio.h>
#define TTY_STRUCT		struct termio
#define TTY_FLAGS		c_lflag
#define TTY_get(tty,data)	ioctl(tty,TCGETA,data)
#define TTY_set(tty,data)	ioctl(tty,TCSETA,data)
#endif

#ifdef SGTTY
#include <sgtty.h>
#define TTY_STRUCT		struct sgttyb
#define TTY_FLAGS		sg_flags
#define TTY_get(tty,data)	ioctl(tty,TIOCGETP,data)
#define TTY_set(tty,data)	ioctl(tty,TIOCSETP,data)
#endif

#if !defined(_LIBC) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_VMS) && !defined(MAC_OS_pre_X)
#include <sys/ioctl.h>
#endif

#if defined(OPENSSL_SYS_MSDOS) && !defined(__CYGWIN32__) && !defined(OPENSSL_SYS_WINCE)
#include <conio.h>
#define fgets(a,b,c) noecho_fgets(a,b,c)
#endif

#ifdef OPENSSL_SYS_VMS
#include <ssdef.h>
#include <iodef.h>
#include <ttdef.h>
#include <descrip.h>
struct IOSB {
	short iosb$w_value;
	short iosb$w_count;
	long  iosb$l_info;
	};
#endif

#if defined(MAC_OS_pre_X) || defined(MAC_OS_GUSI_SOURCE)
/*
 * This one needs work. As a matter of fact the code is unoperational
 * and this is only a trick to get it compiled.
 *					<appro@@fy.chalmers.se>
 */
#define TTY_STRUCT int
#endif

#ifndef NX509_SIG
#define NX509_SIG 32
#endif

static void read_till_nl(FILE *);
static void recsig(int);
static void pushsig(void);
static void popsig(void);
#if defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_WIN16)
static int noecho_fgets(char *buf, int size, FILE *tty);
#endif
#ifdef SIGACTION
 static struct sigaction savsig[NX509_SIG];
#else
  static void (*savsig[NX509_SIG])(int );
#endif
static jmp_buf save;

int des_read_pw_string(char *buf, int length, const char *prompt,
	     int verify)
	{
	char buff[BUFSIZ];
	int ret;

	ret=des_read_pw(buf,buff,(length>BUFSIZ)?BUFSIZ:length,prompt,verify);
	OPENSSL_cleanse(buff,BUFSIZ);
	return(ret);
	}

#ifdef OPENSSL_SYS_WINCE

int des_read_pw(char *buf, char *buff, int size, const char *prompt, int verify)
	{ 
	memset(buf,0,size);
	memset(buff,0,size);
	return(0);
	}

#elif defined(OPENSSL_SYS_WIN16)

int des_read_pw(char *buf, char *buff, int size, char *prompt, int verify)
	{ 
	memset(buf,0,size);
	memset(buff,0,size);
	return(0);
	}

#else /* !OPENSSL_SYS_WINCE && !OPENSSL_SYS_WIN16 */

static void read_till_nl(FILE *in)
	{
#define SIZE 4
	char buf[SIZE+1];

	do	{
		fgets(buf,SIZE,in);
		} while (strchr(buf,'\n') == NULL);
	}


/* return 0 if ok, 1 (or -1) otherwise */
int des_read_pw(char *buf, char *buff, int size, const char *prompt,
	     int verify)
	{
#ifdef OPENSSL_SYS_VMS
	struct IOSB iosb;
	$DESCRIPTOR(terminal,"TT");
	long tty_orig[3], tty_new[3];
	long status;
	unsigned short channel = 0;
#else
#if !defined(OPENSSL_SYS_MSDOS) || defined(__DJGPP__)
	TTY_STRUCT tty_orig,tty_new;
#endif
#endif
	int number;
	int ok;
	/* statics are simply to avoid warnings about longjmp clobbering
	   things */
	static int ps;
	int is_a_tty;
	static FILE *tty;
	char *p;

	if (setjmp(save))
		{
		ok=0;
		goto error;
		}

	number=5;
	ok=0;
	ps=0;
	is_a_tty=1;
	tty=NULL;

#ifdef OPENSSL_SYS_MSDOS
	if ((tty=fopen("con","r")) == NULL)
		tty=stdin;
#elif defined(MAC_OS_pre_X) || defined(OPENSSL_SYS_VXWORKS)
	tty=stdin;
#else
#ifndef OPENSSL_SYS_MPE
	if ((tty=fopen("/dev/tty","r")) == NULL)
#endif
		tty=stdin;
#endif

#if defined(TTY_get) && !defined(OPENSSL_SYS_VMS)
	if (TTY_get(fileno(tty),&tty_orig) == -1)
		{
#ifdef ENOTTY
		if (errno == ENOTTY)
			is_a_tty=0;
		else
#endif
#ifdef EINVAL
		/* Ariel Glenn ariel@@columbia.edu reports that solaris
		 * can return EINVAL instead.  This should be ok */
		if (errno == EINVAL)
			is_a_tty=0;
		else
#endif
			return(-1);
		}
	memcpy(&(tty_new),&(tty_orig),sizeof(tty_orig));
#endif
#ifdef OPENSSL_SYS_VMS
	status = sys$assign(&terminal,&channel,0,0);
	if (status != SS$_NORMAL)
		return(-1);
	status=sys$qiow(0,channel,IO$_SENSEMODE,&iosb,0,0,tty_orig,12,0,0,0,0);
	if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))
		return(-1);
#endif

	pushsig();
	ps=1;

#ifdef TTY_FLAGS
	tty_new.TTY_FLAGS &= ~ECHO;
#endif

#if defined(TTY_set) && !defined(OPENSSL_SYS_VMS)
	if (is_a_tty && (TTY_set(fileno(tty),&tty_new) == -1))
#ifdef OPENSSL_SYS_MPE 
		; /* MPE lies -- echo really has been disabled */
#else
		return(-1);
#endif
#endif
#ifdef OPENSSL_SYS_VMS
	tty_new[0] = tty_orig[0];
	tty_new[1] = tty_orig[1] | TT$M_NOECHO;
	tty_new[2] = tty_orig[2];
	status = sys$qiow(0,channel,IO$_SETMODE,&iosb,0,0,tty_new,12,0,0,0,0);
	if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))
		return(-1);
#endif
	ps=2;

	while ((!ok) && (number--))
		{
		fputs(prompt,stderr);
		fflush(stderr);

		buf[0]='\0';
		fgets(buf,size,tty);
		if (feof(tty)) goto error;
		if (ferror(tty)) goto error;
		if ((p=(char *)strchr(buf,'\n')) != NULL)
			*p='\0';
		else	read_till_nl(tty);
		if (verify)
			{
			fprintf(stderr,"\nVerifying password - %s",prompt);
			fflush(stderr);
			buff[0]='\0';
			fgets(buff,size,tty);
			if (feof(tty)) goto error;
			if ((p=(char *)strchr(buff,'\n')) != NULL)
				*p='\0';
			else	read_till_nl(tty);
				
			if (strcmp(buf,buff) != 0)
				{
				fprintf(stderr,"\nVerify failure");
				fflush(stderr);
				break;
				/* continue; */
				}
			}
		ok=1;
		}

error:
	fprintf(stderr,"\n");
#if 0
	perror("fgets(tty)");
#endif
	/* What can we do if there is an error? */
#if defined(TTY_set) && !defined(OPENSSL_SYS_VMS)
	if (ps >= 2) TTY_set(fileno(tty),&tty_orig);
#endif
#ifdef OPENSSL_SYS_VMS
	if (ps >= 2)
		status = sys$qiow(0,channel,IO$_SETMODE,&iosb,0,0
			,tty_orig,12,0,0,0,0);
#endif
	
	if (ps >= 1) popsig();
	if (stdin != tty) fclose(tty);
#ifdef OPENSSL_SYS_VMS
	status = sys$dassgn(channel);
#endif
	return(!ok);
	}

static void pushsig(void)
	{
	int i;
#ifdef SIGACTION
	struct sigaction sa;

	memset(&sa,0,sizeof sa);
	sa.sa_handler=recsig;
#endif

	for (i=1; i<NX509_SIG; i++)
		{
#ifdef SIGUSR1
		if (i == SIGUSR1)
			continue;
#endif
#ifdef SIGUSR2
		if (i == SIGUSR2)
			continue;
#endif
#ifdef SIGACTION
		sigaction(i,&sa,&savsig[i]);
#else
		savsig[i]=signal(i,recsig);
#endif
		}

#ifdef SIGWINCH
	signal(SIGWINCH,SIG_DFL);
#endif
	}

static void popsig(void)
	{
	int i;

	for (i=1; i<NX509_SIG; i++)
		{
#ifdef SIGUSR1
		if (i == SIGUSR1)
			continue;
#endif
#ifdef SIGUSR2
		if (i == SIGUSR2)
			continue;
#endif
#ifdef SIGACTION
		sigaction(i,&savsig[i],NULL);
#else
		signal(i,savsig[i]);
#endif
		}
	}

static void recsig(int i)
	{
	longjmp(save,1);
#ifdef LINT
	i=i;
#endif
	}

#ifdef OPENSSL_SYS_MSDOS
static int noecho_fgets(char *buf, int size, FILE *tty)
	{
	int i;
	char *p;

	p=buf;
	for (;;)
		{
		if (size == 0)
			{
			*p='\0';
			break;
			}
		size--;
#ifdef WIN16TTY
		i=_inchar();
#else
		i=getch();
#endif
		if (i == '\r') i='\n';
		*(p++)=i;
		if (i == '\n')
			{
			*p='\0';
			break;
			}
		}
#ifdef WIN_CONSOLE_BUG
/* Win95 has several evil console bugs: one of these is that the
 * last character read using getch() is passed to the next read: this is
 * usually a CR so this can be trouble. No STDIO fix seems to work but
 * flushing the console appears to do the trick.
 */
		{
			HANDLE inh;
			inh = GetStdHandle(STD_INPUT_HANDLE);
			FlushConsoleInputBuffer(inh);
		}
#endif
	return(strlen(buf));
	}
#endif
#endif /* !OPENSSL_SYS_WINCE && !WIN16 */
@


1.9
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@@


1.8
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d104 1
d107 1
d138 1
a138 1
#if defined(OPENSSL_SYS_VSWORKS)
d172 1
a172 1
#if defined(OPENSSL_SYS_MSDOS) && !defined(__CYGWIN32__)
d223 1
a223 1
	memset(buff,0,BUFSIZ);
d227 19
a245 1
#ifndef OPENSSL_SYS_WIN16
d297 1
a297 1
#elif defined(MAC_OS_pre_X) || defined(OPENSSL_SYS_VSWORKS)
a415 11
#else /* OPENSSL_SYS_WIN16 */

int des_read_pw(char *buf, char *buff, int size, char *prompt, int verify)
	{ 
	memset(buf,0,size);
	memset(buff,0,size);
	return(0);
	}

#endif

d478 1
a478 1
#if defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_WIN16)
d521 1
@


1.7
log
@merge with 0.9.7-beta1
@
text
@d249 1
a249 1
#ifndef OPENSSL_SYS_MSDOS
@


1.6
log
@remove whitespace changes (keep diffs to 0.9.7-beta1 minimal)
@
text
@d214 1
a214 1
int _ossl_old_des_read_pw_string(char *buf, int length, const char *prompt,
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d210 1
a210 1
 static void (*savsig[NX509_SIG])(int );
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d59 2
a60 2
#if !defined(MSDOS) && !defined(VMS) && !defined(WIN32)
#include <openssl/opensslconf.h>
d81 1
a81 1
#undef WIN16
d95 1
a95 1
#ifdef VMS			/* prototypes for sys$whatever */
d130 1
a130 1
#if !defined(TERMIO) && !defined(TERMIOS) && !defined(VMS) && !defined(MSDOS) && !defined(MAC_OS_pre_X) && !defined(MAC_OS_GUSI_SOURCE)
d136 6
d166 1
a166 1
#if !defined(_LIBC) && !defined(MSDOS) && !defined(VMS) && !defined(MAC_OS_pre_X)
d170 1
a170 1
#if defined(MSDOS) && !defined(__CYGWIN32__)
d175 1
a175 1
#ifdef VMS
d204 1
a204 1
#if defined(MSDOS) && !defined(WIN16)
d210 1
a210 1
  static void (*savsig[NX509_SIG])(int );
d214 1
a214 1
int des_read_pw_string(char *buf, int length, const char *prompt,
d225 1
a225 1
#ifndef WIN16
d242 1
a242 1
#ifdef VMS
d249 1
a249 1
#ifndef MSDOS
d274 1
a274 1
#ifdef MSDOS
d277 1
a277 1
#elif defined(MAC_OS_pre_X)
d280 1
a280 1
#ifndef MPE
d286 1
a286 1
#if defined(TTY_get) && !defined(VMS)
d305 1
a305 1
#ifdef VMS
d321 1
a321 1
#if defined(TTY_set) && !defined(VMS)
d323 1
a323 1
#ifdef MPE 
d329 1
a329 1
#ifdef VMS
d375 1
a375 1
#ifdef DEBUG
d379 1
a379 1
#if defined(TTY_set) && !defined(VMS)
d382 1
a382 1
#ifdef VMS
d390 1
a390 1
#ifdef VMS
d396 1
a396 1
#else /* WIN16 */
d469 1
a469 1
#if defined(MSDOS) && !defined(WIN16)
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d164 1
a164 1
#ifdef MSDOS
d268 7
a274 1
#ifndef MSDOS
d276 1
d278 1
a278 4
#else /* MSDOS */
	if ((tty=fopen("con","r")) == NULL)
		tty=stdin;
#endif /* MSDOS */
d317 3
d321 1
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d61 5
a65 1
#include OPENSSL_UNISTD
d130 1
a130 1
#if !defined(TERMIO) && !defined(TERMIOS) && !defined(VMS) && !defined(MSDOS)
d160 1
a160 1
#if !defined(_LIBC) && !defined(MSDOS) && !defined(VMS)
d179 9
@


1.1
log
@Initial revision
@
text
@d59 15
d75 1
d84 1
d86 1
d91 13
a180 1
#ifndef NOPROTO
a187 10
#else
static void read_till_nl();
static void recsig();
static void pushsig();
static void popsig();
#if defined(MSDOS) && !defined(WIN16)
static int noecho_fgets();
#endif
#endif

a190 1
# ifndef NOPROTO
a191 3
# else
  static void (*savsig[NX509_SIG])();
# endif
d195 2
a196 5
int des_read_pw_string(buf, length, prompt, verify)
char *buf;
int length;
char *prompt;
int verify;
d208 1
a208 2
static void read_till_nl(in)
FILE *in;
d220 2
a221 6
int des_read_pw(buf, buff, size, prompt, verify)
char *buf;
char *buff;
int size;
char *prompt;
int verify;
d234 8
a241 4
	int number=5;
	int ok=0;
	int ps=0;
	int is_a_tty=1;
d243 11
a253 2
	FILE *tty=NULL;
	char *p;
d283 1
a283 1
	status = SYS$ASSIGN(&terminal,&channel,0,0);
d286 1
a286 1
	status=SYS$QIOW(0,channel,IO$_SENSEMODE,&iosb,0,0,tty_orig,12,0,0,0,0);
a290 5
	if (setjmp(save))
		{
		ok=0;
		goto error;
		}
d306 1
a306 1
	status = SYS$QIOW(0,channel,IO$_SETMODE,&iosb,0,0,tty_new,12,0,0,0,0);
d352 1
a352 1
#if defined(TTY_set) && !defined(VMS) 
d357 1
a357 1
		status = SYS$QIOW(0,channel,IO$_SETMODE,&iosb,0,0
d364 1
a364 1
	status = SYS$DASSGN(channel);
d371 1
a371 6
int des_read_pw(buf, buff, size, prompt, verify)
char *buf;
char *buff;
int size;
char *prompt;
int verify;
d380 1
a380 1
static void pushsig()
d383 6
d401 1
a401 1
		sigaction(i,NULL,&savsig[i]);
d412 1
a412 1
static void popsig()
d434 1
a434 2
static void recsig(i)
int i;
d443 1
a443 4
static int noecho_fgets(buf,size,tty)
char *buf;
int size;
FILE *tty;
d470 12
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a58 19
#include <openssl/e_os2.h>
#if !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_VMS) && !defined(OPENSSL_SYS_WIN32)
#ifdef OPENSSL_UNISTD
# include OPENSSL_UNISTD
#else
# include <unistd.h>
#endif
/* If unistd.h defines _POSIX_VERSION, we conclude that we
 * are on a POSIX system and have sigaction and termios. */
#if defined(_POSIX_VERSION)

# define SIGACTION
# if !defined(TERMIOS) && !defined(TERMIO) && !defined(SGTTY)
# define TERMIOS
# endif

#endif
#endif

a59 1

d61 1
a61 1
#undef OPENSSL_SYS_WIN16
a67 1
#include "cryptlib.h"
a68 1
#include <stdio.h>
a72 13
#ifdef OPENSSL_SYS_VMS			/* prototypes for sys$whatever */
#include <starlet.h>
#ifdef __DECC
#pragma message disable DOLLARID
#endif
#endif

#ifdef WIN_CONSOLE_BUG
#include <windows.h>
#include <wincon.h>
#endif


d95 1
a95 1
#if !defined(TERMIO) && !defined(TERMIOS) && !defined(OPENSSL_SYS_VMS) && !defined(OPENSSL_SYS_MSDOS) && !defined(MAC_OS_pre_X) && !defined(MAC_OS_GUSI_SOURCE)
a100 6
#if defined(OPENSSL_SYS_VSWORKS)
#undef TERMIOS
#undef TERMIO
#undef SGTTY
#endif

d125 1
a125 1
#if !defined(_LIBC) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_VMS) && !defined(MAC_OS_pre_X)
d129 1
a129 1
#if defined(OPENSSL_SYS_MSDOS) && !defined(__CYGWIN32__)
d134 1
a134 1
#ifdef OPENSSL_SYS_VMS
a145 9
#if defined(MAC_OS_pre_X) || defined(MAC_OS_GUSI_SOURCE)
/*
 * This one needs work. As a matter of fact the code is unoperational
 * and this is only a trick to get it compiled.
 *					<appro@@fy.chalmers.se>
 */
#define TTY_STRUCT int
#endif

d150 1
d155 1
a155 1
#if defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_WIN16)
d158 10
d171 1
d173 3
d179 5
a183 2
int des_read_pw_string(char *buf, int length, const char *prompt,
	     int verify)
d193 1
a193 1
#ifndef OPENSSL_SYS_WIN16
d195 2
a196 1
static void read_till_nl(FILE *in)
d208 6
a213 2
int des_read_pw(char *buf, char *buff, int size, const char *prompt,
	     int verify)
d215 1
a215 1
#ifdef OPENSSL_SYS_VMS
d222 1
a222 1
#ifndef OPENSSL_SYS_MSDOS
d226 6
a231 7
	int number;
	int ok;
	/* statics are simply to avoid warnings about longjmp clobbering
	   things */
	static int ps;
	int is_a_tty;
	static FILE *tty;
d234 4
a237 13
	if (setjmp(save))
		{
		ok=0;
		goto error;
		}

	number=5;
	ok=0;
	ps=0;
	is_a_tty=1;
	tty=NULL;

#ifdef OPENSSL_SYS_MSDOS
d240 1
a240 8
#elif defined(MAC_OS_pre_X) || defined(OPENSSL_SYS_VSWORKS)
	tty=stdin;
#else
#ifndef OPENSSL_SYS_MPE
	if ((tty=fopen("/dev/tty","r")) == NULL)
#endif
		tty=stdin;
#endif
d242 1
a242 1
#if defined(TTY_get) && !defined(OPENSSL_SYS_VMS)
d261 2
a262 2
#ifdef OPENSSL_SYS_VMS
	status = sys$assign(&terminal,&channel,0,0);
d265 1
a265 1
	status=sys$qiow(0,channel,IO$_SENSEMODE,&iosb,0,0,tty_orig,12,0,0,0,0);
d270 5
d282 1
a282 1
#if defined(TTY_set) && !defined(OPENSSL_SYS_VMS)
a283 3
#ifdef OPENSSL_SYS_MPE 
		; /* MPE lies -- echo really has been disabled */
#else
d286 1
a286 2
#endif
#ifdef OPENSSL_SYS_VMS
d290 1
a290 1
	status = sys$qiow(0,channel,IO$_SETMODE,&iosb,0,0,tty_new,12,0,0,0,0);
d332 1
a332 1
#if 0
d336 1
a336 1
#if defined(TTY_set) && !defined(OPENSSL_SYS_VMS)
d339 1
a339 1
#ifdef OPENSSL_SYS_VMS
d341 1
a341 1
		status = sys$qiow(0,channel,IO$_SETMODE,&iosb,0,0
d347 2
a348 2
#ifdef OPENSSL_SYS_VMS
	status = sys$dassgn(channel);
d353 1
a353 1
#else /* OPENSSL_SYS_WIN16 */
d355 6
a360 1
int des_read_pw(char *buf, char *buff, int size, char *prompt, int verify)
d369 1
a369 1
static void pushsig(void)
a371 6
#ifdef SIGACTION
	struct sigaction sa;

	memset(&sa,0,sizeof sa);
	sa.sa_handler=recsig;
#endif
d384 1
a384 1
		sigaction(i,&sa,&savsig[i]);
d395 1
a395 1
static void popsig(void)
d417 2
a418 1
static void recsig(int i)
d426 5
a430 2
#if defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_WIN16)
static int noecho_fgets(char *buf, int size, FILE *tty)
a456 12
#ifdef WIN_CONSOLE_BUG
/* Win95 has several evil console bugs: one of these is that the
 * last character read using getch() is passed to the next read: this is
 * usually a CR so this can be trouble. No STDIO fix seems to work but
 * flushing the console appears to do the trick.
 */
		{
			HANDLE inh;
			inh = GetStdHandle(STD_INPUT_HANDLE);
			FlushConsoleInputBuffer(inh);
		}
#endif
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d249 1
a249 1
#if !defined(OPENSSL_SYS_MSDOS) || defined(__DJGPP__)
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@a103 1
#ifndef OPENSSL_SYS_WINCE
a105 1
#endif
d136 1
a136 1
#if defined(OPENSSL_SYS_VXWORKS)
d170 1
a170 1
#if defined(OPENSSL_SYS_MSDOS) && !defined(__CYGWIN32__) && !defined(OPENSSL_SYS_WINCE)
d221 1
a221 1
	OPENSSL_cleanse(buff,BUFSIZ);
d225 1
a225 19
#ifdef OPENSSL_SYS_WINCE

int des_read_pw(char *buf, char *buff, int size, const char *prompt, int verify)
	{ 
	memset(buf,0,size);
	memset(buff,0,size);
	return(0);
	}

#elif defined(OPENSSL_SYS_WIN16)

int des_read_pw(char *buf, char *buff, int size, char *prompt, int verify)
	{ 
	memset(buf,0,size);
	memset(buff,0,size);
	return(0);
	}

#else /* !OPENSSL_SYS_WINCE && !OPENSSL_SYS_WIN16 */
d277 1
a277 1
#elif defined(MAC_OS_pre_X) || defined(OPENSSL_SYS_VXWORKS)
d396 11
d469 1
a469 1
#ifdef OPENSSL_SYS_MSDOS
a511 1
#endif /* !OPENSSL_SYS_WINCE && !WIN16 */
@


