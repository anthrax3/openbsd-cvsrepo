head	1.17;
access;
symbols
	OPENBSD_6_0:1.16.0.8
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.4
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	butholakala:1.1.1.3
	openssl_1_0_1_g:1.1.1.3
	OPENSSL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.8
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.4
	OPENBSD_5_4_BASE:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.2
	OPENBSD_5_3_BASE:1.1.1.2
	openssl_1_0_1_c:1.1.1.2
	OPENBSD_5_2:1.1.1.1.0.6
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.8
	openssl_1_0_0_f:1.1.1.1
	openssl_1_0_0_e:1.1.1.1
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	openssh_1_0_0_a:1.1.1.1
	openssl:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.09.03.11.33.37;	author beck;	state dead;
branches;
next	1.16;
commitid	HnbXxsegngek41U2;

1.16
date	2015.02.11.04.05.14;	author beck;	state Exp;
branches;
next	1.15;
commitid	BiQ5VBK0FHpjQNna;

1.15
date	2015.02.11.03.55.42;	author beck;	state Exp;
branches;
next	1.14;
commitid	1omCojArcEf3nCrU;

1.14
date	2014.10.07.04.58.50;	author miod;	state Exp;
branches;
next	1.13;
commitid	BLAnrVp6Vhr1AwVY;

1.13
date	2014.07.13.15.47.51;	author logan;	state Exp;
branches;
next	1.12;
commitid	zx5DHpWUmXXLeJoY;

1.12
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches;
next	1.11;
commitid	G74O1dmRukKsW7IJ;

1.11
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.10;
commitid	yQEL1wOWIearrW15;

1.10
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.9;
commitid	nzndm3zqPmFurSaK;

1.9
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	mJUVYpkFBZ0Zv2bG;

1.8
date	2014.06.07.14.41.57;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	2nvnQBrv22dLtvTt;

1.7
date	2014.05.30.06.22.57;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2014.05.22.21.12.16;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2014.05.06.03.56.27;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2014.04.27.20.26.48;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.20.12.30.41;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2010.10.01.22.54.06;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.10.01.22.54.06;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2012.10.13.21.23.39;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.04.13.15.16.33;	author miod;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Remove the libssl/src directory
@
text
@/* $OpenBSD: ec_ameth.c,v 1.16 2015/02/11 04:05:14 beck Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2006.
 */
/* ====================================================================
 * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>

#include <openssl/opensslconf.h>

#include <openssl/bn.h>
#include <openssl/ec.h>
#include <openssl/err.h>
#include <openssl/x509.h>

#ifndef OPENSSL_NO_CMS
#include <openssl/cms.h>
#endif

#include "asn1_locl.h"

static int 
eckey_param2type(int *pptype, void **ppval, EC_KEY * ec_key)
{
	const EC_GROUP *group;
	int nid;
	if (ec_key == NULL || (group = EC_KEY_get0_group(ec_key)) == NULL) {
		ECerr(EC_F_ECKEY_PARAM2TYPE, EC_R_MISSING_PARAMETERS);
		return 0;
	}
	if (EC_GROUP_get_asn1_flag(group) &&
	    (nid = EC_GROUP_get_curve_name(group))) {
		/* we have a 'named curve' => just set the OID */
		*ppval = OBJ_nid2obj(nid);
		*pptype = V_ASN1_OBJECT;
	} else {
		/* explicit parameters */
		ASN1_STRING *pstr = NULL;
		pstr = ASN1_STRING_new();
		if (!pstr)
			return 0;
		pstr->length = i2d_ECParameters(ec_key, &pstr->data);
		if (pstr->length <= 0) {
			ASN1_STRING_free(pstr);
			ECerr(EC_F_ECKEY_PARAM2TYPE, ERR_R_EC_LIB);
			return 0;
		}
		*ppval = pstr;
		*pptype = V_ASN1_SEQUENCE;
	}
	return 1;
}

static int 
eckey_pub_encode(X509_PUBKEY * pk, const EVP_PKEY * pkey)
{
	EC_KEY *ec_key = pkey->pkey.ec;
	void *pval = NULL;
	int ptype;
	unsigned char *penc = NULL, *p;
	int penclen;

	if (!eckey_param2type(&ptype, &pval, ec_key)) {
		ECerr(EC_F_ECKEY_PUB_ENCODE, ERR_R_EC_LIB);
		return 0;
	}
	penclen = i2o_ECPublicKey(ec_key, NULL);
	if (penclen <= 0)
		goto err;
	penc = malloc(penclen);
	if (!penc)
		goto err;
	p = penc;
	penclen = i2o_ECPublicKey(ec_key, &p);
	if (penclen <= 0)
		goto err;
	if (X509_PUBKEY_set0_param(pk, OBJ_nid2obj(EVP_PKEY_EC),
		ptype, pval, penc, penclen))
		return 1;
err:
	if (ptype == V_ASN1_OBJECT)
		ASN1_OBJECT_free(pval);
	else
		ASN1_STRING_free(pval);
	free(penc);
	return 0;
}

static EC_KEY *
eckey_type2param(int ptype, void *pval)
{
	EC_KEY *eckey = NULL;

	if (ptype == V_ASN1_SEQUENCE) {
		ASN1_STRING *pstr = pval;
		const unsigned char *pm = NULL;
		int pmlen;

		pm = pstr->data;
		pmlen = pstr->length;
		if (!(eckey = d2i_ECParameters(NULL, &pm, pmlen))) {
			ECerr(EC_F_ECKEY_TYPE2PARAM, EC_R_DECODE_ERROR);
			goto ecerr;
		}
	} else if (ptype == V_ASN1_OBJECT) {
		ASN1_OBJECT *poid = pval;
		EC_GROUP *group;

		/*
		 * type == V_ASN1_OBJECT => the parameters are given by an
		 * asn1 OID
		 */
		if ((eckey = EC_KEY_new()) == NULL) {
			ECerr(EC_F_ECKEY_TYPE2PARAM, ERR_R_MALLOC_FAILURE);
			goto ecerr;
		}
		group = EC_GROUP_new_by_curve_name(OBJ_obj2nid(poid));
		if (group == NULL)
			goto ecerr;
		EC_GROUP_set_asn1_flag(group, OPENSSL_EC_NAMED_CURVE);
		if (EC_KEY_set_group(eckey, group) == 0)
			goto ecerr;
		EC_GROUP_free(group);
	} else {
		ECerr(EC_F_ECKEY_TYPE2PARAM, EC_R_DECODE_ERROR);
		goto ecerr;
	}

	return eckey;

ecerr:
	if (eckey)
		EC_KEY_free(eckey);
	return NULL;
}

static int 
eckey_pub_decode(EVP_PKEY * pkey, X509_PUBKEY * pubkey)
{
	const unsigned char *p = NULL;
	void *pval;
	int ptype, pklen;
	EC_KEY *eckey = NULL;
	X509_ALGOR *palg;

	if (!X509_PUBKEY_get0_param(NULL, &p, &pklen, &palg, pubkey))
		return 0;
	X509_ALGOR_get0(NULL, &ptype, &pval, palg);

	eckey = eckey_type2param(ptype, pval);

	if (!eckey) {
		ECerr(EC_F_ECKEY_PUB_DECODE, ERR_R_EC_LIB);
		return 0;
	}
	/* We have parameters now set public key */
	if (!o2i_ECPublicKey(&eckey, &p, pklen)) {
		ECerr(EC_F_ECKEY_PUB_DECODE, EC_R_DECODE_ERROR);
		goto ecerr;
	}
	EVP_PKEY_assign_EC_KEY(pkey, eckey);
	return 1;

ecerr:
	if (eckey)
		EC_KEY_free(eckey);
	return 0;
}

static int 
eckey_pub_cmp(const EVP_PKEY * a, const EVP_PKEY * b)
{
	int r;
	const EC_GROUP *group = EC_KEY_get0_group(b->pkey.ec);
	const EC_POINT *pa = EC_KEY_get0_public_key(a->pkey.ec), *pb = EC_KEY_get0_public_key(b->pkey.ec);

	r = EC_POINT_cmp(group, pa, pb, NULL);
	if (r == 0)
		return 1;
	if (r == 1)
		return 0;
	return -2;
}

static int 
eckey_priv_decode(EVP_PKEY * pkey, PKCS8_PRIV_KEY_INFO * p8)
{
	const unsigned char *p = NULL;
	void *pval;
	int ptype, pklen;
	EC_KEY *eckey = NULL;
	X509_ALGOR *palg;

	if (!PKCS8_pkey_get0(NULL, &p, &pklen, &palg, p8))
		return 0;
	X509_ALGOR_get0(NULL, &ptype, &pval, palg);

	eckey = eckey_type2param(ptype, pval);

	if (!eckey)
		goto ecliberr;

	/* We have parameters now set private key */
	if (!d2i_ECPrivateKey(&eckey, &p, pklen)) {
		ECerr(EC_F_ECKEY_PRIV_DECODE, EC_R_DECODE_ERROR);
		goto ecerr;
	}
	/* calculate public key (if necessary) */
	if (EC_KEY_get0_public_key(eckey) == NULL) {
		const BIGNUM *priv_key;
		const EC_GROUP *group;
		EC_POINT *pub_key;
		/*
		 * the public key was not included in the SEC1 private key =>
		 * calculate the public key
		 */
		group = EC_KEY_get0_group(eckey);
		pub_key = EC_POINT_new(group);
		if (pub_key == NULL) {
			ECerr(EC_F_ECKEY_PRIV_DECODE, ERR_R_EC_LIB);
			goto ecliberr;
		}
		if (!EC_POINT_copy(pub_key, EC_GROUP_get0_generator(group))) {
			EC_POINT_free(pub_key);
			ECerr(EC_F_ECKEY_PRIV_DECODE, ERR_R_EC_LIB);
			goto ecliberr;
		}
		priv_key = EC_KEY_get0_private_key(eckey);
		if (!EC_POINT_mul(group, pub_key, priv_key, NULL, NULL, NULL)) {
			EC_POINT_free(pub_key);
			ECerr(EC_F_ECKEY_PRIV_DECODE, ERR_R_EC_LIB);
			goto ecliberr;
		}
		if (EC_KEY_set_public_key(eckey, pub_key) == 0) {
			EC_POINT_free(pub_key);
			ECerr(EC_F_ECKEY_PRIV_DECODE, ERR_R_EC_LIB);
			goto ecliberr;
		}
		EC_POINT_free(pub_key);
	}
	EVP_PKEY_assign_EC_KEY(pkey, eckey);
	return 1;

ecliberr:
	ECerr(EC_F_ECKEY_PRIV_DECODE, ERR_R_EC_LIB);
ecerr:
	if (eckey)
		EC_KEY_free(eckey);
	return 0;
}

static int 
eckey_priv_encode(PKCS8_PRIV_KEY_INFO * p8, const EVP_PKEY * pkey)
{
	EC_KEY *ec_key;
	unsigned char *ep, *p;
	int eplen, ptype;
	void *pval;
	unsigned int tmp_flags, old_flags;

	ec_key = pkey->pkey.ec;

	if (!eckey_param2type(&ptype, &pval, ec_key)) {
		ECerr(EC_F_ECKEY_PRIV_ENCODE, EC_R_DECODE_ERROR);
		return 0;
	}
	/* set the private key */

	/*
	 * do not include the parameters in the SEC1 private key see PKCS#11
	 * 12.11
	 */
	old_flags = EC_KEY_get_enc_flags(ec_key);
	tmp_flags = old_flags | EC_PKEY_NO_PARAMETERS;
	EC_KEY_set_enc_flags(ec_key, tmp_flags);
	eplen = i2d_ECPrivateKey(ec_key, NULL);
	if (!eplen) {
		EC_KEY_set_enc_flags(ec_key, old_flags);
		ECerr(EC_F_ECKEY_PRIV_ENCODE, ERR_R_EC_LIB);
		return 0;
	}
	ep = malloc(eplen);
	if (!ep) {
		EC_KEY_set_enc_flags(ec_key, old_flags);
		ECerr(EC_F_ECKEY_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);
		return 0;
	}
	p = ep;
	if (!i2d_ECPrivateKey(ec_key, &p)) {
		EC_KEY_set_enc_flags(ec_key, old_flags);
		free(ep);
		ECerr(EC_F_ECKEY_PRIV_ENCODE, ERR_R_EC_LIB);
		return 0;
	}
	/* restore old encoding flags */
	EC_KEY_set_enc_flags(ec_key, old_flags);

	if (!PKCS8_pkey_set0(p8, OBJ_nid2obj(NID_X9_62_id_ecPublicKey), 0,
		ptype, pval, ep, eplen))
		return 0;

	return 1;
}

static int 
int_ec_size(const EVP_PKEY * pkey)
{
	return ECDSA_size(pkey->pkey.ec);
}

static int 
ec_bits(const EVP_PKEY * pkey)
{
	BIGNUM *order = BN_new();
	const EC_GROUP *group;
	int ret;

	if (!order) {
		ERR_clear_error();
		return 0;
	}
	group = EC_KEY_get0_group(pkey->pkey.ec);
	if (!EC_GROUP_get_order(group, order, NULL)) {
		BN_free(order);
		ERR_clear_error();
		return 0;
	}
	ret = BN_num_bits(order);
	BN_free(order);
	return ret;
}

static int 
ec_missing_parameters(const EVP_PKEY * pkey)
{
	if (EC_KEY_get0_group(pkey->pkey.ec) == NULL)
		return 1;
	return 0;
}

static int 
ec_copy_parameters(EVP_PKEY * to, const EVP_PKEY * from)
{
	return EC_KEY_set_group(to->pkey.ec, EC_KEY_get0_group(from->pkey.ec));
}

static int 
ec_cmp_parameters(const EVP_PKEY * a, const EVP_PKEY * b)
{
	const EC_GROUP *group_a = EC_KEY_get0_group(a->pkey.ec), *group_b = EC_KEY_get0_group(b->pkey.ec);
	if (EC_GROUP_cmp(group_a, group_b, NULL))
		return 0;
	else
		return 1;
}

static void 
int_ec_free(EVP_PKEY * pkey)
{
	EC_KEY_free(pkey->pkey.ec);
}

static int 
do_EC_KEY_print(BIO * bp, const EC_KEY * x, int off, int ktype)
{
	unsigned char *buffer = NULL;
	const char *ecstr;
	size_t buf_len = 0, i;
	int ret = 0, reason = ERR_R_BIO_LIB;
	BIGNUM *pub_key = NULL, *order = NULL;
	BN_CTX *ctx = NULL;
	const EC_GROUP *group;
	const EC_POINT *public_key;
	const BIGNUM *priv_key;

	if (x == NULL || (group = EC_KEY_get0_group(x)) == NULL) {
		reason = ERR_R_PASSED_NULL_PARAMETER;
		goto err;
	}
	ctx = BN_CTX_new();
	if (ctx == NULL) {
		reason = ERR_R_MALLOC_FAILURE;
		goto err;
	}
	if (ktype > 0) {
		public_key = EC_KEY_get0_public_key(x);
		if ((pub_key = EC_POINT_point2bn(group, public_key,
			    EC_KEY_get_conv_form(x), NULL, ctx)) == NULL) {
			reason = ERR_R_EC_LIB;
			goto err;
		}
		if (pub_key)
			buf_len = (size_t) BN_num_bytes(pub_key);
	}
	if (ktype == 2) {
		priv_key = EC_KEY_get0_private_key(x);
		if (priv_key && (i = (size_t) BN_num_bytes(priv_key)) > buf_len)
			buf_len = i;
	} else
		priv_key = NULL;

	if (ktype > 0) {
		buf_len += 10;
		if ((buffer = malloc(buf_len)) == NULL) {
			reason = ERR_R_MALLOC_FAILURE;
			goto err;
		}
	}
	if (ktype == 2)
		ecstr = "Private-Key";
	else if (ktype == 1)
		ecstr = "Public-Key";
	else
		ecstr = "ECDSA-Parameters";

	if (!BIO_indent(bp, off, 128))
		goto err;
	if ((order = BN_new()) == NULL)
		goto err;
	if (!EC_GROUP_get_order(group, order, NULL))
		goto err;
	if (BIO_printf(bp, "%s: (%d bit)\n", ecstr,
		BN_num_bits(order)) <= 0)
		goto err;

	if ((priv_key != NULL) && !ASN1_bn_print(bp, "priv:", priv_key,
		buffer, off))
		goto err;
	if ((pub_key != NULL) && !ASN1_bn_print(bp, "pub: ", pub_key,
		buffer, off))
		goto err;
	if (!ECPKParameters_print(bp, group, off))
		goto err;
	ret = 1;
err:
	if (!ret)
		ECerr(EC_F_DO_EC_KEY_PRINT, reason);
	BN_free(pub_key);
	BN_free(order);
	BN_CTX_free(ctx);
	free(buffer);
	return (ret);
}

static int 
eckey_param_decode(EVP_PKEY * pkey,
    const unsigned char **pder, int derlen)
{
	EC_KEY *eckey;
	if (!(eckey = d2i_ECParameters(NULL, pder, derlen))) {
		ECerr(EC_F_ECKEY_PARAM_DECODE, ERR_R_EC_LIB);
		return 0;
	}
	EVP_PKEY_assign_EC_KEY(pkey, eckey);
	return 1;
}

static int 
eckey_param_encode(const EVP_PKEY * pkey, unsigned char **pder)
{
	return i2d_ECParameters(pkey->pkey.ec, pder);
}

static int 
eckey_param_print(BIO * bp, const EVP_PKEY * pkey, int indent,
    ASN1_PCTX * ctx)
{
	return do_EC_KEY_print(bp, pkey->pkey.ec, indent, 0);
}

static int 
eckey_pub_print(BIO * bp, const EVP_PKEY * pkey, int indent,
    ASN1_PCTX * ctx)
{
	return do_EC_KEY_print(bp, pkey->pkey.ec, indent, 1);
}


static int 
eckey_priv_print(BIO * bp, const EVP_PKEY * pkey, int indent,
    ASN1_PCTX * ctx)
{
	return do_EC_KEY_print(bp, pkey->pkey.ec, indent, 2);
}

static int 
old_ec_priv_decode(EVP_PKEY * pkey,
    const unsigned char **pder, int derlen)
{
	EC_KEY *ec;
	if (!(ec = d2i_ECPrivateKey(NULL, pder, derlen))) {
		ECerr(EC_F_OLD_EC_PRIV_DECODE, EC_R_DECODE_ERROR);
		return 0;
	}
	EVP_PKEY_assign_EC_KEY(pkey, ec);
	return 1;
}

static int 
old_ec_priv_encode(const EVP_PKEY * pkey, unsigned char **pder)
{
	return i2d_ECPrivateKey(pkey->pkey.ec, pder);
}

static int 
ec_pkey_ctrl(EVP_PKEY * pkey, int op, long arg1, void *arg2)
{
	switch (op) {
	case ASN1_PKEY_CTRL_PKCS7_SIGN:
		if (arg1 == 0) {
			int snid, hnid;
			X509_ALGOR *alg1, *alg2;
			PKCS7_SIGNER_INFO_get0_algs(arg2, NULL, &alg1, &alg2);
			if (alg1 == NULL || alg1->algorithm == NULL)
				return -1;
			hnid = OBJ_obj2nid(alg1->algorithm);
			if (hnid == NID_undef)
				return -1;
			if (!OBJ_find_sigid_by_algs(&snid, hnid, EVP_PKEY_id(pkey)))
				return -1;
			X509_ALGOR_set0(alg2, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0);
		}
		return 1;
#ifndef OPENSSL_NO_CMS
	case ASN1_PKEY_CTRL_CMS_SIGN:
		if (arg1 == 0) {
			int snid, hnid;
			X509_ALGOR *alg1, *alg2;
			CMS_SignerInfo_get0_algs(arg2, NULL, NULL,
			    &alg1, &alg2);
			if (alg1 == NULL || alg1->algorithm == NULL)
				return -1;
			hnid = OBJ_obj2nid(alg1->algorithm);
			if (hnid == NID_undef)
				return -1;
			if (!OBJ_find_sigid_by_algs(&snid, hnid, EVP_PKEY_id(pkey)))
				return -1;
			X509_ALGOR_set0(alg2, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0);
		}
		return 1;
#endif

	case ASN1_PKEY_CTRL_DEFAULT_MD_NID:
		*(int *) arg2 = NID_sha1;
		return 2;

	default:
		return -2;

	}

}

const EVP_PKEY_ASN1_METHOD eckey_asn1_meth = {
	.pkey_id = EVP_PKEY_EC,
	.pkey_base_id = EVP_PKEY_EC,

	.pem_str = "EC",
	.info = "OpenSSL EC algorithm",

	.pub_decode = eckey_pub_decode,
	.pub_encode = eckey_pub_encode,
	.pub_cmp = eckey_pub_cmp,
	.pub_print = eckey_pub_print,

	.priv_decode = eckey_priv_decode,
	.priv_encode = eckey_priv_encode,
	.priv_print = eckey_priv_print,

	.pkey_size = int_ec_size,
	.pkey_bits = ec_bits,

	.param_decode = eckey_param_decode,
	.param_encode = eckey_param_encode,
	.param_missing = ec_missing_parameters,
	.param_copy = ec_copy_parameters,
	.param_cmp = ec_cmp_parameters,
	.param_print = eckey_param_print,

	.pkey_free = int_ec_free,
	.pkey_ctrl = ec_pkey_ctrl,
	.old_priv_decode = old_ec_priv_decode,
	.old_priv_encode = old_ec_priv_encode
};
@


1.16
log
@Guenther has plans for OPENSSL_NO_CMS, so revert this for the moment.
@
text
@d1 1
a1 1
/* $OpenBSD: ec_ameth.c,v 1.15 2015/02/11 03:55:42 beck Exp $ */
@


1.15
log
@get rid of OPENSSL_NO_CMS code we do not use.
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_ameth.c,v 1.14 2014/10/07 04:58:50 miod Exp $ */
d68 3
d576 18
@


1.14
log
@EC_KEY_set_group() does an EC_GROUP_dup() of its argument, so we don't
need to do it in ec_copy_parameters() prior to invoking EC_KEY_set_group().
ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_ameth.c,v 1.13 2014/07/13 15:47:51 logan Exp $ */
a67 3
#ifndef OPENSSL_NO_CMS
#include <openssl/cms.h>
#endif
a572 18
#ifndef OPENSSL_NO_CMS
	case ASN1_PKEY_CTRL_CMS_SIGN:
		if (arg1 == 0) {
			int snid, hnid;
			X509_ALGOR *alg1, *alg2;
			CMS_SignerInfo_get0_algs(arg2, NULL, NULL,
			    &alg1, &alg2);
			if (alg1 == NULL || alg1->algorithm == NULL)
				return -1;
			hnid = OBJ_obj2nid(alg1->algorithm);
			if (hnid == NID_undef)
				return -1;
			if (!OBJ_find_sigid_by_algs(&snid, hnid, EVP_PKEY_id(pkey)))
				return -1;
			X509_ALGOR_set0(alg2, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0);
		}
		return 1;
#endif
@


1.13
log
@Fix memory leak.

OK from beck@@ and miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_ameth.c,v 1.12 2014/07/12 16:03:37 miod Exp $ */
d396 1
a396 7
	EC_GROUP *group = EC_GROUP_dup(EC_KEY_get0_group(from->pkey.ec));
	if (group == NULL)
		return 0;
	if (EC_KEY_set_group(to->pkey.ec, group) == 0)
		return 0;
	EC_GROUP_free(group);
	return 1;
@


1.12
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_ameth.c,v 1.11 2014/07/11 08:44:48 jsing Exp $ */
d376 1
@


1.11
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_ameth.c,v 1.10 2014/07/10 22:45:57 jsing Exp $ */
d495 3
a497 6
	if (pub_key)
		BN_free(pub_key);
	if (order)
		BN_free(order);
	if (ctx)
		BN_CTX_free(ctx);
@


1.10
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: ec_ameth.c,v 1.9 2014/06/12 15:49:29 deraadt Exp $ */
d63 3
a65 1
#include "cryptlib.h"
d67 1
a67 2
#include <openssl/ec.h>
#include <openssl/bn.h>
d71 1
@


1.9
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 3
@


1.8
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
@


1.7
log
@more: no need for null check before free
ok tedu guenther
@
text
@d328 1
a328 1
	ep = (unsigned char *) malloc(eplen);
@


1.6
log
@if (x) free(x) -> free(x); semantic patch generated with coccinelle, carefully
eyeballed before applying. Contributed by Cyril Roelandt on tech@@
@
text
@d495 1
a495 2
	if (buffer != NULL)
		free(buffer);
@


1.5
log
@knf approximation
@
text
@d131 1
a131 2
	if (penc)
		free(penc);
@


1.4
log
@Use C99 initializers for the various FOO_METHOD structs. More readable, and
avoid unreadable/unmaintainable constructs like that:

const EVP_PKEY_ASN1_METHOD cmac_asn1_meth =
        {
        EVP_PKEY_CMAC,
        EVP_PKEY_CMAC,
        0,

        "CMAC",
        "OpenSSL CMAC method",

        0,0,0,0,

        0,0,0,

        cmac_size,
        0,
        0,0,0,0,0,0,0,

        cmac_key_free,
        0,
        0,0
        };

ok matthew@@ deraadt@@
@
text
@d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d68 4
a71 3
static int eckey_param2type(int *pptype, void **ppval, EC_KEY *ec_key)
	{
	const EC_GROUP  *group;
d73 1
a73 2
	if (ec_key == NULL || (group = EC_KEY_get0_group(ec_key)) == NULL) 
	{
d77 2
a78 2
	if (EC_GROUP_get_asn1_flag(group)
                     && (nid = EC_GROUP_get_curve_name(group)))
a79 1
		{
d82 2
a83 3
		}
	else	/* explicit parameters */
		{
d89 1
a89 2
		if (pstr->length <= 0)
			{
d93 1
a93 1
			}
d96 1
a96 1
		}
d98 1
a98 1
	}
d100 3
a102 2
static int eckey_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)
	{
d109 1
a109 2
	if (!eckey_param2type(&ptype, &pval, ec_key))
		{
d112 1
a112 1
		}
d124 1
a124 1
				ptype, pval, penc, penclen))
d126 1
a126 1
	err:
d134 1
a134 1
	}
d136 3
a138 2
static EC_KEY *eckey_type2param(int ptype, void *pval)
	{
d140 2
a141 2
	if (ptype == V_ASN1_SEQUENCE)
		{
d145 1
d148 1
a148 2
		if (!(eckey = d2i_ECParameters(NULL, &pm, pmlen)))
			{
a150 1
			}
d152 1
a152 2
	else if (ptype == V_ASN1_OBJECT)
		{
d156 3
a158 2
		/* type == V_ASN1_OBJECT => the parameters are given
		 * by an asn1 OID
d160 1
a160 2
		if ((eckey = EC_KEY_new()) == NULL)
			{
d163 1
a163 1
			}
d171 1
a171 3
		}
	else
		{
d174 1
a174 1
		}
d178 1
a178 1
	ecerr:
d182 1
a182 1
	}
d184 3
a186 2
static int eckey_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)
	{
d199 1
a199 2
	if (!eckey)
		{
d202 1
a202 2
		}

d204 1
a204 2
	if (!o2i_ECPublicKey(&eckey, &p, pklen))
		{
d207 1
a207 2
		}

d211 1
a211 1
	ecerr:
d215 1
a215 1
	}
d217 4
a220 3
static int eckey_pub_cmp(const EVP_PKEY *a, const EVP_PKEY *b)
	{
	int  r;
d222 2
a223 2
	const EC_POINT *pa = EC_KEY_get0_public_key(a->pkey.ec),
	               *pb = EC_KEY_get0_public_key(b->pkey.ec);
d230 1
a230 1
	}
d232 3
a234 2
static int eckey_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)
	{
d251 1
a251 2
	if (!d2i_ECPrivateKey(&eckey, &p, pklen))
		{
d254 1
a254 2
		}

d256 1
a256 2
	if (EC_KEY_get0_public_key(eckey) == NULL)
		{
d260 5
a264 3
		/* the public key was not included in the SEC1 private
		 * key => calculate the public key */
		group   = EC_KEY_get0_group(eckey);
d266 1
a266 2
		if (pub_key == NULL)
			{
d269 2
a270 3
			}
		if (!EC_POINT_copy(pub_key, EC_GROUP_get0_generator(group)))
			{
d274 1
a274 1
			}
d276 1
a276 2
		if (!EC_POINT_mul(group, pub_key, priv_key, NULL, NULL, NULL))
			{
d280 2
a281 3
			}
		if (EC_KEY_set_public_key(eckey, pub_key) == 0)
			{
d285 1
a285 1
			}
d287 1
a287 2
		}

d291 1
a291 1
	ecliberr:
d293 1
a293 1
	ecerr:
d297 1
a297 1
	}
d299 2
a300 1
static int eckey_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
d302 5
a306 5
	EC_KEY		*ec_key;
	unsigned char	*ep, *p;
	int 		eplen, ptype;
	void		*pval;
	unsigned int    tmp_flags, old_flags;
d310 1
a310 2
	if (!eckey_param2type(&ptype, &pval, ec_key))
		{
d313 1
a313 2
		}

d316 4
a319 2
	/* do not include the parameters in the SEC1 private key
	 * see PKCS#11 12.11 */
d324 1
a324 2
	if (!eplen)
	{
d330 1
a330 2
	if (!ep)
	{
d336 1
a336 2
	if (!i2d_ECPrivateKey(ec_key, &p))
	{
d346 1
a346 1
				ptype, pval, ep, eplen))
d352 3
a354 2
static int int_ec_size(const EVP_PKEY *pkey)
	{
d356 1
a356 1
	}
d358 3
a360 2
static int ec_bits(const EVP_PKEY *pkey)
	{
d365 1
a365 2
	if (!order)
		{
d368 1
a368 1
		}
d370 1
a370 2
	if (!EC_GROUP_get_order(group, order, NULL))
		{
d373 1
a373 2
		}

d377 1
a377 1
	}
d379 3
a381 2
static int ec_missing_parameters(const EVP_PKEY *pkey)
	{
d385 1
a385 1
	}
d387 3
a389 2
static int ec_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from)
	{
d397 1
a397 1
	}
d399 4
a402 4
static int ec_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b)
	{
	const EC_GROUP *group_a = EC_KEY_get0_group(a->pkey.ec),
	               *group_b = EC_KEY_get0_group(b->pkey.ec);
d407 1
a407 1
	}
d409 3
a411 2
static void int_ec_free(EVP_PKEY *pkey)
	{
d413 1
a413 1
	}
d415 4
a418 3
static int do_EC_KEY_print(BIO *bp, const EC_KEY *x, int off, int ktype)
	{
	unsigned char *buffer=NULL;
d420 4
a423 4
	size_t	buf_len=0, i;
	int     ret=0, reason=ERR_R_BIO_LIB;
	BIGNUM  *pub_key=NULL, *order=NULL;
	BN_CTX  *ctx=NULL;
d427 2
a428 3
 
	if (x == NULL || (group = EC_KEY_get0_group(x)) == NULL)
		{
d431 1
a431 2
		}

d433 1
a433 2
	if (ctx == NULL)
		{
d436 2
a437 4
		}

	if (ktype > 0)
		{
d440 1
a440 2
			EC_KEY_get_conv_form(x), NULL, ctx)) == NULL)
			{
d443 1
a443 1
			}
d445 3
a447 5
			buf_len = (size_t)BN_num_bytes(pub_key);
		}

	if (ktype == 2)
		{
d449 1
a449 1
		if (priv_key && (i = (size_t)BN_num_bytes(priv_key)) > buf_len)
d451 1
a451 2
		}
	else
d454 1
a454 2
	if (ktype > 0)
		{
d456 1
a456 2
		if ((buffer = malloc(buf_len)) == NULL)
			{
a458 1
			}
d460 1
d475 4
a478 3
		BN_num_bits(order)) <= 0) goto err;
  
	if ((priv_key != NULL) && !ASN1_bn_print(bp, "priv:", priv_key, 
d486 1
a486 1
	ret=1;
d489 2
a490 2
 		ECerr(EC_F_DO_EC_KEY_PRINT, reason);
	if (pub_key) 
d498 2
a499 2
	return(ret);
	}
d501 4
a504 3
static int eckey_param_decode(EVP_PKEY *pkey,
					const unsigned char **pder, int derlen)
	{
d506 1
a506 2
	if (!(eckey = d2i_ECParameters(NULL, pder, derlen)))
		{
d509 1
a509 1
		}
d512 1
a512 1
	}
d514 3
a516 2
static int eckey_param_encode(const EVP_PKEY *pkey, unsigned char **pder)
	{
d518 1
a518 1
	}
d520 4
a523 3
static int eckey_param_print(BIO *bp, const EVP_PKEY *pkey, int indent,
							ASN1_PCTX *ctx)
	{
d525 1
a525 1
	}
d527 4
a530 3
static int eckey_pub_print(BIO *bp, const EVP_PKEY *pkey, int indent,
							ASN1_PCTX *ctx)
	{
d532 1
a532 1
	}
d535 4
a538 3
static int eckey_priv_print(BIO *bp, const EVP_PKEY *pkey, int indent,
							ASN1_PCTX *ctx)
	{
d540 1
a540 1
	}
d542 4
a545 3
static int old_ec_priv_decode(EVP_PKEY *pkey,
					const unsigned char **pder, int derlen)
	{
d547 1
a547 2
	if (!(ec = d2i_ECPrivateKey (NULL, pder, derlen)))
		{
d550 1
a550 1
		}
d553 1
a553 1
	}
d555 3
a557 2
static int old_ec_priv_encode(const EVP_PKEY *pkey, unsigned char **pder)
	{
d559 1
a559 1
	}
d561 6
a566 7
static int ec_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)
	{
	switch (op)
		{
		case ASN1_PKEY_CTRL_PKCS7_SIGN:
		if (arg1 == 0)
			{
d576 1
a576 1
				return -1; 
d578 1
a578 1
			}
d581 2
a582 3
		case ASN1_PKEY_CTRL_CMS_SIGN:
		if (arg1 == 0)
			{
d586 1
a586 1
								&alg1, &alg2);
d593 1
a593 1
				return -1; 
d595 1
a595 1
			}
d599 2
a600 2
		case ASN1_PKEY_CTRL_DEFAULT_MD_NID:
		*(int *)arg2 = NID_sha1;
d603 1
a603 1
		default:
d606 1
a606 1
		}
d608 1
a608 1
	}
@


1.3
log
@return after error instead of plowing ahead. noticed by mancha1 at zoho
@
text
@d629 31
a659 33
const EVP_PKEY_ASN1_METHOD eckey_asn1_meth = 
	{
	EVP_PKEY_EC,
	EVP_PKEY_EC,
	0,
	"EC",
	"OpenSSL EC algorithm",

	eckey_pub_decode,
	eckey_pub_encode,
	eckey_pub_cmp,
	eckey_pub_print,

	eckey_priv_decode,
	eckey_priv_encode,
	eckey_priv_print,

	int_ec_size,
	ec_bits,

	eckey_param_decode,
	eckey_param_encode,
	ec_missing_parameters,
	ec_copy_parameters,
	ec_cmp_parameters,
	eckey_param_print,
	0,

	int_ec_free,
	ec_pkey_ctrl,
	old_ec_priv_decode,
	old_ec_priv_encode
	};
@


1.2
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d355 1
@


1.1
log
@Initial revision
@
text
@d91 1
a91 1
		if (pstr->length < 0)
d119 1
a119 1
	penc = OPENSSL_malloc(penclen);
d135 1
a135 1
		OPENSSL_free(penc);
d342 1
a342 1
	ep = (unsigned char *) OPENSSL_malloc(eplen);
d353 1
a353 1
		OPENSSL_free(ep);
d477 1
a477 1
		if ((buffer = OPENSSL_malloc(buf_len)) == NULL)
d518 1
a518 1
		OPENSSL_free(buffer);
d654 1
@


1.1.1.1
log
@import OpenSSL-1.0.0a
@
text
@@


1.1.1.2
log
@import OpenSSL-1.0.1c
@
text
@a653 1
	0,
@


1.1.1.3
log
@Import OpenSSL 1.0.1g
@
text
@d91 1
a91 1
		if (pstr->length <= 0)
@


