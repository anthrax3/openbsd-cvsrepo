head	1.10;
access;
symbols
	OPENBSD_6_0:1.9.0.10
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.6
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	butholakala:1.4
	openssl_1_0_1_g:1.1.1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	openssl_1_0_1_c:1.1.1.4
	OPENBSD_5_2:1.3.0.6
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	openssl_1_0_0_f:1.1.1.3
	openssl_1_0_0_e:1.1.1.3
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	openssh_1_0_0_a:1.1.1.3
	OPENBSD_4_8:1.2.0.8
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	openssl_0_9_8_k:1.1.1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	openssl_0_9_8_j:1.1.1.2
	openssl_0_9_8_h:1.1.1.2
	pre_openssl_0_9_8h:1.1
	OPENBSD_4_4:1.1.0.26
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.24
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.22
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.20
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.18
	OPENBSD_4_0_BASE:1.1
	openssl_0_9_7j:1.1.1.1
	openssl:1.1.1
	OPENBSD_3_9:1.1.0.16
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.14
	OPENBSD_3_8_BASE:1.1
	OPENSSL_0_9_7G:1.1.1.1
	OPENBSD_3_7:1.1.0.12
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.10
	OPENBSD_3_6_BASE:1.1
	OPENSSL_0_9_7D:1.1.1.1
	OPENBSD_3_5:1.1.0.8
	OPENBSD_3_5_BASE:1.1
	OPENSSL_0_9_7C:1.1.1.1
	OPENBSD_3_4:1.1.0.6
	OPENBSD_3_4_BASE:1.1
	OPENSSL_0_9_7B:1.1.1.1
	OPENBSD_3_3:1.1.0.4
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.09.03.11.33.37;	author beck;	state dead;
branches;
next	1.9;
commitid	HnbXxsegngek41U2;

1.9
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches;
next	1.8;
commitid	G74O1dmRukKsW7IJ;

1.8
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	mJUVYpkFBZ0Zv2bG;

1.7
date	2014.05.06.03.56.27;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.27.20.26.48;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.15.20.06.09;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.01.22.58.55;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.13;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.18;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.10.01.22.54.06;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.10.13.21.23.39;	author djm;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Remove the libssl/src directory
@
text
@/* $OpenBSD: ecp_nist.c,v 1.9 2014/07/12 16:03:37 miod Exp $ */
/*
 * Written by Nils Larsch for the OpenSSL project.
 */
/* ====================================================================
 * Copyright (c) 1998-2003 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * Portions of this software developed by SUN MICROSYSTEMS, INC.,
 * and contributed to the OpenSSL project.
 */

#include <limits.h>

#include <openssl/err.h>
#include <openssl/obj_mac.h>
#include "ec_lcl.h"

const EC_METHOD *
EC_GFp_nist_method(void)
{
	static const EC_METHOD ret = {
		.flags = EC_FLAGS_DEFAULT_OCT,
		.field_type = NID_X9_62_prime_field,
		.group_init = ec_GFp_simple_group_init,
		.group_finish = ec_GFp_simple_group_finish,
		.group_clear_finish = ec_GFp_simple_group_clear_finish,
		.group_copy = ec_GFp_nist_group_copy,
		.group_set_curve = ec_GFp_nist_group_set_curve,
		.group_get_curve = ec_GFp_simple_group_get_curve,
		.group_get_degree = ec_GFp_simple_group_get_degree,
		.group_check_discriminant =
		ec_GFp_simple_group_check_discriminant,
		.point_init = ec_GFp_simple_point_init,
		.point_finish = ec_GFp_simple_point_finish,
		.point_clear_finish = ec_GFp_simple_point_clear_finish,
		.point_copy = ec_GFp_simple_point_copy,
		.point_set_to_infinity = ec_GFp_simple_point_set_to_infinity,
		.point_set_Jprojective_coordinates_GFp =
		ec_GFp_simple_set_Jprojective_coordinates_GFp,
		.point_get_Jprojective_coordinates_GFp =
		ec_GFp_simple_get_Jprojective_coordinates_GFp,
		.point_set_affine_coordinates =
		ec_GFp_simple_point_set_affine_coordinates,
		.point_get_affine_coordinates =
		ec_GFp_simple_point_get_affine_coordinates,
		.add = ec_GFp_simple_add,
		.dbl = ec_GFp_simple_dbl,
		.invert = ec_GFp_simple_invert,
		.is_at_infinity = ec_GFp_simple_is_at_infinity,
		.is_on_curve = ec_GFp_simple_is_on_curve,
		.point_cmp = ec_GFp_simple_cmp,
		.make_affine = ec_GFp_simple_make_affine,
		.points_make_affine = ec_GFp_simple_points_make_affine,
		.field_mul = ec_GFp_nist_field_mul,
		.field_sqr = ec_GFp_nist_field_sqr
	};

	return &ret;
}

int 
ec_GFp_nist_group_copy(EC_GROUP * dest, const EC_GROUP * src)
{
	dest->field_mod_func = src->field_mod_func;

	return ec_GFp_simple_group_copy(dest, src);
}

int 
ec_GFp_nist_group_set_curve(EC_GROUP *group, const BIGNUM *p,
    const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
{
	int ret = 0;
	BN_CTX *new_ctx = NULL;
	BIGNUM *tmp_bn;

	if (ctx == NULL)
		if ((ctx = new_ctx = BN_CTX_new()) == NULL)
			return 0;

	BN_CTX_start(ctx);
	if ((tmp_bn = BN_CTX_get(ctx)) == NULL)
		goto err;

	if (BN_ucmp(BN_get0_nist_prime_192(), p) == 0)
		group->field_mod_func = BN_nist_mod_192;
	else if (BN_ucmp(BN_get0_nist_prime_224(), p) == 0)
		group->field_mod_func = BN_nist_mod_224;
	else if (BN_ucmp(BN_get0_nist_prime_256(), p) == 0)
		group->field_mod_func = BN_nist_mod_256;
	else if (BN_ucmp(BN_get0_nist_prime_384(), p) == 0)
		group->field_mod_func = BN_nist_mod_384;
	else if (BN_ucmp(BN_get0_nist_prime_521(), p) == 0)
		group->field_mod_func = BN_nist_mod_521;
	else {
		ECerr(EC_F_EC_GFP_NIST_GROUP_SET_CURVE, EC_R_NOT_A_NIST_PRIME);
		goto err;
	}

	ret = ec_GFp_simple_group_set_curve(group, p, a, b, ctx);

err:
	BN_CTX_end(ctx);
	BN_CTX_free(new_ctx);
	return ret;
}


int 
ec_GFp_nist_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
    const BIGNUM *b, BN_CTX *ctx)
{
	int ret = 0;
	BN_CTX *ctx_new = NULL;

	if (!group || !r || !a || !b) {
		ECerr(EC_F_EC_GFP_NIST_FIELD_MUL, ERR_R_PASSED_NULL_PARAMETER);
		goto err;
	}
	if (!ctx)
		if ((ctx_new = ctx = BN_CTX_new()) == NULL)
			goto err;

	if (!BN_mul(r, a, b, ctx))
		goto err;
	if (!group->field_mod_func(r, r, &group->field, ctx))
		goto err;

	ret = 1;
err:
	BN_CTX_free(ctx_new);
	return ret;
}


int 
ec_GFp_nist_field_sqr(const EC_GROUP * group, BIGNUM * r, const BIGNUM * a,
    BN_CTX * ctx)
{
	int ret = 0;
	BN_CTX *ctx_new = NULL;

	if (!group || !r || !a) {
		ECerr(EC_F_EC_GFP_NIST_FIELD_SQR, EC_R_PASSED_NULL_PARAMETER);
		goto err;
	}
	if (!ctx)
		if ((ctx_new = ctx = BN_CTX_new()) == NULL)
			goto err;

	if (!BN_sqr(r, a, ctx))
		goto err;
	if (!group->field_mod_func(r, r, &group->field, ctx))
		goto err;

	ret = 1;
err:
	BN_CTX_free(ctx_new);
	return ret;
}
@


1.9
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ecp_nist.c,v 1.8 2014/06/12 15:49:29 deraadt Exp $ */
@


1.8
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d156 1
a156 2
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
d183 1
a183 2
	if (ctx_new)
		BN_CTX_free(ctx_new);
d210 1
a210 2
	if (ctx_new)
		BN_CTX_free(ctx_new);
@


1.7
log
@knf approximation
@
text
@d1 1
a1 1
/* crypto/ec/ecp_nist.c */
@


1.6
log
@Use C99 initializers for the various FOO_METHOD structs. More readable, and
avoid unreadable/unmaintainable constructs like that:

const EVP_PKEY_ASN1_METHOD cmac_asn1_meth =
        {
        EVP_PKEY_CMAC,
        EVP_PKEY_CMAC,
        0,

        "CMAC",
        "OpenSSL CMAC method",

        0,0,0,0,

        0,0,0,

        cmac_size,
        0,
        0,0,0,0,0,0,0,

        cmac_key_free,
        0,
        0,0
        };

ok matthew@@ deraadt@@
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d84 1
a84 1
		    ec_GFp_simple_group_check_discriminant,
d91 1
a91 1
		    ec_GFp_simple_set_Jprojective_coordinates_GFp,
d93 1
a93 1
		    ec_GFp_simple_get_Jprojective_coordinates_GFp,
d95 1
a95 1
		    ec_GFp_simple_point_set_affine_coordinates,
d97 1
a97 1
		    ec_GFp_simple_point_get_affine_coordinates,
d113 3
a115 2
int ec_GFp_nist_group_copy(EC_GROUP *dest, const EC_GROUP *src)
	{
d119 1
a119 1
	}
d121 4
a124 3
int ec_GFp_nist_group_set_curve(EC_GROUP *group, const BIGNUM *p,
	const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
	{
d128 1
a128 1
	
d130 2
a131 1
		if ((ctx = new_ctx = BN_CTX_new()) == NULL) return 0;
d134 2
a135 1
	if ((tmp_bn = BN_CTX_get(ctx)) == NULL) goto err;
d147 1
a147 2
	else
		{
d150 1
a150 1
		}
d154 1
a154 1
 err:
d159 1
a159 1
	}
d162 6
a167 5
int ec_GFp_nist_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
	const BIGNUM *b, BN_CTX *ctx)
	{
	int	ret=0;
	BN_CTX	*ctx_new=NULL;
d169 1
a169 2
	if (!group || !r || !a || !b)
		{
d172 1
a172 1
		}
d174 2
a175 1
		if ((ctx_new = ctx = BN_CTX_new()) == NULL) goto err;
d177 2
a178 1
	if (!BN_mul(r, a, b, ctx)) goto err;
d182 1
a182 1
	ret=1;
d187 1
a187 1
	}
d190 6
a195 5
int ec_GFp_nist_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
	BN_CTX *ctx)
	{
	int	ret=0;
	BN_CTX	*ctx_new=NULL;
d197 1
a197 2
	if (!group || !r || !a)
		{
d200 1
a200 1
		}
d202 2
a203 1
		if ((ctx_new = ctx = BN_CTX_new()) == NULL) goto err;
d205 2
a206 1
	if (!BN_sqr(r, a, ctx)) goto err;
d210 1
a210 1
	ret=1;
d215 1
a215 1
	}
@


1.5
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok beck deraadt
@
text
@d70 3
a72 2
const EC_METHOD *EC_GFp_nist_method(void)
	{
d74 35
a108 37
		EC_FLAGS_DEFAULT_OCT,
		NID_X9_62_prime_field,
		ec_GFp_simple_group_init,
		ec_GFp_simple_group_finish,
		ec_GFp_simple_group_clear_finish,
		ec_GFp_nist_group_copy,
		ec_GFp_nist_group_set_curve,
		ec_GFp_simple_group_get_curve,
		ec_GFp_simple_group_get_degree,
		ec_GFp_simple_group_check_discriminant,
		ec_GFp_simple_point_init,
		ec_GFp_simple_point_finish,
		ec_GFp_simple_point_clear_finish,
		ec_GFp_simple_point_copy,
		ec_GFp_simple_point_set_to_infinity,
		ec_GFp_simple_set_Jprojective_coordinates_GFp,
		ec_GFp_simple_get_Jprojective_coordinates_GFp,
		ec_GFp_simple_point_set_affine_coordinates,
		ec_GFp_simple_point_get_affine_coordinates,
		0,0,0,
		ec_GFp_simple_add,
		ec_GFp_simple_dbl,
		ec_GFp_simple_invert,
		ec_GFp_simple_is_at_infinity,
		ec_GFp_simple_is_on_curve,
		ec_GFp_simple_cmp,
		ec_GFp_simple_make_affine,
		ec_GFp_simple_points_make_affine,
		0 /* mul */,
		0 /* precompute_mult */,
		0 /* have_precompute_mult */,	
		ec_GFp_nist_field_mul,
		ec_GFp_nist_field_sqr,
		0 /* field_div */,
		0 /* field_encode */,
		0 /* field_decode */,
		0 /* field_set_to_one */ };
d111 1
a111 1
	}
@


1.4
log
@resolve conflicts
@
text
@a69 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

a71 3
#ifdef OPENSSL_FIPS
	return fips_ec_gfp_nist_method();
#else
a111 1
#endif
@


1.3
log
@resolve conflicts, fix local changes
@
text
@d70 4
d76 3
d80 1
d99 1
a99 3
		ec_GFp_simple_set_compressed_coordinates,
		ec_GFp_simple_point2oct,
		ec_GFp_simple_oct2point,
d119 1
@


1.2
log
@resolve conflicts
@
text
@a114 4
#if BN_BITS2 == 64
#define	NO_32_BIT_TYPE
#endif

a137 2
		{
#ifndef NO_32_BIT_TYPE
a138 5
#else
		ECerr(EC_F_EC_GFP_NIST_GROUP_SET_CURVE, EC_R_NOT_A_SUPPORTED_NIST_PRIME);
		goto err;
#endif
		}
a139 2
		{
#ifndef NO_32_BIT_TYPE
a140 5
#else
		ECerr(EC_F_EC_GFP_NIST_GROUP_SET_CURVE, EC_R_NOT_A_SUPPORTED_NIST_PRIME);
		goto err;
#endif
		}
a141 2
		{
#ifndef NO_32_BIT_TYPE
a142 5
#else
		ECerr(EC_F_EC_GFP_NIST_GROUP_SET_CURVE, EC_R_NOT_A_SUPPORTED_NIST_PRIME);
		goto err;
#endif
		}
a143 1
		/* this one works in the NO_32_BIT_TYPE case */
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d2 3
d6 1
a6 1
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
d58 5
d64 4
a69 1
#if 0
d73 4
a76 3
		ec_GFp_nist_group_init,
		ec_GFp_nist_group_finish,
		ec_GFp_nist_group_clear_finish,
d78 4
a81 6
		ec_GFp_nist_group_set_curve_GFp,
		ec_GFp_simple_group_get_curve_GFp,
		ec_GFp_simple_group_set_generator,
		ec_GFp_simple_group_get0_generator,
		ec_GFp_simple_group_get_order,
		ec_GFp_simple_group_get_cofactor,
d89 3
a91 3
		ec_GFp_simple_point_set_affine_coordinates_GFp,
		ec_GFp_simple_point_get_affine_coordinates_GFp,
		ec_GFp_simple_set_compressed_coordinates_GFp,
d102 3
d107 1
d114 3
d119 1
a119 2

int ec_GFp_nist_group_init(EC_GROUP *group)
d121 1
a121 1
	int ok;
d123 1
a123 3
	ok = ec_GFp_simple_group_init(group);
	group->field_data1 = NULL;
	return ok;
d126 59
a185 2
int ec_GFp_nist_group_set_curve_GFp(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
/* TODO */
d187 5
d193 18
a210 2
void ec_GFp_nist_group_finish(EC_GROUP *group);
/* TODO */
d213 5
a217 2
void ec_GFp_nist_group_clear_finish(EC_GROUP *group);
/* TODO */
d219 18
a236 11

int ec_GFp_nist_group_copy(EC_GROUP *dest, const EC_GROUP *src);
/* TODO */


int ec_GFp_nist_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
/* TODO */


int ec_GFp_nist_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a, BN_CTX *ctx);
/* TODO */
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import of OpenSSL 0.9.8h
@
text
@a1 3
/*
 * Written by Nils Larsch for the OpenSSL project.
 */
d3 1
a3 1
 * Copyright (c) 1998-2003 The OpenSSL Project.  All rights reserved.
a54 5
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * Portions of this software developed by SUN MICROSYSTEMS, INC.,
 * and contributed to the OpenSSL project.
 */
a55 4
#include <limits.h>

#include <openssl/err.h>
#include <openssl/obj_mac.h>
d58 1
d62 3
a64 4
		NID_X9_62_prime_field,
		ec_GFp_simple_group_init,
		ec_GFp_simple_group_finish,
		ec_GFp_simple_group_clear_finish,
d66 6
a71 4
		ec_GFp_nist_group_set_curve,
		ec_GFp_simple_group_get_curve,
		ec_GFp_simple_group_get_degree,
		ec_GFp_simple_group_check_discriminant,
d79 3
a81 3
		ec_GFp_simple_point_set_affine_coordinates,
		ec_GFp_simple_point_get_affine_coordinates,
		ec_GFp_simple_set_compressed_coordinates,
a91 3
		0 /* mul */,
		0 /* precompute_mult */,
		0 /* have_precompute_mult */,	
a93 1
		0 /* field_div */,
d100 1
a101 3
#if BN_BITS2 == 64
#define	NO_32_BIT_TYPE
#endif
d103 1
a103 1
int ec_GFp_nist_group_copy(EC_GROUP *dest, const EC_GROUP *src)
d105 1
a105 1
	dest->field_mod_func = src->field_mod_func;
d107 3
a109 1
	return ec_GFp_simple_group_copy(dest, src);
d112 11
a122 59
int ec_GFp_nist_group_set_curve(EC_GROUP *group, const BIGNUM *p,
	const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
	{
	int ret = 0;
	BN_CTX *new_ctx = NULL;
	BIGNUM *tmp_bn;
	
	if (ctx == NULL)
		if ((ctx = new_ctx = BN_CTX_new()) == NULL) return 0;

	BN_CTX_start(ctx);
	if ((tmp_bn = BN_CTX_get(ctx)) == NULL) goto err;

	if (BN_ucmp(BN_get0_nist_prime_192(), p) == 0)
		group->field_mod_func = BN_nist_mod_192;
	else if (BN_ucmp(BN_get0_nist_prime_224(), p) == 0)
		{
#ifndef NO_32_BIT_TYPE
		group->field_mod_func = BN_nist_mod_224;
#else
		ECerr(EC_F_EC_GFP_NIST_GROUP_SET_CURVE, EC_R_NOT_A_SUPPORTED_NIST_PRIME);
		goto err;
#endif
		}
	else if (BN_ucmp(BN_get0_nist_prime_256(), p) == 0)
		{
#ifndef NO_32_BIT_TYPE
		group->field_mod_func = BN_nist_mod_256;
#else
		ECerr(EC_F_EC_GFP_NIST_GROUP_SET_CURVE, EC_R_NOT_A_SUPPORTED_NIST_PRIME);
		goto err;
#endif
		}
	else if (BN_ucmp(BN_get0_nist_prime_384(), p) == 0)
		{
#ifndef NO_32_BIT_TYPE
		group->field_mod_func = BN_nist_mod_384;
#else
		ECerr(EC_F_EC_GFP_NIST_GROUP_SET_CURVE, EC_R_NOT_A_SUPPORTED_NIST_PRIME);
		goto err;
#endif
		}
	else if (BN_ucmp(BN_get0_nist_prime_521(), p) == 0)
		/* this one works in the NO_32_BIT_TYPE case */
		group->field_mod_func = BN_nist_mod_521;
	else
		{
		ECerr(EC_F_EC_GFP_NIST_GROUP_SET_CURVE, EC_R_NOT_A_NIST_PRIME);
		goto err;
		}

	ret = ec_GFp_simple_group_set_curve(group, p, a, b, ctx);

 err:
	BN_CTX_end(ctx);
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
	return ret;
	}
d125 2
a126 5
int ec_GFp_nist_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
	const BIGNUM *b, BN_CTX *ctx)
	{
	int	ret=0;
	BN_CTX	*ctx_new=NULL;
a127 18
	if (!group || !r || !a || !b)
		{
		ECerr(EC_F_EC_GFP_NIST_FIELD_MUL, ERR_R_PASSED_NULL_PARAMETER);
		goto err;
		}
	if (!ctx)
		if ((ctx_new = ctx = BN_CTX_new()) == NULL) goto err;

	if (!BN_mul(r, a, b, ctx)) goto err;
	if (!group->field_mod_func(r, r, &group->field, ctx))
		goto err;

	ret=1;
err:
	if (ctx_new)
		BN_CTX_free(ctx_new);
	return ret;
	}
d129 2
a131 5
int ec_GFp_nist_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
	BN_CTX *ctx)
	{
	int	ret=0;
	BN_CTX	*ctx_new=NULL;
d133 2
a134 18
	if (!group || !r || !a)
		{
		ECerr(EC_F_EC_GFP_NIST_FIELD_SQR, EC_R_PASSED_NULL_PARAMETER);
		goto err;
		}
	if (!ctx)
		if ((ctx_new = ctx = BN_CTX_new()) == NULL) goto err;

	if (!BN_sqr(r, a, ctx)) goto err;
	if (!group->field_mod_func(r, r, &group->field, ctx))
		goto err;

	ret=1;
err:
	if (ctx_new)
		BN_CTX_free(ctx_new);
	return ret;
	}
@


1.1.1.3
log
@import OpenSSL-1.0.0a
@
text
@d115 4
d142 2
d145 5
d151 2
d154 5
d160 2
d163 5
d169 1
@


1.1.1.4
log
@import OpenSSL-1.0.1c
@
text
@a69 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

a71 3
#ifdef OPENSSL_FIPS
	return fips_ec_gfp_nist_method();
#else
a72 1
		EC_FLAGS_DEFAULT_OCT,
d91 3
a93 1
		0,0,0,
a112 1
#endif
@


