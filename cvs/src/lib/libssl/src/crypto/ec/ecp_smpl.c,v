head	1.15;
access;
symbols
	OPENBSD_6_0:1.15.0.8
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.4
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	butholakala:1.5
	openssl_1_0_1_g:1.1.1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	openssl_1_0_1_c:1.1.1.5
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	openssl_1_0_0_f:1.1.1.4
	openssl_1_0_0_e:1.1.1.4
	OPENBSD_5_0:1.3.0.12
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.10
	OPENBSD_4_9_BASE:1.3
	openssh_1_0_0_a:1.1.1.3
	OPENBSD_4_8:1.3.0.8
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	openssl_0_9_8_k:1.1.1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	openssl_0_9_8_j:1.1.1.3
	openssl_0_9_8_h:1.1.1.3
	pre_openssl_0_9_8h:1.2
	OPENBSD_4_4:1.2.0.18
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.16
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.14
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.12
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.10
	OPENBSD_4_0_BASE:1.2
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.2.0.8
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENSSL_0_9_7G:1.1.1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.1.0.8
	OPENBSD_3_5_BASE:1.1
	OPENSSL_0_9_7C:1.1.1.1
	OPENBSD_3_4:1.1.0.6
	OPENBSD_3_4_BASE:1.1
	OPENSSL_0_9_7B:1.1.1.1
	OPENBSD_3_3:1.1.0.4
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.02.09.15.49.22;	author jsing;	state Exp;
branches;
next	1.14;
commitid	69Tc75PIK8JcRRsC;

1.14
date	2015.02.08.22.25.03;	author miod;	state Exp;
branches;
next	1.13;
commitid	QrqYr2yKPjNFCI1S;

1.13
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches;
next	1.12;
commitid	G74O1dmRukKsW7IJ;

1.12
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	mJUVYpkFBZ0Zv2bG;

1.11
date	2014.05.29.21.07.42;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2014.05.06.03.56.27;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.27.20.26.48;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.15.20.06.09;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.13.23.50.02;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches
	1.5.4.1
	1.5.8.1;
next	1.4;

1.4
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.08.08.03.13;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.13;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.18;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.04.07.20.41.41;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.11.03.02.32.11;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.10.13.21.23.39;	author djm;	state Exp;
branches;
next	;

1.5.4.1
date	2014.08.09.16.55.55;	author tedu;	state Exp;
branches;
next	;
commitid	M9vFauFXshUDHG4j;

1.5.8.1
date	2014.08.09.16.54.57;	author tedu;	state Exp;
branches;
next	;
commitid	iDBdpZ9JdHGZqIAL;


desc
@@


1.15
log
@BN_CTX_get() can fail - consistently check its return value.

There are currently cases where the return from each call is checked,
the return from only the last call is checked and cases where it is not
checked at all (including code in bn, ec and engine).

Checking the last return value is valid as once the function fails it will
continue to return NULL. However, in order to be consistent check each
call with the same idiom. This makes it easy to verify.

Note there are still a handful of cases that do not follow the idiom -
these will be handled separately.

ok beck@@ doug@@
@
text
@/* $OpenBSD: ecp_smpl.c,v 1.14 2015/02/08 22:25:03 miod Exp $ */
/* Includes code written by Lenka Fibikova <fibikova@@exp-math.uni-essen.de>
 * for the OpenSSL project.
 * Includes code written by Bodo Moeller for the OpenSSL project.
*/
/* ====================================================================
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * Portions of this software developed by SUN MICROSYSTEMS, INC.,
 * and contributed to the OpenSSL project.
 */

#include <openssl/err.h>

#include "ec_lcl.h"

const EC_METHOD *
EC_GFp_simple_method(void)
{
	static const EC_METHOD ret = {
		.flags = EC_FLAGS_DEFAULT_OCT,
		.field_type = NID_X9_62_prime_field,
		.group_init = ec_GFp_simple_group_init,
		.group_finish = ec_GFp_simple_group_finish,
		.group_clear_finish = ec_GFp_simple_group_clear_finish,
		.group_copy = ec_GFp_simple_group_copy,
		.group_set_curve = ec_GFp_simple_group_set_curve,
		.group_get_curve = ec_GFp_simple_group_get_curve,
		.group_get_degree = ec_GFp_simple_group_get_degree,
		.group_check_discriminant =
		ec_GFp_simple_group_check_discriminant,
		.point_init = ec_GFp_simple_point_init,
		.point_finish = ec_GFp_simple_point_finish,
		.point_clear_finish = ec_GFp_simple_point_clear_finish,
		.point_copy = ec_GFp_simple_point_copy,
		.point_set_to_infinity = ec_GFp_simple_point_set_to_infinity,
		.point_set_Jprojective_coordinates_GFp =
		ec_GFp_simple_set_Jprojective_coordinates_GFp,
		.point_get_Jprojective_coordinates_GFp =
		ec_GFp_simple_get_Jprojective_coordinates_GFp,
		.point_set_affine_coordinates =
		ec_GFp_simple_point_set_affine_coordinates,
		.point_get_affine_coordinates =
		ec_GFp_simple_point_get_affine_coordinates,
		.add = ec_GFp_simple_add,
		.dbl = ec_GFp_simple_dbl,
		.invert = ec_GFp_simple_invert,
		.is_at_infinity = ec_GFp_simple_is_at_infinity,
		.is_on_curve = ec_GFp_simple_is_on_curve,
		.point_cmp = ec_GFp_simple_cmp,
		.make_affine = ec_GFp_simple_make_affine,
		.points_make_affine = ec_GFp_simple_points_make_affine,
		.field_mul = ec_GFp_simple_field_mul,
		.field_sqr = ec_GFp_simple_field_sqr
	};

	return &ret;
}


/* Most method functions in this file are designed to work with
 * non-trivial representations of field elements if necessary
 * (see ecp_mont.c): while standard modular addition and subtraction
 * are used, the field_mul and field_sqr methods will be used for
 * multiplication, and field_encode and field_decode (if defined)
 * will be used for converting between representations.

 * Functions ec_GFp_simple_points_make_affine() and
 * ec_GFp_simple_point_get_affine_coordinates() specifically assume
 * that if a non-trivial representation is used, it is a Montgomery
 * representation (i.e. 'encoding' means multiplying by some factor R).
 */


int 
ec_GFp_simple_group_init(EC_GROUP * group)
{
	BN_init(&group->field);
	BN_init(&group->a);
	BN_init(&group->b);
	group->a_is_minus3 = 0;
	return 1;
}


void 
ec_GFp_simple_group_finish(EC_GROUP * group)
{
	BN_free(&group->field);
	BN_free(&group->a);
	BN_free(&group->b);
}


void 
ec_GFp_simple_group_clear_finish(EC_GROUP * group)
{
	BN_clear_free(&group->field);
	BN_clear_free(&group->a);
	BN_clear_free(&group->b);
}


int 
ec_GFp_simple_group_copy(EC_GROUP * dest, const EC_GROUP * src)
{
	if (!BN_copy(&dest->field, &src->field))
		return 0;
	if (!BN_copy(&dest->a, &src->a))
		return 0;
	if (!BN_copy(&dest->b, &src->b))
		return 0;

	dest->a_is_minus3 = src->a_is_minus3;

	return 1;
}


int 
ec_GFp_simple_group_set_curve(EC_GROUP * group,
    const BIGNUM * p, const BIGNUM * a, const BIGNUM * b, BN_CTX * ctx)
{
	int ret = 0;
	BN_CTX *new_ctx = NULL;
	BIGNUM *tmp_a;

	/* p must be a prime > 3 */
	if (BN_num_bits(p) <= 2 || !BN_is_odd(p)) {
		ECerr(EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE, EC_R_INVALID_FIELD);
		return 0;
	}
	if (ctx == NULL) {
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			return 0;
	}
	BN_CTX_start(ctx);
	if ((tmp_a = BN_CTX_get(ctx)) == NULL)
		goto err;

	/* group->field */
	if (!BN_copy(&group->field, p))
		goto err;
	BN_set_negative(&group->field, 0);

	/* group->a */
	if (!BN_nnmod(tmp_a, a, p, ctx))
		goto err;
	if (group->meth->field_encode) {
		if (!group->meth->field_encode(group, &group->a, tmp_a, ctx))
			goto err;
	} else if (!BN_copy(&group->a, tmp_a))
		goto err;

	/* group->b */
	if (!BN_nnmod(&group->b, b, p, ctx))
		goto err;
	if (group->meth->field_encode)
		if (!group->meth->field_encode(group, &group->b, &group->b, ctx))
			goto err;

	/* group->a_is_minus3 */
	if (!BN_add_word(tmp_a, 3))
		goto err;
	group->a_is_minus3 = (0 == BN_cmp(tmp_a, &group->field));

	ret = 1;

err:
	BN_CTX_end(ctx);
	BN_CTX_free(new_ctx);
	return ret;
}


int 
ec_GFp_simple_group_get_curve(const EC_GROUP * group, BIGNUM * p, BIGNUM * a, BIGNUM * b, BN_CTX * ctx)
{
	int ret = 0;
	BN_CTX *new_ctx = NULL;

	if (p != NULL) {
		if (!BN_copy(p, &group->field))
			return 0;
	}
	if (a != NULL || b != NULL) {
		if (group->meth->field_decode) {
			if (ctx == NULL) {
				ctx = new_ctx = BN_CTX_new();
				if (ctx == NULL)
					return 0;
			}
			if (a != NULL) {
				if (!group->meth->field_decode(group, a, &group->a, ctx))
					goto err;
			}
			if (b != NULL) {
				if (!group->meth->field_decode(group, b, &group->b, ctx))
					goto err;
			}
		} else {
			if (a != NULL) {
				if (!BN_copy(a, &group->a))
					goto err;
			}
			if (b != NULL) {
				if (!BN_copy(b, &group->b))
					goto err;
			}
		}
	}
	ret = 1;

err:
	BN_CTX_free(new_ctx);
	return ret;
}


int 
ec_GFp_simple_group_get_degree(const EC_GROUP * group)
{
	return BN_num_bits(&group->field);
}


int 
ec_GFp_simple_group_check_discriminant(const EC_GROUP * group, BN_CTX * ctx)
{
	int ret = 0;
	BIGNUM *a, *b, *order, *tmp_1, *tmp_2;
	const BIGNUM *p = &group->field;
	BN_CTX *new_ctx = NULL;

	if (ctx == NULL) {
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL) {
			ECerr(EC_F_EC_GFP_SIMPLE_GROUP_CHECK_DISCRIMINANT, ERR_R_MALLOC_FAILURE);
			goto err;
		}
	}
	BN_CTX_start(ctx);
	if ((a = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((b = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((tmp_1 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((tmp_2 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((order = BN_CTX_get(ctx)) == NULL)
		goto err;

	if (group->meth->field_decode) {
		if (!group->meth->field_decode(group, a, &group->a, ctx))
			goto err;
		if (!group->meth->field_decode(group, b, &group->b, ctx))
			goto err;
	} else {
		if (!BN_copy(a, &group->a))
			goto err;
		if (!BN_copy(b, &group->b))
			goto err;
	}

	/*
	 * check the discriminant: y^2 = x^3 + a*x + b is an elliptic curve
	 * <=> 4*a^3 + 27*b^2 != 0 (mod p) 0 =< a, b < p
	 */
	if (BN_is_zero(a)) {
		if (BN_is_zero(b))
			goto err;
	} else if (!BN_is_zero(b)) {
		if (!BN_mod_sqr(tmp_1, a, p, ctx))
			goto err;
		if (!BN_mod_mul(tmp_2, tmp_1, a, p, ctx))
			goto err;
		if (!BN_lshift(tmp_1, tmp_2, 2))
			goto err;
		/* tmp_1 = 4*a^3 */

		if (!BN_mod_sqr(tmp_2, b, p, ctx))
			goto err;
		if (!BN_mul_word(tmp_2, 27))
			goto err;
		/* tmp_2 = 27*b^2 */

		if (!BN_mod_add(a, tmp_1, tmp_2, p, ctx))
			goto err;
		if (BN_is_zero(a))
			goto err;
	}
	ret = 1;

err:
	if (ctx != NULL)
		BN_CTX_end(ctx);
	BN_CTX_free(new_ctx);
	return ret;
}


int 
ec_GFp_simple_point_init(EC_POINT * point)
{
	BN_init(&point->X);
	BN_init(&point->Y);
	BN_init(&point->Z);
	point->Z_is_one = 0;

	return 1;
}


void 
ec_GFp_simple_point_finish(EC_POINT * point)
{
	BN_free(&point->X);
	BN_free(&point->Y);
	BN_free(&point->Z);
}


void 
ec_GFp_simple_point_clear_finish(EC_POINT * point)
{
	BN_clear_free(&point->X);
	BN_clear_free(&point->Y);
	BN_clear_free(&point->Z);
	point->Z_is_one = 0;
}


int 
ec_GFp_simple_point_copy(EC_POINT * dest, const EC_POINT * src)
{
	if (!BN_copy(&dest->X, &src->X))
		return 0;
	if (!BN_copy(&dest->Y, &src->Y))
		return 0;
	if (!BN_copy(&dest->Z, &src->Z))
		return 0;
	dest->Z_is_one = src->Z_is_one;

	return 1;
}


int 
ec_GFp_simple_point_set_to_infinity(const EC_GROUP * group, EC_POINT * point)
{
	point->Z_is_one = 0;
	BN_zero(&point->Z);
	return 1;
}


int 
ec_GFp_simple_set_Jprojective_coordinates_GFp(const EC_GROUP * group, EC_POINT * point,
    const BIGNUM * x, const BIGNUM * y, const BIGNUM * z, BN_CTX * ctx)
{
	BN_CTX *new_ctx = NULL;
	int ret = 0;

	if (ctx == NULL) {
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			return 0;
	}
	if (x != NULL) {
		if (!BN_nnmod(&point->X, x, &group->field, ctx))
			goto err;
		if (group->meth->field_encode) {
			if (!group->meth->field_encode(group, &point->X, &point->X, ctx))
				goto err;
		}
	}
	if (y != NULL) {
		if (!BN_nnmod(&point->Y, y, &group->field, ctx))
			goto err;
		if (group->meth->field_encode) {
			if (!group->meth->field_encode(group, &point->Y, &point->Y, ctx))
				goto err;
		}
	}
	if (z != NULL) {
		int Z_is_one;

		if (!BN_nnmod(&point->Z, z, &group->field, ctx))
			goto err;
		Z_is_one = BN_is_one(&point->Z);
		if (group->meth->field_encode) {
			if (Z_is_one && (group->meth->field_set_to_one != 0)) {
				if (!group->meth->field_set_to_one(group, &point->Z, ctx))
					goto err;
			} else {
				if (!group->meth->field_encode(group, &point->Z, &point->Z, ctx))
					goto err;
			}
		}
		point->Z_is_one = Z_is_one;
	}
	ret = 1;

err:
	BN_CTX_free(new_ctx);
	return ret;
}


int 
ec_GFp_simple_get_Jprojective_coordinates_GFp(const EC_GROUP * group, const EC_POINT * point,
    BIGNUM * x, BIGNUM * y, BIGNUM * z, BN_CTX * ctx)
{
	BN_CTX *new_ctx = NULL;
	int ret = 0;

	if (group->meth->field_decode != 0) {
		if (ctx == NULL) {
			ctx = new_ctx = BN_CTX_new();
			if (ctx == NULL)
				return 0;
		}
		if (x != NULL) {
			if (!group->meth->field_decode(group, x, &point->X, ctx))
				goto err;
		}
		if (y != NULL) {
			if (!group->meth->field_decode(group, y, &point->Y, ctx))
				goto err;
		}
		if (z != NULL) {
			if (!group->meth->field_decode(group, z, &point->Z, ctx))
				goto err;
		}
	} else {
		if (x != NULL) {
			if (!BN_copy(x, &point->X))
				goto err;
		}
		if (y != NULL) {
			if (!BN_copy(y, &point->Y))
				goto err;
		}
		if (z != NULL) {
			if (!BN_copy(z, &point->Z))
				goto err;
		}
	}

	ret = 1;

err:
	BN_CTX_free(new_ctx);
	return ret;
}


int 
ec_GFp_simple_point_set_affine_coordinates(const EC_GROUP * group, EC_POINT * point,
    const BIGNUM * x, const BIGNUM * y, BN_CTX * ctx)
{
	if (x == NULL || y == NULL) {
		/* unlike for projective coordinates, we do not tolerate this */
		ECerr(EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES, ERR_R_PASSED_NULL_PARAMETER);
		return 0;
	}
	return EC_POINT_set_Jprojective_coordinates_GFp(group, point, x, y, BN_value_one(), ctx);
}


int 
ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP * group, const EC_POINT * point,
    BIGNUM * x, BIGNUM * y, BN_CTX * ctx)
{
	BN_CTX *new_ctx = NULL;
	BIGNUM *Z, *Z_1, *Z_2, *Z_3;
	const BIGNUM *Z_;
	int ret = 0;

	if (EC_POINT_is_at_infinity(group, point) > 0) {
		ECerr(EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES, EC_R_POINT_AT_INFINITY);
		return 0;
	}
	if (ctx == NULL) {
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			return 0;
	}
	BN_CTX_start(ctx);
	if ((Z = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((Z_1 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((Z_2 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((Z_3 = BN_CTX_get(ctx)) == NULL)
		goto err;

	/* transform  (X, Y, Z)  into  (x, y) := (X/Z^2, Y/Z^3) */

	if (group->meth->field_decode) {
		if (!group->meth->field_decode(group, Z, &point->Z, ctx))
			goto err;
		Z_ = Z;
	} else {
		Z_ = &point->Z;
	}

	if (BN_is_one(Z_)) {
		if (group->meth->field_decode) {
			if (x != NULL) {
				if (!group->meth->field_decode(group, x, &point->X, ctx))
					goto err;
			}
			if (y != NULL) {
				if (!group->meth->field_decode(group, y, &point->Y, ctx))
					goto err;
			}
		} else {
			if (x != NULL) {
				if (!BN_copy(x, &point->X))
					goto err;
			}
			if (y != NULL) {
				if (!BN_copy(y, &point->Y))
					goto err;
			}
		}
	} else {
		if (!BN_mod_inverse(Z_1, Z_, &group->field, ctx)) {
			ECerr(EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES, ERR_R_BN_LIB);
			goto err;
		}
		if (group->meth->field_encode == 0) {
			/* field_sqr works on standard representation */
			if (!group->meth->field_sqr(group, Z_2, Z_1, ctx))
				goto err;
		} else {
			if (!BN_mod_sqr(Z_2, Z_1, &group->field, ctx))
				goto err;
		}

		if (x != NULL) {
			/*
			 * in the Montgomery case, field_mul will cancel out
			 * Montgomery factor in X:
			 */
			if (!group->meth->field_mul(group, x, &point->X, Z_2, ctx))
				goto err;
		}
		if (y != NULL) {
			if (group->meth->field_encode == 0) {
				/* field_mul works on standard representation */
				if (!group->meth->field_mul(group, Z_3, Z_2, Z_1, ctx))
					goto err;
			} else {
				if (!BN_mod_mul(Z_3, Z_2, Z_1, &group->field, ctx))
					goto err;
			}

			/*
			 * in the Montgomery case, field_mul will cancel out
			 * Montgomery factor in Y:
			 */
			if (!group->meth->field_mul(group, y, &point->Y, Z_3, ctx))
				goto err;
		}
	}

	ret = 1;

err:
	BN_CTX_end(ctx);
	BN_CTX_free(new_ctx);
	return ret;
}

int 
ec_GFp_simple_add(const EC_GROUP * group, EC_POINT * r, const EC_POINT * a, const EC_POINT * b, BN_CTX * ctx)
{
	int (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
	int (*field_sqr) (const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);
	const BIGNUM *p;
	BN_CTX *new_ctx = NULL;
	BIGNUM *n0, *n1, *n2, *n3, *n4, *n5, *n6;
	int ret = 0;

	if (a == b)
		return EC_POINT_dbl(group, r, a, ctx);
	if (EC_POINT_is_at_infinity(group, a) > 0)
		return EC_POINT_copy(r, b);
	if (EC_POINT_is_at_infinity(group, b) > 0)
		return EC_POINT_copy(r, a);

	field_mul = group->meth->field_mul;
	field_sqr = group->meth->field_sqr;
	p = &group->field;

	if (ctx == NULL) {
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			return 0;
	}
	BN_CTX_start(ctx);
	if ((n0 = BN_CTX_get(ctx)) == NULL)
		goto end;
	if ((n1 = BN_CTX_get(ctx)) == NULL)
		goto end;
	if ((n2 = BN_CTX_get(ctx)) == NULL)
		goto end;
	if ((n3 = BN_CTX_get(ctx)) == NULL)
		goto end;
	if ((n4 = BN_CTX_get(ctx)) == NULL)
		goto end;
	if ((n5 = BN_CTX_get(ctx)) == NULL)
		goto end;
	if ((n6 = BN_CTX_get(ctx)) == NULL)
		goto end;

	/*
	 * Note that in this function we must not read components of 'a' or
	 * 'b' once we have written the corresponding components of 'r'. ('r'
	 * might be one of 'a' or 'b'.)
	 */

	/* n1, n2 */
	if (b->Z_is_one) {
		if (!BN_copy(n1, &a->X))
			goto end;
		if (!BN_copy(n2, &a->Y))
			goto end;
		/* n1 = X_a */
		/* n2 = Y_a */
	} else {
		if (!field_sqr(group, n0, &b->Z, ctx))
			goto end;
		if (!field_mul(group, n1, &a->X, n0, ctx))
			goto end;
		/* n1 = X_a * Z_b^2 */

		if (!field_mul(group, n0, n0, &b->Z, ctx))
			goto end;
		if (!field_mul(group, n2, &a->Y, n0, ctx))
			goto end;
		/* n2 = Y_a * Z_b^3 */
	}

	/* n3, n4 */
	if (a->Z_is_one) {
		if (!BN_copy(n3, &b->X))
			goto end;
		if (!BN_copy(n4, &b->Y))
			goto end;
		/* n3 = X_b */
		/* n4 = Y_b */
	} else {
		if (!field_sqr(group, n0, &a->Z, ctx))
			goto end;
		if (!field_mul(group, n3, &b->X, n0, ctx))
			goto end;
		/* n3 = X_b * Z_a^2 */

		if (!field_mul(group, n0, n0, &a->Z, ctx))
			goto end;
		if (!field_mul(group, n4, &b->Y, n0, ctx))
			goto end;
		/* n4 = Y_b * Z_a^3 */
	}

	/* n5, n6 */
	if (!BN_mod_sub_quick(n5, n1, n3, p))
		goto end;
	if (!BN_mod_sub_quick(n6, n2, n4, p))
		goto end;
	/* n5 = n1 - n3 */
	/* n6 = n2 - n4 */

	if (BN_is_zero(n5)) {
		if (BN_is_zero(n6)) {
			/* a is the same point as b */
			BN_CTX_end(ctx);
			ret = EC_POINT_dbl(group, r, a, ctx);
			ctx = NULL;
			goto end;
		} else {
			/* a is the inverse of b */
			BN_zero(&r->Z);
			r->Z_is_one = 0;
			ret = 1;
			goto end;
		}
	}
	/* 'n7', 'n8' */
	if (!BN_mod_add_quick(n1, n1, n3, p))
		goto end;
	if (!BN_mod_add_quick(n2, n2, n4, p))
		goto end;
	/* 'n7' = n1 + n3 */
	/* 'n8' = n2 + n4 */

	/* Z_r */
	if (a->Z_is_one && b->Z_is_one) {
		if (!BN_copy(&r->Z, n5))
			goto end;
	} else {
		if (a->Z_is_one) {
			if (!BN_copy(n0, &b->Z))
				goto end;
		} else if (b->Z_is_one) {
			if (!BN_copy(n0, &a->Z))
				goto end;
		} else {
			if (!field_mul(group, n0, &a->Z, &b->Z, ctx))
				goto end;
		}
		if (!field_mul(group, &r->Z, n0, n5, ctx))
			goto end;
	}
	r->Z_is_one = 0;
	/* Z_r = Z_a * Z_b * n5 */

	/* X_r */
	if (!field_sqr(group, n0, n6, ctx))
		goto end;
	if (!field_sqr(group, n4, n5, ctx))
		goto end;
	if (!field_mul(group, n3, n1, n4, ctx))
		goto end;
	if (!BN_mod_sub_quick(&r->X, n0, n3, p))
		goto end;
	/* X_r = n6^2 - n5^2 * 'n7' */

	/* 'n9' */
	if (!BN_mod_lshift1_quick(n0, &r->X, p))
		goto end;
	if (!BN_mod_sub_quick(n0, n3, n0, p))
		goto end;
	/* n9 = n5^2 * 'n7' - 2 * X_r */

	/* Y_r */
	if (!field_mul(group, n0, n0, n6, ctx))
		goto end;
	if (!field_mul(group, n5, n4, n5, ctx))
		goto end;	/* now n5 is n5^3 */
	if (!field_mul(group, n1, n2, n5, ctx))
		goto end;
	if (!BN_mod_sub_quick(n0, n0, n1, p))
		goto end;
	if (BN_is_odd(n0))
		if (!BN_add(n0, n0, p))
			goto end;
	/* now  0 <= n0 < 2*p,  and n0 is even */
	if (!BN_rshift1(&r->Y, n0))
		goto end;
	/* Y_r = (n6 * 'n9' - 'n8' * 'n5^3') / 2 */

	ret = 1;

end:
	if (ctx)		/* otherwise we already called BN_CTX_end */
		BN_CTX_end(ctx);
	BN_CTX_free(new_ctx);
	return ret;
}


int 
ec_GFp_simple_dbl(const EC_GROUP * group, EC_POINT * r, const EC_POINT * a, BN_CTX * ctx)
{
	int (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
	int (*field_sqr) (const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);
	const BIGNUM *p;
	BN_CTX *new_ctx = NULL;
	BIGNUM *n0, *n1, *n2, *n3;
	int ret = 0;

	if (EC_POINT_is_at_infinity(group, a) > 0) {
		BN_zero(&r->Z);
		r->Z_is_one = 0;
		return 1;
	}
	field_mul = group->meth->field_mul;
	field_sqr = group->meth->field_sqr;
	p = &group->field;

	if (ctx == NULL) {
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			return 0;
	}
	BN_CTX_start(ctx);
	if ((n0 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((n1 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((n2 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((n3 = BN_CTX_get(ctx)) == NULL)
		goto err;

	/*
	 * Note that in this function we must not read components of 'a' once
	 * we have written the corresponding components of 'r'. ('r' might
	 * the same as 'a'.)
	 */

	/* n1 */
	if (a->Z_is_one) {
		if (!field_sqr(group, n0, &a->X, ctx))
			goto err;
		if (!BN_mod_lshift1_quick(n1, n0, p))
			goto err;
		if (!BN_mod_add_quick(n0, n0, n1, p))
			goto err;
		if (!BN_mod_add_quick(n1, n0, &group->a, p))
			goto err;
		/* n1 = 3 * X_a^2 + a_curve */
	} else if (group->a_is_minus3) {
		if (!field_sqr(group, n1, &a->Z, ctx))
			goto err;
		if (!BN_mod_add_quick(n0, &a->X, n1, p))
			goto err;
		if (!BN_mod_sub_quick(n2, &a->X, n1, p))
			goto err;
		if (!field_mul(group, n1, n0, n2, ctx))
			goto err;
		if (!BN_mod_lshift1_quick(n0, n1, p))
			goto err;
		if (!BN_mod_add_quick(n1, n0, n1, p))
			goto err;
		/*
		 * n1 = 3 * (X_a + Z_a^2) * (X_a - Z_a^2) = 3 * X_a^2 - 3 *
		 * Z_a^4
		 */
	} else {
		if (!field_sqr(group, n0, &a->X, ctx))
			goto err;
		if (!BN_mod_lshift1_quick(n1, n0, p))
			goto err;
		if (!BN_mod_add_quick(n0, n0, n1, p))
			goto err;
		if (!field_sqr(group, n1, &a->Z, ctx))
			goto err;
		if (!field_sqr(group, n1, n1, ctx))
			goto err;
		if (!field_mul(group, n1, n1, &group->a, ctx))
			goto err;
		if (!BN_mod_add_quick(n1, n1, n0, p))
			goto err;
		/* n1 = 3 * X_a^2 + a_curve * Z_a^4 */
	}

	/* Z_r */
	if (a->Z_is_one) {
		if (!BN_copy(n0, &a->Y))
			goto err;
	} else {
		if (!field_mul(group, n0, &a->Y, &a->Z, ctx))
			goto err;
	}
	if (!BN_mod_lshift1_quick(&r->Z, n0, p))
		goto err;
	r->Z_is_one = 0;
	/* Z_r = 2 * Y_a * Z_a */

	/* n2 */
	if (!field_sqr(group, n3, &a->Y, ctx))
		goto err;
	if (!field_mul(group, n2, &a->X, n3, ctx))
		goto err;
	if (!BN_mod_lshift_quick(n2, n2, 2, p))
		goto err;
	/* n2 = 4 * X_a * Y_a^2 */

	/* X_r */
	if (!BN_mod_lshift1_quick(n0, n2, p))
		goto err;
	if (!field_sqr(group, &r->X, n1, ctx))
		goto err;
	if (!BN_mod_sub_quick(&r->X, &r->X, n0, p))
		goto err;
	/* X_r = n1^2 - 2 * n2 */

	/* n3 */
	if (!field_sqr(group, n0, n3, ctx))
		goto err;
	if (!BN_mod_lshift_quick(n3, n0, 3, p))
		goto err;
	/* n3 = 8 * Y_a^4 */

	/* Y_r */
	if (!BN_mod_sub_quick(n0, n2, &r->X, p))
		goto err;
	if (!field_mul(group, n0, n1, n0, ctx))
		goto err;
	if (!BN_mod_sub_quick(&r->Y, n0, n3, p))
		goto err;
	/* Y_r = n1 * (n2 - X_r) - n3 */

	ret = 1;

err:
	BN_CTX_end(ctx);
	BN_CTX_free(new_ctx);
	return ret;
}


int 
ec_GFp_simple_invert(const EC_GROUP * group, EC_POINT * point, BN_CTX * ctx)
{
	if (EC_POINT_is_at_infinity(group, point) > 0 || BN_is_zero(&point->Y))
		/* point is its own inverse */
		return 1;

	return BN_usub(&point->Y, &group->field, &point->Y);
}


int 
ec_GFp_simple_is_at_infinity(const EC_GROUP * group, const EC_POINT * point)
{
	return BN_is_zero(&point->Z);
}


int 
ec_GFp_simple_is_on_curve(const EC_GROUP * group, const EC_POINT * point, BN_CTX * ctx)
{
	int (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
	int (*field_sqr) (const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);
	const BIGNUM *p;
	BN_CTX *new_ctx = NULL;
	BIGNUM *rh, *tmp, *Z4, *Z6;
	int ret = -1;

	if (EC_POINT_is_at_infinity(group, point) > 0)
		return 1;

	field_mul = group->meth->field_mul;
	field_sqr = group->meth->field_sqr;
	p = &group->field;

	if (ctx == NULL) {
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			return -1;
	}
	BN_CTX_start(ctx);
	if ((rh = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((tmp = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((Z4 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((Z6 = BN_CTX_get(ctx)) == NULL)
		goto err;

	/*
	 * We have a curve defined by a Weierstrass equation y^2 = x^3 + a*x
	 * + b. The point to consider is given in Jacobian projective
	 * coordinates where  (X, Y, Z)  represents  (x, y) = (X/Z^2, Y/Z^3).
	 * Substituting this and multiplying by  Z^6  transforms the above
	 * equation into Y^2 = X^3 + a*X*Z^4 + b*Z^6. To test this, we add up
	 * the right-hand side in 'rh'.
	 */

	/* rh := X^2 */
	if (!field_sqr(group, rh, &point->X, ctx))
		goto err;

	if (!point->Z_is_one) {
		if (!field_sqr(group, tmp, &point->Z, ctx))
			goto err;
		if (!field_sqr(group, Z4, tmp, ctx))
			goto err;
		if (!field_mul(group, Z6, Z4, tmp, ctx))
			goto err;

		/* rh := (rh + a*Z^4)*X */
		if (group->a_is_minus3) {
			if (!BN_mod_lshift1_quick(tmp, Z4, p))
				goto err;
			if (!BN_mod_add_quick(tmp, tmp, Z4, p))
				goto err;
			if (!BN_mod_sub_quick(rh, rh, tmp, p))
				goto err;
			if (!field_mul(group, rh, rh, &point->X, ctx))
				goto err;
		} else {
			if (!field_mul(group, tmp, Z4, &group->a, ctx))
				goto err;
			if (!BN_mod_add_quick(rh, rh, tmp, p))
				goto err;
			if (!field_mul(group, rh, rh, &point->X, ctx))
				goto err;
		}

		/* rh := rh + b*Z^6 */
		if (!field_mul(group, tmp, &group->b, Z6, ctx))
			goto err;
		if (!BN_mod_add_quick(rh, rh, tmp, p))
			goto err;
	} else {
		/* point->Z_is_one */

		/* rh := (rh + a)*X */
		if (!BN_mod_add_quick(rh, rh, &group->a, p))
			goto err;
		if (!field_mul(group, rh, rh, &point->X, ctx))
			goto err;
		/* rh := rh + b */
		if (!BN_mod_add_quick(rh, rh, &group->b, p))
			goto err;
	}

	/* 'lh' := Y^2 */
	if (!field_sqr(group, tmp, &point->Y, ctx))
		goto err;

	ret = (0 == BN_ucmp(tmp, rh));

err:
	BN_CTX_end(ctx);
	BN_CTX_free(new_ctx);
	return ret;
}


int 
ec_GFp_simple_cmp(const EC_GROUP * group, const EC_POINT * a, const EC_POINT * b, BN_CTX * ctx)
{
	/*
	 * return values: -1   error 0   equal (in affine coordinates) 1
	 * not equal
	 */

	int (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
	int (*field_sqr) (const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);
	BN_CTX *new_ctx = NULL;
	BIGNUM *tmp1, *tmp2, *Za23, *Zb23;
	const BIGNUM *tmp1_, *tmp2_;
	int ret = -1;

	if (EC_POINT_is_at_infinity(group, a) > 0) {
		return EC_POINT_is_at_infinity(group, b) > 0 ? 0 : 1;
	}
	if (EC_POINT_is_at_infinity(group, b) > 0)
		return 1;

	if (a->Z_is_one && b->Z_is_one) {
		return ((BN_cmp(&a->X, &b->X) == 0) && BN_cmp(&a->Y, &b->Y) == 0) ? 0 : 1;
	}
	field_mul = group->meth->field_mul;
	field_sqr = group->meth->field_sqr;

	if (ctx == NULL) {
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			return -1;
	}
	BN_CTX_start(ctx);
	if ((tmp1 = BN_CTX_get(ctx)) == NULL)
		goto end;
	if ((tmp2 = BN_CTX_get(ctx)) == NULL)
		goto end;
	if ((Za23 = BN_CTX_get(ctx)) == NULL)
		goto end;
	if ((Zb23 = BN_CTX_get(ctx)) == NULL)
		goto end;

	/*
	 * We have to decide whether (X_a/Z_a^2, Y_a/Z_a^3) = (X_b/Z_b^2,
	 * Y_b/Z_b^3), or equivalently, whether (X_a*Z_b^2, Y_a*Z_b^3) =
	 * (X_b*Z_a^2, Y_b*Z_a^3).
	 */

	if (!b->Z_is_one) {
		if (!field_sqr(group, Zb23, &b->Z, ctx))
			goto end;
		if (!field_mul(group, tmp1, &a->X, Zb23, ctx))
			goto end;
		tmp1_ = tmp1;
	} else
		tmp1_ = &a->X;
	if (!a->Z_is_one) {
		if (!field_sqr(group, Za23, &a->Z, ctx))
			goto end;
		if (!field_mul(group, tmp2, &b->X, Za23, ctx))
			goto end;
		tmp2_ = tmp2;
	} else
		tmp2_ = &b->X;

	/* compare  X_a*Z_b^2  with  X_b*Z_a^2 */
	if (BN_cmp(tmp1_, tmp2_) != 0) {
		ret = 1;	/* points differ */
		goto end;
	}
	if (!b->Z_is_one) {
		if (!field_mul(group, Zb23, Zb23, &b->Z, ctx))
			goto end;
		if (!field_mul(group, tmp1, &a->Y, Zb23, ctx))
			goto end;
		/* tmp1_ = tmp1 */
	} else
		tmp1_ = &a->Y;
	if (!a->Z_is_one) {
		if (!field_mul(group, Za23, Za23, &a->Z, ctx))
			goto end;
		if (!field_mul(group, tmp2, &b->Y, Za23, ctx))
			goto end;
		/* tmp2_ = tmp2 */
	} else
		tmp2_ = &b->Y;

	/* compare  Y_a*Z_b^3  with  Y_b*Z_a^3 */
	if (BN_cmp(tmp1_, tmp2_) != 0) {
		ret = 1;	/* points differ */
		goto end;
	}
	/* points are equal */
	ret = 0;

end:
	BN_CTX_end(ctx);
	BN_CTX_free(new_ctx);
	return ret;
}


int 
ec_GFp_simple_make_affine(const EC_GROUP * group, EC_POINT * point, BN_CTX * ctx)
{
	BN_CTX *new_ctx = NULL;
	BIGNUM *x, *y;
	int ret = 0;

	if (point->Z_is_one || EC_POINT_is_at_infinity(group, point) > 0)
		return 1;

	if (ctx == NULL) {
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			return 0;
	}
	BN_CTX_start(ctx);
	if ((x = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((y = BN_CTX_get(ctx)) == NULL)
		goto err;

	if (!EC_POINT_get_affine_coordinates_GFp(group, point, x, y, ctx))
		goto err;
	if (!EC_POINT_set_affine_coordinates_GFp(group, point, x, y, ctx))
		goto err;
	if (!point->Z_is_one) {
		ECerr(EC_F_EC_GFP_SIMPLE_MAKE_AFFINE, ERR_R_INTERNAL_ERROR);
		goto err;
	}
	ret = 1;

err:
	BN_CTX_end(ctx);
	BN_CTX_free(new_ctx);
	return ret;
}


int 
ec_GFp_simple_points_make_affine(const EC_GROUP * group, size_t num, EC_POINT * points[], BN_CTX * ctx)
{
	BN_CTX *new_ctx = NULL;
	BIGNUM *tmp0, *tmp1;
	size_t pow2 = 0;
	BIGNUM **heap = NULL;
	size_t i;
	int ret = 0;

	if (num == 0)
		return 1;

	if (ctx == NULL) {
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			return 0;
	}
	BN_CTX_start(ctx);
	if ((tmp0 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((tmp1 = BN_CTX_get(ctx)) == NULL)
		goto err;

	/*
	 * Before converting the individual points, compute inverses of all Z
	 * values. Modular inversion is rather slow, but luckily we can do
	 * with a single explicit inversion, plus about 3 multiplications per
	 * input value.
	 */

	pow2 = 1;
	while (num > pow2)
		pow2 <<= 1;
	/*
	 * Now pow2 is the smallest power of 2 satifsying pow2 >= num. We
	 * need twice that.
	 */
	pow2 <<= 1;

	heap = reallocarray(NULL, pow2, sizeof heap[0]);
	if (heap == NULL)
		goto err;

	/*
	 * The array is used as a binary tree, exactly as in heapsort:
	 * 
	 * heap[1] heap[2]                     heap[3] heap[4]       heap[5]
	 * heap[6]       heap[7] heap[8]heap[9] heap[10]heap[11]
	 * heap[12]heap[13] heap[14] heap[15]
	 * 
	 * We put the Z's in the last line; then we set each other node to the
	 * product of its two child-nodes (where empty or 0 entries are
	 * treated as ones); then we invert heap[1]; then we invert each
	 * other node by replacing it by the product of its parent (after
	 * inversion) and its sibling (before inversion).
	 */
	heap[0] = NULL;
	for (i = pow2 / 2 - 1; i > 0; i--)
		heap[i] = NULL;
	for (i = 0; i < num; i++)
		heap[pow2 / 2 + i] = &points[i]->Z;
	for (i = pow2 / 2 + num; i < pow2; i++)
		heap[i] = NULL;

	/* set each node to the product of its children */
	for (i = pow2 / 2 - 1; i > 0; i--) {
		heap[i] = BN_new();
		if (heap[i] == NULL)
			goto err;

		if (heap[2 * i] != NULL) {
			if ((heap[2 * i + 1] == NULL) || BN_is_zero(heap[2 * i + 1])) {
				if (!BN_copy(heap[i], heap[2 * i]))
					goto err;
			} else {
				if (BN_is_zero(heap[2 * i])) {
					if (!BN_copy(heap[i], heap[2 * i + 1]))
						goto err;
				} else {
					if (!group->meth->field_mul(group, heap[i],
						heap[2 * i], heap[2 * i + 1], ctx))
						goto err;
				}
			}
		}
	}

	/* invert heap[1] */
	if (!BN_is_zero(heap[1])) {
		if (!BN_mod_inverse(heap[1], heap[1], &group->field, ctx)) {
			ECerr(EC_F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE, ERR_R_BN_LIB);
			goto err;
		}
	}
	if (group->meth->field_encode != 0) {
		/*
		 * in the Montgomery case, we just turned  R*H  (representing
		 * H) into  1/(R*H),  but we need  R*(1/H)  (representing
		 * 1/H); i.e. we have need to multiply by the Montgomery
		 * factor twice
		 */
		if (!group->meth->field_encode(group, heap[1], heap[1], ctx))
			goto err;
		if (!group->meth->field_encode(group, heap[1], heap[1], ctx))
			goto err;
	}
	/* set other heap[i]'s to their inverses */
	for (i = 2; i < pow2 / 2 + num; i += 2) {
		/* i is even */
		if ((heap[i + 1] != NULL) && !BN_is_zero(heap[i + 1])) {
			if (!group->meth->field_mul(group, tmp0, heap[i / 2], heap[i + 1], ctx))
				goto err;
			if (!group->meth->field_mul(group, tmp1, heap[i / 2], heap[i], ctx))
				goto err;
			if (!BN_copy(heap[i], tmp0))
				goto err;
			if (!BN_copy(heap[i + 1], tmp1))
				goto err;
		} else {
			if (!BN_copy(heap[i], heap[i / 2]))
				goto err;
		}
	}

	/*
	 * we have replaced all non-zero Z's by their inverses, now fix up
	 * all the points
	 */
	for (i = 0; i < num; i++) {
		EC_POINT *p = points[i];

		if (!BN_is_zero(&p->Z)) {
			/* turn  (X, Y, 1/Z)  into  (X/Z^2, Y/Z^3, 1) */

			if (!group->meth->field_sqr(group, tmp1, &p->Z, ctx))
				goto err;
			if (!group->meth->field_mul(group, &p->X, &p->X, tmp1, ctx))
				goto err;

			if (!group->meth->field_mul(group, tmp1, tmp1, &p->Z, ctx))
				goto err;
			if (!group->meth->field_mul(group, &p->Y, &p->Y, tmp1, ctx))
				goto err;

			if (group->meth->field_set_to_one != 0) {
				if (!group->meth->field_set_to_one(group, &p->Z, ctx))
					goto err;
			} else {
				if (!BN_one(&p->Z))
					goto err;
			}
			p->Z_is_one = 1;
		}
	}

	ret = 1;

err:
	BN_CTX_end(ctx);
	BN_CTX_free(new_ctx);
	if (heap != NULL) {
		/*
		 * heap[pow2/2] .. heap[pow2-1] have not been allocated
		 * locally!
		 */
		for (i = pow2 / 2 - 1; i > 0; i--) {
			BN_clear_free(heap[i]);
		}
		free(heap);
	}
	return ret;
}


int 
ec_GFp_simple_field_mul(const EC_GROUP * group, BIGNUM * r, const BIGNUM * a, const BIGNUM * b, BN_CTX * ctx)
{
	return BN_mod_mul(r, a, b, &group->field, ctx);
}


int 
ec_GFp_simple_field_sqr(const EC_GROUP * group, BIGNUM * r, const BIGNUM * a, BN_CTX * ctx)
{
	return BN_mod_sqr(r, a, &group->field, ctx);
}
@


1.14
log
@Use `> 0' instead of `!= 0' as a successful condition for
EC_POINT_is_at_infinity() and EC_POINT_is_on_curve(), for they may return -1
should an error arise.
ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ecp_smpl.c,v 1.13 2014/07/12 16:03:37 miod Exp $ */
d191 1
a191 2
	tmp_a = BN_CTX_get(ctx);
	if (tmp_a == NULL)
d296 9
a304 6
	a = BN_CTX_get(ctx);
	b = BN_CTX_get(ctx);
	tmp_1 = BN_CTX_get(ctx);
	tmp_2 = BN_CTX_get(ctx);
	order = BN_CTX_get(ctx);
	if (order == NULL)
d544 7
a550 5
	Z = BN_CTX_get(ctx);
	Z_1 = BN_CTX_get(ctx);
	Z_2 = BN_CTX_get(ctx);
	Z_3 = BN_CTX_get(ctx);
	if (Z_3 == NULL)
d659 13
a671 8
	n0 = BN_CTX_get(ctx);
	n1 = BN_CTX_get(ctx);
	n2 = BN_CTX_get(ctx);
	n3 = BN_CTX_get(ctx);
	n4 = BN_CTX_get(ctx);
	n5 = BN_CTX_get(ctx);
	n6 = BN_CTX_get(ctx);
	if (n6 == NULL)
d846 7
a852 5
	n0 = BN_CTX_get(ctx);
	n1 = BN_CTX_get(ctx);
	n2 = BN_CTX_get(ctx);
	n3 = BN_CTX_get(ctx);
	if (n3 == NULL)
d1004 7
a1010 5
	rh = BN_CTX_get(ctx);
	tmp = BN_CTX_get(ctx);
	Z4 = BN_CTX_get(ctx);
	Z6 = BN_CTX_get(ctx);
	if (Z6 == NULL)
d1117 7
a1123 5
	tmp1 = BN_CTX_get(ctx);
	tmp2 = BN_CTX_get(ctx);
	Za23 = BN_CTX_get(ctx);
	Zb23 = BN_CTX_get(ctx);
	if (Zb23 == NULL)
d1202 3
a1204 3
	x = BN_CTX_get(ctx);
	y = BN_CTX_get(ctx);
	if (y == NULL)
d1243 3
a1245 3
	tmp0 = BN_CTX_get(ctx);
	tmp1 = BN_CTX_get(ctx);
	if (tmp0 == NULL || tmp1 == NULL)
@


1.13
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ecp_smpl.c,v 1.12 2014/06/12 15:49:29 deraadt Exp $ */
d532 1
a532 1
	if (EC_POINT_is_at_infinity(group, point)) {
d640 1
a640 1
	if (EC_POINT_is_at_infinity(group, a))
d642 1
a642 1
	if (EC_POINT_is_at_infinity(group, b))
d822 1
a822 1
	if (EC_POINT_is_at_infinity(group, a)) {
d955 1
a955 1
	if (EC_POINT_is_at_infinity(group, point) || BN_is_zero(&point->Y))
d980 1
a980 1
	if (EC_POINT_is_at_infinity(group, point))
d1086 2
a1087 2
	if (EC_POINT_is_at_infinity(group, a)) {
		return EC_POINT_is_at_infinity(group, b) ? 0 : 1;
d1089 1
a1089 1
	if (EC_POINT_is_at_infinity(group, b))
d1178 1
a1178 1
	if (point->Z_is_one || EC_POINT_is_at_infinity(group, point))
@


1.12
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d225 1
a225 2
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
d269 1
a269 2
	if (new_ctx)
		BN_CTX_free(new_ctx);
d349 1
a349 2
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
d457 1
a457 2
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
d505 1
a505 2
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
d624 1
a624 2
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
d807 1
a807 2
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
d947 1
a947 2
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
d1066 1
a1066 2
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
d1166 1
a1166 2
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
d1204 1
a1204 2
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
d1369 1
a1369 2
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
d1376 1
a1376 2
			if (heap[i] != NULL)
				BN_clear_free(heap[i]);
@


1.11
log
@convert 53 malloc(a*b) to reallocarray(NULL, a, b).  that is 53
potential integer overflows easily changed into an allocation return
of NULL, with errno nicely set if need be.  checks for an allocations
returning NULL are commonplace, or if the object is dereferenced
(quite normal) will result in a nice fault which can be detected &
repaired properly.
ok tedu
@
text
@d1 1
a1 1
/* crypto/ec/ecp_smpl.c */
@


1.10
log
@knf approximation
@
text
@d1260 1
a1260 1
	heap = malloc(pow2 * sizeof heap[0]);
@


1.9
log
@Use C99 initializers for the various FOO_METHOD structs. More readable, and
avoid unreadable/unmaintainable constructs like that:

const EVP_PKEY_ASN1_METHOD cmac_asn1_meth =
        {
        EVP_PKEY_CMAC,
        EVP_PKEY_CMAC,
        0,

        "CMAC",
        "OpenSSL CMAC method",

        0,0,0,0,

        0,0,0,

        cmac_size,
        0,
        0,0,0,0,0,0,0,

        cmac_key_free,
        0,
        0,0
        };

ok matthew@@ deraadt@@
@
text
@d3 1
a3 1
 * for the OpenSSL project. 
d14 1
a14 1
 *    notice, this list of conditions and the following disclaimer. 
d83 1
a83 1
		    ec_GFp_simple_group_check_discriminant,
d90 1
a90 1
		    ec_GFp_simple_set_Jprojective_coordinates_GFp,
d92 5
a96 5
		    ec_GFp_simple_get_Jprojective_coordinates_GFp,
		.point_set_affine_coordinates = 
		    ec_GFp_simple_point_set_affine_coordinates,
		.point_get_affine_coordinates = 
		    ec_GFp_simple_point_get_affine_coordinates,
d127 3
a129 2
int ec_GFp_simple_group_init(EC_GROUP *group)
	{
d135 1
a135 1
	}
d138 3
a140 2
void ec_GFp_simple_group_finish(EC_GROUP *group)
	{
d144 1
a144 1
	}
d147 3
a149 2
void ec_GFp_simple_group_clear_finish(EC_GROUP *group)
	{
d153 1
a153 1
	}
d156 9
a164 5
int ec_GFp_simple_group_copy(EC_GROUP *dest, const EC_GROUP *src)
	{
	if (!BN_copy(&dest->field, &src->field)) return 0;
	if (!BN_copy(&dest->a, &src->a)) return 0;
	if (!BN_copy(&dest->b, &src->b)) return 0;
d169 1
a169 1
	}
d172 4
a175 3
int ec_GFp_simple_group_set_curve(EC_GROUP *group,
	const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
	{
d179 1
a179 1
	
d181 1
a181 2
	if (BN_num_bits(p) <= 2 || !BN_is_odd(p))
		{
d184 2
a185 4
		}

	if (ctx == NULL)
		{
d189 1
a189 2
		}

d192 2
a193 1
	if (tmp_a == NULL) goto err;
d196 2
a197 1
	if (!BN_copy(&group->field, p)) goto err;
d201 8
a208 6
	if (!BN_nnmod(tmp_a, a, p, ctx)) goto err;
	if (group->meth->field_encode)
		{ if (!group->meth->field_encode(group, &group->a, tmp_a, ctx)) goto err; }	
	else
		if (!BN_copy(&group->a, tmp_a)) goto err;
	
d210 2
a211 1
	if (!BN_nnmod(&group->b, b, p, ctx)) goto err;
d213 3
a215 2
		if (!group->meth->field_encode(group, &group->b, &group->b, ctx)) goto err;
	
d217 2
a218 1
	if (!BN_add_word(tmp_a, 3)) goto err;
d223 1
a223 1
 err:
d228 1
a228 1
	}
d231 3
a233 2
int ec_GFp_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)
	{
a235 5
	
	if (p != NULL)
		{
		if (!BN_copy(p, &group->field)) return 0;
		}
d237 7
a243 6
	if (a != NULL || b != NULL)
		{
		if (group->meth->field_decode)
			{
			if (ctx == NULL)
				{
a246 9
				}
			if (a != NULL)
				{
				if (!group->meth->field_decode(group, a, &group->a, ctx)) goto err;
				}
			if (b != NULL)
				{
				if (!group->meth->field_decode(group, b, &group->b, ctx)) goto err;
				}
d248 16
a263 10
		else
			{
			if (a != NULL)
				{
				if (!BN_copy(a, &group->a)) goto err;
				}
			if (b != NULL)
				{
				if (!BN_copy(b, &group->b)) goto err;
				}
d266 1
a266 1
	
d268 2
a269 2
	
 err:
d273 1
a273 1
	}
d276 3
a278 2
int ec_GFp_simple_group_get_degree(const EC_GROUP *group)
	{
d280 1
a280 1
	}
d283 3
a285 2
int ec_GFp_simple_group_check_discriminant(const EC_GROUP *group, BN_CTX *ctx)
	{
d287 1
a287 1
	BIGNUM *a,*b,*order,*tmp_1,*tmp_2;
d291 1
a291 2
	if (ctx == NULL)
		{
d293 1
a293 2
		if (ctx == NULL)
			{
a295 1
			}
d297 1
d304 2
a305 1
	if (order == NULL) goto err;
d307 26
a332 23
	if (group->meth->field_decode)
		{
		if (!group->meth->field_decode(group, a, &group->a, ctx)) goto err;
		if (!group->meth->field_decode(group, b, &group->b, ctx)) goto err;
		}
	else
		{
		if (!BN_copy(a, &group->a)) goto err;
		if (!BN_copy(b, &group->b)) goto err;
		}
	
	/* check the discriminant:
	 * y^2 = x^3 + a*x + b is an elliptic curve <=> 4*a^3 + 27*b^2 != 0 (mod p) 
         * 0 =< a, b < p */
	if (BN_is_zero(a))
		{
		if (BN_is_zero(b)) goto err;
		}
	else if (!BN_is_zero(b))
		{
		if (!BN_mod_sqr(tmp_1, a, p, ctx)) goto err;
		if (!BN_mod_mul(tmp_2, tmp_1, a, p, ctx)) goto err;
		if (!BN_lshift(tmp_1, tmp_2, 2)) goto err;
d335 4
a338 2
		if (!BN_mod_sqr(tmp_2, b, p, ctx)) goto err;
		if (!BN_mul_word(tmp_2, 27)) goto err;
d341 5
a345 3
		if (!BN_mod_add(a, tmp_1, tmp_2, p, ctx)) goto err;
		if (BN_is_zero(a)) goto err;
		}
d354 1
a354 1
	}
d357 3
a359 2
int ec_GFp_simple_point_init(EC_POINT *point)
	{
d366 1
a366 1
	}
d369 3
a371 2
void ec_GFp_simple_point_finish(EC_POINT *point)
	{
d375 1
a375 1
	}
d378 3
a380 2
void ec_GFp_simple_point_clear_finish(EC_POINT *point)
	{
d385 1
a385 1
	}
d388 9
a396 5
int ec_GFp_simple_point_copy(EC_POINT *dest, const EC_POINT *src)
	{
	if (!BN_copy(&dest->X, &src->X)) return 0;
	if (!BN_copy(&dest->Y, &src->Y)) return 0;
	if (!BN_copy(&dest->Z, &src->Z)) return 0;
d400 1
a400 1
	}
d403 3
a405 2
int ec_GFp_simple_point_set_to_infinity(const EC_GROUP *group, EC_POINT *point)
	{
d409 1
a409 1
	}
d412 4
a415 3
int ec_GFp_simple_set_Jprojective_coordinates_GFp(const EC_GROUP *group, EC_POINT *point,
	const BIGNUM *x, const BIGNUM *y, const BIGNUM *z, BN_CTX *ctx)
	{
d418 2
a419 3
	
	if (ctx == NULL)
		{
d423 7
d431 7
a437 8

	if (x != NULL)
		{
		if (!BN_nnmod(&point->X, x, &group->field, ctx)) goto err;
		if (group->meth->field_encode)
			{
			if (!group->meth->field_encode(group, &point->X, &point->X, ctx)) goto err;
			}
d439 2
a440 12
	
	if (y != NULL)
		{
		if (!BN_nnmod(&point->Y, y, &group->field, ctx)) goto err;
		if (group->meth->field_encode)
			{
			if (!group->meth->field_encode(group, &point->Y, &point->Y, ctx)) goto err;
			}
		}
	
	if (z != NULL)
		{
d443 2
a444 1
		if (!BN_nnmod(&point->Z, z, &group->field, ctx)) goto err;
d446 7
a452 10
		if (group->meth->field_encode)
			{
			if (Z_is_one && (group->meth->field_set_to_one != 0))
				{
				if (!group->meth->field_set_to_one(group, &point->Z, ctx)) goto err;
				}
			else
				{
				if (!group->meth->field_encode(group, &point->Z, &point->Z, ctx)) goto err;
				}
d454 1
d456 1
a456 2
		}
	
d458 2
a459 2
	
 err:
d463 1
a463 1
	}
d466 4
a469 3
int ec_GFp_simple_get_Jprojective_coordinates_GFp(const EC_GROUP *group, const EC_POINT *point,
	BIGNUM *x, BIGNUM *y, BIGNUM *z, BN_CTX *ctx)
	{
d472 3
a474 5
	
	if (group->meth->field_decode != 0)
		{
		if (ctx == NULL)
			{
a477 14
			}

		if (x != NULL)
			{
			if (!group->meth->field_decode(group, x, &point->X, ctx)) goto err;
			}
		if (y != NULL)
			{
			if (!group->meth->field_decode(group, y, &point->Y, ctx)) goto err;
			}
		if (z != NULL)
			{
			if (!group->meth->field_decode(group, z, &point->Z, ctx)) goto err;
			}
d479 24
a502 14
	else	
		{
		if (x != NULL)
			{
			if (!BN_copy(x, &point->X)) goto err;
			}
		if (y != NULL)
			{
			if (!BN_copy(y, &point->Y)) goto err;
			}
		if (z != NULL)
			{
			if (!BN_copy(z, &point->Z)) goto err;
			}
d504 2
a505 1
	
d508 1
a508 1
 err:
d512 1
a512 1
	}
d515 5
a519 5
int ec_GFp_simple_point_set_affine_coordinates(const EC_GROUP *group, EC_POINT *point,
	const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx)
	{
	if (x == NULL || y == NULL)
		{
d523 1
a523 2
		}

d525 1
a525 1
	}
d528 4
a531 3
int ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP *group, const EC_POINT *point,
	BIGNUM *x, BIGNUM *y, BN_CTX *ctx)
	{
d537 1
a537 2
	if (EC_POINT_is_at_infinity(group, point))
		{
d540 2
a541 4
		}

	if (ctx == NULL)
		{
d545 1
a545 2
		}

d551 2
a552 1
	if (Z_3 == NULL) goto err;
d555 4
a558 4
	
	if (group->meth->field_decode)
		{
		if (!group->meth->field_decode(group, Z, &point->Z, ctx)) goto err;
d560 1
a560 3
		}
	else
		{
d562 20
a581 25
		}
	
	if (BN_is_one(Z_))
		{
		if (group->meth->field_decode)
			{
			if (x != NULL)
				{
				if (!group->meth->field_decode(group, x, &point->X, ctx)) goto err;
				}
			if (y != NULL)
				{
				if (!group->meth->field_decode(group, y, &point->Y, ctx)) goto err;
				}
			}
		else
			{
			if (x != NULL)
				{
				if (!BN_copy(x, &point->X)) goto err;
				}
			if (y != NULL)
				{
				if (!BN_copy(y, &point->Y)) goto err;
				}
d584 2
a585 4
	else
		{
		if (!BN_mod_inverse(Z_1, Z_, &group->field, ctx))
			{
d588 2
a589 4
			}
		
		if (group->meth->field_encode == 0)
			{
d591 23
a613 1
			if (!group->meth->field_sqr(group, Z_2, Z_1, ctx)) goto err;
a614 22
		else
			{
			if (!BN_mod_sqr(Z_2, Z_1, &group->field, ctx)) goto err;
			}
	
		if (x != NULL)
			{
			/* in the Montgomery case, field_mul will cancel out Montgomery factor in X: */
			if (!group->meth->field_mul(group, x, &point->X, Z_2, ctx)) goto err;
			}

		if (y != NULL)
			{
			if (group->meth->field_encode == 0)
				{
				/* field_mul works on standard representation */
				if (!group->meth->field_mul(group, Z_3, Z_2, Z_1, ctx)) goto err;
				}
			else
				{
				if (!BN_mod_mul(Z_3, Z_2, Z_1, &group->field, ctx)) goto err;
				}
d616 6
a621 3
			/* in the Montgomery case, field_mul will cancel out Montgomery factor in Y: */
			if (!group->meth->field_mul(group, y, &point->Y, Z_3, ctx)) goto err;
			}
d623 1
d627 1
a627 1
 err:
d632 1
a632 1
	}
d634 5
a638 4
int ec_GFp_simple_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx)
	{
	int (*field_mul)(const EC_GROUP *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
	int (*field_sqr)(const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);
d643 1
a643 1
	
d650 1
a650 1
	
d655 1
a655 2
	if (ctx == NULL)
		{
d659 1
a659 2
		}

d668 2
a669 1
	if (n6 == NULL) goto end;
d671 4
a674 3
	/* Note that in this function we must not read components of 'a' or 'b'
	 * once we have written the corresponding components of 'r'.
	 * ('r' might be one of 'a' or 'b'.)
d678 5
a682 4
	if (b->Z_is_one)
		{
		if (!BN_copy(n1, &a->X)) goto end;
		if (!BN_copy(n2, &a->Y)) goto end;
d685 5
a689 5
		}
	else
		{
		if (!field_sqr(group, n0, &b->Z, ctx)) goto end;
		if (!field_mul(group, n1, &a->X, n0, ctx)) goto end;
d692 4
a695 2
		if (!field_mul(group, n0, n0, &b->Z, ctx)) goto end;
		if (!field_mul(group, n2, &a->Y, n0, ctx)) goto end;
d697 1
a697 1
		}
d700 5
a704 4
	if (a->Z_is_one)
		{
		if (!BN_copy(n3, &b->X)) goto end;
		if (!BN_copy(n4, &b->Y)) goto end;
d707 5
a711 5
		}
	else
		{
		if (!field_sqr(group, n0, &a->Z, ctx)) goto end;
		if (!field_mul(group, n3, &b->X, n0, ctx)) goto end;
d714 4
a717 2
		if (!field_mul(group, n0, n0, &a->Z, ctx)) goto end;
		if (!field_mul(group, n4, &b->Y, n0, ctx)) goto end;
d719 1
a719 1
		}
d722 4
a725 2
	if (!BN_mod_sub_quick(n5, n1, n3, p)) goto end;
	if (!BN_mod_sub_quick(n6, n2, n4, p)) goto end;
d729 2
a730 4
	if (BN_is_zero(n5))
		{
		if (BN_is_zero(n6))
			{
d736 1
a736 3
			}
		else
			{
a741 1
			}
d743 1
a743 1

d745 4
a748 2
	if (!BN_mod_add_quick(n1, n1, n3, p)) goto end;
	if (!BN_mod_add_quick(n2, n2, n4, p)) goto end;
d753 13
a765 13
	if (a->Z_is_one && b->Z_is_one)
		{
		if (!BN_copy(&r->Z, n5)) goto end;
		}
	else
		{
		if (a->Z_is_one)
			{ if (!BN_copy(n0, &b->Z)) goto end; }
		else if (b->Z_is_one)
			{ if (!BN_copy(n0, &a->Z)) goto end; }
		else
			{ if (!field_mul(group, n0, &a->Z, &b->Z, ctx)) goto end; }
		if (!field_mul(group, &r->Z, n0, n5, ctx)) goto end;
d767 3
d774 8
a781 4
	if (!field_sqr(group, n0, n6, ctx)) goto end;
	if (!field_sqr(group, n4, n5, ctx)) goto end;
	if (!field_mul(group, n3, n1, n4, ctx)) goto end;
	if (!BN_mod_sub_quick(&r->X, n0, n3, p)) goto end;
d783 1
a783 1
	
d785 4
a788 2
	if (!BN_mod_lshift1_quick(n0, &r->X, p)) goto end;
	if (!BN_mod_sub_quick(n0, n3, n0, p)) goto end;
d792 8
a799 4
	if (!field_mul(group, n0, n0, n6, ctx)) goto end;
	if (!field_mul(group, n5, n4, n5, ctx)) goto end; /* now n5 is n5^3 */
	if (!field_mul(group, n1, n2, n5, ctx)) goto end;
	if (!BN_mod_sub_quick(n0, n0, n1, p)) goto end;
d801 2
a802 1
		if (!BN_add(n0, n0, p)) goto end;
d804 2
a805 1
	if (!BN_rshift1(&r->Y, n0)) goto end;
d810 2
a811 2
 end:
	if (ctx) /* otherwise we already called BN_CTX_end */
d816 1
a816 1
	}
d819 5
a823 4
int ec_GFp_simple_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, BN_CTX *ctx)
	{
	int (*field_mul)(const EC_GROUP *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
	int (*field_sqr)(const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);
d828 2
a829 3
	
	if (EC_POINT_is_at_infinity(group, a))
		{
d833 1
a833 2
		}

d838 1
a838 2
	if (ctx == NULL)
		{
d842 1
a842 2
		}

d848 2
a849 1
	if (n3 == NULL) goto err;
d851 4
a854 3
	/* Note that in this function we must not read components of 'a'
	 * once we have written the corresponding components of 'r'.
	 * ('r' might the same as 'a'.)
d858 9
a866 6
	if (a->Z_is_one)
		{
		if (!field_sqr(group, n0, &a->X, ctx)) goto err;
		if (!BN_mod_lshift1_quick(n1, n0, p)) goto err;
		if (!BN_mod_add_quick(n0, n0, n1, p)) goto err;
		if (!BN_mod_add_quick(n1, n0, &group->a, p)) goto err;
d868 32
a899 21
		}
	else if (group->a_is_minus3)
		{
		if (!field_sqr(group, n1, &a->Z, ctx)) goto err;
		if (!BN_mod_add_quick(n0, &a->X, n1, p)) goto err;
		if (!BN_mod_sub_quick(n2, &a->X, n1, p)) goto err;
		if (!field_mul(group, n1, n0, n2, ctx)) goto err;
		if (!BN_mod_lshift1_quick(n0, n1, p)) goto err;
		if (!BN_mod_add_quick(n1, n0, n1, p)) goto err;
		/* n1 = 3 * (X_a + Z_a^2) * (X_a - Z_a^2)
		 *    = 3 * X_a^2 - 3 * Z_a^4 */
		}
	else
		{
		if (!field_sqr(group, n0, &a->X, ctx)) goto err;
		if (!BN_mod_lshift1_quick(n1, n0, p)) goto err;
		if (!BN_mod_add_quick(n0, n0, n1, p)) goto err;
		if (!field_sqr(group, n1, &a->Z, ctx)) goto err;
		if (!field_sqr(group, n1, n1, ctx)) goto err;
		if (!field_mul(group, n1, n1, &group->a, ctx)) goto err;
		if (!BN_mod_add_quick(n1, n1, n0, p)) goto err;
d901 1
a901 1
		}
d904 9
a912 9
	if (a->Z_is_one)
		{
		if (!BN_copy(n0, &a->Y)) goto err;
		}
	else
		{
		if (!field_mul(group, n0, &a->Y, &a->Z, ctx)) goto err;
		}
	if (!BN_mod_lshift1_quick(&r->Z, n0, p)) goto err;
d917 6
a922 3
	if (!field_sqr(group, n3, &a->Y, ctx)) goto err;
	if (!field_mul(group, n2, &a->X, n3, ctx)) goto err;
	if (!BN_mod_lshift_quick(n2, n2, 2, p)) goto err;
d926 6
a931 3
	if (!BN_mod_lshift1_quick(n0, n2, p)) goto err;
	if (!field_sqr(group, &r->X, n1, ctx)) goto err;
	if (!BN_mod_sub_quick(&r->X, &r->X, n0, p)) goto err;
d933 1
a933 1
	
d935 4
a938 2
	if (!field_sqr(group, n0, n3, ctx)) goto err;
	if (!BN_mod_lshift_quick(n3, n0, 3, p)) goto err;
d940 1
a940 1
	
d942 6
a947 3
	if (!BN_mod_sub_quick(n0, n2, &r->X, p)) goto err;
	if (!field_mul(group, n0, n1, n0, ctx)) goto err;
	if (!BN_mod_sub_quick(&r->Y, n0, n3, p)) goto err;
d952 1
a952 1
 err:
d957 1
a957 1
	}
d960 3
a962 2
int ec_GFp_simple_invert(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)
	{
d966 1
a966 1
	
d968 1
a968 1
	}
d971 3
a973 2
int ec_GFp_simple_is_at_infinity(const EC_GROUP *group, const EC_POINT *point)
	{
d975 1
a975 1
	}
d978 5
a982 4
int ec_GFp_simple_is_on_curve(const EC_GROUP *group, const EC_POINT *point, BN_CTX *ctx)
	{
	int (*field_mul)(const EC_GROUP *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
	int (*field_sqr)(const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);
d990 1
a990 1
	
d995 1
a995 2
	if (ctx == NULL)
		{
d999 1
a999 2
		}

d1005 2
a1006 1
	if (Z6 == NULL) goto err;
d1008 7
a1014 7
	/* We have a curve defined by a Weierstrass equation
	 *      y^2 = x^3 + a*x + b.
	 * The point to consider is given in Jacobian projective coordinates
	 * where  (X, Y, Z)  represents  (x, y) = (X/Z^2, Y/Z^3).
	 * Substituting this and multiplying by  Z^6  transforms the above equation into
	 *      Y^2 = X^3 + a*X*Z^4 + b*Z^6.
	 * To test this, we add up the right-hand side in 'rh'.
d1018 2
a1019 1
	if (!field_sqr(group, rh, &point->X, ctx)) goto err;
d1021 7
a1027 5
	if (!point->Z_is_one)
		{
		if (!field_sqr(group, tmp, &point->Z, ctx)) goto err;
		if (!field_sqr(group, Z4, tmp, ctx)) goto err;
		if (!field_mul(group, Z6, Z4, tmp, ctx)) goto err;
d1030 17
a1046 13
		if (group->a_is_minus3)
			{
			if (!BN_mod_lshift1_quick(tmp, Z4, p)) goto err;
			if (!BN_mod_add_quick(tmp, tmp, Z4, p)) goto err;
			if (!BN_mod_sub_quick(rh, rh, tmp, p)) goto err;
			if (!field_mul(group, rh, rh, &point->X, ctx)) goto err;
			}
		else
			{
			if (!field_mul(group, tmp, Z4, &group->a, ctx)) goto err;
			if (!BN_mod_add_quick(rh, rh, tmp, p)) goto err;
			if (!field_mul(group, rh, rh, &point->X, ctx)) goto err;
			}
d1049 5
a1053 5
		if (!field_mul(group, tmp, &group->b, Z6, ctx)) goto err;
		if (!BN_mod_add_quick(rh, rh, tmp, p)) goto err;
		}
	else
		{
d1057 4
a1060 2
		if (!BN_mod_add_quick(rh, rh, &group->a, p)) goto err;
		if (!field_mul(group, rh, rh, &point->X, ctx)) goto err;
d1062 3
a1064 2
		if (!BN_mod_add_quick(rh, rh, &group->b, p)) goto err;
		}
d1067 2
a1068 1
	if (!field_sqr(group, tmp, &point->Y, ctx)) goto err;
d1072 1
a1072 1
 err:
d1077 1
a1077 1
	}
d1080 6
a1085 6
int ec_GFp_simple_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx)
	{
	/* return values:
	 *  -1   error
	 *   0   equal (in affine coordinates)
	 *   1   not equal
d1088 2
a1089 2
	int (*field_mul)(const EC_GROUP *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
	int (*field_sqr)(const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);
d1094 2
a1095 3
	
	if (EC_POINT_is_at_infinity(group, a))
		{
d1097 1
a1097 2
		}

d1100 2
a1101 3
	
	if (a->Z_is_one && b->Z_is_one)
		{
d1103 1
a1103 2
		}

d1107 1
a1107 2
	if (ctx == NULL)
		{
d1111 1
a1111 2
		}

d1117 2
a1118 1
	if (Zb23 == NULL) goto end;
d1120 4
a1123 4
	/* We have to decide whether
	 *     (X_a/Z_a^2, Y_a/Z_a^3) = (X_b/Z_b^2, Y_b/Z_b^3),
	 * or equivalently, whether
	 *     (X_a*Z_b^2, Y_a*Z_b^3) = (X_b*Z_a^2, Y_b*Z_a^3).
d1126 5
a1130 4
	if (!b->Z_is_one)
		{
		if (!field_sqr(group, Zb23, &b->Z, ctx)) goto end;
		if (!field_mul(group, tmp1, &a->X, Zb23, ctx)) goto end;
d1132 1
a1132 2
		}
	else
d1134 5
a1138 4
	if (!a->Z_is_one)
		{
		if (!field_sqr(group, Za23, &a->Z, ctx)) goto end;
		if (!field_mul(group, tmp2, &b->X, Za23, ctx)) goto end;
d1140 1
a1140 2
		}
	else
d1142 1
a1142 1
	
d1144 2
a1145 3
	if (BN_cmp(tmp1_, tmp2_) != 0)
		{
		ret = 1; /* points differ */
d1147 6
a1152 7
		}


	if (!b->Z_is_one)
		{
		if (!field_mul(group, Zb23, Zb23, &b->Z, ctx)) goto end;
		if (!field_mul(group, tmp1, &a->Y, Zb23, ctx)) goto end;
d1154 1
a1154 2
		}
	else
d1156 5
a1160 4
	if (!a->Z_is_one)
		{
		if (!field_mul(group, Za23, Za23, &a->Z, ctx)) goto end;
		if (!field_mul(group, tmp2, &b->Y, Za23, ctx)) goto end;
d1162 1
a1162 2
		}
	else
d1166 2
a1167 3
	if (BN_cmp(tmp1_, tmp2_) != 0)
		{
		ret = 1; /* points differ */
d1169 1
a1169 2
		}

d1173 1
a1173 1
 end:
d1178 1
a1178 1
	}
d1181 3
a1183 2
int ec_GFp_simple_make_affine(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)
	{
d1191 1
a1191 2
	if (ctx == NULL)
		{
d1195 1
a1195 2
		}

d1199 2
a1200 1
	if (y == NULL) goto err;
d1202 5
a1206 4
	if (!EC_POINT_get_affine_coordinates_GFp(group, point, x, y, ctx)) goto err;
	if (!EC_POINT_set_affine_coordinates_GFp(group, point, x, y, ctx)) goto err;
	if (!point->Z_is_one)
		{
d1209 1
a1209 2
		}
	
d1212 1
a1212 1
 err:
d1217 1
a1217 1
	}
d1220 3
a1222 2
int ec_GFp_simple_points_make_affine(const EC_GROUP *group, size_t num, EC_POINT *points[], BN_CTX *ctx)
	{
d1233 1
a1233 2
	if (ctx == NULL)
		{
d1237 1
a1237 2
		}

d1241 2
a1242 1
	if (tmp0  == NULL || tmp1 == NULL) goto err;
d1244 5
a1248 3
	/* Before converting the individual points, compute inverses of all Z values.
	 * Modular inversion is rather slow, but luckily we can do with a single
	 * explicit inversion, plus about 3 multiplications per input value.
d1254 4
a1257 2
	/* Now pow2 is the smallest power of 2 satifsying pow2 >= num.
	 * We need twice that. */
d1261 15
a1275 15
	if (heap == NULL) goto err;
	
	/* The array is used as a binary tree, exactly as in heapsort:
	 *
	 *                               heap[1]
	 *                 heap[2]                     heap[3]
	 *          heap[4]       heap[5]       heap[6]       heap[7]
	 *   heap[8]heap[9] heap[10]heap[11] heap[12]heap[13] heap[14] heap[15]
	 *
	 * We put the Z's in the last line;
	 * then we set each other node to the product of its two child-nodes (where
	 * empty or 0 entries are treated as ones);
	 * then we invert heap[1];
	 * then we invert each other node by replacing it by the product of its
	 * parent (after inversion) and its sibling (before inversion).
d1278 1
a1278 1
	for (i = pow2/2 - 1; i > 0; i--)
d1281 2
a1282 2
		heap[pow2/2 + i] = &points[i]->Z;
	for (i = pow2/2 + num; i < pow2; i++)
d1284 1
a1284 1
	
d1286 1
a1286 2
	for (i = pow2/2 - 1; i > 0; i--)
		{
d1288 12
a1299 16
		if (heap[i] == NULL) goto err;
		
		if (heap[2*i] != NULL)
			{
			if ((heap[2*i + 1] == NULL) || BN_is_zero(heap[2*i + 1]))
				{
				if (!BN_copy(heap[i], heap[2*i])) goto err;
				}
			else
				{
				if (BN_is_zero(heap[2*i]))
					{
					if (!BN_copy(heap[i], heap[2*i + 1])) goto err;
					}
				else
					{
d1301 2
a1302 2
						heap[2*i], heap[2*i + 1], ctx)) goto err;
					}
d1306 1
d1309 2
a1310 4
	if (!BN_is_zero(heap[1]))
		{
		if (!BN_mod_inverse(heap[1], heap[1], &group->field, ctx))
			{
a1312 1
			}
d1314 13
a1326 9
	if (group->meth->field_encode != 0)
		{
		/* in the Montgomery case, we just turned  R*H  (representing H)
		 * into  1/(R*H),  but we need  R*(1/H)  (representing 1/H);
		 * i.e. we have need to multiply by the Montgomery factor twice */
		if (!group->meth->field_encode(group, heap[1], heap[1], ctx)) goto err;
		if (!group->meth->field_encode(group, heap[1], heap[1], ctx)) goto err;
		}

d1328 1
a1328 2
	for (i = 2; i < pow2/2 + num; i += 2)
		{
d1330 12
a1341 11
		if ((heap[i + 1] != NULL) && !BN_is_zero(heap[i + 1]))
			{
			if (!group->meth->field_mul(group, tmp0, heap[i/2], heap[i + 1], ctx)) goto err;
			if (!group->meth->field_mul(group, tmp1, heap[i/2], heap[i], ctx)) goto err;
			if (!BN_copy(heap[i], tmp0)) goto err;
			if (!BN_copy(heap[i + 1], tmp1)) goto err;
			}
		else
			{
			if (!BN_copy(heap[i], heap[i/2])) goto err;
			}
d1343 1
d1345 5
a1349 3
	/* we have replaced all non-zero Z's by their inverses, now fix up all the points */
	for (i = 0; i < num; i++)
		{
d1351 2
a1352 3
		
		if (!BN_is_zero(&p->Z))
			{
d1355 17
a1371 14
			if (!group->meth->field_sqr(group, tmp1, &p->Z, ctx)) goto err;
			if (!group->meth->field_mul(group, &p->X, &p->X, tmp1, ctx)) goto err;

			if (!group->meth->field_mul(group, tmp1, tmp1, &p->Z, ctx)) goto err;
			if (!group->meth->field_mul(group, &p->Y, &p->Y, tmp1, ctx)) goto err;
		
			if (group->meth->field_set_to_one != 0)
				{
				if (!group->meth->field_set_to_one(group, &p->Z, ctx)) goto err;
				}
			else
				{
				if (!BN_one(&p->Z)) goto err;
				}
a1372 1
			}
d1374 1
d1377 2
a1378 2
		
 err:
d1382 6
a1387 5
	if (heap != NULL)
		{
		/* heap[pow2/2] .. heap[pow2-1] have not been allocated locally! */
		for (i = pow2/2 - 1; i > 0; i--)
			{
d1390 1
a1390 1
			}
d1392 1
a1392 1
		}
d1394 1
a1394 1
	}
d1397 3
a1399 2
int ec_GFp_simple_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
	{
d1401 1
a1401 1
	}
d1404 3
a1406 2
int ec_GFp_simple_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)
	{
d1408 1
a1408 1
	}
@


1.8
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d69 3
a71 2
const EC_METHOD *EC_GFp_simple_method(void)
	{
d73 35
a107 37
		EC_FLAGS_DEFAULT_OCT,
		NID_X9_62_prime_field,
		ec_GFp_simple_group_init,
		ec_GFp_simple_group_finish,
		ec_GFp_simple_group_clear_finish,
		ec_GFp_simple_group_copy,
		ec_GFp_simple_group_set_curve,
		ec_GFp_simple_group_get_curve,
		ec_GFp_simple_group_get_degree,
		ec_GFp_simple_group_check_discriminant,
		ec_GFp_simple_point_init,
		ec_GFp_simple_point_finish,
		ec_GFp_simple_point_clear_finish,
		ec_GFp_simple_point_copy,
		ec_GFp_simple_point_set_to_infinity,
		ec_GFp_simple_set_Jprojective_coordinates_GFp,
		ec_GFp_simple_get_Jprojective_coordinates_GFp,
		ec_GFp_simple_point_set_affine_coordinates,
		ec_GFp_simple_point_get_affine_coordinates,
		0,0,0,
		ec_GFp_simple_add,
		ec_GFp_simple_dbl,
		ec_GFp_simple_invert,
		ec_GFp_simple_is_at_infinity,
		ec_GFp_simple_is_on_curve,
		ec_GFp_simple_cmp,
		ec_GFp_simple_make_affine,
		ec_GFp_simple_points_make_affine,
		0 /* mul */,
		0 /* precompute_mult */,
		0 /* have_precompute_mult */,	
		ec_GFp_simple_field_mul,
		ec_GFp_simple_field_sqr,
		0 /* field_div */,
		0 /* field_encode */,
		0 /* field_decode */,
		0 /* field_set_to_one */ };
d110 1
a110 1
	}
@


1.7
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok beck deraadt
@
text
@d1208 1
a1208 1
	heap = OPENSSL_malloc(pow2 * sizeof heap[0]);
d1336 1
a1336 1
		OPENSSL_free(heap);
@


1.6
log
@Cope with the removal of openssl/symhacks.h
@
text
@a66 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

a70 3
#ifdef OPENSSL_FIPS
	return fips_ec_gfp_simple_method();
#else
a110 1
#endif
@


1.5
log
@resolve conflicts
@
text
@a65 1
#include <openssl/symhacks.h>
@


1.5.4.1
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@d1184 3
a1186 2
	BIGNUM *tmp, *tmp_Z;
	BIGNUM **prod_Z = NULL;
d1201 36
a1236 6
	tmp = BN_CTX_get(ctx);
	tmp_Z = BN_CTX_get(ctx);
	if (tmp == NULL || tmp_Z == NULL) goto err;

	prod_Z = OPENSSL_malloc(num * sizeof prod_Z[0]);
	if (prod_Z == NULL) goto err;
d1238 11
a1248 15
		{
		prod_Z[i] = BN_new();
		if (prod_Z[i] == NULL) goto err;
		}

	/* Set each prod_Z[i] to the product of points[0]->Z .. points[i]->Z,
	 * skipping any zero-valued inputs (pretend that they're 1). */

	if (!BN_is_zero(&points[0]->Z))
		{
		if (!BN_copy(prod_Z[0], &points[0]->Z)) goto err;
		}
	else
		{
		if (group->meth->field_set_to_one != 0)
d1250 16
a1265 5
			if (!group->meth->field_set_to_one(group, prod_Z[0], ctx)) goto err;
			}
		else
			{
			if (!BN_one(prod_Z[0])) goto err;
d1269 2
a1270 1
	for (i = 1; i < num; i++)
d1272 1
a1272 1
		if (!BN_is_zero(&points[i]->Z))
d1274 2
a1275 1
			if (!group->meth->field_mul(group, prod_Z[i], prod_Z[i - 1], &points[i]->Z, ctx)) goto err;
a1276 13
		else
			{
			if (!BN_copy(prod_Z[i], prod_Z[i - 1])) goto err;
			}
		}

	/* Now use a single explicit inversion to replace every
	 * non-zero points[i]->Z by its inverse. */

	if (!BN_mod_inverse(tmp, prod_Z[num - 1], &group->field, ctx))
		{
		ECerr(EC_F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE, ERR_R_BN_LIB);
		goto err;
d1280 1
a1280 1
		/* In the Montgomery case, we just turned  R*H  (representing H)
d1282 3
a1284 3
		 * i.e. we need to multiply by the Montgomery factor twice. */
		if (!group->meth->field_encode(group, tmp, tmp, ctx)) goto err;
		if (!group->meth->field_encode(group, tmp, tmp, ctx)) goto err;
d1287 2
a1288 1
	for (i = num - 1; i > 0; --i)
d1290 9
a1298 3
		/* Loop invariant: tmp is the product of the inverses of
		 * points[0]->Z .. points[i]->Z (zero-valued inputs skipped). */
		if (!BN_is_zero(&points[i]->Z))
d1300 1
a1300 7
			/* Set tmp_Z to the inverse of points[i]->Z (as product
			 * of Z inverses 0 .. i, Z values 0 .. i - 1). */
			if (!group->meth->field_mul(group, tmp_Z, prod_Z[i - 1], tmp, ctx)) goto err;
			/* Update tmp to satisfy the loop invariant for i - 1. */
			if (!group->meth->field_mul(group, tmp, tmp, &points[i]->Z, ctx)) goto err;
			/* Replace points[i]->Z by its inverse. */
			if (!BN_copy(&points[i]->Z, tmp_Z)) goto err;
d1304 1
a1304 8
	if (!BN_is_zero(&points[0]->Z))
		{
		/* Replace points[0]->Z by its inverse. */
		if (!BN_copy(&points[0]->Z, tmp)) goto err;
		}

	/* Finally, fix up the X and Y coordinates for all points. */

d1308 1
a1308 1

d1313 2
a1314 5
			if (!group->meth->field_sqr(group, tmp, &p->Z, ctx)) goto err;
			if (!group->meth->field_mul(group, &p->X, &p->X, tmp, ctx)) goto err;

			if (!group->meth->field_mul(group, tmp, tmp, &p->Z, ctx)) goto err;
			if (!group->meth->field_mul(group, &p->Y, &p->Y, tmp, ctx)) goto err;
d1316 3
d1332 1
a1332 1

d1337 1
a1337 1
	if (prod_Z != NULL)
d1339 2
a1340 1
		for (i = 0; i < num; i++)
d1342 2
a1343 2
			if (prod_Z[i] != NULL)
				BN_clear_free(prod_Z[i]);
d1345 1
a1345 1
		OPENSSL_free(prod_Z);
@


1.5.8.1
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@d1184 3
a1186 2
	BIGNUM *tmp, *tmp_Z;
	BIGNUM **prod_Z = NULL;
d1201 36
a1236 6
	tmp = BN_CTX_get(ctx);
	tmp_Z = BN_CTX_get(ctx);
	if (tmp == NULL || tmp_Z == NULL) goto err;

	prod_Z = OPENSSL_malloc(num * sizeof prod_Z[0]);
	if (prod_Z == NULL) goto err;
d1238 11
a1248 15
		{
		prod_Z[i] = BN_new();
		if (prod_Z[i] == NULL) goto err;
		}

	/* Set each prod_Z[i] to the product of points[0]->Z .. points[i]->Z,
	 * skipping any zero-valued inputs (pretend that they're 1). */

	if (!BN_is_zero(&points[0]->Z))
		{
		if (!BN_copy(prod_Z[0], &points[0]->Z)) goto err;
		}
	else
		{
		if (group->meth->field_set_to_one != 0)
d1250 16
a1265 5
			if (!group->meth->field_set_to_one(group, prod_Z[0], ctx)) goto err;
			}
		else
			{
			if (!BN_one(prod_Z[0])) goto err;
d1269 2
a1270 1
	for (i = 1; i < num; i++)
d1272 1
a1272 1
		if (!BN_is_zero(&points[i]->Z))
d1274 2
a1275 1
			if (!group->meth->field_mul(group, prod_Z[i], prod_Z[i - 1], &points[i]->Z, ctx)) goto err;
a1276 13
		else
			{
			if (!BN_copy(prod_Z[i], prod_Z[i - 1])) goto err;
			}
		}

	/* Now use a single explicit inversion to replace every
	 * non-zero points[i]->Z by its inverse. */

	if (!BN_mod_inverse(tmp, prod_Z[num - 1], &group->field, ctx))
		{
		ECerr(EC_F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE, ERR_R_BN_LIB);
		goto err;
d1280 1
a1280 1
		/* In the Montgomery case, we just turned  R*H  (representing H)
d1282 3
a1284 3
		 * i.e. we need to multiply by the Montgomery factor twice. */
		if (!group->meth->field_encode(group, tmp, tmp, ctx)) goto err;
		if (!group->meth->field_encode(group, tmp, tmp, ctx)) goto err;
d1287 2
a1288 1
	for (i = num - 1; i > 0; --i)
d1290 9
a1298 3
		/* Loop invariant: tmp is the product of the inverses of
		 * points[0]->Z .. points[i]->Z (zero-valued inputs skipped). */
		if (!BN_is_zero(&points[i]->Z))
d1300 1
a1300 7
			/* Set tmp_Z to the inverse of points[i]->Z (as product
			 * of Z inverses 0 .. i, Z values 0 .. i - 1). */
			if (!group->meth->field_mul(group, tmp_Z, prod_Z[i - 1], tmp, ctx)) goto err;
			/* Update tmp to satisfy the loop invariant for i - 1. */
			if (!group->meth->field_mul(group, tmp, tmp, &points[i]->Z, ctx)) goto err;
			/* Replace points[i]->Z by its inverse. */
			if (!BN_copy(&points[i]->Z, tmp_Z)) goto err;
d1304 1
a1304 8
	if (!BN_is_zero(&points[0]->Z))
		{
		/* Replace points[0]->Z by its inverse. */
		if (!BN_copy(&points[0]->Z, tmp)) goto err;
		}

	/* Finally, fix up the X and Y coordinates for all points. */

d1308 1
a1308 1

d1313 2
a1314 5
			if (!group->meth->field_sqr(group, tmp, &p->Z, ctx)) goto err;
			if (!group->meth->field_mul(group, &p->X, &p->X, tmp, ctx)) goto err;

			if (!group->meth->field_mul(group, tmp, tmp, &p->Z, ctx)) goto err;
			if (!group->meth->field_mul(group, &p->Y, &p->Y, tmp, ctx)) goto err;
d1316 3
d1332 1
a1332 1

d1337 1
a1337 1
	if (prod_Z != NULL)
d1339 2
a1340 1
		for (i = 0; i < num; i++)
d1342 2
a1343 2
			if (prod_Z[i] != NULL)
				BN_clear_free(prod_Z[i]);
d1345 1
a1345 1
		OPENSSL_free(prod_Z);
@


1.4
log
@openssl-1.0.0e: resolve conflicts
@
text
@d68 4
d76 3
d80 1
d99 1
a99 3
		ec_GFp_simple_set_compressed_coordinates,
		ec_GFp_simple_point2oct,
		ec_GFp_simple_oct2point,
d119 1
a641 366


int ec_GFp_simple_set_compressed_coordinates(const EC_GROUP *group, EC_POINT *point,
	const BIGNUM *x_, int y_bit, BN_CTX *ctx)
	{
	BN_CTX *new_ctx = NULL;
	BIGNUM *tmp1, *tmp2, *x, *y;
	int ret = 0;

	/* clear error queue*/
	ERR_clear_error();

	if (ctx == NULL)
		{
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			return 0;
		}

	y_bit = (y_bit != 0);

	BN_CTX_start(ctx);
	tmp1 = BN_CTX_get(ctx);
	tmp2 = BN_CTX_get(ctx);
	x = BN_CTX_get(ctx);
	y = BN_CTX_get(ctx);
	if (y == NULL) goto err;

	/* Recover y.  We have a Weierstrass equation
	 *     y^2 = x^3 + a*x + b,
	 * so  y  is one of the square roots of  x^3 + a*x + b.
	 */

	/* tmp1 := x^3 */
	if (!BN_nnmod(x, x_, &group->field,ctx)) goto err;
	if (group->meth->field_decode == 0)
		{
		/* field_{sqr,mul} work on standard representation */
		if (!group->meth->field_sqr(group, tmp2, x_, ctx)) goto err;
		if (!group->meth->field_mul(group, tmp1, tmp2, x_, ctx)) goto err;
		}
	else
		{
		if (!BN_mod_sqr(tmp2, x_, &group->field, ctx)) goto err;
		if (!BN_mod_mul(tmp1, tmp2, x_, &group->field, ctx)) goto err;
		}
	
	/* tmp1 := tmp1 + a*x */
	if (group->a_is_minus3)
		{
		if (!BN_mod_lshift1_quick(tmp2, x, &group->field)) goto err;
		if (!BN_mod_add_quick(tmp2, tmp2, x, &group->field)) goto err;
		if (!BN_mod_sub_quick(tmp1, tmp1, tmp2, &group->field)) goto err;
		}
	else
		{
		if (group->meth->field_decode)
			{
			if (!group->meth->field_decode(group, tmp2, &group->a, ctx)) goto err;
			if (!BN_mod_mul(tmp2, tmp2, x, &group->field, ctx)) goto err;
			}
		else
			{
			/* field_mul works on standard representation */
			if (!group->meth->field_mul(group, tmp2, &group->a, x, ctx)) goto err;
			}
		
		if (!BN_mod_add_quick(tmp1, tmp1, tmp2, &group->field)) goto err;
		}
	
	/* tmp1 := tmp1 + b */
	if (group->meth->field_decode)
		{
		if (!group->meth->field_decode(group, tmp2, &group->b, ctx)) goto err;
		if (!BN_mod_add_quick(tmp1, tmp1, tmp2, &group->field)) goto err;
		}
	else
		{
		if (!BN_mod_add_quick(tmp1, tmp1, &group->b, &group->field)) goto err;
		}
	
	if (!BN_mod_sqrt(y, tmp1, &group->field, ctx))
		{
		unsigned long err = ERR_peek_last_error();
		
		if (ERR_GET_LIB(err) == ERR_LIB_BN && ERR_GET_REASON(err) == BN_R_NOT_A_SQUARE)
			{
			ERR_clear_error();
			ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES, EC_R_INVALID_COMPRESSED_POINT);
			}
		else
			ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES, ERR_R_BN_LIB);
		goto err;
		}

	if (y_bit != BN_is_odd(y))
		{
		if (BN_is_zero(y))
			{
			int kron;

			kron = BN_kronecker(x, &group->field, ctx);
			if (kron == -2) goto err;

			if (kron == 1)
				ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES, EC_R_INVALID_COMPRESSION_BIT);
			else
				/* BN_mod_sqrt() should have cought this error (not a square) */
				ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES, EC_R_INVALID_COMPRESSED_POINT);
			goto err;
			}
		if (!BN_usub(y, &group->field, y)) goto err;
		}
	if (y_bit != BN_is_odd(y))
		{
		ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES, ERR_R_INTERNAL_ERROR);
		goto err;
		}

	if (!EC_POINT_set_affine_coordinates_GFp(group, point, x, y, ctx)) goto err;

	ret = 1;

 err:
	BN_CTX_end(ctx);
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
	return ret;
	}


size_t ec_GFp_simple_point2oct(const EC_GROUP *group, const EC_POINT *point, point_conversion_form_t form,
	unsigned char *buf, size_t len, BN_CTX *ctx)
	{
	size_t ret;
	BN_CTX *new_ctx = NULL;
	int used_ctx = 0;
	BIGNUM *x, *y;
	size_t field_len, i, skip;

	if ((form != POINT_CONVERSION_COMPRESSED)
		&& (form != POINT_CONVERSION_UNCOMPRESSED)
		&& (form != POINT_CONVERSION_HYBRID))
		{
		ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, EC_R_INVALID_FORM);
		goto err;
		}

	if (EC_POINT_is_at_infinity(group, point))
		{
		/* encodes to a single 0 octet */
		if (buf != NULL)
			{
			if (len < 1)
				{
				ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);
				return 0;
				}
			buf[0] = 0;
			}
		return 1;
		}


	/* ret := required output buffer length */
	field_len = BN_num_bytes(&group->field);
	ret = (form == POINT_CONVERSION_COMPRESSED) ? 1 + field_len : 1 + 2*field_len;

	/* if 'buf' is NULL, just return required length */
	if (buf != NULL)
		{
		if (len < ret)
			{
			ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);
			goto err;
			}

		if (ctx == NULL)
			{
			ctx = new_ctx = BN_CTX_new();
			if (ctx == NULL)
				return 0;
			}

		BN_CTX_start(ctx);
		used_ctx = 1;
		x = BN_CTX_get(ctx);
		y = BN_CTX_get(ctx);
		if (y == NULL) goto err;

		if (!EC_POINT_get_affine_coordinates_GFp(group, point, x, y, ctx)) goto err;

		if ((form == POINT_CONVERSION_COMPRESSED || form == POINT_CONVERSION_HYBRID) && BN_is_odd(y))
			buf[0] = form + 1;
		else
			buf[0] = form;
	
		i = 1;
		
		skip = field_len - BN_num_bytes(x);
		if (skip > field_len)
			{
			ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);
			goto err;
			}
		while (skip > 0)
			{
			buf[i++] = 0;
			skip--;
			}
		skip = BN_bn2bin(x, buf + i);
		i += skip;
		if (i != 1 + field_len)
			{
			ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);
			goto err;
			}

		if (form == POINT_CONVERSION_UNCOMPRESSED || form == POINT_CONVERSION_HYBRID)
			{
			skip = field_len - BN_num_bytes(y);
			if (skip > field_len)
				{
				ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);
				goto err;
				}
			while (skip > 0)
				{
				buf[i++] = 0;
				skip--;
				}
			skip = BN_bn2bin(y, buf + i);
			i += skip;
			}

		if (i != ret)
			{
			ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);
			goto err;
			}
		}
	
	if (used_ctx)
		BN_CTX_end(ctx);
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
	return ret;

 err:
	if (used_ctx)
		BN_CTX_end(ctx);
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
	return 0;
	}


int ec_GFp_simple_oct2point(const EC_GROUP *group, EC_POINT *point,
	const unsigned char *buf, size_t len, BN_CTX *ctx)
	{
	point_conversion_form_t form;
	int y_bit;
	BN_CTX *new_ctx = NULL;
	BIGNUM *x, *y;
	size_t field_len, enc_len;
	int ret = 0;

	if (len == 0)
		{
		ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_BUFFER_TOO_SMALL);
		return 0;
		}
	form = buf[0];
	y_bit = form & 1;
	form = form & ~1U;
	if ((form != 0)	&& (form != POINT_CONVERSION_COMPRESSED)
		&& (form != POINT_CONVERSION_UNCOMPRESSED)
		&& (form != POINT_CONVERSION_HYBRID))
		{
		ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
		return 0;
		}
	if ((form == 0 || form == POINT_CONVERSION_UNCOMPRESSED) && y_bit)
		{
		ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
		return 0;
		}

	if (form == 0)
		{
		if (len != 1)
			{
			ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
			return 0;
			}

		return EC_POINT_set_to_infinity(group, point);
		}
	
	field_len = BN_num_bytes(&group->field);
	enc_len = (form == POINT_CONVERSION_COMPRESSED) ? 1 + field_len : 1 + 2*field_len;

	if (len != enc_len)
		{
		ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
		return 0;
		}

	if (ctx == NULL)
		{
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			return 0;
		}

	BN_CTX_start(ctx);
	x = BN_CTX_get(ctx);
	y = BN_CTX_get(ctx);
	if (y == NULL) goto err;

	if (!BN_bin2bn(buf + 1, field_len, x)) goto err;
	if (BN_ucmp(x, &group->field) >= 0)
		{
		ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
		goto err;
		}

	if (form == POINT_CONVERSION_COMPRESSED)
		{
		if (!EC_POINT_set_compressed_coordinates_GFp(group, point, x, y_bit, ctx)) goto err;
		}
	else
		{
		if (!BN_bin2bn(buf + 1 + field_len, field_len, y)) goto err;
		if (BN_ucmp(y, &group->field) >= 0)
			{
			ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
			goto err;
			}
		if (form == POINT_CONVERSION_HYBRID)
			{
			if (y_bit != BN_is_odd(y))
				{
				ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
				goto err;
				}
			}

		if (!EC_POINT_set_affine_coordinates_GFp(group, point, x, y, ctx)) goto err;
		}
	
	if (!EC_POINT_is_on_curve(group, point, ctx)) /* test required by X9.62 */
		{
		ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_POINT_IS_NOT_ON_CURVE);
		goto err;
		}

	ret = 1;
	
 err:
	BN_CTX_end(ctx);
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
	return ret;
	}

@


1.3
log
@resolve conflicts
@
text
@d1409 3
@


1.2
log
@merge 0.9.7d
@
text
@d3 3
a5 1
 * for the OpenSSL project. */
d7 1
a7 1
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
d59 5
d66 1
a69 1

d73 1
d78 4
a81 6
		ec_GFp_simple_group_set_curve_GFp,
		ec_GFp_simple_group_get_curve_GFp,
		ec_GFp_simple_group_set_generator,
		ec_GFp_simple_group_get0_generator,
		ec_GFp_simple_group_get_order,
		ec_GFp_simple_group_get_cofactor,
d89 3
a91 3
		ec_GFp_simple_point_set_affine_coordinates_GFp,
		ec_GFp_simple_point_get_affine_coordinates_GFp,
		ec_GFp_simple_set_compressed_coordinates_GFp,
d102 3
d107 1
d116 14
a135 3
	group->generator = NULL;
	BN_init(&group->order);
	BN_init(&group->cofactor);
a144 4
	if (group->generator != NULL)
		EC_POINT_free(group->generator);
	BN_free(&group->order);
	BN_free(&group->cofactor);
a152 7
	if (group->generator != NULL)
		{
		EC_POINT_clear_free(group->generator);
		group->generator = NULL;
		}
	BN_clear_free(&group->order);
	BN_clear_free(&group->cofactor);
a163 22
	if (src->generator != NULL)
		{
		if (dest->generator == NULL)
			{
			dest->generator = EC_POINT_new(dest);
			if (dest->generator == NULL) return 0;
			}
		if (!EC_POINT_copy(dest->generator, src->generator)) return 0;
		}
	else
		{
		/* src->generator == NULL */
		if (dest->generator != NULL)
			{
			EC_POINT_clear_free(dest->generator);
			dest->generator = NULL;
			}
		}

	if (!BN_copy(&dest->order, &src->order)) return 0;
	if (!BN_copy(&dest->cofactor, &src->cofactor)) return 0;

d168 1
a168 1
int ec_GFp_simple_group_set_curve_GFp(EC_GROUP *group,
d178 1
a178 1
		ECerr(EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE_GFP, EC_R_INVALID_FIELD);
d195 1
a195 1
	group->field.neg = 0;
d223 1
a223 1
int ec_GFp_simple_group_get_curve_GFp(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)
d274 5
d280 1
a280 2
int ec_GFp_simple_group_set_generator(EC_GROUP *group, const EC_POINT *generator,
	const BIGNUM *order, const BIGNUM *cofactor)
d282 6
a287 1
	if (generator == NULL)
d289 6
a294 2
		ECerr(EC_F_EC_GFP_SIMPLE_GROUP_SET_GENERATOR, ERR_R_PASSED_NULL_PARAMETER);
		return 0   ;
d296 7
d304 1
a304 1
	if (group->generator == NULL)
d306 2
a307 2
		group->generator = EC_POINT_new(group);
		if (group->generator == NULL) return 0;
a308 4
	if (!EC_POINT_copy(group->generator, generator)) return 0;

	if (order != NULL)
		{ if (!BN_copy(&group->order, order)) return 0; }	
d310 18
a327 1
		{ if (!BN_zero(&group->order)) return 0; }	
d329 3
a331 4
	if (cofactor != NULL)
		{ if (!BN_copy(&group->cofactor, cofactor)) return 0; }	
	else
		{ if (!BN_zero(&group->cofactor)) return 0; }	
d333 4
a336 2
	return 1;
	}
d338 6
a343 22

EC_POINT *ec_GFp_simple_group_get0_generator(const EC_GROUP *group)
	{
	return group->generator;
	}


int ec_GFp_simple_group_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx)
	{
	if (!BN_copy(order, &group->order))
		return 0;

	return !BN_is_zero(&group->order);
	}


int ec_GFp_simple_group_get_cofactor(const EC_GROUP *group, BIGNUM *cofactor, BN_CTX *ctx)
	{
	if (!BN_copy(cofactor, &group->cofactor))
		return 0;

	return !BN_is_zero(&group->cofactor);
d389 2
a390 1
	return (BN_zero(&point->Z));
d507 1
a507 1
int ec_GFp_simple_point_set_affine_coordinates_GFp(const EC_GROUP *group, EC_POINT *point,
d513 1
a513 1
		ECerr(EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES_GFP, ERR_R_PASSED_NULL_PARAMETER);
d521 1
a521 1
int ec_GFp_simple_point_get_affine_coordinates_GFp(const EC_GROUP *group, const EC_POINT *point,
d525 2
a526 2
	BIGNUM *X, *Y, *Z, *Z_1, *Z_2, *Z_3;
	const BIGNUM *X_, *Y_, *Z_;
d531 1
a531 1
		ECerr(EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES_GFP, EC_R_POINT_AT_INFINITY);
a542 2
	X = BN_CTX_get(ctx);
	Y = BN_CTX_get(ctx);
a552 2
		if (!group->meth->field_decode(group, X, &point->X, ctx)) goto err;
		if (!group->meth->field_decode(group, Y, &point->Y, ctx)) goto err;
d554 1
a554 1
		X_ = X; Y_ = Y;	Z_ = Z;
a557 2
		X_ = &point->X;
		Y_ = &point->Y;
d563 1
a563 1
		if (x != NULL)
d565 8
a572 1
			if (!BN_copy(x, X_)) goto err;
d574 1
a574 1
		if (y != NULL)
d576 8
a583 1
			if (!BN_copy(y, Y_)) goto err;
d590 1
a590 1
			ECerr(EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES_GFP, ERR_R_BN_LIB);
d606 2
a607 9
			if (group->meth->field_encode == 0)
				{
				/* field_mul works on standard representation */
				if (!group->meth->field_mul(group, x, X_, Z_2, ctx)) goto err;
				}
			else
				{
				if (!BN_mod_mul(x, X_, Z_2, &group->field, ctx)) goto err;
				}
a615 2
				if (!group->meth->field_mul(group, y, Y_, Z_3, ctx)) goto err;
				
a619 1
				if (!BN_mod_mul(y, Y_, Z_3, &group->field, ctx)) goto err;
d621 3
d637 1
a637 1
int ec_GFp_simple_set_compressed_coordinates_GFp(const EC_GROUP *group, EC_POINT *point,
d644 3
d718 1
a718 1
		unsigned long err = ERR_peek_error();
d722 2
a723 2
			(void)ERR_get_error();
			ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES_GFP, EC_R_INVALID_COMPRESSED_POINT);
d726 1
a726 1
			ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES_GFP, ERR_R_BN_LIB);
a728 2
	/* If tmp1 is not a square (i.e. there is no point on the curve with
	 * our x), then y now is a nonsense value too */
d740 1
a740 1
				ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES_GFP, EC_R_INVALID_COMPRESSION_BIT);
d742 2
a743 1
				ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES_GFP, EC_R_INVALID_COMPRESSED_POINT);
d750 1
a750 1
		ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES_GFP, ERR_R_INTERNAL_ERROR);
d1101 1
a1101 1
			if (!BN_zero(&r->Z)) goto end;
d1177 1
a1177 1
		if (!BN_zero(&r->Z)) return 0;
d1305 1
a1305 1
	BIGNUM *rh, *tmp1, *tmp2, *Z4, *Z6;
d1324 1
a1324 2
	tmp1 = BN_CTX_get(ctx);
	tmp2 = BN_CTX_get(ctx);
d1338 1
a1338 1
	/* rh := X^3 */
a1339 1
	if (!field_mul(group, rh, rh, &point->X, ctx)) goto err;
d1343 3
a1345 3
		if (!field_sqr(group, tmp1, &point->Z, ctx)) goto err;
		if (!field_sqr(group, Z4, tmp1, ctx)) goto err;
		if (!field_mul(group, Z6, Z4, tmp1, ctx)) goto err;
d1347 1
a1347 2
		/* rh := rh + a*X*Z^4 */
		if (!field_mul(group, tmp1, &point->X, Z4, ctx)) goto err;
d1350 4
a1353 3
			if (!BN_mod_lshift1_quick(tmp2, tmp1, p)) goto err;
			if (!BN_mod_add_quick(tmp2, tmp2, tmp1, p)) goto err;
			if (!BN_mod_sub_quick(rh, rh, tmp2, p)) goto err;
d1357 3
a1359 2
			if (!field_mul(group, tmp2, tmp1, &group->a, ctx)) goto err;
			if (!BN_mod_add_quick(rh, rh, tmp2, p)) goto err;
d1363 2
a1364 2
		if (!field_mul(group, tmp1, &group->b, Z6, ctx)) goto err;
		if (!BN_mod_add_quick(rh, rh, tmp1, p)) goto err;
d1370 3
a1372 13
		/* rh := rh + a*X */
		if (group->a_is_minus3)
			{
			if (!BN_mod_lshift1_quick(tmp2, &point->X, p)) goto err;
			if (!BN_mod_add_quick(tmp2, tmp2, &point->X, p)) goto err;
			if (!BN_mod_sub_quick(rh, rh, tmp2, p)) goto err;
			}
		else
			{
			if (!field_mul(group, tmp2, &point->X, &group->a, ctx)) goto err;
			if (!BN_mod_add_quick(rh, rh, tmp2, p)) goto err;
			}

d1378 1
a1378 1
	if (!field_sqr(group, tmp1, &point->Y, ctx)) goto err;
d1380 1
a1380 1
	ret = (0 == BN_cmp(tmp1, rh));
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d899 1
a899 1
	form = form & ~1;
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import openssl-0.9.7d
@
text
@d899 1
a899 1
	form = form & ~1U;
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d3 1
a3 3
 * for the OpenSSL project. 
 * Includes code written by Bodo Moeller for the OpenSSL project.
*/
d5 1
a5 1
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
a56 5
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * Portions of this software developed by SUN MICROSYSTEMS, INC.,
 * and contributed to the OpenSSL project.
 */
a58 1
#include <openssl/symhacks.h>
d62 1
a65 1
		NID_X9_62_prime_field,
d70 6
a75 4
		ec_GFp_simple_group_set_curve,
		ec_GFp_simple_group_get_curve,
		ec_GFp_simple_group_get_degree,
		ec_GFp_simple_group_check_discriminant,
d83 3
a85 3
		ec_GFp_simple_point_set_affine_coordinates,
		ec_GFp_simple_point_get_affine_coordinates,
		ec_GFp_simple_set_compressed_coordinates,
a95 3
		0 /* mul */,
		0 /* precompute_mult */,
		0 /* have_precompute_mult */,	
a97 1
		0 /* field_div */,
a105 14
/* Most method functions in this file are designed to work with
 * non-trivial representations of field elements if necessary
 * (see ecp_mont.c): while standard modular addition and subtraction
 * are used, the field_mul and field_sqr methods will be used for
 * multiplication, and field_encode and field_decode (if defined)
 * will be used for converting between representations.

 * Functions ec_GFp_simple_points_make_affine() and
 * ec_GFp_simple_point_get_affine_coordinates() specifically assume
 * that if a non-trivial representation is used, it is a Montgomery
 * representation (i.e. 'encoding' means multiplying by some factor R).
 */


d112 3
d124 4
d136 7
d154 22
d180 1
a180 1
int ec_GFp_simple_group_set_curve(EC_GROUP *group,
d190 1
a190 1
		ECerr(EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE, EC_R_INVALID_FIELD);
d207 1
a207 1
	BN_set_negative(&group->field, 0);
d235 1
a235 1
int ec_GFp_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)
a285 5
int ec_GFp_simple_group_get_degree(const EC_GROUP *group)
	{
	return BN_num_bits(&group->field);
	}

d287 2
a288 1
int ec_GFp_simple_group_check_discriminant(const EC_GROUP *group, BN_CTX *ctx)
d290 1
a290 6
	int ret = 0;
	BIGNUM *a,*b,*order,*tmp_1,*tmp_2;
	const BIGNUM *p = &group->field;
	BN_CTX *new_ctx = NULL;

	if (ctx == NULL)
d292 2
a293 6
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			{
			ECerr(EC_F_EC_GFP_SIMPLE_GROUP_CHECK_DISCRIMINANT, ERR_R_MALLOC_FAILURE);
			goto err;
			}
a294 7
	BN_CTX_start(ctx);
	a = BN_CTX_get(ctx);
	b = BN_CTX_get(ctx);
	tmp_1 = BN_CTX_get(ctx);
	tmp_2 = BN_CTX_get(ctx);
	order = BN_CTX_get(ctx);
	if (order == NULL) goto err;
d296 1
a296 1
	if (group->meth->field_decode)
d298 2
a299 2
		if (!group->meth->field_decode(group, a, &group->a, ctx)) goto err;
		if (!group->meth->field_decode(group, b, &group->b, ctx)) goto err;
d301 9
d311 19
a329 18
		{
		if (!BN_copy(a, &group->a)) goto err;
		if (!BN_copy(b, &group->b)) goto err;
		}
	
	/* check the discriminant:
	 * y^2 = x^3 + a*x + b is an elliptic curve <=> 4*a^3 + 27*b^2 != 0 (mod p) 
         * 0 =< a, b < p */
	if (BN_is_zero(a))
		{
		if (BN_is_zero(b)) goto err;
		}
	else if (!BN_is_zero(b))
		{
		if (!BN_mod_sqr(tmp_1, a, p, ctx)) goto err;
		if (!BN_mod_mul(tmp_2, tmp_1, a, p, ctx)) goto err;
		if (!BN_lshift(tmp_1, tmp_2, 2)) goto err;
		/* tmp_1 = 4*a^3 */
a330 3
		if (!BN_mod_sqr(tmp_2, b, p, ctx)) goto err;
		if (!BN_mul_word(tmp_2, 27)) goto err;
		/* tmp_2 = 27*b^2 */
d332 4
a335 4
		if (!BN_mod_add(a, tmp_1, tmp_2, p, ctx)) goto err;
		if (BN_is_zero(a)) goto err;
		}
	ret = 1;
d337 1
a337 6
err:
	if (ctx != NULL)
		BN_CTX_end(ctx);
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
	return ret;
d383 1
a383 2
	BN_zero(&point->Z);
	return 1;
d500 1
a500 1
int ec_GFp_simple_point_set_affine_coordinates(const EC_GROUP *group, EC_POINT *point,
d506 1
a506 1
		ECerr(EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES, ERR_R_PASSED_NULL_PARAMETER);
d514 1
a514 1
int ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP *group, const EC_POINT *point,
d518 2
a519 2
	BIGNUM *Z, *Z_1, *Z_2, *Z_3;
	const BIGNUM *Z_;
d524 1
a524 1
		ECerr(EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES, EC_R_POINT_AT_INFINITY);
d536 2
d548 2
d551 1
a551 1
		Z_ = Z;
d555 2
d562 1
a562 1
		if (group->meth->field_decode)
d564 1
a564 8
			if (x != NULL)
				{
				if (!group->meth->field_decode(group, x, &point->X, ctx)) goto err;
				}
			if (y != NULL)
				{
				if (!group->meth->field_decode(group, y, &point->Y, ctx)) goto err;
				}
d566 1
a566 1
		else
d568 1
a568 8
			if (x != NULL)
				{
				if (!BN_copy(x, &point->X)) goto err;
				}
			if (y != NULL)
				{
				if (!BN_copy(y, &point->Y)) goto err;
				}
d575 1
a575 1
			ECerr(EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES, ERR_R_BN_LIB);
d591 9
a599 2
			/* in the Montgomery case, field_mul will cancel out Montgomery factor in X: */
			if (!group->meth->field_mul(group, x, &point->X, Z_2, ctx)) goto err;
d608 2
d614 1
a615 3

			/* in the Montgomery case, field_mul will cancel out Montgomery factor in Y: */
			if (!group->meth->field_mul(group, y, &point->Y, Z_3, ctx)) goto err;
d629 1
a629 1
int ec_GFp_simple_set_compressed_coordinates(const EC_GROUP *group, EC_POINT *point,
a635 3
	/* clear error queue*/
	ERR_clear_error();

d707 1
a707 1
		unsigned long err = ERR_peek_last_error();
d711 2
a712 2
			ERR_clear_error();
			ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES, EC_R_INVALID_COMPRESSED_POINT);
d715 1
a715 1
			ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES, ERR_R_BN_LIB);
d718 2
d731 1
a731 1
				ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES, EC_R_INVALID_COMPRESSION_BIT);
d733 1
a733 2
				/* BN_mod_sqrt() should have cought this error (not a square) */
				ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES, EC_R_INVALID_COMPRESSED_POINT);
d740 1
a740 1
		ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES, ERR_R_INTERNAL_ERROR);
d1091 1
a1091 1
			BN_zero(&r->Z);
d1167 1
a1167 1
		BN_zero(&r->Z);
d1295 1
a1295 1
	BIGNUM *rh, *tmp, *Z4, *Z6;
d1314 2
a1315 1
	tmp = BN_CTX_get(ctx);
d1329 1
a1329 1
	/* rh := X^2 */
d1331 1
d1335 3
a1337 3
		if (!field_sqr(group, tmp, &point->Z, ctx)) goto err;
		if (!field_sqr(group, Z4, tmp, ctx)) goto err;
		if (!field_mul(group, Z6, Z4, tmp, ctx)) goto err;
d1339 2
a1340 1
		/* rh := (rh + a*Z^4)*X */
d1343 3
a1345 4
			if (!BN_mod_lshift1_quick(tmp, Z4, p)) goto err;
			if (!BN_mod_add_quick(tmp, tmp, Z4, p)) goto err;
			if (!BN_mod_sub_quick(rh, rh, tmp, p)) goto err;
			if (!field_mul(group, rh, rh, &point->X, ctx)) goto err;
d1349 2
a1350 3
			if (!field_mul(group, tmp, Z4, &group->a, ctx)) goto err;
			if (!BN_mod_add_quick(rh, rh, tmp, p)) goto err;
			if (!field_mul(group, rh, rh, &point->X, ctx)) goto err;
d1354 2
a1355 2
		if (!field_mul(group, tmp, &group->b, Z6, ctx)) goto err;
		if (!BN_mod_add_quick(rh, rh, tmp, p)) goto err;
d1361 13
a1373 3
		/* rh := (rh + a)*X */
		if (!BN_mod_add_quick(rh, rh, &group->a, p)) goto err;
		if (!field_mul(group, rh, rh, &point->X, ctx)) goto err;
d1379 1
a1379 1
	if (!field_sqr(group, tmp, &point->Y, ctx)) goto err;
d1381 1
a1381 1
	ret = (0 == BN_ucmp(tmp, rh));
@


1.1.1.4
log
@import OpenSSL 1.0.0e
@
text
@a1408 3

	if (EC_POINT_is_at_infinity(group, b))
		return 1;
@


1.1.1.5
log
@import OpenSSL-1.0.1c
@
text
@a67 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

a71 3
#ifdef OPENSSL_FIPS
	return fips_ec_gfp_simple_method();
#else
a72 1
		EC_FLAGS_DEFAULT_OCT,
d91 3
a93 1
		0,0,0,
a112 1
#endif
d635 366
@


