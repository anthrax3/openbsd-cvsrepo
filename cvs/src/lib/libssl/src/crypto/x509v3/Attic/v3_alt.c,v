head	1.26;
access;
symbols
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.22.0.4
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	butholakala:1.11
	openssl_1_0_1_g:1.1.1.5
	OPENBSD_5_5:1.11.0.16
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.12
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	openssl_1_0_1_c:1.1.1.5
	OPENBSD_5_2:1.11.0.6
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.8
	openssl_1_0_0_f:1.1.1.5
	openssl_1_0_0_e:1.1.1.5
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	openssh_1_0_0_a:1.1.1.5
	OPENBSD_4_8:1.10.0.8
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	openssl_0_9_8_k:1.1.1.4
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	openssl_0_9_8_j:1.1.1.4
	openssl_0_9_8_h:1.1.1.3
	pre_openssl_0_9_8h:1.7
	OPENBSD_4_4:1.7.0.18
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.16
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.14
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.12
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.10
	OPENBSD_4_0_BASE:1.7
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENSSL_0_9_7G:1.1.1.2
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENSSL_0_9_7C:1.1.1.1
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENSSL_0_9_7B:1.1.1.1
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.26
date	2016.09.03.11.33.40;	author beck;	state dead;
branches;
next	1.25;
commitid	HnbXxsegngek41U2;

1.25
date	2015.09.30.18.21.50;	author jsing;	state Exp;
branches;
next	1.24;
commitid	W41jP34sV2UzYLCa;

1.24
date	2015.07.29.16.13.48;	author jsing;	state Exp;
branches;
next	1.23;
commitid	p0YErzIitgRtixdM;

1.23
date	2015.07.29.14.58.34;	author jsing;	state Exp;
branches;
next	1.22;
commitid	rYgS8cWcS59JYkBV;

1.22
date	2014.10.28.05.46.56;	author miod;	state Exp;
branches;
next	1.21;
commitid	hDZmp09ZEY5wcTE1;

1.21
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.20;
commitid	yQEL1wOWIearrW15;

1.20
date	2014.07.10.13.58.23;	author jsing;	state Exp;
branches;
next	1.19;
commitid	id8dTrTMtnTn4fqt;

1.19
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	mJUVYpkFBZ0Zv2bG;

1.18
date	2014.04.26.18.56.38;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.21.13.04.02;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.20.20.06.20;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.19.11.43.07;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.16.20.36.35;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.15.16.21.04;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.06.12.20.16;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.06.12.17.52;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.08.08.03.14;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.05.11.05.08;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.17;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.22.00.03.22;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.58.15;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.12.17;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.36.53;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.01;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.04.07.20.41.53;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.47;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.01.09.12.14.01;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.11;	author djm;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Remove the libssl/src directory
@
text
@/* $OpenBSD: v3_alt.c,v 1.25 2015/09/30 18:21:50 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project.
 */
/* ====================================================================
 * Copyright (c) 1999-2003 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <string.h>

#include <openssl/conf.h>
#include <openssl/err.h>
#include <openssl/x509v3.h>

static GENERAL_NAMES *v2i_subject_alt(X509V3_EXT_METHOD *method,
    X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval);
static GENERAL_NAMES *v2i_issuer_alt(X509V3_EXT_METHOD *method,
    X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval);
static int copy_email(X509V3_CTX *ctx, GENERAL_NAMES *gens, int move_p);
static int copy_issuer(X509V3_CTX *ctx, GENERAL_NAMES *gens);
static int do_othername(GENERAL_NAME *gen, char *value, X509V3_CTX *ctx);
static int do_dirname(GENERAL_NAME *gen, char *value, X509V3_CTX *ctx);

const X509V3_EXT_METHOD v3_alt[] = {
	{
		.ext_nid = NID_subject_alt_name,
		.ext_flags = 0,
		.it = ASN1_ITEM_ref(GENERAL_NAMES),
		.ext_new = NULL,
		.ext_free = NULL,
		.d2i = NULL,
		.i2d = NULL,
		.i2s = NULL,
		.s2i = NULL,
		.i2v = (X509V3_EXT_I2V)i2v_GENERAL_NAMES,
		.v2i = (X509V3_EXT_V2I)v2i_subject_alt,
		.i2r = NULL,
		.r2i = NULL,
		.usr_data = NULL,
	},
	{
		.ext_nid = NID_issuer_alt_name,
		.ext_flags = 0,
		.it = ASN1_ITEM_ref(GENERAL_NAMES),
		.ext_new = NULL,
		.ext_free = NULL,
		.d2i = NULL,
		.i2d = NULL,
		.i2s = NULL,
		.s2i = NULL,
		.i2v = (X509V3_EXT_I2V)i2v_GENERAL_NAMES,
		.v2i = (X509V3_EXT_V2I)v2i_issuer_alt,
		.i2r = NULL,
		.r2i = NULL,
		.usr_data = NULL,
	},
	{
		.ext_nid = NID_certificate_issuer,
		.ext_flags = 0,
		.it = ASN1_ITEM_ref(GENERAL_NAMES),
		.ext_new = NULL,
		.ext_free = NULL,
		.d2i = NULL,
		.i2d = NULL,
		.i2s = NULL,
		.s2i = NULL,
		.i2v = (X509V3_EXT_I2V)i2v_GENERAL_NAMES,
		.v2i = NULL,
		.i2r = NULL,
		.r2i = NULL,
		.usr_data = NULL,
	},
};

STACK_OF(CONF_VALUE) *
i2v_GENERAL_NAMES(X509V3_EXT_METHOD *method, GENERAL_NAMES *gens,
    STACK_OF(CONF_VALUE) *ret)
{
	int i;
	GENERAL_NAME *gen;

	for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
		gen = sk_GENERAL_NAME_value(gens, i);
		ret = i2v_GENERAL_NAME(method, gen, ret);
	}
	if (!ret)
		return sk_CONF_VALUE_new_null();
	return ret;
}

STACK_OF(CONF_VALUE) *
i2v_GENERAL_NAME(X509V3_EXT_METHOD *method, GENERAL_NAME *gen,
    STACK_OF(CONF_VALUE) *ret)
{
	unsigned char *p;
	char oline[256], htmp[5];
	int i;

	switch (gen->type) {
	case GEN_OTHERNAME:
		X509V3_add_value("othername", "<unsupported>", &ret);
		break;

	case GEN_X400:
		X509V3_add_value("X400Name", "<unsupported>", &ret);
		break;

	case GEN_EDIPARTY:
		X509V3_add_value("EdiPartyName", "<unsupported>", &ret);
		break;

	case GEN_EMAIL:
		X509V3_add_value_uchar("email", gen->d.ia5->data, &ret);
		break;

	case GEN_DNS:
		X509V3_add_value_uchar("DNS", gen->d.ia5->data, &ret);
		break;

	case GEN_URI:
		X509V3_add_value_uchar("URI", gen->d.ia5->data, &ret);
		break;

	case GEN_DIRNAME:
		X509_NAME_oneline(gen->d.dirn, oline, 256);
		X509V3_add_value("DirName", oline, &ret);
		break;

	case GEN_IPADD:
		p = gen->d.ip->data;
		if (gen->d.ip->length == 4)
			(void) snprintf(oline, sizeof oline,
			    "%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
		else if (gen->d.ip->length == 16) {
			oline[0] = 0;
			for (i = 0; i < 8; i++) {
				(void) snprintf(htmp, sizeof htmp,
				    "%X", p[0] << 8 | p[1]);
				p += 2;
				strlcat(oline, htmp, sizeof(oline));
				if (i != 7)
					strlcat(oline, ":", sizeof(oline));
			}
		} else {
			X509V3_add_value("IP Address", "<invalid>", &ret);
			break;
		}
		X509V3_add_value("IP Address", oline, &ret);
		break;

	case GEN_RID:
		i2t_ASN1_OBJECT(oline, 256, gen->d.rid);
		X509V3_add_value("Registered ID", oline, &ret);
		break;
	}
	return ret;
}

int
GENERAL_NAME_print(BIO *out, GENERAL_NAME *gen)
{
	unsigned char *p;
	int i;

	switch (gen->type) {
	case GEN_OTHERNAME:
		BIO_printf(out, "othername:<unsupported>");
		break;

	case GEN_X400:
		BIO_printf(out, "X400Name:<unsupported>");
		break;

	case GEN_EDIPARTY:
		/* Maybe fix this: it is supported now */
		BIO_printf(out, "EdiPartyName:<unsupported>");
		break;

	case GEN_EMAIL:
		BIO_printf(out, "email:%s", gen->d.ia5->data);
		break;

	case GEN_DNS:
		BIO_printf(out, "DNS:%s", gen->d.ia5->data);
		break;

	case GEN_URI:
		BIO_printf(out, "URI:%s", gen->d.ia5->data);
		break;

	case GEN_DIRNAME:
		BIO_printf(out, "DirName: ");
		X509_NAME_print_ex(out, gen->d.dirn, 0, XN_FLAG_ONELINE);
		break;

	case GEN_IPADD:
		p = gen->d.ip->data;
		if (gen->d.ip->length == 4)
			BIO_printf(out, "IP Address:%d.%d.%d.%d",
			    p[0], p[1], p[2], p[3]);
		else if (gen->d.ip->length == 16) {
			BIO_printf(out, "IP Address");
			for (i = 0; i < 8; i++) {
				BIO_printf(out, ":%X", p[0] << 8 | p[1]);
				p += 2;
			}
			BIO_puts(out, "\n");
		} else {
			BIO_printf(out, "IP Address:<invalid>");
			break;
		}
		break;

	case GEN_RID:
		BIO_printf(out, "Registered ID");
		i2a_ASN1_OBJECT(out, gen->d.rid);
		break;
	}
	return 1;
}

static GENERAL_NAMES *
v2i_issuer_alt(X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
    STACK_OF(CONF_VALUE) *nval)
{
	GENERAL_NAMES *gens = NULL;
	CONF_VALUE *cnf;
	int i;

	if ((gens = sk_GENERAL_NAME_new_null()) == NULL) {
		X509V3err(X509V3_F_V2I_ISSUER_ALT, ERR_R_MALLOC_FAILURE);
		return NULL;
	}
	for (i = 0; i < sk_CONF_VALUE_num(nval); i++) {
		cnf = sk_CONF_VALUE_value(nval, i);
		if (name_cmp(cnf->name, "issuer") == 0 && cnf->value != NULL &&
		    strcmp(cnf->value, "copy") == 0) {
			if (!copy_issuer(ctx, gens))
				goto err;
		} else {
			GENERAL_NAME *gen;
			if ((gen = v2i_GENERAL_NAME(method, ctx, cnf)) == NULL)
				goto err;
			if (sk_GENERAL_NAME_push(gens, gen) == 0) {
				GENERAL_NAME_free(gen);
				goto err;
			}
		}
	}
	return gens;

err:
	sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);
	return NULL;
}

/* Append subject altname of issuer to issuer alt name of subject */

static int
copy_issuer(X509V3_CTX *ctx, GENERAL_NAMES *gens)
{
	GENERAL_NAMES *ialt;
	GENERAL_NAME *gen;
	X509_EXTENSION *ext;
	int i;

	if (ctx && (ctx->flags == CTX_TEST))
		return 1;
	if (!ctx || !ctx->issuer_cert) {
		X509V3err(X509V3_F_COPY_ISSUER, X509V3_R_NO_ISSUER_DETAILS);
		goto err;
	}
	i = X509_get_ext_by_NID(ctx->issuer_cert, NID_subject_alt_name, -1);
	if (i < 0)
		return 1;
	if (!(ext = X509_get_ext(ctx->issuer_cert, i)) ||
	    !(ialt = X509V3_EXT_d2i(ext))) {
		X509V3err(X509V3_F_COPY_ISSUER, X509V3_R_ISSUER_DECODE_ERROR);
		goto err;
	}

	for (i = 0; i < sk_GENERAL_NAME_num(ialt); i++) {
		gen = sk_GENERAL_NAME_value(ialt, i);
		if (!sk_GENERAL_NAME_push(gens, gen)) {
			X509V3err(X509V3_F_COPY_ISSUER, ERR_R_MALLOC_FAILURE);
			goto err;
		}
	}
	sk_GENERAL_NAME_free(ialt);

	return 1;

err:
	return 0;

}

static GENERAL_NAMES *
v2i_subject_alt(X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
    STACK_OF(CONF_VALUE) *nval)
{
	GENERAL_NAMES *gens = NULL;
	CONF_VALUE *cnf;
	int i;

	if (!(gens = sk_GENERAL_NAME_new_null())) {
		X509V3err(X509V3_F_V2I_SUBJECT_ALT, ERR_R_MALLOC_FAILURE);
		return NULL;
	}
	for (i = 0; i < sk_CONF_VALUE_num(nval); i++) {
		cnf = sk_CONF_VALUE_value(nval, i);
		if (!name_cmp(cnf->name, "email") && cnf->value &&
		    !strcmp(cnf->value, "copy")) {
			if (!copy_email(ctx, gens, 0))
				goto err;
		} else if (!name_cmp(cnf->name, "email") && cnf->value &&
		    !strcmp(cnf->value, "move")) {
			if (!copy_email(ctx, gens, 1))
				goto err;
		} else {
			GENERAL_NAME *gen;
			if (!(gen = v2i_GENERAL_NAME(method, ctx, cnf)))
				goto err;
			if (sk_GENERAL_NAME_push(gens, gen) == 0) {
				GENERAL_NAME_free(gen);
				goto err;
			}
		}
	}
	return gens;

err:
	sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);
	return NULL;
}

/* Copy any email addresses in a certificate or request to
 * GENERAL_NAMES
 */

static int
copy_email(X509V3_CTX *ctx, GENERAL_NAMES *gens, int move_p)
{
	X509_NAME *nm;
	ASN1_IA5STRING *email = NULL;
	X509_NAME_ENTRY *ne;
	GENERAL_NAME *gen = NULL;
	int i;

	if (ctx != NULL && ctx->flags == CTX_TEST)
		return 1;
	if (!ctx || (!ctx->subject_cert && !ctx->subject_req)) {
		X509V3err(X509V3_F_COPY_EMAIL, X509V3_R_NO_SUBJECT_DETAILS);
		goto err;
	}
	/* Find the subject name */
	if (ctx->subject_cert)
		nm = X509_get_subject_name(ctx->subject_cert);
	else
		nm = X509_REQ_get_subject_name(ctx->subject_req);

	/* Now add any email address(es) to STACK */
	i = -1;
	while ((i = X509_NAME_get_index_by_NID(nm,
	    NID_pkcs9_emailAddress, i)) >= 0) {
		ne = X509_NAME_get_entry(nm, i);
		email = ASN1_STRING_dup(X509_NAME_ENTRY_get_data(ne));
		if (move_p) {
			X509_NAME_delete_entry(nm, i);
			X509_NAME_ENTRY_free(ne);
			i--;
		}
		if (!email || !(gen = GENERAL_NAME_new())) {
			X509V3err(X509V3_F_COPY_EMAIL, ERR_R_MALLOC_FAILURE);
			goto err;
		}
		gen->d.ia5 = email;
		email = NULL;
		gen->type = GEN_EMAIL;
		if (!sk_GENERAL_NAME_push(gens, gen)) {
			X509V3err(X509V3_F_COPY_EMAIL, ERR_R_MALLOC_FAILURE);
			goto err;
		}
		gen = NULL;
	}

	return 1;

err:
	GENERAL_NAME_free(gen);
	ASN1_IA5STRING_free(email);
	return 0;
}

GENERAL_NAMES *
v2i_GENERAL_NAMES(const X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
    STACK_OF(CONF_VALUE) *nval)
{
	GENERAL_NAME *gen;
	GENERAL_NAMES *gens = NULL;
	CONF_VALUE *cnf;
	int i;

	if (!(gens = sk_GENERAL_NAME_new_null())) {
		X509V3err(X509V3_F_V2I_GENERAL_NAMES, ERR_R_MALLOC_FAILURE);
		return NULL;
	}
	for (i = 0; i < sk_CONF_VALUE_num(nval); i++) {
		cnf = sk_CONF_VALUE_value(nval, i);
		if (!(gen = v2i_GENERAL_NAME(method, ctx, cnf)))
			goto err;
		if (sk_GENERAL_NAME_push(gens, gen) == 0) {
			GENERAL_NAME_free(gen);
			goto err;
		}
	}
	return gens;

err:
	sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);
	return NULL;
}

GENERAL_NAME *
v2i_GENERAL_NAME(const X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
    CONF_VALUE *cnf)
{
	return v2i_GENERAL_NAME_ex(NULL, method, ctx, cnf, 0);
}

GENERAL_NAME *
a2i_GENERAL_NAME(GENERAL_NAME *out, const X509V3_EXT_METHOD *method,
    X509V3_CTX *ctx, int gen_type, char *value, int is_nc)
{
	char is_string = 0;
	GENERAL_NAME *gen = NULL;

	if (!value) {
		X509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_MISSING_VALUE);
		return NULL;
	}

	if (out)
		gen = out;
	else {
		gen = GENERAL_NAME_new();
		if (gen == NULL) {
			X509V3err(X509V3_F_A2I_GENERAL_NAME,
			    ERR_R_MALLOC_FAILURE);
			return NULL;
		}
	}

	switch (gen_type) {
	case GEN_URI:
	case GEN_EMAIL:
	case GEN_DNS:
		is_string = 1;
		break;

	case GEN_RID:
		{
			ASN1_OBJECT *obj;
			if (!(obj = OBJ_txt2obj(value, 0))) {
				X509V3err(X509V3_F_A2I_GENERAL_NAME,
				    X509V3_R_BAD_OBJECT);
				ERR_asprintf_error_data("value=%s", value);
				goto err;
			}
			gen->d.rid = obj;
		}
		break;

	case GEN_IPADD:
		if (is_nc)
			gen->d.ip = a2i_IPADDRESS_NC(value);
		else
			gen->d.ip = a2i_IPADDRESS(value);
		if (gen->d.ip == NULL) {
			X509V3err(X509V3_F_A2I_GENERAL_NAME,
			    X509V3_R_BAD_IP_ADDRESS);
			ERR_asprintf_error_data("value=%s", value);
			goto err;
		}
		break;

	case GEN_DIRNAME:
		if (!do_dirname(gen, value, ctx)) {
			X509V3err(X509V3_F_A2I_GENERAL_NAME,
			    X509V3_R_DIRNAME_ERROR);
			goto err;
		}
		break;

	case GEN_OTHERNAME:
		if (!do_othername(gen, value, ctx)) {
			X509V3err(X509V3_F_A2I_GENERAL_NAME,
			    X509V3_R_OTHERNAME_ERROR);
			goto err;
		}
		break;

	default:
		X509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_UNSUPPORTED_TYPE);
		goto err;
	}

	if (is_string) {
		if (!(gen->d.ia5 = ASN1_IA5STRING_new()) ||
		    !ASN1_STRING_set(gen->d.ia5, (unsigned char*)value,
			strlen(value))) {
			X509V3err(X509V3_F_A2I_GENERAL_NAME,
			    ERR_R_MALLOC_FAILURE);
			goto err;
		}
	}

	gen->type = gen_type;

	return gen;

err:
	if (out == NULL)
		GENERAL_NAME_free(gen);
	return NULL;
}

GENERAL_NAME *
v2i_GENERAL_NAME_ex(GENERAL_NAME *out, const X509V3_EXT_METHOD *method,
    X509V3_CTX *ctx, CONF_VALUE *cnf, int is_nc)
{
	int type;
	char *name, *value;

	name = cnf->name;
	value = cnf->value;

	if (!value) {
		X509V3err(X509V3_F_V2I_GENERAL_NAME_EX, X509V3_R_MISSING_VALUE);
		return NULL;
	}

	if (!name_cmp(name, "email"))
		type = GEN_EMAIL;
	else if (!name_cmp(name, "URI"))
		type = GEN_URI;
	else if (!name_cmp(name, "DNS"))
		type = GEN_DNS;
	else if (!name_cmp(name, "RID"))
		type = GEN_RID;
	else if (!name_cmp(name, "IP"))
		type = GEN_IPADD;
	else if (!name_cmp(name, "dirName"))
		type = GEN_DIRNAME;
	else if (!name_cmp(name, "otherName"))
		type = GEN_OTHERNAME;
	else {
		X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,
		    X509V3_R_UNSUPPORTED_OPTION);
		ERR_asprintf_error_data("name=%s", name);
		return NULL;
	}

	return a2i_GENERAL_NAME(out, method, ctx, type, value, is_nc);
}

static int
do_othername(GENERAL_NAME *gen, char *value, X509V3_CTX *ctx)
{
	char *objtmp = NULL, *p;
	int objlen;

	if (!(p = strchr(value, ';')))
		return 0;
	if (!(gen->d.otherName = OTHERNAME_new()))
		return 0;
	/* Free this up because we will overwrite it.
	 * no need to free type_id because it is static
	 */
	ASN1_TYPE_free(gen->d.otherName->value);
	if (!(gen->d.otherName->value = ASN1_generate_v3(p + 1, ctx)))
		return 0;
	objlen = p - value;
	objtmp = malloc(objlen + 1);
	if (objtmp) {
		strlcpy(objtmp, value, objlen + 1);
		gen->d.otherName->type_id = OBJ_txt2obj(objtmp, 0);
		free(objtmp);
	} else
		gen->d.otherName->type_id = NULL;
	if (!gen->d.otherName->type_id)
		return 0;
	return 1;
}

static int
do_dirname(GENERAL_NAME *gen, char *value, X509V3_CTX *ctx)
{
	int ret;
	STACK_OF(CONF_VALUE) *sk;
	X509_NAME *nm;

	if (!(nm = X509_NAME_new()))
		return 0;
	sk = X509V3_get_section(ctx, value);
	if (!sk) {
		X509V3err(X509V3_F_DO_DIRNAME, X509V3_R_SECTION_NOT_FOUND);
		ERR_asprintf_error_data("section=%s", value);
		X509_NAME_free(nm);
		return 0;
	}
	/* FIXME: should allow other character types... */
	ret = X509V3_NAME_from_section(nm, sk, MBSTRING_ASC);
	if (!ret)
		X509_NAME_free(nm);
	gen->d.dirn = nm;
	X509V3_section_free(ctx, sk);

	return ret;
}
@


1.25
log
@Replace M_ASN1_IA5STRING_(new|free) with ASN1_IA5STRING_(new|free). Same
with one s/M_ASN1_VISIBLESTRING_new/ASN1_VISIBLESTRING_new/.
@
text
@d1 1
a1 1
/* $OpenBSD: v3_alt.c,v 1.24 2015/07/29 16:13:48 jsing Exp $ */
@


1.24
log
@Use named initialisers for X509V3_EXT_METHOD structs (for the usual
reasons) - only change in generated assembly is due to line numbering.
@
text
@d1 1
a1 1
/* $OpenBSD: v3_alt.c,v 1.23 2015/07/29 14:58:34 jsing Exp $ */
d442 1
a442 1
	M_ASN1_IA5STRING_free(email);
d560 1
a560 1
		if (!(gen->d.ia5 = M_ASN1_IA5STRING_new()) ||
@


1.23
log
@Expand obsolete M_ASN1.*(cmp|dup|print|set) macros - no change in generated
assembly.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_alt.c,v 1.22 2014/10/28 05:46:56 miod Exp $ */
d77 14
a90 6
		NID_subject_alt_name, 0, ASN1_ITEM_ref(GENERAL_NAMES),
		0, 0, 0, 0,
		0, 0,
		(X509V3_EXT_I2V)i2v_GENERAL_NAMES,
		(X509V3_EXT_V2I)v2i_subject_alt,
		NULL, NULL, NULL
d93 14
a106 6
		NID_issuer_alt_name, 0, ASN1_ITEM_ref(GENERAL_NAMES),
		0, 0, 0, 0,
		0, 0,
		(X509V3_EXT_I2V)i2v_GENERAL_NAMES,
		(X509V3_EXT_V2I)v2i_issuer_alt,
		NULL, NULL, NULL
d109 14
a122 5
		NID_certificate_issuer, 0, ASN1_ITEM_ref(GENERAL_NAMES),
		0, 0, 0, 0,
		0, 0,
		(X509V3_EXT_I2V)i2v_GENERAL_NAMES,
		NULL, NULL, NULL, NULL
@


1.22
log
@Check the result of sk_*_push() operations for failure.
ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_alt.c,v 1.21 2014/07/11 08:44:49 jsing Exp $ */
d393 1
a393 1
		email = M_ASN1_IA5STRING_dup(X509_NAME_ENTRY_get_data(ne));
@


1.21
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_alt.c,v 1.20 2014/07/10 13:58:23 jsing Exp $ */
d256 1
a256 1
	if (!(gens = sk_GENERAL_NAME_new_null())) {
d262 2
a263 2
		if (!name_cmp(cnf->name, "issuer") && cnf->value &&
		    !strcmp(cnf->value, "copy")) {
d268 4
a271 1
			if (!(gen = v2i_GENERAL_NAME(method, ctx, cnf)))
d273 1
a273 1
			sk_GENERAL_NAME_push(gens, gen);
d350 4
a353 1
			sk_GENERAL_NAME_push(gens, gen);
d438 4
a441 1
		sk_GENERAL_NAME_push(gens, gen);
d549 1
a549 1
	if (!out)
@


1.20
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_alt.c,v 1.19 2014/06/12 15:49:31 deraadt Exp $ */
a61 1
#include "cryptlib.h"
d63 1
@


1.19
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 2
@


1.18
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d1 1
a1 1
/* v3_alt.c */
@


1.17
log
@KNF.
@
text
@d482 1
a482 1
				ERR_add_error_data(2, "value=", value);
d497 1
a497 1
			ERR_add_error_data(2, "value=", value);
d575 1
a575 1
		ERR_add_error_data(2, "name=", name);
d623 1
a623 1
		ERR_add_error_data(2, "section=", value);
@


1.16
log
@Restore beck's (void)snprintf(): they were reviewed.
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d64 4
a67 2
static GENERAL_NAMES *v2i_subject_alt(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval);
static GENERAL_NAMES *v2i_issuer_alt(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval);
d74 23
a96 19
{ NID_subject_alt_name, 0, ASN1_ITEM_ref(GENERAL_NAMES),
0,0,0,0,
0,0,
(X509V3_EXT_I2V)i2v_GENERAL_NAMES,
(X509V3_EXT_V2I)v2i_subject_alt,
NULL, NULL, NULL},

{ NID_issuer_alt_name, 0, ASN1_ITEM_ref(GENERAL_NAMES),
0,0,0,0,
0,0,
(X509V3_EXT_I2V)i2v_GENERAL_NAMES,
(X509V3_EXT_V2I)v2i_issuer_alt,
NULL, NULL, NULL},

{ NID_certificate_issuer, 0, ASN1_ITEM_ref(GENERAL_NAMES),
0,0,0,0,
0,0,
(X509V3_EXT_I2V)i2v_GENERAL_NAMES,
NULL, NULL, NULL, NULL},
d99 3
a101 2
STACK_OF(CONF_VALUE) *i2v_GENERAL_NAMES(X509V3_EXT_METHOD *method,
		GENERAL_NAMES *gens, STACK_OF(CONF_VALUE) *ret)
d105 2
a106 1
	for(i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
d110 2
a111 1
	if(!ret) return sk_CONF_VALUE_new_null();
d115 3
a117 2
STACK_OF(CONF_VALUE) *i2v_GENERAL_NAME(X509V3_EXT_METHOD *method,
				GENERAL_NAME *gen, STACK_OF(CONF_VALUE) *ret)
d122 4
a125 4
	switch (gen->type)
	{
		case GEN_OTHERNAME:
		X509V3_add_value("othername","<unsupported>", &ret);
d128 2
a129 2
		case GEN_X400:
		X509V3_add_value("X400Name","<unsupported>", &ret);
d132 2
a133 2
		case GEN_EDIPARTY:
		X509V3_add_value("EdiPartyName","<unsupported>", &ret);
d136 2
a137 2
		case GEN_EMAIL:
		X509V3_add_value_uchar("email",gen->d.ia5->data, &ret);
d140 2
a141 2
		case GEN_DNS:
		X509V3_add_value_uchar("DNS",gen->d.ia5->data, &ret);
d144 2
a145 2
		case GEN_URI:
		X509V3_add_value_uchar("URI",gen->d.ia5->data, &ret);
d148 1
a148 1
		case GEN_DIRNAME:
d150 1
a150 1
		X509V3_add_value("DirName",oline, &ret);
d153 1
a153 1
		case GEN_IPADD:
d155 1
a155 1
		if(gen->d.ip->length == 4)
d157 2
a158 3
				     "%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
		else if(gen->d.ip->length == 16)
			{
d160 1
a160 2
			for (i = 0; i < 8; i++)
				{
d162 1
a162 1
					     "%X", p[0] << 8 | p[1]);
a166 1
				}
d168 2
a169 3
		else
			{
			X509V3_add_value("IP Address","<invalid>", &ret);
d171 2
a172 2
			}
		X509V3_add_value("IP Address",oline, &ret);
d175 1
a175 1
		case GEN_RID:
d177 1
a177 1
		X509V3_add_value("Registered ID",oline, &ret);
d183 2
a184 1
int GENERAL_NAME_print(BIO *out, GENERAL_NAME *gen)
d188 3
a190 3
	switch (gen->type)
	{
		case GEN_OTHERNAME:
d194 1
a194 1
		case GEN_X400:
d198 1
a198 1
		case GEN_EDIPARTY:
d203 2
a204 2
		case GEN_EMAIL:
		BIO_printf(out, "email:%s",gen->d.ia5->data);
d207 2
a208 2
		case GEN_DNS:
		BIO_printf(out, "DNS:%s",gen->d.ia5->data);
d211 2
a212 2
		case GEN_URI:
		BIO_printf(out, "URI:%s",gen->d.ia5->data);
d215 1
a215 1
		case GEN_DIRNAME:
d220 1
a220 1
		case GEN_IPADD:
d222 1
a222 1
		if(gen->d.ip->length == 4)
d224 2
a225 3
						p[0], p[1], p[2], p[3]);
		else if(gen->d.ip->length == 16)
			{
d227 1
a227 2
			for (i = 0; i < 8; i++)
				{
d230 1
a230 1
				}
d232 2
a233 4
			}
		else
			{
			BIO_printf(out,"IP Address:<invalid>");
d235 1
a235 1
			}
d238 1
a238 1
		case GEN_RID:
d246 3
a248 2
static GENERAL_NAMES *v2i_issuer_alt(X509V3_EXT_METHOD *method,
				 X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval)
d253 3
a255 2
	if(!(gens = sk_GENERAL_NAME_new_null())) {
		X509V3err(X509V3_F_V2I_ISSUER_ALT,ERR_R_MALLOC_FAILURE);
d258 1
a258 1
	for(i = 0; i < sk_CONF_VALUE_num(nval); i++) {
d260 4
a263 3
		if(!name_cmp(cnf->name, "issuer") && cnf->value &&
						!strcmp(cnf->value, "copy")) {
			if(!copy_issuer(ctx, gens)) goto err;
d266 2
a267 2
			if(!(gen = v2i_GENERAL_NAME(method, ctx, cnf)))
								 goto err; 
d272 2
a273 1
	err:
d280 2
a281 1
static int copy_issuer(X509V3_CTX *ctx, GENERAL_NAMES *gens)
d287 5
a291 3
	if(ctx && (ctx->flags == CTX_TEST)) return 1;
	if(!ctx || !ctx->issuer_cert) {
		X509V3err(X509V3_F_COPY_ISSUER,X509V3_R_NO_ISSUER_DETAILS);
d294 6
a299 5
        i = X509_get_ext_by_NID(ctx->issuer_cert, NID_subject_alt_name, -1);
	if(i < 0) return 1;
        if(!(ext = X509_get_ext(ctx->issuer_cert, i)) ||
                        !(ialt = X509V3_EXT_d2i(ext)) ) {
		X509V3err(X509V3_F_COPY_ISSUER,X509V3_R_ISSUER_DECODE_ERROR);
d303 1
a303 1
	for(i = 0; i < sk_GENERAL_NAME_num(ialt); i++) {
d305 2
a306 2
		if(!sk_GENERAL_NAME_push(gens, gen)) {
			X509V3err(X509V3_F_COPY_ISSUER,ERR_R_MALLOC_FAILURE);
d313 2
a314 2
		
	err:
d316 1
a316 1
	
d319 3
a321 2
static GENERAL_NAMES *v2i_subject_alt(X509V3_EXT_METHOD *method,
				 X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval)
d326 3
a328 2
	if(!(gens = sk_GENERAL_NAME_new_null())) {
		X509V3err(X509V3_F_V2I_SUBJECT_ALT,ERR_R_MALLOC_FAILURE);
d331 1
a331 1
	for(i = 0; i < sk_CONF_VALUE_num(nval); i++) {
d333 8
a340 6
		if(!name_cmp(cnf->name, "email") && cnf->value &&
						!strcmp(cnf->value, "copy")) {
			if(!copy_email(ctx, gens, 0)) goto err;
		} else if(!name_cmp(cnf->name, "email") && cnf->value &&
						!strcmp(cnf->value, "move")) {
			if(!copy_email(ctx, gens, 1)) goto err;
d343 2
a344 2
			if(!(gen = v2i_GENERAL_NAME(method, ctx, cnf)))
								 goto err; 
d349 2
a350 1
	err:
d355 1
a355 1
/* Copy any email addresses in a certificate or request to 
d359 2
a360 1
static int copy_email(X509V3_CTX *ctx, GENERAL_NAMES *gens, int move_p)
d367 2
a368 1
	if(ctx != NULL && ctx->flags == CTX_TEST)
d370 2
a371 2
	if(!ctx || (!ctx->subject_cert && !ctx->subject_req)) {
		X509V3err(X509V3_F_COPY_EMAIL,X509V3_R_NO_SUBJECT_DETAILS);
d375 4
a378 2
	if(ctx->subject_cert) nm = X509_get_subject_name(ctx->subject_cert);
	else nm = X509_REQ_get_subject_name(ctx->subject_req);
d382 2
a383 2
	while((i = X509_NAME_get_index_by_NID(nm,
					 NID_pkcs9_emailAddress, i)) >= 0) {
d386 2
a387 3
                if (move_p)
                        {
                        X509_NAME_delete_entry(nm, i);
d389 4
a392 4
                        i--;
                        }
		if(!email || !(gen = GENERAL_NAME_new())) {
			X509V3err(X509V3_F_COPY_EMAIL,ERR_R_MALLOC_FAILURE);
d398 2
a399 2
		if(!sk_GENERAL_NAME_push(gens, gen)) {
			X509V3err(X509V3_F_COPY_EMAIL,ERR_R_MALLOC_FAILURE);
a404 1
	
d406 2
a407 2
		
	err:
a410 1
	
d413 3
a415 2
GENERAL_NAMES *v2i_GENERAL_NAMES(const X509V3_EXT_METHOD *method,
				 X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval)
d421 3
a423 2
	if(!(gens = sk_GENERAL_NAME_new_null())) {
		X509V3err(X509V3_F_V2I_GENERAL_NAMES,ERR_R_MALLOC_FAILURE);
d426 1
a426 1
	for(i = 0; i < sk_CONF_VALUE_num(nval); i++) {
d428 2
a429 1
		if(!(gen = v2i_GENERAL_NAME(method, ctx, cnf))) goto err; 
d433 2
a434 1
	err:
d439 4
a442 3
GENERAL_NAME *v2i_GENERAL_NAME(const X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
			       CONF_VALUE *cnf)
	{
d444 1
a444 1
	}
d446 4
a449 4
GENERAL_NAME *a2i_GENERAL_NAME(GENERAL_NAME *out,
			       const X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
			       int gen_type, char *value, int is_nc)
	{
d453 2
a454 3
	if(!value)
		{
		X509V3err(X509V3_F_A2I_GENERAL_NAME,X509V3_R_MISSING_VALUE);
d456 1
a456 1
		}
d460 1
a460 2
	else
		{
d462 3
a464 3
		if(gen == NULL)
			{
			X509V3err(X509V3_F_A2I_GENERAL_NAME,ERR_R_MALLOC_FAILURE);
a465 1
			}
d467 1
d469 4
a472 5
	switch (gen_type)
		{
		case GEN_URI:
		case GEN_EMAIL:
		case GEN_DNS:
d475 2
a476 2
		
		case GEN_RID:
d478 6
a483 6
		ASN1_OBJECT *obj;
		if(!(obj = OBJ_txt2obj(value,0)))
			{
			X509V3err(X509V3_F_A2I_GENERAL_NAME,X509V3_R_BAD_OBJECT);
			ERR_add_error_data(2, "value=", value);
			goto err;
d485 1
a485 1
		gen->d.rid = obj;
d489 1
a489 1
		case GEN_IPADD:
d494 3
a496 3
		if(gen->d.ip == NULL)
			{
			X509V3err(X509V3_F_A2I_GENERAL_NAME,X509V3_R_BAD_IP_ADDRESS);
d499 1
a499 1
			}
d502 4
a505 4
		case GEN_DIRNAME:
		if (!do_dirname(gen, value, ctx))
			{
			X509V3err(X509V3_F_A2I_GENERAL_NAME,X509V3_R_DIRNAME_ERROR);
d507 1
a507 1
			}
d510 4
a513 4
		case GEN_OTHERNAME:
		if (!do_othername(gen, value, ctx))
			{
			X509V3err(X509V3_F_A2I_GENERAL_NAME,X509V3_R_OTHERNAME_ERROR);
d515 1
a515 1
			}
d517 3
a519 2
		default:
		X509V3err(X509V3_F_A2I_GENERAL_NAME,X509V3_R_UNSUPPORTED_TYPE);
d521 1
a521 1
		}
d523 6
a528 7
	if(is_string)
		{
		if(!(gen->d.ia5 = M_ASN1_IA5STRING_new()) ||
			      !ASN1_STRING_set(gen->d.ia5, (unsigned char*)value,
					       strlen(value)))
			{
			X509V3err(X509V3_F_A2I_GENERAL_NAME,ERR_R_MALLOC_FAILURE);
a529 1
			}
d531 1
d537 1
a537 1
	err:
d541 1
a541 1
	}
d543 4
a546 4
GENERAL_NAME *v2i_GENERAL_NAME_ex(GENERAL_NAME *out,
				  const X509V3_EXT_METHOD *method,
				  X509V3_CTX *ctx, CONF_VALUE *cnf, int is_nc)
	{
a547 1

d553 2
a554 3
	if(!value)
		{
		X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_MISSING_VALUE);
d556 1
a556 1
		}
d558 1
a558 1
	if(!name_cmp(name, "email"))
d560 1
a560 1
	else if(!name_cmp(name, "URI"))
d562 1
a562 1
	else if(!name_cmp(name, "DNS"))
d564 1
a564 1
	else if(!name_cmp(name, "RID"))
d566 1
a566 1
	else if(!name_cmp(name, "IP"))
d568 1
a568 1
	else if(!name_cmp(name, "dirName"))
d570 1
a570 1
	else if(!name_cmp(name, "otherName"))
d572 3
a574 3
	else
		{
		X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_UNSUPPORTED_OPTION);
d577 1
a577 1
		}
d580 1
d582 3
a584 4
	}

static int do_othername(GENERAL_NAME *gen, char *value, X509V3_CTX *ctx)
	{
d587 1
d609 1
a609 1
	}
d611 3
a613 2
static int do_dirname(GENERAL_NAME *gen, char *value, X509V3_CTX *ctx)
	{
d617 1
d621 2
a622 3
	if (!sk)
		{
		X509V3err(X509V3_F_DO_DIRNAME,X509V3_R_SECTION_NOT_FOUND);
d626 1
a626 1
		}
d633 1
a633 1
		
d635 1
a635 1
	}
@


1.15
log
@We'll interpret a (void) cast on snprintf() to mean it's been verified that
truncation is either desirable, not an issue, or is detected and handled later

ok deraadt@@
@
text
@d146 1
a146 1
			snprintf(oline, sizeof oline,
d153 1
a153 1
				snprintf(htmp, sizeof htmp,
@


1.14
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d146 1
a146 1
			(void) snprintf(oline, sizeof oline,
d153 1
a153 1
				(void) snprintf(htmp, sizeof htmp,
@


1.13
log
@Clean up dangerous strncpy use. This included a use where the resulting
string was potentially not nul terminated and a place where malloc return
was unchecked.
while we're at it remove dummytest.c
ok miod@@
@
text
@d581 1
a581 1
	objtmp = OPENSSL_malloc(objlen + 1);
d585 1
a585 1
		OPENSSL_free(objtmp);
@


1.12
log
@Part 1 of eliminating BIO_snprintf(). This fixes mechanical conversions
where the return value is ignored changing to (void) snprintf.
ok deraadt@@
@
text
@d582 6
a587 4
	strncpy(objtmp, value, objlen);
	objtmp[objlen] = 0;
	gen->d.otherName->type_id = OBJ_txt2obj(objtmp, 0);
	OPENSSL_free(objtmp);	
@


1.11
log
@resolve conflicts, fix local changes
@
text
@d146 1
a146 1
			BIO_snprintf(oline, sizeof oline,
d153 1
a153 1
				BIO_snprintf(htmp, sizeof htmp,
@


1.10
log
@resolve conflicts
@
text
@d85 6
d156 1
a156 1
				strlcat(oline, htmp, sizeof oline);
d158 1
a158 1
					strlcat(oline, ":", sizeof oline);
d369 1
d396 2
a397 2
GENERAL_NAMES *v2i_GENERAL_NAMES(X509V3_EXT_METHOD *method,
				X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval)
d418 2
a419 2
GENERAL_NAME *v2i_GENERAL_NAME(X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
							 CONF_VALUE *cnf)
d424 3
a426 3
GENERAL_NAME *v2i_GENERAL_NAME_ex(GENERAL_NAME *out,
				X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
						 CONF_VALUE *cnf, int is_nc)
a428 1
	int type;
a430 5
	char *name, *value;

	name = cnf->name;
	value = cnf->value;

d433 1
a433 1
		X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_MISSING_VALUE);
d444 1
a444 1
			X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,ERR_R_MALLOC_FAILURE);
d449 1
a449 1
	if(!name_cmp(name, "email"))
d451 3
d455 3
a457 13
		type = GEN_EMAIL;
		}
	else if(!name_cmp(name, "URI"))
		{
		is_string = 1;
		type = GEN_URI;
		}
	else if(!name_cmp(name, "DNS"))
		{
		is_string = 1;
		type = GEN_DNS;
		}
	else if(!name_cmp(name, "RID"))
d462 1
a462 1
			X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_BAD_OBJECT);
a466 1
		type = GEN_RID;
d468 3
a470 2
	else if(!name_cmp(name, "IP"))
		{
d477 1
a477 1
			X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_BAD_IP_ADDRESS);
d481 3
a483 5
		type = GEN_IPADD;
		}
	else if(!name_cmp(name, "dirName"))
		{
		type = GEN_DIRNAME;
d486 1
a486 1
			X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_DIRNAME_ERROR);
d489 3
a491 3
		}
	else if(!name_cmp(name, "otherName"))
		{
d494 1
a494 1
			X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_OTHERNAME_ERROR);
d497 3
a499 6
		type = GEN_OTHERNAME;
		}
	else
		{
		X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_UNSUPPORTED_OPTION);
		ERR_add_error_data(2, "name=", name);
d509 1
a509 1
			X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,ERR_R_MALLOC_FAILURE);
d514 1
a514 1
	gen->type = type;
d524 42
d611 1
@


1.9
log
@remerge local tweaks, update per-arch configuration headers, update
Makefiles, crank shlib_version
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
d530 2
a531 1
	GENERAL_NAME_free(gen);
@


1.8
log
@resolve conflicts
@
text
@d150 1
a150 1
				strcat(oline, htmp);
d152 1
a152 1
					strcat(oline, ":");
@


1.7
log
@merge 0.9.7d
@
text
@d3 1
a3 1
 * project 1999.
d6 1
a6 1
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
d68 4
a71 1
X509V3_EXT_METHOD v3_alt[] = {
d104 2
a105 1
	char oline[256];
d139 18
a156 2
		/* BUG: doesn't support IPV6 */
		if(gen->d.ip->length != 4) {
d159 1
a159 3
		}
		BIO_snprintf(oline, sizeof oline,
			     "%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
d174 1
d209 15
a223 2
		/* BUG: doesn't support IPV6 */
		if(gen->d.ip->length != 4) {
d226 1
a226 2
		}
		BIO_printf(out, "IP Address:%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
d244 1
a244 1
		X509V3err(X509V3_F_V2I_GENERAL_NAMES,ERR_R_MALLOC_FAILURE);
d309 1
a309 1
		X509V3err(X509V3_F_V2I_GENERAL_NAMES,ERR_R_MALLOC_FAILURE);
d344 2
a345 1
	if(ctx->flags == CTX_TEST) return 1;
d413 11
a423 4
{
char is_string = 0;
int type;
GENERAL_NAME *gen = NULL;
d425 1
a425 1
char *name, *value;
d427 2
a428 2
name = cnf->name;
value = cnf->value;
d430 5
a434 4
if(!value) {
	X509V3err(X509V3_F_V2I_GENERAL_NAME,X509V3_R_MISSING_VALUE);
	return NULL;
}
d436 11
a446 4
if(!(gen = GENERAL_NAME_new())) {
	X509V3err(X509V3_F_V2I_GENERAL_NAME,ERR_R_MALLOC_FAILURE);
	return NULL;
}
d448 63
a510 14
if(!name_cmp(name, "email")) {
	is_string = 1;
	type = GEN_EMAIL;
} else if(!name_cmp(name, "URI")) {
	is_string = 1;
	type = GEN_URI;
} else if(!name_cmp(name, "DNS")) {
	is_string = 1;
	type = GEN_DNS;
} else if(!name_cmp(name, "RID")) {
	ASN1_OBJECT *obj;
	if(!(obj = OBJ_txt2obj(value,0))) {
		X509V3err(X509V3_F_V2I_GENERAL_NAME,X509V3_R_BAD_OBJECT);
		ERR_add_error_data(2, "value=", value);
d512 9
a520 17
	}
	gen->d.rid = obj;
	type = GEN_RID;
} else if(!name_cmp(name, "IP")) {
	int i1,i2,i3,i4;
	unsigned char ip[4];
	if((sscanf(value, "%d.%d.%d.%d",&i1,&i2,&i3,&i4) != 4) ||
	    (i1 < 0) || (i1 > 255) || (i2 < 0) || (i2 > 255) ||
	    (i3 < 0) || (i3 > 255) || (i4 < 0) || (i4 > 255) ) {
		X509V3err(X509V3_F_V2I_GENERAL_NAME,X509V3_R_BAD_IP_ADDRESS);
		ERR_add_error_data(2, "value=", value);
		goto err;
	}
	ip[0] = i1; ip[1] = i2 ; ip[2] = i3 ; ip[3] = i4;
	if(!(gen->d.ip = M_ASN1_OCTET_STRING_new()) ||
		!ASN1_STRING_set(gen->d.ip, ip, 4)) {
			X509V3err(X509V3_F_V2I_GENERAL_NAME,ERR_R_MALLOC_FAILURE);
d522 10
a532 6
	type = GEN_IPADD;
} else {
	X509V3err(X509V3_F_V2I_GENERAL_NAME,X509V3_R_UNSUPPORTED_OPTION);
	ERR_add_error_data(2, "name=", name);
	goto err;
}
d534 23
a556 6
if(is_string) {
	if(!(gen->d.ia5 = M_ASN1_IA5STRING_new()) ||
		      !ASN1_STRING_set(gen->d.ia5, (unsigned char*)value,
				       strlen(value))) {
		X509V3err(X509V3_F_V2I_GENERAL_NAME,ERR_R_MALLOC_FAILURE);
		goto err;
a557 1
}
d559 23
a581 8
gen->type = type;

return gen;

err:
GENERAL_NAME_free(gen);
return NULL;
}
@


1.6
log
@Trivial sprintf() -> snprintf() changes. ok deraadt@@
@
text
@d140 2
a141 2
		snprintf(oline, sizeof oline, "%d.%d.%d.%d", p[0], p[1], p[2],
			 p[3]);
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d140 2
a141 1
		sprintf(oline, "%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
@


1.4
log
@openssl-engine-0.9.6a merge
@
text
@d64 4
a67 4
static STACK_OF(GENERAL_NAME) *v2i_subject_alt(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval);
static STACK_OF(GENERAL_NAME) *v2i_issuer_alt(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval);
static int copy_email(X509V3_CTX *ctx, STACK_OF(GENERAL_NAME) *gens);
static int copy_issuer(X509V3_CTX *ctx, STACK_OF(GENERAL_NAME) *gens);
d69 3
a71 6
{ NID_subject_alt_name, 0,
(X509V3_EXT_NEW)GENERAL_NAMES_new,
(X509V3_EXT_FREE)GENERAL_NAMES_free,
(X509V3_EXT_D2I)d2i_GENERAL_NAMES,
(X509V3_EXT_I2D)i2d_GENERAL_NAMES,
NULL, NULL,
d75 4
a78 6
{ NID_issuer_alt_name, 0,
(X509V3_EXT_NEW)GENERAL_NAMES_new,
(X509V3_EXT_FREE)GENERAL_NAMES_free,
(X509V3_EXT_D2I)d2i_GENERAL_NAMES,
(X509V3_EXT_I2D)i2d_GENERAL_NAMES,
NULL, NULL,
d85 1
a85 1
		STACK_OF(GENERAL_NAME) *gens, STACK_OF(CONF_VALUE) *ret)
d100 1
a101 1
	unsigned char *p;
d152 54
a205 1
static STACK_OF(GENERAL_NAME) *v2i_issuer_alt(X509V3_EXT_METHOD *method,
d208 1
a208 1
	STACK_OF(GENERAL_NAME) *gens = NULL;
d235 1
a235 1
static int copy_issuer(X509V3_CTX *ctx, STACK_OF(GENERAL_NAME) *gens)
d237 1
a237 1
	STACK_OF(GENERAL_NAME) *ialt;
d270 1
a270 1
static STACK_OF(GENERAL_NAME) *v2i_subject_alt(X509V3_EXT_METHOD *method,
d273 1
a273 1
	STACK_OF(GENERAL_NAME) *gens = NULL;
d284 4
a287 1
			if(!copy_email(ctx, gens)) goto err;
d305 1
a305 1
static int copy_email(X509V3_CTX *ctx, STACK_OF(GENERAL_NAME) *gens)
d327 5
d356 1
a356 1
STACK_OF(GENERAL_NAME) *v2i_GENERAL_NAMES(X509V3_EXT_METHOD *method,
d360 1
a360 1
	STACK_OF(GENERAL_NAME) *gens = NULL;
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d273 1
a273 1
					 NID_pkcs9_emailAddress, i)) > 0) {
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d163 1
a163 1
	if(!(gens = sk_GENERAL_NAME_new(NULL))) {
d228 1
a228 1
	if(!(gens = sk_GENERAL_NAME_new(NULL))) {
d307 1
a307 1
	if(!(gens = sk_GENERAL_NAME_new(NULL))) {
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@a86 1
EXT_END
d275 1
a275 1
		email = ASN1_IA5STRING_dup(X509_NAME_ENTRY_get_data(ne));
d295 1
a295 1
	ASN1_IA5STRING_free(email);
d373 1
a373 1
	if(!(gen->d.ip = ASN1_OCTET_STRING_new()) ||
d386 1
a386 1
	if(!(gen->d.ia5 = ASN1_IA5STRING_new()) ||
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d64 4
a67 4
static GENERAL_NAMES *v2i_subject_alt(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval);
static GENERAL_NAMES *v2i_issuer_alt(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval);
static int copy_email(X509V3_CTX *ctx, GENERAL_NAMES *gens, int move_p);
static int copy_issuer(X509V3_CTX *ctx, GENERAL_NAMES *gens);
d69 6
a74 3
{ NID_subject_alt_name, 0, ASN1_ITEM_ref(GENERAL_NAMES),
0,0,0,0,
0,0,
d78 6
a83 4

{ NID_issuer_alt_name, 0, ASN1_ITEM_ref(GENERAL_NAMES),
0,0,0,0,
0,0,
d87 1
d91 1
a91 1
		GENERAL_NAMES *gens, STACK_OF(CONF_VALUE) *ret)
d106 1
a107 1
	char oline[256];
d158 1
a158 54
int GENERAL_NAME_print(BIO *out, GENERAL_NAME *gen)
{
	unsigned char *p;
	switch (gen->type)
	{
		case GEN_OTHERNAME:
		BIO_printf(out, "othername:<unsupported>");
		break;

		case GEN_X400:
		BIO_printf(out, "X400Name:<unsupported>");
		break;

		case GEN_EDIPARTY:
		/* Maybe fix this: it is supported now */
		BIO_printf(out, "EdiPartyName:<unsupported>");
		break;

		case GEN_EMAIL:
		BIO_printf(out, "email:%s",gen->d.ia5->data);
		break;

		case GEN_DNS:
		BIO_printf(out, "DNS:%s",gen->d.ia5->data);
		break;

		case GEN_URI:
		BIO_printf(out, "URI:%s",gen->d.ia5->data);
		break;

		case GEN_DIRNAME:
		BIO_printf(out, "DirName: ");
		X509_NAME_print_ex(out, gen->d.dirn, 0, XN_FLAG_ONELINE);
		break;

		case GEN_IPADD:
		p = gen->d.ip->data;
		/* BUG: doesn't support IPV6 */
		if(gen->d.ip->length != 4) {
			BIO_printf(out,"IP Address:<invalid>");
			break;
		}
		BIO_printf(out, "IP Address:%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
		break;

		case GEN_RID:
		BIO_printf(out, "Registered ID");
		i2a_ASN1_OBJECT(out, gen->d.rid);
		break;
	}
	return 1;
}

static GENERAL_NAMES *v2i_issuer_alt(X509V3_EXT_METHOD *method,
d161 1
a161 1
	GENERAL_NAMES *gens = NULL;
d164 1
a164 1
	if(!(gens = sk_GENERAL_NAME_new_null())) {
d188 1
a188 1
static int copy_issuer(X509V3_CTX *ctx, GENERAL_NAMES *gens)
d190 1
a190 1
	GENERAL_NAMES *ialt;
d223 1
a223 1
static GENERAL_NAMES *v2i_subject_alt(X509V3_EXT_METHOD *method,
d226 1
a226 1
	GENERAL_NAMES *gens = NULL;
d229 1
a229 1
	if(!(gens = sk_GENERAL_NAME_new_null())) {
d237 1
a237 4
			if(!copy_email(ctx, gens, 0)) goto err;
		} else if(!name_cmp(cnf->name, "email") && cnf->value &&
						!strcmp(cnf->value, "move")) {
			if(!copy_email(ctx, gens, 1)) goto err;
d255 1
a255 1
static int copy_email(X509V3_CTX *ctx, GENERAL_NAMES *gens, int move_p)
d274 1
a274 1
					 NID_pkcs9_emailAddress, i)) >= 0) {
d276 1
a276 6
		email = M_ASN1_IA5STRING_dup(X509_NAME_ENTRY_get_data(ne));
                if (move_p)
                        {
                        X509_NAME_delete_entry(nm, i);
                        i--;
                        }
d296 1
a296 1
	M_ASN1_IA5STRING_free(email);
d301 1
a301 1
GENERAL_NAMES *v2i_GENERAL_NAMES(X509V3_EXT_METHOD *method,
d305 1
a305 1
	GENERAL_NAMES *gens = NULL;
d308 1
a308 1
	if(!(gens = sk_GENERAL_NAME_new_null())) {
d374 1
a374 1
	if(!(gen->d.ip = M_ASN1_OCTET_STRING_new()) ||
d387 1
a387 1
	if(!(gen->d.ia5 = M_ASN1_IA5STRING_new()) ||
@


1.1.1.2
log
@import openssl-0.9.7d
@
text
@d140 1
a140 2
		BIO_snprintf(oline, sizeof oline,
			     "%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d3 1
a3 1
 * project.
d6 1
a6 1
 * Copyright (c) 1999-2003 The OpenSSL Project.  All rights reserved.
d68 1
a68 4
static int do_othername(GENERAL_NAME *gen, char *value, X509V3_CTX *ctx);
static int do_dirname(GENERAL_NAME *gen, char *value, X509V3_CTX *ctx);

const X509V3_EXT_METHOD v3_alt[] = {
d101 1
a101 2
	char oline[256], htmp[5];
	int i;
d135 2
a136 18
		if(gen->d.ip->length == 4)
			BIO_snprintf(oline, sizeof oline,
				     "%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
		else if(gen->d.ip->length == 16)
			{
			oline[0] = 0;
			for (i = 0; i < 8; i++)
				{
				BIO_snprintf(htmp, sizeof htmp,
					     "%X", p[0] << 8 | p[1]);
				p += 2;
				strcat(oline, htmp);
				if (i != 7)
					strcat(oline, ":");
				}
			}
		else
			{
d139 3
a141 1
			}
a155 1
	int i;
d190 2
a191 15
		if(gen->d.ip->length == 4)
			BIO_printf(out, "IP Address:%d.%d.%d.%d",
						p[0], p[1], p[2], p[3]);
		else if(gen->d.ip->length == 16)
			{
			BIO_printf(out, "IP Address");
			for (i = 0; i < 8; i++)
				{
				BIO_printf(out, ":%X", p[0] << 8 | p[1]);
				p += 2;
				}
			BIO_puts(out, "\n");
			}
		else
			{
d194 2
a195 1
			}
d213 1
a213 1
		X509V3err(X509V3_F_V2I_ISSUER_ALT,ERR_R_MALLOC_FAILURE);
d278 1
a278 1
		X509V3err(X509V3_F_V2I_SUBJECT_ALT,ERR_R_MALLOC_FAILURE);
d313 1
a313 2
	if(ctx != NULL && ctx->flags == CTX_TEST)
		return 1;
d381 4
a384 3
	{
	return v2i_GENERAL_NAME_ex(NULL, method, ctx, cnf, 0);
	}
d386 1
a386 7
GENERAL_NAME *v2i_GENERAL_NAME_ex(GENERAL_NAME *out,
				X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
						 CONF_VALUE *cnf, int is_nc)
	{
	char is_string = 0;
	int type;
	GENERAL_NAME *gen = NULL;
d388 2
a389 1
	char *name, *value;
d391 4
a394 2
	name = cnf->name;
	value = cnf->value;
d396 4
a399 5
	if(!value)
		{
		X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_MISSING_VALUE);
		return NULL;
		}
d401 26
a426 75
	if (out)
		gen = out;
	else
		{
		gen = GENERAL_NAME_new();
		if(gen == NULL)
			{
			X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,ERR_R_MALLOC_FAILURE);
			return NULL;
			}
		}

	if(!name_cmp(name, "email"))
		{
		is_string = 1;
		type = GEN_EMAIL;
		}
	else if(!name_cmp(name, "URI"))
		{
		is_string = 1;
		type = GEN_URI;
		}
	else if(!name_cmp(name, "DNS"))
		{
		is_string = 1;
		type = GEN_DNS;
		}
	else if(!name_cmp(name, "RID"))
		{
		ASN1_OBJECT *obj;
		if(!(obj = OBJ_txt2obj(value,0)))
			{
			X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_BAD_OBJECT);
			ERR_add_error_data(2, "value=", value);
			goto err;
			}
		gen->d.rid = obj;
		type = GEN_RID;
		}
	else if(!name_cmp(name, "IP"))
		{
		if (is_nc)
			gen->d.ip = a2i_IPADDRESS_NC(value);
		else
			gen->d.ip = a2i_IPADDRESS(value);
		if(gen->d.ip == NULL)
			{
			X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_BAD_IP_ADDRESS);
			ERR_add_error_data(2, "value=", value);
			goto err;
			}
		type = GEN_IPADD;
		}
	else if(!name_cmp(name, "dirName"))
		{
		type = GEN_DIRNAME;
		if (!do_dirname(gen, value, ctx))
			{
			X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_DIRNAME_ERROR);
			goto err;
			}
		}
	else if(!name_cmp(name, "otherName"))
		{
		if (!do_othername(gen, value, ctx))
			{
			X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_OTHERNAME_ERROR);
			goto err;
			}
		type = GEN_OTHERNAME;
		}
	else
		{
		X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_UNSUPPORTED_OPTION);
		ERR_add_error_data(2, "name=", name);
d428 5
a432 9
		}

	if(is_string)
		{
		if(!(gen->d.ia5 = M_ASN1_IA5STRING_new()) ||
			      !ASN1_STRING_set(gen->d.ia5, (unsigned char*)value,
					       strlen(value)))
			{
			X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,ERR_R_MALLOC_FAILURE);
d434 7
a440 2
			}
		}
d442 8
a449 3
	gen->type = type;

	return gen;
d451 1
a451 4
	err:
	GENERAL_NAME_free(gen);
	return NULL;
	}
d453 1
a453 24
static int do_othername(GENERAL_NAME *gen, char *value, X509V3_CTX *ctx)
	{
	char *objtmp = NULL, *p;
	int objlen;
	if (!(p = strchr(value, ';')))
		return 0;
	if (!(gen->d.otherName = OTHERNAME_new()))
		return 0;
	/* Free this up because we will overwrite it.
	 * no need to free type_id because it is static
	 */
	ASN1_TYPE_free(gen->d.otherName->value);
	if (!(gen->d.otherName->value = ASN1_generate_v3(p + 1, ctx)))
		return 0;
	objlen = p - value;
	objtmp = OPENSSL_malloc(objlen + 1);
	strncpy(objtmp, value, objlen);
	objtmp[objlen] = 0;
	gen->d.otherName->type_id = OBJ_txt2obj(objtmp, 0);
	OPENSSL_free(objtmp);	
	if (!gen->d.otherName->type_id)
		return 0;
	return 1;
	}
d455 4
a458 23
static int do_dirname(GENERAL_NAME *gen, char *value, X509V3_CTX *ctx)
	{
	int ret;
	STACK_OF(CONF_VALUE) *sk;
	X509_NAME *nm;
	if (!(nm = X509_NAME_new()))
		return 0;
	sk = X509V3_get_section(ctx, value);
	if (!sk)
		{
		X509V3err(X509V3_F_DO_DIRNAME,X509V3_R_SECTION_NOT_FOUND);
		ERR_add_error_data(2, "section=", value);
		X509_NAME_free(nm);
		return 0;
		}
	/* FIXME: should allow other character types... */
	ret = X509V3_NAME_from_section(nm, sk, MBSTRING_ASC);
	if (!ret)
		X509_NAME_free(nm);
	gen->d.dirn = nm;
		
	return ret;
	}
@


1.1.1.4
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
d530 1
a530 2
	if (!out)
		GENERAL_NAME_free(gen);
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@a84 6

{ NID_certificate_issuer, 0, ASN1_ITEM_ref(GENERAL_NAMES),
0,0,0,0,
0,0,
(X509V3_EXT_I2V)i2v_GENERAL_NAMES,
NULL, NULL, NULL, NULL},
a362 1
			X509_NAME_ENTRY_free(ne);
d389 2
a390 2
GENERAL_NAMES *v2i_GENERAL_NAMES(const X509V3_EXT_METHOD *method,
				 X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval)
d411 2
a412 2
GENERAL_NAME *v2i_GENERAL_NAME(const X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
			       CONF_VALUE *cnf)
d417 3
a419 3
GENERAL_NAME *a2i_GENERAL_NAME(GENERAL_NAME *out,
			       const X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
			       int gen_type, char *value, int is_nc)
d422 1
d425 5
d432 1
a432 1
		X509V3err(X509V3_F_A2I_GENERAL_NAME,X509V3_R_MISSING_VALUE);
d443 1
a443 1
			X509V3err(X509V3_F_A2I_GENERAL_NAME,ERR_R_MALLOC_FAILURE);
d448 11
a458 1
	switch (gen_type)
a459 3
		case GEN_URI:
		case GEN_EMAIL:
		case GEN_DNS:
d461 3
a463 3
		break;
		
		case GEN_RID:
d468 1
a468 1
			X509V3err(X509V3_F_A2I_GENERAL_NAME,X509V3_R_BAD_OBJECT);
d473 1
d475 2
a476 3
		break;

		case GEN_IPADD:
d483 1
a483 1
			X509V3err(X509V3_F_A2I_GENERAL_NAME,X509V3_R_BAD_IP_ADDRESS);
d487 5
a491 3
		break;

		case GEN_DIRNAME:
d494 1
a494 1
			X509V3err(X509V3_F_A2I_GENERAL_NAME,X509V3_R_DIRNAME_ERROR);
d497 3
a499 3
		break;

		case GEN_OTHERNAME:
d502 1
a502 1
			X509V3err(X509V3_F_A2I_GENERAL_NAME,X509V3_R_OTHERNAME_ERROR);
d505 6
a510 3
		break;
		default:
		X509V3err(X509V3_F_A2I_GENERAL_NAME,X509V3_R_UNSUPPORTED_TYPE);
d520 1
a520 1
			X509V3err(X509V3_F_A2I_GENERAL_NAME,ERR_R_MALLOC_FAILURE);
d525 1
a525 1
	gen->type = gen_type;
a534 42
GENERAL_NAME *v2i_GENERAL_NAME_ex(GENERAL_NAME *out,
				  const X509V3_EXT_METHOD *method,
				  X509V3_CTX *ctx, CONF_VALUE *cnf, int is_nc)
	{
	int type;

	char *name, *value;

	name = cnf->name;
	value = cnf->value;

	if(!value)
		{
		X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_MISSING_VALUE);
		return NULL;
		}

	if(!name_cmp(name, "email"))
		type = GEN_EMAIL;
	else if(!name_cmp(name, "URI"))
		type = GEN_URI;
	else if(!name_cmp(name, "DNS"))
		type = GEN_DNS;
	else if(!name_cmp(name, "RID"))
		type = GEN_RID;
	else if(!name_cmp(name, "IP"))
		type = GEN_IPADD;
	else if(!name_cmp(name, "dirName"))
		type = GEN_DIRNAME;
	else if(!name_cmp(name, "otherName"))
		type = GEN_OTHERNAME;
	else
		{
		X509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_UNSUPPORTED_OPTION);
		ERR_add_error_data(2, "name=", name);
		return NULL;
		}

	return a2i_GENERAL_NAME(out, method, ctx, type, value, is_nc);

	}

a579 1
	X509V3_section_free(ctx, sk);
@


