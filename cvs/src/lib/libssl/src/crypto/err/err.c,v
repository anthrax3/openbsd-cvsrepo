head	1.41;
access;
symbols
	OPENBSD_6_0:1.41.0.8
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.6
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.4
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	butholakala:1.19
	openssl_1_0_1_g:1.1.1.12
	OPENBSD_5_5:1.19.0.8
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.4
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	openssl_1_0_1_c:1.1.1.12
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.8
	openssl_1_0_0_f:1.1.1.11
	openssl_1_0_0_e:1.1.1.11
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	openssh_1_0_0_a:1.1.1.11
	OPENBSD_4_8:1.17.0.8
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.4
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	openssl_0_9_8_k:1.1.1.10
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	openssl_0_9_8_j:1.1.1.10
	openssl_0_9_8_h:1.1.1.9
	pre_openssl_0_9_8h:1.14
	OPENBSD_4_4:1.14.0.10
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.8
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	openssl_0_9_7j:1.1.1.8
	openssl:1.1.1
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENSSL_0_9_7G:1.1.1.7
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENSSL_0_9_7D:1.1.1.6
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENSSL_0_9_7C:1.1.1.5
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2014.11.09.19.17.13;	author miod;	state Exp;
branches;
next	1.40;
commitid	QrgOG8zcUIADOfFd;

1.40
date	2014.10.05.15.21.48;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	RR2uilcOHVeWAvpV;

1.39
date	2014.08.24.16.11.39;	author bcook;	state Exp;
branches;
next	1.38;
commitid	x1lqXfPgG0paj3WI;

1.38
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.37;
commitid	yQEL1wOWIearrW15;

1.37
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.36;
commitid	nzndm3zqPmFurSaK;

1.36
date	2014.06.27.07.01.21;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	RFd7vlg3dAkLUBrB;

1.35
date	2014.06.27.06.07.01;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	ZZZl4WvpSI1Pmokf;

1.34
date	2014.06.26.15.24.08;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	Qcja70xUsejO5LMG;

1.33
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	mJUVYpkFBZ0Zv2bG;

1.32
date	2014.06.07.14.41.57;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	2nvnQBrv22dLtvTt;

1.31
date	2014.05.24.07.00.12;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.24.15.07.20;	author beck;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.21.14.50.59;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.20.20.14.09;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.19.11.43.07;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.19.00.41.38;	author beck;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.18.21.11.00;	author beck;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.17.21.32.37;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.16.20.36.35;	author beck;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.15.16.21.04;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.13.23.31.37;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2010.10.01.22.58.55;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.27.05.07.01;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.29.05.39.21;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.08.08.03.13;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.12.02.18.37;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.03.15.12.44;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.10.16.31.55;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.15.02.29.14;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.22.00.03.09;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.57.37;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.38;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.10.11;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.07;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.47;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.47;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.25;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.39.00;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.35.16;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.11.21.15.13;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.20.41.42;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.04.29.05.37.10;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.06.27.05.05.33;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.01.09.12.13.56;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.10.01.22.54.07;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2012.10.13.21.23.40;	author djm;	state Exp;
branches;
next	;


desc
@@


1.41
log
@GOST crypto algorithms (well, most of them), ported from the removed GOST
engine to regular EVP citizens, contributed by Dmitry Eremin-Solenikov;
libcrypto bits only for now.

This is a verbatim import of Dmitry's work, and does not compile in this
state; the forthcoming commits will address these issues.

None of the GOST code is enabled in libcrypto yet, for it still gets
compiled with OPENSSL_NO_GOST defined. However, the public header gost.h
will be installed.
@
text
@/* $OpenBSD: err.c,v 1.40 2014/10/05 15:21:48 deraadt Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#include <openssl/opensslconf.h>

#include <openssl/bio.h>
#include <openssl/buffer.h>
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/lhash.h>

DECLARE_LHASH_OF(ERR_STRING_DATA);
DECLARE_LHASH_OF(ERR_STATE);

static void err_load_strings(int lib, ERR_STRING_DATA *str);

static void ERR_STATE_free(ERR_STATE *s);
#ifndef OPENSSL_NO_ERR
static ERR_STRING_DATA ERR_str_libraries[] = {
	{ERR_PACK(ERR_LIB_NONE,0,0),		"unknown library"},
	{ERR_PACK(ERR_LIB_SYS,0,0),		"system library"},
	{ERR_PACK(ERR_LIB_BN,0,0),		"bignum routines"},
	{ERR_PACK(ERR_LIB_RSA,0,0),		"rsa routines"},
	{ERR_PACK(ERR_LIB_DH,0,0),		"Diffie-Hellman routines"},
	{ERR_PACK(ERR_LIB_EVP,0,0),		"digital envelope routines"},
	{ERR_PACK(ERR_LIB_BUF,0,0),		"memory buffer routines"},
	{ERR_PACK(ERR_LIB_OBJ,0,0),		"object identifier routines"},
	{ERR_PACK(ERR_LIB_PEM,0,0),		"PEM routines"},
	{ERR_PACK(ERR_LIB_DSA,0,0),		"dsa routines"},
	{ERR_PACK(ERR_LIB_X509,0,0),		"x509 certificate routines"},
	{ERR_PACK(ERR_LIB_ASN1,0,0),		"asn1 encoding routines"},
	{ERR_PACK(ERR_LIB_CONF,0,0),		"configuration file routines"},
	{ERR_PACK(ERR_LIB_CRYPTO,0,0),		"common libcrypto routines"},
	{ERR_PACK(ERR_LIB_EC,0,0),		"elliptic curve routines"},
	{ERR_PACK(ERR_LIB_SSL,0,0),		"SSL routines"},
	{ERR_PACK(ERR_LIB_BIO,0,0),		"BIO routines"},
	{ERR_PACK(ERR_LIB_PKCS7,0,0),		"PKCS7 routines"},
	{ERR_PACK(ERR_LIB_X509V3,0,0),		"X509 V3 routines"},
	{ERR_PACK(ERR_LIB_PKCS12,0,0),		"PKCS12 routines"},
	{ERR_PACK(ERR_LIB_RAND,0,0),		"random number generator"},
	{ERR_PACK(ERR_LIB_DSO,0,0),		"DSO support routines"},
	{ERR_PACK(ERR_LIB_TS,0,0),		"time stamp routines"},
	{ERR_PACK(ERR_LIB_ENGINE,0,0),		"engine routines"},
	{ERR_PACK(ERR_LIB_OCSP,0,0),		"OCSP routines"},
	{ERR_PACK(ERR_LIB_FIPS,0,0),		"FIPS routines"},
	{ERR_PACK(ERR_LIB_CMS,0,0),		"CMS routines"},
	{ERR_PACK(ERR_LIB_HMAC,0,0),		"HMAC routines"},
	{ERR_PACK(ERR_LIB_GOST,0,0),		"GOST routines"},
	{0, NULL},
};

static ERR_STRING_DATA ERR_str_functs[] = {
	{ERR_PACK(0,SYS_F_FOPEN, 0),     	"fopen"},
	{ERR_PACK(0,SYS_F_CONNECT, 0),		"connect"},
	{ERR_PACK(0,SYS_F_GETSERVBYNAME, 0),	"getservbyname"},
	{ERR_PACK(0,SYS_F_SOCKET, 0),		"socket"},
	{ERR_PACK(0,SYS_F_IOCTLSOCKET, 0),	"ioctl"},
	{ERR_PACK(0,SYS_F_BIND, 0),		"bind"},
	{ERR_PACK(0,SYS_F_LISTEN, 0),		"listen"},
	{ERR_PACK(0,SYS_F_ACCEPT, 0),		"accept"},
	{ERR_PACK(0,SYS_F_OPENDIR, 0),		"opendir"},
	{ERR_PACK(0,SYS_F_FREAD, 0),		"fread"},
	{0, NULL},
};

static ERR_STRING_DATA ERR_str_reasons[] = {
	{ERR_R_SYS_LIB,				"system lib"},
	{ERR_R_BN_LIB,				"BN lib"},
	{ERR_R_RSA_LIB,				"RSA lib"},
	{ERR_R_DH_LIB,				"DH lib"},
	{ERR_R_EVP_LIB,				"EVP lib"},
	{ERR_R_BUF_LIB,				"BUF lib"},
	{ERR_R_OBJ_LIB,				"OBJ lib"},
	{ERR_R_PEM_LIB,				"PEM lib"},
	{ERR_R_DSA_LIB,				"DSA lib"},
	{ERR_R_X509_LIB,			"X509 lib"},
	{ERR_R_ASN1_LIB,			"ASN1 lib"},
	{ERR_R_CONF_LIB,			"CONF lib"},
	{ERR_R_CRYPTO_LIB,			"CRYPTO lib"},
	{ERR_R_EC_LIB,				"EC lib"},
	{ERR_R_SSL_LIB,				"SSL lib"},
	{ERR_R_BIO_LIB,				"BIO lib"},
	{ERR_R_PKCS7_LIB,			"PKCS7 lib"},
	{ERR_R_X509V3_LIB,			"X509V3 lib"},
	{ERR_R_PKCS12_LIB,			"PKCS12 lib"},
	{ERR_R_RAND_LIB,			"RAND lib"},
	{ERR_R_DSO_LIB,				"DSO lib"},
	{ERR_R_ENGINE_LIB,			"ENGINE lib"},
	{ERR_R_OCSP_LIB,			"OCSP lib"},
	{ERR_R_TS_LIB,				"TS lib"},

	{ERR_R_NESTED_ASN1_ERROR,		"nested asn1 error"},
	{ERR_R_BAD_ASN1_OBJECT_HEADER,		"bad asn1 object header"},
	{ERR_R_BAD_GET_ASN1_OBJECT_CALL,	"bad get asn1 object call"},
	{ERR_R_EXPECTING_AN_ASN1_SEQUENCE,	"expecting an asn1 sequence"},
	{ERR_R_ASN1_LENGTH_MISMATCH,		"asn1 length mismatch"},
	{ERR_R_MISSING_ASN1_EOS,		"missing asn1 eos"},

	{ERR_R_FATAL,				"fatal"},
	{ERR_R_MALLOC_FAILURE,			"malloc failure"},
	{ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED,	"called a function you should not call"},
	{ERR_R_PASSED_NULL_PARAMETER,		"passed a null parameter"},
	{ERR_R_INTERNAL_ERROR,			"internal error"},
	{ERR_R_DISABLED	,			"called a function that was disabled at compile-time"},

	{0, NULL},
};
#endif


/* Define the predeclared (but externally opaque) "ERR_FNS" type */
struct st_ERR_FNS {
	/* Works on the "error_hash" string table */
	LHASH_OF(ERR_STRING_DATA) *(*cb_err_get)(int create);
	void (*cb_err_del)(void);
	ERR_STRING_DATA *(*cb_err_get_item)(const ERR_STRING_DATA *);
	ERR_STRING_DATA *(*cb_err_set_item)(ERR_STRING_DATA *);
	ERR_STRING_DATA *(*cb_err_del_item)(ERR_STRING_DATA *);
	/* Works on the "thread_hash" error-state table */
	LHASH_OF(ERR_STATE) *(*cb_thread_get)(int create);
	void (*cb_thread_release)(LHASH_OF(ERR_STATE) **hash);
	ERR_STATE *(*cb_thread_get_item)(const ERR_STATE *);
	ERR_STATE *(*cb_thread_set_item)(ERR_STATE *);
	void (*cb_thread_del_item)(const ERR_STATE *);
	/* Returns the next available error "library" numbers */
	int (*cb_get_next_lib)(void);
};

/* Predeclarations of the "err_defaults" functions */
static LHASH_OF(ERR_STRING_DATA) *int_err_get(int create);
static void int_err_del(void);
static ERR_STRING_DATA *int_err_get_item(const ERR_STRING_DATA *);
static ERR_STRING_DATA *int_err_set_item(ERR_STRING_DATA *);
static ERR_STRING_DATA *int_err_del_item(ERR_STRING_DATA *);
static LHASH_OF(ERR_STATE) *int_thread_get(int create);
static void int_thread_release(LHASH_OF(ERR_STATE) **hash);
static ERR_STATE *int_thread_get_item(const ERR_STATE *);
static ERR_STATE *int_thread_set_item(ERR_STATE *);
static void int_thread_del_item(const ERR_STATE *);
static int int_err_get_next_lib(void);

/* The static ERR_FNS table using these defaults functions */
static const ERR_FNS err_defaults = {
	int_err_get,
	int_err_del,
	int_err_get_item,
	int_err_set_item,
	int_err_del_item,
	int_thread_get,
	int_thread_release,
	int_thread_get_item,
	int_thread_set_item,
	int_thread_del_item,
	int_err_get_next_lib
};

/* The replacable table of ERR_FNS functions we use at run-time */
static const ERR_FNS *err_fns = NULL;

/* Eg. rather than using "err_get()", use "ERRFN(err_get)()". */
#define ERRFN(a) err_fns->cb_##a

/* The internal state used by "err_defaults" - as such, the setting, reading,
 * creating, and deleting of this data should only be permitted via the
 * "err_defaults" functions. This way, a linked module can completely defer all
 * ERR state operation (together with requisite locking) to the implementations
 * and state in the loading application. */
static LHASH_OF(ERR_STRING_DATA) *int_error_hash = NULL;
static LHASH_OF(ERR_STATE) *int_thread_hash = NULL;
static int int_thread_hash_references = 0;
static int int_err_library_number = ERR_LIB_USER;

/* Internal function that checks whether "err_fns" is set and if not, sets it to
 * the defaults. */
static void
err_fns_check(void)
{
	if (err_fns)
		return;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (!err_fns)
		err_fns = &err_defaults;
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
}

/* API functions to get or set the underlying ERR functions. */

const ERR_FNS *
ERR_get_implementation(void)
{
	err_fns_check();
	return err_fns;
}

int
ERR_set_implementation(const ERR_FNS *fns)
{
	int ret = 0;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	/* It's too late if 'err_fns' is non-NULL. BTW: not much point setting
	 * an error is there?! */
	if (!err_fns) {
		err_fns = fns;
		ret = 1;
	}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	return ret;
}

/* These are the callbacks provided to "lh_new()" when creating the LHASH tables
 * internal to the "err_defaults" implementation. */

static unsigned long get_error_values(int inc, int top, const char **file,
    int *line, const char **data, int *flags);

/* The internal functions used in the "err_defaults" implementation */

static unsigned long
err_string_data_hash(const ERR_STRING_DATA *a)
{
	unsigned long ret, l;

	l = a->error;
	ret = l^ERR_GET_LIB(l)^ERR_GET_FUNC(l);
	return (ret^ret % 19*13);
}
static IMPLEMENT_LHASH_HASH_FN(err_string_data, ERR_STRING_DATA)

static int
err_string_data_cmp(const ERR_STRING_DATA *a, const ERR_STRING_DATA *b)
{
	return (int)(a->error - b->error);
}
static IMPLEMENT_LHASH_COMP_FN(err_string_data, ERR_STRING_DATA)

static
LHASH_OF(ERR_STRING_DATA) *int_err_get(int create)
{
	LHASH_OF(ERR_STRING_DATA) *ret = NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (!int_error_hash && create) {
		CRYPTO_push_info("int_err_get (err.c)");
		int_error_hash = lh_ERR_STRING_DATA_new();
		CRYPTO_pop_info();
	}
	if (int_error_hash)
		ret = int_error_hash;
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return ret;
}

static void
int_err_del(void)
{
	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (int_error_hash) {
		lh_ERR_STRING_DATA_free(int_error_hash);
		int_error_hash = NULL;
	}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
}

static ERR_STRING_DATA *
int_err_get_item(const ERR_STRING_DATA *d)
{
	ERR_STRING_DATA *p;
	LHASH_OF(ERR_STRING_DATA) *hash;

	err_fns_check();
	hash = ERRFN(err_get)(0);
	if (!hash)
		return NULL;

	CRYPTO_r_lock(CRYPTO_LOCK_ERR);
	p = lh_ERR_STRING_DATA_retrieve(hash, d);
	CRYPTO_r_unlock(CRYPTO_LOCK_ERR);

	return p;
}

static ERR_STRING_DATA *
int_err_set_item(ERR_STRING_DATA *d)
{
	ERR_STRING_DATA *p;
	LHASH_OF(ERR_STRING_DATA) *hash;

	err_fns_check();
	hash = ERRFN(err_get)(1);
	if (!hash)
		return NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = lh_ERR_STRING_DATA_insert(hash, d);
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return p;
}

static ERR_STRING_DATA *
int_err_del_item(ERR_STRING_DATA *d)
{
	ERR_STRING_DATA *p;
	LHASH_OF(ERR_STRING_DATA) *hash;

	err_fns_check();
	hash = ERRFN(err_get)(0);
	if (!hash)
		return NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = lh_ERR_STRING_DATA_delete(hash, d);
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return p;
}

static unsigned long
err_state_hash(const ERR_STATE *a)
{
	return CRYPTO_THREADID_hash(&a->tid) * 13;
}
static IMPLEMENT_LHASH_HASH_FN(err_state, ERR_STATE)

static int
err_state_cmp(const ERR_STATE *a, const ERR_STATE *b)
{
	return CRYPTO_THREADID_cmp(&a->tid, &b->tid);
}
static IMPLEMENT_LHASH_COMP_FN(err_state, ERR_STATE)

static
LHASH_OF(ERR_STATE) *int_thread_get(int create)
{
	LHASH_OF(ERR_STATE) *ret = NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (!int_thread_hash && create) {
		CRYPTO_push_info("int_thread_get (err.c)");
		int_thread_hash = lh_ERR_STATE_new();
		CRYPTO_pop_info();
	}
	if (int_thread_hash) {
		int_thread_hash_references++;
		ret = int_thread_hash;
	}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	return ret;
}

static void
int_thread_release(LHASH_OF(ERR_STATE) **hash)
{
	int i;

	if (hash == NULL || *hash == NULL)
		return;

	i = CRYPTO_add(&int_thread_hash_references, -1, CRYPTO_LOCK_ERR);
	if (i > 0)
		return;

	*hash = NULL;
}

static ERR_STATE *
int_thread_get_item(const ERR_STATE *d)
{
	ERR_STATE *p;
	LHASH_OF(ERR_STATE) *hash;

	err_fns_check();
	hash = ERRFN(thread_get)(0);
	if (!hash)
		return NULL;

	CRYPTO_r_lock(CRYPTO_LOCK_ERR);
	p = lh_ERR_STATE_retrieve(hash, d);
	CRYPTO_r_unlock(CRYPTO_LOCK_ERR);

	ERRFN(thread_release)(&hash);
	return p;
}

static ERR_STATE *
int_thread_set_item(ERR_STATE *d)
{
	ERR_STATE *p;
	LHASH_OF(ERR_STATE) *hash;

	err_fns_check();
	hash = ERRFN(thread_get)(1);
	if (!hash)
		return NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = lh_ERR_STATE_insert(hash, d);
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	ERRFN(thread_release)(&hash);
	return p;
}

static void
int_thread_del_item(const ERR_STATE *d)
{
	ERR_STATE *p;
	LHASH_OF(ERR_STATE) *hash;

	err_fns_check();
	hash = ERRFN(thread_get)(0);
	if (!hash)
		return;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = lh_ERR_STATE_delete(hash, d);
	/* make sure we don't leak memory */
	if (int_thread_hash_references == 1 &&
	    int_thread_hash && lh_ERR_STATE_num_items(int_thread_hash) == 0) {
		lh_ERR_STATE_free(int_thread_hash);
		int_thread_hash = NULL;
	}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	ERRFN(thread_release)(&hash);
	if (p)
		ERR_STATE_free(p);
}

static int
int_err_get_next_lib(void)
{
	int ret;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	ret = int_err_library_number++;
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return ret;
}


#ifndef OPENSSL_NO_ERR
#define NUM_SYS_STR_REASONS 127
#define LEN_SYS_STR_REASON 32

static ERR_STRING_DATA SYS_str_reasons[NUM_SYS_STR_REASONS + 1];
/* SYS_str_reasons is filled with copies of strerror() results at
 * initialization.
 * 'errno' values up to 127 should cover all usual errors,
 * others will be displayed numerically by ERR_error_string.
 * It is crucial that we have something for each reason code
 * that occurs in ERR_str_reasons, or bogus reason strings
 * will be returned for SYSerr(), which always gets an errno
 * value and never one of those 'standard' reason codes. */

static void
build_SYS_str_reasons(void)
{
	/* malloc cannot be used here, use static storage instead */
	static char strerror_tab[NUM_SYS_STR_REASONS][LEN_SYS_STR_REASON];
	int i;
	static int init = 1;

	CRYPTO_r_lock(CRYPTO_LOCK_ERR);
	if (!init) {
		CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
		return;
	}

	CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (!init) {
		CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
		return;
	}

	for (i = 1; i <= NUM_SYS_STR_REASONS; i++) {
		ERR_STRING_DATA *str = &SYS_str_reasons[i - 1];

		str->error = (unsigned long)i;
		if (str->string == NULL) {
			char (*dest)[LEN_SYS_STR_REASON] =
			    &(strerror_tab[i - 1]);
			const char *src = strerror(i);
			if (src != NULL) {
				strlcpy(*dest, src, sizeof *dest);
				str->string = *dest;
			}
		}
		if (str->string == NULL)
			str->string = "unknown";
	}

	/* Now we still have SYS_str_reasons[NUM_SYS_STR_REASONS] = {0, NULL},
	 * as required by ERR_load_strings. */

	init = 0;

	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
}
#endif

#define err_clear_data(p,i) \
	do { \
		if (((p)->err_data[i] != NULL) && \
		    (p)->err_data_flags[i] & ERR_TXT_MALLOCED) { \
			free((p)->err_data[i]); \
			(p)->err_data[i] = NULL; \
		} \
		(p)->err_data_flags[i] = 0; \
	} while(0)

#define err_clear(p,i) \
	do { \
		(p)->err_flags[i] = 0; \
		(p)->err_buffer[i] = 0; \
		err_clear_data(p, i); \
		(p)->err_file[i] = NULL; \
		(p)->err_line[i] = -1; \
	} while(0)

static void
ERR_STATE_free(ERR_STATE *s)
{
	int i;

	if (s == NULL)
		return;

	for (i = 0; i < ERR_NUM_ERRORS; i++) {
		err_clear_data(s, i);
	}
	free(s);
}

void
ERR_load_ERR_strings(void)
{
	err_fns_check();
#ifndef OPENSSL_NO_ERR
	err_load_strings(0, ERR_str_libraries);
	err_load_strings(0, ERR_str_reasons);
	err_load_strings(ERR_LIB_SYS, ERR_str_functs);
	build_SYS_str_reasons();
	err_load_strings(ERR_LIB_SYS, SYS_str_reasons);
#endif
}

static void
err_load_strings(int lib, ERR_STRING_DATA *str)
{
	while (str->error) {
		if (lib)
			str->error |= ERR_PACK(lib, 0, 0);
		ERRFN(err_set_item)(str);
		str++;
	}
}

void
ERR_load_strings(int lib, ERR_STRING_DATA *str)
{
	ERR_load_ERR_strings();
	err_load_strings(lib, str);
}

void
ERR_unload_strings(int lib, ERR_STRING_DATA *str)
{
	while (str->error) {
		if (lib)
			str->error |= ERR_PACK(lib, 0, 0);
		ERRFN(err_del_item)(str);
		str++;
	}
}

void
ERR_free_strings(void)
{
	err_fns_check();
	ERRFN(err_del)();
}

/********************************************************/

void
ERR_put_error(int lib, int func, int reason, const char *file, int line)
{
	ERR_STATE *es;
	int save_errno = errno;

	es = ERR_get_state();

	es->top = (es->top + 1) % ERR_NUM_ERRORS;
	if (es->top == es->bottom)
		es->bottom = (es->bottom + 1) % ERR_NUM_ERRORS;
	es->err_flags[es->top] = 0;
	es->err_buffer[es->top] = ERR_PACK(lib, func, reason);
	es->err_file[es->top] = file;
	es->err_line[es->top] = line;
	err_clear_data(es, es->top);
	errno = save_errno;
}

void
ERR_clear_error(void)
{
	int i;
	ERR_STATE *es;

	es = ERR_get_state();

	for (i = 0; i < ERR_NUM_ERRORS; i++) {
		err_clear(es, i);
	}
	es->top = es->bottom = 0;
}


unsigned long
ERR_get_error(void)
{
	return (get_error_values(1, 0, NULL, NULL, NULL, NULL));
}

unsigned long
ERR_get_error_line(const char **file, int *line)
{
	return (get_error_values(1, 0, file, line, NULL, NULL));
}

unsigned long
ERR_get_error_line_data(const char **file, int *line,
    const char **data, int *flags)
{
	return (get_error_values(1, 0, file, line, data, flags));
}


unsigned long
ERR_peek_error(void)
{
	return (get_error_values(0, 0, NULL, NULL, NULL, NULL));
}

unsigned long
ERR_peek_error_line(const char **file, int *line)
{
	return (get_error_values(0, 0, file, line, NULL, NULL));
}

unsigned long
ERR_peek_error_line_data(const char **file, int *line,
    const char **data, int *flags)
{
	return (get_error_values(0, 0, file, line, data, flags));
}

unsigned long
ERR_peek_last_error(void)
{
	return (get_error_values(0, 1, NULL, NULL, NULL, NULL));
}

unsigned long
ERR_peek_last_error_line(const char **file, int *line)
{
	return (get_error_values(0, 1, file, line, NULL, NULL));
}

unsigned long
ERR_peek_last_error_line_data(const char **file, int *line,
    const char **data, int *flags)
{
	return (get_error_values(0, 1, file, line, data, flags));
}

static unsigned long
get_error_values(int inc, int top, const char **file, int *line,
    const char **data, int *flags)
{
	int i = 0;
	ERR_STATE *es;
	unsigned long ret;

	es = ERR_get_state();

	if (inc && top) {
		if (file)
			*file = "";
		if (line)
			*line = 0;
		if (data)
			*data = "";
		if (flags)
			*flags = 0;

		return ERR_R_INTERNAL_ERROR;
	}

	if (es->bottom == es->top)
		return 0;
	if (top)
		i = es->top;			 /* last error */
	else
		i = (es->bottom + 1) % ERR_NUM_ERRORS; /* first error */

	ret = es->err_buffer[i];
	if (inc) {
		es->bottom = i;
		es->err_buffer[i] = 0;
	}

	if ((file != NULL) && (line != NULL)) {
		if (es->err_file[i] == NULL) {
			*file = "NA";
			if (line != NULL)
				*line = 0;
		} else {
			*file = es->err_file[i];
			if (line != NULL)
				*line = es->err_line[i];
		}
	}

	if (data == NULL) {
		if (inc) {
			err_clear_data(es, i);
		}
	} else {
		if (es->err_data[i] == NULL) {
			*data = "";
			if (flags != NULL)
				*flags = 0;
		} else {
			*data = es->err_data[i];
			if (flags != NULL)
				*flags = es->err_data_flags[i];
		}
	}
	return ret;
}

void
ERR_error_string_n(unsigned long e, char *buf, size_t len)
{
	char lsbuf[30], fsbuf[30], rsbuf[30];
	const char *ls, *fs, *rs;
	int l, f, r, ret;

	l = ERR_GET_LIB(e);
	f = ERR_GET_FUNC(e);
	r = ERR_GET_REASON(e);

	ls = ERR_lib_error_string(e);
	fs = ERR_func_error_string(e);
	rs = ERR_reason_error_string(e);

	if (ls == NULL) {
		(void) snprintf(lsbuf, sizeof(lsbuf), "lib(%d)", l);
		ls = lsbuf;
	}
	if (fs == NULL) {
		(void) snprintf(fsbuf, sizeof(fsbuf), "func(%d)", f);
		fs = fsbuf;
	}
	if (rs == NULL) {
		(void) snprintf(rsbuf, sizeof(rsbuf), "reason(%d)", r);
		rs = rsbuf;
	}

	ret = snprintf(buf, len, "error:%08lX:%s:%s:%s", e, ls, fs, rs);
	if (ret == -1)
		return;	/* can't happen, and can't do better if it does */
	if (ret >= len) {
		/* output may be truncated; make sure we always have 5
		 * colon-separated fields, i.e. 4 colons ... */
#define NUM_COLONS 4
		if (len > NUM_COLONS) /* ... if possible */
		{
			int i;
			char *s = buf;

			for (i = 0; i < NUM_COLONS; i++) {
				char *colon = strchr(s, ':');
				if (colon == NULL ||
				    colon > &buf[len - 1] - NUM_COLONS + i) {
					/* set colon no. i at last possible position
					 * (buf[len-1] is the terminating 0)*/
					colon = &buf[len - 1] - NUM_COLONS + i;
					*colon = ':';
				}
				s = colon + 1;
			}
		}
	}
}

/* BAD for multi-threading: uses a local buffer if ret == NULL */
/* ERR_error_string_n should be used instead for ret != NULL
 * as ERR_error_string cannot know how large the buffer is */
char *
ERR_error_string(unsigned long e, char *ret)
{
	static char buf[256];

	if (ret == NULL)
		ret = buf;
	ERR_error_string_n(e, ret, 256);

	return ret;
}

LHASH_OF(ERR_STRING_DATA) *ERR_get_string_table(void)
{
	err_fns_check();
	return ERRFN(err_get)(0);
}

LHASH_OF(ERR_STATE) *ERR_get_err_state_table(void)
{
	err_fns_check();
	return ERRFN(thread_get)(0);
}

void
ERR_release_err_state_table(LHASH_OF(ERR_STATE) **hash)
{
	err_fns_check();
	ERRFN(thread_release)(hash);
}

const char *
ERR_lib_error_string(unsigned long e)
{
	ERR_STRING_DATA d, *p;
	unsigned long l;

	err_fns_check();
	l = ERR_GET_LIB(e);
	d.error = ERR_PACK(l, 0, 0);
	p = ERRFN(err_get_item)(&d);
	return ((p == NULL) ? NULL : p->string);
}

const char *
ERR_func_error_string(unsigned long e)
{
	ERR_STRING_DATA d, *p;
	unsigned long l, f;

	err_fns_check();
	l = ERR_GET_LIB(e);
	f = ERR_GET_FUNC(e);
	d.error = ERR_PACK(l, f, 0);
	p = ERRFN(err_get_item)(&d);
	return ((p == NULL) ? NULL : p->string);
}

const char *
ERR_reason_error_string(unsigned long e)
{
	ERR_STRING_DATA d, *p = NULL;
	unsigned long l, r;

	err_fns_check();
	l = ERR_GET_LIB(e);
	r = ERR_GET_REASON(e);
	d.error = ERR_PACK(l, 0, r);
	p = ERRFN(err_get_item)(&d);
	if (!p) {
		d.error = ERR_PACK(0, 0, r);
		p = ERRFN(err_get_item)(&d);
	}
	return ((p == NULL) ? NULL : p->string);
}

void
ERR_remove_thread_state(const CRYPTO_THREADID *id)
{
	ERR_STATE tmp;

	if (id)
		CRYPTO_THREADID_cpy(&tmp.tid, id);
	else
		CRYPTO_THREADID_current(&tmp.tid);
	err_fns_check();
	/* thread_del_item automatically destroys the LHASH if the number of
	 * items reaches zero. */
	ERRFN(thread_del_item)(&tmp);
}

#ifndef OPENSSL_NO_DEPRECATED
void
ERR_remove_state(unsigned long pid)
{
	ERR_remove_thread_state(NULL);
}
#endif

ERR_STATE *
ERR_get_state(void)
{
	static ERR_STATE fallback;
	ERR_STATE *ret, tmp, *tmpp = NULL;
	int i;
	CRYPTO_THREADID tid;

	err_fns_check();
	CRYPTO_THREADID_current(&tid);
	CRYPTO_THREADID_cpy(&tmp.tid, &tid);
	ret = ERRFN(thread_get_item)(&tmp);

	/* ret == the error state, if NULL, make a new one */
	if (ret == NULL) {
		ret = malloc(sizeof(ERR_STATE));
		if (ret == NULL)
			return (&fallback);
		CRYPTO_THREADID_cpy(&ret->tid, &tid);
		ret->top = 0;
		ret->bottom = 0;
		for (i = 0; i < ERR_NUM_ERRORS; i++) {
			ret->err_data[i] = NULL;
			ret->err_data_flags[i] = 0;
		}
		tmpp = ERRFN(thread_set_item)(ret);
		/* To check if insertion failed, do a get. */
		if (ERRFN(thread_get_item)(ret) != ret) {
			ERR_STATE_free(ret); /* could not insert it */
			return (&fallback);
		}
		/* If a race occured in this function and we came second, tmpp
		 * is the first one that we just replaced. */
		if (tmpp)
			ERR_STATE_free(tmpp);
	}
	return ret;
}

int
ERR_get_next_error_library(void)
{
	err_fns_check();
	return ERRFN(get_next_lib)();
}

void
ERR_set_error_data(char *data, int flags)
{
	ERR_STATE *es;
	int i;

	es = ERR_get_state();

	i = es->top;
	if (i == 0)
		i = ERR_NUM_ERRORS - 1;

	err_clear_data(es, i);
	es->err_data[i] = data;
	es->err_data_flags[i] = flags;
}

void
ERR_asprintf_error_data(char * format, ...) {
	char *errbuf = NULL;
	va_list ap;
	int r;

	va_start(ap, format);
	r = vasprintf(&errbuf, format, ap);
	va_end(ap);
	if (r == -1)
		ERR_set_error_data("malloc failed", ERR_TXT_STRING);
	else
		ERR_set_error_data(errbuf, ERR_TXT_MALLOCED|ERR_TXT_STRING);
}
void
ERR_add_error_data(int num, ...)
{
	va_list args;
	va_start(args, num);
	ERR_add_error_vdata(num, args);
	va_end(args);
}

void
ERR_add_error_vdata(int num, va_list args)
{
	char format[129];
	char *errbuf;
	int i;

	format[0] = '\0';
	for (i = 0; i < num; i++) {
		if (strlcat(format, "%s", sizeof(format)) >= sizeof(format)) {
			ERR_set_error_data("too many errors", ERR_TXT_STRING);
			return;
		}
	}
	if (vasprintf(&errbuf, format, args) == -1)
		ERR_set_error_data("malloc failed", ERR_TXT_STRING);
	else
		ERR_set_error_data(errbuf, ERR_TXT_MALLOCED|ERR_TXT_STRING);
}

int
ERR_set_mark(void)
{
	ERR_STATE *es;

	es = ERR_get_state();

	if (es->bottom == es->top)
		return 0;
	es->err_flags[es->top] |= ERR_FLAG_MARK;
	return 1;
}

int
ERR_pop_to_mark(void)
{
	ERR_STATE *es;

	es = ERR_get_state();

	while (es->bottom != es->top &&
	    (es->err_flags[es->top] & ERR_FLAG_MARK) == 0) {
		err_clear(es, es->top);
		es->top -= 1;
		if (es->top == -1)
			es->top = ERR_NUM_ERRORS - 1;
	}

	if (es->bottom == es->top)
		return 0;
	es->err_flags[es->top]&=~ERR_FLAG_MARK;
	return 1;
}
@


1.40
log
@compile with c89 (code / decl ordering); from Joakim.Tjernlund@@transmode.se
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: err.c,v 1.39 2014/08/24 16:11:39 bcook Exp $ */
d160 1
@


1.39
log
@constify strerror return value

There is no intention to modify the string returned by strerror and
doing so is forbidden by the standard.

from Jonas 'Sortie' Termansen

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: err.c,v 1.38 2014/07/11 08:44:48 jsing Exp $ */
d1108 2
a1110 1
	int i;
@


1.38
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: err.c,v 1.37 2014/07/10 22:45:57 jsing Exp $ */
d599 1
a599 1
			char *src = strerror(i);
@


1.37
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: err.c,v 1.36 2014/06/27 07:01:21 deraadt Exp $ */
d118 2
a119 2
#include "cryptlib.h"
#include <openssl/lhash.h>
a120 2
#include <openssl/buffer.h>
#include <openssl/bio.h>
d122 1
@


1.36
log
@save_errno botch; spotted by miod
@
text
@d1 1
a1 1
/* $OpenBSD: err.c,v 1.35 2014/06/27 06:07:01 deraadt Exp $ */
d112 1
a113 1
#include <stdarg.h>
d115 3
@


1.35
log
@hand-KNF the remaining bits
@
text
@d1 1
a1 1
/* $OpenBSD: err.c,v 1.34 2014/06/26 15:24:08 deraadt Exp $ */
d716 1
a716 1
	save_errno = errno;
@


1.34
log
@save errno in ERR_put_error(), so that SYSerr doesn't have any accidental
cases where errno can be trashed.
ok jsing
@
text
@d1 1
a1 1
/* $OpenBSD: err.c,v 1.33 2014/06/12 15:49:29 deraadt Exp $ */
d130 28
a157 28
	{ERR_PACK(ERR_LIB_NONE,0,0)		, "unknown library"},
	{ERR_PACK(ERR_LIB_SYS,0,0)		, "system library"},
	{ERR_PACK(ERR_LIB_BN,0,0)		, "bignum routines"},
	{ERR_PACK(ERR_LIB_RSA,0,0)		, "rsa routines"},
	{ERR_PACK(ERR_LIB_DH,0,0)		, "Diffie-Hellman routines"},
	{ERR_PACK(ERR_LIB_EVP,0,0)		, "digital envelope routines"},
	{ERR_PACK(ERR_LIB_BUF,0,0)		, "memory buffer routines"},
	{ERR_PACK(ERR_LIB_OBJ,0,0)		, "object identifier routines"},
	{ERR_PACK(ERR_LIB_PEM,0,0)		, "PEM routines"},
	{ERR_PACK(ERR_LIB_DSA,0,0)		, "dsa routines"},
	{ERR_PACK(ERR_LIB_X509,0,0)		, "x509 certificate routines"},
	{ERR_PACK(ERR_LIB_ASN1,0,0)		, "asn1 encoding routines"},
	{ERR_PACK(ERR_LIB_CONF,0,0)		, "configuration file routines"},
	{ERR_PACK(ERR_LIB_CRYPTO,0,0)		, "common libcrypto routines"},
	{ERR_PACK(ERR_LIB_EC,0,0)		, "elliptic curve routines"},
	{ERR_PACK(ERR_LIB_SSL,0,0)		, "SSL routines"},
	{ERR_PACK(ERR_LIB_BIO,0,0)		, "BIO routines"},
	{ERR_PACK(ERR_LIB_PKCS7,0,0)		, "PKCS7 routines"},
	{ERR_PACK(ERR_LIB_X509V3,0,0)		, "X509 V3 routines"},
	{ERR_PACK(ERR_LIB_PKCS12,0,0)		, "PKCS12 routines"},
	{ERR_PACK(ERR_LIB_RAND,0,0)		, "random number generator"},
	{ERR_PACK(ERR_LIB_DSO,0,0)		, "DSO support routines"},
	{ERR_PACK(ERR_LIB_TS,0,0)		, "time stamp routines"},
	{ERR_PACK(ERR_LIB_ENGINE,0,0)		, "engine routines"},
	{ERR_PACK(ERR_LIB_OCSP,0,0)		, "OCSP routines"},
	{ERR_PACK(ERR_LIB_FIPS,0,0)		, "FIPS routines"},
	{ERR_PACK(ERR_LIB_CMS,0,0)		, "CMS routines"},
	{ERR_PACK(ERR_LIB_HMAC,0,0)		, "HMAC routines"},
d176 38
a213 38
	{ERR_R_SYS_LIB				, "system lib"},
	{ERR_R_BN_LIB				, "BN lib"},
	{ERR_R_RSA_LIB				, "RSA lib"},
	{ERR_R_DH_LIB				, "DH lib"},
	{ERR_R_EVP_LIB				, "EVP lib"},
	{ERR_R_BUF_LIB				, "BUF lib"},
	{ERR_R_OBJ_LIB				, "OBJ lib"},
	{ERR_R_PEM_LIB				, "PEM lib"},
	{ERR_R_DSA_LIB				, "DSA lib"},
	{ERR_R_X509_LIB				, "X509 lib"},
	{ERR_R_ASN1_LIB				, "ASN1 lib"},
	{ERR_R_CONF_LIB				, "CONF lib"},
	{ERR_R_CRYPTO_LIB			, "CRYPTO lib"},
	{ERR_R_EC_LIB				, "EC lib"},
	{ERR_R_SSL_LIB				, "SSL lib"},
	{ERR_R_BIO_LIB				, "BIO lib"},
	{ERR_R_PKCS7_LIB			, "PKCS7 lib"},
	{ERR_R_X509V3_LIB			, "X509V3 lib"},
	{ERR_R_PKCS12_LIB			, "PKCS12 lib"},
	{ERR_R_RAND_LIB				, "RAND lib"},
	{ERR_R_DSO_LIB				, "DSO lib"},
	{ERR_R_ENGINE_LIB			, "ENGINE lib"},
	{ERR_R_OCSP_LIB				, "OCSP lib"},
	{ERR_R_TS_LIB				, "TS lib"},

	{ERR_R_NESTED_ASN1_ERROR		, "nested asn1 error"},
	{ERR_R_BAD_ASN1_OBJECT_HEADER		, "bad asn1 object header"},
	{ERR_R_BAD_GET_ASN1_OBJECT_CALL		, "bad get asn1 object call"},
	{ERR_R_EXPECTING_AN_ASN1_SEQUENCE	, "expecting an asn1 sequence"},
	{ERR_R_ASN1_LENGTH_MISMATCH		, "asn1 length mismatch"},
	{ERR_R_MISSING_ASN1_EOS			, "missing asn1 eos"},

	{ERR_R_FATAL                            , "fatal"},
	{ERR_R_MALLOC_FAILURE			, "malloc failure"},
	{ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED	, "called a function you should not call"},
	{ERR_R_PASSED_NULL_PARAMETER		, "passed a null parameter"},
	{ERR_R_INTERNAL_ERROR			, "internal error"},
	{ERR_R_DISABLED				, "called a function that was disabled at compile-time"},
d618 4
a621 5
	if (((p)->err_data[i] != NULL) && \
		(p)->err_data_flags[i] & ERR_TXT_MALLOCED) \
		{  \
		free((p)->err_data[i]); \
		(p)->err_data[i]=NULL; \
d623 1
a623 1
	(p)->err_data_flags[i]=0; \
d628 5
a632 5
	(p)->err_flags[i]=0; \
	(p)->err_buffer[i]=0; \
	err_clear_data(p,i); \
	(p)->err_file[i]=NULL; \
	(p)->err_line[i]= -1; \
d734 2
a735 1
unsigned long ERR_get_error(void)
d737 1
a737 1
	return (get_error_values(1, 0,NULL, NULL, NULL, NULL));
d740 2
a741 1
unsigned long ERR_get_error_line(const char **file, int *line)
d743 1
a743 1
	return (get_error_values(1, 0,file, line, NULL, NULL));
d746 2
a747 1
unsigned long ERR_get_error_line_data(const char **file, int *line,
d750 1
a750 1
	return (get_error_values(1, 0,file, line, data, flags));
d754 2
a755 1
unsigned long ERR_peek_error(void)
d757 1
a757 1
	return (get_error_values(0, 0,NULL, NULL, NULL, NULL));
d760 2
a761 1
unsigned long ERR_peek_error_line(const char **file, int *line)
d763 1
a763 1
	return (get_error_values(0, 0,file, line, NULL, NULL));
d766 2
a767 1
unsigned long ERR_peek_error_line_data(const char **file, int *line,
d770 1
a770 1
	return (get_error_values(0, 0,file, line, data, flags));
d773 2
a774 1
unsigned long ERR_peek_last_error(void)
d776 1
a776 1
	return (get_error_values(0, 1,NULL, NULL, NULL, NULL));
d779 2
a780 1
unsigned long ERR_peek_last_error_line(const char **file, int *line)
d782 1
a782 1
	return (get_error_values(0, 1,file, line, NULL, NULL));
d785 2
a786 1
unsigned long ERR_peek_last_error_line_data(const char **file, int *line,
d789 1
a789 1
	return (get_error_values(0, 1,file, line, data, flags));
d792 2
a793 2
static unsigned
long get_error_values(int inc, int top, const char **file, int *line,
@


1.33
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d705 1
d717 1
@


1.32
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* crypto/err/err.c */
@


1.31
log
@No OPENSSL_SYS_WINDOWS wanted.

ok miod@@
@
text
@d1020 1
a1020 1
		ret = (ERR_STATE *)malloc(sizeof(ERR_STATE));
@


1.30
log
@add ERR_asprintf_error_data, A tool to be used to get rid of the far too
frequent construct of 30 lines of pointer and strlcat insanity followed
by an ERR_add_error_data. I will sweep through here like a chubby mongol
horde in the next few days pillaging crappy ERR_add_error_data's.
Oh and while we're at it fix the nasty vdata function to use something less
hard on the eyes.
ok jsing@@
@
text
@a169 3
#ifdef OPENSSL_SYS_WINDOWS
	{ERR_PACK(0,SYS_F_WSASTARTUP, 0),	"WSAstartup"},
#endif
@


1.29
log
@KNF.
@
text
@d1072 14
d1097 4
a1100 10
	int i, n, s;
	char *str, *p, *a;

	s = 80;
	str = malloc(s + 1);
	if (str == NULL)
		return;
	str[0] = '\0';

	n = 0;
d1102 3
a1104 14
		a = va_arg(args, char*);
		/* ignore NULLs, thanks to Bob Beck <beck@@obtuse.com> */
		if (a != NULL) {
			n += strlen(a);
			if (n > s) {
				s = n + 20;
				p = realloc(str, s + 1);
				if (p == NULL) {
					free(str);
					return;
				} else
					str = p;
			}
			strlcat(str, a, (size_t)s + 1);
d1107 4
a1110 1
	ERR_set_error_data(str, ERR_TXT_MALLOCED|ERR_TXT_STRING);
@


1.28
log
@Chop off more SSLv2 tentacles and start fixing and noting y2038 issues.
APIs that pass times as longs will have to change at some point...
Bump major on both libcrypto and libssl.

ok tedu@@
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d129 41
a169 43
static ERR_STRING_DATA ERR_str_libraries[]=
	{
{ERR_PACK(ERR_LIB_NONE,0,0)		,"unknown library"},
{ERR_PACK(ERR_LIB_SYS,0,0)		,"system library"},
{ERR_PACK(ERR_LIB_BN,0,0)		,"bignum routines"},
{ERR_PACK(ERR_LIB_RSA,0,0)		,"rsa routines"},
{ERR_PACK(ERR_LIB_DH,0,0)		,"Diffie-Hellman routines"},
{ERR_PACK(ERR_LIB_EVP,0,0)		,"digital envelope routines"},
{ERR_PACK(ERR_LIB_BUF,0,0)		,"memory buffer routines"},
{ERR_PACK(ERR_LIB_OBJ,0,0)		,"object identifier routines"},
{ERR_PACK(ERR_LIB_PEM,0,0)		,"PEM routines"},
{ERR_PACK(ERR_LIB_DSA,0,0)		,"dsa routines"},
{ERR_PACK(ERR_LIB_X509,0,0)		,"x509 certificate routines"},
{ERR_PACK(ERR_LIB_ASN1,0,0)		,"asn1 encoding routines"},
{ERR_PACK(ERR_LIB_CONF,0,0)		,"configuration file routines"},
{ERR_PACK(ERR_LIB_CRYPTO,0,0)		,"common libcrypto routines"},
{ERR_PACK(ERR_LIB_EC,0,0)		,"elliptic curve routines"},
{ERR_PACK(ERR_LIB_SSL,0,0)		,"SSL routines"},
{ERR_PACK(ERR_LIB_BIO,0,0)		,"BIO routines"},
{ERR_PACK(ERR_LIB_PKCS7,0,0)		,"PKCS7 routines"},
{ERR_PACK(ERR_LIB_X509V3,0,0)		,"X509 V3 routines"},
{ERR_PACK(ERR_LIB_PKCS12,0,0)		,"PKCS12 routines"},
{ERR_PACK(ERR_LIB_RAND,0,0)		,"random number generator"},
{ERR_PACK(ERR_LIB_DSO,0,0)		,"DSO support routines"},
{ERR_PACK(ERR_LIB_TS,0,0)		,"time stamp routines"},
{ERR_PACK(ERR_LIB_ENGINE,0,0)		,"engine routines"},
{ERR_PACK(ERR_LIB_OCSP,0,0)		,"OCSP routines"},
{ERR_PACK(ERR_LIB_FIPS,0,0)		,"FIPS routines"},
{ERR_PACK(ERR_LIB_CMS,0,0)		,"CMS routines"},
{ERR_PACK(ERR_LIB_HMAC,0,0)		,"HMAC routines"},
{0,NULL},
	};

static ERR_STRING_DATA ERR_str_functs[]=
	{
	{ERR_PACK(0,SYS_F_FOPEN,0),     	"fopen"},
	{ERR_PACK(0,SYS_F_CONNECT,0),		"connect"},
	{ERR_PACK(0,SYS_F_GETSERVBYNAME,0),	"getservbyname"},
	{ERR_PACK(0,SYS_F_SOCKET,0),		"socket"}, 
	{ERR_PACK(0,SYS_F_IOCTLSOCKET,0),	"ioctl"},
	{ERR_PACK(0,SYS_F_BIND,0),		"bind"},
	{ERR_PACK(0,SYS_F_LISTEN,0),		"listen"},
	{ERR_PACK(0,SYS_F_ACCEPT,0),		"accept"},
d171 1
a171 1
	{ERR_PACK(0,SYS_F_WSASTARTUP,0),	"WSAstartup"},
d173 44
a216 45
	{ERR_PACK(0,SYS_F_OPENDIR,0),		"opendir"},
	{ERR_PACK(0,SYS_F_FREAD,0),		"fread"},
	{0,NULL},
	};

static ERR_STRING_DATA ERR_str_reasons[]=
	{
{ERR_R_SYS_LIB				,"system lib"},
{ERR_R_BN_LIB				,"BN lib"},
{ERR_R_RSA_LIB				,"RSA lib"},
{ERR_R_DH_LIB				,"DH lib"},
{ERR_R_EVP_LIB				,"EVP lib"},
{ERR_R_BUF_LIB				,"BUF lib"},
{ERR_R_OBJ_LIB				,"OBJ lib"},
{ERR_R_PEM_LIB				,"PEM lib"},
{ERR_R_DSA_LIB				,"DSA lib"},
{ERR_R_X509_LIB				,"X509 lib"},
{ERR_R_ASN1_LIB				,"ASN1 lib"},
{ERR_R_CONF_LIB				,"CONF lib"},
{ERR_R_CRYPTO_LIB			,"CRYPTO lib"},
{ERR_R_EC_LIB				,"EC lib"},
{ERR_R_SSL_LIB				,"SSL lib"},
{ERR_R_BIO_LIB				,"BIO lib"},
{ERR_R_PKCS7_LIB			,"PKCS7 lib"},
{ERR_R_X509V3_LIB			,"X509V3 lib"},
{ERR_R_PKCS12_LIB			,"PKCS12 lib"},
{ERR_R_RAND_LIB				,"RAND lib"},
{ERR_R_DSO_LIB				,"DSO lib"},
{ERR_R_ENGINE_LIB			,"ENGINE lib"},
{ERR_R_OCSP_LIB				,"OCSP lib"},
{ERR_R_TS_LIB				,"TS lib"},

{ERR_R_NESTED_ASN1_ERROR		,"nested asn1 error"},
{ERR_R_BAD_ASN1_OBJECT_HEADER		,"bad asn1 object header"},
{ERR_R_BAD_GET_ASN1_OBJECT_CALL		,"bad get asn1 object call"},
{ERR_R_EXPECTING_AN_ASN1_SEQUENCE	,"expecting an asn1 sequence"},
{ERR_R_ASN1_LENGTH_MISMATCH		,"asn1 length mismatch"},
{ERR_R_MISSING_ASN1_EOS			,"missing asn1 eos"},

{ERR_R_FATAL                            ,"fatal"},
{ERR_R_MALLOC_FAILURE			,"malloc failure"},
{ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED	,"called a function you should not call"},
{ERR_R_PASSED_NULL_PARAMETER		,"passed a null parameter"},
{ERR_R_INTERNAL_ERROR			,"internal error"},
{ERR_R_DISABLED				,"called a function that was disabled at compile-time"},
d218 2
a219 2
{0,NULL},
	};
d224 1
a224 2
struct st_ERR_FNS
	{
d239 1
a239 1
	};
d253 1
d255 1
a255 2
static const ERR_FNS err_defaults =
	{
d267 1
a267 1
	};
d283 1
a283 1
static int int_err_library_number= ERR_LIB_USER;
d287 6
a292 4
static void err_fns_check(void)
	{
	if (err_fns) return;
	
d297 1
a297 1
	}
d301 3
a303 2
const ERR_FNS *ERR_get_implementation(void)
	{
d306 1
a306 1
	}
d308 3
a310 2
int ERR_set_implementation(const ERR_FNS *fns)
	{
d316 1
a316 2
	if (!err_fns)
		{
d319 1
a319 1
		}
d322 1
a322 1
	}
d327 2
a328 2
static unsigned long get_error_values(int inc,int top,const char **file,int *line,
				      const char **data,int *flags);
d332 9
a340 8
static unsigned long err_string_data_hash(const ERR_STRING_DATA *a)
	{
	unsigned long ret,l;

	l=a->error;
	ret=l^ERR_GET_LIB(l)^ERR_GET_FUNC(l);
	return(ret^ret%19*13);
	}
d343 3
a345 3
static int err_string_data_cmp(const ERR_STRING_DATA *a,
			       const ERR_STRING_DATA *b)
	{
d347 1
a347 1
	}
d350 3
a352 2
static LHASH_OF(ERR_STRING_DATA) *int_err_get(int create)
	{
d356 1
a356 2
	if (!int_error_hash && create)
		{
d360 1
a360 1
		}
d366 1
a366 1
	}
d368 3
a370 2
static void int_err_del(void)
	{
d372 1
a372 2
	if (int_error_hash)
		{
d375 1
a375 1
		}
d377 1
a377 1
	}
d379 3
a381 2
static ERR_STRING_DATA *int_err_get_item(const ERR_STRING_DATA *d)
	{
d395 1
a395 1
	}
d397 3
a399 2
static ERR_STRING_DATA *int_err_set_item(ERR_STRING_DATA *d)
	{
d413 1
a413 1
	}
d415 3
a417 2
static ERR_STRING_DATA *int_err_del_item(ERR_STRING_DATA *d)
	{
d431 1
a431 1
	}
d433 3
a435 2
static unsigned long err_state_hash(const ERR_STATE *a)
	{
d437 1
a437 1
	}
d440 3
a442 2
static int err_state_cmp(const ERR_STATE *a, const ERR_STATE *b)
	{
d444 1
a444 1
	}
d447 3
a449 2
static LHASH_OF(ERR_STATE) *int_thread_get(int create)
	{
d453 1
a453 2
	if (!int_thread_hash && create)
		{
d457 2
a458 3
		}
	if (int_thread_hash)
		{
d461 1
a461 1
		}
d464 1
a464 1
	}
d466 3
a468 2
static void int_thread_release(LHASH_OF(ERR_STATE) **hash)
	{
d475 2
a476 1
	if (i > 0) return;
d479 1
a479 1
	}
d481 3
a483 2
static ERR_STATE *int_thread_get_item(const ERR_STATE *d)
	{
d498 1
a498 1
	}
d500 3
a502 2
static ERR_STATE *int_thread_set_item(ERR_STATE *d)
	{
d517 1
a517 1
	}
d519 3
a521 2
static void int_thread_del_item(const ERR_STATE *d)
	{
d533 2
a534 3
	if (int_thread_hash_references == 1
	    && int_thread_hash && lh_ERR_STATE_num_items(int_thread_hash) == 0)
		{
d537 1
a537 1
		}
d543 1
a543 1
	}
d545 3
a547 2
static int int_err_get_next_lib(void)
	{
d555 1
a555 1
	}
d572 3
a574 2
static void build_SYS_str_reasons(void)
	{
d581 1
a581 2
	if (!init)
		{
d584 2
a585 2
		}
	
d588 1
a588 2
	if (!init)
		{
d591 1
a591 1
		}
d593 1
a593 2
	for (i = 1; i <= NUM_SYS_STR_REASONS; i++)
		{
d597 3
a599 3
		if (str->string == NULL)
			{
			char (*dest)[LEN_SYS_STR_REASON] = &(strerror_tab[i - 1]);
d601 1
a601 2
			if (src != NULL)
				{
a603 1
				}
d605 1
d608 1
a608 1
		}
d614 1
a614 1
	
d616 1
a616 1
	}
d639 3
a641 2
static void ERR_STATE_free(ERR_STATE *s)
	{
d645 1
a645 1
	    return;
d647 3
a649 4
	for (i=0; i<ERR_NUM_ERRORS; i++)
		{
		err_clear_data(s,i);
		}
d651 1
a651 1
	}
d653 3
a655 2
void ERR_load_ERR_strings(void)
	{
d658 3
a660 3
	err_load_strings(0,ERR_str_libraries);
	err_load_strings(0,ERR_str_reasons);
	err_load_strings(ERR_LIB_SYS,ERR_str_functs);
d662 1
a662 1
	err_load_strings(ERR_LIB_SYS,SYS_str_reasons);
d664 1
a664 1
	}
d666 4
a669 4
static void err_load_strings(int lib, ERR_STRING_DATA *str)
	{
	while (str->error)
		{
d671 1
a671 1
			str->error|=ERR_PACK(lib,0,0);
a673 1
		}
d675 1
d677 3
a679 2
void ERR_load_strings(int lib, ERR_STRING_DATA *str)
	{
d682 1
a682 1
	}
d684 4
a687 4
void ERR_unload_strings(int lib, ERR_STRING_DATA *str)
	{
	while (str->error)
		{
d689 1
a689 1
			str->error|=ERR_PACK(lib,0,0);
a691 1
		}
d693 1
d695 3
a697 2
void ERR_free_strings(void)
	{
d700 1
a700 1
	}
d704 3
a706 3
void ERR_put_error(int lib, int func, int reason, const char *file,
	     int line)
	{
d709 1
a709 1
	es=ERR_get_state();
d711 1
a711 1
	es->top=(es->top+1)%ERR_NUM_ERRORS;
d713 11
a723 10
		es->bottom=(es->bottom+1)%ERR_NUM_ERRORS;
	es->err_flags[es->top]=0;
	es->err_buffer[es->top]=ERR_PACK(lib,func,reason);
	es->err_file[es->top]=file;
	es->err_line[es->top]=line;
	err_clear_data(es,es->top);
	}

void ERR_clear_error(void)
	{
d727 1
a727 1
	es=ERR_get_state();
d729 2
a730 5
	for (i=0; i<ERR_NUM_ERRORS; i++)
		{
		err_clear(es,i);
		}
	es->top=es->bottom=0;
d732 2
d737 8
a744 5
	{ return(get_error_values(1,0,NULL,NULL,NULL,NULL)); }

unsigned long ERR_get_error_line(const char **file,
	     int *line)
	{ return(get_error_values(1,0,file,line,NULL,NULL)); }
d747 4
a750 2
	     const char **data, int *flags)
	{ return(get_error_values(1,0,file,line,data,flags)); }
d754 3
a756 1
	{ return(get_error_values(0,0,NULL,NULL,NULL,NULL)); }
d759 3
a761 1
	{ return(get_error_values(0,0,file,line,NULL,NULL)); }
d764 4
a767 3
	     const char **data, int *flags)
	{ return(get_error_values(0,0,file,line,data,flags)); }

d770 3
a772 1
	{ return(get_error_values(0,1,NULL,NULL,NULL,NULL)); }
d775 3
a777 1
	{ return(get_error_values(0,1,file,line,NULL,NULL)); }
d780 10
a789 8
	     const char **data, int *flags)
	{ return(get_error_values(0,1,file,line,data,flags)); }


static unsigned long get_error_values(int inc, int top, const char **file, int *line,
	     const char **data, int *flags)
	{	
	int i=0;
d793 11
a803 1
	es=ERR_get_state();
a804 7
	if (inc && top)
		{
		if (file) *file = "";
		if (line) *line = 0;
		if (data) *data = "";
		if (flags) *flags = 0;
			
d806 1
a806 1
		}
d808 2
a809 1
	if (es->bottom == es->top) return 0;
d811 1
a811 1
		i=es->top;			 /* last error */
d813 1
a813 1
		i=(es->bottom+1)%ERR_NUM_ERRORS; /* first error */
d815 5
a819 6
	ret=es->err_buffer[i];
	if (inc)
		{
		es->bottom=i;
		es->err_buffer[i]=0;
		}
d821 9
a829 12
	if ((file != NULL) && (line != NULL))
		{
		if (es->err_file[i] == NULL)
			{
			*file="NA";
			if (line != NULL) *line=0;
			}
		else
			{
			*file=es->err_file[i];
			if (line != NULL) *line=es->err_line[i];
			}
d831 1
d833 2
a834 4
	if (data == NULL)
		{
		if (inc)
			{
a835 1
			}
d837 9
a845 12
	else
		{
		if (es->err_data[i] == NULL)
			{
			*data="";
			if (flags != NULL) *flags=0;
			}
		else
			{
			*data=es->err_data[i];
			if (flags != NULL) *flags=es->err_data_flags[i];
			}
d847 1
d849 1
a849 1
	}
d851 3
a853 2
void ERR_error_string_n(unsigned long e, char *buf, size_t len)
	{
d855 1
a855 1
	const char *ls,*fs,*rs;
d858 7
a864 7
	l=ERR_GET_LIB(e);
	f=ERR_GET_FUNC(e);
	r=ERR_GET_REASON(e);

	ls=ERR_lib_error_string(e);
	fs=ERR_func_error_string(e);
	rs=ERR_reason_error_string(e);
d882 2
a883 3
	if (ret >= len)
		{
		/* output may be truncated; make sure we always have 5 
d887 1
a887 1
			{
d890 2
a891 3
			
			for (i = 0; i < NUM_COLONS; i++)
				{
d893 2
a894 2
				if (colon == NULL || colon > &buf[len-1] - NUM_COLONS + i)
					{
d897 1
a897 1
					colon = &buf[len-1] - NUM_COLONS + i;
d899 1
a899 1
					}
a900 1
				}
d904 1
d909 3
a911 2
char *ERR_error_string(unsigned long e, char *ret)
	{
d914 2
a915 1
	if (ret == NULL) ret=buf;
d919 1
a919 1
	}
d922 1
a922 1
	{
d925 1
a925 1
	}
d928 1
a928 1
	{
d931 1
a931 1
	}
d933 3
a935 2
void ERR_release_err_state_table(LHASH_OF(ERR_STATE) **hash)
	{
d938 1
a938 1
	}
d940 4
a943 3
const char *ERR_lib_error_string(unsigned long e)
	{
	ERR_STRING_DATA d,*p;
d947 11
a957 10
	l=ERR_GET_LIB(e);
	d.error=ERR_PACK(l,0,0);
	p=ERRFN(err_get_item)(&d);
	return((p == NULL)?NULL:p->string);
	}

const char *ERR_func_error_string(unsigned long e)
	{
	ERR_STRING_DATA d,*p;
	unsigned long l,f;
d960 12
a971 11
	l=ERR_GET_LIB(e);
	f=ERR_GET_FUNC(e);
	d.error=ERR_PACK(l,f,0);
	p=ERRFN(err_get_item)(&d);
	return((p == NULL)?NULL:p->string);
	}

const char *ERR_reason_error_string(unsigned long e)
	{
	ERR_STRING_DATA d,*p=NULL;
	unsigned long l,r;
d974 14
a987 14
	l=ERR_GET_LIB(e);
	r=ERR_GET_REASON(e);
	d.error=ERR_PACK(l,0,r);
	p=ERRFN(err_get_item)(&d);
	if (!p)
		{
		d.error=ERR_PACK(0,0,r);
		p=ERRFN(err_get_item)(&d);
		}
	return((p == NULL)?NULL:p->string);
	}

void ERR_remove_thread_state(const CRYPTO_THREADID *id)
	{
d998 1
a998 1
	}
d1001 3
a1003 2
void ERR_remove_state(unsigned long pid)
	{
d1005 1
a1005 1
	}
d1008 3
a1010 2
ERR_STATE *ERR_get_state(void)
	{
d1012 1
a1012 1
	ERR_STATE *ret,tmp,*tmpp=NULL;
d1019 1
a1019 1
	ret=ERRFN(thread_get_item)(&tmp);
d1022 4
a1025 4
	if (ret == NULL)
		{
		ret=(ERR_STATE *)malloc(sizeof(ERR_STATE));
		if (ret == NULL) return(&fallback);
d1027 6
a1032 7
		ret->top=0;
		ret->bottom=0;
		for (i=0; i<ERR_NUM_ERRORS; i++)
			{
			ret->err_data[i]=NULL;
			ret->err_data_flags[i]=0;
			}
d1035 1
a1035 2
		if (ERRFN(thread_get_item)(ret) != ret)
			{
d1037 2
a1038 2
			return(&fallback);
			}
d1043 1
a1043 1
		}
d1045 1
a1045 1
	}
d1047 3
a1049 2
int ERR_get_next_error_library(void)
	{
d1052 1
a1052 1
	}
d1054 3
a1056 2
void ERR_set_error_data(char *data, int flags)
	{
d1060 1
a1060 1
	es=ERR_get_state();
d1062 1
a1062 1
	i=es->top;
d1064 1
a1064 6
		i=ERR_NUM_ERRORS-1;

	err_clear_data(es,i);
	es->err_data[i]=data;
	es->err_data_flags[i]=flags;
	}
d1066 8
a1073 2
void ERR_add_error_data(int num, ...)
	{
d1078 1
a1078 1
	}
d1080 11
a1090 9
void ERR_add_error_vdata(int num, va_list args)
	{
	int i,n,s;
	char *str,*p,*a;

	s=80;
	str=malloc(s+1);
	if (str == NULL) return;
	str[0]='\0';
d1092 3
a1094 4
	n=0;
	for (i=0; i<num; i++)
		{
		a=va_arg(args, char*);
d1096 6
a1101 9
		if (a != NULL)
			{
			n+=strlen(a);
			if (n > s)
				{
				s=n+20;
				p=realloc(str,s+1);
				if (p == NULL)
					{
d1104 2
a1105 5
					}
				else
					str=p;
				}
			strlcat(str,a,(size_t)s+1);
d1107 1
a1108 1
	ERR_set_error_data(str,ERR_TXT_MALLOCED|ERR_TXT_STRING);
d1110 2
d1113 3
a1115 2
int ERR_set_mark(void)
	{
d1118 1
a1118 1
	es=ERR_get_state();
d1120 3
a1122 2
	if (es->bottom == es->top) return 0;
	es->err_flags[es->top]|=ERR_FLAG_MARK;
d1124 1
a1124 1
	}
d1126 3
a1128 2
int ERR_pop_to_mark(void)
	{
d1131 1
a1131 1
	es=ERR_get_state();
d1133 10
a1142 9
	while(es->bottom != es->top
		&& (es->err_flags[es->top] & ERR_FLAG_MARK) == 0)
		{
		err_clear(es,es->top);
		es->top-=1;
		if (es->top == -1) es->top=ERR_NUM_ERRORS-1;
		}
		
	if (es->bottom == es->top) return 0;
d1145 1
a1145 1
	}
@


1.27
log
@We'll interpret a (void) cast on snprintf() to mean it's been verified that
truncation is either desirable, not an issue, or is detected and handled later

ok deraadt@@
@
text
@d832 1
a832 1
	char lsbuf[64], fsbuf[64], rsbuf[64];
d834 1
a834 1
	unsigned long l,f,r;
d844 12
a855 6
	if (ls == NULL) 
		snprintf(lsbuf, sizeof(lsbuf), "lib(%lu)", l);
	if (fs == NULL)
		snprintf(fsbuf, sizeof(fsbuf), "func(%lu)", f);
	if (rs == NULL)
		snprintf(rsbuf, sizeof(rsbuf), "reason(%lu)", r);
d857 4
a860 3
	snprintf(buf, len,"error:%08lX:%s:%s:%s", e, ls?ls:lsbuf, 
		fs?fs:fsbuf, rs?rs:rsbuf);
	if (strlen(buf) == len-1)
@


1.26
log
@use intrinsic strlcpy and strlcat everywhere so we only have one set of
funcitons to check for incorrect use. keep BUF_strlcpy and BUF_strlcat
for API comptibility only.
ok tedu@@
@
text
@d845 1
a845 1
		(void) snprintf(lsbuf, sizeof(lsbuf), "lib(%lu)", l);
d847 1
a847 1
		(void) snprintf(fsbuf, sizeof(fsbuf), "func(%lu)", f);
d849 1
a849 1
		(void) snprintf(rsbuf, sizeof(rsbuf), "reason(%lu)", r);
d851 1
a851 1
	(void) snprintf(buf, len,"error:%08lX:%s:%s:%s", e, ls?ls:lsbuf, 
@


1.25
log
@Unsurprisingly, since <unistd.h> was so darn hard to find for OpenSSL developers
they had resorted to manually protyping read(2) instead of incredible amount of
preprocessor wizardry needed to find the ever illusive <unistd.h>. Let's just
include <unistd.h> and we don't need to do this.. While we're at it flense
out _OSD_POSIX and __DGJPP__ cruft.
ok krw@@
@
text
@d1074 1
a1074 1
			BUF_strlcat(str,a,(size_t)s+1);
@


1.24
log
@kill REF_PRINT/REF_CHECK debugging framework noone would use
ok miod
@
text
@a699 19
#ifdef _OSD_POSIX
	/* In the BS2000-OSD POSIX subsystem, the compiler generates
	 * path names in the form "*POSIX(/etc/passwd)".
	 * This dirty hack strips them to something sensible.
	 * @@@@@@ We shouldn't modify a const string, though.
	 */
	if (strncmp(file,"*POSIX(", sizeof("*POSIX(")-1) == 0) {
		char *end;

		/* Skip the "*POSIX(" prefix */
		file += sizeof("*POSIX(")-1;
		end = &file[strlen(file)-1];
		if (*end == ')')
			*end = '\0';
		/* Optional: use the basename of the path only. */
		if ((end = strrchr(file, '/')) != NULL)
			file = &end[1];
	}
#endif
@


1.23
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d470 1
a471 11
#ifdef REF_PRINT
	fprintf(stderr,"%4d:%s\n",int_thread_hash_references,"ERR");
#endif
	if (i > 0) return;
#ifdef REF_CHECK
	if (i < 0)
		{
		fprintf(stderr,"int_thread_release, bad reference count\n");
		abort(); /* ok */
		}
#endif
@


1.22
log
@Clean up dangerous strncpy use. This included a use where the resulting
string was potentially not nul terminated and a place where malloc return
was unchecked.
while we're at it remove dummytest.c
ok miod@@
@
text
@d575 1
a575 1
	/* OPENSSL_malloc cannot be used here, use static storage instead */
d628 1
a628 1
		OPENSSL_free((p)->err_data[i]); \
d654 1
a654 1
	OPENSSL_free(s);
d1018 1
a1018 1
		ret=(ERR_STATE *)OPENSSL_malloc(sizeof(ERR_STATE));
d1079 1
a1079 1
	str=OPENSSL_malloc(s+1);
d1094 1
a1094 1
				p=OPENSSL_realloc(str,s+1);
d1097 1
a1097 1
					OPENSSL_free(str);
@


1.21
log
@Part 1 of eliminating BIO_snprintf(). This fixes mechanical conversions
where the return value is ignored changing to (void) snprintf.
ok deraadt@@
@
text
@d606 1
a606 2
				strncpy(*dest, src, sizeof *dest);
				(*dest)[sizeof *dest - 1] = '\0';
@


1.20
log
@Remove various horrible socket syscall wrappers, especially SHUTDOWN*
which did shutdown + close, all nasty and surprising.  Use the raw
syscalls that everyone knows the behaviour of.
ok beck matthew
@
text
@d875 1
a875 1
		BIO_snprintf(lsbuf, sizeof(lsbuf), "lib(%lu)", l);
d877 1
a877 1
		BIO_snprintf(fsbuf, sizeof(fsbuf), "func(%lu)", f);
d879 1
a879 1
		BIO_snprintf(rsbuf, sizeof(rsbuf), "reason(%lu)", r);
d881 1
a881 1
	BIO_snprintf(buf, len,"error:%08lX:%s:%s:%s", e, ls?ls:lsbuf, 
@


1.19
log
@resolve conflicts
@
text
@d168 1
a168 1
	{ERR_PACK(0,SYS_F_IOCTLSOCKET,0),	"ioctlsocket"},
@


1.18
log
@resolve conflicts, fix local changes
@
text
@d1069 7
a1083 1
	va_start(args, num);
d1099 1
a1099 1
					goto err;
a1107 3

err:
	va_end(args);
@


1.17
log
@resolve conflicts
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
d122 501
a622 3
static unsigned long get_error_values(int inc,int top,
					const char **file,int *line,
					const char **data,int *flags);
d644 62
d860 190
a1135 31

#ifdef OPENSSL_FIPS

static ERR_STATE *fget_state(void)
	{
	static ERR_STATE fstate;
	return &fstate;
	}

ERR_STATE *(*get_state_func)(void) = fget_state;
void (*remove_state_func)(unsigned long pid);

ERR_STATE *ERR_get_state(void)
	{
	return get_state_func();
	}

void int_ERR_set_state_func(ERR_STATE *(*get_func)(void),
				void (*remove_func)(unsigned long pid))
	{
	get_state_func = get_func;
	remove_state_func = remove_func;
	}

void ERR_remove_state(unsigned long pid)
	{
	if (remove_state_func)
		remove_state_func(pid);
	}

#endif
@


1.16
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d122 3
a124 474
static void err_load_strings(int lib, ERR_STRING_DATA *str);

static void ERR_STATE_free(ERR_STATE *s);
#ifndef OPENSSL_NO_ERR
static ERR_STRING_DATA ERR_str_libraries[]=
	{
{ERR_PACK(ERR_LIB_NONE,0,0)		,"unknown library"},
{ERR_PACK(ERR_LIB_SYS,0,0)		,"system library"},
{ERR_PACK(ERR_LIB_BN,0,0)		,"bignum routines"},
{ERR_PACK(ERR_LIB_RSA,0,0)		,"rsa routines"},
{ERR_PACK(ERR_LIB_DH,0,0)		,"Diffie-Hellman routines"},
{ERR_PACK(ERR_LIB_EVP,0,0)		,"digital envelope routines"},
{ERR_PACK(ERR_LIB_BUF,0,0)		,"memory buffer routines"},
{ERR_PACK(ERR_LIB_OBJ,0,0)		,"object identifier routines"},
{ERR_PACK(ERR_LIB_PEM,0,0)		,"PEM routines"},
{ERR_PACK(ERR_LIB_DSA,0,0)		,"dsa routines"},
{ERR_PACK(ERR_LIB_X509,0,0)		,"x509 certificate routines"},
{ERR_PACK(ERR_LIB_ASN1,0,0)		,"asn1 encoding routines"},
{ERR_PACK(ERR_LIB_CONF,0,0)		,"configuration file routines"},
{ERR_PACK(ERR_LIB_CRYPTO,0,0)		,"common libcrypto routines"},
{ERR_PACK(ERR_LIB_EC,0,0)		,"elliptic curve routines"},
{ERR_PACK(ERR_LIB_SSL,0,0)		,"SSL routines"},
{ERR_PACK(ERR_LIB_BIO,0,0)		,"BIO routines"},
{ERR_PACK(ERR_LIB_PKCS7,0,0)		,"PKCS7 routines"},
{ERR_PACK(ERR_LIB_X509V3,0,0)		,"X509 V3 routines"},
{ERR_PACK(ERR_LIB_PKCS12,0,0)		,"PKCS12 routines"},
{ERR_PACK(ERR_LIB_RAND,0,0)		,"random number generator"},
{ERR_PACK(ERR_LIB_DSO,0,0)		,"DSO support routines"},
{ERR_PACK(ERR_LIB_ENGINE,0,0)		,"engine routines"},
{ERR_PACK(ERR_LIB_OCSP,0,0)		,"OCSP routines"},
{ERR_PACK(ERR_LIB_FIPS,0,0)		,"FIPS routines"},
{ERR_PACK(ERR_LIB_CMS,0,0)		,"CMS routines"},
{0,NULL},
	};

static ERR_STRING_DATA ERR_str_functs[]=
	{
	{ERR_PACK(0,SYS_F_FOPEN,0),     	"fopen"},
	{ERR_PACK(0,SYS_F_CONNECT,0),		"connect"},
	{ERR_PACK(0,SYS_F_GETSERVBYNAME,0),	"getservbyname"},
	{ERR_PACK(0,SYS_F_SOCKET,0),		"socket"}, 
	{ERR_PACK(0,SYS_F_IOCTLSOCKET,0),	"ioctlsocket"},
	{ERR_PACK(0,SYS_F_BIND,0),		"bind"},
	{ERR_PACK(0,SYS_F_LISTEN,0),		"listen"},
	{ERR_PACK(0,SYS_F_ACCEPT,0),		"accept"},
#ifdef OPENSSL_SYS_WINDOWS
	{ERR_PACK(0,SYS_F_WSASTARTUP,0),	"WSAstartup"},
#endif
	{ERR_PACK(0,SYS_F_OPENDIR,0),		"opendir"},
	{ERR_PACK(0,SYS_F_FREAD,0),		"fread"},
	{0,NULL},
	};

static ERR_STRING_DATA ERR_str_reasons[]=
	{
{ERR_R_SYS_LIB				,"system lib"},
{ERR_R_BN_LIB				,"BN lib"},
{ERR_R_RSA_LIB				,"RSA lib"},
{ERR_R_DH_LIB				,"DH lib"},
{ERR_R_EVP_LIB				,"EVP lib"},
{ERR_R_BUF_LIB				,"BUF lib"},
{ERR_R_OBJ_LIB				,"OBJ lib"},
{ERR_R_PEM_LIB				,"PEM lib"},
{ERR_R_DSA_LIB				,"DSA lib"},
{ERR_R_X509_LIB				,"X509 lib"},
{ERR_R_ASN1_LIB				,"ASN1 lib"},
{ERR_R_CONF_LIB				,"CONF lib"},
{ERR_R_CRYPTO_LIB			,"CRYPTO lib"},
{ERR_R_EC_LIB				,"EC lib"},
{ERR_R_SSL_LIB				,"SSL lib"},
{ERR_R_BIO_LIB				,"BIO lib"},
{ERR_R_PKCS7_LIB			,"PKCS7 lib"},
{ERR_R_X509V3_LIB			,"X509V3 lib"},
{ERR_R_PKCS12_LIB			,"PKCS12 lib"},
{ERR_R_RAND_LIB				,"RAND lib"},
{ERR_R_DSO_LIB				,"DSO lib"},
{ERR_R_ENGINE_LIB			,"ENGINE lib"},
{ERR_R_OCSP_LIB				,"OCSP lib"},

{ERR_R_NESTED_ASN1_ERROR		,"nested asn1 error"},
{ERR_R_BAD_ASN1_OBJECT_HEADER		,"bad asn1 object header"},
{ERR_R_BAD_GET_ASN1_OBJECT_CALL		,"bad get asn1 object call"},
{ERR_R_EXPECTING_AN_ASN1_SEQUENCE	,"expecting an asn1 sequence"},
{ERR_R_ASN1_LENGTH_MISMATCH		,"asn1 length mismatch"},
{ERR_R_MISSING_ASN1_EOS			,"missing asn1 eos"},

{ERR_R_FATAL                            ,"fatal"},
{ERR_R_MALLOC_FAILURE			,"malloc failure"},
{ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED	,"called a function you should not call"},
{ERR_R_PASSED_NULL_PARAMETER		,"passed a null parameter"},
{ERR_R_INTERNAL_ERROR			,"internal error"},
{ERR_R_DISABLED				,"called a function that was disabled at compile-time"},

{0,NULL},
	};
#endif


/* Define the predeclared (but externally opaque) "ERR_FNS" type */
struct st_ERR_FNS
	{
	/* Works on the "error_hash" string table */
	LHASH *(*cb_err_get)(int create);
	void (*cb_err_del)(void);
	ERR_STRING_DATA *(*cb_err_get_item)(const ERR_STRING_DATA *);
	ERR_STRING_DATA *(*cb_err_set_item)(ERR_STRING_DATA *);
	ERR_STRING_DATA *(*cb_err_del_item)(ERR_STRING_DATA *);
	/* Works on the "thread_hash" error-state table */
	LHASH *(*cb_thread_get)(int create);
	void (*cb_thread_release)(LHASH **hash);
	ERR_STATE *(*cb_thread_get_item)(const ERR_STATE *);
	ERR_STATE *(*cb_thread_set_item)(ERR_STATE *);
	void (*cb_thread_del_item)(const ERR_STATE *);
	/* Returns the next available error "library" numbers */
	int (*cb_get_next_lib)(void);
	};

/* Predeclarations of the "err_defaults" functions */
static LHASH *int_err_get(int create);
static void int_err_del(void);
static ERR_STRING_DATA *int_err_get_item(const ERR_STRING_DATA *);
static ERR_STRING_DATA *int_err_set_item(ERR_STRING_DATA *);
static ERR_STRING_DATA *int_err_del_item(ERR_STRING_DATA *);
static LHASH *int_thread_get(int create);
static void int_thread_release(LHASH **hash);
static ERR_STATE *int_thread_get_item(const ERR_STATE *);
static ERR_STATE *int_thread_set_item(ERR_STATE *);
static void int_thread_del_item(const ERR_STATE *);
static int int_err_get_next_lib(void);
/* The static ERR_FNS table using these defaults functions */
static const ERR_FNS err_defaults =
	{
	int_err_get,
	int_err_del,
	int_err_get_item,
	int_err_set_item,
	int_err_del_item,
	int_thread_get,
	int_thread_release,
	int_thread_get_item,
	int_thread_set_item,
	int_thread_del_item,
	int_err_get_next_lib
	};

/* The replacable table of ERR_FNS functions we use at run-time */
static const ERR_FNS *err_fns = NULL;

/* Eg. rather than using "err_get()", use "ERRFN(err_get)()". */
#define ERRFN(a) err_fns->cb_##a

/* The internal state used by "err_defaults" - as such, the setting, reading,
 * creating, and deleting of this data should only be permitted via the
 * "err_defaults" functions. This way, a linked module can completely defer all
 * ERR state operation (together with requisite locking) to the implementations
 * and state in the loading application. */
static LHASH *int_error_hash = NULL;
static LHASH *int_thread_hash = NULL;
static int int_thread_hash_references = 0;
static int int_err_library_number= ERR_LIB_USER;

/* Internal function that checks whether "err_fns" is set and if not, sets it to
 * the defaults. */
static void err_fns_check(void)
	{
	if (err_fns) return;
	
	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (!err_fns)
		err_fns = &err_defaults;
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	}

/* API functions to get or set the underlying ERR functions. */

const ERR_FNS *ERR_get_implementation(void)
	{
	err_fns_check();
	return err_fns;
	}

int ERR_set_implementation(const ERR_FNS *fns)
	{
	int ret = 0;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	/* It's too late if 'err_fns' is non-NULL. BTW: not much point setting
	 * an error is there?! */
	if (!err_fns)
		{
		err_fns = fns;
		ret = 1;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	return ret;
	}

/* These are the callbacks provided to "lh_new()" when creating the LHASH tables
 * internal to the "err_defaults" implementation. */

/* static unsigned long err_hash(ERR_STRING_DATA *a); */
static unsigned long err_hash(const void *a_void);
/* static int err_cmp(ERR_STRING_DATA *a, ERR_STRING_DATA *b); */
static int err_cmp(const void *a_void, const void *b_void);
/* static unsigned long pid_hash(ERR_STATE *pid); */
static unsigned long pid_hash(const void *pid_void);
/* static int pid_cmp(ERR_STATE *a,ERR_STATE *pid); */
static int pid_cmp(const void *a_void,const void *pid_void);
static unsigned long get_error_values(int inc,int top,const char **file,int *line,
				      const char **data,int *flags);

/* The internal functions used in the "err_defaults" implementation */

static LHASH *int_err_get(int create)
	{
	LHASH *ret = NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (!int_error_hash && create)
		{
		CRYPTO_push_info("int_err_get (err.c)");
		int_error_hash = lh_new(err_hash, err_cmp);
		CRYPTO_pop_info();
		}
	if (int_error_hash)
		ret = int_error_hash;
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return ret;
	}

static void int_err_del(void)
	{
	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (int_error_hash)
		{
		lh_free(int_error_hash);
		int_error_hash = NULL;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	}

static ERR_STRING_DATA *int_err_get_item(const ERR_STRING_DATA *d)
	{
	ERR_STRING_DATA *p;
	LHASH *hash;

	err_fns_check();
	hash = ERRFN(err_get)(0);
	if (!hash)
		return NULL;

	CRYPTO_r_lock(CRYPTO_LOCK_ERR);
	p = (ERR_STRING_DATA *)lh_retrieve(hash, d);
	CRYPTO_r_unlock(CRYPTO_LOCK_ERR);

	return p;
	}

static ERR_STRING_DATA *int_err_set_item(ERR_STRING_DATA *d)
	{
	ERR_STRING_DATA *p;
	LHASH *hash;

	err_fns_check();
	hash = ERRFN(err_get)(1);
	if (!hash)
		return NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = (ERR_STRING_DATA *)lh_insert(hash, d);
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return p;
	}

static ERR_STRING_DATA *int_err_del_item(ERR_STRING_DATA *d)
	{
	ERR_STRING_DATA *p;
	LHASH *hash;

	err_fns_check();
	hash = ERRFN(err_get)(0);
	if (!hash)
		return NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = (ERR_STRING_DATA *)lh_delete(hash, d);
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return p;
	}

static LHASH *int_thread_get(int create)
	{
	LHASH *ret = NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (!int_thread_hash && create)
		{
		CRYPTO_push_info("int_thread_get (err.c)");
		int_thread_hash = lh_new(pid_hash, pid_cmp);
		CRYPTO_pop_info();
		}
	if (int_thread_hash)
		{
		int_thread_hash_references++;
		ret = int_thread_hash;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	return ret;
	}

static void int_thread_release(LHASH **hash)
	{
	int i;

	if (hash == NULL || *hash == NULL)
		return;

	i = CRYPTO_add(&int_thread_hash_references, -1, CRYPTO_LOCK_ERR);

#ifdef REF_PRINT
	fprintf(stderr,"%4d:%s\n",int_thread_hash_references,"ERR");
#endif
	if (i > 0) return;
#ifdef REF_CHECK
	if (i < 0)
		{
		fprintf(stderr,"int_thread_release, bad reference count\n");
		abort(); /* ok */
		}
#endif
	*hash = NULL;
	}

static ERR_STATE *int_thread_get_item(const ERR_STATE *d)
	{
	ERR_STATE *p;
	LHASH *hash;

	err_fns_check();
	hash = ERRFN(thread_get)(0);
	if (!hash)
		return NULL;

	CRYPTO_r_lock(CRYPTO_LOCK_ERR);
	p = (ERR_STATE *)lh_retrieve(hash, d);
	CRYPTO_r_unlock(CRYPTO_LOCK_ERR);

	ERRFN(thread_release)(&hash);
	return p;
	}

static ERR_STATE *int_thread_set_item(ERR_STATE *d)
	{
	ERR_STATE *p;
	LHASH *hash;

	err_fns_check();
	hash = ERRFN(thread_get)(1);
	if (!hash)
		return NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = (ERR_STATE *)lh_insert(hash, d);
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	ERRFN(thread_release)(&hash);
	return p;
	}

static void int_thread_del_item(const ERR_STATE *d)
	{
	ERR_STATE *p;
	LHASH *hash;

	err_fns_check();
	hash = ERRFN(thread_get)(0);
	if (!hash)
		return;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = (ERR_STATE *)lh_delete(hash, d);
	/* make sure we don't leak memory */
	if (int_thread_hash_references == 1
		&& int_thread_hash && (lh_num_items(int_thread_hash) == 0))
		{
		lh_free(int_thread_hash);
		int_thread_hash = NULL;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	ERRFN(thread_release)(&hash);
	if (p)
		ERR_STATE_free(p);
	}

static int int_err_get_next_lib(void)
	{
	int ret;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	ret = int_err_library_number++;
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return ret;
	}


#ifndef OPENSSL_NO_ERR
#define NUM_SYS_STR_REASONS 127
#define LEN_SYS_STR_REASON 32

static ERR_STRING_DATA SYS_str_reasons[NUM_SYS_STR_REASONS + 1];
/* SYS_str_reasons is filled with copies of strerror() results at
 * initialization.
 * 'errno' values up to 127 should cover all usual errors,
 * others will be displayed numerically by ERR_error_string.
 * It is crucial that we have something for each reason code
 * that occurs in ERR_str_reasons, or bogus reason strings
 * will be returned for SYSerr(), which always gets an errno
 * value and never one of those 'standard' reason codes. */

static void build_SYS_str_reasons(void)
	{
	/* OPENSSL_malloc cannot be used here, use static storage instead */
	static char strerror_tab[NUM_SYS_STR_REASONS][LEN_SYS_STR_REASON];
	int i;
	static int init = 1;

	CRYPTO_r_lock(CRYPTO_LOCK_ERR);
	if (!init)
		{
		CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
		return;
		}
	
	CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (!init)
		{
		CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
		return;
		}

	for (i = 1; i <= NUM_SYS_STR_REASONS; i++)
		{
		ERR_STRING_DATA *str = &SYS_str_reasons[i - 1];

		str->error = (unsigned long)i;
		if (str->string == NULL)
			{
			char (*dest)[LEN_SYS_STR_REASON] = &(strerror_tab[i - 1]);
			char *src = strerror(i);
			if (src != NULL)
				{
				strncpy(*dest, src, sizeof *dest);
				(*dest)[sizeof *dest - 1] = '\0';
				str->string = *dest;
				}
			}
		if (str->string == NULL)
			str->string = "unknown";
		}

	/* Now we still have SYS_str_reasons[NUM_SYS_STR_REASONS] = {0, NULL},
	 * as required by ERR_load_strings. */

	init = 0;
	
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	}
#endif
a145 62
static void ERR_STATE_free(ERR_STATE *s)
	{
	int i;

	if (s == NULL)
	    return;

	for (i=0; i<ERR_NUM_ERRORS; i++)
		{
		err_clear_data(s,i);
		}
	OPENSSL_free(s);
	}

void ERR_load_ERR_strings(void)
	{
	err_fns_check();
#ifndef OPENSSL_NO_ERR
	err_load_strings(0,ERR_str_libraries);
	err_load_strings(0,ERR_str_reasons);
	err_load_strings(ERR_LIB_SYS,ERR_str_functs);
	build_SYS_str_reasons();
	err_load_strings(ERR_LIB_SYS,SYS_str_reasons);
#endif
	}

static void err_load_strings(int lib, ERR_STRING_DATA *str)
	{
	while (str->error)
		{
		if (lib)
			str->error|=ERR_PACK(lib,0,0);
		ERRFN(err_set_item)(str);
		str++;
		}
	}

void ERR_load_strings(int lib, ERR_STRING_DATA *str)
	{
	ERR_load_ERR_strings();
	err_load_strings(lib, str);
	}

void ERR_unload_strings(int lib, ERR_STRING_DATA *str)
	{
	while (str->error)
		{
		if (lib)
			str->error|=ERR_PACK(lib,0,0);
		ERRFN(err_del_item)(str);
		str++;
		}
	}

void ERR_free_strings(void)
	{
	err_fns_check();
	ERRFN(err_del)();
	}

/********************************************************/

a299 212
void ERR_error_string_n(unsigned long e, char *buf, size_t len)
	{
	char lsbuf[64], fsbuf[64], rsbuf[64];
	const char *ls,*fs,*rs;
	unsigned long l,f,r;

	l=ERR_GET_LIB(e);
	f=ERR_GET_FUNC(e);
	r=ERR_GET_REASON(e);

	ls=ERR_lib_error_string(e);
	fs=ERR_func_error_string(e);
	rs=ERR_reason_error_string(e);

	if (ls == NULL) 
		BIO_snprintf(lsbuf, sizeof(lsbuf), "lib(%lu)", l);
	if (fs == NULL)
		BIO_snprintf(fsbuf, sizeof(fsbuf), "func(%lu)", f);
	if (rs == NULL)
		BIO_snprintf(rsbuf, sizeof(rsbuf), "reason(%lu)", r);

	BIO_snprintf(buf, len,"error:%08lX:%s:%s:%s", e, ls?ls:lsbuf, 
		fs?fs:fsbuf, rs?rs:rsbuf);
	if (strlen(buf) == len-1)
		{
		/* output may be truncated; make sure we always have 5 
		 * colon-separated fields, i.e. 4 colons ... */
#define NUM_COLONS 4
		if (len > NUM_COLONS) /* ... if possible */
			{
			int i;
			char *s = buf;
			
			for (i = 0; i < NUM_COLONS; i++)
				{
				char *colon = strchr(s, ':');
				if (colon == NULL || colon > &buf[len-1] - NUM_COLONS + i)
					{
					/* set colon no. i at last possible position
					 * (buf[len-1] is the terminating 0)*/
					colon = &buf[len-1] - NUM_COLONS + i;
					*colon = ':';
					}
				s = colon + 1;
				}
			}
		}
	}

/* BAD for multi-threading: uses a local buffer if ret == NULL */
/* ERR_error_string_n should be used instead for ret != NULL
 * as ERR_error_string cannot know how large the buffer is */
char *ERR_error_string(unsigned long e, char *ret)
	{
	static char buf[256];

	if (ret == NULL) ret=buf;
	ERR_error_string_n(e, ret, 256);

	return ret;
	}

LHASH *ERR_get_string_table(void)
	{
	err_fns_check();
	return ERRFN(err_get)(0);
	}

LHASH *ERR_get_err_state_table(void)
	{
	err_fns_check();
	return ERRFN(thread_get)(0);
	}

void ERR_release_err_state_table(LHASH **hash)
	{
	err_fns_check();
	ERRFN(thread_release)(hash);
	}

const char *ERR_lib_error_string(unsigned long e)
	{
	ERR_STRING_DATA d,*p;
	unsigned long l;

	err_fns_check();
	l=ERR_GET_LIB(e);
	d.error=ERR_PACK(l,0,0);
	p=ERRFN(err_get_item)(&d);
	return((p == NULL)?NULL:p->string);
	}

const char *ERR_func_error_string(unsigned long e)
	{
	ERR_STRING_DATA d,*p;
	unsigned long l,f;

	err_fns_check();
	l=ERR_GET_LIB(e);
	f=ERR_GET_FUNC(e);
	d.error=ERR_PACK(l,f,0);
	p=ERRFN(err_get_item)(&d);
	return((p == NULL)?NULL:p->string);
	}

const char *ERR_reason_error_string(unsigned long e)
	{
	ERR_STRING_DATA d,*p=NULL;
	unsigned long l,r;

	err_fns_check();
	l=ERR_GET_LIB(e);
	r=ERR_GET_REASON(e);
	d.error=ERR_PACK(l,0,r);
	p=ERRFN(err_get_item)(&d);
	if (!p)
		{
		d.error=ERR_PACK(0,0,r);
		p=ERRFN(err_get_item)(&d);
		}
	return((p == NULL)?NULL:p->string);
	}

/* static unsigned long err_hash(ERR_STRING_DATA *a) */
static unsigned long err_hash(const void *a_void)
	{
	unsigned long ret,l;

	l=((const ERR_STRING_DATA *)a_void)->error;
	ret=l^ERR_GET_LIB(l)^ERR_GET_FUNC(l);
	return(ret^ret%19*13);
	}

/* static int err_cmp(ERR_STRING_DATA *a, ERR_STRING_DATA *b) */
static int err_cmp(const void *a_void, const void *b_void)
	{
	return((int)(((const ERR_STRING_DATA *)a_void)->error -
			((const ERR_STRING_DATA *)b_void)->error));
	}

/* static unsigned long pid_hash(ERR_STATE *a) */
static unsigned long pid_hash(const void *a_void)
	{
	return(((const ERR_STATE *)a_void)->pid*13);
	}

/* static int pid_cmp(ERR_STATE *a, ERR_STATE *b) */
static int pid_cmp(const void *a_void, const void *b_void)
	{
	return((int)((long)((const ERR_STATE *)a_void)->pid -
			(long)((const ERR_STATE *)b_void)->pid));
	}

void ERR_remove_state(unsigned long pid)
	{
	ERR_STATE tmp;

	err_fns_check();
	if (pid == 0)
		pid=(unsigned long)CRYPTO_thread_id();
	tmp.pid=pid;
	/* thread_del_item automatically destroys the LHASH if the number of
	 * items reaches zero. */
	ERRFN(thread_del_item)(&tmp);
	}

ERR_STATE *ERR_get_state(void)
	{
	static ERR_STATE fallback;
	ERR_STATE *ret,tmp,*tmpp=NULL;
	int i;
	unsigned long pid;

	err_fns_check();
	pid=(unsigned long)CRYPTO_thread_id();
	tmp.pid=pid;
	ret=ERRFN(thread_get_item)(&tmp);

	/* ret == the error state, if NULL, make a new one */
	if (ret == NULL)
		{
		ret=(ERR_STATE *)OPENSSL_malloc(sizeof(ERR_STATE));
		if (ret == NULL) return(&fallback);
		ret->pid=pid;
		ret->top=0;
		ret->bottom=0;
		for (i=0; i<ERR_NUM_ERRORS; i++)
			{
			ret->err_data[i]=NULL;
			ret->err_data_flags[i]=0;
			}
		tmpp = ERRFN(thread_set_item)(ret);
		/* To check if insertion failed, do a get. */
		if (ERRFN(thread_get_item)(ret) != ret)
			{
			ERR_STATE_free(ret); /* could not insert it */
			return(&fallback);
			}
		/* If a race occured in this function and we came second, tmpp
		 * is the first one that we just replaced. */
		if (tmpp)
			ERR_STATE_free(tmpp);
		}
	return ret;
	}

int ERR_get_next_error_library(void)
	{
	err_fns_check();
	return ERRFN(get_next_lib)();
	}

d386 31
@


1.15
log
@resolve conflicts
@
text
@d152 1
@


1.14
log
@resolve conflicts
@
text
@d115 1
a117 1
#include "cryptlib.h"
d152 1
a152 1
{ERR_PACK(ERR_LIB_FIPS,0,0)		,"FIPS routines"},
a170 1
	{ERR_PACK(0,SYS_F_GETADDRINFO,0),	"getaddrinfo"},
d212 1
d545 1
a545 1
static void build_SYS_str_reasons()
d552 8
a559 2
	if (!init) return;

d561 5
d597 1
d604 11
a614 1
	(p)->err_data_flags[i]=0;
d707 1
d723 1
a723 4
		es->err_buffer[i]=0;
		err_clear_data(es,i);
		es->err_file[i]=NULL;
		es->err_line[i]= -1;
d960 1
a960 1
	l=((ERR_STRING_DATA *)a_void)->error;
d968 2
a969 2
	return((int)(((ERR_STRING_DATA *)a_void)->error -
			((ERR_STRING_DATA *)b_void)->error));
d975 1
a975 1
	return(((ERR_STATE *)a_void)->pid*13);
d981 2
a982 2
	return((int)((long)((ERR_STATE *)a_void)->pid -
			(long)((ERR_STATE *)b_void)->pid));
d1092 1
a1092 1
			BUF_strlcat(str,a,s+1);
d1099 30
@


1.13
log
@resolve conflicts
@
text
@d624 2
a625 1
		str->error|=ERR_PACK(lib,0,0);
d641 2
a642 1
		str->error|=ERR_PACK(lib,0,0);
@


1.12
log
@merge 0.9.7d
@
text
@d152 1
d171 1
@


1.11
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d1068 1
a1068 1
			strlcat(str,a,s+1);
@


1.10
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d228 1
d243 1
d257 1
d277 1
d424 2
d427 1
d432 23
d469 1
d487 1
d504 2
a505 1
	if (int_thread_hash && (lh_num_items(int_thread_hash) == 0))
d512 1
d880 6
@


1.9
log
@str{cat,cpy}/sprintf cleanup. markus@@, deraadt@@ ok
@
text
@d214 1
d495 1
@


1.8
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d1026 1
a1026 1
			strcat(str,a);
@


1.7
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d169 1
@


1.6
log
@openssl-engine-0.9.6a merge
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
d122 1
a123 9
static LHASH *error_hash=NULL;
static LHASH *thread_hash=NULL;

static unsigned long err_hash(ERR_STRING_DATA *a);
static int err_cmp(ERR_STRING_DATA *a, ERR_STRING_DATA *b);
static unsigned long pid_hash(ERR_STATE *pid);
static int pid_cmp(ERR_STATE *a,ERR_STATE *pid);
static unsigned long get_error_values(int inc,const char **file,int *line,
				      const char **data,int *flags);
d125 1
a125 1
#ifndef NO_ERR
a131 1
{ERR_PACK(ERR_LIB_DSA,0,0)		,"dsa routines"},
a134 1
{ERR_PACK(ERR_LIB_BIO,0,0)		,"BIO routines"},
d137 2
a139 1
{ERR_PACK(ERR_LIB_X509,0,0)		,"x509 certificate routines"},
d141 2
a142 1
{ERR_PACK(ERR_LIB_METH,0,0)		,"X509 lookup 'method' routines"},
a143 2
{ERR_PACK(ERR_LIB_RSAREF,0,0)		,"RSAref routines"},
{ERR_PACK(ERR_LIB_PROXY,0,0)		,"Proxy routines"},
d151 1
d165 1
a165 1
#ifdef WINDOWS
a173 1
{ERR_R_FATAL                             ,"fatal"},
a179 1
{ERR_R_BIO_LIB				,"BIO lib"},
d182 1
a183 1
{ERR_R_METH_LIB				,"METH lib"},
d186 2
a188 1
{ERR_R_PROXY_LIB			,"PROXY lib"},
d191 1
d193 5
a197 3
{ERR_R_MALLOC_FAILURE			,"Malloc failure"},
{ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED	,"called a function you should not call"},
{ERR_R_PASSED_NULL_PARAMETER		,"passed a null parameter"},
d204 6
a209 2
{ERR_R_DSO_LIB				,"DSO lib"},
{ERR_R_ENGINE_LIB			,"ENGINE lib"},
d215 278
d511 1
d513 3
a515 1
	CRYPTO_w_lock(CRYPTO_LOCK_ERR_HASH);
d540 3
a542 1
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR_HASH);
d559 1
a559 1
	if(s == NULL)
d571 9
a579 1
	static int init=1;
d581 3
a583 1
	if (init)
d585 3
a587 16
		CRYPTO_w_lock(CRYPTO_LOCK_ERR);
		if (init == 0)
			{
			CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
			return;
			}
		CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

#ifndef NO_ERR
		ERR_load_strings(0,ERR_str_libraries);
		ERR_load_strings(0,ERR_str_reasons);
		ERR_load_strings(ERR_LIB_SYS,ERR_str_functs);
		build_SYS_str_reasons();
		ERR_load_strings(ERR_LIB_SYS,SYS_str_reasons);
#endif
		init=0;
d593 3
a595 10
	if (error_hash == NULL)
		{
		CRYPTO_w_lock(CRYPTO_LOCK_ERR_HASH);
		error_hash=lh_new(err_hash,err_cmp);
		if (error_hash == NULL)
			{
			CRYPTO_w_unlock(CRYPTO_LOCK_ERR_HASH);
			return;
			}
		CRYPTO_w_unlock(CRYPTO_LOCK_ERR_HASH);
d597 2
a598 4
		ERR_load_ERR_strings();
		}

	CRYPTO_w_lock(CRYPTO_LOCK_ERR_HASH);
d602 1
a602 1
		lh_insert(error_hash,str);
a604 1
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR_HASH);
d609 2
a610 9
	CRYPTO_w_lock(CRYPTO_LOCK_ERR);

	if (error_hash != NULL)
		{
		lh_free(error_hash);
		error_hash=NULL;
		}

	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
d669 1
a669 1
	{ return(get_error_values(1,NULL,NULL,NULL,NULL)); }
d673 1
a673 1
	{ return(get_error_values(1,file,line,NULL,NULL)); }
d677 2
a678 2
	{ return(get_error_values(1,file,line,
	     data,flags)); }
d681 1
a681 1
	{ return(get_error_values(0,NULL,NULL,NULL,NULL)); }
d683 2
a684 3
unsigned long ERR_peek_error_line(const char **file,
	     int *line)
	{ return(get_error_values(0,file,line,NULL,NULL)); }
d688 13
a700 2
	{ return(get_error_values(0,file,line,
	     data,flags)); }
d702 1
a702 1
static unsigned long get_error_values(int inc, const char **file, int *line,
d711 15
a725 2
	if (es->bottom == es->top) return(0);
	i=(es->bottom+1)%ERR_NUM_ERRORS;
d768 1
a768 1
	return(ret);
d830 1
a830 1
	return(ret);
d835 2
a836 1
	return(error_hash);
a838 1
/* not thread-safe */
d841 2
a842 1
	return(thread_hash);
d847 1
a847 1
	ERR_STRING_DATA d,*p=NULL;
d850 1
d852 2
a853 11

	CRYPTO_w_lock(CRYPTO_LOCK_ERR_HASH);

	if (error_hash != NULL)
		{
		d.error=ERR_PACK(l,0,0);
		p=(ERR_STRING_DATA *)lh_retrieve(error_hash,&d);
		}

	CRYPTO_w_unlock(CRYPTO_LOCK_ERR_HASH);

d859 1
a859 1
	ERR_STRING_DATA d,*p=NULL;
d862 1
d865 2
a866 11

	CRYPTO_w_lock(CRYPTO_LOCK_ERR_HASH);

	if (error_hash != NULL)
		{
		d.error=ERR_PACK(l,f,0);
		p=(ERR_STRING_DATA *)lh_retrieve(error_hash,&d);
		}

	CRYPTO_w_unlock(CRYPTO_LOCK_ERR_HASH);

d875 1
d878 3
a880 4

	CRYPTO_w_lock(CRYPTO_LOCK_ERR_HASH);

	if (error_hash != NULL)
d882 2
a883 7
		d.error=ERR_PACK(l,0,r);
		p=(ERR_STRING_DATA *)lh_retrieve(error_hash,&d);
		if (p == NULL)
			{
			d.error=ERR_PACK(0,0,r);
			p=(ERR_STRING_DATA *)lh_retrieve(error_hash,&d);
			}
a884 3

	CRYPTO_w_unlock(CRYPTO_LOCK_ERR_HASH);

d888 2
a889 1
static unsigned long err_hash(ERR_STRING_DATA *a)
d893 1
a893 1
	l=a->error;
d898 2
a899 1
static int err_cmp(ERR_STRING_DATA *a, ERR_STRING_DATA *b)
d901 2
a902 1
	return((int)(a->error-b->error));
d905 2
a906 1
static unsigned long pid_hash(ERR_STATE *a)
d908 1
a908 1
	return(a->pid*13);
d911 2
a912 1
static int pid_cmp(ERR_STATE *a, ERR_STATE *b)
d914 2
a915 1
	return((int)((long)a->pid - (long)b->pid));
d920 1
a920 1
	ERR_STATE *p = NULL,tmp;
d922 1
a922 2
	if (thread_hash == NULL)
		return;
d926 3
a928 14
	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (thread_hash)
		{
		p=(ERR_STATE *)lh_delete(thread_hash,&tmp);
		if (lh_num_items(thread_hash) == 0)
			{
			/* make sure we don't leak memory */
			lh_free(thread_hash);
			thread_hash = NULL;
			}
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	if (p != NULL) ERR_STATE_free(p);
d934 1
a934 2
	ERR_STATE *ret=NULL,tmp,*tmpp=NULL;
	int thread_state_exists;
d938 1
d940 2
a941 8

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (thread_hash != NULL)
		{
		tmp.pid=pid;
		ret=(ERR_STATE *)lh_retrieve(thread_hash,&tmp);
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
d956 3
a958 18

		CRYPTO_w_lock(CRYPTO_LOCK_ERR);

		/* no entry yet in thread_hash for current thread -
		 * thus, it may have changed since we last looked at it */
		if (thread_hash == NULL)
			thread_hash = lh_new(pid_hash, pid_cmp);
		if (thread_hash == NULL)
			thread_state_exists = 0; /* allocation error */
		else
			{
			tmpp=(ERR_STATE *)lh_insert(thread_hash,ret);
			thread_state_exists = 1;
			}

		CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

		if (!thread_state_exists)
d963 3
a965 3
		
		if (tmpp != NULL) /* old entry - should not happen */
			{
a966 1
			}
d968 1
a968 1
	return(ret);
d973 2
a974 3
	static int value=ERR_LIB_USER;

	return(value++);
d1020 1
a1020 1
					return;
d1030 1
a1032 1

@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d392 1
a396 2
#if 0
	/* hmm... is this needed */
d400 1
a402 1
		err_clear_data(es,i);
a403 1
#endif
d465 8
a472 1
	if (data != NULL)
d757 1
d759 1
a759 1
	es->err_data_flags[es->top]=flags;
d768 1
a768 1
	s=64;
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d119 1
a120 1
#include <openssl/crypto.h>
d140 1
d159 2
d211 2
d233 1
a233 1
	/* Malloc cannot be used here, use static storage instead */
d270 1
a270 1
		Free((p)->err_data[i]); \
d286 1
a286 1
	Free(s);
d483 1
a483 2
/* BAD for multi-threaded, uses a local buffer if ret == NULL */
char *ERR_error_string(unsigned long e, char *ret)
d485 1
a485 1
	static char buf[256];
a487 1
	int i;
d497 2
a498 8
	if (ret == NULL) ret=buf;

	sprintf(&(ret[0]),"error:%08lX:",e);
	i=strlen(ret);
	if (ls == NULL)
		sprintf(&(ret[i]),":lib(%lu) ",l);
	else	sprintf(&(ret[i]),"%s",ls);
	i=strlen(ret);
d500 1
a500 3
		sprintf(&(ret[i]),":func(%lu) ",f);
	else	sprintf(&(ret[i]),":%s",fs);
	i=strlen(ret);
d502 39
a540 2
		sprintf(&(ret[i]),":reason(%lu)",r);
	else	sprintf(&(ret[i]),":%s",rs);
d550 1
d563 1
a563 1
	CRYPTO_r_lock(CRYPTO_LOCK_ERR_HASH);
d571 1
a571 1
	CRYPTO_r_unlock(CRYPTO_LOCK_ERR_HASH);
d584 1
a584 1
	CRYPTO_r_lock(CRYPTO_LOCK_ERR_HASH);
d592 1
a592 1
	CRYPTO_r_unlock(CRYPTO_LOCK_ERR_HASH);
d605 1
a605 1
	CRYPTO_r_lock(CRYPTO_LOCK_ERR_HASH);
d618 1
a618 1
	CRYPTO_r_unlock(CRYPTO_LOCK_ERR_HASH);
d649 1
a649 1
	ERR_STATE *p,tmp;
d657 10
a666 1
	p=(ERR_STATE *)lh_delete(thread_hash,&tmp);
d675 2
a676 1
	ERR_STATE *ret=NULL,tmp,*tmpp;
d682 2
a683 17
	CRYPTO_r_lock(CRYPTO_LOCK_ERR);
	if (thread_hash == NULL)
		{
		CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
		CRYPTO_w_lock(CRYPTO_LOCK_ERR);
		if (thread_hash == NULL)
			{
			MemCheck_off();
			thread_hash=lh_new(pid_hash,pid_cmp);
			MemCheck_on();
			CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
			if (thread_hash == NULL) return(&fallback);
			}
		else
			CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
		}
	else
a686 1
		CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
d688 1
d693 1
a693 1
		ret=(ERR_STATE *)Malloc(sizeof(ERR_STATE));
d703 1
d705 13
a717 1
		tmpp=(ERR_STATE *)lh_insert(thread_hash,ret);
d719 7
d763 1
a763 1
	str=Malloc(s+1);
d779 1
a779 1
				p=Realloc(str,s+1);
d782 1
a782 1
					Free(str);
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d58 53
d114 1
d211 48
a295 1
		init=0;
d302 2
d305 1
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d94 1
a94 1
{ERR_PACK(ERR_LIB_CONF,0,0)		,"configuation file routines"},
d103 1
d225 1
a225 1
		lh_insert(error_hash,(char *)str);
d431 1
a431 1
		p=(ERR_STRING_DATA *)lh_retrieve(error_hash,(char *)&d);
d452 1
a452 1
		p=(ERR_STRING_DATA *)lh_retrieve(error_hash,(char *)&d);
d473 1
a473 1
		p=(ERR_STRING_DATA *)lh_retrieve(error_hash,(char *)&d);
d477 1
a477 2
			p=(ERR_STRING_DATA *)lh_retrieve(error_hash,
				(char *)&d);
d520 1
a520 1
	p=(ERR_STATE *)lh_delete(thread_hash,(char *)&tmp);
d554 1
a554 1
		ret=(ERR_STATE *)lh_retrieve(thread_hash,(char *)&tmp);
d572 1
a572 1
		tmpp=(ERR_STATE *)lh_insert(thread_hash,(char *)ret);
@


1.1
log
@Initial revision
@
text
@d60 3
a62 2
#include "lhash.h"
#include "crypto.h"
d64 3
a66 3
#include "buffer.h"
#include "err.h"
#include "crypto.h"
a71 1
#ifndef NOPROTO
d76 2
a77 2
static unsigned long get_error_values(int inc,char **file,int *line,
	char **data,int *flags);
a78 9
#else
static unsigned long err_hash();
static int err_cmp();
static unsigned long pid_hash();
static int pid_cmp();
static void ERR_STATE_free();
ERR_STATE *s;
#endif

d101 2
d119 1
d143 1
d145 9
a153 1
{ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED	,"called a fuction you should not call"},
d167 1
a167 2
static void ERR_STATE_free(s)
ERR_STATE *s;
d171 3
d181 1
a181 1
void ERR_load_ERR_strings()
d204 1
a204 3
void ERR_load_strings(lib,str)
int lib;
ERR_STRING_DATA *str;
d230 1
a230 1
void ERR_free_strings()
d245 2
a246 4
void ERR_put_error(lib,func,reason,file,line)
int lib,func,reason;
char *file;
int line;
d250 19
d280 1
a280 1
void ERR_clear_error()
d300 1
a300 1
unsigned long ERR_get_error()
d303 2
a304 3
unsigned long ERR_get_error_line(file,line)
char **file;
int *line;
d307 4
a310 6
unsigned long ERR_get_error_line_data(file,line,data,flags)
char **file;
int *line;
char **data;
int *flags;
	{ return(get_error_values(1,file,line,data,flags)); }
d312 1
a312 1
unsigned long ERR_peek_error()
d315 2
a316 3
unsigned long ERR_peek_error_line(file,line)
char **file;
int *line;
d319 7
a325 13
unsigned long ERR_peek_error_line_data(file,line,data,flags)
char **file;
int *line;
char **data;
int *flags;
	{ return(get_error_values(0,file,line,data,flags)); }

static unsigned long get_error_values(inc,file,line,data,flags)
int inc;
char **file;
int *line;
char **data;
int *flags;
d374 1
a374 3
char *ERR_error_string(e,ret)
unsigned long e;
char *ret;
d377 1
a377 1
	char *ls,*fs,*rs;
d408 1
a408 1
LHASH *ERR_get_string_table()
d413 1
a413 1
LHASH *ERR_get_err_state_table()
d418 1
a418 2
char *ERR_lib_error_string(e)
unsigned long e;
d438 1
a438 2
char *ERR_func_error_string(e)
unsigned long e;
d459 1
a459 2
char *ERR_reason_error_string(e)
unsigned long e;
d486 1
a486 2
static unsigned long err_hash(a)
ERR_STRING_DATA *a;
d495 1
a495 2
static int err_cmp(a,b)
ERR_STRING_DATA *a,*b;
d500 1
a500 2
static unsigned long pid_hash(a)
ERR_STATE *a;
d505 1
a505 2
static int pid_cmp(a,b)
ERR_STATE *a,*b;
d510 1
a510 2
void ERR_remove_state(pid)
unsigned long pid;
d526 1
a526 1
ERR_STATE *ERR_get_state()
d542 1
d544 1
d582 1
a582 1
int ERR_get_next_error_library()
d589 1
a589 3
void ERR_set_error_data(data,flags)
char *data;
int flags;
d604 3
a606 4
void ERR_add_error_data( VAR_PLIST(int , num))
VAR_ALIST
        {
        VAR_BDEFN(args, int, num);
d615 1
a615 1
	VAR_INIT(args,int,num);
d619 4
a622 2
		VAR_ARG(args,char *,a);
		if (a != NULL) {
d641 1
a641 1
	VAR_END( args );
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d60 2
a61 4
#include <stdarg.h>
#include <string.h>
#include <openssl/lhash.h>
#include <openssl/crypto.h>
d63 3
a65 3
#include <openssl/buffer.h>
#include <openssl/bio.h>
#include <openssl/err.h>
a66 1
static void err_load_strings(int lib, ERR_STRING_DATA *str);
d68 10
d79 10
a88 1
#ifndef OPENSSL_NO_ERR
d98 1
d101 1
a101 1
{ERR_PACK(ERR_LIB_DSA,0,0)		,"dsa routines"},
d103 2
a104 4
{ERR_PACK(ERR_LIB_ASN1,0,0)		,"asn1 encoding routines"},
{ERR_PACK(ERR_LIB_CONF,0,0)		,"configuration file routines"},
{ERR_PACK(ERR_LIB_CRYPTO,0,0)		,"common libcrypto routines"},
{ERR_PACK(ERR_LIB_EC,0,0)		,"elliptic curve routines"},
d106 2
a109 6
{ERR_PACK(ERR_LIB_X509V3,0,0)		,"X509 V3 routines"},
{ERR_PACK(ERR_LIB_PKCS12,0,0)		,"PKCS12 routines"},
{ERR_PACK(ERR_LIB_RAND,0,0)		,"random number generator"},
{ERR_PACK(ERR_LIB_DSO,0,0)		,"DSO support routines"},
{ERR_PACK(ERR_LIB_ENGINE,0,0)		,"engine routines"},
{ERR_PACK(ERR_LIB_OCSP,0,0)		,"OCSP routines"},
d123 1
a123 1
#ifdef OPENSSL_SYS_WINDOWS
a125 1
	{ERR_PACK(0,SYS_F_OPENDIR,0),		"opendir"},
d131 1
d138 1
a140 1
{ERR_R_DSA_LIB				,"DSA lib"},
d142 1
a144 2
{ERR_R_CRYPTO_LIB			,"CRYPTO lib"},
{ERR_R_EC_LIB				,"EC lib"},
d146 1
d149 2
a150 20
{ERR_R_X509V3_LIB			,"X509V3 lib"},
{ERR_R_PKCS12_LIB			,"PKCS12 lib"},
{ERR_R_RAND_LIB				,"RAND lib"},
{ERR_R_DSO_LIB				,"DSO lib"},
{ERR_R_ENGINE_LIB			,"ENGINE lib"},
{ERR_R_OCSP_LIB				,"OCSP lib"},

{ERR_R_NESTED_ASN1_ERROR		,"nested asn1 error"},
{ERR_R_BAD_ASN1_OBJECT_HEADER		,"bad asn1 object header"},
{ERR_R_BAD_GET_ASN1_OBJECT_CALL		,"bad get asn1 object call"},
{ERR_R_EXPECTING_AN_ASN1_SEQUENCE	,"expecting an asn1 sequence"},
{ERR_R_ASN1_LENGTH_MISMATCH		,"asn1 length mismatch"},
{ERR_R_MISSING_ASN1_EOS			,"missing asn1 eos"},

{ERR_R_FATAL                            ,"fatal"},
{ERR_R_MALLOC_FAILURE			,"malloc failure"},
{ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED	,"called a function you should not call"},
{ERR_R_PASSED_NULL_PARAMETER		,"passed a null parameter"},
{ERR_R_INTERNAL_ERROR			,"internal error"},

a152 331


/* Define the predeclared (but externally opaque) "ERR_FNS" type */
struct st_ERR_FNS
	{
	/* Works on the "error_hash" string table */
	LHASH *(*cb_err_get)(int create);
	void (*cb_err_del)(void);
	ERR_STRING_DATA *(*cb_err_get_item)(const ERR_STRING_DATA *);
	ERR_STRING_DATA *(*cb_err_set_item)(ERR_STRING_DATA *);
	ERR_STRING_DATA *(*cb_err_del_item)(ERR_STRING_DATA *);
	/* Works on the "thread_hash" error-state table */
	LHASH *(*cb_thread_get)(int create);
	ERR_STATE *(*cb_thread_get_item)(const ERR_STATE *);
	ERR_STATE *(*cb_thread_set_item)(ERR_STATE *);
	void (*cb_thread_del_item)(const ERR_STATE *);
	/* Returns the next available error "library" numbers */
	int (*cb_get_next_lib)(void);
	};

/* Predeclarations of the "err_defaults" functions */
static LHASH *int_err_get(int create);
static void int_err_del(void);
static ERR_STRING_DATA *int_err_get_item(const ERR_STRING_DATA *);
static ERR_STRING_DATA *int_err_set_item(ERR_STRING_DATA *);
static ERR_STRING_DATA *int_err_del_item(ERR_STRING_DATA *);
static LHASH *int_thread_get(int create);
static ERR_STATE *int_thread_get_item(const ERR_STATE *);
static ERR_STATE *int_thread_set_item(ERR_STATE *);
static void int_thread_del_item(const ERR_STATE *);
static int int_err_get_next_lib(void);
/* The static ERR_FNS table using these defaults functions */
static const ERR_FNS err_defaults =
	{
	int_err_get,
	int_err_del,
	int_err_get_item,
	int_err_set_item,
	int_err_del_item,
	int_thread_get,
	int_thread_get_item,
	int_thread_set_item,
	int_thread_del_item,
	int_err_get_next_lib
	};

/* The replacable table of ERR_FNS functions we use at run-time */
static const ERR_FNS *err_fns = NULL;

/* Eg. rather than using "err_get()", use "ERRFN(err_get)()". */
#define ERRFN(a) err_fns->cb_##a

/* The internal state used by "err_defaults" - as such, the setting, reading,
 * creating, and deleting of this data should only be permitted via the
 * "err_defaults" functions. This way, a linked module can completely defer all
 * ERR state operation (together with requisite locking) to the implementations
 * and state in the loading application. */
static LHASH *int_error_hash = NULL;
static LHASH *int_thread_hash = NULL;
static int int_err_library_number= ERR_LIB_USER;

/* Internal function that checks whether "err_fns" is set and if not, sets it to
 * the defaults. */
static void err_fns_check(void)
	{
	if (err_fns) return;
	
	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (!err_fns)
		err_fns = &err_defaults;
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	}

/* API functions to get or set the underlying ERR functions. */

const ERR_FNS *ERR_get_implementation(void)
	{
	err_fns_check();
	return err_fns;
	}

int ERR_set_implementation(const ERR_FNS *fns)
	{
	int ret = 0;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	/* It's too late if 'err_fns' is non-NULL. BTW: not much point setting
	 * an error is there?! */
	if (!err_fns)
		{
		err_fns = fns;
		ret = 1;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	return ret;
	}

/* These are the callbacks provided to "lh_new()" when creating the LHASH tables
 * internal to the "err_defaults" implementation. */

/* static unsigned long err_hash(ERR_STRING_DATA *a); */
static unsigned long err_hash(const void *a_void);
/* static int err_cmp(ERR_STRING_DATA *a, ERR_STRING_DATA *b); */
static int err_cmp(const void *a_void, const void *b_void);
/* static unsigned long pid_hash(ERR_STATE *pid); */
static unsigned long pid_hash(const void *pid_void);
/* static int pid_cmp(ERR_STATE *a,ERR_STATE *pid); */
static int pid_cmp(const void *a_void,const void *pid_void);
static unsigned long get_error_values(int inc,int top,const char **file,int *line,
				      const char **data,int *flags);

/* The internal functions used in the "err_defaults" implementation */

static LHASH *int_err_get(int create)
	{
	LHASH *ret = NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (!int_error_hash && create)
		{
		CRYPTO_push_info("int_err_get (err.c)");
		int_error_hash = lh_new(err_hash, err_cmp);
		CRYPTO_pop_info();
		}
	if (int_error_hash)
		ret = int_error_hash;
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return ret;
	}

static void int_err_del(void)
	{
	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (int_error_hash)
		{
		lh_free(int_error_hash);
		int_error_hash = NULL;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	}

static ERR_STRING_DATA *int_err_get_item(const ERR_STRING_DATA *d)
	{
	ERR_STRING_DATA *p;
	LHASH *hash;

	err_fns_check();
	hash = ERRFN(err_get)(0);
	if (!hash)
		return NULL;

	CRYPTO_r_lock(CRYPTO_LOCK_ERR);
	p = (ERR_STRING_DATA *)lh_retrieve(hash, d);
	CRYPTO_r_unlock(CRYPTO_LOCK_ERR);

	return p;
	}

static ERR_STRING_DATA *int_err_set_item(ERR_STRING_DATA *d)
	{
	ERR_STRING_DATA *p;
	LHASH *hash;

	err_fns_check();
	hash = ERRFN(err_get)(1);
	if (!hash)
		return NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = (ERR_STRING_DATA *)lh_insert(hash, d);
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return p;
	}

static ERR_STRING_DATA *int_err_del_item(ERR_STRING_DATA *d)
	{
	ERR_STRING_DATA *p;
	LHASH *hash;

	err_fns_check();
	hash = ERRFN(err_get)(0);
	if (!hash)
		return NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = (ERR_STRING_DATA *)lh_delete(hash, d);
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return p;
	}

static LHASH *int_thread_get(int create)
	{
	LHASH *ret = NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (!int_thread_hash && create)
		{
		CRYPTO_push_info("int_thread_get (err.c)");
		int_thread_hash = lh_new(pid_hash, pid_cmp);
		CRYPTO_pop_info();
		}
	if (int_thread_hash)
		ret = int_thread_hash;
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	return ret;
	}

static ERR_STATE *int_thread_get_item(const ERR_STATE *d)
	{
	ERR_STATE *p;
	LHASH *hash;

	err_fns_check();
	hash = ERRFN(thread_get)(0);
	if (!hash)
		return NULL;

	CRYPTO_r_lock(CRYPTO_LOCK_ERR);
	p = (ERR_STATE *)lh_retrieve(hash, d);
	CRYPTO_r_unlock(CRYPTO_LOCK_ERR);

	return p;
	}

static ERR_STATE *int_thread_set_item(ERR_STATE *d)
	{
	ERR_STATE *p;
	LHASH *hash;

	err_fns_check();
	hash = ERRFN(thread_get)(1);
	if (!hash)
		return NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = (ERR_STATE *)lh_insert(hash, d);
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return p;
	}

static void int_thread_del_item(const ERR_STATE *d)
	{
	ERR_STATE *p;
	LHASH *hash;

	err_fns_check();
	hash = ERRFN(thread_get)(0);
	if (!hash)
		return;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = (ERR_STATE *)lh_delete(hash, d);
	/* make sure we don't leak memory */
	if (int_thread_hash && (lh_num_items(int_thread_hash) == 0))
		{
		lh_free(int_thread_hash);
		int_thread_hash = NULL;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	if (p)
		ERR_STATE_free(p);
	}

static int int_err_get_next_lib(void)
	{
	int ret;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	ret = int_err_library_number++;
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return ret;
	}


#define NUM_SYS_STR_REASONS 127
#define LEN_SYS_STR_REASON 32

static ERR_STRING_DATA SYS_str_reasons[NUM_SYS_STR_REASONS + 1];
/* SYS_str_reasons is filled with copies of strerror() results at
 * initialization.
 * 'errno' values up to 127 should cover all usual errors,
 * others will be displayed numerically by ERR_error_string.
 * It is crucial that we have something for each reason code
 * that occurs in ERR_str_reasons, or bogus reason strings
 * will be returned for SYSerr(), which always gets an errno
 * value and never one of those 'standard' reason codes. */

static void build_SYS_str_reasons()
	{
	/* OPENSSL_malloc cannot be used here, use static storage instead */
	static char strerror_tab[NUM_SYS_STR_REASONS][LEN_SYS_STR_REASON];
	int i;
	static int init = 1;

	if (!init) return;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);

	for (i = 1; i <= NUM_SYS_STR_REASONS; i++)
		{
		ERR_STRING_DATA *str = &SYS_str_reasons[i - 1];

		str->error = (unsigned long)i;
		if (str->string == NULL)
			{
			char (*dest)[LEN_SYS_STR_REASON] = &(strerror_tab[i - 1]);
			char *src = strerror(i);
			if (src != NULL)
				{
				strncpy(*dest, src, sizeof *dest);
				(*dest)[sizeof *dest - 1] = '\0';
				str->string = *dest;
				}
			}
		if (str->string == NULL)
			str->string = "unknown";
		}

	/* Now we still have SYS_str_reasons[NUM_SYS_STR_REASONS] = {0, NULL},
	 * as required by ERR_load_strings. */

	init = 0;
	
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	}
d159 1
a159 1
		OPENSSL_free((p)->err_data[i]); \
d164 2
a165 1
static void ERR_STATE_free(ERR_STATE *s)
a168 3
	if (s == NULL)
	    return;

d173 1
a173 1
	OPENSSL_free(s);
d176 1
a176 1
void ERR_load_ERR_strings(void)
d178 17
a194 7
	err_fns_check();
#ifndef OPENSSL_NO_ERR
	err_load_strings(0,ERR_str_libraries);
	err_load_strings(0,ERR_str_reasons);
	err_load_strings(ERR_LIB_SYS,ERR_str_functs);
	build_SYS_str_reasons();
	err_load_strings(ERR_LIB_SYS,SYS_str_reasons);
d196 1
d199 19
a217 2
static void err_load_strings(int lib, ERR_STRING_DATA *str)
	{
d221 1
a221 1
		ERRFN(err_set_item)(str);
d224 1
d227 1
a227 1
void ERR_load_strings(int lib, ERR_STRING_DATA *str)
d229 1
a229 3
	ERR_load_ERR_strings();
	err_load_strings(lib, str);
	}
d231 1
a231 3
void ERR_unload_strings(int lib, ERR_STRING_DATA *str)
	{
	while (str->error)
d233 2
a234 3
		str->error|=ERR_PACK(lib,0,0);
		ERRFN(err_del_item)(str);
		str++;
a235 1
	}
d237 1
a237 4
void ERR_free_strings(void)
	{
	err_fns_check();
	ERRFN(err_del)();
d242 4
a245 2
void ERR_put_error(int lib, int func, int reason, const char *file,
	     int line)
a248 19
#ifdef _OSD_POSIX
	/* In the BS2000-OSD POSIX subsystem, the compiler generates
	 * path names in the form "*POSIX(/etc/passwd)".
	 * This dirty hack strips them to something sensible.
	 * @@@@@@ We shouldn't modify a const string, though.
	 */
	if (strncmp(file,"*POSIX(", sizeof("*POSIX(")-1) == 0) {
		char *end;

		/* Skip the "*POSIX(" prefix */
		file += sizeof("*POSIX(")-1;
		end = &file[strlen(file)-1];
		if (*end == ')')
			*end = '\0';
		/* Optional: use the basename of the path only. */
		if ((end = strrchr(file, '/')) != NULL)
			file = &end[1];
	}
#endif
d260 1
a260 1
void ERR_clear_error(void)
a261 1
	int i;
d266 2
a270 1
		err_clear_data(es,i);
d273 1
d275 1
d280 2
a281 14
unsigned long ERR_get_error(void)
	{ return(get_error_values(1,0,NULL,NULL,NULL,NULL)); }

unsigned long ERR_get_error_line(const char **file,
	     int *line)
	{ return(get_error_values(1,0,file,line,NULL,NULL)); }

unsigned long ERR_get_error_line_data(const char **file, int *line,
	     const char **data, int *flags)
	{ return(get_error_values(1,0,file,line,data,flags)); }


unsigned long ERR_peek_error(void)
	{ return(get_error_values(0,0,NULL,NULL,NULL,NULL)); }
d283 33
a315 21
unsigned long ERR_peek_error_line(const char **file, int *line)
	{ return(get_error_values(0,0,file,line,NULL,NULL)); }

unsigned long ERR_peek_error_line_data(const char **file, int *line,
	     const char **data, int *flags)
	{ return(get_error_values(0,0,file,line,data,flags)); }


unsigned long ERR_peek_last_error(void)
	{ return(get_error_values(0,1,NULL,NULL,NULL,NULL)); }

unsigned long ERR_peek_last_error_line(const char **file, int *line)
	{ return(get_error_values(0,1,file,line,NULL,NULL)); }

unsigned long ERR_peek_last_error_line_data(const char **file, int *line,
	     const char **data, int *flags)
	{ return(get_error_values(0,1,file,line,data,flags)); }


static unsigned long get_error_values(int inc, int top, const char **file, int *line,
	     const char **data, int *flags)
d323 2
a324 15
	if (inc && top)
		{
		if (file) *file = "";
		if (line) *line = 0;
		if (data) *data = "";
		if (flags) *flags = 0;
			
		return ERR_R_INTERNAL_ERROR;
		}

	if (es->bottom == es->top) return 0;
	if (top)
		i=es->top;			 /* last error */
	else
		i=(es->bottom+1)%ERR_NUM_ERRORS; /* first error */
d347 1
a347 8
	if (data == NULL)
		{
		if (inc)
			{
			err_clear_data(es, i);
			}
		}
	else
d360 1
a360 1
	return ret;
d363 4
a366 1
void ERR_error_string_n(unsigned long e, char *buf, size_t len)
d368 2
a369 2
	char lsbuf[64], fsbuf[64], rsbuf[64];
	const char *ls,*fs,*rs;
d371 1
d381 8
a388 2
	if (ls == NULL) 
		BIO_snprintf(lsbuf, sizeof(lsbuf), "lib(%lu)", l);
d390 3
a392 1
		BIO_snprintf(fsbuf, sizeof(fsbuf), "func(%lu)", f);
d394 2
a395 39
		BIO_snprintf(rsbuf, sizeof(rsbuf), "reason(%lu)", r);

	BIO_snprintf(buf, len,"error:%08lX:%s:%s:%s", e, ls?ls:lsbuf, 
		fs?fs:fsbuf, rs?rs:rsbuf);
	if (strlen(buf) == len-1)
		{
		/* output may be truncated; make sure we always have 5 
		 * colon-separated fields, i.e. 4 colons ... */
#define NUM_COLONS 4
		if (len > NUM_COLONS) /* ... if possible */
			{
			int i;
			char *s = buf;
			
			for (i = 0; i < NUM_COLONS; i++)
				{
				char *colon = strchr(s, ':');
				if (colon == NULL || colon > &buf[len-1] - NUM_COLONS + i)
					{
					/* set colon no. i at last possible position
					 * (buf[len-1] is the terminating 0)*/
					colon = &buf[len-1] - NUM_COLONS + i;
					*colon = ':';
					}
				s = colon + 1;
				}
			}
		}
	}

/* BAD for multi-threading: uses a local buffer if ret == NULL */
/* ERR_error_string_n should be used instead for ret != NULL
 * as ERR_error_string cannot know how large the buffer is */
char *ERR_error_string(unsigned long e, char *ret)
	{
	static char buf[256];

	if (ret == NULL) ret=buf;
	ERR_error_string_n(e, ret, 256);
d397 1
a397 1
	return ret;
d400 1
a400 1
LHASH *ERR_get_string_table(void)
d402 1
a402 2
	err_fns_check();
	return ERRFN(err_get)(0);
d405 1
a405 1
LHASH *ERR_get_err_state_table(void)
d407 1
a407 2
	err_fns_check();
	return ERRFN(thread_get)(0);
d410 2
a411 1
const char *ERR_lib_error_string(unsigned long e)
d413 1
a413 1
	ERR_STRING_DATA d,*p;
a415 1
	err_fns_check();
d417 11
a427 2
	d.error=ERR_PACK(l,0,0);
	p=ERRFN(err_get_item)(&d);
d431 2
a432 1
const char *ERR_func_error_string(unsigned long e)
d434 1
a434 1
	ERR_STRING_DATA d,*p;
a436 1
	err_fns_check();
d439 11
a449 2
	d.error=ERR_PACK(l,f,0);
	p=ERRFN(err_get_item)(&d);
d453 2
a454 1
const char *ERR_reason_error_string(unsigned long e)
a458 1
	err_fns_check();
d461 4
a464 3
	d.error=ERR_PACK(l,0,r);
	p=ERRFN(err_get_item)(&d);
	if (!p)
d466 8
a473 2
		d.error=ERR_PACK(0,0,r);
		p=ERRFN(err_get_item)(&d);
d475 3
d481 2
a482 2
/* static unsigned long err_hash(ERR_STRING_DATA *a) */
static unsigned long err_hash(const void *a_void)
d486 1
a486 1
	l=((ERR_STRING_DATA *)a_void)->error;
d491 2
a492 2
/* static int err_cmp(ERR_STRING_DATA *a, ERR_STRING_DATA *b) */
static int err_cmp(const void *a_void, const void *b_void)
d494 1
a494 2
	return((int)(((ERR_STRING_DATA *)a_void)->error -
			((ERR_STRING_DATA *)b_void)->error));
d497 2
a498 2
/* static unsigned long pid_hash(ERR_STATE *a) */
static unsigned long pid_hash(const void *a_void)
d500 1
a500 1
	return(((ERR_STATE *)a_void)->pid*13);
d503 2
a504 2
/* static int pid_cmp(ERR_STATE *a, ERR_STATE *b) */
static int pid_cmp(const void *a_void, const void *b_void)
d506 1
a506 2
	return((int)((long)((ERR_STATE *)a_void)->pid -
			(long)((ERR_STATE *)b_void)->pid));
d509 2
a510 1
void ERR_remove_state(unsigned long pid)
d512 1
a512 1
	ERR_STATE tmp;
d514 2
a515 1
	err_fns_check();
d519 5
a523 3
	/* thread_del_item automatically destroys the LHASH if the number of
	 * items reaches zero. */
	ERRFN(thread_del_item)(&tmp);
d526 1
a526 1
ERR_STATE *ERR_get_state(void)
d529 1
a529 1
	ERR_STATE *ret,tmp,*tmpp=NULL;
a532 1
	err_fns_check();
d534 21
a554 2
	tmp.pid=pid;
	ret=ERRFN(thread_get_item)(&tmp);
d559 1
a559 1
		ret=(ERR_STATE *)OPENSSL_malloc(sizeof(ERR_STATE));
d569 4
a572 3
		tmpp = ERRFN(thread_set_item)(ret);
		/* To check if insertion failed, do a get. */
		if (ERRFN(thread_get_item)(ret) != ret)
d574 1
a574 2
			ERR_STATE_free(ret); /* could not insert it */
			return(&fallback);
a575 4
		/* If a race occured in this function and we came second, tmpp
		 * is the first one that we just replaced. */
		if (tmpp)
			ERR_STATE_free(tmpp);
d577 1
a577 1
	return ret;
d580 1
a580 1
int ERR_get_next_error_library(void)
d582 3
a584 2
	err_fns_check();
	return ERRFN(get_next_lib)();
d587 3
a589 1
void ERR_set_error_data(char *data, int flags)
a599 1
	err_clear_data(es,i);
d601 1
a601 1
	es->err_data_flags[i]=flags;
d604 4
a607 3
void ERR_add_error_data(int num, ...)
	{
	va_list args;
d611 2
a612 2
	s=80;
	str=OPENSSL_malloc(s+1);
d616 1
a616 1
	va_start(args, num);
d620 2
a621 4
		a=va_arg(args, char*);
		/* ignore NULLs, thanks to Bob Beck <beck@@obtuse.com> */
		if (a != NULL)
			{
d626 1
a626 1
				p=OPENSSL_realloc(str,s+1);
d629 2
a630 2
					OPENSSL_free(str);
					goto err;
d640 1
a640 2
err:
	va_end(args);
d642 1
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a168 1
	{ERR_PACK(0,SYS_F_FREAD,0),		"fread"},
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@a213 1
#endif
a493 1
#ifndef OPENSSL_NO_ERR
@


1.1.1.5
log
@import 0.9.7c
@
text
@a227 1
	void (*cb_thread_release)(LHASH **hash);
a241 1
static void int_thread_release(LHASH **hash);
a254 1
	int_thread_release,
a273 1
static int int_thread_hash_references = 0;
a419 2
		{
		int_thread_hash_references++;
a420 1
		}
a424 23
static void int_thread_release(LHASH **hash)
	{
	int i;

	if (hash == NULL || *hash == NULL)
		return;

	i = CRYPTO_add(&int_thread_hash_references, -1, CRYPTO_LOCK_ERR);

#ifdef REF_PRINT
	fprintf(stderr,"%4d:%s\n",int_thread_hash_references,"ERR");
#endif
	if (i > 0) return;
#ifdef REF_CHECK
	if (i < 0)
		{
		fprintf(stderr,"int_thread_release, bad reference count\n");
		abort(); /* ok */
		}
#endif
	*hash = NULL;
	}

a438 1
	ERRFN(thread_release)(&hash);
a455 1
	ERRFN(thread_release)(&hash);
d472 1
a472 2
	if (int_thread_hash_references == 1
		&& int_thread_hash && (lh_num_items(int_thread_hash) == 0))
a478 1
	ERRFN(thread_release)(&hash);
a845 6
	}

void ERR_release_err_state_table(LHASH **hash)
	{
	err_fns_check();
	ERRFN(thread_release)(hash);
@


1.1.1.6
log
@import openssl-0.9.7d
@
text
@d1068 1
a1068 1
			BUF_strlcat(str,a,s+1);
@


1.1.1.7
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a151 1
{ERR_PACK(ERR_LIB_FIPS,0,0)		,"FIPS routines"},
a169 1
	{ERR_PACK(0,SYS_F_GETADDRINFO,0),	"getaddrinfo"},
@


1.1.1.8
log
@import of openssl-0.9.7j
@
text
@d624 1
a624 2
		if (lib)
			str->error|=ERR_PACK(lib,0,0);
d640 1
a640 2
		if (lib)
			str->error|=ERR_PACK(lib,0,0);
@


1.1.1.9
log
@import of OpenSSL 0.9.8h
@
text
@a114 1
#include "cryptlib.h"
d117 1
d152 1
a152 1
{ERR_PACK(ERR_LIB_CMS,0,0)		,"CMS routines"},
d171 1
a212 1
{ERR_R_DISABLED				,"called a function that was disabled at compile-time"},
d545 1
a545 1
static void build_SYS_str_reasons(void)
d552 2
a553 8
	CRYPTO_r_lock(CRYPTO_LOCK_ERR);
	if (!init)
		{
		CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
		return;
		}
	
	CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
a554 5
	if (!init)
		{
		CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
		return;
		}
a585 1
	do { \
d592 1
a592 11
	(p)->err_data_flags[i]=0; \
	} while(0)

#define err_clear(p,i) \
	do { \
	(p)->err_flags[i]=0; \
	(p)->err_buffer[i]=0; \
	err_clear_data(p,i); \
	(p)->err_file[i]=NULL; \
	(p)->err_line[i]= -1; \
	} while(0)
a684 1
	es->err_flags[es->top]=0;
d700 4
a703 1
		err_clear(es,i);
d940 1
a940 1
	l=((const ERR_STRING_DATA *)a_void)->error;
d948 2
a949 2
	return((int)(((const ERR_STRING_DATA *)a_void)->error -
			((const ERR_STRING_DATA *)b_void)->error));
d955 1
a955 1
	return(((const ERR_STATE *)a_void)->pid*13);
d961 2
a962 2
	return((int)((long)((const ERR_STATE *)a_void)->pid -
			(long)((const ERR_STATE *)b_void)->pid));
d1072 1
a1072 1
			BUF_strlcat(str,a,(size_t)s+1);
a1078 30
	}

int ERR_set_mark(void)
	{
	ERR_STATE *es;

	es=ERR_get_state();

	if (es->bottom == es->top) return 0;
	es->err_flags[es->top]|=ERR_FLAG_MARK;
	return 1;
	}

int ERR_pop_to_mark(void)
	{
	ERR_STATE *es;

	es=ERR_get_state();

	while(es->bottom != es->top
		&& (es->err_flags[es->top] & ERR_FLAG_MARK) == 0)
		{
		err_clear(es,es->top);
		es->top-=1;
		if (es->top == -1) es->top=ERR_NUM_ERRORS-1;
		}
		
	if (es->bottom == es->top) return 0;
	es->err_flags[es->top]&=~ERR_FLAG_MARK;
	return 1;
@


1.1.1.10
log
@import openssl-0.9.8j
@
text
@d122 473
a594 3
static unsigned long get_error_values(int inc,int top,
					const char **file,int *line,
					const char **data,int *flags);
d616 62
d832 212
a1129 31

#ifdef OPENSSL_FIPS

static ERR_STATE *fget_state(void)
	{
	static ERR_STATE fstate;
	return &fstate;
	}

ERR_STATE *(*get_state_func)(void) = fget_state;
void (*remove_state_func)(unsigned long pid);

ERR_STATE *ERR_get_state(void)
	{
	return get_state_func();
	}

void int_ERR_set_state_func(ERR_STATE *(*get_func)(void),
				void (*remove_func)(unsigned long pid))
	{
	get_state_func = get_func;
	remove_state_func = remove_func;
	}

void ERR_remove_state(unsigned long pid)
	{
	if (remove_state_func)
		remove_state_func(pid);
	}

#endif
@


1.1.1.11
log
@import OpenSSL-1.0.0a
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
d122 3
a124 501
DECLARE_LHASH_OF(ERR_STRING_DATA);
DECLARE_LHASH_OF(ERR_STATE);

static void err_load_strings(int lib, ERR_STRING_DATA *str);

static void ERR_STATE_free(ERR_STATE *s);
#ifndef OPENSSL_NO_ERR
static ERR_STRING_DATA ERR_str_libraries[]=
	{
{ERR_PACK(ERR_LIB_NONE,0,0)		,"unknown library"},
{ERR_PACK(ERR_LIB_SYS,0,0)		,"system library"},
{ERR_PACK(ERR_LIB_BN,0,0)		,"bignum routines"},
{ERR_PACK(ERR_LIB_RSA,0,0)		,"rsa routines"},
{ERR_PACK(ERR_LIB_DH,0,0)		,"Diffie-Hellman routines"},
{ERR_PACK(ERR_LIB_EVP,0,0)		,"digital envelope routines"},
{ERR_PACK(ERR_LIB_BUF,0,0)		,"memory buffer routines"},
{ERR_PACK(ERR_LIB_OBJ,0,0)		,"object identifier routines"},
{ERR_PACK(ERR_LIB_PEM,0,0)		,"PEM routines"},
{ERR_PACK(ERR_LIB_DSA,0,0)		,"dsa routines"},
{ERR_PACK(ERR_LIB_X509,0,0)		,"x509 certificate routines"},
{ERR_PACK(ERR_LIB_ASN1,0,0)		,"asn1 encoding routines"},
{ERR_PACK(ERR_LIB_CONF,0,0)		,"configuration file routines"},
{ERR_PACK(ERR_LIB_CRYPTO,0,0)		,"common libcrypto routines"},
{ERR_PACK(ERR_LIB_EC,0,0)		,"elliptic curve routines"},
{ERR_PACK(ERR_LIB_SSL,0,0)		,"SSL routines"},
{ERR_PACK(ERR_LIB_BIO,0,0)		,"BIO routines"},
{ERR_PACK(ERR_LIB_PKCS7,0,0)		,"PKCS7 routines"},
{ERR_PACK(ERR_LIB_X509V3,0,0)		,"X509 V3 routines"},
{ERR_PACK(ERR_LIB_PKCS12,0,0)		,"PKCS12 routines"},
{ERR_PACK(ERR_LIB_RAND,0,0)		,"random number generator"},
{ERR_PACK(ERR_LIB_DSO,0,0)		,"DSO support routines"},
{ERR_PACK(ERR_LIB_TS,0,0)		,"time stamp routines"},
{ERR_PACK(ERR_LIB_ENGINE,0,0)		,"engine routines"},
{ERR_PACK(ERR_LIB_OCSP,0,0)		,"OCSP routines"},
{ERR_PACK(ERR_LIB_FIPS,0,0)		,"FIPS routines"},
{ERR_PACK(ERR_LIB_CMS,0,0)		,"CMS routines"},
{ERR_PACK(ERR_LIB_HMAC,0,0)		,"HMAC routines"},
{0,NULL},
	};

static ERR_STRING_DATA ERR_str_functs[]=
	{
	{ERR_PACK(0,SYS_F_FOPEN,0),     	"fopen"},
	{ERR_PACK(0,SYS_F_CONNECT,0),		"connect"},
	{ERR_PACK(0,SYS_F_GETSERVBYNAME,0),	"getservbyname"},
	{ERR_PACK(0,SYS_F_SOCKET,0),		"socket"}, 
	{ERR_PACK(0,SYS_F_IOCTLSOCKET,0),	"ioctlsocket"},
	{ERR_PACK(0,SYS_F_BIND,0),		"bind"},
	{ERR_PACK(0,SYS_F_LISTEN,0),		"listen"},
	{ERR_PACK(0,SYS_F_ACCEPT,0),		"accept"},
#ifdef OPENSSL_SYS_WINDOWS
	{ERR_PACK(0,SYS_F_WSASTARTUP,0),	"WSAstartup"},
#endif
	{ERR_PACK(0,SYS_F_OPENDIR,0),		"opendir"},
	{ERR_PACK(0,SYS_F_FREAD,0),		"fread"},
	{0,NULL},
	};

static ERR_STRING_DATA ERR_str_reasons[]=
	{
{ERR_R_SYS_LIB				,"system lib"},
{ERR_R_BN_LIB				,"BN lib"},
{ERR_R_RSA_LIB				,"RSA lib"},
{ERR_R_DH_LIB				,"DH lib"},
{ERR_R_EVP_LIB				,"EVP lib"},
{ERR_R_BUF_LIB				,"BUF lib"},
{ERR_R_OBJ_LIB				,"OBJ lib"},
{ERR_R_PEM_LIB				,"PEM lib"},
{ERR_R_DSA_LIB				,"DSA lib"},
{ERR_R_X509_LIB				,"X509 lib"},
{ERR_R_ASN1_LIB				,"ASN1 lib"},
{ERR_R_CONF_LIB				,"CONF lib"},
{ERR_R_CRYPTO_LIB			,"CRYPTO lib"},
{ERR_R_EC_LIB				,"EC lib"},
{ERR_R_SSL_LIB				,"SSL lib"},
{ERR_R_BIO_LIB				,"BIO lib"},
{ERR_R_PKCS7_LIB			,"PKCS7 lib"},
{ERR_R_X509V3_LIB			,"X509V3 lib"},
{ERR_R_PKCS12_LIB			,"PKCS12 lib"},
{ERR_R_RAND_LIB				,"RAND lib"},
{ERR_R_DSO_LIB				,"DSO lib"},
{ERR_R_ENGINE_LIB			,"ENGINE lib"},
{ERR_R_OCSP_LIB				,"OCSP lib"},
{ERR_R_TS_LIB				,"TS lib"},

{ERR_R_NESTED_ASN1_ERROR		,"nested asn1 error"},
{ERR_R_BAD_ASN1_OBJECT_HEADER		,"bad asn1 object header"},
{ERR_R_BAD_GET_ASN1_OBJECT_CALL		,"bad get asn1 object call"},
{ERR_R_EXPECTING_AN_ASN1_SEQUENCE	,"expecting an asn1 sequence"},
{ERR_R_ASN1_LENGTH_MISMATCH		,"asn1 length mismatch"},
{ERR_R_MISSING_ASN1_EOS			,"missing asn1 eos"},

{ERR_R_FATAL                            ,"fatal"},
{ERR_R_MALLOC_FAILURE			,"malloc failure"},
{ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED	,"called a function you should not call"},
{ERR_R_PASSED_NULL_PARAMETER		,"passed a null parameter"},
{ERR_R_INTERNAL_ERROR			,"internal error"},
{ERR_R_DISABLED				,"called a function that was disabled at compile-time"},

{0,NULL},
	};
#endif


/* Define the predeclared (but externally opaque) "ERR_FNS" type */
struct st_ERR_FNS
	{
	/* Works on the "error_hash" string table */
	LHASH_OF(ERR_STRING_DATA) *(*cb_err_get)(int create);
	void (*cb_err_del)(void);
	ERR_STRING_DATA *(*cb_err_get_item)(const ERR_STRING_DATA *);
	ERR_STRING_DATA *(*cb_err_set_item)(ERR_STRING_DATA *);
	ERR_STRING_DATA *(*cb_err_del_item)(ERR_STRING_DATA *);
	/* Works on the "thread_hash" error-state table */
	LHASH_OF(ERR_STATE) *(*cb_thread_get)(int create);
	void (*cb_thread_release)(LHASH_OF(ERR_STATE) **hash);
	ERR_STATE *(*cb_thread_get_item)(const ERR_STATE *);
	ERR_STATE *(*cb_thread_set_item)(ERR_STATE *);
	void (*cb_thread_del_item)(const ERR_STATE *);
	/* Returns the next available error "library" numbers */
	int (*cb_get_next_lib)(void);
	};

/* Predeclarations of the "err_defaults" functions */
static LHASH_OF(ERR_STRING_DATA) *int_err_get(int create);
static void int_err_del(void);
static ERR_STRING_DATA *int_err_get_item(const ERR_STRING_DATA *);
static ERR_STRING_DATA *int_err_set_item(ERR_STRING_DATA *);
static ERR_STRING_DATA *int_err_del_item(ERR_STRING_DATA *);
static LHASH_OF(ERR_STATE) *int_thread_get(int create);
static void int_thread_release(LHASH_OF(ERR_STATE) **hash);
static ERR_STATE *int_thread_get_item(const ERR_STATE *);
static ERR_STATE *int_thread_set_item(ERR_STATE *);
static void int_thread_del_item(const ERR_STATE *);
static int int_err_get_next_lib(void);
/* The static ERR_FNS table using these defaults functions */
static const ERR_FNS err_defaults =
	{
	int_err_get,
	int_err_del,
	int_err_get_item,
	int_err_set_item,
	int_err_del_item,
	int_thread_get,
	int_thread_release,
	int_thread_get_item,
	int_thread_set_item,
	int_thread_del_item,
	int_err_get_next_lib
	};

/* The replacable table of ERR_FNS functions we use at run-time */
static const ERR_FNS *err_fns = NULL;

/* Eg. rather than using "err_get()", use "ERRFN(err_get)()". */
#define ERRFN(a) err_fns->cb_##a

/* The internal state used by "err_defaults" - as such, the setting, reading,
 * creating, and deleting of this data should only be permitted via the
 * "err_defaults" functions. This way, a linked module can completely defer all
 * ERR state operation (together with requisite locking) to the implementations
 * and state in the loading application. */
static LHASH_OF(ERR_STRING_DATA) *int_error_hash = NULL;
static LHASH_OF(ERR_STATE) *int_thread_hash = NULL;
static int int_thread_hash_references = 0;
static int int_err_library_number= ERR_LIB_USER;

/* Internal function that checks whether "err_fns" is set and if not, sets it to
 * the defaults. */
static void err_fns_check(void)
	{
	if (err_fns) return;
	
	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (!err_fns)
		err_fns = &err_defaults;
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	}

/* API functions to get or set the underlying ERR functions. */

const ERR_FNS *ERR_get_implementation(void)
	{
	err_fns_check();
	return err_fns;
	}

int ERR_set_implementation(const ERR_FNS *fns)
	{
	int ret = 0;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	/* It's too late if 'err_fns' is non-NULL. BTW: not much point setting
	 * an error is there?! */
	if (!err_fns)
		{
		err_fns = fns;
		ret = 1;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	return ret;
	}

/* These are the callbacks provided to "lh_new()" when creating the LHASH tables
 * internal to the "err_defaults" implementation. */

static unsigned long get_error_values(int inc,int top,const char **file,int *line,
				      const char **data,int *flags);

/* The internal functions used in the "err_defaults" implementation */

static unsigned long err_string_data_hash(const ERR_STRING_DATA *a)
	{
	unsigned long ret,l;

	l=a->error;
	ret=l^ERR_GET_LIB(l)^ERR_GET_FUNC(l);
	return(ret^ret%19*13);
	}
static IMPLEMENT_LHASH_HASH_FN(err_string_data, ERR_STRING_DATA)

static int err_string_data_cmp(const ERR_STRING_DATA *a,
			       const ERR_STRING_DATA *b)
	{
	return (int)(a->error - b->error);
	}
static IMPLEMENT_LHASH_COMP_FN(err_string_data, ERR_STRING_DATA)

static LHASH_OF(ERR_STRING_DATA) *int_err_get(int create)
	{
	LHASH_OF(ERR_STRING_DATA) *ret = NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (!int_error_hash && create)
		{
		CRYPTO_push_info("int_err_get (err.c)");
		int_error_hash = lh_ERR_STRING_DATA_new();
		CRYPTO_pop_info();
		}
	if (int_error_hash)
		ret = int_error_hash;
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return ret;
	}

static void int_err_del(void)
	{
	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (int_error_hash)
		{
		lh_ERR_STRING_DATA_free(int_error_hash);
		int_error_hash = NULL;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	}

static ERR_STRING_DATA *int_err_get_item(const ERR_STRING_DATA *d)
	{
	ERR_STRING_DATA *p;
	LHASH_OF(ERR_STRING_DATA) *hash;

	err_fns_check();
	hash = ERRFN(err_get)(0);
	if (!hash)
		return NULL;

	CRYPTO_r_lock(CRYPTO_LOCK_ERR);
	p = lh_ERR_STRING_DATA_retrieve(hash, d);
	CRYPTO_r_unlock(CRYPTO_LOCK_ERR);

	return p;
	}

static ERR_STRING_DATA *int_err_set_item(ERR_STRING_DATA *d)
	{
	ERR_STRING_DATA *p;
	LHASH_OF(ERR_STRING_DATA) *hash;

	err_fns_check();
	hash = ERRFN(err_get)(1);
	if (!hash)
		return NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = lh_ERR_STRING_DATA_insert(hash, d);
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return p;
	}

static ERR_STRING_DATA *int_err_del_item(ERR_STRING_DATA *d)
	{
	ERR_STRING_DATA *p;
	LHASH_OF(ERR_STRING_DATA) *hash;

	err_fns_check();
	hash = ERRFN(err_get)(0);
	if (!hash)
		return NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = lh_ERR_STRING_DATA_delete(hash, d);
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return p;
	}

static unsigned long err_state_hash(const ERR_STATE *a)
	{
	return CRYPTO_THREADID_hash(&a->tid) * 13;
	}
static IMPLEMENT_LHASH_HASH_FN(err_state, ERR_STATE)

static int err_state_cmp(const ERR_STATE *a, const ERR_STATE *b)
	{
	return CRYPTO_THREADID_cmp(&a->tid, &b->tid);
	}
static IMPLEMENT_LHASH_COMP_FN(err_state, ERR_STATE)

static LHASH_OF(ERR_STATE) *int_thread_get(int create)
	{
	LHASH_OF(ERR_STATE) *ret = NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (!int_thread_hash && create)
		{
		CRYPTO_push_info("int_thread_get (err.c)");
		int_thread_hash = lh_ERR_STATE_new();
		CRYPTO_pop_info();
		}
	if (int_thread_hash)
		{
		int_thread_hash_references++;
		ret = int_thread_hash;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	return ret;
	}

static void int_thread_release(LHASH_OF(ERR_STATE) **hash)
	{
	int i;

	if (hash == NULL || *hash == NULL)
		return;

	i = CRYPTO_add(&int_thread_hash_references, -1, CRYPTO_LOCK_ERR);

#ifdef REF_PRINT
	fprintf(stderr,"%4d:%s\n",int_thread_hash_references,"ERR");
#endif
	if (i > 0) return;
#ifdef REF_CHECK
	if (i < 0)
		{
		fprintf(stderr,"int_thread_release, bad reference count\n");
		abort(); /* ok */
		}
#endif
	*hash = NULL;
	}

static ERR_STATE *int_thread_get_item(const ERR_STATE *d)
	{
	ERR_STATE *p;
	LHASH_OF(ERR_STATE) *hash;

	err_fns_check();
	hash = ERRFN(thread_get)(0);
	if (!hash)
		return NULL;

	CRYPTO_r_lock(CRYPTO_LOCK_ERR);
	p = lh_ERR_STATE_retrieve(hash, d);
	CRYPTO_r_unlock(CRYPTO_LOCK_ERR);

	ERRFN(thread_release)(&hash);
	return p;
	}

static ERR_STATE *int_thread_set_item(ERR_STATE *d)
	{
	ERR_STATE *p;
	LHASH_OF(ERR_STATE) *hash;

	err_fns_check();
	hash = ERRFN(thread_get)(1);
	if (!hash)
		return NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = lh_ERR_STATE_insert(hash, d);
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	ERRFN(thread_release)(&hash);
	return p;
	}

static void int_thread_del_item(const ERR_STATE *d)
	{
	ERR_STATE *p;
	LHASH_OF(ERR_STATE) *hash;

	err_fns_check();
	hash = ERRFN(thread_get)(0);
	if (!hash)
		return;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	p = lh_ERR_STATE_delete(hash, d);
	/* make sure we don't leak memory */
	if (int_thread_hash_references == 1
	    && int_thread_hash && lh_ERR_STATE_num_items(int_thread_hash) == 0)
		{
		lh_ERR_STATE_free(int_thread_hash);
		int_thread_hash = NULL;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	ERRFN(thread_release)(&hash);
	if (p)
		ERR_STATE_free(p);
	}

static int int_err_get_next_lib(void)
	{
	int ret;

	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	ret = int_err_library_number++;
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);

	return ret;
	}


#ifndef OPENSSL_NO_ERR
#define NUM_SYS_STR_REASONS 127
#define LEN_SYS_STR_REASON 32

static ERR_STRING_DATA SYS_str_reasons[NUM_SYS_STR_REASONS + 1];
/* SYS_str_reasons is filled with copies of strerror() results at
 * initialization.
 * 'errno' values up to 127 should cover all usual errors,
 * others will be displayed numerically by ERR_error_string.
 * It is crucial that we have something for each reason code
 * that occurs in ERR_str_reasons, or bogus reason strings
 * will be returned for SYSerr(), which always gets an errno
 * value and never one of those 'standard' reason codes. */

static void build_SYS_str_reasons(void)
	{
	/* OPENSSL_malloc cannot be used here, use static storage instead */
	static char strerror_tab[NUM_SYS_STR_REASONS][LEN_SYS_STR_REASON];
	int i;
	static int init = 1;

	CRYPTO_r_lock(CRYPTO_LOCK_ERR);
	if (!init)
		{
		CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
		return;
		}
	
	CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
	CRYPTO_w_lock(CRYPTO_LOCK_ERR);
	if (!init)
		{
		CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
		return;
		}

	for (i = 1; i <= NUM_SYS_STR_REASONS; i++)
		{
		ERR_STRING_DATA *str = &SYS_str_reasons[i - 1];

		str->error = (unsigned long)i;
		if (str->string == NULL)
			{
			char (*dest)[LEN_SYS_STR_REASON] = &(strerror_tab[i - 1]);
			char *src = strerror(i);
			if (src != NULL)
				{
				strncpy(*dest, src, sizeof *dest);
				(*dest)[sizeof *dest - 1] = '\0';
				str->string = *dest;
				}
			}
		if (str->string == NULL)
			str->string = "unknown";
		}

	/* Now we still have SYS_str_reasons[NUM_SYS_STR_REASONS] = {0, NULL},
	 * as required by ERR_load_strings. */

	init = 0;
	
	CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
	}
#endif
a145 62
static void ERR_STATE_free(ERR_STATE *s)
	{
	int i;

	if (s == NULL)
	    return;

	for (i=0; i<ERR_NUM_ERRORS; i++)
		{
		err_clear_data(s,i);
		}
	OPENSSL_free(s);
	}

void ERR_load_ERR_strings(void)
	{
	err_fns_check();
#ifndef OPENSSL_NO_ERR
	err_load_strings(0,ERR_str_libraries);
	err_load_strings(0,ERR_str_reasons);
	err_load_strings(ERR_LIB_SYS,ERR_str_functs);
	build_SYS_str_reasons();
	err_load_strings(ERR_LIB_SYS,SYS_str_reasons);
#endif
	}

static void err_load_strings(int lib, ERR_STRING_DATA *str)
	{
	while (str->error)
		{
		if (lib)
			str->error|=ERR_PACK(lib,0,0);
		ERRFN(err_set_item)(str);
		str++;
		}
	}

void ERR_load_strings(int lib, ERR_STRING_DATA *str)
	{
	ERR_load_ERR_strings();
	err_load_strings(lib, str);
	}

void ERR_unload_strings(int lib, ERR_STRING_DATA *str)
	{
	while (str->error)
		{
		if (lib)
			str->error|=ERR_PACK(lib,0,0);
		ERRFN(err_del_item)(str);
		str++;
		}
	}

void ERR_free_strings(void)
	{
	err_fns_check();
	ERRFN(err_del)();
	}

/********************************************************/

a299 190
void ERR_error_string_n(unsigned long e, char *buf, size_t len)
	{
	char lsbuf[64], fsbuf[64], rsbuf[64];
	const char *ls,*fs,*rs;
	unsigned long l,f,r;

	l=ERR_GET_LIB(e);
	f=ERR_GET_FUNC(e);
	r=ERR_GET_REASON(e);

	ls=ERR_lib_error_string(e);
	fs=ERR_func_error_string(e);
	rs=ERR_reason_error_string(e);

	if (ls == NULL) 
		BIO_snprintf(lsbuf, sizeof(lsbuf), "lib(%lu)", l);
	if (fs == NULL)
		BIO_snprintf(fsbuf, sizeof(fsbuf), "func(%lu)", f);
	if (rs == NULL)
		BIO_snprintf(rsbuf, sizeof(rsbuf), "reason(%lu)", r);

	BIO_snprintf(buf, len,"error:%08lX:%s:%s:%s", e, ls?ls:lsbuf, 
		fs?fs:fsbuf, rs?rs:rsbuf);
	if (strlen(buf) == len-1)
		{
		/* output may be truncated; make sure we always have 5 
		 * colon-separated fields, i.e. 4 colons ... */
#define NUM_COLONS 4
		if (len > NUM_COLONS) /* ... if possible */
			{
			int i;
			char *s = buf;
			
			for (i = 0; i < NUM_COLONS; i++)
				{
				char *colon = strchr(s, ':');
				if (colon == NULL || colon > &buf[len-1] - NUM_COLONS + i)
					{
					/* set colon no. i at last possible position
					 * (buf[len-1] is the terminating 0)*/
					colon = &buf[len-1] - NUM_COLONS + i;
					*colon = ':';
					}
				s = colon + 1;
				}
			}
		}
	}

/* BAD for multi-threading: uses a local buffer if ret == NULL */
/* ERR_error_string_n should be used instead for ret != NULL
 * as ERR_error_string cannot know how large the buffer is */
char *ERR_error_string(unsigned long e, char *ret)
	{
	static char buf[256];

	if (ret == NULL) ret=buf;
	ERR_error_string_n(e, ret, 256);

	return ret;
	}

LHASH_OF(ERR_STRING_DATA) *ERR_get_string_table(void)
	{
	err_fns_check();
	return ERRFN(err_get)(0);
	}

LHASH_OF(ERR_STATE) *ERR_get_err_state_table(void)
	{
	err_fns_check();
	return ERRFN(thread_get)(0);
	}

void ERR_release_err_state_table(LHASH_OF(ERR_STATE) **hash)
	{
	err_fns_check();
	ERRFN(thread_release)(hash);
	}

const char *ERR_lib_error_string(unsigned long e)
	{
	ERR_STRING_DATA d,*p;
	unsigned long l;

	err_fns_check();
	l=ERR_GET_LIB(e);
	d.error=ERR_PACK(l,0,0);
	p=ERRFN(err_get_item)(&d);
	return((p == NULL)?NULL:p->string);
	}

const char *ERR_func_error_string(unsigned long e)
	{
	ERR_STRING_DATA d,*p;
	unsigned long l,f;

	err_fns_check();
	l=ERR_GET_LIB(e);
	f=ERR_GET_FUNC(e);
	d.error=ERR_PACK(l,f,0);
	p=ERRFN(err_get_item)(&d);
	return((p == NULL)?NULL:p->string);
	}

const char *ERR_reason_error_string(unsigned long e)
	{
	ERR_STRING_DATA d,*p=NULL;
	unsigned long l,r;

	err_fns_check();
	l=ERR_GET_LIB(e);
	r=ERR_GET_REASON(e);
	d.error=ERR_PACK(l,0,r);
	p=ERRFN(err_get_item)(&d);
	if (!p)
		{
		d.error=ERR_PACK(0,0,r);
		p=ERRFN(err_get_item)(&d);
		}
	return((p == NULL)?NULL:p->string);
	}

void ERR_remove_thread_state(const CRYPTO_THREADID *id)
	{
	ERR_STATE tmp;

	if (id)
		CRYPTO_THREADID_cpy(&tmp.tid, id);
	else
		CRYPTO_THREADID_current(&tmp.tid);
	err_fns_check();
	/* thread_del_item automatically destroys the LHASH if the number of
	 * items reaches zero. */
	ERRFN(thread_del_item)(&tmp);
	}

#ifndef OPENSSL_NO_DEPRECATED
void ERR_remove_state(unsigned long pid)
	{
	ERR_remove_thread_state(NULL);
	}
#endif

ERR_STATE *ERR_get_state(void)
	{
	static ERR_STATE fallback;
	ERR_STATE *ret,tmp,*tmpp=NULL;
	int i;
	CRYPTO_THREADID tid;

	err_fns_check();
	CRYPTO_THREADID_current(&tid);
	CRYPTO_THREADID_cpy(&tmp.tid, &tid);
	ret=ERRFN(thread_get_item)(&tmp);

	/* ret == the error state, if NULL, make a new one */
	if (ret == NULL)
		{
		ret=(ERR_STATE *)OPENSSL_malloc(sizeof(ERR_STATE));
		if (ret == NULL) return(&fallback);
		CRYPTO_THREADID_cpy(&ret->tid, &tid);
		ret->top=0;
		ret->bottom=0;
		for (i=0; i<ERR_NUM_ERRORS; i++)
			{
			ret->err_data[i]=NULL;
			ret->err_data_flags[i]=0;
			}
		tmpp = ERRFN(thread_set_item)(ret);
		/* To check if insertion failed, do a get. */
		if (ERRFN(thread_get_item)(ret) != ret)
			{
			ERR_STATE_free(ret); /* could not insert it */
			return(&fallback);
			}
		/* If a race occured in this function and we came second, tmpp
		 * is the first one that we just replaced. */
		if (tmpp)
			ERR_STATE_free(tmpp);
		}
	return ret;
	}

int ERR_get_next_error_library(void)
	{
	err_fns_check();
	return ERRFN(get_next_lib)();
	}

d386 31
@


1.1.1.12
log
@import OpenSSL-1.0.1c
@
text
@a1068 7
	va_start(args, num);
	ERR_add_error_vdata(num, args);
	va_end(args);
	}

void ERR_add_error_vdata(int num, va_list args)
	{
d1077 1
d1093 1
a1093 1
					return;
d1102 3
@


