head	1.18;
access;
symbols
	butholakala:1.17
	openssl_1_0_1_g:1.1.1.13
	OPENBSD_5_5:1.16.0.8
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	openssl_1_0_1_c:1.1.1.12
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	openssl_1_0_0_f:1.1.1.11
	openssl_1_0_0_e:1.1.1.11
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	openssh_1_0_0_a:1.1.1.10
	OPENBSD_4_8:1.13.0.6
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	openssl_0_9_8_k:1.1.1.9
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	openssl_0_9_8_j:1.1.1.8
	openssl_0_9_8_h:1.1.1.7
	pre_openssl_0_9_8h:1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	openssl_0_9_7j:1.1.1.6
	openssl:1.1.1
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@# @;


1.18
date	2014.04.15.21.34.05;	author tedu;	state dead;
branches;
next	1.17;

1.17
date	2014.04.13.15.25.35;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2010.10.01.22.59.01;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2009.04.06.06.33.20;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.06.12.17.54;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.27.05.07.03;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.29.05.39.33;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.21;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.58.47;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.53;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.44;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.58;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.58;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.51;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.45.21;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.36.59;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.32;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.06.27.05.05.40;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.53;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.14.09;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.04.06.06.30.08;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.10.01.22.54.18;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2011.11.03.02.32.23;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2012.10.13.21.23.53;	author djm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.04.13.15.16.37;	author miod;	state Exp;
branches;
next	;


desc
@@


1.18
log
@    $infile="/home/eay/ssl/SSLeay/MINFO";
I wonder when these scripts were last used...
@
text
@#!/usr/local/bin/perl
# VC-32.pl - unified script for Microsoft Visual C++, covering Win32,
# Win64 and WinCE [follow $FLAVOR variable to trace the differences].
#

$ssl=	"ssleay32";
$crypto="libeay32";

if ($fips && !$shlib)
	{
	$crypto="libeayfips32";
	$crypto_compat = "libeaycompat32.lib";
	}
else
	{
	$crypto="libeay32";
	}

$o='\\';
$cp='$(PERL) util/copy.pl';
$mkdir='$(PERL) util/mkdir-p.pl';
$rm='del /Q';

$zlib_lib="zlib1.lib";

# Santize -L options for ms link
$l_flags =~ s/-L("\[^"]+")/\/libpath:$1/g;
$l_flags =~ s/-L(\S+)/\/libpath:$1/g;

my $ff = "";

# C compiler stuff
$cc='cl';
if ($FLAVOR =~ /WIN64/)
    {
    # Note that we currently don't have /WX on Win64! There is a lot of
    # warnings, but only of two types:
    #
    # C4344: conversion from '__int64' to 'int/long', possible loss of data
    # C4267: conversion from 'size_t' to 'int/long', possible loss of data
    #
    # Amount of latter type is minimized by aliasing strlen to function of
    # own desing and limiting its return value to 2GB-1 (see e_os.h). As
    # per 0.9.8 release remaining warnings were explicitly examined and
    # considered safe to ignore.
    # 
    $base_cflags= " $mf_cflag";
    my $f = $shlib || $fips ?' /MD':' /MT';
    $lib_cflag='/Zl' if (!$shlib);	# remove /DEFAULTLIBs from static lib
    $opt_cflags=$f.' /Ox';
    $dbg_cflags=$f.'d /Od -DDEBUG -D_DEBUG';
    $lflags="/nologo /subsystem:console /opt:ref";

    *::perlasm_compile_target = sub {
	my ($target,$source,$bname)=@@_;
	my $ret;

	$bname =~ s/(.*)\.[^\.]$/$1/;
	$ret=<<___;
\$(TMP_D)$o$bname.asm: $source
	set ASM=\$(ASM)
	\$(PERL) $source \$\@@

$target: \$(TMP_D)$o$bname.asm
	\$(ASM) $afile\$\@@ \$(TMP_D)$o$bname.asm

___
	}
    }
elsif ($FLAVOR =~ /CE/)
    {
    # sanity check
    die '%OSVERSION% is not defined'	if (!defined($ENV{'OSVERSION'}));
    die '%PLATFORM% is not defined'	if (!defined($ENV{'PLATFORM'}));
    die '%TARGETCPU% is not defined'	if (!defined($ENV{'TARGETCPU'}));

    #
    # Idea behind this is to mimic flags set by eVC++ IDE...
    #
    $wcevers = $ENV{'OSVERSION'};			# WCENNN
    die '%OSVERSION% value is insane'	if ($wcevers !~ /^WCE([1-9])([0-9]{2})$/);
    $wcecdefs = "-D_WIN32_WCE=$1$2 -DUNDER_CE=$1$2";	# -D_WIN32_WCE=NNN
    $wcelflag = "/subsystem:windowsce,$1.$2";		# ...,N.NN

    $wceplatf =  $ENV{'PLATFORM'};
    $wceplatf =~ tr/a-z0-9 /A-Z0-9_/d;
    $wcecdefs .= " -DWCE_PLATFORM_$wceplatf";

    $wcetgt = $ENV{'TARGETCPU'};	# just shorter name...
    SWITCH: for($wcetgt) {
	/^X86/		&& do {	$wcecdefs.=" -Dx86 -D_X86_ -D_i386_ -Di_386_";
				$wcelflag.=" /machine:IX86";	last; };
	/^ARMV4[IT]/	&& do { $wcecdefs.=" -DARM -D_ARM_ -D$wcetgt";
				$wcecdefs.=" -DTHUMB -D_THUMB_" if($wcetgt=~/T$/);
				$wcecdefs.=" -QRarch4T -QRinterwork-return";
				$wcelflag.=" /machine:THUMB";	last; };
	/^ARM/		&& do {	$wcecdefs.=" -DARM -D_ARM_ -D$wcetgt";
				$wcelflag.=" /machine:ARM";	last; };
	/^MIPSIV/	&& do {	$wcecdefs.=" -DMIPS -D_MIPS_ -DR4000 -D$wcetgt";
				$wcecdefs.=" -D_MIPS64 -QMmips4 -QMn32";
				$wcelflag.=" /machine:MIPSFPU";	last; };
	/^MIPS16/	&& do {	$wcecdefs.=" -DMIPS -D_MIPS_ -DR4000 -D$wcetgt";
				$wcecdefs.=" -DMIPSII -QMmips16";
				$wcelflag.=" /machine:MIPS16";	last; };
	/^MIPSII/	&& do {	$wcecdefs.=" -DMIPS -D_MIPS_ -DR4000 -D$wcetgt";
				$wcecdefs.=" -QMmips2";
				$wcelflag.=" /machine:MIPS";	last; };
	/^R4[0-9]{3}/	&& do {	$wcecdefs.=" -DMIPS -D_MIPS_ -DR4000";
				$wcelflag.=" /machine:MIPS";	last; };
	/^SH[0-9]/	&& do {	$wcecdefs.=" -D$wcetgt -D_$wcetgt_ -DSHx";
				$wcecdefs.=" -Qsh4" if ($wcetgt =~ /^SH4/);
				$wcelflag.=" /machine:$wcetgt";	last; };
	{ $wcecdefs.=" -D$wcetgt -D_$wcetgt_";
	  $wcelflag.=" /machine:$wcetgt";			last; };
    }

    $cc='$(CC)';
    $base_cflags=' /W3 /WX /GF /Gy /nologo -DUNICODE -D_UNICODE -DOPENSSL_SYSNAME_WINCE -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DDSO_WIN32 -DNO_CHMOD -DOPENSSL_SMALL_FOOTPRINT';
    $base_cflags.=" $wcecdefs";
    $base_cflags.=' -I$(WCECOMPAT)/include'		if (defined($ENV{'WCECOMPAT'}));
    $base_cflags.=' -I$(PORTSDK_LIBPATH)/../../include'	if (defined($ENV{'PORTSDK_LIBPATH'}));
    $opt_cflags=' /MC /O1i';	# optimize for space, but with intrinsics...
    $dbg_cflags=' /MC /Od -DDEBUG -D_DEBUG';
    $lflags="/nologo /opt:ref $wcelflag";
    }
else	# Win32
    {
    $base_cflags= " $mf_cflag";
    my $f = $shlib || $fips ?' /MD':' /MT';
    $lib_cflag='/Zl' if (!$shlib);	# remove /DEFAULTLIBs from static lib
    $ff = "/fixed";
    $opt_cflags=$f.' /Ox /O2 /Ob2';
    $dbg_cflags=$f.'d /Od -DDEBUG -D_DEBUG';
    $lflags="/nologo /subsystem:console /opt:ref";
    }
$mlflags='';

$out_def ="out32";	$out_def.="dll"			if ($shlib);
			$out_def.='_$(TARGETCPU)'	if ($FLAVOR =~ /CE/);
$tmp_def ="tmp32";	$tmp_def.="dll"			if ($shlib);
			$tmp_def.='_$(TARGETCPU)'	if ($FLAVOR =~ /CE/);
$inc_def="inc32";

if ($debug)
	{
	$cflags=$dbg_cflags.$base_cflags;
	}
else
	{
	$cflags=$opt_cflags.$base_cflags;
	}

# generate symbols.pdb unconditionally
$app_cflag.=" /Zi /Fd\$(TMP_D)/app";
$lib_cflag.=" /Zi /Fd\$(TMP_D)/lib";
$lflags.=" /debug";

$obj='.obj';
$asm_suffix='.asm';
$ofile="/Fo";

# EXE linking stuff
$link="link";
$rsc="rc";
$efile="/out:";
$exep='.exe';
if ($no_sock)		{ $ex_libs=''; }
elsif ($FLAVOR =~ /CE/)	{ $ex_libs='winsock.lib'; }
else			{ $ex_libs='ws2_32.lib'; }

if ($FLAVOR =~ /CE/)
	{
	$ex_libs.=' $(WCECOMPAT)/lib/wcecompatex.lib'	if (defined($ENV{'WCECOMPAT'}));
	$ex_libs.=' $(PORTSDK_LIBPATH)/portlib.lib'	if (defined($ENV{'PORTSDK_LIBPATH'}));
	$ex_libs.=' /nodefaultlib:oldnames.lib coredll.lib corelibc.lib' if ($ENV{'TARGETCPU'} eq "X86");
	}
else
	{
	$ex_libs.=' gdi32.lib advapi32.lib crypt32.lib user32.lib';
	$ex_libs.=' bufferoverflowu.lib' if ($FLAVOR =~ /WIN64/ and `cl 2>&1` =~ /14\.00\.4[0-9]{4}\./);
	# WIN32 UNICODE build gets linked with unicows.lib for
	# backward compatibility with Win9x.
	$ex_libs="unicows.lib $ex_libs" if ($FLAVOR =~ /WIN32/ and $cflags =~ /\-DUNICODE/);
	}

# static library stuff
$mklib='lib /nologo';
$ranlib='';
$plib="";
$libp=".lib";
$shlibp=($shlib)?".dll":".lib";
$lfile='/out:';

$shlib_ex_obj="";
$app_ex_obj="setargv.obj" if ($FLAVOR !~ /CE/);
if ($FLAVOR =~ /WIN64A/) {
	if (`nasm -v 2>NUL` =~ /NASM version ([0-9]+\.[0-9]+)/ && $1 >= 2.0) {
		$asm='nasm -f win64 -DNEAR -Ox -g';
		$afile='-o ';
	} else {
		$asm='ml64 /c /Cp /Cx /Zi';
		$afile='/Fo';
	}
} elsif ($FLAVOR =~ /WIN64I/) {
	$asm='ias -d debug';
	$afile="-o ";
} elsif ($nasm) {
	my $ver=`nasm -v 2>NUL`;
	my $vew=`nasmw -v 2>NUL`;
	# pick newest version
	$asm=($ver ge $vew?"nasm":"nasmw")." -f win32";
	$asmtype="win32n";
	$afile='-o ';
} else {
	$asm='ml /nologo /Cp /coff /c /Cx /Zi';
	$afile='/Fo';
	$asmtype="win32";
}

$bn_asm_obj='';
$bn_asm_src='';
$des_enc_obj='';
$des_enc_src='';
$bf_enc_obj='';
$bf_enc_src='';

if (!$no_asm)
	{
	win32_import_asm($mf_bn_asm, "bn", \$bn_asm_obj, \$bn_asm_src);
	win32_import_asm($mf_aes_asm, "aes", \$aes_asm_obj, \$aes_asm_src);
	win32_import_asm($mf_des_asm, "des", \$des_enc_obj, \$des_enc_src);
	win32_import_asm($mf_bf_asm, "bf", \$bf_enc_obj, \$bf_enc_src);
	win32_import_asm($mf_cast_asm, "cast", \$cast_enc_obj, \$cast_enc_src);
	win32_import_asm($mf_rc4_asm, "rc4", \$rc4_enc_obj, \$rc4_enc_src);
	win32_import_asm($mf_rc5_asm, "rc5", \$rc5_enc_obj, \$rc5_enc_src);
	win32_import_asm($mf_md5_asm, "md5", \$md5_asm_obj, \$md5_asm_src);
	win32_import_asm($mf_sha_asm, "sha", \$sha1_asm_obj, \$sha1_asm_src);
	win32_import_asm($mf_rmd_asm, "ripemd", \$rmd160_asm_obj, \$rmd160_asm_src);
	win32_import_asm($mf_wp_asm, "whrlpool", \$whirlpool_asm_obj, \$whirlpool_asm_src);
	win32_import_asm($mf_cpuid_asm, "", \$cpuid_asm_obj, \$cpuid_asm_src);
	$perl_asm = 1;
	}

if ($shlib && $FLAVOR !~ /CE/)
	{
	$mlflags.=" $lflags /dll";
	$lib_cflag.=" -D_WINDLL";
	#
	# Engage Applink...
	#
	$app_ex_obj.=" \$(OBJ_D)\\applink.obj /implib:\$(TMP_D)\\junk.lib";
	$cflags.=" -DOPENSSL_USE_APPLINK -I.";
	# I'm open for better suggestions than overriding $banner...
	$banner=<<'___';
	@@echo Building OpenSSL

$(OBJ_D)\applink.obj:	ms\applink.c
	$(CC) /Fo$(OBJ_D)\applink.obj $(APP_CFLAGS) -c ms\applink.c
$(OBJ_D)\uplink.obj:	ms\uplink.c ms\applink.c
	$(CC) /Fo$(OBJ_D)\uplink.obj $(SHLIB_CFLAGS) -c ms\uplink.c
$(INCO_D)\applink.c:	ms\applink.c
	$(CP) ms\applink.c $(INCO_D)\applink.c

EXHEADER= $(EXHEADER) $(INCO_D)\applink.c

LIBS_DEP=$(LIBS_DEP) $(OBJ_D)\applink.obj
CRYPTOOBJ=$(OBJ_D)\uplink.obj $(CRYPTOOBJ)
___
	$banner.=<<'___' if ($FLAVOR =~ /WIN64/);
CRYPTOOBJ=ms\uptable.obj $(CRYPTOOBJ)
___
	}
elsif ($shlib && $FLAVOR =~ /CE/)
	{
	$mlflags.=" $lflags /dll";
	$lflags.=' /entry:mainCRTstartup' if(defined($ENV{'PORTSDK_LIBPATH'}));
	$lib_cflag.=" -D_WINDLL -D_DLL";
	}

sub do_lib_rule
	{
	my($objs,$target,$name,$shlib,$ign,$base_addr) = @@_;
	local($ret);

	$taget =~ s/\//$o/g if $o ne '/';
	my $base_arg;
	if ($base_addr ne "")
		{
		$base_arg= " /base:$base_addr";
		}
	else
		{
		$base_arg = "";
		}
	if ($name ne "")
		{
		$name =~ tr/a-z/A-Z/;
		$name = "/def:ms/${name}.def";
		}

#	$target="\$(LIB_D)$o$target";
#	$ret.="$target: $objs\n";
	if (!$shlib)
		{
#		$ret.="\t\$(RM) \$(O_$Name)\n";
		$ret.="$target: $objs\n";
		$ret.="\t\$(MKLIB) $lfile$target @@<<\n  $objs\n<<\n";
		}
	else
		{
		local($ex)=($target =~ /O_CRYPTO/)?'':' $(L_CRYPTO)';
		$ex.=" $zlib_lib" if $zlib_opt == 1 && $target =~ /O_CRYPTO/;

 		if ($fips && $target =~ /O_CRYPTO/)
			{
			$ret.="$target: $objs \$(PREMAIN_DSO_EXE)";
			$ret.="\n\tSET FIPS_LINK=\$(LINK)\n";
			$ret.="\tSET FIPS_CC=\$(CC)\n";
			$ret.="\tSET FIPS_CC_ARGS=/Fo\$(OBJ_D)${o}fips_premain.obj \$(SHLIB_CFLAGS) -c\n";
			$ret.="\tSET PREMAIN_DSO_EXE=\$(PREMAIN_DSO_EXE)\n";
			$ret.="\tSET FIPS_SHA1_EXE=\$(FIPS_SHA1_EXE)\n";
			$ret.="\tSET FIPS_TARGET=$target\n";
			$ret.="\tSET FIPSLIB_D=\$(FIPSLIB_D)\n";
			$ret.="\t\$(FIPSLINK) \$(MLFLAGS) $ff /map $base_arg $efile$target ";
			$ret.="$name @@<<\n  \$(SHLIB_EX_OBJ) $objs \$(EX_LIBS) ";
			$ret.="\$(OBJ_D)${o}fips_premain.obj $ex\n<<\n";
			}
		else
			{
			$ret.="$target: $objs";
			$ret.="\n\t\$(LINK) \$(MLFLAGS) $efile$target $name @@<<\n  \$(SHLIB_EX_OBJ) $objs $ex \$(EX_LIBS)\n<<\n";
			}
		$ret.="\tIF EXIST \$@@.manifest mt -nologo -manifest \$@@.manifest -outputresource:\$@@;2\n\n";
		}
	$ret.="\n";
	return($ret);
	}

sub do_link_rule
	{
	my($target,$files,$dep_libs,$libs,$standalone)=@@_;
	local($ret,$_);
	$file =~ s/\//$o/g if $o ne '/';
	$n=&bname($targer);
	$ret.="$target: $files $dep_libs\n";
	if ($standalone == 1)
		{
		$ret.="  \$(LINK) \$(LFLAGS) $efile$target @@<<\n\t";
		$ret.= "\$(EX_LIBS) " if ($files =~ /O_FIPSCANISTER/ && !$fipscanisterbuild);
		$ret.="$files $libs\n<<\n";
		}
	elsif ($standalone == 2)
		{
		$ret.="\tSET FIPS_LINK=\$(LINK)\n";
		$ret.="\tSET FIPS_CC=\$(CC)\n";
		$ret.="\tSET FIPS_CC_ARGS=/Fo\$(OBJ_D)${o}fips_premain.obj \$(SHLIB_CFLAGS) -c\n";
		$ret.="\tSET PREMAIN_DSO_EXE=\n";
		$ret.="\tSET FIPS_TARGET=$target\n";
		$ret.="\tSET FIPS_SHA1_EXE=\$(FIPS_SHA1_EXE)\n";
		$ret.="\tSET FIPSLIB_D=\$(FIPSLIB_D)\n";
		$ret.="\t\$(FIPSLINK) \$(LFLAGS) $ff /map $efile$target @@<<\n";
		$ret.="\t\$(APP_EX_OBJ) $files \$(OBJ_D)${o}fips_premain.obj $libs\n<<\n";
		}
	else
		{
		$ret.="\t\$(LINK) \$(LFLAGS) $efile$target @@<<\n";
		$ret.="\t\$(APP_EX_OBJ) $files $libs\n<<\n";
		}
    	$ret.="\tIF EXIST \$@@.manifest mt -nologo -manifest \$@@.manifest -outputresource:\$@@;1\n\n";
	return($ret);
	}

sub win32_import_asm
	{
	my ($mf_var, $asm_name, $oref, $sref) = @@_;
	my $asm_dir;
	if ($asm_name eq "")
		{
		$asm_dir = "crypto\\";
		}
	else
		{
		$asm_dir = "crypto\\$asm_name\\asm\\";
		}

	$$oref = "";
	$mf_var =~ s/\.o$/.obj/g;

	foreach (split(/ /, $mf_var))
		{
		$$oref .= $asm_dir . $_ . " ";
		}
	$$oref =~ s/ $//;
	$$sref = $$oref;
	$$sref =~ s/\.obj/.asm/g;

	}


1;
@


1.17
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@@


1.16
log
@resolve conflicts
@
text
@d30 2
d123 1
a123 1
    $dbg_clfags=' /MC /Od -DDEBUG -D_DEBUG';
d131 1
d324 1
a324 1
			$ret.="\t\$(FIPSLINK) \$(MLFLAGS) /map $base_arg $efile$target ";
d361 1
a361 1
		$ret.="\t\$(FIPSLINK) \$(LFLAGS) /map $efile$target @@<<\n";
@


1.15
log
@openssl-1.0.0e: resolve conflicts
@
text
@d9 10
d46 1
a46 1
    my $f = $shlib?' /MD':' /MT';
d127 1
a127 1
    my $f = $shlib?' /MD':' /MT';
d279 1
a279 1
	local($objs,$target,$name,$shlib)=@@_;
d283 9
d299 1
a299 1
	$ret.="$target: $objs\n";
d303 1
d310 20
a329 1
		$ret.="\t\$(LINK) \$(MLFLAGS) $efile$target $name @@<<\n  \$(SHLIB_EX_OBJ) $objs $ex \$(EX_LIBS)\n<<\n";
d338 1
a338 1
	local($target,$files,$dep_libs,$libs)=@@_;
a339 1
	
d343 24
a366 3
	$ret.="\t\$(LINK) \$(LFLAGS) $efile$target @@<<\n";
	$ret.="  \$(APP_EX_OBJ) $files $libs\n<<\n";
	$ret.="\tIF EXIST \$@@.manifest mt -nologo -manifest \$@@.manifest -outputresource:\$@@;1\n\n";
@


1.14
log
@resolve conflicts, fix local changes
@
text
@d141 2
a142 2
$app_cflag.=" /Zi /Fd$tmp_def/app";
$lib_cflag.=" /Zi /Fd$tmp_def/lib";
d198 1
a198 1
	$asm=($ver gt $vew?"nasm":"nasmw")." -f win32";
@


1.13
log
@resolve conflicts
@
text
@d7 1
a7 15

if ($fips && !$shlib)
	{
	$crypto="libeayfips32";
	$crypto_compat = "libeaycompat32.lib";
	}
else
	{
	$crypto="libeay32";
	}

if ($fipscanisterbuild)
	{
	$fips_canister_path = "\$(LIB_D)\\fipscanister.lib";
	}
d16 4
d35 1
a35 3
    $base_cflags=' /W3 /Gs0 /GF /Gy /nologo -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DDSO_WIN32 -DOPENSSL_SYSNAME_WIN32 -DOPENSSL_SYSNAME_WINNT -DUNICODE -D_UNICODE';
    $base_cflags.=' -D_CRT_SECURE_NO_DEPRECATE';	# shut up VC8
    $base_cflags.=' -D_CRT_NONSTDC_NO_DEPRECATE';	# shut up VC8
d41 16
d106 1
a106 1
    $base_cflags=' /W3 /WX /GF /Gy /nologo -DUNICODE -D_UNICODE -DOPENSSL_SYSNAME_WINCE -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DDSO_WIN32 -DNO_CHMOD -I$(WCECOMPAT)/include -DOPENSSL_SMALL_FOOTPRINT';
d108 2
d116 2
a117 4
    $base_cflags=' /W3 /WX /Gs0 /GF /Gy /nologo -DOPENSSL_SYSNAME_WIN32 -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DDSO_WIN32';
    $base_cflags.=' -D_CRT_SECURE_NO_DEPRECATE';	# shut up VC8
    $base_cflags.=' -D_CRT_NONSTDC_NO_DEPRECATE';	# shut up VC8
    my $f = $shlib || $fips ?' /MD':' /MT';
d125 4
a128 2
$out_def="out32"; $out_def.='_$(TARGETCPU)' if ($FLAVOR =~ /CE/);
$tmp_def="tmp32"; $tmp_def.='_$(TARGETCPU)' if ($FLAVOR =~ /CE/);
a133 2
	$lflags.=" /debug";
	$mlflags.=' /debug';
d140 5
d146 1
d156 1
a156 1
else			{ $ex_libs='wsock32.lib'; }
d160 2
a161 1
	$ex_libs.=' $(WCECOMPAT)/lib/wcecompatex.lib';
d166 5
a170 2
	$ex_libs.=' gdi32.lib crypt32.lib advapi32.lib user32.lib';
	$ex_libs.=' bufferoverflowu.lib' if ($FLAVOR =~ /WIN64/);
a172 7
# As native NT API is pure UNICODE, our WIN-NT build defaults to UNICODE,
# but gets linked with unicows.lib to ensure backward compatibility.
if ($FLAVOR =~ /NT/)
	{
	$cflags.=" -DOPENSSL_SYSNAME_WINNT -DUNICODE -D_UNICODE";
	$ex_libs="unicows.lib $ex_libs";
	}
d183 12
a194 1
if ($nasm) {
d199 1
a200 4
} elsif ($ml64) {
	$asm='ml64 /c /Cp /Cx';
	$asm.=' /Zi' if $debug;
	$afile='/Fo';
d202 1
a202 2
	$asm='ml /nologo /Cp /coff /c /Cx';
	$asm.=" /Zi" if $debug;
d204 1
a206 1
$aes_asm_obj='';
a214 2
    {
    if ($FLAVOR =~ "WIN32")
d216 13
a228 25
	$aes_asm_obj='crypto\aes\asm\a_win32.obj';
	$aes_asm_src='crypto\aes\asm\a_win32.asm';
	$bn_asm_obj='crypto\bn\asm\bn_win32.obj crypto\bn\asm\mt_win32.obj';
	$bn_asm_src='crypto\bn\asm\bn_win32.asm crypto\bn\asm\mt_win32.asm';
	$bnco_asm_obj='crypto\bn\asm\co_win32.obj';
	$bnco_asm_src='crypto\bn\asm\co_win32.asm';
	$des_enc_obj='crypto\des\asm\d_win32.obj crypto\des\asm\y_win32.obj';
	$des_enc_src='crypto\des\asm\d_win32.asm crypto\des\asm\y_win32.asm';
	$bf_enc_obj='crypto\bf\asm\b_win32.obj';
	$bf_enc_src='crypto\bf\asm\b_win32.asm';
	$cast_enc_obj='crypto\cast\asm\c_win32.obj';
	$cast_enc_src='crypto\cast\asm\c_win32.asm';
	$rc4_enc_obj='crypto\rc4\asm\r4_win32.obj';
	$rc4_enc_src='crypto\rc4\asm\r4_win32.asm';
	$rc5_enc_obj='crypto\rc5\asm\r5_win32.obj';
	$rc5_enc_src='crypto\rc5\asm\r5_win32.asm';
	$md5_asm_obj='crypto\md5\asm\m5_win32.obj';
	$md5_asm_src='crypto\md5\asm\m5_win32.asm';
	$sha1_asm_obj='crypto\sha\asm\s1_win32.obj crypto\sha\asm\sha512-sse2.obj';
	$sha1_asm_src='crypto\sha\asm\s1_win32.asm crypto\sha\asm\sha512-sse2.asm';
	$rmd160_asm_obj='crypto\ripemd\asm\rm_win32.obj';
	$rmd160_asm_src='crypto\ripemd\asm\rm_win32.asm';
	$cpuid_asm_obj='crypto\cpu_win32.obj';
	$cpuid_asm_src='crypto\cpu_win32.asm';
	$cflags.=" -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DAES_ASM -DBN_ASM -DOPENSSL_BN_ASM_PART_WORDS -DOPENSSL_BN_ASM_MONT -DMD5_ASM -DSHA1_ASM -DRMD160_ASM";
a229 13
    elsif ($FLAVOR =~ "WIN64A")
	{
	$aes_asm_obj='$(OBJ_D)\aes-x86_64.obj';
	$aes_asm_src='crypto\aes\asm\aes-x86_64.asm';
	$bn_asm_obj='$(OBJ_D)\x86_64-mont.obj $(OBJ_D)\bn_asm.obj';
	$bn_asm_src='crypto\bn\asm\x86_64-mont.asm';
	$sha1_asm_obj='$(OBJ_D)\sha1-x86_64.obj $(OBJ_D)\sha256-x86_64.obj $(OBJ_D)\sha512-x86_64.obj';
	$sha1_asm_src='crypto\sha\asm\sha1-x86_64.asm crypto\sha\asm\sha256-x86_64.asm crypto\sha\asm\sha512-x86_64.asm';
	$cpuid_asm_obj='$(OBJ_D)\cpuid-x86_64.obj';
	$cpuid_asm_src='crypto\cpuid-x86_64.asm';
	$cflags.=" -DOPENSSL_CPUID_OBJ -DAES_ASM -DOPENSSL_BN_ASM_MONT -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM";
	}
    }
d234 1
a234 4
#	$cflags =~ s| /MD| /MT|;
	$lib_cflag=" -D_WINDLL";
	$out_def="out32dll";
	$tmp_def="tmp32dll";
d254 1
a255 1
$banner .= "CRYPTOOBJ=\$(OBJ_D)\\uplink.obj \$(CRYPTOOBJ)\n";
d263 2
a264 3
	$lib_cflag=" -D_WINDLL -D_DLL";
	$out_def='out32dll_$(TARGETCPU)';
	$tmp_def='tmp32dll_$(TARGETCPU)';
a266 2
$cflags.=" /Fd$out_def";

d269 1
a269 1
	my($objs,$target,$name,$shlib,$ign,$base_addr) = @@_;
d273 1
a273 14
	my $base_arg;
	if ($base_addr ne "")
		{
		$base_arg= " /base:$base_addr";
		}
	else
		{
		$base_arg = "";
		}
	if ($target =~ /O_CRYPTO/ && $fipsdso)
		{
		$name = "/def:ms/libeayfips.def";
		}
	elsif ($name ne "")
d278 1
d280 1
a280 1
#	$ret.="$target: $objs\n";
d284 1
a284 3
		$ex =' ';
		$ret.="$target: $objs\n";
		$ret.="\t\$(MKLIB) $lfile$target @@<<\n  $objs $ex\n<<\n";
d288 1
a288 36
		my $ex = "";		
		if ($target =~ /O_SSL/)
			{
			$ex .= " \$(L_CRYPTO)";
			#$ex .= " \$(L_FIPS)" if $fipsdso;
			}
		my $fipstarget;
		if ($fipsdso)
			{
			$fipstarget = "O_FIPS";
			}
		else
			{
			$fipstarget = "O_CRYPTO";
			}


		if ($name eq "")
			{
			$ex.=' bufferoverflowu.lib' if ($FLAVOR =~ /WIN64/);
			if ($target =~ /capi/)
				{
				$ex.=' crypt32.lib advapi32.lib';
				}
			}
		elsif ($FLAVOR =~ /CE/)
			{
			$ex.=' winsock.lib $(WCECOMPAT)/lib/wcecompatex.lib';
			}
		else
			{
			$ex.=' unicows.lib' if ($FLAVOR =~ /NT/);
			$ex.=' wsock32.lib gdi32.lib advapi32.lib user32.lib';
			$ex.=' crypt32.lib';
			$ex.=' bufferoverflowu.lib' if ($FLAVOR =~ /WIN64/);
			}
d290 2
a291 34

 		if ($fips && $target =~ /$fipstarget/)
			{
			$ex.= $mwex unless $fipscanisterbuild;
			$ret.="$target: $objs \$(PREMAIN_DSO_EXE)";
			if ($fipsdso)
				{
				$ex.=" \$(OBJ_D)\\\$(LIBFIPS).res";
				$ret.=" \$(OBJ_D)\\\$(LIBFIPS).res";
				$ret.=" ms/\$(LIBFIPS).def";
				}
			$ret.="\n\tSET FIPS_LINK=\$(LINK)\n";
			$ret.="\tSET FIPS_CC=\$(CC)\n";
			$ret.="\tSET FIPS_CC_ARGS=/Fo\$(OBJ_D)${o}fips_premain.obj \$(SHLIB_CFLAGS) -c\n";
			$ret.="\tSET PREMAIN_DSO_EXE=\$(PREMAIN_DSO_EXE)\n";
			$ret.="\tSET FIPS_SHA1_EXE=\$(FIPS_SHA1_EXE)\n";
			$ret.="\tSET FIPS_TARGET=$target\n";
			$ret.="\tSET FIPSLIB_D=\$(FIPSLIB_D)\n";
			$ret.="\t\$(FIPSLINK) \$(MLFLAGS) /map $base_arg $efile$target ";
			$ret.="$name @@<<\n  \$(SHLIB_EX_OBJ) $objs ";
			$ret.="\$(OBJ_D)${o}fips_premain.obj $ex\n<<\n";
			}
		else
			{
			$ret.="$target: $objs";
			if ($target =~ /O_CRYPTO/ && $fipsdso)
				{
				$ret .= " \$(O_FIPS)";
				$ex .= " \$(L_FIPS)";
				}
			$ret.="\n\t\$(LINK) \$(MLFLAGS) $efile$target $name @@<<\n  \$(SHLIB_EX_OBJ) $objs $ex\n<<\n";
			}

        $ret.="\tIF EXIST \$@@.manifest mt -nologo -manifest \$@@.manifest -outputresource:\$@@;2\n\n";
d299 1
a299 1
	my($target,$files,$dep_libs,$libs,$standalone)=@@_;
d301 1
d305 11
a315 1
	if ($standalone == 1)
d317 1
a317 3
		$ret.="  \$(LINK) \$(LFLAGS) $efile$target @@<<\n\t";
		$ret.= "\$(EX_LIBS) " if ($files =~ /O_FIPSCANISTER/ && !$fipscanisterbuild);
		$ret.="$files $libs\n<<\n";
d319 1
a319 1
	elsif ($standalone == 2)
d321 1
a321 9
		$ret.="\tSET FIPS_LINK=\$(LINK)\n";
		$ret.="\tSET FIPS_CC=\$(CC)\n";
		$ret.="\tSET FIPS_CC_ARGS=/Fo\$(OBJ_D)${o}fips_premain.obj \$(SHLIB_CFLAGS) -c\n";
		$ret.="\tSET PREMAIN_DSO_EXE=\n";
		$ret.="\tSET FIPS_TARGET=$target\n";
		$ret.="\tSET FIPS_SHA1_EXE=\$(FIPS_SHA1_EXE)\n";
		$ret.="\tSET FIPSLIB_D=\$(FIPSLIB_D)\n";
		$ret.="\t\$(FIPSLINK) \$(LFLAGS) /map $efile$target @@<<\n";
		$ret.="\t\$(APP_EX_OBJ) $files \$(OBJ_D)${o}fips_premain.obj $libs\n<<\n";
d323 5
a327 1
	else
d329 1
a329 2
		$ret.="\t\$(LINK) \$(LFLAGS) $efile$target @@<<\n";
		$ret.="\t\$(APP_EX_OBJ) $files $libs\n<<\n";
d331 3
a333 3
    	$ret.="\tIF EXIST \$@@.manifest mt -nologo -manifest \$@@.manifest -outputresource:\$@@;1\n\n";
	return($ret);
	}
a334 18
sub do_rlink_rule
	{
	local($target,$rl_start, $rl_mid, $rl_end,$dep_libs,$libs)=@@_;
	local($ret,$_);
	my $files = "$rl_start $rl_mid $rl_end";

	$file =~ s/\//$o/g if $o ne '/';
	$n=&bname($targer);
	$ret.="$target: $files $dep_libs \$(FIPS_SHA1_EXE)\n";
	$ret.="\t\$(PERL) ms\\segrenam.pl \$\$a $rl_start\n";
	$ret.="\t\$(PERL) ms\\segrenam.pl \$\$b $rl_mid\n";
	$ret.="\t\$(PERL) ms\\segrenam.pl \$\$c $rl_end\n";
	$ret.="\t\$(MKLIB) $lfile$target @@<<\n\t$files\n<<\n";
	$ret.="\t\$(FIPS_SHA1_EXE) $target > ${target}.sha1\n";
	$ret.="\t\$(PERL) util${o}copy.pl -stripcr fips${o}fips_premain.c \$(LIB_D)${o}fips_premain.c\n";
	$ret.="\t\$(CP) fips${o}fips_premain.c.sha1 \$(LIB_D)${o}fips_premain.c.sha1\n";
	$ret.="\n";
	return($ret);
a336 7
sub do_sdef_rule
	{
	my $ret = "ms/\$(LIBFIPS).def: \$(O_FIPSCANISTER)\n";
	$ret.="\t\$(PERL) util/mksdef.pl \$(MLFLAGS) /out:dummy.dll /def:ms/libeay32.def @@<<\n  \$(O_FIPSCANISTER)\n<<\n";
	$ret.="\n";
	return $ret;
	}
@


1.12
log
@resolve conflicts
@
text
@d167 1
a167 1
$mklib='lib';
d187 1
a187 1
	$asm='ml /Cp /coff /c /Cx';
d407 1
a407 1
		$ret.= "$mwex advapi32.lib " if ($files =~ /O_FIPSCANISTER/ && !$fipscanisterbuild);
@


1.11
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d7 15
a21 1
$crypto="libeay32";
d26 1
a26 1
$rm='del';
d113 1
a113 1
    my $f = $shlib?' /MD':' /MT';
d182 4
d192 1
d201 2
d206 2
a207 2
	$bn_asm_obj='crypto\bn\asm\bn_win32.obj';
	$bn_asm_src='crypto\bn\asm\bn_win32.asm';
d228 1
a228 1
	$cflags.=" -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DAES_ASM -DBN_ASM -DOPENSSL_BN_ASM_PART_WORDS -DMD5_ASM -DSHA1_ASM -DRMD160_ASM";
d230 13
d247 1
a269 1
CRYPTOOBJ=$(OBJ_D)\uplink.obj $(CRYPTOOBJ)
d271 1
d288 1
a288 1
	local($objs,$target,$name,$shlib)=@@_;
d292 14
a305 1
	if ($name ne "")
d311 1
a311 1
	$ret.="$target: $objs\n";
d316 1
d321 17
a337 1
		local($ex)=($target =~ /O_CRYPTO/)?'':' $(L_CRYPTO)';
d358 33
a390 1
		$ret.="\t\$(LINK) \$(MLFLAGS) $efile$target $name @@<<\n  \$(SHLIB_EX_OBJ) $objs $ex\n<<\n";
d399 1
a399 1
	local($target,$files,$dep_libs,$libs)=@@_;
a400 1
	
d404 24
a427 3
	$ret.="\t\$(LINK) \$(LFLAGS) $efile$target @@<<\n";
	$ret.="  \$(APP_EX_OBJ) $files $libs\n<<\n";
    $ret.="\tIF EXIST \$@@.manifest mt -nologo -manifest \$@@.manifest -outputresource:\$@@;1\n\n";
d429 28
@


1.10
log
@resolve conflicts
@
text
@d141 1
a141 1
	$ex_libs.=' gdi32.lib advapi32.lib user32.lib';
a261 1

d276 4
d289 1
@


1.9
log
@resolve conflicts
@
text
@d2 2
a3 1
# VCw32lib.pl - the file for Visual C++ 4.[01] for windows NT, static libraries
d7 1
a7 10

if ($fips && !$shlib)
	{
	$crypto="libeayfips32";
	$crypto_compat = "libeaycompat32.lib";
	}
else
	{
	$crypto="libeay32";
	}
d10 2
a11 1
$cp='copy nul+';	# Timestamps get stuffed otherwise
d18 87
a104 4
$cflags=' /MD /W3 /WX /Ox /O2 /Ob2 /Gs0 /GF /Gy /nologo -DOPENSSL_SYSNAME_WIN32 -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DDSO_WIN32';
$cflags.=' -D_CRT_SECURE_NO_DEPRECATE';		# shut up VC8
$cflags.=' -D_CRT_NONSTDC_NO_DEPRECATE';	# shut up VC8
$lflags="/nologo /subsystem:console /machine:I386 /opt:ref";
d107 2
a108 2
$out_def="out32";
$tmp_def="tmp32";
d113 1
a113 1
	$cflags=" /MDd /W3 /WX /Zi /Yd /Od /nologo -DOPENSSL_SYSNAME_WIN32 -D_DEBUG -DL_ENDIAN -DWIN32_LEAN_AND_MEAN -DDEBUG -DDSO_WIN32";
d117 4
a120 1
$cflags .= " -DOPENSSL_SYSNAME_WINNT" if $NT == 1;
d127 1
d130 3
a132 3
if ($no_sock)
	{ $ex_libs=""; }
else	{ $ex_libs="wsock32.lib user32.lib gdi32.lib"; }
d134 18
d161 1
a161 1
$app_ex_obj="setargv.obj";
d163 4
a166 1
	$asm='nasmw -f win32';
d181 1
a181 1
if (!$no_asm && !$fips)
d183 2
d187 2
d201 2
a202 2
	$sha1_asm_obj='crypto\sha\asm\s1_win32.obj';
	$sha1_asm_src='crypto\sha\asm\s1_win32.asm';
d205 3
a207 1
	$cflags.=" -DBN_ASM -DMD5_ASM -DSHA1_ASM -DRMD160_ASM";
d210 1
a210 1
if ($shlib)
a212 1
#	$cflags =~ s| /MD| /MT|;
d216 31
d253 2
a254 2
	local($objs,$target,$name,$shlib,$ign,$base_addr) = @@_;
	local($ret,$Name);
d257 1
a257 7
	($Name=$name) =~ tr/a-z/A-Z/;
	my $base_arg;
	if ($base_addr ne "")
		{
		$base_arg= " /base:$base_addr";
		}
	else
d259 2
a260 1
		$base_arg = "";
a262 1

d264 1
d268 1
a268 3
		$ret.="$target: $objs\n";
		$ex =' advapi32.lib';
 		$ex.=" \$(FIPSLIB_D)${o}_chkstk.o" if $fips && $target =~ /O_CRYPTO/;
d273 6
a278 4
		local($ex)=($target =~ /O_SSL/)?' $(L_CRYPTO)':'';
		$ex.=' wsock32.lib gdi32.lib advapi32.lib user32.lib';
 		$ex.=" $zlib_lib" if $zlib_opt == 1 && $target =~ /O_CRYPTO/;
 		if ($fips && $target =~ /O_CRYPTO/)
d280 1
a280 12
 			$ex.=" \$(FIPSLIB_D)${o}_chkstk.o";
			$ret.="$target: $objs \$(PREMAIN_DSO_EXE)\n";
			$ret.="\tSET FIPS_LINK=\$(LINK)\n";
			$ret.="\tSET FIPS_CC=\$(CC)\n";
			$ret.="\tSET FIPS_CC_ARGS=/Fo\$(OBJ_D)${o}fips_premain.obj \$(SHLIB_CFLAGS) -c\n";
			$ret.="\tSET PREMAIN_DSO_EXE=\$(PREMAIN_DSO_EXE)\n";
			$ret.="\tSET FIPS_SHA1_EXE=\$(FIPS_SHA1_EXE)\n";
			$ret.="\tSET FIPS_TARGET=$target\n";
			$ret.="\tSET FIPSLIB_D=\$(FIPSLIB_D)\n";
			$ret.="\t\$(FIPSLINK) \$(MLFLAGS) $base_arg $efile$target ";
			$ret.="/def:ms/${Name}.def @@<<\n  \$(SHLIB_EX_OBJ) $objs ";
			$ret.="\$(OBJ_D)${o}fips_premain.obj $ex\n<<\n";
d284 3
a286 2
			$ret.="$target: $objs\n";
			$ret.="\t\$(LINK) \$(MLFLAGS) $base_arg $efile$target /def:ms/${Name}.def @@<<\n  \$(SHLIB_EX_OBJ) $objs $ex\n<<\n";
d288 3
a297 34
	local($target,$files,$dep_libs,$libs,$standalone)=@@_;
	local($ret,$_);
	$file =~ s/\//$o/g if $o ne '/';
	$n=&bname($targer);
	$ret.="$target: $files $dep_libs\n";
	if ($standalone)
		{
		$ret.="  \$(LINK) \$(LFLAGS) $efile$target @@<<\n\t";
		$ret.="\$(FIPSLIB_D)${o}_chkstk.o " if ($files =~ /O_FIPSCANISTER/);
		$ret.="$files $libs\n<<\n";
		}
	elsif ($fips && !$shlib)
		{
		$ret.="\tSET FIPS_LINK=\$(LINK)\n";
		$ret.="\tSET FIPS_CC=\$(CC)\n";
		$ret.="\tSET FIPS_CC_ARGS=/Fo\$(OBJ_D)${o}fips_premain.obj \$(SHLIB_CFLAGS) -c\n";
		$ret.="\tSET PREMAIN_DSO_EXE=\n";
		$ret.="\tSET FIPS_TARGET=$target\n";
		$ret.="\tSET FIPS_SHA1_EXE=\$(FIPS_SHA1_EXE)\n";
		$ret.="\tSET FIPSLIB_D=\$(FIPSLIB_D)\n";
		$ret.="  \$(FIPSLINK) \$(LFLAGS) $efile$target @@<<\n";
		$ret.="  \$(APP_EX_OBJ) $files \$(OBJ_D)${o}fips_premain.obj $libs\n<<\n";
		}
	else
		{
		$ret.="  \$(LINK) \$(LFLAGS) $efile$target @@<<\n";
		$ret.="  \$(APP_EX_OBJ) $files $libs\n<<\n";
		}
	$ret.="\n";
	return($ret);
	}

sub do_rlink_rule
	{
d300 1
a300 1

d304 3
a306 3
	$ret.="  \$(MKCANISTER) $target <<\n";
	$ret.="INPUT($files)\n<<\n";
	$ret.="\n";
a308 1

@


1.8
log
@resolve conflicts
@
text
@d6 10
a15 1
$crypto="libeay32";
d21 2
d25 3
a27 1
$cflags=' /MD /W3 /WX /G5 /Ox /O2 /Ob2 /Gs0 /GF /Gy /nologo -DOPENSSL_SYSNAME_WIN32 -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DDSO_WIN32';
d116 1
a116 1
	local($objs,$target,$name,$shlib)=@@_;
d121 10
a132 1
	$ret.="$target: $objs\n";
d136 1
d138 1
d144 22
a165 2
		$ex.=' wsock32.lib gdi32.lib advapi32.lib';
		$ret.="\t\$(LINK) \$(MLFLAGS) $efile$target /def:ms/${Name}.def @@<<\n  \$(SHLIB_EX_OBJ) $objs $ex\n<<\n";
d173 1
a173 1
	local($target,$files,$dep_libs,$libs,$sha1file,$openssl)=@@_;
a174 1
	
d178 7
a184 3
	$ret.="  \$(LINK) \$(LFLAGS) $efile$target @@<<\n";
	$ret.="  \$(APP_EX_OBJ) $files $libs\n<<\n";
	if (defined $sha1file)
d186 9
a194 1
		$ret.="  $openssl sha1 -hmac etaonrishdlcupfm -binary $target > $sha1file";
d196 19
d218 1
@


1.7
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d67 1
a67 1
if (!$no_asm)
d129 1
a129 1
	local($target,$files,$dep_libs,$libs)=@@_;
d136 6
a141 1
	$ret.="  \$(APP_EX_OBJ) $files $libs\n<<\n\n";
@


1.6
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d94 1
a94 1
	$lib_cflag=" -D_WINDLL -D_DLL";
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d69 18
a86 18
	$bn_asm_obj='crypto\bn\asm\bn-win32.obj';
	$bn_asm_src='crypto\bn\asm\bn-win32.asm';
	$des_enc_obj='crypto\des\asm\d-win32.obj crypto\des\asm\y-win32.obj';
	$des_enc_src='crypto\des\asm\d-win32.asm crypto\des\asm\y-win32.asm';
	$bf_enc_obj='crypto\bf\asm\b-win32.obj';
	$bf_enc_src='crypto\bf\asm\b-win32.asm';
	$cast_enc_obj='crypto\cast\asm\c-win32.obj';
	$cast_enc_src='crypto\cast\asm\c-win32.asm';
	$rc4_enc_obj='crypto\rc4\asm\r4-win32.obj';
	$rc4_enc_src='crypto\rc4\asm\r4-win32.asm';
	$rc5_enc_obj='crypto\rc5\asm\r5-win32.obj';
	$rc5_enc_src='crypto\rc5\asm\r5-win32.asm';
	$md5_asm_obj='crypto\md5\asm\m5-win32.obj';
	$md5_asm_src='crypto\md5\asm\m5-win32.asm';
	$sha1_asm_obj='crypto\sha\asm\s1-win32.obj';
	$sha1_asm_src='crypto\sha\asm\s1-win32.asm';
	$rmd160_asm_obj='crypto\ripemd\asm\rm-win32.obj';
	$rmd160_asm_src='crypto\ripemd\asm\rm-win32.asm';
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@a6 1
$RSAref="RSAref32";
d14 1
a14 1
$cflags=' /MD /W3 /WX /G5 /Ox /O2 /Ob2 /Gs0 /GF /Gy /nologo -DWIN32 -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DDSO_WIN32';
d24 1
a24 1
	$cflags=" /MDd /W3 /WX /Zi /Yd /Od /nologo -DWIN32 -D_DEBUG -DL_ENDIAN -DWIN32_LEAN_AND_MEAN -DDEBUG -DDSO_WIN32";
d28 1
a28 1
$cflags .= " -DWINNT" if $NT == 1;
d94 1
a94 1
	$lib_cflag=" /GD -D_WINDLL -D_DLL";
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d15 1
a15 1
$cflags=' /MD /W3 /WX /G5 /Ox /O2 /Ob2 /Gs0 /GF /Gy /nologo -DWIN32 -DWIN32_LEAN_AND_MEAN -DL_ENDIAN';
d25 1
a25 1
	$cflags=" /MDd /W3 /WX /Zi /Yd /Od /nologo -DWIN32 -D_DEBUG -DL_ENDIAN -DWIN32_LEAN_AND_MEAN -DDEBUG";
d115 2
a116 1
		$ret.="\t\$(MKLIB) $lfile$target @@<<\n  $objs\n<<\n";
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d25 1
a25 1
	$cflags=" /MDd /W3 /WX /Zi /Yd /Od /nologo -DWINDOWS -DWIN32 -D_DEBUG -DL_ENDIAN -DWIN32_LEAN_AND_MEAN -DDEBUG";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#!/usr/bin/perl
d10 1
a10 1
$cp='copy';
d25 1
a25 1
	$cflags=" /MDd /W3 /WX /Zi /Yd /Od /nologo -DWINDOWS -DWIN32 -D_DEBUG -DL_ENDIAN";
d29 1
d52 8
d61 2
a62 6
$asm='ml /Cp /coff /c /Cx';
$asm.=" /Zi" if $debug;
$afile='/Fo';

$bn_mulw_obj='';
$bn_mulw_src='';
d70 2
a71 2
	$bn_mulw_obj='crypto\bn\asm\bn-win32.obj';
	$bn_mulw_src='crypto\bn\asm\bn-win32.asm';
d100 2
d120 1
a120 1
		$ex.=' wsock32.lib gdi32.lib';
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d1 1
a1 1
#!/usr/local/bin/perl
d7 1
d10 1
a10 1
$cp='copy nul+';	# Timestamps get stuffed otherwise
d15 1
a15 1
$cflags=' /MD /W3 /WX /G5 /Ox /O2 /Ob2 /Gs0 /GF /Gy /nologo -DOPENSSL_SYSNAME_WIN32 -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DDSO_WIN32';
d25 1
a25 1
	$cflags=" /MDd /W3 /WX /Zi /Yd /Od /nologo -DOPENSSL_SYSNAME_WIN32 -D_DEBUG -DL_ENDIAN -DWIN32_LEAN_AND_MEAN -DDEBUG -DDSO_WIN32";
a28 1
$cflags .= " -DOPENSSL_SYSNAME_WINNT" if $NT == 1;
a50 8
if ($nasm) {
	$asm='nasmw -f win32';
	$afile='-o ';
} else {
	$asm='ml /Cp /coff /c /Cx';
	$asm.=" /Zi" if $debug;
	$afile='/Fo';
}
d52 6
a57 2
$bn_asm_obj='';
$bn_asm_src='';
d65 2
a66 2
	$bn_asm_obj='crypto\bn\asm\bn-win32.obj';
	$bn_asm_src='crypto\bn\asm\bn-win32.asm';
d90 1
a90 1
	$lib_cflag=" -D_WINDLL -D_DLL";
a94 2
$cflags.=" /Fd$out_def";

d108 1
a108 2
		$ex =' advapi32.lib';
		$ret.="\t\$(MKLIB) $lfile$target @@<<\n  $objs $ex\n<<\n";
d113 1
a113 1
		$ex.=' wsock32.lib gdi32.lib advapi32.lib';
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d69 18
a86 18
	$bn_asm_obj='crypto\bn\asm\bn_win32.obj';
	$bn_asm_src='crypto\bn\asm\bn_win32.asm';
	$des_enc_obj='crypto\des\asm\d_win32.obj crypto\des\asm\y_win32.obj';
	$des_enc_src='crypto\des\asm\d_win32.asm crypto\des\asm\y_win32.asm';
	$bf_enc_obj='crypto\bf\asm\b_win32.obj';
	$bf_enc_src='crypto\bf\asm\b_win32.asm';
	$cast_enc_obj='crypto\cast\asm\c_win32.obj';
	$cast_enc_src='crypto\cast\asm\c_win32.asm';
	$rc4_enc_obj='crypto\rc4\asm\r4_win32.obj';
	$rc4_enc_src='crypto\rc4\asm\r4_win32.asm';
	$rc5_enc_obj='crypto\rc5\asm\r5_win32.obj';
	$rc5_enc_src='crypto\rc5\asm\r5_win32.asm';
	$md5_asm_obj='crypto\md5\asm\m5_win32.obj';
	$md5_asm_src='crypto\md5\asm\m5_win32.asm';
	$sha1_asm_obj='crypto\sha\asm\s1_win32.obj';
	$sha1_asm_src='crypto\sha\asm\s1_win32.asm';
	$rmd160_asm_obj='crypto\ripemd\asm\rm_win32.obj';
	$rmd160_asm_src='crypto\ripemd\asm\rm_win32.asm';
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d94 1
a94 1
	$lib_cflag=" -D_WINDLL";
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d67 1
a67 1
if (!$no_asm && !$fips)
d129 1
a129 1
	local($target,$files,$dep_libs,$libs,$sha1file,$openssl)=@@_;
d136 1
a136 6
	$ret.="  \$(APP_EX_OBJ) $files $libs\n<<\n";
	if (defined $sha1file)
		{
		$ret.="  $openssl sha1 -hmac etaonrishdlcupfm -binary $target > $sha1file";
		}
	$ret.="\n";
@


1.1.1.6
log
@import of openssl-0.9.7j
@
text
@d6 1
a6 10

if ($fips && !$shlib)
	{
	$crypto="libeayfips32";
	$crypto_compat = "libeaycompat32.lib";
	}
else
	{
	$crypto="libeay32";
	}
a11 2
$zlib_lib="zlib1.lib";

d14 1
a14 3
$cflags=' /MD /W3 /WX /Ox /O2 /Ob2 /Gs0 /GF /Gy /nologo -DOPENSSL_SYSNAME_WIN32 -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DDSO_WIN32';
$cflags.=' -D_CRT_SECURE_NO_DEPRECATE';		# shut up VC8
$cflags.=' -D_CRT_NONSTDC_NO_DEPRECATE';	# shut up VC8
d103 1
a103 1
	local($objs,$target,$name,$shlib,$ign,$base_addr) = @@_;
a107 10
	my $base_arg;
	if ($base_addr ne "")
		{
		$base_arg= " /base:$base_addr";
		}
	else
		{
		$base_arg = "";
		}

d110 1
a113 1
		$ret.="$target: $objs\n";
a114 1
 		$ex.=" \$(FIPSLIB_D)${o}_chkstk.o" if $fips && $target =~ /O_CRYPTO/;
d120 2
a121 22
		$ex.=' wsock32.lib gdi32.lib advapi32.lib user32.lib';
 		$ex.=" $zlib_lib" if $zlib_opt == 1 && $target =~ /O_CRYPTO/;
 		if ($fips && $target =~ /O_CRYPTO/)
			{
 			$ex.=" \$(FIPSLIB_D)${o}_chkstk.o";
			$ret.="$target: $objs \$(PREMAIN_DSO_EXE)\n";
			$ret.="\tSET FIPS_LINK=\$(LINK)\n";
			$ret.="\tSET FIPS_CC=\$(CC)\n";
			$ret.="\tSET FIPS_CC_ARGS=/Fo\$(OBJ_D)${o}fips_premain.obj \$(SHLIB_CFLAGS) -c\n";
			$ret.="\tSET PREMAIN_DSO_EXE=\$(PREMAIN_DSO_EXE)\n";
			$ret.="\tSET FIPS_SHA1_EXE=\$(FIPS_SHA1_EXE)\n";
			$ret.="\tSET FIPS_TARGET=$target\n";
			$ret.="\tSET FIPSLIB_D=\$(FIPSLIB_D)\n";
			$ret.="\t\$(FIPSLINK) \$(MLFLAGS) $base_arg $efile$target ";
			$ret.="/def:ms/${Name}.def @@<<\n  \$(SHLIB_EX_OBJ) $objs ";
			$ret.="\$(OBJ_D)${o}fips_premain.obj $ex\n<<\n";
			}
		else
			{
			$ret.="$target: $objs\n";
			$ret.="\t\$(LINK) \$(MLFLAGS) $base_arg $efile$target /def:ms/${Name}.def @@<<\n  \$(SHLIB_EX_OBJ) $objs $ex\n<<\n";
			}
d129 1
a129 1
	local($target,$files,$dep_libs,$libs,$standalone)=@@_;
d131 1
d135 3
a137 7
	if ($standalone)
		{
		$ret.="  \$(LINK) \$(LFLAGS) $efile$target @@<<\n\t";
		$ret.="\$(FIPSLIB_D)${o}_chkstk.o " if ($files =~ /O_FIPSCANISTER/);
		$ret.="$files $libs\n<<\n";
		}
	elsif ($fips && !$shlib)
d139 1
a139 9
		$ret.="\tSET FIPS_LINK=\$(LINK)\n";
		$ret.="\tSET FIPS_CC=\$(CC)\n";
		$ret.="\tSET FIPS_CC_ARGS=/Fo\$(OBJ_D)${o}fips_premain.obj \$(SHLIB_CFLAGS) -c\n";
		$ret.="\tSET PREMAIN_DSO_EXE=\n";
		$ret.="\tSET FIPS_TARGET=$target\n";
		$ret.="\tSET FIPS_SHA1_EXE=\$(FIPS_SHA1_EXE)\n";
		$ret.="\tSET FIPSLIB_D=\$(FIPSLIB_D)\n";
		$ret.="  \$(FIPSLINK) \$(LFLAGS) $efile$target @@<<\n";
		$ret.="  \$(APP_EX_OBJ) $files \$(OBJ_D)${o}fips_premain.obj $libs\n<<\n";
a140 19
	else
		{
		$ret.="  \$(LINK) \$(LFLAGS) $efile$target @@<<\n";
		$ret.="  \$(APP_EX_OBJ) $files $libs\n<<\n";
		}
	$ret.="\n";
	return($ret);
	}

sub do_rlink_rule
	{
	local($target,$files,$dep_libs,$libs)=@@_;
	local($ret,$_);

	$file =~ s/\//$o/g if $o ne '/';
	$n=&bname($targer);
	$ret.="$target: $files $dep_libs\n";
	$ret.="  \$(MKCANISTER) $target <<\n";
	$ret.="INPUT($files)\n<<\n";
a143 1

@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@d2 1
a2 2
# VC-32.pl - unified script for Microsoft Visual C++, covering Win32,
# Win64 and WinCE [follow $FLAVOR variable to trace the differences].
d6 10
a15 1
$crypto="libeay32";
d18 1
a18 2
$cp='$(PERL) util/copy.pl';
$mkdir='$(PERL) util/mkdir-p.pl';
d25 4
a28 87
if ($FLAVOR =~ /WIN64/)
    {
    # Note that we currently don't have /WX on Win64! There is a lot of
    # warnings, but only of two types:
    #
    # C4344: conversion from '__int64' to 'int/long', possible loss of data
    # C4267: conversion from 'size_t' to 'int/long', possible loss of data
    #
    # Amount of latter type is minimized by aliasing strlen to function of
    # own desing and limiting its return value to 2GB-1 (see e_os.h). As
    # per 0.9.8 release remaining warnings were explicitly examined and
    # considered safe to ignore.
    # 
    $base_cflags=' /W3 /Gs0 /GF /Gy /nologo -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DDSO_WIN32 -DOPENSSL_SYSNAME_WIN32 -DOPENSSL_SYSNAME_WINNT -DUNICODE -D_UNICODE';
    $base_cflags.=' -D_CRT_SECURE_NO_DEPRECATE';	# shut up VC8
    $base_cflags.=' -D_CRT_NONSTDC_NO_DEPRECATE';	# shut up VC8
    my $f = $shlib?' /MD':' /MT';
    $lib_cflag='/Zl' if (!$shlib);	# remove /DEFAULTLIBs from static lib
    $opt_cflags=$f.' /Ox';
    $dbg_cflags=$f.'d /Od -DDEBUG -D_DEBUG';
    $lflags="/nologo /subsystem:console /opt:ref";
    }
elsif ($FLAVOR =~ /CE/)
    {
    # sanity check
    die '%OSVERSION% is not defined'	if (!defined($ENV{'OSVERSION'}));
    die '%PLATFORM% is not defined'	if (!defined($ENV{'PLATFORM'}));
    die '%TARGETCPU% is not defined'	if (!defined($ENV{'TARGETCPU'}));

    #
    # Idea behind this is to mimic flags set by eVC++ IDE...
    #
    $wcevers = $ENV{'OSVERSION'};			# WCENNN
    die '%OSVERSION% value is insane'	if ($wcevers !~ /^WCE([1-9])([0-9]{2})$/);
    $wcecdefs = "-D_WIN32_WCE=$1$2 -DUNDER_CE=$1$2";	# -D_WIN32_WCE=NNN
    $wcelflag = "/subsystem:windowsce,$1.$2";		# ...,N.NN

    $wceplatf =  $ENV{'PLATFORM'};
    $wceplatf =~ tr/a-z0-9 /A-Z0-9_/d;
    $wcecdefs .= " -DWCE_PLATFORM_$wceplatf";

    $wcetgt = $ENV{'TARGETCPU'};	# just shorter name...
    SWITCH: for($wcetgt) {
	/^X86/		&& do {	$wcecdefs.=" -Dx86 -D_X86_ -D_i386_ -Di_386_";
				$wcelflag.=" /machine:IX86";	last; };
	/^ARMV4[IT]/	&& do { $wcecdefs.=" -DARM -D_ARM_ -D$wcetgt";
				$wcecdefs.=" -DTHUMB -D_THUMB_" if($wcetgt=~/T$/);
				$wcecdefs.=" -QRarch4T -QRinterwork-return";
				$wcelflag.=" /machine:THUMB";	last; };
	/^ARM/		&& do {	$wcecdefs.=" -DARM -D_ARM_ -D$wcetgt";
				$wcelflag.=" /machine:ARM";	last; };
	/^MIPSIV/	&& do {	$wcecdefs.=" -DMIPS -D_MIPS_ -DR4000 -D$wcetgt";
				$wcecdefs.=" -D_MIPS64 -QMmips4 -QMn32";
				$wcelflag.=" /machine:MIPSFPU";	last; };
	/^MIPS16/	&& do {	$wcecdefs.=" -DMIPS -D_MIPS_ -DR4000 -D$wcetgt";
				$wcecdefs.=" -DMIPSII -QMmips16";
				$wcelflag.=" /machine:MIPS16";	last; };
	/^MIPSII/	&& do {	$wcecdefs.=" -DMIPS -D_MIPS_ -DR4000 -D$wcetgt";
				$wcecdefs.=" -QMmips2";
				$wcelflag.=" /machine:MIPS";	last; };
	/^R4[0-9]{3}/	&& do {	$wcecdefs.=" -DMIPS -D_MIPS_ -DR4000";
				$wcelflag.=" /machine:MIPS";	last; };
	/^SH[0-9]/	&& do {	$wcecdefs.=" -D$wcetgt -D_$wcetgt_ -DSHx";
				$wcecdefs.=" -Qsh4" if ($wcetgt =~ /^SH4/);
				$wcelflag.=" /machine:$wcetgt";	last; };
	{ $wcecdefs.=" -D$wcetgt -D_$wcetgt_";
	  $wcelflag.=" /machine:$wcetgt";			last; };
    }

    $cc='$(CC)';
    $base_cflags=' /W3 /WX /GF /Gy /nologo -DUNICODE -D_UNICODE -DOPENSSL_SYSNAME_WINCE -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DDSO_WIN32 -DNO_CHMOD -I$(WCECOMPAT)/include -DOPENSSL_SMALL_FOOTPRINT';
    $base_cflags.=" $wcecdefs";
    $opt_cflags=' /MC /O1i';	# optimize for space, but with intrinsics...
    $dbg_clfags=' /MC /Od -DDEBUG -D_DEBUG';
    $lflags="/nologo /opt:ref $wcelflag";
    }
else	# Win32
    {
    $base_cflags=' /W3 /WX /Gs0 /GF /Gy /nologo -DOPENSSL_SYSNAME_WIN32 -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DDSO_WIN32';
    $base_cflags.=' -D_CRT_SECURE_NO_DEPRECATE';	# shut up VC8
    $base_cflags.=' -D_CRT_NONSTDC_NO_DEPRECATE';	# shut up VC8
    my $f = $shlib?' /MD':' /MT';
    $lib_cflag='/Zl' if (!$shlib);	# remove /DEFAULTLIBs from static lib
    $opt_cflags=$f.' /Ox /O2 /Ob2';
    $dbg_cflags=$f.'d /Od -DDEBUG -D_DEBUG';
    $lflags="/nologo /subsystem:console /opt:ref";
    }
d31 2
a32 2
$out_def="out32"; $out_def.='_$(TARGETCPU)' if ($FLAVOR =~ /CE/);
$tmp_def="tmp32"; $tmp_def.='_$(TARGETCPU)' if ($FLAVOR =~ /CE/);
d37 1
a37 1
	$cflags=$dbg_cflags.$base_cflags;
d41 1
a41 4
else
	{
	$cflags=$opt_cflags.$base_cflags;
	}
a47 1
$rsc="rc";
d50 3
a52 3
if ($no_sock)		{ $ex_libs=''; }
elsif ($FLAVOR =~ /CE/)	{ $ex_libs='winsock.lib'; }
else			{ $ex_libs='wsock32.lib'; }
a53 18
if ($FLAVOR =~ /CE/)
	{
	$ex_libs.=' $(WCECOMPAT)/lib/wcecompatex.lib';
	$ex_libs.=' /nodefaultlib:oldnames.lib coredll.lib corelibc.lib' if ($ENV{'TARGETCPU'} eq "X86");
	}
else
	{
	$ex_libs.=' gdi32.lib advapi32.lib user32.lib';
	$ex_libs.=' bufferoverflowu.lib' if ($FLAVOR =~ /WIN64/);
	}

# As native NT API is pure UNICODE, our WIN-NT build defaults to UNICODE,
# but gets linked with unicows.lib to ensure backward compatibility.
if ($FLAVOR =~ /NT/)
	{
	$cflags.=" -DOPENSSL_SYSNAME_WINNT -DUNICODE -D_UNICODE";
	$ex_libs="unicows.lib $ex_libs";
	}
d63 1
a63 1
$app_ex_obj="setargv.obj" if ($FLAVOR !~ /CE/);
d65 1
a65 4
	my $ver=`nasm -v 2>NUL`;
	my $vew=`nasmw -v 2>NUL`;
	# pick newest version
	$asm=($ver gt $vew?"nasm":"nasmw")." -f win32";
d80 1
a80 1
if (!$no_asm)
a81 2
	$aes_asm_obj='crypto\aes\asm\a_win32.obj';
	$aes_asm_src='crypto\aes\asm\a_win32.asm';
a83 2
	$bnco_asm_obj='crypto\bn\asm\co_win32.obj';
	$bnco_asm_src='crypto\bn\asm\co_win32.asm';
d96 2
a97 2
	$sha1_asm_obj='crypto\sha\asm\s1_win32.obj crypto\sha\asm\sha512-sse2.obj';
	$sha1_asm_src='crypto\sha\asm\s1_win32.asm crypto\sha\asm\sha512-sse2.asm';
d100 1
a100 3
	$cpuid_asm_obj='crypto\cpu_win32.obj';
	$cpuid_asm_src='crypto\cpu_win32.asm';
	$cflags.=" -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DAES_ASM -DBN_ASM -DOPENSSL_BN_ASM_PART_WORDS -DMD5_ASM -DSHA1_ASM -DRMD160_ASM";
d103 1
a103 1
if ($shlib && $FLAVOR !~ /CE/)
d106 1
a109 31
	#
	# Engage Applink...
	#
	$app_ex_obj.=" \$(OBJ_D)\\applink.obj /implib:\$(TMP_D)\\junk.lib";
	$cflags.=" -DOPENSSL_USE_APPLINK -I.";
	# I'm open for better suggestions than overriding $banner...
	$banner=<<'___';
	@@echo Building OpenSSL

$(OBJ_D)\applink.obj:	ms\applink.c
	$(CC) /Fo$(OBJ_D)\applink.obj $(APP_CFLAGS) -c ms\applink.c
$(OBJ_D)\uplink.obj:	ms\uplink.c ms\applink.c
	$(CC) /Fo$(OBJ_D)\uplink.obj $(SHLIB_CFLAGS) -c ms\uplink.c
$(INCO_D)\applink.c:	ms\applink.c
	$(CP) ms\applink.c $(INCO_D)\applink.c

EXHEADER= $(EXHEADER) $(INCO_D)\applink.c

LIBS_DEP=$(LIBS_DEP) $(OBJ_D)\applink.obj
CRYPTOOBJ=$(OBJ_D)\uplink.obj $(CRYPTOOBJ)
___
	$banner.=<<'___' if ($FLAVOR =~ /WIN64/);
CRYPTOOBJ=ms\uptable.obj $(CRYPTOOBJ)
___
	}
elsif ($shlib && $FLAVOR =~ /CE/)
	{
	$mlflags.=" $lflags /dll";
	$lib_cflag=" -D_WINDLL -D_DLL";
	$out_def='out32dll_$(TARGETCPU)';
	$tmp_def='tmp32dll_$(TARGETCPU)';
d116 2
a117 2
	local($objs,$target,$name,$shlib)=@@_;
	local($ret);
d120 7
a126 1
	if ($name ne "")
d128 1
a128 2
		$name =~ tr/a-z/A-Z/;
		$name = "/def:ms/${name}.def";
d131 1
a132 1
	$ret.="$target: $objs\n";
d136 3
a138 1
		$ex =' ';
d143 4
a146 6
		local($ex)=($target =~ /O_CRYPTO/)?'':' $(L_CRYPTO)';
		if ($name eq "")
			{
			$ex.=' bufferoverflowu.lib' if ($FLAVOR =~ /WIN64/);
			}
		elsif ($FLAVOR =~ /CE/)
d148 12
a159 1
			$ex.=' winsock.lib $(WCECOMPAT)/lib/wcecompatex.lib';
d163 2
a164 3
			$ex.=' unicows.lib' if ($FLAVOR =~ /NT/);
			$ex.=' wsock32.lib gdi32.lib advapi32.lib user32.lib';
			$ex.=' bufferoverflowu.lib' if ($FLAVOR =~ /WIN64/);
a165 3
		$ex.=" $zlib_lib" if $zlib_opt == 1 && $target =~ /O_CRYPTO/;
		$ret.="\t\$(LINK) \$(MLFLAGS) $efile$target $name @@<<\n  \$(SHLIB_EX_OBJ) $objs $ex\n<<\n";
        $ret.="\tIF EXIST \$@@.manifest mt -nologo -manifest \$@@.manifest -outputresource:\$@@;2\n\n";
d173 34
d209 1
a209 1
	
d213 3
a215 3
	$ret.="\t\$(LINK) \$(LFLAGS) $efile$target @@<<\n";
	$ret.="  \$(APP_EX_OBJ) $files $libs\n<<\n";
    $ret.="\tIF EXIST \$@@.manifest mt -nologo -manifest \$@@.manifest -outputresource:\$@@;1\n\n";
d218 1
@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@d7 1
a7 15

if ($fips && !$shlib)
	{
	$crypto="libeayfips32";
	$crypto_compat = "libeaycompat32.lib";
	}
else
	{
	$crypto="libeay32";
	}

if ($fipscanisterbuild)
	{
	$fips_canister_path = "\$(LIB_D)\\fipscanister.lib";
	}
d12 1
a12 1
$rm='del /Q';
d99 1
a99 1
    my $f = $shlib || $fips ?' /MD':' /MT';
d141 1
a141 1
	$ex_libs.=' gdi32.lib crypt32.lib advapi32.lib user32.lib';
a167 4
} elsif ($ml64) {
	$asm='ml64 /c /Cp /Cx';
	$asm.=' /Zi' if $debug;
	$afile='/Fo';
a173 1
$aes_asm_obj='';
a181 2
    {
    if ($FLAVOR =~ "WIN32")
d185 2
a186 2
	$bn_asm_obj='crypto\bn\asm\bn_win32.obj crypto\bn\asm\mt_win32.obj';
	$bn_asm_src='crypto\bn\asm\bn_win32.asm crypto\bn\asm\mt_win32.asm';
d207 1
a207 1
	$cflags.=" -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DAES_ASM -DBN_ASM -DOPENSSL_BN_ASM_PART_WORDS -DOPENSSL_BN_ASM_MONT -DMD5_ASM -DSHA1_ASM -DRMD160_ASM";
a208 13
    elsif ($FLAVOR =~ "WIN64A")
	{
	$aes_asm_obj='$(OBJ_D)\aes-x86_64.obj';
	$aes_asm_src='crypto\aes\asm\aes-x86_64.asm';
	$bn_asm_obj='$(OBJ_D)\x86_64-mont.obj $(OBJ_D)\bn_asm.obj';
	$bn_asm_src='crypto\bn\asm\x86_64-mont.asm';
	$sha1_asm_obj='$(OBJ_D)\sha1-x86_64.obj $(OBJ_D)\sha256-x86_64.obj $(OBJ_D)\sha512-x86_64.obj';
	$sha1_asm_src='crypto\sha\asm\sha1-x86_64.asm crypto\sha\asm\sha256-x86_64.asm crypto\sha\asm\sha512-x86_64.asm';
	$cpuid_asm_obj='$(OBJ_D)\cpuid-x86_64.obj';
	$cpuid_asm_src='crypto\cpuid-x86_64.asm';
	$cflags.=" -DOPENSSL_CPUID_OBJ -DAES_ASM -DOPENSSL_BN_ASM_MONT -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM";
	}
    }
a212 1
#	$cflags =~ s| /MD| /MT|;
d235 1
a236 1
$banner .= "CRYPTOOBJ=\$(OBJ_D)\\uplink.obj \$(CRYPTOOBJ)\n";
d253 1
a253 1
	my($objs,$target,$name,$shlib,$ign,$base_addr) = @@_;
d257 1
a257 14
	my $base_arg;
	if ($base_addr ne "")
		{
		$base_arg= " /base:$base_addr";
		}
	else
		{
		$base_arg = "";
		}
	if ($target =~ /O_CRYPTO/ && $fipsdso)
		{
		$name = "/def:ms/libeayfips.def";
		}
	elsif ($name ne "")
d264 1
a264 1
#	$ret.="$target: $objs\n";
a268 1
		$ret.="$target: $objs\n";
d273 1
a273 17
		my $ex = "";		
		if ($target =~ /O_SSL/)
			{
			$ex .= " \$(L_CRYPTO)";
			#$ex .= " \$(L_FIPS)" if $fipsdso;
			}
		my $fipstarget;
		if ($fipsdso)
			{
			$fipstarget = "O_FIPS";
			}
		else
			{
			$fipstarget = "O_CRYPTO";
			}


a276 4
			if ($target =~ /capi/)
				{
				$ex.=' crypt32.lib advapi32.lib';
				}
a285 1
			$ex.=' crypt32.lib';
d289 1
a289 33

 		if ($fips && $target =~ /$fipstarget/)
			{
			$ex.= $mwex unless $fipscanisterbuild;
			$ret.="$target: $objs \$(PREMAIN_DSO_EXE)";
			if ($fipsdso)
				{
				$ex.=" \$(OBJ_D)\\\$(LIBFIPS).res";
				$ret.=" \$(OBJ_D)\\\$(LIBFIPS).res";
				$ret.=" ms/\$(LIBFIPS).def";
				}
			$ret.="\n\tSET FIPS_LINK=\$(LINK)\n";
			$ret.="\tSET FIPS_CC=\$(CC)\n";
			$ret.="\tSET FIPS_CC_ARGS=/Fo\$(OBJ_D)${o}fips_premain.obj \$(SHLIB_CFLAGS) -c\n";
			$ret.="\tSET PREMAIN_DSO_EXE=\$(PREMAIN_DSO_EXE)\n";
			$ret.="\tSET FIPS_SHA1_EXE=\$(FIPS_SHA1_EXE)\n";
			$ret.="\tSET FIPS_TARGET=$target\n";
			$ret.="\tSET FIPSLIB_D=\$(FIPSLIB_D)\n";
			$ret.="\t\$(FIPSLINK) \$(MLFLAGS) /map $base_arg $efile$target ";
			$ret.="$name @@<<\n  \$(SHLIB_EX_OBJ) $objs ";
			$ret.="\$(OBJ_D)${o}fips_premain.obj $ex\n<<\n";
			}
		else
			{
			$ret.="$target: $objs";
			if ($target =~ /O_CRYPTO/ && $fipsdso)
				{
				$ret .= " \$(O_FIPS)";
				$ex .= " \$(L_FIPS)";
				}
			$ret.="\n\t\$(LINK) \$(MLFLAGS) $efile$target $name @@<<\n  \$(SHLIB_EX_OBJ) $objs $ex\n<<\n";
			}

d298 1
a298 1
	my($target,$files,$dep_libs,$libs,$standalone)=@@_;
d300 1
d304 3
a306 44
	if ($standalone == 1)
		{
		$ret.="  \$(LINK) \$(LFLAGS) $efile$target @@<<\n\t";
		$ret.= "$mwex advapi32.lib " if ($files =~ /O_FIPSCANISTER/ && !$fipscanisterbuild);
		$ret.="$files $libs\n<<\n";
		}
	elsif ($standalone == 2)
		{
		$ret.="\tSET FIPS_LINK=\$(LINK)\n";
		$ret.="\tSET FIPS_CC=\$(CC)\n";
		$ret.="\tSET FIPS_CC_ARGS=/Fo\$(OBJ_D)${o}fips_premain.obj \$(SHLIB_CFLAGS) -c\n";
		$ret.="\tSET PREMAIN_DSO_EXE=\n";
		$ret.="\tSET FIPS_TARGET=$target\n";
		$ret.="\tSET FIPS_SHA1_EXE=\$(FIPS_SHA1_EXE)\n";
		$ret.="\tSET FIPSLIB_D=\$(FIPSLIB_D)\n";
		$ret.="\t\$(FIPSLINK) \$(LFLAGS) /map $efile$target @@<<\n";
		$ret.="\t\$(APP_EX_OBJ) $files \$(OBJ_D)${o}fips_premain.obj $libs\n<<\n";
		}
	else
		{
		$ret.="\t\$(LINK) \$(LFLAGS) $efile$target @@<<\n";
		$ret.="\t\$(APP_EX_OBJ) $files $libs\n<<\n";
		}
    	$ret.="\tIF EXIST \$@@.manifest mt -nologo -manifest \$@@.manifest -outputresource:\$@@;1\n\n";
	return($ret);
	}

sub do_rlink_rule
	{
	local($target,$rl_start, $rl_mid, $rl_end,$dep_libs,$libs)=@@_;
	local($ret,$_);
	my $files = "$rl_start $rl_mid $rl_end";

	$file =~ s/\//$o/g if $o ne '/';
	$n=&bname($targer);
	$ret.="$target: $files $dep_libs \$(FIPS_SHA1_EXE)\n";
	$ret.="\t\$(PERL) ms\\segrenam.pl \$\$a $rl_start\n";
	$ret.="\t\$(PERL) ms\\segrenam.pl \$\$b $rl_mid\n";
	$ret.="\t\$(PERL) ms\\segrenam.pl \$\$c $rl_end\n";
	$ret.="\t\$(MKLIB) $lfile$target @@<<\n\t$files\n<<\n";
	$ret.="\t\$(FIPS_SHA1_EXE) $target > ${target}.sha1\n";
	$ret.="\t\$(PERL) util${o}copy.pl -stripcr fips${o}fips_premain.c \$(LIB_D)${o}fips_premain.c\n";
	$ret.="\t\$(CP) fips${o}fips_premain.c.sha1 \$(LIB_D)${o}fips_premain.c.sha1\n";
	$ret.="\n";
a307 8
	}

sub do_sdef_rule
	{
	my $ret = "ms/\$(LIBFIPS).def: \$(O_FIPSCANISTER)\n";
	$ret.="\t\$(PERL) util/mksdef.pl \$(MLFLAGS) /out:dummy.dll /def:ms/libeay32.def @@<<\n  \$(O_FIPSCANISTER)\n<<\n";
	$ret.="\n";
	return $ret;
@


1.1.1.9
log
@import of OpenSSL 0.9.8k
@
text
@d167 1
a167 1
$mklib='lib /nologo';
d187 1
a187 1
	$asm='ml /nologo /Cp /coff /c /Cx';
d408 1
a408 1
		$ret.= "\$(EX_LIBS) " if ($files =~ /O_FIPSCANISTER/ && !$fipscanisterbuild);
@


1.1.1.10
log
@import OpenSSL-1.0.0a
@
text
@d7 15
a21 1
$crypto="libeay32";
a29 4
# Santize -L options for ms link
$l_flags =~ s/-L("\[^"]+")/\/libpath:$1/g;
$l_flags =~ s/-L(\S+)/\/libpath:$1/g;

d45 3
a47 1
    $base_cflags= " $mf_cflag";
a52 16

    *::perlasm_compile_target = sub {
	my ($target,$source,$bname)=@@_;
	my $ret;

	$bname =~ s/(.*)\.[^\.]$/$1/;
	$ret=<<___;
\$(TMP_D)$o$bname.asm: $source
	set ASM=\$(ASM)
	\$(PERL) $source \$\@@

$target: \$(TMP_D)$o$bname.asm
	\$(ASM) $afile\$\@@ \$(TMP_D)$o$bname.asm

___
	}
d102 1
a102 1
    $base_cflags=' /W3 /WX /GF /Gy /nologo -DUNICODE -D_UNICODE -DOPENSSL_SYSNAME_WINCE -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DDSO_WIN32 -DNO_CHMOD -DOPENSSL_SMALL_FOOTPRINT';
a103 2
    $base_cflags.=' -I$(WCECOMPAT)/include'		if (defined($ENV{'WCECOMPAT'}));
    $base_cflags.=' -I$(PORTSDK_LIBPATH)/../../include'	if (defined($ENV{'PORTSDK_LIBPATH'}));
d110 4
a113 2
    $base_cflags= " $mf_cflag";
    my $f = $shlib?' /MD':' /MT';
d121 2
a122 4
$out_def ="out32";	$out_def.="dll"			if ($shlib);
			$out_def.='_$(TARGETCPU)'	if ($FLAVOR =~ /CE/);
$tmp_def ="tmp32";	$tmp_def.="dll"			if ($shlib);
			$tmp_def.='_$(TARGETCPU)'	if ($FLAVOR =~ /CE/);
d128 2
a135 5
# generate symbols.pdb unconditionally
$app_cflag.=" /Zi /Fd$tmp_def/app";
$lib_cflag.=" /Zi /Fd$tmp_def/lib";
$lflags.=" /debug";

a136 1
$asm_suffix='.asm';
d146 1
a146 1
else			{ $ex_libs='ws2_32.lib'; }
d150 1
a150 2
	$ex_libs.=' $(WCECOMPAT)/lib/wcecompatex.lib'	if (defined($ENV{'WCECOMPAT'}));
	$ex_libs.=' $(PORTSDK_LIBPATH)/portlib.lib'	if (defined($ENV{'PORTSDK_LIBPATH'}));
d155 2
a156 5
	$ex_libs.=' gdi32.lib advapi32.lib crypt32.lib user32.lib';
	$ex_libs.=' bufferoverflowu.lib' if ($FLAVOR =~ /WIN64/ and `cl 2>&1` =~ /14\.00\.4[0-9]{4}\./);
	# WIN32 UNICODE build gets linked with unicows.lib for
	# backward compatibility with Win9x.
	$ex_libs="unicows.lib $ex_libs" if ($FLAVOR =~ /WIN32/ and $cflags =~ /\-DUNICODE/);
d159 7
d176 1
a176 12
if ($FLAVOR =~ /WIN64A/) {
	if (`nasm -v 2>NUL` =~ /NASM version ([0-9]+\.[0-9]+)/ && $1 >= 2.0) {
		$asm='nasm -f win64 -DNEAR -Ox -g';
		$afile='-o ';
	} else {
		$asm='ml64 /c /Cp /Cx /Zi';
		$afile='/Fo';
	}
} elsif ($FLAVOR =~ /WIN64I/) {
	$asm='ias -d debug';
	$afile="-o ";
} elsif ($nasm) {
a180 1
	$asmtype="win32n";
d182 4
d187 2
a188 1
	$asm='ml /nologo /Cp /coff /c /Cx /Zi';
a189 1
	$asmtype="win32";
d192 1
d201 2
d204 25
a228 13
	win32_import_asm($mf_bn_asm, "bn", \$bn_asm_obj, \$bn_asm_src);
	win32_import_asm($mf_aes_asm, "aes", \$aes_asm_obj, \$aes_asm_src);
	win32_import_asm($mf_des_asm, "des", \$des_enc_obj, \$des_enc_src);
	win32_import_asm($mf_bf_asm, "bf", \$bf_enc_obj, \$bf_enc_src);
	win32_import_asm($mf_cast_asm, "cast", \$cast_enc_obj, \$cast_enc_src);
	win32_import_asm($mf_rc4_asm, "rc4", \$rc4_enc_obj, \$rc4_enc_src);
	win32_import_asm($mf_rc5_asm, "rc5", \$rc5_enc_obj, \$rc5_enc_src);
	win32_import_asm($mf_md5_asm, "md5", \$md5_asm_obj, \$md5_asm_src);
	win32_import_asm($mf_sha_asm, "sha", \$sha1_asm_obj, \$sha1_asm_src);
	win32_import_asm($mf_rmd_asm, "ripemd", \$rmd160_asm_obj, \$rmd160_asm_src);
	win32_import_asm($mf_wp_asm, "whrlpool", \$whirlpool_asm_obj, \$whirlpool_asm_src);
	win32_import_asm($mf_cpuid_asm, "", \$cpuid_asm_obj, \$cpuid_asm_src);
	$perl_asm = 1;
d230 13
d247 4
a250 1
	$lib_cflag.=" -D_WINDLL";
a269 1
CRYPTOOBJ=$(OBJ_D)\uplink.obj $(CRYPTOOBJ)
d271 1
d279 3
a281 2
	$lflags.=' /entry:mainCRTstartup' if(defined($ENV{'PORTSDK_LIBPATH'}));
	$lib_cflag.=" -D_WINDLL -D_DLL";
d284 2
d288 1
a288 1
	local($objs,$target,$name,$shlib)=@@_;
d292 14
a305 1
	if ($name ne "")
d312 1
a312 1
	$ret.="$target: $objs\n";
d316 3
a318 1
		$ret.="\t\$(MKLIB) $lfile$target @@<<\n  $objs\n<<\n";
d322 36
a357 1
		local($ex)=($target =~ /O_CRYPTO/)?'':' $(L_CRYPTO)';
d359 34
a392 2
		$ret.="\t\$(LINK) \$(MLFLAGS) $efile$target $name @@<<\n  \$(SHLIB_EX_OBJ) $objs $ex \$(EX_LIBS)\n<<\n";
		$ret.="\tIF EXIST \$@@.manifest mt -nologo -manifest \$@@.manifest -outputresource:\$@@;2\n\n";
d400 1
a400 1
	local($target,$files,$dep_libs,$libs)=@@_;
a401 1
	
d405 7
a411 11
	$ret.="\t\$(LINK) \$(LFLAGS) $efile$target @@<<\n";
	$ret.="  \$(APP_EX_OBJ) $files $libs\n<<\n";
	$ret.="\tIF EXIST \$@@.manifest mt -nologo -manifest \$@@.manifest -outputresource:\$@@;1\n\n";
	return($ret);
	}

sub win32_import_asm
	{
	my ($mf_var, $asm_name, $oref, $sref) = @@_;
	my $asm_dir;
	if ($asm_name eq "")
d413 9
a421 1
		$asm_dir = "crypto\\";
d425 2
a426 1
		$asm_dir = "crypto\\$asm_name\\asm\\";
d428 3
d432 5
a436 2
	$$oref = "";
	$mf_var =~ s/\.o$/.obj/g;
d438 13
a450 7
	foreach (split(/ /, $mf_var))
		{
		$$oref .= $asm_dir . $_ . " ";
		}
	$$oref =~ s/ $//;
	$$sref = $$oref;
	$$sref =~ s/\.obj/.asm/g;
d452 6
a458 1

@


1.1.1.11
log
@import OpenSSL 1.0.0e
@
text
@d141 2
a142 2
$app_cflag.=" /Zi /Fd\$(TMP_D)/app";
$lib_cflag.=" /Zi /Fd\$(TMP_D)/lib";
d198 1
a198 1
	$asm=($ver ge $vew?"nasm":"nasmw")." -f win32";
@


1.1.1.12
log
@import OpenSSL-1.0.1c
@
text
@a8 10
if ($fips && !$shlib)
	{
	$crypto="libeayfips32";
	$crypto_compat = "libeaycompat32.lib";
	}
else
	{
	$crypto="libeay32";
	}

d36 1
a36 1
    my $f = $shlib || $fips ?' /MD':' /MT';
d117 1
a117 1
    my $f = $shlib || $fips ?' /MD':' /MT';
d269 1
a269 1
	my($objs,$target,$name,$shlib,$ign,$base_addr) = @@_;
a272 9
	my $base_arg;
	if ($base_addr ne "")
		{
		$base_arg= " /base:$base_addr";
		}
	else
		{
		$base_arg = "";
		}
d280 1
a280 1
#	$ret.="$target: $objs\n";
a283 1
		$ret.="$target: $objs\n";
d290 1
a290 20

 		if ($fips && $target =~ /O_CRYPTO/)
			{
			$ret.="$target: $objs \$(PREMAIN_DSO_EXE)";
			$ret.="\n\tSET FIPS_LINK=\$(LINK)\n";
			$ret.="\tSET FIPS_CC=\$(CC)\n";
			$ret.="\tSET FIPS_CC_ARGS=/Fo\$(OBJ_D)${o}fips_premain.obj \$(SHLIB_CFLAGS) -c\n";
			$ret.="\tSET PREMAIN_DSO_EXE=\$(PREMAIN_DSO_EXE)\n";
			$ret.="\tSET FIPS_SHA1_EXE=\$(FIPS_SHA1_EXE)\n";
			$ret.="\tSET FIPS_TARGET=$target\n";
			$ret.="\tSET FIPSLIB_D=\$(FIPSLIB_D)\n";
			$ret.="\t\$(FIPSLINK) \$(MLFLAGS) /map $base_arg $efile$target ";
			$ret.="$name @@<<\n  \$(SHLIB_EX_OBJ) $objs \$(EX_LIBS) ";
			$ret.="\$(OBJ_D)${o}fips_premain.obj $ex\n<<\n";
			}
		else
			{
			$ret.="$target: $objs";
			$ret.="\n\t\$(LINK) \$(MLFLAGS) $efile$target $name @@<<\n  \$(SHLIB_EX_OBJ) $objs $ex \$(EX_LIBS)\n<<\n";
			}
d299 1
a299 1
	my($target,$files,$dep_libs,$libs,$standalone)=@@_;
d301 1
d305 3
a307 24
	if ($standalone == 1)
		{
		$ret.="  \$(LINK) \$(LFLAGS) $efile$target @@<<\n\t";
		$ret.= "\$(EX_LIBS) " if ($files =~ /O_FIPSCANISTER/ && !$fipscanisterbuild);
		$ret.="$files $libs\n<<\n";
		}
	elsif ($standalone == 2)
		{
		$ret.="\tSET FIPS_LINK=\$(LINK)\n";
		$ret.="\tSET FIPS_CC=\$(CC)\n";
		$ret.="\tSET FIPS_CC_ARGS=/Fo\$(OBJ_D)${o}fips_premain.obj \$(SHLIB_CFLAGS) -c\n";
		$ret.="\tSET PREMAIN_DSO_EXE=\n";
		$ret.="\tSET FIPS_TARGET=$target\n";
		$ret.="\tSET FIPS_SHA1_EXE=\$(FIPS_SHA1_EXE)\n";
		$ret.="\tSET FIPSLIB_D=\$(FIPSLIB_D)\n";
		$ret.="\t\$(FIPSLINK) \$(LFLAGS) /map $efile$target @@<<\n";
		$ret.="\t\$(APP_EX_OBJ) $files \$(OBJ_D)${o}fips_premain.obj $libs\n<<\n";
		}
	else
		{
		$ret.="\t\$(LINK) \$(LFLAGS) $efile$target @@<<\n";
		$ret.="\t\$(APP_EX_OBJ) $files $libs\n<<\n";
		}
    	$ret.="\tIF EXIST \$@@.manifest mt -nologo -manifest \$@@.manifest -outputresource:\$@@;1\n\n";
@


1.1.1.13
log
@Import OpenSSL 1.0.1g
@
text
@a29 2
my $ff = "";

d121 1
a121 1
    $dbg_cflags=' /MC /Od -DDEBUG -D_DEBUG';
a128 1
    $ff = "/fixed";
d321 1
a321 1
			$ret.="\t\$(FIPSLINK) \$(MLFLAGS) $ff /map $base_arg $efile$target ";
d358 1
a358 1
		$ret.="\t\$(FIPSLINK) \$(LFLAGS) $ff /map $efile$target @@<<\n";
@


