head	1.19;
access;
symbols
	butholakala:1.17
	openssl_1_0_1_g:1.1.1.12
	OPENBSD_5_5:1.16.0.8
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	openssl_1_0_1_c:1.1.1.12
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	openssl_1_0_0_f:1.1.1.11
	openssl_1_0_0_e:1.1.1.11
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	openssh_1_0_0_a:1.1.1.10
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	openssl_0_9_8_k:1.1.1.9
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	openssl_0_9_8_j:1.1.1.9
	openssl_0_9_8_h:1.1.1.8
	pre_openssl_0_9_8h:1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	openssl_0_9_7j:1.1.1.7
	openssl:1.1.1
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENSSL_0_9_7G:1.1.1.6
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENSSL_0_9_7D:1.1.1.5
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@# @;


1.19
date	2014.04.17.19.20.52;	author afresh1;	state dead;
branches;
next	1.18;

1.18
date	2014.04.15.18.02.05;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.13.15.25.35;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2010.10.01.22.59.01;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.06.12.17.54;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.27.05.07.03;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.29.05.39.33;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.08.08.03.15;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.21;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.58.45;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.15.06.18.51;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.40;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.58;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.58;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.50;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.45.13;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.36.56;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.20.42.11;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.04.29.05.37.31;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.06.27.05.05.40;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.06.12.15.53;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.01.09.12.14.08;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.10.01.22.54.18;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2011.11.03.02.32.22;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2012.10.13.21.23.53;	author djm;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Remove unused ssl utils

This code is the reason perl has a name as a write only language.

ok deraadt miod
@
text
@#!/usr/local/bin/perl
# A bit of an evil hack but it post processes the file ../MINFO which
# is generated by `make files` in the top directory.
# This script outputs one mega makefile that has no shell stuff or any
# funny stuff
#

$INSTALLTOP="/usr/local/ssl";
$OPENSSLDIR="/usr/local/ssl";
$OPTIONS="";
$ssl_version="";
$banner="\t\@@echo Building OpenSSL";

my $no_static_engine = 1;
my $engines = "";
my $otherlibs = "";
local $zlib_opt = 0;	# 0 = no zlib, 1 = static, 2 = dynamic
local $zlib_lib = "";
local $perl_asm = 0;	# 1 to autobuild asm files from perl scripts

my $ex_l_libs = "";

# Options to import from top level Makefile

my %mf_import = (
	VERSION	       => \$ssl_version,
	OPTIONS        => \$OPTIONS,
	INSTALLTOP     => \$INSTALLTOP,
	OPENSSLDIR     => \$OPENSSLDIR,
	PLATFORM       => \$mf_platform,
	CFLAG	       => \$mf_cflag,
	DEPFLAG	       => \$mf_depflag,
	CPUID_OBJ      => \$mf_cpuid_asm,
	BN_ASM	       => \$mf_bn_asm,
	DES_ENC	       => \$mf_des_asm,
	AES_ENC        => \$mf_aes_asm,
	BF_ENC	       => \$mf_bf_asm,
	CAST_ENC       => \$mf_cast_asm,
	RC4_ENC	       => \$mf_rc4_asm,
	RC5_ENC        => \$mf_rc5_asm,
	MD5_ASM_OBJ    => \$mf_md5_asm,
	SHA1_ASM_OBJ   => \$mf_sha_asm,
	RMD160_ASM_OBJ => \$mf_rmd_asm,
	WP_ASM_OBJ     => \$mf_wp_asm,
	CMLL_ENC       => \$mf_cm_asm,
	BASEADDR       => \$baseaddr,
	FIPSDIR        => \$fipsdir,
);


open(IN,"<Makefile") || die "unable to open Makefile!\n";
while(<IN>) {
    my ($mf_opt, $mf_ref);
    while (($mf_opt, $mf_ref) = each %mf_import) {
    	if (/^$mf_opt\s*=\s*(.*)$/) {
	   $$mf_ref = $1;
	}
    }
}
close(IN);

$debug = 1 if $mf_platform =~ /^debug-/;

die "Makefile is not the toplevel Makefile!\n" if $ssl_version eq "";

$infile="MINFO";

%ops=(
	"VC-WIN32",   "Microsoft Visual C++ [4-6] - Windows NT or 9X",
	"VC-WIN64I",  "Microsoft C/C++ - Win64/IA-64",
	"VC-WIN64A",  "Microsoft C/C++ - Win64/x64",
	"VC-CE",   "Microsoft eMbedded Visual C++ 3.0 - Windows CE ONLY",
	"VC-NT",   "Microsoft Visual C++ [4-6] - Windows NT ONLY",
	"Mingw32", "GNU C++ - Windows NT or 9x",
	"Mingw32-files", "Create files with DOS copy ...",
	"BC-NT",   "Borland C++ 4.5 - Windows NT",
	"linux-elf","Linux elf",
	"ultrix-mips","DEC mips ultrix",
	"FreeBSD","FreeBSD distribution",
	"OS2-EMX", "EMX GCC OS/2",
	"netware-clib", "CodeWarrior for NetWare - CLib - with WinSock Sockets",
	"netware-clib-bsdsock", "CodeWarrior for NetWare - CLib - with BSD Sockets",
	"netware-libc", "CodeWarrior for NetWare - LibC - with WinSock Sockets",
	"netware-libc-bsdsock", "CodeWarrior for NetWare - LibC - with BSD Sockets",
	"default","cc under unix",
	"auto", "auto detect from top level Makefile"
	);

$platform="";
my $xcflags="";
foreach (@@ARGV)
	{
	if (!&read_options && !defined($ops{$_}))
		{
		print STDERR "unknown option - $_\n";
		print STDERR "usage: perl mk1mf.pl [options] [system]\n";
		print STDERR "\nwhere [system] can be one of the following\n";
		foreach $i (sort keys %ops)
		{ printf STDERR "\t%-10s\t%s\n",$i,$ops{$i}; }
		print STDERR <<"EOF";
and [options] can be one of
	no-md2 no-md4 no-md5 no-sha no-mdc2	- Skip this digest
	no-ripemd
	no-rc2 no-rc4 no-rc5 no-idea no-des     - Skip this symetric cipher
	no-bf no-cast no-aes no-camellia no-seed
	no-rsa no-dsa no-dh			- Skip this public key cipher
	no-ssl2 no-ssl3				- Skip this version of SSL
	just-ssl				- remove all non-ssl keys/digest
	no-asm 					- No x86 asm
	no-krb5					- No KRB5
	no-srp					- No SRP
	no-ec					- No EC
	no-ecdsa				- No ECDSA
	no-ecdh					- No ECDH
	no-engine				- No engine
	no-hw					- No hw
	nasm 					- Use NASM for x86 asm
	nw-nasm					- Use NASM x86 asm for NetWare
	nw-mwasm				- Use Metrowerks x86 asm for NetWare
	gaswin					- Use GNU as with Mingw32
	no-socks				- No socket code
	no-err					- No error strings
	dll/shlib				- Build shared libraries (MS)
	debug					- Debug build
        profile                                 - Profiling build
	gcc					- Use Gcc (unix)

Values that can be set
TMP=tmpdir OUT=outdir SRC=srcdir BIN=binpath INC=header-outdir CC=C-compiler

-L<ex_lib_path> -l<ex_lib>			- extra library flags (unix)
-<ex_cc_flags>					- extra 'cc' flags,
						  added (MS), or replace (unix)
EOF
		exit(1);
		}
	$platform=$_;
	}
foreach (grep(!/^$/, split(/ /, $OPTIONS)))
	{
	print STDERR "unknown option - $_\n" if !&read_options;
	}

$no_static_engine = 0 if (!$shlib);

$no_mdc2=1 if ($no_des);

$no_ssl3=1 if ($no_md5 || $no_sha);
$no_ssl3=1 if ($no_rsa && $no_dh);

$no_ssl2=1 if ($no_md5);
$no_ssl2=1 if ($no_rsa);

$out_def="out";
$inc_def="outinc";
$tmp_def="tmp";

$perl="perl" unless defined $perl;
$mkdir="-mkdir" unless defined $mkdir;

($ssl,$crypto)=("ssl","crypto");
$ranlib="echo ranlib";

$cc=(defined($VARS{'CC'}))?$VARS{'CC'}:'cc';
$src_dir=(defined($VARS{'SRC'}))?$VARS{'SRC'}:'.';
$bin_dir=(defined($VARS{'BIN'}))?$VARS{'BIN'}:'';

# $bin_dir.=$o causes a core dump on my sparc :-(


$NT=0;

push(@@INC,"util/pl","pl");

if ($platform eq "auto") {
	$platform = $mf_platform;
	print STDERR "Imported platform $mf_platform\n";
}

if (($platform =~ /VC-(.+)/))
	{
	$FLAVOR=$1;
	$NT = 1 if $1 eq "NT";
	require 'VC-32.pl';
	}
elsif ($platform eq "Mingw32")
	{
	require 'Mingw32.pl';
	}
elsif ($platform eq "Mingw32-files")
	{
	require 'Mingw32f.pl';
	}
elsif ($platform eq "BC-NT")
	{
	$bc=1;
	require 'BC-32.pl';
	}
elsif ($platform eq "FreeBSD")
	{
	require 'unix.pl';
	$cflags='-DTERMIO -D_ANSI_SOURCE -O2 -fomit-frame-pointer';
	}
elsif ($platform eq "linux-elf")
	{
	require "unix.pl";
	require "linux.pl";
	$unix=1;
	}
elsif ($platform eq "ultrix-mips")
	{
	require "unix.pl";
	require "ultrix.pl";
	$unix=1;
	}
elsif ($platform eq "OS2-EMX")
	{
	$wc=1;
	require 'OS2-EMX.pl';
	}
elsif (($platform eq "netware-clib") || ($platform eq "netware-libc") ||
       ($platform eq "netware-clib-bsdsock") || ($platform eq "netware-libc-bsdsock"))
	{
	$LIBC=1 if $platform eq "netware-libc" || $platform eq "netware-libc-bsdsock";
	$BSDSOCK=1 if ($platform eq "netware-libc-bsdsock") || ($platform eq "netware-clib-bsdsock");
	require 'netware.pl';
	}
else
	{
	require "unix.pl";

	$unix=1;
	$cflags.=' -DTERMIO';
	}

$fipsdir =~ s/\//${o}/g;

$out_dir=(defined($VARS{'OUT'}))?$VARS{'OUT'}:$out_def.($debug?".dbg":"");
$tmp_dir=(defined($VARS{'TMP'}))?$VARS{'TMP'}:$tmp_def.($debug?".dbg":"");
$inc_dir=(defined($VARS{'INC'}))?$VARS{'INC'}:$inc_def;

$bin_dir=$bin_dir.$o unless ((substr($bin_dir,-1,1) eq $o) || ($bin_dir eq ''));

$cflags= "$xcflags$cflags" if $xcflags ne "";

$cflags.=" -DOPENSSL_NO_IDEA" if $no_idea;
$cflags.=" -DOPENSSL_NO_AES"  if $no_aes;
$cflags.=" -DOPENSSL_NO_CAMELLIA"  if $no_camellia;
$cflags.=" -DOPENSSL_NO_SEED" if $no_seed;
$cflags.=" -DOPENSSL_NO_RC2"  if $no_rc2;
$cflags.=" -DOPENSSL_NO_RC4"  if $no_rc4;
$cflags.=" -DOPENSSL_NO_RC5"  if $no_rc5;
$cflags.=" -DOPENSSL_NO_MD2"  if $no_md2;
$cflags.=" -DOPENSSL_NO_MD4"  if $no_md4;
$cflags.=" -DOPENSSL_NO_MD5"  if $no_md5;
$cflags.=" -DOPENSSL_NO_SHA"  if $no_sha;
$cflags.=" -DOPENSSL_NO_SHA1" if $no_sha1;
$cflags.=" -DOPENSSL_NO_RIPEMD" if $no_ripemd;
$cflags.=" -DOPENSSL_NO_MDC2" if $no_mdc2;
$cflags.=" -DOPENSSL_NO_BF"  if $no_bf;
$cflags.=" -DOPENSSL_NO_CAST" if $no_cast;
$cflags.=" -DOPENSSL_NO_DES"  if $no_des;
$cflags.=" -DOPENSSL_NO_RSA"  if $no_rsa;
$cflags.=" -DOPENSSL_NO_DSA"  if $no_dsa;
$cflags.=" -DOPENSSL_NO_DH"   if $no_dh;
$cflags.=" -DOPENSSL_NO_WHIRLPOOL"   if $no_whirlpool;
$cflags.=" -DOPENSSL_NO_SOCK" if $no_sock;
$cflags.=" -DOPENSSL_NO_SSL2" if $no_ssl2;
$cflags.=" -DOPENSSL_NO_SSL3" if $no_ssl3;
$cflags.=" -DOPENSSL_NO_TLSEXT" if $no_tlsext;
$cflags.=" -DOPENSSL_NO_SRP" if $no_srp;
$cflags.=" -DOPENSSL_NO_CMS" if $no_cms;
$cflags.=" -DOPENSSL_NO_ERR"  if $no_err;
$cflags.=" -DOPENSSL_NO_KRB5" if $no_krb5;
$cflags.=" -DOPENSSL_NO_EC"   if $no_ec;
$cflags.=" -DOPENSSL_NO_ECDSA" if $no_ecdsa;
$cflags.=" -DOPENSSL_NO_ECDH" if $no_ecdh;
$cflags.=" -DOPENSSL_NO_GOST" if $no_gost;
$cflags.=" -DOPENSSL_NO_ENGINE"   if $no_engine;
$cflags.=" -DOPENSSL_NO_HW"   if $no_hw;
$cflags.=" -DOPENSSL_FIPS"    if $fips;
$cflags.=" -DOPENSSL_NO_JPAKE"    if $no_jpake;
$cflags.=" -DOPENSSL_NO_EC2M"    if $no_ec2m;
$cflags.= " -DZLIB" if $zlib_opt;
$cflags.= " -DZLIB_SHARED" if $zlib_opt == 2;

if ($no_static_engine)
	{
	$cflags .= " -DOPENSSL_NO_STATIC_ENGINE";
	}
else
	{
	$cflags .= " -DOPENSSL_NO_DYNAMIC_ENGINE";
	}

#$cflags.=" -DRSAref"  if $rsaref ne "";

## if ($unix)
##	{ $cflags="$c_flags" if ($c_flags ne ""); }
##else
	{ $cflags="$c_flags$cflags" if ($c_flags ne ""); }

$ex_libs="$l_flags$ex_libs" if ($l_flags ne "");


%shlib_ex_cflags=("SSL" => " -DOPENSSL_BUILD_SHLIBSSL",
		  "CRYPTO" => " -DOPENSSL_BUILD_SHLIBCRYPTO");

if ($msdos)
	{
	$banner ="\t\@@echo Make sure you have run 'perl Configure $platform' in the\n";
	$banner.="\t\@@echo top level directory, if you don't have perl, you will\n";
	$banner.="\t\@@echo need to probably edit crypto/bn/bn.h, check the\n";
	$banner.="\t\@@echo documentation for details.\n";
	}

# have to do this to allow $(CC) under unix
$link="$bin_dir$link" if ($link !~ /^\$/);

$INSTALLTOP =~ s|/|$o|g;
$OPENSSLDIR =~ s|/|$o|g;

#############################################
# We parse in input file and 'store' info for later printing.
open(IN,"<$infile") || die "unable to open $infile:$!\n";
$_=<IN>;
for (;;)
	{
	chop;

	($key,$val)=/^([^=]+)=(.*)/;
	if ($key eq "RELATIVE_DIRECTORY")
		{
		if ($lib ne "")
			{
			$uc=$lib;
			$uc =~ s/^lib(.*)\.a/$1/;
			$uc =~ tr/a-z/A-Z/;
			$lib_nam{$uc}=$uc;
			$lib_obj{$uc}.=$libobj." ";
			}
		last if ($val eq "FINISHED");
		$lib="";
		$libobj="";
		$dir=$val;
		}

	if ($key eq "KRB5_INCLUDES")
		{ $cflags .= " $val";}

	if ($key eq "ZLIB_INCLUDE")
		{ $cflags .= " $val" if $val ne "";}

	if ($key eq "LIBZLIB")
		{ $zlib_lib = "$val" if $val ne "";}

	if ($key eq "LIBKRB5")
		{ $ex_libs .= " $val" if $val ne "";}

	if ($key eq "TEST")
		{ $test.=&var_add($dir,$val, 0); }

	if (($key eq "PROGS") || ($key eq "E_OBJ"))
		{ $e_exe.=&var_add($dir,$val, 0); }

	if ($key eq "LIB")
		{
		$lib=$val;
		$lib =~ s/^.*\/([^\/]+)$/$1/;
		}
	if ($key eq "LIBNAME" && $no_static_engine)
		{
		$lib=$val;
		$lib =~ s/^.*\/([^\/]+)$/$1/;
		$otherlibs .= " $lib";
		}

	if ($key eq "EXHEADER")
		{ $exheader.=&var_add($dir,$val, 1); }

	if ($key eq "HEADER")
		{ $header.=&var_add($dir,$val, 1); }

	if ($key eq "LIBOBJ" && ($dir ne "engines" || !$no_static_engine))
		{ $libobj=&var_add($dir,$val, 0); }
	if ($key eq "LIBNAMES" && $dir eq "engines" && $no_static_engine)
 		{ $engines.=$val }

	if (!($_=<IN>))
		{ $_="RELATIVE_DIRECTORY=FINISHED\n"; }
	}
close(IN);

if ($shlib)
	{
	$extra_install= <<"EOF";
	\$(CP) \"\$(O_SSL)\" \"\$(INSTALLTOP)${o}bin\"
	\$(CP) \"\$(O_CRYPTO)\" \"\$(INSTALLTOP)${o}bin\"
	\$(CP) \"\$(L_SSL)\" \"\$(INSTALLTOP)${o}lib\"
	\$(CP) \"\$(L_CRYPTO)\" \"\$(INSTALLTOP)${o}lib\"
EOF
	if ($no_static_engine)
		{
		$extra_install .= <<"EOF"
	\$(MKDIR) \"\$(INSTALLTOP)${o}lib${o}engines\"
	\$(CP) \"\$(E_SHLIB)\" \"\$(INSTALLTOP)${o}lib${o}engines\"
EOF
		}
	}
else
	{
	$extra_install= <<"EOF";
	\$(CP) \"\$(O_SSL)\" \"\$(INSTALLTOP)${o}lib\"
	\$(CP) \"\$(O_CRYPTO)\" \"\$(INSTALLTOP)${o}lib\"
EOF
	$ex_libs .= " $zlib_lib" if $zlib_opt == 1;
	if ($fips)
		{
		$build_targets .= " \$(LIB_D)$o$crypto_compat \$(PREMAIN_DSO_EXE)";
		$ex_l_libs .= " \$(O_FIPSCANISTER)";
		}
	}

$defs= <<"EOF";
# This makefile has been automatically generated from the OpenSSL distribution.
# This single makefile will build the complete OpenSSL distribution and
# by default leave the 'intertesting' output files in .${o}out and the stuff
# that needs deleting in .${o}tmp.
# The file was generated by running 'make makefile.one', which
# does a 'make files', which writes all the environment variables from all
# the makefiles to the file call MINFO.  This file is used by
# util${o}mk1mf.pl to generate makefile.one.
# The 'makefile per directory' system suites me when developing this
# library and also so I can 'distribute' indervidual library sections.
# The one monster makefile better suits building in non-unix
# environments.

EOF

$defs .= $preamble if defined $preamble;

$defs.= <<"EOF";
INSTALLTOP=$INSTALLTOP
OPENSSLDIR=$OPENSSLDIR

# Set your compiler options
PLATFORM=$platform
CC=$bin_dir${cc}
CFLAG=$cflags
APP_CFLAG=$app_cflag
LIB_CFLAG=$lib_cflag
SHLIB_CFLAG=$shl_cflag
APP_EX_OBJ=$app_ex_obj
SHLIB_EX_OBJ=$shlib_ex_obj
# add extra libraries to this define, for solaris -lsocket -lnsl would
# be added
EX_LIBS=$ex_libs

# The OpenSSL directory
SRC_D=$src_dir

LINK=$link
LFLAGS=$lflags
RSC=$rsc

# The output directory for everything intersting
OUT_D=$out_dir
# The output directory for all the temporary muck
TMP_D=$tmp_dir
# The output directory for the header files
INC_D=$inc_dir
INCO_D=$inc_dir${o}openssl

PERL=$perl
CP=$cp
RM=$rm
RANLIB=$ranlib
MKDIR=$mkdir
MKLIB=$bin_dir$mklib
MLFLAGS=$mlflags
ASM=$bin_dir$asm

# FIPS validated module and support file locations

FIPSDIR=$fipsdir
BASEADDR=$baseaddr
FIPSLIB_D=\$(FIPSDIR)${o}lib
FIPS_PREMAIN_SRC=\$(FIPSLIB_D)${o}fips_premain.c
O_FIPSCANISTER=\$(FIPSLIB_D)${o}fipscanister.lib
FIPS_SHA1_EXE=\$(FIPSDIR)${o}bin${o}fips_standalone_sha1${exep}
E_PREMAIN_DSO=fips_premain_dso
PREMAIN_DSO_EXE=\$(BIN_D)${o}fips_premain_dso$exep
FIPSLINK=\$(PERL) \$(FIPSDIR)${o}bin${o}fipslink.pl

######################################################
# You should not need to touch anything below this point
######################################################

E_EXE=openssl
SSL=$ssl
CRYPTO=$crypto

# BIN_D  - Binary output directory
# TEST_D - Binary test file output directory
# LIB_D  - library output directory
# ENG_D  - dynamic engine output directory
# Note: if you change these point to different directories then uncomment out
# the lines around the 'NB' comment below.
# 
BIN_D=\$(OUT_D)
TEST_D=\$(OUT_D)
LIB_D=\$(OUT_D)
ENG_D=\$(OUT_D)

# INCL_D - local library directory
# OBJ_D  - temp object file directory
OBJ_D=\$(TMP_D)
INCL_D=\$(TMP_D)

O_SSL=     \$(LIB_D)$o$plib\$(SSL)$shlibp
O_CRYPTO=  \$(LIB_D)$o$plib\$(CRYPTO)$shlibp
SO_SSL=    $plib\$(SSL)$so_shlibp
SO_CRYPTO= $plib\$(CRYPTO)$so_shlibp
L_SSL=     \$(LIB_D)$o$plib\$(SSL)$libp
L_CRYPTO=  \$(LIB_D)$o$plib\$(CRYPTO)$libp

L_LIBS= \$(L_SSL) \$(L_CRYPTO) $ex_l_libs

######################################################
# Don't touch anything below this point
######################################################

INC=-I\$(INC_D) -I\$(INCL_D)
APP_CFLAGS=\$(INC) \$(CFLAG) \$(APP_CFLAG)
LIB_CFLAGS=\$(INC) \$(CFLAG) \$(LIB_CFLAG)
SHLIB_CFLAGS=\$(INC) \$(CFLAG) \$(LIB_CFLAG) \$(SHLIB_CFLAG)
LIBS_DEP=\$(O_CRYPTO) \$(O_SSL)

#############################################
EOF

$rules=<<"EOF";
all: banner \$(TMP_D) \$(BIN_D) \$(TEST_D) \$(LIB_D) \$(INCO_D) headers lib exe $build_targets

banner:
$banner

\$(TMP_D):
	\$(MKDIR) \"\$(TMP_D)\"
# NB: uncomment out these lines if BIN_D, TEST_D and LIB_D are different
#\$(BIN_D):
#	\$(MKDIR) \$(BIN_D)
#
#\$(TEST_D):
#	\$(MKDIR) \$(TEST_D)

\$(LIB_D):
	\$(MKDIR) \"\$(LIB_D)\"

\$(INCO_D): \$(INC_D)
	\$(MKDIR) \"\$(INCO_D)\"

\$(INC_D):
	\$(MKDIR) \"\$(INC_D)\"

headers: \$(HEADER) \$(EXHEADER)
	@@

lib: \$(LIBS_DEP) \$(E_SHLIB)

exe: \$(T_EXE) \$(BIN_D)$o\$(E_EXE)$exep

install: all
	\$(MKDIR) \"\$(INSTALLTOP)\"
	\$(MKDIR) \"\$(INSTALLTOP)${o}bin\"
	\$(MKDIR) \"\$(INSTALLTOP)${o}include\"
	\$(MKDIR) \"\$(INSTALLTOP)${o}include${o}openssl\"
	\$(MKDIR) \"\$(INSTALLTOP)${o}lib\"
	\$(CP) \"\$(INCO_D)${o}*.\[ch\]\" \"\$(INSTALLTOP)${o}include${o}openssl\"
	\$(CP) \"\$(BIN_D)$o\$(E_EXE)$exep \$(INSTALLTOP)${o}bin\"
	\$(MKDIR) \"\$(OPENSSLDIR)\"
	\$(CP) apps${o}openssl.cnf \"\$(OPENSSLDIR)\"
$extra_install


test: \$(T_EXE)
	cd \$(BIN_D)
	..${o}ms${o}test

clean:
	\$(RM) \$(TMP_D)$o*.*

vclean:
	\$(RM) \$(TMP_D)$o*.*
	\$(RM) \$(OUT_D)$o*.*

EOF
    
my $platform_cpp_symbol = "MK1MF_PLATFORM_$platform";
$platform_cpp_symbol =~ s/-/_/g;
if (open(IN,"crypto/buildinf.h"))
	{
	# Remove entry for this platform in existing file buildinf.h.

	my $old_buildinf_h = "";
	while (<IN>)
		{
		if (/^\#ifdef $platform_cpp_symbol$/)
			{
			while (<IN>) { last if (/^\#endif/); }
			}
		else
			{
			$old_buildinf_h .= $_;
			}
		}
	close(IN);

	open(OUT,">crypto/buildinf.h") || die "Can't open buildinf.h";
	print OUT $old_buildinf_h;
	close(OUT);
	}

open (OUT,">>crypto/buildinf.h") || die "Can't open buildinf.h";
printf OUT <<EOF;
#ifdef $platform_cpp_symbol
  /* auto-generated/updated by util/mk1mf.pl for crypto/cversion.c */
  #define CFLAGS "$cc $cflags"
  #define PLATFORM "$platform"
EOF
printf OUT "  #define DATE \"%s\"\n", scalar gmtime();
printf OUT "#endif\n";
close(OUT);

# Strip of trailing ' '
foreach (keys %lib_obj) { $lib_obj{$_}=&clean_up_ws($lib_obj{$_}); }
$test=&clean_up_ws($test);
$e_exe=&clean_up_ws($e_exe);
$exheader=&clean_up_ws($exheader);
$header=&clean_up_ws($header);

# First we strip the exheaders from the headers list
foreach (split(/\s+/,$exheader)){ $h{$_}=1; }
foreach (split(/\s+/,$header))	{ $h.=$_." " unless $h{$_}; }
chop($h); $header=$h;

$defs.=&do_defs("HEADER",$header,"\$(INCL_D)","");
$rules.=&do_copy_rule("\$(INCL_D)",$header,"");

$defs.=&do_defs("EXHEADER",$exheader,"\$(INCO_D)","");
$rules.=&do_copy_rule("\$(INCO_D)",$exheader,"");

$defs.=&do_defs("T_OBJ",$test,"\$(OBJ_D)",$obj);
$rules.=&do_compile_rule("\$(OBJ_D)",$test,"\$(APP_CFLAGS)");

$defs.=&do_defs("E_OBJ",$e_exe,"\$(OBJ_D)",$obj);
$rules.=&do_compile_rule("\$(OBJ_D)",$e_exe,'-DMONOLITH $(APP_CFLAGS)');

# Special case rule for fips_premain_dso

if ($fips)
	{
	$rules.=&cc_compile_target("\$(OBJ_D)${o}\$(E_PREMAIN_DSO)$obj",
		"\$(FIPS_PREMAIN_SRC)",
		"-DFINGERPRINT_PREMAIN_DSO_LOAD \$(SHLIB_CFLAGS)", "");
	$rules.=&do_link_rule("\$(PREMAIN_DSO_EXE)","\$(OBJ_D)${o}\$(E_PREMAIN_DSO)$obj \$(CRYPTOOBJ) \$(O_FIPSCANISTER)","","\$(EX_LIBS)", 1);
	}

foreach (values %lib_nam)
	{
	$lib_obj=$lib_obj{$_};
	local($slib)=$shlib;

	if (($_ eq "SSL") && $no_ssl2 && $no_ssl3)
		{
		$rules.="\$(O_SSL):\n\n"; 
		next;
		}

	$defs.=&do_defs(${_}."OBJ",$lib_obj,"\$(OBJ_D)",$obj);
	$lib=($slib)?" \$(SHLIB_CFLAGS)".$shlib_ex_cflags{$_}:" \$(LIB_CFLAGS)";
	$rules.=&do_compile_rule("\$(OBJ_D)",$lib_obj{$_},$lib);
	}

# hack to add version info on MSVC
if (($platform eq "VC-WIN32") || ($platform eq "VC-WIN64A")
	|| ($platform eq "VC-WIN64I") || ($platform eq "VC-NT")) {
    $rules.= <<"EOF";
\$(OBJ_D)\\\$(CRYPTO).res: ms\\version32.rc
	\$(RSC) /fo"\$(OBJ_D)\\\$(CRYPTO).res" /d CRYPTO ms\\version32.rc

\$(OBJ_D)\\\$(SSL).res: ms\\version32.rc
	\$(RSC) /fo"\$(OBJ_D)\\\$(SSL).res" /d SSL ms\\version32.rc

EOF
}

$defs.=&do_defs("T_EXE",$test,"\$(TEST_D)",$exep);
foreach (split(/\s+/,$test))
	{
	$t=&bname($_);
	$tt="\$(OBJ_D)${o}$t${obj}";
	$rules.=&do_link_rule("\$(TEST_D)$o$t$exep",$tt,"\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)");
	}

$defs.=&do_defs("E_SHLIB",$engines . $otherlibs,"\$(ENG_D)",$shlibp);

foreach (split(/\s+/,$engines))
	{
	$rules.=&do_compile_rule("\$(OBJ_D)","engines${o}e_$_",$lib);
	$rules.= &do_lib_rule("\$(OBJ_D)${o}e_${_}.obj","\$(ENG_D)$o$_$shlibp","",$shlib,"");
	}



$rules.= &do_lib_rule("\$(SSLOBJ)","\$(O_SSL)",$ssl,$shlib,"\$(SO_SSL)");

if ($fips)
	{
	if ($shlib)
		{
		$rules.= &do_lib_rule("\$(CRYPTOOBJ) \$(O_FIPSCANISTER)",
				"\$(O_CRYPTO)", "$crypto",
				$shlib, "\$(SO_CRYPTO)", "\$(BASEADDR)");
		}
	else
		{
		$rules.= &do_lib_rule("\$(CRYPTOOBJ)",
			"\$(O_CRYPTO)",$crypto,$shlib,"\$(SO_CRYPTO)", "");
		$rules.= &do_lib_rule("\$(CRYPTOOBJ) \$(O_FIPSCANISTER)",
			"\$(LIB_D)$o$crypto_compat",$crypto,$shlib,"\$(SO_CRYPTO)", "");
		}
	}
	else
	{
	$rules.= &do_lib_rule("\$(CRYPTOOBJ)","\$(O_CRYPTO)",$crypto,$shlib,
							"\$(SO_CRYPTO)");
	}

foreach (split(" ",$otherlibs))
	{
	my $uc = $_;
	$uc =~ tr /a-z/A-Z/;	
	$rules.= &do_lib_rule("\$(${uc}OBJ)","\$(ENG_D)$o$_$shlibp", "", $shlib, "");

	}

$rules.=&do_link_rule("\$(BIN_D)$o\$(E_EXE)$exep","\$(E_OBJ)","\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)", ($fips && !$shlib) ? 2 : 0);

print $defs;

if ($platform eq "linux-elf") {
    print <<"EOF";
# Generate perlasm output files
%.cpp:
	(cd \$(\@@D)/..; PERL=perl make -f Makefile asm/\$(\@@F))
EOF
}
print "###################################################################\n";
print $rules;

###############################################
# strip off any trailing .[och] and append the relative directory
# also remembering to do nothing if we are in one of the dropped
# directories
sub var_add
	{
	local($dir,$val,$keepext)=@@_;
	local(@@a,$_,$ret);

	return("") if $no_engine && $dir =~ /\/engine/;
	return("") if $no_hw   && $dir =~ /\/hw/;
	return("") if $no_idea && $dir =~ /\/idea/;
	return("") if $no_aes  && $dir =~ /\/aes/;
	return("") if $no_camellia  && $dir =~ /\/camellia/;
	return("") if $no_seed && $dir =~ /\/seed/;
	return("") if $no_rc2  && $dir =~ /\/rc2/;
	return("") if $no_rc4  && $dir =~ /\/rc4/;
	return("") if $no_rc5  && $dir =~ /\/rc5/;
	return("") if $no_rsa  && $dir =~ /\/rsa/;
	return("") if $no_rsa  && $dir =~ /^rsaref/;
	return("") if $no_dsa  && $dir =~ /\/dsa/;
	return("") if $no_dh   && $dir =~ /\/dh/;
	return("") if $no_ec   && $dir =~ /\/ec/;
	return("") if $no_cms  && $dir =~ /\/cms/;
	return("") if $no_jpake  && $dir =~ /\/jpake/;
	if ($no_des && $dir =~ /\/des/)
		{
		if ($val =~ /read_pwd/)
			{ return("$dir/read_pwd "); }
		else
			{ return(""); }
		}
	return("") if $no_mdc2 && $dir =~ /\/mdc2/;
	return("") if $no_sock && $dir =~ /\/proxy/;
	return("") if $no_bf   && $dir =~ /\/bf/;
	return("") if $no_cast && $dir =~ /\/cast/;
	return("") if $no_whirlpool && $dir =~ /\/whrlpool/;

	$val =~ s/^\s*(.*)\s*$/$1/;
	@@a=split(/\s+/,$val);
	grep(s/\.[och]$//,@@a) unless $keepext;

	@@a=grep(!/^e_.*_3d$/,@@a) if $no_des;
	@@a=grep(!/^e_.*_d$/,@@a) if $no_des;
	@@a=grep(!/^e_.*_ae$/,@@a) if $no_idea;
	@@a=grep(!/^e_.*_i$/,@@a) if $no_aes;
	@@a=grep(!/^e_.*_r2$/,@@a) if $no_rc2;
	@@a=grep(!/^e_.*_r5$/,@@a) if $no_rc5;
	@@a=grep(!/^e_.*_bf$/,@@a) if $no_bf;
	@@a=grep(!/^e_.*_c$/,@@a) if $no_cast;
	@@a=grep(!/^e_rc4$/,@@a) if $no_rc4;
	@@a=grep(!/^e_camellia$/,@@a) if $no_camellia;
	@@a=grep(!/^e_seed$/,@@a) if $no_seed;

	#@@a=grep(!/(^s2_)|(^s23_)/,@@a) if $no_ssl2;
	#@@a=grep(!/(^s3_)|(^s23_)/,@@a) if $no_ssl3;

	@@a=grep(!/(_sock$)|(_acpt$)|(_conn$)|(^pxy_)/,@@a) if $no_sock;

	@@a=grep(!/(^md2)|(_md2$)/,@@a) if $no_md2;
	@@a=grep(!/(^md4)|(_md4$)/,@@a) if $no_md4;
	@@a=grep(!/(^md5)|(_md5$)/,@@a) if $no_md5;
	@@a=grep(!/(rmd)|(ripemd)/,@@a) if $no_ripemd;

	@@a=grep(!/(^d2i_r_)|(^i2d_r_)/,@@a) if $no_rsa;
	@@a=grep(!/(^p_open$)|(^p_seal$)/,@@a) if $no_rsa;
	@@a=grep(!/(^pem_seal$)/,@@a) if $no_rsa;

	@@a=grep(!/(m_dss$)|(m_dss1$)/,@@a) if $no_dsa;
	@@a=grep(!/(^d2i_s_)|(^i2d_s_)|(_dsap$)/,@@a) if $no_dsa;

	@@a=grep(!/^n_pkey$/,@@a) if $no_rsa || $no_rc4;

	@@a=grep(!/_dhp$/,@@a) if $no_dh;

	@@a=grep(!/(^sha[^1])|(_sha$)|(m_dss$)/,@@a) if $no_sha;
	@@a=grep(!/(^sha1)|(_sha1$)|(m_dss1$)/,@@a) if $no_sha1;
	@@a=grep(!/_mdc2$/,@@a) if $no_mdc2;

	@@a=grep(!/(srp)/,@@a) if $no_srp;

	@@a=grep(!/^engine$/,@@a) if $no_engine;
	@@a=grep(!/^hw$/,@@a) if $no_hw;
	@@a=grep(!/(^rsa$)|(^genrsa$)/,@@a) if $no_rsa;
	@@a=grep(!/(^dsa$)|(^gendsa$)|(^dsaparam$)/,@@a) if $no_dsa;
	@@a=grep(!/^gendsa$/,@@a) if $no_sha1;
	@@a=grep(!/(^dh$)|(^gendh$)/,@@a) if $no_dh;

	@@a=grep(!/(^dh)|(_sha1$)|(m_dss1$)/,@@a) if $no_sha1;

	grep($_="$dir/$_",@@a);
	@@a=grep(!/(^|\/)s_/,@@a) if $no_sock;
	@@a=grep(!/(^|\/)bio_sock/,@@a) if $no_sock;
	$ret=join(' ',@@a)." ";
	return($ret);
	}

# change things so that each 'token' is only separated by one space
sub clean_up_ws
	{
	local($w)=@@_;

	$w =~ s/^\s*(.*)\s*$/$1/;
	$w =~ s/\s+/ /g;
	return($w);
	}

sub do_defs
	{
	local($var,$files,$location,$postfix)=@@_;
	local($_,$ret,$pf);
	local(*OUT,$tmp,$t);

	$files =~ s/\//$o/g if $o ne '/';
	$ret="$var="; 
	$n=1;
	$Vars{$var}.="";
	foreach (split(/ /,$files))
		{
		$orig=$_;
		$_=&bname($_) unless /^\$/;
		if ($n++ == 2)
			{
			$n=0;
			$ret.="\\\n\t";
			}
		if (($_ =~ /bss_file/) && ($postfix eq ".h"))
			{ $pf=".c"; }
		else	{ $pf=$postfix; }
		if ($_ =~ /BN_ASM/)	{ $t="$_ "; }
		elsif ($_ =~ /BNCO_ASM/){ $t="$_ "; }
		elsif ($_ =~ /AES_ASM/){ $t="$_ "; }
		elsif ($_ =~ /DES_ENC/)	{ $t="$_ "; }
		elsif ($_ =~ /BF_ENC/)	{ $t="$_ "; }
		elsif ($_ =~ /CAST_ENC/){ $t="$_ "; }
		elsif ($_ =~ /RC4_ENC/)	{ $t="$_ "; }
		elsif ($_ =~ /RC5_ENC/)	{ $t="$_ "; }
		elsif ($_ =~ /MD5_ASM/)	{ $t="$_ "; }
		elsif ($_ =~ /SHA1_ASM/){ $t="$_ "; }
		elsif ($_ =~ /RMD160_ASM/){ $t="$_ "; }
		elsif ($_ =~ /WHIRLPOOL_ASM/){ $t="$_ "; }
		elsif ($_ =~ /CPUID_ASM/){ $t="$_ "; }
		else	{ $t="$location${o}$_$pf "; }

		$Vars{$var}.="$t ";
		$ret.=$t;
		}
	# hack to add version info on MSVC
	if ($shlib && (($platform eq "VC-WIN32") || ($platfrom eq "VC-WIN64I") || ($platform eq "VC-WIN64A") || ($platform eq "VC-NT")))
		{
		if ($var eq "CRYPTOOBJ")
			{ $ret.="\$(OBJ_D)\\\$(CRYPTO).res "; }
		elsif ($var eq "SSLOBJ")
			{ $ret.="\$(OBJ_D)\\\$(SSL).res "; }
		}
	chomp($ret);
	$ret.="\n\n";
	return($ret);
	}

# return the name with the leading path removed
sub bname
	{
	local($ret)=@@_;
	$ret =~ s/^.*[\\\/]([^\\\/]+)$/$1/;
	return($ret);
	}

# return the leading path
sub dname
	{
	my $ret=shift;
	$ret =~ s/(^.*)[\\\/][^\\\/]+$/$1/;
	return($ret);
	}

##############################################################
# do a rule for each file that says 'compile' to new direcory
# compile the files in '$files' into $to
sub do_compile_rule
	{
	local($to,$files,$ex)=@@_;
	local($ret,$_,$n,$d,$s);

	$files =~ s/\//$o/g if $o ne '/';
	foreach (split(/\s+/,$files))
		{
		$n=&bname($_);
		$d=&dname($_);
		if (-f "${_}.c")
			{
			$ret.=&cc_compile_target("$to${o}$n$obj","${_}.c",$ex)
			}
		elsif (-f ($s="${d}${o}asm${o}${n}.pl") or
		       ($s=~s/sha256/sha512/ and -f $s) or
		       -f ($s="${d}${o}${n}.pl"))
			{
			$ret.=&perlasm_compile_target("$to${o}$n$obj",$s,$n);
			}
		elsif (-f ($s="${d}${o}asm${o}${n}.S") or
		       -f ($s="${d}${o}${n}.S"))
			{
			$ret.=&Sasm_compile_target("$to${o}$n$obj",$s,$n);
			}
		else	{ die "no rule for $_"; }
		}
	return($ret);
	}

##############################################################
# do a rule for each file that says 'compile' to new direcory
sub perlasm_compile_target
	{
	my($target,$source,$bname)=@@_;
	my($ret);

	$bname =~ s/(.*)\.[^\.]$/$1/;
	$ret ="\$(TMP_D)$o$bname.asm: $source\n";
	$ret.="\t\$(PERL) $source $asmtype \$(CFLAG) >\$\@@\n\n";
	$ret.="$target: \$(TMP_D)$o$bname.asm\n";
	$ret.="\t\$(ASM) $afile\$\@@ \$(TMP_D)$o$bname.asm\n\n";
	return($ret);
	}

sub Sasm_compile_target
	{
	my($target,$source,$bname)=@@_;
	my($ret);

	$bname =~ s/(.*)\.[^\.]$/$1/;
	$ret ="\$(TMP_D)$o$bname.asm: $source\n";
	$ret.="\t\$(CC) -E \$(CFLAG) $source >\$\@@\n\n";
	$ret.="$target: \$(TMP_D)$o$bname.asm\n";
	$ret.="\t\$(ASM) $afile\$\@@ \$(TMP_D)$o$bname.asm\n\n";
	return($ret);
	}

sub cc_compile_target
	{
	local($target,$source,$ex_flags, $srcd)=@@_;
	local($ret);
	
	$ex_flags.=" -DMK1MF_BUILD -D$platform_cpp_symbol" if ($source =~ /cversion/);
	$target =~ s/\//$o/g if $o ne "/";
	$source =~ s/\//$o/g if $o ne "/";
	$srcd = "\$(SRC_D)$o" unless defined $srcd;
	$ret ="$target: $srcd$source\n\t";
	$ret.="\$(CC) ${ofile}$target $ex_flags -c $srcd$source\n\n";
	return($ret);
	}

##############################################################
sub do_asm_rule
	{
	local($target,$src)=@@_;
	local($ret,@@s,@@t,$i);

	$target =~ s/\//$o/g if $o ne "/";
	$src =~ s/\//$o/g if $o ne "/";

	@@t=split(/\s+/,$target);
	@@s=split(/\s+/,$src);


	for ($i=0; $i<=$#s; $i++)
		{
		my $objfile = $t[$i];
		my $srcfile = $s[$i];

		if ($perl_asm == 1)
			{
			my $plasm = $objfile;
			$plasm =~ s/${obj}/.pl/;
			$ret.="$srcfile: $plasm\n";
			$ret.="\t\$(PERL) $plasm $asmtype \$(CFLAG) >$srcfile\n\n";
			}

		$ret.="$objfile: $srcfile\n";
		$ret.="\t\$(ASM) $afile$objfile \$(SRC_D)$o$srcfile\n\n";
		}
	return($ret);
	}

sub do_shlib_rule
	{
	local($n,$def)=@@_;
	local($ret,$nn);
	local($t);

	($nn=$n) =~ tr/a-z/A-Z/;
	$ret.="$n.dll: \$(${nn}OBJ)\n";
	if ($vc && $w32)
		{
		$ret.="\t\$(MKSHLIB) $efile$n.dll $def @@<<\n  \$(${nn}OBJ_F)\n<<\n";
		}
	$ret.="\n";
	return($ret);
	}

# do a rule for each file that says 'copy' to new direcory on change
sub do_copy_rule
	{
	local($to,$files,$p)=@@_;
	local($ret,$_,$n,$pp);
	
	$files =~ s/\//$o/g if $o ne '/';
	foreach (split(/\s+/,$files))
		{
		$n=&bname($_);
		if ($n =~ /bss_file/)
			{ $pp=".c"; }
		else	{ $pp=$p; }
		$ret.="$to${o}$n$pp: \$(SRC_D)$o$_$pp\n\t\$(CP) \"\$(SRC_D)$o$_$pp\" \"$to${o}$n$pp\"\n\n";
		}
	return($ret);
	}

sub read_options
	{
	# Many options are handled in a similar way. In particular
	# no-xxx sets zero or more scalars to 1.
	# Process these using a hash containing the option name and
	# reference to the scalars to set.

	my %valid_options = (
		"no-rc2" => \$no_rc2,
		"no-rc4" => \$no_rc4,
		"no-rc5" => \$no_rc5,
		"no-idea" => \$no_idea,
		"no-aes" => \$no_aes,
		"no-camellia" => \$no_camellia,
		"no-seed" => \$no_seed,
		"no-des" => \$no_des,
		"no-bf" => \$no_bf,
		"no-cast" => \$no_cast,
		"no-md2" => \$no_md2,
		"no-md4" => \$no_md4,
		"no-md5" => \$no_md5,
		"no-sha" => \$no_sha,
		"no-sha1" => \$no_sha1,
		"no-ripemd" => \$no_ripemd,
		"no-mdc2" => \$no_mdc2,
		"no-whirlpool" => \$no_whirlpool,
		"no-patents" => 
			[\$no_rc2, \$no_rc4, \$no_rc5, \$no_idea, \$no_rsa],
		"no-rsa" => \$no_rsa,
		"no-dsa" => \$no_dsa,
		"no-dh" => \$no_dh,
		"no-hmac" => \$no_hmac,
		"no-asm" => \$no_asm,
		"nasm" => \$nasm,
		"nw-nasm" => \$nw_nasm,
		"nw-mwasm" => \$nw_mwasm,
		"gaswin" => \$gaswin,
		"no-ssl2" => \$no_ssl2,
		"no-ssl3" => \$no_ssl3,
		"no-tlsext" => \$no_tlsext,
		"no-srp" => \$no_srp,
		"no-cms" => \$no_cms,
		"no-ec2m" => \$no_ec2m,
		"no-jpake" => \$no_jpake,
		"no-ec_nistp_64_gcc_128" => 0,
		"no-err" => \$no_err,
		"no-sock" => \$no_sock,
		"no-krb5" => \$no_krb5,
		"no-ec" => \$no_ec,
		"no-ecdsa" => \$no_ecdsa,
		"no-ecdh" => \$no_ecdh,
		"no-gost" => \$no_gost,
		"no-engine" => \$no_engine,
		"no-hw" => \$no_hw,
		"no-rsax" => 0,
		"just-ssl" =>
			[\$no_rc2, \$no_idea, \$no_des, \$no_bf, \$no_cast,
			  \$no_md2, \$no_sha, \$no_mdc2, \$no_dsa, \$no_dh,
			  \$no_ssl2, \$no_err, \$no_ripemd, \$no_rc5,
			  \$no_aes, \$no_camellia, \$no_seed, \$no_srp],
		"rsaref" => 0,
		"gcc" => \$gcc,
		"debug" => \$debug,
		"profile" => \$profile,
		"shlib" => \$shlib,
		"dll" => \$shlib,
		"shared" => 0,
		"no-sctp" => 0,
		"no-gmp" => 0,
		"no-rfc3779" => 0,
		"no-montasm" => 0,
		"no-shared" => 0,
		"no-store" => 0,
		"no-zlib" => 0,
		"no-zlib-dynamic" => 0,
		"fips" => \$fips
		);

	if (exists $valid_options{$_})
		{
		my $r = $valid_options{$_};
		if ( ref $r eq "SCALAR")
			{ $$r = 1;}
		elsif ( ref $r eq "ARRAY")
			{
			my $r2;
			foreach $r2 (@@$r)
				{
				$$r2 = 1;
				}
			}
		}
	elsif (/^no-comp$/) { $xcflags = "-DOPENSSL_NO_COMP $xcflags"; }
	elsif (/^enable-zlib$/) { $zlib_opt = 1 if $zlib_opt == 0 }
	elsif (/^enable-zlib-dynamic$/)
		{
		$zlib_opt = 2;
		}
	elsif (/^no-static-engine/)
		{
		$no_static_engine = 1;
		}
	elsif (/^enable-static-engine/)
		{
		$no_static_engine = 0;
		}
	# There are also enable-xxx options which correspond to
	# the no-xxx. Since the scalars are enabled by default
	# these can be ignored.
	elsif (/^enable-/)
		{
		my $t = $_;
		$t =~ s/^enable/no/;
		if (exists $valid_options{$t})
			{return 1;}
		return 0;
		}
	# experimental-xxx is mostly like enable-xxx, but opensslconf.v
	# will still set OPENSSL_NO_xxx unless we set OPENSSL_EXPERIMENTAL_xxx.
	# (No need to fail if we don't know the algorithm -- this is for adventurous users only.)
	elsif (/^experimental-/)
		{
		my $algo, $ALGO;
		($algo = $_) =~ s/^experimental-//;
		($ALGO = $algo) =~ tr/[a-z]/[A-Z]/;

		$xcflags="-DOPENSSL_EXPERIMENTAL_$ALGO $xcflags";
		
		}
	elsif (/^--with-krb5-flavor=(.*)$/)
		{
		my $krb5_flavor = $1;
		if ($krb5_flavor =~ /^force-[Hh]eimdal$/)
			{
			$xcflags="-DKRB5_HEIMDAL $xcflags";
			}
		elsif ($krb5_flavor =~ /^MIT/i)
			{
			$xcflags="-DKRB5_MIT $xcflags";
		 	if ($krb5_flavor =~ /^MIT[._-]*1[._-]*[01]/i)
				{
				$xcflags="-DKRB5_MIT_OLD11 $xcflags"
				}
			}
		}
	elsif (/^([^=]*)=(.*)$/){ $VARS{$1}=$2; }
	elsif (/^-[lL].*$/)	{ $l_flags.="$_ "; }
	elsif ((!/^-help/) && (!/^-h/) && (!/^-\?/) && /^-.*$/)
		{ $c_flags.="$_ "; }
	else { return(0); }
	return(1);
	}
@


1.18
log
@Remove the GOST engine: It is not compiled or used and depends on the
"dynamic engine" feature that is not enabled in our build.  People who
need it can still pull it out of the Attic; if it is to have a Russian
engine just because it's a Russian engine.

OK deraadt@@ beck@@
@
text
@@


1.17
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a784 1
	return("") if $no_gost   && $dir =~ /\/ccgost/;
@


1.16
log
@resolve conflicts
@
text
@d1225 1
a1225 1
	elsif (/^([^=]*)=(.*)$/ && !/^-D/){ $VARS{$1}=$2; }
@


1.15
log
@openssl-1.0.0e: resolve conflicts
@
text
@d21 2
d45 3
a47 1
	CMLL_ENC       => \$mf_cm_asm
d111 1
d236 2
d271 1
d281 1
d283 1
d417 5
d483 12
d527 1
a527 1
L_LIBS= \$(L_SSL) \$(L_CRYPTO)
d543 1
a543 1
all: banner \$(TMP_D) \$(BIN_D) \$(TEST_D) \$(LIB_D) \$(INCO_D) headers lib exe
d659 10
d717 22
a738 1
$rules.= &do_lib_rule("\$(CRYPTOOBJ)","\$(O_CRYPTO)",$crypto,$shlib,"\$(SO_CRYPTO)");
d748 1
a748 1
$rules.=&do_link_rule("\$(BIN_D)$o\$(E_EXE)$exep","\$(E_OBJ)","\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)");
d842 2
d1002 1
a1002 1
	local($target,$source,$ex_flags)=@@_;
d1008 3
a1010 2
	$ret ="$target: \$(SRC_D)$o$source\n\t";
	$ret.="\$(CC) ${ofile}$target $ex_flags -c \$(SRC_D)$o$source\n\n";
d1120 1
d1122 1
d1124 1
d1134 1
d1139 1
a1139 1
			  \$no_aes, \$no_camellia, \$no_seed],
d1147 1
d1155 1
@


1.14
log
@resolve conflicts, fix local changes
@
text
@d16 1
d270 1
d361 6
d669 1
a669 1
$defs.=&do_defs("E_SHLIB",$engines,"\$(ENG_D)",$shlibp);
d682 8
d727 1
d1067 1
@


1.13
log
@resolve conflicts
@
text
@d9 1
d14 1
a14 1
my $no_static_engine = 0;
d18 1
d20 1
a20 4
local $fips_canister_path = "";
my $fips_premain_dso_exe_path = "";
my $fips_premain_c_path = "";
my $fips_sha1_exe_path = "";
d22 22
a43 2
local $fipscanisterbuild = 0;
local $fipsdso = 0;
a44 4
my $fipslibdir = "";
my $baseaddr = "";

my $ex_l_libs = "";
d48 6
a53 3
    $ssl_version=$1 if (/^VERSION=(.*)$/);
    $OPTIONS=$1 if (/^OPTIONS=(.*)$/);
    $INSTALLTOP=$1 if (/^INSTALLTOP=(.*$)/);
d57 2
d81 1
d168 6
d258 1
a263 2
$cflags.=" -DOPENSSL_NO_JPAKE" if $no_jpake;
$cflags.=" -DOPENSSL_NO_CAPIENG" if $no_capieng;
d271 1
a271 1
$cflags.=" -DOPENSSL_FIPS"    if $fips;
d293 1
d295 1
a295 2
		  "CRYPTO" => " -DOPENSSL_BUILD_SHLIBCRYPTO",
		  "FIPS" => " -DOPENSSL_BUILD_SHLIBCRYPTO");
d309 1
d324 5
a328 15
 			if ($fips && $dir =~ /^fips/)
 				{
 				$uc = "FIPS";
 				}
 			else
 				{
 				$uc=$lib;
 				$uc =~ s/^lib(.*)\.a/$1/;
 				$uc =~ tr/a-z/A-Z/;
				}
			if (($uc ne "FIPS") || $fipscanisterbuild)
				{
				$lib_nam{$uc}=$uc;
				$lib_obj{$uc}.=$libobj." ";
				}
a370 15
	if ($key eq "FIPS_EX_OBJ")
		{ 
		$fips_ex_obj=&var_add("crypto",$val,0);
		}

	if ($key eq "FIPSLIBDIR")
		{
		$fipslibdir=$val;
		$fipslibdir =~ s/\/$//;
		$fipslibdir =~ s/\//$o/g;
		}

	if ($key eq "BASEADDR")
		{ $baseaddr=$val;}

a375 104
if ($fips)
	{
	 
	foreach (split " ", $fips_ex_obj)
		{
		$fips_exclude_obj{$1} = 1 if (/\/([^\/]*)$/);
		}

	$fips_exclude_obj{"cpu_win32"} = 1;
	$fips_exclude_obj{"bn_asm"} = 1;
	$fips_exclude_obj{"des_enc"} = 1;
	$fips_exclude_obj{"fcrypt_b"} = 1;
	$fips_exclude_obj{"aes_core"} = 1;
	$fips_exclude_obj{"aes_cbc"} = 1;

	my @@ltmp = split " ", $lib_obj{"CRYPTO"};


	$lib_obj{"CRYPTO"} = "";

	foreach(@@ltmp)
		{
		if (/\/([^\/]*)$/ && exists $fips_exclude_obj{$1})
			{
			if ($fipscanisterbuild)
				{
				$lib_obj{"FIPS"} .= "$_ ";
				}
			}
		else
			{
			$lib_obj{"CRYPTO"} .= "$_ ";
			}
		}

	}

if ($fipscanisterbuild)
	{
	$fips_canister_path = "\$(LIB_D)${o}fipscanister.lib" if $fips_canister_path eq "";
	$fips_premain_c_path = "\$(LIB_D)${o}fips_premain.c";
	}
else
	{
	if ($fips_canister_path eq "")
		{
		$fips_canister_path = "\$(FIPSLIB_D)${o}fipscanister.lib";
		}

	if ($fips_premain_c_path eq "")
		{
		$fips_premain_c_path = "\$(FIPSLIB_D)${o}fips_premain.c";
		}
	}

if ($fips)
	{
	if ($fips_sha1_exe_path eq "")
		{
		$fips_sha1_exe_path =
			"\$(BIN_D)${o}fips_standalone_sha1$exep";
		}
	}
	else
	{
	$fips_sha1_exe_path = "";
	}

if ($fips_premain_dso_exe_path eq "")
	{
	$fips_premain_dso_exe_path = "\$(BIN_D)${o}fips_premain_dso$exep";
	}

#	$ex_build_targets .= "\$(BIN_D)${o}\$(E_PREMAIN_DSO)$exep" if ($fips);

#$ex_l_libs .= " \$(L_FIPS)" if $fipsdso;

if ($fips)
	{
	if (!$shlib)
		{
		$ex_build_targets .= " \$(LIB_D)$o$crypto_compat \$(PREMAIN_DSO_EXE)";
		$ex_l_libs .= " \$(O_FIPSCANISTER)";
		$ex_libs_dep .= " \$(O_FIPSCANISTER)" if $fipscanisterbuild;
		}
	if ($fipscanisterbuild)
		{
		$fipslibdir = "\$(LIB_D)";
		}
	else
		{
		if ($fipslibdir eq "")
			{
			open (IN, "util/fipslib_path.txt") || fipslib_error();
			$fipslibdir = <IN>;
			chomp $fipslibdir;
			close IN;
			}
		fips_check_files($fipslibdir,
				"fipscanister.lib", "fipscanister.lib.sha1",
				"fips_premain.c", "fips_premain.c.sha1");
		}
	}

d421 1
a441 26
FIPSLINK=\$(PERL) util${o}fipslink.pl

AES_ASM_OBJ=$aes_asm_obj
AES_ASM_SRC=$aes_asm_src
BN_ASM_OBJ=$bn_asm_obj
BN_ASM_SRC=$bn_asm_src
BNCO_ASM_OBJ=$bnco_asm_obj
BNCO_ASM_SRC=$bnco_asm_src
DES_ENC_OBJ=$des_enc_obj
DES_ENC_SRC=$des_enc_src
BF_ENC_OBJ=$bf_enc_obj
BF_ENC_SRC=$bf_enc_src
CAST_ENC_OBJ=$cast_enc_obj
CAST_ENC_SRC=$cast_enc_src
RC4_ENC_OBJ=$rc4_enc_obj
RC4_ENC_SRC=$rc4_enc_src
RC5_ENC_OBJ=$rc5_enc_obj
RC5_ENC_SRC=$rc5_enc_src
MD5_ASM_OBJ=$md5_asm_obj
MD5_ASM_SRC=$md5_asm_src
SHA1_ASM_OBJ=$sha1_asm_obj
SHA1_ASM_SRC=$sha1_asm_src
RMD160_ASM_OBJ=$rmd160_asm_obj
RMD160_ASM_SRC=$rmd160_asm_src
CPUID_ASM_OBJ=$cpuid_asm_obj
CPUID_ASM_SRC=$cpuid_asm_src
a459 11
# FIPS validated module and support file locations

E_PREMAIN_DSO=fips_premain_dso

FIPSLIB_D=$fipslibdir
BASEADDR=$baseaddr
FIPS_PREMAIN_SRC=$fips_premain_c_path
O_FIPSCANISTER=$fips_canister_path
FIPS_SHA1_EXE=$fips_sha1_exe_path
PREMAIN_DSO_EXE=$fips_premain_dso_exe_path

a466 1
LIBFIPS=libosslfips
a486 1
O_FIPS=    \$(LIB_D)$o$plib\$(LIBFIPS)$shlibp
a490 1
L_FIPS=    \$(LIB_D)$o$plib\$(LIBFIPS)$libp
d492 1
a492 1
L_LIBS= \$(L_SSL) \$(L_CRYPTO) $ex_l_libs
d502 1
a502 1
LIBS_DEP=\$(O_CRYPTO) \$(O_SSL) $ex_libs_dep
d508 1
a508 1
all: banner \$(TMP_D) \$(BIN_D) \$(TEST_D) \$(LIB_D) \$(INCO_D) headers \$(FIPS_SHA1_EXE) lib exe $ex_build_targets
d545 3
a547 2
	\$(CP) \"\$(BIN_D)$o\$(E_EXE)$exep\" \"\$(INSTALLTOP)${o}bin\"
	\$(CP) \"apps${o}openssl.cnf\" \"\$(INSTALLTOP)\"
a623 20
# Special case rules for fips_start and fips_end fips_premain_dso

if ($fips)
	{
	if ($fipscanisterbuild)
		{
		$rules.=&cc_compile_target("\$(OBJ_D)${o}fips_start$obj",
			"fips${o}fips_canister.c",
			"-DFIPS_START \$(SHLIB_CFLAGS)");
		$rules.=&cc_compile_target("\$(OBJ_D)${o}fips_end$obj",
			"fips${o}fips_canister.c", "\$(SHLIB_CFLAGS)");
		}
	$rules.=&cc_compile_target("\$(OBJ_D)${o}fips_standalone_sha1$obj",
		"fips${o}sha${o}fips_standalone_sha1.c",
		"\$(SHLIB_CFLAGS)");
	$rules.=&cc_compile_target("\$(OBJ_D)${o}\$(E_PREMAIN_DSO)$obj",
		"fips${o}fips_premain.c",
		"-DFINGERPRINT_PREMAIN_DSO_LOAD \$(SHLIB_CFLAGS)");
	}

a634 65
	if ((!$fips && ($_ eq "CRYPTO")) || ($fips && ($_ eq "FIPS")))
		{
		if ($cpuid_asm_obj ne "")
			{
			$lib_obj =~ s/(\S*\/cryptlib\S*)/$1 \$(CPUID_ASM_OBJ)/;
			$rules.=&do_asm_rule($cpuid_asm_obj,$cpuid_asm_src);
			}
		if ($aes_asm_obj ne "")
			{
			$lib_obj =~ s/\s(\S*\/aes_core\S*)/ \$(AES_ASM_OBJ)/;
			$lib_obj =~ s/\s\S*\/aes_cbc\S*//;
			$rules.=&do_asm_rule($aes_asm_obj,$aes_asm_src);
			}
		if ($sha1_asm_obj ne "")
			{
			$lib_obj =~ s/\s(\S*\/sha1dgst\S*)/ $1 \$(SHA1_ASM_OBJ)/;
			$rules.=&do_asm_rule($sha1_asm_obj,$sha1_asm_src);
			}
		if ($bn_asm_obj ne "")
			{
			$lib_obj =~ s/\s\S*\/bn_asm\S*/ \$(BN_ASM_OBJ)/;
			$rules.=&do_asm_rule($bn_asm_obj,$bn_asm_src);
			}
		if ($bnco_asm_obj ne "")
			{
			$lib_obj .= "\$(BNCO_ASM_OBJ)";
			$rules.=&do_asm_rule($bnco_asm_obj,$bnco_asm_src);
			}
		if ($des_enc_obj ne "")
			{
			$lib_obj =~ s/\s\S*des_enc\S*/ \$(DES_ENC_OBJ)/;
			$lib_obj =~ s/\s\S*\/fcrypt_b\S*\s*/ /;
			$rules.=&do_asm_rule($des_enc_obj,$des_enc_src);
			}
		}
	if (($bf_enc_obj ne "") && ($_ eq "CRYPTO"))
		{
		$lib_obj =~ s/\s\S*\/bf_enc\S*/ \$(BF_ENC_OBJ)/;
		$rules.=&do_asm_rule($bf_enc_obj,$bf_enc_src);
		}
	if (($cast_enc_obj ne "") && ($_ eq "CRYPTO"))
		{
		$lib_obj =~ s/(\s\S*\/c_enc\S*)/ \$(CAST_ENC_OBJ)/;
		$rules.=&do_asm_rule($cast_enc_obj,$cast_enc_src);
		}
	if (($rc4_enc_obj ne "") && ($_ eq "CRYPTO"))
		{
		$lib_obj =~ s/\s\S*\/rc4_enc\S*/ \$(RC4_ENC_OBJ)/;
		$rules.=&do_asm_rule($rc4_enc_obj,$rc4_enc_src);
		}
	if (($rc5_enc_obj ne "") && ($_ eq "CRYPTO"))
		{
		$lib_obj =~ s/\s\S*\/rc5_enc\S*/ \$(RC5_ENC_OBJ)/;
		$rules.=&do_asm_rule($rc5_enc_obj,$rc5_enc_src);
		}
	if (($md5_asm_obj ne "") && ($_ eq "CRYPTO"))
		{
		$lib_obj =~ s/\s(\S*\/md5_dgst\S*)/ $1 \$(MD5_ASM_OBJ)/;
		$rules.=&do_asm_rule($md5_asm_obj,$md5_asm_src);
		}
	if (($rmd160_asm_obj ne "") && ($_ eq "CRYPTO"))
		{
		$lib_obj =~ s/\s(\S*\/rmd_dgst\S*)/ $1 \$(RMD160_ASM_OBJ)/;
		$rules.=&do_asm_rule($rmd160_asm_obj,$rmd160_asm_src);
		}
d641 2
a642 1
if (($platform eq "VC-WIN32") || ($platform eq "VC-NT")) {
a649 3
\$(OBJ_D)\\\$(LIBFIPS).res: ms\\version32.rc
	\$(RSC) /fo"\$(OBJ_D)\\\$(LIBFIPS).res" /d FIPS ms\\version32.rc

a655 1
	my $t_libs;
a656 24
	my $ltype;
	# Check to see if test program is FIPS
	if ($fips && /fips/)
		{
		# If fipsdso link to libosslfips.dll 
		# otherwise perform static link to 
		# $(O_FIPSCANISTER)
		if ($fipsdso)
			{
			$t_libs = "\$(L_FIPS)";
			$ltype = 0;
			}
		else
			{
			$t_libs = "\$(O_FIPSCANISTER)";
			$ltype = 2;
			}
		}
	else
		{
		$t_libs = "\$(L_LIBS)";
		$ltype = 0;
		}

d658 1
a658 1
	$rules.=&do_link_rule("\$(TEST_D)$o$t$exep",$tt,"\$(LIBS_DEP)","$t_libs \$(EX_LIBS)", $ltype);
d672 1
d674 1
a674 62
if ($fips)
	{
	if ($shlib)
		{
		if ($fipsdso)
			{
			$rules.= &do_lib_rule("\$(CRYPTOOBJ)",
					"\$(O_CRYPTO)", "$crypto",
					$shlib, "", "");
			$rules.= &do_lib_rule(
				"\$(O_FIPSCANISTER)",
				"\$(O_FIPS)", "\$(LIBFIPS)",
				$shlib, "\$(SO_CRYPTO)", "\$(BASEADDR)");
			$rules.= &do_sdef_rule();
			}
		else
			{
			$rules.= &do_lib_rule(
				"\$(CRYPTOOBJ) \$(O_FIPSCANISTER)",
				"\$(O_CRYPTO)", "$crypto",
				$shlib, "\$(SO_CRYPTO)", "\$(BASEADDR)");
			}
		}
	else
		{
		$rules.= &do_lib_rule("\$(CRYPTOOBJ)",
			"\$(O_CRYPTO)",$crypto,$shlib,"\$(SO_CRYPTO)", "");
		$rules.= &do_lib_rule("\$(CRYPTOOBJ) \$(FIPSOBJ)",
			"\$(LIB_D)$o$crypto_compat",$crypto,$shlib,"\$(SO_CRYPTO)", "");
		}
	}
	else
	{
	$rules.= &do_lib_rule("\$(CRYPTOOBJ)","\$(O_CRYPTO)",$crypto,$shlib,
							"\$(SO_CRYPTO)");
	}

if ($fips)
	{
	if ($fipscanisterbuild)
		{
		$rules.= &do_rlink_rule("\$(O_FIPSCANISTER)",
					"\$(OBJ_D)${o}fips_start$obj",
					"\$(FIPSOBJ)",
					"\$(OBJ_D)${o}fips_end$obj",
					"\$(FIPS_SHA1_EXE)", "");
		$rules.=&do_link_rule("\$(FIPS_SHA1_EXE)",
					"\$(OBJ_D)${o}fips_standalone_sha1$obj \$(OBJ_D)${o}sha1dgst$obj \$(SHA1_ASM_OBJ)",
					"","\$(EX_LIBS)", 1);
		}
	else
		{
		$rules.=&do_link_rule("\$(FIPS_SHA1_EXE)",
					"\$(OBJ_D)${o}fips_standalone_sha1$obj \$(O_FIPSCANISTER)",
					"","", 1);

		}
	$rules.=&do_link_rule("\$(PREMAIN_DSO_EXE)","\$(OBJ_D)${o}\$(E_PREMAIN_DSO)$obj \$(CRYPTOOBJ) \$(O_FIPSCANISTER)","","\$(EX_LIBS)", 1);
	
	}

$rules.=&do_link_rule("\$(BIN_D)$o\$(E_EXE)$exep","\$(E_OBJ)","\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)", ($fips && !$shlib) ? 2 : 0);
a712 1
	return("") if !$fips   && $dir =~ /^fips/;
d724 1
d742 2
a743 2
	@@a=grep(!/(^s2_)|(^s23_)/,@@a) if $no_ssl2;
	@@a=grep(!/(^s3_)|(^s23_)/,@@a) if $no_ssl3;
d817 1
a824 1
		elsif ($_ =~ /AES_ASM/){ $t="$_ "; }
d826 1
d834 1
a834 1
	if ($shlib && (($platform eq "VC-WIN32") || ($platform eq "VC-NT")))
d854 7
d868 2
a869 2
	local($ret,$_,$n);
	
d874 17
a890 1
		$ret.=&cc_compile_target("$to${o}$n$obj","${_}.c",$ex)
d897 26
d945 1
d947 1
a947 1
	@@t=split(/\s+/,$target);
d951 13
a963 2
		$ret.="$t[$i]: $s[$i]\n";
		$ret.="\t\$(ASM) $afile$t[$i] \$(SRC_D)$o$s[$i]\n\n";
d1027 1
a1035 1
		"ml64" => \$ml64,
a1043 1
		"no-capieng" => \$no_capieng,
d1068 1
a1070 3
		"fips" => \$fips,
		"fipscanisterbuild" => [\$fips, \$fipscanisterbuild],
		"fipsdso" => [\$fips, \$fipscanisterbuild, \$fipsdso],
a1145 28
	}

sub fipslib_error
	{
	print STDERR "***FIPS module directory sanity check failed***\n";
	print STDERR "FIPS module build failed, or was deleted\n";
	print STDERR "Please rebuild FIPS module.\n"; 
	exit 1;
	}

sub fips_check_files
	{
	my $dir = shift @@_;
	my $ret = 1;
	if (!-d $dir)
		{
		print STDERR "FIPS module directory $dir does not exist\n";
		fipslib_error();
		}
	foreach (@@_)
		{
		if (!-f "$dir${o}$_")
			{
			print STDERR "FIPS module file $_ does not exist!\n";
			$ret = 0;
			}
		}
	fipslib_error() if ($ret == 0);
@


1.12
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d18 12
d236 1
d245 1
a245 1

a266 1

d268 2
a269 1
		  "CRYPTO" => " -DOPENSSL_BUILD_SHLIBCRYPTO");
d297 15
a311 5
			$uc=$lib;
			$uc =~ s/^lib(.*)\.a/$1/;
			$uc =~ tr/a-z/A-Z/;
			$lib_nam{$uc}=$uc;
			$lib_obj{$uc}.=$libobj." ";
d354 15
d374 104
d543 1
d587 11
d605 1
d626 1
d631 1
d633 1
a633 1
L_LIBS= \$(L_SSL) \$(L_CRYPTO)
d643 1
a643 1
LIBS_DEP=\$(O_CRYPTO) \$(O_SSL)
d649 1
a649 1
all: banner \$(TMP_D) \$(BIN_D) \$(TEST_D) \$(LIB_D) \$(INCO_D) headers lib exe
d764 20
d794 2
a795 1
	if (($aes_asm_obj ne "") && ($_ eq "CRYPTO"))
d797 32
a828 19
		$lib_obj =~ s/\s(\S*\/aes_core\S*)/ \$(AES_ASM_OBJ)/;
		$lib_obj =~ s/\s\S*\/aes_cbc\S*//;
		$rules.=&do_asm_rule($aes_asm_obj,$aes_asm_src);
		}
	if (($bn_asm_obj ne "") && ($_ eq "CRYPTO"))
		{
		$lib_obj =~ s/\s\S*\/bn_asm\S*/ \$(BN_ASM_OBJ)/;
		$rules.=&do_asm_rule($bn_asm_obj,$bn_asm_src);
		}
	if (($bnco_asm_obj ne "") && ($_ eq "CRYPTO"))
		{
		$lib_obj .= "\$(BNCO_ASM_OBJ)";
		$rules.=&do_asm_rule($bnco_asm_obj,$bnco_asm_src);
		}
	if (($des_enc_obj ne "") && ($_ eq "CRYPTO"))
		{
		$lib_obj =~ s/\s\S*des_enc\S*/ \$(DES_ENC_OBJ)/;
		$lib_obj =~ s/\s\S*\/fcrypt_b\S*\s*/ /;
		$rules.=&do_asm_rule($des_enc_obj,$des_enc_src);
a854 5
	if (($sha1_asm_obj ne "") && ($_ eq "CRYPTO"))
		{
		$lib_obj =~ s/\s(\S*\/sha1dgst\S*)/ $1 \$(SHA1_ASM_OBJ)/;
		$rules.=&do_asm_rule($sha1_asm_obj,$sha1_asm_src);
		}
a859 5
	if (($cpuid_asm_obj ne "") && ($_ eq "CRYPTO"))
		{
		$lib_obj =~ s/\s(\S*\/cversion\S*)/ $1 \$(CPUID_ASM_OBJ)/;
		$rules.=&do_asm_rule($cpuid_asm_obj,$cpuid_asm_src);
		}
d874 3
d883 1
d885 24
d910 1
a910 1
	$rules.=&do_link_rule("\$(TEST_D)$o$t$exep",$tt,"\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)");
a923 1
$rules.= &do_lib_rule("\$(CRYPTOOBJ)","\$(O_CRYPTO)",$crypto,$shlib,"\$(SO_CRYPTO)");
d925 62
a986 1
$rules.=&do_link_rule("\$(BIN_D)$o\$(E_EXE)$exep","\$(E_OBJ)","\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)");
d1024 2
d1285 1
d1293 1
d1321 3
d1365 12
d1399 28
@


1.11
log
@resolve conflicts
@
text
@d224 1
d1021 1
d1105 1
a1105 1
	elsif (/^([^=]*)=(.*)$/){ $VARS{$1}=$2; }
@


1.10
log
@resolve conflicts
@
text
@d13 2
a17 10
my $fips_canister_path = "";
my $fips_premain_dso_exe_path = "";
my $fips_premain_c_path = "";
my $fips_sha1_exe_path = "";

my $fipslibdir = "";
my $baseaddr = "";

my $ex_l_libs = "";

d33 2
a34 1
	"VC-WIN32-GMAKE", "Microsoft Visual C++ [4-6] - Windows NT or 9X, GNU make",
a36 4
	"VC-W31-16",  "Microsoft Visual C++ 1.52 - Windows 3.1 - 286",
	"VC-WIN16",   "Alias for VC-W31-32",
	"VC-W31-32",  "Microsoft Visual C++ 1.52 - Windows 3.1 - 386+",
	"VC-MSDOS","Microsoft Visual C++ 1.52 - MSDOS",
a39 2
	"BC-W31",  "Borland C++ 4.5 - Windows 3.1 - PROBABLY NOT WORKING",
	"BC-MSDOS","Borland C++ 4.5 - MSDOS",
d44 4
d67 1
a67 1
	no-bf no-cast no-aes
d74 2
d79 2
d105 2
d119 2
a120 4
$mkdir="-mkdir";
$mkcanister="ld -r -o";

$ex_build_targets = "";
a122 1
$cryptocompat = "";
d131 1
d135 1
a135 7
if ($platform eq "VC-MSDOS")
	{
	$asmbits=16;
	$msdos=1;
	require 'VC-16.pl';
	}
elsif ($platform eq "VC-W31-16")
d137 2
a138 13
	$asmbits=16;
	$msdos=1; $win16=1;
	require 'VC-16.pl';
	}
elsif (($platform eq "VC-W31-32") || ($platform eq "VC-WIN16"))
	{
	$asmbits=32;
	$msdos=1; $win16=1;
	require 'VC-16.pl';
	}
elsif (($platform eq "VC-WIN32") || ($platform eq "VC-NT"))
	{
	$NT = 1 if $platform eq "VC-NT";
a140 8
elsif ($platform eq "VC-WIN32-GMAKE")
	{
	require 'VC-32-GMAKE.pl';
	}
elsif ($platform eq "VC-CE")
	{
	require 'VC-CE.pl';
	}
a153 17
elsif ($platform eq "BC-W31")
	{
	$bc=1;
	$msdos=1; $w16=1;
	require 'BC-16.pl';
	}
elsif ($platform eq "BC-Q16")
	{
	$msdos=1; $w16=1; $shlib=0; $qw=1;
	require 'BC-16.pl';
	}
elsif ($platform eq "BC-MSDOS")
	{
	$asmbits=16;
	$msdos=1;
	require 'BC-16.pl';
	}
d176 7
d201 2
d213 1
a213 1
$cflags.=" -DOPENSSL_NO_BF"   if $no_bf;
d222 2
d227 2
a230 2
$cflags.=" -DOPENSSL_FIPS"    if $fips;
#$cflags.=" -DRSAref"  if $rsaref ne "";
d235 11
d283 5
a287 15
 			if ($fips && $dir =~ /^fips/)
 				{
 				$uc = "FIPS";
 				}
 			else
 				{
 				$uc=$lib;
 				$uc =~ s/^lib(.*)\.a/$1/;
 				$uc =~ tr/a-z/A-Z/;
				}
			if (($uc ne "FIPS") || $fips_canister_build)
				{
				$lib_nam{$uc}=$uc;
				$lib_obj{$uc}.=$libobj." ";
				}
d308 1
a308 1
		{ $test.=&var_add($dir,$val); }
d311 1
a311 1
		{ $e_exe.=&var_add($dir,$val); }
d320 1
a320 1
		{ $exheader.=&var_add($dir,$val); }
d323 1
a323 1
		{ $header.=&var_add($dir,$val); }
d325 4
a328 8
	if ($key eq "LIBOBJ")
		{ $libobj=&var_add($dir,$val); }

	if ($key eq "FIPSLIBDIR")
		{ $fipslibdir=$val;}

	if ($key eq "BASEADDR")
		{ $baseaddr=$val;}
d335 1
a335 1
if ($fips_canister_path eq "")
d337 7
a343 11
	$fips_canister_path = "\$(FIPSLIB_D)${o}fipscanister.o";
	}

if ($fips_premain_c_path eq "")
	{
	$fips_premain_c_path = "\$(FIPSLIB_D)${o}fips_premain.c";
	}

if ($fips)
	{
	if ($fips_sha1_exe_path eq "")
d345 4
a348 2
		$fips_sha1_exe_path =
			"\$(BIN_D)${o}fips_standalone_sha1$exep";
d351 1
a351 1
	else
d353 5
a357 27
	$fips_sha1_exe_path = "";
	}

if ($fips_premain_dso_exe_path eq "")
	{
	$fips_premain_dso_exe_path = "\$(BIN_D)${o}fips_premain_dso$exep";
	}

#	$ex_build_targets .= "\$(BIN_D)${o}\$(E_PREMAIN_DSO)$exep" if ($fips);

if ($fips)
	{
	if (!$shlib)
		{
		$ex_build_targets .= " \$(LIB_D)$o$crypto_compat \$(PREMAIN_DSO_EXE)";
		$ex_l_libs .= " \$(O_FIPSCANISTER)";
		}
	if ($fipslibdir eq "")
		{
		open (IN, "util/fipslib_path.txt") || fipslib_error();
		$fipslibdir = <IN>;
		chomp $fipslibdir;
		close IN;
		}
	fips_check_files($fipslibdir,
			"fipscanister.o", "fipscanister.o.sha1",
			"fips_premain.c", "fips_premain.c.sha1");
a358 1
	
a377 9
if ($platform eq "VC-CE")
	{
	$defs.= <<"EOF";
!INCLUDE <\$(WCECOMPAT)/wcedefs.mak>

EOF
	$ex_libs .= " $zlib_lib" if $zlib_opt == 1;
	}

a397 2
PERL=perl
FIPSLINK=\$(PERL) util${o}fipslink.pl
d399 1
d401 2
d423 2
d434 1
a434 3
# Directory containing FIPS module


a441 12
MKCANISTER=$mkcanister

# FIPS validated module and support file locations

E_PREMAIN_DSO=fips_premain_dso

FIPSLIB_D=$fipslibdir
BASEADDR=$baseaddr
FIPS_PREMAIN_SRC=$fips_premain_c_path
O_FIPSCANISTER=$fips_canister_path
FIPS_SHA1_EXE=$fips_sha1_exe_path
PREMAIN_DSO_EXE=$fips_premain_dso_exe_path
d454 1
d461 1
d475 1
a475 1
L_LIBS= \$(L_SSL) \$(L_CRYPTO) $ex_l_libs
d485 1
a485 1
LIBS_DEP=\$(O_CRYPTO) \$(O_SSL) $ex_libs_dep
d491 1
a491 1
all: banner \$(TMP_D) \$(BIN_D) \$(TEST_D) \$(LIB_D) \$(INCO_D) headers \$(FIPS_SHA1_EXE) lib exe $ex_build_targets
d497 1
a497 1
	\$(MKDIR) \$(TMP_D)
d506 1
a506 1
	\$(MKDIR) \$(LIB_D)
d509 1
a509 1
	\$(MKDIR) \$(INCO_D)
d512 1
a512 1
	\$(MKDIR) \$(INC_D)
d517 1
a517 1
lib: \$(LIBS_DEP)
d521 15
a535 10
install:
	\$(MKDIR) \$(INSTALLTOP)
	\$(MKDIR) \$(INSTALLTOP)${o}bin
	\$(MKDIR) \$(INSTALLTOP)${o}include
	\$(MKDIR) \$(INSTALLTOP)${o}include${o}openssl
	\$(MKDIR) \$(INSTALLTOP)${o}lib
	\$(CP) \$(INCO_D)${o}*.\[ch\] \$(INSTALLTOP)${o}include${o}openssl
	\$(CP) \$(BIN_D)$o\$(E_EXE)$exep \$(INSTALLTOP)${o}bin
	\$(CP) \$(O_SSL) \$(INSTALLTOP)${o}lib
	\$(CP) \$(O_CRYPTO) \$(INSTALLTOP)${o}lib
d594 2
a595 2
$defs.=&do_defs("HEADER",$header,"\$(INCL_D)",".h");
$rules.=&do_copy_rule("\$(INCL_D)",$header,".h");
d597 2
a598 2
$defs.=&do_defs("EXHEADER",$exheader,"\$(INCO_D)",".h");
$rules.=&do_copy_rule("\$(INCO_D)",$exheader,".h");
a605 23
# Special case rules for fips_start and fips_end fips_premain_dso

if ($fips)
	{
	if ($fips_canister_build)
		{
		$rules.=&cc_compile_target("\$(OBJ_D)${o}fips_start$obj",
			"fips-1.0${o}fips_canister.c",
			"-DFIPS_START \$(SHLIB_CFLAGS)");
		$rules.=&cc_compile_target("\$(OBJ_D)${o}fips_end$obj",
			"fips-1.0${o}fips_canister.c", "\$(SHLIB_CFLAGS)");
		}
	$rules.=&cc_compile_target("\$(OBJ_D)${o}fips_standalone_sha1$obj",
		"fips-1.0${o}sha${o}fips_standalone_sha1.c",
		"\$(SHLIB_CFLAGS)");
	$rules.=&cc_compile_target("\$(OBJ_D)${o}fips_sha1dgst$obj",
		"fips-1.0${o}sha${o}fips_sha1dgst.c",
		"\$(SHLIB_CFLAGS)") unless $fips_canister_build;
	$rules.=&cc_compile_target("\$(OBJ_D)${o}\$(E_PREMAIN_DSO)$obj",
		"fips-1.0${o}fips_premain.c",
		"-DFINGERPRINT_PREMAIN_DSO_LOAD \$(SHLIB_CFLAGS)");
	}

d616 6
a621 1

d673 5
d683 12
d703 1
a703 2
$rules.= &do_lib_rule("\$(SSLOBJ)","\$(O_SSL)",$ssl,$shlib,"\$(SO_SSL)");

d705 1
a705 1
if ($fips)
d707 2
a708 19
	if ($shlib)
		{
		$rules.= &do_lib_rule("\$(CRYPTOOBJ) \$(O_FIPSCANISTER)",
			"\$(O_CRYPTO)",
			"$crypto",
			$shlib, "\$(SO_CRYPTO)", "\$(BASEADDR)");
		}
	else
		{
		$rules.= &do_lib_rule("\$(CRYPTOOBJ)",
			"\$(O_CRYPTO)",$crypto,$shlib,"\$(SO_CRYPTO)", "");
		$rules.= &do_lib_rule("\$(CRYPTOOBJ) \$(O_FIPSCANISTER)",
			"\$(LIB_D)$o$crypto_compat",$crypto,$shlib,"\$(SO_CRYPTO)", "");
		}
	}
	else
	{
	$rules.= &do_lib_rule("\$(CRYPTOOBJ)","\$(O_CRYPTO)",$crypto,$shlib,
							"\$(SO_CRYPTO)");
a711 7
if ($fips)
	{
	$rules.= &do_rlink_rule("\$(O_FIPSCANISTER)", "\$(OBJ_D)${o}fips_start$obj \$(FIPSOBJ) \$(OBJ_D)${o}fips_end$obj", "\$(FIPSLIB_D)${o}fips_standalone_sha1$exep", "") if $fips_canister_build;
	$rules.=&do_link_rule("\$(PREMAIN_DSO_EXE)","\$(OBJ_D)${o}\$(E_PREMAIN_DSO)$obj \$(CRYPTOOBJ) \$(O_FIPSCANISTER)","","\$(EX_LIBS)", 1);
	
	$rules.=&do_link_rule("\$(FIPS_SHA1_EXE)","\$(OBJ_D)${o}fips_standalone_sha1$obj \$(OBJ_D)${o}fips_sha1dgst$obj","","", 1);
	}
d713 4
a716 1
	$rules.=&do_link_rule("\$(BIN_D)$o\$(E_EXE)$exep","\$(E_OBJ)","\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)",0);
d736 1
a736 1
	local($dir,$val)=@@_;
d743 2
d753 1
d768 1
a768 1
	grep(s/\.[och]$//,@@a);
d779 2
d864 1
d866 1
d872 9
a880 1
	chop($ret);
d975 1
a975 1
		$ret.="$to${o}$n$pp: \$(SRC_D)$o$_$pp\n\t\$(CP) \$(SRC_D)$o$_$pp $to${o}$n$pp\n\n";
d982 105
a1086 48
	if    (/^no-rc2$/)	{ $no_rc2=1; }
	elsif (/^no-rc4$/)	{ $no_rc4=1; }
	elsif (/^no-rc5$/)	{ $no_rc5=1; }
	elsif (/^no-idea$/)	{ $no_idea=1; }
	elsif (/^no-aes$/)	{ $no_aes=1; }
	elsif (/^no-des$/)	{ $no_des=1; }
	elsif (/^no-bf$/)	{ $no_bf=1; }
	elsif (/^no-cast$/)	{ $no_cast=1; }
	elsif (/^no-md2$/)  	{ $no_md2=1; }
	elsif (/^no-md4$/)	{ $no_md4=1; }
	elsif (/^no-md5$/)	{ $no_md5=1; }
	elsif (/^no-sha$/)	{ $no_sha=1; }
	elsif (/^no-sha1$/)	{ $no_sha1=1; }
	elsif (/^no-ripemd$/)	{ $no_ripemd=1; }
	elsif (/^no-mdc2$/)	{ $no_mdc2=1; }
	elsif (/^no-patents$/)	{ $no_rc2=$no_rc4=$no_rc5=$no_idea=$no_rsa=1; }
	elsif (/^no-rsa$/)	{ $no_rsa=1; }
	elsif (/^no-dsa$/)	{ $no_dsa=1; }
	elsif (/^no-dh$/)	{ $no_dh=1; }
	elsif (/^no-hmac$/)	{ $no_hmac=1; }
	elsif (/^no-aes$/)	{ $no_aes=1; }
	elsif (/^no-asm$/)	{ $no_asm=1; }
	elsif (/^nasm$/)	{ $nasm=1; }
	elsif (/^gaswin$/)	{ $gaswin=1; }
	elsif (/^no-ssl2$/)	{ $no_ssl2=1; }
	elsif (/^no-ssl3$/)	{ $no_ssl3=1; }
	elsif (/^no-err$/)	{ $no_err=1; }
	elsif (/^no-sock$/)	{ $no_sock=1; }
	elsif (/^no-krb5$/)	{ $no_krb5=1; }
	elsif (/^no-ec$/)	{ $no_ec=1; }
	elsif (/^no-engine$/)	{ $no_engine=1; }
	elsif (/^no-hw$/)	{ $no_hw=1; }

	elsif (/^just-ssl$/)	{ $no_rc2=$no_idea=$no_des=$no_bf=$no_cast=1;
				  $no_md2=$no_sha=$no_mdc2=$no_dsa=$no_dh=1;
				  $no_ssl2=$no_err=$no_ripemd=$no_rc5=1;
				  $no_aes=1; }

	elsif (/^rsaref$/)	{ }
	elsif (/^fips$/)	{ $fips=1; }
	elsif (/^gcc$/)		{ $gcc=1; }
	elsif (/^debug$/)	{ $debug=1; }
	elsif (/^profile$/)	{ $profile=1; }
	elsif (/^shlib$/)	{ $shlib=1; }
	elsif (/^dll$/)		{ $shlib=1; }
	elsif (/^shared$/)	{ } # We just need to ignore it for now...
 	elsif (/^zlib$/) { $zlib_opt = 1 if $zlib_opt == 0 }
	elsif (/^zlib-dynamic$/){ $zlib_opt = 2; }
a1108 28
	}

sub fipslib_error
	{
	print STDERR "***FIPS module directory sanity check failed***\n";
	print STDERR "FIPS module build failed, or was deleted\n";
	print STDERR "Please rebuild FIPS module.\n"; 
	exit 1;
	}

sub fips_check_files
	{
	my $dir = shift @@_;
	my $ret = 1;
	if (!-d $dir)
		{
		print STDERR "FIPS module directory $dir does not exist\n";
		fipslib_error();
		}
	foreach (@@_)
		{
		if (!-f "$dir${o}$_")
			{
			print STDERR "FIPS module file $_ does not exist!\n";
			$ret = 0;
			}
		}
	fipslib_error() if ($ret == 0);
@


1.9
log
@resolve conflicts
@
text
@d13 14
d41 1
d61 1
d123 3
d128 1
d163 4
d237 2
d268 3
d278 1
d295 129
d448 1
d471 2
d504 3
d514 12
d557 1
a557 1
L_LIBS= \$(L_SSL) \$(L_CRYPTO)
d567 1
a567 1
LIBS_DEP=\$(O_CRYPTO) \$(O_SSL)
d573 1
a573 1
all: banner \$(TMP_D) \$(BIN_D) \$(TEST_D) \$(LIB_D) \$(INCO_D) headers lib exe
a658 51
#############################################
# We parse in input file and 'store' info for later printing.
open(IN,"<$infile") || die "unable to open $infile:$!\n";
$_=<IN>;
for (;;)
	{
	chop;

	($key,$val)=/^([^=]+)=(.*)/;
	if ($key eq "RELATIVE_DIRECTORY")
		{
		if ($lib ne "")
			{
			$uc=$lib;
			$uc =~ s/^lib(.*)\.a/$1/;
			$uc =~ tr/a-z/A-Z/;
			$lib_nam{$uc}=$uc;
			$lib_obj{$uc}.=$libobj." ";
			}
		last if ($val eq "FINISHED");
		$lib="";
		$libobj="";
		$dir=$val;
		}

	if ($key eq "TEST")
		{ $test.=&var_add($dir,$val); }

	if (($key eq "PROGS") || ($key eq "E_OBJ"))
		{ $e_exe.=&var_add($dir,$val); }

	if ($key eq "LIB")
		{
		$lib=$val;
		$lib =~ s/^.*\/([^\/]+)$/$1/;
		}

	if ($key eq "EXHEADER")
		{ $exheader.=&var_add($dir,$val); }

	if ($key eq "HEADER")
		{ $header.=&var_add($dir,$val); }

	if ($key eq "LIBOBJ")
		{ $libobj=&var_add($dir,$val); }

	if (!($_=<IN>))
		{ $_="RELATIVE_DIRECTORY=FINISHED\n"; }
	}
close(IN);

d683 23
d782 1
a782 1
$rules.= &do_lib_rule("\$(CRYPTOOBJ)","\$(O_CRYPTO)",$crypto,$shlib,"\$(SO_CRYPTO)");
d786 14
a799 1
	$rules.=&do_link_rule("\$(BIN_D)$o\$(E_EXE)$exep","\$(E_OBJ)","\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)","\$(BIN_D)$o.sha1","\$(BIN_D)$o\$(E_EXE)$exep");
d801 8
a808 1
else
d810 4
a813 1
	$rules.=&do_link_rule("\$(BIN_D)$o\$(E_EXE)$exep","\$(E_OBJ)","\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)");
d815 3
d1113 18
d1137 28
@


1.8
log
@merge 0.9.7d
@
text
@d13 1
a13 1
open(IN,"<Makefile.ssl") || die "unable to open Makefile.ssl!\n";
d21 1
a21 1
die "Makefile.ssl is not the toplevel Makefile!\n" if $ssl_version eq "";
d225 1
a225 1
$cflags.=" -DOPENSSL_NO_BF"  if $no_bf;
d239 1
d635 8
a642 2
$rules.=&do_link_rule("\$(BIN_D)$o\$(E_EXE)$exep","\$(E_OBJ)","\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)");

d649 1
a649 1
	(cd \$(\@@D)/..; PERL=perl make -f Makefile.ssl asm/\$(\@@F))
d931 1
@


1.7
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d280 2
@


1.6
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d27 1
d67 2
d143 4
d223 1
a223 1
$cflags.=" -DOPENSSL_NO_RIPEMD" if $no_rmd160;
d237 2
d278 11
d655 2
d666 1
d701 1
a701 1
	@@a=grep(!/(rmd)|(ripemd)/,@@a) if $no_rmd160;
d718 2
d913 2
d918 1
a918 1
				  $no_ssl2=$no_err=$no_rmd160=$no_rc5=1;
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d103 1
a103 1
$mkdir="mkdir";
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d40 1
d58 2
a59 2
	no-rc2 no-rc4 no-idea no-des no-bf no-cast - Skip this symetric cipher
	no-rc5
d64 2
a73 1
	rsaref					- Build to require RSAref
d86 1
a86 1
foreach (split / /, $OPTIONS)
d96 1
a96 1
$no_ssl2=1 if ($no_md5 || $no_rsa);
a105 1
$RSAglue="RSAglue";
d187 5
d206 25
a230 22
$cflags.=" -DNO_IDEA" if $no_idea;
$cflags.=" -DNO_RC2"  if $no_rc2;
$cflags.=" -DNO_RC4"  if $no_rc4;
$cflags.=" -DNO_RC5"  if $no_rc5;
$cflags.=" -DNO_MD2"  if $no_md2;
$cflags.=" -DNO_MD4"  if $no_md4;
$cflags.=" -DNO_MD5"  if $no_md5;
$cflags.=" -DNO_SHA"  if $no_sha;
$cflags.=" -DNO_SHA1" if $no_sha1;
$cflags.=" -DNO_RIPEMD" if $no_rmd160;
$cflags.=" -DNO_MDC2" if $no_mdc2;
$cflags.=" -DNO_BF"  if $no_bf;
$cflags.=" -DNO_CAST" if $no_cast;
$cflags.=" -DNO_DES"  if $no_des;
$cflags.=" -DNO_RSA"  if $no_rsa;
$cflags.=" -DNO_DSA"  if $no_dsa;
$cflags.=" -DNO_DH"   if $no_dh;
$cflags.=" -DNO_SOCK" if $no_sock;
$cflags.=" -DNO_SSL2" if $no_ssl2;
$cflags.=" -DNO_SSL3" if $no_ssl3;
$cflags.=" -DNO_ERR"  if $no_err;
$cflags.=" -DRSAref"  if $rsaref ne "";
d239 3
a333 1
RSAGLUE=$RSAglue
a351 1
O_RSAGLUE= \$(LIB_D)$o$plib\$(RSAGLUE)$libp
a357 1
#L_LIBS= \$(O_SSL) \$(O_RSAGLUE) -lrsaref \$(O_CRYPTO)
d367 1
a367 1
LIBS_DEP=\$(O_CRYPTO) \$(O_RSAGLUE) \$(O_SSL)
a538 2
	$slib=0 if ($_ eq "RSAGLUE");

a544 6
	if (($_ eq "RSAGLUE") && $no_rsa)
		{
		$rules.="\$(O_RSAGLUE):\n\n"; 
		next;
		}

d597 1
a597 1
	$lib=($slib)?" \$(SHLIB_CFLAGS)":" \$(LIB_CFLAGS)";
a609 2
$rules.= &do_lib_rule("\$(RSAGLUEOBJ)","\$(O_RSAGLUE)",$RSAglue,0,"")
	unless $no_rsa;
d636 1
d662 2
a663 1
	@@a=grep(!/^e_.*_i$/,@@a) if $no_idea;
d862 1
d878 1
d886 2
d891 2
a892 1
				  $no_ssl2=$no_err=$no_rmd160=$no_rc5=1; }
d894 1
a894 1
	elsif (/^rsaref$/)	{ $rsaref=1; }
@


1.3
log
@OpenSSL 0.9.5a merge
@
text
@d55 2
a56 1
	no-md2 no-md5 no-sha no-mdc2 no-ripemd  - Skip this digest
d69 1
d205 1
d223 4
a226 3
if ($unix)
	{ $cflags="$c_flags" if ($c_flags ne ""); }
else	{ $cflags="$c_flags$cflags" if ($c_flags ne ""); }
d280 2
d388 1
d549 5
d616 8
d675 1
d741 1
d865 1
d891 1
d894 1
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d11 1
d63 1
d855 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#!/usr/bin/perl
d9 2
d12 9
a20 1
$ssl_version="0.8.2";
d25 2
a26 1
	"VC-WIN32",   "Microsoft Visual C++ 4.[01] - Windows NT [34].x",
d31 3
a33 1
	"BC-NT",   "Borland C++ 4.5 - Windows NT  - PROBABLY NOT WORKING",
d37 1
d42 1
a42 1
$type="";
d45 1
a45 37
	if    (/^no-rc2$/)	{ $no_rc2=1; }
	elsif (/^no-rc4$/)	{ $no_rc4=1; }
	elsif (/^no-rc5$/)	{ $no_rc5=1; }
	elsif (/^no-idea$/)	{ $no_idea=1; }
	elsif (/^no-des$/)	{ $no_des=1; }
	elsif (/^no-bf$/)	{ $no_bf=1; }
	elsif (/^no-cast$/)	{ $no_cast=1; }
	elsif (/^no-md2$/)  	{ $no_md2=1; }
	elsif (/^no-md5$/)	{ $no_md5=1; }
	elsif (/^no-sha$/)	{ $no_sha=1; }
	elsif (/^no-sha1$/)	{ $no_sha1=1; }
	elsif (/^no-rmd160$/)	{ $no_rmd160=1; }
	elsif (/^no-mdc2$/)	{ $no_mdc2=1; }
	elsif (/^no-patents$/)	{ $no_rc2=$no_rc4=$no_rc5=$no_idea=$no_rsa=1; }
	elsif (/^no-rsa$/)	{ $no_rsa=1; }
	elsif (/^no-dsa$/)	{ $no_dsa=1; }
	elsif (/^no-dh$/)	{ $no_dh=1; }
	elsif (/^no-asm$/)	{ $no_asm=1; }
	elsif (/^no-ssl2$/)	{ $no_ssl2=1; }
	elsif (/^no-ssl3$/)	{ $no_ssl3=1; }
	elsif (/^no-err$/)	{ $no_err=1; }
	elsif (/^no-sock$/)	{ $no_sock=1; }

	elsif (/^just-ssl$/)	{ $no_rc2=$no_idea=$no_des=$no_bf=$no_cast=1;
				  $no_md2=$no_sha=$no_mdc2=$no_dsa=$no_dh=1;
				  $no_ssl2=$no_err=1; }

	elsif (/^rsaref$/)	{ $rsaref=1; }
	elsif (/^gcc$/)		{ $gcc=1; }
	elsif (/^debug$/)	{ $debug=1; }
	elsif (/^shlib$/)	{ $shlib=1; }
	elsif (/^dll$/)		{ $shlib=1; }
	elsif (/^([^=]*)=(.*)$/){ $VARS{$1}=$2; }
	elsif (/^-[lL].*$/)	{ $l_flags.="$_ "; }
	elsif ((!/^-help/) && (!/^-h/) && (!/^-\?/) && /^-.*$/)
		{ $c_flags.="$_ "; }
	else
d47 6
a52 8
		if (!defined($ops{$_}))
			{
			print STDERR "unknown option - $_\n";
			print STDERR "usage: perl mk1mf.pl [system] [options]\n";
			print STDERR "\nwhere [system] can be one of the following\n";
			foreach $i (sort keys %ops)
				{ printf STDERR "\t%-10s\t%s\n",$i,$ops{$i}; }
			print STDERR <<"EOF";
d54 1
a54 1
	no-md2 no-md5 no-sha no-sha1 no-mdc2 no-rmd160 - Skip this digest
d61 1
d76 1
a76 3
			exit(1);
			}
		$type=$_;
d78 5
d87 1
a87 1
$no_ssl3=1 if ($no_md5 || $no_sha1);
d97 1
d109 2
d112 1
a112 1
if ($type eq "VC-MSDOS")
d118 1
a118 1
elsif ($type eq "VC-W31-16")
d124 1
a124 1
elsif (($type eq "VC-W31-32") || ($type eq "VC-WIN16"))
d130 1
a130 1
elsif (($type eq "VC-WIN32") || ($type eq "VC-NT"))
d132 1
d135 9
a143 1
elsif ($type eq "BC-NT")
d148 1
a148 1
elsif ($type eq "BC-W31")
d154 1
a154 1
elsif ($type eq "BC-Q16")
d159 1
a159 1
elsif ($type eq "BC-MSDOS")
d165 1
a165 1
elsif ($type eq "FreeBSD")
d170 1
a170 1
elsif ($type eq "linux-elf")
d176 6
d204 1
a204 1
$cflags.=" -DNO_RMD160" if $no_rmd160;
d206 1
a206 1
$cflags.=" -DNO_BLOWFISH"  if $no_bf;
a223 5
if ($ranlib ne "")
	{
	$ranlib="\$(SRC_D)$o$ranlib";
	}

d226 1
a226 1
	$banner ="\t\@@echo Make sure you have run 'perl Configure $type' in the\n";
d238 2
a239 2
# This makefile has been automatically generated from the SSLeay distribution.
# This single makefile will build the complete SSLeay distribution and
d254 1
d266 1
a266 1
# The SSLeay directory
d272 2
a273 2
BN_MULW_OBJ=$bn_mulw_obj
BN_MULW_SRC=$bn_mulw_src
a275 2
DES_CRYPT_OBJ=$des_crypt_obj
DES_CRYPT_SRC=$des_crypt_src
d297 1
d302 1
a302 1
MKDIR=mkdir
d311 1
a311 1
E_EXE=ssleay
d319 3
d336 2
a337 2
L_SSL=     \$(LIB_D)$o\$(SSL)$libp
L_CRYPTO=  \$(LIB_D)$o\$(CRYPTO)$libp
d356 1
a356 1
all: banner \$(TMP_D) \$(BIN_D) \$(TEST_D) \$(LIB_D) \$(INC_D) headers lib exe
d363 6
a368 6

\$(BIN_D):
	\$(MKDIR) \$(BIN_D)

\$(TEST_D):
	\$(MKDIR) \$(TEST_D)
d373 3
d389 1
d391 1
a391 1
	\$(CP) \$(INC_D)${o}*.\[ch\] \$(INSTALLTOP)${o}include
d404 36
d507 2
a508 2
$defs.=&do_defs("EXHEADER",$exheader,"\$(INC_D)",".h");
$rules.=&do_copy_rule("\$(INC_D)",$exheader,".h");
d535 1
a535 1
	if (($bn_mulw_obj ne "") && ($_ eq "CRYPTO"))
d537 2
a538 2
		$lib_obj =~ s/\s\S*\/bn_mulw\S*/ \$(BN_MULW_OBJ)/;
		$rules.=&do_asm_rule($bn_mulw_obj,$bn_mulw_src);
d654 1
d671 1
a671 1
	@@a=grep(!/(^rsa$)|(^genrsa$)|(^req$)|(^ca$)/,@@a) if $no_rsa;
d717 1
a717 1
		if ($_ =~ /BN_MULW/)	{ $t="$_ "; }
a743 17
# do a rule for each file that says 'copy' to new direcory on change
sub do_copy_rule
	{
	local($to,$files,$p)=@@_;
	local($ret,$_,$n,$pp);
	
	$files =~ s/\//$o/g if $o ne '/';
	foreach (split(/\s+/,$files))
		{
		$n=&bname($_);
		if ($n =~ /bss_file/)
			{ $pp=".c"; }
		else	{ $pp=$p; }
		$ret.="$to${o}$n$pp: \$(SRC_D)$o$_$pp\n\t\$(CP) \$(SRC_D)$o$_$pp $to${o}$n$pp\n\n";
		}
	return($ret);
	}
d769 1
a769 2
	# EAY EAY
	$ex_flags.=' -DCFLAGS="\"$(CC) $(CFLAG)\""' if ($source =~ /cversion/);
d813 61
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d1 1
a1 1
#!/usr/local/bin/perl
a8 11
$OPTIONS="";
$ssl_version="";
$banner="\t\@@echo Building OpenSSL";

open(IN,"<Makefile.ssl") || die "unable to open Makefile.ssl!\n";
while(<IN>) {
    $ssl_version=$1 if (/^VERSION=(.*)$/);
    $OPTIONS=$1 if (/^OPTIONS=(.*)$/);
    $INSTALLTOP=$1 if (/^INSTALLTOP=(.*$)/);
}
close(IN);
d10 1
a10 1
die "Makefile.ssl is not the toplevel Makefile!\n" if $ssl_version eq "";
d15 1
a15 2
	"VC-WIN32",   "Microsoft Visual C++ [4-6] - Windows NT or 9X",
	"VC-NT",   "Microsoft Visual C++ [4-6] - Windows NT ONLY",
d20 1
a20 3
	"Mingw32", "GNU C++ - Windows NT or 9x",
	"Mingw32-files", "Create files with DOS copy ...",
	"BC-NT",   "Borland C++ 4.5 - Windows NT",
a23 1
	"ultrix-mips","DEC mips ultrix",
a24 1
	"OS2-EMX", "EMX GCC OS/2",
d28 1
a28 1
$platform="";
d31 37
a67 1
	if (!&read_options && !defined($ops{$_}))
d69 8
a76 6
		print STDERR "unknown option - $_\n";
		print STDERR "usage: perl mk1mf.pl [options] [system]\n";
		print STDERR "\nwhere [system] can be one of the following\n";
		foreach $i (sort keys %ops)
		{ printf STDERR "\t%-10s\t%s\n",$i,$ops{$i}; }
		print STDERR <<"EOF";
d78 3
a80 4
	no-md2 no-md4 no-md5 no-sha no-mdc2	- Skip this digest
	no-ripemd
	no-rc2 no-rc4 no-rc5 no-idea no-des     - Skip this symetric cipher
	no-bf no-cast no-aes
a84 4
	no-krb5					- No KRB5
	no-ec					- No EC
	nasm 					- Use NASM for x86 asm
	gaswin					- Use GNU as with Mingw32
a88 1
        profile                                 - Profiling build
d90 1
d99 3
a101 1
		exit(1);
a102 5
	$platform=$_;
	}
foreach (grep(!/^$/, split(/ /, $OPTIONS)))
	{
	print STDERR "unknown option - $_\n" if !&read_options;
d107 1
a107 1
$no_ssl3=1 if ($no_md5 || $no_sha);
d110 1
a110 1
$no_ssl2=1 if ($no_md5);
a116 1
$mkdir="mkdir";
d119 1
a127 2
$NT=0;

d129 1
a129 1
if ($platform eq "VC-MSDOS")
d135 1
a135 1
elsif ($platform eq "VC-W31-16")
d141 1
a141 1
elsif (($platform eq "VC-W31-32") || ($platform eq "VC-WIN16"))
d147 1
a147 1
elsif (($platform eq "VC-WIN32") || ($platform eq "VC-NT"))
a148 1
	$NT = 1 if $platform eq "VC-NT";
d151 1
a151 9
elsif ($platform eq "Mingw32")
	{
	require 'Mingw32.pl';
	}
elsif ($platform eq "Mingw32-files")
	{
	require 'Mingw32f.pl';
	}
elsif ($platform eq "BC-NT")
d156 1
a156 1
elsif ($platform eq "BC-W31")
d162 1
a162 1
elsif ($platform eq "BC-Q16")
d167 1
a167 1
elsif ($platform eq "BC-MSDOS")
d173 1
a173 1
elsif ($platform eq "FreeBSD")
d178 1
a178 1
elsif ($platform eq "linux-elf")
a183 11
elsif ($platform eq "ultrix-mips")
	{
	require "unix.pl";
	require "ultrix.pl";
	$unix=1;
	}
elsif ($platform eq "OS2-EMX")
	{
	$wc=1;
	require 'OS2-EMX.pl';
	}
d198 25
a222 30
$cflags.=" -DOPENSSL_NO_IDEA" if $no_idea;
$cflags.=" -DOPENSSL_NO_AES"  if $no_aes;
$cflags.=" -DOPENSSL_NO_RC2"  if $no_rc2;
$cflags.=" -DOPENSSL_NO_RC4"  if $no_rc4;
$cflags.=" -DOPENSSL_NO_RC5"  if $no_rc5;
$cflags.=" -DOPENSSL_NO_MD2"  if $no_md2;
$cflags.=" -DOPENSSL_NO_MD4"  if $no_md4;
$cflags.=" -DOPENSSL_NO_MD5"  if $no_md5;
$cflags.=" -DOPENSSL_NO_SHA"  if $no_sha;
$cflags.=" -DOPENSSL_NO_SHA1" if $no_sha1;
$cflags.=" -DOPENSSL_NO_RIPEMD" if $no_rmd160;
$cflags.=" -DOPENSSL_NO_MDC2" if $no_mdc2;
$cflags.=" -DOPENSSL_NO_BF"  if $no_bf;
$cflags.=" -DOPENSSL_NO_CAST" if $no_cast;
$cflags.=" -DOPENSSL_NO_DES"  if $no_des;
$cflags.=" -DOPENSSL_NO_RSA"  if $no_rsa;
$cflags.=" -DOPENSSL_NO_DSA"  if $no_dsa;
$cflags.=" -DOPENSSL_NO_DH"   if $no_dh;
$cflags.=" -DOPENSSL_NO_SOCK" if $no_sock;
$cflags.=" -DOPENSSL_NO_SSL2" if $no_ssl2;
$cflags.=" -DOPENSSL_NO_SSL3" if $no_ssl3;
$cflags.=" -DOPENSSL_NO_ERR"  if $no_err;
$cflags.=" -DOPENSSL_NO_KRB5" if $no_krb5;
$cflags.=" -DOPENSSL_NO_EC"   if $no_ec;
#$cflags.=" -DRSAref"  if $rsaref ne "";

## if ($unix)
##	{ $cflags="$c_flags" if ($c_flags ne ""); }
##else
	{ $cflags="$c_flags$cflags" if ($c_flags ne ""); }
d226 4
a229 2
%shlib_ex_cflags=("SSL" => " -DOPENSSL_BUILD_SHLIBSSL",
		  "CRYPTO" => " -DOPENSSL_BUILD_SHLIBCRYPTO");
d233 1
a233 1
	$banner ="\t\@@echo Make sure you have run 'perl Configure $platform' in the\n";
d245 2
a246 2
# This makefile has been automatically generated from the OpenSSL distribution.
# This single makefile will build the complete OpenSSL distribution and
a260 1
PLATFORM=$platform
d272 1
a272 1
# The OpenSSL directory
d278 2
a279 4
BN_ASM_OBJ=$bn_asm_obj
BN_ASM_SRC=$bn_asm_src
BNCO_ASM_OBJ=$bnco_asm_obj
BNCO_ASM_SRC=$bnco_asm_src
d282 2
a304 1
INCO_D=$inc_dir${o}openssl
d309 1
a309 1
MKDIR=$mkdir
d318 1
a318 1
E_EXE=openssl
d321 1
a325 3
# Note: if you change these point to different directories then uncomment out
# the lines around the 'NB' comment below.
# 
d337 1
d340 2
a341 2
L_SSL=     \$(LIB_D)$o$plib\$(SSL)$libp
L_CRYPTO=  \$(LIB_D)$o$plib\$(CRYPTO)$libp
d344 1
d354 1
a354 1
LIBS_DEP=\$(O_CRYPTO) \$(O_SSL)
d360 1
a360 1
all: banner \$(TMP_D) \$(BIN_D) \$(TEST_D) \$(LIB_D) \$(INCO_D) headers lib exe
d367 6
a372 6
# NB: uncomment out these lines if BIN_D, TEST_D and LIB_D are different
#\$(BIN_D):
#	\$(MKDIR) \$(BIN_D)
#
#\$(TEST_D):
#	\$(MKDIR) \$(TEST_D)
a376 3
\$(INCO_D): \$(INC_D)
	\$(MKDIR) \$(INCO_D)

a380 1
	@@
a389 1
	\$(MKDIR) \$(INSTALLTOP)${o}include${o}openssl
d391 1
a391 1
	\$(CP) \$(INCO_D)${o}*.\[ch\] \$(INSTALLTOP)${o}include${o}openssl
a403 36
    
my $platform_cpp_symbol = "MK1MF_PLATFORM_$platform";
$platform_cpp_symbol =~ s/-/_/g;
if (open(IN,"crypto/buildinf.h"))
	{
	# Remove entry for this platform in existing file buildinf.h.

	my $old_buildinf_h = "";
	while (<IN>)
		{
		if (/^\#ifdef $platform_cpp_symbol$/)
			{
			while (<IN>) { last if (/^\#endif/); }
			}
		else
			{
			$old_buildinf_h .= $_;
			}
		}
	close(IN);

	open(OUT,">crypto/buildinf.h") || die "Can't open buildinf.h";
	print OUT $old_buildinf_h;
	close(OUT);
	}

open (OUT,">>crypto/buildinf.h") || die "Can't open buildinf.h";
printf OUT <<EOF;
#ifdef $platform_cpp_symbol
  /* auto-generated/updated by util/mk1mf.pl for crypto/cversion.c */
  #define CFLAGS "$cc $cflags"
  #define PLATFORM "$platform"
EOF
printf OUT "  #define DATE \"%s\"\n", scalar gmtime();
printf OUT "#endif\n";
close(OUT);
d471 2
a472 2
$defs.=&do_defs("EXHEADER",$exheader,"\$(INCO_D)",".h");
$rules.=&do_copy_rule("\$(INCO_D)",$exheader,".h");
d485 2
d493 1
a493 1
	if (($bn_asm_obj ne "") && ($_ eq "CRYPTO"))
d495 2
a496 2
		$lib_obj =~ s/\s\S*\/bn_asm\S*/ \$(BN_ASM_OBJ)/;
		$rules.=&do_asm_rule($bn_asm_obj,$bn_asm_src);
d498 2
a499 1
	if (($bnco_asm_obj ne "") && ($_ eq "CRYPTO"))
d501 2
a502 2
		$lib_obj .= "\$(BNCO_ASM_OBJ)";
		$rules.=&do_asm_rule($bnco_asm_obj,$bnco_asm_src);
d546 1
a546 1
	$lib=($slib)?" \$(SHLIB_CFLAGS)".$shlib_ex_cflags{$_}:" \$(LIB_CFLAGS)";
d559 2
a565 8

if ($platform eq "linux-elf") {
    print <<"EOF";
# Generate perlasm output files
%.cpp:
	(cd \$(\@@D)/..; PERL=perl make -f Makefile.ssl asm/\$(\@@F))
EOF
}
a578 1
	return("") if $no_aes  && $dir =~ /\/aes/;
d604 1
a604 2
	@@a=grep(!/^e_.*_ae$/,@@a) if $no_idea;
	@@a=grep(!/^e_.*_i$/,@@a) if $no_aes;
a616 1
	@@a=grep(!/(^md4)|(_md4$)/,@@a) if $no_md4;
a617 1
	@@a=grep(!/(rmd)|(ripemd)/,@@a) if $no_rmd160;
d634 1
a634 1
	@@a=grep(!/(^rsa$)|(^genrsa$)/,@@a) if $no_rsa;
d680 1
a680 2
		if ($_ =~ /BN_ASM/)	{ $t="$_ "; }
		elsif ($_ =~ /BNCO_ASM/){ $t="$_ "; }
d707 17
d749 2
a750 1
	$ex_flags.=" -DMK1MF_BUILD -D$platform_cpp_symbol" if ($source =~ /cversion/);
a793 70
# do a rule for each file that says 'copy' to new direcory on change
sub do_copy_rule
	{
	local($to,$files,$p)=@@_;
	local($ret,$_,$n,$pp);
	
	$files =~ s/\//$o/g if $o ne '/';
	foreach (split(/\s+/,$files))
		{
		$n=&bname($_);
		if ($n =~ /bss_file/)
			{ $pp=".c"; }
		else	{ $pp=$p; }
		$ret.="$to${o}$n$pp: \$(SRC_D)$o$_$pp\n\t\$(CP) \$(SRC_D)$o$_$pp $to${o}$n$pp\n\n";
		}
	return($ret);
	}

sub read_options
	{
	if    (/^no-rc2$/)	{ $no_rc2=1; }
	elsif (/^no-rc4$/)	{ $no_rc4=1; }
	elsif (/^no-rc5$/)	{ $no_rc5=1; }
	elsif (/^no-idea$/)	{ $no_idea=1; }
	elsif (/^no-aes$/)	{ $no_aes=1; }
	elsif (/^no-des$/)	{ $no_des=1; }
	elsif (/^no-bf$/)	{ $no_bf=1; }
	elsif (/^no-cast$/)	{ $no_cast=1; }
	elsif (/^no-md2$/)  	{ $no_md2=1; }
	elsif (/^no-md4$/)	{ $no_md4=1; }
	elsif (/^no-md5$/)	{ $no_md5=1; }
	elsif (/^no-sha$/)	{ $no_sha=1; }
	elsif (/^no-sha1$/)	{ $no_sha1=1; }
	elsif (/^no-ripemd$/)	{ $no_ripemd=1; }
	elsif (/^no-mdc2$/)	{ $no_mdc2=1; }
	elsif (/^no-patents$/)	{ $no_rc2=$no_rc4=$no_rc5=$no_idea=$no_rsa=1; }
	elsif (/^no-rsa$/)	{ $no_rsa=1; }
	elsif (/^no-dsa$/)	{ $no_dsa=1; }
	elsif (/^no-dh$/)	{ $no_dh=1; }
	elsif (/^no-hmac$/)	{ $no_hmac=1; }
	elsif (/^no-aes$/)	{ $no_aes=1; }
	elsif (/^no-asm$/)	{ $no_asm=1; }
	elsif (/^nasm$/)	{ $nasm=1; }
	elsif (/^gaswin$/)	{ $gaswin=1; }
	elsif (/^no-ssl2$/)	{ $no_ssl2=1; }
	elsif (/^no-ssl3$/)	{ $no_ssl3=1; }
	elsif (/^no-err$/)	{ $no_err=1; }
	elsif (/^no-sock$/)	{ $no_sock=1; }
	elsif (/^no-krb5$/)	{ $no_krb5=1; }
	elsif (/^no-ec$/)	{ $no_ec=1; }

	elsif (/^just-ssl$/)	{ $no_rc2=$no_idea=$no_des=$no_bf=$no_cast=1;
				  $no_md2=$no_sha=$no_mdc2=$no_dsa=$no_dh=1;
				  $no_ssl2=$no_err=$no_rmd160=$no_rc5=1;
				  $no_aes=1; }

	elsif (/^rsaref$/)	{ }
	elsif (/^gcc$/)		{ $gcc=1; }
	elsif (/^debug$/)	{ $debug=1; }
	elsif (/^profile$/)	{ $profile=1; }
	elsif (/^shlib$/)	{ $shlib=1; }
	elsif (/^dll$/)		{ $shlib=1; }
	elsif (/^shared$/)	{ } # We just need to ignore it for now...
	elsif (/^([^=]*)=(.*)$/){ $VARS{$1}=$2; }
	elsif (/^-[lL].*$/)	{ $l_flags.="$_ "; }
	elsif ((!/^-help/) && (!/^-h/) && (!/^-\?/) && /^-.*$/)
		{ $c_flags.="$_ "; }
	else { return(0); }
	return(1);
	}
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d103 1
a103 1
$mkdir="-mkdir";
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@a26 1
	"VC-CE",   "Microsoft eMbedded Visual C++ 3.0 - Windows CE ONLY",
a65 2
	no-engine				- No engine
	no-hw					- No hw
a139 4
elsif ($platform eq "VC-CE")
	{
	require 'VC-CE.pl';
	}
d216 1
a216 1
$cflags.=" -DOPENSSL_NO_RIPEMD" if $no_ripemd;
a229 2
$cflags.=" -DOPENSSL_NO_ENGINE"   if $no_engine;
$cflags.=" -DOPENSSL_NO_HW"   if $no_hw;
a268 11
EOF

if ($platform eq "VC-CE")
	{
	$defs.= <<"EOF";
!INCLUDE <\$(WCECOMPAT)/wcedefs.mak>

EOF
	}

$defs.= <<"EOF";
a634 2
	return("") if $no_engine && $dir =~ /\/engine/;
	return("") if $no_hw   && $dir =~ /\/hw/;
a643 1
	return("") if $no_ec   && $dir =~ /\/ec/;
d678 1
a678 1
	@@a=grep(!/(rmd)|(ripemd)/,@@a) if $no_ripemd;
a694 2
	@@a=grep(!/^engine$/,@@a) if $no_engine;
	@@a=grep(!/^hw$/,@@a) if $no_hw;
a887 2
	elsif (/^no-engine$/)	{ $no_engine=1; }
	elsif (/^no-hw$/)	{ $no_hw=1; }
d891 1
a891 1
				  $no_ssl2=$no_err=$no_ripemd=$no_rc5=1;
@


1.1.1.5
log
@import openssl-0.9.7d
@
text
@a279 2
$defs .= $preamble if defined $preamble;

@


1.1.1.6
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d13 1
a13 1
open(IN,"<Makefile") || die "unable to open Makefile!\n";
d21 1
a21 1
die "Makefile is not the toplevel Makefile!\n" if $ssl_version eq "";
d225 1
a225 1
$cflags.=" -DOPENSSL_NO_BF"   if $no_bf;
a238 1
$cflags.=" -DOPENSSL_FIPS"    if $fips;
d634 2
a635 8
if ($fips)
	{
	$rules.=&do_link_rule("\$(BIN_D)$o\$(E_EXE)$exep","\$(E_OBJ)","\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)","\$(BIN_D)$o.sha1","\$(BIN_D)$o\$(E_EXE)$exep");
	}
else
	{
	$rules.=&do_link_rule("\$(BIN_D)$o\$(E_EXE)$exep","\$(E_OBJ)","\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)");
	}
d642 1
a642 1
	(cd \$(\@@D)/..; PERL=perl make -f Makefile asm/\$(\@@F))
a923 1
	elsif (/^fips$/)	{ $fips=1; }
@


1.1.1.7
log
@import of openssl-0.9.7j
@
text
@a12 14
local $zlib_opt = 0;	# 0 = no zlib, 1 = static, 2 = dynamic
local $zlib_lib = "";

my $fips_canister_path = "";
my $fips_premain_dso_exe_path = "";
my $fips_premain_c_path = "";
my $fips_sha1_exe_path = "";

my $fipslibdir = "";
my $baseaddr = "";

my $ex_l_libs = "";


a26 1
	"VC-WIN32-GMAKE", "Microsoft Visual C++ [4-6] - Windows NT or 9X, GNU make",
a45 1
my $xcflags="";
a106 3
$mkcanister="ld -r -o";

$ex_build_targets = "";
a108 1
$cryptocompat = "";
a142 4
elsif ($platform eq "VC-WIN32-GMAKE")
	{
	require 'VC-32-GMAKE.pl';
	}
a212 2
$cflags= "$xcflags$cflags" if $xcflags ne "";

a241 3
$cflags.= " -DZLIB" if $zlib_opt;
$cflags.= " -DZLIB_SHARED" if $zlib_opt == 2;

a248 1

a264 129
#############################################
# We parse in input file and 'store' info for later printing.
open(IN,"<$infile") || die "unable to open $infile:$!\n";
$_=<IN>;
for (;;)
	{
	chop;

	($key,$val)=/^([^=]+)=(.*)/;
	if ($key eq "RELATIVE_DIRECTORY")
		{
		if ($lib ne "")
			{
 			if ($fips && $dir =~ /^fips/)
 				{
 				$uc = "FIPS";
 				}
 			else
 				{
 				$uc=$lib;
 				$uc =~ s/^lib(.*)\.a/$1/;
 				$uc =~ tr/a-z/A-Z/;
				}
			if (($uc ne "FIPS") || $fips_canister_build)
				{
				$lib_nam{$uc}=$uc;
				$lib_obj{$uc}.=$libobj." ";
				}
			}
		last if ($val eq "FINISHED");
		$lib="";
		$libobj="";
		$dir=$val;
		}

	if ($key eq "KRB5_INCLUDES")
		{ $cflags .= " $val";}

	if ($key eq "ZLIB_INCLUDE")
		{ $cflags .= " $val" if $val ne "";}

	if ($key eq "LIBZLIB")
		{ $zlib_lib = "$val" if $val ne "";}

	if ($key eq "LIBKRB5")
		{ $ex_libs .= " $val" if $val ne "";}

	if ($key eq "TEST")
		{ $test.=&var_add($dir,$val); }

	if (($key eq "PROGS") || ($key eq "E_OBJ"))
		{ $e_exe.=&var_add($dir,$val); }

	if ($key eq "LIB")
		{
		$lib=$val;
		$lib =~ s/^.*\/([^\/]+)$/$1/;
		}

	if ($key eq "EXHEADER")
		{ $exheader.=&var_add($dir,$val); }

	if ($key eq "HEADER")
		{ $header.=&var_add($dir,$val); }

	if ($key eq "LIBOBJ")
		{ $libobj=&var_add($dir,$val); }

	if ($key eq "FIPSLIBDIR")
		{ $fipslibdir=$val;}

	if ($key eq "BASEADDR")
		{ $baseaddr=$val;}

	if (!($_=<IN>))
		{ $_="RELATIVE_DIRECTORY=FINISHED\n"; }
	}
close(IN);

if ($fips_canister_path eq "")
	{
	$fips_canister_path = "\$(FIPSLIB_D)${o}fipscanister.o";
	}

if ($fips_premain_c_path eq "")
	{
	$fips_premain_c_path = "\$(FIPSLIB_D)${o}fips_premain.c";
	}

if ($fips)
	{
	if ($fips_sha1_exe_path eq "")
		{
		$fips_sha1_exe_path =
			"\$(BIN_D)${o}fips_standalone_sha1$exep";
		}
	}
	else
	{
	$fips_sha1_exe_path = "";
	}

if ($fips_premain_dso_exe_path eq "")
	{
	$fips_premain_dso_exe_path = "\$(BIN_D)${o}fips_premain_dso$exep";
	}

#	$ex_build_targets .= "\$(BIN_D)${o}\$(E_PREMAIN_DSO)$exep" if ($fips);

if ($fips)
	{
	if (!$shlib)
		{
		$ex_build_targets .= " \$(LIB_D)$o$crypto_compat \$(PREMAIN_DSO_EXE)";
		$ex_l_libs .= " \$(O_FIPSCANISTER)";
		}
	if ($fipslibdir eq "")
		{
		open (IN, "util/fipslib_path.txt") || fipslib_error();
		$fipslibdir = <IN>;
		chomp $fipslibdir;
		close IN;
		}
	fips_check_files($fipslibdir,
			"fipscanister.o", "fipscanister.o.sha1",
			"fips_premain.c", "fips_premain.c.sha1");
	}
	

a288 1
	$ex_libs .= " $zlib_lib" if $zlib_opt == 1;
a310 2
PERL=perl
FIPSLINK=\$(PERL) util${o}fipslink.pl
a341 3
# Directory containing FIPS module


a348 12
MKCANISTER=$mkcanister

# FIPS validated module and support file locations

E_PREMAIN_DSO=fips_premain_dso

FIPSLIB_D=$fipslibdir
BASEADDR=$baseaddr
FIPS_PREMAIN_SRC=$fips_premain_c_path
O_FIPSCANISTER=$fips_canister_path
FIPS_SHA1_EXE=$fips_sha1_exe_path
PREMAIN_DSO_EXE=$fips_premain_dso_exe_path
d380 1
a380 1
L_LIBS= \$(L_SSL) \$(L_CRYPTO) $ex_l_libs
d390 1
a390 1
LIBS_DEP=\$(O_CRYPTO) \$(O_SSL) $ex_libs_dep
d396 1
a396 1
all: banner \$(TMP_D) \$(BIN_D) \$(TEST_D) \$(LIB_D) \$(INCO_D) headers \$(FIPS_SHA1_EXE) lib exe $ex_build_targets
d482 51
a556 23
# Special case rules for fips_start and fips_end fips_premain_dso

if ($fips)
	{
	if ($fips_canister_build)
		{
		$rules.=&cc_compile_target("\$(OBJ_D)${o}fips_start$obj",
			"fips-1.0${o}fips_canister.c",
			"-DFIPS_START \$(SHLIB_CFLAGS)");
		$rules.=&cc_compile_target("\$(OBJ_D)${o}fips_end$obj",
			"fips-1.0${o}fips_canister.c", "\$(SHLIB_CFLAGS)");
		}
	$rules.=&cc_compile_target("\$(OBJ_D)${o}fips_standalone_sha1$obj",
		"fips-1.0${o}sha${o}fips_standalone_sha1.c",
		"\$(SHLIB_CFLAGS)");
	$rules.=&cc_compile_target("\$(OBJ_D)${o}fips_sha1dgst$obj",
		"fips-1.0${o}sha${o}fips_sha1dgst.c",
		"\$(SHLIB_CFLAGS)") unless $fips_canister_build;
	$rules.=&cc_compile_target("\$(OBJ_D)${o}\$(E_PREMAIN_DSO)$obj",
		"fips-1.0${o}fips_premain.c",
		"-DFINGERPRINT_PREMAIN_DSO_LOAD \$(SHLIB_CFLAGS)");
	}

d633 1
a633 1

d637 1
a637 14
	if ($shlib)
		{
		$rules.= &do_lib_rule("\$(CRYPTOOBJ) \$(O_FIPSCANISTER)",
			"\$(O_CRYPTO)",
			"$crypto",
			$shlib, "\$(SO_CRYPTO)", "\$(BASEADDR)");
		}
	else
		{
		$rules.= &do_lib_rule("\$(CRYPTOOBJ)",
			"\$(O_CRYPTO)",$crypto,$shlib,"\$(SO_CRYPTO)", "");
		$rules.= &do_lib_rule("\$(CRYPTOOBJ) \$(O_FIPSCANISTER)",
			"\$(LIB_D)$o$crypto_compat",$crypto,$shlib,"\$(SO_CRYPTO)", "");
		}
d639 1
a639 8
	else
	{
	$rules.= &do_lib_rule("\$(CRYPTOOBJ)","\$(O_CRYPTO)",$crypto,$shlib,
							"\$(SO_CRYPTO)");
	}


if ($fips)
d641 1
a641 4
	$rules.= &do_rlink_rule("\$(O_FIPSCANISTER)", "\$(OBJ_D)${o}fips_start$obj \$(FIPSOBJ) \$(OBJ_D)${o}fips_end$obj", "\$(FIPSLIB_D)${o}fips_standalone_sha1$exep", "") if $fips_canister_build;
	$rules.=&do_link_rule("\$(PREMAIN_DSO_EXE)","\$(OBJ_D)${o}\$(E_PREMAIN_DSO)$obj \$(CRYPTOOBJ) \$(O_FIPSCANISTER)","","\$(EX_LIBS)", 1);
	
	$rules.=&do_link_rule("\$(FIPS_SHA1_EXE)","\$(OBJ_D)${o}fips_standalone_sha1$obj \$(OBJ_D)${o}fips_sha1dgst$obj","","", 1);
a642 3

	$rules.=&do_link_rule("\$(BIN_D)$o\$(E_EXE)$exep","\$(E_OBJ)","\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)",0);

a937 18
 	elsif (/^zlib$/) { $zlib_opt = 1 if $zlib_opt == 0 }
	elsif (/^zlib-dynamic$/){ $zlib_opt = 2; }
	elsif (/^--with-krb5-flavor=(.*)$/)
		{
		my $krb5_flavor = $1;
		if ($krb5_flavor =~ /^force-[Hh]eimdal$/)
			{
			$xcflags="-DKRB5_HEIMDAL $xcflags";
			}
		elsif ($krb5_flavor =~ /^MIT/i)
			{
			$xcflags="-DKRB5_MIT $xcflags";
		 	if ($krb5_flavor =~ /^MIT[._-]*1[._-]*[01]/i)
				{
				$xcflags="-DKRB5_MIT_OLD11 $xcflags"
				}
			}
		}
a943 28
	}

sub fipslib_error
	{
	print STDERR "***FIPS module directory sanity check failed***\n";
	print STDERR "FIPS module build failed, or was deleted\n";
	print STDERR "Please rebuild FIPS module.\n"; 
	exit 1;
	}

sub fips_check_files
	{
	my $dir = shift @@_;
	my $ret = 1;
	if (!-d $dir)
		{
		print STDERR "FIPS module directory $dir does not exist\n";
		fipslib_error();
		}
	foreach (@@_)
		{
		if (!-f "$dir${o}$_")
			{
			print STDERR "FIPS module file $_ does not exist!\n";
			$ret = 0;
			}
		}
	fipslib_error() if ($ret == 0);
@


1.1.1.8
log
@import of OpenSSL 0.9.8h
@
text
@a12 2
my $no_static_engine = 0;
my $engines = "";
d16 10
d41 1
a41 2
	"VC-WIN64I",  "Microsoft C/C++ - Win64/IA-64",
	"VC-WIN64A",  "Microsoft C/C++ - Win64/x64",
d44 4
d51 2
a56 4
	"netware-clib", "CodeWarrior for NetWare - CLib - with WinSock Sockets",
	"netware-clib-bsdsock", "CodeWarrior for NetWare - CLib - with BSD Sockets",
	"netware-libc", "CodeWarrior for NetWare - LibC - with WinSock Sockets",
	"netware-libc-bsdsock", "CodeWarrior for NetWare - LibC - with BSD Sockets",
d76 1
a76 1
	no-bf no-cast no-aes no-camellia no-seed
a82 2
	no-ecdsa				- No ECDSA
	no-ecdh					- No ECDH
a85 2
	nw-nasm					- Use NASM x86 asm for NetWare
	nw-mwasm				- Use Metrowerks x86 asm for NetWare
a109 2
$no_static_engine = 0 if (!$shlib);

d122 4
a125 2
$perl="perl" unless defined $perl;
$mkdir="-mkdir" unless defined $mkdir;
d128 1
a136 1

d140 7
a146 1
if (($platform =~ /VC-(.+)/))
d148 13
a160 2
	$FLAVOR=$1;
	$NT = 1 if $1 eq "NT";
d163 8
d184 17
a222 7
elsif (($platform eq "netware-clib") || ($platform eq "netware-libc") ||
       ($platform eq "netware-clib-bsdsock") || ($platform eq "netware-libc-bsdsock"))
	{
	$LIBC=1 if $platform eq "netware-libc" || $platform eq "netware-libc-bsdsock";
	$BSDSOCK=1 if ($platform eq "netware-libc-bsdsock") || ($platform eq "netware-clib-bsdsock");
	require 'netware.pl';
	}
a240 2
$cflags.=" -DOPENSSL_NO_CAMELLIA"  if $no_camellia;
$cflags.=" -DOPENSSL_NO_SEED" if $no_seed;
d251 1
a251 1
$cflags.=" -DOPENSSL_NO_BF"  if $no_bf;
a259 2
$cflags.=" -DOPENSSL_NO_TLSEXT" if $no_tlsext;
$cflags.=" -DOPENSSL_NO_CMS" if $no_cms;
a262 2
$cflags.=" -DOPENSSL_NO_ECDSA" if $no_ecdsa;
$cflags.=" -DOPENSSL_NO_ECDH" if $no_ecdh;
d265 2
a270 11
if ($no_static_engine)
	{
	$cflags .= " -DOPENSSL_NO_STATIC_ENGINE";
	}
else
	{
	$cflags .= " -DOPENSSL_NO_DYNAMIC_ENGINE";
	}

#$cflags.=" -DRSAref"  if $rsaref ne "";

d308 15
a322 5
			$uc=$lib;
			$uc =~ s/^lib(.*)\.a/$1/;
			$uc =~ tr/a-z/A-Z/;
			$lib_nam{$uc}=$uc;
			$lib_obj{$uc}.=$libobj." ";
d343 1
a343 1
		{ $test.=&var_add($dir,$val, 0); }
d346 1
a346 1
		{ $e_exe.=&var_add($dir,$val, 0); }
d355 1
a355 1
		{ $exheader.=&var_add($dir,$val, 1); }
d358 1
a358 1
		{ $header.=&var_add($dir,$val, 1); }
d360 8
a367 4
	if ($key eq "LIBOBJ" && ($dir ne "engines" || !$no_static_engine))
		{ $libobj=&var_add($dir,$val, 0); }
	if ($key eq "LIBNAMES" && $dir eq "engines" && $no_static_engine)
 		{ $engines.=$val }
d374 11
a384 1
if ($shlib)
d386 1
a386 7
	$extra_install= <<"EOF";
	\$(CP) \"\$(O_SSL)\" \"\$(INSTALLTOP)${o}bin\"
	\$(CP) \"\$(O_CRYPTO)\" \"\$(INSTALLTOP)${o}bin\"
	\$(CP) \"\$(L_SSL)\" \"\$(INSTALLTOP)${o}lib\"
	\$(CP) \"\$(L_CRYPTO)\" \"\$(INSTALLTOP)${o}lib\"
EOF
	if ($no_static_engine)
d388 2
a389 4
		$extra_install .= <<"EOF"
	\$(MKDIR) \"\$(INSTALLTOP)${o}lib${o}engines\"
	\$(CP) \"\$(E_SHLIB)\" \"\$(INSTALLTOP)${o}lib${o}engines\"
EOF
d392 13
a404 1
else
d406 15
a420 5
	$extra_install= <<"EOF";
	\$(CP) \"\$(O_SSL)\" \"\$(INSTALLTOP)${o}lib\"
	\$(CP) \"\$(O_CRYPTO)\" \"\$(INSTALLTOP)${o}lib\"
EOF
	$ex_libs .= " $zlib_lib" if $zlib_opt == 1;
d422 1
d442 9
d471 2
a473 1
RSC=$rsc
a474 2
AES_ASM_OBJ=$aes_asm_obj
AES_ASM_SRC=$aes_asm_src
a494 2
CPUID_ASM_OBJ=$cpuid_asm_obj
CPUID_ASM_SRC=$cpuid_asm_src
d504 3
a506 1
PERL=$perl
d514 12
a537 1
# ENG_D  - dynamic engine output directory
a543 1
ENG_D=\$(OUT_D)
d557 1
a557 1
L_LIBS= \$(L_SSL) \$(L_CRYPTO)
d567 1
a567 1
LIBS_DEP=\$(O_CRYPTO) \$(O_SSL)
d573 1
a573 1
all: banner \$(TMP_D) \$(BIN_D) \$(TEST_D) \$(LIB_D) \$(INCO_D) headers lib exe
d579 1
a579 1
	\$(MKDIR) \"\$(TMP_D)\"
d588 1
a588 1
	\$(MKDIR) \"\$(LIB_D)\"
d591 1
a591 1
	\$(MKDIR) \"\$(INCO_D)\"
d594 1
a594 1
	\$(MKDIR) \"\$(INC_D)\"
d599 1
a599 1
lib: \$(LIBS_DEP) \$(E_SHLIB)
d603 10
a612 15
install: all
	\$(MKDIR) \"\$(INSTALLTOP)\"
	\$(MKDIR) \"\$(INSTALLTOP)${o}bin\"
	\$(MKDIR) \"\$(INSTALLTOP)${o}include\"
	\$(MKDIR) \"\$(INSTALLTOP)${o}include${o}openssl\"
	\$(MKDIR) \"\$(INSTALLTOP)${o}lib\"
	\$(CP) \"\$(INCO_D)${o}*.\[ch\]\" \"\$(INSTALLTOP)${o}include${o}openssl\"
	\$(CP) \"\$(BIN_D)$o\$(E_EXE)$exep\" \"\$(INSTALLTOP)${o}bin\"
	\$(CP) \"apps${o}openssl.cnf\" \"\$(INSTALLTOP)\"
$extra_install


test: \$(T_EXE)
	cd \$(BIN_D)
	..${o}ms${o}test
d671 2
a672 2
$defs.=&do_defs("HEADER",$header,"\$(INCL_D)","");
$rules.=&do_copy_rule("\$(INCL_D)",$header,"");
d674 2
a675 2
$defs.=&do_defs("EXHEADER",$exheader,"\$(INCO_D)","");
$rules.=&do_copy_rule("\$(INCO_D)",$exheader,"");
d683 23
d716 1
a716 6
	if (($aes_asm_obj ne "") && ($_ eq "CRYPTO"))
		{
		$lib_obj =~ s/\s(\S*\/aes_core\S*)/ \$(AES_ASM_OBJ)/;
		$lib_obj =~ s/\s\S*\/aes_cbc\S*//;
		$rules.=&do_asm_rule($aes_asm_obj,$aes_asm_src);
		}
a767 5
	if (($cpuid_asm_obj ne "") && ($_ eq "CRYPTO"))
		{
		$lib_obj =~ s/\s(\S*\/cversion\S*)/ $1 \$(CPUID_ASM_OBJ)/;
		$rules.=&do_asm_rule($cpuid_asm_obj,$cpuid_asm_src);
		}
a772 12
# hack to add version info on MSVC
if (($platform eq "VC-WIN32") || ($platform eq "VC-NT")) {
    $rules.= <<"EOF";
\$(OBJ_D)\\\$(CRYPTO).res: ms\\version32.rc
	\$(RSC) /fo"\$(OBJ_D)\\\$(CRYPTO).res" /d CRYPTO ms\\version32.rc

\$(OBJ_D)\\\$(SSL).res: ms\\version32.rc
	\$(RSC) /fo"\$(OBJ_D)\\\$(SSL).res" /d SSL ms\\version32.rc

EOF
}

d781 2
a782 1
$defs.=&do_defs("E_SHLIB",$engines,"\$(ENG_D)",$shlibp);
d784 18
a801 1
foreach (split(/\s+/,$engines))
d803 2
a804 2
	$rules.=&do_compile_rule("\$(OBJ_D)","engines${o}e_$_",$lib);
	$rules.= &do_lib_rule("\$(OBJ_D)${o}e_${_}.obj","\$(ENG_D)$o$_$shlibp","",$shlib,"");
d808 7
d816 1
a816 4
$rules.= &do_lib_rule("\$(SSLOBJ)","\$(O_SSL)",$ssl,$shlib,"\$(SO_SSL)");
$rules.= &do_lib_rule("\$(CRYPTOOBJ)","\$(O_CRYPTO)",$crypto,$shlib,"\$(SO_CRYPTO)");

$rules.=&do_link_rule("\$(BIN_D)$o\$(E_EXE)$exep","\$(E_OBJ)","\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)");
d836 1
a836 1
	local($dir,$val,$keepext)=@@_;
a842 2
	return("") if $no_camellia  && $dir =~ /\/camellia/;
	return("") if $no_seed && $dir =~ /\/seed/;
a850 1
	return("") if $no_cms  && $dir =~ /\/cms/;
d865 1
a865 1
	grep(s/\.[och]$//,@@a) unless $keepext;
a875 2
	@@a=grep(!/^e_camellia$/,@@a) if $no_camellia;
	@@a=grep(!/^e_seed$/,@@a) if $no_seed;
a958 1
		elsif ($_ =~ /AES_ASM/){ $t="$_ "; }
a959 1
		elsif ($_ =~ /CPUID_ASM/){ $t="$_ "; }
d965 1
a965 9
	# hack to add version info on MSVC
	if ($shlib && (($platform eq "VC-WIN32") || ($platform eq "VC-NT")))
		{
		if ($var eq "CRYPTOOBJ")
			{ $ret.="\$(OBJ_D)\\\$(CRYPTO).res "; }
		elsif ($var eq "SSLOBJ")
			{ $ret.="\$(OBJ_D)\\\$(SSL).res "; }
		}
	chomp($ret);
d1060 1
a1060 1
		$ret.="$to${o}$n$pp: \$(SRC_D)$o$_$pp\n\t\$(CP) \"\$(SRC_D)$o$_$pp\" \"$to${o}$n$pp\"\n\n";
d1067 48
a1114 105
	# Many options are handled in a similar way. In particular
	# no-xxx sets zero or more scalars to 1.
	# Process these using a hash containing the option name and
	# reference to the scalars to set.

	my %valid_options = (
		"no-rc2" => \$no_rc2,
		"no-rc4" => \$no_rc4,
		"no-rc5" => \$no_rc5,
		"no-idea" => \$no_idea,
		"no-aes" => \$no_aes,
		"no-camellia" => \$no_camellia,
		"no-seed" => \$no_seed,
		"no-des" => \$no_des,
		"no-bf" => \$no_bf,
		"no-cast" => \$no_cast,
		"no-md2" => \$no_md2,
		"no-md4" => \$no_md4,
		"no-md5" => \$no_md5,
		"no-sha" => \$no_sha,
		"no-sha1" => \$no_sha1,
		"no-ripemd" => \$no_ripemd,
		"no-mdc2" => \$no_mdc2,
		"no-patents" => 
			[\$no_rc2, \$no_rc4, \$no_rc5, \$no_idea, \$no_rsa],
		"no-rsa" => \$no_rsa,
		"no-dsa" => \$no_dsa,
		"no-dh" => \$no_dh,
		"no-hmac" => \$no_hmac,
		"no-asm" => \$no_asm,
		"nasm" => \$nasm,
		"nw-nasm" => \$nw_nasm,
		"nw-mwasm" => \$nw_mwasm,
		"gaswin" => \$gaswin,
		"no-ssl2" => \$no_ssl2,
		"no-ssl3" => \$no_ssl3,
		"no-tlsext" => \$no_tlsext,
		"no-cms" => \$no_cms,
		"no-err" => \$no_err,
		"no-sock" => \$no_sock,
		"no-krb5" => \$no_krb5,
		"no-ec" => \$no_ec,
		"no-ecdsa" => \$no_ecdsa,
		"no-ecdh" => \$no_ecdh,
		"no-engine" => \$no_engine,
		"no-hw" => \$no_hw,
		"just-ssl" =>
			[\$no_rc2, \$no_idea, \$no_des, \$no_bf, \$no_cast,
			  \$no_md2, \$no_sha, \$no_mdc2, \$no_dsa, \$no_dh,
			  \$no_ssl2, \$no_err, \$no_ripemd, \$no_rc5,
			  \$no_aes, \$no_camellia, \$no_seed],
		"rsaref" => 0,
		"gcc" => \$gcc,
		"debug" => \$debug,
		"profile" => \$profile,
		"shlib" => \$shlib,
		"dll" => \$shlib,
		"shared" => 0,
		"no-gmp" => 0,
		"no-rfc3779" => 0,
		"no-montasm" => 0,
		"no-shared" => 0,
		"no-zlib" => 0,
		"no-zlib-dynamic" => 0,
		);

	if (exists $valid_options{$_})
		{
		my $r = $valid_options{$_};
		if ( ref $r eq "SCALAR")
			{ $$r = 1;}
		elsif ( ref $r eq "ARRAY")
			{
			my $r2;
			foreach $r2 (@@$r)
				{
				$$r2 = 1;
				}
			}
		}
	elsif (/^no-comp$/) { $xcflags = "-DOPENSSL_NO_COMP $xcflags"; }
	elsif (/^enable-zlib$/) { $zlib_opt = 1 if $zlib_opt == 0 }
	elsif (/^enable-zlib-dynamic$/)
		{
		$zlib_opt = 2;
		}
	elsif (/^no-static-engine/)
		{
		$no_static_engine = 1;
		}
	elsif (/^enable-static-engine/)
		{
		$no_static_engine = 0;
		}
	# There are also enable-xxx options which correspond to
	# the no-xxx. Since the scalars are enabled by default
	# these can be ignored.
	elsif (/^enable-/)
		{
		my $t = $_;
		$t =~ s/^enable/no/;
		if (exists $valid_options{$t})
			{return 1;}
		return 0;
		}
d1137 28
@


1.1.1.9
log
@import openssl-0.9.8j
@
text
@a17 12
local $fips_canister_path = "";
my $fips_premain_dso_exe_path = "";
my $fips_premain_c_path = "";
my $fips_sha1_exe_path = "";

local $fipscanisterbuild = 0;
local $fipsdso = 0;

my $fipslibdir = "";
my $baseaddr = "";

my $ex_l_libs = "";
a223 2
$cflags.=" -DOPENSSL_NO_JPAKE" if $no_jpake;
$cflags.=" -DOPENSSL_NO_CAPIENG" if $no_capieng;
d231 1
a231 1
$cflags.=" -DOPENSSL_FIPS"    if $fips;
d253 1
d255 1
a255 2
		  "CRYPTO" => " -DOPENSSL_BUILD_SHLIBCRYPTO",
		  "FIPS" => " -DOPENSSL_BUILD_SHLIBCRYPTO");
d283 5
a287 15
 			if ($fips && $dir =~ /^fips/)
 				{
 				$uc = "FIPS";
 				}
 			else
 				{
 				$uc=$lib;
 				$uc =~ s/^lib(.*)\.a/$1/;
 				$uc =~ tr/a-z/A-Z/;
				}
			if (($uc ne "FIPS") || $fipscanisterbuild)
				{
				$lib_nam{$uc}=$uc;
				$lib_obj{$uc}.=$libobj." ";
				}
a329 15
	if ($key eq "FIPS_EX_OBJ")
		{ 
		$fips_ex_obj=&var_add("crypto",$val,0);
		}

	if ($key eq "FIPSLIBDIR")
		{
		$fipslibdir=$val;
		$fipslibdir =~ s/\/$//;
		$fipslibdir =~ s/\//$o/g;
		}

	if ($key eq "BASEADDR")
		{ $baseaddr=$val;}

a334 104
if ($fips)
	{
	 
	foreach (split " ", $fips_ex_obj)
		{
		$fips_exclude_obj{$1} = 1 if (/\/([^\/]*)$/);
		}

	$fips_exclude_obj{"cpu_win32"} = 1;
	$fips_exclude_obj{"bn_asm"} = 1;
	$fips_exclude_obj{"des_enc"} = 1;
	$fips_exclude_obj{"fcrypt_b"} = 1;
	$fips_exclude_obj{"aes_core"} = 1;
	$fips_exclude_obj{"aes_cbc"} = 1;

	my @@ltmp = split " ", $lib_obj{"CRYPTO"};


	$lib_obj{"CRYPTO"} = "";

	foreach(@@ltmp)
		{
		if (/\/([^\/]*)$/ && exists $fips_exclude_obj{$1})
			{
			if ($fipscanisterbuild)
				{
				$lib_obj{"FIPS"} .= "$_ ";
				}
			}
		else
			{
			$lib_obj{"CRYPTO"} .= "$_ ";
			}
		}

	}

if ($fipscanisterbuild)
	{
	$fips_canister_path = "\$(LIB_D)${o}fipscanister.lib" if $fips_canister_path eq "";
	$fips_premain_c_path = "\$(LIB_D)${o}fips_premain.c";
	}
else
	{
	if ($fips_canister_path eq "")
		{
		$fips_canister_path = "\$(FIPSLIB_D)${o}fipscanister.lib";
		}

	if ($fips_premain_c_path eq "")
		{
		$fips_premain_c_path = "\$(FIPSLIB_D)${o}fips_premain.c";
		}
	}

if ($fips)
	{
	if ($fips_sha1_exe_path eq "")
		{
		$fips_sha1_exe_path =
			"\$(BIN_D)${o}fips_standalone_sha1$exep";
		}
	}
	else
	{
	$fips_sha1_exe_path = "";
	}

if ($fips_premain_dso_exe_path eq "")
	{
	$fips_premain_dso_exe_path = "\$(BIN_D)${o}fips_premain_dso$exep";
	}

#	$ex_build_targets .= "\$(BIN_D)${o}\$(E_PREMAIN_DSO)$exep" if ($fips);

#$ex_l_libs .= " \$(L_FIPS)" if $fipsdso;

if ($fips)
	{
	if (!$shlib)
		{
		$ex_build_targets .= " \$(LIB_D)$o$crypto_compat \$(PREMAIN_DSO_EXE)";
		$ex_l_libs .= " \$(O_FIPSCANISTER)";
		$ex_libs_dep .= " \$(O_FIPSCANISTER)" if $fipscanisterbuild;
		}
	if ($fipscanisterbuild)
		{
		$fipslibdir = "\$(LIB_D)";
		}
	else
		{
		if ($fipslibdir eq "")
			{
			open (IN, "util/fipslib_path.txt") || fipslib_error();
			$fipslibdir = <IN>;
			chomp $fipslibdir;
			close IN;
			}
		fips_check_files($fipslibdir,
				"fipscanister.lib", "fipscanister.lib.sha1",
				"fips_premain.c", "fips_premain.c.sha1");
		}
	}

a399 1
FIPSLINK=\$(PERL) util${o}fipslink.pl
a442 11
# FIPS validated module and support file locations

E_PREMAIN_DSO=fips_premain_dso

FIPSLIB_D=$fipslibdir
BASEADDR=$baseaddr
FIPS_PREMAIN_SRC=$fips_premain_c_path
O_FIPSCANISTER=$fips_canister_path
FIPS_SHA1_EXE=$fips_sha1_exe_path
PREMAIN_DSO_EXE=$fips_premain_dso_exe_path

a449 1
LIBFIPS=libosslfips
a469 1
O_FIPS=    \$(LIB_D)$o$plib\$(LIBFIPS)$shlibp
a473 1
L_FIPS=    \$(LIB_D)$o$plib\$(LIBFIPS)$libp
d475 1
a475 1
L_LIBS= \$(L_SSL) \$(L_CRYPTO) $ex_l_libs
d485 1
a485 1
LIBS_DEP=\$(O_CRYPTO) \$(O_SSL) $ex_libs_dep
d491 1
a491 1
all: banner \$(TMP_D) \$(BIN_D) \$(TEST_D) \$(LIB_D) \$(INCO_D) headers \$(FIPS_SHA1_EXE) lib exe $ex_build_targets
a605 20
# Special case rules for fips_start and fips_end fips_premain_dso

if ($fips)
	{
	if ($fipscanisterbuild)
		{
		$rules.=&cc_compile_target("\$(OBJ_D)${o}fips_start$obj",
			"fips${o}fips_canister.c",
			"-DFIPS_START \$(SHLIB_CFLAGS)");
		$rules.=&cc_compile_target("\$(OBJ_D)${o}fips_end$obj",
			"fips${o}fips_canister.c", "\$(SHLIB_CFLAGS)");
		}
	$rules.=&cc_compile_target("\$(OBJ_D)${o}fips_standalone_sha1$obj",
		"fips${o}sha${o}fips_standalone_sha1.c",
		"\$(SHLIB_CFLAGS)");
	$rules.=&cc_compile_target("\$(OBJ_D)${o}\$(E_PREMAIN_DSO)$obj",
		"fips${o}fips_premain.c",
		"-DFINGERPRINT_PREMAIN_DSO_LOAD \$(SHLIB_CFLAGS)");
	}

d616 17
a632 2

	if ((!$fips && ($_ eq "CRYPTO")) || ($fips && ($_ eq "FIPS")))
d634 3
a636 32
		if ($cpuid_asm_obj ne "")
			{
			$lib_obj =~ s/(\S*\/cryptlib\S*)/$1 \$(CPUID_ASM_OBJ)/;
			$rules.=&do_asm_rule($cpuid_asm_obj,$cpuid_asm_src);
			}
		if ($aes_asm_obj ne "")
			{
			$lib_obj =~ s/\s(\S*\/aes_core\S*)/ \$(AES_ASM_OBJ)/;
			$lib_obj =~ s/\s\S*\/aes_cbc\S*//;
			$rules.=&do_asm_rule($aes_asm_obj,$aes_asm_src);
			}
		if ($sha1_asm_obj ne "")
			{
			$lib_obj =~ s/\s(\S*\/sha1dgst\S*)/ $1 \$(SHA1_ASM_OBJ)/;
			$rules.=&do_asm_rule($sha1_asm_obj,$sha1_asm_src);
			}
		if ($bn_asm_obj ne "")
			{
			$lib_obj =~ s/\s\S*\/bn_asm\S*/ \$(BN_ASM_OBJ)/;
			$rules.=&do_asm_rule($bn_asm_obj,$bn_asm_src);
			}
		if ($bnco_asm_obj ne "")
			{
			$lib_obj .= "\$(BNCO_ASM_OBJ)";
			$rules.=&do_asm_rule($bnco_asm_obj,$bnco_asm_src);
			}
		if ($des_enc_obj ne "")
			{
			$lib_obj =~ s/\s\S*des_enc\S*/ \$(DES_ENC_OBJ)/;
			$lib_obj =~ s/\s\S*\/fcrypt_b\S*\s*/ /;
			$rules.=&do_asm_rule($des_enc_obj,$des_enc_src);
			}
d663 5
d673 5
a691 3
\$(OBJ_D)\\\$(LIBFIPS).res: ms\\version32.rc
	\$(RSC) /fo"\$(OBJ_D)\\\$(LIBFIPS).res" /d FIPS ms\\version32.rc

a697 1
	my $t_libs;
a698 24
	my $ltype;
	# Check to see if test program is FIPS
	if ($fips && /fips/)
		{
		# If fipsdso link to libosslfips.dll 
		# otherwise perform static link to 
		# $(O_FIPSCANISTER)
		if ($fipsdso)
			{
			$t_libs = "\$(L_FIPS)";
			$ltype = 0;
			}
		else
			{
			$t_libs = "\$(O_FIPSCANISTER)";
			$ltype = 2;
			}
		}
	else
		{
		$t_libs = "\$(L_LIBS)";
		$ltype = 0;
		}

d700 1
a700 1
	$rules.=&do_link_rule("\$(TEST_D)$o$t$exep",$tt,"\$(LIBS_DEP)","$t_libs \$(EX_LIBS)", $ltype);
d714 1
d716 1
a716 62
if ($fips)
	{
	if ($shlib)
		{
		if ($fipsdso)
			{
			$rules.= &do_lib_rule("\$(CRYPTOOBJ)",
					"\$(O_CRYPTO)", "$crypto",
					$shlib, "", "");
			$rules.= &do_lib_rule(
				"\$(O_FIPSCANISTER)",
				"\$(O_FIPS)", "\$(LIBFIPS)",
				$shlib, "\$(SO_CRYPTO)", "\$(BASEADDR)");
			$rules.= &do_sdef_rule();
			}
		else
			{
			$rules.= &do_lib_rule(
				"\$(CRYPTOOBJ) \$(O_FIPSCANISTER)",
				"\$(O_CRYPTO)", "$crypto",
				$shlib, "\$(SO_CRYPTO)", "\$(BASEADDR)");
			}
		}
	else
		{
		$rules.= &do_lib_rule("\$(CRYPTOOBJ)",
			"\$(O_CRYPTO)",$crypto,$shlib,"\$(SO_CRYPTO)", "");
		$rules.= &do_lib_rule("\$(CRYPTOOBJ) \$(FIPSOBJ)",
			"\$(LIB_D)$o$crypto_compat",$crypto,$shlib,"\$(SO_CRYPTO)", "");
		}
	}
	else
	{
	$rules.= &do_lib_rule("\$(CRYPTOOBJ)","\$(O_CRYPTO)",$crypto,$shlib,
							"\$(SO_CRYPTO)");
	}

if ($fips)
	{
	if ($fipscanisterbuild)
		{
		$rules.= &do_rlink_rule("\$(O_FIPSCANISTER)",
					"\$(OBJ_D)${o}fips_start$obj",
					"\$(FIPSOBJ)",
					"\$(OBJ_D)${o}fips_end$obj",
					"\$(FIPS_SHA1_EXE)", "");
		$rules.=&do_link_rule("\$(FIPS_SHA1_EXE)",
					"\$(OBJ_D)${o}fips_standalone_sha1$obj \$(OBJ_D)${o}sha1dgst$obj \$(SHA1_ASM_OBJ)",
					"","\$(EX_LIBS)", 1);
		}
	else
		{
		$rules.=&do_link_rule("\$(FIPS_SHA1_EXE)",
					"\$(OBJ_D)${o}fips_standalone_sha1$obj \$(O_FIPSCANISTER)",
					"","", 1);

		}
	$rules.=&do_link_rule("\$(PREMAIN_DSO_EXE)","\$(OBJ_D)${o}\$(E_PREMAIN_DSO)$obj \$(CRYPTOOBJ) \$(O_FIPSCANISTER)","","\$(EX_LIBS)", 1);
	
	}

$rules.=&do_link_rule("\$(BIN_D)$o\$(E_EXE)$exep","\$(E_OBJ)","\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)", ($fips && !$shlib) ? 2 : 0);
a753 2
	return("") if $no_jpake  && $dir =~ /\/jpake/;
	return("") if !$fips   && $dir =~ /^fips/;
a1012 1
		"ml64" => \$ml64,
a1019 2
		"no-jpake" => \$no_jpake,
		"no-capieng" => \$no_capieng,
a1045 3
		"fips" => \$fips,
		"fipscanisterbuild" => [\$fips, \$fipscanisterbuild],
		"fipsdso" => [\$fips, \$fipscanisterbuild, \$fipsdso],
a1086 12
	# experimental-xxx is mostly like enable-xxx, but opensslconf.v
	# will still set OPENSSL_NO_xxx unless we set OPENSSL_EXPERIMENTAL_xxx.
	# (No need to fail if we don't know the algorithm -- this is for adventurous users only.)
	elsif (/^experimental-/)
		{
		my $algo, $ALGO;
		($algo = $_) =~ s/^experimental-//;
		($ALGO = $algo) =~ tr/[a-z]/[A-Z]/;

		$xcflags="-DOPENSSL_EXPERIMENTAL_$ALGO $xcflags";
		
		}
a1108 28
	}

sub fipslib_error
	{
	print STDERR "***FIPS module directory sanity check failed***\n";
	print STDERR "FIPS module build failed, or was deleted\n";
	print STDERR "Please rebuild FIPS module.\n"; 
	exit 1;
	}

sub fips_check_files
	{
	my $dir = shift @@_;
	my $ret = 1;
	if (!-d $dir)
		{
		print STDERR "FIPS module directory $dir does not exist\n";
		fipslib_error();
		}
	foreach (@@_)
		{
		if (!-f "$dir${o}$_")
			{
			print STDERR "FIPS module file $_ does not exist!\n";
			$ret = 0;
			}
		}
	fipslib_error() if ($ret == 0);
@


1.1.1.10
log
@import OpenSSL-1.0.0a
@
text
@a8 1
$OPENSSLDIR="/usr/local/ssl";
d13 1
a13 1
my $no_static_engine = 1;
a16 1
local $perl_asm = 0;	# 1 to autobuild asm files from perl scripts
d18 4
a21 1
# Options to import from top level Makefile
d23 2
a24 22
my %mf_import = (
	VERSION	       => \$ssl_version,
	OPTIONS        => \$OPTIONS,
	INSTALLTOP     => \$INSTALLTOP,
	OPENSSLDIR     => \$OPENSSLDIR,
	PLATFORM       => \$mf_platform,
	CFLAG	       => \$mf_cflag,
	DEPFLAG	       => \$mf_depflag,
	CPUID_OBJ      => \$mf_cpuid_asm,
	BN_ASM	       => \$mf_bn_asm,
	DES_ENC	       => \$mf_des_asm,
	AES_ENC        => \$mf_aes_asm,
	BF_ENC	       => \$mf_bf_asm,
	CAST_ENC       => \$mf_cast_asm,
	RC4_ENC	       => \$mf_rc4_asm,
	RC5_ENC        => \$mf_rc5_asm,
	MD5_ASM_OBJ    => \$mf_md5_asm,
	SHA1_ASM_OBJ   => \$mf_sha_asm,
	RMD160_ASM_OBJ => \$mf_rmd_asm,
	WP_ASM_OBJ     => \$mf_wp_asm,
	CMLL_ENC       => \$mf_cm_asm
);
d26 4
d33 3
a35 6
    my ($mf_opt, $mf_ref);
    while (($mf_opt, $mf_ref) = each %mf_import) {
    	if (/^$mf_opt\s*=\s*(.*)$/) {
	   $$mf_ref = $1;
	}
    }
a38 2
$debug = 1 if $mf_platform =~ /^debug-/;

a60 1
	"auto", "auto detect from top level Makefile"
a146 6

if ($platform eq "auto") {
	$platform = $mf_platform;
	print STDERR "Imported platform $mf_platform\n";
}

a230 1
$cflags.=" -DOPENSSL_NO_WHIRLPOOL"   if $no_whirlpool;
d236 2
d245 1
a245 1
$cflags.=" -DOPENSSL_NO_JPAKE"    if $no_jpake;
a266 1

d268 2
a269 1
		  "CRYPTO" => " -DOPENSSL_BUILD_SHLIBCRYPTO");
a282 1
$OPENSSLDIR =~ s|/|$o|g;
d297 15
a311 5
			$uc=$lib;
			$uc =~ s/^lib(.*)\.a/$1/;
			$uc =~ tr/a-z/A-Z/;
			$lib_nam{$uc}=$uc;
			$lib_obj{$uc}.=$libobj." ";
d354 15
d374 104
a522 1
OPENSSLDIR=$OPENSSLDIR
d543 26
d587 11
d605 1
d626 1
d631 1
d633 1
a633 1
L_LIBS= \$(L_SSL) \$(L_CRYPTO)
d643 1
a643 1
LIBS_DEP=\$(O_CRYPTO) \$(O_SSL)
d649 1
a649 1
all: banner \$(TMP_D) \$(BIN_D) \$(TEST_D) \$(LIB_D) \$(INCO_D) headers lib exe
d686 2
a687 3
	\$(CP) \"\$(BIN_D)$o\$(E_EXE)$exep \$(INSTALLTOP)${o}bin\"
	\$(MKDIR) \"\$(OPENSSLDIR)\"
	\$(CP) apps${o}openssl.cnf \"\$(OPENSSLDIR)\"
d764 20
d795 65
d866 1
a866 2
if (($platform eq "VC-WIN32") || ($platform eq "VC-WIN64A")
	|| ($platform eq "VC-WIN64I") || ($platform eq "VC-NT")) {
d874 3
d883 1
d885 24
d910 1
a910 1
	$rules.=&do_link_rule("\$(TEST_D)$o$t$exep",$tt,"\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)");
a923 1
$rules.= &do_lib_rule("\$(CRYPTOOBJ)","\$(O_CRYPTO)",$crypto,$shlib,"\$(SO_CRYPTO)");
d925 62
a986 1
$rules.=&do_link_rule("\$(BIN_D)$o\$(E_EXE)$exep","\$(E_OBJ)","\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)");
d1025 1
a1036 1
	return("") if $no_whirlpool && $dir =~ /\/whrlpool/;
d1054 2
a1055 2
	#@@a=grep(!/(^s2_)|(^s23_)/,@@a) if $no_ssl2;
	#@@a=grep(!/(^s3_)|(^s23_)/,@@a) if $no_ssl3;
a1128 1
		elsif ($_ =~ /AES_ASM/){ $t="$_ "; }
d1136 1
a1137 1
		elsif ($_ =~ /WHIRLPOOL_ASM/){ $t="$_ "; }
d1145 1
a1145 1
	if ($shlib && (($platform eq "VC-WIN32") || ($platfrom eq "VC-WIN64I") || ($platform eq "VC-WIN64A") || ($platform eq "VC-NT")))
a1164 7
# return the leading path
sub dname
	{
	my $ret=shift;
	$ret =~ s/(^.*)[\\\/][^\\\/]+$/$1/;
	return($ret);
	}
d1172 2
a1173 2
	local($ret,$_,$n,$d,$s);

d1178 1
a1178 17
		$d=&dname($_);
		if (-f "${_}.c")
			{
			$ret.=&cc_compile_target("$to${o}$n$obj","${_}.c",$ex)
			}
		elsif (-f ($s="${d}${o}asm${o}${n}.pl") or
		       ($s=~s/sha256/sha512/ and -f $s) or
		       -f ($s="${d}${o}${n}.pl"))
			{
			$ret.=&perlasm_compile_target("$to${o}$n$obj",$s,$n);
			}
		elsif (-f ($s="${d}${o}asm${o}${n}.S") or
		       -f ($s="${d}${o}${n}.S"))
			{
			$ret.=&Sasm_compile_target("$to${o}$n$obj",$s,$n);
			}
		else	{ die "no rule for $_"; }
a1184 26
sub perlasm_compile_target
	{
	my($target,$source,$bname)=@@_;
	my($ret);

	$bname =~ s/(.*)\.[^\.]$/$1/;
	$ret ="\$(TMP_D)$o$bname.asm: $source\n";
	$ret.="\t\$(PERL) $source $asmtype \$(CFLAG) >\$\@@\n\n";
	$ret.="$target: \$(TMP_D)$o$bname.asm\n";
	$ret.="\t\$(ASM) $afile\$\@@ \$(TMP_D)$o$bname.asm\n\n";
	return($ret);
	}

sub Sasm_compile_target
	{
	my($target,$source,$bname)=@@_;
	my($ret);

	$bname =~ s/(.*)\.[^\.]$/$1/;
	$ret ="\$(TMP_D)$o$bname.asm: $source\n";
	$ret.="\t\$(CC) -E \$(CFLAG) $source >\$\@@\n\n";
	$ret.="$target: \$(TMP_D)$o$bname.asm\n";
	$ret.="\t\$(ASM) $afile\$\@@ \$(TMP_D)$o$bname.asm\n\n";
	return($ret);
	}

d1207 1
a1208 2
	@@s=split(/\s+/,$src);

d1212 2
a1213 13
		my $objfile = $t[$i];
		my $srcfile = $s[$i];

		if ($perl_asm == 1)
			{
			my $plasm = $objfile;
			$plasm =~ s/${obj}/.pl/;
			$ret.="$srcfile: $plasm\n";
			$ret.="\t\$(PERL) $plasm $asmtype \$(CFLAG) >$srcfile\n\n";
			}

		$ret.="$objfile: $srcfile\n";
		$ret.="\t\$(ASM) $afile$objfile \$(SRC_D)$o$srcfile\n\n";
a1276 1
		"no-whirlpool" => \$no_whirlpool,
d1285 1
d1294 1
a1318 1
		"no-store" => 0,
d1321 3
d1399 28
@


1.1.1.11
log
@import OpenSSL 1.0.0e
@
text
@a15 1
my $otherlibs = "";
a268 1
$cflags.=" -DOPENSSL_NO_GOST" if $no_gost;
a358 6
	if ($key eq "LIBNAME" && $no_static_engine)
		{
		$lib=$val;
		$lib =~ s/^.*\/([^\/]+)$/$1/;
		$otherlibs .= " $lib";
		}
d661 1
a661 1
$defs.=&do_defs("E_SHLIB",$engines . $otherlibs,"\$(ENG_D)",$shlibp);
a673 8
foreach (split(" ",$otherlibs))
	{
	my $uc = $_;
	$uc =~ tr /a-z/A-Z/;	
	$rules.= &do_lib_rule("\$(${uc}OBJ)","\$(ENG_D)$o$_$shlibp", "", $shlib, "");

	}

a710 1
	return("") if $no_gost   && $dir =~ /\/ccgost/;
a1049 1
		"no-gost" => \$no_gost,
@


1.1.1.12
log
@import OpenSSL-1.0.1c
@
text
@a20 2
my $ex_l_libs = "";

d43 1
a43 3
	CMLL_ENC       => \$mf_cm_asm,
	BASEADDR       => \$baseaddr,
	FIPSDIR        => \$fipsdir,
a106 1
	no-srp					- No SRP
a230 2
$fipsdir =~ s/\//${o}/g;

a263 1
$cflags.=" -DOPENSSL_NO_SRP" if $no_srp;
a272 1
$cflags.=" -DOPENSSL_FIPS"    if $fips;
a273 1
$cflags.=" -DOPENSSL_NO_EC2M"    if $no_ec2m;
a406 5
	if ($fips)
		{
		$build_targets .= " \$(LIB_D)$o$crypto_compat \$(PREMAIN_DSO_EXE)";
		$ex_l_libs .= " \$(O_FIPSCANISTER)";
		}
a467 12
# FIPS validated module and support file locations

FIPSDIR=$fipsdir
BASEADDR=$baseaddr
FIPSLIB_D=\$(FIPSDIR)${o}lib
FIPS_PREMAIN_SRC=\$(FIPSLIB_D)${o}fips_premain.c
O_FIPSCANISTER=\$(FIPSLIB_D)${o}fipscanister.lib
FIPS_SHA1_EXE=\$(FIPSDIR)${o}bin${o}fips_standalone_sha1${exep}
E_PREMAIN_DSO=fips_premain_dso
PREMAIN_DSO_EXE=\$(BIN_D)${o}fips_premain_dso$exep
FIPSLINK=\$(PERL) \$(FIPSDIR)${o}bin${o}fipslink.pl

d500 1
a500 1
L_LIBS= \$(L_SSL) \$(L_CRYPTO) $ex_l_libs
d516 1
a516 1
all: banner \$(TMP_D) \$(BIN_D) \$(TEST_D) \$(LIB_D) \$(INCO_D) headers lib exe $build_targets
a631 10
# Special case rule for fips_premain_dso

if ($fips)
	{
	$rules.=&cc_compile_target("\$(OBJ_D)${o}\$(E_PREMAIN_DSO)$obj",
		"\$(FIPS_PREMAIN_SRC)",
		"-DFINGERPRINT_PREMAIN_DSO_LOAD \$(SHLIB_CFLAGS)", "");
	$rules.=&do_link_rule("\$(PREMAIN_DSO_EXE)","\$(OBJ_D)${o}\$(E_PREMAIN_DSO)$obj \$(CRYPTOOBJ) \$(O_FIPSCANISTER)","","\$(EX_LIBS)", 1);
	}

d680 1
a680 22

if ($fips)
	{
	if ($shlib)
		{
		$rules.= &do_lib_rule("\$(CRYPTOOBJ) \$(O_FIPSCANISTER)",
				"\$(O_CRYPTO)", "$crypto",
				$shlib, "\$(SO_CRYPTO)", "\$(BASEADDR)");
		}
	else
		{
		$rules.= &do_lib_rule("\$(CRYPTOOBJ)",
			"\$(O_CRYPTO)",$crypto,$shlib,"\$(SO_CRYPTO)", "");
		$rules.= &do_lib_rule("\$(CRYPTOOBJ) \$(O_FIPSCANISTER)",
			"\$(LIB_D)$o$crypto_compat",$crypto,$shlib,"\$(SO_CRYPTO)", "");
		}
	}
	else
	{
	$rules.= &do_lib_rule("\$(CRYPTOOBJ)","\$(O_CRYPTO)",$crypto,$shlib,
							"\$(SO_CRYPTO)");
	}
d690 1
a690 1
$rules.=&do_link_rule("\$(BIN_D)$o\$(E_EXE)$exep","\$(E_OBJ)","\$(LIBS_DEP)","\$(L_LIBS) \$(EX_LIBS)", ($fips && !$shlib) ? 2 : 0);
a783 2
	@@a=grep(!/(srp)/,@@a) if $no_srp;

d942 1
a942 1
	local($target,$source,$ex_flags, $srcd)=@@_;
d948 2
a949 3
	$srcd = "\$(SRC_D)$o" unless defined $srcd;
	$ret ="$target: $srcd$source\n\t";
	$ret.="\$(CC) ${ofile}$target $ex_flags -c $srcd$source\n\n";
a1058 1
		"no-srp" => \$no_srp,
a1059 1
		"no-ec2m" => \$no_ec2m,
a1060 1
		"no-ec_nistp_64_gcc_128" => 0,
a1069 1
		"no-rsax" => 0,
d1074 1
a1074 1
			  \$no_aes, \$no_camellia, \$no_seed, \$no_srp],
a1081 1
		"no-sctp" => 0,
a1088 1
		"fips" => \$fips
@


