head	1.19;
access;
symbols
	butholakala:1.18
	openssl_1_0_1_g:1.1.1.12
	OPENBSD_5_5:1.18.0.8
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.4
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	openssl_1_0_1_c:1.1.1.12
	OPENBSD_5_2:1.17.0.2
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	openssl_1_0_0_f:1.1.1.11
	openssl_1_0_0_e:1.1.1.11
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	openssh_1_0_0_a:1.1.1.10
	OPENBSD_4_8:1.15.0.8
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.4
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	openssl_0_9_8_k:1.1.1.9
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	openssl_0_9_8_j:1.1.1.9
	openssl_0_9_8_h:1.1.1.8
	pre_openssl_0_9_8h:1.12
	OPENBSD_4_4:1.12.0.10
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	openssl_0_9_7j:1.1.1.7
	openssl:1.1.1
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENSSL_0_9_7G:1.1.1.6
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENSSL_0_9_7D:1.1.1.5
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@# @;


1.19
date	2014.04.17.19.20.52;	author afresh1;	state dead;
branches;
next	1.18;

1.18
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.01.22.59.01;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.06.12.17.54;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.27.05.07.03;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.29.05.39.33;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.08.08.03.15;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.07.09.06.03;	author jufi;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.21;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.03.43;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.58.45;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.48;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.41;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.58;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.58;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.50;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.45.15;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.36.58;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.20.42.11;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.04.29.05.37.31;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.06.27.05.05.40;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.06.12.15.53;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.01.09.12.14.09;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.10.01.22.54.18;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2011.11.03.02.32.23;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2012.10.13.21.23.53;	author djm;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Remove unused ssl utils

This code is the reason perl has a name as a write only language.

ok deraadt miod
@
text
@#!/usr/local/bin/perl -w
#
# generate a .def file
#
# It does this by parsing the header files and looking for the
# prototyped functions: it then prunes the output.
#
# Intermediary files are created, call libeay.num and ssleay.num,...
# Previously, they had the following format:
#
#	routine-name	nnnn
#
# But that isn't enough for a number of reasons, the first on being that
# this format is (needlessly) very Win32-centric, and even then...
# One of the biggest problems is that there's no information about what
# routines should actually be used, which varies with what crypto algorithms
# are disabled.  Also, some operating systems (for example VMS with VAX C)
# need to keep track of the global variables as well as the functions.
#
# So, a remake of this script is done so as to include information on the
# kind of symbol it is (function or variable) and what algorithms they're
# part of.  This will allow easy translating to .def files or the corresponding
# file in other operating systems (a .opt file for VMS, possibly with a .mar
# file).
#
# The format now becomes:
#
#	routine-name	nnnn	info
#
# and the "info" part is actually a colon-separated string of fields with
# the following meaning:
#
#	existence:platform:kind:algorithms
#
# - "existence" can be "EXIST" or "NOEXIST" depending on if the symbol is
#   found somewhere in the source, 
# - "platforms" is empty if it exists on all platforms, otherwise it contains
#   comma-separated list of the platform, just as they are if the symbol exists
#   for those platforms, or prepended with a "!" if not.  This helps resolve
#   symbol name variants for platforms where the names are too long for the
#   compiler or linker, or if the systems is case insensitive and there is a
#   clash, or the symbol is implemented differently (see
#   EXPORT_VAR_AS_FUNCTION).  This script assumes renaming of symbols is found
#   in the file crypto/symhacks.h.
#   The semantics for the platforms is that every item is checked against the
#   environment.  For the negative items ("!FOO"), if any of them is false
#   (i.e. "FOO" is true) in the environment, the corresponding symbol can't be
#   used.  For the positive itms, if all of them are false in the environment,
#   the corresponding symbol can't be used.  Any combination of positive and
#   negative items are possible, and of course leave room for some redundancy.
# - "kind" is "FUNCTION" or "VARIABLE".  The meaning of that is obvious.
# - "algorithms" is a comma-separated list of algorithm names.  This helps
#   exclude symbols that are part of an algorithm that some user wants to
#   exclude.
#

my $debug=0;

my $crypto_num= "util/libeay.num";
my $ssl_num=    "util/ssleay.num";
my $libname;

my $do_update = 0;
my $do_rewrite = 1;
my $do_crypto = 0;
my $do_ssl = 0;
my $do_ctest = 0;
my $do_ctestall = 0;
my $do_checkexist = 0;

my $VMSVAX=0;
my $VMSNonVAX=0;
my $VMS=0;
my $W32=0;
my $W16=0;
my $NT=0;
my $OS2=0;
# Set this to make typesafe STACK definitions appear in DEF
my $safe_stack_def = 0;

my @@known_platforms = ( "__FreeBSD__", "PERL5", "NeXT",
			"EXPORT_VAR_AS_FUNCTION", "ZLIB", "OPENSSL_FIPS" );
my @@known_ossl_platforms = ( "VMS", "WIN16", "WIN32", "WINNT", "OS2" );
my @@known_algorithms = ( "RC2", "RC4", "RC5", "IDEA", "DES", "BF",
			 "CAST", "MD2", "MD4", "MD5", "SHA", "SHA0", "SHA1",
			 "SHA256", "SHA512", "RIPEMD",
			 "MDC2", "WHIRLPOOL", "RSA", "DSA", "DH", "EC", "ECDH", "ECDSA", "EC2M",
			 "HMAC", "AES", "CAMELLIA", "SEED", "GOST",
			 # EC_NISTP_64_GCC_128
			 "EC_NISTP_64_GCC_128",
			 # Envelope "algorithms"
			 "EVP", "X509", "ASN1_TYPEDEFS",
			 # Helper "algorithms"
			 "BIO", "COMP", "BUFFER", "LHASH", "STACK", "ERR",
			 "LOCKING",
			 # External "algorithms"
			 "FP_API", "STDIO", "SOCK", "KRB5", "DGRAM",
			 # Engines
			 "STATIC_ENGINE", "ENGINE", "HW", "GMP",
			 # RFC3779
			 "RFC3779",
			 # TLS
			 "TLSEXT", "PSK", "SRP", "HEARTBEATS",
			 # CMS
			 "CMS",
			 # CryptoAPI Engine
			 "CAPIENG",
			 # SSL v2
			 "SSL2",
			 # JPAKE
			 "JPAKE",
			 # NEXTPROTONEG
			 "NEXTPROTONEG",
			 # Deprecated functions
			 "DEPRECATED",
			 # Hide SSL internals
			 "SSL_INTERN",
			 # SCTP
			 "SCTP");

my $options="";
open(IN,"<Makefile") || die "unable to open Makefile!\n";
while(<IN>) {
    $options=$1 if (/^OPTIONS=(.*)$/);
}
close(IN);

# The following ciphers may be excluded (by Configure). This means functions
# defined with ifndef(NO_XXX) are not included in the .def file, and everything
# in directory xxx is ignored.
my $no_rc2; my $no_rc4; my $no_rc5; my $no_idea; my $no_des; my $no_bf;
my $no_cast; my $no_whirlpool; my $no_camellia; my $no_seed;
my $no_md2; my $no_md4; my $no_md5; my $no_sha; my $no_ripemd; my $no_mdc2;
my $no_rsa; my $no_dsa; my $no_dh; my $no_hmac=0; my $no_aes; my $no_krb5;
my $no_ec; my $no_ecdsa; my $no_ecdh; my $no_engine; my $no_hw;
my $no_fp_api; my $no_static_engine=1; my $no_gmp; my $no_deprecated;
my $no_rfc3779; my $no_psk; my $no_tlsext; my $no_cms; my $no_capieng;
my $no_jpake; my $no_srp; my $no_ssl2; my $no_ec2m; my $no_nistp_gcc; 
my $no_nextprotoneg; my $no_sctp;

my $fips;

my $zlib;


foreach (@@ARGV, split(/ /, $options))
	{
	$debug=1 if $_ eq "debug";
	$W32=1 if $_ eq "32";
	$W16=1 if $_ eq "16";
	if($_ eq "NT") {
		$W32 = 1;
		$NT = 1;
	}
	if ($_ eq "VMS-VAX") {
		$VMS=1;
		$VMSVAX=1;
	}
	if ($_ eq "VMS-NonVAX") {
		$VMS=1;
		$VMSNonVAX=1;
	}
	$VMS=1 if $_ eq "VMS";
	$OS2=1 if $_ eq "OS2";
	$fips=1 if /^fips/;
	if ($_ eq "zlib" || $_ eq "enable-zlib" || $_ eq "zlib-dynamic"
			 || $_ eq "enable-zlib-dynamic") {
		$zlib = 1;
	}

	$do_ssl=1 if $_ eq "ssleay";
	if ($_ eq "ssl") {
		$do_ssl=1; 
		$libname=$_
	}
	$do_crypto=1 if $_ eq "libeay";
	if ($_ eq "crypto") {
		$do_crypto=1;
		$libname=$_;
	}
	$no_static_engine=1 if $_ eq "no-static-engine";
	$no_static_engine=0 if $_ eq "enable-static-engine";
	$do_update=1 if $_ eq "update";
	$do_rewrite=1 if $_ eq "rewrite";
	$do_ctest=1 if $_ eq "ctest";
	$do_ctestall=1 if $_ eq "ctestall";
	$do_checkexist=1 if $_ eq "exist";
	#$safe_stack_def=1 if $_ eq "-DDEBUG_SAFESTACK";

	if    (/^no-rc2$/)      { $no_rc2=1; }
	elsif (/^no-rc4$/)      { $no_rc4=1; }
	elsif (/^no-rc5$/)      { $no_rc5=1; }
	elsif (/^no-idea$/)     { $no_idea=1; }
	elsif (/^no-des$/)      { $no_des=1; $no_mdc2=1; }
	elsif (/^no-bf$/)       { $no_bf=1; }
	elsif (/^no-cast$/)     { $no_cast=1; }
	elsif (/^no-whirlpool$/)     { $no_whirlpool=1; }
	elsif (/^no-md2$/)      { $no_md2=1; }
	elsif (/^no-md4$/)      { $no_md4=1; }
	elsif (/^no-md5$/)      { $no_md5=1; }
	elsif (/^no-sha$/)      { $no_sha=1; }
	elsif (/^no-ripemd$/)   { $no_ripemd=1; }
	elsif (/^no-mdc2$/)     { $no_mdc2=1; }
	elsif (/^no-rsa$/)      { $no_rsa=1; }
	elsif (/^no-dsa$/)      { $no_dsa=1; }
	elsif (/^no-dh$/)       { $no_dh=1; }
	elsif (/^no-ec$/)       { $no_ec=1; }
	elsif (/^no-ecdsa$/)	{ $no_ecdsa=1; }
	elsif (/^no-ecdh$/) 	{ $no_ecdh=1; }
	elsif (/^no-hmac$/)	{ $no_hmac=1; }
	elsif (/^no-aes$/)	{ $no_aes=1; }
	elsif (/^no-camellia$/)	{ $no_camellia=1; }
	elsif (/^no-seed$/)     { $no_seed=1; }
	elsif (/^no-evp$/)	{ $no_evp=1; }
	elsif (/^no-lhash$/)	{ $no_lhash=1; }
	elsif (/^no-stack$/)	{ $no_stack=1; }
	elsif (/^no-err$/)	{ $no_err=1; }
	elsif (/^no-buffer$/)	{ $no_buffer=1; }
	elsif (/^no-bio$/)	{ $no_bio=1; }
	#elsif (/^no-locking$/)	{ $no_locking=1; }
	elsif (/^no-comp$/)	{ $no_comp=1; }
	elsif (/^no-dso$/)	{ $no_dso=1; }
	elsif (/^no-krb5$/)	{ $no_krb5=1; }
	elsif (/^no-engine$/)	{ $no_engine=1; }
	elsif (/^no-hw$/)	{ $no_hw=1; }
	elsif (/^no-gmp$/)	{ $no_gmp=1; }
	elsif (/^no-rfc3779$/)	{ $no_rfc3779=1; }
	elsif (/^no-tlsext$/)	{ $no_tlsext=1; }
	elsif (/^no-cms$/)	{ $no_cms=1; }
	elsif (/^no-ec2m$/)	{ $no_ec2m=1; }
	elsif (/^no-ec_nistp_64_gcc_128$/)	{ $no_nistp_gcc=1; }
	elsif (/^no-nextprotoneg$/)	{ $no_nextprotoneg=1; }
	elsif (/^no-ssl2$/)	{ $no_ssl2=1; }
	elsif (/^no-capieng$/)	{ $no_capieng=1; }
	elsif (/^no-jpake$/)	{ $no_jpake=1; }
	elsif (/^no-srp$/)	{ $no_srp=1; }
	elsif (/^no-sctp$/)	{ $no_sctp=1; }
	}


if (!$libname) { 
	if ($do_ssl) {
		$libname="SSLEAY";
	}
	if ($do_crypto) {
		$libname="LIBEAY";
	}
}

# If no platform is given, assume WIN32
if ($W32 + $W16 + $VMS + $OS2 == 0) {
	$W32 = 1;
}

# Add extra knowledge
if ($W16) {
	$no_fp_api=1;
}

if (!$do_ssl && !$do_crypto)
	{
	print STDERR "usage: $0 ( ssl | crypto ) [ 16 | 32 | NT | OS2 ]\n";
	exit(1);
	}

%ssl_list=&load_numbers($ssl_num);
$max_ssl = $max_num;
%crypto_list=&load_numbers($crypto_num);
$max_crypto = $max_num;

my $ssl="ssl/ssl.h";
$ssl.=" ssl/kssl.h";
$ssl.=" ssl/tls1.h";
$ssl.=" ssl/srtp.h";

my $crypto ="crypto/crypto.h";
$crypto.=" crypto/cryptlib.h";
$crypto.=" crypto/o_dir.h";
$crypto.=" crypto/o_str.h";
$crypto.=" crypto/o_time.h";
$crypto.=" crypto/des/des.h crypto/des/des_old.h" ; # unless $no_des;
$crypto.=" crypto/idea/idea.h" ; # unless $no_idea;
$crypto.=" crypto/rc4/rc4.h" ; # unless $no_rc4;
$crypto.=" crypto/rc5/rc5.h" ; # unless $no_rc5;
$crypto.=" crypto/rc2/rc2.h" ; # unless $no_rc2;
$crypto.=" crypto/bf/blowfish.h" ; # unless $no_bf;
$crypto.=" crypto/cast/cast.h" ; # unless $no_cast;
$crypto.=" crypto/whrlpool/whrlpool.h" ;
$crypto.=" crypto/md2/md2.h" ; # unless $no_md2;
$crypto.=" crypto/md4/md4.h" ; # unless $no_md4;
$crypto.=" crypto/md5/md5.h" ; # unless $no_md5;
$crypto.=" crypto/mdc2/mdc2.h" ; # unless $no_mdc2;
$crypto.=" crypto/sha/sha.h" ; # unless $no_sha;
$crypto.=" crypto/ripemd/ripemd.h" ; # unless $no_ripemd;
$crypto.=" crypto/aes/aes.h" ; # unless $no_aes;
$crypto.=" crypto/camellia/camellia.h" ; # unless $no_camellia;
$crypto.=" crypto/seed/seed.h"; # unless $no_seed;

$crypto.=" crypto/bn/bn.h";
$crypto.=" crypto/rsa/rsa.h" ; # unless $no_rsa;
$crypto.=" crypto/dsa/dsa.h" ; # unless $no_dsa;
$crypto.=" crypto/dh/dh.h" ; # unless $no_dh;
$crypto.=" crypto/ec/ec.h" ; # unless $no_ec;
$crypto.=" crypto/ecdsa/ecdsa.h" ; # unless $no_ecdsa;
$crypto.=" crypto/ecdh/ecdh.h" ; # unless $no_ecdh;
$crypto.=" crypto/hmac/hmac.h" ; # unless $no_hmac;
$crypto.=" crypto/cmac/cmac.h" ; # unless $no_hmac;

$crypto.=" crypto/engine/engine.h"; # unless $no_engine;
$crypto.=" crypto/stack/stack.h" ; # unless $no_stack;
$crypto.=" crypto/buffer/buffer.h" ; # unless $no_buffer;
$crypto.=" crypto/bio/bio.h" ; # unless $no_bio;
$crypto.=" crypto/dso/dso.h" ; # unless $no_dso;
$crypto.=" crypto/lhash/lhash.h" ; # unless $no_lhash;
$crypto.=" crypto/conf/conf.h";
$crypto.=" crypto/txt_db/txt_db.h";

$crypto.=" crypto/evp/evp.h" ; # unless $no_evp;
$crypto.=" crypto/objects/objects.h";
$crypto.=" crypto/pem/pem.h";
#$crypto.=" crypto/meth/meth.h";
$crypto.=" crypto/asn1/asn1.h";
$crypto.=" crypto/asn1/asn1t.h";
$crypto.=" crypto/asn1/asn1_mac.h";
$crypto.=" crypto/err/err.h" ; # unless $no_err;
$crypto.=" crypto/pkcs7/pkcs7.h";
$crypto.=" crypto/pkcs12/pkcs12.h";
$crypto.=" crypto/x509/x509.h";
$crypto.=" crypto/x509/x509_vfy.h";
$crypto.=" crypto/x509v3/x509v3.h";
$crypto.=" crypto/ts/ts.h";
$crypto.=" crypto/rand/rand.h";
$crypto.=" crypto/comp/comp.h" ; # unless $no_comp;
$crypto.=" crypto/ocsp/ocsp.h";
$crypto.=" crypto/ui/ui.h crypto/ui/ui_compat.h";
$crypto.=" crypto/krb5/krb5_asn.h";
#$crypto.=" crypto/store/store.h";
$crypto.=" crypto/pqueue/pqueue.h";
$crypto.=" crypto/cms/cms.h";
$crypto.=" crypto/jpake/jpake.h";
$crypto.=" crypto/modes/modes.h";
$crypto.=" crypto/srp/srp.h";

my $symhacks="crypto/symhacks.h";

my @@ssl_symbols = &do_defs("SSLEAY", $ssl, $symhacks);
my @@crypto_symbols = &do_defs("LIBEAY", $crypto, $symhacks);

if ($do_update) {

if ($do_ssl == 1) {

	&maybe_add_info("SSLEAY",*ssl_list,@@ssl_symbols);
	if ($do_rewrite == 1) {
		open(OUT, ">$ssl_num");
		&rewrite_numbers(*OUT,"SSLEAY",*ssl_list,@@ssl_symbols);
	} else {
		open(OUT, ">>$ssl_num");
	}
	&update_numbers(*OUT,"SSLEAY",*ssl_list,$max_ssl,@@ssl_symbols);
	close OUT;
}

if($do_crypto == 1) {

	&maybe_add_info("LIBEAY",*crypto_list,@@crypto_symbols);
	if ($do_rewrite == 1) {
		open(OUT, ">$crypto_num");
		&rewrite_numbers(*OUT,"LIBEAY",*crypto_list,@@crypto_symbols);
	} else {
		open(OUT, ">>$crypto_num");
	}
	&update_numbers(*OUT,"LIBEAY",*crypto_list,$max_crypto,@@crypto_symbols);
	close OUT;
} 

} elsif ($do_checkexist) {
	&check_existing(*ssl_list, @@ssl_symbols)
		if $do_ssl == 1;
	&check_existing(*crypto_list, @@crypto_symbols)
		if $do_crypto == 1;
} elsif ($do_ctest || $do_ctestall) {

	print <<"EOF";

/* Test file to check all DEF file symbols are present by trying
 * to link to all of them. This is *not* intended to be run!
 */

int main()
{
EOF
	&print_test_file(*STDOUT,"SSLEAY",*ssl_list,$do_ctestall,@@ssl_symbols)
		if $do_ssl == 1;

	&print_test_file(*STDOUT,"LIBEAY",*crypto_list,$do_ctestall,@@crypto_symbols)
		if $do_crypto == 1;

	print "}\n";

} else {

	&print_def_file(*STDOUT,$libname,*ssl_list,@@ssl_symbols)
		if $do_ssl == 1;

	&print_def_file(*STDOUT,$libname,*crypto_list,@@crypto_symbols)
		if $do_crypto == 1;

}


sub do_defs
{
	my($name,$files,$symhacksfile)=@@_;
	my $file;
	my @@ret;
	my %syms;
	my %platform;		# For anything undefined, we assume ""
	my %kind;		# For anything undefined, we assume "FUNCTION"
	my %algorithm;		# For anything undefined, we assume ""
	my %variant;
	my %variant_cnt;	# To be able to allocate "name{n}" if "name"
				# is the same name as the original.
	my $cpp;
	my %unknown_algorithms = ();

	foreach $file (split(/\s+/,$symhacksfile." ".$files))
		{
		print STDERR "DEBUG: starting on $file:\n" if $debug;
		open(IN,"<$file") || die "unable to open $file:$!\n";
		my $line = "", my $def= "";
		my %tag = (
			(map { $_ => 0 } @@known_platforms),
			(map { "OPENSSL_SYS_".$_ => 0 } @@known_ossl_platforms),
			(map { "OPENSSL_NO_".$_ => 0 } @@known_algorithms),
			NOPROTO		=> 0,
			PERL5		=> 0,
			_WINDLL		=> 0,
			CONST_STRICT	=> 0,
			TRUE		=> 1,
		);
		my $symhacking = $file eq $symhacksfile;
		my @@current_platforms = ();
		my @@current_algorithms = ();

		# params: symbol, alias, platforms, kind
		# The reason to put this subroutine in a variable is that
		# it will otherwise create it's own, unshared, version of
		# %tag and %variant...
		my $make_variant = sub
		{
			my ($s, $a, $p, $k) = @@_;
			my ($a1, $a2);

			print STDERR "DEBUG: make_variant: Entered with ",$s,", ",$a,", ",(defined($p)?$p:""),", ",(defined($k)?$k:""),"\n" if $debug;
			if (defined($p))
			{
				$a1 = join(",",$p,
					   grep(!/^$/,
						map { $tag{$_} == 1 ? $_ : "" }
						@@known_platforms));
			}
			else
			{
				$a1 = join(",",
					   grep(!/^$/,
						map { $tag{$_} == 1 ? $_ : "" }
						@@known_platforms));
			}
			$a2 = join(",",
				   grep(!/^$/,
					map { $tag{"OPENSSL_SYS_".$_} == 1 ? $_ : "" }
					@@known_ossl_platforms));
			print STDERR "DEBUG: make_variant: a1 = $a1; a2 = $a2\n" if $debug;
			if ($a1 eq "") { $a1 = $a2; }
			elsif ($a1 ne "" && $a2 ne "") { $a1 .= ",".$a2; }
			if ($a eq $s)
			{
				if (!defined($variant_cnt{$s}))
				{
					$variant_cnt{$s} = 0;
				}
				$variant_cnt{$s}++;
				$a .= "{$variant_cnt{$s}}";
			}
			my $toadd = $a.":".$a1.(defined($k)?":".$k:"");
			my $togrep = $s.'(\{[0-9]+\})?:'.$a1.(defined($k)?":".$k:"");
			if (!grep(/^$togrep$/,
				  split(/;/, defined($variant{$s})?$variant{$s}:""))) {
				if (defined($variant{$s})) { $variant{$s} .= ";"; }
				$variant{$s} .= $toadd;
			}
			print STDERR "DEBUG: make_variant: Exit with variant of ",$s," = ",$variant{$s},"\n" if $debug;
		};

		print STDERR "DEBUG: parsing ----------\n" if $debug;
		while(<IN>) {
			if (/\/\* Error codes for the \w+ functions\. \*\//)
				{
				undef @@tag;
				last;
				}
			if ($line ne '') {
				$_ = $line . $_;
				$line = '';
			}

			if (/\\$/) {
				chomp; # remove eol
				chop; # remove ending backslash
				$line = $_;
				next;
			}

			if(/\/\*/) {
				if (not /\*\//) {	# multiline comment...
					$line = $_;	# ... just accumulate
					next;
				} else {
					s/\/\*.*?\*\///gs;# wipe it
				}
			}

			if ($cpp) {
				$cpp++ if /^#\s*if/;
				$cpp-- if /^#\s*endif/;
				next;
	    		}
			$cpp = 1 if /^#.*ifdef.*cplusplus/;

			s/{[^{}]*}//gs;                      # ignore {} blocks
			print STDERR "DEBUG: \$def=\"$def\"\n" if $debug && $def ne "";
			print STDERR "DEBUG: \$_=\"$_\"\n" if $debug;
			if (/^\#\s*ifndef\s+(.*)/) {
				push(@@tag,"-");
				push(@@tag,$1);
				$tag{$1}=-1;
				print STDERR "DEBUG: $file: found tag $1 = -1\n" if $debug;
			} elsif (/^\#\s*if\s+!defined\(([^\)]+)\)/) {
				push(@@tag,"-");
				if (/^\#\s*if\s+(!defined\(([^\)]+)\)(\s+\&\&\s+!defined\(([^\)]+)\))*)$/) {
					my $tmp_1 = $1;
					my $tmp_;
					foreach $tmp_ (split '\&\&',$tmp_1) {
						$tmp_ =~ /!defined\(([^\)]+)\)/;
						print STDERR "DEBUG: $file: found tag $1 = -1\n" if $debug;
						push(@@tag,$1);
						$tag{$1}=-1;
					}
				} else {
					print STDERR "Warning: $file: complicated expression: $_" if $debug; # because it is O...
					print STDERR "DEBUG: $file: found tag $1 = -1\n" if $debug;
					push(@@tag,$1);
					$tag{$1}=-1;
				}
			} elsif (/^\#\s*ifdef\s+(\S*)/) {
				push(@@tag,"-");
				push(@@tag,$1);
				$tag{$1}=1;
				print STDERR "DEBUG: $file: found tag $1 = 1\n" if $debug;
			} elsif (/^\#\s*if\s+defined\(([^\)]+)\)/) {
				push(@@tag,"-");
				if (/^\#\s*if\s+(defined\(([^\)]+)\)(\s+\|\|\s+defined\(([^\)]+)\))*)$/) {
					my $tmp_1 = $1;
					my $tmp_;
					foreach $tmp_ (split '\|\|',$tmp_1) {
						$tmp_ =~ /defined\(([^\)]+)\)/;
						print STDERR "DEBUG: $file: found tag $1 = 1\n" if $debug;
						push(@@tag,$1);
						$tag{$1}=1;
					}
				} else {
					print STDERR "Warning: $file: complicated expression: $_\n" if $debug; # because it is O...
					print STDERR "DEBUG: $file: found tag $1 = 1\n" if $debug;
					push(@@tag,$1);
					$tag{$1}=1;
				}
			} elsif (/^\#\s*error\s+(\w+) is disabled\./) {
				my $tag_i = $#tag;
				while($tag[$tag_i] ne "-") {
					if ($tag[$tag_i] eq "OPENSSL_NO_".$1) {
						$tag{$tag[$tag_i]}=2;
						print STDERR "DEBUG: $file: chaged tag $1 = 2\n" if $debug;
					}
					$tag_i--;
				}
			} elsif (/^\#\s*endif/) {
				my $tag_i = $#tag;
				while($tag_i > 0 && $tag[$tag_i] ne "-") {
					my $t=$tag[$tag_i];
					print STDERR "DEBUG: \$t=\"$t\"\n" if $debug;
					if ($tag{$t}==2) {
						$tag{$t}=-1;
					} else {
						$tag{$t}=0;
					}
					print STDERR "DEBUG: $file: changed tag ",$t," = ",$tag{$t},"\n" if $debug;
					pop(@@tag);
					if ($t =~ /^OPENSSL_NO_([A-Z0-9_]+)$/) {
						$t=$1;
					} else {
						$t="";
					}
					if ($t ne ""
					    && !grep(/^$t$/, @@known_algorithms)) {
						$unknown_algorithms{$t} = 1;
						#print STDERR "DEBUG: Added as unknown algorithm: $t\n" if $debug;
					}
					$tag_i--;
				}
				pop(@@tag);
			} elsif (/^\#\s*else/) {
				my $tag_i = $#tag;
				while($tag[$tag_i] ne "-") {
					my $t=$tag[$tag_i];
					$tag{$t}= -$tag{$t};
					print STDERR "DEBUG: $file: changed tag ",$t," = ",$tag{$t},"\n" if $debug;
					$tag_i--;
				}
			} elsif (/^\#\s*if\s+1/) {
				push(@@tag,"-");
				# Dummy tag
				push(@@tag,"TRUE");
				$tag{"TRUE"}=1;
				print STDERR "DEBUG: $file: found 1\n" if $debug;
			} elsif (/^\#\s*if\s+0/) {
				push(@@tag,"-");
				# Dummy tag
				push(@@tag,"TRUE");
				$tag{"TRUE"}=-1;
				print STDERR "DEBUG: $file: found 0\n" if $debug;
			} elsif (/^\#\s*define\s+(\w+)\s+(\w+)/
				 && $symhacking && $tag{'TRUE'} != -1) {
				# This is for aliasing.  When we find an alias,
				# we have to invert
				&$make_variant($1,$2);
				print STDERR "DEBUG: $file: defined $1 = $2\n" if $debug;
			}
			if (/^\#/) {
				@@current_platforms =
				    grep(!/^$/,
					 map { $tag{$_} == 1 ? $_ :
						   $tag{$_} == -1 ? "!".$_  : "" }
					 @@known_platforms);
				push @@current_platforms
				    , grep(!/^$/,
					   map { $tag{"OPENSSL_SYS_".$_} == 1 ? $_ :
						     $tag{"OPENSSL_SYS_".$_} == -1 ? "!".$_  : "" }
					   @@known_ossl_platforms);
				@@current_algorithms =
				    grep(!/^$/,
					 map { $tag{"OPENSSL_NO_".$_} == -1 ? $_ : "" }
					 @@known_algorithms);
				$def .=
				    "#INFO:"
					.join(',',@@current_platforms).":"
					    .join(',',@@current_algorithms).";";
				next;
			}
			if ($tag{'TRUE'} != -1) {
				if (/^\s*DECLARE_STACK_OF\s*\(\s*(\w*)\s*\)/) {
					next;
				} elsif (/^\s*DECLARE_ASN1_ENCODE_FUNCTIONS\s*\(\s*(\w*)\s*,\s*(\w*)\s*,\s*(\w*)\s*\)/) {
					$def .= "int d2i_$3(void);";
					$def .= "int i2d_$3(void);";
					# Variant for platforms that do not
					# have to access globale variables
					# in shared libraries through functions
					$def .=
					    "#INFO:"
						.join(',',"!EXPORT_VAR_AS_FUNCTION",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "OPENSSL_EXTERN int $2_it;";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Variant for platforms that have to
					# access globale variables in shared
					# libraries through functions
					&$make_variant("$2_it","$2_it",
						      "EXPORT_VAR_AS_FUNCTION",
						      "FUNCTION");
					next;
				} elsif (/^\s*DECLARE_ASN1_FUNCTIONS_fname\s*\(\s*(\w*)\s*,\s*(\w*)\s*,\s*(\w*)\s*\)/) {
					$def .= "int d2i_$3(void);";
					$def .= "int i2d_$3(void);";
					$def .= "int $3_free(void);";
					$def .= "int $3_new(void);";
					# Variant for platforms that do not
					# have to access globale variables
					# in shared libraries through functions
					$def .=
					    "#INFO:"
						.join(',',"!EXPORT_VAR_AS_FUNCTION",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "OPENSSL_EXTERN int $2_it;";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Variant for platforms that have to
					# access globale variables in shared
					# libraries through functions
					&$make_variant("$2_it","$2_it",
						      "EXPORT_VAR_AS_FUNCTION",
						      "FUNCTION");
					next;
				} elsif (/^\s*DECLARE_ASN1_FUNCTIONS\s*\(\s*(\w*)\s*\)/ ||
					 /^\s*DECLARE_ASN1_FUNCTIONS_const\s*\(\s*(\w*)\s*\)/) {
					$def .= "int d2i_$1(void);";
					$def .= "int i2d_$1(void);";
					$def .= "int $1_free(void);";
					$def .= "int $1_new(void);";
					# Variant for platforms that do not
					# have to access globale variables
					# in shared libraries through functions
					$def .=
					    "#INFO:"
						.join(',',"!EXPORT_VAR_AS_FUNCTION",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "OPENSSL_EXTERN int $1_it;";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Variant for platforms that have to
					# access globale variables in shared
					# libraries through functions
					&$make_variant("$1_it","$1_it",
						      "EXPORT_VAR_AS_FUNCTION",
						      "FUNCTION");
					next;
				} elsif (/^\s*DECLARE_ASN1_ENCODE_FUNCTIONS_const\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
					$def .= "int d2i_$2(void);";
					$def .= "int i2d_$2(void);";
					# Variant for platforms that do not
					# have to access globale variables
					# in shared libraries through functions
					$def .=
					    "#INFO:"
						.join(',',"!EXPORT_VAR_AS_FUNCTION",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "OPENSSL_EXTERN int $2_it;";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Variant for platforms that have to
					# access globale variables in shared
					# libraries through functions
					&$make_variant("$2_it","$2_it",
						      "EXPORT_VAR_AS_FUNCTION",
						      "FUNCTION");
					next;
				} elsif (/^\s*DECLARE_ASN1_ALLOC_FUNCTIONS\s*\(\s*(\w*)\s*\)/) {
					$def .= "int $1_free(void);";
					$def .= "int $1_new(void);";
					next;
				} elsif (/^\s*DECLARE_ASN1_FUNCTIONS_name\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
					$def .= "int d2i_$2(void);";
					$def .= "int i2d_$2(void);";
					$def .= "int $2_free(void);";
					$def .= "int $2_new(void);";
					# Variant for platforms that do not
					# have to access globale variables
					# in shared libraries through functions
					$def .=
					    "#INFO:"
						.join(',',"!EXPORT_VAR_AS_FUNCTION",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "OPENSSL_EXTERN int $2_it;";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Variant for platforms that have to
					# access globale variables in shared
					# libraries through functions
					&$make_variant("$2_it","$2_it",
						      "EXPORT_VAR_AS_FUNCTION",
						      "FUNCTION");
					next;
				} elsif (/^\s*DECLARE_ASN1_ITEM\s*\(\s*(\w*)\s*\)/) {
					# Variant for platforms that do not
					# have to access globale variables
					# in shared libraries through functions
					$def .=
					    "#INFO:"
						.join(',',"!EXPORT_VAR_AS_FUNCTION",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "OPENSSL_EXTERN int $1_it;";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Variant for platforms that have to
					# access globale variables in shared
					# libraries through functions
					&$make_variant("$1_it","$1_it",
						      "EXPORT_VAR_AS_FUNCTION",
						      "FUNCTION");
					next;
				} elsif (/^\s*DECLARE_ASN1_NDEF_FUNCTION\s*\(\s*(\w*)\s*\)/) {
					$def .= "int i2d_$1_NDEF(void);";
				} elsif (/^\s*DECLARE_ASN1_SET_OF\s*\(\s*(\w*)\s*\)/) {
					next;
				} elsif (/^\s*DECLARE_ASN1_PRINT_FUNCTION\s*\(\s*(\w*)\s*\)/) {
					$def .= "int $1_print_ctx(void);";
					next;
				} elsif (/^\s*DECLARE_ASN1_PRINT_FUNCTION_name\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
					$def .= "int $2_print_ctx(void);";
					next;
				} elsif (/^\s*DECLARE_PKCS12_STACK_OF\s*\(\s*(\w*)\s*\)/) {
					next;
				} elsif (/^DECLARE_PEM_rw\s*\(\s*(\w*)\s*,/ ||
					 /^DECLARE_PEM_rw_cb\s*\(\s*(\w*)\s*,/ ||
					 /^DECLARE_PEM_rw_const\s*\(\s*(\w*)\s*,/ ) {
					# Things not in Win16
					$def .=
					    "#INFO:"
						.join(',',"!WIN16",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "int PEM_read_$1(void);";
					$def .= "int PEM_write_$1(void);";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Things that are everywhere
					$def .= "int PEM_read_bio_$1(void);";
					$def .= "int PEM_write_bio_$1(void);";
					next;
				} elsif (/^DECLARE_PEM_write\s*\(\s*(\w*)\s*,/ ||
					 /^DECLARE_PEM_write_cb\s*\(\s*(\w*)\s*,/ ) {
					# Things not in Win16
					$def .=
					    "#INFO:"
						.join(',',"!WIN16",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "int PEM_write_$1(void);";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Things that are everywhere
					$def .= "int PEM_write_bio_$1(void);";
					next;
				} elsif (/^DECLARE_PEM_read\s*\(\s*(\w*)\s*,/ ||
					 /^DECLARE_PEM_read_cb\s*\(\s*(\w*)\s*,/ ) {
					# Things not in Win16
					$def .=
					    "#INFO:"
						.join(',',"!WIN16",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "int PEM_read_$1(void);";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Things that are everywhere
					$def .= "int PEM_read_bio_$1(void);";
					next;
				} elsif (/^OPENSSL_DECLARE_GLOBAL\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
					# Variant for platforms that do not
					# have to access globale variables
					# in shared libraries through functions
					$def .=
					    "#INFO:"
						.join(',',"!EXPORT_VAR_AS_FUNCTION",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "OPENSSL_EXTERN int _shadow_$2;";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Variant for platforms that have to
					# access globale variables in shared
					# libraries through functions
					&$make_variant("_shadow_$2","_shadow_$2",
						      "EXPORT_VAR_AS_FUNCTION",
						      "FUNCTION");
				} elsif ($tag{'CONST_STRICT'} != 1) {
					if (/\{|\/\*|\([^\)]*$/) {
						$line = $_;
					} else {
						$def .= $_;
					}
				}
			}
		}
		close(IN);

		my $algs;
		my $plays;

		print STDERR "DEBUG: postprocessing ----------\n" if $debug;
		foreach (split /;/, $def) {
			my $s; my $k = "FUNCTION"; my $p; my $a;
			s/^[\n\s]*//g;
			s/[\n\s]*$//g;
			next if(/\#undef/);
			next if(/typedef\W/);
			next if(/\#define/);

			# Reduce argument lists to empty ()
			# fold round brackets recursively: (t(*v)(t),t) -> (t{}{},t) -> {}
			while(/\(.*\)/s) {
				s/\([^\(\)]+\)/\{\}/gs;
				s/\(\s*\*\s*(\w+)\s*\{\}\s*\)/$1/gs;	#(*f{}) -> f
			}
			# pretend as we didn't use curly braces: {} -> ()
			s/\{\}/\(\)/gs;

			s/STACK_OF\(\)/void/gs;
			s/LHASH_OF\(\)/void/gs;

			print STDERR "DEBUG: \$_ = \"$_\"\n" if $debug;
			if (/^\#INFO:([^:]*):(.*)$/) {
				$plats = $1;
				$algs = $2;
				print STDERR "DEBUG: found info on platforms ($plats) and algorithms ($algs)\n" if $debug;
				next;
			} elsif (/^\s*OPENSSL_EXTERN\s.*?(\w+(\{[0-9]+\})?)(\[[0-9]*\])*\s*$/) {
				$s = $1;
				$k = "VARIABLE";
				print STDERR "DEBUG: found external variable $s\n" if $debug;
			} elsif (/TYPEDEF_\w+_OF/s) {
				next;
			} elsif (/(\w+)\s*\(\).*/s) {	# first token prior [first] () is
				$s = $1;		# a function name!
				print STDERR "DEBUG: found function $s\n" if $debug;
			} elsif (/\(/ and not (/=/)) {
				print STDERR "File $file: cannot parse: $_;\n";
				next;
			} else {
				next;
			}

			$syms{$s} = 1;
			$kind{$s} = $k;

			$p = $plats;
			$a = $algs;
			$a .= ",BF" if($s =~ /EVP_bf/);
			$a .= ",CAST" if($s =~ /EVP_cast/);
			$a .= ",DES" if($s =~ /EVP_des/);
			$a .= ",DSA" if($s =~ /EVP_dss/);
			$a .= ",IDEA" if($s =~ /EVP_idea/);
			$a .= ",MD2" if($s =~ /EVP_md2/);
			$a .= ",MD4" if($s =~ /EVP_md4/);
			$a .= ",MD5" if($s =~ /EVP_md5/);
			$a .= ",RC2" if($s =~ /EVP_rc2/);
			$a .= ",RC4" if($s =~ /EVP_rc4/);
			$a .= ",RC5" if($s =~ /EVP_rc5/);
			$a .= ",RIPEMD" if($s =~ /EVP_ripemd/);
			$a .= ",SHA" if($s =~ /EVP_sha/);
			$a .= ",RSA" if($s =~ /EVP_(Open|Seal)(Final|Init)/);
			$a .= ",RSA" if($s =~ /PEM_Seal(Final|Init|Update)/);
			$a .= ",RSA" if($s =~ /RSAPrivateKey/);
			$a .= ",RSA" if($s =~ /SSLv23?_((client|server)_)?method/);

			$platform{$s} =
			    &reduce_platforms((defined($platform{$s})?$platform{$s}.',':"").$p);
			$algorithm{$s} .= ','.$a;

			if (defined($variant{$s})) {
				foreach $v (split /;/,$variant{$s}) {
					(my $r, my $p, my $k) = split(/:/,$v);
					my $ip = join ',',map({ /^!(.*)$/ ? $1 : "!".$_ } split /,/, $p);
					$syms{$r} = 1;
					if (!defined($k)) { $k = $kind{$s}; }
					$kind{$r} = $k."(".$s.")";
					$algorithm{$r} = $algorithm{$s};
					$platform{$r} = &reduce_platforms($platform{$s}.",".$p.",".$p);
					$platform{$s} = &reduce_platforms($platform{$s}.','.$ip.','.$ip);
					print STDERR "DEBUG: \$variant{\"$s\"} = ",$v,"; \$r = $r; \$p = ",$platform{$r},"; \$a = ",$algorithm{$r},"; \$kind = ",$kind{$r},"\n" if $debug;
				}
			}
			print STDERR "DEBUG: \$s = $s; \$p = ",$platform{$s},"; \$a = ",$algorithm{$s},"; \$kind = ",$kind{$s},"\n" if $debug;
		}
	}

	# Prune the returned symbols

        delete $syms{"bn_dump1"};
	$platform{"BIO_s_log"} .= ",!WIN32,!WIN16,!macintosh";

	$platform{"PEM_read_NS_CERT_SEQ"} = "VMS";
	$platform{"PEM_write_NS_CERT_SEQ"} = "VMS";
	$platform{"PEM_read_P8_PRIV_KEY_INFO"} = "VMS";
	$platform{"PEM_write_P8_PRIV_KEY_INFO"} = "VMS";
	$platform{"EVP_sha384"} = "!VMSVAX";
	$platform{"EVP_sha512"} = "!VMSVAX";
	$platform{"SHA384_Init"} = "!VMSVAX";
	$platform{"SHA384_Transform"} = "!VMSVAX";
	$platform{"SHA384_Update"} = "!VMSVAX";
	$platform{"SHA384_Final"} = "!VMSVAX";
	$platform{"SHA384"} = "!VMSVAX";
	$platform{"SHA512_Init"} = "!VMSVAX";
	$platform{"SHA512_Transform"} = "!VMSVAX";
	$platform{"SHA512_Update"} = "!VMSVAX";
	$platform{"SHA512_Final"} = "!VMSVAX";
	$platform{"SHA512"} = "!VMSVAX";
	$platform{"WHIRLPOOL_Init"} = "!VMSVAX";
	$platform{"WHIRLPOOL"} = "!VMSVAX";
	$platform{"WHIRLPOOL_BitUpdate"} = "!VMSVAX";
	$platform{"EVP_whirlpool"} = "!VMSVAX";
	$platform{"WHIRLPOOL_Final"} = "!VMSVAX";
	$platform{"WHIRLPOOL_Update"} = "!VMSVAX";


	# Info we know about

	push @@ret, map { $_."\\".&info_string($_,"EXIST",
					      $platform{$_},
					      $kind{$_},
					      $algorithm{$_}) } keys %syms;

	if (keys %unknown_algorithms) {
		print STDERR "WARNING: mkdef.pl doesn't know the following algorithms:\n";
		print STDERR "\t",join("\n\t",keys %unknown_algorithms),"\n";
	}
	return(@@ret);
}

# Param: string of comma-separated platform-specs.
sub reduce_platforms
{
	my ($platforms) = @@_;
	my $pl = defined($platforms) ? $platforms : "";
	my %p = map { $_ => 0 } split /,/, $pl;
	my $ret;

	print STDERR "DEBUG: Entered reduce_platforms with \"$platforms\"\n"
	    if $debug;
	# We do this, because if there's code like the following, it really
	# means the function exists in all cases and should therefore be
	# everywhere.  By increasing and decreasing, we may attain 0:
	#
	# ifndef WIN16
	#    int foo();
	# else
	#    int _fat foo();
	# endif
	foreach $platform (split /,/, $pl) {
		if ($platform =~ /^!(.*)$/) {
			$p{$1}--;
		} else {
			$p{$platform}++;
		}
	}
	foreach $platform (keys %p) {
		if ($p{$platform} == 0) { delete $p{$platform}; }
	}

	delete $p{""};

	$ret = join(',',sort(map { $p{$_} < 0 ? "!".$_ : $_ } keys %p));
	print STDERR "DEBUG: Exiting reduce_platforms with \"$ret\"\n"
	    if $debug;
	return $ret;
}

sub info_string {
	(my $symbol, my $exist, my $platforms, my $kind, my $algorithms) = @@_;

	my %a = defined($algorithms) ?
	    map { $_ => 1 } split /,/, $algorithms : ();
	my $k = defined($kind) ? $kind : "FUNCTION";
	my $ret;
	my $p = &reduce_platforms($platforms);

	delete $a{""};

	$ret = $exist;
	$ret .= ":".$p;
	$ret .= ":".$k;
	$ret .= ":".join(',',sort keys %a);
	return $ret;
}

sub maybe_add_info {
	(my $name, *nums, my @@symbols) = @@_;
	my $sym;
	my $new_info = 0;
	my %syms=();

	print STDERR "Updating $name info\n";
	foreach $sym (@@symbols) {
		(my $s, my $i) = split /\\/, $sym;
		if (defined($nums{$s})) {
			$i =~ s/^(.*?:.*?:\w+)(\(\w+\))?/$1/;
			(my $n, my $dummy) = split /\\/, $nums{$s};
			if (!defined($dummy) || $i ne $dummy) {
				$nums{$s} = $n."\\".$i;
				$new_info++;
				print STDERR "DEBUG: maybe_add_info for $s: \"$dummy\" => \"$i\"\n" if $debug;
			}
		}
		$syms{$s} = 1;
	}

	my @@s=sort { &parse_number($nums{$a},"n") <=> &parse_number($nums{$b},"n") } keys %nums;
	foreach $sym (@@s) {
		(my $n, my $i) = split /\\/, $nums{$sym};
		if (!defined($syms{$sym}) && $i !~ /^NOEXIST:/) {
			$new_info++;
			print STDERR "DEBUG: maybe_add_info for $sym: -> undefined\n" if $debug;
		}
	}
	if ($new_info) {
		print STDERR "$new_info old symbols got an info update\n";
		if (!$do_rewrite) {
			print STDERR "You should do a rewrite to fix this.\n";
		}
	} else {
		print STDERR "No old symbols needed info update\n";
	}
}

# Param: string of comma-separated keywords, each possibly prefixed with a "!"
sub is_valid
{
	my ($keywords_txt,$platforms) = @@_;
	my (@@keywords) = split /,/,$keywords_txt;
	my ($falsesum, $truesum) = (0, 1);

	# Param: one keyword
	sub recognise
	{
		my ($keyword,$platforms) = @@_;

		if ($platforms) {
			# platforms
			if ($keyword eq "VMSVAX" && $VMSVAX) { return 1; }
			if ($keyword eq "VMSNonVAX" && $VMSNonVAX) { return 1; }
			if ($keyword eq "VMS" && $VMS) { return 1; }
			if ($keyword eq "WIN32" && $W32) { return 1; }
			if ($keyword eq "WIN16" && $W16) { return 1; }
			if ($keyword eq "WINNT" && $NT) { return 1; }
			if ($keyword eq "OS2" && $OS2) { return 1; }
			# Special platforms:
			# EXPORT_VAR_AS_FUNCTION means that global variables
			# will be represented as functions.  This currently
			# only happens on VMS-VAX.
			if ($keyword eq "EXPORT_VAR_AS_FUNCTION" && ($VMSVAX || $W32 || $W16)) {
				return 1;
			}
			if ($keyword eq "OPENSSL_FIPS" && $fips) {
				return 1;
			}
			if ($keyword eq "ZLIB" && $zlib) { return 1; }
			return 0;
		} else {
			# algorithms
			if ($keyword eq "RC2" && $no_rc2) { return 0; }
			if ($keyword eq "RC4" && $no_rc4) { return 0; }
			if ($keyword eq "RC5" && $no_rc5) { return 0; }
			if ($keyword eq "IDEA" && $no_idea) { return 0; }
			if ($keyword eq "DES" && $no_des) { return 0; }
			if ($keyword eq "BF" && $no_bf) { return 0; }
			if ($keyword eq "CAST" && $no_cast) { return 0; }
			if ($keyword eq "MD2" && $no_md2) { return 0; }
			if ($keyword eq "MD4" && $no_md4) { return 0; }
			if ($keyword eq "MD5" && $no_md5) { return 0; }
			if ($keyword eq "SHA" && $no_sha) { return 0; }
			if ($keyword eq "RIPEMD" && $no_ripemd) { return 0; }
			if ($keyword eq "MDC2" && $no_mdc2) { return 0; }
			if ($keyword eq "WHIRLPOOL" && $no_whirlpool) { return 0; }
			if ($keyword eq "RSA" && $no_rsa) { return 0; }
			if ($keyword eq "DSA" && $no_dsa) { return 0; }
			if ($keyword eq "DH" && $no_dh) { return 0; }
			if ($keyword eq "EC" && $no_ec) { return 0; }
			if ($keyword eq "ECDSA" && $no_ecdsa) { return 0; }
			if ($keyword eq "ECDH" && $no_ecdh) { return 0; }
			if ($keyword eq "HMAC" && $no_hmac) { return 0; }
			if ($keyword eq "AES" && $no_aes) { return 0; }
			if ($keyword eq "CAMELLIA" && $no_camellia) { return 0; }
			if ($keyword eq "SEED" && $no_seed) { return 0; }
			if ($keyword eq "EVP" && $no_evp) { return 0; }
			if ($keyword eq "LHASH" && $no_lhash) { return 0; }
			if ($keyword eq "STACK" && $no_stack) { return 0; }
			if ($keyword eq "ERR" && $no_err) { return 0; }
			if ($keyword eq "BUFFER" && $no_buffer) { return 0; }
			if ($keyword eq "BIO" && $no_bio) { return 0; }
			if ($keyword eq "COMP" && $no_comp) { return 0; }
			if ($keyword eq "DSO" && $no_dso) { return 0; }
			if ($keyword eq "KRB5" && $no_krb5) { return 0; }
			if ($keyword eq "ENGINE" && $no_engine) { return 0; }
			if ($keyword eq "HW" && $no_hw) { return 0; }
			if ($keyword eq "FP_API" && $no_fp_api) { return 0; }
			if ($keyword eq "STATIC_ENGINE" && $no_static_engine) { return 0; }
			if ($keyword eq "GMP" && $no_gmp) { return 0; }
			if ($keyword eq "RFC3779" && $no_rfc3779) { return 0; }
			if ($keyword eq "TLSEXT" && $no_tlsext) { return 0; }
			if ($keyword eq "PSK" && $no_psk) { return 0; }
			if ($keyword eq "CMS" && $no_cms) { return 0; }
			if ($keyword eq "EC2M" && $no_ec2m) { return 0; }
			if ($keyword eq "NEXTPROTONEG" && $no_nextprotoneg) { return 0; }
			if ($keyword eq "EC_NISTP_64_GCC_128" && $no_nistp_gcc)
					{ return 0; }
			if ($keyword eq "SSL2" && $no_ssl2) { return 0; }
			if ($keyword eq "CAPIENG" && $no_capieng) { return 0; }
			if ($keyword eq "JPAKE" && $no_jpake) { return 0; }
			if ($keyword eq "SRP" && $no_srp) { return 0; }
			if ($keyword eq "SCTP" && $no_sctp) { return 0; }
			if ($keyword eq "DEPRECATED" && $no_deprecated) { return 0; }

			# Nothing recognise as true
			return 1;
		}
	}

	foreach $k (@@keywords) {
		if ($k =~ /^!(.*)$/) {
			$falsesum += &recognise($1,$platforms);
		} else {
			$truesum *= &recognise($k,$platforms);
		}
	}
	print STDERR "DEBUG: [",$#keywords,",",$#keywords < 0,"] is_valid($keywords_txt) => (\!$falsesum) && $truesum = ",(!$falsesum) && $truesum,"\n" if $debug;
	return (!$falsesum) && $truesum;
}

sub print_test_file
{
	(*OUT,my $name,*nums,my $testall,my @@symbols)=@@_;
	my $n = 1; my @@e; my @@r;
	my $sym; my $prev = ""; my $prefSSLeay;

	(@@e)=grep(/^SSLeay(\{[0-9]+\})?\\.*?:.*?:.*/,@@symbols);
	(@@r)=grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:.*/ && !/^SSLeay(\{[0-9]+\})?\\.*?:.*?:.*/,@@symbols);
	@@symbols=((sort @@e),(sort @@r));

	foreach $sym (@@symbols) {
		(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
		my $v = 0;
		$v = 1 if $i=~ /^.*?:.*?:VARIABLE/;
		my $p = ($i =~ /^[^:]*:([^:]*):/,$1);
		my $a = ($i =~ /^[^:]*:[^:]*:[^:]*:([^:]*)/,$1);
		if (!defined($nums{$s})) {
			print STDERR "Warning: $s does not have a number assigned\n"
			    if(!$do_update);
		} elsif (is_valid($p,1) && is_valid($a,0)) {
			my $s2 = ($s =~ /^(.*?)(\{[0-9]+\})?$/, $1);
			if ($prev eq $s2) {
				print OUT "\t/* The following has already appeared previously */\n";
				print STDERR "Warning: Symbol '",$s2,"' redefined. old=",($nums{$prev} =~ /^(.*?)\\/,$1),", new=",($nums{$s2} =~ /^(.*?)\\/,$1),"\n";
			}
			$prev = $s2;	# To warn about duplicates...

			($nn,$ni)=($nums{$s2} =~ /^(.*?)\\(.*)$/);
			if ($v) {
				print OUT "\textern int $s2; /* type unknown */ /* $nn $ni */\n";
			} else {
				print OUT "\textern int $s2(); /* type unknown */ /* $nn $ni */\n";
			}
		}
	}
}

sub get_version {
   local *MF;
   my $v = '?';
   open MF, 'Makefile' or return $v;
   while (<MF>) {
     $v = $1, last if /^VERSION=(.*?)\s*$/;
   }
   close MF;
   return $v;
}

sub print_def_file
{
	(*OUT,my $name,*nums,my @@symbols)=@@_;
	my $n = 1; my @@e; my @@r; my @@v; my $prev="";
	my $liboptions="";
	my $libname = $name;
	my $http_vendor = 'www.openssl.org/';
	my $version = get_version();
	my $what = "OpenSSL: implementation of Secure Socket Layer";
	my $description = "$what $version, $name - http://$http_vendor";

	if ($W32)
		{ $libname.="32"; }
	elsif ($W16)
		{ $libname.="16"; }
	elsif ($OS2)
		{ # DLL names should not clash on the whole system.
		  # However, they should not have any particular relationship
		  # to the name of the static library.  Chose descriptive names
		  # (must be at most 8 chars).
		  my %translate = (ssl => 'open_ssl', crypto => 'cryptssl');
		  $libname = $translate{$name} || $name;
		  $liboptions = <<EOO;
INITINSTANCE
DATA MULTIPLE NONSHARED
EOO
		  # Vendor field can't contain colon, drat; so we omit http://
		  $description = "\@@#$http_vendor:$version#\@@$what; DLL for library $name.  Build for EMX -Zmtd";
		}

	print OUT <<"EOF";
;
; Definition file for the DLL version of the $name library from OpenSSL
;

LIBRARY         $libname	$liboptions

EOF

	if ($W16) {
		print <<"EOF";
CODE            PRELOAD MOVEABLE
DATA            PRELOAD MOVEABLE SINGLE

EXETYPE		WINDOWS

HEAPSIZE	4096
STACKSIZE	8192

EOF
	}

	print "EXPORTS\n";

	(@@e)=grep(/^SSLeay(\{[0-9]+\})?\\.*?:.*?:FUNCTION/,@@symbols);
	(@@r)=grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:FUNCTION/ && !/^SSLeay(\{[0-9]+\})?\\.*?:.*?:FUNCTION/,@@symbols);
	(@@v)=grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:VARIABLE/,@@symbols);
	@@symbols=((sort @@e),(sort @@r), (sort @@v));


	foreach $sym (@@symbols) {
		(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
		my $v = 0;
		$v = 1 if $i =~ /^.*?:.*?:VARIABLE/;
		if (!defined($nums{$s})) {
			printf STDERR "Warning: $s does not have a number assigned\n"
			    if(!$do_update);
		} else {
			(my $n, my $dummy) = split /\\/, $nums{$s};
			my %pf = ();
			my $p = ($i =~ /^[^:]*:([^:]*):/,$1);
			my $a = ($i =~ /^[^:]*:[^:]*:[^:]*:([^:]*)/,$1);
			if (is_valid($p,1) && is_valid($a,0)) {
				my $s2 = ($s =~ /^(.*?)(\{[0-9]+\})?$/, $1);
				if ($prev eq $s2) {
					print STDERR "Warning: Symbol '",$s2,"' redefined. old=",($nums{$prev} =~ /^(.*?)\\/,$1),", new=",($nums{$s2} =~ /^(.*?)\\/,$1),"\n";
				}
				$prev = $s2;	# To warn about duplicates...
				if($v && !$OS2) {
					printf OUT "    %s%-39s @@%-8d DATA\n",($W32)?"":"_",$s2,$n;
				} else {
					printf OUT "    %s%-39s @@%d\n",($W32||$OS2)?"":"_",$s2,$n;
				}
			}
		}
	}
	printf OUT "\n";
}

sub load_numbers
{
	my($name)=@@_;
	my(@@a,%ret);

	$max_num = 0;
	$num_noinfo = 0;
	$prev = "";
	$prev_cnt = 0;

	open(IN,"<$name") || die "unable to open $name:$!\n";
	while (<IN>) {
		chop;
		s/#.*$//;
		next if /^\s*$/;
		@@a=split;
		if (defined $ret{$a[0]}) {
			# This is actually perfectly OK
			#print STDERR "Warning: Symbol '",$a[0],"' redefined. old=",$ret{$a[0]},", new=",$a[1],"\n";
		}
		if ($max_num > $a[1]) {
			print STDERR "Warning: Number decreased from ",$max_num," to ",$a[1],"\n";
		}
		elsif ($max_num == $a[1]) {
			# This is actually perfectly OK
			#print STDERR "Warning: Symbol ",$a[0]," has same number as previous ",$prev,": ",$a[1],"\n";
			if ($a[0] eq $prev) {
				$prev_cnt++;
				$a[0] .= "{$prev_cnt}";
			}
		}
		else {
			$prev_cnt = 0;
		}
		if ($#a < 2) {
			# Existence will be proven later, in do_defs
			$ret{$a[0]}=$a[1];
			$num_noinfo++;
		} else {
			$ret{$a[0]}=$a[1]."\\".$a[2]; # \\ is a special marker
		}
		$max_num = $a[1] if $a[1] > $max_num;
		$prev=$a[0];
	}
	if ($num_noinfo) {
		print STDERR "Warning: $num_noinfo symbols were without info.";
		if ($do_rewrite) {
			printf STDERR "  The rewrite will fix this.\n";
		} else {
			printf STDERR "  You should do a rewrite to fix this.\n";
		}
	}
	close(IN);
	return(%ret);
}

sub parse_number
{
	(my $str, my $what) = @@_;
	(my $n, my $i) = split(/\\/,$str);
	if ($what eq "n") {
		return $n;
	} else {
		return $i;
	}
}

sub rewrite_numbers
{
	(*OUT,$name,*nums,@@symbols)=@@_;
	my $thing;

	print STDERR "Rewriting $name\n";

	my @@r = grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:\w+\(\w+\)/,@@symbols);
	my $r; my %r; my %rsyms;
	foreach $r (@@r) {
		(my $s, my $i) = split /\\/, $r;
		my $a = $1 if $i =~ /^.*?:.*?:\w+\((\w+)\)/;
		$i =~ s/^(.*?:.*?:\w+)\(\w+\)/$1/;
		$r{$a} = $s."\\".$i;
		$rsyms{$s} = 1;
	}

	my %syms = ();
	foreach $_ (@@symbols) {
		(my $n, my $i) = split /\\/;
		$syms{$n} = 1;
	}

	my @@s=sort {
	    &parse_number($nums{$a},"n") <=> &parse_number($nums{$b},"n")
	    || $a cmp $b
	} keys %nums;
	foreach $sym (@@s) {
		(my $n, my $i) = split /\\/, $nums{$sym};
		next if defined($i) && $i =~ /^.*?:.*?:\w+\(\w+\)/;
		next if defined($rsyms{$sym});
		print STDERR "DEBUG: rewrite_numbers for sym = ",$sym,": i = ",$i,", n = ",$n,", rsym{sym} = ",$rsyms{$sym},"syms{sym} = ",$syms{$sym},"\n" if $debug;
		$i="NOEXIST::FUNCTION:"
			if !defined($i) || $i eq "" || !defined($syms{$sym});
		my $s2 = $sym;
		$s2 =~ s/\{[0-9]+\}$//;
		printf OUT "%s%-39s %d\t%s\n","",$s2,$n,$i;
		if (exists $r{$sym}) {
			(my $s, $i) = split /\\/,$r{$sym};
			my $s2 = $s;
			$s2 =~ s/\{[0-9]+\}$//;
			printf OUT "%s%-39s %d\t%s\n","",$s2,$n,$i;
		}
	}
}

sub update_numbers
{
	(*OUT,$name,*nums,my $start_num, my @@symbols)=@@_;
	my $new_syms = 0;

	print STDERR "Updating $name numbers\n";

	my @@r = grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:\w+\(\w+\)/,@@symbols);
	my $r; my %r; my %rsyms;
	foreach $r (@@r) {
		(my $s, my $i) = split /\\/, $r;
		my $a = $1 if $i =~ /^.*?:.*?:\w+\((\w+)\)/;
		$i =~ s/^(.*?:.*?:\w+)\(\w+\)/$1/;
		$r{$a} = $s."\\".$i;
		$rsyms{$s} = 1;
	}

	foreach $sym (@@symbols) {
		(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
		next if $i =~ /^.*?:.*?:\w+\(\w+\)/;
		next if defined($rsyms{$sym});
		die "ERROR: Symbol $sym had no info attached to it."
		    if $i eq "";
		if (!exists $nums{$s}) {
			$new_syms++;
			my $s2 = $s;
			$s2 =~ s/\{[0-9]+\}$//;
			printf OUT "%s%-39s %d\t%s\n","",$s2, ++$start_num,$i;
			if (exists $r{$s}) {
				($s, $i) = split /\\/,$r{$s};
				$s =~ s/\{[0-9]+\}$//;
				printf OUT "%s%-39s %d\t%s\n","",$s, $start_num,$i;
			}
		}
	}
	if($new_syms) {
		print STDERR "$new_syms New symbols added\n";
	} else {
		print STDERR "No New symbols Added\n";
	}
}

sub check_existing
{
	(*nums, my @@symbols)=@@_;
	my %existing; my @@remaining;
	@@remaining=();
	foreach $sym (@@symbols) {
		(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
		$existing{$s}=1;
	}
	foreach $sym (keys %nums) {
		if (!exists $existing{$sym}) {
			push @@remaining, $sym;
		}
	}
	if(@@remaining) {
		print STDERR "The following symbols do not seem to exist:\n";
		foreach $sym (@@remaining) {
			print STDERR "\t",$sym,"\n";
		}
	}
}

@


1.18
log
@resolve conflicts
@
text
@@


1.17
log
@openssl-1.0.0e: resolve conflicts
@
text
@d82 1
a82 1
			"EXPORT_VAR_AS_FUNCTION", "ZLIB" );
d87 1
a87 1
			 "MDC2", "WHIRLPOOL", "RSA", "DSA", "DH", "EC", "ECDH", "ECDSA",
d89 2
d103 1
a103 1
			 "TLSEXT", "PSK",
d112 2
d115 5
a119 1
			 "DEPRECATED" );
d138 4
a141 1
my $no_jpake; my $no_ssl2;
d165 1
d230 3
d236 2
d274 1
d277 1
d307 1
d342 1
d1150 3
d1199 4
d1206 2
@


1.16
log
@resolve conflicts, fix local changes
@
text
@d260 2
d321 1
@


1.15
log
@resolve conflicts
@
text
@d72 1
a72 1
my $VMSAlpha=0;
d82 1
a82 1
			"EXPORT_VAR_AS_FUNCTION", "ZLIB", "OPENSSL_FIPS"); 
d87 2
a88 1
			 "MDC2", "RSA", "DSA", "DH", "EC", "ECDH", "ECDSA", "HMAC", "AES", "CAMELLIA", "SEED",
d98 1
a98 1
			 # RFC3779 support 
d100 2
a101 2
			 # TLS extension support
			 "TLSEXT",
d106 2
d124 1
a124 1
my $no_cast;
d127 6
a132 5
my $no_ec; my $no_ecdsa; my $no_ecdh; my $no_engine; my $no_hw; my $no_camellia;
my $no_seed;
my $no_fp_api; my $no_static_engine; my $no_gmp; my $no_deprecated;
my $no_rfc3779; my $no_tlsext; my $no_cms; my $no_capieng; my $no_jpake;
my $fips;
d148 1
a148 1
	if ($_ eq "VMS-Alpha") {
d150 1
a150 1
		$VMSAlpha=1;
d154 3
a156 5
	$fips=1 if /^fips/;

	if ($_ eq "zlib" || $_ eq "zlib-dynamic"
 			 || $_ eq "enable-zlib-dynamic") {
 		$zlib = 1;
d185 1
d218 1
d267 1
d309 1
d315 1
a315 2
$crypto.=" crypto/tmdiff.h";
$crypto.=" crypto/store/store.h";
a318 1
$crypto.=" fips/fips.h fips/rand/fips_rand.h";
d892 1
d969 19
d1112 2
a1125 3
			if ($keyword eq "OPENSSL_FIPS" && $fips) {
				return 1;
			}
d1143 1
d1170 1
d1172 1
@


1.14
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d82 1
a82 1
			"EXPORT_VAR_AS_FUNCTION", "ZLIB" );
d105 2
d127 2
a128 1
my $no_rfc3779; my $no_tlsext; my $no_cms; my $no_capieng;
d150 2
d153 2
a154 2
			 || $_ eq "enable-zlib-dynamic") {
		$zlib = 1;
a156 1

d216 1
d313 2
d1100 3
d1148 1
@


1.13
log
@resolve conflicts
@
text
@d103 2
d125 1
a125 1
my $no_rfc3779; my $no_tlsext; my $no_cms;
d211 1
d1137 1
@


1.12
log
@resolve conflicts
@
text
@d82 1
a82 1
			"EXPORT_VAR_AS_FUNCTION", "OPENSSL_FIPS" );
d87 1
a87 1
			 "MDC2", "RSA", "DSA", "DH", "EC", "HMAC", "AES",
d94 11
a104 1
			 "FP_API", "STDIO", "SOCK", "KRB5", "ENGINE", "HW" );
d120 5
a124 3
my $no_ec; my $no_engine; my $no_hw;
my $no_fp_api;
my $fips;
d145 5
a149 1
	$fips=1 if $_ eq "fips";
d161 2
d187 2
d191 2
d205 4
d244 1
d247 1
d262 2
d270 2
d302 3
a304 1
$crypto.=" fips-1.0/fips.h fips-1.0/rand/fips_rand.h fips-1.0/sha/fips_sha.h";
d460 5
a464 1
			last if (/\/\* Error codes for the \w+ functions\. \*\//);
d477 9
a485 1
	    		$cpp = 1 if /^\#.*ifdef.*cplusplus/;
d487 2
a488 1
				$cpp = 0 if /^\#.*endif/;
d491 1
a492 5
			s/\/\*.*?\*\///gs;                   # ignore comments
			if (/\/\*/) {			     # if we have part
				$line = $_;		     # of a comment,
				next;			     # continue reading
			}
d551 1
a551 1
				while($tag[$tag_i] ne "-") {
d718 4
d766 2
d770 6
d779 2
a780 1
					 /^DECLARE_PEM_rw_cb\s*\(\s*(\w*)\s*,/ ) {
d856 1
a856 1
		my $algs = '';
d868 11
d889 1
a889 6
			} elsif (/\(\*(\w*(\{[0-9]+\})?)\([^\)]+/) {
				$s = $1;
				print STDERR "DEBUG: found ANSI C function $s\n" if $debug;
			} elsif (/\w+\W+(\w+)\W*\(\s*\)(\s*__attribute__\(.*\)\s*)?$/s) {
				# K&R C
				print STDERR "DEBUG: found K&R C function $s\n" if $debug;
d891 2
a892 8
			} elsif (/\w+\W+\w+(\{[0-9]+\})?\W*\(.*\)(\s*__attribute__\(.*\)\s*)?$/s) {
				while (not /\(\)(\s*__attribute__\(.*\)\s*)?$/s) {
					s/[^\(\)]*\)(\s*__attribute__\(.*\)\s*)?$/\)/s;
					s/\([^\(\)]*\)\)(\s*__attribute__\(.*\)\s*)?$/\)/s;
				}
				s/\(void\)//;
				/(\w+(\{[0-9]+\})?)\W*\(\)/s;
				$s = $1;
a922 3
			# SHA2 algorithms only defined in FIPS mode for
			# OpenSSL 0.9.7
			$p .= "OPENSSL_FIPS" if($s =~ /SHA[235]/);
a925 1
			$algorithm{$s} = '' if !defined $algorithm{$s};
d1090 1
a1090 3
			if ($keyword eq "OPENSSL_FIPS" && $fips) {
				return 1;
			}
d1111 2
d1115 2
d1129 6
a1235 2

DESCRIPTION     '$description'
@


1.11
log
@resolve conflicts
@
text
@d86 1
a86 1
			 "RIPEMD",
d270 1
a270 1
$crypto.=" fips/fips.h fips/rand/fips_rand.h";
d867 3
d1017 1
a1017 1
	my ($falsesum, $truesum) = (0, !grep(/^[^!]/,@@keywords));
d1085 1
a1085 1
			$truesum += &recognise($k,$platforms);
@


1.10
log
@merge 0.9.7d
@
text
@d82 1
a82 1
			"EXPORT_VAR_AS_FUNCTION" );
d97 1
a97 1
open(IN,"<Makefile.ssl") || die "unable to open Makefile.ssl!\n";
d112 1
d133 1
d270 1
d475 1
a475 1
			} elsif (/^\#\s*ifdef\s+(.*)/) {
d800 1
a800 1
		my $algs;
d870 1
d1035 3
d1129 1
a1129 1
   open MF, 'Makefile.ssl' or return $v;
@


1.9
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d1119 11
d1135 5
d1142 1
a1142 1
		{ $name.="32"; }
d1144 1
a1144 1
		{ $name.="16"; }
d1146 13
a1158 1
		{ $liboptions = "INITINSTANCE\nDATA NONSHARED"; }
d1165 1
a1165 1
LIBRARY         $name	$liboptions
d1167 1
a1167 1
DESCRIPTION     'OpenSSL $name - http://www.openssl.org/'
@


1.8
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d94 1
a94 1
			 "FP_API", "STDIO", "SOCK", "KRB5" );
d110 1
a110 1
my $no_ec;
d179 2
d240 1
a240 1
$crypto.=" crypto/engine/engine.h";
d443 4
d448 1
d822 1
a822 1
			} elsif (/\w+\W+(\w+)\W*\(\s*\)$/s) {
d826 4
a829 4
			} elsif (/\w+\W+\w+(\{[0-9]+\})?\W*\(.*\)$/s) {
				while (not /\(\)$/s) {
					s/[^\(\)]*\)$/\)/s;
					s/\([^\(\)]*\)\)$/\)/s;
d1062 2
@


1.7
log
@
enviroment -> environment
@
text
@d61 1
d77 1
d83 1
a83 1
my @@known_ossl_platforms = ( "VMS", "WIN16", "WIN32", "WINNT" );
d131 1
d134 4
a137 1
	$do_ssl=1 if $_ eq "ssl";
d139 4
a142 1
	$do_crypto=1 if $_ eq "crypto";
d182 9
d192 1
a192 1
if ($W32 + $W16 + $VMS == 0) {
d203 1
a203 1
	print STDERR "usage: $0 ( ssl | crypto ) [ 16 | 32 | NT ]\n";
d326 1
a326 1
	&print_def_file(*STDOUT,"SSLEAY",*ssl_list,@@ssl_symbols)
d329 1
a329 1
	&print_def_file(*STDOUT,"LIBEAY",*crypto_list,@@crypto_symbols)
d1016 1
d1114 1
d1118 1
a1118 1
	else
d1120 2
d1128 1
a1128 1
LIBRARY         $name
d1134 1
a1134 1
	if (!$W32) {
d1173 1
a1173 1
				if($v) {
d1176 1
a1176 1
					printf OUT "    %s%-39s @@%d\n",($W32)?"":"_",$s2,$n;
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d46 2
a47 2
#   enviroment.  For the negative items ("!FOO"), if any of them is false
#   (i.e. "FOO" is true) in the enviroment, the corresponding symbol can't be
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@d40 1
a40 1
#   symbol name replacements for platforms where the names are too long for the
d42 9
a50 9
#   clash.  This script assumes those redefinitions are place in the file
#   crypto/symhacks.h.
#   The semantics for the platforms list is a bit complicated.  The rule of
#   thumb is that the list is exclusive, but it seems to mean different things.
#   So, if the list is all negatives (like "!VMS,!WIN16"), the symbol exists
#   on all platforms except those listed.  If the list is all positives (like
#   "VMS,WIN16"), the symbol exists only on those platforms and nowhere else.
#   The combination of positives and negatives will act as if the positives
#   weren't there.
d57 2
d63 1
a63 1
my $do_rewrite = 0;
d68 1
a68 1
my $rsaref = 0;
d70 2
d79 3
a81 2
my @@known_platforms = ( "__FreeBSD__", "VMS", "WIN16", "WIN32",
			"WINNT", "PERL5", "NeXT" );
d83 10
a92 2
			 "CAST", "MD2", "MD4", "MD5", "SHA", "RIPEMD",
			 "MDC2", "RSA", "DSA", "DH", "HMAC", "FP_API" );
d107 2
a108 1
my $no_rsa; my $no_dsa; my $no_dh; my $no_hmac=0;
d113 1
d120 8
a128 1
	$rsaref=1 if $_ eq "rsaref";
d138 1
d157 1
d159 11
d185 1
a185 1
	print STDERR "usage: $0 ( ssl | crypto ) [ 16 | 32 | NT ] [rsaref]\n";
d195 1
d198 14
a211 13
$crypto.=" crypto/des/des.h" unless $no_des;
$crypto.=" crypto/idea/idea.h" unless $no_idea;
$crypto.=" crypto/rc4/rc4.h" unless $no_rc4;
$crypto.=" crypto/rc5/rc5.h" unless $no_rc5;
$crypto.=" crypto/rc2/rc2.h" unless $no_rc2;
$crypto.=" crypto/bf/blowfish.h" unless $no_bf;
$crypto.=" crypto/cast/cast.h" unless $no_cast;
$crypto.=" crypto/md2/md2.h" unless $no_md2;
$crypto.=" crypto/md4/md4.h" unless $no_md4;
$crypto.=" crypto/md5/md5.h" unless $no_md5;
$crypto.=" crypto/mdc2/mdc2.h" unless $no_mdc2;
$crypto.=" crypto/sha/sha.h" unless $no_sha;
$crypto.=" crypto/ripemd/ripemd.h" unless $no_ripemd;
d214 5
a218 4
$crypto.=" crypto/rsa/rsa.h" unless $no_rsa;
$crypto.=" crypto/dsa/dsa.h" unless $no_dsa;
$crypto.=" crypto/dh/dh.h" unless $no_dh;
$crypto.=" crypto/hmac/hmac.h" unless $no_hmac;
d221 5
a225 5
$crypto.=" crypto/stack/stack.h";
$crypto.=" crypto/buffer/buffer.h";
$crypto.=" crypto/bio/bio.h";
$crypto.=" crypto/dso/dso.h";
$crypto.=" crypto/lhash/lhash.h";
d229 1
a229 1
$crypto.=" crypto/evp/evp.h";
d234 1
d236 1
a236 1
$crypto.=" crypto/err/err.h";
d243 4
a246 1
$crypto.=" crypto/comp/comp.h";
a261 1
		close OUT;
d282 5
d326 3
a328 1
	my %rename;
d330 1
d334 1
d339 2
a340 1
			(map { "NO_".$_ => 0 } @@known_algorithms),
d348 54
d403 1
a403 1
			last if (/BEGIN ERROR CODES/);
d410 2
d424 3
a426 1
			if (/^\#\s*ifndef (.*)/) {
d429 20
a448 7
			} elsif (/^\#\s*if !defined\(([^\)]+)\)/) {
				push(@@tag,$1);
				$tag{$1}=-1;
			} elsif (/^\#\s*ifdef (.*)/) {
				push(@@tag,$1);
				$tag{$1}=1;
			} elsif (/^\#\s*if defined\(([^\)]+)\)/) {
d451 18
d470 7
a476 2
				if ($tag[$#tag] eq "NO_".$1) {
					$tag{$tag[$#tag]}=2;
d479 22
a500 4
				if ($tag{$tag[$#tag]}==2) {
					$tag{$tag[$#tag]}=-1;
				} else {
					$tag{$tag[$#tag]}=0;
d504 7
a510 2
				my $t=$tag[$#tag];
				$tag{$t}= -$tag{$t};
d512 1
d516 1
d518 1
d522 1
d524 5
a528 8
				 && $symhacking) {
				my $s = $1;
				my $a =
				    $2.":".join(",", grep(!/^$/,
							  map { $tag{$_} == 1 ?
								    $_ : "" }
							  @@known_platforms));
				$rename{$s} = $a;
d531 18
a548 8
				my @@p = grep(!/^$/,
					     map { $tag{$_} == 1 ? $_ :
						       $tag{$_} == -1 ? "!".$_  : "" }
					     @@known_platforms);
				my @@a = grep(!/^$/,
					     map { $tag{"NO_".$_} == -1 ? $_ : "" }
					     @@known_algorithms);
				$def .= "#INFO:".join(',',@@p).":".join(',',@@a).";";
d551 211
a761 73
			if (/^\s*DECLARE_STACK_OF\s*\(\s*(\w*)\s*\)/) {
				next;
			} elsif (/^\s*DECLARE_PKCS12_STACK_OF\s*\(\s*(\w*)\s*\)/) {
				next;
			} elsif (/^\s*DECLARE_ASN1_SET_OF\s*\(\s*(\w*)\s*\)/) {
				next;
			} elsif (/^DECLARE_PEM_rw\s*\(\s*(\w*)\s*,/ ||
				 /^DECLARE_PEM_rw_cb\s*\(\s*(\w*)\s*,/ ) {
				# Things not in Win16
				$syms{"PEM_read_${1}"} = 1;
				$platform{"PEM_read_${1}"} = "!WIN16";
				$syms{"PEM_write_${1}"} = 1;
				$platform{"PEM_write_${1}"} = "!WIN16";
				# Things that are everywhere
				$syms{"PEM_read_bio_${1}"} = 1;
				$syms{"PEM_write_bio_${1}"} = 1;
				if ($1 eq "RSAPrivateKey" ||
				    $1 eq "RSAPublicKey" ||
				    $1 eq "RSA_PUBKEY") {
					$algorithm{"PEM_read_${1}"} = "RSA";
					$algorithm{"PEM_write_${1}"} = "RSA";
					$algorithm{"PEM_read_bio_${1}"} = "RSA";
					$algorithm{"PEM_write_bio_${1}"} = "RSA";
				}
				elsif ($1 eq "DSAPrivateKey" ||
				       $1 eq "DSAparams" ||
				       $1 eq "RSA_PUBKEY") {
					$algorithm{"PEM_read_${1}"} = "DSA";
					$algorithm{"PEM_write_${1}"} = "DSA";
					$algorithm{"PEM_read_bio_${1}"} = "DSA";
					$algorithm{"PEM_write_bio_${1}"} = "DSA";
				}
				elsif ($1 eq "DHparams") {
					$algorithm{"PEM_read_${1}"} = "DH";
					$algorithm{"PEM_write_${1}"} = "DH";
					$algorithm{"PEM_read_bio_${1}"} = "DH";
					$algorithm{"PEM_write_bio_${1}"} = "DH";
				}
			} elsif (/^DECLARE_PEM_write\s*\(\s*(\w*)\s*,/ ||
				     /^DECLARE_PEM_write_cb\s*\(\s*(\w*)\s*,/ ) {
				# Things not in Win16
				$syms{"PEM_write_${1}"} = 1;
				$platform{"PEM_write_${1}"} .= ",!WIN16";
				# Things that are everywhere
				$syms{"PEM_write_bio_${1}"} = 1;
				if ($1 eq "RSAPrivateKey" ||
				    $1 eq "RSAPublicKey" ||
				    $1 eq "RSA_PUBKEY") {
					$algorithm{"PEM_write_${1}"} = "RSA";
					$algorithm{"PEM_write_bio_${1}"} = "RSA";
				}
				elsif ($1 eq "DSAPrivateKey" ||
				       $1 eq "DSAparams" ||
				       $1 eq "RSA_PUBKEY") {
					$algorithm{"PEM_write_${1}"} = "DSA";
					$algorithm{"PEM_write_bio_${1}"} = "DSA";
				}
				elsif ($1 eq "DHparams") {
					$algorithm{"PEM_write_${1}"} = "DH";
					$algorithm{"PEM_write_bio_${1}"} = "DH";
				}
			} elsif (/^DECLARE_PEM_read\s*\(\s*(\w*)\s*,/ ||
				     /^DECLARE_PEM_read_cb\s*\(\s*(\w*)\s*,/ ) {
				# Things not in Win16
				$syms{"PEM_read_${1}"} = 1;
				$platform{"PEM_read_${1}"} .= ",!WIN16";
				# Things that are everywhere
				$syms{"PEM_read_bio_${1}"} = 1;
			} elsif (
				($tag{'TRUE'} != -1)
				&& ($tag{'CONST_STRICT'} != 1)
				 )
				{
d769 1
d775 1
d784 1
d788 1
d790 1
a790 1
			} elsif (/^\s*OPENSSL_EXTERN\s.*?(\w+)(\[[0-9]*\])*\s*$/) {
d793 2
a794 1
			} elsif (/\(\*(\w*)\([^\)]+/) {
d796 1
d799 1
d801 1
a801 1
			} elsif (/\w+\W+\w+\W*\(.*\)$/s) {
d807 1
a807 1
				/(\w+)\W*\(\)/s;
d809 1
d840 2
a841 1
			$platform{$s} .= ','.$p;
d844 12
a855 8
			if (defined($rename{$s})) {
				(my $r, my $p) = split(/:/,$rename{$s});
				my @@ip = map { /^!(.*)$/ ? $1 : "!".$_ } split /,/, $p;
				$syms{$r} = 1;
				$kind{$r} = $kind{$s}."(".$s.")";
				$algorithm{$r} = $algorithm{$s};
				$platform{$r} = $platform{$s}.",".$p;
				$platform{$s} .= ','.join(',', @@ip).','.join(',', @@ip);
d857 1
a862 3
	$platform{"crypt"} .= ",!PERL5,!__FreeBSD__,!NeXT";

        delete $syms{"SSL_add_dir_cert_subjects_to_stack"};
a863 9

	$platform{"BIO_s_file_internal"} .= ",WIN16";
	$platform{"BIO_new_file_internal"} .= ",WIN16";
	$platform{"BIO_new_fp_internal"} .= ",WIN16";

	$platform{"BIO_s_file"} .= ",!WIN16";
	$platform{"BIO_new_file"} .= ",!WIN16";
	$platform{"BIO_new_fp"} .= ",!WIN16";

d866 4
a869 5
	if(exists $syms{"ERR_load_CRYPTO_strings"}) {
		$platform{"ERR_load_CRYPTO_strings"} .= ",!VMS,!WIN16";
		$syms{"ERR_load_CRYPTOlib_strings"} = 1;
		$platform{"ERR_load_CRYPTOlib_strings"} .= ",VMS,WIN16";
	}
a872 3
	$platform{"RSA_PKCS1_RSAref"} = "RSAREF";
	$algorithm{"RSA_PKCS1_RSAref"} = "RSA";

d878 4
d885 4
a888 5
sub info_string {
	(my $symbol, my $exist, my $platforms, my $kind, my $algorithms) = @@_;

	my %a = defined($algorithms) ?
	    map { $_ => 1 } split /,/, $algorithms : ();
a890 1
	my $k = defined($kind) ? $kind : "FUNCTION";
d893 2
d916 16
d935 1
a935 1
	$ret .= ":".join(',',map { $p{$_} < 0 ? "!".$_ : $_ } keys %p);
d937 1
a937 1
	$ret .= ":".join(',',keys %a);
d945 1
a949 1
		$i =~ s/^(.*?:.*?:\w+)(\(\w+\))?/$1/;
d951 1
d956 1
a956 1
				#print STDERR "DEBUG: maybe_add_info for $s: \"$dummy\" => \"$i\"\n";
d959 10
d980 74
d1056 1
a1056 1
	(*OUT,my $name,*nums,my @@symbols)=@@_;
d1060 2
a1061 2
	(@@e)=grep(/^SSLeay\\.*?:.*?:FUNCTION/,@@symbols);
	(@@r)=grep(/^\w+\\.*?:.*?:FUNCTION/ && !/^SSLeay\\.*?:.*?:FUNCTION/,@@symbols);
d1066 18
a1083 4
		if ($s ne $prev) {
			if (!defined($nums{$sym})) {
				printf STDERR "Warning: $sym does not have a number assigned\n"
						if(!$do_update);
d1085 1
a1085 2
				$n=$nums{$s};
				print OUT "\t$s();\n";
a1087 1
		$prev = $s;	# To avoid duplicates...
d1094 1
a1094 1
	my $n = 1; my @@e; my @@r;
d1127 4
a1130 3
	(@@e)=grep(/^SSLeay\\.*?:.*?:FUNCTION/,@@symbols);
	(@@r)=grep(/^\w+\\.*?:.*?:FUNCTION/ && !/^SSLeay\\.*?:.*?:FUNCTION/,@@symbols);
	@@symbols=((sort @@e),(sort @@r));
d1135 2
d1139 1
a1139 1
					if(!$do_update);
d1141 1
a1141 1
			(my $n, my $i) = split /\\/, $nums{$s};
d1143 13
a1155 61
			my @@p = split(/,/, ($i =~ /^[^:]*:([^:]*):/,$1));
			my @@a = split(/,/, ($i =~ /^[^:]*:[^:]*:[^:]*:([^:]*)/,$1));
			# @@p_purged must contain hardware platforms only
			my @@p_purged = ();
			foreach $ptmp (@@p) {
				next if $ptmp =~ /^!?RSAREF$/;
				push @@p_purged, $ptmp;
			}
			my $negatives = !!grep(/^!/,@@p);
			# It is very important to check NT before W32
			if ((($NT && (!@@p_purged
				      || (!$negatives && grep(/^WINNT$/,@@p))
				      || ($negatives && !grep(/^!WINNT$/,@@p))))
			     || ($W32 && (!@@p_purged
					  || (!$negatives && grep(/^WIN32$/,@@p))
					  || ($negatives && !grep(/^!WIN32$/,@@p))))
			     || ($W16 && (!@@p_purged
					  || (!$negatives && grep(/^WIN16$/,@@p))
					  || ($negatives && !grep(/^!WIN16$/,@@p)))))
			    && (!@@p
				|| (!$negatives
				    && ($rsaref || !grep(/^RSAREF$/,@@p)))
				|| ($negatives
				    && (!$rsaref || !grep(/^!RSAREF$/,@@p))))
			    && (!@@a || (!$no_rc2 || !grep(/^RC2$/,@@a)))
			    && (!@@a || (!$no_rc4 || !grep(/^RC4$/,@@a)))
			    && (!@@a || (!$no_rc5 || !grep(/^RC5$/,@@a)))
			    && (!@@a || (!$no_idea || !grep(/^IDEA$/,@@a)))
			    && (!@@a || (!$no_des || !grep(/^DES$/,@@a)))
			    && (!@@a || (!$no_bf || !grep(/^BF$/,@@a)))
			    && (!@@a || (!$no_cast || !grep(/^CAST$/,@@a)))
			    && (!@@a || (!$no_md2 || !grep(/^MD2$/,@@a)))
			    && (!@@a || (!$no_md4 || !grep(/^MD4$/,@@a)))
			    && (!@@a || (!$no_md5 || !grep(/^MD5$/,@@a)))
			    && (!@@a || (!$no_sha || !grep(/^SHA$/,@@a)))
			    && (!@@a || (!$no_ripemd || !grep(/^RIPEMD$/,@@a)))
			    && (!@@a || (!$no_mdc2 || !grep(/^MDC2$/,@@a)))
			    && (!@@a || (!$no_rsa || !grep(/^RSA$/,@@a)))
			    && (!@@a || (!$no_dsa || !grep(/^DSA$/,@@a)))
			    && (!@@a || (!$no_dh || !grep(/^DH$/,@@a)))
			    && (!@@a || (!$no_hmac || !grep(/^HMAC$/,@@a)))
			    && (!@@a || (!$no_fp_api || !grep(/^FP_API$/,@@a)))
			    ) {
				printf OUT "    %s%-40s@@%d\n",($W32)?"":"_",$s,$n;
#			} else {
#				print STDERR "DEBUG: \"$sym\" (@@p):",
#				" rsaref:", !!(!@@p
#					       || (!$negatives
#						   && ($rsaref || !grep(/^RSAREF$/,@@p)))
#					       || ($negatives
#						   && (!$rsaref || !grep(/^!RSAREF$/,@@p))))?1:0,
#				" 16:", !!($W16 && (!@@p_purged
#						    || (!$negatives && grep(/^WIN16$/,@@p))
#						    || ($negatives && !grep(/^!WIN16$/,@@p)))),
#				" 32:", !!($W32 && (!@@p_purged
#						    || (!$negatives && grep(/^WIN32$/,@@p))
#						    || ($negatives && !grep(/^!WIN32$/,@@p)))),
#				" NT:", !!($NT && (!@@p_purged
#						   || (!$negatives && grep(/^WINNT$/,@@p))
#						   || ($negatives && !grep(/^!WINNT$/,@@p)))),
#				"\n";
d1170 1
d1179 2
a1180 1
			print STDERR "Warning: Symbol '",$a[0],"' redefined. old=",$ret{$a[0]},", new=",$a[1],"\n";
d1185 1
a1185 1
		if ($max_num == $a[1]) {
d1188 7
d1236 1
a1236 1
	my @@r = grep(/^\w+\\.*?:.*?:\w+\(\w+\)/,@@symbols);
d1246 10
a1255 1
	my @@s=sort { &parse_number($nums{$a},"n") <=> &parse_number($nums{$b},"n") } keys %nums;
d1260 6
a1265 2
		$i="NOEXIST::FUNCTION:" if !defined($i) || $i eq "";
		printf OUT "%s%-40s%d\t%s\n","",$sym,$n,$i;
d1268 3
a1270 1
			printf OUT "%s%-40s%d\t%s\n","",$s,$n,$i;
d1282 1
a1282 1
	my @@r = grep(/^\w+\\.*?:.*?:\w+\(\w+\)/,@@symbols);
d1300 3
a1302 1
			printf OUT "%s%-40s%d\t%s\n","",$s, ++$start_num,$i;
d1305 2
a1306 1
				printf OUT "%s%-40s%d\t%s\n","",$s, $start_num,$i;
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d122 1
a122 1
	elsif (/^no-des$/)      { $no_des=1; }
d708 2
a709 1
			my @@p = split(/,/, ($i =~ /^.*?:(.*?):/,$1));
d731 20
a750 1
				    && (!$rsaref || !grep(/^!RSAREF$/,@@p))))) {
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d8 48
d57 2
a58 2
my $crypto_num="util/libeay.num";
my $ssl_num=   "util/ssleay.num";
d61 1
d65 1
d68 3
a70 1
my $W32=1;
d73 7
a79 1
my $safe_stack_def = 1;
d92 2
a93 1
my $no_cast; my $no_md2; my $no_md5; my $no_sha; my $no_ripemd; my $no_mdc2;
d95 1
d100 1
a100 1
	$W32=0 if $_ eq "16";
d105 3
d113 1
d115 2
a116 1
	$rsaref=1 if $_ eq "rsaref";
d126 1
d138 10
d170 1
d182 1
d186 1
d207 1
a207 2
my @@ssl_func = &do_defs("SSLEAY", $ssl);
my @@crypto_func = &do_defs("LIBEAY", $crypto);
d209 2
d215 10
a224 2
	open(OUT, ">>$ssl_num");
	&update_numbers(*OUT,"SSLEAY",*ssl_list,$max_ssl, @@ssl_func);
d229 9
a237 2
	open(OUT, ">>$crypto_num");
	&update_numbers(*OUT,"LIBEAY",*crypto_list,$max_crypto, @@crypto_func);
d241 1
a241 1
} elsif ($do_ctest) {
d252 1
a252 1
	&print_test_file(*STDOUT,"SSLEAY",*ssl_list,@@ssl_func)
d255 1
a255 1
	&print_test_file(*STDOUT,"LIBEAY",*crypto_list,@@crypto_func)
d262 1
a262 1
	&print_def_file(*STDOUT,"SSLEAY",*ssl_list,@@ssl_func)
d265 1
a265 1
	&print_def_file(*STDOUT,"LIBEAY",*crypto_list,@@crypto_func)
d273 1
a273 1
	my($name,$files)=@@_;
d276 5
a280 1
	my %funcs;
d283 1
a283 1
	foreach $file (split(/\s+/,$files))
d288 2
a289 1
			FreeBSD		=> 0,
a290 1
			WIN16		=> 0,
a292 1
			NO_FP_API	=> 0,
a294 16
			NO_RC2		=> 0,
			NO_RC4		=> 0,
			NO_RC5		=> 0,
			NO_IDEA		=> 0,
			NO_DES		=> 0,
			NO_BF		=> 0,
			NO_CAST		=> 0,
			NO_MD2		=> 0,
			NO_MD5		=> 0,
			NO_SHA		=> 0,
			NO_RIPEMD	=> 0,
			NO_MDC2		=> 0,
			NO_RSA		=> 0,
			NO_DSA		=> 0,
			NO_DH		=> 0,
			NO_HMAC		=> 0,
d296 1
d309 1
a309 1
	    		$cpp = 1 if /^#.*ifdef.*cplusplus/;
d311 1
a311 1
				$cpp = 0 if /^#.*endif/;
a319 1
				next;
a322 1
				next;
d326 1
a326 2
				next;
			} elsif (/^\#\s*if defined(.*)/) {
d329 4
a332 1
				next;
d334 5
a338 1
				$tag{$tag[$#tag]}=0;
a339 1
				next;
a342 1
				next;
a346 1
				next;
d351 22
d374 3
a376 1
			} elsif (/^\#/) {
a377 26
			}
			if ($safe_stack_def &&
				/^\s*DECLARE_STACK_OF\s*\(\s*(\w*)\s*\)/) {
				$funcs{"sk_${1}_new"} = 1;
				$funcs{"sk_${1}_new_null"} = 1;
				$funcs{"sk_${1}_free"} = 1;
				$funcs{"sk_${1}_num"} = 1;
				$funcs{"sk_${1}_value"} = 1;
				$funcs{"sk_${1}_set"} = 1;
				$funcs{"sk_${1}_zero"} = 1;
				$funcs{"sk_${1}_push"} = 1;
				$funcs{"sk_${1}_unshift"} = 1;
				$funcs{"sk_${1}_find"} = 1;
				$funcs{"sk_${1}_delete"} = 1;
				$funcs{"sk_${1}_delete_ptr"} = 1;
				$funcs{"sk_${1}_insert"} = 1;
				$funcs{"sk_${1}_set_cmp_func"} = 1;
				$funcs{"sk_${1}_dup"} = 1;
				$funcs{"sk_${1}_pop_free"} = 1;
				$funcs{"sk_${1}_shift"} = 1;
				$funcs{"sk_${1}_pop"} = 1;
				$funcs{"sk_${1}_sort"} = 1;
			} elsif ($safe_stack_def &&
				/^\s*DECLARE_ASN1_SET_OF\s*\(\s*(\w*)\s*\)/) {
				$funcs{"d2i_ASN1_SET_OF_${1}"} = 1;
				$funcs{"i2d_ASN1_SET_OF_${1}"} = 1;
d379 30
a408 4
				     /^DECLARE_PEM_rw_cb\s*\(\s*(\w*)\s*,/ ) {
				if($W32) {
					$funcs{"PEM_read_${1}"} = 1;
					$funcs{"PEM_write_${1}"} = 1;
a409 2
				$funcs{"PEM_read_bio_${1}"} = 1;
				$funcs{"PEM_write_bio_${1}"} = 1;
d412 20
a431 2
				if($W32) {
					$funcs{"PEM_write_${1}"} = 1;
a432 1
				$funcs{"PEM_write_bio_${1}"} = 1;
d435 5
a439 4
				if($W32) {
					$funcs{"PEM_read_${1}"} = 1;
				}
				$funcs{"PEM_read_bio_${1}"} = 1;
d441 3
a443 27
				($tag{'TRUE'} != -1) &&
				($tag{'FreeBSD'} != 1) &&
				($tag{'CONST_STRICT'} != 1) &&
				(($W32 && ($tag{'WIN16'} != 1)) ||
				 (!$W32 && ($tag{'WIN16'} != -1))) &&
				($tag{'PERL5'} != 1) &&
#				($tag{'_WINDLL'} != -1) &&
				((!$W32 && $tag{'_WINDLL'} != -1) ||
				 ($W32 && $tag{'_WINDLL'} != 1)) &&
				((($tag{'NO_FP_API'} != 1) && $W32) ||
				 (($tag{'NO_FP_API'} != -1) && !$W32)) &&
				($tag{'NO_RC2'} == 0  || !$no_rc2) &&
				($tag{'NO_RC4'} == 0  || !$no_rc4) &&
				($tag{'NO_RC5'} == 0  || !$no_rc5) &&
				($tag{'NO_IDEA'} == 0 || !$no_idea) &&
				($tag{'NO_DES'} == 0  || !$no_des) &&
				($tag{'NO_BF'} == 0   || !$no_bf) &&
				($tag{'NO_CAST'} == 0 || !$no_cast) &&
				($tag{'NO_MD2'} == 0  || !$no_md2) &&
				($tag{'NO_MD5'} == 0  || !$no_md5) &&
				($tag{'NO_SHA'} == 0  || !$no_sha) &&
				($tag{'NO_RIPEMD'} == 0 || !$no_ripemd) &&
				($tag{'NO_MDC2'} == 0 || !$no_mdc2) &&
				($tag{'NO_RSA'} == 0  || !$no_rsa) &&
				($tag{'NO_DSA'} == 0  || !$no_dsa) &&
				($tag{'NO_DH'} == 0   || !$no_dh) &&
				($tag{'NO_HMAC'} == 0 || !$no_hmac))
d445 1
a445 1
					if (/{|\/\*/) { # }
d454 3
d458 1
d461 1
d463 11
a473 14
			next if(/EVP_bf/ and $no_bf);
			next if(/EVP_cast/ and $no_cast);
			next if(/EVP_des/ and $no_des);
			next if(/EVP_dss/ and $no_dsa);
			next if(/EVP_idea/ and $no_idea);
			next if(/EVP_md2/ and $no_md2);
			next if(/EVP_md5/ and $no_md5);
			next if(/EVP_rc2/ and $no_rc2);
			next if(/EVP_rc4/ and $no_rc4);
			next if(/EVP_rc5/ and $no_rc5);
			next if(/EVP_ripemd/ and $no_ripemd);
			next if(/EVP_sha/ and $no_sha);
			if (/\(\*(\w*)\([^\)]+/) {
				$funcs{$1} = 1;
d484 1
a484 1
				$funcs{$1} = 1;
d487 39
d530 35
a564 1
	# Prune the returned functions
d566 24
a589 12
        delete $funcs{"SSL_add_dir_cert_subjects_to_stack"};
        delete $funcs{"RSA_PKCS1_RSAref"} unless $rsaref;
        delete $funcs{"bn_dump1"};

	if($W32) {
		delete $funcs{"BIO_s_file_internal"};
		delete $funcs{"BIO_new_file_internal"};
		delete $funcs{"BIO_new_fp_internal"};
	} else {
		if(exists $funcs{"ERR_load_CRYPTO_strings"}) {
			delete $funcs{"ERR_load_CRYPTO_strings"};
			$funcs{"ERR_load_CRYPTOlib_strings"} = 1;
a590 3
		delete $funcs{"BIO_s_file"};
		delete $funcs{"BIO_new_file"};
		delete $funcs{"BIO_new_fp"};
d592 2
a593 2
	if (!$NT) {
		delete $funcs{"BIO_s_log"};
d596 9
a604 1
	push @@ret, keys %funcs;
d606 26
a631 1
	return(@@ret);
d636 1
a636 1
	(*OUT,my $name,*nums,my @@functions)=@@_;
d638 1
a638 1
	my $func;
d640 14
a653 11
	(@@e)=grep(/^SSLeay/,@@functions);
	(@@r)=grep(!/^SSLeay/,@@functions);
	@@functions=((sort @@e),(sort @@r));

	foreach $func (@@functions) {
		if (!defined($nums{$func})) {
			printf STDERR "$func does not have a number assigned\n"
					if(!$do_update);
		} else {
			$n=$nums{$func};
			print OUT "\t$func();\n";
d655 1
d661 1
a661 1
	(*OUT,my $name,*nums,my @@functions)=@@_;
d695 3
d699 5
a703 7
	(@@e)=grep(/^SSLeay/,@@functions);
	(@@r)=grep(!/^SSLeay/,@@functions);
	@@functions=((sort @@e),(sort @@r));

	foreach $func (@@functions) {
		if (!defined($nums{$func})) {
			printf STDERR "$func does not have a number assigned\n"
d706 44
a749 2
			$n=$nums{$func};
			printf OUT "    %s%-40s@@%d\n",($W32)?"":"_",$func,$n;
d761 2
d770 17
a786 1
		$ret{$a[0]}=$a[1];
d788 9
d802 42
d846 28
a873 7
	(*OUT,$name,*nums,my $start_num, my @@functions)=@@_;
	my $new_funcs = 0;
	print STDERR "Updating $name\n";
	foreach $func (@@functions) {
		if (!exists $nums{$func}) {
			$new_funcs++;
			printf OUT "%s%-40s%d\n","",$func, ++$start_num;
d876 2
a877 2
	if($new_funcs) {
		print STDERR "$new_funcs New Functions added\n";
d879 23
a901 1
		print STDERR "No New Functions Added\n";
d904 1
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d9 2
a10 2
$crypto_num="util/libeay.num";
$ssl_num=   "util/ssleay.num";
d15 2
a16 1
$rsaref = 0;
d18 2
a19 2
$W32=1;
$NT=0;
d21 1
a21 1
$safe_stack_def = 1;
d23 1
a23 1
$options="";
d30 7
d50 1
d71 1
d83 1
a83 1
$ssl="ssl/ssl.h";
d85 1
a85 1
$crypto ="crypto/crypto.h";
d128 2
a129 2
@@ssl_func = &do_defs("SSLEAY", $ssl);
@@crypto_func = &do_defs("LIBEAY", $crypto);
d144 20
a163 1
}
d179 1
d182 1
d187 1
a187 2

		my $line = "", $def= "";
d197 16
d263 5
d304 14
a317 1
			} elsif ( 
d327 17
a343 1
				 (($tag{'NO_FP_API'} != -1) && !$W32)))
a391 1
        delete $funcs{"des_crypt"};
d393 1
d417 21
d440 2
a441 2
	(*OUT,my $name,*nums,@@functions)=@@_;
	my $n =1;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#!/usr/bin/perl
d6 1
a6 1
# non-prototyped functions.
d12 18
a29 2
$NT=1;
foreach (@@ARGV)
d31 6
a36 2
	$NT=1 if $_ eq "32";
	$NT=0 if $_ eq "16";
d38 1
d40 20
d64 1
a64 1
	print STDERR "usage: $0 ( ssl | crypto ) [ 16 | 32 ]\n";
d69 1
d71 1
d76 12
a87 12
$crypto.=" crypto/des/des.h";
$crypto.=" crypto/idea/idea.h";
$crypto.=" crypto/rc4/rc4.h";
$crypto.=" crypto/rc5/rc5.h";
$crypto.=" crypto/rc2/rc2.h";
$crypto.=" crypto/bf/blowfish.h";
$crypto.=" crypto/cast/cast.h";
$crypto.=" crypto/md2/md2.h";
$crypto.=" crypto/md5/md5.h";
$crypto.=" crypto/mdc2/mdc2.h";
$crypto.=" crypto/sha/sha.h";
$crypto.=" crypto/ripemd/ripemd.h";
d90 4
a93 3
$crypto.=" crypto/rsa/rsa.h";
$crypto.=" crypto/dsa/dsa.h";
$crypto.=" crypto/dh/dh.h";
d110 1
d113 1
d115 22
a136 1
$crypto.=" crypto/hmac/hmac.h";
d138 2
a139 2
$match{'NOPROTO'}=1;
$match2{'PERL5'}=1;
d141 4
a144 2
&print_def_file(*STDOUT,"SSLEAY",*ssl_list,&do_defs("SSLEAY",$ssl))
	if $do_ssl == 1;
a145 2
&print_def_file(*STDOUT,"LIBEAY",*crypto_list,&do_defs("LIBEAY",$crypto))
	if $do_crypto == 1;
d148 4
a151 3
	{
	local($name,$files)=@@_;
	local(@@ret);
a152 1
	$off=-1;
a154 1
#		print STDERR "reading $file\n";
d156 22
a177 11
		$depth=0;
		$pr=-1;
		@@np="";
		$/=undef;
		$a=<IN>;
		while (($i=index($a,"/*")) >= 0)
			{
			$j=index($a,"*/");
			break unless ($j >= 0);
			$a=substr($a,0,$i).substr($a,$j+2);
		#	print "$i $j\n";
d179 10
a188 4
		foreach (split("\n",$a))
			{
			if (/^\#\s*ifndef (.*)/)
				{
d192 1
a192 3
				}
			elsif (/^\#\s*if !defined\(([^\)]+)\)/)
				{
d196 1
a196 3
				}
			elsif (/^\#\s*ifdef (.*)/)
				{
d200 1
a200 3
				}
			elsif (/^\#\s*if defined(.*)/)
				{
d204 1
a204 3
				}
			elsif (/^\#\s*endif/)
				{
d208 2
a209 4
				}
			elsif (/^\#\s*else/)
				{
				$t=$tag[$#tag];
d212 38
d251 3
a253 7
#printf STDERR "$_\n%2d %2d %2d %2d %2d $NT\n",
#$tag{'NOPROTO'},$tag{'FreeBSD'},$tag{'WIN16'},$tag{'PERL5'},$tag{'NO_FP_API'};

			$t=undef;
			if (/^extern .*;$/)
				{ $t=&do_extern($name,$_); }
			elsif (	($tag{'NOPROTO'} == 1) &&
d255 3
a257 2
				(($NT && ($tag{'WIN16'} != 1)) ||
				 (!$NT && ($tag{'WIN16'} != -1))) &&
d260 4
a263 8
				((!$NT && $tag{'_WINDLL'} != -1) ||
				 ($NT && $tag{'_WINDLL'} != 1)) &&
				((($tag{'NO_FP_API'} != 1) && $NT) ||
				 (($tag{'NO_FP_API'} != -1) && !$NT)))
				{ $t=&do_line($name,$_); }
			else
				{ $t=undef; }
			if (($t ne undef) && (!$done{$name,$t}))
d265 5
a269 3
				$done{$name,$t}++;
				push(@@ret,$t);
#printf STDERR "one:$t\n" if $t =~ /BIO_/;
d273 33
a306 1
	return(@@ret);
d309 1
a309 4
sub do_line
	{
	local($file,$_)=@@_;
	local($n);
d311 12
a322 31
	return(undef) if /^$/;
	return(undef) if /^\s/;
#printf STDERR "two:$_\n" if $_ =~ /BIO_/;
	if (/(CRYPTO_get_locking_callback)/)
		{ return($1); }
	elsif (/(CRYPTO_get_id_callback)/)
		{ return($1); }
	elsif (/(CRYPTO_get_add_lock_callback)/)
		{ return($1); }
	elsif (/(SSL_CTX_get_verify_callback)/)
		{ return($1); }
	elsif (/(SSL_get_info_callback)/)
		{ return($1); }
	elsif ((!$NT) && /(ERR_load_CRYPTO_strings)/)
		{ return("ERR_load_CRYPTOlib_strings"); }
	elsif (!$NT && /BIO_s_file/)
		{ return(undef); }
	elsif (!$NT && /BIO_new_file/)
		{ return(undef); }
	elsif (!$NT && /BIO_new_fp/)
		{ return(undef); }
	elsif ($NT && /BIO_s_file_internal/)
		{ return(undef); }
	elsif ($NT && /BIO_new_file_internal/)
		{ return(undef); }
	elsif ($NT && /BIO_new_fp_internal/)
		{ return(undef); }
	else
		{
		/\s\**(\S+)\s*\(/;
		return($1);
d324 6
d332 1
a332 4
sub do_extern
	{
	local($file,$_)=@@_;
	local($n);
d334 2
a335 3
	/\s\**(\S+);$/;
	return($1);
	}
d338 3
a340 3
	{
	local(*OUT,$name,*nums,@@functions)=@@_;
	local($n)=1;
d342 1
a342 1
	if ($NT)
d349 1
a349 1
; Definition file for the DDL version of the $name library from SSLeay
d354 1
a354 1
DESCRIPTION     'SSLeay $name - eay\@@cryptsoft.com'
d358 1
a358 2
	if (!$NT)
		{
d369 1
a369 1
		}
d378 5
a382 8
	foreach $func (@@functions)
		{
		if (!defined($nums{$func}))
			{
			printf STDERR "$func does not have a number assigned\n";
			}
		else
			{
d384 1
a384 2
			printf OUT "    %s%-35s@@%d\n",($NT)?"":"_",$func,$n;
			}
d386 1
d388 1
a388 1
	}
d391 5
a395 3
	{
	local($name)=@@_;
	local($j,@@a,%ret);
d398 1
a398 2
	while (<IN>)
		{
d404 2
a405 1
		}
d408 17
d426 1
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d1 1
a1 1
#!/usr/local/bin/perl -w
d6 1
a6 1
# prototyped functions: it then prunes the output.
a7 50
# Intermediary files are created, call libeay.num and ssleay.num,...
# Previously, they had the following format:
#
#	routine-name	nnnn
#
# But that isn't enough for a number of reasons, the first on being that
# this format is (needlessly) very Win32-centric, and even then...
# One of the biggest problems is that there's no information about what
# routines should actually be used, which varies with what crypto algorithms
# are disabled.  Also, some operating systems (for example VMS with VAX C)
# need to keep track of the global variables as well as the functions.
#
# So, a remake of this script is done so as to include information on the
# kind of symbol it is (function or variable) and what algorithms they're
# part of.  This will allow easy translating to .def files or the corresponding
# file in other operating systems (a .opt file for VMS, possibly with a .mar
# file).
#
# The format now becomes:
#
#	routine-name	nnnn	info
#
# and the "info" part is actually a colon-separated string of fields with
# the following meaning:
#
#	existence:platform:kind:algorithms
#
# - "existence" can be "EXIST" or "NOEXIST" depending on if the symbol is
#   found somewhere in the source, 
# - "platforms" is empty if it exists on all platforms, otherwise it contains
#   comma-separated list of the platform, just as they are if the symbol exists
#   for those platforms, or prepended with a "!" if not.  This helps resolve
#   symbol name variants for platforms where the names are too long for the
#   compiler or linker, or if the systems is case insensitive and there is a
#   clash, or the symbol is implemented differently (see
#   EXPORT_VAR_AS_FUNCTION).  This script assumes renaming of symbols is found
#   in the file crypto/symhacks.h.
#   The semantics for the platforms is that every item is checked against the
#   enviroment.  For the negative items ("!FOO"), if any of them is false
#   (i.e. "FOO" is true) in the enviroment, the corresponding symbol can't be
#   used.  For the positive itms, if all of them are false in the environment,
#   the corresponding symbol can't be used.  Any combination of positive and
#   negative items are possible, and of course leave room for some redundancy.
# - "kind" is "FUNCTION" or "VARIABLE".  The meaning of that is obvious.
# - "algorithms" is a comma-separated list of algorithm names.  This helps
#   exclude symbols that are part of an algorithm that some user wants to
#   exclude.
#

my $debug=0;
d9 2
a10 2
my $crypto_num= "util/libeay.num";
my $ssl_num=    "util/ssleay.num";
d12 2
a13 50
my $do_update = 0;
my $do_rewrite = 1;
my $do_crypto = 0;
my $do_ssl = 0;
my $do_ctest = 0;
my $do_ctestall = 0;
my $do_checkexist = 0;

my $VMSVAX=0;
my $VMSAlpha=0;
my $VMS=0;
my $W32=0;
my $W16=0;
my $NT=0;
# Set this to make typesafe STACK definitions appear in DEF
my $safe_stack_def = 0;

my @@known_platforms = ( "__FreeBSD__", "PERL5", "NeXT",
			"EXPORT_VAR_AS_FUNCTION" );
my @@known_ossl_platforms = ( "VMS", "WIN16", "WIN32", "WINNT" );
my @@known_algorithms = ( "RC2", "RC4", "RC5", "IDEA", "DES", "BF",
			 "CAST", "MD2", "MD4", "MD5", "SHA", "SHA0", "SHA1",
			 "RIPEMD",
			 "MDC2", "RSA", "DSA", "DH", "EC", "HMAC", "AES",
			 # Envelope "algorithms"
			 "EVP", "X509", "ASN1_TYPEDEFS",
			 # Helper "algorithms"
			 "BIO", "COMP", "BUFFER", "LHASH", "STACK", "ERR",
			 "LOCKING",
			 # External "algorithms"
			 "FP_API", "STDIO", "SOCK", "KRB5" );

my $options="";
open(IN,"<Makefile.ssl") || die "unable to open Makefile.ssl!\n";
while(<IN>) {
    $options=$1 if (/^OPTIONS=(.*)$/);
}
close(IN);

# The following ciphers may be excluded (by Configure). This means functions
# defined with ifndef(NO_XXX) are not included in the .def file, and everything
# in directory xxx is ignored.
my $no_rc2; my $no_rc4; my $no_rc5; my $no_idea; my $no_des; my $no_bf;
my $no_cast;
my $no_md2; my $no_md4; my $no_md5; my $no_sha; my $no_ripemd; my $no_mdc2;
my $no_rsa; my $no_dsa; my $no_dh; my $no_hmac=0; my $no_aes; my $no_krb5;
my $no_ec;
my $no_fp_api;

foreach (@@ARGV, split(/ /, $options))
d15 2
a16 17
	$debug=1 if $_ eq "debug";
	$W32=1 if $_ eq "32";
	$W16=1 if $_ eq "16";
	if($_ eq "NT") {
		$W32 = 1;
		$NT = 1;
	}
	if ($_ eq "VMS-VAX") {
		$VMS=1;
		$VMSVAX=1;
	}
	if ($_ eq "VMS-Alpha") {
		$VMS=1;
		$VMSAlpha=1;
	}
	$VMS=1 if $_ eq "VMS";

a17 1
	$do_ssl=1 if $_ eq "ssl";
a18 37
	$do_crypto=1 if $_ eq "crypto";
	$do_update=1 if $_ eq "update";
	$do_rewrite=1 if $_ eq "rewrite";
	$do_ctest=1 if $_ eq "ctest";
	$do_ctestall=1 if $_ eq "ctestall";
	$do_checkexist=1 if $_ eq "exist";
	#$safe_stack_def=1 if $_ eq "-DDEBUG_SAFESTACK";

	if    (/^no-rc2$/)      { $no_rc2=1; }
	elsif (/^no-rc4$/)      { $no_rc4=1; }
	elsif (/^no-rc5$/)      { $no_rc5=1; }
	elsif (/^no-idea$/)     { $no_idea=1; }
	elsif (/^no-des$/)      { $no_des=1; $no_mdc2=1; }
	elsif (/^no-bf$/)       { $no_bf=1; }
	elsif (/^no-cast$/)     { $no_cast=1; }
	elsif (/^no-md2$/)      { $no_md2=1; }
	elsif (/^no-md4$/)      { $no_md4=1; }
	elsif (/^no-md5$/)      { $no_md5=1; }
	elsif (/^no-sha$/)      { $no_sha=1; }
	elsif (/^no-ripemd$/)   { $no_ripemd=1; }
	elsif (/^no-mdc2$/)     { $no_mdc2=1; }
	elsif (/^no-rsa$/)      { $no_rsa=1; }
	elsif (/^no-dsa$/)      { $no_dsa=1; }
	elsif (/^no-dh$/)       { $no_dh=1; }
	elsif (/^no-ec$/)       { $no_ec=1; }
	elsif (/^no-hmac$/)	{ $no_hmac=1; }
	elsif (/^no-aes$/)	{ $no_aes=1; }
	elsif (/^no-evp$/)	{ $no_evp=1; }
	elsif (/^no-lhash$/)	{ $no_lhash=1; }
	elsif (/^no-stack$/)	{ $no_stack=1; }
	elsif (/^no-err$/)	{ $no_err=1; }
	elsif (/^no-buffer$/)	{ $no_buffer=1; }
	elsif (/^no-bio$/)	{ $no_bio=1; }
	#elsif (/^no-locking$/)	{ $no_locking=1; }
	elsif (/^no-comp$/)	{ $no_comp=1; }
	elsif (/^no-dso$/)	{ $no_dso=1; }
	elsif (/^no-krb5$/)	{ $no_krb5=1; }
a20 11

# If no platform is given, assume WIN32
if ($W32 + $W16 + $VMS == 0) {
	$W32 = 1;
}

# Add extra knowledge
if ($W16) {
	$no_fp_api=1;
}

d23 1
a23 1
	print STDERR "usage: $0 ( ssl | crypto ) [ 16 | 32 | NT ]\n";
a27 1
$max_ssl = $max_num;
a28 1
$max_crypto = $max_num;
d30 1
a30 2
my $ssl="ssl/ssl.h";
$ssl.=" ssl/kssl.h";
d32 13
a44 15
my $crypto ="crypto/crypto.h";
$crypto.=" crypto/des/des.h crypto/des/des_old.h" ; # unless $no_des;
$crypto.=" crypto/idea/idea.h" ; # unless $no_idea;
$crypto.=" crypto/rc4/rc4.h" ; # unless $no_rc4;
$crypto.=" crypto/rc5/rc5.h" ; # unless $no_rc5;
$crypto.=" crypto/rc2/rc2.h" ; # unless $no_rc2;
$crypto.=" crypto/bf/blowfish.h" ; # unless $no_bf;
$crypto.=" crypto/cast/cast.h" ; # unless $no_cast;
$crypto.=" crypto/md2/md2.h" ; # unless $no_md2;
$crypto.=" crypto/md4/md4.h" ; # unless $no_md4;
$crypto.=" crypto/md5/md5.h" ; # unless $no_md5;
$crypto.=" crypto/mdc2/mdc2.h" ; # unless $no_mdc2;
$crypto.=" crypto/sha/sha.h" ; # unless $no_sha;
$crypto.=" crypto/ripemd/ripemd.h" ; # unless $no_ripemd;
$crypto.=" crypto/aes/aes.h" ; # unless $no_aes;
d47 8
a54 12
$crypto.=" crypto/rsa/rsa.h" ; # unless $no_rsa;
$crypto.=" crypto/dsa/dsa.h" ; # unless $no_dsa;
$crypto.=" crypto/dh/dh.h" ; # unless $no_dh;
$crypto.=" crypto/ec/ec.h" ; # unless $no_ec;
$crypto.=" crypto/hmac/hmac.h" ; # unless $no_hmac;

$crypto.=" crypto/engine/engine.h";
$crypto.=" crypto/stack/stack.h" ; # unless $no_stack;
$crypto.=" crypto/buffer/buffer.h" ; # unless $no_buffer;
$crypto.=" crypto/bio/bio.h" ; # unless $no_bio;
$crypto.=" crypto/dso/dso.h" ; # unless $no_dso;
$crypto.=" crypto/lhash/lhash.h" ; # unless $no_lhash;
d58 1
a58 1
$crypto.=" crypto/evp/evp.h" ; # unless $no_evp;
a62 1
$crypto.=" crypto/asn1/asn1t.h";
d64 1
a64 1
$crypto.=" crypto/err/err.h" ; # unless $no_err;
a65 1
$crypto.=" crypto/pkcs12/pkcs12.h";
a67 1
$crypto.=" crypto/x509v3/x509v3.h";
d69 1
a69 51
$crypto.=" crypto/comp/comp.h" ; # unless $no_comp;
$crypto.=" crypto/ocsp/ocsp.h";
$crypto.=" crypto/ui/ui.h crypto/ui/ui_compat.h";
$crypto.=" crypto/krb5/krb5_asn.h";
$crypto.=" crypto/tmdiff.h";

my $symhacks="crypto/symhacks.h";

my @@ssl_symbols = &do_defs("SSLEAY", $ssl, $symhacks);
my @@crypto_symbols = &do_defs("LIBEAY", $crypto, $symhacks);

if ($do_update) {

if ($do_ssl == 1) {

	&maybe_add_info("SSLEAY",*ssl_list,@@ssl_symbols);
	if ($do_rewrite == 1) {
		open(OUT, ">$ssl_num");
		&rewrite_numbers(*OUT,"SSLEAY",*ssl_list,@@ssl_symbols);
	} else {
		open(OUT, ">>$ssl_num");
	}
	&update_numbers(*OUT,"SSLEAY",*ssl_list,$max_ssl,@@ssl_symbols);
	close OUT;
}

if($do_crypto == 1) {

	&maybe_add_info("LIBEAY",*crypto_list,@@crypto_symbols);
	if ($do_rewrite == 1) {
		open(OUT, ">$crypto_num");
		&rewrite_numbers(*OUT,"LIBEAY",*crypto_list,@@crypto_symbols);
	} else {
		open(OUT, ">>$crypto_num");
	}
	&update_numbers(*OUT,"LIBEAY",*crypto_list,$max_crypto,@@crypto_symbols);
	close OUT;
} 

} elsif ($do_checkexist) {
	&check_existing(*ssl_list, @@ssl_symbols)
		if $do_ssl == 1;
	&check_existing(*crypto_list, @@crypto_symbols)
		if $do_crypto == 1;
} elsif ($do_ctest || $do_ctestall) {

	print <<"EOF";

/* Test file to check all DEF file symbols are present by trying
 * to link to all of them. This is *not* intended to be run!
 */
d71 2
a72 15
int main()
{
EOF
	&print_test_file(*STDOUT,"SSLEAY",*ssl_list,$do_ctestall,@@ssl_symbols)
		if $do_ssl == 1;

	&print_test_file(*STDOUT,"LIBEAY",*crypto_list,$do_ctestall,@@crypto_symbols)
		if $do_crypto == 1;

	print "}\n";

} else {

	&print_def_file(*STDOUT,"SSLEAY",*ssl_list,@@ssl_symbols)
		if $do_ssl == 1;
d74 2
a75 4
	&print_def_file(*STDOUT,"LIBEAY",*crypto_list,@@crypto_symbols)
		if $do_crypto == 1;

}
d77 2
d81 3
a83 13
{
	my($name,$files,$symhacksfile)=@@_;
	my $file;
	my @@ret;
	my %syms;
	my %platform;		# For anything undefined, we assume ""
	my %kind;		# For anything undefined, we assume "FUNCTION"
	my %algorithm;		# For anything undefined, we assume ""
	my %variant;
	my %variant_cnt;	# To be able to allocate "name{n}" if "name"
				# is the same name as the original.
	my $cpp;
	my %unknown_algorithms = ();
d85 2
a86 1
	foreach $file (split(/\s+/,$symhacksfile." ".$files))
d88 1
a88 1
		print STDERR "DEBUG: starting on $file:\n" if $debug;
d90 6
a95 26
		my $line = "", my $def= "";
		my %tag = (
			(map { $_ => 0 } @@known_platforms),
			(map { "OPENSSL_SYS_".$_ => 0 } @@known_ossl_platforms),
			(map { "OPENSSL_NO_".$_ => 0 } @@known_algorithms),
			NOPROTO		=> 0,
			PERL5		=> 0,
			_WINDLL		=> 0,
			CONST_STRICT	=> 0,
			TRUE		=> 1,
		);
		my $symhacking = $file eq $symhacksfile;
		my @@current_platforms = ();
		my @@current_algorithms = ();

		# params: symbol, alias, platforms, kind
		# The reason to put this subroutine in a variable is that
		# it will otherwise create it's own, unshared, version of
		# %tag and %variant...
		my $make_variant = sub
		{
			my ($s, $a, $p, $k) = @@_;
			my ($a1, $a2);

			print STDERR "DEBUG: make_variant: Entered with ",$s,", ",$a,", ",(defined($p)?$p:""),", ",(defined($k)?$k:""),"\n" if $debug;
			if (defined($p))
d97 4
a100 4
				$a1 = join(",",$p,
					   grep(!/^$/,
						map { $tag{$_} == 1 ? $_ : "" }
						@@known_platforms));
d102 1
a102 15
			else
			{
				$a1 = join(",",
					   grep(!/^$/,
						map { $tag{$_} == 1 ? $_ : "" }
						@@known_platforms));
			}
			$a2 = join(",",
				   grep(!/^$/,
					map { $tag{"OPENSSL_SYS_".$_} == 1 ? $_ : "" }
					@@known_ossl_platforms));
			print STDERR "DEBUG: make_variant: a1 = $a1; a2 = $a2\n" if $debug;
			if ($a1 eq "") { $a1 = $a2; }
			elsif ($a1 ne "" && $a2 ne "") { $a1 .= ",".$a2; }
			if ($a eq $s)
d104 1
a104 1
				if (!defined($variant_cnt{$s}))
d106 3
a108 1
					$variant_cnt{$s} = 0;
d110 2
a111 39
				$variant_cnt{$s}++;
				$a .= "{$variant_cnt{$s}}";
			}
			my $toadd = $a.":".$a1.(defined($k)?":".$k:"");
			my $togrep = $s.'(\{[0-9]+\})?:'.$a1.(defined($k)?":".$k:"");
			if (!grep(/^$togrep$/,
				  split(/;/, defined($variant{$s})?$variant{$s}:""))) {
				if (defined($variant{$s})) { $variant{$s} .= ";"; }
				$variant{$s} .= $toadd;
			}
			print STDERR "DEBUG: make_variant: Exit with variant of ",$s," = ",$variant{$s},"\n" if $debug;
		};

		print STDERR "DEBUG: parsing ----------\n" if $debug;
		while(<IN>) {
			last if (/\/\* Error codes for the \w+ functions\. \*\//);
			if ($line ne '') {
				$_ = $line . $_;
				$line = '';
			}

			if (/\\$/) {
				chomp; # remove eol
				chop; # remove ending backslash
				$line = $_;
				next;
			}

	    		$cpp = 1 if /^\#.*ifdef.*cplusplus/;
			if ($cpp) {
				$cpp = 0 if /^\#.*endif/;
				next;
	    		}

			s/\/\*.*?\*\///gs;                   # ignore comments
			s/{[^{}]*}//gs;                      # ignore {} blocks
			print STDERR "DEBUG: \$_=\"$_\"\n" if $debug;
			if (/^\#\s*ifndef\s+(.*)/) {
				push(@@tag,"-");
d114 1
a114 17
				print STDERR "DEBUG: $file: found tag $1 = -1\n" if $debug;
			} elsif (/^\#\s*if\s+!defined\(([^\)]+)\)/) {
				push(@@tag,"-");
				if (/^\#\s*if\s+(!defined\(([^\)]+)\)(\s+\&\&\s+!defined\(([^\)]+)\))*)$/) {
					my $tmp_1 = $1;
					my $tmp_;
					foreach $tmp_ (split '\&\&',$tmp_1) {
						$tmp_ =~ /!defined\(([^\)]+)\)/;
						print STDERR "DEBUG: $file: found tag $1 = -1\n" if $debug;
						push(@@tag,$1);
						$tag{$1}=-1;
					}
				} else {
					print STDERR "Warning: $file: complicated expression: $_" if $debug; # because it is O...
					print STDERR "DEBUG: $file: found tag $1 = -1\n" if $debug;
					push(@@tag,$1);
					$tag{$1}=-1;
d116 2
a117 2
			} elsif (/^\#\s*ifdef\s+(.*)/) {
				push(@@tag,"-");
d120 1
a120 17
				print STDERR "DEBUG: $file: found tag $1 = 1\n" if $debug;
			} elsif (/^\#\s*if\s+defined\(([^\)]+)\)/) {
				push(@@tag,"-");
				if (/^\#\s*if\s+(defined\(([^\)]+)\)(\s+\|\|\s+defined\(([^\)]+)\))*)$/) {
					my $tmp_1 = $1;
					my $tmp_;
					foreach $tmp_ (split '\|\|',$tmp_1) {
						$tmp_ =~ /defined\(([^\)]+)\)/;
						print STDERR "DEBUG: $file: found tag $1 = 1\n" if $debug;
						push(@@tag,$1);
						$tag{$1}=1;
					}
				} else {
					print STDERR "Warning: $file: complicated expression: $_\n" if $debug; # because it is O...
					print STDERR "DEBUG: $file: found tag $1 = 1\n" if $debug;
					push(@@tag,$1);
					$tag{$1}=1;
d122 5
a126 32
			} elsif (/^\#\s*error\s+(\w+) is disabled\./) {
				my $tag_i = $#tag;
				while($tag[$tag_i] ne "-") {
					if ($tag[$tag_i] eq "OPENSSL_NO_".$1) {
						$tag{$tag[$tag_i]}=2;
						print STDERR "DEBUG: $file: chaged tag $1 = 2\n" if $debug;
					}
					$tag_i--;
				}
			} elsif (/^\#\s*endif/) {
				my $tag_i = $#tag;
				while($tag[$tag_i] ne "-") {
					my $t=$tag[$tag_i];
					print STDERR "DEBUG: \$t=\"$t\"\n" if $debug;
					if ($tag{$t}==2) {
						$tag{$t}=-1;
					} else {
						$tag{$t}=0;
					}
					print STDERR "DEBUG: $file: changed tag ",$t," = ",$tag{$t},"\n" if $debug;
					pop(@@tag);
					if ($t =~ /^OPENSSL_NO_([A-Z0-9_]+)$/) {
						$t=$1;
					} else {
						$t="";
					}
					if ($t ne ""
					    && !grep(/^$t$/, @@known_algorithms)) {
						$unknown_algorithms{$t} = 1;
						#print STDERR "DEBUG: Added as unknown algorithm: $t\n" if $debug;
					}
					$tag_i--;
d128 3
a131 46
			} elsif (/^\#\s*else/) {
				my $tag_i = $#tag;
				while($tag[$tag_i] ne "-") {
					my $t=$tag[$tag_i];
					$tag{$t}= -$tag{$t};
					print STDERR "DEBUG: $file: changed tag ",$t," = ",$tag{$t},"\n" if $debug;
					$tag_i--;
				}
			} elsif (/^\#\s*if\s+1/) {
				push(@@tag,"-");
				# Dummy tag
				push(@@tag,"TRUE");
				$tag{"TRUE"}=1;
				print STDERR "DEBUG: $file: found 1\n" if $debug;
			} elsif (/^\#\s*if\s+0/) {
				push(@@tag,"-");
				# Dummy tag
				push(@@tag,"TRUE");
				$tag{"TRUE"}=-1;
				print STDERR "DEBUG: $file: found 0\n" if $debug;
			} elsif (/^\#\s*define\s+(\w+)\s+(\w+)/
				 && $symhacking && $tag{'TRUE'} != -1) {
				# This is for aliasing.  When we find an alias,
				# we have to invert
				&$make_variant($1,$2);
				print STDERR "DEBUG: $file: defined $1 = $2\n" if $debug;
			}
			if (/^\#/) {
				@@current_platforms =
				    grep(!/^$/,
					 map { $tag{$_} == 1 ? $_ :
						   $tag{$_} == -1 ? "!".$_  : "" }
					 @@known_platforms);
				push @@current_platforms
				    , grep(!/^$/,
					   map { $tag{"OPENSSL_SYS_".$_} == 1 ? $_ :
						     $tag{"OPENSSL_SYS_".$_} == -1 ? "!".$_  : "" }
					   @@known_ossl_platforms);
				@@current_algorithms =
				    grep(!/^$/,
					 map { $tag{"OPENSSL_NO_".$_} == -1 ? $_ : "" }
					 @@known_algorithms);
				$def .=
				    "#INFO:"
					.join(',',@@current_platforms).":"
					    .join(',',@@current_algorithms).";";
a132 217
			}
			if ($tag{'TRUE'} != -1) {
				if (/^\s*DECLARE_STACK_OF\s*\(\s*(\w*)\s*\)/) {
					next;
				} elsif (/^\s*DECLARE_ASN1_ENCODE_FUNCTIONS\s*\(\s*(\w*)\s*,\s*(\w*)\s*,\s*(\w*)\s*\)/) {
					$def .= "int d2i_$3(void);";
					$def .= "int i2d_$3(void);";
					# Variant for platforms that do not
					# have to access globale variables
					# in shared libraries through functions
					$def .=
					    "#INFO:"
						.join(',',"!EXPORT_VAR_AS_FUNCTION",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "OPENSSL_EXTERN int $2_it;";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Variant for platforms that have to
					# access globale variables in shared
					# libraries through functions
					&$make_variant("$2_it","$2_it",
						      "EXPORT_VAR_AS_FUNCTION",
						      "FUNCTION");
					next;
				} elsif (/^\s*DECLARE_ASN1_FUNCTIONS_fname\s*\(\s*(\w*)\s*,\s*(\w*)\s*,\s*(\w*)\s*\)/) {
					$def .= "int d2i_$3(void);";
					$def .= "int i2d_$3(void);";
					$def .= "int $3_free(void);";
					$def .= "int $3_new(void);";
					# Variant for platforms that do not
					# have to access globale variables
					# in shared libraries through functions
					$def .=
					    "#INFO:"
						.join(',',"!EXPORT_VAR_AS_FUNCTION",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "OPENSSL_EXTERN int $2_it;";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Variant for platforms that have to
					# access globale variables in shared
					# libraries through functions
					&$make_variant("$2_it","$2_it",
						      "EXPORT_VAR_AS_FUNCTION",
						      "FUNCTION");
					next;
				} elsif (/^\s*DECLARE_ASN1_FUNCTIONS\s*\(\s*(\w*)\s*\)/ ||
					 /^\s*DECLARE_ASN1_FUNCTIONS_const\s*\(\s*(\w*)\s*\)/) {
					$def .= "int d2i_$1(void);";
					$def .= "int i2d_$1(void);";
					$def .= "int $1_free(void);";
					$def .= "int $1_new(void);";
					# Variant for platforms that do not
					# have to access globale variables
					# in shared libraries through functions
					$def .=
					    "#INFO:"
						.join(',',"!EXPORT_VAR_AS_FUNCTION",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "OPENSSL_EXTERN int $1_it;";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Variant for platforms that have to
					# access globale variables in shared
					# libraries through functions
					&$make_variant("$1_it","$1_it",
						      "EXPORT_VAR_AS_FUNCTION",
						      "FUNCTION");
					next;
				} elsif (/^\s*DECLARE_ASN1_ENCODE_FUNCTIONS_const\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
					$def .= "int d2i_$2(void);";
					$def .= "int i2d_$2(void);";
					# Variant for platforms that do not
					# have to access globale variables
					# in shared libraries through functions
					$def .=
					    "#INFO:"
						.join(',',"!EXPORT_VAR_AS_FUNCTION",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "OPENSSL_EXTERN int $2_it;";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Variant for platforms that have to
					# access globale variables in shared
					# libraries through functions
					&$make_variant("$2_it","$2_it",
						      "EXPORT_VAR_AS_FUNCTION",
						      "FUNCTION");
					next;
				} elsif (/^\s*DECLARE_ASN1_FUNCTIONS_name\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
					$def .= "int d2i_$2(void);";
					$def .= "int i2d_$2(void);";
					$def .= "int $2_free(void);";
					$def .= "int $2_new(void);";
					# Variant for platforms that do not
					# have to access globale variables
					# in shared libraries through functions
					$def .=
					    "#INFO:"
						.join(',',"!EXPORT_VAR_AS_FUNCTION",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "OPENSSL_EXTERN int $2_it;";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Variant for platforms that have to
					# access globale variables in shared
					# libraries through functions
					&$make_variant("$2_it","$2_it",
						      "EXPORT_VAR_AS_FUNCTION",
						      "FUNCTION");
					next;
				} elsif (/^\s*DECLARE_ASN1_ITEM\s*\(\s*(\w*)\s*\)/) {
					# Variant for platforms that do not
					# have to access globale variables
					# in shared libraries through functions
					$def .=
					    "#INFO:"
						.join(',',"!EXPORT_VAR_AS_FUNCTION",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "OPENSSL_EXTERN int $1_it;";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Variant for platforms that have to
					# access globale variables in shared
					# libraries through functions
					&$make_variant("$1_it","$1_it",
						      "EXPORT_VAR_AS_FUNCTION",
						      "FUNCTION");
					next;
				} elsif (/^\s*DECLARE_ASN1_SET_OF\s*\(\s*(\w*)\s*\)/) {
					next;
				} elsif (/^\s*DECLARE_PKCS12_STACK_OF\s*\(\s*(\w*)\s*\)/) {
					next;
				} elsif (/^DECLARE_PEM_rw\s*\(\s*(\w*)\s*,/ ||
					 /^DECLARE_PEM_rw_cb\s*\(\s*(\w*)\s*,/ ) {
					# Things not in Win16
					$def .=
					    "#INFO:"
						.join(',',"!WIN16",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "int PEM_read_$1(void);";
					$def .= "int PEM_write_$1(void);";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Things that are everywhere
					$def .= "int PEM_read_bio_$1(void);";
					$def .= "int PEM_write_bio_$1(void);";
					next;
				} elsif (/^DECLARE_PEM_write\s*\(\s*(\w*)\s*,/ ||
					 /^DECLARE_PEM_write_cb\s*\(\s*(\w*)\s*,/ ) {
					# Things not in Win16
					$def .=
					    "#INFO:"
						.join(',',"!WIN16",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "int PEM_write_$1(void);";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Things that are everywhere
					$def .= "int PEM_write_bio_$1(void);";
					next;
				} elsif (/^DECLARE_PEM_read\s*\(\s*(\w*)\s*,/ ||
					 /^DECLARE_PEM_read_cb\s*\(\s*(\w*)\s*,/ ) {
					# Things not in Win16
					$def .=
					    "#INFO:"
						.join(',',"!WIN16",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "int PEM_read_$1(void);";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Things that are everywhere
					$def .= "int PEM_read_bio_$1(void);";
					next;
				} elsif (/^OPENSSL_DECLARE_GLOBAL\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
					# Variant for platforms that do not
					# have to access globale variables
					# in shared libraries through functions
					$def .=
					    "#INFO:"
						.join(',',"!EXPORT_VAR_AS_FUNCTION",@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					$def .= "OPENSSL_EXTERN int _shadow_$2;";
					$def .=
					    "#INFO:"
						.join(',',@@current_platforms).":"
						    .join(',',@@current_algorithms).";";
					# Variant for platforms that have to
					# access globale variables in shared
					# libraries through functions
					&$make_variant("_shadow_$2","_shadow_$2",
						      "EXPORT_VAR_AS_FUNCTION",
						      "FUNCTION");
				} elsif ($tag{'CONST_STRICT'} != 1) {
					if (/\{|\/\*|\([^\)]*$/) {
						$line = $_;
					} else {
						$def .= $_;
					}
d134 4
a137 32
			}
		}
		close(IN);

		my $algs;
		my $plays;

		print STDERR "DEBUG: postprocessing ----------\n" if $debug;
		foreach (split /;/, $def) {
			my $s; my $k = "FUNCTION"; my $p; my $a;
			s/^[\n\s]*//g;
			s/[\n\s]*$//g;
			next if(/\#undef/);
			next if(/typedef\W/);
			next if(/\#define/);

			print STDERR "DEBUG: \$_ = \"$_\"\n" if $debug;
			if (/^\#INFO:([^:]*):(.*)$/) {
				$plats = $1;
				$algs = $2;
				print STDERR "DEBUG: found info on platforms ($plats) and algorithms ($algs)\n" if $debug;
				next;
			} elsif (/^\s*OPENSSL_EXTERN\s.*?(\w+(\{[0-9]+\})?)(\[[0-9]*\])*\s*$/) {
				$s = $1;
				$k = "VARIABLE";
				print STDERR "DEBUG: found external variable $s\n" if $debug;
			} elsif (/\(\*(\w*(\{[0-9]+\})?)\([^\)]+/) {
				$s = $1;
				print STDERR "DEBUG: found ANSI C function $s\n" if $debug;
			} elsif (/\w+\W+(\w+)\W*\(\s*\)$/s) {
				# K&R C
				print STDERR "DEBUG: found K&R C function $s\n" if $debug;
a138 4
			} elsif (/\w+\W+\w+(\{[0-9]+\})?\W*\(.*\)$/s) {
				while (not /\(\)$/s) {
					s/[^\(\)]*\)$/\)/s;
					s/\([^\(\)]*\)\)$/\)/s;
d140 2
a141 10
				s/\(void\)//;
				/(\w+(\{[0-9]+\})?)\W*\(\)/s;
				$s = $1;
				print STDERR "DEBUG: found function $s\n" if $debug;
			} elsif (/\(/ and not (/=/)) {
				print STDERR "File $file: cannot parse: $_;\n";
				next;
			} else {
				next;
			}
d143 21
a163 38
			$syms{$s} = 1;
			$kind{$s} = $k;

			$p = $plats;
			$a = $algs;
			$a .= ",BF" if($s =~ /EVP_bf/);
			$a .= ",CAST" if($s =~ /EVP_cast/);
			$a .= ",DES" if($s =~ /EVP_des/);
			$a .= ",DSA" if($s =~ /EVP_dss/);
			$a .= ",IDEA" if($s =~ /EVP_idea/);
			$a .= ",MD2" if($s =~ /EVP_md2/);
			$a .= ",MD4" if($s =~ /EVP_md4/);
			$a .= ",MD5" if($s =~ /EVP_md5/);
			$a .= ",RC2" if($s =~ /EVP_rc2/);
			$a .= ",RC4" if($s =~ /EVP_rc4/);
			$a .= ",RC5" if($s =~ /EVP_rc5/);
			$a .= ",RIPEMD" if($s =~ /EVP_ripemd/);
			$a .= ",SHA" if($s =~ /EVP_sha/);
			$a .= ",RSA" if($s =~ /EVP_(Open|Seal)(Final|Init)/);
			$a .= ",RSA" if($s =~ /PEM_Seal(Final|Init|Update)/);
			$a .= ",RSA" if($s =~ /RSAPrivateKey/);
			$a .= ",RSA" if($s =~ /SSLv23?_((client|server)_)?method/);

			$platform{$s} =
			    &reduce_platforms((defined($platform{$s})?$platform{$s}.',':"").$p);
			$algorithm{$s} .= ','.$a;

			if (defined($variant{$s})) {
				foreach $v (split /;/,$variant{$s}) {
					(my $r, my $p, my $k) = split(/:/,$v);
					my $ip = join ',',map({ /^!(.*)$/ ? $1 : "!".$_ } split /,/, $p);
					$syms{$r} = 1;
					if (!defined($k)) { $k = $kind{$s}; }
					$kind{$r} = $k."(".$s.")";
					$algorithm{$r} = $algorithm{$s};
					$platform{$r} = &reduce_platforms($platform{$s}.",".$p.",".$p);
					$platform{$s} = &reduce_platforms($platform{$s}.','.$ip.','.$ip);
					print STDERR "DEBUG: \$variant{\"$s\"} = ",$v,"; \$r = $r; \$p = ",$platform{$r},"; \$a = ",$algorithm{$r},"; \$kind = ",$kind{$r},"\n" if $debug;
d166 1
a166 1
			print STDERR "DEBUG: \$s = $s; \$p = ",$platform{$s},"; \$a = ",$algorithm{$s},"; \$kind = ",$kind{$s},"\n" if $debug;
a167 23
	}

	# Prune the returned symbols

        delete $syms{"bn_dump1"};
	$platform{"BIO_s_log"} .= ",!WIN32,!WIN16,!macintosh";

	$platform{"PEM_read_NS_CERT_SEQ"} = "VMS";
	$platform{"PEM_write_NS_CERT_SEQ"} = "VMS";
	$platform{"PEM_read_P8_PRIV_KEY_INFO"} = "VMS";
	$platform{"PEM_write_P8_PRIV_KEY_INFO"} = "VMS";

	# Info we know about

	push @@ret, map { $_."\\".&info_string($_,"EXIST",
					      $platform{$_},
					      $kind{$_},
					      $algorithm{$_}) } keys %syms;

	if (keys %unknown_algorithms) {
		print STDERR "WARNING: mkdef.pl doesn't know the following algorithms:\n";
		print STDERR "\t",join("\n\t",keys %unknown_algorithms),"\n";
	}
a168 30
}

# Param: string of comma-separated platform-specs.
sub reduce_platforms
{
	my ($platforms) = @@_;
	my $pl = defined($platforms) ? $platforms : "";
	my %p = map { $_ => 0 } split /,/, $pl;
	my $ret;

	print STDERR "DEBUG: Entered reduce_platforms with \"$platforms\"\n"
	    if $debug;
	# We do this, because if there's code like the following, it really
	# means the function exists in all cases and should therefore be
	# everywhere.  By increasing and decreasing, we may attain 0:
	#
	# ifndef WIN16
	#    int foo();
	# else
	#    int _fat foo();
	# endif
	foreach $platform (split /,/, $pl) {
		if ($platform =~ /^!(.*)$/) {
			$p{$1}--;
		} else {
			$p{$platform}++;
		}
	}
	foreach $platform (keys %p) {
		if ($p{$platform} == 0) { delete $p{$platform}; }
d171 4
a174 1
	delete $p{""};
d176 31
a206 41
	$ret = join(',',sort(map { $p{$_} < 0 ? "!".$_ : $_ } keys %p));
	print STDERR "DEBUG: Exiting reduce_platforms with \"$ret\"\n"
	    if $debug;
	return $ret;
}

sub info_string {
	(my $symbol, my $exist, my $platforms, my $kind, my $algorithms) = @@_;

	my %a = defined($algorithms) ?
	    map { $_ => 1 } split /,/, $algorithms : ();
	my $k = defined($kind) ? $kind : "FUNCTION";
	my $ret;
	my $p = &reduce_platforms($platforms);

	delete $a{""};

	$ret = $exist;
	$ret .= ":".$p;
	$ret .= ":".$k;
	$ret .= ":".join(',',sort keys %a);
	return $ret;
}

sub maybe_add_info {
	(my $name, *nums, my @@symbols) = @@_;
	my $sym;
	my $new_info = 0;
	my %syms=();

	print STDERR "Updating $name info\n";
	foreach $sym (@@symbols) {
		(my $s, my $i) = split /\\/, $sym;
		if (defined($nums{$s})) {
			$i =~ s/^(.*?:.*?:\w+)(\(\w+\))?/$1/;
			(my $n, my $dummy) = split /\\/, $nums{$s};
			if (!defined($dummy) || $i ne $dummy) {
				$nums{$s} = $n."\\".$i;
				$new_info++;
				print STDERR "DEBUG: maybe_add_info for $s: \"$dummy\" => \"$i\"\n" if $debug;
			}
a207 1
		$syms{$s} = 1;
d210 1
a210 27
	my @@s=sort { &parse_number($nums{$a},"n") <=> &parse_number($nums{$b},"n") } keys %nums;
	foreach $sym (@@s) {
		(my $n, my $i) = split /\\/, $nums{$sym};
		if (!defined($syms{$sym}) && $i !~ /^NOEXIST:/) {
			$new_info++;
			print STDERR "DEBUG: maybe_add_info for $sym: -> undefined\n" if $debug;
		}
	}
	if ($new_info) {
		print STDERR "$new_info old symbols got an info update\n";
		if (!$do_rewrite) {
			print STDERR "You should do a rewrite to fix this.\n";
		}
	} else {
		print STDERR "No old symbols needed info update\n";
	}
}

# Param: string of comma-separated keywords, each possibly prefixed with a "!"
sub is_valid
{
	my ($keywords_txt,$platforms) = @@_;
	my (@@keywords) = split /,/,$keywords_txt;
	my ($falsesum, $truesum) = (0, !grep(/^[^!]/,@@keywords));

	# Param: one keyword
	sub recognise
d212 2
a213 47
		my ($keyword,$platforms) = @@_;

		if ($platforms) {
			# platforms
			if ($keyword eq "VMS" && $VMS) { return 1; }
			if ($keyword eq "WIN32" && $W32) { return 1; }
			if ($keyword eq "WIN16" && $W16) { return 1; }
			if ($keyword eq "WINNT" && $NT) { return 1; }
			# Special platforms:
			# EXPORT_VAR_AS_FUNCTION means that global variables
			# will be represented as functions.  This currently
			# only happens on VMS-VAX.
			if ($keyword eq "EXPORT_VAR_AS_FUNCTION" && ($VMSVAX || $W32 || $W16)) {
				return 1;
			}
			return 0;
		} else {
			# algorithms
			if ($keyword eq "RC2" && $no_rc2) { return 0; }
			if ($keyword eq "RC4" && $no_rc4) { return 0; }
			if ($keyword eq "RC5" && $no_rc5) { return 0; }
			if ($keyword eq "IDEA" && $no_idea) { return 0; }
			if ($keyword eq "DES" && $no_des) { return 0; }
			if ($keyword eq "BF" && $no_bf) { return 0; }
			if ($keyword eq "CAST" && $no_cast) { return 0; }
			if ($keyword eq "MD2" && $no_md2) { return 0; }
			if ($keyword eq "MD4" && $no_md4) { return 0; }
			if ($keyword eq "MD5" && $no_md5) { return 0; }
			if ($keyword eq "SHA" && $no_sha) { return 0; }
			if ($keyword eq "RIPEMD" && $no_ripemd) { return 0; }
			if ($keyword eq "MDC2" && $no_mdc2) { return 0; }
			if ($keyword eq "RSA" && $no_rsa) { return 0; }
			if ($keyword eq "DSA" && $no_dsa) { return 0; }
			if ($keyword eq "DH" && $no_dh) { return 0; }
			if ($keyword eq "EC" && $no_ec) { return 0; }
			if ($keyword eq "HMAC" && $no_hmac) { return 0; }
			if ($keyword eq "AES" && $no_aes) { return 0; }
			if ($keyword eq "EVP" && $no_evp) { return 0; }
			if ($keyword eq "LHASH" && $no_lhash) { return 0; }
			if ($keyword eq "STACK" && $no_stack) { return 0; }
			if ($keyword eq "ERR" && $no_err) { return 0; }
			if ($keyword eq "BUFFER" && $no_buffer) { return 0; }
			if ($keyword eq "BIO" && $no_bio) { return 0; }
			if ($keyword eq "COMP" && $no_comp) { return 0; }
			if ($keyword eq "DSO" && $no_dso) { return 0; }
			if ($keyword eq "KRB5" && $no_krb5) { return 0; }
			if ($keyword eq "FP_API" && $no_fp_api) { return 0; }
d215 2
a216 3
			# Nothing recognise as true
			return 1;
		}
a218 48
	foreach $k (@@keywords) {
		if ($k =~ /^!(.*)$/) {
			$falsesum += &recognise($1,$platforms);
		} else {
			$truesum += &recognise($k,$platforms);
		}
	}
	print STDERR "DEBUG: [",$#keywords,",",$#keywords < 0,"] is_valid($keywords_txt) => (\!$falsesum) && $truesum = ",(!$falsesum) && $truesum,"\n" if $debug;
	return (!$falsesum) && $truesum;
}

sub print_test_file
{
	(*OUT,my $name,*nums,my $testall,my @@symbols)=@@_;
	my $n = 1; my @@e; my @@r;
	my $sym; my $prev = ""; my $prefSSLeay;

	(@@e)=grep(/^SSLeay(\{[0-9]+\})?\\.*?:.*?:.*/,@@symbols);
	(@@r)=grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:.*/ && !/^SSLeay(\{[0-9]+\})?\\.*?:.*?:.*/,@@symbols);
	@@symbols=((sort @@e),(sort @@r));

	foreach $sym (@@symbols) {
		(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
		my $v = 0;
		$v = 1 if $i=~ /^.*?:.*?:VARIABLE/;
		my $p = ($i =~ /^[^:]*:([^:]*):/,$1);
		my $a = ($i =~ /^[^:]*:[^:]*:[^:]*:([^:]*)/,$1);
		if (!defined($nums{$s})) {
			print STDERR "Warning: $s does not have a number assigned\n"
			    if(!$do_update);
		} elsif (is_valid($p,1) && is_valid($a,0)) {
			my $s2 = ($s =~ /^(.*?)(\{[0-9]+\})?$/, $1);
			if ($prev eq $s2) {
				print OUT "\t/* The following has already appeared previously */\n";
				print STDERR "Warning: Symbol '",$s2,"' redefined. old=",($nums{$prev} =~ /^(.*?)\\/,$1),", new=",($nums{$s2} =~ /^(.*?)\\/,$1),"\n";
			}
			$prev = $s2;	# To warn about duplicates...

			($nn,$ni)=($nums{$s2} =~ /^(.*?)\\(.*)$/);
			if ($v) {
				print OUT "\textern int $s2; /* type unknown */ /* $nn $ni */\n";
			} else {
				print OUT "\textern int $s2(); /* type unknown */ /* $nn $ni */\n";
			}
		}
	}
}

d220 3
a222 3
{
	(*OUT,my $name,*nums,my @@symbols)=@@_;
	my $n = 1; my @@e; my @@r; my @@v; my $prev="";
d224 1
a224 1
	if ($W32)
d231 1
a231 1
; Definition file for the DLL version of the $name library from OpenSSL
d236 1
a236 1
DESCRIPTION     'OpenSSL $name - http://www.openssl.org/'
d240 2
a241 1
	if (!$W32) {
d252 1
a252 1
	}
d256 15
a270 29
	(@@e)=grep(/^SSLeay(\{[0-9]+\})?\\.*?:.*?:FUNCTION/,@@symbols);
	(@@r)=grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:FUNCTION/ && !/^SSLeay(\{[0-9]+\})?\\.*?:.*?:FUNCTION/,@@symbols);
	(@@v)=grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:VARIABLE/,@@symbols);
	@@symbols=((sort @@e),(sort @@r), (sort @@v));


	foreach $sym (@@symbols) {
		(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
		my $v = 0;
		$v = 1 if $i =~ /^.*?:.*?:VARIABLE/;
		if (!defined($nums{$s})) {
			printf STDERR "Warning: $s does not have a number assigned\n"
			    if(!$do_update);
		} else {
			(my $n, my $dummy) = split /\\/, $nums{$s};
			my %pf = ();
			my $p = ($i =~ /^[^:]*:([^:]*):/,$1);
			my $a = ($i =~ /^[^:]*:[^:]*:[^:]*:([^:]*)/,$1);
			if (is_valid($p,1) && is_valid($a,0)) {
				my $s2 = ($s =~ /^(.*?)(\{[0-9]+\})?$/, $1);
				if ($prev eq $s2) {
					print STDERR "Warning: Symbol '",$s2,"' redefined. old=",($nums{$prev} =~ /^(.*?)\\/,$1),", new=",($nums{$s2} =~ /^(.*?)\\/,$1),"\n";
				}
				$prev = $s2;	# To warn about duplicates...
				if($v) {
					printf OUT "    %s%-39s @@%-8d DATA\n",($W32)?"":"_",$s2,$n;
				} else {
					printf OUT "    %s%-39s @@%d\n",($W32)?"":"_",$s2,$n;
				}
d273 1
a274 2
	printf OUT "\n";
}
d277 3
a279 8
{
	my($name)=@@_;
	my(@@a,%ret);

	$max_num = 0;
	$num_noinfo = 0;
	$prev = "";
	$prev_cnt = 0;
d282 2
a283 1
	while (<IN>) {
d288 1
a288 14
		if (defined $ret{$a[0]}) {
			# This is actually perfectly OK
			#print STDERR "Warning: Symbol '",$a[0],"' redefined. old=",$ret{$a[0]},", new=",$a[1],"\n";
		}
		if ($max_num > $a[1]) {
			print STDERR "Warning: Number decreased from ",$max_num," to ",$a[1],"\n";
		}
		elsif ($max_num == $a[1]) {
			# This is actually perfectly OK
			#print STDERR "Warning: Symbol ",$a[0]," has same number as previous ",$prev,": ",$a[1],"\n";
			if ($a[0] eq $prev) {
				$prev_cnt++;
				$a[0] .= "{$prev_cnt}";
			}
a289 21
		else {
			$prev_cnt = 0;
		}
		if ($#a < 2) {
			# Existence will be proven later, in do_defs
			$ret{$a[0]}=$a[1];
			$num_noinfo++;
		} else {
			$ret{$a[0]}=$a[1]."\\".$a[2]; # \\ is a special marker
		}
		$max_num = $a[1] if $a[1] > $max_num;
		$prev=$a[0];
	}
	if ($num_noinfo) {
		print STDERR "Warning: $num_noinfo symbols were without info.";
		if ($do_rewrite) {
			printf STDERR "  The rewrite will fix this.\n";
		} else {
			printf STDERR "  You should do a rewrite to fix this.\n";
		}
	}
a291 98
}

sub parse_number
{
	(my $str, my $what) = @@_;
	(my $n, my $i) = split(/\\/,$str);
	if ($what eq "n") {
		return $n;
	} else {
		return $i;
	}
}

sub rewrite_numbers
{
	(*OUT,$name,*nums,@@symbols)=@@_;
	my $thing;

	print STDERR "Rewriting $name\n";

	my @@r = grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:\w+\(\w+\)/,@@symbols);
	my $r; my %r; my %rsyms;
	foreach $r (@@r) {
		(my $s, my $i) = split /\\/, $r;
		my $a = $1 if $i =~ /^.*?:.*?:\w+\((\w+)\)/;
		$i =~ s/^(.*?:.*?:\w+)\(\w+\)/$1/;
		$r{$a} = $s."\\".$i;
		$rsyms{$s} = 1;
	}

	my %syms = ();
	foreach $_ (@@symbols) {
		(my $n, my $i) = split /\\/;
		$syms{$n} = 1;
	}

	my @@s=sort {
	    &parse_number($nums{$a},"n") <=> &parse_number($nums{$b},"n")
	    || $a cmp $b
	} keys %nums;
	foreach $sym (@@s) {
		(my $n, my $i) = split /\\/, $nums{$sym};
		next if defined($i) && $i =~ /^.*?:.*?:\w+\(\w+\)/;
		next if defined($rsyms{$sym});
		print STDERR "DEBUG: rewrite_numbers for sym = ",$sym,": i = ",$i,", n = ",$n,", rsym{sym} = ",$rsyms{$sym},"syms{sym} = ",$syms{$sym},"\n" if $debug;
		$i="NOEXIST::FUNCTION:"
			if !defined($i) || $i eq "" || !defined($syms{$sym});
		my $s2 = $sym;
		$s2 =~ s/\{[0-9]+\}$//;
		printf OUT "%s%-39s %d\t%s\n","",$s2,$n,$i;
		if (exists $r{$sym}) {
			(my $s, $i) = split /\\/,$r{$sym};
			my $s2 = $s;
			$s2 =~ s/\{[0-9]+\}$//;
			printf OUT "%s%-39s %d\t%s\n","",$s2,$n,$i;
		}
	}
}

sub update_numbers
{
	(*OUT,$name,*nums,my $start_num, my @@symbols)=@@_;
	my $new_syms = 0;

	print STDERR "Updating $name numbers\n";

	my @@r = grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:\w+\(\w+\)/,@@symbols);
	my $r; my %r; my %rsyms;
	foreach $r (@@r) {
		(my $s, my $i) = split /\\/, $r;
		my $a = $1 if $i =~ /^.*?:.*?:\w+\((\w+)\)/;
		$i =~ s/^(.*?:.*?:\w+)\(\w+\)/$1/;
		$r{$a} = $s."\\".$i;
		$rsyms{$s} = 1;
	}

	foreach $sym (@@symbols) {
		(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
		next if $i =~ /^.*?:.*?:\w+\(\w+\)/;
		next if defined($rsyms{$sym});
		die "ERROR: Symbol $sym had no info attached to it."
		    if $i eq "";
		if (!exists $nums{$s}) {
			$new_syms++;
			my $s2 = $s;
			$s2 =~ s/\{[0-9]+\}$//;
			printf OUT "%s%-39s %d\t%s\n","",$s2, ++$start_num,$i;
			if (exists $r{$s}) {
				($s, $i) = split /\\/,$r{$s};
				$s =~ s/\{[0-9]+\}$//;
				printf OUT "%s%-39s %d\t%s\n","",$s, $start_num,$i;
			}
		}
	}
	if($new_syms) {
		print STDERR "$new_syms New symbols added\n";
	} else {
		print STDERR "No New symbols Added\n";
a292 24
}

sub check_existing
{
	(*nums, my @@symbols)=@@_;
	my %existing; my @@remaining;
	@@remaining=();
	foreach $sym (@@symbols) {
		(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
		$existing{$s}=1;
	}
	foreach $sym (keys %nums) {
		if (!exists $existing{$sym}) {
			push @@remaining, $sym;
		}
	}
	if(@@remaining) {
		print STDERR "The following symbols do not seem to exist:\n";
		foreach $sym (@@remaining) {
			print STDERR "\t",$sym,"\n";
		}
	}
}

@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d46 2
a47 2
#   environment.  For the negative items ("!FOO"), if any of them is false
#   (i.e. "FOO" is true) in the environment, the corresponding symbol can't be
a60 1
my $libname;
a75 1
my $OS2=0;
d81 1
a81 1
my @@known_ossl_platforms = ( "VMS", "WIN16", "WIN32", "WINNT", "OS2" );
a128 1
	$OS2=1 if $_ eq "OS2";
d131 1
a131 4
	if ($_ eq "ssl") {
		$do_ssl=1; 
		$libname=$_
	}
d133 1
a133 4
	if ($_ eq "crypto") {
		$do_crypto=1;
		$libname=$_;
	}
a172 9
if (!$libname) { 
	if ($do_ssl) {
		$libname="SSLEAY";
	}
	if ($do_crypto) {
		$libname="LIBEAY";
	}
}

d174 1
a174 1
if ($W32 + $W16 + $VMS + $OS2 == 0) {
d185 1
a185 1
	print STDERR "usage: $0 ( ssl | crypto ) [ 16 | 32 | NT | OS2 ]\n";
d308 1
a308 1
	&print_def_file(*STDOUT,$libname,*ssl_list,@@ssl_symbols)
d311 1
a311 1
	&print_def_file(*STDOUT,$libname,*crypto_list,@@crypto_symbols)
a997 1
			if ($keyword eq "OS2" && $OS2) { return 1; }
a1094 1
	my $liboptions="";
d1098 1
a1098 1
	elsif ($W16)
a1099 2
	elsif ($OS2)
		{ $liboptions = "INITINSTANCE\nDATA NONSHARED"; }
d1106 1
a1106 1
LIBRARY         $name	$liboptions
d1112 1
a1112 1
	if ($W16) {
d1151 1
a1151 1
				if($v && !$OS2) {
d1154 1
a1154 1
					printf OUT "    %s%-39s @@%d\n",($W32||$OS2)?"":"_",$s2,$n;
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d94 1
a94 1
			 "FP_API", "STDIO", "SOCK", "KRB5", "ENGINE", "HW" );
d110 1
a110 1
my $no_ec; my $no_engine; my $no_hw;
a178 2
	elsif (/^no-engine$/)	{ $no_engine=1; }
	elsif (/^no-hw$/)	{ $no_hw=1; }
d238 1
a238 1
$crypto.=" crypto/engine/engine.h"; # unless $no_engine;
a440 4
			if (/\/\*/) {			     # if we have part
				$line = $_;		     # of a comment,
				next;			     # continue reading
			}
a441 1
			print STDERR "DEBUG: \$def=\"$def\"\n" if $debug && $def ne "";
d815 1
a815 1
			} elsif (/\w+\W+(\w+)\W*\(\s*\)(\s*__attribute__\(.*\)\s*)?$/s) {
d819 4
a822 4
			} elsif (/\w+\W+\w+(\{[0-9]+\})?\W*\(.*\)(\s*__attribute__\(.*\)\s*)?$/s) {
				while (not /\(\)(\s*__attribute__\(.*\)\s*)?$/s) {
					s/[^\(\)]*\)(\s*__attribute__\(.*\)\s*)?$/\)/s;
					s/\([^\(\)]*\)\)(\s*__attribute__\(.*\)\s*)?$/\)/s;
a1054 2
			if ($keyword eq "ENGINE" && $no_engine) { return 0; }
			if ($keyword eq "HW" && $no_hw) { return 0; }
@


1.1.1.5
log
@import openssl-0.9.7d
@
text
@a1118 11
sub get_version {
   local *MF;
   my $v = '?';
   open MF, 'Makefile.ssl' or return $v;
   while (<MF>) {
     $v = $1, last if /^VERSION=(.*?)\s*$/;
   }
   close MF;
   return $v;
}

a1123 5
	my $libname = $name;
	my $http_vendor = 'www.openssl.org/';
	my $version = get_version();
	my $what = "OpenSSL: implementation of Secure Socket Layer";
	my $description = "$what $version, $name - http://$http_vendor";
d1126 1
a1126 1
		{ $libname.="32"; }
d1128 1
a1128 1
		{ $libname.="16"; }
d1130 1
a1130 13
		{ # DLL names should not clash on the whole system.
		  # However, they should not have any particular relationship
		  # to the name of the static library.  Chose descriptive names
		  # (must be at most 8 chars).
		  my %translate = (ssl => 'open_ssl', crypto => 'cryptssl');
		  $libname = $translate{$name} || $name;
		  $liboptions = <<EOO;
INITINSTANCE
DATA MULTIPLE NONSHARED
EOO
		  # Vendor field can't contain colon, drat; so we omit http://
		  $description = "\@@#$http_vendor:$version#\@@$what; DLL for library $name.  Build for EMX -Zmtd";
		}
d1137 1
a1137 1
LIBRARY         $libname	$liboptions
d1139 1
a1139 1
DESCRIPTION     '$description'
@


1.1.1.6
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d82 1
a82 1
			"EXPORT_VAR_AS_FUNCTION", "OPENSSL_FIPS" );
d97 1
a97 1
open(IN,"<Makefile") || die "unable to open Makefile!\n";
a111 1
my $fips;
a131 1
	$fips=1 if $_ eq "fips";
a267 1
$crypto.=" fips/fips.h fips/rand/fips_rand.h";
d472 1
a472 1
			} elsif (/^\#\s*ifdef\s+(\S*)/) {
d797 1
a797 1
		my $algs = '';
a866 1
			$algorithm{$s} = '' if !defined $algorithm{$s};
a1030 3
			if ($keyword eq "OPENSSL_FIPS" && $fips) {
				return 1;
			}
d1122 1
a1122 1
   open MF, 'Makefile' or return $v;
@


1.1.1.7
log
@import of openssl-0.9.7j
@
text
@d86 1
a86 1
			 "SHA256", "SHA512", "RIPEMD",
d270 1
a270 1
$crypto.=" fips-1.0/fips.h fips-1.0/rand/fips_rand.h fips-1.0/sha/fips_sha.h";
a866 3
			# SHA2 algorithms only defined in FIPS mode for
			# OpenSSL 0.9.7
			$p .= "OPENSSL_FIPS" if($s =~ /SHA[235]/);
d1014 1
a1014 1
	my ($falsesum, $truesum) = (0, 1);
d1082 1
a1082 1
			$truesum *= &recognise($k,$platforms);
@


1.1.1.8
log
@import of OpenSSL 0.9.8h
@
text
@d82 1
a82 1
			"EXPORT_VAR_AS_FUNCTION", "ZLIB" );
d87 1
a87 1
			 "MDC2", "RSA", "DSA", "DH", "EC", "ECDH", "ECDSA", "HMAC", "AES", "CAMELLIA", "SEED",
d94 1
a94 11
			 "FP_API", "STDIO", "SOCK", "KRB5", "DGRAM",
			 # Engines
			 "STATIC_ENGINE", "ENGINE", "HW", "GMP",
			 # RFC3779 support 
			 "RFC3779",
			 # TLS extension support
			 "TLSEXT",
			 # CMS
			 "CMS",
			 # Deprecated functions
			 "DEPRECATED" );
d110 3
a112 5
my $no_ec; my $no_ecdsa; my $no_ecdh; my $no_engine; my $no_hw; my $no_camellia;
my $no_seed;
my $no_fp_api; my $no_static_engine; my $no_gmp; my $no_deprecated;
my $no_rfc3779; my $no_tlsext; my $no_cms;

d133 1
a133 5
	if ($_ eq "zlib" || $_ eq "zlib-dynamic"
			 || $_ eq "enable-zlib-dynamic") {
		$zlib = 1;
	}

a144 2
	$no_static_engine=1 if $_ eq "no-static-engine";
	$no_static_engine=0 if $_ eq "enable-static-engine";
a168 2
	elsif (/^no-ecdsa$/)	{ $no_ecdsa=1; }
	elsif (/^no-ecdh$/) 	{ $no_ecdh=1; }
a170 2
	elsif (/^no-camellia$/)	{ $no_camellia=1; }
	elsif (/^no-seed$/)     { $no_seed=1; }
a182 4
	elsif (/^no-gmp$/)	{ $no_gmp=1; }
	elsif (/^no-rfc3779$/)	{ $no_rfc3779=1; }
	elsif (/^no-tlsext$/)	{ $no_tlsext=1; }
	elsif (/^no-cms$/)	{ $no_cms=1; }
a217 1
$ssl.=" ssl/tls1.h";
a219 1
$crypto.=" crypto/o_dir.h";
a233 2
$crypto.=" crypto/camellia/camellia.h" ; # unless $no_camellia;
$crypto.=" crypto/seed/seed.h"; # unless $no_seed;
a239 2
$crypto.=" crypto/ecdsa/ecdsa.h" ; # unless $no_ecdsa;
$crypto.=" crypto/ecdh/ecdh.h" ; # unless $no_ecdh;
d270 1
a270 3
$crypto.=" crypto/store/store.h";
$crypto.=" crypto/pqueue/pqueue.h";
$crypto.=" crypto/cms/cms.h";
d426 1
a426 5
			if (/\/\* Error codes for the \w+ functions\. \*\//)
				{
				undef @@tag;
				last;
				}
d439 1
a439 9
			if(/\/\*/) {
				if (not /\*\//) {	# multiline comment...
					$line = $_;	# ... just accumulate
					next;
				} else {
					s/\/\*.*?\*\///gs;# wipe it
				}
			}

d441 1
a441 2
				$cpp++ if /^#\s*if/;
				$cpp-- if /^#\s*endif/;
a443 1
			$cpp = 1 if /^#.*ifdef.*cplusplus/;
d445 5
d508 1
a508 1
				while($tag_i > 0 && $tag[$tag_i] ne "-") {
a674 4
				} elsif (/^\s*DECLARE_ASN1_ALLOC_FUNCTIONS\s*\(\s*(\w*)\s*\)/) {
					$def .= "int $1_free(void);";
					$def .= "int $1_new(void);";
					next;
a718 2
				} elsif (/^\s*DECLARE_ASN1_NDEF_FUNCTION\s*\(\s*(\w*)\s*\)/) {
					$def .= "int i2d_$1_NDEF(void);";
a720 6
				} elsif (/^\s*DECLARE_ASN1_PRINT_FUNCTION\s*\(\s*(\w*)\s*\)/) {
					$def .= "int $1_print_ctx(void);";
					next;
				} elsif (/^\s*DECLARE_ASN1_PRINT_FUNCTION_name\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
					$def .= "int $2_print_ctx(void);";
					next;
d724 1
a724 2
					 /^DECLARE_PEM_rw_cb\s*\(\s*(\w*)\s*,/ ||
					 /^DECLARE_PEM_rw_const\s*\(\s*(\w*)\s*,/ ) {
d800 1
a800 1
		my $algs;
a811 11
			# Reduce argument lists to empty ()
			# fold round brackets recursively: (t(*v)(t),t) -> (t{}{},t) -> {}
			while(/\(.*\)/s) {
				s/\([^\(\)]+\)/\{\}/gs;
				s/\(\s*\*\s*(\w+)\s*\{\}\s*\)/$1/gs;	#(*f{}) -> f
			}
			# pretend as we didn't use curly braces: {} -> ()
			s/\{\}/\(\)/gs;

			s/STACK_OF\(\)/void/gs;

d822 6
a827 1
			} elsif (/TYPEDEF_\w+_OF/s) {
d829 8
a836 2
			} elsif (/(\w+)\s*\(\).*/s) {	# first token prior [first] () is
				$s = $1;		# a function name!
d867 3
d873 1
d1038 3
a1040 1
			if ($keyword eq "ZLIB" && $zlib) { return 1; }
a1060 2
			if ($keyword eq "ECDSA" && $no_ecdsa) { return 0; }
			if ($keyword eq "ECDH" && $no_ecdh) { return 0; }
a1062 2
			if ($keyword eq "CAMELLIA" && $no_camellia) { return 0; }
			if ($keyword eq "SEED" && $no_seed) { return 0; }
a1074 6
			if ($keyword eq "STATIC_ENGINE" && $no_static_engine) { return 0; }
			if ($keyword eq "GMP" && $no_gmp) { return 0; }
			if ($keyword eq "RFC3779" && $no_rfc3779) { return 0; }
			if ($keyword eq "TLSEXT" && $no_tlsext) { return 0; }
			if ($keyword eq "CMS" && $no_cms) { return 0; }
			if ($keyword eq "DEPRECATED" && $no_deprecated) { return 0; }
d1176 2
@


1.1.1.9
log
@import openssl-0.9.8j
@
text
@d82 1
a82 1
			"EXPORT_VAR_AS_FUNCTION", "ZLIB", "OPENSSL_FIPS"); 
a102 4
			 # CryptoAPI Engine
			 "CAPIENG",
			 # JPAKE
			 "JPAKE",
d123 1
a123 2
my $no_rfc3779; my $no_tlsext; my $no_cms; my $no_capieng; my $no_jpake;
my $fips;
a144 2
	$fips=1 if /^fips/;

d146 2
a147 2
 			 || $_ eq "enable-zlib-dynamic") {
 		$zlib = 1;
d150 1
a208 2
	elsif (/^no-capieng$/)	{ $no_capieng=1; }
	elsif (/^no-jpake$/)	{ $no_jpake=1; }
a304 2
$crypto.=" crypto/jpake/jpake.h";
$crypto.=" fips/fips.h fips/rand/fips_rand.h";
a1089 3
			if ($keyword eq "OPENSSL_FIPS" && $fips) {
				return 1;
			}
a1133 2
			if ($keyword eq "CAPIENG" && $no_capieng) { return 0; }
			if ($keyword eq "JPAKE" && $no_jpake) { return 0; }
@


1.1.1.10
log
@import OpenSSL-1.0.0a
@
text
@d72 1
a72 1
my $VMSNonVAX=0;
d82 1
a82 1
			"EXPORT_VAR_AS_FUNCTION", "ZLIB" );
d87 1
a87 2
			 "MDC2", "WHIRLPOOL", "RSA", "DSA", "DH", "EC", "ECDH", "ECDSA",
			 "HMAC", "AES", "CAMELLIA", "SEED", "GOST",
d97 1
a97 1
			 # RFC3779
d99 2
a100 2
			 # TLS
			 "TLSEXT", "PSK",
a104 2
			 # SSL v2
			 "SSL2",
d121 1
a121 1
my $no_cast; my $no_whirlpool; my $no_camellia; my $no_seed;
d124 5
a128 6
my $no_ec; my $no_ecdsa; my $no_ecdh; my $no_engine; my $no_hw;
my $no_fp_api; my $no_static_engine=1; my $no_gmp; my $no_deprecated;
my $no_rfc3779; my $no_psk; my $no_tlsext; my $no_cms; my $no_capieng;
my $no_jpake; my $no_ssl2;

my $zlib;
d144 1
a144 1
	if ($_ eq "VMS-NonVAX") {
d146 1
a146 1
		$VMSNonVAX=1;
d150 5
a154 3
	if ($_ eq "zlib" || $_ eq "enable-zlib" || $_ eq "zlib-dynamic"
			 || $_ eq "enable-zlib-dynamic") {
		$zlib = 1;
a182 1
	elsif (/^no-whirlpool$/)     { $no_whirlpool=1; }
a214 1
	elsif (/^no-ssl2$/)	{ $no_ssl2=1; }
a262 1
$crypto.=" crypto/whrlpool/whrlpool.h" ;
a303 1
$crypto.=" crypto/ts/ts.h";
d309 2
a310 1
#$crypto.=" crypto/store/store.h";
d314 1
a887 1
			s/LHASH_OF\(\)/void/gs;
a963 19
	$platform{"EVP_sha384"} = "!VMSVAX";
	$platform{"EVP_sha512"} = "!VMSVAX";
	$platform{"SHA384_Init"} = "!VMSVAX";
	$platform{"SHA384_Transform"} = "!VMSVAX";
	$platform{"SHA384_Update"} = "!VMSVAX";
	$platform{"SHA384_Final"} = "!VMSVAX";
	$platform{"SHA384"} = "!VMSVAX";
	$platform{"SHA512_Init"} = "!VMSVAX";
	$platform{"SHA512_Transform"} = "!VMSVAX";
	$platform{"SHA512_Update"} = "!VMSVAX";
	$platform{"SHA512_Final"} = "!VMSVAX";
	$platform{"SHA512"} = "!VMSVAX";
	$platform{"WHIRLPOOL_Init"} = "!VMSVAX";
	$platform{"WHIRLPOOL"} = "!VMSVAX";
	$platform{"WHIRLPOOL_BitUpdate"} = "!VMSVAX";
	$platform{"EVP_whirlpool"} = "!VMSVAX";
	$platform{"WHIRLPOOL_Final"} = "!VMSVAX";
	$platform{"WHIRLPOOL_Update"} = "!VMSVAX";

a1087 2
			if ($keyword eq "VMSVAX" && $VMSVAX) { return 1; }
			if ($keyword eq "VMSNonVAX" && $VMSNonVAX) { return 1; }
d1100 3
a1119 1
			if ($keyword eq "WHIRLPOOL" && $no_whirlpool) { return 0; }
a1145 1
			if ($keyword eq "PSK" && $no_psk) { return 0; }
a1146 1
			if ($keyword eq "SSL2" && $no_ssl2) { return 0; }
@


1.1.1.11
log
@import OpenSSL 1.0.0e
@
text
@a259 2
$crypto.=" crypto/o_str.h";
$crypto.=" crypto/o_time.h";
a318 1
$crypto.=" crypto/modes/modes.h";
@


1.1.1.12
log
@import OpenSSL-1.0.1c
@
text
@d82 1
a82 1
			"EXPORT_VAR_AS_FUNCTION", "ZLIB", "OPENSSL_FIPS" );
d87 1
a87 1
			 "MDC2", "WHIRLPOOL", "RSA", "DSA", "DH", "EC", "ECDH", "ECDSA", "EC2M",
a88 2
			 # EC_NISTP_64_GCC_128
			 "EC_NISTP_64_GCC_128",
d101 1
a101 1
			 "TLSEXT", "PSK", "SRP", "HEARTBEATS",
a109 2
			 # NEXTPROTONEG
			 "NEXTPROTONEG",
d111 1
a111 5
			 "DEPRECATED",
			 # Hide SSL internals
			 "SSL_INTERN",
			 # SCTP
			 "SCTP");
d130 1
a130 4
my $no_jpake; my $no_srp; my $no_ssl2; my $no_ec2m; my $no_nistp_gcc; 
my $no_nextprotoneg; my $no_sctp;

my $fips;
a153 1
	$fips=1 if /^fips/;
a217 3
	elsif (/^no-ec2m$/)	{ $no_ec2m=1; }
	elsif (/^no-ec_nistp_64_gcc_128$/)	{ $no_nistp_gcc=1; }
	elsif (/^no-nextprotoneg$/)	{ $no_nextprotoneg=1; }
a220 2
	elsif (/^no-srp$/)	{ $no_srp=1; }
	elsif (/^no-sctp$/)	{ $no_sctp=1; }
a256 1
$ssl.=" ssl/srtp.h";
a258 1
$crypto.=" crypto/cryptlib.h";
a287 1
$crypto.=" crypto/cmac/cmac.h" ; # unless $no_hmac;
a321 1
$crypto.=" crypto/srp/srp.h";
a1128 3
			if ($keyword eq "OPENSSL_FIPS" && $fips) {
				return 1;
			}
a1174 4
			if ($keyword eq "EC2M" && $no_ec2m) { return 0; }
			if ($keyword eq "NEXTPROTONEG" && $no_nextprotoneg) { return 0; }
			if ($keyword eq "EC_NISTP_64_GCC_128" && $no_nistp_gcc)
					{ return 0; }
a1177 2
			if ($keyword eq "SRP" && $no_srp) { return 0; }
			if ($keyword eq "SCTP" && $no_sctp) { return 0; }
@


