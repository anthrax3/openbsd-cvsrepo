head	1.2;
access;
symbols
	openssl_1_0_1_g:1.1.1.8
	openssl_1_0_1_c:1.1.1.8
	openssl_1_0_0_f:1.1.1.8
	openssl_1_0_0_e:1.1.1.8
	openssh_1_0_0_a:1.1.1.8
	openssl_0_9_8_k:1.1.1.7
	openssl_0_9_8_j:1.1.1.7
	openssl_0_9_8_h:1.1.1.7
	openssl_0_9_7j:1.1.1.7
	openssl:1.1.1
	OPENSSL_0_9_7G:1.1.1.7
	OPENSSL_0_9_7D:1.1.1.6
	OPENSSL_0_9_7C:1.1.1.5
	OPENSSL_0_9_7B:1.1.1.4
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@# @;


1.2
date	99.09.29.04.37.39;	author beck;	state dead;
branches;
next	1.1;

1.1
date	98.10.05.20.13.04;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.04;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.47;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.44.59;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.36.53;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.11.21.21.54;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.20.42.10;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.04.29.05.37.31;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.10.01.22.54.17;	author djm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@#!/bin/sh
#
# redo the hashes for the certificates in your cert path or the ones passed
# on the command line.
#

if [ "$SSLEAY"x = "x" -o ! -x $SSLEAY ]; then
	SSLEAY='ssleay'
	export SSLEAY
fi
DIR=/usr/ssl
PATH=$DIR/bin:$PATH

SSL_DIR=$DIR/certs

if [ "$*" = "" ]; then
	CERTS=${*:-${SSL_CERT_DIR:-$SSL_DIR}}
else
	CERTS=$*
fi

IFS=': '
for i in $CERTS
do
  (
  IFS=' '
  if [ -d $i -a -w $i ]; then
    cd $i
    echo "Doing $i"
    for i in *.pem
    do
      if [ $i != '*.pem' ]; then
        h=`$SSLEAY x509 -hash -noout -in $i`
	if [ "x$h" = "x" ]; then
	  echo $i does not contain a certificate
	else
          if [ -f $h.0 ]; then
            /bin/rm -f $h.0
          fi
          echo "$i => $h.0"
          ln -s $i $h.0
	fi
      fi
    done
  fi
  )
done
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d1 47
a47 158
#!/usr/bin/perl


# Perl c_rehash script, scan all files in a directory
# and add symbolic links to their hash values.

my $openssl;

my $dir = "/usr/local/ssl";

if(defined $ENV{OPENSSL}) {
	$openssl = $ENV{OPENSSL};
} else {
	$openssl = "openssl";
	$ENV{OPENSSL} = $openssl;
}

$ENV{PATH} .= ":$dir/bin";

if(! -f $openssl) {
	my $found = 0;
	foreach (split /:/, $ENV{PATH}) {
		if(-f "$_/$openssl") {
			$found = 1;
			last;
		}	
	}
	if($found == 0) {
		print STDERR "c_rehash: rehashing skipped ('openssl' program not available)\n";
		exit 0;
	}
}

if(@@ARGV) {
	@@dirlist = @@ARGV;
} elsif($ENV{SSL_CERT_DIR}) {
	@@dirlist = split /:/, $ENV{SSL_CERT_DIR};
} else {
	$dirlist[0] = "$dir/certs";
}


foreach (@@dirlist) {
	if(-d $_ and -w $_) {
		hash_dir($_);
	}
}

sub hash_dir {
	my %hashlist;
	print "Doing $_[0]\n";
	chdir $_[0];
	opendir(DIR, ".");
	my @@flist = readdir(DIR);
	# Delete any existing symbolic links
	foreach (grep {/^[\da-f]+\.r{0,1}\d+$/} @@flist) {
		if(-l $_) {
			unlink $_;
		}
	}
	closedir DIR;
	FILE: foreach $fname (grep {/\.pem$/} @@flist) {
		# Check to see if certificates and/or CRLs present.
		my ($cert, $crl) = check_file($fname);
		if(!$cert && !$crl) {
			print STDERR "WARNING: $fname does not contain a certificate or CRL: skipping\n";
			next;
		}
		link_hash_cert($fname) if($cert);
		link_hash_crl($fname) if($crl);
	}
}

sub check_file {
	my ($is_cert, $is_crl) = (0,0);
	my $fname = $_[0];
	open IN, $fname;
	while(<IN>) {
		if(/^-----BEGIN (.*)-----/) {
			my $hdr = $1;
			if($hdr =~ /^(X509 |TRUSTED |)CERTIFICATE$/) {
				$is_cert = 1;
				last if($is_crl);
			} elsif($hdr eq "X509 CRL") {
				$is_crl = 1;
				last if($is_cert);
			}
		}
	}
	close IN;
	return ($is_cert, $is_crl);
}


# Link a certificate to its subject name hash value, each hash is of
# the form <hash>.<n> where n is an integer. If the hash value already exists
# then we need to up the value of n, unless its a duplicate in which
# case we skip the link. We check for duplicates by comparing the
# certificate fingerprints

sub link_hash_cert {
		my $fname = $_[0];
		my ($hash, $fprint) = `$openssl x509 -hash -fingerprint -noout -in "$fname"`;
		chomp $hash;
		chomp $fprint;
		$fprint =~ s/^.*=//;
		$fprint =~ tr/://d;
		my $suffix = 0;
		# Search for an unused hash filename
		while(exists $hashlist{"$hash.$suffix"}) {
			# Hash matches: if fingerprint matches its a duplicate cert
			if($hashlist{"$hash.$suffix"} eq $fprint) {
				print STDERR "WARNING: Skipping duplicate certificate $fname\n";
				return;
			}
			$suffix++;
		}
		$hash .= ".$suffix";
		print "$fname => $hash\n";
		$symlink_exists=eval {symlink("",""); 1};
		if ($symlink_exists) {
			symlink $fname, $hash;
		} else {
			system ("cp", $fname, $hash);
		}
		$hashlist{$hash} = $fprint;
}

# Same as above except for a CRL. CRL links are of the form <hash>.r<n>

sub link_hash_crl {
		my $fname = $_[0];
		my ($hash, $fprint) = `$openssl crl -hash -fingerprint -noout -in "$fname"`;
		chomp $hash;
		chomp $fprint;
		$fprint =~ s/^.*=//;
		$fprint =~ tr/://d;
		my $suffix = 0;
		# Search for an unused hash filename
		while(exists $hashlist{"$hash.r$suffix"}) {
			# Hash matches: if fingerprint matches its a duplicate cert
			if($hashlist{"$hash.r$suffix"} eq $fprint) {
				print STDERR "WARNING: Skipping duplicate CRL $fname\n";
				return;
			}
			$suffix++;
		}
		$hash .= ".r$suffix";
		print "$fname => $hash\n";
		$symlink_exists=eval {symlink("",""); 1};
		if ($symlink_exists) {
			symlink $fname, $hash;
		} else {
			system ("cp", $fname, $hash);
		}
		$hashlist{$hash} = $fprint;
}

@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d1 1
a1 1
#!/usr/local/bin/perl5
d20 1
a20 1
if(! -x $openssl) {
d23 1
a23 1
		if(-x "$_/$openssl") {
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d1 1
a1 1
#!/usr/local/bin/perl
d103 1
a103 2
		$fname =~ s/'/'\\''/g;
		my ($hash, $fprint) = `"$openssl" x509 -hash -fingerprint -noout -in '$fname'`;
d133 1
a133 2
		$fname =~ s/'/'\\''/g;
		my ($hash, $fprint) = `"$openssl" crl -hash -fingerprint -noout -in '$fname'`;
@


1.1.1.5
log
@import 0.9.7c
@
text
@d1 1
a1 1
#!/usr/bin/perl
@


1.1.1.6
log
@import openssl-0.9.7d
@
text
@d1 1
a1 1
#!/usr/local/bin/perl
@


1.1.1.7
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d1 1
a1 1
#!/usr/bin/perl
@


1.1.1.8
log
@import OpenSSL-1.0.0a
@
text
@a9 1
my $prefix = "/usr/local/ssl";
d18 1
a18 10
my $pwd;
eval "require Cwd";
if (defined(&Cwd::getcwd)) {
	$pwd=Cwd::getcwd();
} else {
	$pwd=`pwd`; chomp($pwd);
}
my $path_delim = ($pwd =~ /^[a-z]\:/i) ? ';' : ':'; # DOS/Win32 or Unix delimiter?

$ENV{PATH} = "$prefix/bin" . ($ENV{PATH} ? $path_delim . $ENV{PATH} : ""); # prefix our path
d22 1
a22 1
	foreach (split /$path_delim/, $ENV{PATH}) {
a24 1
			$openssl = "$_/$openssl";
d37 1
a37 1
	@@dirlist = split /$path_delim/, $ENV{SSL_CERT_DIR};
a41 5
if (-d $dirlist[0]) {
	chdir $dirlist[0];
	$openssl="$pwd/$openssl" if (!-x $openssl);
	chdir $pwd;
}
d104 1
a104 1
		my ($hash, $fprint) = `"$openssl" x509 -hash -fingerprint -noout -in "$fname"`;
d125 1
a125 5
			open IN,"<$fname" or die "can't open $fname for read";
			open OUT,">$hash" or die "can't open $hash for write";
			print OUT <IN>;	# does the job for small text files
			close OUT;
			close IN;
@


