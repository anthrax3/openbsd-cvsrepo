head	1.8;
access;
symbols
	butholakala:1.7
	openssl_1_0_1_g:1.1.1.4
	OPENBSD_5_5:1.7.0.16
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.12
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.10
	OPENBSD_5_3_BASE:1.7
	openssl_1_0_1_c:1.1.1.4
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.8
	openssl_1_0_0_f:1.1.1.4
	openssl_1_0_0_e:1.1.1.4
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	openssh_1_0_0_a:1.1.1.4
	OPENBSD_4_8:1.6.0.30
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.26
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.28
	OPENBSD_4_6_BASE:1.6
	openssl_0_9_8_k:1.1.1.3
	OPENBSD_4_5:1.6.0.24
	OPENBSD_4_5_BASE:1.6
	openssl_0_9_8_j:1.1.1.3
	openssl_0_9_8_h:1.1.1.3
	pre_openssl_0_9_8h:1.6
	OPENBSD_4_4:1.6.0.22
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.20
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.18
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	openssl_0_9_7j:1.1.1.3
	openssl:1.1.1
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENSSL_0_9_7G:1.1.1.3
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENSSL_0_9_7D:1.1.1.3
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENSSL_0_9_7C:1.1.1.3
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.3.0.4
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.1.0.6
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@# @;


1.8
date	2014.04.20.19.23.08;	author afresh1;	state dead;
branches;
next	1.7;

1.7
date	2010.10.01.22.59.01;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.21;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.22.00.03.42;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.15.02.58.44;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.37.39;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.47;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.22.45.00;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.36.53;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.17;	author djm;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Remove unused/never installed libssl tools and docs and references to them

Sure deraadt
@
text
@#!/usr/local/bin/perl


# Perl c_rehash script, scan all files in a directory
# and add symbolic links to their hash values.

my $openssl;

my $dir;
my $prefix;

if(defined $ENV{OPENSSL}) {
	$openssl = $ENV{OPENSSL};
} else {
	$openssl = "openssl";
	$ENV{OPENSSL} = $openssl;
}

my $pwd;
eval "require Cwd";
if (defined(&Cwd::getcwd)) {
	$pwd=Cwd::getcwd();
} else {
	$pwd=`pwd`; chomp($pwd);
}
my $path_delim = ($pwd =~ /^[a-z]\:/i) ? ';' : ':'; # DOS/Win32 or Unix delimiter?

$ENV{PATH} = "$prefix/bin" . ($ENV{PATH} ? $path_delim . $ENV{PATH} : ""); # prefix our path

if(! -x $openssl) {
	my $found = 0;
	foreach (split /$path_delim/, $ENV{PATH}) {
		if(-x "$_/$openssl") {
			$found = 1;
			$openssl = "$_/$openssl";
			last;
		}	
	}
	if($found == 0) {
		print STDERR "c_rehash: rehashing skipped ('openssl' program not available)\n";
		exit 0;
	}
}

if(@@ARGV) {
	@@dirlist = @@ARGV;
} elsif($ENV{SSL_CERT_DIR}) {
	@@dirlist = split /$path_delim/, $ENV{SSL_CERT_DIR};
} else {
	$dirlist[0] = "$dir/certs";
}

if (-d $dirlist[0]) {
	chdir $dirlist[0];
	$openssl="$pwd/$openssl" if (!-x $openssl);
	chdir $pwd;
}

foreach (@@dirlist) {
	if(-d $_ and -w $_) {
		hash_dir($_);
	}
}

sub hash_dir {
	my %hashlist;
	print "Doing $_[0]\n";
	chdir $_[0];
	opendir(DIR, ".");
	my @@flist = readdir(DIR);
	# Delete any existing symbolic links
	foreach (grep {/^[\da-f]+\.r{0,1}\d+$/} @@flist) {
		if(-l $_) {
			unlink $_;
		}
	}
	closedir DIR;
	FILE: foreach $fname (grep {/\.pem$/} @@flist) {
		# Check to see if certificates and/or CRLs present.
		my ($cert, $crl) = check_file($fname);
		if(!$cert && !$crl) {
			print STDERR "WARNING: $fname does not contain a certificate or CRL: skipping\n";
			next;
		}
		link_hash_cert($fname) if($cert);
		link_hash_crl($fname) if($crl);
	}
}

sub check_file {
	my ($is_cert, $is_crl) = (0,0);
	my $fname = $_[0];
	open IN, $fname;
	while(<IN>) {
		if(/^-----BEGIN (.*)-----/) {
			my $hdr = $1;
			if($hdr =~ /^(X509 |TRUSTED |)CERTIFICATE$/) {
				$is_cert = 1;
				last if($is_crl);
			} elsif($hdr eq "X509 CRL") {
				$is_crl = 1;
				last if($is_cert);
			}
		}
	}
	close IN;
	return ($is_cert, $is_crl);
}


# Link a certificate to its subject name hash value, each hash is of
# the form <hash>.<n> where n is an integer. If the hash value already exists
# then we need to up the value of n, unless its a duplicate in which
# case we skip the link. We check for duplicates by comparing the
# certificate fingerprints

sub link_hash_cert {
		my $fname = $_[0];
		$fname =~ s/'/'\\''/g;
		my ($hash, $fprint) = `"$openssl" x509 -hash -fingerprint -noout -in "$fname"`;
		chomp $hash;
		chomp $fprint;
		$fprint =~ s/^.*=//;
		$fprint =~ tr/://d;
		my $suffix = 0;
		# Search for an unused hash filename
		while(exists $hashlist{"$hash.$suffix"}) {
			# Hash matches: if fingerprint matches its a duplicate cert
			if($hashlist{"$hash.$suffix"} eq $fprint) {
				print STDERR "WARNING: Skipping duplicate certificate $fname\n";
				return;
			}
			$suffix++;
		}
		$hash .= ".$suffix";
		print "$fname => $hash\n";
		$symlink_exists=eval {symlink("",""); 1};
		if ($symlink_exists) {
			symlink $fname, $hash;
		} else {
			open IN,"<$fname" or die "can't open $fname for read";
			open OUT,">$hash" or die "can't open $hash for write";
			print OUT <IN>;	# does the job for small text files
			close OUT;
			close IN;
		}
		$hashlist{$hash} = $fprint;
}

# Same as above except for a CRL. CRL links are of the form <hash>.r<n>

sub link_hash_crl {
		my $fname = $_[0];
		$fname =~ s/'/'\\''/g;
		my ($hash, $fprint) = `"$openssl" crl -hash -fingerprint -noout -in '$fname'`;
		chomp $hash;
		chomp $fprint;
		$fprint =~ s/^.*=//;
		$fprint =~ tr/://d;
		my $suffix = 0;
		# Search for an unused hash filename
		while(exists $hashlist{"$hash.r$suffix"}) {
			# Hash matches: if fingerprint matches its a duplicate cert
			if($hashlist{"$hash.r$suffix"} eq $fprint) {
				print STDERR "WARNING: Skipping duplicate CRL $fname\n";
				return;
			}
			$suffix++;
		}
		$hash .= ".r$suffix";
		print "$fname => $hash\n";
		$symlink_exists=eval {symlink("",""); 1};
		if ($symlink_exists) {
			symlink $fname, $hash;
		} else {
			system ("cp", $fname, $hash);
		}
		$hashlist{$hash} = $fprint;
}

@


1.7
log
@resolve conflicts, fix local changes
@
text
@@


1.6
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d10 1
d19 10
a28 1
$ENV{PATH} .= ":$dir/bin";
d32 1
a32 1
	foreach (split /:/, $ENV{PATH}) {
d35 1
d48 1
a48 1
	@@dirlist = split /:/, $ENV{SSL_CERT_DIR};
d53 5
d120 1
a120 1
		my ($hash, $fprint) = `"$openssl" x509 -hash -fingerprint -noout -in '$fname'`;
d141 5
a145 1
			system ("cp", $fname, $hash);
@


1.5
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d103 2
a104 1
		my ($hash, $fprint) = `$openssl x509 -hash -fingerprint -noout -in "$fname"`;
d134 2
a135 1
		my ($hash, $fprint) = `$openssl crl -hash -fingerprint -noout -in "$fname"`;
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d20 1
a20 1
if(! -f $openssl) {
d23 1
a23 1
		if(-f "$_/$openssl") {
@


1.3
log
@openssl-engine-0.9.6a merge
@
text
@d103 1
a103 1
		my ($hash, $fprint) = `$openssl x509 -hash -fingerprint -noout -in $fname`;
d133 1
a133 1
		my ($hash, $fprint) = `$openssl crl -hash -fingerprint -noout -in $fname`;
@


1.2
log
@openssl-engine-0.9.6 merge
@
text
@d120 6
a125 1
		symlink $fname, $hash;
d150 6
a155 1
		symlink $fname, $hash;
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d1 148
a148 61
#!/bin/sh
#
# redo the hashes for the certificates in your cert path or the ones passed
# on the command line.
#

if [ "$OPENSSL"x = "x" -o ! -x "$OPENSSL" ]; then
	OPENSSL='openssl'
	export OPENSSL
fi
DIR=/usr/local/ssl
PATH=$DIR/bin:$PATH

if [ ! -f "$OPENSSL" ]; then
    found=0
    for dir in . `echo $PATH | sed -e 's/:/ /g'`; do
        if [ -f "$dir/$OPENSSL" ]; then
            found=1
            break
        fi
    done
    if [ $found = 0 ]; then
        echo "c_rehash: rehashing skipped ('openssl' program not available)" 1>&2
        exit 0
    fi
fi

SSL_DIR=$DIR/certs

if [ "$*" = "" ]; then
	CERTS=${*:-${SSL_CERT_DIR:-$SSL_DIR}}
else
	CERTS=$*
fi

IFS=': '
for i in $CERTS
do
  (
  IFS=' '
  if [ -d $i -a -w $i ]; then
    cd $i
    echo "Doing $i"
    for i in *.pem
    do
      if [ $i != '*.pem' ]; then
        h=`$OPENSSL x509 -hash -noout -in $i`
	if [ "x$h" = "x" ]; then
	  echo $i does not contain a certificate
	else
          if [ -f $h.0 ]; then
            /bin/rm -f $h.0
          fi
          echo "$i => $h.0"
          ln -s $i $h.0
	fi
      fi
    done
  fi
  )
done
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d1 61
a61 158
#!/usr/local/bin/perl


# Perl c_rehash script, scan all files in a directory
# and add symbolic links to their hash values.

my $openssl;

my $dir;

if(defined $ENV{OPENSSL}) {
	$openssl = $ENV{OPENSSL};
} else {
	$openssl = "openssl";
	$ENV{OPENSSL} = $openssl;
}

$ENV{PATH} .= ":$dir/bin";

if(! -f $openssl) {
	my $found = 0;
	foreach (split /:/, $ENV{PATH}) {
		if(-f "$_/$openssl") {
			$found = 1;
			last;
		}	
	}
	if($found == 0) {
		print STDERR "c_rehash: rehashing skipped ('openssl' program not available)\n";
		exit 0;
	}
}

if(@@ARGV) {
	@@dirlist = @@ARGV;
} elsif($ENV{SSL_CERT_DIR}) {
	@@dirlist = split /:/, $ENV{SSL_CERT_DIR};
} else {
	$dirlist[0] = "$dir/certs";
}


foreach (@@dirlist) {
	if(-d $_ and -w $_) {
		hash_dir($_);
	}
}

sub hash_dir {
	my %hashlist;
	print "Doing $_[0]\n";
	chdir $_[0];
	opendir(DIR, ".");
	my @@flist = readdir(DIR);
	# Delete any existing symbolic links
	foreach (grep {/^[\da-f]+\.r{0,1}\d+$/} @@flist) {
		if(-l $_) {
			unlink $_;
		}
	}
	closedir DIR;
	FILE: foreach $fname (grep {/\.pem$/} @@flist) {
		# Check to see if certificates and/or CRLs present.
		my ($cert, $crl) = check_file($fname);
		if(!$cert && !$crl) {
			print STDERR "WARNING: $fname does not contain a certificate or CRL: skipping\n";
			next;
		}
		link_hash_cert($fname) if($cert);
		link_hash_crl($fname) if($crl);
	}
}

sub check_file {
	my ($is_cert, $is_crl) = (0,0);
	my $fname = $_[0];
	open IN, $fname;
	while(<IN>) {
		if(/^-----BEGIN (.*)-----/) {
			my $hdr = $1;
			if($hdr =~ /^(X509 |TRUSTED |)CERTIFICATE$/) {
				$is_cert = 1;
				last if($is_crl);
			} elsif($hdr eq "X509 CRL") {
				$is_crl = 1;
				last if($is_cert);
			}
		}
	}
	close IN;
	return ($is_cert, $is_crl);
}


# Link a certificate to its subject name hash value, each hash is of
# the form <hash>.<n> where n is an integer. If the hash value already exists
# then we need to up the value of n, unless its a duplicate in which
# case we skip the link. We check for duplicates by comparing the
# certificate fingerprints

sub link_hash_cert {
		my $fname = $_[0];
		my ($hash, $fprint) = `$openssl x509 -hash -fingerprint -noout -in "$fname"`;
		chomp $hash;
		chomp $fprint;
		$fprint =~ s/^.*=//;
		$fprint =~ tr/://d;
		my $suffix = 0;
		# Search for an unused hash filename
		while(exists $hashlist{"$hash.$suffix"}) {
			# Hash matches: if fingerprint matches its a duplicate cert
			if($hashlist{"$hash.$suffix"} eq $fprint) {
				print STDERR "WARNING: Skipping duplicate certificate $fname\n";
				return;
			}
			$suffix++;
		}
		$hash .= ".$suffix";
		print "$fname => $hash\n";
		$symlink_exists=eval {symlink("",""); 1};
		if ($symlink_exists) {
			symlink $fname, $hash;
		} else {
			system ("cp", $fname, $hash);
		}
		$hashlist{$hash} = $fprint;
}

# Same as above except for a CRL. CRL links are of the form <hash>.r<n>

sub link_hash_crl {
		my $fname = $_[0];
		my ($hash, $fprint) = `$openssl crl -hash -fingerprint -noout -in "$fname"`;
		chomp $hash;
		chomp $fprint;
		$fprint =~ s/^.*=//;
		$fprint =~ tr/://d;
		my $suffix = 0;
		# Search for an unused hash filename
		while(exists $hashlist{"$hash.r$suffix"}) {
			# Hash matches: if fingerprint matches its a duplicate cert
			if($hashlist{"$hash.r$suffix"} eq $fprint) {
				print STDERR "WARNING: Skipping duplicate CRL $fname\n";
				return;
			}
			$suffix++;
		}
		$hash .= ".r$suffix";
		print "$fname => $hash\n";
		$symlink_exists=eval {symlink("",""); 1};
		if ($symlink_exists) {
			symlink $fname, $hash;
		} else {
			system ("cp", $fname, $hash);
		}
		$hashlist{$hash} = $fprint;
}

@


1.1.1.2
log
@import openssl-0.9.7-beta3
@
text
@d20 1
a20 1
if(! -x $openssl) {
d23 1
a23 1
		if(-x "$_/$openssl") {
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d103 1
a103 2
		$fname =~ s/'/'\\''/g;
		my ($hash, $fprint) = `"$openssl" x509 -hash -fingerprint -noout -in '$fname'`;
d133 1
a133 2
		$fname =~ s/'/'\\''/g;
		my ($hash, $fprint) = `"$openssl" crl -hash -fingerprint -noout -in '$fname'`;
@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@a9 1
my $prefix;
d18 1
a18 10
my $pwd;
eval "require Cwd";
if (defined(&Cwd::getcwd)) {
	$pwd=Cwd::getcwd();
} else {
	$pwd=`pwd`; chomp($pwd);
}
my $path_delim = ($pwd =~ /^[a-z]\:/i) ? ';' : ':'; # DOS/Win32 or Unix delimiter?

$ENV{PATH} = "$prefix/bin" . ($ENV{PATH} ? $path_delim . $ENV{PATH} : ""); # prefix our path
d22 1
a22 1
	foreach (split /$path_delim/, $ENV{PATH}) {
a24 1
			$openssl = "$_/$openssl";
d37 1
a37 1
	@@dirlist = split /$path_delim/, $ENV{SSL_CERT_DIR};
a41 5
if (-d $dirlist[0]) {
	chdir $dirlist[0];
	$openssl="$pwd/$openssl" if (!-x $openssl);
	chdir $pwd;
}
d104 1
a104 1
		my ($hash, $fprint) = `"$openssl" x509 -hash -fingerprint -noout -in "$fname"`;
d125 1
a125 5
			open IN,"<$fname" or die "can't open $fname for read";
			open OUT,">$hash" or die "can't open $hash for write";
			print OUT <IN>;	# does the job for small text files
			close OUT;
			close IN;
@


