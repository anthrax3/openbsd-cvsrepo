head	1.33;
access;
symbols
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.27.0.4
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	butholakala:1.1.1.7
	openssl_1_0_1_g:1.1.1.7
	OPENSSL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.8
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.4
	OPENBSD_5_4_BASE:1.1.1.6
	OPENBSD_5_3:1.1.1.6.0.2
	OPENBSD_5_3_BASE:1.1.1.6
	openssl_1_0_1_c:1.1.1.6
	OPENBSD_5_2:1.1.1.5.0.2
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.4
	openssl_1_0_0_f:1.1.1.5
	openssl_1_0_0_e:1.1.1.4
	OPENBSD_5_0:1.1.1.3.0.4
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.2
	OPENBSD_4_9_BASE:1.1.1.3
	openssh_1_0_0_a:1.1.1.3
	OPENBSD_4_8:1.1.1.2.0.8
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.4
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.6
	OPENBSD_4_6_BASE:1.1.1.2
	openssl_0_9_8_k:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.2
	OPENBSD_4_5_BASE:1.1.1.2
	openssl_0_9_8_j:1.1.1.2
	openssl_0_9_8_h:1.1.1.1
	openssl:1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2016.02.29.06.48.03;	author mmcc;	state Exp;
branches;
next	1.32;
commitid	oWOcgaFtpCrx7PJ9;

1.32
date	2015.10.07.13.20.48;	author bcook;	state Exp;
branches;
next	1.31;
commitid	VfR0jmLy7R2agjcd;

1.31
date	2015.09.10.17.57.50;	author jsing;	state Exp;
branches;
next	1.30;
commitid	T35skZJCouRaXVVY;

1.30
date	2015.09.10.15.56.26;	author jsing;	state Exp;
branches;
next	1.29;
commitid	vHznCDK3idwNEFz4;

1.29
date	2015.07.19.20.32.18;	author doug;	state Exp;
branches;
next	1.28;
commitid	JJGxWtixsF6e0H2B;

1.28
date	2015.03.19.14.00.22;	author tedu;	state Exp;
branches;
next	1.27;
commitid	Ix1rLPv61p1TR5LF;

1.27
date	2015.02.09.10.53.28;	author jsing;	state Exp;
branches
	1.27.4.1;
next	1.26;
commitid	91DZ31h3Xbk1xWbU;

1.26
date	2014.12.14.15.30.50;	author jsing;	state Exp;
branches;
next	1.25;
commitid	XNZawfRSWvnVv1VS;

1.25
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.24;
commitid	M3pvHgIFoWUHNqJn;

1.24
date	2014.07.17.23.48.24;	author deraadt;	state Exp;
branches
	1.24.4.1;
next	1.23;
commitid	SvIcv0xWaEV65AYd;

1.23
date	2014.07.11.13.09.04;	author miod;	state Exp;
branches;
next	1.22;
commitid	0YYMQkVy8UiZ1eNF;

1.22
date	2014.07.09.11.10.51;	author bcook;	state Exp;
branches;
next	1.21;
commitid	lHJTcoC4c5BhEOGj;

1.21
date	2014.06.21.17.02.25;	author jsing;	state Exp;
branches;
next	1.20;
commitid	pgD7ISJAPEuMy3ok;

1.20
date	2014.06.13.04.29.13;	author miod;	state Exp;
branches;
next	1.19;
commitid	8Qu6YceLSxhOi4yG;

1.19
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	mJUVYpkFBZ0Zv2bG;

1.18
date	2014.06.11.13.19.53;	author logan;	state Exp;
branches;
next	1.17;
commitid	KW3D3a0lUCVde0xr;

1.17
date	2014.05.29.16.00.16;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2014.05.28.13.03.24;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2014.05.26.12.11.38;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2014.05.24.16.06.28;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2014.05.22.17.37.06;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.20.14.14.52;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.20.14.03.55;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.14.18.45.55;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.14.14.16.33;	author jsing;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.14.11.08.35;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.14.10.49.12;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2014.04.13.22.37.35;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.13.22.11.45;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.13.21.11.19;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.01.09.12.14.06;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.11.03.02.32.19;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.01.05.22.59.08;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2012.10.13.21.23.49;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;

1.24.4.1
date	2015.03.19.14.02.23;	author tedu;	state Exp;
branches;
next	;
commitid	bYTbbXa7PWk8y7To;

1.27.4.1
date	2015.03.19.14.01.16;	author tedu;	state Exp;
branches;
next	;
commitid	dQgHc1qjfDF6g1rY;


desc
@@


1.33
log
@remove NULL checks for pqueue_free()

ok doug@@
@
text
@/* $OpenBSD: d1_lib.c,v 1.32 2015/10/07 13:20:48 bcook Exp $ */
/*
 * DTLS implementation written by Nagendra Modadugu
 * (nagendra@@cs.stanford.edu) for the OpenSSL project 2005.
 */
/* ====================================================================
 * Copyright (c) 1999-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>

#include <netinet/in.h>

#include <stdio.h>

#include <openssl/objects.h>

#include "pqueue.h"
#include "ssl_locl.h"

int dtls1_listen(SSL *s, struct sockaddr *client);

SSL3_ENC_METHOD DTLSv1_enc_data = {
	.enc = dtls1_enc,
	.mac = tls1_mac,
	.setup_key_block = tls1_setup_key_block,
	.generate_master_secret = tls1_generate_master_secret,
	.change_cipher_state = tls1_change_cipher_state,
	.final_finish_mac = tls1_final_finish_mac,
	.finish_mac_length = TLS1_FINISH_MAC_LENGTH,
	.cert_verify_mac = tls1_cert_verify_mac,
	.client_finished_label = TLS_MD_CLIENT_FINISH_CONST,
	.client_finished_label_len = TLS_MD_CLIENT_FINISH_CONST_SIZE,
	.server_finished_label = TLS_MD_SERVER_FINISH_CONST,
	.server_finished_label_len = TLS_MD_SERVER_FINISH_CONST_SIZE,
	.alert_value = tls1_alert_code,
	.export_keying_material = tls1_export_keying_material,
	.enc_flags = SSL_ENC_FLAG_DTLS|SSL_ENC_FLAG_EXPLICIT_IV,
};

long
dtls1_default_timeout(void)
{
	/* 2 hours, the 24 hours mentioned in the DTLSv1 spec
	 * is way too long for http, the cache would over fill */
	return (60*60*2);
}

int
dtls1_new(SSL *s)
{
	DTLS1_STATE *d1;

	if (!ssl3_new(s))
		return (0);
	if ((d1 = calloc(1, sizeof *d1)) == NULL) {
		ssl3_free(s);
		return (0);
	}

	/* d1->handshake_epoch=0; */

	d1->unprocessed_rcds.q = pqueue_new();
	d1->processed_rcds.q = pqueue_new();
	d1->buffered_messages = pqueue_new();
	d1->sent_messages = pqueue_new();
	d1->buffered_app_data.q = pqueue_new();

	if (s->server) {
		d1->cookie_len = sizeof(s->d1->cookie);
	}

	if (!d1->unprocessed_rcds.q || !d1->processed_rcds.q ||
	    !d1->buffered_messages || !d1->sent_messages ||
	    !d1->buffered_app_data.q) {
		pqueue_free(d1->unprocessed_rcds.q);
		pqueue_free(d1->processed_rcds.q);
		pqueue_free(d1->buffered_messages);
		pqueue_free(d1->sent_messages);
		pqueue_free(d1->buffered_app_data.q);
		free(d1);
		ssl3_free(s);
		return (0);
	}

	s->d1 = d1;
	s->method->ssl_clear(s);
	return (1);
}

static void
dtls1_clear_queues(SSL *s)
{
	pitem *item = NULL;
	hm_fragment *frag = NULL;
	DTLS1_RECORD_DATA *rdata;

	while ((item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL) {
		rdata = (DTLS1_RECORD_DATA *) item->data;
		free(rdata->rbuf.buf);
		free(item->data);
		pitem_free(item);
	}

	while ((item = pqueue_pop(s->d1->processed_rcds.q)) != NULL) {
		rdata = (DTLS1_RECORD_DATA *) item->data;
		free(rdata->rbuf.buf);
		free(item->data);
		pitem_free(item);
	}

	while ((item = pqueue_pop(s->d1->buffered_messages)) != NULL) {
		frag = (hm_fragment *)item->data;
		free(frag->fragment);
		free(frag);
		pitem_free(item);
	}

	while ((item = pqueue_pop(s->d1->sent_messages)) != NULL) {
		frag = (hm_fragment *)item->data;
		free(frag->fragment);
		free(frag);
		pitem_free(item);
	}

	while ((item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL) {
		rdata = (DTLS1_RECORD_DATA *) item->data;
		free(rdata->rbuf.buf);
		free(item->data);
		pitem_free(item);
	}
}

void
dtls1_free(SSL *s)
{
	if (s == NULL)
		return;

	ssl3_free(s);

	dtls1_clear_queues(s);

	pqueue_free(s->d1->unprocessed_rcds.q);
	pqueue_free(s->d1->processed_rcds.q);
	pqueue_free(s->d1->buffered_messages);
	pqueue_free(s->d1->sent_messages);
	pqueue_free(s->d1->buffered_app_data.q);

	explicit_bzero(s->d1, sizeof *s->d1);
	free(s->d1);
	s->d1 = NULL;
}

void
dtls1_clear(SSL *s)
{
	pqueue unprocessed_rcds;
	pqueue processed_rcds;
	pqueue buffered_messages;
	pqueue sent_messages;
	pqueue buffered_app_data;
	unsigned int mtu;

	if (s->d1) {
		unprocessed_rcds = s->d1->unprocessed_rcds.q;
		processed_rcds = s->d1->processed_rcds.q;
		buffered_messages = s->d1->buffered_messages;
		sent_messages = s->d1->sent_messages;
		buffered_app_data = s->d1->buffered_app_data.q;
		mtu = s->d1->mtu;

		dtls1_clear_queues(s);

		memset(s->d1, 0, sizeof(*(s->d1)));

		if (s->server) {
			s->d1->cookie_len = sizeof(s->d1->cookie);
		}

		if (SSL_get_options(s) & SSL_OP_NO_QUERY_MTU) {
			s->d1->mtu = mtu;
		}

		s->d1->unprocessed_rcds.q = unprocessed_rcds;
		s->d1->processed_rcds.q = processed_rcds;
		s->d1->buffered_messages = buffered_messages;
		s->d1->sent_messages = sent_messages;
		s->d1->buffered_app_data.q = buffered_app_data;
	}

	ssl3_clear(s);

	s->version = DTLS1_VERSION;
}

long
dtls1_ctrl(SSL *s, int cmd, long larg, void *parg)
{
	int ret = 0;

	switch (cmd) {
	case DTLS_CTRL_GET_TIMEOUT:
		if (dtls1_get_timeout(s, (struct timeval*) parg) != NULL) {
			ret = 1;
		}
		break;
	case DTLS_CTRL_HANDLE_TIMEOUT:
		ret = dtls1_handle_timeout(s);
		break;
	case DTLS_CTRL_LISTEN:
		ret = dtls1_listen(s, parg);
		break;

	default:
		ret = ssl3_ctrl(s, cmd, larg, parg);
		break;
	}
	return (ret);
}

/*
 * As it's impossible to use stream ciphers in "datagram" mode, this
 * simple filter is designed to disengage them in DTLS. Unfortunately
 * there is no universal way to identify stream SSL_CIPHER, so we have
 * to explicitly list their SSL_* codes. Currently RC4 is the only one
 * available, but if new ones emerge, they will have to be added...
 */
const SSL_CIPHER *
dtls1_get_cipher(unsigned int u)
{
	const SSL_CIPHER *ciph = ssl3_get_cipher(u);

	if (ciph != NULL) {
		if (ciph->algorithm_enc == SSL_RC4)
			return NULL;
	}

	return ciph;
}

void
dtls1_start_timer(SSL *s)
{

	/* If timer is not set, initialize duration with 1 second */
	if (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0) {
		s->d1->timeout_duration = 1;
	}

	/* Set timeout to current time */
	gettimeofday(&(s->d1->next_timeout), NULL);

	/* Add duration to current time */
	s->d1->next_timeout.tv_sec += s->d1->timeout_duration;
	BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0,
	    &(s->d1->next_timeout));
}

struct timeval*
dtls1_get_timeout(SSL *s, struct timeval* timeleft)
{
	struct timeval timenow;

	/* If no timeout is set, just return NULL */
	if (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0) {
		return NULL;
	}

	/* Get current time */
	gettimeofday(&timenow, NULL);

	/* If timer already expired, set remaining time to 0 */
	if (s->d1->next_timeout.tv_sec < timenow.tv_sec ||
	    (s->d1->next_timeout.tv_sec == timenow.tv_sec &&
	     s->d1->next_timeout.tv_usec <= timenow.tv_usec)) {
		memset(timeleft, 0, sizeof(struct timeval));
		return timeleft;
	}

	/* Calculate time left until timer expires */
	memcpy(timeleft, &(s->d1->next_timeout), sizeof(struct timeval));
	timeleft->tv_sec -= timenow.tv_sec;
	timeleft->tv_usec -= timenow.tv_usec;
	if (timeleft->tv_usec < 0) {
		timeleft->tv_sec--;
		timeleft->tv_usec += 1000000;
	}

	/* If remaining time is less than 15 ms, set it to 0
	 * to prevent issues because of small devergences with
	 * socket timeouts.
	 */
	if (timeleft->tv_sec == 0 && timeleft->tv_usec < 15000) {
		memset(timeleft, 0, sizeof(struct timeval));
	}


	return timeleft;
}

int
dtls1_is_timer_expired(SSL *s)
{
	struct timeval timeleft;

	/* Get time left until timeout, return false if no timer running */
	if (dtls1_get_timeout(s, &timeleft) == NULL) {
		return 0;
	}

	/* Return false if timer is not expired yet */
	if (timeleft.tv_sec > 0 || timeleft.tv_usec > 0) {
		return 0;
	}

	/* Timer expired, so return true */
	return 1;
}

void
dtls1_double_timeout(SSL *s)
{
	s->d1->timeout_duration *= 2;
	if (s->d1->timeout_duration > 60)
		s->d1->timeout_duration = 60;
	dtls1_start_timer(s);
}

void
dtls1_stop_timer(SSL *s)
{
	/* Reset everything */
	memset(&(s->d1->timeout), 0, sizeof(struct dtls1_timeout_st));
	memset(&(s->d1->next_timeout), 0, sizeof(struct timeval));
	s->d1->timeout_duration = 1;
	BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0,
	    &(s->d1->next_timeout));
	/* Clear retransmission buffer */
	dtls1_clear_record_buffer(s);
}

int
dtls1_check_timeout_num(SSL *s)
{
	s->d1->timeout.num_alerts++;

	/* Reduce MTU after 2 unsuccessful retransmissions */
	if (s->d1->timeout.num_alerts > 2) {
		s->d1->mtu = BIO_ctrl(SSL_get_wbio(s),
		    BIO_CTRL_DGRAM_GET_FALLBACK_MTU, 0, NULL);

	}

	if (s->d1->timeout.num_alerts > DTLS1_TMO_ALERT_COUNT) {
		/* fail the connection, enough alerts have been sent */
		SSLerr(SSL_F_DTLS1_CHECK_TIMEOUT_NUM, SSL_R_READ_TIMEOUT_EXPIRED);
		return -1;
	}

	return 0;
}

int
dtls1_handle_timeout(SSL *s)
{
	/* if no timer is expired, don't do anything */
	if (!dtls1_is_timer_expired(s)) {
		return 0;
	}

	dtls1_double_timeout(s);

	if (dtls1_check_timeout_num(s) < 0)
		return -1;

	s->d1->timeout.read_timeouts++;
	if (s->d1->timeout.read_timeouts > DTLS1_TMO_READ_COUNT) {
		s->d1->timeout.read_timeouts = 1;
	}

	dtls1_start_timer(s);
	return dtls1_retransmit_buffered_messages(s);
}

int
dtls1_listen(SSL *s, struct sockaddr *client)
{
	int ret;

	/* Ensure there is no state left over from a previous invocation */
	SSL_clear(s);

	SSL_set_options(s, SSL_OP_COOKIE_EXCHANGE);
	s->d1->listen = 1;

	ret = SSL_accept(s);
	if (ret <= 0)
		return ret;

	(void)BIO_dgram_get_peer(SSL_get_rbio(s), client);
	return 1;
}

void
dtls1_build_sequence_number(unsigned char *dst, unsigned char *seq,
    unsigned short epoch)
{
	unsigned char dtlsseq[SSL3_SEQUENCE_SIZE];
	unsigned char *p;

	p = dtlsseq;
	s2n(epoch, p);
	memcpy(p, &seq[2], SSL3_SEQUENCE_SIZE - 2);
	memcpy(dst, dtlsseq, SSL3_SEQUENCE_SIZE);
}
@


1.32
log
@include <sys/time.h> for gettimeofday(2)
@
text
@d1 1
a1 1
/* $OpenBSD: d1_lib.c,v 1.31 2015/09/10 17:57:50 jsing Exp $ */
d128 5
a132 10
		if (d1->unprocessed_rcds.q)
			pqueue_free(d1->unprocessed_rcds.q);
		if (d1->processed_rcds.q)
			pqueue_free(d1->processed_rcds.q);
		if (d1->buffered_messages)
			pqueue_free(d1->buffered_messages);
		if (d1->sent_messages)
			pqueue_free(d1->sent_messages);
		if (d1->buffered_app_data.q)
			pqueue_free(d1->buffered_app_data.q);
@


1.31
log
@Remove support for DTLS_BAD_VER. We do not support non-standard and
incomplete implementations just so that we can interoperate with products
from vendors who have not bothered to fix things in the last ~10 years.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_lib.c,v 1.30 2015/09/10 15:56:26 jsing Exp $ */
d62 1
@


1.30
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_lib.c,v 1.29 2015/07/19 20:32:18 doug Exp $ */
d249 2
a250 4
	if (s->options & SSL_OP_CISCO_ANYCONNECT)
		s->version = DTLS1_BAD_VER;
	else
		s->version = DTLS1_VERSION;
@


1.29
log
@Allow *_free() functions in libssl to handle NULL input.

This mimics free()'s behavior which makes error handling simpler.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_lib.c,v 1.28 2015/03/19 14:00:22 tedu Exp $ */
d206 1
a206 1
	OPENSSL_cleanse(s->d1, sizeof *s->d1);
@


1.28
log
@Fix several crash causing defects from OpenSSL.
These include:
CVE-2015-0209 - Use After Free following d2i_ECPrivatekey error
CVE-2015-0286 - Segmentation fault in ASN1_TYPE_cmp
CVE-2015-0287 - ASN.1 structure reuse memory corruption
CVE-2015-0289 - PKCS7 NULL pointer dereferences

Several other issues did not apply or were already fixed.
Refer to https://www.openssl.org/news/secadv_20150319.txt

joint work with beck, doug, guenther, jsing, miod
@
text
@d1 1
a1 1
/* $OpenBSD: d1_lib.c,v 1.27 2015/02/09 10:53:28 jsing Exp $ */
d193 3
@


1.27
log
@Jettison DTLS over SCTP.

OpenBSD does not have SCTP support and it sees little use in the wild.
OPENSSL_NO_SCTP is already specified via opensslfeatures.h, hence this
is a code removal only and symbols should remain unchanged.

ok beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_lib.c,v 1.26 2014/12/14 15:30:50 jsing Exp $ */
d445 3
@


1.27.4.1
log
@Fix several crash causing defects from OpenSSL.
These include:
CVE-2015-0209 - Use After Free following d2i_ECPrivatekey error
CVE-2015-0286 - Segmentation fault in ASN1_TYPE_cmp
CVE-2015-0287 - ASN.1 structure reuse memory corruption
CVE-2015-0288 - X509_to_X509_REQ NULL pointer deref
CVE-2015-0289 - PKCS7 NULL pointer dereferences

Several other issues did not apply or were already fixed.
Refer to https://www.openssl.org/news/secadv_20150319.txt

joint work with beck, doug, guenther, jsing, miod
@
text
@d1 1
a1 1
/* $OpenBSD: d1_lib.c,v 1.27 2015/02/09 10:53:28 jsing Exp $ */
a444 3

	/* Ensure there is no state left over from a previous invocation */
	SSL_clear(s);
@


1.26
log
@Remove trailing whitespace.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_lib.c,v 1.25 2014/11/16 14:12:47 jsing Exp $ */
a299 7
#ifndef OPENSSL_NO_SCTP
	/* Disable timer for SCTP */
	if (BIO_dgram_is_sctp(SSL_get_wbio(s))) {
		memset(&(s->d1->next_timeout), 0, sizeof(struct timeval));
		return;
	}
#endif
@


1.25
log
@Sort and group includes.
@
text
@d1 2
a2 2
/* $OpenBSD: d1_lib.c,v 1.24 2014/07/17 23:48:24 deraadt Exp $ */
/* 
d4 1
a4 1
 * (nagendra@@cs.stanford.edu) for the OpenSSL project 2005.  
d14 1
a14 1
 *    notice, this list of conditions and the following disclaimer. 
@


1.24
log
@avoid sys/param.h; Jonas Termansen
@
text
@d1 1
a1 1
/* $OpenBSD: d1_lib.c,v 1.23 2014/07/11 13:09:04 miod Exp $ */
d66 1
@


1.24.4.1
log
@Fix several crash causing defects from OpenSSL.
These include:
CVE-2015-0209 - Use After Free following d2i_ECPrivatekey error
CVE-2015-0286 - Segmentation fault in ASN1_TYPE_cmp
CVE-2015-0287 - ASN.1 structure reuse memory corruption
CVE-2015-0288 - X509_to_X509_REQ NULL pointer deref
CVE-2015-0289 - PKCS7 NULL pointer dereferences

Several other issues did not apply or were already fixed.
Refer to https://www.openssl.org/news/secadv_20150319.txt

joint work with beck, doug, guenther, jsing, miod
@
text
@d1 1
a1 1
/* $OpenBSD: d1_lib.c,v 1.24 2014/07/17 23:48:24 deraadt Exp $ */
a450 3

	/* Ensure there is no state left over from a previous invocation */
	SSL_clear(s);
@


1.23
log
@In dtls1_clear_queues(), free buffered_add_data.q correctly, it's made of
DTLS1_RECORD_DATA, not hm_fragment.

OpenSSL PR #3286 via OpenSSL trunk.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_lib.c,v 1.22 2014/07/09 11:10:51 bcook Exp $ */
d60 1
a60 1
#include <sys/param.h>
@


1.22
log
@remove unused, private version strings except SSL_version_str

Also remove unused des_ver.h, which exports some of these strings, but is not installed.

ok miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_lib.c,v 1.21 2014/06/21 17:02:25 jsing Exp $ */
d182 3
a184 3
		frag = (hm_fragment *)item->data;
		free(frag->fragment);
		free(frag);
@


1.21
log
@Pull the code that builds a DTLS sequence number out into its own function
to avoid duplication. Also use fewer magic numbers.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_lib.c,v 1.20 2014/06/13 04:29:13 miod Exp $ */
a70 1
const char dtls1_version_str[]="DTLSv1" OPENSSL_VERSION_PTEXT;
@


1.20
log
@Remove support for the `opaque PRF input' extension, which draft has expired
7 years ago and never made it into an RFC. That code wasn't compiled in
anyway unless one would define the actual on-the-wire extension id bytes;
crank libssl major.

With help and enlightenment from Brendan MacDonell.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_lib.c,v 1.19 2014/06/12 15:49:31 deraadt Exp $ */
d462 13
@


1.19
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d138 1
d203 1
@


1.18
log
@Fix memory leak: free s if calloc fails.

(From Jonas Maebe)

OK from beck@@
@
text
@d1 1
a1 1
/* ssl/d1_lib.c */
@


1.17
log
@Make it substantially easier to identify protocol version requirements
by adding an enc_flags field to the ssl3_enc_method, specifying four flags
that are used with this field and providing macros for evaluating these
conditions. Currently the version requirements are identified by
continually checking the version number and other criteria.

This change also adds separate SSL3_ENC_METHOD data for TLS v1.1 and v1.2,
since they have different enc_flags from TLS v1.

Based on changes in OpenSSL head.

No objection from miod@@
@
text
@d107 2
a108 1
	if ((d1 = calloc(1, sizeof *d1)) == NULL)
d110 1
@


1.16
log
@There is no point in checking if a pointer is non-NULL before calling free,
since free already does this for us. Also remove some pointless NULL
assignments, where the result from malloc(3) is immediately assigned to the
same variable.

ok miod@@
@
text
@d89 1
@


1.15
log
@repair some KNF missed by the script; ok jsing
@
text
@d152 1
a152 3
		if (rdata->rbuf.buf) {
			free(rdata->rbuf.buf);
		}
d159 1
a159 3
		if (rdata->rbuf.buf) {
			free(rdata->rbuf.buf);
		}
@


1.14
log
@Use C99 initialisers for SSL3_ENC_METHOD structs.

ok miod@@
@
text
@d317 2
a318 1
	BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout));
d322 2
a323 1
dtls1_get_timeout(SSL *s, struct timeval* timeleft) {
d336 2
a337 2
		(s->d1->next_timeout.tv_sec == timenow.tv_sec &&
	s->d1->next_timeout.tv_usec <= timenow.tv_usec)) {
d398 2
a399 1
	BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout));
d411 2
a412 1
		s->d1->mtu = BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_GET_FALLBACK_MTU, 0, NULL);
@


1.13
log
@Stop pulling pqueue.h into ssl_locl.h since only a small part of libssl
actually needs it. Instead, just include it in the files where it is
actually necessary.

Also remove standard includes from pqueue.h so that they are not available
as a side effect. Just add the two includes that are needed to pqueue.c.

ok miod@@
@
text
@d75 14
a88 12
	dtls1_enc,
	tls1_mac,
	tls1_setup_key_block,
	tls1_generate_master_secret,
	tls1_change_cipher_state,
	tls1_final_finish_mac,
	TLS1_FINISH_MAC_LENGTH,
	tls1_cert_verify_mac,
	TLS_MD_CLIENT_FINISH_CONST, TLS_MD_CLIENT_FINISH_CONST_SIZE,
	TLS_MD_SERVER_FINISH_CONST, TLS_MD_SERVER_FINISH_CONST_SIZE,
	tls1_alert_code,
	tls1_export_keying_material,
@


1.12
log
@gettimeofday() is portable enough and does not need a wrapper
@
text
@d67 2
@


1.11
log
@calloc() rather than malloc+memset
@
text
@a68 1
static void get_current_time(struct timeval *t);
d309 1
a309 1
	get_current_time(&(s->d1->next_timeout));
d326 1
a326 1
	get_current_time(&timenow);
a436 6
}

static void
get_current_time(struct timeval *t)
{
	gettimeofday(t, NULL);
@


1.10
log
@More KNF and style consistency tweaks
@
text
@d103 2
a104 2
	if ((d1 = malloc(sizeof *d1)) == NULL) return (0);
		memset(d1, 0, sizeof *d1);
@


1.9
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d280 2
a281 2
const SSL_CIPHER
*dtls1_get_cipher(unsigned int u)
@


1.8
log
@make OPENSSL_NO_HEARTBLEED the default and only option. ok deraadt miod
@
text
@d103 1
a103 1
	if ((d1 = OPENSSL_malloc(sizeof *d1)) == NULL) return (0);
d131 1
a131 1
		OPENSSL_free(d1);
d150 1
a150 1
			OPENSSL_free(rdata->rbuf.buf);
d152 1
a152 1
		OPENSSL_free(item->data);
d159 1
a159 1
			OPENSSL_free(rdata->rbuf.buf);
d161 1
a161 1
		OPENSSL_free(item->data);
d167 2
a168 2
		OPENSSL_free(frag->fragment);
		OPENSSL_free(frag);
d174 2
a175 2
		OPENSSL_free(frag->fragment);
		OPENSSL_free(frag);
d181 2
a182 2
		OPENSSL_free(frag->fragment);
		OPENSSL_free(frag);
d200 1
a200 1
	OPENSSL_free(s->d1);
@


1.7
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a435 7
#ifndef OPENSSL_NO_HEARTBEATS
	if (s->tlsext_hb_pending) {
		s->tlsext_hb_pending = 0;
		return dtls1_heartbeat(s);
	}
#endif

@


1.6
log
@Revert previous.  I don't known why cvs blame tells me I committed this,
but after cross-checking with 1.0.1g sources, they are not coming from
my change.
@
text
@d73 2
a74 2
SSL3_ENC_METHOD DTLSv1_enc_data={
    dtls1_enc,
d82 2
a83 2
	TLS_MD_CLIENT_FINISH_CONST,TLS_MD_CLIENT_FINISH_CONST_SIZE,
	TLS_MD_SERVER_FINISH_CONST,TLS_MD_SERVER_FINISH_CONST_SIZE,
d86 1
a86 1
	};
d88 3
a90 2
long dtls1_default_timeout(void)
	{
d93 2
a94 2
	return(60*60*2);
	}
d96 3
a98 2
int dtls1_new(SSL *s)
	{
d101 4
a104 3
	if (!ssl3_new(s)) return(0);
	if ((d1=OPENSSL_malloc(sizeof *d1)) == NULL) return (0);
	memset(d1,0, sizeof *d1);
d108 2
a109 2
	d1->unprocessed_rcds.q=pqueue_new();
	d1->processed_rcds.q=pqueue_new();
d111 2
a112 2
	d1->sent_messages=pqueue_new();
	d1->buffered_app_data.q=pqueue_new();
d114 1
a114 2
	if ( s->server)
		{
d116 1
a116 1
		}
d118 13
a130 8
	if( ! d1->unprocessed_rcds.q || ! d1->processed_rcds.q 
        || ! d1->buffered_messages || ! d1->sent_messages || ! d1->buffered_app_data.q)
		{
        if ( d1->unprocessed_rcds.q) pqueue_free(d1->unprocessed_rcds.q);
        if ( d1->processed_rcds.q) pqueue_free(d1->processed_rcds.q);
        if ( d1->buffered_messages) pqueue_free(d1->buffered_messages);
		if ( d1->sent_messages) pqueue_free(d1->sent_messages);
		if ( d1->buffered_app_data.q) pqueue_free(d1->buffered_app_data.q);
d133 1
a133 1
		}
d135 1
a135 1
	s->d1=d1;
d137 2
a138 2
	return(1);
	}
d140 5
a144 4
static void dtls1_clear_queues(SSL *s)
	{
    pitem *item = NULL;
    hm_fragment *frag = NULL;
d147 1
a147 2
    while( (item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL)
        {
d149 1
a149 2
		if (rdata->rbuf.buf)
			{
d151 4
a154 4
			}
        OPENSSL_free(item->data);
        pitem_free(item);
        }
d156 1
a156 2
    while( (item = pqueue_pop(s->d1->processed_rcds.q)) != NULL)
        {
d158 1
a158 2
		if (rdata->rbuf.buf)
			{
d160 18
a177 20
			}
        OPENSSL_free(item->data);
        pitem_free(item);
        }

    while( (item = pqueue_pop(s->d1->buffered_messages)) != NULL)
        {
        frag = (hm_fragment *)item->data;
        OPENSSL_free(frag->fragment);
        OPENSSL_free(frag);
        pitem_free(item);
        }

    while ( (item = pqueue_pop(s->d1->sent_messages)) != NULL)
        {
        frag = (hm_fragment *)item->data;
        OPENSSL_free(frag->fragment);
        OPENSSL_free(frag);
        pitem_free(item);
        }
d179 1
a179 2
	while ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL)
		{
a183 1
		}
d185 1
d187 3
a189 2
void dtls1_free(SSL *s)
	{
d194 3
a196 3
    pqueue_free(s->d1->unprocessed_rcds.q);
    pqueue_free(s->d1->processed_rcds.q);
    pqueue_free(s->d1->buffered_messages);
d202 1
a202 1
	}
d204 6
a209 5
void dtls1_clear(SSL *s)
	{
    pqueue unprocessed_rcds;
    pqueue processed_rcds;
    pqueue buffered_messages;
d214 1
a214 2
	if (s->d1)
		{
d226 1
a226 2
		if (s->server)
			{
d228 1
a228 1
			}
d230 1
a230 2
		if (SSL_get_options(s) & SSL_OP_NO_QUERY_MTU)
			{
d232 1
a232 1
			}
d239 1
a239 1
		}
d243 1
a243 1
		s->version=DTLS1_BAD_VER;
d245 2
a246 2
		s->version=DTLS1_VERSION;
	}
d248 4
a251 3
long dtls1_ctrl(SSL *s, int cmd, long larg, void *parg)
	{
	int ret=0;
d253 1
a253 2
	switch (cmd)
		{
d255 1
a255 2
		if (dtls1_get_timeout(s, (struct timeval*) parg) != NULL)
			{
d257 1
a257 1
			}
a268 2
		}
	return(ret);
d270 2
d280 3
a282 2
const SSL_CIPHER *dtls1_get_cipher(unsigned int u)
	{
d285 1
a285 2
	if (ciph != NULL)
		{
d288 1
a288 1
		}
d291 1
a291 1
	}
d293 3
a295 2
void dtls1_start_timer(SSL *s)
	{
d298 1
a298 2
	if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
		{
d301 1
a301 1
		}
d305 1
a305 2
	if (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0)
		{
d307 2
a308 2
		}
	
d315 1
a315 1
	}
d317 2
a318 2
struct timeval* dtls1_get_timeout(SSL *s, struct timeval* timeleft)
	{
d322 1
a322 2
	if (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0)
		{
d324 1
a324 1
		}
d332 1
a332 2
		 s->d1->next_timeout.tv_usec <= timenow.tv_usec))
		{
d335 1
a335 1
		}
d341 1
a341 2
	if (timeleft->tv_usec < 0)
		{
d344 1
a344 1
		}
d350 1
a350 2
	if (timeleft->tv_sec == 0 && timeleft->tv_usec < 15000)
		{
d352 2
a353 2
		}
	
d356 1
a356 1
	}
d358 3
a360 2
int dtls1_is_timer_expired(SSL *s)
	{
d364 1
a364 2
	if (dtls1_get_timeout(s, &timeleft) == NULL)
		{
d366 1
a366 1
		}
d369 1
a369 2
	if (timeleft.tv_sec > 0 || timeleft.tv_usec > 0)
		{
d371 1
a371 1
		}
d373 1
a373 1
	/* Timer expired, so return true */	
d375 1
a375 1
	}
d377 3
a379 2
void dtls1_double_timeout(SSL *s)
	{
d384 1
a384 1
	}
d386 3
a388 2
void dtls1_stop_timer(SSL *s)
	{
d396 1
a396 1
	}
d398 3
a400 2
int dtls1_check_timeout_num(SSL *s)
	{
d404 4
a407 4
	if (s->d1->timeout.num_alerts > 2)
		{
		s->d1->mtu = BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_GET_FALLBACK_MTU, 0, NULL);		
		}
d409 1
a409 2
	if (s->d1->timeout.num_alerts > DTLS1_TMO_ALERT_COUNT)
		{
d411 1
a411 1
		SSLerr(SSL_F_DTLS1_CHECK_TIMEOUT_NUM,SSL_R_READ_TIMEOUT_EXPIRED);
d413 1
a413 1
		}
d416 1
a416 1
	}
d418 3
a420 2
int dtls1_handle_timeout(SSL *s)
	{
d422 1
a422 2
	if (!dtls1_is_timer_expired(s))
		{
d424 1
a424 1
		}
d432 1
a432 2
	if (s->d1->timeout.read_timeouts > DTLS1_TMO_READ_COUNT)
		{
d434 1
a434 1
		}
d437 1
a437 2
	if (s->tlsext_hb_pending)
		{
d440 1
a440 1
		}
d445 1
a445 1
	}
d447 2
a448 1
static void get_current_time(struct timeval *t)
d453 3
a455 2
int dtls1_listen(SSL *s, struct sockaddr *client)
	{
d462 4
a465 3
	if (ret <= 0) return ret;
	
	(void) BIO_dgram_get_peer(SSL_get_rbio(s), client);
d467 1
a467 1
	}
@


1.5
log
@Revert to 1.1 minus the VMS stuff, I accidentally committed this chunk
in my last change.
@
text
@d60 5
d69 1
d71 1
d85 1
a94 5
IMPLEMENT_dtls1_meth_func(dtlsv1_base_method,
			ssl_undefined_function,
			ssl_undefined_function,
			ssl_bad_method)

a103 6
	d1->bitmap.length=sizeof(d1->bitmap.map) * 8;
	pq_64bit_init(&(d1->bitmap.map));
	pq_64bit_init(&(d1->bitmap.max_seq_num));
	
	pq_64bit_init(&(d1->next_bitmap.map));
	pq_64bit_init(&(d1->next_bitmap.max_seq_num));
d109 1
d117 1
a117 1
        || ! d1->buffered_messages || ! d1->sent_messages)
d123 1
d133 1
a133 1
void dtls1_free(SSL *s)
d137 1
a137 2

	ssl3_free(s);
d141 5
a148 1
    pqueue_free(s->d1->unprocessed_rcds.q);
d152 5
a159 1
    pqueue_free(s->d1->processed_rcds.q);
a167 1
    pqueue_free(s->d1->buffered_messages);
a175 1
	pqueue_free(s->d1->sent_messages);
d177 12
a188 2
	pq_64bit_free(&(s->d1->bitmap.map));
	pq_64bit_free(&(s->d1->bitmap.max_seq_num));
d190 7
a196 2
	pq_64bit_free(&(s->d1->next_bitmap.map));
	pq_64bit_free(&(s->d1->next_bitmap.max_seq_num));
d199 1
d204 37
d242 30
a271 1
	s->version=DTLS1_VERSION;
d281 1
a281 1
SSL_CIPHER *dtls1_get_cipher(unsigned int u)
d283 1
a283 1
	SSL_CIPHER *ciph = ssl3_get_cipher(u);
d287 1
a287 1
		if ((ciph->algorithms&SSL_ENC_MASK) == SSL_RC4)
d292 179
@


1.4
log
@Fix the gettimeofday function that I broke with my last commit.
noticed by mattheew and deraadt
ok deraadt@@
@
text
@a59 5
#include <sys/param.h>
#include <sys/socket.h>

#include <netinet/in.h>

a63 1
static void get_current_time(struct timeval *t);
a64 1
int dtls1_listen(SSL *s, struct sockaddr *client);
a77 1
	tls1_export_keying_material,
d87 5
d101 6
a111 1
	d1->buffered_app_data.q=pqueue_new();
d119 1
a119 1
        || ! d1->buffered_messages || ! d1->sent_messages || ! d1->buffered_app_data.q)
a124 1
		if ( d1->buffered_app_data.q) pqueue_free(d1->buffered_app_data.q);
d134 1
a134 1
static void dtls1_clear_queues(SSL *s)
d138 2
a139 1
	DTLS1_RECORD_DATA *rdata;
a142 5
		rdata = (DTLS1_RECORD_DATA *) item->data;
		if (rdata->rbuf.buf)
			{
			OPENSSL_free(rdata->rbuf.buf);
			}
d146 1
a149 5
		rdata = (DTLS1_RECORD_DATA *) item->data;
		if (rdata->rbuf.buf)
			{
			OPENSSL_free(rdata->rbuf.buf);
			}
d153 1
d162 1
d171 1
d173 2
a174 8
	while ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL)
		{
		frag = (hm_fragment *)item->data;
		OPENSSL_free(frag->fragment);
		OPENSSL_free(frag);
		pitem_free(item);
		}
	}
d176 2
a177 11
void dtls1_free(SSL *s)
	{
	ssl3_free(s);

	dtls1_clear_queues(s);

    pqueue_free(s->d1->unprocessed_rcds.q);
    pqueue_free(s->d1->processed_rcds.q);
    pqueue_free(s->d1->buffered_messages);
	pqueue_free(s->d1->sent_messages);
	pqueue_free(s->d1->buffered_app_data.q);
a179 1
	s->d1 = NULL;
a183 37
    pqueue unprocessed_rcds;
    pqueue processed_rcds;
    pqueue buffered_messages;
	pqueue sent_messages;
	pqueue buffered_app_data;
	unsigned int mtu;

	if (s->d1)
		{
		unprocessed_rcds = s->d1->unprocessed_rcds.q;
		processed_rcds = s->d1->processed_rcds.q;
		buffered_messages = s->d1->buffered_messages;
		sent_messages = s->d1->sent_messages;
		buffered_app_data = s->d1->buffered_app_data.q;
		mtu = s->d1->mtu;

		dtls1_clear_queues(s);

		memset(s->d1, 0, sizeof(*(s->d1)));

		if (s->server)
			{
			s->d1->cookie_len = sizeof(s->d1->cookie);
			}

		if (SSL_get_options(s) & SSL_OP_NO_QUERY_MTU)
			{
			s->d1->mtu = mtu;
			}

		s->d1->unprocessed_rcds.q = unprocessed_rcds;
		s->d1->processed_rcds.q = processed_rcds;
		s->d1->buffered_messages = buffered_messages;
		s->d1->sent_messages = sent_messages;
		s->d1->buffered_app_data.q = buffered_app_data;
		}

d185 1
a185 30
	if (s->options & SSL_OP_CISCO_ANYCONNECT)
		s->version=DTLS1_BAD_VER;
	else
		s->version=DTLS1_VERSION;
	}

long dtls1_ctrl(SSL *s, int cmd, long larg, void *parg)
	{
	int ret=0;

	switch (cmd)
		{
	case DTLS_CTRL_GET_TIMEOUT:
		if (dtls1_get_timeout(s, (struct timeval*) parg) != NULL)
			{
			ret = 1;
			}
		break;
	case DTLS_CTRL_HANDLE_TIMEOUT:
		ret = dtls1_handle_timeout(s);
		break;
	case DTLS_CTRL_LISTEN:
		ret = dtls1_listen(s, parg);
		break;

	default:
		ret = ssl3_ctrl(s, cmd, larg, parg);
		break;
		}
	return(ret);
d195 1
a195 1
const SSL_CIPHER *dtls1_get_cipher(unsigned int u)
d197 1
a197 1
	const SSL_CIPHER *ciph = ssl3_get_cipher(u);
d201 1
a201 1
		if (ciph->algorithm_enc == SSL_RC4)
a205 179
	}

void dtls1_start_timer(SSL *s)
	{
#ifndef OPENSSL_NO_SCTP
	/* Disable timer for SCTP */
	if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
		{
		memset(&(s->d1->next_timeout), 0, sizeof(struct timeval));
		return;
		}
#endif

	/* If timer is not set, initialize duration with 1 second */
	if (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0)
		{
		s->d1->timeout_duration = 1;
		}
	
	/* Set timeout to current time */
	get_current_time(&(s->d1->next_timeout));

	/* Add duration to current time */
	s->d1->next_timeout.tv_sec += s->d1->timeout_duration;
	BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout));
	}

struct timeval* dtls1_get_timeout(SSL *s, struct timeval* timeleft)
	{
	struct timeval timenow;

	/* If no timeout is set, just return NULL */
	if (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0)
		{
		return NULL;
		}

	/* Get current time */
	get_current_time(&timenow);

	/* If timer already expired, set remaining time to 0 */
	if (s->d1->next_timeout.tv_sec < timenow.tv_sec ||
		(s->d1->next_timeout.tv_sec == timenow.tv_sec &&
		 s->d1->next_timeout.tv_usec <= timenow.tv_usec))
		{
		memset(timeleft, 0, sizeof(struct timeval));
		return timeleft;
		}

	/* Calculate time left until timer expires */
	memcpy(timeleft, &(s->d1->next_timeout), sizeof(struct timeval));
	timeleft->tv_sec -= timenow.tv_sec;
	timeleft->tv_usec -= timenow.tv_usec;
	if (timeleft->tv_usec < 0)
		{
		timeleft->tv_sec--;
		timeleft->tv_usec += 1000000;
		}

	/* If remaining time is less than 15 ms, set it to 0
	 * to prevent issues because of small devergences with
	 * socket timeouts.
	 */
	if (timeleft->tv_sec == 0 && timeleft->tv_usec < 15000)
		{
		memset(timeleft, 0, sizeof(struct timeval));
		}
	

	return timeleft;
	}

int dtls1_is_timer_expired(SSL *s)
	{
	struct timeval timeleft;

	/* Get time left until timeout, return false if no timer running */
	if (dtls1_get_timeout(s, &timeleft) == NULL)
		{
		return 0;
		}

	/* Return false if timer is not expired yet */
	if (timeleft.tv_sec > 0 || timeleft.tv_usec > 0)
		{
		return 0;
		}

	/* Timer expired, so return true */	
	return 1;
	}

void dtls1_double_timeout(SSL *s)
	{
	s->d1->timeout_duration *= 2;
	if (s->d1->timeout_duration > 60)
		s->d1->timeout_duration = 60;
	dtls1_start_timer(s);
	}

void dtls1_stop_timer(SSL *s)
	{
	/* Reset everything */
	memset(&(s->d1->timeout), 0, sizeof(struct dtls1_timeout_st));
	memset(&(s->d1->next_timeout), 0, sizeof(struct timeval));
	s->d1->timeout_duration = 1;
	BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout));
	/* Clear retransmission buffer */
	dtls1_clear_record_buffer(s);
	}

int dtls1_check_timeout_num(SSL *s)
	{
	s->d1->timeout.num_alerts++;

	/* Reduce MTU after 2 unsuccessful retransmissions */
	if (s->d1->timeout.num_alerts > 2)
		{
		s->d1->mtu = BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_GET_FALLBACK_MTU, 0, NULL);		
		}

	if (s->d1->timeout.num_alerts > DTLS1_TMO_ALERT_COUNT)
		{
		/* fail the connection, enough alerts have been sent */
		SSLerr(SSL_F_DTLS1_CHECK_TIMEOUT_NUM,SSL_R_READ_TIMEOUT_EXPIRED);
		return -1;
		}

	return 0;
	}

int dtls1_handle_timeout(SSL *s)
	{
	/* if no timer is expired, don't do anything */
	if (!dtls1_is_timer_expired(s))
		{
		return 0;
		}

	dtls1_double_timeout(s);

	if (dtls1_check_timeout_num(s) < 0)
		return -1;

	s->d1->timeout.read_timeouts++;
	if (s->d1->timeout.read_timeouts > DTLS1_TMO_READ_COUNT)
		{
		s->d1->timeout.read_timeouts = 1;
		}

#ifndef OPENSSL_NO_HEARTBEATS
	if (s->tlsext_hb_pending)
		{
		s->tlsext_hb_pending = 0;
		return dtls1_heartbeat(s);
		}
#endif

	dtls1_start_timer(s);
	return dtls1_retransmit_buffered_messages(s);
	}

static void get_current_time(struct timeval *t)
{
	gettimeofday(t, NULL);
}

int dtls1_listen(SSL *s, struct sockaddr *client)
	{
	int ret;

	SSL_set_options(s, SSL_OP_COOKIE_EXCHANGE);
	s->d1->listen = 1;

	ret = SSL_accept(s);
	if (ret <= 0) return ret;
	
	(void) BIO_dgram_get_peer(SSL_get_rbio(s), client);
	return 1;
@


1.3
log
@Remove vms support stuff.
ok deraadt@@
@
text
@a455 5
#ifdef OPENSSL_SYS_WIN32
	struct _timeb tb;
	_ftime(&tb);
	t->tv_sec = (long)tb.time;
	t->tv_usec = (long)tb.millitm * 1000;
a456 1
#endif
@


1.2
log
@Do not include "e_os.h" anymore.  Simply pull in the necessary headers.

ok miod@@, deraadt@@
@
text
@a68 4
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS)
#include <sys/timeb.h>
#endif

a460 6
#elif defined(OPENSSL_SYS_VMS)
	struct timeb tb;
	ftime(&tb);
	t->tv_sec = (long)tb.time;
	t->tv_usec = (long)tb.millitm * 1000;
#else
@


1.1
log
@Initial revision
@
text
@d60 5
d69 5
d75 1
d89 1
a98 5
IMPLEMENT_dtls1_meth_func(dtlsv1_base_method,
			ssl_undefined_function,
			ssl_undefined_function,
			ssl_bad_method)

a107 10
#if defined(OPENSSL_SYS_VMS) || defined(VMS_TEST)
	d1->bitmap.length=64;
#else
	d1->bitmap.length=sizeof(d1->bitmap.map) * 8;
#endif
	pq_64bit_init(&(d1->bitmap.map));
	pq_64bit_init(&(d1->bitmap.max_seq_num));
	
	pq_64bit_init(&(d1->next_bitmap.map));
	pq_64bit_init(&(d1->next_bitmap.max_seq_num));
d113 1
d121 1
a121 1
        || ! d1->buffered_messages || ! d1->sent_messages)
d127 1
d137 1
a137 1
void dtls1_free(SSL *s)
d141 1
a141 2

	ssl3_free(s);
d145 5
a152 1
    pqueue_free(s->d1->unprocessed_rcds.q);
d156 5
a163 1
    pqueue_free(s->d1->processed_rcds.q);
a171 1
    pqueue_free(s->d1->buffered_messages);
a179 1
	pqueue_free(s->d1->sent_messages);
d181 14
a194 2
	pq_64bit_free(&(s->d1->bitmap.map));
	pq_64bit_free(&(s->d1->bitmap.max_seq_num));
d196 5
a200 2
	pq_64bit_free(&(s->d1->next_bitmap.map));
	pq_64bit_free(&(s->d1->next_bitmap.max_seq_num));
d203 1
d208 37
d246 30
a275 1
	s->version=DTLS1_VERSION;
d285 1
a285 1
SSL_CIPHER *dtls1_get_cipher(unsigned int u)
d287 1
a287 1
	SSL_CIPHER *ciph = ssl3_get_cipher(u);
d291 1
a291 1
		if ((ciph->algorithms&SSL_ENC_MASK) == SSL_RC4)
d296 191
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import openssl-0.9.8j
@
text
@a108 1
	d1->next_bitmap.length = d1->bitmap.length;
@


1.1.1.3
log
@import OpenSSL-1.0.0a
@
text
@a60 1
#define USE_SOCKETS
a63 5
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS)
#include <sys/timeb.h>
#endif

static void get_current_time(struct timeval *t);
a64 1
int dtls1_listen(SSL *s, struct sockaddr *client);
d87 5
d101 11
a116 1
	d1->buffered_app_data.q=pqueue_new();
d124 1
a124 1
        || ! d1->buffered_messages || ! d1->sent_messages || ! d1->buffered_app_data.q)
a129 1
		if ( d1->buffered_app_data.q) pqueue_free(d1->buffered_app_data.q);
d178 5
a182 8
	while ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL)
		{
		frag = (hm_fragment *)item->data;
		OPENSSL_free(frag->fragment);
		OPENSSL_free(frag);
		pitem_free(item);
		}
	pqueue_free(s->d1->buffered_app_data.q);
d190 1
a190 30
	if (s->options & SSL_OP_CISCO_ANYCONNECT)
		s->version=DTLS1_BAD_VER;
	else
		s->version=DTLS1_VERSION;
	}

long dtls1_ctrl(SSL *s, int cmd, long larg, void *parg)
	{
	int ret=0;

	switch (cmd)
		{
	case DTLS_CTRL_GET_TIMEOUT:
		if (dtls1_get_timeout(s, (struct timeval*) parg) != NULL)
			{
			ret = 1;
			}
		break;
	case DTLS_CTRL_HANDLE_TIMEOUT:
		ret = dtls1_handle_timeout(s);
		break;
	case DTLS_CTRL_LISTEN:
		ret = dtls1_listen(s, parg);
		break;

	default:
		ret = ssl3_ctrl(s, cmd, larg, parg);
		break;
		}
	return(ret);
d200 1
a200 1
const SSL_CIPHER *dtls1_get_cipher(unsigned int u)
d202 1
a202 1
	const SSL_CIPHER *ciph = ssl3_get_cipher(u);
d206 1
a206 1
		if (ciph->algorithm_enc == SSL_RC4)
a210 158
	}

void dtls1_start_timer(SSL *s)
	{
	/* If timer is not set, initialize duration with 1 second */
	if (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0)
		{
		s->d1->timeout_duration = 1;
		}
	
	/* Set timeout to current time */
	get_current_time(&(s->d1->next_timeout));

	/* Add duration to current time */
	s->d1->next_timeout.tv_sec += s->d1->timeout_duration;
	BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout));
	}

struct timeval* dtls1_get_timeout(SSL *s, struct timeval* timeleft)
	{
	struct timeval timenow;

	/* If no timeout is set, just return NULL */
	if (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0)
		{
		return NULL;
		}

	/* Get current time */
	get_current_time(&timenow);

	/* If timer already expired, set remaining time to 0 */
	if (s->d1->next_timeout.tv_sec < timenow.tv_sec ||
		(s->d1->next_timeout.tv_sec == timenow.tv_sec &&
		 s->d1->next_timeout.tv_usec <= timenow.tv_usec))
		{
		memset(timeleft, 0, sizeof(struct timeval));
		return timeleft;
		}

	/* Calculate time left until timer expires */
	memcpy(timeleft, &(s->d1->next_timeout), sizeof(struct timeval));
	timeleft->tv_sec -= timenow.tv_sec;
	timeleft->tv_usec -= timenow.tv_usec;
	if (timeleft->tv_usec < 0)
		{
		timeleft->tv_sec--;
		timeleft->tv_usec += 1000000;
		}

	/* If remaining time is less than 15 ms, set it to 0
	 * to prevent issues because of small devergences with
	 * socket timeouts.
	 */
	if (timeleft->tv_sec == 0 && timeleft->tv_usec < 15000)
		{
		memset(timeleft, 0, sizeof(struct timeval));
		}
	

	return timeleft;
	}

int dtls1_is_timer_expired(SSL *s)
	{
	struct timeval timeleft;

	/* Get time left until timeout, return false if no timer running */
	if (dtls1_get_timeout(s, &timeleft) == NULL)
		{
		return 0;
		}

	/* Return false if timer is not expired yet */
	if (timeleft.tv_sec > 0 || timeleft.tv_usec > 0)
		{
		return 0;
		}

	/* Timer expired, so return true */	
	return 1;
	}

void dtls1_double_timeout(SSL *s)
	{
	s->d1->timeout_duration *= 2;
	if (s->d1->timeout_duration > 60)
		s->d1->timeout_duration = 60;
	dtls1_start_timer(s);
	}

void dtls1_stop_timer(SSL *s)
	{
	/* Reset everything */
	memset(&(s->d1->next_timeout), 0, sizeof(struct timeval));
	s->d1->timeout_duration = 1;
	BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout));
	}

int dtls1_handle_timeout(SSL *s)
	{
	DTLS1_STATE *state;

	/* if no timer is expired, don't do anything */
	if (!dtls1_is_timer_expired(s))
		{
		return 0;
		}

	dtls1_double_timeout(s);
	state = s->d1;
	state->timeout.num_alerts++;
	if ( state->timeout.num_alerts > DTLS1_TMO_ALERT_COUNT)
		{
		/* fail the connection, enough alerts have been sent */
		SSLerr(SSL_F_DTLS1_HANDLE_TIMEOUT,SSL_R_READ_TIMEOUT_EXPIRED);
		return 0;
		}

	state->timeout.read_timeouts++;
	if ( state->timeout.read_timeouts > DTLS1_TMO_READ_COUNT)
		{
		state->timeout.read_timeouts = 1;
		}

	dtls1_start_timer(s);
	return dtls1_retransmit_buffered_messages(s);
	}

static void get_current_time(struct timeval *t)
{
#ifdef OPENSSL_SYS_WIN32
	struct _timeb tb;
	_ftime(&tb);
	t->tv_sec = (long)tb.time;
	t->tv_usec = (long)tb.millitm * 1000;
#elif defined(OPENSSL_SYS_VMS)
	struct timeb tb;
	ftime(&tb);
	t->tv_sec = (long)tb.time;
	t->tv_usec = (long)tb.millitm * 1000;
#else
	gettimeofday(t, NULL);
#endif
}

int dtls1_listen(SSL *s, struct sockaddr *client)
	{
	int ret;

	SSL_set_options(s, SSL_OP_COOKIE_EXCHANGE);
	s->d1->listen = 1;

	ret = SSL_accept(s);
	if (ret <= 0) return ret;
	
	(void) BIO_dgram_get_peer(SSL_get_rbio(s), client);
	return 1;
@


1.1.1.4
log
@import OpenSSL 1.0.0e
@
text
@d132 1
a132 1
static void dtls1_clear_queues(SSL *s)
d136 2
a137 1
	DTLS1_RECORD_DATA *rdata;
a140 5
		rdata = (DTLS1_RECORD_DATA *) item->data;
		if (rdata->rbuf.buf)
			{
			OPENSSL_free(rdata->rbuf.buf);
			}
d144 1
a147 5
		rdata = (DTLS1_RECORD_DATA *) item->data;
		if (rdata->rbuf.buf)
			{
			OPENSSL_free(rdata->rbuf.buf);
			}
d151 1
d160 1
d169 1
a177 12
	}

void dtls1_free(SSL *s)
	{
	ssl3_free(s);

	dtls1_clear_queues(s);

    pqueue_free(s->d1->unprocessed_rcds.q);
    pqueue_free(s->d1->processed_rcds.q);
    pqueue_free(s->d1->buffered_messages);
	pqueue_free(s->d1->sent_messages);
a184 30
    pqueue unprocessed_rcds;
    pqueue processed_rcds;
    pqueue buffered_messages;
	pqueue sent_messages;
	pqueue buffered_app_data;
	
	if (s->d1)
		{
		unprocessed_rcds = s->d1->unprocessed_rcds.q;
		processed_rcds = s->d1->processed_rcds.q;
		buffered_messages = s->d1->buffered_messages;
		sent_messages = s->d1->sent_messages;
		buffered_app_data = s->d1->buffered_app_data.q;

		dtls1_clear_queues(s);

		memset(s->d1, 0, sizeof(*(s->d1)));

		if (s->server)
			{
			s->d1->cookie_len = sizeof(s->d1->cookie);
			}

		s->d1->unprocessed_rcds.q = unprocessed_rcds;
		s->d1->processed_rcds.q = processed_rcds;
		s->d1->buffered_messages = buffered_messages;
		s->d1->sent_messages = sent_messages;
		s->d1->buffered_app_data.q = buffered_app_data;
		}

a332 2
	/* Clear retransmission buffer */
	dtls1_clear_record_buffer(s);
d352 1
a352 1
		return -1;
@


1.1.1.5
log
@OpenSSL 1.0.0f: import upstream source
@
text
@d207 1
a207 2
	unsigned int mtu;

a214 1
		mtu = s->d1->mtu;
a222 5
			}

		if (SSL_get_options(s) & SSL_OP_NO_QUERY_MTU)
			{
			s->d1->mtu = mtu;
@


1.1.1.6
log
@import OpenSSL-1.0.1c
@
text
@a84 1
	tls1_export_keying_material,
a293 9
#ifndef OPENSSL_NO_SCTP
	/* Disable timer for SCTP */
	if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
		{
		memset(&(s->d1->next_timeout), 0, sizeof(struct timeval));
		return;
		}
#endif

a383 1
	memset(&(s->d1->timeout), 0, sizeof(struct dtls1_timeout_st));
d391 1
a391 1
int dtls1_check_timeout_num(SSL *s)
d393 1
a393 1
	s->d1->timeout.num_alerts++;
a394 18
	/* Reduce MTU after 2 unsuccessful retransmissions */
	if (s->d1->timeout.num_alerts > 2)
		{
		s->d1->mtu = BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_GET_FALLBACK_MTU, 0, NULL);		
		}

	if (s->d1->timeout.num_alerts > DTLS1_TMO_ALERT_COUNT)
		{
		/* fail the connection, enough alerts have been sent */
		SSLerr(SSL_F_DTLS1_CHECK_TIMEOUT_NUM,SSL_R_READ_TIMEOUT_EXPIRED);
		return -1;
		}

	return 0;
	}

int dtls1_handle_timeout(SSL *s)
	{
d402 6
a407 2

	if (dtls1_check_timeout_num(s) < 0)
a408 5

	s->d1->timeout.read_timeouts++;
	if (s->d1->timeout.read_timeouts > DTLS1_TMO_READ_COUNT)
		{
		s->d1->timeout.read_timeouts = 1;
d411 2
a412 2
#ifndef OPENSSL_NO_HEARTBEATS
	if (s->tlsext_hb_pending)
d414 1
a414 2
		s->tlsext_hb_pending = 0;
		return dtls1_heartbeat(s);
a415 1
#endif
@


1.1.1.7
log
@Import OpenSSL 1.0.1g
@
text
@a198 1
	s->d1 = NULL;
@


