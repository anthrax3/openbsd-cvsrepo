head	1.86;
access;
symbols
	OPENBSD_6_0:1.86.0.2
	OPENBSD_6_0_BASE:1.86
	OPENBSD_5_9:1.84.0.2
	OPENBSD_5_9_BASE:1.84
	OPENBSD_5_8:1.81.0.6
	OPENBSD_5_8_BASE:1.81
	OPENBSD_5_7:1.81.0.4
	OPENBSD_5_7_BASE:1.81
	OPENBSD_5_6:1.66.0.4
	OPENBSD_5_6_BASE:1.66
	butholakala:1.22
	openssl_1_0_1_g:1.1.1.15
	OPENBSD_5_5:1.21.0.8
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.4
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	openssl_1_0_1_c:1.1.1.14
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	openssl_1_0_0_f:1.1.1.13
	openssl_1_0_0_e:1.1.1.12
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	openssh_1_0_0_a:1.1.1.11
	OPENBSD_4_8:1.17.0.6
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	openssl_0_9_8_k:1.1.1.10
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	openssl_0_9_8_j:1.1.1.9
	openssl_0_9_8_h:1.1.1.8
	pre_openssl_0_9_8h:1.13
	OPENBSD_4_4:1.13.0.10
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	openssl_0_9_7j:1.1.1.7
	openssl:1.1.1
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENSSL_0_9_7G:1.1.1.6
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENSSL_0_9_7D:1.1.1.5
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.5.0.6
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.86
date	2016.04.28.16.39.45;	author jsing;	state Exp;
branches;
next	1.85;
commitid	MlZ5jZHGKzYpF9uz;

1.85
date	2016.04.28.16.06.53;	author jsing;	state Exp;
branches;
next	1.84;
commitid	82vUQnYEexbUmRFI;

1.84
date	2015.12.12.22.04.10;	author mmcc;	state Exp;
branches;
next	1.83;
commitid	c3bGdL4aZmfLKOiZ;

1.83
date	2015.09.13.12.34.02;	author jsing;	state Exp;
branches;
next	1.82;
commitid	tc3bnGhjOsbOLxvc;

1.82
date	2015.09.13.09.10.01;	author jsing;	state Exp;
branches;
next	1.81;
commitid	A3G6JIW7kL7rEj5M;

1.81
date	2015.02.07.04.17.11;	author jsing;	state Exp;
branches;
next	1.80;
commitid	kTcp4bxIaEX3QOn0;

1.80
date	2015.01.26.13.06.39;	author jsing;	state Exp;
branches;
next	1.79;
commitid	giaBqbLY6IrY5S0l;

1.79
date	2014.12.14.15.30.50;	author jsing;	state Exp;
branches;
next	1.78;
commitid	XNZawfRSWvnVv1VS;

1.78
date	2014.12.10.15.36.47;	author jsing;	state Exp;
branches;
next	1.77;
commitid	x50cturILyXAfPoH;

1.77
date	2014.12.07.12.13.06;	author jsing;	state Exp;
branches;
next	1.76;
commitid	hr25pW0RF8ycu1cB;

1.76
date	2014.12.06.15.27.45;	author jsing;	state Exp;
branches;
next	1.75;
commitid	ojW3qx9XdSlN7BKK;

1.75
date	2014.12.06.15.25.40;	author jsing;	state Exp;
branches;
next	1.74;
commitid	ybLFb8QAvaBwL1fA;

1.74
date	2014.11.18.05.33.43;	author miod;	state Exp;
branches;
next	1.73;
commitid	81uwsCsokEuKDUjo;

1.73
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.72;
commitid	M3pvHgIFoWUHNqJn;

1.72
date	2014.11.08.15.21.02;	author jsing;	state Exp;
branches;
next	1.71;
commitid	lIDXnjZtfw9o5vQC;

1.71
date	2014.11.02.10.42.38;	author jsing;	state Exp;
branches;
next	1.70;
commitid	neOGF3Pv7ccNdldy;

1.70
date	2014.10.15.13.57.21;	author jsing;	state Exp;
branches;
next	1.69;
commitid	mrYYmKqkXNPjzDuB;

1.69
date	2014.10.03.06.02.38;	author doug;	state Exp;
branches;
next	1.68;
commitid	q372AJEo5SAUk3Hj;

1.68
date	2014.09.19.16.02.35;	author jsing;	state Exp;
branches;
next	1.67;
commitid	7VXH20onepGdSUKE;

1.67
date	2014.09.07.12.16.23;	author jsing;	state Exp;
branches;
next	1.66;
commitid	oAt7EW2Y0Fwu0XNB;

1.66
date	2014.07.12.22.33.39;	author jsing;	state Exp;
branches;
next	1.65;
commitid	JT7oO4AHgBkjVLfZ;

1.65
date	2014.07.12.13.11.53;	author jsing;	state Exp;
branches;
next	1.64;
commitid	tJhRneQ4w1l9LuV2;

1.64
date	2014.07.12.07.52.36;	author guenther;	state Exp;
branches;
next	1.63;
commitid	YF9UNiasPEYiIdsl;

1.63
date	2014.07.11.09.24.44;	author beck;	state Exp;
branches;
next	1.62;
commitid	cCGiAdDteN08GytD;

1.62
date	2014.07.10.11.58.08;	author jsing;	state Exp;
branches;
next	1.61;
commitid	qLodpwcyFbEuMoav;

1.61
date	2014.07.10.10.09.54;	author jsing;	state Exp;
branches;
next	1.60;
commitid	ClZ3wY7kSvwpyKpe;

1.60
date	2014.07.10.09.26.08;	author jsing;	state Exp;
branches;
next	1.59;
commitid	YQZ6XBoOk46lT2M2;

1.59
date	2014.07.10.08.51.15;	author tedu;	state Exp;
branches;
next	1.58;
commitid	lsH7iukeZYSZBx6F;

1.58
date	2014.07.09.14.20.55;	author jsing;	state Exp;
branches;
next	1.57;
commitid	dZAWyeUmNGZb3EvB;

1.57
date	2014.07.09.11.25.42;	author jsing;	state Exp;
branches;
next	1.56;
commitid	N5P2FUkVkAd7ODs9;

1.56
date	2014.07.08.21.50.40;	author jsing;	state Exp;
branches;
next	1.55;
commitid	kLhCDmTWLPmmRB38;

1.55
date	2014.06.18.04.48.37;	author miod;	state Exp;
branches;
next	1.54;
commitid	eQuc1ZRV5WIeYGa0;

1.54
date	2014.06.18.04.47.32;	author miod;	state Exp;
branches;
next	1.53;
commitid	lbbhs9HD6nVsGKuv;

1.53
date	2014.06.13.13.28.53;	author jsing;	state Exp;
branches;
next	1.52;
commitid	Ujg3vMZHX0kgoEuK;

1.52
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	mJUVYpkFBZ0Zv2bG;

1.51
date	2014.06.08.16.24.49;	author jsing;	state Exp;
branches;
next	1.50;
commitid	jNUDlA3Vuq6B2gbp;

1.50
date	2014.06.01.01.46.13;	author jsing;	state Exp;
branches;
next	1.49;
commitid	HI7mGdwDHgUzjGxr;

1.49
date	2014.05.30.14.31.03;	author jsing;	state Exp;
branches;
next	1.48;

1.48
date	2014.05.29.18.11.13;	author tedu;	state Exp;
branches;
next	1.47;

1.47
date	2014.05.29.17.13.48;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2014.05.27.13.44.06;	author jsing;	state Exp;
branches;
next	1.45;

1.45
date	2014.05.27.13.36.27;	author jsing;	state Exp;
branches;
next	1.44;

1.44
date	2014.05.27.13.11.56;	author jsing;	state Exp;
branches;
next	1.43;

1.43
date	2014.05.26.20.20.51;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2014.05.25.16.23.10;	author jsing;	state Exp;
branches;
next	1.41;

1.41
date	2014.05.25.13.32.51;	author jsing;	state Exp;
branches;
next	1.40;

1.40
date	2014.05.25.13.27.38;	author jsing;	state Exp;
branches;
next	1.39;

1.39
date	2014.05.24.19.27.48;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2014.05.20.16.59.05;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2014.05.05.15.03.22;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.22.14.27.25;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.21.16.48.59;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.21.16.34.43;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.20.10.31.43;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.17.21.37.37;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.17.13.37.50;	author beck;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.16.20.39.09;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.16.17.59.16;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.15.20.23.37;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.15.19.42.56;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.15.17.46.17;	author beck;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.14.18.53.14;	author beck;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.14.13.10.35;	author jsing;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2012.01.05.23.01.39;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2009.04.06.06.33.20;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.06.12.17.53;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.27.05.07.03;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.29.05.39.31;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.08.08.03.15;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.01.05.52.45;	author cloder;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.07.19.55.34;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.58.40;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.50;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.32;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.29;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.13;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.13;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.40;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.44.27;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.36.42;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.20.42.07;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.04.29.05.37.28;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.06.27.05.05.39;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.01.09.12.14.07;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.04.06.06.30.07;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2011.11.03.02.32.21;	author djm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2012.01.05.22.59.09;	author djm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2012.10.13.21.23.50;	author djm;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;


desc
@@


1.86
log
@Implement the IETF ChaCha20-Poly1305 cipher suites.

Rename the existing ChaCha20-Poly1305 cipher suites with an "-OLD" suffix,
effectively replaces the original Google implementation. We continue to
support both the IETF and Google versions, however the existing names
now refer to the ciphers from draft-ietf-tls-chacha20-poly1305-04.

Feedback from doug@@
@
text
@/* $OpenBSD: ssl_ciph.c,v 1.85 2016/04/28 16:06:53 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */

#include <stdio.h>

#include <openssl/objects.h>

#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif

#include "ssl_locl.h"

#define SSL_ENC_DES_IDX		0
#define SSL_ENC_3DES_IDX	1
#define SSL_ENC_RC4_IDX		2
#define SSL_ENC_IDEA_IDX	3
#define SSL_ENC_NULL_IDX	4
#define SSL_ENC_AES128_IDX	5
#define SSL_ENC_AES256_IDX	6
#define SSL_ENC_CAMELLIA128_IDX	7
#define SSL_ENC_CAMELLIA256_IDX	8
#define SSL_ENC_GOST89_IDX	9
#define SSL_ENC_AES128GCM_IDX	10
#define SSL_ENC_AES256GCM_IDX	11
#define SSL_ENC_NUM_IDX		12


static const EVP_CIPHER *ssl_cipher_methods[SSL_ENC_NUM_IDX] = {
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
};

#define SSL_MD_MD5_IDX	0
#define SSL_MD_SHA1_IDX	1
#define SSL_MD_GOST94_IDX 2
#define SSL_MD_GOST89MAC_IDX 3
#define SSL_MD_SHA256_IDX 4
#define SSL_MD_SHA384_IDX 5
#define SSL_MD_STREEBOG256_IDX 6
#define SSL_MD_STREEBOG512_IDX 7
/*Constant SSL_MAX_DIGEST equal to size of digests array should be
 * defined in the
 * ssl_locl.h */
#define SSL_MD_NUM_IDX	SSL_MAX_DIGEST
static const EVP_MD *ssl_digest_methods[SSL_MD_NUM_IDX] = {
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
};

static int  ssl_mac_pkey_id[SSL_MD_NUM_IDX] = {
	EVP_PKEY_HMAC, EVP_PKEY_HMAC, EVP_PKEY_HMAC, EVP_PKEY_GOSTIMIT,
	EVP_PKEY_HMAC, EVP_PKEY_HMAC, EVP_PKEY_HMAC, EVP_PKEY_HMAC,
};

static int ssl_mac_secret_size[SSL_MD_NUM_IDX] = {
	0, 0, 0, 0, 0, 0, 0, 0
};

static int ssl_handshake_digest_flag[SSL_MD_NUM_IDX] = {
	SSL_HANDSHAKE_MAC_MD5, SSL_HANDSHAKE_MAC_SHA,
	SSL_HANDSHAKE_MAC_GOST94, 0, SSL_HANDSHAKE_MAC_SHA256,
	SSL_HANDSHAKE_MAC_SHA384, SSL_HANDSHAKE_MAC_STREEBOG256,
	SSL_HANDSHAKE_MAC_STREEBOG512
};

#define CIPHER_ADD	1
#define CIPHER_KILL	2
#define CIPHER_DEL	3
#define CIPHER_ORD	4
#define CIPHER_SPECIAL	5

typedef struct cipher_order_st {
	const SSL_CIPHER *cipher;
	int active;
	int dead;
	struct cipher_order_st *next, *prev;
} CIPHER_ORDER;

static const SSL_CIPHER cipher_aliases[] = {

	/* "ALL" doesn't include eNULL (must be specifically enabled) */
	{
		.name = SSL_TXT_ALL,
		.algorithm_enc = ~SSL_eNULL,
	},

	/* "COMPLEMENTOFALL" */
	{
		.name = SSL_TXT_CMPALL,
		.algorithm_enc = SSL_eNULL,
	},

	/*
	 * "COMPLEMENTOFDEFAULT"
	 * (does *not* include ciphersuites not found in ALL!)
	 */
	{
		.name = SSL_TXT_CMPDEF,
		.algorithm_mkey = SSL_kDHE|SSL_kECDHE,
		.algorithm_auth = SSL_aNULL,
		.algorithm_enc = ~SSL_eNULL,
	},

	/*
	 * key exchange aliases
	 * (some of those using only a single bit here combine multiple key
	 * exchange algs according to the RFCs, e.g. kEDH combines DHE_DSS
	 * and DHE_RSA)
	 */
	{
		.name = SSL_TXT_kRSA,
		.algorithm_mkey = SSL_kRSA,
	},
	{
		.name = SSL_TXT_kEDH,
		.algorithm_mkey = SSL_kDHE,
	},
	{
		.name = SSL_TXT_DH,
		.algorithm_mkey = SSL_kDHE,
	},

	{
		.name = SSL_TXT_kECDHr,
		.algorithm_mkey = SSL_kECDHr,
	},
	{
		.name = SSL_TXT_kECDHe,
		.algorithm_mkey = SSL_kECDHe,
	},
	{
		.name = SSL_TXT_kECDH,
		.algorithm_mkey = SSL_kECDHr|SSL_kECDHe,
	},
	{
		.name = SSL_TXT_kEECDH,
		.algorithm_mkey = SSL_kECDHE,
	},
	{
		.name = SSL_TXT_ECDH,
		.algorithm_mkey = SSL_kECDHr|SSL_kECDHe|SSL_kECDHE,
	},

	{
		.name = SSL_TXT_kGOST,
		.algorithm_mkey = SSL_kGOST,
	},

	/* server authentication aliases */
	{
		.name = SSL_TXT_aRSA,
		.algorithm_auth = SSL_aRSA,
	},
	{
		.name = SSL_TXT_aDSS,
		.algorithm_auth = SSL_aDSS,
	},
	{
		.name = SSL_TXT_DSS,
		.algorithm_auth = SSL_aDSS,
	},
	{
		.name = SSL_TXT_aNULL,
		.algorithm_auth = SSL_aNULL,
	},
	{
		.name = SSL_TXT_aECDH,
		.algorithm_auth = SSL_aECDH,
	},
	{
		.name = SSL_TXT_aECDSA,
		.algorithm_auth = SSL_aECDSA,
	},
	{
		.name = SSL_TXT_ECDSA,
		.algorithm_auth = SSL_aECDSA,
	},
	{
		.name = SSL_TXT_aGOST01,
		.algorithm_auth = SSL_aGOST01,
	},
	{
		.name = SSL_TXT_aGOST,
		.algorithm_auth = SSL_aGOST01,
	},

	/* aliases combining key exchange and server authentication */
	{
		.name = SSL_TXT_DHE,
		.algorithm_mkey = SSL_kDHE,
		.algorithm_auth = ~SSL_aNULL,
	},
	{
		.name = SSL_TXT_EDH,
		.algorithm_mkey = SSL_kDHE,
		.algorithm_auth = ~SSL_aNULL,
	},
	{
		.name = SSL_TXT_ECDHE,
		.algorithm_mkey = SSL_kECDHE,
		.algorithm_auth = ~SSL_aNULL,
	},
	{
		.name = SSL_TXT_EECDH,
		.algorithm_mkey = SSL_kECDHE,
		.algorithm_auth = ~SSL_aNULL,
	},
	{
		.name = SSL_TXT_NULL,
		.algorithm_enc = SSL_eNULL,
	},
	{
		.name = SSL_TXT_RSA,
		.algorithm_mkey = SSL_kRSA,
		.algorithm_auth = SSL_aRSA,
	},
	{
		.name = SSL_TXT_ADH,
		.algorithm_mkey = SSL_kDHE,
		.algorithm_auth = SSL_aNULL,
	},
	{
		.name = SSL_TXT_AECDH,
		.algorithm_mkey = SSL_kECDHE,
		.algorithm_auth = SSL_aNULL,
	},

	/* symmetric encryption aliases */
	{
		.name = SSL_TXT_DES,
		.algorithm_enc = SSL_DES,
	},
	{
		.name = SSL_TXT_3DES,
		.algorithm_enc = SSL_3DES,
	},
	{
		.name = SSL_TXT_RC4,
		.algorithm_enc = SSL_RC4,
	},
	{
		.name = SSL_TXT_IDEA,
		.algorithm_enc = SSL_IDEA,
	},
	{
		.name = SSL_TXT_eNULL,
		.algorithm_enc = SSL_eNULL,
	},
	{
		.name = SSL_TXT_AES128,
		.algorithm_enc = SSL_AES128|SSL_AES128GCM,
	},
	{
		.name = SSL_TXT_AES256,
		.algorithm_enc = SSL_AES256|SSL_AES256GCM,
	},
	{
		.name = SSL_TXT_AES,
		.algorithm_enc = SSL_AES,
	},
	{
		.name = SSL_TXT_AES_GCM,
		.algorithm_enc = SSL_AES128GCM|SSL_AES256GCM,
	},
	{
		.name = SSL_TXT_CAMELLIA128,
		.algorithm_enc = SSL_CAMELLIA128,
	},
	{
		.name = SSL_TXT_CAMELLIA256,
		.algorithm_enc = SSL_CAMELLIA256,
	},
	{
		.name = SSL_TXT_CAMELLIA,
		.algorithm_enc = SSL_CAMELLIA128|SSL_CAMELLIA256,
	},
	{
		.name = SSL_TXT_CHACHA20,
		.algorithm_enc = SSL_CHACHA20POLY1305|SSL_CHACHA20POLY1305_OLD,
	},

	/* MAC aliases */
	{
		.name = SSL_TXT_AEAD,
		.algorithm_mac = SSL_AEAD,
	},
	{
		.name = SSL_TXT_MD5,
		.algorithm_mac = SSL_MD5,
	},
	{
		.name = SSL_TXT_SHA1,
		.algorithm_mac = SSL_SHA1,
	},
	{
		.name = SSL_TXT_SHA,
		.algorithm_mac = SSL_SHA1,
	},
	{
		.name = SSL_TXT_GOST94,
		.algorithm_mac = SSL_GOST94,
	},
	{
		.name = SSL_TXT_GOST89MAC,
		.algorithm_mac = SSL_GOST89MAC,
	},
	{
		.name = SSL_TXT_SHA256,
		.algorithm_mac = SSL_SHA256,
	},
	{
		.name = SSL_TXT_SHA384,
		.algorithm_mac = SSL_SHA384,
	},
	{
		.name = SSL_TXT_STREEBOG256,
		.algorithm_mac = SSL_STREEBOG256,
	},
	{
		.name = SSL_TXT_STREEBOG512,
		.algorithm_mac = SSL_STREEBOG512,
	},

	/* protocol version aliases */
	{
		.name = SSL_TXT_SSLV3,
		.algorithm_ssl = SSL_SSLV3,
	},
	{
		.name = SSL_TXT_TLSV1,
		.algorithm_ssl = SSL_TLSV1,
	},
	{
		.name = SSL_TXT_TLSV1_2,
		.algorithm_ssl = SSL_TLSV1_2,
	},

	/* strength classes */
	{
		.name = SSL_TXT_LOW,
		.algo_strength = SSL_LOW,
	},
	{
		.name = SSL_TXT_MEDIUM,
		.algo_strength = SSL_MEDIUM,
	},
	{
		.name = SSL_TXT_HIGH,
		.algo_strength = SSL_HIGH,
	},
};

void
ssl_load_ciphers(void)
{
	ssl_cipher_methods[SSL_ENC_DES_IDX] =
	    EVP_get_cipherbyname(SN_des_cbc);
	ssl_cipher_methods[SSL_ENC_3DES_IDX] =
	    EVP_get_cipherbyname(SN_des_ede3_cbc);
	ssl_cipher_methods[SSL_ENC_RC4_IDX] =
	    EVP_get_cipherbyname(SN_rc4);
#ifndef OPENSSL_NO_IDEA
	ssl_cipher_methods[SSL_ENC_IDEA_IDX] =
	    EVP_get_cipherbyname(SN_idea_cbc);
#else
	ssl_cipher_methods[SSL_ENC_IDEA_IDX] = NULL;
#endif
	ssl_cipher_methods[SSL_ENC_AES128_IDX] =
	    EVP_get_cipherbyname(SN_aes_128_cbc);
	ssl_cipher_methods[SSL_ENC_AES256_IDX] =
	    EVP_get_cipherbyname(SN_aes_256_cbc);
	ssl_cipher_methods[SSL_ENC_CAMELLIA128_IDX] =
	    EVP_get_cipherbyname(SN_camellia_128_cbc);
	ssl_cipher_methods[SSL_ENC_CAMELLIA256_IDX] =
	    EVP_get_cipherbyname(SN_camellia_256_cbc);
	ssl_cipher_methods[SSL_ENC_GOST89_IDX] =
	    EVP_get_cipherbyname(SN_gost89_cnt);

	ssl_cipher_methods[SSL_ENC_AES128GCM_IDX] =
	    EVP_get_cipherbyname(SN_aes_128_gcm);
	ssl_cipher_methods[SSL_ENC_AES256GCM_IDX] =
	    EVP_get_cipherbyname(SN_aes_256_gcm);

	ssl_digest_methods[SSL_MD_MD5_IDX] =
	    EVP_get_digestbyname(SN_md5);
	ssl_mac_secret_size[SSL_MD_MD5_IDX] =
	    EVP_MD_size(ssl_digest_methods[SSL_MD_MD5_IDX]);
	OPENSSL_assert(ssl_mac_secret_size[SSL_MD_MD5_IDX] >= 0);
	ssl_digest_methods[SSL_MD_SHA1_IDX] =
	    EVP_get_digestbyname(SN_sha1);
	ssl_mac_secret_size[SSL_MD_SHA1_IDX] =
	    EVP_MD_size(ssl_digest_methods[SSL_MD_SHA1_IDX]);
	OPENSSL_assert(ssl_mac_secret_size[SSL_MD_SHA1_IDX] >= 0);
	ssl_digest_methods[SSL_MD_GOST94_IDX] =
	    EVP_get_digestbyname(SN_id_GostR3411_94);
	if (ssl_digest_methods[SSL_MD_GOST94_IDX]) {
		ssl_mac_secret_size[SSL_MD_GOST94_IDX] =
		    EVP_MD_size(ssl_digest_methods[SSL_MD_GOST94_IDX]);
		OPENSSL_assert(ssl_mac_secret_size[SSL_MD_GOST94_IDX] >= 0);
	}
	ssl_digest_methods[SSL_MD_GOST89MAC_IDX] =
	    EVP_get_digestbyname(SN_id_Gost28147_89_MAC);
	if (ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX]) {
		ssl_mac_secret_size[SSL_MD_GOST89MAC_IDX] = 32;
	}

	ssl_digest_methods[SSL_MD_SHA256_IDX] =
	    EVP_get_digestbyname(SN_sha256);
	ssl_mac_secret_size[SSL_MD_SHA256_IDX] =
	    EVP_MD_size(ssl_digest_methods[SSL_MD_SHA256_IDX]);
	ssl_digest_methods[SSL_MD_SHA384_IDX] =
	    EVP_get_digestbyname(SN_sha384);
	ssl_mac_secret_size[SSL_MD_SHA384_IDX] =
	    EVP_MD_size(ssl_digest_methods[SSL_MD_SHA384_IDX]);
	ssl_digest_methods[SSL_MD_STREEBOG256_IDX] =
	    EVP_get_digestbyname(SN_id_tc26_gost3411_2012_256);
	ssl_mac_secret_size[SSL_MD_STREEBOG256_IDX] =
	    EVP_MD_size(ssl_digest_methods[SSL_MD_STREEBOG256_IDX]);
	ssl_digest_methods[SSL_MD_STREEBOG512_IDX] =
	    EVP_get_digestbyname(SN_id_tc26_gost3411_2012_512);
	ssl_mac_secret_size[SSL_MD_STREEBOG512_IDX] =
	    EVP_MD_size(ssl_digest_methods[SSL_MD_STREEBOG512_IDX]);
}

int
ssl_cipher_get_evp(const SSL_SESSION *s, const EVP_CIPHER **enc,
    const EVP_MD **md, int *mac_pkey_type, int *mac_secret_size)
{
	const SSL_CIPHER *c;
	int i;

	c = s->cipher;
	if (c == NULL)
		return (0);

	/*
	 * This function does not handle EVP_AEAD.
	 * See ssl_cipher_get_aead_evp instead.
	 */
	if (c->algorithm2 & SSL_CIPHER_ALGORITHM2_AEAD)
		return(0);

	if ((enc == NULL) || (md == NULL))
		return (0);

	switch (c->algorithm_enc) {
	case SSL_DES:
		i = SSL_ENC_DES_IDX;
		break;
	case SSL_3DES:
		i = SSL_ENC_3DES_IDX;
		break;
	case SSL_RC4:
		i = SSL_ENC_RC4_IDX;
		break;
	case SSL_IDEA:
		i = SSL_ENC_IDEA_IDX;
		break;
	case SSL_eNULL:
		i = SSL_ENC_NULL_IDX;
		break;
	case SSL_AES128:
		i = SSL_ENC_AES128_IDX;
		break;
	case SSL_AES256:
		i = SSL_ENC_AES256_IDX;
		break;
	case SSL_CAMELLIA128:
		i = SSL_ENC_CAMELLIA128_IDX;
		break;
	case SSL_CAMELLIA256:
		i = SSL_ENC_CAMELLIA256_IDX;
		break;
	case SSL_eGOST2814789CNT:
		i = SSL_ENC_GOST89_IDX;
		break;
	case SSL_AES128GCM:
		i = SSL_ENC_AES128GCM_IDX;
		break;
	case SSL_AES256GCM:
		i = SSL_ENC_AES256GCM_IDX;
		break;
	default:
		i = -1;
		break;
	}

	if ((i < 0) || (i >= SSL_ENC_NUM_IDX))
		*enc = NULL;
	else {
		if (i == SSL_ENC_NULL_IDX)
			*enc = EVP_enc_null();
		else
			*enc = ssl_cipher_methods[i];
	}

	switch (c->algorithm_mac) {
	case SSL_MD5:
		i = SSL_MD_MD5_IDX;
		break;
	case SSL_SHA1:
		i = SSL_MD_SHA1_IDX;
		break;
	case SSL_SHA256:
		i = SSL_MD_SHA256_IDX;
		break;
	case SSL_SHA384:
		i = SSL_MD_SHA384_IDX;
		break;
	case SSL_GOST94:
		i = SSL_MD_GOST94_IDX;
		break;
	case SSL_GOST89MAC:
		i = SSL_MD_GOST89MAC_IDX;
		break;
	case SSL_STREEBOG256:
		i = SSL_MD_STREEBOG256_IDX;
		break;
	case SSL_STREEBOG512:
		i = SSL_MD_STREEBOG512_IDX;
		break;
	default:
		i = -1;
		break;
	}
	if ((i < 0) || (i >= SSL_MD_NUM_IDX)) {
		*md = NULL;

		if (mac_pkey_type != NULL)
			*mac_pkey_type = NID_undef;
		if (mac_secret_size != NULL)
			*mac_secret_size = 0;
		if (c->algorithm_mac == SSL_AEAD)
			mac_pkey_type = NULL;
	} else {
		*md = ssl_digest_methods[i];
		if (mac_pkey_type != NULL)
			*mac_pkey_type = ssl_mac_pkey_id[i];
		if (mac_secret_size != NULL)
			*mac_secret_size = ssl_mac_secret_size[i];
	}

	if ((*enc != NULL) &&
	    (*md != NULL || (EVP_CIPHER_flags(*enc)&EVP_CIPH_FLAG_AEAD_CIPHER)) &&
	    (!mac_pkey_type || *mac_pkey_type != NID_undef)) {
		const EVP_CIPHER *evp;

		if (s->ssl_version >> 8 != TLS1_VERSION_MAJOR ||
		    s->ssl_version < TLS1_VERSION)
			return 1;

		if (c->algorithm_enc == SSL_RC4 &&
		    c->algorithm_mac == SSL_MD5 &&
		    (evp = EVP_get_cipherbyname("RC4-HMAC-MD5")))
			*enc = evp, *md = NULL;
		else if (c->algorithm_enc == SSL_AES128 &&
		    c->algorithm_mac == SSL_SHA1 &&
		    (evp = EVP_get_cipherbyname("AES-128-CBC-HMAC-SHA1")))
			*enc = evp, *md = NULL;
		else if (c->algorithm_enc == SSL_AES256 &&
		    c->algorithm_mac == SSL_SHA1 &&
		    (evp = EVP_get_cipherbyname("AES-256-CBC-HMAC-SHA1")))
			*enc = evp, *md = NULL;
		return (1);
	} else
		return (0);
}

/*
 * ssl_cipher_get_evp_aead sets aead to point to the correct EVP_AEAD object
 * for s->cipher. It returns 1 on success and 0 on error.
 */
int
ssl_cipher_get_evp_aead(const SSL_SESSION *s, const EVP_AEAD **aead)
{
	const SSL_CIPHER *c = s->cipher;

	*aead = NULL;

	if (c == NULL)
		return 0;
	if ((c->algorithm2 & SSL_CIPHER_ALGORITHM2_AEAD) == 0)
		return 0;

	switch (c->algorithm_enc) {
#ifndef OPENSSL_NO_AES
	case SSL_AES128GCM:
		*aead = EVP_aead_aes_128_gcm();
		return 1;
	case SSL_AES256GCM:
		*aead = EVP_aead_aes_256_gcm();
		return 1;
#endif
#if !defined(OPENSSL_NO_CHACHA) && !defined(OPENSSL_NO_POLY1305)
	case SSL_CHACHA20POLY1305:
		*aead = EVP_aead_chacha20_poly1305();
		return 1;
	case SSL_CHACHA20POLY1305_OLD:
		*aead = EVP_aead_chacha20_poly1305_old();
		return 1;
#endif
	default:
		break;
	}
	return 0;
}

int
ssl_get_handshake_digest(int idx, long *mask, const EVP_MD **md)
{
	if (idx < 0 || idx >= SSL_MD_NUM_IDX) {
		return 0;
	}
	*mask = ssl_handshake_digest_flag[idx];
	if (*mask)
		*md = ssl_digest_methods[idx];
	else
		*md = NULL;
	return 1;
}

#define ITEM_SEP(a) \
	(((a) == ':') || ((a) == ' ') || ((a) == ';') || ((a) == ','))

static void
ll_append_tail(CIPHER_ORDER **head, CIPHER_ORDER *curr,
    CIPHER_ORDER **tail)
{
	if (curr == *tail)
		return;
	if (curr == *head)
		*head = curr->next;
	if (curr->prev != NULL)
		curr->prev->next = curr->next;
	if (curr->next != NULL)
		curr->next->prev = curr->prev;
	(*tail)->next = curr;
	curr->prev= *tail;
	curr->next = NULL;
	*tail = curr;
}

static void
ll_append_head(CIPHER_ORDER **head, CIPHER_ORDER *curr,
    CIPHER_ORDER **tail)
{
	if (curr == *head)
		return;
	if (curr == *tail)
		*tail = curr->prev;
	if (curr->next != NULL)
		curr->next->prev = curr->prev;
	if (curr->prev != NULL)
		curr->prev->next = curr->next;
	(*head)->prev = curr;
	curr->next= *head;
	curr->prev = NULL;
	*head = curr;
}

static void
ssl_cipher_get_disabled(unsigned long *mkey, unsigned long *auth,
    unsigned long *enc, unsigned long *mac, unsigned long *ssl)
{
	*mkey = 0;
	*auth = 0;
	*enc = 0;
	*mac = 0;
	*ssl = 0;

	/*
	 * Check for the availability of GOST 34.10 public/private key
	 * algorithms. If they are not available disable the associated
	 * authentication and key exchange algorithms.
	 */
	if (EVP_PKEY_meth_find(NID_id_GostR3410_2001) == NULL) {
		*auth |= SSL_aGOST01;
		*mkey |= SSL_kGOST;
	}

#ifdef SSL_FORBID_ENULL
	*enc |= SSL_eNULL;
#endif

	*enc |= (ssl_cipher_methods[SSL_ENC_DES_IDX ] == NULL) ? SSL_DES : 0;
	*enc |= (ssl_cipher_methods[SSL_ENC_3DES_IDX] == NULL) ? SSL_3DES : 0;
	*enc |= (ssl_cipher_methods[SSL_ENC_RC4_IDX ] == NULL) ? SSL_RC4 : 0;
	*enc |= (ssl_cipher_methods[SSL_ENC_IDEA_IDX] == NULL) ? SSL_IDEA : 0;
	*enc |= (ssl_cipher_methods[SSL_ENC_AES128_IDX] == NULL) ? SSL_AES128 : 0;
	*enc |= (ssl_cipher_methods[SSL_ENC_AES256_IDX] == NULL) ? SSL_AES256 : 0;
	*enc |= (ssl_cipher_methods[SSL_ENC_AES128GCM_IDX] == NULL) ? SSL_AES128GCM : 0;
	*enc |= (ssl_cipher_methods[SSL_ENC_AES256GCM_IDX] == NULL) ? SSL_AES256GCM : 0;
	*enc |= (ssl_cipher_methods[SSL_ENC_CAMELLIA128_IDX] == NULL) ? SSL_CAMELLIA128 : 0;
	*enc |= (ssl_cipher_methods[SSL_ENC_CAMELLIA256_IDX] == NULL) ? SSL_CAMELLIA256 : 0;
	*enc |= (ssl_cipher_methods[SSL_ENC_GOST89_IDX] == NULL) ? SSL_eGOST2814789CNT : 0;

	*mac |= (ssl_digest_methods[SSL_MD_MD5_IDX ] == NULL) ? SSL_MD5 : 0;
	*mac |= (ssl_digest_methods[SSL_MD_SHA1_IDX] == NULL) ? SSL_SHA1 : 0;
	*mac |= (ssl_digest_methods[SSL_MD_SHA256_IDX] == NULL) ? SSL_SHA256 : 0;
	*mac |= (ssl_digest_methods[SSL_MD_SHA384_IDX] == NULL) ? SSL_SHA384 : 0;
	*mac |= (ssl_digest_methods[SSL_MD_GOST94_IDX] == NULL) ? SSL_GOST94 : 0;
	*mac |= (ssl_digest_methods[SSL_MD_GOST89MAC_IDX] == NULL) ? SSL_GOST89MAC : 0;
	*mac |= (ssl_digest_methods[SSL_MD_STREEBOG256_IDX] == NULL) ? SSL_STREEBOG256 : 0;
	*mac |= (ssl_digest_methods[SSL_MD_STREEBOG512_IDX] == NULL) ? SSL_STREEBOG512 : 0;

}

static void
ssl_cipher_collect_ciphers(const SSL_METHOD *ssl_method, int num_of_ciphers,
    unsigned long disabled_mkey, unsigned long disabled_auth,
    unsigned long disabled_enc, unsigned long disabled_mac,
    unsigned long disabled_ssl, CIPHER_ORDER *co_list,
    CIPHER_ORDER **head_p, CIPHER_ORDER **tail_p)
{
	int i, co_list_num;
	const SSL_CIPHER *c;

	/*
	 * We have num_of_ciphers descriptions compiled in, depending on the
	 * method selected (SSLv3, TLSv1, etc). These will later be sorted in
	 * a linked list with at most num entries.
	 */

	/* Get the initial list of ciphers */
	co_list_num = 0;	/* actual count of ciphers */
	for (i = 0; i < num_of_ciphers; i++) {
		c = ssl_method->get_cipher(i);
		/* drop those that use any of that is not available */
		if ((c != NULL) && c->valid &&
		    !(c->algorithm_mkey & disabled_mkey) &&
		    !(c->algorithm_auth & disabled_auth) &&
		    !(c->algorithm_enc & disabled_enc) &&
		    !(c->algorithm_mac & disabled_mac) &&
		    !(c->algorithm_ssl & disabled_ssl)) {
			co_list[co_list_num].cipher = c;
			co_list[co_list_num].next = NULL;
			co_list[co_list_num].prev = NULL;
			co_list[co_list_num].active = 0;
			co_list_num++;
			/*
			if (!sk_push(ca_list,(char *)c)) goto err;
			*/
		}
	}

	/*
	 * Prepare linked list from list entries
	 */
	if (co_list_num > 0) {
		co_list[0].prev = NULL;

		if (co_list_num > 1) {
			co_list[0].next = &co_list[1];

			for (i = 1; i < co_list_num - 1; i++) {
				co_list[i].prev = &co_list[i - 1];
				co_list[i].next = &co_list[i + 1];
			}

			co_list[co_list_num - 1].prev =
			    &co_list[co_list_num - 2];
		}

		co_list[co_list_num - 1].next = NULL;

		*head_p = &co_list[0];
		*tail_p = &co_list[co_list_num - 1];
	}
}

static void
ssl_cipher_collect_aliases(const SSL_CIPHER **ca_list, int num_of_group_aliases,
    unsigned long disabled_mkey, unsigned long disabled_auth,
    unsigned long disabled_enc, unsigned long disabled_mac,
    unsigned long disabled_ssl, CIPHER_ORDER *head)
{
	CIPHER_ORDER *ciph_curr;
	const SSL_CIPHER **ca_curr;
	int i;
	unsigned long mask_mkey = ~disabled_mkey;
	unsigned long mask_auth = ~disabled_auth;
	unsigned long mask_enc = ~disabled_enc;
	unsigned long mask_mac = ~disabled_mac;
	unsigned long mask_ssl = ~disabled_ssl;

	/*
	 * First, add the real ciphers as already collected
	 */
	ciph_curr = head;
	ca_curr = ca_list;
	while (ciph_curr != NULL) {
		*ca_curr = ciph_curr->cipher;
		ca_curr++;
		ciph_curr = ciph_curr->next;
	}

	/*
	 * Now we add the available ones from the cipher_aliases[] table.
	 * They represent either one or more algorithms, some of which
	 * in any affected category must be supported (set in enabled_mask),
	 * or represent a cipher strength value (will be added in any case because algorithms=0).
	 */
	for (i = 0; i < num_of_group_aliases; i++) {
		unsigned long algorithm_mkey = cipher_aliases[i].algorithm_mkey;
		unsigned long algorithm_auth = cipher_aliases[i].algorithm_auth;
		unsigned long algorithm_enc = cipher_aliases[i].algorithm_enc;
		unsigned long algorithm_mac = cipher_aliases[i].algorithm_mac;
		unsigned long algorithm_ssl = cipher_aliases[i].algorithm_ssl;

		if (algorithm_mkey)
			if ((algorithm_mkey & mask_mkey) == 0)
				continue;

		if (algorithm_auth)
			if ((algorithm_auth & mask_auth) == 0)
				continue;

		if (algorithm_enc)
			if ((algorithm_enc & mask_enc) == 0)
				continue;

		if (algorithm_mac)
			if ((algorithm_mac & mask_mac) == 0)
				continue;

		if (algorithm_ssl)
			if ((algorithm_ssl & mask_ssl) == 0)
				continue;

		*ca_curr = (SSL_CIPHER *)(cipher_aliases + i);
		ca_curr++;
	}

	*ca_curr = NULL;	/* end of list */
}

static void
ssl_cipher_apply_rule(unsigned long cipher_id, unsigned long alg_mkey,
    unsigned long alg_auth, unsigned long alg_enc, unsigned long alg_mac,
    unsigned long alg_ssl, unsigned long algo_strength,
    int rule, int strength_bits, CIPHER_ORDER **head_p, CIPHER_ORDER **tail_p)
{
	CIPHER_ORDER *head, *tail, *curr, *next, *last;
	const SSL_CIPHER *cp;
	int reverse = 0;


	if (rule == CIPHER_DEL)
		reverse = 1; /* needed to maintain sorting between currently deleted ciphers */

	head = *head_p;
	tail = *tail_p;

	if (reverse) {
		next = tail;
		last = head;
	} else {
		next = head;
		last = tail;
	}

	curr = NULL;
	for (;;) {
		if (curr == last)
			break;
		curr = next;
		next = reverse ? curr->prev : curr->next;

		cp = curr->cipher;

		/*
		 * Selection criteria is either the value of strength_bits
		 * or the algorithms used.
		 */
		if (strength_bits >= 0) {
			if (strength_bits != cp->strength_bits)
				continue;
		} else {

			if (alg_mkey && !(alg_mkey & cp->algorithm_mkey))
				continue;
			if (alg_auth && !(alg_auth & cp->algorithm_auth))
				continue;
			if (alg_enc && !(alg_enc & cp->algorithm_enc))
				continue;
			if (alg_mac && !(alg_mac & cp->algorithm_mac))
				continue;
			if (alg_ssl && !(alg_ssl & cp->algorithm_ssl))
				continue;
			if ((algo_strength & SSL_STRONG_MASK) && !(algo_strength & SSL_STRONG_MASK & cp->algo_strength))
				continue;
		}


		/* add the cipher if it has not been added yet. */
		if (rule == CIPHER_ADD) {
			/* reverse == 0 */
			if (!curr->active) {
				ll_append_tail(&head, curr, &tail);
				curr->active = 1;
			}
		}
		/* Move the added cipher to this location */
		else if (rule == CIPHER_ORD) {
			/* reverse == 0 */
			if (curr->active) {
				ll_append_tail(&head, curr, &tail);
			}
		} else if (rule == CIPHER_DEL) {
			/* reverse == 1 */
			if (curr->active) {
				/* most recently deleted ciphersuites get best positions
				 * for any future CIPHER_ADD (note that the CIPHER_DEL loop
				 * works in reverse to maintain the order) */
				ll_append_head(&head, curr, &tail);
				curr->active = 0;
			}
		} else if (rule == CIPHER_KILL) {
			/* reverse == 0 */
			if (head == curr)
				head = curr->next;
			else
				curr->prev->next = curr->next;
			if (tail == curr)
				tail = curr->prev;
			curr->active = 0;
			if (curr->next != NULL)
				curr->next->prev = curr->prev;
			if (curr->prev != NULL)
				curr->prev->next = curr->next;
			curr->next = NULL;
			curr->prev = NULL;
		}
	}

	*head_p = head;
	*tail_p = tail;
}

static int
ssl_cipher_strength_sort(CIPHER_ORDER **head_p, CIPHER_ORDER **tail_p)
{
	int max_strength_bits, i, *number_uses;
	CIPHER_ORDER *curr;

	/*
	 * This routine sorts the ciphers with descending strength. The sorting
	 * must keep the pre-sorted sequence, so we apply the normal sorting
	 * routine as '+' movement to the end of the list.
	 */
	max_strength_bits = 0;
	curr = *head_p;
	while (curr != NULL) {
		if (curr->active &&
		    (curr->cipher->strength_bits > max_strength_bits))
			max_strength_bits = curr->cipher->strength_bits;
		curr = curr->next;
	}

	number_uses = calloc((max_strength_bits + 1), sizeof(int));
	if (!number_uses) {
		SSLerr(SSL_F_SSL_CIPHER_STRENGTH_SORT, ERR_R_MALLOC_FAILURE);
		return (0);
	}

	/*
	 * Now find the strength_bits values actually used
	 */
	curr = *head_p;
	while (curr != NULL) {
		if (curr->active)
			number_uses[curr->cipher->strength_bits]++;
		curr = curr->next;
	}
	/*
	 * Go through the list of used strength_bits values in descending
	 * order.
	 */
	for (i = max_strength_bits; i >= 0; i--)
		if (number_uses[i] > 0)
			ssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, 0, CIPHER_ORD, i, head_p, tail_p);

	free(number_uses);
	return (1);
}

static int
ssl_cipher_process_rulestr(const char *rule_str, CIPHER_ORDER **head_p,
    CIPHER_ORDER **tail_p, const SSL_CIPHER **ca_list)
{
	unsigned long alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl;
	unsigned long algo_strength;
	int j, multi, found, rule, retval, ok, buflen;
	unsigned long cipher_id = 0;
	const char *l, *buf;
	char ch;

	retval = 1;
	l = rule_str;
	for (;;) {
		ch = *l;

		if (ch == '\0')
			break;

		if (ch == '-') {
			rule = CIPHER_DEL;
			l++;
		} else if (ch == '+') {
			rule = CIPHER_ORD;
			l++;
		} else if (ch == '!') {
			rule = CIPHER_KILL;
			l++;
		} else if (ch == '@@') {
			rule = CIPHER_SPECIAL;
			l++;
		} else {
			rule = CIPHER_ADD;
		}

		if (ITEM_SEP(ch)) {
			l++;
			continue;
		}

		alg_mkey = 0;
		alg_auth = 0;
		alg_enc = 0;
		alg_mac = 0;
		alg_ssl = 0;
		algo_strength = 0;

		for (;;) {
			ch = *l;
			buf = l;
			buflen = 0;
			while (((ch >= 'A') && (ch <= 'Z')) ||
			    ((ch >= '0') && (ch <= '9')) ||
			    ((ch >= 'a') && (ch <= 'z')) ||
			    (ch == '-') || (ch == '.')) {
				ch = *(++l);
				buflen++;
			}

			if (buflen == 0) {
				/*
				 * We hit something we cannot deal with,
				 * it is no command or separator nor
				 * alphanumeric, so we call this an error.
				 */
				SSLerr(SSL_F_SSL_CIPHER_PROCESS_RULESTR,
				    SSL_R_INVALID_COMMAND);
				retval = found = 0;
				l++;
				break;
			}

			if (rule == CIPHER_SPECIAL) {
				 /* unused -- avoid compiler warning */
				found = 0;
				/* special treatment */
				break;
			}

			/* check for multi-part specification */
			if (ch == '+') {
				multi = 1;
				l++;
			} else
				multi = 0;

			/*
			 * Now search for the cipher alias in the ca_list.
			 * Be careful with the strncmp, because the "buflen"
			 * limitation will make the rule "ADH:SOME" and the
			 * cipher "ADH-MY-CIPHER" look like a match for
			 * buflen=3. So additionally check whether the cipher
			 * name found has the correct length. We can save a
			 * strlen() call: just checking for the '\0' at the
			 * right place is sufficient, we have to strncmp()
			 * anyway (we cannot use strcmp(), because buf is not
			 * '\0' terminated.)
			 */
			j = found = 0;
			cipher_id = 0;
			while (ca_list[j]) {
				if (!strncmp(buf, ca_list[j]->name, buflen) &&
				    (ca_list[j]->name[buflen] == '\0')) {
					found = 1;
					break;
				} else
					j++;
			}

			if (!found)
				break;	/* ignore this entry */

			if (ca_list[j]->algorithm_mkey) {
				if (alg_mkey) {
					alg_mkey &= ca_list[j]->algorithm_mkey;
					if (!alg_mkey) {
						found = 0;
						break;
					}
				} else
					alg_mkey = ca_list[j]->algorithm_mkey;
			}

			if (ca_list[j]->algorithm_auth) {
				if (alg_auth) {
					alg_auth &= ca_list[j]->algorithm_auth;
					if (!alg_auth) {
						found = 0;
						break;
					}
				} else
					alg_auth = ca_list[j]->algorithm_auth;
			}

			if (ca_list[j]->algorithm_enc) {
				if (alg_enc) {
					alg_enc &= ca_list[j]->algorithm_enc;
					if (!alg_enc) {
						found = 0;
						break;
					}
				} else
					alg_enc = ca_list[j]->algorithm_enc;
			}

			if (ca_list[j]->algorithm_mac) {
				if (alg_mac) {
					alg_mac &= ca_list[j]->algorithm_mac;
					if (!alg_mac) {
						found = 0;
						break;
					}
				} else
					alg_mac = ca_list[j]->algorithm_mac;
			}

			if (ca_list[j]->algo_strength & SSL_STRONG_MASK) {
				if (algo_strength & SSL_STRONG_MASK) {
					algo_strength &=
					    (ca_list[j]->algo_strength &
					    SSL_STRONG_MASK) | ~SSL_STRONG_MASK;
					if (!(algo_strength &
					    SSL_STRONG_MASK)) {
						found = 0;
						break;
					}
				} else
					algo_strength |=
					    ca_list[j]->algo_strength &
					    SSL_STRONG_MASK;
			}

			if (ca_list[j]->valid) {
				/*
				 * explicit ciphersuite found; its protocol
				 * version does not become part of the search
				 * pattern!
				 */
				cipher_id = ca_list[j]->id;
			} else {
				/*
				 * not an explicit ciphersuite; only in this
				 * case, the protocol version is considered
				 * part of the search pattern
				 */
				if (ca_list[j]->algorithm_ssl) {
					if (alg_ssl) {
						alg_ssl &=
						    ca_list[j]->algorithm_ssl;
						if (!alg_ssl) {
							found = 0;
							break;
						}
					} else
						alg_ssl =
						    ca_list[j]->algorithm_ssl;
				}
			}

			if (!multi)
				break;
		}

		/*
		 * Ok, we have the rule, now apply it
		 */
		if (rule == CIPHER_SPECIAL) {
			/* special command */
			ok = 0;
			if ((buflen == 8) && !strncmp(buf, "STRENGTH", 8))
				ok = ssl_cipher_strength_sort(head_p, tail_p);
			else
				SSLerr(SSL_F_SSL_CIPHER_PROCESS_RULESTR,
				    SSL_R_INVALID_COMMAND);
			if (ok == 0)
				retval = 0;
			/*
			 * We do not support any "multi" options
			 * together with "@@", so throw away the
			 * rest of the command, if any left, until
			 * end or ':' is found.
			 */
			while ((*l != '\0') && !ITEM_SEP(*l))
				l++;
		} else if (found) {
			ssl_cipher_apply_rule(cipher_id, alg_mkey, alg_auth,
			    alg_enc, alg_mac, alg_ssl, algo_strength, rule,
			    -1, head_p, tail_p);
		} else {
			while ((*l != '\0') && !ITEM_SEP(*l))
				l++;
		}
		if (*l == '\0')
			break; /* done */
	}

	return (retval);
}

static inline int
ssl_aes_is_accelerated(void)
{
#if defined(__i386__) || defined(__x86_64__)
	return ((OPENSSL_cpu_caps() & (1ULL << 57)) != 0);
#else
	return (0);
#endif
}

STACK_OF(SSL_CIPHER) *
ssl_create_cipher_list(const SSL_METHOD *ssl_method,
    STACK_OF(SSL_CIPHER) **cipher_list,
    STACK_OF(SSL_CIPHER) **cipher_list_by_id,
    const char *rule_str)
{
	int ok, num_of_ciphers, num_of_alias_max, num_of_group_aliases;
	unsigned long disabled_mkey, disabled_auth, disabled_enc, disabled_mac, disabled_ssl;
	STACK_OF(SSL_CIPHER) *cipherstack, *tmp_cipher_list;
	const char *rule_p;
	CIPHER_ORDER *co_list = NULL, *head = NULL, *tail = NULL, *curr;
	const SSL_CIPHER **ca_list = NULL;

	/*
	 * Return with error if nothing to do.
	 */
	if (rule_str == NULL || cipher_list == NULL || cipher_list_by_id == NULL)
		return NULL;

	/*
	 * To reduce the work to do we only want to process the compiled
	 * in algorithms, so we first get the mask of disabled ciphers.
	 */
	ssl_cipher_get_disabled(&disabled_mkey, &disabled_auth, &disabled_enc, &disabled_mac, &disabled_ssl);

	/*
	 * Now we have to collect the available ciphers from the compiled
	 * in ciphers. We cannot get more than the number compiled in, so
	 * it is used for allocation.
	 */
	num_of_ciphers = ssl_method->num_ciphers();
	co_list = reallocarray(NULL, num_of_ciphers, sizeof(CIPHER_ORDER));
	if (co_list == NULL) {
		SSLerr(SSL_F_SSL_CREATE_CIPHER_LIST, ERR_R_MALLOC_FAILURE);
		return(NULL);	/* Failure */
	}

	ssl_cipher_collect_ciphers(ssl_method, num_of_ciphers,
	disabled_mkey, disabled_auth, disabled_enc, disabled_mac, disabled_ssl,
	co_list, &head, &tail);


	/* Now arrange all ciphers by preference: */

	/* Everything else being equal, prefer ephemeral ECDH over other key exchange mechanisms */
	ssl_cipher_apply_rule(0, SSL_kECDHE, 0, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);
	ssl_cipher_apply_rule(0, SSL_kECDHE, 0, 0, 0, 0, 0, CIPHER_DEL, -1, &head, &tail);

	if (ssl_aes_is_accelerated() == 1) {
		/*
		 * We have hardware assisted AES - prefer AES as a symmetric
		 * cipher, with CHACHA20 second.
		 */
		ssl_cipher_apply_rule(0, 0, 0, SSL_AES, 0, 0, 0,
		    CIPHER_ADD, -1, &head, &tail);
		ssl_cipher_apply_rule(0, 0, 0, SSL_CHACHA20POLY1305,
		    0, 0, 0, CIPHER_ADD, -1, &head, &tail);
		ssl_cipher_apply_rule(0, 0, 0, SSL_CHACHA20POLY1305_OLD,
		    0, 0, 0, CIPHER_ADD, -1, &head, &tail);
	} else {
		/*
		 * CHACHA20 is fast and safe on all hardware and is thus our
		 * preferred symmetric cipher, with AES second.
		 */
		ssl_cipher_apply_rule(0, 0, 0, SSL_CHACHA20POLY1305,
		    0, 0, 0, CIPHER_ADD, -1, &head, &tail);
		ssl_cipher_apply_rule(0, 0, 0, SSL_CHACHA20POLY1305_OLD,
		    0, 0, 0, CIPHER_ADD, -1, &head, &tail);
		ssl_cipher_apply_rule(0, 0, 0, SSL_AES, 0, 0, 0,
		    CIPHER_ADD, -1, &head, &tail);
	}

	/* Temporarily enable everything else for sorting */
	ssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);

	/* Low priority for MD5 */
	ssl_cipher_apply_rule(0, 0, 0, 0, SSL_MD5, 0, 0, CIPHER_ORD, -1, &head, &tail);

	/* Move anonymous ciphers to the end.  Usually, these will remain disabled.
	 * (For applications that allow them, they aren't too bad, but we prefer
	 * authenticated ciphers.) */
	ssl_cipher_apply_rule(0, 0, SSL_aNULL, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);

	/* Move ciphers without forward secrecy to the end */
	ssl_cipher_apply_rule(0, 0, SSL_aECDH, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);
	ssl_cipher_apply_rule(0, SSL_kRSA, 0, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);

	/* RC4 is sort of broken - move it to the end */
	ssl_cipher_apply_rule(0, 0, 0, SSL_RC4, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);

	/* Now sort by symmetric encryption strength.  The above ordering remains
	 * in force within each class */
	if (!ssl_cipher_strength_sort(&head, &tail)) {
		free(co_list);
		return NULL;
	}

	/* Now disable everything (maintaining the ordering!) */
	ssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, 0, CIPHER_DEL, -1, &head, &tail);


	/*
	 * We also need cipher aliases for selecting based on the rule_str.
	 * There might be two types of entries in the rule_str: 1) names
	 * of ciphers themselves 2) aliases for groups of ciphers.
	 * For 1) we need the available ciphers and for 2) the cipher
	 * groups of cipher_aliases added together in one list (otherwise
	 * we would be happy with just the cipher_aliases table).
	 */
	num_of_group_aliases = sizeof(cipher_aliases) / sizeof(SSL_CIPHER);
	num_of_alias_max = num_of_ciphers + num_of_group_aliases + 1;
	ca_list = reallocarray(NULL, num_of_alias_max, sizeof(SSL_CIPHER *));
	if (ca_list == NULL) {
		free(co_list);
		SSLerr(SSL_F_SSL_CREATE_CIPHER_LIST, ERR_R_MALLOC_FAILURE);
		return(NULL);	/* Failure */
	}
	ssl_cipher_collect_aliases(ca_list, num_of_group_aliases,
	disabled_mkey, disabled_auth, disabled_enc,
	disabled_mac, disabled_ssl, head);

	/*
	 * If the rule_string begins with DEFAULT, apply the default rule
	 * before using the (possibly available) additional rules.
	 */
	ok = 1;
	rule_p = rule_str;
	if (strncmp(rule_str, "DEFAULT", 7) == 0) {
		ok = ssl_cipher_process_rulestr(SSL_DEFAULT_CIPHER_LIST,
		&head, &tail, ca_list);
		rule_p += 7;
		if (*rule_p == ':')
			rule_p++;
	}

	if (ok && (strlen(rule_p) > 0))
		ok = ssl_cipher_process_rulestr(rule_p, &head, &tail, ca_list);

	free((void *)ca_list);	/* Not needed anymore */

	if (!ok) {
		/* Rule processing failure */
		free(co_list);
		return (NULL);
	}

	/*
	 * Allocate new "cipherstack" for the result, return with error
	 * if we cannot get one.
	 */
	if ((cipherstack = sk_SSL_CIPHER_new_null()) == NULL) {
		free(co_list);
		return (NULL);
	}

	/*
	 * The cipher selection for the list is done. The ciphers are added
	 * to the resulting precedence to the STACK_OF(SSL_CIPHER).
	 */
	for (curr = head; curr != NULL; curr = curr->next) {
		if (curr->active) {
			sk_SSL_CIPHER_push(cipherstack, curr->cipher);
		}
	}
	free(co_list);	/* Not needed any longer */

	tmp_cipher_list = sk_SSL_CIPHER_dup(cipherstack);
	if (tmp_cipher_list == NULL) {
		sk_SSL_CIPHER_free(cipherstack);
		return NULL;
	}
	if (*cipher_list != NULL)
		sk_SSL_CIPHER_free(*cipher_list);
	*cipher_list = cipherstack;
	if (*cipher_list_by_id != NULL)
		sk_SSL_CIPHER_free(*cipher_list_by_id);
	*cipher_list_by_id = tmp_cipher_list;
	(void)sk_SSL_CIPHER_set_cmp_func(*cipher_list_by_id,
	    ssl_cipher_ptr_id_cmp);

	sk_SSL_CIPHER_sort(*cipher_list_by_id);
	return (cipherstack);
}

const SSL_CIPHER *
SSL_CIPHER_get_by_id(unsigned int id)
{
	return ssl3_get_cipher_by_id(id);
}

const SSL_CIPHER *
SSL_CIPHER_get_by_value(uint16_t value)
{
	return ssl3_get_cipher_by_value(value);
}

char *
SSL_CIPHER_description(const SSL_CIPHER *cipher, char *buf, int len)
{
	unsigned long alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl, alg2;
	const char *ver, *kx, *au, *enc, *mac;
	char *ret;
	int l;

	alg_mkey = cipher->algorithm_mkey;
	alg_auth = cipher->algorithm_auth;
	alg_enc = cipher->algorithm_enc;
	alg_mac = cipher->algorithm_mac;
	alg_ssl = cipher->algorithm_ssl;

	alg2 = cipher->algorithm2;

	if (alg_ssl & SSL_SSLV3)
		ver = "SSLv3";
	else if (alg_ssl & SSL_TLSV1_2)
		ver = "TLSv1.2";
	else
		ver = "unknown";

	switch (alg_mkey) {
	case SSL_kRSA:
		kx = "RSA";
		break;
	case SSL_kDHE:
		kx = "DH";
		break;
	case SSL_kECDHr:
		kx = "ECDH/RSA";
		break;
	case SSL_kECDHe:
		kx = "ECDH/ECDSA";
		break;
	case SSL_kECDHE:
		kx = "ECDH";
		break;
	case SSL_kGOST:
		kx = "GOST";
		break;
	default:
		kx = "unknown";
	}

	switch (alg_auth) {
	case SSL_aRSA:
		au = "RSA";
		break;
	case SSL_aDSS:
		au = "DSS";
		break;
	case SSL_aECDH:
		au = "ECDH";
		break;
	case SSL_aNULL:
		au = "None";
		break;
	case SSL_aECDSA:
		au = "ECDSA";
		break;
	case SSL_aGOST01:
		au = "GOST01";
		break;
	default:
		au = "unknown";
		break;
	}

	switch (alg_enc) {
	case SSL_DES:
		enc = "DES(56)";
		break;
	case SSL_3DES:
		enc = "3DES(168)";
		break;
	case SSL_RC4:
		enc = alg2 & SSL2_CF_8_BYTE_ENC ? "RC4(64)" : "RC4(128)";
		break;
	case SSL_IDEA:
		enc = "IDEA(128)";
		break;
	case SSL_eNULL:
		enc = "None";
		break;
	case SSL_AES128:
		enc = "AES(128)";
		break;
	case SSL_AES256:
		enc = "AES(256)";
		break;
	case SSL_AES128GCM:
		enc = "AESGCM(128)";
		break;
	case SSL_AES256GCM:
		enc = "AESGCM(256)";
		break;
	case SSL_CAMELLIA128:
		enc = "Camellia(128)";
		break;
	case SSL_CAMELLIA256:
		enc = "Camellia(256)";
		break;
	case SSL_CHACHA20POLY1305:
		enc = "ChaCha20-Poly1305";
		break;
	case SSL_CHACHA20POLY1305_OLD:
		enc = "ChaCha20-Poly1305-Old";
		break;
	case SSL_eGOST2814789CNT:
		enc = "GOST-28178-89-CNT";
		break;
	default:
		enc = "unknown";
		break;
	}

	switch (alg_mac) {
	case SSL_MD5:
		mac = "MD5";
		break;
	case SSL_SHA1:
		mac = "SHA1";
		break;
	case SSL_SHA256:
		mac = "SHA256";
		break;
	case SSL_SHA384:
		mac = "SHA384";
		break;
	case SSL_AEAD:
		mac = "AEAD";
		break;
	case SSL_GOST94:
		mac = "GOST94";
		break;
	case SSL_GOST89MAC:
		mac = "GOST89IMIT";
		break;
	case SSL_STREEBOG256:
		mac = "STREEBOG256";
		break;
	case SSL_STREEBOG512:
		mac = "STREEBOG512";
		break;
	default:
		mac = "unknown";
		break;
	}

	if (asprintf(&ret, "%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s\n",
	    cipher->name, ver, kx, au, enc, mac) == -1)
		return "OPENSSL_malloc Error";

	if (buf != NULL) {
		l = strlcpy(buf, ret, len);
		free(ret);
		ret = buf;
		if (l >= len)
			ret = "Buffer too small";
	}

	return (ret);
}

char *
SSL_CIPHER_get_version(const SSL_CIPHER *c)
{
	if (c == NULL)
		return("(NONE)");
	if ((c->id >> 24) == 3)
		return("TLSv1/SSLv3");
	else
		return("unknown");
}

/* return the actual cipher being used */
const char *
SSL_CIPHER_get_name(const SSL_CIPHER *c)
{
	if (c != NULL)
		return (c->name);
	return("(NONE)");
}

/* number of bits for symmetric cipher */
int
SSL_CIPHER_get_bits(const SSL_CIPHER *c, int *alg_bits)
{
	int ret = 0;

	if (c != NULL) {
		if (alg_bits != NULL)
			*alg_bits = c->alg_bits;
		ret = c->strength_bits;
	}
	return (ret);
}

unsigned long
SSL_CIPHER_get_id(const SSL_CIPHER *c)
{
	return c->id;
}

uint16_t
SSL_CIPHER_get_value(const SSL_CIPHER *c)
{
	return ssl3_cipher_get_value(c);
}

void *
SSL_COMP_get_compression_methods(void)
{
	return NULL;
}

int
SSL_COMP_add_compression_method(int id, void *cm)
{
	return 1;
}

const char *
SSL_COMP_get_name(const void *comp)
{
	return NULL;
}
@


1.85
log
@Rename EVP_aead_chacha20_poly1305() to EVP_aead_chacha20_poly1305_old()
and replace with EVP_aead_chacha20_poly1305_ietf(). The IETF version will
become the standard version.

Discussed with many.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.84 2015/12/12 22:04:10 mmcc Exp $ */
d417 1
a417 1
		.algorithm_enc = SSL_CHACHA20POLY1305,
d734 3
d1429 4
a1432 2
		ssl_cipher_apply_rule(0, 0, 0, SSL_CHACHA20POLY1305, 0, 0, 0,
		    CIPHER_ADD, -1, &head, &tail);
d1438 4
a1441 2
		ssl_cipher_apply_rule(0, 0, 0, SSL_CHACHA20POLY1305, 0, 0, 0,
		    CIPHER_ADD, -1, &head, &tail);
d1676 3
@


1.84
log
@decipher comment. ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.83 2015/09/13 12:34:02 jsing Exp $ */
d734 1
a734 1
		*aead = EVP_aead_chacha20_poly1305();
@


1.83
log
@Switch to miod's shiny new OPENSSL_cpu_caps() and we can now also enable
the AES acceleration checking for i386.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.82 2015/09/13 09:10:01 jsing Exp $ */
d1454 1
a1454 1
	/* RC4 is sort-of broken -- move the the end */
@


1.82
log
@If we have hardware acceleration for AES, prefer AES as a symmetric cipher
over CHACHA20. Otherwise, prefer CHACHA20 with AES second.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.81 2015/02/07 04:17:11 jsing Exp $ */
d1364 2
a1365 2
#if defined(__x86_64__)
	return ((OPENSSL_ia32cap_loc()[0] & (1UL << 57)) != 0);
@


1.81
log
@Provide a SSL_CIPHER_get_by_value() function that allows a cipher to be
retrieved via its cipher suite value. A corresponding SSL_CIPHER_by_value()
function returns the cipher suite value for a given SSL_CIPHER. These
functions should mean that software does not need to resort to
put_cipher_by_char()/get_cipher_by_char() in order to locate a cipher.

Begrudgingly also provide a SSL_CIPHER_get_by_id() function that locates a
cipher via the internal cipher identifier. Unfortunately these have already
been leaked outside the library via SSL_CIPHER_by_id() and the various
SSL3_CK_* and TLS1_CK_* defines in the ssl3.h/tls1.h headers.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.80 2015/01/26 13:06:39 jsing Exp $ */
d1361 10
d1419 19
a1437 6
	/*
	 * CHACHA20 is fast and safe on all hardware and is thus our preferred
	 * symmetric cipher, with AES second.
	 */
	ssl_cipher_apply_rule(0, 0, 0, SSL_CHACHA20POLY1305, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);
	ssl_cipher_apply_rule(0, 0, 0, SSL_AES, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);
@


1.80
log
@Add AEAD as a "MAC alias" so that it is possible to identify/select ciphers
that use AEAD instead of a MAC. This allows for TLSv1.2 AEAD ciphers
(effectively the only ciphers that are still considered to be secure) to be
selected using TLSv1.2+AEAD as a cipher string.

ok bcook@@ doug@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.79 2014/12/14 15:30:50 jsing Exp $ */
d1528 12
d1741 6
@


1.79
log
@Remove trailing whitespace.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.78 2014/12/10 15:36:47 jsing Exp $ */
d421 4
@


1.78
log
@Remove support for GOST R 34.10-94 signature authentication, along with
the two ciphersuites that use it. GOST94 public/private keys have been
long obsoleted and libcrypto does not have support for them anyway.

Discussed with Dmitry Eremin-Solenikov.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.77 2014/12/07 12:13:06 jsing Exp $ */
d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d113 1
a113 1
 * ECC cipher suite support in OpenSSL originally developed by 
d180 1
a180 1
/*Constant SSL_MAX_DIGEST equal to size of digests array should be 
d183 1
a183 1
#define SSL_MD_NUM_IDX	SSL_MAX_DIGEST 
d230 1
a230 1
	
d241 1
a241 1
	
d260 1
a260 1
	
d281 1
a281 1
	
d286 1
a286 1
	
d419 1
a419 1
	
d457 1
a457 1
	
d471 1
a471 1
	
d879 1
a879 1
	 */	
@


1.77
log
@Remove get_optional_pkey_id() - it is a hack that existed due to GOST
only sometimes being available... and when it was available it was via
the crypto engine. GOST is now part of libcrypto proper.

Instead of trying to do EVP PKEY lookups via string literals and the
ASN1 interfaces, lookup the methods directly using the appropriate NID.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.76 2014/12/06 15:27:45 jsing Exp $ */
a316 4
		.name = SSL_TXT_aGOST94,
		.algorithm_auth = SSL_aGOST94,
	},
	{
d322 1
a322 1
		.algorithm_auth = SSL_aGOST94|SSL_aGOST01,
d807 1
a807 3
	if (EVP_PKEY_meth_find(NID_id_GostR3410_94) == NULL)
		*auth |= SSL_aGOST94;
	if (EVP_PKEY_meth_find(NID_id_GostR3410_2001) == NULL)
a808 1
	if (((~*auth) & (SSL_aGOST94|SSL_aGOST01)) == 0)
d810 1
a1584 3
		break;
	case SSL_aGOST94:
		au = "GOST94";
@


1.76
log
@Remove now bogus comment that got missed in the GOST commit.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.75 2014/12/06 15:25:40 jsing Exp $ */
a490 36
/* Search for public key algorithm with given name and 
 * return its pkey_id if it is available. Otherwise return 0
 */
#ifdef OPENSSL_NO_ENGINE

static int
get_optional_pkey_id(const char *pkey_name)
{
	const EVP_PKEY_ASN1_METHOD *ameth;
	int pkey_id = 0;
	ameth = EVP_PKEY_asn1_find_str(NULL, pkey_name, -1);
	if (ameth) {
		EVP_PKEY_asn1_get0_info(&pkey_id, NULL, NULL, NULL, NULL, ameth);
	}
	return pkey_id;
}

#else

static int
get_optional_pkey_id(const char *pkey_name)
{
	const EVP_PKEY_ASN1_METHOD *ameth;
	ENGINE *tmpeng = NULL;
	int pkey_id = 0;
	ameth = EVP_PKEY_asn1_find_str(&tmpeng, pkey_name, -1);
	if (ameth) {
		EVP_PKEY_asn1_get0_info(&pkey_id, NULL, NULL, NULL, NULL, ameth);
	}
	if (tmpeng)
		ENGINE_finish(tmpeng);
	return pkey_id;
}

#endif

d807 3
a809 2
	 * Check for presence of GOST 34.10 algorithms, and if they
	 * do not present, disable  appropriate auth and key exchange.
d811 1
a811 1
	if (!get_optional_pkey_id("gost94")) {
d813 1
a813 2
	}
	if (!get_optional_pkey_id("gost2001")) {
d815 1
a815 3
	}
	/* Disable GOST key exchange if no GOST signature algs are available. */
	if (((~*auth) & (SSL_aGOST94|SSL_aGOST01)) == 0) {
d817 1
a817 1
	}
@


1.75
log
@Fix some horrible style(9) violations...
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.74 2014/11/18 05:33:43 miod Exp $ */
d187 1
a187 4
/* PKEY_TYPE for GOST89MAC is known in advance, but, because
 * implementation is engine-provided, we'll fill it only if
 * corresponding EVP_PKEY_METHOD is found 
 */
@


1.74
log
@Update the GOST code in libssl, as contributed by Dmitry Eremin-Solenikov.

This causes a libssl major version bump as this affects the layout of some
internal-but-unfortunately-made-visible structs.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.73 2014/11/16 14:12:47 jsing Exp $ */
d533 6
a538 6
	ssl_cipher_methods[SSL_ENC_DES_IDX]=
	EVP_get_cipherbyname(SN_des_cbc);
	ssl_cipher_methods[SSL_ENC_3DES_IDX]=
	EVP_get_cipherbyname(SN_des_ede3_cbc);
	ssl_cipher_methods[SSL_ENC_RC4_IDX]=
	EVP_get_cipherbyname(SN_rc4);
d540 2
a541 2
	ssl_cipher_methods[SSL_ENC_IDEA_IDX]=
	EVP_get_cipherbyname(SN_idea_cbc);
d545 20
a564 20
	ssl_cipher_methods[SSL_ENC_AES128_IDX]=
	EVP_get_cipherbyname(SN_aes_128_cbc);
	ssl_cipher_methods[SSL_ENC_AES256_IDX]=
	EVP_get_cipherbyname(SN_aes_256_cbc);
	ssl_cipher_methods[SSL_ENC_CAMELLIA128_IDX]=
	EVP_get_cipherbyname(SN_camellia_128_cbc);
	ssl_cipher_methods[SSL_ENC_CAMELLIA256_IDX]=
	EVP_get_cipherbyname(SN_camellia_256_cbc);
	ssl_cipher_methods[SSL_ENC_GOST89_IDX]=
	EVP_get_cipherbyname(SN_gost89_cnt);

	ssl_cipher_methods[SSL_ENC_AES128GCM_IDX]=
	EVP_get_cipherbyname(SN_aes_128_gcm);
	ssl_cipher_methods[SSL_ENC_AES256GCM_IDX]=
	EVP_get_cipherbyname(SN_aes_256_gcm);

	ssl_digest_methods[SSL_MD_MD5_IDX]=
	EVP_get_digestbyname(SN_md5);
	ssl_mac_secret_size[SSL_MD_MD5_IDX]=
	EVP_MD_size(ssl_digest_methods[SSL_MD_MD5_IDX]);
d566 4
a569 4
	ssl_digest_methods[SSL_MD_SHA1_IDX]=
	EVP_get_digestbyname(SN_sha1);
	ssl_mac_secret_size[SSL_MD_SHA1_IDX]=
	EVP_MD_size(ssl_digest_methods[SSL_MD_SHA1_IDX]);
d571 2
a572 2
	ssl_digest_methods[SSL_MD_GOST94_IDX]=
	EVP_get_digestbyname(SN_id_GostR3411_94);
d574 2
a575 2
		ssl_mac_secret_size[SSL_MD_GOST94_IDX]=
		EVP_MD_size(ssl_digest_methods[SSL_MD_GOST94_IDX]);
d578 2
a579 2
	ssl_digest_methods[SSL_MD_GOST89MAC_IDX]=
	EVP_get_digestbyname(SN_id_Gost28147_89_MAC);
d584 16
a599 16
	ssl_digest_methods[SSL_MD_SHA256_IDX]=
	EVP_get_digestbyname(SN_sha256);
	ssl_mac_secret_size[SSL_MD_SHA256_IDX]=
	EVP_MD_size(ssl_digest_methods[SSL_MD_SHA256_IDX]);
	ssl_digest_methods[SSL_MD_SHA384_IDX]=
	EVP_get_digestbyname(SN_sha384);
	ssl_mac_secret_size[SSL_MD_SHA384_IDX]=
	EVP_MD_size(ssl_digest_methods[SSL_MD_SHA384_IDX]);
	ssl_digest_methods[SSL_MD_STREEBOG256_IDX]=
	EVP_get_digestbyname(SN_id_tc26_gost3411_2012_256);
	ssl_mac_secret_size[SSL_MD_STREEBOG256_IDX]=
	EVP_MD_size(ssl_digest_methods[SSL_MD_STREEBOG256_IDX]);
	ssl_digest_methods[SSL_MD_STREEBOG512_IDX]=
	EVP_get_digestbyname(SN_id_tc26_gost3411_2012_512);
	ssl_mac_secret_size[SSL_MD_STREEBOG512_IDX]=
	EVP_MD_size(ssl_digest_methods[SSL_MD_STREEBOG512_IDX]);
d887 2
a888 3
ssl_cipher_collect_ciphers(const SSL_METHOD *ssl_method,
    int num_of_ciphers,
unsigned long disabled_mkey, unsigned long disabled_auth,
d890 2
a891 3
unsigned long disabled_ssl,
    CIPHER_ORDER *co_list,
CIPHER_ORDER **head_p, CIPHER_ORDER **tail_p)
d938 2
a939 1
			co_list[co_list_num - 1].prev = &co_list[co_list_num - 2];
d1564 2
a1565 1
	(void)sk_SSL_CIPHER_set_cmp_func(*cipher_list_by_id, ssl_cipher_ptr_id_cmp);
@


1.73
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.72 2014/11/08 15:21:02 jsing Exp $ */
d178 2
d185 1
a185 1
	NULL, NULL, NULL, NULL, NULL, NULL
d192 2
a193 2
	EVP_PKEY_HMAC, EVP_PKEY_HMAC, EVP_PKEY_HMAC, NID_undef,
	EVP_PKEY_HMAC, EVP_PKEY_HMAC
d197 1
a197 1
	0, 0, 0, 0, 0, 0
d203 2
a204 1
	SSL_HANDSHAKE_MAC_SHA384
d331 1
a331 1
	
d456 8
a579 1
	ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX] = get_optional_pkey_id("gost-mac");
d592 8
d693 6
d856 1
a856 1
	if ((*auth & (SSL_aGOST94|SSL_aGOST01)) == (SSL_aGOST94|SSL_aGOST01)) {
d880 3
a882 1
	*mac |= (ssl_digest_methods[SSL_MD_GOST89MAC_IDX] == NULL || ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX]==NID_undef) ? SSL_GOST89MAC : 0;
d1610 3
d1633 6
d1681 3
d1704 12
@


1.72
log
@Clean up more SSLv2 remnants.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.71 2014/11/02 10:42:38 jsing Exp $ */
d144 1
d146 1
d150 1
@


1.71
log
@Remove remnants from RC2 and SEED - there are no longer any cipher suites
that use these algorithms (and SEED was removed from libcrypto some time
ago).

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.70 2014/10/15 13:57:21 jsing Exp $ */
a452 4
		.name = SSL_TXT_SSLV2,
		.algorithm_ssl = SSL_SSLV2,
	},
	{
d871 2
a872 3
	 * method selected (SSLv2 and/or SSLv3, TLSv1 etc).
	 * These will later be sorted in a linked list with at most num
	 * entries.
d1558 1
a1558 3
	if (alg_ssl & SSL_SSLV2)
		ver = "SSLv2";
	else if (alg_ssl & SSL_SSLV3)
a1686 2
	int i;

d1689 1
a1689 2
	i = (int)(c->id >> 24L);
	if (i == 3)
a1690 2
	else if (i == 2)
		return("SSLv2");
@


1.70
log
@Add cipher aliases for DHE (the correct name for EDH) and ECDHE (the
correct name for EECDH). The EDH and EECDH aliases remain for backwards
compatibility.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.69 2014/10/03 06:02:38 doug Exp $ */
d153 10
a162 12
#define SSL_ENC_RC2_IDX		3
#define SSL_ENC_IDEA_IDX	4
#define SSL_ENC_NULL_IDX	5
#define SSL_ENC_AES128_IDX	6
#define SSL_ENC_AES256_IDX	7
#define SSL_ENC_CAMELLIA128_IDX	8
#define SSL_ENC_CAMELLIA256_IDX	9
#define SSL_ENC_GOST89_IDX	10
#define SSL_ENC_SEED_IDX    	11
#define SSL_ENC_AES128GCM_IDX	12
#define SSL_ENC_AES256GCM_IDX	13
#define SSL_ENC_NUM_IDX		14
d166 1
a166 1
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
a380 4
		.name = SSL_TXT_RC2,
		.algorithm_enc = SSL_RC2,
	},
	{
a384 4
		.name = SSL_TXT_SEED,
		.algorithm_enc = SSL_SEED,
	},
	{
a528 2
	ssl_cipher_methods[SSL_ENC_RC2_IDX]=
	EVP_get_cipherbyname(SN_rc2_cbc);
a544 2
	ssl_cipher_methods[SSL_ENC_SEED_IDX]=
	EVP_get_cipherbyname(SN_seed_cbc);
a615 3
	case SSL_RC2:
		i = SSL_ENC_RC2_IDX;
		break;
a636 3
	case SSL_SEED:
		i = SSL_ENC_SEED_IDX;
		break;
a842 1
	*enc |= (ssl_cipher_methods[SSL_ENC_RC2_IDX ] == NULL) ? SSL_RC2 : 0;
a850 1
	*enc |= (ssl_cipher_methods[SSL_ENC_SEED_IDX] == NULL) ? SSL_SEED : 0;
a1622 3
	case SSL_RC2:
		enc = "RC2(128)";
		break;
a1645 3
		break;
	case SSL_SEED:
		enc = "SEED(128)";
@


1.69
log
@Use string literals in printf style calls so gcc's -Wformat works.

ok tedu@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.68 2014/09/19 16:02:35 jsing Exp $ */
d330 5
d337 5
@


1.68
log
@Add CHACHA20 as a cipher symmetric encryption alias.

From Ming <gzchenym at 126.com>
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.67 2014/09/07 12:16:23 jsing Exp $ */
a1561 1
	static const char *fmt="%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s\n";
d1694 2
a1695 1
	if (asprintf(&ret, fmt, cipher->name, ver, kx, au, enc, mac) == -1)
@


1.67
log
@Remove SSL_kDHr, SSL_kDHd and SSL_aDH. No supported ciphersuites use them,
nor do we plan on supporting them.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.66 2014/07/12 22:33:39 jsing Exp $ */
d415 4
@


1.66
log
@The correct name for EDH is DHE, likewise EECDH should be ECDHE.

Based on changes to OpenSSL trunk.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.65 2014/07/12 13:11:53 jsing Exp $ */
a251 15
		/* no such ciphersuites supported! */
		.name = SSL_TXT_kDHr,
		.algorithm_mkey = SSL_kDHr,
	},
	{
		/* no such ciphersuites supported! */
		.name = SSL_TXT_kDHd,
		.algorithm_mkey = SSL_kDHd,
	},
	{
		/* no such ciphersuites supported! */
		.name = SSL_TXT_kDH,
		.algorithm_mkey = SSL_kDHr|SSL_kDHd,
	},
	{
d257 1
a257 1
		.algorithm_mkey = SSL_kDHr|SSL_kDHd|SSL_kDHE,
a303 5
		/* no such ciphersuites supported! */
		.name = SSL_TXT_aDH,
		.algorithm_auth = SSL_aDH,
	},
	{
d819 2
a820 1
ssl_cipher_get_disabled(unsigned long *mkey, unsigned long *auth, unsigned long *enc, unsigned long *mac, unsigned long *ssl)
d828 4
a831 5
	*mkey |= SSL_kDHr|SSL_kDHd; /* no such ciphersuites supported! */
	*auth |= SSL_aDH;

	/* Check for presence of GOST 34.10 algorithms, and if they
	 * do not present, disable  appropriate auth and key exchange */
d838 1
a838 1
	/* Disable GOST key exchange if no GOST signature algs are available * */
a1456 1
	/* ssl_cipher_apply_rule(0, 0, SSL_aDH, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail); */
a1584 6
	case SSL_kDHr:
		kx = "DH/RSA";
		break;
	case SSL_kDHd:
		kx = "DH/DSS";
		break;
a1606 3
		break;
	case SSL_aDH:
		au = "DH";
@


1.65
log
@Remove remnants from PSK, KRB5 and SRP.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.64 2014/07/12 07:52:36 guenther Exp $ */
d236 1
a236 1
		.algorithm_mkey = SSL_kEDH|SSL_kEECDH,
d268 1
a268 1
		.algorithm_mkey = SSL_kEDH,
d272 1
a272 1
		.algorithm_mkey = SSL_kDHr|SSL_kDHd|SSL_kEDH,
d289 1
a289 1
		.algorithm_mkey = SSL_kEECDH,
d293 1
a293 1
		.algorithm_mkey = SSL_kECDHr|SSL_kECDHe|SSL_kEECDH,
d351 1
a351 1
		.algorithm_mkey = SSL_kEDH,
d356 1
a356 1
		.algorithm_mkey = SSL_kEECDH,
d370 1
a370 1
		.algorithm_mkey = SSL_kEDH,
d375 1
a375 1
		.algorithm_mkey = SSL_kEECDH,
d1454 2
a1455 2
	ssl_cipher_apply_rule(0, SSL_kEECDH, 0, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);
	ssl_cipher_apply_rule(0, SSL_kEECDH, 0, 0, 0, 0, 0, CIPHER_DEL, -1, &head, &tail);
d1612 1
a1612 1
	case SSL_kEDH:
d1621 1
a1621 1
	case SSL_kEECDH:
@


1.64
log
@Make disabling last cipher work.
From Thijs Alkemade via OpenSSL trunk
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.63 2014/07/11 09:24:44 beck Exp $ */
a275 5
		.name = SSL_TXT_kKRB5,
		.algorithm_mkey = SSL_kKRB5,
	},
	
	{
a296 8
		.name = SSL_TXT_kPSK,
		.algorithm_mkey = SSL_kPSK,
	},
	{
		.name = SSL_TXT_kSRP,
		.algorithm_mkey = SSL_kSRP,
	},
	{
a314 4
		.name = SSL_TXT_aKRB5,
		.algorithm_auth = SSL_aKRB5,
	},
	{
a335 4
		.name = SSL_TXT_aPSK,
		.algorithm_auth = SSL_aPSK,
	},
	{
a363 5
		.name = SSL_TXT_KRB5,
		.algorithm_mkey = SSL_kKRB5,
		.algorithm_auth = SSL_aKRB5,
	},
	{
d378 1
a378 10
	{
		.name = SSL_TXT_PSK,
		.algorithm_mkey = SSL_kPSK,
		.algorithm_auth = SSL_aPSK,
	},
	{
		.name = SSL_TXT_SRP,
		.algorithm_mkey = SSL_kSRP,
	},
	
d849 1
a849 5
	*mkey |= SSL_kKRB5;
	*auth |= SSL_aKRB5;
	*mkey |= SSL_kPSK;
	*auth |= SSL_aPSK;
	*mkey |= SSL_kSRP;
a1478 2
	ssl_cipher_apply_rule(0, SSL_kPSK, 0, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);
	ssl_cipher_apply_rule(0, SSL_kKRB5, 0, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);
a1611 3
	case SSL_kKRB5:
		kx = "KRB5";
		break;
a1623 6
	case SSL_kPSK:
		kx = "PSK";
		break;
	case SSL_kSRP:
		kx = "SRP";
		break;
a1637 3
	case SSL_aKRB5:
		au = "KRB5";
		break;
a1645 3
		break;
	case SSL_aPSK:
		au = "PSK";
@


1.63
log
@Remove the PSK code. We don't need to drag around this
baggage.
ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.62 2014/07/10 11:58:08 jsing Exp $ */
d1065 1
a1065 1
	CIPHER_ORDER *head, *tail, *curr, *curr2, *last;
d1077 1
a1077 1
		curr = tail;
d1080 1
a1080 1
		curr = head;
d1084 1
a1084 1
	curr2 = curr;
d1086 4
a1089 4
		if ((curr == NULL)
			|| (curr == last)) break;
		curr = curr2;
		curr2 = reverse ? curr->prev : curr->next;
@


1.62
log
@Remove more compression tendrils.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.61 2014/07/10 10:09:54 jsing Exp $ */
a885 1
#ifdef OPENSSL_NO_PSK
a887 1
#endif
@


1.61
log
@Remove more compression related code.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.60 2014/07/10 09:26:08 jsing Exp $ */
a169 4

#define SSL_COMP_NULL_IDX	0
#define SSL_COMP_ZLIB_IDX	1
#define SSL_COMP_NUM_IDX	2
@


1.60
log
@Put back some parts of the public SSL API that should not have been
completely decompressed.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.59 2014/07/10 08:51:15 tedu Exp $ */
a641 9
}

/* ssl_cipher_get_comp sets comp to the correct SSL_COMP for the given
 * session and returns 1. On error it returns 0. */
int
ssl_cipher_get_comp(const SSL_SESSION *s, SSL_COMP **comp)
{
	*comp = NULL;
	return 1;
@


1.59
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.58 2014/07/09 14:20:55 jsing Exp $ */
d1849 18
@


1.58
log
@Clean up and simplify SSL_CIPHER_description by always using asprintf. If
a buffer was supplied then we copy the result into it. Also make the
failure case return values match the documentation.

Joint work with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.57 2014/07/09 11:25:42 jsing Exp $ */
a144 3
#ifndef OPENSSL_NO_COMP
#include <openssl/comp.h>
#endif
a174 2
static STACK_OF(SSL_COMP) *ssl_comp_methods = NULL;

a642 48
#ifndef OPENSSL_NO_COMP

static int
sk_comp_cmp(const SSL_COMP * const *a,
    const SSL_COMP * const *b)
{
	return ((*a)->id - (*b)->id);
}

static void
load_builtin_compressions(void)
{
	int got_write_lock = 0;

	CRYPTO_r_lock(CRYPTO_LOCK_SSL);
	if (ssl_comp_methods == NULL) {
		CRYPTO_r_unlock(CRYPTO_LOCK_SSL);
		CRYPTO_w_lock(CRYPTO_LOCK_SSL);
		got_write_lock = 1;

		if (ssl_comp_methods == NULL) {
			SSL_COMP *comp = NULL;

			ssl_comp_methods = sk_SSL_COMP_new(sk_comp_cmp);
			if (ssl_comp_methods != NULL) {
				comp = malloc(sizeof(SSL_COMP));
				if (comp != NULL) {
					comp->method = COMP_zlib();
					if (comp->method &&
					    comp->method->type == NID_undef)
						free(comp);
					else {
						comp->id = SSL_COMP_ZLIB_IDX;
						comp->name = comp->method->name;
						sk_SSL_COMP_push(ssl_comp_methods, comp);
					}
				}
				sk_SSL_COMP_sort(ssl_comp_methods);
			}
		}
	}

	if (got_write_lock)
		CRYPTO_w_unlock(CRYPTO_LOCK_SSL);
	else
		CRYPTO_r_unlock(CRYPTO_LOCK_SSL);
}
#endif
a648 7
	SSL_COMP ctmp;
	int i;

#ifndef OPENSSL_NO_COMP
	load_builtin_compressions();
#endif

d650 1
a650 13
	if (s->compress_meth == 0)
		return 1;
	if (ssl_comp_methods == NULL)
		return 0;

	ctmp.id = s->compress_meth;
	i = sk_SSL_COMP_find(ssl_comp_methods, &ctmp);
	if (i >= 0) {
		*comp = sk_SSL_COMP_value(ssl_comp_methods, i);
		return 1;
	}

	return 0;
a1849 99

SSL_COMP *
ssl3_comp_find(STACK_OF(SSL_COMP) *sk, int n)
{
	SSL_COMP *ctmp;
	int i, nn;

	if ((n == 0) || (sk == NULL))
		return (NULL);
	nn = sk_SSL_COMP_num(sk);
	for (i = 0; i < nn; i++) {
		ctmp = sk_SSL_COMP_value(sk, i);
		if (ctmp->id == n)
			return (ctmp);
	}
	return (NULL);
}

#ifdef OPENSSL_NO_COMP
void *
SSL_COMP_get_compression_methods(void)
{
	return NULL;
}

int
SSL_COMP_add_compression_method(int id, void *cm)
{
	return 1;
}

const char *
SSL_COMP_get_name(const void *comp)
{
	return NULL;
}
#else
STACK_OF(SSL_COMP) *
SSL_COMP_get_compression_methods(void)
{
	load_builtin_compressions();
	return (ssl_comp_methods);
}

int
SSL_COMP_add_compression_method(int id, COMP_METHOD *cm)
{
	SSL_COMP *comp;

	if (cm == NULL || cm->type == NID_undef)
		return 1;

	/* According to draft-ietf-tls-compression-04.txt, the
	   compression number ranges should be the following:

	   0 to 63:    methods defined by the IETF
	   64 to 192:  external party methods assigned by IANA
	   193 to 255: reserved for private use */
	if (id < 193 || id > 255) {
		SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD,
		    SSL_R_COMPRESSION_ID_NOT_WITHIN_PRIVATE_RANGE);
		return 1;
	}

	comp = malloc(sizeof(SSL_COMP));
	if (comp == NULL) {
		SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD,
		    ERR_R_MALLOC_FAILURE);
		return (1);
	}
	comp->id = id;
	comp->method = cm;
	load_builtin_compressions();
	if (ssl_comp_methods &&
	    sk_SSL_COMP_find(ssl_comp_methods, comp) >= 0) {
		free(comp);
		SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD,
		    SSL_R_DUPLICATE_COMPRESSION_ID);
		return (1);
	} else if ((ssl_comp_methods == NULL) ||
	    !sk_SSL_COMP_push(ssl_comp_methods, comp)) {
		free(comp);
		SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD,
		    ERR_R_MALLOC_FAILURE);
		return (1);
	} else {
		return (0);
	}
}

const char *
SSL_COMP_get_name(const COMP_METHOD *comp)
{
	if (comp)
		return comp->name;
	return NULL;
}

#endif
@


1.57
log
@tedu the SSL export cipher handling - since we do not have enabled export
ciphers we no longer need the flags or code to support it.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.56 2014/07/08 21:50:40 jsing Exp $ */
d1707 4
a1711 4
	const char *ver;
	const char *kx, *au, *enc, *mac;
	unsigned long alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl, alg2;
	static const char *format="%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s\n";
d1722 1
a1722 1
		ver="SSLv2";
d1724 1
a1724 1
		ver="SSLv3";
d1726 1
a1726 1
		ver="TLSv1.2";
d1728 1
a1728 1
		ver="unknown";
d1735 1
a1735 1
		kx="DH/RSA";
d1738 1
a1738 1
		kx="DH/DSS";
d1741 1
a1741 1
		kx="KRB5";
d1747 1
a1747 1
		kx="ECDH/RSA";
d1750 1
a1750 1
		kx="ECDH/ECDSA";
d1753 1
a1753 1
		kx="ECDH";
d1756 1
a1756 1
		kx="PSK";
d1759 1
a1759 1
		kx="SRP";
d1762 1
a1762 1
		kx="unknown";
d1767 1
a1767 1
		au="RSA";
d1770 1
a1770 1
		au="DSS";
d1773 1
a1773 1
		au="DH";
d1776 1
a1776 1
		au="KRB5";
d1779 1
a1779 1
		au="ECDH";
d1782 1
a1782 1
		au="None";
d1785 1
a1785 1
		au="ECDSA";
d1788 1
a1788 1
		au="PSK";
d1791 1
a1791 1
		au="unknown";
d1800 1
a1800 1
		enc="3DES(168)";
d1809 1
a1809 1
		enc="IDEA(128)";
d1812 1
a1812 1
		enc="None";
d1815 1
a1815 1
		enc="AES(128)";
d1818 1
a1818 1
		enc="AES(256)";
d1821 1
a1821 1
		enc="AESGCM(128)";
d1824 1
a1824 1
		enc="AESGCM(256)";
d1827 1
a1827 1
		enc="Camellia(128)";
d1830 1
a1830 1
		enc="Camellia(256)";
d1833 1
a1833 1
		enc="SEED(128)";
d1839 1
a1839 1
		enc="unknown";
d1845 1
a1845 1
		mac="MD5";
d1848 1
a1848 1
		mac="SHA1";
d1851 1
a1851 1
		mac="SHA256";
d1854 1
a1854 1
		mac="SHA384";
d1857 1
a1857 1
		mac="AEAD";
d1860 1
a1860 1
		mac="unknown";
d1864 7
a1870 5
	if (buf == NULL)
		l = asprintf(&buf, format, cipher->name, ver, kx, au, enc, mac);
	else {
		l = snprintf(buf, len, format, cipher->name, ver, kx, au, enc,
		    mac);
d1872 1
a1872 1
			l = -1;
d1874 2
a1875 4
	if (l == -1)
		return("Buffer too small");
	else
		return (buf);
@


1.56
log
@Remove SSL_FIPS.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.55 2014/06/18 04:48:37 miod Exp $ */
a528 10
	/* export flag */
	{
		.name = SSL_TXT_EXP,
		.algo_strength = SSL_EXPORT,
	},
	{
		.name = SSL_TXT_EXPORT,
		.algo_strength = SSL_EXPORT,
	},
	
a530 8
		.name = SSL_TXT_EXP40,
		.algo_strength = SSL_EXP40,
	},
	{
		.name = SSL_TXT_EXP56,
		.algo_strength = SSL_EXP56,
	},
	{
a1198 2
			if ((algo_strength & SSL_EXP_MASK) && !(algo_strength & SSL_EXP_MASK & cp->algo_strength))
				continue;
a1451 15
			if (ca_list[j]->algo_strength & SSL_EXP_MASK) {
				if (algo_strength & SSL_EXP_MASK) {
					algo_strength &=
					    (ca_list[j]->algo_strength &
					    SSL_EXP_MASK) | ~SSL_EXP_MASK;
					if (!(algo_strength & SSL_EXP_MASK)) {
						found = 0;
						break;
					}
				} else
					algo_strength |=
					    ca_list[j]->algo_strength &
					    SSL_EXP_MASK;
			}

d1707 2
a1708 2
	int is_export, pkl, kl, l;
	const char *ver, *exp_str;
d1711 1
a1711 1
	static const char *format="%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s%s\n";
a1720 5
	is_export = SSL_C_IS_EXPORT(cipher);
	pkl = SSL_C_EXPORT_PKEYLENGTH(cipher);
	kl = SSL_C_EXPORT_KEYLENGTH(cipher);
	exp_str = is_export?" export":"";

d1732 1
a1732 1
		kx = is_export?(pkl == 512 ? "RSA(512)" : "RSA(1024)"):"RSA";
d1744 1
a1744 1
		kx = is_export?(pkl == 512 ? "DH(512)" : "DH(1024)"):"DH";
d1797 1
a1797 1
		enc = (is_export && kl == 5)?"DES(40)":"DES(56)";
d1803 1
a1803 2
		enc = is_export?(kl == 5 ? "RC4(40)" : "RC4(56)")
		:((alg2&SSL2_CF_8_BYTE_ENC)?"RC4(64)":"RC4(128)");
d1806 1
a1806 1
		enc = is_export?(kl == 5 ? "RC2(40)" : "RC2(56)"):"RC2(128)";
d1865 1
a1865 2
		l = asprintf(&buf, format, cipher->name, ver, kx, au, enc,
		    mac, exp_str);
d1868 1
a1868 1
		    mac, exp_str);
@


1.55
log
@Use asprintf() instead of a fixed 128-byte size in SSL_CIPHER_description()
when no storage buffer is passed.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.54 2014/06/18 04:47:32 miod Exp $ */
a558 7
	},

	/* FIPS 140-2 approved ciphersuite */
	{
		.name = SSL_TXT_FIPS,
		.algorithm_enc = ~SSL_eNULL,
		.algo_strength = SSL_FIPS,
@


1.54
log
@In SSL_COMP_add_compression_method(), make sure error cases actually return
`error' rather than `success'.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.53 2014/06/13 13:28:53 jsing Exp $ */
d1912 10
a1921 10
	if (buf == NULL) {
		len = 128;
		buf = malloc(len);
		if (buf == NULL)
			return("malloc Error");
	} else if (len < 128)
		return("Buffer too small");

	l = snprintf(buf, len, format, cipher->name, ver, kx, au, enc, mac, exp_str);
	if (l >= len || l == -1)
@


1.53
log
@Add ChaCha20-Poly1305 based ciphersuites.

Based on Adam Langley's chromium patches.

Tested by and ok sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_ciph.c,v 1.52 2014/06/12 15:49:31 deraadt Exp $ */
d2032 1
a2032 1
		return 0;
@


1.52
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d919 5
d1625 5
a1629 1
	/* AES is our preferred symmetric cipher */
d1882 3
@


1.51
log
@Add an SSL_CIPHER_ALGORITHM2_AEAD flag that is used to mark a cipher as
using EVP_AEAD. Also provide an EVP_AEAD-only equivalent of
ssl_cipher_get_evp().
@
text
@d1 1
a1 1
/* ssl/ssl_ciph.c */
@


1.50
log
@Use C99 initialisers for cipher_aliases. This improves readability,
removes the need for zero values to be specified (meaning that we usually
specify two fields instead of 12), makes the field names grepable and
protects from future field reordering/removal.

ok beck@@ miod@@
@
text
@d761 7
d892 31
@


1.49
log
@More KNF.
@
text
@d226 1
d228 5
a232 1
	{0, SSL_TXT_ALL, 0,     0, 0,~SSL_eNULL, 0, 0, 0, 0, 0, 0},
d234 89
a322 29
	{0, SSL_TXT_CMPALL, 0,  0, 0, SSL_eNULL, 0, 0, 0, 0, 0, 0},

	/* "COMPLEMENTOFDEFAULT" (does *not* include ciphersuites not found in ALL!) */
	{0, SSL_TXT_CMPDEF, 0,  SSL_kEDH|SSL_kEECDH, SSL_aNULL,~SSL_eNULL, 0, 0, 0, 0, 0, 0},

	/* key exchange aliases
	 * (some of those using only a single bit here combine
	 * multiple key exchange algs according to the RFCs,
	 * e.g. kEDH combines DHE_DSS and DHE_RSA) */
	{0, SSL_TXT_kRSA, 0,    SSL_kRSA,  0, 0, 0, 0, 0, 0, 0, 0},

	{0,SSL_TXT_kDHr,0,    SSL_kDHr,  0,0,0,0,0,0,0,0}, /* no such ciphersuites supported! */
	{0,SSL_TXT_kDHd,0,    SSL_kDHd,  0,0,0,0,0,0,0,0}, /* no such ciphersuites supported! */
	{0,SSL_TXT_kDH,0,     SSL_kDHr|SSL_kDHd,0,0,0,0,0,0,0,0}, /* no such ciphersuites supported! */
	{0, SSL_TXT_kEDH, 0,    SSL_kEDH,  0, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_DH, 0,      SSL_kDHr|SSL_kDHd|SSL_kEDH, 0, 0, 0, 0, 0, 0, 0, 0},

	{0, SSL_TXT_kKRB5, 0,   SSL_kKRB5, 0, 0, 0, 0, 0, 0, 0, 0},

	{0, SSL_TXT_kECDHr, 0,  SSL_kECDHr, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_kECDHe, 0,  SSL_kECDHe, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_kECDH, 0,   SSL_kECDHr|SSL_kECDHe, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_kEECDH, 0,  SSL_kEECDH, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_ECDH, 0,    SSL_kECDHr|SSL_kECDHe|SSL_kEECDH, 0, 0, 0, 0, 0, 0, 0, 0},

	{0, SSL_TXT_kPSK, 0,    SSL_kPSK,  0, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_kSRP, 0,    SSL_kSRP,  0, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_kGOST, 0, SSL_kGOST, 0, 0, 0, 0, 0, 0, 0, 0},

d324 54
a377 14
	{0, SSL_TXT_aRSA, 0,    0, SSL_aRSA,  0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_aDSS, 0,    0, SSL_aDSS,  0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_DSS, 0,     0, SSL_aDSS,   0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_aKRB5, 0,   0, SSL_aKRB5, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_aNULL, 0,   0, SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
	{0,SSL_TXT_aDH,0,     0,SSL_aDH,   0,0,0,0,0,0,0}, /* no such ciphersuites supported! */
	{0, SSL_TXT_aECDH, 0,   0, SSL_aECDH, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_aECDSA, 0,  0, SSL_aECDSA, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_ECDSA, 0,   0, SSL_aECDSA, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_aPSK, 0,    0, SSL_aPSK,  0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_aGOST94, 0, 0, SSL_aGOST94, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_aGOST01, 0, 0, SSL_aGOST01, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_aGOST, 0, 0, SSL_aGOST94|SSL_aGOST01, 0, 0, 0, 0, 0, 0, 0},

d379 44
a422 11
	{0, SSL_TXT_EDH, 0,     SSL_kEDH,~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_EECDH, 0,   SSL_kEECDH,~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_NULL, 0,    0, 0, SSL_eNULL, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_KRB5, 0,    SSL_kKRB5, SSL_aKRB5, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_RSA, 0,     SSL_kRSA, SSL_aRSA, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_ADH, 0,     SSL_kEDH, SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_AECDH, 0,   SSL_kEECDH, SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_PSK, 0,     SSL_kPSK, SSL_aPSK, 0, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_SRP, 0,     SSL_kSRP, 0, 0, 0, 0, 0, 0, 0, 0},


d424 57
a480 15
	{0, SSL_TXT_DES, 0,     0, 0, SSL_DES,   0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_3DES, 0,    0, 0, SSL_3DES,  0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_RC4, 0,     0, 0, SSL_RC4,   0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_RC2, 0,     0, 0, SSL_RC2,   0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_IDEA, 0,    0, 0, SSL_IDEA,  0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_SEED, 0,    0, 0, SSL_SEED,  0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_eNULL, 0,   0, 0, SSL_eNULL, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_AES128, 0,  0, 0, SSL_AES128|SSL_AES128GCM, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_AES256, 0,  0, 0, SSL_AES256|SSL_AES256GCM, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_AES, 0,     0, 0, SSL_AES, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_AES_GCM, 0, 0, 0, SSL_AES128GCM|SSL_AES256GCM, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_CAMELLIA128, 0, 0, 0, SSL_CAMELLIA128, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_CAMELLIA256, 0, 0, 0, SSL_CAMELLIA256, 0, 0, 0, 0, 0, 0},
	{0, SSL_TXT_CAMELLIA   , 0, 0, 0, SSL_CAMELLIA128|SSL_CAMELLIA256, 0, 0, 0, 0, 0, 0},

d482 29
a510 8
	{0, SSL_TXT_MD5, 0,     0, 0, 0, SSL_MD5,   0, 0, 0, 0, 0},
	{0, SSL_TXT_SHA1, 0,    0, 0, 0, SSL_SHA1,  0, 0, 0, 0, 0},
	{0, SSL_TXT_SHA, 0,     0, 0, 0, SSL_SHA1,  0, 0, 0, 0, 0},
	{0, SSL_TXT_GOST94, 0,     0, 0, 0, SSL_GOST94,  0, 0, 0, 0, 0},
	{0, SSL_TXT_GOST89MAC, 0,     0, 0, 0, SSL_GOST89MAC,  0, 0, 0, 0, 0},
	{0, SSL_TXT_SHA256, 0,    0, 0, 0, SSL_SHA256,  0, 0, 0, 0, 0},
	{0, SSL_TXT_SHA384, 0,    0, 0, 0, SSL_SHA384,  0, 0, 0, 0, 0},

d512 17
a528 5
	{0, SSL_TXT_SSLV2, 0,   0, 0, 0, 0, SSL_SSLV2, 0, 0, 0, 0},
	{0, SSL_TXT_SSLV3, 0,   0, 0, 0, 0, SSL_SSLV3, 0, 0, 0, 0},
	{0, SSL_TXT_TLSV1, 0,   0, 0, 0, 0, SSL_TLSV1, 0, 0, 0, 0},
	{0, SSL_TXT_TLSV1_2, 0, 0, 0, 0, 0, SSL_TLSV1_2, 0, 0, 0, 0},

d530 30
a559 2
	{0, SSL_TXT_EXP, 0,     0, 0, 0, 0, 0, SSL_EXPORT, 0, 0, 0},
	{0, SSL_TXT_EXPORT, 0,  0, 0, 0, 0, 0, SSL_EXPORT, 0, 0, 0},
a560 6
	/* strength classes */
	{0, SSL_TXT_EXP40, 0,   0, 0, 0, 0, 0, SSL_EXP40, 0, 0, 0},
	{0, SSL_TXT_EXP56, 0,   0, 0, 0, 0, 0, SSL_EXP56, 0, 0, 0},
	{0, SSL_TXT_LOW, 0,     0, 0, 0, 0, 0, SSL_LOW,   0, 0, 0},
	{0, SSL_TXT_MEDIUM, 0,  0, 0, 0, 0, 0, SSL_MEDIUM, 0, 0, 0},
	{0, SSL_TXT_HIGH, 0,    0, 0, 0, 0, 0, SSL_HIGH,  0, 0, 0},
d562 5
a566 1
	{0, SSL_TXT_FIPS, 0,    0, 0,~SSL_eNULL, 0, 0, SSL_FIPS,  0, 0, 0},
d568 1
@


1.48
log
@unidef DH, ECDH, and ECDSA. there's no purpose to a libssl without them.
ok deraadt jsing
@
text
@d1041 2
a1042 3
ssl_cipher_process_rulestr(const char *rule_str,
    CIPHER_ORDER **head_p, CIPHER_ORDER **tail_p,
const SSL_CIPHER **ca_list)
d1044 2
a1045 2
	unsigned long alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl, algo_strength;
	const char *l, *buf;
d1048 1
d1058 3
a1060 3
		/* done */
		if (ch == '-')
				{ rule = CIPHER_DEL;
d1062 2
a1063 2
		} else if (ch == '+')
			{ rule = CIPHER_ORD;
d1065 2
a1066 2
		} else if (ch == '!')
			{ rule = CIPHER_KILL;
d1068 2
a1069 2
		} else if (ch == '@@')
			{ rule = CIPHER_SPECIAL;
d1071 2
a1072 2
		} else
				{ rule = CIPHER_ADD;
d1094 1
a1094 2
			    (ch == '-') || (ch == '.'))
			{
d1106 1
a1106 1
				SSL_R_INVALID_COMMAND);
d1113 4
a1116 2
				found = 0; /* unused -- avoid compiler warning */
				break;	/* special treatment */
d1127 10
a1136 9
			 * Now search for the cipher alias in the ca_list. Be careful
			 * with the strncmp, because the "buflen" limitation
			 * will make the rule "ADH:SOME" and the cipher
			 * "ADH-MY-CIPHER" look like a match for buflen=3.
			 * So additionally check whether the cipher name found
			 * has the correct length. We can save a strlen() call:
			 * just checking for the '\0' at the right place is
			 * sufficient, we have to strncmp() anyway. (We cannot
			 * use strcmp(), because buf is not '\0' terminated.)
d1198 3
a1200 1
					algo_strength &= (ca_list[j]->algo_strength & SSL_EXP_MASK) | ~SSL_EXP_MASK;
d1206 3
a1208 1
					algo_strength |= ca_list[j]->algo_strength & SSL_EXP_MASK;
d1213 5
a1217 2
					algo_strength &= (ca_list[j]->algo_strength & SSL_STRONG_MASK) | ~SSL_STRONG_MASK;
					if (!(algo_strength & SSL_STRONG_MASK)) {
d1222 3
a1224 1
					algo_strength |= ca_list[j]->algo_strength & SSL_STRONG_MASK;
d1228 5
a1232 3
				/* explicit ciphersuite found; its protocol version
				 * does not become part of the search pattern!*/

d1235 5
a1239 3
				/* not an explicit ciphersuite; only in this case, the
				 * protocol version is considered part of the search pattern */

d1242 2
a1243 1
						alg_ssl &= ca_list[j]->algorithm_ssl;
d1249 2
a1250 1
						alg_ssl = ca_list[j]->algorithm_ssl;
d1261 2
a1262 2
		if (rule == CIPHER_SPECIAL)
		{	/* special command */
d1264 2
a1265 3
			if ((buflen == 8) &&
				!strncmp(buf, "STRENGTH", 8))
			ok = ssl_cipher_strength_sort(head_p, tail_p);
d1268 1
a1268 1
			SSL_R_INVALID_COMMAND);
d1278 1
a1278 1
			l++;
d1280 3
a1282 3
			ssl_cipher_apply_rule(cipher_id,
			alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl, algo_strength,
			rule, -1, head_p, tail_p);
d1285 1
a1285 3
			l++;
		}
		if (*l == '\0') break; /* done */
d1287 3
@


1.47
log
@repair KNF indent
@
text
@a710 4
#ifdef OPENSSL_NO_DH
	*mkey |= SSL_kDHr|SSL_kDHd|SSL_kEDH;
	*auth |= SSL_aDH;
#endif
a712 7
#ifdef OPENSSL_NO_ECDSA
	*auth |= SSL_aECDSA;
#endif
#ifdef OPENSSL_NO_ECDH
	*mkey |= SSL_kECDHe|SSL_kECDHr;
	*auth |= SSL_aECDH;
#endif
@


1.46
log
@Wrap some long lines.
@
text
@d1622 1
a1622 1
	return("Buffer too small");
@


1.45
log
@Remove MemCheck_{on,off} that escaped last time around.
@
text
@d1734 2
a1735 1
		SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD, SSL_R_COMPRESSION_ID_NOT_WITHIN_PRIVATE_RANGE);
d1741 2
a1742 1
		SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD, ERR_R_MALLOC_FAILURE);
d1751 2
a1752 1
		SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD, SSL_R_DUPLICATE_COMPRESSION_ID);
d1757 2
a1758 1
		SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD, ERR_R_MALLOC_FAILURE);
@


1.44
log
@More KNF.
@
text
@a1737 1
	MemCheck_off();
a1748 1
		MemCheck_on();
a1753 1
		MemCheck_on();
a1756 1
		MemCheck_on();
@


1.43
log
@Unchecked malloc() return value in SSL_COMP_add_compression_method(), in the
!OPENSSL_NO_COMP case. Does not affect OpenBSD as we compile the opposite code
path.
@
text
@d1410 2
a1411 2
	if (!ok)
			{	/* Rule processing failure */
@


1.42
log
@Remove TLS_DEBUG, SSL_DEBUG, CIPHER_DEBUG and OPENSSL_RI_DEBUG. Much of
this is sporadic, hacked up and can easily be put back in an improved form
should we ever need it.

ok miod@@
@
text
@d1740 4
@


1.41
log
@Turn off MemCheck_on and MemCheck_off. These calls are pointless since the
crypto memory debugging code has been castrated.

ok miod@@ "kill it" beck@@
@
text
@a908 4
#ifdef CIPHER_DEBUG
	printf("Applying rule %d with %08lx/%08lx/%08lx/%08lx/%08lx %08lx (%d)\n",
	rule, alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl, algo_strength, strength_bits);
#endif
a940 3
#ifdef CIPHER_DEBUG
			printf("\nName: %s:\nAlgo = %08lx/%08lx/%08lx/%08lx/%08lx Algo_strength = %08lx\n", cp->name, cp->algorithm_mkey, cp->algorithm_auth, cp->algorithm_enc, cp->algorithm_mac, cp->algorithm_ssl, cp->algo_strength);
#endif
a957 3
#ifdef CIPHER_DEBUG
		printf("Action = %d\n", rule);
#endif
a1431 3
#ifdef CIPHER_DEBUG
			printf("<%s>\n", curr->cipher->name);
#endif
@


1.40
log
@The ssl_ciper_get_evp() function is currently overloaded to also return the
compression associated with the SSL session. Based on one of Adam Langley's
chromium diffs, factor out the compression handling code into a separate
ssl_cipher_get_comp() function.

Rewrite the compression handling code to avoid pointless duplication and so
that failures are actually returned to and detectable by the caller.

ok miod@@
@
text
@a455 1
			MemCheck_off();
a471 1
			MemCheck_on();
@


1.39
log
@In ssl_cipher_get_evp(), fix off-by-one in index validation before accessing
arrays.

"kind of scary" deraadt@@, ok guenther@@
@
text
@d484 28
d514 1
a514 1
    const EVP_MD **md, int *mac_pkey_type, int *mac_secret_size, SSL_COMP **comp)
d516 1
a517 1
	const SSL_CIPHER *c;
a521 16
	if (comp != NULL) {
		SSL_COMP ctmp;
#ifndef OPENSSL_NO_COMP
		load_builtin_compressions();
#endif

		*comp = NULL;
		ctmp.id = s->compress_meth;
		if (ssl_comp_methods != NULL) {
			i = sk_SSL_COMP_find(ssl_comp_methods, &ctmp);
			if (i >= 0)
				*comp = sk_SSL_COMP_value(ssl_comp_methods, i);
			else
				*comp = NULL;
		}
	}
a746 2


d1697 2
a1698 2
	if ((n == 0)
		|| (sk == NULL)) return (NULL);
@


1.38
log
@KSSL is dead... nuke KSSL_DEBUG from orbit.

ok beck@@ miod@@
@
text
@d562 1
a562 1
	if ((i < 0) || (i > SSL_ENC_NUM_IDX))
d594 1
a594 1
	if ((i < 0) || (i > SSL_MD_NUM_IDX)) {
@


1.37
log
@Remove SRP and Kerberos support from libssl. These are complex protocols
all on their own and we can't effectively maintain them without using them,
which we don't. If the need arises, the code can be resurrected.
@
text
@a794 3
#ifdef KSSL_DEBUG
			printf("\t%d: %s %lx %lx %lx\n", i, c->name, c->id, c->algorithm_mkey, c->algorithm_auth);
#endif	/* KSSL_DEBUG */
a1320 3
#ifdef KSSL_DEBUG
	printf("ssl_create_cipher_list() for %d ciphers\n", num_of_ciphers);
#endif    /* KSSL_DEBUG */
a1464 3
#ifdef KSSL_DEBUG
	static const char *format="%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s%s AL=%lx/%lx/%lx/%lx/%lx\n";
#else
a1465 1
#endif /* KSSL_DEBUG */
a1628 3
#ifdef KSSL_DEBUG
	l = snprintf(buf, len, format, cipher->name, ver, kx, au, enc, mac, exp_str, alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl);
#else
a1629 1
#endif /* KSSL_DEBUG */
@


1.36
log
@switch to reallocarray
@
text
@a704 1
#ifdef OPENSSL_NO_KRB5
a706 1
#endif
a717 1
#ifdef OPENSSL_NO_SRP
a718 1
#endif
@


1.35
log
@use mallocarray(a,b) instead of malloc(a*b)
@
text
@d1331 1
a1331 1
	co_list = mallocarray(num_of_ciphers, sizeof(CIPHER_ORDER));
d1393 1
a1393 1
	ca_list = mallocarray(num_of_alias_max, sizeof(SSL_CIPHER *));
@


1.34
log
@more malloc/realloc/calloc cleanups; ok beck kettenis
@
text
@d1331 1
a1331 1
	co_list = (CIPHER_ORDER *)malloc(sizeof(CIPHER_ORDER) * num_of_ciphers);
d1393 1
a1393 1
	ca_list = malloc(sizeof(SSL_CIPHER *) * num_of_alias_max);
@


1.33
log
@Use calloc(a,b) instead of malloc(a*b) + memset(a*b).  I don't know if
this instance is integer-overflowable, but we cannot keep hand-auditing
every instance (or apathetically ignoring these issues) when the simple
calloc idiom is better in the presence of a good calloc().  It is simply
unfeasible to always enter correct range checks before the aggregate
size calculation, just go find some 4000 lines of code, REPAIR THEM ALL,
then come back and tell me I am wrong.

This only works on systems where calloc() does the integer overflow
check, but if your system doesn't do this, you need to ask your vendor
WHY THEY ARE 10 YEARS BEHIND IN BEST PRACTICE?  This is the kind of
problem that needs to be solved at the right layer.

malloc integer-overflow was implicated in the 2002 OpenSSH hole.  OpenSSH
and much other code is now written to use calloc(), for instance OpenSSH
has 103 calls to it.  We feel safer with our use of calloc().  It is a
natural approach for us to use calloc().  How safe do you feel on systems
which lack that range check in their calloc()?

Good writeup from 2006: http://undeadly.org/cgi?action=article&sid=20060330071917
@
text
@d459 1
a459 1
				comp = (SSL_COMP *)malloc(sizeof(SSL_COMP));
d1762 1
a1762 1
	comp = (SSL_COMP *)malloc(sizeof(SSL_COMP));
@


1.32
log
@More KNF and style consistency tweaks
@
text
@d1033 1
a1033 1
	number_uses = malloc((max_strength_bits + 1) * sizeof(int));
a1037 1
	memset(number_uses, 0, (max_strength_bits + 1) * sizeof(int));
@


1.31
log
@always build in RSA and DSA. ok deraadt miod
@
text
@d1298 2
a1299 2
STACK_OF(SSL_CIPHER)
*ssl_create_cipher_list(const SSL_METHOD *ssl_method,
d1469 2
a1470 2
char
*SSL_CIPHER_description(const SSL_CIPHER *cipher, char *buf, int len)
d1655 2
a1656 2
char
*SSL_CIPHER_get_version(const SSL_CIPHER *c)
d1672 2
a1673 2
const char
*SSL_CIPHER_get_name(const SSL_CIPHER *c)
d1700 2
a1701 2
SSL_COMP
*ssl3_comp_find(STACK_OF(SSL_COMP) *sk, int n)
d1718 2
a1719 2
void
*SSL_COMP_get_compression_methods(void)
d1730 2
a1731 2
const char
*SSL_COMP_get_name(const void *comp)
d1736 2
a1737 2
STACK_OF(SSL_COMP)
*SSL_COMP_get_compression_methods(void)
d1785 2
a1786 2
const char
*SSL_COMP_get_name(const COMP_METHOD *comp)
@


1.30
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a698 7
#ifdef OPENSSL_NO_RSA
	*mkey |= SSL_kRSA;
	*auth |= SSL_aRSA;
#endif
#ifdef OPENSSL_NO_DSA
	*auth |= SSL_aDSS;
#endif
@


1.29
log
@add back SRP. i was being too greedy.
@
text
@d459 1
a459 1
				comp = (SSL_COMP *)OPENSSL_malloc(sizeof(SSL_COMP));
d464 1
a464 1
						OPENSSL_free(comp);
d1040 1
a1040 1
	number_uses = OPENSSL_malloc((max_strength_bits + 1) * sizeof(int));
d1064 1
a1064 1
	OPENSSL_free(number_uses);
d1339 1
a1339 1
	co_list = (CIPHER_ORDER *)OPENSSL_malloc(sizeof(CIPHER_ORDER) * num_of_ciphers);
d1383 1
a1383 1
		OPENSSL_free(co_list);
d1401 1
a1401 1
	ca_list = OPENSSL_malloc(sizeof(SSL_CIPHER *) * num_of_alias_max);
d1403 1
a1403 1
		OPENSSL_free(co_list);
d1428 1
a1428 1
	OPENSSL_free((void *)ca_list);	/* Not needed anymore */
d1432 1
a1432 1
		OPENSSL_free(co_list);
d1441 1
a1441 1
		OPENSSL_free(co_list);
d1457 1
a1457 1
	OPENSSL_free(co_list);	/* Not needed any longer */
d1645 1
a1645 1
		buf = OPENSSL_malloc(len);
d1647 1
a1647 1
			return("OPENSSL_malloc Error");
d1770 1
a1770 1
	comp = (SSL_COMP *)OPENSSL_malloc(sizeof(SSL_COMP));
d1776 1
a1776 1
		OPENSSL_free(comp);
d1782 1
a1782 1
		OPENSSL_free(comp);
@


1.28
log
@disentangle SRP code from TLS
@
text
@d727 1
d729 1
@


1.27
log
@repair some whitespace
@
text
@a726 1
#ifdef OPENSSL_NO_SRP
a727 1
#endif
@


1.26
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok miod
@
text
@d462 3
a464 3
					if (comp->method
						&& comp->method->type == NID_undef)
					OPENSSL_free(comp);
d511 2
a512 2
	if ((enc == NULL)
		|| (md == NULL)) return (0);
d612 2
a613 2
		(*md != NULL || (EVP_CIPHER_flags(*enc)&EVP_CIPH_FLAG_AEAD_CIPHER)) &&
	(!mac_pkey_type || *mac_pkey_type != NID_undef)) {
d617 2
a618 2
			s->ssl_version < TLS1_VERSION)
		return 1;
d621 3
a623 3
			c->algorithm_mac == SSL_MD5 &&
		(evp = EVP_get_cipherbyname("RC4-HMAC-MD5")))
		*enc = evp, *md = NULL;
d625 3
a627 3
			c->algorithm_mac == SSL_SHA1 &&
		(evp = EVP_get_cipherbyname("AES-128-CBC-HMAC-SHA1")))
		*enc = evp, *md = NULL;
d629 3
a631 3
			c->algorithm_mac == SSL_SHA1 &&
		(evp = EVP_get_cipherbyname("AES-256-CBC-HMAC-SHA1")))
		*enc = evp, *md = NULL;
d796 5
a800 5
		!(c->algorithm_mkey & disabled_mkey) &&
		!(c->algorithm_auth & disabled_auth) &&
		!(c->algorithm_enc & disabled_enc) &&
		!(c->algorithm_mac & disabled_mac) &&
		!(c->algorithm_ssl & disabled_ssl)) {
d840 2
a841 3
ssl_cipher_collect_aliases(const SSL_CIPHER **ca_list,
    int num_of_group_aliases,
unsigned long disabled_mkey, unsigned long disabled_auth,
d843 1
a843 2
unsigned long disabled_ssl,
    CIPHER_ORDER *head)
d906 4
a909 7
ssl_cipher_apply_rule(unsigned long cipher_id,
    unsigned long alg_mkey, unsigned long alg_auth,
unsigned long alg_enc, unsigned long alg_mac,
    unsigned long alg_ssl,
unsigned long algo_strength,
    int rule, int strength_bits,
CIPHER_ORDER **head_p, CIPHER_ORDER **tail_p)
d1021 1
a1021 2
ssl_cipher_strength_sort(CIPHER_ORDER **head_p,
    CIPHER_ORDER **tail_p)
d1035 2
a1036 2
			(curr->cipher->strength_bits > max_strength_bits))
		max_strength_bits = curr->cipher->strength_bits;
d1120 3
a1122 3
			((ch >= '0') && (ch <= '9')) ||
			((ch >= 'a') && (ch <= 'z')) ||
			(ch == '-') || (ch == '.'))
d1168 1
a1168 1
					(ca_list[j]->name[buflen] == '\0')) {
d1273 1
a1273 1
				{	/* special command */
d1307 1
a1307 1
STACK_OF(SSL_CIPHER) **cipher_list,
d1309 1
a1309 1
const char *rule_str)
d1774 2
a1775 2
	if (ssl_comp_methods
		&& sk_SSL_COMP_find(ssl_comp_methods, comp) >= 0) {
d1780 2
a1781 2
	} else if ((ssl_comp_methods == NULL)
	|| !sk_SSL_COMP_push(ssl_comp_methods, comp)) {
@


1.25
log
@Send the rotIBM stream cipher (ebcdic) to Valhalla to party for eternity
with the bearded ones...
some API's that nobody should be using will dissapear with this commit.
@
text
@a619 5
#ifdef OPENSSL_FIPS
		if (FIPS_mode())
			return 1;
#endif

a795 3
#ifdef OPENSSL_FIPS
		(!FIPS_mode() || (c->algo_strength & SSL_FIPS)) &&
#endif
d1456 1
a1456 6
#ifdef OPENSSL_FIPS
		if (curr->active && (!FIPS_mode() || curr->cipher->algo_strength & SSL_FIPS))
#else
		if (curr->active)
#endif
		{
@


1.24
log
@Flense all use of BIO_snprintf from ssl source - use the real one instead,
and allow for the normal posix mandated return values instead of the
nonstandard one from BIO_snprintf.
ok miod@@
@
text
@a1132 1
#ifndef CHARSET_EBCDIC
a1136 3
#else
			while (isalnum(ch) || (ch == '-') || (ch == '.'))
#endif
@


1.23
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@d1502 1
a1502 1
	int is_export, pkl, kl;
d1675 1
a1675 1
	BIO_snprintf(buf, len, format, cipher->name, ver, kx, au, enc, mac, exp_str, alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl);
d1677 1
a1677 1
	BIO_snprintf(buf, len, format, cipher->name, ver, kx, au, enc, mac, exp_str);
d1679 4
a1682 1
	return (buf);
@


1.22
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d170 3
a172 3
static const EVP_CIPHER *ssl_cipher_methods[SSL_ENC_NUM_IDX]={
	NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL
	};
d178 1
a178 1
static STACK_OF(SSL_COMP) *ssl_comp_methods=NULL;
d190 3
a192 3
static const EVP_MD *ssl_digest_methods[SSL_MD_NUM_IDX]={
	NULL,NULL,NULL,NULL,NULL,NULL
	};
d197 8
a204 8
static int  ssl_mac_pkey_id[SSL_MD_NUM_IDX]={
	EVP_PKEY_HMAC,EVP_PKEY_HMAC,EVP_PKEY_HMAC,NID_undef,
	EVP_PKEY_HMAC,EVP_PKEY_HMAC
	};

static int ssl_mac_secret_size[SSL_MD_NUM_IDX]={
	0,0,0,0,0,0
	};
d206 2
a207 2
static int ssl_handshake_digest_flag[SSL_MD_NUM_IDX]={
	SSL_HANDSHAKE_MAC_MD5,SSL_HANDSHAKE_MAC_SHA,
d210 1
a210 1
	};
d218 1
a218 2
typedef struct cipher_order_st
	{
d222 2
a223 2
	struct cipher_order_st *next,*prev;
	} CIPHER_ORDER;
d225 1
a225 1
static const SSL_CIPHER cipher_aliases[]={
d227 1
a227 1
	{0,SSL_TXT_ALL,0,     0,0,~SSL_eNULL,0,0,0,0,0,0},
d229 1
a229 1
	{0,SSL_TXT_CMPALL,0,  0,0,SSL_eNULL,0,0,0,0,0,0},
d232 1
a232 1
	{0,SSL_TXT_CMPDEF,0,  SSL_kEDH|SSL_kEECDH,SSL_aNULL,~SSL_eNULL,0,0,0,0,0,0},
d238 1
a238 1
	{0,SSL_TXT_kRSA,0,    SSL_kRSA,  0,0,0,0,0,0,0,0},
d243 2
a244 2
	{0,SSL_TXT_kEDH,0,    SSL_kEDH,  0,0,0,0,0,0,0,0},
	{0,SSL_TXT_DH,0,      SSL_kDHr|SSL_kDHd|SSL_kEDH,0,0,0,0,0,0,0,0},
d246 1
a246 1
	{0,SSL_TXT_kKRB5,0,   SSL_kKRB5, 0,0,0,0,0,0,0,0},
d248 9
a256 9
	{0,SSL_TXT_kECDHr,0,  SSL_kECDHr,0,0,0,0,0,0,0,0},
	{0,SSL_TXT_kECDHe,0,  SSL_kECDHe,0,0,0,0,0,0,0,0},
	{0,SSL_TXT_kECDH,0,   SSL_kECDHr|SSL_kECDHe,0,0,0,0,0,0,0,0},
	{0,SSL_TXT_kEECDH,0,  SSL_kEECDH,0,0,0,0,0,0,0,0},
	{0,SSL_TXT_ECDH,0,    SSL_kECDHr|SSL_kECDHe|SSL_kEECDH,0,0,0,0,0,0,0,0},

        {0,SSL_TXT_kPSK,0,    SSL_kPSK,  0,0,0,0,0,0,0,0},
	{0,SSL_TXT_kSRP,0,    SSL_kSRP,  0,0,0,0,0,0,0,0},
	{0,SSL_TXT_kGOST,0, SSL_kGOST,0,0,0,0,0,0,0,0},
d259 5
a263 5
	{0,SSL_TXT_aRSA,0,    0,SSL_aRSA,  0,0,0,0,0,0,0},
	{0,SSL_TXT_aDSS,0,    0,SSL_aDSS,  0,0,0,0,0,0,0},
	{0,SSL_TXT_DSS,0,     0,SSL_aDSS,   0,0,0,0,0,0,0},
	{0,SSL_TXT_aKRB5,0,   0,SSL_aKRB5, 0,0,0,0,0,0,0},
	{0,SSL_TXT_aNULL,0,   0,SSL_aNULL, 0,0,0,0,0,0,0},
d265 7
a271 7
	{0,SSL_TXT_aECDH,0,   0,SSL_aECDH, 0,0,0,0,0,0,0},
	{0,SSL_TXT_aECDSA,0,  0,SSL_aECDSA,0,0,0,0,0,0,0},
	{0,SSL_TXT_ECDSA,0,   0,SSL_aECDSA, 0,0,0,0,0,0,0},
        {0,SSL_TXT_aPSK,0,    0,SSL_aPSK,  0,0,0,0,0,0,0},
	{0,SSL_TXT_aGOST94,0,0,SSL_aGOST94,0,0,0,0,0,0,0},
	{0,SSL_TXT_aGOST01,0,0,SSL_aGOST01,0,0,0,0,0,0,0},
	{0,SSL_TXT_aGOST,0,0,SSL_aGOST94|SSL_aGOST01,0,0,0,0,0,0,0},
d274 9
a282 9
	{0,SSL_TXT_EDH,0,     SSL_kEDH,~SSL_aNULL,0,0,0,0,0,0,0},
	{0,SSL_TXT_EECDH,0,   SSL_kEECDH,~SSL_aNULL,0,0,0,0,0,0,0},
	{0,SSL_TXT_NULL,0,    0,0,SSL_eNULL, 0,0,0,0,0,0},
	{0,SSL_TXT_KRB5,0,    SSL_kKRB5,SSL_aKRB5,0,0,0,0,0,0,0},
	{0,SSL_TXT_RSA,0,     SSL_kRSA,SSL_aRSA,0,0,0,0,0,0,0},
	{0,SSL_TXT_ADH,0,     SSL_kEDH,SSL_aNULL,0,0,0,0,0,0,0},
	{0,SSL_TXT_AECDH,0,   SSL_kEECDH,SSL_aNULL,0,0,0,0,0,0,0},
        {0,SSL_TXT_PSK,0,     SSL_kPSK,SSL_aPSK,0,0,0,0,0,0,0},
	{0,SSL_TXT_SRP,0,     SSL_kSRP,0,0,0,0,0,0,0,0},
d286 23
a308 23
	{0,SSL_TXT_DES,0,     0,0,SSL_DES,   0,0,0,0,0,0},
	{0,SSL_TXT_3DES,0,    0,0,SSL_3DES,  0,0,0,0,0,0},
	{0,SSL_TXT_RC4,0,     0,0,SSL_RC4,   0,0,0,0,0,0},
	{0,SSL_TXT_RC2,0,     0,0,SSL_RC2,   0,0,0,0,0,0},
	{0,SSL_TXT_IDEA,0,    0,0,SSL_IDEA,  0,0,0,0,0,0},
	{0,SSL_TXT_SEED,0,    0,0,SSL_SEED,  0,0,0,0,0,0},
	{0,SSL_TXT_eNULL,0,   0,0,SSL_eNULL, 0,0,0,0,0,0},
	{0,SSL_TXT_AES128,0,  0,0,SSL_AES128|SSL_AES128GCM,0,0,0,0,0,0},
	{0,SSL_TXT_AES256,0,  0,0,SSL_AES256|SSL_AES256GCM,0,0,0,0,0,0},
	{0,SSL_TXT_AES,0,     0,0,SSL_AES,0,0,0,0,0,0},
	{0,SSL_TXT_AES_GCM,0, 0,0,SSL_AES128GCM|SSL_AES256GCM,0,0,0,0,0,0},
	{0,SSL_TXT_CAMELLIA128,0,0,0,SSL_CAMELLIA128,0,0,0,0,0,0},
	{0,SSL_TXT_CAMELLIA256,0,0,0,SSL_CAMELLIA256,0,0,0,0,0,0},
	{0,SSL_TXT_CAMELLIA   ,0,0,0,SSL_CAMELLIA128|SSL_CAMELLIA256,0,0,0,0,0,0},

	/* MAC aliases */	
	{0,SSL_TXT_MD5,0,     0,0,0,SSL_MD5,   0,0,0,0,0},
	{0,SSL_TXT_SHA1,0,    0,0,0,SSL_SHA1,  0,0,0,0,0},
	{0,SSL_TXT_SHA,0,     0,0,0,SSL_SHA1,  0,0,0,0,0},
	{0,SSL_TXT_GOST94,0,     0,0,0,SSL_GOST94,  0,0,0,0,0},
	{0,SSL_TXT_GOST89MAC,0,     0,0,0,SSL_GOST89MAC,  0,0,0,0,0},
	{0,SSL_TXT_SHA256,0,    0,0,0,SSL_SHA256,  0,0,0,0,0},
	{0,SSL_TXT_SHA384,0,    0,0,0,SSL_SHA384,  0,0,0,0,0},
d311 4
a314 4
	{0,SSL_TXT_SSLV2,0,   0,0,0,0,SSL_SSLV2, 0,0,0,0},
	{0,SSL_TXT_SSLV3,0,   0,0,0,0,SSL_SSLV3, 0,0,0,0},
	{0,SSL_TXT_TLSV1,0,   0,0,0,0,SSL_TLSV1, 0,0,0,0},
	{0,SSL_TXT_TLSV1_2,0, 0,0,0,0,SSL_TLSV1_2, 0,0,0,0},
d317 2
a318 2
	{0,SSL_TXT_EXP,0,     0,0,0,0,0,SSL_EXPORT,0,0,0},
	{0,SSL_TXT_EXPORT,0,  0,0,0,0,0,SSL_EXPORT,0,0,0},
d321 5
a325 5
	{0,SSL_TXT_EXP40,0,   0,0,0,0,0,SSL_EXP40, 0,0,0},
	{0,SSL_TXT_EXP56,0,   0,0,0,0,0,SSL_EXP56, 0,0,0},
	{0,SSL_TXT_LOW,0,     0,0,0,0,0,SSL_LOW,   0,0,0},
	{0,SSL_TXT_MEDIUM,0,  0,0,0,0,0,SSL_MEDIUM,0,0,0},
	{0,SSL_TXT_HIGH,0,    0,0,0,0,0,SSL_HIGH,  0,0,0},
d327 2
a328 2
	{0,SSL_TXT_FIPS,0,    0,0,~SSL_eNULL,0,0,SSL_FIPS,  0,0,0},
	};
d334 3
a336 2
static int get_optional_pkey_id(const char *pkey_name)
	{
d338 5
a342 6
	int pkey_id=0;
	ameth = EVP_PKEY_asn1_find_str(NULL,pkey_name,-1);
	if (ameth) 
		{
		EVP_PKEY_asn1_get0_info(&pkey_id, NULL,NULL,NULL,NULL,ameth);
		}		
d344 1
a344 1
	}
d348 3
a350 2
static int get_optional_pkey_id(const char *pkey_name)
	{
d353 7
a359 7
	int pkey_id=0;
	ameth = EVP_PKEY_asn1_find_str(&tmpeng,pkey_name,-1);
	if (ameth)
		{
		EVP_PKEY_asn1_get0_info(&pkey_id, NULL,NULL,NULL,NULL,ameth);
		}
	if (tmpeng) ENGINE_finish(tmpeng);
d361 1
a361 1
	}
d365 5
a369 4
void ssl_load_ciphers(void)
	{
	ssl_cipher_methods[SSL_ENC_DES_IDX]= 
		EVP_get_cipherbyname(SN_des_cbc);
d371 1
a371 1
		EVP_get_cipherbyname(SN_des_ede3_cbc);
d373 3
a375 3
		EVP_get_cipherbyname(SN_rc4);
	ssl_cipher_methods[SSL_ENC_RC2_IDX]= 
		EVP_get_cipherbyname(SN_rc2_cbc);
d377 2
a378 2
	ssl_cipher_methods[SSL_ENC_IDEA_IDX]= 
		EVP_get_cipherbyname(SN_idea_cbc);
d380 1
a380 1
	ssl_cipher_methods[SSL_ENC_IDEA_IDX]= NULL;
d383 1
a383 1
	  EVP_get_cipherbyname(SN_aes_128_cbc);
d385 1
a385 1
	  EVP_get_cipherbyname(SN_aes_256_cbc);
d387 1
a387 1
	  EVP_get_cipherbyname(SN_camellia_128_cbc);
d389 1
a389 1
	  EVP_get_cipherbyname(SN_camellia_256_cbc);
d391 1
a391 1
	  EVP_get_cipherbyname(SN_gost89_cnt);
d393 1
a393 1
	  EVP_get_cipherbyname(SN_seed_cbc);
d396 1
a396 1
	  EVP_get_cipherbyname(SN_aes_128_gcm);
d398 1
a398 1
	  EVP_get_cipherbyname(SN_aes_256_gcm);
d401 1
a401 1
		EVP_get_digestbyname(SN_md5);
d403 1
a403 1
		EVP_MD_size(ssl_digest_methods[SSL_MD_MD5_IDX]);
d406 1
a406 1
		EVP_get_digestbyname(SN_sha1);
d408 1
a408 1
		EVP_MD_size(ssl_digest_methods[SSL_MD_SHA1_IDX]);
d411 2
a412 3
		EVP_get_digestbyname(SN_id_GostR3411_94);
	if (ssl_digest_methods[SSL_MD_GOST94_IDX])
		{	
d414 1
a414 1
			EVP_MD_size(ssl_digest_methods[SSL_MD_GOST94_IDX]);
d416 1
a416 1
		}
d418 5
a422 5
		EVP_get_digestbyname(SN_id_Gost28147_89_MAC);
		ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX] = get_optional_pkey_id("gost-mac");
		if (ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX]) {
			ssl_mac_secret_size[SSL_MD_GOST89MAC_IDX]=32;
		}		
d425 1
a425 1
		EVP_get_digestbyname(SN_sha256);
d427 1
a427 1
		EVP_MD_size(ssl_digest_methods[SSL_MD_SHA256_IDX]);
d429 1
a429 1
		EVP_get_digestbyname(SN_sha384);
d431 2
a432 2
		EVP_MD_size(ssl_digest_methods[SSL_MD_SHA384_IDX]);
	}
d435 6
a440 5
static int sk_comp_cmp(const SSL_COMP * const *a,
			const SSL_COMP * const *b)
	{
	return((*a)->id-(*b)->id);
	}
d442 3
a444 2
static void load_builtin_compressions(void)
	{
d448 1
a448 2
	if (ssl_comp_methods == NULL)
		{
d452 2
a453 3
		
		if (ssl_comp_methods == NULL)
			{
d457 5
a461 7
			ssl_comp_methods=sk_SSL_COMP_new(sk_comp_cmp);
			if (ssl_comp_methods != NULL)
				{
				comp=(SSL_COMP *)OPENSSL_malloc(sizeof(SSL_COMP));
				if (comp != NULL)
					{
					comp->method=COMP_zlib();
d464 5
a468 7
						OPENSSL_free(comp);
					else
						{
						comp->id=SSL_COMP_ZLIB_IDX;
						comp->name=comp->method->name;
						sk_SSL_COMP_push(ssl_comp_methods,comp);
						}
a469 1
					sk_SSL_COMP_sort(ssl_comp_methods);
d471 2
a473 1
			}
d475 2
a476 1
	
d481 1
a481 1
	}
d484 4
a487 3
int ssl_cipher_get_evp(const SSL_SESSION *s, const EVP_CIPHER **enc,
	     const EVP_MD **md, int *mac_pkey_type, int *mac_secret_size,SSL_COMP **comp)
	{
d491 4
a494 4
	c=s->cipher;
	if (c == NULL) return(0);
	if (comp != NULL)
		{
d500 4
a503 5
		*comp=NULL;
		ctmp.id=s->compress_meth;
		if (ssl_comp_methods != NULL)
			{
			i=sk_SSL_COMP_find(ssl_comp_methods,&ctmp);
d505 1
a505 1
				*comp=sk_SSL_COMP_value(ssl_comp_methods,i);
d507 1
a507 2
				*comp=NULL;
			}
d509 1
d511 2
a512 1
	if ((enc == NULL) || (md == NULL)) return(0);
d514 1
a514 2
	switch (c->algorithm_enc)
		{
d516 1
a516 1
		i=SSL_ENC_DES_IDX;
d519 1
a519 1
		i=SSL_ENC_3DES_IDX;
d522 1
a522 1
		i=SSL_ENC_RC4_IDX;
d525 1
a525 1
		i=SSL_ENC_RC2_IDX;
d528 1
a528 1
		i=SSL_ENC_IDEA_IDX;
d531 1
a531 1
		i=SSL_ENC_NULL_IDX;
d534 1
a534 1
		i=SSL_ENC_AES128_IDX;
d537 1
a537 1
		i=SSL_ENC_AES256_IDX;
d540 1
a540 1
		i=SSL_ENC_CAMELLIA128_IDX;
d543 1
a543 1
		i=SSL_ENC_CAMELLIA256_IDX;
d546 1
a546 1
		i=SSL_ENC_GOST89_IDX;
d549 1
a549 1
		i=SSL_ENC_SEED_IDX;
d552 1
a552 1
		i=SSL_ENC_AES128GCM_IDX;
d555 1
a555 1
		i=SSL_ENC_AES256GCM_IDX;
d558 1
a558 1
		i= -1;
d560 1
a560 1
		}
d563 2
a564 3
		*enc=NULL;
	else
		{
d566 1
a566 1
			*enc=EVP_enc_null();
d568 2
a569 2
			*enc=ssl_cipher_methods[i];
		}
d571 1
a571 2
	switch (c->algorithm_mac)
		{
d573 1
a573 1
		i=SSL_MD_MD5_IDX;
d576 1
a576 1
		i=SSL_MD_SHA1_IDX;
d579 1
a579 1
		i=SSL_MD_SHA256_IDX;
d582 1
a582 1
		i=SSL_MD_SHA384_IDX;
d591 1
a591 1
		i= -1;
d593 8
a600 6
		}
	if ((i < 0) || (i > SSL_MD_NUM_IDX))
	{
		*md=NULL; 
		if (mac_pkey_type!=NULL) *mac_pkey_type = NID_undef;
		if (mac_secret_size!=NULL) *mac_secret_size = 0;
d603 6
a608 6
	}
	else
	{
		*md=ssl_digest_methods[i];
		if (mac_pkey_type!=NULL) *mac_pkey_type = ssl_mac_pkey_id[i];
		if (mac_secret_size!=NULL) *mac_secret_size = ssl_mac_secret_size[i];
d612 2
a613 3
	    (*md != NULL || (EVP_CIPHER_flags(*enc)&EVP_CIPH_FLAG_AEAD_CIPHER)) &&
	    (!mac_pkey_type||*mac_pkey_type != NID_undef))
		{
d616 3
a618 3
		if (s->ssl_version>>8 != TLS1_VERSION_MAJOR ||
		    s->ssl_version < TLS1_VERSION)
			return 1;
d625 4
a628 4
		if	(c->algorithm_enc == SSL_RC4 &&
			 c->algorithm_mac == SSL_MD5 &&
			 (evp=EVP_get_cipherbyname("RC4-HMAC-MD5")))
			*enc = evp, *md = NULL;
d630 3
a632 3
			 c->algorithm_mac == SSL_SHA1 &&
			 (evp=EVP_get_cipherbyname("AES-128-CBC-HMAC-SHA1")))
			*enc = evp, *md = NULL;
d634 7
a640 8
			 c->algorithm_mac == SSL_SHA1 &&
			 (evp=EVP_get_cipherbyname("AES-256-CBC-HMAC-SHA1")))
			*enc = evp, *md = NULL;
		return(1);
		}
	else
		return(0);
	}
d642 2
a643 1
int ssl_get_handshake_digest(int idx, long *mask, const EVP_MD **md) 
d645 1
a645 2
	if (idx <0||idx>=SSL_MD_NUM_IDX) 
		{
d647 1
a647 1
		}
d659 6
a664 4
static void ll_append_tail(CIPHER_ORDER **head, CIPHER_ORDER *curr,
	     CIPHER_ORDER **tail)
	{
	if (curr == *tail) return;
d666 1
a666 1
		*head=curr->next;
d668 1
a668 1
		curr->prev->next=curr->next;
d670 2
a671 2
		curr->next->prev=curr->prev;
	(*tail)->next=curr;
d673 3
a675 3
	curr->next=NULL;
	*tail=curr;
	}
d677 6
a682 4
static void ll_append_head(CIPHER_ORDER **head, CIPHER_ORDER *curr,
	     CIPHER_ORDER **tail)
	{
	if (curr == *head) return;
d684 1
a684 1
		*tail=curr->prev;
d686 1
a686 1
		curr->next->prev=curr->prev;
d688 2
a689 2
		curr->prev->next=curr->next;
	(*head)->prev=curr;
d691 3
a693 3
	curr->prev=NULL;
	*head=curr;
	}
d695 3
a697 2
static void ssl_cipher_get_disabled(unsigned long *mkey, unsigned long *auth, unsigned long *enc, unsigned long *mac, unsigned long *ssl)
	{
d746 1
a746 1
	}	
a749 1
		
a751 20
	*enc |= (ssl_cipher_methods[SSL_ENC_DES_IDX ] == NULL) ? SSL_DES :0;
	*enc |= (ssl_cipher_methods[SSL_ENC_3DES_IDX] == NULL) ? SSL_3DES:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_RC4_IDX ] == NULL) ? SSL_RC4 :0;
	*enc |= (ssl_cipher_methods[SSL_ENC_RC2_IDX ] == NULL) ? SSL_RC2 :0;
	*enc |= (ssl_cipher_methods[SSL_ENC_IDEA_IDX] == NULL) ? SSL_IDEA:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_AES128_IDX] == NULL) ? SSL_AES128:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_AES256_IDX] == NULL) ? SSL_AES256:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_AES128GCM_IDX] == NULL) ? SSL_AES128GCM:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_AES256GCM_IDX] == NULL) ? SSL_AES256GCM:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_CAMELLIA128_IDX] == NULL) ? SSL_CAMELLIA128:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_CAMELLIA256_IDX] == NULL) ? SSL_CAMELLIA256:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_GOST89_IDX] == NULL) ? SSL_eGOST2814789CNT:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_SEED_IDX] == NULL) ? SSL_SEED:0;

	*mac |= (ssl_digest_methods[SSL_MD_MD5_IDX ] == NULL) ? SSL_MD5 :0;
	*mac |= (ssl_digest_methods[SSL_MD_SHA1_IDX] == NULL) ? SSL_SHA1:0;
	*mac |= (ssl_digest_methods[SSL_MD_SHA256_IDX] == NULL) ? SSL_SHA256:0;
	*mac |= (ssl_digest_methods[SSL_MD_SHA384_IDX] == NULL) ? SSL_SHA384:0;
	*mac |= (ssl_digest_methods[SSL_MD_GOST94_IDX] == NULL) ? SSL_GOST94:0;
	*mac |= (ssl_digest_methods[SSL_MD_GOST89MAC_IDX] == NULL || ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX]==NID_undef)? SSL_GOST89MAC:0;
d753 22
a774 1
	}
d776 9
a784 8
static void ssl_cipher_collect_ciphers(const SSL_METHOD *ssl_method,
                int num_of_ciphers,
                unsigned long disabled_mkey, unsigned long disabled_auth,
                unsigned long disabled_enc, unsigned long disabled_mac,
                unsigned long disabled_ssl,
                CIPHER_ORDER *co_list,
                CIPHER_ORDER **head_p, CIPHER_ORDER **tail_p)
	{
d797 1
a797 2
	for (i = 0; i < num_of_ciphers; i++)
		{
d802 1
a802 1
		    (!FIPS_mode() || (c->algo_strength & SSL_FIPS)) &&
d804 5
a808 6
		    !(c->algorithm_mkey & disabled_mkey) &&
		    !(c->algorithm_auth & disabled_auth) &&
		    !(c->algorithm_enc & disabled_enc) &&
		    !(c->algorithm_mac & disabled_mac) &&
		    !(c->algorithm_ssl & disabled_ssl))
			{
d815 1
a815 1
			printf("\t%d: %s %lx %lx %lx\n",i,c->name,c->id,c->algorithm_mkey,c->algorithm_auth);
a819 1
			}
d821 1
d826 1
a826 2
	if (co_list_num > 0)
		{
d829 1
a829 2
		if (co_list_num > 1)
			{
d831 2
a832 3
			
			for (i = 1; i < co_list_num - 1; i++)
				{
d835 1
a835 1
				}
d838 2
a839 2
			}
		
a843 1
		}
d845 1
d847 8
a854 7
static void ssl_cipher_collect_aliases(const SSL_CIPHER **ca_list,
                        int num_of_group_aliases,
                        unsigned long disabled_mkey, unsigned long disabled_auth,
                        unsigned long disabled_enc, unsigned long disabled_mac,
                        unsigned long disabled_ssl,
			CIPHER_ORDER *head)
	{
d869 1
a869 2
	while (ciph_curr != NULL)
		{
d873 1
a873 1
		}
d881 1
a881 2
	for (i = 0; i < num_of_group_aliases; i++)
		{
d891 1
a891 1
	
d895 1
a895 1
		
d899 1
a899 1
		
d903 1
a903 1
		
d907 1
a907 1
		
d910 1
a910 1
		}
d913 1
a913 1
	}
d915 9
a923 8
static void ssl_cipher_apply_rule(unsigned long cipher_id,
                unsigned long alg_mkey, unsigned long alg_auth,
                unsigned long alg_enc, unsigned long alg_mac,
                unsigned long alg_ssl,
		unsigned long algo_strength,
		int rule, int strength_bits,
		CIPHER_ORDER **head_p, CIPHER_ORDER **tail_p)
	{
d930 1
a930 1
		rule, alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl, algo_strength, strength_bits);
d939 1
a939 2
	if (reverse)
		{
d942 1
a942 3
		}
	else
		{
d945 1
a945 1
		}
d948 3
a950 3
	for (;;)
		{
		if ((curr == NULL) || (curr == last)) break;
d960 1
a960 2
		if (strength_bits >= 0)
			{
d963 1
a963 3
			}
		else
			{
d982 1
a982 1
			}
d989 1
a989 2
		if (rule == CIPHER_ADD)
			{
d991 1
a991 2
			if (!curr->active)
				{
a993 1
				}
d995 1
d997 1
a997 2
		else if (rule == CIPHER_ORD)
			{
d999 1
a999 2
			if (curr->active)
				{
a1000 1
				}
d1002 1
a1002 2
		else if	(rule == CIPHER_DEL)
			{
d1004 1
a1004 2
			if (curr->active)
				{
a1009 1
				}
d1011 1
a1011 2
		else if (rule == CIPHER_KILL)
			{
a1025 1
			}
d1027 1
d1031 1
a1031 1
	}
d1033 4
a1036 3
static int ssl_cipher_strength_sort(CIPHER_ORDER **head_p,
				    CIPHER_ORDER **tail_p)
	{
d1047 1
a1047 2
	while (curr != NULL)
		{
d1049 2
a1050 2
		    (curr->cipher->strength_bits > max_strength_bits))
		    max_strength_bits = curr->cipher->strength_bits;
d1052 1
a1052 1
		}
d1055 4
a1058 5
	if (!number_uses)
		{
		SSLerr(SSL_F_SSL_CIPHER_STRENGTH_SORT,ERR_R_MALLOC_FAILURE);
		return(0);
		}
d1065 1
a1065 2
	while (curr != NULL)
		{
d1069 1
a1069 1
		}
d1079 2
a1080 2
	return(1);
	}
d1082 5
a1086 4
static int ssl_cipher_process_rulestr(const char *rule_str,
                CIPHER_ORDER **head_p, CIPHER_ORDER **tail_p,
                const SSL_CIPHER **ca_list)
	{
d1095 1
a1095 2
	for (;;)
		{
d1099 2
a1100 1
			break;		/* done */
d1102 14
a1115 9
			{ rule = CIPHER_DEL; l++; }
		else if (ch == '+')
			{ rule = CIPHER_ORD; l++; }
		else if (ch == '!')
			{ rule = CIPHER_KILL; l++; }
		else if (ch == '@@')
			{ rule = CIPHER_SPECIAL; l++; }
		else
			{ rule = CIPHER_ADD; }
d1117 1
a1117 2
		if (ITEM_SEP(ch))
			{
d1120 1
a1120 1
			}
d1129 1
a1129 2
		for (;;)
			{
d1134 4
a1137 4
			while (	((ch >= 'A') && (ch <= 'Z')) ||
				((ch >= '0') && (ch <= '9')) ||
				((ch >= 'a') && (ch <= 'z')) ||
				 (ch == '-') || (ch == '.'))
d1139 1
a1139 1
			while (	isalnum(ch) || (ch == '-') || (ch == '.'))
d1141 4
a1144 4
				 {
				 ch = *(++l);
				 buflen++;
				 }
d1146 1
a1146 2
			if (buflen == 0)
				{
d1153 1
a1153 1
				       SSL_R_INVALID_COMMAND);
d1157 1
a1157 1
				}
d1159 1
a1159 2
			if (rule == CIPHER_SPECIAL)
				{
d1162 1
a1162 1
				}
d1165 2
a1166 3
			if (ch == '+')
				{
				multi=1;
d1168 2
a1169 3
				}
			else
				multi=0;
d1184 1
a1184 2
			while (ca_list[j])
				{
d1186 1
a1186 2
				    (ca_list[j]->name[buflen] == '\0'))
					{
d1189 1
a1189 2
					}
				else
d1191 1
a1191 1
				}
d1196 2
a1197 4
			if (ca_list[j]->algorithm_mkey)
				{
				if (alg_mkey)
					{
d1199 3
a1201 1
					if (!alg_mkey) { found = 0; break; }
d1203 1
a1203 1
				else
d1205 1
a1205 1
				}
d1207 2
a1208 4
			if (ca_list[j]->algorithm_auth)
				{
				if (alg_auth)
					{
d1210 3
a1212 1
					if (!alg_auth) { found = 0; break; }
d1214 1
a1214 1
				else
d1216 4
a1219 6
				}
			
			if (ca_list[j]->algorithm_enc)
				{
				if (alg_enc)
					{
d1221 3
a1223 1
					if (!alg_enc) { found = 0; break; }
d1225 1
a1225 1
				else
d1227 4
a1230 6
				}
						
			if (ca_list[j]->algorithm_mac)
				{
				if (alg_mac)
					{
d1232 3
a1234 1
					if (!alg_mac) { found = 0; break; }
d1236 1
a1236 1
				else
d1238 4
a1241 6
				}
			
			if (ca_list[j]->algo_strength & SSL_EXP_MASK)
				{
				if (algo_strength & SSL_EXP_MASK)
					{
d1243 3
a1245 1
					if (!(algo_strength & SSL_EXP_MASK)) { found = 0; break; }
d1247 1
a1247 1
				else
d1249 1
a1249 1
				}
d1251 2
a1252 4
			if (ca_list[j]->algo_strength & SSL_STRONG_MASK)
				{
				if (algo_strength & SSL_STRONG_MASK)
					{
d1254 3
a1256 1
					if (!(algo_strength & SSL_STRONG_MASK)) { found = 0; break; }
d1258 1
a1258 1
				else
d1260 3
a1262 4
				}
			
			if (ca_list[j]->valid)
				{
d1267 1
a1267 3
				}
			else
				{
d1271 2
a1272 4
				if (ca_list[j]->algorithm_ssl)
					{
					if (alg_ssl)
						{
d1274 3
a1276 1
						if (!alg_ssl) { found = 0; break; }
d1278 1
a1278 1
					else
a1279 1
					}
a1280 2
			
			if (!multi) break;
d1283 4
d1291 1
a1291 1
			{	/* special command */
d1295 1
a1295 1
				ok = ssl_cipher_strength_sort(head_p, tail_p);
d1298 1
a1298 1
					SSL_R_INVALID_COMMAND);
d1308 2
a1309 4
				l++;
			}
		else if (found)
			{
d1311 3
a1313 5
				alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl, algo_strength,
				rule, -1, head_p, tail_p);
			}
		else
			{
d1315 2
a1316 2
				l++;
			}
d1320 2
a1321 2
	return(retval);
	}
d1323 6
a1328 5
STACK_OF(SSL_CIPHER) *ssl_create_cipher_list(const SSL_METHOD *ssl_method,
		STACK_OF(SSL_CIPHER) **cipher_list,
		STACK_OF(SSL_CIPHER) **cipher_list_by_id,
		const char *rule_str)
	{
d1358 2
a1359 3
	if (co_list == NULL)
		{
		SSLerr(SSL_F_SSL_CREATE_CIPHER_LIST,ERR_R_MALLOC_FAILURE);
d1361 1
a1361 1
		}
d1364 2
a1365 2
	                           disabled_mkey, disabled_auth, disabled_enc, disabled_mac, disabled_ssl,
	                           co_list, &head, &tail);
d1392 2
a1393 2
	ssl_cipher_apply_rule(0, SSL_kPSK, 0,0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);
	ssl_cipher_apply_rule(0, SSL_kKRB5, 0,0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);
d1400 1
a1400 2
	if (!ssl_cipher_strength_sort(&head, &tail))
		{
d1403 1
a1403 1
		}
d1420 1
a1420 2
	if (ca_list == NULL)
		{
d1422 1
a1422 1
		SSLerr(SSL_F_SSL_CREATE_CIPHER_LIST,ERR_R_MALLOC_FAILURE);
d1424 1
a1424 1
		}
d1426 2
a1427 2
	                           disabled_mkey, disabled_auth, disabled_enc,
				   disabled_mac, disabled_ssl, head);
d1435 1
a1435 2
	if (strncmp(rule_str,"DEFAULT",7) == 0)
		{
d1437 1
a1437 1
			&head, &tail, ca_list);
d1441 1
a1441 1
		}
d1449 1
a1449 1
		{	/* Rule processing failure */
d1451 3
a1453 3
		return(NULL);
		}
	
d1458 1
a1458 2
	if ((cipherstack = sk_SSL_CIPHER_new_null()) == NULL)
		{
d1460 2
a1461 2
		return(NULL);
		}
d1467 1
a1467 2
	for (curr = head; curr != NULL; curr = curr->next)
		{
d1473 1
a1473 1
			{
d1476 1
a1476 1
			printf("<%s>\n",curr->cipher->name);
a1477 1
			}
d1479 1
d1483 1
a1483 2
	if (tmp_cipher_list == NULL)
		{
d1486 1
a1486 1
		}
d1493 1
a1493 1
	(void)sk_SSL_CIPHER_set_cmp_func(*cipher_list_by_id,ssl_cipher_ptr_id_cmp);
d1496 2
a1497 2
	return(cipherstack);
	}
d1499 7
a1505 6
char *SSL_CIPHER_description(const SSL_CIPHER *cipher, char *buf, int len)
	{
	int is_export,pkl,kl;
	const char *ver,*exp_str;
	const char *kx,*au,*enc,*mac;
	unsigned long alg_mkey,alg_auth,alg_enc,alg_mac,alg_ssl,alg2;
d1518 6
a1523 1
	alg2=cipher->algorithm2;
a1524 5
	is_export=SSL_C_IS_EXPORT(cipher);
	pkl=SSL_C_EXPORT_PKEYLENGTH(cipher);
	kl=SSL_C_EXPORT_KEYLENGTH(cipher);
	exp_str=is_export?" export":"";
	
d1534 1
a1534 2
	switch (alg_mkey)
		{
d1536 1
a1536 1
		kx=is_export?(pkl == 512 ? "RSA(512)" : "RSA(1024)"):"RSA";
d1544 1
a1544 1
        case SSL_kKRB5:
d1548 1
a1548 1
		kx=is_export?(pkl == 512 ? "DH(512)" : "DH(1024)"):"DH";
d1567 1
a1567 1
		}
d1569 1
a1569 2
	switch (alg_auth)
		{
d1579 1
a1579 1
        case SSL_aKRB5:
d1582 1
a1582 1
        case SSL_aECDH:
d1597 1
a1597 1
		}
d1599 1
a1599 2
	switch (alg_enc)
		{
d1601 1
a1601 1
		enc=(is_export && kl == 5)?"DES(40)":"DES(56)";
d1607 2
a1608 2
		enc=is_export?(kl == 5 ? "RC4(40)" : "RC4(56)")
		  :((alg2&SSL2_CF_8_BYTE_ENC)?"RC4(64)":"RC4(128)");
d1611 1
a1611 1
		enc=is_export?(kl == 5 ? "RC2(40)" : "RC2(56)"):"RC2(128)";
d1643 1
a1643 1
		}
d1645 1
a1645 2
	switch (alg_mac)
		{
d1664 1
a1664 1
		}
d1666 7
a1672 8
	if (buf == NULL)
		{
		len=128;
		buf=OPENSSL_malloc(len);
		if (buf == NULL) return("OPENSSL_malloc Error");
		}
	else if (len < 128)
		return("Buffer too small");
d1675 1
a1675 1
	BIO_snprintf(buf,len,format,cipher->name,ver,kx,au,enc,mac,exp_str,alg_mkey,alg_auth,alg_enc,alg_mac,alg_ssl);
d1677 1
a1677 1
	BIO_snprintf(buf,len,format,cipher->name,ver,kx,au,enc,mac,exp_str);
d1679 2
a1680 2
	return(buf);
	}
d1682 3
a1684 2
char *SSL_CIPHER_get_version(const SSL_CIPHER *c)
	{
d1687 3
a1689 2
	if (c == NULL) return("(NONE)");
	i=(int)(c->id>>24L);
d1696 1
a1696 1
	}
d1699 3
a1701 2
const char *SSL_CIPHER_get_name(const SSL_CIPHER *c)
	{
d1703 1
a1703 1
		return(c->name);
d1705 1
a1705 1
	}
d1708 4
a1711 3
int SSL_CIPHER_get_bits(const SSL_CIPHER *c, int *alg_bits)
	{
	int ret=0;
d1713 3
a1715 3
	if (c != NULL)
		{
		if (alg_bits != NULL) *alg_bits = c->alg_bits;
a1716 2
		}
	return(ret);
d1718 2
d1721 3
a1723 2
unsigned long SSL_CIPHER_get_id(const SSL_CIPHER *c)
	{
d1725 1
a1725 1
	}
d1727 3
a1729 2
SSL_COMP *ssl3_comp_find(STACK_OF(SSL_COMP) *sk, int n)
	{
d1731 1
a1731 1
	int i,nn;
d1733 5
a1737 5
	if ((n == 0) || (sk == NULL)) return(NULL);
	nn=sk_SSL_COMP_num(sk);
	for (i=0; i<nn; i++)
		{
		ctmp=sk_SSL_COMP_value(sk,i);
d1739 1
a1739 3
			return(ctmp);
		}
	return(NULL);
d1741 2
d1745 3
a1747 2
void *SSL_COMP_get_compression_methods(void)
	{
d1749 5
a1753 3
	}
int SSL_COMP_add_compression_method(int id, void *cm)
	{
d1755 1
a1755 1
	}
d1757 3
a1759 2
const char *SSL_COMP_get_name(const void *comp)
	{
d1761 1
a1761 1
	}
d1763 3
a1765 2
STACK_OF(SSL_COMP) *SSL_COMP_get_compression_methods(void)
	{
d1767 2
a1768 2
	return(ssl_comp_methods);
	}
d1770 3
a1772 2
int SSL_COMP_add_compression_method(int id, COMP_METHOD *cm)
	{
d1775 2
a1776 2
        if (cm == NULL || cm->type == NID_undef)
                return 1;
d1784 2
a1785 3
	if (id < 193 || id > 255)
		{
		SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD,SSL_R_COMPRESSION_ID_NOT_WITHIN_PRIVATE_RANGE);
d1787 1
a1787 1
		}
d1790 3
a1792 3
	comp=(SSL_COMP *)OPENSSL_malloc(sizeof(SSL_COMP));
	comp->id=id;
	comp->method=cm;
d1795 1
a1795 2
		&& sk_SSL_COMP_find(ssl_comp_methods,comp) >= 0)
		{
d1798 4
a1801 6
		SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD,SSL_R_DUPLICATE_COMPRESSION_ID);
		return(1);
		}
	else if ((ssl_comp_methods == NULL)
		|| !sk_SSL_COMP_push(ssl_comp_methods,comp))
		{
d1804 3
a1806 5
		SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD,ERR_R_MALLOC_FAILURE);
		return(1);
		}
	else
		{
d1808 1
a1808 2
		return(0);
		}
d1810 1
d1812 3
a1814 2
const char *SSL_COMP_get_name(const COMP_METHOD *comp)
	{
d1818 1
a1818 1
	}
@


1.21
log
@resolve conflicts
@
text
@d315 1
d1154 1
a1154 1
				 (ch == '-'))
d1156 1
a1156 1
			while (	isalnum(ch) || (ch == '-'))
@


1.20
log
@OpenSSL 1.0.0f: merge
@
text
@d165 3
a167 1
#define SSL_ENC_NUM_IDX		12
d171 1
a171 1
	NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
d184 2
d191 1
a191 1
	NULL,NULL,NULL,NULL
d198 2
a199 1
	EVP_PKEY_HMAC,EVP_PKEY_HMAC,EVP_PKEY_HMAC,NID_undef
d203 1
a203 1
	0,0,0,0
d208 2
a209 1
	SSL_HANDSHAKE_MAC_GOST94,0
d256 1
d283 1
d294 4
a297 3
	{0,SSL_TXT_AES128,0,  0,0,SSL_AES128,0,0,0,0,0,0},
	{0,SSL_TXT_AES256,0,  0,0,SSL_AES256,0,0,0,0,0,0},
	{0,SSL_TXT_AES,0,     0,0,SSL_AES128|SSL_AES256,0,0,0,0,0,0},
d308 2
d393 5
d423 8
d553 6
d582 6
d603 2
a604 1

d611 16
a626 1
	}	
d628 12
a639 1
	if ((*enc != NULL) && (*md != NULL) && (!mac_pkey_type||*mac_pkey_type != NID_undef))
d641 1
a651 1
	if (ssl_handshake_digest_flag[idx]==0) return 0;
d653 4
a656 1
	*md = ssl_digest_methods[idx];
d731 3
d759 2
d768 2
d800 3
d1502 3
d1506 1
d1563 2
d1597 3
d1662 6
d1690 9
d1754 5
@


1.19
log
@openssl-1.0.0e: resolve conflicts
@
text
@d449 1
@


1.18
log
@resolve conflicts, fix local changes
@
text
@d1030 1
a1030 1
	const char *l, *start, *buf;
a1066 1
		start=l;
d1458 1
a1458 1
	unsigned long alg_mkey,alg_auth,alg_enc,alg_mac,alg_ssl,alg2,alg_s;
a1470 1
	alg_s=cipher->algo_strength;
@


1.17
log
@resolve conflicts
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
d116 27
d148 3
a150 1

d158 6
a163 6
#define SSL_ENC_eFZA_IDX	5
#define SSL_ENC_NULL_IDX	6
#define SSL_ENC_AES128_IDX	7
#define SSL_ENC_AES256_IDX	8
#define SSL_ENC_CAMELLIA128_IDX	9
#define SSL_ENC_CAMELLIA256_IDX	10
d169 1
a169 1
	NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL
d180 6
a185 1
#define SSL_MD_NUM_IDX	2
d187 17
a203 1
	NULL,NULL,
d214 1
a214 1
	SSL_CIPHER *cipher;
d221 130
a350 29
	/* Don't include eNULL unless specifically enabled. */
	/* Don't include ECC in ALL because these ciphers are not yet official. */
	{0,SSL_TXT_ALL, 0,SSL_ALL & ~SSL_eNULL & ~SSL_kECDH & ~SSL_kECDHE, SSL_ALL ,0,0,0,SSL_ALL,SSL_ALL}, /* must be first */
	/* TODO: COMPLEMENT OF ALL and COMPLEMENT OF DEFAULT do not have ECC cipher suites handled properly. */
	{0,SSL_TXT_CMPALL,0,SSL_eNULL,0,0,0,0,SSL_ENC_MASK,0},  /* COMPLEMENT OF ALL */
	{0,SSL_TXT_CMPDEF,0,SSL_ADH, 0,0,0,0,SSL_AUTH_MASK,0},
	{0,SSL_TXT_kKRB5,0,SSL_kKRB5,0,0,0,0,SSL_MKEY_MASK,0},  /* VRS Kerberos5 */
	{0,SSL_TXT_kRSA,0,SSL_kRSA,  0,0,0,0,SSL_MKEY_MASK,0},
	{0,SSL_TXT_kDHr,0,SSL_kDHr,  0,0,0,0,SSL_MKEY_MASK,0},
	{0,SSL_TXT_kDHd,0,SSL_kDHd,  0,0,0,0,SSL_MKEY_MASK,0},
	{0,SSL_TXT_kEDH,0,SSL_kEDH,  0,0,0,0,SSL_MKEY_MASK,0},
	{0,SSL_TXT_kFZA,0,SSL_kFZA,  0,0,0,0,SSL_MKEY_MASK,0},
	{0,SSL_TXT_DH,	0,SSL_DH,    0,0,0,0,SSL_MKEY_MASK,0},
	{0,SSL_TXT_ECC,	0,(SSL_kECDH|SSL_kECDHE), 0,0,0,0,SSL_MKEY_MASK,0},
	{0,SSL_TXT_EDH,	0,SSL_EDH,   0,0,0,0,SSL_MKEY_MASK|SSL_AUTH_MASK,0},
	{0,SSL_TXT_aKRB5,0,SSL_aKRB5,0,0,0,0,SSL_AUTH_MASK,0},  /* VRS Kerberos5 */
	{0,SSL_TXT_aRSA,0,SSL_aRSA,  0,0,0,0,SSL_AUTH_MASK,0},
	{0,SSL_TXT_aDSS,0,SSL_aDSS,  0,0,0,0,SSL_AUTH_MASK,0},
	{0,SSL_TXT_aFZA,0,SSL_aFZA,  0,0,0,0,SSL_AUTH_MASK,0},
	{0,SSL_TXT_aNULL,0,SSL_aNULL,0,0,0,0,SSL_AUTH_MASK,0},
	{0,SSL_TXT_aDH, 0,SSL_aDH,   0,0,0,0,SSL_AUTH_MASK,0},
	{0,SSL_TXT_DSS,	0,SSL_DSS,   0,0,0,0,SSL_AUTH_MASK,0},

	{0,SSL_TXT_DES,	0,SSL_DES,   0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_3DES,0,SSL_3DES,  0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_RC4,	0,SSL_RC4,   0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_RC2,	0,SSL_RC2,   0,0,0,0,SSL_ENC_MASK,0},
#ifndef OPENSSL_NO_IDEA
	{0,SSL_TXT_IDEA,0,SSL_IDEA,  0,0,0,0,SSL_ENC_MASK,0},
a351 29
	{0,SSL_TXT_SEED,0,SSL_SEED,  0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_eNULL,0,SSL_eNULL,0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_eFZA,0,SSL_eFZA,  0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_AES,	0,SSL_AES,   0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_CAMELLIA,0,SSL_CAMELLIA, 0,0,0,0,SSL_ENC_MASK,0},

	{0,SSL_TXT_MD5,	0,SSL_MD5,   0,0,0,0,SSL_MAC_MASK,0},
	{0,SSL_TXT_SHA1,0,SSL_SHA1,  0,0,0,0,SSL_MAC_MASK,0},
	{0,SSL_TXT_SHA,	0,SSL_SHA,   0,0,0,0,SSL_MAC_MASK,0},

	{0,SSL_TXT_NULL,0,SSL_NULL,  0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_KRB5,0,SSL_KRB5,  0,0,0,0,SSL_AUTH_MASK|SSL_MKEY_MASK,0},
	{0,SSL_TXT_RSA,	0,SSL_RSA,   0,0,0,0,SSL_AUTH_MASK|SSL_MKEY_MASK,0},
	{0,SSL_TXT_ADH,	0,SSL_ADH,   0,0,0,0,SSL_AUTH_MASK|SSL_MKEY_MASK,0},
	{0,SSL_TXT_FZA,	0,SSL_FZA,   0,0,0,0,SSL_AUTH_MASK|SSL_MKEY_MASK|SSL_ENC_MASK,0},

	{0,SSL_TXT_SSLV2, 0,SSL_SSLV2, 0,0,0,0,SSL_SSL_MASK,0},
	{0,SSL_TXT_SSLV3, 0,SSL_SSLV3, 0,0,0,0,SSL_SSL_MASK,0},
	{0,SSL_TXT_TLSV1, 0,SSL_TLSV1, 0,0,0,0,SSL_SSL_MASK,0},

	{0,SSL_TXT_EXP   ,0, 0,SSL_EXPORT, 0,0,0,0,SSL_EXP_MASK},
	{0,SSL_TXT_EXPORT,0, 0,SSL_EXPORT, 0,0,0,0,SSL_EXP_MASK},
	{0,SSL_TXT_EXP40, 0, 0, SSL_EXP40, 0,0,0,0,SSL_STRONG_MASK},
	{0,SSL_TXT_EXP56, 0, 0, SSL_EXP56, 0,0,0,0,SSL_STRONG_MASK},
	{0,SSL_TXT_LOW,   0, 0,   SSL_LOW, 0,0,0,0,SSL_STRONG_MASK},
	{0,SSL_TXT_MEDIUM,0, 0,SSL_MEDIUM, 0,0,0,0,SSL_STRONG_MASK},
	{0,SSL_TXT_HIGH,  0, 0,  SSL_HIGH, 0,0,0,0,SSL_STRONG_MASK},
	{0,SSL_TXT_FIPS,  0, 0,  SSL_FIPS, 0,0,0,0,SSL_FIPS|SSL_STRONG_NONE},
	};
d377 2
d384 3
d389 18
a407 2


d462 1
a462 1
	     const EVP_MD **md, SSL_COMP **comp)
d465 1
a465 1
	SSL_CIPHER *c;
d490 1
a490 1
	switch (c->algorithms & SSL_ENC_MASK)
d510 11
a520 7
	case SSL_AES:
		switch(c->alg_bits)
			{
		case 128: i=SSL_ENC_AES128_IDX; break;
		case 256: i=SSL_ENC_AES256_IDX; break;
		default: i=-1; break;
			}
d522 2
a523 7
	case SSL_CAMELLIA:
		switch(c->alg_bits)
			{
		case 128: i=SSL_ENC_CAMELLIA128_IDX; break;
		case 256: i=SSL_ENC_CAMELLIA256_IDX; break;
		default: i=-1; break;
			}
a527 1

d533 1
a533 1
	if ((i < 0) || (i >= SSL_ENC_NUM_IDX))
d543 1
a543 1
	switch (c->algorithms & SSL_MAC_MASK)
d551 6
d561 7
a567 2
	if ((i < 0) || (i >= SSL_MD_NUM_IDX))
		*md=NULL;
d569 1
d571 3
d575 1
a575 1
	if ((*enc != NULL) && (*md != NULL))
d581 12
d604 1
a604 1
	if (curr->next != NULL) /* should always be true */
d612 15
a626 6
struct disabled_masks { /* This is a kludge no longer needed with OpenSSL 0.9.9,
                         * where 128-bit and 256-bit algorithms simply will get
                         * separate bits. */
  unsigned long mask; /* everything except m256 */
  unsigned long m256; /* applies to 256-bit algorithms only */
};
d628 1
a628 1
static struct disabled_masks ssl_cipher_get_disabled(void)
d630 5
a634 3
	unsigned long mask;
	unsigned long m256;
	struct disabled_masks ret;
a635 1
	mask = SSL_kFZA;
d637 2
a638 1
	mask |= SSL_aRSA|SSL_kRSA;
d641 1
a641 1
	mask |= SSL_aDSS;
d643 2
d646 2
a647 1
	mask |= SSL_kDHr|SSL_kDHd|SSL_kEDH|SSL_aDH;
d650 5
a654 1
	mask |= SSL_kKRB5|SSL_aKRB5;
d657 6
a662 1
	mask |= SSL_kECDH|SSL_kECDHE;
d664 12
d677 1
a677 1
	mask |= SSL_eNULL;
d679 19
a698 21
	mask |= (ssl_cipher_methods[SSL_ENC_DES_IDX ] == NULL) ? SSL_DES :0;
	mask |= (ssl_cipher_methods[SSL_ENC_3DES_IDX] == NULL) ? SSL_3DES:0;
	mask |= (ssl_cipher_methods[SSL_ENC_RC4_IDX ] == NULL) ? SSL_RC4 :0;
	mask |= (ssl_cipher_methods[SSL_ENC_RC2_IDX ] == NULL) ? SSL_RC2 :0;
	mask |= (ssl_cipher_methods[SSL_ENC_IDEA_IDX] == NULL) ? SSL_IDEA:0;
	mask |= (ssl_cipher_methods[SSL_ENC_eFZA_IDX] == NULL) ? SSL_eFZA:0;
	mask |= (ssl_cipher_methods[SSL_ENC_SEED_IDX] == NULL) ? SSL_SEED:0;

	mask |= (ssl_digest_methods[SSL_MD_MD5_IDX ] == NULL) ? SSL_MD5 :0;
	mask |= (ssl_digest_methods[SSL_MD_SHA1_IDX] == NULL) ? SSL_SHA1:0;

	/* finally consider algorithms where mask and m256 differ */
	m256 = mask;
	mask |= (ssl_cipher_methods[SSL_ENC_AES128_IDX] == NULL) ? SSL_AES:0;
	mask |= (ssl_cipher_methods[SSL_ENC_CAMELLIA128_IDX] == NULL) ? SSL_CAMELLIA:0;
	m256 |= (ssl_cipher_methods[SSL_ENC_AES256_IDX] == NULL) ? SSL_AES:0;
	m256 |= (ssl_cipher_methods[SSL_ENC_CAMELLIA256_IDX] == NULL) ? SSL_CAMELLIA:0;

	ret.mask = mask;
	ret.m256 = m256;
	return ret;
d702 6
a707 3
		int num_of_ciphers, unsigned long mask, unsigned long m256,
		CIPHER_ORDER *co_list, CIPHER_ORDER **head_p,
		CIPHER_ORDER **tail_p)
d710 1
a710 1
	SSL_CIPHER *c;
a723 1
#define IS_MASKED(c) ((c)->algorithms & (((c)->alg_bits == 256) ? m256 : mask))
d725 6
a730 6
#ifdef OPENSSL_FIPS
		if ((c != NULL) && c->valid && !IS_MASKED(c)
			&& (!FIPS_mode() || (c->algo_strength & SSL_FIPS)))
#else
		if ((c != NULL) && c->valid && !IS_MASKED(c))
#endif
d738 1
a738 1
			printf("\t%d: %s %lx %lx\n",i,c->name,c->id,c->algorithms);
a748 5
	for (i = 1; i < co_list_num - 1; i++)
		{
		co_list[i].prev = &(co_list[i-1]);
		co_list[i].next = &(co_list[i+1]);
		}
d751 19
a769 6
		(*head_p) = &(co_list[0]);
		(*head_p)->prev = NULL;
		(*head_p)->next = &(co_list[1]);
		(*tail_p) = &(co_list[co_list_num - 1]);
		(*tail_p)->prev = &(co_list[co_list_num - 2]);
		(*tail_p)->next = NULL;
d773 5
a777 2
static void ssl_cipher_collect_aliases(SSL_CIPHER **ca_list,
			int num_of_group_aliases, unsigned long mask,
d781 1
a781 1
	SSL_CIPHER **ca_curr;
d783 5
d803 3
a805 3
	 * They represent either an algorithm, that must be fully
	 * supported (not match any bit in mask) or represent a cipher
	 * strength value (will be added in any case because algorithms=0).
d809 28
a836 6
		if ((i == 0) ||		/* always fetch "ALL" */
		    !(cipher_aliases[i].algorithms & mask))
			{
			*ca_curr = (SSL_CIPHER *)(cipher_aliases + i);
			ca_curr++;
			}
d842 6
a847 4
static void ssl_cipher_apply_rule(unsigned long cipher_id, unsigned long ssl_version,
		unsigned long algorithms, unsigned long mask,
		unsigned long algo_strength, unsigned long mask_strength,
		int rule, int strength_bits, CIPHER_ORDER *co_list,
d850 3
a852 3
	CIPHER_ORDER *head, *tail, *curr, *curr2, *tail2;
	SSL_CIPHER *cp;
	unsigned long ma, ma_s;
d855 2
a856 3
	printf("Applying rule %d with %08lx %08lx %08lx %08lx (%d)\n",
		rule, algorithms, mask, algo_strength, mask_strength,
		strength_bits);
d859 18
a876 3
	curr = head = *head_p;
	curr2 = head;
	tail2 = tail = *tail_p;
d879 1
a879 1
		if ((curr == NULL) || (curr == tail2)) break;
d881 1
a881 1
		curr2 = curr->next;
d885 5
a889 4
		/* If explicit cipher suite, match only that one for its own protocol version.
		 * Usual selection criteria will be used for similar ciphersuites from other version! */

		if (cipher_id && (cp->algorithms & SSL_SSL_MASK) == ssl_version)
d891 1
a891 1
			if (cp->id != cipher_id)
d894 1
a894 6

		/*
		 * Selection criteria is either the number of strength_bits
		 * or the algorithm used.
		 */
		else if (strength_bits == -1)
a895 3
			ma = mask & cp->algorithms;
			ma_s = mask_strength & cp->algo_strength;

d897 1
a897 2
			printf("\nName: %s:\nAlgo = %08lx Algo_strength = %08lx\nMask = %08lx Mask_strength %08lx\n", cp->name, cp->algorithms, cp->algo_strength, mask, mask_strength);
			printf("ma = %08lx ma_s %08lx, ma&algo=%08lx, ma_s&algos=%08lx\n", ma, ma_s, ma&algorithms, ma_s&algo_strength);
d899 15
a913 9
			/*
			 * Select: if none of the mask bit was met from the
			 * cipher or not all of the bits were met, the
			 * selection does not apply.
			 */
			if (((ma == 0) && (ma_s == 0)) ||
			    ((ma & algorithms) != ma) ||
			    ((ma_s & algo_strength) != ma_s))
				continue; /* does not apply */
a914 2
		else if (strength_bits != cp->strength_bits)
			continue;	/* does not apply */
d923 1
d926 2
a927 16
				int add_this_cipher = 1;

				if (((cp->algorithms & (SSL_kECDHE|SSL_kECDH|SSL_aECDSA)) != 0))
					{
					/* Make sure "ECCdraft" ciphersuites are activated only if
					 * *explicitly* requested, but not implicitly (such as
					 * as part of the "AES" alias). */

					add_this_cipher = (mask & (SSL_kECDHE|SSL_kECDH|SSL_aECDSA)) != 0 || cipher_id != 0;
					}
				
				if (add_this_cipher)
					{
					ll_append_tail(&head, curr, &tail);
					curr->active = 1;
					}
d933 1
d940 11
a950 1
			curr->active = 0;
d953 1
d974 1
a974 2
static int ssl_cipher_strength_sort(CIPHER_ORDER *co_list,
				    CIPHER_ORDER **head_p,
d997 1
a997 1
	{
d1000 1
a1000 1
	}
d1019 1
a1019 2
			ssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, CIPHER_ORD, i,
					co_list, head_p, tail_p);
d1026 2
a1027 2
		CIPHER_ORDER *co_list, CIPHER_ORDER **head_p,
		CIPHER_ORDER **tail_p, SSL_CIPHER **ca_list)
d1029 1
a1029 1
	unsigned long algorithms, mask, algo_strength, mask_strength;
d1032 1
a1032 1
	unsigned long cipher_id = 0, ssl_version = 0;
d1060 6
a1065 1
		algorithms = mask = algo_strength = mask_strength = 0;
d1126 3
a1128 4
			 j = found = 0;
			 cipher_id = 0;
			 ssl_version = 0;
			 while (ca_list[j])
d1139 1
d1143 54
a1196 13
			/* New algorithms:
			 *  1 - any old restrictions apply outside new mask
			 *  2 - any new restrictions apply outside old mask
			 *  3 - enforce old & new where masks intersect
			 */
			algorithms = (algorithms & ~ca_list[j]->mask) |		/* 1 */
			             (ca_list[j]->algorithms & ~mask) |		/* 2 */
			             (algorithms & ca_list[j]->algorithms);	/* 3 */
			mask |= ca_list[j]->mask;
			algo_strength = (algo_strength & ~ca_list[j]->mask_strength) |
			                (ca_list[j]->algo_strength & ~mask_strength) |
			                (algo_strength & ca_list[j]->algo_strength);
			mask_strength |= ca_list[j]->mask_strength;
d1198 11
a1208 1
			/* explicit ciphersuite found */
d1211 3
a1214 2
				ssl_version = ca_list[j]->algorithms & SSL_SSL_MASK;
				break;
d1216 4
d1221 12
d1244 1
a1244 2
				ok = ssl_cipher_strength_sort(co_list,
					head_p, tail_p);
d1261 3
a1263 3
			ssl_cipher_apply_rule(cipher_id, ssl_version, algorithms, mask,
				algo_strength, mask_strength, rule, -1,
				co_list, head_p, tail_p);
d1282 1
a1282 2
	unsigned long disabled_mask;
	unsigned long disabled_m256;
d1286 1
a1286 1
	SSL_CIPHER **ca_list = NULL;
d1298 1
a1298 6
	{
		struct disabled_masks d;
		d = ssl_cipher_get_disabled();
		disabled_mask = d.mask;
		disabled_m256 = d.m256;
	}
d1316 46
a1361 2
	ssl_cipher_collect_ciphers(ssl_method, num_of_ciphers, disabled_mask,
				   disabled_m256, co_list, &head, &tail);
d1373 1
a1373 2
	ca_list =
		(SSL_CIPHER **)OPENSSL_malloc(sizeof(SSL_CIPHER *) * num_of_alias_max);
d1381 2
a1382 1
				   (disabled_mask & disabled_m256), head);
d1393 1
a1393 1
			co_list, &head, &tail, ca_list);
d1400 1
a1400 2
		ok = ssl_cipher_process_rulestr(rule_p, co_list, &head, &tail,
						ca_list);
d1402 1
a1402 1
	OPENSSL_free(ca_list);	/* Not needed anymore */
d1409 1
a1425 3
#ifdef OPENSSL_FIPS
		if (curr->active && (!FIPS_mode() || curr->cipher->algo_strength & SSL_FIPS))
#else
a1426 1
#endif
d1450 1
d1454 1
a1454 1
char *SSL_CIPHER_description(SSL_CIPHER *cipher, char *buf, int len)
d1459 1
a1459 1
	unsigned long alg,alg2,alg_s;
d1461 1
a1461 1
	static const char *format="%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s%s AL=%lx\n";
d1466 6
a1471 1
	alg=cipher->algorithms;
d1480 1
a1480 1
	if (alg & SSL_SSLV2)
d1482 1
a1482 1
	else if (alg & SSL_SSLV3)
d1487 1
a1487 1
	switch (alg&SSL_MKEY_MASK)
d1498 2
a1499 6
        case SSL_kKRB5:         /* VRS */
        case SSL_KRB5:          /* VRS */
            kx="KRB5";
            break;
	case SSL_kFZA:
		kx="Fortezza";
d1504 11
a1514 3
	case SSL_kECDH:
	case SSL_kECDHE:
		kx=is_export?"ECDH(<=163)":"ECDH";
d1520 1
a1520 1
	switch (alg&SSL_AUTH_MASK)
d1531 6
a1536 5
        case SSL_aKRB5:         /* VRS */
        case SSL_KRB5:          /* VRS */
            au="KRB5";
            break;
	case SSL_aFZA:
d1543 3
d1551 1
a1551 1
	switch (alg&SSL_ENC_MASK)
a1568 3
	case SSL_eFZA:
		enc="Fortezza";
		break;
d1572 8
a1579 8
	case SSL_AES:
		switch(cipher->strength_bits)
			{
		case 128: enc="AES(128)"; break;
		case 192: enc="AES(192)"; break;
		case 256: enc="AES(256)"; break;
		default: enc="AES(?""?""?)"; break;
			}
d1581 2
a1582 7
	case SSL_CAMELLIA:
		switch(cipher->strength_bits)
			{
		case 128: enc="Camellia(128)"; break;
		case 256: enc="Camellia(256)"; break;
		default: enc="Camellia(?""?""?)"; break;
			}
a1586 1

d1592 1
a1592 1
	switch (alg&SSL_MAC_MASK)
d1615 1
a1615 1
	BIO_snprintf(buf,len,format,cipher->name,ver,kx,au,enc,mac,exp_str,alg);
@


1.16
log
@resolve conflicts
@
text
@d1358 1
a1358 1
		&& !sk_SSL_COMP_find(ssl_comp_methods,comp))
@


1.15
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d118 1
d120 2
@


1.14
log
@resolve conflicts
@
text
@d225 1
d519 4
d524 1
d1063 3
d1067 1
@


1.13
log
@resolve conflicts
@
text
@d58 58
a115 1

a118 1
#include <openssl/fips.h>
d130 5
a134 1
#define SSL_ENC_NUM_IDX		9
d140 4
d169 4
a172 2
	{0,SSL_TXT_ALL, 0,SSL_ALL & ~SSL_eNULL, SSL_ALL ,0,0,0,SSL_ALL,SSL_ALL}, /* must be first */
        {0,SSL_TXT_CMPALL,0,SSL_eNULL,0,0,0,0,SSL_ENC_MASK,0},  /* COMPLEMENT OF ALL */
d174 1
a174 1
        {0,SSL_TXT_kKRB5,0,SSL_kKRB5,0,0,0,0,SSL_MKEY_MASK,0},  /* VRS Kerberos5 */
d181 1
a182 1

d198 1
d202 1
a224 1
	{0,SSL_TXT_FIPS,  0, 0,  SSL_FIPS, 0,0,0,0,SSL_FIPS|SSL_STRONG_NONE},
d227 1
a227 3
static int init_ciphers=1;

static void load_ciphers(void)
d247 6
a257 1
	init_ciphers=0;
d260 54
d325 3
d329 3
a331 8
		if (s->compress_meth == 0)
			*comp=NULL;
		else if (ssl_comp_methods == NULL)
			{
			/* bad */
			*comp=NULL;
			}
		else
a332 2

			ctmp.id=s->compress_meth;
d371 12
d440 8
a447 1
static unsigned long ssl_cipher_get_disabled(void)
d450 2
d466 3
a468 1

d479 1
a479 1
	mask |= (ssl_cipher_methods[SSL_ENC_AES128_IDX] == NULL) ? SSL_AES:0;
d484 10
a493 1
	return(mask);
d497 3
a499 2
		int num_of_ciphers, unsigned long mask, CIPHER_ORDER *co_list,
		CIPHER_ORDER **head_p, CIPHER_ORDER **tail_p)
d516 1
d518 1
a518 6
#ifdef OPENSSL_FIPS
		if ((c != NULL) && c->valid && !(c->algorithms & mask)
			&& (!FIPS_mode() || (c->algo_strength & SSL_FIPS)))
#else
		if ((c != NULL) && c->valid && !(c->algorithms & mask))
#endif
d592 2
a593 1
static void ssl_cipher_apply_rule(unsigned long algorithms, unsigned long mask,
d619 9
d632 1
a632 1
		if (strength_bits == -1)
d663 16
a678 2
				ll_append_tail(&head, curr, &tail);
				curr->active = 1;
d759 1
a759 1
			ssl_cipher_apply_rule(0, 0, 0, 0, CIPHER_ORD, i,
d773 1
d863 2
d893 8
d925 1
a925 1
			while ((*l != '\0') && ITEM_SEP(*l))
d930 1
a930 1
			ssl_cipher_apply_rule(algorithms, mask,
d936 1
a936 1
			while ((*l != '\0') && ITEM_SEP(*l))
d952 1
a963 7
	if (init_ciphers)
		{
		CRYPTO_w_lock(CRYPTO_LOCK_SSL);
		if (init_ciphers) load_ciphers();
		CRYPTO_w_unlock(CRYPTO_LOCK_SSL);
		}

d968 6
a973 1
	disabled_mask = ssl_cipher_get_disabled();
d992 1
a992 1
				   co_list, &head, &tail);
d1012 2
a1013 2
	ssl_cipher_collect_aliases(ca_list, num_of_group_aliases, disabled_mask,
				   head);
a1056 3
#ifdef OPENSSL_FIPS
		if (curr->active && (!FIPS_mode() || curr->cipher->algo_strength & SSL_FIPS))
#else
a1057 1
#endif
d1079 1
a1079 1
	sk_SSL_CIPHER_set_cmp_func(*cipher_list_by_id,ssl_cipher_ptr_id_cmp);
d1087 2
a1088 2
	char *ver,*exp_str;
	char *kx,*au,*enc,*mac;
d1091 1
a1091 1
	static char *format="%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s%s AL=%lx\n";
d1093 1
a1093 1
	static char *format="%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s%s\n";
d1104 1
a1104 1

d1133 4
d1160 3
d1201 12
d1299 6
a1304 2
static int sk_comp_cmp(const SSL_COMP * const *a,
			const SSL_COMP * const *b)
d1306 1
a1306 1
	return((*a)->id-(*b)->id);
d1309 5
d1316 1
a1322 1
	STACK_OF(SSL_COMP) *sk;
d1327 12
d1343 11
a1353 5
	if (ssl_comp_methods == NULL)
		sk=ssl_comp_methods=sk_SSL_COMP_new(sk_comp_cmp);
	else
		sk=ssl_comp_methods;
	if ((sk == NULL) || !sk_SSL_COMP_push(sk,comp))
d1355 1
d1366 9
@


1.12
log
@resolve conflicts
@
text
@d703 8
a710 1
			algorithms |= ca_list[j]->algorithms;
d712 3
a714 1
			algo_strength |= ca_list[j]->algo_strength;
d768 1
a768 1
	STACK_OF(SSL_CIPHER) *cipherstack;
d776 2
a777 1
	if (rule_str == NULL) return(NULL);
d888 2
a889 35
	/*
	 * The following passage is a little bit odd. If pointer variables
	 * were supplied to hold STACK_OF(SSL_CIPHER) return information,
	 * the old memory pointed to is free()ed. Then, however, the
	 * cipher_list entry will be assigned just a copy of the returned
	 * cipher stack. For cipher_list_by_id a copy of the cipher stack
	 * will be created. See next comment...
	 */
	if (cipher_list != NULL)
		{
		if (*cipher_list != NULL)
			sk_SSL_CIPHER_free(*cipher_list);
		*cipher_list = cipherstack;
		}

	if (cipher_list_by_id != NULL)
		{
		if (*cipher_list_by_id != NULL)
			sk_SSL_CIPHER_free(*cipher_list_by_id);
		*cipher_list_by_id = sk_SSL_CIPHER_dup(cipherstack);
		}

	/*
	 * Now it is getting really strange. If something failed during
	 * the previous pointer assignment or if one of the pointers was
	 * not requested, the error condition is met. That might be
	 * discussable. The strange thing is however that in this case
	 * the memory "ret" pointed to is "free()ed" and hence the pointer
	 * cipher_list becomes wild. The memory reserved for
	 * cipher_list_by_id however is not "free()ed" and stays intact.
	 */
	if (	(cipher_list_by_id == NULL) ||
		(*cipher_list_by_id == NULL) ||
		(cipher_list == NULL) ||
		(*cipher_list == NULL))
d892 1
a892 1
		return(NULL);
d894 6
a899 1

@


1.11
log
@merge 0.9.7d
@
text
@d62 1
d157 1
a163 1
	init_ciphers=0;
d187 1
d190 1
a190 1
int ssl_cipher_get_evp(SSL_SESSION *s, const EVP_CIPHER **enc,
d364 4
d369 1
d864 3
d868 1
d1068 1
a1068 1
char *SSL_CIPHER_get_version(SSL_CIPHER *c)
d1083 1
a1083 1
const char *SSL_CIPHER_get_name(SSL_CIPHER *c)
d1091 1
a1091 1
int SSL_CIPHER_get_bits(SSL_CIPHER *c, int *alg_bits)
@


1.10
log
@Correct some off-by-ones.  They currently don't matter, but this
is for future safety and consistency.
OK krw@@, markus@@
@
text
@d343 1
a343 1
		int num_of_ciphers, unsigned long mask, CIPHER_ORDER *list,
d346 1
a346 1
	int i, list_num;
d357 1
a357 1
	list_num = 0;	/* actual count of ciphers */
d364 5
a368 5
			list[list_num].cipher = c;
			list[list_num].next = NULL;
			list[list_num].prev = NULL;
			list[list_num].active = 0;
			list_num++;
d381 1
a381 1
	for (i = 1; i < list_num - 1; i++)
d383 2
a384 2
		list[i].prev = &(list[i-1]);
		list[i].next = &(list[i+1]);
d386 1
a386 1
	if (list_num > 0)
d388 1
a388 1
		(*head_p) = &(list[0]);
d390 3
a392 3
		(*head_p)->next = &(list[1]);
		(*tail_p) = &(list[list_num - 1]);
		(*tail_p)->prev = &(list[list_num - 2]);
d438 1
a438 1
		int rule, int strength_bits, CIPHER_ORDER *list,
d533 3
a535 2
static int ssl_cipher_strength_sort(CIPHER_ORDER *list, CIPHER_ORDER **head_p,
				     CIPHER_ORDER **tail_p)
d580 1
a580 1
					list, head_p, tail_p);
d587 1
a587 1
		CIPHER_ORDER *list, CIPHER_ORDER **head_p,
d712 1
a712 1
				ok = ssl_cipher_strength_sort(list,
d732 1
a732 1
				list, head_p, tail_p);
d754 1
a754 1
	CIPHER_ORDER *list = NULL, *head = NULL, *tail = NULL, *curr;
d784 2
a785 2
	list = (CIPHER_ORDER *)OPENSSL_malloc(sizeof(CIPHER_ORDER) * num_of_ciphers);
	if (list == NULL)
d792 1
a792 1
				   list, &head, &tail);
d808 1
a808 1
		OPENSSL_free(list);
d824 1
a824 1
			list, &head, &tail, ca_list);
d831 1
a831 1
		ok = ssl_cipher_process_rulestr(rule_p, list, &head, &tail,
d838 1
a838 1
		OPENSSL_free(list);
d847 1
a847 1
		OPENSSL_free(list);
d865 1
a865 1
	OPENSSL_free(list);	/* Not needed any longer */
d915 1
a915 1
	char *ver,*exp;
d931 1
a931 1
	exp=is_export?" export":"";
d1050 1
a1050 1
	BIO_snprintf(buf,len,format,cipher->name,ver,kx,au,enc,mac,exp,alg);
d1052 1
a1052 1
	BIO_snprintf(buf,len,format,cipher->name,ver,kx,au,enc,mac,exp);
d1139 1
a1139 1
		return(0);
d1144 1
a1144 1
		return(1);
@


1.9
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d76 1
a76 1
	NULL,NULL,NULL,NULL,NULL,NULL,
d254 1
a254 1
	if ((i < 0) || (i > SSL_ENC_NUM_IDX))
d276 1
a276 1
	if ((i < 0) || (i > SSL_MD_NUM_IDX))
@


1.8
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d677 2
a678 1
			 * sufficient, we have to strncmp() anyway.
d683 2
a684 2
				if ((ca_list[j]->name[buflen] == '\0') &&
				    !strncmp(buf, ca_list[j]->name, buflen))
d761 6
a766 1
	if (init_ciphers) load_ciphers();
@


1.7
log
@do not propose IDEA cipher on SSL connection.  tested by beck
noticed by Sverre Froyen <sverre@@viewmark.com>
@
text
@d103 4
a106 3
	/* Don't include eNULL unless specifically enabled.
	 * Similarly, don't include AES in ALL because these ciphers are not yet official. */
	{0,SSL_TXT_ALL, 0,SSL_ALL & ~SSL_eNULL & ~SSL_AES, SSL_ALL ,0,0,0,SSL_ALL,SSL_ALL}, /* must be first */
d1009 4
a1012 4
		case 128: enc="AESdraft(128)"; break;
		case 192: enc="AESdraft(192)"; break;
		case 256: enc="AESdraft(256)"; break;
		default: enc="AESdraft(?""?""?)"; break;
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d127 1
d129 1
d170 1
d173 3
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d71 3
a73 1
#define SSL_ENC_NUM_IDX		7
d103 4
a106 2
	/* Don't include eNULL unless specifically enabled */
	{0,SSL_TXT_ALL, 0,SSL_ALL & ~SSL_eNULL, SSL_ALL ,0,0,0,SSL_ALL,SSL_ALL}, /* must be first */
d115 1
d130 1
d137 1
d170 4
d234 8
d304 1
a304 1
#ifdef NO_RSA
d307 1
a307 1
#ifdef NO_DSA
d310 1
a310 1
#ifdef NO_DH
d313 3
d327 1
d362 3
d767 3
d904 3
d908 2
a909 1
	
d937 4
d962 4
d999 9
d1035 3
d1039 1
d1110 4
d1123 1
d1128 2
d1131 1
a1132 1

@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d521 1
a521 1
	number_uses = Malloc((max_strength_bits + 1) * sizeof(int));
d548 1
a548 1
	Free(number_uses);
d741 1
a741 1
	list = (CIPHER_ORDER *)Malloc(sizeof(CIPHER_ORDER) * num_of_ciphers);
d762 1
a762 1
		(SSL_CIPHER **)Malloc(sizeof(SSL_CIPHER *) * num_of_alias_max);
d765 1
a765 1
		Free(list);
d791 1
a791 1
	Free(ca_list);	/* Not needed anymore */
d795 1
a795 1
		Free(list);
d802 1
a802 1
	if ((cipherstack = sk_SSL_CIPHER_new(NULL)) == NULL)
d804 1
a804 1
		Free(list);
d822 1
a822 1
	Free(list);	/* Not needed any longer */
d978 3
a980 2
		buf=Malloc(128);
		if (buf == NULL) return("Malloc Error");
d985 1
a985 1
	sprintf(buf,format,cipher->name,ver,kx,au,enc,mac,exp);
d1040 2
a1041 1
static int sk_comp_cmp(SSL_COMP **a,SSL_COMP **b)
d1056 1
a1056 1
	comp=(SSL_COMP *)Malloc(sizeof(SSL_COMP));
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d610 1
a610 1
				 * We hit something, we cannot deal with,
d623 1
d637 1
a637 1
			 * Now search for the name in the ca_list. Be careful
d641 2
a642 2
			 * So additionally check, whether the cipher name found
			 * has the correct length. We can save a strlen() call,
d669 15
d685 4
a688 1
			 * Ok, we have the rule, now apply it
d690 15
a704 33
			if (rule == CIPHER_SPECIAL)
				{	/* special command */
				ok = 0;
				if ((buflen == 8) &&
					!strncmp(buf, "STRENGTH", 8))
					ok = ssl_cipher_strength_sort(list,
							head_p, tail_p);
				else
					SSLerr(SSL_F_SSL_CIPHER_PROCESS_RULESTR,
						SSL_R_INVALID_COMMAND);
				if (ok == 0)
					retval = 0;
				/*
				 * We do not support any "multi" options
				 * together with "@@", so throw away the
				 * rest of the command, if any left, until
				 * end or ':' is found.
				 */
				while ((*l != '\0') && ITEM_SEP(*l))
					l++;
				}
			else if (found)
				{
				ssl_cipher_apply_rule(algorithms, mask,
					algo_strength, mask_strength, rule, -1,
					list, head_p, tail_p);
				}
			else
				{
				while ((*l != '\0') && ITEM_SEP(*l))
					l++;
				}
			if (*l == '\0') break; /* done */
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@a85 6
typedef struct cipher_sort_st
	{
	SSL_CIPHER *cipher;
	int pref;
	} CIPHER_SORT;

d90 1
a90 8

typedef struct cipher_choice_st
	{
	int type;
	unsigned long algorithms;
	unsigned long mask;
	long top;
	} CIPHER_CHOICE;
d100 1
a100 1
static SSL_CIPHER cipher_aliases[]={
d102 44
a145 42
	{0,SSL_TXT_ALL, 0,SSL_ALL & ~SSL_eNULL, 0,SSL_ALL}, /* must be first */
	{0,SSL_TXT_kRSA,0,SSL_kRSA,  0,SSL_MKEY_MASK},
	{0,SSL_TXT_kDHr,0,SSL_kDHr,  0,SSL_MKEY_MASK},
	{0,SSL_TXT_kDHd,0,SSL_kDHd,  0,SSL_MKEY_MASK},
	{0,SSL_TXT_kEDH,0,SSL_kEDH,  0,SSL_MKEY_MASK},
	{0,SSL_TXT_kFZA,0,SSL_kFZA,  0,SSL_MKEY_MASK},
	{0,SSL_TXT_DH,	0,SSL_DH,    0,SSL_MKEY_MASK},
	{0,SSL_TXT_EDH,	0,SSL_EDH,   0,SSL_MKEY_MASK|SSL_AUTH_MASK},

	{0,SSL_TXT_aRSA,0,SSL_aRSA,  0,SSL_AUTH_MASK},
	{0,SSL_TXT_aDSS,0,SSL_aDSS,  0,SSL_AUTH_MASK},
	{0,SSL_TXT_aFZA,0,SSL_aFZA,  0,SSL_AUTH_MASK},
	{0,SSL_TXT_aNULL,0,SSL_aNULL,0,SSL_AUTH_MASK},
	{0,SSL_TXT_aDH, 0,SSL_aDH,   0,SSL_AUTH_MASK},
	{0,SSL_TXT_DSS,	0,SSL_DSS,   0,SSL_AUTH_MASK},

	{0,SSL_TXT_DES,	0,SSL_DES,   0,SSL_ENC_MASK},
	{0,SSL_TXT_3DES,0,SSL_3DES,  0,SSL_ENC_MASK},
	{0,SSL_TXT_RC4,	0,SSL_RC4,   0,SSL_ENC_MASK},
	{0,SSL_TXT_RC2,	0,SSL_RC2,   0,SSL_ENC_MASK},
	{0,SSL_TXT_IDEA,0,SSL_IDEA,  0,SSL_ENC_MASK},
	{0,SSL_TXT_eNULL,0,SSL_eNULL,0,SSL_ENC_MASK},
	{0,SSL_TXT_eFZA,0,SSL_eFZA,  0,SSL_ENC_MASK},

	{0,SSL_TXT_MD5,	0,SSL_MD5,   0,SSL_MAC_MASK},
	{0,SSL_TXT_SHA1,0,SSL_SHA1,  0,SSL_MAC_MASK},
	{0,SSL_TXT_SHA,	0,SSL_SHA,   0,SSL_MAC_MASK},

	{0,SSL_TXT_NULL,0,SSL_NULL,  0,SSL_ENC_MASK},
	{0,SSL_TXT_RSA,	0,SSL_RSA,   0,SSL_AUTH_MASK|SSL_MKEY_MASK},
	{0,SSL_TXT_ADH,	0,SSL_ADH,   0,SSL_AUTH_MASK|SSL_MKEY_MASK},
	{0,SSL_TXT_FZA,	0,SSL_FZA,   0,SSL_AUTH_MASK|SSL_MKEY_MASK|SSL_ENC_MASK},

	{0,SSL_TXT_EXP40, 0,SSL_EXP40, 0,SSL_EXP_MASK},
	{0,SSL_TXT_EXPORT,0,SSL_EXP40, 0,SSL_EXP_MASK},
	{0,SSL_TXT_EXP56, 0,SSL_EXP56, 0,SSL_EXP_MASK},
	{0,SSL_TXT_SSLV2, 0,SSL_SSLV2, 0,SSL_SSL_MASK},
	{0,SSL_TXT_SSLV3, 0,SSL_SSLV3, 0,SSL_SSL_MASK},
	{0,SSL_TXT_TLSV1, 0,SSL_TLSV1, 0,SSL_SSL_MASK},
	{0,SSL_TXT_LOW,   0,SSL_LOW,   0,SSL_STRONG_MASK},
	{0,SSL_TXT_MEDIUM,0,SSL_MEDIUM,0,SSL_STRONG_MASK},
	{0,SSL_TXT_HIGH,  0,SSL_HIGH,  0,SSL_STRONG_MASK},
a148 6
static void load_ciphers();

static int cmp_by_name(SSL_CIPHER **a, SSL_CIPHER **b)
	{
	return(strcmp((*a)->name,(*b)->name));
	}
d280 1
a280 4
STACK_OF(SSL_CIPHER) *ssl_create_cipher_list(SSL_METHOD *ssl_method,
		STACK_OF(SSL_CIPHER) **cipher_list,
		STACK_OF(SSL_CIPHER) **cipher_list_by_id,
		char *str)
d282 1
a282 39
	SSL_CIPHER *c;
	char *l;
	STACK_OF(SSL_CIPHER) *ret=NULL,*ok=NULL;
#define CL_BUF	40
	char buf[CL_BUF];
	char *tmp_str=NULL;
	unsigned long mask,algorithms,ma;
	char *start;
	int i,j,k,num=0,ch,multi;
	unsigned long al;
	STACK *ca_list=NULL;
	int current_x,num_x;
	CIPHER_CHOICE *ops=NULL;
	CIPHER_ORDER *list=NULL,*head=NULL,*tail=NULL,*curr,*tail2,*curr2;
	int list_num;
	int type;
	SSL_CIPHER c_tmp,*cp;

	if (str == NULL) return(NULL);

	if (strncmp(str,"DEFAULT",7) == 0)
		{
		i=strlen(str)+2+strlen(SSL_DEFAULT_CIPHER_LIST);
		if ((tmp_str=Malloc(i)) == NULL)
			{
			SSLerr(SSL_F_SSL_CREATE_CIPHER_LIST,ERR_R_MALLOC_FAILURE);
			goto err;
			}
		strcpy(tmp_str,SSL_DEFAULT_CIPHER_LIST);
		strcat(tmp_str,":");
		strcat(tmp_str,&(str[7]));
		str=tmp_str;
		}
	if (init_ciphers) load_ciphers();

	num=ssl_method->num_ciphers();

	if ((ret=sk_SSL_CIPHER_new(NULL)) == NULL) goto err;
	if ((ca_list=(STACK *)sk_new(cmp_by_name)) == NULL) goto err;
d284 1
a284 1
	mask =SSL_kFZA;
d286 1
a286 1
	mask|=SSL_aRSA|SSL_kRSA;
d289 1
a289 1
	mask|=SSL_aDSS;
d292 1
a292 1
	mask|=SSL_kDHr|SSL_kDHd|SSL_kEDH|SSL_aDH;
d296 1
a296 1
	mask|=SSL_eNULL;
d299 6
a304 6
	mask|=(ssl_cipher_methods[SSL_ENC_DES_IDX ] == NULL)?SSL_DES :0;
	mask|=(ssl_cipher_methods[SSL_ENC_3DES_IDX] == NULL)?SSL_3DES:0;
	mask|=(ssl_cipher_methods[SSL_ENC_RC4_IDX ] == NULL)?SSL_RC4 :0;
	mask|=(ssl_cipher_methods[SSL_ENC_RC2_IDX ] == NULL)?SSL_RC2 :0;
	mask|=(ssl_cipher_methods[SSL_ENC_IDEA_IDX] == NULL)?SSL_IDEA:0;
	mask|=(ssl_cipher_methods[SSL_ENC_eFZA_IDX] == NULL)?SSL_eFZA:0;
d306 2
a307 2
	mask|=(ssl_digest_methods[SSL_MD_MD5_IDX ] == NULL)?SSL_MD5 :0;
	mask|=(ssl_digest_methods[SSL_MD_SHA1_IDX] == NULL)?SSL_SHA1:0;
d309 16
a324 2
	if ((list=(CIPHER_ORDER *)Malloc(sizeof(CIPHER_ORDER)*num)) == NULL)
		goto err;
d327 2
a328 2
	list_num=0;
	for (i=0; i<num; i++)
d330 1
a330 1
		c=ssl_method->get_cipher((unsigned int)i);
d334 4
a337 4
			list[list_num].cipher=c;
			list[list_num].next=NULL;
			list[list_num].prev=NULL;
			list[list_num].active=0;
d339 1
d341 1
d344 5
a348 2
	
	for (i=1; i<list_num-1; i++)
d350 2
a351 2
		list[i].prev= &(list[i-1]);
		list[i].next= &(list[i+1]);
d355 44
a398 37
		head= &(list[0]);
		head->prev=NULL;
		head->next= &(list[1]);
		tail= &(list[list_num-1]);
		tail->prev= &(list[list_num-2]);
		tail->next=NULL;
		}

	/* special case */
	cipher_aliases[0].algorithms &= ~mask;

	/* get the aliases */
	k=sizeof(cipher_aliases)/sizeof(SSL_CIPHER);
	for (j=0; j<k; j++)
		{
		al=cipher_aliases[j].algorithms;
		/* Drop those that are not relevent */
		if ((al & mask) == al) continue;
		if (!sk_push(ca_list,(char *)&(cipher_aliases[j]))) goto err;
		}

	/* ca_list now holds a 'stack' of SSL_CIPHERS, some real, some
	 * 'aliases' */

	/* how many parameters are there? */
	num=1;
	for (l=str; *l; l++)
		if (ITEM_SEP(*l))
			num++;
	ops=(CIPHER_CHOICE *)Malloc(sizeof(CIPHER_CHOICE)*num);
	if (ops == NULL) goto err;
	memset(ops,0,sizeof(CIPHER_CHOICE)*num);

	/* we now parse the input string and create our operations */
	l=str;
	i=0;
	current_x=0;
d400 21
d423 124
a546 1
		ch= *l;
d548 3
a550 1
		if (ch == '\0') break;
d552 17
d570 1
a570 1
			{ j=CIPHER_DEL; l++; }
d572 1
a572 1
			{ j=CIPHER_ORD; l++; }
d574 5
a578 3
			{ j=CIPHER_KILL; l++; }
		else	
			{ j=CIPHER_ADD; }
d585 2
a586 3
		ops[current_x].type=j;
		ops[current_x].algorithms=0;
		ops[current_x].mask=0;
d591 3
a593 2
			ch= *l;
			i=0;
d603 2
a604 4
				 buf[i]=ch;
				 ch= *(++l);
				 i++;
				 if (i >= (CL_BUF-2)) break;
d606 19
a624 1
			buf[i]='\0';
d635 30
a664 10
			c_tmp.name=buf;
			j=sk_find(ca_list,(char *)&c_tmp);
			if (j < 0)
				goto end_loop;

			cp=(SSL_CIPHER *)sk_value(ca_list,j);
			ops[current_x].algorithms|=cp->algorithms;
			/* We add the SSL_SSL_MASK so we can match the
			 * SSLv2 and SSLv3 versions of RC4-MD5 */
			ops[current_x].mask|=cp->mask;
a666 7
		current_x++;
		if (ch == '\0') break;
end_loop:
		/* Make sure we scan until the next valid start point */
		while ((*l != '\0') && ITEM_SEP(*l))
			l++;
		}
d668 23
a690 26
	num_x=current_x;
	current_x=0;

	/* We will now process the list of ciphers, once for each category, to
	 * decide what we should do with it. */
	for (j=0; j<num_x; j++)
		{
		algorithms=ops[j].algorithms;
		type=ops[j].type;
		mask=ops[j].mask;

		curr=head;
		curr2=head;
		tail2=tail;
		for (;;)
			{
			if ((curr == NULL) || (curr == tail2)) break;
			curr=curr2;
			curr2=curr->next;

			cp=curr->cipher;
			ma=mask & cp->algorithms;
			if ((ma == 0) || ((ma & algorithms) != ma))
				{
				/* does not apply */
				continue;
d692 1
a692 3

			/* add the cipher if it has not been added yet. */
			if (type == CIPHER_ADD)
d694 3
a696 5
				if (!curr->active)
					{
					ll_append_tail(&head,curr,&tail);
					curr->active=1;
					}
d698 1
a698 2
			/* Move the added cipher to this location */
			else if (type == CIPHER_ORD)
d700 2
a701 4
				if (curr->active)
					{
					ll_append_tail(&head,curr,&tail);
					}
d703 1
a703 19
			else if	(type == CIPHER_DEL)
				curr->active=0;
			if (type == CIPHER_KILL)
				{
				if (head == curr)
					head=curr->next;
				else
					curr->prev->next=curr->next;
				if (tail == curr)
					tail=curr->prev;
				curr->active=0;
				if (curr->next != NULL)
					curr->next->prev=curr->prev;
				if (curr->prev != NULL)
					curr->prev->next=curr->next;
				curr->next=NULL;
				curr->prev=NULL;
				}
			}
d706 106
a811 1
	for (curr=head; curr != NULL; curr=curr->next)
d815 1
a815 1
			sk_SSL_CIPHER_push(ret,curr->cipher);
d821 1
d823 8
d835 1
a835 1
		*cipher_list=ret;
d842 1
a842 1
		*cipher_list_by_id=sk_SSL_CIPHER_dup(ret);
d845 9
d858 5
a862 1
		goto err;
d865 1
a865 9
	ok=ret;
	ret=NULL;
err:
	if (tmp_str) Free(tmp_str);
	if (ops != NULL) Free(ops);
	if (ret != NULL) sk_SSL_CIPHER_free(ret);
	if (ca_list != NULL) sk_free(ca_list);
	if (list != NULL) Free(list);
	return(ok);
d873 1
a873 1
	unsigned long alg,alg2;
d877 1
d880 3
a882 3
	is_export=SSL_IS_EXPORT(alg);
	pkl=SSL_EXPORT_PKEYLENGTH(alg);
	kl=SSL_EXPORT_KEYLENGTH(alg);
d1009 1
a1009 1
/* number of bits for symetric cipher */
d1012 1
a1012 4
	int ret=0,a=0;
	const EVP_CIPHER *enc;
	const EVP_MD *md;
	SSL_SESSION ss;
d1016 2
a1017 17
		ss.cipher=c;
		if (!ssl_cipher_get_evp(&ss,&enc,&md,NULL))
			return(0);

		a=EVP_CIPHER_key_length(enc)*8;

		if (SSL_C_IS_EXPORT(c))
			{
			ret=SSL_C_EXPORT_KEYLENGTH(c)*8;
			}
		else
			{
			if (c->algorithm2 & SSL2_CF_8_BYTE_ENC)
				ret=64;
			else
				ret=a;
			}
a1018 3

	if (alg_bits != NULL) *alg_bits=a;
	
@


1.1
log
@Initial revision
@
text
@d60 2
a61 1
#include "objects.h"
d73 1
a73 1
static EVP_CIPHER *ssl_cipher_methods[SSL_ENC_NUM_IDX]={
d77 2
d82 1
a82 1
static EVP_MD *ssl_digest_methods[SSL_MD_NUM_IDX]={
d114 2
a115 1
	{0,SSL_TXT_ALL, 0,SSL_ALL,   0,SSL_ALL},	/* must be first */
d148 7
a154 5
	{0,SSL_TXT_EXP,	0,SSL_EXP,   0,SSL_EXP_MASK},
	{0,SSL_TXT_EXPORT,0,SSL_EXPORT,0,SSL_EXP_MASK},
	{0,SSL_TXT_SSLV2,0,SSL_SSLV2,0,SSL_SSL_MASK},
	{0,SSL_TXT_SSLV3,0,SSL_SSLV3,0,SSL_SSL_MASK},
	{0,SSL_TXT_LOW,  0,SSL_LOW,0,SSL_STRONG_MASK},
d156 1
a156 1
	{0,SSL_TXT_HIGH, 0,SSL_HIGH,0,SSL_STRONG_MASK},
d162 1
a162 2
static int cmp_by_name(a,b)
SSL_CIPHER **a,**b;
d167 1
a167 1
static void load_ciphers()
d187 2
a188 4
int ssl_cipher_get_evp(c,enc,md)
SSL_CIPHER *c;
EVP_CIPHER **enc;
EVP_MD **md;
d191 1
d193 1
d195 24
a239 1
		break;
d281 2
a282 2
static void ll_append_tail(head,curr,tail)
CIPHER_ORDER **head,*curr,**tail;
d297 4
a300 4
STACK *ssl_create_cipher_list(ssl_method,cipher_list,cipher_list_by_id,str)
SSL_METHOD *ssl_method;
STACK **cipher_list,**cipher_list_by_id;
char *str;
d304 1
a304 1
	STACK *ret=NULL,*ok=NULL;
d339 1
a339 1
	if ((ret=(STACK *)sk_new(NULL)) == NULL) goto err;
d353 1
a353 1
#ifndef SSL_ALLOW_ENULL
d403 1
a403 1
	cipher_aliases[0].algorithms= ~mask;
d461 1
d466 3
d576 1
a576 1
			sk_push(ret,(char *)curr->cipher);
d586 1
a586 1
			sk_free(*cipher_list);
d593 2
a594 2
			sk_free(*cipher_list_by_id);
		*cipher_list_by_id=sk_dup(ret);
d602 1
a602 1
	sk_set_cmp_func(*cipher_list_by_id,ssl_cipher_ptr_id_cmp);
d609 1
a609 1
	if (ret != NULL) sk_free(ret);
d615 1
a615 4
char *SSL_CIPHER_description(cipher,buf,len)
SSL_CIPHER *cipher;
char *buf;
int len;
d617 1
a617 1
	int export;
d626 4
a629 2
	export=(alg&SSL_EXP)?1:0;
	exp=(export)?" export":"";
d641 1
a641 1
		kx=(export)?"RSA(512)":"RSA";
d653 1
a653 1
		kx=(export)?"DH(512)":"DH";
d682 1
a682 1
		enc=export?"DES(40)":"DES(56)";
d688 2
a689 1
		enc=export?"RC4(40)":((alg2&SSL2_CF_8_BYTE_ENC)?"RC4(64)":"RC4(128)");
d692 1
a692 1
		enc=export?"RC2(40)":"RC2(128)";
d733 1
a733 2
char *SSL_CIPHER_get_version(c)
SSL_CIPHER *c;
d748 1
a748 2
char *SSL_CIPHER_get_name(c)
SSL_CIPHER *c;
d756 1
a756 3
int SSL_CIPHER_get_bits(c,alg_bits)
SSL_CIPHER *c;
int *alg_bits;
d759 3
a761 2
	EVP_CIPHER *enc;
	EVP_MD *md;
d765 2
a766 1
		if (!ssl_cipher_get_evp(c,&enc,&md))
d771 1
a771 1
		if (c->algorithms & SSL_EXP)
d773 1
a773 1
			ret=40;
d787 47
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d60 1
a60 2
#include <openssl/objects.h>
#include <openssl/comp.h>
d70 1
a70 3
#define SSL_ENC_AES128_IDX	7
#define SSL_ENC_AES256_IDX	8
#define SSL_ENC_NUM_IDX		9
d72 1
a72 1
static const EVP_CIPHER *ssl_cipher_methods[SSL_ENC_NUM_IDX]={
a75 2
static STACK_OF(SSL_COMP) *ssl_comp_methods=NULL;

d79 1
a79 1
static const EVP_MD *ssl_digest_methods[SSL_MD_NUM_IDX]={
d83 6
d93 8
a100 1
#define CIPHER_SPECIAL	5
d110 41
a150 51
static const SSL_CIPHER cipher_aliases[]={
	/* Don't include eNULL unless specifically enabled.
	 * Similarly, don't include AES in ALL because these ciphers are not yet official. */
	{0,SSL_TXT_ALL, 0,SSL_ALL & ~SSL_eNULL & ~SSL_AES, SSL_ALL ,0,0,0,SSL_ALL,SSL_ALL}, /* must be first */
        {0,SSL_TXT_kKRB5,0,SSL_kKRB5,0,0,0,0,SSL_MKEY_MASK,0},  /* VRS Kerberos5 */
	{0,SSL_TXT_kRSA,0,SSL_kRSA,  0,0,0,0,SSL_MKEY_MASK,0},
	{0,SSL_TXT_kDHr,0,SSL_kDHr,  0,0,0,0,SSL_MKEY_MASK,0},
	{0,SSL_TXT_kDHd,0,SSL_kDHd,  0,0,0,0,SSL_MKEY_MASK,0},
	{0,SSL_TXT_kEDH,0,SSL_kEDH,  0,0,0,0,SSL_MKEY_MASK,0},
	{0,SSL_TXT_kFZA,0,SSL_kFZA,  0,0,0,0,SSL_MKEY_MASK,0},
	{0,SSL_TXT_DH,	0,SSL_DH,    0,0,0,0,SSL_MKEY_MASK,0},
	{0,SSL_TXT_EDH,	0,SSL_EDH,   0,0,0,0,SSL_MKEY_MASK|SSL_AUTH_MASK,0},

	{0,SSL_TXT_aKRB5,0,SSL_aKRB5,0,0,0,0,SSL_AUTH_MASK,0},  /* VRS Kerberos5 */
	{0,SSL_TXT_aRSA,0,SSL_aRSA,  0,0,0,0,SSL_AUTH_MASK,0},
	{0,SSL_TXT_aDSS,0,SSL_aDSS,  0,0,0,0,SSL_AUTH_MASK,0},
	{0,SSL_TXT_aFZA,0,SSL_aFZA,  0,0,0,0,SSL_AUTH_MASK,0},
	{0,SSL_TXT_aNULL,0,SSL_aNULL,0,0,0,0,SSL_AUTH_MASK,0},
	{0,SSL_TXT_aDH, 0,SSL_aDH,   0,0,0,0,SSL_AUTH_MASK,0},
	{0,SSL_TXT_DSS,	0,SSL_DSS,   0,0,0,0,SSL_AUTH_MASK,0},

	{0,SSL_TXT_DES,	0,SSL_DES,   0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_3DES,0,SSL_3DES,  0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_RC4,	0,SSL_RC4,   0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_RC2,	0,SSL_RC2,   0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_IDEA,0,SSL_IDEA,  0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_eNULL,0,SSL_eNULL,0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_eFZA,0,SSL_eFZA,  0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_AES,	0,SSL_AES,   0,0,0,0,SSL_ENC_MASK,0},

	{0,SSL_TXT_MD5,	0,SSL_MD5,   0,0,0,0,SSL_MAC_MASK,0},
	{0,SSL_TXT_SHA1,0,SSL_SHA1,  0,0,0,0,SSL_MAC_MASK,0},
	{0,SSL_TXT_SHA,	0,SSL_SHA,   0,0,0,0,SSL_MAC_MASK,0},

	{0,SSL_TXT_NULL,0,SSL_NULL,  0,0,0,0,SSL_ENC_MASK,0},
	{0,SSL_TXT_KRB5,0,SSL_KRB5,  0,0,0,0,SSL_AUTH_MASK|SSL_MKEY_MASK,0},
	{0,SSL_TXT_RSA,	0,SSL_RSA,   0,0,0,0,SSL_AUTH_MASK|SSL_MKEY_MASK,0},
	{0,SSL_TXT_ADH,	0,SSL_ADH,   0,0,0,0,SSL_AUTH_MASK|SSL_MKEY_MASK,0},
	{0,SSL_TXT_FZA,	0,SSL_FZA,   0,0,0,0,SSL_AUTH_MASK|SSL_MKEY_MASK|SSL_ENC_MASK,0},

	{0,SSL_TXT_SSLV2, 0,SSL_SSLV2, 0,0,0,0,SSL_SSL_MASK,0},
	{0,SSL_TXT_SSLV3, 0,SSL_SSLV3, 0,0,0,0,SSL_SSL_MASK,0},
	{0,SSL_TXT_TLSV1, 0,SSL_TLSV1, 0,0,0,0,SSL_SSL_MASK,0},

	{0,SSL_TXT_EXP   ,0, 0,SSL_EXPORT, 0,0,0,0,SSL_EXP_MASK},
	{0,SSL_TXT_EXPORT,0, 0,SSL_EXPORT, 0,0,0,0,SSL_EXP_MASK},
	{0,SSL_TXT_EXP40, 0, 0, SSL_EXP40, 0,0,0,0,SSL_STRONG_MASK},
	{0,SSL_TXT_EXP56, 0, 0, SSL_EXP56, 0,0,0,0,SSL_STRONG_MASK},
	{0,SSL_TXT_LOW,   0, 0,   SSL_LOW, 0,0,0,0,SSL_STRONG_MASK},
	{0,SSL_TXT_MEDIUM,0, 0,SSL_MEDIUM, 0,0,0,0,SSL_STRONG_MASK},
	{0,SSL_TXT_HIGH,  0, 0,  SSL_HIGH, 0,0,0,0,SSL_STRONG_MASK},
d154 1
d156 7
a162 1
static void load_ciphers(void)
a174 4
	ssl_cipher_methods[SSL_ENC_AES128_IDX]=
	  EVP_get_cipherbyname(SN_aes_128_cbc);
	ssl_cipher_methods[SSL_ENC_AES256_IDX]=
	  EVP_get_cipherbyname(SN_aes_256_cbc);
d182 4
a185 2
int ssl_cipher_get_evp(SSL_SESSION *s, const EVP_CIPHER **enc,
	     const EVP_MD **md, SSL_COMP **comp)
a187 1
	SSL_CIPHER *c;
a188 1
	c=s->cipher;
a189 24
	if (comp != NULL)
		{
		SSL_COMP ctmp;

		if (s->compress_meth == 0)
			*comp=NULL;
		else if (ssl_comp_methods == NULL)
			{
			/* bad */
			*comp=NULL;
			}
		else
			{

			ctmp.id=s->compress_meth;
			i=sk_SSL_COMP_find(ssl_comp_methods,&ctmp);
			if (i >= 0)
				*comp=sk_SSL_COMP_value(ssl_comp_methods,i);
			else
				*comp=NULL;
			}
		}

	if ((enc == NULL) || (md == NULL)) return(0);
a210 7
	case SSL_AES:
		switch(c->alg_bits)
			{
		case 128: i=SSL_ENC_AES128_IDX; break;
		case 256: i=SSL_ENC_AES256_IDX; break;
		default: i=-1; break;
			}
d253 2
a254 2
static void ll_append_tail(CIPHER_ORDER **head, CIPHER_ORDER *curr,
	     CIPHER_ORDER **tail)
d269 4
a272 1
static unsigned long ssl_cipher_get_disabled(void)
d274 39
a312 1
	unsigned long mask;
d314 3
a316 6
	mask = SSL_kFZA;
#ifdef OPENSSL_NO_RSA
	mask |= SSL_aRSA|SSL_kRSA;
#endif
#ifdef OPENSSL_NO_DSA
	mask |= SSL_aDSS;
d318 2
a319 2
#ifdef OPENSSL_NO_DH
	mask |= SSL_kDHr|SSL_kDHd|SSL_kEDH|SSL_aDH;
d321 2
a322 2
#ifdef OPENSSL_NO_KRB5
	mask |= SSL_kKRB5|SSL_aKRB5;
d325 2
a326 2
#ifdef SSL_FORBID_ENULL
	mask |= SSL_eNULL;
d329 6
a334 7
	mask |= (ssl_cipher_methods[SSL_ENC_DES_IDX ] == NULL) ? SSL_DES :0;
	mask |= (ssl_cipher_methods[SSL_ENC_3DES_IDX] == NULL) ? SSL_3DES:0;
	mask |= (ssl_cipher_methods[SSL_ENC_RC4_IDX ] == NULL) ? SSL_RC4 :0;
	mask |= (ssl_cipher_methods[SSL_ENC_RC2_IDX ] == NULL) ? SSL_RC2 :0;
	mask |= (ssl_cipher_methods[SSL_ENC_IDEA_IDX] == NULL) ? SSL_IDEA:0;
	mask |= (ssl_cipher_methods[SSL_ENC_eFZA_IDX] == NULL) ? SSL_eFZA:0;
	mask |= (ssl_cipher_methods[SSL_ENC_AES128_IDX] == NULL) ? SSL_AES:0;
d336 2
a337 2
	mask |= (ssl_digest_methods[SSL_MD_MD5_IDX ] == NULL) ? SSL_MD5 :0;
	mask |= (ssl_digest_methods[SSL_MD_SHA1_IDX] == NULL) ? SSL_SHA1:0;
d339 2
a340 16
	return(mask);
	}

static void ssl_cipher_collect_ciphers(const SSL_METHOD *ssl_method,
		int num_of_ciphers, unsigned long mask, CIPHER_ORDER *list,
		CIPHER_ORDER **head_p, CIPHER_ORDER **tail_p)
	{
	int i, list_num;
	SSL_CIPHER *c;

	/*
	 * We have num_of_ciphers descriptions compiled in, depending on the
	 * method selected (SSLv2 and/or SSLv3, TLSv1 etc).
	 * These will later be sorted in a linked list with at most num
	 * entries.
	 */
d343 2
a344 2
	list_num = 0;	/* actual count of ciphers */
	for (i = 0; i < num_of_ciphers; i++)
d346 1
a346 1
		c = ssl_method->get_cipher(i);
d350 4
a353 4
			list[list_num].cipher = c;
			list[list_num].next = NULL;
			list[list_num].prev = NULL;
			list[list_num].active = 0;
a354 4
#ifdef KSSL_DEBUG
			printf("\t%d: %s %lx %lx\n",i,c->name,c->id,c->algorithms);
#endif	/* KSSL_DEBUG */
			/*
a355 1
			*/
d358 2
a359 5

	/*
	 * Prepare linked list from list entries
	 */	
	for (i = 1; i < list_num - 1; i++)
d361 2
a362 2
		list[i].prev = &(list[i-1]);
		list[i].next = &(list[i+1]);
d366 37
a402 44
		(*head_p) = &(list[0]);
		(*head_p)->prev = NULL;
		(*head_p)->next = &(list[1]);
		(*tail_p) = &(list[list_num - 1]);
		(*tail_p)->prev = &(list[list_num - 2]);
		(*tail_p)->next = NULL;
		}
	}

static void ssl_cipher_collect_aliases(SSL_CIPHER **ca_list,
			int num_of_group_aliases, unsigned long mask,
			CIPHER_ORDER *head)
	{
	CIPHER_ORDER *ciph_curr;
	SSL_CIPHER **ca_curr;
	int i;

	/*
	 * First, add the real ciphers as already collected
	 */
	ciph_curr = head;
	ca_curr = ca_list;
	while (ciph_curr != NULL)
		{
		*ca_curr = ciph_curr->cipher;
		ca_curr++;
		ciph_curr = ciph_curr->next;
		}

	/*
	 * Now we add the available ones from the cipher_aliases[] table.
	 * They represent either an algorithm, that must be fully
	 * supported (not match any bit in mask) or represent a cipher
	 * strength value (will be added in any case because algorithms=0).
	 */
	for (i = 0; i < num_of_group_aliases; i++)
		{
		if ((i == 0) ||		/* always fetch "ALL" */
		    !(cipher_aliases[i].algorithms & mask))
			{
			*ca_curr = (SSL_CIPHER *)(cipher_aliases + i);
			ca_curr++;
			}
		}
a403 21
	*ca_curr = NULL;	/* end of list */
	}

static void ssl_cipher_apply_rule(unsigned long algorithms, unsigned long mask,
		unsigned long algo_strength, unsigned long mask_strength,
		int rule, int strength_bits, CIPHER_ORDER *list,
		CIPHER_ORDER **head_p, CIPHER_ORDER **tail_p)
	{
	CIPHER_ORDER *head, *tail, *curr, *curr2, *tail2;
	SSL_CIPHER *cp;
	unsigned long ma, ma_s;

#ifdef CIPHER_DEBUG
	printf("Applying rule %d with %08lx %08lx %08lx %08lx (%d)\n",
		rule, algorithms, mask, algo_strength, mask_strength,
		strength_bits);
#endif

	curr = head = *head_p;
	curr2 = head;
	tail2 = tail = *tail_p;
d406 1
a406 31
		if ((curr == NULL) || (curr == tail2)) break;
		curr = curr2;
		curr2 = curr->next;

		cp = curr->cipher;

		/*
		 * Selection criteria is either the number of strength_bits
		 * or the algorithm used.
		 */
		if (strength_bits == -1)
			{
			ma = mask & cp->algorithms;
			ma_s = mask_strength & cp->algo_strength;

#ifdef CIPHER_DEBUG
			printf("\nName: %s:\nAlgo = %08lx Algo_strength = %08lx\nMask = %08lx Mask_strength %08lx\n", cp->name, cp->algorithms, cp->algo_strength, mask, mask_strength);
			printf("ma = %08lx ma_s %08lx, ma&algo=%08lx, ma_s&algos=%08lx\n", ma, ma_s, ma&algorithms, ma_s&algo_strength);
#endif
			/*
			 * Select: if none of the mask bit was met from the
			 * cipher or not all of the bits were met, the
			 * selection does not apply.
			 */
			if (((ma == 0) && (ma_s == 0)) ||
			    ((ma & algorithms) != ma) ||
			    ((ma_s & algo_strength) != ma_s))
				continue; /* does not apply */
			}
		else if (strength_bits != cp->strength_bits)
			continue;	/* does not apply */
d408 1
a408 111
#ifdef CIPHER_DEBUG
		printf("Action = %d\n", rule);
#endif

		/* add the cipher if it has not been added yet. */
		if (rule == CIPHER_ADD)
			{
			if (!curr->active)
				{
				ll_append_tail(&head, curr, &tail);
				curr->active = 1;
				}
			}
		/* Move the added cipher to this location */
		else if (rule == CIPHER_ORD)
			{
			if (curr->active)
				{
				ll_append_tail(&head, curr, &tail);
				}
			}
		else if	(rule == CIPHER_DEL)
			curr->active = 0;
		else if (rule == CIPHER_KILL)
			{
			if (head == curr)
				head = curr->next;
			else
				curr->prev->next = curr->next;
			if (tail == curr)
				tail = curr->prev;
			curr->active = 0;
			if (curr->next != NULL)
				curr->next->prev = curr->prev;
			if (curr->prev != NULL)
				curr->prev->next = curr->next;
			curr->next = NULL;
			curr->prev = NULL;
			}
		}

	*head_p = head;
	*tail_p = tail;
	}

static int ssl_cipher_strength_sort(CIPHER_ORDER *list, CIPHER_ORDER **head_p,
				     CIPHER_ORDER **tail_p)
	{
	int max_strength_bits, i, *number_uses;
	CIPHER_ORDER *curr;

	/*
	 * This routine sorts the ciphers with descending strength. The sorting
	 * must keep the pre-sorted sequence, so we apply the normal sorting
	 * routine as '+' movement to the end of the list.
	 */
	max_strength_bits = 0;
	curr = *head_p;
	while (curr != NULL)
		{
		if (curr->active &&
		    (curr->cipher->strength_bits > max_strength_bits))
		    max_strength_bits = curr->cipher->strength_bits;
		curr = curr->next;
		}

	number_uses = OPENSSL_malloc((max_strength_bits + 1) * sizeof(int));
	if (!number_uses)
	{
		SSLerr(SSL_F_SSL_CIPHER_STRENGTH_SORT,ERR_R_MALLOC_FAILURE);
		return(0);
	}
	memset(number_uses, 0, (max_strength_bits + 1) * sizeof(int));

	/*
	 * Now find the strength_bits values actually used
	 */
	curr = *head_p;
	while (curr != NULL)
		{
		if (curr->active)
			number_uses[curr->cipher->strength_bits]++;
		curr = curr->next;
		}
	/*
	 * Go through the list of used strength_bits values in descending
	 * order.
	 */
	for (i = max_strength_bits; i >= 0; i--)
		if (number_uses[i] > 0)
			ssl_cipher_apply_rule(0, 0, 0, 0, CIPHER_ORD, i,
					list, head_p, tail_p);

	OPENSSL_free(number_uses);
	return(1);
	}

static int ssl_cipher_process_rulestr(const char *rule_str,
		CIPHER_ORDER *list, CIPHER_ORDER **head_p,
		CIPHER_ORDER **tail_p, SSL_CIPHER **ca_list)
	{
	unsigned long algorithms, mask, algo_strength, mask_strength;
	const char *l, *start, *buf;
	int j, multi, found, rule, retval, ok, buflen;
	char ch;

	retval = 1;
	l = rule_str;
	for (;;)
		{
		ch = *l;
a409 2
		if (ch == '\0')
			break;		/* done */
d411 1
a411 1
			{ rule = CIPHER_DEL; l++; }
d413 1
a413 1
			{ rule = CIPHER_ORD; l++; }
d415 3
a417 5
			{ rule = CIPHER_KILL; l++; }
		else if (ch == '@@')
			{ rule = CIPHER_SPECIAL; l++; }
		else
			{ rule = CIPHER_ADD; }
d424 3
a426 2

		algorithms = mask = algo_strength = mask_strength = 0;
d431 2
a432 4
			ch = *l;
			buf = l;
			buflen = 0;
#ifndef CHARSET_EBCDIC
a436 3
#else
			while (	isalnum(ch) || (ch == '-'))
#endif
d438 4
a441 2
				 ch = *(++l);
				 buflen++;
d443 1
d445 2
a446 1
			if (buflen == 0)
d448 1
a448 8
				/*
				 * We hit something we cannot deal with,
				 * it is no command or separator nor
				 * alphanumeric, so we call this an error.
				 */
				SSLerr(SSL_F_SSL_CIPHER_PROCESS_RULESTR,
				       SSL_R_INVALID_COMMAND);
				retval = found = 0;
a449 1
				break;
d451 22
d474 23
a496 1
			if (rule == CIPHER_SPECIAL)
d498 2
a499 2
				found = 0; /* unused -- avoid compiler warning */
				break;	/* special treatment */
d502 2
a503 2
			/* check for multi-part specification */
			if (ch == '+')
d505 5
a509 2
				multi=1;
				l++;
d511 2
a512 15
			else
				multi=0;

			/*
			 * Now search for the cipher alias in the ca_list. Be careful
			 * with the strncmp, because the "buflen" limitation
			 * will make the rule "ADH:SOME" and the cipher
			 * "ADH-MY-CIPHER" look like a match for buflen=3.
			 * So additionally check whether the cipher name found
			 * has the correct length. We can save a strlen() call:
			 * just checking for the '\0' at the right place is
			 * sufficient, we have to strncmp() anyway.
			 */
			 j = found = 0;
			 while (ca_list[j])
d514 1
a514 2
				if ((ca_list[j]->name[buflen] == '\0') &&
				    !strncmp(buf, ca_list[j]->name, buflen))
d516 1
a516 2
					found = 1;
					break;
d518 7
d526 10
a535 1
					j++;
a536 9
			if (!found)
				break;	/* ignore this entry */

			algorithms |= ca_list[j]->algorithms;
			mask |= ca_list[j]->mask;
			algo_strength |= ca_list[j]->algo_strength;
			mask_strength |= ca_list[j]->mask_strength;

			if (!multi) break;
a537 81

		/*
		 * Ok, we have the rule, now apply it
		 */
		if (rule == CIPHER_SPECIAL)
			{	/* special command */
			ok = 0;
			if ((buflen == 8) &&
				!strncmp(buf, "STRENGTH", 8))
				ok = ssl_cipher_strength_sort(list,
					head_p, tail_p);
			else
				SSLerr(SSL_F_SSL_CIPHER_PROCESS_RULESTR,
					SSL_R_INVALID_COMMAND);
			if (ok == 0)
				retval = 0;
			/*
			 * We do not support any "multi" options
			 * together with "@@", so throw away the
			 * rest of the command, if any left, until
			 * end or ':' is found.
			 */
			while ((*l != '\0') && ITEM_SEP(*l))
				l++;
			}
		else if (found)
			{
			ssl_cipher_apply_rule(algorithms, mask,
				algo_strength, mask_strength, rule, -1,
				list, head_p, tail_p);
			}
		else
			{
			while ((*l != '\0') && ITEM_SEP(*l))
				l++;
			}
		if (*l == '\0') break; /* done */
		}

	return(retval);
	}

STACK_OF(SSL_CIPHER) *ssl_create_cipher_list(const SSL_METHOD *ssl_method,
		STACK_OF(SSL_CIPHER) **cipher_list,
		STACK_OF(SSL_CIPHER) **cipher_list_by_id,
		const char *rule_str)
	{
	int ok, num_of_ciphers, num_of_alias_max, num_of_group_aliases;
	unsigned long disabled_mask;
	STACK_OF(SSL_CIPHER) *cipherstack;
	const char *rule_p;
	CIPHER_ORDER *list = NULL, *head = NULL, *tail = NULL, *curr;
	SSL_CIPHER **ca_list = NULL;

	/*
	 * Return with error if nothing to do.
	 */
	if (rule_str == NULL) return(NULL);

	if (init_ciphers) load_ciphers();

	/*
	 * To reduce the work to do we only want to process the compiled
	 * in algorithms, so we first get the mask of disabled ciphers.
	 */
	disabled_mask = ssl_cipher_get_disabled();

	/*
	 * Now we have to collect the available ciphers from the compiled
	 * in ciphers. We cannot get more than the number compiled in, so
	 * it is used for allocation.
	 */
	num_of_ciphers = ssl_method->num_ciphers();
#ifdef KSSL_DEBUG
	printf("ssl_create_cipher_list() for %d ciphers\n", num_of_ciphers);
#endif    /* KSSL_DEBUG */
	list = (CIPHER_ORDER *)OPENSSL_malloc(sizeof(CIPHER_ORDER) * num_of_ciphers);
	if (list == NULL)
		{
		SSLerr(SSL_F_SSL_CREATE_CIPHER_LIST,ERR_R_MALLOC_FAILURE);
		return(NULL);	/* Failure */
d540 1
a540 65
	ssl_cipher_collect_ciphers(ssl_method, num_of_ciphers, disabled_mask,
				   list, &head, &tail);

	/*
	 * We also need cipher aliases for selecting based on the rule_str.
	 * There might be two types of entries in the rule_str: 1) names
	 * of ciphers themselves 2) aliases for groups of ciphers.
	 * For 1) we need the available ciphers and for 2) the cipher
	 * groups of cipher_aliases added together in one list (otherwise
	 * we would be happy with just the cipher_aliases table).
	 */
	num_of_group_aliases = sizeof(cipher_aliases) / sizeof(SSL_CIPHER);
	num_of_alias_max = num_of_ciphers + num_of_group_aliases + 1;
	ca_list =
		(SSL_CIPHER **)OPENSSL_malloc(sizeof(SSL_CIPHER *) * num_of_alias_max);
	if (ca_list == NULL)
		{
		OPENSSL_free(list);
		SSLerr(SSL_F_SSL_CREATE_CIPHER_LIST,ERR_R_MALLOC_FAILURE);
		return(NULL);	/* Failure */
		}
	ssl_cipher_collect_aliases(ca_list, num_of_group_aliases, disabled_mask,
				   head);

	/*
	 * If the rule_string begins with DEFAULT, apply the default rule
	 * before using the (possibly available) additional rules.
	 */
	ok = 1;
	rule_p = rule_str;
	if (strncmp(rule_str,"DEFAULT",7) == 0)
		{
		ok = ssl_cipher_process_rulestr(SSL_DEFAULT_CIPHER_LIST,
			list, &head, &tail, ca_list);
		rule_p += 7;
		if (*rule_p == ':')
			rule_p++;
		}

	if (ok && (strlen(rule_p) > 0))
		ok = ssl_cipher_process_rulestr(rule_p, list, &head, &tail,
						ca_list);

	OPENSSL_free(ca_list);	/* Not needed anymore */

	if (!ok)
		{	/* Rule processing failure */
		OPENSSL_free(list);
		return(NULL);
		}
	/*
	 * Allocate new "cipherstack" for the result, return with error
	 * if we cannot get one.
	 */
	if ((cipherstack = sk_SSL_CIPHER_new_null()) == NULL)
		{
		OPENSSL_free(list);
		return(NULL);
		}

	/*
	 * The cipher selection for the list is done. The ciphers are added
	 * to the resulting precedence to the STACK_OF(SSL_CIPHER).
	 */
	for (curr = head; curr != NULL; curr = curr->next)
d544 1
a544 1
			sk_SSL_CIPHER_push(cipherstack, curr->cipher);
a549 1
	OPENSSL_free(list);	/* Not needed any longer */
a550 8
	/*
	 * The following passage is a little bit odd. If pointer variables
	 * were supplied to hold STACK_OF(SSL_CIPHER) return information,
	 * the old memory pointed to is free()ed. Then, however, the
	 * cipher_list entry will be assigned just a copy of the returned
	 * cipher stack. For cipher_list_by_id a copy of the cipher stack
	 * will be created. See next comment...
	 */
d554 2
a555 2
			sk_SSL_CIPHER_free(*cipher_list);
		*cipher_list = cipherstack;
d561 2
a562 2
			sk_SSL_CIPHER_free(*cipher_list_by_id);
		*cipher_list_by_id = sk_SSL_CIPHER_dup(cipherstack);
a564 9
	/*
	 * Now it is getting really strange. If something failed during
	 * the previous pointer assignment or if one of the pointers was
	 * not requested, the error condition is met. That might be
	 * discussable. The strange thing is however that in this case
	 * the memory "ret" pointed to is "free()ed" and hence the pointer
	 * cipher_list becomes wild. The memory reserved for
	 * cipher_list_by_id however is not "free()ed" and stays intact.
	 */
d569 2
a570 6
		{
		sk_SSL_CIPHER_free(cipherstack);
		return(NULL);
		}

	sk_SSL_CIPHER_set_cmp_func(*cipher_list_by_id,ssl_cipher_ptr_id_cmp);
d572 15
a586 4
	return(cipherstack);
	}

char *SSL_CIPHER_description(SSL_CIPHER *cipher, char *buf, int len)
d588 1
a588 1
	int is_export,pkl,kl;
d591 1
a591 4
	unsigned long alg,alg2,alg_s;
#ifdef KSSL_DEBUG
	static char *format="%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s%s AL=%lx\n";
#else
d593 1
a593 2
#endif /* KSSL_DEBUG */

a594 1
	alg_s=cipher->algo_strength;
d597 2
a598 4
	is_export=SSL_C_IS_EXPORT(cipher);
	pkl=SSL_C_EXPORT_PKEYLENGTH(cipher);
	kl=SSL_C_EXPORT_KEYLENGTH(cipher);
	exp=is_export?" export":"";
d610 1
a610 1
		kx=is_export?(pkl == 512 ? "RSA(512)" : "RSA(1024)"):"RSA";
a617 4
        case SSL_kKRB5:         /* VRS */
        case SSL_KRB5:          /* VRS */
            kx="KRB5";
            break;
d622 1
a622 1
		kx=is_export?(pkl == 512 ? "DH(512)" : "DH(1024)"):"DH";
a638 4
        case SSL_aKRB5:         /* VRS */
        case SSL_KRB5:          /* VRS */
            au="KRB5";
            break;
d651 1
a651 1
		enc=(is_export && kl == 5)?"DES(40)":"DES(56)";
d657 1
a657 2
		enc=is_export?(kl == 5 ? "RC4(40)" : "RC4(56)")
		  :((alg2&SSL2_CF_8_BYTE_ENC)?"RC4(64)":"RC4(128)");
d660 1
a660 1
		enc=is_export?(kl == 5 ? "RC2(40)" : "RC2(56)"):"RC2(128)";
a670 9
	case SSL_AES:
		switch(cipher->strength_bits)
			{
		case 128: enc="AESdraft(128)"; break;
		case 192: enc="AESdraft(192)"; break;
		case 256: enc="AESdraft(256)"; break;
		default: enc="AESdraft(?""?""?)"; break;
			}
		break;
d691 2
a692 3
		len=128;
		buf=OPENSSL_malloc(len);
		if (buf == NULL) return("OPENSSL_malloc Error");
d697 1
a697 5
#ifdef KSSL_DEBUG
	BIO_snprintf(buf,len,format,cipher->name,ver,kx,au,enc,mac,exp,alg);
#else
	BIO_snprintf(buf,len,format,cipher->name,ver,kx,au,enc,mac,exp);
#endif /* KSSL_DEBUG */
d701 2
a702 1
char *SSL_CIPHER_get_version(SSL_CIPHER *c)
d717 2
a718 1
const char *SSL_CIPHER_get_name(SSL_CIPHER *c)
d725 8
a732 4
/* number of bits for symmetric cipher */
int SSL_CIPHER_get_bits(SSL_CIPHER *c, int *alg_bits)
	{
	int ret=0;
d736 2
a737 5
		if (alg_bits != NULL) *alg_bits = c->alg_bits;
		ret = c->strength_bits;
		}
	return(ret);
	}
d739 1
a739 4
SSL_COMP *ssl3_comp_find(STACK_OF(SSL_COMP) *sk, int n)
	{
	SSL_COMP *ctmp;
	int i,nn;
d741 11
a751 7
	if ((n == 0) || (sk == NULL)) return(NULL);
	nn=sk_SSL_COMP_num(sk);
	for (i=0; i<nn; i++)
		{
		ctmp=sk_SSL_COMP_value(sk,i);
		if (ctmp->id == n)
			return(ctmp);
a752 2
	return(NULL);
	}
d754 3
a756 9
static int sk_comp_cmp(const SSL_COMP * const *a,
			const SSL_COMP * const *b)
	{
	return((*a)->id-(*b)->id);
	}

STACK_OF(SSL_COMP) *SSL_COMP_get_compression_methods(void)
	{
	return(ssl_comp_methods);
a758 28
int SSL_COMP_add_compression_method(int id, COMP_METHOD *cm)
	{
	SSL_COMP *comp;
	STACK_OF(SSL_COMP) *sk;

        if (cm == NULL || cm->type == NID_undef)
                return 1;

	MemCheck_off();
	comp=(SSL_COMP *)OPENSSL_malloc(sizeof(SSL_COMP));
	comp->id=id;
	comp->method=cm;
	if (ssl_comp_methods == NULL)
		sk=ssl_comp_methods=sk_SSL_COMP_new(sk_comp_cmp);
	else
		sk=ssl_comp_methods;
	if ((sk == NULL) || !sk_SSL_COMP_push(sk,comp))
		{
		MemCheck_on();
		SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	else
		{
		MemCheck_on();
		return(1);
		}
	}
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d103 3
a105 4
	/* Don't include eNULL unless specifically enabled. */
	{0,SSL_TXT_ALL, 0,SSL_ALL & ~SSL_eNULL, SSL_ALL ,0,0,0,SSL_ALL,SSL_ALL}, /* must be first */
        {0,SSL_TXT_CMPALL,0,SSL_eNULL,0,0,0,0,SSL_ENC_MASK,0},  /* COMPLEMENT OF ALL */
	{0,SSL_TXT_CMPDEF,0,SSL_ADH, 0,0,0,0,SSL_AUTH_MASK,0},
d1002 4
a1005 4
		case 128: enc="AES(128)"; break;
		case 192: enc="AES(192)"; break;
		case 256: enc="AES(256)"; break;
		default: enc="AES(?""?""?)"; break;
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d671 1
a671 2
			 * sufficient, we have to strncmp() anyway. (We cannot
			 * use strcmp(), because buf is not '\0' terminated.)
d676 2
a677 2
				if (!strncmp(buf, ca_list[j]->name, buflen) &&
				    (ca_list[j]->name[buflen] == '\0'))
d754 1
a754 6
	if (init_ciphers)
		{
		CRYPTO_w_lock(CRYPTO_LOCK_SSL);
		if (init_ciphers) load_ciphers();
		CRYPTO_w_unlock(CRYPTO_LOCK_SSL);
		}
@


1.1.1.5
log
@import openssl-0.9.7d
@
text
@a127 1
#ifndef OPENSSL_NO_IDEA
a128 1
#endif
a168 1
#ifndef OPENSSL_NO_IDEA
a170 3
#else
	ssl_cipher_methods[SSL_ENC_IDEA_IDX]= NULL;
#endif
d337 1
a337 1
		int num_of_ciphers, unsigned long mask, CIPHER_ORDER *co_list,
d340 1
a340 1
	int i, co_list_num;
d351 1
a351 1
	co_list_num = 0;	/* actual count of ciphers */
d358 5
a362 5
			co_list[co_list_num].cipher = c;
			co_list[co_list_num].next = NULL;
			co_list[co_list_num].prev = NULL;
			co_list[co_list_num].active = 0;
			co_list_num++;
d375 1
a375 1
	for (i = 1; i < co_list_num - 1; i++)
d377 2
a378 2
		co_list[i].prev = &(co_list[i-1]);
		co_list[i].next = &(co_list[i+1]);
d380 1
a380 1
	if (co_list_num > 0)
d382 1
a382 1
		(*head_p) = &(co_list[0]);
d384 3
a386 3
		(*head_p)->next = &(co_list[1]);
		(*tail_p) = &(co_list[co_list_num - 1]);
		(*tail_p)->prev = &(co_list[co_list_num - 2]);
d432 1
a432 1
		int rule, int strength_bits, CIPHER_ORDER *co_list,
d527 2
a528 3
static int ssl_cipher_strength_sort(CIPHER_ORDER *co_list,
				    CIPHER_ORDER **head_p,
				    CIPHER_ORDER **tail_p)
d573 1
a573 1
					co_list, head_p, tail_p);
d580 1
a580 1
		CIPHER_ORDER *co_list, CIPHER_ORDER **head_p,
d705 1
a705 1
				ok = ssl_cipher_strength_sort(co_list,
d725 1
a725 1
				co_list, head_p, tail_p);
d747 1
a747 1
	CIPHER_ORDER *co_list = NULL, *head = NULL, *tail = NULL, *curr;
d777 2
a778 2
	co_list = (CIPHER_ORDER *)OPENSSL_malloc(sizeof(CIPHER_ORDER) * num_of_ciphers);
	if (co_list == NULL)
d785 1
a785 1
				   co_list, &head, &tail);
d801 1
a801 1
		OPENSSL_free(co_list);
d817 1
a817 1
			co_list, &head, &tail, ca_list);
d824 1
a824 1
		ok = ssl_cipher_process_rulestr(rule_p, co_list, &head, &tail,
d831 1
a831 1
		OPENSSL_free(co_list);
d840 1
a840 1
		OPENSSL_free(co_list);
d858 1
a858 1
	OPENSSL_free(co_list);	/* Not needed any longer */
d908 1
a908 1
	char *ver,*exp_str;
d924 1
a924 1
	exp_str=is_export?" export":"";
d1043 1
a1043 1
	BIO_snprintf(buf,len,format,cipher->name,ver,kx,au,enc,mac,exp_str,alg);
d1045 1
a1045 1
	BIO_snprintf(buf,len,format,cipher->name,ver,kx,au,enc,mac,exp_str);
d1132 1
a1132 1
		return(1);
d1137 1
a1137 1
		return(0);
@


1.1.1.6
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a61 1
#include <openssl/fips.h>
a155 1
	{0,SSL_TXT_FIPS,  0, 0,  SSL_FIPS, 0,0,0,0,SSL_FIPS|SSL_STRONG_NONE},
d162 1
a185 1
	init_ciphers=0;
d188 1
a188 1
int ssl_cipher_get_evp(const SSL_SESSION *s, const EVP_CIPHER **enc,
a361 4
#ifdef OPENSSL_FIPS
		if ((c != NULL) && c->valid && !(c->algorithms & mask)
			&& (!FIPS_mode() || (c->algo_strength & SSL_FIPS)))
#else
a362 1
#endif
a856 3
#ifdef OPENSSL_FIPS
		if (curr->active && (!FIPS_mode() || curr->cipher->algo_strength & SSL_FIPS))
#else
a857 1
#endif
d1057 1
a1057 1
char *SSL_CIPHER_get_version(const SSL_CIPHER *c)
d1072 1
a1072 1
const char *SSL_CIPHER_get_name(const SSL_CIPHER *c)
d1080 1
a1080 1
int SSL_CIPHER_get_bits(const SSL_CIPHER *c, int *alg_bits)
@


1.1.1.7
log
@import of openssl-0.9.7j
@
text
@d703 1
a703 8
			/* New algorithms:
			 *  1 - any old restrictions apply outside new mask
			 *  2 - any new restrictions apply outside old mask
			 *  3 - enforce old & new where masks intersect
			 */
			algorithms = (algorithms & ~ca_list[j]->mask) |		/* 1 */
			             (ca_list[j]->algorithms & ~mask) |		/* 2 */
			             (algorithms & ca_list[j]->algorithms);	/* 3 */
d705 1
a705 3
			algo_strength = (algo_strength & ~ca_list[j]->mask_strength) |
			                (ca_list[j]->algo_strength & ~mask_strength) |
			                (algo_strength & ca_list[j]->algo_strength);
d759 1
a759 1
	STACK_OF(SSL_CIPHER) *cipherstack, *tmp_cipher_list;
d767 1
a767 2
	if (rule_str == NULL || cipher_list == NULL || cipher_list_by_id == NULL)
		return NULL;
d878 35
a912 2
	tmp_cipher_list = sk_SSL_CIPHER_dup(cipherstack);
	if (tmp_cipher_list == NULL)
d915 1
a915 1
		return NULL;
d917 1
a917 6
	if (*cipher_list != NULL)
		sk_SSL_CIPHER_free(*cipher_list);
	*cipher_list = cipherstack;
	if (*cipher_list_by_id != NULL)
		sk_SSL_CIPHER_free(*cipher_list_by_id);
	*cipher_list_by_id = tmp_cipher_list;
@


1.1.1.8
log
@import of OpenSSL 0.9.8h
@
text
@d58 1
a58 58
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
d62 1
d74 1
a74 5
#define SSL_ENC_CAMELLIA128_IDX	9
#define SSL_ENC_CAMELLIA256_IDX	10
#define SSL_ENC_SEED_IDX    	11
#define SSL_ENC_NUM_IDX		12

a79 4
#define SSL_COMP_NULL_IDX	0
#define SSL_COMP_ZLIB_IDX	1
#define SSL_COMP_NUM_IDX	2

d105 2
a106 4
	/* Don't include ECC in ALL because these ciphers are not yet official. */
	{0,SSL_TXT_ALL, 0,SSL_ALL & ~SSL_eNULL & ~SSL_kECDH & ~SSL_kECDHE, SSL_ALL ,0,0,0,SSL_ALL,SSL_ALL}, /* must be first */
	/* TODO: COMPLEMENT OF ALL and COMPLEMENT OF DEFAULT do not have ECC cipher suites handled properly. */
	{0,SSL_TXT_CMPALL,0,SSL_eNULL,0,0,0,0,SSL_ENC_MASK,0},  /* COMPLEMENT OF ALL */
d108 1
a108 1
	{0,SSL_TXT_kKRB5,0,SSL_kKRB5,0,0,0,0,SSL_MKEY_MASK,0},  /* VRS Kerberos5 */
a114 1
	{0,SSL_TXT_ECC,	0,(SSL_kECDH|SSL_kECDHE), 0,0,0,0,SSL_MKEY_MASK,0},
d116 1
a131 1
	{0,SSL_TXT_SEED,0,SSL_SEED,  0,0,0,0,SSL_ENC_MASK,0},
a134 1
	{0,SSL_TXT_CAMELLIA,0,SSL_CAMELLIA, 0,0,0,0,SSL_ENC_MASK,0},
d157 1
d160 3
a162 1
void ssl_load_ciphers(void)
a181 6
	ssl_cipher_methods[SSL_ENC_CAMELLIA128_IDX]=
	  EVP_get_cipherbyname(SN_camellia_128_cbc);
	ssl_cipher_methods[SSL_ENC_CAMELLIA256_IDX]=
	  EVP_get_cipherbyname(SN_camellia_256_cbc);
	ssl_cipher_methods[SSL_ENC_SEED_IDX]=
	  EVP_get_cipherbyname(SN_seed_cbc);
d187 1
a189 54

#ifndef OPENSSL_NO_COMP

static int sk_comp_cmp(const SSL_COMP * const *a,
			const SSL_COMP * const *b)
	{
	return((*a)->id-(*b)->id);
	}

static void load_builtin_compressions(void)
	{
	int got_write_lock = 0;

	CRYPTO_r_lock(CRYPTO_LOCK_SSL);
	if (ssl_comp_methods == NULL)
		{
		CRYPTO_r_unlock(CRYPTO_LOCK_SSL);
		CRYPTO_w_lock(CRYPTO_LOCK_SSL);
		got_write_lock = 1;
		
		if (ssl_comp_methods == NULL)
			{
			SSL_COMP *comp = NULL;

			MemCheck_off();
			ssl_comp_methods=sk_SSL_COMP_new(sk_comp_cmp);
			if (ssl_comp_methods != NULL)
				{
				comp=(SSL_COMP *)OPENSSL_malloc(sizeof(SSL_COMP));
				if (comp != NULL)
					{
					comp->method=COMP_zlib();
					if (comp->method
						&& comp->method->type == NID_undef)
						OPENSSL_free(comp);
					else
						{
						comp->id=SSL_COMP_ZLIB_IDX;
						comp->name=comp->method->name;
						sk_SSL_COMP_push(ssl_comp_methods,comp);
						}
					}
				}
			MemCheck_on();
			}
		}
	
	if (got_write_lock)
		CRYPTO_w_unlock(CRYPTO_LOCK_SSL);
	else
		CRYPTO_r_unlock(CRYPTO_LOCK_SSL);
	}
#endif

a200 3
#ifndef OPENSSL_NO_COMP
		load_builtin_compressions();
#endif
d202 8
a209 3
		*comp=NULL;
		ctmp.id=s->compress_meth;
		if (ssl_comp_methods != NULL)
d211 2
a250 12
	case SSL_CAMELLIA:
		switch(c->alg_bits)
			{
		case 128: i=SSL_ENC_CAMELLIA128_IDX; break;
		case 256: i=SSL_ENC_CAMELLIA256_IDX; break;
		default: i=-1; break;
			}
		break;
	case SSL_SEED:
		i=SSL_ENC_SEED_IDX;
		break;

d308 1
a308 8
struct disabled_masks { /* This is a kludge no longer needed with OpenSSL 0.9.9,
                         * where 128-bit and 256-bit algorithms simply will get
                         * separate bits. */
  unsigned long mask; /* everything except m256 */
  unsigned long m256; /* applies to 256-bit algorithms only */
};

static struct disabled_masks ssl_cipher_get_disabled(void)
a310 2
	unsigned long m256;
	struct disabled_masks ret;
d325 1
a325 3
#ifdef OPENSSL_NO_ECDH
	mask |= SSL_kECDH|SSL_kECDHE;
#endif
d336 1
a336 1
	mask |= (ssl_cipher_methods[SSL_ENC_SEED_IDX] == NULL) ? SSL_SEED:0;
d341 1
a341 10
	/* finally consider algorithms where mask and m256 differ */
	m256 = mask;
	mask |= (ssl_cipher_methods[SSL_ENC_AES128_IDX] == NULL) ? SSL_AES:0;
	mask |= (ssl_cipher_methods[SSL_ENC_CAMELLIA128_IDX] == NULL) ? SSL_CAMELLIA:0;
	m256 |= (ssl_cipher_methods[SSL_ENC_AES256_IDX] == NULL) ? SSL_AES:0;
	m256 |= (ssl_cipher_methods[SSL_ENC_CAMELLIA256_IDX] == NULL) ? SSL_CAMELLIA:0;

	ret.mask = mask;
	ret.m256 = m256;
	return ret;
d345 2
a346 3
		int num_of_ciphers, unsigned long mask, unsigned long m256,
		CIPHER_ORDER *co_list, CIPHER_ORDER **head_p,
		CIPHER_ORDER **tail_p)
a362 1
#define IS_MASKED(c) ((c)->algorithms & (((c)->alg_bits == 256) ? m256 : mask))
d364 6
a369 1
		if ((c != NULL) && c->valid && !IS_MASKED(c))
d443 1
a443 2
static void ssl_cipher_apply_rule(unsigned long cipher_id, unsigned long ssl_version,
		unsigned long algorithms, unsigned long mask,
a468 9
		/* If explicit cipher suite, match only that one for its own protocol version.
		 * Usual selection criteria will be used for similar ciphersuites from other version! */

		if (cipher_id && (cp->algorithms & SSL_SSL_MASK) == ssl_version)
			{
			if (cp->id != cipher_id)
				continue;
			}

d473 1
a473 1
		else if (strength_bits == -1)
d504 2
a505 16
				int add_this_cipher = 1;

				if (((cp->algorithms & (SSL_kECDHE|SSL_kECDH|SSL_aECDSA)) != 0))
					{
					/* Make sure "ECCdraft" ciphersuites are activated only if
					 * *explicitly* requested, but not implicitly (such as
					 * as part of the "AES" alias). */

					add_this_cipher = (mask & (SSL_kECDHE|SSL_kECDH|SSL_aECDSA)) != 0 || cipher_id != 0;
					}
				
				if (add_this_cipher)
					{
					ll_append_tail(&head, curr, &tail);
					curr->active = 1;
					}
d586 1
a586 1
			ssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, CIPHER_ORD, i,
a599 1
	unsigned long cipher_id = 0, ssl_version = 0;
a688 2
			 cipher_id = 0;
			 ssl_version = 0;
a716 8
			/* explicit ciphersuite found */
			if (ca_list[j]->valid)
				{
				cipher_id = ca_list[j]->id;
				ssl_version = ca_list[j]->algorithms & SSL_SSL_MASK;
				break;
				}

d741 1
a741 1
			while ((*l != '\0') && !ITEM_SEP(*l))
d746 1
a746 1
			ssl_cipher_apply_rule(cipher_id, ssl_version, algorithms, mask,
d752 1
a752 1
			while ((*l != '\0') && !ITEM_SEP(*l))
a767 1
	unsigned long disabled_m256;
d779 7
d790 1
a790 6
	{
		struct disabled_masks d;
		d = ssl_cipher_get_disabled();
		disabled_mask = d.mask;
		disabled_m256 = d.m256;
	}
d809 1
a809 1
				   disabled_m256, co_list, &head, &tail);
d829 2
a830 2
	ssl_cipher_collect_aliases(ca_list, num_of_group_aliases,
				   (disabled_mask & disabled_m256), head);
d874 3
d878 1
d900 1
a900 1
	(void)sk_SSL_CIPHER_set_cmp_func(*cipher_list_by_id,ssl_cipher_ptr_id_cmp);
d908 2
a909 2
	const char *ver,*exp_str;
	const char *kx,*au,*enc,*mac;
d912 1
a912 1
	static const char *format="%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s%s AL=%lx\n";
d914 1
a914 1
	static const char *format="%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s%s\n";
d925 1
a925 1
	
a953 4
	case SSL_kECDH:
	case SSL_kECDHE:
		kx=is_export?"ECDH(<=163)":"ECDH";
		break;
a976 3
	case SSL_aECDSA:
		au="ECDSA";
		break;
a1014 12
	case SSL_CAMELLIA:
		switch(cipher->strength_bits)
			{
		case 128: enc="Camellia(128)"; break;
		case 256: enc="Camellia(256)"; break;
		default: enc="Camellia(?""?""?)"; break;
			}
		break;
	case SSL_SEED:
		enc="SEED(128)";
		break;

d1101 2
a1102 2
#ifdef OPENSSL_NO_COMP
void *SSL_COMP_get_compression_methods(void)
d1104 1
a1104 5
	return NULL;
	}
int SSL_COMP_add_compression_method(int id, void *cm)
	{
	return 1;
a1106 5
const char *SSL_COMP_get_name(const void *comp)
	{
	return NULL;
	}
#else
a1108 1
	load_builtin_compressions();
d1115 1
a1119 12
	/* According to draft-ietf-tls-compression-04.txt, the
	   compression number ranges should be the following:

	   0 to 63:    methods defined by the IETF
	   64 to 192:  external party methods assigned by IANA
	   193 to 255: reserved for private use */
	if (id < 193 || id > 255)
		{
		SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD,SSL_R_COMPRESSION_ID_NOT_WITHIN_PRIVATE_RANGE);
		return 0;
		}

d1124 5
a1128 3
	load_builtin_compressions();
	if (ssl_comp_methods
		&& !sk_SSL_COMP_find(ssl_comp_methods,comp))
a1129 9
		OPENSSL_free(comp);
		MemCheck_on();
		SSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD,SSL_R_DUPLICATE_COMPRESSION_ID);
		return(1);
		}
	else if ((ssl_comp_methods == NULL)
		|| !sk_SSL_COMP_push(ssl_comp_methods,comp))
		{
		OPENSSL_free(comp);
a1139 9

const char *SSL_COMP_get_name(const COMP_METHOD *comp)
	{
	if (comp)
		return comp->name;
	return NULL;
	}

#endif
@


1.1.1.9
log
@import openssl-0.9.8j
@
text
@a117 1
#ifndef OPENSSL_NO_COMP
a118 2
#endif

a224 1
	{0,SSL_TXT_FIPS,  0, 0,  SSL_FIPS, 0,0,0,0,SSL_FIPS|SSL_STRONG_NONE},
a517 4
#ifdef OPENSSL_FIPS
		if ((c != NULL) && c->valid && !IS_MASKED(c)
			&& (!FIPS_mode() || (c->algo_strength & SSL_FIPS)))
#else
a518 1
#endif
a1056 3
#ifdef OPENSSL_FIPS
		if (curr->active && (!FIPS_mode() || curr->cipher->algo_strength & SSL_FIPS))
#else
a1057 1
#endif
@


1.1.1.10
log
@import of OpenSSL 0.9.8k
@
text
@d1358 1
a1358 1
		&& sk_SSL_COMP_find(ssl_comp_methods,comp) >= 0)
@


1.1.1.11
log
@import OpenSSL-1.0.0a
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
a115 27
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */

d121 1
a121 3
#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif
d129 6
a134 6
#define SSL_ENC_NULL_IDX	5
#define SSL_ENC_AES128_IDX	6
#define SSL_ENC_AES256_IDX	7
#define SSL_ENC_CAMELLIA128_IDX	8
#define SSL_ENC_CAMELLIA256_IDX	9
#define SSL_ENC_GOST89_IDX	10
d140 1
a140 1
	NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
d151 1
a151 6
#define SSL_MD_GOST94_IDX 2
#define SSL_MD_GOST89MAC_IDX 3
/*Constant SSL_MAX_DIGEST equal to size of digests array should be 
 * defined in the
 * ssl_locl.h */
#define SSL_MD_NUM_IDX	SSL_MAX_DIGEST 
d153 1
a153 17
	NULL,NULL,NULL,NULL
	};
/* PKEY_TYPE for GOST89MAC is known in advance, but, because
 * implementation is engine-provided, we'll fill it only if
 * corresponding EVP_PKEY_METHOD is found 
 */
static int  ssl_mac_pkey_id[SSL_MD_NUM_IDX]={
	EVP_PKEY_HMAC,EVP_PKEY_HMAC,EVP_PKEY_HMAC,NID_undef
	};

static int ssl_mac_secret_size[SSL_MD_NUM_IDX]={
	0,0,0,0
	};

static int ssl_handshake_digest_flag[SSL_MD_NUM_IDX]={
	SSL_HANDSHAKE_MAC_MD5,SSL_HANDSHAKE_MAC_SHA,
	SSL_HANDSHAKE_MAC_GOST94,0
d164 1
a164 1
	const SSL_CIPHER *cipher;
d171 58
a228 96
	/* "ALL" doesn't include eNULL (must be specifically enabled) */
	{0,SSL_TXT_ALL,0,     0,0,~SSL_eNULL,0,0,0,0,0,0},
	/* "COMPLEMENTOFALL" */
	{0,SSL_TXT_CMPALL,0,  0,0,SSL_eNULL,0,0,0,0,0,0},

	/* "COMPLEMENTOFDEFAULT" (does *not* include ciphersuites not found in ALL!) */
	{0,SSL_TXT_CMPDEF,0,  SSL_kEDH|SSL_kEECDH,SSL_aNULL,~SSL_eNULL,0,0,0,0,0,0},

	/* key exchange aliases
	 * (some of those using only a single bit here combine
	 * multiple key exchange algs according to the RFCs,
	 * e.g. kEDH combines DHE_DSS and DHE_RSA) */
	{0,SSL_TXT_kRSA,0,    SSL_kRSA,  0,0,0,0,0,0,0,0},

	{0,SSL_TXT_kDHr,0,    SSL_kDHr,  0,0,0,0,0,0,0,0}, /* no such ciphersuites supported! */
	{0,SSL_TXT_kDHd,0,    SSL_kDHd,  0,0,0,0,0,0,0,0}, /* no such ciphersuites supported! */
	{0,SSL_TXT_kDH,0,     SSL_kDHr|SSL_kDHd,0,0,0,0,0,0,0,0}, /* no such ciphersuites supported! */
	{0,SSL_TXT_kEDH,0,    SSL_kEDH,  0,0,0,0,0,0,0,0},
	{0,SSL_TXT_DH,0,      SSL_kDHr|SSL_kDHd|SSL_kEDH,0,0,0,0,0,0,0,0},

	{0,SSL_TXT_kKRB5,0,   SSL_kKRB5, 0,0,0,0,0,0,0,0},

	{0,SSL_TXT_kECDHr,0,  SSL_kECDHr,0,0,0,0,0,0,0,0},
	{0,SSL_TXT_kECDHe,0,  SSL_kECDHe,0,0,0,0,0,0,0,0},
	{0,SSL_TXT_kECDH,0,   SSL_kECDHr|SSL_kECDHe,0,0,0,0,0,0,0,0},
	{0,SSL_TXT_kEECDH,0,  SSL_kEECDH,0,0,0,0,0,0,0,0},
	{0,SSL_TXT_ECDH,0,    SSL_kECDHr|SSL_kECDHe|SSL_kEECDH,0,0,0,0,0,0,0,0},

        {0,SSL_TXT_kPSK,0,    SSL_kPSK,  0,0,0,0,0,0,0,0},
	{0,SSL_TXT_kGOST,0, SSL_kGOST,0,0,0,0,0,0,0,0},

	/* server authentication aliases */
	{0,SSL_TXT_aRSA,0,    0,SSL_aRSA,  0,0,0,0,0,0,0},
	{0,SSL_TXT_aDSS,0,    0,SSL_aDSS,  0,0,0,0,0,0,0},
	{0,SSL_TXT_DSS,0,     0,SSL_aDSS,   0,0,0,0,0,0,0},
	{0,SSL_TXT_aKRB5,0,   0,SSL_aKRB5, 0,0,0,0,0,0,0},
	{0,SSL_TXT_aNULL,0,   0,SSL_aNULL, 0,0,0,0,0,0,0},
	{0,SSL_TXT_aDH,0,     0,SSL_aDH,   0,0,0,0,0,0,0}, /* no such ciphersuites supported! */
	{0,SSL_TXT_aECDH,0,   0,SSL_aECDH, 0,0,0,0,0,0,0},
	{0,SSL_TXT_aECDSA,0,  0,SSL_aECDSA,0,0,0,0,0,0,0},
	{0,SSL_TXT_ECDSA,0,   0,SSL_aECDSA, 0,0,0,0,0,0,0},
        {0,SSL_TXT_aPSK,0,    0,SSL_aPSK,  0,0,0,0,0,0,0},
	{0,SSL_TXT_aGOST94,0,0,SSL_aGOST94,0,0,0,0,0,0,0},
	{0,SSL_TXT_aGOST01,0,0,SSL_aGOST01,0,0,0,0,0,0,0},
	{0,SSL_TXT_aGOST,0,0,SSL_aGOST94|SSL_aGOST01,0,0,0,0,0,0,0},

	/* aliases combining key exchange and server authentication */
	{0,SSL_TXT_EDH,0,     SSL_kEDH,~SSL_aNULL,0,0,0,0,0,0,0},
	{0,SSL_TXT_EECDH,0,   SSL_kEECDH,~SSL_aNULL,0,0,0,0,0,0,0},
	{0,SSL_TXT_NULL,0,    0,0,SSL_eNULL, 0,0,0,0,0,0},
	{0,SSL_TXT_KRB5,0,    SSL_kKRB5,SSL_aKRB5,0,0,0,0,0,0,0},
	{0,SSL_TXT_RSA,0,     SSL_kRSA,SSL_aRSA,0,0,0,0,0,0,0},
	{0,SSL_TXT_ADH,0,     SSL_kEDH,SSL_aNULL,0,0,0,0,0,0,0},
	{0,SSL_TXT_AECDH,0,   SSL_kEECDH,SSL_aNULL,0,0,0,0,0,0,0},
        {0,SSL_TXT_PSK,0,     SSL_kPSK,SSL_aPSK,0,0,0,0,0,0,0},


	/* symmetric encryption aliases */
	{0,SSL_TXT_DES,0,     0,0,SSL_DES,   0,0,0,0,0,0},
	{0,SSL_TXT_3DES,0,    0,0,SSL_3DES,  0,0,0,0,0,0},
	{0,SSL_TXT_RC4,0,     0,0,SSL_RC4,   0,0,0,0,0,0},
	{0,SSL_TXT_RC2,0,     0,0,SSL_RC2,   0,0,0,0,0,0},
	{0,SSL_TXT_IDEA,0,    0,0,SSL_IDEA,  0,0,0,0,0,0},
	{0,SSL_TXT_SEED,0,    0,0,SSL_SEED,  0,0,0,0,0,0},
	{0,SSL_TXT_eNULL,0,   0,0,SSL_eNULL, 0,0,0,0,0,0},
	{0,SSL_TXT_AES128,0,  0,0,SSL_AES128,0,0,0,0,0,0},
	{0,SSL_TXT_AES256,0,  0,0,SSL_AES256,0,0,0,0,0,0},
	{0,SSL_TXT_AES,0,     0,0,SSL_AES128|SSL_AES256,0,0,0,0,0,0},
	{0,SSL_TXT_CAMELLIA128,0,0,0,SSL_CAMELLIA128,0,0,0,0,0,0},
	{0,SSL_TXT_CAMELLIA256,0,0,0,SSL_CAMELLIA256,0,0,0,0,0,0},
	{0,SSL_TXT_CAMELLIA   ,0,0,0,SSL_CAMELLIA128|SSL_CAMELLIA256,0,0,0,0,0,0},

	/* MAC aliases */	
	{0,SSL_TXT_MD5,0,     0,0,0,SSL_MD5,   0,0,0,0,0},
	{0,SSL_TXT_SHA1,0,    0,0,0,SSL_SHA1,  0,0,0,0,0},
	{0,SSL_TXT_SHA,0,     0,0,0,SSL_SHA1,  0,0,0,0,0},
	{0,SSL_TXT_GOST94,0,     0,0,0,SSL_GOST94,  0,0,0,0,0},
	{0,SSL_TXT_GOST89MAC,0,     0,0,0,SSL_GOST89MAC,  0,0,0,0,0},

	/* protocol version aliases */
	{0,SSL_TXT_SSLV2,0,   0,0,0,0,SSL_SSLV2, 0,0,0,0},
	{0,SSL_TXT_SSLV3,0,   0,0,0,0,SSL_SSLV3, 0,0,0,0},
	{0,SSL_TXT_TLSV1,0,   0,0,0,0,SSL_TLSV1, 0,0,0,0},

	/* export flag */
	{0,SSL_TXT_EXP,0,     0,0,0,0,0,SSL_EXPORT,0,0,0},
	{0,SSL_TXT_EXPORT,0,  0,0,0,0,0,SSL_EXPORT,0,0,0},

	/* strength classes */
	{0,SSL_TXT_EXP40,0,   0,0,0,0,0,SSL_EXP40, 0,0,0},
	{0,SSL_TXT_EXP56,0,   0,0,0,0,0,SSL_EXP56, 0,0,0},
	{0,SSL_TXT_LOW,0,     0,0,0,0,0,SSL_LOW,   0,0,0},
	{0,SSL_TXT_MEDIUM,0,  0,0,0,0,0,SSL_MEDIUM,0,0,0},
	{0,SSL_TXT_HIGH,0,    0,0,0,0,0,SSL_HIGH,  0,0,0},
	/* FIPS 140-2 approved ciphersuite */
	{0,SSL_TXT_FIPS,0,    0,0,~SSL_eNULL,0,0,SSL_FIPS,  0,0,0},
a229 34
/* Search for public key algorithm with given name and 
 * return its pkey_id if it is available. Otherwise return 0
 */
#ifdef OPENSSL_NO_ENGINE

static int get_optional_pkey_id(const char *pkey_name)
	{
	const EVP_PKEY_ASN1_METHOD *ameth;
	int pkey_id=0;
	ameth = EVP_PKEY_asn1_find_str(NULL,pkey_name,-1);
	if (ameth) 
		{
		EVP_PKEY_asn1_get0_info(&pkey_id, NULL,NULL,NULL,NULL,ameth);
		}		
	return pkey_id;
	}

#else

static int get_optional_pkey_id(const char *pkey_name)
	{
	const EVP_PKEY_ASN1_METHOD *ameth;
	ENGINE *tmpeng = NULL;
	int pkey_id=0;
	ameth = EVP_PKEY_asn1_find_str(&tmpeng,pkey_name,-1);
	if (ameth)
		{
		EVP_PKEY_asn1_get0_info(&pkey_id, NULL,NULL,NULL,NULL,ameth);
		}
	if (tmpeng) ENGINE_finish(tmpeng);
	return pkey_id;
	}

#endif
a254 2
	ssl_cipher_methods[SSL_ENC_GOST89_IDX]=
	  EVP_get_cipherbyname(SN_gost89_cnt);
a259 3
	ssl_mac_secret_size[SSL_MD_MD5_IDX]=
		EVP_MD_size(ssl_digest_methods[SSL_MD_MD5_IDX]);
	OPENSSL_assert(ssl_mac_secret_size[SSL_MD_MD5_IDX] >= 0);
d262 2
a263 17
	ssl_mac_secret_size[SSL_MD_SHA1_IDX]=
		EVP_MD_size(ssl_digest_methods[SSL_MD_SHA1_IDX]);
	OPENSSL_assert(ssl_mac_secret_size[SSL_MD_SHA1_IDX] >= 0);
	ssl_digest_methods[SSL_MD_GOST94_IDX]=
		EVP_get_digestbyname(SN_id_GostR3411_94);
	if (ssl_digest_methods[SSL_MD_GOST94_IDX])
		{	
		ssl_mac_secret_size[SSL_MD_GOST94_IDX]=
			EVP_MD_size(ssl_digest_methods[SSL_MD_GOST94_IDX]);
		OPENSSL_assert(ssl_mac_secret_size[SSL_MD_GOST94_IDX] >= 0);
		}
	ssl_digest_methods[SSL_MD_GOST89MAC_IDX]=
		EVP_get_digestbyname(SN_id_Gost28147_89_MAC);
		ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX] = get_optional_pkey_id("gost-mac");
		if (ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX]) {
			ssl_mac_secret_size[SSL_MD_GOST89MAC_IDX]=32;
		}		
a264 1
	}
d319 1
a319 1
	     const EVP_MD **md, int *mac_pkey_type, int *mac_secret_size,SSL_COMP **comp)
d322 1
a322 1
	const SSL_CIPHER *c;
d347 1
a347 1
	switch (c->algorithm_enc)
d367 7
a373 2
	case SSL_AES128:
		i=SSL_ENC_AES128_IDX;
d375 7
a381 11
	case SSL_AES256:
		i=SSL_ENC_AES256_IDX;
		break;
	case SSL_CAMELLIA128:
		i=SSL_ENC_CAMELLIA128_IDX;
		break;
	case SSL_CAMELLIA256:
		i=SSL_ENC_CAMELLIA256_IDX;
		break;
	case SSL_eGOST2814789CNT:
		i=SSL_ENC_GOST89_IDX;
d386 1
d402 1
a402 1
	switch (c->algorithm_mac)
a409 6
	case SSL_GOST94:
		i = SSL_MD_GOST94_IDX;
		break;
	case SSL_GOST89MAC:
		i = SSL_MD_GOST89MAC_IDX;
		break;
d415 1
a415 6
	{
		*md=NULL; 
		if (mac_pkey_type!=NULL) *mac_pkey_type = NID_undef;
		if (mac_secret_size!=NULL) *mac_secret_size = 0;

	}
a416 1
	{
a417 3
		if (mac_pkey_type!=NULL) *mac_pkey_type = ssl_mac_pkey_id[i];
		if (mac_secret_size!=NULL) *mac_secret_size = ssl_mac_secret_size[i];
	}	
d419 1
a419 1
	if ((*enc != NULL) && (*md != NULL) && (!mac_pkey_type||*mac_pkey_type != NID_undef))
a424 12
int ssl_get_handshake_digest(int idx, long *mask, const EVP_MD **md) 
{
	if (idx <0||idx>=SSL_MD_NUM_IDX) 
		{
		return 0;
		}
	if (ssl_handshake_digest_flag[idx]==0) return 0;
	*mask = ssl_handshake_digest_flag[idx];
	*md = ssl_digest_methods[idx];
	return 1;
}

d436 1
a436 1
	if (curr->next != NULL)
d444 6
a449 15
static void ll_append_head(CIPHER_ORDER **head, CIPHER_ORDER *curr,
	     CIPHER_ORDER **tail)
	{
	if (curr == *head) return;
	if (curr == *tail)
		*tail=curr->prev;
	if (curr->next != NULL)
		curr->next->prev=curr->prev;
	if (curr->prev != NULL)
		curr->prev->next=curr->next;
	(*head)->prev=curr;
	curr->next= *head;
	curr->prev=NULL;
	*head=curr;
	}
d451 1
a451 1
static void ssl_cipher_get_disabled(unsigned long *mkey, unsigned long *auth, unsigned long *enc, unsigned long *mac, unsigned long *ssl)
d453 3
a455 5
	*mkey = 0;
	*auth = 0;
	*enc = 0;
	*mac = 0;
	*ssl = 0;
d457 1
d459 1
a459 2
	*mkey |= SSL_kRSA;
	*auth |= SSL_aRSA;
d462 1
a462 1
	*auth |= SSL_aDSS;
a463 2
	*mkey |= SSL_kDHr|SSL_kDHd; /* no such ciphersuites supported! */
	*auth |= SSL_aDH;
d465 1
a465 2
	*mkey |= SSL_kDHr|SSL_kDHd|SSL_kEDH;
	*auth |= SSL_aDH;
d468 1
a468 5
	*mkey |= SSL_kKRB5;
	*auth |= SSL_aKRB5;
#endif
#ifdef OPENSSL_NO_ECDSA
	*auth |= SSL_aECDSA;
d471 1
a471 6
	*mkey |= SSL_kECDHe|SSL_kECDHr;
	*auth |= SSL_aECDH;
#endif
#ifdef OPENSSL_NO_PSK
	*mkey |= SSL_kPSK;
	*auth |= SSL_aPSK;
a472 12
	/* Check for presence of GOST 34.10 algorithms, and if they
	 * do not present, disable  appropriate auth and key exchange */
	if (!get_optional_pkey_id("gost94")) {
		*auth |= SSL_aGOST94;
	}
	if (!get_optional_pkey_id("gost2001")) {
		*auth |= SSL_aGOST01;
	}
	/* Disable GOST key exchange if no GOST signature algs are available * */
	if ((*auth & (SSL_aGOST94|SSL_aGOST01)) == (SSL_aGOST94|SSL_aGOST01)) {
		*mkey |= SSL_kGOST;
	}	
d474 1
a474 1
	*enc |= SSL_eNULL;
a475 19
		


	*enc |= (ssl_cipher_methods[SSL_ENC_DES_IDX ] == NULL) ? SSL_DES :0;
	*enc |= (ssl_cipher_methods[SSL_ENC_3DES_IDX] == NULL) ? SSL_3DES:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_RC4_IDX ] == NULL) ? SSL_RC4 :0;
	*enc |= (ssl_cipher_methods[SSL_ENC_RC2_IDX ] == NULL) ? SSL_RC2 :0;
	*enc |= (ssl_cipher_methods[SSL_ENC_IDEA_IDX] == NULL) ? SSL_IDEA:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_AES128_IDX] == NULL) ? SSL_AES128:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_AES256_IDX] == NULL) ? SSL_AES256:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_CAMELLIA128_IDX] == NULL) ? SSL_CAMELLIA128:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_CAMELLIA256_IDX] == NULL) ? SSL_CAMELLIA256:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_GOST89_IDX] == NULL) ? SSL_eGOST2814789CNT:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_SEED_IDX] == NULL) ? SSL_SEED:0;

	*mac |= (ssl_digest_methods[SSL_MD_MD5_IDX ] == NULL) ? SSL_MD5 :0;
	*mac |= (ssl_digest_methods[SSL_MD_SHA1_IDX] == NULL) ? SSL_SHA1:0;
	*mac |= (ssl_digest_methods[SSL_MD_GOST94_IDX] == NULL) ? SSL_GOST94:0;
	*mac |= (ssl_digest_methods[SSL_MD_GOST89MAC_IDX] == NULL || ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX]==NID_undef)? SSL_GOST89MAC:0;
d477 21
d501 3
a503 6
                int num_of_ciphers,
                unsigned long disabled_mkey, unsigned long disabled_auth,
                unsigned long disabled_enc, unsigned long disabled_mac,
                unsigned long disabled_ssl,
                CIPHER_ORDER *co_list,
                CIPHER_ORDER **head_p, CIPHER_ORDER **tail_p)
d506 1
a506 1
	const SSL_CIPHER *c;
d520 1
d522 6
a527 6
		if ((c != NULL) && c->valid &&
		    !(c->algorithm_mkey & disabled_mkey) &&
		    !(c->algorithm_auth & disabled_auth) &&
		    !(c->algorithm_enc & disabled_enc) &&
		    !(c->algorithm_mac & disabled_mac) &&
		    !(c->algorithm_ssl & disabled_ssl))
d535 1
a535 1
			printf("\t%d: %s %lx %lx %lx\n",i,c->name,c->id,c->algorithm_mkey,c->algorithm_auth);
d546 5
d553 6
a558 19
		co_list[0].prev = NULL;

		if (co_list_num > 1)
			{
			co_list[0].next = &co_list[1];
			
			for (i = 1; i < co_list_num - 1; i++)
				{
				co_list[i].prev = &co_list[i - 1];
				co_list[i].next = &co_list[i + 1];
				}

			co_list[co_list_num - 1].prev = &co_list[co_list_num - 2];
			}
		
		co_list[co_list_num - 1].next = NULL;

		*head_p = &co_list[0];
		*tail_p = &co_list[co_list_num - 1];
d562 2
a563 5
static void ssl_cipher_collect_aliases(const SSL_CIPHER **ca_list,
                        int num_of_group_aliases,
                        unsigned long disabled_mkey, unsigned long disabled_auth,
                        unsigned long disabled_enc, unsigned long disabled_mac,
                        unsigned long disabled_ssl,
d567 1
a567 1
	const SSL_CIPHER **ca_curr;
a568 5
	unsigned long mask_mkey = ~disabled_mkey;
	unsigned long mask_auth = ~disabled_auth;
	unsigned long mask_enc = ~disabled_enc;
	unsigned long mask_mac = ~disabled_mac;
	unsigned long mask_ssl = ~disabled_ssl;
d584 3
a586 3
	 * They represent either one or more algorithms, some of which
	 * in any affected category must be supported (set in enabled_mask),
	 * or represent a cipher strength value (will be added in any case because algorithms=0).
d590 6
a595 28
		unsigned long algorithm_mkey = cipher_aliases[i].algorithm_mkey;
		unsigned long algorithm_auth = cipher_aliases[i].algorithm_auth;
		unsigned long algorithm_enc = cipher_aliases[i].algorithm_enc;
		unsigned long algorithm_mac = cipher_aliases[i].algorithm_mac;
		unsigned long algorithm_ssl = cipher_aliases[i].algorithm_ssl;

		if (algorithm_mkey)
			if ((algorithm_mkey & mask_mkey) == 0)
				continue;
	
		if (algorithm_auth)
			if ((algorithm_auth & mask_auth) == 0)
				continue;
		
		if (algorithm_enc)
			if ((algorithm_enc & mask_enc) == 0)
				continue;
		
		if (algorithm_mac)
			if ((algorithm_mac & mask_mac) == 0)
				continue;
		
		if (algorithm_ssl)
			if ((algorithm_ssl & mask_ssl) == 0)
				continue;
		
		*ca_curr = (SSL_CIPHER *)(cipher_aliases + i);
		ca_curr++;
d601 4
a604 6
static void ssl_cipher_apply_rule(unsigned long cipher_id,
                unsigned long alg_mkey, unsigned long alg_auth,
                unsigned long alg_enc, unsigned long alg_mac,
                unsigned long alg_ssl,
		unsigned long algo_strength,
		int rule, int strength_bits,
d607 3
a609 3
	CIPHER_ORDER *head, *tail, *curr, *curr2, *last;
	const SSL_CIPHER *cp;
	int reverse = 0;
d612 3
a614 2
	printf("Applying rule %d with %08lx/%08lx/%08lx/%08lx/%08lx %08lx (%d)\n",
		rule, alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl, algo_strength, strength_bits);
d617 3
a619 18
	if (rule == CIPHER_DEL)
		reverse = 1; /* needed to maintain sorting between currently deleted ciphers */

	head = *head_p;
	tail = *tail_p;

	if (reverse)
		{
		curr = tail;
		last = head;
		}
	else
		{
		curr = head;
		last = tail;
		}

	curr2 = curr;
d622 1
a622 1
		if ((curr == NULL) || (curr == last)) break;
d624 1
a624 1
		curr2 = reverse ? curr->prev : curr->next;
d628 4
a631 5
		/*
		 * Selection criteria is either the value of strength_bits
		 * or the algorithms used.
		 */
		if (strength_bits >= 0)
d633 1
a633 1
			if (strength_bits != cp->strength_bits)
d636 6
a641 1
		else
d643 3
d647 2
a648 1
			printf("\nName: %s:\nAlgo = %08lx/%08lx/%08lx/%08lx/%08lx Algo_strength = %08lx\n", cp->name, cp->algorithm_mkey, cp->algorithm_auth, cp->algorithm_enc, cp->algorithm_mac, cp->algorithm_ssl, cp->algo_strength);
d650 9
a658 15

			if (alg_mkey && !(alg_mkey & cp->algorithm_mkey))
				continue;
			if (alg_auth && !(alg_auth & cp->algorithm_auth))
				continue;
			if (alg_enc && !(alg_enc & cp->algorithm_enc))
				continue;
			if (alg_mac && !(alg_mac & cp->algorithm_mac))
				continue;
			if (alg_ssl && !(alg_ssl & cp->algorithm_ssl))
				continue;
			if ((algo_strength & SSL_EXP_MASK) && !(algo_strength & SSL_EXP_MASK & cp->algo_strength))
				continue;
			if ((algo_strength & SSL_STRONG_MASK) && !(algo_strength & SSL_STRONG_MASK & cp->algo_strength))
				continue;
d660 2
a669 1
			/* reverse == 0 */
d672 16
a687 2
				ll_append_tail(&head, curr, &tail);
				curr->active = 1;
a692 1
			/* reverse == 0 */
d699 1
a699 11
			{
			/* reverse == 1 */
			if (curr->active)
				{
				/* most recently deleted ciphersuites get best positions
				 * for any future CIPHER_ADD (note that the CIPHER_DEL loop
				 * works in reverse to maintain the order) */
				ll_append_head(&head, curr, &tail);
				curr->active = 0;
				}
			}
a701 1
			/* reverse == 0 */
d722 2
a723 1
static int ssl_cipher_strength_sort(CIPHER_ORDER **head_p,
d746 1
a746 1
		{
d749 1
a749 1
		}
d768 2
a769 1
			ssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, 0, CIPHER_ORD, i, head_p, tail_p);
d776 2
a777 2
                CIPHER_ORDER **head_p, CIPHER_ORDER **tail_p,
                const SSL_CIPHER **ca_list)
d779 1
a779 1
	unsigned long alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl, algo_strength;
d782 1
a782 1
	unsigned long cipher_id = 0;
d810 1
a810 6
		alg_mkey = 0;
		alg_auth = 0;
		alg_enc = 0;
		alg_mac = 0;
		alg_ssl = 0;
		algo_strength = 0;
d871 4
a874 3
			j = found = 0;
			cipher_id = 0;
			while (ca_list[j])
a884 1

d888 13
a900 10
			if (ca_list[j]->algorithm_mkey)
				{
				if (alg_mkey)
					{
					alg_mkey &= ca_list[j]->algorithm_mkey;
					if (!alg_mkey) { found = 0; break; }
					}
				else
					alg_mkey = ca_list[j]->algorithm_mkey;
				}
d902 1
a902 55
			if (ca_list[j]->algorithm_auth)
				{
				if (alg_auth)
					{
					alg_auth &= ca_list[j]->algorithm_auth;
					if (!alg_auth) { found = 0; break; }
					}
				else
					alg_auth = ca_list[j]->algorithm_auth;
				}
			
			if (ca_list[j]->algorithm_enc)
				{
				if (alg_enc)
					{
					alg_enc &= ca_list[j]->algorithm_enc;
					if (!alg_enc) { found = 0; break; }
					}
				else
					alg_enc = ca_list[j]->algorithm_enc;
				}
						
			if (ca_list[j]->algorithm_mac)
				{
				if (alg_mac)
					{
					alg_mac &= ca_list[j]->algorithm_mac;
					if (!alg_mac) { found = 0; break; }
					}
				else
					alg_mac = ca_list[j]->algorithm_mac;
				}
			
			if (ca_list[j]->algo_strength & SSL_EXP_MASK)
				{
				if (algo_strength & SSL_EXP_MASK)
					{
					algo_strength &= (ca_list[j]->algo_strength & SSL_EXP_MASK) | ~SSL_EXP_MASK;
					if (!(algo_strength & SSL_EXP_MASK)) { found = 0; break; }
					}
				else
					algo_strength |= ca_list[j]->algo_strength & SSL_EXP_MASK;
				}

			if (ca_list[j]->algo_strength & SSL_STRONG_MASK)
				{
				if (algo_strength & SSL_STRONG_MASK)
					{
					algo_strength &= (ca_list[j]->algo_strength & SSL_STRONG_MASK) | ~SSL_STRONG_MASK;
					if (!(algo_strength & SSL_STRONG_MASK)) { found = 0; break; }
					}
				else
					algo_strength |= ca_list[j]->algo_strength & SSL_STRONG_MASK;
				}
			
a904 3
				/* explicit ciphersuite found; its protocol version
				 * does not become part of the search pattern!*/

d906 2
a908 4
			else
				{
				/* not an explicit ciphersuite; only in this case, the
				 * protocol version is considered part of the search pattern */
a909 12
				if (ca_list[j]->algorithm_ssl)
					{
					if (alg_ssl)
						{
						alg_ssl &= ca_list[j]->algorithm_ssl;
						if (!alg_ssl) { found = 0; break; }
						}
					else
						alg_ssl = ca_list[j]->algorithm_ssl;
					}
				}
			
d921 2
a922 1
				ok = ssl_cipher_strength_sort(head_p, tail_p);
d939 3
a941 3
			ssl_cipher_apply_rule(cipher_id,
				alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl, algo_strength,
				rule, -1, head_p, tail_p);
d960 2
a961 1
	unsigned long disabled_mkey, disabled_auth, disabled_enc, disabled_mac, disabled_ssl;
d965 1
a965 1
	const SSL_CIPHER **ca_list = NULL;
d977 6
a982 1
	ssl_cipher_get_disabled(&disabled_mkey, &disabled_auth, &disabled_enc, &disabled_mac, &disabled_ssl);
d1000 2
a1001 46
	ssl_cipher_collect_ciphers(ssl_method, num_of_ciphers,
	                           disabled_mkey, disabled_auth, disabled_enc, disabled_mac, disabled_ssl,
	                           co_list, &head, &tail);


	/* Now arrange all ciphers by preference: */

	/* Everything else being equal, prefer ephemeral ECDH over other key exchange mechanisms */
	ssl_cipher_apply_rule(0, SSL_kEECDH, 0, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);
	ssl_cipher_apply_rule(0, SSL_kEECDH, 0, 0, 0, 0, 0, CIPHER_DEL, -1, &head, &tail);

	/* AES is our preferred symmetric cipher */
	ssl_cipher_apply_rule(0, 0, 0, SSL_AES, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);

	/* Temporarily enable everything else for sorting */
	ssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);

	/* Low priority for MD5 */
	ssl_cipher_apply_rule(0, 0, 0, 0, SSL_MD5, 0, 0, CIPHER_ORD, -1, &head, &tail);

	/* Move anonymous ciphers to the end.  Usually, these will remain disabled.
	 * (For applications that allow them, they aren't too bad, but we prefer
	 * authenticated ciphers.) */
	ssl_cipher_apply_rule(0, 0, SSL_aNULL, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);

	/* Move ciphers without forward secrecy to the end */
	ssl_cipher_apply_rule(0, 0, SSL_aECDH, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);
	/* ssl_cipher_apply_rule(0, 0, SSL_aDH, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail); */
	ssl_cipher_apply_rule(0, SSL_kRSA, 0, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);
	ssl_cipher_apply_rule(0, SSL_kPSK, 0,0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);
	ssl_cipher_apply_rule(0, SSL_kKRB5, 0,0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);

	/* RC4 is sort-of broken -- move the the end */
	ssl_cipher_apply_rule(0, 0, 0, SSL_RC4, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);

	/* Now sort by symmetric encryption strength.  The above ordering remains
	 * in force within each class */
	if (!ssl_cipher_strength_sort(&head, &tail))
		{
		OPENSSL_free(co_list);
		return NULL;
		}

	/* Now disable everything (maintaining the ordering!) */
	ssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, 0, CIPHER_DEL, -1, &head, &tail);

d1013 2
a1014 1
	ca_list = OPENSSL_malloc(sizeof(SSL_CIPHER *) * num_of_alias_max);
d1022 1
a1022 2
	                           disabled_mkey, disabled_auth, disabled_enc,
				   disabled_mac, disabled_ssl, head);
d1033 1
a1033 1
			&head, &tail, ca_list);
d1040 2
a1041 1
		ok = ssl_cipher_process_rulestr(rule_p, &head, &tail, ca_list);
d1043 1
a1043 1
	OPENSSL_free((void *)ca_list);	/* Not needed anymore */
a1049 1
	
d1066 3
d1070 1
a1093 1
	sk_SSL_CIPHER_sort(*cipher_list_by_id);
d1097 1
a1097 1
char *SSL_CIPHER_description(const SSL_CIPHER *cipher, char *buf, int len)
d1102 1
a1102 1
	unsigned long alg_mkey,alg_auth,alg_enc,alg_mac,alg_ssl,alg2,alg_s;
d1104 1
a1104 1
	static const char *format="%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s%s AL=%lx/%lx/%lx/%lx/%lx\n";
d1109 1
a1109 6
	alg_mkey = cipher->algorithm_mkey;
	alg_auth = cipher->algorithm_auth;
	alg_enc = cipher->algorithm_enc;
	alg_mac = cipher->algorithm_mac;
	alg_ssl = cipher->algorithm_ssl;

d1118 1
a1118 1
	if (alg_ssl & SSL_SSLV2)
d1120 1
a1120 1
	else if (alg_ssl & SSL_SSLV3)
d1125 1
a1125 1
	switch (alg_mkey)
d1136 6
a1141 2
        case SSL_kKRB5:
		kx="KRB5";
d1146 3
a1148 11
	case SSL_kECDHr:
		kx="ECDH/RSA";
		break;
	case SSL_kECDHe:
		kx="ECDH/ECDSA";
		break;
	case SSL_kEECDH:
		kx="ECDH";
		break;
	case SSL_kPSK:
		kx="PSK";
d1154 1
a1154 1
	switch (alg_auth)
d1165 5
a1169 6
        case SSL_aKRB5:
		au="KRB5";
		break;
        case SSL_aECDH:
		au="ECDH";
		break;
a1175 3
	case SSL_aPSK:
		au="PSK";
		break;
d1181 1
a1181 1
	switch (alg_enc)
d1199 3
d1205 8
a1212 2
	case SSL_AES128:
		enc="AES(128)";
d1214 7
a1220 8
	case SSL_AES256:
		enc="AES(256)";
		break;
	case SSL_CAMELLIA128:
		enc="Camellia(128)";
		break;
	case SSL_CAMELLIA256:
		enc="Camellia(256)";
d1225 1
d1231 1
a1231 1
	switch (alg_mac)
d1254 1
a1254 1
	BIO_snprintf(buf,len,format,cipher->name,ver,kx,au,enc,mac,exp_str,alg_mkey,alg_auth,alg_enc,alg_mac,alg_ssl);
@


1.1.1.12
log
@import OpenSSL 1.0.0e
@
text
@d1030 1
a1030 1
	const char *l, *buf;
d1067 1
d1459 1
a1459 1
	unsigned long alg_mkey,alg_auth,alg_enc,alg_mac,alg_ssl,alg2;
d1472 1
@


1.1.1.13
log
@OpenSSL 1.0.0f: import upstream source
@
text
@a448 1
					sk_SSL_COMP_sort(ssl_comp_methods);
@


1.1.1.14
log
@import OpenSSL-1.0.1c
@
text
@d165 1
a165 3
#define SSL_ENC_AES128GCM_IDX	12
#define SSL_ENC_AES256GCM_IDX	13
#define SSL_ENC_NUM_IDX		14
d169 1
a169 1
	NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL
a181 2
#define SSL_MD_SHA256_IDX 4
#define SSL_MD_SHA384_IDX 5
d187 1
a187 1
	NULL,NULL,NULL,NULL,NULL,NULL
d194 1
a194 2
	EVP_PKEY_HMAC,EVP_PKEY_HMAC,EVP_PKEY_HMAC,NID_undef,
	EVP_PKEY_HMAC,EVP_PKEY_HMAC
d198 1
a198 1
	0,0,0,0,0,0
d203 1
a203 2
	SSL_HANDSHAKE_MAC_GOST94, 0, SSL_HANDSHAKE_MAC_SHA256,
	SSL_HANDSHAKE_MAC_SHA384
a249 1
	{0,SSL_TXT_kSRP,0,    SSL_kSRP,  0,0,0,0,0,0,0,0},
a275 1
	{0,SSL_TXT_SRP,0,     SSL_kSRP,0,0,0,0,0,0,0,0},
d286 3
a288 4
	{0,SSL_TXT_AES128,0,  0,0,SSL_AES128|SSL_AES128GCM,0,0,0,0,0,0},
	{0,SSL_TXT_AES256,0,  0,0,SSL_AES256|SSL_AES256GCM,0,0,0,0,0,0},
	{0,SSL_TXT_AES,0,     0,0,SSL_AES,0,0,0,0,0,0},
	{0,SSL_TXT_AES_GCM,0, 0,0,SSL_AES128GCM|SSL_AES256GCM,0,0,0,0,0,0},
a298 2
	{0,SSL_TXT_SHA256,0,    0,0,0,SSL_SHA256,  0,0,0,0,0},
	{0,SSL_TXT_SHA384,0,    0,0,0,SSL_SHA384,  0,0,0,0,0},
a381 5
	ssl_cipher_methods[SSL_ENC_AES128GCM_IDX]=
	  EVP_get_cipherbyname(SN_aes_128_gcm);
	ssl_cipher_methods[SSL_ENC_AES256GCM_IDX]=
	  EVP_get_cipherbyname(SN_aes_256_gcm);

a406 8
	ssl_digest_methods[SSL_MD_SHA256_IDX]=
		EVP_get_digestbyname(SN_sha256);
	ssl_mac_secret_size[SSL_MD_SHA256_IDX]=
		EVP_MD_size(ssl_digest_methods[SSL_MD_SHA256_IDX]);
	ssl_digest_methods[SSL_MD_SHA384_IDX]=
		EVP_get_digestbyname(SN_sha384);
	ssl_mac_secret_size[SSL_MD_SHA384_IDX]=
		EVP_MD_size(ssl_digest_methods[SSL_MD_SHA384_IDX]);
a528 6
	case SSL_AES128GCM:
		i=SSL_ENC_AES128GCM_IDX;
		break;
	case SSL_AES256GCM:
		i=SSL_ENC_AES256GCM_IDX;
		break;
a551 6
	case SSL_SHA256:
		i=SSL_MD_SHA256_IDX;
		break;
	case SSL_SHA384:
		i=SSL_MD_SHA384_IDX;
		break;
d567 1
a567 2
		if (c->algorithm_mac == SSL_AEAD)
			mac_pkey_type = NULL;
d574 1
a574 16
	}

	if ((*enc != NULL) &&
	    (*md != NULL || (EVP_CIPHER_flags(*enc)&EVP_CIPH_FLAG_AEAD_CIPHER)) &&
	    (!mac_pkey_type||*mac_pkey_type != NID_undef))
		{
		const EVP_CIPHER *evp;

		if (s->ssl_version>>8 != TLS1_VERSION_MAJOR ||
		    s->ssl_version < TLS1_VERSION)
			return 1;

#ifdef OPENSSL_FIPS
		if (FIPS_mode())
			return 1;
#endif
d576 1
a576 12
		if	(c->algorithm_enc == SSL_RC4 &&
			 c->algorithm_mac == SSL_MD5 &&
			 (evp=EVP_get_cipherbyname("RC4-HMAC-MD5")))
			*enc = evp, *md = NULL;
		else if (c->algorithm_enc == SSL_AES128 &&
			 c->algorithm_mac == SSL_SHA1 &&
			 (evp=EVP_get_cipherbyname("AES-128-CBC-HMAC-SHA1")))
			*enc = evp, *md = NULL;
		else if (c->algorithm_enc == SSL_AES256 &&
			 c->algorithm_mac == SSL_SHA1 &&
			 (evp=EVP_get_cipherbyname("AES-256-CBC-HMAC-SHA1")))
			*enc = evp, *md = NULL;
a577 1
		}
d588 1
d590 1
a590 4
	if (*mask)
		*md = ssl_digest_methods[idx];
	else
		*md = NULL;
a664 3
#ifdef OPENSSL_NO_SRP
	*mkey |= SSL_kSRP;
#endif
a689 2
	*enc |= (ssl_cipher_methods[SSL_ENC_AES128GCM_IDX] == NULL) ? SSL_AES128GCM:0;
	*enc |= (ssl_cipher_methods[SSL_ENC_AES256GCM_IDX] == NULL) ? SSL_AES256GCM:0;
a696 2
	*mac |= (ssl_digest_methods[SSL_MD_SHA256_IDX] == NULL) ? SSL_SHA256:0;
	*mac |= (ssl_digest_methods[SSL_MD_SHA384_IDX] == NULL) ? SSL_SHA384:0;
a726 3
#ifdef OPENSSL_FIPS
		    (!FIPS_mode() || (c->algo_strength & SSL_FIPS)) &&
#endif
a1425 3
#ifdef OPENSSL_FIPS
		if (curr->active && (!FIPS_mode() || curr->cipher->algo_strength & SSL_FIPS))
#else
a1426 1
#endif
a1482 2
	else if (alg_ssl & SSL_TLSV1_2)
		ver="TLSv1.2";
a1514 3
	case SSL_kSRP:
		kx="SRP";
		break;
a1576 6
	case SSL_AES128GCM:
		enc="AESGCM(128)";
		break;
	case SSL_AES256GCM:
		enc="AESGCM(256)";
		break;
a1598 9
	case SSL_SHA256:
		mac="SHA256";
		break;
	case SSL_SHA384:
		mac="SHA384";
		break;
	case SSL_AEAD:
		mac="AEAD";
		break;
a1653 5
	}

unsigned long SSL_CIPHER_get_id(const SSL_CIPHER *c)
	{
	return c->id;
@


1.1.1.15
log
@Import OpenSSL 1.0.1g
@
text
@a314 1
	{0,SSL_TXT_TLSV1_2,0, 0,0,0,0,SSL_TLSV1_2, 0,0,0,0},
d1153 1
a1153 1
				 (ch == '-') || (ch == '.'))
d1155 1
a1155 1
			while (	isalnum(ch) || (ch == '-') || (ch == '.'))
@


